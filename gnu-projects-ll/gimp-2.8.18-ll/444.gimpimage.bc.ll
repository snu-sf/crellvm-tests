; ModuleID = './app/core/gimpimage.bc'
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct._GInterfaceInfo = type { void (i8*, i8*)*, void (i8*, i8*)*, i8* }
%struct._GTypeInstance = type { %struct._GTypeClass* }
%struct._GTypeClass = type { i64 }
%struct._GimpImageClass = type { %struct._GimpViewableClass, void (%struct._GimpImage*)*, void (%struct._GimpImage*)*, void (%struct._GimpImage*)*, void (%struct._GimpImage*)*, void (%struct._GimpImage*)*, void (%struct._GimpImage*)*, void (%struct._GimpImage*, i32)*, void (%struct._GimpImage*, i32)*, void (%struct._GimpImage*)*, void (%struct._GimpImage*)*, void (%struct._GimpImage*, i32, i32, i32, i32)*, void (%struct._GimpImage*)*, void (%struct._GimpImage*)*, void (%struct._GimpImage*)*, void (%struct._GimpImage*, i32)*, void (%struct._GimpImage*, i32)*, void (%struct._GimpImage*, i8*)*, void (%struct._GimpImage*, i8*)*, void (%struct._GimpImage*, %struct._GimpGuide*)*, void (%struct._GimpImage*, %struct._GimpGuide*)*, void (%struct._GimpImage*, %struct._GimpGuide*)*, void (%struct._GimpImage*, %struct._GimpSamplePoint*)*, void (%struct._GimpImage*, %struct._GimpSamplePoint*)*, void (%struct._GimpImage*, %struct._GimpSamplePoint*)*, void (%struct._GimpImage*, i8*)*, void (%struct._GimpImage*, i8*)*, void (%struct._GimpImage*, i32)*, void (%struct._GimpImage*, i32, %struct._GimpUndo*)* }
%struct._GimpViewableClass = type { %struct._GimpObjectClass, i8*, i8*, void (%struct._GimpViewable*)*, void (%struct._GimpViewable*)*, i32 (%struct._GimpViewable*, i32*, i32*)*, void (%struct._GimpViewable*, i32, i32, i32, i32*, i32*)*, i32 (%struct._GimpViewable*, i32, i32, i32, i32*, i32*)*, %struct._TempBuf* (%struct._GimpViewable*, %struct._GimpContext*, i32, i32)*, %struct._TempBuf* (%struct._GimpViewable*, %struct._GimpContext*, i32, i32)*, %struct._GdkPixbuf* (%struct._GimpViewable*, %struct._GimpContext*, i32, i32)*, %struct._GdkPixbuf* (%struct._GimpViewable*, %struct._GimpContext*, i32, i32)*, i8* (%struct._GimpViewable*, i8**)*, %struct._GimpContainer* (%struct._GimpViewable*)*, void (%struct._GimpViewable*, i32)*, i32 (%struct._GimpViewable*)* }
%struct._GimpObjectClass = type { %struct._GObjectClass, void (%struct._GimpObject*)*, void (%struct._GimpObject*)*, i64 (%struct._GimpObject*, i64*)* }
%struct._GObjectClass = type { %struct._GTypeClass, %struct._GSList*, %struct._GObject* (i64, i32, %struct._GObjectConstructParam*)*, void (%struct._GObject*, i32, %struct._GValue*, %struct._GParamSpec*)*, void (%struct._GObject*, i32, %struct._GValue*, %struct._GParamSpec*)*, void (%struct._GObject*)*, void (%struct._GObject*)*, void (%struct._GObject*, i32, %struct._GParamSpec**)*, void (%struct._GObject*, %struct._GParamSpec*)*, void (%struct._GObject*)*, i64, [6 x i8*] }
%struct._GSList = type { i8*, %struct._GSList* }
%struct._GObject = type { %struct._GTypeInstance, i32, %struct._GData* }
%struct._GData = type opaque
%struct._GObjectConstructParam = type { %struct._GParamSpec*, %struct._GValue* }
%struct._GParamSpec = type { %struct._GTypeInstance, i8*, i32, i64, i64, i8*, i8*, %struct._GData*, i32, i32 }
%struct._GValue = type { i64, [2 x %union.anon] }
%union.anon = type { i64 }
%struct._GimpObject = type { %struct._GObject, %struct._GimpObjectPrivate* }
%struct._GimpObjectPrivate = type opaque
%struct._GimpViewable = type { %struct._GimpObject }
%struct._TempBuf = type { i32, i32, i32, i32, i32, i8* }
%struct._GimpContext = type { %struct._GimpViewable, %struct._Gimp*, %struct._GimpContext*, i32, i32, %struct._GimpImage*, i8*, %struct._GimpToolInfo*, i8*, %struct._GimpPaintInfo*, i8*, %struct._GimpRGB, %struct._GimpRGB, double, i32, %struct._GimpBrush*, i8*, %struct._GimpDynamics*, i8*, %struct._GimpPattern*, i8*, %struct._GimpGradient*, i8*, %struct._GimpPalette*, i8*, %struct._GimpToolPreset*, i8*, %struct._GimpFont*, i8*, %struct._GimpBuffer*, i8*, %struct._GimpImagefile*, i8*, %struct._GimpTemplate*, i8* }
%struct._Gimp = type { %struct._GimpObject, %struct._GimpCoreConfig*, %struct._GimpCoreConfig*, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct._GimpGui, i32, i32, i32, %struct._GList*, i32, %struct._GimpParasiteList*, %struct._GimpContainer*, %struct._GimpPaintInfo*, %struct._GimpModuleDB*, i32, %struct._GimpPlugInManager*, %struct._GimpContainer*, i32, i32, %struct._GimpIdTable*, %struct._GimpIdTable*, %struct._GimpContainer*, i32, %struct._GList*, %struct._GimpBuffer*, %struct._GimpContainer*, %struct._GimpContainer*, %struct._GimpDataFactory*, %struct._GimpDataFactory*, %struct._GimpDataFactory*, %struct._GimpDataFactory*, %struct._GimpDataFactory*, %struct._GimpDataFactory*, %struct._GimpTagCache*, %struct._GimpPDB*, %struct._GimpContainer*, %struct._GimpToolInfo*, %struct._GimpContainer*, %struct._GimpContainer*, %struct._GimpTemplate*, %struct._GList*, %struct._GimpContext*, %struct._GimpContext* }
%struct._GimpCoreConfig = type { %struct._GimpBaseConfig, i8*, i32, i32, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i32, i32, i32, i32, i32, i32, %struct._GimpTemplate*, %struct._GimpGrid*, i32, i64, i32, i32, i8*, i32, i32, i32, i64, %struct._GimpColorConfig*, i32, i32, %struct._GimpRGB, i32 }
%struct._GimpBaseConfig = type { %struct._GObject, i8*, i8*, i32, i64 }
%struct._GimpGrid = type { %struct._GimpObject, i32, %struct._GimpRGB, %struct._GimpRGB, double, double, i32, double, double, i32 }
%struct._GimpColorConfig = type { %struct._GObject, i32, i8*, i8*, i8*, i32, i8*, i32, i32, i8*, i32, %struct._GimpRGB, void ()*, void ()*, void ()*, void ()*, void ()*, void ()*, void ()*, void ()* }
%struct._GimpGui = type { void (%struct._Gimp*)*, void (%struct._Gimp*)*, void (%struct._Gimp*)*, void (%struct._Gimp*)*, void (%struct._Gimp*)*, void (%struct._Gimp*, %struct._GObject*, i32, i8*, i8*)*, void (%struct._Gimp*, %struct._GimpProgress*, i8*, i8*)*, i8* (%struct._Gimp*)*, i8* (%struct._Gimp*, i32, i32*)*, i32 (%struct._Gimp*)*, i8* (%struct._Gimp*)*, %struct._GimpObject* (%struct._Gimp*)*, %struct._GimpObject* (%struct._Gimp*)*, %struct._GimpObject* (%struct._Gimp*, i32)*, i32 (%struct._GimpObject*)*, i32 (%struct._GimpObject*)*, %struct._GimpObject* (%struct._Gimp*, %struct._GimpImage*, i32, double)*, void (%struct._GimpObject*)*, void (%struct._Gimp*, %struct._GimpImage*, %struct._GimpImage*)*, %struct._GimpProgress* (%struct._Gimp*, %struct._GimpObject*)*, void (%struct._Gimp*, %struct._GimpProgress*)*, i32 (%struct._Gimp*, %struct._GimpContext*, %struct._GimpProgress*, %struct._GimpContainer*, i8*, i8*, i8*, %struct.__va_list_tag*)*, i32 (%struct._Gimp*, %struct._GimpContainer*, i8*, i8*, %struct.__va_list_tag*)*, i32 (%struct._Gimp*, %struct._GimpContainer*, i8*)*, i32 (%struct._Gimp*, i8*, i8*)*, void (%struct._Gimp*)* }
%struct._GimpProgress = type opaque
%struct.__va_list_tag = type { i32, i32, i8*, i8* }
%struct._GimpParasiteList = type { %struct._GimpObject, %struct._GHashTable* }
%struct._GHashTable = type opaque
%struct._GimpModuleDB = type opaque
%struct._GimpPlugInManager = type opaque
%struct._GimpIdTable = type { %struct._GimpObject, %struct._GimpIdTablePriv* }
%struct._GimpIdTablePriv = type opaque
%struct._GimpDataFactory = type opaque
%struct._GimpTagCache = type opaque
%struct._GimpPDB = type opaque
%struct._GimpContainer = type { %struct._GimpObject, %struct._GimpContainerPriv* }
%struct._GimpContainerPriv = type opaque
%struct._GList = type { i8*, %struct._GList*, %struct._GList* }
%struct._GimpImage = type { %struct._GimpViewable, %struct._Gimp* }
%struct._GimpToolInfo = type opaque
%struct._GimpPaintInfo = type opaque
%struct._GimpRGB = type { double, double, double, double }
%struct._GimpBrush = type opaque
%struct._GimpDynamics = type opaque
%struct._GimpPattern = type opaque
%struct._GimpGradient = type opaque
%struct._GimpPalette = type opaque
%struct._GimpToolPreset = type opaque
%struct._GimpFont = type opaque
%struct._GimpBuffer = type opaque
%struct._GimpImagefile = type opaque
%struct._GimpTemplate = type { %struct._GimpViewable }
%struct._GdkPixbuf = type opaque
%struct._GimpGuide = type { %struct._GObject, i32, i32, i32 }
%struct._GimpSamplePoint = type { i32, i32, i32, i32 }
%struct._GimpUndo = type { %struct._GimpViewable, %struct._GimpImage*, i32, i32, i32, %struct._TempBuf*, i32 }
%struct._GimpImagePrivate = type { i32, %struct._GimpPlugInProcedure*, %struct._GimpPlugInProcedure*, %struct._GimpPlugInProcedure*, i8*, i8*, i32, i32, double, double, i32, i32, i8*, i32, %struct._GimpPalette*, i32, i32, i32, i32, i32, i32, i32, %struct._GimpProjection*, %struct._GeglNode*, %struct._GList*, %struct._GimpGrid*, %struct._GList*, %struct._GimpItemTree*, %struct._GimpItemTree*, %struct._GimpItemTree*, %struct._GSList*, i32, i32, i32, %struct._GimpLayer*, %struct._GimpChannel*, %struct._GimpParasiteList*, [4 x i32], [4 x i32], i32, i32, %struct._GimpRGB, %struct._GimpUndoStack*, %struct._GimpUndoStack*, i32, i32, %struct._TempBuf*, %struct._GimpImageFlushAccumulator }
%struct._GimpPlugInProcedure = type opaque
%struct._GimpProjection = type { %struct._GimpObject, %struct._GimpProjectable*, %struct._TilePyramid*, %struct._GeglNode*, %struct._GeglNode*, %struct._GeglProcessor*, %struct._GSList*, %struct._GimpProjectionIdleRender, i32, i32, i32 }
%struct._GimpProjectable = type opaque
%struct._TilePyramid = type opaque
%struct._GeglProcessor = type opaque
%struct._GimpProjectionIdleRender = type { i32, i32, i32, i32, i32, i32, i32, %struct._GSList* }
%struct._GeglNode = type opaque
%struct._GimpItemTree = type { %struct._GimpObject, %struct._GimpContainer* }
%struct._GimpLayer = type { %struct._GimpDrawable, double, i32, i32, %struct._GimpLayerMask*, %struct._GeglNode*, %struct.anon }
%struct._GimpDrawable = type { %struct._GimpItem, %struct._GimpDrawablePrivate* }
%struct._GimpItem = type { %struct._GimpViewable }
%struct._GimpDrawablePrivate = type opaque
%struct._GimpLayerMask = type { %struct._GimpChannel, %struct._GimpLayer*, i32, i32, i32 }
%struct._GimpChannel = type { %struct._GimpDrawable, %struct._GimpRGB, i32, %struct._GeglNode*, %struct._GeglNode*, %struct._GeglNode*, i32, %struct._BoundSeg*, %struct._BoundSeg*, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct._BoundSeg = type opaque
%struct.anon = type { %struct._GimpDrawable*, i32, %struct._BoundSeg*, i32 }
%struct._GimpUndoStack = type { %struct._GimpUndo, %struct._GimpContainer* }
%struct._GimpImageFlushAccumulator = type { i32, i32, i32, i32 }
%struct._GClosure = type { i32, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)*, i8*, %struct._GClosureNotifyData* }
%struct._GClosureNotifyData = type { i8*, {}* }
%struct._GimpColorManagedInterface = type { %struct._GTypeInterface, i8* (%struct._GimpColorManaged*, i64*)*, void (%struct._GimpColorManaged*)* }
%struct._GTypeInterface = type { i64, i64 }
%struct._GimpColorManaged = type opaque
%struct._GimpProjectableInterface = type { %struct._GTypeInterface, void (%struct._GimpProjectable*, i32, i32, i32, i32)*, void (%struct._GimpProjectable*, i32)*, void (%struct._GimpProjectable*)*, %struct._GimpImage* (%struct._GimpProjectable*)*, i32 (%struct._GimpProjectable*)*, void (%struct._GimpProjectable*, i32*, i32*)*, void (%struct._GimpProjectable*, i32*, i32*)*, %struct._GeglNode* (%struct._GimpProjectable*)*, void (%struct._GimpProjectable*)*, %struct._GList* (%struct._GimpProjectable*)*, %struct._GList* (%struct._GimpProjectable*)* }
%struct._GError = type { i32, i32, i8* }
%struct._GimpItemStack = type { %struct._GimpList }
%struct._GimpList = type { %struct._GimpContainer, %struct._GList*, i32, i32 (i8*, i8*)*, i32 }
%struct._GimpParasite = type { i8*, i32, i32, i8* }
%struct._GimpVectors = type { %struct._GimpItem, %struct._GList*, i32, i32, double, %struct.cairo_path*, i32, i32, double, double, double, double }
%struct.cairo_path = type { i32, %union._cairo_path_data_t*, i32 }
%union._cairo_path_data_t = type { %struct.anon.1 }
%struct.anon.1 = type { double, double }
%struct._GimpItemClass = type { %struct._GimpViewableClass, void (%struct._GimpItem*)*, void (%struct._GimpItem*)*, void (%struct._GimpItem*)*, void (%struct._GimpItem*)*, void (%struct._GimpItem*)*, i32 (%struct._GimpItem*)*, i32 (%struct._GimpItem*)*, %struct._GimpItemTree* (%struct._GimpItem*)*, %struct._GimpItem* (%struct._GimpItem*, i64)*, void (%struct._GimpItem*, %struct._GimpImage*)*, i32 (%struct._GimpItem*, i8*, i8*, %struct._GError**)*, void (%struct._GimpItem*, i32, i32, i32)*, void (%struct._GimpItem*, i32, i32, i32, i32, i32, %struct._GimpProgress*)*, void (%struct._GimpItem*, %struct._GimpContext*, i32, i32, i32, i32)*, void (%struct._GimpItem*, %struct._GimpContext*, i32, double, i32)*, void (%struct._GimpItem*, %struct._GimpContext*, i32, double, double, i32)*, void (%struct._GimpItem*, %struct._GimpContext*, %struct._GimpMatrix3*, i32, i32, i32, i32, %struct._GimpProgress*)*, i32 (%struct._GimpItem*, %struct._GimpDrawable*, %struct._GimpStrokeOptions*, i32, %struct._GimpProgress*, %struct._GError**)*, void (%struct._GimpItem*, i32, i32, i32, double, double)*, %struct._GeglNode* (%struct._GimpItem*)*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8* }
%struct._GimpMatrix3 = type { [3 x [3 x double]] }
%struct._GimpStrokeOptions = type opaque
%struct._GimpCoords = type { double, double, double, double, double, double, double, double }
%struct._GimpPickable = type opaque
%struct._GSignalInvocationHint = type { i32, i32, i32 }
%struct._GimpConfig = type opaque
%struct._GimpDrawableStack = type { %struct._GimpItemStack, %struct._GeglNode* }

@gimp_image_get_type.g_define_type_id__volatile = internal global i64 0, align 8
@.str = private unnamed_addr constant [10 x i8] c"GimpImage\00", align 1
@gimp_image_get_type.g_implement_interface_info = internal constant %struct._GInterfaceInfo { void (i8*, i8*)* bitcast (void (%struct._GimpColorManagedInterface*)* @gimp_color_managed_iface_init to void (i8*, i8*)*), void (i8*, i8*)* null, i8* null }, align 8
@gimp_image_get_type.g_implement_interface_info.1 = internal constant %struct._GInterfaceInfo { void (i8*, i8*)* bitcast (void (%struct._GimpProjectableInterface*)* @gimp_projectable_iface_init to void (i8*, i8*)*), void (i8*, i8*)* null, i8* null }, align 8
@.str.2 = private unnamed_addr constant [10 x i8] c"Gimp-Core\00", align 1
@__func__.gimp_image_new = private unnamed_addr constant [15 x i8] c"gimp_image_new\00", align 1
@.str.3 = private unnamed_addr constant [20 x i8] c"GIMP_IS_GIMP (gimp)\00", align 1
@.str.4 = private unnamed_addr constant [5 x i8] c"gimp\00", align 1
@.str.5 = private unnamed_addr constant [6 x i8] c"width\00", align 1
@.str.6 = private unnamed_addr constant [7 x i8] c"height\00", align 1
@.str.7 = private unnamed_addr constant [10 x i8] c"base-type\00", align 1
@__func__.gimp_image_base_type = private unnamed_addr constant [21 x i8] c"gimp_image_base_type\00", align 1
@.str.8 = private unnamed_addr constant [22 x i8] c"GIMP_IS_IMAGE (image)\00", align 1
@__func__.gimp_image_base_type_with_alpha = private unnamed_addr constant [32 x i8] c"gimp_image_base_type_with_alpha\00", align 1
@valid_combinations = internal constant [6 x [5 x i32]] [[5 x i32] [i32 -1, i32 -1, i32 -1, i32 8, i32 9], [5 x i32] [i32 -1, i32 -1, i32 -1, i32 10, i32 11], [5 x i32] [i32 -1, i32 8, i32 9, i32 -1, i32 -1], [5 x i32] [i32 -1, i32 10, i32 11, i32 -1, i32 -1], [5 x i32] [i32 -1, i32 1, i32 2, i32 -1, i32 -1], [5 x i32] [i32 -1, i32 -1, i32 3, i32 -1, i32 -1]], align 16
@__func__.gimp_image_get_ID = private unnamed_addr constant [18 x i8] c"gimp_image_get_ID\00", align 1
@__func__.gimp_image_get_by_ID = private unnamed_addr constant [21 x i8] c"gimp_image_get_by_ID\00", align 1
@__func__.gimp_image_set_uri = private unnamed_addr constant [19 x i8] c"gimp_image_set_uri\00", align 1
@.str.9 = private unnamed_addr constant [9 x i8] c"Untitled\00", align 1
@__func__.gimp_image_get_uri_or_untitled = private unnamed_addr constant [31 x i8] c"gimp_image_get_uri_or_untitled\00", align 1
@__func__.gimp_image_get_uri = private unnamed_addr constant [19 x i8] c"gimp_image_get_uri\00", align 1
@__func__.gimp_image_set_filename = private unnamed_addr constant [24 x i8] c"gimp_image_set_filename\00", align 1
@__func__.gimp_image_get_imported_uri = private unnamed_addr constant [28 x i8] c"gimp_image_get_imported_uri\00", align 1
@.str.10 = private unnamed_addr constant [28 x i8] c"gimp-file-import-source-uri\00", align 1
@__func__.gimp_image_get_exported_uri = private unnamed_addr constant [28 x i8] c"gimp_image_get_exported_uri\00", align 1
@.str.11 = private unnamed_addr constant [21 x i8] c"gimp-file-export-uri\00", align 1
@__func__.gimp_image_get_save_a_copy_uri = private unnamed_addr constant [31 x i8] c"gimp_image_get_save_a_copy_uri\00", align 1
@.str.12 = private unnamed_addr constant [26 x i8] c"gimp-file-save-a-copy-uri\00", align 1
@__func__.gimp_image_get_any_uri = private unnamed_addr constant [23 x i8] c"gimp_image_get_any_uri\00", align 1
@__func__.gimp_image_set_imported_uri = private unnamed_addr constant [28 x i8] c"gimp_image_set_imported_uri\00", align 1
@__func__.gimp_image_set_exported_uri = private unnamed_addr constant [28 x i8] c"gimp_image_set_exported_uri\00", align 1
@__func__.gimp_image_set_save_a_copy_uri = private unnamed_addr constant [31 x i8] c"gimp_image_set_save_a_copy_uri\00", align 1
@__func__.gimp_image_get_filename = private unnamed_addr constant [24 x i8] c"gimp_image_get_filename\00", align 1
@__func__.gimp_image_get_display_name = private unnamed_addr constant [28 x i8] c"gimp_image_get_display_name\00", align 1
@__func__.gimp_image_get_display_path = private unnamed_addr constant [28 x i8] c"gimp_image_get_display_path\00", align 1
@__func__.gimp_image_set_load_proc = private unnamed_addr constant [25 x i8] c"gimp_image_set_load_proc\00", align 1
@__func__.gimp_image_get_load_proc = private unnamed_addr constant [25 x i8] c"gimp_image_get_load_proc\00", align 1
@__func__.gimp_image_set_save_proc = private unnamed_addr constant [25 x i8] c"gimp_image_set_save_proc\00", align 1
@__func__.gimp_image_get_save_proc = private unnamed_addr constant [25 x i8] c"gimp_image_get_save_proc\00", align 1
@__func__.gimp_image_set_export_proc = private unnamed_addr constant [27 x i8] c"gimp_image_set_export_proc\00", align 1
@__func__.gimp_image_get_export_proc = private unnamed_addr constant [27 x i8] c"gimp_image_get_export_proc\00", align 1
@__func__.gimp_image_set_resolution = private unnamed_addr constant [26 x i8] c"gimp_image_set_resolution\00", align 1
@.str.13 = private unnamed_addr constant [34 x i8] c"undo-type\04Change Image Resolution\00", align 1
@__func__.gimp_image_get_resolution = private unnamed_addr constant [26 x i8] c"gimp_image_get_resolution\00", align 1
@.str.14 = private unnamed_addr constant [43 x i8] c"xresolution != NULL && yresolution != NULL\00", align 1
@__func__.gimp_image_resolution_changed = private unnamed_addr constant [30 x i8] c"gimp_image_resolution_changed\00", align 1
@gimp_image_signals = internal global [28 x i32] zeroinitializer, align 16
@__func__.gimp_image_set_unit = private unnamed_addr constant [20 x i8] c"gimp_image_set_unit\00", align 1
@.str.15 = private unnamed_addr constant [23 x i8] c"unit > GIMP_UNIT_PIXEL\00", align 1
@.str.16 = private unnamed_addr constant [28 x i8] c"undo-type\04Change Image Unit\00", align 1
@__func__.gimp_image_get_unit = private unnamed_addr constant [20 x i8] c"gimp_image_get_unit\00", align 1
@__func__.gimp_image_unit_changed = private unnamed_addr constant [24 x i8] c"gimp_image_unit_changed\00", align 1
@__func__.gimp_image_get_width = private unnamed_addr constant [21 x i8] c"gimp_image_get_width\00", align 1
@__func__.gimp_image_get_height = private unnamed_addr constant [22 x i8] c"gimp_image_get_height\00", align 1
@__func__.gimp_image_has_alpha = private unnamed_addr constant [21 x i8] c"gimp_image_has_alpha\00", align 1
@__func__.gimp_image_is_empty = private unnamed_addr constant [20 x i8] c"gimp_image_is_empty\00", align 1
@__func__.gimp_image_set_floating_selection = private unnamed_addr constant [34 x i8] c"gimp_image_set_floating_selection\00", align 1
@.str.17 = private unnamed_addr constant [53 x i8] c"floating_sel == NULL || GIMP_IS_LAYER (floating_sel)\00", align 1
@__func__.gimp_image_get_floating_selection = private unnamed_addr constant [34 x i8] c"gimp_image_get_floating_selection\00", align 1
@__func__.gimp_image_floating_selection_changed = private unnamed_addr constant [38 x i8] c"gimp_image_floating_selection_changed\00", align 1
@__func__.gimp_image_get_mask = private unnamed_addr constant [20 x i8] c"gimp_image_get_mask\00", align 1
@__func__.gimp_image_mask_changed = private unnamed_addr constant [24 x i8] c"gimp_image_mask_changed\00", align 1
@__func__.gimp_image_take_mask = private unnamed_addr constant [21 x i8] c"gimp_image_take_mask\00", align 1
@.str.18 = private unnamed_addr constant [25 x i8] c"GIMP_IS_SELECTION (mask)\00", align 1
@.str.19 = private unnamed_addr constant [7 x i8] c"update\00", align 1
@__func__.gimp_image_get_component_index = private unnamed_addr constant [31 x i8] c"gimp_image_get_component_index\00", align 1
@__func__.gimp_image_set_component_active = private unnamed_addr constant [32 x i8] c"gimp_image_set_component_active\00", align 1
@__func__.gimp_image_get_component_active = private unnamed_addr constant [32 x i8] c"gimp_image_get_component_active\00", align 1
@__func__.gimp_image_get_active_array = private unnamed_addr constant [28 x i8] c"gimp_image_get_active_array\00", align 1
@.str.20 = private unnamed_addr constant [19 x i8] c"components != NULL\00", align 1
@__func__.gimp_image_set_component_visible = private unnamed_addr constant [33 x i8] c"gimp_image_set_component_visible\00", align 1
@__func__.gimp_image_get_component_visible = private unnamed_addr constant [33 x i8] c"gimp_image_get_component_visible\00", align 1
@__func__.gimp_image_get_visible_array = private unnamed_addr constant [29 x i8] c"gimp_image_get_visible_array\00", align 1
@__func__.gimp_image_mode_changed = private unnamed_addr constant [24 x i8] c"gimp_image_mode_changed\00", align 1
@__func__.gimp_image_alpha_changed = private unnamed_addr constant [25 x i8] c"gimp_image_alpha_changed\00", align 1
@__func__.gimp_image_invalidate = private unnamed_addr constant [22 x i8] c"gimp_image_invalidate\00", align 1
@__func__.gimp_image_guide_added = private unnamed_addr constant [23 x i8] c"gimp_image_guide_added\00", align 1
@.str.21 = private unnamed_addr constant [22 x i8] c"GIMP_IS_GUIDE (guide)\00", align 1
@__func__.gimp_image_guide_removed = private unnamed_addr constant [25 x i8] c"gimp_image_guide_removed\00", align 1
@__func__.gimp_image_guide_moved = private unnamed_addr constant [23 x i8] c"gimp_image_guide_moved\00", align 1
@__func__.gimp_image_sample_point_added = private unnamed_addr constant [30 x i8] c"gimp_image_sample_point_added\00", align 1
@.str.22 = private unnamed_addr constant [21 x i8] c"sample_point != NULL\00", align 1
@__func__.gimp_image_sample_point_removed = private unnamed_addr constant [32 x i8] c"gimp_image_sample_point_removed\00", align 1
@__func__.gimp_image_sample_point_moved = private unnamed_addr constant [30 x i8] c"gimp_image_sample_point_moved\00", align 1
@__func__.gimp_image_size_changed_detailed = private unnamed_addr constant [33 x i8] c"gimp_image_size_changed_detailed\00", align 1
@__func__.gimp_image_colormap_changed = private unnamed_addr constant [28 x i8] c"gimp_image_colormap_changed\00", align 1
@.str.23 = private unnamed_addr constant [76 x i8] c"color_index >= -1 && color_index < GIMP_IMAGE_GET_PRIVATE (image)->n_colors\00", align 1
@__func__.gimp_image_selection_invalidate = private unnamed_addr constant [32 x i8] c"gimp_image_selection_invalidate\00", align 1
@__func__.gimp_image_quick_mask_changed = private unnamed_addr constant [30 x i8] c"gimp_image_quick_mask_changed\00", align 1
@__func__.gimp_image_undo_event = private unnamed_addr constant [22 x i8] c"gimp_image_undo_event\00", align 1
@.str.24 = private unnamed_addr constant [156 x i8] c"((event == GIMP_UNDO_EVENT_UNDO_FREE || event == GIMP_UNDO_EVENT_UNDO_FREEZE || event == GIMP_UNDO_EVENT_UNDO_THAW) && undo == NULL) || GIMP_IS_UNDO (undo)\00", align 1
@__func__.gimp_image_dirty = private unnamed_addr constant [17 x i8] c"gimp_image_dirty\00", align 1
@__func__.gimp_image_clean = private unnamed_addr constant [17 x i8] c"gimp_image_clean\00", align 1
@__func__.gimp_image_clean_all = private unnamed_addr constant [21 x i8] c"gimp_image_clean_all\00", align 1
@__func__.gimp_image_export_clean_all = private unnamed_addr constant [28 x i8] c"gimp_image_export_clean_all\00", align 1
@__func__.gimp_image_is_dirty = private unnamed_addr constant [20 x i8] c"gimp_image_is_dirty\00", align 1
@__func__.gimp_image_is_export_dirty = private unnamed_addr constant [27 x i8] c"gimp_image_is_export_dirty\00", align 1
@__func__.gimp_image_get_dirty_time = private unnamed_addr constant [26 x i8] c"gimp_image_get_dirty_time\00", align 1
@__func__.gimp_image_saved = private unnamed_addr constant [17 x i8] c"gimp_image_saved\00", align 1
@.str.25 = private unnamed_addr constant [12 x i8] c"uri != NULL\00", align 1
@__func__.gimp_image_exported = private unnamed_addr constant [20 x i8] c"gimp_image_exported\00", align 1
@__func__.gimp_image_flush = private unnamed_addr constant [17 x i8] c"gimp_image_flush\00", align 1
@__func__.gimp_image_get_display_count = private unnamed_addr constant [29 x i8] c"gimp_image_get_display_count\00", align 1
@__func__.gimp_image_inc_display_count = private unnamed_addr constant [29 x i8] c"gimp_image_inc_display_count\00", align 1
@__func__.gimp_image_dec_display_count = private unnamed_addr constant [29 x i8] c"gimp_image_dec_display_count\00", align 1
@__func__.gimp_image_get_instance_count = private unnamed_addr constant [30 x i8] c"gimp_image_get_instance_count\00", align 1
@__func__.gimp_image_inc_instance_count = private unnamed_addr constant [30 x i8] c"gimp_image_inc_instance_count\00", align 1
@__func__.gimp_image_get_foreground = private unnamed_addr constant [26 x i8] c"gimp_image_get_foreground\00", align 1
@.str.26 = private unnamed_addr constant [26 x i8] c"GIMP_IS_CONTEXT (context)\00", align 1
@.str.27 = private unnamed_addr constant [11 x i8] c"fg != NULL\00", align 1
@__func__.gimp_image_get_background = private unnamed_addr constant [26 x i8] c"gimp_image_get_background\00", align 1
@.str.28 = private unnamed_addr constant [11 x i8] c"bg != NULL\00", align 1
@__func__.gimp_image_get_color = private unnamed_addr constant [21 x i8] c"gimp_image_get_color\00", align 1
@.str.29 = private unnamed_addr constant [26 x i8] c"GIMP_IS_IMAGE (src_image)\00", align 1
@__func__.gimp_image_transform_rgb = private unnamed_addr constant [25 x i8] c"gimp_image_transform_rgb\00", align 1
@.str.30 = private unnamed_addr constant [27 x i8] c"GIMP_IS_IMAGE (dest_image)\00", align 1
@.str.31 = private unnamed_addr constant [12 x i8] c"rgb != NULL\00", align 1
@.str.32 = private unnamed_addr constant [14 x i8] c"color != NULL\00", align 1
@__func__.gimp_image_transform_color = private unnamed_addr constant [27 x i8] c"gimp_image_transform_color\00", align 1
@.str.33 = private unnamed_addr constant [25 x i8] c"src_type != GIMP_INDEXED\00", align 1
@__func__.gimp_image_transform_temp_buf = private unnamed_addr constant [30 x i8] c"gimp_image_transform_temp_buf\00", align 1
@.str.34 = private unnamed_addr constant [24 x i8] c"GIMP_IMAGE (dest_image)\00", align 1
@.str.35 = private unnamed_addr constant [17 x i8] c"temp_buf != NULL\00", align 1
@.str.36 = private unnamed_addr constant [16 x i8] c"new_buf != NULL\00", align 1
@__func__.gimp_image_parasite_find = private unnamed_addr constant [25 x i8] c"gimp_image_parasite_find\00", align 1
@__func__.gimp_image_parasite_list = private unnamed_addr constant [25 x i8] c"gimp_image_parasite_list\00", align 1
@__func__.gimp_image_parasite_attach = private unnamed_addr constant [27 x i8] c"gimp_image_parasite_attach\00", align 1
@.str.37 = private unnamed_addr constant [17 x i8] c"parasite != NULL\00", align 1
@.str.38 = private unnamed_addr constant [35 x i8] c"undo-type\04Attach Parasite to Image\00", align 1
@.str.39 = private unnamed_addr constant [12 x i8] c"icc-profile\00", align 1
@__func__.gimp_image_parasite_detach = private unnamed_addr constant [27 x i8] c"gimp_image_parasite_detach\00", align 1
@.str.40 = private unnamed_addr constant [13 x i8] c"name != NULL\00", align 1
@.str.41 = private unnamed_addr constant [37 x i8] c"undo-type\04Remove Parasite from Image\00", align 1
@__func__.gimp_image_get_new_tattoo = private unnamed_addr constant [26 x i8] c"gimp_image_get_new_tattoo\00", align 1
@.str.42 = private unnamed_addr constant [47 x i8] c"%s: Tattoo state corrupted (integer overflow).\00", align 1
@__func__.gimp_image_get_tattoo_state = private unnamed_addr constant [28 x i8] c"gimp_image_get_tattoo_state\00", align 1
@__func__.gimp_image_set_tattoo_state = private unnamed_addr constant [28 x i8] c"gimp_image_set_tattoo_state\00", align 1
@__func__.gimp_image_get_projection = private unnamed_addr constant [26 x i8] c"gimp_image_get_projection\00", align 1
@__func__.gimp_image_get_layer_tree = private unnamed_addr constant [26 x i8] c"gimp_image_get_layer_tree\00", align 1
@__func__.gimp_image_get_channel_tree = private unnamed_addr constant [28 x i8] c"gimp_image_get_channel_tree\00", align 1
@__func__.gimp_image_get_vectors_tree = private unnamed_addr constant [28 x i8] c"gimp_image_get_vectors_tree\00", align 1
@__func__.gimp_image_get_layers = private unnamed_addr constant [22 x i8] c"gimp_image_get_layers\00", align 1
@__func__.gimp_image_get_channels = private unnamed_addr constant [24 x i8] c"gimp_image_get_channels\00", align 1
@__func__.gimp_image_get_vectors = private unnamed_addr constant [23 x i8] c"gimp_image_get_vectors\00", align 1
@__func__.gimp_image_get_n_layers = private unnamed_addr constant [24 x i8] c"gimp_image_get_n_layers\00", align 1
@__func__.gimp_image_get_n_channels = private unnamed_addr constant [26 x i8] c"gimp_image_get_n_channels\00", align 1
@__func__.gimp_image_get_n_vectors = private unnamed_addr constant [25 x i8] c"gimp_image_get_n_vectors\00", align 1
@__func__.gimp_image_get_layer_iter = private unnamed_addr constant [26 x i8] c"gimp_image_get_layer_iter\00", align 1
@__func__.gimp_image_get_channel_iter = private unnamed_addr constant [28 x i8] c"gimp_image_get_channel_iter\00", align 1
@__func__.gimp_image_get_vectors_iter = private unnamed_addr constant [28 x i8] c"gimp_image_get_vectors_iter\00", align 1
@__func__.gimp_image_get_layer_list = private unnamed_addr constant [26 x i8] c"gimp_image_get_layer_list\00", align 1
@__func__.gimp_image_get_channel_list = private unnamed_addr constant [28 x i8] c"gimp_image_get_channel_list\00", align 1
@__func__.gimp_image_get_vectors_list = private unnamed_addr constant [28 x i8] c"gimp_image_get_vectors_list\00", align 1
@__func__.gimp_image_get_active_drawable = private unnamed_addr constant [31 x i8] c"gimp_image_get_active_drawable\00", align 1
@__func__.gimp_image_get_active_layer = private unnamed_addr constant [28 x i8] c"gimp_image_get_active_layer\00", align 1
@__func__.gimp_image_get_active_channel = private unnamed_addr constant [30 x i8] c"gimp_image_get_active_channel\00", align 1
@__func__.gimp_image_get_active_vectors = private unnamed_addr constant [30 x i8] c"gimp_image_get_active_vectors\00", align 1
@__func__.gimp_image_set_active_layer = private unnamed_addr constant [28 x i8] c"gimp_image_set_active_layer\00", align 1
@.str.43 = private unnamed_addr constant [39 x i8] c"layer == NULL || GIMP_IS_LAYER (layer)\00", align 1
@.str.44 = private unnamed_addr constant [113 x i8] c"layer == NULL || (gimp_item_is_attached (GIMP_ITEM (layer)) && gimp_item_get_image (GIMP_ITEM (layer)) == image)\00", align 1
@__func__.gimp_image_set_active_channel = private unnamed_addr constant [30 x i8] c"gimp_image_set_active_channel\00", align 1
@.str.45 = private unnamed_addr constant [45 x i8] c"channel == NULL || GIMP_IS_CHANNEL (channel)\00", align 1
@.str.46 = private unnamed_addr constant [119 x i8] c"channel == NULL || (gimp_item_is_attached (GIMP_ITEM (channel)) && gimp_item_get_image (GIMP_ITEM (channel)) == image)\00", align 1
@__func__.gimp_image_unset_active_channel = private unnamed_addr constant [32 x i8] c"gimp_image_unset_active_channel\00", align 1
@__func__.gimp_image_set_active_vectors = private unnamed_addr constant [30 x i8] c"gimp_image_set_active_vectors\00", align 1
@.str.47 = private unnamed_addr constant [45 x i8] c"vectors == NULL || GIMP_IS_VECTORS (vectors)\00", align 1
@.str.48 = private unnamed_addr constant [119 x i8] c"vectors == NULL || (gimp_item_is_attached (GIMP_ITEM (vectors)) && gimp_item_get_image (GIMP_ITEM (vectors)) == image)\00", align 1
@__func__.gimp_image_get_layer_by_tattoo = private unnamed_addr constant [31 x i8] c"gimp_image_get_layer_by_tattoo\00", align 1
@__func__.gimp_image_get_channel_by_tattoo = private unnamed_addr constant [33 x i8] c"gimp_image_get_channel_by_tattoo\00", align 1
@__func__.gimp_image_get_vectors_by_tattoo = private unnamed_addr constant [33 x i8] c"gimp_image_get_vectors_by_tattoo\00", align 1
@__func__.gimp_image_get_layer_by_name = private unnamed_addr constant [29 x i8] c"gimp_image_get_layer_by_name\00", align 1
@__func__.gimp_image_get_channel_by_name = private unnamed_addr constant [31 x i8] c"gimp_image_get_channel_by_name\00", align 1
@__func__.gimp_image_get_vectors_by_name = private unnamed_addr constant [31 x i8] c"gimp_image_get_vectors_by_name\00", align 1
@__func__.gimp_image_reorder_item = private unnamed_addr constant [24 x i8] c"gimp_image_reorder_item\00", align 1
@.str.49 = private unnamed_addr constant [20 x i8] c"GIMP_IS_ITEM (item)\00", align 1
@.str.50 = private unnamed_addr constant [36 x i8] c"gimp_item_get_image (item) == image\00", align 1
@.str.51 = private unnamed_addr constant [13 x i8] c"tree != NULL\00", align 1
@__func__.gimp_image_raise_item = private unnamed_addr constant [22 x i8] c"gimp_image_raise_item\00", align 1
@.str.52 = private unnamed_addr constant [32 x i8] c"error == NULL || *error == NULL\00", align 1
@.str.53 = private unnamed_addr constant [12 x i8] c"index != -1\00", align 1
@__func__.gimp_image_raise_item_to_top = private unnamed_addr constant [29 x i8] c"gimp_image_raise_item_to_top\00", align 1
@__func__.gimp_image_lower_item = private unnamed_addr constant [22 x i8] c"gimp_image_lower_item\00", align 1
@.str.54 = private unnamed_addr constant [18 x i8] c"container != NULL\00", align 1
@__func__.gimp_image_lower_item_to_bottom = private unnamed_addr constant [32 x i8] c"gimp_image_lower_item_to_bottom\00", align 1
@__func__.gimp_image_add_layer = private unnamed_addr constant [21 x i8] c"gimp_image_add_layer\00", align 1
@.str.55 = private unnamed_addr constant [20 x i8] c"undo-type\04Add Layer\00", align 1
@__func__.gimp_image_remove_layer = private unnamed_addr constant [24 x i8] c"gimp_image_remove_layer\00", align 1
@.str.56 = private unnamed_addr constant [22 x i8] c"GIMP_IS_LAYER (layer)\00", align 1
@.str.57 = private unnamed_addr constant [42 x i8] c"gimp_item_is_attached (GIMP_ITEM (layer))\00", align 1
@.str.58 = private unnamed_addr constant [49 x i8] c"gimp_item_get_image (GIMP_ITEM (layer)) == image\00", align 1
@.str.59 = private unnamed_addr constant [128 x i8] c"%s() was called from an undo function while the layer had a floating selection. Please report this at http://www.gimp.org/bugs/\00", align 1
@.str.60 = private unnamed_addr constant [23 x i8] c"undo-type\04Remove Layer\00", align 1
@.str.61 = private unnamed_addr constant [36 x i8] c"undo-type\04Remove Floating Selection\00", align 1
@__func__.gimp_image_add_layers = private unnamed_addr constant [22 x i8] c"gimp_image_add_layers\00", align 1
@.str.62 = private unnamed_addr constant [15 x i8] c"layers != NULL\00", align 1
@__func__.gimp_image_add_channel = private unnamed_addr constant [23 x i8] c"gimp_image_add_channel\00", align 1
@.str.63 = private unnamed_addr constant [22 x i8] c"undo-type\04Add Channel\00", align 1
@__func__.gimp_image_remove_channel = private unnamed_addr constant [26 x i8] c"gimp_image_remove_channel\00", align 1
@.str.64 = private unnamed_addr constant [26 x i8] c"GIMP_IS_CHANNEL (channel)\00", align 1
@.str.65 = private unnamed_addr constant [44 x i8] c"gimp_item_is_attached (GIMP_ITEM (channel))\00", align 1
@.str.66 = private unnamed_addr constant [51 x i8] c"gimp_item_get_image (GIMP_ITEM (channel)) == image\00", align 1
@.str.67 = private unnamed_addr constant [130 x i8] c"%s() was called from an undo function while the channel had a floating selection. Please report this at http://www.gimp.org/bugs/\00", align 1
@.str.68 = private unnamed_addr constant [25 x i8] c"undo-type\04Remove Channel\00", align 1
@__func__.gimp_image_add_vectors = private unnamed_addr constant [23 x i8] c"gimp_image_add_vectors\00", align 1
@.str.69 = private unnamed_addr constant [19 x i8] c"undo-type\04Add Path\00", align 1
@__func__.gimp_image_remove_vectors = private unnamed_addr constant [26 x i8] c"gimp_image_remove_vectors\00", align 1
@.str.70 = private unnamed_addr constant [26 x i8] c"GIMP_IS_VECTORS (vectors)\00", align 1
@.str.71 = private unnamed_addr constant [44 x i8] c"gimp_item_is_attached (GIMP_ITEM (vectors))\00", align 1
@.str.72 = private unnamed_addr constant [51 x i8] c"gimp_item_get_image (GIMP_ITEM (vectors)) == image\00", align 1
@.str.73 = private unnamed_addr constant [22 x i8] c"undo-type\04Remove Path\00", align 1
@__func__.gimp_image_coords_in_active_pickable = private unnamed_addr constant [37 x i8] c"gimp_image_coords_in_active_pickable\00", align 1
@__func__.gimp_image_invalidate_previews = private unnamed_addr constant [31 x i8] c"gimp_image_invalidate_previews\00", align 1
@gimp_image_parent_class = internal global i8* null, align 8
@GimpImage_private_offset = internal global i32 0, align 4
@.str.74 = private unnamed_addr constant [13 x i8] c"mode-changed\00", align 1
@.str.75 = private unnamed_addr constant [14 x i8] c"alpha-changed\00", align 1
@.str.76 = private unnamed_addr constant [27 x i8] c"floating-selection-changed\00", align 1
@.str.77 = private unnamed_addr constant [21 x i8] c"active-layer-changed\00", align 1
@.str.78 = private unnamed_addr constant [23 x i8] c"active-channel-changed\00", align 1
@.str.79 = private unnamed_addr constant [23 x i8] c"active-vectors-changed\00", align 1
@.str.80 = private unnamed_addr constant [29 x i8] c"component-visibility-changed\00", align 1
@.str.81 = private unnamed_addr constant [25 x i8] c"component-active-changed\00", align 1
@.str.82 = private unnamed_addr constant [13 x i8] c"mask-changed\00", align 1
@.str.83 = private unnamed_addr constant [19 x i8] c"resolution-changed\00", align 1
@.str.84 = private unnamed_addr constant [22 x i8] c"size-changed-detailed\00", align 1
@.str.85 = private unnamed_addr constant [13 x i8] c"unit-changed\00", align 1
@.str.86 = private unnamed_addr constant [19 x i8] c"quick-mask-changed\00", align 1
@.str.87 = private unnamed_addr constant [21 x i8] c"selection-invalidate\00", align 1
@.str.88 = private unnamed_addr constant [6 x i8] c"clean\00", align 1
@.str.89 = private unnamed_addr constant [6 x i8] c"dirty\00", align 1
@.str.90 = private unnamed_addr constant [6 x i8] c"saved\00", align 1
@.str.91 = private unnamed_addr constant [9 x i8] c"exported\00", align 1
@.str.92 = private unnamed_addr constant [12 x i8] c"guide-added\00", align 1
@.str.93 = private unnamed_addr constant [14 x i8] c"guide-removed\00", align 1
@.str.94 = private unnamed_addr constant [12 x i8] c"guide-moved\00", align 1
@.str.95 = private unnamed_addr constant [19 x i8] c"sample-point-added\00", align 1
@.str.96 = private unnamed_addr constant [21 x i8] c"sample-point-removed\00", align 1
@.str.97 = private unnamed_addr constant [19 x i8] c"sample-point-moved\00", align 1
@.str.98 = private unnamed_addr constant [18 x i8] c"parasite-attached\00", align 1
@.str.99 = private unnamed_addr constant [18 x i8] c"parasite-detached\00", align 1
@.str.100 = private unnamed_addr constant [17 x i8] c"colormap-changed\00", align 1
@.str.101 = private unnamed_addr constant [11 x i8] c"undo-event\00", align 1
@.str.102 = private unnamed_addr constant [11 x i8] c"gimp-image\00", align 1
@.str.103 = private unnamed_addr constant [3 x i8] c"id\00", align 1
@.str.104 = private unnamed_addr constant [12 x i8] c"gimpimage.c\00", align 1
@__func__.gimp_image_constructed = private unnamed_addr constant [23 x i8] c"gimp_image_constructed\00", align 1
@.str.105 = private unnamed_addr constant [27 x i8] c"GIMP_IS_GIMP (image->gimp)\00", align 1
@.str.106 = private unnamed_addr constant [26 x i8] c"notify::transparency-type\00", align 1
@.str.107 = private unnamed_addr constant [26 x i8] c"notify::transparency-size\00", align 1
@.str.108 = private unnamed_addr constant [23 x i8] c"notify::layer-previews\00", align 1
@__func__.gimp_image_set_property = private unnamed_addr constant [24 x i8] c"gimp_image_set_property\00", align 1
@.str.109 = private unnamed_addr constant [54 x i8] c"%s:%u: invalid %s id %u for \22%s\22 of type '%s' in '%s'\00", align 1
@.str.110 = private unnamed_addr constant [9 x i8] c"property\00", align 1
@.str.111 = private unnamed_addr constant [6 x i8] c"Qmask\00", align 1
@.str.112 = private unnamed_addr constant [6 x i8] c"%s-%d\00", align 1
@.str.113 = private unnamed_addr constant [10 x i8] c"operation\00", align 1
@.str.114 = private unnamed_addr constant [10 x i8] c"gegl:over\00", align 1
@.str.115 = private unnamed_addr constant [7 x i8] c"output\00", align 1
@.str.116 = private unnamed_addr constant [6 x i8] c"input\00", align 1
@.str.117 = private unnamed_addr constant [4 x i8] c"aux\00", align 1
@.str.118 = private unnamed_addr constant [20 x i8] c"notify::active-item\00", align 1
@.str.119 = private unnamed_addr constant [13 x i8] c"name-changed\00", align 1
@.str.120 = private unnamed_addr constant [14 x i8] c"color-changed\00", align 1
@.str.121 = private unnamed_addr constant [4 x i8] c"add\00", align 1
@.str.122 = private unnamed_addr constant [7 x i8] c"remove\00", align 1
@__func__.gimp_image_format_display_uri = private unnamed_addr constant [30 x i8] c"gimp_image_format_display_uri\00", align 1
@.str.123 = private unnamed_addr constant [3 x i8] c"%s\00", align 1
@.str.124 = private unnamed_addr constant [12 x i8] c" (exported)\00", align 1
@.str.125 = private unnamed_addr constant [15 x i8] c" (overwritten)\00", align 1
@.str.126 = private unnamed_addr constant [59 x i8] c"Unexpected code path, Save+export implementation is buggy!\00", align 1
@.str.127 = private unnamed_addr constant [12 x i8] c" (imported)\00", align 1
@.str.128 = private unnamed_addr constant [5 x i8] c"[%s]\00", align 1

; Function Attrs: nounwind readnone uwtable
define i64 @gimp_image_get_type() #0 {
entry:
  %tmp = alloca i32, align 4
  %tmp1 = alloca i8*, align 8
  %g_define_type_id = alloca i64, align 8
  fence seq_cst
  %0 = load volatile i64, i64* @gimp_image_get_type.g_define_type_id__volatile, align 8
  %1 = inttoptr i64 %0 to i8*
  store i8* %1, i8** %tmp1
  %2 = load i8*, i8** %tmp1
  %tobool = icmp ne i8* %2, null
  br i1 %tobool, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %entry
  %call = call i32 @g_once_init_enter(i8* bitcast (i64* @gimp_image_get_type.g_define_type_id__volatile to i8*))
  %tobool2 = icmp ne i32 %call, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %3 = phi i1 [ false, %entry ], [ %tobool2, %land.rhs ]
  %land.ext = zext i1 %3 to i32
  store i32 %land.ext, i32* %tmp
  %4 = load i32, i32* %tmp
  %tobool3 = icmp ne i32 %4, 0
  br i1 %tobool3, label %if.then, label %if.end

if.then:                                          ; preds = %land.end
  %call5 = call i64 @gimp_viewable_get_type() #8
  %call6 = call i8* @g_intern_static_string(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str, i32 0, i32 0))
  %call7 = call i64 @g_type_register_static_simple(i64 %call5, i8* %call6, i32 504, void (i8*, i8*)* bitcast (void (i8*)* @gimp_image_class_intern_init to void (i8*, i8*)*), i32 40, void (%struct._GTypeInstance*, i8*)* bitcast (void (%struct._GimpImage*)* @gimp_image_init to void (%struct._GTypeInstance*, i8*)*), i32 0)
  store i64 %call7, i64* %g_define_type_id, align 8
  %5 = load i64, i64* %g_define_type_id, align 8
  %call8 = call i64 @gimp_color_managed_interface_get_type() #8
  call void @g_type_add_interface_static(i64 %5, i64 %call8, %struct._GInterfaceInfo* @gimp_image_get_type.g_implement_interface_info)
  %6 = load i64, i64* %g_define_type_id, align 8
  %call9 = call i64 @gimp_projectable_interface_get_type() #8
  call void @g_type_add_interface_static(i64 %6, i64 %call9, %struct._GInterfaceInfo* @gimp_image_get_type.g_implement_interface_info.1)
  %7 = load i64, i64* %g_define_type_id, align 8
  call void @g_once_init_leave(i8* bitcast (i64* @gimp_image_get_type.g_define_type_id__volatile to i8*), i64 %7)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.end
  %8 = load volatile i64, i64* @gimp_image_get_type.g_define_type_id__volatile, align 8
  ret i64 %8
}

declare i32 @g_once_init_enter(i8*) #1

declare i64 @g_type_register_static_simple(i64, i8*, i32, void (i8*, i8*)*, i32, void (%struct._GTypeInstance*, i8*)*, i32) #1

; Function Attrs: nounwind readnone
declare i64 @gimp_viewable_get_type() #2

declare i8* @g_intern_static_string(i8*) #1

; Function Attrs: nounwind uwtable
define internal void @gimp_image_class_intern_init(i8* %klass) #3 {
entry:
  %klass.addr = alloca i8*, align 8
  store i8* %klass, i8** %klass.addr, align 8
  %0 = load i8*, i8** %klass.addr, align 8
  %call = call i8* @g_type_class_peek_parent(i8* %0)
  store i8* %call, i8** @gimp_image_parent_class, align 8
  %1 = load i32, i32* @GimpImage_private_offset, align 4
  %cmp = icmp ne i32 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i8*, i8** %klass.addr, align 8
  call void @g_type_class_adjust_private_offset(i8* %2, i32* @GimpImage_private_offset)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i8*, i8** %klass.addr, align 8
  %4 = bitcast i8* %3 to %struct._GimpImageClass*
  call void @gimp_image_class_init(%struct._GimpImageClass* %4)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @gimp_image_init(%struct._GimpImage* %image) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %private = alloca %struct._GimpImagePrivate*, align 8
  %i = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  %call = call i64 @gimp_image_get_type() #8
  %call1 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %1, i64 %call)
  %2 = bitcast i8* %call1 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %2, %struct._GimpImagePrivate** %private, align 8
  %3 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %ID = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %3, i32 0, i32 0
  store i32 0, i32* %ID, align 4
  %4 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %load_proc = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %4, i32 0, i32 1
  store %struct._GimpPlugInProcedure* null, %struct._GimpPlugInProcedure** %load_proc, align 8
  %5 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %save_proc = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %5, i32 0, i32 2
  store %struct._GimpPlugInProcedure* null, %struct._GimpPlugInProcedure** %save_proc, align 8
  %6 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %width = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %6, i32 0, i32 6
  store i32 0, i32* %width, align 4
  %7 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %height = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %7, i32 0, i32 7
  store i32 0, i32* %height, align 4
  %8 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %xresolution = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %8, i32 0, i32 8
  store double 1.000000e+00, double* %xresolution, align 8
  %9 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %yresolution = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %9, i32 0, i32 9
  store double 1.000000e+00, double* %yresolution, align 8
  %10 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %resolution_unit = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %10, i32 0, i32 10
  store i32 1, i32* %resolution_unit, align 4
  %11 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %base_type = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %11, i32 0, i32 11
  store i32 0, i32* %base_type, align 4
  %12 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %colormap = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %12, i32 0, i32 12
  store i8* null, i8** %colormap, align 8
  %13 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %n_colors = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %13, i32 0, i32 13
  store i32 0, i32* %n_colors, align 4
  %14 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %palette = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %14, i32 0, i32 14
  store %struct._GimpPalette* null, %struct._GimpPalette** %palette, align 8
  %15 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %dirty = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %15, i32 0, i32 15
  store i32 1, i32* %dirty, align 4
  %16 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %dirty_time = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %16, i32 0, i32 16
  store i32 0, i32* %dirty_time, align 4
  %17 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %undo_freeze_count = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %17, i32 0, i32 18
  store i32 0, i32* %undo_freeze_count, align 4
  %18 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %export_dirty = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %18, i32 0, i32 17
  store i32 1, i32* %export_dirty, align 4
  %19 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %instance_count = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %19, i32 0, i32 19
  store i32 0, i32* %instance_count, align 4
  %20 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %disp_count = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %20, i32 0, i32 20
  store i32 0, i32* %disp_count, align 4
  %21 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %tattoo_state = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %21, i32 0, i32 21
  store i32 0, i32* %tattoo_state, align 4
  %22 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %23 = bitcast %struct._GimpImage* %22 to %struct._GTypeInstance*
  %call2 = call i64 @gimp_projectable_interface_get_type() #8
  %call3 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %23, i64 %call2)
  %24 = bitcast %struct._GTypeInstance* %call3 to %struct._GimpProjectable*
  %call4 = call %struct._GimpProjection* @gimp_projection_new(%struct._GimpProjectable* %24)
  %25 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %projection = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %25, i32 0, i32 22
  store %struct._GimpProjection* %call4, %struct._GimpProjection** %projection, align 8
  %26 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %guides = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %26, i32 0, i32 24
  store %struct._GList* null, %struct._GList** %guides, align 8
  %27 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %grid = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %27, i32 0, i32 25
  store %struct._GimpGrid* null, %struct._GimpGrid** %grid, align 8
  %28 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %sample_points = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %28, i32 0, i32 26
  store %struct._GList* null, %struct._GList** %sample_points, align 8
  %29 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call5 = call i64 @gimp_drawable_stack_get_type() #8
  %call6 = call i64 @gimp_layer_get_type() #8
  %call7 = call %struct._GimpItemTree* @gimp_item_tree_new(%struct._GimpImage* %29, i64 %call5, i64 %call6)
  %30 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %layers = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %30, i32 0, i32 27
  store %struct._GimpItemTree* %call7, %struct._GimpItemTree** %layers, align 8
  %31 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call8 = call i64 @gimp_drawable_stack_get_type() #8
  %call9 = call i64 @gimp_channel_get_type() #8
  %call10 = call %struct._GimpItemTree* @gimp_item_tree_new(%struct._GimpImage* %31, i64 %call8, i64 %call9)
  %32 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %channels = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %32, i32 0, i32 28
  store %struct._GimpItemTree* %call10, %struct._GimpItemTree** %channels, align 8
  %33 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call11 = call i64 @gimp_item_stack_get_type() #8
  %call12 = call i64 @gimp_vectors_get_type() #8
  %call13 = call %struct._GimpItemTree* @gimp_item_tree_new(%struct._GimpImage* %33, i64 %call11, i64 %call12)
  %34 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %vectors = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %34, i32 0, i32 29
  store %struct._GimpItemTree* %call13, %struct._GimpItemTree** %vectors, align 8
  %35 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %layer_stack = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %35, i32 0, i32 30
  store %struct._GSList* null, %struct._GSList** %layer_stack, align 8
  %36 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %layers14 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %36, i32 0, i32 27
  %37 = load %struct._GimpItemTree*, %struct._GimpItemTree** %layers14, align 8
  %38 = bitcast %struct._GimpItemTree* %37 to i8*
  %39 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %40 = bitcast %struct._GimpImage* %39 to i8*
  %call15 = call i64 @g_signal_connect_data(i8* %38, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.118, i32 0, i32 0), void ()* bitcast (void (%struct._GimpItemTree*, %struct._GParamSpec*, %struct._GimpImage*)* @gimp_image_active_layer_notify to void ()*), i8* %40, void (i8*, %struct._GClosure*)* null, i32 0)
  %41 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %channels16 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %41, i32 0, i32 28
  %42 = load %struct._GimpItemTree*, %struct._GimpItemTree** %channels16, align 8
  %43 = bitcast %struct._GimpItemTree* %42 to i8*
  %44 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %45 = bitcast %struct._GimpImage* %44 to i8*
  %call17 = call i64 @g_signal_connect_data(i8* %43, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.118, i32 0, i32 0), void ()* bitcast (void (%struct._GimpItemTree*, %struct._GParamSpec*, %struct._GimpImage*)* @gimp_image_active_channel_notify to void ()*), i8* %45, void (i8*, %struct._GClosure*)* null, i32 0)
  %46 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %vectors18 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %46, i32 0, i32 29
  %47 = load %struct._GimpItemTree*, %struct._GimpItemTree** %vectors18, align 8
  %48 = bitcast %struct._GimpItemTree* %47 to i8*
  %49 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %50 = bitcast %struct._GimpImage* %49 to i8*
  %call19 = call i64 @g_signal_connect_data(i8* %48, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.118, i32 0, i32 0), void ()* bitcast (void (%struct._GimpItemTree*, %struct._GParamSpec*, %struct._GimpImage*)* @gimp_image_active_vectors_notify to void ()*), i8* %50, void (i8*, %struct._GClosure*)* null, i32 0)
  %51 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %layers20 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %51, i32 0, i32 27
  %52 = load %struct._GimpItemTree*, %struct._GimpItemTree** %layers20, align 8
  %container = getelementptr inbounds %struct._GimpItemTree, %struct._GimpItemTree* %52, i32 0, i32 1
  %53 = load %struct._GimpContainer*, %struct._GimpContainer** %container, align 8
  %54 = bitcast %struct._GimpContainer* %53 to i8*
  %55 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %56 = bitcast %struct._GimpImage* %55 to i8*
  %call21 = call i64 @g_signal_connect_data(i8* %54, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.19, i32 0, i32 0), void ()* bitcast (void (%struct._GimpImage*, i32, i32, i32, i32)* @gimp_image_invalidate to void ()*), i8* %56, void (i8*, %struct._GClosure*)* null, i32 2)
  %57 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %layers22 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %57, i32 0, i32 27
  %58 = load %struct._GimpItemTree*, %struct._GimpItemTree** %layers22, align 8
  %container23 = getelementptr inbounds %struct._GimpItemTree, %struct._GimpItemTree* %58, i32 0, i32 1
  %59 = load %struct._GimpContainer*, %struct._GimpContainer** %container23, align 8
  %60 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %61 = bitcast %struct._GimpImage* %60 to i8*
  %call24 = call i32 @gimp_container_add_handler(%struct._GimpContainer* %59, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.75, i32 0, i32 0), void ()* bitcast (void (%struct._GimpDrawable*, %struct._GimpImage*)* @gimp_image_layer_alpha_changed to void ()*), i8* %61)
  %62 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %layer_alpha_handler = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %62, i32 0, i32 31
  store i32 %call24, i32* %layer_alpha_handler, align 4
  %63 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %channels25 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %63, i32 0, i32 28
  %64 = load %struct._GimpItemTree*, %struct._GimpItemTree** %channels25, align 8
  %container26 = getelementptr inbounds %struct._GimpItemTree, %struct._GimpItemTree* %64, i32 0, i32 1
  %65 = load %struct._GimpContainer*, %struct._GimpContainer** %container26, align 8
  %66 = bitcast %struct._GimpContainer* %65 to i8*
  %67 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %68 = bitcast %struct._GimpImage* %67 to i8*
  %call27 = call i64 @g_signal_connect_data(i8* %66, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.19, i32 0, i32 0), void ()* bitcast (void (%struct._GimpImage*, i32, i32, i32, i32)* @gimp_image_invalidate to void ()*), i8* %68, void (i8*, %struct._GClosure*)* null, i32 2)
  %69 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %channels28 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %69, i32 0, i32 28
  %70 = load %struct._GimpItemTree*, %struct._GimpItemTree** %channels28, align 8
  %container29 = getelementptr inbounds %struct._GimpItemTree, %struct._GimpItemTree* %70, i32 0, i32 1
  %71 = load %struct._GimpContainer*, %struct._GimpContainer** %container29, align 8
  %72 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %73 = bitcast %struct._GimpImage* %72 to i8*
  %call30 = call i32 @gimp_container_add_handler(%struct._GimpContainer* %71, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.119, i32 0, i32 0), void ()* bitcast (void (%struct._GimpChannel*, %struct._GimpImage*)* @gimp_image_channel_name_changed to void ()*), i8* %73)
  %74 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %channel_name_changed_handler = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %74, i32 0, i32 32
  store i32 %call30, i32* %channel_name_changed_handler, align 4
  %75 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %channels31 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %75, i32 0, i32 28
  %76 = load %struct._GimpItemTree*, %struct._GimpItemTree** %channels31, align 8
  %container32 = getelementptr inbounds %struct._GimpItemTree, %struct._GimpItemTree* %76, i32 0, i32 1
  %77 = load %struct._GimpContainer*, %struct._GimpContainer** %container32, align 8
  %78 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %79 = bitcast %struct._GimpImage* %78 to i8*
  %call33 = call i32 @gimp_container_add_handler(%struct._GimpContainer* %77, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.120, i32 0, i32 0), void ()* bitcast (void (%struct._GimpChannel*, %struct._GimpImage*)* @gimp_image_channel_color_changed to void ()*), i8* %79)
  %80 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %channel_color_changed_handler = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %80, i32 0, i32 33
  store i32 %call33, i32* %channel_color_changed_handler, align 4
  %81 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %channels34 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %81, i32 0, i32 28
  %82 = load %struct._GimpItemTree*, %struct._GimpItemTree** %channels34, align 8
  %container35 = getelementptr inbounds %struct._GimpItemTree, %struct._GimpItemTree* %82, i32 0, i32 1
  %83 = load %struct._GimpContainer*, %struct._GimpContainer** %container35, align 8
  %84 = bitcast %struct._GimpContainer* %83 to i8*
  %85 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %86 = bitcast %struct._GimpImage* %85 to i8*
  %call36 = call i64 @g_signal_connect_data(i8* %84, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.121, i32 0, i32 0), void ()* bitcast (void (%struct._GimpContainer*, %struct._GimpChannel*, %struct._GimpImage*)* @gimp_image_channel_add to void ()*), i8* %86, void (i8*, %struct._GClosure*)* null, i32 0)
  %87 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %channels37 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %87, i32 0, i32 28
  %88 = load %struct._GimpItemTree*, %struct._GimpItemTree** %channels37, align 8
  %container38 = getelementptr inbounds %struct._GimpItemTree, %struct._GimpItemTree* %88, i32 0, i32 1
  %89 = load %struct._GimpContainer*, %struct._GimpContainer** %container38, align 8
  %90 = bitcast %struct._GimpContainer* %89 to i8*
  %91 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %92 = bitcast %struct._GimpImage* %91 to i8*
  %call39 = call i64 @g_signal_connect_data(i8* %90, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.122, i32 0, i32 0), void ()* bitcast (void (%struct._GimpContainer*, %struct._GimpChannel*, %struct._GimpImage*)* @gimp_image_channel_remove to void ()*), i8* %92, void (i8*, %struct._GClosure*)* null, i32 0)
  %93 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %floating_sel = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %93, i32 0, i32 34
  store %struct._GimpLayer* null, %struct._GimpLayer** %floating_sel, align 8
  %94 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %selection_mask = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %94, i32 0, i32 35
  store %struct._GimpChannel* null, %struct._GimpChannel** %selection_mask, align 8
  %call40 = call %struct._GimpParasiteList* @gimp_parasite_list_new()
  %95 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %parasites = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %95, i32 0, i32 36
  store %struct._GimpParasiteList* %call40, %struct._GimpParasiteList** %parasites, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %96 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %96, 4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %97 = load i32, i32* %i, align 4
  %idxprom = sext i32 %97 to i64
  %98 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %visible = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %98, i32 0, i32 37
  %arrayidx = getelementptr inbounds [4 x i32], [4 x i32]* %visible, i32 0, i64 %idxprom
  store i32 1, i32* %arrayidx, align 4
  %99 = load i32, i32* %i, align 4
  %idxprom41 = sext i32 %99 to i64
  %100 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %active = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %100, i32 0, i32 38
  %arrayidx42 = getelementptr inbounds [4 x i32], [4 x i32]* %active, i32 0, i64 %idxprom41
  store i32 1, i32* %arrayidx42, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %101 = load i32, i32* %i, align 4
  %inc = add nsw i32 %101, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %102 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %quick_mask_state = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %102, i32 0, i32 39
  store i32 0, i32* %quick_mask_state, align 4
  %103 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %quick_mask_inverted = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %103, i32 0, i32 40
  store i32 0, i32* %quick_mask_inverted, align 4
  %104 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %quick_mask_color = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %104, i32 0, i32 41
  call void @gimp_rgba_set(%struct._GimpRGB* %quick_mask_color, double 1.000000e+00, double 0.000000e+00, double 0.000000e+00, double 5.000000e-01)
  %105 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call43 = call %struct._GimpUndoStack* @gimp_undo_stack_new(%struct._GimpImage* %105)
  %106 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %undo_stack = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %106, i32 0, i32 42
  store %struct._GimpUndoStack* %call43, %struct._GimpUndoStack** %undo_stack, align 8
  %107 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call44 = call %struct._GimpUndoStack* @gimp_undo_stack_new(%struct._GimpImage* %107)
  %108 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %redo_stack = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %108, i32 0, i32 43
  store %struct._GimpUndoStack* %call44, %struct._GimpUndoStack** %redo_stack, align 8
  %109 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %group_count = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %109, i32 0, i32 44
  store i32 0, i32* %group_count, align 4
  %110 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %pushing_undo_group = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %110, i32 0, i32 45
  store i32 0, i32* %pushing_undo_group, align 4
  %111 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %preview = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %111, i32 0, i32 46
  store %struct._TempBuf* null, %struct._TempBuf** %preview, align 8
  %112 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %flush_accum = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %112, i32 0, i32 47
  %alpha_changed = getelementptr inbounds %struct._GimpImageFlushAccumulator, %struct._GimpImageFlushAccumulator* %flush_accum, i32 0, i32 0
  store i32 0, i32* %alpha_changed, align 4
  %113 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %flush_accum45 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %113, i32 0, i32 47
  %mask_changed = getelementptr inbounds %struct._GimpImageFlushAccumulator, %struct._GimpImageFlushAccumulator* %flush_accum45, i32 0, i32 1
  store i32 0, i32* %mask_changed, align 4
  %114 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %flush_accum46 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %114, i32 0, i32 47
  %floating_selection_changed = getelementptr inbounds %struct._GimpImageFlushAccumulator, %struct._GimpImageFlushAccumulator* %flush_accum46, i32 0, i32 2
  store i32 0, i32* %floating_selection_changed, align 4
  %115 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %flush_accum47 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %115, i32 0, i32 47
  %preview_invalidated = getelementptr inbounds %struct._GimpImageFlushAccumulator, %struct._GimpImageFlushAccumulator* %flush_accum47, i32 0, i32 3
  store i32 0, i32* %preview_invalidated, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @gimp_color_managed_iface_init(%struct._GimpColorManagedInterface* %iface) #3 {
entry:
  %iface.addr = alloca %struct._GimpColorManagedInterface*, align 8
  store %struct._GimpColorManagedInterface* %iface, %struct._GimpColorManagedInterface** %iface.addr, align 8
  %0 = load %struct._GimpColorManagedInterface*, %struct._GimpColorManagedInterface** %iface.addr, align 8
  %get_icc_profile = getelementptr inbounds %struct._GimpColorManagedInterface, %struct._GimpColorManagedInterface* %0, i32 0, i32 1
  store i8* (%struct._GimpColorManaged*, i64*)* @gimp_image_get_icc_profile, i8* (%struct._GimpColorManaged*, i64*)** %get_icc_profile, align 8
  ret void
}

declare void @g_type_add_interface_static(i64, i64, %struct._GInterfaceInfo*) #1

; Function Attrs: nounwind readnone
declare i64 @gimp_color_managed_interface_get_type() #2

; Function Attrs: nounwind uwtable
define internal void @gimp_projectable_iface_init(%struct._GimpProjectableInterface* %iface) #3 {
entry:
  %iface.addr = alloca %struct._GimpProjectableInterface*, align 8
  store %struct._GimpProjectableInterface* %iface, %struct._GimpProjectableInterface** %iface.addr, align 8
  %0 = load %struct._GimpProjectableInterface*, %struct._GimpProjectableInterface** %iface.addr, align 8
  %flush = getelementptr inbounds %struct._GimpProjectableInterface, %struct._GimpProjectableInterface* %0, i32 0, i32 2
  store void (%struct._GimpProjectable*, i32)* @gimp_image_projectable_flush, void (%struct._GimpProjectable*, i32)** %flush, align 8
  %1 = load %struct._GimpProjectableInterface*, %struct._GimpProjectableInterface** %iface.addr, align 8
  %get_image = getelementptr inbounds %struct._GimpProjectableInterface, %struct._GimpProjectableInterface* %1, i32 0, i32 4
  store %struct._GimpImage* (%struct._GimpProjectable*)* @gimp_image_get_image, %struct._GimpImage* (%struct._GimpProjectable*)** %get_image, align 8
  %2 = load %struct._GimpProjectableInterface*, %struct._GimpProjectableInterface** %iface.addr, align 8
  %get_image_type = getelementptr inbounds %struct._GimpProjectableInterface, %struct._GimpProjectableInterface* %2, i32 0, i32 5
  store i32 (%struct._GimpProjectable*)* @gimp_image_get_image_type, i32 (%struct._GimpProjectable*)** %get_image_type, align 8
  %3 = load %struct._GimpProjectableInterface*, %struct._GimpProjectableInterface** %iface.addr, align 8
  %get_size = getelementptr inbounds %struct._GimpProjectableInterface, %struct._GimpProjectableInterface* %3, i32 0, i32 7
  store void (%struct._GimpProjectable*, i32*, i32*)* bitcast (i32 (%struct._GimpViewable*, i32*, i32*)* @gimp_image_get_size to void (%struct._GimpProjectable*, i32*, i32*)*), void (%struct._GimpProjectable*, i32*, i32*)** %get_size, align 8
  %4 = load %struct._GimpProjectableInterface*, %struct._GimpProjectableInterface** %iface.addr, align 8
  %get_graph = getelementptr inbounds %struct._GimpProjectableInterface, %struct._GimpProjectableInterface* %4, i32 0, i32 8
  store %struct._GeglNode* (%struct._GimpProjectable*)* @gimp_image_get_graph, %struct._GeglNode* (%struct._GimpProjectable*)** %get_graph, align 8
  %5 = load %struct._GimpProjectableInterface*, %struct._GimpProjectableInterface** %iface.addr, align 8
  %invalidate_preview = getelementptr inbounds %struct._GimpProjectableInterface, %struct._GimpProjectableInterface* %5, i32 0, i32 9
  store void (%struct._GimpProjectable*)* bitcast (void (%struct._GimpViewable*)* @gimp_viewable_invalidate_preview to void (%struct._GimpProjectable*)*), void (%struct._GimpProjectable*)** %invalidate_preview, align 8
  %6 = load %struct._GimpProjectableInterface*, %struct._GimpProjectableInterface** %iface.addr, align 8
  %get_layers = getelementptr inbounds %struct._GimpProjectableInterface, %struct._GimpProjectableInterface* %6, i32 0, i32 10
  store %struct._GList* (%struct._GimpProjectable*)* bitcast (%struct._GList* (%struct._GimpImage*)* @gimp_image_get_layer_iter to %struct._GList* (%struct._GimpProjectable*)*), %struct._GList* (%struct._GimpProjectable*)** %get_layers, align 8
  %7 = load %struct._GimpProjectableInterface*, %struct._GimpProjectableInterface** %iface.addr, align 8
  %get_channels = getelementptr inbounds %struct._GimpProjectableInterface, %struct._GimpProjectableInterface* %7, i32 0, i32 11
  store %struct._GList* (%struct._GimpProjectable*)* bitcast (%struct._GList* (%struct._GimpImage*)* @gimp_image_get_channel_iter to %struct._GList* (%struct._GimpProjectable*)*), %struct._GList* (%struct._GimpProjectable*)** %get_channels, align 8
  ret void
}

; Function Attrs: nounwind readnone
declare i64 @gimp_projectable_interface_get_type() #2

declare void @g_once_init_leave(i8*, i64) #1

; Function Attrs: nounwind uwtable
define %struct._GimpImage* @gimp_image_new(%struct._Gimp* %gimp, i32 %width, i32 %height, i32 %base_type) #3 {
entry:
  %retval = alloca %struct._GimpImage*, align 8
  %gimp.addr = alloca %struct._Gimp*, align 8
  %width.addr = alloca i32, align 4
  %height.addr = alloca i32, align 4
  %base_type.addr = alloca i32, align 4
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._Gimp* %gimp, %struct._Gimp** %gimp.addr, align 8
  store i32 %width, i32* %width.addr, align 4
  store i32 %height, i32* %height.addr, align 4
  store i32 %base_type, i32* %base_type.addr, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._Gimp*, %struct._Gimp** %gimp.addr, align 8
  %1 = bitcast %struct._Gimp* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @__func__.gimp_image_new, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.3, i32 0, i32 0))
  store %struct._GimpImage* null, %struct._GimpImage** %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %call11 = call i64 @gimp_image_get_type() #8
  %13 = load %struct._Gimp*, %struct._Gimp** %gimp.addr, align 8
  %14 = load i32, i32* %width.addr, align 4
  %15 = load i32, i32* %height.addr, align 4
  %16 = load i32, i32* %base_type.addr, align 4
  %call12 = call i8* (i64, i8*, ...) @g_object_new(i64 %call11, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0), %struct._Gimp* %13, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.5, i32 0, i32 0), i32 %14, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.6, i32 0, i32 0), i32 %15, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.7, i32 0, i32 0), i32 %16, i8* null)
  %17 = bitcast i8* %call12 to %struct._GimpImage*
  store %struct._GimpImage* %17, %struct._GimpImage** %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %18 = load %struct._GimpImage*, %struct._GimpImage** %retval
  ret %struct._GimpImage* %18
}

; Function Attrs: nounwind readnone
declare i64 @gimp_get_type() #2

; Function Attrs: nounwind readonly
declare i32 @g_type_check_instance_is_a(%struct._GTypeInstance*, i64) #4

declare void @g_return_if_fail_warning(i8*, i8*, i8*) #1

declare i8* @g_object_new(i64, i8*, ...) #1

; Function Attrs: nounwind uwtable
define i32 @gimp_image_base_type(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca i32, align 4
  %image.addr = alloca %struct._GimpImage*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__func__.gimp_image_base_type, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store i32 -1, i32* %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  %base_type = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %15, i32 0, i32 11
  %16 = load i32, i32* %base_type, align 4
  store i32 %16, i32* %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %17 = load i32, i32* %retval
  ret i32 %17
}

declare i8* @g_type_instance_get_private(%struct._GTypeInstance*, i64) #1

; Function Attrs: nounwind uwtable
define i32 @gimp_image_base_type_with_alpha(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca i32, align 4
  %image.addr = alloca %struct._GimpImage*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([32 x i8], [32 x i8]* @__func__.gimp_image_base_type_with_alpha, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store i32 -1, i32* %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  %base_type = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %15, i32 0, i32 11
  %16 = load i32, i32* %base_type, align 4
  switch i32 %16, label %sw.epilog [
    i32 0, label %sw.bb
    i32 1, label %sw.bb.13
    i32 2, label %sw.bb.14
  ]

sw.bb:                                            ; preds = %do.end
  store i32 1, i32* %retval
  br label %return

sw.bb.13:                                         ; preds = %do.end
  store i32 3, i32* %retval
  br label %return

sw.bb.14:                                         ; preds = %do.end
  store i32 5, i32* %retval
  br label %return

sw.epilog:                                        ; preds = %do.end
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %sw.epilog, %sw.bb.14, %sw.bb.13, %sw.bb, %if.else.9
  %17 = load i32, i32* %retval
  ret i32 %17
}

; Function Attrs: nounwind uwtable
define i32 @gimp_image_get_combination_mode(i32 %dest_type, i32 %src_bytes) #3 {
entry:
  %dest_type.addr = alloca i32, align 4
  %src_bytes.addr = alloca i32, align 4
  store i32 %dest_type, i32* %dest_type.addr, align 4
  store i32 %src_bytes, i32* %src_bytes.addr, align 4
  %0 = load i32, i32* %src_bytes.addr, align 4
  %idxprom = sext i32 %0 to i64
  %1 = load i32, i32* %dest_type.addr, align 4
  %idxprom1 = zext i32 %1 to i64
  %arrayidx = getelementptr inbounds [6 x [5 x i32]], [6 x [5 x i32]]* @valid_combinations, i32 0, i64 %idxprom1
  %arrayidx2 = getelementptr inbounds [5 x i32], [5 x i32]* %arrayidx, i32 0, i64 %idxprom
  %2 = load i32, i32* %arrayidx2, align 4
  ret i32 %2
}

; Function Attrs: nounwind uwtable
define i32 @gimp_image_get_ID(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca i32, align 4
  %image.addr = alloca %struct._GimpImage*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @__func__.gimp_image_get_ID, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store i32 -1, i32* %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  %ID = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %15, i32 0, i32 0
  %16 = load i32, i32* %ID, align 4
  store i32 %16, i32* %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %17 = load i32, i32* %retval
  ret i32 %17
}

; Function Attrs: nounwind uwtable
define %struct._GimpImage* @gimp_image_get_by_ID(%struct._Gimp* %gimp, i32 %image_id) #3 {
entry:
  %retval = alloca %struct._GimpImage*, align 8
  %gimp.addr = alloca %struct._Gimp*, align 8
  %image_id.addr = alloca i32, align 4
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._Gimp* %gimp, %struct._Gimp** %gimp.addr, align 8
  store i32 %image_id, i32* %image_id.addr, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._Gimp*, %struct._Gimp** %gimp.addr, align 8
  %1 = bitcast %struct._Gimp* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__func__.gimp_image_get_by_ID, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.3, i32 0, i32 0))
  store %struct._GimpImage* null, %struct._GimpImage** %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._Gimp*, %struct._Gimp** %gimp.addr, align 8
  %image_table = getelementptr inbounds %struct._Gimp, %struct._Gimp* %13, i32 0, i32 29
  %14 = load %struct._GimpIdTable*, %struct._GimpIdTable** %image_table, align 8
  %cmp11 = icmp eq %struct._GimpIdTable* %14, null
  br i1 %cmp11, label %if.then.12, label %if.end.13

if.then.12:                                       ; preds = %do.end
  store %struct._GimpImage* null, %struct._GimpImage** %retval
  br label %return

if.end.13:                                        ; preds = %do.end
  %15 = load %struct._Gimp*, %struct._Gimp** %gimp.addr, align 8
  %image_table14 = getelementptr inbounds %struct._Gimp, %struct._Gimp* %15, i32 0, i32 29
  %16 = load %struct._GimpIdTable*, %struct._GimpIdTable** %image_table14, align 8
  %17 = load i32, i32* %image_id.addr, align 4
  %call15 = call i8* @gimp_id_table_lookup(%struct._GimpIdTable* %16, i32 %17)
  %18 = bitcast i8* %call15 to %struct._GimpImage*
  store %struct._GimpImage* %18, %struct._GimpImage** %retval
  br label %return

return:                                           ; preds = %if.end.13, %if.then.12, %if.else.9
  %19 = load %struct._GimpImage*, %struct._GimpImage** %retval
  ret %struct._GimpImage* %19
}

declare i8* @gimp_id_table_lookup(%struct._GimpIdTable*, i32) #1

; Function Attrs: nounwind uwtable
define void @gimp_image_set_uri(%struct._GimpImage* %image, i8* %uri) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %uri.addr = alloca i8*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store i8* %uri, i8** %uri.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__func__.gimp_image_set_uri, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_object_get_type() #8
  %call12 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast %struct._GTypeInstance* %call12 to %struct._GimpObject*
  %16 = load i8*, i8** %uri.addr, align 8
  call void @gimp_object_set_name(%struct._GimpObject* %15, i8* %16)
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  ret void
}

declare void @gimp_object_set_name(%struct._GimpObject*, i8*) #1

declare %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance*, i64) #1

; Function Attrs: nounwind readnone
declare i64 @gimp_object_get_type() #2

; Function Attrs: nounwind uwtable
define i8* @gimp_image_get_string_untitled() #3 {
entry:
  %call = call i8* @gettext(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.9, i32 0, i32 0)) #6
  ret i8* %call
}

; Function Attrs: nounwind
declare i8* @gettext(i8*) #5

; Function Attrs: nounwind uwtable
define i8* @gimp_image_get_uri_or_untitled(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca i8*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %uri = alloca i8*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([31 x i8], [31 x i8]* @__func__.gimp_image_get_uri_or_untitled, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store i8* null, i8** %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call11 = call i8* @gimp_image_get_uri(%struct._GimpImage* %13)
  store i8* %call11, i8** %uri, align 8
  %14 = load i8*, i8** %uri, align 8
  %tobool12 = icmp ne i8* %14, null
  br i1 %tobool12, label %cond.true, label %cond.false

cond.true:                                        ; preds = %do.end
  %15 = load i8*, i8** %uri, align 8
  br label %cond.end

cond.false:                                       ; preds = %do.end
  %call13 = call i8* @gimp_image_get_string_untitled()
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %15, %cond.true ], [ %call13, %cond.false ]
  store i8* %cond, i8** %retval
  br label %return

return:                                           ; preds = %cond.end, %if.else.9
  %16 = load i8*, i8** %retval
  ret i8* %16
}

; Function Attrs: nounwind uwtable
define i8* @gimp_image_get_uri(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca i8*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @__func__.gimp_image_get_uri, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store i8* null, i8** %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to i8*
  %call11 = call i8* @gimp_object_get_name(i8* %14)
  store i8* %call11, i8** %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %15 = load i8*, i8** %retval
  ret i8* %15
}

declare i8* @gimp_object_get_name(i8*) #1

; Function Attrs: nounwind uwtable
define void @gimp_image_set_filename(%struct._GimpImage* %image, i8* %filename) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %filename.addr = alloca i8*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store i8* %filename, i8** %filename.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__func__.gimp_image_set_filename, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %if.end.18

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load i8*, i8** %filename.addr, align 8
  %tobool11 = icmp ne i8* %13, null
  br i1 %tobool11, label %land.lhs.true.12, label %if.else.17

land.lhs.true.12:                                 ; preds = %do.end
  %14 = load i8*, i8** %filename.addr, align 8
  %call13 = call i64 @strlen(i8* %14) #9
  %tobool14 = icmp ne i64 %call13, 0
  br i1 %tobool14, label %if.then.15, label %if.else.17

if.then.15:                                       ; preds = %land.lhs.true.12
  %15 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %16 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %gimp = getelementptr inbounds %struct._GimpImage, %struct._GimpImage* %16, i32 0, i32 1
  %17 = load %struct._Gimp*, %struct._Gimp** %gimp, align 8
  %18 = load i8*, i8** %filename.addr, align 8
  %call16 = call i8* @file_utils_filename_to_uri(%struct._Gimp* %17, i8* %18, %struct._GError** null)
  call void @gimp_image_take_uri(%struct._GimpImage* %15, i8* %call16)
  br label %if.end.18

if.else.17:                                       ; preds = %land.lhs.true.12, %do.end
  %19 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  call void @gimp_image_set_uri(%struct._GimpImage* %19, i8* null)
  br label %if.end.18

if.end.18:                                        ; preds = %if.else.9, %if.else.17, %if.then.15
  ret void
}

; Function Attrs: nounwind readonly
declare i64 @strlen(i8*) #4

; Function Attrs: nounwind uwtable
define internal void @gimp_image_take_uri(%struct._GimpImage* %image, i8* %uri) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %uri.addr = alloca i8*, align 8
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store i8* %uri, i8** %uri.addr, align 8
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  %call = call i64 @gimp_object_get_type() #8
  %call1 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %1, i64 %call)
  %2 = bitcast %struct._GTypeInstance* %call1 to %struct._GimpObject*
  %3 = load i8*, i8** %uri.addr, align 8
  call void @gimp_object_take_name(%struct._GimpObject* %2, i8* %3)
  ret void
}

declare i8* @file_utils_filename_to_uri(%struct._Gimp*, i8*, %struct._GError**) #1

; Function Attrs: nounwind uwtable
define i8* @gimp_image_get_imported_uri(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca i8*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__func__.gimp_image_get_imported_uri, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store i8* null, i8** %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %14, i64 80)
  %15 = bitcast %struct._GTypeInstance* %call11 to %struct._GObject*
  %call12 = call i8* @g_object_get_data(%struct._GObject* %15, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.10, i32 0, i32 0))
  store i8* %call12, i8** %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %16 = load i8*, i8** %retval
  ret i8* %16
}

declare i8* @g_object_get_data(%struct._GObject*, i8*) #1

; Function Attrs: nounwind uwtable
define i8* @gimp_image_get_exported_uri(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca i8*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__func__.gimp_image_get_exported_uri, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store i8* null, i8** %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %14, i64 80)
  %15 = bitcast %struct._GTypeInstance* %call11 to %struct._GObject*
  %call12 = call i8* @g_object_get_data(%struct._GObject* %15, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.11, i32 0, i32 0))
  store i8* %call12, i8** %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %16 = load i8*, i8** %retval
  ret i8* %16
}

; Function Attrs: nounwind uwtable
define i8* @gimp_image_get_save_a_copy_uri(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca i8*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([31 x i8], [31 x i8]* @__func__.gimp_image_get_save_a_copy_uri, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store i8* null, i8** %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %14, i64 80)
  %15 = bitcast %struct._GTypeInstance* %call11 to %struct._GObject*
  %call12 = call i8* @g_object_get_data(%struct._GObject* %15, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.12, i32 0, i32 0))
  store i8* %call12, i8** %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %16 = load i8*, i8** %retval
  ret i8* %16
}

; Function Attrs: nounwind uwtable
define i8* @gimp_image_get_any_uri(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca i8*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %uri = alloca i8*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__func__.gimp_image_get_any_uri, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store i8* null, i8** %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call11 = call i8* @gimp_image_get_uri(%struct._GimpImage* %13)
  store i8* %call11, i8** %uri, align 8
  %14 = load i8*, i8** %uri, align 8
  %tobool12 = icmp ne i8* %14, null
  br i1 %tobool12, label %if.end.19, label %if.then.13

if.then.13:                                       ; preds = %do.end
  %15 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call14 = call i8* @gimp_image_get_imported_uri(%struct._GimpImage* %15)
  store i8* %call14, i8** %uri, align 8
  %16 = load i8*, i8** %uri, align 8
  %tobool15 = icmp ne i8* %16, null
  br i1 %tobool15, label %if.end.18, label %if.then.16

if.then.16:                                       ; preds = %if.then.13
  %17 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call17 = call i8* @gimp_image_get_exported_uri(%struct._GimpImage* %17)
  store i8* %call17, i8** %uri, align 8
  br label %if.end.18

if.end.18:                                        ; preds = %if.then.16, %if.then.13
  br label %if.end.19

if.end.19:                                        ; preds = %if.end.18, %do.end
  %18 = load i8*, i8** %uri, align 8
  store i8* %18, i8** %retval
  br label %return

return:                                           ; preds = %if.end.19, %if.else.9
  %19 = load i8*, i8** %retval
  ret i8* %19
}

; Function Attrs: nounwind uwtable
define void @gimp_image_set_imported_uri(%struct._GimpImage* %image, i8* %uri) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %uri.addr = alloca i8*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store i8* %uri, i8** %uri.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__func__.gimp_image_set_imported_uri, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call11 = call i8* @gimp_image_get_imported_uri(%struct._GimpImage* %13)
  %14 = load i8*, i8** %uri.addr, align 8
  %cmp12 = icmp eq i8* %call11, %14
  br i1 %cmp12, label %if.then.13, label %if.end.14

if.then.13:                                       ; preds = %do.end
  br label %return

if.end.14:                                        ; preds = %do.end
  %15 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %16 = bitcast %struct._GimpImage* %15 to %struct._GTypeInstance*
  %call15 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %16, i64 80)
  %17 = bitcast %struct._GTypeInstance* %call15 to %struct._GObject*
  %18 = load i8*, i8** %uri.addr, align 8
  %call16 = call noalias i8* @g_strdup(i8* %18)
  call void @g_object_set_data_full(%struct._GObject* %17, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.10, i32 0, i32 0), i8* %call16, void (i8*)* @g_free)
  %19 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %20 = bitcast %struct._GimpImage* %19 to %struct._GTypeInstance*
  %call17 = call i64 @gimp_object_get_type() #8
  %call18 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %20, i64 %call17)
  %21 = bitcast %struct._GTypeInstance* %call18 to %struct._GimpObject*
  call void @gimp_object_name_changed(%struct._GimpObject* %21)
  br label %return

return:                                           ; preds = %if.end.14, %if.then.13, %if.else.9
  ret void
}

declare void @g_object_set_data_full(%struct._GObject*, i8*, i8*, void (i8*)*) #1

declare noalias i8* @g_strdup(i8*) #1

declare void @g_free(i8*) #1

declare void @gimp_object_name_changed(%struct._GimpObject*) #1

; Function Attrs: nounwind uwtable
define void @gimp_image_set_exported_uri(%struct._GimpImage* %image, i8* %uri) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %uri.addr = alloca i8*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store i8* %uri, i8** %uri.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__func__.gimp_image_set_exported_uri, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call11 = call i8* @gimp_image_get_exported_uri(%struct._GimpImage* %13)
  %14 = load i8*, i8** %uri.addr, align 8
  %cmp12 = icmp eq i8* %call11, %14
  br i1 %cmp12, label %if.then.13, label %if.end.14

if.then.13:                                       ; preds = %do.end
  br label %return

if.end.14:                                        ; preds = %do.end
  %15 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %16 = bitcast %struct._GimpImage* %15 to %struct._GTypeInstance*
  %call15 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %16, i64 80)
  %17 = bitcast %struct._GTypeInstance* %call15 to %struct._GObject*
  %18 = load i8*, i8** %uri.addr, align 8
  %call16 = call noalias i8* @g_strdup(i8* %18)
  call void @g_object_set_data_full(%struct._GObject* %17, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.11, i32 0, i32 0), i8* %call16, void (i8*)* @g_free)
  %19 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %20 = bitcast %struct._GimpImage* %19 to %struct._GTypeInstance*
  %call17 = call i64 @gimp_object_get_type() #8
  %call18 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %20, i64 %call17)
  %21 = bitcast %struct._GTypeInstance* %call18 to %struct._GimpObject*
  call void @gimp_object_name_changed(%struct._GimpObject* %21)
  br label %return

return:                                           ; preds = %if.end.14, %if.then.13, %if.else.9
  ret void
}

; Function Attrs: nounwind uwtable
define void @gimp_image_set_save_a_copy_uri(%struct._GimpImage* %image, i8* %uri) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %uri.addr = alloca i8*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store i8* %uri, i8** %uri.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([31 x i8], [31 x i8]* @__func__.gimp_image_set_save_a_copy_uri, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call11 = call i8* @gimp_image_get_save_a_copy_uri(%struct._GimpImage* %13)
  %14 = load i8*, i8** %uri.addr, align 8
  %cmp12 = icmp eq i8* %call11, %14
  br i1 %cmp12, label %if.then.13, label %if.end.14

if.then.13:                                       ; preds = %do.end
  br label %return

if.end.14:                                        ; preds = %do.end
  %15 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %16 = bitcast %struct._GimpImage* %15 to %struct._GTypeInstance*
  %call15 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %16, i64 80)
  %17 = bitcast %struct._GTypeInstance* %call15 to %struct._GObject*
  %18 = load i8*, i8** %uri.addr, align 8
  %call16 = call noalias i8* @g_strdup(i8* %18)
  call void @g_object_set_data_full(%struct._GObject* %17, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.12, i32 0, i32 0), i8* %call16, void (i8*)* @g_free)
  br label %return

return:                                           ; preds = %if.end.14, %if.then.13, %if.else.9
  ret void
}

; Function Attrs: nounwind uwtable
define i8* @gimp_image_get_filename(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca i8*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %uri = alloca i8*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__func__.gimp_image_get_filename, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store i8* null, i8** %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call11 = call i8* @gimp_image_get_uri(%struct._GimpImage* %13)
  store i8* %call11, i8** %uri, align 8
  %14 = load i8*, i8** %uri, align 8
  %tobool12 = icmp ne i8* %14, null
  br i1 %tobool12, label %if.end.14, label %if.then.13

if.then.13:                                       ; preds = %do.end
  store i8* null, i8** %retval
  br label %return

if.end.14:                                        ; preds = %do.end
  %15 = load i8*, i8** %uri, align 8
  %call15 = call noalias i8* @g_filename_from_uri(i8* %15, i8** null, %struct._GError** null)
  store i8* %call15, i8** %retval
  br label %return

return:                                           ; preds = %if.end.14, %if.then.13, %if.else.9
  %16 = load i8*, i8** %retval
  ret i8* %16
}

declare noalias i8* @g_filename_from_uri(i8*, i8**, %struct._GError**) #1

; Function Attrs: nounwind uwtable
define i8* @gimp_image_get_display_name(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca i8*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %private = alloca %struct._GimpImagePrivate*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__func__.gimp_image_get_display_name, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store i8* null, i8** %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %15, %struct._GimpImagePrivate** %private, align 8
  %16 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %display_name = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %16, i32 0, i32 4
  %17 = load i8*, i8** %display_name, align 8
  %tobool13 = icmp ne i8* %17, null
  br i1 %tobool13, label %if.end.17, label %if.then.14

if.then.14:                                       ; preds = %do.end
  %18 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call15 = call i8* @gimp_image_format_display_uri(%struct._GimpImage* %18, i32 1)
  %19 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %display_name16 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %19, i32 0, i32 4
  store i8* %call15, i8** %display_name16, align 8
  br label %if.end.17

if.end.17:                                        ; preds = %if.then.14, %do.end
  %20 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %display_name18 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %20, i32 0, i32 4
  %21 = load i8*, i8** %display_name18, align 8
  store i8* %21, i8** %retval
  br label %return

return:                                           ; preds = %if.end.17, %if.else.9
  %22 = load i8*, i8** %retval
  ret i8* %22
}

; Function Attrs: nounwind uwtable
define internal i8* @gimp_image_format_display_uri(%struct._GimpImage* %image, i32 %basename) #3 {
entry:
  %retval = alloca i8*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %basename.addr = alloca i32, align 4
  %uri_format = alloca i8*, align 8
  %export_status = alloca i8*, align 8
  %uri = alloca i8*, align 8
  %source = alloca i8*, align 8
  %dest = alloca i8*, align 8
  %is_imported = alloca i32, align 4
  %is_exported = alloca i32, align 4
  %display_uri = alloca i8*, align 8
  %format_string = alloca i8*, align 8
  %tmp = alloca i8*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp10 = alloca i32, align 4
  %tmp52 = alloca i8*, align 8
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store i32 %basename, i32* %basename.addr, align 4
  store i8* null, i8** %uri_format, align 8
  store i8* null, i8** %export_status, align 8
  store i8* null, i8** %display_uri, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.9

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool4 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool4, label %land.lhs.true, label %if.else.7

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class5 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class5, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.6, label %if.else.7

if.then.6:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.7:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call8 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call8, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.7, %if.then.6
  br label %if.end.9

if.end.9:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp10
  %12 = load i32, i32* %tmp10
  %tobool11 = icmp ne i32 %12, 0
  br i1 %tobool11, label %if.then.12, label %if.else.13

if.then.12:                                       ; preds = %if.end.9
  br label %if.end.14

if.else.13:                                       ; preds = %if.end.9
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__func__.gimp_image_format_display_uri, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store i8* null, i8** %retval
  br label %return

if.end.14:                                        ; preds = %if.then.12
  br label %do.end

do.end:                                           ; preds = %if.end.14
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call15 = call i8* @gimp_image_get_uri(%struct._GimpImage* %13)
  store i8* %call15, i8** %uri, align 8
  %14 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call16 = call i8* @gimp_image_get_imported_uri(%struct._GimpImage* %14)
  store i8* %call16, i8** %source, align 8
  %15 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call17 = call i8* @gimp_image_get_exported_uri(%struct._GimpImage* %15)
  store i8* %call17, i8** %dest, align 8
  %16 = load i8*, i8** %source, align 8
  %cmp18 = icmp ne i8* %16, null
  %conv = zext i1 %cmp18 to i32
  store i32 %conv, i32* %is_imported, align 4
  %17 = load i8*, i8** %dest, align 8
  %cmp19 = icmp ne i8* %17, null
  %conv20 = zext i1 %cmp19 to i32
  store i32 %conv20, i32* %is_exported, align 4
  %18 = load i8*, i8** %uri, align 8
  %tobool21 = icmp ne i8* %18, null
  br i1 %tobool21, label %if.then.22, label %if.else.24

if.then.22:                                       ; preds = %do.end
  %19 = load i8*, i8** %uri, align 8
  %call23 = call noalias i8* @g_strdup(i8* %19)
  store i8* %call23, i8** %display_uri, align 8
  store i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.123, i32 0, i32 0), i8** %uri_format, align 8
  br label %if.end.55

if.else.24:                                       ; preds = %do.end
  %20 = load i32, i32* %is_imported, align 4
  %tobool25 = icmp ne i32 %20, 0
  br i1 %tobool25, label %if.then.26, label %if.end.28

if.then.26:                                       ; preds = %if.else.24
  %21 = load i8*, i8** %source, align 8
  %call27 = call noalias i8* @g_strdup(i8* %21)
  store i8* %call27, i8** %display_uri, align 8
  br label %if.end.28

if.end.28:                                        ; preds = %if.then.26, %if.else.24
  %22 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call29 = call i32 @gimp_image_is_export_dirty(%struct._GimpImage* %22)
  %tobool30 = icmp ne i32 %call29, 0
  br i1 %tobool30, label %if.else.43, label %if.then.31

if.then.31:                                       ; preds = %if.end.28
  %23 = load i32, i32* %is_exported, align 4
  %tobool32 = icmp ne i32 %23, 0
  br i1 %tobool32, label %if.then.33, label %if.else.36

if.then.33:                                       ; preds = %if.then.31
  %24 = load i8*, i8** %dest, align 8
  %call34 = call noalias i8* @g_strdup(i8* %24)
  store i8* %call34, i8** %display_uri, align 8
  %call35 = call i8* @gettext(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.124, i32 0, i32 0)) #6
  store i8* %call35, i8** %export_status, align 8
  br label %if.end.42

if.else.36:                                       ; preds = %if.then.31
  %25 = load i32, i32* %is_imported, align 4
  %tobool37 = icmp ne i32 %25, 0
  br i1 %tobool37, label %if.then.38, label %if.else.40

if.then.38:                                       ; preds = %if.else.36
  %call39 = call i8* @gettext(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.125, i32 0, i32 0)) #6
  store i8* %call39, i8** %export_status, align 8
  br label %if.end.41

if.else.40:                                       ; preds = %if.else.36
  call void (i8*, ...) @g_warning(i8* getelementptr inbounds ([59 x i8], [59 x i8]* @.str.126, i32 0, i32 0))
  br label %if.end.41

if.end.41:                                        ; preds = %if.else.40, %if.then.38
  br label %if.end.42

if.end.42:                                        ; preds = %if.end.41, %if.then.33
  br label %if.end.48

if.else.43:                                       ; preds = %if.end.28
  %26 = load i32, i32* %is_imported, align 4
  %tobool44 = icmp ne i32 %26, 0
  br i1 %tobool44, label %if.then.45, label %if.end.47

if.then.45:                                       ; preds = %if.else.43
  %call46 = call i8* @gettext(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.127, i32 0, i32 0)) #6
  store i8* %call46, i8** %export_status, align 8
  br label %if.end.47

if.end.47:                                        ; preds = %if.then.45, %if.else.43
  br label %if.end.48

if.end.48:                                        ; preds = %if.end.47, %if.end.42
  %27 = load i8*, i8** %display_uri, align 8
  %tobool49 = icmp ne i8* %27, null
  br i1 %tobool49, label %if.then.50, label %if.end.54

if.then.50:                                       ; preds = %if.end.48
  %28 = load i8*, i8** %display_uri, align 8
  %call53 = call i8* @file_utils_uri_with_new_ext(i8* %28, i8* null)
  store i8* %call53, i8** %tmp52, align 8
  %29 = load i8*, i8** %display_uri, align 8
  call void @g_free(i8* %29)
  %30 = load i8*, i8** %tmp52, align 8
  store i8* %30, i8** %display_uri, align 8
  br label %if.end.54

if.end.54:                                        ; preds = %if.then.50, %if.end.48
  store i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.128, i32 0, i32 0), i8** %uri_format, align 8
  br label %if.end.55

if.end.55:                                        ; preds = %if.end.54, %if.then.22
  %31 = load i8*, i8** %display_uri, align 8
  %tobool56 = icmp ne i8* %31, null
  br i1 %tobool56, label %if.else.60, label %if.then.57

if.then.57:                                       ; preds = %if.end.55
  %call58 = call i8* @gimp_image_get_string_untitled()
  %call59 = call noalias i8* @g_strdup(i8* %call58)
  store i8* %call59, i8** %display_uri, align 8
  br label %if.end.67

if.else.60:                                       ; preds = %if.end.55
  %32 = load i32, i32* %basename.addr, align 4
  %tobool61 = icmp ne i32 %32, 0
  br i1 %tobool61, label %if.then.62, label %if.else.64

if.then.62:                                       ; preds = %if.else.60
  %33 = load i8*, i8** %display_uri, align 8
  %call63 = call i8* @file_utils_uri_display_basename(i8* %33)
  store i8* %call63, i8** %tmp, align 8
  %34 = load i8*, i8** %display_uri, align 8
  call void @g_free(i8* %34)
  %35 = load i8*, i8** %tmp, align 8
  store i8* %35, i8** %display_uri, align 8
  br label %if.end.66

if.else.64:                                       ; preds = %if.else.60
  %36 = load i8*, i8** %display_uri, align 8
  %call65 = call i8* @file_utils_uri_display_name(i8* %36)
  store i8* %call65, i8** %tmp, align 8
  %37 = load i8*, i8** %display_uri, align 8
  call void @g_free(i8* %37)
  %38 = load i8*, i8** %tmp, align 8
  store i8* %38, i8** %display_uri, align 8
  br label %if.end.66

if.end.66:                                        ; preds = %if.else.64, %if.then.62
  br label %if.end.67

if.end.67:                                        ; preds = %if.end.66, %if.then.57
  %39 = load i8*, i8** %uri_format, align 8
  %40 = load i8*, i8** %export_status, align 8
  %call68 = call noalias i8* (i8*, ...) @g_strconcat(i8* %39, i8* %40, i8* null)
  store i8* %call68, i8** %format_string, align 8
  %41 = load i8*, i8** %format_string, align 8
  %42 = load i8*, i8** %display_uri, align 8
  %call69 = call noalias i8* (i8*, ...) @g_strdup_printf(i8* %41, i8* %42)
  store i8* %call69, i8** %tmp, align 8
  %43 = load i8*, i8** %display_uri, align 8
  call void @g_free(i8* %43)
  %44 = load i8*, i8** %tmp, align 8
  store i8* %44, i8** %display_uri, align 8
  %45 = load i8*, i8** %format_string, align 8
  call void @g_free(i8* %45)
  %46 = load i8*, i8** %display_uri, align 8
  store i8* %46, i8** %retval
  br label %return

return:                                           ; preds = %if.end.67, %if.else.13
  %47 = load i8*, i8** %retval
  ret i8* %47
}

; Function Attrs: nounwind uwtable
define i8* @gimp_image_get_display_path(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca i8*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %private = alloca %struct._GimpImagePrivate*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__func__.gimp_image_get_display_path, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store i8* null, i8** %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %15, %struct._GimpImagePrivate** %private, align 8
  %16 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %display_path = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %16, i32 0, i32 5
  %17 = load i8*, i8** %display_path, align 8
  %tobool13 = icmp ne i8* %17, null
  br i1 %tobool13, label %if.end.17, label %if.then.14

if.then.14:                                       ; preds = %do.end
  %18 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call15 = call i8* @gimp_image_format_display_uri(%struct._GimpImage* %18, i32 0)
  %19 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %display_path16 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %19, i32 0, i32 5
  store i8* %call15, i8** %display_path16, align 8
  br label %if.end.17

if.end.17:                                        ; preds = %if.then.14, %do.end
  %20 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %display_path18 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %20, i32 0, i32 5
  %21 = load i8*, i8** %display_path18, align 8
  store i8* %21, i8** %retval
  br label %return

return:                                           ; preds = %if.end.17, %if.else.9
  %22 = load i8*, i8** %retval
  ret i8* %22
}

; Function Attrs: nounwind uwtable
define void @gimp_image_set_load_proc(%struct._GimpImage* %image, %struct._GimpPlugInProcedure* %proc) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %proc.addr = alloca %struct._GimpPlugInProcedure*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store %struct._GimpPlugInProcedure* %proc, %struct._GimpPlugInProcedure** %proc.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__func__.gimp_image_set_load_proc, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpPlugInProcedure*, %struct._GimpPlugInProcedure** %proc.addr, align 8
  %14 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %15 = bitcast %struct._GimpImage* %14 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %15, i64 %call11)
  %16 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  %load_proc = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %16, i32 0, i32 1
  store %struct._GimpPlugInProcedure* %13, %struct._GimpPlugInProcedure** %load_proc, align 8
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  ret void
}

; Function Attrs: nounwind uwtable
define %struct._GimpPlugInProcedure* @gimp_image_get_load_proc(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca %struct._GimpPlugInProcedure*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__func__.gimp_image_get_load_proc, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store %struct._GimpPlugInProcedure* null, %struct._GimpPlugInProcedure** %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  %load_proc = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %15, i32 0, i32 1
  %16 = load %struct._GimpPlugInProcedure*, %struct._GimpPlugInProcedure** %load_proc, align 8
  store %struct._GimpPlugInProcedure* %16, %struct._GimpPlugInProcedure** %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %17 = load %struct._GimpPlugInProcedure*, %struct._GimpPlugInProcedure** %retval
  ret %struct._GimpPlugInProcedure* %17
}

; Function Attrs: nounwind uwtable
define void @gimp_image_set_save_proc(%struct._GimpImage* %image, %struct._GimpPlugInProcedure* %proc) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %proc.addr = alloca %struct._GimpPlugInProcedure*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store %struct._GimpPlugInProcedure* %proc, %struct._GimpPlugInProcedure** %proc.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__func__.gimp_image_set_save_proc, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpPlugInProcedure*, %struct._GimpPlugInProcedure** %proc.addr, align 8
  %14 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %15 = bitcast %struct._GimpImage* %14 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %15, i64 %call11)
  %16 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  %save_proc = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %16, i32 0, i32 2
  store %struct._GimpPlugInProcedure* %13, %struct._GimpPlugInProcedure** %save_proc, align 8
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  ret void
}

; Function Attrs: nounwind uwtable
define %struct._GimpPlugInProcedure* @gimp_image_get_save_proc(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca %struct._GimpPlugInProcedure*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__func__.gimp_image_get_save_proc, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store %struct._GimpPlugInProcedure* null, %struct._GimpPlugInProcedure** %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  %save_proc = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %15, i32 0, i32 2
  %16 = load %struct._GimpPlugInProcedure*, %struct._GimpPlugInProcedure** %save_proc, align 8
  store %struct._GimpPlugInProcedure* %16, %struct._GimpPlugInProcedure** %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %17 = load %struct._GimpPlugInProcedure*, %struct._GimpPlugInProcedure** %retval
  ret %struct._GimpPlugInProcedure* %17
}

; Function Attrs: nounwind uwtable
define void @gimp_image_set_export_proc(%struct._GimpImage* %image, %struct._GimpPlugInProcedure* %proc) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %proc.addr = alloca %struct._GimpPlugInProcedure*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store %struct._GimpPlugInProcedure* %proc, %struct._GimpPlugInProcedure** %proc.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @__func__.gimp_image_set_export_proc, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpPlugInProcedure*, %struct._GimpPlugInProcedure** %proc.addr, align 8
  %14 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %15 = bitcast %struct._GimpImage* %14 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %15, i64 %call11)
  %16 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  %export_proc = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %16, i32 0, i32 3
  store %struct._GimpPlugInProcedure* %13, %struct._GimpPlugInProcedure** %export_proc, align 8
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  ret void
}

; Function Attrs: nounwind uwtable
define %struct._GimpPlugInProcedure* @gimp_image_get_export_proc(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca %struct._GimpPlugInProcedure*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @__func__.gimp_image_get_export_proc, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store %struct._GimpPlugInProcedure* null, %struct._GimpPlugInProcedure** %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  %export_proc = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %15, i32 0, i32 3
  %16 = load %struct._GimpPlugInProcedure*, %struct._GimpPlugInProcedure** %export_proc, align 8
  store %struct._GimpPlugInProcedure* %16, %struct._GimpPlugInProcedure** %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %17 = load %struct._GimpPlugInProcedure*, %struct._GimpPlugInProcedure** %retval
  ret %struct._GimpPlugInProcedure* %17
}

; Function Attrs: nounwind uwtable
define void @gimp_image_set_resolution(%struct._GimpImage* %image, double %xresolution, double %yresolution) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %xresolution.addr = alloca double, align 8
  %yresolution.addr = alloca double, align 8
  %private = alloca %struct._GimpImagePrivate*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store double %xresolution, double* %xresolution.addr, align 8
  store double %yresolution, double* %yresolution.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__func__.gimp_image_set_resolution, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %if.end.50

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %15, %struct._GimpImagePrivate** %private, align 8
  %16 = load double, double* %xresolution.addr, align 8
  %cmp13 = fcmp olt double %16, 5.000000e-03
  br i1 %cmp13, label %if.then.19, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.end
  %17 = load double, double* %xresolution.addr, align 8
  %cmp14 = fcmp ogt double %17, 6.553600e+04
  br i1 %cmp14, label %if.then.19, label %lor.lhs.false.15

lor.lhs.false.15:                                 ; preds = %lor.lhs.false
  %18 = load double, double* %yresolution.addr, align 8
  %cmp16 = fcmp olt double %18, 5.000000e-03
  br i1 %cmp16, label %if.then.19, label %lor.lhs.false.17

lor.lhs.false.17:                                 ; preds = %lor.lhs.false.15
  %19 = load double, double* %yresolution.addr, align 8
  %cmp18 = fcmp ogt double %19, 6.553600e+04
  br i1 %cmp18, label %if.then.19, label %if.end.20

if.then.19:                                       ; preds = %lor.lhs.false.17, %lor.lhs.false.15, %lor.lhs.false, %do.end
  br label %if.end.50

if.end.20:                                        ; preds = %lor.lhs.false.17
  %20 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %xresolution21 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %20, i32 0, i32 8
  %21 = load double, double* %xresolution21, align 8
  %22 = load double, double* %xresolution.addr, align 8
  %sub = fsub double %21, %22
  %cmp22 = fcmp olt double %sub, 0.000000e+00
  br i1 %cmp22, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.20
  %23 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %xresolution23 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %23, i32 0, i32 8
  %24 = load double, double* %xresolution23, align 8
  %25 = load double, double* %xresolution.addr, align 8
  %sub24 = fsub double %24, %25
  %sub25 = fsub double -0.000000e+00, %sub24
  br label %cond.end

cond.false:                                       ; preds = %if.end.20
  %26 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %xresolution26 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %26, i32 0, i32 8
  %27 = load double, double* %xresolution26, align 8
  %28 = load double, double* %xresolution.addr, align 8
  %sub27 = fsub double %27, %28
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi double [ %sub25, %cond.true ], [ %sub27, %cond.false ]
  %cmp28 = fcmp oge double %cond, 1.000000e-05
  br i1 %cmp28, label %if.then.43, label %lor.lhs.false.29

lor.lhs.false.29:                                 ; preds = %cond.end
  %29 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %yresolution30 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %29, i32 0, i32 9
  %30 = load double, double* %yresolution30, align 8
  %31 = load double, double* %yresolution.addr, align 8
  %sub31 = fsub double %30, %31
  %cmp32 = fcmp olt double %sub31, 0.000000e+00
  br i1 %cmp32, label %cond.true.33, label %cond.false.37

cond.true.33:                                     ; preds = %lor.lhs.false.29
  %32 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %yresolution34 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %32, i32 0, i32 9
  %33 = load double, double* %yresolution34, align 8
  %34 = load double, double* %yresolution.addr, align 8
  %sub35 = fsub double %33, %34
  %sub36 = fsub double -0.000000e+00, %sub35
  br label %cond.end.40

cond.false.37:                                    ; preds = %lor.lhs.false.29
  %35 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %yresolution38 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %35, i32 0, i32 9
  %36 = load double, double* %yresolution38, align 8
  %37 = load double, double* %yresolution.addr, align 8
  %sub39 = fsub double %36, %37
  br label %cond.end.40

cond.end.40:                                      ; preds = %cond.false.37, %cond.true.33
  %cond41 = phi double [ %sub36, %cond.true.33 ], [ %sub39, %cond.false.37 ]
  %cmp42 = fcmp oge double %cond41, 1.000000e-05
  br i1 %cmp42, label %if.then.43, label %if.end.50

if.then.43:                                       ; preds = %cond.end.40, %cond.end
  %38 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call44 = call i8* @g_dpgettext(i8* null, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.13, i32 0, i32 0), i64 10)
  %call45 = call %struct._GimpUndo* @gimp_image_undo_push_image_resolution(%struct._GimpImage* %38, i8* %call44)
  %39 = load double, double* %xresolution.addr, align 8
  %40 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %xresolution46 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %40, i32 0, i32 8
  store double %39, double* %xresolution46, align 8
  %41 = load double, double* %yresolution.addr, align 8
  %42 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %yresolution47 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %42, i32 0, i32 9
  store double %41, double* %yresolution47, align 8
  %43 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  call void @gimp_image_resolution_changed(%struct._GimpImage* %43)
  %44 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %45 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call48 = call i32 @gimp_image_get_width(%struct._GimpImage* %45)
  %46 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call49 = call i32 @gimp_image_get_height(%struct._GimpImage* %46)
  call void @gimp_image_size_changed_detailed(%struct._GimpImage* %44, i32 0, i32 0, i32 %call48, i32 %call49)
  br label %if.end.50

if.end.50:                                        ; preds = %if.else.9, %if.then.19, %if.then.43, %cond.end.40
  ret void
}

declare %struct._GimpUndo* @gimp_image_undo_push_image_resolution(%struct._GimpImage*, i8*) #1

declare i8* @g_dpgettext(i8*, i8*, i64) #1

; Function Attrs: nounwind uwtable
define void @gimp_image_resolution_changed(%struct._GimpImage* %image) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__func__.gimp_image_resolution_changed, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to i8*
  %15 = load i32, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 9), align 4
  call void (i8*, i32, i32, ...) @g_signal_emit(i8* %14, i32 %15, i32 0)
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  ret void
}

; Function Attrs: nounwind uwtable
define void @gimp_image_size_changed_detailed(%struct._GimpImage* %image, i32 %previous_origin_x, i32 %previous_origin_y, i32 %previous_width, i32 %previous_height) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %previous_origin_x.addr = alloca i32, align 4
  %previous_origin_y.addr = alloca i32, align 4
  %previous_width.addr = alloca i32, align 4
  %previous_height.addr = alloca i32, align 4
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store i32 %previous_origin_x, i32* %previous_origin_x.addr, align 4
  store i32 %previous_origin_y, i32* %previous_origin_y.addr, align 4
  store i32 %previous_width, i32* %previous_width.addr, align 4
  store i32 %previous_height, i32* %previous_height.addr, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @__func__.gimp_image_size_changed_detailed, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to i8*
  %15 = load i32, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 10), align 4
  %16 = load i32, i32* %previous_origin_x.addr, align 4
  %17 = load i32, i32* %previous_origin_y.addr, align 4
  %18 = load i32, i32* %previous_width.addr, align 4
  %19 = load i32, i32* %previous_height.addr, align 4
  call void (i8*, i32, i32, ...) @g_signal_emit(i8* %14, i32 %15, i32 0, i32 %16, i32 %17, i32 %18, i32 %19)
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @gimp_image_get_width(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca i32, align 4
  %image.addr = alloca %struct._GimpImage*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__func__.gimp_image_get_width, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store i32 0, i32* %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  %width = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %15, i32 0, i32 6
  %16 = load i32, i32* %width, align 4
  store i32 %16, i32* %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %17 = load i32, i32* %retval
  ret i32 %17
}

; Function Attrs: nounwind uwtable
define i32 @gimp_image_get_height(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca i32, align 4
  %image.addr = alloca %struct._GimpImage*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__func__.gimp_image_get_height, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store i32 0, i32* %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  %height = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %15, i32 0, i32 7
  %16 = load i32, i32* %height, align 4
  store i32 %16, i32* %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %17 = load i32, i32* %retval
  ret i32 %17
}

; Function Attrs: nounwind uwtable
define void @gimp_image_get_resolution(%struct._GimpImage* %image, double* %xresolution, double* %yresolution) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %xresolution.addr = alloca double*, align 8
  %yresolution.addr = alloca double*, align 8
  %private = alloca %struct._GimpImagePrivate*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store double* %xresolution, double** %xresolution.addr, align 8
  store double* %yresolution, double** %yresolution.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__func__.gimp_image_get_resolution, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  br label %do.body.11

do.body.11:                                       ; preds = %do.end
  %13 = load double*, double** %xresolution.addr, align 8
  %cmp12 = icmp ne double* %13, null
  br i1 %cmp12, label %land.lhs.true.13, label %if.else.16

land.lhs.true.13:                                 ; preds = %do.body.11
  %14 = load double*, double** %yresolution.addr, align 8
  %cmp14 = icmp ne double* %14, null
  br i1 %cmp14, label %if.then.15, label %if.else.16

if.then.15:                                       ; preds = %land.lhs.true.13
  br label %if.end.17

if.else.16:                                       ; preds = %land.lhs.true.13, %do.body.11
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__func__.gimp_image_get_resolution, i32 0, i32 0), i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.14, i32 0, i32 0))
  br label %return

if.end.17:                                        ; preds = %if.then.15
  br label %do.end.18

do.end.18:                                        ; preds = %if.end.17
  %15 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %16 = bitcast %struct._GimpImage* %15 to %struct._GTypeInstance*
  %call19 = call i64 @gimp_image_get_type() #8
  %call20 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %16, i64 %call19)
  %17 = bitcast i8* %call20 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %17, %struct._GimpImagePrivate** %private, align 8
  %18 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %xresolution21 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %18, i32 0, i32 8
  %19 = load double, double* %xresolution21, align 8
  %20 = load double*, double** %xresolution.addr, align 8
  store double %19, double* %20, align 8
  %21 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %yresolution22 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %21, i32 0, i32 9
  %22 = load double, double* %yresolution22, align 8
  %23 = load double*, double** %yresolution.addr, align 8
  store double %22, double* %23, align 8
  br label %return

return:                                           ; preds = %do.end.18, %if.else.16, %if.else.9
  ret void
}

declare void @g_signal_emit(i8*, i32, i32, ...) #1

; Function Attrs: nounwind uwtable
define void @gimp_image_set_unit(%struct._GimpImage* %image, i32 %unit) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %unit.addr = alloca i32, align 4
  %private = alloca %struct._GimpImagePrivate*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store i32 %unit, i32* %unit.addr, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__func__.gimp_image_set_unit, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %if.end.24

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  br label %do.body.11

do.body.11:                                       ; preds = %do.end
  %13 = load i32, i32* %unit.addr, align 4
  %cmp12 = icmp ugt i32 %13, 0
  br i1 %cmp12, label %if.then.13, label %if.else.14

if.then.13:                                       ; preds = %do.body.11
  br label %if.end.15

if.else.14:                                       ; preds = %do.body.11
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__func__.gimp_image_set_unit, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.15, i32 0, i32 0))
  br label %if.end.24

if.end.15:                                        ; preds = %if.then.13
  br label %do.end.16

do.end.16:                                        ; preds = %if.end.15
  %14 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %15 = bitcast %struct._GimpImage* %14 to %struct._GTypeInstance*
  %call17 = call i64 @gimp_image_get_type() #8
  %call18 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %15, i64 %call17)
  %16 = bitcast i8* %call18 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %16, %struct._GimpImagePrivate** %private, align 8
  %17 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %resolution_unit = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %17, i32 0, i32 10
  %18 = load i32, i32* %resolution_unit, align 4
  %19 = load i32, i32* %unit.addr, align 4
  %cmp19 = icmp ne i32 %18, %19
  br i1 %cmp19, label %if.then.20, label %if.end.24

if.then.20:                                       ; preds = %do.end.16
  %20 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call21 = call i8* @g_dpgettext(i8* null, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.16, i32 0, i32 0), i64 10)
  %call22 = call %struct._GimpUndo* @gimp_image_undo_push_image_resolution(%struct._GimpImage* %20, i8* %call21)
  %21 = load i32, i32* %unit.addr, align 4
  %22 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %resolution_unit23 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %22, i32 0, i32 10
  store i32 %21, i32* %resolution_unit23, align 4
  %23 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  call void @gimp_image_unit_changed(%struct._GimpImage* %23)
  br label %if.end.24

if.end.24:                                        ; preds = %if.else.9, %if.else.14, %if.then.20, %do.end.16
  ret void
}

; Function Attrs: nounwind uwtable
define void @gimp_image_unit_changed(%struct._GimpImage* %image) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__func__.gimp_image_unit_changed, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to i8*
  %15 = load i32, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 11), align 4
  call void (i8*, i32, i32, ...) @g_signal_emit(i8* %14, i32 %15, i32 0)
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @gimp_image_get_unit(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca i32, align 4
  %image.addr = alloca %struct._GimpImage*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__func__.gimp_image_get_unit, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store i32 1, i32* %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  %resolution_unit = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %15, i32 0, i32 10
  %16 = load i32, i32* %resolution_unit, align 4
  store i32 %16, i32* %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %17 = load i32, i32* %retval
  ret i32 %17
}

; Function Attrs: nounwind uwtable
define i32 @gimp_image_has_alpha(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca i32, align 4
  %image.addr = alloca %struct._GimpImage*, align 8
  %private = alloca %struct._GimpImagePrivate*, align 8
  %layer = alloca %struct._GimpLayer*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__func__.gimp_image_has_alpha, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store i32 1, i32* %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %15, %struct._GimpImagePrivate** %private, align 8
  %16 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %layers = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %16, i32 0, i32 27
  %17 = load %struct._GimpItemTree*, %struct._GimpItemTree** %layers, align 8
  %container = getelementptr inbounds %struct._GimpItemTree, %struct._GimpItemTree* %17, i32 0, i32 1
  %18 = load %struct._GimpContainer*, %struct._GimpContainer** %container, align 8
  %call13 = call %struct._GimpObject* @gimp_container_get_first_child(%struct._GimpContainer* %18)
  %19 = bitcast %struct._GimpObject* %call13 to %struct._GTypeInstance*
  %call14 = call i64 @gimp_layer_get_type() #8
  %call15 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %19, i64 %call14)
  %20 = bitcast %struct._GTypeInstance* %call15 to %struct._GimpLayer*
  store %struct._GimpLayer* %20, %struct._GimpLayer** %layer, align 8
  %21 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call16 = call i32 @gimp_image_get_n_layers(%struct._GimpImage* %21)
  %cmp17 = icmp sgt i32 %call16, 1
  br i1 %cmp17, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %do.end
  %22 = load %struct._GimpLayer*, %struct._GimpLayer** %layer, align 8
  %tobool18 = icmp ne %struct._GimpLayer* %22, null
  br i1 %tobool18, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %lor.rhs
  %23 = load %struct._GimpLayer*, %struct._GimpLayer** %layer, align 8
  %24 = bitcast %struct._GimpLayer* %23 to %struct._GTypeInstance*
  %call19 = call i64 @gimp_drawable_get_type() #8
  %call20 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %24, i64 %call19)
  %25 = bitcast %struct._GTypeInstance* %call20 to %struct._GimpDrawable*
  %call21 = call i32 @gimp_drawable_has_alpha(%struct._GimpDrawable* %25)
  %tobool22 = icmp ne i32 %call21, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %lor.rhs
  %26 = phi i1 [ false, %lor.rhs ], [ %tobool22, %land.rhs ]
  br label %lor.end

lor.end:                                          ; preds = %land.end, %do.end
  %27 = phi i1 [ true, %do.end ], [ %26, %land.end ]
  %lor.ext = zext i1 %27 to i32
  store i32 %lor.ext, i32* %retval
  br label %return

return:                                           ; preds = %lor.end, %if.else.9
  %28 = load i32, i32* %retval
  ret i32 %28
}

declare %struct._GimpObject* @gimp_container_get_first_child(%struct._GimpContainer*) #1

; Function Attrs: nounwind readnone
declare i64 @gimp_layer_get_type() #2

; Function Attrs: nounwind uwtable
define i32 @gimp_image_get_n_layers(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca i32, align 4
  %image.addr = alloca %struct._GimpImage*, align 8
  %stack = alloca %struct._GimpItemStack*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__func__.gimp_image_get_n_layers, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store i32 0, i32* %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call11 = call %struct._GimpContainer* @gimp_image_get_layers(%struct._GimpImage* %13)
  %14 = bitcast %struct._GimpContainer* %call11 to %struct._GTypeInstance*
  %call12 = call i64 @gimp_item_stack_get_type() #8
  %call13 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %14, i64 %call12)
  %15 = bitcast %struct._GTypeInstance* %call13 to %struct._GimpItemStack*
  store %struct._GimpItemStack* %15, %struct._GimpItemStack** %stack, align 8
  %16 = load %struct._GimpItemStack*, %struct._GimpItemStack** %stack, align 8
  %call14 = call i32 @gimp_item_stack_get_n_items(%struct._GimpItemStack* %16)
  store i32 %call14, i32* %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %17 = load i32, i32* %retval
  ret i32 %17
}

declare i32 @gimp_drawable_has_alpha(%struct._GimpDrawable*) #1

; Function Attrs: nounwind readnone
declare i64 @gimp_drawable_get_type() #2

; Function Attrs: nounwind uwtable
define i32 @gimp_image_is_empty(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca i32, align 4
  %image.addr = alloca %struct._GimpImage*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__func__.gimp_image_is_empty, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store i32 1, i32* %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  %layers = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %15, i32 0, i32 27
  %16 = load %struct._GimpItemTree*, %struct._GimpItemTree** %layers, align 8
  %container = getelementptr inbounds %struct._GimpItemTree, %struct._GimpItemTree* %16, i32 0, i32 1
  %17 = load %struct._GimpContainer*, %struct._GimpContainer** %container, align 8
  %call13 = call i32 @gimp_container_is_empty(%struct._GimpContainer* %17)
  store i32 %call13, i32* %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %18 = load i32, i32* %retval
  ret i32 %18
}

declare i32 @gimp_container_is_empty(%struct._GimpContainer*) #1

; Function Attrs: nounwind uwtable
define void @gimp_image_set_floating_selection(%struct._GimpImage* %image, %struct._GimpLayer* %floating_sel) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %floating_sel.addr = alloca %struct._GimpLayer*, align 8
  %private = alloca %struct._GimpImagePrivate*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  %__inst14 = alloca %struct._GTypeInstance*, align 8
  %__t16 = alloca i64, align 8
  %__r19 = alloca i32, align 4
  %tmp34 = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store %struct._GimpLayer* %floating_sel, %struct._GimpLayer** %floating_sel.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([34 x i8], [34 x i8]* @__func__.gimp_image_set_floating_selection, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %if.end.46

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  br label %do.body.11

do.body.11:                                       ; preds = %do.end
  %13 = load %struct._GimpLayer*, %struct._GimpLayer** %floating_sel.addr, align 8
  %cmp12 = icmp eq %struct._GimpLayer* %13, null
  br i1 %cmp12, label %if.then.36, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.body.11
  %14 = load %struct._GimpLayer*, %struct._GimpLayer** %floating_sel.addr, align 8
  %15 = bitcast %struct._GimpLayer* %14 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %15, %struct._GTypeInstance** %__inst14, align 8
  %call17 = call i64 @gimp_layer_get_type() #8
  store i64 %call17, i64* %__t16, align 8
  %16 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst14, align 8
  %tobool20 = icmp ne %struct._GTypeInstance* %16, null
  br i1 %tobool20, label %if.else.22, label %if.then.21

if.then.21:                                       ; preds = %lor.lhs.false
  store i32 0, i32* %__r19, align 4
  br label %if.end.33

if.else.22:                                       ; preds = %lor.lhs.false
  %17 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst14, align 8
  %g_class23 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %17, i32 0, i32 0
  %18 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class23, align 8
  %tobool24 = icmp ne %struct._GTypeClass* %18, null
  br i1 %tobool24, label %land.lhs.true.25, label %if.else.30

land.lhs.true.25:                                 ; preds = %if.else.22
  %19 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst14, align 8
  %g_class26 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %19, i32 0, i32 0
  %20 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class26, align 8
  %g_type27 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %20, i32 0, i32 0
  %21 = load i64, i64* %g_type27, align 8
  %22 = load i64, i64* %__t16, align 8
  %cmp28 = icmp eq i64 %21, %22
  br i1 %cmp28, label %if.then.29, label %if.else.30

if.then.29:                                       ; preds = %land.lhs.true.25
  store i32 1, i32* %__r19, align 4
  br label %if.end.32

if.else.30:                                       ; preds = %land.lhs.true.25, %if.else.22
  %23 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst14, align 8
  %24 = load i64, i64* %__t16, align 8
  %call31 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %23, i64 %24) #9
  store i32 %call31, i32* %__r19, align 4
  br label %if.end.32

if.end.32:                                        ; preds = %if.else.30, %if.then.29
  br label %if.end.33

if.end.33:                                        ; preds = %if.end.32, %if.then.21
  %25 = load i32, i32* %__r19, align 4
  store i32 %25, i32* %tmp34
  %26 = load i32, i32* %tmp34
  %tobool35 = icmp ne i32 %26, 0
  br i1 %tobool35, label %if.then.36, label %if.else.37

if.then.36:                                       ; preds = %if.end.33, %do.body.11
  br label %if.end.38

if.else.37:                                       ; preds = %if.end.33
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([34 x i8], [34 x i8]* @__func__.gimp_image_set_floating_selection, i32 0, i32 0), i8* getelementptr inbounds ([53 x i8], [53 x i8]* @.str.17, i32 0, i32 0))
  br label %if.end.46

if.end.38:                                        ; preds = %if.then.36
  br label %do.end.39

do.end.39:                                        ; preds = %if.end.38
  %27 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %28 = bitcast %struct._GimpImage* %27 to %struct._GTypeInstance*
  %call40 = call i64 @gimp_image_get_type() #8
  %call41 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %28, i64 %call40)
  %29 = bitcast i8* %call41 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %29, %struct._GimpImagePrivate** %private, align 8
  %30 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %floating_sel42 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %30, i32 0, i32 34
  %31 = load %struct._GimpLayer*, %struct._GimpLayer** %floating_sel42, align 8
  %32 = load %struct._GimpLayer*, %struct._GimpLayer** %floating_sel.addr, align 8
  %cmp43 = icmp ne %struct._GimpLayer* %31, %32
  br i1 %cmp43, label %if.then.44, label %if.end.46

if.then.44:                                       ; preds = %do.end.39
  %33 = load %struct._GimpLayer*, %struct._GimpLayer** %floating_sel.addr, align 8
  %34 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %floating_sel45 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %34, i32 0, i32 34
  store %struct._GimpLayer* %33, %struct._GimpLayer** %floating_sel45, align 8
  %35 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %flush_accum = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %35, i32 0, i32 47
  %floating_selection_changed = getelementptr inbounds %struct._GimpImageFlushAccumulator, %struct._GimpImageFlushAccumulator* %flush_accum, i32 0, i32 2
  store i32 1, i32* %floating_selection_changed, align 4
  br label %if.end.46

if.end.46:                                        ; preds = %if.else.9, %if.else.37, %if.then.44, %do.end.39
  ret void
}

; Function Attrs: nounwind uwtable
define %struct._GimpLayer* @gimp_image_get_floating_selection(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca %struct._GimpLayer*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([34 x i8], [34 x i8]* @__func__.gimp_image_get_floating_selection, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store %struct._GimpLayer* null, %struct._GimpLayer** %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  %floating_sel = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %15, i32 0, i32 34
  %16 = load %struct._GimpLayer*, %struct._GimpLayer** %floating_sel, align 8
  store %struct._GimpLayer* %16, %struct._GimpLayer** %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %17 = load %struct._GimpLayer*, %struct._GimpLayer** %retval
  ret %struct._GimpLayer* %17
}

; Function Attrs: nounwind uwtable
define void @gimp_image_floating_selection_changed(%struct._GimpImage* %image) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([38 x i8], [38 x i8]* @__func__.gimp_image_floating_selection_changed, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to i8*
  %15 = load i32, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 2), align 4
  call void (i8*, i32, i32, ...) @g_signal_emit(i8* %14, i32 %15, i32 0)
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  ret void
}

; Function Attrs: nounwind uwtable
define %struct._GimpChannel* @gimp_image_get_mask(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca %struct._GimpChannel*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__func__.gimp_image_get_mask, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store %struct._GimpChannel* null, %struct._GimpChannel** %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  %selection_mask = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %15, i32 0, i32 35
  %16 = load %struct._GimpChannel*, %struct._GimpChannel** %selection_mask, align 8
  store %struct._GimpChannel* %16, %struct._GimpChannel** %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %17 = load %struct._GimpChannel*, %struct._GimpChannel** %retval
  ret %struct._GimpChannel* %17
}

; Function Attrs: nounwind uwtable
define void @gimp_image_mask_changed(%struct._GimpImage* %image) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__func__.gimp_image_mask_changed, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to i8*
  %15 = load i32, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 8), align 4
  call void (i8*, i32, i32, ...) @g_signal_emit(i8* %14, i32 %15, i32 0)
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  ret void
}

; Function Attrs: nounwind uwtable
define void @gimp_image_take_mask(%struct._GimpImage* %image, %struct._GimpChannel* %mask) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %mask.addr = alloca %struct._GimpChannel*, align 8
  %private = alloca %struct._GimpImagePrivate*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  %__inst13 = alloca %struct._GTypeInstance*, align 8
  %__t15 = alloca i64, align 8
  %__r18 = alloca i32, align 4
  %tmp33 = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store %struct._GimpChannel* %mask, %struct._GimpChannel** %mask.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__func__.gimp_image_take_mask, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  br label %do.body.11

do.body.11:                                       ; preds = %do.end
  %13 = load %struct._GimpChannel*, %struct._GimpChannel** %mask.addr, align 8
  %14 = bitcast %struct._GimpChannel* %13 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %14, %struct._GTypeInstance** %__inst13, align 8
  %call16 = call i64 @gimp_selection_get_type() #8
  store i64 %call16, i64* %__t15, align 8
  %15 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %tobool19 = icmp ne %struct._GTypeInstance* %15, null
  br i1 %tobool19, label %if.else.21, label %if.then.20

if.then.20:                                       ; preds = %do.body.11
  store i32 0, i32* %__r18, align 4
  br label %if.end.32

if.else.21:                                       ; preds = %do.body.11
  %16 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %g_class22 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %16, i32 0, i32 0
  %17 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class22, align 8
  %tobool23 = icmp ne %struct._GTypeClass* %17, null
  br i1 %tobool23, label %land.lhs.true.24, label %if.else.29

land.lhs.true.24:                                 ; preds = %if.else.21
  %18 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %g_class25 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %18, i32 0, i32 0
  %19 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class25, align 8
  %g_type26 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %19, i32 0, i32 0
  %20 = load i64, i64* %g_type26, align 8
  %21 = load i64, i64* %__t15, align 8
  %cmp27 = icmp eq i64 %20, %21
  br i1 %cmp27, label %if.then.28, label %if.else.29

if.then.28:                                       ; preds = %land.lhs.true.24
  store i32 1, i32* %__r18, align 4
  br label %if.end.31

if.else.29:                                       ; preds = %land.lhs.true.24, %if.else.21
  %22 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %23 = load i64, i64* %__t15, align 8
  %call30 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %22, i64 %23) #9
  store i32 %call30, i32* %__r18, align 4
  br label %if.end.31

if.end.31:                                        ; preds = %if.else.29, %if.then.28
  br label %if.end.32

if.end.32:                                        ; preds = %if.end.31, %if.then.20
  %24 = load i32, i32* %__r18, align 4
  store i32 %24, i32* %tmp33
  %25 = load i32, i32* %tmp33
  %tobool34 = icmp ne i32 %25, 0
  br i1 %tobool34, label %if.then.35, label %if.else.36

if.then.35:                                       ; preds = %if.end.32
  br label %if.end.37

if.else.36:                                       ; preds = %if.end.32
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__func__.gimp_image_take_mask, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.18, i32 0, i32 0))
  br label %return

if.end.37:                                        ; preds = %if.then.35
  br label %do.end.38

do.end.38:                                        ; preds = %if.end.37
  %26 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %27 = bitcast %struct._GimpImage* %26 to %struct._GTypeInstance*
  %call39 = call i64 @gimp_image_get_type() #8
  %call40 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %27, i64 %call39)
  %28 = bitcast i8* %call40 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %28, %struct._GimpImagePrivate** %private, align 8
  %29 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %selection_mask = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %29, i32 0, i32 35
  %30 = load %struct._GimpChannel*, %struct._GimpChannel** %selection_mask, align 8
  %tobool41 = icmp ne %struct._GimpChannel* %30, null
  br i1 %tobool41, label %if.then.42, label %if.end.44

if.then.42:                                       ; preds = %do.end.38
  %31 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %selection_mask43 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %31, i32 0, i32 35
  %32 = load %struct._GimpChannel*, %struct._GimpChannel** %selection_mask43, align 8
  %33 = bitcast %struct._GimpChannel* %32 to i8*
  call void @g_object_unref(i8* %33)
  br label %if.end.44

if.end.44:                                        ; preds = %if.then.42, %do.end.38
  %34 = load %struct._GimpChannel*, %struct._GimpChannel** %mask.addr, align 8
  %35 = bitcast %struct._GimpChannel* %34 to i8*
  %call45 = call i8* @g_object_ref_sink(i8* %35)
  %36 = bitcast i8* %call45 to %struct._GimpChannel*
  %37 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %selection_mask46 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %37, i32 0, i32 35
  store %struct._GimpChannel* %36, %struct._GimpChannel** %selection_mask46, align 8
  %38 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %selection_mask47 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %38, i32 0, i32 35
  %39 = load %struct._GimpChannel*, %struct._GimpChannel** %selection_mask47, align 8
  %40 = bitcast %struct._GimpChannel* %39 to i8*
  %41 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %42 = bitcast %struct._GimpImage* %41 to i8*
  %call48 = call i64 @g_signal_connect_data(i8* %40, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.19, i32 0, i32 0), void ()* bitcast (void (%struct._GimpDrawable*, i32, i32, i32, i32, %struct._GimpImage*)* @gimp_image_mask_update to void ()*), i8* %42, void (i8*, %struct._GClosure*)* null, i32 0)
  br label %return

return:                                           ; preds = %if.end.44, %if.else.36, %if.else.9
  ret void
}

; Function Attrs: nounwind readnone
declare i64 @gimp_selection_get_type() #2

declare void @g_object_unref(i8*) #1

declare i8* @g_object_ref_sink(i8*) #1

declare i64 @g_signal_connect_data(i8*, i8*, void ()*, i8*, void (i8*, %struct._GClosure*)*, i32) #1

; Function Attrs: nounwind uwtable
define internal void @gimp_image_mask_update(%struct._GimpDrawable* %drawable, i32 %x, i32 %y, i32 %width, i32 %height, %struct._GimpImage* %image) #3 {
entry:
  %drawable.addr = alloca %struct._GimpDrawable*, align 8
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %width.addr = alloca i32, align 4
  %height.addr = alloca i32, align 4
  %image.addr = alloca %struct._GimpImage*, align 8
  store %struct._GimpDrawable* %drawable, %struct._GimpDrawable** %drawable.addr, align 8
  store i32 %x, i32* %x.addr, align 4
  store i32 %y, i32* %y.addr, align 4
  store i32 %width, i32* %width.addr, align 4
  store i32 %height, i32* %height.addr, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  %call = call i64 @gimp_image_get_type() #8
  %call1 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %1, i64 %call)
  %2 = bitcast i8* %call1 to %struct._GimpImagePrivate*
  %flush_accum = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %2, i32 0, i32 47
  %mask_changed = getelementptr inbounds %struct._GimpImageFlushAccumulator, %struct._GimpImageFlushAccumulator* %flush_accum, i32 0, i32 1
  store i32 1, i32* %mask_changed, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @gimp_image_get_component_index(%struct._GimpImage* %image, i32 %channel) #3 {
entry:
  %retval = alloca i32, align 4
  %image.addr = alloca %struct._GimpImage*, align 8
  %channel.addr = alloca i32, align 4
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store i32 %channel, i32* %channel.addr, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([31 x i8], [31 x i8]* @__func__.gimp_image_get_component_index, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store i32 -1, i32* %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load i32, i32* %channel.addr, align 4
  switch i32 %13, label %sw.epilog.20 [
    i32 0, label %sw.bb
    i32 1, label %sw.bb.11
    i32 2, label %sw.bb.12
    i32 3, label %sw.bb.13
    i32 4, label %sw.bb.14
    i32 5, label %sw.bb.15
  ]

sw.bb:                                            ; preds = %do.end
  store i32 0, i32* %retval
  br label %return

sw.bb.11:                                         ; preds = %do.end
  store i32 1, i32* %retval
  br label %return

sw.bb.12:                                         ; preds = %do.end
  store i32 2, i32* %retval
  br label %return

sw.bb.13:                                         ; preds = %do.end
  store i32 0, i32* %retval
  br label %return

sw.bb.14:                                         ; preds = %do.end
  store i32 0, i32* %retval
  br label %return

sw.bb.15:                                         ; preds = %do.end
  %14 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call16 = call i32 @gimp_image_base_type(%struct._GimpImage* %14)
  switch i32 %call16, label %sw.epilog [
    i32 0, label %sw.bb.17
    i32 1, label %sw.bb.18
    i32 2, label %sw.bb.19
  ]

sw.bb.17:                                         ; preds = %sw.bb.15
  store i32 3, i32* %retval
  br label %return

sw.bb.18:                                         ; preds = %sw.bb.15
  store i32 1, i32* %retval
  br label %return

sw.bb.19:                                         ; preds = %sw.bb.15
  store i32 1, i32* %retval
  br label %return

sw.epilog:                                        ; preds = %sw.bb.15
  br label %sw.epilog.20

sw.epilog.20:                                     ; preds = %sw.epilog, %do.end
  store i32 -1, i32* %retval
  br label %return

return:                                           ; preds = %sw.epilog.20, %sw.bb.19, %sw.bb.18, %sw.bb.17, %sw.bb.14, %sw.bb.13, %sw.bb.12, %sw.bb.11, %sw.bb, %if.else.9
  %15 = load i32, i32* %retval
  ret i32 %15
}

; Function Attrs: nounwind uwtable
define void @gimp_image_set_component_active(%struct._GimpImage* %image, i32 %channel, i32 %active) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %channel.addr = alloca i32, align 4
  %active.addr = alloca i32, align 4
  %private = alloca %struct._GimpImagePrivate*, align 8
  %index = alloca i32, align 4
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  %floating_sel = alloca %struct._GimpLayer*, align 8
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store i32 %channel, i32* %channel.addr, align 4
  store i32 %active, i32* %active.addr, align 4
  store i32 -1, i32* %index, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([32 x i8], [32 x i8]* @__func__.gimp_image_set_component_active, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %if.end.37

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %15, %struct._GimpImagePrivate** %private, align 8
  %16 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %17 = load i32, i32* %channel.addr, align 4
  %call13 = call i32 @gimp_image_get_component_index(%struct._GimpImage* %16, i32 %17)
  store i32 %call13, i32* %index, align 4
  %18 = load i32, i32* %index, align 4
  %cmp14 = icmp ne i32 %18, -1
  br i1 %cmp14, label %land.lhs.true.15, label %if.end.37

land.lhs.true.15:                                 ; preds = %do.end
  %19 = load i32, i32* %active.addr, align 4
  %20 = load i32, i32* %index, align 4
  %idxprom = sext i32 %20 to i64
  %21 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %active16 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %21, i32 0, i32 38
  %arrayidx = getelementptr inbounds [4 x i32], [4 x i32]* %active16, i32 0, i64 %idxprom
  %22 = load i32, i32* %arrayidx, align 4
  %cmp17 = icmp ne i32 %19, %22
  br i1 %cmp17, label %if.then.18, label %if.end.37

if.then.18:                                       ; preds = %land.lhs.true.15
  %23 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call20 = call %struct._GimpLayer* @gimp_image_get_floating_selection(%struct._GimpImage* %23)
  store %struct._GimpLayer* %call20, %struct._GimpLayer** %floating_sel, align 8
  %24 = load i32, i32* %active.addr, align 4
  %tobool21 = icmp ne i32 %24, 0
  %cond = select i1 %tobool21, i32 1, i32 0
  %25 = load i32, i32* %index, align 4
  %idxprom22 = sext i32 %25 to i64
  %26 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %active23 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %26, i32 0, i32 38
  %arrayidx24 = getelementptr inbounds [4 x i32], [4 x i32]* %active23, i32 0, i64 %idxprom22
  store i32 %cond, i32* %arrayidx24, align 4
  %27 = load %struct._GimpLayer*, %struct._GimpLayer** %floating_sel, align 8
  %tobool25 = icmp ne %struct._GimpLayer* %27, null
  br i1 %tobool25, label %if.then.26, label %if.end.35

if.then.26:                                       ; preds = %if.then.18
  %28 = load %struct._GimpLayer*, %struct._GimpLayer** %floating_sel, align 8
  %29 = bitcast %struct._GimpLayer* %28 to %struct._GTypeInstance*
  %call27 = call i64 @gimp_drawable_get_type() #8
  %call28 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %29, i64 %call27)
  %30 = bitcast %struct._GTypeInstance* %call28 to %struct._GimpDrawable*
  %31 = load %struct._GimpLayer*, %struct._GimpLayer** %floating_sel, align 8
  %32 = bitcast %struct._GimpLayer* %31 to %struct._GTypeInstance*
  %call29 = call i64 @gimp_item_get_type() #8
  %call30 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %32, i64 %call29)
  %33 = bitcast %struct._GTypeInstance* %call30 to %struct._GimpItem*
  %call31 = call i32 @gimp_item_get_width(%struct._GimpItem* %33)
  %34 = load %struct._GimpLayer*, %struct._GimpLayer** %floating_sel, align 8
  %35 = bitcast %struct._GimpLayer* %34 to %struct._GTypeInstance*
  %call32 = call i64 @gimp_item_get_type() #8
  %call33 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %35, i64 %call32)
  %36 = bitcast %struct._GTypeInstance* %call33 to %struct._GimpItem*
  %call34 = call i32 @gimp_item_get_height(%struct._GimpItem* %36)
  call void @gimp_drawable_update(%struct._GimpDrawable* %30, i32 0, i32 0, i32 %call31, i32 %call34)
  br label %if.end.35

if.end.35:                                        ; preds = %if.then.26, %if.then.18
  %37 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call36 = call %struct._GimpChannel* @gimp_image_unset_active_channel(%struct._GimpImage* %37)
  %38 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %39 = bitcast %struct._GimpImage* %38 to i8*
  %40 = load i32, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 7), align 4
  %41 = load i32, i32* %channel.addr, align 4
  call void (i8*, i32, i32, ...) @g_signal_emit(i8* %39, i32 %40, i32 0, i32 %41)
  br label %if.end.37

if.end.37:                                        ; preds = %if.else.9, %if.end.35, %land.lhs.true.15, %do.end
  ret void
}

declare void @gimp_drawable_update(%struct._GimpDrawable*, i32, i32, i32, i32) #1

declare i32 @gimp_item_get_width(%struct._GimpItem*) #1

; Function Attrs: nounwind readnone
declare i64 @gimp_item_get_type() #2

declare i32 @gimp_item_get_height(%struct._GimpItem*) #1

; Function Attrs: nounwind uwtable
define %struct._GimpChannel* @gimp_image_unset_active_channel(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca %struct._GimpChannel*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %private = alloca %struct._GimpImagePrivate*, align 8
  %channel = alloca %struct._GimpChannel*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([32 x i8], [32 x i8]* @__func__.gimp_image_unset_active_channel, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store %struct._GimpChannel* null, %struct._GimpChannel** %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %15, %struct._GimpImagePrivate** %private, align 8
  %16 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call13 = call %struct._GimpChannel* @gimp_image_get_active_channel(%struct._GimpImage* %16)
  store %struct._GimpChannel* %call13, %struct._GimpChannel** %channel, align 8
  %17 = load %struct._GimpChannel*, %struct._GimpChannel** %channel, align 8
  %tobool14 = icmp ne %struct._GimpChannel* %17, null
  br i1 %tobool14, label %if.then.15, label %if.end.22

if.then.15:                                       ; preds = %do.end
  %18 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call16 = call %struct._GimpChannel* @gimp_image_set_active_channel(%struct._GimpImage* %18, %struct._GimpChannel* null)
  %19 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %layer_stack = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %19, i32 0, i32 30
  %20 = load %struct._GSList*, %struct._GSList** %layer_stack, align 8
  %tobool17 = icmp ne %struct._GSList* %20, null
  br i1 %tobool17, label %if.then.18, label %if.end.21

if.then.18:                                       ; preds = %if.then.15
  %21 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %22 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %layer_stack19 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %22, i32 0, i32 30
  %23 = load %struct._GSList*, %struct._GSList** %layer_stack19, align 8
  %data = getelementptr inbounds %struct._GSList, %struct._GSList* %23, i32 0, i32 0
  %24 = load i8*, i8** %data, align 8
  %25 = bitcast i8* %24 to %struct._GimpLayer*
  %call20 = call %struct._GimpLayer* @gimp_image_set_active_layer(%struct._GimpImage* %21, %struct._GimpLayer* %25)
  br label %if.end.21

if.end.21:                                        ; preds = %if.then.18, %if.then.15
  br label %if.end.22

if.end.22:                                        ; preds = %if.end.21, %do.end
  %26 = load %struct._GimpChannel*, %struct._GimpChannel** %channel, align 8
  store %struct._GimpChannel* %26, %struct._GimpChannel** %retval
  br label %return

return:                                           ; preds = %if.end.22, %if.else.9
  %27 = load %struct._GimpChannel*, %struct._GimpChannel** %retval
  ret %struct._GimpChannel* %27
}

; Function Attrs: nounwind uwtable
define i32 @gimp_image_get_component_active(%struct._GimpImage* %image, i32 %channel) #3 {
entry:
  %retval = alloca i32, align 4
  %image.addr = alloca %struct._GimpImage*, align 8
  %channel.addr = alloca i32, align 4
  %index = alloca i32, align 4
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store i32 %channel, i32* %channel.addr, align 4
  store i32 -1, i32* %index, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([32 x i8], [32 x i8]* @__func__.gimp_image_get_component_active, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store i32 0, i32* %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = load i32, i32* %channel.addr, align 4
  %call11 = call i32 @gimp_image_get_component_index(%struct._GimpImage* %13, i32 %14)
  store i32 %call11, i32* %index, align 4
  %15 = load i32, i32* %index, align 4
  %cmp12 = icmp ne i32 %15, -1
  br i1 %cmp12, label %if.then.13, label %if.end.16

if.then.13:                                       ; preds = %do.end
  %16 = load i32, i32* %index, align 4
  %idxprom = sext i32 %16 to i64
  %17 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %18 = bitcast %struct._GimpImage* %17 to %struct._GTypeInstance*
  %call14 = call i64 @gimp_image_get_type() #8
  %call15 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %18, i64 %call14)
  %19 = bitcast i8* %call15 to %struct._GimpImagePrivate*
  %active = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %19, i32 0, i32 38
  %arrayidx = getelementptr inbounds [4 x i32], [4 x i32]* %active, i32 0, i64 %idxprom
  %20 = load i32, i32* %arrayidx, align 4
  store i32 %20, i32* %retval
  br label %return

if.end.16:                                        ; preds = %do.end
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.end.16, %if.then.13, %if.else.9
  %21 = load i32, i32* %retval
  ret i32 %21
}

; Function Attrs: nounwind uwtable
define void @gimp_image_get_active_array(%struct._GimpImage* %image, i32* %components) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %components.addr = alloca i32*, align 8
  %private = alloca %struct._GimpImagePrivate*, align 8
  %i = alloca i32, align 4
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store i32* %components, i32** %components.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__func__.gimp_image_get_active_array, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %for.end

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  br label %do.body.11

do.body.11:                                       ; preds = %do.end
  %13 = load i32*, i32** %components.addr, align 8
  %cmp12 = icmp ne i32* %13, null
  br i1 %cmp12, label %if.then.13, label %if.else.14

if.then.13:                                       ; preds = %do.body.11
  br label %if.end.15

if.else.14:                                       ; preds = %do.body.11
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__func__.gimp_image_get_active_array, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.20, i32 0, i32 0))
  br label %for.end

if.end.15:                                        ; preds = %if.then.13
  br label %do.end.16

do.end.16:                                        ; preds = %if.end.15
  %14 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %15 = bitcast %struct._GimpImage* %14 to %struct._GTypeInstance*
  %call17 = call i64 @gimp_image_get_type() #8
  %call18 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %15, i64 %call17)
  %16 = bitcast i8* %call18 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %16, %struct._GimpImagePrivate** %private, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end.16
  %17 = load i32, i32* %i, align 4
  %cmp19 = icmp slt i32 %17, 4
  br i1 %cmp19, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %18 = load i32, i32* %i, align 4
  %idxprom = sext i32 %18 to i64
  %19 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %active = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %19, i32 0, i32 38
  %arrayidx = getelementptr inbounds [4 x i32], [4 x i32]* %active, i32 0, i64 %idxprom
  %20 = load i32, i32* %arrayidx, align 4
  %21 = load i32, i32* %i, align 4
  %idxprom20 = sext i32 %21 to i64
  %22 = load i32*, i32** %components.addr, align 8
  %arrayidx21 = getelementptr inbounds i32, i32* %22, i64 %idxprom20
  store i32 %20, i32* %arrayidx21, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %23 = load i32, i32* %i, align 4
  %inc = add nsw i32 %23, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.else.9, %if.else.14, %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define void @gimp_image_set_component_visible(%struct._GimpImage* %image, i32 %channel, i32 %visible) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %channel.addr = alloca i32, align 4
  %visible.addr = alloca i32, align 4
  %private = alloca %struct._GimpImagePrivate*, align 8
  %index = alloca i32, align 4
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store i32 %channel, i32* %channel.addr, align 4
  store i32 %visible, i32* %visible.addr, align 4
  store i32 -1, i32* %index, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @__func__.gimp_image_set_component_visible, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %if.end.25

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %15, %struct._GimpImagePrivate** %private, align 8
  %16 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %17 = load i32, i32* %channel.addr, align 4
  %call13 = call i32 @gimp_image_get_component_index(%struct._GimpImage* %16, i32 %17)
  store i32 %call13, i32* %index, align 4
  %18 = load i32, i32* %index, align 4
  %cmp14 = icmp ne i32 %18, -1
  br i1 %cmp14, label %land.lhs.true.15, label %if.end.25

land.lhs.true.15:                                 ; preds = %do.end
  %19 = load i32, i32* %visible.addr, align 4
  %20 = load i32, i32* %index, align 4
  %idxprom = sext i32 %20 to i64
  %21 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %visible16 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %21, i32 0, i32 37
  %arrayidx = getelementptr inbounds [4 x i32], [4 x i32]* %visible16, i32 0, i64 %idxprom
  %22 = load i32, i32* %arrayidx, align 4
  %cmp17 = icmp ne i32 %19, %22
  br i1 %cmp17, label %if.then.18, label %if.end.25

if.then.18:                                       ; preds = %land.lhs.true.15
  %23 = load i32, i32* %visible.addr, align 4
  %tobool19 = icmp ne i32 %23, 0
  %cond = select i1 %tobool19, i32 1, i32 0
  %24 = load i32, i32* %index, align 4
  %idxprom20 = sext i32 %24 to i64
  %25 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %visible21 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %25, i32 0, i32 37
  %arrayidx22 = getelementptr inbounds [4 x i32], [4 x i32]* %visible21, i32 0, i64 %idxprom20
  store i32 %cond, i32* %arrayidx22, align 4
  %26 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %27 = bitcast %struct._GimpImage* %26 to i8*
  %28 = load i32, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 6), align 4
  %29 = load i32, i32* %channel.addr, align 4
  call void (i8*, i32, i32, ...) @g_signal_emit(i8* %27, i32 %28, i32 0, i32 %29)
  %30 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %31 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call23 = call i32 @gimp_image_get_width(%struct._GimpImage* %31)
  %32 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call24 = call i32 @gimp_image_get_height(%struct._GimpImage* %32)
  call void @gimp_image_invalidate(%struct._GimpImage* %30, i32 0, i32 0, i32 %call23, i32 %call24)
  br label %if.end.25

if.end.25:                                        ; preds = %if.else.9, %if.then.18, %land.lhs.true.15, %do.end
  ret void
}

; Function Attrs: nounwind uwtable
define void @gimp_image_invalidate(%struct._GimpImage* %image, i32 %x, i32 %y, i32 %width, i32 %height) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %width.addr = alloca i32, align 4
  %height.addr = alloca i32, align 4
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store i32 %x, i32* %x.addr, align 4
  store i32 %y, i32* %y.addr, align 4
  store i32 %width, i32* %width.addr, align 4
  store i32 %height, i32* %height.addr, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__func__.gimp_image_invalidate, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_projectable_interface_get_type() #8
  %call12 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast %struct._GTypeInstance* %call12 to %struct._GimpProjectable*
  %16 = load i32, i32* %x.addr, align 4
  %17 = load i32, i32* %y.addr, align 4
  %18 = load i32, i32* %width.addr, align 4
  %19 = load i32, i32* %height.addr, align 4
  call void @gimp_projectable_invalidate(%struct._GimpProjectable* %15, i32 %16, i32 %17, i32 %18, i32 %19)
  %20 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %21 = bitcast %struct._GimpImage* %20 to %struct._GTypeInstance*
  %call13 = call i64 @gimp_image_get_type() #8
  %call14 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %21, i64 %call13)
  %22 = bitcast i8* %call14 to %struct._GimpImagePrivate*
  %flush_accum = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %22, i32 0, i32 47
  %preview_invalidated = getelementptr inbounds %struct._GimpImageFlushAccumulator, %struct._GimpImageFlushAccumulator* %flush_accum, i32 0, i32 3
  store i32 1, i32* %preview_invalidated, align 4
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @gimp_image_get_component_visible(%struct._GimpImage* %image, i32 %channel) #3 {
entry:
  %retval = alloca i32, align 4
  %image.addr = alloca %struct._GimpImage*, align 8
  %channel.addr = alloca i32, align 4
  %index = alloca i32, align 4
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store i32 %channel, i32* %channel.addr, align 4
  store i32 -1, i32* %index, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @__func__.gimp_image_get_component_visible, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store i32 0, i32* %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = load i32, i32* %channel.addr, align 4
  %call11 = call i32 @gimp_image_get_component_index(%struct._GimpImage* %13, i32 %14)
  store i32 %call11, i32* %index, align 4
  %15 = load i32, i32* %index, align 4
  %cmp12 = icmp ne i32 %15, -1
  br i1 %cmp12, label %if.then.13, label %if.end.16

if.then.13:                                       ; preds = %do.end
  %16 = load i32, i32* %index, align 4
  %idxprom = sext i32 %16 to i64
  %17 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %18 = bitcast %struct._GimpImage* %17 to %struct._GTypeInstance*
  %call14 = call i64 @gimp_image_get_type() #8
  %call15 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %18, i64 %call14)
  %19 = bitcast i8* %call15 to %struct._GimpImagePrivate*
  %visible = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %19, i32 0, i32 37
  %arrayidx = getelementptr inbounds [4 x i32], [4 x i32]* %visible, i32 0, i64 %idxprom
  %20 = load i32, i32* %arrayidx, align 4
  store i32 %20, i32* %retval
  br label %return

if.end.16:                                        ; preds = %do.end
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.end.16, %if.then.13, %if.else.9
  %21 = load i32, i32* %retval
  ret i32 %21
}

; Function Attrs: nounwind uwtable
define void @gimp_image_get_visible_array(%struct._GimpImage* %image, i32* %components) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %components.addr = alloca i32*, align 8
  %private = alloca %struct._GimpImagePrivate*, align 8
  %i = alloca i32, align 4
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store i32* %components, i32** %components.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @__func__.gimp_image_get_visible_array, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %for.end

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  br label %do.body.11

do.body.11:                                       ; preds = %do.end
  %13 = load i32*, i32** %components.addr, align 8
  %cmp12 = icmp ne i32* %13, null
  br i1 %cmp12, label %if.then.13, label %if.else.14

if.then.13:                                       ; preds = %do.body.11
  br label %if.end.15

if.else.14:                                       ; preds = %do.body.11
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @__func__.gimp_image_get_visible_array, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.20, i32 0, i32 0))
  br label %for.end

if.end.15:                                        ; preds = %if.then.13
  br label %do.end.16

do.end.16:                                        ; preds = %if.end.15
  %14 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %15 = bitcast %struct._GimpImage* %14 to %struct._GTypeInstance*
  %call17 = call i64 @gimp_image_get_type() #8
  %call18 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %15, i64 %call17)
  %16 = bitcast i8* %call18 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %16, %struct._GimpImagePrivate** %private, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end.16
  %17 = load i32, i32* %i, align 4
  %cmp19 = icmp slt i32 %17, 4
  br i1 %cmp19, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %18 = load i32, i32* %i, align 4
  %idxprom = sext i32 %18 to i64
  %19 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %visible = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %19, i32 0, i32 37
  %arrayidx = getelementptr inbounds [4 x i32], [4 x i32]* %visible, i32 0, i64 %idxprom
  %20 = load i32, i32* %arrayidx, align 4
  %21 = load i32, i32* %i, align 4
  %idxprom20 = sext i32 %21 to i64
  %22 = load i32*, i32** %components.addr, align 8
  %arrayidx21 = getelementptr inbounds i32, i32* %22, i64 %idxprom20
  store i32 %20, i32* %arrayidx21, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %23 = load i32, i32* %i, align 4
  %inc = add nsw i32 %23, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.else.9, %if.else.14, %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define void @gimp_image_mode_changed(%struct._GimpImage* %image) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__func__.gimp_image_mode_changed, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to i8*
  %15 = load i32, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 0), align 4
  call void (i8*, i32, i32, ...) @g_signal_emit(i8* %14, i32 %15, i32 0)
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  ret void
}

; Function Attrs: nounwind uwtable
define void @gimp_image_alpha_changed(%struct._GimpImage* %image) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__func__.gimp_image_alpha_changed, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to i8*
  %15 = load i32, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 1), align 4
  call void (i8*, i32, i32, ...) @g_signal_emit(i8* %14, i32 %15, i32 0)
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  ret void
}

declare void @gimp_projectable_invalidate(%struct._GimpProjectable*, i32, i32, i32, i32) #1

; Function Attrs: nounwind uwtable
define void @gimp_image_guide_added(%struct._GimpImage* %image, %struct._GimpGuide* %guide) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %guide.addr = alloca %struct._GimpGuide*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  %__inst13 = alloca %struct._GTypeInstance*, align 8
  %__t15 = alloca i64, align 8
  %__r18 = alloca i32, align 4
  %tmp33 = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store %struct._GimpGuide* %guide, %struct._GimpGuide** %guide.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__func__.gimp_image_guide_added, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  br label %do.body.11

do.body.11:                                       ; preds = %do.end
  %13 = load %struct._GimpGuide*, %struct._GimpGuide** %guide.addr, align 8
  %14 = bitcast %struct._GimpGuide* %13 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %14, %struct._GTypeInstance** %__inst13, align 8
  %call16 = call i64 @gimp_guide_get_type() #8
  store i64 %call16, i64* %__t15, align 8
  %15 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %tobool19 = icmp ne %struct._GTypeInstance* %15, null
  br i1 %tobool19, label %if.else.21, label %if.then.20

if.then.20:                                       ; preds = %do.body.11
  store i32 0, i32* %__r18, align 4
  br label %if.end.32

if.else.21:                                       ; preds = %do.body.11
  %16 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %g_class22 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %16, i32 0, i32 0
  %17 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class22, align 8
  %tobool23 = icmp ne %struct._GTypeClass* %17, null
  br i1 %tobool23, label %land.lhs.true.24, label %if.else.29

land.lhs.true.24:                                 ; preds = %if.else.21
  %18 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %g_class25 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %18, i32 0, i32 0
  %19 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class25, align 8
  %g_type26 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %19, i32 0, i32 0
  %20 = load i64, i64* %g_type26, align 8
  %21 = load i64, i64* %__t15, align 8
  %cmp27 = icmp eq i64 %20, %21
  br i1 %cmp27, label %if.then.28, label %if.else.29

if.then.28:                                       ; preds = %land.lhs.true.24
  store i32 1, i32* %__r18, align 4
  br label %if.end.31

if.else.29:                                       ; preds = %land.lhs.true.24, %if.else.21
  %22 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %23 = load i64, i64* %__t15, align 8
  %call30 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %22, i64 %23) #9
  store i32 %call30, i32* %__r18, align 4
  br label %if.end.31

if.end.31:                                        ; preds = %if.else.29, %if.then.28
  br label %if.end.32

if.end.32:                                        ; preds = %if.end.31, %if.then.20
  %24 = load i32, i32* %__r18, align 4
  store i32 %24, i32* %tmp33
  %25 = load i32, i32* %tmp33
  %tobool34 = icmp ne i32 %25, 0
  br i1 %tobool34, label %if.then.35, label %if.else.36

if.then.35:                                       ; preds = %if.end.32
  br label %if.end.37

if.else.36:                                       ; preds = %if.end.32
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__func__.gimp_image_guide_added, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.21, i32 0, i32 0))
  br label %return

if.end.37:                                        ; preds = %if.then.35
  br label %do.end.38

do.end.38:                                        ; preds = %if.end.37
  %26 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %27 = bitcast %struct._GimpImage* %26 to i8*
  %28 = load i32, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 18), align 4
  %29 = load %struct._GimpGuide*, %struct._GimpGuide** %guide.addr, align 8
  call void (i8*, i32, i32, ...) @g_signal_emit(i8* %27, i32 %28, i32 0, %struct._GimpGuide* %29)
  br label %return

return:                                           ; preds = %do.end.38, %if.else.36, %if.else.9
  ret void
}

; Function Attrs: nounwind readnone
declare i64 @gimp_guide_get_type() #2

; Function Attrs: nounwind uwtable
define void @gimp_image_guide_removed(%struct._GimpImage* %image, %struct._GimpGuide* %guide) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %guide.addr = alloca %struct._GimpGuide*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  %__inst13 = alloca %struct._GTypeInstance*, align 8
  %__t15 = alloca i64, align 8
  %__r18 = alloca i32, align 4
  %tmp33 = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store %struct._GimpGuide* %guide, %struct._GimpGuide** %guide.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__func__.gimp_image_guide_removed, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  br label %do.body.11

do.body.11:                                       ; preds = %do.end
  %13 = load %struct._GimpGuide*, %struct._GimpGuide** %guide.addr, align 8
  %14 = bitcast %struct._GimpGuide* %13 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %14, %struct._GTypeInstance** %__inst13, align 8
  %call16 = call i64 @gimp_guide_get_type() #8
  store i64 %call16, i64* %__t15, align 8
  %15 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %tobool19 = icmp ne %struct._GTypeInstance* %15, null
  br i1 %tobool19, label %if.else.21, label %if.then.20

if.then.20:                                       ; preds = %do.body.11
  store i32 0, i32* %__r18, align 4
  br label %if.end.32

if.else.21:                                       ; preds = %do.body.11
  %16 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %g_class22 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %16, i32 0, i32 0
  %17 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class22, align 8
  %tobool23 = icmp ne %struct._GTypeClass* %17, null
  br i1 %tobool23, label %land.lhs.true.24, label %if.else.29

land.lhs.true.24:                                 ; preds = %if.else.21
  %18 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %g_class25 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %18, i32 0, i32 0
  %19 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class25, align 8
  %g_type26 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %19, i32 0, i32 0
  %20 = load i64, i64* %g_type26, align 8
  %21 = load i64, i64* %__t15, align 8
  %cmp27 = icmp eq i64 %20, %21
  br i1 %cmp27, label %if.then.28, label %if.else.29

if.then.28:                                       ; preds = %land.lhs.true.24
  store i32 1, i32* %__r18, align 4
  br label %if.end.31

if.else.29:                                       ; preds = %land.lhs.true.24, %if.else.21
  %22 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %23 = load i64, i64* %__t15, align 8
  %call30 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %22, i64 %23) #9
  store i32 %call30, i32* %__r18, align 4
  br label %if.end.31

if.end.31:                                        ; preds = %if.else.29, %if.then.28
  br label %if.end.32

if.end.32:                                        ; preds = %if.end.31, %if.then.20
  %24 = load i32, i32* %__r18, align 4
  store i32 %24, i32* %tmp33
  %25 = load i32, i32* %tmp33
  %tobool34 = icmp ne i32 %25, 0
  br i1 %tobool34, label %if.then.35, label %if.else.36

if.then.35:                                       ; preds = %if.end.32
  br label %if.end.37

if.else.36:                                       ; preds = %if.end.32
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__func__.gimp_image_guide_removed, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.21, i32 0, i32 0))
  br label %return

if.end.37:                                        ; preds = %if.then.35
  br label %do.end.38

do.end.38:                                        ; preds = %if.end.37
  %26 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %27 = bitcast %struct._GimpImage* %26 to i8*
  %28 = load i32, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 19), align 4
  %29 = load %struct._GimpGuide*, %struct._GimpGuide** %guide.addr, align 8
  call void (i8*, i32, i32, ...) @g_signal_emit(i8* %27, i32 %28, i32 0, %struct._GimpGuide* %29)
  br label %return

return:                                           ; preds = %do.end.38, %if.else.36, %if.else.9
  ret void
}

; Function Attrs: nounwind uwtable
define void @gimp_image_guide_moved(%struct._GimpImage* %image, %struct._GimpGuide* %guide) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %guide.addr = alloca %struct._GimpGuide*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  %__inst13 = alloca %struct._GTypeInstance*, align 8
  %__t15 = alloca i64, align 8
  %__r18 = alloca i32, align 4
  %tmp33 = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store %struct._GimpGuide* %guide, %struct._GimpGuide** %guide.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__func__.gimp_image_guide_moved, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  br label %do.body.11

do.body.11:                                       ; preds = %do.end
  %13 = load %struct._GimpGuide*, %struct._GimpGuide** %guide.addr, align 8
  %14 = bitcast %struct._GimpGuide* %13 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %14, %struct._GTypeInstance** %__inst13, align 8
  %call16 = call i64 @gimp_guide_get_type() #8
  store i64 %call16, i64* %__t15, align 8
  %15 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %tobool19 = icmp ne %struct._GTypeInstance* %15, null
  br i1 %tobool19, label %if.else.21, label %if.then.20

if.then.20:                                       ; preds = %do.body.11
  store i32 0, i32* %__r18, align 4
  br label %if.end.32

if.else.21:                                       ; preds = %do.body.11
  %16 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %g_class22 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %16, i32 0, i32 0
  %17 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class22, align 8
  %tobool23 = icmp ne %struct._GTypeClass* %17, null
  br i1 %tobool23, label %land.lhs.true.24, label %if.else.29

land.lhs.true.24:                                 ; preds = %if.else.21
  %18 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %g_class25 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %18, i32 0, i32 0
  %19 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class25, align 8
  %g_type26 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %19, i32 0, i32 0
  %20 = load i64, i64* %g_type26, align 8
  %21 = load i64, i64* %__t15, align 8
  %cmp27 = icmp eq i64 %20, %21
  br i1 %cmp27, label %if.then.28, label %if.else.29

if.then.28:                                       ; preds = %land.lhs.true.24
  store i32 1, i32* %__r18, align 4
  br label %if.end.31

if.else.29:                                       ; preds = %land.lhs.true.24, %if.else.21
  %22 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %23 = load i64, i64* %__t15, align 8
  %call30 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %22, i64 %23) #9
  store i32 %call30, i32* %__r18, align 4
  br label %if.end.31

if.end.31:                                        ; preds = %if.else.29, %if.then.28
  br label %if.end.32

if.end.32:                                        ; preds = %if.end.31, %if.then.20
  %24 = load i32, i32* %__r18, align 4
  store i32 %24, i32* %tmp33
  %25 = load i32, i32* %tmp33
  %tobool34 = icmp ne i32 %25, 0
  br i1 %tobool34, label %if.then.35, label %if.else.36

if.then.35:                                       ; preds = %if.end.32
  br label %if.end.37

if.else.36:                                       ; preds = %if.end.32
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__func__.gimp_image_guide_moved, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.21, i32 0, i32 0))
  br label %return

if.end.37:                                        ; preds = %if.then.35
  br label %do.end.38

do.end.38:                                        ; preds = %if.end.37
  %26 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %27 = bitcast %struct._GimpImage* %26 to i8*
  %28 = load i32, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 20), align 4
  %29 = load %struct._GimpGuide*, %struct._GimpGuide** %guide.addr, align 8
  call void (i8*, i32, i32, ...) @g_signal_emit(i8* %27, i32 %28, i32 0, %struct._GimpGuide* %29)
  br label %return

return:                                           ; preds = %do.end.38, %if.else.36, %if.else.9
  ret void
}

; Function Attrs: nounwind uwtable
define void @gimp_image_sample_point_added(%struct._GimpImage* %image, %struct._GimpSamplePoint* %sample_point) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %sample_point.addr = alloca %struct._GimpSamplePoint*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store %struct._GimpSamplePoint* %sample_point, %struct._GimpSamplePoint** %sample_point.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__func__.gimp_image_sample_point_added, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  br label %do.body.11

do.body.11:                                       ; preds = %do.end
  %13 = load %struct._GimpSamplePoint*, %struct._GimpSamplePoint** %sample_point.addr, align 8
  %cmp12 = icmp ne %struct._GimpSamplePoint* %13, null
  br i1 %cmp12, label %if.then.13, label %if.else.14

if.then.13:                                       ; preds = %do.body.11
  br label %if.end.15

if.else.14:                                       ; preds = %do.body.11
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__func__.gimp_image_sample_point_added, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.22, i32 0, i32 0))
  br label %return

if.end.15:                                        ; preds = %if.then.13
  br label %do.end.16

do.end.16:                                        ; preds = %if.end.15
  %14 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %15 = bitcast %struct._GimpImage* %14 to i8*
  %16 = load i32, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 21), align 4
  %17 = load %struct._GimpSamplePoint*, %struct._GimpSamplePoint** %sample_point.addr, align 8
  call void (i8*, i32, i32, ...) @g_signal_emit(i8* %15, i32 %16, i32 0, %struct._GimpSamplePoint* %17)
  br label %return

return:                                           ; preds = %do.end.16, %if.else.14, %if.else.9
  ret void
}

; Function Attrs: nounwind uwtable
define void @gimp_image_sample_point_removed(%struct._GimpImage* %image, %struct._GimpSamplePoint* %sample_point) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %sample_point.addr = alloca %struct._GimpSamplePoint*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store %struct._GimpSamplePoint* %sample_point, %struct._GimpSamplePoint** %sample_point.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([32 x i8], [32 x i8]* @__func__.gimp_image_sample_point_removed, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  br label %do.body.11

do.body.11:                                       ; preds = %do.end
  %13 = load %struct._GimpSamplePoint*, %struct._GimpSamplePoint** %sample_point.addr, align 8
  %cmp12 = icmp ne %struct._GimpSamplePoint* %13, null
  br i1 %cmp12, label %if.then.13, label %if.else.14

if.then.13:                                       ; preds = %do.body.11
  br label %if.end.15

if.else.14:                                       ; preds = %do.body.11
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([32 x i8], [32 x i8]* @__func__.gimp_image_sample_point_removed, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.22, i32 0, i32 0))
  br label %return

if.end.15:                                        ; preds = %if.then.13
  br label %do.end.16

do.end.16:                                        ; preds = %if.end.15
  %14 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %15 = bitcast %struct._GimpImage* %14 to i8*
  %16 = load i32, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 22), align 4
  %17 = load %struct._GimpSamplePoint*, %struct._GimpSamplePoint** %sample_point.addr, align 8
  call void (i8*, i32, i32, ...) @g_signal_emit(i8* %15, i32 %16, i32 0, %struct._GimpSamplePoint* %17)
  br label %return

return:                                           ; preds = %do.end.16, %if.else.14, %if.else.9
  ret void
}

; Function Attrs: nounwind uwtable
define void @gimp_image_sample_point_moved(%struct._GimpImage* %image, %struct._GimpSamplePoint* %sample_point) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %sample_point.addr = alloca %struct._GimpSamplePoint*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store %struct._GimpSamplePoint* %sample_point, %struct._GimpSamplePoint** %sample_point.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__func__.gimp_image_sample_point_moved, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  br label %do.body.11

do.body.11:                                       ; preds = %do.end
  %13 = load %struct._GimpSamplePoint*, %struct._GimpSamplePoint** %sample_point.addr, align 8
  %cmp12 = icmp ne %struct._GimpSamplePoint* %13, null
  br i1 %cmp12, label %if.then.13, label %if.else.14

if.then.13:                                       ; preds = %do.body.11
  br label %if.end.15

if.else.14:                                       ; preds = %do.body.11
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__func__.gimp_image_sample_point_moved, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.22, i32 0, i32 0))
  br label %return

if.end.15:                                        ; preds = %if.then.13
  br label %do.end.16

do.end.16:                                        ; preds = %if.end.15
  %14 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %15 = bitcast %struct._GimpImage* %14 to i8*
  %16 = load i32, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 23), align 4
  %17 = load %struct._GimpSamplePoint*, %struct._GimpSamplePoint** %sample_point.addr, align 8
  call void (i8*, i32, i32, ...) @g_signal_emit(i8* %15, i32 %16, i32 0, %struct._GimpSamplePoint* %17)
  br label %return

return:                                           ; preds = %do.end.16, %if.else.14, %if.else.9
  ret void
}

; Function Attrs: nounwind uwtable
define void @gimp_image_colormap_changed(%struct._GimpImage* %image, i32 %color_index) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %color_index.addr = alloca i32, align 4
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store i32 %color_index, i32* %color_index.addr, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__func__.gimp_image_colormap_changed, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  br label %do.body.11

do.body.11:                                       ; preds = %do.end
  %13 = load i32, i32* %color_index.addr, align 4
  %cmp12 = icmp sge i32 %13, -1
  br i1 %cmp12, label %land.lhs.true.13, label %if.else.18

land.lhs.true.13:                                 ; preds = %do.body.11
  %14 = load i32, i32* %color_index.addr, align 4
  %15 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %16 = bitcast %struct._GimpImage* %15 to %struct._GTypeInstance*
  %call14 = call i64 @gimp_image_get_type() #8
  %call15 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %16, i64 %call14)
  %17 = bitcast i8* %call15 to %struct._GimpImagePrivate*
  %n_colors = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %17, i32 0, i32 13
  %18 = load i32, i32* %n_colors, align 4
  %cmp16 = icmp slt i32 %14, %18
  br i1 %cmp16, label %if.then.17, label %if.else.18

if.then.17:                                       ; preds = %land.lhs.true.13
  br label %if.end.19

if.else.18:                                       ; preds = %land.lhs.true.13, %do.body.11
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__func__.gimp_image_colormap_changed, i32 0, i32 0), i8* getelementptr inbounds ([76 x i8], [76 x i8]* @.str.23, i32 0, i32 0))
  br label %return

if.end.19:                                        ; preds = %if.then.17
  br label %do.end.20

do.end.20:                                        ; preds = %if.end.19
  %19 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %20 = bitcast %struct._GimpImage* %19 to i8*
  %21 = load i32, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 26), align 4
  %22 = load i32, i32* %color_index.addr, align 4
  call void (i8*, i32, i32, ...) @g_signal_emit(i8* %20, i32 %21, i32 0, i32 %22)
  br label %return

return:                                           ; preds = %do.end.20, %if.else.18, %if.else.9
  ret void
}

; Function Attrs: nounwind uwtable
define void @gimp_image_selection_invalidate(%struct._GimpImage* %image) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([32 x i8], [32 x i8]* @__func__.gimp_image_selection_invalidate, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to i8*
  %15 = load i32, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 13), align 4
  call void (i8*, i32, i32, ...) @g_signal_emit(i8* %14, i32 %15, i32 0)
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  ret void
}

; Function Attrs: nounwind uwtable
define void @gimp_image_quick_mask_changed(%struct._GimpImage* %image) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__func__.gimp_image_quick_mask_changed, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to i8*
  %15 = load i32, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 12), align 4
  call void (i8*, i32, i32, ...) @g_signal_emit(i8* %14, i32 %15, i32 0)
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  ret void
}

; Function Attrs: nounwind uwtable
define void @gimp_image_undo_event(%struct._GimpImage* %image, i32 %event, %struct._GimpUndo* %undo) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %event.addr = alloca i32, align 4
  %undo.addr = alloca %struct._GimpUndo*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  %__inst20 = alloca %struct._GTypeInstance*, align 8
  %__t22 = alloca i64, align 8
  %__r25 = alloca i32, align 4
  %tmp40 = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store i32 %event, i32* %event.addr, align 4
  store %struct._GimpUndo* %undo, %struct._GimpUndo** %undo.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__func__.gimp_image_undo_event, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  br label %do.body.11

do.body.11:                                       ; preds = %do.end
  %13 = load i32, i32* %event.addr, align 4
  %cmp12 = icmp eq i32 %13, 5
  br i1 %cmp12, label %land.lhs.true.16, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.body.11
  %14 = load i32, i32* %event.addr, align 4
  %cmp13 = icmp eq i32 %14, 6
  br i1 %cmp13, label %land.lhs.true.16, label %lor.lhs.false.14

lor.lhs.false.14:                                 ; preds = %lor.lhs.false
  %15 = load i32, i32* %event.addr, align 4
  %cmp15 = icmp eq i32 %15, 7
  br i1 %cmp15, label %land.lhs.true.16, label %lor.lhs.false.18

land.lhs.true.16:                                 ; preds = %lor.lhs.false.14, %lor.lhs.false, %do.body.11
  %16 = load %struct._GimpUndo*, %struct._GimpUndo** %undo.addr, align 8
  %cmp17 = icmp eq %struct._GimpUndo* %16, null
  br i1 %cmp17, label %if.then.42, label %lor.lhs.false.18

lor.lhs.false.18:                                 ; preds = %land.lhs.true.16, %lor.lhs.false.14
  %17 = load %struct._GimpUndo*, %struct._GimpUndo** %undo.addr, align 8
  %18 = bitcast %struct._GimpUndo* %17 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %18, %struct._GTypeInstance** %__inst20, align 8
  %call23 = call i64 @gimp_undo_get_type() #8
  store i64 %call23, i64* %__t22, align 8
  %19 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst20, align 8
  %tobool26 = icmp ne %struct._GTypeInstance* %19, null
  br i1 %tobool26, label %if.else.28, label %if.then.27

if.then.27:                                       ; preds = %lor.lhs.false.18
  store i32 0, i32* %__r25, align 4
  br label %if.end.39

if.else.28:                                       ; preds = %lor.lhs.false.18
  %20 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst20, align 8
  %g_class29 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %20, i32 0, i32 0
  %21 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class29, align 8
  %tobool30 = icmp ne %struct._GTypeClass* %21, null
  br i1 %tobool30, label %land.lhs.true.31, label %if.else.36

land.lhs.true.31:                                 ; preds = %if.else.28
  %22 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst20, align 8
  %g_class32 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %22, i32 0, i32 0
  %23 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class32, align 8
  %g_type33 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %23, i32 0, i32 0
  %24 = load i64, i64* %g_type33, align 8
  %25 = load i64, i64* %__t22, align 8
  %cmp34 = icmp eq i64 %24, %25
  br i1 %cmp34, label %if.then.35, label %if.else.36

if.then.35:                                       ; preds = %land.lhs.true.31
  store i32 1, i32* %__r25, align 4
  br label %if.end.38

if.else.36:                                       ; preds = %land.lhs.true.31, %if.else.28
  %26 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst20, align 8
  %27 = load i64, i64* %__t22, align 8
  %call37 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %26, i64 %27) #9
  store i32 %call37, i32* %__r25, align 4
  br label %if.end.38

if.end.38:                                        ; preds = %if.else.36, %if.then.35
  br label %if.end.39

if.end.39:                                        ; preds = %if.end.38, %if.then.27
  %28 = load i32, i32* %__r25, align 4
  store i32 %28, i32* %tmp40
  %29 = load i32, i32* %tmp40
  %tobool41 = icmp ne i32 %29, 0
  br i1 %tobool41, label %if.then.42, label %if.else.43

if.then.42:                                       ; preds = %if.end.39, %land.lhs.true.16
  br label %if.end.44

if.else.43:                                       ; preds = %if.end.39
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__func__.gimp_image_undo_event, i32 0, i32 0), i8* getelementptr inbounds ([156 x i8], [156 x i8]* @.str.24, i32 0, i32 0))
  br label %return

if.end.44:                                        ; preds = %if.then.42
  br label %do.end.45

do.end.45:                                        ; preds = %if.end.44
  %30 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %31 = bitcast %struct._GimpImage* %30 to i8*
  %32 = load i32, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 27), align 4
  %33 = load i32, i32* %event.addr, align 4
  %34 = load %struct._GimpUndo*, %struct._GimpUndo** %undo.addr, align 8
  call void (i8*, i32, i32, ...) @g_signal_emit(i8* %31, i32 %32, i32 0, i32 %33, %struct._GimpUndo* %34)
  br label %return

return:                                           ; preds = %do.end.45, %if.else.43, %if.else.9
  ret void
}

; Function Attrs: nounwind readnone
declare i64 @gimp_undo_get_type() #2

; Function Attrs: nounwind uwtable
define i32 @gimp_image_dirty(%struct._GimpImage* %image, i32 %dirty_mask) #3 {
entry:
  %retval = alloca i32, align 4
  %image.addr = alloca %struct._GimpImage*, align 8
  %dirty_mask.addr = alloca i32, align 4
  %private = alloca %struct._GimpImagePrivate*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store i32 %dirty_mask, i32* %dirty_mask.addr, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__func__.gimp_image_dirty, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store i32 0, i32* %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %15, %struct._GimpImagePrivate** %private, align 8
  %16 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %dirty = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %16, i32 0, i32 15
  %17 = load i32, i32* %dirty, align 4
  %inc = add nsw i32 %17, 1
  store i32 %inc, i32* %dirty, align 4
  %18 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %export_dirty = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %18, i32 0, i32 17
  %19 = load i32, i32* %export_dirty, align 4
  %inc13 = add nsw i32 %19, 1
  store i32 %inc13, i32* %export_dirty, align 4
  %20 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %dirty_time = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %20, i32 0, i32 16
  %21 = load i32, i32* %dirty_time, align 4
  %tobool14 = icmp ne i32 %21, 0
  br i1 %tobool14, label %if.end.18, label %if.then.15

if.then.15:                                       ; preds = %do.end
  %call16 = call i64 @time(i64* null) #6
  %conv = trunc i64 %call16 to i32
  %22 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %dirty_time17 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %22, i32 0, i32 16
  store i32 %conv, i32* %dirty_time17, align 4
  br label %if.end.18

if.end.18:                                        ; preds = %if.then.15, %do.end
  %23 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %24 = bitcast %struct._GimpImage* %23 to i8*
  %25 = load i32, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 15), align 4
  %26 = load i32, i32* %dirty_mask.addr, align 4
  call void (i8*, i32, i32, ...) @g_signal_emit(i8* %24, i32 %25, i32 0, i32 %26)
  %27 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %dirty19 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %27, i32 0, i32 15
  %28 = load i32, i32* %dirty19, align 4
  store i32 %28, i32* %retval
  br label %return

return:                                           ; preds = %if.end.18, %if.else.9
  %29 = load i32, i32* %retval
  ret i32 %29
}

; Function Attrs: nounwind
declare i64 @time(i64*) #5

; Function Attrs: nounwind uwtable
define i32 @gimp_image_clean(%struct._GimpImage* %image, i32 %dirty_mask) #3 {
entry:
  %retval = alloca i32, align 4
  %image.addr = alloca %struct._GimpImage*, align 8
  %dirty_mask.addr = alloca i32, align 4
  %private = alloca %struct._GimpImagePrivate*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store i32 %dirty_mask, i32* %dirty_mask.addr, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__func__.gimp_image_clean, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store i32 0, i32* %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %15, %struct._GimpImagePrivate** %private, align 8
  %16 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %dirty = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %16, i32 0, i32 15
  %17 = load i32, i32* %dirty, align 4
  %dec = add nsw i32 %17, -1
  store i32 %dec, i32* %dirty, align 4
  %18 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %export_dirty = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %18, i32 0, i32 17
  %19 = load i32, i32* %export_dirty, align 4
  %dec13 = add nsw i32 %19, -1
  store i32 %dec13, i32* %export_dirty, align 4
  %20 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %21 = bitcast %struct._GimpImage* %20 to i8*
  %22 = load i32, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 14), align 4
  %23 = load i32, i32* %dirty_mask.addr, align 4
  call void (i8*, i32, i32, ...) @g_signal_emit(i8* %21, i32 %22, i32 0, i32 %23)
  %24 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %dirty14 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %24, i32 0, i32 15
  %25 = load i32, i32* %dirty14, align 4
  store i32 %25, i32* %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %26 = load i32, i32* %retval
  ret i32 %26
}

; Function Attrs: nounwind uwtable
define void @gimp_image_clean_all(%struct._GimpImage* %image) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %private = alloca %struct._GimpImagePrivate*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__func__.gimp_image_clean_all, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %15, %struct._GimpImagePrivate** %private, align 8
  %16 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %dirty = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %16, i32 0, i32 15
  store i32 0, i32* %dirty, align 4
  %17 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %dirty_time = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %17, i32 0, i32 16
  store i32 0, i32* %dirty_time, align 4
  %18 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %19 = bitcast %struct._GimpImage* %18 to i8*
  %20 = load i32, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 14), align 4
  call void (i8*, i32, i32, ...) @g_signal_emit(i8* %19, i32 %20, i32 0, i32 65535)
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  ret void
}

; Function Attrs: nounwind uwtable
define void @gimp_image_export_clean_all(%struct._GimpImage* %image) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %private = alloca %struct._GimpImagePrivate*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__func__.gimp_image_export_clean_all, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %15, %struct._GimpImagePrivate** %private, align 8
  %16 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %export_dirty = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %16, i32 0, i32 17
  store i32 0, i32* %export_dirty, align 4
  %17 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %18 = bitcast %struct._GimpImage* %17 to i8*
  %19 = load i32, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 14), align 4
  call void (i8*, i32, i32, ...) @g_signal_emit(i8* %18, i32 %19, i32 0, i32 65535)
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @gimp_image_is_dirty(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca i32, align 4
  %image.addr = alloca %struct._GimpImage*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__func__.gimp_image_is_dirty, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store i32 0, i32* %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  %dirty = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %15, i32 0, i32 15
  %16 = load i32, i32* %dirty, align 4
  %cmp13 = icmp ne i32 %16, 0
  %conv = zext i1 %cmp13 to i32
  store i32 %conv, i32* %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %17 = load i32, i32* %retval
  ret i32 %17
}

; Function Attrs: nounwind uwtable
define i32 @gimp_image_is_export_dirty(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca i32, align 4
  %image.addr = alloca %struct._GimpImage*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @__func__.gimp_image_is_export_dirty, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store i32 0, i32* %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  %export_dirty = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %15, i32 0, i32 17
  %16 = load i32, i32* %export_dirty, align 4
  %cmp13 = icmp ne i32 %16, 0
  %conv = zext i1 %cmp13 to i32
  store i32 %conv, i32* %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %17 = load i32, i32* %retval
  ret i32 %17
}

; Function Attrs: nounwind uwtable
define i32 @gimp_image_get_dirty_time(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca i32, align 4
  %image.addr = alloca %struct._GimpImage*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__func__.gimp_image_get_dirty_time, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store i32 0, i32* %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  %dirty_time = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %15, i32 0, i32 16
  %16 = load i32, i32* %dirty_time, align 4
  store i32 %16, i32* %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %17 = load i32, i32* %retval
  ret i32 %17
}

; Function Attrs: nounwind uwtable
define void @gimp_image_saved(%struct._GimpImage* %image, i8* %uri) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %uri.addr = alloca i8*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store i8* %uri, i8** %uri.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__func__.gimp_image_saved, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  br label %do.body.11

do.body.11:                                       ; preds = %do.end
  %13 = load i8*, i8** %uri.addr, align 8
  %cmp12 = icmp ne i8* %13, null
  br i1 %cmp12, label %if.then.13, label %if.else.14

if.then.13:                                       ; preds = %do.body.11
  br label %if.end.15

if.else.14:                                       ; preds = %do.body.11
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__func__.gimp_image_saved, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.25, i32 0, i32 0))
  br label %return

if.end.15:                                        ; preds = %if.then.13
  br label %do.end.16

do.end.16:                                        ; preds = %if.end.15
  %14 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %15 = bitcast %struct._GimpImage* %14 to i8*
  %16 = load i32, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 16), align 4
  %17 = load i8*, i8** %uri.addr, align 8
  call void (i8*, i32, i32, ...) @g_signal_emit(i8* %15, i32 %16, i32 0, i8* %17)
  br label %return

return:                                           ; preds = %do.end.16, %if.else.14, %if.else.9
  ret void
}

; Function Attrs: nounwind uwtable
define void @gimp_image_exported(%struct._GimpImage* %image, i8* %uri) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %uri.addr = alloca i8*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store i8* %uri, i8** %uri.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__func__.gimp_image_exported, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  br label %do.body.11

do.body.11:                                       ; preds = %do.end
  %13 = load i8*, i8** %uri.addr, align 8
  %cmp12 = icmp ne i8* %13, null
  br i1 %cmp12, label %if.then.13, label %if.else.14

if.then.13:                                       ; preds = %do.body.11
  br label %if.end.15

if.else.14:                                       ; preds = %do.body.11
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @__func__.gimp_image_exported, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.25, i32 0, i32 0))
  br label %return

if.end.15:                                        ; preds = %if.then.13
  br label %do.end.16

do.end.16:                                        ; preds = %if.end.15
  %14 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %15 = bitcast %struct._GimpImage* %14 to i8*
  %16 = load i32, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 17), align 4
  %17 = load i8*, i8** %uri.addr, align 8
  call void (i8*, i32, i32, ...) @g_signal_emit(i8* %15, i32 %16, i32 0, i8* %17)
  br label %return

return:                                           ; preds = %do.end.16, %if.else.14, %if.else.9
  ret void
}

; Function Attrs: nounwind uwtable
define void @gimp_image_flush(%struct._GimpImage* %image) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @__func__.gimp_image_flush, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_projectable_interface_get_type() #8
  %call12 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast %struct._GTypeInstance* %call12 to %struct._GimpProjectable*
  %16 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %17 = bitcast %struct._GimpImage* %16 to %struct._GTypeInstance*
  %call13 = call i64 @gimp_image_get_type() #8
  %call14 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %17, i64 %call13)
  %18 = bitcast i8* %call14 to %struct._GimpImagePrivate*
  %flush_accum = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %18, i32 0, i32 47
  %preview_invalidated = getelementptr inbounds %struct._GimpImageFlushAccumulator, %struct._GimpImageFlushAccumulator* %flush_accum, i32 0, i32 3
  %19 = load i32, i32* %preview_invalidated, align 4
  call void @gimp_projectable_flush(%struct._GimpProjectable* %15, i32 %19)
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  ret void
}

declare void @gimp_projectable_flush(%struct._GimpProjectable*, i32) #1

; Function Attrs: nounwind uwtable
define i32 @gimp_image_get_display_count(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca i32, align 4
  %image.addr = alloca %struct._GimpImage*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @__func__.gimp_image_get_display_count, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store i32 0, i32* %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  %disp_count = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %15, i32 0, i32 20
  %16 = load i32, i32* %disp_count, align 4
  store i32 %16, i32* %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %17 = load i32, i32* %retval
  ret i32 %17
}

; Function Attrs: nounwind uwtable
define void @gimp_image_inc_display_count(%struct._GimpImage* %image) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @__func__.gimp_image_inc_display_count, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  %disp_count = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %15, i32 0, i32 20
  %16 = load i32, i32* %disp_count, align 4
  %inc = add nsw i32 %16, 1
  store i32 %inc, i32* %disp_count, align 4
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  ret void
}

; Function Attrs: nounwind uwtable
define void @gimp_image_dec_display_count(%struct._GimpImage* %image) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @__func__.gimp_image_dec_display_count, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  %disp_count = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %15, i32 0, i32 20
  %16 = load i32, i32* %disp_count, align 4
  %dec = add nsw i32 %16, -1
  store i32 %dec, i32* %disp_count, align 4
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @gimp_image_get_instance_count(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca i32, align 4
  %image.addr = alloca %struct._GimpImage*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__func__.gimp_image_get_instance_count, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store i32 0, i32* %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  %instance_count = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %15, i32 0, i32 19
  %16 = load i32, i32* %instance_count, align 4
  store i32 %16, i32* %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %17 = load i32, i32* %retval
  ret i32 %17
}

; Function Attrs: nounwind uwtable
define void @gimp_image_inc_instance_count(%struct._GimpImage* %image) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__func__.gimp_image_inc_instance_count, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  %instance_count = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %15, i32 0, i32 19
  %16 = load i32, i32* %instance_count, align 4
  %inc = add nsw i32 %16, 1
  store i32 %inc, i32* %instance_count, align 4
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  ret void
}

; Function Attrs: nounwind uwtable
define void @gimp_image_get_foreground(%struct._GimpImage* %image, %struct._GimpContext* %context, i32 %dest_type, i8* %fg) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %context.addr = alloca %struct._GimpContext*, align 8
  %dest_type.addr = alloca i32, align 4
  %fg.addr = alloca i8*, align 8
  %color = alloca %struct._GimpRGB, align 8
  %pfg = alloca [3 x i8], align 1
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  %__inst13 = alloca %struct._GTypeInstance*, align 8
  %__t15 = alloca i64, align 8
  %__r18 = alloca i32, align 4
  %tmp33 = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store %struct._GimpContext* %context, %struct._GimpContext** %context.addr, align 8
  store i32 %dest_type, i32* %dest_type.addr, align 4
  store i8* %fg, i8** %fg.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__func__.gimp_image_get_foreground, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  br label %do.body.11

do.body.11:                                       ; preds = %do.end
  %13 = load %struct._GimpContext*, %struct._GimpContext** %context.addr, align 8
  %14 = bitcast %struct._GimpContext* %13 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %14, %struct._GTypeInstance** %__inst13, align 8
  %call16 = call i64 @gimp_context_get_type() #8
  store i64 %call16, i64* %__t15, align 8
  %15 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %tobool19 = icmp ne %struct._GTypeInstance* %15, null
  br i1 %tobool19, label %if.else.21, label %if.then.20

if.then.20:                                       ; preds = %do.body.11
  store i32 0, i32* %__r18, align 4
  br label %if.end.32

if.else.21:                                       ; preds = %do.body.11
  %16 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %g_class22 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %16, i32 0, i32 0
  %17 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class22, align 8
  %tobool23 = icmp ne %struct._GTypeClass* %17, null
  br i1 %tobool23, label %land.lhs.true.24, label %if.else.29

land.lhs.true.24:                                 ; preds = %if.else.21
  %18 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %g_class25 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %18, i32 0, i32 0
  %19 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class25, align 8
  %g_type26 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %19, i32 0, i32 0
  %20 = load i64, i64* %g_type26, align 8
  %21 = load i64, i64* %__t15, align 8
  %cmp27 = icmp eq i64 %20, %21
  br i1 %cmp27, label %if.then.28, label %if.else.29

if.then.28:                                       ; preds = %land.lhs.true.24
  store i32 1, i32* %__r18, align 4
  br label %if.end.31

if.else.29:                                       ; preds = %land.lhs.true.24, %if.else.21
  %22 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %23 = load i64, i64* %__t15, align 8
  %call30 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %22, i64 %23) #9
  store i32 %call30, i32* %__r18, align 4
  br label %if.end.31

if.end.31:                                        ; preds = %if.else.29, %if.then.28
  br label %if.end.32

if.end.32:                                        ; preds = %if.end.31, %if.then.20
  %24 = load i32, i32* %__r18, align 4
  store i32 %24, i32* %tmp33
  %25 = load i32, i32* %tmp33
  %tobool34 = icmp ne i32 %25, 0
  br i1 %tobool34, label %if.then.35, label %if.else.36

if.then.35:                                       ; preds = %if.end.32
  br label %if.end.37

if.else.36:                                       ; preds = %if.end.32
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__func__.gimp_image_get_foreground, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.26, i32 0, i32 0))
  br label %return

if.end.37:                                        ; preds = %if.then.35
  br label %do.end.38

do.end.38:                                        ; preds = %if.end.37
  br label %do.body.39

do.body.39:                                       ; preds = %do.end.38
  %26 = load i8*, i8** %fg.addr, align 8
  %cmp40 = icmp ne i8* %26, null
  br i1 %cmp40, label %if.then.41, label %if.else.42

if.then.41:                                       ; preds = %do.body.39
  br label %if.end.43

if.else.42:                                       ; preds = %do.body.39
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__func__.gimp_image_get_foreground, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.27, i32 0, i32 0))
  br label %return

if.end.43:                                        ; preds = %if.then.41
  br label %do.end.44

do.end.44:                                        ; preds = %if.end.43
  %27 = load %struct._GimpContext*, %struct._GimpContext** %context.addr, align 8
  call void @gimp_context_get_foreground(%struct._GimpContext* %27, %struct._GimpRGB* %color)
  %arrayidx = getelementptr inbounds [3 x i8], [3 x i8]* %pfg, i32 0, i64 0
  %arrayidx45 = getelementptr inbounds [3 x i8], [3 x i8]* %pfg, i32 0, i64 1
  %arrayidx46 = getelementptr inbounds [3 x i8], [3 x i8]* %pfg, i32 0, i64 2
  call void @gimp_rgb_get_uchar(%struct._GimpRGB* %color, i8* %arrayidx, i8* %arrayidx45, i8* %arrayidx46)
  %28 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %29 = load i32, i32* %dest_type.addr, align 4
  %30 = load i8*, i8** %fg.addr, align 8
  %arraydecay = getelementptr inbounds [3 x i8], [3 x i8]* %pfg, i32 0, i32 0
  call void @gimp_image_transform_color(%struct._GimpImage* %28, i32 %29, i8* %30, i32 0, i8* %arraydecay)
  br label %return

return:                                           ; preds = %do.end.44, %if.else.42, %if.else.36, %if.else.9
  ret void
}

; Function Attrs: nounwind readnone
declare i64 @gimp_context_get_type() #2

declare void @gimp_context_get_foreground(%struct._GimpContext*, %struct._GimpRGB*) #1

declare void @gimp_rgb_get_uchar(%struct._GimpRGB*, i8*, i8*, i8*) #1

; Function Attrs: nounwind uwtable
define void @gimp_image_transform_color(%struct._GimpImage* %dest_image, i32 %dest_type, i8* %dest, i32 %src_type, i8* %src) #3 {
entry:
  %dest_image.addr = alloca %struct._GimpImage*, align 8
  %dest_type.addr = alloca i32, align 4
  %dest.addr = alloca i8*, align 8
  %src_type.addr = alloca i32, align 4
  %src.addr = alloca i8*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %dest_image, %struct._GimpImage** %dest_image.addr, align 8
  store i32 %dest_type, i32* %dest_type.addr, align 4
  store i8* %dest, i8** %dest.addr, align 8
  store i32 %src_type, i32* %src_type.addr, align 4
  store i8* %src, i8** %src.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %dest_image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @__func__.gimp_image_transform_color, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.30, i32 0, i32 0))
  br label %sw.epilog.61

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  br label %do.body.11

do.body.11:                                       ; preds = %do.end
  %13 = load i32, i32* %src_type.addr, align 4
  %cmp12 = icmp ne i32 %13, 2
  br i1 %cmp12, label %if.then.13, label %if.else.14

if.then.13:                                       ; preds = %do.body.11
  br label %if.end.15

if.else.14:                                       ; preds = %do.body.11
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @__func__.gimp_image_transform_color, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.33, i32 0, i32 0))
  br label %sw.epilog.61

if.end.15:                                        ; preds = %if.then.13
  br label %do.end.16

do.end.16:                                        ; preds = %if.end.15
  %14 = load i32, i32* %src_type.addr, align 4
  switch i32 %14, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb.45
  ]

sw.bb:                                            ; preds = %do.end.16
  %15 = load i32, i32* %dest_type.addr, align 4
  switch i32 %15, label %sw.epilog [
    i32 0, label %sw.bb.17
    i32 1, label %sw.bb.17
    i32 2, label %sw.bb.23
    i32 3, label %sw.bb.23
    i32 4, label %sw.bb.36
    i32 5, label %sw.bb.36
  ]

sw.bb.17:                                         ; preds = %sw.bb, %sw.bb
  %16 = load i8*, i8** %src.addr, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %16, i32 1
  store i8* %incdec.ptr, i8** %src.addr, align 8
  %17 = load i8, i8* %16, align 1
  %18 = load i8*, i8** %dest.addr, align 8
  %incdec.ptr18 = getelementptr inbounds i8, i8* %18, i32 1
  store i8* %incdec.ptr18, i8** %dest.addr, align 8
  store i8 %17, i8* %18, align 1
  %19 = load i8*, i8** %src.addr, align 8
  %incdec.ptr19 = getelementptr inbounds i8, i8* %19, i32 1
  store i8* %incdec.ptr19, i8** %src.addr, align 8
  %20 = load i8, i8* %19, align 1
  %21 = load i8*, i8** %dest.addr, align 8
  %incdec.ptr20 = getelementptr inbounds i8, i8* %21, i32 1
  store i8* %incdec.ptr20, i8** %dest.addr, align 8
  store i8 %20, i8* %21, align 1
  %22 = load i8*, i8** %src.addr, align 8
  %incdec.ptr21 = getelementptr inbounds i8, i8* %22, i32 1
  store i8* %incdec.ptr21, i8** %src.addr, align 8
  %23 = load i8, i8* %22, align 1
  %24 = load i8*, i8** %dest.addr, align 8
  %incdec.ptr22 = getelementptr inbounds i8, i8* %24, i32 1
  store i8* %incdec.ptr22, i8** %dest.addr, align 8
  store i8 %23, i8* %24, align 1
  br label %sw.epilog

sw.bb.23:                                         ; preds = %sw.bb, %sw.bb
  %25 = load i8*, i8** %src.addr, align 8
  %arrayidx = getelementptr inbounds i8, i8* %25, i64 0
  %26 = load i8, i8* %arrayidx, align 1
  %conv = zext i8 %26 to i32
  %conv24 = sitofp i32 %conv to double
  %mul = fmul double %conv24, 2.126000e-01
  %27 = load i8*, i8** %src.addr, align 8
  %arrayidx25 = getelementptr inbounds i8, i8* %27, i64 1
  %28 = load i8, i8* %arrayidx25, align 1
  %conv26 = zext i8 %28 to i32
  %conv27 = sitofp i32 %conv26 to double
  %mul28 = fmul double %conv27, 7.152000e-01
  %add = fadd double %mul, %mul28
  %29 = load i8*, i8** %src.addr, align 8
  %arrayidx29 = getelementptr inbounds i8, i8* %29, i64 2
  %30 = load i8, i8* %arrayidx29, align 1
  %conv30 = zext i8 %30 to i32
  %conv31 = sitofp i32 %conv30 to double
  %mul32 = fmul double %conv31, 7.220000e-02
  %add33 = fadd double %add, %mul32
  %add34 = fadd double %add33, 5.000000e-01
  %conv35 = fptoui double %add34 to i8
  %31 = load i8*, i8** %dest.addr, align 8
  store i8 %conv35, i8* %31, align 1
  br label %sw.epilog

sw.bb.36:                                         ; preds = %sw.bb, %sw.bb
  %32 = load %struct._GimpImage*, %struct._GimpImage** %dest_image.addr, align 8
  %33 = load i8*, i8** %src.addr, align 8
  %arrayidx37 = getelementptr inbounds i8, i8* %33, i64 0
  %34 = load i8, i8* %arrayidx37, align 1
  %conv38 = zext i8 %34 to i32
  %35 = load i8*, i8** %src.addr, align 8
  %arrayidx39 = getelementptr inbounds i8, i8* %35, i64 1
  %36 = load i8, i8* %arrayidx39, align 1
  %conv40 = zext i8 %36 to i32
  %37 = load i8*, i8** %src.addr, align 8
  %arrayidx41 = getelementptr inbounds i8, i8* %37, i64 2
  %38 = load i8, i8* %arrayidx41, align 1
  %conv42 = zext i8 %38 to i32
  %call43 = call i32 @gimp_image_color_hash_rgb_to_indexed(%struct._GimpImage* %32, i32 %conv38, i32 %conv40, i32 %conv42)
  %conv44 = trunc i32 %call43 to i8
  %39 = load i8*, i8** %dest.addr, align 8
  store i8 %conv44, i8* %39, align 1
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb, %sw.bb.36, %sw.bb.23, %sw.bb.17
  br label %sw.epilog.61

sw.bb.45:                                         ; preds = %do.end.16
  %40 = load i32, i32* %dest_type.addr, align 4
  switch i32 %40, label %sw.epilog.60 [
    i32 0, label %sw.bb.46
    i32 1, label %sw.bb.46
    i32 2, label %sw.bb.50
    i32 3, label %sw.bb.50
    i32 4, label %sw.bb.51
    i32 5, label %sw.bb.51
  ]

sw.bb.46:                                         ; preds = %sw.bb.45, %sw.bb.45
  %41 = load i8*, i8** %src.addr, align 8
  %42 = load i8, i8* %41, align 1
  %43 = load i8*, i8** %dest.addr, align 8
  %incdec.ptr47 = getelementptr inbounds i8, i8* %43, i32 1
  store i8* %incdec.ptr47, i8** %dest.addr, align 8
  store i8 %42, i8* %43, align 1
  %44 = load i8*, i8** %src.addr, align 8
  %45 = load i8, i8* %44, align 1
  %46 = load i8*, i8** %dest.addr, align 8
  %incdec.ptr48 = getelementptr inbounds i8, i8* %46, i32 1
  store i8* %incdec.ptr48, i8** %dest.addr, align 8
  store i8 %45, i8* %46, align 1
  %47 = load i8*, i8** %src.addr, align 8
  %48 = load i8, i8* %47, align 1
  %49 = load i8*, i8** %dest.addr, align 8
  %incdec.ptr49 = getelementptr inbounds i8, i8* %49, i32 1
  store i8* %incdec.ptr49, i8** %dest.addr, align 8
  store i8 %48, i8* %49, align 1
  br label %sw.epilog.60

sw.bb.50:                                         ; preds = %sw.bb.45, %sw.bb.45
  %50 = load i8*, i8** %src.addr, align 8
  %51 = load i8, i8* %50, align 1
  %52 = load i8*, i8** %dest.addr, align 8
  store i8 %51, i8* %52, align 1
  br label %sw.epilog.60

sw.bb.51:                                         ; preds = %sw.bb.45, %sw.bb.45
  %53 = load %struct._GimpImage*, %struct._GimpImage** %dest_image.addr, align 8
  %54 = load i8*, i8** %src.addr, align 8
  %arrayidx52 = getelementptr inbounds i8, i8* %54, i64 0
  %55 = load i8, i8* %arrayidx52, align 1
  %conv53 = zext i8 %55 to i32
  %56 = load i8*, i8** %src.addr, align 8
  %arrayidx54 = getelementptr inbounds i8, i8* %56, i64 0
  %57 = load i8, i8* %arrayidx54, align 1
  %conv55 = zext i8 %57 to i32
  %58 = load i8*, i8** %src.addr, align 8
  %arrayidx56 = getelementptr inbounds i8, i8* %58, i64 0
  %59 = load i8, i8* %arrayidx56, align 1
  %conv57 = zext i8 %59 to i32
  %call58 = call i32 @gimp_image_color_hash_rgb_to_indexed(%struct._GimpImage* %53, i32 %conv53, i32 %conv55, i32 %conv57)
  %conv59 = trunc i32 %call58 to i8
  %60 = load i8*, i8** %dest.addr, align 8
  store i8 %conv59, i8* %60, align 1
  br label %sw.epilog.60

sw.epilog.60:                                     ; preds = %sw.bb.45, %sw.bb.51, %sw.bb.50, %sw.bb.46
  br label %sw.epilog.61

sw.default:                                       ; preds = %do.end.16
  br label %sw.epilog.61

sw.epilog.61:                                     ; preds = %if.else.9, %if.else.14, %sw.default, %sw.epilog.60, %sw.epilog
  ret void
}

; Function Attrs: nounwind uwtable
define void @gimp_image_get_background(%struct._GimpImage* %image, %struct._GimpContext* %context, i32 %dest_type, i8* %bg) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %context.addr = alloca %struct._GimpContext*, align 8
  %dest_type.addr = alloca i32, align 4
  %bg.addr = alloca i8*, align 8
  %color = alloca %struct._GimpRGB, align 8
  %pbg = alloca [3 x i8], align 1
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  %__inst13 = alloca %struct._GTypeInstance*, align 8
  %__t15 = alloca i64, align 8
  %__r18 = alloca i32, align 4
  %tmp33 = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store %struct._GimpContext* %context, %struct._GimpContext** %context.addr, align 8
  store i32 %dest_type, i32* %dest_type.addr, align 4
  store i8* %bg, i8** %bg.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__func__.gimp_image_get_background, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  br label %do.body.11

do.body.11:                                       ; preds = %do.end
  %13 = load %struct._GimpContext*, %struct._GimpContext** %context.addr, align 8
  %14 = bitcast %struct._GimpContext* %13 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %14, %struct._GTypeInstance** %__inst13, align 8
  %call16 = call i64 @gimp_context_get_type() #8
  store i64 %call16, i64* %__t15, align 8
  %15 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %tobool19 = icmp ne %struct._GTypeInstance* %15, null
  br i1 %tobool19, label %if.else.21, label %if.then.20

if.then.20:                                       ; preds = %do.body.11
  store i32 0, i32* %__r18, align 4
  br label %if.end.32

if.else.21:                                       ; preds = %do.body.11
  %16 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %g_class22 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %16, i32 0, i32 0
  %17 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class22, align 8
  %tobool23 = icmp ne %struct._GTypeClass* %17, null
  br i1 %tobool23, label %land.lhs.true.24, label %if.else.29

land.lhs.true.24:                                 ; preds = %if.else.21
  %18 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %g_class25 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %18, i32 0, i32 0
  %19 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class25, align 8
  %g_type26 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %19, i32 0, i32 0
  %20 = load i64, i64* %g_type26, align 8
  %21 = load i64, i64* %__t15, align 8
  %cmp27 = icmp eq i64 %20, %21
  br i1 %cmp27, label %if.then.28, label %if.else.29

if.then.28:                                       ; preds = %land.lhs.true.24
  store i32 1, i32* %__r18, align 4
  br label %if.end.31

if.else.29:                                       ; preds = %land.lhs.true.24, %if.else.21
  %22 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %23 = load i64, i64* %__t15, align 8
  %call30 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %22, i64 %23) #9
  store i32 %call30, i32* %__r18, align 4
  br label %if.end.31

if.end.31:                                        ; preds = %if.else.29, %if.then.28
  br label %if.end.32

if.end.32:                                        ; preds = %if.end.31, %if.then.20
  %24 = load i32, i32* %__r18, align 4
  store i32 %24, i32* %tmp33
  %25 = load i32, i32* %tmp33
  %tobool34 = icmp ne i32 %25, 0
  br i1 %tobool34, label %if.then.35, label %if.else.36

if.then.35:                                       ; preds = %if.end.32
  br label %if.end.37

if.else.36:                                       ; preds = %if.end.32
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__func__.gimp_image_get_background, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.26, i32 0, i32 0))
  br label %return

if.end.37:                                        ; preds = %if.then.35
  br label %do.end.38

do.end.38:                                        ; preds = %if.end.37
  br label %do.body.39

do.body.39:                                       ; preds = %do.end.38
  %26 = load i8*, i8** %bg.addr, align 8
  %cmp40 = icmp ne i8* %26, null
  br i1 %cmp40, label %if.then.41, label %if.else.42

if.then.41:                                       ; preds = %do.body.39
  br label %if.end.43

if.else.42:                                       ; preds = %do.body.39
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__func__.gimp_image_get_background, i32 0, i32 0), i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.28, i32 0, i32 0))
  br label %return

if.end.43:                                        ; preds = %if.then.41
  br label %do.end.44

do.end.44:                                        ; preds = %if.end.43
  %27 = load %struct._GimpContext*, %struct._GimpContext** %context.addr, align 8
  call void @gimp_context_get_background(%struct._GimpContext* %27, %struct._GimpRGB* %color)
  %arrayidx = getelementptr inbounds [3 x i8], [3 x i8]* %pbg, i32 0, i64 0
  %arrayidx45 = getelementptr inbounds [3 x i8], [3 x i8]* %pbg, i32 0, i64 1
  %arrayidx46 = getelementptr inbounds [3 x i8], [3 x i8]* %pbg, i32 0, i64 2
  call void @gimp_rgb_get_uchar(%struct._GimpRGB* %color, i8* %arrayidx, i8* %arrayidx45, i8* %arrayidx46)
  %28 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %29 = load i32, i32* %dest_type.addr, align 4
  %30 = load i8*, i8** %bg.addr, align 8
  %arraydecay = getelementptr inbounds [3 x i8], [3 x i8]* %pbg, i32 0, i32 0
  call void @gimp_image_transform_color(%struct._GimpImage* %28, i32 %29, i8* %30, i32 0, i8* %arraydecay)
  br label %return

return:                                           ; preds = %do.end.44, %if.else.42, %if.else.36, %if.else.9
  ret void
}

declare void @gimp_context_get_background(%struct._GimpContext*, %struct._GimpRGB*) #1

; Function Attrs: nounwind uwtable
define void @gimp_image_get_color(%struct._GimpImage* %src_image, i32 %src_type, i8* %src, i8* %rgba) #3 {
entry:
  %src_image.addr = alloca %struct._GimpImage*, align 8
  %src_type.addr = alloca i32, align 4
  %src.addr = alloca i8*, align 8
  %rgba.addr = alloca i8*, align 8
  %has_alpha = alloca i32, align 4
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  %src_private = alloca %struct._GimpImagePrivate*, align 8
  %index = alloca i32, align 4
  store %struct._GimpImage* %src_image, %struct._GimpImage** %src_image.addr, align 8
  store i32 %src_type, i32* %src_type.addr, align 4
  store i8* %src, i8** %src.addr, align 8
  store i8* %rgba, i8** %rgba.addr, align 8
  store i32 0, i32* %has_alpha, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %src_image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__func__.gimp_image_get_color, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.29, i32 0, i32 0))
  br label %if.end.44

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load i32, i32* %src_type.addr, align 4
  switch i32 %13, label %sw.epilog [
    i32 1, label %sw.bb
    i32 0, label %sw.bb.11
    i32 3, label %sw.bb.17
    i32 2, label %sw.bb.18
    i32 5, label %sw.bb.23
    i32 4, label %sw.bb.24
  ]

sw.bb:                                            ; preds = %do.end
  store i32 1, i32* %has_alpha, align 4
  br label %sw.bb.11

sw.bb.11:                                         ; preds = %do.end, %sw.bb
  %14 = load i8*, i8** %src.addr, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %14, i32 1
  store i8* %incdec.ptr, i8** %src.addr, align 8
  %15 = load i8, i8* %14, align 1
  %16 = load i8*, i8** %rgba.addr, align 8
  %incdec.ptr12 = getelementptr inbounds i8, i8* %16, i32 1
  store i8* %incdec.ptr12, i8** %rgba.addr, align 8
  store i8 %15, i8* %16, align 1
  %17 = load i8*, i8** %src.addr, align 8
  %incdec.ptr13 = getelementptr inbounds i8, i8* %17, i32 1
  store i8* %incdec.ptr13, i8** %src.addr, align 8
  %18 = load i8, i8* %17, align 1
  %19 = load i8*, i8** %rgba.addr, align 8
  %incdec.ptr14 = getelementptr inbounds i8, i8* %19, i32 1
  store i8* %incdec.ptr14, i8** %rgba.addr, align 8
  store i8 %18, i8* %19, align 1
  %20 = load i8*, i8** %src.addr, align 8
  %incdec.ptr15 = getelementptr inbounds i8, i8* %20, i32 1
  store i8* %incdec.ptr15, i8** %src.addr, align 8
  %21 = load i8, i8* %20, align 1
  %22 = load i8*, i8** %rgba.addr, align 8
  %incdec.ptr16 = getelementptr inbounds i8, i8* %22, i32 1
  store i8* %incdec.ptr16, i8** %rgba.addr, align 8
  store i8 %21, i8* %22, align 1
  br label %sw.epilog

sw.bb.17:                                         ; preds = %do.end
  store i32 1, i32* %has_alpha, align 4
  br label %sw.bb.18

sw.bb.18:                                         ; preds = %do.end, %sw.bb.17
  %23 = load i8*, i8** %src.addr, align 8
  %24 = load i8, i8* %23, align 1
  %25 = load i8*, i8** %rgba.addr, align 8
  %incdec.ptr19 = getelementptr inbounds i8, i8* %25, i32 1
  store i8* %incdec.ptr19, i8** %rgba.addr, align 8
  store i8 %24, i8* %25, align 1
  %26 = load i8*, i8** %src.addr, align 8
  %27 = load i8, i8* %26, align 1
  %28 = load i8*, i8** %rgba.addr, align 8
  %incdec.ptr20 = getelementptr inbounds i8, i8* %28, i32 1
  store i8* %incdec.ptr20, i8** %rgba.addr, align 8
  store i8 %27, i8* %28, align 1
  %29 = load i8*, i8** %src.addr, align 8
  %incdec.ptr21 = getelementptr inbounds i8, i8* %29, i32 1
  store i8* %incdec.ptr21, i8** %src.addr, align 8
  %30 = load i8, i8* %29, align 1
  %31 = load i8*, i8** %rgba.addr, align 8
  %incdec.ptr22 = getelementptr inbounds i8, i8* %31, i32 1
  store i8* %incdec.ptr22, i8** %rgba.addr, align 8
  store i8 %30, i8* %31, align 1
  br label %sw.epilog

sw.bb.23:                                         ; preds = %do.end
  store i32 1, i32* %has_alpha, align 4
  br label %sw.bb.24

sw.bb.24:                                         ; preds = %do.end, %sw.bb.23
  %32 = load %struct._GimpImage*, %struct._GimpImage** %src_image.addr, align 8
  %33 = bitcast %struct._GimpImage* %32 to %struct._GTypeInstance*
  %call26 = call i64 @gimp_image_get_type() #8
  %call27 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %33, i64 %call26)
  %34 = bitcast i8* %call27 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %34, %struct._GimpImagePrivate** %src_private, align 8
  %35 = load i8*, i8** %src.addr, align 8
  %incdec.ptr29 = getelementptr inbounds i8, i8* %35, i32 1
  store i8* %incdec.ptr29, i8** %src.addr, align 8
  %36 = load i8, i8* %35, align 1
  %conv = zext i8 %36 to i32
  %mul = mul nsw i32 %conv, 3
  store i32 %mul, i32* %index, align 4
  %37 = load i32, i32* %index, align 4
  %inc = add nsw i32 %37, 1
  store i32 %inc, i32* %index, align 4
  %idxprom = sext i32 %37 to i64
  %38 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %src_private, align 8
  %colormap = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %38, i32 0, i32 12
  %39 = load i8*, i8** %colormap, align 8
  %arrayidx = getelementptr inbounds i8, i8* %39, i64 %idxprom
  %40 = load i8, i8* %arrayidx, align 1
  %41 = load i8*, i8** %rgba.addr, align 8
  %incdec.ptr30 = getelementptr inbounds i8, i8* %41, i32 1
  store i8* %incdec.ptr30, i8** %rgba.addr, align 8
  store i8 %40, i8* %41, align 1
  %42 = load i32, i32* %index, align 4
  %inc31 = add nsw i32 %42, 1
  store i32 %inc31, i32* %index, align 4
  %idxprom32 = sext i32 %42 to i64
  %43 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %src_private, align 8
  %colormap33 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %43, i32 0, i32 12
  %44 = load i8*, i8** %colormap33, align 8
  %arrayidx34 = getelementptr inbounds i8, i8* %44, i64 %idxprom32
  %45 = load i8, i8* %arrayidx34, align 1
  %46 = load i8*, i8** %rgba.addr, align 8
  %incdec.ptr35 = getelementptr inbounds i8, i8* %46, i32 1
  store i8* %incdec.ptr35, i8** %rgba.addr, align 8
  store i8 %45, i8* %46, align 1
  %47 = load i32, i32* %index, align 4
  %inc36 = add nsw i32 %47, 1
  store i32 %inc36, i32* %index, align 4
  %idxprom37 = sext i32 %47 to i64
  %48 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %src_private, align 8
  %colormap38 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %48, i32 0, i32 12
  %49 = load i8*, i8** %colormap38, align 8
  %arrayidx39 = getelementptr inbounds i8, i8* %49, i64 %idxprom37
  %50 = load i8, i8* %arrayidx39, align 1
  %51 = load i8*, i8** %rgba.addr, align 8
  %incdec.ptr40 = getelementptr inbounds i8, i8* %51, i32 1
  store i8* %incdec.ptr40, i8** %rgba.addr, align 8
  store i8 %50, i8* %51, align 1
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end, %sw.bb.24, %sw.bb.18, %sw.bb.11
  %52 = load i32, i32* %has_alpha, align 4
  %tobool41 = icmp ne i32 %52, 0
  br i1 %tobool41, label %if.then.42, label %if.else.43

if.then.42:                                       ; preds = %sw.epilog
  %53 = load i8*, i8** %src.addr, align 8
  %54 = load i8, i8* %53, align 1
  %55 = load i8*, i8** %rgba.addr, align 8
  store i8 %54, i8* %55, align 1
  br label %if.end.44

if.else.43:                                       ; preds = %sw.epilog
  %56 = load i8*, i8** %rgba.addr, align 8
  store i8 -1, i8* %56, align 1
  br label %if.end.44

if.end.44:                                        ; preds = %if.else.9, %if.else.43, %if.then.42
  ret void
}

; Function Attrs: nounwind uwtable
define void @gimp_image_transform_rgb(%struct._GimpImage* %dest_image, i32 %dest_type, %struct._GimpRGB* %rgb, i8* %color) #3 {
entry:
  %dest_image.addr = alloca %struct._GimpImage*, align 8
  %dest_type.addr = alloca i32, align 4
  %rgb.addr = alloca %struct._GimpRGB*, align 8
  %color.addr = alloca i8*, align 8
  %col = alloca [3 x i8], align 1
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %dest_image, %struct._GimpImage** %dest_image.addr, align 8
  store i32 %dest_type, i32* %dest_type.addr, align 4
  store %struct._GimpRGB* %rgb, %struct._GimpRGB** %rgb.addr, align 8
  store i8* %color, i8** %color.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %dest_image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__func__.gimp_image_transform_rgb, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.30, i32 0, i32 0))
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  br label %do.body.11

do.body.11:                                       ; preds = %do.end
  %13 = load %struct._GimpRGB*, %struct._GimpRGB** %rgb.addr, align 8
  %cmp12 = icmp ne %struct._GimpRGB* %13, null
  br i1 %cmp12, label %if.then.13, label %if.else.14

if.then.13:                                       ; preds = %do.body.11
  br label %if.end.15

if.else.14:                                       ; preds = %do.body.11
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__func__.gimp_image_transform_rgb, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.31, i32 0, i32 0))
  br label %return

if.end.15:                                        ; preds = %if.then.13
  br label %do.end.16

do.end.16:                                        ; preds = %if.end.15
  br label %do.body.17

do.body.17:                                       ; preds = %do.end.16
  %14 = load i8*, i8** %color.addr, align 8
  %cmp18 = icmp ne i8* %14, null
  br i1 %cmp18, label %if.then.19, label %if.else.20

if.then.19:                                       ; preds = %do.body.17
  br label %if.end.21

if.else.20:                                       ; preds = %do.body.17
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__func__.gimp_image_transform_rgb, i32 0, i32 0), i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.32, i32 0, i32 0))
  br label %return

if.end.21:                                        ; preds = %if.then.19
  br label %do.end.22

do.end.22:                                        ; preds = %if.end.21
  %15 = load %struct._GimpRGB*, %struct._GimpRGB** %rgb.addr, align 8
  %arrayidx = getelementptr inbounds [3 x i8], [3 x i8]* %col, i32 0, i64 0
  %arrayidx23 = getelementptr inbounds [3 x i8], [3 x i8]* %col, i32 0, i64 1
  %arrayidx24 = getelementptr inbounds [3 x i8], [3 x i8]* %col, i32 0, i64 2
  call void @gimp_rgb_get_uchar(%struct._GimpRGB* %15, i8* %arrayidx, i8* %arrayidx23, i8* %arrayidx24)
  %16 = load %struct._GimpImage*, %struct._GimpImage** %dest_image.addr, align 8
  %17 = load i32, i32* %dest_type.addr, align 4
  %18 = load i8*, i8** %color.addr, align 8
  %arraydecay = getelementptr inbounds [3 x i8], [3 x i8]* %col, i32 0, i32 0
  call void @gimp_image_transform_color(%struct._GimpImage* %16, i32 %17, i8* %18, i32 0, i8* %arraydecay)
  br label %return

return:                                           ; preds = %do.end.22, %if.else.20, %if.else.14, %if.else.9
  ret void
}

declare i32 @gimp_image_color_hash_rgb_to_indexed(%struct._GimpImage*, i32, i32, i32) #1

; Function Attrs: nounwind uwtable
define %struct._TempBuf* @gimp_image_transform_temp_buf(%struct._GimpImage* %dest_image, i32 %dest_type, %struct._TempBuf* %temp_buf, i32* %new_buf) #3 {
entry:
  %retval = alloca %struct._TempBuf*, align 8
  %dest_image.addr = alloca %struct._GimpImage*, align 8
  %dest_type.addr = alloca i32, align 4
  %temp_buf.addr = alloca %struct._TempBuf*, align 8
  %new_buf.addr = alloca i32*, align 8
  %ret_buf = alloca %struct._TempBuf*, align 8
  %ret_buf_type = alloca i32, align 4
  %has_alpha = alloca i32, align 4
  %is_rgb = alloca i32, align 4
  %in_bytes = alloca i32, align 4
  %out_bytes = alloca i32, align 4
  %src = alloca i8*, align 8
  %dest = alloca i8*, align 8
  %size = alloca i32, align 4
  store %struct._GimpImage* %dest_image, %struct._GimpImage** %dest_image.addr, align 8
  store i32 %dest_type, i32* %dest_type.addr, align 4
  store %struct._TempBuf* %temp_buf, %struct._TempBuf** %temp_buf.addr, align 8
  store i32* %new_buf, i32** %new_buf.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %dest_image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  %call = call i64 @gimp_image_get_type() #8
  %call1 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %1, i64 %call)
  %2 = bitcast %struct._GTypeInstance* %call1 to %struct._GimpImage*
  %tobool = icmp ne %struct._GimpImage* %2, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  br label %if.end

if.else:                                          ; preds = %do.body
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__func__.gimp_image_transform_temp_buf, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.34, i32 0, i32 0))
  store %struct._TempBuf* null, %struct._TempBuf** %retval
  br label %return

if.end:                                           ; preds = %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  br label %do.body.2

do.body.2:                                        ; preds = %do.end
  %3 = load %struct._TempBuf*, %struct._TempBuf** %temp_buf.addr, align 8
  %cmp = icmp ne %struct._TempBuf* %3, null
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %do.body.2
  br label %if.end.5

if.else.4:                                        ; preds = %do.body.2
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__func__.gimp_image_transform_temp_buf, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.35, i32 0, i32 0))
  store %struct._TempBuf* null, %struct._TempBuf** %retval
  br label %return

if.end.5:                                         ; preds = %if.then.3
  br label %do.end.6

do.end.6:                                         ; preds = %if.end.5
  br label %do.body.7

do.body.7:                                        ; preds = %do.end.6
  %4 = load i32*, i32** %new_buf.addr, align 8
  %cmp8 = icmp ne i32* %4, null
  br i1 %cmp8, label %if.then.9, label %if.else.10

if.then.9:                                        ; preds = %do.body.7
  br label %if.end.11

if.else.10:                                       ; preds = %do.body.7
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__func__.gimp_image_transform_temp_buf, i32 0, i32 0), i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.36, i32 0, i32 0))
  store %struct._TempBuf* null, %struct._TempBuf** %retval
  br label %return

if.end.11:                                        ; preds = %if.then.9
  br label %do.end.12

do.end.12:                                        ; preds = %if.end.11
  %5 = load %struct._TempBuf*, %struct._TempBuf** %temp_buf.addr, align 8
  %bytes = getelementptr inbounds %struct._TempBuf, %struct._TempBuf* %5, i32 0, i32 0
  %6 = load i32, i32* %bytes, align 4
  store i32 %6, i32* %in_bytes, align 4
  %7 = load i32, i32* %in_bytes, align 4
  %cmp13 = icmp eq i32 %7, 2
  br i1 %cmp13, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %do.end.12
  %8 = load i32, i32* %in_bytes, align 4
  %cmp14 = icmp eq i32 %8, 4
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %do.end.12
  %9 = phi i1 [ true, %do.end.12 ], [ %cmp14, %lor.rhs ]
  %lor.ext = zext i1 %9 to i32
  store i32 %lor.ext, i32* %has_alpha, align 4
  %10 = load i32, i32* %in_bytes, align 4
  %cmp15 = icmp eq i32 %10, 3
  br i1 %cmp15, label %lor.end.18, label %lor.rhs.16

lor.rhs.16:                                       ; preds = %lor.end
  %11 = load i32, i32* %in_bytes, align 4
  %cmp17 = icmp eq i32 %11, 4
  br label %lor.end.18

lor.end.18:                                       ; preds = %lor.rhs.16, %lor.end
  %12 = phi i1 [ true, %lor.end ], [ %cmp17, %lor.rhs.16 ]
  %lor.ext19 = zext i1 %12 to i32
  store i32 %lor.ext19, i32* %is_rgb, align 4
  %13 = load i32, i32* %has_alpha, align 4
  %tobool20 = icmp ne i32 %13, 0
  br i1 %tobool20, label %if.then.21, label %if.else.37

if.then.21:                                       ; preds = %lor.end.18
  %14 = load i32, i32* %dest_type.addr, align 4
  %cmp22 = icmp eq i32 %14, 0
  br i1 %cmp22, label %cond.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then.21
  %15 = load i32, i32* %dest_type.addr, align 4
  %cmp23 = icmp eq i32 %15, 1
  br i1 %cmp23, label %cond.true, label %cond.false

cond.true:                                        ; preds = %lor.lhs.false, %if.then.21
  br label %cond.end.35

cond.false:                                       ; preds = %lor.lhs.false
  %16 = load i32, i32* %dest_type.addr, align 4
  %cmp24 = icmp eq i32 %16, 2
  br i1 %cmp24, label %cond.true.27, label %lor.lhs.false.25

lor.lhs.false.25:                                 ; preds = %cond.false
  %17 = load i32, i32* %dest_type.addr, align 4
  %cmp26 = icmp eq i32 %17, 3
  br i1 %cmp26, label %cond.true.27, label %cond.false.28

cond.true.27:                                     ; preds = %lor.lhs.false.25, %cond.false
  br label %cond.end

cond.false.28:                                    ; preds = %lor.lhs.false.25
  %18 = load i32, i32* %dest_type.addr, align 4
  %cmp29 = icmp eq i32 %18, 4
  br i1 %cmp29, label %lor.end.32, label %lor.rhs.30

lor.rhs.30:                                       ; preds = %cond.false.28
  %19 = load i32, i32* %dest_type.addr, align 4
  %cmp31 = icmp eq i32 %19, 5
  br label %lor.end.32

lor.end.32:                                       ; preds = %lor.rhs.30, %cond.false.28
  %20 = phi i1 [ true, %cond.false.28 ], [ %cmp31, %lor.rhs.30 ]
  %cond = select i1 %20, i32 5, i32 -1
  br label %cond.end

cond.end:                                         ; preds = %lor.end.32, %cond.true.27
  %cond34 = phi i32 [ 3, %cond.true.27 ], [ %cond, %lor.end.32 ]
  br label %cond.end.35

cond.end.35:                                      ; preds = %cond.end, %cond.true
  %cond36 = phi i32 [ 1, %cond.true ], [ %cond34, %cond.end ]
  store i32 %cond36, i32* %ret_buf_type, align 4
  br label %if.end.58

if.else.37:                                       ; preds = %lor.end.18
  %21 = load i32, i32* %dest_type.addr, align 4
  %cmp38 = icmp eq i32 %21, 0
  br i1 %cmp38, label %cond.true.41, label %lor.lhs.false.39

lor.lhs.false.39:                                 ; preds = %if.else.37
  %22 = load i32, i32* %dest_type.addr, align 4
  %cmp40 = icmp eq i32 %22, 1
  br i1 %cmp40, label %cond.true.41, label %cond.false.42

cond.true.41:                                     ; preds = %lor.lhs.false.39, %if.else.37
  br label %cond.end.56

cond.false.42:                                    ; preds = %lor.lhs.false.39
  %23 = load i32, i32* %dest_type.addr, align 4
  %cmp43 = icmp eq i32 %23, 2
  br i1 %cmp43, label %cond.true.46, label %lor.lhs.false.44

lor.lhs.false.44:                                 ; preds = %cond.false.42
  %24 = load i32, i32* %dest_type.addr, align 4
  %cmp45 = icmp eq i32 %24, 3
  br i1 %cmp45, label %cond.true.46, label %cond.false.47

cond.true.46:                                     ; preds = %lor.lhs.false.44, %cond.false.42
  br label %cond.end.54

cond.false.47:                                    ; preds = %lor.lhs.false.44
  %25 = load i32, i32* %dest_type.addr, align 4
  %cmp48 = icmp eq i32 %25, 4
  br i1 %cmp48, label %lor.end.51, label %lor.rhs.49

lor.rhs.49:                                       ; preds = %cond.false.47
  %26 = load i32, i32* %dest_type.addr, align 4
  %cmp50 = icmp eq i32 %26, 5
  br label %lor.end.51

lor.end.51:                                       ; preds = %lor.rhs.49, %cond.false.47
  %27 = phi i1 [ true, %cond.false.47 ], [ %cmp50, %lor.rhs.49 ]
  %cond53 = select i1 %27, i32 4, i32 -1
  br label %cond.end.54

cond.end.54:                                      ; preds = %lor.end.51, %cond.true.46
  %cond55 = phi i32 [ 2, %cond.true.46 ], [ %cond53, %lor.end.51 ]
  br label %cond.end.56

cond.end.56:                                      ; preds = %cond.end.54, %cond.true.41
  %cond57 = phi i32 [ 0, %cond.true.41 ], [ %cond55, %cond.end.54 ]
  store i32 %cond57, i32* %ret_buf_type, align 4
  br label %if.end.58

if.end.58:                                        ; preds = %cond.end.56, %cond.end.35
  %28 = load i32, i32* %ret_buf_type, align 4
  %cmp59 = icmp eq i32 %28, 1
  br i1 %cmp59, label %cond.true.60, label %cond.false.61

cond.true.60:                                     ; preds = %if.end.58
  br label %cond.end.84

cond.false.61:                                    ; preds = %if.end.58
  %29 = load i32, i32* %ret_buf_type, align 4
  %cmp62 = icmp eq i32 %29, 0
  br i1 %cmp62, label %cond.true.63, label %cond.false.64

cond.true.63:                                     ; preds = %cond.false.61
  br label %cond.end.82

cond.false.64:                                    ; preds = %cond.false.61
  %30 = load i32, i32* %ret_buf_type, align 4
  %cmp65 = icmp eq i32 %30, 3
  br i1 %cmp65, label %cond.true.66, label %cond.false.67

cond.true.66:                                     ; preds = %cond.false.64
  br label %cond.end.80

cond.false.67:                                    ; preds = %cond.false.64
  %31 = load i32, i32* %ret_buf_type, align 4
  %cmp68 = icmp eq i32 %31, 2
  br i1 %cmp68, label %cond.true.69, label %cond.false.70

cond.true.69:                                     ; preds = %cond.false.67
  br label %cond.end.78

cond.false.70:                                    ; preds = %cond.false.67
  %32 = load i32, i32* %ret_buf_type, align 4
  %cmp71 = icmp eq i32 %32, 5
  br i1 %cmp71, label %cond.true.72, label %cond.false.73

cond.true.72:                                     ; preds = %cond.false.70
  br label %cond.end.76

cond.false.73:                                    ; preds = %cond.false.70
  %33 = load i32, i32* %ret_buf_type, align 4
  %cmp74 = icmp eq i32 %33, 4
  %cond75 = select i1 %cmp74, i32 1, i32 -1
  br label %cond.end.76

cond.end.76:                                      ; preds = %cond.false.73, %cond.true.72
  %cond77 = phi i32 [ 2, %cond.true.72 ], [ %cond75, %cond.false.73 ]
  br label %cond.end.78

cond.end.78:                                      ; preds = %cond.end.76, %cond.true.69
  %cond79 = phi i32 [ 1, %cond.true.69 ], [ %cond77, %cond.end.76 ]
  br label %cond.end.80

cond.end.80:                                      ; preds = %cond.end.78, %cond.true.66
  %cond81 = phi i32 [ 2, %cond.true.66 ], [ %cond79, %cond.end.78 ]
  br label %cond.end.82

cond.end.82:                                      ; preds = %cond.end.80, %cond.true.63
  %cond83 = phi i32 [ 3, %cond.true.63 ], [ %cond81, %cond.end.80 ]
  br label %cond.end.84

cond.end.84:                                      ; preds = %cond.end.82, %cond.true.60
  %cond85 = phi i32 [ 4, %cond.true.60 ], [ %cond83, %cond.end.82 ]
  store i32 %cond85, i32* %out_bytes, align 4
  %34 = load i32, i32* %in_bytes, align 4
  %35 = load i32, i32* %out_bytes, align 4
  %cmp86 = icmp ne i32 %34, %35
  br i1 %cmp86, label %if.then.91, label %lor.lhs.false.87

lor.lhs.false.87:                                 ; preds = %cond.end.84
  %36 = load i32, i32* %dest_type.addr, align 4
  %cmp88 = icmp eq i32 %36, 4
  br i1 %cmp88, label %if.then.91, label %lor.lhs.false.89

lor.lhs.false.89:                                 ; preds = %lor.lhs.false.87
  %37 = load i32, i32* %dest_type.addr, align 4
  %cmp90 = icmp eq i32 %37, 5
  br i1 %cmp90, label %if.then.91, label %if.else.108

if.then.91:                                       ; preds = %lor.lhs.false.89, %lor.lhs.false.87, %cond.end.84
  %38 = load %struct._TempBuf*, %struct._TempBuf** %temp_buf.addr, align 8
  %width = getelementptr inbounds %struct._TempBuf, %struct._TempBuf* %38, i32 0, i32 1
  %39 = load i32, i32* %width, align 4
  %40 = load %struct._TempBuf*, %struct._TempBuf** %temp_buf.addr, align 8
  %height = getelementptr inbounds %struct._TempBuf, %struct._TempBuf* %40, i32 0, i32 2
  %41 = load i32, i32* %height, align 4
  %42 = load i32, i32* %out_bytes, align 4
  %call92 = call %struct._TempBuf* @temp_buf_new(i32 %39, i32 %41, i32 %42, i32 0, i32 0, i8* null)
  store %struct._TempBuf* %call92, %struct._TempBuf** %ret_buf, align 8
  %43 = load %struct._TempBuf*, %struct._TempBuf** %temp_buf.addr, align 8
  %call93 = call i8* @temp_buf_get_data(%struct._TempBuf* %43)
  store i8* %call93, i8** %src, align 8
  %44 = load %struct._TempBuf*, %struct._TempBuf** %ret_buf, align 8
  %call94 = call i8* @temp_buf_get_data(%struct._TempBuf* %44)
  store i8* %call94, i8** %dest, align 8
  %45 = load %struct._TempBuf*, %struct._TempBuf** %temp_buf.addr, align 8
  %width95 = getelementptr inbounds %struct._TempBuf, %struct._TempBuf* %45, i32 0, i32 1
  %46 = load i32, i32* %width95, align 4
  %47 = load %struct._TempBuf*, %struct._TempBuf** %temp_buf.addr, align 8
  %height96 = getelementptr inbounds %struct._TempBuf, %struct._TempBuf* %47, i32 0, i32 2
  %48 = load i32, i32* %height96, align 4
  %mul = mul nsw i32 %46, %48
  store i32 %mul, i32* %size, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end.105, %if.then.91
  %49 = load i32, i32* %size, align 4
  %dec = add nsw i32 %49, -1
  store i32 %dec, i32* %size, align 4
  %tobool97 = icmp ne i32 %49, 0
  br i1 %tobool97, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %50 = load %struct._GimpImage*, %struct._GimpImage** %dest_image.addr, align 8
  %51 = load i32, i32* %dest_type.addr, align 4
  %52 = load i8*, i8** %dest, align 8
  %53 = load i32, i32* %is_rgb, align 4
  %tobool98 = icmp ne i32 %53, 0
  %cond99 = select i1 %tobool98, i32 0, i32 1
  %54 = load i8*, i8** %src, align 8
  call void @gimp_image_transform_color(%struct._GimpImage* %50, i32 %51, i8* %52, i32 %cond99, i8* %54)
  %55 = load i32, i32* %has_alpha, align 4
  %tobool100 = icmp ne i32 %55, 0
  br i1 %tobool100, label %if.then.101, label %if.end.105

if.then.101:                                      ; preds = %while.body
  %56 = load i32, i32* %in_bytes, align 4
  %sub = sub nsw i32 %56, 1
  %idxprom = sext i32 %sub to i64
  %57 = load i8*, i8** %src, align 8
  %arrayidx = getelementptr inbounds i8, i8* %57, i64 %idxprom
  %58 = load i8, i8* %arrayidx, align 1
  %59 = load i32, i32* %out_bytes, align 4
  %sub102 = sub nsw i32 %59, 1
  %idxprom103 = sext i32 %sub102 to i64
  %60 = load i8*, i8** %dest, align 8
  %arrayidx104 = getelementptr inbounds i8, i8* %60, i64 %idxprom103
  store i8 %58, i8* %arrayidx104, align 1
  br label %if.end.105

if.end.105:                                       ; preds = %if.then.101, %while.body
  %61 = load i32, i32* %in_bytes, align 4
  %62 = load i8*, i8** %src, align 8
  %idx.ext = sext i32 %61 to i64
  %add.ptr = getelementptr inbounds i8, i8* %62, i64 %idx.ext
  store i8* %add.ptr, i8** %src, align 8
  %63 = load i32, i32* %out_bytes, align 4
  %64 = load i8*, i8** %dest, align 8
  %idx.ext106 = sext i32 %63 to i64
  %add.ptr107 = getelementptr inbounds i8, i8* %64, i64 %idx.ext106
  store i8* %add.ptr107, i8** %dest, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %65 = load i32*, i32** %new_buf.addr, align 8
  store i32 1, i32* %65, align 4
  br label %if.end.109

if.else.108:                                      ; preds = %lor.lhs.false.89
  %66 = load %struct._TempBuf*, %struct._TempBuf** %temp_buf.addr, align 8
  store %struct._TempBuf* %66, %struct._TempBuf** %ret_buf, align 8
  %67 = load i32*, i32** %new_buf.addr, align 8
  store i32 0, i32* %67, align 4
  br label %if.end.109

if.end.109:                                       ; preds = %if.else.108, %while.end
  %68 = load %struct._TempBuf*, %struct._TempBuf** %ret_buf, align 8
  store %struct._TempBuf* %68, %struct._TempBuf** %retval
  br label %return

return:                                           ; preds = %if.end.109, %if.else.10, %if.else.4, %if.else
  %69 = load %struct._TempBuf*, %struct._TempBuf** %retval
  ret %struct._TempBuf* %69
}

declare %struct._TempBuf* @temp_buf_new(i32, i32, i32, i32, i32, i8*) #1

declare i8* @temp_buf_get_data(%struct._TempBuf*) #1

; Function Attrs: nounwind uwtable
define %struct._GimpParasite* @gimp_image_parasite_find(%struct._GimpImage* %image, i8* %name) #3 {
entry:
  %retval = alloca %struct._GimpParasite*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %name.addr = alloca i8*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store i8* %name, i8** %name.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__func__.gimp_image_parasite_find, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store %struct._GimpParasite* null, %struct._GimpParasite** %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  %parasites = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %15, i32 0, i32 36
  %16 = load %struct._GimpParasiteList*, %struct._GimpParasiteList** %parasites, align 8
  %17 = load i8*, i8** %name.addr, align 8
  %call13 = call %struct._GimpParasite* @gimp_parasite_list_find(%struct._GimpParasiteList* %16, i8* %17)
  store %struct._GimpParasite* %call13, %struct._GimpParasite** %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %18 = load %struct._GimpParasite*, %struct._GimpParasite** %retval
  ret %struct._GimpParasite* %18
}

declare %struct._GimpParasite* @gimp_parasite_list_find(%struct._GimpParasiteList*, i8*) #1

; Function Attrs: nounwind uwtable
define i8** @gimp_image_parasite_list(%struct._GimpImage* %image, i32* %count) #3 {
entry:
  %retval = alloca i8**, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %count.addr = alloca i32*, align 8
  %private = alloca %struct._GimpImagePrivate*, align 8
  %list = alloca i8**, align 8
  %cur = alloca i8**, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store i32* %count, i32** %count.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__func__.gimp_image_parasite_list, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store i8** null, i8*** %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %15, %struct._GimpImagePrivate** %private, align 8
  %16 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %parasites = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %16, i32 0, i32 36
  %17 = load %struct._GimpParasiteList*, %struct._GimpParasiteList** %parasites, align 8
  %call13 = call i32 @gimp_parasite_list_length(%struct._GimpParasiteList* %17)
  %18 = load i32*, i32** %count.addr, align 8
  store i32 %call13, i32* %18, align 4
  %19 = load i32*, i32** %count.addr, align 8
  %20 = load i32, i32* %19, align 4
  %conv = sext i32 %20 to i64
  %call14 = call noalias i8* @g_malloc_n(i64 %conv, i64 8)
  %21 = bitcast i8* %call14 to i8**
  store i8** %21, i8*** %list, align 8
  store i8** %21, i8*** %cur, align 8
  %22 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %parasites15 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %22, i32 0, i32 36
  %23 = load %struct._GimpParasiteList*, %struct._GimpParasiteList** %parasites15, align 8
  %24 = bitcast i8*** %cur to i8*
  call void @gimp_parasite_list_foreach(%struct._GimpParasiteList* %23, void (i8*, i8*, i8*)* bitcast (void (i8*, %struct._GimpParasite*, i8***)* @list_func to void (i8*, i8*, i8*)*), i8* %24)
  %25 = load i8**, i8*** %list, align 8
  store i8** %25, i8*** %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %26 = load i8**, i8*** %retval
  ret i8** %26
}

declare i32 @gimp_parasite_list_length(%struct._GimpParasiteList*) #1

declare noalias i8* @g_malloc_n(i64, i64) #1

declare void @gimp_parasite_list_foreach(%struct._GimpParasiteList*, void (i8*, i8*, i8*)*, i8*) #1

; Function Attrs: nounwind uwtable
define internal void @list_func(i8* %key, %struct._GimpParasite* %p, i8*** %cur) #3 {
entry:
  %key.addr = alloca i8*, align 8
  %p.addr = alloca %struct._GimpParasite*, align 8
  %cur.addr = alloca i8***, align 8
  store i8* %key, i8** %key.addr, align 8
  store %struct._GimpParasite* %p, %struct._GimpParasite** %p.addr, align 8
  store i8*** %cur, i8**** %cur.addr, align 8
  %0 = load i8*, i8** %key.addr, align 8
  %call = call noalias i8* @g_strdup(i8* %0)
  %1 = load i8***, i8**** %cur.addr, align 8
  %2 = load i8**, i8*** %1, align 8
  %incdec.ptr = getelementptr inbounds i8*, i8** %2, i32 1
  store i8** %incdec.ptr, i8*** %1, align 8
  store i8* %call, i8** %2, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define void @gimp_image_parasite_attach(%struct._GimpImage* %image, %struct._GimpParasite* %parasite) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %parasite.addr = alloca %struct._GimpParasite*, align 8
  %copy = alloca %struct._GimpParasite, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store %struct._GimpParasite* %parasite, %struct._GimpParasite** %parasite.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @__func__.gimp_image_parasite_attach, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %if.end.35

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  br label %do.body.11

do.body.11:                                       ; preds = %do.end
  %13 = load %struct._GimpParasite*, %struct._GimpParasite** %parasite.addr, align 8
  %cmp12 = icmp ne %struct._GimpParasite* %13, null
  br i1 %cmp12, label %if.then.13, label %if.else.14

if.then.13:                                       ; preds = %do.body.11
  br label %if.end.15

if.else.14:                                       ; preds = %do.body.11
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @__func__.gimp_image_parasite_attach, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.37, i32 0, i32 0))
  br label %if.end.35

if.end.15:                                        ; preds = %if.then.13
  br label %do.end.16

do.end.16:                                        ; preds = %if.end.15
  %14 = load %struct._GimpParasite*, %struct._GimpParasite** %parasite.addr, align 8
  %15 = bitcast %struct._GimpParasite* %copy to i8*
  %16 = bitcast %struct._GimpParasite* %14 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %15, i8* %16, i64 24, i32 8, i1 false)
  %call17 = call i32 @gimp_parasite_is_undoable(%struct._GimpParasite* %copy)
  %tobool18 = icmp ne i32 %call17, 0
  br i1 %tobool18, label %if.then.19, label %if.end.22

if.then.19:                                       ; preds = %do.end.16
  %17 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call20 = call i8* @g_dpgettext(i8* null, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.38, i32 0, i32 0), i64 10)
  %call21 = call %struct._GimpUndo* @gimp_image_undo_push_image_parasite(%struct._GimpImage* %17, i8* %call20, %struct._GimpParasite* %copy)
  br label %if.end.22

if.end.22:                                        ; preds = %if.then.19, %do.end.16
  %18 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %19 = bitcast %struct._GimpImage* %18 to %struct._GTypeInstance*
  %call23 = call i64 @gimp_image_get_type() #8
  %call24 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %19, i64 %call23)
  %20 = bitcast i8* %call24 to %struct._GimpImagePrivate*
  %parasites = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %20, i32 0, i32 36
  %21 = load %struct._GimpParasiteList*, %struct._GimpParasiteList** %parasites, align 8
  call void @gimp_parasite_list_add(%struct._GimpParasiteList* %21, %struct._GimpParasite* %copy)
  %call25 = call i32 @gimp_parasite_has_flag(%struct._GimpParasite* %copy, i64 32768)
  %tobool26 = icmp ne i32 %call25, 0
  br i1 %tobool26, label %if.then.27, label %if.end.28

if.then.27:                                       ; preds = %if.end.22
  call void @gimp_parasite_shift_parent(%struct._GimpParasite* %copy)
  %22 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %gimp = getelementptr inbounds %struct._GimpImage, %struct._GimpImage* %22, i32 0, i32 1
  %23 = load %struct._Gimp*, %struct._Gimp** %gimp, align 8
  call void @gimp_parasite_attach(%struct._Gimp* %23, %struct._GimpParasite* %copy)
  br label %if.end.28

if.end.28:                                        ; preds = %if.then.27, %if.end.22
  %24 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %25 = bitcast %struct._GimpImage* %24 to i8*
  %26 = load i32, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 24), align 4
  %27 = load %struct._GimpParasite*, %struct._GimpParasite** %parasite.addr, align 8
  %name = getelementptr inbounds %struct._GimpParasite, %struct._GimpParasite* %27, i32 0, i32 0
  %28 = load i8*, i8** %name, align 8
  call void (i8*, i32, i32, ...) @g_signal_emit(i8* %25, i32 %26, i32 0, i8* %28)
  %29 = load %struct._GimpParasite*, %struct._GimpParasite** %parasite.addr, align 8
  %name29 = getelementptr inbounds %struct._GimpParasite, %struct._GimpParasite* %29, i32 0, i32 0
  %30 = load i8*, i8** %name29, align 8
  %call30 = call i32 @strcmp(i8* %30, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.39, i32 0, i32 0)) #9
  %cmp31 = icmp eq i32 %call30, 0
  br i1 %cmp31, label %if.then.32, label %if.end.35

if.then.32:                                       ; preds = %if.end.28
  %31 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %32 = bitcast %struct._GimpImage* %31 to %struct._GTypeInstance*
  %call33 = call i64 @gimp_color_managed_interface_get_type() #8
  %call34 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %32, i64 %call33)
  %33 = bitcast %struct._GTypeInstance* %call34 to %struct._GimpColorManaged*
  call void @gimp_color_managed_profile_changed(%struct._GimpColorManaged* %33)
  br label %if.end.35

if.end.35:                                        ; preds = %if.else.9, %if.else.14, %if.then.32, %if.end.28
  ret void
}

; Function Attrs: nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture, i8* nocapture readonly, i64, i32, i1) #6

declare i32 @gimp_parasite_is_undoable(%struct._GimpParasite*) #1

declare %struct._GimpUndo* @gimp_image_undo_push_image_parasite(%struct._GimpImage*, i8*, %struct._GimpParasite*) #1

declare void @gimp_parasite_list_add(%struct._GimpParasiteList*, %struct._GimpParasite*) #1

declare i32 @gimp_parasite_has_flag(%struct._GimpParasite*, i64) #1

declare void @gimp_parasite_shift_parent(%struct._GimpParasite*) #1

declare void @gimp_parasite_attach(%struct._Gimp*, %struct._GimpParasite*) #1

; Function Attrs: nounwind readonly
declare i32 @strcmp(i8*, i8*) #4

declare void @gimp_color_managed_profile_changed(%struct._GimpColorManaged*) #1

; Function Attrs: nounwind uwtable
define void @gimp_image_parasite_detach(%struct._GimpImage* %image, i8* %name) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %name.addr = alloca i8*, align 8
  %private = alloca %struct._GimpImagePrivate*, align 8
  %parasite = alloca %struct._GimpParasite*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store i8* %name, i8** %name.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @__func__.gimp_image_parasite_detach, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %if.end.35

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  br label %do.body.11

do.body.11:                                       ; preds = %do.end
  %13 = load i8*, i8** %name.addr, align 8
  %cmp12 = icmp ne i8* %13, null
  br i1 %cmp12, label %if.then.13, label %if.else.14

if.then.13:                                       ; preds = %do.body.11
  br label %if.end.15

if.else.14:                                       ; preds = %do.body.11
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @__func__.gimp_image_parasite_detach, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.40, i32 0, i32 0))
  br label %if.end.35

if.end.15:                                        ; preds = %if.then.13
  br label %do.end.16

do.end.16:                                        ; preds = %if.end.15
  %14 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %15 = bitcast %struct._GimpImage* %14 to %struct._GTypeInstance*
  %call17 = call i64 @gimp_image_get_type() #8
  %call18 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %15, i64 %call17)
  %16 = bitcast i8* %call18 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %16, %struct._GimpImagePrivate** %private, align 8
  %17 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %parasites = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %17, i32 0, i32 36
  %18 = load %struct._GimpParasiteList*, %struct._GimpParasiteList** %parasites, align 8
  %19 = load i8*, i8** %name.addr, align 8
  %call19 = call %struct._GimpParasite* @gimp_parasite_list_find(%struct._GimpParasiteList* %18, i8* %19)
  store %struct._GimpParasite* %call19, %struct._GimpParasite** %parasite, align 8
  %tobool20 = icmp ne %struct._GimpParasite* %call19, null
  br i1 %tobool20, label %if.end.22, label %if.then.21

if.then.21:                                       ; preds = %do.end.16
  br label %if.end.35

if.end.22:                                        ; preds = %do.end.16
  %20 = load %struct._GimpParasite*, %struct._GimpParasite** %parasite, align 8
  %call23 = call i32 @gimp_parasite_is_undoable(%struct._GimpParasite* %20)
  %tobool24 = icmp ne i32 %call23, 0
  br i1 %tobool24, label %if.then.25, label %if.end.28

if.then.25:                                       ; preds = %if.end.22
  %21 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call26 = call i8* @g_dpgettext(i8* null, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.41, i32 0, i32 0), i64 10)
  %22 = load i8*, i8** %name.addr, align 8
  %call27 = call %struct._GimpUndo* @gimp_image_undo_push_image_parasite_remove(%struct._GimpImage* %21, i8* %call26, i8* %22)
  br label %if.end.28

if.end.28:                                        ; preds = %if.then.25, %if.end.22
  %23 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %parasites29 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %23, i32 0, i32 36
  %24 = load %struct._GimpParasiteList*, %struct._GimpParasiteList** %parasites29, align 8
  %25 = load i8*, i8** %name.addr, align 8
  call void @gimp_parasite_list_remove(%struct._GimpParasiteList* %24, i8* %25)
  %26 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %27 = bitcast %struct._GimpImage* %26 to i8*
  %28 = load i32, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 25), align 4
  %29 = load i8*, i8** %name.addr, align 8
  call void (i8*, i32, i32, ...) @g_signal_emit(i8* %27, i32 %28, i32 0, i8* %29)
  %30 = load i8*, i8** %name.addr, align 8
  %call30 = call i32 @strcmp(i8* %30, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.39, i32 0, i32 0)) #9
  %cmp31 = icmp eq i32 %call30, 0
  br i1 %cmp31, label %if.then.32, label %if.end.35

if.then.32:                                       ; preds = %if.end.28
  %31 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %32 = bitcast %struct._GimpImage* %31 to %struct._GTypeInstance*
  %call33 = call i64 @gimp_color_managed_interface_get_type() #8
  %call34 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %32, i64 %call33)
  %33 = bitcast %struct._GTypeInstance* %call34 to %struct._GimpColorManaged*
  call void @gimp_color_managed_profile_changed(%struct._GimpColorManaged* %33)
  br label %if.end.35

if.end.35:                                        ; preds = %if.else.9, %if.else.14, %if.then.21, %if.then.32, %if.end.28
  ret void
}

declare %struct._GimpUndo* @gimp_image_undo_push_image_parasite_remove(%struct._GimpImage*, i8*, i8*) #1

declare void @gimp_parasite_list_remove(%struct._GimpParasiteList*, i8*) #1

; Function Attrs: nounwind uwtable
define i32 @gimp_image_get_new_tattoo(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca i32, align 4
  %image.addr = alloca %struct._GimpImage*, align 8
  %private = alloca %struct._GimpImagePrivate*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__func__.gimp_image_get_new_tattoo, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store i32 0, i32* %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %15, %struct._GimpImagePrivate** %private, align 8
  %16 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %tattoo_state = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %16, i32 0, i32 21
  %17 = load i32, i32* %tattoo_state, align 4
  %inc = add i32 %17, 1
  store i32 %inc, i32* %tattoo_state, align 4
  %18 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %tattoo_state13 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %18, i32 0, i32 21
  %19 = load i32, i32* %tattoo_state13, align 4
  %cmp14 = icmp eq i32 %19, 0
  br i1 %cmp14, label %if.then.15, label %if.end.16

if.then.15:                                       ; preds = %do.end
  call void (i8*, ...) @g_warning(i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.42, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__func__.gimp_image_get_new_tattoo, i32 0, i32 0))
  br label %if.end.16

if.end.16:                                        ; preds = %if.then.15, %do.end
  %20 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %tattoo_state17 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %20, i32 0, i32 21
  %21 = load i32, i32* %tattoo_state17, align 4
  store i32 %21, i32* %retval
  br label %return

return:                                           ; preds = %if.end.16, %if.else.9
  %22 = load i32, i32* %retval
  ret i32 %22
}

; Function Attrs: nounwind uwtable
define internal void @g_warning(i8* %format, ...) #3 {
entry:
  %format.addr = alloca i8*, align 8
  %args = alloca [1 x %struct.__va_list_tag], align 16
  store i8* %format, i8** %format.addr, align 8
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i32 0, i32 0
  %arraydecay1 = bitcast %struct.__va_list_tag* %arraydecay to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  %0 = load i8*, i8** %format.addr, align 8
  %arraydecay2 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i32 0, i32 0
  call void @g_logv(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i32 16, i8* %0, %struct.__va_list_tag* %arraydecay2)
  %arraydecay3 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i32 0, i32 0
  %arraydecay34 = bitcast %struct.__va_list_tag* %arraydecay3 to i8*
  call void @llvm.va_end(i8* %arraydecay34)
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @gimp_image_get_tattoo_state(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca i32, align 4
  %image.addr = alloca %struct._GimpImage*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__func__.gimp_image_get_tattoo_state, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store i32 0, i32* %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  %tattoo_state = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %15, i32 0, i32 21
  %16 = load i32, i32* %tattoo_state, align 4
  store i32 %16, i32* %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %17 = load i32, i32* %retval
  ret i32 %17
}

; Function Attrs: nounwind uwtable
define i32 @gimp_image_set_tattoo_state(%struct._GimpImage* %image, i32 %val) #3 {
entry:
  %retval = alloca i32, align 4
  %image.addr = alloca %struct._GimpImage*, align 8
  %val.addr = alloca i32, align 4
  %all_items = alloca %struct._GList*, align 8
  %list = alloca %struct._GList*, align 8
  %retval1 = alloca i32, align 4
  %maxval = alloca i32, align 4
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  %ltattoo = alloca i32, align 4
  %ctattoo = alloca i32, align 4
  %vtattoo = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store i32 %val, i32* %val.addr, align 4
  store i32 1, i32* %retval1, align 4
  store i32 0, i32* %maxval, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.7

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool2 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool2, label %land.lhs.true, label %if.else.5

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class3 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class3, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.4, label %if.else.5

if.then.4:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.5:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call6 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call6, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.5, %if.then.4
  br label %if.end.7

if.end.7:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool8 = icmp ne i32 %12, 0
  br i1 %tobool8, label %if.then.9, label %if.else.10

if.then.9:                                        ; preds = %if.end.7
  br label %if.end.11

if.else.10:                                       ; preds = %if.end.7
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__func__.gimp_image_set_tattoo_state, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store i32 0, i32* %retval
  br label %return

if.end.11:                                        ; preds = %if.then.9
  br label %do.end

do.end:                                           ; preds = %if.end.11
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call12 = call %struct._GList* @gimp_image_get_layer_list(%struct._GimpImage* %13)
  store %struct._GList* %call12, %struct._GList** %all_items, align 8
  %14 = load %struct._GList*, %struct._GList** %all_items, align 8
  store %struct._GList* %14, %struct._GList** %list, align 8
  br label %for.cond

for.cond:                                         ; preds = %cond.end, %do.end
  %15 = load %struct._GList*, %struct._GList** %list, align 8
  %tobool13 = icmp ne %struct._GList* %15, null
  br i1 %tobool13, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %16 = load %struct._GList*, %struct._GList** %list, align 8
  %data = getelementptr inbounds %struct._GList, %struct._GList* %16, i32 0, i32 0
  %17 = load i8*, i8** %data, align 8
  %18 = bitcast i8* %17 to %struct._GTypeInstance*
  %call15 = call i64 @gimp_item_get_type() #8
  %call16 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %18, i64 %call15)
  %19 = bitcast %struct._GTypeInstance* %call16 to %struct._GimpItem*
  %call17 = call i32 @gimp_item_get_tattoo(%struct._GimpItem* %19)
  store i32 %call17, i32* %ltattoo, align 4
  %20 = load i32, i32* %ltattoo, align 4
  %21 = load i32, i32* %maxval, align 4
  %cmp18 = icmp ugt i32 %20, %21
  br i1 %cmp18, label %if.then.19, label %if.end.20

if.then.19:                                       ; preds = %for.body
  %22 = load i32, i32* %ltattoo, align 4
  store i32 %22, i32* %maxval, align 4
  br label %if.end.20

if.end.20:                                        ; preds = %if.then.19, %for.body
  %23 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %24 = load i32, i32* %ltattoo, align 4
  %call21 = call %struct._GimpChannel* @gimp_image_get_channel_by_tattoo(%struct._GimpImage* %23, i32 %24)
  %tobool22 = icmp ne %struct._GimpChannel* %call21, null
  br i1 %tobool22, label %if.then.23, label %if.end.24

if.then.23:                                       ; preds = %if.end.20
  store i32 0, i32* %retval1, align 4
  br label %if.end.24

if.end.24:                                        ; preds = %if.then.23, %if.end.20
  %25 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %26 = load i32, i32* %ltattoo, align 4
  %call25 = call %struct._GimpVectors* @gimp_image_get_vectors_by_tattoo(%struct._GimpImage* %25, i32 %26)
  %tobool26 = icmp ne %struct._GimpVectors* %call25, null
  br i1 %tobool26, label %if.then.27, label %if.end.28

if.then.27:                                       ; preds = %if.end.24
  store i32 0, i32* %retval1, align 4
  br label %if.end.28

if.end.28:                                        ; preds = %if.then.27, %if.end.24
  br label %for.inc

for.inc:                                          ; preds = %if.end.28
  %27 = load %struct._GList*, %struct._GList** %list, align 8
  %tobool29 = icmp ne %struct._GList* %27, null
  br i1 %tobool29, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.inc
  %28 = load %struct._GList*, %struct._GList** %list, align 8
  %next = getelementptr inbounds %struct._GList, %struct._GList* %28, i32 0, i32 1
  %29 = load %struct._GList*, %struct._GList** %next, align 8
  br label %cond.end

cond.false:                                       ; preds = %for.inc
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct._GList* [ %29, %cond.true ], [ null, %cond.false ]
  store %struct._GList* %cond, %struct._GList** %list, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %30 = load %struct._GList*, %struct._GList** %all_items, align 8
  call void @g_list_free(%struct._GList* %30)
  %31 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call30 = call %struct._GList* @gimp_image_get_channel_list(%struct._GimpImage* %31)
  store %struct._GList* %call30, %struct._GList** %all_items, align 8
  %32 = load %struct._GList*, %struct._GList** %all_items, align 8
  store %struct._GList* %32, %struct._GList** %list, align 8
  br label %for.cond.31

for.cond.31:                                      ; preds = %cond.end.51, %for.end
  %33 = load %struct._GList*, %struct._GList** %list, align 8
  %tobool32 = icmp ne %struct._GList* %33, null
  br i1 %tobool32, label %for.body.33, label %for.end.53

for.body.33:                                      ; preds = %for.cond.31
  %34 = load %struct._GList*, %struct._GList** %list, align 8
  %data35 = getelementptr inbounds %struct._GList, %struct._GList* %34, i32 0, i32 0
  %35 = load i8*, i8** %data35, align 8
  %36 = bitcast i8* %35 to %struct._GTypeInstance*
  %call36 = call i64 @gimp_item_get_type() #8
  %call37 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %36, i64 %call36)
  %37 = bitcast %struct._GTypeInstance* %call37 to %struct._GimpItem*
  %call38 = call i32 @gimp_item_get_tattoo(%struct._GimpItem* %37)
  store i32 %call38, i32* %ctattoo, align 4
  %38 = load i32, i32* %ctattoo, align 4
  %39 = load i32, i32* %maxval, align 4
  %cmp39 = icmp ugt i32 %38, %39
  br i1 %cmp39, label %if.then.40, label %if.end.41

if.then.40:                                       ; preds = %for.body.33
  %40 = load i32, i32* %ctattoo, align 4
  store i32 %40, i32* %maxval, align 4
  br label %if.end.41

if.end.41:                                        ; preds = %if.then.40, %for.body.33
  %41 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %42 = load i32, i32* %ctattoo, align 4
  %call42 = call %struct._GimpVectors* @gimp_image_get_vectors_by_tattoo(%struct._GimpImage* %41, i32 %42)
  %tobool43 = icmp ne %struct._GimpVectors* %call42, null
  br i1 %tobool43, label %if.then.44, label %if.end.45

if.then.44:                                       ; preds = %if.end.41
  store i32 0, i32* %retval1, align 4
  br label %if.end.45

if.end.45:                                        ; preds = %if.then.44, %if.end.41
  br label %for.inc.46

for.inc.46:                                       ; preds = %if.end.45
  %43 = load %struct._GList*, %struct._GList** %list, align 8
  %tobool47 = icmp ne %struct._GList* %43, null
  br i1 %tobool47, label %cond.true.48, label %cond.false.50

cond.true.48:                                     ; preds = %for.inc.46
  %44 = load %struct._GList*, %struct._GList** %list, align 8
  %next49 = getelementptr inbounds %struct._GList, %struct._GList* %44, i32 0, i32 1
  %45 = load %struct._GList*, %struct._GList** %next49, align 8
  br label %cond.end.51

cond.false.50:                                    ; preds = %for.inc.46
  br label %cond.end.51

cond.end.51:                                      ; preds = %cond.false.50, %cond.true.48
  %cond52 = phi %struct._GList* [ %45, %cond.true.48 ], [ null, %cond.false.50 ]
  store %struct._GList* %cond52, %struct._GList** %list, align 8
  br label %for.cond.31

for.end.53:                                       ; preds = %for.cond.31
  %46 = load %struct._GList*, %struct._GList** %all_items, align 8
  call void @g_list_free(%struct._GList* %46)
  %47 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call54 = call %struct._GList* @gimp_image_get_vectors_list(%struct._GimpImage* %47)
  store %struct._GList* %call54, %struct._GList** %all_items, align 8
  %48 = load %struct._GList*, %struct._GList** %all_items, align 8
  store %struct._GList* %48, %struct._GList** %list, align 8
  br label %for.cond.55

for.cond.55:                                      ; preds = %cond.end.71, %for.end.53
  %49 = load %struct._GList*, %struct._GList** %list, align 8
  %tobool56 = icmp ne %struct._GList* %49, null
  br i1 %tobool56, label %for.body.57, label %for.end.73

for.body.57:                                      ; preds = %for.cond.55
  %50 = load %struct._GList*, %struct._GList** %list, align 8
  %data59 = getelementptr inbounds %struct._GList, %struct._GList* %50, i32 0, i32 0
  %51 = load i8*, i8** %data59, align 8
  %52 = bitcast i8* %51 to %struct._GTypeInstance*
  %call60 = call i64 @gimp_item_get_type() #8
  %call61 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %52, i64 %call60)
  %53 = bitcast %struct._GTypeInstance* %call61 to %struct._GimpItem*
  %call62 = call i32 @gimp_item_get_tattoo(%struct._GimpItem* %53)
  store i32 %call62, i32* %vtattoo, align 4
  %54 = load i32, i32* %vtattoo, align 4
  %55 = load i32, i32* %maxval, align 4
  %cmp63 = icmp ugt i32 %54, %55
  br i1 %cmp63, label %if.then.64, label %if.end.65

if.then.64:                                       ; preds = %for.body.57
  %56 = load i32, i32* %vtattoo, align 4
  store i32 %56, i32* %maxval, align 4
  br label %if.end.65

if.end.65:                                        ; preds = %if.then.64, %for.body.57
  br label %for.inc.66

for.inc.66:                                       ; preds = %if.end.65
  %57 = load %struct._GList*, %struct._GList** %list, align 8
  %tobool67 = icmp ne %struct._GList* %57, null
  br i1 %tobool67, label %cond.true.68, label %cond.false.70

cond.true.68:                                     ; preds = %for.inc.66
  %58 = load %struct._GList*, %struct._GList** %list, align 8
  %next69 = getelementptr inbounds %struct._GList, %struct._GList* %58, i32 0, i32 1
  %59 = load %struct._GList*, %struct._GList** %next69, align 8
  br label %cond.end.71

cond.false.70:                                    ; preds = %for.inc.66
  br label %cond.end.71

cond.end.71:                                      ; preds = %cond.false.70, %cond.true.68
  %cond72 = phi %struct._GList* [ %59, %cond.true.68 ], [ null, %cond.false.70 ]
  store %struct._GList* %cond72, %struct._GList** %list, align 8
  br label %for.cond.55

for.end.73:                                       ; preds = %for.cond.55
  %60 = load %struct._GList*, %struct._GList** %all_items, align 8
  call void @g_list_free(%struct._GList* %60)
  %61 = load i32, i32* %val.addr, align 4
  %62 = load i32, i32* %maxval, align 4
  %cmp74 = icmp ult i32 %61, %62
  br i1 %cmp74, label %if.then.75, label %if.end.76

if.then.75:                                       ; preds = %for.end.73
  store i32 0, i32* %retval1, align 4
  br label %if.end.76

if.end.76:                                        ; preds = %if.then.75, %for.end.73
  %63 = load i32, i32* %retval1, align 4
  %cmp77 = icmp eq i32 %63, 1
  br i1 %cmp77, label %if.then.78, label %if.end.81

if.then.78:                                       ; preds = %if.end.76
  %64 = load i32, i32* %val.addr, align 4
  %65 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %66 = bitcast %struct._GimpImage* %65 to %struct._GTypeInstance*
  %call79 = call i64 @gimp_image_get_type() #8
  %call80 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %66, i64 %call79)
  %67 = bitcast i8* %call80 to %struct._GimpImagePrivate*
  %tattoo_state = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %67, i32 0, i32 21
  store i32 %64, i32* %tattoo_state, align 4
  br label %if.end.81

if.end.81:                                        ; preds = %if.then.78, %if.end.76
  %68 = load i32, i32* %retval1, align 4
  store i32 %68, i32* %retval
  br label %return

return:                                           ; preds = %if.end.81, %if.else.10
  %69 = load i32, i32* %retval
  ret i32 %69
}

; Function Attrs: nounwind uwtable
define %struct._GList* @gimp_image_get_layer_list(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca %struct._GList*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %stack = alloca %struct._GimpItemStack*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__func__.gimp_image_get_layer_list, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store %struct._GList* null, %struct._GList** %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call11 = call %struct._GimpContainer* @gimp_image_get_layers(%struct._GimpImage* %13)
  %14 = bitcast %struct._GimpContainer* %call11 to %struct._GTypeInstance*
  %call12 = call i64 @gimp_item_stack_get_type() #8
  %call13 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %14, i64 %call12)
  %15 = bitcast %struct._GTypeInstance* %call13 to %struct._GimpItemStack*
  store %struct._GimpItemStack* %15, %struct._GimpItemStack** %stack, align 8
  %16 = load %struct._GimpItemStack*, %struct._GimpItemStack** %stack, align 8
  %call14 = call %struct._GList* @gimp_item_stack_get_item_list(%struct._GimpItemStack* %16)
  store %struct._GList* %call14, %struct._GList** %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %17 = load %struct._GList*, %struct._GList** %retval
  ret %struct._GList* %17
}

declare i32 @gimp_item_get_tattoo(%struct._GimpItem*) #1

; Function Attrs: nounwind uwtable
define %struct._GimpChannel* @gimp_image_get_channel_by_tattoo(%struct._GimpImage* %image, i32 %tattoo) #3 {
entry:
  %retval = alloca %struct._GimpChannel*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %tattoo.addr = alloca i32, align 4
  %stack = alloca %struct._GimpItemStack*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store i32 %tattoo, i32* %tattoo.addr, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @__func__.gimp_image_get_channel_by_tattoo, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store %struct._GimpChannel* null, %struct._GimpChannel** %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call11 = call %struct._GimpContainer* @gimp_image_get_channels(%struct._GimpImage* %13)
  %14 = bitcast %struct._GimpContainer* %call11 to %struct._GTypeInstance*
  %call12 = call i64 @gimp_item_stack_get_type() #8
  %call13 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %14, i64 %call12)
  %15 = bitcast %struct._GTypeInstance* %call13 to %struct._GimpItemStack*
  store %struct._GimpItemStack* %15, %struct._GimpItemStack** %stack, align 8
  %16 = load %struct._GimpItemStack*, %struct._GimpItemStack** %stack, align 8
  %17 = load i32, i32* %tattoo.addr, align 4
  %call14 = call %struct._GimpItem* @gimp_item_stack_get_item_by_tattoo(%struct._GimpItemStack* %16, i32 %17)
  %18 = bitcast %struct._GimpItem* %call14 to %struct._GTypeInstance*
  %call15 = call i64 @gimp_channel_get_type() #8
  %call16 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %18, i64 %call15)
  %19 = bitcast %struct._GTypeInstance* %call16 to %struct._GimpChannel*
  store %struct._GimpChannel* %19, %struct._GimpChannel** %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %20 = load %struct._GimpChannel*, %struct._GimpChannel** %retval
  ret %struct._GimpChannel* %20
}

; Function Attrs: nounwind uwtable
define %struct._GimpVectors* @gimp_image_get_vectors_by_tattoo(%struct._GimpImage* %image, i32 %tattoo) #3 {
entry:
  %retval = alloca %struct._GimpVectors*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %tattoo.addr = alloca i32, align 4
  %stack = alloca %struct._GimpItemStack*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store i32 %tattoo, i32* %tattoo.addr, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @__func__.gimp_image_get_vectors_by_tattoo, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store %struct._GimpVectors* null, %struct._GimpVectors** %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call11 = call %struct._GimpContainer* @gimp_image_get_vectors(%struct._GimpImage* %13)
  %14 = bitcast %struct._GimpContainer* %call11 to %struct._GTypeInstance*
  %call12 = call i64 @gimp_item_stack_get_type() #8
  %call13 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %14, i64 %call12)
  %15 = bitcast %struct._GTypeInstance* %call13 to %struct._GimpItemStack*
  store %struct._GimpItemStack* %15, %struct._GimpItemStack** %stack, align 8
  %16 = load %struct._GimpItemStack*, %struct._GimpItemStack** %stack, align 8
  %17 = load i32, i32* %tattoo.addr, align 4
  %call14 = call %struct._GimpItem* @gimp_item_stack_get_item_by_tattoo(%struct._GimpItemStack* %16, i32 %17)
  %18 = bitcast %struct._GimpItem* %call14 to %struct._GTypeInstance*
  %call15 = call i64 @gimp_vectors_get_type() #8
  %call16 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %18, i64 %call15)
  %19 = bitcast %struct._GTypeInstance* %call16 to %struct._GimpVectors*
  store %struct._GimpVectors* %19, %struct._GimpVectors** %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %20 = load %struct._GimpVectors*, %struct._GimpVectors** %retval
  ret %struct._GimpVectors* %20
}

declare void @g_list_free(%struct._GList*) #1

; Function Attrs: nounwind uwtable
define %struct._GList* @gimp_image_get_channel_list(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca %struct._GList*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %stack = alloca %struct._GimpItemStack*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__func__.gimp_image_get_channel_list, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store %struct._GList* null, %struct._GList** %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call11 = call %struct._GimpContainer* @gimp_image_get_channels(%struct._GimpImage* %13)
  %14 = bitcast %struct._GimpContainer* %call11 to %struct._GTypeInstance*
  %call12 = call i64 @gimp_item_stack_get_type() #8
  %call13 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %14, i64 %call12)
  %15 = bitcast %struct._GTypeInstance* %call13 to %struct._GimpItemStack*
  store %struct._GimpItemStack* %15, %struct._GimpItemStack** %stack, align 8
  %16 = load %struct._GimpItemStack*, %struct._GimpItemStack** %stack, align 8
  %call14 = call %struct._GList* @gimp_item_stack_get_item_list(%struct._GimpItemStack* %16)
  store %struct._GList* %call14, %struct._GList** %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %17 = load %struct._GList*, %struct._GList** %retval
  ret %struct._GList* %17
}

; Function Attrs: nounwind uwtable
define %struct._GList* @gimp_image_get_vectors_list(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca %struct._GList*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %stack = alloca %struct._GimpItemStack*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__func__.gimp_image_get_vectors_list, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store %struct._GList* null, %struct._GList** %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call11 = call %struct._GimpContainer* @gimp_image_get_vectors(%struct._GimpImage* %13)
  %14 = bitcast %struct._GimpContainer* %call11 to %struct._GTypeInstance*
  %call12 = call i64 @gimp_item_stack_get_type() #8
  %call13 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %14, i64 %call12)
  %15 = bitcast %struct._GTypeInstance* %call13 to %struct._GimpItemStack*
  store %struct._GimpItemStack* %15, %struct._GimpItemStack** %stack, align 8
  %16 = load %struct._GimpItemStack*, %struct._GimpItemStack** %stack, align 8
  %call14 = call %struct._GList* @gimp_item_stack_get_item_list(%struct._GimpItemStack* %16)
  store %struct._GList* %call14, %struct._GList** %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %17 = load %struct._GList*, %struct._GList** %retval
  ret %struct._GList* %17
}

; Function Attrs: nounwind uwtable
define %struct._GimpProjection* @gimp_image_get_projection(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca %struct._GimpProjection*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__func__.gimp_image_get_projection, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store %struct._GimpProjection* null, %struct._GimpProjection** %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  %projection = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %15, i32 0, i32 22
  %16 = load %struct._GimpProjection*, %struct._GimpProjection** %projection, align 8
  store %struct._GimpProjection* %16, %struct._GimpProjection** %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %17 = load %struct._GimpProjection*, %struct._GimpProjection** %retval
  ret %struct._GimpProjection* %17
}

; Function Attrs: nounwind uwtable
define %struct._GimpItemTree* @gimp_image_get_layer_tree(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca %struct._GimpItemTree*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__func__.gimp_image_get_layer_tree, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store %struct._GimpItemTree* null, %struct._GimpItemTree** %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  %layers = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %15, i32 0, i32 27
  %16 = load %struct._GimpItemTree*, %struct._GimpItemTree** %layers, align 8
  store %struct._GimpItemTree* %16, %struct._GimpItemTree** %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %17 = load %struct._GimpItemTree*, %struct._GimpItemTree** %retval
  ret %struct._GimpItemTree* %17
}

; Function Attrs: nounwind uwtable
define %struct._GimpItemTree* @gimp_image_get_channel_tree(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca %struct._GimpItemTree*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__func__.gimp_image_get_channel_tree, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store %struct._GimpItemTree* null, %struct._GimpItemTree** %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  %channels = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %15, i32 0, i32 28
  %16 = load %struct._GimpItemTree*, %struct._GimpItemTree** %channels, align 8
  store %struct._GimpItemTree* %16, %struct._GimpItemTree** %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %17 = load %struct._GimpItemTree*, %struct._GimpItemTree** %retval
  ret %struct._GimpItemTree* %17
}

; Function Attrs: nounwind uwtable
define %struct._GimpItemTree* @gimp_image_get_vectors_tree(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca %struct._GimpItemTree*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__func__.gimp_image_get_vectors_tree, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store %struct._GimpItemTree* null, %struct._GimpItemTree** %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  %vectors = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %15, i32 0, i32 29
  %16 = load %struct._GimpItemTree*, %struct._GimpItemTree** %vectors, align 8
  store %struct._GimpItemTree* %16, %struct._GimpItemTree** %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %17 = load %struct._GimpItemTree*, %struct._GimpItemTree** %retval
  ret %struct._GimpItemTree* %17
}

; Function Attrs: nounwind uwtable
define %struct._GimpContainer* @gimp_image_get_layers(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca %struct._GimpContainer*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__func__.gimp_image_get_layers, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store %struct._GimpContainer* null, %struct._GimpContainer** %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  %layers = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %15, i32 0, i32 27
  %16 = load %struct._GimpItemTree*, %struct._GimpItemTree** %layers, align 8
  %container = getelementptr inbounds %struct._GimpItemTree, %struct._GimpItemTree* %16, i32 0, i32 1
  %17 = load %struct._GimpContainer*, %struct._GimpContainer** %container, align 8
  store %struct._GimpContainer* %17, %struct._GimpContainer** %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %18 = load %struct._GimpContainer*, %struct._GimpContainer** %retval
  ret %struct._GimpContainer* %18
}

; Function Attrs: nounwind uwtable
define %struct._GimpContainer* @gimp_image_get_channels(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca %struct._GimpContainer*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__func__.gimp_image_get_channels, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store %struct._GimpContainer* null, %struct._GimpContainer** %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  %channels = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %15, i32 0, i32 28
  %16 = load %struct._GimpItemTree*, %struct._GimpItemTree** %channels, align 8
  %container = getelementptr inbounds %struct._GimpItemTree, %struct._GimpItemTree* %16, i32 0, i32 1
  %17 = load %struct._GimpContainer*, %struct._GimpContainer** %container, align 8
  store %struct._GimpContainer* %17, %struct._GimpContainer** %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %18 = load %struct._GimpContainer*, %struct._GimpContainer** %retval
  ret %struct._GimpContainer* %18
}

; Function Attrs: nounwind uwtable
define %struct._GimpContainer* @gimp_image_get_vectors(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca %struct._GimpContainer*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__func__.gimp_image_get_vectors, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store %struct._GimpContainer* null, %struct._GimpContainer** %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  %vectors = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %15, i32 0, i32 29
  %16 = load %struct._GimpItemTree*, %struct._GimpItemTree** %vectors, align 8
  %container = getelementptr inbounds %struct._GimpItemTree, %struct._GimpItemTree* %16, i32 0, i32 1
  %17 = load %struct._GimpContainer*, %struct._GimpContainer** %container, align 8
  store %struct._GimpContainer* %17, %struct._GimpContainer** %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %18 = load %struct._GimpContainer*, %struct._GimpContainer** %retval
  ret %struct._GimpContainer* %18
}

; Function Attrs: nounwind readnone
declare i64 @gimp_item_stack_get_type() #2

declare i32 @gimp_item_stack_get_n_items(%struct._GimpItemStack*) #1

; Function Attrs: nounwind uwtable
define i32 @gimp_image_get_n_channels(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca i32, align 4
  %image.addr = alloca %struct._GimpImage*, align 8
  %stack = alloca %struct._GimpItemStack*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__func__.gimp_image_get_n_channels, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store i32 0, i32* %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call11 = call %struct._GimpContainer* @gimp_image_get_channels(%struct._GimpImage* %13)
  %14 = bitcast %struct._GimpContainer* %call11 to %struct._GTypeInstance*
  %call12 = call i64 @gimp_item_stack_get_type() #8
  %call13 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %14, i64 %call12)
  %15 = bitcast %struct._GTypeInstance* %call13 to %struct._GimpItemStack*
  store %struct._GimpItemStack* %15, %struct._GimpItemStack** %stack, align 8
  %16 = load %struct._GimpItemStack*, %struct._GimpItemStack** %stack, align 8
  %call14 = call i32 @gimp_item_stack_get_n_items(%struct._GimpItemStack* %16)
  store i32 %call14, i32* %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %17 = load i32, i32* %retval
  ret i32 %17
}

; Function Attrs: nounwind uwtable
define i32 @gimp_image_get_n_vectors(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca i32, align 4
  %image.addr = alloca %struct._GimpImage*, align 8
  %stack = alloca %struct._GimpItemStack*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([25 x i8], [25 x i8]* @__func__.gimp_image_get_n_vectors, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store i32 0, i32* %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call11 = call %struct._GimpContainer* @gimp_image_get_vectors(%struct._GimpImage* %13)
  %14 = bitcast %struct._GimpContainer* %call11 to %struct._GTypeInstance*
  %call12 = call i64 @gimp_item_stack_get_type() #8
  %call13 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %14, i64 %call12)
  %15 = bitcast %struct._GTypeInstance* %call13 to %struct._GimpItemStack*
  store %struct._GimpItemStack* %15, %struct._GimpItemStack** %stack, align 8
  %16 = load %struct._GimpItemStack*, %struct._GimpItemStack** %stack, align 8
  %call14 = call i32 @gimp_item_stack_get_n_items(%struct._GimpItemStack* %16)
  store i32 %call14, i32* %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %17 = load i32, i32* %retval
  ret i32 %17
}

; Function Attrs: nounwind uwtable
define %struct._GList* @gimp_image_get_layer_iter(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca %struct._GList*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %stack = alloca %struct._GimpItemStack*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__func__.gimp_image_get_layer_iter, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store %struct._GList* null, %struct._GList** %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call11 = call %struct._GimpContainer* @gimp_image_get_layers(%struct._GimpImage* %13)
  %14 = bitcast %struct._GimpContainer* %call11 to %struct._GTypeInstance*
  %call12 = call i64 @gimp_item_stack_get_type() #8
  %call13 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %14, i64 %call12)
  %15 = bitcast %struct._GTypeInstance* %call13 to %struct._GimpItemStack*
  store %struct._GimpItemStack* %15, %struct._GimpItemStack** %stack, align 8
  %16 = load %struct._GimpItemStack*, %struct._GimpItemStack** %stack, align 8
  %call14 = call %struct._GList* @gimp_item_stack_get_item_iter(%struct._GimpItemStack* %16)
  store %struct._GList* %call14, %struct._GList** %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %17 = load %struct._GList*, %struct._GList** %retval
  ret %struct._GList* %17
}

declare %struct._GList* @gimp_item_stack_get_item_iter(%struct._GimpItemStack*) #1

; Function Attrs: nounwind uwtable
define %struct._GList* @gimp_image_get_channel_iter(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca %struct._GList*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %stack = alloca %struct._GimpItemStack*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__func__.gimp_image_get_channel_iter, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store %struct._GList* null, %struct._GList** %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call11 = call %struct._GimpContainer* @gimp_image_get_channels(%struct._GimpImage* %13)
  %14 = bitcast %struct._GimpContainer* %call11 to %struct._GTypeInstance*
  %call12 = call i64 @gimp_item_stack_get_type() #8
  %call13 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %14, i64 %call12)
  %15 = bitcast %struct._GTypeInstance* %call13 to %struct._GimpItemStack*
  store %struct._GimpItemStack* %15, %struct._GimpItemStack** %stack, align 8
  %16 = load %struct._GimpItemStack*, %struct._GimpItemStack** %stack, align 8
  %call14 = call %struct._GList* @gimp_item_stack_get_item_iter(%struct._GimpItemStack* %16)
  store %struct._GList* %call14, %struct._GList** %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %17 = load %struct._GList*, %struct._GList** %retval
  ret %struct._GList* %17
}

; Function Attrs: nounwind uwtable
define %struct._GList* @gimp_image_get_vectors_iter(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca %struct._GList*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %stack = alloca %struct._GimpItemStack*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__func__.gimp_image_get_vectors_iter, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store %struct._GList* null, %struct._GList** %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call11 = call %struct._GimpContainer* @gimp_image_get_vectors(%struct._GimpImage* %13)
  %14 = bitcast %struct._GimpContainer* %call11 to %struct._GTypeInstance*
  %call12 = call i64 @gimp_item_stack_get_type() #8
  %call13 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %14, i64 %call12)
  %15 = bitcast %struct._GTypeInstance* %call13 to %struct._GimpItemStack*
  store %struct._GimpItemStack* %15, %struct._GimpItemStack** %stack, align 8
  %16 = load %struct._GimpItemStack*, %struct._GimpItemStack** %stack, align 8
  %call14 = call %struct._GList* @gimp_item_stack_get_item_iter(%struct._GimpItemStack* %16)
  store %struct._GList* %call14, %struct._GList** %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %17 = load %struct._GList*, %struct._GList** %retval
  ret %struct._GList* %17
}

declare %struct._GList* @gimp_item_stack_get_item_list(%struct._GimpItemStack*) #1

; Function Attrs: nounwind uwtable
define %struct._GimpDrawable* @gimp_image_get_active_drawable(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca %struct._GimpDrawable*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %private = alloca %struct._GimpImagePrivate*, align 8
  %active_channel = alloca %struct._GimpItem*, align 8
  %active_layer = alloca %struct._GimpItem*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  %layer = alloca %struct._GimpLayer*, align 8
  %mask = alloca %struct._GimpLayerMask*, align 8
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([31 x i8], [31 x i8]* @__func__.gimp_image_get_active_drawable, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store %struct._GimpDrawable* null, %struct._GimpDrawable** %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %15, %struct._GimpImagePrivate** %private, align 8
  %16 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %channels = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %16, i32 0, i32 28
  %17 = load %struct._GimpItemTree*, %struct._GimpItemTree** %channels, align 8
  %call13 = call %struct._GimpItem* @gimp_item_tree_get_active_item(%struct._GimpItemTree* %17)
  store %struct._GimpItem* %call13, %struct._GimpItem** %active_channel, align 8
  %18 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %layers = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %18, i32 0, i32 27
  %19 = load %struct._GimpItemTree*, %struct._GimpItemTree** %layers, align 8
  %call14 = call %struct._GimpItem* @gimp_item_tree_get_active_item(%struct._GimpItemTree* %19)
  store %struct._GimpItem* %call14, %struct._GimpItem** %active_layer, align 8
  %20 = load %struct._GimpItem*, %struct._GimpItem** %active_channel, align 8
  %tobool15 = icmp ne %struct._GimpItem* %20, null
  br i1 %tobool15, label %if.then.16, label %if.else.19

if.then.16:                                       ; preds = %do.end
  %21 = load %struct._GimpItem*, %struct._GimpItem** %active_channel, align 8
  %22 = bitcast %struct._GimpItem* %21 to %struct._GTypeInstance*
  %call17 = call i64 @gimp_drawable_get_type() #8
  %call18 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %22, i64 %call17)
  %23 = bitcast %struct._GTypeInstance* %call18 to %struct._GimpDrawable*
  store %struct._GimpDrawable* %23, %struct._GimpDrawable** %retval
  br label %return

if.else.19:                                       ; preds = %do.end
  %24 = load %struct._GimpItem*, %struct._GimpItem** %active_layer, align 8
  %tobool20 = icmp ne %struct._GimpItem* %24, null
  br i1 %tobool20, label %if.then.21, label %if.end.37

if.then.21:                                       ; preds = %if.else.19
  %25 = load %struct._GimpItem*, %struct._GimpItem** %active_layer, align 8
  %26 = bitcast %struct._GimpItem* %25 to %struct._GTypeInstance*
  %call23 = call i64 @gimp_layer_get_type() #8
  %call24 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %26, i64 %call23)
  %27 = bitcast %struct._GTypeInstance* %call24 to %struct._GimpLayer*
  store %struct._GimpLayer* %27, %struct._GimpLayer** %layer, align 8
  %28 = load %struct._GimpLayer*, %struct._GimpLayer** %layer, align 8
  %call26 = call %struct._GimpLayerMask* @gimp_layer_get_mask(%struct._GimpLayer* %28)
  store %struct._GimpLayerMask* %call26, %struct._GimpLayerMask** %mask, align 8
  %29 = load %struct._GimpLayerMask*, %struct._GimpLayerMask** %mask, align 8
  %tobool27 = icmp ne %struct._GimpLayerMask* %29, null
  br i1 %tobool27, label %land.lhs.true.28, label %if.else.34

land.lhs.true.28:                                 ; preds = %if.then.21
  %30 = load %struct._GimpLayerMask*, %struct._GimpLayerMask** %mask, align 8
  %call29 = call i32 @gimp_layer_mask_get_edit(%struct._GimpLayerMask* %30)
  %tobool30 = icmp ne i32 %call29, 0
  br i1 %tobool30, label %if.then.31, label %if.else.34

if.then.31:                                       ; preds = %land.lhs.true.28
  %31 = load %struct._GimpLayerMask*, %struct._GimpLayerMask** %mask, align 8
  %32 = bitcast %struct._GimpLayerMask* %31 to %struct._GTypeInstance*
  %call32 = call i64 @gimp_drawable_get_type() #8
  %call33 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %32, i64 %call32)
  %33 = bitcast %struct._GTypeInstance* %call33 to %struct._GimpDrawable*
  store %struct._GimpDrawable* %33, %struct._GimpDrawable** %retval
  br label %return

if.else.34:                                       ; preds = %land.lhs.true.28, %if.then.21
  %34 = load %struct._GimpLayer*, %struct._GimpLayer** %layer, align 8
  %35 = bitcast %struct._GimpLayer* %34 to %struct._GTypeInstance*
  %call35 = call i64 @gimp_drawable_get_type() #8
  %call36 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %35, i64 %call35)
  %36 = bitcast %struct._GTypeInstance* %call36 to %struct._GimpDrawable*
  store %struct._GimpDrawable* %36, %struct._GimpDrawable** %retval
  br label %return

if.end.37:                                        ; preds = %if.else.19
  br label %if.end.38

if.end.38:                                        ; preds = %if.end.37
  store %struct._GimpDrawable* null, %struct._GimpDrawable** %retval
  br label %return

return:                                           ; preds = %if.end.38, %if.else.34, %if.then.31, %if.then.16, %if.else.9
  %37 = load %struct._GimpDrawable*, %struct._GimpDrawable** %retval
  ret %struct._GimpDrawable* %37
}

declare %struct._GimpItem* @gimp_item_tree_get_active_item(%struct._GimpItemTree*) #1

declare %struct._GimpLayerMask* @gimp_layer_get_mask(%struct._GimpLayer*) #1

declare i32 @gimp_layer_mask_get_edit(%struct._GimpLayerMask*) #1

; Function Attrs: nounwind uwtable
define %struct._GimpLayer* @gimp_image_get_active_layer(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca %struct._GimpLayer*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %private = alloca %struct._GimpImagePrivate*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__func__.gimp_image_get_active_layer, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store %struct._GimpLayer* null, %struct._GimpLayer** %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %15, %struct._GimpImagePrivate** %private, align 8
  %16 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %layers = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %16, i32 0, i32 27
  %17 = load %struct._GimpItemTree*, %struct._GimpItemTree** %layers, align 8
  %call13 = call %struct._GimpItem* @gimp_item_tree_get_active_item(%struct._GimpItemTree* %17)
  %18 = bitcast %struct._GimpItem* %call13 to %struct._GTypeInstance*
  %call14 = call i64 @gimp_layer_get_type() #8
  %call15 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %18, i64 %call14)
  %19 = bitcast %struct._GTypeInstance* %call15 to %struct._GimpLayer*
  store %struct._GimpLayer* %19, %struct._GimpLayer** %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %20 = load %struct._GimpLayer*, %struct._GimpLayer** %retval
  ret %struct._GimpLayer* %20
}

; Function Attrs: nounwind uwtable
define %struct._GimpChannel* @gimp_image_get_active_channel(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca %struct._GimpChannel*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %private = alloca %struct._GimpImagePrivate*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__func__.gimp_image_get_active_channel, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store %struct._GimpChannel* null, %struct._GimpChannel** %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %15, %struct._GimpImagePrivate** %private, align 8
  %16 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %channels = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %16, i32 0, i32 28
  %17 = load %struct._GimpItemTree*, %struct._GimpItemTree** %channels, align 8
  %call13 = call %struct._GimpItem* @gimp_item_tree_get_active_item(%struct._GimpItemTree* %17)
  %18 = bitcast %struct._GimpItem* %call13 to %struct._GTypeInstance*
  %call14 = call i64 @gimp_channel_get_type() #8
  %call15 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %18, i64 %call14)
  %19 = bitcast %struct._GTypeInstance* %call15 to %struct._GimpChannel*
  store %struct._GimpChannel* %19, %struct._GimpChannel** %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %20 = load %struct._GimpChannel*, %struct._GimpChannel** %retval
  ret %struct._GimpChannel* %20
}

; Function Attrs: nounwind readnone
declare i64 @gimp_channel_get_type() #2

; Function Attrs: nounwind uwtable
define %struct._GimpVectors* @gimp_image_get_active_vectors(%struct._GimpImage* %image) #3 {
entry:
  %retval = alloca %struct._GimpVectors*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %private = alloca %struct._GimpImagePrivate*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__func__.gimp_image_get_active_vectors, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store %struct._GimpVectors* null, %struct._GimpVectors** %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %15, %struct._GimpImagePrivate** %private, align 8
  %16 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %vectors = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %16, i32 0, i32 29
  %17 = load %struct._GimpItemTree*, %struct._GimpItemTree** %vectors, align 8
  %call13 = call %struct._GimpItem* @gimp_item_tree_get_active_item(%struct._GimpItemTree* %17)
  %18 = bitcast %struct._GimpItem* %call13 to %struct._GTypeInstance*
  %call14 = call i64 @gimp_vectors_get_type() #8
  %call15 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %18, i64 %call14)
  %19 = bitcast %struct._GTypeInstance* %call15 to %struct._GimpVectors*
  store %struct._GimpVectors* %19, %struct._GimpVectors** %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %20 = load %struct._GimpVectors*, %struct._GimpVectors** %retval
  ret %struct._GimpVectors* %20
}

; Function Attrs: nounwind readnone
declare i64 @gimp_vectors_get_type() #2

; Function Attrs: nounwind uwtable
define %struct._GimpLayer* @gimp_image_set_active_layer(%struct._GimpImage* %image, %struct._GimpLayer* %layer) #3 {
entry:
  %retval = alloca %struct._GimpLayer*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %layer.addr = alloca %struct._GimpLayer*, align 8
  %private = alloca %struct._GimpImagePrivate*, align 8
  %floating_sel = alloca %struct._GimpLayer*, align 8
  %active_layer = alloca %struct._GimpLayer*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  %__inst14 = alloca %struct._GTypeInstance*, align 8
  %__t16 = alloca i64, align 8
  %__r19 = alloca i32, align 4
  %tmp34 = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store %struct._GimpLayer* %layer, %struct._GimpLayer** %layer.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__func__.gimp_image_set_active_layer, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store %struct._GimpLayer* null, %struct._GimpLayer** %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  br label %do.body.11

do.body.11:                                       ; preds = %do.end
  %13 = load %struct._GimpLayer*, %struct._GimpLayer** %layer.addr, align 8
  %cmp12 = icmp eq %struct._GimpLayer* %13, null
  br i1 %cmp12, label %if.then.36, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.body.11
  %14 = load %struct._GimpLayer*, %struct._GimpLayer** %layer.addr, align 8
  %15 = bitcast %struct._GimpLayer* %14 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %15, %struct._GTypeInstance** %__inst14, align 8
  %call17 = call i64 @gimp_layer_get_type() #8
  store i64 %call17, i64* %__t16, align 8
  %16 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst14, align 8
  %tobool20 = icmp ne %struct._GTypeInstance* %16, null
  br i1 %tobool20, label %if.else.22, label %if.then.21

if.then.21:                                       ; preds = %lor.lhs.false
  store i32 0, i32* %__r19, align 4
  br label %if.end.33

if.else.22:                                       ; preds = %lor.lhs.false
  %17 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst14, align 8
  %g_class23 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %17, i32 0, i32 0
  %18 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class23, align 8
  %tobool24 = icmp ne %struct._GTypeClass* %18, null
  br i1 %tobool24, label %land.lhs.true.25, label %if.else.30

land.lhs.true.25:                                 ; preds = %if.else.22
  %19 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst14, align 8
  %g_class26 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %19, i32 0, i32 0
  %20 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class26, align 8
  %g_type27 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %20, i32 0, i32 0
  %21 = load i64, i64* %g_type27, align 8
  %22 = load i64, i64* %__t16, align 8
  %cmp28 = icmp eq i64 %21, %22
  br i1 %cmp28, label %if.then.29, label %if.else.30

if.then.29:                                       ; preds = %land.lhs.true.25
  store i32 1, i32* %__r19, align 4
  br label %if.end.32

if.else.30:                                       ; preds = %land.lhs.true.25, %if.else.22
  %23 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst14, align 8
  %24 = load i64, i64* %__t16, align 8
  %call31 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %23, i64 %24) #9
  store i32 %call31, i32* %__r19, align 4
  br label %if.end.32

if.end.32:                                        ; preds = %if.else.30, %if.then.29
  br label %if.end.33

if.end.33:                                        ; preds = %if.end.32, %if.then.21
  %25 = load i32, i32* %__r19, align 4
  store i32 %25, i32* %tmp34
  %26 = load i32, i32* %tmp34
  %tobool35 = icmp ne i32 %26, 0
  br i1 %tobool35, label %if.then.36, label %if.else.37

if.then.36:                                       ; preds = %if.end.33, %do.body.11
  br label %if.end.38

if.else.37:                                       ; preds = %if.end.33
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__func__.gimp_image_set_active_layer, i32 0, i32 0), i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.43, i32 0, i32 0))
  store %struct._GimpLayer* null, %struct._GimpLayer** %retval
  br label %return

if.end.38:                                        ; preds = %if.then.36
  br label %do.end.39

do.end.39:                                        ; preds = %if.end.38
  br label %do.body.40

do.body.40:                                       ; preds = %do.end.39
  %27 = load %struct._GimpLayer*, %struct._GimpLayer** %layer.addr, align 8
  %cmp41 = icmp eq %struct._GimpLayer* %27, null
  br i1 %cmp41, label %if.then.52, label %lor.lhs.false.42

lor.lhs.false.42:                                 ; preds = %do.body.40
  %28 = load %struct._GimpLayer*, %struct._GimpLayer** %layer.addr, align 8
  %29 = bitcast %struct._GimpLayer* %28 to %struct._GTypeInstance*
  %call43 = call i64 @gimp_item_get_type() #8
  %call44 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %29, i64 %call43)
  %30 = bitcast %struct._GTypeInstance* %call44 to %struct._GimpItem*
  %call45 = call i32 @gimp_item_is_attached(%struct._GimpItem* %30)
  %tobool46 = icmp ne i32 %call45, 0
  br i1 %tobool46, label %land.lhs.true.47, label %if.else.53

land.lhs.true.47:                                 ; preds = %lor.lhs.false.42
  %31 = load %struct._GimpLayer*, %struct._GimpLayer** %layer.addr, align 8
  %32 = bitcast %struct._GimpLayer* %31 to %struct._GTypeInstance*
  %call48 = call i64 @gimp_item_get_type() #8
  %call49 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %32, i64 %call48)
  %33 = bitcast %struct._GTypeInstance* %call49 to %struct._GimpItem*
  %call50 = call %struct._GimpImage* @gimp_item_get_image(%struct._GimpItem* %33)
  %34 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %cmp51 = icmp eq %struct._GimpImage* %call50, %34
  br i1 %cmp51, label %if.then.52, label %if.else.53

if.then.52:                                       ; preds = %land.lhs.true.47, %do.body.40
  br label %if.end.54

if.else.53:                                       ; preds = %land.lhs.true.47, %lor.lhs.false.42
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @__func__.gimp_image_set_active_layer, i32 0, i32 0), i8* getelementptr inbounds ([113 x i8], [113 x i8]* @.str.44, i32 0, i32 0))
  store %struct._GimpLayer* null, %struct._GimpLayer** %retval
  br label %return

if.end.54:                                        ; preds = %if.then.52
  br label %do.end.55

do.end.55:                                        ; preds = %if.end.54
  %35 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %36 = bitcast %struct._GimpImage* %35 to %struct._GTypeInstance*
  %call56 = call i64 @gimp_image_get_type() #8
  %call57 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %36, i64 %call56)
  %37 = bitcast i8* %call57 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %37, %struct._GimpImagePrivate** %private, align 8
  %38 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call58 = call %struct._GimpLayer* @gimp_image_get_floating_selection(%struct._GimpImage* %38)
  store %struct._GimpLayer* %call58, %struct._GimpLayer** %floating_sel, align 8
  %39 = load %struct._GimpLayer*, %struct._GimpLayer** %floating_sel, align 8
  %tobool59 = icmp ne %struct._GimpLayer* %39, null
  br i1 %tobool59, label %land.lhs.true.60, label %if.end.63

land.lhs.true.60:                                 ; preds = %do.end.55
  %40 = load %struct._GimpLayer*, %struct._GimpLayer** %layer.addr, align 8
  %41 = load %struct._GimpLayer*, %struct._GimpLayer** %floating_sel, align 8
  %cmp61 = icmp ne %struct._GimpLayer* %40, %41
  br i1 %cmp61, label %if.then.62, label %if.end.63

if.then.62:                                       ; preds = %land.lhs.true.60
  %42 = load %struct._GimpLayer*, %struct._GimpLayer** %floating_sel, align 8
  store %struct._GimpLayer* %42, %struct._GimpLayer** %retval
  br label %return

if.end.63:                                        ; preds = %land.lhs.true.60, %do.end.55
  %43 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call64 = call %struct._GimpLayer* @gimp_image_get_active_layer(%struct._GimpImage* %43)
  store %struct._GimpLayer* %call64, %struct._GimpLayer** %active_layer, align 8
  %44 = load %struct._GimpLayer*, %struct._GimpLayer** %layer.addr, align 8
  %45 = load %struct._GimpLayer*, %struct._GimpLayer** %active_layer, align 8
  %cmp65 = icmp ne %struct._GimpLayer* %44, %45
  br i1 %cmp65, label %if.then.66, label %if.end.74

if.then.66:                                       ; preds = %if.end.63
  %46 = load %struct._GimpLayer*, %struct._GimpLayer** %active_layer, align 8
  %tobool67 = icmp ne %struct._GimpLayer* %46, null
  br i1 %tobool67, label %if.then.68, label %if.end.71

if.then.68:                                       ; preds = %if.then.66
  %47 = load %struct._GimpLayer*, %struct._GimpLayer** %active_layer, align 8
  %48 = bitcast %struct._GimpLayer* %47 to %struct._GTypeInstance*
  %call69 = call i64 @gimp_drawable_get_type() #8
  %call70 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %48, i64 %call69)
  %49 = bitcast %struct._GTypeInstance* %call70 to %struct._GimpDrawable*
  call void @gimp_drawable_invalidate_boundary(%struct._GimpDrawable* %49)
  br label %if.end.71

if.end.71:                                        ; preds = %if.then.68, %if.then.66
  %50 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %layers = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %50, i32 0, i32 27
  %51 = load %struct._GimpItemTree*, %struct._GimpItemTree** %layers, align 8
  %52 = load %struct._GimpLayer*, %struct._GimpLayer** %layer.addr, align 8
  %53 = bitcast %struct._GimpLayer* %52 to %struct._GTypeInstance*
  %call72 = call i64 @gimp_item_get_type() #8
  %call73 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %53, i64 %call72)
  %54 = bitcast %struct._GTypeInstance* %call73 to %struct._GimpItem*
  call void @gimp_item_tree_set_active_item(%struct._GimpItemTree* %51, %struct._GimpItem* %54)
  br label %if.end.74

if.end.74:                                        ; preds = %if.end.71, %if.end.63
  %55 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call75 = call %struct._GimpLayer* @gimp_image_get_active_layer(%struct._GimpImage* %55)
  store %struct._GimpLayer* %call75, %struct._GimpLayer** %retval
  br label %return

return:                                           ; preds = %if.end.74, %if.then.62, %if.else.53, %if.else.37, %if.else.9
  %56 = load %struct._GimpLayer*, %struct._GimpLayer** %retval
  ret %struct._GimpLayer* %56
}

declare i32 @gimp_item_is_attached(%struct._GimpItem*) #1

declare %struct._GimpImage* @gimp_item_get_image(%struct._GimpItem*) #1

declare void @gimp_drawable_invalidate_boundary(%struct._GimpDrawable*) #1

declare void @gimp_item_tree_set_active_item(%struct._GimpItemTree*, %struct._GimpItem*) #1

; Function Attrs: nounwind uwtable
define %struct._GimpChannel* @gimp_image_set_active_channel(%struct._GimpImage* %image, %struct._GimpChannel* %channel) #3 {
entry:
  %retval = alloca %struct._GimpChannel*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %channel.addr = alloca %struct._GimpChannel*, align 8
  %private = alloca %struct._GimpImagePrivate*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  %__inst14 = alloca %struct._GTypeInstance*, align 8
  %__t16 = alloca i64, align 8
  %__r19 = alloca i32, align 4
  %tmp34 = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store %struct._GimpChannel* %channel, %struct._GimpChannel** %channel.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__func__.gimp_image_set_active_channel, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store %struct._GimpChannel* null, %struct._GimpChannel** %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  br label %do.body.11

do.body.11:                                       ; preds = %do.end
  %13 = load %struct._GimpChannel*, %struct._GimpChannel** %channel.addr, align 8
  %cmp12 = icmp eq %struct._GimpChannel* %13, null
  br i1 %cmp12, label %if.then.36, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.body.11
  %14 = load %struct._GimpChannel*, %struct._GimpChannel** %channel.addr, align 8
  %15 = bitcast %struct._GimpChannel* %14 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %15, %struct._GTypeInstance** %__inst14, align 8
  %call17 = call i64 @gimp_channel_get_type() #8
  store i64 %call17, i64* %__t16, align 8
  %16 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst14, align 8
  %tobool20 = icmp ne %struct._GTypeInstance* %16, null
  br i1 %tobool20, label %if.else.22, label %if.then.21

if.then.21:                                       ; preds = %lor.lhs.false
  store i32 0, i32* %__r19, align 4
  br label %if.end.33

if.else.22:                                       ; preds = %lor.lhs.false
  %17 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst14, align 8
  %g_class23 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %17, i32 0, i32 0
  %18 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class23, align 8
  %tobool24 = icmp ne %struct._GTypeClass* %18, null
  br i1 %tobool24, label %land.lhs.true.25, label %if.else.30

land.lhs.true.25:                                 ; preds = %if.else.22
  %19 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst14, align 8
  %g_class26 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %19, i32 0, i32 0
  %20 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class26, align 8
  %g_type27 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %20, i32 0, i32 0
  %21 = load i64, i64* %g_type27, align 8
  %22 = load i64, i64* %__t16, align 8
  %cmp28 = icmp eq i64 %21, %22
  br i1 %cmp28, label %if.then.29, label %if.else.30

if.then.29:                                       ; preds = %land.lhs.true.25
  store i32 1, i32* %__r19, align 4
  br label %if.end.32

if.else.30:                                       ; preds = %land.lhs.true.25, %if.else.22
  %23 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst14, align 8
  %24 = load i64, i64* %__t16, align 8
  %call31 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %23, i64 %24) #9
  store i32 %call31, i32* %__r19, align 4
  br label %if.end.32

if.end.32:                                        ; preds = %if.else.30, %if.then.29
  br label %if.end.33

if.end.33:                                        ; preds = %if.end.32, %if.then.21
  %25 = load i32, i32* %__r19, align 4
  store i32 %25, i32* %tmp34
  %26 = load i32, i32* %tmp34
  %tobool35 = icmp ne i32 %26, 0
  br i1 %tobool35, label %if.then.36, label %if.else.37

if.then.36:                                       ; preds = %if.end.33, %do.body.11
  br label %if.end.38

if.else.37:                                       ; preds = %if.end.33
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__func__.gimp_image_set_active_channel, i32 0, i32 0), i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.45, i32 0, i32 0))
  store %struct._GimpChannel* null, %struct._GimpChannel** %retval
  br label %return

if.end.38:                                        ; preds = %if.then.36
  br label %do.end.39

do.end.39:                                        ; preds = %if.end.38
  br label %do.body.40

do.body.40:                                       ; preds = %do.end.39
  %27 = load %struct._GimpChannel*, %struct._GimpChannel** %channel.addr, align 8
  %cmp41 = icmp eq %struct._GimpChannel* %27, null
  br i1 %cmp41, label %if.then.52, label %lor.lhs.false.42

lor.lhs.false.42:                                 ; preds = %do.body.40
  %28 = load %struct._GimpChannel*, %struct._GimpChannel** %channel.addr, align 8
  %29 = bitcast %struct._GimpChannel* %28 to %struct._GTypeInstance*
  %call43 = call i64 @gimp_item_get_type() #8
  %call44 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %29, i64 %call43)
  %30 = bitcast %struct._GTypeInstance* %call44 to %struct._GimpItem*
  %call45 = call i32 @gimp_item_is_attached(%struct._GimpItem* %30)
  %tobool46 = icmp ne i32 %call45, 0
  br i1 %tobool46, label %land.lhs.true.47, label %if.else.53

land.lhs.true.47:                                 ; preds = %lor.lhs.false.42
  %31 = load %struct._GimpChannel*, %struct._GimpChannel** %channel.addr, align 8
  %32 = bitcast %struct._GimpChannel* %31 to %struct._GTypeInstance*
  %call48 = call i64 @gimp_item_get_type() #8
  %call49 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %32, i64 %call48)
  %33 = bitcast %struct._GTypeInstance* %call49 to %struct._GimpItem*
  %call50 = call %struct._GimpImage* @gimp_item_get_image(%struct._GimpItem* %33)
  %34 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %cmp51 = icmp eq %struct._GimpImage* %call50, %34
  br i1 %cmp51, label %if.then.52, label %if.else.53

if.then.52:                                       ; preds = %land.lhs.true.47, %do.body.40
  br label %if.end.54

if.else.53:                                       ; preds = %land.lhs.true.47, %lor.lhs.false.42
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__func__.gimp_image_set_active_channel, i32 0, i32 0), i8* getelementptr inbounds ([119 x i8], [119 x i8]* @.str.46, i32 0, i32 0))
  store %struct._GimpChannel* null, %struct._GimpChannel** %retval
  br label %return

if.end.54:                                        ; preds = %if.then.52
  br label %do.end.55

do.end.55:                                        ; preds = %if.end.54
  %35 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %36 = bitcast %struct._GimpImage* %35 to %struct._GTypeInstance*
  %call56 = call i64 @gimp_image_get_type() #8
  %call57 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %36, i64 %call56)
  %37 = bitcast i8* %call57 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %37, %struct._GimpImagePrivate** %private, align 8
  %38 = load %struct._GimpChannel*, %struct._GimpChannel** %channel.addr, align 8
  %tobool58 = icmp ne %struct._GimpChannel* %38, null
  br i1 %tobool58, label %land.lhs.true.59, label %if.end.63

land.lhs.true.59:                                 ; preds = %do.end.55
  %39 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call60 = call %struct._GimpLayer* @gimp_image_get_floating_selection(%struct._GimpImage* %39)
  %tobool61 = icmp ne %struct._GimpLayer* %call60, null
  br i1 %tobool61, label %if.then.62, label %if.end.63

if.then.62:                                       ; preds = %land.lhs.true.59
  store %struct._GimpChannel* null, %struct._GimpChannel** %retval
  br label %return

if.end.63:                                        ; preds = %land.lhs.true.59, %do.end.55
  %40 = load %struct._GimpChannel*, %struct._GimpChannel** %channel.addr, align 8
  %41 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call64 = call %struct._GimpChannel* @gimp_image_get_active_channel(%struct._GimpImage* %41)
  %cmp65 = icmp ne %struct._GimpChannel* %40, %call64
  br i1 %cmp65, label %if.then.66, label %if.end.69

if.then.66:                                       ; preds = %if.end.63
  %42 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %channels = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %42, i32 0, i32 28
  %43 = load %struct._GimpItemTree*, %struct._GimpItemTree** %channels, align 8
  %44 = load %struct._GimpChannel*, %struct._GimpChannel** %channel.addr, align 8
  %45 = bitcast %struct._GimpChannel* %44 to %struct._GTypeInstance*
  %call67 = call i64 @gimp_item_get_type() #8
  %call68 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %45, i64 %call67)
  %46 = bitcast %struct._GTypeInstance* %call68 to %struct._GimpItem*
  call void @gimp_item_tree_set_active_item(%struct._GimpItemTree* %43, %struct._GimpItem* %46)
  br label %if.end.69

if.end.69:                                        ; preds = %if.then.66, %if.end.63
  %47 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call70 = call %struct._GimpChannel* @gimp_image_get_active_channel(%struct._GimpImage* %47)
  store %struct._GimpChannel* %call70, %struct._GimpChannel** %retval
  br label %return

return:                                           ; preds = %if.end.69, %if.then.62, %if.else.53, %if.else.37, %if.else.9
  %48 = load %struct._GimpChannel*, %struct._GimpChannel** %retval
  ret %struct._GimpChannel* %48
}

; Function Attrs: nounwind uwtable
define %struct._GimpVectors* @gimp_image_set_active_vectors(%struct._GimpImage* %image, %struct._GimpVectors* %vectors) #3 {
entry:
  %retval = alloca %struct._GimpVectors*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %vectors.addr = alloca %struct._GimpVectors*, align 8
  %private = alloca %struct._GimpImagePrivate*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  %__inst14 = alloca %struct._GTypeInstance*, align 8
  %__t16 = alloca i64, align 8
  %__r19 = alloca i32, align 4
  %tmp34 = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store %struct._GimpVectors* %vectors, %struct._GimpVectors** %vectors.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__func__.gimp_image_set_active_vectors, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store %struct._GimpVectors* null, %struct._GimpVectors** %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  br label %do.body.11

do.body.11:                                       ; preds = %do.end
  %13 = load %struct._GimpVectors*, %struct._GimpVectors** %vectors.addr, align 8
  %cmp12 = icmp eq %struct._GimpVectors* %13, null
  br i1 %cmp12, label %if.then.36, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.body.11
  %14 = load %struct._GimpVectors*, %struct._GimpVectors** %vectors.addr, align 8
  %15 = bitcast %struct._GimpVectors* %14 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %15, %struct._GTypeInstance** %__inst14, align 8
  %call17 = call i64 @gimp_vectors_get_type() #8
  store i64 %call17, i64* %__t16, align 8
  %16 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst14, align 8
  %tobool20 = icmp ne %struct._GTypeInstance* %16, null
  br i1 %tobool20, label %if.else.22, label %if.then.21

if.then.21:                                       ; preds = %lor.lhs.false
  store i32 0, i32* %__r19, align 4
  br label %if.end.33

if.else.22:                                       ; preds = %lor.lhs.false
  %17 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst14, align 8
  %g_class23 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %17, i32 0, i32 0
  %18 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class23, align 8
  %tobool24 = icmp ne %struct._GTypeClass* %18, null
  br i1 %tobool24, label %land.lhs.true.25, label %if.else.30

land.lhs.true.25:                                 ; preds = %if.else.22
  %19 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst14, align 8
  %g_class26 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %19, i32 0, i32 0
  %20 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class26, align 8
  %g_type27 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %20, i32 0, i32 0
  %21 = load i64, i64* %g_type27, align 8
  %22 = load i64, i64* %__t16, align 8
  %cmp28 = icmp eq i64 %21, %22
  br i1 %cmp28, label %if.then.29, label %if.else.30

if.then.29:                                       ; preds = %land.lhs.true.25
  store i32 1, i32* %__r19, align 4
  br label %if.end.32

if.else.30:                                       ; preds = %land.lhs.true.25, %if.else.22
  %23 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst14, align 8
  %24 = load i64, i64* %__t16, align 8
  %call31 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %23, i64 %24) #9
  store i32 %call31, i32* %__r19, align 4
  br label %if.end.32

if.end.32:                                        ; preds = %if.else.30, %if.then.29
  br label %if.end.33

if.end.33:                                        ; preds = %if.end.32, %if.then.21
  %25 = load i32, i32* %__r19, align 4
  store i32 %25, i32* %tmp34
  %26 = load i32, i32* %tmp34
  %tobool35 = icmp ne i32 %26, 0
  br i1 %tobool35, label %if.then.36, label %if.else.37

if.then.36:                                       ; preds = %if.end.33, %do.body.11
  br label %if.end.38

if.else.37:                                       ; preds = %if.end.33
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__func__.gimp_image_set_active_vectors, i32 0, i32 0), i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.47, i32 0, i32 0))
  store %struct._GimpVectors* null, %struct._GimpVectors** %retval
  br label %return

if.end.38:                                        ; preds = %if.then.36
  br label %do.end.39

do.end.39:                                        ; preds = %if.end.38
  br label %do.body.40

do.body.40:                                       ; preds = %do.end.39
  %27 = load %struct._GimpVectors*, %struct._GimpVectors** %vectors.addr, align 8
  %cmp41 = icmp eq %struct._GimpVectors* %27, null
  br i1 %cmp41, label %if.then.52, label %lor.lhs.false.42

lor.lhs.false.42:                                 ; preds = %do.body.40
  %28 = load %struct._GimpVectors*, %struct._GimpVectors** %vectors.addr, align 8
  %29 = bitcast %struct._GimpVectors* %28 to %struct._GTypeInstance*
  %call43 = call i64 @gimp_item_get_type() #8
  %call44 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %29, i64 %call43)
  %30 = bitcast %struct._GTypeInstance* %call44 to %struct._GimpItem*
  %call45 = call i32 @gimp_item_is_attached(%struct._GimpItem* %30)
  %tobool46 = icmp ne i32 %call45, 0
  br i1 %tobool46, label %land.lhs.true.47, label %if.else.53

land.lhs.true.47:                                 ; preds = %lor.lhs.false.42
  %31 = load %struct._GimpVectors*, %struct._GimpVectors** %vectors.addr, align 8
  %32 = bitcast %struct._GimpVectors* %31 to %struct._GTypeInstance*
  %call48 = call i64 @gimp_item_get_type() #8
  %call49 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %32, i64 %call48)
  %33 = bitcast %struct._GTypeInstance* %call49 to %struct._GimpItem*
  %call50 = call %struct._GimpImage* @gimp_item_get_image(%struct._GimpItem* %33)
  %34 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %cmp51 = icmp eq %struct._GimpImage* %call50, %34
  br i1 %cmp51, label %if.then.52, label %if.else.53

if.then.52:                                       ; preds = %land.lhs.true.47, %do.body.40
  br label %if.end.54

if.else.53:                                       ; preds = %land.lhs.true.47, %lor.lhs.false.42
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([30 x i8], [30 x i8]* @__func__.gimp_image_set_active_vectors, i32 0, i32 0), i8* getelementptr inbounds ([119 x i8], [119 x i8]* @.str.48, i32 0, i32 0))
  store %struct._GimpVectors* null, %struct._GimpVectors** %retval
  br label %return

if.end.54:                                        ; preds = %if.then.52
  br label %do.end.55

do.end.55:                                        ; preds = %if.end.54
  %35 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %36 = bitcast %struct._GimpImage* %35 to %struct._GTypeInstance*
  %call56 = call i64 @gimp_image_get_type() #8
  %call57 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %36, i64 %call56)
  %37 = bitcast i8* %call57 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %37, %struct._GimpImagePrivate** %private, align 8
  %38 = load %struct._GimpVectors*, %struct._GimpVectors** %vectors.addr, align 8
  %39 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call58 = call %struct._GimpVectors* @gimp_image_get_active_vectors(%struct._GimpImage* %39)
  %cmp59 = icmp ne %struct._GimpVectors* %38, %call58
  br i1 %cmp59, label %if.then.60, label %if.end.64

if.then.60:                                       ; preds = %do.end.55
  %40 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %vectors61 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %40, i32 0, i32 29
  %41 = load %struct._GimpItemTree*, %struct._GimpItemTree** %vectors61, align 8
  %42 = load %struct._GimpVectors*, %struct._GimpVectors** %vectors.addr, align 8
  %43 = bitcast %struct._GimpVectors* %42 to %struct._GTypeInstance*
  %call62 = call i64 @gimp_item_get_type() #8
  %call63 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %43, i64 %call62)
  %44 = bitcast %struct._GTypeInstance* %call63 to %struct._GimpItem*
  call void @gimp_item_tree_set_active_item(%struct._GimpItemTree* %41, %struct._GimpItem* %44)
  br label %if.end.64

if.end.64:                                        ; preds = %if.then.60, %do.end.55
  %45 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call65 = call %struct._GimpVectors* @gimp_image_get_active_vectors(%struct._GimpImage* %45)
  store %struct._GimpVectors* %call65, %struct._GimpVectors** %retval
  br label %return

return:                                           ; preds = %if.end.64, %if.else.53, %if.else.37, %if.else.9
  %46 = load %struct._GimpVectors*, %struct._GimpVectors** %retval
  ret %struct._GimpVectors* %46
}

; Function Attrs: nounwind uwtable
define %struct._GimpLayer* @gimp_image_get_layer_by_tattoo(%struct._GimpImage* %image, i32 %tattoo) #3 {
entry:
  %retval = alloca %struct._GimpLayer*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %tattoo.addr = alloca i32, align 4
  %stack = alloca %struct._GimpItemStack*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store i32 %tattoo, i32* %tattoo.addr, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([31 x i8], [31 x i8]* @__func__.gimp_image_get_layer_by_tattoo, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store %struct._GimpLayer* null, %struct._GimpLayer** %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call11 = call %struct._GimpContainer* @gimp_image_get_layers(%struct._GimpImage* %13)
  %14 = bitcast %struct._GimpContainer* %call11 to %struct._GTypeInstance*
  %call12 = call i64 @gimp_item_stack_get_type() #8
  %call13 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %14, i64 %call12)
  %15 = bitcast %struct._GTypeInstance* %call13 to %struct._GimpItemStack*
  store %struct._GimpItemStack* %15, %struct._GimpItemStack** %stack, align 8
  %16 = load %struct._GimpItemStack*, %struct._GimpItemStack** %stack, align 8
  %17 = load i32, i32* %tattoo.addr, align 4
  %call14 = call %struct._GimpItem* @gimp_item_stack_get_item_by_tattoo(%struct._GimpItemStack* %16, i32 %17)
  %18 = bitcast %struct._GimpItem* %call14 to %struct._GTypeInstance*
  %call15 = call i64 @gimp_layer_get_type() #8
  %call16 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %18, i64 %call15)
  %19 = bitcast %struct._GTypeInstance* %call16 to %struct._GimpLayer*
  store %struct._GimpLayer* %19, %struct._GimpLayer** %retval
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  %20 = load %struct._GimpLayer*, %struct._GimpLayer** %retval
  ret %struct._GimpLayer* %20
}

declare %struct._GimpItem* @gimp_item_stack_get_item_by_tattoo(%struct._GimpItemStack*, i32) #1

; Function Attrs: nounwind uwtable
define %struct._GimpLayer* @gimp_image_get_layer_by_name(%struct._GimpImage* %image, i8* %name) #3 {
entry:
  %retval = alloca %struct._GimpLayer*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %name.addr = alloca i8*, align 8
  %tree = alloca %struct._GimpItemTree*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store i8* %name, i8** %name.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @__func__.gimp_image_get_layer_by_name, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store %struct._GimpLayer* null, %struct._GimpLayer** %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  br label %do.body.11

do.body.11:                                       ; preds = %do.end
  %13 = load i8*, i8** %name.addr, align 8
  %cmp12 = icmp ne i8* %13, null
  br i1 %cmp12, label %if.then.13, label %if.else.14

if.then.13:                                       ; preds = %do.body.11
  br label %if.end.15

if.else.14:                                       ; preds = %do.body.11
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @__func__.gimp_image_get_layer_by_name, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.40, i32 0, i32 0))
  store %struct._GimpLayer* null, %struct._GimpLayer** %retval
  br label %return

if.end.15:                                        ; preds = %if.then.13
  br label %do.end.16

do.end.16:                                        ; preds = %if.end.15
  %14 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call17 = call %struct._GimpItemTree* @gimp_image_get_layer_tree(%struct._GimpImage* %14)
  store %struct._GimpItemTree* %call17, %struct._GimpItemTree** %tree, align 8
  %15 = load %struct._GimpItemTree*, %struct._GimpItemTree** %tree, align 8
  %16 = load i8*, i8** %name.addr, align 8
  %call18 = call %struct._GimpItem* @gimp_item_tree_get_item_by_name(%struct._GimpItemTree* %15, i8* %16)
  %17 = bitcast %struct._GimpItem* %call18 to %struct._GTypeInstance*
  %call19 = call i64 @gimp_layer_get_type() #8
  %call20 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %17, i64 %call19)
  %18 = bitcast %struct._GTypeInstance* %call20 to %struct._GimpLayer*
  store %struct._GimpLayer* %18, %struct._GimpLayer** %retval
  br label %return

return:                                           ; preds = %do.end.16, %if.else.14, %if.else.9
  %19 = load %struct._GimpLayer*, %struct._GimpLayer** %retval
  ret %struct._GimpLayer* %19
}

declare %struct._GimpItem* @gimp_item_tree_get_item_by_name(%struct._GimpItemTree*, i8*) #1

; Function Attrs: nounwind uwtable
define %struct._GimpChannel* @gimp_image_get_channel_by_name(%struct._GimpImage* %image, i8* %name) #3 {
entry:
  %retval = alloca %struct._GimpChannel*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %name.addr = alloca i8*, align 8
  %tree = alloca %struct._GimpItemTree*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store i8* %name, i8** %name.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([31 x i8], [31 x i8]* @__func__.gimp_image_get_channel_by_name, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store %struct._GimpChannel* null, %struct._GimpChannel** %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  br label %do.body.11

do.body.11:                                       ; preds = %do.end
  %13 = load i8*, i8** %name.addr, align 8
  %cmp12 = icmp ne i8* %13, null
  br i1 %cmp12, label %if.then.13, label %if.else.14

if.then.13:                                       ; preds = %do.body.11
  br label %if.end.15

if.else.14:                                       ; preds = %do.body.11
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([31 x i8], [31 x i8]* @__func__.gimp_image_get_channel_by_name, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.40, i32 0, i32 0))
  store %struct._GimpChannel* null, %struct._GimpChannel** %retval
  br label %return

if.end.15:                                        ; preds = %if.then.13
  br label %do.end.16

do.end.16:                                        ; preds = %if.end.15
  %14 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call17 = call %struct._GimpItemTree* @gimp_image_get_channel_tree(%struct._GimpImage* %14)
  store %struct._GimpItemTree* %call17, %struct._GimpItemTree** %tree, align 8
  %15 = load %struct._GimpItemTree*, %struct._GimpItemTree** %tree, align 8
  %16 = load i8*, i8** %name.addr, align 8
  %call18 = call %struct._GimpItem* @gimp_item_tree_get_item_by_name(%struct._GimpItemTree* %15, i8* %16)
  %17 = bitcast %struct._GimpItem* %call18 to %struct._GTypeInstance*
  %call19 = call i64 @gimp_channel_get_type() #8
  %call20 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %17, i64 %call19)
  %18 = bitcast %struct._GTypeInstance* %call20 to %struct._GimpChannel*
  store %struct._GimpChannel* %18, %struct._GimpChannel** %retval
  br label %return

return:                                           ; preds = %do.end.16, %if.else.14, %if.else.9
  %19 = load %struct._GimpChannel*, %struct._GimpChannel** %retval
  ret %struct._GimpChannel* %19
}

; Function Attrs: nounwind uwtable
define %struct._GimpVectors* @gimp_image_get_vectors_by_name(%struct._GimpImage* %image, i8* %name) #3 {
entry:
  %retval = alloca %struct._GimpVectors*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %name.addr = alloca i8*, align 8
  %tree = alloca %struct._GimpItemTree*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store i8* %name, i8** %name.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([31 x i8], [31 x i8]* @__func__.gimp_image_get_vectors_by_name, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store %struct._GimpVectors* null, %struct._GimpVectors** %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  br label %do.body.11

do.body.11:                                       ; preds = %do.end
  %13 = load i8*, i8** %name.addr, align 8
  %cmp12 = icmp ne i8* %13, null
  br i1 %cmp12, label %if.then.13, label %if.else.14

if.then.13:                                       ; preds = %do.body.11
  br label %if.end.15

if.else.14:                                       ; preds = %do.body.11
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([31 x i8], [31 x i8]* @__func__.gimp_image_get_vectors_by_name, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.40, i32 0, i32 0))
  store %struct._GimpVectors* null, %struct._GimpVectors** %retval
  br label %return

if.end.15:                                        ; preds = %if.then.13
  br label %do.end.16

do.end.16:                                        ; preds = %if.end.15
  %14 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call17 = call %struct._GimpItemTree* @gimp_image_get_vectors_tree(%struct._GimpImage* %14)
  store %struct._GimpItemTree* %call17, %struct._GimpItemTree** %tree, align 8
  %15 = load %struct._GimpItemTree*, %struct._GimpItemTree** %tree, align 8
  %16 = load i8*, i8** %name.addr, align 8
  %call18 = call %struct._GimpItem* @gimp_item_tree_get_item_by_name(%struct._GimpItemTree* %15, i8* %16)
  %17 = bitcast %struct._GimpItem* %call18 to %struct._GTypeInstance*
  %call19 = call i64 @gimp_vectors_get_type() #8
  %call20 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %17, i64 %call19)
  %18 = bitcast %struct._GTypeInstance* %call20 to %struct._GimpVectors*
  store %struct._GimpVectors* %18, %struct._GimpVectors** %retval
  br label %return

return:                                           ; preds = %do.end.16, %if.else.14, %if.else.9
  %19 = load %struct._GimpVectors*, %struct._GimpVectors** %retval
  ret %struct._GimpVectors* %19
}

; Function Attrs: nounwind uwtable
define i32 @gimp_image_reorder_item(%struct._GimpImage* %image, %struct._GimpItem* %item, %struct._GimpItem* %new_parent, i32 %new_index, i32 %push_undo, i8* %undo_desc) #3 {
entry:
  %retval = alloca i32, align 4
  %image.addr = alloca %struct._GimpImage*, align 8
  %item.addr = alloca %struct._GimpItem*, align 8
  %new_parent.addr = alloca %struct._GimpItem*, align 8
  %new_index.addr = alloca i32, align 4
  %push_undo.addr = alloca i32, align 4
  %undo_desc.addr = alloca i8*, align 8
  %tree = alloca %struct._GimpItemTree*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  %__inst13 = alloca %struct._GTypeInstance*, align 8
  %__t15 = alloca i64, align 8
  %__r18 = alloca i32, align 4
  %tmp33 = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store %struct._GimpItem* %item, %struct._GimpItem** %item.addr, align 8
  store %struct._GimpItem* %new_parent, %struct._GimpItem** %new_parent.addr, align 8
  store i32 %new_index, i32* %new_index.addr, align 4
  store i32 %push_undo, i32* %push_undo.addr, align 4
  store i8* %undo_desc, i8** %undo_desc.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__func__.gimp_image_reorder_item, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store i32 0, i32* %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  br label %do.body.11

do.body.11:                                       ; preds = %do.end
  %13 = load %struct._GimpItem*, %struct._GimpItem** %item.addr, align 8
  %14 = bitcast %struct._GimpItem* %13 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %14, %struct._GTypeInstance** %__inst13, align 8
  %call16 = call i64 @gimp_item_get_type() #8
  store i64 %call16, i64* %__t15, align 8
  %15 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %tobool19 = icmp ne %struct._GTypeInstance* %15, null
  br i1 %tobool19, label %if.else.21, label %if.then.20

if.then.20:                                       ; preds = %do.body.11
  store i32 0, i32* %__r18, align 4
  br label %if.end.32

if.else.21:                                       ; preds = %do.body.11
  %16 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %g_class22 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %16, i32 0, i32 0
  %17 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class22, align 8
  %tobool23 = icmp ne %struct._GTypeClass* %17, null
  br i1 %tobool23, label %land.lhs.true.24, label %if.else.29

land.lhs.true.24:                                 ; preds = %if.else.21
  %18 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %g_class25 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %18, i32 0, i32 0
  %19 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class25, align 8
  %g_type26 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %19, i32 0, i32 0
  %20 = load i64, i64* %g_type26, align 8
  %21 = load i64, i64* %__t15, align 8
  %cmp27 = icmp eq i64 %20, %21
  br i1 %cmp27, label %if.then.28, label %if.else.29

if.then.28:                                       ; preds = %land.lhs.true.24
  store i32 1, i32* %__r18, align 4
  br label %if.end.31

if.else.29:                                       ; preds = %land.lhs.true.24, %if.else.21
  %22 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %23 = load i64, i64* %__t15, align 8
  %call30 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %22, i64 %23) #9
  store i32 %call30, i32* %__r18, align 4
  br label %if.end.31

if.end.31:                                        ; preds = %if.else.29, %if.then.28
  br label %if.end.32

if.end.32:                                        ; preds = %if.end.31, %if.then.20
  %24 = load i32, i32* %__r18, align 4
  store i32 %24, i32* %tmp33
  %25 = load i32, i32* %tmp33
  %tobool34 = icmp ne i32 %25, 0
  br i1 %tobool34, label %if.then.35, label %if.else.36

if.then.35:                                       ; preds = %if.end.32
  br label %if.end.37

if.else.36:                                       ; preds = %if.end.32
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__func__.gimp_image_reorder_item, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.49, i32 0, i32 0))
  store i32 0, i32* %retval
  br label %return

if.end.37:                                        ; preds = %if.then.35
  br label %do.end.38

do.end.38:                                        ; preds = %if.end.37
  br label %do.body.39

do.body.39:                                       ; preds = %do.end.38
  %26 = load %struct._GimpItem*, %struct._GimpItem** %item.addr, align 8
  %call40 = call %struct._GimpImage* @gimp_item_get_image(%struct._GimpItem* %26)
  %27 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %cmp41 = icmp eq %struct._GimpImage* %call40, %27
  br i1 %cmp41, label %if.then.42, label %if.else.43

if.then.42:                                       ; preds = %do.body.39
  br label %if.end.44

if.else.43:                                       ; preds = %do.body.39
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__func__.gimp_image_reorder_item, i32 0, i32 0), i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.50, i32 0, i32 0))
  store i32 0, i32* %retval
  br label %return

if.end.44:                                        ; preds = %if.then.42
  br label %do.end.45

do.end.45:                                        ; preds = %if.end.44
  %28 = load %struct._GimpItem*, %struct._GimpItem** %item.addr, align 8
  %call46 = call %struct._GimpItemTree* @gimp_item_get_tree(%struct._GimpItem* %28)
  store %struct._GimpItemTree* %call46, %struct._GimpItemTree** %tree, align 8
  br label %do.body.47

do.body.47:                                       ; preds = %do.end.45
  %29 = load %struct._GimpItemTree*, %struct._GimpItemTree** %tree, align 8
  %cmp48 = icmp ne %struct._GimpItemTree* %29, null
  br i1 %cmp48, label %if.then.49, label %if.else.50

if.then.49:                                       ; preds = %do.body.47
  br label %if.end.51

if.else.50:                                       ; preds = %do.body.47
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__func__.gimp_image_reorder_item, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.51, i32 0, i32 0))
  store i32 0, i32* %retval
  br label %return

if.end.51:                                        ; preds = %if.then.49
  br label %do.end.52

do.end.52:                                        ; preds = %if.end.51
  %30 = load i32, i32* %push_undo.addr, align 4
  %tobool53 = icmp ne i32 %30, 0
  br i1 %tobool53, label %land.lhs.true.54, label %if.end.58

land.lhs.true.54:                                 ; preds = %do.end.52
  %31 = load i8*, i8** %undo_desc.addr, align 8
  %tobool55 = icmp ne i8* %31, null
  br i1 %tobool55, label %if.end.58, label %if.then.56

if.then.56:                                       ; preds = %land.lhs.true.54
  %32 = load %struct._GimpItem*, %struct._GimpItem** %item.addr, align 8
  %33 = bitcast %struct._GimpItem* %32 to %struct._GTypeInstance*
  %g_class57 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %33, i32 0, i32 0
  %34 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class57, align 8
  %35 = bitcast %struct._GTypeClass* %34 to %struct._GimpItemClass*
  %reorder_desc = getelementptr inbounds %struct._GimpItemClass, %struct._GimpItemClass* %35, i32 0, i32 31
  %36 = load i8*, i8** %reorder_desc, align 8
  store i8* %36, i8** %undo_desc.addr, align 8
  br label %if.end.58

if.end.58:                                        ; preds = %if.then.56, %land.lhs.true.54, %do.end.52
  %37 = load %struct._GimpItemTree*, %struct._GimpItemTree** %tree, align 8
  %38 = load %struct._GimpItem*, %struct._GimpItem** %item.addr, align 8
  %39 = load %struct._GimpItem*, %struct._GimpItem** %new_parent.addr, align 8
  %40 = load i32, i32* %new_index.addr, align 4
  %41 = load i32, i32* %push_undo.addr, align 4
  %42 = load i8*, i8** %undo_desc.addr, align 8
  %call59 = call i32 @gimp_item_tree_reorder_item(%struct._GimpItemTree* %37, %struct._GimpItem* %38, %struct._GimpItem* %39, i32 %40, i32 %41, i8* %42)
  store i32 %call59, i32* %retval
  br label %return

return:                                           ; preds = %if.end.58, %if.else.50, %if.else.43, %if.else.36, %if.else.9
  %43 = load i32, i32* %retval
  ret i32 %43
}

declare %struct._GimpItemTree* @gimp_item_get_tree(%struct._GimpItem*) #1

declare i32 @gimp_item_tree_reorder_item(%struct._GimpItemTree*, %struct._GimpItem*, %struct._GimpItem*, i32, i32, i8*) #1

; Function Attrs: nounwind uwtable
define i32 @gimp_image_raise_item(%struct._GimpImage* %image, %struct._GimpItem* %item, %struct._GError** %error) #3 {
entry:
  %retval = alloca i32, align 4
  %image.addr = alloca %struct._GimpImage*, align 8
  %item.addr = alloca %struct._GimpItem*, align 8
  %error.addr = alloca %struct._GError**, align 8
  %index = alloca i32, align 4
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  %__inst13 = alloca %struct._GTypeInstance*, align 8
  %__t15 = alloca i64, align 8
  %__r18 = alloca i32, align 4
  %tmp33 = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store %struct._GimpItem* %item, %struct._GimpItem** %item.addr, align 8
  store %struct._GError** %error, %struct._GError*** %error.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__func__.gimp_image_raise_item, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store i32 0, i32* %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  br label %do.body.11

do.body.11:                                       ; preds = %do.end
  %13 = load %struct._GimpItem*, %struct._GimpItem** %item.addr, align 8
  %14 = bitcast %struct._GimpItem* %13 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %14, %struct._GTypeInstance** %__inst13, align 8
  %call16 = call i64 @gimp_item_get_type() #8
  store i64 %call16, i64* %__t15, align 8
  %15 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %tobool19 = icmp ne %struct._GTypeInstance* %15, null
  br i1 %tobool19, label %if.else.21, label %if.then.20

if.then.20:                                       ; preds = %do.body.11
  store i32 0, i32* %__r18, align 4
  br label %if.end.32

if.else.21:                                       ; preds = %do.body.11
  %16 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %g_class22 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %16, i32 0, i32 0
  %17 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class22, align 8
  %tobool23 = icmp ne %struct._GTypeClass* %17, null
  br i1 %tobool23, label %land.lhs.true.24, label %if.else.29

land.lhs.true.24:                                 ; preds = %if.else.21
  %18 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %g_class25 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %18, i32 0, i32 0
  %19 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class25, align 8
  %g_type26 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %19, i32 0, i32 0
  %20 = load i64, i64* %g_type26, align 8
  %21 = load i64, i64* %__t15, align 8
  %cmp27 = icmp eq i64 %20, %21
  br i1 %cmp27, label %if.then.28, label %if.else.29

if.then.28:                                       ; preds = %land.lhs.true.24
  store i32 1, i32* %__r18, align 4
  br label %if.end.31

if.else.29:                                       ; preds = %land.lhs.true.24, %if.else.21
  %22 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %23 = load i64, i64* %__t15, align 8
  %call30 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %22, i64 %23) #9
  store i32 %call30, i32* %__r18, align 4
  br label %if.end.31

if.end.31:                                        ; preds = %if.else.29, %if.then.28
  br label %if.end.32

if.end.32:                                        ; preds = %if.end.31, %if.then.20
  %24 = load i32, i32* %__r18, align 4
  store i32 %24, i32* %tmp33
  %25 = load i32, i32* %tmp33
  %tobool34 = icmp ne i32 %25, 0
  br i1 %tobool34, label %if.then.35, label %if.else.36

if.then.35:                                       ; preds = %if.end.32
  br label %if.end.37

if.else.36:                                       ; preds = %if.end.32
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__func__.gimp_image_raise_item, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.49, i32 0, i32 0))
  store i32 0, i32* %retval
  br label %return

if.end.37:                                        ; preds = %if.then.35
  br label %do.end.38

do.end.38:                                        ; preds = %if.end.37
  br label %do.body.39

do.body.39:                                       ; preds = %do.end.38
  %26 = load %struct._GError**, %struct._GError*** %error.addr, align 8
  %cmp40 = icmp eq %struct._GError** %26, null
  br i1 %cmp40, label %if.then.42, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.body.39
  %27 = load %struct._GError**, %struct._GError*** %error.addr, align 8
  %28 = load %struct._GError*, %struct._GError** %27, align 8
  %cmp41 = icmp eq %struct._GError* %28, null
  br i1 %cmp41, label %if.then.42, label %if.else.43

if.then.42:                                       ; preds = %lor.lhs.false, %do.body.39
  br label %if.end.44

if.else.43:                                       ; preds = %lor.lhs.false
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__func__.gimp_image_raise_item, i32 0, i32 0), i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.52, i32 0, i32 0))
  store i32 0, i32* %retval
  br label %return

if.end.44:                                        ; preds = %if.then.42
  br label %do.end.45

do.end.45:                                        ; preds = %if.end.44
  %29 = load %struct._GimpItem*, %struct._GimpItem** %item.addr, align 8
  %call46 = call i32 @gimp_item_get_index(%struct._GimpItem* %29)
  store i32 %call46, i32* %index, align 4
  br label %do.body.47

do.body.47:                                       ; preds = %do.end.45
  %30 = load i32, i32* %index, align 4
  %cmp48 = icmp ne i32 %30, -1
  br i1 %cmp48, label %if.then.49, label %if.else.50

if.then.49:                                       ; preds = %do.body.47
  br label %if.end.51

if.else.50:                                       ; preds = %do.body.47
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__func__.gimp_image_raise_item, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.53, i32 0, i32 0))
  store i32 0, i32* %retval
  br label %return

if.end.51:                                        ; preds = %if.then.49
  br label %do.end.52

do.end.52:                                        ; preds = %if.end.51
  %31 = load i32, i32* %index, align 4
  %cmp53 = icmp eq i32 %31, 0
  br i1 %cmp53, label %if.then.54, label %if.end.57

if.then.54:                                       ; preds = %do.end.52
  %32 = load %struct._GError**, %struct._GError*** %error.addr, align 8
  %call55 = call i32 @gimp_error_quark() #8
  %33 = load %struct._GimpItem*, %struct._GimpItem** %item.addr, align 8
  %34 = bitcast %struct._GimpItem* %33 to %struct._GTypeInstance*
  %g_class56 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %34, i32 0, i32 0
  %35 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class56, align 8
  %36 = bitcast %struct._GTypeClass* %35 to %struct._GimpItemClass*
  %raise_failed = getelementptr inbounds %struct._GimpItemClass, %struct._GimpItemClass* %36, i32 0, i32 36
  %37 = load i8*, i8** %raise_failed, align 8
  call void @g_set_error_literal(%struct._GError** %32, i32 %call55, i32 0, i8* %37)
  store i32 0, i32* %retval
  br label %return

if.end.57:                                        ; preds = %do.end.52
  %38 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %39 = load %struct._GimpItem*, %struct._GimpItem** %item.addr, align 8
  %40 = load %struct._GimpItem*, %struct._GimpItem** %item.addr, align 8
  %call58 = call %struct._GimpItem* @gimp_item_get_parent(%struct._GimpItem* %40)
  %41 = load i32, i32* %index, align 4
  %sub = sub nsw i32 %41, 1
  %42 = load %struct._GimpItem*, %struct._GimpItem** %item.addr, align 8
  %43 = bitcast %struct._GimpItem* %42 to %struct._GTypeInstance*
  %g_class59 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %43, i32 0, i32 0
  %44 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class59, align 8
  %45 = bitcast %struct._GTypeClass* %44 to %struct._GimpItemClass*
  %raise_desc = getelementptr inbounds %struct._GimpItemClass, %struct._GimpItemClass* %45, i32 0, i32 32
  %46 = load i8*, i8** %raise_desc, align 8
  %call60 = call i32 @gimp_image_reorder_item(%struct._GimpImage* %38, %struct._GimpItem* %39, %struct._GimpItem* %call58, i32 %sub, i32 1, i8* %46)
  store i32 %call60, i32* %retval
  br label %return

return:                                           ; preds = %if.end.57, %if.then.54, %if.else.50, %if.else.43, %if.else.36, %if.else.9
  %47 = load i32, i32* %retval
  ret i32 %47
}

declare i32 @gimp_item_get_index(%struct._GimpItem*) #1

declare void @g_set_error_literal(%struct._GError**, i32, i32, i8*) #1

; Function Attrs: nounwind readnone
declare i32 @gimp_error_quark() #2

declare %struct._GimpItem* @gimp_item_get_parent(%struct._GimpItem*) #1

; Function Attrs: nounwind uwtable
define i32 @gimp_image_raise_item_to_top(%struct._GimpImage* %image, %struct._GimpItem* %item) #3 {
entry:
  %retval = alloca i32, align 4
  %image.addr = alloca %struct._GimpImage*, align 8
  %item.addr = alloca %struct._GimpItem*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  %__inst13 = alloca %struct._GTypeInstance*, align 8
  %__t15 = alloca i64, align 8
  %__r18 = alloca i32, align 4
  %tmp33 = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store %struct._GimpItem* %item, %struct._GimpItem** %item.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @__func__.gimp_image_raise_item_to_top, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store i32 0, i32* %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  br label %do.body.11

do.body.11:                                       ; preds = %do.end
  %13 = load %struct._GimpItem*, %struct._GimpItem** %item.addr, align 8
  %14 = bitcast %struct._GimpItem* %13 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %14, %struct._GTypeInstance** %__inst13, align 8
  %call16 = call i64 @gimp_item_get_type() #8
  store i64 %call16, i64* %__t15, align 8
  %15 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %tobool19 = icmp ne %struct._GTypeInstance* %15, null
  br i1 %tobool19, label %if.else.21, label %if.then.20

if.then.20:                                       ; preds = %do.body.11
  store i32 0, i32* %__r18, align 4
  br label %if.end.32

if.else.21:                                       ; preds = %do.body.11
  %16 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %g_class22 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %16, i32 0, i32 0
  %17 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class22, align 8
  %tobool23 = icmp ne %struct._GTypeClass* %17, null
  br i1 %tobool23, label %land.lhs.true.24, label %if.else.29

land.lhs.true.24:                                 ; preds = %if.else.21
  %18 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %g_class25 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %18, i32 0, i32 0
  %19 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class25, align 8
  %g_type26 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %19, i32 0, i32 0
  %20 = load i64, i64* %g_type26, align 8
  %21 = load i64, i64* %__t15, align 8
  %cmp27 = icmp eq i64 %20, %21
  br i1 %cmp27, label %if.then.28, label %if.else.29

if.then.28:                                       ; preds = %land.lhs.true.24
  store i32 1, i32* %__r18, align 4
  br label %if.end.31

if.else.29:                                       ; preds = %land.lhs.true.24, %if.else.21
  %22 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %23 = load i64, i64* %__t15, align 8
  %call30 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %22, i64 %23) #9
  store i32 %call30, i32* %__r18, align 4
  br label %if.end.31

if.end.31:                                        ; preds = %if.else.29, %if.then.28
  br label %if.end.32

if.end.32:                                        ; preds = %if.end.31, %if.then.20
  %24 = load i32, i32* %__r18, align 4
  store i32 %24, i32* %tmp33
  %25 = load i32, i32* %tmp33
  %tobool34 = icmp ne i32 %25, 0
  br i1 %tobool34, label %if.then.35, label %if.else.36

if.then.35:                                       ; preds = %if.end.32
  br label %if.end.37

if.else.36:                                       ; preds = %if.end.32
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([29 x i8], [29 x i8]* @__func__.gimp_image_raise_item_to_top, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.49, i32 0, i32 0))
  store i32 0, i32* %retval
  br label %return

if.end.37:                                        ; preds = %if.then.35
  br label %do.end.38

do.end.38:                                        ; preds = %if.end.37
  %26 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %27 = load %struct._GimpItem*, %struct._GimpItem** %item.addr, align 8
  %28 = load %struct._GimpItem*, %struct._GimpItem** %item.addr, align 8
  %call39 = call %struct._GimpItem* @gimp_item_get_parent(%struct._GimpItem* %28)
  %29 = load %struct._GimpItem*, %struct._GimpItem** %item.addr, align 8
  %30 = bitcast %struct._GimpItem* %29 to %struct._GTypeInstance*
  %g_class40 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %30, i32 0, i32 0
  %31 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class40, align 8
  %32 = bitcast %struct._GTypeClass* %31 to %struct._GimpItemClass*
  %raise_to_top_desc = getelementptr inbounds %struct._GimpItemClass, %struct._GimpItemClass* %32, i32 0, i32 33
  %33 = load i8*, i8** %raise_to_top_desc, align 8
  %call41 = call i32 @gimp_image_reorder_item(%struct._GimpImage* %26, %struct._GimpItem* %27, %struct._GimpItem* %call39, i32 0, i32 1, i8* %33)
  store i32 %call41, i32* %retval
  br label %return

return:                                           ; preds = %do.end.38, %if.else.36, %if.else.9
  %34 = load i32, i32* %retval
  ret i32 %34
}

; Function Attrs: nounwind uwtable
define i32 @gimp_image_lower_item(%struct._GimpImage* %image, %struct._GimpItem* %item, %struct._GError** %error) #3 {
entry:
  %retval = alloca i32, align 4
  %image.addr = alloca %struct._GimpImage*, align 8
  %item.addr = alloca %struct._GimpItem*, align 8
  %error.addr = alloca %struct._GError**, align 8
  %container = alloca %struct._GimpContainer*, align 8
  %index = alloca i32, align 4
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  %__inst13 = alloca %struct._GTypeInstance*, align 8
  %__t15 = alloca i64, align 8
  %__r18 = alloca i32, align 4
  %tmp33 = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store %struct._GimpItem* %item, %struct._GimpItem** %item.addr, align 8
  store %struct._GError** %error, %struct._GError*** %error.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__func__.gimp_image_lower_item, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store i32 0, i32* %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  br label %do.body.11

do.body.11:                                       ; preds = %do.end
  %13 = load %struct._GimpItem*, %struct._GimpItem** %item.addr, align 8
  %14 = bitcast %struct._GimpItem* %13 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %14, %struct._GTypeInstance** %__inst13, align 8
  %call16 = call i64 @gimp_item_get_type() #8
  store i64 %call16, i64* %__t15, align 8
  %15 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %tobool19 = icmp ne %struct._GTypeInstance* %15, null
  br i1 %tobool19, label %if.else.21, label %if.then.20

if.then.20:                                       ; preds = %do.body.11
  store i32 0, i32* %__r18, align 4
  br label %if.end.32

if.else.21:                                       ; preds = %do.body.11
  %16 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %g_class22 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %16, i32 0, i32 0
  %17 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class22, align 8
  %tobool23 = icmp ne %struct._GTypeClass* %17, null
  br i1 %tobool23, label %land.lhs.true.24, label %if.else.29

land.lhs.true.24:                                 ; preds = %if.else.21
  %18 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %g_class25 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %18, i32 0, i32 0
  %19 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class25, align 8
  %g_type26 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %19, i32 0, i32 0
  %20 = load i64, i64* %g_type26, align 8
  %21 = load i64, i64* %__t15, align 8
  %cmp27 = icmp eq i64 %20, %21
  br i1 %cmp27, label %if.then.28, label %if.else.29

if.then.28:                                       ; preds = %land.lhs.true.24
  store i32 1, i32* %__r18, align 4
  br label %if.end.31

if.else.29:                                       ; preds = %land.lhs.true.24, %if.else.21
  %22 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %23 = load i64, i64* %__t15, align 8
  %call30 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %22, i64 %23) #9
  store i32 %call30, i32* %__r18, align 4
  br label %if.end.31

if.end.31:                                        ; preds = %if.else.29, %if.then.28
  br label %if.end.32

if.end.32:                                        ; preds = %if.end.31, %if.then.20
  %24 = load i32, i32* %__r18, align 4
  store i32 %24, i32* %tmp33
  %25 = load i32, i32* %tmp33
  %tobool34 = icmp ne i32 %25, 0
  br i1 %tobool34, label %if.then.35, label %if.else.36

if.then.35:                                       ; preds = %if.end.32
  br label %if.end.37

if.else.36:                                       ; preds = %if.end.32
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__func__.gimp_image_lower_item, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.49, i32 0, i32 0))
  store i32 0, i32* %retval
  br label %return

if.end.37:                                        ; preds = %if.then.35
  br label %do.end.38

do.end.38:                                        ; preds = %if.end.37
  br label %do.body.39

do.body.39:                                       ; preds = %do.end.38
  %26 = load %struct._GError**, %struct._GError*** %error.addr, align 8
  %cmp40 = icmp eq %struct._GError** %26, null
  br i1 %cmp40, label %if.then.42, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.body.39
  %27 = load %struct._GError**, %struct._GError*** %error.addr, align 8
  %28 = load %struct._GError*, %struct._GError** %27, align 8
  %cmp41 = icmp eq %struct._GError* %28, null
  br i1 %cmp41, label %if.then.42, label %if.else.43

if.then.42:                                       ; preds = %lor.lhs.false, %do.body.39
  br label %if.end.44

if.else.43:                                       ; preds = %lor.lhs.false
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__func__.gimp_image_lower_item, i32 0, i32 0), i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.52, i32 0, i32 0))
  store i32 0, i32* %retval
  br label %return

if.end.44:                                        ; preds = %if.then.42
  br label %do.end.45

do.end.45:                                        ; preds = %if.end.44
  %29 = load %struct._GimpItem*, %struct._GimpItem** %item.addr, align 8
  %call46 = call %struct._GimpContainer* @gimp_item_get_container(%struct._GimpItem* %29)
  store %struct._GimpContainer* %call46, %struct._GimpContainer** %container, align 8
  br label %do.body.47

do.body.47:                                       ; preds = %do.end.45
  %30 = load %struct._GimpContainer*, %struct._GimpContainer** %container, align 8
  %cmp48 = icmp ne %struct._GimpContainer* %30, null
  br i1 %cmp48, label %if.then.49, label %if.else.50

if.then.49:                                       ; preds = %do.body.47
  br label %if.end.51

if.else.50:                                       ; preds = %do.body.47
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__func__.gimp_image_lower_item, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.54, i32 0, i32 0))
  store i32 0, i32* %retval
  br label %return

if.end.51:                                        ; preds = %if.then.49
  br label %do.end.52

do.end.52:                                        ; preds = %if.end.51
  %31 = load %struct._GimpItem*, %struct._GimpItem** %item.addr, align 8
  %call53 = call i32 @gimp_item_get_index(%struct._GimpItem* %31)
  store i32 %call53, i32* %index, align 4
  %32 = load i32, i32* %index, align 4
  %33 = load %struct._GimpContainer*, %struct._GimpContainer** %container, align 8
  %call54 = call i32 @gimp_container_get_n_children(%struct._GimpContainer* %33)
  %sub = sub nsw i32 %call54, 1
  %cmp55 = icmp eq i32 %32, %sub
  br i1 %cmp55, label %if.then.56, label %if.end.59

if.then.56:                                       ; preds = %do.end.52
  %34 = load %struct._GError**, %struct._GError*** %error.addr, align 8
  %call57 = call i32 @gimp_error_quark() #8
  %35 = load %struct._GimpItem*, %struct._GimpItem** %item.addr, align 8
  %36 = bitcast %struct._GimpItem* %35 to %struct._GTypeInstance*
  %g_class58 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %36, i32 0, i32 0
  %37 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class58, align 8
  %38 = bitcast %struct._GTypeClass* %37 to %struct._GimpItemClass*
  %lower_failed = getelementptr inbounds %struct._GimpItemClass, %struct._GimpItemClass* %38, i32 0, i32 37
  %39 = load i8*, i8** %lower_failed, align 8
  call void @g_set_error_literal(%struct._GError** %34, i32 %call57, i32 0, i8* %39)
  store i32 0, i32* %retval
  br label %return

if.end.59:                                        ; preds = %do.end.52
  %40 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %41 = load %struct._GimpItem*, %struct._GimpItem** %item.addr, align 8
  %42 = load %struct._GimpItem*, %struct._GimpItem** %item.addr, align 8
  %call60 = call %struct._GimpItem* @gimp_item_get_parent(%struct._GimpItem* %42)
  %43 = load i32, i32* %index, align 4
  %add = add nsw i32 %43, 1
  %44 = load %struct._GimpItem*, %struct._GimpItem** %item.addr, align 8
  %45 = bitcast %struct._GimpItem* %44 to %struct._GTypeInstance*
  %g_class61 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %45, i32 0, i32 0
  %46 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class61, align 8
  %47 = bitcast %struct._GTypeClass* %46 to %struct._GimpItemClass*
  %lower_desc = getelementptr inbounds %struct._GimpItemClass, %struct._GimpItemClass* %47, i32 0, i32 34
  %48 = load i8*, i8** %lower_desc, align 8
  %call62 = call i32 @gimp_image_reorder_item(%struct._GimpImage* %40, %struct._GimpItem* %41, %struct._GimpItem* %call60, i32 %add, i32 1, i8* %48)
  store i32 %call62, i32* %retval
  br label %return

return:                                           ; preds = %if.end.59, %if.then.56, %if.else.50, %if.else.43, %if.else.36, %if.else.9
  %49 = load i32, i32* %retval
  ret i32 %49
}

declare %struct._GimpContainer* @gimp_item_get_container(%struct._GimpItem*) #1

declare i32 @gimp_container_get_n_children(%struct._GimpContainer*) #1

; Function Attrs: nounwind uwtable
define i32 @gimp_image_lower_item_to_bottom(%struct._GimpImage* %image, %struct._GimpItem* %item) #3 {
entry:
  %retval = alloca i32, align 4
  %image.addr = alloca %struct._GimpImage*, align 8
  %item.addr = alloca %struct._GimpItem*, align 8
  %container = alloca %struct._GimpContainer*, align 8
  %length = alloca i32, align 4
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  %__inst13 = alloca %struct._GTypeInstance*, align 8
  %__t15 = alloca i64, align 8
  %__r18 = alloca i32, align 4
  %tmp33 = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store %struct._GimpItem* %item, %struct._GimpItem** %item.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([32 x i8], [32 x i8]* @__func__.gimp_image_lower_item_to_bottom, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store i32 0, i32* %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  br label %do.body.11

do.body.11:                                       ; preds = %do.end
  %13 = load %struct._GimpItem*, %struct._GimpItem** %item.addr, align 8
  %14 = bitcast %struct._GimpItem* %13 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %14, %struct._GTypeInstance** %__inst13, align 8
  %call16 = call i64 @gimp_item_get_type() #8
  store i64 %call16, i64* %__t15, align 8
  %15 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %tobool19 = icmp ne %struct._GTypeInstance* %15, null
  br i1 %tobool19, label %if.else.21, label %if.then.20

if.then.20:                                       ; preds = %do.body.11
  store i32 0, i32* %__r18, align 4
  br label %if.end.32

if.else.21:                                       ; preds = %do.body.11
  %16 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %g_class22 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %16, i32 0, i32 0
  %17 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class22, align 8
  %tobool23 = icmp ne %struct._GTypeClass* %17, null
  br i1 %tobool23, label %land.lhs.true.24, label %if.else.29

land.lhs.true.24:                                 ; preds = %if.else.21
  %18 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %g_class25 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %18, i32 0, i32 0
  %19 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class25, align 8
  %g_type26 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %19, i32 0, i32 0
  %20 = load i64, i64* %g_type26, align 8
  %21 = load i64, i64* %__t15, align 8
  %cmp27 = icmp eq i64 %20, %21
  br i1 %cmp27, label %if.then.28, label %if.else.29

if.then.28:                                       ; preds = %land.lhs.true.24
  store i32 1, i32* %__r18, align 4
  br label %if.end.31

if.else.29:                                       ; preds = %land.lhs.true.24, %if.else.21
  %22 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %23 = load i64, i64* %__t15, align 8
  %call30 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %22, i64 %23) #9
  store i32 %call30, i32* %__r18, align 4
  br label %if.end.31

if.end.31:                                        ; preds = %if.else.29, %if.then.28
  br label %if.end.32

if.end.32:                                        ; preds = %if.end.31, %if.then.20
  %24 = load i32, i32* %__r18, align 4
  store i32 %24, i32* %tmp33
  %25 = load i32, i32* %tmp33
  %tobool34 = icmp ne i32 %25, 0
  br i1 %tobool34, label %if.then.35, label %if.else.36

if.then.35:                                       ; preds = %if.end.32
  br label %if.end.37

if.else.36:                                       ; preds = %if.end.32
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([32 x i8], [32 x i8]* @__func__.gimp_image_lower_item_to_bottom, i32 0, i32 0), i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.49, i32 0, i32 0))
  store i32 0, i32* %retval
  br label %return

if.end.37:                                        ; preds = %if.then.35
  br label %do.end.38

do.end.38:                                        ; preds = %if.end.37
  %26 = load %struct._GimpItem*, %struct._GimpItem** %item.addr, align 8
  %call39 = call %struct._GimpContainer* @gimp_item_get_container(%struct._GimpItem* %26)
  store %struct._GimpContainer* %call39, %struct._GimpContainer** %container, align 8
  br label %do.body.40

do.body.40:                                       ; preds = %do.end.38
  %27 = load %struct._GimpContainer*, %struct._GimpContainer** %container, align 8
  %cmp41 = icmp ne %struct._GimpContainer* %27, null
  br i1 %cmp41, label %if.then.42, label %if.else.43

if.then.42:                                       ; preds = %do.body.40
  br label %if.end.44

if.else.43:                                       ; preds = %do.body.40
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([32 x i8], [32 x i8]* @__func__.gimp_image_lower_item_to_bottom, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.54, i32 0, i32 0))
  store i32 0, i32* %retval
  br label %return

if.end.44:                                        ; preds = %if.then.42
  br label %do.end.45

do.end.45:                                        ; preds = %if.end.44
  %28 = load %struct._GimpContainer*, %struct._GimpContainer** %container, align 8
  %call46 = call i32 @gimp_container_get_n_children(%struct._GimpContainer* %28)
  store i32 %call46, i32* %length, align 4
  %29 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %30 = load %struct._GimpItem*, %struct._GimpItem** %item.addr, align 8
  %31 = load %struct._GimpItem*, %struct._GimpItem** %item.addr, align 8
  %call47 = call %struct._GimpItem* @gimp_item_get_parent(%struct._GimpItem* %31)
  %32 = load i32, i32* %length, align 4
  %sub = sub nsw i32 %32, 1
  %33 = load %struct._GimpItem*, %struct._GimpItem** %item.addr, align 8
  %34 = bitcast %struct._GimpItem* %33 to %struct._GTypeInstance*
  %g_class48 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %34, i32 0, i32 0
  %35 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class48, align 8
  %36 = bitcast %struct._GTypeClass* %35 to %struct._GimpItemClass*
  %lower_to_bottom_desc = getelementptr inbounds %struct._GimpItemClass, %struct._GimpItemClass* %36, i32 0, i32 35
  %37 = load i8*, i8** %lower_to_bottom_desc, align 8
  %call49 = call i32 @gimp_image_reorder_item(%struct._GimpImage* %29, %struct._GimpItem* %30, %struct._GimpItem* %call47, i32 %sub, i32 1, i8* %37)
  store i32 %call49, i32* %retval
  br label %return

return:                                           ; preds = %do.end.45, %if.else.43, %if.else.36, %if.else.9
  %38 = load i32, i32* %retval
  ret i32 %38
}

; Function Attrs: nounwind uwtable
define i32 @gimp_image_add_layer(%struct._GimpImage* %image, %struct._GimpLayer* %layer, %struct._GimpLayer* %parent, i32 %position, i32 %push_undo) #3 {
entry:
  %retval = alloca i32, align 4
  %image.addr = alloca %struct._GimpImage*, align 8
  %layer.addr = alloca %struct._GimpLayer*, align 8
  %parent.addr = alloca %struct._GimpLayer*, align 8
  %position.addr = alloca i32, align 4
  %push_undo.addr = alloca i32, align 4
  %private = alloca %struct._GimpImagePrivate*, align 8
  %old_has_alpha = alloca i32, align 4
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store %struct._GimpLayer* %layer, %struct._GimpLayer** %layer.addr, align 8
  store %struct._GimpLayer* %parent, %struct._GimpLayer** %parent.addr, align 8
  store i32 %position, i32* %position.addr, align 4
  store i32 %push_undo, i32* %push_undo.addr, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @__func__.gimp_image_add_layer, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store i32 0, i32* %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %15, %struct._GimpImagePrivate** %private, align 8
  %16 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %layers = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %16, i32 0, i32 27
  %17 = load %struct._GimpItemTree*, %struct._GimpItemTree** %layers, align 8
  %18 = load %struct._GimpLayer*, %struct._GimpLayer** %layer.addr, align 8
  %19 = bitcast %struct._GimpLayer* %18 to %struct._GimpItem*
  %20 = bitcast %struct._GimpLayer** %parent.addr to %struct._GimpItem**
  %call13 = call i32 @gimp_item_tree_get_insert_pos(%struct._GimpItemTree* %17, %struct._GimpItem* %19, %struct._GimpItem** %20, i32* %position.addr)
  %tobool14 = icmp ne i32 %call13, 0
  br i1 %tobool14, label %if.end.16, label %if.then.15

if.then.15:                                       ; preds = %do.end
  store i32 0, i32* %retval
  br label %return

if.end.16:                                        ; preds = %do.end
  %21 = load %struct._GimpLayer*, %struct._GimpLayer** %parent.addr, align 8
  %cmp17 = icmp eq %struct._GimpLayer* %21, null
  br i1 %cmp17, label %land.lhs.true.18, label %if.end.24

land.lhs.true.18:                                 ; preds = %if.end.16
  %22 = load i32, i32* %position.addr, align 4
  %cmp19 = icmp eq i32 %22, 0
  br i1 %cmp19, label %land.lhs.true.20, label %if.end.24

land.lhs.true.20:                                 ; preds = %land.lhs.true.18
  %23 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call21 = call %struct._GimpLayer* @gimp_image_get_floating_selection(%struct._GimpImage* %23)
  %tobool22 = icmp ne %struct._GimpLayer* %call21, null
  br i1 %tobool22, label %if.then.23, label %if.end.24

if.then.23:                                       ; preds = %land.lhs.true.20
  store i32 1, i32* %position.addr, align 4
  br label %if.end.24

if.end.24:                                        ; preds = %if.then.23, %land.lhs.true.20, %land.lhs.true.18, %if.end.16
  %24 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call25 = call i32 @gimp_image_has_alpha(%struct._GimpImage* %24)
  store i32 %call25, i32* %old_has_alpha, align 4
  %25 = load i32, i32* %push_undo.addr, align 4
  %tobool26 = icmp ne i32 %25, 0
  br i1 %tobool26, label %if.then.27, label %if.end.31

if.then.27:                                       ; preds = %if.end.24
  %26 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call28 = call i8* @g_dpgettext(i8* null, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.55, i32 0, i32 0), i64 10)
  %27 = load %struct._GimpLayer*, %struct._GimpLayer** %layer.addr, align 8
  %28 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call29 = call %struct._GimpLayer* @gimp_image_get_active_layer(%struct._GimpImage* %28)
  %call30 = call %struct._GimpUndo* @gimp_image_undo_push_layer_add(%struct._GimpImage* %26, i8* %call28, %struct._GimpLayer* %27, %struct._GimpLayer* %call29)
  br label %if.end.31

if.end.31:                                        ; preds = %if.then.27, %if.end.24
  %29 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %layers32 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %29, i32 0, i32 27
  %30 = load %struct._GimpItemTree*, %struct._GimpItemTree** %layers32, align 8
  %31 = load %struct._GimpLayer*, %struct._GimpLayer** %layer.addr, align 8
  %32 = bitcast %struct._GimpLayer* %31 to %struct._GTypeInstance*
  %call33 = call i64 @gimp_item_get_type() #8
  %call34 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %32, i64 %call33)
  %33 = bitcast %struct._GTypeInstance* %call34 to %struct._GimpItem*
  %34 = load %struct._GimpLayer*, %struct._GimpLayer** %parent.addr, align 8
  %35 = bitcast %struct._GimpLayer* %34 to %struct._GTypeInstance*
  %call35 = call i64 @gimp_item_get_type() #8
  %call36 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %35, i64 %call35)
  %36 = bitcast %struct._GTypeInstance* %call36 to %struct._GimpItem*
  %37 = load i32, i32* %position.addr, align 4
  call void @gimp_item_tree_add_item(%struct._GimpItemTree* %30, %struct._GimpItem* %33, %struct._GimpItem* %36, i32 %37)
  %38 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %39 = load %struct._GimpLayer*, %struct._GimpLayer** %layer.addr, align 8
  %call37 = call %struct._GimpLayer* @gimp_image_set_active_layer(%struct._GimpImage* %38, %struct._GimpLayer* %39)
  %40 = load %struct._GimpLayer*, %struct._GimpLayer** %layer.addr, align 8
  %call38 = call i32 @gimp_layer_is_floating_sel(%struct._GimpLayer* %40)
  %tobool39 = icmp ne i32 %call38, 0
  br i1 %tobool39, label %if.then.40, label %if.end.42

if.then.40:                                       ; preds = %if.end.31
  %41 = load %struct._GimpLayer*, %struct._GimpLayer** %layer.addr, align 8
  %call41 = call %struct._GimpDrawable* @gimp_layer_get_floating_sel_drawable(%struct._GimpLayer* %41)
  %42 = load %struct._GimpLayer*, %struct._GimpLayer** %layer.addr, align 8
  call void @gimp_drawable_attach_floating_sel(%struct._GimpDrawable* %call41, %struct._GimpLayer* %42)
  br label %if.end.42

if.end.42:                                        ; preds = %if.then.40, %if.end.31
  %43 = load i32, i32* %old_has_alpha, align 4
  %44 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call43 = call i32 @gimp_image_has_alpha(%struct._GimpImage* %44)
  %cmp44 = icmp ne i32 %43, %call43
  br i1 %cmp44, label %if.then.45, label %if.end.46

if.then.45:                                       ; preds = %if.end.42
  %45 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %flush_accum = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %45, i32 0, i32 47
  %alpha_changed = getelementptr inbounds %struct._GimpImageFlushAccumulator, %struct._GimpImageFlushAccumulator* %flush_accum, i32 0, i32 0
  store i32 1, i32* %alpha_changed, align 4
  br label %if.end.46

if.end.46:                                        ; preds = %if.then.45, %if.end.42
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %if.end.46, %if.then.15, %if.else.9
  %46 = load i32, i32* %retval
  ret i32 %46
}

declare i32 @gimp_item_tree_get_insert_pos(%struct._GimpItemTree*, %struct._GimpItem*, %struct._GimpItem**, i32*) #1

declare %struct._GimpUndo* @gimp_image_undo_push_layer_add(%struct._GimpImage*, i8*, %struct._GimpLayer*, %struct._GimpLayer*) #1

declare void @gimp_item_tree_add_item(%struct._GimpItemTree*, %struct._GimpItem*, %struct._GimpItem*, i32) #1

declare i32 @gimp_layer_is_floating_sel(%struct._GimpLayer*) #1

declare void @gimp_drawable_attach_floating_sel(%struct._GimpDrawable*, %struct._GimpLayer*) #1

declare %struct._GimpDrawable* @gimp_layer_get_floating_sel_drawable(%struct._GimpLayer*) #1

; Function Attrs: nounwind uwtable
define void @gimp_image_remove_layer(%struct._GimpImage* %image, %struct._GimpLayer* %layer, i32 %push_undo, %struct._GimpLayer* %new_active) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %layer.addr = alloca %struct._GimpLayer*, align 8
  %push_undo.addr = alloca i32, align 4
  %new_active.addr = alloca %struct._GimpLayer*, align 8
  %private = alloca %struct._GimpImagePrivate*, align 8
  %active_layer = alloca %struct._GimpLayer*, align 8
  %old_has_alpha = alloca i32, align 4
  %undo_group = alloca i32, align 4
  %undo_desc = alloca i8*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  %__inst13 = alloca %struct._GTypeInstance*, align 8
  %__t15 = alloca i64, align 8
  %__r18 = alloca i32, align 4
  %tmp33 = alloca i32, align 4
  %stack = alloca %struct._GimpContainer*, align 8
  %children = alloca %struct._GList*, align 8
  %list = alloca %struct._GList*, align 8
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store %struct._GimpLayer* %layer, %struct._GimpLayer** %layer.addr, align 8
  store i32 %push_undo, i32* %push_undo.addr, align 4
  store %struct._GimpLayer* %new_active, %struct._GimpLayer** %new_active.addr, align 8
  store i32 0, i32* %undo_group, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__func__.gimp_image_remove_layer, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %if.end.150

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  br label %do.body.11

do.body.11:                                       ; preds = %do.end
  %13 = load %struct._GimpLayer*, %struct._GimpLayer** %layer.addr, align 8
  %14 = bitcast %struct._GimpLayer* %13 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %14, %struct._GTypeInstance** %__inst13, align 8
  %call16 = call i64 @gimp_layer_get_type() #8
  store i64 %call16, i64* %__t15, align 8
  %15 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %tobool19 = icmp ne %struct._GTypeInstance* %15, null
  br i1 %tobool19, label %if.else.21, label %if.then.20

if.then.20:                                       ; preds = %do.body.11
  store i32 0, i32* %__r18, align 4
  br label %if.end.32

if.else.21:                                       ; preds = %do.body.11
  %16 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %g_class22 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %16, i32 0, i32 0
  %17 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class22, align 8
  %tobool23 = icmp ne %struct._GTypeClass* %17, null
  br i1 %tobool23, label %land.lhs.true.24, label %if.else.29

land.lhs.true.24:                                 ; preds = %if.else.21
  %18 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %g_class25 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %18, i32 0, i32 0
  %19 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class25, align 8
  %g_type26 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %19, i32 0, i32 0
  %20 = load i64, i64* %g_type26, align 8
  %21 = load i64, i64* %__t15, align 8
  %cmp27 = icmp eq i64 %20, %21
  br i1 %cmp27, label %if.then.28, label %if.else.29

if.then.28:                                       ; preds = %land.lhs.true.24
  store i32 1, i32* %__r18, align 4
  br label %if.end.31

if.else.29:                                       ; preds = %land.lhs.true.24, %if.else.21
  %22 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %23 = load i64, i64* %__t15, align 8
  %call30 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %22, i64 %23) #9
  store i32 %call30, i32* %__r18, align 4
  br label %if.end.31

if.end.31:                                        ; preds = %if.else.29, %if.then.28
  br label %if.end.32

if.end.32:                                        ; preds = %if.end.31, %if.then.20
  %24 = load i32, i32* %__r18, align 4
  store i32 %24, i32* %tmp33
  %25 = load i32, i32* %tmp33
  %tobool34 = icmp ne i32 %25, 0
  br i1 %tobool34, label %if.then.35, label %if.else.36

if.then.35:                                       ; preds = %if.end.32
  br label %if.end.37

if.else.36:                                       ; preds = %if.end.32
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__func__.gimp_image_remove_layer, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.56, i32 0, i32 0))
  br label %if.end.150

if.end.37:                                        ; preds = %if.then.35
  br label %do.end.38

do.end.38:                                        ; preds = %if.end.37
  br label %do.body.39

do.body.39:                                       ; preds = %do.end.38
  %26 = load %struct._GimpLayer*, %struct._GimpLayer** %layer.addr, align 8
  %27 = bitcast %struct._GimpLayer* %26 to %struct._GTypeInstance*
  %call40 = call i64 @gimp_item_get_type() #8
  %call41 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %27, i64 %call40)
  %28 = bitcast %struct._GTypeInstance* %call41 to %struct._GimpItem*
  %call42 = call i32 @gimp_item_is_attached(%struct._GimpItem* %28)
  %tobool43 = icmp ne i32 %call42, 0
  br i1 %tobool43, label %if.then.44, label %if.else.45

if.then.44:                                       ; preds = %do.body.39
  br label %if.end.46

if.else.45:                                       ; preds = %do.body.39
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__func__.gimp_image_remove_layer, i32 0, i32 0), i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.57, i32 0, i32 0))
  br label %if.end.150

if.end.46:                                        ; preds = %if.then.44
  br label %do.end.47

do.end.47:                                        ; preds = %if.end.46
  br label %do.body.48

do.body.48:                                       ; preds = %do.end.47
  %29 = load %struct._GimpLayer*, %struct._GimpLayer** %layer.addr, align 8
  %30 = bitcast %struct._GimpLayer* %29 to %struct._GTypeInstance*
  %call49 = call i64 @gimp_item_get_type() #8
  %call50 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %30, i64 %call49)
  %31 = bitcast %struct._GTypeInstance* %call50 to %struct._GimpItem*
  %call51 = call %struct._GimpImage* @gimp_item_get_image(%struct._GimpItem* %31)
  %32 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %cmp52 = icmp eq %struct._GimpImage* %call51, %32
  br i1 %cmp52, label %if.then.53, label %if.else.54

if.then.53:                                       ; preds = %do.body.48
  br label %if.end.55

if.else.54:                                       ; preds = %do.body.48
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__func__.gimp_image_remove_layer, i32 0, i32 0), i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.58, i32 0, i32 0))
  br label %if.end.150

if.end.55:                                        ; preds = %if.then.53
  br label %do.end.56

do.end.56:                                        ; preds = %if.end.55
  %33 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %34 = bitcast %struct._GimpImage* %33 to %struct._GTypeInstance*
  %call57 = call i64 @gimp_image_get_type() #8
  %call58 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %34, i64 %call57)
  %35 = bitcast i8* %call58 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %35, %struct._GimpImagePrivate** %private, align 8
  %36 = load %struct._GimpLayer*, %struct._GimpLayer** %layer.addr, align 8
  %37 = bitcast %struct._GimpLayer* %36 to %struct._GTypeInstance*
  %call59 = call i64 @gimp_drawable_get_type() #8
  %call60 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %37, i64 %call59)
  %38 = bitcast %struct._GTypeInstance* %call60 to %struct._GimpDrawable*
  %call61 = call %struct._GimpLayer* @gimp_drawable_get_floating_sel(%struct._GimpDrawable* %38)
  %tobool62 = icmp ne %struct._GimpLayer* %call61, null
  br i1 %tobool62, label %if.then.63, label %if.end.72

if.then.63:                                       ; preds = %do.end.56
  %39 = load i32, i32* %push_undo.addr, align 4
  %tobool64 = icmp ne i32 %39, 0
  br i1 %tobool64, label %if.end.66, label %if.then.65

if.then.65:                                       ; preds = %if.then.63
  call void (i8*, ...) @g_warning(i8* getelementptr inbounds ([128 x i8], [128 x i8]* @.str.59, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__func__.gimp_image_remove_layer, i32 0, i32 0))
  br label %if.end.150

if.end.66:                                        ; preds = %if.then.63
  %40 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call67 = call i8* @g_dpgettext(i8* null, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.60, i32 0, i32 0), i64 10)
  %call68 = call i32 @gimp_image_undo_group_start(%struct._GimpImage* %40, i32 7, i8* %call67)
  store i32 1, i32* %undo_group, align 4
  %41 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %42 = load %struct._GimpLayer*, %struct._GimpLayer** %layer.addr, align 8
  %43 = bitcast %struct._GimpLayer* %42 to %struct._GTypeInstance*
  %call69 = call i64 @gimp_drawable_get_type() #8
  %call70 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %43, i64 %call69)
  %44 = bitcast %struct._GTypeInstance* %call70 to %struct._GimpDrawable*
  %call71 = call %struct._GimpLayer* @gimp_drawable_get_floating_sel(%struct._GimpDrawable* %44)
  call void @gimp_image_remove_layer(%struct._GimpImage* %41, %struct._GimpLayer* %call71, i32 1, %struct._GimpLayer* null)
  br label %if.end.72

if.end.72:                                        ; preds = %if.end.66, %do.end.56
  %45 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call73 = call %struct._GimpLayer* @gimp_image_get_active_layer(%struct._GimpImage* %45)
  store %struct._GimpLayer* %call73, %struct._GimpLayer** %active_layer, align 8
  %46 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call74 = call i32 @gimp_image_has_alpha(%struct._GimpImage* %46)
  store i32 %call74, i32* %old_has_alpha, align 4
  %47 = load %struct._GimpLayer*, %struct._GimpLayer** %layer.addr, align 8
  %call75 = call i32 @gimp_layer_is_floating_sel(%struct._GimpLayer* %47)
  %tobool76 = icmp ne i32 %call75, 0
  br i1 %tobool76, label %if.then.77, label %if.else.80

if.then.77:                                       ; preds = %if.end.72
  %call78 = call i8* @g_dpgettext(i8* null, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.61, i32 0, i32 0), i64 10)
  store i8* %call78, i8** %undo_desc, align 8
  %48 = load %struct._GimpLayer*, %struct._GimpLayer** %layer.addr, align 8
  %call79 = call %struct._GimpDrawable* @gimp_layer_get_floating_sel_drawable(%struct._GimpLayer* %48)
  call void @gimp_drawable_detach_floating_sel(%struct._GimpDrawable* %call79)
  br label %if.end.82

if.else.80:                                       ; preds = %if.end.72
  %call81 = call i8* @g_dpgettext(i8* null, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.60, i32 0, i32 0), i64 10)
  store i8* %call81, i8** %undo_desc, align 8
  br label %if.end.82

if.end.82:                                        ; preds = %if.else.80, %if.then.77
  %49 = load i32, i32* %push_undo.addr, align 4
  %tobool83 = icmp ne i32 %49, 0
  br i1 %tobool83, label %if.then.84, label %if.end.90

if.then.84:                                       ; preds = %if.end.82
  %50 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %51 = load i8*, i8** %undo_desc, align 8
  %52 = load %struct._GimpLayer*, %struct._GimpLayer** %layer.addr, align 8
  %53 = load %struct._GimpLayer*, %struct._GimpLayer** %layer.addr, align 8
  %call85 = call %struct._GimpLayer* @gimp_layer_get_parent(%struct._GimpLayer* %53)
  %54 = load %struct._GimpLayer*, %struct._GimpLayer** %layer.addr, align 8
  %55 = bitcast %struct._GimpLayer* %54 to %struct._GTypeInstance*
  %call86 = call i64 @gimp_item_get_type() #8
  %call87 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %55, i64 %call86)
  %56 = bitcast %struct._GTypeInstance* %call87 to %struct._GimpItem*
  %call88 = call i32 @gimp_item_get_index(%struct._GimpItem* %56)
  %57 = load %struct._GimpLayer*, %struct._GimpLayer** %active_layer, align 8
  %call89 = call %struct._GimpUndo* @gimp_image_undo_push_layer_remove(%struct._GimpImage* %50, i8* %51, %struct._GimpLayer* %52, %struct._GimpLayer* %call85, i32 %call88, %struct._GimpLayer* %57)
  br label %if.end.90

if.end.90:                                        ; preds = %if.then.84, %if.end.82
  %58 = load %struct._GimpLayer*, %struct._GimpLayer** %layer.addr, align 8
  %59 = bitcast %struct._GimpLayer* %58 to i8*
  %call91 = call i8* @g_object_ref(i8* %59)
  %60 = load %struct._GimpLayer*, %struct._GimpLayer** %layer.addr, align 8
  %61 = load %struct._GimpLayer*, %struct._GimpLayer** %active_layer, align 8
  %cmp92 = icmp eq %struct._GimpLayer* %60, %61
  br i1 %cmp92, label %if.then.93, label %if.end.96

if.then.93:                                       ; preds = %if.end.90
  %62 = load %struct._GimpLayer*, %struct._GimpLayer** %layer.addr, align 8
  %63 = bitcast %struct._GimpLayer* %62 to %struct._GTypeInstance*
  %call94 = call i64 @gimp_drawable_get_type() #8
  %call95 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %63, i64 %call94)
  %64 = bitcast %struct._GTypeInstance* %call95 to %struct._GimpDrawable*
  call void @gimp_drawable_invalidate_boundary(%struct._GimpDrawable* %64)
  br label %if.end.96

if.end.96:                                        ; preds = %if.then.93, %if.end.90
  %65 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %layer_stack = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %65, i32 0, i32 30
  %66 = load %struct._GSList*, %struct._GSList** %layer_stack, align 8
  %67 = load %struct._GimpLayer*, %struct._GimpLayer** %layer.addr, align 8
  %68 = bitcast %struct._GimpLayer* %67 to i8*
  %call97 = call %struct._GSList* @g_slist_remove(%struct._GSList* %66, i8* %68)
  %69 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %layer_stack98 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %69, i32 0, i32 30
  store %struct._GSList* %call97, %struct._GSList** %layer_stack98, align 8
  %70 = load %struct._GimpLayer*, %struct._GimpLayer** %layer.addr, align 8
  %71 = bitcast %struct._GimpLayer* %70 to %struct._GTypeInstance*
  %call99 = call i64 @gimp_viewable_get_type() #8
  %call100 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %71, i64 %call99)
  %72 = bitcast %struct._GTypeInstance* %call100 to %struct._GimpViewable*
  %call101 = call %struct._GimpContainer* @gimp_viewable_get_children(%struct._GimpViewable* %72)
  %tobool102 = icmp ne %struct._GimpContainer* %call101, null
  br i1 %tobool102, label %if.then.103, label %if.end.118

if.then.103:                                      ; preds = %if.end.96
  %73 = load %struct._GimpLayer*, %struct._GimpLayer** %layer.addr, align 8
  %74 = bitcast %struct._GimpLayer* %73 to %struct._GTypeInstance*
  %call105 = call i64 @gimp_viewable_get_type() #8
  %call106 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %74, i64 %call105)
  %75 = bitcast %struct._GTypeInstance* %call106 to %struct._GimpViewable*
  %call107 = call %struct._GimpContainer* @gimp_viewable_get_children(%struct._GimpViewable* %75)
  store %struct._GimpContainer* %call107, %struct._GimpContainer** %stack, align 8
  %76 = load %struct._GimpContainer*, %struct._GimpContainer** %stack, align 8
  %77 = bitcast %struct._GimpContainer* %76 to %struct._GTypeInstance*
  %call110 = call i64 @gimp_item_stack_get_type() #8
  %call111 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %77, i64 %call110)
  %78 = bitcast %struct._GTypeInstance* %call111 to %struct._GimpItemStack*
  %call112 = call %struct._GList* @gimp_item_stack_get_item_list(%struct._GimpItemStack* %78)
  store %struct._GList* %call112, %struct._GList** %children, align 8
  %79 = load %struct._GList*, %struct._GList** %children, align 8
  store %struct._GList* %79, %struct._GList** %list, align 8
  br label %for.cond

for.cond:                                         ; preds = %cond.end, %if.then.103
  %80 = load %struct._GList*, %struct._GList** %list, align 8
  %tobool113 = icmp ne %struct._GList* %80, null
  br i1 %tobool113, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %81 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %layer_stack114 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %81, i32 0, i32 30
  %82 = load %struct._GSList*, %struct._GSList** %layer_stack114, align 8
  %83 = load %struct._GList*, %struct._GList** %list, align 8
  %data = getelementptr inbounds %struct._GList, %struct._GList* %83, i32 0, i32 0
  %84 = load i8*, i8** %data, align 8
  %call115 = call %struct._GSList* @g_slist_remove(%struct._GSList* %82, i8* %84)
  %85 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %layer_stack116 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %85, i32 0, i32 30
  store %struct._GSList* %call115, %struct._GSList** %layer_stack116, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %86 = load %struct._GList*, %struct._GList** %list, align 8
  %tobool117 = icmp ne %struct._GList* %86, null
  br i1 %tobool117, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.inc
  %87 = load %struct._GList*, %struct._GList** %list, align 8
  %next = getelementptr inbounds %struct._GList, %struct._GList* %87, i32 0, i32 1
  %88 = load %struct._GList*, %struct._GList** %next, align 8
  br label %cond.end

cond.false:                                       ; preds = %for.inc
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct._GList* [ %88, %cond.true ], [ null, %cond.false ]
  store %struct._GList* %cond, %struct._GList** %list, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %89 = load %struct._GList*, %struct._GList** %children, align 8
  call void @g_list_free(%struct._GList* %89)
  br label %if.end.118

if.end.118:                                       ; preds = %for.end, %if.end.96
  %90 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %layers = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %90, i32 0, i32 27
  %91 = load %struct._GimpItemTree*, %struct._GimpItemTree** %layers, align 8
  %92 = load %struct._GimpLayer*, %struct._GimpLayer** %layer.addr, align 8
  %93 = bitcast %struct._GimpLayer* %92 to %struct._GTypeInstance*
  %call119 = call i64 @gimp_item_get_type() #8
  %call120 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %93, i64 %call119)
  %94 = bitcast %struct._GTypeInstance* %call120 to %struct._GimpItem*
  %95 = load %struct._GimpLayer*, %struct._GimpLayer** %new_active.addr, align 8
  %96 = bitcast %struct._GimpLayer* %95 to %struct._GTypeInstance*
  %call121 = call i64 @gimp_item_get_type() #8
  %call122 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %96, i64 %call121)
  %97 = bitcast %struct._GTypeInstance* %call122 to %struct._GimpItem*
  %call123 = call %struct._GimpItem* @gimp_item_tree_remove_item(%struct._GimpItemTree* %91, %struct._GimpItem* %94, %struct._GimpItem* %97)
  %98 = bitcast %struct._GimpItem* %call123 to %struct._GTypeInstance*
  %call124 = call i64 @gimp_layer_get_type() #8
  %call125 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %98, i64 %call124)
  %99 = bitcast %struct._GTypeInstance* %call125 to %struct._GimpLayer*
  store %struct._GimpLayer* %99, %struct._GimpLayer** %new_active.addr, align 8
  %100 = load %struct._GimpLayer*, %struct._GimpLayer** %layer.addr, align 8
  %call126 = call i32 @gimp_layer_is_floating_sel(%struct._GimpLayer* %100)
  %tobool127 = icmp ne i32 %call126, 0
  br i1 %tobool127, label %if.then.128, label %if.else.129

if.then.128:                                      ; preds = %if.end.118
  %101 = load %struct._GimpLayer*, %struct._GimpLayer** %layer.addr, align 8
  call void @floating_sel_activate_drawable(%struct._GimpLayer* %101)
  br label %if.end.142

if.else.129:                                      ; preds = %if.end.118
  %102 = load %struct._GimpLayer*, %struct._GimpLayer** %active_layer, align 8
  %tobool130 = icmp ne %struct._GimpLayer* %102, null
  br i1 %tobool130, label %land.lhs.true.131, label %if.end.141

land.lhs.true.131:                                ; preds = %if.else.129
  %103 = load %struct._GimpLayer*, %struct._GimpLayer** %layer.addr, align 8
  %104 = load %struct._GimpLayer*, %struct._GimpLayer** %active_layer, align 8
  %cmp132 = icmp eq %struct._GimpLayer* %103, %104
  br i1 %cmp132, label %if.then.139, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true.131
  %105 = load %struct._GimpLayer*, %struct._GimpLayer** %layer.addr, align 8
  %106 = bitcast %struct._GimpLayer* %105 to %struct._GTypeInstance*
  %call133 = call i64 @gimp_viewable_get_type() #8
  %call134 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %106, i64 %call133)
  %107 = bitcast %struct._GTypeInstance* %call134 to %struct._GimpViewable*
  %108 = load %struct._GimpLayer*, %struct._GimpLayer** %active_layer, align 8
  %109 = bitcast %struct._GimpLayer* %108 to %struct._GTypeInstance*
  %call135 = call i64 @gimp_viewable_get_type() #8
  %call136 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %109, i64 %call135)
  %110 = bitcast %struct._GTypeInstance* %call136 to %struct._GimpViewable*
  %call137 = call i32 @gimp_viewable_is_ancestor(%struct._GimpViewable* %107, %struct._GimpViewable* %110)
  %tobool138 = icmp ne i32 %call137, 0
  br i1 %tobool138, label %if.then.139, label %if.end.141

if.then.139:                                      ; preds = %lor.lhs.false, %land.lhs.true.131
  %111 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %112 = load %struct._GimpLayer*, %struct._GimpLayer** %new_active.addr, align 8
  %call140 = call %struct._GimpLayer* @gimp_image_set_active_layer(%struct._GimpImage* %111, %struct._GimpLayer* %112)
  br label %if.end.141

if.end.141:                                       ; preds = %if.then.139, %lor.lhs.false, %if.else.129
  br label %if.end.142

if.end.142:                                       ; preds = %if.end.141, %if.then.128
  %113 = load %struct._GimpLayer*, %struct._GimpLayer** %layer.addr, align 8
  %114 = bitcast %struct._GimpLayer* %113 to i8*
  call void @g_object_unref(i8* %114)
  %115 = load i32, i32* %old_has_alpha, align 4
  %116 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call143 = call i32 @gimp_image_has_alpha(%struct._GimpImage* %116)
  %cmp144 = icmp ne i32 %115, %call143
  br i1 %cmp144, label %if.then.145, label %if.end.146

if.then.145:                                      ; preds = %if.end.142
  %117 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %flush_accum = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %117, i32 0, i32 47
  %alpha_changed = getelementptr inbounds %struct._GimpImageFlushAccumulator, %struct._GimpImageFlushAccumulator* %flush_accum, i32 0, i32 0
  store i32 1, i32* %alpha_changed, align 4
  br label %if.end.146

if.end.146:                                       ; preds = %if.then.145, %if.end.142
  %118 = load i32, i32* %undo_group, align 4
  %tobool147 = icmp ne i32 %118, 0
  br i1 %tobool147, label %if.then.148, label %if.end.150

if.then.148:                                      ; preds = %if.end.146
  %119 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call149 = call i32 @gimp_image_undo_group_end(%struct._GimpImage* %119)
  br label %if.end.150

if.end.150:                                       ; preds = %if.else.9, %if.else.36, %if.else.45, %if.else.54, %if.then.65, %if.then.148, %if.end.146
  ret void
}

declare %struct._GimpLayer* @gimp_drawable_get_floating_sel(%struct._GimpDrawable*) #1

declare i32 @gimp_image_undo_group_start(%struct._GimpImage*, i32, i8*) #1

declare void @gimp_drawable_detach_floating_sel(%struct._GimpDrawable*) #1

declare %struct._GimpUndo* @gimp_image_undo_push_layer_remove(%struct._GimpImage*, i8*, %struct._GimpLayer*, %struct._GimpLayer*, i32, %struct._GimpLayer*) #1

declare %struct._GimpLayer* @gimp_layer_get_parent(%struct._GimpLayer*) #1

declare i8* @g_object_ref(i8*) #1

declare %struct._GSList* @g_slist_remove(%struct._GSList*, i8*) #1

declare %struct._GimpContainer* @gimp_viewable_get_children(%struct._GimpViewable*) #1

declare %struct._GimpItem* @gimp_item_tree_remove_item(%struct._GimpItemTree*, %struct._GimpItem*, %struct._GimpItem*) #1

declare void @floating_sel_activate_drawable(%struct._GimpLayer*) #1

declare i32 @gimp_viewable_is_ancestor(%struct._GimpViewable*, %struct._GimpViewable*) #1

declare i32 @gimp_image_undo_group_end(%struct._GimpImage*) #1

; Function Attrs: nounwind uwtable
define void @gimp_image_add_layers(%struct._GimpImage* %image, %struct._GList* %layers, %struct._GimpLayer* %parent, i32 %position, i32 %x, i32 %y, i32 %width, i32 %height, i8* %undo_desc) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %layers.addr = alloca %struct._GList*, align 8
  %parent.addr = alloca %struct._GimpLayer*, align 8
  %position.addr = alloca i32, align 4
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %width.addr = alloca i32, align 4
  %height.addr = alloca i32, align 4
  %undo_desc.addr = alloca i8*, align 8
  %private = alloca %struct._GimpImagePrivate*, align 8
  %list = alloca %struct._GList*, align 8
  %layers_x = alloca i32, align 4
  %layers_y = alloca i32, align 4
  %layers_width = alloca i32, align 4
  %layers_height = alloca i32, align 4
  %offset_x = alloca i32, align 4
  %offset_y = alloca i32, align 4
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  %item = alloca %struct._GimpItem*, align 8
  %off_x = alloca i32, align 4
  %off_y = alloca i32, align 4
  %new_item = alloca %struct._GimpItem*, align 8
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store %struct._GList* %layers, %struct._GList** %layers.addr, align 8
  store %struct._GimpLayer* %parent, %struct._GimpLayer** %parent.addr, align 8
  store i32 %position, i32* %position.addr, align 4
  store i32 %x, i32* %x.addr, align 4
  store i32 %y, i32* %y.addr, align 4
  store i32 %width, i32* %width.addr, align 4
  store i32 %height, i32* %height.addr, align 4
  store i8* %undo_desc, i8** %undo_desc.addr, align 8
  store i32 2147483647, i32* %layers_x, align 4
  store i32 2147483647, i32* %layers_y, align 4
  store i32 0, i32* %layers_width, align 4
  store i32 0, i32* %layers_height, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__func__.gimp_image_add_layers, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  br label %do.body.11

do.body.11:                                       ; preds = %do.end
  %13 = load %struct._GList*, %struct._GList** %layers.addr, align 8
  %cmp12 = icmp ne %struct._GList* %13, null
  br i1 %cmp12, label %if.then.13, label %if.else.14

if.then.13:                                       ; preds = %do.body.11
  br label %if.end.15

if.else.14:                                       ; preds = %do.body.11
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @__func__.gimp_image_add_layers, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.62, i32 0, i32 0))
  br label %return

if.end.15:                                        ; preds = %if.then.13
  br label %do.end.16

do.end.16:                                        ; preds = %if.end.15
  %14 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %15 = bitcast %struct._GimpImage* %14 to %struct._GTypeInstance*
  %call17 = call i64 @gimp_image_get_type() #8
  %call18 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %15, i64 %call17)
  %16 = bitcast i8* %call18 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %16, %struct._GimpImagePrivate** %private, align 8
  %17 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %layers19 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %17, i32 0, i32 27
  %18 = load %struct._GimpItemTree*, %struct._GimpItemTree** %layers19, align 8
  %19 = load %struct._GList*, %struct._GList** %layers.addr, align 8
  %data = getelementptr inbounds %struct._GList, %struct._GList* %19, i32 0, i32 0
  %20 = load i8*, i8** %data, align 8
  %21 = bitcast i8* %20 to %struct._GimpItem*
  %22 = bitcast %struct._GimpLayer** %parent.addr to %struct._GimpItem**
  %call20 = call i32 @gimp_item_tree_get_insert_pos(%struct._GimpItemTree* %18, %struct._GimpItem* %21, %struct._GimpItem** %22, i32* %position.addr)
  %tobool21 = icmp ne i32 %call20, 0
  br i1 %tobool21, label %if.end.23, label %if.then.22

if.then.22:                                       ; preds = %do.end.16
  br label %return

if.end.23:                                        ; preds = %do.end.16
  %23 = load %struct._GList*, %struct._GList** %layers.addr, align 8
  store %struct._GList* %23, %struct._GList** %list, align 8
  br label %for.cond

for.cond:                                         ; preds = %cond.end.60, %if.end.23
  %24 = load %struct._GList*, %struct._GList** %list, align 8
  %tobool24 = icmp ne %struct._GList* %24, null
  br i1 %tobool24, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %25 = load %struct._GList*, %struct._GList** %list, align 8
  %data26 = getelementptr inbounds %struct._GList, %struct._GList* %25, i32 0, i32 0
  %26 = load i8*, i8** %data26, align 8
  %27 = bitcast i8* %26 to %struct._GTypeInstance*
  %call27 = call i64 @gimp_item_get_type() #8
  %call28 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %27, i64 %call27)
  %28 = bitcast %struct._GTypeInstance* %call28 to %struct._GimpItem*
  store %struct._GimpItem* %28, %struct._GimpItem** %item, align 8
  %29 = load %struct._GimpItem*, %struct._GimpItem** %item, align 8
  call void @gimp_item_get_offset(%struct._GimpItem* %29, i32* %off_x, i32* %off_y)
  %30 = load i32, i32* %layers_x, align 4
  %31 = load i32, i32* %off_x, align 4
  %cmp31 = icmp slt i32 %30, %31
  br i1 %cmp31, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  %32 = load i32, i32* %layers_x, align 4
  br label %cond.end

cond.false:                                       ; preds = %for.body
  %33 = load i32, i32* %off_x, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %32, %cond.true ], [ %33, %cond.false ]
  store i32 %cond, i32* %layers_x, align 4
  %34 = load i32, i32* %layers_y, align 4
  %35 = load i32, i32* %off_y, align 4
  %cmp32 = icmp slt i32 %34, %35
  br i1 %cmp32, label %cond.true.33, label %cond.false.34

cond.true.33:                                     ; preds = %cond.end
  %36 = load i32, i32* %layers_y, align 4
  br label %cond.end.35

cond.false.34:                                    ; preds = %cond.end
  %37 = load i32, i32* %off_y, align 4
  br label %cond.end.35

cond.end.35:                                      ; preds = %cond.false.34, %cond.true.33
  %cond36 = phi i32 [ %36, %cond.true.33 ], [ %37, %cond.false.34 ]
  store i32 %cond36, i32* %layers_y, align 4
  %38 = load i32, i32* %layers_width, align 4
  %39 = load i32, i32* %off_x, align 4
  %40 = load %struct._GimpItem*, %struct._GimpItem** %item, align 8
  %call37 = call i32 @gimp_item_get_width(%struct._GimpItem* %40)
  %add = add nsw i32 %39, %call37
  %41 = load i32, i32* %layers_x, align 4
  %sub = sub nsw i32 %add, %41
  %cmp38 = icmp sgt i32 %38, %sub
  br i1 %cmp38, label %cond.true.39, label %cond.false.40

cond.true.39:                                     ; preds = %cond.end.35
  %42 = load i32, i32* %layers_width, align 4
  br label %cond.end.44

cond.false.40:                                    ; preds = %cond.end.35
  %43 = load i32, i32* %off_x, align 4
  %44 = load %struct._GimpItem*, %struct._GimpItem** %item, align 8
  %call41 = call i32 @gimp_item_get_width(%struct._GimpItem* %44)
  %add42 = add nsw i32 %43, %call41
  %45 = load i32, i32* %layers_x, align 4
  %sub43 = sub nsw i32 %add42, %45
  br label %cond.end.44

cond.end.44:                                      ; preds = %cond.false.40, %cond.true.39
  %cond45 = phi i32 [ %42, %cond.true.39 ], [ %sub43, %cond.false.40 ]
  store i32 %cond45, i32* %layers_width, align 4
  %46 = load i32, i32* %layers_height, align 4
  %47 = load i32, i32* %off_y, align 4
  %48 = load %struct._GimpItem*, %struct._GimpItem** %item, align 8
  %call46 = call i32 @gimp_item_get_height(%struct._GimpItem* %48)
  %add47 = add nsw i32 %47, %call46
  %49 = load i32, i32* %layers_y, align 4
  %sub48 = sub nsw i32 %add47, %49
  %cmp49 = icmp sgt i32 %46, %sub48
  br i1 %cmp49, label %cond.true.50, label %cond.false.51

cond.true.50:                                     ; preds = %cond.end.44
  %50 = load i32, i32* %layers_height, align 4
  br label %cond.end.55

cond.false.51:                                    ; preds = %cond.end.44
  %51 = load i32, i32* %off_y, align 4
  %52 = load %struct._GimpItem*, %struct._GimpItem** %item, align 8
  %call52 = call i32 @gimp_item_get_height(%struct._GimpItem* %52)
  %add53 = add nsw i32 %51, %call52
  %53 = load i32, i32* %layers_y, align 4
  %sub54 = sub nsw i32 %add53, %53
  br label %cond.end.55

cond.end.55:                                      ; preds = %cond.false.51, %cond.true.50
  %cond56 = phi i32 [ %50, %cond.true.50 ], [ %sub54, %cond.false.51 ]
  store i32 %cond56, i32* %layers_height, align 4
  br label %for.inc

for.inc:                                          ; preds = %cond.end.55
  %54 = load %struct._GList*, %struct._GList** %list, align 8
  %tobool57 = icmp ne %struct._GList* %54, null
  br i1 %tobool57, label %cond.true.58, label %cond.false.59

cond.true.58:                                     ; preds = %for.inc
  %55 = load %struct._GList*, %struct._GList** %list, align 8
  %next = getelementptr inbounds %struct._GList, %struct._GList* %55, i32 0, i32 1
  %56 = load %struct._GList*, %struct._GList** %next, align 8
  br label %cond.end.60

cond.false.59:                                    ; preds = %for.inc
  br label %cond.end.60

cond.end.60:                                      ; preds = %cond.false.59, %cond.true.58
  %cond61 = phi %struct._GList* [ %56, %cond.true.58 ], [ null, %cond.false.59 ]
  store %struct._GList* %cond61, %struct._GList** %list, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %57 = load i32, i32* %x.addr, align 4
  %58 = load i32, i32* %width.addr, align 4
  %59 = load i32, i32* %layers_width, align 4
  %sub62 = sub nsw i32 %58, %59
  %div = sdiv i32 %sub62, 2
  %add63 = add nsw i32 %57, %div
  %60 = load i32, i32* %layers_x, align 4
  %sub64 = sub nsw i32 %add63, %60
  store i32 %sub64, i32* %offset_x, align 4
  %61 = load i32, i32* %y.addr, align 4
  %62 = load i32, i32* %height.addr, align 4
  %63 = load i32, i32* %layers_height, align 4
  %sub65 = sub nsw i32 %62, %63
  %div66 = sdiv i32 %sub65, 2
  %add67 = add nsw i32 %61, %div66
  %64 = load i32, i32* %layers_y, align 4
  %sub68 = sub nsw i32 %add67, %64
  store i32 %sub68, i32* %offset_y, align 4
  %65 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %66 = load i8*, i8** %undo_desc.addr, align 8
  %call69 = call i32 @gimp_image_undo_group_start(%struct._GimpImage* %65, i32 23, i8* %66)
  %67 = load %struct._GList*, %struct._GList** %layers.addr, align 8
  store %struct._GList* %67, %struct._GList** %list, align 8
  br label %for.cond.70

for.cond.70:                                      ; preds = %cond.end.85, %for.end
  %68 = load %struct._GList*, %struct._GList** %list, align 8
  %tobool71 = icmp ne %struct._GList* %68, null
  br i1 %tobool71, label %for.body.72, label %for.end.87

for.body.72:                                      ; preds = %for.cond.70
  %69 = load %struct._GList*, %struct._GList** %list, align 8
  %data74 = getelementptr inbounds %struct._GList, %struct._GList* %69, i32 0, i32 0
  %70 = load i8*, i8** %data74, align 8
  %71 = bitcast i8* %70 to %struct._GTypeInstance*
  %call75 = call i64 @gimp_item_get_type() #8
  %call76 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %71, i64 %call75)
  %72 = bitcast %struct._GTypeInstance* %call76 to %struct._GimpItem*
  store %struct._GimpItem* %72, %struct._GimpItem** %new_item, align 8
  %73 = load %struct._GimpItem*, %struct._GimpItem** %new_item, align 8
  %74 = load i32, i32* %offset_x, align 4
  %75 = load i32, i32* %offset_y, align 4
  call void @gimp_item_translate(%struct._GimpItem* %73, i32 %74, i32 %75, i32 0)
  %76 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %77 = load %struct._GimpItem*, %struct._GimpItem** %new_item, align 8
  %78 = bitcast %struct._GimpItem* %77 to %struct._GTypeInstance*
  %call77 = call i64 @gimp_layer_get_type() #8
  %call78 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %78, i64 %call77)
  %79 = bitcast %struct._GTypeInstance* %call78 to %struct._GimpLayer*
  %80 = load %struct._GimpLayer*, %struct._GimpLayer** %parent.addr, align 8
  %81 = load i32, i32* %position.addr, align 4
  %call79 = call i32 @gimp_image_add_layer(%struct._GimpImage* %76, %struct._GimpLayer* %79, %struct._GimpLayer* %80, i32 %81, i32 1)
  %82 = load i32, i32* %position.addr, align 4
  %inc = add nsw i32 %82, 1
  store i32 %inc, i32* %position.addr, align 4
  br label %for.inc.80

for.inc.80:                                       ; preds = %for.body.72
  %83 = load %struct._GList*, %struct._GList** %list, align 8
  %tobool81 = icmp ne %struct._GList* %83, null
  br i1 %tobool81, label %cond.true.82, label %cond.false.84

cond.true.82:                                     ; preds = %for.inc.80
  %84 = load %struct._GList*, %struct._GList** %list, align 8
  %next83 = getelementptr inbounds %struct._GList, %struct._GList* %84, i32 0, i32 1
  %85 = load %struct._GList*, %struct._GList** %next83, align 8
  br label %cond.end.85

cond.false.84:                                    ; preds = %for.inc.80
  br label %cond.end.85

cond.end.85:                                      ; preds = %cond.false.84, %cond.true.82
  %cond86 = phi %struct._GList* [ %85, %cond.true.82 ], [ null, %cond.false.84 ]
  store %struct._GList* %cond86, %struct._GList** %list, align 8
  br label %for.cond.70

for.end.87:                                       ; preds = %for.cond.70
  %86 = load %struct._GList*, %struct._GList** %layers.addr, align 8
  %tobool88 = icmp ne %struct._GList* %86, null
  br i1 %tobool88, label %if.then.89, label %if.end.92

if.then.89:                                       ; preds = %for.end.87
  %87 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %88 = load %struct._GList*, %struct._GList** %layers.addr, align 8
  %data90 = getelementptr inbounds %struct._GList, %struct._GList* %88, i32 0, i32 0
  %89 = load i8*, i8** %data90, align 8
  %90 = bitcast i8* %89 to %struct._GimpLayer*
  %call91 = call %struct._GimpLayer* @gimp_image_set_active_layer(%struct._GimpImage* %87, %struct._GimpLayer* %90)
  br label %if.end.92

if.end.92:                                        ; preds = %if.then.89, %for.end.87
  %91 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call93 = call i32 @gimp_image_undo_group_end(%struct._GimpImage* %91)
  br label %return

return:                                           ; preds = %if.end.92, %if.then.22, %if.else.14, %if.else.9
  ret void
}

declare void @gimp_item_get_offset(%struct._GimpItem*, i32*, i32*) #1

declare void @gimp_item_translate(%struct._GimpItem*, i32, i32, i32) #1

; Function Attrs: nounwind uwtable
define i32 @gimp_image_add_channel(%struct._GimpImage* %image, %struct._GimpChannel* %channel, %struct._GimpChannel* %parent, i32 %position, i32 %push_undo) #3 {
entry:
  %retval = alloca i32, align 4
  %image.addr = alloca %struct._GimpImage*, align 8
  %channel.addr = alloca %struct._GimpChannel*, align 8
  %parent.addr = alloca %struct._GimpChannel*, align 8
  %position.addr = alloca i32, align 4
  %push_undo.addr = alloca i32, align 4
  %private = alloca %struct._GimpImagePrivate*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store %struct._GimpChannel* %channel, %struct._GimpChannel** %channel.addr, align 8
  store %struct._GimpChannel* %parent, %struct._GimpChannel** %parent.addr, align 8
  store i32 %position, i32* %position.addr, align 4
  store i32 %push_undo, i32* %push_undo.addr, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__func__.gimp_image_add_channel, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store i32 0, i32* %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %15, %struct._GimpImagePrivate** %private, align 8
  %16 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %channels = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %16, i32 0, i32 28
  %17 = load %struct._GimpItemTree*, %struct._GimpItemTree** %channels, align 8
  %18 = load %struct._GimpChannel*, %struct._GimpChannel** %channel.addr, align 8
  %19 = bitcast %struct._GimpChannel* %18 to %struct._GimpItem*
  %20 = bitcast %struct._GimpChannel** %parent.addr to %struct._GimpItem**
  %call13 = call i32 @gimp_item_tree_get_insert_pos(%struct._GimpItemTree* %17, %struct._GimpItem* %19, %struct._GimpItem** %20, i32* %position.addr)
  %tobool14 = icmp ne i32 %call13, 0
  br i1 %tobool14, label %if.end.16, label %if.then.15

if.then.15:                                       ; preds = %do.end
  store i32 0, i32* %retval
  br label %return

if.end.16:                                        ; preds = %do.end
  %21 = load i32, i32* %push_undo.addr, align 4
  %tobool17 = icmp ne i32 %21, 0
  br i1 %tobool17, label %if.then.18, label %if.end.22

if.then.18:                                       ; preds = %if.end.16
  %22 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call19 = call i8* @g_dpgettext(i8* null, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.63, i32 0, i32 0), i64 10)
  %23 = load %struct._GimpChannel*, %struct._GimpChannel** %channel.addr, align 8
  %24 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call20 = call %struct._GimpChannel* @gimp_image_get_active_channel(%struct._GimpImage* %24)
  %call21 = call %struct._GimpUndo* @gimp_image_undo_push_channel_add(%struct._GimpImage* %22, i8* %call19, %struct._GimpChannel* %23, %struct._GimpChannel* %call20)
  br label %if.end.22

if.end.22:                                        ; preds = %if.then.18, %if.end.16
  %25 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %channels23 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %25, i32 0, i32 28
  %26 = load %struct._GimpItemTree*, %struct._GimpItemTree** %channels23, align 8
  %27 = load %struct._GimpChannel*, %struct._GimpChannel** %channel.addr, align 8
  %28 = bitcast %struct._GimpChannel* %27 to %struct._GTypeInstance*
  %call24 = call i64 @gimp_item_get_type() #8
  %call25 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %28, i64 %call24)
  %29 = bitcast %struct._GTypeInstance* %call25 to %struct._GimpItem*
  %30 = load %struct._GimpChannel*, %struct._GimpChannel** %parent.addr, align 8
  %31 = bitcast %struct._GimpChannel* %30 to %struct._GTypeInstance*
  %call26 = call i64 @gimp_item_get_type() #8
  %call27 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %31, i64 %call26)
  %32 = bitcast %struct._GTypeInstance* %call27 to %struct._GimpItem*
  %33 = load i32, i32* %position.addr, align 4
  call void @gimp_item_tree_add_item(%struct._GimpItemTree* %26, %struct._GimpItem* %29, %struct._GimpItem* %32, i32 %33)
  %34 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %35 = load %struct._GimpChannel*, %struct._GimpChannel** %channel.addr, align 8
  %call28 = call %struct._GimpChannel* @gimp_image_set_active_channel(%struct._GimpImage* %34, %struct._GimpChannel* %35)
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %if.end.22, %if.then.15, %if.else.9
  %36 = load i32, i32* %retval
  ret i32 %36
}

declare %struct._GimpUndo* @gimp_image_undo_push_channel_add(%struct._GimpImage*, i8*, %struct._GimpChannel*, %struct._GimpChannel*) #1

; Function Attrs: nounwind uwtable
define void @gimp_image_remove_channel(%struct._GimpImage* %image, %struct._GimpChannel* %channel, i32 %push_undo, %struct._GimpChannel* %new_active) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %channel.addr = alloca %struct._GimpChannel*, align 8
  %push_undo.addr = alloca i32, align 4
  %new_active.addr = alloca %struct._GimpChannel*, align 8
  %private = alloca %struct._GimpImagePrivate*, align 8
  %active_channel = alloca %struct._GimpChannel*, align 8
  %undo_group = alloca i32, align 4
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  %__inst13 = alloca %struct._GTypeInstance*, align 8
  %__t15 = alloca i64, align 8
  %__r18 = alloca i32, align 4
  %tmp33 = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store %struct._GimpChannel* %channel, %struct._GimpChannel** %channel.addr, align 8
  store i32 %push_undo, i32* %push_undo.addr, align 4
  store %struct._GimpChannel* %new_active, %struct._GimpChannel** %new_active.addr, align 8
  store i32 0, i32* %undo_group, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__func__.gimp_image_remove_channel, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %if.end.111

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  br label %do.body.11

do.body.11:                                       ; preds = %do.end
  %13 = load %struct._GimpChannel*, %struct._GimpChannel** %channel.addr, align 8
  %14 = bitcast %struct._GimpChannel* %13 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %14, %struct._GTypeInstance** %__inst13, align 8
  %call16 = call i64 @gimp_channel_get_type() #8
  store i64 %call16, i64* %__t15, align 8
  %15 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %tobool19 = icmp ne %struct._GTypeInstance* %15, null
  br i1 %tobool19, label %if.else.21, label %if.then.20

if.then.20:                                       ; preds = %do.body.11
  store i32 0, i32* %__r18, align 4
  br label %if.end.32

if.else.21:                                       ; preds = %do.body.11
  %16 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %g_class22 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %16, i32 0, i32 0
  %17 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class22, align 8
  %tobool23 = icmp ne %struct._GTypeClass* %17, null
  br i1 %tobool23, label %land.lhs.true.24, label %if.else.29

land.lhs.true.24:                                 ; preds = %if.else.21
  %18 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %g_class25 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %18, i32 0, i32 0
  %19 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class25, align 8
  %g_type26 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %19, i32 0, i32 0
  %20 = load i64, i64* %g_type26, align 8
  %21 = load i64, i64* %__t15, align 8
  %cmp27 = icmp eq i64 %20, %21
  br i1 %cmp27, label %if.then.28, label %if.else.29

if.then.28:                                       ; preds = %land.lhs.true.24
  store i32 1, i32* %__r18, align 4
  br label %if.end.31

if.else.29:                                       ; preds = %land.lhs.true.24, %if.else.21
  %22 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %23 = load i64, i64* %__t15, align 8
  %call30 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %22, i64 %23) #9
  store i32 %call30, i32* %__r18, align 4
  br label %if.end.31

if.end.31:                                        ; preds = %if.else.29, %if.then.28
  br label %if.end.32

if.end.32:                                        ; preds = %if.end.31, %if.then.20
  %24 = load i32, i32* %__r18, align 4
  store i32 %24, i32* %tmp33
  %25 = load i32, i32* %tmp33
  %tobool34 = icmp ne i32 %25, 0
  br i1 %tobool34, label %if.then.35, label %if.else.36

if.then.35:                                       ; preds = %if.end.32
  br label %if.end.37

if.else.36:                                       ; preds = %if.end.32
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__func__.gimp_image_remove_channel, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.64, i32 0, i32 0))
  br label %if.end.111

if.end.37:                                        ; preds = %if.then.35
  br label %do.end.38

do.end.38:                                        ; preds = %if.end.37
  br label %do.body.39

do.body.39:                                       ; preds = %do.end.38
  %26 = load %struct._GimpChannel*, %struct._GimpChannel** %channel.addr, align 8
  %27 = bitcast %struct._GimpChannel* %26 to %struct._GTypeInstance*
  %call40 = call i64 @gimp_item_get_type() #8
  %call41 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %27, i64 %call40)
  %28 = bitcast %struct._GTypeInstance* %call41 to %struct._GimpItem*
  %call42 = call i32 @gimp_item_is_attached(%struct._GimpItem* %28)
  %tobool43 = icmp ne i32 %call42, 0
  br i1 %tobool43, label %if.then.44, label %if.else.45

if.then.44:                                       ; preds = %do.body.39
  br label %if.end.46

if.else.45:                                       ; preds = %do.body.39
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__func__.gimp_image_remove_channel, i32 0, i32 0), i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.65, i32 0, i32 0))
  br label %if.end.111

if.end.46:                                        ; preds = %if.then.44
  br label %do.end.47

do.end.47:                                        ; preds = %if.end.46
  br label %do.body.48

do.body.48:                                       ; preds = %do.end.47
  %29 = load %struct._GimpChannel*, %struct._GimpChannel** %channel.addr, align 8
  %30 = bitcast %struct._GimpChannel* %29 to %struct._GTypeInstance*
  %call49 = call i64 @gimp_item_get_type() #8
  %call50 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %30, i64 %call49)
  %31 = bitcast %struct._GTypeInstance* %call50 to %struct._GimpItem*
  %call51 = call %struct._GimpImage* @gimp_item_get_image(%struct._GimpItem* %31)
  %32 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %cmp52 = icmp eq %struct._GimpImage* %call51, %32
  br i1 %cmp52, label %if.then.53, label %if.else.54

if.then.53:                                       ; preds = %do.body.48
  br label %if.end.55

if.else.54:                                       ; preds = %do.body.48
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__func__.gimp_image_remove_channel, i32 0, i32 0), i8* getelementptr inbounds ([51 x i8], [51 x i8]* @.str.66, i32 0, i32 0))
  br label %if.end.111

if.end.55:                                        ; preds = %if.then.53
  br label %do.end.56

do.end.56:                                        ; preds = %if.end.55
  %33 = load %struct._GimpChannel*, %struct._GimpChannel** %channel.addr, align 8
  %34 = bitcast %struct._GimpChannel* %33 to %struct._GTypeInstance*
  %call57 = call i64 @gimp_drawable_get_type() #8
  %call58 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %34, i64 %call57)
  %35 = bitcast %struct._GTypeInstance* %call58 to %struct._GimpDrawable*
  %call59 = call %struct._GimpLayer* @gimp_drawable_get_floating_sel(%struct._GimpDrawable* %35)
  %tobool60 = icmp ne %struct._GimpLayer* %call59, null
  br i1 %tobool60, label %if.then.61, label %if.end.70

if.then.61:                                       ; preds = %do.end.56
  %36 = load i32, i32* %push_undo.addr, align 4
  %tobool62 = icmp ne i32 %36, 0
  br i1 %tobool62, label %if.end.64, label %if.then.63

if.then.63:                                       ; preds = %if.then.61
  call void (i8*, ...) @g_warning(i8* getelementptr inbounds ([130 x i8], [130 x i8]* @.str.67, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__func__.gimp_image_remove_channel, i32 0, i32 0))
  br label %if.end.111

if.end.64:                                        ; preds = %if.then.61
  %37 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call65 = call i8* @g_dpgettext(i8* null, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.68, i32 0, i32 0), i64 10)
  %call66 = call i32 @gimp_image_undo_group_start(%struct._GimpImage* %37, i32 7, i8* %call65)
  store i32 1, i32* %undo_group, align 4
  %38 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %39 = load %struct._GimpChannel*, %struct._GimpChannel** %channel.addr, align 8
  %40 = bitcast %struct._GimpChannel* %39 to %struct._GTypeInstance*
  %call67 = call i64 @gimp_drawable_get_type() #8
  %call68 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %40, i64 %call67)
  %41 = bitcast %struct._GTypeInstance* %call68 to %struct._GimpDrawable*
  %call69 = call %struct._GimpLayer* @gimp_drawable_get_floating_sel(%struct._GimpDrawable* %41)
  call void @gimp_image_remove_layer(%struct._GimpImage* %38, %struct._GimpLayer* %call69, i32 1, %struct._GimpLayer* null)
  br label %if.end.70

if.end.70:                                        ; preds = %if.end.64, %do.end.56
  %42 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %43 = bitcast %struct._GimpImage* %42 to %struct._GTypeInstance*
  %call71 = call i64 @gimp_image_get_type() #8
  %call72 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %43, i64 %call71)
  %44 = bitcast i8* %call72 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %44, %struct._GimpImagePrivate** %private, align 8
  %45 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call73 = call %struct._GimpChannel* @gimp_image_get_active_channel(%struct._GimpImage* %45)
  store %struct._GimpChannel* %call73, %struct._GimpChannel** %active_channel, align 8
  %46 = load i32, i32* %push_undo.addr, align 4
  %tobool74 = icmp ne i32 %46, 0
  br i1 %tobool74, label %if.then.75, label %if.end.82

if.then.75:                                       ; preds = %if.end.70
  %47 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call76 = call i8* @g_dpgettext(i8* null, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.68, i32 0, i32 0), i64 10)
  %48 = load %struct._GimpChannel*, %struct._GimpChannel** %channel.addr, align 8
  %49 = load %struct._GimpChannel*, %struct._GimpChannel** %channel.addr, align 8
  %call77 = call %struct._GimpChannel* @gimp_channel_get_parent(%struct._GimpChannel* %49)
  %50 = load %struct._GimpChannel*, %struct._GimpChannel** %channel.addr, align 8
  %51 = bitcast %struct._GimpChannel* %50 to %struct._GTypeInstance*
  %call78 = call i64 @gimp_item_get_type() #8
  %call79 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %51, i64 %call78)
  %52 = bitcast %struct._GTypeInstance* %call79 to %struct._GimpItem*
  %call80 = call i32 @gimp_item_get_index(%struct._GimpItem* %52)
  %53 = load %struct._GimpChannel*, %struct._GimpChannel** %active_channel, align 8
  %call81 = call %struct._GimpUndo* @gimp_image_undo_push_channel_remove(%struct._GimpImage* %47, i8* %call76, %struct._GimpChannel* %48, %struct._GimpChannel* %call77, i32 %call80, %struct._GimpChannel* %53)
  br label %if.end.82

if.end.82:                                        ; preds = %if.then.75, %if.end.70
  %54 = load %struct._GimpChannel*, %struct._GimpChannel** %channel.addr, align 8
  %55 = bitcast %struct._GimpChannel* %54 to i8*
  %call83 = call i8* @g_object_ref(i8* %55)
  %56 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %channels = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %56, i32 0, i32 28
  %57 = load %struct._GimpItemTree*, %struct._GimpItemTree** %channels, align 8
  %58 = load %struct._GimpChannel*, %struct._GimpChannel** %channel.addr, align 8
  %59 = bitcast %struct._GimpChannel* %58 to %struct._GTypeInstance*
  %call84 = call i64 @gimp_item_get_type() #8
  %call85 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %59, i64 %call84)
  %60 = bitcast %struct._GTypeInstance* %call85 to %struct._GimpItem*
  %61 = load %struct._GimpChannel*, %struct._GimpChannel** %new_active.addr, align 8
  %62 = bitcast %struct._GimpChannel* %61 to %struct._GTypeInstance*
  %call86 = call i64 @gimp_item_get_type() #8
  %call87 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %62, i64 %call86)
  %63 = bitcast %struct._GTypeInstance* %call87 to %struct._GimpItem*
  %call88 = call %struct._GimpItem* @gimp_item_tree_remove_item(%struct._GimpItemTree* %57, %struct._GimpItem* %60, %struct._GimpItem* %63)
  %64 = bitcast %struct._GimpItem* %call88 to %struct._GTypeInstance*
  %call89 = call i64 @gimp_channel_get_type() #8
  %call90 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %64, i64 %call89)
  %65 = bitcast %struct._GTypeInstance* %call90 to %struct._GimpChannel*
  store %struct._GimpChannel* %65, %struct._GimpChannel** %new_active.addr, align 8
  %66 = load %struct._GimpChannel*, %struct._GimpChannel** %active_channel, align 8
  %tobool91 = icmp ne %struct._GimpChannel* %66, null
  br i1 %tobool91, label %land.lhs.true.92, label %if.end.107

land.lhs.true.92:                                 ; preds = %if.end.82
  %67 = load %struct._GimpChannel*, %struct._GimpChannel** %channel.addr, align 8
  %68 = load %struct._GimpChannel*, %struct._GimpChannel** %active_channel, align 8
  %cmp93 = icmp eq %struct._GimpChannel* %67, %68
  br i1 %cmp93, label %if.then.100, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true.92
  %69 = load %struct._GimpChannel*, %struct._GimpChannel** %channel.addr, align 8
  %70 = bitcast %struct._GimpChannel* %69 to %struct._GTypeInstance*
  %call94 = call i64 @gimp_viewable_get_type() #8
  %call95 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %70, i64 %call94)
  %71 = bitcast %struct._GTypeInstance* %call95 to %struct._GimpViewable*
  %72 = load %struct._GimpChannel*, %struct._GimpChannel** %active_channel, align 8
  %73 = bitcast %struct._GimpChannel* %72 to %struct._GTypeInstance*
  %call96 = call i64 @gimp_viewable_get_type() #8
  %call97 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %73, i64 %call96)
  %74 = bitcast %struct._GTypeInstance* %call97 to %struct._GimpViewable*
  %call98 = call i32 @gimp_viewable_is_ancestor(%struct._GimpViewable* %71, %struct._GimpViewable* %74)
  %tobool99 = icmp ne i32 %call98, 0
  br i1 %tobool99, label %if.then.100, label %if.end.107

if.then.100:                                      ; preds = %lor.lhs.false, %land.lhs.true.92
  %75 = load %struct._GimpChannel*, %struct._GimpChannel** %new_active.addr, align 8
  %tobool101 = icmp ne %struct._GimpChannel* %75, null
  br i1 %tobool101, label %if.then.102, label %if.else.104

if.then.102:                                      ; preds = %if.then.100
  %76 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %77 = load %struct._GimpChannel*, %struct._GimpChannel** %new_active.addr, align 8
  %call103 = call %struct._GimpChannel* @gimp_image_set_active_channel(%struct._GimpImage* %76, %struct._GimpChannel* %77)
  br label %if.end.106

if.else.104:                                      ; preds = %if.then.100
  %78 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call105 = call %struct._GimpChannel* @gimp_image_unset_active_channel(%struct._GimpImage* %78)
  br label %if.end.106

if.end.106:                                       ; preds = %if.else.104, %if.then.102
  br label %if.end.107

if.end.107:                                       ; preds = %if.end.106, %lor.lhs.false, %if.end.82
  %79 = load %struct._GimpChannel*, %struct._GimpChannel** %channel.addr, align 8
  %80 = bitcast %struct._GimpChannel* %79 to i8*
  call void @g_object_unref(i8* %80)
  %81 = load i32, i32* %undo_group, align 4
  %tobool108 = icmp ne i32 %81, 0
  br i1 %tobool108, label %if.then.109, label %if.end.111

if.then.109:                                      ; preds = %if.end.107
  %82 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call110 = call i32 @gimp_image_undo_group_end(%struct._GimpImage* %82)
  br label %if.end.111

if.end.111:                                       ; preds = %if.else.9, %if.else.36, %if.else.45, %if.else.54, %if.then.63, %if.then.109, %if.end.107
  ret void
}

declare %struct._GimpUndo* @gimp_image_undo_push_channel_remove(%struct._GimpImage*, i8*, %struct._GimpChannel*, %struct._GimpChannel*, i32, %struct._GimpChannel*) #1

declare %struct._GimpChannel* @gimp_channel_get_parent(%struct._GimpChannel*) #1

; Function Attrs: nounwind uwtable
define i32 @gimp_image_add_vectors(%struct._GimpImage* %image, %struct._GimpVectors* %vectors, %struct._GimpVectors* %parent, i32 %position, i32 %push_undo) #3 {
entry:
  %retval = alloca i32, align 4
  %image.addr = alloca %struct._GimpImage*, align 8
  %vectors.addr = alloca %struct._GimpVectors*, align 8
  %parent.addr = alloca %struct._GimpVectors*, align 8
  %position.addr = alloca i32, align 4
  %push_undo.addr = alloca i32, align 4
  %private = alloca %struct._GimpImagePrivate*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store %struct._GimpVectors* %vectors, %struct._GimpVectors** %vectors.addr, align 8
  store %struct._GimpVectors* %parent, %struct._GimpVectors** %parent.addr, align 8
  store i32 %position, i32* %position.addr, align 4
  store i32 %push_undo, i32* %push_undo.addr, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__func__.gimp_image_add_vectors, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store i32 0, i32* %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %14 = bitcast %struct._GimpImage* %13 to %struct._GTypeInstance*
  %call11 = call i64 @gimp_image_get_type() #8
  %call12 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %14, i64 %call11)
  %15 = bitcast i8* %call12 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %15, %struct._GimpImagePrivate** %private, align 8
  %16 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %vectors13 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %16, i32 0, i32 29
  %17 = load %struct._GimpItemTree*, %struct._GimpItemTree** %vectors13, align 8
  %18 = load %struct._GimpVectors*, %struct._GimpVectors** %vectors.addr, align 8
  %19 = bitcast %struct._GimpVectors* %18 to %struct._GimpItem*
  %20 = bitcast %struct._GimpVectors** %parent.addr to %struct._GimpItem**
  %call14 = call i32 @gimp_item_tree_get_insert_pos(%struct._GimpItemTree* %17, %struct._GimpItem* %19, %struct._GimpItem** %20, i32* %position.addr)
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %if.end.17, label %if.then.16

if.then.16:                                       ; preds = %do.end
  store i32 0, i32* %retval
  br label %return

if.end.17:                                        ; preds = %do.end
  %21 = load i32, i32* %push_undo.addr, align 4
  %tobool18 = icmp ne i32 %21, 0
  br i1 %tobool18, label %if.then.19, label %if.end.23

if.then.19:                                       ; preds = %if.end.17
  %22 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call20 = call i8* @g_dpgettext(i8* null, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.69, i32 0, i32 0), i64 10)
  %23 = load %struct._GimpVectors*, %struct._GimpVectors** %vectors.addr, align 8
  %24 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call21 = call %struct._GimpVectors* @gimp_image_get_active_vectors(%struct._GimpImage* %24)
  %call22 = call %struct._GimpUndo* @gimp_image_undo_push_vectors_add(%struct._GimpImage* %22, i8* %call20, %struct._GimpVectors* %23, %struct._GimpVectors* %call21)
  br label %if.end.23

if.end.23:                                        ; preds = %if.then.19, %if.end.17
  %25 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %vectors24 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %25, i32 0, i32 29
  %26 = load %struct._GimpItemTree*, %struct._GimpItemTree** %vectors24, align 8
  %27 = load %struct._GimpVectors*, %struct._GimpVectors** %vectors.addr, align 8
  %28 = bitcast %struct._GimpVectors* %27 to %struct._GTypeInstance*
  %call25 = call i64 @gimp_item_get_type() #8
  %call26 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %28, i64 %call25)
  %29 = bitcast %struct._GTypeInstance* %call26 to %struct._GimpItem*
  %30 = load %struct._GimpVectors*, %struct._GimpVectors** %parent.addr, align 8
  %31 = bitcast %struct._GimpVectors* %30 to %struct._GTypeInstance*
  %call27 = call i64 @gimp_item_get_type() #8
  %call28 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %31, i64 %call27)
  %32 = bitcast %struct._GTypeInstance* %call28 to %struct._GimpItem*
  %33 = load i32, i32* %position.addr, align 4
  call void @gimp_item_tree_add_item(%struct._GimpItemTree* %26, %struct._GimpItem* %29, %struct._GimpItem* %32, i32 %33)
  %34 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %35 = load %struct._GimpVectors*, %struct._GimpVectors** %vectors.addr, align 8
  %call29 = call %struct._GimpVectors* @gimp_image_set_active_vectors(%struct._GimpImage* %34, %struct._GimpVectors* %35)
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %if.end.23, %if.then.16, %if.else.9
  %36 = load i32, i32* %retval
  ret i32 %36
}

declare %struct._GimpUndo* @gimp_image_undo_push_vectors_add(%struct._GimpImage*, i8*, %struct._GimpVectors*, %struct._GimpVectors*) #1

; Function Attrs: nounwind uwtable
define void @gimp_image_remove_vectors(%struct._GimpImage* %image, %struct._GimpVectors* %vectors, i32 %push_undo, %struct._GimpVectors* %new_active) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %vectors.addr = alloca %struct._GimpVectors*, align 8
  %push_undo.addr = alloca i32, align 4
  %new_active.addr = alloca %struct._GimpVectors*, align 8
  %private = alloca %struct._GimpImagePrivate*, align 8
  %active_vectors = alloca %struct._GimpVectors*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  %__inst13 = alloca %struct._GTypeInstance*, align 8
  %__t15 = alloca i64, align 8
  %__r18 = alloca i32, align 4
  %tmp33 = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store %struct._GimpVectors* %vectors, %struct._GimpVectors** %vectors.addr, align 8
  store i32 %push_undo, i32* %push_undo.addr, align 4
  store %struct._GimpVectors* %new_active, %struct._GimpVectors** %new_active.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__func__.gimp_image_remove_vectors, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  br label %do.body.11

do.body.11:                                       ; preds = %do.end
  %13 = load %struct._GimpVectors*, %struct._GimpVectors** %vectors.addr, align 8
  %14 = bitcast %struct._GimpVectors* %13 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %14, %struct._GTypeInstance** %__inst13, align 8
  %call16 = call i64 @gimp_vectors_get_type() #8
  store i64 %call16, i64* %__t15, align 8
  %15 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %tobool19 = icmp ne %struct._GTypeInstance* %15, null
  br i1 %tobool19, label %if.else.21, label %if.then.20

if.then.20:                                       ; preds = %do.body.11
  store i32 0, i32* %__r18, align 4
  br label %if.end.32

if.else.21:                                       ; preds = %do.body.11
  %16 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %g_class22 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %16, i32 0, i32 0
  %17 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class22, align 8
  %tobool23 = icmp ne %struct._GTypeClass* %17, null
  br i1 %tobool23, label %land.lhs.true.24, label %if.else.29

land.lhs.true.24:                                 ; preds = %if.else.21
  %18 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %g_class25 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %18, i32 0, i32 0
  %19 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class25, align 8
  %g_type26 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %19, i32 0, i32 0
  %20 = load i64, i64* %g_type26, align 8
  %21 = load i64, i64* %__t15, align 8
  %cmp27 = icmp eq i64 %20, %21
  br i1 %cmp27, label %if.then.28, label %if.else.29

if.then.28:                                       ; preds = %land.lhs.true.24
  store i32 1, i32* %__r18, align 4
  br label %if.end.31

if.else.29:                                       ; preds = %land.lhs.true.24, %if.else.21
  %22 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst13, align 8
  %23 = load i64, i64* %__t15, align 8
  %call30 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %22, i64 %23) #9
  store i32 %call30, i32* %__r18, align 4
  br label %if.end.31

if.end.31:                                        ; preds = %if.else.29, %if.then.28
  br label %if.end.32

if.end.32:                                        ; preds = %if.end.31, %if.then.20
  %24 = load i32, i32* %__r18, align 4
  store i32 %24, i32* %tmp33
  %25 = load i32, i32* %tmp33
  %tobool34 = icmp ne i32 %25, 0
  br i1 %tobool34, label %if.then.35, label %if.else.36

if.then.35:                                       ; preds = %if.end.32
  br label %if.end.37

if.else.36:                                       ; preds = %if.end.32
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__func__.gimp_image_remove_vectors, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.70, i32 0, i32 0))
  br label %return

if.end.37:                                        ; preds = %if.then.35
  br label %do.end.38

do.end.38:                                        ; preds = %if.end.37
  br label %do.body.39

do.body.39:                                       ; preds = %do.end.38
  %26 = load %struct._GimpVectors*, %struct._GimpVectors** %vectors.addr, align 8
  %27 = bitcast %struct._GimpVectors* %26 to %struct._GTypeInstance*
  %call40 = call i64 @gimp_item_get_type() #8
  %call41 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %27, i64 %call40)
  %28 = bitcast %struct._GTypeInstance* %call41 to %struct._GimpItem*
  %call42 = call i32 @gimp_item_is_attached(%struct._GimpItem* %28)
  %tobool43 = icmp ne i32 %call42, 0
  br i1 %tobool43, label %if.then.44, label %if.else.45

if.then.44:                                       ; preds = %do.body.39
  br label %if.end.46

if.else.45:                                       ; preds = %do.body.39
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__func__.gimp_image_remove_vectors, i32 0, i32 0), i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.71, i32 0, i32 0))
  br label %return

if.end.46:                                        ; preds = %if.then.44
  br label %do.end.47

do.end.47:                                        ; preds = %if.end.46
  br label %do.body.48

do.body.48:                                       ; preds = %do.end.47
  %29 = load %struct._GimpVectors*, %struct._GimpVectors** %vectors.addr, align 8
  %30 = bitcast %struct._GimpVectors* %29 to %struct._GTypeInstance*
  %call49 = call i64 @gimp_item_get_type() #8
  %call50 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %30, i64 %call49)
  %31 = bitcast %struct._GTypeInstance* %call50 to %struct._GimpItem*
  %call51 = call %struct._GimpImage* @gimp_item_get_image(%struct._GimpItem* %31)
  %32 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %cmp52 = icmp eq %struct._GimpImage* %call51, %32
  br i1 %cmp52, label %if.then.53, label %if.else.54

if.then.53:                                       ; preds = %do.body.48
  br label %if.end.55

if.else.54:                                       ; preds = %do.body.48
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @__func__.gimp_image_remove_vectors, i32 0, i32 0), i8* getelementptr inbounds ([51 x i8], [51 x i8]* @.str.72, i32 0, i32 0))
  br label %return

if.end.55:                                        ; preds = %if.then.53
  br label %do.end.56

do.end.56:                                        ; preds = %if.end.55
  %33 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %34 = bitcast %struct._GimpImage* %33 to %struct._GTypeInstance*
  %call57 = call i64 @gimp_image_get_type() #8
  %call58 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %34, i64 %call57)
  %35 = bitcast i8* %call58 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %35, %struct._GimpImagePrivate** %private, align 8
  %36 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call59 = call %struct._GimpVectors* @gimp_image_get_active_vectors(%struct._GimpImage* %36)
  store %struct._GimpVectors* %call59, %struct._GimpVectors** %active_vectors, align 8
  %37 = load i32, i32* %push_undo.addr, align 4
  %tobool60 = icmp ne i32 %37, 0
  br i1 %tobool60, label %if.then.61, label %if.end.68

if.then.61:                                       ; preds = %do.end.56
  %38 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call62 = call i8* @g_dpgettext(i8* null, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.73, i32 0, i32 0), i64 10)
  %39 = load %struct._GimpVectors*, %struct._GimpVectors** %vectors.addr, align 8
  %40 = load %struct._GimpVectors*, %struct._GimpVectors** %vectors.addr, align 8
  %call63 = call %struct._GimpVectors* @gimp_vectors_get_parent(%struct._GimpVectors* %40)
  %41 = load %struct._GimpVectors*, %struct._GimpVectors** %vectors.addr, align 8
  %42 = bitcast %struct._GimpVectors* %41 to %struct._GTypeInstance*
  %call64 = call i64 @gimp_item_get_type() #8
  %call65 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %42, i64 %call64)
  %43 = bitcast %struct._GTypeInstance* %call65 to %struct._GimpItem*
  %call66 = call i32 @gimp_item_get_index(%struct._GimpItem* %43)
  %44 = load %struct._GimpVectors*, %struct._GimpVectors** %active_vectors, align 8
  %call67 = call %struct._GimpUndo* @gimp_image_undo_push_vectors_remove(%struct._GimpImage* %38, i8* %call62, %struct._GimpVectors* %39, %struct._GimpVectors* %call63, i32 %call66, %struct._GimpVectors* %44)
  br label %if.end.68

if.end.68:                                        ; preds = %if.then.61, %do.end.56
  %45 = load %struct._GimpVectors*, %struct._GimpVectors** %vectors.addr, align 8
  %46 = bitcast %struct._GimpVectors* %45 to i8*
  %call69 = call i8* @g_object_ref(i8* %46)
  %47 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %vectors70 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %47, i32 0, i32 29
  %48 = load %struct._GimpItemTree*, %struct._GimpItemTree** %vectors70, align 8
  %49 = load %struct._GimpVectors*, %struct._GimpVectors** %vectors.addr, align 8
  %50 = bitcast %struct._GimpVectors* %49 to %struct._GTypeInstance*
  %call71 = call i64 @gimp_item_get_type() #8
  %call72 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %50, i64 %call71)
  %51 = bitcast %struct._GTypeInstance* %call72 to %struct._GimpItem*
  %52 = load %struct._GimpVectors*, %struct._GimpVectors** %new_active.addr, align 8
  %53 = bitcast %struct._GimpVectors* %52 to %struct._GTypeInstance*
  %call73 = call i64 @gimp_item_get_type() #8
  %call74 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %53, i64 %call73)
  %54 = bitcast %struct._GTypeInstance* %call74 to %struct._GimpItem*
  %call75 = call %struct._GimpItem* @gimp_item_tree_remove_item(%struct._GimpItemTree* %48, %struct._GimpItem* %51, %struct._GimpItem* %54)
  %55 = bitcast %struct._GimpItem* %call75 to %struct._GTypeInstance*
  %call76 = call i64 @gimp_vectors_get_type() #8
  %call77 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %55, i64 %call76)
  %56 = bitcast %struct._GTypeInstance* %call77 to %struct._GimpVectors*
  store %struct._GimpVectors* %56, %struct._GimpVectors** %new_active.addr, align 8
  %57 = load %struct._GimpVectors*, %struct._GimpVectors** %active_vectors, align 8
  %tobool78 = icmp ne %struct._GimpVectors* %57, null
  br i1 %tobool78, label %land.lhs.true.79, label %if.end.89

land.lhs.true.79:                                 ; preds = %if.end.68
  %58 = load %struct._GimpVectors*, %struct._GimpVectors** %vectors.addr, align 8
  %59 = load %struct._GimpVectors*, %struct._GimpVectors** %active_vectors, align 8
  %cmp80 = icmp eq %struct._GimpVectors* %58, %59
  br i1 %cmp80, label %if.then.87, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true.79
  %60 = load %struct._GimpVectors*, %struct._GimpVectors** %vectors.addr, align 8
  %61 = bitcast %struct._GimpVectors* %60 to %struct._GTypeInstance*
  %call81 = call i64 @gimp_viewable_get_type() #8
  %call82 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %61, i64 %call81)
  %62 = bitcast %struct._GTypeInstance* %call82 to %struct._GimpViewable*
  %63 = load %struct._GimpVectors*, %struct._GimpVectors** %active_vectors, align 8
  %64 = bitcast %struct._GimpVectors* %63 to %struct._GTypeInstance*
  %call83 = call i64 @gimp_viewable_get_type() #8
  %call84 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %64, i64 %call83)
  %65 = bitcast %struct._GTypeInstance* %call84 to %struct._GimpViewable*
  %call85 = call i32 @gimp_viewable_is_ancestor(%struct._GimpViewable* %62, %struct._GimpViewable* %65)
  %tobool86 = icmp ne i32 %call85, 0
  br i1 %tobool86, label %if.then.87, label %if.end.89

if.then.87:                                       ; preds = %lor.lhs.false, %land.lhs.true.79
  %66 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %67 = load %struct._GimpVectors*, %struct._GimpVectors** %new_active.addr, align 8
  %call88 = call %struct._GimpVectors* @gimp_image_set_active_vectors(%struct._GimpImage* %66, %struct._GimpVectors* %67)
  br label %if.end.89

if.end.89:                                        ; preds = %if.then.87, %lor.lhs.false, %if.end.68
  %68 = load %struct._GimpVectors*, %struct._GimpVectors** %vectors.addr, align 8
  %69 = bitcast %struct._GimpVectors* %68 to i8*
  call void @g_object_unref(i8* %69)
  br label %return

return:                                           ; preds = %if.end.89, %if.else.54, %if.else.45, %if.else.36, %if.else.9
  ret void
}

declare %struct._GimpUndo* @gimp_image_undo_push_vectors_remove(%struct._GimpImage*, i8*, %struct._GimpVectors*, %struct._GimpVectors*, i32, %struct._GimpVectors*) #1

declare %struct._GimpVectors* @gimp_vectors_get_parent(%struct._GimpVectors*) #1

; Function Attrs: nounwind uwtable
define i32 @gimp_image_coords_in_active_pickable(%struct._GimpImage* %image, %struct._GimpCoords* %coords, i32 %sample_merged, i32 %selected_only) #3 {
entry:
  %retval = alloca i32, align 4
  %image.addr = alloca %struct._GimpImage*, align 8
  %coords.addr = alloca %struct._GimpCoords*, align 8
  %sample_merged.addr = alloca i32, align 4
  %selected_only.addr = alloca i32, align 4
  %x = alloca i32, align 4
  %y = alloca i32, align 4
  %in_pickable = alloca i32, align 4
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  %drawable = alloca %struct._GimpDrawable*, align 8
  %item = alloca %struct._GimpItem*, align 8
  %off_x = alloca i32, align 4
  %off_y = alloca i32, align 4
  %d_x = alloca i32, align 4
  %d_y = alloca i32, align 4
  %selection = alloca %struct._GimpChannel*, align 8
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store %struct._GimpCoords* %coords, %struct._GimpCoords** %coords.addr, align 8
  store i32 %sample_merged, i32* %sample_merged.addr, align 4
  store i32 %selected_only, i32* %selected_only.addr, align 4
  store i32 0, i32* %in_pickable, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([37 x i8], [37 x i8]* @__func__.gimp_image_coords_in_active_pickable, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  store i32 0, i32* %retval
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpCoords*, %struct._GimpCoords** %coords.addr, align 8
  %x11 = getelementptr inbounds %struct._GimpCoords, %struct._GimpCoords* %13, i32 0, i32 0
  %14 = load double, double* %x11, align 8
  %call12 = call double @floor(double %14) #8
  %conv = fptosi double %call12 to i32
  store i32 %conv, i32* %x, align 4
  %15 = load %struct._GimpCoords*, %struct._GimpCoords** %coords.addr, align 8
  %y13 = getelementptr inbounds %struct._GimpCoords, %struct._GimpCoords* %15, i32 0, i32 1
  %16 = load double, double* %y13, align 8
  %call14 = call double @floor(double %16) #8
  %conv15 = fptosi double %call14 to i32
  store i32 %conv15, i32* %y, align 4
  %17 = load i32, i32* %sample_merged.addr, align 4
  %tobool16 = icmp ne i32 %17, 0
  br i1 %tobool16, label %if.then.17, label %if.else.33

if.then.17:                                       ; preds = %do.end
  %18 = load i32, i32* %x, align 4
  %cmp18 = icmp sge i32 %18, 0
  br i1 %cmp18, label %land.lhs.true.20, label %if.end.32

land.lhs.true.20:                                 ; preds = %if.then.17
  %19 = load i32, i32* %x, align 4
  %20 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call21 = call i32 @gimp_image_get_width(%struct._GimpImage* %20)
  %cmp22 = icmp slt i32 %19, %call21
  br i1 %cmp22, label %land.lhs.true.24, label %if.end.32

land.lhs.true.24:                                 ; preds = %land.lhs.true.20
  %21 = load i32, i32* %y, align 4
  %cmp25 = icmp sge i32 %21, 0
  br i1 %cmp25, label %land.lhs.true.27, label %if.end.32

land.lhs.true.27:                                 ; preds = %land.lhs.true.24
  %22 = load i32, i32* %y, align 4
  %23 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call28 = call i32 @gimp_image_get_height(%struct._GimpImage* %23)
  %cmp29 = icmp slt i32 %22, %call28
  br i1 %cmp29, label %if.then.31, label %if.end.32

if.then.31:                                       ; preds = %land.lhs.true.27
  store i32 1, i32* %in_pickable, align 4
  br label %if.end.32

if.end.32:                                        ; preds = %if.then.31, %land.lhs.true.27, %land.lhs.true.24, %land.lhs.true.20, %if.then.17
  br label %if.end.62

if.else.33:                                       ; preds = %do.end
  %24 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call35 = call %struct._GimpDrawable* @gimp_image_get_active_drawable(%struct._GimpImage* %24)
  store %struct._GimpDrawable* %call35, %struct._GimpDrawable** %drawable, align 8
  %25 = load %struct._GimpDrawable*, %struct._GimpDrawable** %drawable, align 8
  %tobool36 = icmp ne %struct._GimpDrawable* %25, null
  br i1 %tobool36, label %if.then.37, label %if.end.61

if.then.37:                                       ; preds = %if.else.33
  %26 = load %struct._GimpDrawable*, %struct._GimpDrawable** %drawable, align 8
  %27 = bitcast %struct._GimpDrawable* %26 to %struct._GTypeInstance*
  %call39 = call i64 @gimp_item_get_type() #8
  %call40 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %27, i64 %call39)
  %28 = bitcast %struct._GTypeInstance* %call40 to %struct._GimpItem*
  store %struct._GimpItem* %28, %struct._GimpItem** %item, align 8
  %29 = load %struct._GimpItem*, %struct._GimpItem** %item, align 8
  call void @gimp_item_get_offset(%struct._GimpItem* %29, i32* %off_x, i32* %off_y)
  %30 = load i32, i32* %x, align 4
  %31 = load i32, i32* %off_x, align 4
  %sub = sub nsw i32 %30, %31
  store i32 %sub, i32* %d_x, align 4
  %32 = load i32, i32* %y, align 4
  %33 = load i32, i32* %off_y, align 4
  %sub45 = sub nsw i32 %32, %33
  store i32 %sub45, i32* %d_y, align 4
  %34 = load i32, i32* %d_x, align 4
  %cmp46 = icmp sge i32 %34, 0
  br i1 %cmp46, label %land.lhs.true.48, label %if.end.60

land.lhs.true.48:                                 ; preds = %if.then.37
  %35 = load i32, i32* %d_x, align 4
  %36 = load %struct._GimpItem*, %struct._GimpItem** %item, align 8
  %call49 = call i32 @gimp_item_get_width(%struct._GimpItem* %36)
  %cmp50 = icmp slt i32 %35, %call49
  br i1 %cmp50, label %land.lhs.true.52, label %if.end.60

land.lhs.true.52:                                 ; preds = %land.lhs.true.48
  %37 = load i32, i32* %d_y, align 4
  %cmp53 = icmp sge i32 %37, 0
  br i1 %cmp53, label %land.lhs.true.55, label %if.end.60

land.lhs.true.55:                                 ; preds = %land.lhs.true.52
  %38 = load i32, i32* %d_y, align 4
  %39 = load %struct._GimpItem*, %struct._GimpItem** %item, align 8
  %call56 = call i32 @gimp_item_get_height(%struct._GimpItem* %39)
  %cmp57 = icmp slt i32 %38, %call56
  br i1 %cmp57, label %if.then.59, label %if.end.60

if.then.59:                                       ; preds = %land.lhs.true.55
  store i32 1, i32* %in_pickable, align 4
  br label %if.end.60

if.end.60:                                        ; preds = %if.then.59, %land.lhs.true.55, %land.lhs.true.52, %land.lhs.true.48, %if.then.37
  br label %if.end.61

if.end.61:                                        ; preds = %if.end.60, %if.else.33
  br label %if.end.62

if.end.62:                                        ; preds = %if.end.61, %if.end.32
  %40 = load i32, i32* %in_pickable, align 4
  %tobool63 = icmp ne i32 %40, 0
  br i1 %tobool63, label %land.lhs.true.64, label %if.end.78

land.lhs.true.64:                                 ; preds = %if.end.62
  %41 = load i32, i32* %selected_only.addr, align 4
  %tobool65 = icmp ne i32 %41, 0
  br i1 %tobool65, label %if.then.66, label %if.end.78

if.then.66:                                       ; preds = %land.lhs.true.64
  %42 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call68 = call %struct._GimpChannel* @gimp_image_get_mask(%struct._GimpImage* %42)
  store %struct._GimpChannel* %call68, %struct._GimpChannel** %selection, align 8
  %43 = load %struct._GimpChannel*, %struct._GimpChannel** %selection, align 8
  %call69 = call i32 @gimp_channel_is_empty(%struct._GimpChannel* %43)
  %tobool70 = icmp ne i32 %call69, 0
  br i1 %tobool70, label %if.end.77, label %land.lhs.true.71

land.lhs.true.71:                                 ; preds = %if.then.66
  %44 = load %struct._GimpChannel*, %struct._GimpChannel** %selection, align 8
  %45 = bitcast %struct._GimpChannel* %44 to %struct._GTypeInstance*
  %call72 = call i64 @gimp_pickable_interface_get_type() #8
  %call73 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %45, i64 %call72)
  %46 = bitcast %struct._GTypeInstance* %call73 to %struct._GimpPickable*
  %47 = load i32, i32* %x, align 4
  %48 = load i32, i32* %y, align 4
  %call74 = call i32 @gimp_pickable_get_opacity_at(%struct._GimpPickable* %46, i32 %47, i32 %48)
  %tobool75 = icmp ne i32 %call74, 0
  br i1 %tobool75, label %if.end.77, label %if.then.76

if.then.76:                                       ; preds = %land.lhs.true.71
  store i32 0, i32* %in_pickable, align 4
  br label %if.end.77

if.end.77:                                        ; preds = %if.then.76, %land.lhs.true.71, %if.then.66
  br label %if.end.78

if.end.78:                                        ; preds = %if.end.77, %land.lhs.true.64, %if.end.62
  %49 = load i32, i32* %in_pickable, align 4
  store i32 %49, i32* %retval
  br label %return

return:                                           ; preds = %if.end.78, %if.else.9
  %50 = load i32, i32* %retval
  ret i32 %50
}

; Function Attrs: nounwind readnone
declare double @floor(double) #2

declare i32 @gimp_channel_is_empty(%struct._GimpChannel*) #1

declare i32 @gimp_pickable_get_opacity_at(%struct._GimpPickable*, i32, i32) #1

; Function Attrs: nounwind readnone
declare i64 @gimp_pickable_interface_get_type() #2

; Function Attrs: nounwind uwtable
define void @gimp_image_invalidate_previews(%struct._GimpImage* %image) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %layers = alloca %struct._GimpItemStack*, align 8
  %channels = alloca %struct._GimpItemStack*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %1, %struct._GTypeInstance** %__inst, align 8
  %call = call i64 @gimp_image_get_type() #8
  store i64 %call, i64* %__t, align 8
  %2 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool = icmp ne %struct._GTypeInstance* %2, null
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.6

if.else:                                          ; preds = %do.body
  %3 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %3, i32 0, i32 0
  %4 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool1 = icmp ne %struct._GTypeClass* %4, null
  br i1 %tobool1, label %land.lhs.true, label %if.else.4

land.lhs.true:                                    ; preds = %if.else
  %5 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class2 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %5, i32 0, i32 0
  %6 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class2, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %6, i32 0, i32 0
  %7 = load i64, i64* %g_type, align 8
  %8 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %7, %8
  br i1 %cmp, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end

if.else.4:                                        ; preds = %land.lhs.true, %if.else
  %9 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %10 = load i64, i64* %__t, align 8
  %call5 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %9, i64 %10) #9
  store i32 %call5, i32* %__r, align 4
  br label %if.end

if.end:                                           ; preds = %if.else.4, %if.then.3
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %if.then
  %11 = load i32, i32* %__r, align 4
  store i32 %11, i32* %tmp
  %12 = load i32, i32* %tmp
  %tobool7 = icmp ne i32 %12, 0
  br i1 %tobool7, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.end.6
  br label %if.end.10

if.else.9:                                        ; preds = %if.end.6
  call void @g_return_if_fail_warning(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([31 x i8], [31 x i8]* @__func__.gimp_image_invalidate_previews, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.8, i32 0, i32 0))
  br label %return

if.end.10:                                        ; preds = %if.then.8
  br label %do.end

do.end:                                           ; preds = %if.end.10
  %13 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call11 = call %struct._GimpContainer* @gimp_image_get_layers(%struct._GimpImage* %13)
  %14 = bitcast %struct._GimpContainer* %call11 to %struct._GTypeInstance*
  %call12 = call i64 @gimp_item_stack_get_type() #8
  %call13 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %14, i64 %call12)
  %15 = bitcast %struct._GTypeInstance* %call13 to %struct._GimpItemStack*
  store %struct._GimpItemStack* %15, %struct._GimpItemStack** %layers, align 8
  %16 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call14 = call %struct._GimpContainer* @gimp_image_get_channels(%struct._GimpImage* %16)
  %17 = bitcast %struct._GimpContainer* %call14 to %struct._GTypeInstance*
  %call15 = call i64 @gimp_item_stack_get_type() #8
  %call16 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %17, i64 %call15)
  %18 = bitcast %struct._GTypeInstance* %call16 to %struct._GimpItemStack*
  store %struct._GimpItemStack* %18, %struct._GimpItemStack** %channels, align 8
  %19 = load %struct._GimpItemStack*, %struct._GimpItemStack** %layers, align 8
  call void @gimp_item_stack_invalidate_previews(%struct._GimpItemStack* %19)
  %20 = load %struct._GimpItemStack*, %struct._GimpItemStack** %channels, align 8
  call void @gimp_item_stack_invalidate_previews(%struct._GimpItemStack* %20)
  br label %return

return:                                           ; preds = %do.end, %if.else.9
  ret void
}

declare void @gimp_item_stack_invalidate_previews(%struct._GimpItemStack*) #1

declare i8* @g_type_class_peek_parent(i8*) #1

declare void @g_type_class_adjust_private_offset(i8*, i32*) #1

; Function Attrs: nounwind uwtable
define internal void @gimp_image_class_init(%struct._GimpImageClass* %klass) #3 {
entry:
  %klass.addr = alloca %struct._GimpImageClass*, align 8
  %object_class = alloca %struct._GObjectClass*, align 8
  %gimp_object_class = alloca %struct._GimpObjectClass*, align 8
  %viewable_class = alloca %struct._GimpViewableClass*, align 8
  store %struct._GimpImageClass* %klass, %struct._GimpImageClass** %klass.addr, align 8
  %0 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %1 = bitcast %struct._GimpImageClass* %0 to %struct._GTypeClass*
  %call = call %struct._GTypeClass* @g_type_check_class_cast(%struct._GTypeClass* %1, i64 80)
  %2 = bitcast %struct._GTypeClass* %call to %struct._GObjectClass*
  store %struct._GObjectClass* %2, %struct._GObjectClass** %object_class, align 8
  %3 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %4 = bitcast %struct._GimpImageClass* %3 to %struct._GTypeClass*
  %call1 = call i64 @gimp_object_get_type() #8
  %call2 = call %struct._GTypeClass* @g_type_check_class_cast(%struct._GTypeClass* %4, i64 %call1)
  %5 = bitcast %struct._GTypeClass* %call2 to %struct._GimpObjectClass*
  store %struct._GimpObjectClass* %5, %struct._GimpObjectClass** %gimp_object_class, align 8
  %6 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %7 = bitcast %struct._GimpImageClass* %6 to %struct._GTypeClass*
  %call3 = call i64 @gimp_viewable_get_type() #8
  %call4 = call %struct._GTypeClass* @g_type_check_class_cast(%struct._GTypeClass* %7, i64 %call3)
  %8 = bitcast %struct._GTypeClass* %call4 to %struct._GimpViewableClass*
  store %struct._GimpViewableClass* %8, %struct._GimpViewableClass** %viewable_class, align 8
  %9 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %10 = bitcast %struct._GimpImageClass* %9 to %struct._GTypeClass*
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %10, i32 0, i32 0
  %11 = load i64, i64* %g_type, align 8
  %call5 = call i32 (i8*, i64, i32, i32, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)*, i8*, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)*, i64, i32, ...) @g_signal_new(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.74, i32 0, i32 0), i64 %11, i32 1, i32 280, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)* null, i8* null, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)* @g_cclosure_marshal_VOID__VOID, i64 4, i32 0)
  store i32 %call5, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 0), align 4
  %12 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %13 = bitcast %struct._GimpImageClass* %12 to %struct._GTypeClass*
  %g_type6 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %13, i32 0, i32 0
  %14 = load i64, i64* %g_type6, align 8
  %call7 = call i32 (i8*, i64, i32, i32, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)*, i8*, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)*, i64, i32, ...) @g_signal_new(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.75, i32 0, i32 0), i64 %14, i32 1, i32 288, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)* null, i8* null, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)* @g_cclosure_marshal_VOID__VOID, i64 4, i32 0)
  store i32 %call7, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 1), align 4
  %15 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %16 = bitcast %struct._GimpImageClass* %15 to %struct._GTypeClass*
  %g_type8 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %16, i32 0, i32 0
  %17 = load i64, i64* %g_type8, align 8
  %call9 = call i32 (i8*, i64, i32, i32, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)*, i8*, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)*, i64, i32, ...) @g_signal_new(i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.76, i32 0, i32 0), i64 %17, i32 1, i32 296, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)* null, i8* null, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)* @g_cclosure_marshal_VOID__VOID, i64 4, i32 0)
  store i32 %call9, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 2), align 4
  %18 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %19 = bitcast %struct._GimpImageClass* %18 to %struct._GTypeClass*
  %g_type10 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %19, i32 0, i32 0
  %20 = load i64, i64* %g_type10, align 8
  %call11 = call i32 (i8*, i64, i32, i32, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)*, i8*, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)*, i64, i32, ...) @g_signal_new(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.77, i32 0, i32 0), i64 %20, i32 1, i32 304, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)* null, i8* null, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)* @g_cclosure_marshal_VOID__VOID, i64 4, i32 0)
  store i32 %call11, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 3), align 4
  %21 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %22 = bitcast %struct._GimpImageClass* %21 to %struct._GTypeClass*
  %g_type12 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %22, i32 0, i32 0
  %23 = load i64, i64* %g_type12, align 8
  %call13 = call i32 (i8*, i64, i32, i32, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)*, i8*, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)*, i64, i32, ...) @g_signal_new(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.78, i32 0, i32 0), i64 %23, i32 1, i32 312, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)* null, i8* null, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)* @g_cclosure_marshal_VOID__VOID, i64 4, i32 0)
  store i32 %call13, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 4), align 4
  %24 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %25 = bitcast %struct._GimpImageClass* %24 to %struct._GTypeClass*
  %g_type14 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %25, i32 0, i32 0
  %26 = load i64, i64* %g_type14, align 8
  %call15 = call i32 (i8*, i64, i32, i32, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)*, i8*, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)*, i64, i32, ...) @g_signal_new(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.79, i32 0, i32 0), i64 %26, i32 1, i32 320, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)* null, i8* null, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)* @g_cclosure_marshal_VOID__VOID, i64 4, i32 0)
  store i32 %call15, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 5), align 4
  %27 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %28 = bitcast %struct._GimpImageClass* %27 to %struct._GTypeClass*
  %g_type16 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %28, i32 0, i32 0
  %29 = load i64, i64* %g_type16, align 8
  %call17 = call i64 @gimp_channel_type_get_type() #8
  %call18 = call i32 (i8*, i64, i32, i32, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)*, i8*, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)*, i64, i32, ...) @g_signal_new(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.80, i32 0, i32 0), i64 %29, i32 1, i32 328, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)* null, i8* null, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)* @g_cclosure_marshal_VOID__ENUM, i64 4, i32 1, i64 %call17)
  store i32 %call18, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 6), align 4
  %30 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %31 = bitcast %struct._GimpImageClass* %30 to %struct._GTypeClass*
  %g_type19 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %31, i32 0, i32 0
  %32 = load i64, i64* %g_type19, align 8
  %call20 = call i64 @gimp_channel_type_get_type() #8
  %call21 = call i32 (i8*, i64, i32, i32, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)*, i8*, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)*, i64, i32, ...) @g_signal_new(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.81, i32 0, i32 0), i64 %32, i32 1, i32 336, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)* null, i8* null, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)* @g_cclosure_marshal_VOID__ENUM, i64 4, i32 1, i64 %call20)
  store i32 %call21, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 7), align 4
  %33 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %34 = bitcast %struct._GimpImageClass* %33 to %struct._GTypeClass*
  %g_type22 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %34, i32 0, i32 0
  %35 = load i64, i64* %g_type22, align 8
  %call23 = call i32 (i8*, i64, i32, i32, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)*, i8*, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)*, i64, i32, ...) @g_signal_new(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.82, i32 0, i32 0), i64 %35, i32 1, i32 344, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)* null, i8* null, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)* @g_cclosure_marshal_VOID__VOID, i64 4, i32 0)
  store i32 %call23, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 8), align 4
  %36 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %37 = bitcast %struct._GimpImageClass* %36 to %struct._GTypeClass*
  %g_type24 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %37, i32 0, i32 0
  %38 = load i64, i64* %g_type24, align 8
  %call25 = call i32 (i8*, i64, i32, i32, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)*, i8*, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)*, i64, i32, ...) @g_signal_new(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.83, i32 0, i32 0), i64 %38, i32 1, i32 352, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)* null, i8* null, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)* @g_cclosure_marshal_VOID__VOID, i64 4, i32 0)
  store i32 %call25, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 9), align 4
  %39 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %40 = bitcast %struct._GimpImageClass* %39 to %struct._GTypeClass*
  %g_type26 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %40, i32 0, i32 0
  %41 = load i64, i64* %g_type26, align 8
  %call27 = call i32 (i8*, i64, i32, i32, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)*, i8*, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)*, i64, i32, ...) @g_signal_new(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.84, i32 0, i32 0), i64 %41, i32 1, i32 360, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)* null, i8* null, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)* @gimp_marshal_VOID__INT_INT_INT_INT, i64 4, i32 4, i64 24, i64 24, i64 24, i64 24)
  store i32 %call27, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 10), align 4
  %42 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %43 = bitcast %struct._GimpImageClass* %42 to %struct._GTypeClass*
  %g_type28 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %43, i32 0, i32 0
  %44 = load i64, i64* %g_type28, align 8
  %call29 = call i32 (i8*, i64, i32, i32, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)*, i8*, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)*, i64, i32, ...) @g_signal_new(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.85, i32 0, i32 0), i64 %44, i32 1, i32 368, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)* null, i8* null, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)* @g_cclosure_marshal_VOID__VOID, i64 4, i32 0)
  store i32 %call29, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 11), align 4
  %45 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %46 = bitcast %struct._GimpImageClass* %45 to %struct._GTypeClass*
  %g_type30 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %46, i32 0, i32 0
  %47 = load i64, i64* %g_type30, align 8
  %call31 = call i32 (i8*, i64, i32, i32, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)*, i8*, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)*, i64, i32, ...) @g_signal_new(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.86, i32 0, i32 0), i64 %47, i32 1, i32 376, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)* null, i8* null, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)* @g_cclosure_marshal_VOID__VOID, i64 4, i32 0)
  store i32 %call31, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 12), align 4
  %48 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %49 = bitcast %struct._GimpImageClass* %48 to %struct._GTypeClass*
  %g_type32 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %49, i32 0, i32 0
  %50 = load i64, i64* %g_type32, align 8
  %call33 = call i32 (i8*, i64, i32, i32, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)*, i8*, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)*, i64, i32, ...) @g_signal_new(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.87, i32 0, i32 0), i64 %50, i32 1, i32 384, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)* null, i8* null, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)* @g_cclosure_marshal_VOID__VOID, i64 4, i32 0)
  store i32 %call33, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 13), align 4
  %51 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %52 = bitcast %struct._GimpImageClass* %51 to %struct._GTypeClass*
  %g_type34 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %52, i32 0, i32 0
  %53 = load i64, i64* %g_type34, align 8
  %call35 = call i64 @gimp_dirty_mask_get_type() #8
  %call36 = call i32 (i8*, i64, i32, i32, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)*, i8*, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)*, i64, i32, ...) @g_signal_new(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.88, i32 0, i32 0), i64 %53, i32 1, i32 392, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)* null, i8* null, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)* @g_cclosure_marshal_VOID__FLAGS, i64 4, i32 1, i64 %call35)
  store i32 %call36, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 14), align 4
  %54 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %55 = bitcast %struct._GimpImageClass* %54 to %struct._GTypeClass*
  %g_type37 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %55, i32 0, i32 0
  %56 = load i64, i64* %g_type37, align 8
  %call38 = call i64 @gimp_dirty_mask_get_type() #8
  %call39 = call i32 (i8*, i64, i32, i32, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)*, i8*, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)*, i64, i32, ...) @g_signal_new(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.89, i32 0, i32 0), i64 %56, i32 1, i32 400, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)* null, i8* null, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)* @g_cclosure_marshal_VOID__FLAGS, i64 4, i32 1, i64 %call38)
  store i32 %call39, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 15), align 4
  %57 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %58 = bitcast %struct._GimpImageClass* %57 to %struct._GTypeClass*
  %g_type40 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %58, i32 0, i32 0
  %59 = load i64, i64* %g_type40, align 8
  %call41 = call i32 (i8*, i64, i32, i32, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)*, i8*, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)*, i64, i32, ...) @g_signal_new(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.90, i32 0, i32 0), i64 %59, i32 1, i32 408, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)* null, i8* null, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)* @g_cclosure_marshal_VOID__STRING, i64 4, i32 1, i64 64)
  store i32 %call41, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 16), align 4
  %60 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %61 = bitcast %struct._GimpImageClass* %60 to %struct._GTypeClass*
  %g_type42 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %61, i32 0, i32 0
  %62 = load i64, i64* %g_type42, align 8
  %call43 = call i32 (i8*, i64, i32, i32, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)*, i8*, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)*, i64, i32, ...) @g_signal_new(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.91, i32 0, i32 0), i64 %62, i32 1, i32 416, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)* null, i8* null, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)* @g_cclosure_marshal_VOID__STRING, i64 4, i32 1, i64 64)
  store i32 %call43, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 17), align 4
  %63 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %64 = bitcast %struct._GimpImageClass* %63 to %struct._GTypeClass*
  %g_type44 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %64, i32 0, i32 0
  %65 = load i64, i64* %g_type44, align 8
  %call45 = call i64 @gimp_guide_get_type() #8
  %call46 = call i32 (i8*, i64, i32, i32, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)*, i8*, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)*, i64, i32, ...) @g_signal_new(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.92, i32 0, i32 0), i64 %65, i32 1, i32 424, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)* null, i8* null, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)* @g_cclosure_marshal_VOID__OBJECT, i64 4, i32 1, i64 %call45)
  store i32 %call46, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 18), align 4
  %66 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %67 = bitcast %struct._GimpImageClass* %66 to %struct._GTypeClass*
  %g_type47 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %67, i32 0, i32 0
  %68 = load i64, i64* %g_type47, align 8
  %call48 = call i64 @gimp_guide_get_type() #8
  %call49 = call i32 (i8*, i64, i32, i32, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)*, i8*, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)*, i64, i32, ...) @g_signal_new(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.93, i32 0, i32 0), i64 %68, i32 1, i32 432, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)* null, i8* null, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)* @g_cclosure_marshal_VOID__OBJECT, i64 4, i32 1, i64 %call48)
  store i32 %call49, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 19), align 4
  %69 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %70 = bitcast %struct._GimpImageClass* %69 to %struct._GTypeClass*
  %g_type50 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %70, i32 0, i32 0
  %71 = load i64, i64* %g_type50, align 8
  %call51 = call i64 @gimp_guide_get_type() #8
  %call52 = call i32 (i8*, i64, i32, i32, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)*, i8*, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)*, i64, i32, ...) @g_signal_new(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.94, i32 0, i32 0), i64 %71, i32 1, i32 440, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)* null, i8* null, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)* @g_cclosure_marshal_VOID__OBJECT, i64 4, i32 1, i64 %call51)
  store i32 %call52, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 20), align 4
  %72 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %73 = bitcast %struct._GimpImageClass* %72 to %struct._GTypeClass*
  %g_type53 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %73, i32 0, i32 0
  %74 = load i64, i64* %g_type53, align 8
  %call54 = call i32 (i8*, i64, i32, i32, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)*, i8*, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)*, i64, i32, ...) @g_signal_new(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.95, i32 0, i32 0), i64 %74, i32 1, i32 448, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)* null, i8* null, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)* @g_cclosure_marshal_VOID__POINTER, i64 4, i32 1, i64 68)
  store i32 %call54, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 21), align 4
  %75 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %76 = bitcast %struct._GimpImageClass* %75 to %struct._GTypeClass*
  %g_type55 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %76, i32 0, i32 0
  %77 = load i64, i64* %g_type55, align 8
  %call56 = call i32 (i8*, i64, i32, i32, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)*, i8*, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)*, i64, i32, ...) @g_signal_new(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.96, i32 0, i32 0), i64 %77, i32 1, i32 456, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)* null, i8* null, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)* @g_cclosure_marshal_VOID__POINTER, i64 4, i32 1, i64 68)
  store i32 %call56, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 22), align 4
  %78 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %79 = bitcast %struct._GimpImageClass* %78 to %struct._GTypeClass*
  %g_type57 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %79, i32 0, i32 0
  %80 = load i64, i64* %g_type57, align 8
  %call58 = call i32 (i8*, i64, i32, i32, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)*, i8*, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)*, i64, i32, ...) @g_signal_new(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.97, i32 0, i32 0), i64 %80, i32 1, i32 464, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)* null, i8* null, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)* @g_cclosure_marshal_VOID__POINTER, i64 4, i32 1, i64 68)
  store i32 %call58, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 23), align 4
  %81 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %82 = bitcast %struct._GimpImageClass* %81 to %struct._GTypeClass*
  %g_type59 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %82, i32 0, i32 0
  %83 = load i64, i64* %g_type59, align 8
  %call60 = call i32 (i8*, i64, i32, i32, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)*, i8*, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)*, i64, i32, ...) @g_signal_new(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.98, i32 0, i32 0), i64 %83, i32 1, i32 472, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)* null, i8* null, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)* @g_cclosure_marshal_VOID__STRING, i64 4, i32 1, i64 64)
  store i32 %call60, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 24), align 4
  %84 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %85 = bitcast %struct._GimpImageClass* %84 to %struct._GTypeClass*
  %g_type61 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %85, i32 0, i32 0
  %86 = load i64, i64* %g_type61, align 8
  %call62 = call i32 (i8*, i64, i32, i32, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)*, i8*, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)*, i64, i32, ...) @g_signal_new(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.99, i32 0, i32 0), i64 %86, i32 1, i32 480, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)* null, i8* null, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)* @g_cclosure_marshal_VOID__STRING, i64 4, i32 1, i64 64)
  store i32 %call62, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 25), align 4
  %87 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %88 = bitcast %struct._GimpImageClass* %87 to %struct._GTypeClass*
  %g_type63 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %88, i32 0, i32 0
  %89 = load i64, i64* %g_type63, align 8
  %call64 = call i32 (i8*, i64, i32, i32, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)*, i8*, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)*, i64, i32, ...) @g_signal_new(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.100, i32 0, i32 0), i64 %89, i32 1, i32 488, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)* null, i8* null, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)* @g_cclosure_marshal_VOID__INT, i64 4, i32 1, i64 24)
  store i32 %call64, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 26), align 4
  %90 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %91 = bitcast %struct._GimpImageClass* %90 to %struct._GTypeClass*
  %g_type65 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %91, i32 0, i32 0
  %92 = load i64, i64* %g_type65, align 8
  %call66 = call i64 @gimp_undo_event_get_type() #8
  %call67 = call i64 @gimp_undo_get_type() #8
  %call68 = call i32 (i8*, i64, i32, i32, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)*, i8*, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)*, i64, i32, ...) @g_signal_new(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.101, i32 0, i32 0), i64 %92, i32 1, i32 496, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)* null, i8* null, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)* @gimp_marshal_VOID__ENUM_OBJECT, i64 4, i32 2, i64 %call66, i64 %call67)
  store i32 %call68, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 27), align 4
  %93 = load %struct._GObjectClass*, %struct._GObjectClass** %object_class, align 8
  %constructed = getelementptr inbounds %struct._GObjectClass, %struct._GObjectClass* %93, i32 0, i32 9
  store void (%struct._GObject*)* @gimp_image_constructed, void (%struct._GObject*)** %constructed, align 8
  %94 = load %struct._GObjectClass*, %struct._GObjectClass** %object_class, align 8
  %set_property = getelementptr inbounds %struct._GObjectClass, %struct._GObjectClass* %94, i32 0, i32 3
  store void (%struct._GObject*, i32, %struct._GValue*, %struct._GParamSpec*)* @gimp_image_set_property, void (%struct._GObject*, i32, %struct._GValue*, %struct._GParamSpec*)** %set_property, align 8
  %95 = load %struct._GObjectClass*, %struct._GObjectClass** %object_class, align 8
  %get_property = getelementptr inbounds %struct._GObjectClass, %struct._GObjectClass* %95, i32 0, i32 4
  store void (%struct._GObject*, i32, %struct._GValue*, %struct._GParamSpec*)* @gimp_image_get_property, void (%struct._GObject*, i32, %struct._GValue*, %struct._GParamSpec*)** %get_property, align 8
  %96 = load %struct._GObjectClass*, %struct._GObjectClass** %object_class, align 8
  %dispose = getelementptr inbounds %struct._GObjectClass, %struct._GObjectClass* %96, i32 0, i32 5
  store void (%struct._GObject*)* @gimp_image_dispose, void (%struct._GObject*)** %dispose, align 8
  %97 = load %struct._GObjectClass*, %struct._GObjectClass** %object_class, align 8
  %finalize = getelementptr inbounds %struct._GObjectClass, %struct._GObjectClass* %97, i32 0, i32 6
  store void (%struct._GObject*)* @gimp_image_finalize, void (%struct._GObject*)** %finalize, align 8
  %98 = load %struct._GimpObjectClass*, %struct._GimpObjectClass** %gimp_object_class, align 8
  %name_changed = getelementptr inbounds %struct._GimpObjectClass, %struct._GimpObjectClass* %98, i32 0, i32 2
  store void (%struct._GimpObject*)* @gimp_image_name_changed, void (%struct._GimpObject*)** %name_changed, align 8
  %99 = load %struct._GimpObjectClass*, %struct._GimpObjectClass** %gimp_object_class, align 8
  %get_memsize = getelementptr inbounds %struct._GimpObjectClass, %struct._GimpObjectClass* %99, i32 0, i32 3
  store i64 (%struct._GimpObject*, i64*)* @gimp_image_get_memsize, i64 (%struct._GimpObject*, i64*)** %get_memsize, align 8
  %100 = load %struct._GimpViewableClass*, %struct._GimpViewableClass** %viewable_class, align 8
  %default_stock_id = getelementptr inbounds %struct._GimpViewableClass, %struct._GimpViewableClass* %100, i32 0, i32 1
  store i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.102, i32 0, i32 0), i8** %default_stock_id, align 8
  %101 = load %struct._GimpViewableClass*, %struct._GimpViewableClass** %viewable_class, align 8
  %get_size = getelementptr inbounds %struct._GimpViewableClass, %struct._GimpViewableClass* %101, i32 0, i32 5
  store i32 (%struct._GimpViewable*, i32*, i32*)* @gimp_image_get_size, i32 (%struct._GimpViewable*, i32*, i32*)** %get_size, align 8
  %102 = load %struct._GimpViewableClass*, %struct._GimpViewableClass** %viewable_class, align 8
  %invalidate_preview = getelementptr inbounds %struct._GimpViewableClass, %struct._GimpViewableClass* %102, i32 0, i32 3
  store void (%struct._GimpViewable*)* @gimp_image_invalidate_preview, void (%struct._GimpViewable*)** %invalidate_preview, align 8
  %103 = load %struct._GimpViewableClass*, %struct._GimpViewableClass** %viewable_class, align 8
  %size_changed = getelementptr inbounds %struct._GimpViewableClass, %struct._GimpViewableClass* %103, i32 0, i32 4
  store void (%struct._GimpViewable*)* @gimp_image_size_changed, void (%struct._GimpViewable*)** %size_changed, align 8
  %104 = load %struct._GimpViewableClass*, %struct._GimpViewableClass** %viewable_class, align 8
  %get_preview_size = getelementptr inbounds %struct._GimpViewableClass, %struct._GimpViewableClass* %104, i32 0, i32 6
  store void (%struct._GimpViewable*, i32, i32, i32, i32*, i32*)* @gimp_image_get_preview_size, void (%struct._GimpViewable*, i32, i32, i32, i32*, i32*)** %get_preview_size, align 8
  %105 = load %struct._GimpViewableClass*, %struct._GimpViewableClass** %viewable_class, align 8
  %get_popup_size = getelementptr inbounds %struct._GimpViewableClass, %struct._GimpViewableClass* %105, i32 0, i32 7
  store i32 (%struct._GimpViewable*, i32, i32, i32, i32*, i32*)* @gimp_image_get_popup_size, i32 (%struct._GimpViewable*, i32, i32, i32, i32*, i32*)** %get_popup_size, align 8
  %106 = load %struct._GimpViewableClass*, %struct._GimpViewableClass** %viewable_class, align 8
  %get_preview = getelementptr inbounds %struct._GimpViewableClass, %struct._GimpViewableClass* %106, i32 0, i32 8
  store %struct._TempBuf* (%struct._GimpViewable*, %struct._GimpContext*, i32, i32)* @gimp_image_get_preview, %struct._TempBuf* (%struct._GimpViewable*, %struct._GimpContext*, i32, i32)** %get_preview, align 8
  %107 = load %struct._GimpViewableClass*, %struct._GimpViewableClass** %viewable_class, align 8
  %get_new_preview = getelementptr inbounds %struct._GimpViewableClass, %struct._GimpViewableClass* %107, i32 0, i32 9
  store %struct._TempBuf* (%struct._GimpViewable*, %struct._GimpContext*, i32, i32)* @gimp_image_get_new_preview, %struct._TempBuf* (%struct._GimpViewable*, %struct._GimpContext*, i32, i32)** %get_new_preview, align 8
  %108 = load %struct._GimpViewableClass*, %struct._GimpViewableClass** %viewable_class, align 8
  %get_description = getelementptr inbounds %struct._GimpViewableClass, %struct._GimpViewableClass* %108, i32 0, i32 12
  store i8* (%struct._GimpViewable*, i8**)* @gimp_image_get_description, i8* (%struct._GimpViewable*, i8**)** %get_description, align 8
  %109 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %mode_changed = getelementptr inbounds %struct._GimpImageClass, %struct._GimpImageClass* %109, i32 0, i32 1
  store void (%struct._GimpImage*)* @gimp_image_real_mode_changed, void (%struct._GimpImage*)** %mode_changed, align 8
  %110 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %alpha_changed = getelementptr inbounds %struct._GimpImageClass, %struct._GimpImageClass* %110, i32 0, i32 2
  store void (%struct._GimpImage*)* null, void (%struct._GimpImage*)** %alpha_changed, align 8
  %111 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %floating_selection_changed = getelementptr inbounds %struct._GimpImageClass, %struct._GimpImageClass* %111, i32 0, i32 3
  store void (%struct._GimpImage*)* null, void (%struct._GimpImage*)** %floating_selection_changed, align 8
  %112 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %active_layer_changed = getelementptr inbounds %struct._GimpImageClass, %struct._GimpImageClass* %112, i32 0, i32 4
  store void (%struct._GimpImage*)* null, void (%struct._GimpImage*)** %active_layer_changed, align 8
  %113 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %active_channel_changed = getelementptr inbounds %struct._GimpImageClass, %struct._GimpImageClass* %113, i32 0, i32 5
  store void (%struct._GimpImage*)* null, void (%struct._GimpImage*)** %active_channel_changed, align 8
  %114 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %active_vectors_changed = getelementptr inbounds %struct._GimpImageClass, %struct._GimpImageClass* %114, i32 0, i32 6
  store void (%struct._GimpImage*)* null, void (%struct._GimpImage*)** %active_vectors_changed, align 8
  %115 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %component_visibility_changed = getelementptr inbounds %struct._GimpImageClass, %struct._GimpImageClass* %115, i32 0, i32 7
  store void (%struct._GimpImage*, i32)* null, void (%struct._GimpImage*, i32)** %component_visibility_changed, align 8
  %116 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %component_active_changed = getelementptr inbounds %struct._GimpImageClass, %struct._GimpImageClass* %116, i32 0, i32 8
  store void (%struct._GimpImage*, i32)* null, void (%struct._GimpImage*, i32)** %component_active_changed, align 8
  %117 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %mask_changed = getelementptr inbounds %struct._GimpImageClass, %struct._GimpImageClass* %117, i32 0, i32 9
  store void (%struct._GimpImage*)* null, void (%struct._GimpImage*)** %mask_changed, align 8
  %118 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %resolution_changed = getelementptr inbounds %struct._GimpImageClass, %struct._GimpImageClass* %118, i32 0, i32 10
  store void (%struct._GimpImage*)* null, void (%struct._GimpImage*)** %resolution_changed, align 8
  %119 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %size_changed_detailed = getelementptr inbounds %struct._GimpImageClass, %struct._GimpImageClass* %119, i32 0, i32 11
  store void (%struct._GimpImage*, i32, i32, i32, i32)* @gimp_image_real_size_changed_detailed, void (%struct._GimpImage*, i32, i32, i32, i32)** %size_changed_detailed, align 8
  %120 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %unit_changed = getelementptr inbounds %struct._GimpImageClass, %struct._GimpImageClass* %120, i32 0, i32 12
  store void (%struct._GimpImage*)* null, void (%struct._GimpImage*)** %unit_changed, align 8
  %121 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %quick_mask_changed = getelementptr inbounds %struct._GimpImageClass, %struct._GimpImageClass* %121, i32 0, i32 13
  store void (%struct._GimpImage*)* null, void (%struct._GimpImage*)** %quick_mask_changed, align 8
  %122 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %selection_invalidate = getelementptr inbounds %struct._GimpImageClass, %struct._GimpImageClass* %122, i32 0, i32 14
  store void (%struct._GimpImage*)* null, void (%struct._GimpImage*)** %selection_invalidate, align 8
  %123 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %clean = getelementptr inbounds %struct._GimpImageClass, %struct._GimpImageClass* %123, i32 0, i32 15
  store void (%struct._GimpImage*, i32)* null, void (%struct._GimpImage*, i32)** %clean, align 8
  %124 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %dirty = getelementptr inbounds %struct._GimpImageClass, %struct._GimpImageClass* %124, i32 0, i32 16
  store void (%struct._GimpImage*, i32)* null, void (%struct._GimpImage*, i32)** %dirty, align 8
  %125 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %saved = getelementptr inbounds %struct._GimpImageClass, %struct._GimpImageClass* %125, i32 0, i32 17
  store void (%struct._GimpImage*, i8*)* null, void (%struct._GimpImage*, i8*)** %saved, align 8
  %126 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %exported = getelementptr inbounds %struct._GimpImageClass, %struct._GimpImageClass* %126, i32 0, i32 18
  store void (%struct._GimpImage*, i8*)* null, void (%struct._GimpImage*, i8*)** %exported, align 8
  %127 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %guide_added = getelementptr inbounds %struct._GimpImageClass, %struct._GimpImageClass* %127, i32 0, i32 19
  store void (%struct._GimpImage*, %struct._GimpGuide*)* null, void (%struct._GimpImage*, %struct._GimpGuide*)** %guide_added, align 8
  %128 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %guide_removed = getelementptr inbounds %struct._GimpImageClass, %struct._GimpImageClass* %128, i32 0, i32 20
  store void (%struct._GimpImage*, %struct._GimpGuide*)* null, void (%struct._GimpImage*, %struct._GimpGuide*)** %guide_removed, align 8
  %129 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %guide_moved = getelementptr inbounds %struct._GimpImageClass, %struct._GimpImageClass* %129, i32 0, i32 21
  store void (%struct._GimpImage*, %struct._GimpGuide*)* null, void (%struct._GimpImage*, %struct._GimpGuide*)** %guide_moved, align 8
  %130 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %sample_point_added = getelementptr inbounds %struct._GimpImageClass, %struct._GimpImageClass* %130, i32 0, i32 22
  store void (%struct._GimpImage*, %struct._GimpSamplePoint*)* null, void (%struct._GimpImage*, %struct._GimpSamplePoint*)** %sample_point_added, align 8
  %131 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %sample_point_removed = getelementptr inbounds %struct._GimpImageClass, %struct._GimpImageClass* %131, i32 0, i32 23
  store void (%struct._GimpImage*, %struct._GimpSamplePoint*)* null, void (%struct._GimpImage*, %struct._GimpSamplePoint*)** %sample_point_removed, align 8
  %132 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %sample_point_moved = getelementptr inbounds %struct._GimpImageClass, %struct._GimpImageClass* %132, i32 0, i32 24
  store void (%struct._GimpImage*, %struct._GimpSamplePoint*)* null, void (%struct._GimpImage*, %struct._GimpSamplePoint*)** %sample_point_moved, align 8
  %133 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %parasite_attached = getelementptr inbounds %struct._GimpImageClass, %struct._GimpImageClass* %133, i32 0, i32 25
  store void (%struct._GimpImage*, i8*)* null, void (%struct._GimpImage*, i8*)** %parasite_attached, align 8
  %134 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %parasite_detached = getelementptr inbounds %struct._GimpImageClass, %struct._GimpImageClass* %134, i32 0, i32 26
  store void (%struct._GimpImage*, i8*)* null, void (%struct._GimpImage*, i8*)** %parasite_detached, align 8
  %135 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %colormap_changed = getelementptr inbounds %struct._GimpImageClass, %struct._GimpImageClass* %135, i32 0, i32 27
  store void (%struct._GimpImage*, i32)* @gimp_image_real_colormap_changed, void (%struct._GimpImage*, i32)** %colormap_changed, align 8
  %136 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %undo_event = getelementptr inbounds %struct._GimpImageClass, %struct._GimpImageClass* %136, i32 0, i32 28
  store void (%struct._GimpImage*, i32, %struct._GimpUndo*)* null, void (%struct._GimpImage*, i32, %struct._GimpUndo*)** %undo_event, align 8
  %137 = load %struct._GObjectClass*, %struct._GObjectClass** %object_class, align 8
  %call69 = call i64 @gimp_get_type() #8
  %call70 = call %struct._GParamSpec* @g_param_spec_object(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0), i8* null, i8* null, i64 %call69, i32 235)
  call void @g_object_class_install_property(%struct._GObjectClass* %137, i32 1, %struct._GParamSpec* %call70)
  %138 = load %struct._GObjectClass*, %struct._GObjectClass** %object_class, align 8
  %call71 = call %struct._GParamSpec* @g_param_spec_int(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.103, i32 0, i32 0), i8* null, i8* null, i32 0, i32 2147483647, i32 0, i32 225)
  call void @g_object_class_install_property(%struct._GObjectClass* %138, i32 2, %struct._GParamSpec* %call71)
  %139 = load %struct._GObjectClass*, %struct._GObjectClass** %object_class, align 8
  %call72 = call %struct._GParamSpec* @g_param_spec_int(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.5, i32 0, i32 0), i8* null, i8* null, i32 1, i32 262144, i32 1, i32 231)
  call void @g_object_class_install_property(%struct._GObjectClass* %139, i32 3, %struct._GParamSpec* %call72)
  %140 = load %struct._GObjectClass*, %struct._GObjectClass** %object_class, align 8
  %call73 = call %struct._GParamSpec* @g_param_spec_int(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.6, i32 0, i32 0), i8* null, i8* null, i32 1, i32 262144, i32 1, i32 231)
  call void @g_object_class_install_property(%struct._GObjectClass* %140, i32 4, %struct._GParamSpec* %call73)
  %141 = load %struct._GObjectClass*, %struct._GObjectClass** %object_class, align 8
  %call74 = call i64 @gimp_image_base_type_get_type() #8
  %call75 = call %struct._GParamSpec* @g_param_spec_enum(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.7, i32 0, i32 0), i8* null, i8* null, i64 %call74, i32 0, i32 231)
  call void @g_object_class_install_property(%struct._GObjectClass* %141, i32 5, %struct._GParamSpec* %call75)
  call void @gimp_image_color_hash_init()
  %142 = load %struct._GimpImageClass*, %struct._GimpImageClass** %klass.addr, align 8
  %143 = bitcast %struct._GimpImageClass* %142 to i8*
  call void @g_type_class_add_private(i8* %143, i64 368)
  ret void
}

declare %struct._GTypeClass* @g_type_check_class_cast(%struct._GTypeClass*, i64) #1

declare i32 @g_signal_new(i8*, i64, i32, i32, i32 (%struct._GSignalInvocationHint*, %struct._GValue*, %struct._GValue*, i8*)*, i8*, void (%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*)*, i64, i32, ...) #1

declare void @g_cclosure_marshal_VOID__VOID(%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*) #1

declare void @g_cclosure_marshal_VOID__ENUM(%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*) #1

; Function Attrs: nounwind readnone
declare i64 @gimp_channel_type_get_type() #2

declare void @gimp_marshal_VOID__INT_INT_INT_INT(%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*) #1

declare void @g_cclosure_marshal_VOID__FLAGS(%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*) #1

; Function Attrs: nounwind readnone
declare i64 @gimp_dirty_mask_get_type() #2

declare void @g_cclosure_marshal_VOID__STRING(%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*) #1

declare void @g_cclosure_marshal_VOID__OBJECT(%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*) #1

declare void @g_cclosure_marshal_VOID__POINTER(%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*) #1

declare void @g_cclosure_marshal_VOID__INT(%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*) #1

declare void @gimp_marshal_VOID__ENUM_OBJECT(%struct._GClosure*, %struct._GValue*, i32, %struct._GValue*, i8*, i8*) #1

; Function Attrs: nounwind readnone
declare i64 @gimp_undo_event_get_type() #2

; Function Attrs: nounwind uwtable
define internal void @gimp_image_constructed(%struct._GObject* %object) #3 {
entry:
  %object.addr = alloca %struct._GObject*, align 8
  %image = alloca %struct._GimpImage*, align 8
  %private = alloca %struct._GimpImagePrivate*, align 8
  %selection = alloca %struct._GimpChannel*, align 8
  %config = alloca %struct._GimpCoreConfig*, align 8
  %template = alloca %struct._GimpTemplate*, align 8
  %__inst = alloca %struct._GTypeInstance*, align 8
  %__t = alloca i64, align 8
  %__r = alloca i32, align 4
  %tmp = alloca i32, align 4
  store %struct._GObject* %object, %struct._GObject** %object.addr, align 8
  %0 = load %struct._GObject*, %struct._GObject** %object.addr, align 8
  %1 = bitcast %struct._GObject* %0 to %struct._GTypeInstance*
  %call = call i64 @gimp_image_get_type() #8
  %call1 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %1, i64 %call)
  %2 = bitcast %struct._GTypeInstance* %call1 to %struct._GimpImage*
  store %struct._GimpImage* %2, %struct._GimpImage** %image, align 8
  %3 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  %4 = bitcast %struct._GimpImage* %3 to %struct._GTypeInstance*
  %call2 = call i64 @gimp_image_get_type() #8
  %call3 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %4, i64 %call2)
  %5 = bitcast i8* %call3 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %5, %struct._GimpImagePrivate** %private, align 8
  %6 = load i8*, i8** @gimp_image_parent_class, align 8
  %7 = bitcast i8* %6 to %struct._GTypeClass*
  %call4 = call %struct._GTypeClass* @g_type_check_class_cast(%struct._GTypeClass* %7, i64 80)
  %8 = bitcast %struct._GTypeClass* %call4 to %struct._GObjectClass*
  %constructed = getelementptr inbounds %struct._GObjectClass, %struct._GObjectClass* %8, i32 0, i32 9
  %9 = load void (%struct._GObject*)*, void (%struct._GObject*)** %constructed, align 8
  %tobool = icmp ne void (%struct._GObject*)* %9, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %10 = load i8*, i8** @gimp_image_parent_class, align 8
  %11 = bitcast i8* %10 to %struct._GTypeClass*
  %call5 = call %struct._GTypeClass* @g_type_check_class_cast(%struct._GTypeClass* %11, i64 80)
  %12 = bitcast %struct._GTypeClass* %call5 to %struct._GObjectClass*
  %constructed6 = getelementptr inbounds %struct._GObjectClass, %struct._GObjectClass* %12, i32 0, i32 9
  %13 = load void (%struct._GObject*)*, void (%struct._GObject*)** %constructed6, align 8
  %14 = load %struct._GObject*, %struct._GObject** %object.addr, align 8
  call void %13(%struct._GObject* %14)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  br label %do.body

do.body:                                          ; preds = %if.end
  %15 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  %gimp = getelementptr inbounds %struct._GimpImage, %struct._GimpImage* %15, i32 0, i32 1
  %16 = load %struct._Gimp*, %struct._Gimp** %gimp, align 8
  %17 = bitcast %struct._Gimp* %16 to %struct._GTypeInstance*
  store %struct._GTypeInstance* %17, %struct._GTypeInstance** %__inst, align 8
  %call7 = call i64 @gimp_get_type() #8
  store i64 %call7, i64* %__t, align 8
  %18 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %tobool8 = icmp ne %struct._GTypeInstance* %18, null
  br i1 %tobool8, label %if.else, label %if.then.9

if.then.9:                                        ; preds = %do.body
  store i32 0, i32* %__r, align 4
  br label %if.end.16

if.else:                                          ; preds = %do.body
  %19 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %19, i32 0, i32 0
  %20 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %tobool10 = icmp ne %struct._GTypeClass* %20, null
  br i1 %tobool10, label %land.lhs.true, label %if.else.13

land.lhs.true:                                    ; preds = %if.else
  %21 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %g_class11 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %21, i32 0, i32 0
  %22 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class11, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %22, i32 0, i32 0
  %23 = load i64, i64* %g_type, align 8
  %24 = load i64, i64* %__t, align 8
  %cmp = icmp eq i64 %23, %24
  br i1 %cmp, label %if.then.12, label %if.else.13

if.then.12:                                       ; preds = %land.lhs.true
  store i32 1, i32* %__r, align 4
  br label %if.end.15

if.else.13:                                       ; preds = %land.lhs.true, %if.else
  %25 = load %struct._GTypeInstance*, %struct._GTypeInstance** %__inst, align 8
  %26 = load i64, i64* %__t, align 8
  %call14 = call i32 @g_type_check_instance_is_a(%struct._GTypeInstance* %25, i64 %26) #9
  store i32 %call14, i32* %__r, align 4
  br label %if.end.15

if.end.15:                                        ; preds = %if.else.13, %if.then.12
  br label %if.end.16

if.end.16:                                        ; preds = %if.end.15, %if.then.9
  %27 = load i32, i32* %__r, align 4
  store i32 %27, i32* %tmp
  %28 = load i32, i32* %tmp
  %tobool17 = icmp ne i32 %28, 0
  br i1 %tobool17, label %if.then.18, label %if.else.19

if.then.18:                                       ; preds = %if.end.16
  br label %if.end.20

if.else.19:                                       ; preds = %if.end.16
  call void @g_assertion_message_expr(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.104, i32 0, i32 0), i32 750, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @__func__.gimp_image_constructed, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.105, i32 0, i32 0)) #10
  unreachable

if.end.20:                                        ; preds = %if.then.18
  br label %do.end

do.end:                                           ; preds = %if.end.20
  %29 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  %gimp21 = getelementptr inbounds %struct._GimpImage, %struct._GimpImage* %29, i32 0, i32 1
  %30 = load %struct._Gimp*, %struct._Gimp** %gimp21, align 8
  %config22 = getelementptr inbounds %struct._Gimp, %struct._Gimp* %30, i32 0, i32 1
  %31 = load %struct._GimpCoreConfig*, %struct._GimpCoreConfig** %config22, align 8
  store %struct._GimpCoreConfig* %31, %struct._GimpCoreConfig** %config, align 8
  %32 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  %gimp23 = getelementptr inbounds %struct._GimpImage, %struct._GimpImage* %32, i32 0, i32 1
  %33 = load %struct._Gimp*, %struct._Gimp** %gimp23, align 8
  %image_table = getelementptr inbounds %struct._Gimp, %struct._Gimp* %33, i32 0, i32 29
  %34 = load %struct._GimpIdTable*, %struct._GimpIdTable** %image_table, align 8
  %35 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  %36 = bitcast %struct._GimpImage* %35 to i8*
  %call24 = call i32 @gimp_id_table_insert(%struct._GimpIdTable* %34, i8* %36)
  %37 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %ID = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %37, i32 0, i32 0
  store i32 %call24, i32* %ID, align 4
  %38 = load %struct._GimpCoreConfig*, %struct._GimpCoreConfig** %config, align 8
  %default_image = getelementptr inbounds %struct._GimpCoreConfig, %struct._GimpCoreConfig* %38, i32 0, i32 35
  %39 = load %struct._GimpTemplate*, %struct._GimpTemplate** %default_image, align 8
  store %struct._GimpTemplate* %39, %struct._GimpTemplate** %template, align 8
  %40 = load %struct._GimpTemplate*, %struct._GimpTemplate** %template, align 8
  %call25 = call double @gimp_template_get_resolution_x(%struct._GimpTemplate* %40)
  %41 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %xresolution = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %41, i32 0, i32 8
  store double %call25, double* %xresolution, align 8
  %42 = load %struct._GimpTemplate*, %struct._GimpTemplate** %template, align 8
  %call26 = call double @gimp_template_get_resolution_y(%struct._GimpTemplate* %42)
  %43 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %yresolution = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %43, i32 0, i32 9
  store double %call26, double* %yresolution, align 8
  %44 = load %struct._GimpTemplate*, %struct._GimpTemplate** %template, align 8
  %call27 = call i32 @gimp_template_get_resolution_unit(%struct._GimpTemplate* %44)
  %45 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %resolution_unit = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %45, i32 0, i32 10
  store i32 %call27, i32* %resolution_unit, align 4
  %46 = load %struct._GimpCoreConfig*, %struct._GimpCoreConfig** %config, align 8
  %default_grid = getelementptr inbounds %struct._GimpCoreConfig, %struct._GimpCoreConfig* %46, i32 0, i32 36
  %47 = load %struct._GimpGrid*, %struct._GimpGrid** %default_grid, align 8
  %48 = bitcast %struct._GimpGrid* %47 to %struct._GTypeInstance*
  %call28 = call i64 @gimp_config_interface_get_type() #8
  %call29 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %48, i64 %call28)
  %49 = bitcast %struct._GTypeInstance* %call29 to %struct._GimpConfig*
  %call30 = call i8* @gimp_config_duplicate(%struct._GimpConfig* %49)
  %50 = bitcast i8* %call30 to %struct._GimpGrid*
  %51 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %grid = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %51, i32 0, i32 25
  store %struct._GimpGrid* %50, %struct._GimpGrid** %grid, align 8
  %52 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %quick_mask_color = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %52, i32 0, i32 41
  %53 = load %struct._GimpCoreConfig*, %struct._GimpCoreConfig** %config, align 8
  %quick_mask_color31 = getelementptr inbounds %struct._GimpCoreConfig, %struct._GimpCoreConfig* %53, i32 0, i32 49
  %54 = bitcast %struct._GimpRGB* %quick_mask_color to i8*
  %55 = bitcast %struct._GimpRGB* %quick_mask_color31 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %54, i8* %55, i64 32, i32 8, i1 false)
  %56 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %base_type = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %56, i32 0, i32 11
  %57 = load i32, i32* %base_type, align 4
  %cmp32 = icmp eq i32 %57, 2
  br i1 %cmp32, label %if.then.33, label %if.end.34

if.then.33:                                       ; preds = %do.end
  %58 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  call void @gimp_image_colormap_init(%struct._GimpImage* %58)
  br label %if.end.34

if.end.34:                                        ; preds = %if.then.33, %do.end
  %59 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  %60 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  %call35 = call i32 @gimp_image_get_width(%struct._GimpImage* %60)
  %61 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  %call36 = call i32 @gimp_image_get_height(%struct._GimpImage* %61)
  %call37 = call %struct._GimpChannel* @gimp_selection_new(%struct._GimpImage* %59, i32 %call35, i32 %call36)
  store %struct._GimpChannel* %call37, %struct._GimpChannel** %selection, align 8
  %62 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  %63 = load %struct._GimpChannel*, %struct._GimpChannel** %selection, align 8
  call void @gimp_image_take_mask(%struct._GimpImage* %62, %struct._GimpChannel* %63)
  %64 = load %struct._GimpCoreConfig*, %struct._GimpCoreConfig** %config, align 8
  %65 = bitcast %struct._GimpCoreConfig* %64 to i8*
  %66 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %layers = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %66, i32 0, i32 27
  %67 = load %struct._GimpItemTree*, %struct._GimpItemTree** %layers, align 8
  %container = getelementptr inbounds %struct._GimpItemTree, %struct._GimpItemTree* %67, i32 0, i32 1
  %68 = load %struct._GimpContainer*, %struct._GimpContainer** %container, align 8
  %69 = bitcast %struct._GimpContainer* %68 to i8*
  %call38 = call i64 @g_signal_connect_object(i8* %65, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.106, i32 0, i32 0), void ()* bitcast (void (%struct._GimpItemStack*)* @gimp_item_stack_invalidate_previews to void ()*), i8* %69, i32 2)
  %70 = load %struct._GimpCoreConfig*, %struct._GimpCoreConfig** %config, align 8
  %71 = bitcast %struct._GimpCoreConfig* %70 to i8*
  %72 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %layers39 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %72, i32 0, i32 27
  %73 = load %struct._GimpItemTree*, %struct._GimpItemTree** %layers39, align 8
  %container40 = getelementptr inbounds %struct._GimpItemTree, %struct._GimpItemTree* %73, i32 0, i32 1
  %74 = load %struct._GimpContainer*, %struct._GimpContainer** %container40, align 8
  %75 = bitcast %struct._GimpContainer* %74 to i8*
  %call41 = call i64 @g_signal_connect_object(i8* %71, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.107, i32 0, i32 0), void ()* bitcast (void (%struct._GimpItemStack*)* @gimp_item_stack_invalidate_previews to void ()*), i8* %75, i32 2)
  %76 = load %struct._GimpCoreConfig*, %struct._GimpCoreConfig** %config, align 8
  %77 = bitcast %struct._GimpCoreConfig* %76 to i8*
  %78 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  %79 = bitcast %struct._GimpImage* %78 to i8*
  %call42 = call i64 @g_signal_connect_object(i8* %77, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.108, i32 0, i32 0), void ()* bitcast (void (%struct._GimpViewable*)* @gimp_viewable_size_changed to void ()*), i8* %79, i32 2)
  %80 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  %gimp43 = getelementptr inbounds %struct._GimpImage, %struct._GimpImage* %80, i32 0, i32 1
  %81 = load %struct._Gimp*, %struct._Gimp** %gimp43, align 8
  %images = getelementptr inbounds %struct._Gimp, %struct._Gimp* %81, i32 0, i32 26
  %82 = load %struct._GimpContainer*, %struct._GimpContainer** %images, align 8
  %83 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  %84 = bitcast %struct._GimpImage* %83 to %struct._GTypeInstance*
  %call44 = call i64 @gimp_object_get_type() #8
  %call45 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %84, i64 %call44)
  %85 = bitcast %struct._GTypeInstance* %call45 to %struct._GimpObject*
  %call46 = call i32 @gimp_container_add(%struct._GimpContainer* %82, %struct._GimpObject* %85)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @gimp_image_set_property(%struct._GObject* %object, i32 %property_id, %struct._GValue* %value, %struct._GParamSpec* %pspec) #3 {
entry:
  %object.addr = alloca %struct._GObject*, align 8
  %property_id.addr = alloca i32, align 4
  %value.addr = alloca %struct._GValue*, align 8
  %pspec.addr = alloca %struct._GParamSpec*, align 8
  %image = alloca %struct._GimpImage*, align 8
  %private = alloca %struct._GimpImagePrivate*, align 8
  %_glib__object = alloca %struct._GObject*, align 8
  %_glib__pspec = alloca %struct._GParamSpec*, align 8
  %_glib__property_id = alloca i32, align 4
  store %struct._GObject* %object, %struct._GObject** %object.addr, align 8
  store i32 %property_id, i32* %property_id.addr, align 4
  store %struct._GValue* %value, %struct._GValue** %value.addr, align 8
  store %struct._GParamSpec* %pspec, %struct._GParamSpec** %pspec.addr, align 8
  %0 = load %struct._GObject*, %struct._GObject** %object.addr, align 8
  %1 = bitcast %struct._GObject* %0 to %struct._GTypeInstance*
  %call = call i64 @gimp_image_get_type() #8
  %call1 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %1, i64 %call)
  %2 = bitcast %struct._GTypeInstance* %call1 to %struct._GimpImage*
  store %struct._GimpImage* %2, %struct._GimpImage** %image, align 8
  %3 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  %4 = bitcast %struct._GimpImage* %3 to %struct._GTypeInstance*
  %call2 = call i64 @gimp_image_get_type() #8
  %call3 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %4, i64 %call2)
  %5 = bitcast i8* %call3 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %5, %struct._GimpImagePrivate** %private, align 8
  %6 = load i32, i32* %property_id.addr, align 4
  switch i32 %6, label %sw.default [
    i32 1, label %sw.bb
    i32 2, label %sw.bb.5
    i32 3, label %sw.bb.6
    i32 4, label %sw.bb.8
    i32 5, label %sw.bb.10
  ]

sw.bb:                                            ; preds = %entry
  %7 = load %struct._GValue*, %struct._GValue** %value.addr, align 8
  %call4 = call i8* @g_value_get_object(%struct._GValue* %7)
  %8 = bitcast i8* %call4 to %struct._Gimp*
  %9 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  %gimp = getelementptr inbounds %struct._GimpImage, %struct._GimpImage* %9, i32 0, i32 1
  store %struct._Gimp* %8, %struct._Gimp** %gimp, align 8
  br label %sw.epilog

sw.bb.5:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %sw.bb.5
  call void @g_assertion_message_expr(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.2, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.104, i32 0, i32 0), i32 802, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @__func__.gimp_image_set_property, i32 0, i32 0), i8* null) #10
  unreachable

do.end:                                           ; No predecessors!
  br label %sw.epilog

sw.bb.6:                                          ; preds = %entry
  %10 = load %struct._GValue*, %struct._GValue** %value.addr, align 8
  %call7 = call i32 @g_value_get_int(%struct._GValue* %10)
  %11 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %width = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %11, i32 0, i32 6
  store i32 %call7, i32* %width, align 4
  br label %sw.epilog

sw.bb.8:                                          ; preds = %entry
  %12 = load %struct._GValue*, %struct._GValue** %value.addr, align 8
  %call9 = call i32 @g_value_get_int(%struct._GValue* %12)
  %13 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %height = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %13, i32 0, i32 7
  store i32 %call9, i32* %height, align 4
  br label %sw.epilog

sw.bb.10:                                         ; preds = %entry
  %14 = load %struct._GValue*, %struct._GValue** %value.addr, align 8
  %call11 = call i32 @g_value_get_enum(%struct._GValue* %14)
  %15 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %base_type = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %15, i32 0, i32 11
  store i32 %call11, i32* %base_type, align 4
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  br label %do.body.12

do.body.12:                                       ; preds = %sw.default
  %16 = load %struct._GObject*, %struct._GObject** %object.addr, align 8
  store %struct._GObject* %16, %struct._GObject** %_glib__object, align 8
  %17 = load %struct._GParamSpec*, %struct._GParamSpec** %pspec.addr, align 8
  store %struct._GParamSpec* %17, %struct._GParamSpec** %_glib__pspec, align 8
  %18 = load i32, i32* %property_id.addr, align 4
  store i32 %18, i32* %_glib__property_id, align 4
  %19 = load i32, i32* %_glib__property_id, align 4
  %20 = load %struct._GParamSpec*, %struct._GParamSpec** %_glib__pspec, align 8
  %name = getelementptr inbounds %struct._GParamSpec, %struct._GParamSpec* %20, i32 0, i32 1
  %21 = load i8*, i8** %name, align 8
  %22 = load %struct._GParamSpec*, %struct._GParamSpec** %_glib__pspec, align 8
  %23 = bitcast %struct._GParamSpec* %22 to %struct._GTypeInstance*
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %23, i32 0, i32 0
  %24 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %24, i32 0, i32 0
  %25 = load i64, i64* %g_type, align 8
  %call13 = call i8* @g_type_name(i64 %25)
  %26 = load %struct._GObject*, %struct._GObject** %_glib__object, align 8
  %27 = bitcast %struct._GObject* %26 to %struct._GTypeInstance*
  %g_class14 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %27, i32 0, i32 0
  %28 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class14, align 8
  %g_type15 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %28, i32 0, i32 0
  %29 = load i64, i64* %g_type15, align 8
  %call16 = call i8* @g_type_name(i64 %29)
  call void (i8*, ...) @g_warning(i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.109, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.104, i32 0, i32 0), i32 814, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.110, i32 0, i32 0), i32 %19, i8* %21, i8* %call13, i8* %call16)
  br label %do.end.17

do.end.17:                                        ; preds = %do.body.12
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end.17, %sw.bb.10, %sw.bb.8, %sw.bb.6, %do.end, %sw.bb
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @gimp_image_get_property(%struct._GObject* %object, i32 %property_id, %struct._GValue* %value, %struct._GParamSpec* %pspec) #3 {
entry:
  %object.addr = alloca %struct._GObject*, align 8
  %property_id.addr = alloca i32, align 4
  %value.addr = alloca %struct._GValue*, align 8
  %pspec.addr = alloca %struct._GParamSpec*, align 8
  %image = alloca %struct._GimpImage*, align 8
  %private = alloca %struct._GimpImagePrivate*, align 8
  %_glib__object = alloca %struct._GObject*, align 8
  %_glib__pspec = alloca %struct._GParamSpec*, align 8
  %_glib__property_id = alloca i32, align 4
  store %struct._GObject* %object, %struct._GObject** %object.addr, align 8
  store i32 %property_id, i32* %property_id.addr, align 4
  store %struct._GValue* %value, %struct._GValue** %value.addr, align 8
  store %struct._GParamSpec* %pspec, %struct._GParamSpec** %pspec.addr, align 8
  %0 = load %struct._GObject*, %struct._GObject** %object.addr, align 8
  %1 = bitcast %struct._GObject* %0 to %struct._GTypeInstance*
  %call = call i64 @gimp_image_get_type() #8
  %call1 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %1, i64 %call)
  %2 = bitcast %struct._GTypeInstance* %call1 to %struct._GimpImage*
  store %struct._GimpImage* %2, %struct._GimpImage** %image, align 8
  %3 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  %4 = bitcast %struct._GimpImage* %3 to %struct._GTypeInstance*
  %call2 = call i64 @gimp_image_get_type() #8
  %call3 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %4, i64 %call2)
  %5 = bitcast i8* %call3 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %5, %struct._GimpImagePrivate** %private, align 8
  %6 = load i32, i32* %property_id.addr, align 4
  switch i32 %6, label %sw.default [
    i32 1, label %sw.bb
    i32 2, label %sw.bb.4
    i32 3, label %sw.bb.5
    i32 4, label %sw.bb.6
    i32 5, label %sw.bb.7
  ]

sw.bb:                                            ; preds = %entry
  %7 = load %struct._GValue*, %struct._GValue** %value.addr, align 8
  %8 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  %gimp = getelementptr inbounds %struct._GimpImage, %struct._GimpImage* %8, i32 0, i32 1
  %9 = load %struct._Gimp*, %struct._Gimp** %gimp, align 8
  %10 = bitcast %struct._Gimp* %9 to i8*
  call void @g_value_set_object(%struct._GValue* %7, i8* %10)
  br label %sw.epilog

sw.bb.4:                                          ; preds = %entry
  %11 = load %struct._GValue*, %struct._GValue** %value.addr, align 8
  %12 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %ID = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %12, i32 0, i32 0
  %13 = load i32, i32* %ID, align 4
  call void @g_value_set_int(%struct._GValue* %11, i32 %13)
  br label %sw.epilog

sw.bb.5:                                          ; preds = %entry
  %14 = load %struct._GValue*, %struct._GValue** %value.addr, align 8
  %15 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %width = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %15, i32 0, i32 6
  %16 = load i32, i32* %width, align 4
  call void @g_value_set_int(%struct._GValue* %14, i32 %16)
  br label %sw.epilog

sw.bb.6:                                          ; preds = %entry
  %17 = load %struct._GValue*, %struct._GValue** %value.addr, align 8
  %18 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %height = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %18, i32 0, i32 7
  %19 = load i32, i32* %height, align 4
  call void @g_value_set_int(%struct._GValue* %17, i32 %19)
  br label %sw.epilog

sw.bb.7:                                          ; preds = %entry
  %20 = load %struct._GValue*, %struct._GValue** %value.addr, align 8
  %21 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %base_type = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %21, i32 0, i32 11
  %22 = load i32, i32* %base_type, align 4
  call void @g_value_set_enum(%struct._GValue* %20, i32 %22)
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %sw.default
  %23 = load %struct._GObject*, %struct._GObject** %object.addr, align 8
  store %struct._GObject* %23, %struct._GObject** %_glib__object, align 8
  %24 = load %struct._GParamSpec*, %struct._GParamSpec** %pspec.addr, align 8
  store %struct._GParamSpec* %24, %struct._GParamSpec** %_glib__pspec, align 8
  %25 = load i32, i32* %property_id.addr, align 4
  store i32 %25, i32* %_glib__property_id, align 4
  %26 = load i32, i32* %_glib__property_id, align 4
  %27 = load %struct._GParamSpec*, %struct._GParamSpec** %_glib__pspec, align 8
  %name = getelementptr inbounds %struct._GParamSpec, %struct._GParamSpec* %27, i32 0, i32 1
  %28 = load i8*, i8** %name, align 8
  %29 = load %struct._GParamSpec*, %struct._GParamSpec** %_glib__pspec, align 8
  %30 = bitcast %struct._GParamSpec* %29 to %struct._GTypeInstance*
  %g_class = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %30, i32 0, i32 0
  %31 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class, align 8
  %g_type = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %31, i32 0, i32 0
  %32 = load i64, i64* %g_type, align 8
  %call8 = call i8* @g_type_name(i64 %32)
  %33 = load %struct._GObject*, %struct._GObject** %_glib__object, align 8
  %34 = bitcast %struct._GObject* %33 to %struct._GTypeInstance*
  %g_class9 = getelementptr inbounds %struct._GTypeInstance, %struct._GTypeInstance* %34, i32 0, i32 0
  %35 = load %struct._GTypeClass*, %struct._GTypeClass** %g_class9, align 8
  %g_type10 = getelementptr inbounds %struct._GTypeClass, %struct._GTypeClass* %35, i32 0, i32 0
  %36 = load i64, i64* %g_type10, align 8
  %call11 = call i8* @g_type_name(i64 %36)
  call void (i8*, ...) @g_warning(i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.109, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.104, i32 0, i32 0), i32 846, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.110, i32 0, i32 0), i32 %26, i8* %28, i8* %call8, i8* %call11)
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end, %sw.bb.7, %sw.bb.6, %sw.bb.5, %sw.bb.4, %sw.bb
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @gimp_image_dispose(%struct._GObject* %object) #3 {
entry:
  %object.addr = alloca %struct._GObject*, align 8
  %image = alloca %struct._GimpImage*, align 8
  %private = alloca %struct._GimpImagePrivate*, align 8
  store %struct._GObject* %object, %struct._GObject** %object.addr, align 8
  %0 = load %struct._GObject*, %struct._GObject** %object.addr, align 8
  %1 = bitcast %struct._GObject* %0 to %struct._GTypeInstance*
  %call = call i64 @gimp_image_get_type() #8
  %call1 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %1, i64 %call)
  %2 = bitcast %struct._GTypeInstance* %call1 to %struct._GimpImage*
  store %struct._GimpImage* %2, %struct._GimpImage** %image, align 8
  %3 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  %4 = bitcast %struct._GimpImage* %3 to %struct._GTypeInstance*
  %call2 = call i64 @gimp_image_get_type() #8
  %call3 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %4, i64 %call2)
  %5 = bitcast i8* %call3 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %5, %struct._GimpImagePrivate** %private, align 8
  %6 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %colormap = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %6, i32 0, i32 12
  %7 = load i8*, i8** %colormap, align 8
  %tobool = icmp ne i8* %7, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %8 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  call void @gimp_image_colormap_dispose(%struct._GimpImage* %8)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %9 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  call void @gimp_image_undo_free(%struct._GimpImage* %9)
  %10 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %layers = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %10, i32 0, i32 27
  %11 = load %struct._GimpItemTree*, %struct._GimpItemTree** %layers, align 8
  %container = getelementptr inbounds %struct._GimpItemTree, %struct._GimpItemTree* %11, i32 0, i32 1
  %12 = load %struct._GimpContainer*, %struct._GimpContainer** %container, align 8
  %13 = bitcast %struct._GimpContainer* %12 to i8*
  %14 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  %15 = bitcast %struct._GimpImage* %14 to i8*
  %call4 = call i32 @g_signal_handlers_disconnect_matched(i8* %13, i32 24, i32 0, i32 0, %struct._GClosure* null, i8* bitcast (void (%struct._GimpImage*, i32, i32, i32, i32)* @gimp_image_invalidate to i8*), i8* %15)
  %16 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %layers5 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %16, i32 0, i32 27
  %17 = load %struct._GimpItemTree*, %struct._GimpItemTree** %layers5, align 8
  %container6 = getelementptr inbounds %struct._GimpItemTree, %struct._GimpItemTree* %17, i32 0, i32 1
  %18 = load %struct._GimpContainer*, %struct._GimpContainer** %container6, align 8
  %19 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %layer_alpha_handler = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %19, i32 0, i32 31
  %20 = load i32, i32* %layer_alpha_handler, align 4
  call void @gimp_container_remove_handler(%struct._GimpContainer* %18, i32 %20)
  %21 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %channels = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %21, i32 0, i32 28
  %22 = load %struct._GimpItemTree*, %struct._GimpItemTree** %channels, align 8
  %container7 = getelementptr inbounds %struct._GimpItemTree, %struct._GimpItemTree* %22, i32 0, i32 1
  %23 = load %struct._GimpContainer*, %struct._GimpContainer** %container7, align 8
  %24 = bitcast %struct._GimpContainer* %23 to i8*
  %25 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  %26 = bitcast %struct._GimpImage* %25 to i8*
  %call8 = call i32 @g_signal_handlers_disconnect_matched(i8* %24, i32 24, i32 0, i32 0, %struct._GClosure* null, i8* bitcast (void (%struct._GimpImage*, i32, i32, i32, i32)* @gimp_image_invalidate to i8*), i8* %26)
  %27 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %channels9 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %27, i32 0, i32 28
  %28 = load %struct._GimpItemTree*, %struct._GimpItemTree** %channels9, align 8
  %container10 = getelementptr inbounds %struct._GimpItemTree, %struct._GimpItemTree* %28, i32 0, i32 1
  %29 = load %struct._GimpContainer*, %struct._GimpContainer** %container10, align 8
  %30 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %channel_name_changed_handler = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %30, i32 0, i32 32
  %31 = load i32, i32* %channel_name_changed_handler, align 4
  call void @gimp_container_remove_handler(%struct._GimpContainer* %29, i32 %31)
  %32 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %channels11 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %32, i32 0, i32 28
  %33 = load %struct._GimpItemTree*, %struct._GimpItemTree** %channels11, align 8
  %container12 = getelementptr inbounds %struct._GimpItemTree, %struct._GimpItemTree* %33, i32 0, i32 1
  %34 = load %struct._GimpContainer*, %struct._GimpContainer** %container12, align 8
  %35 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %channel_color_changed_handler = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %35, i32 0, i32 33
  %36 = load i32, i32* %channel_color_changed_handler, align 4
  call void @gimp_container_remove_handler(%struct._GimpContainer* %34, i32 %36)
  %37 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %channels13 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %37, i32 0, i32 28
  %38 = load %struct._GimpItemTree*, %struct._GimpItemTree** %channels13, align 8
  %container14 = getelementptr inbounds %struct._GimpItemTree, %struct._GimpItemTree* %38, i32 0, i32 1
  %39 = load %struct._GimpContainer*, %struct._GimpContainer** %container14, align 8
  %40 = bitcast %struct._GimpContainer* %39 to i8*
  %41 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  %42 = bitcast %struct._GimpImage* %41 to i8*
  %call15 = call i32 @g_signal_handlers_disconnect_matched(i8* %40, i32 24, i32 0, i32 0, %struct._GClosure* null, i8* bitcast (void (%struct._GimpContainer*, %struct._GimpChannel*, %struct._GimpImage*)* @gimp_image_channel_add to i8*), i8* %42)
  %43 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %channels16 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %43, i32 0, i32 28
  %44 = load %struct._GimpItemTree*, %struct._GimpItemTree** %channels16, align 8
  %container17 = getelementptr inbounds %struct._GimpItemTree, %struct._GimpItemTree* %44, i32 0, i32 1
  %45 = load %struct._GimpContainer*, %struct._GimpContainer** %container17, align 8
  %46 = bitcast %struct._GimpContainer* %45 to i8*
  %47 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  %48 = bitcast %struct._GimpImage* %47 to i8*
  %call18 = call i32 @g_signal_handlers_disconnect_matched(i8* %46, i32 24, i32 0, i32 0, %struct._GClosure* null, i8* bitcast (void (%struct._GimpContainer*, %struct._GimpChannel*, %struct._GimpImage*)* @gimp_image_channel_remove to i8*), i8* %48)
  %49 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %layers19 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %49, i32 0, i32 27
  %50 = load %struct._GimpItemTree*, %struct._GimpItemTree** %layers19, align 8
  %container20 = getelementptr inbounds %struct._GimpItemTree, %struct._GimpItemTree* %50, i32 0, i32 1
  %51 = load %struct._GimpContainer*, %struct._GimpContainer** %container20, align 8
  call void @gimp_container_foreach(%struct._GimpContainer* %51, void (i8*, i8*)* bitcast (void (%struct._GimpItem*)* @gimp_item_removed to void (i8*, i8*)*), i8* null)
  %52 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %channels21 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %52, i32 0, i32 28
  %53 = load %struct._GimpItemTree*, %struct._GimpItemTree** %channels21, align 8
  %container22 = getelementptr inbounds %struct._GimpItemTree, %struct._GimpItemTree* %53, i32 0, i32 1
  %54 = load %struct._GimpContainer*, %struct._GimpContainer** %container22, align 8
  call void @gimp_container_foreach(%struct._GimpContainer* %54, void (i8*, i8*)* bitcast (void (%struct._GimpItem*)* @gimp_item_removed to void (i8*, i8*)*), i8* null)
  %55 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %vectors = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %55, i32 0, i32 29
  %56 = load %struct._GimpItemTree*, %struct._GimpItemTree** %vectors, align 8
  %container23 = getelementptr inbounds %struct._GimpItemTree, %struct._GimpItemTree* %56, i32 0, i32 1
  %57 = load %struct._GimpContainer*, %struct._GimpContainer** %container23, align 8
  call void @gimp_container_foreach(%struct._GimpContainer* %57, void (i8*, i8*)* bitcast (void (%struct._GimpItem*)* @gimp_item_removed to void (i8*, i8*)*), i8* null)
  %58 = load i8*, i8** @gimp_image_parent_class, align 8
  %59 = bitcast i8* %58 to %struct._GTypeClass*
  %call24 = call %struct._GTypeClass* @g_type_check_class_cast(%struct._GTypeClass* %59, i64 80)
  %60 = bitcast %struct._GTypeClass* %call24 to %struct._GObjectClass*
  %dispose = getelementptr inbounds %struct._GObjectClass, %struct._GObjectClass* %60, i32 0, i32 5
  %61 = load void (%struct._GObject*)*, void (%struct._GObject*)** %dispose, align 8
  %62 = load %struct._GObject*, %struct._GObject** %object.addr, align 8
  call void %61(%struct._GObject* %62)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @gimp_image_finalize(%struct._GObject* %object) #3 {
entry:
  %object.addr = alloca %struct._GObject*, align 8
  %image = alloca %struct._GimpImage*, align 8
  %private = alloca %struct._GimpImagePrivate*, align 8
  store %struct._GObject* %object, %struct._GObject** %object.addr, align 8
  %0 = load %struct._GObject*, %struct._GObject** %object.addr, align 8
  %1 = bitcast %struct._GObject* %0 to %struct._GTypeInstance*
  %call = call i64 @gimp_image_get_type() #8
  %call1 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %1, i64 %call)
  %2 = bitcast %struct._GTypeInstance* %call1 to %struct._GimpImage*
  store %struct._GimpImage* %2, %struct._GimpImage** %image, align 8
  %3 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  %4 = bitcast %struct._GimpImage* %3 to %struct._GTypeInstance*
  %call2 = call i64 @gimp_image_get_type() #8
  %call3 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %4, i64 %call2)
  %5 = bitcast i8* %call3 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %5, %struct._GimpImagePrivate** %private, align 8
  %6 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %projection = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %6, i32 0, i32 22
  %7 = load %struct._GimpProjection*, %struct._GimpProjection** %projection, align 8
  %tobool = icmp ne %struct._GimpProjection* %7, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %8 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %projection4 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %8, i32 0, i32 22
  %9 = load %struct._GimpProjection*, %struct._GimpProjection** %projection4, align 8
  %10 = bitcast %struct._GimpProjection* %9 to i8*
  call void @g_object_unref(i8* %10)
  %11 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %projection5 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %11, i32 0, i32 22
  store %struct._GimpProjection* null, %struct._GimpProjection** %projection5, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %12 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %graph = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %12, i32 0, i32 23
  %13 = load %struct._GeglNode*, %struct._GeglNode** %graph, align 8
  %tobool6 = icmp ne %struct._GeglNode* %13, null
  br i1 %tobool6, label %if.then.7, label %if.end.10

if.then.7:                                        ; preds = %if.end
  %14 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %graph8 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %14, i32 0, i32 23
  %15 = load %struct._GeglNode*, %struct._GeglNode** %graph8, align 8
  %16 = bitcast %struct._GeglNode* %15 to i8*
  call void @g_object_unref(i8* %16)
  %17 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %graph9 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %17, i32 0, i32 23
  store %struct._GeglNode* null, %struct._GeglNode** %graph9, align 8
  br label %if.end.10

if.end.10:                                        ; preds = %if.then.7, %if.end
  %18 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %colormap = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %18, i32 0, i32 12
  %19 = load i8*, i8** %colormap, align 8
  %tobool11 = icmp ne i8* %19, null
  br i1 %tobool11, label %if.then.12, label %if.end.13

if.then.12:                                       ; preds = %if.end.10
  %20 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  call void @gimp_image_colormap_free(%struct._GimpImage* %20)
  br label %if.end.13

if.end.13:                                        ; preds = %if.then.12, %if.end.10
  %21 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %layers = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %21, i32 0, i32 27
  %22 = load %struct._GimpItemTree*, %struct._GimpItemTree** %layers, align 8
  %tobool14 = icmp ne %struct._GimpItemTree* %22, null
  br i1 %tobool14, label %if.then.15, label %if.end.18

if.then.15:                                       ; preds = %if.end.13
  %23 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %layers16 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %23, i32 0, i32 27
  %24 = load %struct._GimpItemTree*, %struct._GimpItemTree** %layers16, align 8
  %25 = bitcast %struct._GimpItemTree* %24 to i8*
  call void @g_object_unref(i8* %25)
  %26 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %layers17 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %26, i32 0, i32 27
  store %struct._GimpItemTree* null, %struct._GimpItemTree** %layers17, align 8
  br label %if.end.18

if.end.18:                                        ; preds = %if.then.15, %if.end.13
  %27 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %channels = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %27, i32 0, i32 28
  %28 = load %struct._GimpItemTree*, %struct._GimpItemTree** %channels, align 8
  %tobool19 = icmp ne %struct._GimpItemTree* %28, null
  br i1 %tobool19, label %if.then.20, label %if.end.23

if.then.20:                                       ; preds = %if.end.18
  %29 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %channels21 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %29, i32 0, i32 28
  %30 = load %struct._GimpItemTree*, %struct._GimpItemTree** %channels21, align 8
  %31 = bitcast %struct._GimpItemTree* %30 to i8*
  call void @g_object_unref(i8* %31)
  %32 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %channels22 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %32, i32 0, i32 28
  store %struct._GimpItemTree* null, %struct._GimpItemTree** %channels22, align 8
  br label %if.end.23

if.end.23:                                        ; preds = %if.then.20, %if.end.18
  %33 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %vectors = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %33, i32 0, i32 29
  %34 = load %struct._GimpItemTree*, %struct._GimpItemTree** %vectors, align 8
  %tobool24 = icmp ne %struct._GimpItemTree* %34, null
  br i1 %tobool24, label %if.then.25, label %if.end.28

if.then.25:                                       ; preds = %if.end.23
  %35 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %vectors26 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %35, i32 0, i32 29
  %36 = load %struct._GimpItemTree*, %struct._GimpItemTree** %vectors26, align 8
  %37 = bitcast %struct._GimpItemTree* %36 to i8*
  call void @g_object_unref(i8* %37)
  %38 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %vectors27 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %38, i32 0, i32 29
  store %struct._GimpItemTree* null, %struct._GimpItemTree** %vectors27, align 8
  br label %if.end.28

if.end.28:                                        ; preds = %if.then.25, %if.end.23
  %39 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %layer_stack = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %39, i32 0, i32 30
  %40 = load %struct._GSList*, %struct._GSList** %layer_stack, align 8
  %tobool29 = icmp ne %struct._GSList* %40, null
  br i1 %tobool29, label %if.then.30, label %if.end.33

if.then.30:                                       ; preds = %if.end.28
  %41 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %layer_stack31 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %41, i32 0, i32 30
  %42 = load %struct._GSList*, %struct._GSList** %layer_stack31, align 8
  call void @g_slist_free(%struct._GSList* %42)
  %43 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %layer_stack32 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %43, i32 0, i32 30
  store %struct._GSList* null, %struct._GSList** %layer_stack32, align 8
  br label %if.end.33

if.end.33:                                        ; preds = %if.then.30, %if.end.28
  %44 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %selection_mask = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %44, i32 0, i32 35
  %45 = load %struct._GimpChannel*, %struct._GimpChannel** %selection_mask, align 8
  %tobool34 = icmp ne %struct._GimpChannel* %45, null
  br i1 %tobool34, label %if.then.35, label %if.end.38

if.then.35:                                       ; preds = %if.end.33
  %46 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %selection_mask36 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %46, i32 0, i32 35
  %47 = load %struct._GimpChannel*, %struct._GimpChannel** %selection_mask36, align 8
  %48 = bitcast %struct._GimpChannel* %47 to i8*
  call void @g_object_unref(i8* %48)
  %49 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %selection_mask37 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %49, i32 0, i32 35
  store %struct._GimpChannel* null, %struct._GimpChannel** %selection_mask37, align 8
  br label %if.end.38

if.end.38:                                        ; preds = %if.then.35, %if.end.33
  %50 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %preview = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %50, i32 0, i32 46
  %51 = load %struct._TempBuf*, %struct._TempBuf** %preview, align 8
  %tobool39 = icmp ne %struct._TempBuf* %51, null
  br i1 %tobool39, label %if.then.40, label %if.end.43

if.then.40:                                       ; preds = %if.end.38
  %52 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %preview41 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %52, i32 0, i32 46
  %53 = load %struct._TempBuf*, %struct._TempBuf** %preview41, align 8
  call void @temp_buf_free(%struct._TempBuf* %53)
  %54 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %preview42 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %54, i32 0, i32 46
  store %struct._TempBuf* null, %struct._TempBuf** %preview42, align 8
  br label %if.end.43

if.end.43:                                        ; preds = %if.then.40, %if.end.38
  %55 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %parasites = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %55, i32 0, i32 36
  %56 = load %struct._GimpParasiteList*, %struct._GimpParasiteList** %parasites, align 8
  %tobool44 = icmp ne %struct._GimpParasiteList* %56, null
  br i1 %tobool44, label %if.then.45, label %if.end.48

if.then.45:                                       ; preds = %if.end.43
  %57 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %parasites46 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %57, i32 0, i32 36
  %58 = load %struct._GimpParasiteList*, %struct._GimpParasiteList** %parasites46, align 8
  %59 = bitcast %struct._GimpParasiteList* %58 to i8*
  call void @g_object_unref(i8* %59)
  %60 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %parasites47 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %60, i32 0, i32 36
  store %struct._GimpParasiteList* null, %struct._GimpParasiteList** %parasites47, align 8
  br label %if.end.48

if.end.48:                                        ; preds = %if.then.45, %if.end.43
  %61 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %guides = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %61, i32 0, i32 24
  %62 = load %struct._GList*, %struct._GList** %guides, align 8
  %tobool49 = icmp ne %struct._GList* %62, null
  br i1 %tobool49, label %if.then.50, label %if.end.53

if.then.50:                                       ; preds = %if.end.48
  %63 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %guides51 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %63, i32 0, i32 24
  %64 = load %struct._GList*, %struct._GList** %guides51, align 8
  call void @g_list_free_full(%struct._GList* %64, void (i8*)* @g_object_unref)
  %65 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %guides52 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %65, i32 0, i32 24
  store %struct._GList* null, %struct._GList** %guides52, align 8
  br label %if.end.53

if.end.53:                                        ; preds = %if.then.50, %if.end.48
  %66 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %grid = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %66, i32 0, i32 25
  %67 = load %struct._GimpGrid*, %struct._GimpGrid** %grid, align 8
  %tobool54 = icmp ne %struct._GimpGrid* %67, null
  br i1 %tobool54, label %if.then.55, label %if.end.58

if.then.55:                                       ; preds = %if.end.53
  %68 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %grid56 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %68, i32 0, i32 25
  %69 = load %struct._GimpGrid*, %struct._GimpGrid** %grid56, align 8
  %70 = bitcast %struct._GimpGrid* %69 to i8*
  call void @g_object_unref(i8* %70)
  %71 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %grid57 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %71, i32 0, i32 25
  store %struct._GimpGrid* null, %struct._GimpGrid** %grid57, align 8
  br label %if.end.58

if.end.58:                                        ; preds = %if.then.55, %if.end.53
  %72 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %sample_points = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %72, i32 0, i32 26
  %73 = load %struct._GList*, %struct._GList** %sample_points, align 8
  %tobool59 = icmp ne %struct._GList* %73, null
  br i1 %tobool59, label %if.then.60, label %if.end.63

if.then.60:                                       ; preds = %if.end.58
  %74 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %sample_points61 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %74, i32 0, i32 26
  %75 = load %struct._GList*, %struct._GList** %sample_points61, align 8
  call void @g_list_free_full(%struct._GList* %75, void (i8*)* bitcast (void (%struct._GimpSamplePoint*)* @gimp_sample_point_unref to void (i8*)*))
  %76 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %sample_points62 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %76, i32 0, i32 26
  store %struct._GList* null, %struct._GList** %sample_points62, align 8
  br label %if.end.63

if.end.63:                                        ; preds = %if.then.60, %if.end.58
  %77 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %undo_stack = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %77, i32 0, i32 42
  %78 = load %struct._GimpUndoStack*, %struct._GimpUndoStack** %undo_stack, align 8
  %tobool64 = icmp ne %struct._GimpUndoStack* %78, null
  br i1 %tobool64, label %if.then.65, label %if.end.68

if.then.65:                                       ; preds = %if.end.63
  %79 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %undo_stack66 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %79, i32 0, i32 42
  %80 = load %struct._GimpUndoStack*, %struct._GimpUndoStack** %undo_stack66, align 8
  %81 = bitcast %struct._GimpUndoStack* %80 to i8*
  call void @g_object_unref(i8* %81)
  %82 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %undo_stack67 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %82, i32 0, i32 42
  store %struct._GimpUndoStack* null, %struct._GimpUndoStack** %undo_stack67, align 8
  br label %if.end.68

if.end.68:                                        ; preds = %if.then.65, %if.end.63
  %83 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %redo_stack = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %83, i32 0, i32 43
  %84 = load %struct._GimpUndoStack*, %struct._GimpUndoStack** %redo_stack, align 8
  %tobool69 = icmp ne %struct._GimpUndoStack* %84, null
  br i1 %tobool69, label %if.then.70, label %if.end.73

if.then.70:                                       ; preds = %if.end.68
  %85 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %redo_stack71 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %85, i32 0, i32 43
  %86 = load %struct._GimpUndoStack*, %struct._GimpUndoStack** %redo_stack71, align 8
  %87 = bitcast %struct._GimpUndoStack* %86 to i8*
  call void @g_object_unref(i8* %87)
  %88 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %redo_stack72 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %88, i32 0, i32 43
  store %struct._GimpUndoStack* null, %struct._GimpUndoStack** %redo_stack72, align 8
  br label %if.end.73

if.end.73:                                        ; preds = %if.then.70, %if.end.68
  %89 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  %gimp = getelementptr inbounds %struct._GimpImage, %struct._GimpImage* %89, i32 0, i32 1
  %90 = load %struct._Gimp*, %struct._Gimp** %gimp, align 8
  %tobool74 = icmp ne %struct._Gimp* %90, null
  br i1 %tobool74, label %land.lhs.true, label %if.end.82

land.lhs.true:                                    ; preds = %if.end.73
  %91 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  %gimp75 = getelementptr inbounds %struct._GimpImage, %struct._GimpImage* %91, i32 0, i32 1
  %92 = load %struct._Gimp*, %struct._Gimp** %gimp75, align 8
  %image_table = getelementptr inbounds %struct._Gimp, %struct._Gimp* %92, i32 0, i32 29
  %93 = load %struct._GimpIdTable*, %struct._GimpIdTable** %image_table, align 8
  %tobool76 = icmp ne %struct._GimpIdTable* %93, null
  br i1 %tobool76, label %if.then.77, label %if.end.82

if.then.77:                                       ; preds = %land.lhs.true
  %94 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  %gimp78 = getelementptr inbounds %struct._GimpImage, %struct._GimpImage* %94, i32 0, i32 1
  %95 = load %struct._Gimp*, %struct._Gimp** %gimp78, align 8
  %image_table79 = getelementptr inbounds %struct._Gimp, %struct._Gimp* %95, i32 0, i32 29
  %96 = load %struct._GimpIdTable*, %struct._GimpIdTable** %image_table79, align 8
  %97 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %ID = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %97, i32 0, i32 0
  %98 = load i32, i32* %ID, align 4
  %call80 = call i32 @gimp_id_table_remove(%struct._GimpIdTable* %96, i32 %98)
  %99 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  %gimp81 = getelementptr inbounds %struct._GimpImage, %struct._GimpImage* %99, i32 0, i32 1
  store %struct._Gimp* null, %struct._Gimp** %gimp81, align 8
  br label %if.end.82

if.end.82:                                        ; preds = %if.then.77, %land.lhs.true, %if.end.73
  %100 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %display_name = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %100, i32 0, i32 4
  %101 = load i8*, i8** %display_name, align 8
  %tobool83 = icmp ne i8* %101, null
  br i1 %tobool83, label %if.then.84, label %if.end.87

if.then.84:                                       ; preds = %if.end.82
  %102 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %display_name85 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %102, i32 0, i32 4
  %103 = load i8*, i8** %display_name85, align 8
  call void @g_free(i8* %103)
  %104 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %display_name86 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %104, i32 0, i32 4
  store i8* null, i8** %display_name86, align 8
  br label %if.end.87

if.end.87:                                        ; preds = %if.then.84, %if.end.82
  %105 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %display_path = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %105, i32 0, i32 5
  %106 = load i8*, i8** %display_path, align 8
  %tobool88 = icmp ne i8* %106, null
  br i1 %tobool88, label %if.then.89, label %if.end.92

if.then.89:                                       ; preds = %if.end.87
  %107 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %display_path90 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %107, i32 0, i32 5
  %108 = load i8*, i8** %display_path90, align 8
  call void @g_free(i8* %108)
  %109 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %display_path91 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %109, i32 0, i32 5
  store i8* null, i8** %display_path91, align 8
  br label %if.end.92

if.end.92:                                        ; preds = %if.then.89, %if.end.87
  %110 = load i8*, i8** @gimp_image_parent_class, align 8
  %111 = bitcast i8* %110 to %struct._GTypeClass*
  %call93 = call %struct._GTypeClass* @g_type_check_class_cast(%struct._GTypeClass* %111, i64 80)
  %112 = bitcast %struct._GTypeClass* %call93 to %struct._GObjectClass*
  %finalize = getelementptr inbounds %struct._GObjectClass, %struct._GObjectClass* %112, i32 0, i32 6
  %113 = load void (%struct._GObject*)*, void (%struct._GObject*)** %finalize, align 8
  %114 = load %struct._GObject*, %struct._GObject** %object.addr, align 8
  call void %113(%struct._GObject* %114)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @gimp_image_name_changed(%struct._GimpObject* %object) #3 {
entry:
  %object.addr = alloca %struct._GimpObject*, align 8
  %image = alloca %struct._GimpImage*, align 8
  %private = alloca %struct._GimpImagePrivate*, align 8
  %name = alloca i8*, align 8
  store %struct._GimpObject* %object, %struct._GimpObject** %object.addr, align 8
  %0 = load %struct._GimpObject*, %struct._GimpObject** %object.addr, align 8
  %1 = bitcast %struct._GimpObject* %0 to %struct._GTypeInstance*
  %call = call i64 @gimp_image_get_type() #8
  %call1 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %1, i64 %call)
  %2 = bitcast %struct._GTypeInstance* %call1 to %struct._GimpImage*
  store %struct._GimpImage* %2, %struct._GimpImage** %image, align 8
  %3 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  %4 = bitcast %struct._GimpImage* %3 to %struct._GTypeInstance*
  %call2 = call i64 @gimp_image_get_type() #8
  %call3 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %4, i64 %call2)
  %5 = bitcast i8* %call3 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %5, %struct._GimpImagePrivate** %private, align 8
  %6 = load i8*, i8** @gimp_image_parent_class, align 8
  %7 = bitcast i8* %6 to %struct._GTypeClass*
  %call4 = call i64 @gimp_object_get_type() #8
  %call5 = call %struct._GTypeClass* @g_type_check_class_cast(%struct._GTypeClass* %7, i64 %call4)
  %8 = bitcast %struct._GTypeClass* %call5 to %struct._GimpObjectClass*
  %name_changed = getelementptr inbounds %struct._GimpObjectClass, %struct._GimpObjectClass* %8, i32 0, i32 2
  %9 = load void (%struct._GimpObject*)*, void (%struct._GimpObject*)** %name_changed, align 8
  %tobool = icmp ne void (%struct._GimpObject*)* %9, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %10 = load i8*, i8** @gimp_image_parent_class, align 8
  %11 = bitcast i8* %10 to %struct._GTypeClass*
  %call6 = call i64 @gimp_object_get_type() #8
  %call7 = call %struct._GTypeClass* @g_type_check_class_cast(%struct._GTypeClass* %11, i64 %call6)
  %12 = bitcast %struct._GTypeClass* %call7 to %struct._GimpObjectClass*
  %name_changed8 = getelementptr inbounds %struct._GimpObjectClass, %struct._GimpObjectClass* %12, i32 0, i32 2
  %13 = load void (%struct._GimpObject*)*, void (%struct._GimpObject*)** %name_changed8, align 8
  %14 = load %struct._GimpObject*, %struct._GimpObject** %object.addr, align 8
  call void %13(%struct._GimpObject* %14)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %15 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %display_name = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %15, i32 0, i32 4
  %16 = load i8*, i8** %display_name, align 8
  %tobool9 = icmp ne i8* %16, null
  br i1 %tobool9, label %if.then.10, label %if.end.13

if.then.10:                                       ; preds = %if.end
  %17 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %display_name11 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %17, i32 0, i32 4
  %18 = load i8*, i8** %display_name11, align 8
  call void @g_free(i8* %18)
  %19 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %display_name12 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %19, i32 0, i32 4
  store i8* null, i8** %display_name12, align 8
  br label %if.end.13

if.end.13:                                        ; preds = %if.then.10, %if.end
  %20 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %display_path = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %20, i32 0, i32 5
  %21 = load i8*, i8** %display_path, align 8
  %tobool14 = icmp ne i8* %21, null
  br i1 %tobool14, label %if.then.15, label %if.end.18

if.then.15:                                       ; preds = %if.end.13
  %22 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %display_path16 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %22, i32 0, i32 5
  %23 = load i8*, i8** %display_path16, align 8
  call void @g_free(i8* %23)
  %24 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %display_path17 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %24, i32 0, i32 5
  store i8* null, i8** %display_path17, align 8
  br label %if.end.18

if.end.18:                                        ; preds = %if.then.15, %if.end.13
  %25 = load %struct._GimpObject*, %struct._GimpObject** %object.addr, align 8
  %26 = bitcast %struct._GimpObject* %25 to i8*
  %call19 = call i8* @gimp_object_get_name(i8* %26)
  store i8* %call19, i8** %name, align 8
  %27 = load i8*, i8** %name, align 8
  %tobool20 = icmp ne i8* %27, null
  br i1 %tobool20, label %land.lhs.true, label %if.end.23

land.lhs.true:                                    ; preds = %if.end.18
  %28 = load i8*, i8** %name, align 8
  %call21 = call i64 @strlen(i8* %28) #9
  %cmp = icmp eq i64 %call21, 0
  br i1 %cmp, label %if.then.22, label %if.end.23

if.then.22:                                       ; preds = %land.lhs.true
  %29 = load %struct._GimpObject*, %struct._GimpObject** %object.addr, align 8
  call void @gimp_object_name_free(%struct._GimpObject* %29)
  br label %if.end.23

if.end.23:                                        ; preds = %if.then.22, %land.lhs.true, %if.end.18
  ret void
}

; Function Attrs: nounwind uwtable
define internal i64 @gimp_image_get_memsize(%struct._GimpObject* %object, i64* %gui_size) #3 {
entry:
  %object.addr = alloca %struct._GimpObject*, align 8
  %gui_size.addr = alloca i64*, align 8
  %image = alloca %struct._GimpImage*, align 8
  %private = alloca %struct._GimpImagePrivate*, align 8
  %memsize = alloca i64, align 8
  store %struct._GimpObject* %object, %struct._GimpObject** %object.addr, align 8
  store i64* %gui_size, i64** %gui_size.addr, align 8
  %0 = load %struct._GimpObject*, %struct._GimpObject** %object.addr, align 8
  %1 = bitcast %struct._GimpObject* %0 to %struct._GTypeInstance*
  %call = call i64 @gimp_image_get_type() #8
  %call1 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %1, i64 %call)
  %2 = bitcast %struct._GTypeInstance* %call1 to %struct._GimpImage*
  store %struct._GimpImage* %2, %struct._GimpImage** %image, align 8
  %3 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  %4 = bitcast %struct._GimpImage* %3 to %struct._GTypeInstance*
  %call2 = call i64 @gimp_image_get_type() #8
  %call3 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %4, i64 %call2)
  %5 = bitcast i8* %call3 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %5, %struct._GimpImagePrivate** %private, align 8
  store i64 0, i64* %memsize, align 8
  %6 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  %call4 = call i8* @gimp_image_get_colormap(%struct._GimpImage* %6)
  %tobool = icmp ne i8* %call4, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %7 = load i64, i64* %memsize, align 8
  %add = add nsw i64 %7, 768
  store i64 %add, i64* %memsize, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %8 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %palette = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %8, i32 0, i32 14
  %9 = load %struct._GimpPalette*, %struct._GimpPalette** %palette, align 8
  %10 = bitcast %struct._GimpPalette* %9 to %struct._GTypeInstance*
  %call5 = call i64 @gimp_object_get_type() #8
  %call6 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %10, i64 %call5)
  %11 = bitcast %struct._GTypeInstance* %call6 to %struct._GimpObject*
  %12 = load i64*, i64** %gui_size.addr, align 8
  %call7 = call i64 @gimp_object_get_memsize(%struct._GimpObject* %11, i64* %12)
  %13 = load i64, i64* %memsize, align 8
  %add8 = add nsw i64 %13, %call7
  store i64 %add8, i64* %memsize, align 8
  %14 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %projection = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %14, i32 0, i32 22
  %15 = load %struct._GimpProjection*, %struct._GimpProjection** %projection, align 8
  %16 = bitcast %struct._GimpProjection* %15 to %struct._GTypeInstance*
  %call9 = call i64 @gimp_object_get_type() #8
  %call10 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %16, i64 %call9)
  %17 = bitcast %struct._GTypeInstance* %call10 to %struct._GimpObject*
  %18 = load i64*, i64** %gui_size.addr, align 8
  %call11 = call i64 @gimp_object_get_memsize(%struct._GimpObject* %17, i64* %18)
  %19 = load i64, i64* %memsize, align 8
  %add12 = add nsw i64 %19, %call11
  store i64 %add12, i64* %memsize, align 8
  %20 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  %call13 = call %struct._GList* @gimp_image_get_guides(%struct._GimpImage* %20)
  %call14 = call i64 @gimp_g_list_get_memsize(%struct._GList* %call13, i64 40)
  %21 = load i64, i64* %memsize, align 8
  %add15 = add nsw i64 %21, %call14
  store i64 %add15, i64* %memsize, align 8
  %22 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %grid = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %22, i32 0, i32 25
  %23 = load %struct._GimpGrid*, %struct._GimpGrid** %grid, align 8
  %24 = bitcast %struct._GimpGrid* %23 to %struct._GTypeInstance*
  %call16 = call i64 @gimp_object_get_type() #8
  %call17 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %24, i64 %call16)
  %25 = bitcast %struct._GTypeInstance* %call17 to %struct._GimpObject*
  %26 = load i64*, i64** %gui_size.addr, align 8
  %call18 = call i64 @gimp_object_get_memsize(%struct._GimpObject* %25, i64* %26)
  %27 = load i64, i64* %memsize, align 8
  %add19 = add nsw i64 %27, %call18
  store i64 %add19, i64* %memsize, align 8
  %28 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  %call20 = call %struct._GList* @gimp_image_get_sample_points(%struct._GimpImage* %28)
  %call21 = call i64 @gimp_g_list_get_memsize(%struct._GList* %call20, i64 16)
  %29 = load i64, i64* %memsize, align 8
  %add22 = add nsw i64 %29, %call21
  store i64 %add22, i64* %memsize, align 8
  %30 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %layers = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %30, i32 0, i32 27
  %31 = load %struct._GimpItemTree*, %struct._GimpItemTree** %layers, align 8
  %32 = bitcast %struct._GimpItemTree* %31 to %struct._GTypeInstance*
  %call23 = call i64 @gimp_object_get_type() #8
  %call24 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %32, i64 %call23)
  %33 = bitcast %struct._GTypeInstance* %call24 to %struct._GimpObject*
  %34 = load i64*, i64** %gui_size.addr, align 8
  %call25 = call i64 @gimp_object_get_memsize(%struct._GimpObject* %33, i64* %34)
  %35 = load i64, i64* %memsize, align 8
  %add26 = add nsw i64 %35, %call25
  store i64 %add26, i64* %memsize, align 8
  %36 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %channels = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %36, i32 0, i32 28
  %37 = load %struct._GimpItemTree*, %struct._GimpItemTree** %channels, align 8
  %38 = bitcast %struct._GimpItemTree* %37 to %struct._GTypeInstance*
  %call27 = call i64 @gimp_object_get_type() #8
  %call28 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %38, i64 %call27)
  %39 = bitcast %struct._GTypeInstance* %call28 to %struct._GimpObject*
  %40 = load i64*, i64** %gui_size.addr, align 8
  %call29 = call i64 @gimp_object_get_memsize(%struct._GimpObject* %39, i64* %40)
  %41 = load i64, i64* %memsize, align 8
  %add30 = add nsw i64 %41, %call29
  store i64 %add30, i64* %memsize, align 8
  %42 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %vectors = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %42, i32 0, i32 29
  %43 = load %struct._GimpItemTree*, %struct._GimpItemTree** %vectors, align 8
  %44 = bitcast %struct._GimpItemTree* %43 to %struct._GTypeInstance*
  %call31 = call i64 @gimp_object_get_type() #8
  %call32 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %44, i64 %call31)
  %45 = bitcast %struct._GTypeInstance* %call32 to %struct._GimpObject*
  %46 = load i64*, i64** %gui_size.addr, align 8
  %call33 = call i64 @gimp_object_get_memsize(%struct._GimpObject* %45, i64* %46)
  %47 = load i64, i64* %memsize, align 8
  %add34 = add nsw i64 %47, %call33
  store i64 %add34, i64* %memsize, align 8
  %48 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %layer_stack = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %48, i32 0, i32 30
  %49 = load %struct._GSList*, %struct._GSList** %layer_stack, align 8
  %call35 = call i64 @gimp_g_slist_get_memsize(%struct._GSList* %49, i64 0)
  %50 = load i64, i64* %memsize, align 8
  %add36 = add nsw i64 %50, %call35
  store i64 %add36, i64* %memsize, align 8
  %51 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %selection_mask = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %51, i32 0, i32 35
  %52 = load %struct._GimpChannel*, %struct._GimpChannel** %selection_mask, align 8
  %53 = bitcast %struct._GimpChannel* %52 to %struct._GTypeInstance*
  %call37 = call i64 @gimp_object_get_type() #8
  %call38 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %53, i64 %call37)
  %54 = bitcast %struct._GTypeInstance* %call38 to %struct._GimpObject*
  %55 = load i64*, i64** %gui_size.addr, align 8
  %call39 = call i64 @gimp_object_get_memsize(%struct._GimpObject* %54, i64* %55)
  %56 = load i64, i64* %memsize, align 8
  %add40 = add nsw i64 %56, %call39
  store i64 %add40, i64* %memsize, align 8
  %57 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %parasites = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %57, i32 0, i32 36
  %58 = load %struct._GimpParasiteList*, %struct._GimpParasiteList** %parasites, align 8
  %59 = bitcast %struct._GimpParasiteList* %58 to %struct._GTypeInstance*
  %call41 = call i64 @gimp_object_get_type() #8
  %call42 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %59, i64 %call41)
  %60 = bitcast %struct._GTypeInstance* %call42 to %struct._GimpObject*
  %61 = load i64*, i64** %gui_size.addr, align 8
  %call43 = call i64 @gimp_object_get_memsize(%struct._GimpObject* %60, i64* %61)
  %62 = load i64, i64* %memsize, align 8
  %add44 = add nsw i64 %62, %call43
  store i64 %add44, i64* %memsize, align 8
  %63 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %undo_stack = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %63, i32 0, i32 42
  %64 = load %struct._GimpUndoStack*, %struct._GimpUndoStack** %undo_stack, align 8
  %65 = bitcast %struct._GimpUndoStack* %64 to %struct._GTypeInstance*
  %call45 = call i64 @gimp_object_get_type() #8
  %call46 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %65, i64 %call45)
  %66 = bitcast %struct._GTypeInstance* %call46 to %struct._GimpObject*
  %67 = load i64*, i64** %gui_size.addr, align 8
  %call47 = call i64 @gimp_object_get_memsize(%struct._GimpObject* %66, i64* %67)
  %68 = load i64, i64* %memsize, align 8
  %add48 = add nsw i64 %68, %call47
  store i64 %add48, i64* %memsize, align 8
  %69 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %redo_stack = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %69, i32 0, i32 43
  %70 = load %struct._GimpUndoStack*, %struct._GimpUndoStack** %redo_stack, align 8
  %71 = bitcast %struct._GimpUndoStack* %70 to %struct._GTypeInstance*
  %call49 = call i64 @gimp_object_get_type() #8
  %call50 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %71, i64 %call49)
  %72 = bitcast %struct._GTypeInstance* %call50 to %struct._GimpObject*
  %73 = load i64*, i64** %gui_size.addr, align 8
  %call51 = call i64 @gimp_object_get_memsize(%struct._GimpObject* %72, i64* %73)
  %74 = load i64, i64* %memsize, align 8
  %add52 = add nsw i64 %74, %call51
  store i64 %add52, i64* %memsize, align 8
  %75 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %preview = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %75, i32 0, i32 46
  %76 = load %struct._TempBuf*, %struct._TempBuf** %preview, align 8
  %call53 = call i64 @temp_buf_get_memsize(%struct._TempBuf* %76)
  %77 = load i64*, i64** %gui_size.addr, align 8
  %78 = load i64, i64* %77, align 8
  %add54 = add i64 %78, %call53
  store i64 %add54, i64* %77, align 8
  %79 = load i64, i64* %memsize, align 8
  %80 = load i8*, i8** @gimp_image_parent_class, align 8
  %81 = bitcast i8* %80 to %struct._GTypeClass*
  %call55 = call i64 @gimp_object_get_type() #8
  %call56 = call %struct._GTypeClass* @g_type_check_class_cast(%struct._GTypeClass* %81, i64 %call55)
  %82 = bitcast %struct._GTypeClass* %call56 to %struct._GimpObjectClass*
  %get_memsize = getelementptr inbounds %struct._GimpObjectClass, %struct._GimpObjectClass* %82, i32 0, i32 3
  %83 = load i64 (%struct._GimpObject*, i64*)*, i64 (%struct._GimpObject*, i64*)** %get_memsize, align 8
  %84 = load %struct._GimpObject*, %struct._GimpObject** %object.addr, align 8
  %85 = load i64*, i64** %gui_size.addr, align 8
  %call57 = call i64 %83(%struct._GimpObject* %84, i64* %85)
  %add58 = add nsw i64 %79, %call57
  ret i64 %add58
}

; Function Attrs: nounwind uwtable
define internal i32 @gimp_image_get_size(%struct._GimpViewable* %viewable, i32* %width, i32* %height) #3 {
entry:
  %viewable.addr = alloca %struct._GimpViewable*, align 8
  %width.addr = alloca i32*, align 8
  %height.addr = alloca i32*, align 8
  %image = alloca %struct._GimpImage*, align 8
  store %struct._GimpViewable* %viewable, %struct._GimpViewable** %viewable.addr, align 8
  store i32* %width, i32** %width.addr, align 8
  store i32* %height, i32** %height.addr, align 8
  %0 = load %struct._GimpViewable*, %struct._GimpViewable** %viewable.addr, align 8
  %1 = bitcast %struct._GimpViewable* %0 to %struct._GTypeInstance*
  %call = call i64 @gimp_image_get_type() #8
  %call1 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %1, i64 %call)
  %2 = bitcast %struct._GTypeInstance* %call1 to %struct._GimpImage*
  store %struct._GimpImage* %2, %struct._GimpImage** %image, align 8
  %3 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  %call2 = call i32 @gimp_image_get_width(%struct._GimpImage* %3)
  %4 = load i32*, i32** %width.addr, align 8
  store i32 %call2, i32* %4, align 4
  %5 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  %call3 = call i32 @gimp_image_get_height(%struct._GimpImage* %5)
  %6 = load i32*, i32** %height.addr, align 8
  store i32 %call3, i32* %6, align 4
  ret i32 1
}

; Function Attrs: nounwind uwtable
define internal void @gimp_image_invalidate_preview(%struct._GimpViewable* %viewable) #3 {
entry:
  %viewable.addr = alloca %struct._GimpViewable*, align 8
  %private = alloca %struct._GimpImagePrivate*, align 8
  store %struct._GimpViewable* %viewable, %struct._GimpViewable** %viewable.addr, align 8
  %0 = load %struct._GimpViewable*, %struct._GimpViewable** %viewable.addr, align 8
  %1 = bitcast %struct._GimpViewable* %0 to %struct._GTypeInstance*
  %call = call i64 @gimp_image_get_type() #8
  %call1 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %1, i64 %call)
  %2 = bitcast i8* %call1 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %2, %struct._GimpImagePrivate** %private, align 8
  %3 = load i8*, i8** @gimp_image_parent_class, align 8
  %4 = bitcast i8* %3 to %struct._GTypeClass*
  %call2 = call i64 @gimp_viewable_get_type() #8
  %call3 = call %struct._GTypeClass* @g_type_check_class_cast(%struct._GTypeClass* %4, i64 %call2)
  %5 = bitcast %struct._GTypeClass* %call3 to %struct._GimpViewableClass*
  %invalidate_preview = getelementptr inbounds %struct._GimpViewableClass, %struct._GimpViewableClass* %5, i32 0, i32 3
  %6 = load void (%struct._GimpViewable*)*, void (%struct._GimpViewable*)** %invalidate_preview, align 8
  %7 = load %struct._GimpViewable*, %struct._GimpViewable** %viewable.addr, align 8
  call void %6(%struct._GimpViewable* %7)
  %8 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %preview = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %8, i32 0, i32 46
  %9 = load %struct._TempBuf*, %struct._TempBuf** %preview, align 8
  %tobool = icmp ne %struct._TempBuf* %9, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %10 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %preview4 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %10, i32 0, i32 46
  %11 = load %struct._TempBuf*, %struct._TempBuf** %preview4, align 8
  call void @temp_buf_free(%struct._TempBuf* %11)
  %12 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %preview5 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %12, i32 0, i32 46
  store %struct._TempBuf* null, %struct._TempBuf** %preview5, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @gimp_image_size_changed(%struct._GimpViewable* %viewable) #3 {
entry:
  %viewable.addr = alloca %struct._GimpViewable*, align 8
  %image = alloca %struct._GimpImage*, align 8
  %all_items = alloca %struct._GList*, align 8
  %list = alloca %struct._GList*, align 8
  %mask = alloca %struct._GimpLayerMask*, align 8
  store %struct._GimpViewable* %viewable, %struct._GimpViewable** %viewable.addr, align 8
  %0 = load %struct._GimpViewable*, %struct._GimpViewable** %viewable.addr, align 8
  %1 = bitcast %struct._GimpViewable* %0 to %struct._GTypeInstance*
  %call = call i64 @gimp_image_get_type() #8
  %call1 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %1, i64 %call)
  %2 = bitcast %struct._GTypeInstance* %call1 to %struct._GimpImage*
  store %struct._GimpImage* %2, %struct._GimpImage** %image, align 8
  %3 = load i8*, i8** @gimp_image_parent_class, align 8
  %4 = bitcast i8* %3 to %struct._GTypeClass*
  %call2 = call i64 @gimp_viewable_get_type() #8
  %call3 = call %struct._GTypeClass* @g_type_check_class_cast(%struct._GTypeClass* %4, i64 %call2)
  %5 = bitcast %struct._GTypeClass* %call3 to %struct._GimpViewableClass*
  %size_changed = getelementptr inbounds %struct._GimpViewableClass, %struct._GimpViewableClass* %5, i32 0, i32 4
  %6 = load void (%struct._GimpViewable*)*, void (%struct._GimpViewable*)** %size_changed, align 8
  %tobool = icmp ne void (%struct._GimpViewable*)* %6, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %7 = load i8*, i8** @gimp_image_parent_class, align 8
  %8 = bitcast i8* %7 to %struct._GTypeClass*
  %call4 = call i64 @gimp_viewable_get_type() #8
  %call5 = call %struct._GTypeClass* @g_type_check_class_cast(%struct._GTypeClass* %8, i64 %call4)
  %9 = bitcast %struct._GTypeClass* %call5 to %struct._GimpViewableClass*
  %size_changed6 = getelementptr inbounds %struct._GimpViewableClass, %struct._GimpViewableClass* %9, i32 0, i32 4
  %10 = load void (%struct._GimpViewable*)*, void (%struct._GimpViewable*)** %size_changed6, align 8
  %11 = load %struct._GimpViewable*, %struct._GimpViewable** %viewable.addr, align 8
  call void %10(%struct._GimpViewable* %11)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %12 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  %call7 = call %struct._GList* @gimp_image_get_layer_list(%struct._GimpImage* %12)
  store %struct._GList* %call7, %struct._GList** %all_items, align 8
  %13 = load %struct._GList*, %struct._GList** %all_items, align 8
  store %struct._GList* %13, %struct._GList** %list, align 8
  br label %for.cond

for.cond:                                         ; preds = %cond.end, %if.end
  %14 = load %struct._GList*, %struct._GList** %list, align 8
  %tobool8 = icmp ne %struct._GList* %14, null
  br i1 %tobool8, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %15 = load %struct._GList*, %struct._GList** %list, align 8
  %data = getelementptr inbounds %struct._GList, %struct._GList* %15, i32 0, i32 0
  %16 = load i8*, i8** %data, align 8
  %17 = bitcast i8* %16 to %struct._GTypeInstance*
  %call9 = call i64 @gimp_layer_get_type() #8
  %call10 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %17, i64 %call9)
  %18 = bitcast %struct._GTypeInstance* %call10 to %struct._GimpLayer*
  %call11 = call %struct._GimpLayerMask* @gimp_layer_get_mask(%struct._GimpLayer* %18)
  store %struct._GimpLayerMask* %call11, %struct._GimpLayerMask** %mask, align 8
  %19 = load %struct._GList*, %struct._GList** %list, align 8
  %data12 = getelementptr inbounds %struct._GList, %struct._GList* %19, i32 0, i32 0
  %20 = load i8*, i8** %data12, align 8
  %21 = bitcast i8* %20 to %struct._GTypeInstance*
  %call13 = call i64 @gimp_viewable_get_type() #8
  %call14 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %21, i64 %call13)
  %22 = bitcast %struct._GTypeInstance* %call14 to %struct._GimpViewable*
  call void @gimp_viewable_size_changed(%struct._GimpViewable* %22)
  %23 = load %struct._GimpLayerMask*, %struct._GimpLayerMask** %mask, align 8
  %tobool15 = icmp ne %struct._GimpLayerMask* %23, null
  br i1 %tobool15, label %if.then.16, label %if.end.19

if.then.16:                                       ; preds = %for.body
  %24 = load %struct._GimpLayerMask*, %struct._GimpLayerMask** %mask, align 8
  %25 = bitcast %struct._GimpLayerMask* %24 to %struct._GTypeInstance*
  %call17 = call i64 @gimp_viewable_get_type() #8
  %call18 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %25, i64 %call17)
  %26 = bitcast %struct._GTypeInstance* %call18 to %struct._GimpViewable*
  call void @gimp_viewable_size_changed(%struct._GimpViewable* %26)
  br label %if.end.19

if.end.19:                                        ; preds = %if.then.16, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end.19
  %27 = load %struct._GList*, %struct._GList** %list, align 8
  %tobool20 = icmp ne %struct._GList* %27, null
  br i1 %tobool20, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.inc
  %28 = load %struct._GList*, %struct._GList** %list, align 8
  %next = getelementptr inbounds %struct._GList, %struct._GList* %28, i32 0, i32 1
  %29 = load %struct._GList*, %struct._GList** %next, align 8
  br label %cond.end

cond.false:                                       ; preds = %for.inc
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct._GList* [ %29, %cond.true ], [ null, %cond.false ]
  store %struct._GList* %cond, %struct._GList** %list, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %30 = load %struct._GList*, %struct._GList** %all_items, align 8
  call void @g_list_free(%struct._GList* %30)
  %31 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  %call21 = call %struct._GList* @gimp_image_get_channel_list(%struct._GimpImage* %31)
  store %struct._GList* %call21, %struct._GList** %all_items, align 8
  %32 = load %struct._GList*, %struct._GList** %all_items, align 8
  call void @g_list_free_full(%struct._GList* %32, void (i8*)* bitcast (void (%struct._GimpViewable*)* @gimp_viewable_size_changed to void (i8*)*))
  %33 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  %call22 = call %struct._GList* @gimp_image_get_vectors_list(%struct._GimpImage* %33)
  store %struct._GList* %call22, %struct._GList** %all_items, align 8
  %34 = load %struct._GList*, %struct._GList** %all_items, align 8
  call void @g_list_free_full(%struct._GList* %34, void (i8*)* bitcast (void (%struct._GimpViewable*)* @gimp_viewable_size_changed to void (i8*)*))
  %35 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  %call23 = call %struct._GimpChannel* @gimp_image_get_mask(%struct._GimpImage* %35)
  %36 = bitcast %struct._GimpChannel* %call23 to %struct._GTypeInstance*
  %call24 = call i64 @gimp_viewable_get_type() #8
  %call25 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %36, i64 %call24)
  %37 = bitcast %struct._GTypeInstance* %call25 to %struct._GimpViewable*
  call void @gimp_viewable_size_changed(%struct._GimpViewable* %37)
  %38 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  %39 = bitcast %struct._GimpImage* %38 to %struct._GTypeInstance*
  %call26 = call i64 @gimp_projectable_interface_get_type() #8
  %call27 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %39, i64 %call26)
  %40 = bitcast %struct._GTypeInstance* %call27 to %struct._GimpProjectable*
  call void @gimp_projectable_structure_changed(%struct._GimpProjectable* %40)
  ret void
}

declare void @gimp_image_get_preview_size(%struct._GimpViewable*, i32, i32, i32, i32*, i32*) #1

declare i32 @gimp_image_get_popup_size(%struct._GimpViewable*, i32, i32, i32, i32*, i32*) #1

declare %struct._TempBuf* @gimp_image_get_preview(%struct._GimpViewable*, %struct._GimpContext*, i32, i32) #1

declare %struct._TempBuf* @gimp_image_get_new_preview(%struct._GimpViewable*, %struct._GimpContext*, i32, i32) #1

; Function Attrs: nounwind uwtable
define internal i8* @gimp_image_get_description(%struct._GimpViewable* %viewable, i8** %tooltip) #3 {
entry:
  %viewable.addr = alloca %struct._GimpViewable*, align 8
  %tooltip.addr = alloca i8**, align 8
  %image = alloca %struct._GimpImage*, align 8
  store %struct._GimpViewable* %viewable, %struct._GimpViewable** %viewable.addr, align 8
  store i8** %tooltip, i8*** %tooltip.addr, align 8
  %0 = load %struct._GimpViewable*, %struct._GimpViewable** %viewable.addr, align 8
  %1 = bitcast %struct._GimpViewable* %0 to %struct._GTypeInstance*
  %call = call i64 @gimp_image_get_type() #8
  %call1 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %1, i64 %call)
  %2 = bitcast %struct._GTypeInstance* %call1 to %struct._GimpImage*
  store %struct._GimpImage* %2, %struct._GimpImage** %image, align 8
  %3 = load i8**, i8*** %tooltip.addr, align 8
  %tobool = icmp ne i8** %3, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  %call2 = call i8* @gimp_image_get_display_path(%struct._GimpImage* %4)
  %call3 = call noalias i8* @g_strdup(i8* %call2)
  %5 = load i8**, i8*** %tooltip.addr, align 8
  store i8* %call3, i8** %5, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  %call4 = call i8* @gimp_image_get_display_name(%struct._GimpImage* %6)
  %7 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  %call5 = call i32 @gimp_image_get_ID(%struct._GimpImage* %7)
  %call6 = call noalias i8* (i8*, ...) @g_strdup_printf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.112, i32 0, i32 0), i8* %call4, i32 %call5)
  ret i8* %call6
}

; Function Attrs: nounwind uwtable
define internal void @gimp_image_real_mode_changed(%struct._GimpImage* %image) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  %call = call i64 @gimp_projectable_interface_get_type() #8
  %call1 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %1, i64 %call)
  %2 = bitcast %struct._GTypeInstance* %call1 to %struct._GimpProjectable*
  call void @gimp_projectable_structure_changed(%struct._GimpProjectable* %2)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @gimp_image_real_size_changed_detailed(%struct._GimpImage* %image, i32 %previous_origin_x, i32 %previous_origin_y, i32 %previous_width, i32 %previous_height) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %previous_origin_x.addr = alloca i32, align 4
  %previous_origin_y.addr = alloca i32, align 4
  %previous_width.addr = alloca i32, align 4
  %previous_height.addr = alloca i32, align 4
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store i32 %previous_origin_x, i32* %previous_origin_x.addr, align 4
  store i32 %previous_origin_y, i32* %previous_origin_y.addr, align 4
  store i32 %previous_width, i32* %previous_width.addr, align 4
  store i32 %previous_height, i32* %previous_height.addr, align 4
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  %call = call i64 @gimp_viewable_get_type() #8
  %call1 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %1, i64 %call)
  %2 = bitcast %struct._GTypeInstance* %call1 to %struct._GimpViewable*
  call void @gimp_viewable_size_changed(%struct._GimpViewable* %2)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @gimp_image_real_colormap_changed(%struct._GimpImage* %image, i32 %color_index) #3 {
entry:
  %image.addr = alloca %struct._GimpImage*, align 8
  %color_index.addr = alloca i32, align 4
  %private = alloca %struct._GimpImagePrivate*, align 8
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  store i32 %color_index, i32* %color_index.addr, align 4
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call = call i32 @gimp_image_base_type(%struct._GimpImage* %0)
  %cmp = icmp eq i32 %call, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %2 = bitcast %struct._GimpImage* %1 to %struct._GTypeInstance*
  %call1 = call i64 @gimp_image_get_type() #8
  %call2 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %2, i64 %call1)
  %3 = bitcast i8* %call2 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %3, %struct._GimpImagePrivate** %private, align 8
  %4 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %5 = load i32, i32* %color_index.addr, align 4
  call void @gimp_image_color_hash_invalidate(%struct._GimpImage* %4, i32 %5)
  %6 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %7 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call3 = call i32 @gimp_image_get_width(%struct._GimpImage* %7)
  %8 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call4 = call i32 @gimp_image_get_height(%struct._GimpImage* %8)
  call void @gimp_image_invalidate(%struct._GimpImage* %6, i32 0, i32 0, i32 %call3, i32 %call4)
  %9 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %layers = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %9, i32 0, i32 27
  %10 = load %struct._GimpItemTree*, %struct._GimpItemTree** %layers, align 8
  %container = getelementptr inbounds %struct._GimpItemTree, %struct._GimpItemTree* %10, i32 0, i32 1
  %11 = load %struct._GimpContainer*, %struct._GimpContainer** %container, align 8
  %12 = bitcast %struct._GimpContainer* %11 to %struct._GTypeInstance*
  %call5 = call i64 @gimp_item_stack_get_type() #8
  %call6 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %12, i64 %call5)
  %13 = bitcast %struct._GTypeInstance* %call6 to %struct._GimpItemStack*
  call void @gimp_item_stack_invalidate_previews(%struct._GimpItemStack* %13)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @g_object_class_install_property(%struct._GObjectClass*, i32, %struct._GParamSpec*) #1

declare %struct._GParamSpec* @g_param_spec_object(i8*, i8*, i8*, i64, i32) #1

declare %struct._GParamSpec* @g_param_spec_int(i8*, i8*, i8*, i32, i32, i32, i32) #1

declare %struct._GParamSpec* @g_param_spec_enum(i8*, i8*, i8*, i64, i32, i32) #1

; Function Attrs: nounwind readnone
declare i64 @gimp_image_base_type_get_type() #2

declare void @gimp_image_color_hash_init() #1

declare void @g_type_class_add_private(i8*, i64) #1

; Function Attrs: noreturn
declare void @g_assertion_message_expr(i8*, i8*, i32, i8*, i8*) #7

declare i32 @gimp_id_table_insert(%struct._GimpIdTable*, i8*) #1

declare double @gimp_template_get_resolution_x(%struct._GimpTemplate*) #1

declare double @gimp_template_get_resolution_y(%struct._GimpTemplate*) #1

declare i32 @gimp_template_get_resolution_unit(%struct._GimpTemplate*) #1

declare i8* @gimp_config_duplicate(%struct._GimpConfig*) #1

; Function Attrs: nounwind readnone
declare i64 @gimp_config_interface_get_type() #2

declare void @gimp_image_colormap_init(%struct._GimpImage*) #1

declare %struct._GimpChannel* @gimp_selection_new(%struct._GimpImage*, i32, i32) #1

declare i64 @g_signal_connect_object(i8*, i8*, void ()*, i8*, i32) #1

declare void @gimp_viewable_size_changed(%struct._GimpViewable*) #1

declare i32 @gimp_container_add(%struct._GimpContainer*, %struct._GimpObject*) #1

declare i8* @g_value_get_object(%struct._GValue*) #1

declare i32 @g_value_get_int(%struct._GValue*) #1

declare i32 @g_value_get_enum(%struct._GValue*) #1

declare i8* @g_type_name(i64) #1

declare void @g_value_set_object(%struct._GValue*, i8*) #1

declare void @g_value_set_int(%struct._GValue*, i32) #1

declare void @g_value_set_enum(%struct._GValue*, i32) #1

declare void @gimp_image_colormap_dispose(%struct._GimpImage*) #1

declare void @gimp_image_undo_free(%struct._GimpImage*) #1

declare i32 @g_signal_handlers_disconnect_matched(i8*, i32, i32, i32, %struct._GClosure*, i8*, i8*) #1

declare void @gimp_container_remove_handler(%struct._GimpContainer*, i32) #1

; Function Attrs: nounwind uwtable
define internal void @gimp_image_channel_add(%struct._GimpContainer* %container, %struct._GimpChannel* %channel, %struct._GimpImage* %image) #3 {
entry:
  %container.addr = alloca %struct._GimpContainer*, align 8
  %channel.addr = alloca %struct._GimpChannel*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  store %struct._GimpContainer* %container, %struct._GimpContainer** %container.addr, align 8
  store %struct._GimpChannel* %channel, %struct._GimpChannel** %channel.addr, align 8
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  %0 = load %struct._GimpChannel*, %struct._GimpChannel** %channel.addr, align 8
  %1 = bitcast %struct._GimpChannel* %0 to i8*
  %call = call i8* @gimp_object_get_name(i8* %1)
  %call1 = call i32 @strcmp(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.111, i32 0, i32 0), i8* %call) #9
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  call void @gimp_image_set_quick_mask_state(%struct._GimpImage* %2, i32 1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @gimp_image_channel_remove(%struct._GimpContainer* %container, %struct._GimpChannel* %channel, %struct._GimpImage* %image) #3 {
entry:
  %container.addr = alloca %struct._GimpContainer*, align 8
  %channel.addr = alloca %struct._GimpChannel*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  store %struct._GimpContainer* %container, %struct._GimpContainer** %container.addr, align 8
  store %struct._GimpChannel* %channel, %struct._GimpChannel** %channel.addr, align 8
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  %0 = load %struct._GimpChannel*, %struct._GimpChannel** %channel.addr, align 8
  %1 = bitcast %struct._GimpChannel* %0 to i8*
  %call = call i8* @gimp_object_get_name(i8* %1)
  %call1 = call i32 @strcmp(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.111, i32 0, i32 0), i8* %call) #9
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  call void @gimp_image_set_quick_mask_state(%struct._GimpImage* %2, i32 0)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare void @gimp_container_foreach(%struct._GimpContainer*, void (i8*, i8*)*, i8*) #1

declare void @gimp_item_removed(%struct._GimpItem*) #1

declare void @gimp_image_set_quick_mask_state(%struct._GimpImage*, i32) #1

declare void @gimp_image_colormap_free(%struct._GimpImage*) #1

declare void @g_slist_free(%struct._GSList*) #1

declare void @temp_buf_free(%struct._TempBuf*) #1

declare void @g_list_free_full(%struct._GList*, void (i8*)*) #1

declare void @gimp_sample_point_unref(%struct._GimpSamplePoint*) #1

declare i32 @gimp_id_table_remove(%struct._GimpIdTable*, i32) #1

declare void @gimp_object_name_free(%struct._GimpObject*) #1

declare i8* @gimp_image_get_colormap(%struct._GimpImage*) #1

declare i64 @gimp_object_get_memsize(%struct._GimpObject*, i64*) #1

declare i64 @gimp_g_list_get_memsize(%struct._GList*, i64) #1

declare %struct._GList* @gimp_image_get_guides(%struct._GimpImage*) #1

declare %struct._GList* @gimp_image_get_sample_points(%struct._GimpImage*) #1

declare i64 @gimp_g_slist_get_memsize(%struct._GSList*, i64) #1

declare i64 @temp_buf_get_memsize(%struct._TempBuf*) #1

declare void @gimp_projectable_structure_changed(%struct._GimpProjectable*) #1

declare noalias i8* @g_strdup_printf(i8*, ...) #1

declare void @gimp_image_color_hash_invalidate(%struct._GimpImage*, i32) #1

; Function Attrs: nounwind uwtable
define internal i8* @gimp_image_get_icc_profile(%struct._GimpColorManaged* %managed, i64* %len) #3 {
entry:
  %retval = alloca i8*, align 8
  %managed.addr = alloca %struct._GimpColorManaged*, align 8
  %len.addr = alloca i64*, align 8
  %parasite = alloca %struct._GimpParasite*, align 8
  %data_size = alloca i64, align 8
  store %struct._GimpColorManaged* %managed, %struct._GimpColorManaged** %managed.addr, align 8
  store i64* %len, i64** %len.addr, align 8
  %0 = load %struct._GimpColorManaged*, %struct._GimpColorManaged** %managed.addr, align 8
  %1 = bitcast %struct._GimpColorManaged* %0 to %struct._GTypeInstance*
  %call = call i64 @gimp_image_get_type() #8
  %call1 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %1, i64 %call)
  %2 = bitcast %struct._GTypeInstance* %call1 to %struct._GimpImage*
  %call2 = call %struct._GimpParasite* @gimp_image_parasite_find(%struct._GimpImage* %2, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.39, i32 0, i32 0))
  store %struct._GimpParasite* %call2, %struct._GimpParasite** %parasite, align 8
  %3 = load %struct._GimpParasite*, %struct._GimpParasite** %parasite, align 8
  %tobool = icmp ne %struct._GimpParasite* %3, null
  br i1 %tobool, label %if.then, label %if.end.6

if.then:                                          ; preds = %entry
  %4 = load %struct._GimpParasite*, %struct._GimpParasite** %parasite, align 8
  %call3 = call i64 @gimp_parasite_data_size(%struct._GimpParasite* %4)
  store i64 %call3, i64* %data_size, align 8
  %5 = load i64, i64* %data_size, align 8
  %cmp = icmp ugt i64 %5, 0
  br i1 %cmp, label %if.then.4, label %if.end

if.then.4:                                        ; preds = %if.then
  %6 = load i64, i64* %data_size, align 8
  %7 = load i64*, i64** %len.addr, align 8
  store i64 %6, i64* %7, align 8
  %8 = load %struct._GimpParasite*, %struct._GimpParasite** %parasite, align 8
  %call5 = call i8* @gimp_parasite_data(%struct._GimpParasite* %8)
  store i8* %call5, i8** %retval
  br label %return

if.end:                                           ; preds = %if.then
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %entry
  store i8* null, i8** %retval
  br label %return

return:                                           ; preds = %if.end.6, %if.then.4
  %9 = load i8*, i8** %retval
  ret i8* %9
}

declare i64 @gimp_parasite_data_size(%struct._GimpParasite*) #1

declare i8* @gimp_parasite_data(%struct._GimpParasite*) #1

; Function Attrs: nounwind uwtable
define internal void @gimp_image_projectable_flush(%struct._GimpProjectable* %projectable, i32 %invalidate_preview) #3 {
entry:
  %projectable.addr = alloca %struct._GimpProjectable*, align 8
  %invalidate_preview.addr = alloca i32, align 4
  %image = alloca %struct._GimpImage*, align 8
  %private = alloca %struct._GimpImagePrivate*, align 8
  store %struct._GimpProjectable* %projectable, %struct._GimpProjectable** %projectable.addr, align 8
  store i32 %invalidate_preview, i32* %invalidate_preview.addr, align 4
  %0 = load %struct._GimpProjectable*, %struct._GimpProjectable** %projectable.addr, align 8
  %1 = bitcast %struct._GimpProjectable* %0 to %struct._GTypeInstance*
  %call = call i64 @gimp_image_get_type() #8
  %call1 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %1, i64 %call)
  %2 = bitcast %struct._GTypeInstance* %call1 to %struct._GimpImage*
  store %struct._GimpImage* %2, %struct._GimpImage** %image, align 8
  %3 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  %4 = bitcast %struct._GimpImage* %3 to %struct._GTypeInstance*
  %call2 = call i64 @gimp_image_get_type() #8
  %call3 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %4, i64 %call2)
  %5 = bitcast i8* %call3 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %5, %struct._GimpImagePrivate** %private, align 8
  %6 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %flush_accum = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %6, i32 0, i32 47
  %alpha_changed = getelementptr inbounds %struct._GimpImageFlushAccumulator, %struct._GimpImageFlushAccumulator* %flush_accum, i32 0, i32 0
  %7 = load i32, i32* %alpha_changed, align 4
  %tobool = icmp ne i32 %7, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %8 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  call void @gimp_image_alpha_changed(%struct._GimpImage* %8)
  %9 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %flush_accum4 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %9, i32 0, i32 47
  %alpha_changed5 = getelementptr inbounds %struct._GimpImageFlushAccumulator, %struct._GimpImageFlushAccumulator* %flush_accum4, i32 0, i32 0
  store i32 0, i32* %alpha_changed5, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %10 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %flush_accum6 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %10, i32 0, i32 47
  %mask_changed = getelementptr inbounds %struct._GimpImageFlushAccumulator, %struct._GimpImageFlushAccumulator* %flush_accum6, i32 0, i32 1
  %11 = load i32, i32* %mask_changed, align 4
  %tobool7 = icmp ne i32 %11, 0
  br i1 %tobool7, label %if.then.8, label %if.end.11

if.then.8:                                        ; preds = %if.end
  %12 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  call void @gimp_image_mask_changed(%struct._GimpImage* %12)
  %13 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %flush_accum9 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %13, i32 0, i32 47
  %mask_changed10 = getelementptr inbounds %struct._GimpImageFlushAccumulator, %struct._GimpImageFlushAccumulator* %flush_accum9, i32 0, i32 1
  store i32 0, i32* %mask_changed10, align 4
  br label %if.end.11

if.end.11:                                        ; preds = %if.then.8, %if.end
  %14 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %flush_accum12 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %14, i32 0, i32 47
  %floating_selection_changed = getelementptr inbounds %struct._GimpImageFlushAccumulator, %struct._GimpImageFlushAccumulator* %flush_accum12, i32 0, i32 2
  %15 = load i32, i32* %floating_selection_changed, align 4
  %tobool13 = icmp ne i32 %15, 0
  br i1 %tobool13, label %if.then.14, label %if.end.17

if.then.14:                                       ; preds = %if.end.11
  %16 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  call void @gimp_image_floating_selection_changed(%struct._GimpImage* %16)
  %17 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %flush_accum15 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %17, i32 0, i32 47
  %floating_selection_changed16 = getelementptr inbounds %struct._GimpImageFlushAccumulator, %struct._GimpImageFlushAccumulator* %flush_accum15, i32 0, i32 2
  store i32 0, i32* %floating_selection_changed16, align 4
  br label %if.end.17

if.end.17:                                        ; preds = %if.then.14, %if.end.11
  %18 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %flush_accum18 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %18, i32 0, i32 47
  %preview_invalidated = getelementptr inbounds %struct._GimpImageFlushAccumulator, %struct._GimpImageFlushAccumulator* %flush_accum18, i32 0, i32 3
  %19 = load i32, i32* %preview_invalidated, align 4
  %tobool19 = icmp ne i32 %19, 0
  br i1 %tobool19, label %if.then.20, label %if.end.23

if.then.20:                                       ; preds = %if.end.17
  %20 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %flush_accum21 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %20, i32 0, i32 47
  %preview_invalidated22 = getelementptr inbounds %struct._GimpImageFlushAccumulator, %struct._GimpImageFlushAccumulator* %flush_accum21, i32 0, i32 3
  store i32 0, i32* %preview_invalidated22, align 4
  br label %if.end.23

if.end.23:                                        ; preds = %if.then.20, %if.end.17
  ret void
}

; Function Attrs: nounwind uwtable
define internal %struct._GimpImage* @gimp_image_get_image(%struct._GimpProjectable* %projectable) #3 {
entry:
  %projectable.addr = alloca %struct._GimpProjectable*, align 8
  store %struct._GimpProjectable* %projectable, %struct._GimpProjectable** %projectable.addr, align 8
  %0 = load %struct._GimpProjectable*, %struct._GimpProjectable** %projectable.addr, align 8
  %1 = bitcast %struct._GimpProjectable* %0 to %struct._GTypeInstance*
  %call = call i64 @gimp_image_get_type() #8
  %call1 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %1, i64 %call)
  %2 = bitcast %struct._GTypeInstance* %call1 to %struct._GimpImage*
  ret %struct._GimpImage* %2
}

; Function Attrs: nounwind uwtable
define internal i32 @gimp_image_get_image_type(%struct._GimpProjectable* %projectable) #3 {
entry:
  %projectable.addr = alloca %struct._GimpProjectable*, align 8
  %private = alloca %struct._GimpImagePrivate*, align 8
  %type = alloca i32, align 4
  store %struct._GimpProjectable* %projectable, %struct._GimpProjectable** %projectable.addr, align 8
  %0 = load %struct._GimpProjectable*, %struct._GimpProjectable** %projectable.addr, align 8
  %1 = bitcast %struct._GimpProjectable* %0 to %struct._GTypeInstance*
  %call = call i64 @gimp_image_get_type() #8
  %call1 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %1, i64 %call)
  %2 = bitcast i8* %call1 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %2, %struct._GimpImagePrivate** %private, align 8
  %3 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %base_type = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %3, i32 0, i32 11
  %4 = load i32, i32* %base_type, align 4
  %cmp = icmp eq i32 %4, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end.9

cond.false:                                       ; preds = %entry
  %5 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %base_type2 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %5, i32 0, i32 11
  %6 = load i32, i32* %base_type2, align 4
  %cmp3 = icmp eq i32 %6, 1
  br i1 %cmp3, label %cond.true.4, label %cond.false.5

cond.true.4:                                      ; preds = %cond.false
  br label %cond.end

cond.false.5:                                     ; preds = %cond.false
  %7 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %base_type6 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %7, i32 0, i32 11
  %8 = load i32, i32* %base_type6, align 4
  %cmp7 = icmp eq i32 %8, 2
  %cond = select i1 %cmp7, i32 4, i32 -1
  br label %cond.end

cond.end:                                         ; preds = %cond.false.5, %cond.true.4
  %cond8 = phi i32 [ 2, %cond.true.4 ], [ %cond, %cond.false.5 ]
  br label %cond.end.9

cond.end.9:                                       ; preds = %cond.end, %cond.true
  %cond10 = phi i32 [ 0, %cond.true ], [ %cond8, %cond.end ]
  store i32 %cond10, i32* %type, align 4
  %9 = load i32, i32* %type, align 4
  %cmp11 = icmp eq i32 %9, 0
  br i1 %cmp11, label %cond.true.13, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end.9
  %10 = load i32, i32* %type, align 4
  %cmp12 = icmp eq i32 %10, 1
  br i1 %cmp12, label %cond.true.13, label %cond.false.14

cond.true.13:                                     ; preds = %lor.lhs.false, %cond.end.9
  br label %cond.end.25

cond.false.14:                                    ; preds = %lor.lhs.false
  %11 = load i32, i32* %type, align 4
  %cmp15 = icmp eq i32 %11, 2
  br i1 %cmp15, label %cond.true.18, label %lor.lhs.false.16

lor.lhs.false.16:                                 ; preds = %cond.false.14
  %12 = load i32, i32* %type, align 4
  %cmp17 = icmp eq i32 %12, 3
  br i1 %cmp17, label %cond.true.18, label %cond.false.19

cond.true.18:                                     ; preds = %lor.lhs.false.16, %cond.false.14
  br label %cond.end.23

cond.false.19:                                    ; preds = %lor.lhs.false.16
  %13 = load i32, i32* %type, align 4
  %cmp20 = icmp eq i32 %13, 4
  br i1 %cmp20, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %cond.false.19
  %14 = load i32, i32* %type, align 4
  %cmp21 = icmp eq i32 %14, 5
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %cond.false.19
  %15 = phi i1 [ true, %cond.false.19 ], [ %cmp21, %lor.rhs ]
  %cond22 = select i1 %15, i32 5, i32 -1
  br label %cond.end.23

cond.end.23:                                      ; preds = %lor.end, %cond.true.18
  %cond24 = phi i32 [ 3, %cond.true.18 ], [ %cond22, %lor.end ]
  br label %cond.end.25

cond.end.25:                                      ; preds = %cond.end.23, %cond.true.13
  %cond26 = phi i32 [ 1, %cond.true.13 ], [ %cond24, %cond.end.23 ]
  ret i32 %cond26
}

; Function Attrs: nounwind uwtable
define internal %struct._GeglNode* @gimp_image_get_graph(%struct._GimpProjectable* %projectable) #3 {
entry:
  %retval = alloca %struct._GeglNode*, align 8
  %projectable.addr = alloca %struct._GimpProjectable*, align 8
  %image = alloca %struct._GimpImage*, align 8
  %private = alloca %struct._GimpImagePrivate*, align 8
  %layers_node = alloca %struct._GeglNode*, align 8
  %channels_node = alloca %struct._GeglNode*, align 8
  %blend_node = alloca %struct._GeglNode*, align 8
  %output = alloca %struct._GeglNode*, align 8
  store %struct._GimpProjectable* %projectable, %struct._GimpProjectable** %projectable.addr, align 8
  %0 = load %struct._GimpProjectable*, %struct._GimpProjectable** %projectable.addr, align 8
  %1 = bitcast %struct._GimpProjectable* %0 to %struct._GTypeInstance*
  %call = call i64 @gimp_image_get_type() #8
  %call1 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %1, i64 %call)
  %2 = bitcast %struct._GTypeInstance* %call1 to %struct._GimpImage*
  store %struct._GimpImage* %2, %struct._GimpImage** %image, align 8
  %3 = load %struct._GimpImage*, %struct._GimpImage** %image, align 8
  %4 = bitcast %struct._GimpImage* %3 to %struct._GTypeInstance*
  %call2 = call i64 @gimp_image_get_type() #8
  %call3 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %4, i64 %call2)
  %5 = bitcast i8* %call3 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %5, %struct._GimpImagePrivate** %private, align 8
  %6 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %graph = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %6, i32 0, i32 23
  %7 = load %struct._GeglNode*, %struct._GeglNode** %graph, align 8
  %tobool = icmp ne %struct._GeglNode* %7, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %8 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %graph4 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %8, i32 0, i32 23
  %9 = load %struct._GeglNode*, %struct._GeglNode** %graph4, align 8
  store %struct._GeglNode* %9, %struct._GeglNode** %retval
  br label %return

if.end:                                           ; preds = %entry
  %call5 = call %struct._GeglNode* @gegl_node_new()
  %10 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %graph6 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %10, i32 0, i32 23
  store %struct._GeglNode* %call5, %struct._GeglNode** %graph6, align 8
  %11 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %layers = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %11, i32 0, i32 27
  %12 = load %struct._GimpItemTree*, %struct._GimpItemTree** %layers, align 8
  %container = getelementptr inbounds %struct._GimpItemTree, %struct._GimpItemTree* %12, i32 0, i32 1
  %13 = load %struct._GimpContainer*, %struct._GimpContainer** %container, align 8
  %14 = bitcast %struct._GimpContainer* %13 to %struct._GTypeInstance*
  %call7 = call i64 @gimp_drawable_stack_get_type() #8
  %call8 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %14, i64 %call7)
  %15 = bitcast %struct._GTypeInstance* %call8 to %struct._GimpDrawableStack*
  %call9 = call %struct._GeglNode* @gimp_drawable_stack_get_graph(%struct._GimpDrawableStack* %15)
  store %struct._GeglNode* %call9, %struct._GeglNode** %layers_node, align 8
  %16 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %graph10 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %16, i32 0, i32 23
  %17 = load %struct._GeglNode*, %struct._GeglNode** %graph10, align 8
  %18 = load %struct._GeglNode*, %struct._GeglNode** %layers_node, align 8
  %call11 = call %struct._GeglNode* @gegl_node_add_child(%struct._GeglNode* %17, %struct._GeglNode* %18)
  %19 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %channels = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %19, i32 0, i32 28
  %20 = load %struct._GimpItemTree*, %struct._GimpItemTree** %channels, align 8
  %container12 = getelementptr inbounds %struct._GimpItemTree, %struct._GimpItemTree* %20, i32 0, i32 1
  %21 = load %struct._GimpContainer*, %struct._GimpContainer** %container12, align 8
  %22 = bitcast %struct._GimpContainer* %21 to %struct._GTypeInstance*
  %call13 = call i64 @gimp_drawable_stack_get_type() #8
  %call14 = call %struct._GTypeInstance* @g_type_check_instance_cast(%struct._GTypeInstance* %22, i64 %call13)
  %23 = bitcast %struct._GTypeInstance* %call14 to %struct._GimpDrawableStack*
  %call15 = call %struct._GeglNode* @gimp_drawable_stack_get_graph(%struct._GimpDrawableStack* %23)
  store %struct._GeglNode* %call15, %struct._GeglNode** %channels_node, align 8
  %24 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %graph16 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %24, i32 0, i32 23
  %25 = load %struct._GeglNode*, %struct._GeglNode** %graph16, align 8
  %26 = load %struct._GeglNode*, %struct._GeglNode** %channels_node, align 8
  %call17 = call %struct._GeglNode* @gegl_node_add_child(%struct._GeglNode* %25, %struct._GeglNode* %26)
  %27 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %graph18 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %27, i32 0, i32 23
  %28 = load %struct._GeglNode*, %struct._GeglNode** %graph18, align 8
  %call19 = call %struct._GeglNode* (%struct._GeglNode*, i8*, ...) @gegl_node_new_child(%struct._GeglNode* %28, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.113, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.114, i32 0, i32 0), i8* null)
  store %struct._GeglNode* %call19, %struct._GeglNode** %blend_node, align 8
  %29 = load %struct._GeglNode*, %struct._GeglNode** %layers_node, align 8
  %30 = load %struct._GeglNode*, %struct._GeglNode** %blend_node, align 8
  %call20 = call i32 @gegl_node_connect_to(%struct._GeglNode* %29, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.115, i32 0, i32 0), %struct._GeglNode* %30, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.116, i32 0, i32 0))
  %31 = load %struct._GeglNode*, %struct._GeglNode** %channels_node, align 8
  %32 = load %struct._GeglNode*, %struct._GeglNode** %blend_node, align 8
  %call21 = call i32 @gegl_node_connect_to(%struct._GeglNode* %31, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.115, i32 0, i32 0), %struct._GeglNode* %32, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.117, i32 0, i32 0))
  %33 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %graph22 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %33, i32 0, i32 23
  %34 = load %struct._GeglNode*, %struct._GeglNode** %graph22, align 8
  %call23 = call %struct._GeglNode* @gegl_node_get_output_proxy(%struct._GeglNode* %34, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.115, i32 0, i32 0))
  store %struct._GeglNode* %call23, %struct._GeglNode** %output, align 8
  %35 = load %struct._GeglNode*, %struct._GeglNode** %blend_node, align 8
  %36 = load %struct._GeglNode*, %struct._GeglNode** %output, align 8
  %call24 = call i32 @gegl_node_connect_to(%struct._GeglNode* %35, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.115, i32 0, i32 0), %struct._GeglNode* %36, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.116, i32 0, i32 0))
  %37 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %graph25 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %37, i32 0, i32 23
  %38 = load %struct._GeglNode*, %struct._GeglNode** %graph25, align 8
  store %struct._GeglNode* %38, %struct._GeglNode** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %39 = load %struct._GeglNode*, %struct._GeglNode** %retval
  ret %struct._GeglNode* %39
}

declare void @gimp_viewable_invalidate_preview(%struct._GimpViewable*) #1

declare %struct._GeglNode* @gegl_node_new() #1

declare %struct._GeglNode* @gimp_drawable_stack_get_graph(%struct._GimpDrawableStack*) #1

; Function Attrs: nounwind readnone
declare i64 @gimp_drawable_stack_get_type() #2

declare %struct._GeglNode* @gegl_node_add_child(%struct._GeglNode*, %struct._GeglNode*) #1

declare %struct._GeglNode* @gegl_node_new_child(%struct._GeglNode*, i8*, ...) #1

declare i32 @gegl_node_connect_to(%struct._GeglNode*, i8*, %struct._GeglNode*, i8*) #1

declare %struct._GeglNode* @gegl_node_get_output_proxy(%struct._GeglNode*, i8*) #1

declare %struct._GimpProjection* @gimp_projection_new(%struct._GimpProjectable*) #1

declare %struct._GimpItemTree* @gimp_item_tree_new(%struct._GimpImage*, i64, i64) #1

; Function Attrs: nounwind uwtable
define internal void @gimp_image_active_layer_notify(%struct._GimpItemTree* %tree, %struct._GParamSpec* %pspec, %struct._GimpImage* %image) #3 {
entry:
  %tree.addr = alloca %struct._GimpItemTree*, align 8
  %pspec.addr = alloca %struct._GParamSpec*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %private = alloca %struct._GimpImagePrivate*, align 8
  %layer = alloca %struct._GimpLayer*, align 8
  store %struct._GimpItemTree* %tree, %struct._GimpItemTree** %tree.addr, align 8
  store %struct._GParamSpec* %pspec, %struct._GParamSpec** %pspec.addr, align 8
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  %call = call i64 @gimp_image_get_type() #8
  %call1 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %1, i64 %call)
  %2 = bitcast i8* %call1 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %2, %struct._GimpImagePrivate** %private, align 8
  %3 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call2 = call %struct._GimpLayer* @gimp_image_get_active_layer(%struct._GimpImage* %3)
  store %struct._GimpLayer* %call2, %struct._GimpLayer** %layer, align 8
  %4 = load %struct._GimpLayer*, %struct._GimpLayer** %layer, align 8
  %tobool = icmp ne %struct._GimpLayer* %4, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %layer_stack = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %5, i32 0, i32 30
  %6 = load %struct._GSList*, %struct._GSList** %layer_stack, align 8
  %7 = load %struct._GimpLayer*, %struct._GimpLayer** %layer, align 8
  %8 = bitcast %struct._GimpLayer* %7 to i8*
  %call3 = call %struct._GSList* @g_slist_remove(%struct._GSList* %6, i8* %8)
  %9 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %layer_stack4 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %9, i32 0, i32 30
  store %struct._GSList* %call3, %struct._GSList** %layer_stack4, align 8
  %10 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %layer_stack5 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %10, i32 0, i32 30
  %11 = load %struct._GSList*, %struct._GSList** %layer_stack5, align 8
  %12 = load %struct._GimpLayer*, %struct._GimpLayer** %layer, align 8
  %13 = bitcast %struct._GimpLayer* %12 to i8*
  %call6 = call %struct._GSList* @g_slist_prepend(%struct._GSList* %11, i8* %13)
  %14 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %layer_stack7 = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %14, i32 0, i32 30
  store %struct._GSList* %call6, %struct._GSList** %layer_stack7, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %15 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %16 = bitcast %struct._GimpImage* %15 to i8*
  %17 = load i32, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 3), align 4
  call void (i8*, i32, i32, ...) @g_signal_emit(i8* %16, i32 %17, i32 0)
  %18 = load %struct._GimpLayer*, %struct._GimpLayer** %layer, align 8
  %tobool8 = icmp ne %struct._GimpLayer* %18, null
  br i1 %tobool8, label %land.lhs.true, label %if.end.13

land.lhs.true:                                    ; preds = %if.end
  %19 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call9 = call %struct._GimpChannel* @gimp_image_get_active_channel(%struct._GimpImage* %19)
  %tobool10 = icmp ne %struct._GimpChannel* %call9, null
  br i1 %tobool10, label %if.then.11, label %if.end.13

if.then.11:                                       ; preds = %land.lhs.true
  %20 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call12 = call %struct._GimpChannel* @gimp_image_set_active_channel(%struct._GimpImage* %20, %struct._GimpChannel* null)
  br label %if.end.13

if.end.13:                                        ; preds = %if.then.11, %land.lhs.true, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @gimp_image_active_channel_notify(%struct._GimpItemTree* %tree, %struct._GParamSpec* %pspec, %struct._GimpImage* %image) #3 {
entry:
  %tree.addr = alloca %struct._GimpItemTree*, align 8
  %pspec.addr = alloca %struct._GParamSpec*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %channel = alloca %struct._GimpChannel*, align 8
  store %struct._GimpItemTree* %tree, %struct._GimpItemTree** %tree.addr, align 8
  store %struct._GParamSpec* %pspec, %struct._GParamSpec** %pspec.addr, align 8
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call = call %struct._GimpChannel* @gimp_image_get_active_channel(%struct._GimpImage* %0)
  store %struct._GimpChannel* %call, %struct._GimpChannel** %channel, align 8
  %1 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %2 = bitcast %struct._GimpImage* %1 to i8*
  %3 = load i32, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 4), align 4
  call void (i8*, i32, i32, ...) @g_signal_emit(i8* %2, i32 %3, i32 0)
  %4 = load %struct._GimpChannel*, %struct._GimpChannel** %channel, align 8
  %tobool = icmp ne %struct._GimpChannel* %4, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %5 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call1 = call %struct._GimpLayer* @gimp_image_get_active_layer(%struct._GimpImage* %5)
  %tobool2 = icmp ne %struct._GimpLayer* %call1, null
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %6 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call3 = call %struct._GimpLayer* @gimp_image_set_active_layer(%struct._GimpImage* %6, %struct._GimpLayer* null)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @gimp_image_active_vectors_notify(%struct._GimpItemTree* %tree, %struct._GParamSpec* %pspec, %struct._GimpImage* %image) #3 {
entry:
  %tree.addr = alloca %struct._GimpItemTree*, align 8
  %pspec.addr = alloca %struct._GParamSpec*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  store %struct._GimpItemTree* %tree, %struct._GimpItemTree** %tree.addr, align 8
  store %struct._GParamSpec* %pspec, %struct._GParamSpec** %pspec.addr, align 8
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to i8*
  %2 = load i32, i32* getelementptr inbounds ([28 x i32], [28 x i32]* @gimp_image_signals, i32 0, i64 5), align 4
  call void (i8*, i32, i32, ...) @g_signal_emit(i8* %1, i32 %2, i32 0)
  ret void
}

declare i32 @gimp_container_add_handler(%struct._GimpContainer*, i8*, void ()*, i8*) #1

; Function Attrs: nounwind uwtable
define internal void @gimp_image_layer_alpha_changed(%struct._GimpDrawable* %drawable, %struct._GimpImage* %image) #3 {
entry:
  %drawable.addr = alloca %struct._GimpDrawable*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  %private = alloca %struct._GimpImagePrivate*, align 8
  store %struct._GimpDrawable* %drawable, %struct._GimpDrawable** %drawable.addr, align 8
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  %0 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %1 = bitcast %struct._GimpImage* %0 to %struct._GTypeInstance*
  %call = call i64 @gimp_image_get_type() #8
  %call1 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %1, i64 %call)
  %2 = bitcast i8* %call1 to %struct._GimpImagePrivate*
  store %struct._GimpImagePrivate* %2, %struct._GimpImagePrivate** %private, align 8
  %3 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %layers = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %3, i32 0, i32 27
  %4 = load %struct._GimpItemTree*, %struct._GimpItemTree** %layers, align 8
  %container = getelementptr inbounds %struct._GimpItemTree, %struct._GimpItemTree* %4, i32 0, i32 1
  %5 = load %struct._GimpContainer*, %struct._GimpContainer** %container, align 8
  %call2 = call i32 @gimp_container_get_n_children(%struct._GimpContainer* %5)
  %cmp = icmp eq i32 %call2, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load %struct._GimpImagePrivate*, %struct._GimpImagePrivate** %private, align 8
  %flush_accum = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %6, i32 0, i32 47
  %alpha_changed = getelementptr inbounds %struct._GimpImageFlushAccumulator, %struct._GimpImageFlushAccumulator* %flush_accum, i32 0, i32 0
  store i32 1, i32* %alpha_changed, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @gimp_image_channel_name_changed(%struct._GimpChannel* %channel, %struct._GimpImage* %image) #3 {
entry:
  %channel.addr = alloca %struct._GimpChannel*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  store %struct._GimpChannel* %channel, %struct._GimpChannel** %channel.addr, align 8
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  %0 = load %struct._GimpChannel*, %struct._GimpChannel** %channel.addr, align 8
  %1 = bitcast %struct._GimpChannel* %0 to i8*
  %call = call i8* @gimp_object_get_name(i8* %1)
  %call1 = call i32 @strcmp(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.111, i32 0, i32 0), i8* %call) #9
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %2 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  call void @gimp_image_set_quick_mask_state(%struct._GimpImage* %2, i32 1)
  br label %if.end.7

if.else:                                          ; preds = %entry
  %3 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call2 = call i32 @gimp_image_get_quick_mask_state(%struct._GimpImage* %3)
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.else
  %4 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %call4 = call %struct._GimpChannel* @gimp_image_get_quick_mask(%struct._GimpImage* %4)
  %tobool5 = icmp ne %struct._GimpChannel* %call4, null
  br i1 %tobool5, label %if.end, label %if.then.6

if.then.6:                                        ; preds = %land.lhs.true
  %5 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  call void @gimp_image_set_quick_mask_state(%struct._GimpImage* %5, i32 0)
  br label %if.end

if.end:                                           ; preds = %if.then.6, %land.lhs.true, %if.else
  br label %if.end.7

if.end.7:                                         ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @gimp_image_channel_color_changed(%struct._GimpChannel* %channel, %struct._GimpImage* %image) #3 {
entry:
  %channel.addr = alloca %struct._GimpChannel*, align 8
  %image.addr = alloca %struct._GimpImage*, align 8
  store %struct._GimpChannel* %channel, %struct._GimpChannel** %channel.addr, align 8
  store %struct._GimpImage* %image, %struct._GimpImage** %image.addr, align 8
  %0 = load %struct._GimpChannel*, %struct._GimpChannel** %channel.addr, align 8
  %1 = bitcast %struct._GimpChannel* %0 to i8*
  %call = call i8* @gimp_object_get_name(i8* %1)
  %call1 = call i32 @strcmp(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.111, i32 0, i32 0), i8* %call) #9
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load %struct._GimpImage*, %struct._GimpImage** %image.addr, align 8
  %3 = bitcast %struct._GimpImage* %2 to %struct._GTypeInstance*
  %call2 = call i64 @gimp_image_get_type() #8
  %call3 = call i8* @g_type_instance_get_private(%struct._GTypeInstance* %3, i64 %call2)
  %4 = bitcast i8* %call3 to %struct._GimpImagePrivate*
  %quick_mask_color = getelementptr inbounds %struct._GimpImagePrivate, %struct._GimpImagePrivate* %4, i32 0, i32 41
  %5 = load %struct._GimpChannel*, %struct._GimpChannel** %channel.addr, align 8
  %color = getelementptr inbounds %struct._GimpChannel, %struct._GimpChannel* %5, i32 0, i32 1
  %6 = bitcast %struct._GimpRGB* %quick_mask_color to i8*
  %7 = bitcast %struct._GimpRGB* %color to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %6, i8* %7, i64 32, i32 8, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare %struct._GimpParasiteList* @gimp_parasite_list_new() #1

declare void @gimp_rgba_set(%struct._GimpRGB*, double, double, double, double) #1

declare %struct._GimpUndoStack* @gimp_undo_stack_new(%struct._GimpImage*) #1

declare %struct._GSList* @g_slist_prepend(%struct._GSList*, i8*) #1

declare i32 @gimp_image_get_quick_mask_state(%struct._GimpImage*) #1

declare %struct._GimpChannel* @gimp_image_get_quick_mask(%struct._GimpImage*) #1

declare void @gimp_object_take_name(%struct._GimpObject*, i8*) #1

declare i8* @file_utils_uri_with_new_ext(i8*, i8*) #1

declare i8* @file_utils_uri_display_basename(i8*) #1

declare i8* @file_utils_uri_display_name(i8*) #1

declare noalias i8* @g_strconcat(i8*, ...) #1

; Function Attrs: nounwind
declare void @llvm.va_start(i8*) #6

declare void @g_logv(i8*, i32, i8*, %struct.__va_list_tag*) #1

; Function Attrs: nounwind
declare void @llvm.va_end(i8*) #6

attributes #0 = { nounwind readnone uwtable "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind readnone "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind uwtable "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind readonly "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { nounwind }
attributes #7 = { noreturn "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #8 = { nounwind readnone }
attributes #9 = { nounwind readonly }
attributes #10 = { noreturn }

!llvm.ident = !{!0}

!0 = !{!"clang version 3.7.0 (tags/RELEASE_370/final)"}
