; ModuleID = '4.queue.bc'
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.sm_file = type { i8*, i8*, i32, i32, i64, i16, %struct.smbuf, i32, i8*, i32, i32 (%struct.sm_file*)*, i64 (%struct.sm_file*, i8*, i64)*, i64 (%struct.sm_file*, i64, i32)*, i64 (%struct.sm_file*, i8*, i64)*, i32 (%struct.sm_file*, i8*, i32, i8*)*, i32 (%struct.sm_file*, i32, i8*)*, i32 (%struct.sm_file*, i32, i8*)*, i32, i32, i8*, %struct.sm_file*, %struct.sm_file*, %struct.smbuf, i8*, i32, [3 x i8], [1 x i8], i32, i64, i32 }
%struct.smbuf = type { i8*, i32 }
%struct.mailer = type { i8*, i8*, i8*, i8*, i8*, [8 x i32], i16, i16, i8**, i16, i16, i16, i16, i8*, i64, i32, i32, i8*, i8*, i32, i32, i8*, i64, i32, i16 }
%struct.queuegrp = type { i8*, i8*, i16, i32, i32, i64, %struct.qpaths_s*, [8 x i32], i16, i32, i32, i32, i32, i64 }
%struct.qpaths_s = type { i8*, i16, i16, i32 }
%struct.workgrp = type { i32, i32, i32, %struct.queuegrp**, i32, i64, i32, i32 }
%struct.sm_debug = type { i8*, i32, i8*, i8*, %struct.sm_debug* }
%struct.envelope = type { %struct.header*, i64, i64, i8*, %struct.address, i8*, i8**, %struct.address*, %struct.address*, i64, i8*, i64, i32, i16, i16, i16, i16, i16, i16, i32 (%struct.mailer_con_info*, %struct.header*, %struct.envelope*, i32)*, i32 (%struct.mailer_con_info*, %struct.envelope*, i8*)*, %struct.envelope*, %struct.envelope*, i8*, %struct.sm_file*, i8*, i32, i32, i32, i32, i32, i32, %struct.sm_file*, %struct.sm_file*, i8*, i8*, i8*, i8, i8*, i8*, i8*, i8*, i64, i32, i64, i64, %struct.MACROS_T, %struct.mailer_con_info*, i8*, %struct.sm_timers, i64, i32, %struct.SM_RPOOL_T*, i32 }
%struct.header = type { i8*, i8*, %struct.header*, i8, i64, [8 x i32] }
%struct.address = type { i8*, i8*, i8*, i8*, %struct.mailer*, i64, i32, i32, i8*, i8*, %struct.address*, %struct.address*, i8*, %struct.address*, %struct.address*, i8*, i8*, i8*, i8*, i64, i8*, i16, i8*, i32, i32, i8* }
%struct.MACROS_T = type { %struct.SM_RPOOL_T*, [8 x i32], [256 x i8*] }
%struct.mailer_con_info = type { i64, i16, i16, i16, i16, i32, i64, %struct.sm_file*, %struct.sm_file*, i32, i8*, %struct.mailer*, i8*, i8*, i8*, i64, %struct.sm_file*, i8*, i64, i32, i8*, %struct.SM_RPOOL_T*, i32, %struct.address*, %struct.MACROS_T }
%struct.sm_timers = type { %struct._timer }
%struct._timer = type { i64, i64, i64, i64 }
%struct.SM_RPOOL_T = type { i8*, void (i8*)**, i64, i64, i8*, i64, %struct.sm_poollink*, %struct.sm_resource*, i64, %struct.sm_rlist* }
%struct.sm_poollink = type { %struct.sm_poollink* }
%struct.sm_resource = type { void (i8*)*, i8* }
%struct.sm_rlist = type { [511 x %struct.sm_resource], %struct.sm_rlist* }
%struct.queue_char = type { i8*, i32, %struct.queue_char* }
%struct.queue_shared = type { i32 }
%struct.work = type { i8*, i8*, i32, i32, i64, i64, i64, i32, i32, %struct.work* }
%struct.filesys_shared = type { i64, i64, i64 }
%struct.anon = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [8 x i64], [8 x i64], [3 x i64], [3 x i32] }
%struct.stat = type { i64, i64, i64, i32, i32, i32, i32, i64, i64, i64, i64, %struct.timespec, %struct.timespec, %struct.timespec, [3 x i64] }
%struct.timespec = type { i64, i64 }
%union.bigsockaddr = type { %struct.sockaddr_in, [96 x i8] }
%struct.sockaddr_in = type { i16, i16, %struct.in_addr, [8 x i8] }
%struct.in_addr = type { i32 }
%struct.sm_event = type { i64, void (i32)*, i32, i32, %struct.sm_event* }
%struct.sm_exc = type { i8*, i64, %struct.sm_exc_type*, %union.sm_val* }
%struct.sm_exc_type = type { i8*, i8*, i8*, void (%struct.sm_exc*, %struct.sm_file*)*, i8* }
%union.sm_val = type { i64 }
%struct.dirent = type { i64, i64, i16, i8, [256 x i8] }
%struct.__dirstream = type opaque
%struct.__res_state = type { i32, i32, i64, i32, [3 x %struct.sockaddr_in], i16, [7 x i8*], [256 x i8], i64, i32, [10 x %struct.anon.0], i32 (%struct.sockaddr_in**, i8**, i32*, i8*, i32, i32*)*, i32 (%struct.sockaddr_in*, i8*, i32, i8*, i32, i32*)*, i32, i32, i32, %union.anon.1 }
%struct.anon.0 = type { %struct.in_addr, i32 }
%union.anon.1 = type { %struct.anon.2 }
%struct.anon.2 = type { i16, [3 x i16], [3 x i32], i16, i16, [3 x %struct.sockaddr_in6*], [2 x i32] }
%struct.sockaddr_in6 = type { i16, i16, i32, %struct.in6_addr, i32 }
%struct.in6_addr = type { %union.anon.3 }
%union.anon.3 = type { [4 x i32] }
%struct.tm = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i64, i8* }
%struct.symtab = type { i8*, i16, %struct.symtab*, %union.anon }
%union.anon = type { %struct.mailer_con_info }
%struct.sortqgrp = type { i32, i32 }
%struct.passwd = type { i8*, i8*, i32, i32, i8*, i8*, i8* }

@ShmId = global i32 -2, align 4
@QueueFileMode = external global i32, align 4
@SmFtStdiofd_def = external global %struct.sm_file, align 8
@.str = private unnamed_addr constant [62 x i8] c"!queueup: cannot create queue file %s, euid=%ld, fd=%d, fp=%p\00", align 1
@.str.1 = private unnamed_addr constant [8 x i8] c"queueup\00", align 1
@LogLevel = external global i32, align 4
@.str.2 = private unnamed_addr constant [40 x i8] c"queueup: cannot create %s, euid=%ld: %s\00", align 1
@.str.3 = private unnamed_addr constant [28 x i8] c"queueup: cannot lock %s: %s\00", align 1
@.str.4 = private unnamed_addr constant [52 x i8] c"!queueup: cannot create queue temp file %s, uid=%ld\00", align 1
@tTdvect = external global [100 x i8], align 16
@IntSig = external global i32, align 4
@.str.5 = private unnamed_addr constant [31 x i8] c"\0A>>>>> queueing %s/%s%s >>>>>\0A\00", align 1
@.str.6 = private unnamed_addr constant [10 x i8] c" (new id)\00", align 1
@.str.7 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.8 = private unnamed_addr constant [11 x i8] c"  e_flags=\00", align 1
@.str.9 = private unnamed_addr constant [9 x i8] c"  sendq=\00", align 1
@.str.10 = private unnamed_addr constant [7 x i8] c"  tfp=\00", align 1
@.str.11 = private unnamed_addr constant [10 x i8] c"  lockfp=\00", align 1
@.str.12 = private unnamed_addr constant [6 x i8] c"NULL\0A\00", align 1
@SuperSafe = external global i32, align 4
@.str.13 = private unnamed_addr constant [46 x i8] c"!queueup: cannot commit data file %s, uid=%ld\00", align 1
@.str.14 = private unnamed_addr constant [25 x i8] c"queueup: fsync(e->e_dfp)\00", align 1
@.str.15 = private unnamed_addr constant [32 x i8] c"!552 Error writing data file %s\00", align 1
@.str.16 = private unnamed_addr constant [32 x i8] c"!452 Error writing data file %s\00", align 1
@.str.17 = private unnamed_addr constant [21 x i8] c"SendmailBufferedFile\00", align 1
@.str.18 = private unnamed_addr constant [24 x i8] c"committing over bf file\00", align 1
@.str.19 = private unnamed_addr constant [51 x i8] c"!queueup: cannot create data temp file %s, uid=%ld\00", align 1
@FileMailer = external global %struct.mailer*, align 8
@.str.20 = private unnamed_addr constant [20 x i8] c"queueup: fsync(dfp)\00", align 1
@.str.21 = private unnamed_addr constant [49 x i8] c"!queueup: cannot save data temp file %s, uid=%ld\00", align 1
@.str.22 = private unnamed_addr constant [5 x i8] c"V%d\0A\00", align 1
@.str.23 = private unnamed_addr constant [6 x i8] c"T%ld\0A\00", align 1
@.str.24 = private unnamed_addr constant [6 x i8] c"K%ld\0A\00", align 1
@.str.25 = private unnamed_addr constant [5 x i8] c"N%d\0A\00", align 1
@.str.26 = private unnamed_addr constant [6 x i8] c"P%ld\0A\00", align 1
@.str.27 = private unnamed_addr constant [5 x i8] c"d%s\0A\00", align 1
@Queue = external global [51 x %struct.queuegrp*], align 16
@.str.28 = private unnamed_addr constant [15 x i8] c"I%ld/%ld/%llu\0A\00", align 1
@.str.29 = private unnamed_addr constant [5 x i8] c"B%s\0A\00", align 1
@.str.30 = private unnamed_addr constant [5 x i8] c"q%s\0A\00", align 1
@.str.31 = private unnamed_addr constant [5 x i8] c"M%s\0A\00", align 1
@.str.32 = private unnamed_addr constant [5 x i8] c"F%s\0A\00", align 1
@.str.33 = private unnamed_addr constant [19 x i8] c"{persistentMacros}\00", align 1
@.str.34 = private unnamed_addr constant [5 x i8] c"S%s\0A\00", align 1
@.str.35 = private unnamed_addr constant [5 x i8] c"Z%s\0A\00", align 1
@.str.36 = private unnamed_addr constant [5 x i8] c"A%s\0A\00", align 1
@.str.37 = private unnamed_addr constant [9 x i8] c"!%c %ld\0A\00", align 1
@.str.38 = private unnamed_addr constant [5 x i8] c"Q%s\0A\00", align 1
@.str.39 = private unnamed_addr constant [5 x i8] c"r%s\0A\00", align 1
@.str.40 = private unnamed_addr constant [4 x i8] c"%s\0A\00", align 1
@.str.41 = private unnamed_addr constant [7 x i8] c"queued\00", align 1
@.str.42 = private unnamed_addr constant [12 x i8] c"quarantined\00", align 1
@.str.43 = private unnamed_addr constant [3 x i8] c"%s\00", align 1
@.str.44 = private unnamed_addr constant [10 x i8] c"queueing \00", align 1
@.str.45 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.46 = private unnamed_addr constant [3 x i8] c"\81f\00", align 1
@.str.47 = private unnamed_addr constant [8 x i8] c"queue.c\00", align 1
@SmHeapGroup = external global i32, align 4
@.str.48 = private unnamed_addr constant [3 x i8] c"H?\00", align 1
@.str.49 = private unnamed_addr constant [6 x i8] c"${%s}\00", align 1
@.str.50 = private unnamed_addr constant [4 x i8] c"$%c\00", align 1
@.str.51 = private unnamed_addr constant [7 x i8] c"%s:%s\0A\00", align 1
@TrafficLogFile = external global %struct.sm_file*, align 8
@.str.52 = private unnamed_addr constant [3 x i8] c".\0A\00", align 1
@.str.53 = private unnamed_addr constant [35 x i8] c"!552 Error writing control file %s\00", align 1
@.str.54 = private unnamed_addr constant [35 x i8] c"!452 Error writing control file %s\00", align 1
@.str.55 = private unnamed_addr constant [31 x i8] c"cannot rename(%s, %s), uid=%ld\00", align 1
@.str.56 = private unnamed_addr constant [28 x i8] c"type changed from %c to %c\0A\00", align 1
@.str.57 = private unnamed_addr constant [31 x i8] c"queueup: unlink(%s) failed: %s\00", align 1
@.str.58 = private unnamed_addr constant [42 x i8] c"!queueup: cannot fsync queue temp file %s\00", align 1
@.str.59 = private unnamed_addr constant [11 x i8] c"queueup %s\00", align 1
@.str.60 = private unnamed_addr constant [31 x i8] c"<<<<< done queueing %s <<<<<\0A\0A\00", align 1
@NumWorkGroups = internal global i32 0, align 4
@WorkGrp = internal global [51 x %struct.workgrp] zeroinitializer, align 16
@RestartWorkGroup = external global i32, align 4
@NoMoreRunners = internal global i32 0, align 4
@.str.61 = private unnamed_addr constant [43 x i8] c"restart queue runner=%d due to signal 0x%x\00", align 1
@runqueue.curnum = internal global i32 0, align 4
@DebugLeakQ = internal global %struct.sm_debug { i8* getelementptr inbounds ([0 x i8], [0 x i8]* @SmDebugMagic, i32 0, i32 0), i32 -1, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.194, i32 0, i32 0), i8* getelementptr inbounds ([66 x i8], [66 x i8]* @.str.195, i32 0, i32 0), %struct.sm_debug* null }, align 8
@SmHeapMaxGroup = external global i32, align 4
@.str.62 = private unnamed_addr constant [27 x i8] c"runqueue() heap group #%d\0A\00", align 1
@DoQueueRun = internal global i32 0, align 4
@Oldsh_term = internal global void (i32)* null, align 8
@Oldsh_hup = internal global void (i32)* null, align 8
@MaxQueueChildren = external global i32, align 4
@CurRunners = external global i32, align 4
@.str.63 = private unnamed_addr constant [60 x i8] c"%s: CurRunners=%d, i=%d, count=%d, status=should not happen\00", align 1
@.str.64 = private unnamed_addr constant [9 x i8] c"runqueue\00", align 1
@Current_LA_time = internal global i64 0, align 8
@WkRecipFact = external global i64, align 8
@.str.65 = private unnamed_addr constant [44 x i8] c"Skipping queue run -- load average too high\00", align 1
@.str.66 = private unnamed_addr constant [8 x i8] c"458 %s\0A\00", align 1
@.str.67 = private unnamed_addr constant [13 x i8] c"runqueue: %s\00", align 1
@MaxChildren = external global i32, align 4
@CurChildren = external global i32, align 4
@.str.68 = private unnamed_addr constant [40 x i8] c"Skipping queue run -- too many children\00", align 1
@.str.69 = private unnamed_addr constant [13 x i8] c"458 %s (%d)\0A\00", align 1
@.str.70 = private unnamed_addr constant [18 x i8] c"runqueue: %s (%d)\00", align 1
@.str.71 = private unnamed_addr constant [36 x i8] c"Skipping queue run -- fork() failed\00", align 1
@.str.72 = private unnamed_addr constant [12 x i8] c"458 %s: %s\0A\00", align 1
@.str.73 = private unnamed_addr constant [17 x i8] c"runqueue: %s: %s\00", align 1
@.str.74 = private unnamed_addr constant [13 x i8] c"Queue runner\00", align 1
@RestartRequest = external global i8*, align 8
@ShutdownRequest = external global i8*, align 8
@PendingSignal = external global i32, align 4
@CurrentPid = external global i32, align 4
@.str.75 = private unnamed_addr constant [27 x i8] c"Queue runner child process\00", align 1
@NoConnect = external global i32, align 4
@QueueEnvelope = internal global %struct.envelope zeroinitializer, align 8
@CurEnv = external global %struct.envelope*, align 8
@BlankEnvelope = external global %struct.envelope, align 8
@QuickAbort = external global i32, align 4
@QueueLimitId = external global %struct.queue_char*, align 8
@QueueLimitSender = external global %struct.queue_char*, align 8
@QueueLimitQuarantine = external global %struct.queue_char*, align 8
@QueueLimitRecipient = external global %struct.queue_char*, align 8
@IgnoreHostStatus = external global i32, align 4
@MinQueueAge = external global i64, align 8
@MaxQueueAge = external global i64, align 8
@ExitStat = external global i32, align 4
@.str.76 = private unnamed_addr constant [18 x i8] c"running queue: %s\00", align 1
@.str.77 = private unnamed_addr constant [33 x i8] c"runqueue %s, pid=%d, forkflag=%d\00", align 1
@QShm = internal global %struct.queue_shared* null, align 8
@Verbose = external global i32, align 4
@.str.78 = private unnamed_addr constant [28 x i8] c"run_work_group: cannot fork\00", align 1
@WorkQ = internal global %struct.work* null, align 8
@.str.79 = private unnamed_addr constant [27 x i8] c"Queue child runner process\00", align 1
@OpMode = external global i8, align 1
@OnlyOneError = external global i32, align 4
@FallbackMX = external global i8*, align 8
@SmHeapCheck = external global %struct.sm_debug, align 8
@.str.80 = private unnamed_addr constant [8 x i8] c"memdump\00", align 1
@SmFtStdio_def = external global %struct.sm_file, align 8
@.str.81 = private unnamed_addr constant [12 x i8] c"memdump.out\00", align 1
@.str.82 = private unnamed_addr constant [24 x i8] c"----------------------\0A\00", align 1
@QueueIntvl = external global i64, align 8
@.str.83 = private unnamed_addr constant [15 x i8] c"dowork(%s/%s)\0A\00", align 1
@.str.84 = private unnamed_addr constant [20 x i8] c"dowork: cannot fork\00", align 1
@UseErrorsTo = external global i32, align 4
@GrabTo = external global i32, align 4
@.str.85 = private unnamed_addr constant [14 x i8] c"%s from queue\00", align 1
@.str.86 = private unnamed_addr constant [15 x i8] c"dowork, pid=%d\00", align 1
@.str.87 = private unnamed_addr constant [19 x i8] c"readqf(%s) failed\0A\00", align 1
@.str.88 = private unnamed_addr constant [14 x i8] c"doworklist()\0A\00", align 1
@.str.89 = private unnamed_addr constant [24 x i8] c"doworklist: cannot fork\00", align 1
@.str.90 = private unnamed_addr constant [19 x i8] c"doworklist, pid=%d\00", align 1
@QueueMode = external global i32, align 4
@.str.91 = private unnamed_addr constant [45 x i8] c"Data unavailable: shared memory not updated\0A\00", align 1
@.str.92 = private unnamed_addr constant [21 x i8] c"%sNOTCONFIGURED:-1\0D\0A\00", align 1
@NumQueue = external global i32, align 4
@StopRequest = external global i32, align 4
@.str.93 = private unnamed_addr constant [10 x i8] c"%s%s:%d\0D\0A\00", align 1
@.str.94 = private unnamed_addr constant [31 x i8] c"%s: unknown number of entries\0A\00", align 1
@.str.95 = private unnamed_addr constant [13 x i8] c"%s is empty\0A\00", align 1
@.str.96 = private unnamed_addr constant [16 x i8] c"%s: entries=%d\0A\00", align 1
@.str.97 = private unnamed_addr constant [24 x i8] c"\09\09Total requests: %d%s\0A\00", align 1
@.str.98 = private unnamed_addr constant [9 x i8] c" (about)\00", align 1
@SmIoF = external global [0 x %struct.sm_file], align 8
@.str.99 = private unnamed_addr constant [22 x i8] c"\09\09Total requests: %d\0A\00", align 1
@.str.100 = private unnamed_addr constant [2 x i8] c".\00", align 1
@.str.101 = private unnamed_addr constant [4 x i8] c"/qf\00", align 1
@.str.102 = private unnamed_addr constant [4 x i8] c"/df\00", align 1
@PrivacyFlags = external global i64, align 8
@RealUid = external global i32, align 4
@.str.103 = private unnamed_addr constant [15 x i8] c"Cannot stat %s\00", align 1
@InitialGidSet = external global [65536 x i32], align 16
@RealGid = external global i32, align 4
@.str.104 = private unnamed_addr constant [43 x i8] c"510 You are not permitted to see the queue\00", align 1
@.str.105 = private unnamed_addr constant [19 x i8] c"\09\09%s (%d request%s\00", align 1
@.str.106 = private unnamed_addr constant [2 x i8] c"s\00", align 1
@MaxQueueRun = external global i32, align 4
@.str.107 = private unnamed_addr constant [18 x i8] c", only %d printed\00", align 1
@.str.108 = private unnamed_addr constant [84 x i8] c")\0A-----Q-ID----- --Size-- -Priority- ---Q-Time--- --------Sender/Recipient--------\0A\00", align 1
@.str.109 = private unnamed_addr constant [84 x i8] c")\0A-----Q-ID----- --Size-- -----Q-Time----- ------------Sender/Recipient-----------\0A\00", align 1
@.str.110 = private unnamed_addr constant [5 x i8] c"%13s\00", align 1
@.str.111 = private unnamed_addr constant [2 x i8] c"/\00", align 1
@.str.112 = private unnamed_addr constant [22 x i8] c" (permission denied)\0A\00", align 1
@.str.113 = private unnamed_addr constant [18 x i8] c" (job completed)\0A\00", align 1
@.str.114 = private unnamed_addr constant [7 x i8] c" (%s)\0A\00", align 1
@.str.115 = private unnamed_addr constant [2 x i8] c"*\00", align 1
@.str.116 = private unnamed_addr constant [2 x i8] c"?\00", align 1
@.str.117 = private unnamed_addr constant [2 x i8] c"-\00", align 1
@.str.118 = private unnamed_addr constant [2 x i8] c"X\00", align 1
@.str.119 = private unnamed_addr constant [2 x i8] c" \00", align 1
@.str.120 = private unnamed_addr constant [19 x i8] c"%8ld %10ld%c%.12s \00", align 1
@.str.121 = private unnamed_addr constant [12 x i8] c"%8ld %.16s \00", align 1
@.str.122 = private unnamed_addr constant [23 x i8] c"\0A     QUARANTINE: %.*s\00", align 1
@.str.123 = private unnamed_addr constant [13 x i8] c"\0A    %10.10s\00", align 1
@.str.124 = private unnamed_addr constant [10 x i8] c"   (%.*s)\00", align 1
@.str.125 = private unnamed_addr constant [21 x i8] c"\0A\09\09\09\09\09\09(---%.64s---)\00", align 1
@.str.126 = private unnamed_addr constant [8 x i8] c"\0A\09\09\09\09\09\09\00", align 1
@.str.127 = private unnamed_addr constant [8 x i8] c"\0A\09\09\09\09\09 \00", align 1
@.str.128 = private unnamed_addr constant [13 x i8] c"\0A\09\09 (%.100s)\00", align 1
@.str.129 = private unnamed_addr constant [19 x i8] c" (no control file)\00", align 1
@queuename.buf = internal global [4096 x i8] zeroinitializer, align 16
@.str.130 = private unnamed_addr constant [5 x i8] c"/df/\00", align 1
@.str.131 = private unnamed_addr constant [5 x i8] c"/qf/\00", align 1
@.str.132 = private unnamed_addr constant [5 x i8] c"/xf/\00", align 1
@.str.133 = private unnamed_addr constant [34 x i8] c"queuename: bad queue file type %d\00", align 1
@.str.134 = private unnamed_addr constant [15 x i8] c"queuename: %s\0A\00", align 1
@LastQueueTime = internal global i64 0, align 8
@LastQueuePid = internal global i32 -1, align 4
@assign_queueid.cX = internal global i32 0, align 4
@assign_queueid.random_offset = internal global i32 0, align 4
@.str.135 = private unnamed_addr constant [39 x i8] c"assign_queueid: random_offset=%u (%u)\0A\00", align 1
@QueueIdChars = internal constant [63 x i8] c"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\00", align 16
@.str.136 = private unnamed_addr constant [5 x i8] c"%06d\00", align 1
@.str.137 = private unnamed_addr constant [38 x i8] c"assign_queueid: assigned id %s, e=%p\0A\00", align 1
@.str.138 = private unnamed_addr constant [12 x i8] c"assigned id\00", align 1
@.str.139 = private unnamed_addr constant [17 x i8] c"unlockqueue(%s)\0A\00", align 1
@.str.140 = private unnamed_addr constant [8 x i8] c"NOQUEUE\00", align 1
@.str.141 = private unnamed_addr constant [7 x i8] c"unlock\00", align 1
@.str.142 = private unnamed_addr constant [14 x i8] c"Losing %s: %s\00", align 1
@qid_printname.idbuf = internal global [55 x i8] zeroinitializer, align 16
@.str.143 = private unnamed_addr constant [9 x i8] c"%.32s/%s\00", align 1
@qid_printqueue.dir = internal global [4096 x i8] zeroinitializer, align 16
@MinBlocksFree = external global i64, align 8
@PtrFileSys = internal global %struct.filesys_shared* null, align 8
@FSPath = internal global [256 x i8*] zeroinitializer, align 16
@.str.144 = private unnamed_addr constant [69 x i8] c"low on space (%s needs %ld bytes + %ld blocks in %s), max avail: %ld\00", align 1
@CurHostName = external global i8*, align 8
@.str.145 = private unnamed_addr constant [12 x i8] c"SMTP-DAEMON\00", align 1
@.str.146 = private unnamed_addr constant [21 x i8] c"setnewqueue: called\0A\00", align 1
@.str.147 = private unnamed_addr constant [43 x i8] c"setnewqueue: e_qdir already assigned (%s)\0A\00", align 1
@.str.148 = private unnamed_addr constant [51 x i8] c"452 4.4.5 Insufficient disk space; try again later\00", align 1
@.str.149 = private unnamed_addr constant [42 x i8] c"setnewqueue: Assigned queue directory %s\0A\00", align 1
@filesys_update.nextupdate = internal global i64 0, align 8
@DaemonPid = external global i32, align 4
@PNumFileSys = external global i32*, align 8
@.str.150 = private unnamed_addr constant [59 x i8] c"filesys_update failed: %s, fs=%s, avail=%ld, blocksize=%ld\00", align 1
@.str.151 = private unnamed_addr constant [14 x i8] c"%s%d/%s/%ld\0D\0A\00", align 1
@.str.152 = private unnamed_addr constant [63 x i8] c"func=upd_qs, count=%d, space=%d, where=%s, idx=%d, entries=%d\0A\00", align 1
@QueueDir = external global i8*, align 8
@.str.153 = private unnamed_addr constant [43 x i8] c"QueueDirectory: path too long: %d,  max %d\00", align 1
@.str.154 = private unnamed_addr constant [26 x i8] c"SM_ASSERT(len > 0) failed\00", align 1
@.str.155 = private unnamed_addr constant [52 x i8] c"QueueDirectory: can not wildcard relative path \22%s\22\00", align 1
@.str.156 = private unnamed_addr constant [53 x i8] c"setup_queues: \22%s\22: Can not wildcard relative path.\0A\00", align 1
@.str.157 = private unnamed_addr constant [42 x i8] c"SM_ASSERT(basedir[len - 1] == '/') failed\00", align 1
@.str.158 = private unnamed_addr constant [18 x i8] c"can not chdir(%s)\00", align 1
@.str.159 = private unnamed_addr constant [70 x i8] c"Program mode requires special privileges, e.g., root or TrustedUser.\0A\00", align 1
@.str.160 = private unnamed_addr constant [24 x i8] c"setup_queues: \22%s\22: %s\0A\00", align 1
@UseMSP = external global i32, align 4
@.str.161 = private unnamed_addr constant [17 x i8] c"can not stat(%s)\00", align 1
@RunAsUid = external global i32, align 4
@RunAsGid = external global i32, align 4
@RunAsUserName = external global i8*, align 8
@.str.162 = private unnamed_addr constant [65 x i8] c"can not write to queue directory %s (RunAsGid=%ld, required=%ld)\00", align 1
@.str.163 = private unnamed_addr constant [47 x i8] c"dangerous permissions=%o on queue directory %s\00", align 1
@.str.164 = private unnamed_addr constant [25 x i8] c"SM_ASSERT(!owner) failed\00", align 1
@.str.165 = private unnamed_addr constant [38 x i8] c"filesys_setup failed twice, result=%d\00", align 1
@.str.166 = private unnamed_addr constant [54 x i8] c"shared memory does not contain expected data, ignored\00", align 1
@Pshm = internal global i8* null, align 8
@.str.167 = private unnamed_addr constant [21 x i8] c"sm_shmstop failed=%s\00", align 1
@MaxRunnersPerQueue = external global i32, align 4
@NiceQueueRun = external global i32, align 4
@.str.168 = private unnamed_addr constant [24 x i8] c"name required for queue\00", align 1
@.str.169 = private unnamed_addr constant [23 x i8] c"queue %s: `=' expected\00", align 1
@.str.170 = private unnamed_addr constant [26 x i8] c"queue %s: empty path name\00", align 1
@.str.171 = private unnamed_addr constant [65 x i8] c"Q=%s: R=%d exceeds MaxQueueChildren=%d, set to MaxQueueChildren\0A\00", align 1
@.str.172 = private unnamed_addr constant [30 x i8] c"Q%s: unknown queue equate %c=\00", align 1
@.str.173 = private unnamed_addr constant [39 x i8] c"too many queue groups defined (%d max)\00", align 1
@.str.174 = private unnamed_addr constant [45 x i8] c"QueueDir must be defined before queue groups\00", align 1
@.str.175 = private unnamed_addr constant [81 x i8] c"Warning: Q=%s: R=%d: multiple queue runners specified\0A\09but flag '%c' is not set\0A\00", align 1
@.str.176 = private unnamed_addr constant [28 x i8] c"Adding %s to stab, path: %s\00", align 1
@.str.177 = private unnamed_addr constant [7 x i8] c"mqueue\00", align 1
@.str.178 = private unnamed_addr constant [55 x i8] c"!cannot allocate memory for work queues, need %d bytes\00", align 1
@.str.179 = private unnamed_addr constant [15 x i8] c"Workgroup[%d]=\00", align 1
@.str.180 = private unnamed_addr constant [5 x i8] c"%s, \00", align 1
@.str.181 = private unnamed_addr constant [3 x i8] c"; \00", align 1
@.str.182 = private unnamed_addr constant [24 x i8] c"SM_ASSERT(j < l) failed\00", align 1
@.str.183 = private unnamed_addr constant [25 x i8] c"split: count=%d, id%s=%s\00", align 1
@.str.184 = private unnamed_addr constant [16 x i8] c"%s: no matches\0A\00", align 1
@.str.185 = private unnamed_addr constant [16 x i8] c"Processing %s:\0A\00", align 1
@WorkListCount = internal global i32 0, align 4
@WorkList = internal global %struct.work* null, align 8
@.str.186 = private unnamed_addr constant [13 x i8] c"Would do %s\0A\00", align 1
@WorkListSize = internal global i32 0, align 4
@.str.187 = private unnamed_addr constant [12 x i8] c"No changes\0A\00", align 1
@.str.188 = private unnamed_addr constant [13 x i8] c"%d change%s\0A\00", align 1
@PRSATmpCnt = common global i32* null, align 8
@printctladdr.lastctladdr = internal global %struct.address* null, align 8
@printctladdr.lastuid = internal global i32 0, align 4
@.str.189 = private unnamed_addr constant [3 x i8] c"C\0A\00", align 1
@.str.190 = private unnamed_addr constant [2 x i8] c"C\00", align 1
@.str.191 = private unnamed_addr constant [12 x i8] c"C%s:%ld:%ld\00", align 1
@.str.192 = private unnamed_addr constant [5 x i8] c":%s\0A\00", align 1
@.str.193 = private unnamed_addr constant [78 x i8] c"ERROR: persistent queue runner=%d restarted too many times, queue runner lost\00", align 1
@SmDebugMagic = external constant [0 x i8], align 1
@.str.194 = private unnamed_addr constant [7 x i8] c"leak_q\00", align 1
@.str.195 = private unnamed_addr constant [66 x i8] c"@(#)$Debug: leak_q - trace memory leaks during queue processing $\00", align 1
@InCriticalSection = external global i32, align 4
@Oldsh = internal global void (i32)* null, align 8
@Oldsig = internal global i32 0, align 4
@BlockOldsh = internal global i32 0, align 4
@.str.196 = private unnamed_addr constant [34 x i8] c"run_queue_group() heap group #%d\0A\00", align 1
@.str.197 = private unnamed_addr constant [42 x i8] c"Aborting queue run: load average too high\00", align 1
@QueueSortOrder = external global i32, align 4
@.str.198 = private unnamed_addr constant [62 x i8] c"Skipping %s/%s (sequence %d of %d) and flushing rest of queue\00", align 1
@.str.199 = private unnamed_addr constant [63 x i8] c"runqueue: Flushing queue from %s/%s (pri %ld, LA %d, %d of %d)\00", align 1
@CurrentLA = external global i32, align 4
@.str.200 = private unnamed_addr constant [35 x i8] c"Skipping %s/%s (sequence %d of %d)\00", align 1
@.str.201 = private unnamed_addr constant [34 x i8] c"Running %s/%s (sequence %d of %d)\00", align 1
@.str.202 = private unnamed_addr constant [23 x i8] c"runqueue %s dowork(%s)\00", align 1
@ForkQueueRuns = external global i32, align 4
@.str.203 = private unnamed_addr constant [10 x i8] c"gatherq:\0A\00", align 1
@.str.204 = private unnamed_addr constant [22 x i8] c"\09QueueLimitId = %s%s\0A\00", align 1
@.str.205 = private unnamed_addr constant [2 x i8] c"!\00", align 1
@.str.206 = private unnamed_addr constant [26 x i8] c"\09QueueLimitSender = %s%s\0A\00", align 1
@.str.207 = private unnamed_addr constant [29 x i8] c"\09QueueLimitRecipient = %s%s\0A\00", align 1
@.str.208 = private unnamed_addr constant [30 x i8] c"\09QueueLimitQuarantine = %s%s\0A\00", align 1
@.str.209 = private unnamed_addr constant [26 x i8] c"gatherq: cannot open \22%s\22\00", align 1
@.str.210 = private unnamed_addr constant [23 x i8] c"gatherq: checking %s..\00", align 1
@.str.211 = private unnamed_addr constant [12 x i8] c"  skipping\0A\00", align 1
@.str.212 = private unnamed_addr constant [41 x i8] c"gatherq: %s too long, %d max characters\0A\00", align 1
@.str.213 = private unnamed_addr constant [40 x i8] c"gatherq: %s too long, %d max characters\00", align 1
@.str.214 = private unnamed_addr constant [32 x i8] c"WorkList for %s maxed out at %d\00", align 1
@.str.215 = private unnamed_addr constant [26 x i8] c"SM_ASSERT(wn >= 0) failed\00", align 1
@.str.216 = private unnamed_addr constant [26 x i8] c"gatherq: can't stat %s/%s\00", align 1
@.str.217 = private unnamed_addr constant [37 x i8] c"gatherq: %s/%s is not a regular file\00", align 1
@.str.218 = private unnamed_addr constant [29 x i8] c"gatherq: cannot open %s: %s\0A\00", align 1
@.str.219 = private unnamed_addr constant [49 x i8] c"%s not marked as quarantined but has a 'q' line\0A\00", align 1
@.str.220 = private unnamed_addr constant [18 x i8] c"skipping %s (%x)\0A\00", align 1
@.str.221 = private unnamed_addr constant [29 x i8] c"grow_wlist: WorkListSize=%d\0A\00", align 1
@.str.222 = private unnamed_addr constant [27 x i8] c"grew WorkList for %s to %d\00", align 1
@.str.223 = private unnamed_addr constant [37 x i8] c"FAILED to grow WorkList for %s to %d\00", align 1
@.str.224 = private unnamed_addr constant [33 x i8] c"grow_wlist: WorkListSize now %d\0A\00", align 1
@randi = internal global i32 3, align 4
@.str.225 = private unnamed_addr constant [18 x i8] c"%22s: pri=%ld %s\0A\00", align 1
@.str.226 = private unnamed_addr constant [15 x i8] c"%32s: pri=%ld\0A\00", align 1
@.str.227 = private unnamed_addr constant [29 x i8] c"SM_REQUIRE(e != NULL) failed\00", align 1
@.str.228 = private unnamed_addr constant [37 x i8] c"readqf(%s): sm_io_open failure (%s)\0A\00", align 1
@.str.229 = private unnamed_addr constant [27 x i8] c"readqf: no control file %s\00", align 1
@.str.230 = private unnamed_addr constant [12 x i8] c"%s: locked\0A\00", align 1
@.str.231 = private unnamed_addr constant [7 x i8] c"locked\00", align 1
@.str.232 = private unnamed_addr constant [34 x i8] c"readqf(%s): [f]stat failure (%s)\0A\00", align 1
@.str.233 = private unnamed_addr constant [13 x i8] c"%s: changed\0A\00", align 1
@.str.234 = private unnamed_addr constant [8 x i8] c"changed\00", align 1
@TrustedUid = external global i32, align 4
@.str.235 = private unnamed_addr constant [33 x i8] c"readqf: cannot stat directory %s\00", align 1
@.str.236 = private unnamed_addr constant [44 x i8] c"bogus queue file, uid=%ld, gid=%ld, mode=%o\00", align 1
@.str.237 = private unnamed_addr constant [24 x i8] c"readqf(%s): bogus file\0A\00", align 1
@.str.238 = private unnamed_addr constant [29 x i8] c"bogus file uid/gid in mqueue\00", align 1
@LineNumber = external global i32, align 4
@.str.239 = private unnamed_addr constant [10 x i8] c"+++++ %s\0A\00", align 1
@.str.240 = private unnamed_addr constant [54 x i8] c"SECURITY ALERT: extra or bogus data in queue file: %s\00", align 1
@.str.241 = private unnamed_addr constant [17 x i8] c"bogus queue line\00", align 1
@.str.242 = private unnamed_addr constant [27 x i8] c"bogus queue file directory\00", align 1
@.str.243 = private unnamed_addr constant [6 x i8] c"From \00", align 1
@.str.244 = private unnamed_addr constant [33 x i8] c"SECURITY ALERT: bogus qf line %s\00", align 1
@.str.245 = private unnamed_addr constant [13 x i8] c"{quarantine}\00", align 1
@.str.246 = private unnamed_addr constant [20 x i8] c"%s: too young (%s)\0A\00", align 1
@.str.247 = private unnamed_addr constant [15 x i8] c"too young (%s)\00", align 1
@.str.248 = private unnamed_addr constant [9 x i8] c"{ntries}\00", align 1
@TimeOuts = external global %struct.anon, align 8
@WkTimeFact = external global i64, align 8
@.str.249 = private unnamed_addr constant [12 x i8] c"{addr_type}\00", align 1
@.str.250 = private unnamed_addr constant [4 x i8] c"e b\00", align 1
@.str.251 = private unnamed_addr constant [4 x i8] c"e r\00", align 1
@.str.252 = private unnamed_addr constant [56 x i8] c"Version number in queue file (%d) greater than max (%d)\00", align 1
@.str.253 = private unnamed_addr constant [31 x i8] c"unsupported queue file version\00", align 1
@.str.254 = private unnamed_addr constant [12 x i8] c"{dsn_envid}\00", align 1
@.str.255 = private unnamed_addr constant [35 x i8] c"readqf: %s: line %d: bad line \22%s\22\00", align 1
@.str.256 = private unnamed_addr constant [18 x i8] c"unrecognized line\00", align 1
@.str.257 = private unnamed_addr constant [39 x i8] c"readqf: %s: incomplete queue file read\00", align 1
@.str.258 = private unnamed_addr constant [10 x i8] c"{dsn_ret}\00", align 1
@.str.259 = private unnamed_addr constant [5 x i8] c"hdrs\00", align 1
@.str.260 = private unnamed_addr constant [5 x i8] c"full\00", align 1
@.str.261 = private unnamed_addr constant [23 x i8] c"readqf: cannot open %s\00", align 1
@.str.262 = private unnamed_addr constant [4 x i8] c"%ld\00", align 1
@.str.263 = private unnamed_addr constant [11 x i8] c"{msg_size}\00", align 1
@.str.264 = private unnamed_addr constant [2 x i8] c":\00", align 1
@LocalMailer = external global %struct.mailer*, align 8
@.str.265 = private unnamed_addr constant [6 x i8] c"\5C%03o\00", align 1
@.str.266 = private unnamed_addr constant [26 x i8] c"multiqueue_cache: called\0A\00", align 1
@.str.267 = private unnamed_addr constant [26 x i8] c"QueuePath %s not absolute\00", align 1
@.str.268 = private unnamed_addr constant [35 x i8] c"QueuePath %.256s too long (%d max)\00", align 1
@.str.269 = private unnamed_addr constant [46 x i8] c"QueuePath %s not subpath of QueueDirectory %s\00", align 1
@.str.270 = private unnamed_addr constant [29 x i8] c"SM_ASSERT(cp != NULL) failed\00", align 1
@.str.271 = private unnamed_addr constant [34 x i8] c"SM_ASSERT(len >= blen - 1) failed\00", align 1
@.str.272 = private unnamed_addr constant [47 x i8] c"QueueDirectory: can not wildcard relative path\00", align 1
@.str.273 = private unnamed_addr constant [58 x i8] c"multiqueue_cache: \22%s*\22: Can not wildcard relative path.\0A\00", align 1
@.str.274 = private unnamed_addr constant [40 x i8] c"SM_ASSERT(off < sizeof(relpath)) failed\00", align 1
@.str.275 = private unnamed_addr constant [33 x i8] c"multiqueue_cache: prefix=\22%s%s\22\0A\00", align 1
@.str.276 = private unnamed_addr constant [38 x i8] c"multiqueue_cache: \22%s\22: Not safe: %s\0A\00", align 1
@.str.277 = private unnamed_addr constant [23 x i8] c"can not opendir(%s/%s)\00", align 1
@.str.278 = private unnamed_addr constant [40 x i8] c"multiqueue_cache: opendir(\22%s/%s\22): %s\0A\00", align 1
@.str.279 = private unnamed_addr constant [3 x i8] c"..\00", align 1
@.str.280 = private unnamed_addr constant [33 x i8] c"multiqueue_cache: \22%s\22, skipped\0A\00", align 1
@.str.281 = private unnamed_addr constant [3 x i8] c"qf\00", align 1
@.str.282 = private unnamed_addr constant [3 x i8] c"df\00", align 1
@.str.283 = private unnamed_addr constant [3 x i8] c"xf\00", align 1
@.str.284 = private unnamed_addr constant [41 x i8] c"multiqueue_cache: %d: \22%s\22 cached (%x).\0A\00", align 1
@.str.285 = private unnamed_addr constant [20 x i8] c"can not opendir(%s)\00", align 1
@.str.286 = private unnamed_addr constant [37 x i8] c"multiqueue_cache: opendir(\22%s\22): %s\0A\00", align 1
@.str.287 = private unnamed_addr constant [25 x i8] c"chkqdir: stat(\22%s\22): %s\0A\00", align 1
@.str.288 = private unnamed_addr constant [32 x i8] c"chkqdir: \22%s\22: Not a directory\0A\00", align 1
@.str.289 = private unnamed_addr constant [29 x i8] c"chkqdir: \22%s\22: Not safe: %s\0A\00", align 1
@FileSys = internal global [256 x %struct.filesys_shared] zeroinitializer, align 16
@Numfilesys = external global i32, align 4
@ShmKey = external global i32, align 4
@shms = internal global i64 0, align 8
@ShmKeyFile = external global i8*, align 8
@.str.290 = private unnamed_addr constant [55 x i8] c"key=%ld, sm_shmsetowner=%d, RunAsUid=%ld, RunAsGid=%ld\00", align 1
@.str.291 = private unnamed_addr constant [36 x i8] c"can't %s shared memory, key=%ld: %s\00", align 1
@.str.292 = private unnamed_addr constant [11 x i8] c"initialize\00", align 1
@.str.293 = private unnamed_addr constant [10 x i8] c"attach to\00", align 1
@FileMode = external global i32, align 4
@.str.294 = private unnamed_addr constant [22 x i8] c"unable to read %s: %s\00", align 1
@.str.295 = private unnamed_addr constant [23 x i8] c"unable to write %s: %s\00", align 1
@.str.296 = private unnamed_addr constant [41 x i8] c"ownership change on %s to %ld failed: %s\00", align 1
@.str.297 = private unnamed_addr constant [5 x i8] c"%ld\0A\00", align 1
@.str.298 = private unnamed_addr constant [31 x i8] c"cannot stat queue directory %s\00", align 1
@.str.299 = private unnamed_addr constant [37 x i8] c"too many queue file systems (%d max)\00", align 1
@.str.300 = private unnamed_addr constant [42 x i8] c"SM_REQUIRE(ISVALIDQGRP(e->e_qgrp)) failed\00", align 1
@.str.301 = private unnamed_addr constant [11 x i8] c"queuegroup\00", align 1
@.str.302 = private unnamed_addr constant [26 x i8] c"queue group name %s -> %d\00", align 1
@.str.303 = private unnamed_addr constant [50 x i8] c"can't find queue group name %s, selection ignored\00", align 1
@.str.304 = private unnamed_addr constant [72 x i8] c"SM_REQUIRE(ISVALIDQGRP(old->e_qgrp) && ISVALIDQDIR(old->e_qdir)) failed\00", align 1
@.str.305 = private unnamed_addr constant [72 x i8] c"SM_REQUIRE(ISVALIDQGRP(new->e_qgrp) && ISVALIDQDIR(new->e_qdir)) failed\00", align 1
@.str.306 = private unnamed_addr constant [17 x i8] c"@can't commit %s\00", align 1
@.str.307 = private unnamed_addr constant [76 x i8] c"SM_REQUIRE(ISVALIDQGRP(old->e_dfqgrp) && ISVALIDQDIR(old->e_dfqdir)) failed\00", align 1
@.str.308 = private unnamed_addr constant [76 x i8] c"SM_REQUIRE(ISVALIDQGRP(new->e_dfqgrp) && ISVALIDQDIR(new->e_dfqdir)) failed\00", align 1
@.str.309 = private unnamed_addr constant [65 x i8] c"dup_df: can't link %s to %s, error=%s, envelope splitting failed\00", align 1
@.str.310 = private unnamed_addr constant [48 x i8] c"split: maxrcpts=%d, rcpts=%d, count=%d, id%s=%s\00", align 1
@.str.311 = private unnamed_addr constant [13 x i8] c"Skipping %s\0A\00", align 1
@.str.312 = private unnamed_addr constant [36 x i8] c"Skipping %s: Could not open %s: %s\0A\00", align 1
@.str.313 = private unnamed_addr constant [32 x i8] c"Skipping %s: Could not lock %s\0A\00", align 1
@.str.314 = private unnamed_addr constant [32 x i8] c"%s: Removed quarantine of \22%s\22\0A\00", align 1
@.str.315 = private unnamed_addr constant [13 x i8] c"unquarantine\00", align 1
@.str.316 = private unnamed_addr constant [35 x i8] c"%s: Already quarantined with \22%s\22\0A\00", align 1
@.str.317 = private unnamed_addr constant [42 x i8] c"%s: Quarantine changed from \22%s\22 to \22%s\22\0A\00", align 1
@.str.318 = private unnamed_addr constant [14 x i8] c"quarantine=%s\00", align 1
@.str.319 = private unnamed_addr constant [27 x i8] c"%s: Quarantined with \22%s\22\0A\00", align 1
@.str.320 = private unnamed_addr constant [35 x i8] c"Skipping %s: Error reading %s: %s\0A\00", align 1
@.str.321 = private unnamed_addr constant [34 x i8] c"Skipping %s: Incomplete file: %s\0A\00", align 1
@.str.322 = private unnamed_addr constant [35 x i8] c"Skipping %s: Error writing %s: %s\0A\00", align 1
@.str.323 = private unnamed_addr constant [42 x i8] c"quarantine_queue_item: rename(%s, %s): %s\00", align 1
@.str.324 = private unnamed_addr constant [29 x i8] c"Error renaming %s to %s: %s\0A\00", align 1
@.str.325 = private unnamed_addr constant [36 x i8] c"!452 Error renaming control file %s\00", align 1
@.str.326 = private unnamed_addr constant [23 x i8] c"Error removing %s: %s\0A\00", align 1

; Function Attrs: nounwind uwtable
define void @queueup(%struct.envelope* %e, i32 %announce, i32 %msync) #0 {
entry:
  %e.addr = alloca %struct.envelope*, align 8
  %announce.addr = alloca i32, align 4
  %msync.addr = alloca i32, align 4
  %tfp = alloca %struct.sm_file*, align 8
  %h = alloca %struct.header*, align 8
  %q = alloca %struct.address*, align 8
  %tfd = alloca i32, align 4
  %i = alloca i32, align 4
  %newid = alloca i32, align 4
  %p = alloca i8*, align 8
  %nullmailer = alloca %struct.mailer, align 8
  %mcibuf = alloca %struct.mailer_con_info, align 8
  %qf = alloca [4096 x i8], align 16
  %tf = alloca [4096 x i8], align 16
  %df = alloca [4096 x i8], align 16
  %buf = alloca [2048 x i8], align 16
  %oldumask = alloca i32, align 4
  %save_errno = alloca i32, align 4
  %oldumask41 = alloca i32, align 4
  %save_errno126 = alloca i32, align 4
  %dfd = alloca i32, align 4
  %oldumask237 = alloca i32, align 4
  %dfp = alloca %struct.sm_file*, align 8
  %stbuf = alloca %struct.stat, align 8
  %tag = alloca i8*, align 8
  %j = alloca i32, align 4
  %oldstyle = alloca i32, align 4
  %savetrace = alloca %struct.sm_file*, align 8
  %new = alloca i8, align 1
  store %struct.envelope* %e, %struct.envelope** %e.addr, align 8, !tbaa !1
  store i32 %announce, i32* %announce.addr, align 4, !tbaa !5
  store i32 %msync, i32* %msync.addr, align 4, !tbaa !5
  %0 = bitcast %struct.sm_file** %tfp to i8*
  call void @llvm.lifetime.start(i64 8, i8* %0) #1
  %1 = bitcast %struct.header** %h to i8*
  call void @llvm.lifetime.start(i64 8, i8* %1) #1
  %2 = bitcast %struct.address** %q to i8*
  call void @llvm.lifetime.start(i64 8, i8* %2) #1
  %3 = bitcast i32* %tfd to i8*
  call void @llvm.lifetime.start(i64 4, i8* %3) #1
  store i32 -1, i32* %tfd, align 4, !tbaa !5
  %4 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start(i64 4, i8* %4) #1
  %5 = bitcast i32* %newid to i8*
  call void @llvm.lifetime.start(i64 4, i8* %5) #1
  %6 = bitcast i8** %p to i8*
  call void @llvm.lifetime.start(i64 8, i8* %6) #1
  %7 = bitcast %struct.mailer* %nullmailer to i8*
  call void @llvm.lifetime.start(i64 168, i8* %7) #1
  %8 = bitcast %struct.mailer_con_info* %mcibuf to i8*
  call void @llvm.lifetime.start(i64 2256, i8* %8) #1
  %9 = bitcast [4096 x i8]* %qf to i8*
  call void @llvm.lifetime.start(i64 4096, i8* %9) #1
  %10 = bitcast [4096 x i8]* %tf to i8*
  call void @llvm.lifetime.start(i64 4096, i8* %10) #1
  %11 = bitcast [4096 x i8]* %df to i8*
  call void @llvm.lifetime.start(i64 4096, i8* %11) #1
  %12 = bitcast [2048 x i8]* %buf to i8*
  call void @llvm.lifetime.start(i64 2048, i8* %12) #1
  %13 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id = getelementptr inbounds %struct.envelope, %struct.envelope* %13, i32 0, i32 25
  %14 = load i8*, i8** %e_id, align 8, !tbaa !7
  %cmp = icmp eq i8* %14, null
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %15 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_flags = getelementptr inbounds %struct.envelope, %struct.envelope* %15, i32 0, i32 11
  %16 = load i64, i64* %e_flags, align 8, !tbaa !15
  %and = and i64 %16, 2
  %cmp1 = icmp ne i64 %and, 0
  %lnot = xor i1 %cmp1, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %entry
  %17 = phi i1 [ true, %entry ], [ %lnot, %lor.rhs ]
  %lor.ext = zext i1 %17 to i32
  store i32 %lor.ext, i32* %newid, align 4, !tbaa !5
  %arraydecay = getelementptr inbounds [4096 x i8], [4096 x i8]* %tf, i32 0, i32 0
  %18 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %call = call i8* @queuename(%struct.envelope* %18, i32 116)
  %call2 = call i64 @sm_strlcpy(i8* %arraydecay, i8* %call, i64 4096)
  %19 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_lockfp = getelementptr inbounds %struct.envelope, %struct.envelope* %19, i32 0, i32 33
  %20 = load %struct.sm_file*, %struct.sm_file** %e_lockfp, align 8, !tbaa !16
  store %struct.sm_file* %20, %struct.sm_file** %tfp, align 8, !tbaa !1
  %21 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  %cmp3 = icmp eq %struct.sm_file* %21, null
  br i1 %cmp3, label %land.lhs.true, label %if.end.32

land.lhs.true:                                    ; preds = %lor.end
  %22 = load i32, i32* %newid, align 4, !tbaa !5
  %tobool = icmp ne i32 %22, 0
  br i1 %tobool, label %if.then, label %if.end.32

if.then:                                          ; preds = %land.lhs.true
  %arraydecay4 = getelementptr inbounds [4096 x i8], [4096 x i8]* %tf, i32 0, i32 0
  %23 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %call5 = call i8* @queuename(%struct.envelope* %23, i32 63)
  %call6 = call i64 @sm_strlcpy(i8* %arraydecay4, i8* %call5, i64 4096)
  br label %do.body

do.body:                                          ; preds = %if.then
  %24 = bitcast i32* %oldumask to i8*
  call void @llvm.lifetime.start(i64 4, i8* %24) #1
  store i32 0, i32* %oldumask, align 4, !tbaa !5
  %25 = load i32, i32* @QueueFileMode, align 4, !tbaa !5
  %and7 = and i32 %25, 16
  %cmp8 = icmp ne i32 %and7, 0
  br i1 %cmp8, label %if.then.9, label %if.end

if.then.9:                                        ; preds = %do.body
  %call10 = call i32 @umask(i32 2) #1
  store i32 %call10, i32* %oldumask, align 4, !tbaa !5
  br label %if.end

if.end:                                           ; preds = %if.then.9, %do.body
  %arraydecay11 = getelementptr inbounds [4096 x i8], [4096 x i8]* %tf, i32 0, i32 0
  %26 = load i32, i32* @QueueFileMode, align 4, !tbaa !5
  %call12 = call i32 (i8*, i32, ...) @open(i8* %arraydecay11, i32 193, i32 %26)
  store i32 %call12, i32* %tfd, align 4, !tbaa !5
  %27 = load i32, i32* @QueueFileMode, align 4, !tbaa !5
  %and13 = and i32 %27, 16
  %cmp14 = icmp ne i32 %and13, 0
  br i1 %cmp14, label %if.then.15, label %if.end.17

if.then.15:                                       ; preds = %if.end
  %28 = load i32, i32* %oldumask, align 4, !tbaa !5
  %call16 = call i32 @umask(i32 %28) #1
  br label %if.end.17

if.end.17:                                        ; preds = %if.then.15, %if.end
  %29 = bitcast i32* %oldumask to i8*
  call void @llvm.lifetime.end(i64 4, i8* %29) #1
  br label %do.cond

do.cond:                                          ; preds = %if.end.17
  br label %do.end

do.end:                                           ; preds = %do.cond
  %30 = load i32, i32* %tfd, align 4, !tbaa !5
  %cmp18 = icmp slt i32 %30, 0
  br i1 %cmp18, label %if.then.25, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.end
  %31 = load i32, i32* %tfd, align 4, !tbaa !5
  %arraydecay19 = getelementptr inbounds [4096 x i8], [4096 x i8]* %tf, i32 0, i32 0
  %call20 = call i32 @lockfile(i32 %31, i8* %arraydecay19, i8* null, i32 6)
  %tobool21 = icmp ne i32 %call20, 0
  br i1 %tobool21, label %lor.lhs.false.22, label %if.then.25

lor.lhs.false.22:                                 ; preds = %lor.lhs.false
  %32 = bitcast i32* %tfd to i8*
  %call23 = call %struct.sm_file* @sm_io_open(%struct.sm_file* @SmFtStdiofd_def, i32 -2, i8* %32, i32 3, i8* null)
  store %struct.sm_file* %call23, %struct.sm_file** %tfp, align 8, !tbaa !1
  %cmp24 = icmp eq %struct.sm_file* %call23, null
  br i1 %cmp24, label %if.then.25, label %if.end.30

if.then.25:                                       ; preds = %lor.lhs.false.22, %lor.lhs.false, %do.end
  %33 = bitcast i32* %save_errno to i8*
  call void @llvm.lifetime.start(i64 4, i8* %33) #1
  %call26 = call i32* @__errno_location() #11
  %34 = load i32, i32* %call26, align 4, !tbaa !5
  store i32 %34, i32* %save_errno, align 4, !tbaa !5
  call void @printopenfds(i32 1)
  %35 = load i32, i32* %save_errno, align 4, !tbaa !5
  %call27 = call i32* @__errno_location() #11
  store i32 %35, i32* %call27, align 4, !tbaa !5
  %arraydecay28 = getelementptr inbounds [4096 x i8], [4096 x i8]* %tf, i32 0, i32 0
  %call29 = call i32 @geteuid() #1
  %conv = zext i32 %call29 to i64
  %36 = load i32, i32* %tfd, align 4, !tbaa !5
  %37 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([62 x i8], [62 x i8]* @.str, i32 0, i32 0), i8* %arraydecay28, i64 %conv, i32 %36, %struct.sm_file* %37)
  %38 = bitcast i32* %save_errno to i8*
  call void @llvm.lifetime.end(i64 4, i8* %38) #1
  br label %if.end.30

if.end.30:                                        ; preds = %if.then.25, %lor.lhs.false.22
  %39 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  %40 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_lockfp31 = getelementptr inbounds %struct.envelope, %struct.envelope* %40, i32 0, i32 33
  store %struct.sm_file* %39, %struct.sm_file** %e_lockfp31, align 8, !tbaa !16
  %41 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  call void @upd_qs(%struct.envelope* %41, i32 1, i32 0, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1, i32 0, i32 0))
  br label %if.end.32

if.end.32:                                        ; preds = %if.end.30, %land.lhs.true, %lor.end
  %42 = load i32, i32* %newid, align 4, !tbaa !5
  %tobool33 = icmp ne i32 %42, 0
  br i1 %tobool33, label %if.end.133, label %if.then.34

if.then.34:                                       ; preds = %if.end.32
  store i32 0, i32* %i, align 4, !tbaa !5
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then.34
  %43 = load i32, i32* %i, align 4, !tbaa !5
  %cmp35 = icmp slt i32 %43, 128
  br i1 %cmp35, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %44 = load i32, i32* %tfd, align 4, !tbaa !5
  %cmp37 = icmp slt i32 %44, 0
  br i1 %cmp37, label %if.then.39, label %if.end.80

if.then.39:                                       ; preds = %for.body
  br label %do.body.40

do.body.40:                                       ; preds = %if.then.39
  %45 = bitcast i32* %oldumask41 to i8*
  call void @llvm.lifetime.start(i64 4, i8* %45) #1
  store i32 0, i32* %oldumask41, align 4, !tbaa !5
  %46 = load i32, i32* @QueueFileMode, align 4, !tbaa !5
  %and42 = and i32 %46, 16
  %cmp43 = icmp ne i32 %and42, 0
  br i1 %cmp43, label %if.then.45, label %if.end.47

if.then.45:                                       ; preds = %do.body.40
  %call46 = call i32 @umask(i32 2) #1
  store i32 %call46, i32* %oldumask41, align 4, !tbaa !5
  br label %if.end.47

if.end.47:                                        ; preds = %if.then.45, %do.body.40
  %arraydecay48 = getelementptr inbounds [4096 x i8], [4096 x i8]* %tf, i32 0, i32 0
  %47 = load i32, i32* @QueueFileMode, align 4, !tbaa !5
  %call49 = call i32 (i8*, i32, ...) @open(i8* %arraydecay48, i32 193, i32 %47)
  store i32 %call49, i32* %tfd, align 4, !tbaa !5
  %48 = load i32, i32* @QueueFileMode, align 4, !tbaa !5
  %and50 = and i32 %48, 16
  %cmp51 = icmp ne i32 %and50, 0
  br i1 %cmp51, label %if.then.53, label %if.end.55

if.then.53:                                       ; preds = %if.end.47
  %49 = load i32, i32* %oldumask41, align 4, !tbaa !5
  %call54 = call i32 @umask(i32 %49) #1
  br label %if.end.55

if.end.55:                                        ; preds = %if.then.53, %if.end.47
  %50 = bitcast i32* %oldumask41 to i8*
  call void @llvm.lifetime.end(i64 4, i8* %50) #1
  br label %do.cond.56

do.cond.56:                                       ; preds = %if.end.55
  br label %do.end.57

do.end.57:                                        ; preds = %do.cond.56
  %51 = load i32, i32* %tfd, align 4, !tbaa !5
  %cmp58 = icmp slt i32 %51, 0
  br i1 %cmp58, label %if.then.60, label %if.end.79

if.then.60:                                       ; preds = %do.end.57
  %call61 = call i32* @__errno_location() #11
  %52 = load i32, i32* %call61, align 4, !tbaa !5
  %cmp62 = icmp ne i32 %52, 17
  br i1 %cmp62, label %if.then.64, label %if.end.65

if.then.64:                                       ; preds = %if.then.60
  br label %for.end

if.end.65:                                        ; preds = %if.then.60
  %53 = load i32, i32* @LogLevel, align 4, !tbaa !5
  %cmp66 = icmp sgt i32 %53, 0
  br i1 %cmp66, label %land.lhs.true.68, label %if.end.78

land.lhs.true.68:                                 ; preds = %if.end.65
  %54 = load i32, i32* %i, align 4, !tbaa !5
  %rem = srem i32 %54, 32
  %cmp69 = icmp eq i32 %rem, 0
  br i1 %cmp69, label %if.then.71, label %if.end.78

if.then.71:                                       ; preds = %land.lhs.true.68
  %55 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id72 = getelementptr inbounds %struct.envelope, %struct.envelope* %55, i32 0, i32 25
  %56 = load i8*, i8** %e_id72, align 8, !tbaa !7
  %arraydecay73 = getelementptr inbounds [4096 x i8], [4096 x i8]* %tf, i32 0, i32 0
  %call74 = call i32 @geteuid() #1
  %conv75 = zext i32 %call74 to i64
  %call76 = call i32* @__errno_location() #11
  %57 = load i32, i32* %call76, align 4, !tbaa !5
  %call77 = call i8* @sm_errstring(i32 %57)
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 1, i8* %56, i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.2, i32 0, i32 0), i8* %arraydecay73, i64 %conv75, i8* %call77)
  br label %if.end.78

if.end.78:                                        ; preds = %if.then.71, %land.lhs.true.68, %if.end.65
  br label %if.end.79

if.end.79:                                        ; preds = %if.end.78, %do.end.57
  br label %if.end.80

if.end.80:                                        ; preds = %if.end.79, %for.body
  %58 = load i32, i32* %tfd, align 4, !tbaa !5
  %cmp81 = icmp sge i32 %58, 0
  br i1 %cmp81, label %if.then.83, label %if.end.107

if.then.83:                                       ; preds = %if.end.80
  %59 = load i32, i32* %tfd, align 4, !tbaa !5
  %arraydecay84 = getelementptr inbounds [4096 x i8], [4096 x i8]* %tf, i32 0, i32 0
  %call85 = call i32 @lockfile(i32 %59, i8* %arraydecay84, i8* null, i32 6)
  %tobool86 = icmp ne i32 %call85, 0
  br i1 %tobool86, label %if.then.87, label %if.else

if.then.87:                                       ; preds = %if.then.83
  br label %for.end

if.else:                                          ; preds = %if.then.83
  %60 = load i32, i32* @LogLevel, align 4, !tbaa !5
  %cmp88 = icmp sgt i32 %60, 0
  br i1 %cmp88, label %land.lhs.true.90, label %if.end.99

land.lhs.true.90:                                 ; preds = %if.else
  %61 = load i32, i32* %i, align 4, !tbaa !5
  %rem91 = srem i32 %61, 32
  %cmp92 = icmp eq i32 %rem91, 0
  br i1 %cmp92, label %if.then.94, label %if.end.99

if.then.94:                                       ; preds = %land.lhs.true.90
  %62 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id95 = getelementptr inbounds %struct.envelope, %struct.envelope* %62, i32 0, i32 25
  %63 = load i8*, i8** %e_id95, align 8, !tbaa !7
  %arraydecay96 = getelementptr inbounds [4096 x i8], [4096 x i8]* %tf, i32 0, i32 0
  %call97 = call i32* @__errno_location() #11
  %64 = load i32, i32* %call97, align 4, !tbaa !5
  %call98 = call i8* @sm_errstring(i32 %64)
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 1, i8* %63, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.3, i32 0, i32 0), i8* %arraydecay96, i8* %call98)
  br label %if.end.99

if.end.99:                                        ; preds = %if.then.94, %land.lhs.true.90, %if.else
  br label %if.end.100

if.end.100:                                       ; preds = %if.end.99
  %65 = load i32, i32* %i, align 4, !tbaa !5
  %rem101 = srem i32 %65, 32
  %cmp102 = icmp eq i32 %rem101, 31
  br i1 %cmp102, label %if.then.104, label %if.end.106

if.then.104:                                      ; preds = %if.end.100
  %66 = load i32, i32* %tfd, align 4, !tbaa !5
  %call105 = call i32 @close(i32 %66)
  store i32 -1, i32* %tfd, align 4, !tbaa !5
  br label %if.end.106

if.end.106:                                       ; preds = %if.then.104, %if.end.100
  br label %if.end.107

if.end.107:                                       ; preds = %if.end.106, %if.end.80
  %67 = load i32, i32* %i, align 4, !tbaa !5
  %rem108 = srem i32 %67, 32
  %cmp109 = icmp eq i32 %rem108, 31
  br i1 %cmp109, label %if.then.111, label %if.else.115

if.then.111:                                      ; preds = %if.end.107
  %arraydecay112 = getelementptr inbounds [4096 x i8], [4096 x i8]* %tf, i32 0, i32 0
  %68 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %call113 = call i8* @queuename(%struct.envelope* %68, i32 84)
  %call114 = call i32 @rename(i8* %arraydecay112, i8* %call113) #1
  br label %if.end.118

if.else.115:                                      ; preds = %if.end.107
  %69 = load i32, i32* %i, align 4, !tbaa !5
  %rem116 = srem i32 %69, 32
  %call117 = call i32 @sleep(i32 %rem116)
  br label %if.end.118

if.end.118:                                       ; preds = %if.else.115, %if.then.111
  br label %for.inc

for.inc:                                          ; preds = %if.end.118
  %70 = load i32, i32* %i, align 4, !tbaa !5
  %inc = add nsw i32 %70, 1
  store i32 %inc, i32* %i, align 4, !tbaa !5
  br label %for.cond

for.end:                                          ; preds = %if.then.87, %if.then.64, %for.cond
  %71 = load i32, i32* %tfd, align 4, !tbaa !5
  %cmp119 = icmp slt i32 %71, 0
  br i1 %cmp119, label %if.then.125, label %lor.lhs.false.121

lor.lhs.false.121:                                ; preds = %for.end
  %72 = bitcast i32* %tfd to i8*
  %call122 = call %struct.sm_file* @sm_io_open(%struct.sm_file* @SmFtStdiofd_def, i32 -2, i8* %72, i32 3, i8* null)
  store %struct.sm_file* %call122, %struct.sm_file** %tfp, align 8, !tbaa !1
  %cmp123 = icmp eq %struct.sm_file* %call122, null
  br i1 %cmp123, label %if.then.125, label %if.end.132

if.then.125:                                      ; preds = %lor.lhs.false.121, %for.end
  %73 = bitcast i32* %save_errno126 to i8*
  call void @llvm.lifetime.start(i64 4, i8* %73) #1
  %call127 = call i32* @__errno_location() #11
  %74 = load i32, i32* %call127, align 4, !tbaa !5
  store i32 %74, i32* %save_errno126, align 4, !tbaa !5
  call void @printopenfds(i32 1)
  %75 = load i32, i32* %save_errno126, align 4, !tbaa !5
  %call128 = call i32* @__errno_location() #11
  store i32 %75, i32* %call128, align 4, !tbaa !5
  %arraydecay129 = getelementptr inbounds [4096 x i8], [4096 x i8]* %tf, i32 0, i32 0
  %call130 = call i32 @geteuid() #1
  %conv131 = zext i32 %call130 to i64
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str.4, i32 0, i32 0), i8* %arraydecay129, i64 %conv131)
  %76 = bitcast i32* %save_errno126 to i8*
  call void @llvm.lifetime.end(i64 4, i8* %76) #1
  br label %if.end.132

if.end.132:                                       ; preds = %if.then.125, %lor.lhs.false.121
  br label %if.end.133

if.end.133:                                       ; preds = %if.end.132, %if.end.32
  %77 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 40), align 1, !tbaa !17
  %conv134 = zext i8 %77 to i32
  %cmp135 = icmp sge i32 %conv134, 1
  br i1 %cmp135, label %land.lhs.true.137, label %if.end.143

land.lhs.true.137:                                ; preds = %if.end.133
  %78 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool138 = icmp ne i32 %78, 0
  br i1 %tobool138, label %if.end.143, label %if.then.139

if.then.139:                                      ; preds = %land.lhs.true.137
  %79 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qgrp = getelementptr inbounds %struct.envelope, %struct.envelope* %79, i32 0, i32 26
  %80 = load i32, i32* %e_qgrp, align 4, !tbaa !18
  %81 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qdir = getelementptr inbounds %struct.envelope, %struct.envelope* %81, i32 0, i32 27
  %82 = load i32, i32* %e_qdir, align 4, !tbaa !19
  %call140 = call i8* @qid_printqueue(i32 %80, i32 %82)
  %83 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %call141 = call i8* @queuename(%struct.envelope* %83, i32 63)
  %84 = load i32, i32* %newid, align 4, !tbaa !5
  %tobool142 = icmp ne i32 %84, 0
  %cond = select i1 %tobool142, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.6, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0)
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.5, i32 0, i32 0), i8* %call140, i8* %call141, i8* %cond)
  br label %if.end.143

if.end.143:                                       ; preds = %if.then.139, %land.lhs.true.137, %if.end.133
  %85 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 40), align 1, !tbaa !17
  %conv144 = zext i8 %85 to i32
  %cmp145 = icmp sge i32 %conv144, 3
  br i1 %cmp145, label %land.lhs.true.147, label %if.end.150

land.lhs.true.147:                                ; preds = %if.end.143
  %86 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool148 = icmp ne i32 %86, 0
  br i1 %tobool148, label %if.end.150, label %if.then.149

if.then.149:                                      ; preds = %land.lhs.true.147
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.8, i32 0, i32 0))
  %87 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  call void @printenvflags(%struct.envelope* %87)
  br label %if.end.150

if.end.150:                                       ; preds = %if.then.149, %land.lhs.true.147, %if.end.143
  %88 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 40), align 1, !tbaa !17
  %conv151 = zext i8 %88 to i32
  %cmp152 = icmp sge i32 %conv151, 32
  br i1 %cmp152, label %land.lhs.true.154, label %if.end.158

land.lhs.true.154:                                ; preds = %if.end.150
  %89 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool155 = icmp ne i32 %89, 0
  br i1 %tobool155, label %if.end.158, label %if.then.156

if.then.156:                                      ; preds = %land.lhs.true.154
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.9, i32 0, i32 0))
  %call157 = call %struct.sm_file* @sm_debug_file()
  %90 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_sendqueue = getelementptr inbounds %struct.envelope, %struct.envelope* %90, i32 0, i32 7
  %91 = load %struct.address*, %struct.address** %e_sendqueue, align 8, !tbaa !20
  call void @printaddr(%struct.sm_file* %call157, %struct.address* %91, i32 1)
  br label %if.end.158

if.end.158:                                       ; preds = %if.then.156, %land.lhs.true.154, %if.end.150
  %92 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 40), align 1, !tbaa !17
  %conv159 = zext i8 %92 to i32
  %cmp160 = icmp sge i32 %conv159, 9
  br i1 %cmp160, label %land.lhs.true.162, label %if.end.174

land.lhs.true.162:                                ; preds = %if.end.158
  %93 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool163 = icmp ne i32 %93, 0
  br i1 %tobool163, label %if.end.174, label %if.then.164

if.then.164:                                      ; preds = %land.lhs.true.162
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.10, i32 0, i32 0))
  %94 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  %call165 = call i32 @sm_io_getinfo(%struct.sm_file* %94, i32 3, i8* null)
  call void @dumpfd(i32 %call165, i32 1, i32 0)
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.11, i32 0, i32 0))
  %95 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_lockfp166 = getelementptr inbounds %struct.envelope, %struct.envelope* %95, i32 0, i32 33
  %96 = load %struct.sm_file*, %struct.sm_file** %e_lockfp166, align 8, !tbaa !16
  %cmp167 = icmp eq %struct.sm_file* %96, null
  br i1 %cmp167, label %if.then.169, label %if.else.170

if.then.169:                                      ; preds = %if.then.164
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.12, i32 0, i32 0))
  br label %if.end.173

if.else.170:                                      ; preds = %if.then.164
  %97 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_lockfp171 = getelementptr inbounds %struct.envelope, %struct.envelope* %97, i32 0, i32 33
  %98 = load %struct.sm_file*, %struct.sm_file** %e_lockfp171, align 8, !tbaa !16
  %call172 = call i32 @sm_io_getinfo(%struct.sm_file* %98, i32 3, i8* null)
  call void @dumpfd(i32 %call172, i32 1, i32 0)
  br label %if.end.173

if.end.173:                                       ; preds = %if.else.170, %if.then.169
  br label %if.end.174

if.end.174:                                       ; preds = %if.end.173, %land.lhs.true.162, %if.end.158
  %arraydecay175 = getelementptr inbounds [4096 x i8], [4096 x i8]* %df, i32 0, i32 0
  %99 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %call176 = call i8* @queuename(%struct.envelope* %99, i32 100)
  %call177 = call i64 @sm_strlcpy(i8* %arraydecay175, i8* %call176, i64 4096)
  %100 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_flags178 = getelementptr inbounds %struct.envelope, %struct.envelope* %100, i32 0, i32 11
  %101 = load i64, i64* %e_flags178, align 8, !tbaa !15
  %and179 = and i64 %101, 2097152
  %cmp180 = icmp ne i64 %and179, 0
  br i1 %cmp180, label %if.then.182, label %if.else.236

if.then.182:                                      ; preds = %if.end.174
  %102 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_dfp = getelementptr inbounds %struct.envelope, %struct.envelope* %102, i32 0, i32 24
  %103 = load %struct.sm_file*, %struct.sm_file** %e_dfp, align 8, !tbaa !21
  %cmp183 = icmp ne %struct.sm_file* %103, null
  br i1 %cmp183, label %land.lhs.true.185, label %if.end.204

land.lhs.true.185:                                ; preds = %if.then.182
  %104 = load i32, i32* @SuperSafe, align 4, !tbaa !5
  %cmp186 = icmp ne i32 %104, 2
  br i1 %cmp186, label %land.lhs.true.188, label %if.end.204

land.lhs.true.188:                                ; preds = %land.lhs.true.185
  %105 = load i32, i32* @SuperSafe, align 4, !tbaa !5
  %cmp189 = icmp ne i32 %105, 3
  br i1 %cmp189, label %land.lhs.true.191, label %if.end.204

land.lhs.true.191:                                ; preds = %land.lhs.true.188
  %106 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_dfp192 = getelementptr inbounds %struct.envelope, %struct.envelope* %106, i32 0, i32 24
  %107 = load %struct.sm_file*, %struct.sm_file** %e_dfp192, align 8, !tbaa !21
  %call193 = call i32 @sm_io_setinfo(%struct.sm_file* %107, i32 1001, i8* null)
  %cmp194 = icmp slt i32 %call193, 0
  br i1 %cmp194, label %land.lhs.true.196, label %if.end.204

land.lhs.true.196:                                ; preds = %land.lhs.true.191
  %call197 = call i32* @__errno_location() #11
  %108 = load i32, i32* %call197, align 4, !tbaa !5
  %cmp198 = icmp ne i32 %108, 22
  br i1 %cmp198, label %if.then.200, label %if.end.204

if.then.200:                                      ; preds = %land.lhs.true.196
  %109 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %call201 = call i8* @queuename(%struct.envelope* %109, i32 100)
  %call202 = call i32 @geteuid() #1
  %conv203 = zext i32 %call202 to i64
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([46 x i8], [46 x i8]* @.str.13, i32 0, i32 0), i8* %call201, i64 %conv203)
  br label %if.end.204

if.end.204:                                       ; preds = %if.then.200, %land.lhs.true.196, %land.lhs.true.191, %land.lhs.true.188, %land.lhs.true.185, %if.then.182
  %110 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_dfp205 = getelementptr inbounds %struct.envelope, %struct.envelope* %110, i32 0, i32 24
  %111 = load %struct.sm_file*, %struct.sm_file** %e_dfp205, align 8, !tbaa !21
  %cmp206 = icmp ne %struct.sm_file* %111, null
  br i1 %cmp206, label %land.lhs.true.208, label %if.end.235

land.lhs.true.208:                                ; preds = %if.end.204
  %112 = load i32, i32* @SuperSafe, align 4, !tbaa !5
  %cmp209 = icmp eq i32 %112, 1
  br i1 %cmp209, label %land.lhs.true.211, label %if.end.235

land.lhs.true.211:                                ; preds = %land.lhs.true.208
  %113 = load i32, i32* %msync.addr, align 4, !tbaa !5
  %tobool212 = icmp ne i32 %113, 0
  br i1 %tobool212, label %if.then.213, label %if.end.235

if.then.213:                                      ; preds = %land.lhs.true.211
  %114 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 40), align 1, !tbaa !17
  %conv214 = zext i8 %114 to i32
  %cmp215 = icmp sge i32 %conv214, 32
  br i1 %cmp215, label %land.lhs.true.217, label %if.end.221

land.lhs.true.217:                                ; preds = %if.then.213
  %115 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool218 = icmp ne i32 %115, 0
  br i1 %tobool218, label %if.end.221, label %if.then.219

if.then.219:                                      ; preds = %land.lhs.true.217
  %116 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id220 = getelementptr inbounds %struct.envelope, %struct.envelope* %116, i32 0, i32 25
  %117 = load i8*, i8** %e_id220, align 8, !tbaa !7
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 6, i8* %117, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.14, i32 0, i32 0))
  br label %if.end.221

if.end.221:                                       ; preds = %if.then.219, %land.lhs.true.217, %if.then.213
  %118 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_dfp222 = getelementptr inbounds %struct.envelope, %struct.envelope* %118, i32 0, i32 24
  %119 = load %struct.sm_file*, %struct.sm_file** %e_dfp222, align 8, !tbaa !21
  %call223 = call i32 @sm_io_getinfo(%struct.sm_file* %119, i32 3, i8* null)
  %call224 = call i32 @fsync(i32 %call223)
  %cmp225 = icmp slt i32 %call224, 0
  br i1 %cmp225, label %if.then.227, label %if.end.234

if.then.227:                                      ; preds = %if.end.221
  %120 = load i32, i32* %newid, align 4, !tbaa !5
  %tobool228 = icmp ne i32 %120, 0
  br i1 %tobool228, label %if.then.229, label %if.else.231

if.then.229:                                      ; preds = %if.then.227
  %arraydecay230 = getelementptr inbounds [4096 x i8], [4096 x i8]* %df, i32 0, i32 0
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.15, i32 0, i32 0), i8* %arraydecay230)
  br label %if.end.233

if.else.231:                                      ; preds = %if.then.227
  %arraydecay232 = getelementptr inbounds [4096 x i8], [4096 x i8]* %df, i32 0, i32 0
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.16, i32 0, i32 0), i8* %arraydecay232)
  br label %if.end.233

if.end.233:                                       ; preds = %if.else.231, %if.then.229
  br label %if.end.234

if.end.234:                                       ; preds = %if.end.233, %if.end.221
  br label %if.end.235

if.end.235:                                       ; preds = %if.end.234, %land.lhs.true.211, %land.lhs.true.208, %if.end.204
  br label %if.end.322

if.else.236:                                      ; preds = %if.end.174
  %121 = bitcast i32* %dfd to i8*
  call void @llvm.lifetime.start(i64 4, i8* %121) #1
  %122 = bitcast i32* %oldumask237 to i8*
  call void @llvm.lifetime.start(i64 4, i8* %122) #1
  store i32 0, i32* %oldumask237, align 4, !tbaa !5
  %123 = bitcast %struct.sm_file** %dfp to i8*
  call void @llvm.lifetime.start(i64 8, i8* %123) #1
  store %struct.sm_file* null, %struct.sm_file** %dfp, align 8, !tbaa !1
  %124 = bitcast %struct.stat* %stbuf to i8*
  call void @llvm.lifetime.start(i64 144, i8* %124) #1
  %125 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_dfp238 = getelementptr inbounds %struct.envelope, %struct.envelope* %125, i32 0, i32 24
  %126 = load %struct.sm_file*, %struct.sm_file** %e_dfp238, align 8, !tbaa !21
  %cmp239 = icmp ne %struct.sm_file* %126, null
  br i1 %cmp239, label %land.lhs.true.241, label %if.end.246

land.lhs.true.241:                                ; preds = %if.else.236
  %127 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_dfp242 = getelementptr inbounds %struct.envelope, %struct.envelope* %127, i32 0, i32 24
  %128 = load %struct.sm_file*, %struct.sm_file** %e_dfp242, align 8, !tbaa !21
  %call243 = call i32 @sm_io_getinfo(%struct.sm_file* %128, i32 5, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.17, i32 0, i32 0))
  %tobool244 = icmp ne i32 %call243, 0
  br i1 %tobool244, label %if.then.245, label %if.end.246

if.then.245:                                      ; preds = %land.lhs.true.241
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.18, i32 0, i32 0))
  br label %if.end.246

if.end.246:                                       ; preds = %if.then.245, %land.lhs.true.241, %if.else.236
  %129 = load i32, i32* @QueueFileMode, align 4, !tbaa !5
  %and247 = and i32 %129, 16
  %cmp248 = icmp ne i32 %and247, 0
  br i1 %cmp248, label %if.then.250, label %if.end.252

if.then.250:                                      ; preds = %if.end.246
  %call251 = call i32 @umask(i32 2) #1
  store i32 %call251, i32* %oldumask237, align 4, !tbaa !5
  br label %if.end.252

if.end.252:                                       ; preds = %if.then.250, %if.end.246
  %arraydecay253 = getelementptr inbounds [4096 x i8], [4096 x i8]* %df, i32 0, i32 0
  %130 = load i32, i32* @QueueFileMode, align 4, !tbaa !5
  %call254 = call i32 (i8*, i32, ...) @open(i8* %arraydecay253, i32 577, i32 %130)
  store i32 %call254, i32* %dfd, align 4, !tbaa !5
  %131 = load i32, i32* @QueueFileMode, align 4, !tbaa !5
  %and255 = and i32 %131, 16
  %cmp256 = icmp ne i32 %and255, 0
  br i1 %cmp256, label %if.then.258, label %if.end.260

if.then.258:                                      ; preds = %if.end.252
  %132 = load i32, i32* %oldumask237, align 4, !tbaa !5
  %call259 = call i32 @umask(i32 %132) #1
  br label %if.end.260

if.end.260:                                       ; preds = %if.then.258, %if.end.252
  %133 = load i32, i32* %dfd, align 4, !tbaa !5
  %cmp261 = icmp slt i32 %133, 0
  br i1 %cmp261, label %if.then.267, label %lor.lhs.false.263

lor.lhs.false.263:                                ; preds = %if.end.260
  %134 = bitcast i32* %dfd to i8*
  %call264 = call %struct.sm_file* @sm_io_open(%struct.sm_file* @SmFtStdiofd_def, i32 -2, i8* %134, i32 3, i8* null)
  store %struct.sm_file* %call264, %struct.sm_file** %dfp, align 8, !tbaa !1
  %cmp265 = icmp eq %struct.sm_file* %call264, null
  br i1 %cmp265, label %if.then.267, label %if.end.271

if.then.267:                                      ; preds = %lor.lhs.false.263, %if.end.260
  %arraydecay268 = getelementptr inbounds [4096 x i8], [4096 x i8]* %df, i32 0, i32 0
  %call269 = call i32 @geteuid() #1
  %conv270 = zext i32 %call269 to i64
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([51 x i8], [51 x i8]* @.str.19, i32 0, i32 0), i8* %arraydecay268, i64 %conv270)
  br label %if.end.271

if.end.271:                                       ; preds = %if.then.267, %lor.lhs.false.263
  %135 = load i32, i32* %dfd, align 4, !tbaa !5
  %call272 = call i32 @fstat(i32 %135, %struct.stat* %stbuf) #1
  %cmp273 = icmp slt i32 %call272, 0
  br i1 %cmp273, label %if.then.275, label %if.else.276

if.then.275:                                      ; preds = %if.end.271
  %136 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_dfino = getelementptr inbounds %struct.envelope, %struct.envelope* %136, i32 0, i32 45
  store i64 -1, i64* %e_dfino, align 8, !tbaa !22
  br label %if.end.278

if.else.276:                                      ; preds = %if.end.271
  %st_dev = getelementptr inbounds %struct.stat, %struct.stat* %stbuf, i32 0, i32 0
  %137 = load i64, i64* %st_dev, align 8, !tbaa !23
  %138 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_dfdev = getelementptr inbounds %struct.envelope, %struct.envelope* %138, i32 0, i32 44
  store i64 %137, i64* %e_dfdev, align 8, !tbaa !26
  %st_ino = getelementptr inbounds %struct.stat, %struct.stat* %stbuf, i32 0, i32 1
  %139 = load i64, i64* %st_ino, align 8, !tbaa !27
  %140 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_dfino277 = getelementptr inbounds %struct.envelope, %struct.envelope* %140, i32 0, i32 45
  store i64 %139, i64* %e_dfino277, align 8, !tbaa !22
  br label %if.end.278

if.end.278:                                       ; preds = %if.else.276, %if.then.275
  %141 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_flags279 = getelementptr inbounds %struct.envelope, %struct.envelope* %141, i32 0, i32 11
  %142 = load i64, i64* %e_flags279, align 8, !tbaa !15
  %or = or i64 %142, 2097152
  store i64 %or, i64* %e_flags279, align 8, !tbaa !15
  %143 = bitcast %struct.mailer_con_info* %mcibuf to i8*
  call void @llvm.memset.p0i8.i64(i8* %143, i8 0, i64 2256, i32 8, i1 false)
  %144 = load %struct.sm_file*, %struct.sm_file** %dfp, align 8, !tbaa !1
  %mci_out = getelementptr inbounds %struct.mailer_con_info, %struct.mailer_con_info* %mcibuf, i32 0, i32 8
  store %struct.sm_file* %144, %struct.sm_file** %mci_out, align 8, !tbaa !28
  %145 = load %struct.mailer*, %struct.mailer** @FileMailer, align 8, !tbaa !1
  %mci_mailer = getelementptr inbounds %struct.mailer_con_info, %struct.mailer_con_info* %mcibuf, i32 0, i32 11
  store %struct.mailer* %145, %struct.mailer** %mci_mailer, align 8, !tbaa !30
  %146 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_putbody = getelementptr inbounds %struct.envelope, %struct.envelope* %146, i32 0, i32 20
  %147 = load i32 (%struct.mailer_con_info*, %struct.envelope*, i8*)*, i32 (%struct.mailer_con_info*, %struct.envelope*, i8*)** %e_putbody, align 8, !tbaa !31
  %148 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %call280 = call i32 %147(%struct.mailer_con_info* %mcibuf, %struct.envelope* %148, i8* null)
  %149 = load i32, i32* @SuperSafe, align 4, !tbaa !5
  %cmp281 = icmp eq i32 %149, 2
  br i1 %cmp281, label %if.then.291, label %lor.lhs.false.283

lor.lhs.false.283:                                ; preds = %if.end.278
  %150 = load i32, i32* @SuperSafe, align 4, !tbaa !5
  %cmp284 = icmp eq i32 %150, 3
  br i1 %cmp284, label %if.then.291, label %lor.lhs.false.286

lor.lhs.false.286:                                ; preds = %lor.lhs.false.283
  %151 = load i32, i32* @SuperSafe, align 4, !tbaa !5
  %cmp287 = icmp eq i32 %151, 1
  br i1 %cmp287, label %land.lhs.true.289, label %if.end.312

land.lhs.true.289:                                ; preds = %lor.lhs.false.286
  %152 = load i32, i32* %msync.addr, align 4, !tbaa !5
  %tobool290 = icmp ne i32 %152, 0
  br i1 %tobool290, label %if.then.291, label %if.end.312

if.then.291:                                      ; preds = %land.lhs.true.289, %lor.lhs.false.283, %if.end.278
  %153 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 40), align 1, !tbaa !17
  %conv292 = zext i8 %153 to i32
  %cmp293 = icmp sge i32 %conv292, 32
  br i1 %cmp293, label %land.lhs.true.295, label %if.end.299

land.lhs.true.295:                                ; preds = %if.then.291
  %154 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool296 = icmp ne i32 %154, 0
  br i1 %tobool296, label %if.end.299, label %if.then.297

if.then.297:                                      ; preds = %land.lhs.true.295
  %155 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id298 = getelementptr inbounds %struct.envelope, %struct.envelope* %155, i32 0, i32 25
  %156 = load i8*, i8** %e_id298, align 8, !tbaa !7
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 6, i8* %156, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.20, i32 0, i32 0))
  br label %if.end.299

if.end.299:                                       ; preds = %if.then.297, %land.lhs.true.295, %if.then.291
  %157 = load %struct.sm_file*, %struct.sm_file** %dfp, align 8, !tbaa !1
  %call300 = call i32 @sm_io_getinfo(%struct.sm_file* %157, i32 3, i8* null)
  %call301 = call i32 @fsync(i32 %call300)
  %cmp302 = icmp slt i32 %call301, 0
  br i1 %cmp302, label %if.then.304, label %if.end.311

if.then.304:                                      ; preds = %if.end.299
  %158 = load i32, i32* %newid, align 4, !tbaa !5
  %tobool305 = icmp ne i32 %158, 0
  br i1 %tobool305, label %if.then.306, label %if.else.308

if.then.306:                                      ; preds = %if.then.304
  %arraydecay307 = getelementptr inbounds [4096 x i8], [4096 x i8]* %df, i32 0, i32 0
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.15, i32 0, i32 0), i8* %arraydecay307)
  br label %if.end.310

if.else.308:                                      ; preds = %if.then.304
  %arraydecay309 = getelementptr inbounds [4096 x i8], [4096 x i8]* %df, i32 0, i32 0
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.16, i32 0, i32 0), i8* %arraydecay309)
  br label %if.end.310

if.end.310:                                       ; preds = %if.else.308, %if.then.306
  br label %if.end.311

if.end.311:                                       ; preds = %if.end.310, %if.end.299
  br label %if.end.312

if.end.312:                                       ; preds = %if.end.311, %land.lhs.true.289, %lor.lhs.false.286
  %159 = load %struct.sm_file*, %struct.sm_file** %dfp, align 8, !tbaa !1
  %call313 = call i32 @sm_io_close(%struct.sm_file* %159, i32 -2)
  %cmp314 = icmp slt i32 %call313, 0
  br i1 %cmp314, label %if.then.316, label %if.end.320

if.then.316:                                      ; preds = %if.end.312
  %arraydecay317 = getelementptr inbounds [4096 x i8], [4096 x i8]* %df, i32 0, i32 0
  %call318 = call i32 @geteuid() #1
  %conv319 = zext i32 %call318 to i64
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.21, i32 0, i32 0), i8* %arraydecay317, i64 %conv319)
  br label %if.end.320

if.end.320:                                       ; preds = %if.then.316, %if.end.312
  %160 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_putbody321 = getelementptr inbounds %struct.envelope, %struct.envelope* %160, i32 0, i32 20
  store i32 (%struct.mailer_con_info*, %struct.envelope*, i8*)* @putbody, i32 (%struct.mailer_con_info*, %struct.envelope*, i8*)** %e_putbody321, align 8, !tbaa !31
  %161 = bitcast %struct.stat* %stbuf to i8*
  call void @llvm.lifetime.end(i64 144, i8* %161) #1
  %162 = bitcast %struct.sm_file** %dfp to i8*
  call void @llvm.lifetime.end(i64 8, i8* %162) #1
  %163 = bitcast i32* %oldumask237 to i8*
  call void @llvm.lifetime.end(i64 4, i8* %163) #1
  %164 = bitcast i32* %dfd to i8*
  call void @llvm.lifetime.end(i64 4, i8* %164) #1
  br label %if.end.322

if.end.322:                                       ; preds = %if.end.320, %if.end.235
  %165 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  %call323 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* %165, i32 -2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.22, i32 0, i32 0), i32 8)
  %166 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  %167 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_ctime = getelementptr inbounds %struct.envelope, %struct.envelope* %167, i32 0, i32 2
  %168 = load i64, i64* %e_ctime, align 8, !tbaa !32
  %call324 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* %166, i32 -2, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.23, i32 0, i32 0), i64 %168)
  %169 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  %170 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_dtime = getelementptr inbounds %struct.envelope, %struct.envelope* %170, i32 0, i32 42
  %171 = load i64, i64* %e_dtime, align 8, !tbaa !33
  %call325 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* %169, i32 -2, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.24, i32 0, i32 0), i64 %171)
  %172 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  %173 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_ntries = getelementptr inbounds %struct.envelope, %struct.envelope* %173, i32 0, i32 43
  %174 = load i32, i32* %e_ntries, align 4, !tbaa !34
  %call326 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* %172, i32 -2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.25, i32 0, i32 0), i32 %174)
  %175 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  %176 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_msgpriority = getelementptr inbounds %struct.envelope, %struct.envelope* %176, i32 0, i32 1
  %177 = load i64, i64* %e_msgpriority, align 8, !tbaa !35
  %call327 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* %175, i32 -2, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.26, i32 0, i32 0), i64 %177)
  %178 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_dfqgrp = getelementptr inbounds %struct.envelope, %struct.envelope* %178, i32 0, i32 28
  %179 = load i32, i32* %e_dfqgrp, align 4, !tbaa !36
  %180 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qgrp328 = getelementptr inbounds %struct.envelope, %struct.envelope* %180, i32 0, i32 26
  %181 = load i32, i32* %e_qgrp328, align 4, !tbaa !18
  %cmp329 = icmp ne i32 %179, %181
  br i1 %cmp329, label %if.then.331, label %if.end.336

if.then.331:                                      ; preds = %if.end.322
  %182 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  %183 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_dfqdir = getelementptr inbounds %struct.envelope, %struct.envelope* %183, i32 0, i32 29
  %184 = load i32, i32* %e_dfqdir, align 4, !tbaa !37
  %idxprom = sext i32 %184 to i64
  %185 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_dfqgrp332 = getelementptr inbounds %struct.envelope, %struct.envelope* %185, i32 0, i32 28
  %186 = load i32, i32* %e_dfqgrp332, align 4, !tbaa !36
  %idxprom333 = sext i32 %186 to i64
  %arrayidx = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom333
  %187 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx, align 8, !tbaa !1
  %qg_qpaths = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %187, i32 0, i32 6
  %188 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths, align 8, !tbaa !38
  %arrayidx334 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %188, i64 %idxprom
  %qp_name = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %arrayidx334, i32 0, i32 0
  %189 = load i8*, i8** %qp_name, align 8, !tbaa !40
  %call335 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* %182, i32 -2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.27, i32 0, i32 0), i8* %189)
  br label %if.end.336

if.end.336:                                       ; preds = %if.then.331, %if.end.322
  %190 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_dfino337 = getelementptr inbounds %struct.envelope, %struct.envelope* %190, i32 0, i32 45
  %191 = load i64, i64* %e_dfino337, align 8, !tbaa !22
  %cmp338 = icmp ne i64 %191, -1
  br i1 %cmp338, label %if.then.340, label %if.end.349

if.then.340:                                      ; preds = %if.end.336
  %192 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  %193 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_dfdev341 = getelementptr inbounds %struct.envelope, %struct.envelope* %193, i32 0, i32 44
  %194 = load i64, i64* %e_dfdev341, align 8, !tbaa !26
  %call342 = call i32 @gnu_dev_major(i64 %194) #11
  %conv343 = zext i32 %call342 to i64
  %195 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_dfdev344 = getelementptr inbounds %struct.envelope, %struct.envelope* %195, i32 0, i32 44
  %196 = load i64, i64* %e_dfdev344, align 8, !tbaa !26
  %call345 = call i32 @gnu_dev_minor(i64 %196) #11
  %conv346 = zext i32 %call345 to i64
  %197 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_dfino347 = getelementptr inbounds %struct.envelope, %struct.envelope* %197, i32 0, i32 45
  %198 = load i64, i64* %e_dfino347, align 8, !tbaa !22
  %call348 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* %192, i32 -2, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.28, i32 0, i32 0), i64 %conv343, i64 %conv346, i64 %198)
  br label %if.end.349

if.end.349:                                       ; preds = %if.then.340, %if.end.336
  %199 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_bodytype = getelementptr inbounds %struct.envelope, %struct.envelope* %199, i32 0, i32 23
  %200 = load i8*, i8** %e_bodytype, align 8, !tbaa !42
  %cmp350 = icmp ne i8* %200, null
  br i1 %cmp350, label %if.then.352, label %if.end.356

if.then.352:                                      ; preds = %if.end.349
  %201 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  %202 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_bodytype353 = getelementptr inbounds %struct.envelope, %struct.envelope* %202, i32 0, i32 23
  %203 = load i8*, i8** %e_bodytype353, align 8, !tbaa !42
  %call354 = call i8* @denlstring(i8* %203, i32 1, i32 0)
  %call355 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* %201, i32 -2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.29, i32 0, i32 0), i8* %call354)
  br label %if.end.356

if.end.356:                                       ; preds = %if.then.352, %if.end.349
  %204 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_quarmsg = getelementptr inbounds %struct.envelope, %struct.envelope* %204, i32 0, i32 36
  %205 = load i8*, i8** %e_quarmsg, align 8, !tbaa !43
  %cmp357 = icmp ne i8* %205, null
  br i1 %cmp357, label %if.then.359, label %if.end.363

if.then.359:                                      ; preds = %if.end.356
  %206 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  %207 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_quarmsg360 = getelementptr inbounds %struct.envelope, %struct.envelope* %207, i32 0, i32 36
  %208 = load i8*, i8** %e_quarmsg360, align 8, !tbaa !43
  %call361 = call i8* @denlstring(i8* %208, i32 1, i32 0)
  %call362 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* %206, i32 -2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.30, i32 0, i32 0), i8* %call361)
  br label %if.end.363

if.end.363:                                       ; preds = %if.then.359, %if.end.356
  %209 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_message = getelementptr inbounds %struct.envelope, %struct.envelope* %209, i32 0, i32 34
  %210 = load i8*, i8** %e_message, align 8, !tbaa !44
  %cmp364 = icmp ne i8* %210, null
  br i1 %cmp364, label %if.then.366, label %if.end.370

if.then.366:                                      ; preds = %if.end.363
  %211 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  %212 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_message367 = getelementptr inbounds %struct.envelope, %struct.envelope* %212, i32 0, i32 34
  %213 = load i8*, i8** %e_message367, align 8, !tbaa !44
  %call368 = call i8* @denlstring(i8* %213, i32 1, i32 0)
  %call369 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* %211, i32 -2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.31, i32 0, i32 0), i8* %call368)
  br label %if.end.370

if.end.370:                                       ; preds = %if.then.366, %if.end.363
  %arraydecay371 = getelementptr inbounds [2048 x i8], [2048 x i8]* %buf, i32 0, i32 0
  store i8* %arraydecay371, i8** %p, align 8, !tbaa !1
  %214 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_flags372 = getelementptr inbounds %struct.envelope, %struct.envelope* %214, i32 0, i32 11
  %215 = load i64, i64* %e_flags372, align 8, !tbaa !15
  %and373 = and i64 %215, 1024
  %cmp374 = icmp ne i64 %and373, 0
  br i1 %cmp374, label %if.then.376, label %if.end.377

if.then.376:                                      ; preds = %if.end.370
  %216 = load i8*, i8** %p, align 8, !tbaa !1
  %incdec.ptr = getelementptr inbounds i8, i8* %216, i32 1
  store i8* %incdec.ptr, i8** %p, align 8, !tbaa !1
  store i8 119, i8* %216, align 1, !tbaa !17
  br label %if.end.377

if.end.377:                                       ; preds = %if.then.376, %if.end.370
  %217 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_flags378 = getelementptr inbounds %struct.envelope, %struct.envelope* %217, i32 0, i32 11
  %218 = load i64, i64* %e_flags378, align 8, !tbaa !15
  %and379 = and i64 %218, 128
  %cmp380 = icmp ne i64 %and379, 0
  br i1 %cmp380, label %if.then.382, label %if.end.384

if.then.382:                                      ; preds = %if.end.377
  %219 = load i8*, i8** %p, align 8, !tbaa !1
  %incdec.ptr383 = getelementptr inbounds i8, i8* %219, i32 1
  store i8* %incdec.ptr383, i8** %p, align 8, !tbaa !1
  store i8 114, i8* %219, align 1, !tbaa !17
  br label %if.end.384

if.end.384:                                       ; preds = %if.then.382, %if.end.377
  %220 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_flags385 = getelementptr inbounds %struct.envelope, %struct.envelope* %220, i32 0, i32 11
  %221 = load i64, i64* %e_flags385, align 8, !tbaa !15
  %and386 = and i64 %221, 131072
  %cmp387 = icmp ne i64 %and386, 0
  br i1 %cmp387, label %if.then.389, label %if.end.391

if.then.389:                                      ; preds = %if.end.384
  %222 = load i8*, i8** %p, align 8, !tbaa !1
  %incdec.ptr390 = getelementptr inbounds i8, i8* %222, i32 1
  store i8* %incdec.ptr390, i8** %p, align 8, !tbaa !1
  store i8 56, i8* %222, align 1, !tbaa !17
  br label %if.end.391

if.end.391:                                       ; preds = %if.then.389, %if.end.384
  %223 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_flags392 = getelementptr inbounds %struct.envelope, %struct.envelope* %223, i32 0, i32 11
  %224 = load i64, i64* %e_flags392, align 8, !tbaa !15
  %and393 = and i64 %224, 64
  %cmp394 = icmp ne i64 %and393, 0
  br i1 %cmp394, label %if.then.396, label %if.end.398

if.then.396:                                      ; preds = %if.end.391
  %225 = load i8*, i8** %p, align 8, !tbaa !1
  %incdec.ptr397 = getelementptr inbounds i8, i8* %225, i32 1
  store i8* %incdec.ptr397, i8** %p, align 8, !tbaa !1
  store i8 98, i8* %225, align 1, !tbaa !17
  br label %if.end.398

if.end.398:                                       ; preds = %if.then.396, %if.end.391
  %226 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_flags399 = getelementptr inbounds %struct.envelope, %struct.envelope* %226, i32 0, i32 11
  %227 = load i64, i64* %e_flags399, align 8, !tbaa !15
  %and400 = and i64 %227, 1048576
  %cmp401 = icmp ne i64 %and400, 0
  br i1 %cmp401, label %if.then.403, label %if.end.405

if.then.403:                                      ; preds = %if.end.398
  %228 = load i8*, i8** %p, align 8, !tbaa !1
  %incdec.ptr404 = getelementptr inbounds i8, i8* %228, i32 1
  store i8* %incdec.ptr404, i8** %p, align 8, !tbaa !1
  store i8 100, i8* %228, align 1, !tbaa !17
  br label %if.end.405

if.end.405:                                       ; preds = %if.then.403, %if.end.398
  %229 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_flags406 = getelementptr inbounds %struct.envelope, %struct.envelope* %229, i32 0, i32 11
  %230 = load i64, i64* %e_flags406, align 8, !tbaa !15
  %and407 = and i64 %230, 4
  %cmp408 = icmp ne i64 %and407, 0
  br i1 %cmp408, label %if.then.410, label %if.end.412

if.then.410:                                      ; preds = %if.end.405
  %231 = load i8*, i8** %p, align 8, !tbaa !1
  %incdec.ptr411 = getelementptr inbounds i8, i8* %231, i32 1
  store i8* %incdec.ptr411, i8** %p, align 8, !tbaa !1
  store i8 110, i8* %231, align 1, !tbaa !17
  br label %if.end.412

if.end.412:                                       ; preds = %if.then.410, %if.end.405
  %232 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_flags413 = getelementptr inbounds %struct.envelope, %struct.envelope* %232, i32 0, i32 11
  %233 = load i64, i64* %e_flags413, align 8, !tbaa !15
  %and414 = and i64 %233, 67108864
  %cmp415 = icmp ne i64 %and414, 0
  br i1 %cmp415, label %if.then.417, label %if.end.419

if.then.417:                                      ; preds = %if.end.412
  %234 = load i8*, i8** %p, align 8, !tbaa !1
  %incdec.ptr418 = getelementptr inbounds i8, i8* %234, i32 1
  store i8* %incdec.ptr418, i8** %p, align 8, !tbaa !1
  store i8 115, i8* %234, align 1, !tbaa !17
  br label %if.end.419

if.end.419:                                       ; preds = %if.then.417, %if.end.412
  %235 = load i8*, i8** %p, align 8, !tbaa !1
  %incdec.ptr420 = getelementptr inbounds i8, i8* %235, i32 1
  store i8* %incdec.ptr420, i8** %p, align 8, !tbaa !1
  store i8 0, i8* %235, align 1, !tbaa !17
  %arrayidx421 = getelementptr inbounds [2048 x i8], [2048 x i8]* %buf, i32 0, i64 0
  %236 = load i8, i8* %arrayidx421, align 1, !tbaa !17
  %conv422 = sext i8 %236 to i32
  %cmp423 = icmp ne i32 %conv422, 0
  br i1 %cmp423, label %if.then.425, label %if.end.428

if.then.425:                                      ; preds = %if.end.419
  %237 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  %arraydecay426 = getelementptr inbounds [2048 x i8], [2048 x i8]* %buf, i32 0, i32 0
  %call427 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* %237, i32 -2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.32, i32 0, i32 0), i8* %arraydecay426)
  br label %if.end.428

if.end.428:                                       ; preds = %if.then.425, %if.end.419
  %call429 = call i32 @macid_parse(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.33, i32 0, i32 0), i8** null)
  %238 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  %239 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  call void @queueup_macros(i32 %call429, %struct.sm_file* %238, %struct.envelope* %239)
  %240 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_from = getelementptr inbounds %struct.envelope, %struct.envelope* %240, i32 0, i32 4
  %q_mailer = getelementptr inbounds %struct.address, %struct.address* %e_from, i32 0, i32 4
  %241 = load %struct.mailer*, %struct.mailer** %q_mailer, align 8, !tbaa !45
  %m_flags = getelementptr inbounds %struct.mailer, %struct.mailer* %241, i32 0, i32 5
  %arrayidx430 = getelementptr inbounds [8 x i32], [8 x i32]* %m_flags, i32 0, i64 3
  %242 = load i32, i32* %arrayidx430, align 4, !tbaa !5
  %and431 = and i32 %242, 512
  %tobool432 = icmp ne i32 %and431, 0
  br i1 %tobool432, label %if.then.433, label %if.else.434

if.then.433:                                      ; preds = %if.end.428
  %243 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_sender = getelementptr inbounds %struct.envelope, %struct.envelope* %243, i32 0, i32 5
  %244 = load i8*, i8** %e_sender, align 8, !tbaa !46
  store i8* %244, i8** %p, align 8, !tbaa !1
  br label %if.end.436

if.else.434:                                      ; preds = %if.end.428
  %245 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_from435 = getelementptr inbounds %struct.envelope, %struct.envelope* %245, i32 0, i32 4
  %q_paddr = getelementptr inbounds %struct.address, %struct.address* %e_from435, i32 0, i32 0
  %246 = load i8*, i8** %q_paddr, align 8, !tbaa !47
  store i8* %246, i8** %p, align 8, !tbaa !1
  br label %if.end.436

if.end.436:                                       ; preds = %if.else.434, %if.then.433
  %247 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  %248 = load i8*, i8** %p, align 8, !tbaa !1
  %call437 = call i8* @denlstring(i8* %248, i32 1, i32 0)
  %call438 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* %247, i32 -2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.34, i32 0, i32 0), i8* %call437)
  %249 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_envid = getelementptr inbounds %struct.envelope, %struct.envelope* %249, i32 0, i32 40
  %250 = load i8*, i8** %e_envid, align 8, !tbaa !48
  %cmp439 = icmp ne i8* %250, null
  br i1 %cmp439, label %if.then.441, label %if.end.445

if.then.441:                                      ; preds = %if.end.436
  %251 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  %252 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_envid442 = getelementptr inbounds %struct.envelope, %struct.envelope* %252, i32 0, i32 40
  %253 = load i8*, i8** %e_envid442, align 8, !tbaa !48
  %call443 = call i8* @denlstring(i8* %253, i32 1, i32 0)
  %call444 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* %251, i32 -2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.35, i32 0, i32 0), i8* %call443)
  br label %if.end.445

if.end.445:                                       ; preds = %if.then.441, %if.end.436
  %254 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_auth_param = getelementptr inbounds %struct.envelope, %struct.envelope* %254, i32 0, i32 48
  %255 = load i8*, i8** %e_auth_param, align 8, !tbaa !49
  %cmp446 = icmp ne i8* %255, null
  br i1 %cmp446, label %if.then.448, label %if.end.452

if.then.448:                                      ; preds = %if.end.445
  %256 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  %257 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_auth_param449 = getelementptr inbounds %struct.envelope, %struct.envelope* %257, i32 0, i32 48
  %258 = load i8*, i8** %e_auth_param449, align 8, !tbaa !49
  %call450 = call i8* @denlstring(i8* %258, i32 1, i32 0)
  %call451 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* %256, i32 -2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.36, i32 0, i32 0), i8* %call450)
  br label %if.end.452

if.end.452:                                       ; preds = %if.then.448, %if.end.445
  %259 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_dlvr_flag = getelementptr inbounds %struct.envelope, %struct.envelope* %259, i32 0, i32 51
  %260 = load i32, i32* %e_dlvr_flag, align 4, !tbaa !50
  %cmp453 = icmp ne i32 %260, 0
  br i1 %cmp453, label %if.then.455, label %if.end.460

if.then.455:                                      ; preds = %if.end.452
  %261 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  %262 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_dlvr_flag456 = getelementptr inbounds %struct.envelope, %struct.envelope* %262, i32 0, i32 51
  %263 = load i32, i32* %e_dlvr_flag456, align 4, !tbaa !50
  %conv457 = trunc i32 %263 to i8
  %conv458 = sext i8 %conv457 to i32
  %264 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_deliver_by = getelementptr inbounds %struct.envelope, %struct.envelope* %264, i32 0, i32 50
  %265 = load i64, i64* %e_deliver_by, align 8, !tbaa !51
  %call459 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* %261, i32 -2, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.37, i32 0, i32 0), i32 %conv458, i64 %265)
  br label %if.end.460

if.end.460:                                       ; preds = %if.then.455, %if.end.452
  call void @printctladdr(%struct.address* null, %struct.sm_file* null)
  %266 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_sendqueue461 = getelementptr inbounds %struct.envelope, %struct.envelope* %266, i32 0, i32 7
  %267 = load %struct.address*, %struct.address** %e_sendqueue461, align 8, !tbaa !20
  store %struct.address* %267, %struct.address** %q, align 8, !tbaa !1
  br label %for.cond.462

for.cond.462:                                     ; preds = %for.inc.594, %if.end.460
  %268 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %cmp463 = icmp ne %struct.address* %268, null
  br i1 %cmp463, label %for.body.465, label %for.end.595

for.body.465:                                     ; preds = %for.cond.462
  %269 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_state = getelementptr inbounds %struct.address, %struct.address* %269, i32 0, i32 21
  %270 = load i16, i16* %q_state, align 2, !tbaa !52
  %conv466 = sext i16 %270 to i32
  %cmp467 = icmp eq i32 %conv466, 0
  br i1 %cmp467, label %if.end.485, label %lor.lhs.false.469

lor.lhs.false.469:                                ; preds = %for.body.465
  %271 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_state470 = getelementptr inbounds %struct.address, %struct.address* %271, i32 0, i32 21
  %272 = load i16, i16* %q_state470, align 2, !tbaa !52
  %conv471 = sext i16 %272 to i32
  %cmp472 = icmp eq i32 %conv471, 3
  br i1 %cmp472, label %if.end.485, label %lor.lhs.false.474

lor.lhs.false.474:                                ; preds = %lor.lhs.false.469
  %273 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_state475 = getelementptr inbounds %struct.address, %struct.address* %273, i32 0, i32 21
  %274 = load i16, i16* %q_state475, align 2, !tbaa !52
  %conv476 = sext i16 %274 to i32
  %cmp477 = icmp eq i32 %conv476, 4
  br i1 %cmp477, label %if.end.485, label %lor.lhs.false.479

lor.lhs.false.479:                                ; preds = %lor.lhs.false.474
  %275 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_state480 = getelementptr inbounds %struct.address, %struct.address* %275, i32 0, i32 21
  %276 = load i16, i16* %q_state480, align 2, !tbaa !52
  %conv481 = sext i16 %276 to i32
  %cmp482 = icmp eq i32 %conv481, 5
  br i1 %cmp482, label %if.end.485, label %if.then.484

if.then.484:                                      ; preds = %lor.lhs.false.479
  br label %for.inc.594

if.end.485:                                       ; preds = %lor.lhs.false.479, %lor.lhs.false.474, %lor.lhs.false.469, %for.body.465
  %277 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_message = getelementptr inbounds %struct.address, %struct.address* %277, i32 0, i32 25
  %278 = load i8*, i8** %q_message, align 8, !tbaa !53
  %cmp486 = icmp ne i8* %278, null
  br i1 %cmp486, label %if.then.488, label %if.end.492

if.then.488:                                      ; preds = %if.end.485
  %279 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  %280 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_message489 = getelementptr inbounds %struct.address, %struct.address* %280, i32 0, i32 25
  %281 = load i8*, i8** %q_message489, align 8, !tbaa !53
  %call490 = call i8* @denlstring(i8* %281, i32 1, i32 0)
  %call491 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* %279, i32 -2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.31, i32 0, i32 0), i8* %call490)
  br label %if.end.492

if.end.492:                                       ; preds = %if.then.488, %if.end.485
  %282 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %283 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  call void @printctladdr(%struct.address* %282, %struct.sm_file* %283)
  %284 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_orcpt = getelementptr inbounds %struct.address, %struct.address* %284, i32 0, i32 16
  %285 = load i8*, i8** %q_orcpt, align 8, !tbaa !54
  %cmp493 = icmp ne i8* %285, null
  br i1 %cmp493, label %if.then.495, label %if.end.499

if.then.495:                                      ; preds = %if.end.492
  %286 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  %287 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_orcpt496 = getelementptr inbounds %struct.address, %struct.address* %287, i32 0, i32 16
  %288 = load i8*, i8** %q_orcpt496, align 8, !tbaa !54
  %call497 = call i8* @denlstring(i8* %288, i32 1, i32 0)
  %call498 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* %286, i32 -2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.38, i32 0, i32 0), i8* %call497)
  br label %if.end.499

if.end.499:                                       ; preds = %if.then.495, %if.end.492
  %289 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_finalrcpt = getelementptr inbounds %struct.address, %struct.address* %289, i32 0, i32 15
  %290 = load i8*, i8** %q_finalrcpt, align 8, !tbaa !55
  %cmp500 = icmp ne i8* %290, null
  br i1 %cmp500, label %if.then.502, label %if.end.506

if.then.502:                                      ; preds = %if.end.499
  %291 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  %292 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_finalrcpt503 = getelementptr inbounds %struct.address, %struct.address* %292, i32 0, i32 15
  %293 = load i8*, i8** %q_finalrcpt503, align 8, !tbaa !55
  %call504 = call i8* @denlstring(i8* %293, i32 1, i32 0)
  %call505 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* %291, i32 -2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.39, i32 0, i32 0), i8* %call504)
  br label %if.end.506

if.end.506:                                       ; preds = %if.then.502, %if.end.499
  %294 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  %call507 = call i32 @sm_io_putc(%struct.sm_file* %294, i32 -2, i32 82)
  %295 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_flags = getelementptr inbounds %struct.address, %struct.address* %295, i32 0, i32 5
  %296 = load i64, i64* %q_flags, align 8, !tbaa !56
  %and508 = and i64 %296, 2
  %cmp509 = icmp ne i64 %and508, 0
  br i1 %cmp509, label %if.then.511, label %if.end.513

if.then.511:                                      ; preds = %if.end.506
  %297 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  %call512 = call i32 @sm_io_putc(%struct.sm_file* %297, i32 -2, i32 80)
  br label %if.end.513

if.end.513:                                       ; preds = %if.then.511, %if.end.506
  %298 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_flags514 = getelementptr inbounds %struct.address, %struct.address* %298, i32 0, i32 5
  %299 = load i64, i64* %q_flags514, align 8, !tbaa !56
  %and515 = and i64 %299, 512
  %cmp516 = icmp ne i64 %and515, 0
  br i1 %cmp516, label %if.then.518, label %if.end.520

if.then.518:                                      ; preds = %if.end.513
  %300 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  %call519 = call i32 @sm_io_putc(%struct.sm_file* %300, i32 -2, i32 78)
  br label %if.end.520

if.end.520:                                       ; preds = %if.then.518, %if.end.513
  %301 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_flags521 = getelementptr inbounds %struct.address, %struct.address* %301, i32 0, i32 5
  %302 = load i64, i64* %q_flags521, align 8, !tbaa !56
  %and522 = and i64 %302, 64
  %cmp523 = icmp ne i64 %and522, 0
  br i1 %cmp523, label %if.then.525, label %if.end.527

if.then.525:                                      ; preds = %if.end.520
  %303 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  %call526 = call i32 @sm_io_putc(%struct.sm_file* %303, i32 -2, i32 83)
  br label %if.end.527

if.end.527:                                       ; preds = %if.then.525, %if.end.520
  %304 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_flags528 = getelementptr inbounds %struct.address, %struct.address* %304, i32 0, i32 5
  %305 = load i64, i64* %q_flags528, align 8, !tbaa !56
  %and529 = and i64 %305, 128
  %cmp530 = icmp ne i64 %and529, 0
  br i1 %cmp530, label %if.then.532, label %if.end.534

if.then.532:                                      ; preds = %if.end.527
  %306 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  %call533 = call i32 @sm_io_putc(%struct.sm_file* %306, i32 -2, i32 70)
  br label %if.end.534

if.end.534:                                       ; preds = %if.then.532, %if.end.527
  %307 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_flags535 = getelementptr inbounds %struct.address, %struct.address* %307, i32 0, i32 5
  %308 = load i64, i64* %q_flags535, align 8, !tbaa !56
  %and536 = and i64 %308, 256
  %cmp537 = icmp ne i64 %and536, 0
  br i1 %cmp537, label %if.then.539, label %if.end.541

if.then.539:                                      ; preds = %if.end.534
  %309 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  %call540 = call i32 @sm_io_putc(%struct.sm_file* %309, i32 -2, i32 68)
  br label %if.end.541

if.end.541:                                       ; preds = %if.then.539, %if.end.534
  %310 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_flags542 = getelementptr inbounds %struct.address, %struct.address* %310, i32 0, i32 5
  %311 = load i64, i64* %q_flags542, align 8, !tbaa !56
  %and543 = and i64 %311, 262144
  %cmp544 = icmp ne i64 %and543, 0
  br i1 %cmp544, label %if.then.546, label %if.end.548

if.then.546:                                      ; preds = %if.end.541
  %312 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  %call547 = call i32 @sm_io_putc(%struct.sm_file* %312, i32 -2, i32 66)
  br label %if.end.548

if.end.548:                                       ; preds = %if.then.546, %if.end.541
  %313 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_alias = getelementptr inbounds %struct.address, %struct.address* %313, i32 0, i32 11
  %314 = load %struct.address*, %struct.address** %q_alias, align 8, !tbaa !57
  %cmp549 = icmp ne %struct.address* %314, null
  br i1 %cmp549, label %land.lhs.true.551, label %if.end.559

land.lhs.true.551:                                ; preds = %if.end.548
  %315 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_alias552 = getelementptr inbounds %struct.address, %struct.address* %315, i32 0, i32 11
  %316 = load %struct.address*, %struct.address** %q_alias552, align 8, !tbaa !57
  %q_flags553 = getelementptr inbounds %struct.address, %struct.address* %316, i32 0, i32 5
  %317 = load i64, i64* %q_flags553, align 8, !tbaa !56
  %and554 = and i64 %317, 16384
  %cmp555 = icmp ne i64 %and554, 0
  br i1 %cmp555, label %if.then.557, label %if.end.559

if.then.557:                                      ; preds = %land.lhs.true.551
  %318 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  %call558 = call i32 @sm_io_putc(%struct.sm_file* %318, i32 -2, i32 65)
  br label %if.end.559

if.end.559:                                       ; preds = %if.then.557, %land.lhs.true.551, %if.end.548
  %319 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_flags560 = getelementptr inbounds %struct.address, %struct.address* %319, i32 0, i32 5
  %320 = load i64, i64* %q_flags560, align 8, !tbaa !56
  %and561 = and i64 %320, 524288
  %cmp562 = icmp ne i64 %and561, 0
  br i1 %cmp562, label %if.then.564, label %if.end.566

if.then.564:                                      ; preds = %if.end.559
  %321 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  %call565 = call i32 @sm_io_putc(%struct.sm_file* %321, i32 -2, i32 89)
  br label %if.end.566

if.end.566:                                       ; preds = %if.then.564, %if.end.559
  %322 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  %call567 = call i32 @sm_io_putc(%struct.sm_file* %322, i32 -2, i32 58)
  %323 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  %324 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_paddr568 = getelementptr inbounds %struct.address, %struct.address* %324, i32 0, i32 0
  %325 = load i8*, i8** %q_paddr568, align 8, !tbaa !58
  %call569 = call i8* @denlstring(i8* %325, i32 1, i32 0)
  %call570 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* %323, i32 -2, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.40, i32 0, i32 0), i8* %call569)
  %326 = load i32, i32* %announce.addr, align 4, !tbaa !5
  %tobool571 = icmp ne i32 %326, 0
  br i1 %tobool571, label %if.then.572, label %if.end.585

if.then.572:                                      ; preds = %if.end.566
  %327 = bitcast i8** %tag to i8*
  call void @llvm.lifetime.start(i64 8, i8* %327) #1
  store i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.41, i32 0, i32 0), i8** %tag, align 8, !tbaa !1
  %328 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_quarmsg573 = getelementptr inbounds %struct.envelope, %struct.envelope* %328, i32 0, i32 36
  %329 = load i8*, i8** %e_quarmsg573, align 8, !tbaa !43
  %cmp574 = icmp ne i8* %329, null
  br i1 %cmp574, label %if.then.576, label %if.end.577

if.then.576:                                      ; preds = %if.then.572
  store i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.42, i32 0, i32 0), i8** %tag, align 8, !tbaa !1
  br label %if.end.577

if.end.577:                                       ; preds = %if.then.576, %if.then.572
  %330 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_paddr578 = getelementptr inbounds %struct.address, %struct.address* %330, i32 0, i32 0
  %331 = load i8*, i8** %q_paddr578, align 8, !tbaa !58
  %332 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_to = getelementptr inbounds %struct.envelope, %struct.envelope* %332, i32 0, i32 3
  store i8* %331, i8** %e_to, align 8, !tbaa !59
  %333 = load i8*, i8** %tag, align 8, !tbaa !1
  call void (i8*, ...) @message(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.43, i32 0, i32 0), i8* %333)
  %334 = load i32, i32* @LogLevel, align 4, !tbaa !5
  %cmp579 = icmp sgt i32 %334, 8
  br i1 %cmp579, label %if.then.581, label %if.end.583

if.then.581:                                      ; preds = %if.end.577
  %335 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_mailer582 = getelementptr inbounds %struct.address, %struct.address* %335, i32 0, i32 4
  %336 = load %struct.mailer*, %struct.mailer** %q_mailer582, align 8, !tbaa !60
  %337 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_status = getelementptr inbounds %struct.address, %struct.address* %337, i32 0, i32 17
  %338 = load i8*, i8** %q_status, align 8, !tbaa !61
  %339 = load i8*, i8** %tag, align 8, !tbaa !1
  %340 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %341 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  call void @logdelivery(%struct.mailer* %336, %struct.mailer_con_info* null, i8* %338, i8* %339, %struct.address* null, i64 0, %struct.envelope* %340, %struct.address* %341, i32 0)
  br label %if.end.583

if.end.583:                                       ; preds = %if.then.581, %if.end.577
  %342 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_to584 = getelementptr inbounds %struct.envelope, %struct.envelope* %342, i32 0, i32 3
  store i8* null, i8** %e_to584, align 8, !tbaa !59
  %343 = bitcast i8** %tag to i8*
  call void @llvm.lifetime.end(i64 8, i8* %343) #1
  br label %if.end.585

if.end.585:                                       ; preds = %if.end.583, %if.end.566
  %344 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 40), align 1, !tbaa !17
  %conv586 = zext i8 %344 to i32
  %cmp587 = icmp sge i32 %conv586, 1
  br i1 %cmp587, label %land.lhs.true.589, label %if.end.593

land.lhs.true.589:                                ; preds = %if.end.585
  %345 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool590 = icmp ne i32 %345, 0
  br i1 %tobool590, label %if.end.593, label %if.then.591

if.then.591:                                      ; preds = %land.lhs.true.589
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.44, i32 0, i32 0))
  %call592 = call %struct.sm_file* @sm_debug_file()
  %346 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  call void @printaddr(%struct.sm_file* %call592, %struct.address* %346, i32 0)
  br label %if.end.593

if.end.593:                                       ; preds = %if.then.591, %land.lhs.true.589, %if.end.585
  br label %for.inc.594

for.inc.594:                                      ; preds = %if.end.593, %if.then.484
  %347 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_next = getelementptr inbounds %struct.address, %struct.address* %347, i32 0, i32 10
  %348 = load %struct.address*, %struct.address** %q_next, align 8, !tbaa !62
  store %struct.address* %348, %struct.address** %q, align 8, !tbaa !1
  br label %for.cond.462

for.end.595:                                      ; preds = %for.cond.462
  %349 = bitcast %struct.mailer* %nullmailer to i8*
  call void @llvm.memset.p0i8.i64(i8* %349, i8 0, i64 168, i32 1, i1 false)
  %m_sh_rwset = getelementptr inbounds %struct.mailer, %struct.mailer* %nullmailer, i32 0, i32 9
  store i16 -1, i16* %m_sh_rwset, align 2, !tbaa !63
  %m_se_rwset = getelementptr inbounds %struct.mailer, %struct.mailer* %nullmailer, i32 0, i32 10
  store i16 -1, i16* %m_se_rwset, align 2, !tbaa !65
  %m_rh_rwset = getelementptr inbounds %struct.mailer, %struct.mailer* %nullmailer, i32 0, i32 11
  store i16 -1, i16* %m_rh_rwset, align 2, !tbaa !66
  %m_re_rwset = getelementptr inbounds %struct.mailer, %struct.mailer* %nullmailer, i32 0, i32 12
  store i16 -1, i16* %m_re_rwset, align 2, !tbaa !67
  %m_eol = getelementptr inbounds %struct.mailer, %struct.mailer* %nullmailer, i32 0, i32 13
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.45, i32 0, i32 0), i8** %m_eol, align 8, !tbaa !68
  %350 = bitcast %struct.mailer_con_info* %mcibuf to i8*
  call void @llvm.memset.p0i8.i64(i8* %350, i8 0, i64 2256, i32 8, i1 false)
  %mci_mailer596 = getelementptr inbounds %struct.mailer_con_info, %struct.mailer_con_info* %mcibuf, i32 0, i32 11
  store %struct.mailer* %nullmailer, %struct.mailer** %mci_mailer596, align 8, !tbaa !30
  %351 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  %mci_out597 = getelementptr inbounds %struct.mailer_con_info, %struct.mailer_con_info* %mcibuf, i32 0, i32 8
  store %struct.sm_file* %351, %struct.sm_file** %mci_out597, align 8, !tbaa !28
  %352 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_macro = getelementptr inbounds %struct.envelope, %struct.envelope* %352, i32 0, i32 46
  %353 = load i32, i32* @SmHeapGroup, align 4, !tbaa !5
  call void @macdefine_tagged(%struct.MACROS_T* %e_macro, i32 2, i32 103, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.46, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 780, i32 %353)
  %354 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_header = getelementptr inbounds %struct.envelope, %struct.envelope* %354, i32 0, i32 0
  %355 = load %struct.header*, %struct.header** %e_header, align 8, !tbaa !69
  store %struct.header* %355, %struct.header** %h, align 8, !tbaa !1
  br label %for.cond.598

for.cond.598:                                     ; preds = %for.inc.738, %for.end.595
  %356 = load %struct.header*, %struct.header** %h, align 8, !tbaa !1
  %cmp599 = icmp ne %struct.header* %356, null
  br i1 %cmp599, label %for.body.601, label %for.end.739

for.body.601:                                     ; preds = %for.cond.598
  %357 = load %struct.header*, %struct.header** %h, align 8, !tbaa !1
  %h_value = getelementptr inbounds %struct.header, %struct.header* %357, i32 0, i32 1
  %358 = load i8*, i8** %h_value, align 8, !tbaa !70
  %cmp602 = icmp eq i8* %358, null
  br i1 %cmp602, label %if.then.604, label %if.end.605

if.then.604:                                      ; preds = %for.body.601
  br label %for.inc.738

if.end.605:                                       ; preds = %for.body.601
  %359 = load %struct.header*, %struct.header** %h, align 8, !tbaa !1
  %h_flags = getelementptr inbounds %struct.header, %struct.header* %359, i32 0, i32 4
  %360 = load i64, i64* %h_flags, align 8, !tbaa !72
  %and606 = and i64 %360, 8
  %cmp607 = icmp ne i64 %and606, 0
  br i1 %cmp607, label %land.lhs.true.609, label %if.end.615

land.lhs.true.609:                                ; preds = %if.end.605
  %361 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_flags610 = getelementptr inbounds %struct.envelope, %struct.envelope* %361, i32 0, i32 11
  %362 = load i64, i64* %e_flags610, align 8, !tbaa !15
  %and611 = and i64 %362, 256
  %cmp612 = icmp ne i64 %and611, 0
  br i1 %cmp612, label %if.end.615, label %if.then.614

if.then.614:                                      ; preds = %land.lhs.true.609
  br label %for.inc.738

if.end.615:                                       ; preds = %land.lhs.true.609, %if.end.605
  %363 = load %struct.header*, %struct.header** %h, align 8, !tbaa !1
  %h_flags616 = getelementptr inbounds %struct.header, %struct.header* %363, i32 0, i32 4
  %364 = load i64, i64* %h_flags616, align 8, !tbaa !72
  %and617 = and i64 %364, 4
  %cmp618 = icmp ne i64 %and617, 0
  br i1 %cmp618, label %if.then.620, label %if.end.640

if.then.620:                                      ; preds = %if.end.615
  %365 = load %struct.header*, %struct.header** %h, align 8, !tbaa !1
  %h_value621 = getelementptr inbounds %struct.header, %struct.header* %365, i32 0, i32 1
  %366 = load i8*, i8** %h_value621, align 8, !tbaa !70
  %arraydecay622 = getelementptr inbounds [2048 x i8], [2048 x i8]* %buf, i32 0, i32 0
  %367 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  call void @expand(i8* %366, i8* %arraydecay622, i64 2048, %struct.envelope* %367)
  %arrayidx623 = getelementptr inbounds [2048 x i8], [2048 x i8]* %buf, i32 0, i64 0
  %368 = load i8, i8* %arrayidx623, align 1, !tbaa !17
  %conv624 = sext i8 %368 to i32
  %cmp625 = icmp eq i32 %conv624, 0
  br i1 %cmp625, label %if.then.627, label %if.end.628

if.then.627:                                      ; preds = %if.then.620
  br label %for.inc.738

if.end.628:                                       ; preds = %if.then.620
  %arrayidx629 = getelementptr inbounds [2048 x i8], [2048 x i8]* %buf, i32 0, i64 0
  %369 = load i8, i8* %arrayidx629, align 1, !tbaa !17
  %conv630 = sext i8 %369 to i32
  %cmp631 = icmp eq i32 %conv630, 32
  br i1 %cmp631, label %land.lhs.true.633, label %if.end.639

land.lhs.true.633:                                ; preds = %if.end.628
  %arrayidx634 = getelementptr inbounds [2048 x i8], [2048 x i8]* %buf, i32 0, i64 1
  %370 = load i8, i8* %arrayidx634, align 1, !tbaa !17
  %conv635 = sext i8 %370 to i32
  %cmp636 = icmp eq i32 %conv635, 0
  br i1 %cmp636, label %if.then.638, label %if.end.639

if.then.638:                                      ; preds = %land.lhs.true.633
  br label %for.inc.738

if.end.639:                                       ; preds = %land.lhs.true.633, %if.end.628
  br label %if.end.640

if.end.640:                                       ; preds = %if.end.639, %if.end.615
  %371 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  %call641 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* %371, i32 -2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.48, i32 0, i32 0))
  %372 = load %struct.header*, %struct.header** %h, align 8, !tbaa !1
  %h_macro = getelementptr inbounds %struct.header, %struct.header* %372, i32 0, i32 3
  %373 = load i8, i8* %h_macro, align 1, !tbaa !73
  %conv642 = zext i8 %373 to i32
  %cmp643 = icmp ne i32 %conv642, 0
  br i1 %cmp643, label %if.then.645, label %if.else.662

if.then.645:                                      ; preds = %if.end.640
  %374 = load %struct.header*, %struct.header** %h, align 8, !tbaa !1
  %h_macro646 = getelementptr inbounds %struct.header, %struct.header* %374, i32 0, i32 3
  %375 = load i8, i8* %h_macro646, align 1, !tbaa !73
  %conv647 = zext i8 %375 to i32
  %and648 = and i32 %conv647, 128
  %cmp649 = icmp ne i32 %and648, 0
  br i1 %cmp649, label %if.then.651, label %if.else.657

if.then.651:                                      ; preds = %if.then.645
  %376 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  %377 = load %struct.header*, %struct.header** %h, align 8, !tbaa !1
  %h_macro652 = getelementptr inbounds %struct.header, %struct.header* %377, i32 0, i32 3
  %378 = load i8, i8* %h_macro652, align 1, !tbaa !73
  %conv653 = zext i8 %378 to i32
  %and654 = and i32 %conv653, 255
  %call655 = call i8* @macname(i32 %and654)
  %call656 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* %376, i32 -2, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.49, i32 0, i32 0), i8* %call655)
  br label %if.end.661

if.else.657:                                      ; preds = %if.then.645
  %379 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  %380 = load %struct.header*, %struct.header** %h, align 8, !tbaa !1
  %h_macro658 = getelementptr inbounds %struct.header, %struct.header* %380, i32 0, i32 3
  %381 = load i8, i8* %h_macro658, align 1, !tbaa !73
  %conv659 = zext i8 %381 to i32
  %call660 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* %379, i32 -2, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.50, i32 0, i32 0), i32 %conv659)
  br label %if.end.661

if.end.661:                                       ; preds = %if.else.657, %if.then.651
  br label %if.end.693

if.else.662:                                      ; preds = %if.end.640
  %382 = load %struct.header*, %struct.header** %h, align 8, !tbaa !1
  %h_mflags = getelementptr inbounds %struct.header, %struct.header* %382, i32 0, i32 5
  %arraydecay663 = getelementptr inbounds [8 x i32], [8 x i32]* %h_mflags, i32 0, i32 0
  %call664 = call i32 @bitzerop(i32* %arraydecay663)
  %tobool665 = icmp ne i32 %call664, 0
  br i1 %tobool665, label %if.end.692, label %land.lhs.true.666

land.lhs.true.666:                                ; preds = %if.else.662
  %383 = load %struct.header*, %struct.header** %h, align 8, !tbaa !1
  %h_flags667 = getelementptr inbounds %struct.header, %struct.header* %383, i32 0, i32 4
  %384 = load i64, i64* %h_flags667, align 8, !tbaa !72
  %and668 = and i64 %384, 48
  %cmp669 = icmp ne i64 %and668, 0
  br i1 %cmp669, label %if.then.671, label %if.end.692

if.then.671:                                      ; preds = %land.lhs.true.666
  %385 = bitcast i32* %j to i8*
  call void @llvm.lifetime.start(i64 4, i8* %385) #1
  store i32 0, i32* %j, align 4, !tbaa !5
  br label %for.cond.672

for.cond.672:                                     ; preds = %for.inc.689, %if.then.671
  %386 = load i32, i32* %j, align 4, !tbaa !5
  %cmp673 = icmp sle i32 %386, 127
  br i1 %cmp673, label %for.body.675, label %for.end.691

for.body.675:                                     ; preds = %for.cond.672
  %387 = load i32, i32* %j, align 4, !tbaa !5
  %conv676 = trunc i32 %387 to i8
  %conv677 = zext i8 %conv676 to i64
  %div = udiv i64 %conv677, 32
  %and678 = and i64 %div, 7
  %388 = load %struct.header*, %struct.header** %h, align 8, !tbaa !1
  %h_mflags679 = getelementptr inbounds %struct.header, %struct.header* %388, i32 0, i32 5
  %arrayidx680 = getelementptr inbounds [8 x i32], [8 x i32]* %h_mflags679, i32 0, i64 %and678
  %389 = load i32, i32* %arrayidx680, align 4, !tbaa !5
  %390 = load i32, i32* %j, align 4, !tbaa !5
  %conv681 = trunc i32 %390 to i8
  %conv682 = zext i8 %conv681 to i64
  %rem683 = urem i64 %conv682, 32
  %sh_prom = trunc i64 %rem683 to i32
  %shl = shl i32 1, %sh_prom
  %and684 = and i32 %389, %shl
  %tobool685 = icmp ne i32 %and684, 0
  br i1 %tobool685, label %if.then.686, label %if.end.688

if.then.686:                                      ; preds = %for.body.675
  %391 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  %392 = load i32, i32* %j, align 4, !tbaa !5
  %call687 = call i32 @sm_io_putc(%struct.sm_file* %391, i32 -2, i32 %392)
  br label %if.end.688

if.end.688:                                       ; preds = %if.then.686, %for.body.675
  br label %for.inc.689

for.inc.689:                                      ; preds = %if.end.688
  %393 = load i32, i32* %j, align 4, !tbaa !5
  %inc690 = add nsw i32 %393, 1
  store i32 %inc690, i32* %j, align 4, !tbaa !5
  br label %for.cond.672

for.end.691:                                      ; preds = %for.cond.672
  %394 = bitcast i32* %j to i8*
  call void @llvm.lifetime.end(i64 4, i8* %394) #1
  br label %if.end.692

if.end.692:                                       ; preds = %for.end.691, %land.lhs.true.666, %if.else.662
  br label %if.end.693

if.end.693:                                       ; preds = %if.end.692, %if.end.661
  %395 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  %call694 = call i32 @sm_io_putc(%struct.sm_file* %395, i32 -2, i32 63)
  %396 = load %struct.header*, %struct.header** %h, align 8, !tbaa !1
  %h_flags695 = getelementptr inbounds %struct.header, %struct.header* %396, i32 0, i32 4
  %397 = load i64, i64* %h_flags695, align 8, !tbaa !72
  %and696 = and i64 %397, 4
  %cmp697 = icmp ne i64 %and696, 0
  br i1 %cmp697, label %land.lhs.true.699, label %if.else.708

land.lhs.true.699:                                ; preds = %if.end.693
  %398 = load %struct.header*, %struct.header** %h, align 8, !tbaa !1
  %h_flags700 = getelementptr inbounds %struct.header, %struct.header* %398, i32 0, i32 4
  %399 = load i64, i64* %h_flags700, align 8, !tbaa !72
  %and701 = and i64 %399, 131072
  %cmp702 = icmp ne i64 %and701, 0
  br i1 %cmp702, label %if.else.708, label %if.then.704

if.then.704:                                      ; preds = %land.lhs.true.699
  %400 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  %401 = load %struct.header*, %struct.header** %h, align 8, !tbaa !1
  %h_field = getelementptr inbounds %struct.header, %struct.header* %401, i32 0, i32 0
  %402 = load i8*, i8** %h_field, align 8, !tbaa !74
  %arraydecay705 = getelementptr inbounds [2048 x i8], [2048 x i8]* %buf, i32 0, i32 0
  %call706 = call i8* @denlstring(i8* %arraydecay705, i32 0, i32 1)
  %call707 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* %400, i32 -2, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.51, i32 0, i32 0), i8* %402, i8* %call706)
  br label %if.end.737

if.else.708:                                      ; preds = %land.lhs.true.699, %if.end.693
  %403 = load %struct.header*, %struct.header** %h, align 8, !tbaa !1
  %h_flags709 = getelementptr inbounds %struct.header, %struct.header* %403, i32 0, i32 4
  %404 = load i64, i64* %h_flags709, align 8, !tbaa !72
  %and710 = and i64 %404, 258
  %cmp711 = icmp ne i64 %and710, 0
  br i1 %cmp711, label %land.lhs.true.713, label %if.else.731

land.lhs.true.713:                                ; preds = %if.else.708
  %405 = load %struct.header*, %struct.header** %h, align 8, !tbaa !1
  %h_flags714 = getelementptr inbounds %struct.header, %struct.header* %405, i32 0, i32 4
  %406 = load i64, i64* %h_flags714, align 8, !tbaa !72
  %and715 = and i64 %406, 131072
  %cmp716 = icmp ne i64 %and715, 0
  br i1 %cmp716, label %if.else.731, label %if.then.718

if.then.718:                                      ; preds = %land.lhs.true.713
  %407 = bitcast i32* %oldstyle to i8*
  call void @llvm.lifetime.start(i64 4, i8* %407) #1
  %408 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_flags719 = getelementptr inbounds %struct.envelope, %struct.envelope* %408, i32 0, i32 11
  %409 = load i64, i64* %e_flags719, align 8, !tbaa !15
  %and720 = and i64 %409, 1
  %cmp721 = icmp ne i64 %and720, 0
  %conv722 = zext i1 %cmp721 to i32
  store i32 %conv722, i32* %oldstyle, align 4, !tbaa !5
  %410 = bitcast %struct.sm_file** %savetrace to i8*
  call void @llvm.lifetime.start(i64 8, i8* %410) #1
  %411 = load %struct.sm_file*, %struct.sm_file** @TrafficLogFile, align 8, !tbaa !1
  store %struct.sm_file* %411, %struct.sm_file** %savetrace, align 8, !tbaa !1
  store %struct.sm_file* null, %struct.sm_file** @TrafficLogFile, align 8, !tbaa !1
  %412 = load %struct.header*, %struct.header** %h, align 8, !tbaa !1
  %h_flags723 = getelementptr inbounds %struct.header, %struct.header* %412, i32 0, i32 4
  %413 = load i64, i64* %h_flags723, align 8, !tbaa !72
  %and724 = and i64 %413, 256
  %cmp725 = icmp ne i64 %and724, 0
  br i1 %cmp725, label %if.then.727, label %if.end.728

if.then.727:                                      ; preds = %if.then.718
  store i32 0, i32* %oldstyle, align 4, !tbaa !5
  br label %if.end.728

if.end.728:                                       ; preds = %if.then.727, %if.then.718
  %414 = load %struct.header*, %struct.header** %h, align 8, !tbaa !1
  %415 = load %struct.header*, %struct.header** %h, align 8, !tbaa !1
  %h_value729 = getelementptr inbounds %struct.header, %struct.header* %415, i32 0, i32 1
  %416 = load i8*, i8** %h_value729, align 8, !tbaa !70
  %417 = load i32, i32* %oldstyle, align 4, !tbaa !5
  %418 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %call730 = call i32 @commaize(%struct.header* %414, i8* %416, i32 %417, %struct.mailer_con_info* %mcibuf, %struct.envelope* %418, i32 4)
  %419 = load %struct.sm_file*, %struct.sm_file** %savetrace, align 8, !tbaa !1
  store %struct.sm_file* %419, %struct.sm_file** @TrafficLogFile, align 8, !tbaa !1
  %420 = bitcast %struct.sm_file** %savetrace to i8*
  call void @llvm.lifetime.end(i64 8, i8* %420) #1
  %421 = bitcast i32* %oldstyle to i8*
  call void @llvm.lifetime.end(i64 4, i8* %421) #1
  br label %if.end.736

if.else.731:                                      ; preds = %land.lhs.true.713, %if.else.708
  %422 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  %423 = load %struct.header*, %struct.header** %h, align 8, !tbaa !1
  %h_field732 = getelementptr inbounds %struct.header, %struct.header* %423, i32 0, i32 0
  %424 = load i8*, i8** %h_field732, align 8, !tbaa !74
  %425 = load %struct.header*, %struct.header** %h, align 8, !tbaa !1
  %h_value733 = getelementptr inbounds %struct.header, %struct.header* %425, i32 0, i32 1
  %426 = load i8*, i8** %h_value733, align 8, !tbaa !70
  %call734 = call i8* @denlstring(i8* %426, i32 0, i32 1)
  %call735 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* %422, i32 -2, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.51, i32 0, i32 0), i8* %424, i8* %call734)
  br label %if.end.736

if.end.736:                                       ; preds = %if.else.731, %if.end.728
  br label %if.end.737

if.end.737:                                       ; preds = %if.end.736, %if.then.704
  br label %for.inc.738

for.inc.738:                                      ; preds = %if.end.737, %if.then.638, %if.then.627, %if.then.614, %if.then.604
  %427 = load %struct.header*, %struct.header** %h, align 8, !tbaa !1
  %h_link = getelementptr inbounds %struct.header, %struct.header* %427, i32 0, i32 2
  %428 = load %struct.header*, %struct.header** %h_link, align 8, !tbaa !75
  store %struct.header* %428, %struct.header** %h, align 8, !tbaa !1
  br label %for.cond.598

for.end.739:                                      ; preds = %for.cond.598
  %429 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  %call740 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* %429, i32 -2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.52, i32 0, i32 0))
  %430 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  %call741 = call i32 @sm_io_flush(%struct.sm_file* %430, i32 -2)
  %cmp742 = icmp ne i32 %call741, 0
  br i1 %cmp742, label %if.then.764, label %lor.lhs.false.744

lor.lhs.false.744:                                ; preds = %for.end.739
  %431 = load i32, i32* @SuperSafe, align 4, !tbaa !5
  %cmp745 = icmp eq i32 %431, 2
  br i1 %cmp745, label %land.lhs.true.755, label %lor.lhs.false.747

lor.lhs.false.747:                                ; preds = %lor.lhs.false.744
  %432 = load i32, i32* @SuperSafe, align 4, !tbaa !5
  %cmp748 = icmp eq i32 %432, 3
  br i1 %cmp748, label %land.lhs.true.755, label %lor.lhs.false.750

lor.lhs.false.750:                                ; preds = %lor.lhs.false.747
  %433 = load i32, i32* @SuperSafe, align 4, !tbaa !5
  %cmp751 = icmp eq i32 %433, 1
  br i1 %cmp751, label %land.lhs.true.753, label %lor.lhs.false.760

land.lhs.true.753:                                ; preds = %lor.lhs.false.750
  %434 = load i32, i32* %msync.addr, align 4, !tbaa !5
  %tobool754 = icmp ne i32 %434, 0
  br i1 %tobool754, label %land.lhs.true.755, label %lor.lhs.false.760

land.lhs.true.755:                                ; preds = %land.lhs.true.753, %lor.lhs.false.747, %lor.lhs.false.744
  %435 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  %call756 = call i32 @sm_io_getinfo(%struct.sm_file* %435, i32 3, i8* null)
  %call757 = call i32 @fsync(i32 %call756)
  %cmp758 = icmp slt i32 %call757, 0
  br i1 %cmp758, label %if.then.764, label %lor.lhs.false.760

lor.lhs.false.760:                                ; preds = %land.lhs.true.755, %land.lhs.true.753, %lor.lhs.false.750
  %436 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  %f_flags = getelementptr inbounds %struct.sm_file, %struct.sm_file* %436, i32 0, i32 4
  %437 = load i64, i64* %f_flags, align 8, !tbaa !76
  %and761 = and i64 %437, 256
  %cmp762 = icmp ne i64 %and761, 0
  br i1 %cmp762, label %if.then.764, label %if.end.771

if.then.764:                                      ; preds = %lor.lhs.false.760, %land.lhs.true.755, %for.end.739
  %438 = load i32, i32* %newid, align 4, !tbaa !5
  %tobool765 = icmp ne i32 %438, 0
  br i1 %tobool765, label %if.then.766, label %if.else.768

if.then.766:                                      ; preds = %if.then.764
  %arraydecay767 = getelementptr inbounds [4096 x i8], [4096 x i8]* %tf, i32 0, i32 0
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.53, i32 0, i32 0), i8* %arraydecay767)
  br label %if.end.770

if.else.768:                                      ; preds = %if.then.764
  %arraydecay769 = getelementptr inbounds [4096 x i8], [4096 x i8]* %tf, i32 0, i32 0
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.54, i32 0, i32 0), i8* %arraydecay769)
  br label %if.end.770

if.end.770:                                       ; preds = %if.else.768, %if.then.766
  br label %if.end.771

if.end.771:                                       ; preds = %if.end.770, %lor.lhs.false.760
  %439 = load i32, i32* %newid, align 4, !tbaa !5
  %tobool772 = icmp ne i32 %439, 0
  br i1 %tobool772, label %if.else.858, label %if.then.773

if.then.773:                                      ; preds = %if.end.771
  call void @llvm.lifetime.start(i64 1, i8* %new) #1
  %440 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %call774 = call signext i8 @queue_letter(%struct.envelope* %440, i32 63)
  store i8 %call774, i8* %new, align 1, !tbaa !17
  %arraydecay775 = getelementptr inbounds [4096 x i8], [4096 x i8]* %qf, i32 0, i32 0
  %441 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %call776 = call i8* @queuename(%struct.envelope* %441, i32 63)
  %call777 = call i64 @sm_strlcpy(i8* %arraydecay775, i8* %call776, i64 4096)
  %arraydecay778 = getelementptr inbounds [4096 x i8], [4096 x i8]* %tf, i32 0, i32 0
  %arraydecay779 = getelementptr inbounds [4096 x i8], [4096 x i8]* %qf, i32 0, i32 0
  %call780 = call i32 @rename(i8* %arraydecay778, i8* %arraydecay779) #1
  %cmp781 = icmp slt i32 %call780, 0
  br i1 %cmp781, label %if.then.783, label %if.else.788

if.then.783:                                      ; preds = %if.then.773
  %arraydecay784 = getelementptr inbounds [4096 x i8], [4096 x i8]* %tf, i32 0, i32 0
  %arraydecay785 = getelementptr inbounds [4096 x i8], [4096 x i8]* %qf, i32 0, i32 0
  %call786 = call i32 @geteuid() #1
  %conv787 = zext i32 %call786 to i64
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.55, i32 0, i32 0), i8* %arraydecay784, i8* %arraydecay785, i64 %conv787)
  br label %if.end.828

if.else.788:                                      ; preds = %if.then.773
  %442 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qfletter = getelementptr inbounds %struct.envelope, %struct.envelope* %442, i32 0, i32 37
  %443 = load i8, i8* %e_qfletter, align 1, !tbaa !79
  %conv789 = sext i8 %443 to i32
  %cmp790 = icmp ne i32 %conv789, 0
  br i1 %cmp790, label %land.lhs.true.792, label %if.end.827

land.lhs.true.792:                                ; preds = %if.else.788
  %444 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qfletter793 = getelementptr inbounds %struct.envelope, %struct.envelope* %444, i32 0, i32 37
  %445 = load i8, i8* %e_qfletter793, align 1, !tbaa !79
  %conv794 = sext i8 %445 to i32
  %446 = load i8, i8* %new, align 1, !tbaa !17
  %conv795 = sext i8 %446 to i32
  %cmp796 = icmp ne i32 %conv794, %conv795
  br i1 %cmp796, label %if.then.798, label %if.end.827

if.then.798:                                      ; preds = %land.lhs.true.792
  %447 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 40), align 1, !tbaa !17
  %conv799 = zext i8 %447 to i32
  %cmp800 = icmp sge i32 %conv799, 5
  br i1 %cmp800, label %land.lhs.true.802, label %if.end.808

land.lhs.true.802:                                ; preds = %if.then.798
  %448 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool803 = icmp ne i32 %448, 0
  br i1 %tobool803, label %if.end.808, label %if.then.804

if.then.804:                                      ; preds = %land.lhs.true.802
  %449 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qfletter805 = getelementptr inbounds %struct.envelope, %struct.envelope* %449, i32 0, i32 37
  %450 = load i8, i8* %e_qfletter805, align 1, !tbaa !79
  %conv806 = sext i8 %450 to i32
  %451 = load i8, i8* %new, align 1, !tbaa !17
  %conv807 = sext i8 %451 to i32
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.56, i32 0, i32 0), i32 %conv806, i32 %conv807)
  br label %if.end.808

if.end.808:                                       ; preds = %if.then.804, %land.lhs.true.802, %if.then.798
  %452 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %453 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qfletter809 = getelementptr inbounds %struct.envelope, %struct.envelope* %453, i32 0, i32 37
  %454 = load i8, i8* %e_qfletter809, align 1, !tbaa !79
  %conv810 = sext i8 %454 to i32
  %call811 = call i8* @queuename(%struct.envelope* %452, i32 %conv810)
  %call812 = call i32 @unlink(i8* %call811) #1
  %cmp813 = icmp slt i32 %call812, 0
  br i1 %cmp813, label %if.then.815, label %if.end.826

if.then.815:                                      ; preds = %if.end.808
  %455 = load i32, i32* @LogLevel, align 4, !tbaa !5
  %cmp816 = icmp sgt i32 %455, 0
  br i1 %cmp816, label %if.then.818, label %if.end.825

if.then.818:                                      ; preds = %if.then.815
  %456 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id819 = getelementptr inbounds %struct.envelope, %struct.envelope* %456, i32 0, i32 25
  %457 = load i8*, i8** %e_id819, align 8, !tbaa !7
  %458 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %459 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qfletter820 = getelementptr inbounds %struct.envelope, %struct.envelope* %459, i32 0, i32 37
  %460 = load i8, i8* %e_qfletter820, align 1, !tbaa !79
  %conv821 = sext i8 %460 to i32
  %call822 = call i8* @queuename(%struct.envelope* %458, i32 %conv821)
  %call823 = call i32* @__errno_location() #11
  %461 = load i32, i32* %call823, align 4, !tbaa !5
  %call824 = call i8* @sm_errstring(i32 %461)
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 3, i8* %457, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.57, i32 0, i32 0), i8* %call822, i8* %call824)
  br label %if.end.825

if.end.825:                                       ; preds = %if.then.818, %if.then.815
  br label %if.end.826

if.end.826:                                       ; preds = %if.end.825, %if.end.808
  br label %if.end.827

if.end.827:                                       ; preds = %if.end.826, %land.lhs.true.792, %if.else.788
  br label %if.end.828

if.end.828:                                       ; preds = %if.end.827, %if.then.783
  %462 = load i8, i8* %new, align 1, !tbaa !17
  %463 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qfletter829 = getelementptr inbounds %struct.envelope, %struct.envelope* %463, i32 0, i32 37
  store i8 %462, i8* %e_qfletter829, align 1, !tbaa !79
  %464 = load i32, i32* @SuperSafe, align 4, !tbaa !5
  %cmp830 = icmp ne i32 %464, 0
  br i1 %cmp830, label %if.then.832, label %if.end.843

if.then.832:                                      ; preds = %if.end.828
  %465 = load i32, i32* %tfd, align 4, !tbaa !5
  %cmp833 = icmp sge i32 %465, 0
  br i1 %cmp833, label %land.lhs.true.835, label %if.end.841

land.lhs.true.835:                                ; preds = %if.then.832
  %466 = load i32, i32* %tfd, align 4, !tbaa !5
  %call836 = call i32 @fsync(i32 %466)
  %cmp837 = icmp slt i32 %call836, 0
  br i1 %cmp837, label %if.then.839, label %if.end.841

if.then.839:                                      ; preds = %land.lhs.true.835
  %arraydecay840 = getelementptr inbounds [4096 x i8], [4096 x i8]* %tf, i32 0, i32 0
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.58, i32 0, i32 0), i8* %arraydecay840)
  br label %if.end.841

if.end.841:                                       ; preds = %if.then.839, %land.lhs.true.835, %if.then.832
  %arraydecay842 = getelementptr inbounds [4096 x i8], [4096 x i8]* %qf, i32 0, i32 0
  call void @sync_dir(i8* %arraydecay842, i32 1)
  br label %if.end.843

if.end.843:                                       ; preds = %if.end.841, %if.end.828
  %467 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_lockfp844 = getelementptr inbounds %struct.envelope, %struct.envelope* %467, i32 0, i32 33
  %468 = load %struct.sm_file*, %struct.sm_file** %e_lockfp844, align 8, !tbaa !16
  %cmp845 = icmp ne %struct.sm_file* %468, null
  br i1 %cmp845, label %if.then.847, label %if.end.850

if.then.847:                                      ; preds = %if.end.843
  %469 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_lockfp848 = getelementptr inbounds %struct.envelope, %struct.envelope* %469, i32 0, i32 33
  %470 = load %struct.sm_file*, %struct.sm_file** %e_lockfp848, align 8, !tbaa !16
  %call849 = call i32 @sm_io_close(%struct.sm_file* %470, i32 -2)
  br label %if.end.850

if.end.850:                                       ; preds = %if.then.847, %if.end.843
  %471 = load %struct.sm_file*, %struct.sm_file** %tfp, align 8, !tbaa !1
  %472 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_lockfp851 = getelementptr inbounds %struct.envelope, %struct.envelope* %472, i32 0, i32 33
  store %struct.sm_file* %471, %struct.sm_file** %e_lockfp851, align 8, !tbaa !16
  %473 = load i32, i32* @LogLevel, align 4, !tbaa !5
  %cmp852 = icmp sgt i32 %473, 79
  br i1 %cmp852, label %if.then.854, label %if.end.857

if.then.854:                                      ; preds = %if.end.850
  %474 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id855 = getelementptr inbounds %struct.envelope, %struct.envelope* %474, i32 0, i32 25
  %475 = load i8*, i8** %e_id855, align 8, !tbaa !7
  %arraydecay856 = getelementptr inbounds [4096 x i8], [4096 x i8]* %qf, i32 0, i32 0
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 7, i8* %475, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.59, i32 0, i32 0), i8* %arraydecay856)
  br label %if.end.857

if.end.857:                                       ; preds = %if.then.854, %if.end.850
  call void @llvm.lifetime.end(i64 1, i8* %new) #1
  br label %if.end.867

if.else.858:                                      ; preds = %if.end.771
  %476 = load i32, i32* @LogLevel, align 4, !tbaa !5
  %cmp859 = icmp sgt i32 %476, 79
  br i1 %cmp859, label %if.then.861, label %if.end.864

if.then.861:                                      ; preds = %if.else.858
  %477 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id862 = getelementptr inbounds %struct.envelope, %struct.envelope* %477, i32 0, i32 25
  %478 = load i8*, i8** %e_id862, align 8, !tbaa !7
  %arraydecay863 = getelementptr inbounds [4096 x i8], [4096 x i8]* %tf, i32 0, i32 0
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 7, i8* %478, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.59, i32 0, i32 0), i8* %arraydecay863)
  br label %if.end.864

if.end.864:                                       ; preds = %if.then.861, %if.else.858
  %479 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %call865 = call signext i8 @queue_letter(%struct.envelope* %479, i32 63)
  %480 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qfletter866 = getelementptr inbounds %struct.envelope, %struct.envelope* %480, i32 0, i32 37
  store i8 %call865, i8* %e_qfletter866, align 1, !tbaa !79
  br label %if.end.867

if.end.867:                                       ; preds = %if.end.864, %if.end.857
  %call868 = call i32* @__errno_location() #11
  store i32 0, i32* %call868, align 4, !tbaa !5
  %481 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_flags869 = getelementptr inbounds %struct.envelope, %struct.envelope* %481, i32 0, i32 11
  %482 = load i64, i64* %e_flags869, align 8, !tbaa !15
  %or870 = or i64 %482, 2
  store i64 %or870, i64* %e_flags869, align 8, !tbaa !15
  %483 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 40), align 1, !tbaa !17
  %conv871 = zext i8 %483 to i32
  %cmp872 = icmp sge i32 %conv871, 1
  br i1 %cmp872, label %land.lhs.true.874, label %if.end.878

land.lhs.true.874:                                ; preds = %if.end.867
  %484 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool875 = icmp ne i32 %484, 0
  br i1 %tobool875, label %if.end.878, label %if.then.876

if.then.876:                                      ; preds = %land.lhs.true.874
  %485 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id877 = getelementptr inbounds %struct.envelope, %struct.envelope* %485, i32 0, i32 25
  %486 = load i8*, i8** %e_id877, align 8, !tbaa !7
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.60, i32 0, i32 0), i8* %486)
  br label %if.end.878

if.end.878:                                       ; preds = %if.then.876, %land.lhs.true.874, %if.end.867
  %487 = bitcast [2048 x i8]* %buf to i8*
  call void @llvm.lifetime.end(i64 2048, i8* %487) #1
  %488 = bitcast [4096 x i8]* %df to i8*
  call void @llvm.lifetime.end(i64 4096, i8* %488) #1
  %489 = bitcast [4096 x i8]* %tf to i8*
  call void @llvm.lifetime.end(i64 4096, i8* %489) #1
  %490 = bitcast [4096 x i8]* %qf to i8*
  call void @llvm.lifetime.end(i64 4096, i8* %490) #1
  %491 = bitcast %struct.mailer_con_info* %mcibuf to i8*
  call void @llvm.lifetime.end(i64 2256, i8* %491) #1
  %492 = bitcast %struct.mailer* %nullmailer to i8*
  call void @llvm.lifetime.end(i64 168, i8* %492) #1
  %493 = bitcast i8** %p to i8*
  call void @llvm.lifetime.end(i64 8, i8* %493) #1
  %494 = bitcast i32* %newid to i8*
  call void @llvm.lifetime.end(i64 4, i8* %494) #1
  %495 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end(i64 4, i8* %495) #1
  %496 = bitcast i32* %tfd to i8*
  call void @llvm.lifetime.end(i64 4, i8* %496) #1
  %497 = bitcast %struct.address** %q to i8*
  call void @llvm.lifetime.end(i64 8, i8* %497) #1
  %498 = bitcast %struct.header** %h to i8*
  call void @llvm.lifetime.end(i64 8, i8* %498) #1
  %499 = bitcast %struct.sm_file** %tfp to i8*
  call void @llvm.lifetime.end(i64 8, i8* %499) #1
  ret void
}

; Function Attrs: nounwind
declare void @llvm.lifetime.start(i64, i8* nocapture) #1

declare i64 @sm_strlcpy(i8*, i8*, i64) #2

; Function Attrs: nounwind uwtable
define i8* @queuename(%struct.envelope* %e, i32 %type) #0 {
entry:
  %retval = alloca i8*, align 8
  %e.addr = alloca %struct.envelope*, align 8
  %type.addr = alloca i32, align 4
  %qd = alloca i32, align 4
  %qg = alloca i32, align 4
  %sub = alloca i8*, align 8
  %pref = alloca [3 x i8], align 1
  %cleanup.dest.slot = alloca i32
  store %struct.envelope* %e, %struct.envelope** %e.addr, align 8, !tbaa !1
  store i32 %type, i32* %type.addr, align 4, !tbaa !5
  %0 = bitcast i32* %qd to i8*
  call void @llvm.lifetime.start(i64 4, i8* %0) #1
  %1 = bitcast i32* %qg to i8*
  call void @llvm.lifetime.start(i64 4, i8* %1) #1
  %2 = bitcast i8** %sub to i8*
  call void @llvm.lifetime.start(i64 8, i8* %2) #1
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.111, i32 0, i32 0), i8** %sub, align 8, !tbaa !1
  %3 = bitcast [3 x i8]* %pref to i8*
  call void @llvm.lifetime.start(i64 3, i8* %3) #1
  %4 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id = getelementptr inbounds %struct.envelope, %struct.envelope* %4, i32 0, i32 25
  %5 = load i8*, i8** %e_id, align 8, !tbaa !7
  %cmp = icmp eq i8* %5, null
  br i1 %cmp, label %if.then, label %if.end.2

if.then:                                          ; preds = %entry
  %6 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool = icmp ne i32 %6, 0
  br i1 %tobool, label %if.then.1, label %if.end

if.then.1:                                        ; preds = %if.then
  store i8* null, i8** %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end:                                           ; preds = %if.then
  %7 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  call void @assign_queueid(%struct.envelope* %7)
  br label %if.end.2

if.end.2:                                         ; preds = %if.end, %entry
  %8 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %9 = load i32, i32* %type.addr, align 4, !tbaa !5
  %call = call signext i8 @queue_letter(%struct.envelope* %8, i32 %9)
  %conv = sext i8 %call to i32
  store i32 %conv, i32* %type.addr, align 4, !tbaa !5
  %10 = load i32, i32* %type.addr, align 4, !tbaa !5
  %conv3 = trunc i32 %10 to i8
  %arrayidx = getelementptr inbounds [3 x i8], [3 x i8]* %pref, i32 0, i64 0
  store i8 %conv3, i8* %arrayidx, align 1, !tbaa !17
  %arrayidx4 = getelementptr inbounds [3 x i8], [3 x i8]* %pref, i32 0, i64 1
  store i8 102, i8* %arrayidx4, align 1, !tbaa !17
  %arrayidx5 = getelementptr inbounds [3 x i8], [3 x i8]* %pref, i32 0, i64 2
  store i8 0, i8* %arrayidx5, align 1, !tbaa !17
  %11 = load i32, i32* %type.addr, align 4, !tbaa !5
  %cmp6 = icmp eq i32 %11, 120
  br i1 %cmp6, label %if.then.8, label %if.else.44

if.then.8:                                        ; preds = %if.end.2
  %12 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_xfqgrp = getelementptr inbounds %struct.envelope, %struct.envelope* %12, i32 0, i32 30
  %13 = load i32, i32* %e_xfqgrp, align 4, !tbaa !80
  %cmp9 = icmp eq i32 %13, -1
  br i1 %cmp9, label %if.then.13, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then.8
  %14 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_xfqdir = getelementptr inbounds %struct.envelope, %struct.envelope* %14, i32 0, i32 31
  %15 = load i32, i32* %e_xfqdir, align 4, !tbaa !81
  %cmp11 = icmp eq i32 %15, -1
  br i1 %cmp11, label %if.then.13, label %if.end.41

if.then.13:                                       ; preds = %lor.lhs.false, %if.then.8
  %16 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qgrp = getelementptr inbounds %struct.envelope, %struct.envelope* %16, i32 0, i32 26
  %17 = load i32, i32* %e_qgrp, align 4, !tbaa !18
  %cmp14 = icmp ne i32 %17, -1
  br i1 %cmp14, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.then.13
  %18 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qdir = getelementptr inbounds %struct.envelope, %struct.envelope* %18, i32 0, i32 27
  %19 = load i32, i32* %e_qdir, align 4, !tbaa !19
  %cmp16 = icmp ne i32 %19, -1
  br i1 %cmp16, label %if.then.18, label %if.else

if.then.18:                                       ; preds = %land.lhs.true
  %20 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qgrp19 = getelementptr inbounds %struct.envelope, %struct.envelope* %20, i32 0, i32 26
  %21 = load i32, i32* %e_qgrp19, align 4, !tbaa !18
  %22 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_xfqgrp20 = getelementptr inbounds %struct.envelope, %struct.envelope* %22, i32 0, i32 30
  store i32 %21, i32* %e_xfqgrp20, align 4, !tbaa !80
  %23 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qdir21 = getelementptr inbounds %struct.envelope, %struct.envelope* %23, i32 0, i32 27
  %24 = load i32, i32* %e_qdir21, align 4, !tbaa !19
  %25 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_xfqdir22 = getelementptr inbounds %struct.envelope, %struct.envelope* %25, i32 0, i32 31
  store i32 %24, i32* %e_xfqdir22, align 4, !tbaa !81
  br label %if.end.40

if.else:                                          ; preds = %land.lhs.true, %if.then.13
  %26 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_xfqgrp23 = getelementptr inbounds %struct.envelope, %struct.envelope* %26, i32 0, i32 30
  store i32 0, i32* %e_xfqgrp23, align 4, !tbaa !80
  %27 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_xfqgrp24 = getelementptr inbounds %struct.envelope, %struct.envelope* %27, i32 0, i32 30
  %28 = load i32, i32* %e_xfqgrp24, align 4, !tbaa !80
  %idxprom = sext i32 %28 to i64
  %arrayidx25 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom
  %29 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx25, align 8, !tbaa !1
  %qg_numqueues = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %29, i32 0, i32 4
  %30 = load i32, i32* %qg_numqueues, align 4, !tbaa !82
  %cmp26 = icmp sle i32 %30, 1
  br i1 %cmp26, label %if.then.28, label %if.else.30

if.then.28:                                       ; preds = %if.else
  %31 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_xfqdir29 = getelementptr inbounds %struct.envelope, %struct.envelope* %31, i32 0, i32 31
  store i32 0, i32* %e_xfqdir29, align 4, !tbaa !81
  br label %if.end.39

if.else.30:                                       ; preds = %if.else
  %call31 = call i64 @random() #1
  %32 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_xfqgrp32 = getelementptr inbounds %struct.envelope, %struct.envelope* %32, i32 0, i32 30
  %33 = load i32, i32* %e_xfqgrp32, align 4, !tbaa !80
  %idxprom33 = sext i32 %33 to i64
  %arrayidx34 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom33
  %34 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx34, align 8, !tbaa !1
  %qg_numqueues35 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %34, i32 0, i32 4
  %35 = load i32, i32* %qg_numqueues35, align 4, !tbaa !82
  %conv36 = sext i32 %35 to i64
  %rem = srem i64 %call31, %conv36
  %conv37 = trunc i64 %rem to i32
  %36 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_xfqdir38 = getelementptr inbounds %struct.envelope, %struct.envelope* %36, i32 0, i32 31
  store i32 %conv37, i32* %e_xfqdir38, align 4, !tbaa !81
  br label %if.end.39

if.end.39:                                        ; preds = %if.else.30, %if.then.28
  br label %if.end.40

if.end.40:                                        ; preds = %if.end.39, %if.then.18
  br label %if.end.41

if.end.41:                                        ; preds = %if.end.40, %lor.lhs.false
  %37 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_xfqdir42 = getelementptr inbounds %struct.envelope, %struct.envelope* %37, i32 0, i32 31
  %38 = load i32, i32* %e_xfqdir42, align 4, !tbaa !81
  store i32 %38, i32* %qd, align 4, !tbaa !5
  %39 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_xfqgrp43 = getelementptr inbounds %struct.envelope, %struct.envelope* %39, i32 0, i32 30
  %40 = load i32, i32* %e_xfqgrp43, align 4, !tbaa !80
  store i32 %40, i32* %qg, align 4, !tbaa !5
  br label %if.end.65

if.else.44:                                       ; preds = %if.end.2
  %41 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qgrp45 = getelementptr inbounds %struct.envelope, %struct.envelope* %41, i32 0, i32 26
  %42 = load i32, i32* %e_qgrp45, align 4, !tbaa !18
  %cmp46 = icmp eq i32 %42, -1
  br i1 %cmp46, label %if.then.52, label %lor.lhs.false.48

lor.lhs.false.48:                                 ; preds = %if.else.44
  %43 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qdir49 = getelementptr inbounds %struct.envelope, %struct.envelope* %43, i32 0, i32 27
  %44 = load i32, i32* %e_qdir49, align 4, !tbaa !19
  %cmp50 = icmp eq i32 %44, -1
  br i1 %cmp50, label %if.then.52, label %if.end.57

if.then.52:                                       ; preds = %lor.lhs.false.48, %if.else.44
  %45 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool53 = icmp ne i32 %45, 0
  br i1 %tobool53, label %if.then.54, label %if.end.55

if.then.54:                                       ; preds = %if.then.52
  store i8* null, i8** %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.55:                                        ; preds = %if.then.52
  %46 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %call56 = call i32 @setnewqueue(%struct.envelope* %46)
  br label %if.end.57

if.end.57:                                        ; preds = %if.end.55, %lor.lhs.false.48
  %47 = load i32, i32* %type.addr, align 4, !tbaa !5
  %cmp58 = icmp eq i32 %47, 100
  br i1 %cmp58, label %if.then.60, label %if.else.61

if.then.60:                                       ; preds = %if.end.57
  %48 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_dfqdir = getelementptr inbounds %struct.envelope, %struct.envelope* %48, i32 0, i32 29
  %49 = load i32, i32* %e_dfqdir, align 4, !tbaa !37
  store i32 %49, i32* %qd, align 4, !tbaa !5
  %50 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_dfqgrp = getelementptr inbounds %struct.envelope, %struct.envelope* %50, i32 0, i32 28
  %51 = load i32, i32* %e_dfqgrp, align 4, !tbaa !36
  store i32 %51, i32* %qg, align 4, !tbaa !5
  br label %if.end.64

if.else.61:                                       ; preds = %if.end.57
  %52 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qdir62 = getelementptr inbounds %struct.envelope, %struct.envelope* %52, i32 0, i32 27
  %53 = load i32, i32* %e_qdir62, align 4, !tbaa !19
  store i32 %53, i32* %qd, align 4, !tbaa !5
  %54 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qgrp63 = getelementptr inbounds %struct.envelope, %struct.envelope* %54, i32 0, i32 26
  %55 = load i32, i32* %e_qgrp63, align 4, !tbaa !18
  store i32 %55, i32* %qg, align 4, !tbaa !5
  br label %if.end.64

if.end.64:                                        ; preds = %if.else.61, %if.then.60
  br label %if.end.65

if.end.65:                                        ; preds = %if.end.64, %if.end.41
  %56 = load i32, i32* %qd, align 4, !tbaa !5
  %cmp66 = icmp eq i32 %56, -1
  br i1 %cmp66, label %land.lhs.true.71, label %lor.lhs.false.68

lor.lhs.false.68:                                 ; preds = %if.end.65
  %57 = load i32, i32* %qg, align 4, !tbaa !5
  %cmp69 = icmp eq i32 %57, -1
  br i1 %cmp69, label %land.lhs.true.71, label %if.else.77

land.lhs.true.71:                                 ; preds = %lor.lhs.false.68, %if.end.65
  %58 = load i32, i32* %type.addr, align 4, !tbaa !5
  %cmp72 = icmp ne i32 %58, 120
  br i1 %cmp72, label %if.then.74, label %if.else.77

if.then.74:                                       ; preds = %land.lhs.true.71
  %arraydecay = getelementptr inbounds [3 x i8], [3 x i8]* %pref, i32 0, i32 0
  %59 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id75 = getelementptr inbounds %struct.envelope, %struct.envelope* %59, i32 0, i32 25
  %60 = load i8*, i8** %e_id75, align 8, !tbaa !7
  %call76 = call i64 (i8*, i64, i32, ...) @sm_strlcpyn(i8* getelementptr inbounds ([4096 x i8], [4096 x i8]* @queuename.buf, i32 0, i32 0), i64 4096, i32 2, i8* %arraydecay, i8* %60)
  br label %if.end.124

if.else.77:                                       ; preds = %land.lhs.true.71, %lor.lhs.false.68
  %61 = load i32, i32* %type.addr, align 4, !tbaa !5
  switch i32 %61, label %sw.default [
    i32 100, label %sw.bb
    i32 104, label %sw.bb.87
    i32 84, label %sw.bb.87
    i32 116, label %sw.bb.87
    i32 81, label %sw.bb.87
    i32 113, label %sw.bb.87
    i32 120, label %sw.bb.100
  ]

sw.bb:                                            ; preds = %if.else.77
  %62 = load i32, i32* %qd, align 4, !tbaa !5
  %idxprom78 = sext i32 %62 to i64
  %63 = load i32, i32* %qg, align 4, !tbaa !5
  %idxprom79 = sext i32 %63 to i64
  %arrayidx80 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom79
  %64 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx80, align 8, !tbaa !1
  %qg_qpaths = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %64, i32 0, i32 6
  %65 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths, align 8, !tbaa !38
  %arrayidx81 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %65, i64 %idxprom78
  %qp_subdirs = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %arrayidx81, i32 0, i32 1
  %66 = load i16, i16* %qp_subdirs, align 2, !tbaa !83
  %conv82 = sext i16 %66 to i32
  %and = and i32 %conv82, 1
  %cmp83 = icmp ne i32 %and, 0
  br i1 %cmp83, label %if.then.85, label %if.end.86

if.then.85:                                       ; preds = %sw.bb
  store i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.130, i32 0, i32 0), i8** %sub, align 8, !tbaa !1
  br label %if.end.86

if.end.86:                                        ; preds = %if.then.85, %sw.bb
  br label %sw.epilog

sw.bb.87:                                         ; preds = %if.else.77, %if.else.77, %if.else.77, %if.else.77, %if.else.77
  %67 = load i32, i32* %qd, align 4, !tbaa !5
  %idxprom88 = sext i32 %67 to i64
  %68 = load i32, i32* %qg, align 4, !tbaa !5
  %idxprom89 = sext i32 %68 to i64
  %arrayidx90 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom89
  %69 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx90, align 8, !tbaa !1
  %qg_qpaths91 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %69, i32 0, i32 6
  %70 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths91, align 8, !tbaa !38
  %arrayidx92 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %70, i64 %idxprom88
  %qp_subdirs93 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %arrayidx92, i32 0, i32 1
  %71 = load i16, i16* %qp_subdirs93, align 2, !tbaa !83
  %conv94 = sext i16 %71 to i32
  %and95 = and i32 %conv94, 2
  %cmp96 = icmp ne i32 %and95, 0
  br i1 %cmp96, label %if.then.98, label %if.end.99

if.then.98:                                       ; preds = %sw.bb.87
  store i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.131, i32 0, i32 0), i8** %sub, align 8, !tbaa !1
  br label %if.end.99

if.end.99:                                        ; preds = %if.then.98, %sw.bb.87
  br label %sw.epilog

sw.bb.100:                                        ; preds = %if.else.77
  %72 = load i32, i32* %qd, align 4, !tbaa !5
  %idxprom101 = sext i32 %72 to i64
  %73 = load i32, i32* %qg, align 4, !tbaa !5
  %idxprom102 = sext i32 %73 to i64
  %arrayidx103 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom102
  %74 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx103, align 8, !tbaa !1
  %qg_qpaths104 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %74, i32 0, i32 6
  %75 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths104, align 8, !tbaa !38
  %arrayidx105 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %75, i64 %idxprom101
  %qp_subdirs106 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %arrayidx105, i32 0, i32 1
  %76 = load i16, i16* %qp_subdirs106, align 2, !tbaa !83
  %conv107 = sext i16 %76 to i32
  %and108 = and i32 %conv107, 4
  %cmp109 = icmp ne i32 %and108, 0
  br i1 %cmp109, label %if.then.111, label %if.end.112

if.then.111:                                      ; preds = %sw.bb.100
  store i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.132, i32 0, i32 0), i8** %sub, align 8, !tbaa !1
  br label %if.end.112

if.end.112:                                       ; preds = %if.then.111, %sw.bb.100
  br label %sw.epilog

sw.default:                                       ; preds = %if.else.77
  %77 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool113 = icmp ne i32 %77, 0
  br i1 %tobool113, label %if.then.114, label %if.end.115

if.then.114:                                      ; preds = %sw.default
  store i8* null, i8** %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.115:                                       ; preds = %sw.default
  %78 = load i32, i32* %type.addr, align 4, !tbaa !5
  call void (i8*, ...) @sm_abort(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.133, i32 0, i32 0), i32 %78) #12
  unreachable

sw.epilog:                                        ; preds = %if.end.112, %if.end.99, %if.end.86
  %79 = load i32, i32* %qd, align 4, !tbaa !5
  %idxprom116 = sext i32 %79 to i64
  %80 = load i32, i32* %qg, align 4, !tbaa !5
  %idxprom117 = sext i32 %80 to i64
  %arrayidx118 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom117
  %81 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx118, align 8, !tbaa !1
  %qg_qpaths119 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %81, i32 0, i32 6
  %82 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths119, align 8, !tbaa !38
  %arrayidx120 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %82, i64 %idxprom116
  %qp_name = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %arrayidx120, i32 0, i32 0
  %83 = load i8*, i8** %qp_name, align 8, !tbaa !40
  %84 = load i8*, i8** %sub, align 8, !tbaa !1
  %arraydecay121 = getelementptr inbounds [3 x i8], [3 x i8]* %pref, i32 0, i32 0
  %85 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id122 = getelementptr inbounds %struct.envelope, %struct.envelope* %85, i32 0, i32 25
  %86 = load i8*, i8** %e_id122, align 8, !tbaa !7
  %call123 = call i64 (i8*, i64, i32, ...) @sm_strlcpyn(i8* getelementptr inbounds ([4096 x i8], [4096 x i8]* @queuename.buf, i32 0, i32 0), i64 4096, i32 4, i8* %83, i8* %84, i8* %arraydecay121, i8* %86)
  br label %if.end.124

if.end.124:                                       ; preds = %sw.epilog, %if.then.74
  %87 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 7), align 1, !tbaa !17
  %conv125 = zext i8 %87 to i32
  %cmp126 = icmp sge i32 %conv125, 2
  br i1 %cmp126, label %land.lhs.true.128, label %if.end.131

land.lhs.true.128:                                ; preds = %if.end.124
  %88 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool129 = icmp ne i32 %88, 0
  br i1 %tobool129, label %if.end.131, label %if.then.130

if.then.130:                                      ; preds = %land.lhs.true.128
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.134, i32 0, i32 0), i8* getelementptr inbounds ([4096 x i8], [4096 x i8]* @queuename.buf, i32 0, i32 0))
  br label %if.end.131

if.end.131:                                       ; preds = %if.then.130, %land.lhs.true.128, %if.end.124
  store i8* getelementptr inbounds ([4096 x i8], [4096 x i8]* @queuename.buf, i32 0, i32 0), i8** %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

cleanup:                                          ; preds = %if.end.131, %if.then.114, %if.then.54, %if.then.1
  %89 = bitcast [3 x i8]* %pref to i8*
  call void @llvm.lifetime.end(i64 3, i8* %89) #1
  %90 = bitcast i8** %sub to i8*
  call void @llvm.lifetime.end(i64 8, i8* %90) #1
  %91 = bitcast i32* %qg to i8*
  call void @llvm.lifetime.end(i64 4, i8* %91) #1
  %92 = bitcast i32* %qd to i8*
  call void @llvm.lifetime.end(i64 4, i8* %92) #1
  %93 = load i8*, i8** %retval
  ret i8* %93
}

; Function Attrs: nounwind
declare i32 @umask(i32) #3

declare i32 @open(i8*, i32, ...) #2

; Function Attrs: nounwind
declare void @llvm.lifetime.end(i64, i8* nocapture) #1

declare i32 @lockfile(i32, i8*, i8*, i32) #2

declare %struct.sm_file* @sm_io_open(%struct.sm_file*, i32, i8*, i32, i8*) #2

; Function Attrs: nounwind readnone
declare i32* @__errno_location() #4

declare void @printopenfds(i32) #2

declare void @syserr(i8*, ...) #2

; Function Attrs: nounwind
declare i32 @geteuid() #3

; Function Attrs: nounwind uwtable
define void @upd_qs(%struct.envelope* %e, i32 %count, i32 %space, i8* %where) #0 {
entry:
  %e.addr = alloca %struct.envelope*, align 8
  %count.addr = alloca i32, align 4
  %space.addr = alloca i32, align 4
  %where.addr = alloca i8*, align 8
  %fidx = alloca i16, align 2
  %idx = alloca i32, align 4
  %s = alloca i64, align 8
  %cleanup.dest.slot = alloca i32
  store %struct.envelope* %e, %struct.envelope** %e.addr, align 8, !tbaa !1
  store i32 %count, i32* %count.addr, align 4, !tbaa !5
  store i32 %space, i32* %space.addr, align 4, !tbaa !5
  store i8* %where, i8** %where.addr, align 8, !tbaa !1
  %0 = bitcast i16* %fidx to i8*
  call void @llvm.lifetime.start(i64 2, i8* %0) #1
  %1 = bitcast i32* %idx to i8*
  call void @llvm.lifetime.start(i64 4, i8* %1) #1
  %2 = bitcast i64* %s to i8*
  call void @llvm.lifetime.start(i64 8, i8* %2) #1
  %3 = load i32, i32* @ShmId, align 4, !tbaa !5
  %cmp = icmp eq i32 %3, -2
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %4 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %cmp1 = icmp eq %struct.envelope* %4, null
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end:                                           ; preds = %lor.lhs.false
  %5 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qgrp = getelementptr inbounds %struct.envelope, %struct.envelope* %5, i32 0, i32 26
  %6 = load i32, i32* %e_qgrp, align 4, !tbaa !18
  %cmp2 = icmp eq i32 %6, -1
  br i1 %cmp2, label %if.then.5, label %lor.lhs.false.3

lor.lhs.false.3:                                  ; preds = %if.end
  %7 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qdir = getelementptr inbounds %struct.envelope, %struct.envelope* %7, i32 0, i32 27
  %8 = load i32, i32* %e_qdir, align 4, !tbaa !19
  %cmp4 = icmp eq i32 %8, -1
  br i1 %cmp4, label %if.then.5, label %if.end.6

if.then.5:                                        ; preds = %lor.lhs.false.3, %if.end
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.6:                                         ; preds = %lor.lhs.false.3
  %9 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qdir7 = getelementptr inbounds %struct.envelope, %struct.envelope* %9, i32 0, i32 27
  %10 = load i32, i32* %e_qdir7, align 4, !tbaa !19
  %idxprom = sext i32 %10 to i64
  %11 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qgrp8 = getelementptr inbounds %struct.envelope, %struct.envelope* %11, i32 0, i32 26
  %12 = load i32, i32* %e_qgrp8, align 4, !tbaa !18
  %idxprom9 = sext i32 %12 to i64
  %arrayidx = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom9
  %13 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx, align 8, !tbaa !1
  %qg_qpaths = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %13, i32 0, i32 6
  %14 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths, align 8, !tbaa !38
  %arrayidx10 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %14, i64 %idxprom
  %qp_idx = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %arrayidx10, i32 0, i32 3
  %15 = load i32, i32* %qp_idx, align 4, !tbaa !84
  store i32 %15, i32* %idx, align 4, !tbaa !5
  %16 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 73), align 1, !tbaa !17
  %conv = zext i8 %16 to i32
  %cmp11 = icmp sge i32 %conv, 2
  br i1 %cmp11, label %land.lhs.true, label %if.end.16

land.lhs.true:                                    ; preds = %if.end.6
  %17 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool = icmp ne i32 %17, 0
  br i1 %tobool, label %if.end.16, label %if.then.13

if.then.13:                                       ; preds = %land.lhs.true
  %18 = load i32, i32* %count.addr, align 4, !tbaa !5
  %19 = load i32, i32* %space.addr, align 4, !tbaa !5
  %20 = load i8*, i8** %where.addr, align 8, !tbaa !1
  %21 = load i32, i32* %idx, align 4, !tbaa !5
  %22 = load i32, i32* %idx, align 4, !tbaa !5
  %idxprom14 = sext i32 %22 to i64
  %23 = load %struct.queue_shared*, %struct.queue_shared** @QShm, align 8, !tbaa !1
  %arrayidx15 = getelementptr inbounds %struct.queue_shared, %struct.queue_shared* %23, i64 %idxprom14
  %qs_entries = getelementptr inbounds %struct.queue_shared, %struct.queue_shared* %arrayidx15, i32 0, i32 0
  %24 = load i32, i32* %qs_entries, align 4, !tbaa !85
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str.152, i32 0, i32 0), i32 %18, i32 %19, i8* %20, i32 %21, i32 %24)
  br label %if.end.16

if.end.16:                                        ; preds = %if.then.13, %land.lhs.true, %if.end.6
  %25 = load i32, i32* %idx, align 4, !tbaa !5
  %idxprom17 = sext i32 %25 to i64
  %26 = load %struct.queue_shared*, %struct.queue_shared** @QShm, align 8, !tbaa !1
  %arrayidx18 = getelementptr inbounds %struct.queue_shared, %struct.queue_shared* %26, i64 %idxprom17
  %qs_entries19 = getelementptr inbounds %struct.queue_shared, %struct.queue_shared* %arrayidx18, i32 0, i32 0
  %27 = load i32, i32* %qs_entries19, align 4, !tbaa !85
  %cmp20 = icmp sge i32 %27, 0
  br i1 %cmp20, label %land.lhs.true.22, label %if.end.29

land.lhs.true.22:                                 ; preds = %if.end.16
  %28 = load i32, i32* %count.addr, align 4, !tbaa !5
  %cmp23 = icmp ne i32 %28, 0
  br i1 %cmp23, label %if.then.25, label %if.end.29

if.then.25:                                       ; preds = %land.lhs.true.22
  %29 = load i32, i32* %count.addr, align 4, !tbaa !5
  %30 = load i32, i32* %idx, align 4, !tbaa !5
  %idxprom26 = sext i32 %30 to i64
  %31 = load %struct.queue_shared*, %struct.queue_shared** @QShm, align 8, !tbaa !1
  %arrayidx27 = getelementptr inbounds %struct.queue_shared, %struct.queue_shared* %31, i64 %idxprom26
  %qs_entries28 = getelementptr inbounds %struct.queue_shared, %struct.queue_shared* %arrayidx27, i32 0, i32 0
  %32 = load i32, i32* %qs_entries28, align 4, !tbaa !85
  %add = add nsw i32 %32, %29
  store i32 %add, i32* %qs_entries28, align 4, !tbaa !85
  br label %if.end.29

if.end.29:                                        ; preds = %if.then.25, %land.lhs.true.22, %if.end.16
  %33 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qdir30 = getelementptr inbounds %struct.envelope, %struct.envelope* %33, i32 0, i32 27
  %34 = load i32, i32* %e_qdir30, align 4, !tbaa !19
  %idxprom31 = sext i32 %34 to i64
  %35 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qgrp32 = getelementptr inbounds %struct.envelope, %struct.envelope* %35, i32 0, i32 26
  %36 = load i32, i32* %e_qgrp32, align 4, !tbaa !18
  %idxprom33 = sext i32 %36 to i64
  %arrayidx34 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom33
  %37 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx34, align 8, !tbaa !1
  %qg_qpaths35 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %37, i32 0, i32 6
  %38 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths35, align 8, !tbaa !38
  %arrayidx36 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %38, i64 %idxprom31
  %qp_fsysidx = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %arrayidx36, i32 0, i32 2
  %39 = load i16, i16* %qp_fsysidx, align 2, !tbaa !87
  store i16 %39, i16* %fidx, align 2, !tbaa !88
  %40 = load i16, i16* %fidx, align 2, !tbaa !88
  %conv37 = sext i16 %40 to i32
  %cmp38 = icmp slt i32 %conv37, 0
  br i1 %cmp38, label %if.then.40, label %if.end.41

if.then.40:                                       ; preds = %if.end.29
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.41:                                        ; preds = %if.end.29
  %41 = load i32, i32* %space.addr, align 4, !tbaa !5
  %cmp42 = icmp eq i32 %41, 0
  br i1 %cmp42, label %if.then.44, label %if.end.45

if.then.44:                                       ; preds = %if.end.41
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.45:                                        ; preds = %if.end.41
  %42 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_msgsize = getelementptr inbounds %struct.envelope, %struct.envelope* %42, i32 0, i32 9
  %43 = load i64, i64* %e_msgsize, align 8, !tbaa !89
  %44 = load i16, i16* %fidx, align 2, !tbaa !88
  %idxprom46 = sext i16 %44 to i64
  %45 = load %struct.filesys_shared*, %struct.filesys_shared** @PtrFileSys, align 8, !tbaa !1
  %arrayidx47 = getelementptr inbounds %struct.filesys_shared, %struct.filesys_shared* %45, i64 %idxprom46
  %fs_blksize = getelementptr inbounds %struct.filesys_shared, %struct.filesys_shared* %arrayidx47, i32 0, i32 2
  %46 = load i64, i64* %fs_blksize, align 8, !tbaa !90
  %div = sdiv i64 %43, %46
  store i64 %div, i64* %s, align 8, !tbaa !92
  %47 = load i64, i64* %s, align 8, !tbaa !92
  %cmp48 = icmp eq i64 %47, 0
  br i1 %cmp48, label %if.then.50, label %if.end.51

if.then.50:                                       ; preds = %if.end.45
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.51:                                        ; preds = %if.end.45
  %48 = load i32, i32* %space.addr, align 4, !tbaa !5
  %cmp52 = icmp sgt i32 %48, 0
  br i1 %cmp52, label %if.then.54, label %if.else

if.then.54:                                       ; preds = %if.end.51
  %49 = load i64, i64* %s, align 8, !tbaa !92
  %50 = load i16, i16* %fidx, align 2, !tbaa !88
  %idxprom55 = sext i16 %50 to i64
  %51 = load %struct.filesys_shared*, %struct.filesys_shared** @PtrFileSys, align 8, !tbaa !1
  %arrayidx56 = getelementptr inbounds %struct.filesys_shared, %struct.filesys_shared* %51, i64 %idxprom55
  %fs_avail = getelementptr inbounds %struct.filesys_shared, %struct.filesys_shared* %arrayidx56, i32 0, i32 1
  %52 = load i64, i64* %fs_avail, align 8, !tbaa !93
  %add57 = add nsw i64 %52, %49
  store i64 %add57, i64* %fs_avail, align 8, !tbaa !93
  br label %if.end.61

if.else:                                          ; preds = %if.end.51
  %53 = load i64, i64* %s, align 8, !tbaa !92
  %54 = load i16, i16* %fidx, align 2, !tbaa !88
  %idxprom58 = sext i16 %54 to i64
  %55 = load %struct.filesys_shared*, %struct.filesys_shared** @PtrFileSys, align 8, !tbaa !1
  %arrayidx59 = getelementptr inbounds %struct.filesys_shared, %struct.filesys_shared* %55, i64 %idxprom58
  %fs_avail60 = getelementptr inbounds %struct.filesys_shared, %struct.filesys_shared* %arrayidx59, i32 0, i32 1
  %56 = load i64, i64* %fs_avail60, align 8, !tbaa !93
  %sub = sub nsw i64 %56, %53
  store i64 %sub, i64* %fs_avail60, align 8, !tbaa !93
  br label %if.end.61

if.end.61:                                        ; preds = %if.else, %if.then.54
  store i32 0, i32* %cleanup.dest.slot
  br label %cleanup

cleanup:                                          ; preds = %if.end.61, %if.then.50, %if.then.44, %if.then.40, %if.then.5, %if.then
  %57 = bitcast i64* %s to i8*
  call void @llvm.lifetime.end(i64 8, i8* %57) #1
  %58 = bitcast i32* %idx to i8*
  call void @llvm.lifetime.end(i64 4, i8* %58) #1
  %59 = bitcast i16* %fidx to i8*
  call void @llvm.lifetime.end(i64 2, i8* %59) #1
  %cleanup.dest = load i32, i32* %cleanup.dest.slot
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %cleanup.cont
    i32 1, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup, %cleanup
  ret void

unreachable:                                      ; preds = %cleanup
  unreachable
}

declare void @sm_syslog(i32, i8*, i8*, ...) #2

declare i8* @sm_errstring(i32) #2

declare i32 @close(i32) #2

; Function Attrs: nounwind
declare i32 @rename(i8*, i8*) #3

declare i32 @sleep(i32) #2

declare void @sm_dprintf(i8*, ...) #2

; Function Attrs: nounwind uwtable
define i8* @qid_printqueue(i32 %qgrp, i32 %qdir) #0 {
entry:
  %retval = alloca i8*, align 8
  %qgrp.addr = alloca i32, align 4
  %qdir.addr = alloca i32, align 4
  %subdir = alloca i8*, align 8
  %cleanup.dest.slot = alloca i32
  %__s1_len = alloca i64, align 8
  %__s2_len = alloca i64, align 8
  %tmp = alloca i32, align 4
  %__s1 = alloca i8*, align 8
  %__result = alloca i32, align 4
  %tmp43 = alloca i32, align 4
  store i32 %qgrp, i32* %qgrp.addr, align 4, !tbaa !5
  store i32 %qdir, i32* %qdir.addr, align 4, !tbaa !5
  %0 = bitcast i8** %subdir to i8*
  call void @llvm.lifetime.start(i64 8, i8* %0) #1
  %1 = load i32, i32* %qdir.addr, align 4, !tbaa !5
  %cmp = icmp eq i32 %1, -1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32, i32* %qgrp.addr, align 4, !tbaa !5
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom
  %3 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx, align 8, !tbaa !1
  %qg_qdir = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %3, i32 0, i32 1
  %4 = load i8*, i8** %qg_qdir, align 8, !tbaa !94
  store i8* %4, i8** %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end:                                           ; preds = %entry
  %5 = bitcast i64* %__s1_len to i8*
  call void @llvm.lifetime.start(i64 8, i8* %5) #1
  %6 = bitcast i64* %__s2_len to i8*
  call void @llvm.lifetime.start(i64 8, i8* %6) #1
  br i1 icmp eq (i64 sub (i64 ptrtoint (i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.100, i32 0, i64 1) to i64), i64 ptrtoint ([2 x i8]* @.str.100 to i64)), i64 1), label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %if.end
  store i64 1, i64* %__s2_len, align 8, !tbaa !92
  %7 = load i64, i64* %__s2_len, align 8, !tbaa !92
  %cmp1 = icmp ult i64 %7, 4
  br i1 %cmp1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true
  %8 = bitcast i8** %__s1 to i8*
  call void @llvm.lifetime.start(i64 8, i8* %8) #1
  %9 = load i32, i32* %qdir.addr, align 4, !tbaa !5
  %idxprom3 = sext i32 %9 to i64
  %10 = load i32, i32* %qgrp.addr, align 4, !tbaa !5
  %idxprom4 = sext i32 %10 to i64
  %arrayidx5 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom4
  %11 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx5, align 8, !tbaa !1
  %qg_qpaths = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %11, i32 0, i32 6
  %12 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths, align 8, !tbaa !38
  %arrayidx6 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %12, i64 %idxprom3
  %qp_name = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %arrayidx6, i32 0, i32 0
  %13 = load i8*, i8** %qp_name, align 8, !tbaa !40
  store i8* %13, i8** %__s1, align 8, !tbaa !1
  %14 = bitcast i32* %__result to i8*
  call void @llvm.lifetime.start(i64 4, i8* %14) #1
  %15 = load i8*, i8** %__s1, align 8, !tbaa !1
  %arrayidx8 = getelementptr inbounds i8, i8* %15, i64 0
  %16 = load i8, i8* %arrayidx8, align 1, !tbaa !17
  %conv = zext i8 %16 to i32
  %17 = load i8, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.100, i32 0, i32 0), align 1, !tbaa !17
  %conv9 = zext i8 %17 to i32
  %sub = sub nsw i32 %conv, %conv9
  store i32 %sub, i32* %__result, align 4, !tbaa !5
  %18 = load i64, i64* %__s2_len, align 8, !tbaa !92
  %cmp10 = icmp ugt i64 %18, 0
  br i1 %cmp10, label %land.lhs.true.12, label %if.end.42

land.lhs.true.12:                                 ; preds = %cond.true
  %19 = load i32, i32* %__result, align 4, !tbaa !5
  %cmp13 = icmp eq i32 %19, 0
  br i1 %cmp13, label %if.then.15, label %if.end.42

if.then.15:                                       ; preds = %land.lhs.true.12
  %20 = load i8*, i8** %__s1, align 8, !tbaa !1
  %arrayidx16 = getelementptr inbounds i8, i8* %20, i64 1
  %21 = load i8, i8* %arrayidx16, align 1, !tbaa !17
  %conv17 = zext i8 %21 to i32
  %22 = load i8, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.100, i32 0, i64 1), align 1, !tbaa !17
  %conv18 = zext i8 %22 to i32
  %sub19 = sub nsw i32 %conv17, %conv18
  store i32 %sub19, i32* %__result, align 4, !tbaa !5
  %23 = load i64, i64* %__s2_len, align 8, !tbaa !92
  %cmp20 = icmp ugt i64 %23, 1
  br i1 %cmp20, label %land.lhs.true.22, label %if.end.41

land.lhs.true.22:                                 ; preds = %if.then.15
  %24 = load i32, i32* %__result, align 4, !tbaa !5
  %cmp23 = icmp eq i32 %24, 0
  br i1 %cmp23, label %if.then.25, label %if.end.41

if.then.25:                                       ; preds = %land.lhs.true.22
  %25 = load i8*, i8** %__s1, align 8, !tbaa !1
  %arrayidx26 = getelementptr inbounds i8, i8* %25, i64 2
  %26 = load i8, i8* %arrayidx26, align 1, !tbaa !17
  %conv27 = zext i8 %26 to i32
  %27 = load i8, i8* getelementptr inbounds (i8, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.100, i32 0, i32 0), i64 2), align 1, !tbaa !17
  %conv28 = zext i8 %27 to i32
  %sub29 = sub nsw i32 %conv27, %conv28
  store i32 %sub29, i32* %__result, align 4, !tbaa !5
  %28 = load i64, i64* %__s2_len, align 8, !tbaa !92
  %cmp30 = icmp ugt i64 %28, 2
  br i1 %cmp30, label %land.lhs.true.32, label %if.end.40

land.lhs.true.32:                                 ; preds = %if.then.25
  %29 = load i32, i32* %__result, align 4, !tbaa !5
  %cmp33 = icmp eq i32 %29, 0
  br i1 %cmp33, label %if.then.35, label %if.end.40

if.then.35:                                       ; preds = %land.lhs.true.32
  %30 = load i8*, i8** %__s1, align 8, !tbaa !1
  %arrayidx36 = getelementptr inbounds i8, i8* %30, i64 3
  %31 = load i8, i8* %arrayidx36, align 1, !tbaa !17
  %conv37 = zext i8 %31 to i32
  %32 = load i8, i8* getelementptr inbounds (i8, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.100, i32 0, i32 0), i64 3), align 1, !tbaa !17
  %conv38 = zext i8 %32 to i32
  %sub39 = sub nsw i32 %conv37, %conv38
  store i32 %sub39, i32* %__result, align 4, !tbaa !5
  br label %if.end.40

if.end.40:                                        ; preds = %if.then.35, %land.lhs.true.32, %if.then.25
  br label %if.end.41

if.end.41:                                        ; preds = %if.end.40, %land.lhs.true.22, %if.then.15
  br label %if.end.42

if.end.42:                                        ; preds = %if.end.41, %land.lhs.true.12, %cond.true
  %33 = load i32, i32* %__result, align 4, !tbaa !5
  store i32 %33, i32* %tmp43, !tbaa !5
  %34 = bitcast i32* %__result to i8*
  call void @llvm.lifetime.end(i64 4, i8* %34) #1
  %35 = bitcast i8** %__s1 to i8*
  call void @llvm.lifetime.end(i64 8, i8* %35) #1
  %36 = load i32, i32* %tmp43, !tbaa !5
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %if.end
  %37 = load i32, i32* %qdir.addr, align 4, !tbaa !5
  %idxprom44 = sext i32 %37 to i64
  %38 = load i32, i32* %qgrp.addr, align 4, !tbaa !5
  %idxprom45 = sext i32 %38 to i64
  %arrayidx46 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom45
  %39 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx46, align 8, !tbaa !1
  %qg_qpaths47 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %39, i32 0, i32 6
  %40 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths47, align 8, !tbaa !38
  %arrayidx48 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %40, i64 %idxprom44
  %qp_name49 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %arrayidx48, i32 0, i32 0
  %41 = load i8*, i8** %qp_name49, align 8, !tbaa !40
  %call = call i32 @strcmp(i8* %41, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.100, i32 0, i32 0)) #1
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %if.end.42
  %cond = phi i32 [ %36, %if.end.42 ], [ %call, %cond.false ]
  store i32 %cond, i32* %tmp, !tbaa !5
  %42 = bitcast i64* %__s2_len to i8*
  call void @llvm.lifetime.end(i64 8, i8* %42) #1
  %43 = bitcast i64* %__s1_len to i8*
  call void @llvm.lifetime.end(i64 8, i8* %43) #1
  %44 = load i32, i32* %tmp, !tbaa !5
  %cmp50 = icmp eq i32 %44, 0
  br i1 %cmp50, label %if.then.52, label %if.else

if.then.52:                                       ; preds = %cond.end
  store i8* null, i8** %subdir, align 8, !tbaa !1
  br label %if.end.59

if.else:                                          ; preds = %cond.end
  %45 = load i32, i32* %qdir.addr, align 4, !tbaa !5
  %idxprom53 = sext i32 %45 to i64
  %46 = load i32, i32* %qgrp.addr, align 4, !tbaa !5
  %idxprom54 = sext i32 %46 to i64
  %arrayidx55 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom54
  %47 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx55, align 8, !tbaa !1
  %qg_qpaths56 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %47, i32 0, i32 6
  %48 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths56, align 8, !tbaa !38
  %arrayidx57 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %48, i64 %idxprom53
  %qp_name58 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %arrayidx57, i32 0, i32 0
  %49 = load i8*, i8** %qp_name58, align 8, !tbaa !40
  store i8* %49, i8** %subdir, align 8, !tbaa !1
  br label %if.end.59

if.end.59:                                        ; preds = %if.else, %if.then.52
  %50 = load i32, i32* %qgrp.addr, align 4, !tbaa !5
  %idxprom60 = sext i32 %50 to i64
  %arrayidx61 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom60
  %51 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx61, align 8, !tbaa !1
  %qg_qdir62 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %51, i32 0, i32 1
  %52 = load i8*, i8** %qg_qdir62, align 8, !tbaa !94
  %53 = load i8*, i8** %subdir, align 8, !tbaa !1
  %cmp63 = icmp eq i8* %53, null
  %cond65 = select i1 %cmp63, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0), i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.111, i32 0, i32 0)
  %54 = load i8*, i8** %subdir, align 8, !tbaa !1
  %cmp66 = icmp eq i8* %54, null
  br i1 %cmp66, label %cond.true.68, label %cond.false.69

cond.true.68:                                     ; preds = %if.end.59
  br label %cond.end.70

cond.false.69:                                    ; preds = %if.end.59
  %55 = load i8*, i8** %subdir, align 8, !tbaa !1
  br label %cond.end.70

cond.end.70:                                      ; preds = %cond.false.69, %cond.true.68
  %cond71 = phi i8* [ getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0), %cond.true.68 ], [ %55, %cond.false.69 ]
  %56 = load i32, i32* %qdir.addr, align 4, !tbaa !5
  %idxprom72 = sext i32 %56 to i64
  %57 = load i32, i32* %qgrp.addr, align 4, !tbaa !5
  %idxprom73 = sext i32 %57 to i64
  %arrayidx74 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom73
  %58 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx74, align 8, !tbaa !1
  %qg_qpaths75 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %58, i32 0, i32 6
  %59 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths75, align 8, !tbaa !38
  %arrayidx76 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %59, i64 %idxprom72
  %qp_subdirs = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %arrayidx76, i32 0, i32 1
  %60 = load i16, i16* %qp_subdirs, align 2, !tbaa !83
  %conv77 = sext i16 %60 to i32
  %and = and i32 %conv77, 1
  %cmp78 = icmp ne i32 %and, 0
  %cond80 = select i1 %cmp78, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.102, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0)
  %call81 = call i64 (i8*, i64, i32, ...) @sm_strlcpyn(i8* getelementptr inbounds ([4096 x i8], [4096 x i8]* @qid_printqueue.dir, i32 0, i32 0), i64 4096, i32 4, i8* %52, i8* %cond65, i8* %cond71, i8* %cond80)
  store i8* getelementptr inbounds ([4096 x i8], [4096 x i8]* @qid_printqueue.dir, i32 0, i32 0), i8** %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

cleanup:                                          ; preds = %cond.end.70, %if.then
  %61 = bitcast i8** %subdir to i8*
  call void @llvm.lifetime.end(i64 8, i8* %61) #1
  %62 = load i8*, i8** %retval
  ret i8* %62
}

declare void @printenvflags(%struct.envelope*) #2

declare void @printaddr(%struct.sm_file*, %struct.address*, i32) #2

declare %struct.sm_file* @sm_debug_file() #2

declare void @dumpfd(i32, i32, i32) #2

declare i32 @sm_io_getinfo(%struct.sm_file*, i32, i8*) #2

declare i32 @sm_io_setinfo(%struct.sm_file*, i32, i8*) #2

declare i32 @fsync(i32) #2

; Function Attrs: inlinehint nounwind uwtable
define available_externally i32 @fstat(i32 %__fd, %struct.stat* nonnull %__statbuf) #5 {
entry:
  %__fd.addr = alloca i32, align 4
  %__statbuf.addr = alloca %struct.stat*, align 8
  store i32 %__fd, i32* %__fd.addr, align 4, !tbaa !5
  store %struct.stat* %__statbuf, %struct.stat** %__statbuf.addr, align 8, !tbaa !1
  %0 = load i32, i32* %__fd.addr, align 4, !tbaa !5
  %1 = load %struct.stat*, %struct.stat** %__statbuf.addr, align 8, !tbaa !1
  %call = call i32 @__fxstat(i32 1, i32 %0, %struct.stat* %1) #1
  ret i32 %call
}

; Function Attrs: nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture, i8, i64, i32, i1) #1

declare i32 @sm_io_close(%struct.sm_file*, i32) #2

declare i32 @putbody(%struct.mailer_con_info*, %struct.envelope*, i8*) #2

declare i32 @sm_io_fprintf(%struct.sm_file*, i32, i8*, ...) #2

; Function Attrs: inlinehint nounwind readnone uwtable
define available_externally i32 @gnu_dev_major(i64 %__dev) #6 {
entry:
  %__dev.addr = alloca i64, align 8
  store i64 %__dev, i64* %__dev.addr, align 8, !tbaa !95
  %0 = load i64, i64* %__dev.addr, align 8, !tbaa !95
  %shr = lshr i64 %0, 8
  %and = and i64 %shr, 4095
  %1 = load i64, i64* %__dev.addr, align 8, !tbaa !95
  %shr1 = lshr i64 %1, 32
  %conv = trunc i64 %shr1 to i32
  %and2 = and i32 %conv, -4096
  %conv3 = zext i32 %and2 to i64
  %or = or i64 %and, %conv3
  %conv4 = trunc i64 %or to i32
  ret i32 %conv4
}

; Function Attrs: inlinehint nounwind readnone uwtable
define available_externally i32 @gnu_dev_minor(i64 %__dev) #6 {
entry:
  %__dev.addr = alloca i64, align 8
  store i64 %__dev, i64* %__dev.addr, align 8, !tbaa !95
  %0 = load i64, i64* %__dev.addr, align 8, !tbaa !95
  %and = and i64 %0, 255
  %1 = load i64, i64* %__dev.addr, align 8, !tbaa !95
  %shr = lshr i64 %1, 12
  %conv = trunc i64 %shr to i32
  %and1 = and i32 %conv, -256
  %conv2 = zext i32 %and1 to i64
  %or = or i64 %and, %conv2
  %conv3 = trunc i64 %or to i32
  ret i32 %conv3
}

declare i8* @denlstring(i8*, i32, i32) #2

declare void @queueup_macros(i32, %struct.sm_file*, %struct.envelope*) #2

declare i32 @macid_parse(i8*, i8**) #2

; Function Attrs: nounwind uwtable
define internal void @printctladdr(%struct.address* %a, %struct.sm_file* %tfp) #0 {
entry:
  %a.addr = alloca %struct.address*, align 8
  %tfp.addr = alloca %struct.sm_file*, align 8
  %user = alloca i8*, align 8
  %q = alloca %struct.address*, align 8
  %uid = alloca i32, align 4
  %gid = alloca i32, align 4
  %cleanup.dest.slot = alloca i32
  %__s1_len = alloca i64, align 8
  %__s2_len = alloca i64, align 8
  %tmp = alloca i32, align 4
  store %struct.address* %a, %struct.address** %a.addr, align 8, !tbaa !1
  store %struct.sm_file* %tfp, %struct.sm_file** %tfp.addr, align 8, !tbaa !1
  %0 = bitcast i8** %user to i8*
  call void @llvm.lifetime.start(i64 8, i8* %0) #1
  %1 = bitcast %struct.address** %q to i8*
  call void @llvm.lifetime.start(i64 8, i8* %1) #1
  %2 = bitcast i32* %uid to i8*
  call void @llvm.lifetime.start(i64 4, i8* %2) #1
  %3 = bitcast i32* %gid to i8*
  call void @llvm.lifetime.start(i64 4, i8* %3) #1
  %4 = load %struct.address*, %struct.address** %a.addr, align 8, !tbaa !1
  %cmp = icmp eq %struct.address* %4, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %5 = load %struct.address*, %struct.address** %a.addr, align 8, !tbaa !1
  %q_alias = getelementptr inbounds %struct.address, %struct.address* %5, i32 0, i32 11
  %6 = load %struct.address*, %struct.address** %q_alias, align 8, !tbaa !57
  %cmp1 = icmp eq %struct.address* %6, null
  br i1 %cmp1, label %if.then, label %lor.lhs.false.2

lor.lhs.false.2:                                  ; preds = %lor.lhs.false
  %7 = load %struct.sm_file*, %struct.sm_file** %tfp.addr, align 8, !tbaa !1
  %cmp3 = icmp eq %struct.sm_file* %7, null
  br i1 %cmp3, label %if.then, label %if.end.7

if.then:                                          ; preds = %lor.lhs.false.2, %lor.lhs.false, %entry
  %8 = load %struct.address*, %struct.address** @printctladdr.lastctladdr, align 8, !tbaa !1
  %cmp4 = icmp ne %struct.address* %8, null
  br i1 %cmp4, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then
  %9 = load %struct.sm_file*, %struct.sm_file** %tfp.addr, align 8, !tbaa !1
  %cmp5 = icmp ne %struct.sm_file* %9, null
  br i1 %cmp5, label %if.then.6, label %if.end

if.then.6:                                        ; preds = %land.lhs.true
  %10 = load %struct.sm_file*, %struct.sm_file** %tfp.addr, align 8, !tbaa !1
  %call = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* %10, i32 -2, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.189, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then.6, %land.lhs.true, %if.then
  store %struct.address* null, %struct.address** @printctladdr.lastctladdr, align 8, !tbaa !1
  store i32 0, i32* @printctladdr.lastuid, align 4, !tbaa !5
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.7:                                         ; preds = %lor.lhs.false.2
  %11 = load %struct.address*, %struct.address** %a.addr, align 8, !tbaa !1
  %call8 = call %struct.address* @getctladdr(%struct.address* %11)
  store %struct.address* %call8, %struct.address** %q, align 8, !tbaa !1
  %12 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %cmp9 = icmp eq %struct.address* %12, null
  br i1 %cmp9, label %if.then.10, label %if.else

if.then.10:                                       ; preds = %if.end.7
  store i8* null, i8** %user, align 8, !tbaa !1
  store i32 0, i32* %uid, align 4, !tbaa !5
  store i32 0, i32* %gid, align 4, !tbaa !5
  br label %if.end.13

if.else:                                          ; preds = %if.end.7
  %13 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_ruser = getelementptr inbounds %struct.address, %struct.address* %13, i32 0, i32 2
  %14 = load i8*, i8** %q_ruser, align 8, !tbaa !97
  %cmp11 = icmp ne i8* %14, null
  br i1 %cmp11, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.else
  %15 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_ruser12 = getelementptr inbounds %struct.address, %struct.address* %15, i32 0, i32 2
  %16 = load i8*, i8** %q_ruser12, align 8, !tbaa !97
  br label %cond.end

cond.false:                                       ; preds = %if.else
  %17 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_user = getelementptr inbounds %struct.address, %struct.address* %17, i32 0, i32 1
  %18 = load i8*, i8** %q_user, align 8, !tbaa !98
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %16, %cond.true ], [ %18, %cond.false ]
  store i8* %cond, i8** %user, align 8, !tbaa !1
  %19 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_uid = getelementptr inbounds %struct.address, %struct.address* %19, i32 0, i32 6
  %20 = load i32, i32* %q_uid, align 4, !tbaa !99
  store i32 %20, i32* %uid, align 4, !tbaa !5
  %21 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_gid = getelementptr inbounds %struct.address, %struct.address* %21, i32 0, i32 7
  %22 = load i32, i32* %q_gid, align 4, !tbaa !100
  store i32 %22, i32* %gid, align 4, !tbaa !5
  br label %if.end.13

if.end.13:                                        ; preds = %cond.end, %if.then.10
  %23 = load %struct.address*, %struct.address** %a.addr, align 8, !tbaa !1
  %q_alias14 = getelementptr inbounds %struct.address, %struct.address* %23, i32 0, i32 11
  %24 = load %struct.address*, %struct.address** %q_alias14, align 8, !tbaa !57
  store %struct.address* %24, %struct.address** %a.addr, align 8, !tbaa !1
  %25 = load %struct.address*, %struct.address** @printctladdr.lastctladdr, align 8, !tbaa !1
  %cmp15 = icmp ne %struct.address* %25, null
  br i1 %cmp15, label %land.lhs.true.16, label %if.end.23

land.lhs.true.16:                                 ; preds = %if.end.13
  %26 = load i32, i32* %uid, align 4, !tbaa !5
  %27 = load i32, i32* @printctladdr.lastuid, align 4, !tbaa !5
  %cmp17 = icmp eq i32 %26, %27
  br i1 %cmp17, label %land.lhs.true.18, label %if.end.23

land.lhs.true.18:                                 ; preds = %land.lhs.true.16
  %28 = bitcast i64* %__s1_len to i8*
  call void @llvm.lifetime.start(i64 8, i8* %28) #1
  %29 = bitcast i64* %__s2_len to i8*
  call void @llvm.lifetime.start(i64 8, i8* %29) #1
  %30 = load %struct.address*, %struct.address** @printctladdr.lastctladdr, align 8, !tbaa !1
  %q_paddr = getelementptr inbounds %struct.address, %struct.address* %30, i32 0, i32 0
  %31 = load i8*, i8** %q_paddr, align 8, !tbaa !58
  %32 = load %struct.address*, %struct.address** %a.addr, align 8, !tbaa !1
  %q_paddr19 = getelementptr inbounds %struct.address, %struct.address* %32, i32 0, i32 0
  %33 = load i8*, i8** %q_paddr19, align 8, !tbaa !58
  %call20 = call i32 @strcmp(i8* %31, i8* %33) #1
  store i32 %call20, i32* %tmp, !tbaa !5
  %34 = bitcast i64* %__s2_len to i8*
  call void @llvm.lifetime.end(i64 8, i8* %34) #1
  %35 = bitcast i64* %__s1_len to i8*
  call void @llvm.lifetime.end(i64 8, i8* %35) #1
  %36 = load i32, i32* %tmp, !tbaa !5
  %cmp21 = icmp eq i32 %36, 0
  br i1 %cmp21, label %if.then.22, label %if.end.23

if.then.22:                                       ; preds = %land.lhs.true.18
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.23:                                        ; preds = %land.lhs.true.18, %land.lhs.true.16, %if.end.13
  %37 = load i32, i32* %uid, align 4, !tbaa !5
  store i32 %37, i32* @printctladdr.lastuid, align 4, !tbaa !5
  %38 = load %struct.address*, %struct.address** %a.addr, align 8, !tbaa !1
  store %struct.address* %38, %struct.address** @printctladdr.lastctladdr, align 8, !tbaa !1
  %39 = load i32, i32* %uid, align 4, !tbaa !5
  %cmp24 = icmp eq i32 %39, 0
  br i1 %cmp24, label %if.then.30, label %lor.lhs.false.25

lor.lhs.false.25:                                 ; preds = %if.end.23
  %40 = load i8*, i8** %user, align 8, !tbaa !1
  %cmp26 = icmp eq i8* %40, null
  br i1 %cmp26, label %if.then.30, label %lor.lhs.false.27

lor.lhs.false.27:                                 ; preds = %lor.lhs.false.25
  %41 = load i8*, i8** %user, align 8, !tbaa !1
  %arrayidx = getelementptr inbounds i8, i8* %41, i64 0
  %42 = load i8, i8* %arrayidx, align 1, !tbaa !17
  %conv = sext i8 %42 to i32
  %cmp28 = icmp eq i32 %conv, 0
  br i1 %cmp28, label %if.then.30, label %if.else.32

if.then.30:                                       ; preds = %lor.lhs.false.27, %lor.lhs.false.25, %if.end.23
  %43 = load %struct.sm_file*, %struct.sm_file** %tfp.addr, align 8, !tbaa !1
  %call31 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* %43, i32 -2, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.190, i32 0, i32 0))
  br label %if.end.37

if.else.32:                                       ; preds = %lor.lhs.false.27
  %44 = load %struct.sm_file*, %struct.sm_file** %tfp.addr, align 8, !tbaa !1
  %45 = load i8*, i8** %user, align 8, !tbaa !1
  %call33 = call i8* @denlstring(i8* %45, i32 1, i32 0)
  %46 = load i32, i32* %uid, align 4, !tbaa !5
  %conv34 = zext i32 %46 to i64
  %47 = load i32, i32* %gid, align 4, !tbaa !5
  %conv35 = zext i32 %47 to i64
  %call36 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* %44, i32 -2, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.191, i32 0, i32 0), i8* %call33, i64 %conv34, i64 %conv35)
  br label %if.end.37

if.end.37:                                        ; preds = %if.else.32, %if.then.30
  %48 = load %struct.sm_file*, %struct.sm_file** %tfp.addr, align 8, !tbaa !1
  %49 = load %struct.address*, %struct.address** %a.addr, align 8, !tbaa !1
  %q_paddr38 = getelementptr inbounds %struct.address, %struct.address* %49, i32 0, i32 0
  %50 = load i8*, i8** %q_paddr38, align 8, !tbaa !58
  %call39 = call i8* @denlstring(i8* %50, i32 1, i32 0)
  %call40 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* %48, i32 -2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.192, i32 0, i32 0), i8* %call39)
  store i32 0, i32* %cleanup.dest.slot
  br label %cleanup

cleanup:                                          ; preds = %if.end.37, %if.then.22, %if.end
  %51 = bitcast i32* %gid to i8*
  call void @llvm.lifetime.end(i64 4, i8* %51) #1
  %52 = bitcast i32* %uid to i8*
  call void @llvm.lifetime.end(i64 4, i8* %52) #1
  %53 = bitcast %struct.address** %q to i8*
  call void @llvm.lifetime.end(i64 8, i8* %53) #1
  %54 = bitcast i8** %user to i8*
  call void @llvm.lifetime.end(i64 8, i8* %54) #1
  %cleanup.dest = load i32, i32* %cleanup.dest.slot
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %cleanup.cont
    i32 1, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup, %cleanup
  ret void

unreachable:                                      ; preds = %cleanup
  unreachable
}

declare i32 @sm_io_putc(%struct.sm_file*, i32, i32) #2

declare void @message(i8*, ...) #2

declare void @logdelivery(%struct.mailer*, %struct.mailer_con_info*, i8*, i8*, %struct.address*, i64, %struct.envelope*, %struct.address*, i32) #2

declare void @macdefine_tagged(%struct.MACROS_T*, i32, i32, i8*, i8*, i32, i32) #2

declare void @expand(i8*, i8*, i64, %struct.envelope*) #2

declare i8* @macname(i32) #2

declare i32 @bitzerop(i32*) #2

declare i32 @commaize(%struct.header*, i8*, i32, %struct.mailer_con_info*, %struct.envelope*, i32) #2

declare i32 @sm_io_flush(%struct.sm_file*, i32) #2

; Function Attrs: nounwind uwtable
define internal signext i8 @queue_letter(%struct.envelope* %e, i32 %type) #0 {
entry:
  %e.addr = alloca %struct.envelope*, align 8
  %type.addr = alloca i32, align 4
  store %struct.envelope* %e, %struct.envelope** %e.addr, align 8, !tbaa !1
  store i32 %type, i32* %type.addr, align 4, !tbaa !5
  %0 = load i32, i32* %type.addr, align 4, !tbaa !5
  %cmp = icmp eq i32 %0, 63
  br i1 %cmp, label %if.then, label %if.end.5

if.then:                                          ; preds = %entry
  %1 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_quarmsg = getelementptr inbounds %struct.envelope, %struct.envelope* %1, i32 0, i32 36
  %2 = load i8*, i8** %e_quarmsg, align 8, !tbaa !43
  %cmp1 = icmp ne i8* %2, null
  br i1 %cmp1, label %if.then.2, label %if.else

if.then.2:                                        ; preds = %if.then
  store i32 104, i32* %type.addr, align 4, !tbaa !5
  br label %if.end

if.else:                                          ; preds = %if.then
  %3 = load i32, i32* @QueueMode, align 4, !tbaa !5
  switch i32 %3, label %sw.default [
    i32 32, label %sw.bb
    i32 81, label %sw.bb.3
    i32 76, label %sw.bb.4
  ]

sw.bb:                                            ; preds = %if.else
  store i32 113, i32* %type.addr, align 4, !tbaa !5
  br label %sw.epilog

sw.bb.3:                                          ; preds = %if.else
  store i32 104, i32* %type.addr, align 4, !tbaa !5
  br label %sw.epilog

sw.bb.4:                                          ; preds = %if.else
  store i32 81, i32* %type.addr, align 4, !tbaa !5
  br label %sw.epilog

sw.default:                                       ; preds = %if.else
  call void @abort() #13
  unreachable

sw.epilog:                                        ; preds = %sw.bb.4, %sw.bb.3, %sw.bb
  br label %if.end

if.end:                                           ; preds = %sw.epilog, %if.then.2
  br label %if.end.5

if.end.5:                                         ; preds = %if.end, %entry
  %4 = load i32, i32* %type.addr, align 4, !tbaa !5
  %conv = trunc i32 %4 to i8
  ret i8 %conv
}

; Function Attrs: nounwind
declare i32 @unlink(i8*) #3

declare void @sync_dir(i8*, i32) #2

; Function Attrs: nounwind uwtable
define void @mark_work_group_restart(i32 %wgrp, i32 %reason) #0 {
entry:
  %wgrp.addr = alloca i32, align 4
  %reason.addr = alloca i32, align 4
  store i32 %wgrp, i32* %wgrp.addr, align 4, !tbaa !5
  store i32 %reason, i32* %reason.addr, align 4, !tbaa !5
  %0 = load i32, i32* %wgrp.addr, align 4, !tbaa !5
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %wgrp.addr, align 4, !tbaa !5
  %2 = load i32, i32* @NumWorkGroups, align 4, !tbaa !5
  %cmp1 = icmp sgt i32 %1, %2
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %if.end.4

if.end:                                           ; preds = %lor.lhs.false
  %3 = load i32, i32* %reason.addr, align 4, !tbaa !5
  %4 = load i32, i32* %wgrp.addr, align 4, !tbaa !5
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds [51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 %idxprom
  %wg_restart = getelementptr inbounds %struct.workgrp, %struct.workgrp* %arrayidx, i32 0, i32 6
  store volatile i32 %3, i32* %wg_restart, align 4, !tbaa !101
  %5 = load i32, i32* %reason.addr, align 4, !tbaa !5
  %cmp2 = icmp sge i32 %5, 0
  br i1 %cmp2, label %if.then.3, label %if.end.4

if.then.3:                                        ; preds = %if.end
  store volatile i32 1, i32* @RestartWorkGroup, align 4, !tbaa !5
  br label %if.end.4

if.end.4:                                         ; preds = %if.then, %if.then.3, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define void @restart_marked_work_groups() #0 {
entry:
  %i = alloca i32, align 4
  %wasblocked = alloca i32, align 4
  %cleanup.dest.slot = alloca i32
  %0 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start(i64 4, i8* %0) #1
  %1 = bitcast i32* %wasblocked to i8*
  call void @llvm.lifetime.start(i64 4, i8* %1) #1
  %2 = load volatile i32, i32* @NoMoreRunners, align 4, !tbaa !5
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end:                                           ; preds = %entry
  %call = call i32 @sm_blocksignal(i32 17)
  store i32 %call, i32* %wasblocked, align 4, !tbaa !5
  store i32 0, i32* %i, align 4, !tbaa !5
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %3 = load i32, i32* %i, align 4, !tbaa !5
  %4 = load i32, i32* @NumWorkGroups, align 4, !tbaa !5
  %cmp = icmp slt i32 %3, %4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds [51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 %idxprom
  %wg_restart = getelementptr inbounds %struct.workgrp, %struct.workgrp* %arrayidx, i32 0, i32 6
  %6 = load volatile i32, i32* %wg_restart, align 4, !tbaa !101
  %cmp1 = icmp sge i32 %6, 0
  br i1 %cmp1, label %if.then.2, label %if.end.9

if.then.2:                                        ; preds = %for.body
  %7 = load i32, i32* @LogLevel, align 4, !tbaa !5
  %cmp3 = icmp sgt i32 %7, 8
  br i1 %cmp3, label %if.then.4, label %if.end.8

if.then.4:                                        ; preds = %if.then.2
  %8 = load i32, i32* %i, align 4, !tbaa !5
  %9 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom5 = sext i32 %9 to i64
  %arrayidx6 = getelementptr inbounds [51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 %idxprom5
  %wg_restart7 = getelementptr inbounds %struct.workgrp, %struct.workgrp* %arrayidx6, i32 0, i32 6
  %10 = load volatile i32, i32* %wg_restart7, align 4, !tbaa !101
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 3, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0), i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.61, i32 0, i32 0), i32 %8, i32 %10)
  br label %if.end.8

if.end.8:                                         ; preds = %if.then.4, %if.then.2
  %11 = load i32, i32* %i, align 4, !tbaa !5
  call void @restart_work_group(i32 %11)
  br label %if.end.9

if.end.9:                                         ; preds = %if.end.8, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end.9
  %12 = load i32, i32* %i, align 4, !tbaa !5
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %i, align 4, !tbaa !5
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store volatile i32 0, i32* @RestartWorkGroup, align 4, !tbaa !5
  %13 = load i32, i32* %wasblocked, align 4, !tbaa !5
  %cmp10 = icmp eq i32 %13, 0
  br i1 %cmp10, label %if.then.11, label %if.end.13

if.then.11:                                       ; preds = %for.end
  %call12 = call i32 @sm_releasesignal(i32 17)
  br label %if.end.13

if.end.13:                                        ; preds = %if.then.11, %for.end
  store i32 0, i32* %cleanup.dest.slot
  br label %cleanup

cleanup:                                          ; preds = %if.end.13, %if.then
  %14 = bitcast i32* %wasblocked to i8*
  call void @llvm.lifetime.end(i64 4, i8* %14) #1
  %15 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end(i64 4, i8* %15) #1
  %cleanup.dest = load i32, i32* %cleanup.dest.slot
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %cleanup.cont
    i32 1, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup, %cleanup
  ret void

unreachable:                                      ; preds = %cleanup
  unreachable
}

declare i32 @sm_blocksignal(i32) #2

; Function Attrs: nounwind uwtable
define internal void @restart_work_group(i32 %wgrp) #0 {
entry:
  %wgrp.addr = alloca i32, align 4
  store i32 %wgrp, i32* %wgrp.addr, align 4, !tbaa !5
  %0 = load volatile i32, i32* @NoMoreRunners, align 4, !tbaa !5
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %wgrp.addr, align 4, !tbaa !5
  %cmp = icmp slt i32 %1, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false.1

lor.lhs.false.1:                                  ; preds = %lor.lhs.false
  %2 = load i32, i32* %wgrp.addr, align 4, !tbaa !5
  %3 = load i32, i32* @NumWorkGroups, align 4, !tbaa !5
  %cmp2 = icmp sgt i32 %2, %3
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false.1, %lor.lhs.false, %entry
  br label %if.end.10

if.end:                                           ; preds = %lor.lhs.false.1
  %4 = load i32, i32* %wgrp.addr, align 4, !tbaa !5
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds [51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 %idxprom
  %wg_restart = getelementptr inbounds %struct.workgrp, %struct.workgrp* %arrayidx, i32 0, i32 6
  store volatile i32 -1, i32* %wg_restart, align 4, !tbaa !101
  %5 = load i32, i32* %wgrp.addr, align 4, !tbaa !5
  %idxprom3 = sext i32 %5 to i64
  %arrayidx4 = getelementptr inbounds [51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 %idxprom3
  %wg_restartcnt = getelementptr inbounds %struct.workgrp, %struct.workgrp* %arrayidx4, i32 0, i32 7
  %6 = load volatile i32, i32* %wg_restartcnt, align 4, !tbaa !103
  %cmp5 = icmp slt i32 %6, 10
  br i1 %cmp5, label %if.then.6, label %if.else

if.then.6:                                        ; preds = %if.end
  %7 = load i32, i32* %wgrp.addr, align 4, !tbaa !5
  %idxprom7 = sext i32 %7 to i64
  %arrayidx8 = getelementptr inbounds [51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 %idxprom7
  %wg_restartcnt9 = getelementptr inbounds %struct.workgrp, %struct.workgrp* %arrayidx8, i32 0, i32 7
  %8 = load volatile i32, i32* %wg_restartcnt9, align 4, !tbaa !103
  %inc = add nsw i32 %8, 1
  store volatile i32 %inc, i32* %wg_restartcnt9, align 4, !tbaa !103
  %9 = load i32, i32* %wgrp.addr, align 4, !tbaa !5
  %call = call i32 @run_work_group(i32 %9, i32 21)
  br label %if.end.10

if.else:                                          ; preds = %if.end
  %10 = load i32, i32* %wgrp.addr, align 4, !tbaa !5
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 3, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0), i8* getelementptr inbounds ([78 x i8], [78 x i8]* @.str.193, i32 0, i32 0), i32 %10)
  br label %if.end.10

if.end.10:                                        ; preds = %if.then, %if.else, %if.then.6
  ret void
}

declare i32 @sm_releasesignal(i32) #2

; Function Attrs: nounwind uwtable
define i32 @runqueue(i32 %forkflag, i32 %verbose, i32 %persistent, i32 %runall) #0 {
entry:
  %forkflag.addr = alloca i32, align 4
  %verbose.addr = alloca i32, align 4
  %persistent.addr = alloca i32, align 4
  %runall.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %ret = alloca i32, align 4
  %cursh = alloca void (i32)*, align 8
  %oldgroup = alloca i32, align 4
  %rwgflags = alloca i32, align 4
  %wasblocked = alloca i32, align 4
  %cleanup.dest.slot = alloca i32
  %h = alloca i32, align 4
  store i32 %forkflag, i32* %forkflag.addr, align 4, !tbaa !5
  store i32 %verbose, i32* %verbose.addr, align 4, !tbaa !5
  store i32 %persistent, i32* %persistent.addr, align 4, !tbaa !5
  store i32 %runall, i32* %runall.addr, align 4, !tbaa !5
  %0 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start(i64 4, i8* %0) #1
  %1 = bitcast i32* %ret to i8*
  call void @llvm.lifetime.start(i64 4, i8* %1) #1
  store i32 1, i32* %ret, align 4, !tbaa !5
  %2 = bitcast void (i32)** %cursh to i8*
  call void @llvm.lifetime.start(i64 8, i8* %2) #1
  %3 = bitcast i32* %oldgroup to i8*
  call void @llvm.lifetime.start(i64 4, i8* %3) #1
  store i32 0, i32* %oldgroup, align 4, !tbaa !5
  %4 = load i32, i32* getelementptr inbounds (%struct.sm_debug, %struct.sm_debug* @DebugLeakQ, i32 0, i32 1), align 4, !tbaa !104
  %cmp = icmp uge i32 %4, 1
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %5 = load i32, i32* getelementptr inbounds (%struct.sm_debug, %struct.sm_debug* @DebugLeakQ, i32 0, i32 1), align 4, !tbaa !104
  %cmp1 = icmp ne i32 %5, -1
  br i1 %cmp1, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %call = call i32 @sm_debug_loadactive(%struct.sm_debug* @DebugLeakQ, i32 1)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %land.lhs.true
  %6 = load i32, i32* @SmHeapGroup, align 4, !tbaa !5
  store i32 %6, i32* %oldgroup, align 4, !tbaa !5
  %7 = load i32, i32* @SmHeapMaxGroup, align 4, !tbaa !5
  %inc = add nsw i32 %7, 1
  store i32 %inc, i32* @SmHeapMaxGroup, align 4, !tbaa !5
  store i32 %inc, i32* @SmHeapGroup, align 4, !tbaa !5
  %8 = load i32, i32* @SmHeapGroup, align 4, !tbaa !5
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.62, i32 0, i32 0), i32 %8)
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false, %entry
  store volatile i32 0, i32* @DoQueueRun, align 4, !tbaa !5
  %9 = load i32, i32* %forkflag.addr, align 4, !tbaa !5
  %tobool2 = icmp ne i32 %9, 0
  br i1 %tobool2, label %if.end.12, label %land.lhs.true.3

land.lhs.true.3:                                  ; preds = %if.end
  %10 = load i32, i32* %verbose.addr, align 4, !tbaa !5
  %tobool4 = icmp ne i32 %10, 0
  br i1 %tobool4, label %if.end.12, label %land.lhs.true.5

land.lhs.true.5:                                  ; preds = %land.lhs.true.3
  %11 = load volatile %struct.queuegrp**, %struct.queuegrp*** getelementptr inbounds ([51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 0, i32 3), align 8, !tbaa !106
  %arrayidx = getelementptr inbounds %struct.queuegrp*, %struct.queuegrp** %11, i64 0
  %12 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx, align 8, !tbaa !1
  %qg_numqueues = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %12, i32 0, i32 4
  %13 = load i32, i32* %qg_numqueues, align 4, !tbaa !82
  %cmp6 = icmp sgt i32 %13, 1
  br i1 %cmp6, label %if.then.11, label %lor.lhs.false.7

lor.lhs.false.7:                                  ; preds = %land.lhs.true.5
  %14 = load i32, i32* @NumWorkGroups, align 4, !tbaa !5
  %cmp8 = icmp sgt i32 %14, 1
  br i1 %cmp8, label %if.then.11, label %lor.lhs.false.9

lor.lhs.false.9:                                  ; preds = %lor.lhs.false.7
  %15 = load volatile i32, i32* getelementptr inbounds ([51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 0, i32 0), align 4, !tbaa !107
  %cmp10 = icmp sgt i32 %15, 1
  br i1 %cmp10, label %if.then.11, label %if.end.12

if.then.11:                                       ; preds = %lor.lhs.false.9, %lor.lhs.false.7, %land.lhs.true.5
  store i32 1, i32* %forkflag.addr, align 4, !tbaa !5
  br label %if.end.12

if.end.12:                                        ; preds = %if.then.11, %lor.lhs.false.9, %land.lhs.true.3, %if.end
  %call13 = call void (i32)* @sm_signal(i32 15, void (i32)* @runners_sigterm)
  store void (i32)* %call13, void (i32)** %cursh, align 8, !tbaa !1
  %16 = load void (i32)*, void (i32)** %cursh, align 8, !tbaa !1
  %cmp14 = icmp ne void (i32)* %16, @runners_sigterm
  br i1 %cmp14, label %if.then.15, label %if.end.16

if.then.15:                                       ; preds = %if.end.12
  %17 = load void (i32)*, void (i32)** %cursh, align 8, !tbaa !1
  store void (i32)* %17, void (i32)** @Oldsh_term, align 8, !tbaa !1
  br label %if.end.16

if.end.16:                                        ; preds = %if.then.15, %if.end.12
  %call17 = call void (i32)* @sm_signal(i32 1, void (i32)* @runners_sighup)
  store void (i32)* %call17, void (i32)** %cursh, align 8, !tbaa !1
  %18 = load void (i32)*, void (i32)** %cursh, align 8, !tbaa !1
  %cmp18 = icmp ne void (i32)* %18, @runners_sighup
  br i1 %cmp18, label %if.then.19, label %if.end.20

if.then.19:                                       ; preds = %if.end.16
  %19 = load void (i32)*, void (i32)** %cursh, align 8, !tbaa !1
  store void (i32)* %19, void (i32)** @Oldsh_hup, align 8, !tbaa !1
  br label %if.end.20

if.end.20:                                        ; preds = %if.then.19, %if.end.16
  store i32 0, i32* %i, align 4, !tbaa !5
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end.20
  %20 = load i32, i32* %i, align 4, !tbaa !5
  %21 = load i32, i32* @NumWorkGroups, align 4, !tbaa !5
  %cmp21 = icmp slt i32 %20, %21
  br i1 %cmp21, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %22 = load volatile i32, i32* @NoMoreRunners, align 4, !tbaa !5
  %tobool22 = icmp ne i32 %22, 0
  %lnot = xor i1 %tobool22, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %23 = phi i1 [ false, %for.cond ], [ %lnot, %land.rhs ]
  br i1 %23, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %24 = bitcast i32* %rwgflags to i8*
  call void @llvm.lifetime.start(i64 4, i8* %24) #1
  store i32 0, i32* %rwgflags, align 4, !tbaa !5
  %25 = bitcast i32* %wasblocked to i8*
  call void @llvm.lifetime.start(i64 4, i8* %25) #1
  %26 = load i32, i32* @MaxQueueChildren, align 4, !tbaa !5
  %cmp23 = icmp sgt i32 %26, 0
  br i1 %cmp23, label %land.lhs.true.24, label %if.end.28

land.lhs.true.24:                                 ; preds = %for.body
  %27 = load volatile i32, i32* @CurRunners, align 4, !tbaa !5
  %28 = load i32, i32* @runqueue.curnum, align 4, !tbaa !5
  %idxprom = sext i32 %28 to i64
  %arrayidx25 = getelementptr inbounds [51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 %idxprom
  %wg_maxact = getelementptr inbounds %struct.workgrp, %struct.workgrp* %arrayidx25, i32 0, i32 4
  %29 = load volatile i32, i32* %wg_maxact, align 4, !tbaa !108
  %add = add nsw i32 %27, %29
  %30 = load i32, i32* @MaxQueueChildren, align 4, !tbaa !5
  %cmp26 = icmp sgt i32 %add, %30
  br i1 %cmp26, label %if.then.27, label %if.end.28

if.then.27:                                       ; preds = %land.lhs.true.24
  store i32 2, i32* %cleanup.dest.slot
  br label %cleanup

if.end.28:                                        ; preds = %land.lhs.true.24, %for.body
  %call29 = call i32 @sm_blocksignal(i32 17)
  store i32 %call29, i32* %wasblocked, align 4, !tbaa !5
  %31 = load i32, i32* @runqueue.curnum, align 4, !tbaa !5
  %idxprom30 = sext i32 %31 to i64
  %arrayidx31 = getelementptr inbounds [51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 %idxprom30
  %wg_maxact32 = getelementptr inbounds %struct.workgrp, %struct.workgrp* %arrayidx31, i32 0, i32 4
  %32 = load volatile i32, i32* %wg_maxact32, align 4, !tbaa !108
  %33 = load volatile i32, i32* @CurRunners, align 4, !tbaa !5
  %add33 = add nsw i32 %33, %32
  store volatile i32 %add33, i32* @CurRunners, align 4, !tbaa !5
  %34 = load i32, i32* %wasblocked, align 4, !tbaa !5
  %cmp34 = icmp eq i32 %34, 0
  br i1 %cmp34, label %if.then.35, label %if.end.37

if.then.35:                                       ; preds = %if.end.28
  %call36 = call i32 @sm_releasesignal(i32 17)
  br label %if.end.37

if.end.37:                                        ; preds = %if.then.35, %if.end.28
  %35 = load i32, i32* %forkflag.addr, align 4, !tbaa !5
  %tobool38 = icmp ne i32 %35, 0
  br i1 %tobool38, label %if.then.39, label %if.end.40

if.then.39:                                       ; preds = %if.end.37
  %36 = load i32, i32* %rwgflags, align 4, !tbaa !5
  %or = or i32 %36, 1
  store i32 %or, i32* %rwgflags, align 4, !tbaa !5
  br label %if.end.40

if.end.40:                                        ; preds = %if.then.39, %if.end.37
  %37 = load i32, i32* %verbose.addr, align 4, !tbaa !5
  %tobool41 = icmp ne i32 %37, 0
  br i1 %tobool41, label %if.then.42, label %if.end.44

if.then.42:                                       ; preds = %if.end.40
  %38 = load i32, i32* %rwgflags, align 4, !tbaa !5
  %or43 = or i32 %38, 2
  store i32 %or43, i32* %rwgflags, align 4, !tbaa !5
  br label %if.end.44

if.end.44:                                        ; preds = %if.then.42, %if.end.40
  %39 = load i32, i32* %persistent.addr, align 4, !tbaa !5
  %tobool45 = icmp ne i32 %39, 0
  br i1 %tobool45, label %if.then.46, label %if.end.48

if.then.46:                                       ; preds = %if.end.44
  %40 = load i32, i32* %rwgflags, align 4, !tbaa !5
  %or47 = or i32 %40, 4
  store i32 %or47, i32* %rwgflags, align 4, !tbaa !5
  br label %if.end.48

if.end.48:                                        ; preds = %if.then.46, %if.end.44
  %41 = load i32, i32* %runall.addr, align 4, !tbaa !5
  %tobool49 = icmp ne i32 %41, 0
  br i1 %tobool49, label %if.then.50, label %if.end.52

if.then.50:                                       ; preds = %if.end.48
  %42 = load i32, i32* %rwgflags, align 4, !tbaa !5
  %or51 = or i32 %42, 16
  store i32 %or51, i32* %rwgflags, align 4, !tbaa !5
  br label %if.end.52

if.end.52:                                        ; preds = %if.then.50, %if.end.48
  %43 = load i32, i32* @runqueue.curnum, align 4, !tbaa !5
  %44 = load i32, i32* %rwgflags, align 4, !tbaa !5
  %call53 = call i32 @run_work_group(i32 %43, i32 %44)
  store i32 %call53, i32* %ret, align 4, !tbaa !5
  %45 = load i32, i32* %ret, align 4, !tbaa !5
  %tobool54 = icmp ne i32 %45, 0
  br i1 %tobool54, label %if.end.73, label %if.then.55

if.then.55:                                       ; preds = %if.end.52
  %call56 = call i32 @sm_blocksignal(i32 17)
  store i32 %call56, i32* %wasblocked, align 4, !tbaa !5
  %46 = load i32, i32* @runqueue.curnum, align 4, !tbaa !5
  %idxprom57 = sext i32 %46 to i64
  %arrayidx58 = getelementptr inbounds [51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 %idxprom57
  %wg_maxact59 = getelementptr inbounds %struct.workgrp, %struct.workgrp* %arrayidx58, i32 0, i32 4
  %47 = load volatile i32, i32* %wg_maxact59, align 4, !tbaa !108
  %48 = load volatile i32, i32* @CurRunners, align 4, !tbaa !5
  %sub = sub nsw i32 %48, %47
  store volatile i32 %sub, i32* @CurRunners, align 4, !tbaa !5
  br label %do.body

do.body:                                          ; preds = %if.then.55
  %49 = load volatile i32, i32* @CurRunners, align 4, !tbaa !5
  %cmp60 = icmp slt i32 %49, 0
  br i1 %cmp60, label %if.then.61, label %if.end.68

if.then.61:                                       ; preds = %do.body
  %50 = load i32, i32* @LogLevel, align 4, !tbaa !5
  %cmp62 = icmp sgt i32 %50, 3
  br i1 %cmp62, label %if.then.63, label %if.end.67

if.then.63:                                       ; preds = %if.then.61
  %51 = load volatile i32, i32* @CurRunners, align 4, !tbaa !5
  %52 = load i32, i32* @runqueue.curnum, align 4, !tbaa !5
  %53 = load i32, i32* @runqueue.curnum, align 4, !tbaa !5
  %idxprom64 = sext i32 %53 to i64
  %arrayidx65 = getelementptr inbounds [51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 %idxprom64
  %wg_maxact66 = getelementptr inbounds %struct.workgrp, %struct.workgrp* %arrayidx65, i32 0, i32 4
  %54 = load volatile i32, i32* %wg_maxact66, align 4, !tbaa !108
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 3, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0), i8* getelementptr inbounds ([60 x i8], [60 x i8]* @.str.63, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.64, i32 0, i32 0), i32 %51, i32 %52, i32 %54)
  br label %if.end.67

if.end.67:                                        ; preds = %if.then.63, %if.then.61
  store volatile i32 0, i32* @CurRunners, align 4, !tbaa !5
  br label %if.end.68

if.end.68:                                        ; preds = %if.end.67, %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end.68
  br label %do.end

do.end:                                           ; preds = %do.cond
  %55 = load i32, i32* %wasblocked, align 4, !tbaa !5
  %cmp69 = icmp eq i32 %55, 0
  br i1 %cmp69, label %if.then.70, label %if.end.72

if.then.70:                                       ; preds = %do.end
  %call71 = call i32 @sm_releasesignal(i32 17)
  br label %if.end.72

if.end.72:                                        ; preds = %if.then.70, %do.end
  store i32 2, i32* %cleanup.dest.slot
  br label %cleanup

if.end.73:                                        ; preds = %if.end.52
  %56 = load i32, i32* %persistent.addr, align 4, !tbaa !5
  %tobool74 = icmp ne i32 %56, 0
  br i1 %tobool74, label %if.end.76, label %if.then.75

if.then.75:                                       ; preds = %if.end.73
  %57 = load i32, i32* %runall.addr, align 4, !tbaa !5
  %58 = load i32, i32* @runqueue.curnum, align 4, !tbaa !5
  call void @schedule_queue_runs(i32 %57, i32 %58, i32 1)
  br label %if.end.76

if.end.76:                                        ; preds = %if.then.75, %if.end.73
  %59 = load i32, i32* @runqueue.curnum, align 4, !tbaa !5
  %inc77 = add nsw i32 %59, 1
  store i32 %inc77, i32* @runqueue.curnum, align 4, !tbaa !5
  %60 = load i32, i32* @NumWorkGroups, align 4, !tbaa !5
  %cmp78 = icmp sge i32 %inc77, %60
  br i1 %cmp78, label %if.then.79, label %if.else

if.then.79:                                       ; preds = %if.end.76
  store i32 0, i32* @runqueue.curnum, align 4, !tbaa !5
  br label %if.end.80

if.else:                                          ; preds = %if.end.76
  br label %if.end.80

if.end.80:                                        ; preds = %if.else, %if.then.79
  store i32 0, i32* %cleanup.dest.slot
  br label %cleanup

cleanup:                                          ; preds = %if.end.80, %if.end.72, %if.then.27
  %61 = bitcast i32* %wasblocked to i8*
  call void @llvm.lifetime.end(i64 4, i8* %61) #1
  %62 = bitcast i32* %rwgflags to i8*
  call void @llvm.lifetime.end(i64 4, i8* %62) #1
  %cleanup.dest = load i32, i32* %cleanup.dest.slot
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %cleanup.cont
    i32 2, label %for.end
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont
  %63 = load i32, i32* %i, align 4, !tbaa !5
  %inc82 = add nsw i32 %63, 1
  store i32 %inc82, i32* %i, align 4, !tbaa !5
  br label %for.cond

for.end:                                          ; preds = %cleanup, %land.end
  %64 = load i32, i32* %i, align 4, !tbaa !5
  %65 = load i32, i32* @NumWorkGroups, align 4, !tbaa !5
  %cmp83 = icmp slt i32 %64, %65
  br i1 %cmp83, label %land.lhs.true.84, label %if.end.100

land.lhs.true.84:                                 ; preds = %for.end
  %66 = load volatile i32, i32* @NoMoreRunners, align 4, !tbaa !5
  %tobool85 = icmp ne i32 %66, 0
  br i1 %tobool85, label %if.end.100, label %land.lhs.true.86

land.lhs.true.86:                                 ; preds = %land.lhs.true.84
  %67 = load i32, i32* %persistent.addr, align 4, !tbaa !5
  %tobool87 = icmp ne i32 %67, 0
  br i1 %tobool87, label %if.end.100, label %if.then.88

if.then.88:                                       ; preds = %land.lhs.true.86
  %68 = bitcast i32* %h to i8*
  call void @llvm.lifetime.start(i64 4, i8* %68) #1
  %69 = load i32, i32* @runqueue.curnum, align 4, !tbaa !5
  store i32 %69, i32* %h, align 4, !tbaa !5
  br label %for.cond.89

for.cond.89:                                      ; preds = %for.inc.97, %if.then.88
  %70 = load i32, i32* %i, align 4, !tbaa !5
  %71 = load i32, i32* @NumWorkGroups, align 4, !tbaa !5
  %cmp90 = icmp slt i32 %70, %71
  br i1 %cmp90, label %for.body.91, label %for.end.99

for.body.91:                                      ; preds = %for.cond.89
  %72 = load i32, i32* %runall.addr, align 4, !tbaa !5
  %73 = load i32, i32* %h, align 4, !tbaa !5
  call void @schedule_queue_runs(i32 %72, i32 %73, i32 0)
  %74 = load i32, i32* %h, align 4, !tbaa !5
  %inc92 = add nsw i32 %74, 1
  store i32 %inc92, i32* %h, align 4, !tbaa !5
  %75 = load i32, i32* @NumWorkGroups, align 4, !tbaa !5
  %cmp93 = icmp sge i32 %inc92, %75
  br i1 %cmp93, label %if.then.94, label %if.else.95

if.then.94:                                       ; preds = %for.body.91
  store i32 0, i32* %h, align 4, !tbaa !5
  br label %if.end.96

if.else.95:                                       ; preds = %for.body.91
  br label %if.end.96

if.end.96:                                        ; preds = %if.else.95, %if.then.94
  br label %for.inc.97

for.inc.97:                                       ; preds = %if.end.96
  %76 = load i32, i32* %i, align 4, !tbaa !5
  %inc98 = add nsw i32 %76, 1
  store i32 %inc98, i32* %i, align 4, !tbaa !5
  br label %for.cond.89

for.end.99:                                       ; preds = %for.cond.89
  %77 = bitcast i32* %h to i8*
  call void @llvm.lifetime.end(i64 4, i8* %77) #1
  br label %if.end.100

if.end.100:                                       ; preds = %for.end.99, %land.lhs.true.86, %land.lhs.true.84, %for.end
  %78 = load i32, i32* getelementptr inbounds (%struct.sm_debug, %struct.sm_debug* @DebugLeakQ, i32 0, i32 1), align 4, !tbaa !104
  %cmp101 = icmp uge i32 %78, 1
  br i1 %cmp101, label %land.lhs.true.102, label %if.end.108

land.lhs.true.102:                                ; preds = %if.end.100
  %79 = load i32, i32* getelementptr inbounds (%struct.sm_debug, %struct.sm_debug* @DebugLeakQ, i32 0, i32 1), align 4, !tbaa !104
  %cmp103 = icmp ne i32 %79, -1
  br i1 %cmp103, label %if.then.107, label %lor.lhs.false.104

lor.lhs.false.104:                                ; preds = %land.lhs.true.102
  %call105 = call i32 @sm_debug_loadactive(%struct.sm_debug* @DebugLeakQ, i32 1)
  %tobool106 = icmp ne i32 %call105, 0
  br i1 %tobool106, label %if.then.107, label %if.end.108

if.then.107:                                      ; preds = %lor.lhs.false.104, %land.lhs.true.102
  %80 = load i32, i32* %oldgroup, align 4, !tbaa !5
  store i32 %80, i32* @SmHeapGroup, align 4, !tbaa !5
  br label %if.end.108

if.end.108:                                       ; preds = %if.then.107, %lor.lhs.false.104, %if.end.100
  %81 = load i32, i32* %ret, align 4, !tbaa !5
  store i32 1, i32* %cleanup.dest.slot
  %82 = bitcast i32* %oldgroup to i8*
  call void @llvm.lifetime.end(i64 4, i8* %82) #1
  %83 = bitcast void (i32)** %cursh to i8*
  call void @llvm.lifetime.end(i64 8, i8* %83) #1
  %84 = bitcast i32* %ret to i8*
  call void @llvm.lifetime.end(i64 4, i8* %84) #1
  %85 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end(i64 4, i8* %85) #1
  ret i32 %81

unreachable:                                      ; preds = %cleanup
  unreachable
}

declare i32 @sm_debug_loadactive(%struct.sm_debug*, i32) #2

declare void (i32)* @sm_signal(i32, void (i32)*) #2

; Function Attrs: nounwind uwtable
define internal void @runners_sigterm(i32 %sig) #0 {
entry:
  %sig.addr = alloca i32, align 4
  %save_errno = alloca i32, align 4
  %cleanup.dest.slot = alloca i32
  store i32 %sig, i32* %sig.addr, align 4, !tbaa !5
  %0 = bitcast i32* %save_errno to i8*
  call void @llvm.lifetime.start(i64 4, i8* %0) #1
  %call = call i32* @__errno_location() #11
  %1 = load i32, i32* %call, align 4, !tbaa !5
  store i32 %1, i32* %save_errno, align 4, !tbaa !5
  %2 = load i32, i32* %save_errno, align 4, !tbaa !5
  %call1 = call i32* @__errno_location() #11
  store i32 %2, i32* %call1, align 4, !tbaa !5
  br label %do.body

do.body:                                          ; preds = %entry
  %3 = load volatile i32, i32* @InCriticalSection, align 4, !tbaa !5
  %cmp = icmp ugt i32 %3, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %do.body
  %4 = load i32, i32* %sig.addr, align 4, !tbaa !5
  %cmp2 = icmp ne i32 %4, 0
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %5 = load i32, i32* %sig.addr, align 4, !tbaa !5
  call void @pend_signal(i32 %5)
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end:                                           ; preds = %land.lhs.true, %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store volatile i32 1, i32* @NoMoreRunners, align 4, !tbaa !5
  %6 = load void (i32)*, void (i32)** @Oldsh_term, align 8, !tbaa !1
  store volatile void (i32)* %6, void (i32)** @Oldsh, align 8, !tbaa !1
  %7 = load i32, i32* %sig.addr, align 4, !tbaa !5
  store volatile i32 %7, i32* @Oldsig, align 4, !tbaa !5
  %8 = load i32, i32* %sig.addr, align 4, !tbaa !5
  call void @proc_list_signal(i32 3, i32 %8)
  %9 = load i32, i32* @BlockOldsh, align 4, !tbaa !5
  %tobool = icmp ne i32 %9, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then.5

lor.lhs.false:                                    ; preds = %do.end
  %call3 = call i32 @getppid() #1
  %cmp4 = icmp sle i32 %call3, 1
  br i1 %cmp4, label %if.then.5, label %if.end.13

if.then.5:                                        ; preds = %lor.lhs.false, %do.end
  %10 = load void (i32)*, void (i32)** @Oldsh_term, align 8, !tbaa !1
  %cmp6 = icmp ne void (i32)* %10, null
  br i1 %cmp6, label %land.lhs.true.7, label %if.end.12

land.lhs.true.7:                                  ; preds = %if.then.5
  %11 = load void (i32)*, void (i32)** @Oldsh_term, align 8, !tbaa !1
  %cmp8 = icmp ne void (i32)* %11, inttoptr (i64 1 to void (i32)*)
  br i1 %cmp8, label %land.lhs.true.9, label %if.end.12

land.lhs.true.9:                                  ; preds = %land.lhs.true.7
  %12 = load void (i32)*, void (i32)** @Oldsh_term, align 8, !tbaa !1
  %cmp10 = icmp ne void (i32)* %12, @runners_sigterm
  br i1 %cmp10, label %if.then.11, label %if.end.12

if.then.11:                                       ; preds = %land.lhs.true.9
  %13 = load void (i32)*, void (i32)** @Oldsh_term, align 8, !tbaa !1
  %14 = load i32, i32* %sig.addr, align 4, !tbaa !5
  call void %13(i32 %14)
  br label %if.end.12

if.end.12:                                        ; preds = %if.then.11, %land.lhs.true.9, %land.lhs.true.7, %if.then.5
  br label %if.end.13

if.end.13:                                        ; preds = %if.end.12, %lor.lhs.false
  %15 = load i32, i32* %save_errno, align 4, !tbaa !5
  %call14 = call i32* @__errno_location() #11
  store i32 %15, i32* %call14, align 4, !tbaa !5
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

cleanup:                                          ; preds = %if.end.13, %if.then
  %16 = bitcast i32* %save_errno to i8*
  call void @llvm.lifetime.end(i64 4, i8* %16) #1
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @runners_sighup(i32 %sig) #0 {
entry:
  %sig.addr = alloca i32, align 4
  %save_errno = alloca i32, align 4
  %cleanup.dest.slot = alloca i32
  store i32 %sig, i32* %sig.addr, align 4, !tbaa !5
  %0 = bitcast i32* %save_errno to i8*
  call void @llvm.lifetime.start(i64 4, i8* %0) #1
  %call = call i32* @__errno_location() #11
  %1 = load i32, i32* %call, align 4, !tbaa !5
  store i32 %1, i32* %save_errno, align 4, !tbaa !5
  %2 = load i32, i32* %save_errno, align 4, !tbaa !5
  %call1 = call i32* @__errno_location() #11
  store i32 %2, i32* %call1, align 4, !tbaa !5
  br label %do.body

do.body:                                          ; preds = %entry
  %3 = load volatile i32, i32* @InCriticalSection, align 4, !tbaa !5
  %cmp = icmp ugt i32 %3, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %do.body
  %4 = load i32, i32* %sig.addr, align 4, !tbaa !5
  %cmp2 = icmp ne i32 %4, 0
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %5 = load i32, i32* %sig.addr, align 4, !tbaa !5
  call void @pend_signal(i32 %5)
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end:                                           ; preds = %land.lhs.true, %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store volatile i32 1, i32* @NoMoreRunners, align 4, !tbaa !5
  %6 = load void (i32)*, void (i32)** @Oldsh_hup, align 8, !tbaa !1
  store volatile void (i32)* %6, void (i32)** @Oldsh, align 8, !tbaa !1
  %7 = load i32, i32* %sig.addr, align 4, !tbaa !5
  store volatile i32 %7, i32* @Oldsig, align 4, !tbaa !5
  %8 = load i32, i32* %sig.addr, align 4, !tbaa !5
  call void @proc_list_signal(i32 3, i32 %8)
  %9 = load i32, i32* @BlockOldsh, align 4, !tbaa !5
  %tobool = icmp ne i32 %9, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then.5

lor.lhs.false:                                    ; preds = %do.end
  %call3 = call i32 @getppid() #1
  %cmp4 = icmp sle i32 %call3, 1
  br i1 %cmp4, label %if.then.5, label %if.end.13

if.then.5:                                        ; preds = %lor.lhs.false, %do.end
  %10 = load void (i32)*, void (i32)** @Oldsh_hup, align 8, !tbaa !1
  %cmp6 = icmp ne void (i32)* %10, null
  br i1 %cmp6, label %land.lhs.true.7, label %if.end.12

land.lhs.true.7:                                  ; preds = %if.then.5
  %11 = load void (i32)*, void (i32)** @Oldsh_hup, align 8, !tbaa !1
  %cmp8 = icmp ne void (i32)* %11, inttoptr (i64 1 to void (i32)*)
  br i1 %cmp8, label %land.lhs.true.9, label %if.end.12

land.lhs.true.9:                                  ; preds = %land.lhs.true.7
  %12 = load void (i32)*, void (i32)** @Oldsh_hup, align 8, !tbaa !1
  %cmp10 = icmp ne void (i32)* %12, @runners_sighup
  br i1 %cmp10, label %if.then.11, label %if.end.12

if.then.11:                                       ; preds = %land.lhs.true.9
  %13 = load void (i32)*, void (i32)** @Oldsh_hup, align 8, !tbaa !1
  %14 = load i32, i32* %sig.addr, align 4, !tbaa !5
  call void %13(i32 %14)
  br label %if.end.12

if.end.12:                                        ; preds = %if.then.11, %land.lhs.true.9, %land.lhs.true.7, %if.then.5
  br label %if.end.13

if.end.13:                                        ; preds = %if.end.12, %lor.lhs.false
  %15 = load i32, i32* %save_errno, align 4, !tbaa !5
  %call14 = call i32* @__errno_location() #11
  store i32 %15, i32* %call14, align 4, !tbaa !5
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

cleanup:                                          ; preds = %if.end.13, %if.then
  %16 = bitcast i32* %save_errno to i8*
  call void @llvm.lifetime.end(i64 4, i8* %16) #1
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @run_work_group(i32 %wgrp, i32 %flags) #0 {
entry:
  %retval = alloca i32, align 4
  %wgrp.addr = alloca i32, align 4
  %flags.addr = alloca i32, align 4
  %e = alloca %struct.envelope*, align 8
  %njobs = alloca i32, align 4
  %qdir = alloca i32, align 4
  %sequenceno = alloca i32, align 4
  %qgrp = alloca i32, align 4
  %endgrp = alloca i32, align 4
  %h = alloca i32, align 4
  %i = alloca i32, align 4
  %now = alloca i64, align 8
  %full = alloca i32, align 4
  %more = alloca i32, align 4
  %rpool = alloca %struct.SM_RPOOL_T*, align 8
  %cleanup.dest.slot = alloca i32
  %msg = alloca i8*, align 8
  %msg27 = alloca i8*, align 8
  %pid = alloca i32, align 4
  %msg44 = alloca i8*, align 8
  %err = alloca i8*, align 8
  %loop = alloca i32, align 4
  %maxrunners = alloca i32, align 4
  %pid209 = alloca i32, align 4
  %status = alloca i32, align 4
  %ret = alloca i32, align 4
  %out = alloca %struct.sm_file*, align 8
  store i32 %wgrp, i32* %wgrp.addr, align 4, !tbaa !5
  store i32 %flags, i32* %flags.addr, align 4, !tbaa !5
  %0 = bitcast %struct.envelope** %e to i8*
  call void @llvm.lifetime.start(i64 8, i8* %0) #1
  %1 = bitcast i32* %njobs to i8*
  call void @llvm.lifetime.start(i64 4, i8* %1) #1
  %2 = bitcast i32* %qdir to i8*
  call void @llvm.lifetime.start(i64 4, i8* %2) #1
  %3 = bitcast i32* %sequenceno to i8*
  call void @llvm.lifetime.start(i64 4, i8* %3) #1
  store i32 1, i32* %sequenceno, align 4, !tbaa !5
  %4 = bitcast i32* %qgrp to i8*
  call void @llvm.lifetime.start(i64 4, i8* %4) #1
  %5 = bitcast i32* %endgrp to i8*
  call void @llvm.lifetime.start(i64 4, i8* %5) #1
  %6 = bitcast i32* %h to i8*
  call void @llvm.lifetime.start(i64 4, i8* %6) #1
  %7 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start(i64 4, i8* %7) #1
  %8 = bitcast i64* %now to i8*
  call void @llvm.lifetime.start(i64 8, i8* %8) #1
  %9 = bitcast i32* %full to i8*
  call void @llvm.lifetime.start(i64 4, i8* %9) #1
  %10 = bitcast i32* %more to i8*
  call void @llvm.lifetime.start(i64 4, i8* %10) #1
  %11 = bitcast %struct.SM_RPOOL_T** %rpool to i8*
  call void @llvm.lifetime.start(i64 8, i8* %11) #1
  %12 = load i32, i32* %wgrp.addr, align 4, !tbaa !5
  %cmp = icmp slt i32 %12, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup.394

if.end:                                           ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.end
  %call = call i64 @curtime()
  store i64 %call, i64* %now, align 8, !tbaa !92
  %13 = load i64, i64* @Current_LA_time, align 8, !tbaa !92
  %14 = load i64, i64* %now, align 8, !tbaa !92
  %sub = sub nsw i64 %14, 30
  %cmp1 = icmp slt i64 %13, %sub
  br i1 %cmp1, label %if.then.2, label %if.end.3

if.then.2:                                        ; preds = %do.body
  call void @sm_getla()
  %15 = load i64, i64* %now, align 8, !tbaa !92
  store i64 %15, i64* @Current_LA_time, align 8, !tbaa !92
  br label %if.end.3

if.end.3:                                         ; preds = %if.then.2, %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end.3
  br label %do.end

do.end:                                           ; preds = %do.cond
  %16 = load i32, i32* %flags.addr, align 4, !tbaa !5
  %and = and i32 %16, 4
  %cmp4 = icmp ne i32 %and, 0
  br i1 %cmp4, label %if.end.14, label %land.lhs.true

land.lhs.true:                                    ; preds = %do.end
  %17 = load i64, i64* @WkRecipFact, align 8, !tbaa !92
  %18 = load i64, i64* @Current_LA_time, align 8, !tbaa !92
  %call5 = call i32 @shouldqueue(i64 %17, i64 %18)
  %tobool = icmp ne i32 %call5, 0
  br i1 %tobool, label %if.then.6, label %if.end.14

if.then.6:                                        ; preds = %land.lhs.true
  %19 = bitcast i8** %msg to i8*
  call void @llvm.lifetime.start(i64 8, i8* %19) #1
  store i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.65, i32 0, i32 0), i8** %msg, align 8, !tbaa !1
  %20 = load i32, i32* %flags.addr, align 4, !tbaa !5
  %and7 = and i32 %20, 2
  %cmp8 = icmp ne i32 %and7, 0
  br i1 %cmp8, label %if.then.9, label %if.end.10

if.then.9:                                        ; preds = %if.then.6
  %21 = load i8*, i8** %msg, align 8, !tbaa !1
  call void (i8*, ...) @message(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.66, i32 0, i32 0), i8* %21)
  br label %if.end.10

if.end.10:                                        ; preds = %if.then.9, %if.then.6
  %22 = load i32, i32* @LogLevel, align 4, !tbaa !5
  %cmp11 = icmp sgt i32 %22, 8
  br i1 %cmp11, label %if.then.12, label %if.end.13

if.then.12:                                       ; preds = %if.end.10
  %23 = load i8*, i8** %msg, align 8, !tbaa !1
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 6, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.67, i32 0, i32 0), i8* %23)
  br label %if.end.13

if.end.13:                                        ; preds = %if.then.12, %if.end.10
  store i32 0, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  %24 = bitcast i8** %msg to i8*
  call void @llvm.lifetime.end(i64 8, i8* %24) #1
  br label %cleanup.394

if.end.14:                                        ; preds = %land.lhs.true, %do.end
  %25 = load i32, i32* %flags.addr, align 4, !tbaa !5
  %and15 = and i32 %25, 1
  %cmp16 = icmp ne i32 %and15, 0
  br i1 %cmp16, label %land.lhs.true.17, label %if.end.35

land.lhs.true.17:                                 ; preds = %if.end.14
  %26 = load i32, i32* %wgrp.addr, align 4, !tbaa !5
  %idxprom = sext i32 %26 to i64
  %arrayidx = getelementptr inbounds [51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 %idxprom
  %wg_lowqintvl = getelementptr inbounds %struct.workgrp, %struct.workgrp* %arrayidx, i32 0, i32 5
  %27 = load volatile i64, i64* %wg_lowqintvl, align 8, !tbaa !109
  %cmp18 = icmp sgt i64 %27, 0
  br i1 %cmp18, label %land.lhs.true.19, label %if.end.35

land.lhs.true.19:                                 ; preds = %land.lhs.true.17
  %28 = load i32, i32* %flags.addr, align 4, !tbaa !5
  %and20 = and i32 %28, 4
  %cmp21 = icmp ne i32 %and20, 0
  br i1 %cmp21, label %if.end.35, label %land.lhs.true.22

land.lhs.true.22:                                 ; preds = %land.lhs.true.19
  %29 = load i32, i32* @MaxChildren, align 4, !tbaa !5
  %cmp23 = icmp sgt i32 %29, 0
  br i1 %cmp23, label %land.lhs.true.24, label %if.end.35

land.lhs.true.24:                                 ; preds = %land.lhs.true.22
  %30 = load volatile i32, i32* @CurChildren, align 4, !tbaa !5
  %31 = load i32, i32* @MaxChildren, align 4, !tbaa !5
  %cmp25 = icmp sge i32 %30, %31
  br i1 %cmp25, label %if.then.26, label %if.end.35

if.then.26:                                       ; preds = %land.lhs.true.24
  %32 = bitcast i8** %msg27 to i8*
  call void @llvm.lifetime.start(i64 8, i8* %32) #1
  store i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.68, i32 0, i32 0), i8** %msg27, align 8, !tbaa !1
  %33 = load i32, i32* %flags.addr, align 4, !tbaa !5
  %and28 = and i32 %33, 2
  %cmp29 = icmp ne i32 %and28, 0
  br i1 %cmp29, label %if.then.30, label %if.end.31

if.then.30:                                       ; preds = %if.then.26
  %34 = load i8*, i8** %msg27, align 8, !tbaa !1
  %35 = load volatile i32, i32* @CurChildren, align 4, !tbaa !5
  call void (i8*, ...) @message(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.69, i32 0, i32 0), i8* %34, i32 %35)
  br label %if.end.31

if.end.31:                                        ; preds = %if.then.30, %if.then.26
  %36 = load i32, i32* @LogLevel, align 4, !tbaa !5
  %cmp32 = icmp sgt i32 %36, 8
  br i1 %cmp32, label %if.then.33, label %if.end.34

if.then.33:                                       ; preds = %if.end.31
  %37 = load i8*, i8** %msg27, align 8, !tbaa !1
  %38 = load volatile i32, i32* @CurChildren, align 4, !tbaa !5
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 6, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0), i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.70, i32 0, i32 0), i8* %37, i32 %38)
  br label %if.end.34

if.end.34:                                        ; preds = %if.then.33, %if.end.31
  store i32 0, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  %39 = bitcast i8** %msg27 to i8*
  call void @llvm.lifetime.end(i64 8, i8* %39) #1
  br label %cleanup.394

if.end.35:                                        ; preds = %land.lhs.true.24, %land.lhs.true.22, %land.lhs.true.19, %land.lhs.true.17, %if.end.14
  %40 = load i32, i32* %flags.addr, align 4, !tbaa !5
  %and36 = and i32 %40, 1
  %cmp37 = icmp ne i32 %and36, 0
  br i1 %cmp37, label %if.then.38, label %if.end.71

if.then.38:                                       ; preds = %if.end.35
  %41 = bitcast i32* %pid to i8*
  call void @llvm.lifetime.start(i64 4, i8* %41) #1
  %call39 = call i32 @sm_blocksignal(i32 17)
  %call40 = call void (i32)* @sm_signal(i32 17, void (i32)* @reapchild)
  %call41 = call i32 @dofork()
  store i32 %call41, i32* %pid, align 4, !tbaa !5
  %42 = load i32, i32* %pid, align 4, !tbaa !5
  %cmp42 = icmp eq i32 %42, -1
  br i1 %cmp42, label %if.then.43, label %if.end.55

if.then.43:                                       ; preds = %if.then.38
  %43 = bitcast i8** %msg44 to i8*
  call void @llvm.lifetime.start(i64 8, i8* %43) #1
  store i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.71, i32 0, i32 0), i8** %msg44, align 8, !tbaa !1
  %44 = bitcast i8** %err to i8*
  call void @llvm.lifetime.start(i64 8, i8* %44) #1
  %call45 = call i32* @__errno_location() #11
  %45 = load i32, i32* %call45, align 4, !tbaa !5
  %call46 = call i8* @sm_errstring(i32 %45)
  store i8* %call46, i8** %err, align 8, !tbaa !1
  %46 = load i32, i32* %flags.addr, align 4, !tbaa !5
  %and47 = and i32 %46, 2
  %cmp48 = icmp ne i32 %and47, 0
  br i1 %cmp48, label %if.then.49, label %if.end.50

if.then.49:                                       ; preds = %if.then.43
  %47 = load i8*, i8** %msg44, align 8, !tbaa !1
  %48 = load i8*, i8** %err, align 8, !tbaa !1
  call void (i8*, ...) @message(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.72, i32 0, i32 0), i8* %47, i8* %48)
  br label %if.end.50

if.end.50:                                        ; preds = %if.then.49, %if.then.43
  %49 = load i32, i32* @LogLevel, align 4, !tbaa !5
  %cmp51 = icmp sgt i32 %49, 8
  br i1 %cmp51, label %if.then.52, label %if.end.53

if.then.52:                                       ; preds = %if.end.50
  %50 = load i8*, i8** %msg44, align 8, !tbaa !1
  %51 = load i8*, i8** %err, align 8, !tbaa !1
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 6, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.73, i32 0, i32 0), i8* %50, i8* %51)
  br label %if.end.53

if.end.53:                                        ; preds = %if.then.52, %if.end.50
  %call54 = call i32 @sm_releasesignal(i32 17)
  store i32 0, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  %52 = bitcast i8** %err to i8*
  call void @llvm.lifetime.end(i64 8, i8* %52) #1
  %53 = bitcast i8** %msg44 to i8*
  call void @llvm.lifetime.end(i64 8, i8* %53) #1
  br label %cleanup

if.end.55:                                        ; preds = %if.then.38
  %54 = load i32, i32* %pid, align 4, !tbaa !5
  %cmp56 = icmp ne i32 %54, 0
  br i1 %cmp56, label %if.then.57, label %if.end.65

if.then.57:                                       ; preds = %if.end.55
  %call58 = call i32 @sm_blocksignal(i32 14)
  %55 = load i32, i32* %pid, align 4, !tbaa !5
  %56 = load i32, i32* %wgrp.addr, align 4, !tbaa !5
  %idxprom59 = sext i32 %56 to i64
  %arrayidx60 = getelementptr inbounds [51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 %idxprom59
  %wg_maxact = getelementptr inbounds %struct.workgrp, %struct.workgrp* %arrayidx60, i32 0, i32 4
  %57 = load volatile i32, i32* %wg_maxact, align 4, !tbaa !108
  %58 = load i32, i32* %flags.addr, align 4, !tbaa !5
  %and61 = and i32 %58, 4
  %cmp62 = icmp ne i32 %and61, 0
  br i1 %cmp62, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.57
  %59 = load i32, i32* %wgrp.addr, align 4, !tbaa !5
  br label %cond.end

cond.false:                                       ; preds = %if.then.57
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %59, %cond.true ], [ -1, %cond.false ]
  call void @proc_list_add(i32 %55, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.74, i32 0, i32 0), i32 3, i32 %57, i32 %cond, %union.bigsockaddr* null)
  %call63 = call i32 @sm_releasesignal(i32 14)
  %call64 = call i32 @sm_releasesignal(i32 17)
  store i32 1, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.65:                                        ; preds = %if.end.55
  store volatile i8* null, i8** @RestartRequest, align 8, !tbaa !1
  store volatile i32 0, i32* @RestartWorkGroup, align 4, !tbaa !5
  store volatile i8* null, i8** @ShutdownRequest, align 8, !tbaa !1
  store volatile i32 0, i32* @PendingSignal, align 4, !tbaa !5
  %call66 = call i32 @getpid() #1
  store i32 %call66, i32* @CurrentPid, align 4, !tbaa !5
  call void @close_sendmail_pid()
  call void @sm_exc_newthread(void (%struct.sm_exc*)* @fatal_error)
  call void @clrcontrol()
  call void @proc_list_clear()
  %60 = load i32, i32* @CurrentPid, align 4, !tbaa !5
  call void @proc_list_add(i32 %60, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.75, i32 0, i32 0), i32 3, i32 0, i32 -1, %union.bigsockaddr* null)
  %call67 = call i32 @sm_releasesignal(i32 17)
  %call68 = call void (i32)* @sm_signal(i32 17, void (i32)* null)
  %call69 = call void (i32)* @sm_signal(i32 1, void (i32)* null)
  %call70 = call void (i32)* @sm_signal(i32 15, void (i32)* @intsig)
  store i32 0, i32* %cleanup.dest.slot
  br label %cleanup

cleanup:                                          ; preds = %if.end.65, %cond.end, %if.end.53
  %61 = bitcast i32* %pid to i8*
  call void @llvm.lifetime.end(i64 4, i8* %61) #1
  %cleanup.dest = load i32, i32* %cleanup.dest.slot
  switch i32 %cleanup.dest, label %cleanup.394 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %if.end.71

if.end.71:                                        ; preds = %cleanup.cont, %if.end.35
  call void @clrdaemon()
  store i32 0, i32* @NoConnect, align 4, !tbaa !5
  %call72 = call i32 @geteuid() #1
  %cmp73 = icmp eq i32 %call72, 0
  br i1 %cmp73, label %if.then.74, label %if.end.76

if.then.74:                                       ; preds = %if.end.71
  %call75 = call i32 @drop_privileges(i32 0)
  br label %if.end.76

if.end.76:                                        ; preds = %if.then.74, %if.end.71
  store %struct.envelope* @QueueEnvelope, %struct.envelope** @CurEnv, align 8, !tbaa !1
  %call77 = call %struct.SM_RPOOL_T* @sm_rpool_new_x(%struct.SM_RPOOL_T* null)
  store %struct.SM_RPOOL_T* %call77, %struct.SM_RPOOL_T** %rpool, align 8, !tbaa !1
  %62 = load %struct.envelope*, %struct.envelope** @CurEnv, align 8, !tbaa !1
  %63 = load %struct.SM_RPOOL_T*, %struct.SM_RPOOL_T** %rpool, align 8, !tbaa !1
  %call78 = call %struct.envelope* @newenvelope(%struct.envelope* @QueueEnvelope, %struct.envelope* %62, %struct.SM_RPOOL_T* %63)
  store %struct.envelope* %call78, %struct.envelope** %e, align 8, !tbaa !1
  %64 = load i64, i64* getelementptr inbounds (%struct.envelope, %struct.envelope* @BlankEnvelope, i32 0, i32 11), align 8, !tbaa !15
  %65 = load %struct.envelope*, %struct.envelope** %e, align 8, !tbaa !1
  %e_flags = getelementptr inbounds %struct.envelope, %struct.envelope* %65, i32 0, i32 11
  store i64 %64, i64* %e_flags, align 8, !tbaa !15
  %66 = load %struct.envelope*, %struct.envelope** %e, align 8, !tbaa !1
  %e_parent = getelementptr inbounds %struct.envelope, %struct.envelope* %66, i32 0, i32 21
  store %struct.envelope* null, %struct.envelope** %e_parent, align 8, !tbaa !110
  %67 = load i32, i32* %flags.addr, align 4, !tbaa !5
  %and79 = and i32 %67, 1
  %cmp80 = icmp ne i32 %and79, 0
  br i1 %cmp80, label %if.then.81, label %if.end.82

if.then.81:                                       ; preds = %if.end.76
  %68 = load %struct.envelope*, %struct.envelope** %e, align 8, !tbaa !1
  call void @disconnect(i32 1, %struct.envelope* %68)
  store i32 0, i32* @QuickAbort, align 4, !tbaa !5
  br label %if.end.82

if.end.82:                                        ; preds = %if.then.81, %if.end.76
  %69 = load %struct.queue_char*, %struct.queue_char** @QueueLimitId, align 8, !tbaa !1
  %cmp83 = icmp ne %struct.queue_char* %69, null
  br i1 %cmp83, label %if.then.89, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end.82
  %70 = load %struct.queue_char*, %struct.queue_char** @QueueLimitSender, align 8, !tbaa !1
  %cmp84 = icmp ne %struct.queue_char* %70, null
  br i1 %cmp84, label %if.then.89, label %lor.lhs.false.85

lor.lhs.false.85:                                 ; preds = %lor.lhs.false
  %71 = load %struct.queue_char*, %struct.queue_char** @QueueLimitQuarantine, align 8, !tbaa !1
  %cmp86 = icmp ne %struct.queue_char* %71, null
  br i1 %cmp86, label %if.then.89, label %lor.lhs.false.87

lor.lhs.false.87:                                 ; preds = %lor.lhs.false.85
  %72 = load %struct.queue_char*, %struct.queue_char** @QueueLimitRecipient, align 8, !tbaa !1
  %cmp88 = icmp ne %struct.queue_char* %72, null
  br i1 %cmp88, label %if.then.89, label %if.end.90

if.then.89:                                       ; preds = %lor.lhs.false.87, %lor.lhs.false.85, %lor.lhs.false, %if.end.82
  store i32 1, i32* @IgnoreHostStatus, align 4, !tbaa !5
  store i64 0, i64* @MinQueueAge, align 8, !tbaa !92
  store i64 0, i64* @MaxQueueAge, align 8, !tbaa !92
  br label %if.end.90

if.end.90:                                        ; preds = %if.then.89, %lor.lhs.false.87
  %73 = load i32, i32* %wgrp.addr, align 4, !tbaa !5
  %idxprom91 = sext i32 %73 to i64
  %arrayidx92 = getelementptr inbounds [51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 %idxprom91
  %wg_curqgrp = getelementptr inbounds %struct.workgrp, %struct.workgrp* %arrayidx92, i32 0, i32 2
  %74 = load volatile i32, i32* %wg_curqgrp, align 4, !tbaa !111
  store i32 %74, i32* %endgrp, align 4, !tbaa !5
  br label %domorework

domorework:                                       ; preds = %if.end.383, %if.then.293, %if.end.90
  %call93 = call i64 @curtime()
  store i64 %call93, i64* %now, align 8, !tbaa !92
  br label %for.cond

for.cond:                                         ; preds = %if.end.136, %domorework
  %75 = load i32, i32* %wgrp.addr, align 4, !tbaa !5
  %idxprom94 = sext i32 %75 to i64
  %arrayidx95 = getelementptr inbounds [51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 %idxprom94
  %wg_curqgrp96 = getelementptr inbounds %struct.workgrp, %struct.workgrp* %arrayidx95, i32 0, i32 2
  %76 = load volatile i32, i32* %wg_curqgrp96, align 4, !tbaa !111
  %idxprom97 = sext i32 %76 to i64
  %77 = load i32, i32* %wgrp.addr, align 4, !tbaa !5
  %idxprom98 = sext i32 %77 to i64
  %arrayidx99 = getelementptr inbounds [51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 %idxprom98
  %wg_qgs = getelementptr inbounds %struct.workgrp, %struct.workgrp* %arrayidx99, i32 0, i32 3
  %78 = load volatile %struct.queuegrp**, %struct.queuegrp*** %wg_qgs, align 8, !tbaa !106
  %arrayidx100 = getelementptr inbounds %struct.queuegrp*, %struct.queuegrp** %78, i64 %idxprom97
  %79 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx100, align 8, !tbaa !1
  %qg_index = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %79, i32 0, i32 2
  %80 = load i16, i16* %qg_index, align 2, !tbaa !112
  %conv = sext i16 %80 to i32
  store i32 %conv, i32* %qgrp, align 4, !tbaa !5
  %81 = load i32, i32* %wgrp.addr, align 4, !tbaa !5
  %idxprom101 = sext i32 %81 to i64
  %arrayidx102 = getelementptr inbounds [51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 %idxprom101
  %wg_curqgrp103 = getelementptr inbounds %struct.workgrp, %struct.workgrp* %arrayidx102, i32 0, i32 2
  %82 = load volatile i32, i32* %wg_curqgrp103, align 4, !tbaa !111
  %inc = add nsw i32 %82, 1
  store volatile i32 %inc, i32* %wg_curqgrp103, align 4, !tbaa !111
  %83 = load i32, i32* %wgrp.addr, align 4, !tbaa !5
  %idxprom104 = sext i32 %83 to i64
  %arrayidx105 = getelementptr inbounds [51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 %idxprom104
  %wg_numqgrp = getelementptr inbounds %struct.workgrp, %struct.workgrp* %arrayidx105, i32 0, i32 0
  %84 = load volatile i32, i32* %wg_numqgrp, align 4, !tbaa !107
  %85 = load i32, i32* %wgrp.addr, align 4, !tbaa !5
  %idxprom106 = sext i32 %85 to i64
  %arrayidx107 = getelementptr inbounds [51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 %idxprom106
  %wg_curqgrp108 = getelementptr inbounds %struct.workgrp, %struct.workgrp* %arrayidx107, i32 0, i32 2
  %86 = load volatile i32, i32* %wg_curqgrp108, align 4, !tbaa !111
  %rem = srem i32 %86, %84
  store volatile i32 %rem, i32* %wg_curqgrp108, align 4, !tbaa !111
  %87 = load i32, i32* %flags.addr, align 4, !tbaa !5
  %and109 = and i32 %87, 16
  %cmp110 = icmp ne i32 %and109, 0
  br i1 %cmp110, label %if.then.123, label %lor.lhs.false.112

lor.lhs.false.112:                                ; preds = %for.cond
  %88 = load i32, i32* %qgrp, align 4, !tbaa !5
  %idxprom113 = sext i32 %88 to i64
  %arrayidx114 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom113
  %89 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx114, align 8, !tbaa !1
  %qg_nextrun = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %89, i32 0, i32 13
  %90 = load i64, i64* %qg_nextrun, align 8, !tbaa !113
  %91 = load i64, i64* %now, align 8, !tbaa !92
  %cmp115 = icmp sle i64 %90, %91
  br i1 %cmp115, label %land.lhs.true.117, label %if.end.124

land.lhs.true.117:                                ; preds = %lor.lhs.false.112
  %92 = load i32, i32* %qgrp, align 4, !tbaa !5
  %idxprom118 = sext i32 %92 to i64
  %arrayidx119 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom118
  %93 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx119, align 8, !tbaa !1
  %qg_nextrun120 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %93, i32 0, i32 13
  %94 = load i64, i64* %qg_nextrun120, align 8, !tbaa !113
  %cmp121 = icmp ne i64 %94, -1
  br i1 %cmp121, label %if.then.123, label %if.end.124

if.then.123:                                      ; preds = %land.lhs.true.117, %for.cond
  br label %for.end

if.end.124:                                       ; preds = %land.lhs.true.117, %lor.lhs.false.112
  %95 = load i32, i32* %endgrp, align 4, !tbaa !5
  %96 = load i32, i32* %wgrp.addr, align 4, !tbaa !5
  %idxprom125 = sext i32 %96 to i64
  %arrayidx126 = getelementptr inbounds [51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 %idxprom125
  %wg_curqgrp127 = getelementptr inbounds %struct.workgrp, %struct.workgrp* %arrayidx126, i32 0, i32 2
  %97 = load volatile i32, i32* %wg_curqgrp127, align 4, !tbaa !111
  %cmp128 = icmp eq i32 %95, %97
  br i1 %cmp128, label %if.then.130, label %if.end.136

if.then.130:                                      ; preds = %if.end.124
  %98 = load %struct.envelope*, %struct.envelope** %e, align 8, !tbaa !1
  %e_id = getelementptr inbounds %struct.envelope, %struct.envelope* %98, i32 0, i32 25
  store i8* null, i8** %e_id, align 8, !tbaa !7
  %99 = load i32, i32* %flags.addr, align 4, !tbaa !5
  %and131 = and i32 %99, 1
  %cmp132 = icmp ne i32 %and131, 0
  br i1 %cmp132, label %if.then.134, label %if.end.135

if.then.134:                                      ; preds = %if.then.130
  %100 = load i32, i32* @ExitStat, align 4, !tbaa !5
  call void @finis(i32 1, i32 1, i32 %100)
  br label %if.end.135

if.end.135:                                       ; preds = %if.then.134, %if.then.130
  store i32 1, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup.394

if.end.136:                                       ; preds = %if.end.124
  br label %for.cond

for.end:                                          ; preds = %if.then.123
  %101 = load i32, i32* %qgrp, align 4, !tbaa !5
  %idxprom137 = sext i32 %101 to i64
  %arrayidx138 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom137
  %102 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx138, align 8, !tbaa !1
  %qg_curnum = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %102, i32 0, i32 11
  %103 = load i32, i32* %qg_curnum, align 4, !tbaa !114
  store i32 %103, i32* %qdir, align 4, !tbaa !5
  %104 = load i32, i32* %qgrp, align 4, !tbaa !5
  %idxprom139 = sext i32 %104 to i64
  %arrayidx140 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom139
  %105 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx140, align 8, !tbaa !1
  %qg_nice = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %105, i32 0, i32 8
  %106 = load i16, i16* %qg_nice, align 2, !tbaa !115
  %conv141 = sext i16 %106 to i32
  %cmp142 = icmp sgt i32 %conv141, 0
  br i1 %cmp142, label %if.then.144, label %if.end.150

if.then.144:                                      ; preds = %for.end
  %107 = load i32, i32* %qgrp, align 4, !tbaa !5
  %idxprom145 = sext i32 %107 to i64
  %arrayidx146 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom145
  %108 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx146, align 8, !tbaa !1
  %qg_nice147 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %108, i32 0, i32 8
  %109 = load i16, i16* %qg_nice147, align 2, !tbaa !115
  %conv148 = sext i16 %109 to i32
  %call149 = call i32 @nice(i32 %conv148) #1
  br label %if.end.150

if.end.150:                                       ; preds = %if.then.144, %for.end
  %110 = load %struct.envelope*, %struct.envelope** @CurEnv, align 8, !tbaa !1
  %111 = load i32, i32* %qgrp, align 4, !tbaa !5
  %112 = load i32, i32* %qdir, align 4, !tbaa !5
  %call151 = call i8* @qid_printqueue(i32 %111, i32 %112)
  call void (i32, %struct.envelope*, i8*, ...) @sm_setproctitle(i32 1, %struct.envelope* %110, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.76, i32 0, i32 0), i8* %call151)
  %113 = load i32, i32* @LogLevel, align 4, !tbaa !5
  %cmp152 = icmp sgt i32 %113, 69
  br i1 %cmp152, label %if.then.160, label %lor.lhs.false.154

lor.lhs.false.154:                                ; preds = %if.end.150
  %114 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 63), align 1, !tbaa !17
  %conv155 = zext i8 %114 to i32
  %cmp156 = icmp sge i32 %conv155, 99
  br i1 %cmp156, label %land.lhs.true.158, label %if.end.165

land.lhs.true.158:                                ; preds = %lor.lhs.false.154
  %115 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool159 = icmp ne i32 %115, 0
  br i1 %tobool159, label %if.end.165, label %if.then.160

if.then.160:                                      ; preds = %land.lhs.true.158, %if.end.150
  %116 = load i32, i32* %qgrp, align 4, !tbaa !5
  %117 = load i32, i32* %qdir, align 4, !tbaa !5
  %call161 = call i8* @qid_printqueue(i32 %116, i32 %117)
  %118 = load i32, i32* @CurrentPid, align 4, !tbaa !5
  %119 = load i32, i32* %flags.addr, align 4, !tbaa !5
  %and162 = and i32 %119, 1
  %cmp163 = icmp ne i32 %and162, 0
  %conv164 = zext i1 %cmp163 to i32
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 7, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0), i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.77, i32 0, i32 0), i8* %call161, i32 %118, i32 %conv164)
  br label %if.end.165

if.end.165:                                       ; preds = %if.then.160, %land.lhs.true.158, %lor.lhs.false.154
  store i32 0, i32* %i, align 4, !tbaa !5
  br label %for.cond.166

for.cond.166:                                     ; preds = %for.inc, %if.end.165
  %120 = load i32, i32* %i, align 4, !tbaa !5
  %121 = load i32, i32* %qgrp, align 4, !tbaa !5
  %idxprom167 = sext i32 %121 to i64
  %arrayidx168 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom167
  %122 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx168, align 8, !tbaa !1
  %qg_numqueues = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %122, i32 0, i32 4
  %123 = load i32, i32* %qg_numqueues, align 4, !tbaa !82
  %cmp169 = icmp slt i32 %120, %123
  br i1 %cmp169, label %for.body, label %for.end.194

for.body:                                         ; preds = %for.cond.166
  %124 = load i32, i32* %qgrp, align 4, !tbaa !5
  %125 = load i32, i32* %qdir, align 4, !tbaa !5
  %call171 = call i32 @gatherq(i32 %124, i32 %125, i32 0, i32* %full, i32* %more, i32* %h)
  %126 = load i32, i32* @ShmId, align 4, !tbaa !5
  %cmp172 = icmp ne i32 %126, -2
  br i1 %cmp172, label %if.then.174, label %if.end.181

if.then.174:                                      ; preds = %for.body
  %127 = load i32, i32* %h, align 4, !tbaa !5
  %128 = load i32, i32* %qdir, align 4, !tbaa !5
  %idxprom175 = sext i32 %128 to i64
  %129 = load i32, i32* %qgrp, align 4, !tbaa !5
  %idxprom176 = sext i32 %129 to i64
  %arrayidx177 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom176
  %130 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx177, align 8, !tbaa !1
  %qg_qpaths = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %130, i32 0, i32 6
  %131 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths, align 8, !tbaa !38
  %arrayidx178 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %131, i64 %idxprom175
  %qp_idx = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %arrayidx178, i32 0, i32 3
  %132 = load i32, i32* %qp_idx, align 4, !tbaa !84
  %idxprom179 = sext i32 %132 to i64
  %133 = load %struct.queue_shared*, %struct.queue_shared** @QShm, align 8, !tbaa !1
  %arrayidx180 = getelementptr inbounds %struct.queue_shared, %struct.queue_shared* %133, i64 %idxprom179
  %qs_entries = getelementptr inbounds %struct.queue_shared, %struct.queue_shared* %arrayidx180, i32 0, i32 0
  store i32 %127, i32* %qs_entries, align 4, !tbaa !85
  br label %if.end.181

if.end.181:                                       ; preds = %if.then.174, %for.body
  %134 = load i32, i32* %more, align 4, !tbaa !5
  %tobool182 = icmp ne i32 %134, 0
  br i1 %tobool182, label %if.end.189, label %if.then.183

if.then.183:                                      ; preds = %if.end.181
  %135 = load i32, i32* %qdir, align 4, !tbaa !5
  %inc184 = add nsw i32 %135, 1
  store i32 %inc184, i32* %qdir, align 4, !tbaa !5
  %136 = load i32, i32* %qgrp, align 4, !tbaa !5
  %idxprom185 = sext i32 %136 to i64
  %arrayidx186 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom185
  %137 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx186, align 8, !tbaa !1
  %qg_numqueues187 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %137, i32 0, i32 4
  %138 = load i32, i32* %qg_numqueues187, align 4, !tbaa !82
  %139 = load i32, i32* %qdir, align 4, !tbaa !5
  %rem188 = srem i32 %139, %138
  store i32 %rem188, i32* %qdir, align 4, !tbaa !5
  br label %if.end.189

if.end.189:                                       ; preds = %if.then.183, %if.end.181
  %140 = load i32, i32* %full, align 4, !tbaa !5
  %tobool190 = icmp ne i32 %140, 0
  br i1 %tobool190, label %if.then.191, label %if.end.192

if.then.191:                                      ; preds = %if.end.189
  br label %for.end.194

if.end.192:                                       ; preds = %if.end.189
  br label %for.inc

for.inc:                                          ; preds = %if.end.192
  %141 = load i32, i32* %i, align 4, !tbaa !5
  %inc193 = add nsw i32 %141, 1
  store i32 %inc193, i32* %i, align 4, !tbaa !5
  br label %for.cond.166

for.end.194:                                      ; preds = %if.then.191, %for.cond.166
  %142 = load i32, i32* %qgrp, align 4, !tbaa !5
  %idxprom195 = sext i32 %142 to i64
  %arrayidx196 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom195
  %143 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx196, align 8, !tbaa !1
  %qg_maxlist = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %143, i32 0, i32 10
  %144 = load i32, i32* %qg_maxlist, align 4, !tbaa !116
  %call197 = call i32 @sortq(i32 %144)
  store i32 %call197, i32* %njobs, align 4, !tbaa !5
  %145 = load i32, i32* %qdir, align 4, !tbaa !5
  %146 = load i32, i32* %qgrp, align 4, !tbaa !5
  %idxprom198 = sext i32 %146 to i64
  %arrayidx199 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom198
  %147 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx199, align 8, !tbaa !1
  %qg_curnum200 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %147, i32 0, i32 11
  store i32 %145, i32* %qg_curnum200, align 4, !tbaa !114
  %148 = load i32, i32* @Verbose, align 4, !tbaa !5
  %tobool201 = icmp ne i32 %148, 0
  br i1 %tobool201, label %if.else.275, label %land.lhs.true.202

land.lhs.true.202:                                ; preds = %for.end.194
  %149 = load i32, i32* %qgrp, align 4, !tbaa !5
  %idxprom203 = sext i32 %149 to i64
  %arrayidx204 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom203
  %150 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx204, align 8, !tbaa !1
  %qg_flags = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %150, i32 0, i32 7
  %arrayidx205 = getelementptr inbounds [8 x i32], [8 x i32]* %qg_flags, i32 0, i64 3
  %151 = load i32, i32* %arrayidx205, align 4, !tbaa !5
  %and206 = and i32 %151, 64
  %tobool207 = icmp ne i32 %and206, 0
  br i1 %tobool207, label %if.then.208, label %if.else.275

if.then.208:                                      ; preds = %land.lhs.true.202
  %152 = bitcast i32* %loop to i8*
  call void @llvm.lifetime.start(i64 4, i8* %152) #1
  %153 = bitcast i32* %maxrunners to i8*
  call void @llvm.lifetime.start(i64 4, i8* %153) #1
  %154 = bitcast i32* %pid209 to i8*
  call void @llvm.lifetime.start(i64 4, i8* %154) #1
  %155 = load i32, i32* %qgrp, align 4, !tbaa !5
  %idxprom210 = sext i32 %155 to i64
  %arrayidx211 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom210
  %156 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx211, align 8, !tbaa !1
  %qg_maxqrun = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %156, i32 0, i32 3
  %157 = load i32, i32* %qg_maxqrun, align 4, !tbaa !117
  store i32 %157, i32* %maxrunners, align 4, !tbaa !5
  %158 = load i32, i32* %maxrunners, align 4, !tbaa !5
  %cmp212 = icmp eq i32 %158, 0
  br i1 %cmp212, label %land.lhs.true.214, label %if.end.219

land.lhs.true.214:                                ; preds = %if.then.208
  %159 = load i32, i32* %flags.addr, align 4, !tbaa !5
  %and215 = and i32 %159, 8
  %cmp216 = icmp ne i32 %and215, 0
  br i1 %cmp216, label %if.then.218, label %if.end.219

if.then.218:                                      ; preds = %land.lhs.true.214
  store i32 1, i32* %maxrunners, align 4, !tbaa !5
  br label %if.end.219

if.end.219:                                       ; preds = %if.then.218, %land.lhs.true.214, %if.then.208
  %160 = load i32, i32* %maxrunners, align 4, !tbaa !5
  %161 = load i32, i32* %njobs, align 4, !tbaa !5
  %cmp220 = icmp sgt i32 %160, %161
  br i1 %cmp220, label %if.then.222, label %if.end.223

if.then.222:                                      ; preds = %if.end.219
  %162 = load i32, i32* %njobs, align 4, !tbaa !5
  store i32 %162, i32* %maxrunners, align 4, !tbaa !5
  br label %if.end.223

if.end.223:                                       ; preds = %if.then.222, %if.end.219
  store i32 0, i32* %loop, align 4, !tbaa !5
  br label %for.cond.224

for.cond.224:                                     ; preds = %for.inc.258, %if.end.223
  %163 = load i32, i32* %loop, align 4, !tbaa !5
  %164 = load i32, i32* %maxrunners, align 4, !tbaa !5
  %cmp225 = icmp slt i32 %163, %164
  br i1 %cmp225, label %for.body.227, label %for.end.260

for.body.227:                                     ; preds = %for.cond.224
  call void @closemaps(i32 0)
  %call228 = call i32 @fork() #1
  store i32 %call228, i32* %pid209, align 4, !tbaa !5
  %165 = load i32, i32* %pid209, align 4, !tbaa !5
  %cmp229 = icmp slt i32 %165, 0
  br i1 %cmp229, label %if.then.231, label %if.else

if.then.231:                                      ; preds = %for.body.227
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.78, i32 0, i32 0))
  store i32 0, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup.270

if.else:                                          ; preds = %for.body.227
  %166 = load i32, i32* %pid209, align 4, !tbaa !5
  %cmp232 = icmp sgt i32 %166, 0
  br i1 %cmp232, label %if.then.234, label %if.else.240

if.then.234:                                      ; preds = %if.else
  call void @mci_flush(i32 0, %struct.mailer_con_info* null)
  %167 = load %struct.work*, %struct.work** @WorkQ, align 8, !tbaa !1
  %w_next = getelementptr inbounds %struct.work, %struct.work* %167, i32 0, i32 9
  %168 = load %struct.work*, %struct.work** %w_next, align 8, !tbaa !118
  store %struct.work* %168, %struct.work** @WorkQ, align 8, !tbaa !1
  %169 = load i32, i32* %sequenceno, align 4, !tbaa !5
  %inc235 = add nsw i32 %169, 1
  store i32 %inc235, i32* %sequenceno, align 4, !tbaa !5
  %170 = load i32, i32* %pid209, align 4, !tbaa !5
  call void @proc_list_add(i32 %170, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.79, i32 0, i32 0), i32 3, i32 0, i32 -1, %union.bigsockaddr* null)
  %171 = load %struct.work*, %struct.work** @WorkQ, align 8, !tbaa !1
  %cmp236 = icmp eq %struct.work* %171, null
  br i1 %cmp236, label %if.then.238, label %if.end.239

if.then.238:                                      ; preds = %if.then.234
  br label %for.end.260

if.end.239:                                       ; preds = %if.then.234
  br label %if.end.256

if.else.240:                                      ; preds = %if.else
  store volatile i8* null, i8** @RestartRequest, align 8, !tbaa !1
  store volatile i32 0, i32* @RestartWorkGroup, align 4, !tbaa !5
  store volatile i8* null, i8** @ShutdownRequest, align 8, !tbaa !1
  store volatile i32 0, i32* @PendingSignal, align 4, !tbaa !5
  %call241 = call i32 @getpid() #1
  store i32 %call241, i32* @CurrentPid, align 4, !tbaa !5
  call void @close_sendmail_pid()
  call void @sm_exc_newthread(void (%struct.sm_exc*)* @fatal_error)
  %172 = load i8, i8* @OpMode, align 1, !tbaa !17
  %conv242 = sext i8 %172 to i32
  %cmp243 = icmp eq i32 %conv242, 115
  br i1 %cmp243, label %if.then.252, label %lor.lhs.false.245

lor.lhs.false.245:                                ; preds = %if.else.240
  %173 = load i8, i8* @OpMode, align 1, !tbaa !17
  %conv246 = sext i8 %173 to i32
  %cmp247 = icmp eq i32 %conv246, 100
  br i1 %cmp247, label %if.then.252, label %lor.lhs.false.249

lor.lhs.false.249:                                ; preds = %lor.lhs.false.245
  %174 = load i32, i32* @MaxQueueChildren, align 4, !tbaa !5
  %cmp250 = icmp sgt i32 %174, 0
  br i1 %cmp250, label %if.then.252, label %if.end.255

if.then.252:                                      ; preds = %lor.lhs.false.249, %lor.lhs.false.245, %if.else.240
  call void @proc_list_clear()
  %call253 = call i32 @sm_releasesignal(i32 17)
  %call254 = call void (i32)* @sm_signal(i32 17, void (i32)* null)
  br label %if.end.255

if.end.255:                                       ; preds = %if.then.252, %lor.lhs.false.249
  store i32 0, i32* @OnlyOneError, align 4, !tbaa !5
  store i32 0, i32* @QuickAbort, align 4, !tbaa !5
  %175 = load %struct.envelope*, %struct.envelope** %e, align 8, !tbaa !1
  %176 = load i32, i32* %sequenceno, align 4, !tbaa !5
  %177 = load i32, i32* %maxrunners, align 4, !tbaa !5
  %178 = load i32, i32* %njobs, align 4, !tbaa !5
  call void @runner_work(%struct.envelope* %175, i32 %176, i32 1, i32 %177, i32 %178)
  %179 = load i32, i32* @ExitStat, align 4, !tbaa !5
  call void @finis(i32 1, i32 1, i32 %179)
  br label %if.end.256

if.end.256:                                       ; preds = %if.end.255, %if.end.239
  br label %if.end.257

if.end.257:                                       ; preds = %if.end.256
  br label %for.inc.258

for.inc.258:                                      ; preds = %if.end.257
  %180 = load i32, i32* %loop, align 4, !tbaa !5
  %inc259 = add nsw i32 %180, 1
  store i32 %inc259, i32* %loop, align 4, !tbaa !5
  br label %for.cond.224

for.end.260:                                      ; preds = %if.then.238, %for.cond.224
  %call261 = call i32 @sm_releasesignal(i32 17)
  br label %while.cond

while.cond:                                       ; preds = %while.end, %for.end.260
  %181 = load volatile i32, i32* @CurChildren, align 4, !tbaa !5
  %cmp262 = icmp sgt i32 %181, 0
  br i1 %cmp262, label %while.body, label %while.end.269

while.body:                                       ; preds = %while.cond
  %182 = bitcast i32* %status to i8*
  call void @llvm.lifetime.start(i64 4, i8* %182) #1
  %183 = bitcast i32* %ret to i8*
  call void @llvm.lifetime.start(i64 4, i8* %183) #1
  br label %while.cond.264

while.cond.264:                                   ; preds = %while.body.268, %while.body
  %call265 = call i32 @sm_wait(i32* %status)
  store i32 %call265, i32* %ret, align 4, !tbaa !5
  %cmp266 = icmp sle i32 %call265, 0
  br i1 %cmp266, label %while.body.268, label %while.end

while.body.268:                                   ; preds = %while.cond.264
  br label %while.cond.264

while.end:                                        ; preds = %while.cond.264
  %184 = load i32, i32* %ret, align 4, !tbaa !5
  %185 = load i32, i32* %status, align 4, !tbaa !5
  call void @proc_list_drop(i32 %184, i32 %185, i32* null)
  %186 = bitcast i32* %ret to i8*
  call void @llvm.lifetime.end(i64 4, i8* %186) #1
  %187 = bitcast i32* %status to i8*
  call void @llvm.lifetime.end(i64 4, i8* %187) #1
  br label %while.cond

while.end.269:                                    ; preds = %while.cond
  store i32 0, i32* %cleanup.dest.slot
  br label %cleanup.270

cleanup.270:                                      ; preds = %while.end.269, %if.then.231
  %188 = bitcast i32* %pid209 to i8*
  call void @llvm.lifetime.end(i64 4, i8* %188) #1
  %189 = bitcast i32* %maxrunners to i8*
  call void @llvm.lifetime.end(i64 4, i8* %189) #1
  %190 = bitcast i32* %loop to i8*
  call void @llvm.lifetime.end(i64 4, i8* %190) #1
  %cleanup.dest.273 = load i32, i32* %cleanup.dest.slot
  switch i32 %cleanup.dest.273, label %cleanup.394 [
    i32 0, label %cleanup.cont.274
  ]

cleanup.cont.274:                                 ; preds = %cleanup.270
  br label %if.end.287

if.else.275:                                      ; preds = %land.lhs.true.202, %for.end.194
  %191 = load i32, i32* %qgrp, align 4, !tbaa !5
  %idxprom276 = sext i32 %191 to i64
  %arrayidx277 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom276
  %192 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx277, align 8, !tbaa !1
  %qg_maxqrun278 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %192, i32 0, i32 3
  %193 = load i32, i32* %qg_maxqrun278, align 4, !tbaa !117
  %cmp279 = icmp sgt i32 %193, 0
  br i1 %cmp279, label %if.then.285, label %lor.lhs.false.281

lor.lhs.false.281:                                ; preds = %if.else.275
  %194 = load i32, i32* %flags.addr, align 4, !tbaa !5
  %and282 = and i32 %194, 8
  %cmp283 = icmp ne i32 %and282, 0
  br i1 %cmp283, label %if.then.285, label %if.end.286

if.then.285:                                      ; preds = %lor.lhs.false.281, %if.else.275
  %195 = load %struct.envelope*, %struct.envelope** %e, align 8, !tbaa !1
  %196 = load i32, i32* %sequenceno, align 4, !tbaa !5
  %197 = load i32, i32* %njobs, align 4, !tbaa !5
  call void @runner_work(%struct.envelope* %195, i32 %196, i32 0, i32 1, i32 %197)
  br label %if.end.286

if.end.286:                                       ; preds = %if.then.285, %lor.lhs.false.281
  br label %if.end.287

if.end.287:                                       ; preds = %if.end.286, %cleanup.cont.274
  %198 = load %struct.SM_RPOOL_T*, %struct.SM_RPOOL_T** %rpool, align 8, !tbaa !1
  call void @sm_rpool_free(%struct.SM_RPOOL_T* %198)
  store %struct.SM_RPOOL_T* null, %struct.SM_RPOOL_T** getelementptr inbounds (%struct.envelope, %struct.envelope* @QueueEnvelope, i32 0, i32 52), align 8, !tbaa !120
  %199 = load i32, i32* %endgrp, align 4, !tbaa !5
  %200 = load i32, i32* %wgrp.addr, align 4, !tbaa !5
  %idxprom288 = sext i32 %200 to i64
  %arrayidx289 = getelementptr inbounds [51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 %idxprom288
  %wg_curqgrp290 = getelementptr inbounds %struct.workgrp, %struct.workgrp* %arrayidx289, i32 0, i32 2
  %201 = load volatile i32, i32* %wg_curqgrp290, align 4, !tbaa !111
  %cmp291 = icmp ne i32 %199, %201
  br i1 %cmp291, label %if.then.293, label %if.end.297

if.then.293:                                      ; preds = %if.end.287
  %call294 = call %struct.SM_RPOOL_T* @sm_rpool_new_x(%struct.SM_RPOOL_T* null)
  store %struct.SM_RPOOL_T* %call294, %struct.SM_RPOOL_T** %rpool, align 8, !tbaa !1
  %202 = load %struct.envelope*, %struct.envelope** @CurEnv, align 8, !tbaa !1
  %203 = load %struct.SM_RPOOL_T*, %struct.SM_RPOOL_T** %rpool, align 8, !tbaa !1
  %call295 = call %struct.envelope* @newenvelope(%struct.envelope* @QueueEnvelope, %struct.envelope* %202, %struct.SM_RPOOL_T* %203)
  store %struct.envelope* %call295, %struct.envelope** %e, align 8, !tbaa !1
  %204 = load i64, i64* getelementptr inbounds (%struct.envelope, %struct.envelope* @BlankEnvelope, i32 0, i32 11), align 8, !tbaa !15
  %205 = load %struct.envelope*, %struct.envelope** %e, align 8, !tbaa !1
  %e_flags296 = getelementptr inbounds %struct.envelope, %struct.envelope* %205, i32 0, i32 11
  store i64 %204, i64* %e_flags296, align 8, !tbaa !15
  br label %domorework

if.end.297:                                       ; preds = %if.end.287
  %206 = load i32, i32* %flags.addr, align 4, !tbaa !5
  %and298 = and i32 %206, 4
  %cmp299 = icmp ne i32 %and298, 0
  br i1 %cmp299, label %if.then.301, label %if.end.387

if.then.301:                                      ; preds = %if.end.297
  store i32 1, i32* %sequenceno, align 4, !tbaa !5
  %207 = load i32, i32* %qgrp, align 4, !tbaa !5
  %208 = load i32, i32* %qdir, align 4, !tbaa !5
  %call302 = call i8* @qid_printqueue(i32 %207, i32 %208)
  call void (i32, %struct.envelope*, i8*, ...) @sm_setproctitle(i32 1, %struct.envelope* null, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.76, i32 0, i32 0), i8* %call302)
  call void @closemaps(i32 1)
  call void @mci_flush(i32 1, %struct.mailer_con_info* null)
  call void @rmexpstab()
  %209 = load i8*, i8** @FallbackMX, align 8, !tbaa !1
  %cmp303 = icmp ne i8* %209, null
  br i1 %cmp303, label %if.then.305, label %if.end.307

if.then.305:                                      ; preds = %if.then.301
  %210 = load i8*, i8** @FallbackMX, align 8, !tbaa !1
  %call306 = call i32 @getfallbackmxrr(i8* %210)
  br label %if.end.307

if.end.307:                                       ; preds = %if.then.305, %if.then.301
  %211 = load i32, i32* getelementptr inbounds (%struct.sm_debug, %struct.sm_debug* @SmHeapCheck, i32 0, i32 1), align 4, !tbaa !104
  %cmp308 = icmp uge i32 %211, 2
  br i1 %cmp308, label %land.lhs.true.310, label %if.end.337

land.lhs.true.310:                                ; preds = %if.end.307
  %212 = load i32, i32* getelementptr inbounds (%struct.sm_debug, %struct.sm_debug* @SmHeapCheck, i32 0, i32 1), align 4, !tbaa !104
  %cmp311 = icmp ne i32 %212, -1
  br i1 %cmp311, label %land.lhs.true.316, label %lor.lhs.false.313

lor.lhs.false.313:                                ; preds = %land.lhs.true.310
  %call314 = call i32 @sm_debug_loadactive(%struct.sm_debug* @SmHeapCheck, i32 2)
  %tobool315 = icmp ne i32 %call314, 0
  br i1 %tobool315, label %land.lhs.true.316, label %if.end.337

land.lhs.true.316:                                ; preds = %lor.lhs.false.313, %land.lhs.true.310
  %call317 = call i32 @access(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.80, i32 0, i32 0), i32 0) #1
  %cmp318 = icmp eq i32 %call317, 0
  br i1 %cmp318, label %if.then.320, label %if.end.337

if.then.320:                                      ; preds = %land.lhs.true.316
  %213 = bitcast %struct.sm_file** %out to i8*
  call void @llvm.lifetime.start(i64 8, i8* %213) #1
  %call321 = call i32 @remove(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.80, i32 0, i32 0)) #1
  %call322 = call %struct.sm_file* @sm_io_open(%struct.sm_file* @SmFtStdio_def, i32 -2, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.81, i32 0, i32 0), i32 4, i8* null)
  store %struct.sm_file* %call322, %struct.sm_file** %out, align 8, !tbaa !1
  %214 = load %struct.sm_file*, %struct.sm_file** %out, align 8, !tbaa !1
  %cmp323 = icmp ne %struct.sm_file* %214, null
  br i1 %cmp323, label %if.then.325, label %if.end.336

if.then.325:                                      ; preds = %if.then.320
  %215 = load %struct.sm_file*, %struct.sm_file** %out, align 8, !tbaa !1
  %call326 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* %215, i32 -2, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.82, i32 0, i32 0))
  %216 = load %struct.sm_file*, %struct.sm_file** %out, align 8, !tbaa !1
  %217 = load i32, i32* getelementptr inbounds (%struct.sm_debug, %struct.sm_debug* @SmHeapCheck, i32 0, i32 1), align 4, !tbaa !104
  %cmp327 = icmp eq i32 %217, -1
  br i1 %cmp327, label %cond.true.329, label %cond.false.331

cond.true.329:                                    ; preds = %if.then.325
  %call330 = call i32 @sm_debug_loadlevel(%struct.sm_debug* @SmHeapCheck)
  br label %cond.end.332

cond.false.331:                                   ; preds = %if.then.325
  %218 = load i32, i32* getelementptr inbounds (%struct.sm_debug, %struct.sm_debug* @SmHeapCheck, i32 0, i32 1), align 4, !tbaa !104
  br label %cond.end.332

cond.end.332:                                     ; preds = %cond.false.331, %cond.true.329
  %cond333 = phi i32 [ %call330, %cond.true.329 ], [ %218, %cond.false.331 ]
  %sub334 = sub i32 %cond333, 1
  call void @sm_heap_report(%struct.sm_file* %216, i32 %sub334)
  %219 = load %struct.sm_file*, %struct.sm_file** %out, align 8, !tbaa !1
  %call335 = call i32 @sm_io_close(%struct.sm_file* %219, i32 -2)
  br label %if.end.336

if.end.336:                                       ; preds = %cond.end.332, %if.then.320
  %220 = bitcast %struct.sm_file** %out to i8*
  call void @llvm.lifetime.end(i64 8, i8* %220) #1
  br label %if.end.337

if.end.337:                                       ; preds = %if.end.336, %land.lhs.true.316, %lor.lhs.false.313, %if.end.307
  %221 = load i32, i32* %njobs, align 4, !tbaa !5
  %cmp338 = icmp eq i32 %221, 0
  br i1 %cmp338, label %land.lhs.true.340, label %if.else.348

land.lhs.true.340:                                ; preds = %if.end.337
  %222 = load i32, i32* %wgrp.addr, align 4, !tbaa !5
  %idxprom341 = sext i32 %222 to i64
  %arrayidx342 = getelementptr inbounds [51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 %idxprom341
  %wg_lowqintvl343 = getelementptr inbounds %struct.workgrp, %struct.workgrp* %arrayidx342, i32 0, i32 5
  %223 = load volatile i64, i64* %wg_lowqintvl343, align 8, !tbaa !109
  %cmp344 = icmp slt i64 %223, 5
  br i1 %cmp344, label %if.then.346, label %if.else.348

if.then.346:                                      ; preds = %land.lhs.true.340
  %call347 = call i32 @sleep(i32 5)
  br label %if.end.370

if.else.348:                                      ; preds = %land.lhs.true.340, %if.end.337
  %224 = load i32, i32* %wgrp.addr, align 4, !tbaa !5
  %idxprom349 = sext i32 %224 to i64
  %arrayidx350 = getelementptr inbounds [51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 %idxprom349
  %wg_lowqintvl351 = getelementptr inbounds %struct.workgrp, %struct.workgrp* %arrayidx350, i32 0, i32 5
  %225 = load volatile i64, i64* %wg_lowqintvl351, align 8, !tbaa !109
  %cmp352 = icmp sle i64 %225, 0
  br i1 %cmp352, label %if.then.354, label %if.else.363

if.then.354:                                      ; preds = %if.else.348
  %226 = load i64, i64* @QueueIntvl, align 8, !tbaa !92
  %cmp355 = icmp sgt i64 %226, 0
  br i1 %cmp355, label %cond.true.357, label %cond.false.358

cond.true.357:                                    ; preds = %if.then.354
  %227 = load i64, i64* @QueueIntvl, align 8, !tbaa !92
  br label %cond.end.359

cond.false.358:                                   ; preds = %if.then.354
  br label %cond.end.359

cond.end.359:                                     ; preds = %cond.false.358, %cond.true.357
  %cond360 = phi i64 [ %227, %cond.true.357 ], [ 5, %cond.false.358 ]
  %conv361 = trunc i64 %cond360 to i32
  %call362 = call i32 @sleep(i32 %conv361)
  br label %if.end.369

if.else.363:                                      ; preds = %if.else.348
  %228 = load i32, i32* %wgrp.addr, align 4, !tbaa !5
  %idxprom364 = sext i32 %228 to i64
  %arrayidx365 = getelementptr inbounds [51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 %idxprom364
  %wg_lowqintvl366 = getelementptr inbounds %struct.workgrp, %struct.workgrp* %arrayidx365, i32 0, i32 5
  %229 = load volatile i64, i64* %wg_lowqintvl366, align 8, !tbaa !109
  %conv367 = trunc i64 %229 to i32
  %call368 = call i32 @sleep(i32 %conv367)
  br label %if.end.369

if.end.369:                                       ; preds = %if.else.363, %cond.end.359
  br label %if.end.370

if.end.370:                                       ; preds = %if.end.369, %if.then.346
  %230 = load i32, i32* %njobs, align 4, !tbaa !5
  %cmp371 = icmp eq i32 %230, 0
  br i1 %cmp371, label %if.then.373, label %if.end.383

if.then.373:                                      ; preds = %if.end.370
  br label %do.body.374

do.body.374:                                      ; preds = %if.then.373
  %call375 = call i64 @curtime()
  store i64 %call375, i64* %now, align 8, !tbaa !92
  %231 = load i64, i64* @Current_LA_time, align 8, !tbaa !92
  %232 = load i64, i64* %now, align 8, !tbaa !92
  %sub376 = sub nsw i64 %232, 30
  %cmp377 = icmp slt i64 %231, %sub376
  br i1 %cmp377, label %if.then.379, label %if.end.380

if.then.379:                                      ; preds = %do.body.374
  call void @sm_getla()
  %233 = load i64, i64* %now, align 8, !tbaa !92
  store i64 %233, i64* @Current_LA_time, align 8, !tbaa !92
  br label %if.end.380

if.end.380:                                       ; preds = %if.then.379, %do.body.374
  br label %do.cond.381

do.cond.381:                                      ; preds = %if.end.380
  br label %do.end.382

do.end.382:                                       ; preds = %do.cond.381
  br label %if.end.383

if.end.383:                                       ; preds = %do.end.382, %if.end.370
  %call384 = call %struct.SM_RPOOL_T* @sm_rpool_new_x(%struct.SM_RPOOL_T* null)
  store %struct.SM_RPOOL_T* %call384, %struct.SM_RPOOL_T** %rpool, align 8, !tbaa !1
  %234 = load %struct.envelope*, %struct.envelope** @CurEnv, align 8, !tbaa !1
  %235 = load %struct.SM_RPOOL_T*, %struct.SM_RPOOL_T** %rpool, align 8, !tbaa !1
  %call385 = call %struct.envelope* @newenvelope(%struct.envelope* @QueueEnvelope, %struct.envelope* %234, %struct.SM_RPOOL_T* %235)
  store %struct.envelope* %call385, %struct.envelope** %e, align 8, !tbaa !1
  %236 = load i64, i64* getelementptr inbounds (%struct.envelope, %struct.envelope* @BlankEnvelope, i32 0, i32 11), align 8, !tbaa !15
  %237 = load %struct.envelope*, %struct.envelope** %e, align 8, !tbaa !1
  %e_flags386 = getelementptr inbounds %struct.envelope, %struct.envelope* %237, i32 0, i32 11
  store i64 %236, i64* %e_flags386, align 8, !tbaa !15
  br label %domorework

if.end.387:                                       ; preds = %if.end.297
  %238 = load %struct.envelope*, %struct.envelope** %e, align 8, !tbaa !1
  %e_id388 = getelementptr inbounds %struct.envelope, %struct.envelope* %238, i32 0, i32 25
  store i8* null, i8** %e_id388, align 8, !tbaa !7
  %239 = load i32, i32* %flags.addr, align 4, !tbaa !5
  %and389 = and i32 %239, 1
  %cmp390 = icmp ne i32 %and389, 0
  br i1 %cmp390, label %if.then.392, label %if.end.393

if.then.392:                                      ; preds = %if.end.387
  %240 = load i32, i32* @ExitStat, align 4, !tbaa !5
  call void @finis(i32 1, i32 1, i32 %240)
  br label %if.end.393

if.end.393:                                       ; preds = %if.then.392, %if.end.387
  store i32 1, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup.394

cleanup.394:                                      ; preds = %if.end.393, %cleanup.270, %if.end.135, %cleanup, %if.end.34, %if.end.13, %if.then
  %241 = bitcast %struct.SM_RPOOL_T** %rpool to i8*
  call void @llvm.lifetime.end(i64 8, i8* %241) #1
  %242 = bitcast i32* %more to i8*
  call void @llvm.lifetime.end(i64 4, i8* %242) #1
  %243 = bitcast i32* %full to i8*
  call void @llvm.lifetime.end(i64 4, i8* %243) #1
  %244 = bitcast i64* %now to i8*
  call void @llvm.lifetime.end(i64 8, i8* %244) #1
  %245 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end(i64 4, i8* %245) #1
  %246 = bitcast i32* %h to i8*
  call void @llvm.lifetime.end(i64 4, i8* %246) #1
  %247 = bitcast i32* %endgrp to i8*
  call void @llvm.lifetime.end(i64 4, i8* %247) #1
  %248 = bitcast i32* %qgrp to i8*
  call void @llvm.lifetime.end(i64 4, i8* %248) #1
  %249 = bitcast i32* %sequenceno to i8*
  call void @llvm.lifetime.end(i64 4, i8* %249) #1
  %250 = bitcast i32* %qdir to i8*
  call void @llvm.lifetime.end(i64 4, i8* %250) #1
  %251 = bitcast i32* %njobs to i8*
  call void @llvm.lifetime.end(i64 4, i8* %251) #1
  %252 = bitcast %struct.envelope** %e to i8*
  call void @llvm.lifetime.end(i64 8, i8* %252) #1
  %253 = load i32, i32* %retval
  ret i32 %253
}

; Function Attrs: nounwind uwtable
define internal void @schedule_queue_runs(i32 %runall, i32 %wgrp, i32 %didit) #0 {
entry:
  %runall.addr = alloca i32, align 4
  %wgrp.addr = alloca i32, align 4
  %didit.addr = alloca i32, align 4
  %qgrp = alloca i32, align 4
  %cgrp = alloca i32, align 4
  %endgrp = alloca i32, align 4
  %now = alloca i64, align 8
  %minqintvl = alloca i64, align 8
  %qintvl = alloca i64, align 8
  store i32 %runall, i32* %runall.addr, align 4, !tbaa !5
  store i32 %wgrp, i32* %wgrp.addr, align 4, !tbaa !5
  store i32 %didit, i32* %didit.addr, align 4, !tbaa !5
  %0 = bitcast i32* %qgrp to i8*
  call void @llvm.lifetime.start(i64 4, i8* %0) #1
  %1 = bitcast i32* %cgrp to i8*
  call void @llvm.lifetime.start(i64 4, i8* %1) #1
  %2 = bitcast i32* %endgrp to i8*
  call void @llvm.lifetime.start(i64 4, i8* %2) #1
  %3 = bitcast i64* %now to i8*
  call void @llvm.lifetime.start(i64 8, i8* %3) #1
  %4 = bitcast i64* %minqintvl to i8*
  call void @llvm.lifetime.start(i64 8, i8* %4) #1
  %call = call i64 @curtime()
  store i64 %call, i64* %now, align 8, !tbaa !92
  store i64 0, i64* %minqintvl, align 8, !tbaa !92
  %5 = load i32, i32* %wgrp.addr, align 4, !tbaa !5
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds [51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 %idxprom
  %wg_curqgrp = getelementptr inbounds %struct.workgrp, %struct.workgrp* %arrayidx, i32 0, i32 2
  %6 = load volatile i32, i32* %wg_curqgrp, align 4, !tbaa !111
  store i32 %6, i32* %endgrp, align 4, !tbaa !5
  store i32 %6, i32* %cgrp, align 4, !tbaa !5
  br label %do.body

do.body:                                          ; preds = %do.cond, %entry
  %7 = bitcast i64* %qintvl to i8*
  call void @llvm.lifetime.start(i64 8, i8* %7) #1
  %8 = load i32, i32* %cgrp, align 4, !tbaa !5
  %idxprom1 = sext i32 %8 to i64
  %9 = load i32, i32* %wgrp.addr, align 4, !tbaa !5
  %idxprom2 = sext i32 %9 to i64
  %arrayidx3 = getelementptr inbounds [51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 %idxprom2
  %wg_qgs = getelementptr inbounds %struct.workgrp, %struct.workgrp* %arrayidx3, i32 0, i32 3
  %10 = load volatile %struct.queuegrp**, %struct.queuegrp*** %wg_qgs, align 8, !tbaa !106
  %arrayidx4 = getelementptr inbounds %struct.queuegrp*, %struct.queuegrp** %10, i64 %idxprom1
  %11 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx4, align 8, !tbaa !1
  %qg_index = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %11, i32 0, i32 2
  %12 = load i16, i16* %qg_index, align 2, !tbaa !112
  %conv = sext i16 %12 to i32
  store i32 %conv, i32* %qgrp, align 4, !tbaa !5
  %13 = load i32, i32* %qgrp, align 4, !tbaa !5
  %idxprom5 = sext i32 %13 to i64
  %arrayidx6 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom5
  %14 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx6, align 8, !tbaa !1
  %qg_queueintvl = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %14, i32 0, i32 5
  %15 = load i64, i64* %qg_queueintvl, align 8, !tbaa !121
  %cmp = icmp sgt i64 %15, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  %16 = load i32, i32* %qgrp, align 4, !tbaa !5
  %idxprom8 = sext i32 %16 to i64
  %arrayidx9 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom8
  %17 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx9, align 8, !tbaa !1
  %qg_queueintvl10 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %17, i32 0, i32 5
  %18 = load i64, i64* %qg_queueintvl10, align 8, !tbaa !121
  store i64 %18, i64* %qintvl, align 8, !tbaa !92
  br label %if.end.15

if.else:                                          ; preds = %do.body
  %19 = load i64, i64* @QueueIntvl, align 8, !tbaa !92
  %cmp11 = icmp sgt i64 %19, 0
  br i1 %cmp11, label %if.then.13, label %if.else.14

if.then.13:                                       ; preds = %if.else
  %20 = load i64, i64* @QueueIntvl, align 8, !tbaa !92
  store i64 %20, i64* %qintvl, align 8, !tbaa !92
  br label %if.end

if.else.14:                                       ; preds = %if.else
  store i64 0, i64* %qintvl, align 8, !tbaa !92
  br label %if.end

if.end:                                           ; preds = %if.else.14, %if.then.13
  br label %if.end.15

if.end.15:                                        ; preds = %if.end, %if.then
  %21 = load i32, i32* %runall.addr, align 4, !tbaa !5
  %tobool = icmp ne i32 %21, 0
  br i1 %tobool, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end.15
  %22 = load i32, i32* %qgrp, align 4, !tbaa !5
  %idxprom16 = sext i32 %22 to i64
  %arrayidx17 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom16
  %23 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx17, align 8, !tbaa !1
  %qg_nextrun = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %23, i32 0, i32 13
  %24 = load i64, i64* %qg_nextrun, align 8, !tbaa !113
  %25 = load i64, i64* %now, align 8, !tbaa !92
  %cmp18 = icmp sle i64 %24, %25
  br i1 %cmp18, label %land.lhs.true, label %if.end.36

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.end.15
  %26 = load i64, i64* %qintvl, align 8, !tbaa !92
  %cmp20 = icmp sgt i64 %26, 0
  br i1 %cmp20, label %if.then.22, label %if.end.36

if.then.22:                                       ; preds = %land.lhs.true
  %27 = load i64, i64* %minqintvl, align 8, !tbaa !92
  %cmp23 = icmp eq i64 %27, 0
  br i1 %cmp23, label %if.then.28, label %lor.lhs.false.25

lor.lhs.false.25:                                 ; preds = %if.then.22
  %28 = load i64, i64* %qintvl, align 8, !tbaa !92
  %29 = load i64, i64* %minqintvl, align 8, !tbaa !92
  %cmp26 = icmp slt i64 %28, %29
  br i1 %cmp26, label %if.then.28, label %if.end.29

if.then.28:                                       ; preds = %lor.lhs.false.25, %if.then.22
  %30 = load i64, i64* %qintvl, align 8, !tbaa !92
  store i64 %30, i64* %minqintvl, align 8, !tbaa !92
  br label %if.end.29

if.end.29:                                        ; preds = %if.then.28, %lor.lhs.false.25
  %31 = load i32, i32* %didit.addr, align 4, !tbaa !5
  %tobool30 = icmp ne i32 %31, 0
  br i1 %tobool30, label %if.then.31, label %if.end.35

if.then.31:                                       ; preds = %if.end.29
  %32 = load i64, i64* %qintvl, align 8, !tbaa !92
  %33 = load i32, i32* %qgrp, align 4, !tbaa !5
  %idxprom32 = sext i32 %33 to i64
  %arrayidx33 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom32
  %34 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx33, align 8, !tbaa !1
  %qg_nextrun34 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %34, i32 0, i32 13
  %35 = load i64, i64* %qg_nextrun34, align 8, !tbaa !113
  %add = add nsw i64 %35, %32
  store i64 %add, i64* %qg_nextrun34, align 8, !tbaa !113
  br label %if.end.35

if.end.35:                                        ; preds = %if.then.31, %if.end.29
  br label %if.end.36

if.end.36:                                        ; preds = %if.end.35, %land.lhs.true, %lor.lhs.false
  %36 = load i32, i32* %cgrp, align 4, !tbaa !5
  %inc = add nsw i32 %36, 1
  store i32 %inc, i32* %cgrp, align 4, !tbaa !5
  %37 = load i32, i32* %wgrp.addr, align 4, !tbaa !5
  %idxprom37 = sext i32 %37 to i64
  %arrayidx38 = getelementptr inbounds [51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 %idxprom37
  %wg_numqgrp = getelementptr inbounds %struct.workgrp, %struct.workgrp* %arrayidx38, i32 0, i32 0
  %38 = load volatile i32, i32* %wg_numqgrp, align 4, !tbaa !107
  %cmp39 = icmp sge i32 %inc, %38
  br i1 %cmp39, label %if.then.41, label %if.else.42

if.then.41:                                       ; preds = %if.end.36
  store i32 0, i32* %cgrp, align 4, !tbaa !5
  br label %if.end.43

if.else.42:                                       ; preds = %if.end.36
  br label %if.end.43

if.end.43:                                        ; preds = %if.else.42, %if.then.41
  %39 = bitcast i64* %qintvl to i8*
  call void @llvm.lifetime.end(i64 8, i8* %39) #1
  br label %do.cond

do.cond:                                          ; preds = %if.end.43
  %40 = load i32, i32* %endgrp, align 4, !tbaa !5
  %41 = load i32, i32* %cgrp, align 4, !tbaa !5
  %cmp44 = icmp ne i32 %40, %41
  br i1 %cmp44, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  %42 = load i64, i64* %minqintvl, align 8, !tbaa !92
  %cmp46 = icmp sgt i64 %42, 0
  br i1 %cmp46, label %if.then.48, label %if.end.51

if.then.48:                                       ; preds = %do.end
  %43 = load i64, i64* %minqintvl, align 8, !tbaa !92
  %mul = mul nsw i64 %43, 1000
  %conv49 = trunc i64 %mul to i32
  %call50 = call %struct.sm_event* @sm_seteventm(i32 %conv49, void (i32)* @runqueueevent, i32 0)
  br label %if.end.51

if.end.51:                                        ; preds = %if.then.48, %do.end
  %44 = bitcast i64* %minqintvl to i8*
  call void @llvm.lifetime.end(i64 8, i8* %44) #1
  %45 = bitcast i64* %now to i8*
  call void @llvm.lifetime.end(i64 8, i8* %45) #1
  %46 = bitcast i32* %endgrp to i8*
  call void @llvm.lifetime.end(i64 4, i8* %46) #1
  %47 = bitcast i32* %cgrp to i8*
  call void @llvm.lifetime.end(i64 4, i8* %47) #1
  %48 = bitcast i32* %qgrp to i8*
  call void @llvm.lifetime.end(i64 4, i8* %48) #1
  ret void
}

declare i64 @curtime() #2

declare void @sm_getla() #2

declare i32 @shouldqueue(i64, i64) #2

declare void @reapchild(i32) #2

declare i32 @dofork() #2

declare void @proc_list_add(i32, i8*, i32, i32, i32, %union.bigsockaddr*) #2

; Function Attrs: nounwind
declare i32 @getpid() #3

declare void @close_sendmail_pid() #2

declare void @sm_exc_newthread(void (%struct.sm_exc*)*) #2

declare void @fatal_error(%struct.sm_exc*) #2

declare void @clrcontrol() #2

declare void @proc_list_clear() #2

declare void @intsig(i32) #2

declare void @clrdaemon() #2

declare i32 @drop_privileges(i32) #2

declare %struct.SM_RPOOL_T* @sm_rpool_new_x(%struct.SM_RPOOL_T*) #2

declare %struct.envelope* @newenvelope(%struct.envelope*, %struct.envelope*, %struct.SM_RPOOL_T*) #2

declare void @disconnect(i32, %struct.envelope*) #2

declare void @finis(i32, i32, i32) #2

; Function Attrs: nounwind
declare i32 @nice(i32) #3

declare void @sm_setproctitle(i32, %struct.envelope*, i8*, ...) #2

; Function Attrs: nounwind uwtable
define internal i32 @gatherq(i32 %qgrp, i32 %qdir, i32 %doall, i32* %full, i32* %more, i32* %pnentries) #0 {
entry:
  %retval = alloca i32, align 4
  %qgrp.addr = alloca i32, align 4
  %qdir.addr = alloca i32, align 4
  %doall.addr = alloca i32, align 4
  %full.addr = alloca i32*, align 8
  %more.addr = alloca i32*, align 8
  %pnentries.addr = alloca i32*, align 8
  %d = alloca %struct.dirent*, align 8
  %w = alloca %struct.work*, align 8
  %p = alloca i8*, align 8
  %f = alloca %struct.__dirstream*, align 8
  %i = alloca i32, align 4
  %num_ent = alloca i32, align 4
  %wn = alloca i32, align 4
  %nentries = alloca i32, align 4
  %check = alloca %struct.queue_char*, align 8
  %qd = alloca [4096 x i8], align 16
  %qf = alloca [4096 x i8], align 16
  %cleanup.dest.slot = alloca i32
  %cf = alloca %struct.sm_file*, align 8
  %qfver = alloca i32, align 4
  %lbuf = alloca [257 x i8], align 16
  %sbuf = alloca %struct.stat, align 8
  %c = alloca i32, align 4
  %age = alloca i64, align 8
  %lasttry = alloca i64, align 8
  %delay = alloca i64, align 8
  store i32 %qgrp, i32* %qgrp.addr, align 4, !tbaa !5
  store i32 %qdir, i32* %qdir.addr, align 4, !tbaa !5
  store i32 %doall, i32* %doall.addr, align 4, !tbaa !5
  store i32* %full, i32** %full.addr, align 8, !tbaa !1
  store i32* %more, i32** %more.addr, align 8, !tbaa !1
  store i32* %pnentries, i32** %pnentries.addr, align 8, !tbaa !1
  %0 = bitcast %struct.dirent** %d to i8*
  call void @llvm.lifetime.start(i64 8, i8* %0) #1
  %1 = bitcast %struct.work** %w to i8*
  call void @llvm.lifetime.start(i64 8, i8* %1) #1
  %2 = bitcast i8** %p to i8*
  call void @llvm.lifetime.start(i64 8, i8* %2) #1
  %3 = bitcast %struct.__dirstream** %f to i8*
  call void @llvm.lifetime.start(i64 8, i8* %3) #1
  %4 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start(i64 4, i8* %4) #1
  %5 = bitcast i32* %num_ent to i8*
  call void @llvm.lifetime.start(i64 4, i8* %5) #1
  %6 = bitcast i32* %wn to i8*
  call void @llvm.lifetime.start(i64 4, i8* %6) #1
  %7 = bitcast i32* %nentries to i8*
  call void @llvm.lifetime.start(i64 4, i8* %7) #1
  %8 = bitcast %struct.queue_char** %check to i8*
  call void @llvm.lifetime.start(i64 8, i8* %8) #1
  %9 = bitcast [4096 x i8]* %qd to i8*
  call void @llvm.lifetime.start(i64 4096, i8* %9) #1
  %10 = bitcast [4096 x i8]* %qf to i8*
  call void @llvm.lifetime.start(i64 4096, i8* %10) #1
  %11 = load i32, i32* @WorkListCount, align 4, !tbaa !5
  %sub = sub nsw i32 %11, 1
  store i32 %sub, i32* %wn, align 4, !tbaa !5
  store i32 0, i32* %num_ent, align 4, !tbaa !5
  store i32 0, i32* %nentries, align 4, !tbaa !5
  %12 = load i32, i32* %qdir.addr, align 4, !tbaa !5
  %cmp = icmp eq i32 %12, -1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %arraydecay = getelementptr inbounds [4096 x i8], [4096 x i8]* %qd, i32 0, i32 0
  %call = call i64 @sm_strlcpy(i8* %arraydecay, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.100, i32 0, i32 0), i64 4096)
  br label %if.end

if.else:                                          ; preds = %entry
  %arraydecay1 = getelementptr inbounds [4096 x i8], [4096 x i8]* %qd, i32 0, i32 0
  %13 = load i32, i32* %qdir.addr, align 4, !tbaa !5
  %idxprom = sext i32 %13 to i64
  %14 = load i32, i32* %qgrp.addr, align 4, !tbaa !5
  %idxprom2 = sext i32 %14 to i64
  %arrayidx = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom2
  %15 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx, align 8, !tbaa !1
  %qg_qpaths = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %15, i32 0, i32 6
  %16 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths, align 8, !tbaa !38
  %arrayidx3 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %16, i64 %idxprom
  %qp_name = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %arrayidx3, i32 0, i32 0
  %17 = load i8*, i8** %qp_name, align 8, !tbaa !40
  %18 = load i32, i32* %qdir.addr, align 4, !tbaa !5
  %idxprom4 = sext i32 %18 to i64
  %19 = load i32, i32* %qgrp.addr, align 4, !tbaa !5
  %idxprom5 = sext i32 %19 to i64
  %arrayidx6 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom5
  %20 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx6, align 8, !tbaa !1
  %qg_qpaths7 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %20, i32 0, i32 6
  %21 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths7, align 8, !tbaa !38
  %arrayidx8 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %21, i64 %idxprom4
  %qp_subdirs = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %arrayidx8, i32 0, i32 1
  %22 = load i16, i16* %qp_subdirs, align 2, !tbaa !83
  %conv = sext i16 %22 to i32
  %and = and i32 %conv, 2
  %cmp9 = icmp ne i32 %and, 0
  %cond = select i1 %cmp9, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.101, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0)
  %call11 = call i64 (i8*, i64, i32, ...) @sm_strlcpyn(i8* %arraydecay1, i64 4096, i32 2, i8* %17, i8* %cond)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %23 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 41), align 1, !tbaa !17
  %conv12 = zext i8 %23 to i32
  %cmp13 = icmp sge i32 %conv12, 1
  br i1 %cmp13, label %land.lhs.true, label %if.end.54

land.lhs.true:                                    ; preds = %if.end
  %24 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool = icmp ne i32 %24, 0
  br i1 %tobool, label %if.end.54, label %if.then.15

if.then.15:                                       ; preds = %land.lhs.true
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.203, i32 0, i32 0))
  %25 = load %struct.queue_char*, %struct.queue_char** @QueueLimitId, align 8, !tbaa !1
  store %struct.queue_char* %25, %struct.queue_char** %check, align 8, !tbaa !1
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then.15
  %26 = load %struct.queue_char*, %struct.queue_char** %check, align 8, !tbaa !1
  %cmp16 = icmp ne %struct.queue_char* %26, null
  br i1 %cmp16, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %27 = load %struct.queue_char*, %struct.queue_char** %check, align 8, !tbaa !1
  %queue_negate = getelementptr inbounds %struct.queue_char, %struct.queue_char* %27, i32 0, i32 1
  %28 = load i32, i32* %queue_negate, align 4, !tbaa !122
  %tobool18 = icmp ne i32 %28, 0
  %cond19 = select i1 %tobool18, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.205, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0)
  %29 = load %struct.queue_char*, %struct.queue_char** %check, align 8, !tbaa !1
  %queue_match = getelementptr inbounds %struct.queue_char, %struct.queue_char* %29, i32 0, i32 0
  %30 = load i8*, i8** %queue_match, align 8, !tbaa !124
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.204, i32 0, i32 0), i8* %cond19, i8* %30)
  %31 = load %struct.queue_char*, %struct.queue_char** %check, align 8, !tbaa !1
  %queue_next = getelementptr inbounds %struct.queue_char, %struct.queue_char* %31, i32 0, i32 2
  %32 = load %struct.queue_char*, %struct.queue_char** %queue_next, align 8, !tbaa !125
  store %struct.queue_char* %32, %struct.queue_char** %check, align 8, !tbaa !1
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %33 = load %struct.queue_char*, %struct.queue_char** @QueueLimitSender, align 8, !tbaa !1
  store %struct.queue_char* %33, %struct.queue_char** %check, align 8, !tbaa !1
  br label %while.cond.20

while.cond.20:                                    ; preds = %while.body.23, %while.end
  %34 = load %struct.queue_char*, %struct.queue_char** %check, align 8, !tbaa !1
  %cmp21 = icmp ne %struct.queue_char* %34, null
  br i1 %cmp21, label %while.body.23, label %while.end.29

while.body.23:                                    ; preds = %while.cond.20
  %35 = load %struct.queue_char*, %struct.queue_char** %check, align 8, !tbaa !1
  %queue_negate24 = getelementptr inbounds %struct.queue_char, %struct.queue_char* %35, i32 0, i32 1
  %36 = load i32, i32* %queue_negate24, align 4, !tbaa !122
  %tobool25 = icmp ne i32 %36, 0
  %cond26 = select i1 %tobool25, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.205, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0)
  %37 = load %struct.queue_char*, %struct.queue_char** %check, align 8, !tbaa !1
  %queue_match27 = getelementptr inbounds %struct.queue_char, %struct.queue_char* %37, i32 0, i32 0
  %38 = load i8*, i8** %queue_match27, align 8, !tbaa !124
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.206, i32 0, i32 0), i8* %cond26, i8* %38)
  %39 = load %struct.queue_char*, %struct.queue_char** %check, align 8, !tbaa !1
  %queue_next28 = getelementptr inbounds %struct.queue_char, %struct.queue_char* %39, i32 0, i32 2
  %40 = load %struct.queue_char*, %struct.queue_char** %queue_next28, align 8, !tbaa !125
  store %struct.queue_char* %40, %struct.queue_char** %check, align 8, !tbaa !1
  br label %while.cond.20

while.end.29:                                     ; preds = %while.cond.20
  %41 = load %struct.queue_char*, %struct.queue_char** @QueueLimitRecipient, align 8, !tbaa !1
  store %struct.queue_char* %41, %struct.queue_char** %check, align 8, !tbaa !1
  br label %while.cond.30

while.cond.30:                                    ; preds = %while.body.33, %while.end.29
  %42 = load %struct.queue_char*, %struct.queue_char** %check, align 8, !tbaa !1
  %cmp31 = icmp ne %struct.queue_char* %42, null
  br i1 %cmp31, label %while.body.33, label %while.end.39

while.body.33:                                    ; preds = %while.cond.30
  %43 = load %struct.queue_char*, %struct.queue_char** %check, align 8, !tbaa !1
  %queue_negate34 = getelementptr inbounds %struct.queue_char, %struct.queue_char* %43, i32 0, i32 1
  %44 = load i32, i32* %queue_negate34, align 4, !tbaa !122
  %tobool35 = icmp ne i32 %44, 0
  %cond36 = select i1 %tobool35, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.205, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0)
  %45 = load %struct.queue_char*, %struct.queue_char** %check, align 8, !tbaa !1
  %queue_match37 = getelementptr inbounds %struct.queue_char, %struct.queue_char* %45, i32 0, i32 0
  %46 = load i8*, i8** %queue_match37, align 8, !tbaa !124
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.207, i32 0, i32 0), i8* %cond36, i8* %46)
  %47 = load %struct.queue_char*, %struct.queue_char** %check, align 8, !tbaa !1
  %queue_next38 = getelementptr inbounds %struct.queue_char, %struct.queue_char* %47, i32 0, i32 2
  %48 = load %struct.queue_char*, %struct.queue_char** %queue_next38, align 8, !tbaa !125
  store %struct.queue_char* %48, %struct.queue_char** %check, align 8, !tbaa !1
  br label %while.cond.30

while.end.39:                                     ; preds = %while.cond.30
  %49 = load i32, i32* @QueueMode, align 4, !tbaa !5
  %cmp40 = icmp eq i32 %49, 81
  br i1 %cmp40, label %if.then.42, label %if.end.53

if.then.42:                                       ; preds = %while.end.39
  %50 = load %struct.queue_char*, %struct.queue_char** @QueueLimitQuarantine, align 8, !tbaa !1
  store %struct.queue_char* %50, %struct.queue_char** %check, align 8, !tbaa !1
  br label %while.cond.43

while.cond.43:                                    ; preds = %while.body.46, %if.then.42
  %51 = load %struct.queue_char*, %struct.queue_char** %check, align 8, !tbaa !1
  %cmp44 = icmp ne %struct.queue_char* %51, null
  br i1 %cmp44, label %while.body.46, label %while.end.52

while.body.46:                                    ; preds = %while.cond.43
  %52 = load %struct.queue_char*, %struct.queue_char** %check, align 8, !tbaa !1
  %queue_negate47 = getelementptr inbounds %struct.queue_char, %struct.queue_char* %52, i32 0, i32 1
  %53 = load i32, i32* %queue_negate47, align 4, !tbaa !122
  %tobool48 = icmp ne i32 %53, 0
  %cond49 = select i1 %tobool48, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.205, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0)
  %54 = load %struct.queue_char*, %struct.queue_char** %check, align 8, !tbaa !1
  %queue_match50 = getelementptr inbounds %struct.queue_char, %struct.queue_char* %54, i32 0, i32 0
  %55 = load i8*, i8** %queue_match50, align 8, !tbaa !124
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.208, i32 0, i32 0), i8* %cond49, i8* %55)
  %56 = load %struct.queue_char*, %struct.queue_char** %check, align 8, !tbaa !1
  %queue_next51 = getelementptr inbounds %struct.queue_char, %struct.queue_char* %56, i32 0, i32 2
  %57 = load %struct.queue_char*, %struct.queue_char** %queue_next51, align 8, !tbaa !125
  store %struct.queue_char* %57, %struct.queue_char** %check, align 8, !tbaa !1
  br label %while.cond.43

while.end.52:                                     ; preds = %while.cond.43
  br label %if.end.53

if.end.53:                                        ; preds = %while.end.52, %while.end.39
  br label %if.end.54

if.end.54:                                        ; preds = %if.end.53, %land.lhs.true, %if.end
  %arraydecay55 = getelementptr inbounds [4096 x i8], [4096 x i8]* %qd, i32 0, i32 0
  %call56 = call %struct.__dirstream* @opendir(i8* %arraydecay55)
  store %struct.__dirstream* %call56, %struct.__dirstream** %f, align 8, !tbaa !1
  %58 = load %struct.__dirstream*, %struct.__dirstream** %f, align 8, !tbaa !1
  %cmp57 = icmp eq %struct.__dirstream* %58, null
  br i1 %cmp57, label %if.then.59, label %if.end.73

if.then.59:                                       ; preds = %if.end.54
  %59 = load i32, i32* %qgrp.addr, align 4, !tbaa !5
  %60 = load i32, i32* %qdir.addr, align 4, !tbaa !5
  %call60 = call i8* @qid_printqueue(i32 %59, i32 %60)
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.209, i32 0, i32 0), i8* %call60)
  %61 = load i32*, i32** %full.addr, align 8, !tbaa !1
  %cmp61 = icmp ne i32* %61, null
  br i1 %cmp61, label %if.then.63, label %if.end.68

if.then.63:                                       ; preds = %if.then.59
  %62 = load i32, i32* @WorkListCount, align 4, !tbaa !5
  %63 = load i32, i32* @MaxQueueRun, align 4, !tbaa !5
  %cmp64 = icmp sge i32 %62, %63
  br i1 %cmp64, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then.63
  %64 = load i32, i32* @MaxQueueRun, align 4, !tbaa !5
  %cmp66 = icmp sgt i32 %64, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then.63
  %65 = phi i1 [ false, %if.then.63 ], [ %cmp66, %land.rhs ]
  %land.ext = zext i1 %65 to i32
  %66 = load i32*, i32** %full.addr, align 8, !tbaa !1
  store i32 %land.ext, i32* %66, align 4, !tbaa !5
  br label %if.end.68

if.end.68:                                        ; preds = %land.end, %if.then.59
  %67 = load i32*, i32** %more.addr, align 8, !tbaa !1
  %cmp69 = icmp ne i32* %67, null
  br i1 %cmp69, label %if.then.71, label %if.end.72

if.then.71:                                       ; preds = %if.end.68
  %68 = load i32*, i32** %more.addr, align 8, !tbaa !1
  store i32 0, i32* %68, align 4, !tbaa !5
  br label %if.end.72

if.end.72:                                        ; preds = %if.then.71, %if.end.68
  store i32 0, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup.669

if.end.73:                                        ; preds = %if.end.54
  br label %while.cond.74

while.cond.74:                                    ; preds = %cleanup.cont, %cleanup, %if.end.73
  %69 = load %struct.__dirstream*, %struct.__dirstream** %f, align 8, !tbaa !1
  %call75 = call %struct.dirent* @readdir(%struct.__dirstream* %69)
  store %struct.dirent* %call75, %struct.dirent** %d, align 8, !tbaa !1
  %cmp76 = icmp ne %struct.dirent* %call75, null
  br i1 %cmp76, label %while.body.78, label %while.end.630

while.body.78:                                    ; preds = %while.cond.74
  %70 = bitcast %struct.sm_file** %cf to i8*
  call void @llvm.lifetime.start(i64 8, i8* %70) #1
  %71 = bitcast i32* %qfver to i8*
  call void @llvm.lifetime.start(i64 4, i8* %71) #1
  store i32 0, i32* %qfver, align 4, !tbaa !5
  %72 = bitcast [257 x i8]* %lbuf to i8*
  call void @llvm.lifetime.start(i64 257, i8* %72) #1
  %73 = bitcast %struct.stat* %sbuf to i8*
  call void @llvm.lifetime.start(i64 144, i8* %73) #1
  %74 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 41), align 1, !tbaa !17
  %conv79 = zext i8 %74 to i32
  %cmp80 = icmp sge i32 %conv79, 50
  br i1 %cmp80, label %land.lhs.true.82, label %if.end.86

land.lhs.true.82:                                 ; preds = %while.body.78
  %75 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool83 = icmp ne i32 %75, 0
  br i1 %tobool83, label %if.end.86, label %if.then.84

if.then.84:                                       ; preds = %land.lhs.true.82
  %76 = load %struct.dirent*, %struct.dirent** %d, align 8, !tbaa !1
  %d_name = getelementptr inbounds %struct.dirent, %struct.dirent* %76, i32 0, i32 4
  %arraydecay85 = getelementptr inbounds [256 x i8], [256 x i8]* %d_name, i32 0, i32 0
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.210, i32 0, i32 0), i8* %arraydecay85)
  br label %if.end.86

if.end.86:                                        ; preds = %if.then.84, %land.lhs.true.82, %while.body.78
  %77 = load i32, i32* @QueueMode, align 4, !tbaa !5
  %cmp87 = icmp eq i32 %77, 32
  br i1 %cmp87, label %land.lhs.true.89, label %lor.lhs.false

land.lhs.true.89:                                 ; preds = %if.end.86
  %78 = load %struct.dirent*, %struct.dirent** %d, align 8, !tbaa !1
  %d_name90 = getelementptr inbounds %struct.dirent, %struct.dirent* %78, i32 0, i32 4
  %arrayidx91 = getelementptr inbounds [256 x i8], [256 x i8]* %d_name90, i32 0, i64 0
  %79 = load i8, i8* %arrayidx91, align 1, !tbaa !17
  %conv92 = sext i8 %79 to i32
  %cmp93 = icmp eq i32 %conv92, 113
  br i1 %cmp93, label %land.lhs.true.112, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true.89, %if.end.86
  %80 = load i32, i32* @QueueMode, align 4, !tbaa !5
  %cmp95 = icmp eq i32 %80, 81
  br i1 %cmp95, label %land.lhs.true.97, label %lor.lhs.false.103

land.lhs.true.97:                                 ; preds = %lor.lhs.false
  %81 = load %struct.dirent*, %struct.dirent** %d, align 8, !tbaa !1
  %d_name98 = getelementptr inbounds %struct.dirent, %struct.dirent* %81, i32 0, i32 4
  %arrayidx99 = getelementptr inbounds [256 x i8], [256 x i8]* %d_name98, i32 0, i64 0
  %82 = load i8, i8* %arrayidx99, align 1, !tbaa !17
  %conv100 = sext i8 %82 to i32
  %cmp101 = icmp eq i32 %conv100, 104
  br i1 %cmp101, label %land.lhs.true.112, label %lor.lhs.false.103

lor.lhs.false.103:                                ; preds = %land.lhs.true.97, %lor.lhs.false
  %83 = load i32, i32* @QueueMode, align 4, !tbaa !5
  %cmp104 = icmp eq i32 %83, 76
  br i1 %cmp104, label %land.lhs.true.106, label %if.then.118

land.lhs.true.106:                                ; preds = %lor.lhs.false.103
  %84 = load %struct.dirent*, %struct.dirent** %d, align 8, !tbaa !1
  %d_name107 = getelementptr inbounds %struct.dirent, %struct.dirent* %84, i32 0, i32 4
  %arrayidx108 = getelementptr inbounds [256 x i8], [256 x i8]* %d_name107, i32 0, i64 0
  %85 = load i8, i8* %arrayidx108, align 1, !tbaa !17
  %conv109 = sext i8 %85 to i32
  %cmp110 = icmp eq i32 %conv109, 81
  br i1 %cmp110, label %land.lhs.true.112, label %if.then.118

land.lhs.true.112:                                ; preds = %land.lhs.true.106, %land.lhs.true.97, %land.lhs.true.89
  %86 = load %struct.dirent*, %struct.dirent** %d, align 8, !tbaa !1
  %d_name113 = getelementptr inbounds %struct.dirent, %struct.dirent* %86, i32 0, i32 4
  %arrayidx114 = getelementptr inbounds [256 x i8], [256 x i8]* %d_name113, i32 0, i64 1
  %87 = load i8, i8* %arrayidx114, align 1, !tbaa !17
  %conv115 = sext i8 %87 to i32
  %cmp116 = icmp eq i32 %conv115, 102
  br i1 %cmp116, label %if.end.126, label %if.then.118

if.then.118:                                      ; preds = %land.lhs.true.112, %land.lhs.true.106, %lor.lhs.false.103
  %88 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 41), align 1, !tbaa !17
  %conv119 = zext i8 %88 to i32
  %cmp120 = icmp sge i32 %conv119, 50
  br i1 %cmp120, label %land.lhs.true.122, label %if.end.125

land.lhs.true.122:                                ; preds = %if.then.118
  %89 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool123 = icmp ne i32 %89, 0
  br i1 %tobool123, label %if.end.125, label %if.then.124

if.then.124:                                      ; preds = %land.lhs.true.122
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.211, i32 0, i32 0))
  br label %if.end.125

if.end.125:                                       ; preds = %if.then.124, %land.lhs.true.122, %if.then.118
  store i32 10, i32* %cleanup.dest.slot
  br label %cleanup

if.end.126:                                       ; preds = %land.lhs.true.112
  %90 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 41), align 1, !tbaa !17
  %conv127 = zext i8 %90 to i32
  %cmp128 = icmp sge i32 %conv127, 50
  br i1 %cmp128, label %land.lhs.true.130, label %if.end.133

land.lhs.true.130:                                ; preds = %if.end.126
  %91 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool131 = icmp ne i32 %91, 0
  br i1 %tobool131, label %if.end.133, label %if.then.132

if.then.132:                                      ; preds = %land.lhs.true.130
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.45, i32 0, i32 0))
  br label %if.end.133

if.end.133:                                       ; preds = %if.then.132, %land.lhs.true.130, %if.end.126
  %92 = load %struct.dirent*, %struct.dirent** %d, align 8, !tbaa !1
  %d_name134 = getelementptr inbounds %struct.dirent, %struct.dirent* %92, i32 0, i32 4
  %arraydecay135 = getelementptr inbounds [256 x i8], [256 x i8]* %d_name134, i32 0, i32 0
  %call136 = call i64 @strlen(i8* %arraydecay135) #14
  %cmp137 = icmp uge i64 %call136, 21
  br i1 %cmp137, label %if.then.139, label %if.end.152

if.then.139:                                      ; preds = %if.end.133
  %93 = load i32, i32* @Verbose, align 4, !tbaa !5
  %tobool140 = icmp ne i32 %93, 0
  br i1 %tobool140, label %if.then.141, label %if.end.145

if.then.141:                                      ; preds = %if.then.139
  %94 = load %struct.dirent*, %struct.dirent** %d, align 8, !tbaa !1
  %d_name142 = getelementptr inbounds %struct.dirent, %struct.dirent* %94, i32 0, i32 4
  %arraydecay143 = getelementptr inbounds [256 x i8], [256 x i8]* %d_name142, i32 0, i32 0
  %call144 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.212, i32 0, i32 0), i8* %arraydecay143, i32 21)
  br label %if.end.145

if.end.145:                                       ; preds = %if.then.141, %if.then.139
  %95 = load i32, i32* @LogLevel, align 4, !tbaa !5
  %cmp146 = icmp sgt i32 %95, 0
  br i1 %cmp146, label %if.then.148, label %if.end.151

if.then.148:                                      ; preds = %if.end.145
  %96 = load %struct.dirent*, %struct.dirent** %d, align 8, !tbaa !1
  %d_name149 = getelementptr inbounds %struct.dirent, %struct.dirent* %96, i32 0, i32 4
  %arraydecay150 = getelementptr inbounds [256 x i8], [256 x i8]* %d_name149, i32 0, i32 0
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 1, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0), i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.213, i32 0, i32 0), i8* %arraydecay150, i32 21)
  br label %if.end.151

if.end.151:                                       ; preds = %if.then.148, %if.end.145
  store i32 10, i32* %cleanup.dest.slot
  br label %cleanup

if.end.152:                                       ; preds = %if.end.133
  %97 = load i32, i32* %nentries, align 4, !tbaa !5
  %inc = add nsw i32 %97, 1
  store i32 %inc, i32* %nentries, align 4, !tbaa !5
  %98 = load %struct.queue_char*, %struct.queue_char** @QueueLimitId, align 8, !tbaa !1
  store %struct.queue_char* %98, %struct.queue_char** %check, align 8, !tbaa !1
  br label %while.cond.153

while.cond.153:                                   ; preds = %if.end.167, %if.end.152
  %99 = load %struct.queue_char*, %struct.queue_char** %check, align 8, !tbaa !1
  %cmp154 = icmp ne %struct.queue_char* %99, null
  br i1 %cmp154, label %while.body.156, label %while.end.168

while.body.156:                                   ; preds = %while.cond.153
  %100 = load %struct.queue_char*, %struct.queue_char** %check, align 8, !tbaa !1
  %queue_match157 = getelementptr inbounds %struct.queue_char, %struct.queue_char* %100, i32 0, i32 0
  %101 = load i8*, i8** %queue_match157, align 8, !tbaa !124
  %102 = load %struct.dirent*, %struct.dirent** %d, align 8, !tbaa !1
  %d_name158 = getelementptr inbounds %struct.dirent, %struct.dirent* %102, i32 0, i32 4
  %arraydecay159 = getelementptr inbounds [256 x i8], [256 x i8]* %d_name158, i32 0, i32 0
  %call160 = call i32 @strcontainedin(i32 0, i8* %101, i8* %arraydecay159)
  %103 = load %struct.queue_char*, %struct.queue_char** %check, align 8, !tbaa !1
  %queue_negate161 = getelementptr inbounds %struct.queue_char, %struct.queue_char* %103, i32 0, i32 1
  %104 = load i32, i32* %queue_negate161, align 4, !tbaa !122
  %cmp162 = icmp ne i32 %call160, %104
  br i1 %cmp162, label %if.then.164, label %if.else.165

if.then.164:                                      ; preds = %while.body.156
  br label %while.end.168

if.else.165:                                      ; preds = %while.body.156
  %105 = load %struct.queue_char*, %struct.queue_char** %check, align 8, !tbaa !1
  %queue_next166 = getelementptr inbounds %struct.queue_char, %struct.queue_char* %105, i32 0, i32 2
  %106 = load %struct.queue_char*, %struct.queue_char** %queue_next166, align 8, !tbaa !125
  store %struct.queue_char* %106, %struct.queue_char** %check, align 8, !tbaa !1
  br label %if.end.167

if.end.167:                                       ; preds = %if.else.165
  br label %while.cond.153

while.end.168:                                    ; preds = %if.then.164, %while.cond.153
  %107 = load %struct.queue_char*, %struct.queue_char** @QueueLimitId, align 8, !tbaa !1
  %cmp169 = icmp ne %struct.queue_char* %107, null
  br i1 %cmp169, label %land.lhs.true.171, label %if.end.175

land.lhs.true.171:                                ; preds = %while.end.168
  %108 = load %struct.queue_char*, %struct.queue_char** %check, align 8, !tbaa !1
  %cmp172 = icmp eq %struct.queue_char* %108, null
  br i1 %cmp172, label %if.then.174, label %if.end.175

if.then.174:                                      ; preds = %land.lhs.true.171
  store i32 10, i32* %cleanup.dest.slot
  br label %cleanup

if.end.175:                                       ; preds = %land.lhs.true.171, %while.end.168
  %109 = load i32, i32* %wn, align 4, !tbaa !5
  %inc176 = add nsw i32 %109, 1
  store i32 %inc176, i32* %wn, align 4, !tbaa !5
  %110 = load i32, i32* @MaxQueueRun, align 4, !tbaa !5
  %cmp177 = icmp sge i32 %inc176, %110
  br i1 %cmp177, label %land.lhs.true.179, label %if.end.194

land.lhs.true.179:                                ; preds = %if.end.175
  %111 = load i32, i32* @MaxQueueRun, align 4, !tbaa !5
  %cmp180 = icmp sgt i32 %111, 0
  br i1 %cmp180, label %if.then.182, label %if.end.194

if.then.182:                                      ; preds = %land.lhs.true.179
  %112 = load i32, i32* %wn, align 4, !tbaa !5
  %113 = load i32, i32* @MaxQueueRun, align 4, !tbaa !5
  %cmp183 = icmp eq i32 %112, %113
  br i1 %cmp183, label %land.lhs.true.185, label %if.end.190

land.lhs.true.185:                                ; preds = %if.then.182
  %114 = load i32, i32* @LogLevel, align 4, !tbaa !5
  %cmp186 = icmp sgt i32 %114, 0
  br i1 %cmp186, label %if.then.188, label %if.end.190

if.then.188:                                      ; preds = %land.lhs.true.185
  %115 = load i32, i32* %qgrp.addr, align 4, !tbaa !5
  %116 = load i32, i32* %qdir.addr, align 4, !tbaa !5
  %call189 = call i8* @qid_printqueue(i32 %115, i32 %116)
  %117 = load i32, i32* @MaxQueueRun, align 4, !tbaa !5
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 4, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0), i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.214, i32 0, i32 0), i8* %call189, i32 %117)
  br label %if.end.190

if.end.190:                                       ; preds = %if.then.188, %land.lhs.true.185, %if.then.182
  %118 = load i32, i32* %doall.addr, align 4, !tbaa !5
  %tobool191 = icmp ne i32 %118, 0
  br i1 %tobool191, label %if.then.192, label %if.end.193

if.then.192:                                      ; preds = %if.end.190
  store i32 10, i32* %cleanup.dest.slot
  br label %cleanup

if.end.193:                                       ; preds = %if.end.190
  store i32 11, i32* %cleanup.dest.slot
  br label %cleanup

if.end.194:                                       ; preds = %land.lhs.true.179, %if.end.175
  %119 = load i32, i32* %wn, align 4, !tbaa !5
  %120 = load i32, i32* @WorkListSize, align 4, !tbaa !5
  %cmp195 = icmp sge i32 %119, %120
  br i1 %cmp195, label %if.then.197, label %if.end.202

if.then.197:                                      ; preds = %if.end.194
  %121 = load i32, i32* %qgrp.addr, align 4, !tbaa !5
  %122 = load i32, i32* %qdir.addr, align 4, !tbaa !5
  call void @grow_wlist(i32 %121, i32 %122)
  %123 = load i32, i32* %wn, align 4, !tbaa !5
  %124 = load i32, i32* @WorkListSize, align 4, !tbaa !5
  %cmp198 = icmp sge i32 %123, %124
  br i1 %cmp198, label %if.then.200, label %if.end.201

if.then.200:                                      ; preds = %if.then.197
  store i32 10, i32* %cleanup.dest.slot
  br label %cleanup

if.end.201:                                       ; preds = %if.then.197
  br label %if.end.202

if.end.202:                                       ; preds = %if.end.201, %if.end.194
  %125 = load i32, i32* %wn, align 4, !tbaa !5
  %cmp203 = icmp sge i32 %125, 0
  br i1 %cmp203, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.end.202
  call void @sm_abort_at(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 2646, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.215, i32 0, i32 0)) #12
  unreachable
                                                  ; No predecessors!
  br label %lor.end

lor.end:                                          ; preds = %126, %if.end.202
  %127 = phi i1 [ true, %if.end.202 ], [ false, %126 ]
  %lor.ext = zext i1 %127 to i32
  %128 = load i32, i32* %wn, align 4, !tbaa !5
  %idxprom205 = sext i32 %128 to i64
  %129 = load %struct.work*, %struct.work** @WorkList, align 8, !tbaa !1
  %arrayidx206 = getelementptr inbounds %struct.work, %struct.work* %129, i64 %idxprom205
  store %struct.work* %arrayidx206, %struct.work** %w, align 8, !tbaa !1
  %arraydecay207 = getelementptr inbounds [4096 x i8], [4096 x i8]* %qf, i32 0, i32 0
  %arraydecay208 = getelementptr inbounds [4096 x i8], [4096 x i8]* %qd, i32 0, i32 0
  %130 = load %struct.dirent*, %struct.dirent** %d, align 8, !tbaa !1
  %d_name209 = getelementptr inbounds %struct.dirent, %struct.dirent* %130, i32 0, i32 4
  %arraydecay210 = getelementptr inbounds [256 x i8], [256 x i8]* %d_name209, i32 0, i32 0
  %call211 = call i64 (i8*, i64, i32, ...) @sm_strlcpyn(i8* %arraydecay207, i64 4096, i32 3, i8* %arraydecay208, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.111, i32 0, i32 0), i8* %arraydecay210)
  %arraydecay212 = getelementptr inbounds [4096 x i8], [4096 x i8]* %qf, i32 0, i32 0
  %call213 = call i32 @stat(i8* %arraydecay212, %struct.stat* %sbuf) #1
  %cmp214 = icmp slt i32 %call213, 0
  br i1 %cmp214, label %if.then.216, label %if.end.225

if.then.216:                                      ; preds = %lor.end
  %call217 = call i32* @__errno_location() #11
  %131 = load i32, i32* %call217, align 4, !tbaa !5
  %cmp218 = icmp ne i32 %131, 2
  br i1 %cmp218, label %if.then.220, label %if.end.224

if.then.220:                                      ; preds = %if.then.216
  %132 = load i32, i32* %qgrp.addr, align 4, !tbaa !5
  %133 = load i32, i32* %qdir.addr, align 4, !tbaa !5
  %call221 = call i8* @qid_printqueue(i32 %132, i32 %133)
  %134 = load %struct.dirent*, %struct.dirent** %d, align 8, !tbaa !1
  %d_name222 = getelementptr inbounds %struct.dirent, %struct.dirent* %134, i32 0, i32 4
  %arraydecay223 = getelementptr inbounds [256 x i8], [256 x i8]* %d_name222, i32 0, i32 0
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 6, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.216, i32 0, i32 0), i8* %call221, i8* %arraydecay223)
  br label %if.end.224

if.end.224:                                       ; preds = %if.then.220, %if.then.216
  %135 = load i32, i32* %wn, align 4, !tbaa !5
  %dec = add nsw i32 %135, -1
  store i32 %dec, i32* %wn, align 4, !tbaa !5
  store i32 10, i32* %cleanup.dest.slot
  br label %cleanup

if.end.225:                                       ; preds = %lor.end
  %st_mode = getelementptr inbounds %struct.stat, %struct.stat* %sbuf, i32 0, i32 3
  %136 = load i32, i32* %st_mode, align 4, !tbaa !126
  %and226 = and i32 %136, 32768
  %cmp227 = icmp ne i32 %and226, 0
  br i1 %cmp227, label %if.end.277, label %if.then.229

if.then.229:                                      ; preds = %if.end.225
  %137 = load %struct.dirent*, %struct.dirent** %d, align 8, !tbaa !1
  %d_name230 = getelementptr inbounds %struct.dirent, %struct.dirent* %137, i32 0, i32 4
  %arrayidx231 = getelementptr inbounds [256 x i8], [256 x i8]* %d_name230, i32 0, i64 0
  %138 = load i8, i8* %arrayidx231, align 1, !tbaa !17
  %conv232 = sext i8 %138 to i32
  %cmp233 = icmp eq i32 %conv232, 100
  br i1 %cmp233, label %land.lhs.true.259, label %lor.lhs.false.235

lor.lhs.false.235:                                ; preds = %if.then.229
  %139 = load %struct.dirent*, %struct.dirent** %d, align 8, !tbaa !1
  %d_name236 = getelementptr inbounds %struct.dirent, %struct.dirent* %139, i32 0, i32 4
  %arrayidx237 = getelementptr inbounds [256 x i8], [256 x i8]* %d_name236, i32 0, i64 0
  %140 = load i8, i8* %arrayidx237, align 1, !tbaa !17
  %conv238 = sext i8 %140 to i32
  %cmp239 = icmp eq i32 %conv238, 113
  br i1 %cmp239, label %land.lhs.true.259, label %lor.lhs.false.241

lor.lhs.false.241:                                ; preds = %lor.lhs.false.235
  %141 = load %struct.dirent*, %struct.dirent** %d, align 8, !tbaa !1
  %d_name242 = getelementptr inbounds %struct.dirent, %struct.dirent* %141, i32 0, i32 4
  %arrayidx243 = getelementptr inbounds [256 x i8], [256 x i8]* %d_name242, i32 0, i64 0
  %142 = load i8, i8* %arrayidx243, align 1, !tbaa !17
  %conv244 = sext i8 %142 to i32
  %cmp245 = icmp eq i32 %conv244, 104
  br i1 %cmp245, label %land.lhs.true.259, label %lor.lhs.false.247

lor.lhs.false.247:                                ; preds = %lor.lhs.false.241
  %143 = load %struct.dirent*, %struct.dirent** %d, align 8, !tbaa !1
  %d_name248 = getelementptr inbounds %struct.dirent, %struct.dirent* %143, i32 0, i32 4
  %arrayidx249 = getelementptr inbounds [256 x i8], [256 x i8]* %d_name248, i32 0, i64 0
  %144 = load i8, i8* %arrayidx249, align 1, !tbaa !17
  %conv250 = sext i8 %144 to i32
  %cmp251 = icmp eq i32 %conv250, 81
  br i1 %cmp251, label %land.lhs.true.259, label %lor.lhs.false.253

lor.lhs.false.253:                                ; preds = %lor.lhs.false.247
  %145 = load %struct.dirent*, %struct.dirent** %d, align 8, !tbaa !1
  %d_name254 = getelementptr inbounds %struct.dirent, %struct.dirent* %145, i32 0, i32 4
  %arrayidx255 = getelementptr inbounds [256 x i8], [256 x i8]* %d_name254, i32 0, i64 0
  %146 = load i8, i8* %arrayidx255, align 1, !tbaa !17
  %conv256 = sext i8 %146 to i32
  %cmp257 = icmp eq i32 %conv256, 120
  br i1 %cmp257, label %land.lhs.true.259, label %if.then.271

land.lhs.true.259:                                ; preds = %lor.lhs.false.253, %lor.lhs.false.247, %lor.lhs.false.241, %lor.lhs.false.235, %if.then.229
  %147 = load %struct.dirent*, %struct.dirent** %d, align 8, !tbaa !1
  %d_name260 = getelementptr inbounds %struct.dirent, %struct.dirent* %147, i32 0, i32 4
  %arrayidx261 = getelementptr inbounds [256 x i8], [256 x i8]* %d_name260, i32 0, i64 1
  %148 = load i8, i8* %arrayidx261, align 1, !tbaa !17
  %conv262 = sext i8 %148 to i32
  %cmp263 = icmp eq i32 %conv262, 102
  br i1 %cmp263, label %land.lhs.true.265, label %if.then.271

land.lhs.true.265:                                ; preds = %land.lhs.true.259
  %149 = load %struct.dirent*, %struct.dirent** %d, align 8, !tbaa !1
  %d_name266 = getelementptr inbounds %struct.dirent, %struct.dirent* %149, i32 0, i32 4
  %arrayidx267 = getelementptr inbounds [256 x i8], [256 x i8]* %d_name266, i32 0, i64 2
  %150 = load i8, i8* %arrayidx267, align 1, !tbaa !17
  %conv268 = sext i8 %150 to i32
  %cmp269 = icmp eq i32 %conv268, 0
  br i1 %cmp269, label %if.end.275, label %if.then.271

if.then.271:                                      ; preds = %land.lhs.true.265, %land.lhs.true.259, %lor.lhs.false.253
  %151 = load i32, i32* %qgrp.addr, align 4, !tbaa !5
  %152 = load i32, i32* %qdir.addr, align 4, !tbaa !5
  %call272 = call i8* @qid_printqueue(i32 %151, i32 %152)
  %153 = load %struct.dirent*, %struct.dirent** %d, align 8, !tbaa !1
  %d_name273 = getelementptr inbounds %struct.dirent, %struct.dirent* %153, i32 0, i32 4
  %arraydecay274 = getelementptr inbounds [256 x i8], [256 x i8]* %d_name273, i32 0, i32 0
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.217, i32 0, i32 0), i8* %call272, i8* %arraydecay274)
  br label %if.end.275

if.end.275:                                       ; preds = %if.then.271, %land.lhs.true.265
  %154 = load i32, i32* %wn, align 4, !tbaa !5
  %dec276 = add nsw i32 %154, -1
  store i32 %dec276, i32* %wn, align 4, !tbaa !5
  store i32 10, i32* %cleanup.dest.slot
  br label %cleanup

if.end.277:                                       ; preds = %if.end.225
  %155 = load i32, i32* @QueueSortOrder, align 4, !tbaa !5
  %cmp278 = icmp eq i32 %155, 3
  br i1 %cmp278, label %land.lhs.true.289, label %lor.lhs.false.280

lor.lhs.false.280:                                ; preds = %if.end.277
  %156 = load i32, i32* @QueueSortOrder, align 4, !tbaa !5
  %cmp281 = icmp eq i32 %156, 5
  br i1 %cmp281, label %land.lhs.true.289, label %lor.lhs.false.283

lor.lhs.false.283:                                ; preds = %lor.lhs.false.280
  %157 = load i32, i32* @QueueSortOrder, align 4, !tbaa !5
  %cmp284 = icmp eq i32 %157, 6
  br i1 %cmp284, label %land.lhs.true.289, label %lor.lhs.false.286

lor.lhs.false.286:                                ; preds = %lor.lhs.false.283
  %158 = load i32, i32* @QueueSortOrder, align 4, !tbaa !5
  %cmp287 = icmp eq i32 %158, 4
  br i1 %cmp287, label %land.lhs.true.289, label %if.end.303

land.lhs.true.289:                                ; preds = %lor.lhs.false.286, %lor.lhs.false.283, %lor.lhs.false.280, %if.end.277
  %159 = load %struct.queue_char*, %struct.queue_char** @QueueLimitQuarantine, align 8, !tbaa !1
  %cmp290 = icmp eq %struct.queue_char* %159, null
  br i1 %cmp290, label %land.lhs.true.292, label %if.end.303

land.lhs.true.292:                                ; preds = %land.lhs.true.289
  %160 = load %struct.queue_char*, %struct.queue_char** @QueueLimitSender, align 8, !tbaa !1
  %cmp293 = icmp eq %struct.queue_char* %160, null
  br i1 %cmp293, label %land.lhs.true.295, label %if.end.303

land.lhs.true.295:                                ; preds = %land.lhs.true.292
  %161 = load %struct.queue_char*, %struct.queue_char** @QueueLimitRecipient, align 8, !tbaa !1
  %cmp296 = icmp eq %struct.queue_char* %161, null
  br i1 %cmp296, label %if.then.298, label %if.end.303

if.then.298:                                      ; preds = %land.lhs.true.295
  %162 = load i32, i32* %qgrp.addr, align 4, !tbaa !5
  %163 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_qgrp = getelementptr inbounds %struct.work, %struct.work* %163, i32 0, i32 7
  store i32 %162, i32* %w_qgrp, align 4, !tbaa !127
  %164 = load i32, i32* %qdir.addr, align 4, !tbaa !5
  %165 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_qdir = getelementptr inbounds %struct.work, %struct.work* %165, i32 0, i32 8
  store i32 %164, i32* %w_qdir, align 4, !tbaa !128
  %166 = load %struct.dirent*, %struct.dirent** %d, align 8, !tbaa !1
  %d_name299 = getelementptr inbounds %struct.dirent, %struct.dirent* %166, i32 0, i32 4
  %arraydecay300 = getelementptr inbounds [256 x i8], [256 x i8]* %d_name299, i32 0, i32 0
  %call301 = call i8* @newstr(i8* %arraydecay300)
  %167 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_name = getelementptr inbounds %struct.work, %struct.work* %167, i32 0, i32 0
  store i8* %call301, i8** %w_name, align 8, !tbaa !129
  %168 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_host = getelementptr inbounds %struct.work, %struct.work* %168, i32 0, i32 1
  store i8* null, i8** %w_host, align 8, !tbaa !130
  %169 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_tooyoung = getelementptr inbounds %struct.work, %struct.work* %169, i32 0, i32 3
  store i32 0, i32* %w_tooyoung, align 4, !tbaa !131
  %170 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_lock = getelementptr inbounds %struct.work, %struct.work* %170, i32 0, i32 2
  store i32 0, i32* %w_lock, align 4, !tbaa !132
  %171 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_pri = getelementptr inbounds %struct.work, %struct.work* %171, i32 0, i32 4
  store i64 0, i64* %w_pri, align 8, !tbaa !133
  %172 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_ctime = getelementptr inbounds %struct.work, %struct.work* %172, i32 0, i32 5
  store i64 0, i64* %w_ctime, align 8, !tbaa !134
  %st_mtim = getelementptr inbounds %struct.stat, %struct.stat* %sbuf, i32 0, i32 12
  %tv_sec = getelementptr inbounds %struct.timespec, %struct.timespec* %st_mtim, i32 0, i32 0
  %173 = load i64, i64* %tv_sec, align 8, !tbaa !135
  %174 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_mtime = getelementptr inbounds %struct.work, %struct.work* %174, i32 0, i32 6
  store i64 %173, i64* %w_mtime, align 8, !tbaa !136
  %175 = load i32, i32* %num_ent, align 4, !tbaa !5
  %inc302 = add nsw i32 %175, 1
  store i32 %inc302, i32* %num_ent, align 4, !tbaa !5
  store i32 10, i32* %cleanup.dest.slot
  br label %cleanup

if.end.303:                                       ; preds = %land.lhs.true.295, %land.lhs.true.292, %land.lhs.true.289, %lor.lhs.false.286
  %arraydecay304 = getelementptr inbounds [4096 x i8], [4096 x i8]* %qf, i32 0, i32 0
  %call305 = call %struct.sm_file* @sm_io_open(%struct.sm_file* @SmFtStdio_def, i32 -2, i8* %arraydecay304, i32 2, i8* null)
  store %struct.sm_file* %call305, %struct.sm_file** %cf, align 8, !tbaa !1
  %176 = load %struct.sm_file*, %struct.sm_file** %cf, align 8, !tbaa !1
  %cmp306 = icmp eq %struct.sm_file* %176, null
  br i1 %cmp306, label %land.lhs.true.308, label %if.end.326

land.lhs.true.308:                                ; preds = %if.end.303
  %177 = load i8, i8* @OpMode, align 1, !tbaa !17
  %conv309 = sext i8 %177 to i32
  %cmp310 = icmp ne i32 %conv309, 112
  br i1 %cmp310, label %if.then.312, label %if.end.326

if.then.312:                                      ; preds = %land.lhs.true.308
  %178 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 41), align 1, !tbaa !17
  %conv313 = zext i8 %178 to i32
  %cmp314 = icmp sge i32 %conv313, 2
  br i1 %cmp314, label %land.lhs.true.316, label %if.end.323

land.lhs.true.316:                                ; preds = %if.then.312
  %179 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool317 = icmp ne i32 %179, 0
  br i1 %tobool317, label %if.end.323, label %if.then.318

if.then.318:                                      ; preds = %land.lhs.true.316
  %180 = load %struct.dirent*, %struct.dirent** %d, align 8, !tbaa !1
  %d_name319 = getelementptr inbounds %struct.dirent, %struct.dirent* %180, i32 0, i32 4
  %arraydecay320 = getelementptr inbounds [256 x i8], [256 x i8]* %d_name319, i32 0, i32 0
  %call321 = call i32* @__errno_location() #11
  %181 = load i32, i32* %call321, align 4, !tbaa !5
  %call322 = call i8* @sm_errstring(i32 %181)
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.218, i32 0, i32 0), i8* %arraydecay320, i8* %call322)
  br label %if.end.323

if.end.323:                                       ; preds = %if.then.318, %land.lhs.true.316, %if.then.312
  %call324 = call i32* @__errno_location() #11
  store i32 0, i32* %call324, align 4, !tbaa !5
  %182 = load i32, i32* %wn, align 4, !tbaa !5
  %dec325 = add nsw i32 %182, -1
  store i32 %dec325, i32* %wn, align 4, !tbaa !5
  store i32 10, i32* %cleanup.dest.slot
  br label %cleanup

if.end.326:                                       ; preds = %land.lhs.true.308, %if.end.303
  %183 = load i32, i32* %qgrp.addr, align 4, !tbaa !5
  %184 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_qgrp327 = getelementptr inbounds %struct.work, %struct.work* %184, i32 0, i32 7
  store i32 %183, i32* %w_qgrp327, align 4, !tbaa !127
  %185 = load i32, i32* %qdir.addr, align 4, !tbaa !5
  %186 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_qdir328 = getelementptr inbounds %struct.work, %struct.work* %186, i32 0, i32 8
  store i32 %185, i32* %w_qdir328, align 4, !tbaa !128
  %187 = load %struct.dirent*, %struct.dirent** %d, align 8, !tbaa !1
  %d_name329 = getelementptr inbounds %struct.dirent, %struct.dirent* %187, i32 0, i32 4
  %arraydecay330 = getelementptr inbounds [256 x i8], [256 x i8]* %d_name329, i32 0, i32 0
  %call331 = call i8* @newstr(i8* %arraydecay330)
  %188 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_name332 = getelementptr inbounds %struct.work, %struct.work* %188, i32 0, i32 0
  store i8* %call331, i8** %w_name332, align 8, !tbaa !129
  %189 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_host333 = getelementptr inbounds %struct.work, %struct.work* %189, i32 0, i32 1
  store i8* null, i8** %w_host333, align 8, !tbaa !130
  %190 = load %struct.sm_file*, %struct.sm_file** %cf, align 8, !tbaa !1
  %cmp334 = icmp ne %struct.sm_file* %190, null
  br i1 %cmp334, label %if.then.336, label %if.end.342

if.then.336:                                      ; preds = %if.end.326
  %191 = load %struct.sm_file*, %struct.sm_file** %cf, align 8, !tbaa !1
  %call337 = call i32 @sm_io_getinfo(%struct.sm_file* %191, i32 3, i8* null)
  %192 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_name338 = getelementptr inbounds %struct.work, %struct.work* %192, i32 0, i32 0
  %193 = load i8*, i8** %w_name338, align 8, !tbaa !129
  %call339 = call i32 @lockfile(i32 %call337, i8* %193, i8* null, i32 5)
  %tobool340 = icmp ne i32 %call339, 0
  %lnot = xor i1 %tobool340, true
  %lnot.ext = zext i1 %lnot to i32
  %194 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_lock341 = getelementptr inbounds %struct.work, %struct.work* %194, i32 0, i32 2
  store i32 %lnot.ext, i32* %w_lock341, align 4, !tbaa !132
  br label %if.end.342

if.end.342:                                       ; preds = %if.then.336, %if.end.326
  %195 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_tooyoung343 = getelementptr inbounds %struct.work, %struct.work* %195, i32 0, i32 3
  store i32 0, i32* %w_tooyoung343, align 4, !tbaa !131
  %196 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_pri344 = getelementptr inbounds %struct.work, %struct.work* %196, i32 0, i32 4
  store i64 2147483647, i64* %w_pri344, align 8, !tbaa !133
  %197 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_ctime345 = getelementptr inbounds %struct.work, %struct.work* %197, i32 0, i32 5
  store i64 0, i64* %w_ctime345, align 8, !tbaa !134
  %st_mtim346 = getelementptr inbounds %struct.stat, %struct.stat* %sbuf, i32 0, i32 12
  %tv_sec347 = getelementptr inbounds %struct.timespec, %struct.timespec* %st_mtim346, i32 0, i32 0
  %198 = load i64, i64* %tv_sec347, align 8, !tbaa !135
  %199 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_mtime348 = getelementptr inbounds %struct.work, %struct.work* %199, i32 0, i32 6
  store i64 %198, i64* %w_mtime348, align 8, !tbaa !136
  store i32 3, i32* %i, align 4, !tbaa !5
  %200 = load i32, i32* @QueueSortOrder, align 4, !tbaa !5
  %cmp349 = icmp eq i32 %200, 1
  br i1 %cmp349, label %if.then.351, label %if.end.352

if.then.351:                                      ; preds = %if.end.342
  %201 = load i32, i32* %i, align 4, !tbaa !5
  %or = or i32 %201, 16
  store i32 %or, i32* %i, align 4, !tbaa !5
  br label %if.end.352

if.end.352:                                       ; preds = %if.then.351, %if.end.342
  %202 = load %struct.queue_char*, %struct.queue_char** @QueueLimitSender, align 8, !tbaa !1
  %cmp353 = icmp ne %struct.queue_char* %202, null
  br i1 %cmp353, label %if.then.355, label %if.end.357

if.then.355:                                      ; preds = %if.end.352
  %203 = load i32, i32* %i, align 4, !tbaa !5
  %or356 = or i32 %203, 8
  store i32 %or356, i32* %i, align 4, !tbaa !5
  br label %if.end.357

if.end.357:                                       ; preds = %if.then.355, %if.end.352
  %204 = load %struct.queue_char*, %struct.queue_char** @QueueLimitRecipient, align 8, !tbaa !1
  %cmp358 = icmp ne %struct.queue_char* %204, null
  br i1 %cmp358, label %if.then.360, label %if.end.362

if.then.360:                                      ; preds = %if.end.357
  %205 = load i32, i32* %i, align 4, !tbaa !5
  %or361 = or i32 %205, 4
  store i32 %or361, i32* %i, align 4, !tbaa !5
  br label %if.end.362

if.end.362:                                       ; preds = %if.then.360, %if.end.357
  %206 = load %struct.queue_char*, %struct.queue_char** @QueueLimitQuarantine, align 8, !tbaa !1
  %cmp363 = icmp ne %struct.queue_char* %206, null
  br i1 %cmp363, label %if.then.365, label %if.end.367

if.then.365:                                      ; preds = %if.end.362
  %207 = load i32, i32* %i, align 4, !tbaa !5
  %or366 = or i32 %207, 64
  store i32 %or366, i32* %i, align 4, !tbaa !5
  br label %if.end.367

if.end.367:                                       ; preds = %if.then.365, %if.end.362
  br label %while.cond.368

while.cond.368:                                   ; preds = %sw.epilog, %if.end.367
  %208 = load %struct.sm_file*, %struct.sm_file** %cf, align 8, !tbaa !1
  %cmp369 = icmp ne %struct.sm_file* %208, null
  br i1 %cmp369, label %land.lhs.true.371, label %land.end.379

land.lhs.true.371:                                ; preds = %while.cond.368
  %209 = load i32, i32* %i, align 4, !tbaa !5
  %cmp372 = icmp ne i32 %209, 0
  br i1 %cmp372, label %land.rhs.374, label %land.end.379

land.rhs.374:                                     ; preds = %land.lhs.true.371
  %210 = load %struct.sm_file*, %struct.sm_file** %cf, align 8, !tbaa !1
  %arraydecay375 = getelementptr inbounds [257 x i8], [257 x i8]* %lbuf, i32 0, i32 0
  %call376 = call i32 @sm_io_fgets(%struct.sm_file* %210, i32 -2, i8* %arraydecay375, i32 257)
  %cmp377 = icmp sge i32 %call376, 0
  br label %land.end.379

land.end.379:                                     ; preds = %land.rhs.374, %land.lhs.true.371, %while.cond.368
  %211 = phi i1 [ false, %land.lhs.true.371 ], [ false, %while.cond.368 ], [ %cmp377, %land.rhs.374 ]
  br i1 %211, label %while.body.381, label %while.end.580

while.body.381:                                   ; preds = %land.end.379
  %212 = bitcast i32* %c to i8*
  call void @llvm.lifetime.start(i64 4, i8* %212) #1
  %213 = bitcast i64* %age to i8*
  call void @llvm.lifetime.start(i64 8, i8* %213) #1
  %arraydecay382 = getelementptr inbounds [257 x i8], [257 x i8]* %lbuf, i32 0, i32 0
  %call383 = call i8* @strchr(i8* %arraydecay382, i32 10) #1
  store i8* %call383, i8** %p, align 8, !tbaa !1
  %214 = load i8*, i8** %p, align 8, !tbaa !1
  %cmp384 = icmp ne i8* %214, null
  br i1 %cmp384, label %if.then.386, label %if.else.387

if.then.386:                                      ; preds = %while.body.381
  %215 = load i8*, i8** %p, align 8, !tbaa !1
  store i8 0, i8* %215, align 1, !tbaa !17
  br label %if.end.399

if.else.387:                                      ; preds = %while.body.381
  br label %while.cond.388

while.cond.388:                                   ; preds = %while.body.397, %if.else.387
  %216 = load %struct.sm_file*, %struct.sm_file** %cf, align 8, !tbaa !1
  %call389 = call i32 @sm_io_getc(%struct.sm_file* %216, i32 -2)
  store i32 %call389, i32* %c, align 4, !tbaa !5
  %cmp390 = icmp ne i32 %call389, -1
  br i1 %cmp390, label %land.rhs.392, label %land.end.395

land.rhs.392:                                     ; preds = %while.cond.388
  %217 = load i32, i32* %c, align 4, !tbaa !5
  %cmp393 = icmp ne i32 %217, 10
  br label %land.end.395

land.end.395:                                     ; preds = %land.rhs.392, %while.cond.388
  %218 = phi i1 [ false, %while.cond.388 ], [ %cmp393, %land.rhs.392 ]
  br i1 %218, label %while.body.397, label %while.end.398

while.body.397:                                   ; preds = %land.end.395
  br label %while.cond.388

while.end.398:                                    ; preds = %land.end.395
  br label %if.end.399

if.end.399:                                       ; preds = %while.end.398, %if.then.386
  %arrayidx400 = getelementptr inbounds [257 x i8], [257 x i8]* %lbuf, i32 0, i64 0
  %219 = load i8, i8* %arrayidx400, align 1, !tbaa !17
  %conv401 = sext i8 %219 to i32
  switch i32 %conv401, label %sw.epilog [
    i32 86, label %sw.bb
    i32 80, label %sw.bb.404
    i32 84, label %sw.bb.409
    i32 113, label %sw.bb.414
    i32 82, label %sw.bb.461
    i32 83, label %sw.bb.515
    i32 75, label %sw.bb.536
    i32 78, label %sw.bb.572
  ]

sw.bb:                                            ; preds = %if.end.399
  %arrayidx402 = getelementptr inbounds [257 x i8], [257 x i8]* %lbuf, i32 0, i64 1
  %call403 = call i32 @atoi(i8* %arrayidx402) #14
  store i32 %call403, i32* %qfver, align 4, !tbaa !5
  br label %sw.epilog

sw.bb.404:                                        ; preds = %if.end.399
  %arrayidx405 = getelementptr inbounds [257 x i8], [257 x i8]* %lbuf, i32 0, i64 1
  %call406 = call i64 @atol(i8* %arrayidx405) #14
  %220 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_pri407 = getelementptr inbounds %struct.work, %struct.work* %220, i32 0, i32 4
  store i64 %call406, i64* %w_pri407, align 8, !tbaa !133
  %221 = load i32, i32* %i, align 4, !tbaa !5
  %and408 = and i32 %221, -2
  store i32 %and408, i32* %i, align 4, !tbaa !5
  br label %sw.epilog

sw.bb.409:                                        ; preds = %if.end.399
  %arrayidx410 = getelementptr inbounds [257 x i8], [257 x i8]* %lbuf, i32 0, i64 1
  %call411 = call i64 @atol(i8* %arrayidx410) #14
  %222 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_ctime412 = getelementptr inbounds %struct.work, %struct.work* %222, i32 0, i32 5
  store i64 %call411, i64* %w_ctime412, align 8, !tbaa !134
  %223 = load i32, i32* %i, align 4, !tbaa !5
  %and413 = and i32 %223, -3
  store i32 %and413, i32* %i, align 4, !tbaa !5
  br label %sw.epilog

sw.bb.414:                                        ; preds = %if.end.399
  %224 = load i32, i32* @QueueMode, align 4, !tbaa !5
  %cmp415 = icmp ne i32 %224, 81
  br i1 %cmp415, label %land.lhs.true.417, label %if.else.430

land.lhs.true.417:                                ; preds = %sw.bb.414
  %225 = load i32, i32* @QueueMode, align 4, !tbaa !5
  %cmp418 = icmp ne i32 %225, 76
  br i1 %cmp418, label %if.then.420, label %if.else.430

if.then.420:                                      ; preds = %land.lhs.true.417
  %226 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 41), align 1, !tbaa !17
  %conv421 = zext i8 %226 to i32
  %cmp422 = icmp sge i32 %conv421, 49
  br i1 %cmp422, label %land.lhs.true.424, label %if.end.428

land.lhs.true.424:                                ; preds = %if.then.420
  %227 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool425 = icmp ne i32 %227, 0
  br i1 %tobool425, label %if.end.428, label %if.then.426

if.then.426:                                      ; preds = %land.lhs.true.424
  %228 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_name427 = getelementptr inbounds %struct.work, %struct.work* %228, i32 0, i32 0
  %229 = load i8*, i8** %w_name427, align 8, !tbaa !129
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.219, i32 0, i32 0), i8* %229)
  br label %if.end.428

if.end.428:                                       ; preds = %if.then.426, %land.lhs.true.424, %if.then.420
  %230 = load i32, i32* %i, align 4, !tbaa !5
  %or429 = or i32 %230, 32
  store i32 %or429, i32* %i, align 4, !tbaa !5
  br label %if.end.460

if.else.430:                                      ; preds = %land.lhs.true.417, %sw.bb.414
  %231 = load i32, i32* @QueueMode, align 4, !tbaa !5
  %cmp431 = icmp eq i32 %231, 81
  br i1 %cmp431, label %if.then.433, label %if.end.459

if.then.433:                                      ; preds = %if.else.430
  %232 = load %struct.queue_char*, %struct.queue_char** @QueueLimitQuarantine, align 8, !tbaa !1
  %cmp434 = icmp eq %struct.queue_char* %232, null
  br i1 %cmp434, label %if.then.436, label %if.end.438

if.then.436:                                      ; preds = %if.then.433
  %233 = load i32, i32* %i, align 4, !tbaa !5
  %and437 = and i32 %233, -65
  store i32 %and437, i32* %i, align 4, !tbaa !5
  br label %sw.epilog

if.end.438:                                       ; preds = %if.then.433
  %arrayidx439 = getelementptr inbounds [257 x i8], [257 x i8]* %lbuf, i32 0, i64 1
  store i8* %arrayidx439, i8** %p, align 8, !tbaa !1
  %234 = load %struct.queue_char*, %struct.queue_char** @QueueLimitQuarantine, align 8, !tbaa !1
  store %struct.queue_char* %234, %struct.queue_char** %check, align 8, !tbaa !1
  br label %while.cond.440

while.cond.440:                                   ; preds = %if.end.452, %if.end.438
  %235 = load %struct.queue_char*, %struct.queue_char** %check, align 8, !tbaa !1
  %cmp441 = icmp ne %struct.queue_char* %235, null
  br i1 %cmp441, label %while.body.443, label %while.end.453

while.body.443:                                   ; preds = %while.cond.440
  %236 = load %struct.queue_char*, %struct.queue_char** %check, align 8, !tbaa !1
  %queue_match444 = getelementptr inbounds %struct.queue_char, %struct.queue_char* %236, i32 0, i32 0
  %237 = load i8*, i8** %queue_match444, align 8, !tbaa !124
  %238 = load i8*, i8** %p, align 8, !tbaa !1
  %call445 = call i32 @strcontainedin(i32 0, i8* %237, i8* %238)
  %239 = load %struct.queue_char*, %struct.queue_char** %check, align 8, !tbaa !1
  %queue_negate446 = getelementptr inbounds %struct.queue_char, %struct.queue_char* %239, i32 0, i32 1
  %240 = load i32, i32* %queue_negate446, align 4, !tbaa !122
  %cmp447 = icmp ne i32 %call445, %240
  br i1 %cmp447, label %if.then.449, label %if.else.450

if.then.449:                                      ; preds = %while.body.443
  br label %while.end.453

if.else.450:                                      ; preds = %while.body.443
  %241 = load %struct.queue_char*, %struct.queue_char** %check, align 8, !tbaa !1
  %queue_next451 = getelementptr inbounds %struct.queue_char, %struct.queue_char* %241, i32 0, i32 2
  %242 = load %struct.queue_char*, %struct.queue_char** %queue_next451, align 8, !tbaa !125
  store %struct.queue_char* %242, %struct.queue_char** %check, align 8, !tbaa !1
  br label %if.end.452

if.end.452:                                       ; preds = %if.else.450
  br label %while.cond.440

while.end.453:                                    ; preds = %if.then.449, %while.cond.440
  %243 = load %struct.queue_char*, %struct.queue_char** %check, align 8, !tbaa !1
  %cmp454 = icmp ne %struct.queue_char* %243, null
  br i1 %cmp454, label %if.then.456, label %if.end.458

if.then.456:                                      ; preds = %while.end.453
  %244 = load i32, i32* %i, align 4, !tbaa !5
  %and457 = and i32 %244, -65
  store i32 %and457, i32* %i, align 4, !tbaa !5
  br label %if.end.458

if.end.458:                                       ; preds = %if.then.456, %while.end.453
  br label %if.end.459

if.end.459:                                       ; preds = %if.end.458, %if.else.430
  br label %if.end.460

if.end.460:                                       ; preds = %if.end.459, %if.end.428
  br label %sw.epilog

sw.bb.461:                                        ; preds = %if.end.399
  %245 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_host462 = getelementptr inbounds %struct.work, %struct.work* %245, i32 0, i32 1
  %246 = load i8*, i8** %w_host462, align 8, !tbaa !130
  %cmp463 = icmp eq i8* %246, null
  br i1 %cmp463, label %land.lhs.true.465, label %if.end.476

land.lhs.true.465:                                ; preds = %sw.bb.461
  %arrayidx466 = getelementptr inbounds [257 x i8], [257 x i8]* %lbuf, i32 0, i64 1
  %call467 = call i8* @strrchr(i8* %arrayidx466, i32 64) #14
  store i8* %call467, i8** %p, align 8, !tbaa !1
  %cmp468 = icmp ne i8* %call467, null
  br i1 %cmp468, label %if.then.470, label %if.end.476

if.then.470:                                      ; preds = %land.lhs.true.465
  %247 = load i8*, i8** %p, align 8, !tbaa !1
  %arrayidx471 = getelementptr inbounds i8, i8* %247, i64 1
  %call472 = call i8* @strrev(i8* %arrayidx471)
  %248 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_host473 = getelementptr inbounds %struct.work, %struct.work* %248, i32 0, i32 1
  store i8* %call472, i8** %w_host473, align 8, !tbaa !130
  %249 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_host474 = getelementptr inbounds %struct.work, %struct.work* %249, i32 0, i32 1
  %250 = load i8*, i8** %w_host474, align 8, !tbaa !130
  call void @makelower(i8* %250)
  %251 = load i32, i32* %i, align 4, !tbaa !5
  %and475 = and i32 %251, -17
  store i32 %and475, i32* %i, align 4, !tbaa !5
  br label %if.end.476

if.end.476:                                       ; preds = %if.then.470, %land.lhs.true.465, %sw.bb.461
  %252 = load %struct.queue_char*, %struct.queue_char** @QueueLimitRecipient, align 8, !tbaa !1
  %cmp477 = icmp eq %struct.queue_char* %252, null
  br i1 %cmp477, label %if.then.479, label %if.end.481

if.then.479:                                      ; preds = %if.end.476
  %253 = load i32, i32* %i, align 4, !tbaa !5
  %and480 = and i32 %253, -5
  store i32 %and480, i32* %i, align 4, !tbaa !5
  br label %sw.epilog

if.end.481:                                       ; preds = %if.end.476
  %254 = load i32, i32* %qfver, align 4, !tbaa !5
  %cmp482 = icmp sgt i32 %254, 0
  br i1 %cmp482, label %if.then.484, label %if.else.493

if.then.484:                                      ; preds = %if.end.481
  %arrayidx485 = getelementptr inbounds [257 x i8], [257 x i8]* %lbuf, i32 0, i64 1
  %call486 = call i8* @strchr(i8* %arrayidx485, i32 58) #1
  store i8* %call486, i8** %p, align 8, !tbaa !1
  %255 = load i8*, i8** %p, align 8, !tbaa !1
  %cmp487 = icmp eq i8* %255, null
  br i1 %cmp487, label %if.then.489, label %if.else.491

if.then.489:                                      ; preds = %if.then.484
  %arrayidx490 = getelementptr inbounds [257 x i8], [257 x i8]* %lbuf, i32 0, i64 1
  store i8* %arrayidx490, i8** %p, align 8, !tbaa !1
  br label %if.end.492

if.else.491:                                      ; preds = %if.then.484
  %256 = load i8*, i8** %p, align 8, !tbaa !1
  %incdec.ptr = getelementptr inbounds i8, i8* %256, i32 1
  store i8* %incdec.ptr, i8** %p, align 8, !tbaa !1
  br label %if.end.492

if.end.492:                                       ; preds = %if.else.491, %if.then.489
  br label %if.end.495

if.else.493:                                      ; preds = %if.end.481
  %arrayidx494 = getelementptr inbounds [257 x i8], [257 x i8]* %lbuf, i32 0, i64 1
  store i8* %arrayidx494, i8** %p, align 8, !tbaa !1
  br label %if.end.495

if.end.495:                                       ; preds = %if.else.493, %if.end.492
  %257 = load %struct.queue_char*, %struct.queue_char** @QueueLimitRecipient, align 8, !tbaa !1
  store %struct.queue_char* %257, %struct.queue_char** %check, align 8, !tbaa !1
  br label %while.cond.496

while.cond.496:                                   ; preds = %if.end.508, %if.end.495
  %258 = load %struct.queue_char*, %struct.queue_char** %check, align 8, !tbaa !1
  %cmp497 = icmp ne %struct.queue_char* %258, null
  br i1 %cmp497, label %while.body.499, label %while.end.509

while.body.499:                                   ; preds = %while.cond.496
  %259 = load %struct.queue_char*, %struct.queue_char** %check, align 8, !tbaa !1
  %queue_match500 = getelementptr inbounds %struct.queue_char, %struct.queue_char* %259, i32 0, i32 0
  %260 = load i8*, i8** %queue_match500, align 8, !tbaa !124
  %261 = load i8*, i8** %p, align 8, !tbaa !1
  %call501 = call i32 @strcontainedin(i32 1, i8* %260, i8* %261)
  %262 = load %struct.queue_char*, %struct.queue_char** %check, align 8, !tbaa !1
  %queue_negate502 = getelementptr inbounds %struct.queue_char, %struct.queue_char* %262, i32 0, i32 1
  %263 = load i32, i32* %queue_negate502, align 4, !tbaa !122
  %cmp503 = icmp ne i32 %call501, %263
  br i1 %cmp503, label %if.then.505, label %if.else.506

if.then.505:                                      ; preds = %while.body.499
  br label %while.end.509

if.else.506:                                      ; preds = %while.body.499
  %264 = load %struct.queue_char*, %struct.queue_char** %check, align 8, !tbaa !1
  %queue_next507 = getelementptr inbounds %struct.queue_char, %struct.queue_char* %264, i32 0, i32 2
  %265 = load %struct.queue_char*, %struct.queue_char** %queue_next507, align 8, !tbaa !125
  store %struct.queue_char* %265, %struct.queue_char** %check, align 8, !tbaa !1
  br label %if.end.508

if.end.508:                                       ; preds = %if.else.506
  br label %while.cond.496

while.end.509:                                    ; preds = %if.then.505, %while.cond.496
  %266 = load %struct.queue_char*, %struct.queue_char** %check, align 8, !tbaa !1
  %cmp510 = icmp ne %struct.queue_char* %266, null
  br i1 %cmp510, label %if.then.512, label %if.end.514

if.then.512:                                      ; preds = %while.end.509
  %267 = load i32, i32* %i, align 4, !tbaa !5
  %and513 = and i32 %267, -5
  store i32 %and513, i32* %i, align 4, !tbaa !5
  br label %if.end.514

if.end.514:                                       ; preds = %if.then.512, %while.end.509
  br label %sw.epilog

sw.bb.515:                                        ; preds = %if.end.399
  %268 = load %struct.queue_char*, %struct.queue_char** @QueueLimitSender, align 8, !tbaa !1
  store %struct.queue_char* %268, %struct.queue_char** %check, align 8, !tbaa !1
  br label %while.cond.516

while.cond.516:                                   ; preds = %if.end.529, %sw.bb.515
  %269 = load %struct.queue_char*, %struct.queue_char** %check, align 8, !tbaa !1
  %cmp517 = icmp ne %struct.queue_char* %269, null
  br i1 %cmp517, label %while.body.519, label %while.end.530

while.body.519:                                   ; preds = %while.cond.516
  %270 = load %struct.queue_char*, %struct.queue_char** %check, align 8, !tbaa !1
  %queue_match520 = getelementptr inbounds %struct.queue_char, %struct.queue_char* %270, i32 0, i32 0
  %271 = load i8*, i8** %queue_match520, align 8, !tbaa !124
  %arrayidx521 = getelementptr inbounds [257 x i8], [257 x i8]* %lbuf, i32 0, i64 1
  %call522 = call i32 @strcontainedin(i32 1, i8* %271, i8* %arrayidx521)
  %272 = load %struct.queue_char*, %struct.queue_char** %check, align 8, !tbaa !1
  %queue_negate523 = getelementptr inbounds %struct.queue_char, %struct.queue_char* %272, i32 0, i32 1
  %273 = load i32, i32* %queue_negate523, align 4, !tbaa !122
  %cmp524 = icmp ne i32 %call522, %273
  br i1 %cmp524, label %if.then.526, label %if.else.527

if.then.526:                                      ; preds = %while.body.519
  br label %while.end.530

if.else.527:                                      ; preds = %while.body.519
  %274 = load %struct.queue_char*, %struct.queue_char** %check, align 8, !tbaa !1
  %queue_next528 = getelementptr inbounds %struct.queue_char, %struct.queue_char* %274, i32 0, i32 2
  %275 = load %struct.queue_char*, %struct.queue_char** %queue_next528, align 8, !tbaa !125
  store %struct.queue_char* %275, %struct.queue_char** %check, align 8, !tbaa !1
  br label %if.end.529

if.end.529:                                       ; preds = %if.else.527
  br label %while.cond.516

while.end.530:                                    ; preds = %if.then.526, %while.cond.516
  %276 = load %struct.queue_char*, %struct.queue_char** %check, align 8, !tbaa !1
  %cmp531 = icmp ne %struct.queue_char* %276, null
  br i1 %cmp531, label %if.then.533, label %if.end.535

if.then.533:                                      ; preds = %while.end.530
  %277 = load i32, i32* %i, align 4, !tbaa !5
  %and534 = and i32 %277, -9
  store i32 %and534, i32* %i, align 4, !tbaa !5
  br label %if.end.535

if.end.535:                                       ; preds = %if.then.533, %while.end.530
  br label %sw.epilog

sw.bb.536:                                        ; preds = %if.end.399
  %278 = load i64, i64* @MaxQueueAge, align 8, !tbaa !92
  %cmp537 = icmp sgt i64 %278, 0
  br i1 %cmp537, label %if.then.539, label %if.end.556

if.then.539:                                      ; preds = %sw.bb.536
  %279 = bitcast i64* %lasttry to i8*
  call void @llvm.lifetime.start(i64 8, i8* %279) #1
  %280 = bitcast i64* %delay to i8*
  call void @llvm.lifetime.start(i64 8, i8* %280) #1
  %arrayidx540 = getelementptr inbounds [257 x i8], [257 x i8]* %lbuf, i32 0, i64 1
  %call541 = call i64 @atol(i8* %arrayidx540) #14
  store i64 %call541, i64* %lasttry, align 8, !tbaa !92
  %281 = load i64, i64* %lasttry, align 8, !tbaa !92
  %282 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_ctime542 = getelementptr inbounds %struct.work, %struct.work* %282, i32 0, i32 5
  %283 = load i64, i64* %w_ctime542, align 8, !tbaa !134
  %sub543 = sub nsw i64 %281, %283
  %284 = load i64, i64* @MaxQueueAge, align 8, !tbaa !92
  %cmp544 = icmp slt i64 %sub543, %284
  br i1 %cmp544, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.539
  %285 = load i64, i64* %lasttry, align 8, !tbaa !92
  %286 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_ctime546 = getelementptr inbounds %struct.work, %struct.work* %286, i32 0, i32 5
  %287 = load i64, i64* %w_ctime546, align 8, !tbaa !134
  %sub547 = sub nsw i64 %285, %287
  br label %cond.end

cond.false:                                       ; preds = %if.then.539
  %288 = load i64, i64* @MaxQueueAge, align 8, !tbaa !92
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond548 = phi i64 [ %sub547, %cond.true ], [ %288, %cond.false ]
  store i64 %cond548, i64* %delay, align 8, !tbaa !92
  %call549 = call i64 @curtime()
  %289 = load i64, i64* %lasttry, align 8, !tbaa !92
  %sub550 = sub nsw i64 %call549, %289
  store i64 %sub550, i64* %age, align 8, !tbaa !92
  %290 = load i64, i64* %age, align 8, !tbaa !92
  %291 = load i64, i64* %delay, align 8, !tbaa !92
  %cmp551 = icmp slt i64 %290, %291
  br i1 %cmp551, label %if.then.553, label %if.end.555

if.then.553:                                      ; preds = %cond.end
  %292 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_tooyoung554 = getelementptr inbounds %struct.work, %struct.work* %292, i32 0, i32 3
  store i32 1, i32* %w_tooyoung554, align 4, !tbaa !131
  br label %if.end.555

if.end.555:                                       ; preds = %if.then.553, %cond.end
  store i32 18, i32* %cleanup.dest.slot
  %293 = bitcast i64* %delay to i8*
  call void @llvm.lifetime.end(i64 8, i8* %293) #1
  %294 = bitcast i64* %lasttry to i8*
  call void @llvm.lifetime.end(i64 8, i8* %294) #1
  br label %sw.epilog

if.end.556:                                       ; preds = %sw.bb.536
  %call557 = call i64 @curtime()
  %arrayidx558 = getelementptr inbounds [257 x i8], [257 x i8]* %lbuf, i32 0, i64 1
  %call559 = call i64 @atol(i8* %arrayidx558) #14
  %sub560 = sub nsw i64 %call557, %call559
  store i64 %sub560, i64* %age, align 8, !tbaa !92
  %295 = load i64, i64* %age, align 8, !tbaa !92
  %cmp561 = icmp sge i64 %295, 0
  br i1 %cmp561, label %land.lhs.true.563, label %if.end.571

land.lhs.true.563:                                ; preds = %if.end.556
  %296 = load i64, i64* @MinQueueAge, align 8, !tbaa !92
  %cmp564 = icmp sgt i64 %296, 0
  br i1 %cmp564, label %land.lhs.true.566, label %if.end.571

land.lhs.true.566:                                ; preds = %land.lhs.true.563
  %297 = load i64, i64* %age, align 8, !tbaa !92
  %298 = load i64, i64* @MinQueueAge, align 8, !tbaa !92
  %cmp567 = icmp slt i64 %297, %298
  br i1 %cmp567, label %if.then.569, label %if.end.571

if.then.569:                                      ; preds = %land.lhs.true.566
  %299 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_tooyoung570 = getelementptr inbounds %struct.work, %struct.work* %299, i32 0, i32 3
  store i32 1, i32* %w_tooyoung570, align 4, !tbaa !131
  br label %if.end.571

if.end.571:                                       ; preds = %if.then.569, %land.lhs.true.566, %land.lhs.true.563, %if.end.556
  br label %sw.epilog

sw.bb.572:                                        ; preds = %if.end.399
  %arrayidx573 = getelementptr inbounds [257 x i8], [257 x i8]* %lbuf, i32 0, i64 1
  %call574 = call i64 @atol(i8* %arrayidx573) #14
  %cmp575 = icmp eq i64 %call574, 0
  br i1 %cmp575, label %if.then.577, label %if.end.579

if.then.577:                                      ; preds = %sw.bb.572
  %300 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_tooyoung578 = getelementptr inbounds %struct.work, %struct.work* %300, i32 0, i32 3
  store i32 0, i32* %w_tooyoung578, align 4, !tbaa !131
  br label %if.end.579

if.end.579:                                       ; preds = %if.then.577, %sw.bb.572
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end.399, %if.end.579, %if.end.571, %if.end.555, %if.end.535, %if.end.514, %if.then.479, %if.end.460, %if.then.436, %sw.bb.409, %sw.bb.404, %sw.bb
  %301 = bitcast i64* %age to i8*
  call void @llvm.lifetime.end(i64 8, i8* %301) #1
  %302 = bitcast i32* %c to i8*
  call void @llvm.lifetime.end(i64 4, i8* %302) #1
  br label %while.cond.368

while.end.580:                                    ; preds = %land.end.379
  %303 = load %struct.sm_file*, %struct.sm_file** %cf, align 8, !tbaa !1
  %cmp581 = icmp ne %struct.sm_file* %303, null
  br i1 %cmp581, label %if.then.583, label %if.end.585

if.then.583:                                      ; preds = %while.end.580
  %304 = load %struct.sm_file*, %struct.sm_file** %cf, align 8, !tbaa !1
  %call584 = call i32 @sm_io_close(%struct.sm_file* %304, i32 -2)
  br label %if.end.585

if.end.585:                                       ; preds = %if.then.583, %while.end.580
  %305 = load i32, i32* %doall.addr, align 4, !tbaa !5
  %tobool586 = icmp ne i32 %305, 0
  br i1 %tobool586, label %lor.lhs.false.595, label %land.lhs.true.587

land.lhs.true.587:                                ; preds = %if.end.585
  %306 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_pri588 = getelementptr inbounds %struct.work, %struct.work* %306, i32 0, i32 4
  %307 = load i64, i64* %w_pri588, align 8, !tbaa !133
  %308 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_ctime589 = getelementptr inbounds %struct.work, %struct.work* %308, i32 0, i32 5
  %309 = load i64, i64* %w_ctime589, align 8, !tbaa !134
  %call590 = call i32 @shouldqueue(i64 %307, i64 %309)
  %tobool591 = icmp ne i32 %call590, 0
  br i1 %tobool591, label %if.then.607, label %lor.lhs.false.592

lor.lhs.false.592:                                ; preds = %land.lhs.true.587
  %310 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_tooyoung593 = getelementptr inbounds %struct.work, %struct.work* %310, i32 0, i32 3
  %311 = load i32, i32* %w_tooyoung593, align 4, !tbaa !131
  %tobool594 = icmp ne i32 %311, 0
  br i1 %tobool594, label %if.then.607, label %lor.lhs.false.595

lor.lhs.false.595:                                ; preds = %lor.lhs.false.592, %if.end.585
  %312 = load i32, i32* %i, align 4, !tbaa !5
  %and596 = and i32 %312, 32
  %cmp597 = icmp ne i32 %and596, 0
  br i1 %cmp597, label %if.then.607, label %lor.lhs.false.599

lor.lhs.false.599:                                ; preds = %lor.lhs.false.595
  %313 = load i32, i32* %i, align 4, !tbaa !5
  %and600 = and i32 %313, 64
  %cmp601 = icmp ne i32 %and600, 0
  br i1 %cmp601, label %if.then.607, label %lor.lhs.false.603

lor.lhs.false.603:                                ; preds = %lor.lhs.false.599
  %314 = load i32, i32* %i, align 4, !tbaa !5
  %and604 = and i32 %314, 12
  %cmp605 = icmp ne i32 %and604, 0
  br i1 %cmp605, label %if.then.607, label %if.else.624

if.then.607:                                      ; preds = %lor.lhs.false.603, %lor.lhs.false.599, %lor.lhs.false.595, %lor.lhs.false.592, %land.lhs.true.587
  %315 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 41), align 1, !tbaa !17
  %conv608 = zext i8 %315 to i32
  %cmp609 = icmp sge i32 %conv608, 49
  br i1 %cmp609, label %land.lhs.true.611, label %if.end.615

land.lhs.true.611:                                ; preds = %if.then.607
  %316 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool612 = icmp ne i32 %316, 0
  br i1 %tobool612, label %if.end.615, label %if.then.613

if.then.613:                                      ; preds = %land.lhs.true.611
  %317 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_name614 = getelementptr inbounds %struct.work, %struct.work* %317, i32 0, i32 0
  %318 = load i8*, i8** %w_name614, align 8, !tbaa !129
  %319 = load i32, i32* %i, align 4, !tbaa !5
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.220, i32 0, i32 0), i8* %318, i32 %319)
  br label %if.end.615

if.end.615:                                       ; preds = %if.then.613, %land.lhs.true.611, %if.then.607
  %320 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_name616 = getelementptr inbounds %struct.work, %struct.work* %320, i32 0, i32 0
  %321 = load i8*, i8** %w_name616, align 8, !tbaa !129
  call void @sm_free_tagged(i8* %321, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 2908)
  %322 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_host617 = getelementptr inbounds %struct.work, %struct.work* %322, i32 0, i32 1
  %323 = load i8*, i8** %w_host617, align 8, !tbaa !130
  %cmp618 = icmp ne i8* %323, null
  br i1 %cmp618, label %if.then.620, label %if.end.622

if.then.620:                                      ; preds = %if.end.615
  %324 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_host621 = getelementptr inbounds %struct.work, %struct.work* %324, i32 0, i32 1
  %325 = load i8*, i8** %w_host621, align 8, !tbaa !130
  call void @sm_free_tagged(i8* %325, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 2910)
  br label %if.end.622

if.end.622:                                       ; preds = %if.then.620, %if.end.615
  %326 = load i32, i32* %wn, align 4, !tbaa !5
  %dec623 = add nsw i32 %326, -1
  store i32 %dec623, i32* %wn, align 4, !tbaa !5
  br label %if.end.626

if.else.624:                                      ; preds = %lor.lhs.false.603
  %327 = load i32, i32* %num_ent, align 4, !tbaa !5
  %inc625 = add nsw i32 %327, 1
  store i32 %inc625, i32* %num_ent, align 4, !tbaa !5
  br label %if.end.626

if.end.626:                                       ; preds = %if.else.624, %if.end.622
  store i32 0, i32* %cleanup.dest.slot
  br label %cleanup

cleanup:                                          ; preds = %if.end.626, %if.end.323, %if.then.298, %if.end.275, %if.end.224, %if.then.200, %if.end.193, %if.then.192, %if.then.174, %if.end.151, %if.end.125
  %328 = bitcast %struct.stat* %sbuf to i8*
  call void @llvm.lifetime.end(i64 144, i8* %328) #1
  %329 = bitcast [257 x i8]* %lbuf to i8*
  call void @llvm.lifetime.end(i64 257, i8* %329) #1
  %330 = bitcast i32* %qfver to i8*
  call void @llvm.lifetime.end(i64 4, i8* %330) #1
  %331 = bitcast %struct.sm_file** %cf to i8*
  call void @llvm.lifetime.end(i64 8, i8* %331) #1
  %cleanup.dest = load i32, i32* %cleanup.dest.slot
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %cleanup.cont
    i32 10, label %while.cond.74
    i32 11, label %while.end.630
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %while.cond.74

while.end.630:                                    ; preds = %cleanup, %while.cond.74
  %332 = load %struct.__dirstream*, %struct.__dirstream** %f, align 8, !tbaa !1
  %call631 = call i32 @closedir(%struct.__dirstream* %332)
  %333 = load i32, i32* %wn, align 4, !tbaa !5
  %inc632 = add nsw i32 %333, 1
  store i32 %inc632, i32* %wn, align 4, !tbaa !5
  %334 = load i32, i32* %wn, align 4, !tbaa !5
  %335 = load i32, i32* @WorkListCount, align 4, !tbaa !5
  %sub633 = sub nsw i32 %334, %335
  store i32 %sub633, i32* %i, align 4, !tbaa !5
  %336 = load i32, i32* %num_ent, align 4, !tbaa !5
  %337 = load i32, i32* @WorkListSize, align 4, !tbaa !5
  %cmp634 = icmp slt i32 %336, %337
  br i1 %cmp634, label %cond.true.636, label %cond.false.637

cond.true.636:                                    ; preds = %while.end.630
  %338 = load i32, i32* %num_ent, align 4, !tbaa !5
  br label %cond.end.638

cond.false.637:                                   ; preds = %while.end.630
  %339 = load i32, i32* @WorkListSize, align 4, !tbaa !5
  br label %cond.end.638

cond.end.638:                                     ; preds = %cond.false.637, %cond.true.636
  %cond639 = phi i32 [ %338, %cond.true.636 ], [ %339, %cond.false.637 ]
  %340 = load i32, i32* @WorkListCount, align 4, !tbaa !5
  %add = add nsw i32 %340, %cond639
  store i32 %add, i32* @WorkListCount, align 4, !tbaa !5
  %341 = load i32*, i32** %more.addr, align 8, !tbaa !1
  %cmp640 = icmp ne i32* %341, null
  br i1 %cmp640, label %if.then.642, label %if.end.645

if.then.642:                                      ; preds = %cond.end.638
  %342 = load i32, i32* @WorkListCount, align 4, !tbaa !5
  %343 = load i32, i32* %wn, align 4, !tbaa !5
  %cmp643 = icmp slt i32 %342, %343
  %conv644 = zext i1 %cmp643 to i32
  %344 = load i32*, i32** %more.addr, align 8, !tbaa !1
  store i32 %conv644, i32* %344, align 4, !tbaa !5
  br label %if.end.645

if.end.645:                                       ; preds = %if.then.642, %cond.end.638
  %345 = load i32*, i32** %full.addr, align 8, !tbaa !1
  %cmp646 = icmp ne i32* %345, null
  br i1 %cmp646, label %if.then.648, label %if.end.664

if.then.648:                                      ; preds = %if.end.645
  %346 = load i32, i32* %wn, align 4, !tbaa !5
  %347 = load i32, i32* @MaxQueueRun, align 4, !tbaa !5
  %cmp649 = icmp sge i32 %346, %347
  br i1 %cmp649, label %land.lhs.true.651, label %lor.rhs.654

land.lhs.true.651:                                ; preds = %if.then.648
  %348 = load i32, i32* @MaxQueueRun, align 4, !tbaa !5
  %cmp652 = icmp sgt i32 %348, 0
  br i1 %cmp652, label %lor.end.662, label %lor.rhs.654

lor.rhs.654:                                      ; preds = %land.lhs.true.651, %if.then.648
  %349 = load %struct.work*, %struct.work** @WorkList, align 8, !tbaa !1
  %cmp655 = icmp eq %struct.work* %349, null
  br i1 %cmp655, label %land.rhs.657, label %land.end.660

land.rhs.657:                                     ; preds = %lor.rhs.654
  %350 = load i32, i32* %wn, align 4, !tbaa !5
  %cmp658 = icmp sgt i32 %350, 0
  br label %land.end.660

land.end.660:                                     ; preds = %land.rhs.657, %lor.rhs.654
  %351 = phi i1 [ false, %lor.rhs.654 ], [ %cmp658, %land.rhs.657 ]
  br label %lor.end.662

lor.end.662:                                      ; preds = %land.end.660, %land.lhs.true.651
  %352 = phi i1 [ true, %land.lhs.true.651 ], [ %351, %land.end.660 ]
  %lor.ext663 = zext i1 %352 to i32
  %353 = load i32*, i32** %full.addr, align 8, !tbaa !1
  store i32 %lor.ext663, i32* %353, align 4, !tbaa !5
  br label %if.end.664

if.end.664:                                       ; preds = %lor.end.662, %if.end.645
  %354 = load i32*, i32** %pnentries.addr, align 8, !tbaa !1
  %cmp665 = icmp ne i32* %354, null
  br i1 %cmp665, label %if.then.667, label %if.end.668

if.then.667:                                      ; preds = %if.end.664
  %355 = load i32, i32* %nentries, align 4, !tbaa !5
  %356 = load i32*, i32** %pnentries.addr, align 8, !tbaa !1
  store i32 %355, i32* %356, align 4, !tbaa !5
  br label %if.end.668

if.end.668:                                       ; preds = %if.then.667, %if.end.664
  %357 = load i32, i32* %i, align 4, !tbaa !5
  store i32 %357, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup.669

cleanup.669:                                      ; preds = %if.end.668, %if.end.72
  %358 = bitcast [4096 x i8]* %qf to i8*
  call void @llvm.lifetime.end(i64 4096, i8* %358) #1
  %359 = bitcast [4096 x i8]* %qd to i8*
  call void @llvm.lifetime.end(i64 4096, i8* %359) #1
  %360 = bitcast %struct.queue_char** %check to i8*
  call void @llvm.lifetime.end(i64 8, i8* %360) #1
  %361 = bitcast i32* %nentries to i8*
  call void @llvm.lifetime.end(i64 4, i8* %361) #1
  %362 = bitcast i32* %wn to i8*
  call void @llvm.lifetime.end(i64 4, i8* %362) #1
  %363 = bitcast i32* %num_ent to i8*
  call void @llvm.lifetime.end(i64 4, i8* %363) #1
  %364 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end(i64 4, i8* %364) #1
  %365 = bitcast %struct.__dirstream** %f to i8*
  call void @llvm.lifetime.end(i64 8, i8* %365) #1
  %366 = bitcast i8** %p to i8*
  call void @llvm.lifetime.end(i64 8, i8* %366) #1
  %367 = bitcast %struct.work** %w to i8*
  call void @llvm.lifetime.end(i64 8, i8* %367) #1
  %368 = bitcast %struct.dirent** %d to i8*
  call void @llvm.lifetime.end(i64 8, i8* %368) #1
  %369 = load i32, i32* %retval
  ret i32 %369

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @sortq(i32 %max) #0 {
entry:
  %retval = alloca i32, align 4
  %max.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %w = alloca %struct.work*, align 8
  %wc = alloca i32, align 4
  %nw = alloca %struct.work*, align 8
  %cleanup.dest.slot = alloca i32
  store i32 %max, i32* %max.addr, align 4, !tbaa !5
  %0 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start(i64 4, i8* %0) #1
  %1 = bitcast %struct.work** %w to i8*
  call void @llvm.lifetime.start(i64 8, i8* %1) #1
  %2 = bitcast i32* %wc to i8*
  call void @llvm.lifetime.start(i64 4, i8* %2) #1
  %3 = load i32, i32* @WorkListCount, align 4, !tbaa !5
  store i32 %3, i32* %wc, align 4, !tbaa !5
  %4 = load %struct.work*, %struct.work** @WorkQ, align 8, !tbaa !1
  %cmp = icmp ne %struct.work* %4, null
  br i1 %cmp, label %if.then, label %if.end.5

if.then:                                          ; preds = %entry
  %5 = bitcast %struct.work** %nw to i8*
  call void @llvm.lifetime.start(i64 8, i8* %5) #1
  %6 = load %struct.work*, %struct.work** @WorkQ, align 8, !tbaa !1
  store %struct.work* %6, %struct.work** %w, align 8, !tbaa !1
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %7 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %cmp1 = icmp ne %struct.work* %7, null
  br i1 %cmp1, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_next = getelementptr inbounds %struct.work, %struct.work* %8, i32 0, i32 9
  %9 = load %struct.work*, %struct.work** %w_next, align 8, !tbaa !118
  store %struct.work* %9, %struct.work** %nw, align 8, !tbaa !1
  %10 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_name = getelementptr inbounds %struct.work, %struct.work* %10, i32 0, i32 0
  %11 = load i8*, i8** %w_name, align 8, !tbaa !129
  call void @sm_free_tagged(i8* %11, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 2969)
  %12 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_host = getelementptr inbounds %struct.work, %struct.work* %12, i32 0, i32 1
  %13 = load i8*, i8** %w_host, align 8, !tbaa !130
  %cmp2 = icmp ne i8* %13, null
  br i1 %cmp2, label %if.then.3, label %if.end

if.then.3:                                        ; preds = %for.body
  %14 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_host4 = getelementptr inbounds %struct.work, %struct.work* %14, i32 0, i32 1
  %15 = load i8*, i8** %w_host4, align 8, !tbaa !130
  call void @sm_free_tagged(i8* %15, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 2971)
  br label %if.end

if.end:                                           ; preds = %if.then.3, %for.body
  %16 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %17 = bitcast %struct.work* %16 to i8*
  call void @sm_free_tagged(i8* %17, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 2972)
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %18 = load %struct.work*, %struct.work** %nw, align 8, !tbaa !1
  store %struct.work* %18, %struct.work** %w, align 8, !tbaa !1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store %struct.work* null, %struct.work** @WorkQ, align 8, !tbaa !1
  %19 = bitcast %struct.work** %nw to i8*
  call void @llvm.lifetime.end(i64 8, i8* %19) #1
  br label %if.end.5

if.end.5:                                         ; preds = %for.end, %entry
  %20 = load %struct.work*, %struct.work** @WorkList, align 8, !tbaa !1
  %cmp6 = icmp eq %struct.work* %20, null
  br i1 %cmp6, label %if.then.8, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end.5
  %21 = load i32, i32* %wc, align 4, !tbaa !5
  %cmp7 = icmp sle i32 %21, 0
  br i1 %cmp7, label %if.then.8, label %if.end.9

if.then.8:                                        ; preds = %lor.lhs.false, %if.end.5
  store i32 0, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.9:                                         ; preds = %lor.lhs.false
  %22 = load i32, i32* @QueueSortOrder, align 4, !tbaa !5
  %cmp10 = icmp eq i32 %22, 1
  br i1 %cmp10, label %if.then.11, label %if.else.60

if.then.11:                                       ; preds = %if.end.9
  %23 = load %struct.work*, %struct.work** @WorkList, align 8, !tbaa !1
  %24 = bitcast %struct.work* %23 to i8*
  %25 = load i32, i32* %wc, align 4, !tbaa !5
  %conv = sext i32 %25 to i64
  call void @qsort(i8* %24, i64 %conv, i64 64, i32 (i8*, i8*)* bitcast (i32 (%struct.work*, %struct.work*)* @workcmpf1 to i32 (i8*, i8*)*))
  store i32 0, i32* %i, align 4, !tbaa !5
  br label %while.cond

while.cond:                                       ; preds = %while.end, %if.then.14, %if.then.11
  %26 = load i32, i32* %i, align 4, !tbaa !5
  %27 = load i32, i32* %wc, align 4, !tbaa !5
  %cmp12 = icmp slt i32 %26, %27
  br i1 %cmp12, label %while.body, label %while.end.58

while.body:                                       ; preds = %while.cond
  %28 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom = sext i32 %28 to i64
  %29 = load %struct.work*, %struct.work** @WorkList, align 8, !tbaa !1
  %arrayidx = getelementptr inbounds %struct.work, %struct.work* %29, i64 %idxprom
  %w_lock = getelementptr inbounds %struct.work, %struct.work* %arrayidx, i32 0, i32 2
  %30 = load i32, i32* %w_lock, align 4, !tbaa !132
  %tobool = icmp ne i32 %30, 0
  br i1 %tobool, label %if.end.15, label %if.then.14

if.then.14:                                       ; preds = %while.body
  %31 = load i32, i32* %i, align 4, !tbaa !5
  %inc = add nsw i32 %31, 1
  store i32 %inc, i32* %i, align 4, !tbaa !5
  br label %while.cond

if.end.15:                                        ; preds = %while.body
  %32 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom16 = sext i32 %32 to i64
  %33 = load %struct.work*, %struct.work** @WorkList, align 8, !tbaa !1
  %arrayidx17 = getelementptr inbounds %struct.work, %struct.work* %33, i64 %idxprom16
  store %struct.work* %arrayidx17, %struct.work** %w, align 8, !tbaa !1
  br label %while.cond.18

while.cond.18:                                    ; preds = %if.end.57, %if.end.15
  %34 = load i32, i32* %i, align 4, !tbaa !5
  %inc19 = add nsw i32 %34, 1
  store i32 %inc19, i32* %i, align 4, !tbaa !5
  %35 = load i32, i32* %wc, align 4, !tbaa !5
  %cmp20 = icmp slt i32 %inc19, %35
  br i1 %cmp20, label %while.body.22, label %while.end

while.body.22:                                    ; preds = %while.cond.18
  %36 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom23 = sext i32 %36 to i64
  %37 = load %struct.work*, %struct.work** @WorkList, align 8, !tbaa !1
  %arrayidx24 = getelementptr inbounds %struct.work, %struct.work* %37, i64 %idxprom23
  %w_host25 = getelementptr inbounds %struct.work, %struct.work* %arrayidx24, i32 0, i32 1
  %38 = load i8*, i8** %w_host25, align 8, !tbaa !130
  %cmp26 = icmp eq i8* %38, null
  br i1 %cmp26, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %while.body.22
  %39 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_host28 = getelementptr inbounds %struct.work, %struct.work* %39, i32 0, i32 1
  %40 = load i8*, i8** %w_host28, align 8, !tbaa !130
  %cmp29 = icmp eq i8* %40, null
  br i1 %cmp29, label %if.then.31, label %if.else

if.then.31:                                       ; preds = %land.lhs.true
  %41 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom32 = sext i32 %41 to i64
  %42 = load %struct.work*, %struct.work** @WorkList, align 8, !tbaa !1
  %arrayidx33 = getelementptr inbounds %struct.work, %struct.work* %42, i64 %idxprom32
  %w_lock34 = getelementptr inbounds %struct.work, %struct.work* %arrayidx33, i32 0, i32 2
  store i32 1, i32* %w_lock34, align 4, !tbaa !132
  br label %if.end.57

if.else:                                          ; preds = %land.lhs.true, %while.body.22
  %43 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom35 = sext i32 %43 to i64
  %44 = load %struct.work*, %struct.work** @WorkList, align 8, !tbaa !1
  %arrayidx36 = getelementptr inbounds %struct.work, %struct.work* %44, i64 %idxprom35
  %w_host37 = getelementptr inbounds %struct.work, %struct.work* %arrayidx36, i32 0, i32 1
  %45 = load i8*, i8** %w_host37, align 8, !tbaa !130
  %cmp38 = icmp ne i8* %45, null
  br i1 %cmp38, label %land.lhs.true.40, label %if.else.55

land.lhs.true.40:                                 ; preds = %if.else
  %46 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_host41 = getelementptr inbounds %struct.work, %struct.work* %46, i32 0, i32 1
  %47 = load i8*, i8** %w_host41, align 8, !tbaa !130
  %cmp42 = icmp ne i8* %47, null
  br i1 %cmp42, label %land.lhs.true.44, label %if.else.55

land.lhs.true.44:                                 ; preds = %land.lhs.true.40
  %48 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom45 = sext i32 %48 to i64
  %49 = load %struct.work*, %struct.work** @WorkList, align 8, !tbaa !1
  %arrayidx46 = getelementptr inbounds %struct.work, %struct.work* %49, i64 %idxprom45
  %w_host47 = getelementptr inbounds %struct.work, %struct.work* %arrayidx46, i32 0, i32 1
  %50 = load i8*, i8** %w_host47, align 8, !tbaa !130
  %51 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_host48 = getelementptr inbounds %struct.work, %struct.work* %51, i32 0, i32 1
  %52 = load i8*, i8** %w_host48, align 8, !tbaa !130
  %call = call i32 @sm_strcasecmp(i8* %50, i8* %52)
  %cmp49 = icmp eq i32 %call, 0
  br i1 %cmp49, label %if.then.51, label %if.else.55

if.then.51:                                       ; preds = %land.lhs.true.44
  %53 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom52 = sext i32 %53 to i64
  %54 = load %struct.work*, %struct.work** @WorkList, align 8, !tbaa !1
  %arrayidx53 = getelementptr inbounds %struct.work, %struct.work* %54, i64 %idxprom52
  %w_lock54 = getelementptr inbounds %struct.work, %struct.work* %arrayidx53, i32 0, i32 2
  store i32 1, i32* %w_lock54, align 4, !tbaa !132
  br label %if.end.56

if.else.55:                                       ; preds = %land.lhs.true.44, %land.lhs.true.40, %if.else
  br label %while.end

if.end.56:                                        ; preds = %if.then.51
  br label %if.end.57

if.end.57:                                        ; preds = %if.end.56, %if.then.31
  br label %while.cond.18

while.end:                                        ; preds = %if.else.55, %while.cond.18
  br label %while.cond

while.end.58:                                     ; preds = %while.cond
  %55 = load %struct.work*, %struct.work** @WorkList, align 8, !tbaa !1
  %56 = bitcast %struct.work* %55 to i8*
  %57 = load i32, i32* %wc, align 4, !tbaa !5
  %conv59 = sext i32 %57 to i64
  call void @qsort(i8* %56, i64 %conv59, i64 64, i32 (i8*, i8*)* bitcast (i32 (%struct.work*, %struct.work*)* @workcmpf2 to i32 (i8*, i8*)*))
  br label %if.end.96

if.else.60:                                       ; preds = %if.end.9
  %58 = load i32, i32* @QueueSortOrder, align 4, !tbaa !5
  %cmp61 = icmp eq i32 %58, 2
  br i1 %cmp61, label %if.then.63, label %if.else.65

if.then.63:                                       ; preds = %if.else.60
  %59 = load %struct.work*, %struct.work** @WorkList, align 8, !tbaa !1
  %60 = bitcast %struct.work* %59 to i8*
  %61 = load i32, i32* %wc, align 4, !tbaa !5
  %conv64 = sext i32 %61 to i64
  call void @qsort(i8* %60, i64 %conv64, i64 64, i32 (i8*, i8*)* bitcast (i32 (%struct.work*, %struct.work*)* @workcmpf3 to i32 (i8*, i8*)*))
  br label %if.end.95

if.else.65:                                       ; preds = %if.else.60
  %62 = load i32, i32* @QueueSortOrder, align 4, !tbaa !5
  %cmp66 = icmp eq i32 %62, 3
  br i1 %cmp66, label %if.then.68, label %if.else.70

if.then.68:                                       ; preds = %if.else.65
  %63 = load %struct.work*, %struct.work** @WorkList, align 8, !tbaa !1
  %64 = bitcast %struct.work* %63 to i8*
  %65 = load i32, i32* %wc, align 4, !tbaa !5
  %conv69 = sext i32 %65 to i64
  call void @qsort(i8* %64, i64 %conv69, i64 64, i32 (i8*, i8*)* bitcast (i32 (%struct.work*, %struct.work*)* @workcmpf4 to i32 (i8*, i8*)*))
  br label %if.end.94

if.else.70:                                       ; preds = %if.else.65
  %66 = load i32, i32* @QueueSortOrder, align 4, !tbaa !5
  %cmp71 = icmp eq i32 %66, 4
  br i1 %cmp71, label %if.then.73, label %if.else.81

if.then.73:                                       ; preds = %if.else.70
  %call74 = call i64 @random() #1
  %rem = srem i64 %call74, 21
  %conv75 = trunc i64 %rem to i32
  store i32 %conv75, i32* @randi, align 4, !tbaa !5
  %67 = load i32, i32* @randi, align 4, !tbaa !5
  %cmp76 = icmp slt i32 %67, 2
  br i1 %cmp76, label %if.then.78, label %if.end.79

if.then.78:                                       ; preds = %if.then.73
  store i32 3, i32* @randi, align 4, !tbaa !5
  br label %if.end.79

if.end.79:                                        ; preds = %if.then.78, %if.then.73
  %68 = load %struct.work*, %struct.work** @WorkList, align 8, !tbaa !1
  %69 = bitcast %struct.work* %68 to i8*
  %70 = load i32, i32* %wc, align 4, !tbaa !5
  %conv80 = sext i32 %70 to i64
  call void @qsort(i8* %69, i64 %conv80, i64 64, i32 (i8*, i8*)* bitcast (i32 (%struct.work*, %struct.work*)* @workcmpf5 to i32 (i8*, i8*)*))
  br label %if.end.93

if.else.81:                                       ; preds = %if.else.70
  %71 = load i32, i32* @QueueSortOrder, align 4, !tbaa !5
  %cmp82 = icmp eq i32 %71, 5
  br i1 %cmp82, label %if.then.84, label %if.else.86

if.then.84:                                       ; preds = %if.else.81
  %72 = load %struct.work*, %struct.work** @WorkList, align 8, !tbaa !1
  %73 = bitcast %struct.work* %72 to i8*
  %74 = load i32, i32* %wc, align 4, !tbaa !5
  %conv85 = sext i32 %74 to i64
  call void @qsort(i8* %73, i64 %conv85, i64 64, i32 (i8*, i8*)* bitcast (i32 (%struct.work*, %struct.work*)* @workcmpf6 to i32 (i8*, i8*)*))
  br label %if.end.92

if.else.86:                                       ; preds = %if.else.81
  %75 = load i32, i32* @QueueSortOrder, align 4, !tbaa !5
  %cmp87 = icmp eq i32 %75, 0
  br i1 %cmp87, label %if.then.89, label %if.end.91

if.then.89:                                       ; preds = %if.else.86
  %76 = load %struct.work*, %struct.work** @WorkList, align 8, !tbaa !1
  %77 = bitcast %struct.work* %76 to i8*
  %78 = load i32, i32* %wc, align 4, !tbaa !5
  %conv90 = sext i32 %78 to i64
  call void @qsort(i8* %77, i64 %conv90, i64 64, i32 (i8*, i8*)* bitcast (i32 (%struct.work*, %struct.work*)* @workcmpf0 to i32 (i8*, i8*)*))
  br label %if.end.91

if.end.91:                                        ; preds = %if.then.89, %if.else.86
  br label %if.end.92

if.end.92:                                        ; preds = %if.end.91, %if.then.84
  br label %if.end.93

if.end.93:                                        ; preds = %if.end.92, %if.end.79
  br label %if.end.94

if.end.94:                                        ; preds = %if.end.93, %if.then.68
  br label %if.end.95

if.end.95:                                        ; preds = %if.end.94, %if.then.63
  br label %if.end.96

if.end.96:                                        ; preds = %if.end.95, %while.end.58
  %79 = load i32, i32* %wc, align 4, !tbaa !5
  %80 = load i32, i32* %max.addr, align 4, !tbaa !5
  %cmp97 = icmp sgt i32 %79, %80
  br i1 %cmp97, label %land.lhs.true.99, label %if.end.103

land.lhs.true.99:                                 ; preds = %if.end.96
  %81 = load i32, i32* %max.addr, align 4, !tbaa !5
  %cmp100 = icmp sgt i32 %81, 0
  br i1 %cmp100, label %if.then.102, label %if.end.103

if.then.102:                                      ; preds = %land.lhs.true.99
  %82 = load i32, i32* %max.addr, align 4, !tbaa !5
  store i32 %82, i32* %wc, align 4, !tbaa !5
  br label %if.end.103

if.end.103:                                       ; preds = %if.then.102, %land.lhs.true.99, %if.end.96
  %83 = load i32, i32* %wc, align 4, !tbaa !5
  store i32 %83, i32* %i, align 4, !tbaa !5
  br label %for.cond.104

for.cond.104:                                     ; preds = %for.body.107, %if.end.103
  %84 = load i32, i32* %i, align 4, !tbaa !5
  %dec = add nsw i32 %84, -1
  store i32 %dec, i32* %i, align 4, !tbaa !5
  %cmp105 = icmp sge i32 %dec, 0
  br i1 %cmp105, label %for.body.107, label %for.end.140

for.body.107:                                     ; preds = %for.cond.104
  %call108 = call i8* @xalloc_tagged(i32 64, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 3104)
  %85 = bitcast i8* %call108 to %struct.work*
  store %struct.work* %85, %struct.work** %w, align 8, !tbaa !1
  %86 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom109 = sext i32 %86 to i64
  %87 = load %struct.work*, %struct.work** @WorkList, align 8, !tbaa !1
  %arrayidx110 = getelementptr inbounds %struct.work, %struct.work* %87, i64 %idxprom109
  %w_qgrp = getelementptr inbounds %struct.work, %struct.work* %arrayidx110, i32 0, i32 7
  %88 = load i32, i32* %w_qgrp, align 4, !tbaa !127
  %89 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_qgrp111 = getelementptr inbounds %struct.work, %struct.work* %89, i32 0, i32 7
  store i32 %88, i32* %w_qgrp111, align 4, !tbaa !127
  %90 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom112 = sext i32 %90 to i64
  %91 = load %struct.work*, %struct.work** @WorkList, align 8, !tbaa !1
  %arrayidx113 = getelementptr inbounds %struct.work, %struct.work* %91, i64 %idxprom112
  %w_qdir = getelementptr inbounds %struct.work, %struct.work* %arrayidx113, i32 0, i32 8
  %92 = load i32, i32* %w_qdir, align 4, !tbaa !128
  %93 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_qdir114 = getelementptr inbounds %struct.work, %struct.work* %93, i32 0, i32 8
  store i32 %92, i32* %w_qdir114, align 4, !tbaa !128
  %94 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom115 = sext i32 %94 to i64
  %95 = load %struct.work*, %struct.work** @WorkList, align 8, !tbaa !1
  %arrayidx116 = getelementptr inbounds %struct.work, %struct.work* %95, i64 %idxprom115
  %w_name117 = getelementptr inbounds %struct.work, %struct.work* %arrayidx116, i32 0, i32 0
  %96 = load i8*, i8** %w_name117, align 8, !tbaa !129
  %97 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_name118 = getelementptr inbounds %struct.work, %struct.work* %97, i32 0, i32 0
  store i8* %96, i8** %w_name118, align 8, !tbaa !129
  %98 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom119 = sext i32 %98 to i64
  %99 = load %struct.work*, %struct.work** @WorkList, align 8, !tbaa !1
  %arrayidx120 = getelementptr inbounds %struct.work, %struct.work* %99, i64 %idxprom119
  %w_host121 = getelementptr inbounds %struct.work, %struct.work* %arrayidx120, i32 0, i32 1
  %100 = load i8*, i8** %w_host121, align 8, !tbaa !130
  %101 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_host122 = getelementptr inbounds %struct.work, %struct.work* %101, i32 0, i32 1
  store i8* %100, i8** %w_host122, align 8, !tbaa !130
  %102 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom123 = sext i32 %102 to i64
  %103 = load %struct.work*, %struct.work** @WorkList, align 8, !tbaa !1
  %arrayidx124 = getelementptr inbounds %struct.work, %struct.work* %103, i64 %idxprom123
  %w_lock125 = getelementptr inbounds %struct.work, %struct.work* %arrayidx124, i32 0, i32 2
  %104 = load i32, i32* %w_lock125, align 4, !tbaa !132
  %105 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_lock126 = getelementptr inbounds %struct.work, %struct.work* %105, i32 0, i32 2
  store i32 %104, i32* %w_lock126, align 4, !tbaa !132
  %106 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom127 = sext i32 %106 to i64
  %107 = load %struct.work*, %struct.work** @WorkList, align 8, !tbaa !1
  %arrayidx128 = getelementptr inbounds %struct.work, %struct.work* %107, i64 %idxprom127
  %w_tooyoung = getelementptr inbounds %struct.work, %struct.work* %arrayidx128, i32 0, i32 3
  %108 = load i32, i32* %w_tooyoung, align 4, !tbaa !131
  %109 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_tooyoung129 = getelementptr inbounds %struct.work, %struct.work* %109, i32 0, i32 3
  store i32 %108, i32* %w_tooyoung129, align 4, !tbaa !131
  %110 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom130 = sext i32 %110 to i64
  %111 = load %struct.work*, %struct.work** @WorkList, align 8, !tbaa !1
  %arrayidx131 = getelementptr inbounds %struct.work, %struct.work* %111, i64 %idxprom130
  %w_pri = getelementptr inbounds %struct.work, %struct.work* %arrayidx131, i32 0, i32 4
  %112 = load i64, i64* %w_pri, align 8, !tbaa !133
  %113 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_pri132 = getelementptr inbounds %struct.work, %struct.work* %113, i32 0, i32 4
  store i64 %112, i64* %w_pri132, align 8, !tbaa !133
  %114 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom133 = sext i32 %114 to i64
  %115 = load %struct.work*, %struct.work** @WorkList, align 8, !tbaa !1
  %arrayidx134 = getelementptr inbounds %struct.work, %struct.work* %115, i64 %idxprom133
  %w_ctime = getelementptr inbounds %struct.work, %struct.work* %arrayidx134, i32 0, i32 5
  %116 = load i64, i64* %w_ctime, align 8, !tbaa !134
  %117 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_ctime135 = getelementptr inbounds %struct.work, %struct.work* %117, i32 0, i32 5
  store i64 %116, i64* %w_ctime135, align 8, !tbaa !134
  %118 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom136 = sext i32 %118 to i64
  %119 = load %struct.work*, %struct.work** @WorkList, align 8, !tbaa !1
  %arrayidx137 = getelementptr inbounds %struct.work, %struct.work* %119, i64 %idxprom136
  %w_mtime = getelementptr inbounds %struct.work, %struct.work* %arrayidx137, i32 0, i32 6
  %120 = load i64, i64* %w_mtime, align 8, !tbaa !136
  %121 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_mtime138 = getelementptr inbounds %struct.work, %struct.work* %121, i32 0, i32 6
  store i64 %120, i64* %w_mtime138, align 8, !tbaa !136
  %122 = load %struct.work*, %struct.work** @WorkQ, align 8, !tbaa !1
  %123 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_next139 = getelementptr inbounds %struct.work, %struct.work* %123, i32 0, i32 9
  store %struct.work* %122, %struct.work** %w_next139, align 8, !tbaa !118
  %124 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  store %struct.work* %124, %struct.work** @WorkQ, align 8, !tbaa !1
  br label %for.cond.104

for.end.140:                                      ; preds = %for.cond.104
  %125 = load i32, i32* @WorkListCount, align 4, !tbaa !5
  store i32 %125, i32* %i, align 4, !tbaa !5
  br label %for.cond.141

for.cond.141:                                     ; preds = %if.end.158, %for.end.140
  %126 = load i32, i32* %i, align 4, !tbaa !5
  %dec142 = add nsw i32 %126, -1
  store i32 %dec142, i32* %i, align 4, !tbaa !5
  %127 = load i32, i32* %wc, align 4, !tbaa !5
  %cmp143 = icmp sge i32 %dec142, %127
  br i1 %cmp143, label %for.body.145, label %for.end.159

for.body.145:                                     ; preds = %for.cond.141
  %128 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom146 = sext i32 %128 to i64
  %129 = load %struct.work*, %struct.work** @WorkList, align 8, !tbaa !1
  %arrayidx147 = getelementptr inbounds %struct.work, %struct.work* %129, i64 %idxprom146
  %w_name148 = getelementptr inbounds %struct.work, %struct.work* %arrayidx147, i32 0, i32 0
  %130 = load i8*, i8** %w_name148, align 8, !tbaa !129
  call void @sm_free_tagged(i8* %130, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 3121)
  %131 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom149 = sext i32 %131 to i64
  %132 = load %struct.work*, %struct.work** @WorkList, align 8, !tbaa !1
  %arrayidx150 = getelementptr inbounds %struct.work, %struct.work* %132, i64 %idxprom149
  %w_host151 = getelementptr inbounds %struct.work, %struct.work* %arrayidx150, i32 0, i32 1
  %133 = load i8*, i8** %w_host151, align 8, !tbaa !130
  %cmp152 = icmp ne i8* %133, null
  br i1 %cmp152, label %if.then.154, label %if.end.158

if.then.154:                                      ; preds = %for.body.145
  %134 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom155 = sext i32 %134 to i64
  %135 = load %struct.work*, %struct.work** @WorkList, align 8, !tbaa !1
  %arrayidx156 = getelementptr inbounds %struct.work, %struct.work* %135, i64 %idxprom155
  %w_host157 = getelementptr inbounds %struct.work, %struct.work* %arrayidx156, i32 0, i32 1
  %136 = load i8*, i8** %w_host157, align 8, !tbaa !130
  call void @sm_free_tagged(i8* %136, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 3123)
  br label %if.end.158

if.end.158:                                       ; preds = %if.then.154, %for.body.145
  br label %for.cond.141

for.end.159:                                      ; preds = %for.cond.141
  %137 = load %struct.work*, %struct.work** @WorkList, align 8, !tbaa !1
  %cmp160 = icmp ne %struct.work* %137, null
  br i1 %cmp160, label %if.then.162, label %if.end.163

if.then.162:                                      ; preds = %for.end.159
  %138 = load %struct.work*, %struct.work** @WorkList, align 8, !tbaa !1
  %139 = bitcast %struct.work* %138 to i8*
  call void @sm_free_tagged(i8* %139, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 3127)
  br label %if.end.163

if.end.163:                                       ; preds = %if.then.162, %for.end.159
  store %struct.work* null, %struct.work** @WorkList, align 8, !tbaa !1
  store i32 0, i32* @WorkListSize, align 4, !tbaa !5
  store i32 0, i32* @WorkListCount, align 4, !tbaa !5
  %140 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 40), align 1, !tbaa !17
  %conv164 = zext i8 %140 to i32
  %cmp165 = icmp sge i32 %conv164, 1
  br i1 %cmp165, label %land.lhs.true.167, label %if.end.188

land.lhs.true.167:                                ; preds = %if.end.163
  %141 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool168 = icmp ne i32 %141, 0
  br i1 %tobool168, label %if.end.188, label %if.then.169

if.then.169:                                      ; preds = %land.lhs.true.167
  %142 = load %struct.work*, %struct.work** @WorkQ, align 8, !tbaa !1
  store %struct.work* %142, %struct.work** %w, align 8, !tbaa !1
  br label %for.cond.170

for.cond.170:                                     ; preds = %for.inc.185, %if.then.169
  %143 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %cmp171 = icmp ne %struct.work* %143, null
  br i1 %cmp171, label %for.body.173, label %for.end.187

for.body.173:                                     ; preds = %for.cond.170
  %144 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_host174 = getelementptr inbounds %struct.work, %struct.work* %144, i32 0, i32 1
  %145 = load i8*, i8** %w_host174, align 8, !tbaa !130
  %cmp175 = icmp ne i8* %145, null
  br i1 %cmp175, label %if.then.177, label %if.else.181

if.then.177:                                      ; preds = %for.body.173
  %146 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_name178 = getelementptr inbounds %struct.work, %struct.work* %146, i32 0, i32 0
  %147 = load i8*, i8** %w_name178, align 8, !tbaa !129
  %148 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_pri179 = getelementptr inbounds %struct.work, %struct.work* %148, i32 0, i32 4
  %149 = load i64, i64* %w_pri179, align 8, !tbaa !133
  %150 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_host180 = getelementptr inbounds %struct.work, %struct.work* %150, i32 0, i32 1
  %151 = load i8*, i8** %w_host180, align 8, !tbaa !130
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.225, i32 0, i32 0), i8* %147, i64 %149, i8* %151)
  br label %if.end.184

if.else.181:                                      ; preds = %for.body.173
  %152 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_name182 = getelementptr inbounds %struct.work, %struct.work* %152, i32 0, i32 0
  %153 = load i8*, i8** %w_name182, align 8, !tbaa !129
  %154 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_pri183 = getelementptr inbounds %struct.work, %struct.work* %154, i32 0, i32 4
  %155 = load i64, i64* %w_pri183, align 8, !tbaa !133
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.226, i32 0, i32 0), i8* %153, i64 %155)
  br label %if.end.184

if.end.184:                                       ; preds = %if.else.181, %if.then.177
  br label %for.inc.185

for.inc.185:                                      ; preds = %if.end.184
  %156 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_next186 = getelementptr inbounds %struct.work, %struct.work* %156, i32 0, i32 9
  %157 = load %struct.work*, %struct.work** %w_next186, align 8, !tbaa !118
  store %struct.work* %157, %struct.work** %w, align 8, !tbaa !1
  br label %for.cond.170

for.end.187:                                      ; preds = %for.cond.170
  br label %if.end.188

if.end.188:                                       ; preds = %for.end.187, %land.lhs.true.167, %if.end.163
  %158 = load i32, i32* %wc, align 4, !tbaa !5
  store i32 %158, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

cleanup:                                          ; preds = %if.end.188, %if.then.8
  %159 = bitcast i32* %wc to i8*
  call void @llvm.lifetime.end(i64 4, i8* %159) #1
  %160 = bitcast %struct.work** %w to i8*
  call void @llvm.lifetime.end(i64 8, i8* %160) #1
  %161 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end(i64 4, i8* %161) #1
  %162 = load i32, i32* %retval
  ret i32 %162
}

declare void @closemaps(i32) #2

; Function Attrs: nounwind
declare i32 @fork() #3

declare void @mci_flush(i32, %struct.mailer_con_info*) #2

; Function Attrs: nounwind uwtable
define internal void @runner_work(%struct.envelope* %e, i32 %sequenceno, i32 %didfork, i32 %skip, i32 %njobs) #0 {
entry:
  %e.addr = alloca %struct.envelope*, align 8
  %sequenceno.addr = alloca i32, align 4
  %didfork.addr = alloca i32, align 4
  %skip.addr = alloca i32, align 4
  %njobs.addr = alloca i32, align 4
  %n = alloca i32, align 4
  %seqjump = alloca i32, align 4
  %w = alloca %struct.work*, align 8
  %now = alloca i64, align 8
  %oldgroup = alloca i32, align 4
  %cleanup.dest.slot = alloca i32
  %msg = alloca i8*, align 8
  store %struct.envelope* %e, %struct.envelope** %e.addr, align 8, !tbaa !1
  store i32 %sequenceno, i32* %sequenceno.addr, align 4, !tbaa !5
  store i32 %didfork, i32* %didfork.addr, align 4, !tbaa !5
  store i32 %skip, i32* %skip.addr, align 4, !tbaa !5
  store i32 %njobs, i32* %njobs.addr, align 4, !tbaa !5
  %0 = bitcast i32* %n to i8*
  call void @llvm.lifetime.start(i64 4, i8* %0) #1
  %1 = bitcast i32* %seqjump to i8*
  call void @llvm.lifetime.start(i64 4, i8* %1) #1
  %2 = bitcast %struct.work** %w to i8*
  call void @llvm.lifetime.start(i64 8, i8* %2) #1
  %3 = bitcast i64* %now to i8*
  call void @llvm.lifetime.start(i64 8, i8* %3) #1
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call i64 @curtime()
  store i64 %call, i64* %now, align 8, !tbaa !92
  %4 = load i64, i64* @Current_LA_time, align 8, !tbaa !92
  %5 = load i64, i64* %now, align 8, !tbaa !92
  %sub = sub nsw i64 %5, 30
  %cmp = icmp slt i64 %4, %sub
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  call void @sm_getla()
  %6 = load i64, i64* %now, align 8, !tbaa !92
  store i64 %6, i64* @Current_LA_time, align 8, !tbaa !92
  br label %if.end

if.end:                                           ; preds = %if.then, %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 1, i32* @BlockOldsh, align 4, !tbaa !5
  %7 = load i32, i32* %skip.addr, align 4, !tbaa !5
  store i32 %7, i32* %seqjump, align 4, !tbaa !5
  br label %while.cond

while.cond:                                       ; preds = %cleanup.cont, %do.end
  %8 = load %struct.work*, %struct.work** @WorkQ, align 8, !tbaa !1
  %cmp1 = icmp ne %struct.work* %8, null
  br i1 %cmp1, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %9 = bitcast i32* %oldgroup to i8*
  call void @llvm.lifetime.start(i64 4, i8* %9) #1
  store i32 0, i32* %oldgroup, align 4, !tbaa !5
  %10 = load i32, i32* getelementptr inbounds (%struct.sm_debug, %struct.sm_debug* @DebugLeakQ, i32 0, i32 1), align 4, !tbaa !104
  %cmp2 = icmp uge i32 %10, 1
  br i1 %cmp2, label %land.lhs.true, label %if.end.6

land.lhs.true:                                    ; preds = %while.body
  %11 = load i32, i32* getelementptr inbounds (%struct.sm_debug, %struct.sm_debug* @DebugLeakQ, i32 0, i32 1), align 4, !tbaa !104
  %cmp3 = icmp ne i32 %11, -1
  br i1 %cmp3, label %if.then.5, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %call4 = call i32 @sm_debug_loadactive(%struct.sm_debug* @DebugLeakQ, i32 1)
  %tobool = icmp ne i32 %call4, 0
  br i1 %tobool, label %if.then.5, label %if.end.6

if.then.5:                                        ; preds = %lor.lhs.false, %land.lhs.true
  %12 = load i32, i32* @SmHeapGroup, align 4, !tbaa !5
  store i32 %12, i32* %oldgroup, align 4, !tbaa !5
  %13 = load i32, i32* @SmHeapMaxGroup, align 4, !tbaa !5
  %inc = add nsw i32 %13, 1
  store i32 %inc, i32* @SmHeapMaxGroup, align 4, !tbaa !5
  store i32 %inc, i32* @SmHeapGroup, align 4, !tbaa !5
  %14 = load i32, i32* @SmHeapGroup, align 4, !tbaa !5
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.196, i32 0, i32 0), i32 %14)
  br label %if.end.6

if.end.6:                                         ; preds = %if.then.5, %lor.lhs.false, %while.body
  %15 = load volatile i32, i32* @NoMoreRunners, align 4, !tbaa !5
  %tobool7 = icmp ne i32 %15, 0
  br i1 %tobool7, label %if.then.8, label %if.end.18

if.then.8:                                        ; preds = %if.end.6
  %16 = load volatile void (i32)*, void (i32)** @Oldsh, align 8, !tbaa !1
  %cmp9 = icmp ne void (i32)* %16, null
  br i1 %cmp9, label %land.lhs.true.10, label %if.end.17

land.lhs.true.10:                                 ; preds = %if.then.8
  %17 = load volatile void (i32)*, void (i32)** @Oldsh, align 8, !tbaa !1
  %cmp11 = icmp ne void (i32)* %17, inttoptr (i64 1 to void (i32)*)
  br i1 %cmp11, label %land.lhs.true.12, label %if.end.17

land.lhs.true.12:                                 ; preds = %land.lhs.true.10
  %18 = load volatile void (i32)*, void (i32)** @Oldsh, align 8, !tbaa !1
  %cmp13 = icmp ne void (i32)* %18, @runners_sighup
  br i1 %cmp13, label %land.lhs.true.14, label %if.end.17

land.lhs.true.14:                                 ; preds = %land.lhs.true.12
  %19 = load volatile void (i32)*, void (i32)** @Oldsh, align 8, !tbaa !1
  %cmp15 = icmp ne void (i32)* %19, @runners_sigterm
  br i1 %cmp15, label %if.then.16, label %if.end.17

if.then.16:                                       ; preds = %land.lhs.true.14
  %20 = load volatile void (i32)*, void (i32)** @Oldsh, align 8, !tbaa !1
  %21 = load volatile i32, i32* @Oldsig, align 4, !tbaa !5
  call void %20(i32 %21)
  br label %if.end.17

if.end.17:                                        ; preds = %if.then.16, %land.lhs.true.14, %land.lhs.true.12, %land.lhs.true.10, %if.then.8
  store i32 5, i32* %cleanup.dest.slot
  br label %cleanup

if.end.18:                                        ; preds = %if.end.6
  %22 = load %struct.work*, %struct.work** @WorkQ, align 8, !tbaa !1
  store %struct.work* %22, %struct.work** %w, align 8, !tbaa !1
  store i32 0, i32* %n, align 4, !tbaa !5
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end.18
  %23 = load i32, i32* %n, align 4, !tbaa !5
  %24 = load i32, i32* %skip.addr, align 4, !tbaa !5
  %cmp19 = icmp slt i32 %23, %24
  br i1 %cmp19, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %25 = load %struct.work*, %struct.work** @WorkQ, align 8, !tbaa !1
  %cmp20 = icmp ne %struct.work* %25, null
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %26 = phi i1 [ false, %for.cond ], [ %cmp20, %land.rhs ]
  br i1 %26, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %27 = load %struct.work*, %struct.work** @WorkQ, align 8, !tbaa !1
  %w_next = getelementptr inbounds %struct.work, %struct.work* %27, i32 0, i32 9
  %28 = load %struct.work*, %struct.work** %w_next, align 8, !tbaa !118
  store %struct.work* %28, %struct.work** @WorkQ, align 8, !tbaa !1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %29 = load i32, i32* %n, align 4, !tbaa !5
  %inc21 = add nsw i32 %29, 1
  store i32 %inc21, i32* %n, align 4, !tbaa !5
  br label %for.cond

for.end:                                          ; preds = %land.end
  %30 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_to = getelementptr inbounds %struct.envelope, %struct.envelope* %30, i32 0, i32 3
  store i8* null, i8** %e_to, align 8, !tbaa !59
  br label %do.body.22

do.body.22:                                       ; preds = %for.end
  %call23 = call i64 @curtime()
  store i64 %call23, i64* %now, align 8, !tbaa !92
  %31 = load i64, i64* @Current_LA_time, align 8, !tbaa !92
  %32 = load i64, i64* %now, align 8, !tbaa !92
  %sub24 = sub nsw i64 %32, 30
  %cmp25 = icmp slt i64 %31, %sub24
  br i1 %cmp25, label %if.then.26, label %if.end.27

if.then.26:                                       ; preds = %do.body.22
  call void @sm_getla()
  %33 = load i64, i64* %now, align 8, !tbaa !92
  store i64 %33, i64* @Current_LA_time, align 8, !tbaa !92
  br label %if.end.27

if.end.27:                                        ; preds = %if.then.26, %do.body.22
  br label %do.cond.28

do.cond.28:                                       ; preds = %if.end.27
  br label %do.end.29

do.end.29:                                        ; preds = %do.cond.28
  %34 = load i64, i64* @WkRecipFact, align 8, !tbaa !92
  %35 = load i64, i64* @Current_LA_time, align 8, !tbaa !92
  %call30 = call i32 @shouldqueue(i64 %34, i64 %35)
  %tobool31 = icmp ne i32 %call30, 0
  br i1 %tobool31, label %if.then.32, label %if.end.39

if.then.32:                                       ; preds = %do.end.29
  %36 = bitcast i8** %msg to i8*
  call void @llvm.lifetime.start(i64 8, i8* %36) #1
  store i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.197, i32 0, i32 0), i8** %msg, align 8, !tbaa !1
  %37 = load i32, i32* @Verbose, align 4, !tbaa !5
  %tobool33 = icmp ne i32 %37, 0
  br i1 %tobool33, label %if.then.34, label %if.end.35

if.then.34:                                       ; preds = %if.then.32
  %38 = load i8*, i8** %msg, align 8, !tbaa !1
  call void (i8*, ...) @message(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.43, i32 0, i32 0), i8* %38)
  br label %if.end.35

if.end.35:                                        ; preds = %if.then.34, %if.then.32
  %39 = load i32, i32* @LogLevel, align 4, !tbaa !5
  %cmp36 = icmp sgt i32 %39, 8
  br i1 %cmp36, label %if.then.37, label %if.end.38

if.then.37:                                       ; preds = %if.end.35
  %40 = load i8*, i8** %msg, align 8, !tbaa !1
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 6, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.67, i32 0, i32 0), i8* %40)
  br label %if.end.38

if.end.38:                                        ; preds = %if.then.37, %if.end.35
  store i32 5, i32* %cleanup.dest.slot
  %41 = bitcast i8** %msg to i8*
  call void @llvm.lifetime.end(i64 8, i8* %41) #1
  br label %cleanup

if.end.39:                                        ; preds = %do.end.29
  %42 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_pri = getelementptr inbounds %struct.work, %struct.work* %42, i32 0, i32 4
  %43 = load i64, i64* %w_pri, align 8, !tbaa !133
  %44 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_ctime = getelementptr inbounds %struct.work, %struct.work* %44, i32 0, i32 5
  %45 = load i64, i64* %w_ctime, align 8, !tbaa !134
  %call40 = call i32 @shouldqueue(i64 %43, i64 %45)
  %tobool41 = icmp ne i32 %call40, 0
  br i1 %tobool41, label %if.then.42, label %if.else.70

if.then.42:                                       ; preds = %if.end.39
  %46 = load i32, i32* @Verbose, align 4, !tbaa !5
  %tobool43 = icmp ne i32 %46, 0
  br i1 %tobool43, label %if.then.44, label %if.end.45

if.then.44:                                       ; preds = %if.then.42
  call void (i8*, ...) @message(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.43, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0))
  br label %if.end.45

if.end.45:                                        ; preds = %if.then.44, %if.then.42
  %47 = load i32, i32* @QueueSortOrder, align 4, !tbaa !5
  %cmp46 = icmp eq i32 %47, 0
  br i1 %cmp46, label %if.then.47, label %if.else

if.then.47:                                       ; preds = %if.end.45
  %48 = load i32, i32* @Verbose, align 4, !tbaa !5
  %tobool48 = icmp ne i32 %48, 0
  br i1 %tobool48, label %if.then.49, label %if.end.51

if.then.49:                                       ; preds = %if.then.47
  %49 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_qgrp = getelementptr inbounds %struct.work, %struct.work* %49, i32 0, i32 7
  %50 = load i32, i32* %w_qgrp, align 4, !tbaa !127
  %51 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_qdir = getelementptr inbounds %struct.work, %struct.work* %51, i32 0, i32 8
  %52 = load i32, i32* %w_qdir, align 4, !tbaa !128
  %call50 = call i8* @qid_printqueue(i32 %50, i32 %52)
  %53 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_name = getelementptr inbounds %struct.work, %struct.work* %53, i32 0, i32 0
  %54 = load i8*, i8** %w_name, align 8, !tbaa !129
  %add.ptr = getelementptr inbounds i8, i8* %54, i64 2
  %55 = load i32, i32* %sequenceno.addr, align 4, !tbaa !5
  %56 = load i32, i32* %njobs.addr, align 4, !tbaa !5
  call void (i8*, ...) @message(i8* getelementptr inbounds ([62 x i8], [62 x i8]* @.str.198, i32 0, i32 0), i8* %call50, i8* %add.ptr, i32 %55, i32 %56)
  br label %if.end.51

if.end.51:                                        ; preds = %if.then.49, %if.then.47
  %57 = load i32, i32* @LogLevel, align 4, !tbaa !5
  %cmp52 = icmp sgt i32 %57, 8
  br i1 %cmp52, label %if.then.53, label %if.end.60

if.then.53:                                       ; preds = %if.end.51
  %58 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_qgrp54 = getelementptr inbounds %struct.work, %struct.work* %58, i32 0, i32 7
  %59 = load i32, i32* %w_qgrp54, align 4, !tbaa !127
  %60 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_qdir55 = getelementptr inbounds %struct.work, %struct.work* %60, i32 0, i32 8
  %61 = load i32, i32* %w_qdir55, align 4, !tbaa !128
  %call56 = call i8* @qid_printqueue(i32 %59, i32 %61)
  %62 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_name57 = getelementptr inbounds %struct.work, %struct.work* %62, i32 0, i32 0
  %63 = load i8*, i8** %w_name57, align 8, !tbaa !129
  %add.ptr58 = getelementptr inbounds i8, i8* %63, i64 2
  %64 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_pri59 = getelementptr inbounds %struct.work, %struct.work* %64, i32 0, i32 4
  %65 = load i64, i64* %w_pri59, align 8, !tbaa !133
  %66 = load i32, i32* @CurrentLA, align 4, !tbaa !5
  %67 = load i32, i32* %sequenceno.addr, align 4, !tbaa !5
  %68 = load i32, i32* %njobs.addr, align 4, !tbaa !5
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 6, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0), i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str.199, i32 0, i32 0), i8* %call56, i8* %add.ptr58, i64 %65, i32 %66, i32 %67, i32 %68)
  br label %if.end.60

if.end.60:                                        ; preds = %if.then.53, %if.end.51
  store i32 5, i32* %cleanup.dest.slot
  br label %cleanup

if.else:                                          ; preds = %if.end.45
  %69 = load i32, i32* @Verbose, align 4, !tbaa !5
  %tobool61 = icmp ne i32 %69, 0
  br i1 %tobool61, label %if.then.62, label %if.end.68

if.then.62:                                       ; preds = %if.else
  %70 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_qgrp63 = getelementptr inbounds %struct.work, %struct.work* %70, i32 0, i32 7
  %71 = load i32, i32* %w_qgrp63, align 4, !tbaa !127
  %72 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_qdir64 = getelementptr inbounds %struct.work, %struct.work* %72, i32 0, i32 8
  %73 = load i32, i32* %w_qdir64, align 4, !tbaa !128
  %call65 = call i8* @qid_printqueue(i32 %71, i32 %73)
  %74 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_name66 = getelementptr inbounds %struct.work, %struct.work* %74, i32 0, i32 0
  %75 = load i8*, i8** %w_name66, align 8, !tbaa !129
  %add.ptr67 = getelementptr inbounds i8, i8* %75, i64 2
  %76 = load i32, i32* %sequenceno.addr, align 4, !tbaa !5
  %77 = load i32, i32* %njobs.addr, align 4, !tbaa !5
  call void (i8*, ...) @message(i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.200, i32 0, i32 0), i8* %call65, i8* %add.ptr67, i32 %76, i32 %77)
  br label %if.end.68

if.end.68:                                        ; preds = %if.then.62, %if.else
  br label %if.end.69

if.end.69:                                        ; preds = %if.end.68
  br label %if.end.103

if.else.70:                                       ; preds = %if.end.39
  %78 = load i32, i32* @Verbose, align 4, !tbaa !5
  %tobool71 = icmp ne i32 %78, 0
  br i1 %tobool71, label %if.then.72, label %if.end.78

if.then.72:                                       ; preds = %if.else.70
  call void (i8*, ...) @message(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.43, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0))
  %79 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_qgrp73 = getelementptr inbounds %struct.work, %struct.work* %79, i32 0, i32 7
  %80 = load i32, i32* %w_qgrp73, align 4, !tbaa !127
  %81 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_qdir74 = getelementptr inbounds %struct.work, %struct.work* %81, i32 0, i32 8
  %82 = load i32, i32* %w_qdir74, align 4, !tbaa !128
  %call75 = call i8* @qid_printqueue(i32 %80, i32 %82)
  %83 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_name76 = getelementptr inbounds %struct.work, %struct.work* %83, i32 0, i32 0
  %84 = load i8*, i8** %w_name76, align 8, !tbaa !129
  %add.ptr77 = getelementptr inbounds i8, i8* %84, i64 2
  %85 = load i32, i32* %sequenceno.addr, align 4, !tbaa !5
  %86 = load i32, i32* %njobs.addr, align 4, !tbaa !5
  call void (i8*, ...) @message(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.201, i32 0, i32 0), i8* %call75, i8* %add.ptr77, i32 %85, i32 %86)
  br label %if.end.78

if.end.78:                                        ; preds = %if.then.72, %if.else.70
  %87 = load i32, i32* %didfork.addr, align 4, !tbaa !5
  %tobool79 = icmp ne i32 %87, 0
  br i1 %tobool79, label %land.lhs.true.80, label %if.end.85

land.lhs.true.80:                                 ; preds = %if.end.78
  %88 = load i32, i32* @MaxQueueChildren, align 4, !tbaa !5
  %cmp81 = icmp sgt i32 %88, 0
  br i1 %cmp81, label %if.then.82, label %if.end.85

if.then.82:                                       ; preds = %land.lhs.true.80
  %call83 = call i32 @sm_blocksignal(i32 17)
  %call84 = call void (i32)* @sm_signal(i32 17, void (i32)* @reapchild)
  br label %if.end.85

if.end.85:                                        ; preds = %if.then.82, %land.lhs.true.80, %if.end.78
  %89 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 63), align 1, !tbaa !17
  %conv = zext i8 %89 to i32
  %cmp86 = icmp sge i32 %conv, 100
  br i1 %cmp86, label %land.lhs.true.88, label %if.end.96

land.lhs.true.88:                                 ; preds = %if.end.85
  %90 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool89 = icmp ne i32 %90, 0
  br i1 %tobool89, label %if.end.96, label %if.then.90

if.then.90:                                       ; preds = %land.lhs.true.88
  %91 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_qgrp91 = getelementptr inbounds %struct.work, %struct.work* %91, i32 0, i32 7
  %92 = load i32, i32* %w_qgrp91, align 4, !tbaa !127
  %93 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_qdir92 = getelementptr inbounds %struct.work, %struct.work* %93, i32 0, i32 8
  %94 = load i32, i32* %w_qdir92, align 4, !tbaa !128
  %call93 = call i8* @qid_printqueue(i32 %92, i32 %94)
  %95 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_name94 = getelementptr inbounds %struct.work, %struct.work* %95, i32 0, i32 0
  %96 = load i8*, i8** %w_name94, align 8, !tbaa !129
  %add.ptr95 = getelementptr inbounds i8, i8* %96, i64 2
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 7, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.202, i32 0, i32 0), i8* %call93, i8* %add.ptr95)
  br label %if.end.96

if.end.96:                                        ; preds = %if.then.90, %land.lhs.true.88, %if.end.85
  %97 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_qgrp97 = getelementptr inbounds %struct.work, %struct.work* %97, i32 0, i32 7
  %98 = load i32, i32* %w_qgrp97, align 4, !tbaa !127
  %99 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_qdir98 = getelementptr inbounds %struct.work, %struct.work* %99, i32 0, i32 8
  %100 = load i32, i32* %w_qdir98, align 4, !tbaa !128
  %101 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_name99 = getelementptr inbounds %struct.work, %struct.work* %101, i32 0, i32 0
  %102 = load i8*, i8** %w_name99, align 8, !tbaa !129
  %add.ptr100 = getelementptr inbounds i8, i8* %102, i64 2
  %103 = load i32, i32* @ForkQueueRuns, align 4, !tbaa !5
  %104 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %call101 = call i32 @dowork(i32 %98, i32 %100, i8* %add.ptr100, i32 %103, i32 0, %struct.envelope* %104)
  %call102 = call i32* @__errno_location() #11
  store i32 0, i32* %call102, align 4, !tbaa !5
  br label %if.end.103

if.end.103:                                       ; preds = %if.end.96, %if.end.69
  %105 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_name104 = getelementptr inbounds %struct.work, %struct.work* %105, i32 0, i32 0
  %106 = load i8*, i8** %w_name104, align 8, !tbaa !129
  call void @sm_free_tagged(i8* %106, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 1835)
  %107 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_host = getelementptr inbounds %struct.work, %struct.work* %107, i32 0, i32 1
  %108 = load i8*, i8** %w_host, align 8, !tbaa !130
  %cmp105 = icmp ne i8* %108, null
  br i1 %cmp105, label %if.then.107, label %if.end.109

if.then.107:                                      ; preds = %if.end.103
  %109 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_host108 = getelementptr inbounds %struct.work, %struct.work* %109, i32 0, i32 1
  %110 = load i8*, i8** %w_host108, align 8, !tbaa !130
  call void @sm_free_tagged(i8* %110, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 1837)
  br label %if.end.109

if.end.109:                                       ; preds = %if.then.107, %if.end.103
  %111 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %112 = bitcast %struct.work* %111 to i8*
  call void @sm_free_tagged(i8* %112, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 1838)
  %113 = load i32, i32* %seqjump, align 4, !tbaa !5
  %114 = load i32, i32* %sequenceno.addr, align 4, !tbaa !5
  %add = add nsw i32 %114, %113
  store i32 %add, i32* %sequenceno.addr, align 4, !tbaa !5
  %115 = load i32, i32* getelementptr inbounds (%struct.sm_debug, %struct.sm_debug* @DebugLeakQ, i32 0, i32 1), align 4, !tbaa !104
  %cmp110 = icmp uge i32 %115, 1
  br i1 %cmp110, label %land.lhs.true.112, label %if.end.119

land.lhs.true.112:                                ; preds = %if.end.109
  %116 = load i32, i32* getelementptr inbounds (%struct.sm_debug, %struct.sm_debug* @DebugLeakQ, i32 0, i32 1), align 4, !tbaa !104
  %cmp113 = icmp ne i32 %116, -1
  br i1 %cmp113, label %if.then.118, label %lor.lhs.false.115

lor.lhs.false.115:                                ; preds = %land.lhs.true.112
  %call116 = call i32 @sm_debug_loadactive(%struct.sm_debug* @DebugLeakQ, i32 1)
  %tobool117 = icmp ne i32 %call116, 0
  br i1 %tobool117, label %if.then.118, label %if.end.119

if.then.118:                                      ; preds = %lor.lhs.false.115, %land.lhs.true.112
  %117 = load i32, i32* %oldgroup, align 4, !tbaa !5
  store i32 %117, i32* @SmHeapGroup, align 4, !tbaa !5
  br label %if.end.119

if.end.119:                                       ; preds = %if.then.118, %lor.lhs.false.115, %if.end.109
  store i32 0, i32* %cleanup.dest.slot
  br label %cleanup

cleanup:                                          ; preds = %if.end.119, %if.end.60, %if.end.38, %if.end.17
  %118 = bitcast i32* %oldgroup to i8*
  call void @llvm.lifetime.end(i64 4, i8* %118) #1
  %cleanup.dest = load i32, i32* %cleanup.dest.slot
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %cleanup.cont
    i32 5, label %while.end
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %while.cond

while.end:                                        ; preds = %cleanup, %while.cond
  store i32 0, i32* @BlockOldsh, align 4, !tbaa !5
  %119 = load volatile i32, i32* @NoMoreRunners, align 4, !tbaa !5
  %tobool120 = icmp ne i32 %119, 0
  br i1 %tobool120, label %if.then.121, label %if.end.135

if.then.121:                                      ; preds = %while.end
  %120 = load volatile void (i32)*, void (i32)** @Oldsh, align 8, !tbaa !1
  %cmp122 = icmp ne void (i32)* %120, null
  br i1 %cmp122, label %land.lhs.true.124, label %if.end.134

land.lhs.true.124:                                ; preds = %if.then.121
  %121 = load volatile void (i32)*, void (i32)** @Oldsh, align 8, !tbaa !1
  %cmp125 = icmp ne void (i32)* %121, inttoptr (i64 1 to void (i32)*)
  br i1 %cmp125, label %land.lhs.true.127, label %if.end.134

land.lhs.true.127:                                ; preds = %land.lhs.true.124
  %122 = load volatile void (i32)*, void (i32)** @Oldsh, align 8, !tbaa !1
  %cmp128 = icmp ne void (i32)* %122, @runners_sighup
  br i1 %cmp128, label %land.lhs.true.130, label %if.end.134

land.lhs.true.130:                                ; preds = %land.lhs.true.127
  %123 = load volatile void (i32)*, void (i32)** @Oldsh, align 8, !tbaa !1
  %cmp131 = icmp ne void (i32)* %123, @runners_sigterm
  br i1 %cmp131, label %if.then.133, label %if.end.134

if.then.133:                                      ; preds = %land.lhs.true.130
  %124 = load volatile void (i32)*, void (i32)** @Oldsh, align 8, !tbaa !1
  %125 = load volatile i32, i32* @Oldsig, align 4, !tbaa !5
  call void %124(i32 %125)
  br label %if.end.134

if.end.134:                                       ; preds = %if.then.133, %land.lhs.true.130, %land.lhs.true.127, %land.lhs.true.124, %if.then.121
  br label %if.end.135

if.end.135:                                       ; preds = %if.end.134, %while.end
  store volatile void (i32)* null, void (i32)** @Oldsh, align 8, !tbaa !1
  %126 = bitcast i64* %now to i8*
  call void @llvm.lifetime.end(i64 8, i8* %126) #1
  %127 = bitcast %struct.work** %w to i8*
  call void @llvm.lifetime.end(i64 8, i8* %127) #1
  %128 = bitcast i32* %seqjump to i8*
  call void @llvm.lifetime.end(i64 4, i8* %128) #1
  %129 = bitcast i32* %n to i8*
  call void @llvm.lifetime.end(i64 4, i8* %129) #1
  ret void

unreachable:                                      ; preds = %cleanup
  unreachable
}

declare i32 @sm_wait(i32*) #2

declare void @proc_list_drop(i32, i32, i32*) #2

declare void @sm_rpool_free(%struct.SM_RPOOL_T*) #2

declare void @rmexpstab() #2

declare i32 @getfallbackmxrr(i8*) #2

; Function Attrs: nounwind
declare i32 @access(i8*, i32) #3

; Function Attrs: nounwind
declare i32 @remove(i8*) #3

declare void @sm_heap_report(%struct.sm_file*, i32) #2

declare i32 @sm_debug_loadlevel(%struct.sm_debug*) #2

; Function Attrs: nounwind uwtable
define i32 @doqueuerun() #0 {
entry:
  %0 = load volatile i32, i32* @DoQueueRun, align 4, !tbaa !5
  ret i32 %0
}

; Function Attrs: nounwind uwtable
define void @runqueueevent(i32 %ignore) #0 {
entry:
  %ignore.addr = alloca i32, align 4
  %save_errno = alloca i32, align 4
  store i32 %ignore, i32* %ignore.addr, align 4, !tbaa !5
  %0 = bitcast i32* %save_errno to i8*
  call void @llvm.lifetime.start(i64 4, i8* %0) #1
  %call = call i32* @__errno_location() #11
  %1 = load i32, i32* %call, align 4, !tbaa !5
  store i32 %1, i32* %save_errno, align 4, !tbaa !5
  store volatile i32 1, i32* @DoQueueRun, align 4, !tbaa !5
  %2 = load i32, i32* %save_errno, align 4, !tbaa !5
  %call1 = call i32* @__errno_location() #11
  store i32 %2, i32* %call1, align 4, !tbaa !5
  %call2 = call i32* @__errno_location() #11
  %3 = load i32, i32* %call2, align 4, !tbaa !5
  %cmp = icmp eq i32 %3, 4
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call3 = call i32* @__errno_location() #11
  store i32 110, i32* %call3, align 4, !tbaa !5
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = bitcast i32* %save_errno to i8*
  call void @llvm.lifetime.end(i64 4, i8* %4) #1
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @dowork(i32 %qgrp, i32 %qdir, i8* %id, i32 %forkflag, i32 %requeueflag, %struct.envelope* %e) #0 {
entry:
  %retval = alloca i32, align 4
  %qgrp.addr = alloca i32, align 4
  %qdir.addr = alloca i32, align 4
  %id.addr = alloca i8*, align 8
  %forkflag.addr = alloca i32, align 4
  %requeueflag.addr = alloca i32, align 4
  %e.addr = alloca %struct.envelope*, align 8
  %pid = alloca i32, align 4
  %rpool = alloca %struct.SM_RPOOL_T*, align 8
  %cleanup.dest.slot = alloca i32
  store i32 %qgrp, i32* %qgrp.addr, align 4, !tbaa !5
  store i32 %qdir, i32* %qdir.addr, align 4, !tbaa !5
  store i8* %id, i8** %id.addr, align 8, !tbaa !1
  store i32 %forkflag, i32* %forkflag.addr, align 4, !tbaa !5
  store i32 %requeueflag, i32* %requeueflag.addr, align 4, !tbaa !5
  store %struct.envelope* %e, %struct.envelope** %e.addr, align 8, !tbaa !1
  %0 = bitcast i32* %pid to i8*
  call void @llvm.lifetime.start(i64 4, i8* %0) #1
  %1 = bitcast %struct.SM_RPOOL_T** %rpool to i8*
  call void @llvm.lifetime.start(i64 8, i8* %1) #1
  %2 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 40), align 1, !tbaa !17
  %conv = zext i8 %2 to i32
  %cmp = icmp sge i32 %conv, 1
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %3 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %4 = load i32, i32* %qgrp.addr, align 4, !tbaa !5
  %5 = load i32, i32* %qdir.addr, align 4, !tbaa !5
  %call = call i8* @qid_printqueue(i32 %4, i32 %5)
  %6 = load i8*, i8** %id.addr, align 8, !tbaa !1
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.83, i32 0, i32 0), i8* %call, i8* %6)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %7 = load i32, i32* %forkflag.addr, align 4, !tbaa !5
  %tobool2 = icmp ne i32 %7, 0
  br i1 %tobool2, label %if.then.3, label %if.else.28

if.then.3:                                        ; preds = %if.end
  call void @closemaps(i32 0)
  %call4 = call i32 @fork() #1
  store i32 %call4, i32* %pid, align 4, !tbaa !5
  %8 = load i32, i32* %pid, align 4, !tbaa !5
  %cmp5 = icmp slt i32 %8, 0
  br i1 %cmp5, label %if.then.7, label %if.else

if.then.7:                                        ; preds = %if.then.3
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.84, i32 0, i32 0))
  store i32 0, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.else:                                          ; preds = %if.then.3
  %9 = load i32, i32* %pid, align 4, !tbaa !5
  %cmp8 = icmp sgt i32 %9, 0
  br i1 %cmp8, label %if.then.10, label %if.else.11

if.then.10:                                       ; preds = %if.else
  call void @mci_flush(i32 0, %struct.mailer_con_info* null)
  br label %if.end.26

if.else.11:                                       ; preds = %if.else
  store volatile i8* null, i8** @RestartRequest, align 8, !tbaa !1
  store volatile i32 0, i32* @RestartWorkGroup, align 4, !tbaa !5
  store volatile i8* null, i8** @ShutdownRequest, align 8, !tbaa !1
  store volatile i32 0, i32* @PendingSignal, align 4, !tbaa !5
  %call12 = call i32 @getpid() #1
  store i32 %call12, i32* @CurrentPid, align 4, !tbaa !5
  call void @sm_exc_newthread(void (%struct.sm_exc*)* @fatal_error)
  %10 = load i8, i8* @OpMode, align 1, !tbaa !17
  %conv13 = sext i8 %10 to i32
  %cmp14 = icmp eq i32 %conv13, 115
  br i1 %cmp14, label %if.then.22, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else.11
  %11 = load i8, i8* @OpMode, align 1, !tbaa !17
  %conv16 = sext i8 %11 to i32
  %cmp17 = icmp eq i32 %conv16, 100
  br i1 %cmp17, label %if.then.22, label %lor.lhs.false.19

lor.lhs.false.19:                                 ; preds = %lor.lhs.false
  %12 = load i32, i32* @MaxQueueChildren, align 4, !tbaa !5
  %cmp20 = icmp sgt i32 %12, 0
  br i1 %cmp20, label %if.then.22, label %if.end.25

if.then.22:                                       ; preds = %lor.lhs.false.19, %lor.lhs.false, %if.else.11
  call void @proc_list_clear()
  %call23 = call i32 @sm_releasesignal(i32 17)
  %call24 = call void (i32)* @sm_signal(i32 17, void (i32)* null)
  br label %if.end.25

if.end.25:                                        ; preds = %if.then.22, %lor.lhs.false.19
  store i32 0, i32* @OnlyOneError, align 4, !tbaa !5
  store i32 0, i32* @QuickAbort, align 4, !tbaa !5
  br label %if.end.26

if.end.26:                                        ; preds = %if.end.25, %if.then.10
  br label %if.end.27

if.end.27:                                        ; preds = %if.end.26
  br label %if.end.29

if.else.28:                                       ; preds = %if.end
  store i32 0, i32* %pid, align 4, !tbaa !5
  br label %if.end.29

if.end.29:                                        ; preds = %if.else.28, %if.end.27
  %13 = load i32, i32* %pid, align 4, !tbaa !5
  %cmp30 = icmp eq i32 %13, 0
  br i1 %cmp30, label %if.then.32, label %if.end.78

if.then.32:                                       ; preds = %if.end.29
  %14 = load i32, i32* %forkflag.addr, align 4, !tbaa !5
  %tobool33 = icmp ne i32 %14, 0
  br i1 %tobool33, label %if.then.34, label %if.end.35

if.then.34:                                       ; preds = %if.then.32
  store volatile i8* null, i8** @RestartRequest, align 8, !tbaa !1
  store volatile i32 0, i32* @RestartWorkGroup, align 4, !tbaa !5
  store volatile i8* null, i8** @ShutdownRequest, align 8, !tbaa !1
  store volatile i32 0, i32* @PendingSignal, align 4, !tbaa !5
  br label %if.end.35

if.end.35:                                        ; preds = %if.then.34, %if.then.32
  call void @sm_clear_events()
  call void @clearstats()
  %call36 = call %struct.SM_RPOOL_T* @sm_rpool_new_x(%struct.SM_RPOOL_T* null)
  store %struct.SM_RPOOL_T* %call36, %struct.SM_RPOOL_T** %rpool, align 8, !tbaa !1
  %15 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %16 = load %struct.SM_RPOOL_T*, %struct.SM_RPOOL_T** %rpool, align 8, !tbaa !1
  call void @clearenvelope(%struct.envelope* %15, i32 0, %struct.SM_RPOOL_T* %16)
  %17 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_flags = getelementptr inbounds %struct.envelope, %struct.envelope* %17, i32 0, i32 11
  %18 = load i64, i64* %e_flags, align 8, !tbaa !15
  %or = or i64 %18, 6144
  store i64 %or, i64* %e_flags, align 8, !tbaa !15
  %19 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  call void @set_delivery_mode(i32 105, %struct.envelope* %19)
  %20 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_errormode = getelementptr inbounds %struct.envelope, %struct.envelope* %20, i32 0, i32 17
  store i16 109, i16* %e_errormode, align 2, !tbaa !137
  %21 = load i8*, i8** %id.addr, align 8, !tbaa !1
  %22 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id = getelementptr inbounds %struct.envelope, %struct.envelope* %22, i32 0, i32 25
  store i8* %21, i8** %e_id, align 8, !tbaa !7
  %23 = load i32, i32* %qgrp.addr, align 4, !tbaa !5
  %24 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qgrp = getelementptr inbounds %struct.envelope, %struct.envelope* %24, i32 0, i32 26
  store i32 %23, i32* %e_qgrp, align 4, !tbaa !18
  %25 = load i32, i32* %qdir.addr, align 4, !tbaa !5
  %26 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qdir = getelementptr inbounds %struct.envelope, %struct.envelope* %26, i32 0, i32 27
  store i32 %25, i32* %e_qdir, align 4, !tbaa !19
  store i32 0, i32* @UseErrorsTo, align 4, !tbaa !5
  store i32 0, i32* @GrabTo, align 4, !tbaa !5
  store i32 0, i32* @ExitStat, align 4, !tbaa !5
  %27 = load i32, i32* %forkflag.addr, align 4, !tbaa !5
  %tobool37 = icmp ne i32 %27, 0
  br i1 %tobool37, label %if.then.38, label %if.end.39

if.then.38:                                       ; preds = %if.end.35
  %28 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  call void @disconnect(i32 1, %struct.envelope* %28)
  call void @set_op_mode(i32 113)
  br label %if.end.39

if.end.39:                                        ; preds = %if.then.38, %if.end.35
  %29 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %30 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %call40 = call i8* @qid_printname(%struct.envelope* %30)
  call void (i32, %struct.envelope*, i8*, ...) @sm_setproctitle(i32 1, %struct.envelope* %29, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.85, i32 0, i32 0), i8* %call40)
  %31 = load i32, i32* @LogLevel, align 4, !tbaa !5
  %cmp41 = icmp sgt i32 %31, 76
  br i1 %cmp41, label %if.then.43, label %if.end.45

if.then.43:                                       ; preds = %if.end.39
  %32 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id44 = getelementptr inbounds %struct.envelope, %struct.envelope* %32, i32 0, i32 25
  %33 = load i8*, i8** %e_id44, align 8, !tbaa !7
  %34 = load i32, i32* @CurrentPid, align 4, !tbaa !5
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 7, i8* %33, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.86, i32 0, i32 0), i32 %34)
  br label %if.end.45

if.end.45:                                        ; preds = %if.then.43, %if.end.39
  %35 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_header = getelementptr inbounds %struct.envelope, %struct.envelope* %35, i32 0, i32 0
  store %struct.header* null, %struct.header** %e_header, align 8, !tbaa !69
  %36 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %call46 = call i32 @readqf(%struct.envelope* %36, i32 0)
  %tobool47 = icmp ne i32 %call46, 0
  br i1 %tobool47, label %if.end.66, label %if.then.48

if.then.48:                                       ; preds = %if.end.45
  %37 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 40), align 1, !tbaa !17
  %conv49 = zext i8 %37 to i32
  %cmp50 = icmp sge i32 %conv49, 4
  br i1 %cmp50, label %land.lhs.true.52, label %if.end.60

land.lhs.true.52:                                 ; preds = %if.then.48
  %38 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool53 = icmp ne i32 %38, 0
  br i1 %tobool53, label %if.end.60, label %land.lhs.true.54

land.lhs.true.54:                                 ; preds = %land.lhs.true.52
  %39 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id55 = getelementptr inbounds %struct.envelope, %struct.envelope* %39, i32 0, i32 25
  %40 = load i8*, i8** %e_id55, align 8, !tbaa !7
  %cmp56 = icmp ne i8* %40, null
  br i1 %cmp56, label %if.then.58, label %if.end.60

if.then.58:                                       ; preds = %land.lhs.true.54
  %41 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %call59 = call i8* @qid_printname(%struct.envelope* %41)
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.87, i32 0, i32 0), i8* %call59)
  br label %if.end.60

if.end.60:                                        ; preds = %if.then.58, %land.lhs.true.54, %land.lhs.true.52, %if.then.48
  %42 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id61 = getelementptr inbounds %struct.envelope, %struct.envelope* %42, i32 0, i32 25
  store i8* null, i8** %e_id61, align 8, !tbaa !7
  %43 = load i32, i32* %forkflag.addr, align 4, !tbaa !5
  %tobool62 = icmp ne i32 %43, 0
  br i1 %tobool62, label %if.then.63, label %if.else.64

if.then.63:                                       ; preds = %if.end.60
  call void @finis(i32 0, i32 1, i32 0)
  br label %if.end.65

if.else.64:                                       ; preds = %if.end.60
  %44 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %45 = load %struct.SM_RPOOL_T*, %struct.SM_RPOOL_T** %rpool, align 8, !tbaa !1
  call void @clearenvelope(%struct.envelope* %44, i32 0, %struct.SM_RPOOL_T* %45)
  %46 = load %struct.SM_RPOOL_T*, %struct.SM_RPOOL_T** %rpool, align 8, !tbaa !1
  call void @sm_rpool_free(%struct.SM_RPOOL_T* %46)
  %47 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_rpool = getelementptr inbounds %struct.envelope, %struct.envelope* %47, i32 0, i32 52
  store %struct.SM_RPOOL_T* null, %struct.SM_RPOOL_T** %e_rpool, align 8, !tbaa !120
  store i32 0, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.65:                                        ; preds = %if.then.63
  br label %if.end.66

if.end.66:                                        ; preds = %if.end.65, %if.end.45
  %48 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_flags67 = getelementptr inbounds %struct.envelope, %struct.envelope* %48, i32 0, i32 11
  %49 = load i64, i64* %e_flags67, align 8, !tbaa !15
  %or68 = or i64 %49, 2
  store i64 %or68, i64* %e_flags67, align 8, !tbaa !15
  %50 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %51 = load i32, i32* %requeueflag.addr, align 4, !tbaa !5
  call void @eatheader(%struct.envelope* %50, i32 %51, i32 1)
  %52 = load i32, i32* %requeueflag.addr, align 4, !tbaa !5
  %tobool69 = icmp ne i32 %52, 0
  br i1 %tobool69, label %if.then.70, label %if.end.71

if.then.70:                                       ; preds = %if.end.66
  %53 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  call void @queueup(%struct.envelope* %53, i32 0, i32 0)
  br label %if.end.71

if.end.71:                                        ; preds = %if.then.70, %if.end.66
  %54 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  call void @sendall(%struct.envelope* %54, i32 105)
  %55 = load i32, i32* %forkflag.addr, align 4, !tbaa !5
  %tobool72 = icmp ne i32 %55, 0
  br i1 %tobool72, label %if.then.73, label %if.else.74

if.then.73:                                       ; preds = %if.end.71
  %56 = load i32, i32* @ExitStat, align 4, !tbaa !5
  call void @finis(i32 1, i32 1, i32 %56)
  br label %if.end.77

if.else.74:                                       ; preds = %if.end.71
  %57 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %call75 = call i32 @dropenvelope(%struct.envelope* %57, i32 1, i32 0)
  %58 = load %struct.SM_RPOOL_T*, %struct.SM_RPOOL_T** %rpool, align 8, !tbaa !1
  call void @sm_rpool_free(%struct.SM_RPOOL_T* %58)
  %59 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_rpool76 = getelementptr inbounds %struct.envelope, %struct.envelope* %59, i32 0, i32 52
  store %struct.SM_RPOOL_T* null, %struct.SM_RPOOL_T** %e_rpool76, align 8, !tbaa !120
  %60 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_message = getelementptr inbounds %struct.envelope, %struct.envelope* %60, i32 0, i32 34
  store i8* null, i8** %e_message, align 8, !tbaa !44
  br label %if.end.77

if.end.77:                                        ; preds = %if.else.74, %if.then.73
  br label %if.end.78

if.end.78:                                        ; preds = %if.end.77, %if.end.29
  %61 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id79 = getelementptr inbounds %struct.envelope, %struct.envelope* %61, i32 0, i32 25
  store i8* null, i8** %e_id79, align 8, !tbaa !7
  %62 = load i32, i32* %pid, align 4, !tbaa !5
  store i32 %62, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

cleanup:                                          ; preds = %if.end.78, %if.else.64, %if.then.7
  %63 = bitcast %struct.SM_RPOOL_T** %rpool to i8*
  call void @llvm.lifetime.end(i64 8, i8* %63) #1
  %64 = bitcast i32* %pid to i8*
  call void @llvm.lifetime.end(i64 4, i8* %64) #1
  %65 = load i32, i32* %retval
  ret i32 %65
}

declare void @sm_clear_events() #2

declare void @clearstats() #2

declare void @clearenvelope(%struct.envelope*, i32, %struct.SM_RPOOL_T*) #2

declare void @set_delivery_mode(i32, %struct.envelope*) #2

declare void @set_op_mode(i32) #2

; Function Attrs: nounwind uwtable
define i8* @qid_printname(%struct.envelope* %e) #0 {
entry:
  %retval = alloca i8*, align 8
  %e.addr = alloca %struct.envelope*, align 8
  %id = alloca i8*, align 8
  %cleanup.dest.slot = alloca i32
  store %struct.envelope* %e, %struct.envelope** %e.addr, align 8, !tbaa !1
  %0 = bitcast i8** %id to i8*
  call void @llvm.lifetime.start(i64 8, i8* %0) #1
  %1 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %cmp = icmp eq %struct.envelope* %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0), i8** %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end:                                           ; preds = %entry
  %2 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id = getelementptr inbounds %struct.envelope, %struct.envelope* %2, i32 0, i32 25
  %3 = load i8*, i8** %e_id, align 8, !tbaa !7
  %cmp1 = icmp eq i8* %3, null
  br i1 %cmp1, label %if.then.2, label %if.else

if.then.2:                                        ; preds = %if.end
  store i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0), i8** %id, align 8, !tbaa !1
  br label %if.end.4

if.else:                                          ; preds = %if.end
  %4 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id3 = getelementptr inbounds %struct.envelope, %struct.envelope* %4, i32 0, i32 25
  %5 = load i8*, i8** %e_id3, align 8, !tbaa !7
  store i8* %5, i8** %id, align 8, !tbaa !1
  br label %if.end.4

if.end.4:                                         ; preds = %if.else, %if.then.2
  %6 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qdir = getelementptr inbounds %struct.envelope, %struct.envelope* %6, i32 0, i32 27
  %7 = load i32, i32* %e_qdir, align 4, !tbaa !19
  %cmp5 = icmp eq i32 %7, -1
  br i1 %cmp5, label %if.then.6, label %if.end.7

if.then.6:                                        ; preds = %if.end.4
  %8 = load i8*, i8** %id, align 8, !tbaa !1
  store i8* %8, i8** %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.7:                                         ; preds = %if.end.4
  %9 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qdir8 = getelementptr inbounds %struct.envelope, %struct.envelope* %9, i32 0, i32 27
  %10 = load i32, i32* %e_qdir8, align 4, !tbaa !19
  %idxprom = sext i32 %10 to i64
  %11 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qgrp = getelementptr inbounds %struct.envelope, %struct.envelope* %11, i32 0, i32 26
  %12 = load i32, i32* %e_qgrp, align 4, !tbaa !18
  %idxprom9 = sext i32 %12 to i64
  %arrayidx = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom9
  %13 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx, align 8, !tbaa !1
  %qg_qpaths = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %13, i32 0, i32 6
  %14 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths, align 8, !tbaa !38
  %arrayidx10 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %14, i64 %idxprom
  %qp_name = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %arrayidx10, i32 0, i32 0
  %15 = load i8*, i8** %qp_name, align 8, !tbaa !40
  %16 = load i8*, i8** %id, align 8, !tbaa !1
  %call = call i32 (i8*, i64, i8*, ...) @sm_snprintf(i8* getelementptr inbounds ([55 x i8], [55 x i8]* @qid_printname.idbuf, i32 0, i32 0), i64 55, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.143, i32 0, i32 0), i8* %15, i8* %16)
  store i8* getelementptr inbounds ([55 x i8], [55 x i8]* @qid_printname.idbuf, i32 0, i32 0), i8** %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

cleanup:                                          ; preds = %if.end.7, %if.then.6, %if.then
  %17 = bitcast i8** %id to i8*
  call void @llvm.lifetime.end(i64 8, i8* %17) #1
  %18 = load i8*, i8** %retval
  ret i8* %18
}

; Function Attrs: nounwind uwtable
define internal i32 @readqf(%struct.envelope* %e, i32 %openonly) #0 {
entry:
  %retval = alloca i32, align 4
  %e.addr = alloca %struct.envelope*, align 8
  %openonly.addr = alloca i32, align 4
  %qfp = alloca %struct.sm_file*, align 8
  %ctladdr = alloca %struct.address*, align 8
  %st = alloca %struct.stat, align 8
  %stf = alloca %struct.stat, align 8
  %bp = alloca i8*, align 8
  %qfver = alloca i32, align 4
  %hdrsize = alloca i64, align 8
  %p = alloca i8*, align 8
  %frcpt = alloca i8*, align 8
  %orcpt = alloca i8*, align 8
  %nomore = alloca i32, align 4
  %bogus = alloca i32, align 4
  %qsafe = alloca i32, align 4
  %err = alloca i8*, align 8
  %qf = alloca [4096 x i8], align 16
  %buf = alloca [2048 x i8], align 16
  %bufsize = alloca i32, align 4
  %save_errno = alloca i32, align 4
  %cleanup.dest.slot = alloca i32
  %delim = alloca i8, align 1
  %dst = alloca %struct.stat, align 8
  %qflags = alloca i64, align 8
  %q = alloca %struct.address*, align 8
  %r = alloca i32, align 4
  %now = alloca i64, align 8
  %ep = alloca i8*, align 8
  %qgrp = alloca i32, align 4
  %qdir = alloca i32, align 4
  %__s1_len = alloca i64, align 8
  %__s2_len = alloca i64, align 8
  %tmp = alloca i32, align 4
  %howlong = alloca i8*, align 8
  %p549 = alloca i8*, align 8
  store %struct.envelope* %e, %struct.envelope** %e.addr, align 8, !tbaa !1
  store i32 %openonly, i32* %openonly.addr, align 4, !tbaa !5
  %0 = bitcast %struct.sm_file** %qfp to i8*
  call void @llvm.lifetime.start(i64 8, i8* %0) #1
  %1 = bitcast %struct.address** %ctladdr to i8*
  call void @llvm.lifetime.start(i64 8, i8* %1) #1
  %2 = bitcast %struct.stat* %st to i8*
  call void @llvm.lifetime.start(i64 144, i8* %2) #1
  %3 = bitcast %struct.stat* %stf to i8*
  call void @llvm.lifetime.start(i64 144, i8* %3) #1
  %4 = bitcast i8** %bp to i8*
  call void @llvm.lifetime.start(i64 8, i8* %4) #1
  %5 = bitcast i32* %qfver to i8*
  call void @llvm.lifetime.start(i64 4, i8* %5) #1
  store i32 0, i32* %qfver, align 4, !tbaa !5
  %6 = bitcast i64* %hdrsize to i8*
  call void @llvm.lifetime.start(i64 8, i8* %6) #1
  store i64 0, i64* %hdrsize, align 8, !tbaa !92
  %7 = bitcast i8** %p to i8*
  call void @llvm.lifetime.start(i64 8, i8* %7) #1
  %8 = bitcast i8** %frcpt to i8*
  call void @llvm.lifetime.start(i64 8, i8* %8) #1
  store i8* null, i8** %frcpt, align 8, !tbaa !1
  %9 = bitcast i8** %orcpt to i8*
  call void @llvm.lifetime.start(i64 8, i8* %9) #1
  store i8* null, i8** %orcpt, align 8, !tbaa !1
  %10 = bitcast i32* %nomore to i8*
  call void @llvm.lifetime.start(i64 4, i8* %10) #1
  store i32 0, i32* %nomore, align 4, !tbaa !5
  %11 = bitcast i32* %bogus to i8*
  call void @llvm.lifetime.start(i64 4, i8* %11) #1
  store i32 0, i32* %bogus, align 4, !tbaa !5
  %12 = bitcast i32* %qsafe to i8*
  call void @llvm.lifetime.start(i64 4, i8* %12) #1
  %13 = bitcast i8** %err to i8*
  call void @llvm.lifetime.start(i64 8, i8* %13) #1
  %14 = bitcast [4096 x i8]* %qf to i8*
  call void @llvm.lifetime.start(i64 4096, i8* %14) #1
  %15 = bitcast [2048 x i8]* %buf to i8*
  call void @llvm.lifetime.start(i64 2048, i8* %15) #1
  %16 = bitcast i32* %bufsize to i8*
  call void @llvm.lifetime.start(i64 4, i8* %16) #1
  %17 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %cmp = icmp ne %struct.envelope* %17, null
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  call void @sm_abort_at(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 3952, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.227, i32 0, i32 0)) #12
  unreachable
                                                  ; No predecessors!
  br label %lor.end

lor.end:                                          ; preds = %18, %entry
  %19 = phi i1 [ true, %entry ], [ false, %18 ]
  %lor.ext = zext i1 %19 to i32
  store i8* null, i8** %bp, align 8, !tbaa !1
  %arraydecay = getelementptr inbounds [4096 x i8], [4096 x i8]* %qf, i32 0, i32 0
  %20 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %call = call i8* @queuename(%struct.envelope* %20, i32 63)
  %call1 = call i64 @sm_strlcpy(i8* %arraydecay, i8* %call, i64 4096)
  %arraydecay2 = getelementptr inbounds [4096 x i8], [4096 x i8]* %qf, i32 0, i32 0
  %call3 = call %struct.sm_file* @sm_io_open(%struct.sm_file* @SmFtStdio_def, i32 -2, i8* %arraydecay2, i32 1, i8* null)
  store %struct.sm_file* %call3, %struct.sm_file** %qfp, align 8, !tbaa !1
  %21 = load %struct.sm_file*, %struct.sm_file** %qfp, align 8, !tbaa !1
  %cmp4 = icmp eq %struct.sm_file* %21, null
  br i1 %cmp4, label %if.then, label %if.end.19

if.then:                                          ; preds = %lor.end
  %22 = bitcast i32* %save_errno to i8*
  call void @llvm.lifetime.start(i64 4, i8* %22) #1
  %call5 = call i32* @__errno_location() #11
  %23 = load i32, i32* %call5, align 4, !tbaa !5
  store i32 %23, i32* %save_errno, align 4, !tbaa !5
  %24 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 40), align 1, !tbaa !17
  %conv = zext i8 %24 to i32
  %cmp6 = icmp sge i32 %conv, 8
  br i1 %cmp6, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then
  %25 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool = icmp ne i32 %25, 0
  br i1 %tobool, label %if.end, label %if.then.8

if.then.8:                                        ; preds = %land.lhs.true
  %arraydecay9 = getelementptr inbounds [4096 x i8], [4096 x i8]* %qf, i32 0, i32 0
  %call10 = call i32* @__errno_location() #11
  %26 = load i32, i32* %call10, align 4, !tbaa !5
  %call11 = call i8* @sm_errstring(i32 %26)
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.228, i32 0, i32 0), i8* %arraydecay9, i8* %call11)
  br label %if.end

if.end:                                           ; preds = %if.then.8, %land.lhs.true, %if.then
  %27 = load i32, i32* %save_errno, align 4, !tbaa !5
  %call12 = call i32* @__errno_location() #11
  store i32 %27, i32* %call12, align 4, !tbaa !5
  %call13 = call i32* @__errno_location() #11
  %28 = load i32, i32* %call13, align 4, !tbaa !5
  %cmp14 = icmp ne i32 %28, 2
  br i1 %cmp14, label %if.then.16, label %if.end.18

if.then.16:                                       ; preds = %if.end
  %arraydecay17 = getelementptr inbounds [4096 x i8], [4096 x i8]* %qf, i32 0, i32 0
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.229, i32 0, i32 0), i8* %arraydecay17)
  br label %if.end.18

if.end.18:                                        ; preds = %if.then.16, %if.end
  store i32 0, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  %29 = bitcast i32* %save_errno to i8*
  call void @llvm.lifetime.end(i64 4, i8* %29) #1
  br label %cleanup.668

if.end.19:                                        ; preds = %lor.end
  %30 = load %struct.sm_file*, %struct.sm_file** %qfp, align 8, !tbaa !1
  %call20 = call i32 @sm_io_getinfo(%struct.sm_file* %30, i32 3, i8* null)
  %arraydecay21 = getelementptr inbounds [4096 x i8], [4096 x i8]* %qf, i32 0, i32 0
  %call22 = call i32 @lockfile(i32 %call20, i8* %arraydecay21, i8* null, i32 6)
  %tobool23 = icmp ne i32 %call22, 0
  br i1 %tobool23, label %if.end.43, label %if.then.24

if.then.24:                                       ; preds = %if.end.19
  %31 = load i32, i32* @Verbose, align 4, !tbaa !5
  %tobool25 = icmp ne i32 %31, 0
  br i1 %tobool25, label %if.then.26, label %if.end.28

if.then.26:                                       ; preds = %if.then.24
  %32 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id = getelementptr inbounds %struct.envelope, %struct.envelope* %32, i32 0, i32 25
  %33 = load i8*, i8** %e_id, align 8, !tbaa !7
  %call27 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.230, i32 0, i32 0), i8* %33)
  br label %if.end.28

if.end.28:                                        ; preds = %if.then.26, %if.then.24
  %34 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 40), align 1, !tbaa !17
  %conv29 = zext i8 %34 to i32
  %cmp30 = icmp sge i32 %conv29, 8
  br i1 %cmp30, label %land.lhs.true.32, label %if.end.36

land.lhs.true.32:                                 ; preds = %if.end.28
  %35 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool33 = icmp ne i32 %35, 0
  br i1 %tobool33, label %if.end.36, label %if.then.34

if.then.34:                                       ; preds = %land.lhs.true.32
  %36 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id35 = getelementptr inbounds %struct.envelope, %struct.envelope* %36, i32 0, i32 25
  %37 = load i8*, i8** %e_id35, align 8, !tbaa !7
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.230, i32 0, i32 0), i8* %37)
  br label %if.end.36

if.end.36:                                        ; preds = %if.then.34, %land.lhs.true.32, %if.end.28
  %38 = load i32, i32* @LogLevel, align 4, !tbaa !5
  %cmp37 = icmp sgt i32 %38, 19
  br i1 %cmp37, label %if.then.39, label %if.end.41

if.then.39:                                       ; preds = %if.end.36
  %39 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id40 = getelementptr inbounds %struct.envelope, %struct.envelope* %39, i32 0, i32 25
  %40 = load i8*, i8** %e_id40, align 8, !tbaa !7
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 7, i8* %40, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.231, i32 0, i32 0))
  br label %if.end.41

if.end.41:                                        ; preds = %if.then.39, %if.end.36
  %41 = load %struct.sm_file*, %struct.sm_file** %qfp, align 8, !tbaa !1
  %call42 = call i32 @sm_io_close(%struct.sm_file* %41, i32 -2)
  store i32 0, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup.668

if.end.43:                                        ; preds = %if.end.19
  %arraydecay44 = getelementptr inbounds [4096 x i8], [4096 x i8]* %qf, i32 0, i32 0
  %call45 = call i32 @stat(i8* %arraydecay44, %struct.stat* %stf) #1
  %cmp46 = icmp slt i32 %call45, 0
  br i1 %cmp46, label %if.then.52, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end.43
  %42 = load %struct.sm_file*, %struct.sm_file** %qfp, align 8, !tbaa !1
  %call48 = call i32 @sm_io_getinfo(%struct.sm_file* %42, i32 3, i8* null)
  %call49 = call i32 @fstat(i32 %call48, %struct.stat* %st) #1
  %cmp50 = icmp slt i32 %call49, 0
  br i1 %cmp50, label %if.then.52, label %if.end.64

if.then.52:                                       ; preds = %lor.lhs.false, %if.end.43
  %43 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 40), align 1, !tbaa !17
  %conv53 = zext i8 %43 to i32
  %cmp54 = icmp sge i32 %conv53, 8
  br i1 %cmp54, label %land.lhs.true.56, label %if.end.62

land.lhs.true.56:                                 ; preds = %if.then.52
  %44 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool57 = icmp ne i32 %44, 0
  br i1 %tobool57, label %if.end.62, label %if.then.58

if.then.58:                                       ; preds = %land.lhs.true.56
  %arraydecay59 = getelementptr inbounds [4096 x i8], [4096 x i8]* %qf, i32 0, i32 0
  %call60 = call i32* @__errno_location() #11
  %45 = load i32, i32* %call60, align 4, !tbaa !5
  %call61 = call i8* @sm_errstring(i32 %45)
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.232, i32 0, i32 0), i8* %arraydecay59, i8* %call61)
  br label %if.end.62

if.end.62:                                        ; preds = %if.then.58, %land.lhs.true.56, %if.then.52
  %46 = load %struct.sm_file*, %struct.sm_file** %qfp, align 8, !tbaa !1
  %call63 = call i32 @sm_io_close(%struct.sm_file* %46, i32 -2)
  store i32 0, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup.668

if.end.64:                                        ; preds = %lor.lhs.false
  %st_nlink = getelementptr inbounds %struct.stat, %struct.stat* %st, i32 0, i32 2
  %47 = load i64, i64* %st_nlink, align 8, !tbaa !138
  %st_nlink65 = getelementptr inbounds %struct.stat, %struct.stat* %stf, i32 0, i32 2
  %48 = load i64, i64* %st_nlink65, align 8, !tbaa !138
  %cmp66 = icmp ne i64 %47, %48
  br i1 %cmp66, label %if.then.88, label %lor.lhs.false.68

lor.lhs.false.68:                                 ; preds = %if.end.64
  %st_dev = getelementptr inbounds %struct.stat, %struct.stat* %st, i32 0, i32 0
  %49 = load i64, i64* %st_dev, align 8, !tbaa !23
  %st_dev69 = getelementptr inbounds %struct.stat, %struct.stat* %stf, i32 0, i32 0
  %50 = load i64, i64* %st_dev69, align 8, !tbaa !23
  %cmp70 = icmp ne i64 %49, %50
  br i1 %cmp70, label %if.then.88, label %lor.lhs.false.72

lor.lhs.false.72:                                 ; preds = %lor.lhs.false.68
  %st_ino = getelementptr inbounds %struct.stat, %struct.stat* %st, i32 0, i32 1
  %51 = load i64, i64* %st_ino, align 8, !tbaa !27
  %st_ino73 = getelementptr inbounds %struct.stat, %struct.stat* %stf, i32 0, i32 1
  %52 = load i64, i64* %st_ino73, align 8, !tbaa !27
  %cmp74 = icmp ne i64 %51, %52
  br i1 %cmp74, label %if.then.88, label %lor.lhs.false.76

lor.lhs.false.76:                                 ; preds = %lor.lhs.false.72
  %st_uid = getelementptr inbounds %struct.stat, %struct.stat* %st, i32 0, i32 4
  %53 = load i32, i32* %st_uid, align 4, !tbaa !139
  %st_uid77 = getelementptr inbounds %struct.stat, %struct.stat* %stf, i32 0, i32 4
  %54 = load i32, i32* %st_uid77, align 4, !tbaa !139
  %cmp78 = icmp ne i32 %53, %54
  br i1 %cmp78, label %if.then.88, label %lor.lhs.false.80

lor.lhs.false.80:                                 ; preds = %lor.lhs.false.76
  %st_gid = getelementptr inbounds %struct.stat, %struct.stat* %st, i32 0, i32 5
  %55 = load i32, i32* %st_gid, align 4, !tbaa !140
  %st_gid81 = getelementptr inbounds %struct.stat, %struct.stat* %stf, i32 0, i32 5
  %56 = load i32, i32* %st_gid81, align 4, !tbaa !140
  %cmp82 = icmp ne i32 %55, %56
  br i1 %cmp82, label %if.then.88, label %lor.lhs.false.84

lor.lhs.false.84:                                 ; preds = %lor.lhs.false.80
  %st_size = getelementptr inbounds %struct.stat, %struct.stat* %st, i32 0, i32 8
  %57 = load i64, i64* %st_size, align 8, !tbaa !141
  %st_size85 = getelementptr inbounds %struct.stat, %struct.stat* %stf, i32 0, i32 8
  %58 = load i64, i64* %st_size85, align 8, !tbaa !141
  %cmp86 = icmp ne i64 %57, %58
  br i1 %cmp86, label %if.then.88, label %if.end.108

if.then.88:                                       ; preds = %lor.lhs.false.84, %lor.lhs.false.80, %lor.lhs.false.76, %lor.lhs.false.72, %lor.lhs.false.68, %if.end.64
  %59 = load i32, i32* @Verbose, align 4, !tbaa !5
  %tobool89 = icmp ne i32 %59, 0
  br i1 %tobool89, label %if.then.90, label %if.end.93

if.then.90:                                       ; preds = %if.then.88
  %60 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id91 = getelementptr inbounds %struct.envelope, %struct.envelope* %60, i32 0, i32 25
  %61 = load i8*, i8** %e_id91, align 8, !tbaa !7
  %call92 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.233, i32 0, i32 0), i8* %61)
  br label %if.end.93

if.end.93:                                        ; preds = %if.then.90, %if.then.88
  %62 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 40), align 1, !tbaa !17
  %conv94 = zext i8 %62 to i32
  %cmp95 = icmp sge i32 %conv94, 8
  br i1 %cmp95, label %land.lhs.true.97, label %if.end.101

land.lhs.true.97:                                 ; preds = %if.end.93
  %63 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool98 = icmp ne i32 %63, 0
  br i1 %tobool98, label %if.end.101, label %if.then.99

if.then.99:                                       ; preds = %land.lhs.true.97
  %64 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id100 = getelementptr inbounds %struct.envelope, %struct.envelope* %64, i32 0, i32 25
  %65 = load i8*, i8** %e_id100, align 8, !tbaa !7
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.233, i32 0, i32 0), i8* %65)
  br label %if.end.101

if.end.101:                                       ; preds = %if.then.99, %land.lhs.true.97, %if.end.93
  %66 = load i32, i32* @LogLevel, align 4, !tbaa !5
  %cmp102 = icmp sgt i32 %66, 19
  br i1 %cmp102, label %if.then.104, label %if.end.106

if.then.104:                                      ; preds = %if.end.101
  %67 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id105 = getelementptr inbounds %struct.envelope, %struct.envelope* %67, i32 0, i32 25
  %68 = load i8*, i8** %e_id105, align 8, !tbaa !7
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 7, i8* %68, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.234, i32 0, i32 0))
  br label %if.end.106

if.end.106:                                       ; preds = %if.then.104, %if.end.101
  %69 = load %struct.sm_file*, %struct.sm_file** %qfp, align 8, !tbaa !1
  %call107 = call i32 @sm_io_close(%struct.sm_file* %69, i32 -2)
  store i32 0, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup.668

if.end.108:                                       ; preds = %lor.lhs.false.84
  store i32 18, i32* %qsafe, align 4, !tbaa !5
  %70 = load i32, i32* @QueueFileMode, align 4, !tbaa !5
  %and = and i32 %70, 16
  %cmp109 = icmp ne i32 %and, 0
  br i1 %cmp109, label %if.then.111, label %if.end.113

if.then.111:                                      ; preds = %if.end.108
  %71 = load i32, i32* %qsafe, align 4, !tbaa !5
  %and112 = and i32 %71, -17
  store i32 %and112, i32* %qsafe, align 4, !tbaa !5
  br label %if.end.113

if.end.113:                                       ; preds = %if.then.111, %if.end.108
  %st_uid114 = getelementptr inbounds %struct.stat, %struct.stat* %st, i32 0, i32 4
  %72 = load i32, i32* %st_uid114, align 4, !tbaa !139
  %call115 = call i32 @geteuid() #1
  %cmp116 = icmp ne i32 %72, %call115
  br i1 %cmp116, label %land.lhs.true.118, label %land.end

land.lhs.true.118:                                ; preds = %if.end.113
  %st_uid119 = getelementptr inbounds %struct.stat, %struct.stat* %st, i32 0, i32 4
  %73 = load i32, i32* %st_uid119, align 4, !tbaa !139
  %74 = load i32, i32* @TrustedUid, align 4, !tbaa !5
  %cmp120 = icmp ne i32 %73, %74
  br i1 %cmp120, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true.118
  %call122 = call i32 @geteuid() #1
  %75 = load i32, i32* @RealUid, align 4, !tbaa !5
  %cmp123 = icmp ne i32 %call122, %75
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true.118, %if.end.113
  %76 = phi i1 [ false, %land.lhs.true.118 ], [ false, %if.end.113 ], [ %cmp123, %land.rhs ]
  %land.ext = zext i1 %76 to i32
  store i32 %land.ext, i32* %bogus, align 4, !tbaa !5
  %77 = load i32, i32* %bogus, align 4, !tbaa !5
  %tobool125 = icmp ne i32 %77, 0
  br i1 %tobool125, label %land.lhs.true.126, label %if.end.177

land.lhs.true.126:                                ; preds = %land.end
  %st_gid127 = getelementptr inbounds %struct.stat, %struct.stat* %st, i32 0, i32 5
  %78 = load i32, i32* %st_gid127, align 4, !tbaa !140
  %call128 = call i32 @getegid() #1
  %cmp129 = icmp eq i32 %78, %call128
  br i1 %cmp129, label %land.lhs.true.131, label %if.end.177

land.lhs.true.131:                                ; preds = %land.lhs.true.126
  %79 = load i32, i32* @UseMSP, align 4, !tbaa !5
  %tobool132 = icmp ne i32 %79, 0
  br i1 %tobool132, label %if.then.133, label %if.end.177

if.then.133:                                      ; preds = %land.lhs.true.131
  call void @llvm.lifetime.start(i64 1, i8* %delim) #1
  %80 = bitcast %struct.stat* %dst to i8*
  call void @llvm.lifetime.start(i64 144, i8* %80) #1
  %arraydecay134 = getelementptr inbounds [4096 x i8], [4096 x i8]* %qf, i32 0, i32 0
  %call135 = call i8* @strrchr(i8* %arraydecay134, i32 47) #14
  store i8* %call135, i8** %bp, align 8, !tbaa !1
  %81 = load i8*, i8** %bp, align 8, !tbaa !1
  %cmp136 = icmp eq i8* %81, null
  br i1 %cmp136, label %if.then.138, label %if.else

if.then.138:                                      ; preds = %if.then.133
  store i8 0, i8* %delim, align 1, !tbaa !17
  br label %if.end.139

if.else:                                          ; preds = %if.then.133
  %82 = load i8*, i8** %bp, align 8, !tbaa !1
  %83 = load i8, i8* %82, align 1, !tbaa !17
  store i8 %83, i8* %delim, align 1, !tbaa !17
  %84 = load i8*, i8** %bp, align 8, !tbaa !1
  store i8 0, i8* %84, align 1, !tbaa !17
  br label %if.end.139

if.end.139:                                       ; preds = %if.else, %if.then.138
  %85 = load i8, i8* %delim, align 1, !tbaa !17
  %conv140 = sext i8 %85 to i32
  %cmp141 = icmp eq i32 %conv140, 0
  br i1 %cmp141, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.139
  br label %cond.end

cond.false:                                       ; preds = %if.end.139
  %arraydecay143 = getelementptr inbounds [4096 x i8], [4096 x i8]* %qf, i32 0, i32 0
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ getelementptr inbounds ([2 x i8], [2 x i8]* @.str.100, i32 0, i32 0), %cond.true ], [ %arraydecay143, %cond.false ]
  %call144 = call i32 @stat(i8* %cond, %struct.stat* %dst) #1
  %cmp145 = icmp slt i32 %call144, 0
  br i1 %cmp145, label %if.then.147, label %if.else.156

if.then.147:                                      ; preds = %cond.end
  %86 = load i8, i8* %delim, align 1, !tbaa !17
  %conv148 = sext i8 %86 to i32
  %cmp149 = icmp eq i32 %conv148, 0
  br i1 %cmp149, label %cond.true.151, label %cond.false.152

cond.true.151:                                    ; preds = %if.then.147
  br label %cond.end.154

cond.false.152:                                   ; preds = %if.then.147
  %arraydecay153 = getelementptr inbounds [4096 x i8], [4096 x i8]* %qf, i32 0, i32 0
  br label %cond.end.154

cond.end.154:                                     ; preds = %cond.false.152, %cond.true.151
  %cond155 = phi i8* [ getelementptr inbounds ([2 x i8], [2 x i8]* @.str.100, i32 0, i32 0), %cond.true.151 ], [ %arraydecay153, %cond.false.152 ]
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.235, i32 0, i32 0), i8* %cond155)
  br label %if.end.171

if.else.156:                                      ; preds = %cond.end
  %87 = load i32, i32* @QueueFileMode, align 4, !tbaa !5
  %and157 = and i32 %87, 16
  %cmp158 = icmp ne i32 %and157, 0
  br i1 %cmp158, label %land.lhs.true.160, label %land.end.169

land.lhs.true.160:                                ; preds = %if.else.156
  %st_mode = getelementptr inbounds %struct.stat, %struct.stat* %dst, i32 0, i32 3
  %88 = load i32, i32* %st_mode, align 4, !tbaa !126
  %and161 = and i32 %88, 16
  %cmp162 = icmp ne i32 %and161, 0
  br i1 %cmp162, label %land.rhs.164, label %land.end.169

land.rhs.164:                                     ; preds = %land.lhs.true.160
  %st_gid165 = getelementptr inbounds %struct.stat, %struct.stat* %dst, i32 0, i32 5
  %89 = load i32, i32* %st_gid165, align 4, !tbaa !140
  %st_gid166 = getelementptr inbounds %struct.stat, %struct.stat* %st, i32 0, i32 5
  %90 = load i32, i32* %st_gid166, align 4, !tbaa !140
  %cmp167 = icmp eq i32 %89, %90
  br label %land.end.169

land.end.169:                                     ; preds = %land.rhs.164, %land.lhs.true.160, %if.else.156
  %91 = phi i1 [ false, %land.lhs.true.160 ], [ false, %if.else.156 ], [ %cmp167, %land.rhs.164 ]
  %lnot = xor i1 %91, true
  %lnot.ext = zext i1 %lnot to i32
  store i32 %lnot.ext, i32* %bogus, align 4, !tbaa !5
  br label %if.end.171

if.end.171:                                       ; preds = %land.end.169, %cond.end.154
  %92 = load i8, i8* %delim, align 1, !tbaa !17
  %conv172 = sext i8 %92 to i32
  %cmp173 = icmp ne i32 %conv172, 0
  br i1 %cmp173, label %if.then.175, label %if.end.176

if.then.175:                                      ; preds = %if.end.171
  %93 = load i8, i8* %delim, align 1, !tbaa !17
  %94 = load i8*, i8** %bp, align 8, !tbaa !1
  store i8 %93, i8* %94, align 1, !tbaa !17
  br label %if.end.176

if.end.176:                                       ; preds = %if.then.175, %if.end.171
  store i8* null, i8** %bp, align 8, !tbaa !1
  %95 = bitcast %struct.stat* %dst to i8*
  call void @llvm.lifetime.end(i64 144, i8* %95) #1
  call void @llvm.lifetime.end(i64 1, i8* %delim) #1
  br label %if.end.177

if.end.177:                                       ; preds = %if.end.176, %land.lhs.true.131, %land.lhs.true.126, %land.end
  %96 = load i32, i32* %bogus, align 4, !tbaa !5
  %tobool178 = icmp ne i32 %96, 0
  br i1 %tobool178, label %if.end.184, label %if.then.179

if.then.179:                                      ; preds = %if.end.177
  %st_mode180 = getelementptr inbounds %struct.stat, %struct.stat* %st, i32 0, i32 3
  %97 = load i32, i32* %st_mode180, align 4, !tbaa !126
  %98 = load i32, i32* %qsafe, align 4, !tbaa !5
  %and181 = and i32 %97, %98
  %cmp182 = icmp ne i32 %and181, 0
  %conv183 = zext i1 %cmp182 to i32
  store i32 %conv183, i32* %bogus, align 4, !tbaa !5
  br label %if.end.184

if.end.184:                                       ; preds = %if.then.179, %if.end.177
  %99 = load i32, i32* %bogus, align 4, !tbaa !5
  %tobool185 = icmp ne i32 %99, 0
  br i1 %tobool185, label %if.then.186, label %if.end.209

if.then.186:                                      ; preds = %if.end.184
  %100 = load i32, i32* @LogLevel, align 4, !tbaa !5
  %cmp187 = icmp sgt i32 %100, 0
  br i1 %cmp187, label %if.then.189, label %if.end.196

if.then.189:                                      ; preds = %if.then.186
  %101 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id190 = getelementptr inbounds %struct.envelope, %struct.envelope* %101, i32 0, i32 25
  %102 = load i8*, i8** %e_id190, align 8, !tbaa !7
  %st_uid191 = getelementptr inbounds %struct.stat, %struct.stat* %st, i32 0, i32 4
  %103 = load i32, i32* %st_uid191, align 4, !tbaa !139
  %conv192 = zext i32 %103 to i64
  %st_gid193 = getelementptr inbounds %struct.stat, %struct.stat* %st, i32 0, i32 5
  %104 = load i32, i32* %st_gid193, align 4, !tbaa !140
  %conv194 = zext i32 %104 to i64
  %st_mode195 = getelementptr inbounds %struct.stat, %struct.stat* %st, i32 0, i32 3
  %105 = load i32, i32* %st_mode195, align 4, !tbaa !126
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 1, i8* %102, i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.236, i32 0, i32 0), i64 %conv192, i64 %conv194, i32 %105)
  br label %if.end.196

if.end.196:                                       ; preds = %if.then.189, %if.then.186
  %106 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 40), align 1, !tbaa !17
  %conv197 = zext i8 %106 to i32
  %cmp198 = icmp sge i32 %conv197, 8
  br i1 %cmp198, label %land.lhs.true.200, label %if.end.204

land.lhs.true.200:                                ; preds = %if.end.196
  %107 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool201 = icmp ne i32 %107, 0
  br i1 %tobool201, label %if.end.204, label %if.then.202

if.then.202:                                      ; preds = %land.lhs.true.200
  %arraydecay203 = getelementptr inbounds [4096 x i8], [4096 x i8]* %qf, i32 0, i32 0
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.237, i32 0, i32 0), i8* %arraydecay203)
  br label %if.end.204

if.end.204:                                       ; preds = %if.then.202, %land.lhs.true.200, %if.end.196
  %108 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_flags = getelementptr inbounds %struct.envelope, %struct.envelope* %108, i32 0, i32 11
  %109 = load i64, i64* %e_flags, align 8, !tbaa !15
  %or = or i64 %109, 2
  store i64 %or, i64* %e_flags, align 8, !tbaa !15
  %110 = load i32, i32* %openonly.addr, align 4, !tbaa !5
  %tobool205 = icmp ne i32 %110, 0
  br i1 %tobool205, label %if.end.207, label %if.then.206

if.then.206:                                      ; preds = %if.end.204
  %111 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  call void @loseqfile(%struct.envelope* %111, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.238, i32 0, i32 0))
  br label %if.end.207

if.end.207:                                       ; preds = %if.then.206, %if.end.204
  %112 = load %struct.sm_file*, %struct.sm_file** %qfp, align 8, !tbaa !1
  %call208 = call i32 @sm_io_close(%struct.sm_file* %112, i32 -2)
  store i32 0, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup.668

if.end.209:                                       ; preds = %if.end.184
  %st_size210 = getelementptr inbounds %struct.stat, %struct.stat* %st, i32 0, i32 8
  %113 = load i64, i64* %st_size210, align 8, !tbaa !141
  %cmp211 = icmp eq i64 %113, 0
  br i1 %cmp211, label %if.then.213, label %if.end.226

if.then.213:                                      ; preds = %if.end.209
  %114 = load i32, i32* %openonly.addr, align 4, !tbaa !5
  %tobool214 = icmp ne i32 %114, 0
  br i1 %tobool214, label %if.end.224, label %land.lhs.true.215

land.lhs.true.215:                                ; preds = %if.then.213
  %st_ctim = getelementptr inbounds %struct.stat, %struct.stat* %st, i32 0, i32 13
  %tv_sec = getelementptr inbounds %struct.timespec, %struct.timespec* %st_ctim, i32 0, i32 0
  %115 = load i64, i64* %tv_sec, align 8, !tbaa !142
  %add = add nsw i64 %115, 600
  %call216 = call i64 @curtime()
  %cmp217 = icmp slt i64 %add, %call216
  br i1 %cmp217, label %if.then.219, label %if.end.224

if.then.219:                                      ; preds = %land.lhs.true.215
  %116 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %call220 = call i8* @queuename(%struct.envelope* %116, i32 100)
  %call221 = call i32 @xunlink(i8* %call220)
  %117 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %call222 = call i8* @queuename(%struct.envelope* %117, i32 63)
  %call223 = call i32 @xunlink(i8* %call222)
  br label %if.end.224

if.end.224:                                       ; preds = %if.then.219, %land.lhs.true.215, %if.then.213
  %118 = load %struct.sm_file*, %struct.sm_file** %qfp, align 8, !tbaa !1
  %call225 = call i32 @sm_io_close(%struct.sm_file* %118, i32 -2)
  store i32 0, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup.668

if.end.226:                                       ; preds = %if.end.209
  %st_nlink227 = getelementptr inbounds %struct.stat, %struct.stat* %st, i32 0, i32 2
  %119 = load i64, i64* %st_nlink227, align 8, !tbaa !138
  %cmp228 = icmp eq i64 %119, 0
  br i1 %cmp228, label %if.then.230, label %if.end.232

if.then.230:                                      ; preds = %if.end.226
  %120 = load %struct.sm_file*, %struct.sm_file** %qfp, align 8, !tbaa !1
  %call231 = call i32 @sm_io_close(%struct.sm_file* %120, i32 -2)
  store i32 0, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup.668

if.end.232:                                       ; preds = %if.end.226
  %st_uid233 = getelementptr inbounds %struct.stat, %struct.stat* %st, i32 0, i32 4
  %121 = load i32, i32* %st_uid233, align 4, !tbaa !139
  %call234 = call i32 @geteuid() #1
  %cmp235 = icmp ne i32 %121, %call234
  br i1 %cmp235, label %if.then.237, label %if.end.240

if.then.237:                                      ; preds = %if.end.232
  %122 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_flags238 = getelementptr inbounds %struct.envelope, %struct.envelope* %122, i32 0, i32 11
  %123 = load i64, i64* %e_flags238, align 8, !tbaa !15
  %or239 = or i64 %123, 134217728
  store i64 %or239, i64* %e_flags238, align 8, !tbaa !15
  br label %if.end.240

if.end.240:                                       ; preds = %if.then.237, %if.end.232
  %124 = load %struct.sm_file*, %struct.sm_file** %qfp, align 8, !tbaa !1
  %125 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_lockfp = getelementptr inbounds %struct.envelope, %struct.envelope* %125, i32 0, i32 33
  store %struct.sm_file* %124, %struct.sm_file** %e_lockfp, align 8, !tbaa !16
  %126 = load i32, i32* %openonly.addr, align 4, !tbaa !5
  %tobool241 = icmp ne i32 %126, 0
  br i1 %tobool241, label %if.then.242, label %if.end.243

if.then.242:                                      ; preds = %if.end.240
  store i32 1, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup.668

if.end.243:                                       ; preds = %if.end.240
  %127 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  call void @initsys(%struct.envelope* %127)
  %128 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_macro = getelementptr inbounds %struct.envelope, %struct.envelope* %128, i32 0, i32 46
  %129 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id244 = getelementptr inbounds %struct.envelope, %struct.envelope* %129, i32 0, i32 25
  %130 = load i8*, i8** %e_id244, align 8, !tbaa !7
  %131 = load i32, i32* @SmHeapGroup, align 4, !tbaa !5
  call void @macdefine_tagged(%struct.MACROS_T* %e_macro, i32 2, i32 105, i8* %130, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 4154, i32 %131)
  store i32 0, i32* @LineNumber, align 4, !tbaa !5
  %132 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_flags245 = getelementptr inbounds %struct.envelope, %struct.envelope* %132, i32 0, i32 11
  %133 = load i64, i64* %e_flags245, align 8, !tbaa !15
  %or246 = or i64 %133, 4096
  store i64 %or246, i64* %e_flags245, align 8, !tbaa !15
  call void @set_op_mode(i32 113)
  store %struct.address* null, %struct.address** %ctladdr, align 8, !tbaa !1
  %134 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %call247 = call signext i8 @queue_letter(%struct.envelope* %134, i32 63)
  %135 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qfletter = getelementptr inbounds %struct.envelope, %struct.envelope* %135, i32 0, i32 37
  store i8 %call247, i8* %e_qfletter, align 1, !tbaa !79
  %136 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qgrp = getelementptr inbounds %struct.envelope, %struct.envelope* %136, i32 0, i32 26
  %137 = load i32, i32* %e_qgrp, align 4, !tbaa !18
  %138 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_dfqgrp = getelementptr inbounds %struct.envelope, %struct.envelope* %138, i32 0, i32 28
  store i32 %137, i32* %e_dfqgrp, align 4, !tbaa !36
  %139 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qdir = getelementptr inbounds %struct.envelope, %struct.envelope* %139, i32 0, i32 27
  %140 = load i32, i32* %e_qdir, align 4, !tbaa !19
  %141 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_dfqdir = getelementptr inbounds %struct.envelope, %struct.envelope* %141, i32 0, i32 29
  store i32 %140, i32* %e_dfqdir, align 4, !tbaa !37
  %142 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_dfino = getelementptr inbounds %struct.envelope, %struct.envelope* %142, i32 0, i32 45
  store i64 -1, i64* %e_dfino, align 8, !tbaa !22
  %143 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_msgsize = getelementptr inbounds %struct.envelope, %struct.envelope* %143, i32 0, i32 9
  store i64 -1, i64* %e_msgsize, align 8, !tbaa !89
  br label %while.cond

while.cond:                                       ; preds = %cleanup.cont.581, %if.end.243
  store i32 2048, i32* %bufsize, align 4, !tbaa !5
  %arraydecay248 = getelementptr inbounds [2048 x i8], [2048 x i8]* %buf, i32 0, i32 0
  %144 = load %struct.sm_file*, %struct.sm_file** %qfp, align 8, !tbaa !1
  %call249 = call i8* @fgetfolded(i8* %arraydecay248, i32* %bufsize, %struct.sm_file* %144)
  store i8* %call249, i8** %bp, align 8, !tbaa !1
  %cmp250 = icmp ne i8* %call249, null
  br i1 %cmp250, label %while.body, label %while.end.582

while.body:                                       ; preds = %while.cond
  %145 = bitcast i64* %qflags to i8*
  call void @llvm.lifetime.start(i64 8, i8* %145) #1
  %146 = bitcast %struct.address** %q to i8*
  call void @llvm.lifetime.start(i64 8, i8* %146) #1
  %147 = bitcast i32* %r to i8*
  call void @llvm.lifetime.start(i64 4, i8* %147) #1
  %148 = bitcast i64* %now to i8*
  call void @llvm.lifetime.start(i64 8, i8* %148) #1
  %149 = bitcast i8** %ep to i8*
  call void @llvm.lifetime.start(i64 8, i8* %149) #1
  %150 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 40), align 1, !tbaa !17
  %conv252 = zext i8 %150 to i32
  %cmp253 = icmp sge i32 %conv252, 4
  br i1 %cmp253, label %land.lhs.true.255, label %if.end.258

land.lhs.true.255:                                ; preds = %while.body
  %151 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool256 = icmp ne i32 %151, 0
  br i1 %tobool256, label %if.end.258, label %if.then.257

if.then.257:                                      ; preds = %land.lhs.true.255
  %152 = load i8*, i8** %bp, align 8, !tbaa !1
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.239, i32 0, i32 0), i8* %152)
  br label %if.end.258

if.end.258:                                       ; preds = %if.then.257, %land.lhs.true.255, %while.body
  %153 = load i32, i32* %nomore, align 4, !tbaa !5
  %tobool259 = icmp ne i32 %153, 0
  br i1 %tobool259, label %if.then.260, label %if.end.261

if.then.260:                                      ; preds = %if.end.258
  br label %hackattack

hackattack:                                       ; preds = %if.then.278, %if.then.266, %if.then.260
  %154 = load i8*, i8** %bp, align 8, !tbaa !1
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.240, i32 0, i32 0), i8* %154)
  store i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.241, i32 0, i32 0), i8** %err, align 8, !tbaa !1
  store i32 5, i32* %cleanup.dest.slot
  br label %cleanup.575

if.end.261:                                       ; preds = %if.end.258
  %155 = load i8*, i8** %bp, align 8, !tbaa !1
  %arrayidx = getelementptr inbounds i8, i8* %155, i64 0
  %156 = load i8, i8* %arrayidx, align 1, !tbaa !17
  %conv262 = sext i8 %156 to i32
  switch i32 %conv262, label %sw.default.562 [
    i32 65, label %sw.bb
    i32 66, label %sw.bb.270
    i32 67, label %sw.bb.283
    i32 68, label %sw.epilog.565
    i32 100, label %sw.bb.286
    i32 69, label %sw.epilog.565
    i32 70, label %sw.bb.317
    i32 113, label %sw.bb.353
    i32 72, label %sw.bb.360
    i32 73, label %sw.epilog.565
    i32 75, label %sw.bb.365
    i32 76, label %sw.bb.368
    i32 77, label %sw.bb.368
    i32 78, label %sw.bb.369
    i32 80, label %sw.bb.433
    i32 81, label %sw.bb.437
    i32 114, label %sw.bb.441
    i32 82, label %sw.bb.445
    i32 83, label %sw.bb.521
    i32 84, label %sw.bb.525
    i32 86, label %sw.bb.528
    i32 90, label %sw.bb.535
    i32 33, label %sw.bb.542
    i32 36, label %sw.bb.547
    i32 46, label %sw.bb.561
  ]

sw.bb:                                            ; preds = %if.end.261
  %157 = load i8*, i8** %bp, align 8, !tbaa !1
  %arrayidx263 = getelementptr inbounds i8, i8* %157, i64 1
  %call264 = call i32 @xtextok(i8* %arrayidx263)
  %tobool265 = icmp ne i32 %call264, 0
  br i1 %tobool265, label %if.end.267, label %if.then.266

if.then.266:                                      ; preds = %sw.bb
  br label %hackattack

if.end.267:                                       ; preds = %sw.bb
  %158 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_rpool = getelementptr inbounds %struct.envelope, %struct.envelope* %158, i32 0, i32 52
  %159 = load %struct.SM_RPOOL_T*, %struct.SM_RPOOL_T** %e_rpool, align 8, !tbaa !120
  %160 = load i8*, i8** %bp, align 8, !tbaa !1
  %arrayidx268 = getelementptr inbounds i8, i8* %160, i64 1
  %call269 = call i8* @sm_rpool_strdup_x(%struct.SM_RPOOL_T* %159, i8* %arrayidx268)
  %161 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_auth_param = getelementptr inbounds %struct.envelope, %struct.envelope* %161, i32 0, i32 48
  store i8* %call269, i8** %e_auth_param, align 8, !tbaa !49
  br label %sw.epilog.565

sw.bb.270:                                        ; preds = %if.end.261
  %162 = load i8*, i8** %bp, align 8, !tbaa !1
  %arrayidx271 = getelementptr inbounds i8, i8* %162, i64 1
  %call272 = call i32 @check_bodytype(i8* %arrayidx271)
  store i32 %call272, i32* %r, align 4, !tbaa !5
  %163 = load i32, i32* %r, align 4, !tbaa !5
  %cmp273 = icmp eq i32 %163, 1
  br i1 %cmp273, label %if.end.279, label %lor.lhs.false.275

lor.lhs.false.275:                                ; preds = %sw.bb.270
  %164 = load i32, i32* %r, align 4, !tbaa !5
  %cmp276 = icmp eq i32 %164, 2
  br i1 %cmp276, label %if.end.279, label %if.then.278

if.then.278:                                      ; preds = %lor.lhs.false.275
  br label %hackattack

if.end.279:                                       ; preds = %lor.lhs.false.275, %sw.bb.270
  %165 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_rpool280 = getelementptr inbounds %struct.envelope, %struct.envelope* %165, i32 0, i32 52
  %166 = load %struct.SM_RPOOL_T*, %struct.SM_RPOOL_T** %e_rpool280, align 8, !tbaa !120
  %167 = load i8*, i8** %bp, align 8, !tbaa !1
  %arrayidx281 = getelementptr inbounds i8, i8* %167, i64 1
  %call282 = call i8* @sm_rpool_strdup_x(%struct.SM_RPOOL_T* %166, i8* %arrayidx281)
  %168 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_bodytype = getelementptr inbounds %struct.envelope, %struct.envelope* %168, i32 0, i32 23
  store i8* %call282, i8** %e_bodytype, align 8, !tbaa !42
  br label %sw.epilog.565

sw.bb.283:                                        ; preds = %if.end.261
  %169 = load i8*, i8** %bp, align 8, !tbaa !1
  %arrayidx284 = getelementptr inbounds i8, i8* %169, i64 1
  %170 = load i32, i32* %qfver, align 4, !tbaa !5
  %171 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %call285 = call %struct.address* @setctluser(i8* %arrayidx284, i32 %170, %struct.envelope* %171)
  store %struct.address* %call285, %struct.address** %ctladdr, align 8, !tbaa !1
  br label %sw.epilog.565

sw.bb.286:                                        ; preds = %if.end.261
  %172 = bitcast i32* %qgrp to i8*
  call void @llvm.lifetime.start(i64 4, i8* %172) #1
  %173 = bitcast i32* %qdir to i8*
  call void @llvm.lifetime.start(i64 4, i8* %173) #1
  store i32 0, i32* %qgrp, align 4, !tbaa !5
  br label %for.cond

for.cond:                                         ; preds = %for.inc.313, %sw.bb.286
  %174 = load i32, i32* %qgrp, align 4, !tbaa !5
  %175 = load i32, i32* @NumQueue, align 4, !tbaa !5
  %cmp287 = icmp slt i32 %174, %175
  br i1 %cmp287, label %land.rhs.289, label %land.end.293

land.rhs.289:                                     ; preds = %for.cond
  %176 = load i32, i32* %qgrp, align 4, !tbaa !5
  %idxprom = sext i32 %176 to i64
  %arrayidx290 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom
  %177 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx290, align 8, !tbaa !1
  %cmp291 = icmp ne %struct.queuegrp* %177, null
  br label %land.end.293

land.end.293:                                     ; preds = %land.rhs.289, %for.cond
  %178 = phi i1 [ false, %for.cond ], [ %cmp291, %land.rhs.289 ]
  br i1 %178, label %for.body, label %for.end.315

for.body:                                         ; preds = %land.end.293
  store i32 0, i32* %qdir, align 4, !tbaa !5
  br label %for.cond.295

for.cond.295:                                     ; preds = %for.inc, %for.body
  %179 = load i32, i32* %qdir, align 4, !tbaa !5
  %180 = load i32, i32* %qgrp, align 4, !tbaa !5
  %idxprom296 = sext i32 %180 to i64
  %arrayidx297 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom296
  %181 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx297, align 8, !tbaa !1
  %qg_numqueues = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %181, i32 0, i32 4
  %182 = load i32, i32* %qg_numqueues, align 4, !tbaa !82
  %cmp298 = icmp slt i32 %179, %182
  br i1 %cmp298, label %for.body.300, label %for.end

for.body.300:                                     ; preds = %for.cond.295
  %183 = bitcast i64* %__s1_len to i8*
  call void @llvm.lifetime.start(i64 8, i8* %183) #1
  %184 = bitcast i64* %__s2_len to i8*
  call void @llvm.lifetime.start(i64 8, i8* %184) #1
  %185 = load i8*, i8** %bp, align 8, !tbaa !1
  %arrayidx301 = getelementptr inbounds i8, i8* %185, i64 1
  %186 = load i32, i32* %qdir, align 4, !tbaa !5
  %idxprom302 = sext i32 %186 to i64
  %187 = load i32, i32* %qgrp, align 4, !tbaa !5
  %idxprom303 = sext i32 %187 to i64
  %arrayidx304 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom303
  %188 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx304, align 8, !tbaa !1
  %qg_qpaths = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %188, i32 0, i32 6
  %189 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths, align 8, !tbaa !38
  %arrayidx305 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %189, i64 %idxprom302
  %qp_name = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %arrayidx305, i32 0, i32 0
  %190 = load i8*, i8** %qp_name, align 8, !tbaa !40
  %call306 = call i32 @strcmp(i8* %arrayidx301, i8* %190) #1
  store i32 %call306, i32* %tmp, !tbaa !5
  %191 = bitcast i64* %__s2_len to i8*
  call void @llvm.lifetime.end(i64 8, i8* %191) #1
  %192 = bitcast i64* %__s1_len to i8*
  call void @llvm.lifetime.end(i64 8, i8* %192) #1
  %193 = load i32, i32* %tmp, !tbaa !5
  %cmp307 = icmp eq i32 %193, 0
  br i1 %cmp307, label %if.then.309, label %if.end.312

if.then.309:                                      ; preds = %for.body.300
  %194 = load i32, i32* %qgrp, align 4, !tbaa !5
  %195 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_dfqgrp310 = getelementptr inbounds %struct.envelope, %struct.envelope* %195, i32 0, i32 28
  store i32 %194, i32* %e_dfqgrp310, align 4, !tbaa !36
  %196 = load i32, i32* %qdir, align 4, !tbaa !5
  %197 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_dfqdir311 = getelementptr inbounds %struct.envelope, %struct.envelope* %197, i32 0, i32 29
  store i32 %196, i32* %e_dfqdir311, align 4, !tbaa !37
  br label %done

if.end.312:                                       ; preds = %for.body.300
  br label %for.inc

for.inc:                                          ; preds = %if.end.312
  %198 = load i32, i32* %qdir, align 4, !tbaa !5
  %inc = add nsw i32 %198, 1
  store i32 %inc, i32* %qdir, align 4, !tbaa !5
  br label %for.cond.295

for.end:                                          ; preds = %for.cond.295
  br label %for.inc.313

for.inc.313:                                      ; preds = %for.end
  %199 = load i32, i32* %qgrp, align 4, !tbaa !5
  %inc314 = add nsw i32 %199, 1
  store i32 %inc314, i32* %qgrp, align 4, !tbaa !5
  br label %for.cond

for.end.315:                                      ; preds = %land.end.293
  store i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.242, i32 0, i32 0), i8** %err, align 8, !tbaa !1
  store i32 5, i32* %cleanup.dest.slot
  br label %cleanup

done:                                             ; preds = %if.then.309
  store i32 6, i32* %cleanup.dest.slot
  br label %cleanup

cleanup:                                          ; preds = %for.end.315, %done
  %200 = bitcast i32* %qdir to i8*
  call void @llvm.lifetime.end(i64 4, i8* %200) #1
  %201 = bitcast i32* %qgrp to i8*
  call void @llvm.lifetime.end(i64 4, i8* %201) #1
  %cleanup.dest = load i32, i32* %cleanup.dest.slot
  switch i32 %cleanup.dest, label %cleanup.575 [
    i32 6, label %sw.epilog.565
  ]

sw.bb.317:                                        ; preds = %if.end.261
  %202 = load i8*, i8** %bp, align 8, !tbaa !1
  %call318 = call i32 @strncmp(i8* %202, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.243, i32 0, i32 0), i64 5) #14
  %cmp319 = icmp eq i32 %call318, 0
  br i1 %cmp319, label %if.then.321, label %if.end.322

if.then.321:                                      ; preds = %sw.bb.317
  %203 = load i8*, i8** %bp, align 8, !tbaa !1
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.244, i32 0, i32 0), i8* %203)
  store i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.241, i32 0, i32 0), i8** %err, align 8, !tbaa !1
  store i32 5, i32* %cleanup.dest.slot
  br label %cleanup.575

if.end.322:                                       ; preds = %sw.bb.317
  %204 = load i8*, i8** %bp, align 8, !tbaa !1
  %arrayidx323 = getelementptr inbounds i8, i8* %204, i64 1
  store i8* %arrayidx323, i8** %p, align 8, !tbaa !1
  br label %for.cond.324

for.cond.324:                                     ; preds = %for.inc.351, %if.end.322
  %205 = load i8*, i8** %p, align 8, !tbaa !1
  %206 = load i8, i8* %205, align 1, !tbaa !17
  %conv325 = sext i8 %206 to i32
  %cmp326 = icmp ne i32 %conv325, 0
  br i1 %cmp326, label %for.body.328, label %for.end.352

for.body.328:                                     ; preds = %for.cond.324
  %207 = load i8*, i8** %p, align 8, !tbaa !1
  %208 = load i8, i8* %207, align 1, !tbaa !17
  %conv329 = sext i8 %208 to i32
  switch i32 %conv329, label %sw.epilog [
    i32 56, label %sw.bb.330
    i32 98, label %sw.bb.333
    i32 100, label %sw.bb.336
    i32 110, label %sw.bb.339
    i32 114, label %sw.bb.342
    i32 115, label %sw.bb.345
    i32 119, label %sw.bb.348
  ]

sw.bb.330:                                        ; preds = %for.body.328
  %209 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_flags331 = getelementptr inbounds %struct.envelope, %struct.envelope* %209, i32 0, i32 11
  %210 = load i64, i64* %e_flags331, align 8, !tbaa !15
  %or332 = or i64 %210, 131072
  store i64 %or332, i64* %e_flags331, align 8, !tbaa !15
  br label %sw.epilog

sw.bb.333:                                        ; preds = %for.body.328
  %211 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_flags334 = getelementptr inbounds %struct.envelope, %struct.envelope* %211, i32 0, i32 11
  %212 = load i64, i64* %e_flags334, align 8, !tbaa !15
  %or335 = or i64 %212, 64
  store i64 %or335, i64* %e_flags334, align 8, !tbaa !15
  br label %sw.epilog

sw.bb.336:                                        ; preds = %for.body.328
  %213 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_flags337 = getelementptr inbounds %struct.envelope, %struct.envelope* %213, i32 0, i32 11
  %214 = load i64, i64* %e_flags337, align 8, !tbaa !15
  %or338 = or i64 %214, 1048576
  store i64 %or338, i64* %e_flags337, align 8, !tbaa !15
  br label %sw.epilog

sw.bb.339:                                        ; preds = %for.body.328
  %215 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_flags340 = getelementptr inbounds %struct.envelope, %struct.envelope* %215, i32 0, i32 11
  %216 = load i64, i64* %e_flags340, align 8, !tbaa !15
  %or341 = or i64 %216, 4
  store i64 %or341, i64* %e_flags340, align 8, !tbaa !15
  br label %sw.epilog

sw.bb.342:                                        ; preds = %for.body.328
  %217 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_flags343 = getelementptr inbounds %struct.envelope, %struct.envelope* %217, i32 0, i32 11
  %218 = load i64, i64* %e_flags343, align 8, !tbaa !15
  %or344 = or i64 %218, 128
  store i64 %or344, i64* %e_flags343, align 8, !tbaa !15
  br label %sw.epilog

sw.bb.345:                                        ; preds = %for.body.328
  %219 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_flags346 = getelementptr inbounds %struct.envelope, %struct.envelope* %219, i32 0, i32 11
  %220 = load i64, i64* %e_flags346, align 8, !tbaa !15
  %or347 = or i64 %220, 67108864
  store i64 %or347, i64* %e_flags346, align 8, !tbaa !15
  br label %sw.epilog

sw.bb.348:                                        ; preds = %for.body.328
  %221 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_flags349 = getelementptr inbounds %struct.envelope, %struct.envelope* %221, i32 0, i32 11
  %222 = load i64, i64* %e_flags349, align 8, !tbaa !15
  %or350 = or i64 %222, 1024
  store i64 %or350, i64* %e_flags349, align 8, !tbaa !15
  br label %sw.epilog

sw.epilog:                                        ; preds = %for.body.328, %sw.bb.348, %sw.bb.345, %sw.bb.342, %sw.bb.339, %sw.bb.336, %sw.bb.333, %sw.bb.330
  br label %for.inc.351

for.inc.351:                                      ; preds = %sw.epilog
  %223 = load i8*, i8** %p, align 8, !tbaa !1
  %incdec.ptr = getelementptr inbounds i8, i8* %223, i32 1
  store i8* %incdec.ptr, i8** %p, align 8, !tbaa !1
  br label %for.cond.324

for.end.352:                                      ; preds = %for.cond.324
  br label %sw.epilog.565

sw.bb.353:                                        ; preds = %if.end.261
  %224 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_rpool354 = getelementptr inbounds %struct.envelope, %struct.envelope* %224, i32 0, i32 52
  %225 = load %struct.SM_RPOOL_T*, %struct.SM_RPOOL_T** %e_rpool354, align 8, !tbaa !120
  %226 = load i8*, i8** %bp, align 8, !tbaa !1
  %arrayidx355 = getelementptr inbounds i8, i8* %226, i64 1
  %call356 = call i8* @sm_rpool_strdup_x(%struct.SM_RPOOL_T* %225, i8* %arrayidx355)
  %227 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_quarmsg = getelementptr inbounds %struct.envelope, %struct.envelope* %227, i32 0, i32 36
  store i8* %call356, i8** %e_quarmsg, align 8, !tbaa !43
  %228 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_macro357 = getelementptr inbounds %struct.envelope, %struct.envelope* %228, i32 0, i32 46
  %call358 = call i32 @macid_parse(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.245, i32 0, i32 0), i8** null)
  %229 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_quarmsg359 = getelementptr inbounds %struct.envelope, %struct.envelope* %229, i32 0, i32 36
  %230 = load i8*, i8** %e_quarmsg359, align 8, !tbaa !43
  %231 = load i32, i32* @SmHeapGroup, align 4, !tbaa !5
  call void @macdefine_tagged(%struct.MACROS_T* %e_macro357, i32 2, i32 %call358, i8* %230, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 4295, i32 %231)
  br label %sw.epilog.565

sw.bb.360:                                        ; preds = %if.end.261
  %232 = load i8*, i8** %bp, align 8, !tbaa !1
  %call361 = call i64 @strlen(i8* %232) #14
  %sub = sub i64 %call361, 3
  %233 = load i64, i64* %hdrsize, align 8, !tbaa !92
  %add362 = add i64 %233, %sub
  store i64 %add362, i64* %hdrsize, align 8, !tbaa !92
  %234 = load i8*, i8** %bp, align 8, !tbaa !1
  %arrayidx363 = getelementptr inbounds i8, i8* %234, i64 1
  %235 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %call364 = call i64 @chompheader(i8* %arrayidx363, i32 8, %struct.header** null, %struct.envelope* %235)
  br label %sw.epilog.565

sw.bb.365:                                        ; preds = %if.end.261
  %arrayidx366 = getelementptr inbounds [2048 x i8], [2048 x i8]* %buf, i32 0, i64 1
  %call367 = call i64 @atol(i8* %arrayidx366) #14
  %236 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_dtime = getelementptr inbounds %struct.envelope, %struct.envelope* %236, i32 0, i32 42
  store i64 %call367, i64* %e_dtime, align 8, !tbaa !33
  br label %sw.epilog.565

sw.bb.368:                                        ; preds = %if.end.261, %if.end.261
  br label %sw.epilog.565

sw.bb.369:                                        ; preds = %if.end.261
  %arrayidx370 = getelementptr inbounds [2048 x i8], [2048 x i8]* %buf, i32 0, i64 1
  %call371 = call i32 @atoi(i8* %arrayidx370) #14
  %237 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_ntries = getelementptr inbounds %struct.envelope, %struct.envelope* %237, i32 0, i32 43
  store i32 %call371, i32* %e_ntries, align 4, !tbaa !34
  %call372 = call i64 @curtime()
  store i64 %call372, i64* %now, align 8, !tbaa !92
  %238 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_ntries373 = getelementptr inbounds %struct.envelope, %struct.envelope* %238, i32 0, i32 43
  %239 = load i32, i32* %e_ntries373, align 4, !tbaa !34
  %cmp374 = icmp sgt i32 %239, 0
  br i1 %cmp374, label %land.lhs.true.376, label %if.end.415

land.lhs.true.376:                                ; preds = %sw.bb.369
  %240 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_dtime377 = getelementptr inbounds %struct.envelope, %struct.envelope* %240, i32 0, i32 42
  %241 = load i64, i64* %e_dtime377, align 8, !tbaa !33
  %242 = load i64, i64* %now, align 8, !tbaa !92
  %cmp378 = icmp sle i64 %241, %242
  br i1 %cmp378, label %land.lhs.true.380, label %if.end.415

land.lhs.true.380:                                ; preds = %land.lhs.true.376
  %243 = load i64, i64* %now, align 8, !tbaa !92
  %244 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_dtime381 = getelementptr inbounds %struct.envelope, %struct.envelope* %244, i32 0, i32 42
  %245 = load i64, i64* %e_dtime381, align 8, !tbaa !33
  %246 = load i64, i64* @MinQueueAge, align 8, !tbaa !92
  %add382 = add nsw i64 %245, %246
  %cmp383 = icmp slt i64 %243, %add382
  br i1 %cmp383, label %if.then.385, label %if.end.415

if.then.385:                                      ; preds = %land.lhs.true.380
  %247 = bitcast i8** %howlong to i8*
  call void @llvm.lifetime.start(i64 8, i8* %247) #1
  %248 = load i64, i64* %now, align 8, !tbaa !92
  %249 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_dtime387 = getelementptr inbounds %struct.envelope, %struct.envelope* %249, i32 0, i32 42
  %250 = load i64, i64* %e_dtime387, align 8, !tbaa !33
  %sub388 = sub nsw i64 %248, %250
  %call389 = call i8* @pintvl(i64 %sub388, i32 1)
  store i8* %call389, i8** %howlong, align 8, !tbaa !1
  %251 = load i32, i32* @Verbose, align 4, !tbaa !5
  %tobool390 = icmp ne i32 %251, 0
  br i1 %tobool390, label %if.then.391, label %if.end.394

if.then.391:                                      ; preds = %if.then.385
  %252 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id392 = getelementptr inbounds %struct.envelope, %struct.envelope* %252, i32 0, i32 25
  %253 = load i8*, i8** %e_id392, align 8, !tbaa !7
  %254 = load i8*, i8** %howlong, align 8, !tbaa !1
  %call393 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.246, i32 0, i32 0), i8* %253, i8* %254)
  br label %if.end.394

if.end.394:                                       ; preds = %if.then.391, %if.then.385
  %255 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 40), align 1, !tbaa !17
  %conv395 = zext i8 %255 to i32
  %cmp396 = icmp sge i32 %conv395, 8
  br i1 %cmp396, label %land.lhs.true.398, label %if.end.402

land.lhs.true.398:                                ; preds = %if.end.394
  %256 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool399 = icmp ne i32 %256, 0
  br i1 %tobool399, label %if.end.402, label %if.then.400

if.then.400:                                      ; preds = %land.lhs.true.398
  %257 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id401 = getelementptr inbounds %struct.envelope, %struct.envelope* %257, i32 0, i32 25
  %258 = load i8*, i8** %e_id401, align 8, !tbaa !7
  %259 = load i8*, i8** %howlong, align 8, !tbaa !1
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.246, i32 0, i32 0), i8* %258, i8* %259)
  br label %if.end.402

if.end.402:                                       ; preds = %if.then.400, %land.lhs.true.398, %if.end.394
  %260 = load i32, i32* @LogLevel, align 4, !tbaa !5
  %cmp403 = icmp sgt i32 %260, 19
  br i1 %cmp403, label %if.then.405, label %if.end.407

if.then.405:                                      ; preds = %if.end.402
  %261 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id406 = getelementptr inbounds %struct.envelope, %struct.envelope* %261, i32 0, i32 25
  %262 = load i8*, i8** %e_id406, align 8, !tbaa !7
  %263 = load i8*, i8** %howlong, align 8, !tbaa !1
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 7, i8* %262, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.247, i32 0, i32 0), i8* %263)
  br label %if.end.407

if.end.407:                                       ; preds = %if.then.405, %if.end.402
  %264 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id408 = getelementptr inbounds %struct.envelope, %struct.envelope* %264, i32 0, i32 25
  store i8* null, i8** %e_id408, align 8, !tbaa !7
  %265 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  call void @unlockqueue(%struct.envelope* %265)
  %266 = load i8*, i8** %bp, align 8, !tbaa !1
  %arraydecay409 = getelementptr inbounds [2048 x i8], [2048 x i8]* %buf, i32 0, i32 0
  %cmp410 = icmp ne i8* %266, %arraydecay409
  br i1 %cmp410, label %if.then.412, label %if.end.413

if.then.412:                                      ; preds = %if.end.407
  %267 = load i8*, i8** %bp, align 8, !tbaa !1
  call void @sm_free_tagged(i8* %267, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 4349)
  br label %if.end.413

if.end.413:                                       ; preds = %if.then.412, %if.end.407
  store i32 0, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  %268 = bitcast i8** %howlong to i8*
  call void @llvm.lifetime.end(i64 8, i8* %268) #1
  br label %cleanup.575

if.end.415:                                       ; preds = %land.lhs.true.380, %land.lhs.true.376, %sw.bb.369
  %269 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_macro416 = getelementptr inbounds %struct.envelope, %struct.envelope* %269, i32 0, i32 46
  %call417 = call i32 @macid_parse(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.248, i32 0, i32 0), i8** null)
  %arrayidx418 = getelementptr inbounds [2048 x i8], [2048 x i8]* %buf, i32 0, i64 1
  %270 = load i32, i32* @SmHeapGroup, align 4, !tbaa !5
  call void @macdefine_tagged(%struct.MACROS_T* %e_macro416, i32 1, i32 %call417, i8* %arrayidx418, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 4353, i32 %270)
  %271 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_ntries419 = getelementptr inbounds %struct.envelope, %struct.envelope* %271, i32 0, i32 43
  %272 = load i32, i32* %e_ntries419, align 4, !tbaa !34
  %cmp420 = icmp eq i32 %272, 0
  br i1 %cmp420, label %if.then.422, label %if.else.426

if.then.422:                                      ; preds = %if.end.415
  %273 = load i32, i32* getelementptr inbounds (%struct.anon, %struct.anon* @TimeOuts, i32 0, i32 21, i64 0), align 4, !tbaa !5
  %call423 = call %struct.__res_state* @__res_state() #11
  %retry = getelementptr inbounds %struct.__res_state, %struct.__res_state* %call423, i32 0, i32 1
  store i32 %273, i32* %retry, align 4, !tbaa !143
  %274 = load i64, i64* getelementptr inbounds (%struct.anon, %struct.anon* @TimeOuts, i32 0, i32 20, i64 0), align 8, !tbaa !92
  %conv424 = trunc i64 %274 to i32
  %call425 = call %struct.__res_state* @__res_state() #11
  %retrans = getelementptr inbounds %struct.__res_state, %struct.__res_state* %call425, i32 0, i32 0
  store i32 %conv424, i32* %retrans, align 4, !tbaa !145
  br label %if.end.432

if.else.426:                                      ; preds = %if.end.415
  %275 = load i32, i32* getelementptr inbounds (%struct.anon, %struct.anon* @TimeOuts, i32 0, i32 21, i64 1), align 4, !tbaa !5
  %call427 = call %struct.__res_state* @__res_state() #11
  %retry428 = getelementptr inbounds %struct.__res_state, %struct.__res_state* %call427, i32 0, i32 1
  store i32 %275, i32* %retry428, align 4, !tbaa !143
  %276 = load i64, i64* getelementptr inbounds (%struct.anon, %struct.anon* @TimeOuts, i32 0, i32 20, i64 1), align 8, !tbaa !92
  %conv429 = trunc i64 %276 to i32
  %call430 = call %struct.__res_state* @__res_state() #11
  %retrans431 = getelementptr inbounds %struct.__res_state, %struct.__res_state* %call430, i32 0, i32 0
  store i32 %conv429, i32* %retrans431, align 4, !tbaa !145
  br label %if.end.432

if.end.432:                                       ; preds = %if.else.426, %if.then.422
  br label %sw.epilog.565

sw.bb.433:                                        ; preds = %if.end.261
  %277 = load i8*, i8** %bp, align 8, !tbaa !1
  %arrayidx434 = getelementptr inbounds i8, i8* %277, i64 1
  %call435 = call i64 @atol(i8* %arrayidx434) #14
  %278 = load i64, i64* @WkTimeFact, align 8, !tbaa !92
  %add436 = add nsw i64 %call435, %278
  %279 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_msgpriority = getelementptr inbounds %struct.envelope, %struct.envelope* %279, i32 0, i32 1
  store i64 %add436, i64* %e_msgpriority, align 8, !tbaa !35
  br label %sw.epilog.565

sw.bb.437:                                        ; preds = %if.end.261
  %280 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_rpool438 = getelementptr inbounds %struct.envelope, %struct.envelope* %280, i32 0, i32 52
  %281 = load %struct.SM_RPOOL_T*, %struct.SM_RPOOL_T** %e_rpool438, align 8, !tbaa !120
  %282 = load i8*, i8** %bp, align 8, !tbaa !1
  %arrayidx439 = getelementptr inbounds i8, i8* %282, i64 1
  %call440 = call i8* @sm_rpool_strdup_x(%struct.SM_RPOOL_T* %281, i8* %arrayidx439)
  store i8* %call440, i8** %orcpt, align 8, !tbaa !1
  br label %sw.epilog.565

sw.bb.441:                                        ; preds = %if.end.261
  %283 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_rpool442 = getelementptr inbounds %struct.envelope, %struct.envelope* %283, i32 0, i32 52
  %284 = load %struct.SM_RPOOL_T*, %struct.SM_RPOOL_T** %e_rpool442, align 8, !tbaa !120
  %285 = load i8*, i8** %bp, align 8, !tbaa !1
  %arrayidx443 = getelementptr inbounds i8, i8* %285, i64 1
  %call444 = call i8* @sm_rpool_strdup_x(%struct.SM_RPOOL_T* %284, i8* %arrayidx443)
  store i8* %call444, i8** %frcpt, align 8, !tbaa !1
  br label %sw.epilog.565

sw.bb.445:                                        ; preds = %if.end.261
  %286 = load i8*, i8** %bp, align 8, !tbaa !1
  store i8* %286, i8** %p, align 8, !tbaa !1
  store i64 0, i64* %qflags, align 8, !tbaa !92
  %287 = load i32, i32* %qfver, align 4, !tbaa !5
  %cmp446 = icmp sge i32 %287, 1
  br i1 %cmp446, label %if.then.448, label %if.else.483

if.then.448:                                      ; preds = %sw.bb.445
  br label %while.cond.449

while.cond.449:                                   ; preds = %sw.epilog.482, %if.then.448
  %288 = load i8*, i8** %p, align 8, !tbaa !1
  %incdec.ptr450 = getelementptr inbounds i8, i8* %288, i32 1
  store i8* %incdec.ptr450, i8** %p, align 8, !tbaa !1
  %289 = load i8, i8* %incdec.ptr450, align 1, !tbaa !17
  %conv451 = sext i8 %289 to i32
  %cmp452 = icmp ne i32 %conv451, 0
  br i1 %cmp452, label %land.rhs.454, label %land.end.458

land.rhs.454:                                     ; preds = %while.cond.449
  %290 = load i8*, i8** %p, align 8, !tbaa !1
  %291 = load i8, i8* %290, align 1, !tbaa !17
  %conv455 = sext i8 %291 to i32
  %cmp456 = icmp ne i32 %conv455, 58
  br label %land.end.458

land.end.458:                                     ; preds = %land.rhs.454, %while.cond.449
  %292 = phi i1 [ false, %while.cond.449 ], [ %cmp456, %land.rhs.454 ]
  br i1 %292, label %while.body.460, label %while.end

while.body.460:                                   ; preds = %land.end.458
  %293 = load i8*, i8** %p, align 8, !tbaa !1
  %294 = load i8, i8* %293, align 1, !tbaa !17
  %conv461 = sext i8 %294 to i32
  switch i32 %conv461, label %sw.default [
    i32 78, label %sw.bb.462
    i32 83, label %sw.bb.464
    i32 70, label %sw.bb.466
    i32 68, label %sw.bb.468
    i32 80, label %sw.bb.470
    i32 65, label %sw.bb.472
    i32 66, label %sw.bb.478
    i32 89, label %sw.bb.480
  ]

sw.bb.462:                                        ; preds = %while.body.460
  %295 = load i64, i64* %qflags, align 8, !tbaa !92
  %or463 = or i64 %295, 512
  store i64 %or463, i64* %qflags, align 8, !tbaa !92
  br label %sw.epilog.482

sw.bb.464:                                        ; preds = %while.body.460
  %296 = load i64, i64* %qflags, align 8, !tbaa !92
  %or465 = or i64 %296, 64
  store i64 %or465, i64* %qflags, align 8, !tbaa !92
  br label %sw.epilog.482

sw.bb.466:                                        ; preds = %while.body.460
  %297 = load i64, i64* %qflags, align 8, !tbaa !92
  %or467 = or i64 %297, 128
  store i64 %or467, i64* %qflags, align 8, !tbaa !92
  br label %sw.epilog.482

sw.bb.468:                                        ; preds = %while.body.460
  %298 = load i64, i64* %qflags, align 8, !tbaa !92
  %or469 = or i64 %298, 256
  store i64 %or469, i64* %qflags, align 8, !tbaa !92
  br label %sw.epilog.482

sw.bb.470:                                        ; preds = %while.body.460
  %299 = load i64, i64* %qflags, align 8, !tbaa !92
  %or471 = or i64 %299, 2
  store i64 %or471, i64* %qflags, align 8, !tbaa !92
  br label %sw.epilog.482

sw.bb.472:                                        ; preds = %while.body.460
  %300 = load %struct.address*, %struct.address** %ctladdr, align 8, !tbaa !1
  %cmp473 = icmp ne %struct.address* %300, null
  br i1 %cmp473, label %if.then.475, label %if.end.477

if.then.475:                                      ; preds = %sw.bb.472
  %301 = load %struct.address*, %struct.address** %ctladdr, align 8, !tbaa !1
  %q_flags = getelementptr inbounds %struct.address, %struct.address* %301, i32 0, i32 5
  %302 = load i64, i64* %q_flags, align 8, !tbaa !56
  %or476 = or i64 %302, 16384
  store i64 %or476, i64* %q_flags, align 8, !tbaa !56
  br label %if.end.477

if.end.477:                                       ; preds = %if.then.475, %sw.bb.472
  br label %sw.epilog.482

sw.bb.478:                                        ; preds = %while.body.460
  %303 = load i64, i64* %qflags, align 8, !tbaa !92
  %or479 = or i64 %303, 262144
  store i64 %or479, i64* %qflags, align 8, !tbaa !92
  br label %sw.epilog.482

sw.bb.480:                                        ; preds = %while.body.460
  %304 = load i64, i64* %qflags, align 8, !tbaa !92
  %or481 = or i64 %304, 524288
  store i64 %or481, i64* %qflags, align 8, !tbaa !92
  br label %sw.epilog.482

sw.default:                                       ; preds = %while.body.460
  br label %sw.epilog.482

sw.epilog.482:                                    ; preds = %sw.default, %sw.bb.480, %sw.bb.478, %if.end.477, %sw.bb.470, %sw.bb.468, %sw.bb.466, %sw.bb.464, %sw.bb.462
  br label %while.cond.449

while.end:                                        ; preds = %land.end.458
  br label %if.end.485

if.else.483:                                      ; preds = %sw.bb.445
  %305 = load i64, i64* %qflags, align 8, !tbaa !92
  %or484 = or i64 %305, 2
  store i64 %or484, i64* %qflags, align 8, !tbaa !92
  br label %if.end.485

if.end.485:                                       ; preds = %if.else.483, %while.end
  %306 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_macro486 = getelementptr inbounds %struct.envelope, %struct.envelope* %306, i32 0, i32 46
  %call487 = call i32 @macid_parse(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.249, i32 0, i32 0), i8** null)
  %307 = load i64, i64* %qflags, align 8, !tbaa !92
  %and488 = and i64 %307, 262144
  %cmp489 = icmp ne i64 %and488, 0
  %cond491 = select i1 %cmp489, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.250, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.251, i32 0, i32 0)
  %308 = load i32, i32* @SmHeapGroup, align 4, !tbaa !5
  call void @macdefine_tagged(%struct.MACROS_T* %e_macro486, i32 2, i32 %call487, i8* %cond491, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 4433, i32 %308)
  %309 = load i8*, i8** %p, align 8, !tbaa !1
  %310 = load i8, i8* %309, align 1, !tbaa !17
  %conv492 = sext i8 %310 to i32
  %cmp493 = icmp ne i32 %conv492, 0
  br i1 %cmp493, label %if.then.495, label %if.else.498

if.then.495:                                      ; preds = %if.end.485
  %311 = load i8*, i8** %p, align 8, !tbaa !1
  %incdec.ptr496 = getelementptr inbounds i8, i8* %311, i32 1
  store i8* %incdec.ptr496, i8** %p, align 8, !tbaa !1
  %312 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %call497 = call %struct.address* @parseaddr(i8* %incdec.ptr496, %struct.address* null, i32 48, i32 0, i8** null, %struct.envelope* %312, i32 1)
  store %struct.address* %call497, %struct.address** %q, align 8, !tbaa !1
  br label %if.end.499

if.else.498:                                      ; preds = %if.end.485
  store %struct.address* null, %struct.address** %q, align 8, !tbaa !1
  br label %if.end.499

if.end.499:                                       ; preds = %if.else.498, %if.then.495
  %313 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %cmp500 = icmp ne %struct.address* %313, null
  br i1 %cmp500, label %if.then.502, label %if.end.518

if.then.502:                                      ; preds = %if.end.499
  %314 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qgrp503 = getelementptr inbounds %struct.envelope, %struct.envelope* %314, i32 0, i32 26
  %315 = load i32, i32* %e_qgrp503, align 4, !tbaa !18
  %cmp504 = icmp sge i32 %315, 0
  br i1 %cmp504, label %if.then.506, label %if.end.508

if.then.506:                                      ; preds = %if.then.502
  %316 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qgrp507 = getelementptr inbounds %struct.envelope, %struct.envelope* %316, i32 0, i32 26
  %317 = load i32, i32* %e_qgrp507, align 4, !tbaa !18
  %318 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_qgrp = getelementptr inbounds %struct.address, %struct.address* %318, i32 0, i32 23
  store i32 %317, i32* %q_qgrp, align 4, !tbaa !146
  br label %if.end.508

if.end.508:                                       ; preds = %if.then.506, %if.then.502
  %319 = load %struct.address*, %struct.address** %ctladdr, align 8, !tbaa !1
  %320 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_alias = getelementptr inbounds %struct.address, %struct.address* %320, i32 0, i32 11
  store %struct.address* %319, %struct.address** %q_alias, align 8, !tbaa !57
  %321 = load i32, i32* %qfver, align 4, !tbaa !5
  %cmp509 = icmp sge i32 %321, 1
  br i1 %cmp509, label %if.then.511, label %if.end.514

if.then.511:                                      ; preds = %if.end.508
  %322 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_flags512 = getelementptr inbounds %struct.address, %struct.address* %322, i32 0, i32 5
  %323 = load i64, i64* %q_flags512, align 8, !tbaa !56
  %and513 = and i64 %323, -449
  store i64 %and513, i64* %q_flags512, align 8, !tbaa !56
  br label %if.end.514

if.end.514:                                       ; preds = %if.then.511, %if.end.508
  %324 = load i64, i64* %qflags, align 8, !tbaa !92
  %325 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_flags515 = getelementptr inbounds %struct.address, %struct.address* %325, i32 0, i32 5
  %326 = load i64, i64* %q_flags515, align 8, !tbaa !56
  %or516 = or i64 %326, %324
  store i64 %or516, i64* %q_flags515, align 8, !tbaa !56
  %327 = load i8*, i8** %frcpt, align 8, !tbaa !1
  %328 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_finalrcpt = getelementptr inbounds %struct.address, %struct.address* %328, i32 0, i32 15
  store i8* %327, i8** %q_finalrcpt, align 8, !tbaa !55
  %329 = load i8*, i8** %orcpt, align 8, !tbaa !1
  %330 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_orcpt = getelementptr inbounds %struct.address, %struct.address* %330, i32 0, i32 16
  store i8* %329, i8** %q_orcpt, align 8, !tbaa !54
  %331 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %332 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_sendqueue = getelementptr inbounds %struct.envelope, %struct.envelope* %332, i32 0, i32 7
  %333 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %call517 = call %struct.address* @recipient(%struct.address* %331, %struct.address** %e_sendqueue, i32 0, %struct.envelope* %333)
  br label %if.end.518

if.end.518:                                       ; preds = %if.end.514, %if.end.499
  store i8* null, i8** %frcpt, align 8, !tbaa !1
  store i8* null, i8** %orcpt, align 8, !tbaa !1
  %334 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_macro519 = getelementptr inbounds %struct.envelope, %struct.envelope* %334, i32 0, i32 46
  %call520 = call i32 @macid_parse(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.249, i32 0, i32 0), i8** null)
  %335 = load i32, i32* @SmHeapGroup, align 4, !tbaa !5
  call void @macdefine_tagged(%struct.MACROS_T* %e_macro519, i32 2, i32 %call520, i8* null, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 4459, i32 %335)
  br label %sw.epilog.565

sw.bb.521:                                        ; preds = %if.end.261
  %336 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_rpool522 = getelementptr inbounds %struct.envelope, %struct.envelope* %336, i32 0, i32 52
  %337 = load %struct.SM_RPOOL_T*, %struct.SM_RPOOL_T** %e_rpool522, align 8, !tbaa !120
  %338 = load i8*, i8** %bp, align 8, !tbaa !1
  %arrayidx523 = getelementptr inbounds i8, i8* %338, i64 1
  %call524 = call i8* @sm_rpool_strdup_x(%struct.SM_RPOOL_T* %337, i8* %arrayidx523)
  %339 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  call void @setsender(i8* %call524, %struct.envelope* %339, i8** null, i32 0, i32 1)
  br label %sw.epilog.565

sw.bb.525:                                        ; preds = %if.end.261
  %340 = load i8*, i8** %bp, align 8, !tbaa !1
  %arrayidx526 = getelementptr inbounds i8, i8* %340, i64 1
  %call527 = call i64 @atol(i8* %arrayidx526) #14
  %341 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_ctime = getelementptr inbounds %struct.envelope, %struct.envelope* %341, i32 0, i32 2
  store i64 %call527, i64* %e_ctime, align 8, !tbaa !32
  br label %sw.epilog.565

sw.bb.528:                                        ; preds = %if.end.261
  %342 = load i8*, i8** %bp, align 8, !tbaa !1
  %arrayidx529 = getelementptr inbounds i8, i8* %342, i64 1
  %call530 = call i32 @atoi(i8* %arrayidx529) #14
  store i32 %call530, i32* %qfver, align 4, !tbaa !5
  %343 = load i32, i32* %qfver, align 4, !tbaa !5
  %cmp531 = icmp sle i32 %343, 8
  br i1 %cmp531, label %if.then.533, label %if.end.534

if.then.533:                                      ; preds = %sw.bb.528
  br label %sw.epilog.565

if.end.534:                                       ; preds = %sw.bb.528
  %344 = load i32, i32* %qfver, align 4, !tbaa !5
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([56 x i8], [56 x i8]* @.str.252, i32 0, i32 0), i32 %344, i32 8)
  store i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.253, i32 0, i32 0), i8** %err, align 8, !tbaa !1
  store i32 5, i32* %cleanup.dest.slot
  br label %cleanup.575

sw.bb.535:                                        ; preds = %if.end.261
  %345 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_rpool536 = getelementptr inbounds %struct.envelope, %struct.envelope* %345, i32 0, i32 52
  %346 = load %struct.SM_RPOOL_T*, %struct.SM_RPOOL_T** %e_rpool536, align 8, !tbaa !120
  %347 = load i8*, i8** %bp, align 8, !tbaa !1
  %arrayidx537 = getelementptr inbounds i8, i8* %347, i64 1
  %call538 = call i8* @sm_rpool_strdup_x(%struct.SM_RPOOL_T* %346, i8* %arrayidx537)
  %348 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_envid = getelementptr inbounds %struct.envelope, %struct.envelope* %348, i32 0, i32 40
  store i8* %call538, i8** %e_envid, align 8, !tbaa !48
  %349 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_macro539 = getelementptr inbounds %struct.envelope, %struct.envelope* %349, i32 0, i32 46
  %call540 = call i32 @macid_parse(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.254, i32 0, i32 0), i8** null)
  %350 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_envid541 = getelementptr inbounds %struct.envelope, %struct.envelope* %350, i32 0, i32 40
  %351 = load i8*, i8** %e_envid541, align 8, !tbaa !48
  %352 = load i32, i32* @SmHeapGroup, align 4, !tbaa !5
  call void @macdefine_tagged(%struct.MACROS_T* %e_macro539, i32 2, i32 %call540, i8* %351, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 4485, i32 %352)
  br label %sw.epilog.565

sw.bb.542:                                        ; preds = %if.end.261
  %arrayidx543 = getelementptr inbounds [2048 x i8], [2048 x i8]* %buf, i32 0, i64 1
  %353 = load i8, i8* %arrayidx543, align 1, !tbaa !17
  %conv544 = sext i8 %353 to i32
  %354 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_dlvr_flag = getelementptr inbounds %struct.envelope, %struct.envelope* %354, i32 0, i32 51
  store i32 %conv544, i32* %e_dlvr_flag, align 4, !tbaa !50
  %arrayidx545 = getelementptr inbounds [2048 x i8], [2048 x i8]* %buf, i32 0, i64 3
  %call546 = call i64 @strtol(i8* %arrayidx545, i8** null, i32 10) #1
  %355 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_deliver_by = getelementptr inbounds %struct.envelope, %struct.envelope* %355, i32 0, i32 50
  store i64 %call546, i64* %e_deliver_by, align 8, !tbaa !51
  br label %sw.bb.547

sw.bb.547:                                        ; preds = %if.end.261, %sw.bb.542
  %356 = bitcast i8** %p549 to i8*
  call void @llvm.lifetime.start(i64 8, i8* %356) #1
  %357 = load i8*, i8** %bp, align 8, !tbaa !1
  %arrayidx550 = getelementptr inbounds i8, i8* %357, i64 1
  %call551 = call i32 @macid_parse(i8* %arrayidx550, i8** %ep)
  store i32 %call551, i32* %r, align 4, !tbaa !5
  %358 = load i32, i32* %r, align 4, !tbaa !5
  %cmp552 = icmp eq i32 %358, 0
  br i1 %cmp552, label %if.then.554, label %if.end.555

if.then.554:                                      ; preds = %sw.bb.547
  store i32 6, i32* %cleanup.dest.slot
  br label %cleanup.559

if.end.555:                                       ; preds = %sw.bb.547
  %359 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_rpool556 = getelementptr inbounds %struct.envelope, %struct.envelope* %359, i32 0, i32 52
  %360 = load %struct.SM_RPOOL_T*, %struct.SM_RPOOL_T** %e_rpool556, align 8, !tbaa !120
  %361 = load i8*, i8** %ep, align 8, !tbaa !1
  %call557 = call i8* @sm_rpool_strdup_x(%struct.SM_RPOOL_T* %360, i8* %361)
  store i8* %call557, i8** %p549, align 8, !tbaa !1
  %362 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_macro558 = getelementptr inbounds %struct.envelope, %struct.envelope* %362, i32 0, i32 46
  %363 = load i32, i32* %r, align 4, !tbaa !5
  %364 = load i8*, i8** %p549, align 8, !tbaa !1
  %365 = load i32, i32* @SmHeapGroup, align 4, !tbaa !5
  call void @macdefine_tagged(%struct.MACROS_T* %e_macro558, i32 2, i32 %363, i8* %364, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 4503, i32 %365)
  store i32 0, i32* %cleanup.dest.slot
  br label %cleanup.559

cleanup.559:                                      ; preds = %if.end.555, %if.then.554
  %366 = bitcast i8** %p549 to i8*
  call void @llvm.lifetime.end(i64 8, i8* %366) #1
  %cleanup.dest.560 = load i32, i32* %cleanup.dest.slot
  switch i32 %cleanup.dest.560, label %unreachable [
    i32 0, label %cleanup.cont
    i32 6, label %sw.epilog.565
  ]

cleanup.cont:                                     ; preds = %cleanup.559
  br label %sw.epilog.565

sw.bb.561:                                        ; preds = %if.end.261
  store i32 1, i32* %nomore, align 4, !tbaa !5
  br label %sw.epilog.565

sw.default.562:                                   ; preds = %if.end.261
  %arraydecay563 = getelementptr inbounds [4096 x i8], [4096 x i8]* %qf, i32 0, i32 0
  %367 = load i32, i32* @LineNumber, align 4, !tbaa !5
  %368 = load i8*, i8** %bp, align 8, !tbaa !1
  %call564 = call i8* @shortenstring(i8* %368, i64 203)
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.255, i32 0, i32 0), i8* %arraydecay563, i32 %367, i8* %call564)
  store i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.256, i32 0, i32 0), i8** %err, align 8, !tbaa !1
  store i32 5, i32* %cleanup.dest.slot
  br label %cleanup.575

sw.epilog.565:                                    ; preds = %sw.bb.561, %cleanup.cont, %cleanup.559, %sw.bb.535, %if.then.533, %sw.bb.525, %sw.bb.521, %if.end.518, %sw.bb.441, %sw.bb.437, %sw.bb.433, %if.end.432, %sw.bb.368, %sw.bb.365, %if.end.261, %if.end.261, %if.end.261, %sw.bb.360, %sw.bb.353, %for.end.352, %cleanup, %sw.bb.283, %if.end.279, %if.end.267
  %369 = load i8*, i8** %bp, align 8, !tbaa !1
  %arraydecay566 = getelementptr inbounds [2048 x i8], [2048 x i8]* %buf, i32 0, i32 0
  %cmp567 = icmp ne i8* %369, %arraydecay566
  br i1 %cmp567, label %if.then.569, label %if.end.574

if.then.569:                                      ; preds = %sw.epilog.565
  br label %do.body

do.body:                                          ; preds = %if.then.569
  %370 = load i8*, i8** %bp, align 8, !tbaa !1
  %cmp570 = icmp ne i8* %370, null
  br i1 %cmp570, label %if.then.572, label %if.end.573

if.then.572:                                      ; preds = %do.body
  %371 = load i8*, i8** %bp, align 8, !tbaa !1
  call void @sm_free_tagged(i8* %371, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 4519)
  store i8* null, i8** %bp, align 8, !tbaa !1
  br label %if.end.573

if.end.573:                                       ; preds = %if.then.572, %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end.573
  br label %do.end

do.end:                                           ; preds = %do.cond
  br label %if.end.574

if.end.574:                                       ; preds = %do.end, %sw.epilog.565
  store i32 0, i32* %cleanup.dest.slot
  br label %cleanup.575

cleanup.575:                                      ; preds = %sw.default.562, %if.end.534, %if.then.321, %hackattack, %if.end.574, %if.end.413, %cleanup
  %372 = bitcast i8** %ep to i8*
  call void @llvm.lifetime.end(i64 8, i8* %372) #1
  %373 = bitcast i64* %now to i8*
  call void @llvm.lifetime.end(i64 8, i8* %373) #1
  %374 = bitcast i32* %r to i8*
  call void @llvm.lifetime.end(i64 4, i8* %374) #1
  %375 = bitcast %struct.address** %q to i8*
  call void @llvm.lifetime.end(i64 8, i8* %375) #1
  %376 = bitcast i64* %qflags to i8*
  call void @llvm.lifetime.end(i64 8, i8* %376) #1
  %cleanup.dest.580 = load i32, i32* %cleanup.dest.slot
  switch i32 %cleanup.dest.580, label %cleanup.668 [
    i32 0, label %cleanup.cont.581
    i32 5, label %fail
  ]

cleanup.cont.581:                                 ; preds = %cleanup.575
  br label %while.cond

while.end.582:                                    ; preds = %while.cond
  %377 = load i32, i32* @LineNumber, align 4, !tbaa !5
  %cmp583 = icmp eq i32 %377, 0
  br i1 %cmp583, label %if.then.585, label %if.end.589

if.then.585:                                      ; preds = %while.end.582
  %call586 = call i32* @__errno_location() #11
  store i32 0, i32* %call586, align 4, !tbaa !5
  %378 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_flags587 = getelementptr inbounds %struct.envelope, %struct.envelope* %378, i32 0, i32 11
  %379 = load i64, i64* %e_flags587, align 8, !tbaa !15
  %or588 = or i64 %379, 168
  store i64 %or588, i64* %e_flags587, align 8, !tbaa !15
  store i32 1, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup.668

if.end.589:                                       ; preds = %while.end.582
  %380 = load i32, i32* %nomore, align 4, !tbaa !5
  %tobool590 = icmp ne i32 %380, 0
  br i1 %tobool590, label %if.end.594, label %if.then.591

if.then.591:                                      ; preds = %if.end.589
  %arraydecay592 = getelementptr inbounds [4096 x i8], [4096 x i8]* %qf, i32 0, i32 0
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.257, i32 0, i32 0), i8* %arraydecay592)
  %381 = load %struct.sm_file*, %struct.sm_file** %qfp, align 8, !tbaa !1
  %call593 = call i32 @sm_io_close(%struct.sm_file* %381, i32 -2)
  store i32 0, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup.668

if.end.594:                                       ; preds = %if.end.589
  %382 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_flags595 = getelementptr inbounds %struct.envelope, %struct.envelope* %382, i32 0, i32 11
  %383 = load i64, i64* %e_flags595, align 8, !tbaa !15
  %and596 = and i64 %383, 1048576
  %cmp597 = icmp ne i64 %and596, 0
  br i1 %cmp597, label %if.then.599, label %if.end.611

if.then.599:                                      ; preds = %if.end.594
  %384 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_flags600 = getelementptr inbounds %struct.envelope, %struct.envelope* %384, i32 0, i32 11
  %385 = load i64, i64* %e_flags600, align 8, !tbaa !15
  %and601 = and i64 %385, 4
  %cmp602 = icmp ne i64 %and601, 0
  br i1 %cmp602, label %if.then.604, label %if.else.607

if.then.604:                                      ; preds = %if.then.599
  %386 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_macro605 = getelementptr inbounds %struct.envelope, %struct.envelope* %386, i32 0, i32 46
  %call606 = call i32 @macid_parse(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.258, i32 0, i32 0), i8** null)
  %387 = load i32, i32* @SmHeapGroup, align 4, !tbaa !5
  call void @macdefine_tagged(%struct.MACROS_T* %e_macro605, i32 2, i32 %call606, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.259, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 4558, i32 %387)
  br label %if.end.610

if.else.607:                                      ; preds = %if.then.599
  %388 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_macro608 = getelementptr inbounds %struct.envelope, %struct.envelope* %388, i32 0, i32 46
  %call609 = call i32 @macid_parse(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.258, i32 0, i32 0), i8** null)
  %389 = load i32, i32* @SmHeapGroup, align 4, !tbaa !5
  call void @macdefine_tagged(%struct.MACROS_T* %e_macro608, i32 2, i32 %call609, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.260, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 4561, i32 %389)
  br label %if.end.610

if.end.610:                                       ; preds = %if.else.607, %if.then.604
  br label %if.end.611

if.end.611:                                       ; preds = %if.end.610, %if.end.594
  %390 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %call612 = call i8* @queuename(%struct.envelope* %390, i32 100)
  store i8* %call612, i8** %p, align 8, !tbaa !1
  %391 = load i8*, i8** %p, align 8, !tbaa !1
  %call613 = call %struct.sm_file* @sm_io_open(%struct.sm_file* @SmFtStdio_def, i32 -2, i8* %391, i32 2, i8* null)
  %392 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_dfp = getelementptr inbounds %struct.envelope, %struct.envelope* %392, i32 0, i32 24
  store %struct.sm_file* %call613, %struct.sm_file** %e_dfp, align 8, !tbaa !21
  %393 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_dfp614 = getelementptr inbounds %struct.envelope, %struct.envelope* %393, i32 0, i32 24
  %394 = load %struct.sm_file*, %struct.sm_file** %e_dfp614, align 8, !tbaa !21
  %cmp615 = icmp eq %struct.sm_file* %394, null
  br i1 %cmp615, label %if.then.617, label %if.else.618

if.then.617:                                      ; preds = %if.end.611
  %395 = load i8*, i8** %p, align 8, !tbaa !1
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.261, i32 0, i32 0), i8* %395)
  br label %if.end.647

if.else.618:                                      ; preds = %if.end.611
  %396 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_flags619 = getelementptr inbounds %struct.envelope, %struct.envelope* %396, i32 0, i32 11
  %397 = load i64, i64* %e_flags619, align 8, !tbaa !15
  %or620 = or i64 %397, 2097152
  store i64 %or620, i64* %e_flags619, align 8, !tbaa !15
  %398 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_dfp621 = getelementptr inbounds %struct.envelope, %struct.envelope* %398, i32 0, i32 24
  %399 = load %struct.sm_file*, %struct.sm_file** %e_dfp621, align 8, !tbaa !21
  %call622 = call i32 @sm_io_getinfo(%struct.sm_file* %399, i32 3, i8* null)
  %call623 = call i32 @fstat(i32 %call622, %struct.stat* %st) #1
  %cmp624 = icmp sge i32 %call623, 0
  br i1 %cmp624, label %if.then.626, label %if.end.646

if.then.626:                                      ; preds = %if.else.618
  %st_size627 = getelementptr inbounds %struct.stat, %struct.stat* %st, i32 0, i32 8
  %400 = load i64, i64* %st_size627, align 8, !tbaa !141
  %401 = load i64, i64* %hdrsize, align 8, !tbaa !92
  %add628 = add nsw i64 %400, %401
  %402 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_msgsize629 = getelementptr inbounds %struct.envelope, %struct.envelope* %402, i32 0, i32 9
  store i64 %add628, i64* %e_msgsize629, align 8, !tbaa !89
  %st_dev630 = getelementptr inbounds %struct.stat, %struct.stat* %st, i32 0, i32 0
  %403 = load i64, i64* %st_dev630, align 8, !tbaa !23
  %404 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_dfdev = getelementptr inbounds %struct.envelope, %struct.envelope* %404, i32 0, i32 44
  store i64 %403, i64* %e_dfdev, align 8, !tbaa !26
  %st_ino631 = getelementptr inbounds %struct.stat, %struct.stat* %st, i32 0, i32 1
  %405 = load i64, i64* %st_ino631, align 8, !tbaa !27
  %406 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_dfino632 = getelementptr inbounds %struct.envelope, %struct.envelope* %406, i32 0, i32 45
  store i64 %405, i64* %e_dfino632, align 8, !tbaa !22
  %arraydecay633 = getelementptr inbounds [2048 x i8], [2048 x i8]* %buf, i32 0, i32 0
  %407 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_msgsize634 = getelementptr inbounds %struct.envelope, %struct.envelope* %407, i32 0, i32 9
  %408 = load i64, i64* %e_msgsize634, align 8, !tbaa !89
  %cmp635 = icmp slt i64 %408, 0
  br i1 %cmp635, label %cond.true.637, label %cond.false.638

cond.true.637:                                    ; preds = %if.then.626
  br label %cond.end.640

cond.false.638:                                   ; preds = %if.then.626
  %409 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_msgsize639 = getelementptr inbounds %struct.envelope, %struct.envelope* %409, i32 0, i32 9
  %410 = load i64, i64* %e_msgsize639, align 8, !tbaa !89
  br label %cond.end.640

cond.end.640:                                     ; preds = %cond.false.638, %cond.true.637
  %cond641 = phi i64 [ 9223372036854775807, %cond.true.637 ], [ %410, %cond.false.638 ]
  %call642 = call i32 (i8*, i64, i8*, ...) @sm_snprintf(i8* %arraydecay633, i64 2048, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.262, i32 0, i32 0), i64 %cond641)
  %411 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_macro643 = getelementptr inbounds %struct.envelope, %struct.envelope* %411, i32 0, i32 46
  %call644 = call i32 @macid_parse(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.263, i32 0, i32 0), i8** null)
  %arraydecay645 = getelementptr inbounds [2048 x i8], [2048 x i8]* %buf, i32 0, i32 0
  %412 = load i32, i32* @SmHeapGroup, align 4, !tbaa !5
  call void @macdefine_tagged(%struct.MACROS_T* %e_macro643, i32 1, i32 %call644, i8* %arraydecay645, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 4587, i32 %412)
  br label %if.end.646

if.end.646:                                       ; preds = %cond.end.640, %if.else.618
  br label %if.end.647

if.end.647:                                       ; preds = %if.end.646, %if.then.617
  store i32 1, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup.668

fail:                                             ; preds = %cleanup.575
  %413 = load i8*, i8** %bp, align 8, !tbaa !1
  %arraydecay648 = getelementptr inbounds [2048 x i8], [2048 x i8]* %buf, i32 0, i32 0
  %cmp649 = icmp ne i8* %413, %arraydecay648
  br i1 %cmp649, label %if.then.651, label %if.end.659

if.then.651:                                      ; preds = %fail
  br label %do.body.652

do.body.652:                                      ; preds = %if.then.651
  %414 = load i8*, i8** %bp, align 8, !tbaa !1
  %cmp653 = icmp ne i8* %414, null
  br i1 %cmp653, label %if.then.655, label %if.end.656

if.then.655:                                      ; preds = %do.body.652
  %415 = load i8*, i8** %bp, align 8, !tbaa !1
  call void @sm_free_tagged(i8* %415, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 4604)
  store i8* null, i8** %bp, align 8, !tbaa !1
  br label %if.end.656

if.end.656:                                       ; preds = %if.then.655, %do.body.652
  br label %do.cond.657

do.cond.657:                                      ; preds = %if.end.656
  br label %do.end.658

do.end.658:                                       ; preds = %do.cond.657
  br label %if.end.659

if.end.659:                                       ; preds = %do.end.658, %fail
  %416 = load %struct.sm_file*, %struct.sm_file** %qfp, align 8, !tbaa !1
  %cmp660 = icmp ne %struct.sm_file* %416, null
  br i1 %cmp660, label %if.then.662, label %if.end.664

if.then.662:                                      ; preds = %if.end.659
  %417 = load %struct.sm_file*, %struct.sm_file** %qfp, align 8, !tbaa !1
  %call663 = call i32 @sm_io_close(%struct.sm_file* %417, i32 -2)
  br label %if.end.664

if.end.664:                                       ; preds = %if.then.662, %if.end.659
  %418 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_lockfp665 = getelementptr inbounds %struct.envelope, %struct.envelope* %418, i32 0, i32 33
  store %struct.sm_file* null, %struct.sm_file** %e_lockfp665, align 8, !tbaa !16
  %419 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_flags666 = getelementptr inbounds %struct.envelope, %struct.envelope* %419, i32 0, i32 11
  %420 = load i64, i64* %e_flags666, align 8, !tbaa !15
  %or667 = or i64 %420, 2
  store i64 %or667, i64* %e_flags666, align 8, !tbaa !15
  %421 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %422 = load i8*, i8** %err, align 8, !tbaa !1
  call void @loseqfile(%struct.envelope* %421, i8* %422)
  store i32 0, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup.668

cleanup.668:                                      ; preds = %if.end.664, %if.end.647, %if.then.591, %if.then.585, %cleanup.575, %if.then.242, %if.then.230, %if.end.224, %if.end.207, %if.end.106, %if.end.62, %if.end.41, %if.end.18
  %423 = bitcast i32* %bufsize to i8*
  call void @llvm.lifetime.end(i64 4, i8* %423) #1
  %424 = bitcast [2048 x i8]* %buf to i8*
  call void @llvm.lifetime.end(i64 2048, i8* %424) #1
  %425 = bitcast [4096 x i8]* %qf to i8*
  call void @llvm.lifetime.end(i64 4096, i8* %425) #1
  %426 = bitcast i8** %err to i8*
  call void @llvm.lifetime.end(i64 8, i8* %426) #1
  %427 = bitcast i32* %qsafe to i8*
  call void @llvm.lifetime.end(i64 4, i8* %427) #1
  %428 = bitcast i32* %bogus to i8*
  call void @llvm.lifetime.end(i64 4, i8* %428) #1
  %429 = bitcast i32* %nomore to i8*
  call void @llvm.lifetime.end(i64 4, i8* %429) #1
  %430 = bitcast i8** %orcpt to i8*
  call void @llvm.lifetime.end(i64 8, i8* %430) #1
  %431 = bitcast i8** %frcpt to i8*
  call void @llvm.lifetime.end(i64 8, i8* %431) #1
  %432 = bitcast i8** %p to i8*
  call void @llvm.lifetime.end(i64 8, i8* %432) #1
  %433 = bitcast i64* %hdrsize to i8*
  call void @llvm.lifetime.end(i64 8, i8* %433) #1
  %434 = bitcast i32* %qfver to i8*
  call void @llvm.lifetime.end(i64 4, i8* %434) #1
  %435 = bitcast i8** %bp to i8*
  call void @llvm.lifetime.end(i64 8, i8* %435) #1
  %436 = bitcast %struct.stat* %stf to i8*
  call void @llvm.lifetime.end(i64 144, i8* %436) #1
  %437 = bitcast %struct.stat* %st to i8*
  call void @llvm.lifetime.end(i64 144, i8* %437) #1
  %438 = bitcast %struct.address** %ctladdr to i8*
  call void @llvm.lifetime.end(i64 8, i8* %438) #1
  %439 = bitcast %struct.sm_file** %qfp to i8*
  call void @llvm.lifetime.end(i64 8, i8* %439) #1
  %440 = load i32, i32* %retval
  ret i32 %440

unreachable:                                      ; preds = %cleanup.559
  unreachable
}

declare void @eatheader(%struct.envelope*, i32, i32) #2

declare void @sendall(%struct.envelope*, i32) #2

declare i32 @dropenvelope(%struct.envelope*, i32, i32) #2

; Function Attrs: nounwind uwtable
define i32 @doworklist(%struct.envelope* %el, i32 %forkflag, i32 %requeueflag) #0 {
entry:
  %retval = alloca i32, align 4
  %el.addr = alloca %struct.envelope*, align 8
  %forkflag.addr = alloca i32, align 4
  %requeueflag.addr = alloca i32, align 4
  %pid = alloca i32, align 4
  %ei = alloca %struct.envelope*, align 8
  %cleanup.dest.slot = alloca i32
  %e = alloca %struct.envelope, align 8
  %rpool = alloca %struct.SM_RPOOL_T*, align 8
  store %struct.envelope* %el, %struct.envelope** %el.addr, align 8, !tbaa !1
  store i32 %forkflag, i32* %forkflag.addr, align 4, !tbaa !5
  store i32 %requeueflag, i32* %requeueflag.addr, align 4, !tbaa !5
  %0 = bitcast i32* %pid to i8*
  call void @llvm.lifetime.start(i64 4, i8* %0) #1
  %1 = bitcast %struct.envelope** %ei to i8*
  call void @llvm.lifetime.start(i64 8, i8* %1) #1
  %2 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 40), align 1, !tbaa !17
  %conv = zext i8 %2 to i32
  %cmp = icmp sge i32 %conv, 1
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %3 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.88, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %4 = load i32, i32* %forkflag.addr, align 4, !tbaa !5
  %tobool2 = icmp ne i32 %4, 0
  br i1 %tobool2, label %if.then.3, label %if.else.27

if.then.3:                                        ; preds = %if.end
  call void @closemaps(i32 0)
  %call = call i32 @fork() #1
  store i32 %call, i32* %pid, align 4, !tbaa !5
  %5 = load i32, i32* %pid, align 4, !tbaa !5
  %cmp4 = icmp slt i32 %5, 0
  br i1 %cmp4, label %if.then.6, label %if.else

if.then.6:                                        ; preds = %if.then.3
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.89, i32 0, i32 0))
  store i32 0, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup.97

if.else:                                          ; preds = %if.then.3
  %6 = load i32, i32* %pid, align 4, !tbaa !5
  %cmp7 = icmp sgt i32 %6, 0
  br i1 %cmp7, label %if.then.9, label %if.else.10

if.then.9:                                        ; preds = %if.else
  call void @mci_flush(i32 0, %struct.mailer_con_info* null)
  br label %if.end.25

if.else.10:                                       ; preds = %if.else
  store volatile i8* null, i8** @RestartRequest, align 8, !tbaa !1
  store volatile i32 0, i32* @RestartWorkGroup, align 4, !tbaa !5
  store volatile i8* null, i8** @ShutdownRequest, align 8, !tbaa !1
  store volatile i32 0, i32* @PendingSignal, align 4, !tbaa !5
  %call11 = call i32 @getpid() #1
  store i32 %call11, i32* @CurrentPid, align 4, !tbaa !5
  call void @sm_exc_newthread(void (%struct.sm_exc*)* @fatal_error)
  %7 = load i8, i8* @OpMode, align 1, !tbaa !17
  %conv12 = sext i8 %7 to i32
  %cmp13 = icmp eq i32 %conv12, 115
  br i1 %cmp13, label %if.then.21, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else.10
  %8 = load i8, i8* @OpMode, align 1, !tbaa !17
  %conv15 = sext i8 %8 to i32
  %cmp16 = icmp eq i32 %conv15, 100
  br i1 %cmp16, label %if.then.21, label %lor.lhs.false.18

lor.lhs.false.18:                                 ; preds = %lor.lhs.false
  %9 = load i32, i32* @MaxQueueChildren, align 4, !tbaa !5
  %cmp19 = icmp sgt i32 %9, 0
  br i1 %cmp19, label %if.then.21, label %if.end.24

if.then.21:                                       ; preds = %lor.lhs.false.18, %lor.lhs.false, %if.else.10
  call void @proc_list_clear()
  %call22 = call i32 @sm_releasesignal(i32 17)
  %call23 = call void (i32)* @sm_signal(i32 17, void (i32)* null)
  br label %if.end.24

if.end.24:                                        ; preds = %if.then.21, %lor.lhs.false.18
  store i32 0, i32* @OnlyOneError, align 4, !tbaa !5
  store i32 0, i32* @QuickAbort, align 4, !tbaa !5
  br label %if.end.25

if.end.25:                                        ; preds = %if.end.24, %if.then.9
  br label %if.end.26

if.end.26:                                        ; preds = %if.end.25
  br label %if.end.28

if.else.27:                                       ; preds = %if.end
  store i32 0, i32* %pid, align 4, !tbaa !5
  br label %if.end.28

if.end.28:                                        ; preds = %if.else.27, %if.end.26
  %10 = load i32, i32* %pid, align 4, !tbaa !5
  %cmp29 = icmp ne i32 %10, 0
  br i1 %cmp29, label %if.then.31, label %if.end.32

if.then.31:                                       ; preds = %if.end.28
  %11 = load i32, i32* %pid, align 4, !tbaa !5
  store i32 %11, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup.97

if.end.32:                                        ; preds = %if.end.28
  %12 = load i32, i32* %forkflag.addr, align 4, !tbaa !5
  %tobool33 = icmp ne i32 %12, 0
  br i1 %tobool33, label %if.then.34, label %if.end.35

if.then.34:                                       ; preds = %if.end.32
  store volatile i8* null, i8** @RestartRequest, align 8, !tbaa !1
  store volatile i32 0, i32* @RestartWorkGroup, align 4, !tbaa !5
  store volatile i8* null, i8** @ShutdownRequest, align 8, !tbaa !1
  store volatile i32 0, i32* @PendingSignal, align 4, !tbaa !5
  br label %if.end.35

if.end.35:                                        ; preds = %if.then.34, %if.end.32
  call void @sm_clear_events()
  call void @clearstats()
  store i32 0, i32* @UseErrorsTo, align 4, !tbaa !5
  store i32 0, i32* @GrabTo, align 4, !tbaa !5
  store i32 0, i32* @ExitStat, align 4, !tbaa !5
  %13 = load i32, i32* %forkflag.addr, align 4, !tbaa !5
  %tobool36 = icmp ne i32 %13, 0
  br i1 %tobool36, label %if.then.37, label %if.end.38

if.then.37:                                       ; preds = %if.end.35
  %14 = load %struct.envelope*, %struct.envelope** %el.addr, align 8, !tbaa !1
  call void @disconnect(i32 1, %struct.envelope* %14)
  call void @set_op_mode(i32 113)
  br label %if.end.38

if.end.38:                                        ; preds = %if.then.37, %if.end.35
  %15 = load i32, i32* @LogLevel, align 4, !tbaa !5
  %cmp39 = icmp sgt i32 %15, 76
  br i1 %cmp39, label %if.then.41, label %if.end.42

if.then.41:                                       ; preds = %if.end.38
  %16 = load %struct.envelope*, %struct.envelope** %el.addr, align 8, !tbaa !1
  %e_id = getelementptr inbounds %struct.envelope, %struct.envelope* %16, i32 0, i32 25
  %17 = load i8*, i8** %e_id, align 8, !tbaa !7
  %18 = load i32, i32* @CurrentPid, align 4, !tbaa !5
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 7, i8* %17, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.90, i32 0, i32 0), i32 %18)
  br label %if.end.42

if.end.42:                                        ; preds = %if.then.41, %if.end.38
  %19 = load %struct.envelope*, %struct.envelope** %el.addr, align 8, !tbaa !1
  store %struct.envelope* %19, %struct.envelope** %ei, align 8, !tbaa !1
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end.42
  %20 = load %struct.envelope*, %struct.envelope** %ei, align 8, !tbaa !1
  %cmp43 = icmp ne %struct.envelope* %20, null
  br i1 %cmp43, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %21 = bitcast %struct.envelope* %e to i8*
  call void @llvm.lifetime.start(i64 2656, i8* %21) #1
  %22 = bitcast %struct.SM_RPOOL_T** %rpool to i8*
  call void @llvm.lifetime.start(i64 8, i8* %22) #1
  %23 = load %struct.envelope*, %struct.envelope** %ei, align 8, !tbaa !1
  %e_sendmode = getelementptr inbounds %struct.envelope, %struct.envelope* %23, i32 0, i32 16
  %24 = load i16, i16* %e_sendmode, align 2, !tbaa !147
  %conv45 = sext i16 %24 to i32
  %cmp46 = icmp eq i32 %conv45, 113
  br i1 %cmp46, label %if.then.53, label %lor.lhs.false.48

lor.lhs.false.48:                                 ; preds = %for.body
  %25 = load %struct.envelope*, %struct.envelope** %ei, align 8, !tbaa !1
  %e_sendmode49 = getelementptr inbounds %struct.envelope, %struct.envelope* %25, i32 0, i32 16
  %26 = load i16, i16* %e_sendmode49, align 2, !tbaa !147
  %conv50 = sext i16 %26 to i32
  %cmp51 = icmp eq i32 %conv50, 100
  br i1 %cmp51, label %if.then.53, label %if.else.54

if.then.53:                                       ; preds = %lor.lhs.false.48, %for.body
  store i32 4, i32* %cleanup.dest.slot
  br label %cleanup

if.else.54:                                       ; preds = %lor.lhs.false.48
  %27 = load i32, i32* @QueueMode, align 4, !tbaa !5
  %cmp55 = icmp ne i32 %27, 81
  br i1 %cmp55, label %land.lhs.true.57, label %if.end.61

land.lhs.true.57:                                 ; preds = %if.else.54
  %28 = load %struct.envelope*, %struct.envelope** %ei, align 8, !tbaa !1
  %e_quarmsg = getelementptr inbounds %struct.envelope, %struct.envelope* %28, i32 0, i32 36
  %29 = load i8*, i8** %e_quarmsg, align 8, !tbaa !43
  %cmp58 = icmp ne i8* %29, null
  br i1 %cmp58, label %if.then.60, label %if.end.61

if.then.60:                                       ; preds = %land.lhs.true.57
  store i32 4, i32* %cleanup.dest.slot
  br label %cleanup

if.end.61:                                        ; preds = %land.lhs.true.57, %if.else.54
  br label %if.end.62

if.end.62:                                        ; preds = %if.end.61
  %call63 = call %struct.SM_RPOOL_T* @sm_rpool_new_x(%struct.SM_RPOOL_T* null)
  store %struct.SM_RPOOL_T* %call63, %struct.SM_RPOOL_T** %rpool, align 8, !tbaa !1
  %30 = load %struct.SM_RPOOL_T*, %struct.SM_RPOOL_T** %rpool, align 8, !tbaa !1
  call void @clearenvelope(%struct.envelope* %e, i32 1, %struct.SM_RPOOL_T* %30)
  %e_flags = getelementptr inbounds %struct.envelope, %struct.envelope* %e, i32 0, i32 11
  %31 = load i64, i64* %e_flags, align 8, !tbaa !15
  %or = or i64 %31, 6144
  store i64 %or, i64* %e_flags, align 8, !tbaa !15
  call void @set_delivery_mode(i32 105, %struct.envelope* %e)
  %e_errormode = getelementptr inbounds %struct.envelope, %struct.envelope* %e, i32 0, i32 17
  store i16 109, i16* %e_errormode, align 2, !tbaa !137
  %32 = load %struct.envelope*, %struct.envelope** %ei, align 8, !tbaa !1
  %e_id64 = getelementptr inbounds %struct.envelope, %struct.envelope* %32, i32 0, i32 25
  %33 = load i8*, i8** %e_id64, align 8, !tbaa !7
  %e_id65 = getelementptr inbounds %struct.envelope, %struct.envelope* %e, i32 0, i32 25
  store i8* %33, i8** %e_id65, align 8, !tbaa !7
  %34 = load %struct.envelope*, %struct.envelope** %ei, align 8, !tbaa !1
  %e_qgrp = getelementptr inbounds %struct.envelope, %struct.envelope* %34, i32 0, i32 26
  %35 = load i32, i32* %e_qgrp, align 4, !tbaa !18
  %e_qgrp66 = getelementptr inbounds %struct.envelope, %struct.envelope* %e, i32 0, i32 26
  store i32 %35, i32* %e_qgrp66, align 4, !tbaa !18
  %36 = load %struct.envelope*, %struct.envelope** %ei, align 8, !tbaa !1
  %e_qdir = getelementptr inbounds %struct.envelope, %struct.envelope* %36, i32 0, i32 27
  %37 = load i32, i32* %e_qdir, align 4, !tbaa !19
  %e_qdir67 = getelementptr inbounds %struct.envelope, %struct.envelope* %e, i32 0, i32 27
  store i32 %37, i32* %e_qdir67, align 4, !tbaa !19
  call void @openxscript(%struct.envelope* %e)
  %call68 = call i8* @qid_printname(%struct.envelope* %e)
  call void (i32, %struct.envelope*, i8*, ...) @sm_setproctitle(i32 1, %struct.envelope* %e, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.85, i32 0, i32 0), i8* %call68)
  %e_header = getelementptr inbounds %struct.envelope, %struct.envelope* %e, i32 0, i32 0
  store %struct.header* null, %struct.header** %e_header, align 8, !tbaa !69
  store %struct.envelope* %e, %struct.envelope** @CurEnv, align 8, !tbaa !1
  %call69 = call i32 @readqf(%struct.envelope* %e, i32 0)
  %tobool70 = icmp ne i32 %call69, 0
  br i1 %tobool70, label %if.then.71, label %if.else.78

if.then.71:                                       ; preds = %if.end.62
  %e_flags72 = getelementptr inbounds %struct.envelope, %struct.envelope* %e, i32 0, i32 11
  %38 = load i64, i64* %e_flags72, align 8, !tbaa !15
  %or73 = or i64 %38, 2
  store i64 %or73, i64* %e_flags72, align 8, !tbaa !15
  %39 = load i32, i32* %requeueflag.addr, align 4, !tbaa !5
  call void @eatheader(%struct.envelope* %e, i32 %39, i32 1)
  %40 = load i32, i32* %requeueflag.addr, align 4, !tbaa !5
  %tobool74 = icmp ne i32 %40, 0
  br i1 %tobool74, label %if.then.75, label %if.end.76

if.then.75:                                       ; preds = %if.then.71
  call void @queueup(%struct.envelope* %e, i32 0, i32 0)
  br label %if.end.76

if.end.76:                                        ; preds = %if.then.75, %if.then.71
  call void @sendall(%struct.envelope* %e, i32 105)
  %call77 = call i32 @dropenvelope(%struct.envelope* %e, i32 1, i32 0)
  br label %if.end.91

if.else.78:                                       ; preds = %if.end.62
  %41 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 40), align 1, !tbaa !17
  %conv79 = zext i8 %41 to i32
  %cmp80 = icmp sge i32 %conv79, 4
  br i1 %cmp80, label %land.lhs.true.82, label %if.end.90

land.lhs.true.82:                                 ; preds = %if.else.78
  %42 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool83 = icmp ne i32 %42, 0
  br i1 %tobool83, label %if.end.90, label %land.lhs.true.84

land.lhs.true.84:                                 ; preds = %land.lhs.true.82
  %e_id85 = getelementptr inbounds %struct.envelope, %struct.envelope* %e, i32 0, i32 25
  %43 = load i8*, i8** %e_id85, align 8, !tbaa !7
  %cmp86 = icmp ne i8* %43, null
  br i1 %cmp86, label %if.then.88, label %if.end.90

if.then.88:                                       ; preds = %land.lhs.true.84
  %call89 = call i8* @qid_printname(%struct.envelope* %e)
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.87, i32 0, i32 0), i8* %call89)
  br label %if.end.90

if.end.90:                                        ; preds = %if.then.88, %land.lhs.true.84, %land.lhs.true.82, %if.else.78
  br label %if.end.91

if.end.91:                                        ; preds = %if.end.90, %if.end.76
  %44 = load %struct.SM_RPOOL_T*, %struct.SM_RPOOL_T** %rpool, align 8, !tbaa !1
  call void @sm_rpool_free(%struct.SM_RPOOL_T* %44)
  %45 = load %struct.envelope*, %struct.envelope** %ei, align 8, !tbaa !1
  %e_id92 = getelementptr inbounds %struct.envelope, %struct.envelope* %45, i32 0, i32 25
  store i8* null, i8** %e_id92, align 8, !tbaa !7
  store i32 0, i32* %cleanup.dest.slot
  br label %cleanup

cleanup:                                          ; preds = %if.end.91, %if.then.60, %if.then.53
  %46 = bitcast %struct.SM_RPOOL_T** %rpool to i8*
  call void @llvm.lifetime.end(i64 8, i8* %46) #1
  %47 = bitcast %struct.envelope* %e to i8*
  call void @llvm.lifetime.end(i64 2656, i8* %47) #1
  %cleanup.dest = load i32, i32* %cleanup.dest.slot
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %cleanup.cont
    i32 4, label %for.inc
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc

for.inc:                                          ; preds = %cleanup.cont, %cleanup
  %48 = load %struct.envelope*, %struct.envelope** %ei, align 8, !tbaa !1
  %e_sibling = getelementptr inbounds %struct.envelope, %struct.envelope* %48, i32 0, i32 22
  %49 = load %struct.envelope*, %struct.envelope** %e_sibling, align 8, !tbaa !148
  store %struct.envelope* %49, %struct.envelope** %ei, align 8, !tbaa !1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %50 = load %struct.envelope*, %struct.envelope** %el.addr, align 8, !tbaa !1
  store %struct.envelope* %50, %struct.envelope** @CurEnv, align 8, !tbaa !1
  %51 = load i32, i32* %forkflag.addr, align 4, !tbaa !5
  %tobool94 = icmp ne i32 %51, 0
  br i1 %tobool94, label %if.then.95, label %if.end.96

if.then.95:                                       ; preds = %for.end
  %52 = load i32, i32* @ExitStat, align 4, !tbaa !5
  call void @finis(i32 1, i32 1, i32 %52)
  br label %if.end.96

if.end.96:                                        ; preds = %if.then.95, %for.end
  store i32 0, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup.97

cleanup.97:                                       ; preds = %if.end.96, %if.then.31, %if.then.6
  %53 = bitcast %struct.envelope** %ei to i8*
  call void @llvm.lifetime.end(i64 8, i8* %53) #1
  %54 = bitcast i32* %pid to i8*
  call void @llvm.lifetime.end(i64 4, i8* %54) #1
  %55 = load i32, i32* %retval
  ret i32 %55

unreachable:                                      ; preds = %cleanup
  unreachable
}

declare void @openxscript(%struct.envelope*) #2

; Function Attrs: nounwind uwtable
define void @printnqe(%struct.sm_file* %out, i8* %prefix) #0 {
entry:
  %out.addr = alloca %struct.sm_file*, align 8
  %prefix.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %k = alloca i32, align 4
  %nrequests = alloca i32, align 4
  %unknown = alloca i32, align 4
  %cleanup.dest.slot = alloca i32
  %j = alloca i32, align 4
  %n = alloca i32, align 4
  store %struct.sm_file* %out, %struct.sm_file** %out.addr, align 8, !tbaa !1
  store i8* %prefix, i8** %prefix.addr, align 8, !tbaa !1
  %0 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start(i64 4, i8* %0) #1
  %1 = bitcast i32* %k to i8*
  call void @llvm.lifetime.start(i64 4, i8* %1) #1
  store i32 0, i32* %k, align 4, !tbaa !5
  %2 = bitcast i32* %nrequests to i8*
  call void @llvm.lifetime.start(i64 4, i8* %2) #1
  store i32 0, i32* %nrequests, align 4, !tbaa !5
  %3 = bitcast i32* %unknown to i8*
  call void @llvm.lifetime.start(i64 4, i8* %3) #1
  store i32 0, i32* %unknown, align 4, !tbaa !5
  %4 = load i32, i32* @ShmId, align 4, !tbaa !5
  %cmp = icmp eq i32 %4, -2
  br i1 %cmp, label %if.then, label %if.end.4

if.then:                                          ; preds = %entry
  %5 = load i8*, i8** %prefix.addr, align 8, !tbaa !1
  %cmp1 = icmp eq i8* %5, null
  br i1 %cmp1, label %if.then.2, label %if.else

if.then.2:                                        ; preds = %if.then
  %6 = load %struct.sm_file*, %struct.sm_file** %out.addr, align 8, !tbaa !1
  %call = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* %6, i32 -2, i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.91, i32 0, i32 0))
  br label %if.end

if.else:                                          ; preds = %if.then
  %7 = load %struct.sm_file*, %struct.sm_file** %out.addr, align 8, !tbaa !1
  %8 = load i8*, i8** %prefix.addr, align 8, !tbaa !1
  %call3 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* %7, i32 -2, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.92, i32 0, i32 0), i8* %8)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then.2
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.4:                                         ; preds = %entry
  store i32 0, i32* %i, align 4, !tbaa !5
  br label %for.cond

for.cond:                                         ; preds = %for.inc.45, %if.end.4
  %9 = load i32, i32* %i, align 4, !tbaa !5
  %10 = load i32, i32* @NumQueue, align 4, !tbaa !5
  %cmp5 = icmp slt i32 %9, %10
  br i1 %cmp5, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %11 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom = sext i32 %11 to i64
  %arrayidx = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom
  %12 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx, align 8, !tbaa !1
  %cmp6 = icmp ne %struct.queuegrp* %12, null
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %13 = phi i1 [ false, %for.cond ], [ %cmp6, %land.rhs ]
  br i1 %13, label %for.body, label %for.end.47

for.body:                                         ; preds = %land.end
  %14 = bitcast i32* %j to i8*
  call void @llvm.lifetime.start(i64 4, i8* %14) #1
  %15 = load i32, i32* %k, align 4, !tbaa !5
  %inc = add nsw i32 %15, 1
  store i32 %inc, i32* %k, align 4, !tbaa !5
  store i32 0, i32* %j, align 4, !tbaa !5
  br label %for.cond.7

for.cond.7:                                       ; preds = %for.inc, %for.body
  %16 = load i32, i32* %j, align 4, !tbaa !5
  %17 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom8 = sext i32 %17 to i64
  %arrayidx9 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom8
  %18 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx9, align 8, !tbaa !1
  %qg_numqueues = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %18, i32 0, i32 4
  %19 = load i32, i32* %qg_numqueues, align 4, !tbaa !82
  %cmp10 = icmp slt i32 %16, %19
  br i1 %cmp10, label %for.body.11, label %for.end

for.body.11:                                      ; preds = %for.cond.7
  %20 = bitcast i32* %n to i8*
  call void @llvm.lifetime.start(i64 4, i8* %20) #1
  %21 = load volatile i32, i32* @StopRequest, align 4, !tbaa !5
  %tobool = icmp ne i32 %21, 0
  br i1 %tobool, label %if.then.12, label %if.end.13

if.then.12:                                       ; preds = %for.body.11
  call void @stop_sendmail()
  br label %if.end.13

if.end.13:                                        ; preds = %if.then.12, %for.body.11
  %22 = load i32, i32* %j, align 4, !tbaa !5
  %idxprom14 = sext i32 %22 to i64
  %23 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom15 = sext i32 %23 to i64
  %arrayidx16 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom15
  %24 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx16, align 8, !tbaa !1
  %qg_qpaths = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %24, i32 0, i32 6
  %25 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths, align 8, !tbaa !38
  %arrayidx17 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %25, i64 %idxprom14
  %qp_idx = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %arrayidx17, i32 0, i32 3
  %26 = load i32, i32* %qp_idx, align 4, !tbaa !84
  %idxprom18 = sext i32 %26 to i64
  %27 = load %struct.queue_shared*, %struct.queue_shared** @QShm, align 8, !tbaa !1
  %arrayidx19 = getelementptr inbounds %struct.queue_shared, %struct.queue_shared* %27, i64 %idxprom18
  %qs_entries = getelementptr inbounds %struct.queue_shared, %struct.queue_shared* %arrayidx19, i32 0, i32 0
  %28 = load i32, i32* %qs_entries, align 4, !tbaa !85
  store i32 %28, i32* %n, align 4, !tbaa !5
  %29 = load i8*, i8** %prefix.addr, align 8, !tbaa !1
  %cmp20 = icmp ne i8* %29, null
  br i1 %cmp20, label %if.then.21, label %if.else.24

if.then.21:                                       ; preds = %if.end.13
  %30 = load %struct.sm_file*, %struct.sm_file** %out.addr, align 8, !tbaa !1
  %31 = load i8*, i8** %prefix.addr, align 8, !tbaa !1
  %32 = load i32, i32* %i, align 4, !tbaa !5
  %33 = load i32, i32* %j, align 4, !tbaa !5
  %call22 = call i8* @qid_printqueue(i32 %32, i32 %33)
  %34 = load i32, i32* %n, align 4, !tbaa !5
  %call23 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* %30, i32 -2, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.93, i32 0, i32 0), i8* %31, i8* %call22, i32 %34)
  br label %if.end.43

if.else.24:                                       ; preds = %if.end.13
  %35 = load i32, i32* %n, align 4, !tbaa !5
  %cmp25 = icmp slt i32 %35, 0
  br i1 %cmp25, label %if.then.26, label %if.else.29

if.then.26:                                       ; preds = %if.else.24
  %36 = load %struct.sm_file*, %struct.sm_file** %out.addr, align 8, !tbaa !1
  %37 = load i32, i32* %i, align 4, !tbaa !5
  %38 = load i32, i32* %j, align 4, !tbaa !5
  %call27 = call i8* @qid_printqueue(i32 %37, i32 %38)
  %call28 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* %36, i32 -2, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.94, i32 0, i32 0), i8* %call27)
  store i32 1, i32* %unknown, align 4, !tbaa !5
  br label %if.end.42

if.else.29:                                       ; preds = %if.else.24
  %39 = load i32, i32* %n, align 4, !tbaa !5
  %cmp30 = icmp eq i32 %39, 0
  br i1 %cmp30, label %if.then.31, label %if.else.34

if.then.31:                                       ; preds = %if.else.29
  %40 = load %struct.sm_file*, %struct.sm_file** %out.addr, align 8, !tbaa !1
  %41 = load i32, i32* %i, align 4, !tbaa !5
  %42 = load i32, i32* %j, align 4, !tbaa !5
  %call32 = call i8* @qid_printqueue(i32 %41, i32 %42)
  %call33 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* %40, i32 -2, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.95, i32 0, i32 0), i8* %call32)
  br label %if.end.41

if.else.34:                                       ; preds = %if.else.29
  %43 = load i32, i32* %n, align 4, !tbaa !5
  %cmp35 = icmp sgt i32 %43, 0
  br i1 %cmp35, label %if.then.36, label %if.end.40

if.then.36:                                       ; preds = %if.else.34
  %44 = load %struct.sm_file*, %struct.sm_file** %out.addr, align 8, !tbaa !1
  %45 = load i32, i32* %i, align 4, !tbaa !5
  %46 = load i32, i32* %j, align 4, !tbaa !5
  %call37 = call i8* @qid_printqueue(i32 %45, i32 %46)
  %47 = load i32, i32* %n, align 4, !tbaa !5
  %call38 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* %44, i32 -2, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.96, i32 0, i32 0), i8* %call37, i32 %47)
  %48 = load i32, i32* %n, align 4, !tbaa !5
  %49 = load i32, i32* %nrequests, align 4, !tbaa !5
  %add = add nsw i32 %49, %48
  store i32 %add, i32* %nrequests, align 4, !tbaa !5
  %50 = load i32, i32* %k, align 4, !tbaa !5
  %inc39 = add nsw i32 %50, 1
  store i32 %inc39, i32* %k, align 4, !tbaa !5
  br label %if.end.40

if.end.40:                                        ; preds = %if.then.36, %if.else.34
  br label %if.end.41

if.end.41:                                        ; preds = %if.end.40, %if.then.31
  br label %if.end.42

if.end.42:                                        ; preds = %if.end.41, %if.then.26
  br label %if.end.43

if.end.43:                                        ; preds = %if.end.42, %if.then.21
  %51 = bitcast i32* %n to i8*
  call void @llvm.lifetime.end(i64 4, i8* %51) #1
  br label %for.inc

for.inc:                                          ; preds = %if.end.43
  %52 = load i32, i32* %j, align 4, !tbaa !5
  %inc44 = add nsw i32 %52, 1
  store i32 %inc44, i32* %j, align 4, !tbaa !5
  br label %for.cond.7

for.end:                                          ; preds = %for.cond.7
  %53 = bitcast i32* %j to i8*
  call void @llvm.lifetime.end(i64 4, i8* %53) #1
  br label %for.inc.45

for.inc.45:                                       ; preds = %for.end
  %54 = load i32, i32* %i, align 4, !tbaa !5
  %inc46 = add nsw i32 %54, 1
  store i32 %inc46, i32* %i, align 4, !tbaa !5
  br label %for.cond

for.end.47:                                       ; preds = %land.end
  %55 = load i8*, i8** %prefix.addr, align 8, !tbaa !1
  %cmp48 = icmp eq i8* %55, null
  br i1 %cmp48, label %land.lhs.true, label %if.end.53

land.lhs.true:                                    ; preds = %for.end.47
  %56 = load i32, i32* %k, align 4, !tbaa !5
  %cmp49 = icmp sgt i32 %56, 1
  br i1 %cmp49, label %if.then.50, label %if.end.53

if.then.50:                                       ; preds = %land.lhs.true
  %57 = load %struct.sm_file*, %struct.sm_file** %out.addr, align 8, !tbaa !1
  %58 = load i32, i32* %nrequests, align 4, !tbaa !5
  %59 = load i32, i32* %unknown, align 4, !tbaa !5
  %tobool51 = icmp ne i32 %59, 0
  %cond = select i1 %tobool51, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.98, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0)
  %call52 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* %57, i32 -2, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.97, i32 0, i32 0), i32 %58, i8* %cond)
  br label %if.end.53

if.end.53:                                        ; preds = %if.then.50, %land.lhs.true, %for.end.47
  store i32 0, i32* %cleanup.dest.slot
  br label %cleanup

cleanup:                                          ; preds = %if.end.53, %if.end
  %60 = bitcast i32* %unknown to i8*
  call void @llvm.lifetime.end(i64 4, i8* %60) #1
  %61 = bitcast i32* %nrequests to i8*
  call void @llvm.lifetime.end(i64 4, i8* %61) #1
  %62 = bitcast i32* %k to i8*
  call void @llvm.lifetime.end(i64 4, i8* %62) #1
  %63 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end(i64 4, i8* %63) #1
  %cleanup.dest = load i32, i32* %cleanup.dest.slot
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %cleanup.cont
    i32 1, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup, %cleanup
  ret void

unreachable:                                      ; preds = %cleanup
  unreachable
}

declare void @stop_sendmail() #2

; Function Attrs: nounwind uwtable
define void @printqueue() #0 {
entry:
  %i = alloca i32, align 4
  %k = alloca i32, align 4
  %nrequests = alloca i32, align 4
  %j = alloca i32, align 4
  %0 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start(i64 4, i8* %0) #1
  %1 = bitcast i32* %k to i8*
  call void @llvm.lifetime.start(i64 4, i8* %1) #1
  store i32 0, i32* %k, align 4, !tbaa !5
  %2 = bitcast i32* %nrequests to i8*
  call void @llvm.lifetime.start(i64 4, i8* %2) #1
  store i32 0, i32* %nrequests, align 4, !tbaa !5
  store i32 0, i32* %i, align 4, !tbaa !5
  br label %for.cond

for.cond:                                         ; preds = %for.inc.9, %entry
  %3 = load i32, i32* %i, align 4, !tbaa !5
  %4 = load i32, i32* @NumQueue, align 4, !tbaa !5
  %cmp = icmp slt i32 %3, %4
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %5 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom
  %6 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx, align 8, !tbaa !1
  %cmp1 = icmp ne %struct.queuegrp* %6, null
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %7 = phi i1 [ false, %for.cond ], [ %cmp1, %land.rhs ]
  br i1 %7, label %for.body, label %for.end.11

for.body:                                         ; preds = %land.end
  %8 = bitcast i32* %j to i8*
  call void @llvm.lifetime.start(i64 4, i8* %8) #1
  %9 = load i32, i32* %k, align 4, !tbaa !5
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %k, align 4, !tbaa !5
  store i32 0, i32* %j, align 4, !tbaa !5
  br label %for.cond.2

for.cond.2:                                       ; preds = %for.inc, %for.body
  %10 = load i32, i32* %j, align 4, !tbaa !5
  %11 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom3 = sext i32 %11 to i64
  %arrayidx4 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom3
  %12 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx4, align 8, !tbaa !1
  %qg_numqueues = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %12, i32 0, i32 4
  %13 = load i32, i32* %qg_numqueues, align 4, !tbaa !82
  %cmp5 = icmp slt i32 %10, %13
  br i1 %cmp5, label %for.body.6, label %for.end

for.body.6:                                       ; preds = %for.cond.2
  %14 = load volatile i32, i32* @StopRequest, align 4, !tbaa !5
  %tobool = icmp ne i32 %14, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body.6
  call void @stop_sendmail()
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body.6
  %15 = load i32, i32* %i, align 4, !tbaa !5
  %16 = load i32, i32* %j, align 4, !tbaa !5
  %call = call i32 @print_single_queue(i32 %15, i32 %16)
  %17 = load i32, i32* %nrequests, align 4, !tbaa !5
  %add = add nsw i32 %17, %call
  store i32 %add, i32* %nrequests, align 4, !tbaa !5
  %18 = load i32, i32* %k, align 4, !tbaa !5
  %inc7 = add nsw i32 %18, 1
  store i32 %inc7, i32* %k, align 4, !tbaa !5
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %19 = load i32, i32* %j, align 4, !tbaa !5
  %inc8 = add nsw i32 %19, 1
  store i32 %inc8, i32* %j, align 4, !tbaa !5
  br label %for.cond.2

for.end:                                          ; preds = %for.cond.2
  %20 = bitcast i32* %j to i8*
  call void @llvm.lifetime.end(i64 4, i8* %20) #1
  br label %for.inc.9

for.inc.9:                                        ; preds = %for.end
  %21 = load i32, i32* %i, align 4, !tbaa !5
  %inc10 = add nsw i32 %21, 1
  store i32 %inc10, i32* %i, align 4, !tbaa !5
  br label %for.cond

for.end.11:                                       ; preds = %land.end
  %22 = load i32, i32* %k, align 4, !tbaa !5
  %cmp12 = icmp sgt i32 %22, 1
  br i1 %cmp12, label %if.then.13, label %if.end.15

if.then.13:                                       ; preds = %for.end.11
  %23 = load i32, i32* %nrequests, align 4, !tbaa !5
  %call14 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.99, i32 0, i32 0), i32 %23)
  br label %if.end.15

if.end.15:                                        ; preds = %if.then.13, %for.end.11
  %24 = bitcast i32* %nrequests to i8*
  call void @llvm.lifetime.end(i64 4, i8* %24) #1
  %25 = bitcast i32* %k to i8*
  call void @llvm.lifetime.end(i64 4, i8* %25) #1
  %26 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end(i64 4, i8* %26) #1
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @print_single_queue(i32 %qgrp, i32 %qdir) #0 {
entry:
  %retval = alloca i32, align 4
  %qgrp.addr = alloca i32, align 4
  %qdir.addr = alloca i32, align 4
  %w = alloca %struct.work*, align 8
  %f = alloca %struct.sm_file*, align 8
  %nrequests = alloca i32, align 4
  %qd = alloca [4096 x i8], align 16
  %qddf = alloca [4096 x i8], align 16
  %buf = alloca [2048 x i8], align 16
  %st = alloca %struct.stat, align 8
  %n = alloca i32, align 4
  %cleanup.dest.slot = alloca i32
  %st100 = alloca %struct.stat, align 8
  %submittime = alloca i64, align 8
  %dfsize = alloca i64, align 8
  %flags = alloca i32, align 4
  %qfver = alloca i32, align 4
  %quarmsg = alloca [2048 x i8], align 16
  %statmsg = alloca [2048 x i8], align 16
  %bodytype = alloca [257 x i8], align 16
  %qf = alloca [4096 x i8], align 16
  %e = alloca %struct.envelope, align 8
  %df = alloca i8*, align 8
  %i = alloca i32, align 4
  %p = alloca i8*, align 8
  store i32 %qgrp, i32* %qgrp.addr, align 4, !tbaa !5
  store i32 %qdir, i32* %qdir.addr, align 4, !tbaa !5
  %0 = bitcast %struct.work** %w to i8*
  call void @llvm.lifetime.start(i64 8, i8* %0) #1
  %1 = bitcast %struct.sm_file** %f to i8*
  call void @llvm.lifetime.start(i64 8, i8* %1) #1
  %2 = bitcast i32* %nrequests to i8*
  call void @llvm.lifetime.start(i64 4, i8* %2) #1
  %3 = bitcast [4096 x i8]* %qd to i8*
  call void @llvm.lifetime.start(i64 4096, i8* %3) #1
  %4 = bitcast [4096 x i8]* %qddf to i8*
  call void @llvm.lifetime.start(i64 4096, i8* %4) #1
  %5 = bitcast [2048 x i8]* %buf to i8*
  call void @llvm.lifetime.start(i64 2048, i8* %5) #1
  %6 = load i32, i32* %qdir.addr, align 4, !tbaa !5
  %cmp = icmp eq i32 %6, -1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %arraydecay = getelementptr inbounds [4096 x i8], [4096 x i8]* %qd, i32 0, i32 0
  %call = call i64 @sm_strlcpy(i8* %arraydecay, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.100, i32 0, i32 0), i64 4096)
  %arraydecay1 = getelementptr inbounds [4096 x i8], [4096 x i8]* %qddf, i32 0, i32 0
  %call2 = call i64 @sm_strlcpy(i8* %arraydecay1, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.100, i32 0, i32 0), i64 4096)
  br label %if.end

if.else:                                          ; preds = %entry
  %arraydecay3 = getelementptr inbounds [4096 x i8], [4096 x i8]* %qd, i32 0, i32 0
  %7 = load i32, i32* %qdir.addr, align 4, !tbaa !5
  %idxprom = sext i32 %7 to i64
  %8 = load i32, i32* %qgrp.addr, align 4, !tbaa !5
  %idxprom4 = sext i32 %8 to i64
  %arrayidx = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom4
  %9 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx, align 8, !tbaa !1
  %qg_qpaths = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %9, i32 0, i32 6
  %10 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths, align 8, !tbaa !38
  %arrayidx5 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %10, i64 %idxprom
  %qp_name = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %arrayidx5, i32 0, i32 0
  %11 = load i8*, i8** %qp_name, align 8, !tbaa !40
  %12 = load i32, i32* %qdir.addr, align 4, !tbaa !5
  %idxprom6 = sext i32 %12 to i64
  %13 = load i32, i32* %qgrp.addr, align 4, !tbaa !5
  %idxprom7 = sext i32 %13 to i64
  %arrayidx8 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom7
  %14 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx8, align 8, !tbaa !1
  %qg_qpaths9 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %14, i32 0, i32 6
  %15 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths9, align 8, !tbaa !38
  %arrayidx10 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %15, i64 %idxprom6
  %qp_subdirs = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %arrayidx10, i32 0, i32 1
  %16 = load i16, i16* %qp_subdirs, align 2, !tbaa !83
  %conv = sext i16 %16 to i32
  %and = and i32 %conv, 2
  %cmp11 = icmp ne i32 %and, 0
  %cond = select i1 %cmp11, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.101, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0)
  %call13 = call i64 (i8*, i64, i32, ...) @sm_strlcpyn(i8* %arraydecay3, i64 4096, i32 2, i8* %11, i8* %cond)
  %arraydecay14 = getelementptr inbounds [4096 x i8], [4096 x i8]* %qddf, i32 0, i32 0
  %17 = load i32, i32* %qdir.addr, align 4, !tbaa !5
  %idxprom15 = sext i32 %17 to i64
  %18 = load i32, i32* %qgrp.addr, align 4, !tbaa !5
  %idxprom16 = sext i32 %18 to i64
  %arrayidx17 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom16
  %19 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx17, align 8, !tbaa !1
  %qg_qpaths18 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %19, i32 0, i32 6
  %20 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths18, align 8, !tbaa !38
  %arrayidx19 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %20, i64 %idxprom15
  %qp_name20 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %arrayidx19, i32 0, i32 0
  %21 = load i8*, i8** %qp_name20, align 8, !tbaa !40
  %22 = load i32, i32* %qdir.addr, align 4, !tbaa !5
  %idxprom21 = sext i32 %22 to i64
  %23 = load i32, i32* %qgrp.addr, align 4, !tbaa !5
  %idxprom22 = sext i32 %23 to i64
  %arrayidx23 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom22
  %24 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx23, align 8, !tbaa !1
  %qg_qpaths24 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %24, i32 0, i32 6
  %25 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths24, align 8, !tbaa !38
  %arrayidx25 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %25, i64 %idxprom21
  %qp_subdirs26 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %arrayidx25, i32 0, i32 1
  %26 = load i16, i16* %qp_subdirs26, align 2, !tbaa !83
  %conv27 = sext i16 %26 to i32
  %and28 = and i32 %conv27, 1
  %cmp29 = icmp ne i32 %and28, 0
  %cond31 = select i1 %cmp29, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.102, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0)
  %call32 = call i64 (i8*, i64, i32, ...) @sm_strlcpyn(i8* %arraydecay14, i64 4096, i32 2, i8* %21, i8* %cond31)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %27 = load i64, i64* @PrivacyFlags, align 8, !tbaa !92
  %and33 = and i64 %27, 65536
  %cmp34 = icmp ne i64 %and33, 0
  br i1 %cmp34, label %land.lhs.true, label %if.end.69

land.lhs.true:                                    ; preds = %if.end
  %28 = load i32, i32* @RealUid, align 4, !tbaa !5
  %cmp36 = icmp ne i32 %28, 0
  br i1 %cmp36, label %if.then.38, label %if.end.69

if.then.38:                                       ; preds = %land.lhs.true
  %29 = bitcast %struct.stat* %st to i8*
  call void @llvm.lifetime.start(i64 144, i8* %29) #1
  %30 = bitcast i32* %n to i8*
  call void @llvm.lifetime.start(i64 4, i8* %30) #1
  %arraydecay39 = getelementptr inbounds [4096 x i8], [4096 x i8]* %qd, i32 0, i32 0
  %call40 = call i32 @stat(i8* %arraydecay39, %struct.stat* %st) #1
  %cmp41 = icmp slt i32 %call40, 0
  br i1 %cmp41, label %if.then.43, label %if.end.45

if.then.43:                                       ; preds = %if.then.38
  %31 = load i32, i32* %qgrp.addr, align 4, !tbaa !5
  %32 = load i32, i32* %qdir.addr, align 4, !tbaa !5
  %call44 = call i8* @qid_printqueue(i32 %31, i32 %32)
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.103, i32 0, i32 0), i8* %call44)
  store i32 0, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.45:                                        ; preds = %if.then.38
  store i32 65536, i32* %n, align 4, !tbaa !5
  br label %while.cond

while.cond:                                       ; preds = %if.end.53, %if.end.45
  %33 = load i32, i32* %n, align 4, !tbaa !5
  %dec = add nsw i32 %33, -1
  store i32 %dec, i32* %n, align 4, !tbaa !5
  %cmp46 = icmp sge i32 %dec, 0
  br i1 %cmp46, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %34 = load i32, i32* %n, align 4, !tbaa !5
  %idxprom48 = sext i32 %34 to i64
  %arrayidx49 = getelementptr inbounds [65536 x i32], [65536 x i32]* @InitialGidSet, i32 0, i64 %idxprom48
  %35 = load i32, i32* %arrayidx49, align 4, !tbaa !5
  %st_gid = getelementptr inbounds %struct.stat, %struct.stat* %st, i32 0, i32 5
  %36 = load i32, i32* %st_gid, align 4, !tbaa !140
  %cmp50 = icmp eq i32 %35, %36
  br i1 %cmp50, label %if.then.52, label %if.end.53

if.then.52:                                       ; preds = %while.body
  br label %while.end

if.end.53:                                        ; preds = %while.body
  br label %while.cond

while.end:                                        ; preds = %if.then.52, %while.cond
  %37 = load i32, i32* %n, align 4, !tbaa !5
  %cmp54 = icmp slt i32 %37, 0
  br i1 %cmp54, label %land.lhs.true.56, label %if.end.67

land.lhs.true.56:                                 ; preds = %while.end
  %38 = load i32, i32* @RealGid, align 4, !tbaa !5
  %st_gid57 = getelementptr inbounds %struct.stat, %struct.stat* %st, i32 0, i32 5
  %39 = load i32, i32* %st_gid57, align 4, !tbaa !140
  %cmp58 = icmp ne i32 %38, %39
  br i1 %cmp58, label %if.then.60, label %if.end.67

if.then.60:                                       ; preds = %land.lhs.true.56
  call void (i8*, ...) @usrerr(i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.104, i32 0, i32 0))
  br label %do.body

do.body:                                          ; preds = %if.then.60
  %40 = load i32, i32* @ExitStat, align 4, !tbaa !5
  %cmp61 = icmp eq i32 %40, 0
  br i1 %cmp61, label %if.then.65, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.body
  %41 = load i32, i32* @ExitStat, align 4, !tbaa !5
  %cmp63 = icmp eq i32 %41, 75
  br i1 %cmp63, label %if.then.65, label %if.end.66

if.then.65:                                       ; preds = %lor.lhs.false, %do.body
  store i32 77, i32* @ExitStat, align 4, !tbaa !5
  br label %if.end.66

if.end.66:                                        ; preds = %if.then.65, %lor.lhs.false
  br label %do.cond

do.cond:                                          ; preds = %if.end.66
  br label %do.end

do.end:                                           ; preds = %do.cond
  store i32 0, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.67:                                        ; preds = %land.lhs.true.56, %while.end
  store i32 0, i32* %cleanup.dest.slot
  br label %cleanup

cleanup:                                          ; preds = %if.end.67, %do.end, %if.then.43
  %42 = bitcast i32* %n to i8*
  call void @llvm.lifetime.end(i64 4, i8* %42) #1
  %43 = bitcast %struct.stat* %st to i8*
  call void @llvm.lifetime.end(i64 144, i8* %43) #1
  %cleanup.dest = load i32, i32* %cleanup.dest.slot
  switch i32 %cleanup.dest, label %cleanup.373 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %if.end.69

if.end.69:                                        ; preds = %cleanup.cont, %land.lhs.true, %if.end
  %44 = load i32, i32* %qgrp.addr, align 4, !tbaa !5
  %45 = load i32, i32* %qdir.addr, align 4, !tbaa !5
  %call70 = call i32 @gatherq(i32 %44, i32 %45, i32 1, i32* null, i32* null, i32* null)
  store i32 %call70, i32* %nrequests, align 4, !tbaa !5
  %46 = load i32, i32* %qgrp.addr, align 4, !tbaa !5
  %idxprom71 = sext i32 %46 to i64
  %arrayidx72 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom71
  %47 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx72, align 8, !tbaa !1
  %qg_maxlist = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %47, i32 0, i32 10
  %48 = load i32, i32* %qg_maxlist, align 4, !tbaa !116
  %call73 = call i32 @sortq(i32 %48)
  %49 = load i32, i32* %nrequests, align 4, !tbaa !5
  %cmp74 = icmp sle i32 %49, 0
  br i1 %cmp74, label %if.then.76, label %if.end.79

if.then.76:                                       ; preds = %if.end.69
  %50 = load i32, i32* %qgrp.addr, align 4, !tbaa !5
  %51 = load i32, i32* %qdir.addr, align 4, !tbaa !5
  %call77 = call i8* @qid_printqueue(i32 %50, i32 %51)
  %call78 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.95, i32 0, i32 0), i8* %call77)
  store i32 0, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup.373

if.end.79:                                        ; preds = %if.end.69
  call void @sm_getla()
  %52 = load i32, i32* %qgrp.addr, align 4, !tbaa !5
  %53 = load i32, i32* %qdir.addr, align 4, !tbaa !5
  %call80 = call i8* @qid_printqueue(i32 %52, i32 %53)
  %54 = load i32, i32* %nrequests, align 4, !tbaa !5
  %55 = load i32, i32* %nrequests, align 4, !tbaa !5
  %cmp81 = icmp eq i32 %55, 1
  %cond83 = select i1 %cmp81, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0), i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.106, i32 0, i32 0)
  %call84 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.105, i32 0, i32 0), i8* %call80, i32 %54, i8* %cond83)
  %56 = load i32, i32* @MaxQueueRun, align 4, !tbaa !5
  %cmp85 = icmp sgt i32 %56, 0
  br i1 %cmp85, label %land.lhs.true.87, label %if.end.92

land.lhs.true.87:                                 ; preds = %if.end.79
  %57 = load i32, i32* %nrequests, align 4, !tbaa !5
  %58 = load i32, i32* @MaxQueueRun, align 4, !tbaa !5
  %cmp88 = icmp sgt i32 %57, %58
  br i1 %cmp88, label %if.then.90, label %if.end.92

if.then.90:                                       ; preds = %land.lhs.true.87
  %59 = load i32, i32* @MaxQueueRun, align 4, !tbaa !5
  %call91 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.107, i32 0, i32 0), i32 %59)
  br label %if.end.92

if.end.92:                                        ; preds = %if.then.90, %land.lhs.true.87, %if.end.79
  %60 = load i32, i32* @Verbose, align 4, !tbaa !5
  %tobool = icmp ne i32 %60, 0
  br i1 %tobool, label %if.then.93, label %if.else.95

if.then.93:                                       ; preds = %if.end.92
  %call94 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([84 x i8], [84 x i8]* @.str.108, i32 0, i32 0))
  br label %if.end.97

if.else.95:                                       ; preds = %if.end.92
  %call96 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([84 x i8], [84 x i8]* @.str.109, i32 0, i32 0))
  br label %if.end.97

if.end.97:                                        ; preds = %if.else.95, %if.then.93
  %61 = load %struct.work*, %struct.work** @WorkQ, align 8, !tbaa !1
  store %struct.work* %61, %struct.work** %w, align 8, !tbaa !1
  br label %for.cond

for.cond:                                         ; preds = %for.inc.371, %if.end.97
  %62 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %cmp98 = icmp ne %struct.work* %62, null
  br i1 %cmp98, label %for.body, label %for.end.372

for.body:                                         ; preds = %for.cond
  %63 = bitcast %struct.stat* %st100 to i8*
  call void @llvm.lifetime.start(i64 144, i8* %63) #1
  %64 = bitcast i64* %submittime to i8*
  call void @llvm.lifetime.start(i64 8, i8* %64) #1
  store i64 0, i64* %submittime, align 8, !tbaa !92
  %65 = bitcast i64* %dfsize to i8*
  call void @llvm.lifetime.start(i64 8, i8* %65) #1
  %66 = bitcast i32* %flags to i8*
  call void @llvm.lifetime.start(i64 4, i8* %66) #1
  store i32 0, i32* %flags, align 4, !tbaa !5
  %67 = bitcast i32* %qfver to i8*
  call void @llvm.lifetime.start(i64 4, i8* %67) #1
  %68 = bitcast [2048 x i8]* %quarmsg to i8*
  call void @llvm.lifetime.start(i64 2048, i8* %68) #1
  %69 = bitcast [2048 x i8]* %statmsg to i8*
  call void @llvm.lifetime.start(i64 2048, i8* %69) #1
  %70 = bitcast [257 x i8]* %bodytype to i8*
  call void @llvm.lifetime.start(i64 257, i8* %70) #1
  %71 = bitcast [4096 x i8]* %qf to i8*
  call void @llvm.lifetime.start(i64 4096, i8* %71) #1
  %72 = load volatile i32, i32* @StopRequest, align 4, !tbaa !5
  %tobool101 = icmp ne i32 %72, 0
  br i1 %tobool101, label %if.then.102, label %if.end.103

if.then.102:                                      ; preds = %for.body
  call void @stop_sendmail()
  br label %if.end.103

if.end.103:                                       ; preds = %if.then.102, %for.body
  %73 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_name = getelementptr inbounds %struct.work, %struct.work* %73, i32 0, i32 0
  %74 = load i8*, i8** %w_name, align 8, !tbaa !129
  %add.ptr = getelementptr inbounds i8, i8* %74, i64 2
  %call104 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.110, i32 0, i32 0), i8* %add.ptr)
  %arraydecay105 = getelementptr inbounds [4096 x i8], [4096 x i8]* %qf, i32 0, i32 0
  %arraydecay106 = getelementptr inbounds [4096 x i8], [4096 x i8]* %qd, i32 0, i32 0
  %75 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_name107 = getelementptr inbounds %struct.work, %struct.work* %75, i32 0, i32 0
  %76 = load i8*, i8** %w_name107, align 8, !tbaa !129
  %call108 = call i64 (i8*, i64, i32, ...) @sm_strlcpyn(i8* %arraydecay105, i64 4096, i32 3, i8* %arraydecay106, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.111, i32 0, i32 0), i8* %76)
  %arraydecay109 = getelementptr inbounds [4096 x i8], [4096 x i8]* %qf, i32 0, i32 0
  %call110 = call %struct.sm_file* @sm_io_open(%struct.sm_file* @SmFtStdio_def, i32 -2, i8* %arraydecay109, i32 2, i8* null)
  store %struct.sm_file* %call110, %struct.sm_file** %f, align 8, !tbaa !1
  %77 = load %struct.sm_file*, %struct.sm_file** %f, align 8, !tbaa !1
  %cmp111 = icmp eq %struct.sm_file* %77, null
  br i1 %cmp111, label %if.then.113, label %if.end.132

if.then.113:                                      ; preds = %if.end.103
  %call114 = call i32* @__errno_location() #11
  %78 = load i32, i32* %call114, align 4, !tbaa !5
  %cmp115 = icmp eq i32 %78, 1
  br i1 %cmp115, label %if.then.117, label %if.else.119

if.then.117:                                      ; preds = %if.then.113
  %call118 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.112, i32 0, i32 0))
  br label %if.end.130

if.else.119:                                      ; preds = %if.then.113
  %call120 = call i32* @__errno_location() #11
  %79 = load i32, i32* %call120, align 4, !tbaa !5
  %cmp121 = icmp eq i32 %79, 2
  br i1 %cmp121, label %if.then.123, label %if.else.125

if.then.123:                                      ; preds = %if.else.119
  %call124 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.113, i32 0, i32 0))
  br label %if.end.129

if.else.125:                                      ; preds = %if.else.119
  %call126 = call i32* @__errno_location() #11
  %80 = load i32, i32* %call126, align 4, !tbaa !5
  %call127 = call i8* @sm_errstring(i32 %80)
  %call128 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.114, i32 0, i32 0), i8* %call127)
  br label %if.end.129

if.end.129:                                       ; preds = %if.else.125, %if.then.123
  br label %if.end.130

if.end.130:                                       ; preds = %if.end.129, %if.then.117
  %call131 = call i32* @__errno_location() #11
  store i32 0, i32* %call131, align 4, !tbaa !5
  store i32 8, i32* %cleanup.dest.slot
  br label %cleanup.360

if.end.132:                                       ; preds = %if.end.103
  %81 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_name133 = getelementptr inbounds %struct.work, %struct.work* %81, i32 0, i32 0
  %82 = load i8*, i8** %w_name133, align 8, !tbaa !129
  %arrayidx134 = getelementptr inbounds i8, i8* %82, i64 0
  store i8 100, i8* %arrayidx134, align 1, !tbaa !17
  %arraydecay135 = getelementptr inbounds [4096 x i8], [4096 x i8]* %qf, i32 0, i32 0
  %arraydecay136 = getelementptr inbounds [4096 x i8], [4096 x i8]* %qddf, i32 0, i32 0
  %83 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_name137 = getelementptr inbounds %struct.work, %struct.work* %83, i32 0, i32 0
  %84 = load i8*, i8** %w_name137, align 8, !tbaa !129
  %call138 = call i64 (i8*, i64, i32, ...) @sm_strlcpyn(i8* %arraydecay135, i64 4096, i32 3, i8* %arraydecay136, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.111, i32 0, i32 0), i8* %84)
  %arraydecay139 = getelementptr inbounds [4096 x i8], [4096 x i8]* %qf, i32 0, i32 0
  %call140 = call i32 @stat(i8* %arraydecay139, %struct.stat* %st100) #1
  %cmp141 = icmp sge i32 %call140, 0
  br i1 %cmp141, label %if.then.143, label %if.else.144

if.then.143:                                      ; preds = %if.end.132
  %st_size = getelementptr inbounds %struct.stat, %struct.stat* %st100, i32 0, i32 8
  %85 = load i64, i64* %st_size, align 8, !tbaa !141
  store i64 %85, i64* %dfsize, align 8, !tbaa !92
  br label %if.end.168

if.else.144:                                      ; preds = %if.end.132
  %86 = bitcast %struct.envelope* %e to i8*
  call void @llvm.lifetime.start(i64 2656, i8* %86) #1
  %call145 = call %struct.SM_RPOOL_T* @sm_rpool_new_x(%struct.SM_RPOOL_T* null)
  %call146 = call %struct.envelope* @newenvelope(%struct.envelope* %e, %struct.envelope* @BlankEnvelope, %struct.SM_RPOOL_T* %call145)
  %87 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_name147 = getelementptr inbounds %struct.work, %struct.work* %87, i32 0, i32 0
  %88 = load i8*, i8** %w_name147, align 8, !tbaa !129
  %add.ptr148 = getelementptr inbounds i8, i8* %88, i64 2
  %e_id = getelementptr inbounds %struct.envelope, %struct.envelope* %e, i32 0, i32 25
  store i8* %add.ptr148, i8** %e_id, align 8, !tbaa !7
  %89 = load i32, i32* %qgrp.addr, align 4, !tbaa !5
  %e_qgrp = getelementptr inbounds %struct.envelope, %struct.envelope* %e, i32 0, i32 26
  store i32 %89, i32* %e_qgrp, align 4, !tbaa !18
  %90 = load i32, i32* %qdir.addr, align 4, !tbaa !5
  %e_qdir = getelementptr inbounds %struct.envelope, %struct.envelope* %e, i32 0, i32 27
  store i32 %90, i32* %e_qdir, align 4, !tbaa !19
  store i64 -1, i64* %dfsize, align 8, !tbaa !92
  %call149 = call i32 @readqf(%struct.envelope* %e, i32 0)
  %tobool150 = icmp ne i32 %call149, 0
  br i1 %tobool150, label %if.then.151, label %if.end.159

if.then.151:                                      ; preds = %if.else.144
  %91 = bitcast i8** %df to i8*
  call void @llvm.lifetime.start(i64 8, i8* %91) #1
  %call152 = call i8* @queuename(%struct.envelope* %e, i32 100)
  store i8* %call152, i8** %df, align 8, !tbaa !1
  %92 = load i8*, i8** %df, align 8, !tbaa !1
  %call153 = call i32 @stat(i8* %92, %struct.stat* %st100) #1
  %cmp154 = icmp sge i32 %call153, 0
  br i1 %cmp154, label %if.then.156, label %if.end.158

if.then.156:                                      ; preds = %if.then.151
  %st_size157 = getelementptr inbounds %struct.stat, %struct.stat* %st100, i32 0, i32 8
  %93 = load i64, i64* %st_size157, align 8, !tbaa !141
  store i64 %93, i64* %dfsize, align 8, !tbaa !92
  br label %if.end.158

if.end.158:                                       ; preds = %if.then.156, %if.then.151
  %94 = bitcast i8** %df to i8*
  call void @llvm.lifetime.end(i64 8, i8* %94) #1
  br label %if.end.159

if.end.159:                                       ; preds = %if.end.158, %if.else.144
  %e_lockfp = getelementptr inbounds %struct.envelope, %struct.envelope* %e, i32 0, i32 33
  %95 = load %struct.sm_file*, %struct.sm_file** %e_lockfp, align 8, !tbaa !16
  %cmp160 = icmp ne %struct.sm_file* %95, null
  br i1 %cmp160, label %if.then.162, label %if.end.166

if.then.162:                                      ; preds = %if.end.159
  %e_lockfp163 = getelementptr inbounds %struct.envelope, %struct.envelope* %e, i32 0, i32 33
  %96 = load %struct.sm_file*, %struct.sm_file** %e_lockfp163, align 8, !tbaa !16
  %call164 = call i32 @sm_io_close(%struct.sm_file* %96, i32 -2)
  %e_lockfp165 = getelementptr inbounds %struct.envelope, %struct.envelope* %e, i32 0, i32 33
  store %struct.sm_file* null, %struct.sm_file** %e_lockfp165, align 8, !tbaa !16
  br label %if.end.166

if.end.166:                                       ; preds = %if.then.162, %if.end.159
  %e_rpool = getelementptr inbounds %struct.envelope, %struct.envelope* %e, i32 0, i32 52
  %97 = load %struct.SM_RPOOL_T*, %struct.SM_RPOOL_T** %e_rpool, align 8, !tbaa !120
  call void @clearenvelope(%struct.envelope* %e, i32 0, %struct.SM_RPOOL_T* %97)
  %e_rpool167 = getelementptr inbounds %struct.envelope, %struct.envelope* %e, i32 0, i32 52
  %98 = load %struct.SM_RPOOL_T*, %struct.SM_RPOOL_T** %e_rpool167, align 8, !tbaa !120
  call void @sm_rpool_free(%struct.SM_RPOOL_T* %98)
  %99 = bitcast %struct.envelope* %e to i8*
  call void @llvm.lifetime.end(i64 2656, i8* %99) #1
  br label %if.end.168

if.end.168:                                       ; preds = %if.end.166, %if.then.143
  %100 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_lock = getelementptr inbounds %struct.work, %struct.work* %100, i32 0, i32 2
  %101 = load i32, i32* %w_lock, align 4, !tbaa !132
  %tobool169 = icmp ne i32 %101, 0
  br i1 %tobool169, label %if.then.170, label %if.else.172

if.then.170:                                      ; preds = %if.end.168
  %call171 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.115, i32 0, i32 0))
  br label %if.end.191

if.else.172:                                      ; preds = %if.end.168
  %102 = load i32, i32* @QueueMode, align 4, !tbaa !5
  %cmp173 = icmp eq i32 %102, 76
  br i1 %cmp173, label %if.then.175, label %if.else.177

if.then.175:                                      ; preds = %if.else.172
  %call176 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.116, i32 0, i32 0))
  br label %if.end.190

if.else.177:                                      ; preds = %if.else.172
  %103 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_tooyoung = getelementptr inbounds %struct.work, %struct.work* %103, i32 0, i32 3
  %104 = load i32, i32* %w_tooyoung, align 4, !tbaa !131
  %tobool178 = icmp ne i32 %104, 0
  br i1 %tobool178, label %if.then.179, label %if.else.181

if.then.179:                                      ; preds = %if.else.177
  %call180 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.117, i32 0, i32 0))
  br label %if.end.189

if.else.181:                                      ; preds = %if.else.177
  %105 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_pri = getelementptr inbounds %struct.work, %struct.work* %105, i32 0, i32 4
  %106 = load i64, i64* %w_pri, align 8, !tbaa !133
  %107 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_ctime = getelementptr inbounds %struct.work, %struct.work* %107, i32 0, i32 5
  %108 = load i64, i64* %w_ctime, align 8, !tbaa !134
  %call182 = call i32 @shouldqueue(i64 %106, i64 %108)
  %tobool183 = icmp ne i32 %call182, 0
  br i1 %tobool183, label %if.then.184, label %if.else.186

if.then.184:                                      ; preds = %if.else.181
  %call185 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.118, i32 0, i32 0))
  br label %if.end.188

if.else.186:                                      ; preds = %if.else.181
  %call187 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.119, i32 0, i32 0))
  br label %if.end.188

if.end.188:                                       ; preds = %if.else.186, %if.then.184
  br label %if.end.189

if.end.189:                                       ; preds = %if.end.188, %if.then.179
  br label %if.end.190

if.end.190:                                       ; preds = %if.end.189, %if.then.175
  br label %if.end.191

if.end.191:                                       ; preds = %if.end.190, %if.then.170
  %call192 = call i32* @__errno_location() #11
  store i32 0, i32* %call192, align 4, !tbaa !5
  %arrayidx193 = getelementptr inbounds [2048 x i8], [2048 x i8]* %quarmsg, i32 0, i64 0
  store i8 0, i8* %arrayidx193, align 1, !tbaa !17
  %arrayidx194 = getelementptr inbounds [257 x i8], [257 x i8]* %bodytype, i32 0, i64 0
  store i8 0, i8* %arrayidx194, align 1, !tbaa !17
  %arrayidx195 = getelementptr inbounds [2048 x i8], [2048 x i8]* %statmsg, i32 0, i64 0
  store i8 0, i8* %arrayidx195, align 1, !tbaa !17
  store i32 0, i32* %qfver, align 4, !tbaa !5
  br label %while.cond.196

while.cond.196:                                   ; preds = %sw.epilog.351, %if.end.191
  %109 = load %struct.sm_file*, %struct.sm_file** %f, align 8, !tbaa !1
  %arraydecay197 = getelementptr inbounds [2048 x i8], [2048 x i8]* %buf, i32 0, i32 0
  %call198 = call i32 @sm_io_fgets(%struct.sm_file* %109, i32 -2, i8* %arraydecay197, i32 2048)
  %cmp199 = icmp sge i32 %call198, 0
  br i1 %cmp199, label %while.body.201, label %while.end.352

while.body.201:                                   ; preds = %while.cond.196
  %110 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start(i64 4, i8* %110) #1
  %111 = bitcast i8** %p to i8*
  call void @llvm.lifetime.start(i64 8, i8* %111) #1
  %112 = load volatile i32, i32* @StopRequest, align 4, !tbaa !5
  %tobool202 = icmp ne i32 %112, 0
  br i1 %tobool202, label %if.then.203, label %if.end.204

if.then.203:                                      ; preds = %while.body.201
  call void @stop_sendmail()
  br label %if.end.204

if.end.204:                                       ; preds = %if.then.203, %while.body.201
  %arraydecay205 = getelementptr inbounds [2048 x i8], [2048 x i8]* %buf, i32 0, i32 0
  call void @fixcrlf(i8* %arraydecay205, i32 1)
  %arrayidx206 = getelementptr inbounds [2048 x i8], [2048 x i8]* %buf, i32 0, i64 0
  %113 = load i8, i8* %arrayidx206, align 1, !tbaa !17
  %conv207 = sext i8 %113 to i32
  switch i32 %conv207, label %sw.epilog.351 [
    i32 86, label %sw.bb
    i32 77, label %sw.bb.210
    i32 113, label %sw.bb.223
    i32 66, label %sw.bb.236
    i32 83, label %sw.bb.249
    i32 67, label %sw.bb.302
    i32 82, label %sw.bb.308
    i32 84, label %sw.bb.336
    i32 70, label %sw.bb.339
  ]

sw.bb:                                            ; preds = %if.end.204
  %arrayidx208 = getelementptr inbounds [2048 x i8], [2048 x i8]* %buf, i32 0, i64 1
  %call209 = call i32 @atoi(i8* %arrayidx208) #14
  store i32 %call209, i32* %qfver, align 4, !tbaa !5
  br label %sw.epilog.351

sw.bb.210:                                        ; preds = %if.end.204
  %arrayidx211 = getelementptr inbounds [2048 x i8], [2048 x i8]* %buf, i32 0, i64 1
  %call212 = call i64 @strlen(i8* %arrayidx211) #14
  %conv213 = trunc i64 %call212 to i32
  store i32 %conv213, i32* %i, align 4, !tbaa !5
  %conv214 = sext i32 %conv213 to i64
  %cmp215 = icmp uge i64 %conv214, 2048
  br i1 %cmp215, label %if.then.217, label %if.end.218

if.then.217:                                      ; preds = %sw.bb.210
  store i32 2047, i32* %i, align 4, !tbaa !5
  br label %if.end.218

if.end.218:                                       ; preds = %if.then.217, %sw.bb.210
  %114 = bitcast [2048 x i8]* %statmsg to i8*
  %arrayidx219 = getelementptr inbounds [2048 x i8], [2048 x i8]* %buf, i32 0, i64 1
  %115 = load i32, i32* %i, align 4, !tbaa !5
  %conv220 = sext i32 %115 to i64
  call void @llvm.memmove.p0i8.p0i8.i64(i8* %114, i8* %arrayidx219, i64 %conv220, i32 1, i1 false)
  %116 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom221 = sext i32 %116 to i64
  %arrayidx222 = getelementptr inbounds [2048 x i8], [2048 x i8]* %statmsg, i32 0, i64 %idxprom221
  store i8 0, i8* %arrayidx222, align 1, !tbaa !17
  br label %sw.epilog.351

sw.bb.223:                                        ; preds = %if.end.204
  %arrayidx224 = getelementptr inbounds [2048 x i8], [2048 x i8]* %buf, i32 0, i64 1
  %call225 = call i64 @strlen(i8* %arrayidx224) #14
  %conv226 = trunc i64 %call225 to i32
  store i32 %conv226, i32* %i, align 4, !tbaa !5
  %conv227 = sext i32 %conv226 to i64
  %cmp228 = icmp uge i64 %conv227, 2048
  br i1 %cmp228, label %if.then.230, label %if.end.231

if.then.230:                                      ; preds = %sw.bb.223
  store i32 2047, i32* %i, align 4, !tbaa !5
  br label %if.end.231

if.end.231:                                       ; preds = %if.then.230, %sw.bb.223
  %117 = bitcast [2048 x i8]* %quarmsg to i8*
  %arrayidx232 = getelementptr inbounds [2048 x i8], [2048 x i8]* %buf, i32 0, i64 1
  %118 = load i32, i32* %i, align 4, !tbaa !5
  %conv233 = sext i32 %118 to i64
  call void @llvm.memmove.p0i8.p0i8.i64(i8* %117, i8* %arrayidx232, i64 %conv233, i32 1, i1 false)
  %119 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom234 = sext i32 %119 to i64
  %arrayidx235 = getelementptr inbounds [2048 x i8], [2048 x i8]* %quarmsg, i32 0, i64 %idxprom234
  store i8 0, i8* %arrayidx235, align 1, !tbaa !17
  br label %sw.epilog.351

sw.bb.236:                                        ; preds = %if.end.204
  %arrayidx237 = getelementptr inbounds [2048 x i8], [2048 x i8]* %buf, i32 0, i64 1
  %call238 = call i64 @strlen(i8* %arrayidx237) #14
  %conv239 = trunc i64 %call238 to i32
  store i32 %conv239, i32* %i, align 4, !tbaa !5
  %conv240 = sext i32 %conv239 to i64
  %cmp241 = icmp uge i64 %conv240, 257
  br i1 %cmp241, label %if.then.243, label %if.end.244

if.then.243:                                      ; preds = %sw.bb.236
  store i32 256, i32* %i, align 4, !tbaa !5
  br label %if.end.244

if.end.244:                                       ; preds = %if.then.243, %sw.bb.236
  %120 = bitcast [257 x i8]* %bodytype to i8*
  %arrayidx245 = getelementptr inbounds [2048 x i8], [2048 x i8]* %buf, i32 0, i64 1
  %121 = load i32, i32* %i, align 4, !tbaa !5
  %conv246 = sext i32 %121 to i64
  call void @llvm.memmove.p0i8.p0i8.i64(i8* %120, i8* %arrayidx245, i64 %conv246, i32 1, i1 false)
  %122 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom247 = sext i32 %122 to i64
  %arrayidx248 = getelementptr inbounds [257 x i8], [257 x i8]* %bodytype, i32 0, i64 %idxprom247
  store i8 0, i8* %arrayidx248, align 1, !tbaa !17
  br label %sw.epilog.351

sw.bb.249:                                        ; preds = %if.end.204
  %123 = load i32, i32* @Verbose, align 4, !tbaa !5
  %tobool250 = icmp ne i32 %123, 0
  br i1 %tobool250, label %if.then.251, label %if.else.262

if.then.251:                                      ; preds = %sw.bb.249
  %124 = load i64, i64* %dfsize, align 8, !tbaa !92
  %125 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_pri252 = getelementptr inbounds %struct.work, %struct.work* %125, i32 0, i32 4
  %126 = load i64, i64* %w_pri252, align 8, !tbaa !133
  %127 = load i32, i32* %flags, align 4, !tbaa !5
  %conv253 = sext i32 %127 to i64
  %and254 = and i64 %conv253, 1024
  %cmp255 = icmp ne i64 %and254, 0
  %cond257 = select i1 %cmp255, i32 43, i32 32
  %call258 = call i8* @ctime(i64* %submittime) #1
  %add.ptr259 = getelementptr inbounds i8, i8* %call258, i64 4
  %call260 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.120, i32 0, i32 0), i64 %124, i64 %126, i32 %cond257, i8* %add.ptr259)
  %arrayidx261 = getelementptr inbounds [2048 x i8], [2048 x i8]* %buf, i32 0, i64 1
  call void @prtstr(i8* %arrayidx261, i32 78)
  br label %if.end.266

if.else.262:                                      ; preds = %sw.bb.249
  %128 = load i64, i64* %dfsize, align 8, !tbaa !92
  %call263 = call i8* @ctime(i64* %submittime) #1
  %call264 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.121, i32 0, i32 0), i64 %128, i8* %call263)
  %arrayidx265 = getelementptr inbounds [2048 x i8], [2048 x i8]* %buf, i32 0, i64 1
  call void @prtstr(i8* %arrayidx265, i32 39)
  br label %if.end.266

if.end.266:                                       ; preds = %if.else.262, %if.then.251
  %arrayidx267 = getelementptr inbounds [2048 x i8], [2048 x i8]* %quarmsg, i32 0, i64 0
  %129 = load i8, i8* %arrayidx267, align 1, !tbaa !17
  %conv268 = sext i8 %129 to i32
  %cmp269 = icmp ne i32 %conv268, 0
  br i1 %cmp269, label %if.then.271, label %if.end.277

if.then.271:                                      ; preds = %if.end.266
  %130 = load i32, i32* @Verbose, align 4, !tbaa !5
  %tobool272 = icmp ne i32 %130, 0
  %cond273 = select i1 %tobool272, i32 100, i32 60
  %arraydecay274 = getelementptr inbounds [2048 x i8], [2048 x i8]* %quarmsg, i32 0, i32 0
  %call275 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.122, i32 0, i32 0), i32 %cond273, i8* %arraydecay274)
  %arrayidx276 = getelementptr inbounds [2048 x i8], [2048 x i8]* %quarmsg, i32 0, i64 0
  store i8 0, i8* %arrayidx276, align 1, !tbaa !17
  br label %if.end.277

if.end.277:                                       ; preds = %if.then.271, %if.end.266
  %arrayidx278 = getelementptr inbounds [2048 x i8], [2048 x i8]* %statmsg, i32 0, i64 0
  %131 = load i8, i8* %arrayidx278, align 1, !tbaa !17
  %conv279 = sext i8 %131 to i32
  %cmp280 = icmp ne i32 %conv279, 0
  br i1 %cmp280, label %if.then.287, label %lor.lhs.false.282

lor.lhs.false.282:                                ; preds = %if.end.277
  %arrayidx283 = getelementptr inbounds [257 x i8], [257 x i8]* %bodytype, i32 0, i64 0
  %132 = load i8, i8* %arrayidx283, align 1, !tbaa !17
  %conv284 = sext i8 %132 to i32
  %cmp285 = icmp ne i32 %conv284, 0
  br i1 %cmp285, label %if.then.287, label %if.end.301

if.then.287:                                      ; preds = %lor.lhs.false.282, %if.end.277
  %arraydecay288 = getelementptr inbounds [257 x i8], [257 x i8]* %bodytype, i32 0, i32 0
  %call289 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.123, i32 0, i32 0), i8* %arraydecay288)
  %arrayidx290 = getelementptr inbounds [2048 x i8], [2048 x i8]* %statmsg, i32 0, i64 0
  %133 = load i8, i8* %arrayidx290, align 1, !tbaa !17
  %conv291 = sext i8 %133 to i32
  %cmp292 = icmp ne i32 %conv291, 0
  br i1 %cmp292, label %if.then.294, label %if.end.299

if.then.294:                                      ; preds = %if.then.287
  %134 = load i32, i32* @Verbose, align 4, !tbaa !5
  %tobool295 = icmp ne i32 %134, 0
  %cond296 = select i1 %tobool295, i32 100, i32 60
  %arraydecay297 = getelementptr inbounds [2048 x i8], [2048 x i8]* %statmsg, i32 0, i32 0
  %call298 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.124, i32 0, i32 0), i32 %cond296, i8* %arraydecay297)
  br label %if.end.299

if.end.299:                                       ; preds = %if.then.294, %if.then.287
  %arrayidx300 = getelementptr inbounds [2048 x i8], [2048 x i8]* %statmsg, i32 0, i64 0
  store i8 0, i8* %arrayidx300, align 1, !tbaa !17
  br label %if.end.301

if.end.301:                                       ; preds = %if.end.299, %lor.lhs.false.282
  br label %sw.epilog.351

sw.bb.302:                                        ; preds = %if.end.204
  %135 = load i32, i32* @Verbose, align 4, !tbaa !5
  %tobool303 = icmp ne i32 %135, 0
  br i1 %tobool303, label %if.then.304, label %if.end.307

if.then.304:                                      ; preds = %sw.bb.302
  %arrayidx305 = getelementptr inbounds [2048 x i8], [2048 x i8]* %buf, i32 0, i64 1
  %call306 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.125, i32 0, i32 0), i8* %arrayidx305)
  br label %if.end.307

if.end.307:                                       ; preds = %if.then.304, %sw.bb.302
  br label %sw.epilog.351

sw.bb.308:                                        ; preds = %if.end.204
  %arrayidx309 = getelementptr inbounds [2048 x i8], [2048 x i8]* %buf, i32 0, i64 1
  store i8* %arrayidx309, i8** %p, align 8, !tbaa !1
  %136 = load i32, i32* %qfver, align 4, !tbaa !5
  %cmp310 = icmp sge i32 %136, 1
  br i1 %cmp310, label %if.then.312, label %if.end.318

if.then.312:                                      ; preds = %sw.bb.308
  %137 = load i8*, i8** %p, align 8, !tbaa !1
  %call313 = call i8* @strchr(i8* %137, i32 58) #1
  store i8* %call313, i8** %p, align 8, !tbaa !1
  %138 = load i8*, i8** %p, align 8, !tbaa !1
  %cmp314 = icmp eq i8* %138, null
  br i1 %cmp314, label %if.then.316, label %if.end.317

if.then.316:                                      ; preds = %if.then.312
  br label %sw.epilog.351

if.end.317:                                       ; preds = %if.then.312
  %139 = load i8*, i8** %p, align 8, !tbaa !1
  %incdec.ptr = getelementptr inbounds i8, i8* %139, i32 1
  store i8* %incdec.ptr, i8** %p, align 8, !tbaa !1
  br label %if.end.318

if.end.318:                                       ; preds = %if.end.317, %sw.bb.308
  %140 = load i32, i32* @Verbose, align 4, !tbaa !5
  %tobool319 = icmp ne i32 %140, 0
  br i1 %tobool319, label %if.then.320, label %if.else.322

if.then.320:                                      ; preds = %if.end.318
  %call321 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.126, i32 0, i32 0))
  %141 = load i8*, i8** %p, align 8, !tbaa !1
  call void @prtstr(i8* %141, i32 71)
  br label %if.end.324

if.else.322:                                      ; preds = %if.end.318
  %call323 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.127, i32 0, i32 0))
  %142 = load i8*, i8** %p, align 8, !tbaa !1
  call void @prtstr(i8* %142, i32 38)
  br label %if.end.324

if.end.324:                                       ; preds = %if.else.322, %if.then.320
  %143 = load i32, i32* @Verbose, align 4, !tbaa !5
  %tobool325 = icmp ne i32 %143, 0
  br i1 %tobool325, label %land.lhs.true.326, label %if.end.335

land.lhs.true.326:                                ; preds = %if.end.324
  %arrayidx327 = getelementptr inbounds [2048 x i8], [2048 x i8]* %statmsg, i32 0, i64 0
  %144 = load i8, i8* %arrayidx327, align 1, !tbaa !17
  %conv328 = sext i8 %144 to i32
  %cmp329 = icmp ne i32 %conv328, 0
  br i1 %cmp329, label %if.then.331, label %if.end.335

if.then.331:                                      ; preds = %land.lhs.true.326
  %arraydecay332 = getelementptr inbounds [2048 x i8], [2048 x i8]* %statmsg, i32 0, i32 0
  %call333 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.128, i32 0, i32 0), i8* %arraydecay332)
  %arrayidx334 = getelementptr inbounds [2048 x i8], [2048 x i8]* %statmsg, i32 0, i64 0
  store i8 0, i8* %arrayidx334, align 1, !tbaa !17
  br label %if.end.335

if.end.335:                                       ; preds = %if.then.331, %land.lhs.true.326, %if.end.324
  br label %sw.epilog.351

sw.bb.336:                                        ; preds = %if.end.204
  %arrayidx337 = getelementptr inbounds [2048 x i8], [2048 x i8]* %buf, i32 0, i64 1
  %call338 = call i64 @atol(i8* %arrayidx337) #14
  store i64 %call338, i64* %submittime, align 8, !tbaa !92
  br label %sw.epilog.351

sw.bb.339:                                        ; preds = %if.end.204
  %arrayidx340 = getelementptr inbounds [2048 x i8], [2048 x i8]* %buf, i32 0, i64 1
  store i8* %arrayidx340, i8** %p, align 8, !tbaa !1
  br label %for.cond.341

for.cond.341:                                     ; preds = %for.inc, %sw.bb.339
  %145 = load i8*, i8** %p, align 8, !tbaa !1
  %146 = load i8, i8* %145, align 1, !tbaa !17
  %conv342 = sext i8 %146 to i32
  %cmp343 = icmp ne i32 %conv342, 0
  br i1 %cmp343, label %for.body.345, label %for.end

for.body.345:                                     ; preds = %for.cond.341
  %147 = load i8*, i8** %p, align 8, !tbaa !1
  %148 = load i8, i8* %147, align 1, !tbaa !17
  %conv346 = sext i8 %148 to i32
  switch i32 %conv346, label %sw.epilog [
    i32 119, label %sw.bb.347
  ]

sw.bb.347:                                        ; preds = %for.body.345
  %149 = load i32, i32* %flags, align 4, !tbaa !5
  %conv348 = sext i32 %149 to i64
  %or = or i64 %conv348, 1024
  %conv349 = trunc i64 %or to i32
  store i32 %conv349, i32* %flags, align 4, !tbaa !5
  br label %sw.epilog

sw.epilog:                                        ; preds = %for.body.345, %sw.bb.347
  br label %for.inc

for.inc:                                          ; preds = %sw.epilog
  %150 = load i8*, i8** %p, align 8, !tbaa !1
  %incdec.ptr350 = getelementptr inbounds i8, i8* %150, i32 1
  store i8* %incdec.ptr350, i8** %p, align 8, !tbaa !1
  br label %for.cond.341

for.end:                                          ; preds = %for.cond.341
  br label %sw.epilog.351

sw.epilog.351:                                    ; preds = %for.end, %if.end.204, %sw.bb.336, %if.end.335, %if.then.316, %if.end.307, %if.end.301, %if.end.244, %if.end.231, %if.end.218, %sw.bb
  %151 = bitcast i8** %p to i8*
  call void @llvm.lifetime.end(i64 8, i8* %151) #1
  %152 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end(i64 4, i8* %152) #1
  br label %while.cond.196

while.end.352:                                    ; preds = %while.cond.196
  %153 = load i64, i64* %submittime, align 8, !tbaa !92
  %cmp353 = icmp eq i64 %153, 0
  br i1 %cmp353, label %if.then.355, label %if.end.357

if.then.355:                                      ; preds = %while.end.352
  %call356 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.129, i32 0, i32 0))
  br label %if.end.357

if.end.357:                                       ; preds = %if.then.355, %while.end.352
  %call358 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.45, i32 0, i32 0))
  %154 = load %struct.sm_file*, %struct.sm_file** %f, align 8, !tbaa !1
  %call359 = call i32 @sm_io_close(%struct.sm_file* %154, i32 -2)
  store i32 0, i32* %cleanup.dest.slot
  br label %cleanup.360

cleanup.360:                                      ; preds = %if.end.357, %if.end.130
  %155 = bitcast [4096 x i8]* %qf to i8*
  call void @llvm.lifetime.end(i64 4096, i8* %155) #1
  %156 = bitcast [257 x i8]* %bodytype to i8*
  call void @llvm.lifetime.end(i64 257, i8* %156) #1
  %157 = bitcast [2048 x i8]* %statmsg to i8*
  call void @llvm.lifetime.end(i64 2048, i8* %157) #1
  %158 = bitcast [2048 x i8]* %quarmsg to i8*
  call void @llvm.lifetime.end(i64 2048, i8* %158) #1
  %159 = bitcast i32* %qfver to i8*
  call void @llvm.lifetime.end(i64 4, i8* %159) #1
  %160 = bitcast i32* %flags to i8*
  call void @llvm.lifetime.end(i64 4, i8* %160) #1
  %161 = bitcast i64* %dfsize to i8*
  call void @llvm.lifetime.end(i64 8, i8* %161) #1
  %162 = bitcast i64* %submittime to i8*
  call void @llvm.lifetime.end(i64 8, i8* %162) #1
  %163 = bitcast %struct.stat* %st100 to i8*
  call void @llvm.lifetime.end(i64 144, i8* %163) #1
  %cleanup.dest.369 = load i32, i32* %cleanup.dest.slot
  switch i32 %cleanup.dest.369, label %unreachable [
    i32 0, label %cleanup.cont.370
    i32 8, label %for.inc.371
  ]

cleanup.cont.370:                                 ; preds = %cleanup.360
  br label %for.inc.371

for.inc.371:                                      ; preds = %cleanup.cont.370, %cleanup.360
  %164 = load %struct.work*, %struct.work** %w, align 8, !tbaa !1
  %w_next = getelementptr inbounds %struct.work, %struct.work* %164, i32 0, i32 9
  %165 = load %struct.work*, %struct.work** %w_next, align 8, !tbaa !118
  store %struct.work* %165, %struct.work** %w, align 8, !tbaa !1
  br label %for.cond

for.end.372:                                      ; preds = %for.cond
  %166 = load i32, i32* %nrequests, align 4, !tbaa !5
  store i32 %166, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup.373

cleanup.373:                                      ; preds = %for.end.372, %if.then.76, %cleanup
  %167 = bitcast [2048 x i8]* %buf to i8*
  call void @llvm.lifetime.end(i64 2048, i8* %167) #1
  %168 = bitcast [4096 x i8]* %qddf to i8*
  call void @llvm.lifetime.end(i64 4096, i8* %168) #1
  %169 = bitcast [4096 x i8]* %qd to i8*
  call void @llvm.lifetime.end(i64 4096, i8* %169) #1
  %170 = bitcast i32* %nrequests to i8*
  call void @llvm.lifetime.end(i64 4, i8* %170) #1
  %171 = bitcast %struct.sm_file** %f to i8*
  call void @llvm.lifetime.end(i64 8, i8* %171) #1
  %172 = bitcast %struct.work** %w to i8*
  call void @llvm.lifetime.end(i64 8, i8* %172) #1
  %173 = load i32, i32* %retval
  ret i32 %173

unreachable:                                      ; preds = %cleanup.360
  unreachable
}

declare i64 @sm_strlcpyn(i8*, i64, i32, ...) #2

; Function Attrs: inlinehint nounwind uwtable
define available_externally i32 @stat(i8* nonnull %__path, %struct.stat* nonnull %__statbuf) #5 {
entry:
  %__path.addr = alloca i8*, align 8
  %__statbuf.addr = alloca %struct.stat*, align 8
  store i8* %__path, i8** %__path.addr, align 8, !tbaa !1
  store %struct.stat* %__statbuf, %struct.stat** %__statbuf.addr, align 8, !tbaa !1
  %0 = load i8*, i8** %__path.addr, align 8, !tbaa !1
  %1 = load %struct.stat*, %struct.stat** %__statbuf.addr, align 8, !tbaa !1
  %call = call i32 @__xstat(i32 1, i8* %0, %struct.stat* %1) #1
  ret i32 %call
}

declare void @usrerr(i8*, ...) #2

declare i32 @sm_io_fgets(%struct.sm_file*, i32, i8*, i32) #2

declare void @fixcrlf(i8*, i32) #2

; Function Attrs: inlinehint nounwind readonly uwtable
define available_externally i32 @atoi(i8* nonnull %__nptr) #7 {
entry:
  %__nptr.addr = alloca i8*, align 8
  store i8* %__nptr, i8** %__nptr.addr, align 8, !tbaa !1
  %0 = load i8*, i8** %__nptr.addr, align 8, !tbaa !1
  %call = call i64 @strtol(i8* %0, i8** null, i32 10) #1
  %conv = trunc i64 %call to i32
  ret i32 %conv
}

; Function Attrs: nounwind readonly
declare i64 @strlen(i8*) #8

; Function Attrs: nounwind
declare void @llvm.memmove.p0i8.p0i8.i64(i8* nocapture, i8* nocapture readonly, i64, i32, i1) #1

; Function Attrs: nounwind
declare i8* @ctime(i64*) #3

; Function Attrs: nounwind uwtable
define internal void @prtstr(i8* %s, i32 %ml) #0 {
entry:
  %s.addr = alloca i8*, align 8
  %ml.addr = alloca i32, align 4
  %c = alloca i32, align 4
  %cleanup.dest.slot = alloca i32
  store i8* %s, i8** %s.addr, align 8, !tbaa !1
  store i32 %ml, i32* %ml.addr, align 4, !tbaa !5
  %0 = bitcast i32* %c to i8*
  call void @llvm.lifetime.start(i64 4, i8* %0) #1
  %1 = load i8*, i8** %s.addr, align 8, !tbaa !1
  %cmp = icmp eq i8* %1, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end:                                           ; preds = %entry
  br label %while.cond

while.cond:                                       ; preds = %if.end.28, %if.end
  %2 = load i32, i32* %ml.addr, align 4, !tbaa !5
  %dec = add nsw i32 %2, -1
  store i32 %dec, i32* %ml.addr, align 4, !tbaa !5
  %cmp1 = icmp sgt i32 %2, 0
  br i1 %cmp1, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %3 = load i8*, i8** %s.addr, align 8, !tbaa !1
  %incdec.ptr = getelementptr inbounds i8, i8* %3, i32 1
  store i8* %incdec.ptr, i8** %s.addr, align 8, !tbaa !1
  %4 = load i8, i8* %3, align 1, !tbaa !17
  %conv = sext i8 %4 to i32
  store i32 %conv, i32* %c, align 4, !tbaa !5
  %cmp2 = icmp ne i32 %conv, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %5 = phi i1 [ false, %while.cond ], [ %cmp2, %land.rhs ]
  br i1 %5, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %6 = load i32, i32* %c, align 4, !tbaa !5
  %cmp4 = icmp eq i32 %6, 92
  br i1 %cmp4, label %if.then.6, label %if.else

if.then.6:                                        ; preds = %while.body
  %7 = load i32, i32* %ml.addr, align 4, !tbaa !5
  %dec7 = add nsw i32 %7, -1
  store i32 %dec7, i32* %ml.addr, align 4, !tbaa !5
  %cmp8 = icmp sgt i32 %7, 0
  br i1 %cmp8, label %if.then.10, label %if.end.12

if.then.10:                                       ; preds = %if.then.6
  %8 = load i32, i32* %c, align 4, !tbaa !5
  %call = call i32 @sm_io_putc(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i32 %8)
  %9 = load i32, i32* %c, align 4, !tbaa !5
  %call11 = call i32 @sm_io_putc(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i32 %9)
  br label %if.end.12

if.end.12:                                        ; preds = %if.then.10, %if.then.6
  br label %if.end.28

if.else:                                          ; preds = %while.body
  %10 = load i32, i32* %c, align 4, !tbaa !5
  %and = and i32 %10, -128
  %cmp13 = icmp eq i32 %and, 0
  br i1 %cmp13, label %land.lhs.true, label %if.else.20

land.lhs.true:                                    ; preds = %if.else
  %11 = load i32, i32* %c, align 4, !tbaa !5
  %idxprom = sext i32 %11 to i64
  %call15 = call i16** @__ctype_b_loc() #11
  %12 = load i16*, i16** %call15, align 8, !tbaa !1
  %arrayidx = getelementptr inbounds i16, i16* %12, i64 %idxprom
  %13 = load i16, i16* %arrayidx, align 2, !tbaa !88
  %conv16 = zext i16 %13 to i32
  %and17 = and i32 %conv16, 16384
  %tobool = icmp ne i32 %and17, 0
  br i1 %tobool, label %if.then.18, label %if.else.20

if.then.18:                                       ; preds = %land.lhs.true
  %14 = load i32, i32* %c, align 4, !tbaa !5
  %call19 = call i32 @sm_io_putc(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i32 %14)
  br label %if.end.27

if.else.20:                                       ; preds = %land.lhs.true, %if.else
  %15 = load i32, i32* %ml.addr, align 4, !tbaa !5
  %sub = sub nsw i32 %15, 3
  store i32 %sub, i32* %ml.addr, align 4, !tbaa !5
  %cmp21 = icmp sgt i32 %sub, 0
  br i1 %cmp21, label %if.then.23, label %if.end.26

if.then.23:                                       ; preds = %if.else.20
  %16 = load i32, i32* %c, align 4, !tbaa !5
  %and24 = and i32 %16, 255
  %call25 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.265, i32 0, i32 0), i32 %and24)
  br label %if.end.26

if.end.26:                                        ; preds = %if.then.23, %if.else.20
  br label %if.end.27

if.end.27:                                        ; preds = %if.end.26, %if.then.18
  br label %if.end.28

if.end.28:                                        ; preds = %if.end.27, %if.end.12
  br label %while.cond

while.end:                                        ; preds = %land.end
  store i32 0, i32* %cleanup.dest.slot
  br label %cleanup

cleanup:                                          ; preds = %while.end, %if.then
  %17 = bitcast i32* %c to i8*
  call void @llvm.lifetime.end(i64 4, i8* %17) #1
  %cleanup.dest = load i32, i32* %cleanup.dest.slot
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %cleanup.cont
    i32 1, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup, %cleanup
  ret void

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: nounwind
declare i8* @strchr(i8*, i32) #3

; Function Attrs: inlinehint nounwind readonly uwtable
define available_externally i64 @atol(i8* nonnull %__nptr) #7 {
entry:
  %__nptr.addr = alloca i8*, align 8
  store i8* %__nptr, i8** %__nptr.addr, align 8, !tbaa !1
  %0 = load i8*, i8** %__nptr.addr, align 8, !tbaa !1
  %call = call i64 @strtol(i8* %0, i8** null, i32 10) #1
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define void @assign_queueid(%struct.envelope* %e) #0 {
entry:
  %e.addr = alloca %struct.envelope*, align 8
  %pid = alloca i32, align 4
  %tm = alloca %struct.tm*, align 8
  %idbuf = alloca [19 x i8], align 16
  %seq = alloca i32, align 4
  %cleanup.dest.slot = alloca i32
  %then = alloca i64, align 8
  store %struct.envelope* %e, %struct.envelope** %e.addr, align 8, !tbaa !1
  %0 = bitcast i32* %pid to i8*
  call void @llvm.lifetime.start(i64 4, i8* %0) #1
  %1 = load i32, i32* @CurrentPid, align 4, !tbaa !5
  store i32 %1, i32* %pid, align 4, !tbaa !5
  %2 = bitcast %struct.tm** %tm to i8*
  call void @llvm.lifetime.start(i64 8, i8* %2) #1
  %3 = bitcast [19 x i8]* %idbuf to i8*
  call void @llvm.lifetime.start(i64 19, i8* %3) #1
  %4 = bitcast i32* %seq to i8*
  call void @llvm.lifetime.start(i64 4, i8* %4) #1
  %5 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id = getelementptr inbounds %struct.envelope, %struct.envelope* %5, i32 0, i32 25
  %6 = load i8*, i8** %e_id, align 8, !tbaa !7
  %cmp = icmp ne i8* %6, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end:                                           ; preds = %entry
  %7 = load i32, i32* @assign_queueid.cX, align 4, !tbaa !5
  %cmp1 = icmp uge i32 %7, 3600
  br i1 %cmp1, label %if.then.5, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %8 = load i64, i64* @LastQueueTime, align 8, !tbaa !92
  %cmp2 = icmp eq i64 %8, 0
  br i1 %cmp2, label %if.then.5, label %lor.lhs.false.3

lor.lhs.false.3:                                  ; preds = %lor.lhs.false
  %9 = load i32, i32* @LastQueuePid, align 4, !tbaa !5
  %10 = load i32, i32* %pid, align 4, !tbaa !5
  %cmp4 = icmp ne i32 %9, %10
  br i1 %cmp4, label %if.then.5, label %if.end.15

if.then.5:                                        ; preds = %lor.lhs.false.3, %lor.lhs.false, %if.end
  %11 = bitcast i64* %then to i8*
  call void @llvm.lifetime.start(i64 8, i8* %11) #1
  %12 = load i64, i64* @LastQueueTime, align 8, !tbaa !92
  store i64 %12, i64* %then, align 8, !tbaa !92
  %13 = load i64, i64* @LastQueueTime, align 8, !tbaa !92
  %cmp6 = icmp eq i64 %13, 0
  br i1 %cmp6, label %if.then.7, label %if.end.8

if.then.7:                                        ; preds = %if.then.5
  %call = call i64 @random() #1
  %conv = trunc i64 %call to i32
  %rem = urem i32 %conv, 3600
  store i32 %rem, i32* @assign_queueid.random_offset, align 4, !tbaa !5
  br label %if.end.8

if.end.8:                                         ; preds = %if.then.7, %if.then.5
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end.8
  %call9 = call i64 @curtime()
  store i64 %call9, i64* @LastQueueTime, align 8, !tbaa !92
  %14 = load i64, i64* %then, align 8, !tbaa !92
  %cmp10 = icmp eq i64 %call9, %14
  br i1 %cmp10, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %15 = load i32, i32* @LastQueuePid, align 4, !tbaa !5
  %16 = load i32, i32* %pid, align 4, !tbaa !5
  %cmp12 = icmp eq i32 %15, %16
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %17 = phi i1 [ false, %while.cond ], [ %cmp12, %land.rhs ]
  br i1 %17, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %call14 = call i32 @sleep(i32 1)
  br label %while.cond

while.end:                                        ; preds = %land.end
  %18 = load i32, i32* @CurrentPid, align 4, !tbaa !5
  store i32 %18, i32* @LastQueuePid, align 4, !tbaa !5
  store i32 0, i32* @assign_queueid.cX, align 4, !tbaa !5
  %19 = bitcast i64* %then to i8*
  call void @llvm.lifetime.end(i64 8, i8* %19) #1
  br label %if.end.15

if.end.15:                                        ; preds = %while.end, %lor.lhs.false.3
  %20 = load i32, i32* @assign_queueid.cX, align 4, !tbaa !5
  %21 = load i32, i32* @assign_queueid.random_offset, align 4, !tbaa !5
  %add = add i32 %20, %21
  %rem16 = urem i32 %add, 3600
  store i32 %rem16, i32* %seq, align 4, !tbaa !5
  %22 = load i32, i32* @assign_queueid.cX, align 4, !tbaa !5
  %inc = add i32 %22, 1
  store i32 %inc, i32* @assign_queueid.cX, align 4, !tbaa !5
  %23 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 7), align 1, !tbaa !17
  %conv17 = zext i8 %23 to i32
  %cmp18 = icmp sge i32 %conv17, 50
  br i1 %cmp18, label %land.lhs.true, label %if.end.21

land.lhs.true:                                    ; preds = %if.end.15
  %24 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool = icmp ne i32 %24, 0
  br i1 %tobool, label %if.end.21, label %if.then.20

if.then.20:                                       ; preds = %land.lhs.true
  %25 = load i32, i32* @assign_queueid.random_offset, align 4, !tbaa !5
  %26 = load i32, i32* %seq, align 4, !tbaa !5
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.135, i32 0, i32 0), i32 %25, i32 %26)
  br label %if.end.21

if.end.21:                                        ; preds = %if.then.20, %land.lhs.true, %if.end.15
  %call22 = call %struct.tm* @gmtime(i64* @LastQueueTime) #1
  store %struct.tm* %call22, %struct.tm** %tm, align 8, !tbaa !1
  %27 = load %struct.tm*, %struct.tm** %tm, align 8, !tbaa !1
  %tm_year = getelementptr inbounds %struct.tm, %struct.tm* %27, i32 0, i32 5
  %28 = load i32, i32* %tm_year, align 4, !tbaa !149
  %rem23 = srem i32 %28, 60
  %idxprom = sext i32 %rem23 to i64
  %arrayidx = getelementptr inbounds [63 x i8], [63 x i8]* @QueueIdChars, i32 0, i64 %idxprom
  %29 = load i8, i8* %arrayidx, align 1, !tbaa !17
  %arrayidx24 = getelementptr inbounds [19 x i8], [19 x i8]* %idbuf, i32 0, i64 0
  store i8 %29, i8* %arrayidx24, align 1, !tbaa !17
  %30 = load %struct.tm*, %struct.tm** %tm, align 8, !tbaa !1
  %tm_mon = getelementptr inbounds %struct.tm, %struct.tm* %30, i32 0, i32 4
  %31 = load i32, i32* %tm_mon, align 4, !tbaa !151
  %idxprom25 = sext i32 %31 to i64
  %arrayidx26 = getelementptr inbounds [63 x i8], [63 x i8]* @QueueIdChars, i32 0, i64 %idxprom25
  %32 = load i8, i8* %arrayidx26, align 1, !tbaa !17
  %arrayidx27 = getelementptr inbounds [19 x i8], [19 x i8]* %idbuf, i32 0, i64 1
  store i8 %32, i8* %arrayidx27, align 1, !tbaa !17
  %33 = load %struct.tm*, %struct.tm** %tm, align 8, !tbaa !1
  %tm_mday = getelementptr inbounds %struct.tm, %struct.tm* %33, i32 0, i32 3
  %34 = load i32, i32* %tm_mday, align 4, !tbaa !152
  %idxprom28 = sext i32 %34 to i64
  %arrayidx29 = getelementptr inbounds [63 x i8], [63 x i8]* @QueueIdChars, i32 0, i64 %idxprom28
  %35 = load i8, i8* %arrayidx29, align 1, !tbaa !17
  %arrayidx30 = getelementptr inbounds [19 x i8], [19 x i8]* %idbuf, i32 0, i64 2
  store i8 %35, i8* %arrayidx30, align 1, !tbaa !17
  %36 = load %struct.tm*, %struct.tm** %tm, align 8, !tbaa !1
  %tm_hour = getelementptr inbounds %struct.tm, %struct.tm* %36, i32 0, i32 2
  %37 = load i32, i32* %tm_hour, align 4, !tbaa !153
  %idxprom31 = sext i32 %37 to i64
  %arrayidx32 = getelementptr inbounds [63 x i8], [63 x i8]* @QueueIdChars, i32 0, i64 %idxprom31
  %38 = load i8, i8* %arrayidx32, align 1, !tbaa !17
  %arrayidx33 = getelementptr inbounds [19 x i8], [19 x i8]* %idbuf, i32 0, i64 3
  store i8 %38, i8* %arrayidx33, align 1, !tbaa !17
  %39 = load %struct.tm*, %struct.tm** %tm, align 8, !tbaa !1
  %tm_min = getelementptr inbounds %struct.tm, %struct.tm* %39, i32 0, i32 1
  %40 = load i32, i32* %tm_min, align 4, !tbaa !154
  %rem34 = srem i32 %40, 62
  %idxprom35 = sext i32 %rem34 to i64
  %arrayidx36 = getelementptr inbounds [63 x i8], [63 x i8]* @QueueIdChars, i32 0, i64 %idxprom35
  %41 = load i8, i8* %arrayidx36, align 1, !tbaa !17
  %arrayidx37 = getelementptr inbounds [19 x i8], [19 x i8]* %idbuf, i32 0, i64 4
  store i8 %41, i8* %arrayidx37, align 1, !tbaa !17
  %42 = load %struct.tm*, %struct.tm** %tm, align 8, !tbaa !1
  %tm_sec = getelementptr inbounds %struct.tm, %struct.tm* %42, i32 0, i32 0
  %43 = load i32, i32* %tm_sec, align 4, !tbaa !155
  %rem38 = srem i32 %43, 62
  %idxprom39 = sext i32 %rem38 to i64
  %arrayidx40 = getelementptr inbounds [63 x i8], [63 x i8]* @QueueIdChars, i32 0, i64 %idxprom39
  %44 = load i8, i8* %arrayidx40, align 1, !tbaa !17
  %arrayidx41 = getelementptr inbounds [19 x i8], [19 x i8]* %idbuf, i32 0, i64 5
  store i8 %44, i8* %arrayidx41, align 1, !tbaa !17
  %45 = load i32, i32* %seq, align 4, !tbaa !5
  %div = udiv i32 %45, 60
  %idxprom42 = zext i32 %div to i64
  %arrayidx43 = getelementptr inbounds [63 x i8], [63 x i8]* @QueueIdChars, i32 0, i64 %idxprom42
  %46 = load i8, i8* %arrayidx43, align 1, !tbaa !17
  %arrayidx44 = getelementptr inbounds [19 x i8], [19 x i8]* %idbuf, i32 0, i64 6
  store i8 %46, i8* %arrayidx44, align 1, !tbaa !17
  %47 = load i32, i32* %seq, align 4, !tbaa !5
  %rem45 = urem i32 %47, 60
  %idxprom46 = zext i32 %rem45 to i64
  %arrayidx47 = getelementptr inbounds [63 x i8], [63 x i8]* @QueueIdChars, i32 0, i64 %idxprom46
  %48 = load i8, i8* %arrayidx47, align 1, !tbaa !17
  %arrayidx48 = getelementptr inbounds [19 x i8], [19 x i8]* %idbuf, i32 0, i64 7
  store i8 %48, i8* %arrayidx48, align 1, !tbaa !17
  %arrayidx49 = getelementptr inbounds [19 x i8], [19 x i8]* %idbuf, i32 0, i64 8
  %49 = load i32, i32* @LastQueuePid, align 4, !tbaa !5
  %call50 = call i32 (i8*, i64, i8*, ...) @sm_snprintf(i8* %arrayidx49, i64 11, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.136, i32 0, i32 0), i32 %49)
  %50 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_rpool = getelementptr inbounds %struct.envelope, %struct.envelope* %50, i32 0, i32 52
  %51 = load %struct.SM_RPOOL_T*, %struct.SM_RPOOL_T** %e_rpool, align 8, !tbaa !120
  %arraydecay = getelementptr inbounds [19 x i8], [19 x i8]* %idbuf, i32 0, i32 0
  %call51 = call i8* @sm_rpool_strdup_x(%struct.SM_RPOOL_T* %51, i8* %arraydecay)
  %52 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id52 = getelementptr inbounds %struct.envelope, %struct.envelope* %52, i32 0, i32 25
  store i8* %call51, i8** %e_id52, align 8, !tbaa !7
  %53 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_macro = getelementptr inbounds %struct.envelope, %struct.envelope* %53, i32 0, i32 46
  %54 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id53 = getelementptr inbounds %struct.envelope, %struct.envelope* %54, i32 0, i32 25
  %55 = load i8*, i8** %e_id53, align 8, !tbaa !7
  %56 = load i32, i32* @SmHeapGroup, align 4, !tbaa !5
  call void @macdefine_tagged(%struct.MACROS_T* %e_macro, i32 2, i32 105, i8* %55, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 5438, i32 %56)
  %57 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qfletter = getelementptr inbounds %struct.envelope, %struct.envelope* %57, i32 0, i32 37
  store i8 0, i8* %e_qfletter, align 1, !tbaa !79
  %58 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 7), align 1, !tbaa !17
  %conv54 = zext i8 %58 to i32
  %cmp55 = icmp sge i32 %conv54, 1
  br i1 %cmp55, label %land.lhs.true.57, label %if.end.61

land.lhs.true.57:                                 ; preds = %if.end.21
  %59 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool58 = icmp ne i32 %59, 0
  br i1 %tobool58, label %if.end.61, label %if.then.59

if.then.59:                                       ; preds = %land.lhs.true.57
  %60 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id60 = getelementptr inbounds %struct.envelope, %struct.envelope* %60, i32 0, i32 25
  %61 = load i8*, i8** %e_id60, align 8, !tbaa !7
  %62 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.137, i32 0, i32 0), i8* %61, %struct.envelope* %62)
  br label %if.end.61

if.end.61:                                        ; preds = %if.then.59, %land.lhs.true.57, %if.end.21
  %63 = load i32, i32* @LogLevel, align 4, !tbaa !5
  %cmp62 = icmp sgt i32 %63, 93
  br i1 %cmp62, label %if.then.64, label %if.end.66

if.then.64:                                       ; preds = %if.end.61
  %64 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id65 = getelementptr inbounds %struct.envelope, %struct.envelope* %64, i32 0, i32 25
  %65 = load i8*, i8** %e_id65, align 8, !tbaa !7
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 7, i8* %65, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.138, i32 0, i32 0))
  br label %if.end.66

if.end.66:                                        ; preds = %if.then.64, %if.end.61
  store i32 0, i32* %cleanup.dest.slot
  br label %cleanup

cleanup:                                          ; preds = %if.end.66, %if.then
  %66 = bitcast i32* %seq to i8*
  call void @llvm.lifetime.end(i64 4, i8* %66) #1
  %67 = bitcast [19 x i8]* %idbuf to i8*
  call void @llvm.lifetime.end(i64 19, i8* %67) #1
  %68 = bitcast %struct.tm** %tm to i8*
  call void @llvm.lifetime.end(i64 8, i8* %68) #1
  %69 = bitcast i32* %pid to i8*
  call void @llvm.lifetime.end(i64 4, i8* %69) #1
  %cleanup.dest = load i32, i32* %cleanup.dest.slot
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %cleanup.cont
    i32 1, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup, %cleanup
  ret void

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: nounwind
declare i64 @random() #3

; Function Attrs: nounwind uwtable
define i32 @setnewqueue(%struct.envelope* %e) #0 {
entry:
  %retval = alloca i32, align 4
  %e.addr = alloca %struct.envelope*, align 8
  %q = alloca %struct.address*, align 8
  store %struct.envelope* %e, %struct.envelope** %e.addr, align 8, !tbaa !1
  %0 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 41), align 1, !tbaa !17
  %conv = zext i8 %0 to i32
  %cmp = icmp sge i32 %conv, 20
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.146, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %2 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qgrp = getelementptr inbounds %struct.envelope, %struct.envelope* %2, i32 0, i32 26
  %3 = load i32, i32* %e_qgrp, align 4, !tbaa !18
  %cmp2 = icmp eq i32 %3, -1
  br i1 %cmp2, label %if.then.4, label %if.end.42

if.then.4:                                        ; preds = %if.end
  %4 = bitcast %struct.address** %q to i8*
  call void @llvm.lifetime.start(i64 8, i8* %4) #1
  %5 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_sendqueue = getelementptr inbounds %struct.envelope, %struct.envelope* %5, i32 0, i32 7
  %6 = load %struct.address*, %struct.address** %e_sendqueue, align 8, !tbaa !20
  store %struct.address* %6, %struct.address** %q, align 8, !tbaa !1
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then.4
  %7 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %cmp5 = icmp ne %struct.address* %7, null
  br i1 %cmp5, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %8 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_state = getelementptr inbounds %struct.address, %struct.address* %8, i32 0, i32 21
  %9 = load i16, i16* %q_state, align 2, !tbaa !52
  %conv7 = sext i16 %9 to i32
  %cmp8 = icmp eq i32 %conv7, 2
  br i1 %cmp8, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.rhs
  %10 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_state10 = getelementptr inbounds %struct.address, %struct.address* %10, i32 0, i32 21
  %11 = load i16, i16* %q_state10, align 2, !tbaa !52
  %conv11 = sext i16 %11 to i32
  %cmp12 = icmp sge i32 %conv11, 6
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.rhs
  %12 = phi i1 [ true, %land.rhs ], [ %cmp12, %lor.rhs ]
  br label %land.end

land.end:                                         ; preds = %lor.end, %while.cond
  %13 = phi i1 [ false, %while.cond ], [ %12, %lor.end ]
  br i1 %13, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %14 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_next = getelementptr inbounds %struct.address, %struct.address* %14, i32 0, i32 10
  %15 = load %struct.address*, %struct.address** %q_next, align 8, !tbaa !62
  store %struct.address* %15, %struct.address** %q, align 8, !tbaa !1
  br label %while.cond

while.end:                                        ; preds = %land.end
  %16 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %cmp14 = icmp eq %struct.address* %16, null
  br i1 %cmp14, label %if.then.16, label %if.else

if.then.16:                                       ; preds = %while.end
  %17 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qgrp17 = getelementptr inbounds %struct.envelope, %struct.envelope* %17, i32 0, i32 26
  store i32 0, i32* %e_qgrp17, align 4, !tbaa !18
  br label %if.end.40

if.else:                                          ; preds = %while.end
  %18 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_qgrp = getelementptr inbounds %struct.address, %struct.address* %18, i32 0, i32 23
  %19 = load i32, i32* %q_qgrp, align 4, !tbaa !146
  %cmp18 = icmp sge i32 %19, 0
  br i1 %cmp18, label %if.then.20, label %if.else.23

if.then.20:                                       ; preds = %if.else
  %20 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_qgrp21 = getelementptr inbounds %struct.address, %struct.address* %20, i32 0, i32 23
  %21 = load i32, i32* %q_qgrp21, align 4, !tbaa !146
  %22 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qgrp22 = getelementptr inbounds %struct.envelope, %struct.envelope* %22, i32 0, i32 26
  store i32 %21, i32* %e_qgrp22, align 4, !tbaa !18
  br label %if.end.39

if.else.23:                                       ; preds = %if.else
  %23 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_mailer = getelementptr inbounds %struct.address, %struct.address* %23, i32 0, i32 4
  %24 = load %struct.mailer*, %struct.mailer** %q_mailer, align 8, !tbaa !60
  %cmp24 = icmp ne %struct.mailer* %24, null
  br i1 %cmp24, label %land.lhs.true.26, label %if.else.36

land.lhs.true.26:                                 ; preds = %if.else.23
  %25 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_mailer27 = getelementptr inbounds %struct.address, %struct.address* %25, i32 0, i32 4
  %26 = load %struct.mailer*, %struct.mailer** %q_mailer27, align 8, !tbaa !60
  %m_qgrp = getelementptr inbounds %struct.mailer, %struct.mailer* %26, i32 0, i32 24
  %27 = load i16, i16* %m_qgrp, align 2, !tbaa !156
  %conv28 = sext i16 %27 to i32
  %cmp29 = icmp sge i32 %conv28, 0
  br i1 %cmp29, label %if.then.31, label %if.else.36

if.then.31:                                       ; preds = %land.lhs.true.26
  %28 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_mailer32 = getelementptr inbounds %struct.address, %struct.address* %28, i32 0, i32 4
  %29 = load %struct.mailer*, %struct.mailer** %q_mailer32, align 8, !tbaa !60
  %m_qgrp33 = getelementptr inbounds %struct.mailer, %struct.mailer* %29, i32 0, i32 24
  %30 = load i16, i16* %m_qgrp33, align 2, !tbaa !156
  %conv34 = sext i16 %30 to i32
  %31 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qgrp35 = getelementptr inbounds %struct.envelope, %struct.envelope* %31, i32 0, i32 26
  store i32 %conv34, i32* %e_qgrp35, align 4, !tbaa !18
  br label %if.end.38

if.else.36:                                       ; preds = %land.lhs.true.26, %if.else.23
  %32 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qgrp37 = getelementptr inbounds %struct.envelope, %struct.envelope* %32, i32 0, i32 26
  store i32 0, i32* %e_qgrp37, align 4, !tbaa !18
  br label %if.end.38

if.end.38:                                        ; preds = %if.else.36, %if.then.31
  br label %if.end.39

if.end.39:                                        ; preds = %if.end.38, %if.then.20
  br label %if.end.40

if.end.40:                                        ; preds = %if.end.39, %if.then.16
  %33 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qgrp41 = getelementptr inbounds %struct.envelope, %struct.envelope* %33, i32 0, i32 26
  %34 = load i32, i32* %e_qgrp41, align 4, !tbaa !18
  %35 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_dfqgrp = getelementptr inbounds %struct.envelope, %struct.envelope* %35, i32 0, i32 28
  store i32 %34, i32* %e_dfqgrp, align 4, !tbaa !36
  %36 = bitcast %struct.address** %q to i8*
  call void @llvm.lifetime.end(i64 8, i8* %36) #1
  br label %if.end.42

if.end.42:                                        ; preds = %if.end.40, %if.end
  %37 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qdir = getelementptr inbounds %struct.envelope, %struct.envelope* %37, i32 0, i32 27
  %38 = load i32, i32* %e_qdir, align 4, !tbaa !19
  %cmp43 = icmp sge i32 %38, 0
  br i1 %cmp43, label %land.lhs.true.45, label %if.end.58

land.lhs.true.45:                                 ; preds = %if.end.42
  %39 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_dfqdir = getelementptr inbounds %struct.envelope, %struct.envelope* %39, i32 0, i32 29
  %40 = load i32, i32* %e_dfqdir, align 4, !tbaa !37
  %cmp46 = icmp sge i32 %40, 0
  br i1 %cmp46, label %if.then.48, label %if.end.58

if.then.48:                                       ; preds = %land.lhs.true.45
  %41 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 41), align 1, !tbaa !17
  %conv49 = zext i8 %41 to i32
  %cmp50 = icmp sge i32 %conv49, 20
  br i1 %cmp50, label %land.lhs.true.52, label %if.end.57

land.lhs.true.52:                                 ; preds = %if.then.48
  %42 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool53 = icmp ne i32 %42, 0
  br i1 %tobool53, label %if.end.57, label %if.then.54

if.then.54:                                       ; preds = %land.lhs.true.52
  %43 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qgrp55 = getelementptr inbounds %struct.envelope, %struct.envelope* %43, i32 0, i32 26
  %44 = load i32, i32* %e_qgrp55, align 4, !tbaa !18
  %45 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qdir56 = getelementptr inbounds %struct.envelope, %struct.envelope* %45, i32 0, i32 27
  %46 = load i32, i32* %e_qdir56, align 4, !tbaa !19
  %call = call i8* @qid_printqueue(i32 %44, i32 %46)
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.147, i32 0, i32 0), i8* %call)
  br label %if.end.57

if.end.57:                                        ; preds = %if.then.54, %land.lhs.true.52, %if.then.48
  store i32 1, i32* %retval
  br label %return

if.end.58:                                        ; preds = %land.lhs.true.45, %if.end.42
  call void @filesys_update()
  %47 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qgrp59 = getelementptr inbounds %struct.envelope, %struct.envelope* %47, i32 0, i32 26
  %48 = load i32, i32* %e_qgrp59, align 4, !tbaa !18
  %idxprom = sext i32 %48 to i64
  %arrayidx = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom
  %49 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx, align 8, !tbaa !1
  %50 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_msgsize = getelementptr inbounds %struct.envelope, %struct.envelope* %50, i32 0, i32 9
  %51 = load i64, i64* %e_msgsize, align 8, !tbaa !89
  %52 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %call60 = call i32 @pickqdir(%struct.queuegrp* %49, i64 %51, %struct.envelope* %52)
  %53 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qdir61 = getelementptr inbounds %struct.envelope, %struct.envelope* %53, i32 0, i32 27
  store i32 %call60, i32* %e_qdir61, align 4, !tbaa !19
  %54 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qdir62 = getelementptr inbounds %struct.envelope, %struct.envelope* %54, i32 0, i32 27
  %55 = load i32, i32* %e_qdir62, align 4, !tbaa !19
  %cmp63 = icmp eq i32 %55, -1
  br i1 %cmp63, label %if.then.65, label %if.end.72

if.then.65:                                       ; preds = %if.end.58
  %56 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qgrp66 = getelementptr inbounds %struct.envelope, %struct.envelope* %56, i32 0, i32 26
  store i32 -1, i32* %e_qgrp66, align 4, !tbaa !18
  %57 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_flags = getelementptr inbounds %struct.envelope, %struct.envelope* %57, i32 0, i32 11
  %58 = load i64, i64* %e_flags, align 8, !tbaa !15
  %and = and i64 %58, 32
  %cmp67 = icmp ne i64 %and, 0
  br i1 %cmp67, label %if.end.70, label %if.then.69

if.then.69:                                       ; preds = %if.then.65
  call void (i8*, ...) @usrerr(i8* getelementptr inbounds ([51 x i8], [51 x i8]* @.str.148, i32 0, i32 0))
  br label %if.end.70

if.end.70:                                        ; preds = %if.then.69, %if.then.65
  %59 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_flags71 = getelementptr inbounds %struct.envelope, %struct.envelope* %59, i32 0, i32 11
  %60 = load i64, i64* %e_flags71, align 8, !tbaa !15
  %or = or i64 %60, 32
  store i64 %or, i64* %e_flags71, align 8, !tbaa !15
  store i32 0, i32* %retval
  br label %return

if.end.72:                                        ; preds = %if.end.58
  %61 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 41), align 1, !tbaa !17
  %conv73 = zext i8 %61 to i32
  %cmp74 = icmp sge i32 %conv73, 3
  br i1 %cmp74, label %land.lhs.true.76, label %if.end.82

land.lhs.true.76:                                 ; preds = %if.end.72
  %62 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool77 = icmp ne i32 %62, 0
  br i1 %tobool77, label %if.end.82, label %if.then.78

if.then.78:                                       ; preds = %land.lhs.true.76
  %63 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qgrp79 = getelementptr inbounds %struct.envelope, %struct.envelope* %63, i32 0, i32 26
  %64 = load i32, i32* %e_qgrp79, align 4, !tbaa !18
  %65 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qdir80 = getelementptr inbounds %struct.envelope, %struct.envelope* %65, i32 0, i32 27
  %66 = load i32, i32* %e_qdir80, align 4, !tbaa !19
  %call81 = call i8* @qid_printqueue(i32 %64, i32 %66)
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.149, i32 0, i32 0), i8* %call81)
  br label %if.end.82

if.end.82:                                        ; preds = %if.then.78, %land.lhs.true.76, %if.end.72
  %67 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_xfqgrp = getelementptr inbounds %struct.envelope, %struct.envelope* %67, i32 0, i32 30
  %68 = load i32, i32* %e_xfqgrp, align 4, !tbaa !80
  %cmp83 = icmp eq i32 %68, -1
  br i1 %cmp83, label %if.then.87, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end.82
  %69 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_xfqdir = getelementptr inbounds %struct.envelope, %struct.envelope* %69, i32 0, i32 31
  %70 = load i32, i32* %e_xfqdir, align 4, !tbaa !81
  %cmp85 = icmp eq i32 %70, -1
  br i1 %cmp85, label %if.then.87, label %if.end.92

if.then.87:                                       ; preds = %lor.lhs.false, %if.end.82
  %71 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qgrp88 = getelementptr inbounds %struct.envelope, %struct.envelope* %71, i32 0, i32 26
  %72 = load i32, i32* %e_qgrp88, align 4, !tbaa !18
  %73 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_xfqgrp89 = getelementptr inbounds %struct.envelope, %struct.envelope* %73, i32 0, i32 30
  store i32 %72, i32* %e_xfqgrp89, align 4, !tbaa !80
  %74 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qdir90 = getelementptr inbounds %struct.envelope, %struct.envelope* %74, i32 0, i32 27
  %75 = load i32, i32* %e_qdir90, align 4, !tbaa !19
  %76 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_xfqdir91 = getelementptr inbounds %struct.envelope, %struct.envelope* %76, i32 0, i32 31
  store i32 %75, i32* %e_xfqdir91, align 4, !tbaa !81
  br label %if.end.92

if.end.92:                                        ; preds = %if.then.87, %lor.lhs.false
  %77 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qdir93 = getelementptr inbounds %struct.envelope, %struct.envelope* %77, i32 0, i32 27
  %78 = load i32, i32* %e_qdir93, align 4, !tbaa !19
  %79 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_dfqdir94 = getelementptr inbounds %struct.envelope, %struct.envelope* %79, i32 0, i32 29
  store i32 %78, i32* %e_dfqdir94, align 4, !tbaa !37
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %if.end.92, %if.end.70, %if.end.57
  %80 = load i32, i32* %retval
  ret i32 %80
}

; Function Attrs: noreturn
declare void @sm_abort(i8*, ...) #9

; Function Attrs: nounwind uwtable
define void @init_qid_alg() #0 {
entry:
  store i64 0, i64* @LastQueueTime, align 8, !tbaa !92
  store i32 -1, i32* @LastQueuePid, align 4, !tbaa !5
  ret void
}

; Function Attrs: nounwind
declare %struct.tm* @gmtime(i64*) #3

declare i32 @sm_snprintf(i8*, i64, i8*, ...) #2

declare i8* @sm_rpool_strdup_x(%struct.SM_RPOOL_T*, i8*) #2

; Function Attrs: nounwind uwtable
define void @sync_queue_time() #0 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define void @unlockqueue(%struct.envelope* %e) #0 {
entry:
  %e.addr = alloca %struct.envelope*, align 8
  store %struct.envelope* %e, %struct.envelope** %e.addr, align 8, !tbaa !1
  %0 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 51), align 1, !tbaa !17
  %conv = zext i8 %0 to i32
  %cmp = icmp sge i32 %conv, 4
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %2 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id = getelementptr inbounds %struct.envelope, %struct.envelope* %2, i32 0, i32 25
  %3 = load i8*, i8** %e_id, align 8, !tbaa !7
  %cmp2 = icmp eq i8* %3, null
  br i1 %cmp2, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  br label %cond.end

cond.false:                                       ; preds = %if.then
  %4 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id4 = getelementptr inbounds %struct.envelope, %struct.envelope* %4, i32 0, i32 25
  %5 = load i8*, i8** %e_id4, align 8, !tbaa !7
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ getelementptr inbounds ([8 x i8], [8 x i8]* @.str.140, i32 0, i32 0), %cond.true ], [ %5, %cond.false ]
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.139, i32 0, i32 0), i8* %cond)
  br label %if.end

if.end:                                           ; preds = %cond.end, %land.lhs.true, %entry
  %6 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_lockfp = getelementptr inbounds %struct.envelope, %struct.envelope* %6, i32 0, i32 33
  %7 = load %struct.sm_file*, %struct.sm_file** %e_lockfp, align 8, !tbaa !16
  %cmp5 = icmp ne %struct.sm_file* %7, null
  br i1 %cmp5, label %if.then.7, label %if.end.9

if.then.7:                                        ; preds = %if.end
  %8 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_lockfp8 = getelementptr inbounds %struct.envelope, %struct.envelope* %8, i32 0, i32 33
  %9 = load %struct.sm_file*, %struct.sm_file** %e_lockfp8, align 8, !tbaa !16
  %call = call i32 @sm_io_close(%struct.sm_file* %9, i32 -2)
  br label %if.end.9

if.end.9:                                         ; preds = %if.then.7, %if.end
  %10 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_lockfp10 = getelementptr inbounds %struct.envelope, %struct.envelope* %10, i32 0, i32 33
  store %struct.sm_file* null, %struct.sm_file** %e_lockfp10, align 8, !tbaa !16
  %11 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id11 = getelementptr inbounds %struct.envelope, %struct.envelope* %11, i32 0, i32 25
  %12 = load i8*, i8** %e_id11, align 8, !tbaa !7
  %cmp12 = icmp eq i8* %12, null
  br i1 %cmp12, label %if.then.14, label %if.end.15

if.then.14:                                       ; preds = %if.end.9
  br label %if.end.29

if.end.15:                                        ; preds = %if.end.9
  %13 = load i32, i32* @LogLevel, align 4, !tbaa !5
  %cmp16 = icmp sgt i32 %13, 87
  br i1 %cmp16, label %if.then.18, label %if.end.20

if.then.18:                                       ; preds = %if.end.15
  %14 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id19 = getelementptr inbounds %struct.envelope, %struct.envelope* %14, i32 0, i32 25
  %15 = load i8*, i8** %e_id19, align 8, !tbaa !7
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 7, i8* %15, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.141, i32 0, i32 0))
  br label %if.end.20

if.end.20:                                        ; preds = %if.then.18, %if.end.15
  %16 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 51), align 1, !tbaa !17
  %conv21 = zext i8 %16 to i32
  %cmp22 = icmp sge i32 %conv21, 104
  br i1 %cmp22, label %land.lhs.true.24, label %if.then.26

land.lhs.true.24:                                 ; preds = %if.end.20
  %17 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool25 = icmp ne i32 %17, 0
  br i1 %tobool25, label %if.then.26, label %if.end.29

if.then.26:                                       ; preds = %land.lhs.true.24, %if.end.20
  %18 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %call27 = call i8* @queuename(%struct.envelope* %18, i32 120)
  %call28 = call i32 @xunlink(i8* %call27)
  br label %if.end.29

if.end.29:                                        ; preds = %if.then.14, %if.then.26, %land.lhs.true.24
  ret void
}

declare i32 @xunlink(i8*) #2

; Function Attrs: nounwind uwtable
define void @loseqfile(%struct.envelope* %e, i8* %why) #0 {
entry:
  %e.addr = alloca %struct.envelope*, align 8
  %why.addr = alloca i8*, align 8
  %loseit = alloca i32, align 4
  %p = alloca i8*, align 8
  %buf = alloca [4096 x i8], align 16
  %cleanup.dest.slot = alloca i32
  store %struct.envelope* %e, %struct.envelope** %e.addr, align 8, !tbaa !1
  store i8* %why, i8** %why.addr, align 8, !tbaa !1
  %0 = bitcast i32* %loseit to i8*
  call void @llvm.lifetime.start(i64 4, i8* %0) #1
  store i32 1, i32* %loseit, align 4, !tbaa !5
  %1 = bitcast i8** %p to i8*
  call void @llvm.lifetime.start(i64 8, i8* %1) #1
  %2 = bitcast [4096 x i8]* %buf to i8*
  call void @llvm.lifetime.start(i64 4096, i8* %2) #1
  %3 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %cmp = icmp eq %struct.envelope* %3, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %4 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id = getelementptr inbounds %struct.envelope, %struct.envelope* %4, i32 0, i32 25
  %5 = load i8*, i8** %e_id, align 8, !tbaa !7
  %cmp1 = icmp eq i8* %5, null
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end:                                           ; preds = %lor.lhs.false
  %6 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %call = call i8* @queuename(%struct.envelope* %6, i32 63)
  store i8* %call, i8** %p, align 8, !tbaa !1
  %arraydecay = getelementptr inbounds [4096 x i8], [4096 x i8]* %buf, i32 0, i32 0
  %7 = load i8*, i8** %p, align 8, !tbaa !1
  %call2 = call i64 @sm_strlcpy(i8* %arraydecay, i8* %7, i64 4096)
  %cmp3 = icmp uge i64 %call2, 4096
  br i1 %cmp3, label %if.then.4, label %if.end.5

if.then.4:                                        ; preds = %if.end
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.5:                                         ; preds = %if.end
  %8 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_flags = getelementptr inbounds %struct.envelope, %struct.envelope* %8, i32 0, i32 11
  %9 = load i64, i64* %e_flags, align 8, !tbaa !15
  %and = and i64 %9, 2
  %cmp6 = icmp ne i64 %and, 0
  br i1 %cmp6, label %if.else, label %if.then.7

if.then.7:                                        ; preds = %if.end.5
  %10 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  call void @queueup(%struct.envelope* %10, i32 0, i32 1)
  br label %if.end.11

if.else:                                          ; preds = %if.end.5
  %11 = load i32, i32* @QueueMode, align 4, !tbaa !5
  %cmp8 = icmp eq i32 %11, 76
  br i1 %cmp8, label %if.then.9, label %if.end.10

if.then.9:                                        ; preds = %if.else
  store i32 0, i32* %loseit, align 4, !tbaa !5
  br label %if.end.10

if.end.10:                                        ; preds = %if.then.9, %if.else
  br label %if.end.11

if.end.11:                                        ; preds = %if.end.10, %if.then.7
  %12 = load i32, i32* %loseit, align 4, !tbaa !5
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.then.12, label %if.end.28

if.then.12:                                       ; preds = %if.end.11
  %13 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %call13 = call i8* @queuename(%struct.envelope* %13, i32 81)
  store i8* %call13, i8** %p, align 8, !tbaa !1
  %arraydecay14 = getelementptr inbounds [4096 x i8], [4096 x i8]* %buf, i32 0, i32 0
  %14 = load i8*, i8** %p, align 8, !tbaa !1
  %call15 = call i32 @rename(i8* %arraydecay14, i8* %14) #1
  %cmp16 = icmp slt i32 %call15, 0
  br i1 %cmp16, label %if.then.17, label %if.else.20

if.then.17:                                       ; preds = %if.then.12
  %arraydecay18 = getelementptr inbounds [4096 x i8], [4096 x i8]* %buf, i32 0, i32 0
  %15 = load i8*, i8** %p, align 8, !tbaa !1
  %call19 = call i32 @geteuid() #1
  %conv = zext i32 %call19 to i64
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.55, i32 0, i32 0), i8* %arraydecay18, i8* %15, i64 %conv)
  br label %if.end.27

if.else.20:                                       ; preds = %if.then.12
  %16 = load i32, i32* @LogLevel, align 4, !tbaa !5
  %cmp21 = icmp sgt i32 %16, 0
  br i1 %cmp21, label %if.then.23, label %if.end.26

if.then.23:                                       ; preds = %if.else.20
  %17 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id24 = getelementptr inbounds %struct.envelope, %struct.envelope* %17, i32 0, i32 25
  %18 = load i8*, i8** %e_id24, align 8, !tbaa !7
  %arraydecay25 = getelementptr inbounds [4096 x i8], [4096 x i8]* %buf, i32 0, i32 0
  %19 = load i8*, i8** %why.addr, align 8, !tbaa !1
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 1, i8* %18, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.142, i32 0, i32 0), i8* %arraydecay25, i8* %19)
  br label %if.end.26

if.end.26:                                        ; preds = %if.then.23, %if.else.20
  br label %if.end.27

if.end.27:                                        ; preds = %if.end.26, %if.then.17
  br label %if.end.28

if.end.28:                                        ; preds = %if.end.27, %if.end.11
  %20 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_dfp = getelementptr inbounds %struct.envelope, %struct.envelope* %20, i32 0, i32 24
  %21 = load %struct.sm_file*, %struct.sm_file** %e_dfp, align 8, !tbaa !21
  %cmp29 = icmp ne %struct.sm_file* %21, null
  br i1 %cmp29, label %if.then.31, label %if.end.35

if.then.31:                                       ; preds = %if.end.28
  %22 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_dfp32 = getelementptr inbounds %struct.envelope, %struct.envelope* %22, i32 0, i32 24
  %23 = load %struct.sm_file*, %struct.sm_file** %e_dfp32, align 8, !tbaa !21
  %call33 = call i32 @sm_io_close(%struct.sm_file* %23, i32 -2)
  %24 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_dfp34 = getelementptr inbounds %struct.envelope, %struct.envelope* %24, i32 0, i32 24
  store %struct.sm_file* null, %struct.sm_file** %e_dfp34, align 8, !tbaa !21
  br label %if.end.35

if.end.35:                                        ; preds = %if.then.31, %if.end.28
  %25 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_flags36 = getelementptr inbounds %struct.envelope, %struct.envelope* %25, i32 0, i32 11
  %26 = load i64, i64* %e_flags36, align 8, !tbaa !15
  %and37 = and i64 %26, -2097153
  store i64 %and37, i64* %e_flags36, align 8, !tbaa !15
  store i32 0, i32* %cleanup.dest.slot
  br label %cleanup

cleanup:                                          ; preds = %if.end.35, %if.then.4, %if.then
  %27 = bitcast [4096 x i8]* %buf to i8*
  call void @llvm.lifetime.end(i64 4096, i8* %27) #1
  %28 = bitcast i8** %p to i8*
  call void @llvm.lifetime.end(i64 8, i8* %28) #1
  %29 = bitcast i32* %loseit to i8*
  call void @llvm.lifetime.end(i64 4, i8* %29) #1
  %cleanup.dest = load i32, i32* %cleanup.dest.slot
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %cleanup.cont
    i32 1, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup, %cleanup
  ret void

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: nounwind uwtable
define i32 @name2qid(i8* %queuename) #0 {
entry:
  %retval = alloca i32, align 4
  %queuename.addr = alloca i8*, align 8
  %s = alloca %struct.symtab*, align 8
  %cleanup.dest.slot = alloca i32
  store i8* %queuename, i8** %queuename.addr, align 8, !tbaa !1
  %0 = bitcast %struct.symtab** %s to i8*
  call void @llvm.lifetime.start(i64 8, i8* %0) #1
  %1 = load i8*, i8** %queuename.addr, align 8, !tbaa !1
  %call = call %struct.symtab* @stab(i8* %1, i32 15, i32 0)
  store %struct.symtab* %call, %struct.symtab** %s, align 8, !tbaa !1
  %2 = load %struct.symtab*, %struct.symtab** %s, align 8, !tbaa !1
  %cmp = icmp eq %struct.symtab* %2, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -1, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end:                                           ; preds = %entry
  %3 = load %struct.symtab*, %struct.symtab** %s, align 8, !tbaa !1
  %s_value = getelementptr inbounds %struct.symtab, %struct.symtab* %3, i32 0, i32 3
  %sv_queue = bitcast %union.anon* %s_value to %struct.queuegrp**
  %4 = load %struct.queuegrp*, %struct.queuegrp** %sv_queue, align 8, !tbaa !1
  %qg_index = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %4, i32 0, i32 2
  %5 = load i16, i16* %qg_index, align 2, !tbaa !112
  %conv = sext i16 %5 to i32
  store i32 %conv, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

cleanup:                                          ; preds = %if.end, %if.then
  %6 = bitcast %struct.symtab** %s to i8*
  call void @llvm.lifetime.end(i64 8, i8* %6) #1
  %7 = load i32, i32* %retval
  ret i32 %7
}

declare %struct.symtab* @stab(i8*, i32, i32) #2

; Function Attrs: nounwind
declare i32 @strcmp(i8*, i8*) #3

; Function Attrs: nounwind uwtable
define i32 @pickqdir(%struct.queuegrp* %qg, i64 %fsize, %struct.envelope* %e) #0 {
entry:
  %retval = alloca i32, align 4
  %qg.addr = alloca %struct.queuegrp*, align 8
  %fsize.addr = alloca i64, align 8
  %e.addr = alloca %struct.envelope*, align 8
  %qdir = alloca i32, align 4
  %i = alloca i32, align 4
  %avail = alloca i64, align 8
  %cleanup.dest.slot = alloca i32
  %qp = alloca %struct.qpaths_s*, align 8
  %needed = alloca i64, align 8
  %fsavail = alloca i64, align 8
  %blksize = alloca i64, align 8
  store %struct.queuegrp* %qg, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  store i64 %fsize, i64* %fsize.addr, align 8, !tbaa !92
  store %struct.envelope* %e, %struct.envelope** %e.addr, align 8, !tbaa !1
  %0 = bitcast i32* %qdir to i8*
  call void @llvm.lifetime.start(i64 4, i8* %0) #1
  %1 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start(i64 4, i8* %1) #1
  %2 = bitcast i64* %avail to i8*
  call void @llvm.lifetime.start(i64 8, i8* %2) #1
  store i64 0, i64* %avail, align 8, !tbaa !92
  %3 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_numqueues = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %3, i32 0, i32 4
  %4 = load i32, i32* %qg_numqueues, align 4, !tbaa !82
  %cmp = icmp sle i32 %4, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 0, i32* %qdir, align 4, !tbaa !5
  br label %if.end

if.else:                                          ; preds = %entry
  %call = call i64 @random() #1
  %5 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_numqueues1 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %5, i32 0, i32 4
  %6 = load i32, i32* %qg_numqueues1, align 4, !tbaa !82
  %conv = sext i32 %6 to i64
  %rem = srem i64 %call, %conv
  %conv2 = trunc i64 %rem to i32
  store i32 %conv2, i32* %qdir, align 4, !tbaa !5
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %7 = load i64, i64* @MinBlocksFree, align 8, !tbaa !92
  %cmp3 = icmp sle i64 %7, 0
  br i1 %cmp3, label %land.lhs.true, label %if.end.8

land.lhs.true:                                    ; preds = %if.end
  %8 = load i64, i64* %fsize.addr, align 8, !tbaa !92
  %cmp5 = icmp sle i64 %8, 0
  br i1 %cmp5, label %if.then.7, label %if.end.8

if.then.7:                                        ; preds = %land.lhs.true
  %9 = load i32, i32* %qdir, align 4, !tbaa !5
  store i32 %9, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup.74

if.end.8:                                         ; preds = %land.lhs.true, %if.end
  %10 = load i32, i32* %qdir, align 4, !tbaa !5
  store i32 %10, i32* %i, align 4, !tbaa !5
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.end.8
  %11 = bitcast %struct.qpaths_s** %qp to i8*
  call void @llvm.lifetime.start(i64 8, i8* %11) #1
  %12 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom = sext i32 %12 to i64
  %13 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qpaths = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %13, i32 0, i32 6
  %14 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths, align 8, !tbaa !38
  %arrayidx = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %14, i64 %idxprom
  store %struct.qpaths_s* %arrayidx, %struct.qpaths_s** %qp, align 8, !tbaa !1
  %15 = bitcast i64* %needed to i8*
  call void @llvm.lifetime.start(i64 8, i8* %15) #1
  store i64 0, i64* %needed, align 8, !tbaa !92
  %16 = bitcast i64* %fsavail to i8*
  call void @llvm.lifetime.start(i64 8, i8* %16) #1
  store i64 0, i64* %fsavail, align 8, !tbaa !92
  %17 = load i64, i64* %fsize.addr, align 8, !tbaa !92
  %cmp9 = icmp sgt i64 %17, 0
  br i1 %cmp9, label %if.then.11, label %if.end.23

if.then.11:                                       ; preds = %do.body
  %18 = load i64, i64* %fsize.addr, align 8, !tbaa !92
  %19 = load %struct.qpaths_s*, %struct.qpaths_s** %qp, align 8, !tbaa !1
  %qp_fsysidx = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %19, i32 0, i32 2
  %20 = load i16, i16* %qp_fsysidx, align 2, !tbaa !87
  %idxprom12 = sext i16 %20 to i64
  %21 = load %struct.filesys_shared*, %struct.filesys_shared** @PtrFileSys, align 8, !tbaa !1
  %arrayidx13 = getelementptr inbounds %struct.filesys_shared, %struct.filesys_shared* %21, i64 %idxprom12
  %fs_blksize = getelementptr inbounds %struct.filesys_shared, %struct.filesys_shared* %arrayidx13, i32 0, i32 2
  %22 = load i64, i64* %fs_blksize, align 8, !tbaa !90
  %div = sdiv i64 %18, %22
  %23 = load i64, i64* %fsize.addr, align 8, !tbaa !92
  %24 = load %struct.qpaths_s*, %struct.qpaths_s** %qp, align 8, !tbaa !1
  %qp_fsysidx14 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %24, i32 0, i32 2
  %25 = load i16, i16* %qp_fsysidx14, align 2, !tbaa !87
  %idxprom15 = sext i16 %25 to i64
  %26 = load %struct.filesys_shared*, %struct.filesys_shared** @PtrFileSys, align 8, !tbaa !1
  %arrayidx16 = getelementptr inbounds %struct.filesys_shared, %struct.filesys_shared* %26, i64 %idxprom15
  %fs_blksize17 = getelementptr inbounds %struct.filesys_shared, %struct.filesys_shared* %arrayidx16, i32 0, i32 2
  %27 = load i64, i64* %fs_blksize17, align 8, !tbaa !90
  %rem18 = srem i64 %23, %27
  %cmp19 = icmp sgt i64 %rem18, 0
  %cond = select i1 %cmp19, i32 1, i32 0
  %conv21 = sext i32 %cond to i64
  %add = add nsw i64 %div, %conv21
  %28 = load i64, i64* %needed, align 8, !tbaa !92
  %add22 = add nsw i64 %28, %add
  store i64 %add22, i64* %needed, align 8, !tbaa !92
  br label %if.end.23

if.end.23:                                        ; preds = %if.then.11, %do.body
  %29 = load i64, i64* @MinBlocksFree, align 8, !tbaa !92
  %cmp24 = icmp sgt i64 %29, 0
  br i1 %cmp24, label %if.then.26, label %if.end.28

if.then.26:                                       ; preds = %if.end.23
  %30 = load i64, i64* @MinBlocksFree, align 8, !tbaa !92
  %31 = load i64, i64* %needed, align 8, !tbaa !92
  %add27 = add nsw i64 %31, %30
  store i64 %add27, i64* %needed, align 8, !tbaa !92
  br label %if.end.28

if.end.28:                                        ; preds = %if.then.26, %if.end.23
  %32 = load %struct.qpaths_s*, %struct.qpaths_s** %qp, align 8, !tbaa !1
  %qp_fsysidx29 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %32, i32 0, i32 2
  %33 = load i16, i16* %qp_fsysidx29, align 2, !tbaa !87
  %idxprom30 = sext i16 %33 to i64
  %34 = load %struct.filesys_shared*, %struct.filesys_shared** @PtrFileSys, align 8, !tbaa !1
  %arrayidx31 = getelementptr inbounds %struct.filesys_shared, %struct.filesys_shared* %34, i64 %idxprom30
  %fs_avail = getelementptr inbounds %struct.filesys_shared, %struct.filesys_shared* %arrayidx31, i32 0, i32 1
  %35 = load i64, i64* %fs_avail, align 8, !tbaa !93
  store i64 %35, i64* %fsavail, align 8, !tbaa !92
  %36 = load i64, i64* %fsavail, align 8, !tbaa !92
  %cmp32 = icmp sle i64 %36, 0
  br i1 %cmp32, label %if.then.34, label %if.end.43

if.then.34:                                       ; preds = %if.end.28
  %37 = bitcast i64* %blksize to i8*
  call void @llvm.lifetime.start(i64 8, i8* %37) #1
  %38 = load %struct.qpaths_s*, %struct.qpaths_s** %qp, align 8, !tbaa !1
  %qp_fsysidx35 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %38, i32 0, i32 2
  %39 = load i16, i16* %qp_fsysidx35, align 2, !tbaa !87
  %idxprom36 = sext i16 %39 to i64
  %arrayidx37 = getelementptr inbounds [256 x i8*], [256 x i8*]* @FSPath, i32 0, i64 %idxprom36
  %40 = load i8*, i8** %arrayidx37, align 8, !tbaa !1
  %call38 = call i64 @freediskspace(i8* %40, i64* %blksize)
  store i64 %call38, i64* %fsavail, align 8, !tbaa !92
  %41 = load i64, i64* %fsavail, align 8, !tbaa !92
  %cmp39 = icmp slt i64 %41, 0
  br i1 %cmp39, label %if.then.41, label %if.end.42

if.then.41:                                       ; preds = %if.then.34
  store i64 0, i64* %fsavail, align 8, !tbaa !92
  br label %if.end.42

if.end.42:                                        ; preds = %if.then.41, %if.then.34
  %42 = bitcast i64* %blksize to i8*
  call void @llvm.lifetime.end(i64 8, i8* %42) #1
  br label %if.end.43

if.end.43:                                        ; preds = %if.end.42, %if.end.28
  %43 = load i64, i64* %needed, align 8, !tbaa !92
  %44 = load i64, i64* %fsavail, align 8, !tbaa !92
  %cmp44 = icmp sle i64 %43, %44
  br i1 %cmp44, label %if.then.46, label %if.end.47

if.then.46:                                       ; preds = %if.end.43
  %45 = load i32, i32* %i, align 4, !tbaa !5
  store i32 %45, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.47:                                        ; preds = %if.end.43
  %46 = load i64, i64* %avail, align 8, !tbaa !92
  %47 = load i64, i64* %fsavail, align 8, !tbaa !92
  %cmp48 = icmp slt i64 %46, %47
  br i1 %cmp48, label %if.then.50, label %if.end.51

if.then.50:                                       ; preds = %if.end.47
  %48 = load i64, i64* %fsavail, align 8, !tbaa !92
  store i64 %48, i64* %avail, align 8, !tbaa !92
  br label %if.end.51

if.end.51:                                        ; preds = %if.then.50, %if.end.47
  %49 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_numqueues52 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %49, i32 0, i32 4
  %50 = load i32, i32* %qg_numqueues52, align 4, !tbaa !82
  %cmp53 = icmp sgt i32 %50, 0
  br i1 %cmp53, label %if.then.55, label %if.end.59

if.then.55:                                       ; preds = %if.end.51
  %51 = load i32, i32* %i, align 4, !tbaa !5
  %add56 = add nsw i32 %51, 1
  %52 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_numqueues57 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %52, i32 0, i32 4
  %53 = load i32, i32* %qg_numqueues57, align 4, !tbaa !82
  %rem58 = srem i32 %add56, %53
  store i32 %rem58, i32* %i, align 4, !tbaa !5
  br label %if.end.59

if.end.59:                                        ; preds = %if.then.55, %if.end.51
  store i32 0, i32* %cleanup.dest.slot
  br label %cleanup

cleanup:                                          ; preds = %if.end.59, %if.then.46
  %54 = bitcast i64* %fsavail to i8*
  call void @llvm.lifetime.end(i64 8, i8* %54) #1
  %55 = bitcast i64* %needed to i8*
  call void @llvm.lifetime.end(i64 8, i8* %55) #1
  %56 = bitcast %struct.qpaths_s** %qp to i8*
  call void @llvm.lifetime.end(i64 8, i8* %56) #1
  %cleanup.dest = load i32, i32* %cleanup.dest.slot
  switch i32 %cleanup.dest, label %cleanup.74 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %do.cond

do.cond:                                          ; preds = %cleanup.cont
  %57 = load i32, i32* %i, align 4, !tbaa !5
  %58 = load i32, i32* %qdir, align 4, !tbaa !5
  %cmp62 = icmp ne i32 %57, %58
  br i1 %cmp62, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  %59 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %cmp64 = icmp ne %struct.envelope* %59, null
  br i1 %cmp64, label %land.lhs.true.66, label %if.end.73

land.lhs.true.66:                                 ; preds = %do.end
  %60 = load i32, i32* @LogLevel, align 4, !tbaa !5
  %cmp67 = icmp sgt i32 %60, 0
  br i1 %cmp67, label %if.then.69, label %if.end.73

if.then.69:                                       ; preds = %land.lhs.true.66
  %61 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id = getelementptr inbounds %struct.envelope, %struct.envelope* %61, i32 0, i32 25
  %62 = load i8*, i8** %e_id, align 8, !tbaa !7
  %63 = load i8*, i8** @CurHostName, align 8, !tbaa !1
  %cmp70 = icmp eq i8* %63, null
  br i1 %cmp70, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.69
  br label %cond.end

cond.false:                                       ; preds = %if.then.69
  %64 = load i8*, i8** @CurHostName, align 8, !tbaa !1
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond72 = phi i8* [ getelementptr inbounds ([12 x i8], [12 x i8]* @.str.145, i32 0, i32 0), %cond.true ], [ %64, %cond.false ]
  %65 = load i64, i64* %fsize.addr, align 8, !tbaa !92
  %66 = load i64, i64* @MinBlocksFree, align 8, !tbaa !92
  %67 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qdir = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %67, i32 0, i32 1
  %68 = load i8*, i8** %qg_qdir, align 8, !tbaa !94
  %69 = load i64, i64* %avail, align 8, !tbaa !92
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 1, i8* %62, i8* getelementptr inbounds ([69 x i8], [69 x i8]* @.str.144, i32 0, i32 0), i8* %cond72, i64 %65, i64 %66, i8* %68, i64 %69)
  br label %if.end.73

if.end.73:                                        ; preds = %cond.end, %land.lhs.true.66, %do.end
  store i32 -1, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup.74

cleanup.74:                                       ; preds = %if.end.73, %cleanup, %if.then.7
  %70 = bitcast i64* %avail to i8*
  call void @llvm.lifetime.end(i64 8, i8* %70) #1
  %71 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end(i64 4, i8* %71) #1
  %72 = bitcast i32* %qdir to i8*
  call void @llvm.lifetime.end(i64 4, i8* %72) #1
  %73 = load i32, i32* %retval
  ret i32 %73
}

declare i64 @freediskspace(i8*, i64*) #2

; Function Attrs: nounwind uwtable
define void @filesys_update() #0 {
entry:
  %i = alloca i32, align 4
  %avail = alloca i64, align 8
  %blksize = alloca i64, align 8
  %now = alloca i64, align 8
  %cleanup.dest.slot = alloca i32
  %fs = alloca %struct.filesys_shared*, align 8
  %0 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start(i64 4, i8* %0) #1
  %1 = bitcast i64* %avail to i8*
  call void @llvm.lifetime.start(i64 8, i8* %1) #1
  %2 = bitcast i64* %blksize to i8*
  call void @llvm.lifetime.start(i64 8, i8* %2) #1
  %3 = bitcast i64* %now to i8*
  call void @llvm.lifetime.start(i64 8, i8* %3) #1
  %4 = load i32, i32* @ShmId, align 4, !tbaa !5
  %cmp = icmp ne i32 %4, -2
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %5 = load i32, i32* @DaemonPid, align 4, !tbaa !5
  %6 = load i32, i32* @CurrentPid, align 4, !tbaa !5
  %cmp1 = icmp ne i32 %5, %6
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end:                                           ; preds = %land.lhs.true, %entry
  %call = call i64 @curtime()
  store i64 %call, i64* %now, align 8, !tbaa !92
  %7 = load i64, i64* %now, align 8, !tbaa !92
  %8 = load i64, i64* @filesys_update.nextupdate, align 8, !tbaa !92
  %cmp2 = icmp slt i64 %7, %8
  br i1 %cmp2, label %if.then.3, label %if.end.4

if.then.3:                                        ; preds = %if.end
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.4:                                         ; preds = %if.end
  %9 = load i64, i64* %now, align 8, !tbaa !92
  %add = add nsw i64 %9, 300
  store i64 %add, i64* @filesys_update.nextupdate, align 8, !tbaa !92
  store i32 0, i32* %i, align 4, !tbaa !5
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end.4
  %10 = load i32, i32* %i, align 4, !tbaa !5
  %11 = load i32*, i32** @PNumFileSys, align 8, !tbaa !1
  %12 = load i32, i32* %11, align 4, !tbaa !5
  %cmp5 = icmp slt i32 %10, %12
  br i1 %cmp5, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %13 = bitcast %struct.filesys_shared** %fs to i8*
  call void @llvm.lifetime.start(i64 8, i8* %13) #1
  %14 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom = sext i32 %14 to i64
  %15 = load %struct.filesys_shared*, %struct.filesys_shared** @PtrFileSys, align 8, !tbaa !1
  %arrayidx = getelementptr inbounds %struct.filesys_shared, %struct.filesys_shared* %15, i64 %idxprom
  store %struct.filesys_shared* %arrayidx, %struct.filesys_shared** %fs, align 8, !tbaa !1
  %16 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom6 = sext i32 %16 to i64
  %arrayidx7 = getelementptr inbounds [256 x i8*], [256 x i8*]* @FSPath, i32 0, i64 %idxprom6
  %17 = load i8*, i8** %arrayidx7, align 8, !tbaa !1
  %call8 = call i64 @freediskspace(i8* %17, i64* %blksize)
  store i64 %call8, i64* %avail, align 8, !tbaa !92
  %18 = load i64, i64* %avail, align 8, !tbaa !92
  %cmp9 = icmp slt i64 %18, 0
  br i1 %cmp9, label %if.then.11, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %19 = load i64, i64* %blksize, align 8, !tbaa !92
  %cmp10 = icmp sle i64 %19, 0
  br i1 %cmp10, label %if.then.11, label %if.else

if.then.11:                                       ; preds = %lor.lhs.false, %for.body
  %20 = load i32, i32* @LogLevel, align 4, !tbaa !5
  %cmp12 = icmp sgt i32 %20, 5
  br i1 %cmp12, label %if.then.13, label %if.end.18

if.then.13:                                       ; preds = %if.then.11
  %call14 = call i32* @__errno_location() #11
  %21 = load i32, i32* %call14, align 4, !tbaa !5
  %call15 = call i8* @sm_errstring(i32 %21)
  %22 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom16 = sext i32 %22 to i64
  %arrayidx17 = getelementptr inbounds [256 x i8*], [256 x i8*]* @FSPath, i32 0, i64 %idxprom16
  %23 = load i8*, i8** %arrayidx17, align 8, !tbaa !1
  %24 = load i64, i64* %avail, align 8, !tbaa !92
  %25 = load i64, i64* %blksize, align 8, !tbaa !92
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 3, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0), i8* getelementptr inbounds ([59 x i8], [59 x i8]* @.str.150, i32 0, i32 0), i8* %call15, i8* %23, i64 %24, i64 %25)
  br label %if.end.18

if.end.18:                                        ; preds = %if.then.13, %if.then.11
  %26 = load %struct.filesys_shared*, %struct.filesys_shared** %fs, align 8, !tbaa !1
  %fs_avail = getelementptr inbounds %struct.filesys_shared, %struct.filesys_shared* %26, i32 0, i32 1
  store i64 0, i64* %fs_avail, align 8, !tbaa !93
  %27 = load %struct.filesys_shared*, %struct.filesys_shared** %fs, align 8, !tbaa !1
  %fs_blksize = getelementptr inbounds %struct.filesys_shared, %struct.filesys_shared* %27, i32 0, i32 2
  store i64 1024, i64* %fs_blksize, align 8, !tbaa !90
  %28 = load i64, i64* %now, align 8, !tbaa !92
  %add19 = add nsw i64 %28, 2
  store i64 %add19, i64* @filesys_update.nextupdate, align 8, !tbaa !92
  br label %if.end.22

if.else:                                          ; preds = %lor.lhs.false
  %29 = load i64, i64* %avail, align 8, !tbaa !92
  %30 = load %struct.filesys_shared*, %struct.filesys_shared** %fs, align 8, !tbaa !1
  %fs_avail20 = getelementptr inbounds %struct.filesys_shared, %struct.filesys_shared* %30, i32 0, i32 1
  store i64 %29, i64* %fs_avail20, align 8, !tbaa !93
  %31 = load i64, i64* %blksize, align 8, !tbaa !92
  %32 = load %struct.filesys_shared*, %struct.filesys_shared** %fs, align 8, !tbaa !1
  %fs_blksize21 = getelementptr inbounds %struct.filesys_shared, %struct.filesys_shared* %32, i32 0, i32 2
  store i64 %31, i64* %fs_blksize21, align 8, !tbaa !90
  br label %if.end.22

if.end.22:                                        ; preds = %if.else, %if.end.18
  %33 = bitcast %struct.filesys_shared** %fs to i8*
  call void @llvm.lifetime.end(i64 8, i8* %33) #1
  br label %for.inc

for.inc:                                          ; preds = %if.end.22
  %34 = load i32, i32* %i, align 4, !tbaa !5
  %inc = add nsw i32 %34, 1
  store i32 %inc, i32* %i, align 4, !tbaa !5
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i32 0, i32* %cleanup.dest.slot
  br label %cleanup

cleanup:                                          ; preds = %for.end, %if.then.3, %if.then
  %35 = bitcast i64* %now to i8*
  call void @llvm.lifetime.end(i64 8, i8* %35) #1
  %36 = bitcast i64* %blksize to i8*
  call void @llvm.lifetime.end(i64 8, i8* %36) #1
  %37 = bitcast i64* %avail to i8*
  call void @llvm.lifetime.end(i64 8, i8* %37) #1
  %38 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end(i64 4, i8* %38) #1
  %cleanup.dest = load i32, i32* %cleanup.dest.slot
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %cleanup.cont
    i32 1, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup, %cleanup
  ret void

unreachable:                                      ; preds = %cleanup
  unreachable
}

; Function Attrs: nounwind uwtable
define void @disk_status(%struct.sm_file* %out, i8* %prefix) #0 {
entry:
  %out.addr = alloca %struct.sm_file*, align 8
  %prefix.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %avail = alloca i64, align 8
  %blksize = alloca i64, align 8
  %free = alloca i64, align 8
  store %struct.sm_file* %out, %struct.sm_file** %out.addr, align 8, !tbaa !1
  store i8* %prefix, i8** %prefix.addr, align 8, !tbaa !1
  %0 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start(i64 4, i8* %0) #1
  %1 = bitcast i64* %avail to i8*
  call void @llvm.lifetime.start(i64 8, i8* %1) #1
  %2 = bitcast i64* %blksize to i8*
  call void @llvm.lifetime.start(i64 8, i8* %2) #1
  %3 = bitcast i64* %free to i8*
  call void @llvm.lifetime.start(i64 8, i8* %3) #1
  store i32 0, i32* %i, align 4, !tbaa !5
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %4 = load i32, i32* %i, align 4, !tbaa !5
  %5 = load i32*, i32** @PNumFileSys, align 8, !tbaa !1
  %6 = load i32, i32* %5, align 4, !tbaa !5
  %cmp = icmp slt i32 %4, %6
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom = sext i32 %7 to i64
  %arrayidx = getelementptr inbounds [256 x i8*], [256 x i8*]* @FSPath, i32 0, i64 %idxprom
  %8 = load i8*, i8** %arrayidx, align 8, !tbaa !1
  %call = call i64 @freediskspace(i8* %8, i64* %blksize)
  store i64 %call, i64* %avail, align 8, !tbaa !92
  %9 = load i64, i64* %avail, align 8, !tbaa !92
  %cmp1 = icmp sge i64 %9, 0
  br i1 %cmp1, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %for.body
  %10 = load i64, i64* %blksize, align 8, !tbaa !92
  %cmp2 = icmp sgt i64 %10, 0
  br i1 %cmp2, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %11 = load i64, i64* %avail, align 8, !tbaa !92
  %conv = sitofp i64 %11 to double
  %12 = load i64, i64* %blksize, align 8, !tbaa !92
  %conv3 = sitofp i64 %12 to double
  %div = fdiv double %conv3, 1.024000e+03
  %mul = fmul double %conv, %div
  %conv4 = fptosi double %mul to i64
  store i64 %conv4, i64* %free, align 8, !tbaa !92
  br label %if.end

if.else:                                          ; preds = %land.lhs.true, %for.body
  store i64 -1, i64* %free, align 8, !tbaa !92
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %13 = load %struct.sm_file*, %struct.sm_file** %out.addr, align 8, !tbaa !1
  %14 = load i8*, i8** %prefix.addr, align 8, !tbaa !1
  %15 = load i32, i32* %i, align 4, !tbaa !5
  %16 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom5 = sext i32 %16 to i64
  %arrayidx6 = getelementptr inbounds [256 x i8*], [256 x i8*]* @FSPath, i32 0, i64 %idxprom5
  %17 = load i8*, i8** %arrayidx6, align 8, !tbaa !1
  %18 = load i64, i64* %free, align 8, !tbaa !92
  %call7 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* %13, i32 -2, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.151, i32 0, i32 0), i8* %14, i32 %15, i8* %17, i64 %18)
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %19 = load i32, i32* %i, align 4, !tbaa !5
  %inc = add nsw i32 %19, 1
  store i32 %inc, i32* %i, align 4, !tbaa !5
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %20 = bitcast i64* %free to i8*
  call void @llvm.lifetime.end(i64 8, i8* %20) #1
  %21 = bitcast i64* %blksize to i8*
  call void @llvm.lifetime.end(i64 8, i8* %21) #1
  %22 = bitcast i64* %avail to i8*
  call void @llvm.lifetime.end(i64 8, i8* %22) #1
  %23 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end(i64 4, i8* %23) #1
  ret void
}

; Function Attrs: nounwind uwtable
define void @setup_queues(i32 %owner) #0 {
entry:
  %owner.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %qn = alloca i32, align 4
  %len = alloca i32, align 4
  %hashval = alloca i32, align 4
  %now = alloca i64, align 8
  %basedir = alloca [4096 x i8], align 16
  %st = alloca %struct.stat, align 8
  %cleanup.dest.slot = alloca i32
  %cp = alloca i8*, align 8
  %save_errno = alloca i32, align 4
  %sff = alloca i64, align 8
  store i32 %owner, i32* %owner.addr, align 4, !tbaa !5
  %0 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start(i64 4, i8* %0) #1
  %1 = bitcast i32* %qn to i8*
  call void @llvm.lifetime.start(i64 4, i8* %1) #1
  %2 = bitcast i32* %len to i8*
  call void @llvm.lifetime.start(i64 4, i8* %2) #1
  %3 = bitcast i32* %hashval to i8*
  call void @llvm.lifetime.start(i64 4, i8* %3) #1
  %4 = bitcast i64* %now to i8*
  call void @llvm.lifetime.start(i64 8, i8* %4) #1
  %5 = bitcast [4096 x i8]* %basedir to i8*
  call void @llvm.lifetime.start(i64 4096, i8* %5) #1
  %6 = bitcast %struct.stat* %st to i8*
  call void @llvm.lifetime.start(i64 144, i8* %6) #1
  store i32 0, i32* %hashval, align 4, !tbaa !5
  %call = call i32* @__errno_location() #11
  store i32 0, i32* %call, align 4, !tbaa !5
  %arraydecay = getelementptr inbounds [4096 x i8], [4096 x i8]* %basedir, i32 0, i32 0
  %7 = load i8*, i8** @QueueDir, align 8, !tbaa !1
  %call1 = call i64 @sm_strlcpy(i8* %arraydecay, i8* %7, i64 4096)
  %conv = trunc i64 %call1 to i32
  store i32 %conv, i32* %len, align 4, !tbaa !5
  %8 = load i32, i32* %len, align 4, !tbaa !5
  %conv2 = sext i32 %8 to i64
  %cmp = icmp uge i64 %conv2, 4095
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %9 = load i32, i32* %len, align 4, !tbaa !5
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.153, i32 0, i32 0), i32 %9, i32 4095)
  store i32 78, i32* @ExitStat, align 4, !tbaa !5
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup.184

if.end:                                           ; preds = %entry
  %10 = load i32, i32* %len, align 4, !tbaa !5
  %cmp4 = icmp sgt i32 %10, 0
  br i1 %cmp4, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.end
  call void @sm_abort_at(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 7076, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.154, i32 0, i32 0)) #12
  unreachable
                                                  ; No predecessors!
  br label %lor.end

lor.end:                                          ; preds = %11, %if.end
  %12 = phi i1 [ true, %if.end ], [ false, %11 ]
  %lor.ext = zext i1 %12 to i32
  %13 = load i32, i32* %len, align 4, !tbaa !5
  %sub = sub nsw i32 %13, 1
  %idxprom = sext i32 %sub to i64
  %arrayidx = getelementptr inbounds [4096 x i8], [4096 x i8]* %basedir, i32 0, i64 %idxprom
  %14 = load i8, i8* %arrayidx, align 1, !tbaa !17
  %conv6 = sext i8 %14 to i32
  %cmp7 = icmp eq i32 %conv6, 42
  br i1 %cmp7, label %if.then.9, label %if.else

if.then.9:                                        ; preds = %lor.end
  %15 = bitcast i8** %cp to i8*
  call void @llvm.lifetime.start(i64 8, i8* %15) #1
  %arraydecay10 = getelementptr inbounds [4096 x i8], [4096 x i8]* %basedir, i32 0, i32 0
  %call11 = call i8* @strrchr(i8* %arraydecay10, i32 47) #14
  store i8* %call11, i8** %cp, align 8, !tbaa !1
  %16 = load i8*, i8** %cp, align 8, !tbaa !1
  %cmp12 = icmp eq i8* %16, null
  br i1 %cmp12, label %if.then.14, label %if.end.20

if.then.14:                                       ; preds = %if.then.9
  %17 = load i8*, i8** @QueueDir, align 8, !tbaa !1
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str.155, i32 0, i32 0), i8* %17)
  %18 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 41), align 1, !tbaa !17
  %conv15 = zext i8 %18 to i32
  %cmp16 = icmp sge i32 %conv15, 2
  br i1 %cmp16, label %land.lhs.true, label %if.end.19

land.lhs.true:                                    ; preds = %if.then.14
  %19 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool = icmp ne i32 %19, 0
  br i1 %tobool, label %if.end.19, label %if.then.18

if.then.18:                                       ; preds = %land.lhs.true
  %20 = load i8*, i8** @QueueDir, align 8, !tbaa !1
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([53 x i8], [53 x i8]* @.str.156, i32 0, i32 0), i8* %20)
  br label %if.end.19

if.end.19:                                        ; preds = %if.then.18, %land.lhs.true, %if.then.14
  store i32 78, i32* @ExitStat, align 4, !tbaa !5
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.20:                                        ; preds = %if.then.9
  %21 = load i8*, i8** %cp, align 8, !tbaa !1
  %incdec.ptr = getelementptr inbounds i8, i8* %21, i32 1
  store i8* %incdec.ptr, i8** %cp, align 8, !tbaa !1
  store i8 0, i8* %incdec.ptr, align 1, !tbaa !17
  %22 = load i8*, i8** %cp, align 8, !tbaa !1
  %arraydecay21 = getelementptr inbounds [4096 x i8], [4096 x i8]* %basedir, i32 0, i32 0
  %sub.ptr.lhs.cast = ptrtoint i8* %22 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %arraydecay21 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv22 = trunc i64 %sub.ptr.sub to i32
  store i32 %conv22, i32* %len, align 4, !tbaa !5
  store i32 0, i32* %cleanup.dest.slot
  br label %cleanup

cleanup:                                          ; preds = %if.end.20, %if.end.19
  %23 = bitcast i8** %cp to i8*
  call void @llvm.lifetime.end(i64 8, i8* %23) #1
  %cleanup.dest = load i32, i32* %cleanup.dest.slot
  switch i32 %cleanup.dest, label %cleanup.184 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %if.end.35

if.else:                                          ; preds = %lor.end
  %24 = load i32, i32* %len, align 4, !tbaa !5
  %sub23 = sub nsw i32 %24, 1
  %idxprom24 = sext i32 %sub23 to i64
  %arrayidx25 = getelementptr inbounds [4096 x i8], [4096 x i8]* %basedir, i32 0, i64 %idxprom24
  %25 = load i8, i8* %arrayidx25, align 1, !tbaa !17
  %conv26 = sext i8 %25 to i32
  %cmp27 = icmp eq i32 %conv26, 47
  br i1 %cmp27, label %if.end.34, label %if.then.29

if.then.29:                                       ; preds = %if.else
  %26 = load i32, i32* %len, align 4, !tbaa !5
  %idxprom30 = sext i32 %26 to i64
  %arrayidx31 = getelementptr inbounds [4096 x i8], [4096 x i8]* %basedir, i32 0, i64 %idxprom30
  store i8 47, i8* %arrayidx31, align 1, !tbaa !17
  %27 = load i32, i32* %len, align 4, !tbaa !5
  %inc = add nsw i32 %27, 1
  store i32 %inc, i32* %len, align 4, !tbaa !5
  %idxprom32 = sext i32 %inc to i64
  %arrayidx33 = getelementptr inbounds [4096 x i8], [4096 x i8]* %basedir, i32 0, i64 %idxprom32
  store i8 0, i8* %arrayidx33, align 1, !tbaa !17
  br label %if.end.34

if.end.34:                                        ; preds = %if.then.29, %if.else
  br label %if.end.35

if.end.35:                                        ; preds = %if.end.34, %cleanup.cont
  %28 = load i32, i32* %len, align 4, !tbaa !5
  %sub36 = sub nsw i32 %28, 1
  %idxprom37 = sext i32 %sub36 to i64
  %arrayidx38 = getelementptr inbounds [4096 x i8], [4096 x i8]* %basedir, i32 0, i64 %idxprom37
  %29 = load i8, i8* %arrayidx38, align 1, !tbaa !17
  %conv39 = sext i8 %29 to i32
  %cmp40 = icmp eq i32 %conv39, 47
  br i1 %cmp40, label %lor.end.43, label %lor.rhs.42

lor.rhs.42:                                       ; preds = %if.end.35
  call void @sm_abort_at(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 7105, i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.157, i32 0, i32 0)) #12
  unreachable
                                                  ; No predecessors!
  br label %lor.end.43

lor.end.43:                                       ; preds = %30, %if.end.35
  %31 = phi i1 [ true, %if.end.35 ], [ false, %30 ]
  %lor.ext44 = zext i1 %31 to i32
  %arraydecay45 = getelementptr inbounds [4096 x i8], [4096 x i8]* %basedir, i32 0, i32 0
  %call46 = call i32 @chdir(i8* %arraydecay45) #1
  %cmp47 = icmp slt i32 %call46, 0
  br i1 %cmp47, label %if.then.49, label %if.end.68

if.then.49:                                       ; preds = %lor.end.43
  %32 = bitcast i32* %save_errno to i8*
  call void @llvm.lifetime.start(i64 4, i8* %32) #1
  %call50 = call i32* @__errno_location() #11
  %33 = load i32, i32* %call50, align 4, !tbaa !5
  store i32 %33, i32* %save_errno, align 4, !tbaa !5
  %arraydecay51 = getelementptr inbounds [4096 x i8], [4096 x i8]* %basedir, i32 0, i32 0
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.158, i32 0, i32 0), i8* %arraydecay51)
  %34 = load i32, i32* %save_errno, align 4, !tbaa !5
  %cmp52 = icmp eq i32 %34, 13
  br i1 %cmp52, label %if.then.54, label %if.end.56

if.then.54:                                       ; preds = %if.then.49
  %call55 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 2), i32 -2, i8* getelementptr inbounds ([70 x i8], [70 x i8]* @.str.159, i32 0, i32 0))
  br label %if.end.56

if.end.56:                                        ; preds = %if.then.54, %if.then.49
  %35 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 41), align 1, !tbaa !17
  %conv57 = zext i8 %35 to i32
  %cmp58 = icmp sge i32 %conv57, 2
  br i1 %cmp58, label %land.lhs.true.60, label %if.end.66

land.lhs.true.60:                                 ; preds = %if.end.56
  %36 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool61 = icmp ne i32 %36, 0
  br i1 %tobool61, label %if.end.66, label %if.then.62

if.then.62:                                       ; preds = %land.lhs.true.60
  %arraydecay63 = getelementptr inbounds [4096 x i8], [4096 x i8]* %basedir, i32 0, i32 0
  %call64 = call i32* @__errno_location() #11
  %37 = load i32, i32* %call64, align 4, !tbaa !5
  %call65 = call i8* @sm_errstring(i32 %37)
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.160, i32 0, i32 0), i8* %arraydecay63, i8* %call65)
  br label %if.end.66

if.end.66:                                        ; preds = %if.then.62, %land.lhs.true.60, %if.end.56
  store i32 78, i32* @ExitStat, align 4, !tbaa !5
  store i32 1, i32* %cleanup.dest.slot
  %38 = bitcast i32* %save_errno to i8*
  call void @llvm.lifetime.end(i64 4, i8* %38) #1
  br label %cleanup.184

if.end.68:                                        ; preds = %lor.end.43
  %arraydecay69 = getelementptr inbounds [4096 x i8], [4096 x i8]* %basedir, i32 0, i32 0
  %39 = load i32, i32* %hashval, align 4, !tbaa !5
  %call70 = call i32 @hash_q(i8* %arraydecay69, i32 %39)
  store i32 %call70, i32* %hashval, align 4, !tbaa !5
  store volatile i32 0, i32* @DoQueueRun, align 4, !tbaa !5
  %call71 = call i64 @curtime()
  store i64 %call71, i64* %now, align 8, !tbaa !92
  store i32 0, i32* %i, align 4, !tbaa !5
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end.68
  %40 = load i32, i32* %i, align 4, !tbaa !5
  %41 = load i32, i32* @NumQueue, align 4, !tbaa !5
  %cmp72 = icmp slt i32 %40, %41
  br i1 %cmp72, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %42 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom74 = sext i32 %42 to i64
  %arrayidx75 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom74
  %43 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx75, align 8, !tbaa !1
  %cmp76 = icmp ne %struct.queuegrp* %43, null
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %44 = phi i1 [ false, %for.cond ], [ %cmp76, %land.rhs ]
  br i1 %44, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %45 = load i64, i64* %now, align 8, !tbaa !92
  %46 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom78 = sext i32 %46 to i64
  %arrayidx79 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom78
  %47 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx79, align 8, !tbaa !1
  %qg_nextrun = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %47, i32 0, i32 13
  store i64 %45, i64* %qg_nextrun, align 8, !tbaa !113
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %48 = load i32, i32* %i, align 4, !tbaa !5
  %inc80 = add nsw i32 %48, 1
  store i32 %inc80, i32* %i, align 4, !tbaa !5
  br label %for.cond

for.end:                                          ; preds = %land.end
  %49 = load i32, i32* @UseMSP, align 4, !tbaa !5
  %tobool81 = icmp ne i32 %49, 0
  br i1 %tobool81, label %land.lhs.true.82, label %if.end.137

land.lhs.true.82:                                 ; preds = %for.end
  %50 = load i8, i8* @OpMode, align 1, !tbaa !17
  %conv83 = sext i8 %50 to i32
  %cmp84 = icmp ne i32 %conv83, 116
  br i1 %cmp84, label %if.then.86, label %if.end.137

if.then.86:                                       ; preds = %land.lhs.true.82
  %51 = bitcast i64* %sff to i8*
  call void @llvm.lifetime.start(i64 8, i8* %51) #1
  store i64 64, i64* %sff, align 8, !tbaa !92
  %call87 = call i32 @stat(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.100, i32 0, i32 0), %struct.stat* %st) #1
  %cmp88 = icmp slt i32 %call87, 0
  br i1 %cmp88, label %if.then.90, label %if.end.102

if.then.90:                                       ; preds = %if.then.86
  %arraydecay91 = getelementptr inbounds [4096 x i8], [4096 x i8]* %basedir, i32 0, i32 0
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.161, i32 0, i32 0), i8* %arraydecay91)
  %52 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 41), align 1, !tbaa !17
  %conv92 = zext i8 %52 to i32
  %cmp93 = icmp sge i32 %conv92, 2
  br i1 %cmp93, label %land.lhs.true.95, label %if.end.101

land.lhs.true.95:                                 ; preds = %if.then.90
  %53 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool96 = icmp ne i32 %53, 0
  br i1 %tobool96, label %if.end.101, label %if.then.97

if.then.97:                                       ; preds = %land.lhs.true.95
  %arraydecay98 = getelementptr inbounds [4096 x i8], [4096 x i8]* %basedir, i32 0, i32 0
  %call99 = call i32* @__errno_location() #11
  %54 = load i32, i32* %call99, align 4, !tbaa !5
  %call100 = call i8* @sm_errstring(i32 %54)
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.160, i32 0, i32 0), i8* %arraydecay98, i8* %call100)
  br label %if.end.101

if.end.101:                                       ; preds = %if.then.97, %land.lhs.true.95, %if.then.90
  store i32 78, i32* @ExitStat, align 4, !tbaa !5
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup.134

if.end.102:                                       ; preds = %if.then.86
  %55 = load i32, i32* @RunAsUid, align 4, !tbaa !5
  %cmp103 = icmp eq i32 %55, 0
  br i1 %cmp103, label %if.then.105, label %if.end.106

if.then.105:                                      ; preds = %if.end.102
  %56 = load i64, i64* %sff, align 8, !tbaa !92
  %or = or i64 %56, 4
  store i64 %or, i64* %sff, align 8, !tbaa !92
  br label %if.end.106

if.end.106:                                       ; preds = %if.then.105, %if.end.102
  %57 = load i32, i32* @QueueFileMode, align 4, !tbaa !5
  %and = and i32 %57, 16
  %cmp107 = icmp ne i32 %and, 0
  br i1 %cmp107, label %land.lhs.true.109, label %if.end.121

land.lhs.true.109:                                ; preds = %if.end.106
  %st_mode = getelementptr inbounds %struct.stat, %struct.stat* %st, i32 0, i32 3
  %58 = load i32, i32* %st_mode, align 4, !tbaa !126
  %and110 = and i32 %58, 16
  %cmp111 = icmp ne i32 %and110, 0
  br i1 %cmp111, label %land.lhs.true.113, label %if.end.121

land.lhs.true.113:                                ; preds = %land.lhs.true.109
  %59 = load i32, i32* @RunAsUid, align 4, !tbaa !5
  %60 = load i32, i32* @RunAsGid, align 4, !tbaa !5
  %61 = load i8*, i8** @RunAsUserName, align 8, !tbaa !1
  %62 = load i64, i64* %sff, align 8, !tbaa !92
  %63 = load i32, i32* @QueueFileMode, align 4, !tbaa !5
  %call114 = call i32 @safefile(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.119, i32 0, i32 0), i32 %59, i32 %60, i8* %61, i64 %62, i32 %63, %struct.stat* null)
  %cmp115 = icmp ne i32 %call114, 0
  br i1 %cmp115, label %if.then.117, label %if.end.121

if.then.117:                                      ; preds = %land.lhs.true.113
  %arraydecay118 = getelementptr inbounds [4096 x i8], [4096 x i8]* %basedir, i32 0, i32 0
  %64 = load i32, i32* @RunAsGid, align 4, !tbaa !5
  %conv119 = zext i32 %64 to i64
  %st_gid = getelementptr inbounds %struct.stat, %struct.stat* %st, i32 0, i32 5
  %65 = load i32, i32* %st_gid, align 4, !tbaa !140
  %conv120 = zext i32 %65 to i64
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([65 x i8], [65 x i8]* @.str.162, i32 0, i32 0), i8* %arraydecay118, i64 %conv119, i64 %conv120)
  br label %if.end.121

if.end.121:                                       ; preds = %if.then.117, %land.lhs.true.113, %land.lhs.true.109, %if.end.106
  %st_mode122 = getelementptr inbounds %struct.stat, %struct.stat* %st, i32 0, i32 3
  %66 = load i32, i32* %st_mode122, align 4, !tbaa !126
  %and123 = and i32 %66, 3
  %cmp124 = icmp ne i32 %and123, 0
  br i1 %cmp124, label %if.then.126, label %if.end.133

if.then.126:                                      ; preds = %if.end.121
  %67 = load i32, i32* @LogLevel, align 4, !tbaa !5
  %cmp127 = icmp sgt i32 %67, 0
  br i1 %cmp127, label %if.then.129, label %if.end.132

if.then.129:                                      ; preds = %if.then.126
  %st_mode130 = getelementptr inbounds %struct.stat, %struct.stat* %st, i32 0, i32 3
  %68 = load i32, i32* %st_mode130, align 4, !tbaa !126
  %arraydecay131 = getelementptr inbounds [4096 x i8], [4096 x i8]* %basedir, i32 0, i32 0
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 3, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0), i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.163, i32 0, i32 0), i32 %68, i8* %arraydecay131)
  br label %if.end.132

if.end.132:                                       ; preds = %if.then.129, %if.then.126
  br label %if.end.133

if.end.133:                                       ; preds = %if.end.132, %if.end.121
  store i32 0, i32* %cleanup.dest.slot
  br label %cleanup.134

cleanup.134:                                      ; preds = %if.end.133, %if.end.101
  %69 = bitcast i64* %sff to i8*
  call void @llvm.lifetime.end(i64 8, i8* %69) #1
  %cleanup.dest.135 = load i32, i32* %cleanup.dest.slot
  switch i32 %cleanup.dest.135, label %cleanup.184 [
    i32 0, label %cleanup.cont.136
  ]

cleanup.cont.136:                                 ; preds = %cleanup.134
  br label %if.end.137

if.end.137:                                       ; preds = %cleanup.cont.136, %land.lhs.true.82, %for.end
  store i32 0, i32* %qn, align 4, !tbaa !5
  store i32 0, i32* %i, align 4, !tbaa !5
  br label %for.cond.138

for.cond.138:                                     ; preds = %for.inc.152, %if.end.137
  %70 = load i32, i32* %i, align 4, !tbaa !5
  %71 = load i32, i32* @NumQueue, align 4, !tbaa !5
  %cmp139 = icmp slt i32 %70, %71
  br i1 %cmp139, label %land.rhs.141, label %land.end.146

land.rhs.141:                                     ; preds = %for.cond.138
  %72 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom142 = sext i32 %72 to i64
  %arrayidx143 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom142
  %73 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx143, align 8, !tbaa !1
  %cmp144 = icmp ne %struct.queuegrp* %73, null
  br label %land.end.146

land.end.146:                                     ; preds = %land.rhs.141, %for.cond.138
  %74 = phi i1 [ false, %for.cond.138 ], [ %cmp144, %land.rhs.141 ]
  br i1 %74, label %for.body.147, label %for.end.154

for.body.147:                                     ; preds = %land.end.146
  %arraydecay148 = getelementptr inbounds [4096 x i8], [4096 x i8]* %basedir, i32 0, i32 0
  %75 = load i32, i32* %len, align 4, !tbaa !5
  %76 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom149 = sext i32 %76 to i64
  %arrayidx150 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom149
  %77 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx150, align 8, !tbaa !1
  %78 = load i32, i32* %qn, align 4, !tbaa !5
  %call151 = call i32 @multiqueue_cache(i8* %arraydecay148, i32 %75, %struct.queuegrp* %77, i32 %78, i32* %hashval)
  store i32 %call151, i32* %qn, align 4, !tbaa !5
  br label %for.inc.152

for.inc.152:                                      ; preds = %for.body.147
  %79 = load i32, i32* %i, align 4, !tbaa !5
  %inc153 = add nsw i32 %79, 1
  store i32 %inc153, i32* %i, align 4, !tbaa !5
  br label %for.cond.138

for.end.154:                                      ; preds = %land.end.146
  %80 = load i32, i32* %qn, align 4, !tbaa !5
  %81 = load i32, i32* %owner.addr, align 4, !tbaa !5
  %82 = load i32, i32* %hashval, align 4, !tbaa !5
  call void @init_shm(i32 %80, i32 %81, i32 %82)
  %83 = load i32, i32* %owner.addr, align 4, !tbaa !5
  %tobool155 = icmp ne i32 %83, 0
  br i1 %tobool155, label %lor.end.159, label %lor.rhs.156

lor.rhs.156:                                      ; preds = %for.end.154
  %84 = load i32, i32* @ShmId, align 4, !tbaa !5
  %cmp157 = icmp eq i32 %84, -2
  br label %lor.end.159

lor.end.159:                                      ; preds = %lor.rhs.156, %for.end.154
  %85 = phi i1 [ true, %for.end.154 ], [ %cmp157, %lor.rhs.156 ]
  %lor.ext160 = zext i1 %85 to i32
  %call161 = call i32 @filesys_setup(i32 %lor.ext160)
  store i32 %call161, i32* %i, align 4, !tbaa !5
  %86 = load i32, i32* %i, align 4, !tbaa !5
  %cmp162 = icmp eq i32 %86, -1
  br i1 %cmp162, label %if.then.164, label %if.end.179

if.then.164:                                      ; preds = %lor.end.159
  %87 = load i32, i32* %owner.addr, align 4, !tbaa !5
  %tobool165 = icmp ne i32 %87, 0
  br i1 %tobool165, label %lor.rhs.166, label %lor.end.167

lor.rhs.166:                                      ; preds = %if.then.164
  call void @sm_abort_at(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 7195, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.164, i32 0, i32 0)) #12
  unreachable
                                                  ; No predecessors!
  br label %lor.end.167

lor.end.167:                                      ; preds = %88, %if.then.164
  %89 = phi i1 [ true, %if.then.164 ], [ false, %88 ]
  %lor.ext168 = zext i1 %89 to i32
  call void @cleanup_shm(i32 0)
  %call169 = call i32 @filesys_setup(i32 0)
  store i32 %call169, i32* %i, align 4, !tbaa !5
  %90 = load i32, i32* %i, align 4, !tbaa !5
  %cmp170 = icmp slt i32 %90, 0
  br i1 %cmp170, label %if.then.172, label %if.else.173

if.then.172:                                      ; preds = %lor.end.167
  %91 = load i32, i32* %i, align 4, !tbaa !5
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.165, i32 0, i32 0), i32 %91)
  br label %if.end.178

if.else.173:                                      ; preds = %lor.end.167
  %92 = load i32, i32* @LogLevel, align 4, !tbaa !5
  %cmp174 = icmp sgt i32 %92, 8
  br i1 %cmp174, label %if.then.176, label %if.end.177

if.then.176:                                      ; preds = %if.else.173
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 4, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0), i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.166, i32 0, i32 0))
  br label %if.end.177

if.end.177:                                       ; preds = %if.then.176, %if.else.173
  br label %if.end.178

if.end.178:                                       ; preds = %if.end.177, %if.then.172
  br label %if.end.179

if.end.179:                                       ; preds = %if.end.178, %lor.end.159
  %93 = load i32, i32* %i, align 4, !tbaa !5
  %cmp180 = icmp slt i32 %93, 0
  br i1 %cmp180, label %if.then.182, label %if.end.183

if.then.182:                                      ; preds = %if.end.179
  store i32 78, i32* @ExitStat, align 4, !tbaa !5
  br label %if.end.183

if.end.183:                                       ; preds = %if.then.182, %if.end.179
  store i32 0, i32* %cleanup.dest.slot
  br label %cleanup.184

cleanup.184:                                      ; preds = %if.end.183, %cleanup.134, %if.end.66, %cleanup, %if.then
  %94 = bitcast %struct.stat* %st to i8*
  call void @llvm.lifetime.end(i64 144, i8* %94) #1
  %95 = bitcast [4096 x i8]* %basedir to i8*
  call void @llvm.lifetime.end(i64 4096, i8* %95) #1
  %96 = bitcast i64* %now to i8*
  call void @llvm.lifetime.end(i64 8, i8* %96) #1
  %97 = bitcast i32* %hashval to i8*
  call void @llvm.lifetime.end(i64 4, i8* %97) #1
  %98 = bitcast i32* %len to i8*
  call void @llvm.lifetime.end(i64 4, i8* %98) #1
  %99 = bitcast i32* %qn to i8*
  call void @llvm.lifetime.end(i64 4, i8* %99) #1
  %100 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end(i64 4, i8* %100) #1
  %cleanup.dest.191 = load i32, i32* %cleanup.dest.slot
  switch i32 %cleanup.dest.191, label %unreachable [
    i32 0, label %cleanup.cont.192
    i32 1, label %cleanup.cont.192
  ]

cleanup.cont.192:                                 ; preds = %cleanup.184, %cleanup.184
  ret void

unreachable:                                      ; preds = %cleanup.184
  unreachable
}

; Function Attrs: noreturn
declare void @sm_abort_at(i8*, i32, i8*) #9

; Function Attrs: nounwind readonly
declare i8* @strrchr(i8*, i32) #8

; Function Attrs: nounwind
declare i32 @chdir(i8*) #3

; Function Attrs: nounwind uwtable
define internal i32 @hash_q(i8* %p, i32 %h) #0 {
entry:
  %p.addr = alloca i8*, align 8
  %h.addr = alloca i32, align 4
  %c = alloca i32, align 4
  %d = alloca i32, align 4
  store i8* %p, i8** %p.addr, align 8, !tbaa !1
  store i32 %h, i32* %h.addr, align 4, !tbaa !5
  %0 = bitcast i32* %c to i8*
  call void @llvm.lifetime.start(i64 4, i8* %0) #1
  %1 = bitcast i32* %d to i8*
  call void @llvm.lifetime.start(i64 4, i8* %1) #1
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %2 = load i8*, i8** %p.addr, align 8, !tbaa !1
  %3 = load i8, i8* %2, align 1, !tbaa !17
  %conv = sext i8 %3 to i32
  %cmp = icmp ne i32 %conv, 0
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %4 = load i8*, i8** %p.addr, align 8, !tbaa !1
  %incdec.ptr = getelementptr inbounds i8, i8* %4, i32 1
  store i8* %incdec.ptr, i8** %p.addr, align 8, !tbaa !1
  %5 = load i8, i8* %4, align 1, !tbaa !17
  %conv2 = sext i8 %5 to i32
  store i32 %conv2, i32* %d, align 4, !tbaa !5
  %6 = load i32, i32* %d, align 4, !tbaa !5
  store i32 %6, i32* %c, align 4, !tbaa !5
  %7 = load i32, i32* %c, align 4, !tbaa !5
  %shl = shl i32 %7, 6
  %8 = load i32, i32* %c, align 4, !tbaa !5
  %xor = xor i32 %8, %shl
  store i32 %xor, i32* %c, align 4, !tbaa !5
  %9 = load i32, i32* %c, align 4, !tbaa !5
  %shl3 = shl i32 %9, 11
  %10 = load i32, i32* %c, align 4, !tbaa !5
  %shr = ashr i32 %10, 1
  %xor4 = xor i32 %shl3, %shr
  %11 = load i32, i32* %h.addr, align 4, !tbaa !5
  %add = add i32 %11, %xor4
  store i32 %add, i32* %h.addr, align 4, !tbaa !5
  %12 = load i32, i32* %d, align 4, !tbaa !5
  %shl5 = shl i32 %12, 14
  %13 = load i32, i32* %d, align 4, !tbaa !5
  %shl6 = shl i32 %13, 7
  %add7 = add nsw i32 %shl5, %shl6
  %14 = load i32, i32* %d, align 4, !tbaa !5
  %shl8 = shl i32 %14, 4
  %add9 = add nsw i32 %add7, %shl8
  %15 = load i32, i32* %d, align 4, !tbaa !5
  %add10 = add nsw i32 %add9, %15
  %16 = load i32, i32* %h.addr, align 4, !tbaa !5
  %xor11 = xor i32 %16, %add10
  store i32 %xor11, i32* %h.addr, align 4, !tbaa !5
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %17 = load i32, i32* %h.addr, align 4, !tbaa !5
  %18 = bitcast i32* %d to i8*
  call void @llvm.lifetime.end(i64 4, i8* %18) #1
  %19 = bitcast i32* %c to i8*
  call void @llvm.lifetime.end(i64 4, i8* %19) #1
  ret i32 %17
}

declare i32 @safefile(i8*, i32, i32, i8*, i64, i32, %struct.stat*) #2

; Function Attrs: nounwind uwtable
define internal i32 @multiqueue_cache(i8* %basedir, i32 %blen, %struct.queuegrp* %qg, i32 %qn, i32* %phash) #0 {
entry:
  %retval = alloca i32, align 4
  %basedir.addr = alloca i8*, align 8
  %blen.addr = alloca i32, align 4
  %qg.addr = alloca %struct.queuegrp*, align 8
  %qn.addr = alloca i32, align 4
  %phash.addr = alloca i32*, align 8
  %cp = alloca i8*, align 8
  %i = alloca i32, align 4
  %len = alloca i32, align 4
  %slotsleft = alloca i32, align 4
  %sff = alloca i64, align 8
  %qpath = alloca [4096 x i8], align 16
  %subdir = alloca [4096 x i8], align 16
  %prefix = alloca [4096 x i8], align 16
  %cleanup.dest.slot = alloca i32
  %dp = alloca %struct.__dirstream*, align 8
  %d = alloca %struct.dirent*, align 8
  %off = alloca i32, align 4
  %delim = alloca i8*, align 8
  %relpath = alloca [4096 x i8], align 16
  %__s1_len = alloca i64, align 8
  %__s2_len = alloca i64, align 8
  %tmp = alloca i32, align 4
  %__s1 = alloca i8*, align 8
  %__result = alloca i32, align 4
  %tmp229 = alloca i32, align 4
  %__s1_len237 = alloca i64, align 8
  %__s2_len239 = alloca i64, align 8
  %tmp240 = alloca i32, align 4
  %__s1246 = alloca i8*, align 8
  %__result250 = alloca i32, align 4
  %tmp288 = alloca i32, align 4
  store i8* %basedir, i8** %basedir.addr, align 8, !tbaa !1
  store i32 %blen, i32* %blen.addr, align 4, !tbaa !5
  store %struct.queuegrp* %qg, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  store i32 %qn, i32* %qn.addr, align 4, !tbaa !5
  store i32* %phash, i32** %phash.addr, align 8, !tbaa !1
  %0 = bitcast i8** %cp to i8*
  call void @llvm.lifetime.start(i64 8, i8* %0) #1
  %1 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start(i64 4, i8* %1) #1
  %2 = bitcast i32* %len to i8*
  call void @llvm.lifetime.start(i64 4, i8* %2) #1
  %3 = bitcast i32* %slotsleft to i8*
  call void @llvm.lifetime.start(i64 4, i8* %3) #1
  store i32 0, i32* %slotsleft, align 4, !tbaa !5
  %4 = bitcast i64* %sff to i8*
  call void @llvm.lifetime.start(i64 8, i8* %4) #1
  store i64 0, i64* %sff, align 8, !tbaa !92
  %5 = bitcast [4096 x i8]* %qpath to i8*
  call void @llvm.lifetime.start(i64 4096, i8* %5) #1
  %6 = bitcast [4096 x i8]* %subdir to i8*
  call void @llvm.lifetime.start(i64 4096, i8* %6) #1
  %7 = bitcast [4096 x i8]* %prefix to i8*
  call void @llvm.lifetime.start(i64 4096, i8* %7) #1
  %8 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 41), align 1, !tbaa !17
  %conv = zext i8 %8 to i32
  %cmp = icmp sge i32 %conv, 20
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %9 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool = icmp ne i32 %9, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.266, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %arrayidx = getelementptr inbounds [4096 x i8], [4096 x i8]* %prefix, i32 0, i64 0
  store i8 46, i8* %arrayidx, align 1, !tbaa !17
  %arrayidx2 = getelementptr inbounds [4096 x i8], [4096 x i8]* %prefix, i32 0, i64 1
  store i8 0, i8* %arrayidx2, align 1, !tbaa !17
  %10 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_numqueues = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %10, i32 0, i32 4
  %11 = load i32, i32* %qg_numqueues, align 4, !tbaa !82
  %cmp3 = icmp ne i32 %11, 0
  br i1 %cmp3, label %land.lhs.true.5, label %if.end.25

land.lhs.true.5:                                  ; preds = %if.end
  %12 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qpaths = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %12, i32 0, i32 6
  %13 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths, align 8, !tbaa !38
  %cmp6 = icmp ne %struct.qpaths_s* %13, null
  br i1 %cmp6, label %if.then.8, label %if.end.25

if.then.8:                                        ; preds = %land.lhs.true.5
  store i32 0, i32* %i, align 4, !tbaa !5
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then.8
  %14 = load i32, i32* %i, align 4, !tbaa !5
  %15 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_numqueues9 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %15, i32 0, i32 4
  %16 = load i32, i32* %qg_numqueues9, align 4, !tbaa !82
  %cmp10 = icmp slt i32 %14, %16
  br i1 %cmp10, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %17 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom = sext i32 %17 to i64
  %18 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qpaths12 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %18, i32 0, i32 6
  %19 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths12, align 8, !tbaa !38
  %arrayidx13 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %19, i64 %idxprom
  %qp_name = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %arrayidx13, i32 0, i32 0
  %20 = load i8*, i8** %qp_name, align 8, !tbaa !40
  %cmp14 = icmp ne i8* %20, null
  br i1 %cmp14, label %if.then.16, label %if.end.21

if.then.16:                                       ; preds = %for.body
  %21 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom17 = sext i32 %21 to i64
  %22 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qpaths18 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %22, i32 0, i32 6
  %23 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths18, align 8, !tbaa !38
  %arrayidx19 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %23, i64 %idxprom17
  %qp_name20 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %arrayidx19, i32 0, i32 0
  %24 = load i8*, i8** %qp_name20, align 8, !tbaa !40
  call void @sm_free_tagged(i8* %24, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 6070)
  br label %if.end.21

if.end.21:                                        ; preds = %if.then.16, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end.21
  %25 = load i32, i32* %i, align 4, !tbaa !5
  %inc = add nsw i32 %25, 1
  store i32 %inc, i32* %i, align 4, !tbaa !5
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %26 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qpaths22 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %26, i32 0, i32 6
  %27 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths22, align 8, !tbaa !38
  %28 = bitcast %struct.qpaths_s* %27 to i8*
  call void @sm_free_tagged(i8* %28, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 6072)
  %29 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qpaths23 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %29, i32 0, i32 6
  store %struct.qpaths_s* null, %struct.qpaths_s** %qg_qpaths23, align 8, !tbaa !38
  %30 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_numqueues24 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %30, i32 0, i32 4
  store i32 0, i32* %qg_numqueues24, align 4, !tbaa !82
  br label %if.end.25

if.end.25:                                        ; preds = %for.end, %land.lhs.true.5, %if.end
  %31 = load i32, i32* @RunAsUid, align 4, !tbaa !5
  %cmp26 = icmp eq i32 %31, 0
  br i1 %cmp26, label %if.then.28, label %if.end.29

if.then.28:                                       ; preds = %if.end.25
  %32 = load i64, i64* %sff, align 8, !tbaa !92
  %or = or i64 %32, 4
  store i64 %or, i64* %sff, align 8, !tbaa !92
  br label %if.end.29

if.end.29:                                        ; preds = %if.then.28, %if.end.25
  %33 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qdir = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %33, i32 0, i32 1
  %34 = load i8*, i8** %qg_qdir, align 8, !tbaa !94
  %arrayidx30 = getelementptr inbounds i8, i8* %34, i64 0
  %35 = load i8, i8* %arrayidx30, align 1, !tbaa !17
  %conv31 = sext i8 %35 to i32
  %cmp32 = icmp eq i32 %conv31, 47
  br i1 %cmp32, label %if.end.36, label %if.then.34

if.then.34:                                       ; preds = %if.end.29
  %36 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qdir35 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %36, i32 0, i32 1
  %37 = load i8*, i8** %qg_qdir35, align 8, !tbaa !94
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.267, i32 0, i32 0), i8* %37)
  store i32 78, i32* @ExitStat, align 4, !tbaa !5
  %38 = load i32, i32* %qn.addr, align 4, !tbaa !5
  store i32 %38, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup.589

if.end.36:                                        ; preds = %if.end.29
  %arraydecay = getelementptr inbounds [4096 x i8], [4096 x i8]* %qpath, i32 0, i32 0
  %39 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qdir37 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %39, i32 0, i32 1
  %40 = load i8*, i8** %qg_qdir37, align 8, !tbaa !94
  %call = call i64 @sm_strlcpy(i8* %arraydecay, i8* %40, i64 4096)
  %conv38 = trunc i64 %call to i32
  store i32 %conv38, i32* %len, align 4, !tbaa !5
  %41 = load i32, i32* %len, align 4, !tbaa !5
  %conv39 = sext i32 %41 to i64
  %cmp40 = icmp uge i64 %conv39, 4096
  br i1 %cmp40, label %if.then.42, label %if.end.44

if.then.42:                                       ; preds = %if.end.36
  %42 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qdir43 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %42, i32 0, i32 1
  %43 = load i8*, i8** %qg_qdir43, align 8, !tbaa !94
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.268, i32 0, i32 0), i8* %43, i32 4096)
  store i32 78, i32* @ExitStat, align 4, !tbaa !5
  %44 = load i32, i32* %qn.addr, align 4, !tbaa !5
  store i32 %44, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup.589

if.end.44:                                        ; preds = %if.end.36
  %45 = load i8*, i8** %basedir.addr, align 8, !tbaa !1
  %arraydecay45 = getelementptr inbounds [4096 x i8], [4096 x i8]* %qpath, i32 0, i32 0
  %46 = load i32, i32* %blen.addr, align 4, !tbaa !5
  %conv46 = sext i32 %46 to i64
  %call47 = call i32 @strncmp(i8* %45, i8* %arraydecay45, i64 %conv46) #14
  %cmp48 = icmp ne i32 %call47, 0
  br i1 %cmp48, label %land.lhs.true.50, label %if.end.61

land.lhs.true.50:                                 ; preds = %if.end.44
  %47 = load i8*, i8** %basedir.addr, align 8, !tbaa !1
  %arraydecay51 = getelementptr inbounds [4096 x i8], [4096 x i8]* %qpath, i32 0, i32 0
  %48 = load i32, i32* %blen.addr, align 4, !tbaa !5
  %sub = sub nsw i32 %48, 1
  %conv52 = sext i32 %sub to i64
  %call53 = call i32 @strncmp(i8* %47, i8* %arraydecay51, i64 %conv52) #14
  %cmp54 = icmp ne i32 %call53, 0
  br i1 %cmp54, label %if.then.59, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true.50
  %49 = load i32, i32* %len, align 4, !tbaa !5
  %50 = load i32, i32* %blen.addr, align 4, !tbaa !5
  %sub56 = sub nsw i32 %50, 1
  %cmp57 = icmp ne i32 %49, %sub56
  br i1 %cmp57, label %if.then.59, label %if.end.61

if.then.59:                                       ; preds = %lor.lhs.false, %land.lhs.true.50
  %arraydecay60 = getelementptr inbounds [4096 x i8], [4096 x i8]* %qpath, i32 0, i32 0
  %51 = load i8*, i8** %basedir.addr, align 8, !tbaa !1
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([46 x i8], [46 x i8]* @.str.269, i32 0, i32 0), i8* %arraydecay60, i8* %51)
  store i32 78, i32* @ExitStat, align 4, !tbaa !5
  %52 = load i32, i32* %qn.addr, align 4, !tbaa !5
  store i32 %52, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup.589

if.end.61:                                        ; preds = %lor.lhs.false, %if.end.44
  %53 = load i32, i32* %blen.addr, align 4, !tbaa !5
  %54 = load i32, i32* %len, align 4, !tbaa !5
  %cmp62 = icmp slt i32 %53, %54
  br i1 %cmp62, label %land.lhs.true.64, label %if.end.84

land.lhs.true.64:                                 ; preds = %if.end.61
  %55 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qdir65 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %55, i32 0, i32 1
  %56 = load i8*, i8** %qg_qdir65, align 8, !tbaa !94
  %57 = load i32, i32* %blen.addr, align 4, !tbaa !5
  %idx.ext = sext i32 %57 to i64
  %add.ptr = getelementptr inbounds i8, i8* %56, i64 %idx.ext
  %call66 = call i8* @strchr(i8* %add.ptr, i32 47) #1
  %cmp67 = icmp ne i8* %call66, null
  br i1 %cmp67, label %if.then.69, label %if.end.84

if.then.69:                                       ; preds = %land.lhs.true.64
  %arraydecay70 = getelementptr inbounds [4096 x i8], [4096 x i8]* %prefix, i32 0, i32 0
  %58 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qdir71 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %58, i32 0, i32 1
  %59 = load i8*, i8** %qg_qdir71, align 8, !tbaa !94
  %60 = load i32, i32* %blen.addr, align 4, !tbaa !5
  %idx.ext72 = sext i32 %60 to i64
  %add.ptr73 = getelementptr inbounds i8, i8* %59, i64 %idx.ext72
  %call74 = call i64 @sm_strlcpy(i8* %arraydecay70, i8* %add.ptr73, i64 4096)
  %cmp75 = icmp uge i64 %call74, 4096
  br i1 %cmp75, label %if.then.77, label %if.end.79

if.then.77:                                       ; preds = %if.then.69
  %61 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qdir78 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %61, i32 0, i32 1
  %62 = load i8*, i8** %qg_qdir78, align 8, !tbaa !94
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.268, i32 0, i32 0), i8* %62, i32 4096)
  store i32 78, i32* @ExitStat, align 4, !tbaa !5
  %63 = load i32, i32* %qn.addr, align 4, !tbaa !5
  store i32 %63, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup.589

if.end.79:                                        ; preds = %if.then.69
  %arraydecay80 = getelementptr inbounds [4096 x i8], [4096 x i8]* %prefix, i32 0, i32 0
  %call81 = call i8* @strrchr(i8* %arraydecay80, i32 47) #14
  store i8* %call81, i8** %cp, align 8, !tbaa !1
  %64 = load i8*, i8** %cp, align 8, !tbaa !1
  %cmp82 = icmp ne i8* %64, null
  br i1 %cmp82, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.end.79
  call void @sm_abort_at(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 6132, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.270, i32 0, i32 0)) #12
  unreachable
                                                  ; No predecessors!
  br label %lor.end

lor.end:                                          ; preds = %65, %if.end.79
  %66 = phi i1 [ true, %if.end.79 ], [ false, %65 ]
  %lor.ext = zext i1 %66 to i32
  %67 = load i8*, i8** %cp, align 8, !tbaa !1
  store i8 0, i8* %67, align 1, !tbaa !17
  br label %if.end.84

if.end.84:                                        ; preds = %lor.end, %land.lhs.true.64, %if.end.61
  %68 = load i32, i32* %len, align 4, !tbaa !5
  %69 = load i32, i32* %blen.addr, align 4, !tbaa !5
  %sub85 = sub nsw i32 %69, 1
  %cmp86 = icmp sge i32 %68, %sub85
  br i1 %cmp86, label %lor.end.89, label %lor.rhs.88

lor.rhs.88:                                       ; preds = %if.end.84
  call void @sm_abort_at(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 6137, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.271, i32 0, i32 0)) #12
  unreachable
                                                  ; No predecessors!
  br label %lor.end.89

lor.end.89:                                       ; preds = %70, %if.end.84
  %71 = phi i1 [ true, %if.end.84 ], [ false, %70 ]
  %lor.ext90 = zext i1 %71 to i32
  %72 = load i32, i32* %len, align 4, !tbaa !5
  %sub91 = sub nsw i32 %72, 1
  %idxprom92 = sext i32 %sub91 to i64
  %arrayidx93 = getelementptr inbounds [4096 x i8], [4096 x i8]* %qpath, i32 0, i64 %idxprom92
  store i8* %arrayidx93, i8** %cp, align 8, !tbaa !1
  %73 = load i8*, i8** %cp, align 8, !tbaa !1
  %74 = load i8, i8* %73, align 1, !tbaa !17
  %conv94 = sext i8 %74 to i32
  %cmp95 = icmp eq i32 %conv94, 42
  br i1 %cmp95, label %if.then.97, label %if.end.476

if.then.97:                                       ; preds = %lor.end.89
  %75 = bitcast %struct.__dirstream** %dp to i8*
  call void @llvm.lifetime.start(i64 8, i8* %75) #1
  %76 = bitcast %struct.dirent** %d to i8*
  call void @llvm.lifetime.start(i64 8, i8* %76) #1
  %77 = bitcast i32* %off to i8*
  call void @llvm.lifetime.start(i64 4, i8* %77) #1
  %78 = bitcast i8** %delim to i8*
  call void @llvm.lifetime.start(i64 8, i8* %78) #1
  %79 = bitcast [4096 x i8]* %relpath to i8*
  call void @llvm.lifetime.start(i64 4096, i8* %79) #1
  %80 = load i8*, i8** %cp, align 8, !tbaa !1
  store i8 0, i8* %80, align 1, !tbaa !17
  %arraydecay98 = getelementptr inbounds [4096 x i8], [4096 x i8]* %qpath, i32 0, i32 0
  %call99 = call i8* @strrchr(i8* %arraydecay98, i32 47) #14
  store i8* %call99, i8** %cp, align 8, !tbaa !1
  %cmp100 = icmp eq i8* %call99, null
  br i1 %cmp100, label %if.then.102, label %if.end.111

if.then.102:                                      ; preds = %if.then.97
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.272, i32 0, i32 0))
  %81 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 41), align 1, !tbaa !17
  %conv103 = zext i8 %81 to i32
  %cmp104 = icmp sge i32 %conv103, 2
  br i1 %cmp104, label %land.lhs.true.106, label %if.end.110

land.lhs.true.106:                                ; preds = %if.then.102
  %82 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool107 = icmp ne i32 %82, 0
  br i1 %tobool107, label %if.end.110, label %if.then.108

if.then.108:                                      ; preds = %land.lhs.true.106
  %arraydecay109 = getelementptr inbounds [4096 x i8], [4096 x i8]* %qpath, i32 0, i32 0
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([58 x i8], [58 x i8]* @.str.273, i32 0, i32 0), i8* %arraydecay109)
  br label %if.end.110

if.end.110:                                       ; preds = %if.then.108, %land.lhs.true.106, %if.then.102
  store i32 78, i32* @ExitStat, align 4, !tbaa !5
  %83 = load i32, i32* %qn.addr, align 4, !tbaa !5
  store i32 %83, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.111:                                       ; preds = %if.then.97
  %84 = load i8*, i8** %cp, align 8, !tbaa !1
  %arraydecay112 = getelementptr inbounds [4096 x i8], [4096 x i8]* %qpath, i32 0, i32 0
  %cmp113 = icmp eq i8* %84, %arraydecay112
  br i1 %cmp113, label %if.then.115, label %if.end.120

if.then.115:                                      ; preds = %if.end.111
  %arraydecay116 = getelementptr inbounds [4096 x i8], [4096 x i8]* %qpath, i32 0, i32 0
  %add.ptr117 = getelementptr inbounds i8, i8* %arraydecay116, i64 1
  %arraydecay118 = getelementptr inbounds [4096 x i8], [4096 x i8]* %qpath, i32 0, i32 0
  %call119 = call i64 @sm_strlcpy(i8* %add.ptr117, i8* %arraydecay118, i64 4095)
  %85 = load i8*, i8** %cp, align 8, !tbaa !1
  %incdec.ptr = getelementptr inbounds i8, i8* %85, i32 1
  store i8* %incdec.ptr, i8** %cp, align 8, !tbaa !1
  br label %if.end.120

if.end.120:                                       ; preds = %if.then.115, %if.end.111
  %86 = load i8*, i8** %cp, align 8, !tbaa !1
  store i8* %86, i8** %delim, align 8, !tbaa !1
  %87 = load i8*, i8** %cp, align 8, !tbaa !1
  %incdec.ptr121 = getelementptr inbounds i8, i8* %87, i32 1
  store i8* %incdec.ptr121, i8** %cp, align 8, !tbaa !1
  store i8 0, i8* %87, align 1, !tbaa !17
  %88 = load i8*, i8** %cp, align 8, !tbaa !1
  %call122 = call i64 @strlen(i8* %88) #14
  %conv123 = trunc i64 %call122 to i32
  store i32 %conv123, i32* %len, align 4, !tbaa !5
  %arraydecay124 = getelementptr inbounds [4096 x i8], [4096 x i8]* %relpath, i32 0, i32 0
  %arraydecay125 = getelementptr inbounds [4096 x i8], [4096 x i8]* %prefix, i32 0, i32 0
  %call126 = call i64 (i8*, i64, i32, ...) @sm_strlcpyn(i8* %arraydecay124, i64 4096, i32 2, i8* %arraydecay125, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.111, i32 0, i32 0))
  %conv127 = trunc i64 %call126 to i32
  store i32 %conv127, i32* %off, align 4, !tbaa !5
  %89 = load i32, i32* %off, align 4, !tbaa !5
  %conv128 = sext i32 %89 to i64
  %cmp129 = icmp ult i64 %conv128, 4096
  br i1 %cmp129, label %lor.end.132, label %lor.rhs.131

lor.rhs.131:                                      ; preds = %if.end.120
  call void @sm_abort_at(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 6178, i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.274, i32 0, i32 0)) #12
  unreachable
                                                  ; No predecessors!
  br label %lor.end.132

lor.end.132:                                      ; preds = %90, %if.end.120
  %91 = phi i1 [ true, %if.end.120 ], [ false, %90 ]
  %lor.ext133 = zext i1 %91 to i32
  %92 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 41), align 1, !tbaa !17
  %conv134 = zext i8 %92 to i32
  %cmp135 = icmp sge i32 %conv134, 2
  br i1 %cmp135, label %land.lhs.true.137, label %if.end.141

land.lhs.true.137:                                ; preds = %lor.end.132
  %93 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool138 = icmp ne i32 %93, 0
  br i1 %tobool138, label %if.end.141, label %if.then.139

if.then.139:                                      ; preds = %land.lhs.true.137
  %arraydecay140 = getelementptr inbounds [4096 x i8], [4096 x i8]* %relpath, i32 0, i32 0
  %94 = load i8*, i8** %cp, align 8, !tbaa !1
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.275, i32 0, i32 0), i8* %arraydecay140, i8* %94)
  br label %if.end.141

if.end.141:                                       ; preds = %if.then.139, %land.lhs.true.137, %lor.end.132
  %95 = load i8*, i8** %basedir.addr, align 8, !tbaa !1
  %call142 = call i8* @newstr(i8* %95)
  %96 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qdir143 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %96, i32 0, i32 1
  store i8* %call142, i8** %qg_qdir143, align 8, !tbaa !94
  %97 = load i32, i32* %blen.addr, align 4, !tbaa !5
  %sub144 = sub nsw i32 %97, 1
  %idxprom145 = sext i32 %sub144 to i64
  %98 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qdir146 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %98, i32 0, i32 1
  %99 = load i8*, i8** %qg_qdir146, align 8, !tbaa !94
  %arrayidx147 = getelementptr inbounds i8, i8* %99, i64 %idxprom145
  store i8 0, i8* %arrayidx147, align 1, !tbaa !17
  %100 = load i32, i32* %qn.addr, align 4, !tbaa !5
  %cmp148 = icmp eq i32 %100, 0
  br i1 %cmp148, label %if.then.150, label %if.end.163

if.then.150:                                      ; preds = %if.end.141
  %101 = load i8*, i8** %basedir.addr, align 8, !tbaa !1
  %102 = load i32, i32* @RunAsUid, align 4, !tbaa !5
  %103 = load i32, i32* @RunAsGid, align 4, !tbaa !5
  %104 = load i64, i64* %sff, align 8, !tbaa !92
  %call151 = call i32 @safedirpath(i8* %101, i32 %102, i32 %103, i8* null, i64 %104, i32 0, i32 0)
  store i32 %call151, i32* %i, align 4, !tbaa !5
  %105 = load i32, i32* %i, align 4, !tbaa !5
  %cmp152 = icmp ne i32 %105, 0
  br i1 %cmp152, label %land.lhs.true.154, label %if.end.162

land.lhs.true.154:                                ; preds = %if.then.150
  %106 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 41), align 1, !tbaa !17
  %conv155 = zext i8 %106 to i32
  %cmp156 = icmp sge i32 %conv155, 2
  br i1 %cmp156, label %land.lhs.true.158, label %if.end.162

land.lhs.true.158:                                ; preds = %land.lhs.true.154
  %107 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool159 = icmp ne i32 %107, 0
  br i1 %tobool159, label %if.end.162, label %if.then.160

if.then.160:                                      ; preds = %land.lhs.true.158
  %108 = load i8*, i8** %basedir.addr, align 8, !tbaa !1
  %109 = load i32, i32* %i, align 4, !tbaa !5
  %call161 = call i8* @sm_errstring(i32 %109)
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.276, i32 0, i32 0), i8* %108, i8* %call161)
  br label %if.end.162

if.end.162:                                       ; preds = %if.then.160, %land.lhs.true.158, %land.lhs.true.154, %if.then.150
  br label %if.end.163

if.end.163:                                       ; preds = %if.end.162, %if.end.141
  %arraydecay164 = getelementptr inbounds [4096 x i8], [4096 x i8]* %prefix, i32 0, i32 0
  %call165 = call %struct.__dirstream* @opendir(i8* %arraydecay164)
  store %struct.__dirstream* %call165, %struct.__dirstream** %dp, align 8, !tbaa !1
  %cmp166 = icmp eq %struct.__dirstream* %call165, null
  br i1 %cmp166, label %if.then.168, label %if.end.182

if.then.168:                                      ; preds = %if.end.163
  %110 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qdir169 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %110, i32 0, i32 1
  %111 = load i8*, i8** %qg_qdir169, align 8, !tbaa !94
  %arraydecay170 = getelementptr inbounds [4096 x i8], [4096 x i8]* %prefix, i32 0, i32 0
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.277, i32 0, i32 0), i8* %111, i8* %arraydecay170)
  %112 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 41), align 1, !tbaa !17
  %conv171 = zext i8 %112 to i32
  %cmp172 = icmp sge i32 %conv171, 2
  br i1 %cmp172, label %land.lhs.true.174, label %if.end.181

land.lhs.true.174:                                ; preds = %if.then.168
  %113 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool175 = icmp ne i32 %113, 0
  br i1 %tobool175, label %if.end.181, label %if.then.176

if.then.176:                                      ; preds = %land.lhs.true.174
  %114 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qdir177 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %114, i32 0, i32 1
  %115 = load i8*, i8** %qg_qdir177, align 8, !tbaa !94
  %arraydecay178 = getelementptr inbounds [4096 x i8], [4096 x i8]* %prefix, i32 0, i32 0
  %call179 = call i32* @__errno_location() #11
  %116 = load i32, i32* %call179, align 4, !tbaa !5
  %call180 = call i8* @sm_errstring(i32 %116)
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.278, i32 0, i32 0), i8* %115, i8* %arraydecay178, i8* %call180)
  br label %if.end.181

if.end.181:                                       ; preds = %if.then.176, %land.lhs.true.174, %if.then.168
  store i32 78, i32* @ExitStat, align 4, !tbaa !5
  %117 = load i32, i32* %qn.addr, align 4, !tbaa !5
  store i32 %117, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.182:                                       ; preds = %if.end.163
  br label %while.cond

while.cond:                                       ; preds = %if.end.461, %if.then.341, %if.then.336, %if.end.321, %if.then.297, %if.end.182
  %118 = load %struct.__dirstream*, %struct.__dirstream** %dp, align 8, !tbaa !1
  %call183 = call %struct.dirent* @readdir(%struct.__dirstream* %118)
  store %struct.dirent* %call183, %struct.dirent** %d, align 8, !tbaa !1
  %cmp184 = icmp ne %struct.dirent* %call183, null
  br i1 %cmp184, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %119 = bitcast i64* %__s1_len to i8*
  call void @llvm.lifetime.start(i64 8, i8* %119) #1
  %120 = bitcast i64* %__s2_len to i8*
  call void @llvm.lifetime.start(i64 8, i8* %120) #1
  br i1 icmp eq (i64 sub (i64 ptrtoint (i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.100, i32 0, i64 1) to i64), i64 ptrtoint ([2 x i8]* @.str.100 to i64)), i64 1), label %land.lhs.true.186, label %cond.false

land.lhs.true.186:                                ; preds = %while.body
  store i64 1, i64* %__s2_len, align 8, !tbaa !92
  %121 = load i64, i64* %__s2_len, align 8, !tbaa !92
  %cmp187 = icmp ult i64 %121, 4
  br i1 %cmp187, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true.186
  %122 = bitcast i8** %__s1 to i8*
  call void @llvm.lifetime.start(i64 8, i8* %122) #1
  %123 = load %struct.dirent*, %struct.dirent** %d, align 8, !tbaa !1
  %d_name = getelementptr inbounds %struct.dirent, %struct.dirent* %123, i32 0, i32 4
  %arraydecay190 = getelementptr inbounds [256 x i8], [256 x i8]* %d_name, i32 0, i32 0
  store i8* %arraydecay190, i8** %__s1, align 8, !tbaa !1
  %124 = bitcast i32* %__result to i8*
  call void @llvm.lifetime.start(i64 4, i8* %124) #1
  %125 = load i8*, i8** %__s1, align 8, !tbaa !1
  %arrayidx192 = getelementptr inbounds i8, i8* %125, i64 0
  %126 = load i8, i8* %arrayidx192, align 1, !tbaa !17
  %conv193 = zext i8 %126 to i32
  %127 = load i8, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.100, i32 0, i32 0), align 1, !tbaa !17
  %conv194 = zext i8 %127 to i32
  %sub195 = sub nsw i32 %conv193, %conv194
  store i32 %sub195, i32* %__result, align 4, !tbaa !5
  %128 = load i64, i64* %__s2_len, align 8, !tbaa !92
  %cmp196 = icmp ugt i64 %128, 0
  br i1 %cmp196, label %land.lhs.true.198, label %if.end.228

land.lhs.true.198:                                ; preds = %cond.true
  %129 = load i32, i32* %__result, align 4, !tbaa !5
  %cmp199 = icmp eq i32 %129, 0
  br i1 %cmp199, label %if.then.201, label %if.end.228

if.then.201:                                      ; preds = %land.lhs.true.198
  %130 = load i8*, i8** %__s1, align 8, !tbaa !1
  %arrayidx202 = getelementptr inbounds i8, i8* %130, i64 1
  %131 = load i8, i8* %arrayidx202, align 1, !tbaa !17
  %conv203 = zext i8 %131 to i32
  %132 = load i8, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.100, i32 0, i64 1), align 1, !tbaa !17
  %conv204 = zext i8 %132 to i32
  %sub205 = sub nsw i32 %conv203, %conv204
  store i32 %sub205, i32* %__result, align 4, !tbaa !5
  %133 = load i64, i64* %__s2_len, align 8, !tbaa !92
  %cmp206 = icmp ugt i64 %133, 1
  br i1 %cmp206, label %land.lhs.true.208, label %if.end.227

land.lhs.true.208:                                ; preds = %if.then.201
  %134 = load i32, i32* %__result, align 4, !tbaa !5
  %cmp209 = icmp eq i32 %134, 0
  br i1 %cmp209, label %if.then.211, label %if.end.227

if.then.211:                                      ; preds = %land.lhs.true.208
  %135 = load i8*, i8** %__s1, align 8, !tbaa !1
  %arrayidx212 = getelementptr inbounds i8, i8* %135, i64 2
  %136 = load i8, i8* %arrayidx212, align 1, !tbaa !17
  %conv213 = zext i8 %136 to i32
  %137 = load i8, i8* getelementptr inbounds (i8, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.100, i32 0, i32 0), i64 2), align 1, !tbaa !17
  %conv214 = zext i8 %137 to i32
  %sub215 = sub nsw i32 %conv213, %conv214
  store i32 %sub215, i32* %__result, align 4, !tbaa !5
  %138 = load i64, i64* %__s2_len, align 8, !tbaa !92
  %cmp216 = icmp ugt i64 %138, 2
  br i1 %cmp216, label %land.lhs.true.218, label %if.end.226

land.lhs.true.218:                                ; preds = %if.then.211
  %139 = load i32, i32* %__result, align 4, !tbaa !5
  %cmp219 = icmp eq i32 %139, 0
  br i1 %cmp219, label %if.then.221, label %if.end.226

if.then.221:                                      ; preds = %land.lhs.true.218
  %140 = load i8*, i8** %__s1, align 8, !tbaa !1
  %arrayidx222 = getelementptr inbounds i8, i8* %140, i64 3
  %141 = load i8, i8* %arrayidx222, align 1, !tbaa !17
  %conv223 = zext i8 %141 to i32
  %142 = load i8, i8* getelementptr inbounds (i8, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.100, i32 0, i32 0), i64 3), align 1, !tbaa !17
  %conv224 = zext i8 %142 to i32
  %sub225 = sub nsw i32 %conv223, %conv224
  store i32 %sub225, i32* %__result, align 4, !tbaa !5
  br label %if.end.226

if.end.226:                                       ; preds = %if.then.221, %land.lhs.true.218, %if.then.211
  br label %if.end.227

if.end.227:                                       ; preds = %if.end.226, %land.lhs.true.208, %if.then.201
  br label %if.end.228

if.end.228:                                       ; preds = %if.end.227, %land.lhs.true.198, %cond.true
  %143 = load i32, i32* %__result, align 4, !tbaa !5
  store i32 %143, i32* %tmp229, !tbaa !5
  %144 = bitcast i32* %__result to i8*
  call void @llvm.lifetime.end(i64 4, i8* %144) #1
  %145 = bitcast i8** %__s1 to i8*
  call void @llvm.lifetime.end(i64 8, i8* %145) #1
  %146 = load i32, i32* %tmp229, !tbaa !5
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true.186, %while.body
  %147 = load %struct.dirent*, %struct.dirent** %d, align 8, !tbaa !1
  %d_name230 = getelementptr inbounds %struct.dirent, %struct.dirent* %147, i32 0, i32 4
  %arraydecay231 = getelementptr inbounds [256 x i8], [256 x i8]* %d_name230, i32 0, i32 0
  %call232 = call i32 @strcmp(i8* %arraydecay231, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.100, i32 0, i32 0)) #1
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %if.end.228
  %cond = phi i32 [ %146, %if.end.228 ], [ %call232, %cond.false ]
  store i32 %cond, i32* %tmp, !tbaa !5
  %148 = bitcast i64* %__s2_len to i8*
  call void @llvm.lifetime.end(i64 8, i8* %148) #1
  %149 = bitcast i64* %__s1_len to i8*
  call void @llvm.lifetime.end(i64 8, i8* %149) #1
  %150 = load i32, i32* %tmp, !tbaa !5
  %cmp233 = icmp eq i32 %150, 0
  br i1 %cmp233, label %if.then.297, label %lor.lhs.false.235

lor.lhs.false.235:                                ; preds = %cond.end
  %151 = bitcast i64* %__s1_len237 to i8*
  call void @llvm.lifetime.start(i64 8, i8* %151) #1
  %152 = bitcast i64* %__s2_len239 to i8*
  call void @llvm.lifetime.start(i64 8, i8* %152) #1
  br i1 icmp eq (i64 sub (i64 ptrtoint (i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.279, i32 0, i64 1) to i64), i64 ptrtoint ([3 x i8]* @.str.279 to i64)), i64 1), label %land.lhs.true.241, label %cond.false.289

land.lhs.true.241:                                ; preds = %lor.lhs.false.235
  store i64 2, i64* %__s2_len239, align 8, !tbaa !92
  %153 = load i64, i64* %__s2_len239, align 8, !tbaa !92
  %cmp242 = icmp ult i64 %153, 4
  br i1 %cmp242, label %cond.true.244, label %cond.false.289

cond.true.244:                                    ; preds = %land.lhs.true.241
  %154 = bitcast i8** %__s1246 to i8*
  call void @llvm.lifetime.start(i64 8, i8* %154) #1
  %155 = load %struct.dirent*, %struct.dirent** %d, align 8, !tbaa !1
  %d_name247 = getelementptr inbounds %struct.dirent, %struct.dirent* %155, i32 0, i32 4
  %arraydecay248 = getelementptr inbounds [256 x i8], [256 x i8]* %d_name247, i32 0, i32 0
  store i8* %arraydecay248, i8** %__s1246, align 8, !tbaa !1
  %156 = bitcast i32* %__result250 to i8*
  call void @llvm.lifetime.start(i64 4, i8* %156) #1
  %157 = load i8*, i8** %__s1246, align 8, !tbaa !1
  %arrayidx251 = getelementptr inbounds i8, i8* %157, i64 0
  %158 = load i8, i8* %arrayidx251, align 1, !tbaa !17
  %conv252 = zext i8 %158 to i32
  %159 = load i8, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.279, i32 0, i32 0), align 1, !tbaa !17
  %conv253 = zext i8 %159 to i32
  %sub254 = sub nsw i32 %conv252, %conv253
  store i32 %sub254, i32* %__result250, align 4, !tbaa !5
  %160 = load i64, i64* %__s2_len239, align 8, !tbaa !92
  %cmp255 = icmp ugt i64 %160, 0
  br i1 %cmp255, label %land.lhs.true.257, label %if.end.287

land.lhs.true.257:                                ; preds = %cond.true.244
  %161 = load i32, i32* %__result250, align 4, !tbaa !5
  %cmp258 = icmp eq i32 %161, 0
  br i1 %cmp258, label %if.then.260, label %if.end.287

if.then.260:                                      ; preds = %land.lhs.true.257
  %162 = load i8*, i8** %__s1246, align 8, !tbaa !1
  %arrayidx261 = getelementptr inbounds i8, i8* %162, i64 1
  %163 = load i8, i8* %arrayidx261, align 1, !tbaa !17
  %conv262 = zext i8 %163 to i32
  %164 = load i8, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.279, i32 0, i64 1), align 1, !tbaa !17
  %conv263 = zext i8 %164 to i32
  %sub264 = sub nsw i32 %conv262, %conv263
  store i32 %sub264, i32* %__result250, align 4, !tbaa !5
  %165 = load i64, i64* %__s2_len239, align 8, !tbaa !92
  %cmp265 = icmp ugt i64 %165, 1
  br i1 %cmp265, label %land.lhs.true.267, label %if.end.286

land.lhs.true.267:                                ; preds = %if.then.260
  %166 = load i32, i32* %__result250, align 4, !tbaa !5
  %cmp268 = icmp eq i32 %166, 0
  br i1 %cmp268, label %if.then.270, label %if.end.286

if.then.270:                                      ; preds = %land.lhs.true.267
  %167 = load i8*, i8** %__s1246, align 8, !tbaa !1
  %arrayidx271 = getelementptr inbounds i8, i8* %167, i64 2
  %168 = load i8, i8* %arrayidx271, align 1, !tbaa !17
  %conv272 = zext i8 %168 to i32
  %169 = load i8, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.279, i32 0, i64 2), align 1, !tbaa !17
  %conv273 = zext i8 %169 to i32
  %sub274 = sub nsw i32 %conv272, %conv273
  store i32 %sub274, i32* %__result250, align 4, !tbaa !5
  %170 = load i64, i64* %__s2_len239, align 8, !tbaa !92
  %cmp275 = icmp ugt i64 %170, 2
  br i1 %cmp275, label %land.lhs.true.277, label %if.end.285

land.lhs.true.277:                                ; preds = %if.then.270
  %171 = load i32, i32* %__result250, align 4, !tbaa !5
  %cmp278 = icmp eq i32 %171, 0
  br i1 %cmp278, label %if.then.280, label %if.end.285

if.then.280:                                      ; preds = %land.lhs.true.277
  %172 = load i8*, i8** %__s1246, align 8, !tbaa !1
  %arrayidx281 = getelementptr inbounds i8, i8* %172, i64 3
  %173 = load i8, i8* %arrayidx281, align 1, !tbaa !17
  %conv282 = zext i8 %173 to i32
  %174 = load i8, i8* getelementptr inbounds (i8, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.279, i32 0, i32 0), i64 3), align 1, !tbaa !17
  %conv283 = zext i8 %174 to i32
  %sub284 = sub nsw i32 %conv282, %conv283
  store i32 %sub284, i32* %__result250, align 4, !tbaa !5
  br label %if.end.285

if.end.285:                                       ; preds = %if.then.280, %land.lhs.true.277, %if.then.270
  br label %if.end.286

if.end.286:                                       ; preds = %if.end.285, %land.lhs.true.267, %if.then.260
  br label %if.end.287

if.end.287:                                       ; preds = %if.end.286, %land.lhs.true.257, %cond.true.244
  %175 = load i32, i32* %__result250, align 4, !tbaa !5
  store i32 %175, i32* %tmp288, !tbaa !5
  %176 = bitcast i32* %__result250 to i8*
  call void @llvm.lifetime.end(i64 4, i8* %176) #1
  %177 = bitcast i8** %__s1246 to i8*
  call void @llvm.lifetime.end(i64 8, i8* %177) #1
  %178 = load i32, i32* %tmp288, !tbaa !5
  br label %cond.end.293

cond.false.289:                                   ; preds = %land.lhs.true.241, %lor.lhs.false.235
  %179 = load %struct.dirent*, %struct.dirent** %d, align 8, !tbaa !1
  %d_name290 = getelementptr inbounds %struct.dirent, %struct.dirent* %179, i32 0, i32 4
  %arraydecay291 = getelementptr inbounds [256 x i8], [256 x i8]* %d_name290, i32 0, i32 0
  %call292 = call i32 @strcmp(i8* %arraydecay291, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.279, i32 0, i32 0)) #1
  br label %cond.end.293

cond.end.293:                                     ; preds = %cond.false.289, %if.end.287
  %cond294 = phi i32 [ %178, %if.end.287 ], [ %call292, %cond.false.289 ]
  store i32 %cond294, i32* %tmp240, !tbaa !5
  %180 = bitcast i64* %__s2_len239 to i8*
  call void @llvm.lifetime.end(i64 8, i8* %180) #1
  %181 = bitcast i64* %__s1_len237 to i8*
  call void @llvm.lifetime.end(i64 8, i8* %181) #1
  %182 = load i32, i32* %tmp240, !tbaa !5
  %cmp295 = icmp eq i32 %182, 0
  br i1 %cmp295, label %if.then.297, label %if.end.298

if.then.297:                                      ; preds = %cond.end.293, %cond.end
  br label %while.cond

if.end.298:                                       ; preds = %cond.end.293
  %183 = load %struct.dirent*, %struct.dirent** %d, align 8, !tbaa !1
  %d_name299 = getelementptr inbounds %struct.dirent, %struct.dirent* %183, i32 0, i32 4
  %arraydecay300 = getelementptr inbounds [256 x i8], [256 x i8]* %d_name299, i32 0, i32 0
  %call301 = call i64 @strlen(i8* %arraydecay300) #14
  %conv302 = trunc i64 %call301 to i32
  store i32 %conv302, i32* %i, align 4, !tbaa !5
  %184 = load i32, i32* %i, align 4, !tbaa !5
  %185 = load i32, i32* %len, align 4, !tbaa !5
  %cmp303 = icmp slt i32 %184, %185
  br i1 %cmp303, label %if.then.312, label %lor.lhs.false.305

lor.lhs.false.305:                                ; preds = %if.end.298
  %186 = load %struct.dirent*, %struct.dirent** %d, align 8, !tbaa !1
  %d_name306 = getelementptr inbounds %struct.dirent, %struct.dirent* %186, i32 0, i32 4
  %arraydecay307 = getelementptr inbounds [256 x i8], [256 x i8]* %d_name306, i32 0, i32 0
  %187 = load i8*, i8** %cp, align 8, !tbaa !1
  %188 = load i32, i32* %len, align 4, !tbaa !5
  %conv308 = sext i32 %188 to i64
  %call309 = call i32 @strncmp(i8* %arraydecay307, i8* %187, i64 %conv308) #14
  %cmp310 = icmp ne i32 %call309, 0
  br i1 %cmp310, label %if.then.312, label %if.end.322

if.then.312:                                      ; preds = %lor.lhs.false.305, %if.end.298
  %189 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 41), align 1, !tbaa !17
  %conv313 = zext i8 %189 to i32
  %cmp314 = icmp sge i32 %conv313, 5
  br i1 %cmp314, label %land.lhs.true.316, label %if.end.321

land.lhs.true.316:                                ; preds = %if.then.312
  %190 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool317 = icmp ne i32 %190, 0
  br i1 %tobool317, label %if.end.321, label %if.then.318

if.then.318:                                      ; preds = %land.lhs.true.316
  %191 = load %struct.dirent*, %struct.dirent** %d, align 8, !tbaa !1
  %d_name319 = getelementptr inbounds %struct.dirent, %struct.dirent* %191, i32 0, i32 4
  %arraydecay320 = getelementptr inbounds [256 x i8], [256 x i8]* %d_name319, i32 0, i32 0
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.280, i32 0, i32 0), i8* %arraydecay320)
  br label %if.end.321

if.end.321:                                       ; preds = %if.then.318, %land.lhs.true.316, %if.then.312
  br label %while.cond

if.end.322:                                       ; preds = %lor.lhs.false.305
  %192 = load i32, i32* %off, align 4, !tbaa !5
  %conv323 = sext i32 %192 to i64
  %sub324 = sub i64 4096, %conv323
  %conv325 = trunc i64 %sub324 to i32
  store i32 %conv325, i32* %i, align 4, !tbaa !5
  %arraydecay326 = getelementptr inbounds [4096 x i8], [4096 x i8]* %relpath, i32 0, i32 0
  %193 = load i32, i32* %off, align 4, !tbaa !5
  %idx.ext327 = sext i32 %193 to i64
  %add.ptr328 = getelementptr inbounds i8, i8* %arraydecay326, i64 %idx.ext327
  %194 = load %struct.dirent*, %struct.dirent** %d, align 8, !tbaa !1
  %d_name329 = getelementptr inbounds %struct.dirent, %struct.dirent* %194, i32 0, i32 4
  %arraydecay330 = getelementptr inbounds [256 x i8], [256 x i8]* %d_name329, i32 0, i32 0
  %195 = load i32, i32* %i, align 4, !tbaa !5
  %conv331 = sext i32 %195 to i64
  %call332 = call i64 @sm_strlcpy(i8* %add.ptr328, i8* %arraydecay330, i64 %conv331)
  %196 = load i32, i32* %i, align 4, !tbaa !5
  %conv333 = sext i32 %196 to i64
  %cmp334 = icmp uge i64 %call332, %conv333
  br i1 %cmp334, label %if.then.336, label %if.end.337

if.then.336:                                      ; preds = %if.end.322
  br label %while.cond

if.end.337:                                       ; preds = %if.end.322
  %arraydecay338 = getelementptr inbounds [4096 x i8], [4096 x i8]* %relpath, i32 0, i32 0
  %197 = load i64, i64* %sff, align 8, !tbaa !92
  %call339 = call i32 @chkqdir(i8* %arraydecay338, i64 %197)
  %tobool340 = icmp ne i32 %call339, 0
  br i1 %tobool340, label %if.end.342, label %if.then.341

if.then.341:                                      ; preds = %if.end.337
  br label %while.cond

if.end.342:                                       ; preds = %if.end.337
  %198 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qpaths343 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %198, i32 0, i32 6
  %199 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths343, align 8, !tbaa !38
  %cmp344 = icmp eq %struct.qpaths_s* %199, null
  br i1 %cmp344, label %if.then.346, label %if.else

if.then.346:                                      ; preds = %if.end.342
  store i32 20, i32* %slotsleft, align 4, !tbaa !5
  %200 = load i32, i32* %slotsleft, align 4, !tbaa !5
  %conv347 = sext i32 %200 to i64
  %mul = mul i64 16, %conv347
  %conv348 = trunc i64 %mul to i32
  %call349 = call i8* @xalloc_tagged(i32 %conv348, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 6243)
  %201 = bitcast i8* %call349 to %struct.qpaths_s*
  %202 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qpaths350 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %202, i32 0, i32 6
  store %struct.qpaths_s* %201, %struct.qpaths_s** %qg_qpaths350, align 8, !tbaa !38
  %203 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_numqueues351 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %203, i32 0, i32 4
  store i32 0, i32* %qg_numqueues351, align 4, !tbaa !82
  br label %if.end.369

if.else:                                          ; preds = %if.end.342
  %204 = load i32, i32* %slotsleft, align 4, !tbaa !5
  %cmp352 = icmp slt i32 %204, 1
  br i1 %cmp352, label %if.then.354, label %if.end.368

if.then.354:                                      ; preds = %if.else
  %205 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qpaths355 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %205, i32 0, i32 6
  %206 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths355, align 8, !tbaa !38
  %207 = bitcast %struct.qpaths_s* %206 to i8*
  %208 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_numqueues356 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %208, i32 0, i32 4
  %209 = load i32, i32* %qg_numqueues356, align 4, !tbaa !82
  %add = add nsw i32 %209, 10
  %conv357 = sext i32 %add to i64
  %mul358 = mul i64 16, %conv357
  %call359 = call i8* @sm_realloc(i8* %207, i64 %mul358)
  %210 = bitcast i8* %call359 to %struct.qpaths_s*
  %211 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qpaths360 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %211, i32 0, i32 6
  store %struct.qpaths_s* %210, %struct.qpaths_s** %qg_qpaths360, align 8, !tbaa !38
  %212 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qpaths361 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %212, i32 0, i32 6
  %213 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths361, align 8, !tbaa !38
  %cmp362 = icmp eq %struct.qpaths_s* %213, null
  br i1 %cmp362, label %if.then.364, label %if.end.366

if.then.364:                                      ; preds = %if.then.354
  %214 = load %struct.__dirstream*, %struct.__dirstream** %dp, align 8, !tbaa !1
  %call365 = call i32 @closedir(%struct.__dirstream* %214)
  %215 = load i32, i32* %qn.addr, align 4, !tbaa !5
  store i32 %215, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.366:                                       ; preds = %if.then.354
  %216 = load i32, i32* %slotsleft, align 4, !tbaa !5
  %add367 = add nsw i32 %216, 10
  store i32 %add367, i32* %slotsleft, align 4, !tbaa !5
  br label %if.end.368

if.end.368:                                       ; preds = %if.end.366, %if.else
  br label %if.end.369

if.end.369:                                       ; preds = %if.end.368, %if.then.346
  %217 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_numqueues370 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %217, i32 0, i32 4
  %218 = load i32, i32* %qg_numqueues370, align 4, !tbaa !82
  %idxprom371 = sext i32 %218 to i64
  %219 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qpaths372 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %219, i32 0, i32 6
  %220 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths372, align 8, !tbaa !38
  %arrayidx373 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %220, i64 %idxprom371
  %qp_subdirs = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %arrayidx373, i32 0, i32 1
  store i16 0, i16* %qp_subdirs, align 2, !tbaa !83
  %arraydecay374 = getelementptr inbounds [4096 x i8], [4096 x i8]* %subdir, i32 0, i32 0
  %arraydecay375 = getelementptr inbounds [4096 x i8], [4096 x i8]* %relpath, i32 0, i32 0
  %call376 = call i64 (i8*, i64, i32, ...) @sm_strlcpyn(i8* %arraydecay374, i64 4096, i32 3, i8* %arraydecay375, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.111, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.281, i32 0, i32 0))
  %arraydecay377 = getelementptr inbounds [4096 x i8], [4096 x i8]* %subdir, i32 0, i32 0
  %221 = load i64, i64* %sff, align 8, !tbaa !92
  %call378 = call i32 @chkqdir(i8* %arraydecay377, i64 %221)
  %tobool379 = icmp ne i32 %call378, 0
  br i1 %tobool379, label %if.then.380, label %if.else.389

if.then.380:                                      ; preds = %if.end.369
  %222 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_numqueues381 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %222, i32 0, i32 4
  %223 = load i32, i32* %qg_numqueues381, align 4, !tbaa !82
  %idxprom382 = sext i32 %223 to i64
  %224 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qpaths383 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %224, i32 0, i32 6
  %225 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths383, align 8, !tbaa !38
  %arrayidx384 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %225, i64 %idxprom382
  %qp_subdirs385 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %arrayidx384, i32 0, i32 1
  %226 = load i16, i16* %qp_subdirs385, align 2, !tbaa !83
  %conv386 = sext i16 %226 to i32
  %or387 = or i32 %conv386, 2
  %conv388 = trunc i32 %or387 to i16
  store i16 %conv388, i16* %qp_subdirs385, align 2, !tbaa !83
  br label %if.end.390

if.else.389:                                      ; preds = %if.end.369
  br label %if.end.390

if.end.390:                                       ; preds = %if.else.389, %if.then.380
  %arraydecay391 = getelementptr inbounds [4096 x i8], [4096 x i8]* %subdir, i32 0, i32 0
  %arraydecay392 = getelementptr inbounds [4096 x i8], [4096 x i8]* %relpath, i32 0, i32 0
  %call393 = call i64 (i8*, i64, i32, ...) @sm_strlcpyn(i8* %arraydecay391, i64 4096, i32 3, i8* %arraydecay392, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.111, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.282, i32 0, i32 0))
  %arraydecay394 = getelementptr inbounds [4096 x i8], [4096 x i8]* %subdir, i32 0, i32 0
  %227 = load i64, i64* %sff, align 8, !tbaa !92
  %call395 = call i32 @chkqdir(i8* %arraydecay394, i64 %227)
  %tobool396 = icmp ne i32 %call395, 0
  br i1 %tobool396, label %if.then.397, label %if.else.406

if.then.397:                                      ; preds = %if.end.390
  %228 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_numqueues398 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %228, i32 0, i32 4
  %229 = load i32, i32* %qg_numqueues398, align 4, !tbaa !82
  %idxprom399 = sext i32 %229 to i64
  %230 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qpaths400 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %230, i32 0, i32 6
  %231 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths400, align 8, !tbaa !38
  %arrayidx401 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %231, i64 %idxprom399
  %qp_subdirs402 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %arrayidx401, i32 0, i32 1
  %232 = load i16, i16* %qp_subdirs402, align 2, !tbaa !83
  %conv403 = sext i16 %232 to i32
  %or404 = or i32 %conv403, 1
  %conv405 = trunc i32 %or404 to i16
  store i16 %conv405, i16* %qp_subdirs402, align 2, !tbaa !83
  br label %if.end.407

if.else.406:                                      ; preds = %if.end.390
  br label %if.end.407

if.end.407:                                       ; preds = %if.else.406, %if.then.397
  %arraydecay408 = getelementptr inbounds [4096 x i8], [4096 x i8]* %subdir, i32 0, i32 0
  %arraydecay409 = getelementptr inbounds [4096 x i8], [4096 x i8]* %relpath, i32 0, i32 0
  %call410 = call i64 (i8*, i64, i32, ...) @sm_strlcpyn(i8* %arraydecay408, i64 4096, i32 3, i8* %arraydecay409, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.111, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.283, i32 0, i32 0))
  %arraydecay411 = getelementptr inbounds [4096 x i8], [4096 x i8]* %subdir, i32 0, i32 0
  %233 = load i64, i64* %sff, align 8, !tbaa !92
  %call412 = call i32 @chkqdir(i8* %arraydecay411, i64 %233)
  %tobool413 = icmp ne i32 %call412, 0
  br i1 %tobool413, label %if.then.414, label %if.else.423

if.then.414:                                      ; preds = %if.end.407
  %234 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_numqueues415 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %234, i32 0, i32 4
  %235 = load i32, i32* %qg_numqueues415, align 4, !tbaa !82
  %idxprom416 = sext i32 %235 to i64
  %236 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qpaths417 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %236, i32 0, i32 6
  %237 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths417, align 8, !tbaa !38
  %arrayidx418 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %237, i64 %idxprom416
  %qp_subdirs419 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %arrayidx418, i32 0, i32 1
  %238 = load i16, i16* %qp_subdirs419, align 2, !tbaa !83
  %conv420 = sext i16 %238 to i32
  %or421 = or i32 %conv420, 4
  %conv422 = trunc i32 %or421 to i16
  store i16 %conv422, i16* %qp_subdirs419, align 2, !tbaa !83
  br label %if.end.424

if.else.423:                                      ; preds = %if.end.407
  br label %if.end.424

if.end.424:                                       ; preds = %if.else.423, %if.then.414
  %arrayidx425 = getelementptr inbounds [4096 x i8], [4096 x i8]* %prefix, i32 0, i64 0
  %239 = load i8, i8* %arrayidx425, align 1, !tbaa !17
  %conv426 = sext i8 %239 to i32
  %cmp427 = icmp ne i32 %conv426, 46
  br i1 %cmp427, label %if.then.429, label %if.else.437

if.then.429:                                      ; preds = %if.end.424
  %arraydecay430 = getelementptr inbounds [4096 x i8], [4096 x i8]* %relpath, i32 0, i32 0
  %call431 = call i8* @newstr(i8* %arraydecay430)
  %240 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_numqueues432 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %240, i32 0, i32 4
  %241 = load i32, i32* %qg_numqueues432, align 4, !tbaa !82
  %idxprom433 = sext i32 %241 to i64
  %242 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qpaths434 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %242, i32 0, i32 6
  %243 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths434, align 8, !tbaa !38
  %arrayidx435 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %243, i64 %idxprom433
  %qp_name436 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %arrayidx435, i32 0, i32 0
  store i8* %call431, i8** %qp_name436, align 8, !tbaa !40
  br label %if.end.446

if.else.437:                                      ; preds = %if.end.424
  %244 = load %struct.dirent*, %struct.dirent** %d, align 8, !tbaa !1
  %d_name438 = getelementptr inbounds %struct.dirent, %struct.dirent* %244, i32 0, i32 4
  %arraydecay439 = getelementptr inbounds [256 x i8], [256 x i8]* %d_name438, i32 0, i32 0
  %call440 = call i8* @newstr(i8* %arraydecay439)
  %245 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_numqueues441 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %245, i32 0, i32 4
  %246 = load i32, i32* %qg_numqueues441, align 4, !tbaa !82
  %idxprom442 = sext i32 %246 to i64
  %247 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qpaths443 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %247, i32 0, i32 6
  %248 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths443, align 8, !tbaa !38
  %arrayidx444 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %248, i64 %idxprom442
  %qp_name445 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %arrayidx444, i32 0, i32 0
  store i8* %call440, i8** %qp_name445, align 8, !tbaa !40
  br label %if.end.446

if.end.446:                                       ; preds = %if.else.437, %if.then.429
  %249 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 41), align 1, !tbaa !17
  %conv447 = zext i8 %249 to i32
  %cmp448 = icmp sge i32 %conv447, 2
  br i1 %cmp448, label %land.lhs.true.450, label %if.end.461

land.lhs.true.450:                                ; preds = %if.end.446
  %250 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool451 = icmp ne i32 %250, 0
  br i1 %tobool451, label %if.end.461, label %if.then.452

if.then.452:                                      ; preds = %land.lhs.true.450
  %251 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_numqueues453 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %251, i32 0, i32 4
  %252 = load i32, i32* %qg_numqueues453, align 4, !tbaa !82
  %arraydecay454 = getelementptr inbounds [4096 x i8], [4096 x i8]* %relpath, i32 0, i32 0
  %253 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_numqueues455 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %253, i32 0, i32 4
  %254 = load i32, i32* %qg_numqueues455, align 4, !tbaa !82
  %idxprom456 = sext i32 %254 to i64
  %255 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qpaths457 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %255, i32 0, i32 6
  %256 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths457, align 8, !tbaa !38
  %arrayidx458 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %256, i64 %idxprom456
  %qp_subdirs459 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %arrayidx458, i32 0, i32 1
  %257 = load i16, i16* %qp_subdirs459, align 2, !tbaa !83
  %conv460 = sext i16 %257 to i32
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.284, i32 0, i32 0), i32 %252, i8* %arraydecay454, i32 %conv460)
  br label %if.end.461

if.end.461:                                       ; preds = %if.then.452, %land.lhs.true.450, %if.end.446
  %258 = load i32, i32* %qn.addr, align 4, !tbaa !5
  %259 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_numqueues462 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %259, i32 0, i32 4
  %260 = load i32, i32* %qg_numqueues462, align 4, !tbaa !82
  %idxprom463 = sext i32 %260 to i64
  %261 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qpaths464 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %261, i32 0, i32 6
  %262 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths464, align 8, !tbaa !38
  %arrayidx465 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %262, i64 %idxprom463
  %qp_idx = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %arrayidx465, i32 0, i32 3
  store i32 %258, i32* %qp_idx, align 4, !tbaa !84
  %arraydecay466 = getelementptr inbounds [4096 x i8], [4096 x i8]* %relpath, i32 0, i32 0
  %263 = load i32*, i32** %phash.addr, align 8, !tbaa !1
  %264 = load i32, i32* %263, align 4, !tbaa !5
  %call467 = call i32 @hash_q(i8* %arraydecay466, i32 %264)
  %265 = load i32*, i32** %phash.addr, align 8, !tbaa !1
  store i32 %call467, i32* %265, align 4, !tbaa !5
  %266 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_numqueues468 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %266, i32 0, i32 4
  %267 = load i32, i32* %qg_numqueues468, align 4, !tbaa !82
  %inc469 = add nsw i32 %267, 1
  store i32 %inc469, i32* %qg_numqueues468, align 4, !tbaa !82
  %268 = load i32, i32* %qn.addr, align 4, !tbaa !5
  %inc470 = add nsw i32 %268, 1
  store i32 %inc470, i32* %qn.addr, align 4, !tbaa !5
  %269 = load i32, i32* %slotsleft, align 4, !tbaa !5
  %dec = add nsw i32 %269, -1
  store i32 %dec, i32* %slotsleft, align 4, !tbaa !5
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %270 = load %struct.__dirstream*, %struct.__dirstream** %dp, align 8, !tbaa !1
  %call471 = call i32 @closedir(%struct.__dirstream* %270)
  %271 = load i8*, i8** %delim, align 8, !tbaa !1
  store i8 47, i8* %271, align 1, !tbaa !17
  store i32 0, i32* %cleanup.dest.slot
  br label %cleanup

cleanup:                                          ; preds = %while.end, %if.then.364, %if.end.181, %if.end.110
  %272 = bitcast [4096 x i8]* %relpath to i8*
  call void @llvm.lifetime.end(i64 4096, i8* %272) #1
  %273 = bitcast i8** %delim to i8*
  call void @llvm.lifetime.end(i64 8, i8* %273) #1
  %274 = bitcast i32* %off to i8*
  call void @llvm.lifetime.end(i64 4, i8* %274) #1
  %275 = bitcast %struct.dirent** %d to i8*
  call void @llvm.lifetime.end(i64 8, i8* %275) #1
  %276 = bitcast %struct.__dirstream** %dp to i8*
  call void @llvm.lifetime.end(i64 8, i8* %276) #1
  %cleanup.dest = load i32, i32* %cleanup.dest.slot
  switch i32 %cleanup.dest, label %cleanup.589 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %if.end.476

if.end.476:                                       ; preds = %cleanup.cont, %lor.end.89
  %277 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_numqueues477 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %277, i32 0, i32 4
  %278 = load i32, i32* %qg_numqueues477, align 4, !tbaa !82
  %cmp478 = icmp eq i32 %278, 0
  br i1 %cmp478, label %if.then.480, label %if.end.588

if.then.480:                                      ; preds = %if.end.476
  %call481 = call i8* @xalloc_tagged(i32 16, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 6303)
  %279 = bitcast i8* %call481 to %struct.qpaths_s*
  %280 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qpaths482 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %280, i32 0, i32 6
  store %struct.qpaths_s* %279, %struct.qpaths_s** %qg_qpaths482, align 8, !tbaa !38
  %arraydecay483 = getelementptr inbounds [4096 x i8], [4096 x i8]* %qpath, i32 0, i32 0
  %281 = load i32, i32* @RunAsUid, align 4, !tbaa !5
  %282 = load i32, i32* @RunAsGid, align 4, !tbaa !5
  %283 = load i64, i64* %sff, align 8, !tbaa !92
  %call484 = call i32 @safedirpath(i8* %arraydecay483, i32 %281, i32 %282, i8* null, i64 %283, i32 0, i32 0)
  store i32 %call484, i32* %i, align 4, !tbaa !5
  %284 = load i32, i32* %i, align 4, !tbaa !5
  %cmp485 = icmp eq i32 %284, 2
  br i1 %cmp485, label %if.then.487, label %if.end.498

if.then.487:                                      ; preds = %if.then.480
  %arraydecay488 = getelementptr inbounds [4096 x i8], [4096 x i8]* %qpath, i32 0, i32 0
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.285, i32 0, i32 0), i8* %arraydecay488)
  %285 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 41), align 1, !tbaa !17
  %conv489 = zext i8 %285 to i32
  %cmp490 = icmp sge i32 %conv489, 2
  br i1 %cmp490, label %land.lhs.true.492, label %if.end.497

land.lhs.true.492:                                ; preds = %if.then.487
  %286 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool493 = icmp ne i32 %286, 0
  br i1 %tobool493, label %if.end.497, label %if.then.494

if.then.494:                                      ; preds = %land.lhs.true.492
  %arraydecay495 = getelementptr inbounds [4096 x i8], [4096 x i8]* %qpath, i32 0, i32 0
  %287 = load i32, i32* %i, align 4, !tbaa !5
  %call496 = call i8* @sm_errstring(i32 %287)
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.286, i32 0, i32 0), i8* %arraydecay495, i8* %call496)
  br label %if.end.497

if.end.497:                                       ; preds = %if.then.494, %land.lhs.true.492, %if.then.487
  store i32 78, i32* @ExitStat, align 4, !tbaa !5
  %288 = load i32, i32* %qn.addr, align 4, !tbaa !5
  store i32 %288, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup.589

if.end.498:                                       ; preds = %if.then.480
  %289 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qpaths499 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %289, i32 0, i32 6
  %290 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths499, align 8, !tbaa !38
  %arrayidx500 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %290, i64 0
  %qp_subdirs501 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %arrayidx500, i32 0, i32 1
  store i16 0, i16* %qp_subdirs501, align 2, !tbaa !83
  %291 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_numqueues502 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %291, i32 0, i32 4
  store i32 1, i32* %qg_numqueues502, align 4, !tbaa !82
  %arraydecay503 = getelementptr inbounds [4096 x i8], [4096 x i8]* %subdir, i32 0, i32 0
  %292 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qdir504 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %292, i32 0, i32 1
  %293 = load i8*, i8** %qg_qdir504, align 8, !tbaa !94
  %call505 = call i64 (i8*, i64, i32, ...) @sm_strlcpyn(i8* %arraydecay503, i64 4096, i32 3, i8* %293, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.111, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.281, i32 0, i32 0))
  %arraydecay506 = getelementptr inbounds [4096 x i8], [4096 x i8]* %subdir, i32 0, i32 0
  %294 = load i64, i64* %sff, align 8, !tbaa !92
  %call507 = call i32 @chkqdir(i8* %arraydecay506, i64 %294)
  %tobool508 = icmp ne i32 %call507, 0
  br i1 %tobool508, label %if.then.509, label %if.else.516

if.then.509:                                      ; preds = %if.end.498
  %295 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qpaths510 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %295, i32 0, i32 6
  %296 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths510, align 8, !tbaa !38
  %arrayidx511 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %296, i64 0
  %qp_subdirs512 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %arrayidx511, i32 0, i32 1
  %297 = load i16, i16* %qp_subdirs512, align 2, !tbaa !83
  %conv513 = sext i16 %297 to i32
  %or514 = or i32 %conv513, 2
  %conv515 = trunc i32 %or514 to i16
  store i16 %conv515, i16* %qp_subdirs512, align 2, !tbaa !83
  br label %if.end.517

if.else.516:                                      ; preds = %if.end.498
  br label %if.end.517

if.end.517:                                       ; preds = %if.else.516, %if.then.509
  %arraydecay518 = getelementptr inbounds [4096 x i8], [4096 x i8]* %subdir, i32 0, i32 0
  %298 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qdir519 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %298, i32 0, i32 1
  %299 = load i8*, i8** %qg_qdir519, align 8, !tbaa !94
  %call520 = call i64 (i8*, i64, i32, ...) @sm_strlcpyn(i8* %arraydecay518, i64 4096, i32 3, i8* %299, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.111, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.282, i32 0, i32 0))
  %arraydecay521 = getelementptr inbounds [4096 x i8], [4096 x i8]* %subdir, i32 0, i32 0
  %300 = load i64, i64* %sff, align 8, !tbaa !92
  %call522 = call i32 @chkqdir(i8* %arraydecay521, i64 %300)
  %tobool523 = icmp ne i32 %call522, 0
  br i1 %tobool523, label %if.then.524, label %if.else.531

if.then.524:                                      ; preds = %if.end.517
  %301 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qpaths525 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %301, i32 0, i32 6
  %302 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths525, align 8, !tbaa !38
  %arrayidx526 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %302, i64 0
  %qp_subdirs527 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %arrayidx526, i32 0, i32 1
  %303 = load i16, i16* %qp_subdirs527, align 2, !tbaa !83
  %conv528 = sext i16 %303 to i32
  %or529 = or i32 %conv528, 1
  %conv530 = trunc i32 %or529 to i16
  store i16 %conv530, i16* %qp_subdirs527, align 2, !tbaa !83
  br label %if.end.532

if.else.531:                                      ; preds = %if.end.517
  br label %if.end.532

if.end.532:                                       ; preds = %if.else.531, %if.then.524
  %arraydecay533 = getelementptr inbounds [4096 x i8], [4096 x i8]* %subdir, i32 0, i32 0
  %304 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qdir534 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %304, i32 0, i32 1
  %305 = load i8*, i8** %qg_qdir534, align 8, !tbaa !94
  %call535 = call i64 (i8*, i64, i32, ...) @sm_strlcpyn(i8* %arraydecay533, i64 4096, i32 3, i8* %305, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.111, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.283, i32 0, i32 0))
  %arraydecay536 = getelementptr inbounds [4096 x i8], [4096 x i8]* %subdir, i32 0, i32 0
  %306 = load i64, i64* %sff, align 8, !tbaa !92
  %call537 = call i32 @chkqdir(i8* %arraydecay536, i64 %306)
  %tobool538 = icmp ne i32 %call537, 0
  br i1 %tobool538, label %if.then.539, label %if.else.546

if.then.539:                                      ; preds = %if.end.532
  %307 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qpaths540 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %307, i32 0, i32 6
  %308 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths540, align 8, !tbaa !38
  %arrayidx541 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %308, i64 0
  %qp_subdirs542 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %arrayidx541, i32 0, i32 1
  %309 = load i16, i16* %qp_subdirs542, align 2, !tbaa !83
  %conv543 = sext i16 %309 to i32
  %or544 = or i32 %conv543, 4
  %conv545 = trunc i32 %or544 to i16
  store i16 %conv545, i16* %qp_subdirs542, align 2, !tbaa !83
  br label %if.end.547

if.else.546:                                      ; preds = %if.end.532
  br label %if.end.547

if.end.547:                                       ; preds = %if.else.546, %if.then.539
  %310 = load i32, i32* %blen.addr, align 4, !tbaa !5
  %sub548 = sub nsw i32 %310, 1
  %idxprom549 = sext i32 %sub548 to i64
  %311 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qdir550 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %311, i32 0, i32 1
  %312 = load i8*, i8** %qg_qdir550, align 8, !tbaa !94
  %arrayidx551 = getelementptr inbounds i8, i8* %312, i64 %idxprom549
  %313 = load i8, i8* %arrayidx551, align 1, !tbaa !17
  %conv552 = sext i8 %313 to i32
  %cmp553 = icmp ne i32 %conv552, 0
  br i1 %cmp553, label %land.lhs.true.555, label %if.else.574

land.lhs.true.555:                                ; preds = %if.end.547
  %314 = load i32, i32* %blen.addr, align 4, !tbaa !5
  %idxprom556 = sext i32 %314 to i64
  %315 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qdir557 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %315, i32 0, i32 1
  %316 = load i8*, i8** %qg_qdir557, align 8, !tbaa !94
  %arrayidx558 = getelementptr inbounds i8, i8* %316, i64 %idxprom556
  %317 = load i8, i8* %arrayidx558, align 1, !tbaa !17
  %conv559 = sext i8 %317 to i32
  %cmp560 = icmp ne i32 %conv559, 0
  br i1 %cmp560, label %if.then.562, label %if.else.574

if.then.562:                                      ; preds = %land.lhs.true.555
  %318 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qdir563 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %318, i32 0, i32 1
  %319 = load i8*, i8** %qg_qdir563, align 8, !tbaa !94
  %320 = load i32, i32* %blen.addr, align 4, !tbaa !5
  %idx.ext564 = sext i32 %320 to i64
  %add.ptr565 = getelementptr inbounds i8, i8* %319, i64 %idx.ext564
  %call566 = call i8* @newstr(i8* %add.ptr565)
  %321 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qpaths567 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %321, i32 0, i32 6
  %322 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths567, align 8, !tbaa !38
  %arrayidx568 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %322, i64 0
  %qp_name569 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %arrayidx568, i32 0, i32 0
  store i8* %call566, i8** %qp_name569, align 8, !tbaa !40
  %323 = load i32, i32* %blen.addr, align 4, !tbaa !5
  %sub570 = sub nsw i32 %323, 1
  %idxprom571 = sext i32 %sub570 to i64
  %324 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qdir572 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %324, i32 0, i32 1
  %325 = load i8*, i8** %qg_qdir572, align 8, !tbaa !94
  %arrayidx573 = getelementptr inbounds i8, i8* %325, i64 %idxprom571
  store i8 0, i8* %arrayidx573, align 1, !tbaa !17
  br label %if.end.579

if.else.574:                                      ; preds = %land.lhs.true.555, %if.end.547
  %call575 = call i8* @newstr(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.100, i32 0, i32 0))
  %326 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qpaths576 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %326, i32 0, i32 6
  %327 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths576, align 8, !tbaa !38
  %arrayidx577 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %327, i64 0
  %qp_name578 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %arrayidx577, i32 0, i32 0
  store i8* %call575, i8** %qp_name578, align 8, !tbaa !40
  br label %if.end.579

if.end.579:                                       ; preds = %if.else.574, %if.then.562
  %328 = load i32, i32* %qn.addr, align 4, !tbaa !5
  %329 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qpaths580 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %329, i32 0, i32 6
  %330 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths580, align 8, !tbaa !38
  %arrayidx581 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %330, i64 0
  %qp_idx582 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %arrayidx581, i32 0, i32 3
  store i32 %328, i32* %qp_idx582, align 4, !tbaa !84
  %331 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qpaths583 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %331, i32 0, i32 6
  %332 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths583, align 8, !tbaa !38
  %arrayidx584 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %332, i64 0
  %qp_name585 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %arrayidx584, i32 0, i32 0
  %333 = load i8*, i8** %qp_name585, align 8, !tbaa !40
  %334 = load i32*, i32** %phash.addr, align 8, !tbaa !1
  %335 = load i32, i32* %334, align 4, !tbaa !5
  %call586 = call i32 @hash_q(i8* %333, i32 %335)
  %336 = load i32*, i32** %phash.addr, align 8, !tbaa !1
  store i32 %call586, i32* %336, align 4, !tbaa !5
  %337 = load i32, i32* %qn.addr, align 4, !tbaa !5
  %inc587 = add nsw i32 %337, 1
  store i32 %inc587, i32* %qn.addr, align 4, !tbaa !5
  br label %if.end.588

if.end.588:                                       ; preds = %if.end.579, %if.end.476
  %338 = load i32, i32* %qn.addr, align 4, !tbaa !5
  store i32 %338, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup.589

cleanup.589:                                      ; preds = %if.end.588, %if.end.497, %cleanup, %if.then.77, %if.then.59, %if.then.42, %if.then.34
  %339 = bitcast [4096 x i8]* %prefix to i8*
  call void @llvm.lifetime.end(i64 4096, i8* %339) #1
  %340 = bitcast [4096 x i8]* %subdir to i8*
  call void @llvm.lifetime.end(i64 4096, i8* %340) #1
  %341 = bitcast [4096 x i8]* %qpath to i8*
  call void @llvm.lifetime.end(i64 4096, i8* %341) #1
  %342 = bitcast i64* %sff to i8*
  call void @llvm.lifetime.end(i64 8, i8* %342) #1
  %343 = bitcast i32* %slotsleft to i8*
  call void @llvm.lifetime.end(i64 4, i8* %343) #1
  %344 = bitcast i32* %len to i8*
  call void @llvm.lifetime.end(i64 4, i8* %344) #1
  %345 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end(i64 4, i8* %345) #1
  %346 = bitcast i8** %cp to i8*
  call void @llvm.lifetime.end(i64 8, i8* %346) #1
  %347 = load i32, i32* %retval
  ret i32 %347
}

; Function Attrs: nounwind uwtable
define internal void @init_shm(i32 %qn, i32 %owner, i32 %hash) #0 {
entry:
  %qn.addr = alloca i32, align 4
  %owner.addr = alloca i32, align 4
  %hash.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %count = alloca i32, align 4
  %save_errno = alloca i32, align 4
  %keyselect = alloca i32, align 4
  %cleanup.dest.slot = alloca i32
  %p = alloca i32*, align 8
  store i32 %qn, i32* %qn.addr, align 4, !tbaa !5
  store i32 %owner, i32* %owner.addr, align 4, !tbaa !5
  store i32 %hash, i32* %hash.addr, align 4, !tbaa !5
  %0 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start(i64 4, i8* %0) #1
  %1 = bitcast i32* %count to i8*
  call void @llvm.lifetime.start(i64 4, i8* %1) #1
  %2 = bitcast i32* %save_errno to i8*
  call void @llvm.lifetime.start(i64 4, i8* %2) #1
  %3 = bitcast i32* %keyselect to i8*
  call void @llvm.lifetime.start(i64 4, i8* %3) #1
  store %struct.filesys_shared* getelementptr inbounds ([256 x %struct.filesys_shared], [256 x %struct.filesys_shared]* @FileSys, i32 0, i64 0), %struct.filesys_shared** @PtrFileSys, align 8, !tbaa !1
  store i32* @Numfilesys, i32** @PNumFileSys, align 8, !tbaa !1
  %4 = load i32, i32* @ShmKey, align 4, !tbaa !5
  %cmp = icmp eq i32 %4, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup.116

if.end:                                           ; preds = %entry
  store i32 0, i32* %count, align 4, !tbaa !5
  %5 = load i32, i32* %qn.addr, align 4, !tbaa !5
  %conv = sext i32 %5 to i64
  %mul = mul i64 %conv, 4
  %add = add i64 6164, %mul
  store i64 %add, i64* @shms, align 8, !tbaa !92
  %6 = load i32, i32* @ShmKey, align 4, !tbaa !5
  %cmp1 = icmp eq i32 %6, -1
  %conv2 = zext i1 %cmp1 to i32
  store i32 %conv2, i32* %keyselect, align 4, !tbaa !5
  %7 = load i32, i32* %keyselect, align 4, !tbaa !5
  %tobool = icmp ne i32 %7, 0
  br i1 %tobool, label %if.then.3, label %if.end.18

if.then.3:                                        ; preds = %if.end
  %8 = load i32, i32* %owner.addr, align 4, !tbaa !5
  %tobool4 = icmp ne i32 %8, 0
  br i1 %tobool4, label %if.then.5, label %if.else

if.then.5:                                        ; preds = %if.then.3
  store i32 25, i32* @ShmKey, align 4, !tbaa !5
  br label %if.end.17

if.else:                                          ; preds = %if.then.3
  %call = call i32* @__errno_location() #11
  store i32 0, i32* %call, align 4, !tbaa !5
  %9 = load i8*, i8** @ShmKeyFile, align 8, !tbaa !1
  %10 = load i32, i32* @ShmKey, align 4, !tbaa !5
  %conv6 = sext i32 %10 to i64
  %call7 = call i64 @read_key_file(i8* %9, i64 %conv6)
  %conv8 = trunc i64 %call7 to i32
  store i32 %conv8, i32* @ShmKey, align 4, !tbaa !5
  store i32 0, i32* %keyselect, align 4, !tbaa !5
  %11 = load i32, i32* @ShmKey, align 4, !tbaa !5
  %cmp9 = icmp eq i32 %11, -1
  br i1 %cmp9, label %if.then.11, label %if.end.16

if.then.11:                                       ; preds = %if.else
  %call12 = call i32* @__errno_location() #11
  %12 = load i32, i32* %call12, align 4, !tbaa !5
  %cmp13 = icmp ne i32 %12, 0
  br i1 %cmp13, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.11
  %call15 = call i32* @__errno_location() #11
  %13 = load i32, i32* %call15, align 4, !tbaa !5
  br label %cond.end

cond.false:                                       ; preds = %if.then.11
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %13, %cond.true ], [ 22, %cond.false ]
  store i32 %cond, i32* %save_errno, align 4, !tbaa !5
  br label %error

if.end.16:                                        ; preds = %if.else
  br label %if.end.17

if.end.17:                                        ; preds = %if.end.16, %if.then.5
  br label %if.end.18

if.end.18:                                        ; preds = %if.end.17, %if.end
  br label %for.cond

for.cond:                                         ; preds = %if.end.46, %if.end.37, %if.end.18
  %14 = load i32, i32* @ShmKey, align 4, !tbaa !5
  %15 = load i64, i64* @shms, align 8, !tbaa !92
  %conv19 = trunc i64 %15 to i32
  %16 = load i32, i32* %owner.addr, align 4, !tbaa !5
  %call20 = call i8* @sm_shmstart(i32 %14, i32 %conv19, i32 432, i32* @ShmId, i32 %16)
  store i8* %call20, i8** @Pshm, align 8, !tbaa !1
  %call21 = call i32* @__errno_location() #11
  %17 = load i32, i32* %call21, align 4, !tbaa !5
  store i32 %17, i32* %save_errno, align 4, !tbaa !5
  %18 = load i8*, i8** @Pshm, align 8, !tbaa !1
  %cmp22 = icmp ne i8* %18, null
  br i1 %cmp22, label %if.then.26, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.cond
  %19 = load i32, i32* %save_errno, align 4, !tbaa !5
  %cmp24 = icmp eq i32 %19, 17
  br i1 %cmp24, label %if.end.27, label %if.then.26

if.then.26:                                       ; preds = %lor.lhs.false, %for.cond
  br label %for.end

if.end.27:                                        ; preds = %lor.lhs.false
  %20 = load i32, i32* %count, align 4, !tbaa !5
  %inc = add nsw i32 %20, 1
  store i32 %inc, i32* %count, align 4, !tbaa !5
  %cmp28 = icmp sge i32 %inc, 3
  br i1 %cmp28, label %if.then.30, label %if.end.39

if.then.30:                                       ; preds = %if.end.27
  %21 = load i32, i32* %keyselect, align 4, !tbaa !5
  %tobool31 = icmp ne i32 %21, 0
  br i1 %tobool31, label %if.then.32, label %if.end.38

if.then.32:                                       ; preds = %if.then.30
  %22 = load i32, i32* @ShmKey, align 4, !tbaa !5
  %inc33 = add nsw i32 %22, 1
  store i32 %inc33, i32* @ShmKey, align 4, !tbaa !5
  %23 = load i32, i32* @ShmKey, align 4, !tbaa !5
  %cmp34 = icmp eq i32 %23, -1
  br i1 %cmp34, label %if.then.36, label %if.end.37

if.then.36:                                       ; preds = %if.then.32
  br label %for.end

if.end.37:                                        ; preds = %if.then.32
  br label %for.cond

if.end.38:                                        ; preds = %if.then.30
  br label %for.end

if.end.39:                                        ; preds = %if.end.27
  %24 = load i32, i32* %keyselect, align 4, !tbaa !5
  %tobool40 = icmp ne i32 %24, 0
  br i1 %tobool40, label %lor.lhs.false.41, label %if.then.44

lor.lhs.false.41:                                 ; preds = %if.end.39
  %25 = load i32, i32* @ShmKey, align 4, !tbaa !5
  %cmp42 = icmp eq i32 %25, -1
  br i1 %cmp42, label %if.then.44, label %if.end.46

if.then.44:                                       ; preds = %lor.lhs.false.41, %if.end.39
  %26 = load i32, i32* %count, align 4, !tbaa !5
  %call45 = call i32 @sleep(i32 %26)
  br label %if.end.46

if.end.46:                                        ; preds = %if.then.44, %lor.lhs.false.41
  br label %for.cond

for.end:                                          ; preds = %if.end.38, %if.then.36, %if.then.26
  %27 = load i8*, i8** @Pshm, align 8, !tbaa !1
  %cmp47 = icmp ne i8* %27, null
  br i1 %cmp47, label %if.then.49, label %if.end.103

if.then.49:                                       ; preds = %for.end
  %28 = bitcast i32** %p to i8*
  call void @llvm.lifetime.start(i64 8, i8* %28) #1
  %29 = load i32, i32* %keyselect, align 4, !tbaa !5
  %tobool50 = icmp ne i32 %29, 0
  br i1 %tobool50, label %if.then.51, label %if.end.54

if.then.51:                                       ; preds = %if.then.49
  %30 = load i8*, i8** @ShmKeyFile, align 8, !tbaa !1
  %31 = load i32, i32* @ShmKey, align 4, !tbaa !5
  %conv52 = sext i32 %31 to i64
  %call53 = call i32 @write_key_file(i8* %30, i64 %conv52)
  br label %if.end.54

if.end.54:                                        ; preds = %if.then.51, %if.then.49
  %32 = load i32, i32* %owner.addr, align 4, !tbaa !5
  %tobool55 = icmp ne i32 %32, 0
  br i1 %tobool55, label %land.lhs.true, label %if.end.67

land.lhs.true:                                    ; preds = %if.end.54
  %33 = load i32, i32* @RunAsUid, align 4, !tbaa !5
  %cmp56 = icmp ne i32 %33, 0
  br i1 %cmp56, label %if.then.58, label %if.end.67

if.then.58:                                       ; preds = %land.lhs.true
  %34 = load i32, i32* @ShmId, align 4, !tbaa !5
  %35 = load i32, i32* @RunAsUid, align 4, !tbaa !5
  %36 = load i32, i32* @RunAsGid, align 4, !tbaa !5
  %call59 = call i32 @sm_shmsetowner(i32 %34, i32 %35, i32 %36, i32 432)
  store i32 %call59, i32* %i, align 4, !tbaa !5
  %37 = load i32, i32* %i, align 4, !tbaa !5
  %cmp60 = icmp ne i32 %37, 0
  br i1 %cmp60, label %if.then.62, label %if.end.66

if.then.62:                                       ; preds = %if.then.58
  %38 = load i32, i32* @ShmKey, align 4, !tbaa !5
  %conv63 = sext i32 %38 to i64
  %39 = load i32, i32* %i, align 4, !tbaa !5
  %40 = load i32, i32* @RunAsUid, align 4, !tbaa !5
  %conv64 = zext i32 %40 to i64
  %41 = load i32, i32* @RunAsGid, align 4, !tbaa !5
  %conv65 = zext i32 %41 to i64
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 3, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0), i8* getelementptr inbounds ([55 x i8], [55 x i8]* @.str.290, i32 0, i32 0), i64 %conv63, i32 %39, i64 %conv64, i64 %conv65)
  br label %if.end.66

if.end.66:                                        ; preds = %if.then.62, %if.then.58
  br label %if.end.67

if.end.67:                                        ; preds = %if.end.66, %land.lhs.true, %if.end.54
  %42 = load i8*, i8** @Pshm, align 8, !tbaa !1
  %43 = bitcast i8* %42 to i32*
  store i32* %43, i32** %p, align 8, !tbaa !1
  %44 = load i32, i32* %owner.addr, align 4, !tbaa !5
  %tobool68 = icmp ne i32 %44, 0
  br i1 %tobool68, label %if.then.69, label %if.else.73

if.then.69:                                       ; preds = %if.end.67
  %45 = load i64, i64* @shms, align 8, !tbaa !92
  %conv70 = trunc i64 %45 to i32
  %46 = load i32*, i32** %p, align 8, !tbaa !1
  store i32 %conv70, i32* %46, align 4, !tbaa !5
  %47 = load i32, i32* @CurrentPid, align 4, !tbaa !5
  %48 = load i8*, i8** @Pshm, align 8, !tbaa !1
  %add.ptr = getelementptr inbounds i8, i8* %48, i64 4
  %49 = bitcast i8* %add.ptr to i32*
  store i32 %47, i32* %49, align 4, !tbaa !5
  %50 = load i8*, i8** @Pshm, align 8, !tbaa !1
  %add.ptr71 = getelementptr inbounds i8, i8* %50, i64 4
  %add.ptr72 = getelementptr inbounds i8, i8* %add.ptr71, i64 4
  %51 = bitcast i8* %add.ptr72 to i32*
  store i32* %51, i32** %p, align 8, !tbaa !1
  %52 = load i32, i32* %hash.addr, align 4, !tbaa !5
  %53 = load i32*, i32** %p, align 8, !tbaa !1
  store i32 %52, i32* %53, align 4, !tbaa !5
  br label %if.end.85

if.else.73:                                       ; preds = %if.end.67
  %54 = load i32*, i32** %p, align 8, !tbaa !1
  %55 = load i32, i32* %54, align 4, !tbaa !5
  %56 = load i64, i64* @shms, align 8, !tbaa !92
  %conv74 = trunc i64 %56 to i32
  %cmp75 = icmp ne i32 %55, %conv74
  br i1 %cmp75, label %if.then.77, label %if.end.78

if.then.77:                                       ; preds = %if.else.73
  store i32 22, i32* %save_errno, align 4, !tbaa !5
  call void @cleanup_shm(i32 0)
  store i32 2, i32* %cleanup.dest.slot
  br label %cleanup

if.end.78:                                        ; preds = %if.else.73
  %57 = load i8*, i8** @Pshm, align 8, !tbaa !1
  %add.ptr79 = getelementptr inbounds i8, i8* %57, i64 4
  %add.ptr80 = getelementptr inbounds i8, i8* %add.ptr79, i64 4
  %58 = bitcast i8* %add.ptr80 to i32*
  store i32* %58, i32** %p, align 8, !tbaa !1
  %59 = load i32*, i32** %p, align 8, !tbaa !1
  %60 = load i32, i32* %59, align 4, !tbaa !5
  %61 = load i32, i32* %hash.addr, align 4, !tbaa !5
  %cmp81 = icmp ne i32 %60, %61
  br i1 %cmp81, label %if.then.83, label %if.end.84

if.then.83:                                       ; preds = %if.end.78
  store i32 22, i32* %save_errno, align 4, !tbaa !5
  call void @cleanup_shm(i32 0)
  store i32 2, i32* %cleanup.dest.slot
  br label %cleanup

if.end.84:                                        ; preds = %if.end.78
  br label %if.end.85

if.end.85:                                        ; preds = %if.end.84, %if.then.69
  %62 = load i8*, i8** @Pshm, align 8, !tbaa !1
  %add.ptr86 = getelementptr inbounds i8, i8* %62, i64 12
  %63 = bitcast i8* %add.ptr86 to %struct.filesys_shared*
  store %struct.filesys_shared* %63, %struct.filesys_shared** @PtrFileSys, align 8, !tbaa !1
  %64 = load i8*, i8** @Pshm, align 8, !tbaa !1
  %add.ptr87 = getelementptr inbounds i8, i8* %64, i64 12
  %add.ptr88 = getelementptr inbounds i8, i8* %add.ptr87, i64 6144
  %65 = bitcast i8* %add.ptr88 to i32*
  store i32* %65, i32** @PNumFileSys, align 8, !tbaa !1
  %66 = load i8*, i8** @Pshm, align 8, !tbaa !1
  %add.ptr89 = getelementptr inbounds i8, i8* %66, i64 12
  %add.ptr90 = getelementptr inbounds i8, i8* %add.ptr89, i64 6144
  %add.ptr91 = getelementptr inbounds i8, i8* %add.ptr90, i64 8
  %67 = bitcast i8* %add.ptr91 to %struct.queue_shared*
  store %struct.queue_shared* %67, %struct.queue_shared** @QShm, align 8, !tbaa !1
  %68 = load i8*, i8** @Pshm, align 8, !tbaa !1
  %add.ptr92 = getelementptr inbounds i8, i8* %68, i64 12
  %add.ptr93 = getelementptr inbounds i8, i8* %add.ptr92, i64 6144
  %add.ptr94 = getelementptr inbounds i8, i8* %add.ptr93, i64 4
  %69 = bitcast i8* %add.ptr94 to i32*
  store i32* %69, i32** @PRSATmpCnt, align 8, !tbaa !1
  %70 = load i32*, i32** @PRSATmpCnt, align 8, !tbaa !1
  store i32 0, i32* %70, align 4, !tbaa !5
  %71 = load i32, i32* %owner.addr, align 4, !tbaa !5
  %tobool95 = icmp ne i32 %71, 0
  br i1 %tobool95, label %if.then.96, label %if.end.102

if.then.96:                                       ; preds = %if.end.85
  %72 = load i32*, i32** @PNumFileSys, align 8, !tbaa !1
  store i32 0, i32* %72, align 4, !tbaa !5
  store i32 0, i32* %i, align 4, !tbaa !5
  br label %for.cond.97

for.cond.97:                                      ; preds = %for.inc, %if.then.96
  %73 = load i32, i32* %i, align 4, !tbaa !5
  %74 = load i32, i32* %qn.addr, align 4, !tbaa !5
  %cmp98 = icmp slt i32 %73, %74
  br i1 %cmp98, label %for.body, label %for.end.101

for.body:                                         ; preds = %for.cond.97
  %75 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom = sext i32 %75 to i64
  %76 = load %struct.queue_shared*, %struct.queue_shared** @QShm, align 8, !tbaa !1
  %arrayidx = getelementptr inbounds %struct.queue_shared, %struct.queue_shared* %76, i64 %idxprom
  %qs_entries = getelementptr inbounds %struct.queue_shared, %struct.queue_shared* %arrayidx, i32 0, i32 0
  store i32 -1, i32* %qs_entries, align 4, !tbaa !85
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %77 = load i32, i32* %i, align 4, !tbaa !5
  %inc100 = add nsw i32 %77, 1
  store i32 %inc100, i32* %i, align 4, !tbaa !5
  br label %for.cond.97

for.end.101:                                      ; preds = %for.cond.97
  br label %if.end.102

if.end.102:                                       ; preds = %for.end.101, %if.end.85
  %78 = load i32, i32* %owner.addr, align 4, !tbaa !5
  call void @init_sem(i32 %78)
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

cleanup:                                          ; preds = %if.then.83, %if.then.77, %if.end.102
  %79 = bitcast i32** %p to i8*
  call void @llvm.lifetime.end(i64 8, i8* %79) #1
  %cleanup.dest = load i32, i32* %cleanup.dest.slot
  switch i32 %cleanup.dest, label %cleanup.116 [
    i32 2, label %error
  ]

if.end.103:                                       ; preds = %for.end
  br label %error

error:                                            ; preds = %if.end.103, %cleanup, %cond.end
  %80 = load i32, i32* @LogLevel, align 4, !tbaa !5
  %81 = load i32, i32* %owner.addr, align 4, !tbaa !5
  %tobool104 = icmp ne i32 %81, 0
  %cond105 = select i1 %tobool104, i32 8, i32 11
  %cmp106 = icmp sgt i32 %80, %cond105
  br i1 %cmp106, label %if.then.108, label %if.end.115

if.then.108:                                      ; preds = %error
  %82 = load i32, i32* %owner.addr, align 4, !tbaa !5
  %tobool109 = icmp ne i32 %82, 0
  %cond110 = select i1 %tobool109, i32 3, i32 5
  %83 = load i32, i32* %owner.addr, align 4, !tbaa !5
  %tobool111 = icmp ne i32 %83, 0
  %cond112 = select i1 %tobool111, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.292, i32 0, i32 0), i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.293, i32 0, i32 0)
  %84 = load i32, i32* @ShmKey, align 4, !tbaa !5
  %conv113 = sext i32 %84 to i64
  %85 = load i32, i32* %save_errno, align 4, !tbaa !5
  %call114 = call i8* @sm_errstring(i32 %85)
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 %cond110, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0), i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.291, i32 0, i32 0), i8* %cond112, i64 %conv113, i8* %call114)
  br label %if.end.115

if.end.115:                                       ; preds = %if.then.108, %error
  store i32 0, i32* %cleanup.dest.slot
  br label %cleanup.116

cleanup.116:                                      ; preds = %if.end.115, %cleanup, %if.then
  %86 = bitcast i32* %keyselect to i8*
  call void @llvm.lifetime.end(i64 4, i8* %86) #1
  %87 = bitcast i32* %save_errno to i8*
  call void @llvm.lifetime.end(i64 4, i8* %87) #1
  %88 = bitcast i32* %count to i8*
  call void @llvm.lifetime.end(i64 4, i8* %88) #1
  %89 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end(i64 4, i8* %89) #1
  %cleanup.dest.120 = load i32, i32* %cleanup.dest.slot
  switch i32 %cleanup.dest.120, label %unreachable [
    i32 0, label %cleanup.cont
    i32 1, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup.116, %cleanup.116
  ret void

unreachable:                                      ; preds = %cleanup.116
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @filesys_setup(i32 %add) #0 {
entry:
  %add.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %fs = alloca i16, align 2
  %ret = alloca i32, align 4
  %qp = alloca %struct.qpaths_s*, align 8
  %qddf = alloca [4096 x i8], align 16
  store i32 %add, i32* %add.addr, align 4, !tbaa !5
  %0 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start(i64 4, i8* %0) #1
  %1 = bitcast i32* %j to i8*
  call void @llvm.lifetime.start(i64 4, i8* %1) #1
  %2 = bitcast i16* %fs to i8*
  call void @llvm.lifetime.start(i64 2, i8* %2) #1
  %3 = bitcast i32* %ret to i8*
  call void @llvm.lifetime.start(i64 4, i8* %3) #1
  store i32 0, i32* %ret, align 4, !tbaa !5
  store i32 0, i32* %i, align 4, !tbaa !5
  br label %for.cond

for.cond:                                         ; preds = %for.inc.26, %entry
  %4 = load i32, i32* %i, align 4, !tbaa !5
  %5 = load i32, i32* @NumQueue, align 4, !tbaa !5
  %cmp = icmp slt i32 %4, %5
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %6 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom
  %7 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx, align 8, !tbaa !1
  %cmp1 = icmp ne %struct.queuegrp* %7, null
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %8 = phi i1 [ false, %for.cond ], [ %cmp1, %land.rhs ]
  br i1 %8, label %for.body, label %for.end.28

for.body:                                         ; preds = %land.end
  store i32 0, i32* %j, align 4, !tbaa !5
  br label %for.cond.2

for.cond.2:                                       ; preds = %for.inc, %for.body
  %9 = load i32, i32* %j, align 4, !tbaa !5
  %10 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom3 = sext i32 %10 to i64
  %arrayidx4 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom3
  %11 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx4, align 8, !tbaa !1
  %qg_numqueues = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %11, i32 0, i32 4
  %12 = load i32, i32* %qg_numqueues, align 4, !tbaa !82
  %cmp5 = icmp slt i32 %9, %12
  br i1 %cmp5, label %for.body.6, label %for.end

for.body.6:                                       ; preds = %for.cond.2
  %13 = bitcast %struct.qpaths_s** %qp to i8*
  call void @llvm.lifetime.start(i64 8, i8* %13) #1
  %14 = load i32, i32* %j, align 4, !tbaa !5
  %idxprom7 = sext i32 %14 to i64
  %15 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom8 = sext i32 %15 to i64
  %arrayidx9 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom8
  %16 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx9, align 8, !tbaa !1
  %qg_qpaths = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %16, i32 0, i32 6
  %17 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths, align 8, !tbaa !38
  %arrayidx10 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %17, i64 %idxprom7
  store %struct.qpaths_s* %arrayidx10, %struct.qpaths_s** %qp, align 8, !tbaa !1
  %18 = bitcast [4096 x i8]* %qddf to i8*
  call void @llvm.lifetime.start(i64 4096, i8* %18) #1
  %arraydecay = getelementptr inbounds [4096 x i8], [4096 x i8]* %qddf, i32 0, i32 0
  %19 = load %struct.qpaths_s*, %struct.qpaths_s** %qp, align 8, !tbaa !1
  %qp_name = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %19, i32 0, i32 0
  %20 = load i8*, i8** %qp_name, align 8, !tbaa !40
  %21 = load %struct.qpaths_s*, %struct.qpaths_s** %qp, align 8, !tbaa !1
  %qp_subdirs = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %21, i32 0, i32 1
  %22 = load i16, i16* %qp_subdirs, align 2, !tbaa !83
  %conv = sext i16 %22 to i32
  %and = and i32 %conv, 1
  %cmp11 = icmp ne i32 %and, 0
  %cond = select i1 %cmp11, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.102, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0)
  %call = call i64 (i8*, i64, i32, ...) @sm_strlcpyn(i8* %arraydecay, i64 4096, i32 2, i8* %20, i8* %cond)
  %23 = load %struct.qpaths_s*, %struct.qpaths_s** %qp, align 8, !tbaa !1
  %qp_name13 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %23, i32 0, i32 0
  %24 = load i8*, i8** %qp_name13, align 8, !tbaa !40
  %arraydecay14 = getelementptr inbounds [4096 x i8], [4096 x i8]* %qddf, i32 0, i32 0
  %25 = load i32, i32* %add.addr, align 4, !tbaa !5
  %call15 = call signext i16 @filesys_find(i8* %24, i8* %arraydecay14, i32 %25)
  store i16 %call15, i16* %fs, align 2, !tbaa !88
  %26 = load i16, i16* %fs, align 2, !tbaa !88
  %conv16 = sext i16 %26 to i32
  %cmp17 = icmp sge i32 %conv16, 0
  br i1 %cmp17, label %if.then, label %if.else

if.then:                                          ; preds = %for.body.6
  %27 = load i16, i16* %fs, align 2, !tbaa !88
  %28 = load %struct.qpaths_s*, %struct.qpaths_s** %qp, align 8, !tbaa !1
  %qp_fsysidx = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %28, i32 0, i32 2
  store i16 %27, i16* %qp_fsysidx, align 2, !tbaa !87
  br label %if.end

if.else:                                          ; preds = %for.body.6
  %29 = load %struct.qpaths_s*, %struct.qpaths_s** %qp, align 8, !tbaa !1
  %qp_fsysidx19 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %29, i32 0, i32 2
  store i16 0, i16* %qp_fsysidx19, align 2, !tbaa !87
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %30 = load i16, i16* %fs, align 2, !tbaa !88
  %conv20 = sext i16 %30 to i32
  %31 = load i32, i32* %ret, align 4, !tbaa !5
  %cmp21 = icmp slt i32 %conv20, %31
  br i1 %cmp21, label %if.then.23, label %if.end.25

if.then.23:                                       ; preds = %if.end
  %32 = load i16, i16* %fs, align 2, !tbaa !88
  %conv24 = sext i16 %32 to i32
  store i32 %conv24, i32* %ret, align 4, !tbaa !5
  br label %if.end.25

if.end.25:                                        ; preds = %if.then.23, %if.end
  %33 = bitcast [4096 x i8]* %qddf to i8*
  call void @llvm.lifetime.end(i64 4096, i8* %33) #1
  %34 = bitcast %struct.qpaths_s** %qp to i8*
  call void @llvm.lifetime.end(i64 8, i8* %34) #1
  br label %for.inc

for.inc:                                          ; preds = %if.end.25
  %35 = load i32, i32* %j, align 4, !tbaa !5
  %inc = add nsw i32 %35, 1
  store i32 %inc, i32* %j, align 4, !tbaa !5
  br label %for.cond.2

for.end:                                          ; preds = %for.cond.2
  br label %for.inc.26

for.inc.26:                                       ; preds = %for.end
  %36 = load i32, i32* %i, align 4, !tbaa !5
  %inc27 = add nsw i32 %36, 1
  store i32 %inc27, i32* %i, align 4, !tbaa !5
  br label %for.cond

for.end.28:                                       ; preds = %land.end
  %37 = load i32, i32* %ret, align 4, !tbaa !5
  %38 = bitcast i32* %ret to i8*
  call void @llvm.lifetime.end(i64 4, i8* %38) #1
  %39 = bitcast i16* %fs to i8*
  call void @llvm.lifetime.end(i64 2, i8* %39) #1
  %40 = bitcast i32* %j to i8*
  call void @llvm.lifetime.end(i64 4, i8* %40) #1
  %41 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end(i64 4, i8* %41) #1
  ret i32 %37
}

; Function Attrs: nounwind uwtable
define void @cleanup_shm(i32 %owner) #0 {
entry:
  %owner.addr = alloca i32, align 4
  store i32 %owner, i32* %owner.addr, align 4, !tbaa !5
  %0 = load i32, i32* @ShmId, align 4, !tbaa !5
  %cmp = icmp ne i32 %0, -2
  br i1 %cmp, label %if.then, label %if.end.6

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** @Pshm, align 8, !tbaa !1
  %2 = load i32, i32* @ShmId, align 4, !tbaa !5
  %3 = load i32, i32* %owner.addr, align 4, !tbaa !5
  %call = call i32 @sm_shmstop(i8* %1, i32 %2, i32 %3)
  %cmp1 = icmp slt i32 %call, 0
  br i1 %cmp1, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then
  %4 = load i32, i32* @LogLevel, align 4, !tbaa !5
  %cmp2 = icmp sgt i32 %4, 8
  br i1 %cmp2, label %if.then.3, label %if.end

if.then.3:                                        ; preds = %land.lhs.true
  %call4 = call i32* @__errno_location() #11
  %5 = load i32, i32* %call4, align 4, !tbaa !5
  %call5 = call i8* @sm_errstring(i32 %5)
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 6, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0), i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.167, i32 0, i32 0), i8* %call5)
  br label %if.end

if.end:                                           ; preds = %if.then.3, %land.lhs.true, %if.then
  store i8* null, i8** @Pshm, align 8, !tbaa !1
  store i32 -2, i32* @ShmId, align 4, !tbaa !5
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %entry
  %6 = load i32, i32* %owner.addr, align 4, !tbaa !5
  call void @stop_sem(i32 %6)
  ret void
}

declare i32 @sm_shmstop(i8*, i32, i32) #2

; Function Attrs: nounwind uwtable
define internal void @stop_sem(i32 %owner) #0 {
entry:
  %owner.addr = alloca i32, align 4
  store i32 %owner, i32* %owner.addr, align 4, !tbaa !5
  ret void
}

; Function Attrs: nounwind uwtable
define void @cleanup_queues() #0 {
entry:
  call void @sync_queue_time()
  ret void
}

; Function Attrs: nounwind uwtable
define void @set_def_queueval(%struct.queuegrp* %qg, i32 %all) #0 {
entry:
  %qg.addr = alloca %struct.queuegrp*, align 8
  %all.addr = alloca i32, align 4
  store %struct.queuegrp* %qg, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  store i32 %all, i32* %all.addr, align 4, !tbaa !5
  %0 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_flags = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %0, i32 0, i32 7
  %arrayidx = getelementptr inbounds [8 x i32], [8 x i32]* %qg_flags, i32 0, i64 0
  %1 = load i32, i32* %arrayidx, align 4, !tbaa !5
  %and = and i32 %1, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i32, i32* %all.addr, align 4, !tbaa !5
  %tobool1 = icmp ne i32 %2, 0
  br i1 %tobool1, label %if.then.2, label %if.end.3

if.then.2:                                        ; preds = %if.end
  %3 = load i8*, i8** @QueueDir, align 8, !tbaa !1
  %4 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_qdir = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %4, i32 0, i32 1
  store i8* %3, i8** %qg_qdir, align 8, !tbaa !94
  br label %if.end.3

if.end.3:                                         ; preds = %if.then.2, %if.end
  %5 = load i32, i32* %all.addr, align 4, !tbaa !5
  %tobool4 = icmp ne i32 %5, 0
  br i1 %tobool4, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.3
  %6 = load i32, i32* @MaxRunnersPerQueue, align 4, !tbaa !5
  br label %cond.end

cond.false:                                       ; preds = %if.end.3
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %6, %cond.true ], [ -1, %cond.false ]
  %7 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_maxqrun = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %7, i32 0, i32 3
  store i32 %cond, i32* %qg_maxqrun, align 4, !tbaa !117
  %8 = load i32, i32* @NiceQueueRun, align 4, !tbaa !5
  %conv = trunc i32 %8 to i16
  %9 = load %struct.queuegrp*, %struct.queuegrp** %qg.addr, align 8, !tbaa !1
  %qg_nice = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %9, i32 0, i32 8
  store i16 %conv, i16* %qg_nice, align 2, !tbaa !115
  br label %return

return:                                           ; preds = %cond.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define void @makequeue(i8* %line, i32 %qdef) #0 {
entry:
  %line.addr = alloca i8*, align 8
  %qdef.addr = alloca i32, align 4
  %p = alloca i8*, align 8
  %qg = alloca %struct.queuegrp*, align 8
  %s = alloca %struct.symtab*, align 8
  %i = alloca i32, align 4
  %fcode = alloca i8, align 1
  %cleanup.dest.slot = alloca i32
  %delimptr = alloca i8*, align 8
  store i8* %line, i8** %line.addr, align 8, !tbaa !1
  store i32 %qdef, i32* %qdef.addr, align 4, !tbaa !5
  %0 = bitcast i8** %p to i8*
  call void @llvm.lifetime.start(i64 8, i8* %0) #1
  %1 = bitcast %struct.queuegrp** %qg to i8*
  call void @llvm.lifetime.start(i64 8, i8* %1) #1
  %2 = bitcast %struct.symtab** %s to i8*
  call void @llvm.lifetime.start(i64 8, i8* %2) #1
  %3 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start(i64 4, i8* %3) #1
  call void @llvm.lifetime.start(i64 1, i8* %fcode) #1
  %call = call i8* @xalloc_tagged(i32 112, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 7323)
  %4 = bitcast i8* %call to %struct.queuegrp*
  store %struct.queuegrp* %4, %struct.queuegrp** %qg, align 8, !tbaa !1
  %5 = load %struct.queuegrp*, %struct.queuegrp** %qg, align 8, !tbaa !1
  %6 = bitcast %struct.queuegrp* %5 to i8*
  call void @llvm.memset.p0i8.i64(i8* %6, i8 0, i64 112, i32 1, i1 false)
  %7 = load i8*, i8** %line.addr, align 8, !tbaa !1
  %arrayidx = getelementptr inbounds i8, i8* %7, i64 0
  %8 = load i8, i8* %arrayidx, align 1, !tbaa !17
  %conv = sext i8 %8 to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.168, i32 0, i32 0))
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup.229

if.end:                                           ; preds = %entry
  %9 = load i8*, i8** %line.addr, align 8, !tbaa !1
  store i8* %9, i8** %p, align 8, !tbaa !1
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i8*, i8** %p, align 8, !tbaa !1
  %11 = load i8, i8* %10, align 1, !tbaa !17
  %conv2 = sext i8 %11 to i32
  %cmp3 = icmp ne i32 %conv2, 0
  br i1 %cmp3, label %land.lhs.true, label %land.end.17

land.lhs.true:                                    ; preds = %for.cond
  %12 = load i8*, i8** %p, align 8, !tbaa !1
  %13 = load i8, i8* %12, align 1, !tbaa !17
  %conv5 = sext i8 %13 to i32
  %cmp6 = icmp ne i32 %conv5, 44
  br i1 %cmp6, label %land.rhs, label %land.end.17

land.rhs:                                         ; preds = %land.lhs.true
  %14 = load i8*, i8** %p, align 8, !tbaa !1
  %15 = load i8, i8* %14, align 1, !tbaa !17
  %conv8 = sext i8 %15 to i32
  %and = and i32 %conv8, -128
  %cmp9 = icmp eq i32 %and, 0
  br i1 %cmp9, label %land.rhs.11, label %land.end

land.rhs.11:                                      ; preds = %land.rhs
  %16 = load i8*, i8** %p, align 8, !tbaa !1
  %17 = load i8, i8* %16, align 1, !tbaa !17
  %conv12 = sext i8 %17 to i32
  %idxprom = sext i32 %conv12 to i64
  %call13 = call i16** @__ctype_b_loc() #11
  %18 = load i16*, i16** %call13, align 8, !tbaa !1
  %arrayidx14 = getelementptr inbounds i16, i16* %18, i64 %idxprom
  %19 = load i16, i16* %arrayidx14, align 2, !tbaa !88
  %conv15 = zext i16 %19 to i32
  %and16 = and i32 %conv15, 8192
  %tobool = icmp ne i32 %and16, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs.11, %land.rhs
  %20 = phi i1 [ false, %land.rhs ], [ %tobool, %land.rhs.11 ]
  %lnot = xor i1 %20, true
  br label %land.end.17

land.end.17:                                      ; preds = %land.end, %land.lhs.true, %for.cond
  %21 = phi i1 [ false, %land.lhs.true ], [ false, %for.cond ], [ %lnot, %land.end ]
  br i1 %21, label %for.body, label %for.end

for.body:                                         ; preds = %land.end.17
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %22 = load i8*, i8** %p, align 8, !tbaa !1
  %incdec.ptr = getelementptr inbounds i8, i8* %22, i32 1
  store i8* %incdec.ptr, i8** %p, align 8, !tbaa !1
  br label %for.cond

for.end:                                          ; preds = %land.end.17
  %23 = load i8*, i8** %p, align 8, !tbaa !1
  %24 = load i8, i8* %23, align 1, !tbaa !17
  %conv18 = sext i8 %24 to i32
  %cmp19 = icmp ne i32 %conv18, 0
  br i1 %cmp19, label %if.then.21, label %if.end.23

if.then.21:                                       ; preds = %for.end
  %25 = load i8*, i8** %p, align 8, !tbaa !1
  %incdec.ptr22 = getelementptr inbounds i8, i8* %25, i32 1
  store i8* %incdec.ptr22, i8** %p, align 8, !tbaa !1
  store i8 0, i8* %25, align 1, !tbaa !17
  br label %if.end.23

if.end.23:                                        ; preds = %if.then.21, %for.end
  %26 = load i8*, i8** %line.addr, align 8, !tbaa !1
  %call24 = call i8* @newstr(i8* %26)
  %27 = load %struct.queuegrp*, %struct.queuegrp** %qg, align 8, !tbaa !1
  %qg_name = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %27, i32 0, i32 0
  store i8* %call24, i8** %qg_name, align 8, !tbaa !157
  %28 = load %struct.queuegrp*, %struct.queuegrp** %qg, align 8, !tbaa !1
  call void @set_def_queueval(%struct.queuegrp* %28, i32 0)
  br label %while.cond

while.cond:                                       ; preds = %cleanup.cont, %if.end.23
  %29 = load i8*, i8** %p, align 8, !tbaa !1
  %30 = load i8, i8* %29, align 1, !tbaa !17
  %conv25 = sext i8 %30 to i32
  %cmp26 = icmp ne i32 %conv25, 0
  br i1 %cmp26, label %while.body, label %while.end.152

while.body:                                       ; preds = %while.cond
  %31 = bitcast i8** %delimptr to i8*
  call void @llvm.lifetime.start(i64 8, i8* %31) #1
  br label %while.cond.28

while.cond.28:                                    ; preds = %while.body.50, %while.body
  %32 = load i8*, i8** %p, align 8, !tbaa !1
  %33 = load i8, i8* %32, align 1, !tbaa !17
  %conv29 = sext i8 %33 to i32
  %cmp30 = icmp ne i32 %conv29, 0
  br i1 %cmp30, label %land.rhs.32, label %land.end.49

land.rhs.32:                                      ; preds = %while.cond.28
  %34 = load i8*, i8** %p, align 8, !tbaa !1
  %35 = load i8, i8* %34, align 1, !tbaa !17
  %conv33 = sext i8 %35 to i32
  %cmp34 = icmp eq i32 %conv33, 44
  br i1 %cmp34, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.rhs.32
  %36 = load i8*, i8** %p, align 8, !tbaa !1
  %37 = load i8, i8* %36, align 1, !tbaa !17
  %conv36 = sext i8 %37 to i32
  %and37 = and i32 %conv36, -128
  %cmp38 = icmp eq i32 %and37, 0
  br i1 %cmp38, label %land.rhs.40, label %land.end.48

land.rhs.40:                                      ; preds = %lor.rhs
  %38 = load i8*, i8** %p, align 8, !tbaa !1
  %39 = load i8, i8* %38, align 1, !tbaa !17
  %conv41 = sext i8 %39 to i32
  %idxprom42 = sext i32 %conv41 to i64
  %call43 = call i16** @__ctype_b_loc() #11
  %40 = load i16*, i16** %call43, align 8, !tbaa !1
  %arrayidx44 = getelementptr inbounds i16, i16* %40, i64 %idxprom42
  %41 = load i16, i16* %arrayidx44, align 2, !tbaa !88
  %conv45 = zext i16 %41 to i32
  %and46 = and i32 %conv45, 8192
  %tobool47 = icmp ne i32 %and46, 0
  br label %land.end.48

land.end.48:                                      ; preds = %land.rhs.40, %lor.rhs
  %42 = phi i1 [ false, %lor.rhs ], [ %tobool47, %land.rhs.40 ]
  br label %lor.end

lor.end:                                          ; preds = %land.end.48, %land.rhs.32
  %43 = phi i1 [ true, %land.rhs.32 ], [ %42, %land.end.48 ]
  br label %land.end.49

land.end.49:                                      ; preds = %lor.end, %while.cond.28
  %44 = phi i1 [ false, %while.cond.28 ], [ %43, %lor.end ]
  br i1 %44, label %while.body.50, label %while.end

while.body.50:                                    ; preds = %land.end.49
  %45 = load i8*, i8** %p, align 8, !tbaa !1
  %incdec.ptr51 = getelementptr inbounds i8, i8* %45, i32 1
  store i8* %incdec.ptr51, i8** %p, align 8, !tbaa !1
  br label %while.cond.28

while.end:                                        ; preds = %land.end.49
  %46 = load i8*, i8** %p, align 8, !tbaa !1
  %47 = load i8, i8* %46, align 1, !tbaa !17
  store i8 %47, i8* %fcode, align 1, !tbaa !17
  br label %while.cond.52

while.cond.52:                                    ; preds = %while.body.65, %while.end
  %48 = load i8*, i8** %p, align 8, !tbaa !1
  %49 = load i8, i8* %48, align 1, !tbaa !17
  %conv53 = sext i8 %49 to i32
  %cmp54 = icmp ne i32 %conv53, 0
  br i1 %cmp54, label %land.lhs.true.56, label %land.end.64

land.lhs.true.56:                                 ; preds = %while.cond.52
  %50 = load i8*, i8** %p, align 8, !tbaa !1
  %51 = load i8, i8* %50, align 1, !tbaa !17
  %conv57 = sext i8 %51 to i32
  %cmp58 = icmp ne i32 %conv57, 61
  br i1 %cmp58, label %land.rhs.60, label %land.end.64

land.rhs.60:                                      ; preds = %land.lhs.true.56
  %52 = load i8*, i8** %p, align 8, !tbaa !1
  %53 = load i8, i8* %52, align 1, !tbaa !17
  %conv61 = sext i8 %53 to i32
  %cmp62 = icmp ne i32 %conv61, 44
  br label %land.end.64

land.end.64:                                      ; preds = %land.rhs.60, %land.lhs.true.56, %while.cond.52
  %54 = phi i1 [ false, %land.lhs.true.56 ], [ false, %while.cond.52 ], [ %cmp62, %land.rhs.60 ]
  br i1 %54, label %while.body.65, label %while.end.67

while.body.65:                                    ; preds = %land.end.64
  %55 = load i8*, i8** %p, align 8, !tbaa !1
  %incdec.ptr66 = getelementptr inbounds i8, i8* %55, i32 1
  store i8* %incdec.ptr66, i8** %p, align 8, !tbaa !1
  br label %while.cond.52

while.end.67:                                     ; preds = %land.end.64
  %56 = load i8*, i8** %p, align 8, !tbaa !1
  %incdec.ptr68 = getelementptr inbounds i8, i8* %56, i32 1
  store i8* %incdec.ptr68, i8** %p, align 8, !tbaa !1
  %57 = load i8, i8* %56, align 1, !tbaa !17
  %conv69 = sext i8 %57 to i32
  %cmp70 = icmp ne i32 %conv69, 61
  br i1 %cmp70, label %if.then.72, label %if.end.74

if.then.72:                                       ; preds = %while.end.67
  %58 = load %struct.queuegrp*, %struct.queuegrp** %qg, align 8, !tbaa !1
  %qg_name73 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %58, i32 0, i32 0
  %59 = load i8*, i8** %qg_name73, align 8, !tbaa !157
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.169, i32 0, i32 0), i8* %59)
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.74:                                        ; preds = %while.end.67
  br label %while.cond.75

while.cond.75:                                    ; preds = %while.body.89, %if.end.74
  %60 = load i8*, i8** %p, align 8, !tbaa !1
  %61 = load i8, i8* %60, align 1, !tbaa !17
  %conv76 = sext i8 %61 to i32
  %and77 = and i32 %conv76, -128
  %cmp78 = icmp eq i32 %and77, 0
  br i1 %cmp78, label %land.rhs.80, label %land.end.88

land.rhs.80:                                      ; preds = %while.cond.75
  %62 = load i8*, i8** %p, align 8, !tbaa !1
  %63 = load i8, i8* %62, align 1, !tbaa !17
  %conv81 = sext i8 %63 to i32
  %idxprom82 = sext i32 %conv81 to i64
  %call83 = call i16** @__ctype_b_loc() #11
  %64 = load i16*, i16** %call83, align 8, !tbaa !1
  %arrayidx84 = getelementptr inbounds i16, i16* %64, i64 %idxprom82
  %65 = load i16, i16* %arrayidx84, align 2, !tbaa !88
  %conv85 = zext i16 %65 to i32
  %and86 = and i32 %conv85, 8192
  %tobool87 = icmp ne i32 %and86, 0
  br label %land.end.88

land.end.88:                                      ; preds = %land.rhs.80, %while.cond.75
  %66 = phi i1 [ false, %while.cond.75 ], [ %tobool87, %land.rhs.80 ]
  br i1 %66, label %while.body.89, label %while.end.91

while.body.89:                                    ; preds = %land.end.88
  %67 = load i8*, i8** %p, align 8, !tbaa !1
  %incdec.ptr90 = getelementptr inbounds i8, i8* %67, i32 1
  store i8* %incdec.ptr90, i8** %p, align 8, !tbaa !1
  br label %while.cond.75

while.end.91:                                     ; preds = %land.end.88
  %68 = load i8*, i8** %p, align 8, !tbaa !1
  %call92 = call i8* @munchstring(i8* %68, i8** %delimptr, i32 44)
  store i8* %call92, i8** %p, align 8, !tbaa !1
  %69 = load i8, i8* %fcode, align 1, !tbaa !17
  %conv93 = sext i8 %69 to i32
  switch i32 %conv93, label %sw.default [
    i32 80, label %sw.bb
    i32 70, label %sw.bb.101
    i32 73, label %sw.bb.128
    i32 78, label %sw.bb.130
    i32 82, label %sw.bb.133
    i32 74, label %sw.bb.146
    i32 114, label %sw.bb.148
  ]

sw.bb:                                            ; preds = %while.end.91
  %70 = load i8*, i8** %p, align 8, !tbaa !1
  %71 = load i8, i8* %70, align 1, !tbaa !17
  %conv94 = sext i8 %71 to i32
  %cmp95 = icmp eq i32 %conv94, 0
  br i1 %cmp95, label %if.then.97, label %if.else

if.then.97:                                       ; preds = %sw.bb
  %72 = load %struct.queuegrp*, %struct.queuegrp** %qg, align 8, !tbaa !1
  %qg_name98 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %72, i32 0, i32 0
  %73 = load i8*, i8** %qg_name98, align 8, !tbaa !157
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.170, i32 0, i32 0), i8* %73)
  br label %if.end.100

if.else:                                          ; preds = %sw.bb
  %74 = load i8*, i8** %p, align 8, !tbaa !1
  %call99 = call i8* @newstr(i8* %74)
  %75 = load %struct.queuegrp*, %struct.queuegrp** %qg, align 8, !tbaa !1
  %qg_qdir = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %75, i32 0, i32 1
  store i8* %call99, i8** %qg_qdir, align 8, !tbaa !94
  br label %if.end.100

if.end.100:                                       ; preds = %if.else, %if.then.97
  br label %sw.epilog

sw.bb.101:                                        ; preds = %while.end.91
  br label %for.cond.102

for.cond.102:                                     ; preds = %for.inc.125, %sw.bb.101
  %76 = load i8*, i8** %p, align 8, !tbaa !1
  %77 = load i8, i8* %76, align 1, !tbaa !17
  %conv103 = sext i8 %77 to i32
  %cmp104 = icmp ne i32 %conv103, 0
  br i1 %cmp104, label %for.body.106, label %for.end.127

for.body.106:                                     ; preds = %for.cond.102
  %78 = load i8*, i8** %p, align 8, !tbaa !1
  %79 = load i8, i8* %78, align 1, !tbaa !17
  %conv107 = sext i8 %79 to i32
  %and108 = and i32 %conv107, -128
  %cmp109 = icmp eq i32 %and108, 0
  br i1 %cmp109, label %land.lhs.true.111, label %if.then.119

land.lhs.true.111:                                ; preds = %for.body.106
  %80 = load i8*, i8** %p, align 8, !tbaa !1
  %81 = load i8, i8* %80, align 1, !tbaa !17
  %conv112 = sext i8 %81 to i32
  %idxprom113 = sext i32 %conv112 to i64
  %call114 = call i16** @__ctype_b_loc() #11
  %82 = load i16*, i16** %call114, align 8, !tbaa !1
  %arrayidx115 = getelementptr inbounds i16, i16* %82, i64 %idxprom113
  %83 = load i16, i16* %arrayidx115, align 2, !tbaa !88
  %conv116 = zext i16 %83 to i32
  %and117 = and i32 %conv116, 8192
  %tobool118 = icmp ne i32 %and117, 0
  br i1 %tobool118, label %if.end.124, label %if.then.119

if.then.119:                                      ; preds = %land.lhs.true.111, %for.body.106
  %84 = load i8*, i8** %p, align 8, !tbaa !1
  %85 = load i8, i8* %84, align 1, !tbaa !17
  %conv120 = zext i8 %85 to i64
  %rem = urem i64 %conv120, 32
  %sh_prom = trunc i64 %rem to i32
  %shl = shl i32 1, %sh_prom
  %86 = load i8*, i8** %p, align 8, !tbaa !1
  %87 = load i8, i8* %86, align 1, !tbaa !17
  %conv121 = zext i8 %87 to i64
  %div = udiv i64 %conv121, 32
  %and122 = and i64 %div, 7
  %88 = load %struct.queuegrp*, %struct.queuegrp** %qg, align 8, !tbaa !1
  %qg_flags = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %88, i32 0, i32 7
  %arrayidx123 = getelementptr inbounds [8 x i32], [8 x i32]* %qg_flags, i32 0, i64 %and122
  %89 = load i32, i32* %arrayidx123, align 4, !tbaa !5
  %or = or i32 %89, %shl
  store i32 %or, i32* %arrayidx123, align 4, !tbaa !5
  br label %if.end.124

if.end.124:                                       ; preds = %if.then.119, %land.lhs.true.111
  br label %for.inc.125

for.inc.125:                                      ; preds = %if.end.124
  %90 = load i8*, i8** %p, align 8, !tbaa !1
  %incdec.ptr126 = getelementptr inbounds i8, i8* %90, i32 1
  store i8* %incdec.ptr126, i8** %p, align 8, !tbaa !1
  br label %for.cond.102

for.end.127:                                      ; preds = %for.cond.102
  br label %sw.epilog

sw.bb.128:                                        ; preds = %while.end.91
  %91 = load i8*, i8** %p, align 8, !tbaa !1
  %call129 = call i64 @convtime(i8* %91, i32 109)
  %92 = load %struct.queuegrp*, %struct.queuegrp** %qg, align 8, !tbaa !1
  %qg_queueintvl = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %92, i32 0, i32 5
  store i64 %call129, i64* %qg_queueintvl, align 8, !tbaa !121
  br label %sw.epilog

sw.bb.130:                                        ; preds = %while.end.91
  %93 = load i8*, i8** %p, align 8, !tbaa !1
  %call131 = call i32 @atoi(i8* %93) #14
  %conv132 = trunc i32 %call131 to i16
  %94 = load %struct.queuegrp*, %struct.queuegrp** %qg, align 8, !tbaa !1
  %qg_nice = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %94, i32 0, i32 8
  store i16 %conv132, i16* %qg_nice, align 2, !tbaa !115
  br label %sw.epilog

sw.bb.133:                                        ; preds = %while.end.91
  %95 = load i8*, i8** %p, align 8, !tbaa !1
  %call134 = call i32 @atoi(i8* %95) #14
  store i32 %call134, i32* %i, align 4, !tbaa !5
  %96 = load i32, i32* @MaxQueueChildren, align 4, !tbaa !5
  %cmp135 = icmp sgt i32 %96, 0
  br i1 %cmp135, label %land.lhs.true.137, label %if.else.143

land.lhs.true.137:                                ; preds = %sw.bb.133
  %97 = load i32, i32* %i, align 4, !tbaa !5
  %98 = load i32, i32* @MaxQueueChildren, align 4, !tbaa !5
  %cmp138 = icmp sgt i32 %97, %98
  br i1 %cmp138, label %if.then.140, label %if.else.143

if.then.140:                                      ; preds = %land.lhs.true.137
  %99 = load i32, i32* @MaxQueueChildren, align 4, !tbaa !5
  %100 = load %struct.queuegrp*, %struct.queuegrp** %qg, align 8, !tbaa !1
  %qg_maxqrun = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %100, i32 0, i32 3
  store i32 %99, i32* %qg_maxqrun, align 4, !tbaa !117
  %101 = load %struct.queuegrp*, %struct.queuegrp** %qg, align 8, !tbaa !1
  %qg_name141 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %101, i32 0, i32 0
  %102 = load i8*, i8** %qg_name141, align 8, !tbaa !157
  %103 = load i32, i32* %i, align 4, !tbaa !5
  %104 = load i32, i32* @MaxQueueChildren, align 4, !tbaa !5
  %call142 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([65 x i8], [65 x i8]* @.str.171, i32 0, i32 0), i8* %102, i32 %103, i32 %104)
  br label %if.end.145

if.else.143:                                      ; preds = %land.lhs.true.137, %sw.bb.133
  %105 = load i32, i32* %i, align 4, !tbaa !5
  %106 = load %struct.queuegrp*, %struct.queuegrp** %qg, align 8, !tbaa !1
  %qg_maxqrun144 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %106, i32 0, i32 3
  store i32 %105, i32* %qg_maxqrun144, align 4, !tbaa !117
  br label %if.end.145

if.end.145:                                       ; preds = %if.else.143, %if.then.140
  br label %sw.epilog

sw.bb.146:                                        ; preds = %while.end.91
  %107 = load i8*, i8** %p, align 8, !tbaa !1
  %call147 = call i32 @atoi(i8* %107) #14
  %108 = load %struct.queuegrp*, %struct.queuegrp** %qg, align 8, !tbaa !1
  %qg_maxlist = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %108, i32 0, i32 10
  store i32 %call147, i32* %qg_maxlist, align 4, !tbaa !116
  br label %sw.epilog

sw.bb.148:                                        ; preds = %while.end.91
  %109 = load i8*, i8** %p, align 8, !tbaa !1
  %call149 = call i32 @atoi(i8* %109) #14
  %110 = load %struct.queuegrp*, %struct.queuegrp** %qg, align 8, !tbaa !1
  %qg_maxrcpt = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %110, i32 0, i32 12
  store i32 %call149, i32* %qg_maxrcpt, align 4, !tbaa !158
  br label %sw.epilog

sw.default:                                       ; preds = %while.end.91
  %111 = load %struct.queuegrp*, %struct.queuegrp** %qg, align 8, !tbaa !1
  %qg_name150 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %111, i32 0, i32 0
  %112 = load i8*, i8** %qg_name150, align 8, !tbaa !157
  %113 = load i8, i8* %fcode, align 1, !tbaa !17
  %conv151 = sext i8 %113 to i32
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.172, i32 0, i32 0), i8* %112, i32 %conv151)
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb.148, %sw.bb.146, %if.end.145, %sw.bb.130, %sw.bb.128, %for.end.127, %if.end.100
  %114 = load i8*, i8** %delimptr, align 8, !tbaa !1
  store i8* %114, i8** %p, align 8, !tbaa !1
  store i32 0, i32* %cleanup.dest.slot
  br label %cleanup

cleanup:                                          ; preds = %sw.epilog, %if.then.72
  %115 = bitcast i8** %delimptr to i8*
  call void @llvm.lifetime.end(i64 8, i8* %115) #1
  %cleanup.dest = load i32, i32* %cleanup.dest.slot
  switch i32 %cleanup.dest, label %cleanup.229 [
    i32 0, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %while.cond

while.end.152:                                    ; preds = %while.cond
  %116 = load i32, i32* @NumQueue, align 4, !tbaa !5
  %cmp153 = icmp sge i32 %116, 50
  br i1 %cmp153, label %if.then.155, label %if.end.156

if.then.155:                                      ; preds = %while.end.152
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.173, i32 0, i32 0), i32 50)
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup.229

if.end.156:                                       ; preds = %while.end.152
  %117 = load %struct.queuegrp*, %struct.queuegrp** %qg, align 8, !tbaa !1
  %qg_qdir157 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %117, i32 0, i32 1
  %118 = load i8*, i8** %qg_qdir157, align 8, !tbaa !94
  %cmp158 = icmp eq i8* %118, null
  br i1 %cmp158, label %if.then.160, label %if.end.170

if.then.160:                                      ; preds = %if.end.156
  %119 = load i8*, i8** @QueueDir, align 8, !tbaa !1
  %cmp161 = icmp eq i8* %119, null
  br i1 %cmp161, label %if.then.166, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then.160
  %120 = load i8*, i8** @QueueDir, align 8, !tbaa !1
  %121 = load i8, i8* %120, align 1, !tbaa !17
  %conv163 = sext i8 %121 to i32
  %cmp164 = icmp eq i32 %conv163, 0
  br i1 %cmp164, label %if.then.166, label %if.end.167

if.then.166:                                      ; preds = %lor.lhs.false, %if.then.160
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.174, i32 0, i32 0))
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup.229

if.end.167:                                       ; preds = %lor.lhs.false
  %122 = load i8*, i8** @QueueDir, align 8, !tbaa !1
  %call168 = call i8* @newstr(i8* %122)
  %123 = load %struct.queuegrp*, %struct.queuegrp** %qg, align 8, !tbaa !1
  %qg_qdir169 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %123, i32 0, i32 1
  store i8* %call168, i8** %qg_qdir169, align 8, !tbaa !94
  br label %if.end.170

if.end.170:                                       ; preds = %if.end.167, %if.end.156
  %124 = load %struct.queuegrp*, %struct.queuegrp** %qg, align 8, !tbaa !1
  %qg_maxqrun171 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %124, i32 0, i32 3
  %125 = load i32, i32* %qg_maxqrun171, align 4, !tbaa !117
  %cmp172 = icmp sgt i32 %125, 1
  br i1 %cmp172, label %land.lhs.true.174, label %if.end.183

land.lhs.true.174:                                ; preds = %if.end.170
  %126 = load %struct.queuegrp*, %struct.queuegrp** %qg, align 8, !tbaa !1
  %qg_flags175 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %126, i32 0, i32 7
  %arrayidx176 = getelementptr inbounds [8 x i32], [8 x i32]* %qg_flags175, i32 0, i64 3
  %127 = load i32, i32* %arrayidx176, align 4, !tbaa !5
  %and177 = and i32 %127, 64
  %tobool178 = icmp ne i32 %and177, 0
  br i1 %tobool178, label %if.end.183, label %if.then.179

if.then.179:                                      ; preds = %land.lhs.true.174
  %128 = load %struct.queuegrp*, %struct.queuegrp** %qg, align 8, !tbaa !1
  %qg_name180 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %128, i32 0, i32 0
  %129 = load i8*, i8** %qg_name180, align 8, !tbaa !157
  %130 = load %struct.queuegrp*, %struct.queuegrp** %qg, align 8, !tbaa !1
  %qg_maxqrun181 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %130, i32 0, i32 3
  %131 = load i32, i32* %qg_maxqrun181, align 4, !tbaa !117
  %call182 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([81 x i8], [81 x i8]* @.str.175, i32 0, i32 0), i8* %129, i32 %131, i32 102)
  br label %if.end.183

if.end.183:                                       ; preds = %if.then.179, %land.lhs.true.174, %if.end.170
  %132 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 37), align 1, !tbaa !17
  %conv184 = zext i8 %132 to i32
  %cmp185 = icmp sge i32 %conv184, 8
  br i1 %cmp185, label %land.lhs.true.187, label %if.end.192

land.lhs.true.187:                                ; preds = %if.end.183
  %133 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool188 = icmp ne i32 %133, 0
  br i1 %tobool188, label %if.end.192, label %if.then.189

if.then.189:                                      ; preds = %land.lhs.true.187
  %134 = load %struct.queuegrp*, %struct.queuegrp** %qg, align 8, !tbaa !1
  %qg_name190 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %134, i32 0, i32 0
  %135 = load i8*, i8** %qg_name190, align 8, !tbaa !157
  %136 = load %struct.queuegrp*, %struct.queuegrp** %qg, align 8, !tbaa !1
  %qg_qdir191 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %136, i32 0, i32 1
  %137 = load i8*, i8** %qg_qdir191, align 8, !tbaa !94
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 6, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0), i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.176, i32 0, i32 0), i8* %135, i8* %137)
  br label %if.end.192

if.end.192:                                       ; preds = %if.then.189, %land.lhs.true.187, %if.end.183
  %138 = load %struct.queuegrp*, %struct.queuegrp** %qg, align 8, !tbaa !1
  %qg_name193 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %138, i32 0, i32 0
  %139 = load i8*, i8** %qg_name193, align 8, !tbaa !157
  %call194 = call %struct.symtab* @stab(i8* %139, i32 15, i32 1)
  store %struct.symtab* %call194, %struct.symtab** %s, align 8, !tbaa !1
  %140 = load %struct.symtab*, %struct.symtab** %s, align 8, !tbaa !1
  %s_value = getelementptr inbounds %struct.symtab, %struct.symtab* %140, i32 0, i32 3
  %sv_queue = bitcast %union.anon* %s_value to %struct.queuegrp**
  %141 = load %struct.queuegrp*, %struct.queuegrp** %sv_queue, align 8, !tbaa !1
  %cmp195 = icmp ne %struct.queuegrp* %141, null
  br i1 %cmp195, label %if.then.197, label %if.else.203

if.then.197:                                      ; preds = %if.end.192
  %142 = load %struct.symtab*, %struct.symtab** %s, align 8, !tbaa !1
  %s_value198 = getelementptr inbounds %struct.symtab, %struct.symtab* %142, i32 0, i32 3
  %sv_queue199 = bitcast %union.anon* %s_value198 to %struct.queuegrp**
  %143 = load %struct.queuegrp*, %struct.queuegrp** %sv_queue199, align 8, !tbaa !1
  %qg_index = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %143, i32 0, i32 2
  %144 = load i16, i16* %qg_index, align 2, !tbaa !112
  %conv200 = sext i16 %144 to i32
  store i32 %conv200, i32* %i, align 4, !tbaa !5
  %145 = load %struct.symtab*, %struct.symtab** %s, align 8, !tbaa !1
  %s_value201 = getelementptr inbounds %struct.symtab, %struct.symtab* %145, i32 0, i32 3
  %sv_queue202 = bitcast %union.anon* %s_value201 to %struct.queuegrp**
  %146 = load %struct.queuegrp*, %struct.queuegrp** %sv_queue202, align 8, !tbaa !1
  %147 = bitcast %struct.queuegrp* %146 to i8*
  call void @sm_free_tagged(i8* %147, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 7529)
  br label %if.end.204

if.else.203:                                      ; preds = %if.end.192
  %148 = load i32, i32* @NumQueue, align 4, !tbaa !5
  %inc = add nsw i32 %148, 1
  store i32 %inc, i32* @NumQueue, align 4, !tbaa !5
  store i32 %148, i32* %i, align 4, !tbaa !5
  br label %if.end.204

if.end.204:                                       ; preds = %if.else.203, %if.then.197
  %149 = load %struct.queuegrp*, %struct.queuegrp** %qg, align 8, !tbaa !1
  %150 = load %struct.symtab*, %struct.symtab** %s, align 8, !tbaa !1
  %s_value205 = getelementptr inbounds %struct.symtab, %struct.symtab* %150, i32 0, i32 3
  %sv_queue206 = bitcast %union.anon* %s_value205 to %struct.queuegrp**
  store %struct.queuegrp* %149, %struct.queuegrp** %sv_queue206, align 8, !tbaa !1
  %151 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom207 = sext i32 %151 to i64
  %arrayidx208 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom207
  store %struct.queuegrp* %149, %struct.queuegrp** %arrayidx208, align 8, !tbaa !1
  %152 = load i32, i32* %i, align 4, !tbaa !5
  %conv209 = trunc i32 %152 to i16
  %153 = load %struct.queuegrp*, %struct.queuegrp** %qg, align 8, !tbaa !1
  %qg_index210 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %153, i32 0, i32 2
  store i16 %conv209, i16* %qg_index210, align 2, !tbaa !112
  %154 = load %struct.queuegrp*, %struct.queuegrp** %qg, align 8, !tbaa !1
  %qg_maxqrun211 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %154, i32 0, i32 3
  %155 = load i32, i32* %qg_maxqrun211, align 4, !tbaa !117
  %cmp212 = icmp slt i32 %155, 0
  br i1 %cmp212, label %if.then.214, label %if.end.222

if.then.214:                                      ; preds = %if.end.204
  %156 = load i32, i32* @MaxRunnersPerQueue, align 4, !tbaa !5
  %cmp215 = icmp sgt i32 %156, 0
  br i1 %cmp215, label %if.then.217, label %if.else.219

if.then.217:                                      ; preds = %if.then.214
  %157 = load i32, i32* @MaxRunnersPerQueue, align 4, !tbaa !5
  %158 = load %struct.queuegrp*, %struct.queuegrp** %qg, align 8, !tbaa !1
  %qg_maxqrun218 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %158, i32 0, i32 3
  store i32 %157, i32* %qg_maxqrun218, align 4, !tbaa !117
  br label %if.end.221

if.else.219:                                      ; preds = %if.then.214
  %159 = load %struct.queuegrp*, %struct.queuegrp** %qg, align 8, !tbaa !1
  %qg_maxqrun220 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %159, i32 0, i32 3
  store i32 1, i32* %qg_maxqrun220, align 4, !tbaa !117
  br label %if.end.221

if.end.221:                                       ; preds = %if.else.219, %if.then.217
  br label %if.end.222

if.end.222:                                       ; preds = %if.end.221, %if.end.204
  %160 = load i32, i32* %qdef.addr, align 4, !tbaa !5
  %tobool223 = icmp ne i32 %160, 0
  br i1 %tobool223, label %if.then.224, label %if.end.228

if.then.224:                                      ; preds = %if.end.222
  %161 = load %struct.queuegrp*, %struct.queuegrp** %qg, align 8, !tbaa !1
  %qg_flags225 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %161, i32 0, i32 7
  %arrayidx226 = getelementptr inbounds [8 x i32], [8 x i32]* %qg_flags225, i32 0, i64 0
  %162 = load i32, i32* %arrayidx226, align 4, !tbaa !5
  %or227 = or i32 %162, 2
  store i32 %or227, i32* %arrayidx226, align 4, !tbaa !5
  br label %if.end.228

if.end.228:                                       ; preds = %if.then.224, %if.end.222
  store i32 0, i32* %cleanup.dest.slot
  br label %cleanup.229

cleanup.229:                                      ; preds = %if.end.228, %if.then.166, %if.then.155, %cleanup, %if.then
  call void @llvm.lifetime.end(i64 1, i8* %fcode) #1
  %163 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end(i64 4, i8* %163) #1
  %164 = bitcast %struct.symtab** %s to i8*
  call void @llvm.lifetime.end(i64 8, i8* %164) #1
  %165 = bitcast %struct.queuegrp** %qg to i8*
  call void @llvm.lifetime.end(i64 8, i8* %165) #1
  %166 = bitcast i8** %p to i8*
  call void @llvm.lifetime.end(i64 8, i8* %166) #1
  %cleanup.dest.234 = load i32, i32* %cleanup.dest.slot
  switch i32 %cleanup.dest.234, label %unreachable [
    i32 0, label %cleanup.cont.235
    i32 1, label %cleanup.cont.235
  ]

cleanup.cont.235:                                 ; preds = %cleanup.229, %cleanup.229
  ret void

unreachable:                                      ; preds = %cleanup.229
  unreachable
}

declare i8* @xalloc_tagged(i32, i8*, i32) #2

; Function Attrs: nounwind readnone
declare i16** @__ctype_b_loc() #4

declare i8* @newstr(i8*) #2

declare i8* @munchstring(i8*, i8**, i32) #2

declare i64 @convtime(i8*, i32) #2

declare void @sm_free_tagged(i8*, i8*, i32) #2

; Function Attrs: nounwind uwtable
define void @makeworkgroups() #0 {
entry:
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %total_runners = alloca i32, align 4
  %dir = alloca i32, align 4
  %h = alloca i32, align 4
  %si = alloca [51 x %struct.sortqgrp], align 16
  %__s1_len = alloca i64, align 8
  %__s2_len = alloca i64, align 8
  %tmp = alloca i32, align 4
  %__s1 = alloca i8*, align 8
  %__result = alloca i32, align 4
  %tmp37 = alloca i32, align 4
  %cleanup.dest.slot = alloca i32
  %0 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start(i64 4, i8* %0) #1
  %1 = bitcast i32* %j to i8*
  call void @llvm.lifetime.start(i64 4, i8* %1) #1
  %2 = bitcast i32* %total_runners to i8*
  call void @llvm.lifetime.start(i64 4, i8* %2) #1
  %3 = bitcast i32* %dir to i8*
  call void @llvm.lifetime.start(i64 4, i8* %3) #1
  %4 = bitcast i32* %h to i8*
  call void @llvm.lifetime.start(i64 4, i8* %4) #1
  %5 = bitcast [51 x %struct.sortqgrp]* %si to i8*
  call void @llvm.lifetime.start(i64 408, i8* %5) #1
  store i32 0, i32* %total_runners, align 4, !tbaa !5
  %6 = load i32, i32* @NumQueue, align 4, !tbaa !5
  %cmp = icmp eq i32 %6, 1
  br i1 %cmp, label %land.lhs.true, label %if.end.61

land.lhs.true:                                    ; preds = %entry
  %7 = bitcast i64* %__s1_len to i8*
  call void @llvm.lifetime.start(i64 8, i8* %7) #1
  %8 = bitcast i64* %__s2_len to i8*
  call void @llvm.lifetime.start(i64 8, i8* %8) #1
  br i1 icmp eq (i64 sub (i64 ptrtoint (i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.177, i32 0, i64 1) to i64), i64 ptrtoint ([7 x i8]* @.str.177 to i64)), i64 1), label %land.lhs.true.1, label %cond.false

land.lhs.true.1:                                  ; preds = %land.lhs.true
  store i64 6, i64* %__s2_len, align 8, !tbaa !92
  %9 = load i64, i64* %__s2_len, align 8, !tbaa !92
  %cmp2 = icmp ult i64 %9, 4
  br i1 %cmp2, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true.1
  %10 = bitcast i8** %__s1 to i8*
  call void @llvm.lifetime.start(i64 8, i8* %10) #1
  %11 = load %struct.queuegrp*, %struct.queuegrp** getelementptr inbounds ([51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 0), align 8, !tbaa !1
  %qg_name = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %11, i32 0, i32 0
  %12 = load i8*, i8** %qg_name, align 8, !tbaa !157
  store i8* %12, i8** %__s1, align 8, !tbaa !1
  %13 = bitcast i32* %__result to i8*
  call void @llvm.lifetime.start(i64 4, i8* %13) #1
  %14 = load i8*, i8** %__s1, align 8, !tbaa !1
  %arrayidx = getelementptr inbounds i8, i8* %14, i64 0
  %15 = load i8, i8* %arrayidx, align 1, !tbaa !17
  %conv = zext i8 %15 to i32
  %16 = load i8, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.177, i32 0, i32 0), align 1, !tbaa !17
  %conv5 = zext i8 %16 to i32
  %sub = sub nsw i32 %conv, %conv5
  store i32 %sub, i32* %__result, align 4, !tbaa !5
  %17 = load i64, i64* %__s2_len, align 8, !tbaa !92
  %cmp6 = icmp ugt i64 %17, 0
  br i1 %cmp6, label %land.lhs.true.8, label %if.end.36

land.lhs.true.8:                                  ; preds = %cond.true
  %18 = load i32, i32* %__result, align 4, !tbaa !5
  %cmp9 = icmp eq i32 %18, 0
  br i1 %cmp9, label %if.then, label %if.end.36

if.then:                                          ; preds = %land.lhs.true.8
  %19 = load i8*, i8** %__s1, align 8, !tbaa !1
  %arrayidx11 = getelementptr inbounds i8, i8* %19, i64 1
  %20 = load i8, i8* %arrayidx11, align 1, !tbaa !17
  %conv12 = zext i8 %20 to i32
  %21 = load i8, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.177, i32 0, i64 1), align 1, !tbaa !17
  %conv13 = zext i8 %21 to i32
  %sub14 = sub nsw i32 %conv12, %conv13
  store i32 %sub14, i32* %__result, align 4, !tbaa !5
  %22 = load i64, i64* %__s2_len, align 8, !tbaa !92
  %cmp15 = icmp ugt i64 %22, 1
  br i1 %cmp15, label %land.lhs.true.17, label %if.end.35

land.lhs.true.17:                                 ; preds = %if.then
  %23 = load i32, i32* %__result, align 4, !tbaa !5
  %cmp18 = icmp eq i32 %23, 0
  br i1 %cmp18, label %if.then.20, label %if.end.35

if.then.20:                                       ; preds = %land.lhs.true.17
  %24 = load i8*, i8** %__s1, align 8, !tbaa !1
  %arrayidx21 = getelementptr inbounds i8, i8* %24, i64 2
  %25 = load i8, i8* %arrayidx21, align 1, !tbaa !17
  %conv22 = zext i8 %25 to i32
  %26 = load i8, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.177, i32 0, i64 2), align 1, !tbaa !17
  %conv23 = zext i8 %26 to i32
  %sub24 = sub nsw i32 %conv22, %conv23
  store i32 %sub24, i32* %__result, align 4, !tbaa !5
  %27 = load i64, i64* %__s2_len, align 8, !tbaa !92
  %cmp25 = icmp ugt i64 %27, 2
  br i1 %cmp25, label %land.lhs.true.27, label %if.end

land.lhs.true.27:                                 ; preds = %if.then.20
  %28 = load i32, i32* %__result, align 4, !tbaa !5
  %cmp28 = icmp eq i32 %28, 0
  br i1 %cmp28, label %if.then.30, label %if.end

if.then.30:                                       ; preds = %land.lhs.true.27
  %29 = load i8*, i8** %__s1, align 8, !tbaa !1
  %arrayidx31 = getelementptr inbounds i8, i8* %29, i64 3
  %30 = load i8, i8* %arrayidx31, align 1, !tbaa !17
  %conv32 = zext i8 %30 to i32
  %31 = load i8, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.177, i32 0, i64 3), align 1, !tbaa !17
  %conv33 = zext i8 %31 to i32
  %sub34 = sub nsw i32 %conv32, %conv33
  store i32 %sub34, i32* %__result, align 4, !tbaa !5
  br label %if.end

if.end:                                           ; preds = %if.then.30, %land.lhs.true.27, %if.then.20
  br label %if.end.35

if.end.35:                                        ; preds = %if.end, %land.lhs.true.17, %if.then
  br label %if.end.36

if.end.36:                                        ; preds = %if.end.35, %land.lhs.true.8, %cond.true
  %32 = load i32, i32* %__result, align 4, !tbaa !5
  store i32 %32, i32* %tmp37, !tbaa !5
  %33 = bitcast i32* %__result to i8*
  call void @llvm.lifetime.end(i64 4, i8* %33) #1
  %34 = bitcast i8** %__s1 to i8*
  call void @llvm.lifetime.end(i64 8, i8* %34) #1
  %35 = load i32, i32* %tmp37, !tbaa !5
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true.1, %land.lhs.true
  %36 = load %struct.queuegrp*, %struct.queuegrp** getelementptr inbounds ([51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 0), align 8, !tbaa !1
  %qg_name38 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %36, i32 0, i32 0
  %37 = load i8*, i8** %qg_name38, align 8, !tbaa !157
  %call = call i32 @strcmp(i8* %37, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.177, i32 0, i32 0)) #1
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %if.end.36
  %cond = phi i32 [ %35, %if.end.36 ], [ %call, %cond.false ]
  store i32 %cond, i32* %tmp, !tbaa !5
  %38 = bitcast i64* %__s2_len to i8*
  call void @llvm.lifetime.end(i64 8, i8* %38) #1
  %39 = bitcast i64* %__s1_len to i8*
  call void @llvm.lifetime.end(i64 8, i8* %39) #1
  %40 = load i32, i32* %tmp, !tbaa !5
  %cmp39 = icmp eq i32 %40, 0
  br i1 %cmp39, label %if.then.41, label %if.end.61

if.then.41:                                       ; preds = %cond.end
  store i32 1, i32* @NumWorkGroups, align 4, !tbaa !5
  store volatile i32 1, i32* getelementptr inbounds ([51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 0, i32 0), align 4, !tbaa !107
  %call42 = call i8* @xalloc_tagged(i32 8, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 7665)
  %41 = bitcast i8* %call42 to %struct.queuegrp**
  store volatile %struct.queuegrp** %41, %struct.queuegrp*** getelementptr inbounds ([51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 0, i32 3), align 8, !tbaa !106
  %42 = load %struct.queuegrp*, %struct.queuegrp** getelementptr inbounds ([51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 0), align 8, !tbaa !1
  %43 = load volatile %struct.queuegrp**, %struct.queuegrp*** getelementptr inbounds ([51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 0, i32 3), align 8, !tbaa !106
  %arrayidx43 = getelementptr inbounds %struct.queuegrp*, %struct.queuegrp** %43, i64 0
  store %struct.queuegrp* %42, %struct.queuegrp** %arrayidx43, align 8, !tbaa !1
  %44 = load i32, i32* @MaxQueueChildren, align 4, !tbaa !5
  %cmp44 = icmp sgt i32 %44, 0
  br i1 %cmp44, label %land.lhs.true.46, label %if.else

land.lhs.true.46:                                 ; preds = %if.then.41
  %45 = load %struct.queuegrp*, %struct.queuegrp** getelementptr inbounds ([51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 0), align 8, !tbaa !1
  %qg_numqueues = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %45, i32 0, i32 4
  %46 = load i32, i32* %qg_numqueues, align 4, !tbaa !82
  %47 = load i32, i32* @MaxQueueChildren, align 4, !tbaa !5
  %cmp47 = icmp sgt i32 %46, %47
  br i1 %cmp47, label %if.then.49, label %if.else

if.then.49:                                       ; preds = %land.lhs.true.46
  %48 = load i32, i32* @MaxQueueChildren, align 4, !tbaa !5
  store volatile i32 %48, i32* getelementptr inbounds ([51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 0, i32 1), align 4, !tbaa !159
  br label %if.end.51

if.else:                                          ; preds = %land.lhs.true.46, %if.then.41
  %49 = load %struct.queuegrp*, %struct.queuegrp** getelementptr inbounds ([51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 0), align 8, !tbaa !1
  %qg_numqueues50 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %49, i32 0, i32 4
  %50 = load i32, i32* %qg_numqueues50, align 4, !tbaa !82
  store volatile i32 %50, i32* getelementptr inbounds ([51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 0, i32 1), align 4, !tbaa !159
  br label %if.end.51

if.end.51:                                        ; preds = %if.else, %if.then.49
  %51 = load %struct.queuegrp*, %struct.queuegrp** getelementptr inbounds ([51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 0), align 8, !tbaa !1
  %qg_wgrp = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %51, i32 0, i32 9
  store i32 0, i32* %qg_wgrp, align 4, !tbaa !160
  %52 = load i32, i32* @MaxQueueChildren, align 4, !tbaa !5
  %cmp52 = icmp sgt i32 %52, 0
  br i1 %cmp52, label %land.lhs.true.54, label %if.end.59

land.lhs.true.54:                                 ; preds = %if.end.51
  %53 = load %struct.queuegrp*, %struct.queuegrp** getelementptr inbounds ([51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 0), align 8, !tbaa !1
  %qg_maxqrun = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %53, i32 0, i32 3
  %54 = load i32, i32* %qg_maxqrun, align 4, !tbaa !117
  %55 = load i32, i32* @MaxQueueChildren, align 4, !tbaa !5
  %cmp55 = icmp sgt i32 %54, %55
  br i1 %cmp55, label %if.then.57, label %if.end.59

if.then.57:                                       ; preds = %land.lhs.true.54
  %56 = load i32, i32* @MaxQueueChildren, align 4, !tbaa !5
  %57 = load %struct.queuegrp*, %struct.queuegrp** getelementptr inbounds ([51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 0), align 8, !tbaa !1
  %qg_maxqrun58 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %57, i32 0, i32 3
  store i32 %56, i32* %qg_maxqrun58, align 4, !tbaa !117
  br label %if.end.59

if.end.59:                                        ; preds = %if.then.57, %land.lhs.true.54, %if.end.51
  %58 = load %struct.queuegrp*, %struct.queuegrp** getelementptr inbounds ([51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 0), align 8, !tbaa !1
  %qg_maxqrun60 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %58, i32 0, i32 3
  %59 = load i32, i32* %qg_maxqrun60, align 4, !tbaa !117
  store volatile i32 %59, i32* getelementptr inbounds ([51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 0, i32 4), align 4, !tbaa !108
  %60 = load %struct.queuegrp*, %struct.queuegrp** getelementptr inbounds ([51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 0), align 8, !tbaa !1
  %qg_queueintvl = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %60, i32 0, i32 5
  %61 = load i64, i64* %qg_queueintvl, align 8, !tbaa !121
  store volatile i64 %61, i64* getelementptr inbounds ([51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 0, i32 5), align 8, !tbaa !109
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.61:                                        ; preds = %cond.end, %entry
  store i32 0, i32* %i, align 4, !tbaa !5
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end.61
  %62 = load i32, i32* %i, align 4, !tbaa !5
  %63 = load i32, i32* @NumQueue, align 4, !tbaa !5
  %cmp62 = icmp slt i32 %62, %63
  br i1 %cmp62, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %64 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom = sext i32 %64 to i64
  %arrayidx64 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom
  %65 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx64, align 8, !tbaa !1
  %qg_maxqrun65 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %65, i32 0, i32 3
  %66 = load i32, i32* %qg_maxqrun65, align 4, !tbaa !117
  %67 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom66 = sext i32 %67 to i64
  %arrayidx67 = getelementptr inbounds [51 x %struct.sortqgrp], [51 x %struct.sortqgrp]* %si, i32 0, i64 %idxprom66
  %sg_maxqrun = getelementptr inbounds %struct.sortqgrp, %struct.sortqgrp* %arrayidx67, i32 0, i32 1
  store i32 %66, i32* %sg_maxqrun, align 4, !tbaa !161
  %68 = load i32, i32* %i, align 4, !tbaa !5
  %69 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom68 = sext i32 %69 to i64
  %arrayidx69 = getelementptr inbounds [51 x %struct.sortqgrp], [51 x %struct.sortqgrp]* %si, i32 0, i64 %idxprom68
  %sg_idx = getelementptr inbounds %struct.sortqgrp, %struct.sortqgrp* %arrayidx69, i32 0, i32 0
  store i32 %68, i32* %sg_idx, align 4, !tbaa !163
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %70 = load i32, i32* %i, align 4, !tbaa !5
  %inc = add nsw i32 %70, 1
  store i32 %inc, i32* %i, align 4, !tbaa !5
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %arraydecay = getelementptr inbounds [51 x %struct.sortqgrp], [51 x %struct.sortqgrp]* %si, i32 0, i32 0
  %71 = bitcast %struct.sortqgrp* %arraydecay to i8*
  %72 = load i32, i32* @NumQueue, align 4, !tbaa !5
  %conv70 = sext i32 %72 to i64
  call void @qsort(i8* %71, i64 %conv70, i64 8, i32 (i8*, i8*)* @cmpidx)
  store i32 0, i32* @NumWorkGroups, align 4, !tbaa !5
  store i32 0, i32* %i, align 4, !tbaa !5
  br label %for.cond.71

for.cond.71:                                      ; preds = %for.inc.86, %for.end
  %73 = load i32, i32* %i, align 4, !tbaa !5
  %74 = load i32, i32* @NumQueue, align 4, !tbaa !5
  %cmp72 = icmp slt i32 %73, %74
  br i1 %cmp72, label %for.body.74, label %for.end.88

for.body.74:                                      ; preds = %for.cond.71
  %75 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom75 = sext i32 %75 to i64
  %arrayidx76 = getelementptr inbounds [51 x %struct.sortqgrp], [51 x %struct.sortqgrp]* %si, i32 0, i64 %idxprom75
  %sg_maxqrun77 = getelementptr inbounds %struct.sortqgrp, %struct.sortqgrp* %arrayidx76, i32 0, i32 1
  %76 = load i32, i32* %sg_maxqrun77, align 4, !tbaa !161
  %77 = load i32, i32* %total_runners, align 4, !tbaa !5
  %add = add nsw i32 %77, %76
  store i32 %add, i32* %total_runners, align 4, !tbaa !5
  %78 = load i32, i32* @MaxQueueChildren, align 4, !tbaa !5
  %cmp78 = icmp sle i32 %78, 0
  br i1 %cmp78, label %if.then.82, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body.74
  %79 = load i32, i32* %total_runners, align 4, !tbaa !5
  %80 = load i32, i32* @MaxQueueChildren, align 4, !tbaa !5
  %cmp80 = icmp sle i32 %79, %80
  br i1 %cmp80, label %if.then.82, label %if.else.84

if.then.82:                                       ; preds = %lor.lhs.false, %for.body.74
  %81 = load i32, i32* @NumWorkGroups, align 4, !tbaa !5
  %inc83 = add nsw i32 %81, 1
  store i32 %inc83, i32* @NumWorkGroups, align 4, !tbaa !5
  br label %if.end.85

if.else.84:                                       ; preds = %lor.lhs.false
  br label %for.end.88

if.end.85:                                        ; preds = %if.then.82
  br label %for.inc.86

for.inc.86:                                       ; preds = %if.end.85
  %82 = load i32, i32* %i, align 4, !tbaa !5
  %inc87 = add nsw i32 %82, 1
  store i32 %inc87, i32* %i, align 4, !tbaa !5
  br label %for.cond.71

for.end.88:                                       ; preds = %if.else.84, %for.cond.71
  %83 = load i32, i32* @NumWorkGroups, align 4, !tbaa !5
  %cmp89 = icmp slt i32 %83, 1
  br i1 %cmp89, label %if.then.91, label %if.else.92

if.then.91:                                       ; preds = %for.end.88
  store i32 1, i32* @NumWorkGroups, align 4, !tbaa !5
  br label %if.end.97

if.else.92:                                       ; preds = %for.end.88
  %84 = load i32, i32* @NumWorkGroups, align 4, !tbaa !5
  %cmp93 = icmp sgt i32 %84, 50
  br i1 %cmp93, label %if.then.95, label %if.end.96

if.then.95:                                       ; preds = %if.else.92
  store i32 50, i32* @NumWorkGroups, align 4, !tbaa !5
  br label %if.end.96

if.end.96:                                        ; preds = %if.then.95, %if.else.92
  br label %if.end.97

if.end.97:                                        ; preds = %if.end.96, %if.then.91
  store i32 0, i32* %j, align 4, !tbaa !5
  store i32 1, i32* %dir, align 4, !tbaa !5
  store i32 0, i32* %i, align 4, !tbaa !5
  br label %for.cond.98

for.cond.98:                                      ; preds = %for.inc.227, %if.end.97
  %85 = load i32, i32* %i, align 4, !tbaa !5
  %86 = load i32, i32* @NumQueue, align 4, !tbaa !5
  %cmp99 = icmp slt i32 %85, %86
  br i1 %cmp99, label %for.body.101, label %for.end.229

for.body.101:                                     ; preds = %for.cond.98
  %87 = load i32, i32* %j, align 4, !tbaa !5
  %88 = load i32, i32* @NumWorkGroups, align 4, !tbaa !5
  %cmp102 = icmp sge i32 %87, %88
  br i1 %cmp102, label %if.then.104, label %if.else.106

if.then.104:                                      ; preds = %for.body.101
  store i32 -1, i32* %dir, align 4, !tbaa !5
  %89 = load i32, i32* @NumWorkGroups, align 4, !tbaa !5
  %sub105 = sub nsw i32 %89, 1
  store i32 %sub105, i32* %j, align 4, !tbaa !5
  br label %if.end.111

if.else.106:                                      ; preds = %for.body.101
  %90 = load i32, i32* %j, align 4, !tbaa !5
  %cmp107 = icmp slt i32 %90, 0
  br i1 %cmp107, label %if.then.109, label %if.end.110

if.then.109:                                      ; preds = %if.else.106
  store i32 0, i32* %j, align 4, !tbaa !5
  store i32 1, i32* %dir, align 4, !tbaa !5
  br label %if.end.110

if.end.110:                                       ; preds = %if.then.109, %if.else.106
  br label %if.end.111

if.end.111:                                       ; preds = %if.end.110, %if.then.104
  %91 = load i32, i32* %j, align 4, !tbaa !5
  %idxprom112 = sext i32 %91 to i64
  %arrayidx113 = getelementptr inbounds [51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 %idxprom112
  %wg_qgs = getelementptr inbounds %struct.workgrp, %struct.workgrp* %arrayidx113, i32 0, i32 3
  %92 = load volatile %struct.queuegrp**, %struct.queuegrp*** %wg_qgs, align 8, !tbaa !106
  %cmp114 = icmp eq %struct.queuegrp** %92, null
  br i1 %cmp114, label %if.then.116, label %if.else.125

if.then.116:                                      ; preds = %if.end.111
  %93 = load i32, i32* %j, align 4, !tbaa !5
  %idxprom117 = sext i32 %93 to i64
  %arrayidx118 = getelementptr inbounds [51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 %idxprom117
  %wg_numqgrp = getelementptr inbounds %struct.workgrp, %struct.workgrp* %arrayidx118, i32 0, i32 0
  %94 = load volatile i32, i32* %wg_numqgrp, align 4, !tbaa !107
  %add119 = add nsw i32 %94, 1
  %conv120 = sext i32 %add119 to i64
  %mul = mul i64 8, %conv120
  %95 = load i32, i32* @SmHeapGroup, align 4, !tbaa !5
  %call121 = call i8* @sm_malloc_tagged(i64 %mul, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 7736, i32 %95)
  %96 = bitcast i8* %call121 to %struct.queuegrp**
  %97 = load i32, i32* %j, align 4, !tbaa !5
  %idxprom122 = sext i32 %97 to i64
  %arrayidx123 = getelementptr inbounds [51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 %idxprom122
  %wg_qgs124 = getelementptr inbounds %struct.workgrp, %struct.workgrp* %arrayidx123, i32 0, i32 3
  store volatile %struct.queuegrp** %96, %struct.queuegrp*** %wg_qgs124, align 8, !tbaa !106
  br label %if.end.139

if.else.125:                                      ; preds = %if.end.111
  %98 = load i32, i32* %j, align 4, !tbaa !5
  %idxprom126 = sext i32 %98 to i64
  %arrayidx127 = getelementptr inbounds [51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 %idxprom126
  %wg_qgs128 = getelementptr inbounds %struct.workgrp, %struct.workgrp* %arrayidx127, i32 0, i32 3
  %99 = load volatile %struct.queuegrp**, %struct.queuegrp*** %wg_qgs128, align 8, !tbaa !106
  %100 = bitcast %struct.queuegrp** %99 to i8*
  %101 = load i32, i32* %j, align 4, !tbaa !5
  %idxprom129 = sext i32 %101 to i64
  %arrayidx130 = getelementptr inbounds [51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 %idxprom129
  %wg_numqgrp131 = getelementptr inbounds %struct.workgrp, %struct.workgrp* %arrayidx130, i32 0, i32 0
  %102 = load volatile i32, i32* %wg_numqgrp131, align 4, !tbaa !107
  %add132 = add nsw i32 %102, 1
  %conv133 = sext i32 %add132 to i64
  %mul134 = mul i64 8, %conv133
  %call135 = call i8* @sm_realloc(i8* %100, i64 %mul134)
  %103 = bitcast i8* %call135 to %struct.queuegrp**
  %104 = load i32, i32* %j, align 4, !tbaa !5
  %idxprom136 = sext i32 %104 to i64
  %arrayidx137 = getelementptr inbounds [51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 %idxprom136
  %wg_qgs138 = getelementptr inbounds %struct.workgrp, %struct.workgrp* %arrayidx137, i32 0, i32 3
  store volatile %struct.queuegrp** %103, %struct.queuegrp*** %wg_qgs138, align 8, !tbaa !106
  br label %if.end.139

if.end.139:                                       ; preds = %if.else.125, %if.then.116
  %105 = load i32, i32* %j, align 4, !tbaa !5
  %idxprom140 = sext i32 %105 to i64
  %arrayidx141 = getelementptr inbounds [51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 %idxprom140
  %wg_qgs142 = getelementptr inbounds %struct.workgrp, %struct.workgrp* %arrayidx141, i32 0, i32 3
  %106 = load volatile %struct.queuegrp**, %struct.queuegrp*** %wg_qgs142, align 8, !tbaa !106
  %cmp143 = icmp eq %struct.queuegrp** %106, null
  br i1 %cmp143, label %if.then.145, label %if.end.153

if.then.145:                                      ; preds = %if.end.139
  %107 = load i32, i32* %j, align 4, !tbaa !5
  %idxprom146 = sext i32 %107 to i64
  %arrayidx147 = getelementptr inbounds [51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 %idxprom146
  %wg_numqgrp148 = getelementptr inbounds %struct.workgrp, %struct.workgrp* %arrayidx147, i32 0, i32 0
  %108 = load volatile i32, i32* %wg_numqgrp148, align 4, !tbaa !107
  %add149 = add nsw i32 %108, 1
  %conv150 = sext i32 %add149 to i64
  %mul151 = mul i64 8, %conv150
  %conv152 = trunc i64 %mul151 to i32
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([55 x i8], [55 x i8]* @.str.178, i32 0, i32 0), i32 %conv152)
  br label %if.end.153

if.end.153:                                       ; preds = %if.then.145, %if.end.139
  %109 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom154 = sext i32 %109 to i64
  %arrayidx155 = getelementptr inbounds [51 x %struct.sortqgrp], [51 x %struct.sortqgrp]* %si, i32 0, i64 %idxprom154
  %sg_idx156 = getelementptr inbounds %struct.sortqgrp, %struct.sortqgrp* %arrayidx155, i32 0, i32 0
  %110 = load i32, i32* %sg_idx156, align 4, !tbaa !163
  store i32 %110, i32* %h, align 4, !tbaa !5
  %111 = load i32, i32* %h, align 4, !tbaa !5
  %idxprom157 = sext i32 %111 to i64
  %arrayidx158 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom157
  %112 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx158, align 8, !tbaa !1
  %113 = load i32, i32* %j, align 4, !tbaa !5
  %idxprom159 = sext i32 %113 to i64
  %arrayidx160 = getelementptr inbounds [51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 %idxprom159
  %wg_numqgrp161 = getelementptr inbounds %struct.workgrp, %struct.workgrp* %arrayidx160, i32 0, i32 0
  %114 = load volatile i32, i32* %wg_numqgrp161, align 4, !tbaa !107
  %idxprom162 = sext i32 %114 to i64
  %115 = load i32, i32* %j, align 4, !tbaa !5
  %idxprom163 = sext i32 %115 to i64
  %arrayidx164 = getelementptr inbounds [51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 %idxprom163
  %wg_qgs165 = getelementptr inbounds %struct.workgrp, %struct.workgrp* %arrayidx164, i32 0, i32 3
  %116 = load volatile %struct.queuegrp**, %struct.queuegrp*** %wg_qgs165, align 8, !tbaa !106
  %arrayidx166 = getelementptr inbounds %struct.queuegrp*, %struct.queuegrp** %116, i64 %idxprom162
  store %struct.queuegrp* %112, %struct.queuegrp** %arrayidx166, align 8, !tbaa !1
  %117 = load i32, i32* %j, align 4, !tbaa !5
  %idxprom167 = sext i32 %117 to i64
  %arrayidx168 = getelementptr inbounds [51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 %idxprom167
  %wg_numqgrp169 = getelementptr inbounds %struct.workgrp, %struct.workgrp* %arrayidx168, i32 0, i32 0
  %118 = load volatile i32, i32* %wg_numqgrp169, align 4, !tbaa !107
  %inc170 = add nsw i32 %118, 1
  store volatile i32 %inc170, i32* %wg_numqgrp169, align 4, !tbaa !107
  %119 = load i32, i32* %h, align 4, !tbaa !5
  %idxprom171 = sext i32 %119 to i64
  %arrayidx172 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom171
  %120 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx172, align 8, !tbaa !1
  %qg_maxqrun173 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %120, i32 0, i32 3
  %121 = load i32, i32* %qg_maxqrun173, align 4, !tbaa !117
  %122 = load i32, i32* %j, align 4, !tbaa !5
  %idxprom174 = sext i32 %122 to i64
  %arrayidx175 = getelementptr inbounds [51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 %idxprom174
  %wg_runners = getelementptr inbounds %struct.workgrp, %struct.workgrp* %arrayidx175, i32 0, i32 1
  %123 = load volatile i32, i32* %wg_runners, align 4, !tbaa !159
  %add176 = add nsw i32 %123, %121
  store volatile i32 %add176, i32* %wg_runners, align 4, !tbaa !159
  %124 = load i32, i32* %j, align 4, !tbaa !5
  %125 = load i32, i32* %h, align 4, !tbaa !5
  %idxprom177 = sext i32 %125 to i64
  %arrayidx178 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom177
  %126 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx178, align 8, !tbaa !1
  %qg_wgrp179 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %126, i32 0, i32 9
  store i32 %124, i32* %qg_wgrp179, align 4, !tbaa !160
  %127 = load i32, i32* %j, align 4, !tbaa !5
  %idxprom180 = sext i32 %127 to i64
  %arrayidx181 = getelementptr inbounds [51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 %idxprom180
  %wg_maxact = getelementptr inbounds %struct.workgrp, %struct.workgrp* %arrayidx181, i32 0, i32 4
  %128 = load volatile i32, i32* %wg_maxact, align 4, !tbaa !108
  %cmp182 = icmp eq i32 %128, 0
  br i1 %cmp182, label %if.then.184, label %if.end.204

if.then.184:                                      ; preds = %if.end.153
  %129 = load i32, i32* @MaxQueueChildren, align 4, !tbaa !5
  %cmp185 = icmp sgt i32 %129, 0
  br i1 %cmp185, label %land.lhs.true.187, label %if.end.197

land.lhs.true.187:                                ; preds = %if.then.184
  %130 = load i32, i32* %h, align 4, !tbaa !5
  %idxprom188 = sext i32 %130 to i64
  %arrayidx189 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom188
  %131 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx189, align 8, !tbaa !1
  %qg_maxqrun190 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %131, i32 0, i32 3
  %132 = load i32, i32* %qg_maxqrun190, align 4, !tbaa !117
  %133 = load i32, i32* @MaxQueueChildren, align 4, !tbaa !5
  %cmp191 = icmp sgt i32 %132, %133
  br i1 %cmp191, label %if.then.193, label %if.end.197

if.then.193:                                      ; preds = %land.lhs.true.187
  %134 = load i32, i32* @MaxQueueChildren, align 4, !tbaa !5
  %135 = load i32, i32* %h, align 4, !tbaa !5
  %idxprom194 = sext i32 %135 to i64
  %arrayidx195 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom194
  %136 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx195, align 8, !tbaa !1
  %qg_maxqrun196 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %136, i32 0, i32 3
  store i32 %134, i32* %qg_maxqrun196, align 4, !tbaa !117
  br label %if.end.197

if.end.197:                                       ; preds = %if.then.193, %land.lhs.true.187, %if.then.184
  %137 = load i32, i32* %h, align 4, !tbaa !5
  %idxprom198 = sext i32 %137 to i64
  %arrayidx199 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom198
  %138 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx199, align 8, !tbaa !1
  %qg_maxqrun200 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %138, i32 0, i32 3
  %139 = load i32, i32* %qg_maxqrun200, align 4, !tbaa !117
  %140 = load i32, i32* %j, align 4, !tbaa !5
  %idxprom201 = sext i32 %140 to i64
  %arrayidx202 = getelementptr inbounds [51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 %idxprom201
  %wg_maxact203 = getelementptr inbounds %struct.workgrp, %struct.workgrp* %arrayidx202, i32 0, i32 4
  store volatile i32 %139, i32* %wg_maxact203, align 4, !tbaa !108
  br label %if.end.204

if.end.204:                                       ; preds = %if.end.197, %if.end.153
  %141 = load i32, i32* %h, align 4, !tbaa !5
  %idxprom205 = sext i32 %141 to i64
  %arrayidx206 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom205
  %142 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx206, align 8, !tbaa !1
  %qg_queueintvl207 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %142, i32 0, i32 5
  %143 = load i64, i64* %qg_queueintvl207, align 8, !tbaa !121
  %cmp208 = icmp sgt i64 %143, 0
  br i1 %cmp208, label %land.lhs.true.210, label %if.end.225

land.lhs.true.210:                                ; preds = %if.end.204
  %144 = load i32, i32* %j, align 4, !tbaa !5
  %idxprom211 = sext i32 %144 to i64
  %arrayidx212 = getelementptr inbounds [51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 %idxprom211
  %wg_lowqintvl = getelementptr inbounds %struct.workgrp, %struct.workgrp* %arrayidx212, i32 0, i32 5
  %145 = load volatile i64, i64* %wg_lowqintvl, align 8, !tbaa !109
  %146 = load i32, i32* %h, align 4, !tbaa !5
  %idxprom213 = sext i32 %146 to i64
  %arrayidx214 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom213
  %147 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx214, align 8, !tbaa !1
  %qg_queueintvl215 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %147, i32 0, i32 5
  %148 = load i64, i64* %qg_queueintvl215, align 8, !tbaa !121
  %cmp216 = icmp slt i64 %145, %148
  br i1 %cmp216, label %if.then.218, label %if.end.225

if.then.218:                                      ; preds = %land.lhs.true.210
  %149 = load i32, i32* %h, align 4, !tbaa !5
  %idxprom219 = sext i32 %149 to i64
  %arrayidx220 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom219
  %150 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx220, align 8, !tbaa !1
  %qg_queueintvl221 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %150, i32 0, i32 5
  %151 = load i64, i64* %qg_queueintvl221, align 8, !tbaa !121
  %152 = load i32, i32* %j, align 4, !tbaa !5
  %idxprom222 = sext i32 %152 to i64
  %arrayidx223 = getelementptr inbounds [51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 %idxprom222
  %wg_lowqintvl224 = getelementptr inbounds %struct.workgrp, %struct.workgrp* %arrayidx223, i32 0, i32 5
  store volatile i64 %151, i64* %wg_lowqintvl224, align 8, !tbaa !109
  br label %if.end.225

if.end.225:                                       ; preds = %if.then.218, %land.lhs.true.210, %if.end.204
  %153 = load i32, i32* %dir, align 4, !tbaa !5
  %154 = load i32, i32* %j, align 4, !tbaa !5
  %add226 = add nsw i32 %154, %153
  store i32 %add226, i32* %j, align 4, !tbaa !5
  br label %for.inc.227

for.inc.227:                                      ; preds = %if.end.225
  %155 = load i32, i32* %i, align 4, !tbaa !5
  %inc228 = add nsw i32 %155, 1
  store i32 %inc228, i32* %i, align 4, !tbaa !5
  br label %for.cond.98

for.end.229:                                      ; preds = %for.cond.98
  %156 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 41), align 1, !tbaa !17
  %conv230 = zext i8 %156 to i32
  %cmp231 = icmp sge i32 %conv230, 9
  br i1 %cmp231, label %land.lhs.true.233, label %if.end.258

land.lhs.true.233:                                ; preds = %for.end.229
  %157 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool = icmp ne i32 %157, 0
  br i1 %tobool, label %if.end.258, label %if.then.234

if.then.234:                                      ; preds = %land.lhs.true.233
  store i32 0, i32* %i, align 4, !tbaa !5
  br label %for.cond.235

for.cond.235:                                     ; preds = %for.inc.255, %if.then.234
  %158 = load i32, i32* %i, align 4, !tbaa !5
  %159 = load i32, i32* @NumWorkGroups, align 4, !tbaa !5
  %cmp236 = icmp slt i32 %158, %159
  br i1 %cmp236, label %for.body.238, label %for.end.257

for.body.238:                                     ; preds = %for.cond.235
  %160 = load i32, i32* %i, align 4, !tbaa !5
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.179, i32 0, i32 0), i32 %160)
  store i32 0, i32* %j, align 4, !tbaa !5
  br label %for.cond.239

for.cond.239:                                     ; preds = %for.inc.252, %for.body.238
  %161 = load i32, i32* %j, align 4, !tbaa !5
  %162 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom240 = sext i32 %162 to i64
  %arrayidx241 = getelementptr inbounds [51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 %idxprom240
  %wg_numqgrp242 = getelementptr inbounds %struct.workgrp, %struct.workgrp* %arrayidx241, i32 0, i32 0
  %163 = load volatile i32, i32* %wg_numqgrp242, align 4, !tbaa !107
  %cmp243 = icmp slt i32 %161, %163
  br i1 %cmp243, label %for.body.245, label %for.end.254

for.body.245:                                     ; preds = %for.cond.239
  %164 = load i32, i32* %j, align 4, !tbaa !5
  %idxprom246 = sext i32 %164 to i64
  %165 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom247 = sext i32 %165 to i64
  %arrayidx248 = getelementptr inbounds [51 x %struct.workgrp], [51 x %struct.workgrp]* @WorkGrp, i32 0, i64 %idxprom247
  %wg_qgs249 = getelementptr inbounds %struct.workgrp, %struct.workgrp* %arrayidx248, i32 0, i32 3
  %166 = load volatile %struct.queuegrp**, %struct.queuegrp*** %wg_qgs249, align 8, !tbaa !106
  %arrayidx250 = getelementptr inbounds %struct.queuegrp*, %struct.queuegrp** %166, i64 %idxprom246
  %167 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx250, align 8, !tbaa !1
  %qg_name251 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %167, i32 0, i32 0
  %168 = load i8*, i8** %qg_name251, align 8, !tbaa !157
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.180, i32 0, i32 0), i8* %168)
  br label %for.inc.252

for.inc.252:                                      ; preds = %for.body.245
  %169 = load i32, i32* %j, align 4, !tbaa !5
  %inc253 = add nsw i32 %169, 1
  store i32 %inc253, i32* %j, align 4, !tbaa !5
  br label %for.cond.239

for.end.254:                                      ; preds = %for.cond.239
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.45, i32 0, i32 0))
  br label %for.inc.255

for.inc.255:                                      ; preds = %for.end.254
  %170 = load i32, i32* %i, align 4, !tbaa !5
  %inc256 = add nsw i32 %170, 1
  store i32 %inc256, i32* %i, align 4, !tbaa !5
  br label %for.cond.235

for.end.257:                                      ; preds = %for.cond.235
  br label %if.end.258

if.end.258:                                       ; preds = %for.end.257, %land.lhs.true.233, %for.end.229
  store i32 0, i32* %cleanup.dest.slot
  br label %cleanup

cleanup:                                          ; preds = %if.end.258, %if.end.59
  %171 = bitcast [51 x %struct.sortqgrp]* %si to i8*
  call void @llvm.lifetime.end(i64 408, i8* %171) #1
  %172 = bitcast i32* %h to i8*
  call void @llvm.lifetime.end(i64 4, i8* %172) #1
  %173 = bitcast i32* %dir to i8*
  call void @llvm.lifetime.end(i64 4, i8* %173) #1
  %174 = bitcast i32* %total_runners to i8*
  call void @llvm.lifetime.end(i64 4, i8* %174) #1
  %175 = bitcast i32* %j to i8*
  call void @llvm.lifetime.end(i64 4, i8* %175) #1
  %176 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end(i64 4, i8* %176) #1
  %cleanup.dest = load i32, i32* %cleanup.dest.slot
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %cleanup.cont
    i32 1, label %cleanup.cont
  ]

cleanup.cont:                                     ; preds = %cleanup, %cleanup
  ret void

unreachable:                                      ; preds = %cleanup
  unreachable
}

declare void @qsort(i8*, i64, i64, i32 (i8*, i8*)*) #2

; Function Attrs: nounwind uwtable
define internal i32 @cmpidx(i8* %a, i8* %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i8*, align 8
  %b.addr = alloca i8*, align 8
  store i8* %a, i8** %a.addr, align 8, !tbaa !1
  store i8* %b, i8** %b.addr, align 8, !tbaa !1
  %0 = load i8*, i8** %a.addr, align 8, !tbaa !1
  %1 = bitcast i8* %0 to %struct.sortqgrp*
  %sg_maxqrun = getelementptr inbounds %struct.sortqgrp, %struct.sortqgrp* %1, i32 0, i32 1
  %2 = load i32, i32* %sg_maxqrun, align 4, !tbaa !161
  %3 = load i8*, i8** %b.addr, align 8, !tbaa !1
  %4 = bitcast i8* %3 to %struct.sortqgrp*
  %sg_maxqrun1 = getelementptr inbounds %struct.sortqgrp, %struct.sortqgrp* %4, i32 0, i32 1
  %5 = load i32, i32* %sg_maxqrun1, align 4, !tbaa !161
  %cmp = icmp slt i32 %2, %5
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval
  br label %return

if.else:                                          ; preds = %entry
  %6 = load i8*, i8** %a.addr, align 8, !tbaa !1
  %7 = bitcast i8* %6 to %struct.sortqgrp*
  %sg_maxqrun2 = getelementptr inbounds %struct.sortqgrp, %struct.sortqgrp* %7, i32 0, i32 1
  %8 = load i32, i32* %sg_maxqrun2, align 4, !tbaa !161
  %9 = load i8*, i8** %b.addr, align 8, !tbaa !1
  %10 = bitcast i8* %9 to %struct.sortqgrp*
  %sg_maxqrun3 = getelementptr inbounds %struct.sortqgrp, %struct.sortqgrp* %10, i32 0, i32 1
  %11 = load i32, i32* %sg_maxqrun3, align 4, !tbaa !161
  %cmp4 = icmp sgt i32 %8, %11
  br i1 %cmp4, label %if.then.5, label %if.else.6

if.then.5:                                        ; preds = %if.else
  store i32 -1, i32* %retval
  br label %return

if.else.6:                                        ; preds = %if.else
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.else.6, %if.then.5, %if.then
  %12 = load i32, i32* %retval
  ret i32 %12
}

declare i8* @sm_malloc_tagged(i64, i8*, i32, i32) #2

declare i8* @sm_realloc(i8*, i64) #2

; Function Attrs: nounwind uwtable
define i32 @split_by_recipient(%struct.envelope* %e) #0 {
entry:
  %retval = alloca i32, align 4
  %e.addr = alloca %struct.envelope*, align 8
  %split = alloca i32, align 4
  %n = alloca i32, align 4
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %l = alloca i32, align 4
  %lsplits = alloca i8*, align 8
  %ee = alloca %struct.envelope*, align 8
  %next = alloca %struct.envelope*, align 8
  %firstsibling = alloca %struct.envelope*, align 8
  %cleanup.dest.slot = alloca i32
  %p = alloca i8*, align 8
  store %struct.envelope* %e, %struct.envelope** %e.addr, align 8, !tbaa !1
  %0 = bitcast i32* %split to i8*
  call void @llvm.lifetime.start(i64 4, i8* %0) #1
  %1 = bitcast i32* %n to i8*
  call void @llvm.lifetime.start(i64 4, i8* %1) #1
  %2 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start(i64 4, i8* %2) #1
  %3 = bitcast i32* %j to i8*
  call void @llvm.lifetime.start(i64 4, i8* %3) #1
  %4 = bitcast i32* %l to i8*
  call void @llvm.lifetime.start(i64 4, i8* %4) #1
  %5 = bitcast i8** %lsplits to i8*
  call void @llvm.lifetime.start(i64 8, i8* %5) #1
  %6 = bitcast %struct.envelope** %ee to i8*
  call void @llvm.lifetime.start(i64 8, i8* %6) #1
  %7 = bitcast %struct.envelope** %next to i8*
  call void @llvm.lifetime.start(i64 8, i8* %7) #1
  %8 = bitcast %struct.envelope** %firstsibling to i8*
  call void @llvm.lifetime.start(i64 8, i8* %8) #1
  %9 = load i8, i8* @OpMode, align 1, !tbaa !17
  %conv = sext i8 %9 to i32
  %cmp = icmp eq i32 %conv, 118
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %10 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qgrp = getelementptr inbounds %struct.envelope, %struct.envelope* %10, i32 0, i32 26
  %11 = load i32, i32* %e_qgrp, align 4, !tbaa !18
  %cmp2 = icmp sge i32 %11, 0
  br i1 %cmp2, label %lor.lhs.false.4, label %if.then

lor.lhs.false.4:                                  ; preds = %lor.lhs.false
  %12 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_flags = getelementptr inbounds %struct.envelope, %struct.envelope* %12, i32 0, i32 11
  %13 = load i64, i64* %e_flags, align 8, !tbaa !15
  %and = and i64 %13, 67108864
  %cmp5 = icmp ne i64 %and, 0
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false.4, %lor.lhs.false, %entry
  store i32 1, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end:                                           ; preds = %lor.lhs.false.4
  %14 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %call = call i32 @split_across_queue_groups(%struct.envelope* %14)
  store i32 %call, i32* %n, align 4, !tbaa !5
  %15 = load i32, i32* %n, align 4, !tbaa !5
  %cmp7 = icmp eq i32 %15, 0
  br i1 %cmp7, label %if.then.9, label %if.end.10

if.then.9:                                        ; preds = %if.end
  store i32 0, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.10:                                        ; preds = %if.end
  %16 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_sibling = getelementptr inbounds %struct.envelope, %struct.envelope* %16, i32 0, i32 22
  %17 = load %struct.envelope*, %struct.envelope** %e_sibling, align 8, !tbaa !148
  store %struct.envelope* %17, %struct.envelope** %ee, align 8, !tbaa !1
  store %struct.envelope* %17, %struct.envelope** %firstsibling, align 8, !tbaa !1
  %18 = load i32, i32* %n, align 4, !tbaa !5
  %cmp11 = icmp sgt i32 %18, 1
  br i1 %cmp11, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.end.10
  %19 = load i32, i32* @LogLevel, align 4, !tbaa !5
  %cmp13 = icmp sgt i32 %19, 8
  br i1 %cmp13, label %if.then.15, label %if.else

if.then.15:                                       ; preds = %land.lhs.true
  store i32 2048, i32* %l, align 4, !tbaa !5
  %20 = load i32, i32* %l, align 4, !tbaa !5
  %conv16 = sext i32 %20 to i64
  %21 = load i32, i32* @SmHeapGroup, align 4, !tbaa !5
  %call17 = call i8* @sm_malloc_tagged(i64 %conv16, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 8419, i32 %21)
  store i8* %call17, i8** %lsplits, align 8, !tbaa !1
  %22 = load i8*, i8** %lsplits, align 8, !tbaa !1
  %cmp18 = icmp ne i8* %22, null
  br i1 %cmp18, label %if.then.20, label %if.end.21

if.then.20:                                       ; preds = %if.then.15
  %23 = load i8*, i8** %lsplits, align 8, !tbaa !1
  store i8 0, i8* %23, align 1, !tbaa !17
  br label %if.end.21

if.end.21:                                        ; preds = %if.then.20, %if.then.15
  store i32 0, i32* %j, align 4, !tbaa !5
  br label %if.end.22

if.else:                                          ; preds = %land.lhs.true, %if.end.10
  store i8* null, i8** %lsplits, align 8, !tbaa !1
  store i32 0, i32* %l, align 4, !tbaa !5
  store i32 0, i32* %j, align 4, !tbaa !5
  br label %if.end.22

if.end.22:                                        ; preds = %if.else, %if.end.21
  store i32 1, i32* %i, align 4, !tbaa !5
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end.22
  %24 = load i32, i32* %i, align 4, !tbaa !5
  %25 = load i32, i32* %n, align 4, !tbaa !5
  %cmp23 = icmp slt i32 %24, %25
  br i1 %cmp23, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %26 = load %struct.envelope*, %struct.envelope** %ee, align 8, !tbaa !1
  %e_sibling25 = getelementptr inbounds %struct.envelope, %struct.envelope* %26, i32 0, i32 22
  %27 = load %struct.envelope*, %struct.envelope** %e_sibling25, align 8, !tbaa !148
  store %struct.envelope* %27, %struct.envelope** %next, align 8, !tbaa !1
  %28 = load %struct.envelope*, %struct.envelope** %ee, align 8, !tbaa !1
  %call26 = call i32 @split_within_queue(%struct.envelope* %28)
  %cmp27 = icmp eq i32 %call26, 0
  br i1 %cmp27, label %if.then.29, label %if.end.31

if.then.29:                                       ; preds = %for.body
  %29 = load %struct.envelope*, %struct.envelope** %firstsibling, align 8, !tbaa !1
  %30 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_sibling30 = getelementptr inbounds %struct.envelope, %struct.envelope* %30, i32 0, i32 22
  store %struct.envelope* %29, %struct.envelope** %e_sibling30, align 8, !tbaa !148
  store i32 0, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.31:                                        ; preds = %for.body
  %31 = load %struct.envelope*, %struct.envelope** %ee, align 8, !tbaa !1
  %e_flags32 = getelementptr inbounds %struct.envelope, %struct.envelope* %31, i32 0, i32 11
  %32 = load i64, i64* %e_flags32, align 8, !tbaa !15
  %or = or i64 %32, 67108864
  store i64 %or, i64* %e_flags32, align 8, !tbaa !15
  %33 = load i32, i32* @LogLevel, align 4, !tbaa !5
  %cmp33 = icmp sgt i32 %33, 8
  br i1 %cmp33, label %land.lhs.true.35, label %if.end.81

land.lhs.true.35:                                 ; preds = %if.end.31
  %34 = load i8*, i8** %lsplits, align 8, !tbaa !1
  %cmp36 = icmp ne i8* %34, null
  br i1 %cmp36, label %if.then.38, label %if.end.81

if.then.38:                                       ; preds = %land.lhs.true.35
  %35 = load i32, i32* %j, align 4, !tbaa !5
  %conv39 = sext i32 %35 to i64
  %36 = load i32, i32* %l, align 4, !tbaa !5
  %conv40 = sext i32 %36 to i64
  %37 = load %struct.envelope*, %struct.envelope** %ee, align 8, !tbaa !1
  %e_id = getelementptr inbounds %struct.envelope, %struct.envelope* %37, i32 0, i32 25
  %38 = load i8*, i8** %e_id, align 8, !tbaa !7
  %call41 = call i64 @strlen(i8* %38) #14
  %sub = sub i64 %conv40, %call41
  %sub42 = sub i64 %sub, 3
  %cmp43 = icmp uge i64 %conv39, %sub42
  br i1 %cmp43, label %if.then.45, label %if.end.53

if.then.45:                                       ; preds = %if.then.38
  %39 = bitcast i8** %p to i8*
  call void @llvm.lifetime.start(i64 8, i8* %39) #1
  %40 = load i32, i32* %l, align 4, !tbaa !5
  %add = add nsw i32 %40, 2048
  store i32 %add, i32* %l, align 4, !tbaa !5
  %41 = load i8*, i8** %lsplits, align 8, !tbaa !1
  %42 = load i32, i32* %l, align 4, !tbaa !5
  %conv46 = sext i32 %42 to i64
  %call47 = call i8* @sm_realloc(i8* %41, i64 %conv46)
  store i8* %call47, i8** %p, align 8, !tbaa !1
  %43 = load i8*, i8** %p, align 8, !tbaa !1
  %cmp48 = icmp eq i8* %43, null
  br i1 %cmp48, label %if.then.50, label %if.else.51

if.then.50:                                       ; preds = %if.then.45
  %44 = load i8*, i8** %lsplits, align 8, !tbaa !1
  call void @sm_free_tagged(i8* %44, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 8450)
  store i8* null, i8** %lsplits, align 8, !tbaa !1
  br label %if.end.52

if.else.51:                                       ; preds = %if.then.45
  %45 = load i8*, i8** %p, align 8, !tbaa !1
  store i8* %45, i8** %lsplits, align 8, !tbaa !1
  br label %if.end.52

if.end.52:                                        ; preds = %if.else.51, %if.then.50
  %46 = bitcast i8** %p to i8*
  call void @llvm.lifetime.end(i64 8, i8* %46) #1
  br label %if.end.53

if.end.53:                                        ; preds = %if.end.52, %if.then.38
  %47 = load i8*, i8** %lsplits, align 8, !tbaa !1
  %cmp54 = icmp ne i8* %47, null
  br i1 %cmp54, label %if.then.56, label %if.end.80

if.then.56:                                       ; preds = %if.end.53
  %48 = load i32, i32* %j, align 4, !tbaa !5
  %cmp57 = icmp eq i32 %48, 0
  br i1 %cmp57, label %if.then.59, label %if.else.67

if.then.59:                                       ; preds = %if.then.56
  %49 = load i8*, i8** %lsplits, align 8, !tbaa !1
  %50 = load i32, i32* %j, align 4, !tbaa !5
  %idx.ext = sext i32 %50 to i64
  %add.ptr = getelementptr inbounds i8, i8* %49, i64 %idx.ext
  %51 = load %struct.envelope*, %struct.envelope** %ee, align 8, !tbaa !1
  %e_id60 = getelementptr inbounds %struct.envelope, %struct.envelope* %51, i32 0, i32 25
  %52 = load i8*, i8** %e_id60, align 8, !tbaa !7
  %53 = load i32, i32* %l, align 4, !tbaa !5
  %54 = load i32, i32* %j, align 4, !tbaa !5
  %sub61 = sub nsw i32 %53, %54
  %conv62 = sext i32 %sub61 to i64
  %call63 = call i64 @sm_strlcat(i8* %add.ptr, i8* %52, i64 %conv62)
  %55 = load i32, i32* %j, align 4, !tbaa !5
  %conv64 = sext i32 %55 to i64
  %add65 = add i64 %conv64, %call63
  %conv66 = trunc i64 %add65 to i32
  store i32 %conv66, i32* %j, align 4, !tbaa !5
  br label %if.end.77

if.else.67:                                       ; preds = %if.then.56
  %56 = load i8*, i8** %lsplits, align 8, !tbaa !1
  %57 = load i32, i32* %j, align 4, !tbaa !5
  %idx.ext68 = sext i32 %57 to i64
  %add.ptr69 = getelementptr inbounds i8, i8* %56, i64 %idx.ext68
  %58 = load %struct.envelope*, %struct.envelope** %ee, align 8, !tbaa !1
  %e_id70 = getelementptr inbounds %struct.envelope, %struct.envelope* %58, i32 0, i32 25
  %59 = load i8*, i8** %e_id70, align 8, !tbaa !7
  %60 = load i32, i32* %l, align 4, !tbaa !5
  %61 = load i32, i32* %j, align 4, !tbaa !5
  %sub71 = sub nsw i32 %60, %61
  %conv72 = sext i32 %sub71 to i64
  %call73 = call i64 @sm_strlcat2(i8* %add.ptr69, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.181, i32 0, i32 0), i8* %59, i64 %conv72)
  %62 = load i32, i32* %j, align 4, !tbaa !5
  %conv74 = sext i32 %62 to i64
  %add75 = add i64 %conv74, %call73
  %conv76 = trunc i64 %add75 to i32
  store i32 %conv76, i32* %j, align 4, !tbaa !5
  br label %if.end.77

if.end.77:                                        ; preds = %if.else.67, %if.then.59
  %63 = load i32, i32* %j, align 4, !tbaa !5
  %64 = load i32, i32* %l, align 4, !tbaa !5
  %cmp78 = icmp slt i32 %63, %64
  br i1 %cmp78, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.end.77
  call void @sm_abort_at(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 8464, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.182, i32 0, i32 0)) #12
  unreachable
                                                  ; No predecessors!
  br label %lor.end

lor.end:                                          ; preds = %65, %if.end.77
  %66 = phi i1 [ true, %if.end.77 ], [ false, %65 ]
  %lor.ext = zext i1 %66 to i32
  br label %if.end.80

if.end.80:                                        ; preds = %lor.end, %if.end.53
  br label %if.end.81

if.end.81:                                        ; preds = %if.end.80, %land.lhs.true.35, %if.end.31
  %67 = load %struct.envelope*, %struct.envelope** %next, align 8, !tbaa !1
  store %struct.envelope* %67, %struct.envelope** %ee, align 8, !tbaa !1
  br label %for.inc

for.inc:                                          ; preds = %if.end.81
  %68 = load i32, i32* %i, align 4, !tbaa !5
  %inc = add nsw i32 %68, 1
  store i32 %inc, i32* %i, align 4, !tbaa !5
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %69 = load i32, i32* @LogLevel, align 4, !tbaa !5
  %cmp82 = icmp sgt i32 %69, 8
  br i1 %cmp82, label %land.lhs.true.84, label %if.end.95

land.lhs.true.84:                                 ; preds = %for.end
  %70 = load i8*, i8** %lsplits, align 8, !tbaa !1
  %cmp85 = icmp ne i8* %70, null
  br i1 %cmp85, label %land.lhs.true.87, label %if.end.95

land.lhs.true.87:                                 ; preds = %land.lhs.true.84
  %71 = load i32, i32* %n, align 4, !tbaa !5
  %cmp88 = icmp sgt i32 %71, 1
  br i1 %cmp88, label %if.then.90, label %if.end.95

if.then.90:                                       ; preds = %land.lhs.true.87
  %72 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id91 = getelementptr inbounds %struct.envelope, %struct.envelope* %72, i32 0, i32 25
  %73 = load i8*, i8** %e_id91, align 8, !tbaa !7
  %74 = load i32, i32* %n, align 4, !tbaa !5
  %sub92 = sub nsw i32 %74, 1
  %75 = load i32, i32* %n, align 4, !tbaa !5
  %cmp93 = icmp sgt i32 %75, 2
  %cond = select i1 %cmp93, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.106, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0)
  %76 = load i8*, i8** %lsplits, align 8, !tbaa !1
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 5, i8* %73, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.183, i32 0, i32 0), i32 %sub92, i8* %cond, i8* %76)
  %77 = load i8*, i8** %lsplits, align 8, !tbaa !1
  call void @sm_free_tagged(i8* %77, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 8473)
  br label %if.end.95

if.end.95:                                        ; preds = %if.then.90, %land.lhs.true.87, %land.lhs.true.84, %for.end
  %78 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %call96 = call i32 @split_within_queue(%struct.envelope* %78)
  %cmp97 = icmp ne i32 %call96, 0
  %conv98 = zext i1 %cmp97 to i32
  store i32 %conv98, i32* %split, align 4, !tbaa !5
  %79 = load i32, i32* %split, align 4, !tbaa !5
  %tobool = icmp ne i32 %79, 0
  br i1 %tobool, label %if.then.99, label %if.end.102

if.then.99:                                       ; preds = %if.end.95
  %80 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_flags100 = getelementptr inbounds %struct.envelope, %struct.envelope* %80, i32 0, i32 11
  %81 = load i64, i64* %e_flags100, align 8, !tbaa !15
  %or101 = or i64 %81, 67108864
  store i64 %or101, i64* %e_flags100, align 8, !tbaa !15
  br label %if.end.102

if.end.102:                                       ; preds = %if.then.99, %if.end.95
  %82 = load i32, i32* %split, align 4, !tbaa !5
  store i32 %82, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

cleanup:                                          ; preds = %if.end.102, %if.then.29, %if.then.9, %if.then
  %83 = bitcast %struct.envelope** %firstsibling to i8*
  call void @llvm.lifetime.end(i64 8, i8* %83) #1
  %84 = bitcast %struct.envelope** %next to i8*
  call void @llvm.lifetime.end(i64 8, i8* %84) #1
  %85 = bitcast %struct.envelope** %ee to i8*
  call void @llvm.lifetime.end(i64 8, i8* %85) #1
  %86 = bitcast i8** %lsplits to i8*
  call void @llvm.lifetime.end(i64 8, i8* %86) #1
  %87 = bitcast i32* %l to i8*
  call void @llvm.lifetime.end(i64 4, i8* %87) #1
  %88 = bitcast i32* %j to i8*
  call void @llvm.lifetime.end(i64 4, i8* %88) #1
  %89 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end(i64 4, i8* %89) #1
  %90 = bitcast i32* %n to i8*
  call void @llvm.lifetime.end(i64 4, i8* %90) #1
  %91 = bitcast i32* %split to i8*
  call void @llvm.lifetime.end(i64 4, i8* %91) #1
  %92 = load i32, i32* %retval
  ret i32 %92
}

; Function Attrs: nounwind uwtable
define internal i32 @split_across_queue_groups(%struct.envelope* %e) #0 {
entry:
  %retval = alloca i32, align 4
  %e.addr = alloca %struct.envelope*, align 8
  %naddrs = alloca i32, align 4
  %nsplits = alloca i32, align 4
  %i = alloca i32, align 4
  %changed = alloca i32, align 4
  %pvp = alloca i8**, align 8
  %q = alloca %struct.address*, align 8
  %addrs = alloca %struct.address**, align 8
  %ee = alloca %struct.envelope*, align 8
  %es = alloca %struct.envelope*, align 8
  %splits = alloca [50 x %struct.envelope*], align 16
  %pvpbuf = alloca [1256 x i8], align 16
  %cleanup.dest.slot = alloca i32
  %j = alloca i32, align 4
  store %struct.envelope* %e, %struct.envelope** %e.addr, align 8, !tbaa !1
  %0 = bitcast i32* %naddrs to i8*
  call void @llvm.lifetime.start(i64 4, i8* %0) #1
  %1 = bitcast i32* %nsplits to i8*
  call void @llvm.lifetime.start(i64 4, i8* %1) #1
  %2 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start(i64 4, i8* %2) #1
  %3 = bitcast i32* %changed to i8*
  call void @llvm.lifetime.start(i64 4, i8* %3) #1
  %4 = bitcast i8*** %pvp to i8*
  call void @llvm.lifetime.start(i64 8, i8* %4) #1
  %5 = bitcast %struct.address** %q to i8*
  call void @llvm.lifetime.start(i64 8, i8* %5) #1
  %6 = bitcast %struct.address*** %addrs to i8*
  call void @llvm.lifetime.start(i64 8, i8* %6) #1
  %7 = bitcast %struct.envelope** %ee to i8*
  call void @llvm.lifetime.start(i64 8, i8* %7) #1
  %8 = bitcast %struct.envelope** %es to i8*
  call void @llvm.lifetime.start(i64 8, i8* %8) #1
  %9 = bitcast [50 x %struct.envelope*]* %splits to i8*
  call void @llvm.lifetime.start(i64 400, i8* %9) #1
  %10 = bitcast [1256 x i8]* %pvpbuf to i8*
  call void @llvm.lifetime.start(i64 1256, i8* %10) #1
  %11 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qgrp = getelementptr inbounds %struct.envelope, %struct.envelope* %11, i32 0, i32 26
  %12 = load i32, i32* %e_qgrp, align 4, !tbaa !18
  %cmp = icmp sge i32 %12, 0
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  call void @sm_abort_at(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 8040, i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.300, i32 0, i32 0)) #12
  unreachable
                                                  ; No predecessors!
  br label %lor.end

lor.end:                                          ; preds = %13, %entry
  %14 = phi i1 [ true, %entry ], [ false, %13 ]
  %lor.ext = zext i1 %14 to i32
  store i32 0, i32* %naddrs, align 4, !tbaa !5
  store i32 0, i32* %changed, align 4, !tbaa !5
  %15 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_sendqueue = getelementptr inbounds %struct.envelope, %struct.envelope* %15, i32 0, i32 7
  %16 = load %struct.address*, %struct.address** %e_sendqueue, align 8, !tbaa !20
  store %struct.address* %16, %struct.address** %q, align 8, !tbaa !1
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %lor.end
  %17 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %cmp1 = icmp ne %struct.address* %17, null
  br i1 %cmp1, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %18 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_state = getelementptr inbounds %struct.address, %struct.address* %18, i32 0, i32 21
  %19 = load i16, i16* %q_state, align 2, !tbaa !52
  %conv = sext i16 %19 to i32
  %cmp2 = icmp sge i32 %conv, 6
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %for.inc

if.end:                                           ; preds = %for.body
  %20 = load i32, i32* %naddrs, align 4, !tbaa !5
  %inc = add nsw i32 %20, 1
  store i32 %inc, i32* %naddrs, align 4, !tbaa !5
  %21 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_state4 = getelementptr inbounds %struct.address, %struct.address* %21, i32 0, i32 21
  %22 = load i16, i16* %q_state4, align 2, !tbaa !52
  %conv5 = sext i16 %22 to i32
  %cmp6 = icmp eq i32 %conv5, 2
  br i1 %cmp6, label %if.then.12, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %23 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_state8 = getelementptr inbounds %struct.address, %struct.address* %23, i32 0, i32 21
  %24 = load i16, i16* %q_state8, align 2, !tbaa !52
  %conv9 = sext i16 %24 to i32
  %cmp10 = icmp eq i32 %conv9, 1
  br i1 %cmp10, label %if.then.12, label %if.else

if.then.12:                                       ; preds = %lor.lhs.false, %if.end
  %25 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qgrp13 = getelementptr inbounds %struct.envelope, %struct.envelope* %25, i32 0, i32 26
  %26 = load i32, i32* %e_qgrp13, align 4, !tbaa !18
  %27 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_qgrp = getelementptr inbounds %struct.address, %struct.address* %27, i32 0, i32 23
  store i32 %26, i32* %q_qgrp, align 4, !tbaa !146
  br label %if.end.87

if.else:                                          ; preds = %lor.lhs.false
  %28 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_qgrp14 = getelementptr inbounds %struct.address, %struct.address* %28, i32 0, i32 23
  %29 = load i32, i32* %q_qgrp14, align 4, !tbaa !146
  %cmp15 = icmp sge i32 %29, 0
  br i1 %cmp15, label %if.end.86, label %if.then.17

if.then.17:                                       ; preds = %if.else
  %30 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_user = getelementptr inbounds %struct.address, %struct.address* %30, i32 0, i32 1
  %31 = load i8*, i8** %q_user, align 8, !tbaa !98
  %32 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %arraydecay = getelementptr inbounds [1256 x i8], [1256 x i8]* %pvpbuf, i32 0, i32 0
  %call = call i32 @rscap(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.301, i32 0, i32 0), i8* %31, i8* null, %struct.envelope* %32, i8*** %pvp, i8* %arraydecay, i32 1256)
  store i32 %call, i32* %i, align 4, !tbaa !5
  %33 = load i32, i32* %i, align 4, !tbaa !5
  %cmp18 = icmp eq i32 %33, 0
  br i1 %cmp18, label %land.lhs.true, label %if.end.62

land.lhs.true:                                    ; preds = %if.then.17
  %34 = load i8**, i8*** %pvp, align 8, !tbaa !1
  %cmp20 = icmp ne i8** %34, null
  br i1 %cmp20, label %land.lhs.true.22, label %if.end.62

land.lhs.true.22:                                 ; preds = %land.lhs.true
  %35 = load i8**, i8*** %pvp, align 8, !tbaa !1
  %arrayidx = getelementptr inbounds i8*, i8** %35, i64 0
  %36 = load i8*, i8** %arrayidx, align 8, !tbaa !1
  %cmp23 = icmp ne i8* %36, null
  br i1 %cmp23, label %land.lhs.true.25, label %if.end.62

land.lhs.true.25:                                 ; preds = %land.lhs.true.22
  %37 = load i8**, i8*** %pvp, align 8, !tbaa !1
  %arrayidx26 = getelementptr inbounds i8*, i8** %37, i64 0
  %38 = load i8*, i8** %arrayidx26, align 8, !tbaa !1
  %arrayidx27 = getelementptr inbounds i8, i8* %38, i64 0
  %39 = load i8, i8* %arrayidx27, align 1, !tbaa !17
  %conv28 = sext i8 %39 to i32
  %and = and i32 %conv28, 255
  %cmp29 = icmp eq i32 %and, 150
  br i1 %cmp29, label %land.lhs.true.31, label %if.end.62

land.lhs.true.31:                                 ; preds = %land.lhs.true.25
  %40 = load i8**, i8*** %pvp, align 8, !tbaa !1
  %arrayidx32 = getelementptr inbounds i8*, i8** %40, i64 1
  %41 = load i8*, i8** %arrayidx32, align 8, !tbaa !1
  %cmp33 = icmp ne i8* %41, null
  br i1 %cmp33, label %land.lhs.true.35, label %if.end.62

land.lhs.true.35:                                 ; preds = %land.lhs.true.31
  %42 = load i8**, i8*** %pvp, align 8, !tbaa !1
  %arrayidx36 = getelementptr inbounds i8*, i8** %42, i64 1
  %43 = load i8*, i8** %arrayidx36, align 8, !tbaa !1
  %arrayidx37 = getelementptr inbounds i8, i8* %43, i64 0
  %44 = load i8, i8* %arrayidx37, align 1, !tbaa !17
  %conv38 = sext i8 %44 to i32
  %cmp39 = icmp ne i32 %conv38, 0
  br i1 %cmp39, label %if.then.41, label %if.end.62

if.then.41:                                       ; preds = %land.lhs.true.35
  %45 = load i8**, i8*** %pvp, align 8, !tbaa !1
  %arrayidx42 = getelementptr inbounds i8*, i8** %45, i64 1
  %46 = load i8*, i8** %arrayidx42, align 8, !tbaa !1
  %call43 = call i32 @name2qid(i8* %46)
  store i32 %call43, i32* %i, align 4, !tbaa !5
  %47 = load i32, i32* %i, align 4, !tbaa !5
  %cmp44 = icmp sge i32 %47, 0
  br i1 %cmp44, label %if.then.46, label %if.else.55

if.then.46:                                       ; preds = %if.then.41
  %48 = load i32, i32* %i, align 4, !tbaa !5
  %49 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_qgrp47 = getelementptr inbounds %struct.address, %struct.address* %49, i32 0, i32 23
  store i32 %48, i32* %q_qgrp47, align 4, !tbaa !146
  store i32 1, i32* %changed, align 4, !tbaa !5
  %50 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 20), align 1, !tbaa !17
  %conv48 = zext i8 %50 to i32
  %cmp49 = icmp sge i32 %conv48, 4
  br i1 %cmp49, label %land.lhs.true.51, label %if.end.54

land.lhs.true.51:                                 ; preds = %if.then.46
  %51 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool = icmp ne i32 %51, 0
  br i1 %tobool, label %if.end.54, label %if.then.52

if.then.52:                                       ; preds = %land.lhs.true.51
  %52 = load i8**, i8*** %pvp, align 8, !tbaa !1
  %arrayidx53 = getelementptr inbounds i8*, i8** %52, i64 1
  %53 = load i8*, i8** %arrayidx53, align 8, !tbaa !1
  %54 = load i32, i32* %i, align 4, !tbaa !5
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 6, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0), i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.302, i32 0, i32 0), i8* %53, i32 %54)
  br label %if.end.54

if.end.54:                                        ; preds = %if.then.52, %land.lhs.true.51, %if.then.46
  br label %for.inc

if.else.55:                                       ; preds = %if.then.41
  %55 = load i32, i32* @LogLevel, align 4, !tbaa !5
  %cmp56 = icmp sgt i32 %55, 10
  br i1 %cmp56, label %if.then.58, label %if.end.60

if.then.58:                                       ; preds = %if.else.55
  %56 = load i8**, i8*** %pvp, align 8, !tbaa !1
  %arrayidx59 = getelementptr inbounds i8*, i8** %56, i64 1
  %57 = load i8*, i8** %arrayidx59, align 8, !tbaa !1
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 6, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0), i8* getelementptr inbounds ([50 x i8], [50 x i8]* @.str.303, i32 0, i32 0), i8* %57)
  br label %if.end.60

if.end.60:                                        ; preds = %if.then.58, %if.else.55
  br label %if.end.61

if.end.61:                                        ; preds = %if.end.60
  br label %if.end.62

if.end.62:                                        ; preds = %if.end.61, %land.lhs.true.35, %land.lhs.true.31, %land.lhs.true.25, %land.lhs.true.22, %land.lhs.true, %if.then.17
  %58 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_mailer = getelementptr inbounds %struct.address, %struct.address* %58, i32 0, i32 4
  %59 = load %struct.mailer*, %struct.mailer** %q_mailer, align 8, !tbaa !60
  %cmp63 = icmp ne %struct.mailer* %59, null
  br i1 %cmp63, label %land.lhs.true.65, label %if.else.75

land.lhs.true.65:                                 ; preds = %if.end.62
  %60 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_mailer66 = getelementptr inbounds %struct.address, %struct.address* %60, i32 0, i32 4
  %61 = load %struct.mailer*, %struct.mailer** %q_mailer66, align 8, !tbaa !60
  %m_qgrp = getelementptr inbounds %struct.mailer, %struct.mailer* %61, i32 0, i32 24
  %62 = load i16, i16* %m_qgrp, align 2, !tbaa !156
  %conv67 = sext i16 %62 to i32
  %cmp68 = icmp sge i32 %conv67, 0
  br i1 %cmp68, label %if.then.70, label %if.else.75

if.then.70:                                       ; preds = %land.lhs.true.65
  store i32 1, i32* %changed, align 4, !tbaa !5
  %63 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_mailer71 = getelementptr inbounds %struct.address, %struct.address* %63, i32 0, i32 4
  %64 = load %struct.mailer*, %struct.mailer** %q_mailer71, align 8, !tbaa !60
  %m_qgrp72 = getelementptr inbounds %struct.mailer, %struct.mailer* %64, i32 0, i32 24
  %65 = load i16, i16* %m_qgrp72, align 2, !tbaa !156
  %conv73 = sext i16 %65 to i32
  %66 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_qgrp74 = getelementptr inbounds %struct.address, %struct.address* %66, i32 0, i32 23
  store i32 %conv73, i32* %q_qgrp74, align 4, !tbaa !146
  br label %if.end.85

if.else.75:                                       ; preds = %land.lhs.true.65, %if.end.62
  %67 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qgrp76 = getelementptr inbounds %struct.envelope, %struct.envelope* %67, i32 0, i32 26
  %68 = load i32, i32* %e_qgrp76, align 4, !tbaa !18
  %cmp77 = icmp sge i32 %68, 0
  br i1 %cmp77, label %if.then.79, label %if.else.82

if.then.79:                                       ; preds = %if.else.75
  %69 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qgrp80 = getelementptr inbounds %struct.envelope, %struct.envelope* %69, i32 0, i32 26
  %70 = load i32, i32* %e_qgrp80, align 4, !tbaa !18
  %71 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_qgrp81 = getelementptr inbounds %struct.address, %struct.address* %71, i32 0, i32 23
  store i32 %70, i32* %q_qgrp81, align 4, !tbaa !146
  br label %if.end.84

if.else.82:                                       ; preds = %if.else.75
  %72 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_qgrp83 = getelementptr inbounds %struct.address, %struct.address* %72, i32 0, i32 23
  store i32 0, i32* %q_qgrp83, align 4, !tbaa !146
  br label %if.end.84

if.end.84:                                        ; preds = %if.else.82, %if.then.79
  br label %if.end.85

if.end.85:                                        ; preds = %if.end.84, %if.then.70
  br label %if.end.86

if.end.86:                                        ; preds = %if.end.85, %if.else
  br label %if.end.87

if.end.87:                                        ; preds = %if.end.86, %if.then.12
  br label %for.inc

for.inc:                                          ; preds = %if.end.87, %if.end.54, %if.then
  %73 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_next = getelementptr inbounds %struct.address, %struct.address* %73, i32 0, i32 10
  %74 = load %struct.address*, %struct.address** %q_next, align 8, !tbaa !62
  store %struct.address* %74, %struct.address** %q, align 8, !tbaa !1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %75 = load i32, i32* %naddrs, align 4, !tbaa !5
  %cmp88 = icmp sle i32 %75, 1
  br i1 %cmp88, label %land.lhs.true.90, label %if.end.93

land.lhs.true.90:                                 ; preds = %for.end
  %76 = load i32, i32* %changed, align 4, !tbaa !5
  %tobool91 = icmp ne i32 %76, 0
  br i1 %tobool91, label %if.end.93, label %if.then.92

if.then.92:                                       ; preds = %land.lhs.true.90
  store i32 1, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.93:                                        ; preds = %land.lhs.true.90, %for.end
  %77 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_rpool = getelementptr inbounds %struct.envelope, %struct.envelope* %77, i32 0, i32 52
  %78 = load %struct.SM_RPOOL_T*, %struct.SM_RPOOL_T** %e_rpool, align 8, !tbaa !120
  %79 = load i32, i32* %naddrs, align 4, !tbaa !5
  %conv94 = sext i32 %79 to i64
  %mul = mul i64 %conv94, 8
  %80 = load i32, i32* @SmHeapGroup, align 4, !tbaa !5
  %call95 = call i8* @sm_rpool_malloc_tagged_x(%struct.SM_RPOOL_T* %78, i64 %mul, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 8099, i32 %80)
  %81 = bitcast i8* %call95 to %struct.address**
  store %struct.address** %81, %struct.address*** %addrs, align 8, !tbaa !1
  store i32 0, i32* %i, align 4, !tbaa !5
  %82 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_sendqueue96 = getelementptr inbounds %struct.envelope, %struct.envelope* %82, i32 0, i32 7
  %83 = load %struct.address*, %struct.address** %e_sendqueue96, align 8, !tbaa !20
  store %struct.address* %83, %struct.address** %q, align 8, !tbaa !1
  br label %for.cond.97

for.cond.97:                                      ; preds = %for.inc.109, %if.end.93
  %84 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %cmp98 = icmp ne %struct.address* %84, null
  br i1 %cmp98, label %for.body.100, label %for.end.111

for.body.100:                                     ; preds = %for.cond.97
  %85 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_state101 = getelementptr inbounds %struct.address, %struct.address* %85, i32 0, i32 21
  %86 = load i16, i16* %q_state101, align 2, !tbaa !52
  %conv102 = sext i16 %86 to i32
  %cmp103 = icmp sge i32 %conv102, 6
  br i1 %cmp103, label %if.then.105, label %if.end.106

if.then.105:                                      ; preds = %for.body.100
  br label %for.inc.109

if.end.106:                                       ; preds = %for.body.100
  %87 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %88 = load i32, i32* %i, align 4, !tbaa !5
  %inc107 = add nsw i32 %88, 1
  store i32 %inc107, i32* %i, align 4, !tbaa !5
  %idxprom = sext i32 %88 to i64
  %89 = load %struct.address**, %struct.address*** %addrs, align 8, !tbaa !1
  %arrayidx108 = getelementptr inbounds %struct.address*, %struct.address** %89, i64 %idxprom
  store %struct.address* %87, %struct.address** %arrayidx108, align 8, !tbaa !1
  br label %for.inc.109

for.inc.109:                                      ; preds = %if.end.106, %if.then.105
  %90 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_next110 = getelementptr inbounds %struct.address, %struct.address* %90, i32 0, i32 10
  %91 = load %struct.address*, %struct.address** %q_next110, align 8, !tbaa !62
  store %struct.address* %91, %struct.address** %q, align 8, !tbaa !1
  br label %for.cond.97

for.end.111:                                      ; preds = %for.cond.97
  %92 = load %struct.address**, %struct.address*** %addrs, align 8, !tbaa !1
  %93 = bitcast %struct.address** %92 to i8*
  %94 = load i32, i32* %naddrs, align 4, !tbaa !5
  %conv112 = sext i32 %94 to i64
  call void @qsort(i8* %93, i64 %conv112, i64 8, i32 (i8*, i8*)* @q_qgrp_compare)
  store i32 0, i32* %nsplits, align 4, !tbaa !5
  store %struct.envelope* null, %struct.envelope** %es, align 8, !tbaa !1
  %95 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_sendqueue113 = getelementptr inbounds %struct.envelope, %struct.envelope* %95, i32 0, i32 7
  store %struct.address* null, %struct.address** %e_sendqueue113, align 8, !tbaa !20
  store i32 0, i32* %i, align 4, !tbaa !5
  br label %for.cond.114

for.cond.114:                                     ; preds = %for.inc.177, %for.end.111
  %96 = load i32, i32* %i, align 4, !tbaa !5
  %97 = load i32, i32* %naddrs, align 4, !tbaa !5
  %cmp115 = icmp slt i32 %96, %97
  br i1 %cmp115, label %for.body.117, label %for.end.179

for.body.117:                                     ; preds = %for.cond.114
  %98 = load i32, i32* %i, align 4, !tbaa !5
  %99 = load i32, i32* %naddrs, align 4, !tbaa !5
  %sub = sub nsw i32 %99, 1
  %cmp118 = icmp eq i32 %98, %sub
  br i1 %cmp118, label %if.then.129, label %lor.lhs.false.120

lor.lhs.false.120:                                ; preds = %for.body.117
  %100 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom121 = sext i32 %100 to i64
  %101 = load %struct.address**, %struct.address*** %addrs, align 8, !tbaa !1
  %arrayidx122 = getelementptr inbounds %struct.address*, %struct.address** %101, i64 %idxprom121
  %102 = load %struct.address*, %struct.address** %arrayidx122, align 8, !tbaa !1
  %q_qgrp123 = getelementptr inbounds %struct.address, %struct.address* %102, i32 0, i32 23
  %103 = load i32, i32* %q_qgrp123, align 4, !tbaa !146
  %104 = load i32, i32* %i, align 4, !tbaa !5
  %add = add nsw i32 %104, 1
  %idxprom124 = sext i32 %add to i64
  %105 = load %struct.address**, %struct.address*** %addrs, align 8, !tbaa !1
  %arrayidx125 = getelementptr inbounds %struct.address*, %struct.address** %105, i64 %idxprom124
  %106 = load %struct.address*, %struct.address** %arrayidx125, align 8, !tbaa !1
  %q_qgrp126 = getelementptr inbounds %struct.address, %struct.address* %106, i32 0, i32 23
  %107 = load i32, i32* %q_qgrp126, align 4, !tbaa !146
  %cmp127 = icmp ne i32 %103, %107
  br i1 %cmp127, label %if.then.129, label %if.else.133

if.then.129:                                      ; preds = %lor.lhs.false.120, %for.body.117
  %108 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom130 = sext i32 %108 to i64
  %109 = load %struct.address**, %struct.address*** %addrs, align 8, !tbaa !1
  %arrayidx131 = getelementptr inbounds %struct.address*, %struct.address** %109, i64 %idxprom130
  %110 = load %struct.address*, %struct.address** %arrayidx131, align 8, !tbaa !1
  %q_next132 = getelementptr inbounds %struct.address, %struct.address* %110, i32 0, i32 10
  store %struct.address* null, %struct.address** %q_next132, align 8, !tbaa !62
  br label %if.end.140

if.else.133:                                      ; preds = %lor.lhs.false.120
  %111 = load i32, i32* %i, align 4, !tbaa !5
  %add134 = add nsw i32 %111, 1
  %idxprom135 = sext i32 %add134 to i64
  %112 = load %struct.address**, %struct.address*** %addrs, align 8, !tbaa !1
  %arrayidx136 = getelementptr inbounds %struct.address*, %struct.address** %112, i64 %idxprom135
  %113 = load %struct.address*, %struct.address** %arrayidx136, align 8, !tbaa !1
  %114 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom137 = sext i32 %114 to i64
  %115 = load %struct.address**, %struct.address*** %addrs, align 8, !tbaa !1
  %arrayidx138 = getelementptr inbounds %struct.address*, %struct.address** %115, i64 %idxprom137
  %116 = load %struct.address*, %struct.address** %arrayidx138, align 8, !tbaa !1
  %q_next139 = getelementptr inbounds %struct.address, %struct.address* %116, i32 0, i32 10
  store %struct.address* %113, %struct.address** %q_next139, align 8, !tbaa !62
  br label %if.end.140

if.end.140:                                       ; preds = %if.else.133, %if.then.129
  %117 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom141 = sext i32 %117 to i64
  %118 = load %struct.address**, %struct.address*** %addrs, align 8, !tbaa !1
  %arrayidx142 = getelementptr inbounds %struct.address*, %struct.address** %118, i64 %idxprom141
  %119 = load %struct.address*, %struct.address** %arrayidx142, align 8, !tbaa !1
  %q_qgrp143 = getelementptr inbounds %struct.address, %struct.address* %119, i32 0, i32 23
  %120 = load i32, i32* %q_qgrp143, align 4, !tbaa !146
  %121 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qgrp144 = getelementptr inbounds %struct.envelope, %struct.envelope* %121, i32 0, i32 26
  %122 = load i32, i32* %e_qgrp144, align 4, !tbaa !18
  %cmp145 = icmp eq i32 %120, %122
  br i1 %cmp145, label %if.then.147, label %if.end.156

if.then.147:                                      ; preds = %if.end.140
  %123 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_sendqueue148 = getelementptr inbounds %struct.envelope, %struct.envelope* %123, i32 0, i32 7
  %124 = load %struct.address*, %struct.address** %e_sendqueue148, align 8, !tbaa !20
  %cmp149 = icmp eq %struct.address* %124, null
  br i1 %cmp149, label %if.then.151, label %if.end.155

if.then.151:                                      ; preds = %if.then.147
  %125 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom152 = sext i32 %125 to i64
  %126 = load %struct.address**, %struct.address*** %addrs, align 8, !tbaa !1
  %arrayidx153 = getelementptr inbounds %struct.address*, %struct.address** %126, i64 %idxprom152
  %127 = load %struct.address*, %struct.address** %arrayidx153, align 8, !tbaa !1
  %128 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_sendqueue154 = getelementptr inbounds %struct.envelope, %struct.envelope* %128, i32 0, i32 7
  store %struct.address* %127, %struct.address** %e_sendqueue154, align 8, !tbaa !20
  br label %if.end.155

if.end.155:                                       ; preds = %if.then.151, %if.then.147
  br label %for.inc.177

if.end.156:                                       ; preds = %if.end.140
  %129 = load %struct.envelope*, %struct.envelope** %es, align 8, !tbaa !1
  %cmp157 = icmp eq %struct.envelope* %129, null
  br i1 %cmp157, label %if.then.166, label %lor.lhs.false.159

lor.lhs.false.159:                                ; preds = %if.end.156
  %130 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom160 = sext i32 %130 to i64
  %131 = load %struct.address**, %struct.address*** %addrs, align 8, !tbaa !1
  %arrayidx161 = getelementptr inbounds %struct.address*, %struct.address** %131, i64 %idxprom160
  %132 = load %struct.address*, %struct.address** %arrayidx161, align 8, !tbaa !1
  %q_qgrp162 = getelementptr inbounds %struct.address, %struct.address* %132, i32 0, i32 23
  %133 = load i32, i32* %q_qgrp162, align 4, !tbaa !146
  %134 = load %struct.envelope*, %struct.envelope** %es, align 8, !tbaa !1
  %e_qgrp163 = getelementptr inbounds %struct.envelope, %struct.envelope* %134, i32 0, i32 26
  %135 = load i32, i32* %e_qgrp163, align 4, !tbaa !18
  %cmp164 = icmp ne i32 %133, %135
  br i1 %cmp164, label %if.then.166, label %if.end.176

if.then.166:                                      ; preds = %lor.lhs.false.159, %if.end.156
  %136 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %137 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom167 = sext i32 %137 to i64
  %138 = load %struct.address**, %struct.address*** %addrs, align 8, !tbaa !1
  %arrayidx168 = getelementptr inbounds %struct.address*, %struct.address** %138, i64 %idxprom167
  %139 = load %struct.address*, %struct.address** %arrayidx168, align 8, !tbaa !1
  %140 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom169 = sext i32 %140 to i64
  %141 = load %struct.address**, %struct.address*** %addrs, align 8, !tbaa !1
  %arrayidx170 = getelementptr inbounds %struct.address*, %struct.address** %141, i64 %idxprom169
  %142 = load %struct.address*, %struct.address** %arrayidx170, align 8, !tbaa !1
  %q_qgrp171 = getelementptr inbounds %struct.address, %struct.address* %142, i32 0, i32 23
  %143 = load i32, i32* %q_qgrp171, align 4, !tbaa !146
  %call172 = call %struct.envelope* @split_env(%struct.envelope* %136, %struct.address* %139, i32 %143, i32 -1)
  store %struct.envelope* %call172, %struct.envelope** %ee, align 8, !tbaa !1
  %144 = load %struct.envelope*, %struct.envelope** %ee, align 8, !tbaa !1
  store %struct.envelope* %144, %struct.envelope** %es, align 8, !tbaa !1
  %145 = load %struct.envelope*, %struct.envelope** %ee, align 8, !tbaa !1
  %146 = load i32, i32* %nsplits, align 4, !tbaa !5
  %inc173 = add nsw i32 %146, 1
  store i32 %inc173, i32* %nsplits, align 4, !tbaa !5
  %idxprom174 = sext i32 %146 to i64
  %arrayidx175 = getelementptr inbounds [50 x %struct.envelope*], [50 x %struct.envelope*]* %splits, i32 0, i64 %idxprom174
  store %struct.envelope* %145, %struct.envelope** %arrayidx175, align 8, !tbaa !1
  br label %if.end.176

if.end.176:                                       ; preds = %if.then.166, %lor.lhs.false.159
  br label %for.inc.177

for.inc.177:                                      ; preds = %if.end.176, %if.end.155
  %147 = load i32, i32* %i, align 4, !tbaa !5
  %inc178 = add nsw i32 %147, 1
  store i32 %inc178, i32* %i, align 4, !tbaa !5
  br label %for.cond.114

for.end.179:                                      ; preds = %for.cond.114
  %148 = load i32, i32* %nsplits, align 4, !tbaa !5
  %cmp180 = icmp sle i32 %148, 0
  br i1 %cmp180, label %if.then.182, label %if.end.183

if.then.182:                                      ; preds = %for.end.179
  store i32 1, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.183:                                       ; preds = %for.end.179
  store i32 0, i32* %i, align 4, !tbaa !5
  br label %for.cond.184

for.cond.184:                                     ; preds = %for.inc.194, %if.end.183
  %149 = load i32, i32* %i, align 4, !tbaa !5
  %150 = load i32, i32* %nsplits, align 4, !tbaa !5
  %cmp185 = icmp slt i32 %149, %150
  br i1 %cmp185, label %for.body.187, label %for.end.196

for.body.187:                                     ; preds = %for.cond.184
  %151 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom188 = sext i32 %151 to i64
  %arrayidx189 = getelementptr inbounds [50 x %struct.envelope*], [50 x %struct.envelope*]* %splits, i32 0, i64 %idxprom188
  %152 = load %struct.envelope*, %struct.envelope** %arrayidx189, align 8, !tbaa !1
  store %struct.envelope* %152, %struct.envelope** %es, align 8, !tbaa !1
  %153 = load %struct.envelope*, %struct.envelope** %es, align 8, !tbaa !1
  %call190 = call i32 @setnewqueue(%struct.envelope* %153)
  %tobool191 = icmp ne i32 %call190, 0
  br i1 %tobool191, label %if.end.193, label %if.then.192

if.then.192:                                      ; preds = %for.body.187
  br label %failure

if.end.193:                                       ; preds = %for.body.187
  br label %for.inc.194

for.inc.194:                                      ; preds = %if.end.193
  %154 = load i32, i32* %i, align 4, !tbaa !5
  %inc195 = add nsw i32 %154, 1
  store i32 %inc195, i32* %i, align 4, !tbaa !5
  br label %for.cond.184

for.end.196:                                      ; preds = %for.cond.184
  %arraydecay197 = getelementptr inbounds [50 x %struct.envelope*], [50 x %struct.envelope*]* %splits, i32 0, i32 0
  %155 = bitcast %struct.envelope** %arraydecay197 to i8*
  %156 = load i32, i32* %nsplits, align 4, !tbaa !5
  %conv198 = sext i32 %156 to i64
  call void @qsort(i8* %155, i64 %conv198, i64 8, i32 (i8*, i8*)* @e_filesys_compare)
  %157 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %arrayidx199 = getelementptr inbounds [50 x %struct.envelope*], [50 x %struct.envelope*]* %splits, i32 0, i64 0
  %158 = load %struct.envelope*, %struct.envelope** %arrayidx199, align 8, !tbaa !1
  %call200 = call i32 @dup_df(%struct.envelope* %157, %struct.envelope* %158)
  %tobool201 = icmp ne i32 %call200, 0
  br i1 %tobool201, label %if.end.203, label %if.then.202

if.then.202:                                      ; preds = %for.end.196
  store i32 0, i32* %i, align 4, !tbaa !5
  br label %failure

if.end.203:                                       ; preds = %for.end.196
  store i32 1, i32* %i, align 4, !tbaa !5
  br label %for.cond.204

for.cond.204:                                     ; preds = %for.inc.217, %if.end.203
  %159 = load i32, i32* %i, align 4, !tbaa !5
  %160 = load i32, i32* %nsplits, align 4, !tbaa !5
  %cmp205 = icmp slt i32 %159, %160
  br i1 %cmp205, label %for.body.207, label %for.end.219

for.body.207:                                     ; preds = %for.cond.204
  %161 = load i32, i32* %i, align 4, !tbaa !5
  %sub208 = sub nsw i32 %161, 1
  %idxprom209 = sext i32 %sub208 to i64
  %arrayidx210 = getelementptr inbounds [50 x %struct.envelope*], [50 x %struct.envelope*]* %splits, i32 0, i64 %idxprom209
  %162 = load %struct.envelope*, %struct.envelope** %arrayidx210, align 8, !tbaa !1
  %163 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom211 = sext i32 %163 to i64
  %arrayidx212 = getelementptr inbounds [50 x %struct.envelope*], [50 x %struct.envelope*]* %splits, i32 0, i64 %idxprom211
  %164 = load %struct.envelope*, %struct.envelope** %arrayidx212, align 8, !tbaa !1
  %call213 = call i32 @dup_df(%struct.envelope* %162, %struct.envelope* %164)
  %tobool214 = icmp ne i32 %call213, 0
  br i1 %tobool214, label %if.end.216, label %if.then.215

if.then.215:                                      ; preds = %for.body.207
  br label %failure

if.end.216:                                       ; preds = %for.body.207
  br label %for.inc.217

for.inc.217:                                      ; preds = %if.end.216
  %165 = load i32, i32* %i, align 4, !tbaa !5
  %inc218 = add nsw i32 %165, 1
  store i32 %inc218, i32* %i, align 4, !tbaa !5
  br label %for.cond.204

for.end.219:                                      ; preds = %for.cond.204
  store i32 0, i32* %i, align 4, !tbaa !5
  br label %for.cond.220

for.cond.220:                                     ; preds = %for.inc.228, %for.end.219
  %166 = load i32, i32* %i, align 4, !tbaa !5
  %167 = load i32, i32* %nsplits, align 4, !tbaa !5
  %cmp221 = icmp slt i32 %166, %167
  br i1 %cmp221, label %for.body.223, label %for.end.230

for.body.223:                                     ; preds = %for.cond.220
  %168 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom224 = sext i32 %168 to i64
  %arrayidx225 = getelementptr inbounds [50 x %struct.envelope*], [50 x %struct.envelope*]* %splits, i32 0, i64 %idxprom224
  %169 = load %struct.envelope*, %struct.envelope** %arrayidx225, align 8, !tbaa !1
  store %struct.envelope* %169, %struct.envelope** %es, align 8, !tbaa !1
  %170 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_sibling = getelementptr inbounds %struct.envelope, %struct.envelope* %170, i32 0, i32 22
  %171 = load %struct.envelope*, %struct.envelope** %e_sibling, align 8, !tbaa !148
  %172 = load %struct.envelope*, %struct.envelope** %es, align 8, !tbaa !1
  %e_sibling226 = getelementptr inbounds %struct.envelope, %struct.envelope* %172, i32 0, i32 22
  store %struct.envelope* %171, %struct.envelope** %e_sibling226, align 8, !tbaa !148
  %173 = load %struct.envelope*, %struct.envelope** %es, align 8, !tbaa !1
  %174 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_sibling227 = getelementptr inbounds %struct.envelope, %struct.envelope* %174, i32 0, i32 22
  store %struct.envelope* %173, %struct.envelope** %e_sibling227, align 8, !tbaa !148
  br label %for.inc.228

for.inc.228:                                      ; preds = %for.body.223
  %175 = load i32, i32* %i, align 4, !tbaa !5
  %inc229 = add nsw i32 %175, 1
  store i32 %inc229, i32* %i, align 4, !tbaa !5
  br label %for.cond.220

for.end.230:                                      ; preds = %for.cond.220
  %176 = load i32, i32* %nsplits, align 4, !tbaa !5
  %add231 = add nsw i32 1, %176
  store i32 %add231, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

failure:                                          ; preds = %if.then.215, %if.then.202, %if.then.192
  %177 = load i32, i32* %i, align 4, !tbaa !5
  %cmp232 = icmp sgt i32 %177, 0
  br i1 %cmp232, label %if.then.234, label %if.end.246

if.then.234:                                      ; preds = %failure
  %178 = bitcast i32* %j to i8*
  call void @llvm.lifetime.start(i64 4, i8* %178) #1
  store i32 0, i32* %j, align 4, !tbaa !5
  br label %for.cond.235

for.cond.235:                                     ; preds = %for.inc.243, %if.then.234
  %179 = load i32, i32* %j, align 4, !tbaa !5
  %180 = load i32, i32* %i, align 4, !tbaa !5
  %cmp236 = icmp slt i32 %179, %180
  br i1 %cmp236, label %for.body.238, label %for.end.245

for.body.238:                                     ; preds = %for.cond.235
  %181 = load i32, i32* %j, align 4, !tbaa !5
  %idxprom239 = sext i32 %181 to i64
  %arrayidx240 = getelementptr inbounds [50 x %struct.envelope*], [50 x %struct.envelope*]* %splits, i32 0, i64 %idxprom239
  %182 = load %struct.envelope*, %struct.envelope** %arrayidx240, align 8, !tbaa !1
  %call241 = call i8* @queuename(%struct.envelope* %182, i32 100)
  %call242 = call i32 @unlink(i8* %call241) #1
  br label %for.inc.243

for.inc.243:                                      ; preds = %for.body.238
  %183 = load i32, i32* %j, align 4, !tbaa !5
  %inc244 = add nsw i32 %183, 1
  store i32 %inc244, i32* %j, align 4, !tbaa !5
  br label %for.cond.235

for.end.245:                                      ; preds = %for.cond.235
  %184 = bitcast i32* %j to i8*
  call void @llvm.lifetime.end(i64 4, i8* %184) #1
  br label %if.end.246

if.end.246:                                       ; preds = %for.end.245, %failure
  %185 = load %struct.address**, %struct.address*** %addrs, align 8, !tbaa !1
  %arrayidx247 = getelementptr inbounds %struct.address*, %struct.address** %185, i64 0
  %186 = load %struct.address*, %struct.address** %arrayidx247, align 8, !tbaa !1
  %187 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_sendqueue248 = getelementptr inbounds %struct.envelope, %struct.envelope* %187, i32 0, i32 7
  store %struct.address* %186, %struct.address** %e_sendqueue248, align 8, !tbaa !20
  store i32 0, i32* %i, align 4, !tbaa !5
  br label %for.cond.249

for.cond.249:                                     ; preds = %for.inc.260, %if.end.246
  %188 = load i32, i32* %i, align 4, !tbaa !5
  %189 = load i32, i32* %naddrs, align 4, !tbaa !5
  %sub250 = sub nsw i32 %189, 1
  %cmp251 = icmp slt i32 %188, %sub250
  br i1 %cmp251, label %for.body.253, label %for.end.262

for.body.253:                                     ; preds = %for.cond.249
  %190 = load i32, i32* %i, align 4, !tbaa !5
  %add254 = add nsw i32 %190, 1
  %idxprom255 = sext i32 %add254 to i64
  %191 = load %struct.address**, %struct.address*** %addrs, align 8, !tbaa !1
  %arrayidx256 = getelementptr inbounds %struct.address*, %struct.address** %191, i64 %idxprom255
  %192 = load %struct.address*, %struct.address** %arrayidx256, align 8, !tbaa !1
  %193 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom257 = sext i32 %193 to i64
  %194 = load %struct.address**, %struct.address*** %addrs, align 8, !tbaa !1
  %arrayidx258 = getelementptr inbounds %struct.address*, %struct.address** %194, i64 %idxprom257
  %195 = load %struct.address*, %struct.address** %arrayidx258, align 8, !tbaa !1
  %q_next259 = getelementptr inbounds %struct.address, %struct.address* %195, i32 0, i32 10
  store %struct.address* %192, %struct.address** %q_next259, align 8, !tbaa !62
  br label %for.inc.260

for.inc.260:                                      ; preds = %for.body.253
  %196 = load i32, i32* %i, align 4, !tbaa !5
  %inc261 = add nsw i32 %196, 1
  store i32 %inc261, i32* %i, align 4, !tbaa !5
  br label %for.cond.249

for.end.262:                                      ; preds = %for.cond.249
  %197 = load i32, i32* %naddrs, align 4, !tbaa !5
  %sub263 = sub nsw i32 %197, 1
  %idxprom264 = sext i32 %sub263 to i64
  %198 = load %struct.address**, %struct.address*** %addrs, align 8, !tbaa !1
  %arrayidx265 = getelementptr inbounds %struct.address*, %struct.address** %198, i64 %idxprom264
  %199 = load %struct.address*, %struct.address** %arrayidx265, align 8, !tbaa !1
  %q_next266 = getelementptr inbounds %struct.address, %struct.address* %199, i32 0, i32 10
  store %struct.address* null, %struct.address** %q_next266, align 8, !tbaa !62
  store i32 0, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

cleanup:                                          ; preds = %for.end.262, %for.end.230, %if.then.182, %if.then.92
  %200 = bitcast [1256 x i8]* %pvpbuf to i8*
  call void @llvm.lifetime.end(i64 1256, i8* %200) #1
  %201 = bitcast [50 x %struct.envelope*]* %splits to i8*
  call void @llvm.lifetime.end(i64 400, i8* %201) #1
  %202 = bitcast %struct.envelope** %es to i8*
  call void @llvm.lifetime.end(i64 8, i8* %202) #1
  %203 = bitcast %struct.envelope** %ee to i8*
  call void @llvm.lifetime.end(i64 8, i8* %203) #1
  %204 = bitcast %struct.address*** %addrs to i8*
  call void @llvm.lifetime.end(i64 8, i8* %204) #1
  %205 = bitcast %struct.address** %q to i8*
  call void @llvm.lifetime.end(i64 8, i8* %205) #1
  %206 = bitcast i8*** %pvp to i8*
  call void @llvm.lifetime.end(i64 8, i8* %206) #1
  %207 = bitcast i32* %changed to i8*
  call void @llvm.lifetime.end(i64 4, i8* %207) #1
  %208 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end(i64 4, i8* %208) #1
  %209 = bitcast i32* %nsplits to i8*
  call void @llvm.lifetime.end(i64 4, i8* %209) #1
  %210 = bitcast i32* %naddrs to i8*
  call void @llvm.lifetime.end(i64 4, i8* %210) #1
  %211 = load i32, i32* %retval
  ret i32 %211
}

; Function Attrs: nounwind uwtable
define internal i32 @split_within_queue(%struct.envelope* %e) #0 {
entry:
  %retval = alloca i32, align 4
  %e.addr = alloca %struct.envelope*, align 8
  %maxrcpt = alloca i32, align 4
  %nrcpt = alloca i32, align 4
  %ndead = alloca i32, align 4
  %nsplit = alloca i32, align 4
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %l = alloca i32, align 4
  %lsplits = alloca i8*, align 8
  %q = alloca %struct.address*, align 8
  %addrs = alloca %struct.address**, align 8
  %ee = alloca %struct.envelope*, align 8
  %firstsibling = alloca %struct.envelope*, align 8
  %cleanup.dest.slot = alloca i32
  %tmp = alloca %struct.address*, align 8
  %p = alloca i8*, align 8
  store %struct.envelope* %e, %struct.envelope** %e.addr, align 8, !tbaa !1
  %0 = bitcast i32* %maxrcpt to i8*
  call void @llvm.lifetime.start(i64 4, i8* %0) #1
  %1 = bitcast i32* %nrcpt to i8*
  call void @llvm.lifetime.start(i64 4, i8* %1) #1
  %2 = bitcast i32* %ndead to i8*
  call void @llvm.lifetime.start(i64 4, i8* %2) #1
  %3 = bitcast i32* %nsplit to i8*
  call void @llvm.lifetime.start(i64 4, i8* %3) #1
  %4 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start(i64 4, i8* %4) #1
  %5 = bitcast i32* %j to i8*
  call void @llvm.lifetime.start(i64 4, i8* %5) #1
  %6 = bitcast i32* %l to i8*
  call void @llvm.lifetime.start(i64 4, i8* %6) #1
  %7 = bitcast i8** %lsplits to i8*
  call void @llvm.lifetime.start(i64 8, i8* %7) #1
  %8 = bitcast %struct.address** %q to i8*
  call void @llvm.lifetime.start(i64 8, i8* %8) #1
  %9 = bitcast %struct.address*** %addrs to i8*
  call void @llvm.lifetime.start(i64 8, i8* %9) #1
  %10 = bitcast %struct.envelope** %ee to i8*
  call void @llvm.lifetime.start(i64 8, i8* %10) #1
  %11 = bitcast %struct.envelope** %firstsibling to i8*
  call void @llvm.lifetime.start(i64 8, i8* %11) #1
  %12 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qgrp = getelementptr inbounds %struct.envelope, %struct.envelope* %12, i32 0, i32 26
  %13 = load i32, i32* %e_qgrp, align 4, !tbaa !18
  %cmp = icmp sge i32 %13, 0
  br i1 %cmp, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %14 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_flags = getelementptr inbounds %struct.envelope, %struct.envelope* %14, i32 0, i32 11
  %15 = load i64, i64* %e_flags, align 8, !tbaa !15
  %and = and i64 %15, 67108864
  %cmp1 = icmp ne i64 %and, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 1, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end:                                           ; preds = %lor.lhs.false
  %16 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qgrp2 = getelementptr inbounds %struct.envelope, %struct.envelope* %16, i32 0, i32 26
  %17 = load i32, i32* %e_qgrp2, align 4, !tbaa !18
  %idxprom = sext i32 %17 to i64
  %arrayidx = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom
  %18 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx, align 8, !tbaa !1
  %qg_maxrcpt = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %18, i32 0, i32 12
  %19 = load i32, i32* %qg_maxrcpt, align 4, !tbaa !158
  store i32 %19, i32* %maxrcpt, align 4, !tbaa !5
  %20 = load i32, i32* %maxrcpt, align 4, !tbaa !5
  %cmp3 = icmp sle i32 %20, 0
  br i1 %cmp3, label %if.then.4, label %if.end.5

if.then.4:                                        ; preds = %if.end
  store i32 1, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.5:                                         ; preds = %if.end
  store i32 0, i32* %nrcpt, align 4, !tbaa !5
  %21 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_sendqueue = getelementptr inbounds %struct.envelope, %struct.envelope* %21, i32 0, i32 7
  %22 = load %struct.address*, %struct.address** %e_sendqueue, align 8, !tbaa !20
  store %struct.address* %22, %struct.address** %q, align 8, !tbaa !1
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end.5
  %23 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %cmp6 = icmp ne %struct.address* %23, null
  br i1 %cmp6, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %24 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_state = getelementptr inbounds %struct.address, %struct.address* %24, i32 0, i32 21
  %25 = load i16, i16* %q_state, align 2, !tbaa !52
  %conv = sext i16 %25 to i32
  %cmp7 = icmp sge i32 %conv, 6
  br i1 %cmp7, label %if.then.9, label %if.end.10

if.then.9:                                        ; preds = %for.body
  br label %for.inc

if.end.10:                                        ; preds = %for.body
  %26 = load i32, i32* %nrcpt, align 4, !tbaa !5
  %inc = add nsw i32 %26, 1
  store i32 %inc, i32* %nrcpt, align 4, !tbaa !5
  br label %for.inc

for.inc:                                          ; preds = %if.end.10, %if.then.9
  %27 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_next = getelementptr inbounds %struct.address, %struct.address* %27, i32 0, i32 10
  %28 = load %struct.address*, %struct.address** %q_next, align 8, !tbaa !62
  store %struct.address* %28, %struct.address** %q, align 8, !tbaa !1
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %29 = load i32, i32* %nrcpt, align 4, !tbaa !5
  %30 = load i32, i32* %maxrcpt, align 4, !tbaa !5
  %cmp11 = icmp sle i32 %29, %30
  br i1 %cmp11, label %if.then.13, label %if.end.14

if.then.13:                                       ; preds = %for.end
  store i32 1, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.14:                                        ; preds = %for.end
  %31 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_rpool = getelementptr inbounds %struct.envelope, %struct.envelope* %31, i32 0, i32 52
  %32 = load %struct.SM_RPOOL_T*, %struct.SM_RPOOL_T** %e_rpool, align 8, !tbaa !120
  %33 = load i32, i32* %nrcpt, align 4, !tbaa !5
  %conv15 = sext i32 %33 to i64
  %mul = mul i64 %conv15, 8
  %34 = load i32, i32* @SmHeapGroup, align 4, !tbaa !5
  %call = call i8* @sm_rpool_malloc_tagged_x(%struct.SM_RPOOL_T* %32, i64 %mul, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 8247, i32 %34)
  %35 = bitcast i8* %call to %struct.address**
  store %struct.address** %35, %struct.address*** %addrs, align 8, !tbaa !1
  store i32 0, i32* %i, align 4, !tbaa !5
  %36 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_sendqueue16 = getelementptr inbounds %struct.envelope, %struct.envelope* %36, i32 0, i32 7
  %37 = load %struct.address*, %struct.address** %e_sendqueue16, align 8, !tbaa !20
  store %struct.address* %37, %struct.address** %q, align 8, !tbaa !1
  br label %for.cond.17

for.cond.17:                                      ; preds = %for.inc.30, %if.end.14
  %38 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %cmp18 = icmp ne %struct.address* %38, null
  br i1 %cmp18, label %for.body.20, label %for.end.32

for.body.20:                                      ; preds = %for.cond.17
  %39 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_state21 = getelementptr inbounds %struct.address, %struct.address* %39, i32 0, i32 21
  %40 = load i16, i16* %q_state21, align 2, !tbaa !52
  %conv22 = sext i16 %40 to i32
  %cmp23 = icmp sge i32 %conv22, 6
  br i1 %cmp23, label %if.then.25, label %if.end.26

if.then.25:                                       ; preds = %for.body.20
  br label %for.inc.30

if.end.26:                                        ; preds = %for.body.20
  %41 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %42 = load i32, i32* %i, align 4, !tbaa !5
  %inc27 = add nsw i32 %42, 1
  store i32 %inc27, i32* %i, align 4, !tbaa !5
  %idxprom28 = sext i32 %42 to i64
  %43 = load %struct.address**, %struct.address*** %addrs, align 8, !tbaa !1
  %arrayidx29 = getelementptr inbounds %struct.address*, %struct.address** %43, i64 %idxprom28
  store %struct.address* %41, %struct.address** %arrayidx29, align 8, !tbaa !1
  br label %for.inc.30

for.inc.30:                                       ; preds = %if.end.26, %if.then.25
  %44 = load %struct.address*, %struct.address** %q, align 8, !tbaa !1
  %q_next31 = getelementptr inbounds %struct.address, %struct.address* %44, i32 0, i32 10
  %45 = load %struct.address*, %struct.address** %q_next31, align 8, !tbaa !62
  store %struct.address* %45, %struct.address** %q, align 8, !tbaa !1
  br label %for.cond.17

for.end.32:                                       ; preds = %for.cond.17
  store i32 0, i32* %ndead, align 4, !tbaa !5
  store i32 0, i32* %i, align 4, !tbaa !5
  br label %for.cond.33

for.cond.33:                                      ; preds = %for.inc.72, %for.end.32
  %46 = load i32, i32* %i, align 4, !tbaa !5
  %47 = load i32, i32* %nrcpt, align 4, !tbaa !5
  %cmp34 = icmp slt i32 %46, %47
  br i1 %cmp34, label %for.body.36, label %for.end.74

for.body.36:                                      ; preds = %for.cond.33
  %48 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom37 = sext i32 %48 to i64
  %49 = load %struct.address**, %struct.address*** %addrs, align 8, !tbaa !1
  %arrayidx38 = getelementptr inbounds %struct.address*, %struct.address** %49, i64 %idxprom37
  %50 = load %struct.address*, %struct.address** %arrayidx38, align 8, !tbaa !1
  %q_state39 = getelementptr inbounds %struct.address, %struct.address* %50, i32 0, i32 21
  %51 = load i16, i16* %q_state39, align 2, !tbaa !52
  %conv40 = sext i16 %51 to i32
  %cmp41 = icmp eq i32 %conv40, 2
  br i1 %cmp41, label %if.then.57, label %lor.lhs.false.43

lor.lhs.false.43:                                 ; preds = %for.body.36
  %52 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom44 = sext i32 %52 to i64
  %53 = load %struct.address**, %struct.address*** %addrs, align 8, !tbaa !1
  %arrayidx45 = getelementptr inbounds %struct.address*, %struct.address** %53, i64 %idxprom44
  %54 = load %struct.address*, %struct.address** %arrayidx45, align 8, !tbaa !1
  %q_state46 = getelementptr inbounds %struct.address, %struct.address* %54, i32 0, i32 21
  %55 = load i16, i16* %q_state46, align 2, !tbaa !52
  %conv47 = sext i16 %55 to i32
  %cmp48 = icmp eq i32 %conv47, 1
  br i1 %cmp48, label %if.then.57, label %lor.lhs.false.50

lor.lhs.false.50:                                 ; preds = %lor.lhs.false.43
  %56 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom51 = sext i32 %56 to i64
  %57 = load %struct.address**, %struct.address*** %addrs, align 8, !tbaa !1
  %arrayidx52 = getelementptr inbounds %struct.address*, %struct.address** %57, i64 %idxprom51
  %58 = load %struct.address*, %struct.address** %arrayidx52, align 8, !tbaa !1
  %q_state53 = getelementptr inbounds %struct.address, %struct.address* %58, i32 0, i32 21
  %59 = load i16, i16* %q_state53, align 2, !tbaa !52
  %conv54 = sext i16 %59 to i32
  %cmp55 = icmp sge i32 %conv54, 6
  br i1 %cmp55, label %if.then.57, label %if.end.71

if.then.57:                                       ; preds = %lor.lhs.false.50, %lor.lhs.false.43, %for.body.36
  %60 = load i32, i32* %i, align 4, !tbaa !5
  %61 = load i32, i32* %ndead, align 4, !tbaa !5
  %cmp58 = icmp sgt i32 %60, %61
  br i1 %cmp58, label %if.then.60, label %if.end.69

if.then.60:                                       ; preds = %if.then.57
  %62 = bitcast %struct.address** %tmp to i8*
  call void @llvm.lifetime.start(i64 8, i8* %62) #1
  %63 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom61 = sext i32 %63 to i64
  %64 = load %struct.address**, %struct.address*** %addrs, align 8, !tbaa !1
  %arrayidx62 = getelementptr inbounds %struct.address*, %struct.address** %64, i64 %idxprom61
  %65 = load %struct.address*, %struct.address** %arrayidx62, align 8, !tbaa !1
  store %struct.address* %65, %struct.address** %tmp, align 8, !tbaa !1
  %66 = load i32, i32* %ndead, align 4, !tbaa !5
  %idxprom63 = sext i32 %66 to i64
  %67 = load %struct.address**, %struct.address*** %addrs, align 8, !tbaa !1
  %arrayidx64 = getelementptr inbounds %struct.address*, %struct.address** %67, i64 %idxprom63
  %68 = load %struct.address*, %struct.address** %arrayidx64, align 8, !tbaa !1
  %69 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom65 = sext i32 %69 to i64
  %70 = load %struct.address**, %struct.address*** %addrs, align 8, !tbaa !1
  %arrayidx66 = getelementptr inbounds %struct.address*, %struct.address** %70, i64 %idxprom65
  store %struct.address* %68, %struct.address** %arrayidx66, align 8, !tbaa !1
  %71 = load %struct.address*, %struct.address** %tmp, align 8, !tbaa !1
  %72 = load i32, i32* %ndead, align 4, !tbaa !5
  %idxprom67 = sext i32 %72 to i64
  %73 = load %struct.address**, %struct.address*** %addrs, align 8, !tbaa !1
  %arrayidx68 = getelementptr inbounds %struct.address*, %struct.address** %73, i64 %idxprom67
  store %struct.address* %71, %struct.address** %arrayidx68, align 8, !tbaa !1
  %74 = bitcast %struct.address** %tmp to i8*
  call void @llvm.lifetime.end(i64 8, i8* %74) #1
  br label %if.end.69

if.end.69:                                        ; preds = %if.then.60, %if.then.57
  %75 = load i32, i32* %ndead, align 4, !tbaa !5
  %inc70 = add nsw i32 %75, 1
  store i32 %inc70, i32* %ndead, align 4, !tbaa !5
  br label %if.end.71

if.end.71:                                        ; preds = %if.end.69, %lor.lhs.false.50
  br label %for.inc.72

for.inc.72:                                       ; preds = %if.end.71
  %76 = load i32, i32* %i, align 4, !tbaa !5
  %inc73 = add nsw i32 %76, 1
  store i32 %inc73, i32* %i, align 4, !tbaa !5
  br label %for.cond.33

for.end.74:                                       ; preds = %for.cond.33
  %77 = load i32, i32* %nrcpt, align 4, !tbaa !5
  %78 = load i32, i32* %ndead, align 4, !tbaa !5
  %sub = sub nsw i32 %77, %78
  %79 = load i32, i32* %maxrcpt, align 4, !tbaa !5
  %cmp75 = icmp sle i32 %sub, %79
  br i1 %cmp75, label %if.then.77, label %if.end.78

if.then.77:                                       ; preds = %for.end.74
  store i32 1, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.78:                                        ; preds = %for.end.74
  store i32 0, i32* %i, align 4, !tbaa !5
  br label %for.cond.79

for.cond.79:                                      ; preds = %for.inc.89, %if.end.78
  %80 = load i32, i32* %i, align 4, !tbaa !5
  %81 = load i32, i32* %nrcpt, align 4, !tbaa !5
  %sub80 = sub nsw i32 %81, 1
  %cmp81 = icmp slt i32 %80, %sub80
  br i1 %cmp81, label %for.body.83, label %for.end.91

for.body.83:                                      ; preds = %for.cond.79
  %82 = load i32, i32* %i, align 4, !tbaa !5
  %add = add nsw i32 %82, 1
  %idxprom84 = sext i32 %add to i64
  %83 = load %struct.address**, %struct.address*** %addrs, align 8, !tbaa !1
  %arrayidx85 = getelementptr inbounds %struct.address*, %struct.address** %83, i64 %idxprom84
  %84 = load %struct.address*, %struct.address** %arrayidx85, align 8, !tbaa !1
  %85 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom86 = sext i32 %85 to i64
  %86 = load %struct.address**, %struct.address*** %addrs, align 8, !tbaa !1
  %arrayidx87 = getelementptr inbounds %struct.address*, %struct.address** %86, i64 %idxprom86
  %87 = load %struct.address*, %struct.address** %arrayidx87, align 8, !tbaa !1
  %q_next88 = getelementptr inbounds %struct.address, %struct.address* %87, i32 0, i32 10
  store %struct.address* %84, %struct.address** %q_next88, align 8, !tbaa !62
  br label %for.inc.89

for.inc.89:                                       ; preds = %for.body.83
  %88 = load i32, i32* %i, align 4, !tbaa !5
  %inc90 = add nsw i32 %88, 1
  store i32 %inc90, i32* %i, align 4, !tbaa !5
  br label %for.cond.79

for.end.91:                                       ; preds = %for.cond.79
  %89 = load i32, i32* %nrcpt, align 4, !tbaa !5
  %sub92 = sub nsw i32 %89, 1
  %idxprom93 = sext i32 %sub92 to i64
  %90 = load %struct.address**, %struct.address*** %addrs, align 8, !tbaa !1
  %arrayidx94 = getelementptr inbounds %struct.address*, %struct.address** %90, i64 %idxprom93
  %91 = load %struct.address*, %struct.address** %arrayidx94, align 8, !tbaa !1
  %q_next95 = getelementptr inbounds %struct.address, %struct.address* %91, i32 0, i32 10
  store %struct.address* null, %struct.address** %q_next95, align 8, !tbaa !62
  %92 = load %struct.address**, %struct.address*** %addrs, align 8, !tbaa !1
  %arrayidx96 = getelementptr inbounds %struct.address*, %struct.address** %92, i64 0
  %93 = load %struct.address*, %struct.address** %arrayidx96, align 8, !tbaa !1
  %94 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_sendqueue97 = getelementptr inbounds %struct.envelope, %struct.envelope* %94, i32 0, i32 7
  store %struct.address* %93, %struct.address** %e_sendqueue97, align 8, !tbaa !20
  %95 = load i32, i32* @LogLevel, align 4, !tbaa !5
  %cmp98 = icmp sgt i32 %95, 8
  br i1 %cmp98, label %if.then.100, label %if.else

if.then.100:                                      ; preds = %for.end.91
  store i32 2048, i32* %l, align 4, !tbaa !5
  %96 = load i32, i32* %l, align 4, !tbaa !5
  %conv101 = sext i32 %96 to i64
  %97 = load i32, i32* @SmHeapGroup, align 4, !tbaa !5
  %call102 = call i8* @sm_malloc_tagged(i64 %conv101, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 8294, i32 %97)
  store i8* %call102, i8** %lsplits, align 8, !tbaa !1
  %98 = load i8*, i8** %lsplits, align 8, !tbaa !1
  %cmp103 = icmp ne i8* %98, null
  br i1 %cmp103, label %if.then.105, label %if.end.106

if.then.105:                                      ; preds = %if.then.100
  %99 = load i8*, i8** %lsplits, align 8, !tbaa !1
  store i8 0, i8* %99, align 1, !tbaa !17
  br label %if.end.106

if.end.106:                                       ; preds = %if.then.105, %if.then.100
  store i32 0, i32* %j, align 4, !tbaa !5
  br label %if.end.107

if.else:                                          ; preds = %for.end.91
  store i8* null, i8** %lsplits, align 8, !tbaa !1
  store i32 0, i32* %l, align 4, !tbaa !5
  store i32 0, i32* %j, align 4, !tbaa !5
  br label %if.end.107

if.end.107:                                       ; preds = %if.else, %if.end.106
  %100 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_sibling = getelementptr inbounds %struct.envelope, %struct.envelope* %100, i32 0, i32 22
  %101 = load %struct.envelope*, %struct.envelope** %e_sibling, align 8, !tbaa !148
  store %struct.envelope* %101, %struct.envelope** %firstsibling, align 8, !tbaa !1
  %102 = load i32, i32* %maxrcpt, align 4, !tbaa !5
  %103 = load i32, i32* %ndead, align 4, !tbaa !5
  %add108 = add nsw i32 %102, %103
  store i32 %add108, i32* %i, align 4, !tbaa !5
  store i32 0, i32* %nsplit, align 4, !tbaa !5
  br label %for.cond.109

for.cond.109:                                     ; preds = %if.end.204, %if.end.107
  %104 = load i32, i32* %i, align 4, !tbaa !5
  %sub110 = sub nsw i32 %104, 1
  %idxprom111 = sext i32 %sub110 to i64
  %105 = load %struct.address**, %struct.address*** %addrs, align 8, !tbaa !1
  %arrayidx112 = getelementptr inbounds %struct.address*, %struct.address** %105, i64 %idxprom111
  %106 = load %struct.address*, %struct.address** %arrayidx112, align 8, !tbaa !1
  %q_next113 = getelementptr inbounds %struct.address, %struct.address* %106, i32 0, i32 10
  store %struct.address* null, %struct.address** %q_next113, align 8, !tbaa !62
  %107 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %108 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom114 = sext i32 %108 to i64
  %109 = load %struct.address**, %struct.address*** %addrs, align 8, !tbaa !1
  %arrayidx115 = getelementptr inbounds %struct.address*, %struct.address** %109, i64 %idxprom114
  %110 = load %struct.address*, %struct.address** %arrayidx115, align 8, !tbaa !1
  %111 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qgrp116 = getelementptr inbounds %struct.envelope, %struct.envelope* %111, i32 0, i32 26
  %112 = load i32, i32* %e_qgrp116, align 4, !tbaa !18
  %113 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_qdir = getelementptr inbounds %struct.envelope, %struct.envelope* %113, i32 0, i32 27
  %114 = load i32, i32* %e_qdir, align 4, !tbaa !19
  %call117 = call %struct.envelope* @split_env(%struct.envelope* %107, %struct.address* %110, i32 %112, i32 %114)
  store %struct.envelope* %call117, %struct.envelope** %ee, align 8, !tbaa !1
  %115 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %116 = load %struct.envelope*, %struct.envelope** %ee, align 8, !tbaa !1
  %call118 = call i32 @dup_df(%struct.envelope* %115, %struct.envelope* %116)
  %tobool = icmp ne i32 %call118, 0
  br i1 %tobool, label %if.end.144, label %if.then.119

if.then.119:                                      ; preds = %for.cond.109
  %117 = load %struct.envelope*, %struct.envelope** %firstsibling, align 8, !tbaa !1
  store %struct.envelope* %117, %struct.envelope** %ee, align 8, !tbaa !1
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then.119
  %118 = load %struct.envelope*, %struct.envelope** %ee, align 8, !tbaa !1
  %cmp120 = icmp ne %struct.envelope* %118, null
  br i1 %cmp120, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %119 = load %struct.envelope*, %struct.envelope** %ee, align 8, !tbaa !1
  %call122 = call i8* @queuename(%struct.envelope* %119, i32 100)
  %call123 = call i32 @unlink(i8* %call122) #1
  %120 = load %struct.envelope*, %struct.envelope** %ee, align 8, !tbaa !1
  %e_sibling124 = getelementptr inbounds %struct.envelope, %struct.envelope* %120, i32 0, i32 22
  %121 = load %struct.envelope*, %struct.envelope** %e_sibling124, align 8, !tbaa !148
  store %struct.envelope* %121, %struct.envelope** %ee, align 8, !tbaa !1
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %122 = load %struct.envelope*, %struct.envelope** %firstsibling, align 8, !tbaa !1
  %123 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_sibling125 = getelementptr inbounds %struct.envelope, %struct.envelope* %123, i32 0, i32 22
  store %struct.envelope* %122, %struct.envelope** %e_sibling125, align 8, !tbaa !148
  store i32 0, i32* %i, align 4, !tbaa !5
  br label %for.cond.126

for.cond.126:                                     ; preds = %for.inc.137, %while.end
  %124 = load i32, i32* %i, align 4, !tbaa !5
  %125 = load i32, i32* %nrcpt, align 4, !tbaa !5
  %sub127 = sub nsw i32 %125, 1
  %cmp128 = icmp slt i32 %124, %sub127
  br i1 %cmp128, label %for.body.130, label %for.end.139

for.body.130:                                     ; preds = %for.cond.126
  %126 = load i32, i32* %i, align 4, !tbaa !5
  %add131 = add nsw i32 %126, 1
  %idxprom132 = sext i32 %add131 to i64
  %127 = load %struct.address**, %struct.address*** %addrs, align 8, !tbaa !1
  %arrayidx133 = getelementptr inbounds %struct.address*, %struct.address** %127, i64 %idxprom132
  %128 = load %struct.address*, %struct.address** %arrayidx133, align 8, !tbaa !1
  %129 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom134 = sext i32 %129 to i64
  %130 = load %struct.address**, %struct.address*** %addrs, align 8, !tbaa !1
  %arrayidx135 = getelementptr inbounds %struct.address*, %struct.address** %130, i64 %idxprom134
  %131 = load %struct.address*, %struct.address** %arrayidx135, align 8, !tbaa !1
  %q_next136 = getelementptr inbounds %struct.address, %struct.address* %131, i32 0, i32 10
  store %struct.address* %128, %struct.address** %q_next136, align 8, !tbaa !62
  br label %for.inc.137

for.inc.137:                                      ; preds = %for.body.130
  %132 = load i32, i32* %i, align 4, !tbaa !5
  %inc138 = add nsw i32 %132, 1
  store i32 %inc138, i32* %i, align 4, !tbaa !5
  br label %for.cond.126

for.end.139:                                      ; preds = %for.cond.126
  %133 = load i8*, i8** %lsplits, align 8, !tbaa !1
  %cmp140 = icmp ne i8* %133, null
  br i1 %cmp140, label %if.then.142, label %if.end.143

if.then.142:                                      ; preds = %for.end.139
  %134 = load i8*, i8** %lsplits, align 8, !tbaa !1
  call void @sm_free_tagged(i8* %134, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 8329)
  br label %if.end.143

if.end.143:                                       ; preds = %if.then.142, %for.end.139
  store i32 0, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.144:                                       ; preds = %for.cond.109
  %135 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_sibling145 = getelementptr inbounds %struct.envelope, %struct.envelope* %135, i32 0, i32 22
  %136 = load %struct.envelope*, %struct.envelope** %e_sibling145, align 8, !tbaa !148
  %137 = load %struct.envelope*, %struct.envelope** %ee, align 8, !tbaa !1
  %e_sibling146 = getelementptr inbounds %struct.envelope, %struct.envelope* %137, i32 0, i32 22
  store %struct.envelope* %136, %struct.envelope** %e_sibling146, align 8, !tbaa !148
  %138 = load %struct.envelope*, %struct.envelope** %ee, align 8, !tbaa !1
  %139 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_sibling147 = getelementptr inbounds %struct.envelope, %struct.envelope* %139, i32 0, i32 22
  store %struct.envelope* %138, %struct.envelope** %e_sibling147, align 8, !tbaa !148
  %140 = load i32, i32* %nsplit, align 4, !tbaa !5
  %inc148 = add nsw i32 %140, 1
  store i32 %inc148, i32* %nsplit, align 4, !tbaa !5
  %141 = load i32, i32* @LogLevel, align 4, !tbaa !5
  %cmp149 = icmp sgt i32 %141, 8
  br i1 %cmp149, label %land.lhs.true, label %if.end.199

land.lhs.true:                                    ; preds = %if.end.144
  %142 = load i8*, i8** %lsplits, align 8, !tbaa !1
  %cmp151 = icmp ne i8* %142, null
  br i1 %cmp151, label %if.then.153, label %if.end.199

if.then.153:                                      ; preds = %land.lhs.true
  %143 = load i32, i32* %j, align 4, !tbaa !5
  %conv154 = sext i32 %143 to i64
  %144 = load i32, i32* %l, align 4, !tbaa !5
  %conv155 = sext i32 %144 to i64
  %145 = load %struct.envelope*, %struct.envelope** %ee, align 8, !tbaa !1
  %e_id = getelementptr inbounds %struct.envelope, %struct.envelope* %145, i32 0, i32 25
  %146 = load i8*, i8** %e_id, align 8, !tbaa !7
  %call156 = call i64 @strlen(i8* %146) #14
  %sub157 = sub i64 %conv155, %call156
  %sub158 = sub i64 %sub157, 3
  %cmp159 = icmp uge i64 %conv154, %sub158
  br i1 %cmp159, label %if.then.161, label %if.end.171

if.then.161:                                      ; preds = %if.then.153
  %147 = bitcast i8** %p to i8*
  call void @llvm.lifetime.start(i64 8, i8* %147) #1
  %148 = load i32, i32* %l, align 4, !tbaa !5
  %add163 = add nsw i32 %148, 2048
  store i32 %add163, i32* %l, align 4, !tbaa !5
  %149 = load i8*, i8** %lsplits, align 8, !tbaa !1
  %150 = load i32, i32* %l, align 4, !tbaa !5
  %conv164 = sext i32 %150 to i64
  %call165 = call i8* @sm_realloc(i8* %149, i64 %conv164)
  store i8* %call165, i8** %p, align 8, !tbaa !1
  %151 = load i8*, i8** %p, align 8, !tbaa !1
  %cmp166 = icmp eq i8* %151, null
  br i1 %cmp166, label %if.then.168, label %if.else.169

if.then.168:                                      ; preds = %if.then.161
  %152 = load i8*, i8** %lsplits, align 8, !tbaa !1
  call void @sm_free_tagged(i8* %152, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 8348)
  store i8* null, i8** %lsplits, align 8, !tbaa !1
  br label %if.end.170

if.else.169:                                      ; preds = %if.then.161
  %153 = load i8*, i8** %p, align 8, !tbaa !1
  store i8* %153, i8** %lsplits, align 8, !tbaa !1
  br label %if.end.170

if.end.170:                                       ; preds = %if.else.169, %if.then.168
  %154 = bitcast i8** %p to i8*
  call void @llvm.lifetime.end(i64 8, i8* %154) #1
  br label %if.end.171

if.end.171:                                       ; preds = %if.end.170, %if.then.153
  %155 = load i8*, i8** %lsplits, align 8, !tbaa !1
  %cmp172 = icmp ne i8* %155, null
  br i1 %cmp172, label %if.then.174, label %if.end.198

if.then.174:                                      ; preds = %if.end.171
  %156 = load i32, i32* %j, align 4, !tbaa !5
  %cmp175 = icmp eq i32 %156, 0
  br i1 %cmp175, label %if.then.177, label %if.else.185

if.then.177:                                      ; preds = %if.then.174
  %157 = load i8*, i8** %lsplits, align 8, !tbaa !1
  %158 = load i32, i32* %j, align 4, !tbaa !5
  %idx.ext = sext i32 %158 to i64
  %add.ptr = getelementptr inbounds i8, i8* %157, i64 %idx.ext
  %159 = load %struct.envelope*, %struct.envelope** %ee, align 8, !tbaa !1
  %e_id178 = getelementptr inbounds %struct.envelope, %struct.envelope* %159, i32 0, i32 25
  %160 = load i8*, i8** %e_id178, align 8, !tbaa !7
  %161 = load i32, i32* %l, align 4, !tbaa !5
  %162 = load i32, i32* %j, align 4, !tbaa !5
  %sub179 = sub nsw i32 %161, %162
  %conv180 = sext i32 %sub179 to i64
  %call181 = call i64 @sm_strlcat(i8* %add.ptr, i8* %160, i64 %conv180)
  %163 = load i32, i32* %j, align 4, !tbaa !5
  %conv182 = sext i32 %163 to i64
  %add183 = add i64 %conv182, %call181
  %conv184 = trunc i64 %add183 to i32
  store i32 %conv184, i32* %j, align 4, !tbaa !5
  br label %if.end.195

if.else.185:                                      ; preds = %if.then.174
  %164 = load i8*, i8** %lsplits, align 8, !tbaa !1
  %165 = load i32, i32* %j, align 4, !tbaa !5
  %idx.ext186 = sext i32 %165 to i64
  %add.ptr187 = getelementptr inbounds i8, i8* %164, i64 %idx.ext186
  %166 = load %struct.envelope*, %struct.envelope** %ee, align 8, !tbaa !1
  %e_id188 = getelementptr inbounds %struct.envelope, %struct.envelope* %166, i32 0, i32 25
  %167 = load i8*, i8** %e_id188, align 8, !tbaa !7
  %168 = load i32, i32* %l, align 4, !tbaa !5
  %169 = load i32, i32* %j, align 4, !tbaa !5
  %sub189 = sub nsw i32 %168, %169
  %conv190 = sext i32 %sub189 to i64
  %call191 = call i64 @sm_strlcat2(i8* %add.ptr187, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.181, i32 0, i32 0), i8* %167, i64 %conv190)
  %170 = load i32, i32* %j, align 4, !tbaa !5
  %conv192 = sext i32 %170 to i64
  %add193 = add i64 %conv192, %call191
  %conv194 = trunc i64 %add193 to i32
  store i32 %conv194, i32* %j, align 4, !tbaa !5
  br label %if.end.195

if.end.195:                                       ; preds = %if.else.185, %if.then.177
  %171 = load i32, i32* %j, align 4, !tbaa !5
  %172 = load i32, i32* %l, align 4, !tbaa !5
  %cmp196 = icmp slt i32 %171, %172
  br i1 %cmp196, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.end.195
  call void @sm_abort_at(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 8365, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.182, i32 0, i32 0)) #12
  unreachable
                                                  ; No predecessors!
  br label %lor.end

lor.end:                                          ; preds = %173, %if.end.195
  %174 = phi i1 [ true, %if.end.195 ], [ false, %173 ]
  %lor.ext = zext i1 %174 to i32
  br label %if.end.198

if.end.198:                                       ; preds = %lor.end, %if.end.171
  br label %if.end.199

if.end.199:                                       ; preds = %if.end.198, %land.lhs.true, %if.end.144
  %175 = load i32, i32* %nrcpt, align 4, !tbaa !5
  %176 = load i32, i32* %i, align 4, !tbaa !5
  %sub200 = sub nsw i32 %175, %176
  %177 = load i32, i32* %maxrcpt, align 4, !tbaa !5
  %cmp201 = icmp sle i32 %sub200, %177
  br i1 %cmp201, label %if.then.203, label %if.end.204

if.then.203:                                      ; preds = %if.end.199
  br label %for.end.206

if.end.204:                                       ; preds = %if.end.199
  %178 = load i32, i32* %maxrcpt, align 4, !tbaa !5
  %179 = load i32, i32* %i, align 4, !tbaa !5
  %add205 = add nsw i32 %179, %178
  store i32 %add205, i32* %i, align 4, !tbaa !5
  br label %for.cond.109

for.end.206:                                      ; preds = %if.then.203
  %180 = load i32, i32* @LogLevel, align 4, !tbaa !5
  %cmp207 = icmp sgt i32 %180, 8
  br i1 %cmp207, label %land.lhs.true.209, label %if.end.221

land.lhs.true.209:                                ; preds = %for.end.206
  %181 = load i8*, i8** %lsplits, align 8, !tbaa !1
  %cmp210 = icmp ne i8* %181, null
  br i1 %cmp210, label %if.then.212, label %if.end.221

if.then.212:                                      ; preds = %land.lhs.true.209
  %182 = load i32, i32* %nsplit, align 4, !tbaa !5
  %cmp213 = icmp sgt i32 %182, 0
  br i1 %cmp213, label %if.then.215, label %if.end.220

if.then.215:                                      ; preds = %if.then.212
  %183 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id216 = getelementptr inbounds %struct.envelope, %struct.envelope* %183, i32 0, i32 25
  %184 = load i8*, i8** %e_id216, align 8, !tbaa !7
  %185 = load i32, i32* %maxrcpt, align 4, !tbaa !5
  %186 = load i32, i32* %nrcpt, align 4, !tbaa !5
  %187 = load i32, i32* %ndead, align 4, !tbaa !5
  %sub217 = sub nsw i32 %186, %187
  %188 = load i32, i32* %nsplit, align 4, !tbaa !5
  %189 = load i32, i32* %nsplit, align 4, !tbaa !5
  %cmp218 = icmp sgt i32 %189, 1
  %cond = select i1 %cmp218, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.106, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0)
  %190 = load i8*, i8** %lsplits, align 8, !tbaa !1
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 5, i8* %184, i8* getelementptr inbounds ([48 x i8], [48 x i8]* @.str.310, i32 0, i32 0), i32 %185, i32 %sub217, i32 %188, i8* %cond, i8* %190)
  br label %if.end.220

if.end.220:                                       ; preds = %if.then.215, %if.then.212
  %191 = load i8*, i8** %lsplits, align 8, !tbaa !1
  call void @sm_free_tagged(i8* %191, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 8381)
  br label %if.end.221

if.end.221:                                       ; preds = %if.end.220, %land.lhs.true.209, %for.end.206
  %192 = load i32, i32* %nsplit, align 4, !tbaa !5
  %add222 = add nsw i32 1, %192
  store i32 %add222, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

cleanup:                                          ; preds = %if.end.221, %if.end.143, %if.then.77, %if.then.13, %if.then.4, %if.then
  %193 = bitcast %struct.envelope** %firstsibling to i8*
  call void @llvm.lifetime.end(i64 8, i8* %193) #1
  %194 = bitcast %struct.envelope** %ee to i8*
  call void @llvm.lifetime.end(i64 8, i8* %194) #1
  %195 = bitcast %struct.address*** %addrs to i8*
  call void @llvm.lifetime.end(i64 8, i8* %195) #1
  %196 = bitcast %struct.address** %q to i8*
  call void @llvm.lifetime.end(i64 8, i8* %196) #1
  %197 = bitcast i8** %lsplits to i8*
  call void @llvm.lifetime.end(i64 8, i8* %197) #1
  %198 = bitcast i32* %l to i8*
  call void @llvm.lifetime.end(i64 4, i8* %198) #1
  %199 = bitcast i32* %j to i8*
  call void @llvm.lifetime.end(i64 4, i8* %199) #1
  %200 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end(i64 4, i8* %200) #1
  %201 = bitcast i32* %nsplit to i8*
  call void @llvm.lifetime.end(i64 4, i8* %201) #1
  %202 = bitcast i32* %ndead to i8*
  call void @llvm.lifetime.end(i64 4, i8* %202) #1
  %203 = bitcast i32* %nrcpt to i8*
  call void @llvm.lifetime.end(i64 4, i8* %203) #1
  %204 = bitcast i32* %maxrcpt to i8*
  call void @llvm.lifetime.end(i64 4, i8* %204) #1
  %205 = load i32, i32* %retval
  ret i32 %205
}

declare i64 @sm_strlcat(i8*, i8*, i64) #2

declare i64 @sm_strlcat2(i8*, i8*, i8*, i64) #2

; Function Attrs: nounwind uwtable
define void @quarantine_queue(i8* %reason, i32 %qgrplimit) #0 {
entry:
  %reason.addr = alloca i8*, align 8
  %qgrplimit.addr = alloca i32, align 4
  %changed = alloca i32, align 4
  %qgrp = alloca i32, align 4
  %qdir = alloca i32, align 4
  %cleanup.dest.slot = alloca i32
  %i = alloca i32, align 4
  %nrequests = alloca i32, align 4
  %e = alloca %struct.envelope, align 8
  store i8* %reason, i8** %reason.addr, align 8, !tbaa !1
  store i32 %qgrplimit, i32* %qgrplimit.addr, align 4, !tbaa !5
  %0 = bitcast i32* %changed to i8*
  call void @llvm.lifetime.start(i64 4, i8* %0) #1
  store i32 0, i32* %changed, align 4, !tbaa !5
  %1 = bitcast i32* %qgrp to i8*
  call void @llvm.lifetime.start(i64 4, i8* %1) #1
  %2 = load i8*, i8** %reason.addr, align 8, !tbaa !1
  %cmp = icmp ne i8* %2, null
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %3 = load i8*, i8** %reason.addr, align 8, !tbaa !1
  %arrayidx = getelementptr inbounds i8, i8* %3, i64 0
  %4 = load i8, i8* %arrayidx, align 1, !tbaa !17
  %conv = sext i8 %4 to i32
  %cmp1 = icmp eq i32 %conv, 46
  br i1 %cmp1, label %land.lhs.true.3, label %if.end

land.lhs.true.3:                                  ; preds = %land.lhs.true
  %5 = load i8*, i8** %reason.addr, align 8, !tbaa !1
  %arrayidx4 = getelementptr inbounds i8, i8* %5, i64 1
  %6 = load i8, i8* %arrayidx4, align 1, !tbaa !17
  %conv5 = sext i8 %6 to i32
  %cmp6 = icmp eq i32 %conv5, 0
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true.3
  store i8* null, i8** %reason.addr, align 8, !tbaa !1
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true.3, %land.lhs.true, %entry
  %7 = load i8*, i8** %reason.addr, align 8, !tbaa !1
  %cmp8 = icmp ne i8* %7, null
  br i1 %cmp8, label %if.then.10, label %if.end.12

if.then.10:                                       ; preds = %if.end
  %8 = load i8*, i8** %reason.addr, align 8, !tbaa !1
  %call = call i8* @denlstring(i8* %8, i32 1, i32 1)
  %call11 = call i8* @newstr(i8* %call)
  store i8* %call11, i8** %reason.addr, align 8, !tbaa !1
  br label %if.end.12

if.end.12:                                        ; preds = %if.then.10, %if.end
  store i32 0, i32* %qgrp, align 4, !tbaa !5
  br label %for.cond

for.cond:                                         ; preds = %for.inc.85, %if.end.12
  %9 = load i32, i32* %qgrp, align 4, !tbaa !5
  %10 = load i32, i32* @NumQueue, align 4, !tbaa !5
  %cmp13 = icmp slt i32 %9, %10
  br i1 %cmp13, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %11 = load i32, i32* %qgrp, align 4, !tbaa !5
  %idxprom = sext i32 %11 to i64
  %arrayidx15 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom
  %12 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx15, align 8, !tbaa !1
  %cmp16 = icmp ne %struct.queuegrp* %12, null
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %13 = phi i1 [ false, %for.cond ], [ %cmp16, %land.rhs ]
  br i1 %13, label %for.body, label %for.end.87

for.body:                                         ; preds = %land.end
  %14 = bitcast i32* %qdir to i8*
  call void @llvm.lifetime.start(i64 4, i8* %14) #1
  %15 = load i32, i32* %qgrplimit.addr, align 4, !tbaa !5
  %cmp18 = icmp ne i32 %15, -1
  br i1 %cmp18, label %land.lhs.true.20, label %if.end.24

land.lhs.true.20:                                 ; preds = %for.body
  %16 = load i32, i32* %qgrplimit.addr, align 4, !tbaa !5
  %17 = load i32, i32* %qgrp, align 4, !tbaa !5
  %cmp21 = icmp ne i32 %16, %17
  br i1 %cmp21, label %if.then.23, label %if.end.24

if.then.23:                                       ; preds = %land.lhs.true.20
  store i32 4, i32* %cleanup.dest.slot
  br label %cleanup.82

if.end.24:                                        ; preds = %land.lhs.true.20, %for.body
  store i32 0, i32* %qdir, align 4, !tbaa !5
  br label %for.cond.25

for.cond.25:                                      ; preds = %for.inc.79, %if.end.24
  %18 = load i32, i32* %qdir, align 4, !tbaa !5
  %19 = load i32, i32* %qgrp, align 4, !tbaa !5
  %idxprom26 = sext i32 %19 to i64
  %arrayidx27 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom26
  %20 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx27, align 8, !tbaa !1
  %qg_numqueues = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %20, i32 0, i32 4
  %21 = load i32, i32* %qg_numqueues, align 4, !tbaa !82
  %cmp28 = icmp slt i32 %18, %21
  br i1 %cmp28, label %for.body.30, label %for.end.81

for.body.30:                                      ; preds = %for.cond.25
  %22 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start(i64 4, i8* %22) #1
  %23 = bitcast i32* %nrequests to i8*
  call void @llvm.lifetime.start(i64 4, i8* %23) #1
  %24 = load volatile i32, i32* @StopRequest, align 4, !tbaa !5
  %tobool = icmp ne i32 %24, 0
  br i1 %tobool, label %if.then.31, label %if.end.32

if.then.31:                                       ; preds = %for.body.30
  call void @stop_sendmail()
  br label %if.end.32

if.end.32:                                        ; preds = %if.then.31, %for.body.30
  %25 = load i32, i32* %qgrp, align 4, !tbaa !5
  %26 = load i32, i32* %qdir, align 4, !tbaa !5
  %call33 = call i32 @gatherq(i32 %25, i32 %26, i32 1, i32* null, i32* null, i32* null)
  store i32 %call33, i32* %nrequests, align 4, !tbaa !5
  %27 = load i32, i32* %nrequests, align 4, !tbaa !5
  %cmp34 = icmp sle i32 %27, 0
  br i1 %cmp34, label %if.then.36, label %if.end.42

if.then.36:                                       ; preds = %if.end.32
  %28 = load i32, i32* @Verbose, align 4, !tbaa !5
  %tobool37 = icmp ne i32 %28, 0
  br i1 %tobool37, label %if.then.38, label %if.end.41

if.then.38:                                       ; preds = %if.then.36
  %29 = load i32, i32* %qgrp, align 4, !tbaa !5
  %30 = load i32, i32* %qdir, align 4, !tbaa !5
  %call39 = call i8* @qid_printqueue(i32 %29, i32 %30)
  %call40 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.184, i32 0, i32 0), i8* %call39)
  br label %if.end.41

if.end.41:                                        ; preds = %if.then.38, %if.then.36
  store i32 7, i32* %cleanup.dest.slot
  br label %cleanup

if.end.42:                                        ; preds = %if.end.32
  %31 = load i32, i32* @Verbose, align 4, !tbaa !5
  %tobool43 = icmp ne i32 %31, 0
  br i1 %tobool43, label %if.then.44, label %if.end.47

if.then.44:                                       ; preds = %if.end.42
  %32 = load i32, i32* %qgrp, align 4, !tbaa !5
  %33 = load i32, i32* %qdir, align 4, !tbaa !5
  %call45 = call i8* @qid_printqueue(i32 %32, i32 %33)
  %call46 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.185, i32 0, i32 0), i8* %call45)
  br label %if.end.47

if.end.47:                                        ; preds = %if.then.44, %if.end.42
  store i32 0, i32* %i, align 4, !tbaa !5
  br label %for.cond.48

for.cond.48:                                      ; preds = %for.inc, %if.end.47
  %34 = load i32, i32* %i, align 4, !tbaa !5
  %35 = load i32, i32* @WorkListCount, align 4, !tbaa !5
  %cmp49 = icmp slt i32 %34, %35
  br i1 %cmp49, label %for.body.51, label %for.end

for.body.51:                                      ; preds = %for.cond.48
  %36 = bitcast %struct.envelope* %e to i8*
  call void @llvm.lifetime.start(i64 2656, i8* %36) #1
  %37 = load volatile i32, i32* @StopRequest, align 4, !tbaa !5
  %tobool52 = icmp ne i32 %37, 0
  br i1 %tobool52, label %if.then.53, label %if.end.54

if.then.53:                                       ; preds = %for.body.51
  call void @stop_sendmail()
  br label %if.end.54

if.end.54:                                        ; preds = %if.then.53, %for.body.51
  %call55 = call %struct.SM_RPOOL_T* @sm_rpool_new_x(%struct.SM_RPOOL_T* null)
  call void @clearenvelope(%struct.envelope* %e, i32 1, %struct.SM_RPOOL_T* %call55)
  %38 = load i32, i32* %i, align 4, !tbaa !5
  %idxprom56 = sext i32 %38 to i64
  %39 = load %struct.work*, %struct.work** @WorkList, align 8, !tbaa !1
  %arrayidx57 = getelementptr inbounds %struct.work, %struct.work* %39, i64 %idxprom56
  %w_name = getelementptr inbounds %struct.work, %struct.work* %arrayidx57, i32 0, i32 0
  %40 = load i8*, i8** %w_name, align 8, !tbaa !129
  %add.ptr = getelementptr inbounds i8, i8* %40, i64 2
  %e_id = getelementptr inbounds %struct.envelope, %struct.envelope* %e, i32 0, i32 25
  store i8* %add.ptr, i8** %e_id, align 8, !tbaa !7
  %41 = load i32, i32* %qgrp, align 4, !tbaa !5
  %e_qgrp = getelementptr inbounds %struct.envelope, %struct.envelope* %e, i32 0, i32 26
  store i32 %41, i32* %e_qgrp, align 4, !tbaa !18
  %42 = load i32, i32* %qdir, align 4, !tbaa !5
  %e_qdir = getelementptr inbounds %struct.envelope, %struct.envelope* %e, i32 0, i32 27
  store i32 %42, i32* %e_qdir, align 4, !tbaa !19
  %43 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 70), align 1, !tbaa !17
  %conv58 = zext i8 %43 to i32
  %cmp59 = icmp sge i32 %conv58, 101
  br i1 %cmp59, label %land.lhs.true.61, label %if.else

land.lhs.true.61:                                 ; preds = %if.end.54
  %44 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool62 = icmp ne i32 %44, 0
  br i1 %tobool62, label %if.else, label %if.then.63

if.then.63:                                       ; preds = %land.lhs.true.61
  %e_id64 = getelementptr inbounds %struct.envelope, %struct.envelope* %e, i32 0, i32 25
  %45 = load i8*, i8** %e_id64, align 8, !tbaa !7
  %call65 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.186, i32 0, i32 0), i8* %45)
  %46 = load i32, i32* %changed, align 4, !tbaa !5
  %inc = add nsw i32 %46, 1
  store i32 %inc, i32* %changed, align 4, !tbaa !5
  br label %if.end.71

if.else:                                          ; preds = %land.lhs.true.61, %if.end.54
  %47 = load i32, i32* %qgrp, align 4, !tbaa !5
  %48 = load i32, i32* %qdir, align 4, !tbaa !5
  %49 = load i8*, i8** %reason.addr, align 8, !tbaa !1
  %call66 = call i32 @quarantine_queue_item(i32 %47, i32 %48, %struct.envelope* %e, i8* %49)
  %tobool67 = icmp ne i32 %call66, 0
  br i1 %tobool67, label %if.then.68, label %if.end.70

if.then.68:                                       ; preds = %if.else
  %50 = load i32, i32* %changed, align 4, !tbaa !5
  %inc69 = add nsw i32 %50, 1
  store i32 %inc69, i32* %changed, align 4, !tbaa !5
  br label %if.end.70

if.end.70:                                        ; preds = %if.then.68, %if.else
  br label %if.end.71

if.end.71:                                        ; preds = %if.end.70, %if.then.63
  %e_rpool = getelementptr inbounds %struct.envelope, %struct.envelope* %e, i32 0, i32 52
  %51 = load %struct.SM_RPOOL_T*, %struct.SM_RPOOL_T** %e_rpool, align 8, !tbaa !120
  call void @sm_rpool_free(%struct.SM_RPOOL_T* %51)
  %e_rpool72 = getelementptr inbounds %struct.envelope, %struct.envelope* %e, i32 0, i32 52
  store %struct.SM_RPOOL_T* null, %struct.SM_RPOOL_T** %e_rpool72, align 8, !tbaa !120
  %52 = bitcast %struct.envelope* %e to i8*
  call void @llvm.lifetime.end(i64 2656, i8* %52) #1
  br label %for.inc

for.inc:                                          ; preds = %if.end.71
  %53 = load i32, i32* %i, align 4, !tbaa !5
  %inc73 = add nsw i32 %53, 1
  store i32 %inc73, i32* %i, align 4, !tbaa !5
  br label %for.cond.48

for.end:                                          ; preds = %for.cond.48
  %54 = load %struct.work*, %struct.work** @WorkList, align 8, !tbaa !1
  %cmp74 = icmp ne %struct.work* %54, null
  br i1 %cmp74, label %if.then.76, label %if.end.77

if.then.76:                                       ; preds = %for.end
  %55 = load %struct.work*, %struct.work** @WorkList, align 8, !tbaa !1
  %56 = bitcast %struct.work* %55 to i8*
  call void @sm_free_tagged(i8* %56, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 8940)
  br label %if.end.77

if.end.77:                                        ; preds = %if.then.76, %for.end
  store %struct.work* null, %struct.work** @WorkList, align 8, !tbaa !1
  store i32 0, i32* @WorkListSize, align 4, !tbaa !5
  store i32 0, i32* @WorkListCount, align 4, !tbaa !5
  store i32 0, i32* %cleanup.dest.slot
  br label %cleanup

cleanup:                                          ; preds = %if.end.77, %if.end.41
  %57 = bitcast i32* %nrequests to i8*
  call void @llvm.lifetime.end(i64 4, i8* %57) #1
  %58 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end(i64 4, i8* %58) #1
  %cleanup.dest = load i32, i32* %cleanup.dest.slot
  switch i32 %cleanup.dest, label %unreachable [
    i32 0, label %cleanup.cont
    i32 7, label %for.inc.79
  ]

cleanup.cont:                                     ; preds = %cleanup
  br label %for.inc.79

for.inc.79:                                       ; preds = %cleanup.cont, %cleanup
  %59 = load i32, i32* %qdir, align 4, !tbaa !5
  %inc80 = add nsw i32 %59, 1
  store i32 %inc80, i32* %qdir, align 4, !tbaa !5
  br label %for.cond.25

for.end.81:                                       ; preds = %for.cond.25
  store i32 0, i32* %cleanup.dest.slot
  br label %cleanup.82

cleanup.82:                                       ; preds = %for.end.81, %if.then.23
  %60 = bitcast i32* %qdir to i8*
  call void @llvm.lifetime.end(i64 4, i8* %60) #1
  %cleanup.dest.83 = load i32, i32* %cleanup.dest.slot
  switch i32 %cleanup.dest.83, label %unreachable [
    i32 0, label %cleanup.cont.84
    i32 4, label %for.inc.85
  ]

cleanup.cont.84:                                  ; preds = %cleanup.82
  br label %for.inc.85

for.inc.85:                                       ; preds = %cleanup.cont.84, %cleanup.82
  %61 = load i32, i32* %qgrp, align 4, !tbaa !5
  %inc86 = add nsw i32 %61, 1
  store i32 %inc86, i32* %qgrp, align 4, !tbaa !5
  br label %for.cond

for.end.87:                                       ; preds = %land.end
  %62 = load i32, i32* @Verbose, align 4, !tbaa !5
  %tobool88 = icmp ne i32 %62, 0
  br i1 %tobool88, label %if.then.89, label %if.end.99

if.then.89:                                       ; preds = %for.end.87
  %63 = load i32, i32* %changed, align 4, !tbaa !5
  %cmp90 = icmp eq i32 %63, 0
  br i1 %cmp90, label %if.then.92, label %if.else.94

if.then.92:                                       ; preds = %if.then.89
  %call93 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.187, i32 0, i32 0))
  br label %if.end.98

if.else.94:                                       ; preds = %if.then.89
  %64 = load i32, i32* %changed, align 4, !tbaa !5
  %65 = load i32, i32* %changed, align 4, !tbaa !5
  %cmp95 = icmp eq i32 %65, 1
  %cond = select i1 %cmp95, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0), i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.106, i32 0, i32 0)
  %call97 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.188, i32 0, i32 0), i32 %64, i8* %cond)
  br label %if.end.98

if.end.98:                                        ; preds = %if.else.94, %if.then.92
  br label %if.end.99

if.end.99:                                        ; preds = %if.end.98, %for.end.87
  %66 = bitcast i32* %qgrp to i8*
  call void @llvm.lifetime.end(i64 4, i8* %66) #1
  %67 = bitcast i32* %changed to i8*
  call void @llvm.lifetime.end(i64 4, i8* %67) #1
  ret void

unreachable:                                      ; preds = %cleanup.82, %cleanup
  unreachable
}

; Function Attrs: nounwind uwtable
define internal i32 @quarantine_queue_item(i32 %qgrp, i32 %qdir, %struct.envelope* %e, i8* %reason) #0 {
entry:
  %retval = alloca i32, align 4
  %qgrp.addr = alloca i32, align 4
  %qdir.addr = alloca i32, align 4
  %e.addr = alloca %struct.envelope*, align 8
  %reason.addr = alloca i8*, align 8
  %dirty = alloca i32, align 4
  %failing = alloca i32, align 4
  %foundq = alloca i32, align 4
  %finished = alloca i32, align 4
  %fd = alloca i32, align 4
  %flags = alloca i32, align 4
  %oldtype = alloca i32, align 4
  %newtype = alloca i32, align 4
  %save_errno = alloca i32, align 4
  %oldumask = alloca i32, align 4
  %oldqfp = alloca %struct.sm_file*, align 8
  %tempqfp = alloca %struct.sm_file*, align 8
  %bp = alloca i8*, align 8
  %bufsize = alloca i32, align 4
  %oldqf = alloca [4096 x i8], align 16
  %tempqf = alloca [4096 x i8], align 16
  %newqf = alloca [4096 x i8], align 16
  %buf = alloca [2048 x i8], align 16
  %cleanup.dest.slot = alloca i32
  %__s1_len = alloca i64, align 8
  %__s2_len = alloca i64, align 8
  %tmp = alloca i32, align 4
  store i32 %qgrp, i32* %qgrp.addr, align 4, !tbaa !5
  store i32 %qdir, i32* %qdir.addr, align 4, !tbaa !5
  store %struct.envelope* %e, %struct.envelope** %e.addr, align 8, !tbaa !1
  store i8* %reason, i8** %reason.addr, align 8, !tbaa !1
  %0 = bitcast i32* %dirty to i8*
  call void @llvm.lifetime.start(i64 4, i8* %0) #1
  store i32 0, i32* %dirty, align 4, !tbaa !5
  %1 = bitcast i32* %failing to i8*
  call void @llvm.lifetime.start(i64 4, i8* %1) #1
  store i32 0, i32* %failing, align 4, !tbaa !5
  %2 = bitcast i32* %foundq to i8*
  call void @llvm.lifetime.start(i64 4, i8* %2) #1
  store i32 0, i32* %foundq, align 4, !tbaa !5
  %3 = bitcast i32* %finished to i8*
  call void @llvm.lifetime.start(i64 4, i8* %3) #1
  store i32 0, i32* %finished, align 4, !tbaa !5
  %4 = bitcast i32* %fd to i8*
  call void @llvm.lifetime.start(i64 4, i8* %4) #1
  %5 = bitcast i32* %flags to i8*
  call void @llvm.lifetime.start(i64 4, i8* %5) #1
  %6 = bitcast i32* %oldtype to i8*
  call void @llvm.lifetime.start(i64 4, i8* %6) #1
  %7 = bitcast i32* %newtype to i8*
  call void @llvm.lifetime.start(i64 4, i8* %7) #1
  %8 = bitcast i32* %save_errno to i8*
  call void @llvm.lifetime.start(i64 4, i8* %8) #1
  %9 = bitcast i32* %oldumask to i8*
  call void @llvm.lifetime.start(i64 4, i8* %9) #1
  store i32 0, i32* %oldumask, align 4, !tbaa !5
  %10 = bitcast %struct.sm_file** %oldqfp to i8*
  call void @llvm.lifetime.start(i64 8, i8* %10) #1
  %11 = bitcast %struct.sm_file** %tempqfp to i8*
  call void @llvm.lifetime.start(i64 8, i8* %11) #1
  %12 = bitcast i8** %bp to i8*
  call void @llvm.lifetime.start(i64 8, i8* %12) #1
  %13 = bitcast i32* %bufsize to i8*
  call void @llvm.lifetime.start(i64 4, i8* %13) #1
  %14 = bitcast [4096 x i8]* %oldqf to i8*
  call void @llvm.lifetime.start(i64 4096, i8* %14) #1
  %15 = bitcast [4096 x i8]* %tempqf to i8*
  call void @llvm.lifetime.start(i64 4096, i8* %15) #1
  %16 = bitcast [4096 x i8]* %newqf to i8*
  call void @llvm.lifetime.start(i64 4096, i8* %16) #1
  %17 = bitcast [2048 x i8]* %buf to i8*
  call void @llvm.lifetime.start(i64 2048, i8* %17) #1
  %18 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %call = call signext i8 @queue_letter(%struct.envelope* %18, i32 63)
  %conv = sext i8 %call to i32
  store i32 %conv, i32* %oldtype, align 4, !tbaa !5
  %arraydecay = getelementptr inbounds [4096 x i8], [4096 x i8]* %oldqf, i32 0, i32 0
  %19 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %call1 = call i8* @queuename(%struct.envelope* %19, i32 63)
  %call2 = call i64 @sm_strlcpy(i8* %arraydecay, i8* %call1, i64 4096)
  %arraydecay3 = getelementptr inbounds [4096 x i8], [4096 x i8]* %tempqf, i32 0, i32 0
  %20 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %call4 = call i8* @queuename(%struct.envelope* %20, i32 116)
  %call5 = call i64 @sm_strlcpy(i8* %arraydecay3, i8* %call4, i64 4096)
  %21 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %call6 = call i32 @readqf(%struct.envelope* %21, i32 1)
  %tobool = icmp ne i32 %call6, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %22 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %call7 = call i8* @qid_printname(%struct.envelope* %22)
  %call8 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.311, i32 0, i32 0), i8* %call7)
  store i32 0, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end:                                           ; preds = %entry
  %23 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_lockfp = getelementptr inbounds %struct.envelope, %struct.envelope* %23, i32 0, i32 33
  %24 = load %struct.sm_file*, %struct.sm_file** %e_lockfp, align 8, !tbaa !16
  store %struct.sm_file* %24, %struct.sm_file** %oldqfp, align 8, !tbaa !1
  store i32 193, i32* %flags, align 4, !tbaa !5
  %25 = load i32, i32* @QueueFileMode, align 4, !tbaa !5
  %and = and i32 %25, 16
  %cmp = icmp ne i32 %and, 0
  br i1 %cmp, label %if.then.10, label %if.end.12

if.then.10:                                       ; preds = %if.end
  %call11 = call i32 @umask(i32 2) #1
  store i32 %call11, i32* %oldumask, align 4, !tbaa !5
  br label %if.end.12

if.end.12:                                        ; preds = %if.then.10, %if.end
  %arraydecay13 = getelementptr inbounds [4096 x i8], [4096 x i8]* %tempqf, i32 0, i32 0
  %26 = load i32, i32* %flags, align 4, !tbaa !5
  %27 = load i32, i32* @QueueFileMode, align 4, !tbaa !5
  %call14 = call i32 (i8*, i32, ...) @open(i8* %arraydecay13, i32 %26, i32 %27)
  store i32 %call14, i32* %fd, align 4, !tbaa !5
  %28 = load i32, i32* @QueueFileMode, align 4, !tbaa !5
  %and15 = and i32 %28, 16
  %cmp16 = icmp ne i32 %and15, 0
  br i1 %cmp16, label %if.then.18, label %if.end.20

if.then.18:                                       ; preds = %if.end.12
  %29 = load i32, i32* %oldumask, align 4, !tbaa !5
  %call19 = call i32 @umask(i32 %29) #1
  br label %if.end.20

if.end.20:                                        ; preds = %if.then.18, %if.end.12
  %30 = load i32, i32* %fd, align 4, !tbaa !5
  %cmp21 = icmp slt i32 %30, 0
  br i1 %cmp21, label %if.then.23, label %if.end.30

if.then.23:                                       ; preds = %if.end.20
  %call24 = call i32* @__errno_location() #11
  %31 = load i32, i32* %call24, align 4, !tbaa !5
  store i32 %31, i32* %save_errno, align 4, !tbaa !5
  %32 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %call25 = call i8* @qid_printname(%struct.envelope* %32)
  %arraydecay26 = getelementptr inbounds [4096 x i8], [4096 x i8]* %tempqf, i32 0, i32 0
  %33 = load i32, i32* %save_errno, align 4, !tbaa !5
  %call27 = call i8* @sm_errstring(i32 %33)
  %call28 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.312, i32 0, i32 0), i8* %call25, i8* %arraydecay26, i8* %call27)
  %34 = load %struct.sm_file*, %struct.sm_file** %oldqfp, align 8, !tbaa !1
  %call29 = call i32 @sm_io_close(%struct.sm_file* %34, i32 -2)
  store i32 0, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.30:                                        ; preds = %if.end.20
  %35 = load i32, i32* %fd, align 4, !tbaa !5
  %arraydecay31 = getelementptr inbounds [4096 x i8], [4096 x i8]* %tempqf, i32 0, i32 0
  %call32 = call i32 @lockfile(i32 %35, i8* %arraydecay31, i8* null, i32 6)
  %tobool33 = icmp ne i32 %call32, 0
  br i1 %tobool33, label %if.end.40, label %if.then.34

if.then.34:                                       ; preds = %if.end.30
  %36 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %call35 = call i8* @qid_printname(%struct.envelope* %36)
  %arraydecay36 = getelementptr inbounds [4096 x i8], [4096 x i8]* %tempqf, i32 0, i32 0
  %call37 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.313, i32 0, i32 0), i8* %call35, i8* %arraydecay36)
  %37 = load i32, i32* %fd, align 4, !tbaa !5
  %call38 = call i32 @close(i32 %37)
  %38 = load %struct.sm_file*, %struct.sm_file** %oldqfp, align 8, !tbaa !1
  %call39 = call i32 @sm_io_close(%struct.sm_file* %38, i32 -2)
  store i32 0, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.40:                                        ; preds = %if.end.30
  %39 = bitcast i32* %fd to i8*
  %call41 = call %struct.sm_file* @sm_io_open(%struct.sm_file* @SmFtStdiofd_def, i32 -2, i8* %39, i32 3, i8* null)
  store %struct.sm_file* %call41, %struct.sm_file** %tempqfp, align 8, !tbaa !1
  %40 = load %struct.sm_file*, %struct.sm_file** %tempqfp, align 8, !tbaa !1
  %cmp42 = icmp eq %struct.sm_file* %40, null
  br i1 %cmp42, label %if.then.44, label %if.end.50

if.then.44:                                       ; preds = %if.end.40
  %41 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %call45 = call i8* @qid_printname(%struct.envelope* %41)
  %arraydecay46 = getelementptr inbounds [4096 x i8], [4096 x i8]* %tempqf, i32 0, i32 0
  %call47 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.313, i32 0, i32 0), i8* %call45, i8* %arraydecay46)
  %42 = load i32, i32* %fd, align 4, !tbaa !5
  %call48 = call i32 @close(i32 %42)
  %43 = load %struct.sm_file*, %struct.sm_file** %oldqfp, align 8, !tbaa !1
  %call49 = call i32 @sm_io_close(%struct.sm_file* %43, i32 -2)
  store i32 0, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.50:                                        ; preds = %if.end.40
  br label %while.cond

while.cond:                                       ; preds = %if.end.114, %if.end.50
  store i32 2048, i32* %bufsize, align 4, !tbaa !5
  %arraydecay51 = getelementptr inbounds [2048 x i8], [2048 x i8]* %buf, i32 0, i32 0
  %44 = load %struct.sm_file*, %struct.sm_file** %oldqfp, align 8, !tbaa !1
  %call52 = call i8* @fgetfolded(i8* %arraydecay51, i32* %bufsize, %struct.sm_file* %44)
  store i8* %call52, i8** %bp, align 8, !tbaa !1
  %cmp53 = icmp ne i8* %call52, null
  br i1 %cmp53, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %45 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 40), align 1, !tbaa !17
  %conv55 = zext i8 %45 to i32
  %cmp56 = icmp sge i32 %conv55, 4
  br i1 %cmp56, label %land.lhs.true, label %if.end.60

land.lhs.true:                                    ; preds = %while.body
  %46 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool58 = icmp ne i32 %46, 0
  br i1 %tobool58, label %if.end.60, label %if.then.59

if.then.59:                                       ; preds = %land.lhs.true
  %47 = load i8*, i8** %bp, align 8, !tbaa !1
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.239, i32 0, i32 0), i8* %47)
  br label %if.end.60

if.end.60:                                        ; preds = %if.then.59, %land.lhs.true, %while.body
  %48 = load i8*, i8** %bp, align 8, !tbaa !1
  %arrayidx = getelementptr inbounds i8, i8* %48, i64 0
  %49 = load i8, i8* %arrayidx, align 1, !tbaa !17
  %conv61 = sext i8 %49 to i32
  switch i32 %conv61, label %sw.default [
    i32 113, label %sw.bb
    i32 83, label %sw.bb.93
    i32 46, label %sw.bb.108
  ]

sw.bb:                                            ; preds = %if.end.60
  store i32 1, i32* %foundq, align 4, !tbaa !5
  %50 = load i8*, i8** %reason.addr, align 8, !tbaa !1
  %cmp62 = icmp eq i8* %50, null
  br i1 %cmp62, label %if.then.64, label %if.else

if.then.64:                                       ; preds = %sw.bb
  %51 = load i32, i32* @Verbose, align 4, !tbaa !5
  %tobool65 = icmp ne i32 %51, 0
  br i1 %tobool65, label %if.then.66, label %if.end.69

if.then.66:                                       ; preds = %if.then.64
  %52 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id = getelementptr inbounds %struct.envelope, %struct.envelope* %52, i32 0, i32 25
  %53 = load i8*, i8** %e_id, align 8, !tbaa !7
  %54 = load i8*, i8** %bp, align 8, !tbaa !1
  %arrayidx67 = getelementptr inbounds i8, i8* %54, i64 1
  %call68 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.314, i32 0, i32 0), i8* %53, i8* %arrayidx67)
  br label %if.end.69

if.end.69:                                        ; preds = %if.then.66, %if.then.64
  %55 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id70 = getelementptr inbounds %struct.envelope, %struct.envelope* %55, i32 0, i32 25
  %56 = load i8*, i8** %e_id70, align 8, !tbaa !7
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 6, i8* %56, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.315, i32 0, i32 0))
  store i32 1, i32* %dirty, align 4, !tbaa !5
  br label %if.end.92

if.else:                                          ; preds = %sw.bb
  %57 = bitcast i64* %__s1_len to i8*
  call void @llvm.lifetime.start(i64 8, i8* %57) #1
  %58 = bitcast i64* %__s2_len to i8*
  call void @llvm.lifetime.start(i64 8, i8* %58) #1
  %59 = load i8*, i8** %reason.addr, align 8, !tbaa !1
  %60 = load i8*, i8** %bp, align 8, !tbaa !1
  %arrayidx71 = getelementptr inbounds i8, i8* %60, i64 1
  %call72 = call i32 @strcmp(i8* %59, i8* %arrayidx71) #1
  store i32 %call72, i32* %tmp, !tbaa !5
  %61 = bitcast i64* %__s2_len to i8*
  call void @llvm.lifetime.end(i64 8, i8* %61) #1
  %62 = bitcast i64* %__s1_len to i8*
  call void @llvm.lifetime.end(i64 8, i8* %62) #1
  %63 = load i32, i32* %tmp, !tbaa !5
  %cmp73 = icmp eq i32 %63, 0
  br i1 %cmp73, label %if.then.75, label %if.else.82

if.then.75:                                       ; preds = %if.else
  %64 = load i32, i32* @Verbose, align 4, !tbaa !5
  %tobool76 = icmp ne i32 %64, 0
  br i1 %tobool76, label %if.then.77, label %if.end.80

if.then.77:                                       ; preds = %if.then.75
  %65 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id78 = getelementptr inbounds %struct.envelope, %struct.envelope* %65, i32 0, i32 25
  %66 = load i8*, i8** %e_id78, align 8, !tbaa !7
  %67 = load i8*, i8** %reason.addr, align 8, !tbaa !1
  %call79 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.316, i32 0, i32 0), i8* %66, i8* %67)
  br label %if.end.80

if.end.80:                                        ; preds = %if.then.77, %if.then.75
  %68 = load %struct.sm_file*, %struct.sm_file** %tempqfp, align 8, !tbaa !1
  %69 = load i8*, i8** %reason.addr, align 8, !tbaa !1
  %call81 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* %68, i32 -2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.30, i32 0, i32 0), i8* %69)
  br label %if.end.91

if.else.82:                                       ; preds = %if.else
  %70 = load i32, i32* @Verbose, align 4, !tbaa !5
  %tobool83 = icmp ne i32 %70, 0
  br i1 %tobool83, label %if.then.84, label %if.end.88

if.then.84:                                       ; preds = %if.else.82
  %71 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id85 = getelementptr inbounds %struct.envelope, %struct.envelope* %71, i32 0, i32 25
  %72 = load i8*, i8** %e_id85, align 8, !tbaa !7
  %73 = load i8*, i8** %bp, align 8, !tbaa !1
  %arrayidx86 = getelementptr inbounds i8, i8* %73, i64 1
  %74 = load i8*, i8** %reason.addr, align 8, !tbaa !1
  %call87 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.317, i32 0, i32 0), i8* %72, i8* %arrayidx86, i8* %74)
  br label %if.end.88

if.end.88:                                        ; preds = %if.then.84, %if.else.82
  %75 = load %struct.sm_file*, %struct.sm_file** %tempqfp, align 8, !tbaa !1
  %76 = load i8*, i8** %reason.addr, align 8, !tbaa !1
  %call89 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* %75, i32 -2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.30, i32 0, i32 0), i8* %76)
  %77 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id90 = getelementptr inbounds %struct.envelope, %struct.envelope* %77, i32 0, i32 25
  %78 = load i8*, i8** %e_id90, align 8, !tbaa !7
  %79 = load i8*, i8** %reason.addr, align 8, !tbaa !1
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 6, i8* %78, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.318, i32 0, i32 0), i8* %79)
  store i32 1, i32* %dirty, align 4, !tbaa !5
  br label %if.end.91

if.end.91:                                        ; preds = %if.end.88, %if.end.80
  br label %if.end.92

if.end.92:                                        ; preds = %if.end.91, %if.end.69
  br label %sw.epilog

sw.bb.93:                                         ; preds = %if.end.60
  %80 = load i32, i32* %foundq, align 4, !tbaa !5
  %tobool94 = icmp ne i32 %80, 0
  br i1 %tobool94, label %if.end.106, label %land.lhs.true.95

land.lhs.true.95:                                 ; preds = %sw.bb.93
  %81 = load i8*, i8** %reason.addr, align 8, !tbaa !1
  %cmp96 = icmp ne i8* %81, null
  br i1 %cmp96, label %if.then.98, label %if.end.106

if.then.98:                                       ; preds = %land.lhs.true.95
  %82 = load i32, i32* @Verbose, align 4, !tbaa !5
  %tobool99 = icmp ne i32 %82, 0
  br i1 %tobool99, label %if.then.100, label %if.end.103

if.then.100:                                      ; preds = %if.then.98
  %83 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id101 = getelementptr inbounds %struct.envelope, %struct.envelope* %83, i32 0, i32 25
  %84 = load i8*, i8** %e_id101, align 8, !tbaa !7
  %85 = load i8*, i8** %reason.addr, align 8, !tbaa !1
  %call102 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.319, i32 0, i32 0), i8* %84, i8* %85)
  br label %if.end.103

if.end.103:                                       ; preds = %if.then.100, %if.then.98
  %86 = load %struct.sm_file*, %struct.sm_file** %tempqfp, align 8, !tbaa !1
  %87 = load i8*, i8** %reason.addr, align 8, !tbaa !1
  %call104 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* %86, i32 -2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.30, i32 0, i32 0), i8* %87)
  %88 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id105 = getelementptr inbounds %struct.envelope, %struct.envelope* %88, i32 0, i32 25
  %89 = load i8*, i8** %e_id105, align 8, !tbaa !7
  %90 = load i8*, i8** %reason.addr, align 8, !tbaa !1
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 6, i8* %89, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.318, i32 0, i32 0), i8* %90)
  store i32 1, i32* %foundq, align 4, !tbaa !5
  store i32 1, i32* %dirty, align 4, !tbaa !5
  br label %if.end.106

if.end.106:                                       ; preds = %if.end.103, %land.lhs.true.95, %sw.bb.93
  %91 = load %struct.sm_file*, %struct.sm_file** %tempqfp, align 8, !tbaa !1
  %92 = load i8*, i8** %bp, align 8, !tbaa !1
  %call107 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* %91, i32 -2, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.40, i32 0, i32 0), i8* %92)
  br label %sw.epilog

sw.bb.108:                                        ; preds = %if.end.60
  store i32 1, i32* %finished, align 4, !tbaa !5
  br label %sw.default

sw.default:                                       ; preds = %if.end.60, %sw.bb.108
  %93 = load %struct.sm_file*, %struct.sm_file** %tempqfp, align 8, !tbaa !1
  %94 = load i8*, i8** %bp, align 8, !tbaa !1
  %call109 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* %93, i32 -2, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.40, i32 0, i32 0), i8* %94)
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.end.106, %if.end.92
  %95 = load i8*, i8** %bp, align 8, !tbaa !1
  %arraydecay110 = getelementptr inbounds [2048 x i8], [2048 x i8]* %buf, i32 0, i32 0
  %cmp111 = icmp ne i8* %95, %arraydecay110
  br i1 %cmp111, label %if.then.113, label %if.end.114

if.then.113:                                      ; preds = %sw.epilog
  %96 = load i8*, i8** %bp, align 8, !tbaa !1
  call void @sm_free_tagged(i8* %96, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 8678)
  br label %if.end.114

if.end.114:                                       ; preds = %if.then.113, %sw.epilog
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %97 = load %struct.sm_file*, %struct.sm_file** %tempqfp, align 8, !tbaa !1
  %f_flags = getelementptr inbounds %struct.sm_file, %struct.sm_file* %97, i32 0, i32 4
  %98 = load i64, i64* %f_flags, align 8, !tbaa !76
  %and115 = and i64 %98, 256
  %cmp116 = icmp ne i64 %and115, 0
  %conv117 = zext i1 %cmp116 to i32
  %call118 = call i32* @__errno_location() #11
  store i32 %conv117, i32* %call118, align 4, !tbaa !5
  %call119 = call i32* @__errno_location() #11
  %99 = load i32, i32* %call119, align 4, !tbaa !5
  %cmp120 = icmp ne i32 %99, 0
  br i1 %cmp120, label %land.lhs.true.122, label %if.end.132

land.lhs.true.122:                                ; preds = %while.end
  %call123 = call i32* @__errno_location() #11
  %100 = load i32, i32* %call123, align 4, !tbaa !5
  %cmp124 = icmp ne i32 %100, -1
  br i1 %cmp124, label %if.then.126, label %if.end.132

if.then.126:                                      ; preds = %land.lhs.true.122
  %call127 = call i32* @__errno_location() #11
  %101 = load i32, i32* %call127, align 4, !tbaa !5
  store i32 %101, i32* %save_errno, align 4, !tbaa !5
  %102 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %call128 = call i8* @qid_printname(%struct.envelope* %102)
  %arraydecay129 = getelementptr inbounds [4096 x i8], [4096 x i8]* %oldqf, i32 0, i32 0
  %103 = load i32, i32* %save_errno, align 4, !tbaa !5
  %call130 = call i8* @sm_errstring(i32 %103)
  %call131 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.320, i32 0, i32 0), i8* %call128, i8* %arraydecay129, i8* %call130)
  store i32 1, i32* %failing, align 4, !tbaa !5
  br label %if.end.132

if.end.132:                                       ; preds = %if.then.126, %land.lhs.true.122, %while.end
  %104 = load i32, i32* %failing, align 4, !tbaa !5
  %tobool133 = icmp ne i32 %104, 0
  br i1 %tobool133, label %if.end.140, label %land.lhs.true.134

land.lhs.true.134:                                ; preds = %if.end.132
  %105 = load i32, i32* %finished, align 4, !tbaa !5
  %tobool135 = icmp ne i32 %105, 0
  br i1 %tobool135, label %if.end.140, label %if.then.136

if.then.136:                                      ; preds = %land.lhs.true.134
  %106 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %call137 = call i8* @qid_printname(%struct.envelope* %106)
  %arraydecay138 = getelementptr inbounds [4096 x i8], [4096 x i8]* %oldqf, i32 0, i32 0
  %call139 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.321, i32 0, i32 0), i8* %call137, i8* %arraydecay138)
  store i32 1, i32* %failing, align 4, !tbaa !5
  br label %if.end.140

if.end.140:                                       ; preds = %if.then.136, %land.lhs.true.134, %if.end.132
  %107 = load i32, i32* %dirty, align 4, !tbaa !5
  %tobool141 = icmp ne i32 %107, 0
  br i1 %tobool141, label %if.end.143, label %if.then.142

if.then.142:                                      ; preds = %if.end.140
  store i32 1, i32* %failing, align 4, !tbaa !5
  br label %if.end.143

if.end.143:                                       ; preds = %if.then.142, %if.end.140
  %108 = load i32, i32* %failing, align 4, !tbaa !5
  %tobool144 = icmp ne i32 %108, 0
  br i1 %tobool144, label %if.end.176, label %land.lhs.true.145

land.lhs.true.145:                                ; preds = %if.end.143
  %109 = load %struct.sm_file*, %struct.sm_file** %tempqfp, align 8, !tbaa !1
  %call146 = call i32 @sm_io_flush(%struct.sm_file* %109, i32 -2)
  %cmp147 = icmp ne i32 %call146, 0
  br i1 %cmp147, label %if.then.170, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true.145
  %110 = load i32, i32* @SuperSafe, align 4, !tbaa !5
  %cmp149 = icmp eq i32 %110, 2
  br i1 %cmp149, label %land.lhs.true.157, label %lor.lhs.false.151

lor.lhs.false.151:                                ; preds = %lor.lhs.false
  %111 = load i32, i32* @SuperSafe, align 4, !tbaa !5
  %cmp152 = icmp eq i32 %111, 3
  br i1 %cmp152, label %land.lhs.true.157, label %lor.lhs.false.154

lor.lhs.false.154:                                ; preds = %lor.lhs.false.151
  %112 = load i32, i32* @SuperSafe, align 4, !tbaa !5
  %cmp155 = icmp eq i32 %112, 1
  br i1 %cmp155, label %land.lhs.true.157, label %lor.lhs.false.162

land.lhs.true.157:                                ; preds = %lor.lhs.false.154, %lor.lhs.false.151, %lor.lhs.false
  %113 = load %struct.sm_file*, %struct.sm_file** %tempqfp, align 8, !tbaa !1
  %call158 = call i32 @sm_io_getinfo(%struct.sm_file* %113, i32 3, i8* null)
  %call159 = call i32 @fsync(i32 %call158)
  %cmp160 = icmp slt i32 %call159, 0
  br i1 %cmp160, label %if.then.170, label %lor.lhs.false.162

lor.lhs.false.162:                                ; preds = %land.lhs.true.157, %lor.lhs.false.154
  %114 = load %struct.sm_file*, %struct.sm_file** %tempqfp, align 8, !tbaa !1
  %f_flags163 = getelementptr inbounds %struct.sm_file, %struct.sm_file* %114, i32 0, i32 4
  %115 = load i64, i64* %f_flags163, align 8, !tbaa !76
  %and164 = and i64 %115, 256
  %cmp165 = icmp ne i64 %and164, 0
  %conv166 = zext i1 %cmp165 to i32
  %call167 = call i32* @__errno_location() #11
  store i32 %conv166, i32* %call167, align 4, !tbaa !5
  %cmp168 = icmp ne i32 %conv166, 0
  br i1 %cmp168, label %if.then.170, label %if.end.176

if.then.170:                                      ; preds = %lor.lhs.false.162, %land.lhs.true.157, %land.lhs.true.145
  %call171 = call i32* @__errno_location() #11
  %116 = load i32, i32* %call171, align 4, !tbaa !5
  store i32 %116, i32* %save_errno, align 4, !tbaa !5
  %117 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %call172 = call i8* @qid_printname(%struct.envelope* %117)
  %arraydecay173 = getelementptr inbounds [4096 x i8], [4096 x i8]* %tempqf, i32 0, i32 0
  %118 = load i32, i32* %save_errno, align 4, !tbaa !5
  %call174 = call i8* @sm_errstring(i32 %118)
  %call175 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.322, i32 0, i32 0), i8* %call172, i8* %arraydecay173, i8* %call174)
  store i32 1, i32* %failing, align 4, !tbaa !5
  br label %if.end.176

if.end.176:                                       ; preds = %if.then.170, %lor.lhs.false.162, %if.end.143
  %119 = load i8*, i8** %reason.addr, align 8, !tbaa !1
  %cmp177 = icmp eq i8* %119, null
  %cond = select i1 %cmp177, i32 113, i32 104
  store i32 %cond, i32* %newtype, align 4, !tbaa !5
  %120 = load i32, i32* %oldtype, align 4, !tbaa !5
  %121 = load i32, i32* %newtype, align 4, !tbaa !5
  %cmp179 = icmp eq i32 %120, %121
  br i1 %cmp179, label %if.then.181, label %if.else.185

if.then.181:                                      ; preds = %if.end.176
  %arraydecay182 = getelementptr inbounds [4096 x i8], [4096 x i8]* %newqf, i32 0, i32 0
  %arraydecay183 = getelementptr inbounds [4096 x i8], [4096 x i8]* %oldqf, i32 0, i32 0
  %call184 = call i64 @sm_strlcpy(i8* %arraydecay182, i8* %arraydecay183, i64 4096)
  br label %if.end.189

if.else.185:                                      ; preds = %if.end.176
  %arraydecay186 = getelementptr inbounds [4096 x i8], [4096 x i8]* %newqf, i32 0, i32 0
  %122 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %123 = load i32, i32* %newtype, align 4, !tbaa !5
  %call187 = call i8* @queuename(%struct.envelope* %122, i32 %123)
  %call188 = call i64 @sm_strlcpy(i8* %arraydecay186, i8* %call187, i64 4096)
  br label %if.end.189

if.end.189:                                       ; preds = %if.else.185, %if.then.181
  store i32 0, i32* %save_errno, align 4, !tbaa !5
  %124 = load i32, i32* %failing, align 4, !tbaa !5
  %tobool190 = icmp ne i32 %124, 0
  br i1 %tobool190, label %if.end.203, label %land.lhs.true.191

land.lhs.true.191:                                ; preds = %if.end.189
  %arraydecay192 = getelementptr inbounds [4096 x i8], [4096 x i8]* %tempqf, i32 0, i32 0
  %arraydecay193 = getelementptr inbounds [4096 x i8], [4096 x i8]* %newqf, i32 0, i32 0
  %call194 = call i32 @rename(i8* %arraydecay192, i8* %arraydecay193) #1
  %cmp195 = icmp slt i32 %call194, 0
  br i1 %cmp195, label %if.then.197, label %if.end.203

if.then.197:                                      ; preds = %land.lhs.true.191
  %call198 = call i32* @__errno_location() #11
  %125 = load i32, i32* %call198, align 4, !tbaa !5
  %cmp199 = icmp eq i32 %125, 0
  br i1 %cmp199, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.197
  br label %cond.end

cond.false:                                       ; preds = %if.then.197
  %call201 = call i32* @__errno_location() #11
  %126 = load i32, i32* %call201, align 4, !tbaa !5
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond202 = phi i32 [ 22, %cond.true ], [ %126, %cond.false ]
  store i32 %cond202, i32* %save_errno, align 4, !tbaa !5
  br label %if.end.203

if.end.203:                                       ; preds = %cond.end, %land.lhs.true.191, %if.end.189
  %127 = load i32, i32* %failing, align 4, !tbaa !5
  %tobool204 = icmp ne i32 %127, 0
  br i1 %tobool204, label %if.end.234, label %land.lhs.true.205

land.lhs.true.205:                                ; preds = %if.end.203
  %128 = load i32, i32* %save_errno, align 4, !tbaa !5
  %cmp206 = icmp ne i32 %128, 0
  br i1 %cmp206, label %if.then.208, label %if.end.234

if.then.208:                                      ; preds = %land.lhs.true.205
  %129 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_id209 = getelementptr inbounds %struct.envelope, %struct.envelope* %129, i32 0, i32 25
  %130 = load i8*, i8** %e_id209, align 8, !tbaa !7
  %arraydecay210 = getelementptr inbounds [4096 x i8], [4096 x i8]* %tempqf, i32 0, i32 0
  %arraydecay211 = getelementptr inbounds [4096 x i8], [4096 x i8]* %newqf, i32 0, i32 0
  %131 = load i32, i32* %save_errno, align 4, !tbaa !5
  %call212 = call i8* @sm_errstring(i32 %131)
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 7, i8* %130, i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.323, i32 0, i32 0), i8* %arraydecay210, i8* %arraydecay211, i8* %call212)
  %arraydecay213 = getelementptr inbounds [4096 x i8], [4096 x i8]* %tempqf, i32 0, i32 0
  %arraydecay214 = getelementptr inbounds [4096 x i8], [4096 x i8]* %newqf, i32 0, i32 0
  %132 = load i32, i32* %save_errno, align 4, !tbaa !5
  %call215 = call i8* @sm_errstring(i32 %132)
  %call216 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.324, i32 0, i32 0), i8* %arraydecay213, i8* %arraydecay214, i8* %call215)
  %133 = load i32, i32* %oldtype, align 4, !tbaa !5
  %134 = load i32, i32* %newtype, align 4, !tbaa !5
  %cmp217 = icmp eq i32 %133, %134
  br i1 %cmp217, label %if.then.219, label %if.else.222

if.then.219:                                      ; preds = %if.then.208
  %135 = load i32, i32* %save_errno, align 4, !tbaa !5
  %call220 = call i32* @__errno_location() #11
  store i32 %135, i32* %call220, align 4, !tbaa !5
  %arraydecay221 = getelementptr inbounds [4096 x i8], [4096 x i8]* %tempqf, i32 0, i32 0
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.325, i32 0, i32 0), i8* %arraydecay221)
  br label %if.end.233

if.else.222:                                      ; preds = %if.then.208
  %arraydecay223 = getelementptr inbounds [4096 x i8], [4096 x i8]* %newqf, i32 0, i32 0
  %call224 = call i32 @xunlink(i8* %arraydecay223)
  %cmp225 = icmp slt i32 %call224, 0
  br i1 %cmp225, label %if.then.227, label %if.end.232

if.then.227:                                      ; preds = %if.else.222
  %call228 = call i32* @__errno_location() #11
  %136 = load i32, i32* %call228, align 4, !tbaa !5
  store i32 %136, i32* %save_errno, align 4, !tbaa !5
  %arraydecay229 = getelementptr inbounds [4096 x i8], [4096 x i8]* %newqf, i32 0, i32 0
  %137 = load i32, i32* %save_errno, align 4, !tbaa !5
  %call230 = call i8* @sm_errstring(i32 %137)
  %call231 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.326, i32 0, i32 0), i8* %arraydecay229, i8* %call230)
  br label %if.end.232

if.end.232:                                       ; preds = %if.then.227, %if.else.222
  store i32 1, i32* %failing, align 4, !tbaa !5
  br label %if.end.233

if.end.233:                                       ; preds = %if.end.232, %if.then.219
  br label %if.end.234

if.end.234:                                       ; preds = %if.end.233, %land.lhs.true.205, %if.end.203
  %138 = load i32, i32* %failing, align 4, !tbaa !5
  %tobool235 = icmp ne i32 %138, 0
  br i1 %tobool235, label %if.end.250, label %land.lhs.true.236

land.lhs.true.236:                                ; preds = %if.end.234
  %139 = load i32, i32* %oldtype, align 4, !tbaa !5
  %140 = load i32, i32* %newtype, align 4, !tbaa !5
  %cmp237 = icmp ne i32 %139, %140
  br i1 %cmp237, label %if.then.239, label %if.end.250

if.then.239:                                      ; preds = %land.lhs.true.236
  %arraydecay240 = getelementptr inbounds [4096 x i8], [4096 x i8]* %oldqf, i32 0, i32 0
  %call241 = call i32 @xunlink(i8* %arraydecay240)
  %cmp242 = icmp slt i32 %call241, 0
  br i1 %cmp242, label %if.then.244, label %if.end.249

if.then.244:                                      ; preds = %if.then.239
  %call245 = call i32* @__errno_location() #11
  %141 = load i32, i32* %call245, align 4, !tbaa !5
  store i32 %141, i32* %save_errno, align 4, !tbaa !5
  %arraydecay246 = getelementptr inbounds [4096 x i8], [4096 x i8]* %oldqf, i32 0, i32 0
  %142 = load i32, i32* %save_errno, align 4, !tbaa !5
  %call247 = call i8* @sm_errstring(i32 %142)
  %call248 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* getelementptr inbounds ([0 x %struct.sm_file], [0 x %struct.sm_file]* @SmIoF, i32 0, i64 1), i32 -2, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.326, i32 0, i32 0), i8* %arraydecay246, i8* %call247)
  br label %if.end.249

if.end.249:                                       ; preds = %if.then.244, %if.then.239
  br label %if.end.250

if.end.250:                                       ; preds = %if.end.249, %land.lhs.true.236, %if.end.234
  %143 = load i32, i32* %failing, align 4, !tbaa !5
  %tobool251 = icmp ne i32 %143, 0
  br i1 %tobool251, label %if.then.252, label %if.end.255

if.then.252:                                      ; preds = %if.end.250
  %arraydecay253 = getelementptr inbounds [4096 x i8], [4096 x i8]* %tempqf, i32 0, i32 0
  %call254 = call i32 @xunlink(i8* %arraydecay253)
  br label %if.end.255

if.end.255:                                       ; preds = %if.then.252, %if.end.250
  %144 = load i32, i32* @SuperSafe, align 4, !tbaa !5
  %cmp256 = icmp ne i32 %144, 0
  br i1 %cmp256, label %if.then.258, label %if.end.267

if.then.258:                                      ; preds = %if.end.255
  %145 = load %struct.sm_file*, %struct.sm_file** %tempqfp, align 8, !tbaa !1
  %call259 = call i32 @sm_io_getinfo(%struct.sm_file* %145, i32 3, i8* null)
  %call260 = call i32 @fsync(i32 %call259)
  %146 = load i32, i32* %failing, align 4, !tbaa !5
  %tobool261 = icmp ne i32 %146, 0
  br i1 %tobool261, label %if.end.265, label %if.then.262

if.then.262:                                      ; preds = %if.then.258
  %147 = load %struct.sm_file*, %struct.sm_file** %oldqfp, align 8, !tbaa !1
  %call263 = call i32 @sm_io_getinfo(%struct.sm_file* %147, i32 3, i8* null)
  %call264 = call i32 @fsync(i32 %call263)
  br label %if.end.265

if.end.265:                                       ; preds = %if.then.262, %if.then.258
  %arraydecay266 = getelementptr inbounds [4096 x i8], [4096 x i8]* %tempqf, i32 0, i32 0
  call void @sync_dir(i8* %arraydecay266, i32 0)
  br label %if.end.267

if.end.267:                                       ; preds = %if.end.265, %if.end.255
  %148 = load %struct.sm_file*, %struct.sm_file** %tempqfp, align 8, !tbaa !1
  %cmp268 = icmp ne %struct.sm_file* %148, null
  br i1 %cmp268, label %if.then.270, label %if.end.272

if.then.270:                                      ; preds = %if.end.267
  %149 = load %struct.sm_file*, %struct.sm_file** %tempqfp, align 8, !tbaa !1
  %call271 = call i32 @sm_io_close(%struct.sm_file* %149, i32 -2)
  br label %if.end.272

if.end.272:                                       ; preds = %if.then.270, %if.end.267
  %150 = load %struct.sm_file*, %struct.sm_file** %oldqfp, align 8, !tbaa !1
  %cmp273 = icmp ne %struct.sm_file* %150, null
  br i1 %cmp273, label %if.then.275, label %if.end.277

if.then.275:                                      ; preds = %if.end.272
  %151 = load %struct.sm_file*, %struct.sm_file** %oldqfp, align 8, !tbaa !1
  %call276 = call i32 @sm_io_close(%struct.sm_file* %151, i32 -2)
  br label %if.end.277

if.end.277:                                       ; preds = %if.then.275, %if.end.272
  %152 = load i32, i32* %failing, align 4, !tbaa !5
  %tobool278 = icmp ne i32 %152, 0
  %lnot = xor i1 %tobool278, true
  %lnot.ext = zext i1 %lnot to i32
  store i32 %lnot.ext, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

cleanup:                                          ; preds = %if.end.277, %if.then.44, %if.then.34, %if.then.23, %if.then
  %153 = bitcast [2048 x i8]* %buf to i8*
  call void @llvm.lifetime.end(i64 2048, i8* %153) #1
  %154 = bitcast [4096 x i8]* %newqf to i8*
  call void @llvm.lifetime.end(i64 4096, i8* %154) #1
  %155 = bitcast [4096 x i8]* %tempqf to i8*
  call void @llvm.lifetime.end(i64 4096, i8* %155) #1
  %156 = bitcast [4096 x i8]* %oldqf to i8*
  call void @llvm.lifetime.end(i64 4096, i8* %156) #1
  %157 = bitcast i32* %bufsize to i8*
  call void @llvm.lifetime.end(i64 4, i8* %157) #1
  %158 = bitcast i8** %bp to i8*
  call void @llvm.lifetime.end(i64 8, i8* %158) #1
  %159 = bitcast %struct.sm_file** %tempqfp to i8*
  call void @llvm.lifetime.end(i64 8, i8* %159) #1
  %160 = bitcast %struct.sm_file** %oldqfp to i8*
  call void @llvm.lifetime.end(i64 8, i8* %160) #1
  %161 = bitcast i32* %oldumask to i8*
  call void @llvm.lifetime.end(i64 4, i8* %161) #1
  %162 = bitcast i32* %save_errno to i8*
  call void @llvm.lifetime.end(i64 4, i8* %162) #1
  %163 = bitcast i32* %newtype to i8*
  call void @llvm.lifetime.end(i64 4, i8* %163) #1
  %164 = bitcast i32* %oldtype to i8*
  call void @llvm.lifetime.end(i64 4, i8* %164) #1
  %165 = bitcast i32* %flags to i8*
  call void @llvm.lifetime.end(i64 4, i8* %165) #1
  %166 = bitcast i32* %fd to i8*
  call void @llvm.lifetime.end(i64 4, i8* %166) #1
  %167 = bitcast i32* %finished to i8*
  call void @llvm.lifetime.end(i64 4, i8* %167) #1
  %168 = bitcast i32* %foundq to i8*
  call void @llvm.lifetime.end(i64 4, i8* %168) #1
  %169 = bitcast i32* %failing to i8*
  call void @llvm.lifetime.end(i64 4, i8* %169) #1
  %170 = bitcast i32* %dirty to i8*
  call void @llvm.lifetime.end(i64 4, i8* %170) #1
  %171 = load i32, i32* %retval
  ret i32 %171
}

; Function Attrs: nounwind
declare i32 @__fxstat(i32, i32, %struct.stat*) #3

declare %struct.address* @getctladdr(%struct.address*) #2

declare void @pend_signal(i32) #2

declare void @proc_list_signal(i32, i32) #2

; Function Attrs: nounwind
declare i32 @getppid() #3

declare %struct.sm_event* @sm_seteventm(i32, void (i32)*, i32) #2

declare %struct.__dirstream* @opendir(i8*) #2

declare %struct.dirent* @readdir(%struct.__dirstream*) #2

declare i32 @strcontainedin(i32, i8*, i8*) #2

; Function Attrs: nounwind uwtable
define internal void @grow_wlist(i32 %qgrp, i32 %qdir) #0 {
entry:
  %qgrp.addr = alloca i32, align 4
  %qdir.addr = alloca i32, align 4
  %newsize = alloca i32, align 4
  %newlist = alloca %struct.work*, align 8
  store i32 %qgrp, i32* %qgrp.addr, align 4, !tbaa !5
  store i32 %qdir, i32* %qdir.addr, align 4, !tbaa !5
  %0 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 41), align 1, !tbaa !17
  %conv = zext i8 %0 to i32
  %cmp = icmp sge i32 %conv, 1
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %2 = load i32, i32* @WorkListSize, align 4, !tbaa !5
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.221, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %3 = load %struct.work*, %struct.work** @WorkList, align 8, !tbaa !1
  %cmp2 = icmp eq %struct.work* %3, null
  br i1 %cmp2, label %if.then.4, label %if.else

if.then.4:                                        ; preds = %if.end
  %call = call i8* @xalloc_tagged(i32 64064, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 3173)
  %4 = bitcast i8* %call to %struct.work*
  store %struct.work* %4, %struct.work** @WorkList, align 8, !tbaa !1
  store i32 1000, i32* @WorkListSize, align 4, !tbaa !5
  br label %if.end.23

if.else:                                          ; preds = %if.end
  %5 = bitcast i32* %newsize to i8*
  call void @llvm.lifetime.start(i64 4, i8* %5) #1
  %6 = load i32, i32* @WorkListSize, align 4, !tbaa !5
  %add = add nsw i32 %6, 1000
  store i32 %add, i32* %newsize, align 4, !tbaa !5
  %7 = bitcast %struct.work** %newlist to i8*
  call void @llvm.lifetime.start(i64 8, i8* %7) #1
  %8 = load %struct.work*, %struct.work** @WorkList, align 8, !tbaa !1
  %9 = bitcast %struct.work* %8 to i8*
  %10 = load i32, i32* %newsize, align 4, !tbaa !5
  %add5 = add nsw i32 %10, 1
  %mul = mul i32 64, %add5
  %conv6 = zext i32 %mul to i64
  %call7 = call i8* @sm_realloc(i8* %9, i64 %conv6)
  %11 = bitcast i8* %call7 to %struct.work*
  store %struct.work* %11, %struct.work** %newlist, align 8, !tbaa !1
  %12 = load %struct.work*, %struct.work** %newlist, align 8, !tbaa !1
  %cmp8 = icmp ne %struct.work* %12, null
  br i1 %cmp8, label %if.then.10, label %if.else.16

if.then.10:                                       ; preds = %if.else
  %13 = load i32, i32* %newsize, align 4, !tbaa !5
  store i32 %13, i32* @WorkListSize, align 4, !tbaa !5
  %14 = load %struct.work*, %struct.work** %newlist, align 8, !tbaa !1
  store %struct.work* %14, %struct.work** @WorkList, align 8, !tbaa !1
  %15 = load i32, i32* @LogLevel, align 4, !tbaa !5
  %cmp11 = icmp sgt i32 %15, 1
  br i1 %cmp11, label %if.then.13, label %if.end.15

if.then.13:                                       ; preds = %if.then.10
  %16 = load i32, i32* %qgrp.addr, align 4, !tbaa !5
  %17 = load i32, i32* %qdir.addr, align 4, !tbaa !5
  %call14 = call i8* @qid_printqueue(i32 %16, i32 %17)
  %18 = load i32, i32* @WorkListSize, align 4, !tbaa !5
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 6, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0), i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.222, i32 0, i32 0), i8* %call14, i32 %18)
  br label %if.end.15

if.end.15:                                        ; preds = %if.then.13, %if.then.10
  br label %if.end.22

if.else.16:                                       ; preds = %if.else
  %19 = load i32, i32* @LogLevel, align 4, !tbaa !5
  %cmp17 = icmp sgt i32 %19, 0
  br i1 %cmp17, label %if.then.19, label %if.end.21

if.then.19:                                       ; preds = %if.else.16
  %20 = load i32, i32* %qgrp.addr, align 4, !tbaa !5
  %21 = load i32, i32* %qdir.addr, align 4, !tbaa !5
  %call20 = call i8* @qid_printqueue(i32 %20, i32 %21)
  %22 = load i32, i32* %newsize, align 4, !tbaa !5
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 1, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0), i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.223, i32 0, i32 0), i8* %call20, i32 %22)
  br label %if.end.21

if.end.21:                                        ; preds = %if.then.19, %if.else.16
  br label %if.end.22

if.end.22:                                        ; preds = %if.end.21, %if.end.15
  %23 = bitcast %struct.work** %newlist to i8*
  call void @llvm.lifetime.end(i64 8, i8* %23) #1
  %24 = bitcast i32* %newsize to i8*
  call void @llvm.lifetime.end(i64 4, i8* %24) #1
  br label %if.end.23

if.end.23:                                        ; preds = %if.end.22, %if.then.4
  %25 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 41), align 1, !tbaa !17
  %conv24 = zext i8 %25 to i32
  %cmp25 = icmp sge i32 %conv24, 1
  br i1 %cmp25, label %land.lhs.true.27, label %if.end.30

land.lhs.true.27:                                 ; preds = %if.end.23
  %26 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool28 = icmp ne i32 %26, 0
  br i1 %tobool28, label %if.end.30, label %if.then.29

if.then.29:                                       ; preds = %land.lhs.true.27
  %27 = load i32, i32* @WorkListSize, align 4, !tbaa !5
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.224, i32 0, i32 0), i32 %27)
  br label %if.end.30

if.end.30:                                        ; preds = %if.then.29, %land.lhs.true.27, %if.end.23
  ret void
}

declare i32 @sm_io_getc(%struct.sm_file*, i32) #2

; Function Attrs: nounwind uwtable
define internal i8* @strrev(i8* %fwd) #0 {
entry:
  %fwd.addr = alloca i8*, align 8
  %rev = alloca i8*, align 8
  %len = alloca i32, align 4
  %cnt = alloca i32, align 4
  store i8* %fwd, i8** %fwd.addr, align 8, !tbaa !1
  %0 = bitcast i8** %rev to i8*
  call void @llvm.lifetime.start(i64 8, i8* %0) #1
  store i8* null, i8** %rev, align 8, !tbaa !1
  %1 = bitcast i32* %len to i8*
  call void @llvm.lifetime.start(i64 4, i8* %1) #1
  %2 = bitcast i32* %cnt to i8*
  call void @llvm.lifetime.start(i64 4, i8* %2) #1
  %3 = load i8*, i8** %fwd.addr, align 8, !tbaa !1
  %call = call i64 @strlen(i8* %3) #14
  %conv = trunc i64 %call to i32
  store i32 %conv, i32* %len, align 4, !tbaa !5
  %4 = load i32, i32* %len, align 4, !tbaa !5
  %add = add nsw i32 %4, 1
  %call1 = call i8* @xalloc_tagged(i32 %add, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 3468)
  store i8* %call1, i8** %rev, align 8, !tbaa !1
  store i32 0, i32* %cnt, align 4, !tbaa !5
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %5 = load i32, i32* %cnt, align 4, !tbaa !5
  %6 = load i32, i32* %len, align 4, !tbaa !5
  %cmp = icmp slt i32 %5, %6
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load i32, i32* %len, align 4, !tbaa !5
  %8 = load i32, i32* %cnt, align 4, !tbaa !5
  %sub = sub nsw i32 %7, %8
  %sub3 = sub nsw i32 %sub, 1
  %idxprom = sext i32 %sub3 to i64
  %9 = load i8*, i8** %fwd.addr, align 8, !tbaa !1
  %arrayidx = getelementptr inbounds i8, i8* %9, i64 %idxprom
  %10 = load i8, i8* %arrayidx, align 1, !tbaa !17
  %11 = load i32, i32* %cnt, align 4, !tbaa !5
  %idxprom4 = sext i32 %11 to i64
  %12 = load i8*, i8** %rev, align 8, !tbaa !1
  %arrayidx5 = getelementptr inbounds i8, i8* %12, i64 %idxprom4
  store i8 %10, i8* %arrayidx5, align 1, !tbaa !17
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %13 = load i32, i32* %cnt, align 4, !tbaa !5
  %inc = add nsw i32 %13, 1
  store i32 %inc, i32* %cnt, align 4, !tbaa !5
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %14 = load i32, i32* %len, align 4, !tbaa !5
  %idxprom6 = sext i32 %14 to i64
  %15 = load i8*, i8** %rev, align 8, !tbaa !1
  %arrayidx7 = getelementptr inbounds i8, i8* %15, i64 %idxprom6
  store i8 0, i8* %arrayidx7, align 1, !tbaa !17
  %16 = load i8*, i8** %rev, align 8, !tbaa !1
  %17 = bitcast i32* %cnt to i8*
  call void @llvm.lifetime.end(i64 4, i8* %17) #1
  %18 = bitcast i32* %len to i8*
  call void @llvm.lifetime.end(i64 4, i8* %18) #1
  %19 = bitcast i8** %rev to i8*
  call void @llvm.lifetime.end(i64 8, i8* %19) #1
  ret i8* %16
}

declare void @makelower(i8*) #2

declare i32 @closedir(%struct.__dirstream*) #2

declare i32 @sm_strcasecmp(i8*, i8*) #2

; Function Attrs: nounwind uwtable
define internal i32 @workcmpf1(%struct.work* %a, %struct.work* %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca %struct.work*, align 8
  %b.addr = alloca %struct.work*, align 8
  %i = alloca i32, align 4
  %cleanup.dest.slot = alloca i32
  store %struct.work* %a, %struct.work** %a.addr, align 8, !tbaa !1
  store %struct.work* %b, %struct.work** %b.addr, align 8, !tbaa !1
  %0 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start(i64 4, i8* %0) #1
  %1 = load %struct.work*, %struct.work** %a.addr, align 8, !tbaa !1
  %w_host = getelementptr inbounds %struct.work, %struct.work* %1, i32 0, i32 1
  %2 = load i8*, i8** %w_host, align 8, !tbaa !130
  %cmp = icmp ne i8* %2, null
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %3 = load %struct.work*, %struct.work** %b.addr, align 8, !tbaa !1
  %w_host1 = getelementptr inbounds %struct.work, %struct.work* %3, i32 0, i32 1
  %4 = load i8*, i8** %w_host1, align 8, !tbaa !130
  %cmp2 = icmp eq i8* %4, null
  br i1 %cmp2, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  store i32 1, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.else:                                          ; preds = %land.lhs.true, %entry
  %5 = load %struct.work*, %struct.work** %a.addr, align 8, !tbaa !1
  %w_host3 = getelementptr inbounds %struct.work, %struct.work* %5, i32 0, i32 1
  %6 = load i8*, i8** %w_host3, align 8, !tbaa !130
  %cmp4 = icmp eq i8* %6, null
  br i1 %cmp4, label %land.lhs.true.5, label %if.end

land.lhs.true.5:                                  ; preds = %if.else
  %7 = load %struct.work*, %struct.work** %b.addr, align 8, !tbaa !1
  %w_host6 = getelementptr inbounds %struct.work, %struct.work* %7, i32 0, i32 1
  %8 = load i8*, i8** %w_host6, align 8, !tbaa !130
  %cmp7 = icmp ne i8* %8, null
  br i1 %cmp7, label %if.then.8, label %if.end

if.then.8:                                        ; preds = %land.lhs.true.5
  store i32 -1, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end:                                           ; preds = %land.lhs.true.5, %if.else
  br label %if.end.9

if.end.9:                                         ; preds = %if.end
  %9 = load %struct.work*, %struct.work** %a.addr, align 8, !tbaa !1
  %w_host10 = getelementptr inbounds %struct.work, %struct.work* %9, i32 0, i32 1
  %10 = load i8*, i8** %w_host10, align 8, !tbaa !130
  %cmp11 = icmp ne i8* %10, null
  br i1 %cmp11, label %land.lhs.true.12, label %if.end.20

land.lhs.true.12:                                 ; preds = %if.end.9
  %11 = load %struct.work*, %struct.work** %b.addr, align 8, !tbaa !1
  %w_host13 = getelementptr inbounds %struct.work, %struct.work* %11, i32 0, i32 1
  %12 = load i8*, i8** %w_host13, align 8, !tbaa !130
  %cmp14 = icmp ne i8* %12, null
  br i1 %cmp14, label %land.lhs.true.15, label %if.end.20

land.lhs.true.15:                                 ; preds = %land.lhs.true.12
  %13 = load %struct.work*, %struct.work** %a.addr, align 8, !tbaa !1
  %w_host16 = getelementptr inbounds %struct.work, %struct.work* %13, i32 0, i32 1
  %14 = load i8*, i8** %w_host16, align 8, !tbaa !130
  %15 = load %struct.work*, %struct.work** %b.addr, align 8, !tbaa !1
  %w_host17 = getelementptr inbounds %struct.work, %struct.work* %15, i32 0, i32 1
  %16 = load i8*, i8** %w_host17, align 8, !tbaa !130
  %call = call i32 @sm_strcasecmp(i8* %14, i8* %16)
  store i32 %call, i32* %i, align 4, !tbaa !5
  %cmp18 = icmp ne i32 %call, 0
  br i1 %cmp18, label %if.then.19, label %if.end.20

if.then.19:                                       ; preds = %land.lhs.true.15
  %17 = load i32, i32* %i, align 4, !tbaa !5
  store i32 %17, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.20:                                        ; preds = %land.lhs.true.15, %land.lhs.true.12, %if.end.9
  %18 = load %struct.work*, %struct.work** %a.addr, align 8, !tbaa !1
  %w_lock = getelementptr inbounds %struct.work, %struct.work* %18, i32 0, i32 2
  %19 = load i32, i32* %w_lock, align 4, !tbaa !132
  %20 = load %struct.work*, %struct.work** %b.addr, align 8, !tbaa !1
  %w_lock21 = getelementptr inbounds %struct.work, %struct.work* %20, i32 0, i32 2
  %21 = load i32, i32* %w_lock21, align 4, !tbaa !132
  %cmp22 = icmp ne i32 %19, %21
  br i1 %cmp22, label %if.then.23, label %if.end.26

if.then.23:                                       ; preds = %if.end.20
  %22 = load %struct.work*, %struct.work** %b.addr, align 8, !tbaa !1
  %w_lock24 = getelementptr inbounds %struct.work, %struct.work* %22, i32 0, i32 2
  %23 = load i32, i32* %w_lock24, align 4, !tbaa !132
  %24 = load %struct.work*, %struct.work** %a.addr, align 8, !tbaa !1
  %w_lock25 = getelementptr inbounds %struct.work, %struct.work* %24, i32 0, i32 2
  %25 = load i32, i32* %w_lock25, align 4, !tbaa !132
  %sub = sub nsw i32 %23, %25
  store i32 %sub, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.26:                                        ; preds = %if.end.20
  %26 = load %struct.work*, %struct.work** %a.addr, align 8, !tbaa !1
  %27 = load %struct.work*, %struct.work** %b.addr, align 8, !tbaa !1
  %call27 = call i32 @workcmpf0(%struct.work* %26, %struct.work* %27)
  store i32 %call27, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

cleanup:                                          ; preds = %if.end.26, %if.then.23, %if.then.19, %if.then.8, %if.then
  %28 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end(i64 4, i8* %28) #1
  %29 = load i32, i32* %retval
  ret i32 %29
}

; Function Attrs: nounwind uwtable
define internal i32 @workcmpf2(%struct.work* %a, %struct.work* %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca %struct.work*, align 8
  %b.addr = alloca %struct.work*, align 8
  %i = alloca i32, align 4
  %cleanup.dest.slot = alloca i32
  store %struct.work* %a, %struct.work** %a.addr, align 8, !tbaa !1
  store %struct.work* %b, %struct.work** %b.addr, align 8, !tbaa !1
  %0 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start(i64 4, i8* %0) #1
  %1 = load %struct.work*, %struct.work** %a.addr, align 8, !tbaa !1
  %w_lock = getelementptr inbounds %struct.work, %struct.work* %1, i32 0, i32 2
  %2 = load i32, i32* %w_lock, align 4, !tbaa !132
  %3 = load %struct.work*, %struct.work** %b.addr, align 8, !tbaa !1
  %w_lock1 = getelementptr inbounds %struct.work, %struct.work* %3, i32 0, i32 2
  %4 = load i32, i32* %w_lock1, align 4, !tbaa !132
  %cmp = icmp ne i32 %2, %4
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load %struct.work*, %struct.work** %a.addr, align 8, !tbaa !1
  %w_lock2 = getelementptr inbounds %struct.work, %struct.work* %5, i32 0, i32 2
  %6 = load i32, i32* %w_lock2, align 4, !tbaa !132
  %7 = load %struct.work*, %struct.work** %b.addr, align 8, !tbaa !1
  %w_lock3 = getelementptr inbounds %struct.work, %struct.work* %7, i32 0, i32 2
  %8 = load i32, i32* %w_lock3, align 4, !tbaa !132
  %sub = sub nsw i32 %6, %8
  store i32 %sub, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end:                                           ; preds = %entry
  %9 = load %struct.work*, %struct.work** %a.addr, align 8, !tbaa !1
  %w_host = getelementptr inbounds %struct.work, %struct.work* %9, i32 0, i32 1
  %10 = load i8*, i8** %w_host, align 8, !tbaa !130
  %cmp4 = icmp ne i8* %10, null
  br i1 %cmp4, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.end
  %11 = load %struct.work*, %struct.work** %b.addr, align 8, !tbaa !1
  %w_host5 = getelementptr inbounds %struct.work, %struct.work* %11, i32 0, i32 1
  %12 = load i8*, i8** %w_host5, align 8, !tbaa !130
  %cmp6 = icmp eq i8* %12, null
  br i1 %cmp6, label %if.then.7, label %if.else

if.then.7:                                        ; preds = %land.lhs.true
  store i32 1, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.else:                                          ; preds = %land.lhs.true, %if.end
  %13 = load %struct.work*, %struct.work** %a.addr, align 8, !tbaa !1
  %w_host8 = getelementptr inbounds %struct.work, %struct.work* %13, i32 0, i32 1
  %14 = load i8*, i8** %w_host8, align 8, !tbaa !130
  %cmp9 = icmp eq i8* %14, null
  br i1 %cmp9, label %land.lhs.true.10, label %if.end.14

land.lhs.true.10:                                 ; preds = %if.else
  %15 = load %struct.work*, %struct.work** %b.addr, align 8, !tbaa !1
  %w_host11 = getelementptr inbounds %struct.work, %struct.work* %15, i32 0, i32 1
  %16 = load i8*, i8** %w_host11, align 8, !tbaa !130
  %cmp12 = icmp ne i8* %16, null
  br i1 %cmp12, label %if.then.13, label %if.end.14

if.then.13:                                       ; preds = %land.lhs.true.10
  store i32 -1, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.14:                                        ; preds = %land.lhs.true.10, %if.else
  br label %if.end.15

if.end.15:                                        ; preds = %if.end.14
  %17 = load %struct.work*, %struct.work** %a.addr, align 8, !tbaa !1
  %w_host16 = getelementptr inbounds %struct.work, %struct.work* %17, i32 0, i32 1
  %18 = load i8*, i8** %w_host16, align 8, !tbaa !130
  %cmp17 = icmp ne i8* %18, null
  br i1 %cmp17, label %land.lhs.true.18, label %if.end.26

land.lhs.true.18:                                 ; preds = %if.end.15
  %19 = load %struct.work*, %struct.work** %b.addr, align 8, !tbaa !1
  %w_host19 = getelementptr inbounds %struct.work, %struct.work* %19, i32 0, i32 1
  %20 = load i8*, i8** %w_host19, align 8, !tbaa !130
  %cmp20 = icmp ne i8* %20, null
  br i1 %cmp20, label %land.lhs.true.21, label %if.end.26

land.lhs.true.21:                                 ; preds = %land.lhs.true.18
  %21 = load %struct.work*, %struct.work** %a.addr, align 8, !tbaa !1
  %w_host22 = getelementptr inbounds %struct.work, %struct.work* %21, i32 0, i32 1
  %22 = load i8*, i8** %w_host22, align 8, !tbaa !130
  %23 = load %struct.work*, %struct.work** %b.addr, align 8, !tbaa !1
  %w_host23 = getelementptr inbounds %struct.work, %struct.work* %23, i32 0, i32 1
  %24 = load i8*, i8** %w_host23, align 8, !tbaa !130
  %call = call i32 @sm_strcasecmp(i8* %22, i8* %24)
  store i32 %call, i32* %i, align 4, !tbaa !5
  %cmp24 = icmp ne i32 %call, 0
  br i1 %cmp24, label %if.then.25, label %if.end.26

if.then.25:                                       ; preds = %land.lhs.true.21
  %25 = load i32, i32* %i, align 4, !tbaa !5
  store i32 %25, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.26:                                        ; preds = %land.lhs.true.21, %land.lhs.true.18, %if.end.15
  %26 = load %struct.work*, %struct.work** %a.addr, align 8, !tbaa !1
  %27 = load %struct.work*, %struct.work** %b.addr, align 8, !tbaa !1
  %call27 = call i32 @workcmpf0(%struct.work* %26, %struct.work* %27)
  store i32 %call27, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

cleanup:                                          ; preds = %if.end.26, %if.then.25, %if.then.13, %if.then.7, %if.then
  %28 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end(i64 4, i8* %28) #1
  %29 = load i32, i32* %retval
  ret i32 %29
}

; Function Attrs: nounwind uwtable
define internal i32 @workcmpf3(%struct.work* %a, %struct.work* %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca %struct.work*, align 8
  %b.addr = alloca %struct.work*, align 8
  store %struct.work* %a, %struct.work** %a.addr, align 8, !tbaa !1
  store %struct.work* %b, %struct.work** %b.addr, align 8, !tbaa !1
  %0 = load %struct.work*, %struct.work** %a.addr, align 8, !tbaa !1
  %w_ctime = getelementptr inbounds %struct.work, %struct.work* %0, i32 0, i32 5
  %1 = load i64, i64* %w_ctime, align 8, !tbaa !134
  %2 = load %struct.work*, %struct.work** %b.addr, align 8, !tbaa !1
  %w_ctime1 = getelementptr inbounds %struct.work, %struct.work* %2, i32 0, i32 5
  %3 = load i64, i64* %w_ctime1, align 8, !tbaa !134
  %cmp = icmp sgt i64 %1, %3
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval
  br label %return

if.else:                                          ; preds = %entry
  %4 = load %struct.work*, %struct.work** %a.addr, align 8, !tbaa !1
  %w_ctime2 = getelementptr inbounds %struct.work, %struct.work* %4, i32 0, i32 5
  %5 = load i64, i64* %w_ctime2, align 8, !tbaa !134
  %6 = load %struct.work*, %struct.work** %b.addr, align 8, !tbaa !1
  %w_ctime3 = getelementptr inbounds %struct.work, %struct.work* %6, i32 0, i32 5
  %7 = load i64, i64* %w_ctime3, align 8, !tbaa !134
  %cmp4 = icmp slt i64 %5, %7
  br i1 %cmp4, label %if.then.5, label %if.else.6

if.then.5:                                        ; preds = %if.else
  store i32 -1, i32* %retval
  br label %return

if.else.6:                                        ; preds = %if.else
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.else.6, %if.then.5, %if.then
  %8 = load i32, i32* %retval
  ret i32 %8
}

; Function Attrs: nounwind uwtable
define internal i32 @workcmpf4(%struct.work* %a, %struct.work* %b) #0 {
entry:
  %a.addr = alloca %struct.work*, align 8
  %b.addr = alloca %struct.work*, align 8
  %__s1_len = alloca i64, align 8
  %__s2_len = alloca i64, align 8
  %tmp = alloca i32, align 4
  store %struct.work* %a, %struct.work** %a.addr, align 8, !tbaa !1
  store %struct.work* %b, %struct.work** %b.addr, align 8, !tbaa !1
  %0 = bitcast i64* %__s1_len to i8*
  call void @llvm.lifetime.start(i64 8, i8* %0) #1
  %1 = bitcast i64* %__s2_len to i8*
  call void @llvm.lifetime.start(i64 8, i8* %1) #1
  %2 = load %struct.work*, %struct.work** %a.addr, align 8, !tbaa !1
  %w_name = getelementptr inbounds %struct.work, %struct.work* %2, i32 0, i32 0
  %3 = load i8*, i8** %w_name, align 8, !tbaa !129
  %4 = load %struct.work*, %struct.work** %b.addr, align 8, !tbaa !1
  %w_name1 = getelementptr inbounds %struct.work, %struct.work* %4, i32 0, i32 0
  %5 = load i8*, i8** %w_name1, align 8, !tbaa !129
  %call = call i32 @strcmp(i8* %3, i8* %5) #1
  store i32 %call, i32* %tmp, !tbaa !5
  %6 = bitcast i64* %__s2_len to i8*
  call void @llvm.lifetime.end(i64 8, i8* %6) #1
  %7 = bitcast i64* %__s1_len to i8*
  call void @llvm.lifetime.end(i64 8, i8* %7) #1
  %8 = load i32, i32* %tmp, !tbaa !5
  ret i32 %8
}

; Function Attrs: nounwind uwtable
define internal i32 @workcmpf5(%struct.work* %a, %struct.work* %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca %struct.work*, align 8
  %b.addr = alloca %struct.work*, align 8
  store %struct.work* %a, %struct.work** %a.addr, align 8, !tbaa !1
  store %struct.work* %b, %struct.work** %b.addr, align 8, !tbaa !1
  %0 = load %struct.work*, %struct.work** %a.addr, align 8, !tbaa !1
  %w_name = getelementptr inbounds %struct.work, %struct.work* %0, i32 0, i32 0
  %1 = load i8*, i8** %w_name, align 8, !tbaa !129
  %call = call i64 @strlen(i8* %1) #14
  %2 = load i32, i32* @randi, align 4, !tbaa !5
  %conv = sext i32 %2 to i64
  %cmp = icmp ult i64 %call, %conv
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %3 = load %struct.work*, %struct.work** %b.addr, align 8, !tbaa !1
  %w_name2 = getelementptr inbounds %struct.work, %struct.work* %3, i32 0, i32 0
  %4 = load i8*, i8** %w_name2, align 8, !tbaa !129
  %call3 = call i64 @strlen(i8* %4) #14
  %5 = load i32, i32* @randi, align 4, !tbaa !5
  %conv4 = sext i32 %5 to i64
  %cmp5 = icmp ult i64 %call3, %conv4
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 -1, i32* %retval
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %6 = load i32, i32* @randi, align 4, !tbaa !5
  %idxprom = sext i32 %6 to i64
  %7 = load %struct.work*, %struct.work** %a.addr, align 8, !tbaa !1
  %w_name7 = getelementptr inbounds %struct.work, %struct.work* %7, i32 0, i32 0
  %8 = load i8*, i8** %w_name7, align 8, !tbaa !129
  %arrayidx = getelementptr inbounds i8, i8* %8, i64 %idxprom
  %9 = load i8, i8* %arrayidx, align 1, !tbaa !17
  %conv8 = sext i8 %9 to i32
  %10 = load i32, i32* @randi, align 4, !tbaa !5
  %idxprom9 = sext i32 %10 to i64
  %11 = load %struct.work*, %struct.work** %b.addr, align 8, !tbaa !1
  %w_name10 = getelementptr inbounds %struct.work, %struct.work* %11, i32 0, i32 0
  %12 = load i8*, i8** %w_name10, align 8, !tbaa !129
  %arrayidx11 = getelementptr inbounds i8, i8* %12, i64 %idxprom9
  %13 = load i8, i8* %arrayidx11, align 1, !tbaa !17
  %conv12 = sext i8 %13 to i32
  %sub = sub nsw i32 %conv8, %conv12
  store i32 %sub, i32* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %14 = load i32, i32* %retval
  ret i32 %14
}

; Function Attrs: nounwind uwtable
define internal i32 @workcmpf6(%struct.work* %a, %struct.work* %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca %struct.work*, align 8
  %b.addr = alloca %struct.work*, align 8
  store %struct.work* %a, %struct.work** %a.addr, align 8, !tbaa !1
  store %struct.work* %b, %struct.work** %b.addr, align 8, !tbaa !1
  %0 = load %struct.work*, %struct.work** %a.addr, align 8, !tbaa !1
  %w_mtime = getelementptr inbounds %struct.work, %struct.work* %0, i32 0, i32 6
  %1 = load i64, i64* %w_mtime, align 8, !tbaa !136
  %2 = load %struct.work*, %struct.work** %b.addr, align 8, !tbaa !1
  %w_mtime1 = getelementptr inbounds %struct.work, %struct.work* %2, i32 0, i32 6
  %3 = load i64, i64* %w_mtime1, align 8, !tbaa !136
  %cmp = icmp sgt i64 %1, %3
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval
  br label %return

if.else:                                          ; preds = %entry
  %4 = load %struct.work*, %struct.work** %a.addr, align 8, !tbaa !1
  %w_mtime2 = getelementptr inbounds %struct.work, %struct.work* %4, i32 0, i32 6
  %5 = load i64, i64* %w_mtime2, align 8, !tbaa !136
  %6 = load %struct.work*, %struct.work** %b.addr, align 8, !tbaa !1
  %w_mtime3 = getelementptr inbounds %struct.work, %struct.work* %6, i32 0, i32 6
  %7 = load i64, i64* %w_mtime3, align 8, !tbaa !136
  %cmp4 = icmp slt i64 %5, %7
  br i1 %cmp4, label %if.then.5, label %if.else.6

if.then.5:                                        ; preds = %if.else
  store i32 -1, i32* %retval
  br label %return

if.else.6:                                        ; preds = %if.else
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.else.6, %if.then.5, %if.then
  %8 = load i32, i32* %retval
  ret i32 %8
}

; Function Attrs: nounwind uwtable
define internal i32 @workcmpf0(%struct.work* %a, %struct.work* %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca %struct.work*, align 8
  %b.addr = alloca %struct.work*, align 8
  %pa = alloca i64, align 8
  %pb = alloca i64, align 8
  %cleanup.dest.slot = alloca i32
  store %struct.work* %a, %struct.work** %a.addr, align 8, !tbaa !1
  store %struct.work* %b, %struct.work** %b.addr, align 8, !tbaa !1
  %0 = bitcast i64* %pa to i8*
  call void @llvm.lifetime.start(i64 8, i8* %0) #1
  %1 = load %struct.work*, %struct.work** %a.addr, align 8, !tbaa !1
  %w_pri = getelementptr inbounds %struct.work, %struct.work* %1, i32 0, i32 4
  %2 = load i64, i64* %w_pri, align 8, !tbaa !133
  store i64 %2, i64* %pa, align 8, !tbaa !92
  %3 = bitcast i64* %pb to i8*
  call void @llvm.lifetime.start(i64 8, i8* %3) #1
  %4 = load %struct.work*, %struct.work** %b.addr, align 8, !tbaa !1
  %w_pri1 = getelementptr inbounds %struct.work, %struct.work* %4, i32 0, i32 4
  %5 = load i64, i64* %w_pri1, align 8, !tbaa !133
  store i64 %5, i64* %pb, align 8, !tbaa !92
  %6 = load i64, i64* %pa, align 8, !tbaa !92
  %7 = load i64, i64* %pb, align 8, !tbaa !92
  %cmp = icmp eq i64 %6, %7
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.else:                                          ; preds = %entry
  %8 = load i64, i64* %pa, align 8, !tbaa !92
  %9 = load i64, i64* %pb, align 8, !tbaa !92
  %cmp2 = icmp sgt i64 %8, %9
  br i1 %cmp2, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %if.else
  store i32 1, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.else.4:                                        ; preds = %if.else
  store i32 -1, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

cleanup:                                          ; preds = %if.else.4, %if.then.3, %if.then
  %10 = bitcast i64* %pb to i8*
  call void @llvm.lifetime.end(i64 8, i8* %10) #1
  %11 = bitcast i64* %pa to i8*
  call void @llvm.lifetime.end(i64 8, i8* %11) #1
  %12 = load i32, i32* %retval
  ret i32 %12
}

; Function Attrs: nounwind
declare i32 @getegid() #3

declare void @initsys(%struct.envelope*) #2

declare i8* @fgetfolded(i8*, i32*, %struct.sm_file*) #2

declare i32 @xtextok(i8*) #2

declare i32 @check_bodytype(i8*) #2

; Function Attrs: nounwind uwtable
define internal %struct.address* @setctluser(i8* %user, i32 %qfver, %struct.envelope* %e) #0 {
entry:
  %retval = alloca %struct.address*, align 8
  %user.addr = alloca i8*, align 8
  %qfver.addr = alloca i32, align 4
  %e.addr = alloca %struct.envelope*, align 8
  %a = alloca %struct.address*, align 8
  %pw = alloca %struct.passwd*, align 8
  %p = alloca i8*, align 8
  %cleanup.dest.slot = alloca i32
  %o = alloca i8*, align 8
  %__s1_len = alloca i64, align 8
  %__s2_len = alloca i64, align 8
  %tmp = alloca i32, align 4
  %__s1 = alloca i8*, align 8
  %__result = alloca i32, align 4
  %tmp93 = alloca i32, align 4
  store i8* %user, i8** %user.addr, align 8, !tbaa !1
  store i32 %qfver, i32* %qfver.addr, align 4, !tbaa !5
  store %struct.envelope* %e, %struct.envelope** %e.addr, align 8, !tbaa !1
  %0 = bitcast %struct.address** %a to i8*
  call void @llvm.lifetime.start(i64 8, i8* %0) #1
  %1 = bitcast %struct.passwd** %pw to i8*
  call void @llvm.lifetime.start(i64 8, i8* %1) #1
  %2 = bitcast i8** %p to i8*
  call void @llvm.lifetime.start(i64 8, i8* %2) #1
  %3 = load i8*, i8** %user.addr, align 8, !tbaa !1
  %cmp = icmp eq i8* %3, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %4 = load i8*, i8** %user.addr, align 8, !tbaa !1
  %5 = load i8, i8* %4, align 1, !tbaa !17
  %conv = sext i8 %5 to i32
  %cmp1 = icmp eq i32 %conv, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store %struct.address* null, %struct.address** %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end:                                           ; preds = %lor.lhs.false
  %6 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_rpool = getelementptr inbounds %struct.envelope, %struct.envelope* %6, i32 0, i32 52
  %7 = load %struct.SM_RPOOL_T*, %struct.SM_RPOOL_T** %e_rpool, align 8, !tbaa !120
  %8 = load i32, i32* @SmHeapGroup, align 4, !tbaa !5
  %call = call i8* @sm_rpool_malloc_tagged_x(%struct.SM_RPOOL_T* %7, i64 192, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 5559, i32 %8)
  %9 = bitcast i8* %call to %struct.address*
  store %struct.address* %9, %struct.address** %a, align 8, !tbaa !1
  %10 = load %struct.address*, %struct.address** %a, align 8, !tbaa !1
  %11 = bitcast %struct.address* %10 to i8*
  call void @llvm.memset.p0i8.i64(i8* %11, i8 0, i64 192, i32 1, i1 false)
  %12 = load i8*, i8** %user.addr, align 8, !tbaa !1
  %13 = load i8, i8* %12, align 1, !tbaa !17
  %conv3 = sext i8 %13 to i32
  %cmp4 = icmp eq i32 %conv3, 58
  br i1 %cmp4, label %if.then.6, label %if.else

if.then.6:                                        ; preds = %if.end
  %14 = load i8*, i8** %user.addr, align 8, !tbaa !1
  %arrayidx = getelementptr inbounds i8, i8* %14, i64 1
  store i8* %arrayidx, i8** %p, align 8, !tbaa !1
  %15 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_rpool7 = getelementptr inbounds %struct.envelope, %struct.envelope* %15, i32 0, i32 52
  %16 = load %struct.SM_RPOOL_T*, %struct.SM_RPOOL_T** %e_rpool7, align 8, !tbaa !120
  %17 = load i8*, i8** %p, align 8, !tbaa !1
  %call8 = call i8* @sm_rpool_strdup_x(%struct.SM_RPOOL_T* %16, i8* %17)
  %18 = load %struct.address*, %struct.address** %a, align 8, !tbaa !1
  %q_user = getelementptr inbounds %struct.address, %struct.address* %18, i32 0, i32 1
  store i8* %call8, i8** %q_user, align 8, !tbaa !98
  br label %if.end.113

if.else:                                          ; preds = %if.end
  %19 = load i8*, i8** %user.addr, align 8, !tbaa !1
  %call9 = call i8* @strtok(i8* %19, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.264, i32 0, i32 0)) #1
  store i8* %call9, i8** %p, align 8, !tbaa !1
  %20 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_rpool10 = getelementptr inbounds %struct.envelope, %struct.envelope* %20, i32 0, i32 52
  %21 = load %struct.SM_RPOOL_T*, %struct.SM_RPOOL_T** %e_rpool10, align 8, !tbaa !120
  %22 = load i8*, i8** %user.addr, align 8, !tbaa !1
  %call11 = call i8* @sm_rpool_strdup_x(%struct.SM_RPOOL_T* %21, i8* %22)
  %23 = load %struct.address*, %struct.address** %a, align 8, !tbaa !1
  %q_user12 = getelementptr inbounds %struct.address, %struct.address* %23, i32 0, i32 1
  store i8* %call11, i8** %q_user12, align 8, !tbaa !98
  %24 = load i32, i32* %qfver.addr, align 4, !tbaa !5
  %cmp13 = icmp sge i32 %24, 2
  br i1 %cmp13, label %if.then.15, label %if.else.41

if.then.15:                                       ; preds = %if.else
  %call16 = call i8* @strtok(i8* null, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.264, i32 0, i32 0)) #1
  store i8* %call16, i8** %p, align 8, !tbaa !1
  %cmp17 = icmp ne i8* %call16, null
  br i1 %cmp17, label %if.then.19, label %if.end.21

if.then.19:                                       ; preds = %if.then.15
  %25 = load i8*, i8** %p, align 8, !tbaa !1
  %call20 = call i32 @atoi(i8* %25) #14
  %26 = load %struct.address*, %struct.address** %a, align 8, !tbaa !1
  %q_uid = getelementptr inbounds %struct.address, %struct.address* %26, i32 0, i32 6
  store i32 %call20, i32* %q_uid, align 4, !tbaa !99
  br label %if.end.21

if.end.21:                                        ; preds = %if.then.19, %if.then.15
  %call22 = call i8* @strtok(i8* null, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.264, i32 0, i32 0)) #1
  store i8* %call22, i8** %p, align 8, !tbaa !1
  %cmp23 = icmp ne i8* %call22, null
  br i1 %cmp23, label %if.then.25, label %if.end.27

if.then.25:                                       ; preds = %if.end.21
  %27 = load i8*, i8** %p, align 8, !tbaa !1
  %call26 = call i32 @atoi(i8* %27) #14
  %28 = load %struct.address*, %struct.address** %a, align 8, !tbaa !1
  %q_gid = getelementptr inbounds %struct.address, %struct.address* %28, i32 0, i32 7
  store i32 %call26, i32* %q_gid, align 4, !tbaa !100
  br label %if.end.27

if.end.27:                                        ; preds = %if.then.25, %if.end.21
  %call28 = call i8* @strtok(i8* null, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.264, i32 0, i32 0)) #1
  store i8* %call28, i8** %p, align 8, !tbaa !1
  %cmp29 = icmp ne i8* %call28, null
  br i1 %cmp29, label %if.then.31, label %if.end.40

if.then.31:                                       ; preds = %if.end.27
  %29 = bitcast i8** %o to i8*
  call void @llvm.lifetime.start(i64 8, i8* %29) #1
  %30 = load %struct.address*, %struct.address** %a, align 8, !tbaa !1
  %q_flags = getelementptr inbounds %struct.address, %struct.address* %30, i32 0, i32 5
  %31 = load i64, i64* %q_flags, align 8, !tbaa !56
  %or = or i64 %31, 1
  store i64 %or, i64* %q_flags, align 8, !tbaa !56
  %call32 = call i8* @strtok(i8* null, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.264, i32 0, i32 0)) #1
  store i8* %call32, i8** %o, align 8, !tbaa !1
  %cmp33 = icmp ne i8* %call32, null
  br i1 %cmp33, label %land.lhs.true, label %if.end.39

land.lhs.true:                                    ; preds = %if.then.31
  %32 = load i8*, i8** %o, align 8, !tbaa !1
  %33 = load i8*, i8** %p, align 8, !tbaa !1
  %cmp35 = icmp ugt i8* %32, %33
  br i1 %cmp35, label %if.then.37, label %if.end.39

if.then.37:                                       ; preds = %land.lhs.true
  %34 = load i8*, i8** %o, align 8, !tbaa !1
  %arrayidx38 = getelementptr inbounds i8, i8* %34, i64 -1
  store i8 58, i8* %arrayidx38, align 1, !tbaa !17
  br label %if.end.39

if.end.39:                                        ; preds = %if.then.37, %land.lhs.true, %if.then.31
  %35 = bitcast i8** %o to i8*
  call void @llvm.lifetime.end(i64 8, i8* %35) #1
  br label %if.end.40

if.end.40:                                        ; preds = %if.end.39, %if.end.27
  br label %if.end.112

if.else.41:                                       ; preds = %if.else
  %36 = load i8*, i8** %user.addr, align 8, !tbaa !1
  %call42 = call %struct.passwd* @sm_getpwnam(i8* %36)
  store %struct.passwd* %call42, %struct.passwd** %pw, align 8, !tbaa !1
  %cmp43 = icmp ne %struct.passwd* %call42, null
  br i1 %cmp43, label %if.then.45, label %if.end.111

if.then.45:                                       ; preds = %if.else.41
  %37 = load %struct.passwd*, %struct.passwd** %pw, align 8, !tbaa !1
  %pw_dir = getelementptr inbounds %struct.passwd, %struct.passwd* %37, i32 0, i32 5
  %38 = load i8*, i8** %pw_dir, align 8, !tbaa !164
  %39 = load i8, i8* %38, align 1, !tbaa !17
  %conv46 = sext i8 %39 to i32
  %cmp47 = icmp eq i32 %conv46, 0
  br i1 %cmp47, label %if.then.49, label %if.else.50

if.then.49:                                       ; preds = %if.then.45
  %40 = load %struct.address*, %struct.address** %a, align 8, !tbaa !1
  %q_home = getelementptr inbounds %struct.address, %struct.address* %40, i32 0, i32 8
  store i8* null, i8** %q_home, align 8, !tbaa !166
  br label %if.end.106

if.else.50:                                       ; preds = %if.then.45
  %41 = bitcast i64* %__s1_len to i8*
  call void @llvm.lifetime.start(i64 8, i8* %41) #1
  %42 = bitcast i64* %__s2_len to i8*
  call void @llvm.lifetime.start(i64 8, i8* %42) #1
  br i1 icmp eq (i64 sub (i64 ptrtoint (i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.111, i32 0, i64 1) to i64), i64 ptrtoint ([2 x i8]* @.str.111 to i64)), i64 1), label %land.lhs.true.51, label %cond.false

land.lhs.true.51:                                 ; preds = %if.else.50
  store i64 1, i64* %__s2_len, align 8, !tbaa !92
  %43 = load i64, i64* %__s2_len, align 8, !tbaa !92
  %cmp52 = icmp ult i64 %43, 4
  br i1 %cmp52, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true.51
  %44 = bitcast i8** %__s1 to i8*
  call void @llvm.lifetime.start(i64 8, i8* %44) #1
  %45 = load %struct.passwd*, %struct.passwd** %pw, align 8, !tbaa !1
  %pw_dir55 = getelementptr inbounds %struct.passwd, %struct.passwd* %45, i32 0, i32 5
  %46 = load i8*, i8** %pw_dir55, align 8, !tbaa !164
  store i8* %46, i8** %__s1, align 8, !tbaa !1
  %47 = bitcast i32* %__result to i8*
  call void @llvm.lifetime.start(i64 4, i8* %47) #1
  %48 = load i8*, i8** %__s1, align 8, !tbaa !1
  %arrayidx57 = getelementptr inbounds i8, i8* %48, i64 0
  %49 = load i8, i8* %arrayidx57, align 1, !tbaa !17
  %conv58 = zext i8 %49 to i32
  %50 = load i8, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.111, i32 0, i32 0), align 1, !tbaa !17
  %conv59 = zext i8 %50 to i32
  %sub = sub nsw i32 %conv58, %conv59
  store i32 %sub, i32* %__result, align 4, !tbaa !5
  %51 = load i64, i64* %__s2_len, align 8, !tbaa !92
  %cmp60 = icmp ugt i64 %51, 0
  br i1 %cmp60, label %land.lhs.true.62, label %if.end.92

land.lhs.true.62:                                 ; preds = %cond.true
  %52 = load i32, i32* %__result, align 4, !tbaa !5
  %cmp63 = icmp eq i32 %52, 0
  br i1 %cmp63, label %if.then.65, label %if.end.92

if.then.65:                                       ; preds = %land.lhs.true.62
  %53 = load i8*, i8** %__s1, align 8, !tbaa !1
  %arrayidx66 = getelementptr inbounds i8, i8* %53, i64 1
  %54 = load i8, i8* %arrayidx66, align 1, !tbaa !17
  %conv67 = zext i8 %54 to i32
  %55 = load i8, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.111, i32 0, i64 1), align 1, !tbaa !17
  %conv68 = zext i8 %55 to i32
  %sub69 = sub nsw i32 %conv67, %conv68
  store i32 %sub69, i32* %__result, align 4, !tbaa !5
  %56 = load i64, i64* %__s2_len, align 8, !tbaa !92
  %cmp70 = icmp ugt i64 %56, 1
  br i1 %cmp70, label %land.lhs.true.72, label %if.end.91

land.lhs.true.72:                                 ; preds = %if.then.65
  %57 = load i32, i32* %__result, align 4, !tbaa !5
  %cmp73 = icmp eq i32 %57, 0
  br i1 %cmp73, label %if.then.75, label %if.end.91

if.then.75:                                       ; preds = %land.lhs.true.72
  %58 = load i8*, i8** %__s1, align 8, !tbaa !1
  %arrayidx76 = getelementptr inbounds i8, i8* %58, i64 2
  %59 = load i8, i8* %arrayidx76, align 1, !tbaa !17
  %conv77 = zext i8 %59 to i32
  %60 = load i8, i8* getelementptr inbounds (i8, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.111, i32 0, i32 0), i64 2), align 1, !tbaa !17
  %conv78 = zext i8 %60 to i32
  %sub79 = sub nsw i32 %conv77, %conv78
  store i32 %sub79, i32* %__result, align 4, !tbaa !5
  %61 = load i64, i64* %__s2_len, align 8, !tbaa !92
  %cmp80 = icmp ugt i64 %61, 2
  br i1 %cmp80, label %land.lhs.true.82, label %if.end.90

land.lhs.true.82:                                 ; preds = %if.then.75
  %62 = load i32, i32* %__result, align 4, !tbaa !5
  %cmp83 = icmp eq i32 %62, 0
  br i1 %cmp83, label %if.then.85, label %if.end.90

if.then.85:                                       ; preds = %land.lhs.true.82
  %63 = load i8*, i8** %__s1, align 8, !tbaa !1
  %arrayidx86 = getelementptr inbounds i8, i8* %63, i64 3
  %64 = load i8, i8* %arrayidx86, align 1, !tbaa !17
  %conv87 = zext i8 %64 to i32
  %65 = load i8, i8* getelementptr inbounds (i8, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.111, i32 0, i32 0), i64 3), align 1, !tbaa !17
  %conv88 = zext i8 %65 to i32
  %sub89 = sub nsw i32 %conv87, %conv88
  store i32 %sub89, i32* %__result, align 4, !tbaa !5
  br label %if.end.90

if.end.90:                                        ; preds = %if.then.85, %land.lhs.true.82, %if.then.75
  br label %if.end.91

if.end.91:                                        ; preds = %if.end.90, %land.lhs.true.72, %if.then.65
  br label %if.end.92

if.end.92:                                        ; preds = %if.end.91, %land.lhs.true.62, %cond.true
  %66 = load i32, i32* %__result, align 4, !tbaa !5
  store i32 %66, i32* %tmp93, !tbaa !5
  %67 = bitcast i32* %__result to i8*
  call void @llvm.lifetime.end(i64 4, i8* %67) #1
  %68 = bitcast i8** %__s1 to i8*
  call void @llvm.lifetime.end(i64 8, i8* %68) #1
  %69 = load i32, i32* %tmp93, !tbaa !5
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true.51, %if.else.50
  %70 = load %struct.passwd*, %struct.passwd** %pw, align 8, !tbaa !1
  %pw_dir94 = getelementptr inbounds %struct.passwd, %struct.passwd* %70, i32 0, i32 5
  %71 = load i8*, i8** %pw_dir94, align 8, !tbaa !164
  %call95 = call i32 @strcmp(i8* %71, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.111, i32 0, i32 0)) #1
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %if.end.92
  %cond = phi i32 [ %69, %if.end.92 ], [ %call95, %cond.false ]
  store i32 %cond, i32* %tmp, !tbaa !5
  %72 = bitcast i64* %__s2_len to i8*
  call void @llvm.lifetime.end(i64 8, i8* %72) #1
  %73 = bitcast i64* %__s1_len to i8*
  call void @llvm.lifetime.end(i64 8, i8* %73) #1
  %74 = load i32, i32* %tmp, !tbaa !5
  %cmp96 = icmp eq i32 %74, 0
  br i1 %cmp96, label %if.then.98, label %if.else.100

if.then.98:                                       ; preds = %cond.end
  %75 = load %struct.address*, %struct.address** %a, align 8, !tbaa !1
  %q_home99 = getelementptr inbounds %struct.address, %struct.address* %75, i32 0, i32 8
  store i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0), i8** %q_home99, align 8, !tbaa !166
  br label %if.end.105

if.else.100:                                      ; preds = %cond.end
  %76 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_rpool101 = getelementptr inbounds %struct.envelope, %struct.envelope* %76, i32 0, i32 52
  %77 = load %struct.SM_RPOOL_T*, %struct.SM_RPOOL_T** %e_rpool101, align 8, !tbaa !120
  %78 = load %struct.passwd*, %struct.passwd** %pw, align 8, !tbaa !1
  %pw_dir102 = getelementptr inbounds %struct.passwd, %struct.passwd* %78, i32 0, i32 5
  %79 = load i8*, i8** %pw_dir102, align 8, !tbaa !164
  %call103 = call i8* @sm_rpool_strdup_x(%struct.SM_RPOOL_T* %77, i8* %79)
  %80 = load %struct.address*, %struct.address** %a, align 8, !tbaa !1
  %q_home104 = getelementptr inbounds %struct.address, %struct.address* %80, i32 0, i32 8
  store i8* %call103, i8** %q_home104, align 8, !tbaa !166
  br label %if.end.105

if.end.105:                                       ; preds = %if.else.100, %if.then.98
  br label %if.end.106

if.end.106:                                       ; preds = %if.end.105, %if.then.49
  %81 = load %struct.passwd*, %struct.passwd** %pw, align 8, !tbaa !1
  %pw_uid = getelementptr inbounds %struct.passwd, %struct.passwd* %81, i32 0, i32 2
  %82 = load i32, i32* %pw_uid, align 4, !tbaa !167
  %83 = load %struct.address*, %struct.address** %a, align 8, !tbaa !1
  %q_uid107 = getelementptr inbounds %struct.address, %struct.address* %83, i32 0, i32 6
  store i32 %82, i32* %q_uid107, align 4, !tbaa !99
  %84 = load %struct.passwd*, %struct.passwd** %pw, align 8, !tbaa !1
  %pw_gid = getelementptr inbounds %struct.passwd, %struct.passwd* %84, i32 0, i32 3
  %85 = load i32, i32* %pw_gid, align 4, !tbaa !168
  %86 = load %struct.address*, %struct.address** %a, align 8, !tbaa !1
  %q_gid108 = getelementptr inbounds %struct.address, %struct.address* %86, i32 0, i32 7
  store i32 %85, i32* %q_gid108, align 4, !tbaa !100
  %87 = load %struct.address*, %struct.address** %a, align 8, !tbaa !1
  %q_flags109 = getelementptr inbounds %struct.address, %struct.address* %87, i32 0, i32 5
  %88 = load i64, i64* %q_flags109, align 8, !tbaa !56
  %or110 = or i64 %88, 1
  store i64 %or110, i64* %q_flags109, align 8, !tbaa !56
  br label %if.end.111

if.end.111:                                       ; preds = %if.end.106, %if.else.41
  br label %if.end.112

if.end.112:                                       ; preds = %if.end.111, %if.end.40
  br label %if.end.113

if.end.113:                                       ; preds = %if.end.112, %if.then.6
  %89 = load %struct.address*, %struct.address** %a, align 8, !tbaa !1
  %q_flags114 = getelementptr inbounds %struct.address, %struct.address* %89, i32 0, i32 5
  %90 = load i64, i64* %q_flags114, align 8, !tbaa !56
  %or115 = or i64 %90, 2
  store i64 %or115, i64* %q_flags114, align 8, !tbaa !56
  %91 = load %struct.mailer*, %struct.mailer** @LocalMailer, align 8, !tbaa !1
  %92 = load %struct.address*, %struct.address** %a, align 8, !tbaa !1
  %q_mailer = getelementptr inbounds %struct.address, %struct.address* %92, i32 0, i32 4
  store %struct.mailer* %91, %struct.mailer** %q_mailer, align 8, !tbaa !60
  %93 = load i8*, i8** %p, align 8, !tbaa !1
  %cmp116 = icmp eq i8* %93, null
  br i1 %cmp116, label %if.then.118, label %if.else.122

if.then.118:                                      ; preds = %if.end.113
  %94 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_rpool119 = getelementptr inbounds %struct.envelope, %struct.envelope* %94, i32 0, i32 52
  %95 = load %struct.SM_RPOOL_T*, %struct.SM_RPOOL_T** %e_rpool119, align 8, !tbaa !120
  %96 = load %struct.address*, %struct.address** %a, align 8, !tbaa !1
  %q_user120 = getelementptr inbounds %struct.address, %struct.address* %96, i32 0, i32 1
  %97 = load i8*, i8** %q_user120, align 8, !tbaa !98
  %call121 = call i8* @sm_rpool_strdup_x(%struct.SM_RPOOL_T* %95, i8* %97)
  %98 = load %struct.address*, %struct.address** %a, align 8, !tbaa !1
  %q_paddr = getelementptr inbounds %struct.address, %struct.address* %98, i32 0, i32 0
  store i8* %call121, i8** %q_paddr, align 8, !tbaa !58
  br label %if.end.126

if.else.122:                                      ; preds = %if.end.113
  %99 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_rpool123 = getelementptr inbounds %struct.envelope, %struct.envelope* %99, i32 0, i32 52
  %100 = load %struct.SM_RPOOL_T*, %struct.SM_RPOOL_T** %e_rpool123, align 8, !tbaa !120
  %101 = load i8*, i8** %p, align 8, !tbaa !1
  %call124 = call i8* @sm_rpool_strdup_x(%struct.SM_RPOOL_T* %100, i8* %101)
  %102 = load %struct.address*, %struct.address** %a, align 8, !tbaa !1
  %q_paddr125 = getelementptr inbounds %struct.address, %struct.address* %102, i32 0, i32 0
  store i8* %call124, i8** %q_paddr125, align 8, !tbaa !58
  br label %if.end.126

if.end.126:                                       ; preds = %if.else.122, %if.then.118
  %103 = load %struct.address*, %struct.address** %a, align 8, !tbaa !1
  store %struct.address* %103, %struct.address** %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

cleanup:                                          ; preds = %if.end.126, %if.then
  %104 = bitcast i8** %p to i8*
  call void @llvm.lifetime.end(i64 8, i8* %104) #1
  %105 = bitcast %struct.passwd** %pw to i8*
  call void @llvm.lifetime.end(i64 8, i8* %105) #1
  %106 = bitcast %struct.address** %a to i8*
  call void @llvm.lifetime.end(i64 8, i8* %106) #1
  %107 = load %struct.address*, %struct.address** %retval
  ret %struct.address* %107
}

; Function Attrs: nounwind readonly
declare i32 @strncmp(i8*, i8*, i64) #8

declare i64 @chompheader(i8*, i32, %struct.header**, %struct.envelope*) #2

declare i8* @pintvl(i64, i32) #2

; Function Attrs: nounwind readnone
declare %struct.__res_state* @__res_state() #4

declare %struct.address* @parseaddr(i8*, %struct.address*, i32, i32, i8**, %struct.envelope*, i32) #2

declare %struct.address* @recipient(%struct.address*, %struct.address**, i32, %struct.envelope*) #2

declare void @setsender(i8*, %struct.envelope*, i8**, i32, i32) #2

; Function Attrs: nounwind
declare i64 @strtol(i8*, i8**, i32) #3

declare i8* @shortenstring(i8*, i64) #2

declare i8* @sm_rpool_malloc_tagged_x(%struct.SM_RPOOL_T*, i64, i8*, i32, i32) #2

; Function Attrs: nounwind
declare i8* @strtok(i8*, i8*) #3

declare %struct.passwd* @sm_getpwnam(i8*) #2

; Function Attrs: nounwind
declare i32 @__xstat(i32, i8*, %struct.stat*) #3

; Function Attrs: noreturn nounwind
declare void @abort() #10

declare i32 @safedirpath(i8*, i32, i32, i8*, i64, i32, i32) #2

; Function Attrs: nounwind uwtable
define internal i32 @chkqdir(i8* %name, i64 %sff) #0 {
entry:
  %retval = alloca i32, align 4
  %name.addr = alloca i8*, align 8
  %sff.addr = alloca i64, align 8
  %statb = alloca %struct.stat, align 8
  %i = alloca i32, align 4
  %cleanup.dest.slot = alloca i32
  store i8* %name, i8** %name.addr, align 8, !tbaa !1
  store i64 %sff, i64* %sff.addr, align 8, !tbaa !92
  %0 = bitcast %struct.stat* %statb to i8*
  call void @llvm.lifetime.start(i64 144, i8* %0) #1
  %1 = bitcast i32* %i to i8*
  call void @llvm.lifetime.start(i64 4, i8* %1) #1
  %2 = load i8*, i8** %name.addr, align 8, !tbaa !1
  %arrayidx = getelementptr inbounds i8, i8* %2, i64 0
  %3 = load i8, i8* %arrayidx, align 1, !tbaa !17
  %conv = sext i8 %3 to i32
  %cmp = icmp eq i32 %conv, 46
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %4 = load i8*, i8** %name.addr, align 8, !tbaa !1
  %arrayidx2 = getelementptr inbounds i8, i8* %4, i64 1
  %5 = load i8, i8* %arrayidx2, align 1, !tbaa !17
  %conv3 = sext i8 %5 to i32
  %cmp4 = icmp eq i32 %conv3, 0
  br i1 %cmp4, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %6 = load i8*, i8** %name.addr, align 8, !tbaa !1
  %arrayidx6 = getelementptr inbounds i8, i8* %6, i64 1
  %7 = load i8, i8* %arrayidx6, align 1, !tbaa !17
  %conv7 = sext i8 %7 to i32
  %cmp8 = icmp eq i32 %conv7, 46
  br i1 %cmp8, label %land.lhs.true.10, label %if.end

land.lhs.true.10:                                 ; preds = %lor.lhs.false
  %8 = load i8*, i8** %name.addr, align 8, !tbaa !1
  %arrayidx11 = getelementptr inbounds i8, i8* %8, i64 2
  %9 = load i8, i8* %arrayidx11, align 1, !tbaa !17
  %conv12 = sext i8 %9 to i32
  %cmp13 = icmp eq i32 %conv12, 0
  br i1 %cmp13, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true.10, %land.lhs.true
  store i32 0, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end:                                           ; preds = %land.lhs.true.10, %lor.lhs.false, %entry
  %10 = load i8*, i8** %name.addr, align 8, !tbaa !1
  %call = call i32 @lstat(i8* %10, %struct.stat* %statb) #1
  %cmp15 = icmp slt i32 %call, 0
  br i1 %cmp15, label %if.then.17, label %if.end.26

if.then.17:                                       ; preds = %if.end
  %11 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 41), align 1, !tbaa !17
  %conv18 = zext i8 %11 to i32
  %cmp19 = icmp sge i32 %conv18, 2
  br i1 %cmp19, label %land.lhs.true.21, label %if.end.25

land.lhs.true.21:                                 ; preds = %if.then.17
  %12 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool = icmp ne i32 %12, 0
  br i1 %tobool, label %if.end.25, label %if.then.22

if.then.22:                                       ; preds = %land.lhs.true.21
  %13 = load i8*, i8** %name.addr, align 8, !tbaa !1
  %call23 = call i32* @__errno_location() #11
  %14 = load i32, i32* %call23, align 4, !tbaa !5
  %call24 = call i8* @sm_errstring(i32 %14)
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.287, i32 0, i32 0), i8* %13, i8* %call24)
  br label %if.end.25

if.end.25:                                        ; preds = %if.then.22, %land.lhs.true.21, %if.then.17
  store i32 0, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.26:                                        ; preds = %if.end
  %st_mode = getelementptr inbounds %struct.stat, %struct.stat* %statb, i32 0, i32 3
  %15 = load i32, i32* %st_mode, align 4, !tbaa !126
  %and = and i32 %15, 61440
  %cmp27 = icmp eq i32 %and, 40960
  br i1 %cmp27, label %if.then.29, label %if.end.44

if.then.29:                                       ; preds = %if.end.26
  %16 = load i8*, i8** %name.addr, align 8, !tbaa !1
  %call30 = call i32 @stat(i8* %16, %struct.stat* %statb) #1
  %cmp31 = icmp slt i32 %call30, 0
  br i1 %cmp31, label %if.then.33, label %if.end.43

if.then.33:                                       ; preds = %if.then.29
  %17 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 41), align 1, !tbaa !17
  %conv34 = zext i8 %17 to i32
  %cmp35 = icmp sge i32 %conv34, 2
  br i1 %cmp35, label %land.lhs.true.37, label %if.end.42

land.lhs.true.37:                                 ; preds = %if.then.33
  %18 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool38 = icmp ne i32 %18, 0
  br i1 %tobool38, label %if.end.42, label %if.then.39

if.then.39:                                       ; preds = %land.lhs.true.37
  %19 = load i8*, i8** %name.addr, align 8, !tbaa !1
  %call40 = call i32* @__errno_location() #11
  %20 = load i32, i32* %call40, align 4, !tbaa !5
  %call41 = call i8* @sm_errstring(i32 %20)
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.287, i32 0, i32 0), i8* %19, i8* %call41)
  br label %if.end.42

if.end.42:                                        ; preds = %if.then.39, %land.lhs.true.37, %if.then.33
  store i32 0, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.43:                                        ; preds = %if.then.29
  br label %if.end.44

if.end.44:                                        ; preds = %if.end.43, %if.end.26
  %st_mode45 = getelementptr inbounds %struct.stat, %struct.stat* %statb, i32 0, i32 3
  %21 = load i32, i32* %st_mode45, align 4, !tbaa !126
  %and46 = and i32 %21, 61440
  %cmp47 = icmp eq i32 %and46, 16384
  br i1 %cmp47, label %if.end.57, label %if.then.49

if.then.49:                                       ; preds = %if.end.44
  %22 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 41), align 1, !tbaa !17
  %conv50 = zext i8 %22 to i32
  %cmp51 = icmp sge i32 %conv50, 2
  br i1 %cmp51, label %land.lhs.true.53, label %if.end.56

land.lhs.true.53:                                 ; preds = %if.then.49
  %23 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool54 = icmp ne i32 %23, 0
  br i1 %tobool54, label %if.end.56, label %if.then.55

if.then.55:                                       ; preds = %land.lhs.true.53
  %24 = load i8*, i8** %name.addr, align 8, !tbaa !1
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.288, i32 0, i32 0), i8* %24)
  br label %if.end.56

if.end.56:                                        ; preds = %if.then.55, %land.lhs.true.53, %if.then.49
  store i32 0, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.57:                                        ; preds = %if.end.44
  %25 = load i8*, i8** %name.addr, align 8, !tbaa !1
  %26 = load i32, i32* @RunAsUid, align 4, !tbaa !5
  %27 = load i32, i32* @RunAsGid, align 4, !tbaa !5
  %28 = load i64, i64* %sff.addr, align 8, !tbaa !92
  %call58 = call i32 @safedirpath(i8* %25, i32 %26, i32 %27, i8* null, i64 %28, i32 0, i32 0)
  store i32 %call58, i32* %i, align 4, !tbaa !5
  %29 = load i32, i32* %i, align 4, !tbaa !5
  %cmp59 = icmp ne i32 %29, 0
  br i1 %cmp59, label %if.then.61, label %if.end.70

if.then.61:                                       ; preds = %if.end.57
  %30 = load i8, i8* getelementptr inbounds ([100 x i8], [100 x i8]* @tTdvect, i32 0, i64 41), align 1, !tbaa !17
  %conv62 = zext i8 %30 to i32
  %cmp63 = icmp sge i32 %conv62, 2
  br i1 %cmp63, label %land.lhs.true.65, label %if.end.69

land.lhs.true.65:                                 ; preds = %if.then.61
  %31 = load volatile i32, i32* @IntSig, align 4, !tbaa !5
  %tobool66 = icmp ne i32 %31, 0
  br i1 %tobool66, label %if.end.69, label %if.then.67

if.then.67:                                       ; preds = %land.lhs.true.65
  %32 = load i8*, i8** %name.addr, align 8, !tbaa !1
  %33 = load i32, i32* %i, align 4, !tbaa !5
  %call68 = call i8* @sm_errstring(i32 %33)
  call void (i8*, ...) @sm_dprintf(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.289, i32 0, i32 0), i8* %32, i8* %call68)
  br label %if.end.69

if.end.69:                                        ; preds = %if.then.67, %land.lhs.true.65, %if.then.61
  br label %if.end.70

if.end.70:                                        ; preds = %if.end.69, %if.end.57
  store i32 1, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

cleanup:                                          ; preds = %if.end.70, %if.end.56, %if.end.42, %if.end.25, %if.then
  %34 = bitcast i32* %i to i8*
  call void @llvm.lifetime.end(i64 4, i8* %34) #1
  %35 = bitcast %struct.stat* %statb to i8*
  call void @llvm.lifetime.end(i64 144, i8* %35) #1
  %36 = load i32, i32* %retval
  ret i32 %36
}

; Function Attrs: inlinehint nounwind uwtable
define available_externally i32 @lstat(i8* nonnull %__path, %struct.stat* nonnull %__statbuf) #5 {
entry:
  %__path.addr = alloca i8*, align 8
  %__statbuf.addr = alloca %struct.stat*, align 8
  store i8* %__path, i8** %__path.addr, align 8, !tbaa !1
  store %struct.stat* %__statbuf, %struct.stat** %__statbuf.addr, align 8, !tbaa !1
  %0 = load i8*, i8** %__path.addr, align 8, !tbaa !1
  %1 = load %struct.stat*, %struct.stat** %__statbuf.addr, align 8, !tbaa !1
  %call = call i32 @__lxstat(i32 1, i8* %0, %struct.stat* %1) #1
  ret i32 %call
}

; Function Attrs: nounwind
declare i32 @__lxstat(i32, i8*, %struct.stat*) #3

; Function Attrs: nounwind uwtable
define internal i64 @read_key_file(i8* %keypath, i64 %key) #0 {
entry:
  %retval = alloca i64, align 8
  %keypath.addr = alloca i8*, align 8
  %key.addr = alloca i64, align 8
  %r = alloca i32, align 4
  %sff = alloca i64, align 8
  %n = alloca i64, align 8
  %keyf = alloca %struct.sm_file*, align 8
  %cleanup.dest.slot = alloca i32
  store i8* %keypath, i8** %keypath.addr, align 8, !tbaa !1
  store i64 %key, i64* %key.addr, align 8, !tbaa !92
  %0 = bitcast i32* %r to i8*
  call void @llvm.lifetime.start(i64 4, i8* %0) #1
  %1 = bitcast i64* %sff to i8*
  call void @llvm.lifetime.start(i64 8, i8* %1) #1
  %2 = bitcast i64* %n to i8*
  call void @llvm.lifetime.start(i64 8, i8* %2) #1
  %3 = bitcast %struct.sm_file** %keyf to i8*
  call void @llvm.lifetime.start(i64 8, i8* %3) #1
  %4 = load i8*, i8** %keypath.addr, align 8, !tbaa !1
  %cmp = icmp eq i8* %4, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %5 = load i8*, i8** %keypath.addr, align 8, !tbaa !1
  %6 = load i8, i8* %5, align 1, !tbaa !17
  %conv = sext i8 %6 to i32
  %cmp1 = icmp eq i32 %conv, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %7 = load i64, i64* %key.addr, align 8, !tbaa !92
  store i64 %7, i64* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end:                                           ; preds = %lor.lhs.false
  store i64 646, i64* %sff, align 8, !tbaa !92
  %8 = load i32, i32* @RealUid, align 4, !tbaa !5
  %cmp3 = icmp eq i32 %8, 0
  br i1 %cmp3, label %if.then.10, label %lor.lhs.false.5

lor.lhs.false.5:                                  ; preds = %if.end
  %9 = load i32, i32* @TrustedUid, align 4, !tbaa !5
  %cmp6 = icmp ne i32 %9, 0
  br i1 %cmp6, label %land.lhs.true, label %if.end.11

land.lhs.true:                                    ; preds = %lor.lhs.false.5
  %10 = load i32, i32* @RealUid, align 4, !tbaa !5
  %11 = load i32, i32* @TrustedUid, align 4, !tbaa !5
  %cmp8 = icmp eq i32 %10, %11
  br i1 %cmp8, label %if.then.10, label %if.end.11

if.then.10:                                       ; preds = %land.lhs.true, %if.end
  %12 = load i64, i64* %sff, align 8, !tbaa !92
  %or = or i64 %12, 8192
  store i64 %or, i64* %sff, align 8, !tbaa !92
  br label %if.end.11

if.end.11:                                        ; preds = %if.then.10, %land.lhs.true, %lor.lhs.false.5
  %13 = load i8*, i8** %keypath.addr, align 8, !tbaa !1
  %14 = load i32, i32* @FileMode, align 4, !tbaa !5
  %15 = load i64, i64* %sff, align 8, !tbaa !92
  %call = call %struct.sm_file* @safefopen(i8* %13, i32 0, i32 %14, i64 %15)
  store %struct.sm_file* %call, %struct.sm_file** %keyf, align 8, !tbaa !1
  %16 = load %struct.sm_file*, %struct.sm_file** %keyf, align 8, !tbaa !1
  %cmp12 = icmp eq %struct.sm_file* %16, null
  br i1 %cmp12, label %if.then.14, label %if.else

if.then.14:                                       ; preds = %if.end.11
  %17 = load i8*, i8** %keypath.addr, align 8, !tbaa !1
  %call15 = call i32* @__errno_location() #11
  %18 = load i32, i32* %call15, align 4, !tbaa !5
  %call16 = call i8* @sm_errstring(i32 %18)
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 3, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0), i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.294, i32 0, i32 0), i8* %17, i8* %call16)
  br label %if.end.23

if.else:                                          ; preds = %if.end.11
  %19 = load %struct.sm_file*, %struct.sm_file** %keyf, align 8, !tbaa !1
  %call17 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fscanf(%struct.sm_file* %19, i32 -2, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.262, i32 0, i32 0), i64* %n)
  store i32 %call17, i32* %r, align 4, !tbaa !5
  %20 = load i32, i32* %r, align 4, !tbaa !5
  %cmp18 = icmp eq i32 %20, 1
  br i1 %cmp18, label %if.then.20, label %if.end.21

if.then.20:                                       ; preds = %if.else
  %21 = load i64, i64* %n, align 8, !tbaa !92
  store i64 %21, i64* %key.addr, align 8, !tbaa !92
  br label %if.end.21

if.end.21:                                        ; preds = %if.then.20, %if.else
  %22 = load %struct.sm_file*, %struct.sm_file** %keyf, align 8, !tbaa !1
  %call22 = call i32 @sm_io_close(%struct.sm_file* %22, i32 -2)
  br label %if.end.23

if.end.23:                                        ; preds = %if.end.21, %if.then.14
  %23 = load i64, i64* %key.addr, align 8, !tbaa !92
  store i64 %23, i64* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

cleanup:                                          ; preds = %if.end.23, %if.then
  %24 = bitcast %struct.sm_file** %keyf to i8*
  call void @llvm.lifetime.end(i64 8, i8* %24) #1
  %25 = bitcast i64* %n to i8*
  call void @llvm.lifetime.end(i64 8, i8* %25) #1
  %26 = bitcast i64* %sff to i8*
  call void @llvm.lifetime.end(i64 8, i8* %26) #1
  %27 = bitcast i32* %r to i8*
  call void @llvm.lifetime.end(i64 4, i8* %27) #1
  %28 = load i64, i64* %retval
  ret i64 %28
}

declare i8* @sm_shmstart(i32, i32, i32, i32*, i32) #2

; Function Attrs: nounwind uwtable
define internal i32 @write_key_file(i8* %keypath, i64 %key) #0 {
entry:
  %retval = alloca i32, align 4
  %keypath.addr = alloca i8*, align 8
  %key.addr = alloca i64, align 8
  %ok = alloca i32, align 4
  %sff = alloca i64, align 8
  %keyf = alloca %struct.sm_file*, align 8
  %cleanup.dest.slot = alloca i32
  %fd = alloca i32, align 4
  %err = alloca i32, align 4
  store i8* %keypath, i8** %keypath.addr, align 8, !tbaa !1
  store i64 %key, i64* %key.addr, align 8, !tbaa !92
  %0 = bitcast i32* %ok to i8*
  call void @llvm.lifetime.start(i64 4, i8* %0) #1
  %1 = bitcast i64* %sff to i8*
  call void @llvm.lifetime.start(i64 8, i8* %1) #1
  %2 = bitcast %struct.sm_file** %keyf to i8*
  call void @llvm.lifetime.start(i64 8, i8* %2) #1
  store i32 0, i32* %ok, align 4, !tbaa !5
  %3 = load i8*, i8** %keypath.addr, align 8, !tbaa !1
  %cmp = icmp eq i8* %3, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %4 = load i8*, i8** %keypath.addr, align 8, !tbaa !1
  %5 = load i8, i8* %4, align 1, !tbaa !17
  %conv = sext i8 %5 to i32
  %cmp1 = icmp eq i32 %conv, 0
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %6 = load i32, i32* %ok, align 4, !tbaa !5
  store i32 %6, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end:                                           ; preds = %lor.lhs.false
  store i64 710, i64* %sff, align 8, !tbaa !92
  %7 = load i32, i32* @TrustedUid, align 4, !tbaa !5
  %cmp3 = icmp ne i32 %7, 0
  br i1 %cmp3, label %land.lhs.true, label %if.end.8

land.lhs.true:                                    ; preds = %if.end
  %8 = load i32, i32* @RealUid, align 4, !tbaa !5
  %9 = load i32, i32* @TrustedUid, align 4, !tbaa !5
  %cmp5 = icmp eq i32 %8, %9
  br i1 %cmp5, label %if.then.7, label %if.end.8

if.then.7:                                        ; preds = %land.lhs.true
  %10 = load i64, i64* %sff, align 8, !tbaa !92
  %or = or i64 %10, 8192
  store i64 %or, i64* %sff, align 8, !tbaa !92
  br label %if.end.8

if.end.8:                                         ; preds = %if.then.7, %land.lhs.true, %if.end
  %11 = load i8*, i8** %keypath.addr, align 8, !tbaa !1
  %12 = load i32, i32* @FileMode, align 4, !tbaa !5
  %13 = load i64, i64* %sff, align 8, !tbaa !92
  %call = call %struct.sm_file* @safefopen(i8* %11, i32 513, i32 %12, i64 %13)
  store %struct.sm_file* %call, %struct.sm_file** %keyf, align 8, !tbaa !1
  %14 = load %struct.sm_file*, %struct.sm_file** %keyf, align 8, !tbaa !1
  %cmp9 = icmp eq %struct.sm_file* %14, null
  br i1 %cmp9, label %if.then.11, label %if.else

if.then.11:                                       ; preds = %if.end.8
  %15 = load i8*, i8** %keypath.addr, align 8, !tbaa !1
  %call12 = call i32* @__errno_location() #11
  %16 = load i32, i32* %call12, align 4, !tbaa !5
  %call13 = call i8* @sm_errstring(i32 %16)
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 3, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0), i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.295, i32 0, i32 0), i8* %15, i8* %call13)
  br label %if.end.40

if.else:                                          ; preds = %if.end.8
  %call14 = call i32 @geteuid() #1
  %cmp15 = icmp eq i32 %call14, 0
  br i1 %cmp15, label %land.lhs.true.17, label %if.end.33

land.lhs.true.17:                                 ; preds = %if.else
  %17 = load i32, i32* @RunAsUid, align 4, !tbaa !5
  %cmp18 = icmp ne i32 %17, 0
  br i1 %cmp18, label %if.then.20, label %if.end.33

if.then.20:                                       ; preds = %land.lhs.true.17
  %18 = bitcast i32* %fd to i8*
  call void @llvm.lifetime.start(i64 4, i8* %18) #1
  %19 = load %struct.sm_file*, %struct.sm_file** %keyf, align 8, !tbaa !1
  %f_file = getelementptr inbounds %struct.sm_file, %struct.sm_file* %19, i32 0, i32 5
  %20 = load i16, i16* %f_file, align 2, !tbaa !169
  %conv21 = sext i16 %20 to i32
  store i32 %conv21, i32* %fd, align 4, !tbaa !5
  %21 = load i32, i32* %fd, align 4, !tbaa !5
  %cmp22 = icmp sge i32 %21, 0
  br i1 %cmp22, label %land.lhs.true.24, label %if.end.32

land.lhs.true.24:                                 ; preds = %if.then.20
  %22 = load i32, i32* %fd, align 4, !tbaa !5
  %23 = load i32, i32* @RunAsUid, align 4, !tbaa !5
  %call25 = call i32 @fchown(i32 %22, i32 %23, i32 -1) #1
  %cmp26 = icmp slt i32 %call25, 0
  br i1 %cmp26, label %if.then.28, label %if.end.32

if.then.28:                                       ; preds = %land.lhs.true.24
  %24 = bitcast i32* %err to i8*
  call void @llvm.lifetime.start(i64 4, i8* %24) #1
  %call29 = call i32* @__errno_location() #11
  %25 = load i32, i32* %call29, align 4, !tbaa !5
  store i32 %25, i32* %err, align 4, !tbaa !5
  %26 = load i8*, i8** %keypath.addr, align 8, !tbaa !1
  %27 = load i32, i32* @RunAsUid, align 4, !tbaa !5
  %conv30 = zext i32 %27 to i64
  %28 = load i32, i32* %err, align 4, !tbaa !5
  %call31 = call i8* @sm_errstring(i32 %28)
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 1, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.7, i32 0, i32 0), i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.296, i32 0, i32 0), i8* %26, i64 %conv30, i8* %call31)
  %29 = bitcast i32* %err to i8*
  call void @llvm.lifetime.end(i64 4, i8* %29) #1
  br label %if.end.32

if.end.32:                                        ; preds = %if.then.28, %land.lhs.true.24, %if.then.20
  %30 = bitcast i32* %fd to i8*
  call void @llvm.lifetime.end(i64 4, i8* %30) #1
  br label %if.end.33

if.end.33:                                        ; preds = %if.end.32, %land.lhs.true.17, %if.else
  %31 = load %struct.sm_file*, %struct.sm_file** %keyf, align 8, !tbaa !1
  %32 = load i64, i64* %key.addr, align 8, !tbaa !92
  %call34 = call i32 (%struct.sm_file*, i32, i8*, ...) @sm_io_fprintf(%struct.sm_file* %31, i32 -2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.297, i32 0, i32 0), i64 %32)
  %cmp35 = icmp ne i32 %call34, -1
  %conv36 = zext i1 %cmp35 to i32
  store i32 %conv36, i32* %ok, align 4, !tbaa !5
  %33 = load %struct.sm_file*, %struct.sm_file** %keyf, align 8, !tbaa !1
  %call37 = call i32 @sm_io_close(%struct.sm_file* %33, i32 -2)
  %cmp38 = icmp ne i32 %call37, -1
  br i1 %cmp38, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end.33
  %34 = load i32, i32* %ok, align 4, !tbaa !5
  %tobool = icmp ne i32 %34, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end.33
  %35 = phi i1 [ false, %if.end.33 ], [ %tobool, %land.rhs ]
  %land.ext = zext i1 %35 to i32
  store i32 %land.ext, i32* %ok, align 4, !tbaa !5
  br label %if.end.40

if.end.40:                                        ; preds = %land.end, %if.then.11
  %36 = load i32, i32* %ok, align 4, !tbaa !5
  store i32 %36, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

cleanup:                                          ; preds = %if.end.40, %if.then
  %37 = bitcast %struct.sm_file** %keyf to i8*
  call void @llvm.lifetime.end(i64 8, i8* %37) #1
  %38 = bitcast i64* %sff to i8*
  call void @llvm.lifetime.end(i64 8, i8* %38) #1
  %39 = bitcast i32* %ok to i8*
  call void @llvm.lifetime.end(i64 4, i8* %39) #1
  %40 = load i32, i32* %retval
  ret i32 %40
}

declare i32 @sm_shmsetowner(i32, i32, i32, i32) #2

; Function Attrs: nounwind uwtable
define internal void @init_sem(i32 %owner) #0 {
entry:
  %owner.addr = alloca i32, align 4
  store i32 %owner, i32* %owner.addr, align 4, !tbaa !5
  ret void
}

declare %struct.sm_file* @safefopen(i8*, i32, i32, i64) #2

declare i32 @sm_io_fscanf(%struct.sm_file*, i32, i8*, ...) #2

; Function Attrs: nounwind
declare i32 @fchown(i32, i32, i32) #3

; Function Attrs: nounwind uwtable
define internal signext i16 @filesys_find(i8* %name, i8* %path, i32 %add) #0 {
entry:
  %retval = alloca i16, align 2
  %name.addr = alloca i8*, align 8
  %path.addr = alloca i8*, align 8
  %add.addr = alloca i32, align 4
  %st = alloca %struct.stat, align 8
  %i = alloca i16, align 2
  %cleanup.dest.slot = alloca i32
  store i8* %name, i8** %name.addr, align 8, !tbaa !1
  store i8* %path, i8** %path.addr, align 8, !tbaa !1
  store i32 %add, i32* %add.addr, align 4, !tbaa !5
  %0 = bitcast %struct.stat* %st to i8*
  call void @llvm.lifetime.start(i64 144, i8* %0) #1
  %1 = bitcast i16* %i to i8*
  call void @llvm.lifetime.start(i64 2, i8* %1) #1
  %2 = load i8*, i8** %path.addr, align 8, !tbaa !1
  %call = call i32 @stat(i8* %2, %struct.stat* %st) #1
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i8*, i8** %path.addr, align 8, !tbaa !1
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.298, i32 0, i32 0), i8* %3)
  store i16 -2, i16* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end:                                           ; preds = %entry
  store i16 0, i16* %i, align 2, !tbaa !88
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %4 = load i16, i16* %i, align 2, !tbaa !88
  %conv = sext i16 %4 to i32
  %5 = load i32*, i32** @PNumFileSys, align 8, !tbaa !1
  %6 = load i32, i32* %5, align 4, !tbaa !5
  %cmp1 = icmp slt i32 %conv, %6
  br i1 %cmp1, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load i16, i16* %i, align 2, !tbaa !88
  %idxprom = sext i16 %7 to i64
  %8 = load %struct.filesys_shared*, %struct.filesys_shared** @PtrFileSys, align 8, !tbaa !1
  %arrayidx = getelementptr inbounds %struct.filesys_shared, %struct.filesys_shared* %8, i64 %idxprom
  %fs_dev = getelementptr inbounds %struct.filesys_shared, %struct.filesys_shared* %arrayidx, i32 0, i32 0
  %9 = load i64, i64* %fs_dev, align 8, !tbaa !170
  %st_dev = getelementptr inbounds %struct.stat, %struct.stat* %st, i32 0, i32 0
  %10 = load i64, i64* %st_dev, align 8, !tbaa !23
  %cmp3 = icmp eq i64 %9, %10
  br i1 %cmp3, label %if.then.5, label %if.end.14

if.then.5:                                        ; preds = %for.body
  %11 = load i16, i16* %i, align 2, !tbaa !88
  %idxprom6 = sext i16 %11 to i64
  %arrayidx7 = getelementptr inbounds [256 x i8*], [256 x i8*]* @FSPath, i32 0, i64 %idxprom6
  %12 = load i8*, i8** %arrayidx7, align 8, !tbaa !1
  %cmp8 = icmp eq i8* null, %12
  br i1 %cmp8, label %if.then.10, label %if.end.13

if.then.10:                                       ; preds = %if.then.5
  %13 = load i8*, i8** %name.addr, align 8, !tbaa !1
  %14 = load i16, i16* %i, align 2, !tbaa !88
  %idxprom11 = sext i16 %14 to i64
  %arrayidx12 = getelementptr inbounds [256 x i8*], [256 x i8*]* @FSPath, i32 0, i64 %idxprom11
  store i8* %13, i8** %arrayidx12, align 8, !tbaa !1
  br label %if.end.13

if.end.13:                                        ; preds = %if.then.10, %if.then.5
  %15 = load i16, i16* %i, align 2, !tbaa !88
  store i16 %15, i16* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.14:                                        ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end.14
  %16 = load i16, i16* %i, align 2, !tbaa !88
  %inc = add i16 %16, 1
  store i16 %inc, i16* %i, align 2, !tbaa !88
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %17 = load i16, i16* %i, align 2, !tbaa !88
  %conv15 = sext i16 %17 to i32
  %cmp16 = icmp sge i32 %conv15, 256
  br i1 %cmp16, label %if.then.18, label %if.end.19

if.then.18:                                       ; preds = %for.end
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.299, i32 0, i32 0), i32 256)
  store i16 -3, i16* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.19:                                        ; preds = %for.end
  %18 = load i32, i32* %add.addr, align 4, !tbaa !5
  %tobool = icmp ne i32 %18, 0
  br i1 %tobool, label %if.end.21, label %if.then.20

if.then.20:                                       ; preds = %if.end.19
  store i16 -1, i16* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.21:                                        ; preds = %if.end.19
  %19 = load i32*, i32** @PNumFileSys, align 8, !tbaa !1
  %20 = load i32, i32* %19, align 4, !tbaa !5
  %inc22 = add nsw i32 %20, 1
  store i32 %inc22, i32* %19, align 4, !tbaa !5
  %21 = load i8*, i8** %name.addr, align 8, !tbaa !1
  %22 = load i16, i16* %i, align 2, !tbaa !88
  %idxprom23 = sext i16 %22 to i64
  %arrayidx24 = getelementptr inbounds [256 x i8*], [256 x i8*]* @FSPath, i32 0, i64 %idxprom23
  store i8* %21, i8** %arrayidx24, align 8, !tbaa !1
  %st_dev25 = getelementptr inbounds %struct.stat, %struct.stat* %st, i32 0, i32 0
  %23 = load i64, i64* %st_dev25, align 8, !tbaa !23
  %24 = load i16, i16* %i, align 2, !tbaa !88
  %idxprom26 = sext i16 %24 to i64
  %25 = load %struct.filesys_shared*, %struct.filesys_shared** @PtrFileSys, align 8, !tbaa !1
  %arrayidx27 = getelementptr inbounds %struct.filesys_shared, %struct.filesys_shared* %25, i64 %idxprom26
  %fs_dev28 = getelementptr inbounds %struct.filesys_shared, %struct.filesys_shared* %arrayidx27, i32 0, i32 0
  store i64 %23, i64* %fs_dev28, align 8, !tbaa !170
  %26 = load i16, i16* %i, align 2, !tbaa !88
  %idxprom29 = sext i16 %26 to i64
  %27 = load %struct.filesys_shared*, %struct.filesys_shared** @PtrFileSys, align 8, !tbaa !1
  %arrayidx30 = getelementptr inbounds %struct.filesys_shared, %struct.filesys_shared* %27, i64 %idxprom29
  %fs_avail = getelementptr inbounds %struct.filesys_shared, %struct.filesys_shared* %arrayidx30, i32 0, i32 1
  store i64 0, i64* %fs_avail, align 8, !tbaa !93
  %28 = load i16, i16* %i, align 2, !tbaa !88
  %idxprom31 = sext i16 %28 to i64
  %29 = load %struct.filesys_shared*, %struct.filesys_shared** @PtrFileSys, align 8, !tbaa !1
  %arrayidx32 = getelementptr inbounds %struct.filesys_shared, %struct.filesys_shared* %29, i64 %idxprom31
  %fs_blksize = getelementptr inbounds %struct.filesys_shared, %struct.filesys_shared* %arrayidx32, i32 0, i32 2
  store i64 1024, i64* %fs_blksize, align 8, !tbaa !90
  %30 = load i16, i16* %i, align 2, !tbaa !88
  store i16 %30, i16* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

cleanup:                                          ; preds = %if.end.21, %if.then.20, %if.then.18, %if.end.13, %if.then
  %31 = bitcast i16* %i to i8*
  call void @llvm.lifetime.end(i64 2, i8* %31) #1
  %32 = bitcast %struct.stat* %st to i8*
  call void @llvm.lifetime.end(i64 144, i8* %32) #1
  %33 = load i16, i16* %retval
  ret i16 %33
}

declare i32 @rscap(i8*, i8*, i8*, %struct.envelope*, i8***, i8*, i32) #2

; Function Attrs: nounwind uwtable
define internal i32 @q_qgrp_compare(i8* %p1, i8* %p2) #0 {
entry:
  %p1.addr = alloca i8*, align 8
  %p2.addr = alloca i8*, align 8
  %pq1 = alloca %struct.address**, align 8
  %pq2 = alloca %struct.address**, align 8
  store i8* %p1, i8** %p1.addr, align 8, !tbaa !1
  store i8* %p2, i8** %p2.addr, align 8, !tbaa !1
  %0 = bitcast %struct.address*** %pq1 to i8*
  call void @llvm.lifetime.start(i64 8, i8* %0) #1
  %1 = load i8*, i8** %p1.addr, align 8, !tbaa !1
  %2 = bitcast i8* %1 to %struct.address**
  store %struct.address** %2, %struct.address*** %pq1, align 8, !tbaa !1
  %3 = bitcast %struct.address*** %pq2 to i8*
  call void @llvm.lifetime.start(i64 8, i8* %3) #1
  %4 = load i8*, i8** %p2.addr, align 8, !tbaa !1
  %5 = bitcast i8* %4 to %struct.address**
  store %struct.address** %5, %struct.address*** %pq2, align 8, !tbaa !1
  %6 = load %struct.address**, %struct.address*** %pq1, align 8, !tbaa !1
  %7 = load %struct.address*, %struct.address** %6, align 8, !tbaa !1
  %q_qgrp = getelementptr inbounds %struct.address, %struct.address* %7, i32 0, i32 23
  %8 = load i32, i32* %q_qgrp, align 4, !tbaa !146
  %9 = load %struct.address**, %struct.address*** %pq2, align 8, !tbaa !1
  %10 = load %struct.address*, %struct.address** %9, align 8, !tbaa !1
  %q_qgrp1 = getelementptr inbounds %struct.address, %struct.address* %10, i32 0, i32 23
  %11 = load i32, i32* %q_qgrp1, align 4, !tbaa !146
  %sub = sub nsw i32 %8, %11
  %12 = bitcast %struct.address*** %pq2 to i8*
  call void @llvm.lifetime.end(i64 8, i8* %12) #1
  %13 = bitcast %struct.address*** %pq1 to i8*
  call void @llvm.lifetime.end(i64 8, i8* %13) #1
  ret i32 %sub
}

; Function Attrs: nounwind uwtable
define internal %struct.envelope* @split_env(%struct.envelope* %e, %struct.address* %sendqueue, i32 %qgrp, i32 %qdir) #0 {
entry:
  %e.addr = alloca %struct.envelope*, align 8
  %sendqueue.addr = alloca %struct.address*, align 8
  %qgrp.addr = alloca i32, align 4
  %qdir.addr = alloca i32, align 4
  %ee = alloca %struct.envelope*, align 8
  store %struct.envelope* %e, %struct.envelope** %e.addr, align 8, !tbaa !1
  store %struct.address* %sendqueue, %struct.address** %sendqueue.addr, align 8, !tbaa !1
  store i32 %qgrp, i32* %qgrp.addr, align 4, !tbaa !5
  store i32 %qdir, i32* %qdir.addr, align 4, !tbaa !5
  %0 = bitcast %struct.envelope** %ee to i8*
  call void @llvm.lifetime.start(i64 8, i8* %0) #1
  %1 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_rpool = getelementptr inbounds %struct.envelope, %struct.envelope* %1, i32 0, i32 52
  %2 = load %struct.SM_RPOOL_T*, %struct.SM_RPOOL_T** %e_rpool, align 8, !tbaa !120
  %3 = load i32, i32* @SmHeapGroup, align 4, !tbaa !5
  %call = call i8* @sm_rpool_malloc_tagged_x(%struct.SM_RPOOL_T* %2, i64 2656, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 7924, i32 %3)
  %4 = bitcast i8* %call to %struct.envelope*
  store %struct.envelope* %4, %struct.envelope** %ee, align 8, !tbaa !1
  %5 = load %struct.envelope*, %struct.envelope** %ee, align 8, !tbaa !1
  %6 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %7 = bitcast %struct.envelope* %5 to i8*
  %8 = bitcast %struct.envelope* %6 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %7, i8* %8, i64 2656, i32 8, i1 false), !tbaa.struct !171
  %9 = load %struct.envelope*, %struct.envelope** %ee, align 8, !tbaa !1
  %e_message = getelementptr inbounds %struct.envelope, %struct.envelope* %9, i32 0, i32 34
  store i8* null, i8** %e_message, align 8, !tbaa !44
  %10 = load %struct.envelope*, %struct.envelope** %ee, align 8, !tbaa !1
  %e_id = getelementptr inbounds %struct.envelope, %struct.envelope* %10, i32 0, i32 25
  store i8* null, i8** %e_id, align 8, !tbaa !7
  %11 = load %struct.envelope*, %struct.envelope** %ee, align 8, !tbaa !1
  call void @assign_queueid(%struct.envelope* %11)
  %12 = load %struct.address*, %struct.address** %sendqueue.addr, align 8, !tbaa !1
  %13 = load %struct.envelope*, %struct.envelope** %ee, align 8, !tbaa !1
  %e_sendqueue = getelementptr inbounds %struct.envelope, %struct.envelope* %13, i32 0, i32 7
  store %struct.address* %12, %struct.address** %e_sendqueue, align 8, !tbaa !20
  %14 = load %struct.envelope*, %struct.envelope** %ee, align 8, !tbaa !1
  %e_flags = getelementptr inbounds %struct.envelope, %struct.envelope* %14, i32 0, i32 11
  %15 = load i64, i64* %e_flags, align 8, !tbaa !15
  %and = and i64 %15, -3145787
  store i64 %and, i64* %e_flags, align 8, !tbaa !15
  %16 = load %struct.envelope*, %struct.envelope** %ee, align 8, !tbaa !1
  %e_flags1 = getelementptr inbounds %struct.envelope, %struct.envelope* %16, i32 0, i32 11
  %17 = load i64, i64* %e_flags1, align 8, !tbaa !15
  %or = or i64 %17, 65536
  store i64 %or, i64* %e_flags1, align 8, !tbaa !15
  %18 = load %struct.envelope*, %struct.envelope** %ee, align 8, !tbaa !1
  %e_from = getelementptr inbounds %struct.envelope, %struct.envelope* %18, i32 0, i32 4
  %q_state = getelementptr inbounds %struct.address, %struct.address* %e_from, i32 0, i32 21
  store i16 8, i16* %q_state, align 2, !tbaa !172
  %19 = load %struct.envelope*, %struct.envelope** %ee, align 8, !tbaa !1
  %e_dfp = getelementptr inbounds %struct.envelope, %struct.envelope* %19, i32 0, i32 24
  store %struct.sm_file* null, %struct.sm_file** %e_dfp, align 8, !tbaa !21
  %20 = load %struct.envelope*, %struct.envelope** %ee, align 8, !tbaa !1
  %e_lockfp = getelementptr inbounds %struct.envelope, %struct.envelope* %20, i32 0, i32 33
  store %struct.sm_file* null, %struct.sm_file** %e_lockfp, align 8, !tbaa !16
  %21 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_xfp = getelementptr inbounds %struct.envelope, %struct.envelope* %21, i32 0, i32 32
  %22 = load %struct.sm_file*, %struct.sm_file** %e_xfp, align 8, !tbaa !173
  %cmp = icmp ne %struct.sm_file* %22, null
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %23 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_xfp2 = getelementptr inbounds %struct.envelope, %struct.envelope* %23, i32 0, i32 32
  %24 = load %struct.sm_file*, %struct.sm_file** %e_xfp2, align 8, !tbaa !173
  %call3 = call %struct.sm_file* @sm_io_dup(%struct.sm_file* %24)
  %25 = load %struct.envelope*, %struct.envelope** %ee, align 8, !tbaa !1
  %e_xfp4 = getelementptr inbounds %struct.envelope, %struct.envelope* %25, i32 0, i32 32
  store %struct.sm_file* %call3, %struct.sm_file** %e_xfp4, align 8, !tbaa !173
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %26 = load %struct.envelope*, %struct.envelope** %ee, align 8, !tbaa !1
  %e_xfp5 = getelementptr inbounds %struct.envelope, %struct.envelope* %26, i32 0, i32 32
  %27 = load %struct.sm_file*, %struct.sm_file** %e_xfp5, align 8, !tbaa !173
  %cmp6 = icmp eq %struct.sm_file* %27, null
  br i1 %cmp6, label %if.then.7, label %if.end.8

if.then.7:                                        ; preds = %if.end
  %28 = load %struct.envelope*, %struct.envelope** %ee, align 8, !tbaa !1
  call void @openxscript(%struct.envelope* %28)
  br label %if.end.8

if.end.8:                                         ; preds = %if.then.7, %if.end
  %29 = load i32, i32* %qgrp.addr, align 4, !tbaa !5
  %30 = load %struct.envelope*, %struct.envelope** %ee, align 8, !tbaa !1
  %e_dfqgrp = getelementptr inbounds %struct.envelope, %struct.envelope* %30, i32 0, i32 28
  store i32 %29, i32* %e_dfqgrp, align 4, !tbaa !36
  %31 = load %struct.envelope*, %struct.envelope** %ee, align 8, !tbaa !1
  %e_qgrp = getelementptr inbounds %struct.envelope, %struct.envelope* %31, i32 0, i32 26
  store i32 %29, i32* %e_qgrp, align 4, !tbaa !18
  %32 = load i32, i32* %qdir.addr, align 4, !tbaa !5
  %33 = load %struct.envelope*, %struct.envelope** %ee, align 8, !tbaa !1
  %e_dfqdir = getelementptr inbounds %struct.envelope, %struct.envelope* %33, i32 0, i32 29
  store i32 %32, i32* %e_dfqdir, align 4, !tbaa !37
  %34 = load %struct.envelope*, %struct.envelope** %ee, align 8, !tbaa !1
  %e_qdir = getelementptr inbounds %struct.envelope, %struct.envelope* %34, i32 0, i32 27
  store i32 %32, i32* %e_qdir, align 4, !tbaa !19
  %35 = load %struct.envelope*, %struct.envelope** %ee, align 8, !tbaa !1
  %e_errormode = getelementptr inbounds %struct.envelope, %struct.envelope* %35, i32 0, i32 17
  store i16 109, i16* %e_errormode, align 2, !tbaa !137
  %36 = load %struct.envelope*, %struct.envelope** %ee, align 8, !tbaa !1
  %e_statmsg = getelementptr inbounds %struct.envelope, %struct.envelope* %36, i32 0, i32 35
  store i8* null, i8** %e_statmsg, align 8, !tbaa !174
  %37 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_quarmsg = getelementptr inbounds %struct.envelope, %struct.envelope* %37, i32 0, i32 36
  %38 = load i8*, i8** %e_quarmsg, align 8, !tbaa !43
  %cmp9 = icmp ne i8* %38, null
  br i1 %cmp9, label %if.then.10, label %if.end.15

if.then.10:                                       ; preds = %if.end.8
  %39 = load %struct.envelope*, %struct.envelope** %ee, align 8, !tbaa !1
  %e_rpool11 = getelementptr inbounds %struct.envelope, %struct.envelope* %39, i32 0, i32 52
  %40 = load %struct.SM_RPOOL_T*, %struct.SM_RPOOL_T** %e_rpool11, align 8, !tbaa !120
  %41 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_quarmsg12 = getelementptr inbounds %struct.envelope, %struct.envelope* %41, i32 0, i32 36
  %42 = load i8*, i8** %e_quarmsg12, align 8, !tbaa !43
  %call13 = call i8* @sm_rpool_strdup_x(%struct.SM_RPOOL_T* %40, i8* %42)
  %43 = load %struct.envelope*, %struct.envelope** %ee, align 8, !tbaa !1
  %e_quarmsg14 = getelementptr inbounds %struct.envelope, %struct.envelope* %43, i32 0, i32 36
  store i8* %call13, i8** %e_quarmsg14, align 8, !tbaa !43
  br label %if.end.15

if.end.15:                                        ; preds = %if.then.10, %if.end.8
  %44 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_header = getelementptr inbounds %struct.envelope, %struct.envelope* %44, i32 0, i32 0
  %45 = load %struct.header*, %struct.header** %e_header, align 8, !tbaa !69
  %46 = load %struct.envelope*, %struct.envelope** %ee, align 8, !tbaa !1
  %e_rpool16 = getelementptr inbounds %struct.envelope, %struct.envelope* %46, i32 0, i32 52
  %47 = load %struct.SM_RPOOL_T*, %struct.SM_RPOOL_T** %e_rpool16, align 8, !tbaa !120
  %call17 = call %struct.header* @copyheader(%struct.header* %45, %struct.SM_RPOOL_T* %47)
  %48 = load %struct.envelope*, %struct.envelope** %ee, align 8, !tbaa !1
  %e_header18 = getelementptr inbounds %struct.envelope, %struct.envelope* %48, i32 0, i32 0
  store %struct.header* %call17, %struct.header** %e_header18, align 8, !tbaa !69
  %49 = load %struct.envelope*, %struct.envelope** %e.addr, align 8, !tbaa !1
  %e_errorqueue = getelementptr inbounds %struct.envelope, %struct.envelope* %49, i32 0, i32 8
  %50 = load %struct.address*, %struct.address** %e_errorqueue, align 8, !tbaa !175
  %51 = load %struct.envelope*, %struct.envelope** %ee, align 8, !tbaa !1
  %e_rpool19 = getelementptr inbounds %struct.envelope, %struct.envelope* %51, i32 0, i32 52
  %52 = load %struct.SM_RPOOL_T*, %struct.SM_RPOOL_T** %e_rpool19, align 8, !tbaa !120
  %call20 = call %struct.address* @copyqueue(%struct.address* %50, %struct.SM_RPOOL_T* %52)
  %53 = load %struct.envelope*, %struct.envelope** %ee, align 8, !tbaa !1
  %e_errorqueue21 = getelementptr inbounds %struct.envelope, %struct.envelope* %53, i32 0, i32 8
  store %struct.address* %call20, %struct.address** %e_errorqueue21, align 8, !tbaa !175
  %54 = load %struct.envelope*, %struct.envelope** %ee, align 8, !tbaa !1
  %55 = bitcast %struct.envelope** %ee to i8*
  call void @llvm.lifetime.end(i64 8, i8* %55) #1
  ret %struct.envelope* %54
}

; Function Attrs: nounwind uwtable
define internal i32 @e_filesys_compare(i8* %p1, i8* %p2) #0 {
entry:
  %retval = alloca i32, align 4
  %p1.addr = alloca i8*, align 8
  %p2.addr = alloca i8*, align 8
  %pe1 = alloca %struct.envelope**, align 8
  %pe2 = alloca %struct.envelope**, align 8
  %fs1 = alloca i32, align 4
  %fs2 = alloca i32, align 4
  %cleanup.dest.slot = alloca i32
  store i8* %p1, i8** %p1.addr, align 8, !tbaa !1
  store i8* %p2, i8** %p2.addr, align 8, !tbaa !1
  %0 = bitcast %struct.envelope*** %pe1 to i8*
  call void @llvm.lifetime.start(i64 8, i8* %0) #1
  %1 = load i8*, i8** %p1.addr, align 8, !tbaa !1
  %2 = bitcast i8* %1 to %struct.envelope**
  store %struct.envelope** %2, %struct.envelope*** %pe1, align 8, !tbaa !1
  %3 = bitcast %struct.envelope*** %pe2 to i8*
  call void @llvm.lifetime.start(i64 8, i8* %3) #1
  %4 = load i8*, i8** %p2.addr, align 8, !tbaa !1
  %5 = bitcast i8* %4 to %struct.envelope**
  store %struct.envelope** %5, %struct.envelope*** %pe2, align 8, !tbaa !1
  %6 = bitcast i32* %fs1 to i8*
  call void @llvm.lifetime.start(i64 4, i8* %6) #1
  %7 = bitcast i32* %fs2 to i8*
  call void @llvm.lifetime.start(i64 4, i8* %7) #1
  %8 = load %struct.envelope**, %struct.envelope*** %pe1, align 8, !tbaa !1
  %9 = load %struct.envelope*, %struct.envelope** %8, align 8, !tbaa !1
  %e_qdir = getelementptr inbounds %struct.envelope, %struct.envelope* %9, i32 0, i32 27
  %10 = load i32, i32* %e_qdir, align 4, !tbaa !19
  %idxprom = sext i32 %10 to i64
  %11 = load %struct.envelope**, %struct.envelope*** %pe1, align 8, !tbaa !1
  %12 = load %struct.envelope*, %struct.envelope** %11, align 8, !tbaa !1
  %e_qgrp = getelementptr inbounds %struct.envelope, %struct.envelope* %12, i32 0, i32 26
  %13 = load i32, i32* %e_qgrp, align 4, !tbaa !18
  %idxprom1 = sext i32 %13 to i64
  %arrayidx = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom1
  %14 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx, align 8, !tbaa !1
  %qg_qpaths = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %14, i32 0, i32 6
  %15 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths, align 8, !tbaa !38
  %arrayidx2 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %15, i64 %idxprom
  %qp_fsysidx = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %arrayidx2, i32 0, i32 2
  %16 = load i16, i16* %qp_fsysidx, align 2, !tbaa !87
  %conv = sext i16 %16 to i32
  store i32 %conv, i32* %fs1, align 4, !tbaa !5
  %17 = load %struct.envelope**, %struct.envelope*** %pe2, align 8, !tbaa !1
  %18 = load %struct.envelope*, %struct.envelope** %17, align 8, !tbaa !1
  %e_qdir3 = getelementptr inbounds %struct.envelope, %struct.envelope* %18, i32 0, i32 27
  %19 = load i32, i32* %e_qdir3, align 4, !tbaa !19
  %idxprom4 = sext i32 %19 to i64
  %20 = load %struct.envelope**, %struct.envelope*** %pe2, align 8, !tbaa !1
  %21 = load %struct.envelope*, %struct.envelope** %20, align 8, !tbaa !1
  %e_qgrp5 = getelementptr inbounds %struct.envelope, %struct.envelope* %21, i32 0, i32 26
  %22 = load i32, i32* %e_qgrp5, align 4, !tbaa !18
  %idxprom6 = sext i32 %22 to i64
  %arrayidx7 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom6
  %23 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx7, align 8, !tbaa !1
  %qg_qpaths8 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %23, i32 0, i32 6
  %24 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths8, align 8, !tbaa !38
  %arrayidx9 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %24, i64 %idxprom4
  %qp_fsysidx10 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %arrayidx9, i32 0, i32 2
  %25 = load i16, i16* %qp_fsysidx10, align 2, !tbaa !87
  %conv11 = sext i16 %25 to i32
  store i32 %conv11, i32* %fs2, align 4, !tbaa !5
  %26 = load i32, i32* %fs1, align 4, !tbaa !5
  %idxprom12 = sext i32 %26 to i64
  %27 = load %struct.filesys_shared*, %struct.filesys_shared** @PtrFileSys, align 8, !tbaa !1
  %arrayidx13 = getelementptr inbounds %struct.filesys_shared, %struct.filesys_shared* %27, i64 %idxprom12
  %fs_dev = getelementptr inbounds %struct.filesys_shared, %struct.filesys_shared* %arrayidx13, i32 0, i32 0
  %28 = load i64, i64* %fs_dev, align 8, !tbaa !170
  %29 = load i32, i32* %fs2, align 4, !tbaa !5
  %idxprom14 = sext i32 %29 to i64
  %30 = load %struct.filesys_shared*, %struct.filesys_shared** @PtrFileSys, align 8, !tbaa !1
  %arrayidx15 = getelementptr inbounds %struct.filesys_shared, %struct.filesys_shared* %30, i64 %idxprom14
  %fs_dev16 = getelementptr inbounds %struct.filesys_shared, %struct.filesys_shared* %arrayidx15, i32 0, i32 0
  %31 = load i64, i64* %fs_dev16, align 8, !tbaa !170
  %cmp = icmp ult i64 %28, %31
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -1, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end:                                           ; preds = %entry
  %32 = load i32, i32* %fs1, align 4, !tbaa !5
  %idxprom18 = sext i32 %32 to i64
  %33 = load %struct.filesys_shared*, %struct.filesys_shared** @PtrFileSys, align 8, !tbaa !1
  %arrayidx19 = getelementptr inbounds %struct.filesys_shared, %struct.filesys_shared* %33, i64 %idxprom18
  %fs_dev20 = getelementptr inbounds %struct.filesys_shared, %struct.filesys_shared* %arrayidx19, i32 0, i32 0
  %34 = load i64, i64* %fs_dev20, align 8, !tbaa !170
  %35 = load i32, i32* %fs2, align 4, !tbaa !5
  %idxprom21 = sext i32 %35 to i64
  %36 = load %struct.filesys_shared*, %struct.filesys_shared** @PtrFileSys, align 8, !tbaa !1
  %arrayidx22 = getelementptr inbounds %struct.filesys_shared, %struct.filesys_shared* %36, i64 %idxprom21
  %fs_dev23 = getelementptr inbounds %struct.filesys_shared, %struct.filesys_shared* %arrayidx22, i32 0, i32 0
  %37 = load i64, i64* %fs_dev23, align 8, !tbaa !170
  %cmp24 = icmp ugt i64 %34, %37
  br i1 %cmp24, label %if.then.26, label %if.end.27

if.then.26:                                       ; preds = %if.end
  store i32 1, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.27:                                        ; preds = %if.end
  store i32 0, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

cleanup:                                          ; preds = %if.end.27, %if.then.26, %if.then
  %38 = bitcast i32* %fs2 to i8*
  call void @llvm.lifetime.end(i64 4, i8* %38) #1
  %39 = bitcast i32* %fs1 to i8*
  call void @llvm.lifetime.end(i64 4, i8* %39) #1
  %40 = bitcast %struct.envelope*** %pe2 to i8*
  call void @llvm.lifetime.end(i64 8, i8* %40) #1
  %41 = bitcast %struct.envelope*** %pe1 to i8*
  call void @llvm.lifetime.end(i64 8, i8* %41) #1
  %42 = load i32, i32* %retval
  ret i32 %42
}

; Function Attrs: nounwind uwtable
define internal i32 @dup_df(%struct.envelope* %old, %struct.envelope* %new) #0 {
entry:
  %retval = alloca i32, align 4
  %old.addr = alloca %struct.envelope*, align 8
  %new.addr = alloca %struct.envelope*, align 8
  %ofs = alloca i32, align 4
  %nfs = alloca i32, align 4
  %r = alloca i32, align 4
  %opath = alloca [4096 x i8], align 16
  %npath = alloca [4096 x i8], align 16
  %cleanup.dest.slot = alloca i32
  store %struct.envelope* %old, %struct.envelope** %old.addr, align 8, !tbaa !1
  store %struct.envelope* %new, %struct.envelope** %new.addr, align 8, !tbaa !1
  %0 = bitcast i32* %ofs to i8*
  call void @llvm.lifetime.start(i64 4, i8* %0) #1
  %1 = bitcast i32* %nfs to i8*
  call void @llvm.lifetime.start(i64 4, i8* %1) #1
  %2 = bitcast i32* %r to i8*
  call void @llvm.lifetime.start(i64 4, i8* %2) #1
  %3 = bitcast [4096 x i8]* %opath to i8*
  call void @llvm.lifetime.start(i64 4096, i8* %3) #1
  %4 = bitcast [4096 x i8]* %npath to i8*
  call void @llvm.lifetime.start(i64 4096, i8* %4) #1
  %5 = load %struct.envelope*, %struct.envelope** %old.addr, align 8, !tbaa !1
  %e_flags = getelementptr inbounds %struct.envelope, %struct.envelope* %5, i32 0, i32 11
  %6 = load i64, i64* %e_flags, align 8, !tbaa !15
  %and = and i64 %6, 2097152
  %cmp = icmp ne i64 %and, 0
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %7 = load %struct.envelope*, %struct.envelope** %old.addr, align 8, !tbaa !1
  call void @queueup(%struct.envelope* %7, i32 0, i32 1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %8 = load %struct.envelope*, %struct.envelope** %old.addr, align 8, !tbaa !1
  %e_qgrp = getelementptr inbounds %struct.envelope, %struct.envelope* %8, i32 0, i32 26
  %9 = load i32, i32* %e_qgrp, align 4, !tbaa !18
  %cmp1 = icmp sge i32 %9, 0
  br i1 %cmp1, label %land.lhs.true, label %lor.rhs

land.lhs.true:                                    ; preds = %if.end
  %10 = load %struct.envelope*, %struct.envelope** %old.addr, align 8, !tbaa !1
  %e_qdir = getelementptr inbounds %struct.envelope, %struct.envelope* %10, i32 0, i32 27
  %11 = load i32, i32* %e_qdir, align 4, !tbaa !19
  %cmp2 = icmp sge i32 %11, 0
  br i1 %cmp2, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.lhs.true, %if.end
  call void @sm_abort_at(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 7834, i8* getelementptr inbounds ([72 x i8], [72 x i8]* @.str.304, i32 0, i32 0)) #12
  unreachable
                                                  ; No predecessors!
  br label %lor.end

lor.end:                                          ; preds = %12, %land.lhs.true
  %13 = phi i1 [ true, %land.lhs.true ], [ false, %12 ]
  %lor.ext = zext i1 %13 to i32
  %14 = load %struct.envelope*, %struct.envelope** %new.addr, align 8, !tbaa !1
  %e_qgrp3 = getelementptr inbounds %struct.envelope, %struct.envelope* %14, i32 0, i32 26
  %15 = load i32, i32* %e_qgrp3, align 4, !tbaa !18
  %cmp4 = icmp sge i32 %15, 0
  br i1 %cmp4, label %land.lhs.true.5, label %lor.rhs.8

land.lhs.true.5:                                  ; preds = %lor.end
  %16 = load %struct.envelope*, %struct.envelope** %new.addr, align 8, !tbaa !1
  %e_qdir6 = getelementptr inbounds %struct.envelope, %struct.envelope* %16, i32 0, i32 27
  %17 = load i32, i32* %e_qdir6, align 4, !tbaa !19
  %cmp7 = icmp sge i32 %17, 0
  br i1 %cmp7, label %lor.end.9, label %lor.rhs.8

lor.rhs.8:                                        ; preds = %land.lhs.true.5, %lor.end
  call void @sm_abort_at(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 7835, i8* getelementptr inbounds ([72 x i8], [72 x i8]* @.str.305, i32 0, i32 0)) #12
  unreachable
                                                  ; No predecessors!
  br label %lor.end.9

lor.end.9:                                        ; preds = %18, %land.lhs.true.5
  %19 = phi i1 [ true, %land.lhs.true.5 ], [ false, %18 ]
  %lor.ext10 = zext i1 %19 to i32
  %arraydecay = getelementptr inbounds [4096 x i8], [4096 x i8]* %opath, i32 0, i32 0
  %20 = load %struct.envelope*, %struct.envelope** %old.addr, align 8, !tbaa !1
  %call = call i8* @queuename(%struct.envelope* %20, i32 100)
  %call11 = call i64 @sm_strlcpy(i8* %arraydecay, i8* %call, i64 4096)
  %arraydecay12 = getelementptr inbounds [4096 x i8], [4096 x i8]* %npath, i32 0, i32 0
  %21 = load %struct.envelope*, %struct.envelope** %new.addr, align 8, !tbaa !1
  %call13 = call i8* @queuename(%struct.envelope* %21, i32 100)
  %call14 = call i64 @sm_strlcpy(i8* %arraydecay12, i8* %call13, i64 4096)
  %22 = load %struct.envelope*, %struct.envelope** %old.addr, align 8, !tbaa !1
  %e_dfp = getelementptr inbounds %struct.envelope, %struct.envelope* %22, i32 0, i32 24
  %23 = load %struct.sm_file*, %struct.sm_file** %e_dfp, align 8, !tbaa !21
  %cmp15 = icmp ne %struct.sm_file* %23, null
  br i1 %cmp15, label %if.then.16, label %if.end.27

if.then.16:                                       ; preds = %lor.end.9
  %24 = load %struct.envelope*, %struct.envelope** %old.addr, align 8, !tbaa !1
  %e_dfp17 = getelementptr inbounds %struct.envelope, %struct.envelope* %24, i32 0, i32 24
  %25 = load %struct.sm_file*, %struct.sm_file** %e_dfp17, align 8, !tbaa !21
  %call18 = call i32 @sm_io_setinfo(%struct.sm_file* %25, i32 1001, i8* null)
  store i32 %call18, i32* %r, align 4, !tbaa !5
  %26 = load i32, i32* %r, align 4, !tbaa !5
  %cmp19 = icmp slt i32 %26, 0
  br i1 %cmp19, label %land.lhs.true.20, label %if.end.26

land.lhs.true.20:                                 ; preds = %if.then.16
  %call21 = call i32* @__errno_location() #11
  %27 = load i32, i32* %call21, align 4, !tbaa !5
  %cmp22 = icmp ne i32 %27, 22
  br i1 %cmp22, label %if.then.23, label %if.end.26

if.then.23:                                       ; preds = %land.lhs.true.20
  %arraydecay24 = getelementptr inbounds [4096 x i8], [4096 x i8]* %opath, i32 0, i32 0
  call void (i8*, ...) @syserr(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.306, i32 0, i32 0), i8* %arraydecay24)
  %28 = load %struct.envelope*, %struct.envelope** %old.addr, align 8, !tbaa !1
  %e_flags25 = getelementptr inbounds %struct.envelope, %struct.envelope* %28, i32 0, i32 11
  %29 = load i64, i64* %e_flags25, align 8, !tbaa !15
  %or = or i64 %29, 32
  store i64 %or, i64* %e_flags25, align 8, !tbaa !15
  store i32 0, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.26:                                        ; preds = %land.lhs.true.20, %if.then.16
  br label %if.end.27

if.end.27:                                        ; preds = %if.end.26, %lor.end.9
  %30 = load %struct.envelope*, %struct.envelope** %old.addr, align 8, !tbaa !1
  %e_dfqgrp = getelementptr inbounds %struct.envelope, %struct.envelope* %30, i32 0, i32 28
  %31 = load i32, i32* %e_dfqgrp, align 4, !tbaa !36
  %cmp28 = icmp sge i32 %31, 0
  br i1 %cmp28, label %land.lhs.true.29, label %lor.rhs.31

land.lhs.true.29:                                 ; preds = %if.end.27
  %32 = load %struct.envelope*, %struct.envelope** %old.addr, align 8, !tbaa !1
  %e_dfqdir = getelementptr inbounds %struct.envelope, %struct.envelope* %32, i32 0, i32 29
  %33 = load i32, i32* %e_dfqdir, align 4, !tbaa !37
  %cmp30 = icmp sge i32 %33, 0
  br i1 %cmp30, label %lor.end.32, label %lor.rhs.31

lor.rhs.31:                                       ; preds = %land.lhs.true.29, %if.end.27
  call void @sm_abort_at(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 7859, i8* getelementptr inbounds ([76 x i8], [76 x i8]* @.str.307, i32 0, i32 0)) #12
  unreachable
                                                  ; No predecessors!
  br label %lor.end.32

lor.end.32:                                       ; preds = %34, %land.lhs.true.29
  %35 = phi i1 [ true, %land.lhs.true.29 ], [ false, %34 ]
  %lor.ext33 = zext i1 %35 to i32
  %36 = load %struct.envelope*, %struct.envelope** %new.addr, align 8, !tbaa !1
  %e_dfqgrp34 = getelementptr inbounds %struct.envelope, %struct.envelope* %36, i32 0, i32 28
  %37 = load i32, i32* %e_dfqgrp34, align 4, !tbaa !36
  %cmp35 = icmp sge i32 %37, 0
  br i1 %cmp35, label %land.lhs.true.36, label %lor.rhs.39

land.lhs.true.36:                                 ; preds = %lor.end.32
  %38 = load %struct.envelope*, %struct.envelope** %new.addr, align 8, !tbaa !1
  %e_dfqdir37 = getelementptr inbounds %struct.envelope, %struct.envelope* %38, i32 0, i32 29
  %39 = load i32, i32* %e_dfqdir37, align 4, !tbaa !37
  %cmp38 = icmp sge i32 %39, 0
  br i1 %cmp38, label %lor.end.40, label %lor.rhs.39

lor.rhs.39:                                       ; preds = %land.lhs.true.36, %lor.end.32
  call void @sm_abort_at(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.47, i32 0, i32 0), i32 7860, i8* getelementptr inbounds ([76 x i8], [76 x i8]* @.str.308, i32 0, i32 0)) #12
  unreachable
                                                  ; No predecessors!
  br label %lor.end.40

lor.end.40:                                       ; preds = %40, %land.lhs.true.36
  %41 = phi i1 [ true, %land.lhs.true.36 ], [ false, %40 ]
  %lor.ext41 = zext i1 %41 to i32
  %42 = load %struct.envelope*, %struct.envelope** %old.addr, align 8, !tbaa !1
  %e_dfqdir42 = getelementptr inbounds %struct.envelope, %struct.envelope* %42, i32 0, i32 29
  %43 = load i32, i32* %e_dfqdir42, align 4, !tbaa !37
  %idxprom = sext i32 %43 to i64
  %44 = load %struct.envelope*, %struct.envelope** %old.addr, align 8, !tbaa !1
  %e_dfqgrp43 = getelementptr inbounds %struct.envelope, %struct.envelope* %44, i32 0, i32 28
  %45 = load i32, i32* %e_dfqgrp43, align 4, !tbaa !36
  %idxprom44 = sext i32 %45 to i64
  %arrayidx = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom44
  %46 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx, align 8, !tbaa !1
  %qg_qpaths = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %46, i32 0, i32 6
  %47 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths, align 8, !tbaa !38
  %arrayidx45 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %47, i64 %idxprom
  %qp_fsysidx = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %arrayidx45, i32 0, i32 2
  %48 = load i16, i16* %qp_fsysidx, align 2, !tbaa !87
  %conv = sext i16 %48 to i32
  store i32 %conv, i32* %ofs, align 4, !tbaa !5
  %49 = load %struct.envelope*, %struct.envelope** %new.addr, align 8, !tbaa !1
  %e_dfqdir46 = getelementptr inbounds %struct.envelope, %struct.envelope* %49, i32 0, i32 29
  %50 = load i32, i32* %e_dfqdir46, align 4, !tbaa !37
  %idxprom47 = sext i32 %50 to i64
  %51 = load %struct.envelope*, %struct.envelope** %new.addr, align 8, !tbaa !1
  %e_dfqgrp48 = getelementptr inbounds %struct.envelope, %struct.envelope* %51, i32 0, i32 28
  %52 = load i32, i32* %e_dfqgrp48, align 4, !tbaa !36
  %idxprom49 = sext i32 %52 to i64
  %arrayidx50 = getelementptr inbounds [51 x %struct.queuegrp*], [51 x %struct.queuegrp*]* @Queue, i32 0, i64 %idxprom49
  %53 = load %struct.queuegrp*, %struct.queuegrp** %arrayidx50, align 8, !tbaa !1
  %qg_qpaths51 = getelementptr inbounds %struct.queuegrp, %struct.queuegrp* %53, i32 0, i32 6
  %54 = load %struct.qpaths_s*, %struct.qpaths_s** %qg_qpaths51, align 8, !tbaa !38
  %arrayidx52 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %54, i64 %idxprom47
  %qp_fsysidx53 = getelementptr inbounds %struct.qpaths_s, %struct.qpaths_s* %arrayidx52, i32 0, i32 2
  %55 = load i16, i16* %qp_fsysidx53, align 2, !tbaa !87
  %conv54 = sext i16 %55 to i32
  store i32 %conv54, i32* %nfs, align 4, !tbaa !5
  %56 = load i32, i32* %ofs, align 4, !tbaa !5
  %idxprom55 = sext i32 %56 to i64
  %57 = load %struct.filesys_shared*, %struct.filesys_shared** @PtrFileSys, align 8, !tbaa !1
  %arrayidx56 = getelementptr inbounds %struct.filesys_shared, %struct.filesys_shared* %57, i64 %idxprom55
  %fs_dev = getelementptr inbounds %struct.filesys_shared, %struct.filesys_shared* %arrayidx56, i32 0, i32 0
  %58 = load i64, i64* %fs_dev, align 8, !tbaa !170
  %59 = load i32, i32* %nfs, align 4, !tbaa !5
  %idxprom57 = sext i32 %59 to i64
  %60 = load %struct.filesys_shared*, %struct.filesys_shared** @PtrFileSys, align 8, !tbaa !1
  %arrayidx58 = getelementptr inbounds %struct.filesys_shared, %struct.filesys_shared* %60, i64 %idxprom57
  %fs_dev59 = getelementptr inbounds %struct.filesys_shared, %struct.filesys_shared* %arrayidx58, i32 0, i32 0
  %61 = load i64, i64* %fs_dev59, align 8, !tbaa !170
  %cmp60 = icmp eq i64 %58, %61
  br i1 %cmp60, label %if.then.62, label %if.end.73

if.then.62:                                       ; preds = %lor.end.40
  %arraydecay63 = getelementptr inbounds [4096 x i8], [4096 x i8]* %opath, i32 0, i32 0
  %arraydecay64 = getelementptr inbounds [4096 x i8], [4096 x i8]* %npath, i32 0, i32 0
  %call65 = call i32 @link(i8* %arraydecay63, i8* %arraydecay64) #1
  %cmp66 = icmp eq i32 %call65, 0
  br i1 %cmp66, label %if.then.68, label %if.end.72

if.then.68:                                       ; preds = %if.then.62
  %62 = load %struct.envelope*, %struct.envelope** %new.addr, align 8, !tbaa !1
  %e_flags69 = getelementptr inbounds %struct.envelope, %struct.envelope* %62, i32 0, i32 11
  %63 = load i64, i64* %e_flags69, align 8, !tbaa !15
  %or70 = or i64 %63, 2097152
  store i64 %or70, i64* %e_flags69, align 8, !tbaa !15
  %arraydecay71 = getelementptr inbounds [4096 x i8], [4096 x i8]* %npath, i32 0, i32 0
  call void @sync_dir(i8* %arraydecay71, i32 1)
  store i32 1, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.72:                                        ; preds = %if.then.62
  br label %error

if.end.73:                                        ; preds = %lor.end.40
  %64 = load %struct.envelope*, %struct.envelope** %old.addr, align 8, !tbaa !1
  %e_dfqgrp74 = getelementptr inbounds %struct.envelope, %struct.envelope* %64, i32 0, i32 28
  %65 = load i32, i32* %e_dfqgrp74, align 4, !tbaa !36
  %66 = load %struct.envelope*, %struct.envelope** %new.addr, align 8, !tbaa !1
  %e_dfqgrp75 = getelementptr inbounds %struct.envelope, %struct.envelope* %66, i32 0, i32 28
  store i32 %65, i32* %e_dfqgrp75, align 4, !tbaa !36
  %67 = load %struct.envelope*, %struct.envelope** %old.addr, align 8, !tbaa !1
  %e_dfqdir76 = getelementptr inbounds %struct.envelope, %struct.envelope* %67, i32 0, i32 29
  %68 = load i32, i32* %e_dfqdir76, align 4, !tbaa !37
  %69 = load %struct.envelope*, %struct.envelope** %new.addr, align 8, !tbaa !1
  %e_dfqdir77 = getelementptr inbounds %struct.envelope, %struct.envelope* %69, i32 0, i32 29
  store i32 %68, i32* %e_dfqdir77, align 4, !tbaa !37
  %arraydecay78 = getelementptr inbounds [4096 x i8], [4096 x i8]* %npath, i32 0, i32 0
  %70 = load %struct.envelope*, %struct.envelope** %new.addr, align 8, !tbaa !1
  %call79 = call i8* @queuename(%struct.envelope* %70, i32 100)
  %call80 = call i64 @sm_strlcpy(i8* %arraydecay78, i8* %call79, i64 4096)
  %arraydecay81 = getelementptr inbounds [4096 x i8], [4096 x i8]* %opath, i32 0, i32 0
  %arraydecay82 = getelementptr inbounds [4096 x i8], [4096 x i8]* %npath, i32 0, i32 0
  %call83 = call i32 @link(i8* %arraydecay81, i8* %arraydecay82) #1
  %cmp84 = icmp eq i32 %call83, 0
  br i1 %cmp84, label %if.then.86, label %if.end.90

if.then.86:                                       ; preds = %if.end.73
  %71 = load %struct.envelope*, %struct.envelope** %new.addr, align 8, !tbaa !1
  %e_flags87 = getelementptr inbounds %struct.envelope, %struct.envelope* %71, i32 0, i32 11
  %72 = load i64, i64* %e_flags87, align 8, !tbaa !15
  %or88 = or i64 %72, 2097152
  store i64 %or88, i64* %e_flags87, align 8, !tbaa !15
  %arraydecay89 = getelementptr inbounds [4096 x i8], [4096 x i8]* %npath, i32 0, i32 0
  call void @sync_dir(i8* %arraydecay89, i32 1)
  store i32 1, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

if.end.90:                                        ; preds = %if.end.73
  br label %error

error:                                            ; preds = %if.end.90, %if.end.72
  %73 = load i32, i32* @LogLevel, align 4, !tbaa !5
  %cmp91 = icmp sgt i32 %73, 0
  br i1 %cmp91, label %if.then.93, label %if.end.98

if.then.93:                                       ; preds = %error
  %74 = load %struct.envelope*, %struct.envelope** %old.addr, align 8, !tbaa !1
  %e_id = getelementptr inbounds %struct.envelope, %struct.envelope* %74, i32 0, i32 25
  %75 = load i8*, i8** %e_id, align 8, !tbaa !7
  %arraydecay94 = getelementptr inbounds [4096 x i8], [4096 x i8]* %opath, i32 0, i32 0
  %arraydecay95 = getelementptr inbounds [4096 x i8], [4096 x i8]* %npath, i32 0, i32 0
  %call96 = call i32* @__errno_location() #11
  %76 = load i32, i32* %call96, align 4, !tbaa !5
  %call97 = call i8* @sm_errstring(i32 %76)
  call void (i32, i8*, i8*, ...) @sm_syslog(i32 3, i8* %75, i8* getelementptr inbounds ([65 x i8], [65 x i8]* @.str.309, i32 0, i32 0), i8* %arraydecay94, i8* %arraydecay95, i8* %call97)
  br label %if.end.98

if.end.98:                                        ; preds = %if.then.93, %error
  store i32 0, i32* %retval
  store i32 1, i32* %cleanup.dest.slot
  br label %cleanup

cleanup:                                          ; preds = %if.end.98, %if.then.86, %if.then.68, %if.then.23
  %77 = bitcast [4096 x i8]* %npath to i8*
  call void @llvm.lifetime.end(i64 4096, i8* %77) #1
  %78 = bitcast [4096 x i8]* %opath to i8*
  call void @llvm.lifetime.end(i64 4096, i8* %78) #1
  %79 = bitcast i32* %r to i8*
  call void @llvm.lifetime.end(i64 4, i8* %79) #1
  %80 = bitcast i32* %nfs to i8*
  call void @llvm.lifetime.end(i64 4, i8* %80) #1
  %81 = bitcast i32* %ofs to i8*
  call void @llvm.lifetime.end(i64 4, i8* %81) #1
  %82 = load i32, i32* %retval
  ret i32 %82
}

; Function Attrs: nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture, i8* nocapture readonly, i64, i32, i1) #1

declare %struct.sm_file* @sm_io_dup(%struct.sm_file*) #2

declare %struct.header* @copyheader(%struct.header*, %struct.SM_RPOOL_T*) #2

declare %struct.address* @copyqueue(%struct.address*, %struct.SM_RPOOL_T*) #2

; Function Attrs: nounwind
declare i32 @link(i8*, i8*) #3

attributes #0 = { nounwind uwtable "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind }
attributes #2 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind readnone "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { inlinehint nounwind uwtable "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { inlinehint nounwind readnone uwtable "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #7 = { inlinehint nounwind readonly uwtable "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #8 = { nounwind readonly "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #9 = { noreturn "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #10 = { noreturn nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #11 = { nounwind readnone }
attributes #12 = { noreturn }
attributes #13 = { noreturn nounwind }
attributes #14 = { nounwind readonly }

!llvm.ident = !{!0}

!0 = !{!"clang version 3.7.0 (tags/RELEASE_370/final)"}
!1 = !{!2, !2, i64 0}
!2 = !{!"any pointer", !3, i64 0}
!3 = !{!"omnipotent char", !4, i64 0}
!4 = !{!"Simple C/C++ TBAA"}
!5 = !{!6, !6, i64 0}
!6 = !{!"int", !3, i64 0}
!7 = !{!8, !2, i64 344}
!8 = !{!"envelope", !2, i64 0, !9, i64 8, !9, i64 16, !2, i64 24, !10, i64 32, !2, i64 224, !2, i64 232, !2, i64 240, !2, i64 248, !9, i64 256, !2, i64 264, !9, i64 272, !6, i64 280, !11, i64 284, !11, i64 286, !11, i64 288, !11, i64 290, !11, i64 292, !11, i64 294, !2, i64 296, !2, i64 304, !2, i64 312, !2, i64 320, !2, i64 328, !2, i64 336, !2, i64 344, !6, i64 352, !6, i64 356, !6, i64 360, !6, i64 364, !6, i64 368, !6, i64 372, !2, i64 376, !2, i64 384, !2, i64 392, !2, i64 400, !2, i64 408, !3, i64 416, !2, i64 424, !2, i64 432, !2, i64 440, !2, i64 448, !9, i64 456, !6, i64 464, !9, i64 472, !9, i64 480, !12, i64 488, !2, i64 2576, !2, i64 2584, !13, i64 2592, !9, i64 2624, !6, i64 2632, !2, i64 2640, !6, i64 2648}
!9 = !{!"long", !3, i64 0}
!10 = !{!"address", !2, i64 0, !2, i64 8, !2, i64 16, !2, i64 24, !2, i64 32, !9, i64 40, !6, i64 48, !6, i64 52, !2, i64 56, !2, i64 64, !2, i64 72, !2, i64 80, !2, i64 88, !2, i64 96, !2, i64 104, !2, i64 112, !2, i64 120, !2, i64 128, !2, i64 136, !9, i64 144, !2, i64 152, !11, i64 160, !2, i64 168, !6, i64 176, !6, i64 180, !2, i64 184}
!11 = !{!"short", !3, i64 0}
!12 = !{!"", !2, i64 0, !3, i64 8, !3, i64 40}
!13 = !{!"sm_timers", !14, i64 0}
!14 = !{!"_timer", !9, i64 0, !9, i64 8, !9, i64 16, !9, i64 24}
!15 = !{!8, !9, i64 272}
!16 = !{!8, !2, i64 384}
!17 = !{!3, !3, i64 0}
!18 = !{!8, !6, i64 352}
!19 = !{!8, !6, i64 356}
!20 = !{!8, !2, i64 240}
!21 = !{!8, !2, i64 336}
!22 = !{!8, !9, i64 480}
!23 = !{!24, !9, i64 0}
!24 = !{!"stat", !9, i64 0, !9, i64 8, !9, i64 16, !6, i64 24, !6, i64 28, !6, i64 32, !6, i64 36, !9, i64 40, !9, i64 48, !9, i64 56, !9, i64 64, !25, i64 72, !25, i64 88, !25, i64 104, !3, i64 120}
!25 = !{!"timespec", !9, i64 0, !9, i64 8}
!26 = !{!8, !9, i64 472}
!27 = !{!24, !9, i64 8}
!28 = !{!29, !2, i64 40}
!29 = !{!"mailer_con_info", !9, i64 0, !11, i64 8, !11, i64 10, !11, i64 12, !11, i64 14, !6, i64 16, !9, i64 24, !2, i64 32, !2, i64 40, !6, i64 48, !2, i64 56, !2, i64 64, !2, i64 72, !2, i64 80, !2, i64 88, !9, i64 96, !2, i64 104, !2, i64 112, !9, i64 120, !6, i64 128, !2, i64 136, !2, i64 144, !6, i64 152, !2, i64 160, !12, i64 168}
!30 = !{!29, !2, i64 64}
!31 = !{!8, !2, i64 304}
!32 = !{!8, !9, i64 16}
!33 = !{!8, !9, i64 456}
!34 = !{!8, !6, i64 464}
!35 = !{!8, !9, i64 8}
!36 = !{!8, !6, i64 360}
!37 = !{!8, !6, i64 364}
!38 = !{!39, !2, i64 40}
!39 = !{!"queuegrp", !2, i64 0, !2, i64 8, !11, i64 16, !6, i64 20, !6, i64 24, !9, i64 32, !2, i64 40, !3, i64 48, !11, i64 80, !6, i64 84, !6, i64 88, !6, i64 92, !6, i64 96, !9, i64 104}
!40 = !{!41, !2, i64 0}
!41 = !{!"qpaths_s", !2, i64 0, !11, i64 8, !11, i64 10, !6, i64 12}
!42 = !{!8, !2, i64 328}
!43 = !{!8, !2, i64 408}
!44 = !{!8, !2, i64 392}
!45 = !{!8, !2, i64 64}
!46 = !{!8, !2, i64 224}
!47 = !{!8, !2, i64 32}
!48 = !{!8, !2, i64 440}
!49 = !{!8, !2, i64 2584}
!50 = !{!8, !6, i64 2632}
!51 = !{!8, !9, i64 2624}
!52 = !{!10, !11, i64 160}
!53 = !{!10, !2, i64 184}
!54 = !{!10, !2, i64 120}
!55 = !{!10, !2, i64 112}
!56 = !{!10, !9, i64 40}
!57 = !{!10, !2, i64 80}
!58 = !{!10, !2, i64 0}
!59 = !{!8, !2, i64 24}
!60 = !{!10, !2, i64 32}
!61 = !{!10, !2, i64 128}
!62 = !{!10, !2, i64 72}
!63 = !{!64, !11, i64 88}
!64 = !{!"mailer", !2, i64 0, !2, i64 8, !2, i64 16, !2, i64 24, !2, i64 32, !3, i64 40, !11, i64 72, !11, i64 74, !2, i64 80, !11, i64 88, !11, i64 90, !11, i64 92, !11, i64 94, !2, i64 96, !9, i64 104, !6, i64 112, !6, i64 116, !2, i64 120, !2, i64 128, !6, i64 136, !6, i64 140, !2, i64 144, !9, i64 152, !6, i64 160, !11, i64 164}
!65 = !{!64, !11, i64 90}
!66 = !{!64, !11, i64 92}
!67 = !{!64, !11, i64 94}
!68 = !{!64, !2, i64 96}
!69 = !{!8, !2, i64 0}
!70 = !{!71, !2, i64 8}
!71 = !{!"header", !2, i64 0, !2, i64 8, !2, i64 16, !3, i64 24, !9, i64 32, !3, i64 40}
!72 = !{!71, !9, i64 32}
!73 = !{!71, !3, i64 24}
!74 = !{!71, !2, i64 0}
!75 = !{!71, !2, i64 16}
!76 = !{!77, !9, i64 24}
!77 = !{!"sm_file", !2, i64 0, !2, i64 8, !6, i64 16, !6, i64 20, !9, i64 24, !11, i64 32, !78, i64 40, !6, i64 56, !2, i64 64, !6, i64 72, !2, i64 80, !2, i64 88, !2, i64 96, !2, i64 104, !2, i64 112, !2, i64 120, !2, i64 128, !6, i64 136, !6, i64 140, !2, i64 144, !2, i64 152, !2, i64 160, !78, i64 168, !2, i64 184, !6, i64 192, !3, i64 196, !3, i64 199, !6, i64 200, !9, i64 208, !6, i64 216}
!78 = !{!"smbuf", !2, i64 0, !6, i64 8}
!79 = !{!8, !3, i64 416}
!80 = !{!8, !6, i64 368}
!81 = !{!8, !6, i64 372}
!82 = !{!39, !6, i64 24}
!83 = !{!41, !11, i64 8}
!84 = !{!41, !6, i64 12}
!85 = !{!86, !6, i64 0}
!86 = !{!"queue_shared", !6, i64 0}
!87 = !{!41, !11, i64 10}
!88 = !{!11, !11, i64 0}
!89 = !{!8, !9, i64 256}
!90 = !{!91, !9, i64 16}
!91 = !{!"filesys_shared", !9, i64 0, !9, i64 8, !9, i64 16}
!92 = !{!9, !9, i64 0}
!93 = !{!91, !9, i64 8}
!94 = !{!39, !2, i64 8}
!95 = !{!96, !96, i64 0}
!96 = !{!"long long", !3, i64 0}
!97 = !{!10, !2, i64 16}
!98 = !{!10, !2, i64 8}
!99 = !{!10, !6, i64 48}
!100 = !{!10, !6, i64 52}
!101 = !{!102, !6, i64 40}
!102 = !{!"workgrp", !6, i64 0, !6, i64 4, !6, i64 8, !2, i64 16, !6, i64 24, !9, i64 32, !6, i64 40, !6, i64 44}
!103 = !{!102, !6, i64 44}
!104 = !{!105, !6, i64 8}
!105 = !{!"sm_debug", !2, i64 0, !6, i64 8, !2, i64 16, !2, i64 24, !2, i64 32}
!106 = !{!102, !2, i64 16}
!107 = !{!102, !6, i64 0}
!108 = !{!102, !6, i64 24}
!109 = !{!102, !9, i64 32}
!110 = !{!8, !2, i64 312}
!111 = !{!102, !6, i64 8}
!112 = !{!39, !11, i64 16}
!113 = !{!39, !9, i64 104}
!114 = !{!39, !6, i64 92}
!115 = !{!39, !11, i64 80}
!116 = !{!39, !6, i64 88}
!117 = !{!39, !6, i64 20}
!118 = !{!119, !2, i64 56}
!119 = !{!"work", !2, i64 0, !2, i64 8, !6, i64 16, !6, i64 20, !9, i64 24, !9, i64 32, !9, i64 40, !6, i64 48, !6, i64 52, !2, i64 56}
!120 = !{!8, !2, i64 2640}
!121 = !{!39, !9, i64 32}
!122 = !{!123, !6, i64 8}
!123 = !{!"queue_char", !2, i64 0, !6, i64 8, !2, i64 16}
!124 = !{!123, !2, i64 0}
!125 = !{!123, !2, i64 16}
!126 = !{!24, !6, i64 24}
!127 = !{!119, !6, i64 48}
!128 = !{!119, !6, i64 52}
!129 = !{!119, !2, i64 0}
!130 = !{!119, !2, i64 8}
!131 = !{!119, !6, i64 20}
!132 = !{!119, !6, i64 16}
!133 = !{!119, !9, i64 24}
!134 = !{!119, !9, i64 32}
!135 = !{!24, !9, i64 88}
!136 = !{!119, !9, i64 40}
!137 = !{!8, !11, i64 292}
!138 = !{!24, !9, i64 16}
!139 = !{!24, !6, i64 28}
!140 = !{!24, !6, i64 32}
!141 = !{!24, !9, i64 48}
!142 = !{!24, !9, i64 104}
!143 = !{!144, !6, i64 4}
!144 = !{!"__res_state", !6, i64 0, !6, i64 4, !9, i64 8, !6, i64 16, !3, i64 20, !11, i64 68, !3, i64 72, !3, i64 128, !9, i64 384, !6, i64 392, !6, i64 392, !6, i64 393, !6, i64 393, !3, i64 396, !2, i64 480, !2, i64 488, !6, i64 496, !6, i64 500, !6, i64 504, !3, i64 512}
!145 = !{!144, !6, i64 0}
!146 = !{!10, !6, i64 176}
!147 = !{!8, !11, i64 290}
!148 = !{!8, !2, i64 320}
!149 = !{!150, !6, i64 20}
!150 = !{!"tm", !6, i64 0, !6, i64 4, !6, i64 8, !6, i64 12, !6, i64 16, !6, i64 20, !6, i64 24, !6, i64 28, !6, i64 32, !9, i64 40, !2, i64 48}
!151 = !{!150, !6, i64 16}
!152 = !{!150, !6, i64 12}
!153 = !{!150, !6, i64 8}
!154 = !{!150, !6, i64 4}
!155 = !{!150, !6, i64 0}
!156 = !{!64, !11, i64 164}
!157 = !{!39, !2, i64 0}
!158 = !{!39, !6, i64 96}
!159 = !{!102, !6, i64 4}
!160 = !{!39, !6, i64 84}
!161 = !{!162, !6, i64 4}
!162 = !{!"sortqgrp", !6, i64 0, !6, i64 4}
!163 = !{!162, !6, i64 0}
!164 = !{!165, !2, i64 32}
!165 = !{!"passwd", !2, i64 0, !2, i64 8, !6, i64 16, !6, i64 20, !2, i64 24, !2, i64 32, !2, i64 40}
!166 = !{!10, !2, i64 56}
!167 = !{!165, !6, i64 16}
!168 = !{!165, !6, i64 20}
!169 = !{!77, !11, i64 32}
!170 = !{!91, !9, i64 0}
!171 = !{i64 0, i64 8, !1, i64 8, i64 8, !92, i64 16, i64 8, !92, i64 24, i64 8, !1, i64 32, i64 8, !1, i64 40, i64 8, !1, i64 48, i64 8, !1, i64 56, i64 8, !1, i64 64, i64 8, !1, i64 72, i64 8, !92, i64 80, i64 4, !5, i64 84, i64 4, !5, i64 88, i64 8, !1, i64 96, i64 8, !1, i64 104, i64 8, !1, i64 112, i64 8, !1, i64 120, i64 8, !1, i64 128, i64 8, !1, i64 136, i64 8, !1, i64 144, i64 8, !1, i64 152, i64 8, !1, i64 160, i64 8, !1, i64 168, i64 8, !1, i64 176, i64 8, !92, i64 184, i64 8, !1, i64 192, i64 2, !88, i64 200, i64 8, !1, i64 208, i64 4, !5, i64 212, i64 4, !5, i64 216, i64 8, !1, i64 224, i64 8, !1, i64 232, i64 8, !1, i64 240, i64 8, !1, i64 248, i64 8, !1, i64 256, i64 8, !92, i64 264, i64 8, !1, i64 272, i64 8, !92, i64 280, i64 4, !5, i64 284, i64 2, !88, i64 286, i64 2, !88, i64 288, i64 2, !88, i64 290, i64 2, !88, i64 292, i64 2, !88, i64 294, i64 2, !88, i64 296, i64 8, !1, i64 304, i64 8, !1, i64 312, i64 8, !1, i64 320, i64 8, !1, i64 328, i64 8, !1, i64 336, i64 8, !1, i64 344, i64 8, !1, i64 352, i64 4, !5, i64 356, i64 4, !5, i64 360, i64 4, !5, i64 364, i64 4, !5, i64 368, i64 4, !5, i64 372, i64 4, !5, i64 376, i64 8, !1, i64 384, i64 8, !1, i64 392, i64 8, !1, i64 400, i64 8, !1, i64 408, i64 8, !1, i64 416, i64 1, !17, i64 424, i64 8, !1, i64 432, i64 8, !1, i64 440, i64 8, !1, i64 448, i64 8, !1, i64 456, i64 8, !92, i64 464, i64 4, !5, i64 472, i64 8, !92, i64 480, i64 8, !92, i64 488, i64 8, !1, i64 496, i64 32, !17, i64 528, i64 2048, !17, i64 2576, i64 8, !1, i64 2584, i64 8, !1, i64 2592, i64 8, !92, i64 2600, i64 8, !92, i64 2608, i64 8, !92, i64 2616, i64 8, !92, i64 2624, i64 8, !92, i64 2632, i64 4, !5, i64 2640, i64 8, !1, i64 2648, i64 4, !5}
!172 = !{!8, !11, i64 192}
!173 = !{!8, !2, i64 376}
!174 = !{!8, !2, i64 400}
!175 = !{!8, !2, i64 248}
