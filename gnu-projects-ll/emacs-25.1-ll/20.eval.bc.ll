; ModuleID = './src/eval.bc'
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%union.specbinding = type { %struct.anon.3 }
%struct.anon.3 = type { i8, i64, i64, i64 }
%struct.emacs_globals = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8 }
%struct.byte_stack = type opaque
%struct.handler = type { i32, i64, i64, %struct.handler*, %struct.handler*, i64*, i32, [1 x %struct.__jmp_buf_tag], i64, i64, i32, i32, %struct.byte_stack* }
%struct.__jmp_buf_tag = type { [8 x i64], i32, %struct.__sigset_t }
%struct.__sigset_t = type { [16 x i64] }
%struct.Lisp_Symbol = type { i16, i64, %union.anon.5, i64, i64, %struct.Lisp_Symbol* }
%union.anon.5 = type { i64 }
%struct.Lisp_Intfwd = type { i32, i64* }
%struct.Lisp_Objfwd = type { i32, i64* }
%struct.Lisp_Boolfwd = type { i32, i8* }
%struct.Lisp_Subr = type { %struct.vectorlike_header, %union.anon.6, i16, i16, i8*, i8*, i8* }
%struct.vectorlike_header = type { i64 }
%union.anon.6 = type { i64 ()* }
%struct.anon.4 = type { i16, i64, i64*, i64 }
%struct.anon = type { i8, void (i64)*, i64 }
%struct.Lisp_Cons = type { i64, %union.anon }
%union.anon = type { i64 }
%struct.Lisp_Buffer_Local_Value = type { i8, %union.Lisp_Fwd*, i64, i64, i64 }
%union.Lisp_Fwd = type { %struct.Lisp_Intfwd }
%struct.anon.0 = type { i8, void (i8*)*, i8* }
%struct.anon.1 = type { i8, void (i32)*, i32 }
%struct.anon.2 = type { i8, void ()* }
%struct.__va_list_tag = type { i32, i32, i8*, i8* }

@specpdl = common global %union.specbinding* null, align 8
@specpdl_ptr = common global %union.specbinding* null, align 8
@specpdl_size = common global i64 0, align 8
@globals = external global %struct.emacs_globals, align 8
@Vrun_hooks = common global i64 0, align 8
@byte_stack_list = external global %struct.byte_stack*, align 8
@handlerlist_sentinel = internal global %struct.handler zeroinitializer, align 8
@handlerlist = common global %struct.handler* null, align 8
@lisp_eval_depth = internal global i64 0, align 8
@when_entered_debugger = internal global i64 0, align 8
@redisplaying_p = external global i8, align 1
@.str = private unnamed_addr constant [22 x i8] c"debugger-may-continue\00", align 1
@lispsym = external global [1074 x %struct.Lisp_Symbol], align 8
@.str.1 = private unnamed_addr constant [32 x i8] c"Cannot make a constant an alias\00", align 1
@.str.2 = private unnamed_addr constant [42 x i8] c"Cannot make an internal variable an alias\00", align 1
@.str.3 = private unnamed_addr constant [53 x i8] c"Don't know how to make a localized variable an alias\00", align 1
@.str.4 = private unnamed_addr constant [53 x i8] c"Don't know how to make a let-bound variable an alias\00", align 1
@.str.5 = private unnamed_addr constant [19 x i8] c"Too many arguments\00", align 1
@pending_signals = external global i8, align 1
@.str.6 = private unnamed_addr constant [44 x i8] c"`let' bindings can have only one value-form\00", align 1
@.str.7 = private unnamed_addr constant [30 x i8] c"Invalid condition handler: %s\00", align 1
@profiler_memory_running = external global i8, align 1
@poll_suppress_count = external global i32, align 4
@interrupt_input_blocked = external global i32, align 4
@immediate_quit = external global i8, align 1
@abort_on_gc = external global i8, align 1
@gc_in_progress = external global i8, align 1
@waiting_for_input = external global i8, align 1
@Vsignaling_function = common global i64 0, align 8
@.str.8 = private unnamed_addr constant [3 x i8] c"%s\00", align 1
@Vautoload_queue = common global i64 0, align 8
@.str.9 = private unnamed_addr constant [47 x i8] c"Attempt to autoload %s while preparing to dump\00", align 1
@.str.10 = private unnamed_addr constant [41 x i8] c"Autoloading failed to define function %s\00", align 1
@.str.11 = private unnamed_addr constant [43 x i8] c"Lisp nesting exceeds `max-lisp-eval-depth'\00", align 1
@.str.12 = private unnamed_addr constant [24 x i8] c"Invalid byte code in %s\00", align 1
@.str.13 = private unnamed_addr constant [18 x i8] c"Invalid byte code\00", align 1
@.str.14 = private unnamed_addr constant [37 x i8] c"Frame-local vars cannot be let-bound\00", align 1
@.str.15 = private unnamed_addr constant [3 x i8] c"* \00", align 1
@.str.16 = private unnamed_addr constant [3 x i8] c"  \00", align 1
@.str.17 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1
@.str.18 = private unnamed_addr constant [2 x i8] c"(\00", align 1
@.str.19 = private unnamed_addr constant [2 x i8] c" \00", align 1
@.str.20 = private unnamed_addr constant [3 x i8] c")\0A\00", align 1
@.str.21 = private unnamed_addr constant [28 x i8] c"Activation frame not found!\00", align 1
@syms_of_eval.i_fwd = internal global %struct.Lisp_Intfwd zeroinitializer, align 8
@.str.22 = private unnamed_addr constant [17 x i8] c"max-specpdl-size\00", align 1
@syms_of_eval.i_fwd.23 = internal global %struct.Lisp_Intfwd zeroinitializer, align 8
@.str.24 = private unnamed_addr constant [20 x i8] c"max-lisp-eval-depth\00", align 1
@syms_of_eval.o_fwd = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.25 = private unnamed_addr constant [10 x i8] c"quit-flag\00", align 1
@syms_of_eval.o_fwd.26 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.27 = private unnamed_addr constant [13 x i8] c"inhibit-quit\00", align 1
@syms_of_eval.o_fwd.28 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.29 = private unnamed_addr constant [17 x i8] c"inhibit-debugger\00", align 1
@syms_of_eval.o_fwd.30 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.31 = private unnamed_addr constant [15 x i8] c"debug-on-error\00", align 1
@syms_of_eval.o_fwd.32 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.33 = private unnamed_addr constant [21 x i8] c"debug-ignored-errors\00", align 1
@syms_of_eval.b_fwd = internal global %struct.Lisp_Boolfwd zeroinitializer, align 8
@.str.34 = private unnamed_addr constant [14 x i8] c"debug-on-quit\00", align 1
@syms_of_eval.b_fwd.35 = internal global %struct.Lisp_Boolfwd zeroinitializer, align 8
@.str.36 = private unnamed_addr constant [19 x i8] c"debug-on-next-call\00", align 1
@syms_of_eval.b_fwd.37 = internal global %struct.Lisp_Boolfwd zeroinitializer, align 8
@syms_of_eval.o_fwd.38 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.39 = private unnamed_addr constant [9 x i8] c"debugger\00", align 1
@syms_of_eval.o_fwd.40 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.41 = private unnamed_addr constant [21 x i8] c"signal-hook-function\00", align 1
@syms_of_eval.o_fwd.42 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.43 = private unnamed_addr constant [16 x i8] c"debug-on-signal\00", align 1
@syms_of_eval.o_fwd.44 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.45 = private unnamed_addr constant [33 x i8] c"internal-interpreter-environment\00", align 1
@.str.46 = private unnamed_addr constant [10 x i8] c"run-hooks\00", align 1
@inhibit_lisp_code = common global i64 0, align 8
@Sbacktrace = internal global %struct.Lisp_Subr { %struct.vectorlike_header { i64 167772160 }, %union.anon.6 { i64 ()* @Fbacktrace }, i16 0, i16 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.85, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.86, i32 0, i32 0), i8* null }, align 8
@.str.47 = private unnamed_addr constant [48 x i8] c"Variable binding depth exceeds max-specpdl-size\00", align 1
@.str.48 = private unnamed_addr constant [3 x i8] c"or\00", align 1
@Sor = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @For }, i16 0, i16 -1, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.48, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.49 = private unnamed_addr constant [4 x i8] c"and\00", align 1
@Sand = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fand }, i16 0, i16 -1, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.49, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.50 = private unnamed_addr constant [3 x i8] c"if\00", align 1
@Sif = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fif }, i16 2, i16 -1, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.50, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.51 = private unnamed_addr constant [5 x i8] c"cond\00", align 1
@Scond = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fcond }, i16 0, i16 -1, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.51, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.52 = private unnamed_addr constant [6 x i8] c"progn\00", align 1
@Sprogn = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fprogn }, i16 0, i16 -1, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.52, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.53 = private unnamed_addr constant [6 x i8] c"prog1\00", align 1
@Sprog1 = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fprog1 }, i16 1, i16 -1, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.53, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.54 = private unnamed_addr constant [6 x i8] c"prog2\00", align 1
@Sprog2 = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fprog2 }, i16 2, i16 -1, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.54, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.55 = private unnamed_addr constant [5 x i8] c"setq\00", align 1
@Ssetq = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fsetq }, i16 0, i16 -1, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.55, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.56 = private unnamed_addr constant [6 x i8] c"quote\00", align 1
@Squote = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fquote }, i16 1, i16 -1, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.56, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.57 = private unnamed_addr constant [9 x i8] c"function\00", align 1
@Sfunction = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Ffunction }, i16 1, i16 -1, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.57, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.58 = private unnamed_addr constant [23 x i8] c"default-toplevel-value\00", align 1
@Sdefault_toplevel_value = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fdefault_toplevel_value }, i16 1, i16 1, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.58, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.59 = private unnamed_addr constant [27 x i8] c"set-default-toplevel-value\00", align 1
@Sset_default_toplevel_value = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fset_default_toplevel_value }, i16 2, i16 2, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.59, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.60 = private unnamed_addr constant [7 x i8] c"defvar\00", align 1
@Sdefvar = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fdefvar }, i16 1, i16 -1, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.60, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.61 = private unnamed_addr constant [12 x i8] c"defvaralias\00", align 1
@Sdefvaralias = internal global { %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64, i64)* } { i64 (i64, i64, i64)* @Fdefvaralias }, i16 2, i16 3, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.61, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.62 = private unnamed_addr constant [9 x i8] c"defconst\00", align 1
@Sdefconst = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fdefconst }, i16 2, i16 -1, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.62, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.63 = private unnamed_addr constant [30 x i8] c"internal-make-var-non-special\00", align 1
@Smake_var_non_special = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fmake_var_non_special }, i16 1, i16 1, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.63, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.64 = private unnamed_addr constant [4 x i8] c"let\00", align 1
@Slet = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Flet }, i16 1, i16 -1, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.64, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.65 = private unnamed_addr constant [5 x i8] c"let*\00", align 1
@SletX = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @FletX }, i16 1, i16 -1, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.65, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.66 = private unnamed_addr constant [6 x i8] c"while\00", align 1
@Swhile = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fwhile }, i16 1, i16 -1, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.66, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.67 = private unnamed_addr constant [12 x i8] c"macroexpand\00", align 1
@Smacroexpand = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fmacroexpand }, i16 1, i16 2, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.67, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.68 = private unnamed_addr constant [6 x i8] c"catch\00", align 1
@Scatch = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fcatch }, i16 1, i16 -1, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.68, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.69 = private unnamed_addr constant [6 x i8] c"throw\00", align 1
@Sthrow = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fthrow }, i16 2, i16 2, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.69, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.70 = private unnamed_addr constant [15 x i8] c"unwind-protect\00", align 1
@Sunwind_protect = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Funwind_protect }, i16 1, i16 -1, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.70, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.71 = private unnamed_addr constant [15 x i8] c"condition-case\00", align 1
@Scondition_case = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fcondition_case }, i16 2, i16 -1, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.71, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.72 = private unnamed_addr constant [7 x i8] c"signal\00", align 1
@Ssignal = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fsignal }, i16 2, i16 2, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.72, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.73 = private unnamed_addr constant [9 x i8] c"commandp\00", align 1
@Scommandp = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fcommandp }, i16 1, i16 2, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.73, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.74 = private unnamed_addr constant [9 x i8] c"autoload\00", align 1
@Sautoload = internal global { %struct.vectorlike_header, { i64 (i64, i64, i64, i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64, i64, i64, i64)* } { i64 (i64, i64, i64, i64, i64)* @Fautoload }, i16 2, i16 5, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.74, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.75 = private unnamed_addr constant [17 x i8] c"autoload-do-load\00", align 1
@Sautoload_do_load = internal global { %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64, i64)* } { i64 (i64, i64, i64)* @Fautoload_do_load }, i16 1, i16 3, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.75, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.76 = private unnamed_addr constant [5 x i8] c"eval\00", align 1
@Seval = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Feval }, i16 1, i16 2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.76, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.77 = private unnamed_addr constant [6 x i8] c"apply\00", align 1
@Sapply = internal global { %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64*)* } { i64 (i64, i64*)* @Fapply }, i16 1, i16 -2, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.77, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.78 = private unnamed_addr constant [8 x i8] c"funcall\00", align 1
@Sfuncall = internal global { %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64*)* } { i64 (i64, i64*)* @Ffuncall }, i16 1, i16 -2, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.78, i32 0, i32 0), i8* null, i8* null }, align 8
@Srun_hooks = internal global { %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64*)* } { i64 (i64, i64*)* @Frun_hooks }, i16 0, i16 -2, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.46, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.79 = private unnamed_addr constant [19 x i8] c"run-hook-with-args\00", align 1
@Srun_hook_with_args = internal global { %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64*)* } { i64 (i64, i64*)* @Frun_hook_with_args }, i16 1, i16 -2, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.79, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.80 = private unnamed_addr constant [33 x i8] c"run-hook-with-args-until-success\00", align 1
@Srun_hook_with_args_until_success = internal global { %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64*)* } { i64 (i64, i64*)* @Frun_hook_with_args_until_success }, i16 1, i16 -2, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.80, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.81 = private unnamed_addr constant [33 x i8] c"run-hook-with-args-until-failure\00", align 1
@Srun_hook_with_args_until_failure = internal global { %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64*)* } { i64 (i64, i64*)* @Frun_hook_with_args_until_failure }, i16 1, i16 -2, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.81, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.82 = private unnamed_addr constant [17 x i8] c"run-hook-wrapped\00", align 1
@Srun_hook_wrapped = internal global { %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64*)* } { i64 (i64, i64*)* @Frun_hook_wrapped }, i16 2, i16 -2, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.82, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.83 = private unnamed_addr constant [15 x i8] c"fetch-bytecode\00", align 1
@Sfetch_bytecode = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Ffetch_bytecode }, i16 1, i16 1, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.83, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.84 = private unnamed_addr constant [16 x i8] c"backtrace-debug\00", align 1
@Sbacktrace_debug = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fbacktrace_debug }, i16 2, i16 2, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.84, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.85 = private unnamed_addr constant [10 x i8] c"backtrace\00", align 1
@.str.86 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.87 = private unnamed_addr constant [16 x i8] c"backtrace-frame\00", align 1
@Sbacktrace_frame = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fbacktrace_frame }, i16 1, i16 2, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.87, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.88 = private unnamed_addr constant [15 x i8] c"backtrace-eval\00", align 1
@Sbacktrace_eval = internal global { %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64, i64)* } { i64 (i64, i64, i64)* @Fbacktrace_eval }, i16 2, i16 3, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.88, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.89 = private unnamed_addr constant [18 x i8] c"backtrace--locals\00", align 1
@Sbacktrace__locals = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fbacktrace__locals }, i16 1, i16 2, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.89, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.90 = private unnamed_addr constant [19 x i8] c"special-variable-p\00", align 1
@Sspecial_variable_p = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fspecial_variable_p }, i16 1, i16 1, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.90, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.91 = private unnamed_addr constant [10 x i8] c"functionp\00", align 1
@Sfunctionp = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Ffunctionp }, i16 1, i16 1, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.91, i32 0, i32 0), i8* null, i8* null }, align 8

; Function Attrs: nounwind uwtable
define i64 @backtrace_function(%union.specbinding* %pdl) #0 {
entry:
  %pdl.addr = alloca %union.specbinding*, align 8
  store %union.specbinding* %pdl, %union.specbinding** %pdl.addr, align 8
  %0 = load %union.specbinding*, %union.specbinding** %pdl.addr, align 8
  %bt = bitcast %union.specbinding* %0 to %struct.anon.4*
  %function = getelementptr inbounds %struct.anon.4, %struct.anon.4* %bt, i32 0, i32 1
  %1 = load i64, i64* %function, align 8
  ret i64 %1
}

; Function Attrs: nounwind uwtable
define i64* @backtrace_args(%union.specbinding* %pdl) #0 {
entry:
  %pdl.addr = alloca %union.specbinding*, align 8
  store %union.specbinding* %pdl, %union.specbinding** %pdl.addr, align 8
  %0 = load %union.specbinding*, %union.specbinding** %pdl.addr, align 8
  %bt = bitcast %union.specbinding* %0 to %struct.anon.4*
  %args = getelementptr inbounds %struct.anon.4, %struct.anon.4* %bt, i32 0, i32 2
  %1 = load i64*, i64** %args, align 8
  ret i64* %1
}

; Function Attrs: nounwind uwtable
define zeroext i1 @backtrace_p(%union.specbinding* %pdl) #0 {
entry:
  %pdl.addr = alloca %union.specbinding*, align 8
  store %union.specbinding* %pdl, %union.specbinding** %pdl.addr, align 8
  %0 = load %union.specbinding*, %union.specbinding** %pdl.addr, align 8
  %1 = load %union.specbinding*, %union.specbinding** @specpdl, align 8
  %cmp = icmp uge %union.specbinding* %0, %1
  ret i1 %cmp
}

; Function Attrs: nounwind uwtable
define %union.specbinding* @backtrace_top() #0 {
entry:
  %pdl = alloca %union.specbinding*, align 8
  %0 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %add.ptr = getelementptr inbounds %union.specbinding, %union.specbinding* %0, i64 -1
  store %union.specbinding* %add.ptr, %union.specbinding** %pdl, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %1 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %call = call zeroext i1 @backtrace_p(%union.specbinding* %1)
  br i1 %call, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %2 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %3 = bitcast %union.specbinding* %2 to i8*
  %bf.load = load i8, i8* %3, align 8
  %bf.cast = zext i8 %bf.load to i32
  %cmp = icmp ne i32 %bf.cast, 4
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %4 = phi i1 [ false, %while.cond ], [ %cmp, %land.rhs ]
  br i1 %4, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %5 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %incdec.ptr = getelementptr inbounds %union.specbinding, %union.specbinding* %5, i32 -1
  store %union.specbinding* %incdec.ptr, %union.specbinding** %pdl, align 8
  br label %while.cond

while.end:                                        ; preds = %land.end
  %6 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  ret %union.specbinding* %6
}

; Function Attrs: nounwind uwtable
define %union.specbinding* @backtrace_next(%union.specbinding* %pdl) #0 {
entry:
  %pdl.addr = alloca %union.specbinding*, align 8
  store %union.specbinding* %pdl, %union.specbinding** %pdl.addr, align 8
  %0 = load %union.specbinding*, %union.specbinding** %pdl.addr, align 8
  %incdec.ptr = getelementptr inbounds %union.specbinding, %union.specbinding* %0, i32 -1
  store %union.specbinding* %incdec.ptr, %union.specbinding** %pdl.addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %1 = load %union.specbinding*, %union.specbinding** %pdl.addr, align 8
  %call = call zeroext i1 @backtrace_p(%union.specbinding* %1)
  br i1 %call, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %2 = load %union.specbinding*, %union.specbinding** %pdl.addr, align 8
  %3 = bitcast %union.specbinding* %2 to i8*
  %bf.load = load i8, i8* %3, align 8
  %bf.cast = zext i8 %bf.load to i32
  %cmp = icmp ne i32 %bf.cast, 4
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %4 = phi i1 [ false, %while.cond ], [ %cmp, %land.rhs ]
  br i1 %4, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %5 = load %union.specbinding*, %union.specbinding** %pdl.addr, align 8
  %incdec.ptr1 = getelementptr inbounds %union.specbinding, %union.specbinding* %5, i32 -1
  store %union.specbinding* %incdec.ptr1, %union.specbinding** %pdl.addr, align 8
  br label %while.cond

while.end:                                        ; preds = %land.end
  %6 = load %union.specbinding*, %union.specbinding** %pdl.addr, align 8
  ret %union.specbinding* %6
}

; Function Attrs: nounwind uwtable
define i8* @near_C_stack_top() #0 {
entry:
  %call = call %union.specbinding* @backtrace_top()
  %call1 = call i64* @backtrace_args(%union.specbinding* %call)
  %0 = bitcast i64* %call1 to i8*
  ret i8* %0
}

; Function Attrs: nounwind uwtable
define void @init_eval_once() #0 {
entry:
  %pdlvec = alloca %union.specbinding*, align 8
  %call = call noalias i8* @xmalloc(i64 1632)
  %0 = bitcast i8* %call to %union.specbinding*
  store %union.specbinding* %0, %union.specbinding** %pdlvec, align 8
  store i64 50, i64* @specpdl_size, align 8
  %1 = load %union.specbinding*, %union.specbinding** %pdlvec, align 8
  %add.ptr = getelementptr inbounds %union.specbinding, %union.specbinding* %1, i64 1
  store %union.specbinding* %add.ptr, %union.specbinding** @specpdl_ptr, align 8
  store %union.specbinding* %add.ptr, %union.specbinding** @specpdl, align 8
  store i64 1300, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 397), align 8
  store i64 800, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 396), align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call1, i64* @Vrun_hooks, align 8
  ret void
}

declare noalias i8* @xmalloc(i64) #1

declare i64 @builtin_lisp_symbol(i32) #1

; Function Attrs: nounwind uwtable
define void @init_eval() #0 {
entry:
  %c = alloca %struct.handler*, align 8
  store %struct.byte_stack* null, %struct.byte_stack** @byte_stack_list, align 8
  %0 = load %union.specbinding*, %union.specbinding** @specpdl, align 8
  store %union.specbinding* %0, %union.specbinding** @specpdl_ptr, align 8
  store %struct.handler* @handlerlist_sentinel, %struct.handler** getelementptr inbounds (%struct.handler, %struct.handler* @handlerlist_sentinel, i32 0, i32 4), align 8
  store %struct.handler* @handlerlist_sentinel, %struct.handler** @handlerlist, align 8
  %call = call i64 @builtin_lisp_symbol(i32 957)
  %call1 = call %struct.handler* @push_handler(i64 %call, i32 0)
  store %struct.handler* %call1, %struct.handler** %c, align 8
  store %struct.handler* null, %struct.handler** getelementptr inbounds (%struct.handler, %struct.handler* @handlerlist_sentinel, i32 0, i32 4), align 8
  store %struct.handler* null, %struct.handler** getelementptr inbounds (%struct.handler, %struct.handler* @handlerlist_sentinel, i32 0, i32 3), align 8
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call2, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  store i8 0, i8* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 432), align 1
  store i64 0, i64* @lisp_eval_depth, align 8
  store i64 -1, i64* @when_entered_debugger, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.handler* @push_handler(i64 %tag_ch_val, i32 %handlertype) #0 {
entry:
  %tag_ch_val.addr = alloca i64, align 8
  %handlertype.addr = alloca i32, align 4
  %c = alloca %struct.handler*, align 8
  store i64 %tag_ch_val, i64* %tag_ch_val.addr, align 8
  store i32 %handlertype, i32* %handlertype.addr, align 4
  %0 = load i64, i64* %tag_ch_val.addr, align 8
  %1 = load i32, i32* %handlertype.addr, align 4
  %call = call %struct.handler* @push_handler_nosignal(i64 %0, i32 %1)
  store %struct.handler* %call, %struct.handler** %c, align 8
  %2 = load %struct.handler*, %struct.handler** %c, align 8
  %tobool = icmp ne %struct.handler* %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call void @memory_full(i64 288) #8
  unreachable

if.end:                                           ; preds = %entry
  %3 = load %struct.handler*, %struct.handler** %c, align 8
  ret %struct.handler* %3
}

; Function Attrs: nounwind uwtable
define i64 @call_debugger(i64 %arg) #0 {
entry:
  %arg.addr = alloca i64, align 8
  %debug_while_redisplaying = alloca i8, align 1
  %count = alloca i64, align 8
  %val = alloca i64, align 8
  %old_depth = alloca i64, align 8
  %old_max = alloca i64, align 8
  store i64 %arg, i64* %arg.addr, align 8
  %call = call i64 @SPECPDL_INDEX()
  store i64 %call, i64* %count, align 8
  %0 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 396), align 8
  store i64 %0, i64* %old_depth, align 8
  %1 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 397), align 8
  %2 = load i64, i64* %count, align 8
  %cmp = icmp sgt i64 %1, %2
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 397), align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %4 = load i64, i64* %count, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %3, %cond.true ], [ %4, %cond.false ]
  store i64 %cond, i64* %old_max, align 8
  %5 = load i64, i64* @lisp_eval_depth, align 8
  %add = add nsw i64 %5, 40
  %6 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 396), align 8
  %cmp1 = icmp sgt i64 %add, %6
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  %7 = load i64, i64* @lisp_eval_depth, align 8
  %add2 = add nsw i64 %7, 40
  store i64 %add2, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 396), align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end
  %8 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 397), align 8
  %sub = sub nsw i64 %8, 200
  %9 = load i64, i64* %count, align 8
  %cmp3 = icmp slt i64 %sub, %9
  br i1 %cmp3, label %if.then.4, label %if.end.6

if.then.4:                                        ; preds = %if.end
  %10 = load i64, i64* %count, align 8
  %add5 = add nsw i64 %10, 200
  store i64 %add5, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 397), align 8
  br label %if.end.6

if.end.6:                                         ; preds = %if.then.4, %if.end
  %11 = load i64, i64* %old_max, align 8
  %12 = load i64, i64* %count, align 8
  %cmp7 = icmp eq i64 %11, %12
  br i1 %cmp7, label %if.then.8, label %if.end.9

if.then.8:                                        ; preds = %if.end.6
  %13 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %incdec.ptr = getelementptr inbounds %union.specbinding, %union.specbinding* %13, i32 -1
  store %union.specbinding* %incdec.ptr, %union.specbinding** @specpdl_ptr, align 8
  call void @grow_specpdl()
  br label %if.end.9

if.end.9:                                         ; preds = %if.then.8, %if.end.6
  %14 = load i64, i64* %old_max, align 8
  %shl = shl i64 %14, 2
  %add10 = add i64 %shl, 2
  %15 = load i64, i64* %old_depth, align 8
  %shl11 = shl i64 %15, 2
  %add12 = add i64 %shl11, 2
  %call13 = call i64 @Fcons(i64 %add10, i64 %add12)
  call void @record_unwind_protect(void (i64)* @restore_stack_limits, i64 %call13)
  %16 = load i8, i8* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 438), align 1
  %tobool = trunc i8 %16 to i1
  br i1 %tobool, label %if.then.14, label %if.end.15

if.then.14:                                       ; preds = %if.end.9
  call void @cancel_hourglass()
  br label %if.end.15

if.end.15:                                        ; preds = %if.then.14, %if.end.9
  store i8 0, i8* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 432), align 1
  %17 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 401), align 8
  store i64 %17, i64* @when_entered_debugger, align 8
  %18 = load i8, i8* @redisplaying_p, align 1
  %tobool16 = trunc i8 %18 to i1
  %frombool = zext i1 %tobool16 to i8
  store i8 %frombool, i8* %debug_while_redisplaying, align 1
  store i8 0, i8* @redisplaying_p, align 1
  %call17 = call i64 @intern(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str, i32 0, i32 0))
  %19 = load i8, i8* %debug_while_redisplaying, align 1
  %tobool18 = trunc i8 %19 to i1
  br i1 %tobool18, label %cond.true.19, label %cond.false.21

cond.true.19:                                     ; preds = %if.end.15
  %call20 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end.23

cond.false.21:                                    ; preds = %if.end.15
  %call22 = call i64 @builtin_lisp_symbol(i32 901)
  br label %cond.end.23

cond.end.23:                                      ; preds = %cond.false.21, %cond.true.19
  %cond24 = phi i64 [ %call20, %cond.true.19 ], [ %call22, %cond.false.21 ]
  call void @specbind(i64 %call17, i64 %cond24)
  %call25 = call i64 @builtin_lisp_symbol(i32 548)
  %call26 = call i64 @builtin_lisp_symbol(i32 0)
  call void @specbind(i64 %call25, i64 %call26)
  %call27 = call i64 @builtin_lisp_symbol(i32 539)
  %call28 = call i64 @builtin_lisp_symbol(i32 901)
  call void @specbind(i64 %call27, i64 %call28)
  %20 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 58), align 8
  %21 = load i64, i64* %arg.addr, align 8
  %call29 = call i64 @apply1(i64 %20, i64 %21)
  store i64 %call29, i64* %val, align 8
  %22 = load i8, i8* %debug_while_redisplaying, align 1
  %tobool30 = trunc i8 %22 to i1
  br i1 %tobool30, label %if.then.31, label %if.end.32

if.then.31:                                       ; preds = %cond.end.23
  %23 = call i64 @Ftop_level() #8
  unreachable

if.end.32:                                        ; preds = %cond.end.23
  %24 = load i64, i64* %count, align 8
  %25 = load i64, i64* %val, align 8
  %call33 = call i64 @unbind_to(i64 %24, i64 %25)
  ret i64 %call33
}

declare i64 @SPECPDL_INDEX() #1

; Function Attrs: nounwind uwtable
define internal void @grow_specpdl() #0 {
entry:
  %count = alloca i64, align 8
  %max_size = alloca i64, align 8
  %pdlvec = alloca %union.specbinding*, align 8
  %pdlvecsize = alloca i64, align 8
  %0 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %incdec.ptr = getelementptr inbounds %union.specbinding, %union.specbinding* %0, i32 1
  store %union.specbinding* %incdec.ptr, %union.specbinding** @specpdl_ptr, align 8
  %1 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %2 = load %union.specbinding*, %union.specbinding** @specpdl, align 8
  %3 = load i64, i64* @specpdl_size, align 8
  %add.ptr = getelementptr inbounds %union.specbinding, %union.specbinding* %2, i64 %3
  %cmp = icmp eq %union.specbinding* %1, %add.ptr
  br i1 %cmp, label %if.then, label %if.end.16

if.then:                                          ; preds = %entry
  %call = call i64 @SPECPDL_INDEX()
  store i64 %call, i64* %count, align 8
  %4 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 397), align 8
  %cmp1 = icmp slt i64 %4, 9223372036854774807
  br i1 %cmp1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  %5 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 397), align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %5, %cond.true ], [ 9223372036854774807, %cond.false ]
  store i64 %cond, i64* %max_size, align 8
  %6 = load %union.specbinding*, %union.specbinding** @specpdl, align 8
  %add.ptr2 = getelementptr inbounds %union.specbinding, %union.specbinding* %6, i64 -1
  store %union.specbinding* %add.ptr2, %union.specbinding** %pdlvec, align 8
  %7 = load i64, i64* @specpdl_size, align 8
  %add = add nsw i64 %7, 1
  store i64 %add, i64* %pdlvecsize, align 8
  %8 = load i64, i64* %max_size, align 8
  %9 = load i64, i64* @specpdl_size, align 8
  %cmp3 = icmp sle i64 %8, %9
  br i1 %cmp3, label %if.then.4, label %if.end.11

if.then.4:                                        ; preds = %cond.end
  %10 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 397), align 8
  %cmp5 = icmp slt i64 %10, 400
  br i1 %cmp5, label %if.then.6, label %if.end

if.then.6:                                        ; preds = %if.then.4
  store i64 400, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 397), align 8
  store i64 400, i64* %max_size, align 8
  br label %if.end

if.end:                                           ; preds = %if.then.6, %if.then.4
  %11 = load i64, i64* %max_size, align 8
  %12 = load i64, i64* @specpdl_size, align 8
  %cmp7 = icmp sle i64 %11, %12
  br i1 %cmp7, label %if.then.8, label %if.end.10

if.then.8:                                        ; preds = %if.end
  %call9 = call i64 @builtin_lisp_symbol(i32 0)
  call void @signal_error(i8* getelementptr inbounds ([48 x i8], [48 x i8]* @.str.47, i32 0, i32 0), i64 %call9) #8
  unreachable

if.end.10:                                        ; preds = %if.end
  br label %if.end.11

if.end.11:                                        ; preds = %if.end.10, %cond.end
  %13 = load %union.specbinding*, %union.specbinding** %pdlvec, align 8
  %14 = bitcast %union.specbinding* %13 to i8*
  %15 = load i64, i64* %max_size, align 8
  %add12 = add nsw i64 %15, 1
  %call13 = call i8* @xpalloc(i8* %14, i64* %pdlvecsize, i64 1, i64 %add12, i64 32)
  %16 = bitcast i8* %call13 to %union.specbinding*
  store %union.specbinding* %16, %union.specbinding** %pdlvec, align 8
  %17 = load %union.specbinding*, %union.specbinding** %pdlvec, align 8
  %add.ptr14 = getelementptr inbounds %union.specbinding, %union.specbinding* %17, i64 1
  store %union.specbinding* %add.ptr14, %union.specbinding** @specpdl, align 8
  %18 = load i64, i64* %pdlvecsize, align 8
  %sub = sub nsw i64 %18, 1
  store i64 %sub, i64* @specpdl_size, align 8
  %19 = load %union.specbinding*, %union.specbinding** @specpdl, align 8
  %20 = load i64, i64* %count, align 8
  %add.ptr15 = getelementptr inbounds %union.specbinding, %union.specbinding* %19, i64 %20
  store %union.specbinding* %add.ptr15, %union.specbinding** @specpdl_ptr, align 8
  br label %if.end.16

if.end.16:                                        ; preds = %if.end.11, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define void @record_unwind_protect(void (i64)* %function, i64 %arg) #0 {
entry:
  %function.addr = alloca void (i64)*, align 8
  %arg.addr = alloca i64, align 8
  store void (i64)* %function, void (i64)** %function.addr, align 8
  store i64 %arg, i64* %arg.addr, align 8
  %0 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %unwind = bitcast %union.specbinding* %0 to %struct.anon*
  %1 = bitcast %struct.anon* %unwind to i8*
  store i8 0, i8* %1, align 8
  %2 = load void (i64)*, void (i64)** %function.addr, align 8
  %3 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %unwind1 = bitcast %union.specbinding* %3 to %struct.anon*
  %func = getelementptr inbounds %struct.anon, %struct.anon* %unwind1, i32 0, i32 1
  store void (i64)* %2, void (i64)** %func, align 8
  %4 = load i64, i64* %arg.addr, align 8
  %5 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %unwind2 = bitcast %union.specbinding* %5 to %struct.anon*
  %arg3 = getelementptr inbounds %struct.anon, %struct.anon* %unwind2, i32 0, i32 2
  store i64 %4, i64* %arg3, align 8
  call void @grow_specpdl()
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @restore_stack_limits(i64 %data) #0 {
entry:
  %data.addr = alloca i64, align 8
  store i64 %data, i64* %data.addr, align 8
  %0 = load i64, i64* %data.addr, align 8
  %sub = sub nsw i64 %0, 3
  %1 = inttoptr i64 %sub to i8*
  %2 = bitcast i8* %1 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %2, i32 0, i32 0
  %3 = load i64, i64* %car, align 8
  %shr = ashr i64 %3, 2
  store i64 %shr, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 397), align 8
  %4 = load i64, i64* %data.addr, align 8
  %sub1 = sub nsw i64 %4, 3
  %5 = inttoptr i64 %sub1 to i8*
  %6 = bitcast i8* %5 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %6, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %7 = load i64, i64* %cdr, align 8
  %shr2 = ashr i64 %7, 2
  store i64 %shr2, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 396), align 8
  ret void
}

declare i64 @Fcons(i64, i64) #1

declare void @cancel_hourglass() #1

; Function Attrs: nounwind uwtable
define void @specbind(i64 %symbol, i64 %value) #0 {
entry:
  %symbol.addr = alloca i64, align 8
  %value.addr = alloca i64, align 8
  %sym = alloca %struct.Lisp_Symbol*, align 8
  %ovalue = alloca i64, align 8
  store i64 %symbol, i64* %symbol.addr, align 8
  store i64 %value, i64* %value.addr, align 8
  %0 = load i64, i64* %symbol.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = call i64 @builtin_lisp_symbol(i32 897)
  %1 = load i64, i64* %symbol.addr, align 8
  %2 = call i64 @wrong_type_argument(i64 %call, i64 %1) #8
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %3, %cond.true
  %4 = load i64, i64* %symbol.addr, align 8
  %sub = sub nsw i64 %4, 0
  %add.ptr = getelementptr inbounds i8, i8* bitcast ([1074 x %struct.Lisp_Symbol]* @lispsym to i8*), i64 %sub
  %5 = bitcast i8* %add.ptr to %struct.Lisp_Symbol*
  store %struct.Lisp_Symbol* %5, %struct.Lisp_Symbol** %sym, align 8
  br label %start

start:                                            ; preds = %sw.bb, %cond.end
  %6 = load %struct.Lisp_Symbol*, %struct.Lisp_Symbol** %sym, align 8
  %7 = bitcast %struct.Lisp_Symbol* %6 to i16*
  %bf.load = load i16, i16* %7, align 8
  %bf.lshr = lshr i16 %bf.load, 1
  %bf.clear = and i16 %bf.lshr, 7
  %bf.cast = zext i16 %bf.clear to i32
  switch i32 %bf.cast, label %sw.default [
    i32 1, label %sw.bb
    i32 4, label %sw.bb.4
    i32 2, label %sw.bb.16
    i32 3, label %sw.bb.24
  ]

sw.bb:                                            ; preds = %start
  %8 = load %struct.Lisp_Symbol*, %struct.Lisp_Symbol** %sym, align 8
  %call2 = call %struct.Lisp_Symbol* @indirect_variable(%struct.Lisp_Symbol* %8)
  store %struct.Lisp_Symbol* %call2, %struct.Lisp_Symbol** %sym, align 8
  %9 = load %struct.Lisp_Symbol*, %struct.Lisp_Symbol** %sym, align 8
  %call3 = call i64 @make_lisp_symbol(%struct.Lisp_Symbol* %9)
  store i64 %call3, i64* %symbol.addr, align 8
  br label %start

sw.bb.4:                                          ; preds = %start
  %10 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %let = bitcast %union.specbinding* %10 to %struct.anon.3*
  %11 = bitcast %struct.anon.3* %let to i8*
  store i8 5, i8* %11, align 8
  %12 = load i64, i64* %symbol.addr, align 8
  %13 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %let5 = bitcast %union.specbinding* %13 to %struct.anon.3*
  %symbol6 = getelementptr inbounds %struct.anon.3, %struct.anon.3* %let5, i32 0, i32 1
  store i64 %12, i64* %symbol6, align 8
  %14 = load %struct.Lisp_Symbol*, %struct.Lisp_Symbol** %sym, align 8
  %val = getelementptr inbounds %struct.Lisp_Symbol, %struct.Lisp_Symbol* %14, i32 0, i32 2
  %value7 = bitcast %union.anon.5* %val to i64*
  %15 = load i64, i64* %value7, align 8
  %16 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %let8 = bitcast %union.specbinding* %16 to %struct.anon.3*
  %old_value = getelementptr inbounds %struct.anon.3, %struct.anon.3* %let8, i32 0, i32 2
  store i64 %15, i64* %old_value, align 8
  call void @grow_specpdl()
  %17 = load %struct.Lisp_Symbol*, %struct.Lisp_Symbol** %sym, align 8
  %18 = bitcast %struct.Lisp_Symbol* %17 to i16*
  %bf.load9 = load i16, i16* %18, align 8
  %bf.lshr10 = lshr i16 %bf.load9, 4
  %bf.clear11 = and i16 %bf.lshr10, 3
  %bf.cast12 = zext i16 %bf.clear11 to i32
  %tobool = icmp ne i32 %bf.cast12, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %sw.bb.4
  %19 = load i64, i64* %value.addr, align 8
  %20 = load %struct.Lisp_Symbol*, %struct.Lisp_Symbol** %sym, align 8
  %val13 = getelementptr inbounds %struct.Lisp_Symbol, %struct.Lisp_Symbol* %20, i32 0, i32 2
  %value14 = bitcast %union.anon.5* %val13 to i64*
  store i64 %19, i64* %value14, align 8
  br label %if.end

if.else:                                          ; preds = %sw.bb.4
  %21 = load i64, i64* %symbol.addr, align 8
  %22 = load i64, i64* %value.addr, align 8
  %call15 = call i64 @builtin_lisp_symbol(i32 0)
  call void @set_internal(i64 %21, i64 %22, i64 %call15, i1 zeroext true)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  br label %sw.epilog

sw.bb.16:                                         ; preds = %start
  %23 = load %struct.Lisp_Symbol*, %struct.Lisp_Symbol** %sym, align 8
  %call17 = call %struct.Lisp_Buffer_Local_Value* @SYMBOL_BLV(%struct.Lisp_Symbol* %23)
  %24 = bitcast %struct.Lisp_Buffer_Local_Value* %call17 to i8*
  %bf.load18 = load i8, i8* %24, align 8
  %bf.lshr19 = lshr i8 %bf.load18, 1
  %bf.clear20 = and i8 %bf.lshr19, 1
  %bf.cast21 = trunc i8 %bf.clear20 to i1
  br i1 %bf.cast21, label %if.then.22, label %if.end.23

if.then.22:                                       ; preds = %sw.bb.16
  call void (i8*, ...) @error(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.14, i32 0, i32 0)) #8
  unreachable

if.end.23:                                        ; preds = %sw.bb.16
  br label %sw.bb.24

sw.bb.24:                                         ; preds = %start, %if.end.23
  %25 = load i64, i64* %symbol.addr, align 8
  %call25 = call i64 @find_symbol_value(i64 %25)
  store i64 %call25, i64* %ovalue, align 8
  %26 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %let26 = bitcast %union.specbinding* %26 to %struct.anon.3*
  %27 = bitcast %struct.anon.3* %let26 to i8*
  store i8 6, i8* %27, align 8
  %28 = load i64, i64* %symbol.addr, align 8
  %29 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %let27 = bitcast %union.specbinding* %29 to %struct.anon.3*
  %symbol28 = getelementptr inbounds %struct.anon.3, %struct.anon.3* %let27, i32 0, i32 1
  store i64 %28, i64* %symbol28, align 8
  %30 = load i64, i64* %ovalue, align 8
  %31 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %let29 = bitcast %union.specbinding* %31 to %struct.anon.3*
  %old_value30 = getelementptr inbounds %struct.anon.3, %struct.anon.3* %let29, i32 0, i32 2
  store i64 %30, i64* %old_value30, align 8
  %call31 = call i64 @Fcurrent_buffer()
  %32 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %let32 = bitcast %union.specbinding* %32 to %struct.anon.3*
  %where = getelementptr inbounds %struct.anon.3, %struct.anon.3* %let32, i32 0, i32 3
  store i64 %call31, i64* %where, align 8
  %33 = load %struct.Lisp_Symbol*, %struct.Lisp_Symbol** %sym, align 8
  %34 = bitcast %struct.Lisp_Symbol* %33 to i16*
  %bf.load33 = load i16, i16* %34, align 8
  %bf.lshr34 = lshr i16 %bf.load33, 1
  %bf.clear35 = and i16 %bf.lshr34, 7
  %bf.cast36 = zext i16 %bf.clear35 to i32
  %cmp37 = icmp eq i32 %bf.cast36, 2
  br i1 %cmp37, label %if.then.39, label %if.else.46

if.then.39:                                       ; preds = %sw.bb.24
  %35 = load %struct.Lisp_Symbol*, %struct.Lisp_Symbol** %sym, align 8
  %call40 = call %struct.Lisp_Buffer_Local_Value* @SYMBOL_BLV(%struct.Lisp_Symbol* %35)
  %call41 = call i32 @blv_found(%struct.Lisp_Buffer_Local_Value* %call40)
  %tobool42 = icmp ne i32 %call41, 0
  br i1 %tobool42, label %if.end.45, label %if.then.43

if.then.43:                                       ; preds = %if.then.39
  %36 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %let44 = bitcast %union.specbinding* %36 to %struct.anon.3*
  %37 = bitcast %struct.anon.3* %let44 to i8*
  store i8 7, i8* %37, align 8
  br label %if.end.45

if.end.45:                                        ; preds = %if.then.43, %if.then.39
  br label %if.end.62

if.else.46:                                       ; preds = %sw.bb.24
  %38 = load %struct.Lisp_Symbol*, %struct.Lisp_Symbol** %sym, align 8
  %call47 = call %union.Lisp_Fwd* @SYMBOL_FWD(%struct.Lisp_Symbol* %38)
  %call48 = call zeroext i1 @BUFFER_OBJFWDP(%union.Lisp_Fwd* %call47)
  br i1 %call48, label %if.then.49, label %if.else.59

if.then.49:                                       ; preds = %if.else.46
  %39 = load i64, i64* %symbol.addr, align 8
  %call50 = call i64 @builtin_lisp_symbol(i32 0)
  %call51 = call i64 @Flocal_variable_p(i64 %39, i64 %call50)
  %call52 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp53 = icmp eq i64 %call51, %call52
  br i1 %cmp53, label %if.then.55, label %if.end.58

if.then.55:                                       ; preds = %if.then.49
  %40 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %let56 = bitcast %union.specbinding* %40 to %struct.anon.3*
  %41 = bitcast %struct.anon.3* %let56 to i8*
  store i8 7, i8* %41, align 8
  call void @grow_specpdl()
  %42 = load i64, i64* %symbol.addr, align 8
  %43 = load i64, i64* %value.addr, align 8
  %call57 = call i64 @Fset_default(i64 %42, i64 %43)
  br label %sw.epilog

if.end.58:                                        ; preds = %if.then.49
  br label %if.end.61

if.else.59:                                       ; preds = %if.else.46
  %44 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %let60 = bitcast %union.specbinding* %44 to %struct.anon.3*
  %45 = bitcast %struct.anon.3* %let60 to i8*
  store i8 5, i8* %45, align 8
  br label %if.end.61

if.end.61:                                        ; preds = %if.else.59, %if.end.58
  br label %if.end.62

if.end.62:                                        ; preds = %if.end.61, %if.end.45
  call void @grow_specpdl()
  %46 = load i64, i64* %symbol.addr, align 8
  %47 = load i64, i64* %value.addr, align 8
  %call63 = call i64 @builtin_lisp_symbol(i32 0)
  call void @set_internal(i64 %46, i64 %47, i64 %call63, i1 zeroext true)
  br label %sw.epilog

sw.default:                                       ; preds = %start
  call void @emacs_abort() #8
  unreachable

sw.epilog:                                        ; preds = %if.then.55, %if.end.62, %if.end
  ret void
}

declare i64 @intern(i8*) #1

; Function Attrs: nounwind uwtable
define i64 @apply1(i64 %fn, i64 %arg) #0 {
entry:
  %fn.addr = alloca i64, align 8
  %arg.addr = alloca i64, align 8
  %.compoundliteral = alloca [2 x i64], align 8
  store i64 %fn, i64* %fn.addr, align 8
  store i64 %arg, i64* %arg.addr, align 8
  %0 = load i64, i64* %arg.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %0, %call
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %call1 = call i64 @Ffuncall(i64 1, i64* %fn.addr)
  br label %cond.end

cond.false:                                       ; preds = %entry
  %arrayinit.begin = getelementptr inbounds [2 x i64], [2 x i64]* %.compoundliteral, i64 0, i64 0
  %1 = load i64, i64* %fn.addr, align 8
  store i64 %1, i64* %arrayinit.begin
  %arrayinit.element = getelementptr inbounds i64, i64* %arrayinit.begin, i64 1
  %2 = load i64, i64* %arg.addr, align 8
  store i64 %2, i64* %arrayinit.element
  %arraydecay = getelementptr inbounds [2 x i64], [2 x i64]* %.compoundliteral, i32 0, i32 0
  %call2 = call i64 @Fapply(i64 2, i64* %arraydecay)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call1, %cond.true ], [ %call2, %cond.false ]
  ret i64 %cond
}

; Function Attrs: noreturn
declare i64 @Ftop_level() #2

; Function Attrs: nounwind uwtable
define i64 @unbind_to(i64 %count, i64 %value) #0 {
entry:
  %count.addr = alloca i64, align 8
  %value.addr = alloca i64, align 8
  %quitf = alloca i64, align 8
  %sym = alloca i64, align 8
  %symbol = alloca i64, align 8
  %where = alloca i64, align 8
  %old_value = alloca i64, align 8
  store i64 %count, i64* %count.addr, align 8
  store i64 %value, i64* %value.addr, align 8
  %0 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  store i64 %0, i64* %quitf, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  br label %while.cond

while.cond:                                       ; preds = %sw.epilog, %entry
  %1 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %2 = load %union.specbinding*, %union.specbinding** @specpdl, align 8
  %3 = load i64, i64* %count.addr, align 8
  %add.ptr = getelementptr inbounds %union.specbinding, %union.specbinding* %2, i64 %3
  %cmp = icmp ne %union.specbinding* %1, %add.ptr
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %4 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %incdec.ptr = getelementptr inbounds %union.specbinding, %union.specbinding* %4, i32 -1
  store %union.specbinding* %incdec.ptr, %union.specbinding** @specpdl_ptr, align 8
  %5 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %6 = bitcast %union.specbinding* %5 to i8*
  %bf.load = load i8, i8* %6, align 8
  %bf.cast = zext i8 %bf.load to i32
  switch i32 %bf.cast, label %sw.epilog [
    i32 0, label %sw.bb
    i32 1, label %sw.bb.2
    i32 2, label %sw.bb.6
    i32 3, label %sw.bb.10
    i32 4, label %sw.bb.12
    i32 5, label %sw.bb.13
    i32 7, label %sw.bb.26
    i32 6, label %sw.bb.30
  ]

sw.bb:                                            ; preds = %while.body
  %7 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %unwind = bitcast %union.specbinding* %7 to %struct.anon*
  %func = getelementptr inbounds %struct.anon, %struct.anon* %unwind, i32 0, i32 1
  %8 = load void (i64)*, void (i64)** %func, align 8
  %9 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %unwind1 = bitcast %union.specbinding* %9 to %struct.anon*
  %arg = getelementptr inbounds %struct.anon, %struct.anon* %unwind1, i32 0, i32 2
  %10 = load i64, i64* %arg, align 8
  call void %8(i64 %10)
  br label %sw.epilog

sw.bb.2:                                          ; preds = %while.body
  %11 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %unwind_ptr = bitcast %union.specbinding* %11 to %struct.anon.0*
  %func3 = getelementptr inbounds %struct.anon.0, %struct.anon.0* %unwind_ptr, i32 0, i32 1
  %12 = load void (i8*)*, void (i8*)** %func3, align 8
  %13 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %unwind_ptr4 = bitcast %union.specbinding* %13 to %struct.anon.0*
  %arg5 = getelementptr inbounds %struct.anon.0, %struct.anon.0* %unwind_ptr4, i32 0, i32 2
  %14 = load i8*, i8** %arg5, align 8
  call void %12(i8* %14)
  br label %sw.epilog

sw.bb.6:                                          ; preds = %while.body
  %15 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %unwind_int = bitcast %union.specbinding* %15 to %struct.anon.1*
  %func7 = getelementptr inbounds %struct.anon.1, %struct.anon.1* %unwind_int, i32 0, i32 1
  %16 = load void (i32)*, void (i32)** %func7, align 8
  %17 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %unwind_int8 = bitcast %union.specbinding* %17 to %struct.anon.1*
  %arg9 = getelementptr inbounds %struct.anon.1, %struct.anon.1* %unwind_int8, i32 0, i32 2
  %18 = load i32, i32* %arg9, align 4
  call void %16(i32 %18)
  br label %sw.epilog

sw.bb.10:                                         ; preds = %while.body
  %19 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %unwind_void = bitcast %union.specbinding* %19 to %struct.anon.2*
  %func11 = getelementptr inbounds %struct.anon.2, %struct.anon.2* %unwind_void, i32 0, i32 1
  %20 = load void ()*, void ()** %func11, align 8
  call void %20()
  br label %sw.epilog

sw.bb.12:                                         ; preds = %while.body
  br label %sw.epilog

sw.bb.13:                                         ; preds = %while.body
  %21 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %call14 = call i64 @specpdl_symbol(%union.specbinding* %21)
  store i64 %call14, i64* %sym, align 8
  %22 = load i64, i64* %sym, align 8
  %and = and i64 %22, 7
  %conv = trunc i64 %and to i32
  %cmp15 = icmp eq i32 %conv, 0
  br i1 %cmp15, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %sw.bb.13
  %23 = load i64, i64* %sym, align 8
  %sub = sub nsw i64 %23, 0
  %add.ptr17 = getelementptr inbounds i8, i8* bitcast ([1074 x %struct.Lisp_Symbol]* @lispsym to i8*), i64 %sub
  %24 = bitcast i8* %add.ptr17 to %struct.Lisp_Symbol*
  %25 = bitcast %struct.Lisp_Symbol* %24 to i16*
  %bf.load18 = load i16, i16* %25, align 8
  %bf.lshr = lshr i16 %bf.load18, 1
  %bf.clear = and i16 %bf.lshr, 7
  %bf.cast19 = zext i16 %bf.clear to i32
  %cmp20 = icmp eq i32 %bf.cast19, 4
  br i1 %cmp20, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %26 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %call22 = call i64 @specpdl_old_value(%union.specbinding* %26)
  %27 = load i64, i64* %sym, align 8
  %sub23 = sub nsw i64 %27, 0
  %add.ptr24 = getelementptr inbounds i8, i8* bitcast ([1074 x %struct.Lisp_Symbol]* @lispsym to i8*), i64 %sub23
  %28 = bitcast i8* %add.ptr24 to %struct.Lisp_Symbol*
  %val = getelementptr inbounds %struct.Lisp_Symbol, %struct.Lisp_Symbol* %28, i32 0, i32 2
  %value25 = bitcast %union.anon.5* %val to i64*
  store i64 %call22, i64* %value25, align 8
  br label %sw.epilog

if.else:                                          ; preds = %land.lhs.true, %sw.bb.13
  br label %if.end

if.end:                                           ; preds = %if.else
  br label %sw.bb.26

sw.bb.26:                                         ; preds = %while.body, %if.end
  %29 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %call27 = call i64 @specpdl_symbol(%union.specbinding* %29)
  %30 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %call28 = call i64 @specpdl_old_value(%union.specbinding* %30)
  %call29 = call i64 @Fset_default(i64 %call27, i64 %call28)
  br label %sw.epilog

sw.bb.30:                                         ; preds = %while.body
  %31 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %call31 = call i64 @specpdl_symbol(%union.specbinding* %31)
  store i64 %call31, i64* %symbol, align 8
  %32 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %call32 = call i64 @specpdl_where(%union.specbinding* %32)
  store i64 %call32, i64* %where, align 8
  %33 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %call33 = call i64 @specpdl_old_value(%union.specbinding* %33)
  store i64 %call33, i64* %old_value, align 8
  %34 = load i64, i64* %symbol, align 8
  %35 = load i64, i64* %where, align 8
  %call34 = call i64 @Flocal_variable_p(i64 %34, i64 %35)
  %call35 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp36 = icmp eq i64 %call34, %call35
  br i1 %cmp36, label %if.end.39, label %if.then.38

if.then.38:                                       ; preds = %sw.bb.30
  %36 = load i64, i64* %symbol, align 8
  %37 = load i64, i64* %old_value, align 8
  %38 = load i64, i64* %where, align 8
  call void @set_internal(i64 %36, i64 %37, i64 %38, i1 zeroext true)
  br label %if.end.39

if.end.39:                                        ; preds = %if.then.38, %sw.bb.30
  br label %sw.epilog

sw.epilog:                                        ; preds = %while.body, %if.end.39, %sw.bb.26, %if.then, %sw.bb.12, %sw.bb.10, %sw.bb.6, %sw.bb.2, %sw.bb
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %39 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call40 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp41 = icmp eq i64 %39, %call40
  br i1 %cmp41, label %land.lhs.true.43, label %if.end.48

land.lhs.true.43:                                 ; preds = %while.end
  %40 = load i64, i64* %quitf, align 8
  %call44 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp45 = icmp eq i64 %40, %call44
  br i1 %cmp45, label %if.end.48, label %if.then.47

if.then.47:                                       ; preds = %land.lhs.true.43
  %41 = load i64, i64* %quitf, align 8
  store i64 %41, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  br label %if.end.48

if.end.48:                                        ; preds = %if.then.47, %land.lhs.true.43, %while.end
  %42 = load i64, i64* %value.addr, align 8
  ret i64 %42
}

; Function Attrs: nounwind uwtable
define i64 @For(i64 %args) #0 {
entry:
  %args.addr = alloca i64, align 8
  %val = alloca i64, align 8
  store i64 %args, i64* %args.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call, i64* %val, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %0 = load i64, i64* %args.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = load i64, i64* %args.addr, align 8
  %sub = sub nsw i64 %1, 3
  %2 = inttoptr i64 %sub to i8*
  %3 = bitcast i8* %2 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %3, i32 0, i32 0
  %4 = load i64, i64* %car, align 8
  %call2 = call i64 @eval_sub(i64 %4)
  store i64 %call2, i64* %val, align 8
  %5 = load i64, i64* %val, align 8
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp4 = icmp eq i64 %5, %call3
  br i1 %cmp4, label %if.end, label %if.then

if.then:                                          ; preds = %while.body
  br label %while.end

if.end:                                           ; preds = %while.body
  %6 = load i64, i64* %args.addr, align 8
  %sub6 = sub nsw i64 %6, 3
  %7 = inttoptr i64 %sub6 to i8*
  %8 = bitcast i8* %7 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %8, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %9 = load i64, i64* %cdr, align 8
  store i64 %9, i64* %args.addr, align 8
  br label %while.cond

while.end:                                        ; preds = %if.then, %while.cond
  %10 = load i64, i64* %val, align 8
  ret i64 %10
}

; Function Attrs: nounwind uwtable
define i64 @eval_sub(i64 %form) #0 {
entry:
  %retval = alloca i64, align 8
  %form.addr = alloca i64, align 8
  %fun = alloca i64, align 8
  %val = alloca i64, align 8
  %original_fun = alloca i64, align 8
  %original_args = alloca i64, align 8
  %funcar = alloca i64, align 8
  %count = alloca i64, align 8
  %argvals = alloca [8 x i64], align 16
  %lex_binding = alloca i64, align 8
  %args_left = alloca i64, align 8
  %numargs = alloca i64, align 8
  %vals = alloca i64*, align 8
  %argnum = alloca i64, align 8
  %sa_avail = alloca i64, align 8
  %sa_count = alloca i64, align 8
  %sa_must_free = alloca i8, align 1
  %alloca_nbytes = alloca i64, align 8
  %arg_ = alloca i64, align 8
  %i = alloca i32, align 4
  %maxargs = alloca i32, align 4
  %count1 = alloca i64, align 8
  %exp = alloca i64, align 8
  store i64 %form, i64* %form.addr, align 8
  %0 = load i64, i64* %form.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 147), align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp2 = icmp eq i64 %1, %call
  br i1 %cmp2, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then
  %2 = load i64, i64* %form.addr, align 8
  %3 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 147), align 8
  %call4 = call i64 @Fassq(i64 %2, i64 %3)
  br label %cond.end

cond.false:                                       ; preds = %if.then
  %call5 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call4, %cond.true ], [ %call5, %cond.false ]
  store i64 %cond, i64* %lex_binding, align 8
  %4 = load i64, i64* %lex_binding, align 8
  %and6 = and i64 %4, 7
  %conv7 = trunc i64 %and6 to i32
  %cmp8 = icmp eq i32 %conv7, 3
  br i1 %cmp8, label %if.then.10, label %if.else

if.then.10:                                       ; preds = %cond.end
  %5 = load i64, i64* %lex_binding, align 8
  %sub = sub nsw i64 %5, 3
  %6 = inttoptr i64 %sub to i8*
  %7 = bitcast i8* %6 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %7, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %8 = load i64, i64* %cdr, align 8
  store i64 %8, i64* %retval
  br label %return

if.else:                                          ; preds = %cond.end
  %9 = load i64, i64* %form.addr, align 8
  %call11 = call i64 @Fsymbol_value(i64 %9)
  store i64 %call11, i64* %retval
  br label %return

if.end:                                           ; preds = %entry
  %10 = load i64, i64* %form.addr, align 8
  %and12 = and i64 %10, 7
  %conv13 = trunc i64 %and12 to i32
  %cmp14 = icmp eq i32 %conv13, 3
  br i1 %cmp14, label %if.end.17, label %if.then.16

if.then.16:                                       ; preds = %if.end
  %11 = load i64, i64* %form.addr, align 8
  store i64 %11, i64* %retval
  br label %return

if.end.17:                                        ; preds = %if.end
  br label %do.body

do.body:                                          ; preds = %if.end.17
  %12 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call18 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp19 = icmp eq i64 %12, %call18
  br i1 %cmp19, label %if.else.25, label %land.lhs.true

land.lhs.true:                                    ; preds = %do.body
  %13 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  %call21 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp22 = icmp eq i64 %13, %call21
  br i1 %cmp22, label %if.then.24, label %if.else.25

if.then.24:                                       ; preds = %land.lhs.true
  call void @process_quit_flag()
  br label %if.end.28

if.else.25:                                       ; preds = %land.lhs.true, %do.body
  %14 = load volatile i8, i8* @pending_signals, align 1
  %tobool = trunc i8 %14 to i1
  br i1 %tobool, label %if.then.26, label %if.end.27

if.then.26:                                       ; preds = %if.else.25
  call void @process_pending_signals()
  br label %if.end.27

if.end.27:                                        ; preds = %if.then.26, %if.else.25
  br label %if.end.28

if.end.28:                                        ; preds = %if.end.27, %if.then.24
  br label %do.end

do.end:                                           ; preds = %if.end.28
  call void @maybe_gc()
  %15 = load i64, i64* @lisp_eval_depth, align 8
  %inc = add nsw i64 %15, 1
  store i64 %inc, i64* @lisp_eval_depth, align 8
  %16 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 396), align 8
  %cmp29 = icmp sgt i64 %inc, %16
  br i1 %cmp29, label %if.then.31, label %if.end.40

if.then.31:                                       ; preds = %do.end
  %17 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 396), align 8
  %cmp32 = icmp slt i64 %17, 100
  br i1 %cmp32, label %if.then.34, label %if.end.35

if.then.34:                                       ; preds = %if.then.31
  store i64 100, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 396), align 8
  br label %if.end.35

if.end.35:                                        ; preds = %if.then.34, %if.then.31
  %18 = load i64, i64* @lisp_eval_depth, align 8
  %19 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 396), align 8
  %cmp36 = icmp sgt i64 %18, %19
  br i1 %cmp36, label %if.then.38, label %if.end.39

if.then.38:                                       ; preds = %if.end.35
  call void (i8*, ...) @error(i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.11, i32 0, i32 0)) #8
  unreachable

if.end.39:                                        ; preds = %if.end.35
  br label %if.end.40

if.end.40:                                        ; preds = %if.end.39, %do.end
  %20 = load i64, i64* %form.addr, align 8
  %sub41 = sub nsw i64 %20, 3
  %21 = inttoptr i64 %sub41 to i8*
  %22 = bitcast i8* %21 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %22, i32 0, i32 0
  %23 = load i64, i64* %car, align 8
  store i64 %23, i64* %original_fun, align 8
  %24 = load i64, i64* %form.addr, align 8
  %sub42 = sub nsw i64 %24, 3
  %25 = inttoptr i64 %sub42 to i8*
  %26 = bitcast i8* %25 to %struct.Lisp_Cons*
  %u43 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %26, i32 0, i32 1
  %cdr44 = bitcast %union.anon* %u43 to i64*
  %27 = load i64, i64* %cdr44, align 8
  store i64 %27, i64* %original_args, align 8
  %28 = load i64, i64* %original_fun, align 8
  %call45 = call i64 @record_in_backtrace(i64 %28, i64* %original_args, i64 -1)
  store i64 %call45, i64* %count, align 8
  %29 = load i8, i8* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 432), align 1
  %tobool46 = trunc i8 %29 to i1
  br i1 %tobool46, label %if.then.47, label %if.end.49

if.then.47:                                       ; preds = %if.end.40
  %call48 = call i64 @builtin_lisp_symbol(i32 901)
  %30 = load i64, i64* %count, align 8
  call void @do_debug_on_call(i64 %call48, i64 %30)
  br label %if.end.49

if.end.49:                                        ; preds = %if.then.47, %if.end.40
  br label %retry

retry:                                            ; preds = %if.then.2779, %if.end.49
  %31 = load i64, i64* %original_fun, align 8
  store i64 %31, i64* %fun, align 8
  %32 = load i64, i64* %fun, align 8
  %and50 = and i64 %32, 7
  %conv51 = trunc i64 %and50 to i32
  %cmp52 = icmp eq i32 %conv51, 0
  br i1 %cmp52, label %if.else.58, label %if.then.54

if.then.54:                                       ; preds = %retry
  %33 = load i64, i64* %fun, align 8
  %call55 = call i64 @builtin_lisp_symbol(i32 0)
  %call56 = call i64 @Fcons(i64 %33, i64 %call55)
  %call57 = call i64 @Ffunction(i64 %call56)
  store i64 %call57, i64* %fun, align 8
  br label %if.end.71

if.else.58:                                       ; preds = %retry
  %34 = load i64, i64* %fun, align 8
  %call59 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp60 = icmp eq i64 %34, %call59
  br i1 %cmp60, label %if.end.70, label %land.lhs.true.62

land.lhs.true.62:                                 ; preds = %if.else.58
  %35 = load i64, i64* %fun, align 8
  %sub63 = sub nsw i64 %35, 0
  %add.ptr = getelementptr inbounds i8, i8* bitcast ([1074 x %struct.Lisp_Symbol]* @lispsym to i8*), i64 %sub63
  %36 = bitcast i8* %add.ptr to %struct.Lisp_Symbol*
  %function = getelementptr inbounds %struct.Lisp_Symbol, %struct.Lisp_Symbol* %36, i32 0, i32 3
  %37 = load i64, i64* %function, align 8
  store i64 %37, i64* %fun, align 8
  %38 = load i64, i64* %fun, align 8
  %and64 = and i64 %38, 7
  %conv65 = trunc i64 %and64 to i32
  %cmp66 = icmp eq i32 %conv65, 0
  br i1 %cmp66, label %if.then.68, label %if.end.70

if.then.68:                                       ; preds = %land.lhs.true.62
  %39 = load i64, i64* %fun, align 8
  %call69 = call i64 @indirect_function(i64 %39)
  store i64 %call69, i64* %fun, align 8
  br label %if.end.70

if.end.70:                                        ; preds = %if.then.68, %land.lhs.true.62, %if.else.58
  br label %if.end.71

if.end.71:                                        ; preds = %if.end.70, %if.then.54
  %40 = load i64, i64* %fun, align 8
  %call72 = call zeroext i1 @SUBRP(i64 %40)
  br i1 %call72, label %if.then.73, label %if.else.2749

if.then.73:                                       ; preds = %if.end.71
  %41 = load i64, i64* %original_args, align 8
  store i64 %41, i64* %args_left, align 8
  %42 = load i64, i64* %args_left, align 8
  %call74 = call i64 @Flength(i64 %42)
  store i64 %call74, i64* %numargs, align 8
  %43 = load i64, i64* %numargs, align 8
  %shr = ashr i64 %43, 2
  %44 = load i64, i64* %fun, align 8
  %call75 = call %struct.Lisp_Subr* @XSUBR(i64 %44)
  %min_args = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call75, i32 0, i32 2
  %45 = load i16, i16* %min_args, align 2
  %conv76 = sext i16 %45 to i64
  %cmp77 = icmp slt i64 %shr, %conv76
  br i1 %cmp77, label %if.then.90, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then.73
  %46 = load i64, i64* %fun, align 8
  %call79 = call %struct.Lisp_Subr* @XSUBR(i64 %46)
  %max_args = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call79, i32 0, i32 3
  %47 = load i16, i16* %max_args, align 2
  %conv80 = sext i16 %47 to i32
  %cmp81 = icmp sge i32 %conv80, 0
  br i1 %cmp81, label %land.lhs.true.83, label %if.else.92

land.lhs.true.83:                                 ; preds = %lor.lhs.false
  %48 = load i64, i64* %fun, align 8
  %call84 = call %struct.Lisp_Subr* @XSUBR(i64 %48)
  %max_args85 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call84, i32 0, i32 3
  %49 = load i16, i16* %max_args85, align 2
  %conv86 = sext i16 %49 to i64
  %50 = load i64, i64* %numargs, align 8
  %shr87 = ashr i64 %50, 2
  %cmp88 = icmp slt i64 %conv86, %shr87
  br i1 %cmp88, label %if.then.90, label %if.else.92

if.then.90:                                       ; preds = %land.lhs.true.83, %if.then.73
  %call91 = call i64 @builtin_lisp_symbol(i32 1043)
  %51 = load i64, i64* %original_fun, align 8
  %52 = load i64, i64* %numargs, align 8
  call void @xsignal2(i64 %call91, i64 %51, i64 %52) #8
  unreachable

if.else.92:                                       ; preds = %land.lhs.true.83, %lor.lhs.false
  %53 = load i64, i64* %fun, align 8
  %call93 = call %struct.Lisp_Subr* @XSUBR(i64 %53)
  %max_args94 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call93, i32 0, i32 3
  %54 = load i16, i16* %max_args94, align 2
  %conv95 = sext i16 %54 to i32
  %cmp96 = icmp eq i32 %conv95, -1
  br i1 %cmp96, label %if.then.98, label %if.else.102

if.then.98:                                       ; preds = %if.else.92
  %55 = load i64, i64* %fun, align 8
  %call99 = call %struct.Lisp_Subr* @XSUBR(i64 %55)
  %function100 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call99, i32 0, i32 1
  %aUNEVALLED = bitcast %union.anon.6* %function100 to i64 (i64)**
  %56 = load i64 (i64)*, i64 (i64)** %aUNEVALLED, align 8
  %57 = load i64, i64* %args_left, align 8
  %call101 = call i64 %56(i64 %57)
  store i64 %call101, i64* %val, align 8
  br label %if.end.2747

if.else.102:                                      ; preds = %if.else.92
  %58 = load i64, i64* %fun, align 8
  %call103 = call %struct.Lisp_Subr* @XSUBR(i64 %58)
  %max_args104 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call103, i32 0, i32 3
  %59 = load i16, i16* %max_args104, align 2
  %conv105 = sext i16 %59 to i32
  %cmp106 = icmp eq i32 %conv105, -2
  br i1 %cmp106, label %if.then.108, label %if.else.2662

if.then.108:                                      ; preds = %if.else.102
  store i64 0, i64* %argnum, align 8
  store i64 16384, i64* %sa_avail, align 8
  %call109 = call i64 @SPECPDL_INDEX()
  store i64 %call109, i64* %sa_count, align 8
  store i8 0, i8* %sa_must_free, align 1
  br label %do.body.110

do.body.110:                                      ; preds = %if.then.108
  br i1 false, label %cond.true.111, label %cond.false.658

cond.true.111:                                    ; preds = %do.body.110
  br i1 false, label %cond.true.112, label %cond.false.409

cond.true.112:                                    ; preds = %cond.true.111
  %60 = load i64, i64* %numargs, align 8
  %shr113 = ashr i64 %60, 2
  %conv114 = trunc i64 %shr113 to i8
  %conv115 = sext i8 %conv114 to i32
  %add = add nsw i32 0, %conv115
  %mul = mul nsw i32 0, %add
  %sub116 = sub nsw i32 %mul, 1
  %cmp117 = icmp slt i32 %sub116, 0
  br i1 %cmp117, label %cond.true.119, label %cond.false.139

cond.true.119:                                    ; preds = %cond.true.112
  %61 = load i64, i64* %numargs, align 8
  %shr120 = ashr i64 %61, 2
  %conv121 = trunc i64 %shr120 to i8
  %conv122 = sext i8 %conv121 to i32
  %add123 = add nsw i32 0, %conv122
  %mul124 = mul nsw i32 0, %add123
  %add125 = add nsw i32 %mul124, 0
  %neg = xor i32 %add125, -1
  %cmp126 = icmp eq i32 %neg, -1
  %conv127 = zext i1 %cmp126 to i32
  %sub128 = sub nsw i32 0, %conv127
  %62 = load i64, i64* %numargs, align 8
  %shr129 = ashr i64 %62, 2
  %conv130 = trunc i64 %shr129 to i8
  %conv131 = sext i8 %conv130 to i32
  %add132 = add nsw i32 0, %conv131
  %mul133 = mul nsw i32 0, %add132
  %add134 = add nsw i32 %mul133, 1
  %shl = shl i32 %add134, 30
  %sub135 = sub nsw i32 %shl, 1
  %mul136 = mul nsw i32 %sub135, 2
  %add137 = add nsw i32 %mul136, 1
  %sub138 = sub nsw i32 %sub128, %add137
  br label %cond.end.146

cond.false.139:                                   ; preds = %cond.true.112
  %63 = load i64, i64* %numargs, align 8
  %shr140 = ashr i64 %63, 2
  %conv141 = trunc i64 %shr140 to i8
  %conv142 = sext i8 %conv141 to i32
  %add143 = add nsw i32 0, %conv142
  %mul144 = mul nsw i32 0, %add143
  %add145 = add nsw i32 %mul144, 0
  br label %cond.end.146

cond.end.146:                                     ; preds = %cond.false.139, %cond.true.119
  %cond147 = phi i32 [ %sub138, %cond.true.119 ], [ %add145, %cond.false.139 ]
  %cmp148 = icmp eq i32 %cond147, 0
  br i1 %cmp148, label %land.lhs.true.150, label %lor.lhs.false.156

land.lhs.true.150:                                ; preds = %cond.end.146
  %64 = load i64, i64* %numargs, align 8
  %shr151 = ashr i64 %64, 2
  %conv152 = trunc i64 %shr151 to i8
  %conv153 = sext i8 %conv152 to i32
  %cmp154 = icmp slt i32 %conv153, 0
  br i1 %cmp154, label %cond.true.357, label %lor.lhs.false.156

lor.lhs.false.156:                                ; preds = %land.lhs.true.150, %cond.end.146
  br i1 false, label %cond.true.157, label %cond.false.245

cond.true.157:                                    ; preds = %lor.lhs.false.156
  %65 = load i64, i64* %numargs, align 8
  %shr158 = ashr i64 %65, 2
  %conv159 = trunc i64 %shr158 to i8
  %conv160 = sext i8 %conv159 to i32
  %cmp161 = icmp slt i32 %conv160, 0
  br i1 %cmp161, label %cond.true.163, label %cond.false.197

cond.true.163:                                    ; preds = %cond.true.157
  %66 = load i64, i64* %numargs, align 8
  %shr164 = ashr i64 %66, 2
  %conv165 = trunc i64 %shr164 to i8
  %conv166 = sext i8 %conv165 to i32
  %67 = load i64, i64* %numargs, align 8
  %shr167 = ashr i64 %67, 2
  %conv168 = trunc i64 %shr167 to i8
  %conv169 = sext i8 %conv168 to i32
  %add170 = add nsw i32 0, %conv169
  %mul171 = mul nsw i32 0, %add170
  %sub172 = sub nsw i32 %mul171, 1
  %cmp173 = icmp slt i32 %sub172, 0
  br i1 %cmp173, label %cond.true.175, label %cond.false.186

cond.true.175:                                    ; preds = %cond.true.163
  %68 = load i64, i64* %numargs, align 8
  %shr176 = ashr i64 %68, 2
  %conv177 = trunc i64 %shr176 to i8
  %conv178 = sext i8 %conv177 to i32
  %add179 = add nsw i32 0, %conv178
  %mul180 = mul nsw i32 0, %add179
  %add181 = add nsw i32 %mul180, 1
  %shl182 = shl i32 %add181, 30
  %sub183 = sub nsw i32 %shl182, 1
  %mul184 = mul nsw i32 %sub183, 2
  %add185 = add nsw i32 %mul184, 1
  br label %cond.end.193

cond.false.186:                                   ; preds = %cond.true.163
  %69 = load i64, i64* %numargs, align 8
  %shr187 = ashr i64 %69, 2
  %conv188 = trunc i64 %shr187 to i8
  %conv189 = sext i8 %conv188 to i32
  %add190 = add nsw i32 0, %conv189
  %mul191 = mul nsw i32 0, %add190
  %sub192 = sub nsw i32 %mul191, 1
  br label %cond.end.193

cond.end.193:                                     ; preds = %cond.false.186, %cond.true.175
  %cond194 = phi i32 [ %add185, %cond.true.175 ], [ %sub192, %cond.false.186 ]
  %div = sdiv i32 %cond194, 8
  %cmp195 = icmp slt i32 %conv166, %div
  br i1 %cmp195, label %cond.true.357, label %lor.lhs.false.334

cond.false.197:                                   ; preds = %cond.true.157
  br i1 false, label %cond.true.198, label %cond.false.199

cond.true.198:                                    ; preds = %cond.false.197
  br i1 false, label %cond.true.357, label %lor.lhs.false.334

cond.false.199:                                   ; preds = %cond.false.197
  %70 = load i64, i64* %numargs, align 8
  %shr200 = ashr i64 %70, 2
  %conv201 = trunc i64 %shr200 to i8
  %conv202 = sext i8 %conv201 to i32
  %add203 = add nsw i32 0, %conv202
  %mul204 = mul nsw i32 0, %add203
  %sub205 = sub nsw i32 %mul204, 1
  %cmp206 = icmp slt i32 %sub205, 0
  br i1 %cmp206, label %cond.true.208, label %cond.false.230

cond.true.208:                                    ; preds = %cond.false.199
  %71 = load i64, i64* %numargs, align 8
  %shr209 = ashr i64 %71, 2
  %conv210 = trunc i64 %shr209 to i8
  %conv211 = sext i8 %conv210 to i32
  %add212 = add nsw i32 0, %conv211
  %mul213 = mul nsw i32 0, %add212
  %add214 = add nsw i32 %mul213, 0
  %neg215 = xor i32 %add214, -1
  %cmp216 = icmp eq i32 %neg215, -1
  %conv217 = zext i1 %cmp216 to i32
  %sub218 = sub nsw i32 0, %conv217
  %72 = load i64, i64* %numargs, align 8
  %shr219 = ashr i64 %72, 2
  %conv220 = trunc i64 %shr219 to i8
  %conv221 = sext i8 %conv220 to i32
  %add222 = add nsw i32 0, %conv221
  %mul223 = mul nsw i32 0, %add222
  %add224 = add nsw i32 %mul223, 1
  %shl225 = shl i32 %add224, 30
  %sub226 = sub nsw i32 %shl225, 1
  %mul227 = mul nsw i32 %sub226, 2
  %add228 = add nsw i32 %mul227, 1
  %sub229 = sub nsw i32 %sub218, %add228
  br label %cond.end.237

cond.false.230:                                   ; preds = %cond.false.199
  %73 = load i64, i64* %numargs, align 8
  %shr231 = ashr i64 %73, 2
  %conv232 = trunc i64 %shr231 to i8
  %conv233 = sext i8 %conv232 to i32
  %add234 = add nsw i32 0, %conv233
  %mul235 = mul nsw i32 0, %add234
  %add236 = add nsw i32 %mul235, 0
  br label %cond.end.237

cond.end.237:                                     ; preds = %cond.false.230, %cond.true.208
  %cond238 = phi i32 [ %sub229, %cond.true.208 ], [ %add236, %cond.false.230 ]
  %div239 = sdiv i32 %cond238, 8
  %74 = load i64, i64* %numargs, align 8
  %shr240 = ashr i64 %74, 2
  %conv241 = trunc i64 %shr240 to i8
  %conv242 = sext i8 %conv241 to i32
  %cmp243 = icmp slt i32 %div239, %conv242
  br i1 %cmp243, label %cond.true.357, label %lor.lhs.false.334

cond.false.245:                                   ; preds = %lor.lhs.false.156
  br i1 false, label %cond.true.246, label %cond.false.247

cond.true.246:                                    ; preds = %cond.false.245
  br i1 false, label %cond.true.357, label %lor.lhs.false.334

cond.false.247:                                   ; preds = %cond.false.245
  %75 = load i64, i64* %numargs, align 8
  %shr248 = ashr i64 %75, 2
  %conv249 = trunc i64 %shr248 to i8
  %conv250 = sext i8 %conv249 to i32
  %cmp251 = icmp slt i32 %conv250, 0
  br i1 %cmp251, label %cond.true.253, label %cond.false.299

cond.true.253:                                    ; preds = %cond.false.247
  %76 = load i64, i64* %numargs, align 8
  %shr254 = ashr i64 %76, 2
  %conv255 = trunc i64 %shr254 to i8
  %conv256 = sext i8 %conv255 to i32
  %77 = load i64, i64* %numargs, align 8
  %shr257 = ashr i64 %77, 2
  %conv258 = trunc i64 %shr257 to i8
  %conv259 = sext i8 %conv258 to i32
  %add260 = add nsw i32 0, %conv259
  %mul261 = mul nsw i32 0, %add260
  %sub262 = sub nsw i32 %mul261, 1
  %cmp263 = icmp slt i32 %sub262, 0
  br i1 %cmp263, label %cond.true.265, label %cond.false.287

cond.true.265:                                    ; preds = %cond.true.253
  %78 = load i64, i64* %numargs, align 8
  %shr266 = ashr i64 %78, 2
  %conv267 = trunc i64 %shr266 to i8
  %conv268 = sext i8 %conv267 to i32
  %add269 = add nsw i32 0, %conv268
  %mul270 = mul nsw i32 0, %add269
  %add271 = add nsw i32 %mul270, 0
  %neg272 = xor i32 %add271, -1
  %cmp273 = icmp eq i32 %neg272, -1
  %conv274 = zext i1 %cmp273 to i32
  %sub275 = sub nsw i32 0, %conv274
  %79 = load i64, i64* %numargs, align 8
  %shr276 = ashr i64 %79, 2
  %conv277 = trunc i64 %shr276 to i8
  %conv278 = sext i8 %conv277 to i32
  %add279 = add nsw i32 0, %conv278
  %mul280 = mul nsw i32 0, %add279
  %add281 = add nsw i32 %mul280, 1
  %shl282 = shl i32 %add281, 30
  %sub283 = sub nsw i32 %shl282, 1
  %mul284 = mul nsw i32 %sub283, 2
  %add285 = add nsw i32 %mul284, 1
  %sub286 = sub nsw i32 %sub275, %add285
  br label %cond.end.294

cond.false.287:                                   ; preds = %cond.true.253
  %80 = load i64, i64* %numargs, align 8
  %shr288 = ashr i64 %80, 2
  %conv289 = trunc i64 %shr288 to i8
  %conv290 = sext i8 %conv289 to i32
  %add291 = add nsw i32 0, %conv290
  %mul292 = mul nsw i32 0, %add291
  %add293 = add nsw i32 %mul292, 0
  br label %cond.end.294

cond.end.294:                                     ; preds = %cond.false.287, %cond.true.265
  %cond295 = phi i32 [ %sub286, %cond.true.265 ], [ %add293, %cond.false.287 ]
  %div296 = sdiv i32 %cond295, 8
  %cmp297 = icmp slt i32 %conv256, %div296
  br i1 %cmp297, label %cond.true.357, label %lor.lhs.false.334

cond.false.299:                                   ; preds = %cond.false.247
  %81 = load i64, i64* %numargs, align 8
  %shr300 = ashr i64 %81, 2
  %conv301 = trunc i64 %shr300 to i8
  %conv302 = sext i8 %conv301 to i32
  %add303 = add nsw i32 0, %conv302
  %mul304 = mul nsw i32 0, %add303
  %sub305 = sub nsw i32 %mul304, 1
  %cmp306 = icmp slt i32 %sub305, 0
  br i1 %cmp306, label %cond.true.308, label %cond.false.319

cond.true.308:                                    ; preds = %cond.false.299
  %82 = load i64, i64* %numargs, align 8
  %shr309 = ashr i64 %82, 2
  %conv310 = trunc i64 %shr309 to i8
  %conv311 = sext i8 %conv310 to i32
  %add312 = add nsw i32 0, %conv311
  %mul313 = mul nsw i32 0, %add312
  %add314 = add nsw i32 %mul313, 1
  %shl315 = shl i32 %add314, 30
  %sub316 = sub nsw i32 %shl315, 1
  %mul317 = mul nsw i32 %sub316, 2
  %add318 = add nsw i32 %mul317, 1
  br label %cond.end.326

cond.false.319:                                   ; preds = %cond.false.299
  %83 = load i64, i64* %numargs, align 8
  %shr320 = ashr i64 %83, 2
  %conv321 = trunc i64 %shr320 to i8
  %conv322 = sext i8 %conv321 to i32
  %add323 = add nsw i32 0, %conv322
  %mul324 = mul nsw i32 0, %add323
  %sub325 = sub nsw i32 %mul324, 1
  br label %cond.end.326

cond.end.326:                                     ; preds = %cond.false.319, %cond.true.308
  %cond327 = phi i32 [ %add318, %cond.true.308 ], [ %sub325, %cond.false.319 ]
  %div328 = sdiv i32 %cond327, 8
  %84 = load i64, i64* %numargs, align 8
  %shr329 = ashr i64 %84, 2
  %conv330 = trunc i64 %shr329 to i8
  %conv331 = sext i8 %conv330 to i32
  %cmp332 = icmp slt i32 %div328, %conv331
  br i1 %cmp332, label %cond.true.357, label %lor.lhs.false.334

lor.lhs.false.334:                                ; preds = %cond.end.326, %cond.end.294, %cond.true.246, %cond.end.237, %cond.true.198, %cond.end.193
  %85 = load i64, i64* %numargs, align 8
  %shr335 = ashr i64 %85, 2
  %conv336 = trunc i64 %shr335 to i8
  %conv337 = sext i8 %conv336 to i32
  %mul338 = mul nsw i32 %conv337, 8
  %mul339 = mul nsw i32 0, %mul338
  %sub340 = sub nsw i32 %mul339, 1
  %cmp341 = icmp slt i32 %sub340, 0
  br i1 %cmp341, label %land.lhs.true.343, label %lor.lhs.false.350

land.lhs.true.343:                                ; preds = %lor.lhs.false.334
  %86 = load i64, i64* %numargs, align 8
  %shr344 = ashr i64 %86, 2
  %conv345 = trunc i64 %shr344 to i8
  %conv346 = sext i8 %conv345 to i32
  %mul347 = mul nsw i32 %conv346, 8
  %cmp348 = icmp slt i32 %mul347, -128
  br i1 %cmp348, label %cond.true.357, label %lor.lhs.false.350

lor.lhs.false.350:                                ; preds = %land.lhs.true.343, %lor.lhs.false.334
  %87 = load i64, i64* %numargs, align 8
  %shr351 = ashr i64 %87, 2
  %conv352 = trunc i64 %shr351 to i8
  %conv353 = sext i8 %conv352 to i32
  %mul354 = mul nsw i32 %conv353, 8
  %cmp355 = icmp slt i32 127, %mul354
  br i1 %cmp355, label %cond.true.357, label %cond.false.383

cond.true.357:                                    ; preds = %lor.lhs.false.350, %land.lhs.true.343, %cond.end.326, %cond.end.294, %cond.true.246, %cond.end.237, %cond.true.198, %cond.end.193, %land.lhs.true.150
  %88 = load i64, i64* %numargs, align 8
  %shr358 = ashr i64 %88, 2
  %conv359 = trunc i64 %shr358 to i8
  %conv360 = zext i8 %conv359 to i32
  %mul361 = mul nsw i32 %conv360, 8
  %cmp362 = icmp sle i32 %mul361, 127
  br i1 %cmp362, label %cond.true.364, label %cond.false.371

cond.true.364:                                    ; preds = %cond.true.357
  %89 = load i64, i64* %numargs, align 8
  %shr365 = ashr i64 %89, 2
  %conv366 = trunc i64 %shr365 to i8
  %conv367 = zext i8 %conv366 to i32
  %mul368 = mul nsw i32 %conv367, 8
  %conv369 = trunc i32 %mul368 to i8
  %conv370 = sext i8 %conv369 to i32
  br label %cond.end.380

cond.false.371:                                   ; preds = %cond.true.357
  %90 = load i64, i64* %numargs, align 8
  %shr372 = ashr i64 %90, 2
  %conv373 = trunc i64 %shr372 to i8
  %conv374 = zext i8 %conv373 to i32
  %mul375 = mul nsw i32 %conv374, 8
  %sub376 = sub nsw i32 %mul375, -128
  %conv377 = trunc i32 %sub376 to i8
  %conv378 = sext i8 %conv377 to i32
  %add379 = add nsw i32 %conv378, -128
  br label %cond.end.380

cond.end.380:                                     ; preds = %cond.false.371, %cond.true.364
  %cond381 = phi i32 [ %conv370, %cond.true.364 ], [ %add379, %cond.false.371 ]
  %conv382 = sext i32 %cond381 to i64
  store i64 %conv382, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2622, label %lor.lhs.false.2619

cond.false.383:                                   ; preds = %lor.lhs.false.350
  %91 = load i64, i64* %numargs, align 8
  %shr384 = ashr i64 %91, 2
  %conv385 = trunc i64 %shr384 to i8
  %conv386 = zext i8 %conv385 to i32
  %mul387 = mul nsw i32 %conv386, 8
  %cmp388 = icmp sle i32 %mul387, 127
  br i1 %cmp388, label %cond.true.390, label %cond.false.397

cond.true.390:                                    ; preds = %cond.false.383
  %92 = load i64, i64* %numargs, align 8
  %shr391 = ashr i64 %92, 2
  %conv392 = trunc i64 %shr391 to i8
  %conv393 = zext i8 %conv392 to i32
  %mul394 = mul nsw i32 %conv393, 8
  %conv395 = trunc i32 %mul394 to i8
  %conv396 = sext i8 %conv395 to i32
  br label %cond.end.406

cond.false.397:                                   ; preds = %cond.false.383
  %93 = load i64, i64* %numargs, align 8
  %shr398 = ashr i64 %93, 2
  %conv399 = trunc i64 %shr398 to i8
  %conv400 = zext i8 %conv399 to i32
  %mul401 = mul nsw i32 %conv400, 8
  %sub402 = sub nsw i32 %mul401, -128
  %conv403 = trunc i32 %sub402 to i8
  %conv404 = sext i8 %conv403 to i32
  %add405 = add nsw i32 %conv404, -128
  br label %cond.end.406

cond.end.406:                                     ; preds = %cond.false.397, %cond.true.390
  %cond407 = phi i32 [ %conv396, %cond.true.390 ], [ %add405, %cond.false.397 ]
  %conv408 = sext i32 %cond407 to i64
  store i64 %conv408, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2622, label %lor.lhs.false.2619

cond.false.409:                                   ; preds = %cond.true.111
  %94 = load i64, i64* %numargs, align 8
  %shr410 = ashr i64 %94, 2
  %add411 = add nsw i64 0, %shr410
  %mul412 = mul nsw i64 0, %add411
  %sub413 = sub nsw i64 %mul412, 1
  %cmp414 = icmp slt i64 %sub413, 0
  br i1 %cmp414, label %cond.true.416, label %cond.false.435

cond.true.416:                                    ; preds = %cond.false.409
  %95 = load i64, i64* %numargs, align 8
  %shr417 = ashr i64 %95, 2
  %add418 = add nsw i64 0, %shr417
  %mul419 = mul nsw i64 0, %add418
  %add420 = add nsw i64 %mul419, 0
  %neg421 = xor i64 %add420, -1
  %cmp422 = icmp eq i64 %neg421, -1
  %conv423 = zext i1 %cmp422 to i32
  %sub424 = sub nsw i32 0, %conv423
  %conv425 = sext i32 %sub424 to i64
  %96 = load i64, i64* %numargs, align 8
  %shr426 = ashr i64 %96, 2
  %add427 = add nsw i64 0, %shr426
  %mul428 = mul nsw i64 0, %add427
  %add429 = add nsw i64 %mul428, 1
  %shl430 = shl i64 %add429, 62
  %sub431 = sub nsw i64 %shl430, 1
  %mul432 = mul nsw i64 %sub431, 2
  %add433 = add nsw i64 %mul432, 1
  %sub434 = sub nsw i64 %conv425, %add433
  br label %cond.end.440

cond.false.435:                                   ; preds = %cond.false.409
  %97 = load i64, i64* %numargs, align 8
  %shr436 = ashr i64 %97, 2
  %add437 = add nsw i64 0, %shr436
  %mul438 = mul nsw i64 0, %add437
  %add439 = add nsw i64 %mul438, 0
  br label %cond.end.440

cond.end.440:                                     ; preds = %cond.false.435, %cond.true.416
  %cond441 = phi i64 [ %sub434, %cond.true.416 ], [ %add439, %cond.false.435 ]
  %cmp442 = icmp eq i64 %cond441, 0
  br i1 %cmp442, label %land.lhs.true.444, label %lor.lhs.false.448

land.lhs.true.444:                                ; preds = %cond.end.440
  %98 = load i64, i64* %numargs, align 8
  %shr445 = ashr i64 %98, 2
  %cmp446 = icmp slt i64 %shr445, 0
  br i1 %cmp446, label %cond.true.606, label %lor.lhs.false.448

lor.lhs.false.448:                                ; preds = %land.lhs.true.444, %cond.end.440
  br i1 false, label %cond.true.449, label %cond.false.519

cond.true.449:                                    ; preds = %lor.lhs.false.448
  %99 = load i64, i64* %numargs, align 8
  %shr450 = ashr i64 %99, 2
  %cmp451 = icmp slt i64 %shr450, 0
  br i1 %cmp451, label %cond.true.453, label %cond.false.480

cond.true.453:                                    ; preds = %cond.true.449
  %100 = load i64, i64* %numargs, align 8
  %shr454 = ashr i64 %100, 2
  %101 = load i64, i64* %numargs, align 8
  %shr455 = ashr i64 %101, 2
  %add456 = add nsw i64 0, %shr455
  %mul457 = mul nsw i64 0, %add456
  %sub458 = sub nsw i64 %mul457, 1
  %cmp459 = icmp slt i64 %sub458, 0
  br i1 %cmp459, label %cond.true.461, label %cond.false.470

cond.true.461:                                    ; preds = %cond.true.453
  %102 = load i64, i64* %numargs, align 8
  %shr462 = ashr i64 %102, 2
  %add463 = add nsw i64 0, %shr462
  %mul464 = mul nsw i64 0, %add463
  %add465 = add nsw i64 %mul464, 1
  %shl466 = shl i64 %add465, 62
  %sub467 = sub nsw i64 %shl466, 1
  %mul468 = mul nsw i64 %sub467, 2
  %add469 = add nsw i64 %mul468, 1
  br label %cond.end.475

cond.false.470:                                   ; preds = %cond.true.453
  %103 = load i64, i64* %numargs, align 8
  %shr471 = ashr i64 %103, 2
  %add472 = add nsw i64 0, %shr471
  %mul473 = mul nsw i64 0, %add472
  %sub474 = sub nsw i64 %mul473, 1
  br label %cond.end.475

cond.end.475:                                     ; preds = %cond.false.470, %cond.true.461
  %cond476 = phi i64 [ %add469, %cond.true.461 ], [ %sub474, %cond.false.470 ]
  %div477 = sdiv i64 %cond476, 8
  %cmp478 = icmp slt i64 %shr454, %div477
  br i1 %cmp478, label %cond.true.606, label %lor.lhs.false.589

cond.false.480:                                   ; preds = %cond.true.449
  br i1 false, label %cond.true.481, label %cond.false.482

cond.true.481:                                    ; preds = %cond.false.480
  br i1 false, label %cond.true.606, label %lor.lhs.false.589

cond.false.482:                                   ; preds = %cond.false.480
  %104 = load i64, i64* %numargs, align 8
  %shr483 = ashr i64 %104, 2
  %add484 = add nsw i64 0, %shr483
  %mul485 = mul nsw i64 0, %add484
  %sub486 = sub nsw i64 %mul485, 1
  %cmp487 = icmp slt i64 %sub486, 0
  br i1 %cmp487, label %cond.true.489, label %cond.false.508

cond.true.489:                                    ; preds = %cond.false.482
  %105 = load i64, i64* %numargs, align 8
  %shr490 = ashr i64 %105, 2
  %add491 = add nsw i64 0, %shr490
  %mul492 = mul nsw i64 0, %add491
  %add493 = add nsw i64 %mul492, 0
  %neg494 = xor i64 %add493, -1
  %cmp495 = icmp eq i64 %neg494, -1
  %conv496 = zext i1 %cmp495 to i32
  %sub497 = sub nsw i32 0, %conv496
  %conv498 = sext i32 %sub497 to i64
  %106 = load i64, i64* %numargs, align 8
  %shr499 = ashr i64 %106, 2
  %add500 = add nsw i64 0, %shr499
  %mul501 = mul nsw i64 0, %add500
  %add502 = add nsw i64 %mul501, 1
  %shl503 = shl i64 %add502, 62
  %sub504 = sub nsw i64 %shl503, 1
  %mul505 = mul nsw i64 %sub504, 2
  %add506 = add nsw i64 %mul505, 1
  %sub507 = sub nsw i64 %conv498, %add506
  br label %cond.end.513

cond.false.508:                                   ; preds = %cond.false.482
  %107 = load i64, i64* %numargs, align 8
  %shr509 = ashr i64 %107, 2
  %add510 = add nsw i64 0, %shr509
  %mul511 = mul nsw i64 0, %add510
  %add512 = add nsw i64 %mul511, 0
  br label %cond.end.513

cond.end.513:                                     ; preds = %cond.false.508, %cond.true.489
  %cond514 = phi i64 [ %sub507, %cond.true.489 ], [ %add512, %cond.false.508 ]
  %div515 = sdiv i64 %cond514, 8
  %108 = load i64, i64* %numargs, align 8
  %shr516 = ashr i64 %108, 2
  %cmp517 = icmp slt i64 %div515, %shr516
  br i1 %cmp517, label %cond.true.606, label %lor.lhs.false.589

cond.false.519:                                   ; preds = %lor.lhs.false.448
  br i1 false, label %cond.true.520, label %cond.false.521

cond.true.520:                                    ; preds = %cond.false.519
  br i1 false, label %cond.true.606, label %lor.lhs.false.589

cond.false.521:                                   ; preds = %cond.false.519
  %109 = load i64, i64* %numargs, align 8
  %shr522 = ashr i64 %109, 2
  %cmp523 = icmp slt i64 %shr522, 0
  br i1 %cmp523, label %cond.true.525, label %cond.false.562

cond.true.525:                                    ; preds = %cond.false.521
  %110 = load i64, i64* %numargs, align 8
  %shr526 = ashr i64 %110, 2
  %111 = load i64, i64* %numargs, align 8
  %shr527 = ashr i64 %111, 2
  %add528 = add nsw i64 0, %shr527
  %mul529 = mul nsw i64 0, %add528
  %sub530 = sub nsw i64 %mul529, 1
  %cmp531 = icmp slt i64 %sub530, 0
  br i1 %cmp531, label %cond.true.533, label %cond.false.552

cond.true.533:                                    ; preds = %cond.true.525
  %112 = load i64, i64* %numargs, align 8
  %shr534 = ashr i64 %112, 2
  %add535 = add nsw i64 0, %shr534
  %mul536 = mul nsw i64 0, %add535
  %add537 = add nsw i64 %mul536, 0
  %neg538 = xor i64 %add537, -1
  %cmp539 = icmp eq i64 %neg538, -1
  %conv540 = zext i1 %cmp539 to i32
  %sub541 = sub nsw i32 0, %conv540
  %conv542 = sext i32 %sub541 to i64
  %113 = load i64, i64* %numargs, align 8
  %shr543 = ashr i64 %113, 2
  %add544 = add nsw i64 0, %shr543
  %mul545 = mul nsw i64 0, %add544
  %add546 = add nsw i64 %mul545, 1
  %shl547 = shl i64 %add546, 62
  %sub548 = sub nsw i64 %shl547, 1
  %mul549 = mul nsw i64 %sub548, 2
  %add550 = add nsw i64 %mul549, 1
  %sub551 = sub nsw i64 %conv542, %add550
  br label %cond.end.557

cond.false.552:                                   ; preds = %cond.true.525
  %114 = load i64, i64* %numargs, align 8
  %shr553 = ashr i64 %114, 2
  %add554 = add nsw i64 0, %shr553
  %mul555 = mul nsw i64 0, %add554
  %add556 = add nsw i64 %mul555, 0
  br label %cond.end.557

cond.end.557:                                     ; preds = %cond.false.552, %cond.true.533
  %cond558 = phi i64 [ %sub551, %cond.true.533 ], [ %add556, %cond.false.552 ]
  %div559 = sdiv i64 %cond558, 8
  %cmp560 = icmp slt i64 %shr526, %div559
  br i1 %cmp560, label %cond.true.606, label %lor.lhs.false.589

cond.false.562:                                   ; preds = %cond.false.521
  %115 = load i64, i64* %numargs, align 8
  %shr563 = ashr i64 %115, 2
  %add564 = add nsw i64 0, %shr563
  %mul565 = mul nsw i64 0, %add564
  %sub566 = sub nsw i64 %mul565, 1
  %cmp567 = icmp slt i64 %sub566, 0
  br i1 %cmp567, label %cond.true.569, label %cond.false.578

cond.true.569:                                    ; preds = %cond.false.562
  %116 = load i64, i64* %numargs, align 8
  %shr570 = ashr i64 %116, 2
  %add571 = add nsw i64 0, %shr570
  %mul572 = mul nsw i64 0, %add571
  %add573 = add nsw i64 %mul572, 1
  %shl574 = shl i64 %add573, 62
  %sub575 = sub nsw i64 %shl574, 1
  %mul576 = mul nsw i64 %sub575, 2
  %add577 = add nsw i64 %mul576, 1
  br label %cond.end.583

cond.false.578:                                   ; preds = %cond.false.562
  %117 = load i64, i64* %numargs, align 8
  %shr579 = ashr i64 %117, 2
  %add580 = add nsw i64 0, %shr579
  %mul581 = mul nsw i64 0, %add580
  %sub582 = sub nsw i64 %mul581, 1
  br label %cond.end.583

cond.end.583:                                     ; preds = %cond.false.578, %cond.true.569
  %cond584 = phi i64 [ %add577, %cond.true.569 ], [ %sub582, %cond.false.578 ]
  %div585 = sdiv i64 %cond584, 8
  %118 = load i64, i64* %numargs, align 8
  %shr586 = ashr i64 %118, 2
  %cmp587 = icmp slt i64 %div585, %shr586
  br i1 %cmp587, label %cond.true.606, label %lor.lhs.false.589

lor.lhs.false.589:                                ; preds = %cond.end.583, %cond.end.557, %cond.true.520, %cond.end.513, %cond.true.481, %cond.end.475
  %119 = load i64, i64* %numargs, align 8
  %shr590 = ashr i64 %119, 2
  %mul591 = mul nsw i64 %shr590, 8
  %mul592 = mul nsw i64 0, %mul591
  %sub593 = sub nsw i64 %mul592, 1
  %cmp594 = icmp slt i64 %sub593, 0
  br i1 %cmp594, label %land.lhs.true.596, label %lor.lhs.false.601

land.lhs.true.596:                                ; preds = %lor.lhs.false.589
  %120 = load i64, i64* %numargs, align 8
  %shr597 = ashr i64 %120, 2
  %mul598 = mul nsw i64 %shr597, 8
  %cmp599 = icmp slt i64 %mul598, -128
  br i1 %cmp599, label %cond.true.606, label %lor.lhs.false.601

lor.lhs.false.601:                                ; preds = %land.lhs.true.596, %lor.lhs.false.589
  %121 = load i64, i64* %numargs, align 8
  %shr602 = ashr i64 %121, 2
  %mul603 = mul nsw i64 %shr602, 8
  %cmp604 = icmp slt i64 127, %mul603
  br i1 %cmp604, label %cond.true.606, label %cond.false.632

cond.true.606:                                    ; preds = %lor.lhs.false.601, %land.lhs.true.596, %cond.end.583, %cond.end.557, %cond.true.520, %cond.end.513, %cond.true.481, %cond.end.475, %land.lhs.true.444
  %122 = load i64, i64* %numargs, align 8
  %shr607 = ashr i64 %122, 2
  %conv608 = trunc i64 %shr607 to i8
  %conv609 = zext i8 %conv608 to i32
  %mul610 = mul nsw i32 %conv609, 8
  %cmp611 = icmp sle i32 %mul610, 127
  br i1 %cmp611, label %cond.true.613, label %cond.false.620

cond.true.613:                                    ; preds = %cond.true.606
  %123 = load i64, i64* %numargs, align 8
  %shr614 = ashr i64 %123, 2
  %conv615 = trunc i64 %shr614 to i8
  %conv616 = zext i8 %conv615 to i32
  %mul617 = mul nsw i32 %conv616, 8
  %conv618 = trunc i32 %mul617 to i8
  %conv619 = sext i8 %conv618 to i32
  br label %cond.end.629

cond.false.620:                                   ; preds = %cond.true.606
  %124 = load i64, i64* %numargs, align 8
  %shr621 = ashr i64 %124, 2
  %conv622 = trunc i64 %shr621 to i8
  %conv623 = zext i8 %conv622 to i32
  %mul624 = mul nsw i32 %conv623, 8
  %sub625 = sub nsw i32 %mul624, -128
  %conv626 = trunc i32 %sub625 to i8
  %conv627 = sext i8 %conv626 to i32
  %add628 = add nsw i32 %conv627, -128
  br label %cond.end.629

cond.end.629:                                     ; preds = %cond.false.620, %cond.true.613
  %cond630 = phi i32 [ %conv619, %cond.true.613 ], [ %add628, %cond.false.620 ]
  %conv631 = sext i32 %cond630 to i64
  store i64 %conv631, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2622, label %lor.lhs.false.2619

cond.false.632:                                   ; preds = %lor.lhs.false.601
  %125 = load i64, i64* %numargs, align 8
  %shr633 = ashr i64 %125, 2
  %conv634 = trunc i64 %shr633 to i8
  %conv635 = zext i8 %conv634 to i32
  %mul636 = mul nsw i32 %conv635, 8
  %cmp637 = icmp sle i32 %mul636, 127
  br i1 %cmp637, label %cond.true.639, label %cond.false.646

cond.true.639:                                    ; preds = %cond.false.632
  %126 = load i64, i64* %numargs, align 8
  %shr640 = ashr i64 %126, 2
  %conv641 = trunc i64 %shr640 to i8
  %conv642 = zext i8 %conv641 to i32
  %mul643 = mul nsw i32 %conv642, 8
  %conv644 = trunc i32 %mul643 to i8
  %conv645 = sext i8 %conv644 to i32
  br label %cond.end.655

cond.false.646:                                   ; preds = %cond.false.632
  %127 = load i64, i64* %numargs, align 8
  %shr647 = ashr i64 %127, 2
  %conv648 = trunc i64 %shr647 to i8
  %conv649 = zext i8 %conv648 to i32
  %mul650 = mul nsw i32 %conv649, 8
  %sub651 = sub nsw i32 %mul650, -128
  %conv652 = trunc i32 %sub651 to i8
  %conv653 = sext i8 %conv652 to i32
  %add654 = add nsw i32 %conv653, -128
  br label %cond.end.655

cond.end.655:                                     ; preds = %cond.false.646, %cond.true.639
  %cond656 = phi i32 [ %conv645, %cond.true.639 ], [ %add654, %cond.false.646 ]
  %conv657 = sext i32 %cond656 to i64
  store i64 %conv657, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2622, label %lor.lhs.false.2619

cond.false.658:                                   ; preds = %do.body.110
  br i1 false, label %cond.true.659, label %cond.false.1211

cond.true.659:                                    ; preds = %cond.false.658
  br i1 false, label %cond.true.660, label %cond.false.962

cond.true.660:                                    ; preds = %cond.true.659
  %128 = load i64, i64* %numargs, align 8
  %shr661 = ashr i64 %128, 2
  %conv662 = trunc i64 %shr661 to i16
  %conv663 = sext i16 %conv662 to i32
  %add664 = add nsw i32 0, %conv663
  %mul665 = mul nsw i32 0, %add664
  %sub666 = sub nsw i32 %mul665, 1
  %cmp667 = icmp slt i32 %sub666, 0
  br i1 %cmp667, label %cond.true.669, label %cond.false.691

cond.true.669:                                    ; preds = %cond.true.660
  %129 = load i64, i64* %numargs, align 8
  %shr670 = ashr i64 %129, 2
  %conv671 = trunc i64 %shr670 to i16
  %conv672 = sext i16 %conv671 to i32
  %add673 = add nsw i32 0, %conv672
  %mul674 = mul nsw i32 0, %add673
  %add675 = add nsw i32 %mul674, 0
  %neg676 = xor i32 %add675, -1
  %cmp677 = icmp eq i32 %neg676, -1
  %conv678 = zext i1 %cmp677 to i32
  %sub679 = sub nsw i32 0, %conv678
  %130 = load i64, i64* %numargs, align 8
  %shr680 = ashr i64 %130, 2
  %conv681 = trunc i64 %shr680 to i16
  %conv682 = sext i16 %conv681 to i32
  %add683 = add nsw i32 0, %conv682
  %mul684 = mul nsw i32 0, %add683
  %add685 = add nsw i32 %mul684, 1
  %shl686 = shl i32 %add685, 30
  %sub687 = sub nsw i32 %shl686, 1
  %mul688 = mul nsw i32 %sub687, 2
  %add689 = add nsw i32 %mul688, 1
  %sub690 = sub nsw i32 %sub679, %add689
  br label %cond.end.698

cond.false.691:                                   ; preds = %cond.true.660
  %131 = load i64, i64* %numargs, align 8
  %shr692 = ashr i64 %131, 2
  %conv693 = trunc i64 %shr692 to i16
  %conv694 = sext i16 %conv693 to i32
  %add695 = add nsw i32 0, %conv694
  %mul696 = mul nsw i32 0, %add695
  %add697 = add nsw i32 %mul696, 0
  br label %cond.end.698

cond.end.698:                                     ; preds = %cond.false.691, %cond.true.669
  %cond699 = phi i32 [ %sub690, %cond.true.669 ], [ %add697, %cond.false.691 ]
  %cmp700 = icmp eq i32 %cond699, 0
  br i1 %cmp700, label %land.lhs.true.702, label %lor.lhs.false.708

land.lhs.true.702:                                ; preds = %cond.end.698
  %132 = load i64, i64* %numargs, align 8
  %shr703 = ashr i64 %132, 2
  %conv704 = trunc i64 %shr703 to i16
  %conv705 = sext i16 %conv704 to i32
  %cmp706 = icmp slt i32 %conv705, 0
  br i1 %cmp706, label %cond.true.910, label %lor.lhs.false.708

lor.lhs.false.708:                                ; preds = %land.lhs.true.702, %cond.end.698
  br i1 false, label %cond.true.709, label %cond.false.798

cond.true.709:                                    ; preds = %lor.lhs.false.708
  %133 = load i64, i64* %numargs, align 8
  %shr710 = ashr i64 %133, 2
  %conv711 = trunc i64 %shr710 to i16
  %conv712 = sext i16 %conv711 to i32
  %cmp713 = icmp slt i32 %conv712, 0
  br i1 %cmp713, label %cond.true.715, label %cond.false.750

cond.true.715:                                    ; preds = %cond.true.709
  %134 = load i64, i64* %numargs, align 8
  %shr716 = ashr i64 %134, 2
  %conv717 = trunc i64 %shr716 to i16
  %conv718 = sext i16 %conv717 to i32
  %135 = load i64, i64* %numargs, align 8
  %shr719 = ashr i64 %135, 2
  %conv720 = trunc i64 %shr719 to i16
  %conv721 = sext i16 %conv720 to i32
  %add722 = add nsw i32 0, %conv721
  %mul723 = mul nsw i32 0, %add722
  %sub724 = sub nsw i32 %mul723, 1
  %cmp725 = icmp slt i32 %sub724, 0
  br i1 %cmp725, label %cond.true.727, label %cond.false.738

cond.true.727:                                    ; preds = %cond.true.715
  %136 = load i64, i64* %numargs, align 8
  %shr728 = ashr i64 %136, 2
  %conv729 = trunc i64 %shr728 to i16
  %conv730 = sext i16 %conv729 to i32
  %add731 = add nsw i32 0, %conv730
  %mul732 = mul nsw i32 0, %add731
  %add733 = add nsw i32 %mul732, 1
  %shl734 = shl i32 %add733, 30
  %sub735 = sub nsw i32 %shl734, 1
  %mul736 = mul nsw i32 %sub735, 2
  %add737 = add nsw i32 %mul736, 1
  br label %cond.end.745

cond.false.738:                                   ; preds = %cond.true.715
  %137 = load i64, i64* %numargs, align 8
  %shr739 = ashr i64 %137, 2
  %conv740 = trunc i64 %shr739 to i16
  %conv741 = sext i16 %conv740 to i32
  %add742 = add nsw i32 0, %conv741
  %mul743 = mul nsw i32 0, %add742
  %sub744 = sub nsw i32 %mul743, 1
  br label %cond.end.745

cond.end.745:                                     ; preds = %cond.false.738, %cond.true.727
  %cond746 = phi i32 [ %add737, %cond.true.727 ], [ %sub744, %cond.false.738 ]
  %div747 = sdiv i32 %cond746, 8
  %cmp748 = icmp slt i32 %conv718, %div747
  br i1 %cmp748, label %cond.true.910, label %lor.lhs.false.887

cond.false.750:                                   ; preds = %cond.true.709
  br i1 false, label %cond.true.751, label %cond.false.752

cond.true.751:                                    ; preds = %cond.false.750
  br i1 false, label %cond.true.910, label %lor.lhs.false.887

cond.false.752:                                   ; preds = %cond.false.750
  %138 = load i64, i64* %numargs, align 8
  %shr753 = ashr i64 %138, 2
  %conv754 = trunc i64 %shr753 to i16
  %conv755 = sext i16 %conv754 to i32
  %add756 = add nsw i32 0, %conv755
  %mul757 = mul nsw i32 0, %add756
  %sub758 = sub nsw i32 %mul757, 1
  %cmp759 = icmp slt i32 %sub758, 0
  br i1 %cmp759, label %cond.true.761, label %cond.false.783

cond.true.761:                                    ; preds = %cond.false.752
  %139 = load i64, i64* %numargs, align 8
  %shr762 = ashr i64 %139, 2
  %conv763 = trunc i64 %shr762 to i16
  %conv764 = sext i16 %conv763 to i32
  %add765 = add nsw i32 0, %conv764
  %mul766 = mul nsw i32 0, %add765
  %add767 = add nsw i32 %mul766, 0
  %neg768 = xor i32 %add767, -1
  %cmp769 = icmp eq i32 %neg768, -1
  %conv770 = zext i1 %cmp769 to i32
  %sub771 = sub nsw i32 0, %conv770
  %140 = load i64, i64* %numargs, align 8
  %shr772 = ashr i64 %140, 2
  %conv773 = trunc i64 %shr772 to i16
  %conv774 = sext i16 %conv773 to i32
  %add775 = add nsw i32 0, %conv774
  %mul776 = mul nsw i32 0, %add775
  %add777 = add nsw i32 %mul776, 1
  %shl778 = shl i32 %add777, 30
  %sub779 = sub nsw i32 %shl778, 1
  %mul780 = mul nsw i32 %sub779, 2
  %add781 = add nsw i32 %mul780, 1
  %sub782 = sub nsw i32 %sub771, %add781
  br label %cond.end.790

cond.false.783:                                   ; preds = %cond.false.752
  %141 = load i64, i64* %numargs, align 8
  %shr784 = ashr i64 %141, 2
  %conv785 = trunc i64 %shr784 to i16
  %conv786 = sext i16 %conv785 to i32
  %add787 = add nsw i32 0, %conv786
  %mul788 = mul nsw i32 0, %add787
  %add789 = add nsw i32 %mul788, 0
  br label %cond.end.790

cond.end.790:                                     ; preds = %cond.false.783, %cond.true.761
  %cond791 = phi i32 [ %sub782, %cond.true.761 ], [ %add789, %cond.false.783 ]
  %div792 = sdiv i32 %cond791, 8
  %142 = load i64, i64* %numargs, align 8
  %shr793 = ashr i64 %142, 2
  %conv794 = trunc i64 %shr793 to i16
  %conv795 = sext i16 %conv794 to i32
  %cmp796 = icmp slt i32 %div792, %conv795
  br i1 %cmp796, label %cond.true.910, label %lor.lhs.false.887

cond.false.798:                                   ; preds = %lor.lhs.false.708
  br i1 false, label %cond.true.799, label %cond.false.800

cond.true.799:                                    ; preds = %cond.false.798
  br i1 false, label %cond.true.910, label %lor.lhs.false.887

cond.false.800:                                   ; preds = %cond.false.798
  %143 = load i64, i64* %numargs, align 8
  %shr801 = ashr i64 %143, 2
  %conv802 = trunc i64 %shr801 to i16
  %conv803 = sext i16 %conv802 to i32
  %cmp804 = icmp slt i32 %conv803, 0
  br i1 %cmp804, label %cond.true.806, label %cond.false.852

cond.true.806:                                    ; preds = %cond.false.800
  %144 = load i64, i64* %numargs, align 8
  %shr807 = ashr i64 %144, 2
  %conv808 = trunc i64 %shr807 to i16
  %conv809 = sext i16 %conv808 to i32
  %145 = load i64, i64* %numargs, align 8
  %shr810 = ashr i64 %145, 2
  %conv811 = trunc i64 %shr810 to i16
  %conv812 = sext i16 %conv811 to i32
  %add813 = add nsw i32 0, %conv812
  %mul814 = mul nsw i32 0, %add813
  %sub815 = sub nsw i32 %mul814, 1
  %cmp816 = icmp slt i32 %sub815, 0
  br i1 %cmp816, label %cond.true.818, label %cond.false.840

cond.true.818:                                    ; preds = %cond.true.806
  %146 = load i64, i64* %numargs, align 8
  %shr819 = ashr i64 %146, 2
  %conv820 = trunc i64 %shr819 to i16
  %conv821 = sext i16 %conv820 to i32
  %add822 = add nsw i32 0, %conv821
  %mul823 = mul nsw i32 0, %add822
  %add824 = add nsw i32 %mul823, 0
  %neg825 = xor i32 %add824, -1
  %cmp826 = icmp eq i32 %neg825, -1
  %conv827 = zext i1 %cmp826 to i32
  %sub828 = sub nsw i32 0, %conv827
  %147 = load i64, i64* %numargs, align 8
  %shr829 = ashr i64 %147, 2
  %conv830 = trunc i64 %shr829 to i16
  %conv831 = sext i16 %conv830 to i32
  %add832 = add nsw i32 0, %conv831
  %mul833 = mul nsw i32 0, %add832
  %add834 = add nsw i32 %mul833, 1
  %shl835 = shl i32 %add834, 30
  %sub836 = sub nsw i32 %shl835, 1
  %mul837 = mul nsw i32 %sub836, 2
  %add838 = add nsw i32 %mul837, 1
  %sub839 = sub nsw i32 %sub828, %add838
  br label %cond.end.847

cond.false.840:                                   ; preds = %cond.true.806
  %148 = load i64, i64* %numargs, align 8
  %shr841 = ashr i64 %148, 2
  %conv842 = trunc i64 %shr841 to i16
  %conv843 = sext i16 %conv842 to i32
  %add844 = add nsw i32 0, %conv843
  %mul845 = mul nsw i32 0, %add844
  %add846 = add nsw i32 %mul845, 0
  br label %cond.end.847

cond.end.847:                                     ; preds = %cond.false.840, %cond.true.818
  %cond848 = phi i32 [ %sub839, %cond.true.818 ], [ %add846, %cond.false.840 ]
  %div849 = sdiv i32 %cond848, 8
  %cmp850 = icmp slt i32 %conv809, %div849
  br i1 %cmp850, label %cond.true.910, label %lor.lhs.false.887

cond.false.852:                                   ; preds = %cond.false.800
  %149 = load i64, i64* %numargs, align 8
  %shr853 = ashr i64 %149, 2
  %conv854 = trunc i64 %shr853 to i16
  %conv855 = sext i16 %conv854 to i32
  %add856 = add nsw i32 0, %conv855
  %mul857 = mul nsw i32 0, %add856
  %sub858 = sub nsw i32 %mul857, 1
  %cmp859 = icmp slt i32 %sub858, 0
  br i1 %cmp859, label %cond.true.861, label %cond.false.872

cond.true.861:                                    ; preds = %cond.false.852
  %150 = load i64, i64* %numargs, align 8
  %shr862 = ashr i64 %150, 2
  %conv863 = trunc i64 %shr862 to i16
  %conv864 = sext i16 %conv863 to i32
  %add865 = add nsw i32 0, %conv864
  %mul866 = mul nsw i32 0, %add865
  %add867 = add nsw i32 %mul866, 1
  %shl868 = shl i32 %add867, 30
  %sub869 = sub nsw i32 %shl868, 1
  %mul870 = mul nsw i32 %sub869, 2
  %add871 = add nsw i32 %mul870, 1
  br label %cond.end.879

cond.false.872:                                   ; preds = %cond.false.852
  %151 = load i64, i64* %numargs, align 8
  %shr873 = ashr i64 %151, 2
  %conv874 = trunc i64 %shr873 to i16
  %conv875 = sext i16 %conv874 to i32
  %add876 = add nsw i32 0, %conv875
  %mul877 = mul nsw i32 0, %add876
  %sub878 = sub nsw i32 %mul877, 1
  br label %cond.end.879

cond.end.879:                                     ; preds = %cond.false.872, %cond.true.861
  %cond880 = phi i32 [ %add871, %cond.true.861 ], [ %sub878, %cond.false.872 ]
  %div881 = sdiv i32 %cond880, 8
  %152 = load i64, i64* %numargs, align 8
  %shr882 = ashr i64 %152, 2
  %conv883 = trunc i64 %shr882 to i16
  %conv884 = sext i16 %conv883 to i32
  %cmp885 = icmp slt i32 %div881, %conv884
  br i1 %cmp885, label %cond.true.910, label %lor.lhs.false.887

lor.lhs.false.887:                                ; preds = %cond.end.879, %cond.end.847, %cond.true.799, %cond.end.790, %cond.true.751, %cond.end.745
  %153 = load i64, i64* %numargs, align 8
  %shr888 = ashr i64 %153, 2
  %conv889 = trunc i64 %shr888 to i16
  %conv890 = sext i16 %conv889 to i32
  %mul891 = mul nsw i32 %conv890, 8
  %mul892 = mul nsw i32 0, %mul891
  %sub893 = sub nsw i32 %mul892, 1
  %cmp894 = icmp slt i32 %sub893, 0
  br i1 %cmp894, label %land.lhs.true.896, label %lor.lhs.false.903

land.lhs.true.896:                                ; preds = %lor.lhs.false.887
  %154 = load i64, i64* %numargs, align 8
  %shr897 = ashr i64 %154, 2
  %conv898 = trunc i64 %shr897 to i16
  %conv899 = sext i16 %conv898 to i32
  %mul900 = mul nsw i32 %conv899, 8
  %cmp901 = icmp slt i32 %mul900, -32768
  br i1 %cmp901, label %cond.true.910, label %lor.lhs.false.903

lor.lhs.false.903:                                ; preds = %land.lhs.true.896, %lor.lhs.false.887
  %155 = load i64, i64* %numargs, align 8
  %shr904 = ashr i64 %155, 2
  %conv905 = trunc i64 %shr904 to i16
  %conv906 = sext i16 %conv905 to i32
  %mul907 = mul nsw i32 %conv906, 8
  %cmp908 = icmp slt i32 32767, %mul907
  br i1 %cmp908, label %cond.true.910, label %cond.false.936

cond.true.910:                                    ; preds = %lor.lhs.false.903, %land.lhs.true.896, %cond.end.879, %cond.end.847, %cond.true.799, %cond.end.790, %cond.true.751, %cond.end.745, %land.lhs.true.702
  %156 = load i64, i64* %numargs, align 8
  %shr911 = ashr i64 %156, 2
  %conv912 = trunc i64 %shr911 to i16
  %conv913 = zext i16 %conv912 to i32
  %mul914 = mul nsw i32 %conv913, 8
  %cmp915 = icmp sle i32 %mul914, 32767
  br i1 %cmp915, label %cond.true.917, label %cond.false.924

cond.true.917:                                    ; preds = %cond.true.910
  %157 = load i64, i64* %numargs, align 8
  %shr918 = ashr i64 %157, 2
  %conv919 = trunc i64 %shr918 to i16
  %conv920 = zext i16 %conv919 to i32
  %mul921 = mul nsw i32 %conv920, 8
  %conv922 = trunc i32 %mul921 to i16
  %conv923 = sext i16 %conv922 to i32
  br label %cond.end.933

cond.false.924:                                   ; preds = %cond.true.910
  %158 = load i64, i64* %numargs, align 8
  %shr925 = ashr i64 %158, 2
  %conv926 = trunc i64 %shr925 to i16
  %conv927 = zext i16 %conv926 to i32
  %mul928 = mul nsw i32 %conv927, 8
  %sub929 = sub nsw i32 %mul928, -32768
  %conv930 = trunc i32 %sub929 to i16
  %conv931 = sext i16 %conv930 to i32
  %add932 = add nsw i32 %conv931, -32768
  br label %cond.end.933

cond.end.933:                                     ; preds = %cond.false.924, %cond.true.917
  %cond934 = phi i32 [ %conv923, %cond.true.917 ], [ %add932, %cond.false.924 ]
  %conv935 = sext i32 %cond934 to i64
  store i64 %conv935, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2622, label %lor.lhs.false.2619

cond.false.936:                                   ; preds = %lor.lhs.false.903
  %159 = load i64, i64* %numargs, align 8
  %shr937 = ashr i64 %159, 2
  %conv938 = trunc i64 %shr937 to i16
  %conv939 = zext i16 %conv938 to i32
  %mul940 = mul nsw i32 %conv939, 8
  %cmp941 = icmp sle i32 %mul940, 32767
  br i1 %cmp941, label %cond.true.943, label %cond.false.950

cond.true.943:                                    ; preds = %cond.false.936
  %160 = load i64, i64* %numargs, align 8
  %shr944 = ashr i64 %160, 2
  %conv945 = trunc i64 %shr944 to i16
  %conv946 = zext i16 %conv945 to i32
  %mul947 = mul nsw i32 %conv946, 8
  %conv948 = trunc i32 %mul947 to i16
  %conv949 = sext i16 %conv948 to i32
  br label %cond.end.959

cond.false.950:                                   ; preds = %cond.false.936
  %161 = load i64, i64* %numargs, align 8
  %shr951 = ashr i64 %161, 2
  %conv952 = trunc i64 %shr951 to i16
  %conv953 = zext i16 %conv952 to i32
  %mul954 = mul nsw i32 %conv953, 8
  %sub955 = sub nsw i32 %mul954, -32768
  %conv956 = trunc i32 %sub955 to i16
  %conv957 = sext i16 %conv956 to i32
  %add958 = add nsw i32 %conv957, -32768
  br label %cond.end.959

cond.end.959:                                     ; preds = %cond.false.950, %cond.true.943
  %cond960 = phi i32 [ %conv949, %cond.true.943 ], [ %add958, %cond.false.950 ]
  %conv961 = sext i32 %cond960 to i64
  store i64 %conv961, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2622, label %lor.lhs.false.2619

cond.false.962:                                   ; preds = %cond.true.659
  %162 = load i64, i64* %numargs, align 8
  %shr963 = ashr i64 %162, 2
  %add964 = add nsw i64 0, %shr963
  %mul965 = mul nsw i64 0, %add964
  %sub966 = sub nsw i64 %mul965, 1
  %cmp967 = icmp slt i64 %sub966, 0
  br i1 %cmp967, label %cond.true.969, label %cond.false.988

cond.true.969:                                    ; preds = %cond.false.962
  %163 = load i64, i64* %numargs, align 8
  %shr970 = ashr i64 %163, 2
  %add971 = add nsw i64 0, %shr970
  %mul972 = mul nsw i64 0, %add971
  %add973 = add nsw i64 %mul972, 0
  %neg974 = xor i64 %add973, -1
  %cmp975 = icmp eq i64 %neg974, -1
  %conv976 = zext i1 %cmp975 to i32
  %sub977 = sub nsw i32 0, %conv976
  %conv978 = sext i32 %sub977 to i64
  %164 = load i64, i64* %numargs, align 8
  %shr979 = ashr i64 %164, 2
  %add980 = add nsw i64 0, %shr979
  %mul981 = mul nsw i64 0, %add980
  %add982 = add nsw i64 %mul981, 1
  %shl983 = shl i64 %add982, 62
  %sub984 = sub nsw i64 %shl983, 1
  %mul985 = mul nsw i64 %sub984, 2
  %add986 = add nsw i64 %mul985, 1
  %sub987 = sub nsw i64 %conv978, %add986
  br label %cond.end.993

cond.false.988:                                   ; preds = %cond.false.962
  %165 = load i64, i64* %numargs, align 8
  %shr989 = ashr i64 %165, 2
  %add990 = add nsw i64 0, %shr989
  %mul991 = mul nsw i64 0, %add990
  %add992 = add nsw i64 %mul991, 0
  br label %cond.end.993

cond.end.993:                                     ; preds = %cond.false.988, %cond.true.969
  %cond994 = phi i64 [ %sub987, %cond.true.969 ], [ %add992, %cond.false.988 ]
  %cmp995 = icmp eq i64 %cond994, 0
  br i1 %cmp995, label %land.lhs.true.997, label %lor.lhs.false.1001

land.lhs.true.997:                                ; preds = %cond.end.993
  %166 = load i64, i64* %numargs, align 8
  %shr998 = ashr i64 %166, 2
  %cmp999 = icmp slt i64 %shr998, 0
  br i1 %cmp999, label %cond.true.1159, label %lor.lhs.false.1001

lor.lhs.false.1001:                               ; preds = %land.lhs.true.997, %cond.end.993
  br i1 false, label %cond.true.1002, label %cond.false.1072

cond.true.1002:                                   ; preds = %lor.lhs.false.1001
  %167 = load i64, i64* %numargs, align 8
  %shr1003 = ashr i64 %167, 2
  %cmp1004 = icmp slt i64 %shr1003, 0
  br i1 %cmp1004, label %cond.true.1006, label %cond.false.1033

cond.true.1006:                                   ; preds = %cond.true.1002
  %168 = load i64, i64* %numargs, align 8
  %shr1007 = ashr i64 %168, 2
  %169 = load i64, i64* %numargs, align 8
  %shr1008 = ashr i64 %169, 2
  %add1009 = add nsw i64 0, %shr1008
  %mul1010 = mul nsw i64 0, %add1009
  %sub1011 = sub nsw i64 %mul1010, 1
  %cmp1012 = icmp slt i64 %sub1011, 0
  br i1 %cmp1012, label %cond.true.1014, label %cond.false.1023

cond.true.1014:                                   ; preds = %cond.true.1006
  %170 = load i64, i64* %numargs, align 8
  %shr1015 = ashr i64 %170, 2
  %add1016 = add nsw i64 0, %shr1015
  %mul1017 = mul nsw i64 0, %add1016
  %add1018 = add nsw i64 %mul1017, 1
  %shl1019 = shl i64 %add1018, 62
  %sub1020 = sub nsw i64 %shl1019, 1
  %mul1021 = mul nsw i64 %sub1020, 2
  %add1022 = add nsw i64 %mul1021, 1
  br label %cond.end.1028

cond.false.1023:                                  ; preds = %cond.true.1006
  %171 = load i64, i64* %numargs, align 8
  %shr1024 = ashr i64 %171, 2
  %add1025 = add nsw i64 0, %shr1024
  %mul1026 = mul nsw i64 0, %add1025
  %sub1027 = sub nsw i64 %mul1026, 1
  br label %cond.end.1028

cond.end.1028:                                    ; preds = %cond.false.1023, %cond.true.1014
  %cond1029 = phi i64 [ %add1022, %cond.true.1014 ], [ %sub1027, %cond.false.1023 ]
  %div1030 = sdiv i64 %cond1029, 8
  %cmp1031 = icmp slt i64 %shr1007, %div1030
  br i1 %cmp1031, label %cond.true.1159, label %lor.lhs.false.1142

cond.false.1033:                                  ; preds = %cond.true.1002
  br i1 false, label %cond.true.1034, label %cond.false.1035

cond.true.1034:                                   ; preds = %cond.false.1033
  br i1 false, label %cond.true.1159, label %lor.lhs.false.1142

cond.false.1035:                                  ; preds = %cond.false.1033
  %172 = load i64, i64* %numargs, align 8
  %shr1036 = ashr i64 %172, 2
  %add1037 = add nsw i64 0, %shr1036
  %mul1038 = mul nsw i64 0, %add1037
  %sub1039 = sub nsw i64 %mul1038, 1
  %cmp1040 = icmp slt i64 %sub1039, 0
  br i1 %cmp1040, label %cond.true.1042, label %cond.false.1061

cond.true.1042:                                   ; preds = %cond.false.1035
  %173 = load i64, i64* %numargs, align 8
  %shr1043 = ashr i64 %173, 2
  %add1044 = add nsw i64 0, %shr1043
  %mul1045 = mul nsw i64 0, %add1044
  %add1046 = add nsw i64 %mul1045, 0
  %neg1047 = xor i64 %add1046, -1
  %cmp1048 = icmp eq i64 %neg1047, -1
  %conv1049 = zext i1 %cmp1048 to i32
  %sub1050 = sub nsw i32 0, %conv1049
  %conv1051 = sext i32 %sub1050 to i64
  %174 = load i64, i64* %numargs, align 8
  %shr1052 = ashr i64 %174, 2
  %add1053 = add nsw i64 0, %shr1052
  %mul1054 = mul nsw i64 0, %add1053
  %add1055 = add nsw i64 %mul1054, 1
  %shl1056 = shl i64 %add1055, 62
  %sub1057 = sub nsw i64 %shl1056, 1
  %mul1058 = mul nsw i64 %sub1057, 2
  %add1059 = add nsw i64 %mul1058, 1
  %sub1060 = sub nsw i64 %conv1051, %add1059
  br label %cond.end.1066

cond.false.1061:                                  ; preds = %cond.false.1035
  %175 = load i64, i64* %numargs, align 8
  %shr1062 = ashr i64 %175, 2
  %add1063 = add nsw i64 0, %shr1062
  %mul1064 = mul nsw i64 0, %add1063
  %add1065 = add nsw i64 %mul1064, 0
  br label %cond.end.1066

cond.end.1066:                                    ; preds = %cond.false.1061, %cond.true.1042
  %cond1067 = phi i64 [ %sub1060, %cond.true.1042 ], [ %add1065, %cond.false.1061 ]
  %div1068 = sdiv i64 %cond1067, 8
  %176 = load i64, i64* %numargs, align 8
  %shr1069 = ashr i64 %176, 2
  %cmp1070 = icmp slt i64 %div1068, %shr1069
  br i1 %cmp1070, label %cond.true.1159, label %lor.lhs.false.1142

cond.false.1072:                                  ; preds = %lor.lhs.false.1001
  br i1 false, label %cond.true.1073, label %cond.false.1074

cond.true.1073:                                   ; preds = %cond.false.1072
  br i1 false, label %cond.true.1159, label %lor.lhs.false.1142

cond.false.1074:                                  ; preds = %cond.false.1072
  %177 = load i64, i64* %numargs, align 8
  %shr1075 = ashr i64 %177, 2
  %cmp1076 = icmp slt i64 %shr1075, 0
  br i1 %cmp1076, label %cond.true.1078, label %cond.false.1115

cond.true.1078:                                   ; preds = %cond.false.1074
  %178 = load i64, i64* %numargs, align 8
  %shr1079 = ashr i64 %178, 2
  %179 = load i64, i64* %numargs, align 8
  %shr1080 = ashr i64 %179, 2
  %add1081 = add nsw i64 0, %shr1080
  %mul1082 = mul nsw i64 0, %add1081
  %sub1083 = sub nsw i64 %mul1082, 1
  %cmp1084 = icmp slt i64 %sub1083, 0
  br i1 %cmp1084, label %cond.true.1086, label %cond.false.1105

cond.true.1086:                                   ; preds = %cond.true.1078
  %180 = load i64, i64* %numargs, align 8
  %shr1087 = ashr i64 %180, 2
  %add1088 = add nsw i64 0, %shr1087
  %mul1089 = mul nsw i64 0, %add1088
  %add1090 = add nsw i64 %mul1089, 0
  %neg1091 = xor i64 %add1090, -1
  %cmp1092 = icmp eq i64 %neg1091, -1
  %conv1093 = zext i1 %cmp1092 to i32
  %sub1094 = sub nsw i32 0, %conv1093
  %conv1095 = sext i32 %sub1094 to i64
  %181 = load i64, i64* %numargs, align 8
  %shr1096 = ashr i64 %181, 2
  %add1097 = add nsw i64 0, %shr1096
  %mul1098 = mul nsw i64 0, %add1097
  %add1099 = add nsw i64 %mul1098, 1
  %shl1100 = shl i64 %add1099, 62
  %sub1101 = sub nsw i64 %shl1100, 1
  %mul1102 = mul nsw i64 %sub1101, 2
  %add1103 = add nsw i64 %mul1102, 1
  %sub1104 = sub nsw i64 %conv1095, %add1103
  br label %cond.end.1110

cond.false.1105:                                  ; preds = %cond.true.1078
  %182 = load i64, i64* %numargs, align 8
  %shr1106 = ashr i64 %182, 2
  %add1107 = add nsw i64 0, %shr1106
  %mul1108 = mul nsw i64 0, %add1107
  %add1109 = add nsw i64 %mul1108, 0
  br label %cond.end.1110

cond.end.1110:                                    ; preds = %cond.false.1105, %cond.true.1086
  %cond1111 = phi i64 [ %sub1104, %cond.true.1086 ], [ %add1109, %cond.false.1105 ]
  %div1112 = sdiv i64 %cond1111, 8
  %cmp1113 = icmp slt i64 %shr1079, %div1112
  br i1 %cmp1113, label %cond.true.1159, label %lor.lhs.false.1142

cond.false.1115:                                  ; preds = %cond.false.1074
  %183 = load i64, i64* %numargs, align 8
  %shr1116 = ashr i64 %183, 2
  %add1117 = add nsw i64 0, %shr1116
  %mul1118 = mul nsw i64 0, %add1117
  %sub1119 = sub nsw i64 %mul1118, 1
  %cmp1120 = icmp slt i64 %sub1119, 0
  br i1 %cmp1120, label %cond.true.1122, label %cond.false.1131

cond.true.1122:                                   ; preds = %cond.false.1115
  %184 = load i64, i64* %numargs, align 8
  %shr1123 = ashr i64 %184, 2
  %add1124 = add nsw i64 0, %shr1123
  %mul1125 = mul nsw i64 0, %add1124
  %add1126 = add nsw i64 %mul1125, 1
  %shl1127 = shl i64 %add1126, 62
  %sub1128 = sub nsw i64 %shl1127, 1
  %mul1129 = mul nsw i64 %sub1128, 2
  %add1130 = add nsw i64 %mul1129, 1
  br label %cond.end.1136

cond.false.1131:                                  ; preds = %cond.false.1115
  %185 = load i64, i64* %numargs, align 8
  %shr1132 = ashr i64 %185, 2
  %add1133 = add nsw i64 0, %shr1132
  %mul1134 = mul nsw i64 0, %add1133
  %sub1135 = sub nsw i64 %mul1134, 1
  br label %cond.end.1136

cond.end.1136:                                    ; preds = %cond.false.1131, %cond.true.1122
  %cond1137 = phi i64 [ %add1130, %cond.true.1122 ], [ %sub1135, %cond.false.1131 ]
  %div1138 = sdiv i64 %cond1137, 8
  %186 = load i64, i64* %numargs, align 8
  %shr1139 = ashr i64 %186, 2
  %cmp1140 = icmp slt i64 %div1138, %shr1139
  br i1 %cmp1140, label %cond.true.1159, label %lor.lhs.false.1142

lor.lhs.false.1142:                               ; preds = %cond.end.1136, %cond.end.1110, %cond.true.1073, %cond.end.1066, %cond.true.1034, %cond.end.1028
  %187 = load i64, i64* %numargs, align 8
  %shr1143 = ashr i64 %187, 2
  %mul1144 = mul nsw i64 %shr1143, 8
  %mul1145 = mul nsw i64 0, %mul1144
  %sub1146 = sub nsw i64 %mul1145, 1
  %cmp1147 = icmp slt i64 %sub1146, 0
  br i1 %cmp1147, label %land.lhs.true.1149, label %lor.lhs.false.1154

land.lhs.true.1149:                               ; preds = %lor.lhs.false.1142
  %188 = load i64, i64* %numargs, align 8
  %shr1150 = ashr i64 %188, 2
  %mul1151 = mul nsw i64 %shr1150, 8
  %cmp1152 = icmp slt i64 %mul1151, -32768
  br i1 %cmp1152, label %cond.true.1159, label %lor.lhs.false.1154

lor.lhs.false.1154:                               ; preds = %land.lhs.true.1149, %lor.lhs.false.1142
  %189 = load i64, i64* %numargs, align 8
  %shr1155 = ashr i64 %189, 2
  %mul1156 = mul nsw i64 %shr1155, 8
  %cmp1157 = icmp slt i64 32767, %mul1156
  br i1 %cmp1157, label %cond.true.1159, label %cond.false.1185

cond.true.1159:                                   ; preds = %lor.lhs.false.1154, %land.lhs.true.1149, %cond.end.1136, %cond.end.1110, %cond.true.1073, %cond.end.1066, %cond.true.1034, %cond.end.1028, %land.lhs.true.997
  %190 = load i64, i64* %numargs, align 8
  %shr1160 = ashr i64 %190, 2
  %conv1161 = trunc i64 %shr1160 to i16
  %conv1162 = zext i16 %conv1161 to i32
  %mul1163 = mul nsw i32 %conv1162, 8
  %cmp1164 = icmp sle i32 %mul1163, 32767
  br i1 %cmp1164, label %cond.true.1166, label %cond.false.1173

cond.true.1166:                                   ; preds = %cond.true.1159
  %191 = load i64, i64* %numargs, align 8
  %shr1167 = ashr i64 %191, 2
  %conv1168 = trunc i64 %shr1167 to i16
  %conv1169 = zext i16 %conv1168 to i32
  %mul1170 = mul nsw i32 %conv1169, 8
  %conv1171 = trunc i32 %mul1170 to i16
  %conv1172 = sext i16 %conv1171 to i32
  br label %cond.end.1182

cond.false.1173:                                  ; preds = %cond.true.1159
  %192 = load i64, i64* %numargs, align 8
  %shr1174 = ashr i64 %192, 2
  %conv1175 = trunc i64 %shr1174 to i16
  %conv1176 = zext i16 %conv1175 to i32
  %mul1177 = mul nsw i32 %conv1176, 8
  %sub1178 = sub nsw i32 %mul1177, -32768
  %conv1179 = trunc i32 %sub1178 to i16
  %conv1180 = sext i16 %conv1179 to i32
  %add1181 = add nsw i32 %conv1180, -32768
  br label %cond.end.1182

cond.end.1182:                                    ; preds = %cond.false.1173, %cond.true.1166
  %cond1183 = phi i32 [ %conv1172, %cond.true.1166 ], [ %add1181, %cond.false.1173 ]
  %conv1184 = sext i32 %cond1183 to i64
  store i64 %conv1184, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2622, label %lor.lhs.false.2619

cond.false.1185:                                  ; preds = %lor.lhs.false.1154
  %193 = load i64, i64* %numargs, align 8
  %shr1186 = ashr i64 %193, 2
  %conv1187 = trunc i64 %shr1186 to i16
  %conv1188 = zext i16 %conv1187 to i32
  %mul1189 = mul nsw i32 %conv1188, 8
  %cmp1190 = icmp sle i32 %mul1189, 32767
  br i1 %cmp1190, label %cond.true.1192, label %cond.false.1199

cond.true.1192:                                   ; preds = %cond.false.1185
  %194 = load i64, i64* %numargs, align 8
  %shr1193 = ashr i64 %194, 2
  %conv1194 = trunc i64 %shr1193 to i16
  %conv1195 = zext i16 %conv1194 to i32
  %mul1196 = mul nsw i32 %conv1195, 8
  %conv1197 = trunc i32 %mul1196 to i16
  %conv1198 = sext i16 %conv1197 to i32
  br label %cond.end.1208

cond.false.1199:                                  ; preds = %cond.false.1185
  %195 = load i64, i64* %numargs, align 8
  %shr1200 = ashr i64 %195, 2
  %conv1201 = trunc i64 %shr1200 to i16
  %conv1202 = zext i16 %conv1201 to i32
  %mul1203 = mul nsw i32 %conv1202, 8
  %sub1204 = sub nsw i32 %mul1203, -32768
  %conv1205 = trunc i32 %sub1204 to i16
  %conv1206 = sext i16 %conv1205 to i32
  %add1207 = add nsw i32 %conv1206, -32768
  br label %cond.end.1208

cond.end.1208:                                    ; preds = %cond.false.1199, %cond.true.1192
  %cond1209 = phi i32 [ %conv1198, %cond.true.1192 ], [ %add1207, %cond.false.1199 ]
  %conv1210 = sext i32 %cond1209 to i64
  store i64 %conv1210, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2622, label %lor.lhs.false.2619

cond.false.1211:                                  ; preds = %cond.false.658
  br i1 false, label %cond.true.1212, label %cond.false.1708

cond.true.1212:                                   ; preds = %cond.false.1211
  br i1 false, label %cond.true.1213, label %cond.false.1473

cond.true.1213:                                   ; preds = %cond.true.1212
  %196 = load i64, i64* %numargs, align 8
  %shr1214 = ashr i64 %196, 2
  %conv1215 = trunc i64 %shr1214 to i32
  %add1216 = add nsw i32 0, %conv1215
  %mul1217 = mul nsw i32 0, %add1216
  %sub1218 = sub nsw i32 %mul1217, 1
  %cmp1219 = icmp slt i32 %sub1218, 0
  br i1 %cmp1219, label %cond.true.1221, label %cond.false.1241

cond.true.1221:                                   ; preds = %cond.true.1213
  %197 = load i64, i64* %numargs, align 8
  %shr1222 = ashr i64 %197, 2
  %conv1223 = trunc i64 %shr1222 to i32
  %add1224 = add nsw i32 0, %conv1223
  %mul1225 = mul nsw i32 0, %add1224
  %add1226 = add nsw i32 %mul1225, 0
  %neg1227 = xor i32 %add1226, -1
  %cmp1228 = icmp eq i32 %neg1227, -1
  %conv1229 = zext i1 %cmp1228 to i32
  %sub1230 = sub nsw i32 0, %conv1229
  %198 = load i64, i64* %numargs, align 8
  %shr1231 = ashr i64 %198, 2
  %conv1232 = trunc i64 %shr1231 to i32
  %add1233 = add nsw i32 0, %conv1232
  %mul1234 = mul nsw i32 0, %add1233
  %add1235 = add nsw i32 %mul1234, 1
  %shl1236 = shl i32 %add1235, 30
  %sub1237 = sub nsw i32 %shl1236, 1
  %mul1238 = mul nsw i32 %sub1237, 2
  %add1239 = add nsw i32 %mul1238, 1
  %sub1240 = sub nsw i32 %sub1230, %add1239
  br label %cond.end.1247

cond.false.1241:                                  ; preds = %cond.true.1213
  %199 = load i64, i64* %numargs, align 8
  %shr1242 = ashr i64 %199, 2
  %conv1243 = trunc i64 %shr1242 to i32
  %add1244 = add nsw i32 0, %conv1243
  %mul1245 = mul nsw i32 0, %add1244
  %add1246 = add nsw i32 %mul1245, 0
  br label %cond.end.1247

cond.end.1247:                                    ; preds = %cond.false.1241, %cond.true.1221
  %cond1248 = phi i32 [ %sub1240, %cond.true.1221 ], [ %add1246, %cond.false.1241 ]
  %cmp1249 = icmp eq i32 %cond1248, 0
  br i1 %cmp1249, label %land.lhs.true.1251, label %lor.lhs.false.1256

land.lhs.true.1251:                               ; preds = %cond.end.1247
  %200 = load i64, i64* %numargs, align 8
  %shr1252 = ashr i64 %200, 2
  %conv1253 = trunc i64 %shr1252 to i32
  %cmp1254 = icmp slt i32 %conv1253, 0
  br i1 %cmp1254, label %cond.true.1435, label %lor.lhs.false.1256

lor.lhs.false.1256:                               ; preds = %land.lhs.true.1251, %cond.end.1247
  br i1 false, label %cond.true.1257, label %cond.false.1336

cond.true.1257:                                   ; preds = %lor.lhs.false.1256
  %201 = load i64, i64* %numargs, align 8
  %shr1258 = ashr i64 %201, 2
  %conv1259 = trunc i64 %shr1258 to i32
  %cmp1260 = icmp slt i32 %conv1259, 0
  br i1 %cmp1260, label %cond.true.1262, label %cond.false.1293

cond.true.1262:                                   ; preds = %cond.true.1257
  %202 = load i64, i64* %numargs, align 8
  %shr1263 = ashr i64 %202, 2
  %conv1264 = trunc i64 %shr1263 to i32
  %203 = load i64, i64* %numargs, align 8
  %shr1265 = ashr i64 %203, 2
  %conv1266 = trunc i64 %shr1265 to i32
  %add1267 = add nsw i32 0, %conv1266
  %mul1268 = mul nsw i32 0, %add1267
  %sub1269 = sub nsw i32 %mul1268, 1
  %cmp1270 = icmp slt i32 %sub1269, 0
  br i1 %cmp1270, label %cond.true.1272, label %cond.false.1282

cond.true.1272:                                   ; preds = %cond.true.1262
  %204 = load i64, i64* %numargs, align 8
  %shr1273 = ashr i64 %204, 2
  %conv1274 = trunc i64 %shr1273 to i32
  %add1275 = add nsw i32 0, %conv1274
  %mul1276 = mul nsw i32 0, %add1275
  %add1277 = add nsw i32 %mul1276, 1
  %shl1278 = shl i32 %add1277, 30
  %sub1279 = sub nsw i32 %shl1278, 1
  %mul1280 = mul nsw i32 %sub1279, 2
  %add1281 = add nsw i32 %mul1280, 1
  br label %cond.end.1288

cond.false.1282:                                  ; preds = %cond.true.1262
  %205 = load i64, i64* %numargs, align 8
  %shr1283 = ashr i64 %205, 2
  %conv1284 = trunc i64 %shr1283 to i32
  %add1285 = add nsw i32 0, %conv1284
  %mul1286 = mul nsw i32 0, %add1285
  %sub1287 = sub nsw i32 %mul1286, 1
  br label %cond.end.1288

cond.end.1288:                                    ; preds = %cond.false.1282, %cond.true.1272
  %cond1289 = phi i32 [ %add1281, %cond.true.1272 ], [ %sub1287, %cond.false.1282 ]
  %div1290 = sdiv i32 %cond1289, 8
  %cmp1291 = icmp slt i32 %conv1264, %div1290
  br i1 %cmp1291, label %cond.true.1435, label %lor.lhs.false.1415

cond.false.1293:                                  ; preds = %cond.true.1257
  br i1 false, label %cond.true.1294, label %cond.false.1295

cond.true.1294:                                   ; preds = %cond.false.1293
  br i1 false, label %cond.true.1435, label %lor.lhs.false.1415

cond.false.1295:                                  ; preds = %cond.false.1293
  %206 = load i64, i64* %numargs, align 8
  %shr1296 = ashr i64 %206, 2
  %conv1297 = trunc i64 %shr1296 to i32
  %add1298 = add nsw i32 0, %conv1297
  %mul1299 = mul nsw i32 0, %add1298
  %sub1300 = sub nsw i32 %mul1299, 1
  %cmp1301 = icmp slt i32 %sub1300, 0
  br i1 %cmp1301, label %cond.true.1303, label %cond.false.1323

cond.true.1303:                                   ; preds = %cond.false.1295
  %207 = load i64, i64* %numargs, align 8
  %shr1304 = ashr i64 %207, 2
  %conv1305 = trunc i64 %shr1304 to i32
  %add1306 = add nsw i32 0, %conv1305
  %mul1307 = mul nsw i32 0, %add1306
  %add1308 = add nsw i32 %mul1307, 0
  %neg1309 = xor i32 %add1308, -1
  %cmp1310 = icmp eq i32 %neg1309, -1
  %conv1311 = zext i1 %cmp1310 to i32
  %sub1312 = sub nsw i32 0, %conv1311
  %208 = load i64, i64* %numargs, align 8
  %shr1313 = ashr i64 %208, 2
  %conv1314 = trunc i64 %shr1313 to i32
  %add1315 = add nsw i32 0, %conv1314
  %mul1316 = mul nsw i32 0, %add1315
  %add1317 = add nsw i32 %mul1316, 1
  %shl1318 = shl i32 %add1317, 30
  %sub1319 = sub nsw i32 %shl1318, 1
  %mul1320 = mul nsw i32 %sub1319, 2
  %add1321 = add nsw i32 %mul1320, 1
  %sub1322 = sub nsw i32 %sub1312, %add1321
  br label %cond.end.1329

cond.false.1323:                                  ; preds = %cond.false.1295
  %209 = load i64, i64* %numargs, align 8
  %shr1324 = ashr i64 %209, 2
  %conv1325 = trunc i64 %shr1324 to i32
  %add1326 = add nsw i32 0, %conv1325
  %mul1327 = mul nsw i32 0, %add1326
  %add1328 = add nsw i32 %mul1327, 0
  br label %cond.end.1329

cond.end.1329:                                    ; preds = %cond.false.1323, %cond.true.1303
  %cond1330 = phi i32 [ %sub1322, %cond.true.1303 ], [ %add1328, %cond.false.1323 ]
  %div1331 = sdiv i32 %cond1330, 8
  %210 = load i64, i64* %numargs, align 8
  %shr1332 = ashr i64 %210, 2
  %conv1333 = trunc i64 %shr1332 to i32
  %cmp1334 = icmp slt i32 %div1331, %conv1333
  br i1 %cmp1334, label %cond.true.1435, label %lor.lhs.false.1415

cond.false.1336:                                  ; preds = %lor.lhs.false.1256
  br i1 false, label %cond.true.1337, label %cond.false.1338

cond.true.1337:                                   ; preds = %cond.false.1336
  br i1 false, label %cond.true.1435, label %lor.lhs.false.1415

cond.false.1338:                                  ; preds = %cond.false.1336
  %211 = load i64, i64* %numargs, align 8
  %shr1339 = ashr i64 %211, 2
  %conv1340 = trunc i64 %shr1339 to i32
  %cmp1341 = icmp slt i32 %conv1340, 0
  br i1 %cmp1341, label %cond.true.1343, label %cond.false.1384

cond.true.1343:                                   ; preds = %cond.false.1338
  %212 = load i64, i64* %numargs, align 8
  %shr1344 = ashr i64 %212, 2
  %conv1345 = trunc i64 %shr1344 to i32
  %213 = load i64, i64* %numargs, align 8
  %shr1346 = ashr i64 %213, 2
  %conv1347 = trunc i64 %shr1346 to i32
  %add1348 = add nsw i32 0, %conv1347
  %mul1349 = mul nsw i32 0, %add1348
  %sub1350 = sub nsw i32 %mul1349, 1
  %cmp1351 = icmp slt i32 %sub1350, 0
  br i1 %cmp1351, label %cond.true.1353, label %cond.false.1373

cond.true.1353:                                   ; preds = %cond.true.1343
  %214 = load i64, i64* %numargs, align 8
  %shr1354 = ashr i64 %214, 2
  %conv1355 = trunc i64 %shr1354 to i32
  %add1356 = add nsw i32 0, %conv1355
  %mul1357 = mul nsw i32 0, %add1356
  %add1358 = add nsw i32 %mul1357, 0
  %neg1359 = xor i32 %add1358, -1
  %cmp1360 = icmp eq i32 %neg1359, -1
  %conv1361 = zext i1 %cmp1360 to i32
  %sub1362 = sub nsw i32 0, %conv1361
  %215 = load i64, i64* %numargs, align 8
  %shr1363 = ashr i64 %215, 2
  %conv1364 = trunc i64 %shr1363 to i32
  %add1365 = add nsw i32 0, %conv1364
  %mul1366 = mul nsw i32 0, %add1365
  %add1367 = add nsw i32 %mul1366, 1
  %shl1368 = shl i32 %add1367, 30
  %sub1369 = sub nsw i32 %shl1368, 1
  %mul1370 = mul nsw i32 %sub1369, 2
  %add1371 = add nsw i32 %mul1370, 1
  %sub1372 = sub nsw i32 %sub1362, %add1371
  br label %cond.end.1379

cond.false.1373:                                  ; preds = %cond.true.1343
  %216 = load i64, i64* %numargs, align 8
  %shr1374 = ashr i64 %216, 2
  %conv1375 = trunc i64 %shr1374 to i32
  %add1376 = add nsw i32 0, %conv1375
  %mul1377 = mul nsw i32 0, %add1376
  %add1378 = add nsw i32 %mul1377, 0
  br label %cond.end.1379

cond.end.1379:                                    ; preds = %cond.false.1373, %cond.true.1353
  %cond1380 = phi i32 [ %sub1372, %cond.true.1353 ], [ %add1378, %cond.false.1373 ]
  %div1381 = sdiv i32 %cond1380, 8
  %cmp1382 = icmp slt i32 %conv1345, %div1381
  br i1 %cmp1382, label %cond.true.1435, label %lor.lhs.false.1415

cond.false.1384:                                  ; preds = %cond.false.1338
  %217 = load i64, i64* %numargs, align 8
  %shr1385 = ashr i64 %217, 2
  %conv1386 = trunc i64 %shr1385 to i32
  %add1387 = add nsw i32 0, %conv1386
  %mul1388 = mul nsw i32 0, %add1387
  %sub1389 = sub nsw i32 %mul1388, 1
  %cmp1390 = icmp slt i32 %sub1389, 0
  br i1 %cmp1390, label %cond.true.1392, label %cond.false.1402

cond.true.1392:                                   ; preds = %cond.false.1384
  %218 = load i64, i64* %numargs, align 8
  %shr1393 = ashr i64 %218, 2
  %conv1394 = trunc i64 %shr1393 to i32
  %add1395 = add nsw i32 0, %conv1394
  %mul1396 = mul nsw i32 0, %add1395
  %add1397 = add nsw i32 %mul1396, 1
  %shl1398 = shl i32 %add1397, 30
  %sub1399 = sub nsw i32 %shl1398, 1
  %mul1400 = mul nsw i32 %sub1399, 2
  %add1401 = add nsw i32 %mul1400, 1
  br label %cond.end.1408

cond.false.1402:                                  ; preds = %cond.false.1384
  %219 = load i64, i64* %numargs, align 8
  %shr1403 = ashr i64 %219, 2
  %conv1404 = trunc i64 %shr1403 to i32
  %add1405 = add nsw i32 0, %conv1404
  %mul1406 = mul nsw i32 0, %add1405
  %sub1407 = sub nsw i32 %mul1406, 1
  br label %cond.end.1408

cond.end.1408:                                    ; preds = %cond.false.1402, %cond.true.1392
  %cond1409 = phi i32 [ %add1401, %cond.true.1392 ], [ %sub1407, %cond.false.1402 ]
  %div1410 = sdiv i32 %cond1409, 8
  %220 = load i64, i64* %numargs, align 8
  %shr1411 = ashr i64 %220, 2
  %conv1412 = trunc i64 %shr1411 to i32
  %cmp1413 = icmp slt i32 %div1410, %conv1412
  br i1 %cmp1413, label %cond.true.1435, label %lor.lhs.false.1415

lor.lhs.false.1415:                               ; preds = %cond.end.1408, %cond.end.1379, %cond.true.1337, %cond.end.1329, %cond.true.1294, %cond.end.1288
  %221 = load i64, i64* %numargs, align 8
  %shr1416 = ashr i64 %221, 2
  %conv1417 = trunc i64 %shr1416 to i32
  %mul1418 = mul nsw i32 %conv1417, 8
  %mul1419 = mul nsw i32 0, %mul1418
  %sub1420 = sub nsw i32 %mul1419, 1
  %cmp1421 = icmp slt i32 %sub1420, 0
  br i1 %cmp1421, label %land.lhs.true.1423, label %lor.lhs.false.1429

land.lhs.true.1423:                               ; preds = %lor.lhs.false.1415
  %222 = load i64, i64* %numargs, align 8
  %shr1424 = ashr i64 %222, 2
  %conv1425 = trunc i64 %shr1424 to i32
  %mul1426 = mul nsw i32 %conv1425, 8
  %cmp1427 = icmp slt i32 %mul1426, -2147483648
  br i1 %cmp1427, label %cond.true.1435, label %lor.lhs.false.1429

lor.lhs.false.1429:                               ; preds = %land.lhs.true.1423, %lor.lhs.false.1415
  %223 = load i64, i64* %numargs, align 8
  %shr1430 = ashr i64 %223, 2
  %conv1431 = trunc i64 %shr1430 to i32
  %mul1432 = mul nsw i32 %conv1431, 8
  %cmp1433 = icmp slt i32 2147483647, %mul1432
  br i1 %cmp1433, label %cond.true.1435, label %cond.false.1454

cond.true.1435:                                   ; preds = %lor.lhs.false.1429, %land.lhs.true.1423, %cond.end.1408, %cond.end.1379, %cond.true.1337, %cond.end.1329, %cond.true.1294, %cond.end.1288, %land.lhs.true.1251
  %224 = load i64, i64* %numargs, align 8
  %shr1436 = ashr i64 %224, 2
  %conv1437 = trunc i64 %shr1436 to i32
  %mul1438 = mul i32 %conv1437, 8
  %cmp1439 = icmp ule i32 %mul1438, 2147483647
  br i1 %cmp1439, label %cond.true.1441, label %cond.false.1445

cond.true.1441:                                   ; preds = %cond.true.1435
  %225 = load i64, i64* %numargs, align 8
  %shr1442 = ashr i64 %225, 2
  %conv1443 = trunc i64 %shr1442 to i32
  %mul1444 = mul i32 %conv1443, 8
  br label %cond.end.1451

cond.false.1445:                                  ; preds = %cond.true.1435
  %226 = load i64, i64* %numargs, align 8
  %shr1446 = ashr i64 %226, 2
  %conv1447 = trunc i64 %shr1446 to i32
  %mul1448 = mul i32 %conv1447, 8
  %sub1449 = sub i32 %mul1448, -2147483648
  %add1450 = add nsw i32 %sub1449, -2147483648
  br label %cond.end.1451

cond.end.1451:                                    ; preds = %cond.false.1445, %cond.true.1441
  %cond1452 = phi i32 [ %mul1444, %cond.true.1441 ], [ %add1450, %cond.false.1445 ]
  %conv1453 = sext i32 %cond1452 to i64
  store i64 %conv1453, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2622, label %lor.lhs.false.2619

cond.false.1454:                                  ; preds = %lor.lhs.false.1429
  %227 = load i64, i64* %numargs, align 8
  %shr1455 = ashr i64 %227, 2
  %conv1456 = trunc i64 %shr1455 to i32
  %mul1457 = mul i32 %conv1456, 8
  %cmp1458 = icmp ule i32 %mul1457, 2147483647
  br i1 %cmp1458, label %cond.true.1460, label %cond.false.1464

cond.true.1460:                                   ; preds = %cond.false.1454
  %228 = load i64, i64* %numargs, align 8
  %shr1461 = ashr i64 %228, 2
  %conv1462 = trunc i64 %shr1461 to i32
  %mul1463 = mul i32 %conv1462, 8
  br label %cond.end.1470

cond.false.1464:                                  ; preds = %cond.false.1454
  %229 = load i64, i64* %numargs, align 8
  %shr1465 = ashr i64 %229, 2
  %conv1466 = trunc i64 %shr1465 to i32
  %mul1467 = mul i32 %conv1466, 8
  %sub1468 = sub i32 %mul1467, -2147483648
  %add1469 = add nsw i32 %sub1468, -2147483648
  br label %cond.end.1470

cond.end.1470:                                    ; preds = %cond.false.1464, %cond.true.1460
  %cond1471 = phi i32 [ %mul1463, %cond.true.1460 ], [ %add1469, %cond.false.1464 ]
  %conv1472 = sext i32 %cond1471 to i64
  store i64 %conv1472, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2622, label %lor.lhs.false.2619

cond.false.1473:                                  ; preds = %cond.true.1212
  %230 = load i64, i64* %numargs, align 8
  %shr1474 = ashr i64 %230, 2
  %add1475 = add nsw i64 0, %shr1474
  %mul1476 = mul nsw i64 0, %add1475
  %sub1477 = sub nsw i64 %mul1476, 1
  %cmp1478 = icmp slt i64 %sub1477, 0
  br i1 %cmp1478, label %cond.true.1480, label %cond.false.1499

cond.true.1480:                                   ; preds = %cond.false.1473
  %231 = load i64, i64* %numargs, align 8
  %shr1481 = ashr i64 %231, 2
  %add1482 = add nsw i64 0, %shr1481
  %mul1483 = mul nsw i64 0, %add1482
  %add1484 = add nsw i64 %mul1483, 0
  %neg1485 = xor i64 %add1484, -1
  %cmp1486 = icmp eq i64 %neg1485, -1
  %conv1487 = zext i1 %cmp1486 to i32
  %sub1488 = sub nsw i32 0, %conv1487
  %conv1489 = sext i32 %sub1488 to i64
  %232 = load i64, i64* %numargs, align 8
  %shr1490 = ashr i64 %232, 2
  %add1491 = add nsw i64 0, %shr1490
  %mul1492 = mul nsw i64 0, %add1491
  %add1493 = add nsw i64 %mul1492, 1
  %shl1494 = shl i64 %add1493, 62
  %sub1495 = sub nsw i64 %shl1494, 1
  %mul1496 = mul nsw i64 %sub1495, 2
  %add1497 = add nsw i64 %mul1496, 1
  %sub1498 = sub nsw i64 %conv1489, %add1497
  br label %cond.end.1504

cond.false.1499:                                  ; preds = %cond.false.1473
  %233 = load i64, i64* %numargs, align 8
  %shr1500 = ashr i64 %233, 2
  %add1501 = add nsw i64 0, %shr1500
  %mul1502 = mul nsw i64 0, %add1501
  %add1503 = add nsw i64 %mul1502, 0
  br label %cond.end.1504

cond.end.1504:                                    ; preds = %cond.false.1499, %cond.true.1480
  %cond1505 = phi i64 [ %sub1498, %cond.true.1480 ], [ %add1503, %cond.false.1499 ]
  %cmp1506 = icmp eq i64 %cond1505, 0
  br i1 %cmp1506, label %land.lhs.true.1508, label %lor.lhs.false.1512

land.lhs.true.1508:                               ; preds = %cond.end.1504
  %234 = load i64, i64* %numargs, align 8
  %shr1509 = ashr i64 %234, 2
  %cmp1510 = icmp slt i64 %shr1509, 0
  br i1 %cmp1510, label %cond.true.1670, label %lor.lhs.false.1512

lor.lhs.false.1512:                               ; preds = %land.lhs.true.1508, %cond.end.1504
  br i1 false, label %cond.true.1513, label %cond.false.1583

cond.true.1513:                                   ; preds = %lor.lhs.false.1512
  %235 = load i64, i64* %numargs, align 8
  %shr1514 = ashr i64 %235, 2
  %cmp1515 = icmp slt i64 %shr1514, 0
  br i1 %cmp1515, label %cond.true.1517, label %cond.false.1544

cond.true.1517:                                   ; preds = %cond.true.1513
  %236 = load i64, i64* %numargs, align 8
  %shr1518 = ashr i64 %236, 2
  %237 = load i64, i64* %numargs, align 8
  %shr1519 = ashr i64 %237, 2
  %add1520 = add nsw i64 0, %shr1519
  %mul1521 = mul nsw i64 0, %add1520
  %sub1522 = sub nsw i64 %mul1521, 1
  %cmp1523 = icmp slt i64 %sub1522, 0
  br i1 %cmp1523, label %cond.true.1525, label %cond.false.1534

cond.true.1525:                                   ; preds = %cond.true.1517
  %238 = load i64, i64* %numargs, align 8
  %shr1526 = ashr i64 %238, 2
  %add1527 = add nsw i64 0, %shr1526
  %mul1528 = mul nsw i64 0, %add1527
  %add1529 = add nsw i64 %mul1528, 1
  %shl1530 = shl i64 %add1529, 62
  %sub1531 = sub nsw i64 %shl1530, 1
  %mul1532 = mul nsw i64 %sub1531, 2
  %add1533 = add nsw i64 %mul1532, 1
  br label %cond.end.1539

cond.false.1534:                                  ; preds = %cond.true.1517
  %239 = load i64, i64* %numargs, align 8
  %shr1535 = ashr i64 %239, 2
  %add1536 = add nsw i64 0, %shr1535
  %mul1537 = mul nsw i64 0, %add1536
  %sub1538 = sub nsw i64 %mul1537, 1
  br label %cond.end.1539

cond.end.1539:                                    ; preds = %cond.false.1534, %cond.true.1525
  %cond1540 = phi i64 [ %add1533, %cond.true.1525 ], [ %sub1538, %cond.false.1534 ]
  %div1541 = sdiv i64 %cond1540, 8
  %cmp1542 = icmp slt i64 %shr1518, %div1541
  br i1 %cmp1542, label %cond.true.1670, label %lor.lhs.false.1653

cond.false.1544:                                  ; preds = %cond.true.1513
  br i1 false, label %cond.true.1545, label %cond.false.1546

cond.true.1545:                                   ; preds = %cond.false.1544
  br i1 false, label %cond.true.1670, label %lor.lhs.false.1653

cond.false.1546:                                  ; preds = %cond.false.1544
  %240 = load i64, i64* %numargs, align 8
  %shr1547 = ashr i64 %240, 2
  %add1548 = add nsw i64 0, %shr1547
  %mul1549 = mul nsw i64 0, %add1548
  %sub1550 = sub nsw i64 %mul1549, 1
  %cmp1551 = icmp slt i64 %sub1550, 0
  br i1 %cmp1551, label %cond.true.1553, label %cond.false.1572

cond.true.1553:                                   ; preds = %cond.false.1546
  %241 = load i64, i64* %numargs, align 8
  %shr1554 = ashr i64 %241, 2
  %add1555 = add nsw i64 0, %shr1554
  %mul1556 = mul nsw i64 0, %add1555
  %add1557 = add nsw i64 %mul1556, 0
  %neg1558 = xor i64 %add1557, -1
  %cmp1559 = icmp eq i64 %neg1558, -1
  %conv1560 = zext i1 %cmp1559 to i32
  %sub1561 = sub nsw i32 0, %conv1560
  %conv1562 = sext i32 %sub1561 to i64
  %242 = load i64, i64* %numargs, align 8
  %shr1563 = ashr i64 %242, 2
  %add1564 = add nsw i64 0, %shr1563
  %mul1565 = mul nsw i64 0, %add1564
  %add1566 = add nsw i64 %mul1565, 1
  %shl1567 = shl i64 %add1566, 62
  %sub1568 = sub nsw i64 %shl1567, 1
  %mul1569 = mul nsw i64 %sub1568, 2
  %add1570 = add nsw i64 %mul1569, 1
  %sub1571 = sub nsw i64 %conv1562, %add1570
  br label %cond.end.1577

cond.false.1572:                                  ; preds = %cond.false.1546
  %243 = load i64, i64* %numargs, align 8
  %shr1573 = ashr i64 %243, 2
  %add1574 = add nsw i64 0, %shr1573
  %mul1575 = mul nsw i64 0, %add1574
  %add1576 = add nsw i64 %mul1575, 0
  br label %cond.end.1577

cond.end.1577:                                    ; preds = %cond.false.1572, %cond.true.1553
  %cond1578 = phi i64 [ %sub1571, %cond.true.1553 ], [ %add1576, %cond.false.1572 ]
  %div1579 = sdiv i64 %cond1578, 8
  %244 = load i64, i64* %numargs, align 8
  %shr1580 = ashr i64 %244, 2
  %cmp1581 = icmp slt i64 %div1579, %shr1580
  br i1 %cmp1581, label %cond.true.1670, label %lor.lhs.false.1653

cond.false.1583:                                  ; preds = %lor.lhs.false.1512
  br i1 false, label %cond.true.1584, label %cond.false.1585

cond.true.1584:                                   ; preds = %cond.false.1583
  br i1 false, label %cond.true.1670, label %lor.lhs.false.1653

cond.false.1585:                                  ; preds = %cond.false.1583
  %245 = load i64, i64* %numargs, align 8
  %shr1586 = ashr i64 %245, 2
  %cmp1587 = icmp slt i64 %shr1586, 0
  br i1 %cmp1587, label %cond.true.1589, label %cond.false.1626

cond.true.1589:                                   ; preds = %cond.false.1585
  %246 = load i64, i64* %numargs, align 8
  %shr1590 = ashr i64 %246, 2
  %247 = load i64, i64* %numargs, align 8
  %shr1591 = ashr i64 %247, 2
  %add1592 = add nsw i64 0, %shr1591
  %mul1593 = mul nsw i64 0, %add1592
  %sub1594 = sub nsw i64 %mul1593, 1
  %cmp1595 = icmp slt i64 %sub1594, 0
  br i1 %cmp1595, label %cond.true.1597, label %cond.false.1616

cond.true.1597:                                   ; preds = %cond.true.1589
  %248 = load i64, i64* %numargs, align 8
  %shr1598 = ashr i64 %248, 2
  %add1599 = add nsw i64 0, %shr1598
  %mul1600 = mul nsw i64 0, %add1599
  %add1601 = add nsw i64 %mul1600, 0
  %neg1602 = xor i64 %add1601, -1
  %cmp1603 = icmp eq i64 %neg1602, -1
  %conv1604 = zext i1 %cmp1603 to i32
  %sub1605 = sub nsw i32 0, %conv1604
  %conv1606 = sext i32 %sub1605 to i64
  %249 = load i64, i64* %numargs, align 8
  %shr1607 = ashr i64 %249, 2
  %add1608 = add nsw i64 0, %shr1607
  %mul1609 = mul nsw i64 0, %add1608
  %add1610 = add nsw i64 %mul1609, 1
  %shl1611 = shl i64 %add1610, 62
  %sub1612 = sub nsw i64 %shl1611, 1
  %mul1613 = mul nsw i64 %sub1612, 2
  %add1614 = add nsw i64 %mul1613, 1
  %sub1615 = sub nsw i64 %conv1606, %add1614
  br label %cond.end.1621

cond.false.1616:                                  ; preds = %cond.true.1589
  %250 = load i64, i64* %numargs, align 8
  %shr1617 = ashr i64 %250, 2
  %add1618 = add nsw i64 0, %shr1617
  %mul1619 = mul nsw i64 0, %add1618
  %add1620 = add nsw i64 %mul1619, 0
  br label %cond.end.1621

cond.end.1621:                                    ; preds = %cond.false.1616, %cond.true.1597
  %cond1622 = phi i64 [ %sub1615, %cond.true.1597 ], [ %add1620, %cond.false.1616 ]
  %div1623 = sdiv i64 %cond1622, 8
  %cmp1624 = icmp slt i64 %shr1590, %div1623
  br i1 %cmp1624, label %cond.true.1670, label %lor.lhs.false.1653

cond.false.1626:                                  ; preds = %cond.false.1585
  %251 = load i64, i64* %numargs, align 8
  %shr1627 = ashr i64 %251, 2
  %add1628 = add nsw i64 0, %shr1627
  %mul1629 = mul nsw i64 0, %add1628
  %sub1630 = sub nsw i64 %mul1629, 1
  %cmp1631 = icmp slt i64 %sub1630, 0
  br i1 %cmp1631, label %cond.true.1633, label %cond.false.1642

cond.true.1633:                                   ; preds = %cond.false.1626
  %252 = load i64, i64* %numargs, align 8
  %shr1634 = ashr i64 %252, 2
  %add1635 = add nsw i64 0, %shr1634
  %mul1636 = mul nsw i64 0, %add1635
  %add1637 = add nsw i64 %mul1636, 1
  %shl1638 = shl i64 %add1637, 62
  %sub1639 = sub nsw i64 %shl1638, 1
  %mul1640 = mul nsw i64 %sub1639, 2
  %add1641 = add nsw i64 %mul1640, 1
  br label %cond.end.1647

cond.false.1642:                                  ; preds = %cond.false.1626
  %253 = load i64, i64* %numargs, align 8
  %shr1643 = ashr i64 %253, 2
  %add1644 = add nsw i64 0, %shr1643
  %mul1645 = mul nsw i64 0, %add1644
  %sub1646 = sub nsw i64 %mul1645, 1
  br label %cond.end.1647

cond.end.1647:                                    ; preds = %cond.false.1642, %cond.true.1633
  %cond1648 = phi i64 [ %add1641, %cond.true.1633 ], [ %sub1646, %cond.false.1642 ]
  %div1649 = sdiv i64 %cond1648, 8
  %254 = load i64, i64* %numargs, align 8
  %shr1650 = ashr i64 %254, 2
  %cmp1651 = icmp slt i64 %div1649, %shr1650
  br i1 %cmp1651, label %cond.true.1670, label %lor.lhs.false.1653

lor.lhs.false.1653:                               ; preds = %cond.end.1647, %cond.end.1621, %cond.true.1584, %cond.end.1577, %cond.true.1545, %cond.end.1539
  %255 = load i64, i64* %numargs, align 8
  %shr1654 = ashr i64 %255, 2
  %mul1655 = mul nsw i64 %shr1654, 8
  %mul1656 = mul nsw i64 0, %mul1655
  %sub1657 = sub nsw i64 %mul1656, 1
  %cmp1658 = icmp slt i64 %sub1657, 0
  br i1 %cmp1658, label %land.lhs.true.1660, label %lor.lhs.false.1665

land.lhs.true.1660:                               ; preds = %lor.lhs.false.1653
  %256 = load i64, i64* %numargs, align 8
  %shr1661 = ashr i64 %256, 2
  %mul1662 = mul nsw i64 %shr1661, 8
  %cmp1663 = icmp slt i64 %mul1662, -2147483648
  br i1 %cmp1663, label %cond.true.1670, label %lor.lhs.false.1665

lor.lhs.false.1665:                               ; preds = %land.lhs.true.1660, %lor.lhs.false.1653
  %257 = load i64, i64* %numargs, align 8
  %shr1666 = ashr i64 %257, 2
  %mul1667 = mul nsw i64 %shr1666, 8
  %cmp1668 = icmp slt i64 2147483647, %mul1667
  br i1 %cmp1668, label %cond.true.1670, label %cond.false.1689

cond.true.1670:                                   ; preds = %lor.lhs.false.1665, %land.lhs.true.1660, %cond.end.1647, %cond.end.1621, %cond.true.1584, %cond.end.1577, %cond.true.1545, %cond.end.1539, %land.lhs.true.1508
  %258 = load i64, i64* %numargs, align 8
  %shr1671 = ashr i64 %258, 2
  %conv1672 = trunc i64 %shr1671 to i32
  %mul1673 = mul i32 %conv1672, 8
  %cmp1674 = icmp ule i32 %mul1673, 2147483647
  br i1 %cmp1674, label %cond.true.1676, label %cond.false.1680

cond.true.1676:                                   ; preds = %cond.true.1670
  %259 = load i64, i64* %numargs, align 8
  %shr1677 = ashr i64 %259, 2
  %conv1678 = trunc i64 %shr1677 to i32
  %mul1679 = mul i32 %conv1678, 8
  br label %cond.end.1686

cond.false.1680:                                  ; preds = %cond.true.1670
  %260 = load i64, i64* %numargs, align 8
  %shr1681 = ashr i64 %260, 2
  %conv1682 = trunc i64 %shr1681 to i32
  %mul1683 = mul i32 %conv1682, 8
  %sub1684 = sub i32 %mul1683, -2147483648
  %add1685 = add nsw i32 %sub1684, -2147483648
  br label %cond.end.1686

cond.end.1686:                                    ; preds = %cond.false.1680, %cond.true.1676
  %cond1687 = phi i32 [ %mul1679, %cond.true.1676 ], [ %add1685, %cond.false.1680 ]
  %conv1688 = sext i32 %cond1687 to i64
  store i64 %conv1688, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2622, label %lor.lhs.false.2619

cond.false.1689:                                  ; preds = %lor.lhs.false.1665
  %261 = load i64, i64* %numargs, align 8
  %shr1690 = ashr i64 %261, 2
  %conv1691 = trunc i64 %shr1690 to i32
  %mul1692 = mul i32 %conv1691, 8
  %cmp1693 = icmp ule i32 %mul1692, 2147483647
  br i1 %cmp1693, label %cond.true.1695, label %cond.false.1699

cond.true.1695:                                   ; preds = %cond.false.1689
  %262 = load i64, i64* %numargs, align 8
  %shr1696 = ashr i64 %262, 2
  %conv1697 = trunc i64 %shr1696 to i32
  %mul1698 = mul i32 %conv1697, 8
  br label %cond.end.1705

cond.false.1699:                                  ; preds = %cond.false.1689
  %263 = load i64, i64* %numargs, align 8
  %shr1700 = ashr i64 %263, 2
  %conv1701 = trunc i64 %shr1700 to i32
  %mul1702 = mul i32 %conv1701, 8
  %sub1703 = sub i32 %mul1702, -2147483648
  %add1704 = add nsw i32 %sub1703, -2147483648
  br label %cond.end.1705

cond.end.1705:                                    ; preds = %cond.false.1699, %cond.true.1695
  %cond1706 = phi i32 [ %mul1698, %cond.true.1695 ], [ %add1704, %cond.false.1699 ]
  %conv1707 = sext i32 %cond1706 to i64
  store i64 %conv1707, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2622, label %lor.lhs.false.2619

cond.false.1708:                                  ; preds = %cond.false.1211
  br i1 true, label %cond.true.1709, label %cond.false.2164

cond.true.1709:                                   ; preds = %cond.false.1708
  br i1 false, label %cond.true.1710, label %cond.false.1937

cond.true.1710:                                   ; preds = %cond.true.1709
  %264 = load i64, i64* %numargs, align 8
  %shr1711 = ashr i64 %264, 2
  %add1712 = add nsw i64 0, %shr1711
  %mul1713 = mul nsw i64 0, %add1712
  %sub1714 = sub nsw i64 %mul1713, 1
  %cmp1715 = icmp slt i64 %sub1714, 0
  br i1 %cmp1715, label %cond.true.1717, label %cond.false.1736

cond.true.1717:                                   ; preds = %cond.true.1710
  %265 = load i64, i64* %numargs, align 8
  %shr1718 = ashr i64 %265, 2
  %add1719 = add nsw i64 0, %shr1718
  %mul1720 = mul nsw i64 0, %add1719
  %add1721 = add nsw i64 %mul1720, 0
  %neg1722 = xor i64 %add1721, -1
  %cmp1723 = icmp eq i64 %neg1722, -1
  %conv1724 = zext i1 %cmp1723 to i32
  %sub1725 = sub nsw i32 0, %conv1724
  %conv1726 = sext i32 %sub1725 to i64
  %266 = load i64, i64* %numargs, align 8
  %shr1727 = ashr i64 %266, 2
  %add1728 = add nsw i64 0, %shr1727
  %mul1729 = mul nsw i64 0, %add1728
  %add1730 = add nsw i64 %mul1729, 1
  %shl1731 = shl i64 %add1730, 62
  %sub1732 = sub nsw i64 %shl1731, 1
  %mul1733 = mul nsw i64 %sub1732, 2
  %add1734 = add nsw i64 %mul1733, 1
  %sub1735 = sub nsw i64 %conv1726, %add1734
  br label %cond.end.1741

cond.false.1736:                                  ; preds = %cond.true.1710
  %267 = load i64, i64* %numargs, align 8
  %shr1737 = ashr i64 %267, 2
  %add1738 = add nsw i64 0, %shr1737
  %mul1739 = mul nsw i64 0, %add1738
  %add1740 = add nsw i64 %mul1739, 0
  br label %cond.end.1741

cond.end.1741:                                    ; preds = %cond.false.1736, %cond.true.1717
  %cond1742 = phi i64 [ %sub1735, %cond.true.1717 ], [ %add1740, %cond.false.1736 ]
  %cmp1743 = icmp eq i64 %cond1742, 0
  br i1 %cmp1743, label %land.lhs.true.1745, label %lor.lhs.false.1749

land.lhs.true.1745:                               ; preds = %cond.end.1741
  %268 = load i64, i64* %numargs, align 8
  %shr1746 = ashr i64 %268, 2
  %cmp1747 = icmp slt i64 %shr1746, 0
  br i1 %cmp1747, label %cond.true.1907, label %lor.lhs.false.1749

lor.lhs.false.1749:                               ; preds = %land.lhs.true.1745, %cond.end.1741
  br i1 false, label %cond.true.1750, label %cond.false.1820

cond.true.1750:                                   ; preds = %lor.lhs.false.1749
  %269 = load i64, i64* %numargs, align 8
  %shr1751 = ashr i64 %269, 2
  %cmp1752 = icmp slt i64 %shr1751, 0
  br i1 %cmp1752, label %cond.true.1754, label %cond.false.1781

cond.true.1754:                                   ; preds = %cond.true.1750
  %270 = load i64, i64* %numargs, align 8
  %shr1755 = ashr i64 %270, 2
  %271 = load i64, i64* %numargs, align 8
  %shr1756 = ashr i64 %271, 2
  %add1757 = add nsw i64 0, %shr1756
  %mul1758 = mul nsw i64 0, %add1757
  %sub1759 = sub nsw i64 %mul1758, 1
  %cmp1760 = icmp slt i64 %sub1759, 0
  br i1 %cmp1760, label %cond.true.1762, label %cond.false.1771

cond.true.1762:                                   ; preds = %cond.true.1754
  %272 = load i64, i64* %numargs, align 8
  %shr1763 = ashr i64 %272, 2
  %add1764 = add nsw i64 0, %shr1763
  %mul1765 = mul nsw i64 0, %add1764
  %add1766 = add nsw i64 %mul1765, 1
  %shl1767 = shl i64 %add1766, 62
  %sub1768 = sub nsw i64 %shl1767, 1
  %mul1769 = mul nsw i64 %sub1768, 2
  %add1770 = add nsw i64 %mul1769, 1
  br label %cond.end.1776

cond.false.1771:                                  ; preds = %cond.true.1754
  %273 = load i64, i64* %numargs, align 8
  %shr1772 = ashr i64 %273, 2
  %add1773 = add nsw i64 0, %shr1772
  %mul1774 = mul nsw i64 0, %add1773
  %sub1775 = sub nsw i64 %mul1774, 1
  br label %cond.end.1776

cond.end.1776:                                    ; preds = %cond.false.1771, %cond.true.1762
  %cond1777 = phi i64 [ %add1770, %cond.true.1762 ], [ %sub1775, %cond.false.1771 ]
  %div1778 = sdiv i64 %cond1777, 8
  %cmp1779 = icmp slt i64 %shr1755, %div1778
  br i1 %cmp1779, label %cond.true.1907, label %lor.lhs.false.1890

cond.false.1781:                                  ; preds = %cond.true.1750
  br i1 false, label %cond.true.1782, label %cond.false.1783

cond.true.1782:                                   ; preds = %cond.false.1781
  br i1 false, label %cond.true.1907, label %lor.lhs.false.1890

cond.false.1783:                                  ; preds = %cond.false.1781
  %274 = load i64, i64* %numargs, align 8
  %shr1784 = ashr i64 %274, 2
  %add1785 = add nsw i64 0, %shr1784
  %mul1786 = mul nsw i64 0, %add1785
  %sub1787 = sub nsw i64 %mul1786, 1
  %cmp1788 = icmp slt i64 %sub1787, 0
  br i1 %cmp1788, label %cond.true.1790, label %cond.false.1809

cond.true.1790:                                   ; preds = %cond.false.1783
  %275 = load i64, i64* %numargs, align 8
  %shr1791 = ashr i64 %275, 2
  %add1792 = add nsw i64 0, %shr1791
  %mul1793 = mul nsw i64 0, %add1792
  %add1794 = add nsw i64 %mul1793, 0
  %neg1795 = xor i64 %add1794, -1
  %cmp1796 = icmp eq i64 %neg1795, -1
  %conv1797 = zext i1 %cmp1796 to i32
  %sub1798 = sub nsw i32 0, %conv1797
  %conv1799 = sext i32 %sub1798 to i64
  %276 = load i64, i64* %numargs, align 8
  %shr1800 = ashr i64 %276, 2
  %add1801 = add nsw i64 0, %shr1800
  %mul1802 = mul nsw i64 0, %add1801
  %add1803 = add nsw i64 %mul1802, 1
  %shl1804 = shl i64 %add1803, 62
  %sub1805 = sub nsw i64 %shl1804, 1
  %mul1806 = mul nsw i64 %sub1805, 2
  %add1807 = add nsw i64 %mul1806, 1
  %sub1808 = sub nsw i64 %conv1799, %add1807
  br label %cond.end.1814

cond.false.1809:                                  ; preds = %cond.false.1783
  %277 = load i64, i64* %numargs, align 8
  %shr1810 = ashr i64 %277, 2
  %add1811 = add nsw i64 0, %shr1810
  %mul1812 = mul nsw i64 0, %add1811
  %add1813 = add nsw i64 %mul1812, 0
  br label %cond.end.1814

cond.end.1814:                                    ; preds = %cond.false.1809, %cond.true.1790
  %cond1815 = phi i64 [ %sub1808, %cond.true.1790 ], [ %add1813, %cond.false.1809 ]
  %div1816 = sdiv i64 %cond1815, 8
  %278 = load i64, i64* %numargs, align 8
  %shr1817 = ashr i64 %278, 2
  %cmp1818 = icmp slt i64 %div1816, %shr1817
  br i1 %cmp1818, label %cond.true.1907, label %lor.lhs.false.1890

cond.false.1820:                                  ; preds = %lor.lhs.false.1749
  br i1 false, label %cond.true.1821, label %cond.false.1822

cond.true.1821:                                   ; preds = %cond.false.1820
  br i1 false, label %cond.true.1907, label %lor.lhs.false.1890

cond.false.1822:                                  ; preds = %cond.false.1820
  %279 = load i64, i64* %numargs, align 8
  %shr1823 = ashr i64 %279, 2
  %cmp1824 = icmp slt i64 %shr1823, 0
  br i1 %cmp1824, label %cond.true.1826, label %cond.false.1863

cond.true.1826:                                   ; preds = %cond.false.1822
  %280 = load i64, i64* %numargs, align 8
  %shr1827 = ashr i64 %280, 2
  %281 = load i64, i64* %numargs, align 8
  %shr1828 = ashr i64 %281, 2
  %add1829 = add nsw i64 0, %shr1828
  %mul1830 = mul nsw i64 0, %add1829
  %sub1831 = sub nsw i64 %mul1830, 1
  %cmp1832 = icmp slt i64 %sub1831, 0
  br i1 %cmp1832, label %cond.true.1834, label %cond.false.1853

cond.true.1834:                                   ; preds = %cond.true.1826
  %282 = load i64, i64* %numargs, align 8
  %shr1835 = ashr i64 %282, 2
  %add1836 = add nsw i64 0, %shr1835
  %mul1837 = mul nsw i64 0, %add1836
  %add1838 = add nsw i64 %mul1837, 0
  %neg1839 = xor i64 %add1838, -1
  %cmp1840 = icmp eq i64 %neg1839, -1
  %conv1841 = zext i1 %cmp1840 to i32
  %sub1842 = sub nsw i32 0, %conv1841
  %conv1843 = sext i32 %sub1842 to i64
  %283 = load i64, i64* %numargs, align 8
  %shr1844 = ashr i64 %283, 2
  %add1845 = add nsw i64 0, %shr1844
  %mul1846 = mul nsw i64 0, %add1845
  %add1847 = add nsw i64 %mul1846, 1
  %shl1848 = shl i64 %add1847, 62
  %sub1849 = sub nsw i64 %shl1848, 1
  %mul1850 = mul nsw i64 %sub1849, 2
  %add1851 = add nsw i64 %mul1850, 1
  %sub1852 = sub nsw i64 %conv1843, %add1851
  br label %cond.end.1858

cond.false.1853:                                  ; preds = %cond.true.1826
  %284 = load i64, i64* %numargs, align 8
  %shr1854 = ashr i64 %284, 2
  %add1855 = add nsw i64 0, %shr1854
  %mul1856 = mul nsw i64 0, %add1855
  %add1857 = add nsw i64 %mul1856, 0
  br label %cond.end.1858

cond.end.1858:                                    ; preds = %cond.false.1853, %cond.true.1834
  %cond1859 = phi i64 [ %sub1852, %cond.true.1834 ], [ %add1857, %cond.false.1853 ]
  %div1860 = sdiv i64 %cond1859, 8
  %cmp1861 = icmp slt i64 %shr1827, %div1860
  br i1 %cmp1861, label %cond.true.1907, label %lor.lhs.false.1890

cond.false.1863:                                  ; preds = %cond.false.1822
  %285 = load i64, i64* %numargs, align 8
  %shr1864 = ashr i64 %285, 2
  %add1865 = add nsw i64 0, %shr1864
  %mul1866 = mul nsw i64 0, %add1865
  %sub1867 = sub nsw i64 %mul1866, 1
  %cmp1868 = icmp slt i64 %sub1867, 0
  br i1 %cmp1868, label %cond.true.1870, label %cond.false.1879

cond.true.1870:                                   ; preds = %cond.false.1863
  %286 = load i64, i64* %numargs, align 8
  %shr1871 = ashr i64 %286, 2
  %add1872 = add nsw i64 0, %shr1871
  %mul1873 = mul nsw i64 0, %add1872
  %add1874 = add nsw i64 %mul1873, 1
  %shl1875 = shl i64 %add1874, 62
  %sub1876 = sub nsw i64 %shl1875, 1
  %mul1877 = mul nsw i64 %sub1876, 2
  %add1878 = add nsw i64 %mul1877, 1
  br label %cond.end.1884

cond.false.1879:                                  ; preds = %cond.false.1863
  %287 = load i64, i64* %numargs, align 8
  %shr1880 = ashr i64 %287, 2
  %add1881 = add nsw i64 0, %shr1880
  %mul1882 = mul nsw i64 0, %add1881
  %sub1883 = sub nsw i64 %mul1882, 1
  br label %cond.end.1884

cond.end.1884:                                    ; preds = %cond.false.1879, %cond.true.1870
  %cond1885 = phi i64 [ %add1878, %cond.true.1870 ], [ %sub1883, %cond.false.1879 ]
  %div1886 = sdiv i64 %cond1885, 8
  %288 = load i64, i64* %numargs, align 8
  %shr1887 = ashr i64 %288, 2
  %cmp1888 = icmp slt i64 %div1886, %shr1887
  br i1 %cmp1888, label %cond.true.1907, label %lor.lhs.false.1890

lor.lhs.false.1890:                               ; preds = %cond.end.1884, %cond.end.1858, %cond.true.1821, %cond.end.1814, %cond.true.1782, %cond.end.1776
  %289 = load i64, i64* %numargs, align 8
  %shr1891 = ashr i64 %289, 2
  %mul1892 = mul nsw i64 %shr1891, 8
  %mul1893 = mul nsw i64 0, %mul1892
  %sub1894 = sub nsw i64 %mul1893, 1
  %cmp1895 = icmp slt i64 %sub1894, 0
  br i1 %cmp1895, label %land.lhs.true.1897, label %lor.lhs.false.1902

land.lhs.true.1897:                               ; preds = %lor.lhs.false.1890
  %290 = load i64, i64* %numargs, align 8
  %shr1898 = ashr i64 %290, 2
  %mul1899 = mul nsw i64 %shr1898, 8
  %cmp1900 = icmp slt i64 %mul1899, -9223372036854775808
  br i1 %cmp1900, label %cond.true.1907, label %lor.lhs.false.1902

lor.lhs.false.1902:                               ; preds = %land.lhs.true.1897, %lor.lhs.false.1890
  %291 = load i64, i64* %numargs, align 8
  %shr1903 = ashr i64 %291, 2
  %mul1904 = mul nsw i64 %shr1903, 8
  %cmp1905 = icmp slt i64 9223372036854775807, %mul1904
  br i1 %cmp1905, label %cond.true.1907, label %cond.false.1922

cond.true.1907:                                   ; preds = %lor.lhs.false.1902, %land.lhs.true.1897, %cond.end.1884, %cond.end.1858, %cond.true.1821, %cond.end.1814, %cond.true.1782, %cond.end.1776, %land.lhs.true.1745
  %292 = load i64, i64* %numargs, align 8
  %shr1908 = ashr i64 %292, 2
  %mul1909 = mul i64 %shr1908, 8
  %cmp1910 = icmp ule i64 %mul1909, 9223372036854775807
  br i1 %cmp1910, label %cond.true.1912, label %cond.false.1915

cond.true.1912:                                   ; preds = %cond.true.1907
  %293 = load i64, i64* %numargs, align 8
  %shr1913 = ashr i64 %293, 2
  %mul1914 = mul i64 %shr1913, 8
  br label %cond.end.1920

cond.false.1915:                                  ; preds = %cond.true.1907
  %294 = load i64, i64* %numargs, align 8
  %shr1916 = ashr i64 %294, 2
  %mul1917 = mul i64 %shr1916, 8
  %sub1918 = sub i64 %mul1917, -9223372036854775808
  %add1919 = add nsw i64 %sub1918, -9223372036854775808
  br label %cond.end.1920

cond.end.1920:                                    ; preds = %cond.false.1915, %cond.true.1912
  %cond1921 = phi i64 [ %mul1914, %cond.true.1912 ], [ %add1919, %cond.false.1915 ]
  store i64 %cond1921, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2622, label %lor.lhs.false.2619

cond.false.1922:                                  ; preds = %lor.lhs.false.1902
  %295 = load i64, i64* %numargs, align 8
  %shr1923 = ashr i64 %295, 2
  %mul1924 = mul i64 %shr1923, 8
  %cmp1925 = icmp ule i64 %mul1924, 9223372036854775807
  br i1 %cmp1925, label %cond.true.1927, label %cond.false.1930

cond.true.1927:                                   ; preds = %cond.false.1922
  %296 = load i64, i64* %numargs, align 8
  %shr1928 = ashr i64 %296, 2
  %mul1929 = mul i64 %shr1928, 8
  br label %cond.end.1935

cond.false.1930:                                  ; preds = %cond.false.1922
  %297 = load i64, i64* %numargs, align 8
  %shr1931 = ashr i64 %297, 2
  %mul1932 = mul i64 %shr1931, 8
  %sub1933 = sub i64 %mul1932, -9223372036854775808
  %add1934 = add nsw i64 %sub1933, -9223372036854775808
  br label %cond.end.1935

cond.end.1935:                                    ; preds = %cond.false.1930, %cond.true.1927
  %cond1936 = phi i64 [ %mul1929, %cond.true.1927 ], [ %add1934, %cond.false.1930 ]
  store i64 %cond1936, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2622, label %lor.lhs.false.2619

cond.false.1937:                                  ; preds = %cond.true.1709
  %298 = load i64, i64* %numargs, align 8
  %shr1938 = ashr i64 %298, 2
  %add1939 = add nsw i64 0, %shr1938
  %mul1940 = mul nsw i64 0, %add1939
  %sub1941 = sub nsw i64 %mul1940, 1
  %cmp1942 = icmp slt i64 %sub1941, 0
  br i1 %cmp1942, label %cond.true.1944, label %cond.false.1963

cond.true.1944:                                   ; preds = %cond.false.1937
  %299 = load i64, i64* %numargs, align 8
  %shr1945 = ashr i64 %299, 2
  %add1946 = add nsw i64 0, %shr1945
  %mul1947 = mul nsw i64 0, %add1946
  %add1948 = add nsw i64 %mul1947, 0
  %neg1949 = xor i64 %add1948, -1
  %cmp1950 = icmp eq i64 %neg1949, -1
  %conv1951 = zext i1 %cmp1950 to i32
  %sub1952 = sub nsw i32 0, %conv1951
  %conv1953 = sext i32 %sub1952 to i64
  %300 = load i64, i64* %numargs, align 8
  %shr1954 = ashr i64 %300, 2
  %add1955 = add nsw i64 0, %shr1954
  %mul1956 = mul nsw i64 0, %add1955
  %add1957 = add nsw i64 %mul1956, 1
  %shl1958 = shl i64 %add1957, 62
  %sub1959 = sub nsw i64 %shl1958, 1
  %mul1960 = mul nsw i64 %sub1959, 2
  %add1961 = add nsw i64 %mul1960, 1
  %sub1962 = sub nsw i64 %conv1953, %add1961
  br label %cond.end.1968

cond.false.1963:                                  ; preds = %cond.false.1937
  %301 = load i64, i64* %numargs, align 8
  %shr1964 = ashr i64 %301, 2
  %add1965 = add nsw i64 0, %shr1964
  %mul1966 = mul nsw i64 0, %add1965
  %add1967 = add nsw i64 %mul1966, 0
  br label %cond.end.1968

cond.end.1968:                                    ; preds = %cond.false.1963, %cond.true.1944
  %cond1969 = phi i64 [ %sub1962, %cond.true.1944 ], [ %add1967, %cond.false.1963 ]
  %cmp1970 = icmp eq i64 %cond1969, 0
  br i1 %cmp1970, label %land.lhs.true.1972, label %lor.lhs.false.1976

land.lhs.true.1972:                               ; preds = %cond.end.1968
  %302 = load i64, i64* %numargs, align 8
  %shr1973 = ashr i64 %302, 2
  %cmp1974 = icmp slt i64 %shr1973, 0
  br i1 %cmp1974, label %cond.true.2134, label %lor.lhs.false.1976

lor.lhs.false.1976:                               ; preds = %land.lhs.true.1972, %cond.end.1968
  br i1 false, label %cond.true.1977, label %cond.false.2047

cond.true.1977:                                   ; preds = %lor.lhs.false.1976
  %303 = load i64, i64* %numargs, align 8
  %shr1978 = ashr i64 %303, 2
  %cmp1979 = icmp slt i64 %shr1978, 0
  br i1 %cmp1979, label %cond.true.1981, label %cond.false.2008

cond.true.1981:                                   ; preds = %cond.true.1977
  %304 = load i64, i64* %numargs, align 8
  %shr1982 = ashr i64 %304, 2
  %305 = load i64, i64* %numargs, align 8
  %shr1983 = ashr i64 %305, 2
  %add1984 = add nsw i64 0, %shr1983
  %mul1985 = mul nsw i64 0, %add1984
  %sub1986 = sub nsw i64 %mul1985, 1
  %cmp1987 = icmp slt i64 %sub1986, 0
  br i1 %cmp1987, label %cond.true.1989, label %cond.false.1998

cond.true.1989:                                   ; preds = %cond.true.1981
  %306 = load i64, i64* %numargs, align 8
  %shr1990 = ashr i64 %306, 2
  %add1991 = add nsw i64 0, %shr1990
  %mul1992 = mul nsw i64 0, %add1991
  %add1993 = add nsw i64 %mul1992, 1
  %shl1994 = shl i64 %add1993, 62
  %sub1995 = sub nsw i64 %shl1994, 1
  %mul1996 = mul nsw i64 %sub1995, 2
  %add1997 = add nsw i64 %mul1996, 1
  br label %cond.end.2003

cond.false.1998:                                  ; preds = %cond.true.1981
  %307 = load i64, i64* %numargs, align 8
  %shr1999 = ashr i64 %307, 2
  %add2000 = add nsw i64 0, %shr1999
  %mul2001 = mul nsw i64 0, %add2000
  %sub2002 = sub nsw i64 %mul2001, 1
  br label %cond.end.2003

cond.end.2003:                                    ; preds = %cond.false.1998, %cond.true.1989
  %cond2004 = phi i64 [ %add1997, %cond.true.1989 ], [ %sub2002, %cond.false.1998 ]
  %div2005 = sdiv i64 %cond2004, 8
  %cmp2006 = icmp slt i64 %shr1982, %div2005
  br i1 %cmp2006, label %cond.true.2134, label %lor.lhs.false.2117

cond.false.2008:                                  ; preds = %cond.true.1977
  br i1 false, label %cond.true.2009, label %cond.false.2010

cond.true.2009:                                   ; preds = %cond.false.2008
  br i1 false, label %cond.true.2134, label %lor.lhs.false.2117

cond.false.2010:                                  ; preds = %cond.false.2008
  %308 = load i64, i64* %numargs, align 8
  %shr2011 = ashr i64 %308, 2
  %add2012 = add nsw i64 0, %shr2011
  %mul2013 = mul nsw i64 0, %add2012
  %sub2014 = sub nsw i64 %mul2013, 1
  %cmp2015 = icmp slt i64 %sub2014, 0
  br i1 %cmp2015, label %cond.true.2017, label %cond.false.2036

cond.true.2017:                                   ; preds = %cond.false.2010
  %309 = load i64, i64* %numargs, align 8
  %shr2018 = ashr i64 %309, 2
  %add2019 = add nsw i64 0, %shr2018
  %mul2020 = mul nsw i64 0, %add2019
  %add2021 = add nsw i64 %mul2020, 0
  %neg2022 = xor i64 %add2021, -1
  %cmp2023 = icmp eq i64 %neg2022, -1
  %conv2024 = zext i1 %cmp2023 to i32
  %sub2025 = sub nsw i32 0, %conv2024
  %conv2026 = sext i32 %sub2025 to i64
  %310 = load i64, i64* %numargs, align 8
  %shr2027 = ashr i64 %310, 2
  %add2028 = add nsw i64 0, %shr2027
  %mul2029 = mul nsw i64 0, %add2028
  %add2030 = add nsw i64 %mul2029, 1
  %shl2031 = shl i64 %add2030, 62
  %sub2032 = sub nsw i64 %shl2031, 1
  %mul2033 = mul nsw i64 %sub2032, 2
  %add2034 = add nsw i64 %mul2033, 1
  %sub2035 = sub nsw i64 %conv2026, %add2034
  br label %cond.end.2041

cond.false.2036:                                  ; preds = %cond.false.2010
  %311 = load i64, i64* %numargs, align 8
  %shr2037 = ashr i64 %311, 2
  %add2038 = add nsw i64 0, %shr2037
  %mul2039 = mul nsw i64 0, %add2038
  %add2040 = add nsw i64 %mul2039, 0
  br label %cond.end.2041

cond.end.2041:                                    ; preds = %cond.false.2036, %cond.true.2017
  %cond2042 = phi i64 [ %sub2035, %cond.true.2017 ], [ %add2040, %cond.false.2036 ]
  %div2043 = sdiv i64 %cond2042, 8
  %312 = load i64, i64* %numargs, align 8
  %shr2044 = ashr i64 %312, 2
  %cmp2045 = icmp slt i64 %div2043, %shr2044
  br i1 %cmp2045, label %cond.true.2134, label %lor.lhs.false.2117

cond.false.2047:                                  ; preds = %lor.lhs.false.1976
  br i1 false, label %cond.true.2048, label %cond.false.2049

cond.true.2048:                                   ; preds = %cond.false.2047
  br i1 false, label %cond.true.2134, label %lor.lhs.false.2117

cond.false.2049:                                  ; preds = %cond.false.2047
  %313 = load i64, i64* %numargs, align 8
  %shr2050 = ashr i64 %313, 2
  %cmp2051 = icmp slt i64 %shr2050, 0
  br i1 %cmp2051, label %cond.true.2053, label %cond.false.2090

cond.true.2053:                                   ; preds = %cond.false.2049
  %314 = load i64, i64* %numargs, align 8
  %shr2054 = ashr i64 %314, 2
  %315 = load i64, i64* %numargs, align 8
  %shr2055 = ashr i64 %315, 2
  %add2056 = add nsw i64 0, %shr2055
  %mul2057 = mul nsw i64 0, %add2056
  %sub2058 = sub nsw i64 %mul2057, 1
  %cmp2059 = icmp slt i64 %sub2058, 0
  br i1 %cmp2059, label %cond.true.2061, label %cond.false.2080

cond.true.2061:                                   ; preds = %cond.true.2053
  %316 = load i64, i64* %numargs, align 8
  %shr2062 = ashr i64 %316, 2
  %add2063 = add nsw i64 0, %shr2062
  %mul2064 = mul nsw i64 0, %add2063
  %add2065 = add nsw i64 %mul2064, 0
  %neg2066 = xor i64 %add2065, -1
  %cmp2067 = icmp eq i64 %neg2066, -1
  %conv2068 = zext i1 %cmp2067 to i32
  %sub2069 = sub nsw i32 0, %conv2068
  %conv2070 = sext i32 %sub2069 to i64
  %317 = load i64, i64* %numargs, align 8
  %shr2071 = ashr i64 %317, 2
  %add2072 = add nsw i64 0, %shr2071
  %mul2073 = mul nsw i64 0, %add2072
  %add2074 = add nsw i64 %mul2073, 1
  %shl2075 = shl i64 %add2074, 62
  %sub2076 = sub nsw i64 %shl2075, 1
  %mul2077 = mul nsw i64 %sub2076, 2
  %add2078 = add nsw i64 %mul2077, 1
  %sub2079 = sub nsw i64 %conv2070, %add2078
  br label %cond.end.2085

cond.false.2080:                                  ; preds = %cond.true.2053
  %318 = load i64, i64* %numargs, align 8
  %shr2081 = ashr i64 %318, 2
  %add2082 = add nsw i64 0, %shr2081
  %mul2083 = mul nsw i64 0, %add2082
  %add2084 = add nsw i64 %mul2083, 0
  br label %cond.end.2085

cond.end.2085:                                    ; preds = %cond.false.2080, %cond.true.2061
  %cond2086 = phi i64 [ %sub2079, %cond.true.2061 ], [ %add2084, %cond.false.2080 ]
  %div2087 = sdiv i64 %cond2086, 8
  %cmp2088 = icmp slt i64 %shr2054, %div2087
  br i1 %cmp2088, label %cond.true.2134, label %lor.lhs.false.2117

cond.false.2090:                                  ; preds = %cond.false.2049
  %319 = load i64, i64* %numargs, align 8
  %shr2091 = ashr i64 %319, 2
  %add2092 = add nsw i64 0, %shr2091
  %mul2093 = mul nsw i64 0, %add2092
  %sub2094 = sub nsw i64 %mul2093, 1
  %cmp2095 = icmp slt i64 %sub2094, 0
  br i1 %cmp2095, label %cond.true.2097, label %cond.false.2106

cond.true.2097:                                   ; preds = %cond.false.2090
  %320 = load i64, i64* %numargs, align 8
  %shr2098 = ashr i64 %320, 2
  %add2099 = add nsw i64 0, %shr2098
  %mul2100 = mul nsw i64 0, %add2099
  %add2101 = add nsw i64 %mul2100, 1
  %shl2102 = shl i64 %add2101, 62
  %sub2103 = sub nsw i64 %shl2102, 1
  %mul2104 = mul nsw i64 %sub2103, 2
  %add2105 = add nsw i64 %mul2104, 1
  br label %cond.end.2111

cond.false.2106:                                  ; preds = %cond.false.2090
  %321 = load i64, i64* %numargs, align 8
  %shr2107 = ashr i64 %321, 2
  %add2108 = add nsw i64 0, %shr2107
  %mul2109 = mul nsw i64 0, %add2108
  %sub2110 = sub nsw i64 %mul2109, 1
  br label %cond.end.2111

cond.end.2111:                                    ; preds = %cond.false.2106, %cond.true.2097
  %cond2112 = phi i64 [ %add2105, %cond.true.2097 ], [ %sub2110, %cond.false.2106 ]
  %div2113 = sdiv i64 %cond2112, 8
  %322 = load i64, i64* %numargs, align 8
  %shr2114 = ashr i64 %322, 2
  %cmp2115 = icmp slt i64 %div2113, %shr2114
  br i1 %cmp2115, label %cond.true.2134, label %lor.lhs.false.2117

lor.lhs.false.2117:                               ; preds = %cond.end.2111, %cond.end.2085, %cond.true.2048, %cond.end.2041, %cond.true.2009, %cond.end.2003
  %323 = load i64, i64* %numargs, align 8
  %shr2118 = ashr i64 %323, 2
  %mul2119 = mul nsw i64 %shr2118, 8
  %mul2120 = mul nsw i64 0, %mul2119
  %sub2121 = sub nsw i64 %mul2120, 1
  %cmp2122 = icmp slt i64 %sub2121, 0
  br i1 %cmp2122, label %land.lhs.true.2124, label %lor.lhs.false.2129

land.lhs.true.2124:                               ; preds = %lor.lhs.false.2117
  %324 = load i64, i64* %numargs, align 8
  %shr2125 = ashr i64 %324, 2
  %mul2126 = mul nsw i64 %shr2125, 8
  %cmp2127 = icmp slt i64 %mul2126, -9223372036854775808
  br i1 %cmp2127, label %cond.true.2134, label %lor.lhs.false.2129

lor.lhs.false.2129:                               ; preds = %land.lhs.true.2124, %lor.lhs.false.2117
  %325 = load i64, i64* %numargs, align 8
  %shr2130 = ashr i64 %325, 2
  %mul2131 = mul nsw i64 %shr2130, 8
  %cmp2132 = icmp slt i64 9223372036854775807, %mul2131
  br i1 %cmp2132, label %cond.true.2134, label %cond.false.2149

cond.true.2134:                                   ; preds = %lor.lhs.false.2129, %land.lhs.true.2124, %cond.end.2111, %cond.end.2085, %cond.true.2048, %cond.end.2041, %cond.true.2009, %cond.end.2003, %land.lhs.true.1972
  %326 = load i64, i64* %numargs, align 8
  %shr2135 = ashr i64 %326, 2
  %mul2136 = mul i64 %shr2135, 8
  %cmp2137 = icmp ule i64 %mul2136, 9223372036854775807
  br i1 %cmp2137, label %cond.true.2139, label %cond.false.2142

cond.true.2139:                                   ; preds = %cond.true.2134
  %327 = load i64, i64* %numargs, align 8
  %shr2140 = ashr i64 %327, 2
  %mul2141 = mul i64 %shr2140, 8
  br label %cond.end.2147

cond.false.2142:                                  ; preds = %cond.true.2134
  %328 = load i64, i64* %numargs, align 8
  %shr2143 = ashr i64 %328, 2
  %mul2144 = mul i64 %shr2143, 8
  %sub2145 = sub i64 %mul2144, -9223372036854775808
  %add2146 = add nsw i64 %sub2145, -9223372036854775808
  br label %cond.end.2147

cond.end.2147:                                    ; preds = %cond.false.2142, %cond.true.2139
  %cond2148 = phi i64 [ %mul2141, %cond.true.2139 ], [ %add2146, %cond.false.2142 ]
  store i64 %cond2148, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2622, label %lor.lhs.false.2619

cond.false.2149:                                  ; preds = %lor.lhs.false.2129
  %329 = load i64, i64* %numargs, align 8
  %shr2150 = ashr i64 %329, 2
  %mul2151 = mul i64 %shr2150, 8
  %cmp2152 = icmp ule i64 %mul2151, 9223372036854775807
  br i1 %cmp2152, label %cond.true.2154, label %cond.false.2157

cond.true.2154:                                   ; preds = %cond.false.2149
  %330 = load i64, i64* %numargs, align 8
  %shr2155 = ashr i64 %330, 2
  %mul2156 = mul i64 %shr2155, 8
  br label %cond.end.2162

cond.false.2157:                                  ; preds = %cond.false.2149
  %331 = load i64, i64* %numargs, align 8
  %shr2158 = ashr i64 %331, 2
  %mul2159 = mul i64 %shr2158, 8
  %sub2160 = sub i64 %mul2159, -9223372036854775808
  %add2161 = add nsw i64 %sub2160, -9223372036854775808
  br label %cond.end.2162

cond.end.2162:                                    ; preds = %cond.false.2157, %cond.true.2154
  %cond2163 = phi i64 [ %mul2156, %cond.true.2154 ], [ %add2161, %cond.false.2157 ]
  store i64 %cond2163, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2622, label %lor.lhs.false.2619

cond.false.2164:                                  ; preds = %cond.false.1708
  br i1 false, label %cond.true.2165, label %cond.false.2392

cond.true.2165:                                   ; preds = %cond.false.2164
  %332 = load i64, i64* %numargs, align 8
  %shr2166 = ashr i64 %332, 2
  %add2167 = add nsw i64 0, %shr2166
  %mul2168 = mul nsw i64 0, %add2167
  %sub2169 = sub nsw i64 %mul2168, 1
  %cmp2170 = icmp slt i64 %sub2169, 0
  br i1 %cmp2170, label %cond.true.2172, label %cond.false.2191

cond.true.2172:                                   ; preds = %cond.true.2165
  %333 = load i64, i64* %numargs, align 8
  %shr2173 = ashr i64 %333, 2
  %add2174 = add nsw i64 0, %shr2173
  %mul2175 = mul nsw i64 0, %add2174
  %add2176 = add nsw i64 %mul2175, 0
  %neg2177 = xor i64 %add2176, -1
  %cmp2178 = icmp eq i64 %neg2177, -1
  %conv2179 = zext i1 %cmp2178 to i32
  %sub2180 = sub nsw i32 0, %conv2179
  %conv2181 = sext i32 %sub2180 to i64
  %334 = load i64, i64* %numargs, align 8
  %shr2182 = ashr i64 %334, 2
  %add2183 = add nsw i64 0, %shr2182
  %mul2184 = mul nsw i64 0, %add2183
  %add2185 = add nsw i64 %mul2184, 1
  %shl2186 = shl i64 %add2185, 62
  %sub2187 = sub nsw i64 %shl2186, 1
  %mul2188 = mul nsw i64 %sub2187, 2
  %add2189 = add nsw i64 %mul2188, 1
  %sub2190 = sub nsw i64 %conv2181, %add2189
  br label %cond.end.2196

cond.false.2191:                                  ; preds = %cond.true.2165
  %335 = load i64, i64* %numargs, align 8
  %shr2192 = ashr i64 %335, 2
  %add2193 = add nsw i64 0, %shr2192
  %mul2194 = mul nsw i64 0, %add2193
  %add2195 = add nsw i64 %mul2194, 0
  br label %cond.end.2196

cond.end.2196:                                    ; preds = %cond.false.2191, %cond.true.2172
  %cond2197 = phi i64 [ %sub2190, %cond.true.2172 ], [ %add2195, %cond.false.2191 ]
  %cmp2198 = icmp eq i64 %cond2197, 0
  br i1 %cmp2198, label %land.lhs.true.2200, label %lor.lhs.false.2204

land.lhs.true.2200:                               ; preds = %cond.end.2196
  %336 = load i64, i64* %numargs, align 8
  %shr2201 = ashr i64 %336, 2
  %cmp2202 = icmp slt i64 %shr2201, 0
  br i1 %cmp2202, label %cond.true.2362, label %lor.lhs.false.2204

lor.lhs.false.2204:                               ; preds = %land.lhs.true.2200, %cond.end.2196
  br i1 false, label %cond.true.2205, label %cond.false.2275

cond.true.2205:                                   ; preds = %lor.lhs.false.2204
  %337 = load i64, i64* %numargs, align 8
  %shr2206 = ashr i64 %337, 2
  %cmp2207 = icmp slt i64 %shr2206, 0
  br i1 %cmp2207, label %cond.true.2209, label %cond.false.2236

cond.true.2209:                                   ; preds = %cond.true.2205
  %338 = load i64, i64* %numargs, align 8
  %shr2210 = ashr i64 %338, 2
  %339 = load i64, i64* %numargs, align 8
  %shr2211 = ashr i64 %339, 2
  %add2212 = add nsw i64 0, %shr2211
  %mul2213 = mul nsw i64 0, %add2212
  %sub2214 = sub nsw i64 %mul2213, 1
  %cmp2215 = icmp slt i64 %sub2214, 0
  br i1 %cmp2215, label %cond.true.2217, label %cond.false.2226

cond.true.2217:                                   ; preds = %cond.true.2209
  %340 = load i64, i64* %numargs, align 8
  %shr2218 = ashr i64 %340, 2
  %add2219 = add nsw i64 0, %shr2218
  %mul2220 = mul nsw i64 0, %add2219
  %add2221 = add nsw i64 %mul2220, 1
  %shl2222 = shl i64 %add2221, 62
  %sub2223 = sub nsw i64 %shl2222, 1
  %mul2224 = mul nsw i64 %sub2223, 2
  %add2225 = add nsw i64 %mul2224, 1
  br label %cond.end.2231

cond.false.2226:                                  ; preds = %cond.true.2209
  %341 = load i64, i64* %numargs, align 8
  %shr2227 = ashr i64 %341, 2
  %add2228 = add nsw i64 0, %shr2227
  %mul2229 = mul nsw i64 0, %add2228
  %sub2230 = sub nsw i64 %mul2229, 1
  br label %cond.end.2231

cond.end.2231:                                    ; preds = %cond.false.2226, %cond.true.2217
  %cond2232 = phi i64 [ %add2225, %cond.true.2217 ], [ %sub2230, %cond.false.2226 ]
  %div2233 = sdiv i64 %cond2232, 8
  %cmp2234 = icmp slt i64 %shr2210, %div2233
  br i1 %cmp2234, label %cond.true.2362, label %lor.lhs.false.2345

cond.false.2236:                                  ; preds = %cond.true.2205
  br i1 false, label %cond.true.2237, label %cond.false.2238

cond.true.2237:                                   ; preds = %cond.false.2236
  br i1 false, label %cond.true.2362, label %lor.lhs.false.2345

cond.false.2238:                                  ; preds = %cond.false.2236
  %342 = load i64, i64* %numargs, align 8
  %shr2239 = ashr i64 %342, 2
  %add2240 = add nsw i64 0, %shr2239
  %mul2241 = mul nsw i64 0, %add2240
  %sub2242 = sub nsw i64 %mul2241, 1
  %cmp2243 = icmp slt i64 %sub2242, 0
  br i1 %cmp2243, label %cond.true.2245, label %cond.false.2264

cond.true.2245:                                   ; preds = %cond.false.2238
  %343 = load i64, i64* %numargs, align 8
  %shr2246 = ashr i64 %343, 2
  %add2247 = add nsw i64 0, %shr2246
  %mul2248 = mul nsw i64 0, %add2247
  %add2249 = add nsw i64 %mul2248, 0
  %neg2250 = xor i64 %add2249, -1
  %cmp2251 = icmp eq i64 %neg2250, -1
  %conv2252 = zext i1 %cmp2251 to i32
  %sub2253 = sub nsw i32 0, %conv2252
  %conv2254 = sext i32 %sub2253 to i64
  %344 = load i64, i64* %numargs, align 8
  %shr2255 = ashr i64 %344, 2
  %add2256 = add nsw i64 0, %shr2255
  %mul2257 = mul nsw i64 0, %add2256
  %add2258 = add nsw i64 %mul2257, 1
  %shl2259 = shl i64 %add2258, 62
  %sub2260 = sub nsw i64 %shl2259, 1
  %mul2261 = mul nsw i64 %sub2260, 2
  %add2262 = add nsw i64 %mul2261, 1
  %sub2263 = sub nsw i64 %conv2254, %add2262
  br label %cond.end.2269

cond.false.2264:                                  ; preds = %cond.false.2238
  %345 = load i64, i64* %numargs, align 8
  %shr2265 = ashr i64 %345, 2
  %add2266 = add nsw i64 0, %shr2265
  %mul2267 = mul nsw i64 0, %add2266
  %add2268 = add nsw i64 %mul2267, 0
  br label %cond.end.2269

cond.end.2269:                                    ; preds = %cond.false.2264, %cond.true.2245
  %cond2270 = phi i64 [ %sub2263, %cond.true.2245 ], [ %add2268, %cond.false.2264 ]
  %div2271 = sdiv i64 %cond2270, 8
  %346 = load i64, i64* %numargs, align 8
  %shr2272 = ashr i64 %346, 2
  %cmp2273 = icmp slt i64 %div2271, %shr2272
  br i1 %cmp2273, label %cond.true.2362, label %lor.lhs.false.2345

cond.false.2275:                                  ; preds = %lor.lhs.false.2204
  br i1 false, label %cond.true.2276, label %cond.false.2277

cond.true.2276:                                   ; preds = %cond.false.2275
  br i1 false, label %cond.true.2362, label %lor.lhs.false.2345

cond.false.2277:                                  ; preds = %cond.false.2275
  %347 = load i64, i64* %numargs, align 8
  %shr2278 = ashr i64 %347, 2
  %cmp2279 = icmp slt i64 %shr2278, 0
  br i1 %cmp2279, label %cond.true.2281, label %cond.false.2318

cond.true.2281:                                   ; preds = %cond.false.2277
  %348 = load i64, i64* %numargs, align 8
  %shr2282 = ashr i64 %348, 2
  %349 = load i64, i64* %numargs, align 8
  %shr2283 = ashr i64 %349, 2
  %add2284 = add nsw i64 0, %shr2283
  %mul2285 = mul nsw i64 0, %add2284
  %sub2286 = sub nsw i64 %mul2285, 1
  %cmp2287 = icmp slt i64 %sub2286, 0
  br i1 %cmp2287, label %cond.true.2289, label %cond.false.2308

cond.true.2289:                                   ; preds = %cond.true.2281
  %350 = load i64, i64* %numargs, align 8
  %shr2290 = ashr i64 %350, 2
  %add2291 = add nsw i64 0, %shr2290
  %mul2292 = mul nsw i64 0, %add2291
  %add2293 = add nsw i64 %mul2292, 0
  %neg2294 = xor i64 %add2293, -1
  %cmp2295 = icmp eq i64 %neg2294, -1
  %conv2296 = zext i1 %cmp2295 to i32
  %sub2297 = sub nsw i32 0, %conv2296
  %conv2298 = sext i32 %sub2297 to i64
  %351 = load i64, i64* %numargs, align 8
  %shr2299 = ashr i64 %351, 2
  %add2300 = add nsw i64 0, %shr2299
  %mul2301 = mul nsw i64 0, %add2300
  %add2302 = add nsw i64 %mul2301, 1
  %shl2303 = shl i64 %add2302, 62
  %sub2304 = sub nsw i64 %shl2303, 1
  %mul2305 = mul nsw i64 %sub2304, 2
  %add2306 = add nsw i64 %mul2305, 1
  %sub2307 = sub nsw i64 %conv2298, %add2306
  br label %cond.end.2313

cond.false.2308:                                  ; preds = %cond.true.2281
  %352 = load i64, i64* %numargs, align 8
  %shr2309 = ashr i64 %352, 2
  %add2310 = add nsw i64 0, %shr2309
  %mul2311 = mul nsw i64 0, %add2310
  %add2312 = add nsw i64 %mul2311, 0
  br label %cond.end.2313

cond.end.2313:                                    ; preds = %cond.false.2308, %cond.true.2289
  %cond2314 = phi i64 [ %sub2307, %cond.true.2289 ], [ %add2312, %cond.false.2308 ]
  %div2315 = sdiv i64 %cond2314, 8
  %cmp2316 = icmp slt i64 %shr2282, %div2315
  br i1 %cmp2316, label %cond.true.2362, label %lor.lhs.false.2345

cond.false.2318:                                  ; preds = %cond.false.2277
  %353 = load i64, i64* %numargs, align 8
  %shr2319 = ashr i64 %353, 2
  %add2320 = add nsw i64 0, %shr2319
  %mul2321 = mul nsw i64 0, %add2320
  %sub2322 = sub nsw i64 %mul2321, 1
  %cmp2323 = icmp slt i64 %sub2322, 0
  br i1 %cmp2323, label %cond.true.2325, label %cond.false.2334

cond.true.2325:                                   ; preds = %cond.false.2318
  %354 = load i64, i64* %numargs, align 8
  %shr2326 = ashr i64 %354, 2
  %add2327 = add nsw i64 0, %shr2326
  %mul2328 = mul nsw i64 0, %add2327
  %add2329 = add nsw i64 %mul2328, 1
  %shl2330 = shl i64 %add2329, 62
  %sub2331 = sub nsw i64 %shl2330, 1
  %mul2332 = mul nsw i64 %sub2331, 2
  %add2333 = add nsw i64 %mul2332, 1
  br label %cond.end.2339

cond.false.2334:                                  ; preds = %cond.false.2318
  %355 = load i64, i64* %numargs, align 8
  %shr2335 = ashr i64 %355, 2
  %add2336 = add nsw i64 0, %shr2335
  %mul2337 = mul nsw i64 0, %add2336
  %sub2338 = sub nsw i64 %mul2337, 1
  br label %cond.end.2339

cond.end.2339:                                    ; preds = %cond.false.2334, %cond.true.2325
  %cond2340 = phi i64 [ %add2333, %cond.true.2325 ], [ %sub2338, %cond.false.2334 ]
  %div2341 = sdiv i64 %cond2340, 8
  %356 = load i64, i64* %numargs, align 8
  %shr2342 = ashr i64 %356, 2
  %cmp2343 = icmp slt i64 %div2341, %shr2342
  br i1 %cmp2343, label %cond.true.2362, label %lor.lhs.false.2345

lor.lhs.false.2345:                               ; preds = %cond.end.2339, %cond.end.2313, %cond.true.2276, %cond.end.2269, %cond.true.2237, %cond.end.2231
  %357 = load i64, i64* %numargs, align 8
  %shr2346 = ashr i64 %357, 2
  %mul2347 = mul nsw i64 %shr2346, 8
  %mul2348 = mul nsw i64 0, %mul2347
  %sub2349 = sub nsw i64 %mul2348, 1
  %cmp2350 = icmp slt i64 %sub2349, 0
  br i1 %cmp2350, label %land.lhs.true.2352, label %lor.lhs.false.2357

land.lhs.true.2352:                               ; preds = %lor.lhs.false.2345
  %358 = load i64, i64* %numargs, align 8
  %shr2353 = ashr i64 %358, 2
  %mul2354 = mul nsw i64 %shr2353, 8
  %cmp2355 = icmp slt i64 %mul2354, -9223372036854775808
  br i1 %cmp2355, label %cond.true.2362, label %lor.lhs.false.2357

lor.lhs.false.2357:                               ; preds = %land.lhs.true.2352, %lor.lhs.false.2345
  %359 = load i64, i64* %numargs, align 8
  %shr2358 = ashr i64 %359, 2
  %mul2359 = mul nsw i64 %shr2358, 8
  %cmp2360 = icmp slt i64 9223372036854775807, %mul2359
  br i1 %cmp2360, label %cond.true.2362, label %cond.false.2377

cond.true.2362:                                   ; preds = %lor.lhs.false.2357, %land.lhs.true.2352, %cond.end.2339, %cond.end.2313, %cond.true.2276, %cond.end.2269, %cond.true.2237, %cond.end.2231, %land.lhs.true.2200
  %360 = load i64, i64* %numargs, align 8
  %shr2363 = ashr i64 %360, 2
  %mul2364 = mul i64 %shr2363, 8
  %cmp2365 = icmp ule i64 %mul2364, 9223372036854775807
  br i1 %cmp2365, label %cond.true.2367, label %cond.false.2370

cond.true.2367:                                   ; preds = %cond.true.2362
  %361 = load i64, i64* %numargs, align 8
  %shr2368 = ashr i64 %361, 2
  %mul2369 = mul i64 %shr2368, 8
  br label %cond.end.2375

cond.false.2370:                                  ; preds = %cond.true.2362
  %362 = load i64, i64* %numargs, align 8
  %shr2371 = ashr i64 %362, 2
  %mul2372 = mul i64 %shr2371, 8
  %sub2373 = sub i64 %mul2372, -9223372036854775808
  %add2374 = add nsw i64 %sub2373, -9223372036854775808
  br label %cond.end.2375

cond.end.2375:                                    ; preds = %cond.false.2370, %cond.true.2367
  %cond2376 = phi i64 [ %mul2369, %cond.true.2367 ], [ %add2374, %cond.false.2370 ]
  store i64 %cond2376, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2622, label %lor.lhs.false.2619

cond.false.2377:                                  ; preds = %lor.lhs.false.2357
  %363 = load i64, i64* %numargs, align 8
  %shr2378 = ashr i64 %363, 2
  %mul2379 = mul i64 %shr2378, 8
  %cmp2380 = icmp ule i64 %mul2379, 9223372036854775807
  br i1 %cmp2380, label %cond.true.2382, label %cond.false.2385

cond.true.2382:                                   ; preds = %cond.false.2377
  %364 = load i64, i64* %numargs, align 8
  %shr2383 = ashr i64 %364, 2
  %mul2384 = mul i64 %shr2383, 8
  br label %cond.end.2390

cond.false.2385:                                  ; preds = %cond.false.2377
  %365 = load i64, i64* %numargs, align 8
  %shr2386 = ashr i64 %365, 2
  %mul2387 = mul i64 %shr2386, 8
  %sub2388 = sub i64 %mul2387, -9223372036854775808
  %add2389 = add nsw i64 %sub2388, -9223372036854775808
  br label %cond.end.2390

cond.end.2390:                                    ; preds = %cond.false.2385, %cond.true.2382
  %cond2391 = phi i64 [ %mul2384, %cond.true.2382 ], [ %add2389, %cond.false.2385 ]
  store i64 %cond2391, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2622, label %lor.lhs.false.2619

cond.false.2392:                                  ; preds = %cond.false.2164
  %366 = load i64, i64* %numargs, align 8
  %shr2393 = ashr i64 %366, 2
  %add2394 = add nsw i64 0, %shr2393
  %mul2395 = mul nsw i64 0, %add2394
  %sub2396 = sub nsw i64 %mul2395, 1
  %cmp2397 = icmp slt i64 %sub2396, 0
  br i1 %cmp2397, label %cond.true.2399, label %cond.false.2418

cond.true.2399:                                   ; preds = %cond.false.2392
  %367 = load i64, i64* %numargs, align 8
  %shr2400 = ashr i64 %367, 2
  %add2401 = add nsw i64 0, %shr2400
  %mul2402 = mul nsw i64 0, %add2401
  %add2403 = add nsw i64 %mul2402, 0
  %neg2404 = xor i64 %add2403, -1
  %cmp2405 = icmp eq i64 %neg2404, -1
  %conv2406 = zext i1 %cmp2405 to i32
  %sub2407 = sub nsw i32 0, %conv2406
  %conv2408 = sext i32 %sub2407 to i64
  %368 = load i64, i64* %numargs, align 8
  %shr2409 = ashr i64 %368, 2
  %add2410 = add nsw i64 0, %shr2409
  %mul2411 = mul nsw i64 0, %add2410
  %add2412 = add nsw i64 %mul2411, 1
  %shl2413 = shl i64 %add2412, 62
  %sub2414 = sub nsw i64 %shl2413, 1
  %mul2415 = mul nsw i64 %sub2414, 2
  %add2416 = add nsw i64 %mul2415, 1
  %sub2417 = sub nsw i64 %conv2408, %add2416
  br label %cond.end.2423

cond.false.2418:                                  ; preds = %cond.false.2392
  %369 = load i64, i64* %numargs, align 8
  %shr2419 = ashr i64 %369, 2
  %add2420 = add nsw i64 0, %shr2419
  %mul2421 = mul nsw i64 0, %add2420
  %add2422 = add nsw i64 %mul2421, 0
  br label %cond.end.2423

cond.end.2423:                                    ; preds = %cond.false.2418, %cond.true.2399
  %cond2424 = phi i64 [ %sub2417, %cond.true.2399 ], [ %add2422, %cond.false.2418 ]
  %cmp2425 = icmp eq i64 %cond2424, 0
  br i1 %cmp2425, label %land.lhs.true.2427, label %lor.lhs.false.2431

land.lhs.true.2427:                               ; preds = %cond.end.2423
  %370 = load i64, i64* %numargs, align 8
  %shr2428 = ashr i64 %370, 2
  %cmp2429 = icmp slt i64 %shr2428, 0
  br i1 %cmp2429, label %cond.true.2589, label %lor.lhs.false.2431

lor.lhs.false.2431:                               ; preds = %land.lhs.true.2427, %cond.end.2423
  br i1 false, label %cond.true.2432, label %cond.false.2502

cond.true.2432:                                   ; preds = %lor.lhs.false.2431
  %371 = load i64, i64* %numargs, align 8
  %shr2433 = ashr i64 %371, 2
  %cmp2434 = icmp slt i64 %shr2433, 0
  br i1 %cmp2434, label %cond.true.2436, label %cond.false.2463

cond.true.2436:                                   ; preds = %cond.true.2432
  %372 = load i64, i64* %numargs, align 8
  %shr2437 = ashr i64 %372, 2
  %373 = load i64, i64* %numargs, align 8
  %shr2438 = ashr i64 %373, 2
  %add2439 = add nsw i64 0, %shr2438
  %mul2440 = mul nsw i64 0, %add2439
  %sub2441 = sub nsw i64 %mul2440, 1
  %cmp2442 = icmp slt i64 %sub2441, 0
  br i1 %cmp2442, label %cond.true.2444, label %cond.false.2453

cond.true.2444:                                   ; preds = %cond.true.2436
  %374 = load i64, i64* %numargs, align 8
  %shr2445 = ashr i64 %374, 2
  %add2446 = add nsw i64 0, %shr2445
  %mul2447 = mul nsw i64 0, %add2446
  %add2448 = add nsw i64 %mul2447, 1
  %shl2449 = shl i64 %add2448, 62
  %sub2450 = sub nsw i64 %shl2449, 1
  %mul2451 = mul nsw i64 %sub2450, 2
  %add2452 = add nsw i64 %mul2451, 1
  br label %cond.end.2458

cond.false.2453:                                  ; preds = %cond.true.2436
  %375 = load i64, i64* %numargs, align 8
  %shr2454 = ashr i64 %375, 2
  %add2455 = add nsw i64 0, %shr2454
  %mul2456 = mul nsw i64 0, %add2455
  %sub2457 = sub nsw i64 %mul2456, 1
  br label %cond.end.2458

cond.end.2458:                                    ; preds = %cond.false.2453, %cond.true.2444
  %cond2459 = phi i64 [ %add2452, %cond.true.2444 ], [ %sub2457, %cond.false.2453 ]
  %div2460 = sdiv i64 %cond2459, 8
  %cmp2461 = icmp slt i64 %shr2437, %div2460
  br i1 %cmp2461, label %cond.true.2589, label %lor.lhs.false.2572

cond.false.2463:                                  ; preds = %cond.true.2432
  br i1 false, label %cond.true.2464, label %cond.false.2465

cond.true.2464:                                   ; preds = %cond.false.2463
  br i1 false, label %cond.true.2589, label %lor.lhs.false.2572

cond.false.2465:                                  ; preds = %cond.false.2463
  %376 = load i64, i64* %numargs, align 8
  %shr2466 = ashr i64 %376, 2
  %add2467 = add nsw i64 0, %shr2466
  %mul2468 = mul nsw i64 0, %add2467
  %sub2469 = sub nsw i64 %mul2468, 1
  %cmp2470 = icmp slt i64 %sub2469, 0
  br i1 %cmp2470, label %cond.true.2472, label %cond.false.2491

cond.true.2472:                                   ; preds = %cond.false.2465
  %377 = load i64, i64* %numargs, align 8
  %shr2473 = ashr i64 %377, 2
  %add2474 = add nsw i64 0, %shr2473
  %mul2475 = mul nsw i64 0, %add2474
  %add2476 = add nsw i64 %mul2475, 0
  %neg2477 = xor i64 %add2476, -1
  %cmp2478 = icmp eq i64 %neg2477, -1
  %conv2479 = zext i1 %cmp2478 to i32
  %sub2480 = sub nsw i32 0, %conv2479
  %conv2481 = sext i32 %sub2480 to i64
  %378 = load i64, i64* %numargs, align 8
  %shr2482 = ashr i64 %378, 2
  %add2483 = add nsw i64 0, %shr2482
  %mul2484 = mul nsw i64 0, %add2483
  %add2485 = add nsw i64 %mul2484, 1
  %shl2486 = shl i64 %add2485, 62
  %sub2487 = sub nsw i64 %shl2486, 1
  %mul2488 = mul nsw i64 %sub2487, 2
  %add2489 = add nsw i64 %mul2488, 1
  %sub2490 = sub nsw i64 %conv2481, %add2489
  br label %cond.end.2496

cond.false.2491:                                  ; preds = %cond.false.2465
  %379 = load i64, i64* %numargs, align 8
  %shr2492 = ashr i64 %379, 2
  %add2493 = add nsw i64 0, %shr2492
  %mul2494 = mul nsw i64 0, %add2493
  %add2495 = add nsw i64 %mul2494, 0
  br label %cond.end.2496

cond.end.2496:                                    ; preds = %cond.false.2491, %cond.true.2472
  %cond2497 = phi i64 [ %sub2490, %cond.true.2472 ], [ %add2495, %cond.false.2491 ]
  %div2498 = sdiv i64 %cond2497, 8
  %380 = load i64, i64* %numargs, align 8
  %shr2499 = ashr i64 %380, 2
  %cmp2500 = icmp slt i64 %div2498, %shr2499
  br i1 %cmp2500, label %cond.true.2589, label %lor.lhs.false.2572

cond.false.2502:                                  ; preds = %lor.lhs.false.2431
  br i1 false, label %cond.true.2503, label %cond.false.2504

cond.true.2503:                                   ; preds = %cond.false.2502
  br i1 false, label %cond.true.2589, label %lor.lhs.false.2572

cond.false.2504:                                  ; preds = %cond.false.2502
  %381 = load i64, i64* %numargs, align 8
  %shr2505 = ashr i64 %381, 2
  %cmp2506 = icmp slt i64 %shr2505, 0
  br i1 %cmp2506, label %cond.true.2508, label %cond.false.2545

cond.true.2508:                                   ; preds = %cond.false.2504
  %382 = load i64, i64* %numargs, align 8
  %shr2509 = ashr i64 %382, 2
  %383 = load i64, i64* %numargs, align 8
  %shr2510 = ashr i64 %383, 2
  %add2511 = add nsw i64 0, %shr2510
  %mul2512 = mul nsw i64 0, %add2511
  %sub2513 = sub nsw i64 %mul2512, 1
  %cmp2514 = icmp slt i64 %sub2513, 0
  br i1 %cmp2514, label %cond.true.2516, label %cond.false.2535

cond.true.2516:                                   ; preds = %cond.true.2508
  %384 = load i64, i64* %numargs, align 8
  %shr2517 = ashr i64 %384, 2
  %add2518 = add nsw i64 0, %shr2517
  %mul2519 = mul nsw i64 0, %add2518
  %add2520 = add nsw i64 %mul2519, 0
  %neg2521 = xor i64 %add2520, -1
  %cmp2522 = icmp eq i64 %neg2521, -1
  %conv2523 = zext i1 %cmp2522 to i32
  %sub2524 = sub nsw i32 0, %conv2523
  %conv2525 = sext i32 %sub2524 to i64
  %385 = load i64, i64* %numargs, align 8
  %shr2526 = ashr i64 %385, 2
  %add2527 = add nsw i64 0, %shr2526
  %mul2528 = mul nsw i64 0, %add2527
  %add2529 = add nsw i64 %mul2528, 1
  %shl2530 = shl i64 %add2529, 62
  %sub2531 = sub nsw i64 %shl2530, 1
  %mul2532 = mul nsw i64 %sub2531, 2
  %add2533 = add nsw i64 %mul2532, 1
  %sub2534 = sub nsw i64 %conv2525, %add2533
  br label %cond.end.2540

cond.false.2535:                                  ; preds = %cond.true.2508
  %386 = load i64, i64* %numargs, align 8
  %shr2536 = ashr i64 %386, 2
  %add2537 = add nsw i64 0, %shr2536
  %mul2538 = mul nsw i64 0, %add2537
  %add2539 = add nsw i64 %mul2538, 0
  br label %cond.end.2540

cond.end.2540:                                    ; preds = %cond.false.2535, %cond.true.2516
  %cond2541 = phi i64 [ %sub2534, %cond.true.2516 ], [ %add2539, %cond.false.2535 ]
  %div2542 = sdiv i64 %cond2541, 8
  %cmp2543 = icmp slt i64 %shr2509, %div2542
  br i1 %cmp2543, label %cond.true.2589, label %lor.lhs.false.2572

cond.false.2545:                                  ; preds = %cond.false.2504
  %387 = load i64, i64* %numargs, align 8
  %shr2546 = ashr i64 %387, 2
  %add2547 = add nsw i64 0, %shr2546
  %mul2548 = mul nsw i64 0, %add2547
  %sub2549 = sub nsw i64 %mul2548, 1
  %cmp2550 = icmp slt i64 %sub2549, 0
  br i1 %cmp2550, label %cond.true.2552, label %cond.false.2561

cond.true.2552:                                   ; preds = %cond.false.2545
  %388 = load i64, i64* %numargs, align 8
  %shr2553 = ashr i64 %388, 2
  %add2554 = add nsw i64 0, %shr2553
  %mul2555 = mul nsw i64 0, %add2554
  %add2556 = add nsw i64 %mul2555, 1
  %shl2557 = shl i64 %add2556, 62
  %sub2558 = sub nsw i64 %shl2557, 1
  %mul2559 = mul nsw i64 %sub2558, 2
  %add2560 = add nsw i64 %mul2559, 1
  br label %cond.end.2566

cond.false.2561:                                  ; preds = %cond.false.2545
  %389 = load i64, i64* %numargs, align 8
  %shr2562 = ashr i64 %389, 2
  %add2563 = add nsw i64 0, %shr2562
  %mul2564 = mul nsw i64 0, %add2563
  %sub2565 = sub nsw i64 %mul2564, 1
  br label %cond.end.2566

cond.end.2566:                                    ; preds = %cond.false.2561, %cond.true.2552
  %cond2567 = phi i64 [ %add2560, %cond.true.2552 ], [ %sub2565, %cond.false.2561 ]
  %div2568 = sdiv i64 %cond2567, 8
  %390 = load i64, i64* %numargs, align 8
  %shr2569 = ashr i64 %390, 2
  %cmp2570 = icmp slt i64 %div2568, %shr2569
  br i1 %cmp2570, label %cond.true.2589, label %lor.lhs.false.2572

lor.lhs.false.2572:                               ; preds = %cond.end.2566, %cond.end.2540, %cond.true.2503, %cond.end.2496, %cond.true.2464, %cond.end.2458
  %391 = load i64, i64* %numargs, align 8
  %shr2573 = ashr i64 %391, 2
  %mul2574 = mul nsw i64 %shr2573, 8
  %mul2575 = mul nsw i64 0, %mul2574
  %sub2576 = sub nsw i64 %mul2575, 1
  %cmp2577 = icmp slt i64 %sub2576, 0
  br i1 %cmp2577, label %land.lhs.true.2579, label %lor.lhs.false.2584

land.lhs.true.2579:                               ; preds = %lor.lhs.false.2572
  %392 = load i64, i64* %numargs, align 8
  %shr2580 = ashr i64 %392, 2
  %mul2581 = mul nsw i64 %shr2580, 8
  %cmp2582 = icmp slt i64 %mul2581, -9223372036854775808
  br i1 %cmp2582, label %cond.true.2589, label %lor.lhs.false.2584

lor.lhs.false.2584:                               ; preds = %land.lhs.true.2579, %lor.lhs.false.2572
  %393 = load i64, i64* %numargs, align 8
  %shr2585 = ashr i64 %393, 2
  %mul2586 = mul nsw i64 %shr2585, 8
  %cmp2587 = icmp slt i64 9223372036854775807, %mul2586
  br i1 %cmp2587, label %cond.true.2589, label %cond.false.2604

cond.true.2589:                                   ; preds = %lor.lhs.false.2584, %land.lhs.true.2579, %cond.end.2566, %cond.end.2540, %cond.true.2503, %cond.end.2496, %cond.true.2464, %cond.end.2458, %land.lhs.true.2427
  %394 = load i64, i64* %numargs, align 8
  %shr2590 = ashr i64 %394, 2
  %mul2591 = mul i64 %shr2590, 8
  %cmp2592 = icmp ule i64 %mul2591, 9223372036854775807
  br i1 %cmp2592, label %cond.true.2594, label %cond.false.2597

cond.true.2594:                                   ; preds = %cond.true.2589
  %395 = load i64, i64* %numargs, align 8
  %shr2595 = ashr i64 %395, 2
  %mul2596 = mul i64 %shr2595, 8
  br label %cond.end.2602

cond.false.2597:                                  ; preds = %cond.true.2589
  %396 = load i64, i64* %numargs, align 8
  %shr2598 = ashr i64 %396, 2
  %mul2599 = mul i64 %shr2598, 8
  %sub2600 = sub i64 %mul2599, -9223372036854775808
  %add2601 = add nsw i64 %sub2600, -9223372036854775808
  br label %cond.end.2602

cond.end.2602:                                    ; preds = %cond.false.2597, %cond.true.2594
  %cond2603 = phi i64 [ %mul2596, %cond.true.2594 ], [ %add2601, %cond.false.2597 ]
  store i64 %cond2603, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2622, label %lor.lhs.false.2619

cond.false.2604:                                  ; preds = %lor.lhs.false.2584
  %397 = load i64, i64* %numargs, align 8
  %shr2605 = ashr i64 %397, 2
  %mul2606 = mul i64 %shr2605, 8
  %cmp2607 = icmp ule i64 %mul2606, 9223372036854775807
  br i1 %cmp2607, label %cond.true.2609, label %cond.false.2612

cond.true.2609:                                   ; preds = %cond.false.2604
  %398 = load i64, i64* %numargs, align 8
  %shr2610 = ashr i64 %398, 2
  %mul2611 = mul i64 %shr2610, 8
  br label %cond.end.2617

cond.false.2612:                                  ; preds = %cond.false.2604
  %399 = load i64, i64* %numargs, align 8
  %shr2613 = ashr i64 %399, 2
  %mul2614 = mul i64 %shr2613, 8
  %sub2615 = sub i64 %mul2614, -9223372036854775808
  %add2616 = add nsw i64 %sub2615, -9223372036854775808
  br label %cond.end.2617

cond.end.2617:                                    ; preds = %cond.false.2612, %cond.true.2609
  %cond2618 = phi i64 [ %mul2611, %cond.true.2609 ], [ %add2616, %cond.false.2612 ]
  store i64 %cond2618, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2622, label %lor.lhs.false.2619

lor.lhs.false.2619:                               ; preds = %cond.end.2617, %cond.end.2602, %cond.end.2390, %cond.end.2375, %cond.end.2162, %cond.end.2147, %cond.end.1935, %cond.end.1920, %cond.end.1705, %cond.end.1686, %cond.end.1470, %cond.end.1451, %cond.end.1208, %cond.end.1182, %cond.end.959, %cond.end.933, %cond.end.655, %cond.end.629, %cond.end.406, %cond.end.380
  %400 = load i64, i64* %alloca_nbytes, align 8
  %cmp2620 = icmp ult i64 -1, %400
  br i1 %cmp2620, label %if.then.2622, label %if.else.2623

if.then.2622:                                     ; preds = %lor.lhs.false.2619, %cond.end.2617, %cond.end.2602, %cond.end.2390, %cond.end.2375, %cond.end.2162, %cond.end.2147, %cond.end.1935, %cond.end.1920, %cond.end.1705, %cond.end.1686, %cond.end.1470, %cond.end.1451, %cond.end.1208, %cond.end.1182, %cond.end.959, %cond.end.933, %cond.end.655, %cond.end.629, %cond.end.406, %cond.end.380
  call void @memory_full(i64 -1) #8
  unreachable

if.else.2623:                                     ; preds = %lor.lhs.false.2619
  %401 = load i64, i64* %alloca_nbytes, align 8
  %402 = load i64, i64* %sa_avail, align 8
  %cmp2624 = icmp sle i64 %401, %402
  br i1 %cmp2624, label %if.then.2626, label %if.else.2628

if.then.2626:                                     ; preds = %if.else.2623
  %403 = load i64, i64* %alloca_nbytes, align 8
  %404 = load i64, i64* %sa_avail, align 8
  %sub2627 = sub nsw i64 %404, %403
  store i64 %sub2627, i64* %sa_avail, align 8
  %405 = load i64, i64* %alloca_nbytes, align 8
  %406 = alloca i8, i64 %405
  %407 = bitcast i8* %406 to i64*
  store i64* %407, i64** %vals, align 8
  br label %if.end.2632

if.else.2628:                                     ; preds = %if.else.2623
  %408 = load i64, i64* %alloca_nbytes, align 8
  %call2629 = call noalias i8* @xmalloc(i64 %408)
  %409 = bitcast i8* %call2629 to i64*
  store i64* %409, i64** %vals, align 8
  %410 = load i64*, i64** %vals, align 8
  %411 = load i64, i64* %numargs, align 8
  %shr2630 = ashr i64 %411, 2
  %call2631 = call i64 @make_save_memory(i64* %410, i64 %shr2630)
  store i64 %call2631, i64* %arg_, align 8
  store i8 1, i8* %sa_must_free, align 1
  %412 = load i64, i64* %arg_, align 8
  call void @record_unwind_protect(void (i64)* @free_save_value, i64 %412)
  br label %if.end.2632

if.end.2632:                                      ; preds = %if.else.2628, %if.then.2626
  br label %if.end.2633

if.end.2633:                                      ; preds = %if.end.2632
  br label %do.end.2634

do.end.2634:                                      ; preds = %if.end.2633
  br label %while.cond

while.cond:                                       ; preds = %while.body, %do.end.2634
  %413 = load i64, i64* %args_left, align 8
  %call2635 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp2636 = icmp eq i64 %413, %call2635
  %lnot = xor i1 %cmp2636, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %414 = load i64, i64* %args_left, align 8
  %call2638 = call i64 @Fcar(i64 %414)
  %call2639 = call i64 @eval_sub(i64 %call2638)
  %415 = load i64, i64* %argnum, align 8
  %inc2640 = add nsw i64 %415, 1
  store i64 %inc2640, i64* %argnum, align 8
  %416 = load i64*, i64** %vals, align 8
  %arrayidx = getelementptr inbounds i64, i64* %416, i64 %415
  store i64 %call2639, i64* %arrayidx, align 8
  %417 = load i64, i64* %args_left, align 8
  %call2641 = call i64 @Fcdr(i64 %417)
  store i64 %call2641, i64* %args_left, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %418 = load %union.specbinding*, %union.specbinding** @specpdl, align 8
  %419 = load i64, i64* %count, align 8
  %add.ptr2642 = getelementptr inbounds %union.specbinding, %union.specbinding* %418, i64 %419
  %420 = load i64*, i64** %vals, align 8
  %421 = load i64, i64* %numargs, align 8
  %shr2643 = ashr i64 %421, 2
  call void @set_backtrace_args(%union.specbinding* %add.ptr2642, i64* %420, i64 %shr2643)
  %422 = load i64, i64* %fun, align 8
  %call2644 = call %struct.Lisp_Subr* @XSUBR(i64 %422)
  %function2645 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2644, i32 0, i32 1
  %aMANY = bitcast %union.anon.6* %function2645 to i64 (i64, i64*)**
  %423 = load i64 (i64, i64*)*, i64 (i64, i64*)** %aMANY, align 8
  %424 = load i64, i64* %numargs, align 8
  %shr2646 = ashr i64 %424, 2
  %425 = load i64*, i64** %vals, align 8
  %call2647 = call i64 %423(i64 %shr2646, i64* %425)
  store i64 %call2647, i64* %val, align 8
  %426 = load i64, i64* @lisp_eval_depth, align 8
  %dec = add nsw i64 %426, -1
  store i64 %dec, i64* @lisp_eval_depth, align 8
  %427 = load %union.specbinding*, %union.specbinding** @specpdl, align 8
  %428 = load i64, i64* %count, align 8
  %add.ptr2648 = getelementptr inbounds %union.specbinding, %union.specbinding* %427, i64 %428
  %call2649 = call zeroext i1 @backtrace_debug_on_exit(%union.specbinding* %add.ptr2648)
  br i1 %call2649, label %if.then.2650, label %if.end.2654

if.then.2650:                                     ; preds = %while.end
  %call2651 = call i64 @builtin_lisp_symbol(i32 387)
  %429 = load i64, i64* %val, align 8
  %call2652 = call i64 @list2(i64 %call2651, i64 %429)
  %call2653 = call i64 @call_debugger(i64 %call2652)
  store i64 %call2653, i64* %val, align 8
  br label %if.end.2654

if.end.2654:                                      ; preds = %if.then.2650, %while.end
  br label %do.body.2655

do.body.2655:                                     ; preds = %if.end.2654
  %430 = load i8, i8* %sa_must_free, align 1
  %tobool2656 = trunc i8 %430 to i1
  br i1 %tobool2656, label %if.then.2657, label %if.end.2660

if.then.2657:                                     ; preds = %do.body.2655
  store i8 0, i8* %sa_must_free, align 1
  %431 = load i64, i64* %sa_count, align 8
  %call2658 = call i64 @builtin_lisp_symbol(i32 0)
  %call2659 = call i64 @unbind_to(i64 %431, i64 %call2658)
  br label %if.end.2660

if.end.2660:                                      ; preds = %if.then.2657, %do.body.2655
  br label %do.end.2661

do.end.2661:                                      ; preds = %if.end.2660
  %432 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %incdec.ptr = getelementptr inbounds %union.specbinding, %union.specbinding* %432, i32 -1
  store %union.specbinding* %incdec.ptr, %union.specbinding** @specpdl_ptr, align 8
  %433 = load i64, i64* %val, align 8
  store i64 %433, i64* %retval
  br label %return

if.else.2662:                                     ; preds = %if.else.102
  %434 = load i64, i64* %fun, align 8
  %call2663 = call %struct.Lisp_Subr* @XSUBR(i64 %434)
  %max_args2664 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2663, i32 0, i32 3
  %435 = load i16, i16* %max_args2664, align 2
  %conv2665 = sext i16 %435 to i32
  store i32 %conv2665, i32* %maxargs, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.else.2662
  %436 = load i32, i32* %i, align 4
  %437 = load i32, i32* %maxargs, align 4
  %cmp2666 = icmp slt i32 %436, %437
  br i1 %cmp2666, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %438 = load i64, i64* %args_left, align 8
  %call2668 = call i64 @Fcar(i64 %438)
  %call2669 = call i64 @eval_sub(i64 %call2668)
  %439 = load i32, i32* %i, align 4
  %idxprom = sext i32 %439 to i64
  %arrayidx2670 = getelementptr inbounds [8 x i64], [8 x i64]* %argvals, i32 0, i64 %idxprom
  store i64 %call2669, i64* %arrayidx2670, align 8
  %440 = load i64, i64* %args_left, align 8
  %call2671 = call i64 @Fcdr(i64 %440)
  store i64 %call2671, i64* %args_left, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %441 = load i32, i32* %i, align 4
  %inc2672 = add nsw i32 %441, 1
  store i32 %inc2672, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %442 = load %union.specbinding*, %union.specbinding** @specpdl, align 8
  %443 = load i64, i64* %count, align 8
  %add.ptr2673 = getelementptr inbounds %union.specbinding, %union.specbinding* %442, i64 %443
  %arraydecay = getelementptr inbounds [8 x i64], [8 x i64]* %argvals, i32 0, i32 0
  %444 = load i64, i64* %numargs, align 8
  %shr2674 = ashr i64 %444, 2
  call void @set_backtrace_args(%union.specbinding* %add.ptr2673, i64* %arraydecay, i64 %shr2674)
  %445 = load i32, i32* %i, align 4
  switch i32 %445, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb.2678
    i32 2, label %sw.bb.2683
    i32 3, label %sw.bb.2689
    i32 4, label %sw.bb.2696
    i32 5, label %sw.bb.2704
    i32 6, label %sw.bb.2713
    i32 7, label %sw.bb.2723
    i32 8, label %sw.bb.2734
  ]

sw.bb:                                            ; preds = %for.end
  %446 = load i64, i64* %fun, align 8
  %call2675 = call %struct.Lisp_Subr* @XSUBR(i64 %446)
  %function2676 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2675, i32 0, i32 1
  %a0 = bitcast %union.anon.6* %function2676 to i64 ()**
  %447 = load i64 ()*, i64 ()** %a0, align 8
  %call2677 = call i64 %447()
  store i64 %call2677, i64* %val, align 8
  br label %sw.epilog

sw.bb.2678:                                       ; preds = %for.end
  %448 = load i64, i64* %fun, align 8
  %call2679 = call %struct.Lisp_Subr* @XSUBR(i64 %448)
  %function2680 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2679, i32 0, i32 1
  %a1 = bitcast %union.anon.6* %function2680 to i64 (i64)**
  %449 = load i64 (i64)*, i64 (i64)** %a1, align 8
  %arrayidx2681 = getelementptr inbounds [8 x i64], [8 x i64]* %argvals, i32 0, i64 0
  %450 = load i64, i64* %arrayidx2681, align 8
  %call2682 = call i64 %449(i64 %450)
  store i64 %call2682, i64* %val, align 8
  br label %sw.epilog

sw.bb.2683:                                       ; preds = %for.end
  %451 = load i64, i64* %fun, align 8
  %call2684 = call %struct.Lisp_Subr* @XSUBR(i64 %451)
  %function2685 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2684, i32 0, i32 1
  %a2 = bitcast %union.anon.6* %function2685 to i64 (i64, i64)**
  %452 = load i64 (i64, i64)*, i64 (i64, i64)** %a2, align 8
  %arrayidx2686 = getelementptr inbounds [8 x i64], [8 x i64]* %argvals, i32 0, i64 0
  %453 = load i64, i64* %arrayidx2686, align 8
  %arrayidx2687 = getelementptr inbounds [8 x i64], [8 x i64]* %argvals, i32 0, i64 1
  %454 = load i64, i64* %arrayidx2687, align 8
  %call2688 = call i64 %452(i64 %453, i64 %454)
  store i64 %call2688, i64* %val, align 8
  br label %sw.epilog

sw.bb.2689:                                       ; preds = %for.end
  %455 = load i64, i64* %fun, align 8
  %call2690 = call %struct.Lisp_Subr* @XSUBR(i64 %455)
  %function2691 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2690, i32 0, i32 1
  %a3 = bitcast %union.anon.6* %function2691 to i64 (i64, i64, i64)**
  %456 = load i64 (i64, i64, i64)*, i64 (i64, i64, i64)** %a3, align 8
  %arrayidx2692 = getelementptr inbounds [8 x i64], [8 x i64]* %argvals, i32 0, i64 0
  %457 = load i64, i64* %arrayidx2692, align 8
  %arrayidx2693 = getelementptr inbounds [8 x i64], [8 x i64]* %argvals, i32 0, i64 1
  %458 = load i64, i64* %arrayidx2693, align 8
  %arrayidx2694 = getelementptr inbounds [8 x i64], [8 x i64]* %argvals, i32 0, i64 2
  %459 = load i64, i64* %arrayidx2694, align 8
  %call2695 = call i64 %456(i64 %457, i64 %458, i64 %459)
  store i64 %call2695, i64* %val, align 8
  br label %sw.epilog

sw.bb.2696:                                       ; preds = %for.end
  %460 = load i64, i64* %fun, align 8
  %call2697 = call %struct.Lisp_Subr* @XSUBR(i64 %460)
  %function2698 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2697, i32 0, i32 1
  %a4 = bitcast %union.anon.6* %function2698 to i64 (i64, i64, i64, i64)**
  %461 = load i64 (i64, i64, i64, i64)*, i64 (i64, i64, i64, i64)** %a4, align 8
  %arrayidx2699 = getelementptr inbounds [8 x i64], [8 x i64]* %argvals, i32 0, i64 0
  %462 = load i64, i64* %arrayidx2699, align 8
  %arrayidx2700 = getelementptr inbounds [8 x i64], [8 x i64]* %argvals, i32 0, i64 1
  %463 = load i64, i64* %arrayidx2700, align 8
  %arrayidx2701 = getelementptr inbounds [8 x i64], [8 x i64]* %argvals, i32 0, i64 2
  %464 = load i64, i64* %arrayidx2701, align 8
  %arrayidx2702 = getelementptr inbounds [8 x i64], [8 x i64]* %argvals, i32 0, i64 3
  %465 = load i64, i64* %arrayidx2702, align 8
  %call2703 = call i64 %461(i64 %462, i64 %463, i64 %464, i64 %465)
  store i64 %call2703, i64* %val, align 8
  br label %sw.epilog

sw.bb.2704:                                       ; preds = %for.end
  %466 = load i64, i64* %fun, align 8
  %call2705 = call %struct.Lisp_Subr* @XSUBR(i64 %466)
  %function2706 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2705, i32 0, i32 1
  %a5 = bitcast %union.anon.6* %function2706 to i64 (i64, i64, i64, i64, i64)**
  %467 = load i64 (i64, i64, i64, i64, i64)*, i64 (i64, i64, i64, i64, i64)** %a5, align 8
  %arrayidx2707 = getelementptr inbounds [8 x i64], [8 x i64]* %argvals, i32 0, i64 0
  %468 = load i64, i64* %arrayidx2707, align 8
  %arrayidx2708 = getelementptr inbounds [8 x i64], [8 x i64]* %argvals, i32 0, i64 1
  %469 = load i64, i64* %arrayidx2708, align 8
  %arrayidx2709 = getelementptr inbounds [8 x i64], [8 x i64]* %argvals, i32 0, i64 2
  %470 = load i64, i64* %arrayidx2709, align 8
  %arrayidx2710 = getelementptr inbounds [8 x i64], [8 x i64]* %argvals, i32 0, i64 3
  %471 = load i64, i64* %arrayidx2710, align 8
  %arrayidx2711 = getelementptr inbounds [8 x i64], [8 x i64]* %argvals, i32 0, i64 4
  %472 = load i64, i64* %arrayidx2711, align 8
  %call2712 = call i64 %467(i64 %468, i64 %469, i64 %470, i64 %471, i64 %472)
  store i64 %call2712, i64* %val, align 8
  br label %sw.epilog

sw.bb.2713:                                       ; preds = %for.end
  %473 = load i64, i64* %fun, align 8
  %call2714 = call %struct.Lisp_Subr* @XSUBR(i64 %473)
  %function2715 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2714, i32 0, i32 1
  %a6 = bitcast %union.anon.6* %function2715 to i64 (i64, i64, i64, i64, i64, i64)**
  %474 = load i64 (i64, i64, i64, i64, i64, i64)*, i64 (i64, i64, i64, i64, i64, i64)** %a6, align 8
  %arrayidx2716 = getelementptr inbounds [8 x i64], [8 x i64]* %argvals, i32 0, i64 0
  %475 = load i64, i64* %arrayidx2716, align 8
  %arrayidx2717 = getelementptr inbounds [8 x i64], [8 x i64]* %argvals, i32 0, i64 1
  %476 = load i64, i64* %arrayidx2717, align 8
  %arrayidx2718 = getelementptr inbounds [8 x i64], [8 x i64]* %argvals, i32 0, i64 2
  %477 = load i64, i64* %arrayidx2718, align 8
  %arrayidx2719 = getelementptr inbounds [8 x i64], [8 x i64]* %argvals, i32 0, i64 3
  %478 = load i64, i64* %arrayidx2719, align 8
  %arrayidx2720 = getelementptr inbounds [8 x i64], [8 x i64]* %argvals, i32 0, i64 4
  %479 = load i64, i64* %arrayidx2720, align 8
  %arrayidx2721 = getelementptr inbounds [8 x i64], [8 x i64]* %argvals, i32 0, i64 5
  %480 = load i64, i64* %arrayidx2721, align 8
  %call2722 = call i64 %474(i64 %475, i64 %476, i64 %477, i64 %478, i64 %479, i64 %480)
  store i64 %call2722, i64* %val, align 8
  br label %sw.epilog

sw.bb.2723:                                       ; preds = %for.end
  %481 = load i64, i64* %fun, align 8
  %call2724 = call %struct.Lisp_Subr* @XSUBR(i64 %481)
  %function2725 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2724, i32 0, i32 1
  %a7 = bitcast %union.anon.6* %function2725 to i64 (i64, i64, i64, i64, i64, i64, i64)**
  %482 = load i64 (i64, i64, i64, i64, i64, i64, i64)*, i64 (i64, i64, i64, i64, i64, i64, i64)** %a7, align 8
  %arrayidx2726 = getelementptr inbounds [8 x i64], [8 x i64]* %argvals, i32 0, i64 0
  %483 = load i64, i64* %arrayidx2726, align 8
  %arrayidx2727 = getelementptr inbounds [8 x i64], [8 x i64]* %argvals, i32 0, i64 1
  %484 = load i64, i64* %arrayidx2727, align 8
  %arrayidx2728 = getelementptr inbounds [8 x i64], [8 x i64]* %argvals, i32 0, i64 2
  %485 = load i64, i64* %arrayidx2728, align 8
  %arrayidx2729 = getelementptr inbounds [8 x i64], [8 x i64]* %argvals, i32 0, i64 3
  %486 = load i64, i64* %arrayidx2729, align 8
  %arrayidx2730 = getelementptr inbounds [8 x i64], [8 x i64]* %argvals, i32 0, i64 4
  %487 = load i64, i64* %arrayidx2730, align 8
  %arrayidx2731 = getelementptr inbounds [8 x i64], [8 x i64]* %argvals, i32 0, i64 5
  %488 = load i64, i64* %arrayidx2731, align 8
  %arrayidx2732 = getelementptr inbounds [8 x i64], [8 x i64]* %argvals, i32 0, i64 6
  %489 = load i64, i64* %arrayidx2732, align 8
  %call2733 = call i64 %482(i64 %483, i64 %484, i64 %485, i64 %486, i64 %487, i64 %488, i64 %489)
  store i64 %call2733, i64* %val, align 8
  br label %sw.epilog

sw.bb.2734:                                       ; preds = %for.end
  %490 = load i64, i64* %fun, align 8
  %call2735 = call %struct.Lisp_Subr* @XSUBR(i64 %490)
  %function2736 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2735, i32 0, i32 1
  %a8 = bitcast %union.anon.6* %function2736 to i64 (i64, i64, i64, i64, i64, i64, i64, i64)**
  %491 = load i64 (i64, i64, i64, i64, i64, i64, i64, i64)*, i64 (i64, i64, i64, i64, i64, i64, i64, i64)** %a8, align 8
  %arrayidx2737 = getelementptr inbounds [8 x i64], [8 x i64]* %argvals, i32 0, i64 0
  %492 = load i64, i64* %arrayidx2737, align 8
  %arrayidx2738 = getelementptr inbounds [8 x i64], [8 x i64]* %argvals, i32 0, i64 1
  %493 = load i64, i64* %arrayidx2738, align 8
  %arrayidx2739 = getelementptr inbounds [8 x i64], [8 x i64]* %argvals, i32 0, i64 2
  %494 = load i64, i64* %arrayidx2739, align 8
  %arrayidx2740 = getelementptr inbounds [8 x i64], [8 x i64]* %argvals, i32 0, i64 3
  %495 = load i64, i64* %arrayidx2740, align 8
  %arrayidx2741 = getelementptr inbounds [8 x i64], [8 x i64]* %argvals, i32 0, i64 4
  %496 = load i64, i64* %arrayidx2741, align 8
  %arrayidx2742 = getelementptr inbounds [8 x i64], [8 x i64]* %argvals, i32 0, i64 5
  %497 = load i64, i64* %arrayidx2742, align 8
  %arrayidx2743 = getelementptr inbounds [8 x i64], [8 x i64]* %argvals, i32 0, i64 6
  %498 = load i64, i64* %arrayidx2743, align 8
  %arrayidx2744 = getelementptr inbounds [8 x i64], [8 x i64]* %argvals, i32 0, i64 7
  %499 = load i64, i64* %arrayidx2744, align 8
  %call2745 = call i64 %491(i64 %492, i64 %493, i64 %494, i64 %495, i64 %496, i64 %497, i64 %498, i64 %499)
  store i64 %call2745, i64* %val, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %for.end
  call void @emacs_abort() #8
  unreachable

sw.epilog:                                        ; preds = %sw.bb.2734, %sw.bb.2723, %sw.bb.2713, %sw.bb.2704, %sw.bb.2696, %sw.bb.2689, %sw.bb.2683, %sw.bb.2678, %sw.bb
  br label %if.end.2746

if.end.2746:                                      ; preds = %sw.epilog
  br label %if.end.2747

if.end.2747:                                      ; preds = %if.end.2746, %if.then.98
  br label %if.end.2748

if.end.2748:                                      ; preds = %if.end.2747
  br label %if.end.2817

if.else.2749:                                     ; preds = %if.end.71
  %500 = load i64, i64* %fun, align 8
  %call2750 = call zeroext i1 @COMPILEDP(i64 %500)
  br i1 %call2750, label %if.then.2751, label %if.else.2753

if.then.2751:                                     ; preds = %if.else.2749
  %501 = load i64, i64* %fun, align 8
  %502 = load i64, i64* %original_args, align 8
  %503 = load i64, i64* %count, align 8
  %call2752 = call i64 @apply_lambda(i64 %501, i64 %502, i64 %503)
  store i64 %call2752, i64* %retval
  br label %return

if.else.2753:                                     ; preds = %if.else.2749
  %504 = load i64, i64* %fun, align 8
  %call2754 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp2755 = icmp eq i64 %504, %call2754
  br i1 %cmp2755, label %if.then.2757, label %if.end.2759

if.then.2757:                                     ; preds = %if.else.2753
  %call2758 = call i64 @builtin_lisp_symbol(i32 1006)
  %505 = load i64, i64* %original_fun, align 8
  call void @xsignal1(i64 %call2758, i64 %505) #8
  unreachable

if.end.2759:                                      ; preds = %if.else.2753
  %506 = load i64, i64* %fun, align 8
  %and2760 = and i64 %506, 7
  %conv2761 = trunc i64 %and2760 to i32
  %cmp2762 = icmp eq i32 %conv2761, 3
  br i1 %cmp2762, label %if.end.2766, label %if.then.2764

if.then.2764:                                     ; preds = %if.end.2759
  %call2765 = call i64 @builtin_lisp_symbol(i32 570)
  %507 = load i64, i64* %original_fun, align 8
  call void @xsignal1(i64 %call2765, i64 %507) #8
  unreachable

if.end.2766:                                      ; preds = %if.end.2759
  %508 = load i64, i64* %fun, align 8
  %sub2767 = sub nsw i64 %508, 3
  %509 = inttoptr i64 %sub2767 to i8*
  %510 = bitcast i8* %509 to %struct.Lisp_Cons*
  %car2768 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %510, i32 0, i32 0
  %511 = load i64, i64* %car2768, align 8
  store i64 %511, i64* %funcar, align 8
  %512 = load i64, i64* %funcar, align 8
  %and2769 = and i64 %512, 7
  %conv2770 = trunc i64 %and2769 to i32
  %cmp2771 = icmp eq i32 %conv2770, 0
  br i1 %cmp2771, label %if.end.2775, label %if.then.2773

if.then.2773:                                     ; preds = %if.end.2766
  %call2774 = call i64 @builtin_lisp_symbol(i32 570)
  %513 = load i64, i64* %original_fun, align 8
  call void @xsignal1(i64 %call2774, i64 %513) #8
  unreachable

if.end.2775:                                      ; preds = %if.end.2766
  %514 = load i64, i64* %funcar, align 8
  %call2776 = call i64 @builtin_lisp_symbol(i32 191)
  %cmp2777 = icmp eq i64 %514, %call2776
  br i1 %cmp2777, label %if.then.2779, label %if.end.2782

if.then.2779:                                     ; preds = %if.end.2775
  %515 = load i64, i64* %fun, align 8
  %516 = load i64, i64* %original_fun, align 8
  %call2780 = call i64 @builtin_lisp_symbol(i32 0)
  %call2781 = call i64 @Fautoload_do_load(i64 %515, i64 %516, i64 %call2780)
  br label %retry

if.end.2782:                                      ; preds = %if.end.2775
  %517 = load i64, i64* %funcar, align 8
  %call2783 = call i64 @builtin_lisp_symbol(i32 636)
  %cmp2784 = icmp eq i64 %517, %call2783
  br i1 %cmp2784, label %if.then.2786, label %if.else.2803

if.then.2786:                                     ; preds = %if.end.2782
  %call2787 = call i64 @SPECPDL_INDEX()
  store i64 %call2787, i64* %count1, align 8
  %call2788 = call i64 @builtin_lisp_symbol(i32 614)
  %518 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 147), align 8
  %call2789 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp2790 = icmp eq i64 %518, %call2789
  br i1 %cmp2790, label %cond.true.2792, label %cond.false.2794

cond.true.2792:                                   ; preds = %if.then.2786
  %call2793 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end.2796

cond.false.2794:                                  ; preds = %if.then.2786
  %call2795 = call i64 @builtin_lisp_symbol(i32 901)
  br label %cond.end.2796

cond.end.2796:                                    ; preds = %cond.false.2794, %cond.true.2792
  %cond2797 = phi i64 [ %call2793, %cond.true.2792 ], [ %call2795, %cond.false.2794 ]
  call void @specbind(i64 %call2788, i64 %cond2797)
  %519 = load i64, i64* %fun, align 8
  %call2798 = call i64 @Fcdr(i64 %519)
  %520 = load i64, i64* %original_args, align 8
  %call2799 = call i64 @apply1(i64 %call2798, i64 %520)
  store i64 %call2799, i64* %exp, align 8
  %521 = load i64, i64* %count1, align 8
  %call2800 = call i64 @builtin_lisp_symbol(i32 0)
  %call2801 = call i64 @unbind_to(i64 %521, i64 %call2800)
  %522 = load i64, i64* %exp, align 8
  %call2802 = call i64 @eval_sub(i64 %522)
  store i64 %call2802, i64* %val, align 8
  br label %if.end.2815

if.else.2803:                                     ; preds = %if.end.2782
  %523 = load i64, i64* %funcar, align 8
  %call2804 = call i64 @builtin_lisp_symbol(i32 598)
  %cmp2805 = icmp eq i64 %523, %call2804
  br i1 %cmp2805, label %if.then.2811, label %lor.lhs.false.2807

lor.lhs.false.2807:                               ; preds = %if.else.2803
  %524 = load i64, i64* %funcar, align 8
  %call2808 = call i64 @builtin_lisp_symbol(i32 271)
  %cmp2809 = icmp eq i64 %524, %call2808
  br i1 %cmp2809, label %if.then.2811, label %if.else.2813

if.then.2811:                                     ; preds = %lor.lhs.false.2807, %if.else.2803
  %525 = load i64, i64* %fun, align 8
  %526 = load i64, i64* %original_args, align 8
  %527 = load i64, i64* %count, align 8
  %call2812 = call i64 @apply_lambda(i64 %525, i64 %526, i64 %527)
  store i64 %call2812, i64* %retval
  br label %return

if.else.2813:                                     ; preds = %lor.lhs.false.2807
  %call2814 = call i64 @builtin_lisp_symbol(i32 570)
  %528 = load i64, i64* %original_fun, align 8
  call void @xsignal1(i64 %call2814, i64 %528) #8
  unreachable

if.end.2815:                                      ; preds = %cond.end.2796
  br label %if.end.2816

if.end.2816:                                      ; preds = %if.end.2815
  br label %if.end.2817

if.end.2817:                                      ; preds = %if.end.2816, %if.end.2748
  %529 = load i64, i64* @lisp_eval_depth, align 8
  %dec2818 = add nsw i64 %529, -1
  store i64 %dec2818, i64* @lisp_eval_depth, align 8
  %530 = load %union.specbinding*, %union.specbinding** @specpdl, align 8
  %531 = load i64, i64* %count, align 8
  %add.ptr2819 = getelementptr inbounds %union.specbinding, %union.specbinding* %530, i64 %531
  %call2820 = call zeroext i1 @backtrace_debug_on_exit(%union.specbinding* %add.ptr2819)
  br i1 %call2820, label %if.then.2821, label %if.end.2825

if.then.2821:                                     ; preds = %if.end.2817
  %call2822 = call i64 @builtin_lisp_symbol(i32 387)
  %532 = load i64, i64* %val, align 8
  %call2823 = call i64 @list2(i64 %call2822, i64 %532)
  %call2824 = call i64 @call_debugger(i64 %call2823)
  store i64 %call2824, i64* %val, align 8
  br label %if.end.2825

if.end.2825:                                      ; preds = %if.then.2821, %if.end.2817
  %533 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %incdec.ptr2826 = getelementptr inbounds %union.specbinding, %union.specbinding* %533, i32 -1
  store %union.specbinding* %incdec.ptr2826, %union.specbinding** @specpdl_ptr, align 8
  %534 = load i64, i64* %val, align 8
  store i64 %534, i64* %retval
  br label %return

return:                                           ; preds = %if.end.2825, %if.then.2811, %if.then.2751, %do.end.2661, %if.then.16, %if.else, %if.then.10
  %535 = load i64, i64* %retval
  ret i64 %535
}

; Function Attrs: nounwind uwtable
define i64 @Fand(i64 %args) #0 {
entry:
  %args.addr = alloca i64, align 8
  %val = alloca i64, align 8
  store i64 %args, i64* %args.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 901)
  store i64 %call, i64* %val, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %0 = load i64, i64* %args.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = load i64, i64* %args.addr, align 8
  %sub = sub nsw i64 %1, 3
  %2 = inttoptr i64 %sub to i8*
  %3 = bitcast i8* %2 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %3, i32 0, i32 0
  %4 = load i64, i64* %car, align 8
  %call2 = call i64 @eval_sub(i64 %4)
  store i64 %call2, i64* %val, align 8
  %5 = load i64, i64* %val, align 8
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp4 = icmp eq i64 %5, %call3
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  br label %while.end

if.end:                                           ; preds = %while.body
  %6 = load i64, i64* %args.addr, align 8
  %sub6 = sub nsw i64 %6, 3
  %7 = inttoptr i64 %sub6 to i8*
  %8 = bitcast i8* %7 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %8, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %9 = load i64, i64* %cdr, align 8
  store i64 %9, i64* %args.addr, align 8
  br label %while.cond

while.end:                                        ; preds = %if.then, %while.cond
  %10 = load i64, i64* %val, align 8
  ret i64 %10
}

; Function Attrs: nounwind uwtable
define i64 @Fif(i64 %args) #0 {
entry:
  %retval = alloca i64, align 8
  %args.addr = alloca i64, align 8
  %cond = alloca i64, align 8
  store i64 %args, i64* %args.addr, align 8
  %0 = load i64, i64* %args.addr, align 8
  %sub = sub nsw i64 %0, 3
  %1 = inttoptr i64 %sub to i8*
  %2 = bitcast i8* %1 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %2, i32 0, i32 0
  %3 = load i64, i64* %car, align 8
  %call = call i64 @eval_sub(i64 %3)
  store i64 %call, i64* %cond, align 8
  %4 = load i64, i64* %cond, align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %4, %call1
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i64, i64* %args.addr, align 8
  %sub2 = sub nsw i64 %5, 3
  %6 = inttoptr i64 %sub2 to i8*
  %7 = bitcast i8* %6 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %7, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %8 = load i64, i64* %cdr, align 8
  %call3 = call i64 @Fcar(i64 %8)
  %call4 = call i64 @eval_sub(i64 %call3)
  store i64 %call4, i64* %retval
  br label %return

if.end:                                           ; preds = %entry
  %9 = load i64, i64* %args.addr, align 8
  %sub5 = sub nsw i64 %9, 3
  %10 = inttoptr i64 %sub5 to i8*
  %11 = bitcast i8* %10 to %struct.Lisp_Cons*
  %u6 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %11, i32 0, i32 1
  %cdr7 = bitcast %union.anon* %u6 to i64*
  %12 = load i64, i64* %cdr7, align 8
  %sub8 = sub nsw i64 %12, 3
  %13 = inttoptr i64 %sub8 to i8*
  %14 = bitcast i8* %13 to %struct.Lisp_Cons*
  %u9 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %14, i32 0, i32 1
  %cdr10 = bitcast %union.anon* %u9 to i64*
  %15 = load i64, i64* %cdr10, align 8
  %call11 = call i64 @Fprogn(i64 %15)
  store i64 %call11, i64* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %16 = load i64, i64* %retval
  ret i64 %16
}

declare i64 @Fcar(i64) #1

; Function Attrs: nounwind uwtable
define i64 @Fprogn(i64 %body) #0 {
entry:
  %body.addr = alloca i64, align 8
  %val = alloca i64, align 8
  store i64 %body, i64* %body.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call, i64* %val, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load i64, i64* %body.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = load i64, i64* %body.addr, align 8
  %sub = sub nsw i64 %1, 3
  %2 = inttoptr i64 %sub to i8*
  %3 = bitcast i8* %2 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %3, i32 0, i32 0
  %4 = load i64, i64* %car, align 8
  %call2 = call i64 @eval_sub(i64 %4)
  store i64 %call2, i64* %val, align 8
  %5 = load i64, i64* %body.addr, align 8
  %sub3 = sub nsw i64 %5, 3
  %6 = inttoptr i64 %sub3 to i8*
  %7 = bitcast i8* %6 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %7, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %8 = load i64, i64* %cdr, align 8
  store i64 %8, i64* %body.addr, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %9 = load i64, i64* %val, align 8
  ret i64 %9
}

; Function Attrs: nounwind uwtable
define i64 @Fcond(i64 %args) #0 {
entry:
  %args.addr = alloca i64, align 8
  %val = alloca i64, align 8
  %clause = alloca i64, align 8
  store i64 %args, i64* %args.addr, align 8
  %0 = load i64, i64* %args.addr, align 8
  store i64 %0, i64* %val, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end.15, %entry
  %1 = load i64, i64* %args.addr, align 8
  %and = and i64 %1, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load i64, i64* %args.addr, align 8
  %sub = sub nsw i64 %2, 3
  %3 = inttoptr i64 %sub to i8*
  %4 = bitcast i8* %3 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %4, i32 0, i32 0
  %5 = load i64, i64* %car, align 8
  store i64 %5, i64* %clause, align 8
  %6 = load i64, i64* %clause, align 8
  %call = call i64 @Fcar(i64 %6)
  %call2 = call i64 @eval_sub(i64 %call)
  store i64 %call2, i64* %val, align 8
  %7 = load i64, i64* %val, align 8
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp4 = icmp eq i64 %7, %call3
  br i1 %cmp4, label %if.end.15, label %if.then

if.then:                                          ; preds = %while.body
  %8 = load i64, i64* %clause, align 8
  %sub6 = sub nsw i64 %8, 3
  %9 = inttoptr i64 %sub6 to i8*
  %10 = bitcast i8* %9 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %10, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %11 = load i64, i64* %cdr, align 8
  %call7 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp8 = icmp eq i64 %11, %call7
  br i1 %cmp8, label %if.end, label %if.then.10

if.then.10:                                       ; preds = %if.then
  %12 = load i64, i64* %clause, align 8
  %sub11 = sub nsw i64 %12, 3
  %13 = inttoptr i64 %sub11 to i8*
  %14 = bitcast i8* %13 to %struct.Lisp_Cons*
  %u12 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %14, i32 0, i32 1
  %cdr13 = bitcast %union.anon* %u12 to i64*
  %15 = load i64, i64* %cdr13, align 8
  %call14 = call i64 @Fprogn(i64 %15)
  store i64 %call14, i64* %val, align 8
  br label %if.end

if.end:                                           ; preds = %if.then.10, %if.then
  br label %while.end

if.end.15:                                        ; preds = %while.body
  %16 = load i64, i64* %args.addr, align 8
  %sub16 = sub nsw i64 %16, 3
  %17 = inttoptr i64 %sub16 to i8*
  %18 = bitcast i8* %17 to %struct.Lisp_Cons*
  %u17 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %18, i32 0, i32 1
  %cdr18 = bitcast %union.anon* %u17 to i64*
  %19 = load i64, i64* %cdr18, align 8
  store i64 %19, i64* %args.addr, align 8
  br label %while.cond

while.end:                                        ; preds = %if.end, %while.cond
  %20 = load i64, i64* %val, align 8
  ret i64 %20
}

; Function Attrs: nounwind uwtable
define void @unwind_body(i64 %body) #0 {
entry:
  %body.addr = alloca i64, align 8
  store i64 %body, i64* %body.addr, align 8
  %0 = load i64, i64* %body.addr, align 8
  %call = call i64 @Fprogn(i64 %0)
  ret void
}

; Function Attrs: nounwind uwtable
define i64 @Fprog1(i64 %args) #0 {
entry:
  %args.addr = alloca i64, align 8
  %val = alloca i64, align 8
  %args_left = alloca i64, align 8
  store i64 %args, i64* %args.addr, align 8
  %0 = load i64, i64* %args.addr, align 8
  store i64 %0, i64* %args_left, align 8
  %1 = load i64, i64* %args.addr, align 8
  store i64 %1, i64* %val, align 8
  %2 = load i64, i64* %args_left, align 8
  %sub = sub nsw i64 %2, 3
  %3 = inttoptr i64 %sub to i8*
  %4 = bitcast i8* %3 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %4, i32 0, i32 0
  %5 = load i64, i64* %car, align 8
  %call = call i64 @eval_sub(i64 %5)
  store i64 %call, i64* %val, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %6 = load i64, i64* %args_left, align 8
  %sub1 = sub nsw i64 %6, 3
  %7 = inttoptr i64 %sub1 to i8*
  %8 = bitcast i8* %7 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %8, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %9 = load i64, i64* %cdr, align 8
  store i64 %9, i64* %args_left, align 8
  %and = and i64 %9, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %10 = load i64, i64* %args_left, align 8
  %sub3 = sub nsw i64 %10, 3
  %11 = inttoptr i64 %sub3 to i8*
  %12 = bitcast i8* %11 to %struct.Lisp_Cons*
  %car4 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %12, i32 0, i32 0
  %13 = load i64, i64* %car4, align 8
  %call5 = call i64 @eval_sub(i64 %13)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %14 = load i64, i64* %val, align 8
  ret i64 %14
}

; Function Attrs: nounwind uwtable
define i64 @Fprog2(i64 %args) #0 {
entry:
  %args.addr = alloca i64, align 8
  store i64 %args, i64* %args.addr, align 8
  %0 = load i64, i64* %args.addr, align 8
  %sub = sub nsw i64 %0, 3
  %1 = inttoptr i64 %sub to i8*
  %2 = bitcast i8* %1 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %2, i32 0, i32 0
  %3 = load i64, i64* %car, align 8
  %call = call i64 @eval_sub(i64 %3)
  %4 = load i64, i64* %args.addr, align 8
  %sub1 = sub nsw i64 %4, 3
  %5 = inttoptr i64 %sub1 to i8*
  %6 = bitcast i8* %5 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %6, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %7 = load i64, i64* %cdr, align 8
  %call2 = call i64 @Fprog1(i64 %7)
  ret i64 %call2
}

; Function Attrs: nounwind uwtable
define i64 @Fsetq(i64 %args) #0 {
entry:
  %args.addr = alloca i64, align 8
  %val = alloca i64, align 8
  %sym = alloca i64, align 8
  %lex_binding = alloca i64, align 8
  %args_left = alloca i64, align 8
  %numargs = alloca i64, align 8
  store i64 %args, i64* %args.addr, align 8
  %0 = load i64, i64* %args.addr, align 8
  store i64 %0, i64* %val, align 8
  %1 = load i64, i64* %args.addr, align 8
  %and = and i64 %1, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %if.then, label %if.end.32

if.then:                                          ; preds = %entry
  %2 = load i64, i64* %args.addr, align 8
  store i64 %2, i64* %args_left, align 8
  %3 = load i64, i64* %args.addr, align 8
  %call = call i64 @Flength(i64 %3)
  store i64 %call, i64* %numargs, align 8
  %4 = load i64, i64* %numargs, align 8
  %shr = ashr i64 %4, 2
  %and2 = and i64 %shr, 1
  %tobool = icmp ne i64 %and2, 0
  br i1 %tobool, label %if.then.3, label %if.end

if.then.3:                                        ; preds = %if.then
  %call4 = call i64 @builtin_lisp_symbol(i32 1043)
  %call5 = call i64 @builtin_lisp_symbol(i32 854)
  %5 = load i64, i64* %numargs, align 8
  call void @xsignal2(i64 %call4, i64 %call5, i64 %5) #8
  unreachable

if.end:                                           ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.end
  %6 = load i64, i64* %args_left, align 8
  %sub = sub nsw i64 %6, 3
  %7 = inttoptr i64 %sub to i8*
  %8 = bitcast i8* %7 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %8, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %9 = load i64, i64* %cdr, align 8
  %call6 = call i64 @Fcar(i64 %9)
  %call7 = call i64 @eval_sub(i64 %call6)
  store i64 %call7, i64* %val, align 8
  %10 = load i64, i64* %args_left, align 8
  %sub8 = sub nsw i64 %10, 3
  %11 = inttoptr i64 %sub8 to i8*
  %12 = bitcast i8* %11 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %12, i32 0, i32 0
  %13 = load i64, i64* %car, align 8
  store i64 %13, i64* %sym, align 8
  %14 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 147), align 8
  %call9 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp10 = icmp eq i64 %14, %call9
  br i1 %cmp10, label %if.else, label %land.lhs.true

land.lhs.true:                                    ; preds = %do.body
  %15 = load i64, i64* %sym, align 8
  %and12 = and i64 %15, 7
  %conv13 = trunc i64 %and12 to i32
  %cmp14 = icmp eq i32 %conv13, 0
  br i1 %cmp14, label %land.lhs.true.16, label %if.else

land.lhs.true.16:                                 ; preds = %land.lhs.true
  %16 = load i64, i64* %sym, align 8
  %17 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 147), align 8
  %call17 = call i64 @Fassq(i64 %16, i64 %17)
  store i64 %call17, i64* %lex_binding, align 8
  %call18 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp19 = icmp eq i64 %call17, %call18
  br i1 %cmp19, label %if.else, label %if.then.21

if.then.21:                                       ; preds = %land.lhs.true.16
  %18 = load i64, i64* %lex_binding, align 8
  %19 = load i64, i64* %val, align 8
  call void @XSETCDR(i64 %18, i64 %19)
  br label %if.end.23

if.else:                                          ; preds = %land.lhs.true.16, %land.lhs.true, %do.body
  %20 = load i64, i64* %sym, align 8
  %21 = load i64, i64* %val, align 8
  %call22 = call i64 @Fset(i64 %20, i64 %21)
  br label %if.end.23

if.end.23:                                        ; preds = %if.else, %if.then.21
  %22 = load i64, i64* %args_left, align 8
  %sub24 = sub nsw i64 %22, 3
  %23 = inttoptr i64 %sub24 to i8*
  %24 = bitcast i8* %23 to %struct.Lisp_Cons*
  %u25 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %24, i32 0, i32 1
  %cdr26 = bitcast %union.anon* %u25 to i64*
  %25 = load i64, i64* %cdr26, align 8
  %call27 = call i64 @Fcdr(i64 %25)
  store i64 %call27, i64* %args_left, align 8
  br label %do.cond

do.cond:                                          ; preds = %if.end.23
  %26 = load i64, i64* %args_left, align 8
  %and28 = and i64 %26, 7
  %conv29 = trunc i64 %and28 to i32
  %cmp30 = icmp eq i32 %conv29, 3
  br i1 %cmp30, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  br label %if.end.32

if.end.32:                                        ; preds = %do.end, %entry
  %27 = load i64, i64* %val, align 8
  ret i64 %27
}

declare i64 @Flength(i64) #1

; Function Attrs: noreturn nounwind uwtable
define void @xsignal2(i64 %error_symbol, i64 %arg1, i64 %arg2) #3 {
entry:
  %error_symbol.addr = alloca i64, align 8
  %arg1.addr = alloca i64, align 8
  %arg2.addr = alloca i64, align 8
  store i64 %error_symbol, i64* %error_symbol.addr, align 8
  store i64 %arg1, i64* %arg1.addr, align 8
  store i64 %arg2, i64* %arg2.addr, align 8
  %0 = load i64, i64* %error_symbol.addr, align 8
  %1 = load i64, i64* %arg1.addr, align 8
  %2 = load i64, i64* %arg2.addr, align 8
  %call = call i64 @list2(i64 %1, i64 %2)
  call void @xsignal(i64 %0, i64 %call) #8
  unreachable

return:                                           ; No predecessors!
  ret void
}

declare i64 @Fassq(i64, i64) #1

declare void @XSETCDR(i64, i64) #1

declare i64 @Fset(i64, i64) #1

declare i64 @Fcdr(i64) #1

; Function Attrs: nounwind uwtable
define i64 @Fquote(i64 %args) #0 {
entry:
  %args.addr = alloca i64, align 8
  store i64 %args, i64* %args.addr, align 8
  %0 = load i64, i64* %args.addr, align 8
  %sub = sub nsw i64 %0, 3
  %1 = inttoptr i64 %sub to i8*
  %2 = bitcast i8* %1 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %2, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %3 = load i64, i64* %cdr, align 8
  %and = and i64 %3, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i64 @builtin_lisp_symbol(i32 1043)
  %call2 = call i64 @builtin_lisp_symbol(i32 783)
  %4 = load i64, i64* %args.addr, align 8
  %call3 = call i64 @Flength(i64 %4)
  call void @xsignal2(i64 %call, i64 %call2, i64 %call3) #8
  unreachable

if.end:                                           ; preds = %entry
  %5 = load i64, i64* %args.addr, align 8
  %sub4 = sub nsw i64 %5, 3
  %6 = inttoptr i64 %sub4 to i8*
  %7 = bitcast i8* %6 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %7, i32 0, i32 0
  %8 = load i64, i64* %car, align 8
  ret i64 %8
}

; Function Attrs: nounwind uwtable
define i64 @Ffunction(i64 %args) #0 {
entry:
  %retval = alloca i64, align 8
  %args.addr = alloca i64, align 8
  %quoted = alloca i64, align 8
  %cdr19 = alloca i64, align 8
  %tmp = alloca i64, align 8
  %docstring = alloca i64, align 8
  store i64 %args, i64* %args.addr, align 8
  %0 = load i64, i64* %args.addr, align 8
  %sub = sub nsw i64 %0, 3
  %1 = inttoptr i64 %sub to i8*
  %2 = bitcast i8* %1 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %2, i32 0, i32 0
  %3 = load i64, i64* %car, align 8
  store i64 %3, i64* %quoted, align 8
  %4 = load i64, i64* %args.addr, align 8
  %sub1 = sub nsw i64 %4, 3
  %5 = inttoptr i64 %sub1 to i8*
  %6 = bitcast i8* %5 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %6, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %7 = load i64, i64* %cdr, align 8
  %and = and i64 %7, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i64 @builtin_lisp_symbol(i32 1043)
  %call3 = call i64 @builtin_lisp_symbol(i32 476)
  %8 = load i64, i64* %args.addr, align 8
  %call4 = call i64 @Flength(i64 %8)
  call void @xsignal2(i64 %call, i64 %call3, i64 %call4) #8
  unreachable

if.end:                                           ; preds = %entry
  %9 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 147), align 8
  %call5 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp6 = icmp eq i64 %9, %call5
  br i1 %cmp6, label %if.else, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %10 = load i64, i64* %quoted, align 8
  %and8 = and i64 %10, 7
  %conv9 = trunc i64 %and8 to i32
  %cmp10 = icmp eq i32 %conv9, 3
  br i1 %cmp10, label %land.lhs.true.12, label %if.else

land.lhs.true.12:                                 ; preds = %land.lhs.true
  %11 = load i64, i64* %quoted, align 8
  %sub13 = sub nsw i64 %11, 3
  %12 = inttoptr i64 %sub13 to i8*
  %13 = bitcast i8* %12 to %struct.Lisp_Cons*
  %car14 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %13, i32 0, i32 0
  %14 = load i64, i64* %car14, align 8
  %call15 = call i64 @builtin_lisp_symbol(i32 598)
  %cmp16 = icmp eq i64 %14, %call15
  br i1 %cmp16, label %if.then.18, label %if.else

if.then.18:                                       ; preds = %land.lhs.true.12
  %15 = load i64, i64* %quoted, align 8
  %sub20 = sub nsw i64 %15, 3
  %16 = inttoptr i64 %sub20 to i8*
  %17 = bitcast i8* %16 to %struct.Lisp_Cons*
  %u21 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %17, i32 0, i32 1
  %cdr22 = bitcast %union.anon* %u21 to i64*
  %18 = load i64, i64* %cdr22, align 8
  store i64 %18, i64* %cdr19, align 8
  %19 = load i64, i64* %cdr19, align 8
  store i64 %19, i64* %tmp, align 8
  %20 = load i64, i64* %tmp, align 8
  %and23 = and i64 %20, 7
  %conv24 = trunc i64 %and23 to i32
  %cmp25 = icmp eq i32 %conv24, 3
  br i1 %cmp25, label %land.lhs.true.27, label %if.end.65

land.lhs.true.27:                                 ; preds = %if.then.18
  %21 = load i64, i64* %tmp, align 8
  %sub28 = sub nsw i64 %21, 3
  %22 = inttoptr i64 %sub28 to i8*
  %23 = bitcast i8* %22 to %struct.Lisp_Cons*
  %u29 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %23, i32 0, i32 1
  %cdr30 = bitcast %union.anon* %u29 to i64*
  %24 = load i64, i64* %cdr30, align 8
  store i64 %24, i64* %tmp, align 8
  %25 = load i64, i64* %tmp, align 8
  %and31 = and i64 %25, 7
  %conv32 = trunc i64 %and31 to i32
  %cmp33 = icmp eq i32 %conv32, 3
  br i1 %cmp33, label %land.lhs.true.35, label %if.end.65

land.lhs.true.35:                                 ; preds = %land.lhs.true.27
  %26 = load i64, i64* %tmp, align 8
  %sub36 = sub nsw i64 %26, 3
  %27 = inttoptr i64 %sub36 to i8*
  %28 = bitcast i8* %27 to %struct.Lisp_Cons*
  %car37 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %28, i32 0, i32 0
  %29 = load i64, i64* %car37, align 8
  store i64 %29, i64* %tmp, align 8
  %30 = load i64, i64* %tmp, align 8
  %and38 = and i64 %30, 7
  %conv39 = trunc i64 %and38 to i32
  %cmp40 = icmp eq i32 %conv39, 3
  br i1 %cmp40, label %land.lhs.true.42, label %if.end.65

land.lhs.true.42:                                 ; preds = %land.lhs.true.35
  %call43 = call i64 @builtin_lisp_symbol(i32 34)
  %31 = load i64, i64* %tmp, align 8
  %sub44 = sub nsw i64 %31, 3
  %32 = inttoptr i64 %sub44 to i8*
  %33 = bitcast i8* %32 to %struct.Lisp_Cons*
  %car45 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %33, i32 0, i32 0
  %34 = load i64, i64* %car45, align 8
  %cmp46 = icmp eq i64 %call43, %34
  br i1 %cmp46, label %if.then.48, label %if.end.65

if.then.48:                                       ; preds = %land.lhs.true.42
  %35 = load i64, i64* %tmp, align 8
  %sub50 = sub nsw i64 %35, 3
  %36 = inttoptr i64 %sub50 to i8*
  %37 = bitcast i8* %36 to %struct.Lisp_Cons*
  %u51 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %37, i32 0, i32 1
  %cdr52 = bitcast %union.anon* %u51 to i64*
  %38 = load i64, i64* %cdr52, align 8
  %call53 = call i64 @Fcar(i64 %38)
  %call54 = call i64 @eval_sub(i64 %call53)
  store i64 %call54, i64* %docstring, align 8
  %39 = load i64, i64* %docstring, align 8
  call void @CHECK_STRING(i64 %39)
  %40 = load i64, i64* %cdr19, align 8
  %sub55 = sub nsw i64 %40, 3
  %41 = inttoptr i64 %sub55 to i8*
  %42 = bitcast i8* %41 to %struct.Lisp_Cons*
  %car56 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %42, i32 0, i32 0
  %43 = load i64, i64* %car56, align 8
  %44 = load i64, i64* %docstring, align 8
  %45 = load i64, i64* %cdr19, align 8
  %sub57 = sub nsw i64 %45, 3
  %46 = inttoptr i64 %sub57 to i8*
  %47 = bitcast i8* %46 to %struct.Lisp_Cons*
  %u58 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %47, i32 0, i32 1
  %cdr59 = bitcast %union.anon* %u58 to i64*
  %48 = load i64, i64* %cdr59, align 8
  %sub60 = sub nsw i64 %48, 3
  %49 = inttoptr i64 %sub60 to i8*
  %50 = bitcast i8* %49 to %struct.Lisp_Cons*
  %u61 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %50, i32 0, i32 1
  %cdr62 = bitcast %union.anon* %u61 to i64*
  %51 = load i64, i64* %cdr62, align 8
  %call63 = call i64 @Fcons(i64 %44, i64 %51)
  %call64 = call i64 @Fcons(i64 %43, i64 %call63)
  store i64 %call64, i64* %cdr19, align 8
  br label %if.end.65

if.end.65:                                        ; preds = %if.then.48, %land.lhs.true.42, %land.lhs.true.35, %land.lhs.true.27, %if.then.18
  %call66 = call i64 @builtin_lisp_symbol(i32 271)
  %52 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 147), align 8
  %53 = load i64, i64* %cdr19, align 8
  %call67 = call i64 @Fcons(i64 %52, i64 %53)
  %call68 = call i64 @Fcons(i64 %call66, i64 %call67)
  store i64 %call68, i64* %retval
  br label %return

if.else:                                          ; preds = %land.lhs.true.12, %land.lhs.true, %if.end
  %54 = load i64, i64* %quoted, align 8
  store i64 %54, i64* %retval
  br label %return

return:                                           ; preds = %if.else, %if.end.65
  %55 = load i64, i64* %retval
  ret i64 %55
}

declare void @CHECK_STRING(i64) #1

; Function Attrs: nounwind uwtable
define i64 @Fdefvaralias(i64 %new_alias, i64 %base_variable, i64 %docstring) #0 {
entry:
  %new_alias.addr = alloca i64, align 8
  %base_variable.addr = alloca i64, align 8
  %docstring.addr = alloca i64, align 8
  %sym = alloca %struct.Lisp_Symbol*, align 8
  %p = alloca %union.specbinding*, align 8
  store i64 %new_alias, i64* %new_alias.addr, align 8
  store i64 %base_variable, i64* %base_variable.addr, align 8
  store i64 %docstring, i64* %docstring.addr, align 8
  %0 = load i64, i64* %new_alias.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = call i64 @builtin_lisp_symbol(i32 897)
  %1 = load i64, i64* %new_alias.addr, align 8
  %2 = call i64 @wrong_type_argument(i64 %call, i64 %1) #8
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %3, %cond.true
  %4 = load i64, i64* %base_variable.addr, align 8
  %and2 = and i64 %4, 7
  %conv3 = trunc i64 %and2 to i32
  %cmp4 = icmp eq i32 %conv3, 0
  br i1 %cmp4, label %cond.true.6, label %cond.false.7

cond.true.6:                                      ; preds = %cond.end
  br label %cond.end.9

cond.false.7:                                     ; preds = %cond.end
  %call8 = call i64 @builtin_lisp_symbol(i32 897)
  %5 = load i64, i64* %base_variable.addr, align 8
  %6 = call i64 @wrong_type_argument(i64 %call8, i64 %5) #8
  unreachable
                                                  ; No predecessors!
  br label %cond.end.9

cond.end.9:                                       ; preds = %7, %cond.true.6
  %8 = load i64, i64* %new_alias.addr, align 8
  %sub = sub nsw i64 %8, 0
  %add.ptr = getelementptr inbounds i8, i8* bitcast ([1074 x %struct.Lisp_Symbol]* @lispsym to i8*), i64 %sub
  %9 = bitcast i8* %add.ptr to %struct.Lisp_Symbol*
  store %struct.Lisp_Symbol* %9, %struct.Lisp_Symbol** %sym, align 8
  %10 = load %struct.Lisp_Symbol*, %struct.Lisp_Symbol** %sym, align 8
  %11 = bitcast %struct.Lisp_Symbol* %10 to i16*
  %bf.load = load i16, i16* %11, align 8
  %bf.lshr = lshr i16 %bf.load, 4
  %bf.clear = and i16 %bf.lshr, 3
  %bf.cast = zext i16 %bf.clear to i32
  %tobool = icmp ne i32 %bf.cast, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end.9
  call void (i8*, ...) @error(i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.1, i32 0, i32 0)) #8
  unreachable

if.end:                                           ; preds = %cond.end.9
  %12 = load %struct.Lisp_Symbol*, %struct.Lisp_Symbol** %sym, align 8
  %13 = bitcast %struct.Lisp_Symbol* %12 to i16*
  %bf.load10 = load i16, i16* %13, align 8
  %bf.lshr11 = lshr i16 %bf.load10, 1
  %bf.clear12 = and i16 %bf.lshr11, 7
  %bf.cast13 = zext i16 %bf.clear12 to i32
  switch i32 %bf.cast13, label %sw.default [
    i32 3, label %sw.bb
    i32 2, label %sw.bb.14
    i32 4, label %sw.bb.15
    i32 1, label %sw.bb.15
  ]

sw.bb:                                            ; preds = %if.end
  call void (i8*, ...) @error(i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.2, i32 0, i32 0)) #8
  unreachable

sw.bb.14:                                         ; preds = %if.end
  call void (i8*, ...) @error(i8* getelementptr inbounds ([53 x i8], [53 x i8]* @.str.3, i32 0, i32 0)) #8
  unreachable

sw.bb.15:                                         ; preds = %if.end, %if.end
  br label %sw.epilog

sw.default:                                       ; preds = %if.end
  call void @emacs_abort() #8
  unreachable

sw.epilog:                                        ; preds = %sw.bb.15
  %14 = load i64, i64* %base_variable.addr, align 8
  %call16 = call i64 @Fboundp(i64 %14)
  %call17 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp18 = icmp eq i64 %call16, %call17
  br i1 %cmp18, label %if.then.20, label %if.end.23

if.then.20:                                       ; preds = %sw.epilog
  %15 = load i64, i64* %base_variable.addr, align 8
  %16 = load i64, i64* %new_alias.addr, align 8
  %call21 = call i64 @find_symbol_value(i64 %16)
  %call22 = call i64 @builtin_lisp_symbol(i32 0)
  call void @set_internal(i64 %15, i64 %call21, i64 %call22, i1 zeroext true)
  br label %if.end.23

if.end.23:                                        ; preds = %if.then.20, %sw.epilog
  %17 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  store %union.specbinding* %17, %union.specbinding** %p, align 8
  br label %for.cond

for.cond:                                         ; preds = %if.end.34, %if.end.23
  %18 = load %union.specbinding*, %union.specbinding** %p, align 8
  %19 = load %union.specbinding*, %union.specbinding** @specpdl, align 8
  %cmp24 = icmp ugt %union.specbinding* %18, %19
  br i1 %cmp24, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %20 = load %union.specbinding*, %union.specbinding** %p, align 8
  %incdec.ptr = getelementptr inbounds %union.specbinding, %union.specbinding* %20, i32 -1
  store %union.specbinding* %incdec.ptr, %union.specbinding** %p, align 8
  %21 = bitcast %union.specbinding* %incdec.ptr to i8*
  %bf.load26 = load i8, i8* %21, align 8
  %bf.cast27 = zext i8 %bf.load26 to i32
  %cmp28 = icmp sge i32 %bf.cast27, 5
  br i1 %cmp28, label %land.lhs.true, label %if.end.34

land.lhs.true:                                    ; preds = %for.body
  %22 = load i64, i64* %new_alias.addr, align 8
  %23 = load %union.specbinding*, %union.specbinding** %p, align 8
  %call30 = call i64 @specpdl_symbol(%union.specbinding* %23)
  %cmp31 = icmp eq i64 %22, %call30
  br i1 %cmp31, label %if.then.33, label %if.end.34

if.then.33:                                       ; preds = %land.lhs.true
  call void (i8*, ...) @error(i8* getelementptr inbounds ([53 x i8], [53 x i8]* @.str.4, i32 0, i32 0)) #8
  unreachable

if.end.34:                                        ; preds = %land.lhs.true, %for.body
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %24 = load %struct.Lisp_Symbol*, %struct.Lisp_Symbol** %sym, align 8
  %25 = bitcast %struct.Lisp_Symbol* %24 to i16*
  %bf.load35 = load i16, i16* %25, align 8
  %bf.clear36 = and i16 %bf.load35, -257
  %bf.set = or i16 %bf.clear36, 256
  store i16 %bf.set, i16* %25, align 8
  %26 = load i64, i64* %base_variable.addr, align 8
  %sub37 = sub nsw i64 %26, 0
  %add.ptr38 = getelementptr inbounds i8, i8* bitcast ([1074 x %struct.Lisp_Symbol]* @lispsym to i8*), i64 %sub37
  %27 = bitcast i8* %add.ptr38 to %struct.Lisp_Symbol*
  %28 = bitcast %struct.Lisp_Symbol* %27 to i16*
  %bf.load39 = load i16, i16* %28, align 8
  %bf.clear40 = and i16 %bf.load39, -257
  %bf.set41 = or i16 %bf.clear40, 256
  store i16 %bf.set41, i16* %28, align 8
  %29 = load %struct.Lisp_Symbol*, %struct.Lisp_Symbol** %sym, align 8
  %30 = bitcast %struct.Lisp_Symbol* %29 to i16*
  %bf.load42 = load i16, i16* %30, align 8
  %bf.clear43 = and i16 %bf.load42, -15
  %bf.set44 = or i16 %bf.clear43, 2
  store i16 %bf.set44, i16* %30, align 8
  %31 = load %struct.Lisp_Symbol*, %struct.Lisp_Symbol** %sym, align 8
  %32 = load i64, i64* %base_variable.addr, align 8
  %sub45 = sub nsw i64 %32, 0
  %add.ptr46 = getelementptr inbounds i8, i8* bitcast ([1074 x %struct.Lisp_Symbol]* @lispsym to i8*), i64 %sub45
  %33 = bitcast i8* %add.ptr46 to %struct.Lisp_Symbol*
  call void @SET_SYMBOL_ALIAS(%struct.Lisp_Symbol* %31, %struct.Lisp_Symbol* %33)
  %34 = load i64, i64* %base_variable.addr, align 8
  %sub47 = sub nsw i64 %34, 0
  %add.ptr48 = getelementptr inbounds i8, i8* bitcast ([1074 x %struct.Lisp_Symbol]* @lispsym to i8*), i64 %sub47
  %35 = bitcast i8* %add.ptr48 to %struct.Lisp_Symbol*
  %36 = bitcast %struct.Lisp_Symbol* %35 to i16*
  %bf.load49 = load i16, i16* %36, align 8
  %bf.lshr50 = lshr i16 %bf.load49, 4
  %bf.clear51 = and i16 %bf.lshr50, 3
  %bf.cast52 = zext i16 %bf.clear51 to i32
  %37 = load %struct.Lisp_Symbol*, %struct.Lisp_Symbol** %sym, align 8
  %38 = bitcast %struct.Lisp_Symbol* %37 to i16*
  %39 = trunc i32 %bf.cast52 to i16
  %bf.load53 = load i16, i16* %38, align 8
  %bf.value = and i16 %39, 3
  %bf.shl = shl i16 %bf.value, 4
  %bf.clear54 = and i16 %bf.load53, -49
  %bf.set55 = or i16 %bf.clear54, %bf.shl
  store i16 %bf.set55, i16* %38, align 8
  %bf.result.cast = zext i16 %bf.value to i32
  %40 = load i64, i64* %new_alias.addr, align 8
  call void @LOADHIST_ATTACH(i64 %40)
  %41 = load i64, i64* %new_alias.addr, align 8
  %call56 = call i64 @builtin_lisp_symbol(i32 992)
  %42 = load i64, i64* %docstring.addr, align 8
  %call57 = call i64 @Fput(i64 %41, i64 %call56, i64 %42)
  %43 = load i64, i64* %base_variable.addr, align 8
  ret i64 %43
}

; Function Attrs: noreturn
declare i64 @wrong_type_argument(i64, i64) #2

; Function Attrs: noreturn nounwind uwtable
define void @error(i8* %m, ...) #3 {
entry:
  %m.addr = alloca i8*, align 8
  %ap = alloca [1 x %struct.__va_list_tag], align 16
  store i8* %m, i8** %m.addr, align 8
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %ap, i32 0, i32 0
  %arraydecay1 = bitcast %struct.__va_list_tag* %arraydecay to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  %0 = load i8*, i8** %m.addr, align 8
  %arraydecay2 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %ap, i32 0, i32 0
  call void @verror(i8* %0, %struct.__va_list_tag* %arraydecay2) #8
  unreachable

return:                                           ; No predecessors!
  ret void
}

; Function Attrs: noreturn
declare void @emacs_abort() #2

declare i64 @Fboundp(i64) #1

declare void @set_internal(i64, i64, i64, i1 zeroext) #1

declare i64 @find_symbol_value(i64) #1

; Function Attrs: nounwind uwtable
define internal i64 @specpdl_symbol(%union.specbinding* %pdl) #0 {
entry:
  %pdl.addr = alloca %union.specbinding*, align 8
  store %union.specbinding* %pdl, %union.specbinding** %pdl.addr, align 8
  %0 = load %union.specbinding*, %union.specbinding** %pdl.addr, align 8
  %let = bitcast %union.specbinding* %0 to %struct.anon.3*
  %symbol = getelementptr inbounds %struct.anon.3, %struct.anon.3* %let, i32 0, i32 1
  %1 = load i64, i64* %symbol, align 8
  ret i64 %1
}

declare void @SET_SYMBOL_ALIAS(%struct.Lisp_Symbol*, %struct.Lisp_Symbol*) #1

declare void @LOADHIST_ATTACH(i64) #1

declare i64 @Fput(i64, i64, i64) #1

; Function Attrs: nounwind uwtable
define i64 @Fdefault_toplevel_value(i64 %symbol) #0 {
entry:
  %symbol.addr = alloca i64, align 8
  %binding = alloca %union.specbinding*, align 8
  %value = alloca i64, align 8
  store i64 %symbol, i64* %symbol.addr, align 8
  %0 = load i64, i64* %symbol.addr, align 8
  %call = call %union.specbinding* @default_toplevel_binding(i64 %0)
  store %union.specbinding* %call, %union.specbinding** %binding, align 8
  %1 = load %union.specbinding*, %union.specbinding** %binding, align 8
  %tobool = icmp ne %union.specbinding* %1, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load %union.specbinding*, %union.specbinding** %binding, align 8
  %call1 = call i64 @specpdl_old_value(%union.specbinding* %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  %3 = load i64, i64* %symbol.addr, align 8
  %call2 = call i64 @Fdefault_value(i64 %3)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call1, %cond.true ], [ %call2, %cond.false ]
  store i64 %cond, i64* %value, align 8
  %4 = load i64, i64* %value, align 8
  %call3 = call i64 @builtin_lisp_symbol(i32 957)
  %cmp = icmp eq i64 %4, %call3
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  %5 = load i64, i64* %value, align 8
  ret i64 %5

if.end:                                           ; preds = %cond.end
  %call4 = call i64 @builtin_lisp_symbol(i32 1007)
  %6 = load i64, i64* %symbol.addr, align 8
  call void @xsignal1(i64 %call4, i64 %6) #8
  unreachable
}

; Function Attrs: nounwind uwtable
define internal %union.specbinding* @default_toplevel_binding(i64 %symbol) #0 {
entry:
  %symbol.addr = alloca i64, align 8
  %binding = alloca %union.specbinding*, align 8
  %pdl = alloca %union.specbinding*, align 8
  store i64 %symbol, i64* %symbol.addr, align 8
  store %union.specbinding* null, %union.specbinding** %binding, align 8
  %0 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  store %union.specbinding* %0, %union.specbinding** %pdl, align 8
  br label %while.cond

while.cond:                                       ; preds = %sw.epilog, %entry
  %1 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %2 = load %union.specbinding*, %union.specbinding** @specpdl, align 8
  %cmp = icmp ugt %union.specbinding* %1, %2
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %incdec.ptr = getelementptr inbounds %union.specbinding, %union.specbinding* %3, i32 -1
  store %union.specbinding* %incdec.ptr, %union.specbinding** %pdl, align 8
  %4 = bitcast %union.specbinding* %incdec.ptr to i8*
  %bf.load = load i8, i8* %4, align 8
  %bf.cast = zext i8 %bf.load to i32
  switch i32 %bf.cast, label %sw.default [
    i32 7, label %sw.bb
    i32 5, label %sw.bb
    i32 0, label %sw.bb.2
    i32 1, label %sw.bb.2
    i32 2, label %sw.bb.2
    i32 3, label %sw.bb.2
    i32 4, label %sw.bb.2
    i32 6, label %sw.bb.2
  ]

sw.bb:                                            ; preds = %while.body, %while.body
  %5 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %call = call i64 @specpdl_symbol(%union.specbinding* %5)
  %6 = load i64, i64* %symbol.addr, align 8
  %cmp1 = icmp eq i64 %call, %6
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb
  %7 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  store %union.specbinding* %7, %union.specbinding** %binding, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %sw.bb
  br label %sw.epilog

sw.bb.2:                                          ; preds = %while.body, %while.body, %while.body, %while.body, %while.body, %while.body
  br label %sw.epilog

sw.default:                                       ; preds = %while.body
  call void @emacs_abort() #8
  unreachable

sw.epilog:                                        ; preds = %sw.bb.2, %if.end
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %8 = load %union.specbinding*, %union.specbinding** %binding, align 8
  ret %union.specbinding* %8
}

; Function Attrs: nounwind uwtable
define internal i64 @specpdl_old_value(%union.specbinding* %pdl) #0 {
entry:
  %pdl.addr = alloca %union.specbinding*, align 8
  store %union.specbinding* %pdl, %union.specbinding** %pdl.addr, align 8
  %0 = load %union.specbinding*, %union.specbinding** %pdl.addr, align 8
  %let = bitcast %union.specbinding* %0 to %struct.anon.3*
  %old_value = getelementptr inbounds %struct.anon.3, %struct.anon.3* %let, i32 0, i32 2
  %1 = load i64, i64* %old_value, align 8
  ret i64 %1
}

declare i64 @Fdefault_value(i64) #1

; Function Attrs: noreturn nounwind uwtable
define void @xsignal1(i64 %error_symbol, i64 %arg) #3 {
entry:
  %error_symbol.addr = alloca i64, align 8
  %arg.addr = alloca i64, align 8
  store i64 %error_symbol, i64* %error_symbol.addr, align 8
  store i64 %arg, i64* %arg.addr, align 8
  %0 = load i64, i64* %error_symbol.addr, align 8
  %1 = load i64, i64* %arg.addr, align 8
  %call = call i64 @list1(i64 %1)
  call void @xsignal(i64 %0, i64 %call) #8
  unreachable

return:                                           ; No predecessors!
  ret void
}

; Function Attrs: nounwind uwtable
define i64 @Fset_default_toplevel_value(i64 %symbol, i64 %value) #0 {
entry:
  %symbol.addr = alloca i64, align 8
  %value.addr = alloca i64, align 8
  %binding = alloca %union.specbinding*, align 8
  store i64 %symbol, i64* %symbol.addr, align 8
  store i64 %value, i64* %value.addr, align 8
  %0 = load i64, i64* %symbol.addr, align 8
  %call = call %union.specbinding* @default_toplevel_binding(i64 %0)
  store %union.specbinding* %call, %union.specbinding** %binding, align 8
  %1 = load %union.specbinding*, %union.specbinding** %binding, align 8
  %tobool = icmp ne %union.specbinding* %1, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load %union.specbinding*, %union.specbinding** %binding, align 8
  %3 = load i64, i64* %value.addr, align 8
  call void @set_specpdl_old_value(%union.specbinding* %2, i64 %3)
  br label %if.end

if.else:                                          ; preds = %entry
  %4 = load i64, i64* %symbol.addr, align 8
  %5 = load i64, i64* %value.addr, align 8
  %call1 = call i64 @Fset_default(i64 %4, i64 %5)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  ret i64 %call2
}

; Function Attrs: nounwind uwtable
define internal void @set_specpdl_old_value(%union.specbinding* %pdl, i64 %val) #0 {
entry:
  %pdl.addr = alloca %union.specbinding*, align 8
  %val.addr = alloca i64, align 8
  store %union.specbinding* %pdl, %union.specbinding** %pdl.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  %0 = load i64, i64* %val.addr, align 8
  %1 = load %union.specbinding*, %union.specbinding** %pdl.addr, align 8
  %let = bitcast %union.specbinding* %1 to %struct.anon.3*
  %old_value = getelementptr inbounds %struct.anon.3, %struct.anon.3* %let, i32 0, i32 2
  store i64 %0, i64* %old_value, align 8
  ret void
}

declare i64 @Fset_default(i64, i64) #1

; Function Attrs: nounwind uwtable
define i64 @Fdefvar(i64 %args) #0 {
entry:
  %args.addr = alloca i64, align 8
  %sym = alloca i64, align 8
  %tem = alloca i64, align 8
  %tail = alloca i64, align 8
  %binding = alloca %union.specbinding*, align 8
  store i64 %args, i64* %args.addr, align 8
  %0 = load i64, i64* %args.addr, align 8
  %sub = sub nsw i64 %0, 3
  %1 = inttoptr i64 %sub to i8*
  %2 = bitcast i8* %1 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %2, i32 0, i32 0
  %3 = load i64, i64* %car, align 8
  store i64 %3, i64* %sym, align 8
  %4 = load i64, i64* %args.addr, align 8
  %sub1 = sub nsw i64 %4, 3
  %5 = inttoptr i64 %sub1 to i8*
  %6 = bitcast i8* %5 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %6, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %7 = load i64, i64* %cdr, align 8
  store i64 %7, i64* %tail, align 8
  %8 = load i64, i64* %tail, align 8
  %and = and i64 %8, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %if.then, label %if.else.59

if.then:                                          ; preds = %entry
  %9 = load i64, i64* %tail, align 8
  %sub3 = sub nsw i64 %9, 3
  %10 = inttoptr i64 %sub3 to i8*
  %11 = bitcast i8* %10 to %struct.Lisp_Cons*
  %u4 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %11, i32 0, i32 1
  %cdr5 = bitcast %union.anon* %u4 to i64*
  %12 = load i64, i64* %cdr5, align 8
  %and6 = and i64 %12, 7
  %conv7 = trunc i64 %and6 to i32
  %cmp8 = icmp eq i32 %conv7, 3
  br i1 %cmp8, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then
  %13 = load i64, i64* %tail, align 8
  %sub10 = sub nsw i64 %13, 3
  %14 = inttoptr i64 %sub10 to i8*
  %15 = bitcast i8* %14 to %struct.Lisp_Cons*
  %u11 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %15, i32 0, i32 1
  %cdr12 = bitcast %union.anon* %u11 to i64*
  %16 = load i64, i64* %cdr12, align 8
  %sub13 = sub nsw i64 %16, 3
  %17 = inttoptr i64 %sub13 to i8*
  %18 = bitcast i8* %17 to %struct.Lisp_Cons*
  %u14 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %18, i32 0, i32 1
  %cdr15 = bitcast %union.anon* %u14 to i64*
  %19 = load i64, i64* %cdr15, align 8
  %and16 = and i64 %19, 7
  %conv17 = trunc i64 %and16 to i32
  %cmp18 = icmp eq i32 %conv17, 3
  br i1 %cmp18, label %if.then.20, label %if.end

if.then.20:                                       ; preds = %land.lhs.true
  call void (i8*, ...) @error(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.5, i32 0, i32 0)) #8
  unreachable

if.end:                                           ; preds = %land.lhs.true, %if.then
  %20 = load i64, i64* %sym, align 8
  %call = call i64 @Fdefault_boundp(i64 %20)
  store i64 %call, i64* %tem, align 8
  %21 = load i64, i64* %sym, align 8
  %sub21 = sub nsw i64 %21, 0
  %add.ptr = getelementptr inbounds i8, i8* bitcast ([1074 x %struct.Lisp_Symbol]* @lispsym to i8*), i64 %sub21
  %22 = bitcast i8* %add.ptr to %struct.Lisp_Symbol*
  %23 = bitcast %struct.Lisp_Symbol* %22 to i16*
  %bf.load = load i16, i16* %23, align 8
  %bf.clear = and i16 %bf.load, -257
  %bf.set = or i16 %bf.clear, 256
  store i16 %bf.set, i16* %23, align 8
  %24 = load i64, i64* %tem, align 8
  %call22 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp23 = icmp eq i64 %24, %call22
  br i1 %cmp23, label %if.then.25, label %if.else

if.then.25:                                       ; preds = %if.end
  %25 = load i64, i64* %sym, align 8
  %26 = load i64, i64* %tail, align 8
  %sub26 = sub nsw i64 %26, 3
  %27 = inttoptr i64 %sub26 to i8*
  %28 = bitcast i8* %27 to %struct.Lisp_Cons*
  %car27 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %28, i32 0, i32 0
  %29 = load i64, i64* %car27, align 8
  %call28 = call i64 @eval_sub(i64 %29)
  %call29 = call i64 @Fset_default(i64 %25, i64 %call28)
  br label %if.end.41

if.else:                                          ; preds = %if.end
  %30 = load i64, i64* %sym, align 8
  %call30 = call %union.specbinding* @default_toplevel_binding(i64 %30)
  store %union.specbinding* %call30, %union.specbinding** %binding, align 8
  %31 = load %union.specbinding*, %union.specbinding** %binding, align 8
  %tobool = icmp ne %union.specbinding* %31, null
  br i1 %tobool, label %land.lhs.true.31, label %if.end.40

land.lhs.true.31:                                 ; preds = %if.else
  %32 = load %union.specbinding*, %union.specbinding** %binding, align 8
  %call32 = call i64 @specpdl_old_value(%union.specbinding* %32)
  %call33 = call i64 @builtin_lisp_symbol(i32 957)
  %cmp34 = icmp eq i64 %call32, %call33
  br i1 %cmp34, label %if.then.36, label %if.end.40

if.then.36:                                       ; preds = %land.lhs.true.31
  %33 = load %union.specbinding*, %union.specbinding** %binding, align 8
  %34 = load i64, i64* %tail, align 8
  %sub37 = sub nsw i64 %34, 3
  %35 = inttoptr i64 %sub37 to i8*
  %36 = bitcast i8* %35 to %struct.Lisp_Cons*
  %car38 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %36, i32 0, i32 0
  %37 = load i64, i64* %car38, align 8
  %call39 = call i64 @eval_sub(i64 %37)
  call void @set_specpdl_old_value(%union.specbinding* %33, i64 %call39)
  br label %if.end.40

if.end.40:                                        ; preds = %if.then.36, %land.lhs.true.31, %if.else
  br label %if.end.41

if.end.41:                                        ; preds = %if.end.40, %if.then.25
  %38 = load i64, i64* %tail, align 8
  %sub42 = sub nsw i64 %38, 3
  %39 = inttoptr i64 %sub42 to i8*
  %40 = bitcast i8* %39 to %struct.Lisp_Cons*
  %u43 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %40, i32 0, i32 1
  %cdr44 = bitcast %union.anon* %u43 to i64*
  %41 = load i64, i64* %cdr44, align 8
  store i64 %41, i64* %tail, align 8
  %42 = load i64, i64* %tail, align 8
  %call45 = call i64 @Fcar(i64 %42)
  store i64 %call45, i64* %tem, align 8
  %43 = load i64, i64* %tem, align 8
  %call46 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp47 = icmp eq i64 %43, %call46
  br i1 %cmp47, label %if.end.58, label %if.then.49

if.then.49:                                       ; preds = %if.end.41
  %44 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 240), align 8
  %call50 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp51 = icmp eq i64 %44, %call50
  br i1 %cmp51, label %if.end.55, label %if.then.53

if.then.53:                                       ; preds = %if.then.49
  %45 = load i64, i64* %tem, align 8
  %call54 = call i64 @Fpurecopy(i64 %45)
  store i64 %call54, i64* %tem, align 8
  br label %if.end.55

if.end.55:                                        ; preds = %if.then.53, %if.then.49
  %46 = load i64, i64* %sym, align 8
  %call56 = call i64 @builtin_lisp_symbol(i32 992)
  %47 = load i64, i64* %tem, align 8
  %call57 = call i64 @Fput(i64 %46, i64 %call56, i64 %47)
  br label %if.end.58

if.end.58:                                        ; preds = %if.end.55, %if.end.41
  %48 = load i64, i64* %sym, align 8
  call void @LOADHIST_ATTACH(i64 %48)
  br label %if.end.72

if.else.59:                                       ; preds = %entry
  %49 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 147), align 8
  %call60 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp61 = icmp eq i64 %49, %call60
  br i1 %cmp61, label %if.else.70, label %land.lhs.true.63

land.lhs.true.63:                                 ; preds = %if.else.59
  %50 = load i64, i64* %sym, align 8
  %sub64 = sub nsw i64 %50, 0
  %add.ptr65 = getelementptr inbounds i8, i8* bitcast ([1074 x %struct.Lisp_Symbol]* @lispsym to i8*), i64 %sub64
  %51 = bitcast i8* %add.ptr65 to %struct.Lisp_Symbol*
  %52 = bitcast %struct.Lisp_Symbol* %51 to i16*
  %bf.load66 = load i16, i16* %52, align 8
  %bf.lshr = lshr i16 %bf.load66, 8
  %bf.clear67 = and i16 %bf.lshr, 1
  %bf.cast = trunc i16 %bf.clear67 to i1
  br i1 %bf.cast, label %if.else.70, label %if.then.68

if.then.68:                                       ; preds = %land.lhs.true.63
  %53 = load i64, i64* %sym, align 8
  %54 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 147), align 8
  %call69 = call i64 @Fcons(i64 %53, i64 %54)
  store i64 %call69, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 147), align 8
  br label %if.end.71

if.else.70:                                       ; preds = %land.lhs.true.63, %if.else.59
  br label %if.end.71

if.end.71:                                        ; preds = %if.else.70, %if.then.68
  br label %if.end.72

if.end.72:                                        ; preds = %if.end.71, %if.end.58
  %55 = load i64, i64* %sym, align 8
  ret i64 %55
}

declare i64 @Fdefault_boundp(i64) #1

declare i64 @Fpurecopy(i64) #1

; Function Attrs: nounwind uwtable
define i64 @Fdefconst(i64 %args) #0 {
entry:
  %args.addr = alloca i64, align 8
  %sym = alloca i64, align 8
  %tem = alloca i64, align 8
  store i64 %args, i64* %args.addr, align 8
  %0 = load i64, i64* %args.addr, align 8
  %sub = sub nsw i64 %0, 3
  %1 = inttoptr i64 %sub to i8*
  %2 = bitcast i8* %1 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %2, i32 0, i32 0
  %3 = load i64, i64* %car, align 8
  store i64 %3, i64* %sym, align 8
  %4 = load i64, i64* %args.addr, align 8
  %sub1 = sub nsw i64 %4, 3
  %5 = inttoptr i64 %sub1 to i8*
  %6 = bitcast i8* %5 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %6, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %7 = load i64, i64* %cdr, align 8
  %sub2 = sub nsw i64 %7, 3
  %8 = inttoptr i64 %sub2 to i8*
  %9 = bitcast i8* %8 to %struct.Lisp_Cons*
  %u3 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %9, i32 0, i32 1
  %cdr4 = bitcast %union.anon* %u3 to i64*
  %10 = load i64, i64* %cdr4, align 8
  %call = call i64 @Fcdr(i64 %10)
  %and = and i64 %call, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void (i8*, ...) @error(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.5, i32 0, i32 0)) #8
  unreachable

if.end:                                           ; preds = %entry
  %11 = load i64, i64* %args.addr, align 8
  %sub6 = sub nsw i64 %11, 3
  %12 = inttoptr i64 %sub6 to i8*
  %13 = bitcast i8* %12 to %struct.Lisp_Cons*
  %u7 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %13, i32 0, i32 1
  %cdr8 = bitcast %union.anon* %u7 to i64*
  %14 = load i64, i64* %cdr8, align 8
  %call9 = call i64 @Fcar(i64 %14)
  %call10 = call i64 @eval_sub(i64 %call9)
  store i64 %call10, i64* %tem, align 8
  %15 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 240), align 8
  %call11 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp12 = icmp eq i64 %15, %call11
  br i1 %cmp12, label %if.end.16, label %if.then.14

if.then.14:                                       ; preds = %if.end
  %16 = load i64, i64* %tem, align 8
  %call15 = call i64 @Fpurecopy(i64 %16)
  store i64 %call15, i64* %tem, align 8
  br label %if.end.16

if.end.16:                                        ; preds = %if.then.14, %if.end
  %17 = load i64, i64* %sym, align 8
  %18 = load i64, i64* %tem, align 8
  %call17 = call i64 @Fset_default(i64 %17, i64 %18)
  %19 = load i64, i64* %sym, align 8
  %sub18 = sub nsw i64 %19, 0
  %add.ptr = getelementptr inbounds i8, i8* bitcast ([1074 x %struct.Lisp_Symbol]* @lispsym to i8*), i64 %sub18
  %20 = bitcast i8* %add.ptr to %struct.Lisp_Symbol*
  %21 = bitcast %struct.Lisp_Symbol* %20 to i16*
  %bf.load = load i16, i16* %21, align 8
  %bf.clear = and i16 %bf.load, -257
  %bf.set = or i16 %bf.clear, 256
  store i16 %bf.set, i16* %21, align 8
  %22 = load i64, i64* %args.addr, align 8
  %sub19 = sub nsw i64 %22, 3
  %23 = inttoptr i64 %sub19 to i8*
  %24 = bitcast i8* %23 to %struct.Lisp_Cons*
  %u20 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %24, i32 0, i32 1
  %cdr21 = bitcast %union.anon* %u20 to i64*
  %25 = load i64, i64* %cdr21, align 8
  %sub22 = sub nsw i64 %25, 3
  %26 = inttoptr i64 %sub22 to i8*
  %27 = bitcast i8* %26 to %struct.Lisp_Cons*
  %u23 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %27, i32 0, i32 1
  %cdr24 = bitcast %union.anon* %u23 to i64*
  %28 = load i64, i64* %cdr24, align 8
  %call25 = call i64 @Fcar(i64 %28)
  store i64 %call25, i64* %tem, align 8
  %29 = load i64, i64* %tem, align 8
  %call26 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp27 = icmp eq i64 %29, %call26
  br i1 %cmp27, label %if.end.38, label %if.then.29

if.then.29:                                       ; preds = %if.end.16
  %30 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 240), align 8
  %call30 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp31 = icmp eq i64 %30, %call30
  br i1 %cmp31, label %if.end.35, label %if.then.33

if.then.33:                                       ; preds = %if.then.29
  %31 = load i64, i64* %tem, align 8
  %call34 = call i64 @Fpurecopy(i64 %31)
  store i64 %call34, i64* %tem, align 8
  br label %if.end.35

if.end.35:                                        ; preds = %if.then.33, %if.then.29
  %32 = load i64, i64* %sym, align 8
  %call36 = call i64 @builtin_lisp_symbol(i32 992)
  %33 = load i64, i64* %tem, align 8
  %call37 = call i64 @Fput(i64 %32, i64 %call36, i64 %33)
  br label %if.end.38

if.end.38:                                        ; preds = %if.end.35, %if.end.16
  %34 = load i64, i64* %sym, align 8
  %call39 = call i64 @builtin_lisp_symbol(i32 818)
  %call40 = call i64 @builtin_lisp_symbol(i32 901)
  %call41 = call i64 @Fput(i64 %34, i64 %call39, i64 %call40)
  %35 = load i64, i64* %sym, align 8
  call void @LOADHIST_ATTACH(i64 %35)
  %36 = load i64, i64* %sym, align 8
  ret i64 %36
}

; Function Attrs: nounwind uwtable
define i64 @Fmake_var_non_special(i64 %symbol) #0 {
entry:
  %symbol.addr = alloca i64, align 8
  store i64 %symbol, i64* %symbol.addr, align 8
  %0 = load i64, i64* %symbol.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = call i64 @builtin_lisp_symbol(i32 897)
  %1 = load i64, i64* %symbol.addr, align 8
  %2 = call i64 @wrong_type_argument(i64 %call, i64 %1) #8
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %3, %cond.true
  %4 = load i64, i64* %symbol.addr, align 8
  %sub = sub nsw i64 %4, 0
  %add.ptr = getelementptr inbounds i8, i8* bitcast ([1074 x %struct.Lisp_Symbol]* @lispsym to i8*), i64 %sub
  %5 = bitcast i8* %add.ptr to %struct.Lisp_Symbol*
  %6 = bitcast %struct.Lisp_Symbol* %5 to i16*
  %bf.load = load i16, i16* %6, align 8
  %bf.clear = and i16 %bf.load, -257
  store i16 %bf.clear, i16* %6, align 8
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  ret i64 %call2
}

; Function Attrs: nounwind uwtable
define i64 @FletX(i64 %args) #0 {
entry:
  %args.addr = alloca i64, align 8
  %varlist = alloca i64, align 8
  %var = alloca i64, align 8
  %val = alloca i64, align 8
  %elt = alloca i64, align 8
  %lexenv = alloca i64, align 8
  %count = alloca i64, align 8
  %newenv = alloca i64, align 8
  store i64 %args, i64* %args.addr, align 8
  %call = call i64 @SPECPDL_INDEX()
  store i64 %call, i64* %count, align 8
  %0 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 147), align 8
  store i64 %0, i64* %lexenv, align 8
  %1 = load i64, i64* %args.addr, align 8
  %sub = sub nsw i64 %1, 3
  %2 = inttoptr i64 %sub to i8*
  %3 = bitcast i8* %2 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %3, i32 0, i32 0
  %4 = load i64, i64* %car, align 8
  store i64 %4, i64* %varlist, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end.57, %entry
  %5 = load i64, i64* %varlist, align 8
  %and = and i64 %5, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  br label %do.body

do.body:                                          ; preds = %while.body
  %6 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp3 = icmp eq i64 %6, %call2
  br i1 %cmp3, label %if.else, label %land.lhs.true

land.lhs.true:                                    ; preds = %do.body
  %7 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  %call5 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp6 = icmp eq i64 %7, %call5
  br i1 %cmp6, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  call void @process_quit_flag()
  br label %if.end.9

if.else:                                          ; preds = %land.lhs.true, %do.body
  %8 = load volatile i8, i8* @pending_signals, align 1
  %tobool = trunc i8 %8 to i1
  br i1 %tobool, label %if.then.8, label %if.end

if.then.8:                                        ; preds = %if.else
  call void @process_pending_signals()
  br label %if.end

if.end:                                           ; preds = %if.then.8, %if.else
  br label %if.end.9

if.end.9:                                         ; preds = %if.end, %if.then
  br label %do.end

do.end:                                           ; preds = %if.end.9
  %9 = load i64, i64* %varlist, align 8
  %sub10 = sub nsw i64 %9, 3
  %10 = inttoptr i64 %sub10 to i8*
  %11 = bitcast i8* %10 to %struct.Lisp_Cons*
  %car11 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %11, i32 0, i32 0
  %12 = load i64, i64* %car11, align 8
  store i64 %12, i64* %elt, align 8
  %13 = load i64, i64* %elt, align 8
  %and12 = and i64 %13, 7
  %conv13 = trunc i64 %and12 to i32
  %cmp14 = icmp eq i32 %conv13, 0
  br i1 %cmp14, label %if.then.16, label %if.else.18

if.then.16:                                       ; preds = %do.end
  %14 = load i64, i64* %elt, align 8
  store i64 %14, i64* %var, align 8
  %call17 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call17, i64* %val, align 8
  br label %if.end.31

if.else.18:                                       ; preds = %do.end
  %15 = load i64, i64* %elt, align 8
  %call19 = call i64 @Fcdr(i64 %15)
  %call20 = call i64 @Fcdr(i64 %call19)
  %call21 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp22 = icmp eq i64 %call20, %call21
  br i1 %cmp22, label %if.else.25, label %if.then.24

if.then.24:                                       ; preds = %if.else.18
  %16 = load i64, i64* %elt, align 8
  call void @signal_error(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.6, i32 0, i32 0), i64 %16) #8
  unreachable

if.else.25:                                       ; preds = %if.else.18
  %17 = load i64, i64* %elt, align 8
  %call26 = call i64 @Fcar(i64 %17)
  store i64 %call26, i64* %var, align 8
  %18 = load i64, i64* %elt, align 8
  %call27 = call i64 @Fcdr(i64 %18)
  %call28 = call i64 @Fcar(i64 %call27)
  %call29 = call i64 @eval_sub(i64 %call28)
  store i64 %call29, i64* %val, align 8
  br label %if.end.30

if.end.30:                                        ; preds = %if.else.25
  br label %if.end.31

if.end.31:                                        ; preds = %if.end.30, %if.then.16
  %19 = load i64, i64* %lexenv, align 8
  %call32 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp33 = icmp eq i64 %19, %call32
  br i1 %cmp33, label %if.else.56, label %land.lhs.true.35

land.lhs.true.35:                                 ; preds = %if.end.31
  %20 = load i64, i64* %var, align 8
  %and36 = and i64 %20, 7
  %conv37 = trunc i64 %and36 to i32
  %cmp38 = icmp eq i32 %conv37, 0
  br i1 %cmp38, label %land.lhs.true.40, label %if.else.56

land.lhs.true.40:                                 ; preds = %land.lhs.true.35
  %21 = load i64, i64* %var, align 8
  %sub41 = sub nsw i64 %21, 0
  %add.ptr = getelementptr inbounds i8, i8* bitcast ([1074 x %struct.Lisp_Symbol]* @lispsym to i8*), i64 %sub41
  %22 = bitcast i8* %add.ptr to %struct.Lisp_Symbol*
  %23 = bitcast %struct.Lisp_Symbol* %22 to i16*
  %bf.load = load i16, i16* %23, align 8
  %bf.lshr = lshr i16 %bf.load, 8
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = trunc i16 %bf.clear to i1
  br i1 %bf.cast, label %if.else.56, label %land.lhs.true.42

land.lhs.true.42:                                 ; preds = %land.lhs.true.40
  %24 = load i64, i64* %var, align 8
  %25 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 147), align 8
  %call43 = call i64 @Fmemq(i64 %24, i64 %25)
  %call44 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp45 = icmp eq i64 %call43, %call44
  br i1 %cmp45, label %if.then.47, label %if.else.56

if.then.47:                                       ; preds = %land.lhs.true.42
  %26 = load i64, i64* %var, align 8
  %27 = load i64, i64* %val, align 8
  %call48 = call i64 @Fcons(i64 %26, i64 %27)
  %28 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 147), align 8
  %call49 = call i64 @Fcons(i64 %call48, i64 %28)
  store i64 %call49, i64* %newenv, align 8
  %29 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 147), align 8
  %30 = load i64, i64* %lexenv, align 8
  %cmp50 = icmp eq i64 %29, %30
  br i1 %cmp50, label %if.then.52, label %if.else.54

if.then.52:                                       ; preds = %if.then.47
  %call53 = call i64 @builtin_lisp_symbol(i32 567)
  %31 = load i64, i64* %newenv, align 8
  call void @specbind(i64 %call53, i64 %31)
  br label %if.end.55

if.else.54:                                       ; preds = %if.then.47
  %32 = load i64, i64* %newenv, align 8
  store i64 %32, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 147), align 8
  br label %if.end.55

if.end.55:                                        ; preds = %if.else.54, %if.then.52
  br label %if.end.57

if.else.56:                                       ; preds = %land.lhs.true.42, %land.lhs.true.40, %land.lhs.true.35, %if.end.31
  %33 = load i64, i64* %var, align 8
  %34 = load i64, i64* %val, align 8
  call void @specbind(i64 %33, i64 %34)
  br label %if.end.57

if.end.57:                                        ; preds = %if.else.56, %if.end.55
  %35 = load i64, i64* %varlist, align 8
  %sub58 = sub nsw i64 %35, 3
  %36 = inttoptr i64 %sub58 to i8*
  %37 = bitcast i8* %36 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %37, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %38 = load i64, i64* %cdr, align 8
  store i64 %38, i64* %varlist, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %39 = load i64, i64* %args.addr, align 8
  %sub59 = sub nsw i64 %39, 3
  %40 = inttoptr i64 %sub59 to i8*
  %41 = bitcast i8* %40 to %struct.Lisp_Cons*
  %u60 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %41, i32 0, i32 1
  %cdr61 = bitcast %union.anon* %u60 to i64*
  %42 = load i64, i64* %cdr61, align 8
  %call62 = call i64 @Fprogn(i64 %42)
  store i64 %call62, i64* %val, align 8
  %43 = load i64, i64* %count, align 8
  %44 = load i64, i64* %val, align 8
  %call63 = call i64 @unbind_to(i64 %43, i64 %44)
  ret i64 %call63
}

; Function Attrs: nounwind uwtable
define void @process_quit_flag() #0 {
entry:
  %flag = alloca i64, align 8
  %0 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  store i64 %0, i64* %flag, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %1 = load i64, i64* %flag, align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 594)
  %cmp = icmp eq i64 %1, %call1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  %2 = call i64 @Fkill_emacs(i64 %call2) #8
  unreachable

if.end:                                           ; preds = %entry
  %3 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 296), align 8
  %4 = load i64, i64* %flag, align 8
  %cmp3 = icmp eq i64 %3, %4
  br i1 %cmp3, label %if.then.4, label %if.end.6

if.then.4:                                        ; preds = %if.end
  %5 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 296), align 8
  %call5 = call i64 @builtin_lisp_symbol(i32 901)
  %6 = call i64 @Fthrow(i64 %5, i64 %call5) #8
  unreachable

if.end.6:                                         ; preds = %if.end
  %call7 = call i64 @builtin_lisp_symbol(i32 782)
  %call8 = call i64 @builtin_lisp_symbol(i32 0)
  %call9 = call i64 @Fsignal(i64 %call7, i64 %call8)
  ret void
}

declare void @process_pending_signals() #1

; Function Attrs: noreturn nounwind uwtable
define void @signal_error(i8* %s, i64 %arg) #3 {
entry:
  %s.addr = alloca i8*, align 8
  %arg.addr = alloca i64, align 8
  %tortoise = alloca i64, align 8
  %hare = alloca i64, align 8
  store i8* %s, i8** %s.addr, align 8
  store i64 %arg, i64* %arg.addr, align 8
  %0 = load i64, i64* %arg.addr, align 8
  store i64 %0, i64* %tortoise, align 8
  store i64 %0, i64* %hare, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end.15, %entry
  %1 = load i64, i64* %hare, align 8
  %and = and i64 %1, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load i64, i64* %hare, align 8
  %sub = sub nsw i64 %2, 3
  %3 = inttoptr i64 %sub to i8*
  %4 = bitcast i8* %3 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %4, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %5 = load i64, i64* %cdr, align 8
  store i64 %5, i64* %hare, align 8
  %6 = load i64, i64* %hare, align 8
  %and2 = and i64 %6, 7
  %conv3 = trunc i64 %and2 to i32
  %cmp4 = icmp eq i32 %conv3, 3
  br i1 %cmp4, label %if.end, label %if.then

if.then:                                          ; preds = %while.body
  br label %while.end

if.end:                                           ; preds = %while.body
  %7 = load i64, i64* %hare, align 8
  %sub6 = sub nsw i64 %7, 3
  %8 = inttoptr i64 %sub6 to i8*
  %9 = bitcast i8* %8 to %struct.Lisp_Cons*
  %u7 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %9, i32 0, i32 1
  %cdr8 = bitcast %union.anon* %u7 to i64*
  %10 = load i64, i64* %cdr8, align 8
  store i64 %10, i64* %hare, align 8
  %11 = load i64, i64* %tortoise, align 8
  %sub9 = sub nsw i64 %11, 3
  %12 = inttoptr i64 %sub9 to i8*
  %13 = bitcast i8* %12 to %struct.Lisp_Cons*
  %u10 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %13, i32 0, i32 1
  %cdr11 = bitcast %union.anon* %u10 to i64*
  %14 = load i64, i64* %cdr11, align 8
  store i64 %14, i64* %tortoise, align 8
  %15 = load i64, i64* %hare, align 8
  %16 = load i64, i64* %tortoise, align 8
  %cmp12 = icmp eq i64 %15, %16
  br i1 %cmp12, label %if.then.14, label %if.end.15

if.then.14:                                       ; preds = %if.end
  br label %while.end

if.end.15:                                        ; preds = %if.end
  br label %while.cond

while.end:                                        ; preds = %if.then.14, %if.then, %while.cond
  %17 = load i64, i64* %hare, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp16 = icmp eq i64 %17, %call
  br i1 %cmp16, label %if.end.20, label %if.then.18

if.then.18:                                       ; preds = %while.end
  %18 = load i64, i64* %arg.addr, align 8
  %call19 = call i64 @list1(i64 %18)
  store i64 %call19, i64* %arg.addr, align 8
  br label %if.end.20

if.end.20:                                        ; preds = %if.then.18, %while.end
  %call21 = call i64 @builtin_lisp_symbol(i32 372)
  %19 = load i8*, i8** %s.addr, align 8
  %call22 = call i64 @build_string(i8* %19)
  %20 = load i64, i64* %arg.addr, align 8
  %call23 = call i64 @Fcons(i64 %call22, i64 %20)
  call void @xsignal(i64 %call21, i64 %call23) #8
  unreachable

return:                                           ; No predecessors!
  ret void
}

declare i64 @Fmemq(i64, i64) #1

; Function Attrs: nounwind uwtable
define i64 @Flet(i64 %args) #0 {
entry:
  %args.addr = alloca i64, align 8
  %temps = alloca i64*, align 8
  %tem = alloca i64, align 8
  %lexenv = alloca i64, align 8
  %elt = alloca i64, align 8
  %varlist = alloca i64, align 8
  %count = alloca i64, align 8
  %argnum = alloca i64, align 8
  %sa_avail = alloca i64, align 8
  %sa_count = alloca i64, align 8
  %sa_must_free = alloca i8, align 1
  %alloca_nbytes = alloca i64, align 8
  %arg_ = alloca i64, align 8
  %var = alloca i64, align 8
  store i64 %args, i64* %args.addr, align 8
  %call = call i64 @SPECPDL_INDEX()
  store i64 %call, i64* %count, align 8
  store i64 16384, i64* %sa_avail, align 8
  %call1 = call i64 @SPECPDL_INDEX()
  store i64 %call1, i64* %sa_count, align 8
  store i8 0, i8* %sa_must_free, align 1
  %0 = load i64, i64* %args.addr, align 8
  %sub = sub nsw i64 %0, 3
  %1 = inttoptr i64 %sub to i8*
  %2 = bitcast i8* %1 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %2, i32 0, i32 0
  %3 = load i64, i64* %car, align 8
  store i64 %3, i64* %varlist, align 8
  %4 = load i64, i64* %varlist, align 8
  %call2 = call i64 @Flength(i64 %4)
  store i64 %call2, i64* %elt, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br i1 false, label %cond.true, label %cond.false.541

cond.true:                                        ; preds = %do.body
  br i1 false, label %cond.true.3, label %cond.false.292

cond.true.3:                                      ; preds = %cond.true
  %5 = load i64, i64* %elt, align 8
  %shr = ashr i64 %5, 2
  %conv = trunc i64 %shr to i8
  %conv4 = sext i8 %conv to i32
  %add = add nsw i32 0, %conv4
  %mul = mul nsw i32 0, %add
  %sub5 = sub nsw i32 %mul, 1
  %cmp = icmp slt i32 %sub5, 0
  br i1 %cmp, label %cond.true.7, label %cond.false

cond.true.7:                                      ; preds = %cond.true.3
  %6 = load i64, i64* %elt, align 8
  %shr8 = ashr i64 %6, 2
  %conv9 = trunc i64 %shr8 to i8
  %conv10 = sext i8 %conv9 to i32
  %add11 = add nsw i32 0, %conv10
  %mul12 = mul nsw i32 0, %add11
  %add13 = add nsw i32 %mul12, 0
  %neg = xor i32 %add13, -1
  %cmp14 = icmp eq i32 %neg, -1
  %conv15 = zext i1 %cmp14 to i32
  %sub16 = sub nsw i32 0, %conv15
  %7 = load i64, i64* %elt, align 8
  %shr17 = ashr i64 %7, 2
  %conv18 = trunc i64 %shr17 to i8
  %conv19 = sext i8 %conv18 to i32
  %add20 = add nsw i32 0, %conv19
  %mul21 = mul nsw i32 0, %add20
  %add22 = add nsw i32 %mul21, 1
  %shl = shl i32 %add22, 30
  %sub23 = sub nsw i32 %shl, 1
  %mul24 = mul nsw i32 %sub23, 2
  %add25 = add nsw i32 %mul24, 1
  %sub26 = sub nsw i32 %sub16, %add25
  br label %cond.end

cond.false:                                       ; preds = %cond.true.3
  %8 = load i64, i64* %elt, align 8
  %shr27 = ashr i64 %8, 2
  %conv28 = trunc i64 %shr27 to i8
  %conv29 = sext i8 %conv28 to i32
  %add30 = add nsw i32 0, %conv29
  %mul31 = mul nsw i32 0, %add30
  %add32 = add nsw i32 %mul31, 0
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true.7
  %cond = phi i32 [ %sub26, %cond.true.7 ], [ %add32, %cond.false ]
  %cmp33 = icmp eq i32 %cond, 0
  br i1 %cmp33, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %cond.end
  %9 = load i64, i64* %elt, align 8
  %shr35 = ashr i64 %9, 2
  %conv36 = trunc i64 %shr35 to i8
  %conv37 = sext i8 %conv36 to i32
  %cmp38 = icmp slt i32 %conv37, 0
  br i1 %cmp38, label %cond.true.240, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %cond.end
  br i1 false, label %cond.true.40, label %cond.false.128

cond.true.40:                                     ; preds = %lor.lhs.false
  %10 = load i64, i64* %elt, align 8
  %shr41 = ashr i64 %10, 2
  %conv42 = trunc i64 %shr41 to i8
  %conv43 = sext i8 %conv42 to i32
  %cmp44 = icmp slt i32 %conv43, 0
  br i1 %cmp44, label %cond.true.46, label %cond.false.80

cond.true.46:                                     ; preds = %cond.true.40
  %11 = load i64, i64* %elt, align 8
  %shr47 = ashr i64 %11, 2
  %conv48 = trunc i64 %shr47 to i8
  %conv49 = sext i8 %conv48 to i32
  %12 = load i64, i64* %elt, align 8
  %shr50 = ashr i64 %12, 2
  %conv51 = trunc i64 %shr50 to i8
  %conv52 = sext i8 %conv51 to i32
  %add53 = add nsw i32 0, %conv52
  %mul54 = mul nsw i32 0, %add53
  %sub55 = sub nsw i32 %mul54, 1
  %cmp56 = icmp slt i32 %sub55, 0
  br i1 %cmp56, label %cond.true.58, label %cond.false.69

cond.true.58:                                     ; preds = %cond.true.46
  %13 = load i64, i64* %elt, align 8
  %shr59 = ashr i64 %13, 2
  %conv60 = trunc i64 %shr59 to i8
  %conv61 = sext i8 %conv60 to i32
  %add62 = add nsw i32 0, %conv61
  %mul63 = mul nsw i32 0, %add62
  %add64 = add nsw i32 %mul63, 1
  %shl65 = shl i32 %add64, 30
  %sub66 = sub nsw i32 %shl65, 1
  %mul67 = mul nsw i32 %sub66, 2
  %add68 = add nsw i32 %mul67, 1
  br label %cond.end.76

cond.false.69:                                    ; preds = %cond.true.46
  %14 = load i64, i64* %elt, align 8
  %shr70 = ashr i64 %14, 2
  %conv71 = trunc i64 %shr70 to i8
  %conv72 = sext i8 %conv71 to i32
  %add73 = add nsw i32 0, %conv72
  %mul74 = mul nsw i32 0, %add73
  %sub75 = sub nsw i32 %mul74, 1
  br label %cond.end.76

cond.end.76:                                      ; preds = %cond.false.69, %cond.true.58
  %cond77 = phi i32 [ %add68, %cond.true.58 ], [ %sub75, %cond.false.69 ]
  %div = sdiv i32 %cond77, 8
  %cmp78 = icmp slt i32 %conv49, %div
  br i1 %cmp78, label %cond.true.240, label %lor.lhs.false.217

cond.false.80:                                    ; preds = %cond.true.40
  br i1 false, label %cond.true.81, label %cond.false.82

cond.true.81:                                     ; preds = %cond.false.80
  br i1 false, label %cond.true.240, label %lor.lhs.false.217

cond.false.82:                                    ; preds = %cond.false.80
  %15 = load i64, i64* %elt, align 8
  %shr83 = ashr i64 %15, 2
  %conv84 = trunc i64 %shr83 to i8
  %conv85 = sext i8 %conv84 to i32
  %add86 = add nsw i32 0, %conv85
  %mul87 = mul nsw i32 0, %add86
  %sub88 = sub nsw i32 %mul87, 1
  %cmp89 = icmp slt i32 %sub88, 0
  br i1 %cmp89, label %cond.true.91, label %cond.false.113

cond.true.91:                                     ; preds = %cond.false.82
  %16 = load i64, i64* %elt, align 8
  %shr92 = ashr i64 %16, 2
  %conv93 = trunc i64 %shr92 to i8
  %conv94 = sext i8 %conv93 to i32
  %add95 = add nsw i32 0, %conv94
  %mul96 = mul nsw i32 0, %add95
  %add97 = add nsw i32 %mul96, 0
  %neg98 = xor i32 %add97, -1
  %cmp99 = icmp eq i32 %neg98, -1
  %conv100 = zext i1 %cmp99 to i32
  %sub101 = sub nsw i32 0, %conv100
  %17 = load i64, i64* %elt, align 8
  %shr102 = ashr i64 %17, 2
  %conv103 = trunc i64 %shr102 to i8
  %conv104 = sext i8 %conv103 to i32
  %add105 = add nsw i32 0, %conv104
  %mul106 = mul nsw i32 0, %add105
  %add107 = add nsw i32 %mul106, 1
  %shl108 = shl i32 %add107, 30
  %sub109 = sub nsw i32 %shl108, 1
  %mul110 = mul nsw i32 %sub109, 2
  %add111 = add nsw i32 %mul110, 1
  %sub112 = sub nsw i32 %sub101, %add111
  br label %cond.end.120

cond.false.113:                                   ; preds = %cond.false.82
  %18 = load i64, i64* %elt, align 8
  %shr114 = ashr i64 %18, 2
  %conv115 = trunc i64 %shr114 to i8
  %conv116 = sext i8 %conv115 to i32
  %add117 = add nsw i32 0, %conv116
  %mul118 = mul nsw i32 0, %add117
  %add119 = add nsw i32 %mul118, 0
  br label %cond.end.120

cond.end.120:                                     ; preds = %cond.false.113, %cond.true.91
  %cond121 = phi i32 [ %sub112, %cond.true.91 ], [ %add119, %cond.false.113 ]
  %div122 = sdiv i32 %cond121, 8
  %19 = load i64, i64* %elt, align 8
  %shr123 = ashr i64 %19, 2
  %conv124 = trunc i64 %shr123 to i8
  %conv125 = sext i8 %conv124 to i32
  %cmp126 = icmp slt i32 %div122, %conv125
  br i1 %cmp126, label %cond.true.240, label %lor.lhs.false.217

cond.false.128:                                   ; preds = %lor.lhs.false
  br i1 false, label %cond.true.129, label %cond.false.130

cond.true.129:                                    ; preds = %cond.false.128
  br i1 false, label %cond.true.240, label %lor.lhs.false.217

cond.false.130:                                   ; preds = %cond.false.128
  %20 = load i64, i64* %elt, align 8
  %shr131 = ashr i64 %20, 2
  %conv132 = trunc i64 %shr131 to i8
  %conv133 = sext i8 %conv132 to i32
  %cmp134 = icmp slt i32 %conv133, 0
  br i1 %cmp134, label %cond.true.136, label %cond.false.182

cond.true.136:                                    ; preds = %cond.false.130
  %21 = load i64, i64* %elt, align 8
  %shr137 = ashr i64 %21, 2
  %conv138 = trunc i64 %shr137 to i8
  %conv139 = sext i8 %conv138 to i32
  %22 = load i64, i64* %elt, align 8
  %shr140 = ashr i64 %22, 2
  %conv141 = trunc i64 %shr140 to i8
  %conv142 = sext i8 %conv141 to i32
  %add143 = add nsw i32 0, %conv142
  %mul144 = mul nsw i32 0, %add143
  %sub145 = sub nsw i32 %mul144, 1
  %cmp146 = icmp slt i32 %sub145, 0
  br i1 %cmp146, label %cond.true.148, label %cond.false.170

cond.true.148:                                    ; preds = %cond.true.136
  %23 = load i64, i64* %elt, align 8
  %shr149 = ashr i64 %23, 2
  %conv150 = trunc i64 %shr149 to i8
  %conv151 = sext i8 %conv150 to i32
  %add152 = add nsw i32 0, %conv151
  %mul153 = mul nsw i32 0, %add152
  %add154 = add nsw i32 %mul153, 0
  %neg155 = xor i32 %add154, -1
  %cmp156 = icmp eq i32 %neg155, -1
  %conv157 = zext i1 %cmp156 to i32
  %sub158 = sub nsw i32 0, %conv157
  %24 = load i64, i64* %elt, align 8
  %shr159 = ashr i64 %24, 2
  %conv160 = trunc i64 %shr159 to i8
  %conv161 = sext i8 %conv160 to i32
  %add162 = add nsw i32 0, %conv161
  %mul163 = mul nsw i32 0, %add162
  %add164 = add nsw i32 %mul163, 1
  %shl165 = shl i32 %add164, 30
  %sub166 = sub nsw i32 %shl165, 1
  %mul167 = mul nsw i32 %sub166, 2
  %add168 = add nsw i32 %mul167, 1
  %sub169 = sub nsw i32 %sub158, %add168
  br label %cond.end.177

cond.false.170:                                   ; preds = %cond.true.136
  %25 = load i64, i64* %elt, align 8
  %shr171 = ashr i64 %25, 2
  %conv172 = trunc i64 %shr171 to i8
  %conv173 = sext i8 %conv172 to i32
  %add174 = add nsw i32 0, %conv173
  %mul175 = mul nsw i32 0, %add174
  %add176 = add nsw i32 %mul175, 0
  br label %cond.end.177

cond.end.177:                                     ; preds = %cond.false.170, %cond.true.148
  %cond178 = phi i32 [ %sub169, %cond.true.148 ], [ %add176, %cond.false.170 ]
  %div179 = sdiv i32 %cond178, 8
  %cmp180 = icmp slt i32 %conv139, %div179
  br i1 %cmp180, label %cond.true.240, label %lor.lhs.false.217

cond.false.182:                                   ; preds = %cond.false.130
  %26 = load i64, i64* %elt, align 8
  %shr183 = ashr i64 %26, 2
  %conv184 = trunc i64 %shr183 to i8
  %conv185 = sext i8 %conv184 to i32
  %add186 = add nsw i32 0, %conv185
  %mul187 = mul nsw i32 0, %add186
  %sub188 = sub nsw i32 %mul187, 1
  %cmp189 = icmp slt i32 %sub188, 0
  br i1 %cmp189, label %cond.true.191, label %cond.false.202

cond.true.191:                                    ; preds = %cond.false.182
  %27 = load i64, i64* %elt, align 8
  %shr192 = ashr i64 %27, 2
  %conv193 = trunc i64 %shr192 to i8
  %conv194 = sext i8 %conv193 to i32
  %add195 = add nsw i32 0, %conv194
  %mul196 = mul nsw i32 0, %add195
  %add197 = add nsw i32 %mul196, 1
  %shl198 = shl i32 %add197, 30
  %sub199 = sub nsw i32 %shl198, 1
  %mul200 = mul nsw i32 %sub199, 2
  %add201 = add nsw i32 %mul200, 1
  br label %cond.end.209

cond.false.202:                                   ; preds = %cond.false.182
  %28 = load i64, i64* %elt, align 8
  %shr203 = ashr i64 %28, 2
  %conv204 = trunc i64 %shr203 to i8
  %conv205 = sext i8 %conv204 to i32
  %add206 = add nsw i32 0, %conv205
  %mul207 = mul nsw i32 0, %add206
  %sub208 = sub nsw i32 %mul207, 1
  br label %cond.end.209

cond.end.209:                                     ; preds = %cond.false.202, %cond.true.191
  %cond210 = phi i32 [ %add201, %cond.true.191 ], [ %sub208, %cond.false.202 ]
  %div211 = sdiv i32 %cond210, 8
  %29 = load i64, i64* %elt, align 8
  %shr212 = ashr i64 %29, 2
  %conv213 = trunc i64 %shr212 to i8
  %conv214 = sext i8 %conv213 to i32
  %cmp215 = icmp slt i32 %div211, %conv214
  br i1 %cmp215, label %cond.true.240, label %lor.lhs.false.217

lor.lhs.false.217:                                ; preds = %cond.end.209, %cond.end.177, %cond.true.129, %cond.end.120, %cond.true.81, %cond.end.76
  %30 = load i64, i64* %elt, align 8
  %shr218 = ashr i64 %30, 2
  %conv219 = trunc i64 %shr218 to i8
  %conv220 = sext i8 %conv219 to i32
  %mul221 = mul nsw i32 %conv220, 8
  %mul222 = mul nsw i32 0, %mul221
  %sub223 = sub nsw i32 %mul222, 1
  %cmp224 = icmp slt i32 %sub223, 0
  br i1 %cmp224, label %land.lhs.true.226, label %lor.lhs.false.233

land.lhs.true.226:                                ; preds = %lor.lhs.false.217
  %31 = load i64, i64* %elt, align 8
  %shr227 = ashr i64 %31, 2
  %conv228 = trunc i64 %shr227 to i8
  %conv229 = sext i8 %conv228 to i32
  %mul230 = mul nsw i32 %conv229, 8
  %cmp231 = icmp slt i32 %mul230, -128
  br i1 %cmp231, label %cond.true.240, label %lor.lhs.false.233

lor.lhs.false.233:                                ; preds = %land.lhs.true.226, %lor.lhs.false.217
  %32 = load i64, i64* %elt, align 8
  %shr234 = ashr i64 %32, 2
  %conv235 = trunc i64 %shr234 to i8
  %conv236 = sext i8 %conv235 to i32
  %mul237 = mul nsw i32 %conv236, 8
  %cmp238 = icmp slt i32 127, %mul237
  br i1 %cmp238, label %cond.true.240, label %cond.false.266

cond.true.240:                                    ; preds = %lor.lhs.false.233, %land.lhs.true.226, %cond.end.209, %cond.end.177, %cond.true.129, %cond.end.120, %cond.true.81, %cond.end.76, %land.lhs.true
  %33 = load i64, i64* %elt, align 8
  %shr241 = ashr i64 %33, 2
  %conv242 = trunc i64 %shr241 to i8
  %conv243 = zext i8 %conv242 to i32
  %mul244 = mul nsw i32 %conv243, 8
  %cmp245 = icmp sle i32 %mul244, 127
  br i1 %cmp245, label %cond.true.247, label %cond.false.254

cond.true.247:                                    ; preds = %cond.true.240
  %34 = load i64, i64* %elt, align 8
  %shr248 = ashr i64 %34, 2
  %conv249 = trunc i64 %shr248 to i8
  %conv250 = zext i8 %conv249 to i32
  %mul251 = mul nsw i32 %conv250, 8
  %conv252 = trunc i32 %mul251 to i8
  %conv253 = sext i8 %conv252 to i32
  br label %cond.end.263

cond.false.254:                                   ; preds = %cond.true.240
  %35 = load i64, i64* %elt, align 8
  %shr255 = ashr i64 %35, 2
  %conv256 = trunc i64 %shr255 to i8
  %conv257 = zext i8 %conv256 to i32
  %mul258 = mul nsw i32 %conv257, 8
  %sub259 = sub nsw i32 %mul258, -128
  %conv260 = trunc i32 %sub259 to i8
  %conv261 = sext i8 %conv260 to i32
  %add262 = add nsw i32 %conv261, -128
  br label %cond.end.263

cond.end.263:                                     ; preds = %cond.false.254, %cond.true.247
  %cond264 = phi i32 [ %conv253, %cond.true.247 ], [ %add262, %cond.false.254 ]
  %conv265 = sext i32 %cond264 to i64
  store i64 %conv265, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then, label %lor.lhs.false.2502

cond.false.266:                                   ; preds = %lor.lhs.false.233
  %36 = load i64, i64* %elt, align 8
  %shr267 = ashr i64 %36, 2
  %conv268 = trunc i64 %shr267 to i8
  %conv269 = zext i8 %conv268 to i32
  %mul270 = mul nsw i32 %conv269, 8
  %cmp271 = icmp sle i32 %mul270, 127
  br i1 %cmp271, label %cond.true.273, label %cond.false.280

cond.true.273:                                    ; preds = %cond.false.266
  %37 = load i64, i64* %elt, align 8
  %shr274 = ashr i64 %37, 2
  %conv275 = trunc i64 %shr274 to i8
  %conv276 = zext i8 %conv275 to i32
  %mul277 = mul nsw i32 %conv276, 8
  %conv278 = trunc i32 %mul277 to i8
  %conv279 = sext i8 %conv278 to i32
  br label %cond.end.289

cond.false.280:                                   ; preds = %cond.false.266
  %38 = load i64, i64* %elt, align 8
  %shr281 = ashr i64 %38, 2
  %conv282 = trunc i64 %shr281 to i8
  %conv283 = zext i8 %conv282 to i32
  %mul284 = mul nsw i32 %conv283, 8
  %sub285 = sub nsw i32 %mul284, -128
  %conv286 = trunc i32 %sub285 to i8
  %conv287 = sext i8 %conv286 to i32
  %add288 = add nsw i32 %conv287, -128
  br label %cond.end.289

cond.end.289:                                     ; preds = %cond.false.280, %cond.true.273
  %cond290 = phi i32 [ %conv279, %cond.true.273 ], [ %add288, %cond.false.280 ]
  %conv291 = sext i32 %cond290 to i64
  store i64 %conv291, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then, label %lor.lhs.false.2502

cond.false.292:                                   ; preds = %cond.true
  %39 = load i64, i64* %elt, align 8
  %shr293 = ashr i64 %39, 2
  %add294 = add nsw i64 0, %shr293
  %mul295 = mul nsw i64 0, %add294
  %sub296 = sub nsw i64 %mul295, 1
  %cmp297 = icmp slt i64 %sub296, 0
  br i1 %cmp297, label %cond.true.299, label %cond.false.318

cond.true.299:                                    ; preds = %cond.false.292
  %40 = load i64, i64* %elt, align 8
  %shr300 = ashr i64 %40, 2
  %add301 = add nsw i64 0, %shr300
  %mul302 = mul nsw i64 0, %add301
  %add303 = add nsw i64 %mul302, 0
  %neg304 = xor i64 %add303, -1
  %cmp305 = icmp eq i64 %neg304, -1
  %conv306 = zext i1 %cmp305 to i32
  %sub307 = sub nsw i32 0, %conv306
  %conv308 = sext i32 %sub307 to i64
  %41 = load i64, i64* %elt, align 8
  %shr309 = ashr i64 %41, 2
  %add310 = add nsw i64 0, %shr309
  %mul311 = mul nsw i64 0, %add310
  %add312 = add nsw i64 %mul311, 1
  %shl313 = shl i64 %add312, 62
  %sub314 = sub nsw i64 %shl313, 1
  %mul315 = mul nsw i64 %sub314, 2
  %add316 = add nsw i64 %mul315, 1
  %sub317 = sub nsw i64 %conv308, %add316
  br label %cond.end.323

cond.false.318:                                   ; preds = %cond.false.292
  %42 = load i64, i64* %elt, align 8
  %shr319 = ashr i64 %42, 2
  %add320 = add nsw i64 0, %shr319
  %mul321 = mul nsw i64 0, %add320
  %add322 = add nsw i64 %mul321, 0
  br label %cond.end.323

cond.end.323:                                     ; preds = %cond.false.318, %cond.true.299
  %cond324 = phi i64 [ %sub317, %cond.true.299 ], [ %add322, %cond.false.318 ]
  %cmp325 = icmp eq i64 %cond324, 0
  br i1 %cmp325, label %land.lhs.true.327, label %lor.lhs.false.331

land.lhs.true.327:                                ; preds = %cond.end.323
  %43 = load i64, i64* %elt, align 8
  %shr328 = ashr i64 %43, 2
  %cmp329 = icmp slt i64 %shr328, 0
  br i1 %cmp329, label %cond.true.489, label %lor.lhs.false.331

lor.lhs.false.331:                                ; preds = %land.lhs.true.327, %cond.end.323
  br i1 false, label %cond.true.332, label %cond.false.402

cond.true.332:                                    ; preds = %lor.lhs.false.331
  %44 = load i64, i64* %elt, align 8
  %shr333 = ashr i64 %44, 2
  %cmp334 = icmp slt i64 %shr333, 0
  br i1 %cmp334, label %cond.true.336, label %cond.false.363

cond.true.336:                                    ; preds = %cond.true.332
  %45 = load i64, i64* %elt, align 8
  %shr337 = ashr i64 %45, 2
  %46 = load i64, i64* %elt, align 8
  %shr338 = ashr i64 %46, 2
  %add339 = add nsw i64 0, %shr338
  %mul340 = mul nsw i64 0, %add339
  %sub341 = sub nsw i64 %mul340, 1
  %cmp342 = icmp slt i64 %sub341, 0
  br i1 %cmp342, label %cond.true.344, label %cond.false.353

cond.true.344:                                    ; preds = %cond.true.336
  %47 = load i64, i64* %elt, align 8
  %shr345 = ashr i64 %47, 2
  %add346 = add nsw i64 0, %shr345
  %mul347 = mul nsw i64 0, %add346
  %add348 = add nsw i64 %mul347, 1
  %shl349 = shl i64 %add348, 62
  %sub350 = sub nsw i64 %shl349, 1
  %mul351 = mul nsw i64 %sub350, 2
  %add352 = add nsw i64 %mul351, 1
  br label %cond.end.358

cond.false.353:                                   ; preds = %cond.true.336
  %48 = load i64, i64* %elt, align 8
  %shr354 = ashr i64 %48, 2
  %add355 = add nsw i64 0, %shr354
  %mul356 = mul nsw i64 0, %add355
  %sub357 = sub nsw i64 %mul356, 1
  br label %cond.end.358

cond.end.358:                                     ; preds = %cond.false.353, %cond.true.344
  %cond359 = phi i64 [ %add352, %cond.true.344 ], [ %sub357, %cond.false.353 ]
  %div360 = sdiv i64 %cond359, 8
  %cmp361 = icmp slt i64 %shr337, %div360
  br i1 %cmp361, label %cond.true.489, label %lor.lhs.false.472

cond.false.363:                                   ; preds = %cond.true.332
  br i1 false, label %cond.true.364, label %cond.false.365

cond.true.364:                                    ; preds = %cond.false.363
  br i1 false, label %cond.true.489, label %lor.lhs.false.472

cond.false.365:                                   ; preds = %cond.false.363
  %49 = load i64, i64* %elt, align 8
  %shr366 = ashr i64 %49, 2
  %add367 = add nsw i64 0, %shr366
  %mul368 = mul nsw i64 0, %add367
  %sub369 = sub nsw i64 %mul368, 1
  %cmp370 = icmp slt i64 %sub369, 0
  br i1 %cmp370, label %cond.true.372, label %cond.false.391

cond.true.372:                                    ; preds = %cond.false.365
  %50 = load i64, i64* %elt, align 8
  %shr373 = ashr i64 %50, 2
  %add374 = add nsw i64 0, %shr373
  %mul375 = mul nsw i64 0, %add374
  %add376 = add nsw i64 %mul375, 0
  %neg377 = xor i64 %add376, -1
  %cmp378 = icmp eq i64 %neg377, -1
  %conv379 = zext i1 %cmp378 to i32
  %sub380 = sub nsw i32 0, %conv379
  %conv381 = sext i32 %sub380 to i64
  %51 = load i64, i64* %elt, align 8
  %shr382 = ashr i64 %51, 2
  %add383 = add nsw i64 0, %shr382
  %mul384 = mul nsw i64 0, %add383
  %add385 = add nsw i64 %mul384, 1
  %shl386 = shl i64 %add385, 62
  %sub387 = sub nsw i64 %shl386, 1
  %mul388 = mul nsw i64 %sub387, 2
  %add389 = add nsw i64 %mul388, 1
  %sub390 = sub nsw i64 %conv381, %add389
  br label %cond.end.396

cond.false.391:                                   ; preds = %cond.false.365
  %52 = load i64, i64* %elt, align 8
  %shr392 = ashr i64 %52, 2
  %add393 = add nsw i64 0, %shr392
  %mul394 = mul nsw i64 0, %add393
  %add395 = add nsw i64 %mul394, 0
  br label %cond.end.396

cond.end.396:                                     ; preds = %cond.false.391, %cond.true.372
  %cond397 = phi i64 [ %sub390, %cond.true.372 ], [ %add395, %cond.false.391 ]
  %div398 = sdiv i64 %cond397, 8
  %53 = load i64, i64* %elt, align 8
  %shr399 = ashr i64 %53, 2
  %cmp400 = icmp slt i64 %div398, %shr399
  br i1 %cmp400, label %cond.true.489, label %lor.lhs.false.472

cond.false.402:                                   ; preds = %lor.lhs.false.331
  br i1 false, label %cond.true.403, label %cond.false.404

cond.true.403:                                    ; preds = %cond.false.402
  br i1 false, label %cond.true.489, label %lor.lhs.false.472

cond.false.404:                                   ; preds = %cond.false.402
  %54 = load i64, i64* %elt, align 8
  %shr405 = ashr i64 %54, 2
  %cmp406 = icmp slt i64 %shr405, 0
  br i1 %cmp406, label %cond.true.408, label %cond.false.445

cond.true.408:                                    ; preds = %cond.false.404
  %55 = load i64, i64* %elt, align 8
  %shr409 = ashr i64 %55, 2
  %56 = load i64, i64* %elt, align 8
  %shr410 = ashr i64 %56, 2
  %add411 = add nsw i64 0, %shr410
  %mul412 = mul nsw i64 0, %add411
  %sub413 = sub nsw i64 %mul412, 1
  %cmp414 = icmp slt i64 %sub413, 0
  br i1 %cmp414, label %cond.true.416, label %cond.false.435

cond.true.416:                                    ; preds = %cond.true.408
  %57 = load i64, i64* %elt, align 8
  %shr417 = ashr i64 %57, 2
  %add418 = add nsw i64 0, %shr417
  %mul419 = mul nsw i64 0, %add418
  %add420 = add nsw i64 %mul419, 0
  %neg421 = xor i64 %add420, -1
  %cmp422 = icmp eq i64 %neg421, -1
  %conv423 = zext i1 %cmp422 to i32
  %sub424 = sub nsw i32 0, %conv423
  %conv425 = sext i32 %sub424 to i64
  %58 = load i64, i64* %elt, align 8
  %shr426 = ashr i64 %58, 2
  %add427 = add nsw i64 0, %shr426
  %mul428 = mul nsw i64 0, %add427
  %add429 = add nsw i64 %mul428, 1
  %shl430 = shl i64 %add429, 62
  %sub431 = sub nsw i64 %shl430, 1
  %mul432 = mul nsw i64 %sub431, 2
  %add433 = add nsw i64 %mul432, 1
  %sub434 = sub nsw i64 %conv425, %add433
  br label %cond.end.440

cond.false.435:                                   ; preds = %cond.true.408
  %59 = load i64, i64* %elt, align 8
  %shr436 = ashr i64 %59, 2
  %add437 = add nsw i64 0, %shr436
  %mul438 = mul nsw i64 0, %add437
  %add439 = add nsw i64 %mul438, 0
  br label %cond.end.440

cond.end.440:                                     ; preds = %cond.false.435, %cond.true.416
  %cond441 = phi i64 [ %sub434, %cond.true.416 ], [ %add439, %cond.false.435 ]
  %div442 = sdiv i64 %cond441, 8
  %cmp443 = icmp slt i64 %shr409, %div442
  br i1 %cmp443, label %cond.true.489, label %lor.lhs.false.472

cond.false.445:                                   ; preds = %cond.false.404
  %60 = load i64, i64* %elt, align 8
  %shr446 = ashr i64 %60, 2
  %add447 = add nsw i64 0, %shr446
  %mul448 = mul nsw i64 0, %add447
  %sub449 = sub nsw i64 %mul448, 1
  %cmp450 = icmp slt i64 %sub449, 0
  br i1 %cmp450, label %cond.true.452, label %cond.false.461

cond.true.452:                                    ; preds = %cond.false.445
  %61 = load i64, i64* %elt, align 8
  %shr453 = ashr i64 %61, 2
  %add454 = add nsw i64 0, %shr453
  %mul455 = mul nsw i64 0, %add454
  %add456 = add nsw i64 %mul455, 1
  %shl457 = shl i64 %add456, 62
  %sub458 = sub nsw i64 %shl457, 1
  %mul459 = mul nsw i64 %sub458, 2
  %add460 = add nsw i64 %mul459, 1
  br label %cond.end.466

cond.false.461:                                   ; preds = %cond.false.445
  %62 = load i64, i64* %elt, align 8
  %shr462 = ashr i64 %62, 2
  %add463 = add nsw i64 0, %shr462
  %mul464 = mul nsw i64 0, %add463
  %sub465 = sub nsw i64 %mul464, 1
  br label %cond.end.466

cond.end.466:                                     ; preds = %cond.false.461, %cond.true.452
  %cond467 = phi i64 [ %add460, %cond.true.452 ], [ %sub465, %cond.false.461 ]
  %div468 = sdiv i64 %cond467, 8
  %63 = load i64, i64* %elt, align 8
  %shr469 = ashr i64 %63, 2
  %cmp470 = icmp slt i64 %div468, %shr469
  br i1 %cmp470, label %cond.true.489, label %lor.lhs.false.472

lor.lhs.false.472:                                ; preds = %cond.end.466, %cond.end.440, %cond.true.403, %cond.end.396, %cond.true.364, %cond.end.358
  %64 = load i64, i64* %elt, align 8
  %shr473 = ashr i64 %64, 2
  %mul474 = mul nsw i64 %shr473, 8
  %mul475 = mul nsw i64 0, %mul474
  %sub476 = sub nsw i64 %mul475, 1
  %cmp477 = icmp slt i64 %sub476, 0
  br i1 %cmp477, label %land.lhs.true.479, label %lor.lhs.false.484

land.lhs.true.479:                                ; preds = %lor.lhs.false.472
  %65 = load i64, i64* %elt, align 8
  %shr480 = ashr i64 %65, 2
  %mul481 = mul nsw i64 %shr480, 8
  %cmp482 = icmp slt i64 %mul481, -128
  br i1 %cmp482, label %cond.true.489, label %lor.lhs.false.484

lor.lhs.false.484:                                ; preds = %land.lhs.true.479, %lor.lhs.false.472
  %66 = load i64, i64* %elt, align 8
  %shr485 = ashr i64 %66, 2
  %mul486 = mul nsw i64 %shr485, 8
  %cmp487 = icmp slt i64 127, %mul486
  br i1 %cmp487, label %cond.true.489, label %cond.false.515

cond.true.489:                                    ; preds = %lor.lhs.false.484, %land.lhs.true.479, %cond.end.466, %cond.end.440, %cond.true.403, %cond.end.396, %cond.true.364, %cond.end.358, %land.lhs.true.327
  %67 = load i64, i64* %elt, align 8
  %shr490 = ashr i64 %67, 2
  %conv491 = trunc i64 %shr490 to i8
  %conv492 = zext i8 %conv491 to i32
  %mul493 = mul nsw i32 %conv492, 8
  %cmp494 = icmp sle i32 %mul493, 127
  br i1 %cmp494, label %cond.true.496, label %cond.false.503

cond.true.496:                                    ; preds = %cond.true.489
  %68 = load i64, i64* %elt, align 8
  %shr497 = ashr i64 %68, 2
  %conv498 = trunc i64 %shr497 to i8
  %conv499 = zext i8 %conv498 to i32
  %mul500 = mul nsw i32 %conv499, 8
  %conv501 = trunc i32 %mul500 to i8
  %conv502 = sext i8 %conv501 to i32
  br label %cond.end.512

cond.false.503:                                   ; preds = %cond.true.489
  %69 = load i64, i64* %elt, align 8
  %shr504 = ashr i64 %69, 2
  %conv505 = trunc i64 %shr504 to i8
  %conv506 = zext i8 %conv505 to i32
  %mul507 = mul nsw i32 %conv506, 8
  %sub508 = sub nsw i32 %mul507, -128
  %conv509 = trunc i32 %sub508 to i8
  %conv510 = sext i8 %conv509 to i32
  %add511 = add nsw i32 %conv510, -128
  br label %cond.end.512

cond.end.512:                                     ; preds = %cond.false.503, %cond.true.496
  %cond513 = phi i32 [ %conv502, %cond.true.496 ], [ %add511, %cond.false.503 ]
  %conv514 = sext i32 %cond513 to i64
  store i64 %conv514, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then, label %lor.lhs.false.2502

cond.false.515:                                   ; preds = %lor.lhs.false.484
  %70 = load i64, i64* %elt, align 8
  %shr516 = ashr i64 %70, 2
  %conv517 = trunc i64 %shr516 to i8
  %conv518 = zext i8 %conv517 to i32
  %mul519 = mul nsw i32 %conv518, 8
  %cmp520 = icmp sle i32 %mul519, 127
  br i1 %cmp520, label %cond.true.522, label %cond.false.529

cond.true.522:                                    ; preds = %cond.false.515
  %71 = load i64, i64* %elt, align 8
  %shr523 = ashr i64 %71, 2
  %conv524 = trunc i64 %shr523 to i8
  %conv525 = zext i8 %conv524 to i32
  %mul526 = mul nsw i32 %conv525, 8
  %conv527 = trunc i32 %mul526 to i8
  %conv528 = sext i8 %conv527 to i32
  br label %cond.end.538

cond.false.529:                                   ; preds = %cond.false.515
  %72 = load i64, i64* %elt, align 8
  %shr530 = ashr i64 %72, 2
  %conv531 = trunc i64 %shr530 to i8
  %conv532 = zext i8 %conv531 to i32
  %mul533 = mul nsw i32 %conv532, 8
  %sub534 = sub nsw i32 %mul533, -128
  %conv535 = trunc i32 %sub534 to i8
  %conv536 = sext i8 %conv535 to i32
  %add537 = add nsw i32 %conv536, -128
  br label %cond.end.538

cond.end.538:                                     ; preds = %cond.false.529, %cond.true.522
  %cond539 = phi i32 [ %conv528, %cond.true.522 ], [ %add537, %cond.false.529 ]
  %conv540 = sext i32 %cond539 to i64
  store i64 %conv540, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then, label %lor.lhs.false.2502

cond.false.541:                                   ; preds = %do.body
  br i1 false, label %cond.true.542, label %cond.false.1094

cond.true.542:                                    ; preds = %cond.false.541
  br i1 false, label %cond.true.543, label %cond.false.845

cond.true.543:                                    ; preds = %cond.true.542
  %73 = load i64, i64* %elt, align 8
  %shr544 = ashr i64 %73, 2
  %conv545 = trunc i64 %shr544 to i16
  %conv546 = sext i16 %conv545 to i32
  %add547 = add nsw i32 0, %conv546
  %mul548 = mul nsw i32 0, %add547
  %sub549 = sub nsw i32 %mul548, 1
  %cmp550 = icmp slt i32 %sub549, 0
  br i1 %cmp550, label %cond.true.552, label %cond.false.574

cond.true.552:                                    ; preds = %cond.true.543
  %74 = load i64, i64* %elt, align 8
  %shr553 = ashr i64 %74, 2
  %conv554 = trunc i64 %shr553 to i16
  %conv555 = sext i16 %conv554 to i32
  %add556 = add nsw i32 0, %conv555
  %mul557 = mul nsw i32 0, %add556
  %add558 = add nsw i32 %mul557, 0
  %neg559 = xor i32 %add558, -1
  %cmp560 = icmp eq i32 %neg559, -1
  %conv561 = zext i1 %cmp560 to i32
  %sub562 = sub nsw i32 0, %conv561
  %75 = load i64, i64* %elt, align 8
  %shr563 = ashr i64 %75, 2
  %conv564 = trunc i64 %shr563 to i16
  %conv565 = sext i16 %conv564 to i32
  %add566 = add nsw i32 0, %conv565
  %mul567 = mul nsw i32 0, %add566
  %add568 = add nsw i32 %mul567, 1
  %shl569 = shl i32 %add568, 30
  %sub570 = sub nsw i32 %shl569, 1
  %mul571 = mul nsw i32 %sub570, 2
  %add572 = add nsw i32 %mul571, 1
  %sub573 = sub nsw i32 %sub562, %add572
  br label %cond.end.581

cond.false.574:                                   ; preds = %cond.true.543
  %76 = load i64, i64* %elt, align 8
  %shr575 = ashr i64 %76, 2
  %conv576 = trunc i64 %shr575 to i16
  %conv577 = sext i16 %conv576 to i32
  %add578 = add nsw i32 0, %conv577
  %mul579 = mul nsw i32 0, %add578
  %add580 = add nsw i32 %mul579, 0
  br label %cond.end.581

cond.end.581:                                     ; preds = %cond.false.574, %cond.true.552
  %cond582 = phi i32 [ %sub573, %cond.true.552 ], [ %add580, %cond.false.574 ]
  %cmp583 = icmp eq i32 %cond582, 0
  br i1 %cmp583, label %land.lhs.true.585, label %lor.lhs.false.591

land.lhs.true.585:                                ; preds = %cond.end.581
  %77 = load i64, i64* %elt, align 8
  %shr586 = ashr i64 %77, 2
  %conv587 = trunc i64 %shr586 to i16
  %conv588 = sext i16 %conv587 to i32
  %cmp589 = icmp slt i32 %conv588, 0
  br i1 %cmp589, label %cond.true.793, label %lor.lhs.false.591

lor.lhs.false.591:                                ; preds = %land.lhs.true.585, %cond.end.581
  br i1 false, label %cond.true.592, label %cond.false.681

cond.true.592:                                    ; preds = %lor.lhs.false.591
  %78 = load i64, i64* %elt, align 8
  %shr593 = ashr i64 %78, 2
  %conv594 = trunc i64 %shr593 to i16
  %conv595 = sext i16 %conv594 to i32
  %cmp596 = icmp slt i32 %conv595, 0
  br i1 %cmp596, label %cond.true.598, label %cond.false.633

cond.true.598:                                    ; preds = %cond.true.592
  %79 = load i64, i64* %elt, align 8
  %shr599 = ashr i64 %79, 2
  %conv600 = trunc i64 %shr599 to i16
  %conv601 = sext i16 %conv600 to i32
  %80 = load i64, i64* %elt, align 8
  %shr602 = ashr i64 %80, 2
  %conv603 = trunc i64 %shr602 to i16
  %conv604 = sext i16 %conv603 to i32
  %add605 = add nsw i32 0, %conv604
  %mul606 = mul nsw i32 0, %add605
  %sub607 = sub nsw i32 %mul606, 1
  %cmp608 = icmp slt i32 %sub607, 0
  br i1 %cmp608, label %cond.true.610, label %cond.false.621

cond.true.610:                                    ; preds = %cond.true.598
  %81 = load i64, i64* %elt, align 8
  %shr611 = ashr i64 %81, 2
  %conv612 = trunc i64 %shr611 to i16
  %conv613 = sext i16 %conv612 to i32
  %add614 = add nsw i32 0, %conv613
  %mul615 = mul nsw i32 0, %add614
  %add616 = add nsw i32 %mul615, 1
  %shl617 = shl i32 %add616, 30
  %sub618 = sub nsw i32 %shl617, 1
  %mul619 = mul nsw i32 %sub618, 2
  %add620 = add nsw i32 %mul619, 1
  br label %cond.end.628

cond.false.621:                                   ; preds = %cond.true.598
  %82 = load i64, i64* %elt, align 8
  %shr622 = ashr i64 %82, 2
  %conv623 = trunc i64 %shr622 to i16
  %conv624 = sext i16 %conv623 to i32
  %add625 = add nsw i32 0, %conv624
  %mul626 = mul nsw i32 0, %add625
  %sub627 = sub nsw i32 %mul626, 1
  br label %cond.end.628

cond.end.628:                                     ; preds = %cond.false.621, %cond.true.610
  %cond629 = phi i32 [ %add620, %cond.true.610 ], [ %sub627, %cond.false.621 ]
  %div630 = sdiv i32 %cond629, 8
  %cmp631 = icmp slt i32 %conv601, %div630
  br i1 %cmp631, label %cond.true.793, label %lor.lhs.false.770

cond.false.633:                                   ; preds = %cond.true.592
  br i1 false, label %cond.true.634, label %cond.false.635

cond.true.634:                                    ; preds = %cond.false.633
  br i1 false, label %cond.true.793, label %lor.lhs.false.770

cond.false.635:                                   ; preds = %cond.false.633
  %83 = load i64, i64* %elt, align 8
  %shr636 = ashr i64 %83, 2
  %conv637 = trunc i64 %shr636 to i16
  %conv638 = sext i16 %conv637 to i32
  %add639 = add nsw i32 0, %conv638
  %mul640 = mul nsw i32 0, %add639
  %sub641 = sub nsw i32 %mul640, 1
  %cmp642 = icmp slt i32 %sub641, 0
  br i1 %cmp642, label %cond.true.644, label %cond.false.666

cond.true.644:                                    ; preds = %cond.false.635
  %84 = load i64, i64* %elt, align 8
  %shr645 = ashr i64 %84, 2
  %conv646 = trunc i64 %shr645 to i16
  %conv647 = sext i16 %conv646 to i32
  %add648 = add nsw i32 0, %conv647
  %mul649 = mul nsw i32 0, %add648
  %add650 = add nsw i32 %mul649, 0
  %neg651 = xor i32 %add650, -1
  %cmp652 = icmp eq i32 %neg651, -1
  %conv653 = zext i1 %cmp652 to i32
  %sub654 = sub nsw i32 0, %conv653
  %85 = load i64, i64* %elt, align 8
  %shr655 = ashr i64 %85, 2
  %conv656 = trunc i64 %shr655 to i16
  %conv657 = sext i16 %conv656 to i32
  %add658 = add nsw i32 0, %conv657
  %mul659 = mul nsw i32 0, %add658
  %add660 = add nsw i32 %mul659, 1
  %shl661 = shl i32 %add660, 30
  %sub662 = sub nsw i32 %shl661, 1
  %mul663 = mul nsw i32 %sub662, 2
  %add664 = add nsw i32 %mul663, 1
  %sub665 = sub nsw i32 %sub654, %add664
  br label %cond.end.673

cond.false.666:                                   ; preds = %cond.false.635
  %86 = load i64, i64* %elt, align 8
  %shr667 = ashr i64 %86, 2
  %conv668 = trunc i64 %shr667 to i16
  %conv669 = sext i16 %conv668 to i32
  %add670 = add nsw i32 0, %conv669
  %mul671 = mul nsw i32 0, %add670
  %add672 = add nsw i32 %mul671, 0
  br label %cond.end.673

cond.end.673:                                     ; preds = %cond.false.666, %cond.true.644
  %cond674 = phi i32 [ %sub665, %cond.true.644 ], [ %add672, %cond.false.666 ]
  %div675 = sdiv i32 %cond674, 8
  %87 = load i64, i64* %elt, align 8
  %shr676 = ashr i64 %87, 2
  %conv677 = trunc i64 %shr676 to i16
  %conv678 = sext i16 %conv677 to i32
  %cmp679 = icmp slt i32 %div675, %conv678
  br i1 %cmp679, label %cond.true.793, label %lor.lhs.false.770

cond.false.681:                                   ; preds = %lor.lhs.false.591
  br i1 false, label %cond.true.682, label %cond.false.683

cond.true.682:                                    ; preds = %cond.false.681
  br i1 false, label %cond.true.793, label %lor.lhs.false.770

cond.false.683:                                   ; preds = %cond.false.681
  %88 = load i64, i64* %elt, align 8
  %shr684 = ashr i64 %88, 2
  %conv685 = trunc i64 %shr684 to i16
  %conv686 = sext i16 %conv685 to i32
  %cmp687 = icmp slt i32 %conv686, 0
  br i1 %cmp687, label %cond.true.689, label %cond.false.735

cond.true.689:                                    ; preds = %cond.false.683
  %89 = load i64, i64* %elt, align 8
  %shr690 = ashr i64 %89, 2
  %conv691 = trunc i64 %shr690 to i16
  %conv692 = sext i16 %conv691 to i32
  %90 = load i64, i64* %elt, align 8
  %shr693 = ashr i64 %90, 2
  %conv694 = trunc i64 %shr693 to i16
  %conv695 = sext i16 %conv694 to i32
  %add696 = add nsw i32 0, %conv695
  %mul697 = mul nsw i32 0, %add696
  %sub698 = sub nsw i32 %mul697, 1
  %cmp699 = icmp slt i32 %sub698, 0
  br i1 %cmp699, label %cond.true.701, label %cond.false.723

cond.true.701:                                    ; preds = %cond.true.689
  %91 = load i64, i64* %elt, align 8
  %shr702 = ashr i64 %91, 2
  %conv703 = trunc i64 %shr702 to i16
  %conv704 = sext i16 %conv703 to i32
  %add705 = add nsw i32 0, %conv704
  %mul706 = mul nsw i32 0, %add705
  %add707 = add nsw i32 %mul706, 0
  %neg708 = xor i32 %add707, -1
  %cmp709 = icmp eq i32 %neg708, -1
  %conv710 = zext i1 %cmp709 to i32
  %sub711 = sub nsw i32 0, %conv710
  %92 = load i64, i64* %elt, align 8
  %shr712 = ashr i64 %92, 2
  %conv713 = trunc i64 %shr712 to i16
  %conv714 = sext i16 %conv713 to i32
  %add715 = add nsw i32 0, %conv714
  %mul716 = mul nsw i32 0, %add715
  %add717 = add nsw i32 %mul716, 1
  %shl718 = shl i32 %add717, 30
  %sub719 = sub nsw i32 %shl718, 1
  %mul720 = mul nsw i32 %sub719, 2
  %add721 = add nsw i32 %mul720, 1
  %sub722 = sub nsw i32 %sub711, %add721
  br label %cond.end.730

cond.false.723:                                   ; preds = %cond.true.689
  %93 = load i64, i64* %elt, align 8
  %shr724 = ashr i64 %93, 2
  %conv725 = trunc i64 %shr724 to i16
  %conv726 = sext i16 %conv725 to i32
  %add727 = add nsw i32 0, %conv726
  %mul728 = mul nsw i32 0, %add727
  %add729 = add nsw i32 %mul728, 0
  br label %cond.end.730

cond.end.730:                                     ; preds = %cond.false.723, %cond.true.701
  %cond731 = phi i32 [ %sub722, %cond.true.701 ], [ %add729, %cond.false.723 ]
  %div732 = sdiv i32 %cond731, 8
  %cmp733 = icmp slt i32 %conv692, %div732
  br i1 %cmp733, label %cond.true.793, label %lor.lhs.false.770

cond.false.735:                                   ; preds = %cond.false.683
  %94 = load i64, i64* %elt, align 8
  %shr736 = ashr i64 %94, 2
  %conv737 = trunc i64 %shr736 to i16
  %conv738 = sext i16 %conv737 to i32
  %add739 = add nsw i32 0, %conv738
  %mul740 = mul nsw i32 0, %add739
  %sub741 = sub nsw i32 %mul740, 1
  %cmp742 = icmp slt i32 %sub741, 0
  br i1 %cmp742, label %cond.true.744, label %cond.false.755

cond.true.744:                                    ; preds = %cond.false.735
  %95 = load i64, i64* %elt, align 8
  %shr745 = ashr i64 %95, 2
  %conv746 = trunc i64 %shr745 to i16
  %conv747 = sext i16 %conv746 to i32
  %add748 = add nsw i32 0, %conv747
  %mul749 = mul nsw i32 0, %add748
  %add750 = add nsw i32 %mul749, 1
  %shl751 = shl i32 %add750, 30
  %sub752 = sub nsw i32 %shl751, 1
  %mul753 = mul nsw i32 %sub752, 2
  %add754 = add nsw i32 %mul753, 1
  br label %cond.end.762

cond.false.755:                                   ; preds = %cond.false.735
  %96 = load i64, i64* %elt, align 8
  %shr756 = ashr i64 %96, 2
  %conv757 = trunc i64 %shr756 to i16
  %conv758 = sext i16 %conv757 to i32
  %add759 = add nsw i32 0, %conv758
  %mul760 = mul nsw i32 0, %add759
  %sub761 = sub nsw i32 %mul760, 1
  br label %cond.end.762

cond.end.762:                                     ; preds = %cond.false.755, %cond.true.744
  %cond763 = phi i32 [ %add754, %cond.true.744 ], [ %sub761, %cond.false.755 ]
  %div764 = sdiv i32 %cond763, 8
  %97 = load i64, i64* %elt, align 8
  %shr765 = ashr i64 %97, 2
  %conv766 = trunc i64 %shr765 to i16
  %conv767 = sext i16 %conv766 to i32
  %cmp768 = icmp slt i32 %div764, %conv767
  br i1 %cmp768, label %cond.true.793, label %lor.lhs.false.770

lor.lhs.false.770:                                ; preds = %cond.end.762, %cond.end.730, %cond.true.682, %cond.end.673, %cond.true.634, %cond.end.628
  %98 = load i64, i64* %elt, align 8
  %shr771 = ashr i64 %98, 2
  %conv772 = trunc i64 %shr771 to i16
  %conv773 = sext i16 %conv772 to i32
  %mul774 = mul nsw i32 %conv773, 8
  %mul775 = mul nsw i32 0, %mul774
  %sub776 = sub nsw i32 %mul775, 1
  %cmp777 = icmp slt i32 %sub776, 0
  br i1 %cmp777, label %land.lhs.true.779, label %lor.lhs.false.786

land.lhs.true.779:                                ; preds = %lor.lhs.false.770
  %99 = load i64, i64* %elt, align 8
  %shr780 = ashr i64 %99, 2
  %conv781 = trunc i64 %shr780 to i16
  %conv782 = sext i16 %conv781 to i32
  %mul783 = mul nsw i32 %conv782, 8
  %cmp784 = icmp slt i32 %mul783, -32768
  br i1 %cmp784, label %cond.true.793, label %lor.lhs.false.786

lor.lhs.false.786:                                ; preds = %land.lhs.true.779, %lor.lhs.false.770
  %100 = load i64, i64* %elt, align 8
  %shr787 = ashr i64 %100, 2
  %conv788 = trunc i64 %shr787 to i16
  %conv789 = sext i16 %conv788 to i32
  %mul790 = mul nsw i32 %conv789, 8
  %cmp791 = icmp slt i32 32767, %mul790
  br i1 %cmp791, label %cond.true.793, label %cond.false.819

cond.true.793:                                    ; preds = %lor.lhs.false.786, %land.lhs.true.779, %cond.end.762, %cond.end.730, %cond.true.682, %cond.end.673, %cond.true.634, %cond.end.628, %land.lhs.true.585
  %101 = load i64, i64* %elt, align 8
  %shr794 = ashr i64 %101, 2
  %conv795 = trunc i64 %shr794 to i16
  %conv796 = zext i16 %conv795 to i32
  %mul797 = mul nsw i32 %conv796, 8
  %cmp798 = icmp sle i32 %mul797, 32767
  br i1 %cmp798, label %cond.true.800, label %cond.false.807

cond.true.800:                                    ; preds = %cond.true.793
  %102 = load i64, i64* %elt, align 8
  %shr801 = ashr i64 %102, 2
  %conv802 = trunc i64 %shr801 to i16
  %conv803 = zext i16 %conv802 to i32
  %mul804 = mul nsw i32 %conv803, 8
  %conv805 = trunc i32 %mul804 to i16
  %conv806 = sext i16 %conv805 to i32
  br label %cond.end.816

cond.false.807:                                   ; preds = %cond.true.793
  %103 = load i64, i64* %elt, align 8
  %shr808 = ashr i64 %103, 2
  %conv809 = trunc i64 %shr808 to i16
  %conv810 = zext i16 %conv809 to i32
  %mul811 = mul nsw i32 %conv810, 8
  %sub812 = sub nsw i32 %mul811, -32768
  %conv813 = trunc i32 %sub812 to i16
  %conv814 = sext i16 %conv813 to i32
  %add815 = add nsw i32 %conv814, -32768
  br label %cond.end.816

cond.end.816:                                     ; preds = %cond.false.807, %cond.true.800
  %cond817 = phi i32 [ %conv806, %cond.true.800 ], [ %add815, %cond.false.807 ]
  %conv818 = sext i32 %cond817 to i64
  store i64 %conv818, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then, label %lor.lhs.false.2502

cond.false.819:                                   ; preds = %lor.lhs.false.786
  %104 = load i64, i64* %elt, align 8
  %shr820 = ashr i64 %104, 2
  %conv821 = trunc i64 %shr820 to i16
  %conv822 = zext i16 %conv821 to i32
  %mul823 = mul nsw i32 %conv822, 8
  %cmp824 = icmp sle i32 %mul823, 32767
  br i1 %cmp824, label %cond.true.826, label %cond.false.833

cond.true.826:                                    ; preds = %cond.false.819
  %105 = load i64, i64* %elt, align 8
  %shr827 = ashr i64 %105, 2
  %conv828 = trunc i64 %shr827 to i16
  %conv829 = zext i16 %conv828 to i32
  %mul830 = mul nsw i32 %conv829, 8
  %conv831 = trunc i32 %mul830 to i16
  %conv832 = sext i16 %conv831 to i32
  br label %cond.end.842

cond.false.833:                                   ; preds = %cond.false.819
  %106 = load i64, i64* %elt, align 8
  %shr834 = ashr i64 %106, 2
  %conv835 = trunc i64 %shr834 to i16
  %conv836 = zext i16 %conv835 to i32
  %mul837 = mul nsw i32 %conv836, 8
  %sub838 = sub nsw i32 %mul837, -32768
  %conv839 = trunc i32 %sub838 to i16
  %conv840 = sext i16 %conv839 to i32
  %add841 = add nsw i32 %conv840, -32768
  br label %cond.end.842

cond.end.842:                                     ; preds = %cond.false.833, %cond.true.826
  %cond843 = phi i32 [ %conv832, %cond.true.826 ], [ %add841, %cond.false.833 ]
  %conv844 = sext i32 %cond843 to i64
  store i64 %conv844, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then, label %lor.lhs.false.2502

cond.false.845:                                   ; preds = %cond.true.542
  %107 = load i64, i64* %elt, align 8
  %shr846 = ashr i64 %107, 2
  %add847 = add nsw i64 0, %shr846
  %mul848 = mul nsw i64 0, %add847
  %sub849 = sub nsw i64 %mul848, 1
  %cmp850 = icmp slt i64 %sub849, 0
  br i1 %cmp850, label %cond.true.852, label %cond.false.871

cond.true.852:                                    ; preds = %cond.false.845
  %108 = load i64, i64* %elt, align 8
  %shr853 = ashr i64 %108, 2
  %add854 = add nsw i64 0, %shr853
  %mul855 = mul nsw i64 0, %add854
  %add856 = add nsw i64 %mul855, 0
  %neg857 = xor i64 %add856, -1
  %cmp858 = icmp eq i64 %neg857, -1
  %conv859 = zext i1 %cmp858 to i32
  %sub860 = sub nsw i32 0, %conv859
  %conv861 = sext i32 %sub860 to i64
  %109 = load i64, i64* %elt, align 8
  %shr862 = ashr i64 %109, 2
  %add863 = add nsw i64 0, %shr862
  %mul864 = mul nsw i64 0, %add863
  %add865 = add nsw i64 %mul864, 1
  %shl866 = shl i64 %add865, 62
  %sub867 = sub nsw i64 %shl866, 1
  %mul868 = mul nsw i64 %sub867, 2
  %add869 = add nsw i64 %mul868, 1
  %sub870 = sub nsw i64 %conv861, %add869
  br label %cond.end.876

cond.false.871:                                   ; preds = %cond.false.845
  %110 = load i64, i64* %elt, align 8
  %shr872 = ashr i64 %110, 2
  %add873 = add nsw i64 0, %shr872
  %mul874 = mul nsw i64 0, %add873
  %add875 = add nsw i64 %mul874, 0
  br label %cond.end.876

cond.end.876:                                     ; preds = %cond.false.871, %cond.true.852
  %cond877 = phi i64 [ %sub870, %cond.true.852 ], [ %add875, %cond.false.871 ]
  %cmp878 = icmp eq i64 %cond877, 0
  br i1 %cmp878, label %land.lhs.true.880, label %lor.lhs.false.884

land.lhs.true.880:                                ; preds = %cond.end.876
  %111 = load i64, i64* %elt, align 8
  %shr881 = ashr i64 %111, 2
  %cmp882 = icmp slt i64 %shr881, 0
  br i1 %cmp882, label %cond.true.1042, label %lor.lhs.false.884

lor.lhs.false.884:                                ; preds = %land.lhs.true.880, %cond.end.876
  br i1 false, label %cond.true.885, label %cond.false.955

cond.true.885:                                    ; preds = %lor.lhs.false.884
  %112 = load i64, i64* %elt, align 8
  %shr886 = ashr i64 %112, 2
  %cmp887 = icmp slt i64 %shr886, 0
  br i1 %cmp887, label %cond.true.889, label %cond.false.916

cond.true.889:                                    ; preds = %cond.true.885
  %113 = load i64, i64* %elt, align 8
  %shr890 = ashr i64 %113, 2
  %114 = load i64, i64* %elt, align 8
  %shr891 = ashr i64 %114, 2
  %add892 = add nsw i64 0, %shr891
  %mul893 = mul nsw i64 0, %add892
  %sub894 = sub nsw i64 %mul893, 1
  %cmp895 = icmp slt i64 %sub894, 0
  br i1 %cmp895, label %cond.true.897, label %cond.false.906

cond.true.897:                                    ; preds = %cond.true.889
  %115 = load i64, i64* %elt, align 8
  %shr898 = ashr i64 %115, 2
  %add899 = add nsw i64 0, %shr898
  %mul900 = mul nsw i64 0, %add899
  %add901 = add nsw i64 %mul900, 1
  %shl902 = shl i64 %add901, 62
  %sub903 = sub nsw i64 %shl902, 1
  %mul904 = mul nsw i64 %sub903, 2
  %add905 = add nsw i64 %mul904, 1
  br label %cond.end.911

cond.false.906:                                   ; preds = %cond.true.889
  %116 = load i64, i64* %elt, align 8
  %shr907 = ashr i64 %116, 2
  %add908 = add nsw i64 0, %shr907
  %mul909 = mul nsw i64 0, %add908
  %sub910 = sub nsw i64 %mul909, 1
  br label %cond.end.911

cond.end.911:                                     ; preds = %cond.false.906, %cond.true.897
  %cond912 = phi i64 [ %add905, %cond.true.897 ], [ %sub910, %cond.false.906 ]
  %div913 = sdiv i64 %cond912, 8
  %cmp914 = icmp slt i64 %shr890, %div913
  br i1 %cmp914, label %cond.true.1042, label %lor.lhs.false.1025

cond.false.916:                                   ; preds = %cond.true.885
  br i1 false, label %cond.true.917, label %cond.false.918

cond.true.917:                                    ; preds = %cond.false.916
  br i1 false, label %cond.true.1042, label %lor.lhs.false.1025

cond.false.918:                                   ; preds = %cond.false.916
  %117 = load i64, i64* %elt, align 8
  %shr919 = ashr i64 %117, 2
  %add920 = add nsw i64 0, %shr919
  %mul921 = mul nsw i64 0, %add920
  %sub922 = sub nsw i64 %mul921, 1
  %cmp923 = icmp slt i64 %sub922, 0
  br i1 %cmp923, label %cond.true.925, label %cond.false.944

cond.true.925:                                    ; preds = %cond.false.918
  %118 = load i64, i64* %elt, align 8
  %shr926 = ashr i64 %118, 2
  %add927 = add nsw i64 0, %shr926
  %mul928 = mul nsw i64 0, %add927
  %add929 = add nsw i64 %mul928, 0
  %neg930 = xor i64 %add929, -1
  %cmp931 = icmp eq i64 %neg930, -1
  %conv932 = zext i1 %cmp931 to i32
  %sub933 = sub nsw i32 0, %conv932
  %conv934 = sext i32 %sub933 to i64
  %119 = load i64, i64* %elt, align 8
  %shr935 = ashr i64 %119, 2
  %add936 = add nsw i64 0, %shr935
  %mul937 = mul nsw i64 0, %add936
  %add938 = add nsw i64 %mul937, 1
  %shl939 = shl i64 %add938, 62
  %sub940 = sub nsw i64 %shl939, 1
  %mul941 = mul nsw i64 %sub940, 2
  %add942 = add nsw i64 %mul941, 1
  %sub943 = sub nsw i64 %conv934, %add942
  br label %cond.end.949

cond.false.944:                                   ; preds = %cond.false.918
  %120 = load i64, i64* %elt, align 8
  %shr945 = ashr i64 %120, 2
  %add946 = add nsw i64 0, %shr945
  %mul947 = mul nsw i64 0, %add946
  %add948 = add nsw i64 %mul947, 0
  br label %cond.end.949

cond.end.949:                                     ; preds = %cond.false.944, %cond.true.925
  %cond950 = phi i64 [ %sub943, %cond.true.925 ], [ %add948, %cond.false.944 ]
  %div951 = sdiv i64 %cond950, 8
  %121 = load i64, i64* %elt, align 8
  %shr952 = ashr i64 %121, 2
  %cmp953 = icmp slt i64 %div951, %shr952
  br i1 %cmp953, label %cond.true.1042, label %lor.lhs.false.1025

cond.false.955:                                   ; preds = %lor.lhs.false.884
  br i1 false, label %cond.true.956, label %cond.false.957

cond.true.956:                                    ; preds = %cond.false.955
  br i1 false, label %cond.true.1042, label %lor.lhs.false.1025

cond.false.957:                                   ; preds = %cond.false.955
  %122 = load i64, i64* %elt, align 8
  %shr958 = ashr i64 %122, 2
  %cmp959 = icmp slt i64 %shr958, 0
  br i1 %cmp959, label %cond.true.961, label %cond.false.998

cond.true.961:                                    ; preds = %cond.false.957
  %123 = load i64, i64* %elt, align 8
  %shr962 = ashr i64 %123, 2
  %124 = load i64, i64* %elt, align 8
  %shr963 = ashr i64 %124, 2
  %add964 = add nsw i64 0, %shr963
  %mul965 = mul nsw i64 0, %add964
  %sub966 = sub nsw i64 %mul965, 1
  %cmp967 = icmp slt i64 %sub966, 0
  br i1 %cmp967, label %cond.true.969, label %cond.false.988

cond.true.969:                                    ; preds = %cond.true.961
  %125 = load i64, i64* %elt, align 8
  %shr970 = ashr i64 %125, 2
  %add971 = add nsw i64 0, %shr970
  %mul972 = mul nsw i64 0, %add971
  %add973 = add nsw i64 %mul972, 0
  %neg974 = xor i64 %add973, -1
  %cmp975 = icmp eq i64 %neg974, -1
  %conv976 = zext i1 %cmp975 to i32
  %sub977 = sub nsw i32 0, %conv976
  %conv978 = sext i32 %sub977 to i64
  %126 = load i64, i64* %elt, align 8
  %shr979 = ashr i64 %126, 2
  %add980 = add nsw i64 0, %shr979
  %mul981 = mul nsw i64 0, %add980
  %add982 = add nsw i64 %mul981, 1
  %shl983 = shl i64 %add982, 62
  %sub984 = sub nsw i64 %shl983, 1
  %mul985 = mul nsw i64 %sub984, 2
  %add986 = add nsw i64 %mul985, 1
  %sub987 = sub nsw i64 %conv978, %add986
  br label %cond.end.993

cond.false.988:                                   ; preds = %cond.true.961
  %127 = load i64, i64* %elt, align 8
  %shr989 = ashr i64 %127, 2
  %add990 = add nsw i64 0, %shr989
  %mul991 = mul nsw i64 0, %add990
  %add992 = add nsw i64 %mul991, 0
  br label %cond.end.993

cond.end.993:                                     ; preds = %cond.false.988, %cond.true.969
  %cond994 = phi i64 [ %sub987, %cond.true.969 ], [ %add992, %cond.false.988 ]
  %div995 = sdiv i64 %cond994, 8
  %cmp996 = icmp slt i64 %shr962, %div995
  br i1 %cmp996, label %cond.true.1042, label %lor.lhs.false.1025

cond.false.998:                                   ; preds = %cond.false.957
  %128 = load i64, i64* %elt, align 8
  %shr999 = ashr i64 %128, 2
  %add1000 = add nsw i64 0, %shr999
  %mul1001 = mul nsw i64 0, %add1000
  %sub1002 = sub nsw i64 %mul1001, 1
  %cmp1003 = icmp slt i64 %sub1002, 0
  br i1 %cmp1003, label %cond.true.1005, label %cond.false.1014

cond.true.1005:                                   ; preds = %cond.false.998
  %129 = load i64, i64* %elt, align 8
  %shr1006 = ashr i64 %129, 2
  %add1007 = add nsw i64 0, %shr1006
  %mul1008 = mul nsw i64 0, %add1007
  %add1009 = add nsw i64 %mul1008, 1
  %shl1010 = shl i64 %add1009, 62
  %sub1011 = sub nsw i64 %shl1010, 1
  %mul1012 = mul nsw i64 %sub1011, 2
  %add1013 = add nsw i64 %mul1012, 1
  br label %cond.end.1019

cond.false.1014:                                  ; preds = %cond.false.998
  %130 = load i64, i64* %elt, align 8
  %shr1015 = ashr i64 %130, 2
  %add1016 = add nsw i64 0, %shr1015
  %mul1017 = mul nsw i64 0, %add1016
  %sub1018 = sub nsw i64 %mul1017, 1
  br label %cond.end.1019

cond.end.1019:                                    ; preds = %cond.false.1014, %cond.true.1005
  %cond1020 = phi i64 [ %add1013, %cond.true.1005 ], [ %sub1018, %cond.false.1014 ]
  %div1021 = sdiv i64 %cond1020, 8
  %131 = load i64, i64* %elt, align 8
  %shr1022 = ashr i64 %131, 2
  %cmp1023 = icmp slt i64 %div1021, %shr1022
  br i1 %cmp1023, label %cond.true.1042, label %lor.lhs.false.1025

lor.lhs.false.1025:                               ; preds = %cond.end.1019, %cond.end.993, %cond.true.956, %cond.end.949, %cond.true.917, %cond.end.911
  %132 = load i64, i64* %elt, align 8
  %shr1026 = ashr i64 %132, 2
  %mul1027 = mul nsw i64 %shr1026, 8
  %mul1028 = mul nsw i64 0, %mul1027
  %sub1029 = sub nsw i64 %mul1028, 1
  %cmp1030 = icmp slt i64 %sub1029, 0
  br i1 %cmp1030, label %land.lhs.true.1032, label %lor.lhs.false.1037

land.lhs.true.1032:                               ; preds = %lor.lhs.false.1025
  %133 = load i64, i64* %elt, align 8
  %shr1033 = ashr i64 %133, 2
  %mul1034 = mul nsw i64 %shr1033, 8
  %cmp1035 = icmp slt i64 %mul1034, -32768
  br i1 %cmp1035, label %cond.true.1042, label %lor.lhs.false.1037

lor.lhs.false.1037:                               ; preds = %land.lhs.true.1032, %lor.lhs.false.1025
  %134 = load i64, i64* %elt, align 8
  %shr1038 = ashr i64 %134, 2
  %mul1039 = mul nsw i64 %shr1038, 8
  %cmp1040 = icmp slt i64 32767, %mul1039
  br i1 %cmp1040, label %cond.true.1042, label %cond.false.1068

cond.true.1042:                                   ; preds = %lor.lhs.false.1037, %land.lhs.true.1032, %cond.end.1019, %cond.end.993, %cond.true.956, %cond.end.949, %cond.true.917, %cond.end.911, %land.lhs.true.880
  %135 = load i64, i64* %elt, align 8
  %shr1043 = ashr i64 %135, 2
  %conv1044 = trunc i64 %shr1043 to i16
  %conv1045 = zext i16 %conv1044 to i32
  %mul1046 = mul nsw i32 %conv1045, 8
  %cmp1047 = icmp sle i32 %mul1046, 32767
  br i1 %cmp1047, label %cond.true.1049, label %cond.false.1056

cond.true.1049:                                   ; preds = %cond.true.1042
  %136 = load i64, i64* %elt, align 8
  %shr1050 = ashr i64 %136, 2
  %conv1051 = trunc i64 %shr1050 to i16
  %conv1052 = zext i16 %conv1051 to i32
  %mul1053 = mul nsw i32 %conv1052, 8
  %conv1054 = trunc i32 %mul1053 to i16
  %conv1055 = sext i16 %conv1054 to i32
  br label %cond.end.1065

cond.false.1056:                                  ; preds = %cond.true.1042
  %137 = load i64, i64* %elt, align 8
  %shr1057 = ashr i64 %137, 2
  %conv1058 = trunc i64 %shr1057 to i16
  %conv1059 = zext i16 %conv1058 to i32
  %mul1060 = mul nsw i32 %conv1059, 8
  %sub1061 = sub nsw i32 %mul1060, -32768
  %conv1062 = trunc i32 %sub1061 to i16
  %conv1063 = sext i16 %conv1062 to i32
  %add1064 = add nsw i32 %conv1063, -32768
  br label %cond.end.1065

cond.end.1065:                                    ; preds = %cond.false.1056, %cond.true.1049
  %cond1066 = phi i32 [ %conv1055, %cond.true.1049 ], [ %add1064, %cond.false.1056 ]
  %conv1067 = sext i32 %cond1066 to i64
  store i64 %conv1067, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then, label %lor.lhs.false.2502

cond.false.1068:                                  ; preds = %lor.lhs.false.1037
  %138 = load i64, i64* %elt, align 8
  %shr1069 = ashr i64 %138, 2
  %conv1070 = trunc i64 %shr1069 to i16
  %conv1071 = zext i16 %conv1070 to i32
  %mul1072 = mul nsw i32 %conv1071, 8
  %cmp1073 = icmp sle i32 %mul1072, 32767
  br i1 %cmp1073, label %cond.true.1075, label %cond.false.1082

cond.true.1075:                                   ; preds = %cond.false.1068
  %139 = load i64, i64* %elt, align 8
  %shr1076 = ashr i64 %139, 2
  %conv1077 = trunc i64 %shr1076 to i16
  %conv1078 = zext i16 %conv1077 to i32
  %mul1079 = mul nsw i32 %conv1078, 8
  %conv1080 = trunc i32 %mul1079 to i16
  %conv1081 = sext i16 %conv1080 to i32
  br label %cond.end.1091

cond.false.1082:                                  ; preds = %cond.false.1068
  %140 = load i64, i64* %elt, align 8
  %shr1083 = ashr i64 %140, 2
  %conv1084 = trunc i64 %shr1083 to i16
  %conv1085 = zext i16 %conv1084 to i32
  %mul1086 = mul nsw i32 %conv1085, 8
  %sub1087 = sub nsw i32 %mul1086, -32768
  %conv1088 = trunc i32 %sub1087 to i16
  %conv1089 = sext i16 %conv1088 to i32
  %add1090 = add nsw i32 %conv1089, -32768
  br label %cond.end.1091

cond.end.1091:                                    ; preds = %cond.false.1082, %cond.true.1075
  %cond1092 = phi i32 [ %conv1081, %cond.true.1075 ], [ %add1090, %cond.false.1082 ]
  %conv1093 = sext i32 %cond1092 to i64
  store i64 %conv1093, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then, label %lor.lhs.false.2502

cond.false.1094:                                  ; preds = %cond.false.541
  br i1 false, label %cond.true.1095, label %cond.false.1591

cond.true.1095:                                   ; preds = %cond.false.1094
  br i1 false, label %cond.true.1096, label %cond.false.1356

cond.true.1096:                                   ; preds = %cond.true.1095
  %141 = load i64, i64* %elt, align 8
  %shr1097 = ashr i64 %141, 2
  %conv1098 = trunc i64 %shr1097 to i32
  %add1099 = add nsw i32 0, %conv1098
  %mul1100 = mul nsw i32 0, %add1099
  %sub1101 = sub nsw i32 %mul1100, 1
  %cmp1102 = icmp slt i32 %sub1101, 0
  br i1 %cmp1102, label %cond.true.1104, label %cond.false.1124

cond.true.1104:                                   ; preds = %cond.true.1096
  %142 = load i64, i64* %elt, align 8
  %shr1105 = ashr i64 %142, 2
  %conv1106 = trunc i64 %shr1105 to i32
  %add1107 = add nsw i32 0, %conv1106
  %mul1108 = mul nsw i32 0, %add1107
  %add1109 = add nsw i32 %mul1108, 0
  %neg1110 = xor i32 %add1109, -1
  %cmp1111 = icmp eq i32 %neg1110, -1
  %conv1112 = zext i1 %cmp1111 to i32
  %sub1113 = sub nsw i32 0, %conv1112
  %143 = load i64, i64* %elt, align 8
  %shr1114 = ashr i64 %143, 2
  %conv1115 = trunc i64 %shr1114 to i32
  %add1116 = add nsw i32 0, %conv1115
  %mul1117 = mul nsw i32 0, %add1116
  %add1118 = add nsw i32 %mul1117, 1
  %shl1119 = shl i32 %add1118, 30
  %sub1120 = sub nsw i32 %shl1119, 1
  %mul1121 = mul nsw i32 %sub1120, 2
  %add1122 = add nsw i32 %mul1121, 1
  %sub1123 = sub nsw i32 %sub1113, %add1122
  br label %cond.end.1130

cond.false.1124:                                  ; preds = %cond.true.1096
  %144 = load i64, i64* %elt, align 8
  %shr1125 = ashr i64 %144, 2
  %conv1126 = trunc i64 %shr1125 to i32
  %add1127 = add nsw i32 0, %conv1126
  %mul1128 = mul nsw i32 0, %add1127
  %add1129 = add nsw i32 %mul1128, 0
  br label %cond.end.1130

cond.end.1130:                                    ; preds = %cond.false.1124, %cond.true.1104
  %cond1131 = phi i32 [ %sub1123, %cond.true.1104 ], [ %add1129, %cond.false.1124 ]
  %cmp1132 = icmp eq i32 %cond1131, 0
  br i1 %cmp1132, label %land.lhs.true.1134, label %lor.lhs.false.1139

land.lhs.true.1134:                               ; preds = %cond.end.1130
  %145 = load i64, i64* %elt, align 8
  %shr1135 = ashr i64 %145, 2
  %conv1136 = trunc i64 %shr1135 to i32
  %cmp1137 = icmp slt i32 %conv1136, 0
  br i1 %cmp1137, label %cond.true.1318, label %lor.lhs.false.1139

lor.lhs.false.1139:                               ; preds = %land.lhs.true.1134, %cond.end.1130
  br i1 false, label %cond.true.1140, label %cond.false.1219

cond.true.1140:                                   ; preds = %lor.lhs.false.1139
  %146 = load i64, i64* %elt, align 8
  %shr1141 = ashr i64 %146, 2
  %conv1142 = trunc i64 %shr1141 to i32
  %cmp1143 = icmp slt i32 %conv1142, 0
  br i1 %cmp1143, label %cond.true.1145, label %cond.false.1176

cond.true.1145:                                   ; preds = %cond.true.1140
  %147 = load i64, i64* %elt, align 8
  %shr1146 = ashr i64 %147, 2
  %conv1147 = trunc i64 %shr1146 to i32
  %148 = load i64, i64* %elt, align 8
  %shr1148 = ashr i64 %148, 2
  %conv1149 = trunc i64 %shr1148 to i32
  %add1150 = add nsw i32 0, %conv1149
  %mul1151 = mul nsw i32 0, %add1150
  %sub1152 = sub nsw i32 %mul1151, 1
  %cmp1153 = icmp slt i32 %sub1152, 0
  br i1 %cmp1153, label %cond.true.1155, label %cond.false.1165

cond.true.1155:                                   ; preds = %cond.true.1145
  %149 = load i64, i64* %elt, align 8
  %shr1156 = ashr i64 %149, 2
  %conv1157 = trunc i64 %shr1156 to i32
  %add1158 = add nsw i32 0, %conv1157
  %mul1159 = mul nsw i32 0, %add1158
  %add1160 = add nsw i32 %mul1159, 1
  %shl1161 = shl i32 %add1160, 30
  %sub1162 = sub nsw i32 %shl1161, 1
  %mul1163 = mul nsw i32 %sub1162, 2
  %add1164 = add nsw i32 %mul1163, 1
  br label %cond.end.1171

cond.false.1165:                                  ; preds = %cond.true.1145
  %150 = load i64, i64* %elt, align 8
  %shr1166 = ashr i64 %150, 2
  %conv1167 = trunc i64 %shr1166 to i32
  %add1168 = add nsw i32 0, %conv1167
  %mul1169 = mul nsw i32 0, %add1168
  %sub1170 = sub nsw i32 %mul1169, 1
  br label %cond.end.1171

cond.end.1171:                                    ; preds = %cond.false.1165, %cond.true.1155
  %cond1172 = phi i32 [ %add1164, %cond.true.1155 ], [ %sub1170, %cond.false.1165 ]
  %div1173 = sdiv i32 %cond1172, 8
  %cmp1174 = icmp slt i32 %conv1147, %div1173
  br i1 %cmp1174, label %cond.true.1318, label %lor.lhs.false.1298

cond.false.1176:                                  ; preds = %cond.true.1140
  br i1 false, label %cond.true.1177, label %cond.false.1178

cond.true.1177:                                   ; preds = %cond.false.1176
  br i1 false, label %cond.true.1318, label %lor.lhs.false.1298

cond.false.1178:                                  ; preds = %cond.false.1176
  %151 = load i64, i64* %elt, align 8
  %shr1179 = ashr i64 %151, 2
  %conv1180 = trunc i64 %shr1179 to i32
  %add1181 = add nsw i32 0, %conv1180
  %mul1182 = mul nsw i32 0, %add1181
  %sub1183 = sub nsw i32 %mul1182, 1
  %cmp1184 = icmp slt i32 %sub1183, 0
  br i1 %cmp1184, label %cond.true.1186, label %cond.false.1206

cond.true.1186:                                   ; preds = %cond.false.1178
  %152 = load i64, i64* %elt, align 8
  %shr1187 = ashr i64 %152, 2
  %conv1188 = trunc i64 %shr1187 to i32
  %add1189 = add nsw i32 0, %conv1188
  %mul1190 = mul nsw i32 0, %add1189
  %add1191 = add nsw i32 %mul1190, 0
  %neg1192 = xor i32 %add1191, -1
  %cmp1193 = icmp eq i32 %neg1192, -1
  %conv1194 = zext i1 %cmp1193 to i32
  %sub1195 = sub nsw i32 0, %conv1194
  %153 = load i64, i64* %elt, align 8
  %shr1196 = ashr i64 %153, 2
  %conv1197 = trunc i64 %shr1196 to i32
  %add1198 = add nsw i32 0, %conv1197
  %mul1199 = mul nsw i32 0, %add1198
  %add1200 = add nsw i32 %mul1199, 1
  %shl1201 = shl i32 %add1200, 30
  %sub1202 = sub nsw i32 %shl1201, 1
  %mul1203 = mul nsw i32 %sub1202, 2
  %add1204 = add nsw i32 %mul1203, 1
  %sub1205 = sub nsw i32 %sub1195, %add1204
  br label %cond.end.1212

cond.false.1206:                                  ; preds = %cond.false.1178
  %154 = load i64, i64* %elt, align 8
  %shr1207 = ashr i64 %154, 2
  %conv1208 = trunc i64 %shr1207 to i32
  %add1209 = add nsw i32 0, %conv1208
  %mul1210 = mul nsw i32 0, %add1209
  %add1211 = add nsw i32 %mul1210, 0
  br label %cond.end.1212

cond.end.1212:                                    ; preds = %cond.false.1206, %cond.true.1186
  %cond1213 = phi i32 [ %sub1205, %cond.true.1186 ], [ %add1211, %cond.false.1206 ]
  %div1214 = sdiv i32 %cond1213, 8
  %155 = load i64, i64* %elt, align 8
  %shr1215 = ashr i64 %155, 2
  %conv1216 = trunc i64 %shr1215 to i32
  %cmp1217 = icmp slt i32 %div1214, %conv1216
  br i1 %cmp1217, label %cond.true.1318, label %lor.lhs.false.1298

cond.false.1219:                                  ; preds = %lor.lhs.false.1139
  br i1 false, label %cond.true.1220, label %cond.false.1221

cond.true.1220:                                   ; preds = %cond.false.1219
  br i1 false, label %cond.true.1318, label %lor.lhs.false.1298

cond.false.1221:                                  ; preds = %cond.false.1219
  %156 = load i64, i64* %elt, align 8
  %shr1222 = ashr i64 %156, 2
  %conv1223 = trunc i64 %shr1222 to i32
  %cmp1224 = icmp slt i32 %conv1223, 0
  br i1 %cmp1224, label %cond.true.1226, label %cond.false.1267

cond.true.1226:                                   ; preds = %cond.false.1221
  %157 = load i64, i64* %elt, align 8
  %shr1227 = ashr i64 %157, 2
  %conv1228 = trunc i64 %shr1227 to i32
  %158 = load i64, i64* %elt, align 8
  %shr1229 = ashr i64 %158, 2
  %conv1230 = trunc i64 %shr1229 to i32
  %add1231 = add nsw i32 0, %conv1230
  %mul1232 = mul nsw i32 0, %add1231
  %sub1233 = sub nsw i32 %mul1232, 1
  %cmp1234 = icmp slt i32 %sub1233, 0
  br i1 %cmp1234, label %cond.true.1236, label %cond.false.1256

cond.true.1236:                                   ; preds = %cond.true.1226
  %159 = load i64, i64* %elt, align 8
  %shr1237 = ashr i64 %159, 2
  %conv1238 = trunc i64 %shr1237 to i32
  %add1239 = add nsw i32 0, %conv1238
  %mul1240 = mul nsw i32 0, %add1239
  %add1241 = add nsw i32 %mul1240, 0
  %neg1242 = xor i32 %add1241, -1
  %cmp1243 = icmp eq i32 %neg1242, -1
  %conv1244 = zext i1 %cmp1243 to i32
  %sub1245 = sub nsw i32 0, %conv1244
  %160 = load i64, i64* %elt, align 8
  %shr1246 = ashr i64 %160, 2
  %conv1247 = trunc i64 %shr1246 to i32
  %add1248 = add nsw i32 0, %conv1247
  %mul1249 = mul nsw i32 0, %add1248
  %add1250 = add nsw i32 %mul1249, 1
  %shl1251 = shl i32 %add1250, 30
  %sub1252 = sub nsw i32 %shl1251, 1
  %mul1253 = mul nsw i32 %sub1252, 2
  %add1254 = add nsw i32 %mul1253, 1
  %sub1255 = sub nsw i32 %sub1245, %add1254
  br label %cond.end.1262

cond.false.1256:                                  ; preds = %cond.true.1226
  %161 = load i64, i64* %elt, align 8
  %shr1257 = ashr i64 %161, 2
  %conv1258 = trunc i64 %shr1257 to i32
  %add1259 = add nsw i32 0, %conv1258
  %mul1260 = mul nsw i32 0, %add1259
  %add1261 = add nsw i32 %mul1260, 0
  br label %cond.end.1262

cond.end.1262:                                    ; preds = %cond.false.1256, %cond.true.1236
  %cond1263 = phi i32 [ %sub1255, %cond.true.1236 ], [ %add1261, %cond.false.1256 ]
  %div1264 = sdiv i32 %cond1263, 8
  %cmp1265 = icmp slt i32 %conv1228, %div1264
  br i1 %cmp1265, label %cond.true.1318, label %lor.lhs.false.1298

cond.false.1267:                                  ; preds = %cond.false.1221
  %162 = load i64, i64* %elt, align 8
  %shr1268 = ashr i64 %162, 2
  %conv1269 = trunc i64 %shr1268 to i32
  %add1270 = add nsw i32 0, %conv1269
  %mul1271 = mul nsw i32 0, %add1270
  %sub1272 = sub nsw i32 %mul1271, 1
  %cmp1273 = icmp slt i32 %sub1272, 0
  br i1 %cmp1273, label %cond.true.1275, label %cond.false.1285

cond.true.1275:                                   ; preds = %cond.false.1267
  %163 = load i64, i64* %elt, align 8
  %shr1276 = ashr i64 %163, 2
  %conv1277 = trunc i64 %shr1276 to i32
  %add1278 = add nsw i32 0, %conv1277
  %mul1279 = mul nsw i32 0, %add1278
  %add1280 = add nsw i32 %mul1279, 1
  %shl1281 = shl i32 %add1280, 30
  %sub1282 = sub nsw i32 %shl1281, 1
  %mul1283 = mul nsw i32 %sub1282, 2
  %add1284 = add nsw i32 %mul1283, 1
  br label %cond.end.1291

cond.false.1285:                                  ; preds = %cond.false.1267
  %164 = load i64, i64* %elt, align 8
  %shr1286 = ashr i64 %164, 2
  %conv1287 = trunc i64 %shr1286 to i32
  %add1288 = add nsw i32 0, %conv1287
  %mul1289 = mul nsw i32 0, %add1288
  %sub1290 = sub nsw i32 %mul1289, 1
  br label %cond.end.1291

cond.end.1291:                                    ; preds = %cond.false.1285, %cond.true.1275
  %cond1292 = phi i32 [ %add1284, %cond.true.1275 ], [ %sub1290, %cond.false.1285 ]
  %div1293 = sdiv i32 %cond1292, 8
  %165 = load i64, i64* %elt, align 8
  %shr1294 = ashr i64 %165, 2
  %conv1295 = trunc i64 %shr1294 to i32
  %cmp1296 = icmp slt i32 %div1293, %conv1295
  br i1 %cmp1296, label %cond.true.1318, label %lor.lhs.false.1298

lor.lhs.false.1298:                               ; preds = %cond.end.1291, %cond.end.1262, %cond.true.1220, %cond.end.1212, %cond.true.1177, %cond.end.1171
  %166 = load i64, i64* %elt, align 8
  %shr1299 = ashr i64 %166, 2
  %conv1300 = trunc i64 %shr1299 to i32
  %mul1301 = mul nsw i32 %conv1300, 8
  %mul1302 = mul nsw i32 0, %mul1301
  %sub1303 = sub nsw i32 %mul1302, 1
  %cmp1304 = icmp slt i32 %sub1303, 0
  br i1 %cmp1304, label %land.lhs.true.1306, label %lor.lhs.false.1312

land.lhs.true.1306:                               ; preds = %lor.lhs.false.1298
  %167 = load i64, i64* %elt, align 8
  %shr1307 = ashr i64 %167, 2
  %conv1308 = trunc i64 %shr1307 to i32
  %mul1309 = mul nsw i32 %conv1308, 8
  %cmp1310 = icmp slt i32 %mul1309, -2147483648
  br i1 %cmp1310, label %cond.true.1318, label %lor.lhs.false.1312

lor.lhs.false.1312:                               ; preds = %land.lhs.true.1306, %lor.lhs.false.1298
  %168 = load i64, i64* %elt, align 8
  %shr1313 = ashr i64 %168, 2
  %conv1314 = trunc i64 %shr1313 to i32
  %mul1315 = mul nsw i32 %conv1314, 8
  %cmp1316 = icmp slt i32 2147483647, %mul1315
  br i1 %cmp1316, label %cond.true.1318, label %cond.false.1337

cond.true.1318:                                   ; preds = %lor.lhs.false.1312, %land.lhs.true.1306, %cond.end.1291, %cond.end.1262, %cond.true.1220, %cond.end.1212, %cond.true.1177, %cond.end.1171, %land.lhs.true.1134
  %169 = load i64, i64* %elt, align 8
  %shr1319 = ashr i64 %169, 2
  %conv1320 = trunc i64 %shr1319 to i32
  %mul1321 = mul i32 %conv1320, 8
  %cmp1322 = icmp ule i32 %mul1321, 2147483647
  br i1 %cmp1322, label %cond.true.1324, label %cond.false.1328

cond.true.1324:                                   ; preds = %cond.true.1318
  %170 = load i64, i64* %elt, align 8
  %shr1325 = ashr i64 %170, 2
  %conv1326 = trunc i64 %shr1325 to i32
  %mul1327 = mul i32 %conv1326, 8
  br label %cond.end.1334

cond.false.1328:                                  ; preds = %cond.true.1318
  %171 = load i64, i64* %elt, align 8
  %shr1329 = ashr i64 %171, 2
  %conv1330 = trunc i64 %shr1329 to i32
  %mul1331 = mul i32 %conv1330, 8
  %sub1332 = sub i32 %mul1331, -2147483648
  %add1333 = add nsw i32 %sub1332, -2147483648
  br label %cond.end.1334

cond.end.1334:                                    ; preds = %cond.false.1328, %cond.true.1324
  %cond1335 = phi i32 [ %mul1327, %cond.true.1324 ], [ %add1333, %cond.false.1328 ]
  %conv1336 = sext i32 %cond1335 to i64
  store i64 %conv1336, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then, label %lor.lhs.false.2502

cond.false.1337:                                  ; preds = %lor.lhs.false.1312
  %172 = load i64, i64* %elt, align 8
  %shr1338 = ashr i64 %172, 2
  %conv1339 = trunc i64 %shr1338 to i32
  %mul1340 = mul i32 %conv1339, 8
  %cmp1341 = icmp ule i32 %mul1340, 2147483647
  br i1 %cmp1341, label %cond.true.1343, label %cond.false.1347

cond.true.1343:                                   ; preds = %cond.false.1337
  %173 = load i64, i64* %elt, align 8
  %shr1344 = ashr i64 %173, 2
  %conv1345 = trunc i64 %shr1344 to i32
  %mul1346 = mul i32 %conv1345, 8
  br label %cond.end.1353

cond.false.1347:                                  ; preds = %cond.false.1337
  %174 = load i64, i64* %elt, align 8
  %shr1348 = ashr i64 %174, 2
  %conv1349 = trunc i64 %shr1348 to i32
  %mul1350 = mul i32 %conv1349, 8
  %sub1351 = sub i32 %mul1350, -2147483648
  %add1352 = add nsw i32 %sub1351, -2147483648
  br label %cond.end.1353

cond.end.1353:                                    ; preds = %cond.false.1347, %cond.true.1343
  %cond1354 = phi i32 [ %mul1346, %cond.true.1343 ], [ %add1352, %cond.false.1347 ]
  %conv1355 = sext i32 %cond1354 to i64
  store i64 %conv1355, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then, label %lor.lhs.false.2502

cond.false.1356:                                  ; preds = %cond.true.1095
  %175 = load i64, i64* %elt, align 8
  %shr1357 = ashr i64 %175, 2
  %add1358 = add nsw i64 0, %shr1357
  %mul1359 = mul nsw i64 0, %add1358
  %sub1360 = sub nsw i64 %mul1359, 1
  %cmp1361 = icmp slt i64 %sub1360, 0
  br i1 %cmp1361, label %cond.true.1363, label %cond.false.1382

cond.true.1363:                                   ; preds = %cond.false.1356
  %176 = load i64, i64* %elt, align 8
  %shr1364 = ashr i64 %176, 2
  %add1365 = add nsw i64 0, %shr1364
  %mul1366 = mul nsw i64 0, %add1365
  %add1367 = add nsw i64 %mul1366, 0
  %neg1368 = xor i64 %add1367, -1
  %cmp1369 = icmp eq i64 %neg1368, -1
  %conv1370 = zext i1 %cmp1369 to i32
  %sub1371 = sub nsw i32 0, %conv1370
  %conv1372 = sext i32 %sub1371 to i64
  %177 = load i64, i64* %elt, align 8
  %shr1373 = ashr i64 %177, 2
  %add1374 = add nsw i64 0, %shr1373
  %mul1375 = mul nsw i64 0, %add1374
  %add1376 = add nsw i64 %mul1375, 1
  %shl1377 = shl i64 %add1376, 62
  %sub1378 = sub nsw i64 %shl1377, 1
  %mul1379 = mul nsw i64 %sub1378, 2
  %add1380 = add nsw i64 %mul1379, 1
  %sub1381 = sub nsw i64 %conv1372, %add1380
  br label %cond.end.1387

cond.false.1382:                                  ; preds = %cond.false.1356
  %178 = load i64, i64* %elt, align 8
  %shr1383 = ashr i64 %178, 2
  %add1384 = add nsw i64 0, %shr1383
  %mul1385 = mul nsw i64 0, %add1384
  %add1386 = add nsw i64 %mul1385, 0
  br label %cond.end.1387

cond.end.1387:                                    ; preds = %cond.false.1382, %cond.true.1363
  %cond1388 = phi i64 [ %sub1381, %cond.true.1363 ], [ %add1386, %cond.false.1382 ]
  %cmp1389 = icmp eq i64 %cond1388, 0
  br i1 %cmp1389, label %land.lhs.true.1391, label %lor.lhs.false.1395

land.lhs.true.1391:                               ; preds = %cond.end.1387
  %179 = load i64, i64* %elt, align 8
  %shr1392 = ashr i64 %179, 2
  %cmp1393 = icmp slt i64 %shr1392, 0
  br i1 %cmp1393, label %cond.true.1553, label %lor.lhs.false.1395

lor.lhs.false.1395:                               ; preds = %land.lhs.true.1391, %cond.end.1387
  br i1 false, label %cond.true.1396, label %cond.false.1466

cond.true.1396:                                   ; preds = %lor.lhs.false.1395
  %180 = load i64, i64* %elt, align 8
  %shr1397 = ashr i64 %180, 2
  %cmp1398 = icmp slt i64 %shr1397, 0
  br i1 %cmp1398, label %cond.true.1400, label %cond.false.1427

cond.true.1400:                                   ; preds = %cond.true.1396
  %181 = load i64, i64* %elt, align 8
  %shr1401 = ashr i64 %181, 2
  %182 = load i64, i64* %elt, align 8
  %shr1402 = ashr i64 %182, 2
  %add1403 = add nsw i64 0, %shr1402
  %mul1404 = mul nsw i64 0, %add1403
  %sub1405 = sub nsw i64 %mul1404, 1
  %cmp1406 = icmp slt i64 %sub1405, 0
  br i1 %cmp1406, label %cond.true.1408, label %cond.false.1417

cond.true.1408:                                   ; preds = %cond.true.1400
  %183 = load i64, i64* %elt, align 8
  %shr1409 = ashr i64 %183, 2
  %add1410 = add nsw i64 0, %shr1409
  %mul1411 = mul nsw i64 0, %add1410
  %add1412 = add nsw i64 %mul1411, 1
  %shl1413 = shl i64 %add1412, 62
  %sub1414 = sub nsw i64 %shl1413, 1
  %mul1415 = mul nsw i64 %sub1414, 2
  %add1416 = add nsw i64 %mul1415, 1
  br label %cond.end.1422

cond.false.1417:                                  ; preds = %cond.true.1400
  %184 = load i64, i64* %elt, align 8
  %shr1418 = ashr i64 %184, 2
  %add1419 = add nsw i64 0, %shr1418
  %mul1420 = mul nsw i64 0, %add1419
  %sub1421 = sub nsw i64 %mul1420, 1
  br label %cond.end.1422

cond.end.1422:                                    ; preds = %cond.false.1417, %cond.true.1408
  %cond1423 = phi i64 [ %add1416, %cond.true.1408 ], [ %sub1421, %cond.false.1417 ]
  %div1424 = sdiv i64 %cond1423, 8
  %cmp1425 = icmp slt i64 %shr1401, %div1424
  br i1 %cmp1425, label %cond.true.1553, label %lor.lhs.false.1536

cond.false.1427:                                  ; preds = %cond.true.1396
  br i1 false, label %cond.true.1428, label %cond.false.1429

cond.true.1428:                                   ; preds = %cond.false.1427
  br i1 false, label %cond.true.1553, label %lor.lhs.false.1536

cond.false.1429:                                  ; preds = %cond.false.1427
  %185 = load i64, i64* %elt, align 8
  %shr1430 = ashr i64 %185, 2
  %add1431 = add nsw i64 0, %shr1430
  %mul1432 = mul nsw i64 0, %add1431
  %sub1433 = sub nsw i64 %mul1432, 1
  %cmp1434 = icmp slt i64 %sub1433, 0
  br i1 %cmp1434, label %cond.true.1436, label %cond.false.1455

cond.true.1436:                                   ; preds = %cond.false.1429
  %186 = load i64, i64* %elt, align 8
  %shr1437 = ashr i64 %186, 2
  %add1438 = add nsw i64 0, %shr1437
  %mul1439 = mul nsw i64 0, %add1438
  %add1440 = add nsw i64 %mul1439, 0
  %neg1441 = xor i64 %add1440, -1
  %cmp1442 = icmp eq i64 %neg1441, -1
  %conv1443 = zext i1 %cmp1442 to i32
  %sub1444 = sub nsw i32 0, %conv1443
  %conv1445 = sext i32 %sub1444 to i64
  %187 = load i64, i64* %elt, align 8
  %shr1446 = ashr i64 %187, 2
  %add1447 = add nsw i64 0, %shr1446
  %mul1448 = mul nsw i64 0, %add1447
  %add1449 = add nsw i64 %mul1448, 1
  %shl1450 = shl i64 %add1449, 62
  %sub1451 = sub nsw i64 %shl1450, 1
  %mul1452 = mul nsw i64 %sub1451, 2
  %add1453 = add nsw i64 %mul1452, 1
  %sub1454 = sub nsw i64 %conv1445, %add1453
  br label %cond.end.1460

cond.false.1455:                                  ; preds = %cond.false.1429
  %188 = load i64, i64* %elt, align 8
  %shr1456 = ashr i64 %188, 2
  %add1457 = add nsw i64 0, %shr1456
  %mul1458 = mul nsw i64 0, %add1457
  %add1459 = add nsw i64 %mul1458, 0
  br label %cond.end.1460

cond.end.1460:                                    ; preds = %cond.false.1455, %cond.true.1436
  %cond1461 = phi i64 [ %sub1454, %cond.true.1436 ], [ %add1459, %cond.false.1455 ]
  %div1462 = sdiv i64 %cond1461, 8
  %189 = load i64, i64* %elt, align 8
  %shr1463 = ashr i64 %189, 2
  %cmp1464 = icmp slt i64 %div1462, %shr1463
  br i1 %cmp1464, label %cond.true.1553, label %lor.lhs.false.1536

cond.false.1466:                                  ; preds = %lor.lhs.false.1395
  br i1 false, label %cond.true.1467, label %cond.false.1468

cond.true.1467:                                   ; preds = %cond.false.1466
  br i1 false, label %cond.true.1553, label %lor.lhs.false.1536

cond.false.1468:                                  ; preds = %cond.false.1466
  %190 = load i64, i64* %elt, align 8
  %shr1469 = ashr i64 %190, 2
  %cmp1470 = icmp slt i64 %shr1469, 0
  br i1 %cmp1470, label %cond.true.1472, label %cond.false.1509

cond.true.1472:                                   ; preds = %cond.false.1468
  %191 = load i64, i64* %elt, align 8
  %shr1473 = ashr i64 %191, 2
  %192 = load i64, i64* %elt, align 8
  %shr1474 = ashr i64 %192, 2
  %add1475 = add nsw i64 0, %shr1474
  %mul1476 = mul nsw i64 0, %add1475
  %sub1477 = sub nsw i64 %mul1476, 1
  %cmp1478 = icmp slt i64 %sub1477, 0
  br i1 %cmp1478, label %cond.true.1480, label %cond.false.1499

cond.true.1480:                                   ; preds = %cond.true.1472
  %193 = load i64, i64* %elt, align 8
  %shr1481 = ashr i64 %193, 2
  %add1482 = add nsw i64 0, %shr1481
  %mul1483 = mul nsw i64 0, %add1482
  %add1484 = add nsw i64 %mul1483, 0
  %neg1485 = xor i64 %add1484, -1
  %cmp1486 = icmp eq i64 %neg1485, -1
  %conv1487 = zext i1 %cmp1486 to i32
  %sub1488 = sub nsw i32 0, %conv1487
  %conv1489 = sext i32 %sub1488 to i64
  %194 = load i64, i64* %elt, align 8
  %shr1490 = ashr i64 %194, 2
  %add1491 = add nsw i64 0, %shr1490
  %mul1492 = mul nsw i64 0, %add1491
  %add1493 = add nsw i64 %mul1492, 1
  %shl1494 = shl i64 %add1493, 62
  %sub1495 = sub nsw i64 %shl1494, 1
  %mul1496 = mul nsw i64 %sub1495, 2
  %add1497 = add nsw i64 %mul1496, 1
  %sub1498 = sub nsw i64 %conv1489, %add1497
  br label %cond.end.1504

cond.false.1499:                                  ; preds = %cond.true.1472
  %195 = load i64, i64* %elt, align 8
  %shr1500 = ashr i64 %195, 2
  %add1501 = add nsw i64 0, %shr1500
  %mul1502 = mul nsw i64 0, %add1501
  %add1503 = add nsw i64 %mul1502, 0
  br label %cond.end.1504

cond.end.1504:                                    ; preds = %cond.false.1499, %cond.true.1480
  %cond1505 = phi i64 [ %sub1498, %cond.true.1480 ], [ %add1503, %cond.false.1499 ]
  %div1506 = sdiv i64 %cond1505, 8
  %cmp1507 = icmp slt i64 %shr1473, %div1506
  br i1 %cmp1507, label %cond.true.1553, label %lor.lhs.false.1536

cond.false.1509:                                  ; preds = %cond.false.1468
  %196 = load i64, i64* %elt, align 8
  %shr1510 = ashr i64 %196, 2
  %add1511 = add nsw i64 0, %shr1510
  %mul1512 = mul nsw i64 0, %add1511
  %sub1513 = sub nsw i64 %mul1512, 1
  %cmp1514 = icmp slt i64 %sub1513, 0
  br i1 %cmp1514, label %cond.true.1516, label %cond.false.1525

cond.true.1516:                                   ; preds = %cond.false.1509
  %197 = load i64, i64* %elt, align 8
  %shr1517 = ashr i64 %197, 2
  %add1518 = add nsw i64 0, %shr1517
  %mul1519 = mul nsw i64 0, %add1518
  %add1520 = add nsw i64 %mul1519, 1
  %shl1521 = shl i64 %add1520, 62
  %sub1522 = sub nsw i64 %shl1521, 1
  %mul1523 = mul nsw i64 %sub1522, 2
  %add1524 = add nsw i64 %mul1523, 1
  br label %cond.end.1530

cond.false.1525:                                  ; preds = %cond.false.1509
  %198 = load i64, i64* %elt, align 8
  %shr1526 = ashr i64 %198, 2
  %add1527 = add nsw i64 0, %shr1526
  %mul1528 = mul nsw i64 0, %add1527
  %sub1529 = sub nsw i64 %mul1528, 1
  br label %cond.end.1530

cond.end.1530:                                    ; preds = %cond.false.1525, %cond.true.1516
  %cond1531 = phi i64 [ %add1524, %cond.true.1516 ], [ %sub1529, %cond.false.1525 ]
  %div1532 = sdiv i64 %cond1531, 8
  %199 = load i64, i64* %elt, align 8
  %shr1533 = ashr i64 %199, 2
  %cmp1534 = icmp slt i64 %div1532, %shr1533
  br i1 %cmp1534, label %cond.true.1553, label %lor.lhs.false.1536

lor.lhs.false.1536:                               ; preds = %cond.end.1530, %cond.end.1504, %cond.true.1467, %cond.end.1460, %cond.true.1428, %cond.end.1422
  %200 = load i64, i64* %elt, align 8
  %shr1537 = ashr i64 %200, 2
  %mul1538 = mul nsw i64 %shr1537, 8
  %mul1539 = mul nsw i64 0, %mul1538
  %sub1540 = sub nsw i64 %mul1539, 1
  %cmp1541 = icmp slt i64 %sub1540, 0
  br i1 %cmp1541, label %land.lhs.true.1543, label %lor.lhs.false.1548

land.lhs.true.1543:                               ; preds = %lor.lhs.false.1536
  %201 = load i64, i64* %elt, align 8
  %shr1544 = ashr i64 %201, 2
  %mul1545 = mul nsw i64 %shr1544, 8
  %cmp1546 = icmp slt i64 %mul1545, -2147483648
  br i1 %cmp1546, label %cond.true.1553, label %lor.lhs.false.1548

lor.lhs.false.1548:                               ; preds = %land.lhs.true.1543, %lor.lhs.false.1536
  %202 = load i64, i64* %elt, align 8
  %shr1549 = ashr i64 %202, 2
  %mul1550 = mul nsw i64 %shr1549, 8
  %cmp1551 = icmp slt i64 2147483647, %mul1550
  br i1 %cmp1551, label %cond.true.1553, label %cond.false.1572

cond.true.1553:                                   ; preds = %lor.lhs.false.1548, %land.lhs.true.1543, %cond.end.1530, %cond.end.1504, %cond.true.1467, %cond.end.1460, %cond.true.1428, %cond.end.1422, %land.lhs.true.1391
  %203 = load i64, i64* %elt, align 8
  %shr1554 = ashr i64 %203, 2
  %conv1555 = trunc i64 %shr1554 to i32
  %mul1556 = mul i32 %conv1555, 8
  %cmp1557 = icmp ule i32 %mul1556, 2147483647
  br i1 %cmp1557, label %cond.true.1559, label %cond.false.1563

cond.true.1559:                                   ; preds = %cond.true.1553
  %204 = load i64, i64* %elt, align 8
  %shr1560 = ashr i64 %204, 2
  %conv1561 = trunc i64 %shr1560 to i32
  %mul1562 = mul i32 %conv1561, 8
  br label %cond.end.1569

cond.false.1563:                                  ; preds = %cond.true.1553
  %205 = load i64, i64* %elt, align 8
  %shr1564 = ashr i64 %205, 2
  %conv1565 = trunc i64 %shr1564 to i32
  %mul1566 = mul i32 %conv1565, 8
  %sub1567 = sub i32 %mul1566, -2147483648
  %add1568 = add nsw i32 %sub1567, -2147483648
  br label %cond.end.1569

cond.end.1569:                                    ; preds = %cond.false.1563, %cond.true.1559
  %cond1570 = phi i32 [ %mul1562, %cond.true.1559 ], [ %add1568, %cond.false.1563 ]
  %conv1571 = sext i32 %cond1570 to i64
  store i64 %conv1571, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then, label %lor.lhs.false.2502

cond.false.1572:                                  ; preds = %lor.lhs.false.1548
  %206 = load i64, i64* %elt, align 8
  %shr1573 = ashr i64 %206, 2
  %conv1574 = trunc i64 %shr1573 to i32
  %mul1575 = mul i32 %conv1574, 8
  %cmp1576 = icmp ule i32 %mul1575, 2147483647
  br i1 %cmp1576, label %cond.true.1578, label %cond.false.1582

cond.true.1578:                                   ; preds = %cond.false.1572
  %207 = load i64, i64* %elt, align 8
  %shr1579 = ashr i64 %207, 2
  %conv1580 = trunc i64 %shr1579 to i32
  %mul1581 = mul i32 %conv1580, 8
  br label %cond.end.1588

cond.false.1582:                                  ; preds = %cond.false.1572
  %208 = load i64, i64* %elt, align 8
  %shr1583 = ashr i64 %208, 2
  %conv1584 = trunc i64 %shr1583 to i32
  %mul1585 = mul i32 %conv1584, 8
  %sub1586 = sub i32 %mul1585, -2147483648
  %add1587 = add nsw i32 %sub1586, -2147483648
  br label %cond.end.1588

cond.end.1588:                                    ; preds = %cond.false.1582, %cond.true.1578
  %cond1589 = phi i32 [ %mul1581, %cond.true.1578 ], [ %add1587, %cond.false.1582 ]
  %conv1590 = sext i32 %cond1589 to i64
  store i64 %conv1590, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then, label %lor.lhs.false.2502

cond.false.1591:                                  ; preds = %cond.false.1094
  br i1 true, label %cond.true.1592, label %cond.false.2047

cond.true.1592:                                   ; preds = %cond.false.1591
  br i1 false, label %cond.true.1593, label %cond.false.1820

cond.true.1593:                                   ; preds = %cond.true.1592
  %209 = load i64, i64* %elt, align 8
  %shr1594 = ashr i64 %209, 2
  %add1595 = add nsw i64 0, %shr1594
  %mul1596 = mul nsw i64 0, %add1595
  %sub1597 = sub nsw i64 %mul1596, 1
  %cmp1598 = icmp slt i64 %sub1597, 0
  br i1 %cmp1598, label %cond.true.1600, label %cond.false.1619

cond.true.1600:                                   ; preds = %cond.true.1593
  %210 = load i64, i64* %elt, align 8
  %shr1601 = ashr i64 %210, 2
  %add1602 = add nsw i64 0, %shr1601
  %mul1603 = mul nsw i64 0, %add1602
  %add1604 = add nsw i64 %mul1603, 0
  %neg1605 = xor i64 %add1604, -1
  %cmp1606 = icmp eq i64 %neg1605, -1
  %conv1607 = zext i1 %cmp1606 to i32
  %sub1608 = sub nsw i32 0, %conv1607
  %conv1609 = sext i32 %sub1608 to i64
  %211 = load i64, i64* %elt, align 8
  %shr1610 = ashr i64 %211, 2
  %add1611 = add nsw i64 0, %shr1610
  %mul1612 = mul nsw i64 0, %add1611
  %add1613 = add nsw i64 %mul1612, 1
  %shl1614 = shl i64 %add1613, 62
  %sub1615 = sub nsw i64 %shl1614, 1
  %mul1616 = mul nsw i64 %sub1615, 2
  %add1617 = add nsw i64 %mul1616, 1
  %sub1618 = sub nsw i64 %conv1609, %add1617
  br label %cond.end.1624

cond.false.1619:                                  ; preds = %cond.true.1593
  %212 = load i64, i64* %elt, align 8
  %shr1620 = ashr i64 %212, 2
  %add1621 = add nsw i64 0, %shr1620
  %mul1622 = mul nsw i64 0, %add1621
  %add1623 = add nsw i64 %mul1622, 0
  br label %cond.end.1624

cond.end.1624:                                    ; preds = %cond.false.1619, %cond.true.1600
  %cond1625 = phi i64 [ %sub1618, %cond.true.1600 ], [ %add1623, %cond.false.1619 ]
  %cmp1626 = icmp eq i64 %cond1625, 0
  br i1 %cmp1626, label %land.lhs.true.1628, label %lor.lhs.false.1632

land.lhs.true.1628:                               ; preds = %cond.end.1624
  %213 = load i64, i64* %elt, align 8
  %shr1629 = ashr i64 %213, 2
  %cmp1630 = icmp slt i64 %shr1629, 0
  br i1 %cmp1630, label %cond.true.1790, label %lor.lhs.false.1632

lor.lhs.false.1632:                               ; preds = %land.lhs.true.1628, %cond.end.1624
  br i1 false, label %cond.true.1633, label %cond.false.1703

cond.true.1633:                                   ; preds = %lor.lhs.false.1632
  %214 = load i64, i64* %elt, align 8
  %shr1634 = ashr i64 %214, 2
  %cmp1635 = icmp slt i64 %shr1634, 0
  br i1 %cmp1635, label %cond.true.1637, label %cond.false.1664

cond.true.1637:                                   ; preds = %cond.true.1633
  %215 = load i64, i64* %elt, align 8
  %shr1638 = ashr i64 %215, 2
  %216 = load i64, i64* %elt, align 8
  %shr1639 = ashr i64 %216, 2
  %add1640 = add nsw i64 0, %shr1639
  %mul1641 = mul nsw i64 0, %add1640
  %sub1642 = sub nsw i64 %mul1641, 1
  %cmp1643 = icmp slt i64 %sub1642, 0
  br i1 %cmp1643, label %cond.true.1645, label %cond.false.1654

cond.true.1645:                                   ; preds = %cond.true.1637
  %217 = load i64, i64* %elt, align 8
  %shr1646 = ashr i64 %217, 2
  %add1647 = add nsw i64 0, %shr1646
  %mul1648 = mul nsw i64 0, %add1647
  %add1649 = add nsw i64 %mul1648, 1
  %shl1650 = shl i64 %add1649, 62
  %sub1651 = sub nsw i64 %shl1650, 1
  %mul1652 = mul nsw i64 %sub1651, 2
  %add1653 = add nsw i64 %mul1652, 1
  br label %cond.end.1659

cond.false.1654:                                  ; preds = %cond.true.1637
  %218 = load i64, i64* %elt, align 8
  %shr1655 = ashr i64 %218, 2
  %add1656 = add nsw i64 0, %shr1655
  %mul1657 = mul nsw i64 0, %add1656
  %sub1658 = sub nsw i64 %mul1657, 1
  br label %cond.end.1659

cond.end.1659:                                    ; preds = %cond.false.1654, %cond.true.1645
  %cond1660 = phi i64 [ %add1653, %cond.true.1645 ], [ %sub1658, %cond.false.1654 ]
  %div1661 = sdiv i64 %cond1660, 8
  %cmp1662 = icmp slt i64 %shr1638, %div1661
  br i1 %cmp1662, label %cond.true.1790, label %lor.lhs.false.1773

cond.false.1664:                                  ; preds = %cond.true.1633
  br i1 false, label %cond.true.1665, label %cond.false.1666

cond.true.1665:                                   ; preds = %cond.false.1664
  br i1 false, label %cond.true.1790, label %lor.lhs.false.1773

cond.false.1666:                                  ; preds = %cond.false.1664
  %219 = load i64, i64* %elt, align 8
  %shr1667 = ashr i64 %219, 2
  %add1668 = add nsw i64 0, %shr1667
  %mul1669 = mul nsw i64 0, %add1668
  %sub1670 = sub nsw i64 %mul1669, 1
  %cmp1671 = icmp slt i64 %sub1670, 0
  br i1 %cmp1671, label %cond.true.1673, label %cond.false.1692

cond.true.1673:                                   ; preds = %cond.false.1666
  %220 = load i64, i64* %elt, align 8
  %shr1674 = ashr i64 %220, 2
  %add1675 = add nsw i64 0, %shr1674
  %mul1676 = mul nsw i64 0, %add1675
  %add1677 = add nsw i64 %mul1676, 0
  %neg1678 = xor i64 %add1677, -1
  %cmp1679 = icmp eq i64 %neg1678, -1
  %conv1680 = zext i1 %cmp1679 to i32
  %sub1681 = sub nsw i32 0, %conv1680
  %conv1682 = sext i32 %sub1681 to i64
  %221 = load i64, i64* %elt, align 8
  %shr1683 = ashr i64 %221, 2
  %add1684 = add nsw i64 0, %shr1683
  %mul1685 = mul nsw i64 0, %add1684
  %add1686 = add nsw i64 %mul1685, 1
  %shl1687 = shl i64 %add1686, 62
  %sub1688 = sub nsw i64 %shl1687, 1
  %mul1689 = mul nsw i64 %sub1688, 2
  %add1690 = add nsw i64 %mul1689, 1
  %sub1691 = sub nsw i64 %conv1682, %add1690
  br label %cond.end.1697

cond.false.1692:                                  ; preds = %cond.false.1666
  %222 = load i64, i64* %elt, align 8
  %shr1693 = ashr i64 %222, 2
  %add1694 = add nsw i64 0, %shr1693
  %mul1695 = mul nsw i64 0, %add1694
  %add1696 = add nsw i64 %mul1695, 0
  br label %cond.end.1697

cond.end.1697:                                    ; preds = %cond.false.1692, %cond.true.1673
  %cond1698 = phi i64 [ %sub1691, %cond.true.1673 ], [ %add1696, %cond.false.1692 ]
  %div1699 = sdiv i64 %cond1698, 8
  %223 = load i64, i64* %elt, align 8
  %shr1700 = ashr i64 %223, 2
  %cmp1701 = icmp slt i64 %div1699, %shr1700
  br i1 %cmp1701, label %cond.true.1790, label %lor.lhs.false.1773

cond.false.1703:                                  ; preds = %lor.lhs.false.1632
  br i1 false, label %cond.true.1704, label %cond.false.1705

cond.true.1704:                                   ; preds = %cond.false.1703
  br i1 false, label %cond.true.1790, label %lor.lhs.false.1773

cond.false.1705:                                  ; preds = %cond.false.1703
  %224 = load i64, i64* %elt, align 8
  %shr1706 = ashr i64 %224, 2
  %cmp1707 = icmp slt i64 %shr1706, 0
  br i1 %cmp1707, label %cond.true.1709, label %cond.false.1746

cond.true.1709:                                   ; preds = %cond.false.1705
  %225 = load i64, i64* %elt, align 8
  %shr1710 = ashr i64 %225, 2
  %226 = load i64, i64* %elt, align 8
  %shr1711 = ashr i64 %226, 2
  %add1712 = add nsw i64 0, %shr1711
  %mul1713 = mul nsw i64 0, %add1712
  %sub1714 = sub nsw i64 %mul1713, 1
  %cmp1715 = icmp slt i64 %sub1714, 0
  br i1 %cmp1715, label %cond.true.1717, label %cond.false.1736

cond.true.1717:                                   ; preds = %cond.true.1709
  %227 = load i64, i64* %elt, align 8
  %shr1718 = ashr i64 %227, 2
  %add1719 = add nsw i64 0, %shr1718
  %mul1720 = mul nsw i64 0, %add1719
  %add1721 = add nsw i64 %mul1720, 0
  %neg1722 = xor i64 %add1721, -1
  %cmp1723 = icmp eq i64 %neg1722, -1
  %conv1724 = zext i1 %cmp1723 to i32
  %sub1725 = sub nsw i32 0, %conv1724
  %conv1726 = sext i32 %sub1725 to i64
  %228 = load i64, i64* %elt, align 8
  %shr1727 = ashr i64 %228, 2
  %add1728 = add nsw i64 0, %shr1727
  %mul1729 = mul nsw i64 0, %add1728
  %add1730 = add nsw i64 %mul1729, 1
  %shl1731 = shl i64 %add1730, 62
  %sub1732 = sub nsw i64 %shl1731, 1
  %mul1733 = mul nsw i64 %sub1732, 2
  %add1734 = add nsw i64 %mul1733, 1
  %sub1735 = sub nsw i64 %conv1726, %add1734
  br label %cond.end.1741

cond.false.1736:                                  ; preds = %cond.true.1709
  %229 = load i64, i64* %elt, align 8
  %shr1737 = ashr i64 %229, 2
  %add1738 = add nsw i64 0, %shr1737
  %mul1739 = mul nsw i64 0, %add1738
  %add1740 = add nsw i64 %mul1739, 0
  br label %cond.end.1741

cond.end.1741:                                    ; preds = %cond.false.1736, %cond.true.1717
  %cond1742 = phi i64 [ %sub1735, %cond.true.1717 ], [ %add1740, %cond.false.1736 ]
  %div1743 = sdiv i64 %cond1742, 8
  %cmp1744 = icmp slt i64 %shr1710, %div1743
  br i1 %cmp1744, label %cond.true.1790, label %lor.lhs.false.1773

cond.false.1746:                                  ; preds = %cond.false.1705
  %230 = load i64, i64* %elt, align 8
  %shr1747 = ashr i64 %230, 2
  %add1748 = add nsw i64 0, %shr1747
  %mul1749 = mul nsw i64 0, %add1748
  %sub1750 = sub nsw i64 %mul1749, 1
  %cmp1751 = icmp slt i64 %sub1750, 0
  br i1 %cmp1751, label %cond.true.1753, label %cond.false.1762

cond.true.1753:                                   ; preds = %cond.false.1746
  %231 = load i64, i64* %elt, align 8
  %shr1754 = ashr i64 %231, 2
  %add1755 = add nsw i64 0, %shr1754
  %mul1756 = mul nsw i64 0, %add1755
  %add1757 = add nsw i64 %mul1756, 1
  %shl1758 = shl i64 %add1757, 62
  %sub1759 = sub nsw i64 %shl1758, 1
  %mul1760 = mul nsw i64 %sub1759, 2
  %add1761 = add nsw i64 %mul1760, 1
  br label %cond.end.1767

cond.false.1762:                                  ; preds = %cond.false.1746
  %232 = load i64, i64* %elt, align 8
  %shr1763 = ashr i64 %232, 2
  %add1764 = add nsw i64 0, %shr1763
  %mul1765 = mul nsw i64 0, %add1764
  %sub1766 = sub nsw i64 %mul1765, 1
  br label %cond.end.1767

cond.end.1767:                                    ; preds = %cond.false.1762, %cond.true.1753
  %cond1768 = phi i64 [ %add1761, %cond.true.1753 ], [ %sub1766, %cond.false.1762 ]
  %div1769 = sdiv i64 %cond1768, 8
  %233 = load i64, i64* %elt, align 8
  %shr1770 = ashr i64 %233, 2
  %cmp1771 = icmp slt i64 %div1769, %shr1770
  br i1 %cmp1771, label %cond.true.1790, label %lor.lhs.false.1773

lor.lhs.false.1773:                               ; preds = %cond.end.1767, %cond.end.1741, %cond.true.1704, %cond.end.1697, %cond.true.1665, %cond.end.1659
  %234 = load i64, i64* %elt, align 8
  %shr1774 = ashr i64 %234, 2
  %mul1775 = mul nsw i64 %shr1774, 8
  %mul1776 = mul nsw i64 0, %mul1775
  %sub1777 = sub nsw i64 %mul1776, 1
  %cmp1778 = icmp slt i64 %sub1777, 0
  br i1 %cmp1778, label %land.lhs.true.1780, label %lor.lhs.false.1785

land.lhs.true.1780:                               ; preds = %lor.lhs.false.1773
  %235 = load i64, i64* %elt, align 8
  %shr1781 = ashr i64 %235, 2
  %mul1782 = mul nsw i64 %shr1781, 8
  %cmp1783 = icmp slt i64 %mul1782, -9223372036854775808
  br i1 %cmp1783, label %cond.true.1790, label %lor.lhs.false.1785

lor.lhs.false.1785:                               ; preds = %land.lhs.true.1780, %lor.lhs.false.1773
  %236 = load i64, i64* %elt, align 8
  %shr1786 = ashr i64 %236, 2
  %mul1787 = mul nsw i64 %shr1786, 8
  %cmp1788 = icmp slt i64 9223372036854775807, %mul1787
  br i1 %cmp1788, label %cond.true.1790, label %cond.false.1805

cond.true.1790:                                   ; preds = %lor.lhs.false.1785, %land.lhs.true.1780, %cond.end.1767, %cond.end.1741, %cond.true.1704, %cond.end.1697, %cond.true.1665, %cond.end.1659, %land.lhs.true.1628
  %237 = load i64, i64* %elt, align 8
  %shr1791 = ashr i64 %237, 2
  %mul1792 = mul i64 %shr1791, 8
  %cmp1793 = icmp ule i64 %mul1792, 9223372036854775807
  br i1 %cmp1793, label %cond.true.1795, label %cond.false.1798

cond.true.1795:                                   ; preds = %cond.true.1790
  %238 = load i64, i64* %elt, align 8
  %shr1796 = ashr i64 %238, 2
  %mul1797 = mul i64 %shr1796, 8
  br label %cond.end.1803

cond.false.1798:                                  ; preds = %cond.true.1790
  %239 = load i64, i64* %elt, align 8
  %shr1799 = ashr i64 %239, 2
  %mul1800 = mul i64 %shr1799, 8
  %sub1801 = sub i64 %mul1800, -9223372036854775808
  %add1802 = add nsw i64 %sub1801, -9223372036854775808
  br label %cond.end.1803

cond.end.1803:                                    ; preds = %cond.false.1798, %cond.true.1795
  %cond1804 = phi i64 [ %mul1797, %cond.true.1795 ], [ %add1802, %cond.false.1798 ]
  store i64 %cond1804, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then, label %lor.lhs.false.2502

cond.false.1805:                                  ; preds = %lor.lhs.false.1785
  %240 = load i64, i64* %elt, align 8
  %shr1806 = ashr i64 %240, 2
  %mul1807 = mul i64 %shr1806, 8
  %cmp1808 = icmp ule i64 %mul1807, 9223372036854775807
  br i1 %cmp1808, label %cond.true.1810, label %cond.false.1813

cond.true.1810:                                   ; preds = %cond.false.1805
  %241 = load i64, i64* %elt, align 8
  %shr1811 = ashr i64 %241, 2
  %mul1812 = mul i64 %shr1811, 8
  br label %cond.end.1818

cond.false.1813:                                  ; preds = %cond.false.1805
  %242 = load i64, i64* %elt, align 8
  %shr1814 = ashr i64 %242, 2
  %mul1815 = mul i64 %shr1814, 8
  %sub1816 = sub i64 %mul1815, -9223372036854775808
  %add1817 = add nsw i64 %sub1816, -9223372036854775808
  br label %cond.end.1818

cond.end.1818:                                    ; preds = %cond.false.1813, %cond.true.1810
  %cond1819 = phi i64 [ %mul1812, %cond.true.1810 ], [ %add1817, %cond.false.1813 ]
  store i64 %cond1819, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then, label %lor.lhs.false.2502

cond.false.1820:                                  ; preds = %cond.true.1592
  %243 = load i64, i64* %elt, align 8
  %shr1821 = ashr i64 %243, 2
  %add1822 = add nsw i64 0, %shr1821
  %mul1823 = mul nsw i64 0, %add1822
  %sub1824 = sub nsw i64 %mul1823, 1
  %cmp1825 = icmp slt i64 %sub1824, 0
  br i1 %cmp1825, label %cond.true.1827, label %cond.false.1846

cond.true.1827:                                   ; preds = %cond.false.1820
  %244 = load i64, i64* %elt, align 8
  %shr1828 = ashr i64 %244, 2
  %add1829 = add nsw i64 0, %shr1828
  %mul1830 = mul nsw i64 0, %add1829
  %add1831 = add nsw i64 %mul1830, 0
  %neg1832 = xor i64 %add1831, -1
  %cmp1833 = icmp eq i64 %neg1832, -1
  %conv1834 = zext i1 %cmp1833 to i32
  %sub1835 = sub nsw i32 0, %conv1834
  %conv1836 = sext i32 %sub1835 to i64
  %245 = load i64, i64* %elt, align 8
  %shr1837 = ashr i64 %245, 2
  %add1838 = add nsw i64 0, %shr1837
  %mul1839 = mul nsw i64 0, %add1838
  %add1840 = add nsw i64 %mul1839, 1
  %shl1841 = shl i64 %add1840, 62
  %sub1842 = sub nsw i64 %shl1841, 1
  %mul1843 = mul nsw i64 %sub1842, 2
  %add1844 = add nsw i64 %mul1843, 1
  %sub1845 = sub nsw i64 %conv1836, %add1844
  br label %cond.end.1851

cond.false.1846:                                  ; preds = %cond.false.1820
  %246 = load i64, i64* %elt, align 8
  %shr1847 = ashr i64 %246, 2
  %add1848 = add nsw i64 0, %shr1847
  %mul1849 = mul nsw i64 0, %add1848
  %add1850 = add nsw i64 %mul1849, 0
  br label %cond.end.1851

cond.end.1851:                                    ; preds = %cond.false.1846, %cond.true.1827
  %cond1852 = phi i64 [ %sub1845, %cond.true.1827 ], [ %add1850, %cond.false.1846 ]
  %cmp1853 = icmp eq i64 %cond1852, 0
  br i1 %cmp1853, label %land.lhs.true.1855, label %lor.lhs.false.1859

land.lhs.true.1855:                               ; preds = %cond.end.1851
  %247 = load i64, i64* %elt, align 8
  %shr1856 = ashr i64 %247, 2
  %cmp1857 = icmp slt i64 %shr1856, 0
  br i1 %cmp1857, label %cond.true.2017, label %lor.lhs.false.1859

lor.lhs.false.1859:                               ; preds = %land.lhs.true.1855, %cond.end.1851
  br i1 false, label %cond.true.1860, label %cond.false.1930

cond.true.1860:                                   ; preds = %lor.lhs.false.1859
  %248 = load i64, i64* %elt, align 8
  %shr1861 = ashr i64 %248, 2
  %cmp1862 = icmp slt i64 %shr1861, 0
  br i1 %cmp1862, label %cond.true.1864, label %cond.false.1891

cond.true.1864:                                   ; preds = %cond.true.1860
  %249 = load i64, i64* %elt, align 8
  %shr1865 = ashr i64 %249, 2
  %250 = load i64, i64* %elt, align 8
  %shr1866 = ashr i64 %250, 2
  %add1867 = add nsw i64 0, %shr1866
  %mul1868 = mul nsw i64 0, %add1867
  %sub1869 = sub nsw i64 %mul1868, 1
  %cmp1870 = icmp slt i64 %sub1869, 0
  br i1 %cmp1870, label %cond.true.1872, label %cond.false.1881

cond.true.1872:                                   ; preds = %cond.true.1864
  %251 = load i64, i64* %elt, align 8
  %shr1873 = ashr i64 %251, 2
  %add1874 = add nsw i64 0, %shr1873
  %mul1875 = mul nsw i64 0, %add1874
  %add1876 = add nsw i64 %mul1875, 1
  %shl1877 = shl i64 %add1876, 62
  %sub1878 = sub nsw i64 %shl1877, 1
  %mul1879 = mul nsw i64 %sub1878, 2
  %add1880 = add nsw i64 %mul1879, 1
  br label %cond.end.1886

cond.false.1881:                                  ; preds = %cond.true.1864
  %252 = load i64, i64* %elt, align 8
  %shr1882 = ashr i64 %252, 2
  %add1883 = add nsw i64 0, %shr1882
  %mul1884 = mul nsw i64 0, %add1883
  %sub1885 = sub nsw i64 %mul1884, 1
  br label %cond.end.1886

cond.end.1886:                                    ; preds = %cond.false.1881, %cond.true.1872
  %cond1887 = phi i64 [ %add1880, %cond.true.1872 ], [ %sub1885, %cond.false.1881 ]
  %div1888 = sdiv i64 %cond1887, 8
  %cmp1889 = icmp slt i64 %shr1865, %div1888
  br i1 %cmp1889, label %cond.true.2017, label %lor.lhs.false.2000

cond.false.1891:                                  ; preds = %cond.true.1860
  br i1 false, label %cond.true.1892, label %cond.false.1893

cond.true.1892:                                   ; preds = %cond.false.1891
  br i1 false, label %cond.true.2017, label %lor.lhs.false.2000

cond.false.1893:                                  ; preds = %cond.false.1891
  %253 = load i64, i64* %elt, align 8
  %shr1894 = ashr i64 %253, 2
  %add1895 = add nsw i64 0, %shr1894
  %mul1896 = mul nsw i64 0, %add1895
  %sub1897 = sub nsw i64 %mul1896, 1
  %cmp1898 = icmp slt i64 %sub1897, 0
  br i1 %cmp1898, label %cond.true.1900, label %cond.false.1919

cond.true.1900:                                   ; preds = %cond.false.1893
  %254 = load i64, i64* %elt, align 8
  %shr1901 = ashr i64 %254, 2
  %add1902 = add nsw i64 0, %shr1901
  %mul1903 = mul nsw i64 0, %add1902
  %add1904 = add nsw i64 %mul1903, 0
  %neg1905 = xor i64 %add1904, -1
  %cmp1906 = icmp eq i64 %neg1905, -1
  %conv1907 = zext i1 %cmp1906 to i32
  %sub1908 = sub nsw i32 0, %conv1907
  %conv1909 = sext i32 %sub1908 to i64
  %255 = load i64, i64* %elt, align 8
  %shr1910 = ashr i64 %255, 2
  %add1911 = add nsw i64 0, %shr1910
  %mul1912 = mul nsw i64 0, %add1911
  %add1913 = add nsw i64 %mul1912, 1
  %shl1914 = shl i64 %add1913, 62
  %sub1915 = sub nsw i64 %shl1914, 1
  %mul1916 = mul nsw i64 %sub1915, 2
  %add1917 = add nsw i64 %mul1916, 1
  %sub1918 = sub nsw i64 %conv1909, %add1917
  br label %cond.end.1924

cond.false.1919:                                  ; preds = %cond.false.1893
  %256 = load i64, i64* %elt, align 8
  %shr1920 = ashr i64 %256, 2
  %add1921 = add nsw i64 0, %shr1920
  %mul1922 = mul nsw i64 0, %add1921
  %add1923 = add nsw i64 %mul1922, 0
  br label %cond.end.1924

cond.end.1924:                                    ; preds = %cond.false.1919, %cond.true.1900
  %cond1925 = phi i64 [ %sub1918, %cond.true.1900 ], [ %add1923, %cond.false.1919 ]
  %div1926 = sdiv i64 %cond1925, 8
  %257 = load i64, i64* %elt, align 8
  %shr1927 = ashr i64 %257, 2
  %cmp1928 = icmp slt i64 %div1926, %shr1927
  br i1 %cmp1928, label %cond.true.2017, label %lor.lhs.false.2000

cond.false.1930:                                  ; preds = %lor.lhs.false.1859
  br i1 false, label %cond.true.1931, label %cond.false.1932

cond.true.1931:                                   ; preds = %cond.false.1930
  br i1 false, label %cond.true.2017, label %lor.lhs.false.2000

cond.false.1932:                                  ; preds = %cond.false.1930
  %258 = load i64, i64* %elt, align 8
  %shr1933 = ashr i64 %258, 2
  %cmp1934 = icmp slt i64 %shr1933, 0
  br i1 %cmp1934, label %cond.true.1936, label %cond.false.1973

cond.true.1936:                                   ; preds = %cond.false.1932
  %259 = load i64, i64* %elt, align 8
  %shr1937 = ashr i64 %259, 2
  %260 = load i64, i64* %elt, align 8
  %shr1938 = ashr i64 %260, 2
  %add1939 = add nsw i64 0, %shr1938
  %mul1940 = mul nsw i64 0, %add1939
  %sub1941 = sub nsw i64 %mul1940, 1
  %cmp1942 = icmp slt i64 %sub1941, 0
  br i1 %cmp1942, label %cond.true.1944, label %cond.false.1963

cond.true.1944:                                   ; preds = %cond.true.1936
  %261 = load i64, i64* %elt, align 8
  %shr1945 = ashr i64 %261, 2
  %add1946 = add nsw i64 0, %shr1945
  %mul1947 = mul nsw i64 0, %add1946
  %add1948 = add nsw i64 %mul1947, 0
  %neg1949 = xor i64 %add1948, -1
  %cmp1950 = icmp eq i64 %neg1949, -1
  %conv1951 = zext i1 %cmp1950 to i32
  %sub1952 = sub nsw i32 0, %conv1951
  %conv1953 = sext i32 %sub1952 to i64
  %262 = load i64, i64* %elt, align 8
  %shr1954 = ashr i64 %262, 2
  %add1955 = add nsw i64 0, %shr1954
  %mul1956 = mul nsw i64 0, %add1955
  %add1957 = add nsw i64 %mul1956, 1
  %shl1958 = shl i64 %add1957, 62
  %sub1959 = sub nsw i64 %shl1958, 1
  %mul1960 = mul nsw i64 %sub1959, 2
  %add1961 = add nsw i64 %mul1960, 1
  %sub1962 = sub nsw i64 %conv1953, %add1961
  br label %cond.end.1968

cond.false.1963:                                  ; preds = %cond.true.1936
  %263 = load i64, i64* %elt, align 8
  %shr1964 = ashr i64 %263, 2
  %add1965 = add nsw i64 0, %shr1964
  %mul1966 = mul nsw i64 0, %add1965
  %add1967 = add nsw i64 %mul1966, 0
  br label %cond.end.1968

cond.end.1968:                                    ; preds = %cond.false.1963, %cond.true.1944
  %cond1969 = phi i64 [ %sub1962, %cond.true.1944 ], [ %add1967, %cond.false.1963 ]
  %div1970 = sdiv i64 %cond1969, 8
  %cmp1971 = icmp slt i64 %shr1937, %div1970
  br i1 %cmp1971, label %cond.true.2017, label %lor.lhs.false.2000

cond.false.1973:                                  ; preds = %cond.false.1932
  %264 = load i64, i64* %elt, align 8
  %shr1974 = ashr i64 %264, 2
  %add1975 = add nsw i64 0, %shr1974
  %mul1976 = mul nsw i64 0, %add1975
  %sub1977 = sub nsw i64 %mul1976, 1
  %cmp1978 = icmp slt i64 %sub1977, 0
  br i1 %cmp1978, label %cond.true.1980, label %cond.false.1989

cond.true.1980:                                   ; preds = %cond.false.1973
  %265 = load i64, i64* %elt, align 8
  %shr1981 = ashr i64 %265, 2
  %add1982 = add nsw i64 0, %shr1981
  %mul1983 = mul nsw i64 0, %add1982
  %add1984 = add nsw i64 %mul1983, 1
  %shl1985 = shl i64 %add1984, 62
  %sub1986 = sub nsw i64 %shl1985, 1
  %mul1987 = mul nsw i64 %sub1986, 2
  %add1988 = add nsw i64 %mul1987, 1
  br label %cond.end.1994

cond.false.1989:                                  ; preds = %cond.false.1973
  %266 = load i64, i64* %elt, align 8
  %shr1990 = ashr i64 %266, 2
  %add1991 = add nsw i64 0, %shr1990
  %mul1992 = mul nsw i64 0, %add1991
  %sub1993 = sub nsw i64 %mul1992, 1
  br label %cond.end.1994

cond.end.1994:                                    ; preds = %cond.false.1989, %cond.true.1980
  %cond1995 = phi i64 [ %add1988, %cond.true.1980 ], [ %sub1993, %cond.false.1989 ]
  %div1996 = sdiv i64 %cond1995, 8
  %267 = load i64, i64* %elt, align 8
  %shr1997 = ashr i64 %267, 2
  %cmp1998 = icmp slt i64 %div1996, %shr1997
  br i1 %cmp1998, label %cond.true.2017, label %lor.lhs.false.2000

lor.lhs.false.2000:                               ; preds = %cond.end.1994, %cond.end.1968, %cond.true.1931, %cond.end.1924, %cond.true.1892, %cond.end.1886
  %268 = load i64, i64* %elt, align 8
  %shr2001 = ashr i64 %268, 2
  %mul2002 = mul nsw i64 %shr2001, 8
  %mul2003 = mul nsw i64 0, %mul2002
  %sub2004 = sub nsw i64 %mul2003, 1
  %cmp2005 = icmp slt i64 %sub2004, 0
  br i1 %cmp2005, label %land.lhs.true.2007, label %lor.lhs.false.2012

land.lhs.true.2007:                               ; preds = %lor.lhs.false.2000
  %269 = load i64, i64* %elt, align 8
  %shr2008 = ashr i64 %269, 2
  %mul2009 = mul nsw i64 %shr2008, 8
  %cmp2010 = icmp slt i64 %mul2009, -9223372036854775808
  br i1 %cmp2010, label %cond.true.2017, label %lor.lhs.false.2012

lor.lhs.false.2012:                               ; preds = %land.lhs.true.2007, %lor.lhs.false.2000
  %270 = load i64, i64* %elt, align 8
  %shr2013 = ashr i64 %270, 2
  %mul2014 = mul nsw i64 %shr2013, 8
  %cmp2015 = icmp slt i64 9223372036854775807, %mul2014
  br i1 %cmp2015, label %cond.true.2017, label %cond.false.2032

cond.true.2017:                                   ; preds = %lor.lhs.false.2012, %land.lhs.true.2007, %cond.end.1994, %cond.end.1968, %cond.true.1931, %cond.end.1924, %cond.true.1892, %cond.end.1886, %land.lhs.true.1855
  %271 = load i64, i64* %elt, align 8
  %shr2018 = ashr i64 %271, 2
  %mul2019 = mul i64 %shr2018, 8
  %cmp2020 = icmp ule i64 %mul2019, 9223372036854775807
  br i1 %cmp2020, label %cond.true.2022, label %cond.false.2025

cond.true.2022:                                   ; preds = %cond.true.2017
  %272 = load i64, i64* %elt, align 8
  %shr2023 = ashr i64 %272, 2
  %mul2024 = mul i64 %shr2023, 8
  br label %cond.end.2030

cond.false.2025:                                  ; preds = %cond.true.2017
  %273 = load i64, i64* %elt, align 8
  %shr2026 = ashr i64 %273, 2
  %mul2027 = mul i64 %shr2026, 8
  %sub2028 = sub i64 %mul2027, -9223372036854775808
  %add2029 = add nsw i64 %sub2028, -9223372036854775808
  br label %cond.end.2030

cond.end.2030:                                    ; preds = %cond.false.2025, %cond.true.2022
  %cond2031 = phi i64 [ %mul2024, %cond.true.2022 ], [ %add2029, %cond.false.2025 ]
  store i64 %cond2031, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then, label %lor.lhs.false.2502

cond.false.2032:                                  ; preds = %lor.lhs.false.2012
  %274 = load i64, i64* %elt, align 8
  %shr2033 = ashr i64 %274, 2
  %mul2034 = mul i64 %shr2033, 8
  %cmp2035 = icmp ule i64 %mul2034, 9223372036854775807
  br i1 %cmp2035, label %cond.true.2037, label %cond.false.2040

cond.true.2037:                                   ; preds = %cond.false.2032
  %275 = load i64, i64* %elt, align 8
  %shr2038 = ashr i64 %275, 2
  %mul2039 = mul i64 %shr2038, 8
  br label %cond.end.2045

cond.false.2040:                                  ; preds = %cond.false.2032
  %276 = load i64, i64* %elt, align 8
  %shr2041 = ashr i64 %276, 2
  %mul2042 = mul i64 %shr2041, 8
  %sub2043 = sub i64 %mul2042, -9223372036854775808
  %add2044 = add nsw i64 %sub2043, -9223372036854775808
  br label %cond.end.2045

cond.end.2045:                                    ; preds = %cond.false.2040, %cond.true.2037
  %cond2046 = phi i64 [ %mul2039, %cond.true.2037 ], [ %add2044, %cond.false.2040 ]
  store i64 %cond2046, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then, label %lor.lhs.false.2502

cond.false.2047:                                  ; preds = %cond.false.1591
  br i1 false, label %cond.true.2048, label %cond.false.2275

cond.true.2048:                                   ; preds = %cond.false.2047
  %277 = load i64, i64* %elt, align 8
  %shr2049 = ashr i64 %277, 2
  %add2050 = add nsw i64 0, %shr2049
  %mul2051 = mul nsw i64 0, %add2050
  %sub2052 = sub nsw i64 %mul2051, 1
  %cmp2053 = icmp slt i64 %sub2052, 0
  br i1 %cmp2053, label %cond.true.2055, label %cond.false.2074

cond.true.2055:                                   ; preds = %cond.true.2048
  %278 = load i64, i64* %elt, align 8
  %shr2056 = ashr i64 %278, 2
  %add2057 = add nsw i64 0, %shr2056
  %mul2058 = mul nsw i64 0, %add2057
  %add2059 = add nsw i64 %mul2058, 0
  %neg2060 = xor i64 %add2059, -1
  %cmp2061 = icmp eq i64 %neg2060, -1
  %conv2062 = zext i1 %cmp2061 to i32
  %sub2063 = sub nsw i32 0, %conv2062
  %conv2064 = sext i32 %sub2063 to i64
  %279 = load i64, i64* %elt, align 8
  %shr2065 = ashr i64 %279, 2
  %add2066 = add nsw i64 0, %shr2065
  %mul2067 = mul nsw i64 0, %add2066
  %add2068 = add nsw i64 %mul2067, 1
  %shl2069 = shl i64 %add2068, 62
  %sub2070 = sub nsw i64 %shl2069, 1
  %mul2071 = mul nsw i64 %sub2070, 2
  %add2072 = add nsw i64 %mul2071, 1
  %sub2073 = sub nsw i64 %conv2064, %add2072
  br label %cond.end.2079

cond.false.2074:                                  ; preds = %cond.true.2048
  %280 = load i64, i64* %elt, align 8
  %shr2075 = ashr i64 %280, 2
  %add2076 = add nsw i64 0, %shr2075
  %mul2077 = mul nsw i64 0, %add2076
  %add2078 = add nsw i64 %mul2077, 0
  br label %cond.end.2079

cond.end.2079:                                    ; preds = %cond.false.2074, %cond.true.2055
  %cond2080 = phi i64 [ %sub2073, %cond.true.2055 ], [ %add2078, %cond.false.2074 ]
  %cmp2081 = icmp eq i64 %cond2080, 0
  br i1 %cmp2081, label %land.lhs.true.2083, label %lor.lhs.false.2087

land.lhs.true.2083:                               ; preds = %cond.end.2079
  %281 = load i64, i64* %elt, align 8
  %shr2084 = ashr i64 %281, 2
  %cmp2085 = icmp slt i64 %shr2084, 0
  br i1 %cmp2085, label %cond.true.2245, label %lor.lhs.false.2087

lor.lhs.false.2087:                               ; preds = %land.lhs.true.2083, %cond.end.2079
  br i1 false, label %cond.true.2088, label %cond.false.2158

cond.true.2088:                                   ; preds = %lor.lhs.false.2087
  %282 = load i64, i64* %elt, align 8
  %shr2089 = ashr i64 %282, 2
  %cmp2090 = icmp slt i64 %shr2089, 0
  br i1 %cmp2090, label %cond.true.2092, label %cond.false.2119

cond.true.2092:                                   ; preds = %cond.true.2088
  %283 = load i64, i64* %elt, align 8
  %shr2093 = ashr i64 %283, 2
  %284 = load i64, i64* %elt, align 8
  %shr2094 = ashr i64 %284, 2
  %add2095 = add nsw i64 0, %shr2094
  %mul2096 = mul nsw i64 0, %add2095
  %sub2097 = sub nsw i64 %mul2096, 1
  %cmp2098 = icmp slt i64 %sub2097, 0
  br i1 %cmp2098, label %cond.true.2100, label %cond.false.2109

cond.true.2100:                                   ; preds = %cond.true.2092
  %285 = load i64, i64* %elt, align 8
  %shr2101 = ashr i64 %285, 2
  %add2102 = add nsw i64 0, %shr2101
  %mul2103 = mul nsw i64 0, %add2102
  %add2104 = add nsw i64 %mul2103, 1
  %shl2105 = shl i64 %add2104, 62
  %sub2106 = sub nsw i64 %shl2105, 1
  %mul2107 = mul nsw i64 %sub2106, 2
  %add2108 = add nsw i64 %mul2107, 1
  br label %cond.end.2114

cond.false.2109:                                  ; preds = %cond.true.2092
  %286 = load i64, i64* %elt, align 8
  %shr2110 = ashr i64 %286, 2
  %add2111 = add nsw i64 0, %shr2110
  %mul2112 = mul nsw i64 0, %add2111
  %sub2113 = sub nsw i64 %mul2112, 1
  br label %cond.end.2114

cond.end.2114:                                    ; preds = %cond.false.2109, %cond.true.2100
  %cond2115 = phi i64 [ %add2108, %cond.true.2100 ], [ %sub2113, %cond.false.2109 ]
  %div2116 = sdiv i64 %cond2115, 8
  %cmp2117 = icmp slt i64 %shr2093, %div2116
  br i1 %cmp2117, label %cond.true.2245, label %lor.lhs.false.2228

cond.false.2119:                                  ; preds = %cond.true.2088
  br i1 false, label %cond.true.2120, label %cond.false.2121

cond.true.2120:                                   ; preds = %cond.false.2119
  br i1 false, label %cond.true.2245, label %lor.lhs.false.2228

cond.false.2121:                                  ; preds = %cond.false.2119
  %287 = load i64, i64* %elt, align 8
  %shr2122 = ashr i64 %287, 2
  %add2123 = add nsw i64 0, %shr2122
  %mul2124 = mul nsw i64 0, %add2123
  %sub2125 = sub nsw i64 %mul2124, 1
  %cmp2126 = icmp slt i64 %sub2125, 0
  br i1 %cmp2126, label %cond.true.2128, label %cond.false.2147

cond.true.2128:                                   ; preds = %cond.false.2121
  %288 = load i64, i64* %elt, align 8
  %shr2129 = ashr i64 %288, 2
  %add2130 = add nsw i64 0, %shr2129
  %mul2131 = mul nsw i64 0, %add2130
  %add2132 = add nsw i64 %mul2131, 0
  %neg2133 = xor i64 %add2132, -1
  %cmp2134 = icmp eq i64 %neg2133, -1
  %conv2135 = zext i1 %cmp2134 to i32
  %sub2136 = sub nsw i32 0, %conv2135
  %conv2137 = sext i32 %sub2136 to i64
  %289 = load i64, i64* %elt, align 8
  %shr2138 = ashr i64 %289, 2
  %add2139 = add nsw i64 0, %shr2138
  %mul2140 = mul nsw i64 0, %add2139
  %add2141 = add nsw i64 %mul2140, 1
  %shl2142 = shl i64 %add2141, 62
  %sub2143 = sub nsw i64 %shl2142, 1
  %mul2144 = mul nsw i64 %sub2143, 2
  %add2145 = add nsw i64 %mul2144, 1
  %sub2146 = sub nsw i64 %conv2137, %add2145
  br label %cond.end.2152

cond.false.2147:                                  ; preds = %cond.false.2121
  %290 = load i64, i64* %elt, align 8
  %shr2148 = ashr i64 %290, 2
  %add2149 = add nsw i64 0, %shr2148
  %mul2150 = mul nsw i64 0, %add2149
  %add2151 = add nsw i64 %mul2150, 0
  br label %cond.end.2152

cond.end.2152:                                    ; preds = %cond.false.2147, %cond.true.2128
  %cond2153 = phi i64 [ %sub2146, %cond.true.2128 ], [ %add2151, %cond.false.2147 ]
  %div2154 = sdiv i64 %cond2153, 8
  %291 = load i64, i64* %elt, align 8
  %shr2155 = ashr i64 %291, 2
  %cmp2156 = icmp slt i64 %div2154, %shr2155
  br i1 %cmp2156, label %cond.true.2245, label %lor.lhs.false.2228

cond.false.2158:                                  ; preds = %lor.lhs.false.2087
  br i1 false, label %cond.true.2159, label %cond.false.2160

cond.true.2159:                                   ; preds = %cond.false.2158
  br i1 false, label %cond.true.2245, label %lor.lhs.false.2228

cond.false.2160:                                  ; preds = %cond.false.2158
  %292 = load i64, i64* %elt, align 8
  %shr2161 = ashr i64 %292, 2
  %cmp2162 = icmp slt i64 %shr2161, 0
  br i1 %cmp2162, label %cond.true.2164, label %cond.false.2201

cond.true.2164:                                   ; preds = %cond.false.2160
  %293 = load i64, i64* %elt, align 8
  %shr2165 = ashr i64 %293, 2
  %294 = load i64, i64* %elt, align 8
  %shr2166 = ashr i64 %294, 2
  %add2167 = add nsw i64 0, %shr2166
  %mul2168 = mul nsw i64 0, %add2167
  %sub2169 = sub nsw i64 %mul2168, 1
  %cmp2170 = icmp slt i64 %sub2169, 0
  br i1 %cmp2170, label %cond.true.2172, label %cond.false.2191

cond.true.2172:                                   ; preds = %cond.true.2164
  %295 = load i64, i64* %elt, align 8
  %shr2173 = ashr i64 %295, 2
  %add2174 = add nsw i64 0, %shr2173
  %mul2175 = mul nsw i64 0, %add2174
  %add2176 = add nsw i64 %mul2175, 0
  %neg2177 = xor i64 %add2176, -1
  %cmp2178 = icmp eq i64 %neg2177, -1
  %conv2179 = zext i1 %cmp2178 to i32
  %sub2180 = sub nsw i32 0, %conv2179
  %conv2181 = sext i32 %sub2180 to i64
  %296 = load i64, i64* %elt, align 8
  %shr2182 = ashr i64 %296, 2
  %add2183 = add nsw i64 0, %shr2182
  %mul2184 = mul nsw i64 0, %add2183
  %add2185 = add nsw i64 %mul2184, 1
  %shl2186 = shl i64 %add2185, 62
  %sub2187 = sub nsw i64 %shl2186, 1
  %mul2188 = mul nsw i64 %sub2187, 2
  %add2189 = add nsw i64 %mul2188, 1
  %sub2190 = sub nsw i64 %conv2181, %add2189
  br label %cond.end.2196

cond.false.2191:                                  ; preds = %cond.true.2164
  %297 = load i64, i64* %elt, align 8
  %shr2192 = ashr i64 %297, 2
  %add2193 = add nsw i64 0, %shr2192
  %mul2194 = mul nsw i64 0, %add2193
  %add2195 = add nsw i64 %mul2194, 0
  br label %cond.end.2196

cond.end.2196:                                    ; preds = %cond.false.2191, %cond.true.2172
  %cond2197 = phi i64 [ %sub2190, %cond.true.2172 ], [ %add2195, %cond.false.2191 ]
  %div2198 = sdiv i64 %cond2197, 8
  %cmp2199 = icmp slt i64 %shr2165, %div2198
  br i1 %cmp2199, label %cond.true.2245, label %lor.lhs.false.2228

cond.false.2201:                                  ; preds = %cond.false.2160
  %298 = load i64, i64* %elt, align 8
  %shr2202 = ashr i64 %298, 2
  %add2203 = add nsw i64 0, %shr2202
  %mul2204 = mul nsw i64 0, %add2203
  %sub2205 = sub nsw i64 %mul2204, 1
  %cmp2206 = icmp slt i64 %sub2205, 0
  br i1 %cmp2206, label %cond.true.2208, label %cond.false.2217

cond.true.2208:                                   ; preds = %cond.false.2201
  %299 = load i64, i64* %elt, align 8
  %shr2209 = ashr i64 %299, 2
  %add2210 = add nsw i64 0, %shr2209
  %mul2211 = mul nsw i64 0, %add2210
  %add2212 = add nsw i64 %mul2211, 1
  %shl2213 = shl i64 %add2212, 62
  %sub2214 = sub nsw i64 %shl2213, 1
  %mul2215 = mul nsw i64 %sub2214, 2
  %add2216 = add nsw i64 %mul2215, 1
  br label %cond.end.2222

cond.false.2217:                                  ; preds = %cond.false.2201
  %300 = load i64, i64* %elt, align 8
  %shr2218 = ashr i64 %300, 2
  %add2219 = add nsw i64 0, %shr2218
  %mul2220 = mul nsw i64 0, %add2219
  %sub2221 = sub nsw i64 %mul2220, 1
  br label %cond.end.2222

cond.end.2222:                                    ; preds = %cond.false.2217, %cond.true.2208
  %cond2223 = phi i64 [ %add2216, %cond.true.2208 ], [ %sub2221, %cond.false.2217 ]
  %div2224 = sdiv i64 %cond2223, 8
  %301 = load i64, i64* %elt, align 8
  %shr2225 = ashr i64 %301, 2
  %cmp2226 = icmp slt i64 %div2224, %shr2225
  br i1 %cmp2226, label %cond.true.2245, label %lor.lhs.false.2228

lor.lhs.false.2228:                               ; preds = %cond.end.2222, %cond.end.2196, %cond.true.2159, %cond.end.2152, %cond.true.2120, %cond.end.2114
  %302 = load i64, i64* %elt, align 8
  %shr2229 = ashr i64 %302, 2
  %mul2230 = mul nsw i64 %shr2229, 8
  %mul2231 = mul nsw i64 0, %mul2230
  %sub2232 = sub nsw i64 %mul2231, 1
  %cmp2233 = icmp slt i64 %sub2232, 0
  br i1 %cmp2233, label %land.lhs.true.2235, label %lor.lhs.false.2240

land.lhs.true.2235:                               ; preds = %lor.lhs.false.2228
  %303 = load i64, i64* %elt, align 8
  %shr2236 = ashr i64 %303, 2
  %mul2237 = mul nsw i64 %shr2236, 8
  %cmp2238 = icmp slt i64 %mul2237, -9223372036854775808
  br i1 %cmp2238, label %cond.true.2245, label %lor.lhs.false.2240

lor.lhs.false.2240:                               ; preds = %land.lhs.true.2235, %lor.lhs.false.2228
  %304 = load i64, i64* %elt, align 8
  %shr2241 = ashr i64 %304, 2
  %mul2242 = mul nsw i64 %shr2241, 8
  %cmp2243 = icmp slt i64 9223372036854775807, %mul2242
  br i1 %cmp2243, label %cond.true.2245, label %cond.false.2260

cond.true.2245:                                   ; preds = %lor.lhs.false.2240, %land.lhs.true.2235, %cond.end.2222, %cond.end.2196, %cond.true.2159, %cond.end.2152, %cond.true.2120, %cond.end.2114, %land.lhs.true.2083
  %305 = load i64, i64* %elt, align 8
  %shr2246 = ashr i64 %305, 2
  %mul2247 = mul i64 %shr2246, 8
  %cmp2248 = icmp ule i64 %mul2247, 9223372036854775807
  br i1 %cmp2248, label %cond.true.2250, label %cond.false.2253

cond.true.2250:                                   ; preds = %cond.true.2245
  %306 = load i64, i64* %elt, align 8
  %shr2251 = ashr i64 %306, 2
  %mul2252 = mul i64 %shr2251, 8
  br label %cond.end.2258

cond.false.2253:                                  ; preds = %cond.true.2245
  %307 = load i64, i64* %elt, align 8
  %shr2254 = ashr i64 %307, 2
  %mul2255 = mul i64 %shr2254, 8
  %sub2256 = sub i64 %mul2255, -9223372036854775808
  %add2257 = add nsw i64 %sub2256, -9223372036854775808
  br label %cond.end.2258

cond.end.2258:                                    ; preds = %cond.false.2253, %cond.true.2250
  %cond2259 = phi i64 [ %mul2252, %cond.true.2250 ], [ %add2257, %cond.false.2253 ]
  store i64 %cond2259, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then, label %lor.lhs.false.2502

cond.false.2260:                                  ; preds = %lor.lhs.false.2240
  %308 = load i64, i64* %elt, align 8
  %shr2261 = ashr i64 %308, 2
  %mul2262 = mul i64 %shr2261, 8
  %cmp2263 = icmp ule i64 %mul2262, 9223372036854775807
  br i1 %cmp2263, label %cond.true.2265, label %cond.false.2268

cond.true.2265:                                   ; preds = %cond.false.2260
  %309 = load i64, i64* %elt, align 8
  %shr2266 = ashr i64 %309, 2
  %mul2267 = mul i64 %shr2266, 8
  br label %cond.end.2273

cond.false.2268:                                  ; preds = %cond.false.2260
  %310 = load i64, i64* %elt, align 8
  %shr2269 = ashr i64 %310, 2
  %mul2270 = mul i64 %shr2269, 8
  %sub2271 = sub i64 %mul2270, -9223372036854775808
  %add2272 = add nsw i64 %sub2271, -9223372036854775808
  br label %cond.end.2273

cond.end.2273:                                    ; preds = %cond.false.2268, %cond.true.2265
  %cond2274 = phi i64 [ %mul2267, %cond.true.2265 ], [ %add2272, %cond.false.2268 ]
  store i64 %cond2274, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then, label %lor.lhs.false.2502

cond.false.2275:                                  ; preds = %cond.false.2047
  %311 = load i64, i64* %elt, align 8
  %shr2276 = ashr i64 %311, 2
  %add2277 = add nsw i64 0, %shr2276
  %mul2278 = mul nsw i64 0, %add2277
  %sub2279 = sub nsw i64 %mul2278, 1
  %cmp2280 = icmp slt i64 %sub2279, 0
  br i1 %cmp2280, label %cond.true.2282, label %cond.false.2301

cond.true.2282:                                   ; preds = %cond.false.2275
  %312 = load i64, i64* %elt, align 8
  %shr2283 = ashr i64 %312, 2
  %add2284 = add nsw i64 0, %shr2283
  %mul2285 = mul nsw i64 0, %add2284
  %add2286 = add nsw i64 %mul2285, 0
  %neg2287 = xor i64 %add2286, -1
  %cmp2288 = icmp eq i64 %neg2287, -1
  %conv2289 = zext i1 %cmp2288 to i32
  %sub2290 = sub nsw i32 0, %conv2289
  %conv2291 = sext i32 %sub2290 to i64
  %313 = load i64, i64* %elt, align 8
  %shr2292 = ashr i64 %313, 2
  %add2293 = add nsw i64 0, %shr2292
  %mul2294 = mul nsw i64 0, %add2293
  %add2295 = add nsw i64 %mul2294, 1
  %shl2296 = shl i64 %add2295, 62
  %sub2297 = sub nsw i64 %shl2296, 1
  %mul2298 = mul nsw i64 %sub2297, 2
  %add2299 = add nsw i64 %mul2298, 1
  %sub2300 = sub nsw i64 %conv2291, %add2299
  br label %cond.end.2306

cond.false.2301:                                  ; preds = %cond.false.2275
  %314 = load i64, i64* %elt, align 8
  %shr2302 = ashr i64 %314, 2
  %add2303 = add nsw i64 0, %shr2302
  %mul2304 = mul nsw i64 0, %add2303
  %add2305 = add nsw i64 %mul2304, 0
  br label %cond.end.2306

cond.end.2306:                                    ; preds = %cond.false.2301, %cond.true.2282
  %cond2307 = phi i64 [ %sub2300, %cond.true.2282 ], [ %add2305, %cond.false.2301 ]
  %cmp2308 = icmp eq i64 %cond2307, 0
  br i1 %cmp2308, label %land.lhs.true.2310, label %lor.lhs.false.2314

land.lhs.true.2310:                               ; preds = %cond.end.2306
  %315 = load i64, i64* %elt, align 8
  %shr2311 = ashr i64 %315, 2
  %cmp2312 = icmp slt i64 %shr2311, 0
  br i1 %cmp2312, label %cond.true.2472, label %lor.lhs.false.2314

lor.lhs.false.2314:                               ; preds = %land.lhs.true.2310, %cond.end.2306
  br i1 false, label %cond.true.2315, label %cond.false.2385

cond.true.2315:                                   ; preds = %lor.lhs.false.2314
  %316 = load i64, i64* %elt, align 8
  %shr2316 = ashr i64 %316, 2
  %cmp2317 = icmp slt i64 %shr2316, 0
  br i1 %cmp2317, label %cond.true.2319, label %cond.false.2346

cond.true.2319:                                   ; preds = %cond.true.2315
  %317 = load i64, i64* %elt, align 8
  %shr2320 = ashr i64 %317, 2
  %318 = load i64, i64* %elt, align 8
  %shr2321 = ashr i64 %318, 2
  %add2322 = add nsw i64 0, %shr2321
  %mul2323 = mul nsw i64 0, %add2322
  %sub2324 = sub nsw i64 %mul2323, 1
  %cmp2325 = icmp slt i64 %sub2324, 0
  br i1 %cmp2325, label %cond.true.2327, label %cond.false.2336

cond.true.2327:                                   ; preds = %cond.true.2319
  %319 = load i64, i64* %elt, align 8
  %shr2328 = ashr i64 %319, 2
  %add2329 = add nsw i64 0, %shr2328
  %mul2330 = mul nsw i64 0, %add2329
  %add2331 = add nsw i64 %mul2330, 1
  %shl2332 = shl i64 %add2331, 62
  %sub2333 = sub nsw i64 %shl2332, 1
  %mul2334 = mul nsw i64 %sub2333, 2
  %add2335 = add nsw i64 %mul2334, 1
  br label %cond.end.2341

cond.false.2336:                                  ; preds = %cond.true.2319
  %320 = load i64, i64* %elt, align 8
  %shr2337 = ashr i64 %320, 2
  %add2338 = add nsw i64 0, %shr2337
  %mul2339 = mul nsw i64 0, %add2338
  %sub2340 = sub nsw i64 %mul2339, 1
  br label %cond.end.2341

cond.end.2341:                                    ; preds = %cond.false.2336, %cond.true.2327
  %cond2342 = phi i64 [ %add2335, %cond.true.2327 ], [ %sub2340, %cond.false.2336 ]
  %div2343 = sdiv i64 %cond2342, 8
  %cmp2344 = icmp slt i64 %shr2320, %div2343
  br i1 %cmp2344, label %cond.true.2472, label %lor.lhs.false.2455

cond.false.2346:                                  ; preds = %cond.true.2315
  br i1 false, label %cond.true.2347, label %cond.false.2348

cond.true.2347:                                   ; preds = %cond.false.2346
  br i1 false, label %cond.true.2472, label %lor.lhs.false.2455

cond.false.2348:                                  ; preds = %cond.false.2346
  %321 = load i64, i64* %elt, align 8
  %shr2349 = ashr i64 %321, 2
  %add2350 = add nsw i64 0, %shr2349
  %mul2351 = mul nsw i64 0, %add2350
  %sub2352 = sub nsw i64 %mul2351, 1
  %cmp2353 = icmp slt i64 %sub2352, 0
  br i1 %cmp2353, label %cond.true.2355, label %cond.false.2374

cond.true.2355:                                   ; preds = %cond.false.2348
  %322 = load i64, i64* %elt, align 8
  %shr2356 = ashr i64 %322, 2
  %add2357 = add nsw i64 0, %shr2356
  %mul2358 = mul nsw i64 0, %add2357
  %add2359 = add nsw i64 %mul2358, 0
  %neg2360 = xor i64 %add2359, -1
  %cmp2361 = icmp eq i64 %neg2360, -1
  %conv2362 = zext i1 %cmp2361 to i32
  %sub2363 = sub nsw i32 0, %conv2362
  %conv2364 = sext i32 %sub2363 to i64
  %323 = load i64, i64* %elt, align 8
  %shr2365 = ashr i64 %323, 2
  %add2366 = add nsw i64 0, %shr2365
  %mul2367 = mul nsw i64 0, %add2366
  %add2368 = add nsw i64 %mul2367, 1
  %shl2369 = shl i64 %add2368, 62
  %sub2370 = sub nsw i64 %shl2369, 1
  %mul2371 = mul nsw i64 %sub2370, 2
  %add2372 = add nsw i64 %mul2371, 1
  %sub2373 = sub nsw i64 %conv2364, %add2372
  br label %cond.end.2379

cond.false.2374:                                  ; preds = %cond.false.2348
  %324 = load i64, i64* %elt, align 8
  %shr2375 = ashr i64 %324, 2
  %add2376 = add nsw i64 0, %shr2375
  %mul2377 = mul nsw i64 0, %add2376
  %add2378 = add nsw i64 %mul2377, 0
  br label %cond.end.2379

cond.end.2379:                                    ; preds = %cond.false.2374, %cond.true.2355
  %cond2380 = phi i64 [ %sub2373, %cond.true.2355 ], [ %add2378, %cond.false.2374 ]
  %div2381 = sdiv i64 %cond2380, 8
  %325 = load i64, i64* %elt, align 8
  %shr2382 = ashr i64 %325, 2
  %cmp2383 = icmp slt i64 %div2381, %shr2382
  br i1 %cmp2383, label %cond.true.2472, label %lor.lhs.false.2455

cond.false.2385:                                  ; preds = %lor.lhs.false.2314
  br i1 false, label %cond.true.2386, label %cond.false.2387

cond.true.2386:                                   ; preds = %cond.false.2385
  br i1 false, label %cond.true.2472, label %lor.lhs.false.2455

cond.false.2387:                                  ; preds = %cond.false.2385
  %326 = load i64, i64* %elt, align 8
  %shr2388 = ashr i64 %326, 2
  %cmp2389 = icmp slt i64 %shr2388, 0
  br i1 %cmp2389, label %cond.true.2391, label %cond.false.2428

cond.true.2391:                                   ; preds = %cond.false.2387
  %327 = load i64, i64* %elt, align 8
  %shr2392 = ashr i64 %327, 2
  %328 = load i64, i64* %elt, align 8
  %shr2393 = ashr i64 %328, 2
  %add2394 = add nsw i64 0, %shr2393
  %mul2395 = mul nsw i64 0, %add2394
  %sub2396 = sub nsw i64 %mul2395, 1
  %cmp2397 = icmp slt i64 %sub2396, 0
  br i1 %cmp2397, label %cond.true.2399, label %cond.false.2418

cond.true.2399:                                   ; preds = %cond.true.2391
  %329 = load i64, i64* %elt, align 8
  %shr2400 = ashr i64 %329, 2
  %add2401 = add nsw i64 0, %shr2400
  %mul2402 = mul nsw i64 0, %add2401
  %add2403 = add nsw i64 %mul2402, 0
  %neg2404 = xor i64 %add2403, -1
  %cmp2405 = icmp eq i64 %neg2404, -1
  %conv2406 = zext i1 %cmp2405 to i32
  %sub2407 = sub nsw i32 0, %conv2406
  %conv2408 = sext i32 %sub2407 to i64
  %330 = load i64, i64* %elt, align 8
  %shr2409 = ashr i64 %330, 2
  %add2410 = add nsw i64 0, %shr2409
  %mul2411 = mul nsw i64 0, %add2410
  %add2412 = add nsw i64 %mul2411, 1
  %shl2413 = shl i64 %add2412, 62
  %sub2414 = sub nsw i64 %shl2413, 1
  %mul2415 = mul nsw i64 %sub2414, 2
  %add2416 = add nsw i64 %mul2415, 1
  %sub2417 = sub nsw i64 %conv2408, %add2416
  br label %cond.end.2423

cond.false.2418:                                  ; preds = %cond.true.2391
  %331 = load i64, i64* %elt, align 8
  %shr2419 = ashr i64 %331, 2
  %add2420 = add nsw i64 0, %shr2419
  %mul2421 = mul nsw i64 0, %add2420
  %add2422 = add nsw i64 %mul2421, 0
  br label %cond.end.2423

cond.end.2423:                                    ; preds = %cond.false.2418, %cond.true.2399
  %cond2424 = phi i64 [ %sub2417, %cond.true.2399 ], [ %add2422, %cond.false.2418 ]
  %div2425 = sdiv i64 %cond2424, 8
  %cmp2426 = icmp slt i64 %shr2392, %div2425
  br i1 %cmp2426, label %cond.true.2472, label %lor.lhs.false.2455

cond.false.2428:                                  ; preds = %cond.false.2387
  %332 = load i64, i64* %elt, align 8
  %shr2429 = ashr i64 %332, 2
  %add2430 = add nsw i64 0, %shr2429
  %mul2431 = mul nsw i64 0, %add2430
  %sub2432 = sub nsw i64 %mul2431, 1
  %cmp2433 = icmp slt i64 %sub2432, 0
  br i1 %cmp2433, label %cond.true.2435, label %cond.false.2444

cond.true.2435:                                   ; preds = %cond.false.2428
  %333 = load i64, i64* %elt, align 8
  %shr2436 = ashr i64 %333, 2
  %add2437 = add nsw i64 0, %shr2436
  %mul2438 = mul nsw i64 0, %add2437
  %add2439 = add nsw i64 %mul2438, 1
  %shl2440 = shl i64 %add2439, 62
  %sub2441 = sub nsw i64 %shl2440, 1
  %mul2442 = mul nsw i64 %sub2441, 2
  %add2443 = add nsw i64 %mul2442, 1
  br label %cond.end.2449

cond.false.2444:                                  ; preds = %cond.false.2428
  %334 = load i64, i64* %elt, align 8
  %shr2445 = ashr i64 %334, 2
  %add2446 = add nsw i64 0, %shr2445
  %mul2447 = mul nsw i64 0, %add2446
  %sub2448 = sub nsw i64 %mul2447, 1
  br label %cond.end.2449

cond.end.2449:                                    ; preds = %cond.false.2444, %cond.true.2435
  %cond2450 = phi i64 [ %add2443, %cond.true.2435 ], [ %sub2448, %cond.false.2444 ]
  %div2451 = sdiv i64 %cond2450, 8
  %335 = load i64, i64* %elt, align 8
  %shr2452 = ashr i64 %335, 2
  %cmp2453 = icmp slt i64 %div2451, %shr2452
  br i1 %cmp2453, label %cond.true.2472, label %lor.lhs.false.2455

lor.lhs.false.2455:                               ; preds = %cond.end.2449, %cond.end.2423, %cond.true.2386, %cond.end.2379, %cond.true.2347, %cond.end.2341
  %336 = load i64, i64* %elt, align 8
  %shr2456 = ashr i64 %336, 2
  %mul2457 = mul nsw i64 %shr2456, 8
  %mul2458 = mul nsw i64 0, %mul2457
  %sub2459 = sub nsw i64 %mul2458, 1
  %cmp2460 = icmp slt i64 %sub2459, 0
  br i1 %cmp2460, label %land.lhs.true.2462, label %lor.lhs.false.2467

land.lhs.true.2462:                               ; preds = %lor.lhs.false.2455
  %337 = load i64, i64* %elt, align 8
  %shr2463 = ashr i64 %337, 2
  %mul2464 = mul nsw i64 %shr2463, 8
  %cmp2465 = icmp slt i64 %mul2464, -9223372036854775808
  br i1 %cmp2465, label %cond.true.2472, label %lor.lhs.false.2467

lor.lhs.false.2467:                               ; preds = %land.lhs.true.2462, %lor.lhs.false.2455
  %338 = load i64, i64* %elt, align 8
  %shr2468 = ashr i64 %338, 2
  %mul2469 = mul nsw i64 %shr2468, 8
  %cmp2470 = icmp slt i64 9223372036854775807, %mul2469
  br i1 %cmp2470, label %cond.true.2472, label %cond.false.2487

cond.true.2472:                                   ; preds = %lor.lhs.false.2467, %land.lhs.true.2462, %cond.end.2449, %cond.end.2423, %cond.true.2386, %cond.end.2379, %cond.true.2347, %cond.end.2341, %land.lhs.true.2310
  %339 = load i64, i64* %elt, align 8
  %shr2473 = ashr i64 %339, 2
  %mul2474 = mul i64 %shr2473, 8
  %cmp2475 = icmp ule i64 %mul2474, 9223372036854775807
  br i1 %cmp2475, label %cond.true.2477, label %cond.false.2480

cond.true.2477:                                   ; preds = %cond.true.2472
  %340 = load i64, i64* %elt, align 8
  %shr2478 = ashr i64 %340, 2
  %mul2479 = mul i64 %shr2478, 8
  br label %cond.end.2485

cond.false.2480:                                  ; preds = %cond.true.2472
  %341 = load i64, i64* %elt, align 8
  %shr2481 = ashr i64 %341, 2
  %mul2482 = mul i64 %shr2481, 8
  %sub2483 = sub i64 %mul2482, -9223372036854775808
  %add2484 = add nsw i64 %sub2483, -9223372036854775808
  br label %cond.end.2485

cond.end.2485:                                    ; preds = %cond.false.2480, %cond.true.2477
  %cond2486 = phi i64 [ %mul2479, %cond.true.2477 ], [ %add2484, %cond.false.2480 ]
  store i64 %cond2486, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then, label %lor.lhs.false.2502

cond.false.2487:                                  ; preds = %lor.lhs.false.2467
  %342 = load i64, i64* %elt, align 8
  %shr2488 = ashr i64 %342, 2
  %mul2489 = mul i64 %shr2488, 8
  %cmp2490 = icmp ule i64 %mul2489, 9223372036854775807
  br i1 %cmp2490, label %cond.true.2492, label %cond.false.2495

cond.true.2492:                                   ; preds = %cond.false.2487
  %343 = load i64, i64* %elt, align 8
  %shr2493 = ashr i64 %343, 2
  %mul2494 = mul i64 %shr2493, 8
  br label %cond.end.2500

cond.false.2495:                                  ; preds = %cond.false.2487
  %344 = load i64, i64* %elt, align 8
  %shr2496 = ashr i64 %344, 2
  %mul2497 = mul i64 %shr2496, 8
  %sub2498 = sub i64 %mul2497, -9223372036854775808
  %add2499 = add nsw i64 %sub2498, -9223372036854775808
  br label %cond.end.2500

cond.end.2500:                                    ; preds = %cond.false.2495, %cond.true.2492
  %cond2501 = phi i64 [ %mul2494, %cond.true.2492 ], [ %add2499, %cond.false.2495 ]
  store i64 %cond2501, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then, label %lor.lhs.false.2502

lor.lhs.false.2502:                               ; preds = %cond.end.2500, %cond.end.2485, %cond.end.2273, %cond.end.2258, %cond.end.2045, %cond.end.2030, %cond.end.1818, %cond.end.1803, %cond.end.1588, %cond.end.1569, %cond.end.1353, %cond.end.1334, %cond.end.1091, %cond.end.1065, %cond.end.842, %cond.end.816, %cond.end.538, %cond.end.512, %cond.end.289, %cond.end.263
  %345 = load i64, i64* %alloca_nbytes, align 8
  %cmp2503 = icmp ult i64 -1, %345
  br i1 %cmp2503, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false.2502, %cond.end.2500, %cond.end.2485, %cond.end.2273, %cond.end.2258, %cond.end.2045, %cond.end.2030, %cond.end.1818, %cond.end.1803, %cond.end.1588, %cond.end.1569, %cond.end.1353, %cond.end.1334, %cond.end.1091, %cond.end.1065, %cond.end.842, %cond.end.816, %cond.end.538, %cond.end.512, %cond.end.289, %cond.end.263
  call void @memory_full(i64 -1) #8
  unreachable

if.else:                                          ; preds = %lor.lhs.false.2502
  %346 = load i64, i64* %alloca_nbytes, align 8
  %347 = load i64, i64* %sa_avail, align 8
  %cmp2505 = icmp sle i64 %346, %347
  br i1 %cmp2505, label %if.then.2507, label %if.else.2509

if.then.2507:                                     ; preds = %if.else
  %348 = load i64, i64* %alloca_nbytes, align 8
  %349 = load i64, i64* %sa_avail, align 8
  %sub2508 = sub nsw i64 %349, %348
  store i64 %sub2508, i64* %sa_avail, align 8
  %350 = load i64, i64* %alloca_nbytes, align 8
  %351 = alloca i8, i64 %350
  %352 = bitcast i8* %351 to i64*
  store i64* %352, i64** %temps, align 8
  br label %if.end

if.else.2509:                                     ; preds = %if.else
  %353 = load i64, i64* %alloca_nbytes, align 8
  %call2510 = call noalias i8* @xmalloc(i64 %353)
  %354 = bitcast i8* %call2510 to i64*
  store i64* %354, i64** %temps, align 8
  %355 = load i64*, i64** %temps, align 8
  %356 = load i64, i64* %elt, align 8
  %shr2511 = ashr i64 %356, 2
  %call2512 = call i64 @make_save_memory(i64* %355, i64 %shr2511)
  store i64 %call2512, i64* %arg_, align 8
  store i8 1, i8* %sa_must_free, align 1
  %357 = load i64, i64* %arg_, align 8
  call void @record_unwind_protect(void (i64)* @free_save_value, i64 %357)
  br label %if.end

if.end:                                           ; preds = %if.else.2509, %if.then.2507
  br label %if.end.2513

if.end.2513:                                      ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %if.end.2513
  store i64 0, i64* %argnum, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end
  %358 = load i64, i64* %varlist, align 8
  %and = and i64 %358, 7
  %conv2514 = trunc i64 %and to i32
  %cmp2515 = icmp eq i32 %conv2514, 3
  br i1 %cmp2515, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %do.body.2517

do.body.2517:                                     ; preds = %for.body
  %359 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call2518 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp2519 = icmp eq i64 %359, %call2518
  br i1 %cmp2519, label %if.else.2526, label %land.lhs.true.2521

land.lhs.true.2521:                               ; preds = %do.body.2517
  %360 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  %call2522 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp2523 = icmp eq i64 %360, %call2522
  br i1 %cmp2523, label %if.then.2525, label %if.else.2526

if.then.2525:                                     ; preds = %land.lhs.true.2521
  call void @process_quit_flag()
  br label %if.end.2529

if.else.2526:                                     ; preds = %land.lhs.true.2521, %do.body.2517
  %361 = load volatile i8, i8* @pending_signals, align 1
  %tobool = trunc i8 %361 to i1
  br i1 %tobool, label %if.then.2527, label %if.end.2528

if.then.2527:                                     ; preds = %if.else.2526
  call void @process_pending_signals()
  br label %if.end.2528

if.end.2528:                                      ; preds = %if.then.2527, %if.else.2526
  br label %if.end.2529

if.end.2529:                                      ; preds = %if.end.2528, %if.then.2525
  br label %do.end.2530

do.end.2530:                                      ; preds = %if.end.2529
  %362 = load i64, i64* %varlist, align 8
  %sub2531 = sub nsw i64 %362, 3
  %363 = inttoptr i64 %sub2531 to i8*
  %364 = bitcast i8* %363 to %struct.Lisp_Cons*
  %car2532 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %364, i32 0, i32 0
  %365 = load i64, i64* %car2532, align 8
  store i64 %365, i64* %elt, align 8
  %366 = load i64, i64* %elt, align 8
  %and2533 = and i64 %366, 7
  %conv2534 = trunc i64 %and2533 to i32
  %cmp2535 = icmp eq i32 %conv2534, 0
  br i1 %cmp2535, label %if.then.2537, label %if.else.2539

if.then.2537:                                     ; preds = %do.end.2530
  %call2538 = call i64 @builtin_lisp_symbol(i32 0)
  %367 = load i64, i64* %argnum, align 8
  %inc = add nsw i64 %367, 1
  store i64 %inc, i64* %argnum, align 8
  %368 = load i64*, i64** %temps, align 8
  %arrayidx = getelementptr inbounds i64, i64* %368, i64 %367
  store i64 %call2538, i64* %arrayidx, align 8
  br label %if.end.2553

if.else.2539:                                     ; preds = %do.end.2530
  %369 = load i64, i64* %elt, align 8
  %call2540 = call i64 @Fcdr(i64 %369)
  %call2541 = call i64 @Fcdr(i64 %call2540)
  %call2542 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp2543 = icmp eq i64 %call2541, %call2542
  br i1 %cmp2543, label %if.else.2546, label %if.then.2545

if.then.2545:                                     ; preds = %if.else.2539
  %370 = load i64, i64* %elt, align 8
  call void @signal_error(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.6, i32 0, i32 0), i64 %370) #8
  unreachable

if.else.2546:                                     ; preds = %if.else.2539
  %371 = load i64, i64* %elt, align 8
  %call2547 = call i64 @Fcdr(i64 %371)
  %call2548 = call i64 @Fcar(i64 %call2547)
  %call2549 = call i64 @eval_sub(i64 %call2548)
  %372 = load i64, i64* %argnum, align 8
  %inc2550 = add nsw i64 %372, 1
  store i64 %inc2550, i64* %argnum, align 8
  %373 = load i64*, i64** %temps, align 8
  %arrayidx2551 = getelementptr inbounds i64, i64* %373, i64 %372
  store i64 %call2549, i64* %arrayidx2551, align 8
  br label %if.end.2552

if.end.2552:                                      ; preds = %if.else.2546
  br label %if.end.2553

if.end.2553:                                      ; preds = %if.end.2552, %if.then.2537
  br label %for.inc

for.inc:                                          ; preds = %if.end.2553
  %374 = load i64, i64* %varlist, align 8
  %sub2554 = sub nsw i64 %374, 3
  %375 = inttoptr i64 %sub2554 to i8*
  %376 = bitcast i8* %375 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %376, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %377 = load i64, i64* %cdr, align 8
  store i64 %377, i64* %varlist, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %378 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 147), align 8
  store i64 %378, i64* %lexenv, align 8
  %379 = load i64, i64* %args.addr, align 8
  %sub2555 = sub nsw i64 %379, 3
  %380 = inttoptr i64 %sub2555 to i8*
  %381 = bitcast i8* %380 to %struct.Lisp_Cons*
  %car2556 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %381, i32 0, i32 0
  %382 = load i64, i64* %car2556, align 8
  store i64 %382, i64* %varlist, align 8
  store i64 0, i64* %argnum, align 8
  br label %for.cond.2557

for.cond.2557:                                    ; preds = %for.inc.2596, %for.end
  %383 = load i64, i64* %varlist, align 8
  %and2558 = and i64 %383, 7
  %conv2559 = trunc i64 %and2558 to i32
  %cmp2560 = icmp eq i32 %conv2559, 3
  br i1 %cmp2560, label %for.body.2562, label %for.end.2600

for.body.2562:                                    ; preds = %for.cond.2557
  %384 = load i64, i64* %varlist, align 8
  %sub2563 = sub nsw i64 %384, 3
  %385 = inttoptr i64 %sub2563 to i8*
  %386 = bitcast i8* %385 to %struct.Lisp_Cons*
  %car2564 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %386, i32 0, i32 0
  %387 = load i64, i64* %car2564, align 8
  store i64 %387, i64* %elt, align 8
  %388 = load i64, i64* %elt, align 8
  %and2565 = and i64 %388, 7
  %conv2566 = trunc i64 %and2565 to i32
  %cmp2567 = icmp eq i32 %conv2566, 0
  br i1 %cmp2567, label %cond.true.2569, label %cond.false.2570

cond.true.2569:                                   ; preds = %for.body.2562
  %389 = load i64, i64* %elt, align 8
  br label %cond.end.2572

cond.false.2570:                                  ; preds = %for.body.2562
  %390 = load i64, i64* %elt, align 8
  %call2571 = call i64 @Fcar(i64 %390)
  br label %cond.end.2572

cond.end.2572:                                    ; preds = %cond.false.2570, %cond.true.2569
  %cond2573 = phi i64 [ %389, %cond.true.2569 ], [ %call2571, %cond.false.2570 ]
  store i64 %cond2573, i64* %var, align 8
  %391 = load i64, i64* %argnum, align 8
  %inc2574 = add nsw i64 %391, 1
  store i64 %inc2574, i64* %argnum, align 8
  %392 = load i64*, i64** %temps, align 8
  %arrayidx2575 = getelementptr inbounds i64, i64* %392, i64 %391
  %393 = load i64, i64* %arrayidx2575, align 8
  store i64 %393, i64* %tem, align 8
  %394 = load i64, i64* %lexenv, align 8
  %call2576 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp2577 = icmp eq i64 %394, %call2576
  br i1 %cmp2577, label %if.else.2594, label %land.lhs.true.2579

land.lhs.true.2579:                               ; preds = %cond.end.2572
  %395 = load i64, i64* %var, align 8
  %and2580 = and i64 %395, 7
  %conv2581 = trunc i64 %and2580 to i32
  %cmp2582 = icmp eq i32 %conv2581, 0
  br i1 %cmp2582, label %land.lhs.true.2584, label %if.else.2594

land.lhs.true.2584:                               ; preds = %land.lhs.true.2579
  %396 = load i64, i64* %var, align 8
  %sub2585 = sub nsw i64 %396, 0
  %add.ptr = getelementptr inbounds i8, i8* bitcast ([1074 x %struct.Lisp_Symbol]* @lispsym to i8*), i64 %sub2585
  %397 = bitcast i8* %add.ptr to %struct.Lisp_Symbol*
  %398 = bitcast %struct.Lisp_Symbol* %397 to i16*
  %bf.load = load i16, i16* %398, align 8
  %bf.lshr = lshr i16 %bf.load, 8
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = trunc i16 %bf.clear to i1
  br i1 %bf.cast, label %if.else.2594, label %land.lhs.true.2586

land.lhs.true.2586:                               ; preds = %land.lhs.true.2584
  %399 = load i64, i64* %var, align 8
  %400 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 147), align 8
  %call2587 = call i64 @Fmemq(i64 %399, i64 %400)
  %call2588 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp2589 = icmp eq i64 %call2587, %call2588
  br i1 %cmp2589, label %if.then.2591, label %if.else.2594

if.then.2591:                                     ; preds = %land.lhs.true.2586
  %401 = load i64, i64* %var, align 8
  %402 = load i64, i64* %tem, align 8
  %call2592 = call i64 @Fcons(i64 %401, i64 %402)
  %403 = load i64, i64* %lexenv, align 8
  %call2593 = call i64 @Fcons(i64 %call2592, i64 %403)
  store i64 %call2593, i64* %lexenv, align 8
  br label %if.end.2595

if.else.2594:                                     ; preds = %land.lhs.true.2586, %land.lhs.true.2584, %land.lhs.true.2579, %cond.end.2572
  %404 = load i64, i64* %var, align 8
  %405 = load i64, i64* %tem, align 8
  call void @specbind(i64 %404, i64 %405)
  br label %if.end.2595

if.end.2595:                                      ; preds = %if.else.2594, %if.then.2591
  br label %for.inc.2596

for.inc.2596:                                     ; preds = %if.end.2595
  %406 = load i64, i64* %varlist, align 8
  %sub2597 = sub nsw i64 %406, 3
  %407 = inttoptr i64 %sub2597 to i8*
  %408 = bitcast i8* %407 to %struct.Lisp_Cons*
  %u2598 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %408, i32 0, i32 1
  %cdr2599 = bitcast %union.anon* %u2598 to i64*
  %409 = load i64, i64* %cdr2599, align 8
  store i64 %409, i64* %varlist, align 8
  br label %for.cond.2557

for.end.2600:                                     ; preds = %for.cond.2557
  %410 = load i64, i64* %lexenv, align 8
  %411 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 147), align 8
  %cmp2601 = icmp eq i64 %410, %411
  br i1 %cmp2601, label %if.end.2605, label %if.then.2603

if.then.2603:                                     ; preds = %for.end.2600
  %call2604 = call i64 @builtin_lisp_symbol(i32 567)
  %412 = load i64, i64* %lexenv, align 8
  call void @specbind(i64 %call2604, i64 %412)
  br label %if.end.2605

if.end.2605:                                      ; preds = %if.then.2603, %for.end.2600
  %413 = load i64, i64* %args.addr, align 8
  %sub2606 = sub nsw i64 %413, 3
  %414 = inttoptr i64 %sub2606 to i8*
  %415 = bitcast i8* %414 to %struct.Lisp_Cons*
  %u2607 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %415, i32 0, i32 1
  %cdr2608 = bitcast %union.anon* %u2607 to i64*
  %416 = load i64, i64* %cdr2608, align 8
  %call2609 = call i64 @Fprogn(i64 %416)
  store i64 %call2609, i64* %elt, align 8
  br label %do.body.2610

do.body.2610:                                     ; preds = %if.end.2605
  %417 = load i8, i8* %sa_must_free, align 1
  %tobool2611 = trunc i8 %417 to i1
  br i1 %tobool2611, label %if.then.2612, label %if.end.2615

if.then.2612:                                     ; preds = %do.body.2610
  store i8 0, i8* %sa_must_free, align 1
  %418 = load i64, i64* %sa_count, align 8
  %call2613 = call i64 @builtin_lisp_symbol(i32 0)
  %call2614 = call i64 @unbind_to(i64 %418, i64 %call2613)
  br label %if.end.2615

if.end.2615:                                      ; preds = %if.then.2612, %do.body.2610
  br label %do.end.2616

do.end.2616:                                      ; preds = %if.end.2615
  %419 = load i64, i64* %count, align 8
  %420 = load i64, i64* %elt, align 8
  %call2617 = call i64 @unbind_to(i64 %419, i64 %420)
  ret i64 %call2617
}

; Function Attrs: noreturn
declare void @memory_full(i64) #2

declare i64 @make_save_memory(i64*, i64) #1

declare void @free_save_value(i64) #1

; Function Attrs: nounwind uwtable
define i64 @Fwhile(i64 %args) #0 {
entry:
  %args.addr = alloca i64, align 8
  %test = alloca i64, align 8
  %body = alloca i64, align 8
  store i64 %args, i64* %args.addr, align 8
  %0 = load i64, i64* %args.addr, align 8
  %sub = sub nsw i64 %0, 3
  %1 = inttoptr i64 %sub to i8*
  %2 = bitcast i8* %1 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %2, i32 0, i32 0
  %3 = load i64, i64* %car, align 8
  store i64 %3, i64* %test, align 8
  %4 = load i64, i64* %args.addr, align 8
  %sub1 = sub nsw i64 %4, 3
  %5 = inttoptr i64 %sub1 to i8*
  %6 = bitcast i8* %5 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %6, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %7 = load i64, i64* %cdr, align 8
  store i64 %7, i64* %body, align 8
  br label %while.cond

while.cond:                                       ; preds = %do.end, %entry
  %8 = load i64, i64* %test, align 8
  %call = call i64 @eval_sub(i64 %8)
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %call, %call2
  %lnot = xor i1 %cmp, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  br label %do.body

do.body:                                          ; preds = %while.body
  %9 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp4 = icmp eq i64 %9, %call3
  br i1 %cmp4, label %if.else, label %land.lhs.true

land.lhs.true:                                    ; preds = %do.body
  %10 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  %call5 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp6 = icmp eq i64 %10, %call5
  br i1 %cmp6, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  call void @process_quit_flag()
  br label %if.end.8

if.else:                                          ; preds = %land.lhs.true, %do.body
  %11 = load volatile i8, i8* @pending_signals, align 1
  %tobool = trunc i8 %11 to i1
  br i1 %tobool, label %if.then.7, label %if.end

if.then.7:                                        ; preds = %if.else
  call void @process_pending_signals()
  br label %if.end

if.end:                                           ; preds = %if.then.7, %if.else
  br label %if.end.8

if.end.8:                                         ; preds = %if.end, %if.then
  br label %do.end

do.end:                                           ; preds = %if.end.8
  %12 = load i64, i64* %body, align 8
  %call9 = call i64 @Fprogn(i64 %12)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %call10 = call i64 @builtin_lisp_symbol(i32 0)
  ret i64 %call10
}

; Function Attrs: nounwind uwtable
define i64 @Fmacroexpand(i64 %form, i64 %environment) #0 {
entry:
  %form.addr = alloca i64, align 8
  %environment.addr = alloca i64, align 8
  %expander = alloca i64, align 8
  %sym = alloca i64, align 8
  %def = alloca i64, align 8
  %tem = alloca i64, align 8
  %newform = alloca i64, align 8
  store i64 %form, i64* %form.addr, align 8
  store i64 %environment, i64* %environment.addr, align 8
  br label %while.body

while.body:                                       ; preds = %entry, %if.end.69
  %0 = load i64, i64* %form.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %while.body
  br label %while.end.70

if.end:                                           ; preds = %while.body
  %1 = load i64, i64* %form.addr, align 8
  %sub = sub nsw i64 %1, 3
  %2 = inttoptr i64 %sub to i8*
  %3 = bitcast i8* %2 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %3, i32 0, i32 0
  %4 = load i64, i64* %car, align 8
  store i64 %4, i64* %sym, align 8
  store i64 %4, i64* %def, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call, i64* %tem, align 8
  br label %while.cond.2

while.cond.2:                                     ; preds = %if.then.27, %if.end
  %5 = load i64, i64* %def, align 8
  %and3 = and i64 %5, 7
  %conv4 = trunc i64 %and3 to i32
  %cmp5 = icmp eq i32 %conv4, 0
  br i1 %cmp5, label %while.body.7, label %while.end

while.body.7:                                     ; preds = %while.cond.2
  br label %do.body

do.body:                                          ; preds = %while.body.7
  %6 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call8 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp9 = icmp eq i64 %6, %call8
  br i1 %cmp9, label %if.else, label %land.lhs.true

land.lhs.true:                                    ; preds = %do.body
  %7 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  %call11 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp12 = icmp eq i64 %7, %call11
  br i1 %cmp12, label %if.then.14, label %if.else

if.then.14:                                       ; preds = %land.lhs.true
  call void @process_quit_flag()
  br label %if.end.17

if.else:                                          ; preds = %land.lhs.true, %do.body
  %8 = load volatile i8, i8* @pending_signals, align 1
  %tobool = trunc i8 %8 to i1
  br i1 %tobool, label %if.then.15, label %if.end.16

if.then.15:                                       ; preds = %if.else
  call void @process_pending_signals()
  br label %if.end.16

if.end.16:                                        ; preds = %if.then.15, %if.else
  br label %if.end.17

if.end.17:                                        ; preds = %if.end.16, %if.then.14
  br label %do.end

do.end:                                           ; preds = %if.end.17
  %9 = load i64, i64* %def, align 8
  store i64 %9, i64* %sym, align 8
  %10 = load i64, i64* %sym, align 8
  %11 = load i64, i64* %environment.addr, align 8
  %call18 = call i64 @Fassq(i64 %10, i64 %11)
  store i64 %call18, i64* %tem, align 8
  %12 = load i64, i64* %tem, align 8
  %call19 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp20 = icmp eq i64 %12, %call19
  br i1 %cmp20, label %if.then.22, label %if.end.29

if.then.22:                                       ; preds = %do.end
  %13 = load i64, i64* %sym, align 8
  %sub23 = sub nsw i64 %13, 0
  %add.ptr = getelementptr inbounds i8, i8* bitcast ([1074 x %struct.Lisp_Symbol]* @lispsym to i8*), i64 %sub23
  %14 = bitcast i8* %add.ptr to %struct.Lisp_Symbol*
  %function = getelementptr inbounds %struct.Lisp_Symbol, %struct.Lisp_Symbol* %14, i32 0, i32 3
  %15 = load i64, i64* %function, align 8
  store i64 %15, i64* %def, align 8
  %16 = load i64, i64* %def, align 8
  %call24 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp25 = icmp eq i64 %16, %call24
  br i1 %cmp25, label %if.end.28, label %if.then.27

if.then.27:                                       ; preds = %if.then.22
  br label %while.cond.2

if.end.28:                                        ; preds = %if.then.22
  br label %if.end.29

if.end.29:                                        ; preds = %if.end.28, %do.end
  br label %while.end

while.end:                                        ; preds = %if.end.29, %while.cond.2
  %17 = load i64, i64* %tem, align 8
  %call30 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp31 = icmp eq i64 %17, %call30
  br i1 %cmp31, label %if.then.33, label %if.else.51

if.then.33:                                       ; preds = %while.end
  %18 = load i64, i64* %def, align 8
  %19 = load i64, i64* %sym, align 8
  %call34 = call i64 @builtin_lisp_symbol(i32 636)
  %call35 = call i64 @Fautoload_do_load(i64 %18, i64 %19, i64 %call34)
  store i64 %call35, i64* %def, align 8
  %20 = load i64, i64* %def, align 8
  %and36 = and i64 %20, 7
  %conv37 = trunc i64 %and36 to i32
  %cmp38 = icmp eq i32 %conv37, 3
  br i1 %cmp38, label %if.end.41, label %if.then.40

if.then.40:                                       ; preds = %if.then.33
  br label %while.end.70

if.end.41:                                        ; preds = %if.then.33
  %21 = load i64, i64* %def, align 8
  %sub42 = sub nsw i64 %21, 3
  %22 = inttoptr i64 %sub42 to i8*
  %23 = bitcast i8* %22 to %struct.Lisp_Cons*
  %car43 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %23, i32 0, i32 0
  %24 = load i64, i64* %car43, align 8
  %call44 = call i64 @builtin_lisp_symbol(i32 636)
  %cmp45 = icmp eq i64 %24, %call44
  br i1 %cmp45, label %if.else.48, label %if.then.47

if.then.47:                                       ; preds = %if.end.41
  br label %while.end.70

if.else.48:                                       ; preds = %if.end.41
  %25 = load i64, i64* %def, align 8
  %sub49 = sub nsw i64 %25, 3
  %26 = inttoptr i64 %sub49 to i8*
  %27 = bitcast i8* %26 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %27, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %28 = load i64, i64* %cdr, align 8
  store i64 %28, i64* %expander, align 8
  br label %if.end.50

if.end.50:                                        ; preds = %if.else.48
  br label %if.end.60

if.else.51:                                       ; preds = %while.end
  %29 = load i64, i64* %tem, align 8
  %sub52 = sub nsw i64 %29, 3
  %30 = inttoptr i64 %sub52 to i8*
  %31 = bitcast i8* %30 to %struct.Lisp_Cons*
  %u53 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %31, i32 0, i32 1
  %cdr54 = bitcast %union.anon* %u53 to i64*
  %32 = load i64, i64* %cdr54, align 8
  store i64 %32, i64* %expander, align 8
  %33 = load i64, i64* %expander, align 8
  %call55 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp56 = icmp eq i64 %33, %call55
  br i1 %cmp56, label %if.then.58, label %if.end.59

if.then.58:                                       ; preds = %if.else.51
  br label %while.end.70

if.end.59:                                        ; preds = %if.else.51
  br label %if.end.60

if.end.60:                                        ; preds = %if.end.59, %if.end.50
  %34 = load i64, i64* %expander, align 8
  %35 = load i64, i64* %form.addr, align 8
  %sub61 = sub nsw i64 %35, 3
  %36 = inttoptr i64 %sub61 to i8*
  %37 = bitcast i8* %36 to %struct.Lisp_Cons*
  %u62 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %37, i32 0, i32 1
  %cdr63 = bitcast %union.anon* %u62 to i64*
  %38 = load i64, i64* %cdr63, align 8
  %call64 = call i64 @apply1(i64 %34, i64 %38)
  store i64 %call64, i64* %newform, align 8
  %39 = load i64, i64* %form.addr, align 8
  %40 = load i64, i64* %newform, align 8
  %cmp65 = icmp eq i64 %39, %40
  br i1 %cmp65, label %if.then.67, label %if.else.68

if.then.67:                                       ; preds = %if.end.60
  br label %while.end.70

if.else.68:                                       ; preds = %if.end.60
  %41 = load i64, i64* %newform, align 8
  store i64 %41, i64* %form.addr, align 8
  br label %if.end.69

if.end.69:                                        ; preds = %if.else.68
  br label %while.body

while.end.70:                                     ; preds = %if.then.67, %if.then.58, %if.then.47, %if.then.40, %if.then
  %42 = load i64, i64* %form.addr, align 8
  ret i64 %42
}

; Function Attrs: nounwind uwtable
define i64 @Fautoload_do_load(i64 %fundef, i64 %funname, i64 %macro_only) #0 {
entry:
  %retval = alloca i64, align 8
  %fundef.addr = alloca i64, align 8
  %funname.addr = alloca i64, align 8
  %macro_only.addr = alloca i64, align 8
  %count = alloca i64, align 8
  %kind = alloca i64, align 8
  %fun = alloca i64, align 8
  store i64 %fundef, i64* %fundef.addr, align 8
  store i64 %funname, i64* %funname.addr, align 8
  store i64 %macro_only, i64* %macro_only.addr, align 8
  %call = call i64 @SPECPDL_INDEX()
  store i64 %call, i64* %count, align 8
  %0 = load i64, i64* %fundef.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %call2 = call i64 @builtin_lisp_symbol(i32 191)
  %1 = load i64, i64* %fundef.addr, align 8
  %sub = sub nsw i64 %1, 3
  %2 = inttoptr i64 %sub to i8*
  %3 = bitcast i8* %2 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %3, i32 0, i32 0
  %4 = load i64, i64* %car, align 8
  %cmp3 = icmp eq i64 %call2, %4
  br i1 %cmp3, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  %5 = load i64, i64* %fundef.addr, align 8
  store i64 %5, i64* %retval
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %6 = load i64, i64* %macro_only.addr, align 8
  %call5 = call i64 @builtin_lisp_symbol(i32 636)
  %cmp6 = icmp eq i64 %6, %call5
  br i1 %cmp6, label %if.then.8, label %if.end.19

if.then.8:                                        ; preds = %if.end
  %7 = load i64, i64* %fundef.addr, align 8
  %call9 = call i64 @Fnth(i64 18, i64 %7)
  store i64 %call9, i64* %kind, align 8
  %8 = load i64, i64* %kind, align 8
  %call10 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp11 = icmp eq i64 %8, %call10
  br i1 %cmp11, label %if.end.18, label %lor.lhs.false.13

lor.lhs.false.13:                                 ; preds = %if.then.8
  %9 = load i64, i64* %kind, align 8
  %call14 = call i64 @builtin_lisp_symbol(i32 636)
  %cmp15 = icmp eq i64 %9, %call14
  br i1 %cmp15, label %if.end.18, label %if.then.17

if.then.17:                                       ; preds = %lor.lhs.false.13
  %10 = load i64, i64* %fundef.addr, align 8
  store i64 %10, i64* %retval
  br label %return

if.end.18:                                        ; preds = %lor.lhs.false.13, %if.then.8
  br label %if.end.19

if.end.19:                                        ; preds = %if.end.18, %if.end
  %11 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 240), align 8
  %call20 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp21 = icmp eq i64 %11, %call20
  br i1 %cmp21, label %if.end.26, label %if.then.23

if.then.23:                                       ; preds = %if.end.19
  %12 = load i64, i64* %funname.addr, align 8
  %call24 = call i64 @SYMBOL_NAME(i64 %12)
  %call25 = call i8* @SDATA(i64 %call24)
  call void (i8*, ...) @error(i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.9, i32 0, i32 0), i8* %call25) #8
  unreachable

if.end.26:                                        ; preds = %if.end.19
  %13 = load i64, i64* %funname.addr, align 8
  %and27 = and i64 %13, 7
  %conv28 = trunc i64 %and27 to i32
  %cmp29 = icmp eq i32 %conv28, 0
  br i1 %cmp29, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.26
  br label %cond.end

cond.false:                                       ; preds = %if.end.26
  %call31 = call i64 @builtin_lisp_symbol(i32 897)
  %14 = load i64, i64* %funname.addr, align 8
  %15 = call i64 @wrong_type_argument(i64 %call31, i64 %14) #8
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %16, %cond.true
  call void @record_unwind_save_match_data()
  %17 = load i64, i64* @Vautoload_queue, align 8
  call void @record_unwind_protect(void (i64)* @un_autoload, i64 %17)
  %call32 = call i64 @builtin_lisp_symbol(i32 901)
  store i64 %call32, i64* @Vautoload_queue, align 8
  %18 = load i64, i64* %fundef.addr, align 8
  %call33 = call i64 @Fcdr(i64 %18)
  %call34 = call i64 @Fcar(i64 %call33)
  %19 = load i64, i64* %macro_only.addr, align 8
  %call35 = call i64 @builtin_lisp_symbol(i32 901)
  %call36 = call i64 @builtin_lisp_symbol(i32 0)
  %call37 = call i64 @builtin_lisp_symbol(i32 901)
  %call38 = call i64 @Fload(i64 %call34, i64 %19, i64 %call35, i64 %call36, i64 %call37)
  %call39 = call i64 @builtin_lisp_symbol(i32 901)
  store i64 %call39, i64* @Vautoload_queue, align 8
  %20 = load i64, i64* %count, align 8
  %call40 = call i64 @builtin_lisp_symbol(i32 0)
  %call41 = call i64 @unbind_to(i64 %20, i64 %call40)
  %21 = load i64, i64* %funname.addr, align 8
  %call42 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp43 = icmp eq i64 %21, %call42
  br i1 %cmp43, label %if.then.45, label %if.else

if.then.45:                                       ; preds = %cond.end
  %call46 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call46, i64* %retval
  br label %return

if.else:                                          ; preds = %cond.end
  %22 = load i64, i64* %funname.addr, align 8
  %call47 = call i64 @builtin_lisp_symbol(i32 0)
  %call48 = call i64 @Findirect_function(i64 %22, i64 %call47)
  store i64 %call48, i64* %fun, align 8
  %23 = load i64, i64* %fun, align 8
  %24 = load i64, i64* %fundef.addr, align 8
  %call49 = call i64 @Fequal(i64 %23, i64 %24)
  %call50 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp51 = icmp eq i64 %call49, %call50
  br i1 %cmp51, label %if.else.56, label %if.then.53

if.then.53:                                       ; preds = %if.else
  %25 = load i64, i64* %funname.addr, align 8
  %call54 = call i64 @SYMBOL_NAME(i64 %25)
  %call55 = call i8* @SDATA(i64 %call54)
  call void (i8*, ...) @error(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.10, i32 0, i32 0), i8* %call55) #8
  unreachable

if.else.56:                                       ; preds = %if.else
  %26 = load i64, i64* %fun, align 8
  store i64 %26, i64* %retval
  br label %return

return:                                           ; preds = %if.else.56, %if.then.45, %if.then.17, %if.then
  %27 = load i64, i64* %retval
  ret i64 %27
}

; Function Attrs: nounwind uwtable
define i64 @Fcatch(i64 %args) #0 {
entry:
  %args.addr = alloca i64, align 8
  %tag = alloca i64, align 8
  store i64 %args, i64* %args.addr, align 8
  %0 = load i64, i64* %args.addr, align 8
  %sub = sub nsw i64 %0, 3
  %1 = inttoptr i64 %sub to i8*
  %2 = bitcast i8* %1 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %2, i32 0, i32 0
  %3 = load i64, i64* %car, align 8
  %call = call i64 @eval_sub(i64 %3)
  store i64 %call, i64* %tag, align 8
  %4 = load i64, i64* %tag, align 8
  %5 = load i64, i64* %args.addr, align 8
  %sub1 = sub nsw i64 %5, 3
  %6 = inttoptr i64 %sub1 to i8*
  %7 = bitcast i8* %6 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %7, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %8 = load i64, i64* %cdr, align 8
  %call2 = call i64 @internal_catch(i64 %4, i64 (i64)* @Fprogn, i64 %8)
  ret i64 %call2
}

; Function Attrs: nounwind uwtable
define i64 @internal_catch(i64 %tag, i64 (i64)* %func, i64 %arg) #0 {
entry:
  %retval = alloca i64, align 8
  %tag.addr = alloca i64, align 8
  %func.addr = alloca i64 (i64)*, align 8
  %arg.addr = alloca i64, align 8
  %c = alloca %struct.handler*, align 8
  %val = alloca i64, align 8
  %val3 = alloca i64, align 8
  store i64 %tag, i64* %tag.addr, align 8
  store i64 (i64)* %func, i64 (i64)** %func.addr, align 8
  store i64 %arg, i64* %arg.addr, align 8
  %0 = load i64, i64* %tag.addr, align 8
  %call = call %struct.handler* @push_handler(i64 %0, i32 0)
  store %struct.handler* %call, %struct.handler** %c, align 8
  %1 = load %struct.handler*, %struct.handler** %c, align 8
  %jmp = getelementptr inbounds %struct.handler, %struct.handler* %1, i32 0, i32 7
  %arraydecay = getelementptr inbounds [1 x %struct.__jmp_buf_tag], [1 x %struct.__jmp_buf_tag]* %jmp, i32 0, i32 0
  %call1 = call i32 @_setjmp(%struct.__jmp_buf_tag* %arraydecay) #9
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i64 (i64)*, i64 (i64)** %func.addr, align 8
  %3 = load i64, i64* %arg.addr, align 8
  %call2 = call i64 %2(i64 %3)
  store i64 %call2, i64* %val, align 8
  %4 = load %struct.handler*, %struct.handler** @handlerlist, align 8
  %next = getelementptr inbounds %struct.handler, %struct.handler* %4, i32 0, i32 3
  %5 = load %struct.handler*, %struct.handler** %next, align 8
  store %struct.handler* %5, %struct.handler** @handlerlist, align 8
  %6 = load i64, i64* %val, align 8
  store i64 %6, i64* %retval
  br label %return

if.else:                                          ; preds = %entry
  %7 = load %struct.handler*, %struct.handler** @handlerlist, align 8
  %val4 = getelementptr inbounds %struct.handler, %struct.handler* %7, i32 0, i32 2
  %8 = load i64, i64* %val4, align 8
  store i64 %8, i64* %val3, align 8
  %9 = load %struct.handler*, %struct.handler** @handlerlist, align 8
  %next5 = getelementptr inbounds %struct.handler, %struct.handler* %9, i32 0, i32 3
  %10 = load %struct.handler*, %struct.handler** %next5, align 8
  store %struct.handler* %10, %struct.handler** @handlerlist, align 8
  %11 = load i64, i64* %val3, align 8
  store i64 %11, i64* %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %12 = load i64, i64* %retval
  ret i64 %12
}

; Function Attrs: nounwind returns_twice
declare i32 @_setjmp(%struct.__jmp_buf_tag*) #4

; Function Attrs: noreturn nounwind uwtable
define i64 @Fthrow(i64 %tag, i64 %value) #3 {
entry:
  %retval = alloca i64, align 8
  %tag.addr = alloca i64, align 8
  %value.addr = alloca i64, align 8
  %c = alloca %struct.handler*, align 8
  store i64 %tag, i64* %tag.addr, align 8
  store i64 %value, i64* %value.addr, align 8
  %0 = load i64, i64* %tag.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %0, %call
  br i1 %cmp, label %if.end.9, label %if.then

if.then:                                          ; preds = %entry
  %1 = load %struct.handler*, %struct.handler** @handlerlist, align 8
  store %struct.handler* %1, %struct.handler** %c, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %2 = load %struct.handler*, %struct.handler** %c, align 8
  %tobool = icmp ne %struct.handler* %2, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load %struct.handler*, %struct.handler** %c, align 8
  %type = getelementptr inbounds %struct.handler, %struct.handler* %3, i32 0, i32 0
  %4 = load i32, i32* %type, align 4
  %cmp1 = icmp eq i32 %4, 2
  br i1 %cmp1, label %if.then.2, label %if.end

if.then.2:                                        ; preds = %for.body
  %5 = load %struct.handler*, %struct.handler** %c, align 8
  %6 = load i64, i64* %tag.addr, align 8
  %7 = load i64, i64* %value.addr, align 8
  %call3 = call i64 @Fcons(i64 %6, i64 %7)
  call void @unwind_to_catch(%struct.handler* %5, i64 %call3) #8
  unreachable

if.end:                                           ; preds = %for.body
  %8 = load %struct.handler*, %struct.handler** %c, align 8
  %type4 = getelementptr inbounds %struct.handler, %struct.handler* %8, i32 0, i32 0
  %9 = load i32, i32* %type4, align 4
  %cmp5 = icmp eq i32 %9, 0
  br i1 %cmp5, label %land.lhs.true, label %if.end.8

land.lhs.true:                                    ; preds = %if.end
  %10 = load %struct.handler*, %struct.handler** %c, align 8
  %tag_or_ch = getelementptr inbounds %struct.handler, %struct.handler* %10, i32 0, i32 1
  %11 = load i64, i64* %tag_or_ch, align 8
  %12 = load i64, i64* %tag.addr, align 8
  %cmp6 = icmp eq i64 %11, %12
  br i1 %cmp6, label %if.then.7, label %if.end.8

if.then.7:                                        ; preds = %land.lhs.true
  %13 = load %struct.handler*, %struct.handler** %c, align 8
  %14 = load i64, i64* %value.addr, align 8
  call void @unwind_to_catch(%struct.handler* %13, i64 %14) #8
  unreachable

if.end.8:                                         ; preds = %land.lhs.true, %if.end
  br label %for.inc

for.inc:                                          ; preds = %if.end.8
  %15 = load %struct.handler*, %struct.handler** %c, align 8
  %next = getelementptr inbounds %struct.handler, %struct.handler* %15, i32 0, i32 3
  %16 = load %struct.handler*, %struct.handler** %next, align 8
  store %struct.handler* %16, %struct.handler** %c, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end.9

if.end.9:                                         ; preds = %for.end, %entry
  %call10 = call i64 @builtin_lisp_symbol(i32 701)
  %17 = load i64, i64* %tag.addr, align 8
  %18 = load i64, i64* %value.addr, align 8
  call void @xsignal2(i64 %call10, i64 %17, i64 %18) #8
  unreachable

return:                                           ; No predecessors!
  %19 = load i64, i64* %retval
  ret i64 %19
}

; Function Attrs: noreturn nounwind uwtable
define internal void @unwind_to_catch(%struct.handler* %catch, i64 %value) #3 {
entry:
  %catch.addr = alloca %struct.handler*, align 8
  %value.addr = alloca i64, align 8
  %last_time = alloca i8, align 1
  store %struct.handler* %catch, %struct.handler** %catch.addr, align 8
  store i64 %value, i64* %value.addr, align 8
  %0 = load i64, i64* %value.addr, align 8
  %1 = load %struct.handler*, %struct.handler** %catch.addr, align 8
  %val = getelementptr inbounds %struct.handler, %struct.handler* %1, i32 0, i32 2
  store i64 %0, i64* %val, align 8
  %2 = load %struct.handler*, %struct.handler** %catch.addr, align 8
  %poll_suppress_count = getelementptr inbounds %struct.handler, %struct.handler* %2, i32 0, i32 10
  %3 = load i32, i32* %poll_suppress_count, align 4
  call void @set_poll_suppress_count(i32 %3)
  %4 = load %struct.handler*, %struct.handler** %catch.addr, align 8
  %interrupt_input_blocked = getelementptr inbounds %struct.handler, %struct.handler* %4, i32 0, i32 11
  %5 = load i32, i32* %interrupt_input_blocked, align 4
  call void @unblock_input_to(i32 %5)
  store i8 0, i8* @immediate_quit, align 1
  br label %do.body

do.body:                                          ; preds = %do.cond, %entry
  %6 = load %struct.handler*, %struct.handler** @handlerlist, align 8
  %pdlcount = getelementptr inbounds %struct.handler, %struct.handler* %6, i32 0, i32 9
  %7 = load i64, i64* %pdlcount, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %call1 = call i64 @unbind_to(i64 %7, i64 %call)
  %8 = load %struct.handler*, %struct.handler** @handlerlist, align 8
  %9 = load %struct.handler*, %struct.handler** %catch.addr, align 8
  %cmp = icmp eq %struct.handler* %8, %9
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %last_time, align 1
  %10 = load i8, i8* %last_time, align 1
  %tobool = trunc i8 %10 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %do.body
  %11 = load %struct.handler*, %struct.handler** @handlerlist, align 8
  %next = getelementptr inbounds %struct.handler, %struct.handler* %11, i32 0, i32 3
  %12 = load %struct.handler*, %struct.handler** %next, align 8
  store %struct.handler* %12, %struct.handler** @handlerlist, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %do.body
  br label %do.cond

do.cond:                                          ; preds = %if.end
  %13 = load i8, i8* %last_time, align 1
  %tobool2 = trunc i8 %13 to i1
  %lnot = xor i1 %tobool2, true
  br i1 %lnot, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  %14 = load %struct.handler*, %struct.handler** %catch.addr, align 8
  %byte_stack = getelementptr inbounds %struct.handler, %struct.handler* %14, i32 0, i32 12
  %15 = load %struct.byte_stack*, %struct.byte_stack** %byte_stack, align 8
  store %struct.byte_stack* %15, %struct.byte_stack** @byte_stack_list, align 8
  %16 = load %struct.handler*, %struct.handler** %catch.addr, align 8
  %lisp_eval_depth = getelementptr inbounds %struct.handler, %struct.handler* %16, i32 0, i32 8
  %17 = load i64, i64* %lisp_eval_depth, align 8
  store i64 %17, i64* @lisp_eval_depth, align 8
  %18 = load %struct.handler*, %struct.handler** %catch.addr, align 8
  %jmp = getelementptr inbounds %struct.handler, %struct.handler* %18, i32 0, i32 7
  %arraydecay = getelementptr inbounds [1 x %struct.__jmp_buf_tag], [1 x %struct.__jmp_buf_tag]* %jmp, i32 0, i32 0
  call void @_longjmp(%struct.__jmp_buf_tag* %arraydecay, i32 1) #10
  unreachable

return:                                           ; No predecessors!
  ret void
}

; Function Attrs: nounwind uwtable
define i64 @Funwind_protect(i64 %args) #0 {
entry:
  %args.addr = alloca i64, align 8
  %val = alloca i64, align 8
  %count = alloca i64, align 8
  store i64 %args, i64* %args.addr, align 8
  %call = call i64 @SPECPDL_INDEX()
  store i64 %call, i64* %count, align 8
  %0 = load i64, i64* %args.addr, align 8
  %sub = sub nsw i64 %0, 3
  %1 = inttoptr i64 %sub to i8*
  %2 = bitcast i8* %1 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %2, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %3 = load i64, i64* %cdr, align 8
  call void @record_unwind_protect(void (i64)* @unwind_body, i64 %3)
  %4 = load i64, i64* %args.addr, align 8
  %sub1 = sub nsw i64 %4, 3
  %5 = inttoptr i64 %sub1 to i8*
  %6 = bitcast i8* %5 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %6, i32 0, i32 0
  %7 = load i64, i64* %car, align 8
  %call2 = call i64 @eval_sub(i64 %7)
  store i64 %call2, i64* %val, align 8
  %8 = load i64, i64* %count, align 8
  %9 = load i64, i64* %val, align 8
  %call3 = call i64 @unbind_to(i64 %8, i64 %9)
  ret i64 %call3
}

; Function Attrs: nounwind uwtable
define i64 @Fcondition_case(i64 %args) #0 {
entry:
  %args.addr = alloca i64, align 8
  %var = alloca i64, align 8
  %bodyform = alloca i64, align 8
  %handlers = alloca i64, align 8
  store i64 %args, i64* %args.addr, align 8
  %0 = load i64, i64* %args.addr, align 8
  %sub = sub nsw i64 %0, 3
  %1 = inttoptr i64 %sub to i8*
  %2 = bitcast i8* %1 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %2, i32 0, i32 0
  %3 = load i64, i64* %car, align 8
  store i64 %3, i64* %var, align 8
  %4 = load i64, i64* %args.addr, align 8
  %sub1 = sub nsw i64 %4, 3
  %5 = inttoptr i64 %sub1 to i8*
  %6 = bitcast i8* %5 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %6, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %7 = load i64, i64* %cdr, align 8
  %sub2 = sub nsw i64 %7, 3
  %8 = inttoptr i64 %sub2 to i8*
  %9 = bitcast i8* %8 to %struct.Lisp_Cons*
  %car3 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %9, i32 0, i32 0
  %10 = load i64, i64* %car3, align 8
  store i64 %10, i64* %bodyform, align 8
  %11 = load i64, i64* %args.addr, align 8
  %sub4 = sub nsw i64 %11, 3
  %12 = inttoptr i64 %sub4 to i8*
  %13 = bitcast i8* %12 to %struct.Lisp_Cons*
  %u5 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %13, i32 0, i32 1
  %cdr6 = bitcast %union.anon* %u5 to i64*
  %14 = load i64, i64* %cdr6, align 8
  %sub7 = sub nsw i64 %14, 3
  %15 = inttoptr i64 %sub7 to i8*
  %16 = bitcast i8* %15 to %struct.Lisp_Cons*
  %u8 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %16, i32 0, i32 1
  %cdr9 = bitcast %union.anon* %u8 to i64*
  %17 = load i64, i64* %cdr9, align 8
  store i64 %17, i64* %handlers, align 8
  %18 = load i64, i64* %var, align 8
  %19 = load i64, i64* %bodyform, align 8
  %20 = load i64, i64* %handlers, align 8
  %call = call i64 @internal_lisp_condition_case(i64 %18, i64 %19, i64 %20)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define i64 @internal_lisp_condition_case(i64 %var, i64 %bodyform, i64 %handlers) #0 {
entry:
  %retval = alloca i64, align 8
  %var.addr = alloca i64, align 8
  %bodyform.addr = alloca i64, align 8
  %handlers.addr = alloca i64, align 8
  %val = alloca i64, align 8
  %oldhandlerlist = alloca %struct.handler*, align 8
  %clausenb = alloca i32, align 4
  %tem = alloca i64, align 8
  %clauses = alloca i64*, align 8
  %clauses_volatile = alloca i64*, align 8
  %i = alloca i32, align 4
  %clause = alloca i64, align 8
  %condition = alloca i64, align 8
  %c = alloca %struct.handler*, align 8
  %count = alloca i64, align 8
  %val76 = alloca i64, align 8
  %chosen_clause = alloca i64*, align 8
  store volatile i64 %var, i64* %var.addr, align 8
  store i64 %bodyform, i64* %bodyform.addr, align 8
  store i64 %handlers, i64* %handlers.addr, align 8
  %0 = load %struct.handler*, %struct.handler** @handlerlist, align 8
  store %struct.handler* %0, %struct.handler** %oldhandlerlist, align 8
  store i32 0, i32* %clausenb, align 4
  %1 = load volatile i64, i64* %var.addr, align 8
  %and = and i64 %1, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = call i64 @builtin_lisp_symbol(i32 897)
  %2 = load volatile i64, i64* %var.addr, align 8
  %3 = call i64 @wrong_type_argument(i64 %call, i64 %2) #8
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %4, %cond.true
  %5 = load i64, i64* %handlers.addr, align 8
  store i64 %5, i64* %val, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %6 = load i64, i64* %val, align 8
  %and2 = and i64 %6, 7
  %conv3 = trunc i64 %and2 to i32
  %cmp4 = icmp eq i32 %conv3, 3
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load i64, i64* %val, align 8
  %sub = sub nsw i64 %7, 3
  %8 = inttoptr i64 %sub to i8*
  %9 = bitcast i8* %8 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %9, i32 0, i32 0
  %10 = load i64, i64* %car, align 8
  store i64 %10, i64* %tem, align 8
  %11 = load i32, i32* %clausenb, align 4
  %inc = add nsw i32 %11, 1
  store i32 %inc, i32* %clausenb, align 4
  %12 = load i64, i64* %tem, align 8
  %call6 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp7 = icmp eq i64 %12, %call6
  br i1 %cmp7, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %13 = load i64, i64* %tem, align 8
  %and9 = and i64 %13, 7
  %conv10 = trunc i64 %and9 to i32
  %cmp11 = icmp eq i32 %conv10, 3
  br i1 %cmp11, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %lor.lhs.false
  %14 = load i64, i64* %tem, align 8
  %sub13 = sub nsw i64 %14, 3
  %15 = inttoptr i64 %sub13 to i8*
  %16 = bitcast i8* %15 to %struct.Lisp_Cons*
  %car14 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %16, i32 0, i32 0
  %17 = load i64, i64* %car14, align 8
  %and15 = and i64 %17, 7
  %conv16 = trunc i64 %and15 to i32
  %cmp17 = icmp eq i32 %conv16, 0
  br i1 %cmp17, label %if.end, label %lor.lhs.false.19

lor.lhs.false.19:                                 ; preds = %land.lhs.true
  %18 = load i64, i64* %tem, align 8
  %sub20 = sub nsw i64 %18, 3
  %19 = inttoptr i64 %sub20 to i8*
  %20 = bitcast i8* %19 to %struct.Lisp_Cons*
  %car21 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %20, i32 0, i32 0
  %21 = load i64, i64* %car21, align 8
  %and22 = and i64 %21, 7
  %conv23 = trunc i64 %and22 to i32
  %cmp24 = icmp eq i32 %conv23, 3
  br i1 %cmp24, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false.19, %lor.lhs.false
  %22 = load i64, i64* %tem, align 8
  %call26 = call i64 @builtin_lisp_symbol(i32 901)
  %call27 = call i64 @Fprin1_to_string(i64 %22, i64 %call26)
  %call28 = call i8* @SDATA(i64 %call27)
  call void (i8*, ...) @error(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.7, i32 0, i32 0), i8* %call28) #8
  unreachable

if.end:                                           ; preds = %lor.lhs.false.19, %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %23 = load i64, i64* %val, align 8
  %sub29 = sub nsw i64 %23, 3
  %24 = inttoptr i64 %sub29 to i8*
  %25 = bitcast i8* %24 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %25, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %26 = load i64, i64* %cdr, align 8
  store i64 %26, i64* %val, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %27 = load i32, i32* %clausenb, align 4
  %cmp30 = icmp slt i32 2048, %27
  br i1 %cmp30, label %if.then.32, label %if.end.33

if.then.32:                                       ; preds = %for.end
  call void @memory_full(i64 -1) #8
  unreachable

if.end.33:                                        ; preds = %for.end
  %28 = load i32, i32* %clausenb, align 4
  %conv34 = sext i32 %28 to i64
  %mul = mul i64 %conv34, 8
  %29 = alloca i8, i64 %mul
  %30 = bitcast i8* %29 to i64*
  store i64* %30, i64** %clauses, align 8
  %31 = load i64*, i64** %clauses, align 8
  store volatile i64* %31, i64** %clauses_volatile, align 8
  %32 = load i32, i32* %clausenb, align 4
  store i32 %32, i32* %i, align 4
  %33 = load i64, i64* %handlers.addr, align 8
  store i64 %33, i64* %val, align 8
  br label %for.cond.35

for.cond.35:                                      ; preds = %for.inc.43, %if.end.33
  %34 = load i64, i64* %val, align 8
  %and36 = and i64 %34, 7
  %conv37 = trunc i64 %and36 to i32
  %cmp38 = icmp eq i32 %conv37, 3
  br i1 %cmp38, label %for.body.40, label %for.end.47

for.body.40:                                      ; preds = %for.cond.35
  %35 = load i64, i64* %val, align 8
  %sub41 = sub nsw i64 %35, 3
  %36 = inttoptr i64 %sub41 to i8*
  %37 = bitcast i8* %36 to %struct.Lisp_Cons*
  %car42 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %37, i32 0, i32 0
  %38 = load i64, i64* %car42, align 8
  %39 = load i32, i32* %i, align 4
  %dec = add nsw i32 %39, -1
  store i32 %dec, i32* %i, align 4
  %idxprom = sext i32 %dec to i64
  %40 = load i64*, i64** %clauses, align 8
  %arrayidx = getelementptr inbounds i64, i64* %40, i64 %idxprom
  store i64 %38, i64* %arrayidx, align 8
  br label %for.inc.43

for.inc.43:                                       ; preds = %for.body.40
  %41 = load i64, i64* %val, align 8
  %sub44 = sub nsw i64 %41, 3
  %42 = inttoptr i64 %sub44 to i8*
  %43 = bitcast i8* %42 to %struct.Lisp_Cons*
  %u45 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %43, i32 0, i32 1
  %cdr46 = bitcast %union.anon* %u45 to i64*
  %44 = load i64, i64* %cdr46, align 8
  store i64 %44, i64* %val, align 8
  br label %for.cond.35

for.end.47:                                       ; preds = %for.cond.35
  store i32 0, i32* %i, align 4
  br label %for.cond.48

for.cond.48:                                      ; preds = %for.inc.110, %for.end.47
  %45 = load i32, i32* %i, align 4
  %46 = load i32, i32* %clausenb, align 4
  %cmp49 = icmp slt i32 %45, %46
  br i1 %cmp49, label %for.body.51, label %for.end.112

for.body.51:                                      ; preds = %for.cond.48
  %47 = load i32, i32* %i, align 4
  %idxprom52 = sext i32 %47 to i64
  %48 = load i64*, i64** %clauses, align 8
  %arrayidx53 = getelementptr inbounds i64, i64* %48, i64 %idxprom52
  %49 = load i64, i64* %arrayidx53, align 8
  store i64 %49, i64* %clause, align 8
  %50 = load i64, i64* %clause, align 8
  %and54 = and i64 %50, 7
  %conv55 = trunc i64 %and54 to i32
  %cmp56 = icmp eq i32 %conv55, 3
  br i1 %cmp56, label %cond.true.58, label %cond.false.61

cond.true.58:                                     ; preds = %for.body.51
  %51 = load i64, i64* %clause, align 8
  %sub59 = sub nsw i64 %51, 3
  %52 = inttoptr i64 %sub59 to i8*
  %53 = bitcast i8* %52 to %struct.Lisp_Cons*
  %car60 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %53, i32 0, i32 0
  %54 = load i64, i64* %car60, align 8
  br label %cond.end.63

cond.false.61:                                    ; preds = %for.body.51
  %call62 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end.63

cond.end.63:                                      ; preds = %cond.false.61, %cond.true.58
  %cond = phi i64 [ %54, %cond.true.58 ], [ %call62, %cond.false.61 ]
  store i64 %cond, i64* %condition, align 8
  %55 = load i64, i64* %condition, align 8
  %and64 = and i64 %55, 7
  %conv65 = trunc i64 %and64 to i32
  %cmp66 = icmp eq i32 %conv65, 3
  br i1 %cmp66, label %if.end.71, label %if.then.68

if.then.68:                                       ; preds = %cond.end.63
  %56 = load i64, i64* %condition, align 8
  %call69 = call i64 @builtin_lisp_symbol(i32 0)
  %call70 = call i64 @Fcons(i64 %56, i64 %call69)
  store i64 %call70, i64* %condition, align 8
  br label %if.end.71

if.end.71:                                        ; preds = %if.then.68, %cond.end.63
  %57 = load i64, i64* %condition, align 8
  %call72 = call %struct.handler* @push_handler(i64 %57, i32 1)
  store %struct.handler* %call72, %struct.handler** %c, align 8
  %58 = load %struct.handler*, %struct.handler** %c, align 8
  %jmp = getelementptr inbounds %struct.handler, %struct.handler* %58, i32 0, i32 7
  %arraydecay = getelementptr inbounds [1 x %struct.__jmp_buf_tag], [1 x %struct.__jmp_buf_tag]* %jmp, i32 0, i32 0
  %call73 = call i32 @_setjmp(%struct.__jmp_buf_tag* %arraydecay) #9
  %tobool = icmp ne i32 %call73, 0
  br i1 %tobool, label %if.then.74, label %if.end.109

if.then.74:                                       ; preds = %if.end.71
  %call75 = call i64 @SPECPDL_INDEX()
  store i64 %call75, i64* %count, align 8
  %59 = load %struct.handler*, %struct.handler** @handlerlist, align 8
  %val77 = getelementptr inbounds %struct.handler, %struct.handler* %59, i32 0, i32 2
  %60 = load i64, i64* %val77, align 8
  store i64 %60, i64* %val76, align 8
  %61 = load volatile i64*, i64** %clauses_volatile, align 8
  store i64* %61, i64** %chosen_clause, align 8
  %62 = load %struct.handler*, %struct.handler** @handlerlist, align 8
  %next = getelementptr inbounds %struct.handler, %struct.handler* %62, i32 0, i32 3
  %63 = load %struct.handler*, %struct.handler** %next, align 8
  store %struct.handler* %63, %struct.handler** %c, align 8
  br label %for.cond.78

for.cond.78:                                      ; preds = %for.inc.82, %if.then.74
  %64 = load %struct.handler*, %struct.handler** %c, align 8
  %65 = load %struct.handler*, %struct.handler** %oldhandlerlist, align 8
  %cmp79 = icmp ne %struct.handler* %64, %65
  br i1 %cmp79, label %for.body.81, label %for.end.84

for.body.81:                                      ; preds = %for.cond.78
  %66 = load i64*, i64** %chosen_clause, align 8
  %incdec.ptr = getelementptr inbounds i64, i64* %66, i32 1
  store i64* %incdec.ptr, i64** %chosen_clause, align 8
  br label %for.inc.82

for.inc.82:                                       ; preds = %for.body.81
  %67 = load %struct.handler*, %struct.handler** %c, align 8
  %next83 = getelementptr inbounds %struct.handler, %struct.handler* %67, i32 0, i32 3
  %68 = load %struct.handler*, %struct.handler** %next83, align 8
  store %struct.handler* %68, %struct.handler** %c, align 8
  br label %for.cond.78

for.end.84:                                       ; preds = %for.cond.78
  %69 = load %struct.handler*, %struct.handler** %oldhandlerlist, align 8
  store %struct.handler* %69, %struct.handler** @handlerlist, align 8
  %70 = load volatile i64, i64* %var.addr, align 8
  %call85 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp86 = icmp eq i64 %70, %call85
  br i1 %cmp86, label %if.end.97, label %if.then.88

if.then.88:                                       ; preds = %for.end.84
  %71 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 147), align 8
  %call89 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp90 = icmp eq i64 %71, %call89
  br i1 %cmp90, label %if.else, label %if.then.92

if.then.92:                                       ; preds = %if.then.88
  %call93 = call i64 @builtin_lisp_symbol(i32 567)
  %72 = load volatile i64, i64* %var.addr, align 8
  %73 = load i64, i64* %val76, align 8
  %call94 = call i64 @Fcons(i64 %72, i64 %73)
  %74 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 147), align 8
  %call95 = call i64 @Fcons(i64 %call94, i64 %74)
  call void @specbind(i64 %call93, i64 %call95)
  br label %if.end.96

if.else:                                          ; preds = %if.then.88
  %75 = load volatile i64, i64* %var.addr, align 8
  %76 = load i64, i64* %val76, align 8
  call void @specbind(i64 %75, i64 %76)
  br label %if.end.96

if.end.96:                                        ; preds = %if.else, %if.then.92
  br label %if.end.97

if.end.97:                                        ; preds = %if.end.96, %for.end.84
  %77 = load i64*, i64** %chosen_clause, align 8
  %78 = load i64, i64* %77, align 8
  %sub98 = sub nsw i64 %78, 3
  %79 = inttoptr i64 %sub98 to i8*
  %80 = bitcast i8* %79 to %struct.Lisp_Cons*
  %u99 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %80, i32 0, i32 1
  %cdr100 = bitcast %union.anon* %u99 to i64*
  %81 = load i64, i64* %cdr100, align 8
  %call101 = call i64 @Fprogn(i64 %81)
  store i64 %call101, i64* %val76, align 8
  %82 = load volatile i64, i64* %var.addr, align 8
  %call102 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp103 = icmp eq i64 %82, %call102
  br i1 %cmp103, label %if.end.108, label %if.then.105

if.then.105:                                      ; preds = %if.end.97
  %83 = load i64, i64* %count, align 8
  %call106 = call i64 @builtin_lisp_symbol(i32 0)
  %call107 = call i64 @unbind_to(i64 %83, i64 %call106)
  br label %if.end.108

if.end.108:                                       ; preds = %if.then.105, %if.end.97
  %84 = load i64, i64* %val76, align 8
  store i64 %84, i64* %retval
  br label %return

if.end.109:                                       ; preds = %if.end.71
  br label %for.inc.110

for.inc.110:                                      ; preds = %if.end.109
  %85 = load i32, i32* %i, align 4
  %inc111 = add nsw i32 %85, 1
  store i32 %inc111, i32* %i, align 4
  br label %for.cond.48

for.end.112:                                      ; preds = %for.cond.48
  %86 = load i64, i64* %bodyform.addr, align 8
  %call113 = call i64 @eval_sub(i64 %86)
  store i64 %call113, i64* %val, align 8
  %87 = load %struct.handler*, %struct.handler** %oldhandlerlist, align 8
  store %struct.handler* %87, %struct.handler** @handlerlist, align 8
  %88 = load i64, i64* %val, align 8
  store i64 %88, i64* %retval
  br label %return

return:                                           ; preds = %for.end.112, %if.end.108
  %89 = load i64, i64* %retval
  ret i64 %89
}

declare i8* @SDATA(i64) #1

declare i64 @Fprin1_to_string(i64, i64) #1

; Function Attrs: nounwind uwtable
define i64 @internal_condition_case(i64 ()* %bfun, i64 %handlers, i64 (i64)* %hfun) #0 {
entry:
  %retval = alloca i64, align 8
  %bfun.addr = alloca i64 ()*, align 8
  %handlers.addr = alloca i64, align 8
  %hfun.addr = alloca i64 (i64)*, align 8
  %c = alloca %struct.handler*, align 8
  %val = alloca i64, align 8
  %val4 = alloca i64, align 8
  store i64 ()* %bfun, i64 ()** %bfun.addr, align 8
  store i64 %handlers, i64* %handlers.addr, align 8
  store i64 (i64)* %hfun, i64 (i64)** %hfun.addr, align 8
  %0 = load i64, i64* %handlers.addr, align 8
  %call = call %struct.handler* @push_handler(i64 %0, i32 1)
  store %struct.handler* %call, %struct.handler** %c, align 8
  %1 = load %struct.handler*, %struct.handler** %c, align 8
  %jmp = getelementptr inbounds %struct.handler, %struct.handler* %1, i32 0, i32 7
  %arraydecay = getelementptr inbounds [1 x %struct.__jmp_buf_tag], [1 x %struct.__jmp_buf_tag]* %jmp, i32 0, i32 0
  %call1 = call i32 @_setjmp(%struct.__jmp_buf_tag* %arraydecay) #9
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load %struct.handler*, %struct.handler** @handlerlist, align 8
  %val2 = getelementptr inbounds %struct.handler, %struct.handler* %2, i32 0, i32 2
  %3 = load i64, i64* %val2, align 8
  store i64 %3, i64* %val, align 8
  %4 = load %struct.handler*, %struct.handler** @handlerlist, align 8
  %next = getelementptr inbounds %struct.handler, %struct.handler* %4, i32 0, i32 3
  %5 = load %struct.handler*, %struct.handler** %next, align 8
  store %struct.handler* %5, %struct.handler** @handlerlist, align 8
  %6 = load i64 (i64)*, i64 (i64)** %hfun.addr, align 8
  %7 = load i64, i64* %val, align 8
  %call3 = call i64 %6(i64 %7)
  store i64 %call3, i64* %retval
  br label %return

if.else:                                          ; preds = %entry
  %8 = load i64 ()*, i64 ()** %bfun.addr, align 8
  %call5 = call i64 %8()
  store i64 %call5, i64* %val4, align 8
  %9 = load %struct.handler*, %struct.handler** @handlerlist, align 8
  %next6 = getelementptr inbounds %struct.handler, %struct.handler* %9, i32 0, i32 3
  %10 = load %struct.handler*, %struct.handler** %next6, align 8
  store %struct.handler* %10, %struct.handler** @handlerlist, align 8
  %11 = load i64, i64* %val4, align 8
  store i64 %11, i64* %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %12 = load i64, i64* %retval
  ret i64 %12
}

; Function Attrs: nounwind uwtable
define i64 @internal_condition_case_1(i64 (i64)* %bfun, i64 %arg, i64 %handlers, i64 (i64)* %hfun) #0 {
entry:
  %retval = alloca i64, align 8
  %bfun.addr = alloca i64 (i64)*, align 8
  %arg.addr = alloca i64, align 8
  %handlers.addr = alloca i64, align 8
  %hfun.addr = alloca i64 (i64)*, align 8
  %c = alloca %struct.handler*, align 8
  %val = alloca i64, align 8
  %val4 = alloca i64, align 8
  store i64 (i64)* %bfun, i64 (i64)** %bfun.addr, align 8
  store i64 %arg, i64* %arg.addr, align 8
  store i64 %handlers, i64* %handlers.addr, align 8
  store i64 (i64)* %hfun, i64 (i64)** %hfun.addr, align 8
  %0 = load i64, i64* %handlers.addr, align 8
  %call = call %struct.handler* @push_handler(i64 %0, i32 1)
  store %struct.handler* %call, %struct.handler** %c, align 8
  %1 = load %struct.handler*, %struct.handler** %c, align 8
  %jmp = getelementptr inbounds %struct.handler, %struct.handler* %1, i32 0, i32 7
  %arraydecay = getelementptr inbounds [1 x %struct.__jmp_buf_tag], [1 x %struct.__jmp_buf_tag]* %jmp, i32 0, i32 0
  %call1 = call i32 @_setjmp(%struct.__jmp_buf_tag* %arraydecay) #9
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load %struct.handler*, %struct.handler** @handlerlist, align 8
  %val2 = getelementptr inbounds %struct.handler, %struct.handler* %2, i32 0, i32 2
  %3 = load i64, i64* %val2, align 8
  store i64 %3, i64* %val, align 8
  %4 = load %struct.handler*, %struct.handler** @handlerlist, align 8
  %next = getelementptr inbounds %struct.handler, %struct.handler* %4, i32 0, i32 3
  %5 = load %struct.handler*, %struct.handler** %next, align 8
  store %struct.handler* %5, %struct.handler** @handlerlist, align 8
  %6 = load i64 (i64)*, i64 (i64)** %hfun.addr, align 8
  %7 = load i64, i64* %val, align 8
  %call3 = call i64 %6(i64 %7)
  store i64 %call3, i64* %retval
  br label %return

if.else:                                          ; preds = %entry
  %8 = load i64 (i64)*, i64 (i64)** %bfun.addr, align 8
  %9 = load i64, i64* %arg.addr, align 8
  %call5 = call i64 %8(i64 %9)
  store i64 %call5, i64* %val4, align 8
  %10 = load %struct.handler*, %struct.handler** @handlerlist, align 8
  %next6 = getelementptr inbounds %struct.handler, %struct.handler* %10, i32 0, i32 3
  %11 = load %struct.handler*, %struct.handler** %next6, align 8
  store %struct.handler* %11, %struct.handler** @handlerlist, align 8
  %12 = load i64, i64* %val4, align 8
  store i64 %12, i64* %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %13 = load i64, i64* %retval
  ret i64 %13
}

; Function Attrs: nounwind uwtable
define i64 @internal_condition_case_2(i64 (i64, i64)* %bfun, i64 %arg1, i64 %arg2, i64 %handlers, i64 (i64)* %hfun) #0 {
entry:
  %retval = alloca i64, align 8
  %bfun.addr = alloca i64 (i64, i64)*, align 8
  %arg1.addr = alloca i64, align 8
  %arg2.addr = alloca i64, align 8
  %handlers.addr = alloca i64, align 8
  %hfun.addr = alloca i64 (i64)*, align 8
  %c = alloca %struct.handler*, align 8
  %val = alloca i64, align 8
  %val4 = alloca i64, align 8
  store i64 (i64, i64)* %bfun, i64 (i64, i64)** %bfun.addr, align 8
  store i64 %arg1, i64* %arg1.addr, align 8
  store i64 %arg2, i64* %arg2.addr, align 8
  store i64 %handlers, i64* %handlers.addr, align 8
  store i64 (i64)* %hfun, i64 (i64)** %hfun.addr, align 8
  %0 = load i64, i64* %handlers.addr, align 8
  %call = call %struct.handler* @push_handler(i64 %0, i32 1)
  store %struct.handler* %call, %struct.handler** %c, align 8
  %1 = load %struct.handler*, %struct.handler** %c, align 8
  %jmp = getelementptr inbounds %struct.handler, %struct.handler* %1, i32 0, i32 7
  %arraydecay = getelementptr inbounds [1 x %struct.__jmp_buf_tag], [1 x %struct.__jmp_buf_tag]* %jmp, i32 0, i32 0
  %call1 = call i32 @_setjmp(%struct.__jmp_buf_tag* %arraydecay) #9
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load %struct.handler*, %struct.handler** @handlerlist, align 8
  %val2 = getelementptr inbounds %struct.handler, %struct.handler* %2, i32 0, i32 2
  %3 = load i64, i64* %val2, align 8
  store i64 %3, i64* %val, align 8
  %4 = load %struct.handler*, %struct.handler** @handlerlist, align 8
  %next = getelementptr inbounds %struct.handler, %struct.handler* %4, i32 0, i32 3
  %5 = load %struct.handler*, %struct.handler** %next, align 8
  store %struct.handler* %5, %struct.handler** @handlerlist, align 8
  %6 = load i64 (i64)*, i64 (i64)** %hfun.addr, align 8
  %7 = load i64, i64* %val, align 8
  %call3 = call i64 %6(i64 %7)
  store i64 %call3, i64* %retval
  br label %return

if.else:                                          ; preds = %entry
  %8 = load i64 (i64, i64)*, i64 (i64, i64)** %bfun.addr, align 8
  %9 = load i64, i64* %arg1.addr, align 8
  %10 = load i64, i64* %arg2.addr, align 8
  %call5 = call i64 %8(i64 %9, i64 %10)
  store i64 %call5, i64* %val4, align 8
  %11 = load %struct.handler*, %struct.handler** @handlerlist, align 8
  %next6 = getelementptr inbounds %struct.handler, %struct.handler* %11, i32 0, i32 3
  %12 = load %struct.handler*, %struct.handler** %next6, align 8
  store %struct.handler* %12, %struct.handler** @handlerlist, align 8
  %13 = load i64, i64* %val4, align 8
  store i64 %13, i64* %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %14 = load i64, i64* %retval
  ret i64 %14
}

; Function Attrs: nounwind uwtable
define i64 @internal_condition_case_n(i64 (i64, i64*)* %bfun, i64 %nargs, i64* %args, i64 %handlers, i64 (i64, i64, i64*)* %hfun) #0 {
entry:
  %retval = alloca i64, align 8
  %bfun.addr = alloca i64 (i64, i64*)*, align 8
  %nargs.addr = alloca i64, align 8
  %args.addr = alloca i64*, align 8
  %handlers.addr = alloca i64, align 8
  %hfun.addr = alloca i64 (i64, i64, i64*)*, align 8
  %c = alloca %struct.handler*, align 8
  %val = alloca i64, align 8
  %val4 = alloca i64, align 8
  store i64 (i64, i64*)* %bfun, i64 (i64, i64*)** %bfun.addr, align 8
  store i64 %nargs, i64* %nargs.addr, align 8
  store i64* %args, i64** %args.addr, align 8
  store i64 %handlers, i64* %handlers.addr, align 8
  store i64 (i64, i64, i64*)* %hfun, i64 (i64, i64, i64*)** %hfun.addr, align 8
  %0 = load i64, i64* %handlers.addr, align 8
  %call = call %struct.handler* @push_handler(i64 %0, i32 1)
  store %struct.handler* %call, %struct.handler** %c, align 8
  %1 = load %struct.handler*, %struct.handler** %c, align 8
  %jmp = getelementptr inbounds %struct.handler, %struct.handler* %1, i32 0, i32 7
  %arraydecay = getelementptr inbounds [1 x %struct.__jmp_buf_tag], [1 x %struct.__jmp_buf_tag]* %jmp, i32 0, i32 0
  %call1 = call i32 @_setjmp(%struct.__jmp_buf_tag* %arraydecay) #9
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load %struct.handler*, %struct.handler** @handlerlist, align 8
  %val2 = getelementptr inbounds %struct.handler, %struct.handler* %2, i32 0, i32 2
  %3 = load i64, i64* %val2, align 8
  store i64 %3, i64* %val, align 8
  %4 = load %struct.handler*, %struct.handler** @handlerlist, align 8
  %next = getelementptr inbounds %struct.handler, %struct.handler* %4, i32 0, i32 3
  %5 = load %struct.handler*, %struct.handler** %next, align 8
  store %struct.handler* %5, %struct.handler** @handlerlist, align 8
  %6 = load i64 (i64, i64, i64*)*, i64 (i64, i64, i64*)** %hfun.addr, align 8
  %7 = load i64, i64* %val, align 8
  %8 = load i64, i64* %nargs.addr, align 8
  %9 = load i64*, i64** %args.addr, align 8
  %call3 = call i64 %6(i64 %7, i64 %8, i64* %9)
  store i64 %call3, i64* %retval
  br label %return

if.else:                                          ; preds = %entry
  %10 = load i64 (i64, i64*)*, i64 (i64, i64*)** %bfun.addr, align 8
  %11 = load i64, i64* %nargs.addr, align 8
  %12 = load i64*, i64** %args.addr, align 8
  %call5 = call i64 %10(i64 %11, i64* %12)
  store i64 %call5, i64* %val4, align 8
  %13 = load %struct.handler*, %struct.handler** @handlerlist, align 8
  %next6 = getelementptr inbounds %struct.handler, %struct.handler* %13, i32 0, i32 3
  %14 = load %struct.handler*, %struct.handler** %next6, align 8
  store %struct.handler* %14, %struct.handler** @handlerlist, align 8
  %15 = load i64, i64* %val4, align 8
  store i64 %15, i64* %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %16 = load i64, i64* %retval
  ret i64 %16
}

; Function Attrs: nounwind uwtable
define %struct.handler* @push_handler_nosignal(i64 %tag_ch_val, i32 %handlertype) #0 {
entry:
  %retval = alloca %struct.handler*, align 8
  %tag_ch_val.addr = alloca i64, align 8
  %handlertype.addr = alloca i32, align 4
  %c = alloca %struct.handler*, align 8
  store i64 %tag_ch_val, i64* %tag_ch_val.addr, align 8
  store i32 %handlertype, i32* %handlertype.addr, align 4
  %0 = load %struct.handler*, %struct.handler** @handlerlist, align 8
  %nextfree = getelementptr inbounds %struct.handler, %struct.handler* %0, i32 0, i32 4
  %1 = load %struct.handler*, %struct.handler** %nextfree, align 8
  store %struct.handler* %1, %struct.handler** %c, align 8
  %2 = load %struct.handler*, %struct.handler** %c, align 8
  %tobool = icmp ne %struct.handler* %2, null
  br i1 %tobool, label %if.end.8, label %if.then

if.then:                                          ; preds = %entry
  %call = call noalias i8* @malloc(i64 288) #6
  %3 = bitcast i8* %call to %struct.handler*
  store %struct.handler* %3, %struct.handler** %c, align 8
  %4 = load %struct.handler*, %struct.handler** %c, align 8
  %tobool1 = icmp ne %struct.handler* %4, null
  br i1 %tobool1, label %if.end, label %if.then.2

if.then.2:                                        ; preds = %if.then
  %5 = load %struct.handler*, %struct.handler** %c, align 8
  store %struct.handler* %5, %struct.handler** %retval
  br label %return

if.end:                                           ; preds = %if.then
  %6 = load i8, i8* @profiler_memory_running, align 1
  %tobool3 = trunc i8 %6 to i1
  br i1 %tobool3, label %if.then.4, label %if.end.5

if.then.4:                                        ; preds = %if.end
  call void @malloc_probe(i64 288)
  br label %if.end.5

if.end.5:                                         ; preds = %if.then.4, %if.end
  %7 = load %struct.handler*, %struct.handler** %c, align 8
  %nextfree6 = getelementptr inbounds %struct.handler, %struct.handler* %7, i32 0, i32 4
  store %struct.handler* null, %struct.handler** %nextfree6, align 8
  %8 = load %struct.handler*, %struct.handler** %c, align 8
  %9 = load %struct.handler*, %struct.handler** @handlerlist, align 8
  %nextfree7 = getelementptr inbounds %struct.handler, %struct.handler* %9, i32 0, i32 4
  store %struct.handler* %8, %struct.handler** %nextfree7, align 8
  br label %if.end.8

if.end.8:                                         ; preds = %if.end.5, %entry
  %10 = load i32, i32* %handlertype.addr, align 4
  %11 = load %struct.handler*, %struct.handler** %c, align 8
  %type = getelementptr inbounds %struct.handler, %struct.handler* %11, i32 0, i32 0
  store i32 %10, i32* %type, align 4
  %12 = load i64, i64* %tag_ch_val.addr, align 8
  %13 = load %struct.handler*, %struct.handler** %c, align 8
  %tag_or_ch = getelementptr inbounds %struct.handler, %struct.handler* %13, i32 0, i32 1
  store i64 %12, i64* %tag_or_ch, align 8
  %call9 = call i64 @builtin_lisp_symbol(i32 0)
  %14 = load %struct.handler*, %struct.handler** %c, align 8
  %val = getelementptr inbounds %struct.handler, %struct.handler* %14, i32 0, i32 2
  store i64 %call9, i64* %val, align 8
  %15 = load %struct.handler*, %struct.handler** @handlerlist, align 8
  %16 = load %struct.handler*, %struct.handler** %c, align 8
  %next = getelementptr inbounds %struct.handler, %struct.handler* %16, i32 0, i32 3
  store %struct.handler* %15, %struct.handler** %next, align 8
  %17 = load i64, i64* @lisp_eval_depth, align 8
  %18 = load %struct.handler*, %struct.handler** %c, align 8
  %lisp_eval_depth = getelementptr inbounds %struct.handler, %struct.handler* %18, i32 0, i32 8
  store i64 %17, i64* %lisp_eval_depth, align 8
  %call10 = call i64 @SPECPDL_INDEX()
  %19 = load %struct.handler*, %struct.handler** %c, align 8
  %pdlcount = getelementptr inbounds %struct.handler, %struct.handler* %19, i32 0, i32 9
  store i64 %call10, i64* %pdlcount, align 8
  %20 = load i32, i32* @poll_suppress_count, align 4
  %21 = load %struct.handler*, %struct.handler** %c, align 8
  %poll_suppress_count = getelementptr inbounds %struct.handler, %struct.handler* %21, i32 0, i32 10
  store i32 %20, i32* %poll_suppress_count, align 4
  %22 = load volatile i32, i32* @interrupt_input_blocked, align 4
  %23 = load %struct.handler*, %struct.handler** %c, align 8
  %interrupt_input_blocked = getelementptr inbounds %struct.handler, %struct.handler* %23, i32 0, i32 11
  store i32 %22, i32* %interrupt_input_blocked, align 4
  %24 = load %struct.byte_stack*, %struct.byte_stack** @byte_stack_list, align 8
  %25 = load %struct.handler*, %struct.handler** %c, align 8
  %byte_stack = getelementptr inbounds %struct.handler, %struct.handler* %25, i32 0, i32 12
  store %struct.byte_stack* %24, %struct.byte_stack** %byte_stack, align 8
  %26 = load %struct.handler*, %struct.handler** %c, align 8
  store %struct.handler* %26, %struct.handler** @handlerlist, align 8
  %27 = load %struct.handler*, %struct.handler** %c, align 8
  store %struct.handler* %27, %struct.handler** %retval
  br label %return

return:                                           ; preds = %if.end.8, %if.then.2
  %28 = load %struct.handler*, %struct.handler** %retval
  ret %struct.handler* %28
}

; Function Attrs: nounwind
declare noalias i8* @malloc(i64) #5

declare void @malloc_probe(i64) #1

; Function Attrs: noreturn
declare i64 @Fkill_emacs(i64) #2

; Function Attrs: nounwind uwtable
define i64 @Fsignal(i64 %error_symbol, i64 %data) #0 {
entry:
  %error_symbol.addr = alloca i64, align 8
  %data.addr = alloca i64, align 8
  %conditions = alloca i64, align 8
  %string = alloca i64, align 8
  %real_error_symbol = alloca i64, align 8
  %clause = alloca i64, align 8
  %h = alloca %struct.handler*, align 8
  %pdl = alloca %union.specbinding*, align 8
  %debugger_called = alloca i8, align 1
  %unwind_data = alloca i64, align 8
  store i64 %error_symbol, i64* %error_symbol.addr, align 8
  store i64 %data, i64* %data.addr, align 8
  %0 = load i64, i64* %error_symbol.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %0, %call
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load i64, i64* %data.addr, align 8
  %call1 = call i64 @Fcar(i64 %1)
  br label %cond.end

cond.false:                                       ; preds = %entry
  %2 = load i64, i64* %error_symbol.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call1, %cond.true ], [ %2, %cond.false ]
  store i64 %cond, i64* %real_error_symbol, align 8
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call2, i64* %clause, align 8
  store i8 0, i8* @immediate_quit, align 1
  store i8 0, i8* @abort_on_gc, align 1
  %3 = load i8, i8* @gc_in_progress, align 1
  %tobool = trunc i8 %3 to i1
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end
  %4 = load i8, i8* @waiting_for_input, align 1
  %tobool3 = trunc i8 %4 to i1
  br i1 %tobool3, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %cond.end
  call void @emacs_abort() #8
  unreachable

if.end:                                           ; preds = %lor.lhs.false
  %5 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 272), align 8
  %call4 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp5 = icmp eq i64 %5, %call4
  br i1 %cmp5, label %if.end.21, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %6 = load i64, i64* %error_symbol.addr, align 8
  %call6 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp7 = icmp eq i64 %6, %call6
  br i1 %cmp7, label %if.end.21, label %if.then.8

if.then.8:                                        ; preds = %land.lhs.true
  %7 = load i64, i64* @lisp_eval_depth, align 8
  %add = add nsw i64 %7, 20
  %8 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 396), align 8
  %cmp9 = icmp sgt i64 %add, %8
  br i1 %cmp9, label %if.then.10, label %if.end.12

if.then.10:                                       ; preds = %if.then.8
  %9 = load i64, i64* @lisp_eval_depth, align 8
  %add11 = add nsw i64 %9, 20
  store i64 %add11, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 396), align 8
  br label %if.end.12

if.end.12:                                        ; preds = %if.then.10, %if.then.8
  %call13 = call i64 @SPECPDL_INDEX()
  %add14 = add nsw i64 %call13, 40
  %10 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 397), align 8
  %cmp15 = icmp sgt i64 %add14, %10
  br i1 %cmp15, label %if.then.16, label %if.end.19

if.then.16:                                       ; preds = %if.end.12
  %call17 = call i64 @SPECPDL_INDEX()
  %add18 = add nsw i64 %call17, 40
  store i64 %add18, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 397), align 8
  br label %if.end.19

if.end.19:                                        ; preds = %if.then.16, %if.end.12
  %11 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 272), align 8
  %12 = load i64, i64* %error_symbol.addr, align 8
  %13 = load i64, i64* %data.addr, align 8
  %call20 = call i64 @call2(i64 %11, i64 %12, i64 %13)
  br label %if.end.21

if.end.21:                                        ; preds = %if.end.19, %land.lhs.true, %if.end
  %14 = load i64, i64* %real_error_symbol, align 8
  %call22 = call i64 @builtin_lisp_symbol(i32 373)
  %call23 = call i64 @Fget(i64 %14, i64 %call22)
  store i64 %call23, i64* %conditions, align 8
  %call24 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call24, i64* @Vsignaling_function, align 8
  %15 = load i64, i64* %error_symbol.addr, align 8
  %call25 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp26 = icmp eq i64 %15, %call25
  br i1 %cmp26, label %if.end.42, label %if.then.27

if.then.27:                                       ; preds = %if.end.21
  %call28 = call %union.specbinding* @backtrace_top()
  %call29 = call %union.specbinding* @backtrace_next(%union.specbinding* %call28)
  store %union.specbinding* %call29, %union.specbinding** %pdl, align 8
  %16 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %call30 = call zeroext i1 @backtrace_p(%union.specbinding* %16)
  br i1 %call30, label %land.lhs.true.31, label %if.end.37

land.lhs.true.31:                                 ; preds = %if.then.27
  %17 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %call32 = call i64 @backtrace_function(%union.specbinding* %17)
  %call33 = call i64 @builtin_lisp_symbol(i32 372)
  %cmp34 = icmp eq i64 %call32, %call33
  br i1 %cmp34, label %if.then.35, label %if.end.37

if.then.35:                                       ; preds = %land.lhs.true.31
  %18 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %call36 = call %union.specbinding* @backtrace_next(%union.specbinding* %18)
  store %union.specbinding* %call36, %union.specbinding** %pdl, align 8
  br label %if.end.37

if.end.37:                                        ; preds = %if.then.35, %land.lhs.true.31, %if.then.27
  %19 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %call38 = call zeroext i1 @backtrace_p(%union.specbinding* %19)
  br i1 %call38, label %if.then.39, label %if.end.41

if.then.39:                                       ; preds = %if.end.37
  %20 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %call40 = call i64 @backtrace_function(%union.specbinding* %20)
  store i64 %call40, i64* @Vsignaling_function, align 8
  br label %if.end.41

if.end.41:                                        ; preds = %if.then.39, %if.end.37
  br label %if.end.42

if.end.42:                                        ; preds = %if.end.41, %if.end.21
  %21 = load %struct.handler*, %struct.handler** @handlerlist, align 8
  store %struct.handler* %21, %struct.handler** %h, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end.42
  %22 = load %struct.handler*, %struct.handler** %h, align 8
  %tobool43 = icmp ne %struct.handler* %22, null
  br i1 %tobool43, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %23 = load %struct.handler*, %struct.handler** %h, align 8
  %type = getelementptr inbounds %struct.handler, %struct.handler* %23, i32 0, i32 0
  %24 = load i32, i32* %type, align 4
  %cmp44 = icmp ne i32 %24, 1
  br i1 %cmp44, label %if.then.45, label %if.end.46

if.then.45:                                       ; preds = %for.body
  br label %for.inc

if.end.46:                                        ; preds = %for.body
  %25 = load %struct.handler*, %struct.handler** %h, align 8
  %tag_or_ch = getelementptr inbounds %struct.handler, %struct.handler* %25, i32 0, i32 1
  %26 = load i64, i64* %tag_or_ch, align 8
  %27 = load i64, i64* %conditions, align 8
  %call47 = call i64 @find_handler_clause(i64 %26, i64 %27)
  store i64 %call47, i64* %clause, align 8
  %28 = load i64, i64* %clause, align 8
  %call48 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp49 = icmp eq i64 %28, %call48
  br i1 %cmp49, label %if.end.51, label %if.then.50

if.then.50:                                       ; preds = %if.end.46
  br label %for.end

if.end.51:                                        ; preds = %if.end.46
  br label %for.inc

for.inc:                                          ; preds = %if.end.51, %if.then.45
  %29 = load %struct.handler*, %struct.handler** %h, align 8
  %next = getelementptr inbounds %struct.handler, %struct.handler* %29, i32 0, i32 3
  %30 = load %struct.handler*, %struct.handler** %next, align 8
  store %struct.handler* %30, %struct.handler** %h, align 8
  br label %for.cond

for.end:                                          ; preds = %if.then.50, %for.cond
  %31 = load i64, i64* %error_symbol.addr, align 8
  %call52 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp53 = icmp eq i64 %31, %call52
  br i1 %cmp53, label %if.end.85, label %land.lhs.true.54

land.lhs.true.54:                                 ; preds = %for.end
  %32 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 57), align 8
  %call55 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp56 = icmp eq i64 %32, %call55
  br i1 %cmp56, label %lor.lhs.false.57, label %if.then.74

lor.lhs.false.57:                                 ; preds = %land.lhs.true.54
  %33 = load i64, i64* %clause, align 8
  %call58 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp59 = icmp eq i64 %33, %call58
  br i1 %cmp59, label %if.then.74, label %lor.lhs.false.60

lor.lhs.false.60:                                 ; preds = %lor.lhs.false.57
  %34 = load i64, i64* %clause, align 8
  %and = and i64 %34, 7
  %conv = trunc i64 %and to i32
  %cmp61 = icmp eq i32 %conv, 3
  br i1 %cmp61, label %land.lhs.true.63, label %lor.lhs.false.69

land.lhs.true.63:                                 ; preds = %lor.lhs.false.60
  %call64 = call i64 @builtin_lisp_symbol(i32 320)
  %35 = load i64, i64* %clause, align 8
  %call65 = call i64 @Fmemq(i64 %call64, i64 %35)
  %call66 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp67 = icmp eq i64 %call65, %call66
  br i1 %cmp67, label %lor.lhs.false.69, label %if.then.74

lor.lhs.false.69:                                 ; preds = %land.lhs.true.63, %lor.lhs.false.60
  %36 = load %struct.handler*, %struct.handler** %h, align 8
  %tag_or_ch70 = getelementptr inbounds %struct.handler, %struct.handler* %36, i32 0, i32 1
  %37 = load i64, i64* %tag_or_ch70, align 8
  %call71 = call i64 @builtin_lisp_symbol(i32 372)
  %cmp72 = icmp eq i64 %37, %call71
  br i1 %cmp72, label %if.then.74, label %if.end.85

if.then.74:                                       ; preds = %lor.lhs.false.69, %land.lhs.true.63, %lor.lhs.false.57, %land.lhs.true.54
  %38 = load i64, i64* %conditions, align 8
  %39 = load i64, i64* %error_symbol.addr, align 8
  %40 = load i64, i64* %data.addr, align 8
  %call75 = call zeroext i1 @maybe_call_debugger(i64 %38, i64 %39, i64 %40)
  %frombool = zext i1 %call75 to i8
  store i8 %frombool, i8* %debugger_called, align 1
  %41 = load i8, i8* %debugger_called, align 1
  %tobool76 = trunc i8 %41 to i1
  br i1 %tobool76, label %land.lhs.true.78, label %if.end.84

land.lhs.true.78:                                 ; preds = %if.then.74
  %42 = load i64, i64* %real_error_symbol, align 8
  %call79 = call i64 @builtin_lisp_symbol(i32 782)
  %cmp80 = icmp eq i64 %42, %call79
  br i1 %cmp80, label %if.then.82, label %if.end.84

if.then.82:                                       ; preds = %land.lhs.true.78
  %call83 = call i64 @builtin_lisp_symbol(i32 0)
  ret i64 %call83

if.end.84:                                        ; preds = %land.lhs.true.78, %if.then.74
  br label %if.end.85

if.end.85:                                        ; preds = %if.end.84, %lor.lhs.false.69, %for.end
  %43 = load i64, i64* %clause, align 8
  %call86 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp87 = icmp eq i64 %43, %call86
  br i1 %cmp87, label %if.else, label %if.then.89

if.then.89:                                       ; preds = %if.end.85
  %44 = load i64, i64* %error_symbol.addr, align 8
  %call90 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp91 = icmp eq i64 %44, %call90
  br i1 %cmp91, label %cond.true.93, label %cond.false.94

cond.true.93:                                     ; preds = %if.then.89
  %45 = load i64, i64* %data.addr, align 8
  br label %cond.end.96

cond.false.94:                                    ; preds = %if.then.89
  %46 = load i64, i64* %error_symbol.addr, align 8
  %47 = load i64, i64* %data.addr, align 8
  %call95 = call i64 @Fcons(i64 %46, i64 %47)
  br label %cond.end.96

cond.end.96:                                      ; preds = %cond.false.94, %cond.true.93
  %cond97 = phi i64 [ %45, %cond.true.93 ], [ %call95, %cond.false.94 ]
  store i64 %cond97, i64* %unwind_data, align 8
  %48 = load %struct.handler*, %struct.handler** %h, align 8
  %49 = load i64, i64* %unwind_data, align 8
  call void @unwind_to_catch(%struct.handler* %48, i64 %49) #8
  unreachable

if.else:                                          ; preds = %if.end.85
  %50 = load %struct.handler*, %struct.handler** @handlerlist, align 8
  %cmp98 = icmp ne %struct.handler* %50, @handlerlist_sentinel
  br i1 %cmp98, label %if.then.100, label %if.end.103

if.then.100:                                      ; preds = %if.else
  %call101 = call i64 @builtin_lisp_symbol(i32 930)
  %call102 = call i64 @builtin_lisp_symbol(i32 901)
  %51 = call i64 @Fthrow(i64 %call101, i64 %call102) #8
  unreachable

if.end.103:                                       ; preds = %if.else
  br label %if.end.104

if.end.104:                                       ; preds = %if.end.103
  %52 = load i64, i64* %error_symbol.addr, align 8
  %call105 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp106 = icmp eq i64 %52, %call105
  br i1 %cmp106, label %if.end.110, label %if.then.108

if.then.108:                                      ; preds = %if.end.104
  %53 = load i64, i64* %error_symbol.addr, align 8
  %54 = load i64, i64* %data.addr, align 8
  %call109 = call i64 @Fcons(i64 %53, i64 %54)
  store i64 %call109, i64* %data.addr, align 8
  br label %if.end.110

if.end.110:                                       ; preds = %if.then.108, %if.end.104
  %55 = load i64, i64* %data.addr, align 8
  %call111 = call i64 @Ferror_message_string(i64 %55)
  store i64 %call111, i64* %string, align 8
  %56 = load i64, i64* %string, align 8
  %call112 = call i8* @SDATA(i64 %56)
  call void (i8*, ...) @fatal(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.8, i32 0, i32 0), i8* %call112) #8
  unreachable
}

; Function Attrs: nounwind uwtable
define i64 @call2(i64 %fn, i64 %arg1, i64 %arg2) #0 {
entry:
  %fn.addr = alloca i64, align 8
  %arg1.addr = alloca i64, align 8
  %arg2.addr = alloca i64, align 8
  %.compoundliteral = alloca [3 x i64], align 8
  store i64 %fn, i64* %fn.addr, align 8
  store i64 %arg1, i64* %arg1.addr, align 8
  store i64 %arg2, i64* %arg2.addr, align 8
  %arrayinit.begin = getelementptr inbounds [3 x i64], [3 x i64]* %.compoundliteral, i64 0, i64 0
  %0 = load i64, i64* %fn.addr, align 8
  store i64 %0, i64* %arrayinit.begin
  %arrayinit.element = getelementptr inbounds i64, i64* %arrayinit.begin, i64 1
  %1 = load i64, i64* %arg1.addr, align 8
  store i64 %1, i64* %arrayinit.element
  %arrayinit.element1 = getelementptr inbounds i64, i64* %arrayinit.element, i64 1
  %2 = load i64, i64* %arg2.addr, align 8
  store i64 %2, i64* %arrayinit.element1
  %arraydecay = getelementptr inbounds [3 x i64], [3 x i64]* %.compoundliteral, i32 0, i32 0
  %call = call i64 @Ffuncall(i64 3, i64* %arraydecay)
  ret i64 %call
}

declare i64 @Fget(i64, i64) #1

; Function Attrs: nounwind uwtable
define internal i64 @find_handler_clause(i64 %handlers, i64 %conditions) #0 {
entry:
  %retval = alloca i64, align 8
  %handlers.addr = alloca i64, align 8
  %conditions.addr = alloca i64, align 8
  %h = alloca i64, align 8
  %handler = alloca i64, align 8
  store i64 %handlers, i64* %handlers.addr, align 8
  store i64 %conditions, i64* %conditions.addr, align 8
  %0 = load i64, i64* %handlers.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 901)
  %cmp = icmp eq i64 %0, %call
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i64 @builtin_lisp_symbol(i32 901)
  store i64 %call1, i64* %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64, i64* %handlers.addr, align 8
  %call2 = call i64 @builtin_lisp_symbol(i32 372)
  %cmp3 = icmp eq i64 %1, %call2
  br i1 %cmp3, label %if.then.4, label %if.end.6

if.then.4:                                        ; preds = %if.end
  %call5 = call i64 @builtin_lisp_symbol(i32 901)
  store i64 %call5, i64* %retval
  br label %return

if.end.6:                                         ; preds = %if.end
  %2 = load i64, i64* %handlers.addr, align 8
  store i64 %2, i64* %h, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end.6
  %3 = load i64, i64* %h, align 8
  %and = and i64 %3, 7
  %conv = trunc i64 %and to i32
  %cmp7 = icmp eq i32 %conv, 3
  br i1 %cmp7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load i64, i64* %h, align 8
  %sub = sub nsw i64 %4, 3
  %5 = inttoptr i64 %sub to i8*
  %6 = bitcast i8* %5 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %6, i32 0, i32 0
  %7 = load i64, i64* %car, align 8
  store i64 %7, i64* %handler, align 8
  %8 = load i64, i64* %handler, align 8
  %9 = load i64, i64* %conditions.addr, align 8
  %call9 = call i64 @Fmemq(i64 %8, i64 %9)
  %call10 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp11 = icmp eq i64 %call9, %call10
  br i1 %cmp11, label %if.end.14, label %if.then.13

if.then.13:                                       ; preds = %for.body
  %10 = load i64, i64* %handlers.addr, align 8
  store i64 %10, i64* %retval
  br label %return

if.end.14:                                        ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end.14
  %11 = load i64, i64* %h, align 8
  %sub15 = sub nsw i64 %11, 3
  %12 = inttoptr i64 %sub15 to i8*
  %13 = bitcast i8* %12 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %13, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %14 = load i64, i64* %cdr, align 8
  store i64 %14, i64* %h, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call16 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call16, i64* %retval
  br label %return

return:                                           ; preds = %for.end, %if.then.13, %if.then.4, %if.then
  %15 = load i64, i64* %retval
  ret i64 %15
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @maybe_call_debugger(i64 %conditions, i64 %sig, i64 %data) #0 {
entry:
  %retval = alloca i1, align 1
  %conditions.addr = alloca i64, align 8
  %sig.addr = alloca i64, align 8
  %data.addr = alloca i64, align 8
  %combined_data = alloca i64, align 8
  store i64 %conditions, i64* %conditions.addr, align 8
  store i64 %sig, i64* %sig.addr, align 8
  store i64 %data, i64* %data.addr, align 8
  %0 = load i64, i64* %sig.addr, align 8
  %1 = load i64, i64* %data.addr, align 8
  %call = call i64 @Fcons(i64 %0, i64 %1)
  store i64 %call, i64* %combined_data, align 8
  %call1 = call zeroext i1 @input_blocked_p()
  br i1 %call1, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %2 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 133), align 8
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %2, %call2
  br i1 %cmp, label %land.lhs.true.3, label %if.end

land.lhs.true.3:                                  ; preds = %land.lhs.true
  %3 = load i64, i64* %sig.addr, align 8
  %call4 = call i64 @builtin_lisp_symbol(i32 782)
  %cmp5 = icmp eq i64 %3, %call4
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true.3
  %4 = load i8, i8* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 433), align 1
  %tobool = trunc i8 %4 to i1
  br i1 %tobool, label %land.lhs.true.7, label %if.end

cond.false:                                       ; preds = %land.lhs.true.3
  %5 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 54), align 8
  %6 = load i64, i64* %conditions.addr, align 8
  %call6 = call zeroext i1 @wants_debugger(i64 %5, i64 %6)
  br i1 %call6, label %land.lhs.true.7, label %if.end

land.lhs.true.7:                                  ; preds = %cond.false, %cond.true
  %7 = load i64, i64* %conditions.addr, align 8
  %8 = load i64, i64* %combined_data, align 8
  %call8 = call zeroext i1 @skip_debugger(i64 %7, i64 %8)
  br i1 %call8, label %if.end, label %land.lhs.true.9

land.lhs.true.9:                                  ; preds = %land.lhs.true.7
  %9 = load i64, i64* @when_entered_debugger, align 8
  %10 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 401), align 8
  %cmp10 = icmp slt i64 %9, %10
  br i1 %cmp10, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true.9
  %call11 = call i64 @builtin_lisp_symbol(i32 372)
  %11 = load i64, i64* %combined_data, align 8
  %call12 = call i64 @list2(i64 %call11, i64 %11)
  %call13 = call i64 @call_debugger(i64 %call12)
  store i1 true, i1* %retval
  br label %return

if.end:                                           ; preds = %land.lhs.true.9, %land.lhs.true.7, %cond.false, %cond.true, %land.lhs.true, %entry
  store i1 false, i1* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %12 = load i1, i1* %retval
  ret i1 %12
}

declare i64 @Ferror_message_string(i64) #1

; Function Attrs: noreturn
declare void @fatal(i8*, ...) #2

; Function Attrs: noreturn nounwind uwtable
define void @xsignal(i64 %error_symbol, i64 %data) #3 {
entry:
  %error_symbol.addr = alloca i64, align 8
  %data.addr = alloca i64, align 8
  store i64 %error_symbol, i64* %error_symbol.addr, align 8
  store i64 %data, i64* %data.addr, align 8
  %0 = load i64, i64* %error_symbol.addr, align 8
  %1 = load i64, i64* %data.addr, align 8
  %call = call i64 @Fsignal(i64 %0, i64 %1)
  call void @emacs_abort() #8
  unreachable

return:                                           ; No predecessors!
  ret void
}

; Function Attrs: noreturn nounwind uwtable
define void @xsignal0(i64 %error_symbol) #3 {
entry:
  %error_symbol.addr = alloca i64, align 8
  store i64 %error_symbol, i64* %error_symbol.addr, align 8
  %0 = load i64, i64* %error_symbol.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  call void @xsignal(i64 %0, i64 %call) #8
  unreachable

return:                                           ; No predecessors!
  ret void
}

declare i64 @list1(i64) #1

declare i64 @list2(i64, i64) #1

; Function Attrs: noreturn nounwind uwtable
define void @xsignal3(i64 %error_symbol, i64 %arg1, i64 %arg2, i64 %arg3) #3 {
entry:
  %error_symbol.addr = alloca i64, align 8
  %arg1.addr = alloca i64, align 8
  %arg2.addr = alloca i64, align 8
  %arg3.addr = alloca i64, align 8
  store i64 %error_symbol, i64* %error_symbol.addr, align 8
  store i64 %arg1, i64* %arg1.addr, align 8
  store i64 %arg2, i64* %arg2.addr, align 8
  store i64 %arg3, i64* %arg3.addr, align 8
  %0 = load i64, i64* %error_symbol.addr, align 8
  %1 = load i64, i64* %arg1.addr, align 8
  %2 = load i64, i64* %arg2.addr, align 8
  %3 = load i64, i64* %arg3.addr, align 8
  %call = call i64 @list3(i64 %1, i64 %2, i64 %3)
  call void @xsignal(i64 %0, i64 %call) #8
  unreachable

return:                                           ; No predecessors!
  ret void
}

declare i64 @list3(i64, i64, i64) #1

declare i64 @build_string(i8*) #1

; Function Attrs: noreturn nounwind uwtable
define void @verror(i8* %m, %struct.__va_list_tag* %ap) #3 {
entry:
  %m.addr = alloca i8*, align 8
  %ap.addr = alloca %struct.__va_list_tag*, align 8
  %buf = alloca [4000 x i8], align 16
  %size = alloca i64, align 8
  %size_max = alloca i64, align 8
  %buffer = alloca i8*, align 8
  %used = alloca i64, align 8
  %string = alloca i64, align 8
  store i8* %m, i8** %m.addr, align 8
  store %struct.__va_list_tag* %ap, %struct.__va_list_tag** %ap.addr, align 8
  store i64 4000, i64* %size, align 8
  store i64 2305843009213693952, i64* %size_max, align 8
  %arraydecay = getelementptr inbounds [4000 x i8], [4000 x i8]* %buf, i32 0, i32 0
  store i8* %arraydecay, i8** %buffer, align 8
  %arraydecay1 = getelementptr inbounds [4000 x i8], [4000 x i8]* %buf, i32 0, i32 0
  %0 = load i64, i64* %size_max, align 8
  %1 = load i8*, i8** %m.addr, align 8
  %2 = load %struct.__va_list_tag*, %struct.__va_list_tag** %ap.addr, align 8
  %call = call i64 @evxprintf(i8** %buffer, i64* %size, i8* %arraydecay1, i64 %0, i8* %1, %struct.__va_list_tag* %2)
  store i64 %call, i64* %used, align 8
  %3 = load i8*, i8** %buffer, align 8
  %4 = load i64, i64* %used, align 8
  %call2 = call i64 @make_string(i8* %3, i64 %4)
  store i64 %call2, i64* %string, align 8
  %5 = load i8*, i8** %buffer, align 8
  %arraydecay3 = getelementptr inbounds [4000 x i8], [4000 x i8]* %buf, i32 0, i32 0
  %cmp = icmp ne i8* %5, %arraydecay3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load i8*, i8** %buffer, align 8
  call void @xfree(i8* %6)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %call4 = call i64 @builtin_lisp_symbol(i32 372)
  %7 = load i64, i64* %string, align 8
  call void @xsignal1(i64 %call4, i64 %7) #8
  unreachable

return:                                           ; No predecessors!
  ret void
}

declare i64 @evxprintf(i8**, i64*, i8*, i64, i8*, %struct.__va_list_tag*) #1

declare i64 @make_string(i8*, i64) #1

declare void @xfree(i8*) #1

; Function Attrs: nounwind
declare void @llvm.va_start(i8*) #6

; Function Attrs: nounwind uwtable
define i64 @Fcommandp(i64 %function, i64 %for_call_interactively) #0 {
entry:
  %retval = alloca i64, align 8
  %function.addr = alloca i64, align 8
  %for_call_interactively.addr = alloca i64, align 8
  %fun = alloca i64, align 8
  %funcar = alloca i64, align 8
  %if_prop = alloca i64, align 8
  %tmp = alloca i64, align 8
  store i64 %function, i64* %function.addr, align 8
  store i64 %for_call_interactively, i64* %for_call_interactively.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call, i64* %if_prop, align 8
  %0 = load i64, i64* %function.addr, align 8
  store i64 %0, i64* %fun, align 8
  %1 = load i64, i64* %fun, align 8
  %call1 = call i64 @indirect_function(i64 %1)
  store i64 %call1, i64* %fun, align 8
  %2 = load i64, i64* %fun, align 8
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %2, %call2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call3, i64* %retval
  br label %return

if.end:                                           ; preds = %entry
  %3 = load i64, i64* %function.addr, align 8
  store i64 %3, i64* %fun, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end.13, %if.end
  %4 = load i64, i64* %fun, align 8
  %and = and i64 %4, 7
  %conv = trunc i64 %and to i32
  %cmp4 = icmp eq i32 %conv, 0
  br i1 %cmp4, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %5 = load i64, i64* %fun, align 8
  %call6 = call i64 @builtin_lisp_symbol(i32 561)
  %call7 = call i64 @Fget(i64 %5, i64 %call6)
  store i64 %call7, i64* %tmp, align 8
  %6 = load i64, i64* %tmp, align 8
  %call8 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp9 = icmp eq i64 %6, %call8
  br i1 %cmp9, label %if.end.13, label %if.then.11

if.then.11:                                       ; preds = %while.body
  %call12 = call i64 @builtin_lisp_symbol(i32 901)
  store i64 %call12, i64* %if_prop, align 8
  br label %if.end.13

if.end.13:                                        ; preds = %if.then.11, %while.body
  %7 = load i64, i64* %fun, align 8
  %call14 = call i64 @Fsymbol_function(i64 %7)
  store i64 %call14, i64* %fun, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %8 = load i64, i64* %fun, align 8
  %call15 = call zeroext i1 @SUBRP(i64 %8)
  br i1 %call15, label %if.then.16, label %if.else

if.then.16:                                       ; preds = %while.end
  %9 = load i64, i64* %fun, align 8
  %call17 = call %struct.Lisp_Subr* @XSUBR(i64 %9)
  %intspec = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call17, i32 0, i32 5
  %10 = load i8*, i8** %intspec, align 8
  %tobool = icmp ne i8* %10, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.16
  %call18 = call i64 @builtin_lisp_symbol(i32 901)
  br label %cond.end

cond.false:                                       ; preds = %if.then.16
  %11 = load i64, i64* %if_prop, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call18, %cond.true ], [ %11, %cond.false ]
  store i64 %cond, i64* %retval
  br label %return

if.else:                                          ; preds = %while.end
  %12 = load i64, i64* %fun, align 8
  %call19 = call zeroext i1 @COMPILEDP(i64 %12)
  br i1 %call19, label %if.then.20, label %if.end.30

if.then.20:                                       ; preds = %if.else
  %13 = load i64, i64* %fun, align 8
  %call21 = call i64 @ASIZE(i64 %13)
  %and22 = and i64 %call21, 4095
  %cmp23 = icmp sgt i64 %and22, 5
  br i1 %cmp23, label %cond.true.25, label %cond.false.27

cond.true.25:                                     ; preds = %if.then.20
  %call26 = call i64 @builtin_lisp_symbol(i32 901)
  br label %cond.end.28

cond.false.27:                                    ; preds = %if.then.20
  %14 = load i64, i64* %if_prop, align 8
  br label %cond.end.28

cond.end.28:                                      ; preds = %cond.false.27, %cond.true.25
  %cond29 = phi i64 [ %call26, %cond.true.25 ], [ %14, %cond.false.27 ]
  store i64 %cond29, i64* %retval
  br label %return

if.end.30:                                        ; preds = %if.else
  br label %if.end.31

if.end.31:                                        ; preds = %if.end.30
  %15 = load i64, i64* %fun, align 8
  %call32 = call zeroext i1 @STRINGP(i64 %15)
  br i1 %call32, label %if.then.36, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end.31
  %16 = load i64, i64* %fun, align 8
  %call34 = call zeroext i1 @VECTORP(i64 %16)
  br i1 %call34, label %if.then.36, label %if.end.46

if.then.36:                                       ; preds = %lor.lhs.false, %if.end.31
  %17 = load i64, i64* %for_call_interactively.addr, align 8
  %call37 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp38 = icmp eq i64 %17, %call37
  br i1 %cmp38, label %cond.true.40, label %cond.false.42

cond.true.40:                                     ; preds = %if.then.36
  %call41 = call i64 @builtin_lisp_symbol(i32 901)
  br label %cond.end.44

cond.false.42:                                    ; preds = %if.then.36
  %call43 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end.44

cond.end.44:                                      ; preds = %cond.false.42, %cond.true.40
  %cond45 = phi i64 [ %call41, %cond.true.40 ], [ %call43, %cond.false.42 ]
  store i64 %cond45, i64* %retval
  br label %return

if.end.46:                                        ; preds = %lor.lhs.false
  %18 = load i64, i64* %fun, align 8
  %and47 = and i64 %18, 7
  %conv48 = trunc i64 %and47 to i32
  %cmp49 = icmp eq i32 %conv48, 3
  br i1 %cmp49, label %if.end.53, label %if.then.51

if.then.51:                                       ; preds = %if.end.46
  %call52 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call52, i64* %retval
  br label %return

if.end.53:                                        ; preds = %if.end.46
  %19 = load i64, i64* %fun, align 8
  %sub = sub nsw i64 %19, 3
  %20 = inttoptr i64 %sub to i8*
  %21 = bitcast i8* %20 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %21, i32 0, i32 0
  %22 = load i64, i64* %car, align 8
  store i64 %22, i64* %funcar, align 8
  %23 = load i64, i64* %funcar, align 8
  %call54 = call i64 @builtin_lisp_symbol(i32 271)
  %cmp55 = icmp eq i64 %23, %call54
  br i1 %cmp55, label %if.then.57, label %if.else.71

if.then.57:                                       ; preds = %if.end.53
  %call58 = call i64 @builtin_lisp_symbol(i32 560)
  %24 = load i64, i64* %fun, align 8
  %sub59 = sub nsw i64 %24, 3
  %25 = inttoptr i64 %sub59 to i8*
  %26 = bitcast i8* %25 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %26, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %27 = load i64, i64* %cdr, align 8
  %call60 = call i64 @Fcdr(i64 %27)
  %call61 = call i64 @Fcdr(i64 %call60)
  %call62 = call i64 @Fassq(i64 %call58, i64 %call61)
  %call63 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp64 = icmp eq i64 %call62, %call63
  br i1 %cmp64, label %cond.false.68, label %cond.true.66

cond.true.66:                                     ; preds = %if.then.57
  %call67 = call i64 @builtin_lisp_symbol(i32 901)
  br label %cond.end.69

cond.false.68:                                    ; preds = %if.then.57
  %28 = load i64, i64* %if_prop, align 8
  br label %cond.end.69

cond.end.69:                                      ; preds = %cond.false.68, %cond.true.66
  %cond70 = phi i64 [ %call67, %cond.true.66 ], [ %28, %cond.false.68 ]
  store i64 %cond70, i64* %retval
  br label %return

if.else.71:                                       ; preds = %if.end.53
  %29 = load i64, i64* %funcar, align 8
  %call72 = call i64 @builtin_lisp_symbol(i32 598)
  %cmp73 = icmp eq i64 %29, %call72
  br i1 %cmp73, label %if.then.75, label %if.else.90

if.then.75:                                       ; preds = %if.else.71
  %call76 = call i64 @builtin_lisp_symbol(i32 560)
  %30 = load i64, i64* %fun, align 8
  %sub77 = sub nsw i64 %30, 3
  %31 = inttoptr i64 %sub77 to i8*
  %32 = bitcast i8* %31 to %struct.Lisp_Cons*
  %u78 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %32, i32 0, i32 1
  %cdr79 = bitcast %union.anon* %u78 to i64*
  %33 = load i64, i64* %cdr79, align 8
  %call80 = call i64 @Fcdr(i64 %33)
  %call81 = call i64 @Fassq(i64 %call76, i64 %call80)
  %call82 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp83 = icmp eq i64 %call81, %call82
  br i1 %cmp83, label %cond.false.87, label %cond.true.85

cond.true.85:                                     ; preds = %if.then.75
  %call86 = call i64 @builtin_lisp_symbol(i32 901)
  br label %cond.end.88

cond.false.87:                                    ; preds = %if.then.75
  %34 = load i64, i64* %if_prop, align 8
  br label %cond.end.88

cond.end.88:                                      ; preds = %cond.false.87, %cond.true.85
  %cond89 = phi i64 [ %call86, %cond.true.85 ], [ %34, %cond.false.87 ]
  store i64 %cond89, i64* %retval
  br label %return

if.else.90:                                       ; preds = %if.else.71
  %35 = load i64, i64* %funcar, align 8
  %call91 = call i64 @builtin_lisp_symbol(i32 191)
  %cmp92 = icmp eq i64 %35, %call91
  br i1 %cmp92, label %if.then.94, label %if.else.109

if.then.94:                                       ; preds = %if.else.90
  %36 = load i64, i64* %fun, align 8
  %sub95 = sub nsw i64 %36, 3
  %37 = inttoptr i64 %sub95 to i8*
  %38 = bitcast i8* %37 to %struct.Lisp_Cons*
  %u96 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %38, i32 0, i32 1
  %cdr97 = bitcast %union.anon* %u96 to i64*
  %39 = load i64, i64* %cdr97, align 8
  %call98 = call i64 @Fcdr(i64 %39)
  %call99 = call i64 @Fcdr(i64 %call98)
  %call100 = call i64 @Fcar(i64 %call99)
  %call101 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp102 = icmp eq i64 %call100, %call101
  br i1 %cmp102, label %cond.false.106, label %cond.true.104

cond.true.104:                                    ; preds = %if.then.94
  %call105 = call i64 @builtin_lisp_symbol(i32 901)
  br label %cond.end.107

cond.false.106:                                   ; preds = %if.then.94
  %40 = load i64, i64* %if_prop, align 8
  br label %cond.end.107

cond.end.107:                                     ; preds = %cond.false.106, %cond.true.104
  %cond108 = phi i64 [ %call105, %cond.true.104 ], [ %40, %cond.false.106 ]
  store i64 %cond108, i64* %retval
  br label %return

if.else.109:                                      ; preds = %if.else.90
  %call110 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call110, i64* %retval
  br label %return

return:                                           ; preds = %if.else.109, %cond.end.107, %cond.end.88, %cond.end.69, %if.then.51, %cond.end.44, %cond.end.28, %cond.end, %if.then
  %41 = load i64, i64* %retval
  ret i64 %41
}

declare i64 @indirect_function(i64) #1

declare i64 @Fsymbol_function(i64) #1

declare zeroext i1 @SUBRP(i64) #1

declare %struct.Lisp_Subr* @XSUBR(i64) #1

declare zeroext i1 @COMPILEDP(i64) #1

declare i64 @ASIZE(i64) #1

declare zeroext i1 @STRINGP(i64) #1

declare zeroext i1 @VECTORP(i64) #1

; Function Attrs: nounwind uwtable
define i64 @Fautoload(i64 %function, i64 %file, i64 %docstring, i64 %interactive, i64 %type) #0 {
entry:
  %retval = alloca i64, align 8
  %function.addr = alloca i64, align 8
  %file.addr = alloca i64, align 8
  %docstring.addr = alloca i64, align 8
  %interactive.addr = alloca i64, align 8
  %type.addr = alloca i64, align 8
  store i64 %function, i64* %function.addr, align 8
  store i64 %file, i64* %file.addr, align 8
  store i64 %docstring, i64* %docstring.addr, align 8
  store i64 %interactive, i64* %interactive.addr, align 8
  store i64 %type, i64* %type.addr, align 8
  %0 = load i64, i64* %function.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = call i64 @builtin_lisp_symbol(i32 897)
  %1 = load i64, i64* %function.addr, align 8
  %2 = call i64 @wrong_type_argument(i64 %call, i64 %1) #8
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %3, %cond.true
  %4 = load i64, i64* %file.addr, align 8
  call void @CHECK_STRING(i64 %4)
  %5 = load i64, i64* %function.addr, align 8
  %sub = sub nsw i64 %5, 0
  %add.ptr = getelementptr inbounds i8, i8* bitcast ([1074 x %struct.Lisp_Symbol]* @lispsym to i8*), i64 %sub
  %6 = bitcast i8* %add.ptr to %struct.Lisp_Symbol*
  %function2 = getelementptr inbounds %struct.Lisp_Symbol, %struct.Lisp_Symbol* %6, i32 0, i32 3
  %7 = load i64, i64* %function2, align 8
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp4 = icmp eq i64 %7, %call3
  br i1 %cmp4, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %cond.end
  %8 = load i64, i64* %function.addr, align 8
  %sub6 = sub nsw i64 %8, 0
  %add.ptr7 = getelementptr inbounds i8, i8* bitcast ([1074 x %struct.Lisp_Symbol]* @lispsym to i8*), i64 %sub6
  %9 = bitcast i8* %add.ptr7 to %struct.Lisp_Symbol*
  %function8 = getelementptr inbounds %struct.Lisp_Symbol, %struct.Lisp_Symbol* %9, i32 0, i32 3
  %10 = load i64, i64* %function8, align 8
  %call9 = call zeroext i1 @AUTOLOADP(i64 %10)
  br i1 %call9, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %call10 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call10, i64* %retval
  br label %return

if.end:                                           ; preds = %land.lhs.true, %cond.end
  %11 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 240), align 8
  %call11 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp12 = icmp eq i64 %11, %call11
  br i1 %cmp12, label %if.end.19, label %land.lhs.true.14

land.lhs.true.14:                                 ; preds = %if.end
  %12 = load i64, i64* %docstring.addr, align 8
  %cmp15 = icmp eq i64 %12, 2
  br i1 %cmp15, label %if.then.17, label %if.end.19

if.then.17:                                       ; preds = %land.lhs.true.14
  %13 = load i64, i64* %function.addr, align 8
  %call18 = call i64 @XUINT(i64 %13)
  %shl = shl i64 %call18, 2
  %add = add i64 %shl, 2
  store i64 %add, i64* %docstring.addr, align 8
  br label %if.end.19

if.end.19:                                        ; preds = %if.then.17, %land.lhs.true.14, %if.end
  %14 = load i64, i64* %function.addr, align 8
  %call20 = call i64 @builtin_lisp_symbol(i32 191)
  %15 = load i64, i64* %file.addr, align 8
  %16 = load i64, i64* %docstring.addr, align 8
  %17 = load i64, i64* %interactive.addr, align 8
  %18 = load i64, i64* %type.addr, align 8
  %call21 = call i64 @list5(i64 %call20, i64 %15, i64 %16, i64 %17, i64 %18)
  %call22 = call i64 @builtin_lisp_symbol(i32 0)
  %call23 = call i64 @Fdefalias(i64 %14, i64 %call21, i64 %call22)
  store i64 %call23, i64* %retval
  br label %return

return:                                           ; preds = %if.end.19, %if.then
  %19 = load i64, i64* %retval
  ret i64 %19
}

declare zeroext i1 @AUTOLOADP(i64) #1

declare i64 @XUINT(i64) #1

declare i64 @Fdefalias(i64, i64, i64) #1

declare i64 @list5(i64, i64, i64, i64, i64) #1

; Function Attrs: nounwind uwtable
define void @un_autoload(i64 %oldqueue) #0 {
entry:
  %oldqueue.addr = alloca i64, align 8
  %queue = alloca i64, align 8
  %first = alloca i64, align 8
  %second = alloca i64, align 8
  store i64 %oldqueue, i64* %oldqueue.addr, align 8
  %0 = load i64, i64* @Vautoload_queue, align 8
  store i64 %0, i64* %queue, align 8
  %1 = load i64, i64* %oldqueue.addr, align 8
  store i64 %1, i64* @Vautoload_queue, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end, %entry
  %2 = load i64, i64* %queue, align 8
  %and = and i64 %2, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load i64, i64* %queue, align 8
  %sub = sub nsw i64 %3, 3
  %4 = inttoptr i64 %sub to i8*
  %5 = bitcast i8* %4 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %5, i32 0, i32 0
  %6 = load i64, i64* %car, align 8
  store i64 %6, i64* %first, align 8
  %7 = load i64, i64* %first, align 8
  %call = call i64 @Fcdr(i64 %7)
  store i64 %call, i64* %second, align 8
  %8 = load i64, i64* %first, align 8
  %call2 = call i64 @Fcar(i64 %8)
  store i64 %call2, i64* %first, align 8
  %9 = load i64, i64* %first, align 8
  %cmp3 = icmp eq i64 %9, 2
  br i1 %cmp3, label %if.then, label %if.else

if.then:                                          ; preds = %while.body
  %10 = load i64, i64* %second, align 8
  store i64 %10, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 92), align 8
  br label %if.end

if.else:                                          ; preds = %while.body
  %11 = load i64, i64* %first, align 8
  %12 = load i64, i64* %second, align 8
  %call5 = call i64 @Ffset(i64 %11, i64 %12)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %13 = load i64, i64* %queue, align 8
  %sub6 = sub nsw i64 %13, 3
  %14 = inttoptr i64 %sub6 to i8*
  %15 = bitcast i8* %14 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %15, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %16 = load i64, i64* %cdr, align 8
  store i64 %16, i64* %queue, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

declare i64 @Ffset(i64, i64) #1

declare i64 @Fnth(i64, i64) #1

declare i64 @SYMBOL_NAME(i64) #1

declare void @record_unwind_save_match_data() #1

declare i64 @Fload(i64, i64, i64, i64, i64) #1

declare i64 @Findirect_function(i64, i64) #1

declare i64 @Fequal(i64, i64) #1

; Function Attrs: nounwind uwtable
define i64 @Feval(i64 %form, i64 %lexical) #0 {
entry:
  %form.addr = alloca i64, align 8
  %lexical.addr = alloca i64, align 8
  %count = alloca i64, align 8
  store i64 %form, i64* %form.addr, align 8
  store i64 %lexical, i64* %lexical.addr, align 8
  %call = call i64 @SPECPDL_INDEX()
  store i64 %call, i64* %count, align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 567)
  %0 = load i64, i64* %lexical.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %cond.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i64, i64* %lexical.addr, align 8
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp4 = icmp eq i64 %1, %call3
  br i1 %cmp4, label %cond.true, label %cond.false

cond.true:                                        ; preds = %lor.lhs.false, %entry
  %2 = load i64, i64* %lexical.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %lor.lhs.false
  %call6 = call i64 @builtin_lisp_symbol(i32 901)
  %call7 = call i64 @list1(i64 %call6)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %2, %cond.true ], [ %call7, %cond.false ]
  call void @specbind(i64 %call1, i64 %cond)
  %3 = load i64, i64* %count, align 8
  %4 = load i64, i64* %form.addr, align 8
  %call8 = call i64 @eval_sub(i64 %4)
  %call9 = call i64 @unbind_to(i64 %3, i64 %call8)
  ret i64 %call9
}

; Function Attrs: nounwind uwtable
define i64 @record_in_backtrace(i64 %function, i64* %args, i64 %nargs) #0 {
entry:
  %function.addr = alloca i64, align 8
  %args.addr = alloca i64*, align 8
  %nargs.addr = alloca i64, align 8
  %count = alloca i64, align 8
  store i64 %function, i64* %function.addr, align 8
  store i64* %args, i64** %args.addr, align 8
  store i64 %nargs, i64* %nargs.addr, align 8
  %call = call i64 @SPECPDL_INDEX()
  store i64 %call, i64* %count, align 8
  %0 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %bt = bitcast %union.specbinding* %0 to %struct.anon.4*
  %1 = bitcast %struct.anon.4* %bt to i16*
  %bf.load = load i16, i16* %1, align 8
  %bf.clear = and i16 %bf.load, -256
  %bf.set = or i16 %bf.clear, 4
  store i16 %bf.set, i16* %1, align 8
  %2 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %bt1 = bitcast %union.specbinding* %2 to %struct.anon.4*
  %3 = bitcast %struct.anon.4* %bt1 to i16*
  %bf.load2 = load i16, i16* %3, align 8
  %bf.clear3 = and i16 %bf.load2, -257
  store i16 %bf.clear3, i16* %3, align 8
  %4 = load i64, i64* %function.addr, align 8
  %5 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %bt4 = bitcast %union.specbinding* %5 to %struct.anon.4*
  %function5 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %bt4, i32 0, i32 1
  store i64 %4, i64* %function5, align 8
  %6 = load i64*, i64** %args.addr, align 8
  %7 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %bt6 = bitcast %union.specbinding* %7 to %struct.anon.4*
  %args7 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %bt6, i32 0, i32 2
  store i64* %6, i64** %args7, align 8
  %8 = load i64, i64* %nargs.addr, align 8
  %9 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %bt8 = bitcast %union.specbinding* %9 to %struct.anon.4*
  %nargs9 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %bt8, i32 0, i32 3
  store i64 %8, i64* %nargs9, align 8
  call void @grow_specpdl()
  %10 = load i64, i64* %count, align 8
  ret i64 %10
}

declare i64 @Fsymbol_value(i64) #1

declare void @maybe_gc() #1

; Function Attrs: nounwind uwtable
define internal void @do_debug_on_call(i64 %code, i64 %count) #0 {
entry:
  %code.addr = alloca i64, align 8
  %count.addr = alloca i64, align 8
  store i64 %code, i64* %code.addr, align 8
  store i64 %count, i64* %count.addr, align 8
  store i8 0, i8* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 432), align 1
  %0 = load %union.specbinding*, %union.specbinding** @specpdl, align 8
  %1 = load i64, i64* %count.addr, align 8
  %add.ptr = getelementptr inbounds %union.specbinding, %union.specbinding* %0, i64 %1
  call void @set_backtrace_debug_on_exit(%union.specbinding* %add.ptr, i1 zeroext true)
  %2 = load i64, i64* %code.addr, align 8
  %call = call i64 @list1(i64 %2)
  %call1 = call i64 @call_debugger(i64 %call)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @set_backtrace_args(%union.specbinding* %pdl, i64* %args, i64 %nargs) #0 {
entry:
  %pdl.addr = alloca %union.specbinding*, align 8
  %args.addr = alloca i64*, align 8
  %nargs.addr = alloca i64, align 8
  store %union.specbinding* %pdl, %union.specbinding** %pdl.addr, align 8
  store i64* %args, i64** %args.addr, align 8
  store i64 %nargs, i64* %nargs.addr, align 8
  %0 = load i64*, i64** %args.addr, align 8
  %1 = load %union.specbinding*, %union.specbinding** %pdl.addr, align 8
  %bt = bitcast %union.specbinding* %1 to %struct.anon.4*
  %args1 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %bt, i32 0, i32 2
  store i64* %0, i64** %args1, align 8
  %2 = load i64, i64* %nargs.addr, align 8
  %3 = load %union.specbinding*, %union.specbinding** %pdl.addr, align 8
  %bt2 = bitcast %union.specbinding* %3 to %struct.anon.4*
  %nargs3 = getelementptr inbounds %struct.anon.4, %struct.anon.4* %bt2, i32 0, i32 3
  store i64 %2, i64* %nargs3, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @backtrace_debug_on_exit(%union.specbinding* %pdl) #0 {
entry:
  %pdl.addr = alloca %union.specbinding*, align 8
  store %union.specbinding* %pdl, %union.specbinding** %pdl.addr, align 8
  %0 = load %union.specbinding*, %union.specbinding** %pdl.addr, align 8
  %bt = bitcast %union.specbinding* %0 to %struct.anon.4*
  %1 = bitcast %struct.anon.4* %bt to i16*
  %bf.load = load i16, i16* %1, align 8
  %bf.lshr = lshr i16 %bf.load, 8
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = trunc i16 %bf.clear to i1
  ret i1 %bf.cast
}

; Function Attrs: nounwind uwtable
define internal i64 @apply_lambda(i64 %fun, i64 %args, i64 %count) #0 {
entry:
  %fun.addr = alloca i64, align 8
  %args.addr = alloca i64, align 8
  %count.addr = alloca i64, align 8
  %args_left = alloca i64, align 8
  %i = alloca i64, align 8
  %numargs = alloca i64, align 8
  %arg_vector = alloca i64*, align 8
  %tem = alloca i64, align 8
  %sa_avail = alloca i64, align 8
  %sa_count = alloca i64, align 8
  %sa_must_free = alloca i8, align 1
  %alloca_nbytes = alloca i64, align 8
  %arg_ = alloca i64, align 8
  store i64 %fun, i64* %fun.addr, align 8
  store i64 %args, i64* %args.addr, align 8
  store i64 %count, i64* %count.addr, align 8
  store i64 16384, i64* %sa_avail, align 8
  %call = call i64 @SPECPDL_INDEX()
  store i64 %call, i64* %sa_count, align 8
  store i8 0, i8* %sa_must_free, align 1
  %0 = load i64, i64* %args.addr, align 8
  %call1 = call i64 @Flength(i64 %0)
  %shr = ashr i64 %call1, 2
  store i64 %shr, i64* %numargs, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br i1 false, label %cond.true, label %cond.false.472

cond.true:                                        ; preds = %do.body
  br i1 false, label %cond.true.2, label %cond.false.257

cond.true.2:                                      ; preds = %cond.true
  %1 = load i64, i64* %numargs, align 8
  %conv = trunc i64 %1 to i8
  %conv3 = sext i8 %conv to i32
  %add = add nsw i32 0, %conv3
  %mul = mul nsw i32 0, %add
  %sub = sub nsw i32 %mul, 1
  %cmp = icmp slt i32 %sub, 0
  br i1 %cmp, label %cond.true.5, label %cond.false

cond.true.5:                                      ; preds = %cond.true.2
  %2 = load i64, i64* %numargs, align 8
  %conv6 = trunc i64 %2 to i8
  %conv7 = sext i8 %conv6 to i32
  %add8 = add nsw i32 0, %conv7
  %mul9 = mul nsw i32 0, %add8
  %add10 = add nsw i32 %mul9, 0
  %neg = xor i32 %add10, -1
  %cmp11 = icmp eq i32 %neg, -1
  %conv12 = zext i1 %cmp11 to i32
  %sub13 = sub nsw i32 0, %conv12
  %3 = load i64, i64* %numargs, align 8
  %conv14 = trunc i64 %3 to i8
  %conv15 = sext i8 %conv14 to i32
  %add16 = add nsw i32 0, %conv15
  %mul17 = mul nsw i32 0, %add16
  %add18 = add nsw i32 %mul17, 1
  %shl = shl i32 %add18, 30
  %sub19 = sub nsw i32 %shl, 1
  %mul20 = mul nsw i32 %sub19, 2
  %add21 = add nsw i32 %mul20, 1
  %sub22 = sub nsw i32 %sub13, %add21
  br label %cond.end

cond.false:                                       ; preds = %cond.true.2
  %4 = load i64, i64* %numargs, align 8
  %conv23 = trunc i64 %4 to i8
  %conv24 = sext i8 %conv23 to i32
  %add25 = add nsw i32 0, %conv24
  %mul26 = mul nsw i32 0, %add25
  %add27 = add nsw i32 %mul26, 0
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true.5
  %cond = phi i32 [ %sub22, %cond.true.5 ], [ %add27, %cond.false ]
  %cmp28 = icmp eq i32 %cond, 0
  br i1 %cmp28, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %cond.end
  %5 = load i64, i64* %numargs, align 8
  %conv30 = trunc i64 %5 to i8
  %conv31 = sext i8 %conv30 to i32
  %cmp32 = icmp slt i32 %conv31, 0
  br i1 %cmp32, label %cond.true.211, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %cond.end
  br i1 false, label %cond.true.34, label %cond.false.112

cond.true.34:                                     ; preds = %lor.lhs.false
  %6 = load i64, i64* %numargs, align 8
  %conv35 = trunc i64 %6 to i8
  %conv36 = sext i8 %conv35 to i32
  %cmp37 = icmp slt i32 %conv36, 0
  br i1 %cmp37, label %cond.true.39, label %cond.false.69

cond.true.39:                                     ; preds = %cond.true.34
  %7 = load i64, i64* %numargs, align 8
  %conv40 = trunc i64 %7 to i8
  %conv41 = sext i8 %conv40 to i32
  %8 = load i64, i64* %numargs, align 8
  %conv42 = trunc i64 %8 to i8
  %conv43 = sext i8 %conv42 to i32
  %add44 = add nsw i32 0, %conv43
  %mul45 = mul nsw i32 0, %add44
  %sub46 = sub nsw i32 %mul45, 1
  %cmp47 = icmp slt i32 %sub46, 0
  br i1 %cmp47, label %cond.true.49, label %cond.false.59

cond.true.49:                                     ; preds = %cond.true.39
  %9 = load i64, i64* %numargs, align 8
  %conv50 = trunc i64 %9 to i8
  %conv51 = sext i8 %conv50 to i32
  %add52 = add nsw i32 0, %conv51
  %mul53 = mul nsw i32 0, %add52
  %add54 = add nsw i32 %mul53, 1
  %shl55 = shl i32 %add54, 30
  %sub56 = sub nsw i32 %shl55, 1
  %mul57 = mul nsw i32 %sub56, 2
  %add58 = add nsw i32 %mul57, 1
  br label %cond.end.65

cond.false.59:                                    ; preds = %cond.true.39
  %10 = load i64, i64* %numargs, align 8
  %conv60 = trunc i64 %10 to i8
  %conv61 = sext i8 %conv60 to i32
  %add62 = add nsw i32 0, %conv61
  %mul63 = mul nsw i32 0, %add62
  %sub64 = sub nsw i32 %mul63, 1
  br label %cond.end.65

cond.end.65:                                      ; preds = %cond.false.59, %cond.true.49
  %cond66 = phi i32 [ %add58, %cond.true.49 ], [ %sub64, %cond.false.59 ]
  %div = sdiv i32 %cond66, 8
  %cmp67 = icmp slt i32 %conv41, %div
  br i1 %cmp67, label %cond.true.211, label %lor.lhs.false.191

cond.false.69:                                    ; preds = %cond.true.34
  br i1 false, label %cond.true.70, label %cond.false.71

cond.true.70:                                     ; preds = %cond.false.69
  br i1 false, label %cond.true.211, label %lor.lhs.false.191

cond.false.71:                                    ; preds = %cond.false.69
  %11 = load i64, i64* %numargs, align 8
  %conv72 = trunc i64 %11 to i8
  %conv73 = sext i8 %conv72 to i32
  %add74 = add nsw i32 0, %conv73
  %mul75 = mul nsw i32 0, %add74
  %sub76 = sub nsw i32 %mul75, 1
  %cmp77 = icmp slt i32 %sub76, 0
  br i1 %cmp77, label %cond.true.79, label %cond.false.99

cond.true.79:                                     ; preds = %cond.false.71
  %12 = load i64, i64* %numargs, align 8
  %conv80 = trunc i64 %12 to i8
  %conv81 = sext i8 %conv80 to i32
  %add82 = add nsw i32 0, %conv81
  %mul83 = mul nsw i32 0, %add82
  %add84 = add nsw i32 %mul83, 0
  %neg85 = xor i32 %add84, -1
  %cmp86 = icmp eq i32 %neg85, -1
  %conv87 = zext i1 %cmp86 to i32
  %sub88 = sub nsw i32 0, %conv87
  %13 = load i64, i64* %numargs, align 8
  %conv89 = trunc i64 %13 to i8
  %conv90 = sext i8 %conv89 to i32
  %add91 = add nsw i32 0, %conv90
  %mul92 = mul nsw i32 0, %add91
  %add93 = add nsw i32 %mul92, 1
  %shl94 = shl i32 %add93, 30
  %sub95 = sub nsw i32 %shl94, 1
  %mul96 = mul nsw i32 %sub95, 2
  %add97 = add nsw i32 %mul96, 1
  %sub98 = sub nsw i32 %sub88, %add97
  br label %cond.end.105

cond.false.99:                                    ; preds = %cond.false.71
  %14 = load i64, i64* %numargs, align 8
  %conv100 = trunc i64 %14 to i8
  %conv101 = sext i8 %conv100 to i32
  %add102 = add nsw i32 0, %conv101
  %mul103 = mul nsw i32 0, %add102
  %add104 = add nsw i32 %mul103, 0
  br label %cond.end.105

cond.end.105:                                     ; preds = %cond.false.99, %cond.true.79
  %cond106 = phi i32 [ %sub98, %cond.true.79 ], [ %add104, %cond.false.99 ]
  %div107 = sdiv i32 %cond106, 8
  %15 = load i64, i64* %numargs, align 8
  %conv108 = trunc i64 %15 to i8
  %conv109 = sext i8 %conv108 to i32
  %cmp110 = icmp slt i32 %div107, %conv109
  br i1 %cmp110, label %cond.true.211, label %lor.lhs.false.191

cond.false.112:                                   ; preds = %lor.lhs.false
  br i1 false, label %cond.true.113, label %cond.false.114

cond.true.113:                                    ; preds = %cond.false.112
  br i1 false, label %cond.true.211, label %lor.lhs.false.191

cond.false.114:                                   ; preds = %cond.false.112
  %16 = load i64, i64* %numargs, align 8
  %conv115 = trunc i64 %16 to i8
  %conv116 = sext i8 %conv115 to i32
  %cmp117 = icmp slt i32 %conv116, 0
  br i1 %cmp117, label %cond.true.119, label %cond.false.160

cond.true.119:                                    ; preds = %cond.false.114
  %17 = load i64, i64* %numargs, align 8
  %conv120 = trunc i64 %17 to i8
  %conv121 = sext i8 %conv120 to i32
  %18 = load i64, i64* %numargs, align 8
  %conv122 = trunc i64 %18 to i8
  %conv123 = sext i8 %conv122 to i32
  %add124 = add nsw i32 0, %conv123
  %mul125 = mul nsw i32 0, %add124
  %sub126 = sub nsw i32 %mul125, 1
  %cmp127 = icmp slt i32 %sub126, 0
  br i1 %cmp127, label %cond.true.129, label %cond.false.149

cond.true.129:                                    ; preds = %cond.true.119
  %19 = load i64, i64* %numargs, align 8
  %conv130 = trunc i64 %19 to i8
  %conv131 = sext i8 %conv130 to i32
  %add132 = add nsw i32 0, %conv131
  %mul133 = mul nsw i32 0, %add132
  %add134 = add nsw i32 %mul133, 0
  %neg135 = xor i32 %add134, -1
  %cmp136 = icmp eq i32 %neg135, -1
  %conv137 = zext i1 %cmp136 to i32
  %sub138 = sub nsw i32 0, %conv137
  %20 = load i64, i64* %numargs, align 8
  %conv139 = trunc i64 %20 to i8
  %conv140 = sext i8 %conv139 to i32
  %add141 = add nsw i32 0, %conv140
  %mul142 = mul nsw i32 0, %add141
  %add143 = add nsw i32 %mul142, 1
  %shl144 = shl i32 %add143, 30
  %sub145 = sub nsw i32 %shl144, 1
  %mul146 = mul nsw i32 %sub145, 2
  %add147 = add nsw i32 %mul146, 1
  %sub148 = sub nsw i32 %sub138, %add147
  br label %cond.end.155

cond.false.149:                                   ; preds = %cond.true.119
  %21 = load i64, i64* %numargs, align 8
  %conv150 = trunc i64 %21 to i8
  %conv151 = sext i8 %conv150 to i32
  %add152 = add nsw i32 0, %conv151
  %mul153 = mul nsw i32 0, %add152
  %add154 = add nsw i32 %mul153, 0
  br label %cond.end.155

cond.end.155:                                     ; preds = %cond.false.149, %cond.true.129
  %cond156 = phi i32 [ %sub148, %cond.true.129 ], [ %add154, %cond.false.149 ]
  %div157 = sdiv i32 %cond156, 8
  %cmp158 = icmp slt i32 %conv121, %div157
  br i1 %cmp158, label %cond.true.211, label %lor.lhs.false.191

cond.false.160:                                   ; preds = %cond.false.114
  %22 = load i64, i64* %numargs, align 8
  %conv161 = trunc i64 %22 to i8
  %conv162 = sext i8 %conv161 to i32
  %add163 = add nsw i32 0, %conv162
  %mul164 = mul nsw i32 0, %add163
  %sub165 = sub nsw i32 %mul164, 1
  %cmp166 = icmp slt i32 %sub165, 0
  br i1 %cmp166, label %cond.true.168, label %cond.false.178

cond.true.168:                                    ; preds = %cond.false.160
  %23 = load i64, i64* %numargs, align 8
  %conv169 = trunc i64 %23 to i8
  %conv170 = sext i8 %conv169 to i32
  %add171 = add nsw i32 0, %conv170
  %mul172 = mul nsw i32 0, %add171
  %add173 = add nsw i32 %mul172, 1
  %shl174 = shl i32 %add173, 30
  %sub175 = sub nsw i32 %shl174, 1
  %mul176 = mul nsw i32 %sub175, 2
  %add177 = add nsw i32 %mul176, 1
  br label %cond.end.184

cond.false.178:                                   ; preds = %cond.false.160
  %24 = load i64, i64* %numargs, align 8
  %conv179 = trunc i64 %24 to i8
  %conv180 = sext i8 %conv179 to i32
  %add181 = add nsw i32 0, %conv180
  %mul182 = mul nsw i32 0, %add181
  %sub183 = sub nsw i32 %mul182, 1
  br label %cond.end.184

cond.end.184:                                     ; preds = %cond.false.178, %cond.true.168
  %cond185 = phi i32 [ %add177, %cond.true.168 ], [ %sub183, %cond.false.178 ]
  %div186 = sdiv i32 %cond185, 8
  %25 = load i64, i64* %numargs, align 8
  %conv187 = trunc i64 %25 to i8
  %conv188 = sext i8 %conv187 to i32
  %cmp189 = icmp slt i32 %div186, %conv188
  br i1 %cmp189, label %cond.true.211, label %lor.lhs.false.191

lor.lhs.false.191:                                ; preds = %cond.end.184, %cond.end.155, %cond.true.113, %cond.end.105, %cond.true.70, %cond.end.65
  %26 = load i64, i64* %numargs, align 8
  %conv192 = trunc i64 %26 to i8
  %conv193 = sext i8 %conv192 to i32
  %mul194 = mul nsw i32 %conv193, 8
  %mul195 = mul nsw i32 0, %mul194
  %sub196 = sub nsw i32 %mul195, 1
  %cmp197 = icmp slt i32 %sub196, 0
  br i1 %cmp197, label %land.lhs.true.199, label %lor.lhs.false.205

land.lhs.true.199:                                ; preds = %lor.lhs.false.191
  %27 = load i64, i64* %numargs, align 8
  %conv200 = trunc i64 %27 to i8
  %conv201 = sext i8 %conv200 to i32
  %mul202 = mul nsw i32 %conv201, 8
  %cmp203 = icmp slt i32 %mul202, -128
  br i1 %cmp203, label %cond.true.211, label %lor.lhs.false.205

lor.lhs.false.205:                                ; preds = %land.lhs.true.199, %lor.lhs.false.191
  %28 = load i64, i64* %numargs, align 8
  %conv206 = trunc i64 %28 to i8
  %conv207 = sext i8 %conv206 to i32
  %mul208 = mul nsw i32 %conv207, 8
  %cmp209 = icmp slt i32 127, %mul208
  br i1 %cmp209, label %cond.true.211, label %cond.false.234

cond.true.211:                                    ; preds = %lor.lhs.false.205, %land.lhs.true.199, %cond.end.184, %cond.end.155, %cond.true.113, %cond.end.105, %cond.true.70, %cond.end.65, %land.lhs.true
  %29 = load i64, i64* %numargs, align 8
  %conv212 = trunc i64 %29 to i8
  %conv213 = zext i8 %conv212 to i32
  %mul214 = mul nsw i32 %conv213, 8
  %cmp215 = icmp sle i32 %mul214, 127
  br i1 %cmp215, label %cond.true.217, label %cond.false.223

cond.true.217:                                    ; preds = %cond.true.211
  %30 = load i64, i64* %numargs, align 8
  %conv218 = trunc i64 %30 to i8
  %conv219 = zext i8 %conv218 to i32
  %mul220 = mul nsw i32 %conv219, 8
  %conv221 = trunc i32 %mul220 to i8
  %conv222 = sext i8 %conv221 to i32
  br label %cond.end.231

cond.false.223:                                   ; preds = %cond.true.211
  %31 = load i64, i64* %numargs, align 8
  %conv224 = trunc i64 %31 to i8
  %conv225 = zext i8 %conv224 to i32
  %mul226 = mul nsw i32 %conv225, 8
  %sub227 = sub nsw i32 %mul226, -128
  %conv228 = trunc i32 %sub227 to i8
  %conv229 = sext i8 %conv228 to i32
  %add230 = add nsw i32 %conv229, -128
  br label %cond.end.231

cond.end.231:                                     ; preds = %cond.false.223, %cond.true.217
  %cond232 = phi i32 [ %conv222, %cond.true.217 ], [ %add230, %cond.false.223 ]
  %conv233 = sext i32 %cond232 to i64
  store i64 %conv233, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then, label %lor.lhs.false.2161

cond.false.234:                                   ; preds = %lor.lhs.false.205
  %32 = load i64, i64* %numargs, align 8
  %conv235 = trunc i64 %32 to i8
  %conv236 = zext i8 %conv235 to i32
  %mul237 = mul nsw i32 %conv236, 8
  %cmp238 = icmp sle i32 %mul237, 127
  br i1 %cmp238, label %cond.true.240, label %cond.false.246

cond.true.240:                                    ; preds = %cond.false.234
  %33 = load i64, i64* %numargs, align 8
  %conv241 = trunc i64 %33 to i8
  %conv242 = zext i8 %conv241 to i32
  %mul243 = mul nsw i32 %conv242, 8
  %conv244 = trunc i32 %mul243 to i8
  %conv245 = sext i8 %conv244 to i32
  br label %cond.end.254

cond.false.246:                                   ; preds = %cond.false.234
  %34 = load i64, i64* %numargs, align 8
  %conv247 = trunc i64 %34 to i8
  %conv248 = zext i8 %conv247 to i32
  %mul249 = mul nsw i32 %conv248, 8
  %sub250 = sub nsw i32 %mul249, -128
  %conv251 = trunc i32 %sub250 to i8
  %conv252 = sext i8 %conv251 to i32
  %add253 = add nsw i32 %conv252, -128
  br label %cond.end.254

cond.end.254:                                     ; preds = %cond.false.246, %cond.true.240
  %cond255 = phi i32 [ %conv245, %cond.true.240 ], [ %add253, %cond.false.246 ]
  %conv256 = sext i32 %cond255 to i64
  store i64 %conv256, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then, label %lor.lhs.false.2161

cond.false.257:                                   ; preds = %cond.true
  %35 = load i64, i64* %numargs, align 8
  %add258 = add nsw i64 0, %35
  %mul259 = mul nsw i64 0, %add258
  %sub260 = sub nsw i64 %mul259, 1
  %cmp261 = icmp slt i64 %sub260, 0
  br i1 %cmp261, label %cond.true.263, label %cond.false.280

cond.true.263:                                    ; preds = %cond.false.257
  %36 = load i64, i64* %numargs, align 8
  %add264 = add nsw i64 0, %36
  %mul265 = mul nsw i64 0, %add264
  %add266 = add nsw i64 %mul265, 0
  %neg267 = xor i64 %add266, -1
  %cmp268 = icmp eq i64 %neg267, -1
  %conv269 = zext i1 %cmp268 to i32
  %sub270 = sub nsw i32 0, %conv269
  %conv271 = sext i32 %sub270 to i64
  %37 = load i64, i64* %numargs, align 8
  %add272 = add nsw i64 0, %37
  %mul273 = mul nsw i64 0, %add272
  %add274 = add nsw i64 %mul273, 1
  %shl275 = shl i64 %add274, 62
  %sub276 = sub nsw i64 %shl275, 1
  %mul277 = mul nsw i64 %sub276, 2
  %add278 = add nsw i64 %mul277, 1
  %sub279 = sub nsw i64 %conv271, %add278
  br label %cond.end.284

cond.false.280:                                   ; preds = %cond.false.257
  %38 = load i64, i64* %numargs, align 8
  %add281 = add nsw i64 0, %38
  %mul282 = mul nsw i64 0, %add281
  %add283 = add nsw i64 %mul282, 0
  br label %cond.end.284

cond.end.284:                                     ; preds = %cond.false.280, %cond.true.263
  %cond285 = phi i64 [ %sub279, %cond.true.263 ], [ %add283, %cond.false.280 ]
  %cmp286 = icmp eq i64 %cond285, 0
  br i1 %cmp286, label %land.lhs.true.288, label %lor.lhs.false.291

land.lhs.true.288:                                ; preds = %cond.end.284
  %39 = load i64, i64* %numargs, align 8
  %cmp289 = icmp slt i64 %39, 0
  br i1 %cmp289, label %cond.true.426, label %lor.lhs.false.291

lor.lhs.false.291:                                ; preds = %land.lhs.true.288, %cond.end.284
  br i1 false, label %cond.true.292, label %cond.false.352

cond.true.292:                                    ; preds = %lor.lhs.false.291
  %40 = load i64, i64* %numargs, align 8
  %cmp293 = icmp slt i64 %40, 0
  br i1 %cmp293, label %cond.true.295, label %cond.false.318

cond.true.295:                                    ; preds = %cond.true.292
  %41 = load i64, i64* %numargs, align 8
  %42 = load i64, i64* %numargs, align 8
  %add296 = add nsw i64 0, %42
  %mul297 = mul nsw i64 0, %add296
  %sub298 = sub nsw i64 %mul297, 1
  %cmp299 = icmp slt i64 %sub298, 0
  br i1 %cmp299, label %cond.true.301, label %cond.false.309

cond.true.301:                                    ; preds = %cond.true.295
  %43 = load i64, i64* %numargs, align 8
  %add302 = add nsw i64 0, %43
  %mul303 = mul nsw i64 0, %add302
  %add304 = add nsw i64 %mul303, 1
  %shl305 = shl i64 %add304, 62
  %sub306 = sub nsw i64 %shl305, 1
  %mul307 = mul nsw i64 %sub306, 2
  %add308 = add nsw i64 %mul307, 1
  br label %cond.end.313

cond.false.309:                                   ; preds = %cond.true.295
  %44 = load i64, i64* %numargs, align 8
  %add310 = add nsw i64 0, %44
  %mul311 = mul nsw i64 0, %add310
  %sub312 = sub nsw i64 %mul311, 1
  br label %cond.end.313

cond.end.313:                                     ; preds = %cond.false.309, %cond.true.301
  %cond314 = phi i64 [ %add308, %cond.true.301 ], [ %sub312, %cond.false.309 ]
  %div315 = sdiv i64 %cond314, 8
  %cmp316 = icmp slt i64 %41, %div315
  br i1 %cmp316, label %cond.true.426, label %lor.lhs.false.412

cond.false.318:                                   ; preds = %cond.true.292
  br i1 false, label %cond.true.319, label %cond.false.320

cond.true.319:                                    ; preds = %cond.false.318
  br i1 false, label %cond.true.426, label %lor.lhs.false.412

cond.false.320:                                   ; preds = %cond.false.318
  %45 = load i64, i64* %numargs, align 8
  %add321 = add nsw i64 0, %45
  %mul322 = mul nsw i64 0, %add321
  %sub323 = sub nsw i64 %mul322, 1
  %cmp324 = icmp slt i64 %sub323, 0
  br i1 %cmp324, label %cond.true.326, label %cond.false.343

cond.true.326:                                    ; preds = %cond.false.320
  %46 = load i64, i64* %numargs, align 8
  %add327 = add nsw i64 0, %46
  %mul328 = mul nsw i64 0, %add327
  %add329 = add nsw i64 %mul328, 0
  %neg330 = xor i64 %add329, -1
  %cmp331 = icmp eq i64 %neg330, -1
  %conv332 = zext i1 %cmp331 to i32
  %sub333 = sub nsw i32 0, %conv332
  %conv334 = sext i32 %sub333 to i64
  %47 = load i64, i64* %numargs, align 8
  %add335 = add nsw i64 0, %47
  %mul336 = mul nsw i64 0, %add335
  %add337 = add nsw i64 %mul336, 1
  %shl338 = shl i64 %add337, 62
  %sub339 = sub nsw i64 %shl338, 1
  %mul340 = mul nsw i64 %sub339, 2
  %add341 = add nsw i64 %mul340, 1
  %sub342 = sub nsw i64 %conv334, %add341
  br label %cond.end.347

cond.false.343:                                   ; preds = %cond.false.320
  %48 = load i64, i64* %numargs, align 8
  %add344 = add nsw i64 0, %48
  %mul345 = mul nsw i64 0, %add344
  %add346 = add nsw i64 %mul345, 0
  br label %cond.end.347

cond.end.347:                                     ; preds = %cond.false.343, %cond.true.326
  %cond348 = phi i64 [ %sub342, %cond.true.326 ], [ %add346, %cond.false.343 ]
  %div349 = sdiv i64 %cond348, 8
  %49 = load i64, i64* %numargs, align 8
  %cmp350 = icmp slt i64 %div349, %49
  br i1 %cmp350, label %cond.true.426, label %lor.lhs.false.412

cond.false.352:                                   ; preds = %lor.lhs.false.291
  br i1 false, label %cond.true.353, label %cond.false.354

cond.true.353:                                    ; preds = %cond.false.352
  br i1 false, label %cond.true.426, label %lor.lhs.false.412

cond.false.354:                                   ; preds = %cond.false.352
  %50 = load i64, i64* %numargs, align 8
  %cmp355 = icmp slt i64 %50, 0
  br i1 %cmp355, label %cond.true.357, label %cond.false.389

cond.true.357:                                    ; preds = %cond.false.354
  %51 = load i64, i64* %numargs, align 8
  %52 = load i64, i64* %numargs, align 8
  %add358 = add nsw i64 0, %52
  %mul359 = mul nsw i64 0, %add358
  %sub360 = sub nsw i64 %mul359, 1
  %cmp361 = icmp slt i64 %sub360, 0
  br i1 %cmp361, label %cond.true.363, label %cond.false.380

cond.true.363:                                    ; preds = %cond.true.357
  %53 = load i64, i64* %numargs, align 8
  %add364 = add nsw i64 0, %53
  %mul365 = mul nsw i64 0, %add364
  %add366 = add nsw i64 %mul365, 0
  %neg367 = xor i64 %add366, -1
  %cmp368 = icmp eq i64 %neg367, -1
  %conv369 = zext i1 %cmp368 to i32
  %sub370 = sub nsw i32 0, %conv369
  %conv371 = sext i32 %sub370 to i64
  %54 = load i64, i64* %numargs, align 8
  %add372 = add nsw i64 0, %54
  %mul373 = mul nsw i64 0, %add372
  %add374 = add nsw i64 %mul373, 1
  %shl375 = shl i64 %add374, 62
  %sub376 = sub nsw i64 %shl375, 1
  %mul377 = mul nsw i64 %sub376, 2
  %add378 = add nsw i64 %mul377, 1
  %sub379 = sub nsw i64 %conv371, %add378
  br label %cond.end.384

cond.false.380:                                   ; preds = %cond.true.357
  %55 = load i64, i64* %numargs, align 8
  %add381 = add nsw i64 0, %55
  %mul382 = mul nsw i64 0, %add381
  %add383 = add nsw i64 %mul382, 0
  br label %cond.end.384

cond.end.384:                                     ; preds = %cond.false.380, %cond.true.363
  %cond385 = phi i64 [ %sub379, %cond.true.363 ], [ %add383, %cond.false.380 ]
  %div386 = sdiv i64 %cond385, 8
  %cmp387 = icmp slt i64 %51, %div386
  br i1 %cmp387, label %cond.true.426, label %lor.lhs.false.412

cond.false.389:                                   ; preds = %cond.false.354
  %56 = load i64, i64* %numargs, align 8
  %add390 = add nsw i64 0, %56
  %mul391 = mul nsw i64 0, %add390
  %sub392 = sub nsw i64 %mul391, 1
  %cmp393 = icmp slt i64 %sub392, 0
  br i1 %cmp393, label %cond.true.395, label %cond.false.403

cond.true.395:                                    ; preds = %cond.false.389
  %57 = load i64, i64* %numargs, align 8
  %add396 = add nsw i64 0, %57
  %mul397 = mul nsw i64 0, %add396
  %add398 = add nsw i64 %mul397, 1
  %shl399 = shl i64 %add398, 62
  %sub400 = sub nsw i64 %shl399, 1
  %mul401 = mul nsw i64 %sub400, 2
  %add402 = add nsw i64 %mul401, 1
  br label %cond.end.407

cond.false.403:                                   ; preds = %cond.false.389
  %58 = load i64, i64* %numargs, align 8
  %add404 = add nsw i64 0, %58
  %mul405 = mul nsw i64 0, %add404
  %sub406 = sub nsw i64 %mul405, 1
  br label %cond.end.407

cond.end.407:                                     ; preds = %cond.false.403, %cond.true.395
  %cond408 = phi i64 [ %add402, %cond.true.395 ], [ %sub406, %cond.false.403 ]
  %div409 = sdiv i64 %cond408, 8
  %59 = load i64, i64* %numargs, align 8
  %cmp410 = icmp slt i64 %div409, %59
  br i1 %cmp410, label %cond.true.426, label %lor.lhs.false.412

lor.lhs.false.412:                                ; preds = %cond.end.407, %cond.end.384, %cond.true.353, %cond.end.347, %cond.true.319, %cond.end.313
  %60 = load i64, i64* %numargs, align 8
  %mul413 = mul nsw i64 %60, 8
  %mul414 = mul nsw i64 0, %mul413
  %sub415 = sub nsw i64 %mul414, 1
  %cmp416 = icmp slt i64 %sub415, 0
  br i1 %cmp416, label %land.lhs.true.418, label %lor.lhs.false.422

land.lhs.true.418:                                ; preds = %lor.lhs.false.412
  %61 = load i64, i64* %numargs, align 8
  %mul419 = mul nsw i64 %61, 8
  %cmp420 = icmp slt i64 %mul419, -128
  br i1 %cmp420, label %cond.true.426, label %lor.lhs.false.422

lor.lhs.false.422:                                ; preds = %land.lhs.true.418, %lor.lhs.false.412
  %62 = load i64, i64* %numargs, align 8
  %mul423 = mul nsw i64 %62, 8
  %cmp424 = icmp slt i64 127, %mul423
  br i1 %cmp424, label %cond.true.426, label %cond.false.449

cond.true.426:                                    ; preds = %lor.lhs.false.422, %land.lhs.true.418, %cond.end.407, %cond.end.384, %cond.true.353, %cond.end.347, %cond.true.319, %cond.end.313, %land.lhs.true.288
  %63 = load i64, i64* %numargs, align 8
  %conv427 = trunc i64 %63 to i8
  %conv428 = zext i8 %conv427 to i32
  %mul429 = mul nsw i32 %conv428, 8
  %cmp430 = icmp sle i32 %mul429, 127
  br i1 %cmp430, label %cond.true.432, label %cond.false.438

cond.true.432:                                    ; preds = %cond.true.426
  %64 = load i64, i64* %numargs, align 8
  %conv433 = trunc i64 %64 to i8
  %conv434 = zext i8 %conv433 to i32
  %mul435 = mul nsw i32 %conv434, 8
  %conv436 = trunc i32 %mul435 to i8
  %conv437 = sext i8 %conv436 to i32
  br label %cond.end.446

cond.false.438:                                   ; preds = %cond.true.426
  %65 = load i64, i64* %numargs, align 8
  %conv439 = trunc i64 %65 to i8
  %conv440 = zext i8 %conv439 to i32
  %mul441 = mul nsw i32 %conv440, 8
  %sub442 = sub nsw i32 %mul441, -128
  %conv443 = trunc i32 %sub442 to i8
  %conv444 = sext i8 %conv443 to i32
  %add445 = add nsw i32 %conv444, -128
  br label %cond.end.446

cond.end.446:                                     ; preds = %cond.false.438, %cond.true.432
  %cond447 = phi i32 [ %conv437, %cond.true.432 ], [ %add445, %cond.false.438 ]
  %conv448 = sext i32 %cond447 to i64
  store i64 %conv448, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then, label %lor.lhs.false.2161

cond.false.449:                                   ; preds = %lor.lhs.false.422
  %66 = load i64, i64* %numargs, align 8
  %conv450 = trunc i64 %66 to i8
  %conv451 = zext i8 %conv450 to i32
  %mul452 = mul nsw i32 %conv451, 8
  %cmp453 = icmp sle i32 %mul452, 127
  br i1 %cmp453, label %cond.true.455, label %cond.false.461

cond.true.455:                                    ; preds = %cond.false.449
  %67 = load i64, i64* %numargs, align 8
  %conv456 = trunc i64 %67 to i8
  %conv457 = zext i8 %conv456 to i32
  %mul458 = mul nsw i32 %conv457, 8
  %conv459 = trunc i32 %mul458 to i8
  %conv460 = sext i8 %conv459 to i32
  br label %cond.end.469

cond.false.461:                                   ; preds = %cond.false.449
  %68 = load i64, i64* %numargs, align 8
  %conv462 = trunc i64 %68 to i8
  %conv463 = zext i8 %conv462 to i32
  %mul464 = mul nsw i32 %conv463, 8
  %sub465 = sub nsw i32 %mul464, -128
  %conv466 = trunc i32 %sub465 to i8
  %conv467 = sext i8 %conv466 to i32
  %add468 = add nsw i32 %conv467, -128
  br label %cond.end.469

cond.end.469:                                     ; preds = %cond.false.461, %cond.true.455
  %cond470 = phi i32 [ %conv460, %cond.true.455 ], [ %add468, %cond.false.461 ]
  %conv471 = sext i32 %cond470 to i64
  store i64 %conv471, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then, label %lor.lhs.false.2161

cond.false.472:                                   ; preds = %do.body
  br i1 false, label %cond.true.473, label %cond.false.957

cond.true.473:                                    ; preds = %cond.false.472
  br i1 false, label %cond.true.474, label %cond.false.742

cond.true.474:                                    ; preds = %cond.true.473
  %69 = load i64, i64* %numargs, align 8
  %conv475 = trunc i64 %69 to i16
  %conv476 = sext i16 %conv475 to i32
  %add477 = add nsw i32 0, %conv476
  %mul478 = mul nsw i32 0, %add477
  %sub479 = sub nsw i32 %mul478, 1
  %cmp480 = icmp slt i32 %sub479, 0
  br i1 %cmp480, label %cond.true.482, label %cond.false.502

cond.true.482:                                    ; preds = %cond.true.474
  %70 = load i64, i64* %numargs, align 8
  %conv483 = trunc i64 %70 to i16
  %conv484 = sext i16 %conv483 to i32
  %add485 = add nsw i32 0, %conv484
  %mul486 = mul nsw i32 0, %add485
  %add487 = add nsw i32 %mul486, 0
  %neg488 = xor i32 %add487, -1
  %cmp489 = icmp eq i32 %neg488, -1
  %conv490 = zext i1 %cmp489 to i32
  %sub491 = sub nsw i32 0, %conv490
  %71 = load i64, i64* %numargs, align 8
  %conv492 = trunc i64 %71 to i16
  %conv493 = sext i16 %conv492 to i32
  %add494 = add nsw i32 0, %conv493
  %mul495 = mul nsw i32 0, %add494
  %add496 = add nsw i32 %mul495, 1
  %shl497 = shl i32 %add496, 30
  %sub498 = sub nsw i32 %shl497, 1
  %mul499 = mul nsw i32 %sub498, 2
  %add500 = add nsw i32 %mul499, 1
  %sub501 = sub nsw i32 %sub491, %add500
  br label %cond.end.508

cond.false.502:                                   ; preds = %cond.true.474
  %72 = load i64, i64* %numargs, align 8
  %conv503 = trunc i64 %72 to i16
  %conv504 = sext i16 %conv503 to i32
  %add505 = add nsw i32 0, %conv504
  %mul506 = mul nsw i32 0, %add505
  %add507 = add nsw i32 %mul506, 0
  br label %cond.end.508

cond.end.508:                                     ; preds = %cond.false.502, %cond.true.482
  %cond509 = phi i32 [ %sub501, %cond.true.482 ], [ %add507, %cond.false.502 ]
  %cmp510 = icmp eq i32 %cond509, 0
  br i1 %cmp510, label %land.lhs.true.512, label %lor.lhs.false.517

land.lhs.true.512:                                ; preds = %cond.end.508
  %73 = load i64, i64* %numargs, align 8
  %conv513 = trunc i64 %73 to i16
  %conv514 = sext i16 %conv513 to i32
  %cmp515 = icmp slt i32 %conv514, 0
  br i1 %cmp515, label %cond.true.696, label %lor.lhs.false.517

lor.lhs.false.517:                                ; preds = %land.lhs.true.512, %cond.end.508
  br i1 false, label %cond.true.518, label %cond.false.597

cond.true.518:                                    ; preds = %lor.lhs.false.517
  %74 = load i64, i64* %numargs, align 8
  %conv519 = trunc i64 %74 to i16
  %conv520 = sext i16 %conv519 to i32
  %cmp521 = icmp slt i32 %conv520, 0
  br i1 %cmp521, label %cond.true.523, label %cond.false.554

cond.true.523:                                    ; preds = %cond.true.518
  %75 = load i64, i64* %numargs, align 8
  %conv524 = trunc i64 %75 to i16
  %conv525 = sext i16 %conv524 to i32
  %76 = load i64, i64* %numargs, align 8
  %conv526 = trunc i64 %76 to i16
  %conv527 = sext i16 %conv526 to i32
  %add528 = add nsw i32 0, %conv527
  %mul529 = mul nsw i32 0, %add528
  %sub530 = sub nsw i32 %mul529, 1
  %cmp531 = icmp slt i32 %sub530, 0
  br i1 %cmp531, label %cond.true.533, label %cond.false.543

cond.true.533:                                    ; preds = %cond.true.523
  %77 = load i64, i64* %numargs, align 8
  %conv534 = trunc i64 %77 to i16
  %conv535 = sext i16 %conv534 to i32
  %add536 = add nsw i32 0, %conv535
  %mul537 = mul nsw i32 0, %add536
  %add538 = add nsw i32 %mul537, 1
  %shl539 = shl i32 %add538, 30
  %sub540 = sub nsw i32 %shl539, 1
  %mul541 = mul nsw i32 %sub540, 2
  %add542 = add nsw i32 %mul541, 1
  br label %cond.end.549

cond.false.543:                                   ; preds = %cond.true.523
  %78 = load i64, i64* %numargs, align 8
  %conv544 = trunc i64 %78 to i16
  %conv545 = sext i16 %conv544 to i32
  %add546 = add nsw i32 0, %conv545
  %mul547 = mul nsw i32 0, %add546
  %sub548 = sub nsw i32 %mul547, 1
  br label %cond.end.549

cond.end.549:                                     ; preds = %cond.false.543, %cond.true.533
  %cond550 = phi i32 [ %add542, %cond.true.533 ], [ %sub548, %cond.false.543 ]
  %div551 = sdiv i32 %cond550, 8
  %cmp552 = icmp slt i32 %conv525, %div551
  br i1 %cmp552, label %cond.true.696, label %lor.lhs.false.676

cond.false.554:                                   ; preds = %cond.true.518
  br i1 false, label %cond.true.555, label %cond.false.556

cond.true.555:                                    ; preds = %cond.false.554
  br i1 false, label %cond.true.696, label %lor.lhs.false.676

cond.false.556:                                   ; preds = %cond.false.554
  %79 = load i64, i64* %numargs, align 8
  %conv557 = trunc i64 %79 to i16
  %conv558 = sext i16 %conv557 to i32
  %add559 = add nsw i32 0, %conv558
  %mul560 = mul nsw i32 0, %add559
  %sub561 = sub nsw i32 %mul560, 1
  %cmp562 = icmp slt i32 %sub561, 0
  br i1 %cmp562, label %cond.true.564, label %cond.false.584

cond.true.564:                                    ; preds = %cond.false.556
  %80 = load i64, i64* %numargs, align 8
  %conv565 = trunc i64 %80 to i16
  %conv566 = sext i16 %conv565 to i32
  %add567 = add nsw i32 0, %conv566
  %mul568 = mul nsw i32 0, %add567
  %add569 = add nsw i32 %mul568, 0
  %neg570 = xor i32 %add569, -1
  %cmp571 = icmp eq i32 %neg570, -1
  %conv572 = zext i1 %cmp571 to i32
  %sub573 = sub nsw i32 0, %conv572
  %81 = load i64, i64* %numargs, align 8
  %conv574 = trunc i64 %81 to i16
  %conv575 = sext i16 %conv574 to i32
  %add576 = add nsw i32 0, %conv575
  %mul577 = mul nsw i32 0, %add576
  %add578 = add nsw i32 %mul577, 1
  %shl579 = shl i32 %add578, 30
  %sub580 = sub nsw i32 %shl579, 1
  %mul581 = mul nsw i32 %sub580, 2
  %add582 = add nsw i32 %mul581, 1
  %sub583 = sub nsw i32 %sub573, %add582
  br label %cond.end.590

cond.false.584:                                   ; preds = %cond.false.556
  %82 = load i64, i64* %numargs, align 8
  %conv585 = trunc i64 %82 to i16
  %conv586 = sext i16 %conv585 to i32
  %add587 = add nsw i32 0, %conv586
  %mul588 = mul nsw i32 0, %add587
  %add589 = add nsw i32 %mul588, 0
  br label %cond.end.590

cond.end.590:                                     ; preds = %cond.false.584, %cond.true.564
  %cond591 = phi i32 [ %sub583, %cond.true.564 ], [ %add589, %cond.false.584 ]
  %div592 = sdiv i32 %cond591, 8
  %83 = load i64, i64* %numargs, align 8
  %conv593 = trunc i64 %83 to i16
  %conv594 = sext i16 %conv593 to i32
  %cmp595 = icmp slt i32 %div592, %conv594
  br i1 %cmp595, label %cond.true.696, label %lor.lhs.false.676

cond.false.597:                                   ; preds = %lor.lhs.false.517
  br i1 false, label %cond.true.598, label %cond.false.599

cond.true.598:                                    ; preds = %cond.false.597
  br i1 false, label %cond.true.696, label %lor.lhs.false.676

cond.false.599:                                   ; preds = %cond.false.597
  %84 = load i64, i64* %numargs, align 8
  %conv600 = trunc i64 %84 to i16
  %conv601 = sext i16 %conv600 to i32
  %cmp602 = icmp slt i32 %conv601, 0
  br i1 %cmp602, label %cond.true.604, label %cond.false.645

cond.true.604:                                    ; preds = %cond.false.599
  %85 = load i64, i64* %numargs, align 8
  %conv605 = trunc i64 %85 to i16
  %conv606 = sext i16 %conv605 to i32
  %86 = load i64, i64* %numargs, align 8
  %conv607 = trunc i64 %86 to i16
  %conv608 = sext i16 %conv607 to i32
  %add609 = add nsw i32 0, %conv608
  %mul610 = mul nsw i32 0, %add609
  %sub611 = sub nsw i32 %mul610, 1
  %cmp612 = icmp slt i32 %sub611, 0
  br i1 %cmp612, label %cond.true.614, label %cond.false.634

cond.true.614:                                    ; preds = %cond.true.604
  %87 = load i64, i64* %numargs, align 8
  %conv615 = trunc i64 %87 to i16
  %conv616 = sext i16 %conv615 to i32
  %add617 = add nsw i32 0, %conv616
  %mul618 = mul nsw i32 0, %add617
  %add619 = add nsw i32 %mul618, 0
  %neg620 = xor i32 %add619, -1
  %cmp621 = icmp eq i32 %neg620, -1
  %conv622 = zext i1 %cmp621 to i32
  %sub623 = sub nsw i32 0, %conv622
  %88 = load i64, i64* %numargs, align 8
  %conv624 = trunc i64 %88 to i16
  %conv625 = sext i16 %conv624 to i32
  %add626 = add nsw i32 0, %conv625
  %mul627 = mul nsw i32 0, %add626
  %add628 = add nsw i32 %mul627, 1
  %shl629 = shl i32 %add628, 30
  %sub630 = sub nsw i32 %shl629, 1
  %mul631 = mul nsw i32 %sub630, 2
  %add632 = add nsw i32 %mul631, 1
  %sub633 = sub nsw i32 %sub623, %add632
  br label %cond.end.640

cond.false.634:                                   ; preds = %cond.true.604
  %89 = load i64, i64* %numargs, align 8
  %conv635 = trunc i64 %89 to i16
  %conv636 = sext i16 %conv635 to i32
  %add637 = add nsw i32 0, %conv636
  %mul638 = mul nsw i32 0, %add637
  %add639 = add nsw i32 %mul638, 0
  br label %cond.end.640

cond.end.640:                                     ; preds = %cond.false.634, %cond.true.614
  %cond641 = phi i32 [ %sub633, %cond.true.614 ], [ %add639, %cond.false.634 ]
  %div642 = sdiv i32 %cond641, 8
  %cmp643 = icmp slt i32 %conv606, %div642
  br i1 %cmp643, label %cond.true.696, label %lor.lhs.false.676

cond.false.645:                                   ; preds = %cond.false.599
  %90 = load i64, i64* %numargs, align 8
  %conv646 = trunc i64 %90 to i16
  %conv647 = sext i16 %conv646 to i32
  %add648 = add nsw i32 0, %conv647
  %mul649 = mul nsw i32 0, %add648
  %sub650 = sub nsw i32 %mul649, 1
  %cmp651 = icmp slt i32 %sub650, 0
  br i1 %cmp651, label %cond.true.653, label %cond.false.663

cond.true.653:                                    ; preds = %cond.false.645
  %91 = load i64, i64* %numargs, align 8
  %conv654 = trunc i64 %91 to i16
  %conv655 = sext i16 %conv654 to i32
  %add656 = add nsw i32 0, %conv655
  %mul657 = mul nsw i32 0, %add656
  %add658 = add nsw i32 %mul657, 1
  %shl659 = shl i32 %add658, 30
  %sub660 = sub nsw i32 %shl659, 1
  %mul661 = mul nsw i32 %sub660, 2
  %add662 = add nsw i32 %mul661, 1
  br label %cond.end.669

cond.false.663:                                   ; preds = %cond.false.645
  %92 = load i64, i64* %numargs, align 8
  %conv664 = trunc i64 %92 to i16
  %conv665 = sext i16 %conv664 to i32
  %add666 = add nsw i32 0, %conv665
  %mul667 = mul nsw i32 0, %add666
  %sub668 = sub nsw i32 %mul667, 1
  br label %cond.end.669

cond.end.669:                                     ; preds = %cond.false.663, %cond.true.653
  %cond670 = phi i32 [ %add662, %cond.true.653 ], [ %sub668, %cond.false.663 ]
  %div671 = sdiv i32 %cond670, 8
  %93 = load i64, i64* %numargs, align 8
  %conv672 = trunc i64 %93 to i16
  %conv673 = sext i16 %conv672 to i32
  %cmp674 = icmp slt i32 %div671, %conv673
  br i1 %cmp674, label %cond.true.696, label %lor.lhs.false.676

lor.lhs.false.676:                                ; preds = %cond.end.669, %cond.end.640, %cond.true.598, %cond.end.590, %cond.true.555, %cond.end.549
  %94 = load i64, i64* %numargs, align 8
  %conv677 = trunc i64 %94 to i16
  %conv678 = sext i16 %conv677 to i32
  %mul679 = mul nsw i32 %conv678, 8
  %mul680 = mul nsw i32 0, %mul679
  %sub681 = sub nsw i32 %mul680, 1
  %cmp682 = icmp slt i32 %sub681, 0
  br i1 %cmp682, label %land.lhs.true.684, label %lor.lhs.false.690

land.lhs.true.684:                                ; preds = %lor.lhs.false.676
  %95 = load i64, i64* %numargs, align 8
  %conv685 = trunc i64 %95 to i16
  %conv686 = sext i16 %conv685 to i32
  %mul687 = mul nsw i32 %conv686, 8
  %cmp688 = icmp slt i32 %mul687, -32768
  br i1 %cmp688, label %cond.true.696, label %lor.lhs.false.690

lor.lhs.false.690:                                ; preds = %land.lhs.true.684, %lor.lhs.false.676
  %96 = load i64, i64* %numargs, align 8
  %conv691 = trunc i64 %96 to i16
  %conv692 = sext i16 %conv691 to i32
  %mul693 = mul nsw i32 %conv692, 8
  %cmp694 = icmp slt i32 32767, %mul693
  br i1 %cmp694, label %cond.true.696, label %cond.false.719

cond.true.696:                                    ; preds = %lor.lhs.false.690, %land.lhs.true.684, %cond.end.669, %cond.end.640, %cond.true.598, %cond.end.590, %cond.true.555, %cond.end.549, %land.lhs.true.512
  %97 = load i64, i64* %numargs, align 8
  %conv697 = trunc i64 %97 to i16
  %conv698 = zext i16 %conv697 to i32
  %mul699 = mul nsw i32 %conv698, 8
  %cmp700 = icmp sle i32 %mul699, 32767
  br i1 %cmp700, label %cond.true.702, label %cond.false.708

cond.true.702:                                    ; preds = %cond.true.696
  %98 = load i64, i64* %numargs, align 8
  %conv703 = trunc i64 %98 to i16
  %conv704 = zext i16 %conv703 to i32
  %mul705 = mul nsw i32 %conv704, 8
  %conv706 = trunc i32 %mul705 to i16
  %conv707 = sext i16 %conv706 to i32
  br label %cond.end.716

cond.false.708:                                   ; preds = %cond.true.696
  %99 = load i64, i64* %numargs, align 8
  %conv709 = trunc i64 %99 to i16
  %conv710 = zext i16 %conv709 to i32
  %mul711 = mul nsw i32 %conv710, 8
  %sub712 = sub nsw i32 %mul711, -32768
  %conv713 = trunc i32 %sub712 to i16
  %conv714 = sext i16 %conv713 to i32
  %add715 = add nsw i32 %conv714, -32768
  br label %cond.end.716

cond.end.716:                                     ; preds = %cond.false.708, %cond.true.702
  %cond717 = phi i32 [ %conv707, %cond.true.702 ], [ %add715, %cond.false.708 ]
  %conv718 = sext i32 %cond717 to i64
  store i64 %conv718, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then, label %lor.lhs.false.2161

cond.false.719:                                   ; preds = %lor.lhs.false.690
  %100 = load i64, i64* %numargs, align 8
  %conv720 = trunc i64 %100 to i16
  %conv721 = zext i16 %conv720 to i32
  %mul722 = mul nsw i32 %conv721, 8
  %cmp723 = icmp sle i32 %mul722, 32767
  br i1 %cmp723, label %cond.true.725, label %cond.false.731

cond.true.725:                                    ; preds = %cond.false.719
  %101 = load i64, i64* %numargs, align 8
  %conv726 = trunc i64 %101 to i16
  %conv727 = zext i16 %conv726 to i32
  %mul728 = mul nsw i32 %conv727, 8
  %conv729 = trunc i32 %mul728 to i16
  %conv730 = sext i16 %conv729 to i32
  br label %cond.end.739

cond.false.731:                                   ; preds = %cond.false.719
  %102 = load i64, i64* %numargs, align 8
  %conv732 = trunc i64 %102 to i16
  %conv733 = zext i16 %conv732 to i32
  %mul734 = mul nsw i32 %conv733, 8
  %sub735 = sub nsw i32 %mul734, -32768
  %conv736 = trunc i32 %sub735 to i16
  %conv737 = sext i16 %conv736 to i32
  %add738 = add nsw i32 %conv737, -32768
  br label %cond.end.739

cond.end.739:                                     ; preds = %cond.false.731, %cond.true.725
  %cond740 = phi i32 [ %conv730, %cond.true.725 ], [ %add738, %cond.false.731 ]
  %conv741 = sext i32 %cond740 to i64
  store i64 %conv741, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then, label %lor.lhs.false.2161

cond.false.742:                                   ; preds = %cond.true.473
  %103 = load i64, i64* %numargs, align 8
  %add743 = add nsw i64 0, %103
  %mul744 = mul nsw i64 0, %add743
  %sub745 = sub nsw i64 %mul744, 1
  %cmp746 = icmp slt i64 %sub745, 0
  br i1 %cmp746, label %cond.true.748, label %cond.false.765

cond.true.748:                                    ; preds = %cond.false.742
  %104 = load i64, i64* %numargs, align 8
  %add749 = add nsw i64 0, %104
  %mul750 = mul nsw i64 0, %add749
  %add751 = add nsw i64 %mul750, 0
  %neg752 = xor i64 %add751, -1
  %cmp753 = icmp eq i64 %neg752, -1
  %conv754 = zext i1 %cmp753 to i32
  %sub755 = sub nsw i32 0, %conv754
  %conv756 = sext i32 %sub755 to i64
  %105 = load i64, i64* %numargs, align 8
  %add757 = add nsw i64 0, %105
  %mul758 = mul nsw i64 0, %add757
  %add759 = add nsw i64 %mul758, 1
  %shl760 = shl i64 %add759, 62
  %sub761 = sub nsw i64 %shl760, 1
  %mul762 = mul nsw i64 %sub761, 2
  %add763 = add nsw i64 %mul762, 1
  %sub764 = sub nsw i64 %conv756, %add763
  br label %cond.end.769

cond.false.765:                                   ; preds = %cond.false.742
  %106 = load i64, i64* %numargs, align 8
  %add766 = add nsw i64 0, %106
  %mul767 = mul nsw i64 0, %add766
  %add768 = add nsw i64 %mul767, 0
  br label %cond.end.769

cond.end.769:                                     ; preds = %cond.false.765, %cond.true.748
  %cond770 = phi i64 [ %sub764, %cond.true.748 ], [ %add768, %cond.false.765 ]
  %cmp771 = icmp eq i64 %cond770, 0
  br i1 %cmp771, label %land.lhs.true.773, label %lor.lhs.false.776

land.lhs.true.773:                                ; preds = %cond.end.769
  %107 = load i64, i64* %numargs, align 8
  %cmp774 = icmp slt i64 %107, 0
  br i1 %cmp774, label %cond.true.911, label %lor.lhs.false.776

lor.lhs.false.776:                                ; preds = %land.lhs.true.773, %cond.end.769
  br i1 false, label %cond.true.777, label %cond.false.837

cond.true.777:                                    ; preds = %lor.lhs.false.776
  %108 = load i64, i64* %numargs, align 8
  %cmp778 = icmp slt i64 %108, 0
  br i1 %cmp778, label %cond.true.780, label %cond.false.803

cond.true.780:                                    ; preds = %cond.true.777
  %109 = load i64, i64* %numargs, align 8
  %110 = load i64, i64* %numargs, align 8
  %add781 = add nsw i64 0, %110
  %mul782 = mul nsw i64 0, %add781
  %sub783 = sub nsw i64 %mul782, 1
  %cmp784 = icmp slt i64 %sub783, 0
  br i1 %cmp784, label %cond.true.786, label %cond.false.794

cond.true.786:                                    ; preds = %cond.true.780
  %111 = load i64, i64* %numargs, align 8
  %add787 = add nsw i64 0, %111
  %mul788 = mul nsw i64 0, %add787
  %add789 = add nsw i64 %mul788, 1
  %shl790 = shl i64 %add789, 62
  %sub791 = sub nsw i64 %shl790, 1
  %mul792 = mul nsw i64 %sub791, 2
  %add793 = add nsw i64 %mul792, 1
  br label %cond.end.798

cond.false.794:                                   ; preds = %cond.true.780
  %112 = load i64, i64* %numargs, align 8
  %add795 = add nsw i64 0, %112
  %mul796 = mul nsw i64 0, %add795
  %sub797 = sub nsw i64 %mul796, 1
  br label %cond.end.798

cond.end.798:                                     ; preds = %cond.false.794, %cond.true.786
  %cond799 = phi i64 [ %add793, %cond.true.786 ], [ %sub797, %cond.false.794 ]
  %div800 = sdiv i64 %cond799, 8
  %cmp801 = icmp slt i64 %109, %div800
  br i1 %cmp801, label %cond.true.911, label %lor.lhs.false.897

cond.false.803:                                   ; preds = %cond.true.777
  br i1 false, label %cond.true.804, label %cond.false.805

cond.true.804:                                    ; preds = %cond.false.803
  br i1 false, label %cond.true.911, label %lor.lhs.false.897

cond.false.805:                                   ; preds = %cond.false.803
  %113 = load i64, i64* %numargs, align 8
  %add806 = add nsw i64 0, %113
  %mul807 = mul nsw i64 0, %add806
  %sub808 = sub nsw i64 %mul807, 1
  %cmp809 = icmp slt i64 %sub808, 0
  br i1 %cmp809, label %cond.true.811, label %cond.false.828

cond.true.811:                                    ; preds = %cond.false.805
  %114 = load i64, i64* %numargs, align 8
  %add812 = add nsw i64 0, %114
  %mul813 = mul nsw i64 0, %add812
  %add814 = add nsw i64 %mul813, 0
  %neg815 = xor i64 %add814, -1
  %cmp816 = icmp eq i64 %neg815, -1
  %conv817 = zext i1 %cmp816 to i32
  %sub818 = sub nsw i32 0, %conv817
  %conv819 = sext i32 %sub818 to i64
  %115 = load i64, i64* %numargs, align 8
  %add820 = add nsw i64 0, %115
  %mul821 = mul nsw i64 0, %add820
  %add822 = add nsw i64 %mul821, 1
  %shl823 = shl i64 %add822, 62
  %sub824 = sub nsw i64 %shl823, 1
  %mul825 = mul nsw i64 %sub824, 2
  %add826 = add nsw i64 %mul825, 1
  %sub827 = sub nsw i64 %conv819, %add826
  br label %cond.end.832

cond.false.828:                                   ; preds = %cond.false.805
  %116 = load i64, i64* %numargs, align 8
  %add829 = add nsw i64 0, %116
  %mul830 = mul nsw i64 0, %add829
  %add831 = add nsw i64 %mul830, 0
  br label %cond.end.832

cond.end.832:                                     ; preds = %cond.false.828, %cond.true.811
  %cond833 = phi i64 [ %sub827, %cond.true.811 ], [ %add831, %cond.false.828 ]
  %div834 = sdiv i64 %cond833, 8
  %117 = load i64, i64* %numargs, align 8
  %cmp835 = icmp slt i64 %div834, %117
  br i1 %cmp835, label %cond.true.911, label %lor.lhs.false.897

cond.false.837:                                   ; preds = %lor.lhs.false.776
  br i1 false, label %cond.true.838, label %cond.false.839

cond.true.838:                                    ; preds = %cond.false.837
  br i1 false, label %cond.true.911, label %lor.lhs.false.897

cond.false.839:                                   ; preds = %cond.false.837
  %118 = load i64, i64* %numargs, align 8
  %cmp840 = icmp slt i64 %118, 0
  br i1 %cmp840, label %cond.true.842, label %cond.false.874

cond.true.842:                                    ; preds = %cond.false.839
  %119 = load i64, i64* %numargs, align 8
  %120 = load i64, i64* %numargs, align 8
  %add843 = add nsw i64 0, %120
  %mul844 = mul nsw i64 0, %add843
  %sub845 = sub nsw i64 %mul844, 1
  %cmp846 = icmp slt i64 %sub845, 0
  br i1 %cmp846, label %cond.true.848, label %cond.false.865

cond.true.848:                                    ; preds = %cond.true.842
  %121 = load i64, i64* %numargs, align 8
  %add849 = add nsw i64 0, %121
  %mul850 = mul nsw i64 0, %add849
  %add851 = add nsw i64 %mul850, 0
  %neg852 = xor i64 %add851, -1
  %cmp853 = icmp eq i64 %neg852, -1
  %conv854 = zext i1 %cmp853 to i32
  %sub855 = sub nsw i32 0, %conv854
  %conv856 = sext i32 %sub855 to i64
  %122 = load i64, i64* %numargs, align 8
  %add857 = add nsw i64 0, %122
  %mul858 = mul nsw i64 0, %add857
  %add859 = add nsw i64 %mul858, 1
  %shl860 = shl i64 %add859, 62
  %sub861 = sub nsw i64 %shl860, 1
  %mul862 = mul nsw i64 %sub861, 2
  %add863 = add nsw i64 %mul862, 1
  %sub864 = sub nsw i64 %conv856, %add863
  br label %cond.end.869

cond.false.865:                                   ; preds = %cond.true.842
  %123 = load i64, i64* %numargs, align 8
  %add866 = add nsw i64 0, %123
  %mul867 = mul nsw i64 0, %add866
  %add868 = add nsw i64 %mul867, 0
  br label %cond.end.869

cond.end.869:                                     ; preds = %cond.false.865, %cond.true.848
  %cond870 = phi i64 [ %sub864, %cond.true.848 ], [ %add868, %cond.false.865 ]
  %div871 = sdiv i64 %cond870, 8
  %cmp872 = icmp slt i64 %119, %div871
  br i1 %cmp872, label %cond.true.911, label %lor.lhs.false.897

cond.false.874:                                   ; preds = %cond.false.839
  %124 = load i64, i64* %numargs, align 8
  %add875 = add nsw i64 0, %124
  %mul876 = mul nsw i64 0, %add875
  %sub877 = sub nsw i64 %mul876, 1
  %cmp878 = icmp slt i64 %sub877, 0
  br i1 %cmp878, label %cond.true.880, label %cond.false.888

cond.true.880:                                    ; preds = %cond.false.874
  %125 = load i64, i64* %numargs, align 8
  %add881 = add nsw i64 0, %125
  %mul882 = mul nsw i64 0, %add881
  %add883 = add nsw i64 %mul882, 1
  %shl884 = shl i64 %add883, 62
  %sub885 = sub nsw i64 %shl884, 1
  %mul886 = mul nsw i64 %sub885, 2
  %add887 = add nsw i64 %mul886, 1
  br label %cond.end.892

cond.false.888:                                   ; preds = %cond.false.874
  %126 = load i64, i64* %numargs, align 8
  %add889 = add nsw i64 0, %126
  %mul890 = mul nsw i64 0, %add889
  %sub891 = sub nsw i64 %mul890, 1
  br label %cond.end.892

cond.end.892:                                     ; preds = %cond.false.888, %cond.true.880
  %cond893 = phi i64 [ %add887, %cond.true.880 ], [ %sub891, %cond.false.888 ]
  %div894 = sdiv i64 %cond893, 8
  %127 = load i64, i64* %numargs, align 8
  %cmp895 = icmp slt i64 %div894, %127
  br i1 %cmp895, label %cond.true.911, label %lor.lhs.false.897

lor.lhs.false.897:                                ; preds = %cond.end.892, %cond.end.869, %cond.true.838, %cond.end.832, %cond.true.804, %cond.end.798
  %128 = load i64, i64* %numargs, align 8
  %mul898 = mul nsw i64 %128, 8
  %mul899 = mul nsw i64 0, %mul898
  %sub900 = sub nsw i64 %mul899, 1
  %cmp901 = icmp slt i64 %sub900, 0
  br i1 %cmp901, label %land.lhs.true.903, label %lor.lhs.false.907

land.lhs.true.903:                                ; preds = %lor.lhs.false.897
  %129 = load i64, i64* %numargs, align 8
  %mul904 = mul nsw i64 %129, 8
  %cmp905 = icmp slt i64 %mul904, -32768
  br i1 %cmp905, label %cond.true.911, label %lor.lhs.false.907

lor.lhs.false.907:                                ; preds = %land.lhs.true.903, %lor.lhs.false.897
  %130 = load i64, i64* %numargs, align 8
  %mul908 = mul nsw i64 %130, 8
  %cmp909 = icmp slt i64 32767, %mul908
  br i1 %cmp909, label %cond.true.911, label %cond.false.934

cond.true.911:                                    ; preds = %lor.lhs.false.907, %land.lhs.true.903, %cond.end.892, %cond.end.869, %cond.true.838, %cond.end.832, %cond.true.804, %cond.end.798, %land.lhs.true.773
  %131 = load i64, i64* %numargs, align 8
  %conv912 = trunc i64 %131 to i16
  %conv913 = zext i16 %conv912 to i32
  %mul914 = mul nsw i32 %conv913, 8
  %cmp915 = icmp sle i32 %mul914, 32767
  br i1 %cmp915, label %cond.true.917, label %cond.false.923

cond.true.917:                                    ; preds = %cond.true.911
  %132 = load i64, i64* %numargs, align 8
  %conv918 = trunc i64 %132 to i16
  %conv919 = zext i16 %conv918 to i32
  %mul920 = mul nsw i32 %conv919, 8
  %conv921 = trunc i32 %mul920 to i16
  %conv922 = sext i16 %conv921 to i32
  br label %cond.end.931

cond.false.923:                                   ; preds = %cond.true.911
  %133 = load i64, i64* %numargs, align 8
  %conv924 = trunc i64 %133 to i16
  %conv925 = zext i16 %conv924 to i32
  %mul926 = mul nsw i32 %conv925, 8
  %sub927 = sub nsw i32 %mul926, -32768
  %conv928 = trunc i32 %sub927 to i16
  %conv929 = sext i16 %conv928 to i32
  %add930 = add nsw i32 %conv929, -32768
  br label %cond.end.931

cond.end.931:                                     ; preds = %cond.false.923, %cond.true.917
  %cond932 = phi i32 [ %conv922, %cond.true.917 ], [ %add930, %cond.false.923 ]
  %conv933 = sext i32 %cond932 to i64
  store i64 %conv933, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then, label %lor.lhs.false.2161

cond.false.934:                                   ; preds = %lor.lhs.false.907
  %134 = load i64, i64* %numargs, align 8
  %conv935 = trunc i64 %134 to i16
  %conv936 = zext i16 %conv935 to i32
  %mul937 = mul nsw i32 %conv936, 8
  %cmp938 = icmp sle i32 %mul937, 32767
  br i1 %cmp938, label %cond.true.940, label %cond.false.946

cond.true.940:                                    ; preds = %cond.false.934
  %135 = load i64, i64* %numargs, align 8
  %conv941 = trunc i64 %135 to i16
  %conv942 = zext i16 %conv941 to i32
  %mul943 = mul nsw i32 %conv942, 8
  %conv944 = trunc i32 %mul943 to i16
  %conv945 = sext i16 %conv944 to i32
  br label %cond.end.954

cond.false.946:                                   ; preds = %cond.false.934
  %136 = load i64, i64* %numargs, align 8
  %conv947 = trunc i64 %136 to i16
  %conv948 = zext i16 %conv947 to i32
  %mul949 = mul nsw i32 %conv948, 8
  %sub950 = sub nsw i32 %mul949, -32768
  %conv951 = trunc i32 %sub950 to i16
  %conv952 = sext i16 %conv951 to i32
  %add953 = add nsw i32 %conv952, -32768
  br label %cond.end.954

cond.end.954:                                     ; preds = %cond.false.946, %cond.true.940
  %cond955 = phi i32 [ %conv945, %cond.true.940 ], [ %add953, %cond.false.946 ]
  %conv956 = sext i32 %cond955 to i64
  store i64 %conv956, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then, label %lor.lhs.false.2161

cond.false.957:                                   ; preds = %cond.false.472
  br i1 false, label %cond.true.958, label %cond.false.1386

cond.true.958:                                    ; preds = %cond.false.957
  br i1 false, label %cond.true.959, label %cond.false.1185

cond.true.959:                                    ; preds = %cond.true.958
  %137 = load i64, i64* %numargs, align 8
  %conv960 = trunc i64 %137 to i32
  %add961 = add nsw i32 0, %conv960
  %mul962 = mul nsw i32 0, %add961
  %sub963 = sub nsw i32 %mul962, 1
  %cmp964 = icmp slt i32 %sub963, 0
  br i1 %cmp964, label %cond.true.966, label %cond.false.984

cond.true.966:                                    ; preds = %cond.true.959
  %138 = load i64, i64* %numargs, align 8
  %conv967 = trunc i64 %138 to i32
  %add968 = add nsw i32 0, %conv967
  %mul969 = mul nsw i32 0, %add968
  %add970 = add nsw i32 %mul969, 0
  %neg971 = xor i32 %add970, -1
  %cmp972 = icmp eq i32 %neg971, -1
  %conv973 = zext i1 %cmp972 to i32
  %sub974 = sub nsw i32 0, %conv973
  %139 = load i64, i64* %numargs, align 8
  %conv975 = trunc i64 %139 to i32
  %add976 = add nsw i32 0, %conv975
  %mul977 = mul nsw i32 0, %add976
  %add978 = add nsw i32 %mul977, 1
  %shl979 = shl i32 %add978, 30
  %sub980 = sub nsw i32 %shl979, 1
  %mul981 = mul nsw i32 %sub980, 2
  %add982 = add nsw i32 %mul981, 1
  %sub983 = sub nsw i32 %sub974, %add982
  br label %cond.end.989

cond.false.984:                                   ; preds = %cond.true.959
  %140 = load i64, i64* %numargs, align 8
  %conv985 = trunc i64 %140 to i32
  %add986 = add nsw i32 0, %conv985
  %mul987 = mul nsw i32 0, %add986
  %add988 = add nsw i32 %mul987, 0
  br label %cond.end.989

cond.end.989:                                     ; preds = %cond.false.984, %cond.true.966
  %cond990 = phi i32 [ %sub983, %cond.true.966 ], [ %add988, %cond.false.984 ]
  %cmp991 = icmp eq i32 %cond990, 0
  br i1 %cmp991, label %land.lhs.true.993, label %lor.lhs.false.997

land.lhs.true.993:                                ; preds = %cond.end.989
  %141 = load i64, i64* %numargs, align 8
  %conv994 = trunc i64 %141 to i32
  %cmp995 = icmp slt i32 %conv994, 0
  br i1 %cmp995, label %cond.true.1153, label %lor.lhs.false.997

lor.lhs.false.997:                                ; preds = %land.lhs.true.993, %cond.end.989
  br i1 false, label %cond.true.998, label %cond.false.1067

cond.true.998:                                    ; preds = %lor.lhs.false.997
  %142 = load i64, i64* %numargs, align 8
  %conv999 = trunc i64 %142 to i32
  %cmp1000 = icmp slt i32 %conv999, 0
  br i1 %cmp1000, label %cond.true.1002, label %cond.false.1029

cond.true.1002:                                   ; preds = %cond.true.998
  %143 = load i64, i64* %numargs, align 8
  %conv1003 = trunc i64 %143 to i32
  %144 = load i64, i64* %numargs, align 8
  %conv1004 = trunc i64 %144 to i32
  %add1005 = add nsw i32 0, %conv1004
  %mul1006 = mul nsw i32 0, %add1005
  %sub1007 = sub nsw i32 %mul1006, 1
  %cmp1008 = icmp slt i32 %sub1007, 0
  br i1 %cmp1008, label %cond.true.1010, label %cond.false.1019

cond.true.1010:                                   ; preds = %cond.true.1002
  %145 = load i64, i64* %numargs, align 8
  %conv1011 = trunc i64 %145 to i32
  %add1012 = add nsw i32 0, %conv1011
  %mul1013 = mul nsw i32 0, %add1012
  %add1014 = add nsw i32 %mul1013, 1
  %shl1015 = shl i32 %add1014, 30
  %sub1016 = sub nsw i32 %shl1015, 1
  %mul1017 = mul nsw i32 %sub1016, 2
  %add1018 = add nsw i32 %mul1017, 1
  br label %cond.end.1024

cond.false.1019:                                  ; preds = %cond.true.1002
  %146 = load i64, i64* %numargs, align 8
  %conv1020 = trunc i64 %146 to i32
  %add1021 = add nsw i32 0, %conv1020
  %mul1022 = mul nsw i32 0, %add1021
  %sub1023 = sub nsw i32 %mul1022, 1
  br label %cond.end.1024

cond.end.1024:                                    ; preds = %cond.false.1019, %cond.true.1010
  %cond1025 = phi i32 [ %add1018, %cond.true.1010 ], [ %sub1023, %cond.false.1019 ]
  %div1026 = sdiv i32 %cond1025, 8
  %cmp1027 = icmp slt i32 %conv1003, %div1026
  br i1 %cmp1027, label %cond.true.1153, label %lor.lhs.false.1136

cond.false.1029:                                  ; preds = %cond.true.998
  br i1 false, label %cond.true.1030, label %cond.false.1031

cond.true.1030:                                   ; preds = %cond.false.1029
  br i1 false, label %cond.true.1153, label %lor.lhs.false.1136

cond.false.1031:                                  ; preds = %cond.false.1029
  %147 = load i64, i64* %numargs, align 8
  %conv1032 = trunc i64 %147 to i32
  %add1033 = add nsw i32 0, %conv1032
  %mul1034 = mul nsw i32 0, %add1033
  %sub1035 = sub nsw i32 %mul1034, 1
  %cmp1036 = icmp slt i32 %sub1035, 0
  br i1 %cmp1036, label %cond.true.1038, label %cond.false.1056

cond.true.1038:                                   ; preds = %cond.false.1031
  %148 = load i64, i64* %numargs, align 8
  %conv1039 = trunc i64 %148 to i32
  %add1040 = add nsw i32 0, %conv1039
  %mul1041 = mul nsw i32 0, %add1040
  %add1042 = add nsw i32 %mul1041, 0
  %neg1043 = xor i32 %add1042, -1
  %cmp1044 = icmp eq i32 %neg1043, -1
  %conv1045 = zext i1 %cmp1044 to i32
  %sub1046 = sub nsw i32 0, %conv1045
  %149 = load i64, i64* %numargs, align 8
  %conv1047 = trunc i64 %149 to i32
  %add1048 = add nsw i32 0, %conv1047
  %mul1049 = mul nsw i32 0, %add1048
  %add1050 = add nsw i32 %mul1049, 1
  %shl1051 = shl i32 %add1050, 30
  %sub1052 = sub nsw i32 %shl1051, 1
  %mul1053 = mul nsw i32 %sub1052, 2
  %add1054 = add nsw i32 %mul1053, 1
  %sub1055 = sub nsw i32 %sub1046, %add1054
  br label %cond.end.1061

cond.false.1056:                                  ; preds = %cond.false.1031
  %150 = load i64, i64* %numargs, align 8
  %conv1057 = trunc i64 %150 to i32
  %add1058 = add nsw i32 0, %conv1057
  %mul1059 = mul nsw i32 0, %add1058
  %add1060 = add nsw i32 %mul1059, 0
  br label %cond.end.1061

cond.end.1061:                                    ; preds = %cond.false.1056, %cond.true.1038
  %cond1062 = phi i32 [ %sub1055, %cond.true.1038 ], [ %add1060, %cond.false.1056 ]
  %div1063 = sdiv i32 %cond1062, 8
  %151 = load i64, i64* %numargs, align 8
  %conv1064 = trunc i64 %151 to i32
  %cmp1065 = icmp slt i32 %div1063, %conv1064
  br i1 %cmp1065, label %cond.true.1153, label %lor.lhs.false.1136

cond.false.1067:                                  ; preds = %lor.lhs.false.997
  br i1 false, label %cond.true.1068, label %cond.false.1069

cond.true.1068:                                   ; preds = %cond.false.1067
  br i1 false, label %cond.true.1153, label %lor.lhs.false.1136

cond.false.1069:                                  ; preds = %cond.false.1067
  %152 = load i64, i64* %numargs, align 8
  %conv1070 = trunc i64 %152 to i32
  %cmp1071 = icmp slt i32 %conv1070, 0
  br i1 %cmp1071, label %cond.true.1073, label %cond.false.1109

cond.true.1073:                                   ; preds = %cond.false.1069
  %153 = load i64, i64* %numargs, align 8
  %conv1074 = trunc i64 %153 to i32
  %154 = load i64, i64* %numargs, align 8
  %conv1075 = trunc i64 %154 to i32
  %add1076 = add nsw i32 0, %conv1075
  %mul1077 = mul nsw i32 0, %add1076
  %sub1078 = sub nsw i32 %mul1077, 1
  %cmp1079 = icmp slt i32 %sub1078, 0
  br i1 %cmp1079, label %cond.true.1081, label %cond.false.1099

cond.true.1081:                                   ; preds = %cond.true.1073
  %155 = load i64, i64* %numargs, align 8
  %conv1082 = trunc i64 %155 to i32
  %add1083 = add nsw i32 0, %conv1082
  %mul1084 = mul nsw i32 0, %add1083
  %add1085 = add nsw i32 %mul1084, 0
  %neg1086 = xor i32 %add1085, -1
  %cmp1087 = icmp eq i32 %neg1086, -1
  %conv1088 = zext i1 %cmp1087 to i32
  %sub1089 = sub nsw i32 0, %conv1088
  %156 = load i64, i64* %numargs, align 8
  %conv1090 = trunc i64 %156 to i32
  %add1091 = add nsw i32 0, %conv1090
  %mul1092 = mul nsw i32 0, %add1091
  %add1093 = add nsw i32 %mul1092, 1
  %shl1094 = shl i32 %add1093, 30
  %sub1095 = sub nsw i32 %shl1094, 1
  %mul1096 = mul nsw i32 %sub1095, 2
  %add1097 = add nsw i32 %mul1096, 1
  %sub1098 = sub nsw i32 %sub1089, %add1097
  br label %cond.end.1104

cond.false.1099:                                  ; preds = %cond.true.1073
  %157 = load i64, i64* %numargs, align 8
  %conv1100 = trunc i64 %157 to i32
  %add1101 = add nsw i32 0, %conv1100
  %mul1102 = mul nsw i32 0, %add1101
  %add1103 = add nsw i32 %mul1102, 0
  br label %cond.end.1104

cond.end.1104:                                    ; preds = %cond.false.1099, %cond.true.1081
  %cond1105 = phi i32 [ %sub1098, %cond.true.1081 ], [ %add1103, %cond.false.1099 ]
  %div1106 = sdiv i32 %cond1105, 8
  %cmp1107 = icmp slt i32 %conv1074, %div1106
  br i1 %cmp1107, label %cond.true.1153, label %lor.lhs.false.1136

cond.false.1109:                                  ; preds = %cond.false.1069
  %158 = load i64, i64* %numargs, align 8
  %conv1110 = trunc i64 %158 to i32
  %add1111 = add nsw i32 0, %conv1110
  %mul1112 = mul nsw i32 0, %add1111
  %sub1113 = sub nsw i32 %mul1112, 1
  %cmp1114 = icmp slt i32 %sub1113, 0
  br i1 %cmp1114, label %cond.true.1116, label %cond.false.1125

cond.true.1116:                                   ; preds = %cond.false.1109
  %159 = load i64, i64* %numargs, align 8
  %conv1117 = trunc i64 %159 to i32
  %add1118 = add nsw i32 0, %conv1117
  %mul1119 = mul nsw i32 0, %add1118
  %add1120 = add nsw i32 %mul1119, 1
  %shl1121 = shl i32 %add1120, 30
  %sub1122 = sub nsw i32 %shl1121, 1
  %mul1123 = mul nsw i32 %sub1122, 2
  %add1124 = add nsw i32 %mul1123, 1
  br label %cond.end.1130

cond.false.1125:                                  ; preds = %cond.false.1109
  %160 = load i64, i64* %numargs, align 8
  %conv1126 = trunc i64 %160 to i32
  %add1127 = add nsw i32 0, %conv1126
  %mul1128 = mul nsw i32 0, %add1127
  %sub1129 = sub nsw i32 %mul1128, 1
  br label %cond.end.1130

cond.end.1130:                                    ; preds = %cond.false.1125, %cond.true.1116
  %cond1131 = phi i32 [ %add1124, %cond.true.1116 ], [ %sub1129, %cond.false.1125 ]
  %div1132 = sdiv i32 %cond1131, 8
  %161 = load i64, i64* %numargs, align 8
  %conv1133 = trunc i64 %161 to i32
  %cmp1134 = icmp slt i32 %div1132, %conv1133
  br i1 %cmp1134, label %cond.true.1153, label %lor.lhs.false.1136

lor.lhs.false.1136:                               ; preds = %cond.end.1130, %cond.end.1104, %cond.true.1068, %cond.end.1061, %cond.true.1030, %cond.end.1024
  %162 = load i64, i64* %numargs, align 8
  %conv1137 = trunc i64 %162 to i32
  %mul1138 = mul nsw i32 %conv1137, 8
  %mul1139 = mul nsw i32 0, %mul1138
  %sub1140 = sub nsw i32 %mul1139, 1
  %cmp1141 = icmp slt i32 %sub1140, 0
  br i1 %cmp1141, label %land.lhs.true.1143, label %lor.lhs.false.1148

land.lhs.true.1143:                               ; preds = %lor.lhs.false.1136
  %163 = load i64, i64* %numargs, align 8
  %conv1144 = trunc i64 %163 to i32
  %mul1145 = mul nsw i32 %conv1144, 8
  %cmp1146 = icmp slt i32 %mul1145, -2147483648
  br i1 %cmp1146, label %cond.true.1153, label %lor.lhs.false.1148

lor.lhs.false.1148:                               ; preds = %land.lhs.true.1143, %lor.lhs.false.1136
  %164 = load i64, i64* %numargs, align 8
  %conv1149 = trunc i64 %164 to i32
  %mul1150 = mul nsw i32 %conv1149, 8
  %cmp1151 = icmp slt i32 2147483647, %mul1150
  br i1 %cmp1151, label %cond.true.1153, label %cond.false.1169

cond.true.1153:                                   ; preds = %lor.lhs.false.1148, %land.lhs.true.1143, %cond.end.1130, %cond.end.1104, %cond.true.1068, %cond.end.1061, %cond.true.1030, %cond.end.1024, %land.lhs.true.993
  %165 = load i64, i64* %numargs, align 8
  %conv1154 = trunc i64 %165 to i32
  %mul1155 = mul i32 %conv1154, 8
  %cmp1156 = icmp ule i32 %mul1155, 2147483647
  br i1 %cmp1156, label %cond.true.1158, label %cond.false.1161

cond.true.1158:                                   ; preds = %cond.true.1153
  %166 = load i64, i64* %numargs, align 8
  %conv1159 = trunc i64 %166 to i32
  %mul1160 = mul i32 %conv1159, 8
  br label %cond.end.1166

cond.false.1161:                                  ; preds = %cond.true.1153
  %167 = load i64, i64* %numargs, align 8
  %conv1162 = trunc i64 %167 to i32
  %mul1163 = mul i32 %conv1162, 8
  %sub1164 = sub i32 %mul1163, -2147483648
  %add1165 = add nsw i32 %sub1164, -2147483648
  br label %cond.end.1166

cond.end.1166:                                    ; preds = %cond.false.1161, %cond.true.1158
  %cond1167 = phi i32 [ %mul1160, %cond.true.1158 ], [ %add1165, %cond.false.1161 ]
  %conv1168 = sext i32 %cond1167 to i64
  store i64 %conv1168, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then, label %lor.lhs.false.2161

cond.false.1169:                                  ; preds = %lor.lhs.false.1148
  %168 = load i64, i64* %numargs, align 8
  %conv1170 = trunc i64 %168 to i32
  %mul1171 = mul i32 %conv1170, 8
  %cmp1172 = icmp ule i32 %mul1171, 2147483647
  br i1 %cmp1172, label %cond.true.1174, label %cond.false.1177

cond.true.1174:                                   ; preds = %cond.false.1169
  %169 = load i64, i64* %numargs, align 8
  %conv1175 = trunc i64 %169 to i32
  %mul1176 = mul i32 %conv1175, 8
  br label %cond.end.1182

cond.false.1177:                                  ; preds = %cond.false.1169
  %170 = load i64, i64* %numargs, align 8
  %conv1178 = trunc i64 %170 to i32
  %mul1179 = mul i32 %conv1178, 8
  %sub1180 = sub i32 %mul1179, -2147483648
  %add1181 = add nsw i32 %sub1180, -2147483648
  br label %cond.end.1182

cond.end.1182:                                    ; preds = %cond.false.1177, %cond.true.1174
  %cond1183 = phi i32 [ %mul1176, %cond.true.1174 ], [ %add1181, %cond.false.1177 ]
  %conv1184 = sext i32 %cond1183 to i64
  store i64 %conv1184, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then, label %lor.lhs.false.2161

cond.false.1185:                                  ; preds = %cond.true.958
  %171 = load i64, i64* %numargs, align 8
  %add1186 = add nsw i64 0, %171
  %mul1187 = mul nsw i64 0, %add1186
  %sub1188 = sub nsw i64 %mul1187, 1
  %cmp1189 = icmp slt i64 %sub1188, 0
  br i1 %cmp1189, label %cond.true.1191, label %cond.false.1208

cond.true.1191:                                   ; preds = %cond.false.1185
  %172 = load i64, i64* %numargs, align 8
  %add1192 = add nsw i64 0, %172
  %mul1193 = mul nsw i64 0, %add1192
  %add1194 = add nsw i64 %mul1193, 0
  %neg1195 = xor i64 %add1194, -1
  %cmp1196 = icmp eq i64 %neg1195, -1
  %conv1197 = zext i1 %cmp1196 to i32
  %sub1198 = sub nsw i32 0, %conv1197
  %conv1199 = sext i32 %sub1198 to i64
  %173 = load i64, i64* %numargs, align 8
  %add1200 = add nsw i64 0, %173
  %mul1201 = mul nsw i64 0, %add1200
  %add1202 = add nsw i64 %mul1201, 1
  %shl1203 = shl i64 %add1202, 62
  %sub1204 = sub nsw i64 %shl1203, 1
  %mul1205 = mul nsw i64 %sub1204, 2
  %add1206 = add nsw i64 %mul1205, 1
  %sub1207 = sub nsw i64 %conv1199, %add1206
  br label %cond.end.1212

cond.false.1208:                                  ; preds = %cond.false.1185
  %174 = load i64, i64* %numargs, align 8
  %add1209 = add nsw i64 0, %174
  %mul1210 = mul nsw i64 0, %add1209
  %add1211 = add nsw i64 %mul1210, 0
  br label %cond.end.1212

cond.end.1212:                                    ; preds = %cond.false.1208, %cond.true.1191
  %cond1213 = phi i64 [ %sub1207, %cond.true.1191 ], [ %add1211, %cond.false.1208 ]
  %cmp1214 = icmp eq i64 %cond1213, 0
  br i1 %cmp1214, label %land.lhs.true.1216, label %lor.lhs.false.1219

land.lhs.true.1216:                               ; preds = %cond.end.1212
  %175 = load i64, i64* %numargs, align 8
  %cmp1217 = icmp slt i64 %175, 0
  br i1 %cmp1217, label %cond.true.1354, label %lor.lhs.false.1219

lor.lhs.false.1219:                               ; preds = %land.lhs.true.1216, %cond.end.1212
  br i1 false, label %cond.true.1220, label %cond.false.1280

cond.true.1220:                                   ; preds = %lor.lhs.false.1219
  %176 = load i64, i64* %numargs, align 8
  %cmp1221 = icmp slt i64 %176, 0
  br i1 %cmp1221, label %cond.true.1223, label %cond.false.1246

cond.true.1223:                                   ; preds = %cond.true.1220
  %177 = load i64, i64* %numargs, align 8
  %178 = load i64, i64* %numargs, align 8
  %add1224 = add nsw i64 0, %178
  %mul1225 = mul nsw i64 0, %add1224
  %sub1226 = sub nsw i64 %mul1225, 1
  %cmp1227 = icmp slt i64 %sub1226, 0
  br i1 %cmp1227, label %cond.true.1229, label %cond.false.1237

cond.true.1229:                                   ; preds = %cond.true.1223
  %179 = load i64, i64* %numargs, align 8
  %add1230 = add nsw i64 0, %179
  %mul1231 = mul nsw i64 0, %add1230
  %add1232 = add nsw i64 %mul1231, 1
  %shl1233 = shl i64 %add1232, 62
  %sub1234 = sub nsw i64 %shl1233, 1
  %mul1235 = mul nsw i64 %sub1234, 2
  %add1236 = add nsw i64 %mul1235, 1
  br label %cond.end.1241

cond.false.1237:                                  ; preds = %cond.true.1223
  %180 = load i64, i64* %numargs, align 8
  %add1238 = add nsw i64 0, %180
  %mul1239 = mul nsw i64 0, %add1238
  %sub1240 = sub nsw i64 %mul1239, 1
  br label %cond.end.1241

cond.end.1241:                                    ; preds = %cond.false.1237, %cond.true.1229
  %cond1242 = phi i64 [ %add1236, %cond.true.1229 ], [ %sub1240, %cond.false.1237 ]
  %div1243 = sdiv i64 %cond1242, 8
  %cmp1244 = icmp slt i64 %177, %div1243
  br i1 %cmp1244, label %cond.true.1354, label %lor.lhs.false.1340

cond.false.1246:                                  ; preds = %cond.true.1220
  br i1 false, label %cond.true.1247, label %cond.false.1248

cond.true.1247:                                   ; preds = %cond.false.1246
  br i1 false, label %cond.true.1354, label %lor.lhs.false.1340

cond.false.1248:                                  ; preds = %cond.false.1246
  %181 = load i64, i64* %numargs, align 8
  %add1249 = add nsw i64 0, %181
  %mul1250 = mul nsw i64 0, %add1249
  %sub1251 = sub nsw i64 %mul1250, 1
  %cmp1252 = icmp slt i64 %sub1251, 0
  br i1 %cmp1252, label %cond.true.1254, label %cond.false.1271

cond.true.1254:                                   ; preds = %cond.false.1248
  %182 = load i64, i64* %numargs, align 8
  %add1255 = add nsw i64 0, %182
  %mul1256 = mul nsw i64 0, %add1255
  %add1257 = add nsw i64 %mul1256, 0
  %neg1258 = xor i64 %add1257, -1
  %cmp1259 = icmp eq i64 %neg1258, -1
  %conv1260 = zext i1 %cmp1259 to i32
  %sub1261 = sub nsw i32 0, %conv1260
  %conv1262 = sext i32 %sub1261 to i64
  %183 = load i64, i64* %numargs, align 8
  %add1263 = add nsw i64 0, %183
  %mul1264 = mul nsw i64 0, %add1263
  %add1265 = add nsw i64 %mul1264, 1
  %shl1266 = shl i64 %add1265, 62
  %sub1267 = sub nsw i64 %shl1266, 1
  %mul1268 = mul nsw i64 %sub1267, 2
  %add1269 = add nsw i64 %mul1268, 1
  %sub1270 = sub nsw i64 %conv1262, %add1269
  br label %cond.end.1275

cond.false.1271:                                  ; preds = %cond.false.1248
  %184 = load i64, i64* %numargs, align 8
  %add1272 = add nsw i64 0, %184
  %mul1273 = mul nsw i64 0, %add1272
  %add1274 = add nsw i64 %mul1273, 0
  br label %cond.end.1275

cond.end.1275:                                    ; preds = %cond.false.1271, %cond.true.1254
  %cond1276 = phi i64 [ %sub1270, %cond.true.1254 ], [ %add1274, %cond.false.1271 ]
  %div1277 = sdiv i64 %cond1276, 8
  %185 = load i64, i64* %numargs, align 8
  %cmp1278 = icmp slt i64 %div1277, %185
  br i1 %cmp1278, label %cond.true.1354, label %lor.lhs.false.1340

cond.false.1280:                                  ; preds = %lor.lhs.false.1219
  br i1 false, label %cond.true.1281, label %cond.false.1282

cond.true.1281:                                   ; preds = %cond.false.1280
  br i1 false, label %cond.true.1354, label %lor.lhs.false.1340

cond.false.1282:                                  ; preds = %cond.false.1280
  %186 = load i64, i64* %numargs, align 8
  %cmp1283 = icmp slt i64 %186, 0
  br i1 %cmp1283, label %cond.true.1285, label %cond.false.1317

cond.true.1285:                                   ; preds = %cond.false.1282
  %187 = load i64, i64* %numargs, align 8
  %188 = load i64, i64* %numargs, align 8
  %add1286 = add nsw i64 0, %188
  %mul1287 = mul nsw i64 0, %add1286
  %sub1288 = sub nsw i64 %mul1287, 1
  %cmp1289 = icmp slt i64 %sub1288, 0
  br i1 %cmp1289, label %cond.true.1291, label %cond.false.1308

cond.true.1291:                                   ; preds = %cond.true.1285
  %189 = load i64, i64* %numargs, align 8
  %add1292 = add nsw i64 0, %189
  %mul1293 = mul nsw i64 0, %add1292
  %add1294 = add nsw i64 %mul1293, 0
  %neg1295 = xor i64 %add1294, -1
  %cmp1296 = icmp eq i64 %neg1295, -1
  %conv1297 = zext i1 %cmp1296 to i32
  %sub1298 = sub nsw i32 0, %conv1297
  %conv1299 = sext i32 %sub1298 to i64
  %190 = load i64, i64* %numargs, align 8
  %add1300 = add nsw i64 0, %190
  %mul1301 = mul nsw i64 0, %add1300
  %add1302 = add nsw i64 %mul1301, 1
  %shl1303 = shl i64 %add1302, 62
  %sub1304 = sub nsw i64 %shl1303, 1
  %mul1305 = mul nsw i64 %sub1304, 2
  %add1306 = add nsw i64 %mul1305, 1
  %sub1307 = sub nsw i64 %conv1299, %add1306
  br label %cond.end.1312

cond.false.1308:                                  ; preds = %cond.true.1285
  %191 = load i64, i64* %numargs, align 8
  %add1309 = add nsw i64 0, %191
  %mul1310 = mul nsw i64 0, %add1309
  %add1311 = add nsw i64 %mul1310, 0
  br label %cond.end.1312

cond.end.1312:                                    ; preds = %cond.false.1308, %cond.true.1291
  %cond1313 = phi i64 [ %sub1307, %cond.true.1291 ], [ %add1311, %cond.false.1308 ]
  %div1314 = sdiv i64 %cond1313, 8
  %cmp1315 = icmp slt i64 %187, %div1314
  br i1 %cmp1315, label %cond.true.1354, label %lor.lhs.false.1340

cond.false.1317:                                  ; preds = %cond.false.1282
  %192 = load i64, i64* %numargs, align 8
  %add1318 = add nsw i64 0, %192
  %mul1319 = mul nsw i64 0, %add1318
  %sub1320 = sub nsw i64 %mul1319, 1
  %cmp1321 = icmp slt i64 %sub1320, 0
  br i1 %cmp1321, label %cond.true.1323, label %cond.false.1331

cond.true.1323:                                   ; preds = %cond.false.1317
  %193 = load i64, i64* %numargs, align 8
  %add1324 = add nsw i64 0, %193
  %mul1325 = mul nsw i64 0, %add1324
  %add1326 = add nsw i64 %mul1325, 1
  %shl1327 = shl i64 %add1326, 62
  %sub1328 = sub nsw i64 %shl1327, 1
  %mul1329 = mul nsw i64 %sub1328, 2
  %add1330 = add nsw i64 %mul1329, 1
  br label %cond.end.1335

cond.false.1331:                                  ; preds = %cond.false.1317
  %194 = load i64, i64* %numargs, align 8
  %add1332 = add nsw i64 0, %194
  %mul1333 = mul nsw i64 0, %add1332
  %sub1334 = sub nsw i64 %mul1333, 1
  br label %cond.end.1335

cond.end.1335:                                    ; preds = %cond.false.1331, %cond.true.1323
  %cond1336 = phi i64 [ %add1330, %cond.true.1323 ], [ %sub1334, %cond.false.1331 ]
  %div1337 = sdiv i64 %cond1336, 8
  %195 = load i64, i64* %numargs, align 8
  %cmp1338 = icmp slt i64 %div1337, %195
  br i1 %cmp1338, label %cond.true.1354, label %lor.lhs.false.1340

lor.lhs.false.1340:                               ; preds = %cond.end.1335, %cond.end.1312, %cond.true.1281, %cond.end.1275, %cond.true.1247, %cond.end.1241
  %196 = load i64, i64* %numargs, align 8
  %mul1341 = mul nsw i64 %196, 8
  %mul1342 = mul nsw i64 0, %mul1341
  %sub1343 = sub nsw i64 %mul1342, 1
  %cmp1344 = icmp slt i64 %sub1343, 0
  br i1 %cmp1344, label %land.lhs.true.1346, label %lor.lhs.false.1350

land.lhs.true.1346:                               ; preds = %lor.lhs.false.1340
  %197 = load i64, i64* %numargs, align 8
  %mul1347 = mul nsw i64 %197, 8
  %cmp1348 = icmp slt i64 %mul1347, -2147483648
  br i1 %cmp1348, label %cond.true.1354, label %lor.lhs.false.1350

lor.lhs.false.1350:                               ; preds = %land.lhs.true.1346, %lor.lhs.false.1340
  %198 = load i64, i64* %numargs, align 8
  %mul1351 = mul nsw i64 %198, 8
  %cmp1352 = icmp slt i64 2147483647, %mul1351
  br i1 %cmp1352, label %cond.true.1354, label %cond.false.1370

cond.true.1354:                                   ; preds = %lor.lhs.false.1350, %land.lhs.true.1346, %cond.end.1335, %cond.end.1312, %cond.true.1281, %cond.end.1275, %cond.true.1247, %cond.end.1241, %land.lhs.true.1216
  %199 = load i64, i64* %numargs, align 8
  %conv1355 = trunc i64 %199 to i32
  %mul1356 = mul i32 %conv1355, 8
  %cmp1357 = icmp ule i32 %mul1356, 2147483647
  br i1 %cmp1357, label %cond.true.1359, label %cond.false.1362

cond.true.1359:                                   ; preds = %cond.true.1354
  %200 = load i64, i64* %numargs, align 8
  %conv1360 = trunc i64 %200 to i32
  %mul1361 = mul i32 %conv1360, 8
  br label %cond.end.1367

cond.false.1362:                                  ; preds = %cond.true.1354
  %201 = load i64, i64* %numargs, align 8
  %conv1363 = trunc i64 %201 to i32
  %mul1364 = mul i32 %conv1363, 8
  %sub1365 = sub i32 %mul1364, -2147483648
  %add1366 = add nsw i32 %sub1365, -2147483648
  br label %cond.end.1367

cond.end.1367:                                    ; preds = %cond.false.1362, %cond.true.1359
  %cond1368 = phi i32 [ %mul1361, %cond.true.1359 ], [ %add1366, %cond.false.1362 ]
  %conv1369 = sext i32 %cond1368 to i64
  store i64 %conv1369, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then, label %lor.lhs.false.2161

cond.false.1370:                                  ; preds = %lor.lhs.false.1350
  %202 = load i64, i64* %numargs, align 8
  %conv1371 = trunc i64 %202 to i32
  %mul1372 = mul i32 %conv1371, 8
  %cmp1373 = icmp ule i32 %mul1372, 2147483647
  br i1 %cmp1373, label %cond.true.1375, label %cond.false.1378

cond.true.1375:                                   ; preds = %cond.false.1370
  %203 = load i64, i64* %numargs, align 8
  %conv1376 = trunc i64 %203 to i32
  %mul1377 = mul i32 %conv1376, 8
  br label %cond.end.1383

cond.false.1378:                                  ; preds = %cond.false.1370
  %204 = load i64, i64* %numargs, align 8
  %conv1379 = trunc i64 %204 to i32
  %mul1380 = mul i32 %conv1379, 8
  %sub1381 = sub i32 %mul1380, -2147483648
  %add1382 = add nsw i32 %sub1381, -2147483648
  br label %cond.end.1383

cond.end.1383:                                    ; preds = %cond.false.1378, %cond.true.1375
  %cond1384 = phi i32 [ %mul1377, %cond.true.1375 ], [ %add1382, %cond.false.1378 ]
  %conv1385 = sext i32 %cond1384 to i64
  store i64 %conv1385, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then, label %lor.lhs.false.2161

cond.false.1386:                                  ; preds = %cond.false.957
  br i1 true, label %cond.true.1387, label %cond.false.1774

cond.true.1387:                                   ; preds = %cond.false.1386
  br i1 false, label %cond.true.1388, label %cond.false.1581

cond.true.1388:                                   ; preds = %cond.true.1387
  %205 = load i64, i64* %numargs, align 8
  %add1389 = add nsw i64 0, %205
  %mul1390 = mul nsw i64 0, %add1389
  %sub1391 = sub nsw i64 %mul1390, 1
  %cmp1392 = icmp slt i64 %sub1391, 0
  br i1 %cmp1392, label %cond.true.1394, label %cond.false.1411

cond.true.1394:                                   ; preds = %cond.true.1388
  %206 = load i64, i64* %numargs, align 8
  %add1395 = add nsw i64 0, %206
  %mul1396 = mul nsw i64 0, %add1395
  %add1397 = add nsw i64 %mul1396, 0
  %neg1398 = xor i64 %add1397, -1
  %cmp1399 = icmp eq i64 %neg1398, -1
  %conv1400 = zext i1 %cmp1399 to i32
  %sub1401 = sub nsw i32 0, %conv1400
  %conv1402 = sext i32 %sub1401 to i64
  %207 = load i64, i64* %numargs, align 8
  %add1403 = add nsw i64 0, %207
  %mul1404 = mul nsw i64 0, %add1403
  %add1405 = add nsw i64 %mul1404, 1
  %shl1406 = shl i64 %add1405, 62
  %sub1407 = sub nsw i64 %shl1406, 1
  %mul1408 = mul nsw i64 %sub1407, 2
  %add1409 = add nsw i64 %mul1408, 1
  %sub1410 = sub nsw i64 %conv1402, %add1409
  br label %cond.end.1415

cond.false.1411:                                  ; preds = %cond.true.1388
  %208 = load i64, i64* %numargs, align 8
  %add1412 = add nsw i64 0, %208
  %mul1413 = mul nsw i64 0, %add1412
  %add1414 = add nsw i64 %mul1413, 0
  br label %cond.end.1415

cond.end.1415:                                    ; preds = %cond.false.1411, %cond.true.1394
  %cond1416 = phi i64 [ %sub1410, %cond.true.1394 ], [ %add1414, %cond.false.1411 ]
  %cmp1417 = icmp eq i64 %cond1416, 0
  br i1 %cmp1417, label %land.lhs.true.1419, label %lor.lhs.false.1422

land.lhs.true.1419:                               ; preds = %cond.end.1415
  %209 = load i64, i64* %numargs, align 8
  %cmp1420 = icmp slt i64 %209, 0
  br i1 %cmp1420, label %cond.true.1557, label %lor.lhs.false.1422

lor.lhs.false.1422:                               ; preds = %land.lhs.true.1419, %cond.end.1415
  br i1 false, label %cond.true.1423, label %cond.false.1483

cond.true.1423:                                   ; preds = %lor.lhs.false.1422
  %210 = load i64, i64* %numargs, align 8
  %cmp1424 = icmp slt i64 %210, 0
  br i1 %cmp1424, label %cond.true.1426, label %cond.false.1449

cond.true.1426:                                   ; preds = %cond.true.1423
  %211 = load i64, i64* %numargs, align 8
  %212 = load i64, i64* %numargs, align 8
  %add1427 = add nsw i64 0, %212
  %mul1428 = mul nsw i64 0, %add1427
  %sub1429 = sub nsw i64 %mul1428, 1
  %cmp1430 = icmp slt i64 %sub1429, 0
  br i1 %cmp1430, label %cond.true.1432, label %cond.false.1440

cond.true.1432:                                   ; preds = %cond.true.1426
  %213 = load i64, i64* %numargs, align 8
  %add1433 = add nsw i64 0, %213
  %mul1434 = mul nsw i64 0, %add1433
  %add1435 = add nsw i64 %mul1434, 1
  %shl1436 = shl i64 %add1435, 62
  %sub1437 = sub nsw i64 %shl1436, 1
  %mul1438 = mul nsw i64 %sub1437, 2
  %add1439 = add nsw i64 %mul1438, 1
  br label %cond.end.1444

cond.false.1440:                                  ; preds = %cond.true.1426
  %214 = load i64, i64* %numargs, align 8
  %add1441 = add nsw i64 0, %214
  %mul1442 = mul nsw i64 0, %add1441
  %sub1443 = sub nsw i64 %mul1442, 1
  br label %cond.end.1444

cond.end.1444:                                    ; preds = %cond.false.1440, %cond.true.1432
  %cond1445 = phi i64 [ %add1439, %cond.true.1432 ], [ %sub1443, %cond.false.1440 ]
  %div1446 = sdiv i64 %cond1445, 8
  %cmp1447 = icmp slt i64 %211, %div1446
  br i1 %cmp1447, label %cond.true.1557, label %lor.lhs.false.1543

cond.false.1449:                                  ; preds = %cond.true.1423
  br i1 false, label %cond.true.1450, label %cond.false.1451

cond.true.1450:                                   ; preds = %cond.false.1449
  br i1 false, label %cond.true.1557, label %lor.lhs.false.1543

cond.false.1451:                                  ; preds = %cond.false.1449
  %215 = load i64, i64* %numargs, align 8
  %add1452 = add nsw i64 0, %215
  %mul1453 = mul nsw i64 0, %add1452
  %sub1454 = sub nsw i64 %mul1453, 1
  %cmp1455 = icmp slt i64 %sub1454, 0
  br i1 %cmp1455, label %cond.true.1457, label %cond.false.1474

cond.true.1457:                                   ; preds = %cond.false.1451
  %216 = load i64, i64* %numargs, align 8
  %add1458 = add nsw i64 0, %216
  %mul1459 = mul nsw i64 0, %add1458
  %add1460 = add nsw i64 %mul1459, 0
  %neg1461 = xor i64 %add1460, -1
  %cmp1462 = icmp eq i64 %neg1461, -1
  %conv1463 = zext i1 %cmp1462 to i32
  %sub1464 = sub nsw i32 0, %conv1463
  %conv1465 = sext i32 %sub1464 to i64
  %217 = load i64, i64* %numargs, align 8
  %add1466 = add nsw i64 0, %217
  %mul1467 = mul nsw i64 0, %add1466
  %add1468 = add nsw i64 %mul1467, 1
  %shl1469 = shl i64 %add1468, 62
  %sub1470 = sub nsw i64 %shl1469, 1
  %mul1471 = mul nsw i64 %sub1470, 2
  %add1472 = add nsw i64 %mul1471, 1
  %sub1473 = sub nsw i64 %conv1465, %add1472
  br label %cond.end.1478

cond.false.1474:                                  ; preds = %cond.false.1451
  %218 = load i64, i64* %numargs, align 8
  %add1475 = add nsw i64 0, %218
  %mul1476 = mul nsw i64 0, %add1475
  %add1477 = add nsw i64 %mul1476, 0
  br label %cond.end.1478

cond.end.1478:                                    ; preds = %cond.false.1474, %cond.true.1457
  %cond1479 = phi i64 [ %sub1473, %cond.true.1457 ], [ %add1477, %cond.false.1474 ]
  %div1480 = sdiv i64 %cond1479, 8
  %219 = load i64, i64* %numargs, align 8
  %cmp1481 = icmp slt i64 %div1480, %219
  br i1 %cmp1481, label %cond.true.1557, label %lor.lhs.false.1543

cond.false.1483:                                  ; preds = %lor.lhs.false.1422
  br i1 false, label %cond.true.1484, label %cond.false.1485

cond.true.1484:                                   ; preds = %cond.false.1483
  br i1 false, label %cond.true.1557, label %lor.lhs.false.1543

cond.false.1485:                                  ; preds = %cond.false.1483
  %220 = load i64, i64* %numargs, align 8
  %cmp1486 = icmp slt i64 %220, 0
  br i1 %cmp1486, label %cond.true.1488, label %cond.false.1520

cond.true.1488:                                   ; preds = %cond.false.1485
  %221 = load i64, i64* %numargs, align 8
  %222 = load i64, i64* %numargs, align 8
  %add1489 = add nsw i64 0, %222
  %mul1490 = mul nsw i64 0, %add1489
  %sub1491 = sub nsw i64 %mul1490, 1
  %cmp1492 = icmp slt i64 %sub1491, 0
  br i1 %cmp1492, label %cond.true.1494, label %cond.false.1511

cond.true.1494:                                   ; preds = %cond.true.1488
  %223 = load i64, i64* %numargs, align 8
  %add1495 = add nsw i64 0, %223
  %mul1496 = mul nsw i64 0, %add1495
  %add1497 = add nsw i64 %mul1496, 0
  %neg1498 = xor i64 %add1497, -1
  %cmp1499 = icmp eq i64 %neg1498, -1
  %conv1500 = zext i1 %cmp1499 to i32
  %sub1501 = sub nsw i32 0, %conv1500
  %conv1502 = sext i32 %sub1501 to i64
  %224 = load i64, i64* %numargs, align 8
  %add1503 = add nsw i64 0, %224
  %mul1504 = mul nsw i64 0, %add1503
  %add1505 = add nsw i64 %mul1504, 1
  %shl1506 = shl i64 %add1505, 62
  %sub1507 = sub nsw i64 %shl1506, 1
  %mul1508 = mul nsw i64 %sub1507, 2
  %add1509 = add nsw i64 %mul1508, 1
  %sub1510 = sub nsw i64 %conv1502, %add1509
  br label %cond.end.1515

cond.false.1511:                                  ; preds = %cond.true.1488
  %225 = load i64, i64* %numargs, align 8
  %add1512 = add nsw i64 0, %225
  %mul1513 = mul nsw i64 0, %add1512
  %add1514 = add nsw i64 %mul1513, 0
  br label %cond.end.1515

cond.end.1515:                                    ; preds = %cond.false.1511, %cond.true.1494
  %cond1516 = phi i64 [ %sub1510, %cond.true.1494 ], [ %add1514, %cond.false.1511 ]
  %div1517 = sdiv i64 %cond1516, 8
  %cmp1518 = icmp slt i64 %221, %div1517
  br i1 %cmp1518, label %cond.true.1557, label %lor.lhs.false.1543

cond.false.1520:                                  ; preds = %cond.false.1485
  %226 = load i64, i64* %numargs, align 8
  %add1521 = add nsw i64 0, %226
  %mul1522 = mul nsw i64 0, %add1521
  %sub1523 = sub nsw i64 %mul1522, 1
  %cmp1524 = icmp slt i64 %sub1523, 0
  br i1 %cmp1524, label %cond.true.1526, label %cond.false.1534

cond.true.1526:                                   ; preds = %cond.false.1520
  %227 = load i64, i64* %numargs, align 8
  %add1527 = add nsw i64 0, %227
  %mul1528 = mul nsw i64 0, %add1527
  %add1529 = add nsw i64 %mul1528, 1
  %shl1530 = shl i64 %add1529, 62
  %sub1531 = sub nsw i64 %shl1530, 1
  %mul1532 = mul nsw i64 %sub1531, 2
  %add1533 = add nsw i64 %mul1532, 1
  br label %cond.end.1538

cond.false.1534:                                  ; preds = %cond.false.1520
  %228 = load i64, i64* %numargs, align 8
  %add1535 = add nsw i64 0, %228
  %mul1536 = mul nsw i64 0, %add1535
  %sub1537 = sub nsw i64 %mul1536, 1
  br label %cond.end.1538

cond.end.1538:                                    ; preds = %cond.false.1534, %cond.true.1526
  %cond1539 = phi i64 [ %add1533, %cond.true.1526 ], [ %sub1537, %cond.false.1534 ]
  %div1540 = sdiv i64 %cond1539, 8
  %229 = load i64, i64* %numargs, align 8
  %cmp1541 = icmp slt i64 %div1540, %229
  br i1 %cmp1541, label %cond.true.1557, label %lor.lhs.false.1543

lor.lhs.false.1543:                               ; preds = %cond.end.1538, %cond.end.1515, %cond.true.1484, %cond.end.1478, %cond.true.1450, %cond.end.1444
  %230 = load i64, i64* %numargs, align 8
  %mul1544 = mul nsw i64 %230, 8
  %mul1545 = mul nsw i64 0, %mul1544
  %sub1546 = sub nsw i64 %mul1545, 1
  %cmp1547 = icmp slt i64 %sub1546, 0
  br i1 %cmp1547, label %land.lhs.true.1549, label %lor.lhs.false.1553

land.lhs.true.1549:                               ; preds = %lor.lhs.false.1543
  %231 = load i64, i64* %numargs, align 8
  %mul1550 = mul nsw i64 %231, 8
  %cmp1551 = icmp slt i64 %mul1550, -9223372036854775808
  br i1 %cmp1551, label %cond.true.1557, label %lor.lhs.false.1553

lor.lhs.false.1553:                               ; preds = %land.lhs.true.1549, %lor.lhs.false.1543
  %232 = load i64, i64* %numargs, align 8
  %mul1554 = mul nsw i64 %232, 8
  %cmp1555 = icmp slt i64 9223372036854775807, %mul1554
  br i1 %cmp1555, label %cond.true.1557, label %cond.false.1569

cond.true.1557:                                   ; preds = %lor.lhs.false.1553, %land.lhs.true.1549, %cond.end.1538, %cond.end.1515, %cond.true.1484, %cond.end.1478, %cond.true.1450, %cond.end.1444, %land.lhs.true.1419
  %233 = load i64, i64* %numargs, align 8
  %mul1558 = mul i64 %233, 8
  %cmp1559 = icmp ule i64 %mul1558, 9223372036854775807
  br i1 %cmp1559, label %cond.true.1561, label %cond.false.1563

cond.true.1561:                                   ; preds = %cond.true.1557
  %234 = load i64, i64* %numargs, align 8
  %mul1562 = mul i64 %234, 8
  br label %cond.end.1567

cond.false.1563:                                  ; preds = %cond.true.1557
  %235 = load i64, i64* %numargs, align 8
  %mul1564 = mul i64 %235, 8
  %sub1565 = sub i64 %mul1564, -9223372036854775808
  %add1566 = add nsw i64 %sub1565, -9223372036854775808
  br label %cond.end.1567

cond.end.1567:                                    ; preds = %cond.false.1563, %cond.true.1561
  %cond1568 = phi i64 [ %mul1562, %cond.true.1561 ], [ %add1566, %cond.false.1563 ]
  store i64 %cond1568, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then, label %lor.lhs.false.2161

cond.false.1569:                                  ; preds = %lor.lhs.false.1553
  %236 = load i64, i64* %numargs, align 8
  %mul1570 = mul i64 %236, 8
  %cmp1571 = icmp ule i64 %mul1570, 9223372036854775807
  br i1 %cmp1571, label %cond.true.1573, label %cond.false.1575

cond.true.1573:                                   ; preds = %cond.false.1569
  %237 = load i64, i64* %numargs, align 8
  %mul1574 = mul i64 %237, 8
  br label %cond.end.1579

cond.false.1575:                                  ; preds = %cond.false.1569
  %238 = load i64, i64* %numargs, align 8
  %mul1576 = mul i64 %238, 8
  %sub1577 = sub i64 %mul1576, -9223372036854775808
  %add1578 = add nsw i64 %sub1577, -9223372036854775808
  br label %cond.end.1579

cond.end.1579:                                    ; preds = %cond.false.1575, %cond.true.1573
  %cond1580 = phi i64 [ %mul1574, %cond.true.1573 ], [ %add1578, %cond.false.1575 ]
  store i64 %cond1580, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then, label %lor.lhs.false.2161

cond.false.1581:                                  ; preds = %cond.true.1387
  %239 = load i64, i64* %numargs, align 8
  %add1582 = add nsw i64 0, %239
  %mul1583 = mul nsw i64 0, %add1582
  %sub1584 = sub nsw i64 %mul1583, 1
  %cmp1585 = icmp slt i64 %sub1584, 0
  br i1 %cmp1585, label %cond.true.1587, label %cond.false.1604

cond.true.1587:                                   ; preds = %cond.false.1581
  %240 = load i64, i64* %numargs, align 8
  %add1588 = add nsw i64 0, %240
  %mul1589 = mul nsw i64 0, %add1588
  %add1590 = add nsw i64 %mul1589, 0
  %neg1591 = xor i64 %add1590, -1
  %cmp1592 = icmp eq i64 %neg1591, -1
  %conv1593 = zext i1 %cmp1592 to i32
  %sub1594 = sub nsw i32 0, %conv1593
  %conv1595 = sext i32 %sub1594 to i64
  %241 = load i64, i64* %numargs, align 8
  %add1596 = add nsw i64 0, %241
  %mul1597 = mul nsw i64 0, %add1596
  %add1598 = add nsw i64 %mul1597, 1
  %shl1599 = shl i64 %add1598, 62
  %sub1600 = sub nsw i64 %shl1599, 1
  %mul1601 = mul nsw i64 %sub1600, 2
  %add1602 = add nsw i64 %mul1601, 1
  %sub1603 = sub nsw i64 %conv1595, %add1602
  br label %cond.end.1608

cond.false.1604:                                  ; preds = %cond.false.1581
  %242 = load i64, i64* %numargs, align 8
  %add1605 = add nsw i64 0, %242
  %mul1606 = mul nsw i64 0, %add1605
  %add1607 = add nsw i64 %mul1606, 0
  br label %cond.end.1608

cond.end.1608:                                    ; preds = %cond.false.1604, %cond.true.1587
  %cond1609 = phi i64 [ %sub1603, %cond.true.1587 ], [ %add1607, %cond.false.1604 ]
  %cmp1610 = icmp eq i64 %cond1609, 0
  br i1 %cmp1610, label %land.lhs.true.1612, label %lor.lhs.false.1615

land.lhs.true.1612:                               ; preds = %cond.end.1608
  %243 = load i64, i64* %numargs, align 8
  %cmp1613 = icmp slt i64 %243, 0
  br i1 %cmp1613, label %cond.true.1750, label %lor.lhs.false.1615

lor.lhs.false.1615:                               ; preds = %land.lhs.true.1612, %cond.end.1608
  br i1 false, label %cond.true.1616, label %cond.false.1676

cond.true.1616:                                   ; preds = %lor.lhs.false.1615
  %244 = load i64, i64* %numargs, align 8
  %cmp1617 = icmp slt i64 %244, 0
  br i1 %cmp1617, label %cond.true.1619, label %cond.false.1642

cond.true.1619:                                   ; preds = %cond.true.1616
  %245 = load i64, i64* %numargs, align 8
  %246 = load i64, i64* %numargs, align 8
  %add1620 = add nsw i64 0, %246
  %mul1621 = mul nsw i64 0, %add1620
  %sub1622 = sub nsw i64 %mul1621, 1
  %cmp1623 = icmp slt i64 %sub1622, 0
  br i1 %cmp1623, label %cond.true.1625, label %cond.false.1633

cond.true.1625:                                   ; preds = %cond.true.1619
  %247 = load i64, i64* %numargs, align 8
  %add1626 = add nsw i64 0, %247
  %mul1627 = mul nsw i64 0, %add1626
  %add1628 = add nsw i64 %mul1627, 1
  %shl1629 = shl i64 %add1628, 62
  %sub1630 = sub nsw i64 %shl1629, 1
  %mul1631 = mul nsw i64 %sub1630, 2
  %add1632 = add nsw i64 %mul1631, 1
  br label %cond.end.1637

cond.false.1633:                                  ; preds = %cond.true.1619
  %248 = load i64, i64* %numargs, align 8
  %add1634 = add nsw i64 0, %248
  %mul1635 = mul nsw i64 0, %add1634
  %sub1636 = sub nsw i64 %mul1635, 1
  br label %cond.end.1637

cond.end.1637:                                    ; preds = %cond.false.1633, %cond.true.1625
  %cond1638 = phi i64 [ %add1632, %cond.true.1625 ], [ %sub1636, %cond.false.1633 ]
  %div1639 = sdiv i64 %cond1638, 8
  %cmp1640 = icmp slt i64 %245, %div1639
  br i1 %cmp1640, label %cond.true.1750, label %lor.lhs.false.1736

cond.false.1642:                                  ; preds = %cond.true.1616
  br i1 false, label %cond.true.1643, label %cond.false.1644

cond.true.1643:                                   ; preds = %cond.false.1642
  br i1 false, label %cond.true.1750, label %lor.lhs.false.1736

cond.false.1644:                                  ; preds = %cond.false.1642
  %249 = load i64, i64* %numargs, align 8
  %add1645 = add nsw i64 0, %249
  %mul1646 = mul nsw i64 0, %add1645
  %sub1647 = sub nsw i64 %mul1646, 1
  %cmp1648 = icmp slt i64 %sub1647, 0
  br i1 %cmp1648, label %cond.true.1650, label %cond.false.1667

cond.true.1650:                                   ; preds = %cond.false.1644
  %250 = load i64, i64* %numargs, align 8
  %add1651 = add nsw i64 0, %250
  %mul1652 = mul nsw i64 0, %add1651
  %add1653 = add nsw i64 %mul1652, 0
  %neg1654 = xor i64 %add1653, -1
  %cmp1655 = icmp eq i64 %neg1654, -1
  %conv1656 = zext i1 %cmp1655 to i32
  %sub1657 = sub nsw i32 0, %conv1656
  %conv1658 = sext i32 %sub1657 to i64
  %251 = load i64, i64* %numargs, align 8
  %add1659 = add nsw i64 0, %251
  %mul1660 = mul nsw i64 0, %add1659
  %add1661 = add nsw i64 %mul1660, 1
  %shl1662 = shl i64 %add1661, 62
  %sub1663 = sub nsw i64 %shl1662, 1
  %mul1664 = mul nsw i64 %sub1663, 2
  %add1665 = add nsw i64 %mul1664, 1
  %sub1666 = sub nsw i64 %conv1658, %add1665
  br label %cond.end.1671

cond.false.1667:                                  ; preds = %cond.false.1644
  %252 = load i64, i64* %numargs, align 8
  %add1668 = add nsw i64 0, %252
  %mul1669 = mul nsw i64 0, %add1668
  %add1670 = add nsw i64 %mul1669, 0
  br label %cond.end.1671

cond.end.1671:                                    ; preds = %cond.false.1667, %cond.true.1650
  %cond1672 = phi i64 [ %sub1666, %cond.true.1650 ], [ %add1670, %cond.false.1667 ]
  %div1673 = sdiv i64 %cond1672, 8
  %253 = load i64, i64* %numargs, align 8
  %cmp1674 = icmp slt i64 %div1673, %253
  br i1 %cmp1674, label %cond.true.1750, label %lor.lhs.false.1736

cond.false.1676:                                  ; preds = %lor.lhs.false.1615
  br i1 false, label %cond.true.1677, label %cond.false.1678

cond.true.1677:                                   ; preds = %cond.false.1676
  br i1 false, label %cond.true.1750, label %lor.lhs.false.1736

cond.false.1678:                                  ; preds = %cond.false.1676
  %254 = load i64, i64* %numargs, align 8
  %cmp1679 = icmp slt i64 %254, 0
  br i1 %cmp1679, label %cond.true.1681, label %cond.false.1713

cond.true.1681:                                   ; preds = %cond.false.1678
  %255 = load i64, i64* %numargs, align 8
  %256 = load i64, i64* %numargs, align 8
  %add1682 = add nsw i64 0, %256
  %mul1683 = mul nsw i64 0, %add1682
  %sub1684 = sub nsw i64 %mul1683, 1
  %cmp1685 = icmp slt i64 %sub1684, 0
  br i1 %cmp1685, label %cond.true.1687, label %cond.false.1704

cond.true.1687:                                   ; preds = %cond.true.1681
  %257 = load i64, i64* %numargs, align 8
  %add1688 = add nsw i64 0, %257
  %mul1689 = mul nsw i64 0, %add1688
  %add1690 = add nsw i64 %mul1689, 0
  %neg1691 = xor i64 %add1690, -1
  %cmp1692 = icmp eq i64 %neg1691, -1
  %conv1693 = zext i1 %cmp1692 to i32
  %sub1694 = sub nsw i32 0, %conv1693
  %conv1695 = sext i32 %sub1694 to i64
  %258 = load i64, i64* %numargs, align 8
  %add1696 = add nsw i64 0, %258
  %mul1697 = mul nsw i64 0, %add1696
  %add1698 = add nsw i64 %mul1697, 1
  %shl1699 = shl i64 %add1698, 62
  %sub1700 = sub nsw i64 %shl1699, 1
  %mul1701 = mul nsw i64 %sub1700, 2
  %add1702 = add nsw i64 %mul1701, 1
  %sub1703 = sub nsw i64 %conv1695, %add1702
  br label %cond.end.1708

cond.false.1704:                                  ; preds = %cond.true.1681
  %259 = load i64, i64* %numargs, align 8
  %add1705 = add nsw i64 0, %259
  %mul1706 = mul nsw i64 0, %add1705
  %add1707 = add nsw i64 %mul1706, 0
  br label %cond.end.1708

cond.end.1708:                                    ; preds = %cond.false.1704, %cond.true.1687
  %cond1709 = phi i64 [ %sub1703, %cond.true.1687 ], [ %add1707, %cond.false.1704 ]
  %div1710 = sdiv i64 %cond1709, 8
  %cmp1711 = icmp slt i64 %255, %div1710
  br i1 %cmp1711, label %cond.true.1750, label %lor.lhs.false.1736

cond.false.1713:                                  ; preds = %cond.false.1678
  %260 = load i64, i64* %numargs, align 8
  %add1714 = add nsw i64 0, %260
  %mul1715 = mul nsw i64 0, %add1714
  %sub1716 = sub nsw i64 %mul1715, 1
  %cmp1717 = icmp slt i64 %sub1716, 0
  br i1 %cmp1717, label %cond.true.1719, label %cond.false.1727

cond.true.1719:                                   ; preds = %cond.false.1713
  %261 = load i64, i64* %numargs, align 8
  %add1720 = add nsw i64 0, %261
  %mul1721 = mul nsw i64 0, %add1720
  %add1722 = add nsw i64 %mul1721, 1
  %shl1723 = shl i64 %add1722, 62
  %sub1724 = sub nsw i64 %shl1723, 1
  %mul1725 = mul nsw i64 %sub1724, 2
  %add1726 = add nsw i64 %mul1725, 1
  br label %cond.end.1731

cond.false.1727:                                  ; preds = %cond.false.1713
  %262 = load i64, i64* %numargs, align 8
  %add1728 = add nsw i64 0, %262
  %mul1729 = mul nsw i64 0, %add1728
  %sub1730 = sub nsw i64 %mul1729, 1
  br label %cond.end.1731

cond.end.1731:                                    ; preds = %cond.false.1727, %cond.true.1719
  %cond1732 = phi i64 [ %add1726, %cond.true.1719 ], [ %sub1730, %cond.false.1727 ]
  %div1733 = sdiv i64 %cond1732, 8
  %263 = load i64, i64* %numargs, align 8
  %cmp1734 = icmp slt i64 %div1733, %263
  br i1 %cmp1734, label %cond.true.1750, label %lor.lhs.false.1736

lor.lhs.false.1736:                               ; preds = %cond.end.1731, %cond.end.1708, %cond.true.1677, %cond.end.1671, %cond.true.1643, %cond.end.1637
  %264 = load i64, i64* %numargs, align 8
  %mul1737 = mul nsw i64 %264, 8
  %mul1738 = mul nsw i64 0, %mul1737
  %sub1739 = sub nsw i64 %mul1738, 1
  %cmp1740 = icmp slt i64 %sub1739, 0
  br i1 %cmp1740, label %land.lhs.true.1742, label %lor.lhs.false.1746

land.lhs.true.1742:                               ; preds = %lor.lhs.false.1736
  %265 = load i64, i64* %numargs, align 8
  %mul1743 = mul nsw i64 %265, 8
  %cmp1744 = icmp slt i64 %mul1743, -9223372036854775808
  br i1 %cmp1744, label %cond.true.1750, label %lor.lhs.false.1746

lor.lhs.false.1746:                               ; preds = %land.lhs.true.1742, %lor.lhs.false.1736
  %266 = load i64, i64* %numargs, align 8
  %mul1747 = mul nsw i64 %266, 8
  %cmp1748 = icmp slt i64 9223372036854775807, %mul1747
  br i1 %cmp1748, label %cond.true.1750, label %cond.false.1762

cond.true.1750:                                   ; preds = %lor.lhs.false.1746, %land.lhs.true.1742, %cond.end.1731, %cond.end.1708, %cond.true.1677, %cond.end.1671, %cond.true.1643, %cond.end.1637, %land.lhs.true.1612
  %267 = load i64, i64* %numargs, align 8
  %mul1751 = mul i64 %267, 8
  %cmp1752 = icmp ule i64 %mul1751, 9223372036854775807
  br i1 %cmp1752, label %cond.true.1754, label %cond.false.1756

cond.true.1754:                                   ; preds = %cond.true.1750
  %268 = load i64, i64* %numargs, align 8
  %mul1755 = mul i64 %268, 8
  br label %cond.end.1760

cond.false.1756:                                  ; preds = %cond.true.1750
  %269 = load i64, i64* %numargs, align 8
  %mul1757 = mul i64 %269, 8
  %sub1758 = sub i64 %mul1757, -9223372036854775808
  %add1759 = add nsw i64 %sub1758, -9223372036854775808
  br label %cond.end.1760

cond.end.1760:                                    ; preds = %cond.false.1756, %cond.true.1754
  %cond1761 = phi i64 [ %mul1755, %cond.true.1754 ], [ %add1759, %cond.false.1756 ]
  store i64 %cond1761, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then, label %lor.lhs.false.2161

cond.false.1762:                                  ; preds = %lor.lhs.false.1746
  %270 = load i64, i64* %numargs, align 8
  %mul1763 = mul i64 %270, 8
  %cmp1764 = icmp ule i64 %mul1763, 9223372036854775807
  br i1 %cmp1764, label %cond.true.1766, label %cond.false.1768

cond.true.1766:                                   ; preds = %cond.false.1762
  %271 = load i64, i64* %numargs, align 8
  %mul1767 = mul i64 %271, 8
  br label %cond.end.1772

cond.false.1768:                                  ; preds = %cond.false.1762
  %272 = load i64, i64* %numargs, align 8
  %mul1769 = mul i64 %272, 8
  %sub1770 = sub i64 %mul1769, -9223372036854775808
  %add1771 = add nsw i64 %sub1770, -9223372036854775808
  br label %cond.end.1772

cond.end.1772:                                    ; preds = %cond.false.1768, %cond.true.1766
  %cond1773 = phi i64 [ %mul1767, %cond.true.1766 ], [ %add1771, %cond.false.1768 ]
  store i64 %cond1773, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then, label %lor.lhs.false.2161

cond.false.1774:                                  ; preds = %cond.false.1386
  br i1 false, label %cond.true.1775, label %cond.false.1968

cond.true.1775:                                   ; preds = %cond.false.1774
  %273 = load i64, i64* %numargs, align 8
  %add1776 = add nsw i64 0, %273
  %mul1777 = mul nsw i64 0, %add1776
  %sub1778 = sub nsw i64 %mul1777, 1
  %cmp1779 = icmp slt i64 %sub1778, 0
  br i1 %cmp1779, label %cond.true.1781, label %cond.false.1798

cond.true.1781:                                   ; preds = %cond.true.1775
  %274 = load i64, i64* %numargs, align 8
  %add1782 = add nsw i64 0, %274
  %mul1783 = mul nsw i64 0, %add1782
  %add1784 = add nsw i64 %mul1783, 0
  %neg1785 = xor i64 %add1784, -1
  %cmp1786 = icmp eq i64 %neg1785, -1
  %conv1787 = zext i1 %cmp1786 to i32
  %sub1788 = sub nsw i32 0, %conv1787
  %conv1789 = sext i32 %sub1788 to i64
  %275 = load i64, i64* %numargs, align 8
  %add1790 = add nsw i64 0, %275
  %mul1791 = mul nsw i64 0, %add1790
  %add1792 = add nsw i64 %mul1791, 1
  %shl1793 = shl i64 %add1792, 62
  %sub1794 = sub nsw i64 %shl1793, 1
  %mul1795 = mul nsw i64 %sub1794, 2
  %add1796 = add nsw i64 %mul1795, 1
  %sub1797 = sub nsw i64 %conv1789, %add1796
  br label %cond.end.1802

cond.false.1798:                                  ; preds = %cond.true.1775
  %276 = load i64, i64* %numargs, align 8
  %add1799 = add nsw i64 0, %276
  %mul1800 = mul nsw i64 0, %add1799
  %add1801 = add nsw i64 %mul1800, 0
  br label %cond.end.1802

cond.end.1802:                                    ; preds = %cond.false.1798, %cond.true.1781
  %cond1803 = phi i64 [ %sub1797, %cond.true.1781 ], [ %add1801, %cond.false.1798 ]
  %cmp1804 = icmp eq i64 %cond1803, 0
  br i1 %cmp1804, label %land.lhs.true.1806, label %lor.lhs.false.1809

land.lhs.true.1806:                               ; preds = %cond.end.1802
  %277 = load i64, i64* %numargs, align 8
  %cmp1807 = icmp slt i64 %277, 0
  br i1 %cmp1807, label %cond.true.1944, label %lor.lhs.false.1809

lor.lhs.false.1809:                               ; preds = %land.lhs.true.1806, %cond.end.1802
  br i1 false, label %cond.true.1810, label %cond.false.1870

cond.true.1810:                                   ; preds = %lor.lhs.false.1809
  %278 = load i64, i64* %numargs, align 8
  %cmp1811 = icmp slt i64 %278, 0
  br i1 %cmp1811, label %cond.true.1813, label %cond.false.1836

cond.true.1813:                                   ; preds = %cond.true.1810
  %279 = load i64, i64* %numargs, align 8
  %280 = load i64, i64* %numargs, align 8
  %add1814 = add nsw i64 0, %280
  %mul1815 = mul nsw i64 0, %add1814
  %sub1816 = sub nsw i64 %mul1815, 1
  %cmp1817 = icmp slt i64 %sub1816, 0
  br i1 %cmp1817, label %cond.true.1819, label %cond.false.1827

cond.true.1819:                                   ; preds = %cond.true.1813
  %281 = load i64, i64* %numargs, align 8
  %add1820 = add nsw i64 0, %281
  %mul1821 = mul nsw i64 0, %add1820
  %add1822 = add nsw i64 %mul1821, 1
  %shl1823 = shl i64 %add1822, 62
  %sub1824 = sub nsw i64 %shl1823, 1
  %mul1825 = mul nsw i64 %sub1824, 2
  %add1826 = add nsw i64 %mul1825, 1
  br label %cond.end.1831

cond.false.1827:                                  ; preds = %cond.true.1813
  %282 = load i64, i64* %numargs, align 8
  %add1828 = add nsw i64 0, %282
  %mul1829 = mul nsw i64 0, %add1828
  %sub1830 = sub nsw i64 %mul1829, 1
  br label %cond.end.1831

cond.end.1831:                                    ; preds = %cond.false.1827, %cond.true.1819
  %cond1832 = phi i64 [ %add1826, %cond.true.1819 ], [ %sub1830, %cond.false.1827 ]
  %div1833 = sdiv i64 %cond1832, 8
  %cmp1834 = icmp slt i64 %279, %div1833
  br i1 %cmp1834, label %cond.true.1944, label %lor.lhs.false.1930

cond.false.1836:                                  ; preds = %cond.true.1810
  br i1 false, label %cond.true.1837, label %cond.false.1838

cond.true.1837:                                   ; preds = %cond.false.1836
  br i1 false, label %cond.true.1944, label %lor.lhs.false.1930

cond.false.1838:                                  ; preds = %cond.false.1836
  %283 = load i64, i64* %numargs, align 8
  %add1839 = add nsw i64 0, %283
  %mul1840 = mul nsw i64 0, %add1839
  %sub1841 = sub nsw i64 %mul1840, 1
  %cmp1842 = icmp slt i64 %sub1841, 0
  br i1 %cmp1842, label %cond.true.1844, label %cond.false.1861

cond.true.1844:                                   ; preds = %cond.false.1838
  %284 = load i64, i64* %numargs, align 8
  %add1845 = add nsw i64 0, %284
  %mul1846 = mul nsw i64 0, %add1845
  %add1847 = add nsw i64 %mul1846, 0
  %neg1848 = xor i64 %add1847, -1
  %cmp1849 = icmp eq i64 %neg1848, -1
  %conv1850 = zext i1 %cmp1849 to i32
  %sub1851 = sub nsw i32 0, %conv1850
  %conv1852 = sext i32 %sub1851 to i64
  %285 = load i64, i64* %numargs, align 8
  %add1853 = add nsw i64 0, %285
  %mul1854 = mul nsw i64 0, %add1853
  %add1855 = add nsw i64 %mul1854, 1
  %shl1856 = shl i64 %add1855, 62
  %sub1857 = sub nsw i64 %shl1856, 1
  %mul1858 = mul nsw i64 %sub1857, 2
  %add1859 = add nsw i64 %mul1858, 1
  %sub1860 = sub nsw i64 %conv1852, %add1859
  br label %cond.end.1865

cond.false.1861:                                  ; preds = %cond.false.1838
  %286 = load i64, i64* %numargs, align 8
  %add1862 = add nsw i64 0, %286
  %mul1863 = mul nsw i64 0, %add1862
  %add1864 = add nsw i64 %mul1863, 0
  br label %cond.end.1865

cond.end.1865:                                    ; preds = %cond.false.1861, %cond.true.1844
  %cond1866 = phi i64 [ %sub1860, %cond.true.1844 ], [ %add1864, %cond.false.1861 ]
  %div1867 = sdiv i64 %cond1866, 8
  %287 = load i64, i64* %numargs, align 8
  %cmp1868 = icmp slt i64 %div1867, %287
  br i1 %cmp1868, label %cond.true.1944, label %lor.lhs.false.1930

cond.false.1870:                                  ; preds = %lor.lhs.false.1809
  br i1 false, label %cond.true.1871, label %cond.false.1872

cond.true.1871:                                   ; preds = %cond.false.1870
  br i1 false, label %cond.true.1944, label %lor.lhs.false.1930

cond.false.1872:                                  ; preds = %cond.false.1870
  %288 = load i64, i64* %numargs, align 8
  %cmp1873 = icmp slt i64 %288, 0
  br i1 %cmp1873, label %cond.true.1875, label %cond.false.1907

cond.true.1875:                                   ; preds = %cond.false.1872
  %289 = load i64, i64* %numargs, align 8
  %290 = load i64, i64* %numargs, align 8
  %add1876 = add nsw i64 0, %290
  %mul1877 = mul nsw i64 0, %add1876
  %sub1878 = sub nsw i64 %mul1877, 1
  %cmp1879 = icmp slt i64 %sub1878, 0
  br i1 %cmp1879, label %cond.true.1881, label %cond.false.1898

cond.true.1881:                                   ; preds = %cond.true.1875
  %291 = load i64, i64* %numargs, align 8
  %add1882 = add nsw i64 0, %291
  %mul1883 = mul nsw i64 0, %add1882
  %add1884 = add nsw i64 %mul1883, 0
  %neg1885 = xor i64 %add1884, -1
  %cmp1886 = icmp eq i64 %neg1885, -1
  %conv1887 = zext i1 %cmp1886 to i32
  %sub1888 = sub nsw i32 0, %conv1887
  %conv1889 = sext i32 %sub1888 to i64
  %292 = load i64, i64* %numargs, align 8
  %add1890 = add nsw i64 0, %292
  %mul1891 = mul nsw i64 0, %add1890
  %add1892 = add nsw i64 %mul1891, 1
  %shl1893 = shl i64 %add1892, 62
  %sub1894 = sub nsw i64 %shl1893, 1
  %mul1895 = mul nsw i64 %sub1894, 2
  %add1896 = add nsw i64 %mul1895, 1
  %sub1897 = sub nsw i64 %conv1889, %add1896
  br label %cond.end.1902

cond.false.1898:                                  ; preds = %cond.true.1875
  %293 = load i64, i64* %numargs, align 8
  %add1899 = add nsw i64 0, %293
  %mul1900 = mul nsw i64 0, %add1899
  %add1901 = add nsw i64 %mul1900, 0
  br label %cond.end.1902

cond.end.1902:                                    ; preds = %cond.false.1898, %cond.true.1881
  %cond1903 = phi i64 [ %sub1897, %cond.true.1881 ], [ %add1901, %cond.false.1898 ]
  %div1904 = sdiv i64 %cond1903, 8
  %cmp1905 = icmp slt i64 %289, %div1904
  br i1 %cmp1905, label %cond.true.1944, label %lor.lhs.false.1930

cond.false.1907:                                  ; preds = %cond.false.1872
  %294 = load i64, i64* %numargs, align 8
  %add1908 = add nsw i64 0, %294
  %mul1909 = mul nsw i64 0, %add1908
  %sub1910 = sub nsw i64 %mul1909, 1
  %cmp1911 = icmp slt i64 %sub1910, 0
  br i1 %cmp1911, label %cond.true.1913, label %cond.false.1921

cond.true.1913:                                   ; preds = %cond.false.1907
  %295 = load i64, i64* %numargs, align 8
  %add1914 = add nsw i64 0, %295
  %mul1915 = mul nsw i64 0, %add1914
  %add1916 = add nsw i64 %mul1915, 1
  %shl1917 = shl i64 %add1916, 62
  %sub1918 = sub nsw i64 %shl1917, 1
  %mul1919 = mul nsw i64 %sub1918, 2
  %add1920 = add nsw i64 %mul1919, 1
  br label %cond.end.1925

cond.false.1921:                                  ; preds = %cond.false.1907
  %296 = load i64, i64* %numargs, align 8
  %add1922 = add nsw i64 0, %296
  %mul1923 = mul nsw i64 0, %add1922
  %sub1924 = sub nsw i64 %mul1923, 1
  br label %cond.end.1925

cond.end.1925:                                    ; preds = %cond.false.1921, %cond.true.1913
  %cond1926 = phi i64 [ %add1920, %cond.true.1913 ], [ %sub1924, %cond.false.1921 ]
  %div1927 = sdiv i64 %cond1926, 8
  %297 = load i64, i64* %numargs, align 8
  %cmp1928 = icmp slt i64 %div1927, %297
  br i1 %cmp1928, label %cond.true.1944, label %lor.lhs.false.1930

lor.lhs.false.1930:                               ; preds = %cond.end.1925, %cond.end.1902, %cond.true.1871, %cond.end.1865, %cond.true.1837, %cond.end.1831
  %298 = load i64, i64* %numargs, align 8
  %mul1931 = mul nsw i64 %298, 8
  %mul1932 = mul nsw i64 0, %mul1931
  %sub1933 = sub nsw i64 %mul1932, 1
  %cmp1934 = icmp slt i64 %sub1933, 0
  br i1 %cmp1934, label %land.lhs.true.1936, label %lor.lhs.false.1940

land.lhs.true.1936:                               ; preds = %lor.lhs.false.1930
  %299 = load i64, i64* %numargs, align 8
  %mul1937 = mul nsw i64 %299, 8
  %cmp1938 = icmp slt i64 %mul1937, -9223372036854775808
  br i1 %cmp1938, label %cond.true.1944, label %lor.lhs.false.1940

lor.lhs.false.1940:                               ; preds = %land.lhs.true.1936, %lor.lhs.false.1930
  %300 = load i64, i64* %numargs, align 8
  %mul1941 = mul nsw i64 %300, 8
  %cmp1942 = icmp slt i64 9223372036854775807, %mul1941
  br i1 %cmp1942, label %cond.true.1944, label %cond.false.1956

cond.true.1944:                                   ; preds = %lor.lhs.false.1940, %land.lhs.true.1936, %cond.end.1925, %cond.end.1902, %cond.true.1871, %cond.end.1865, %cond.true.1837, %cond.end.1831, %land.lhs.true.1806
  %301 = load i64, i64* %numargs, align 8
  %mul1945 = mul i64 %301, 8
  %cmp1946 = icmp ule i64 %mul1945, 9223372036854775807
  br i1 %cmp1946, label %cond.true.1948, label %cond.false.1950

cond.true.1948:                                   ; preds = %cond.true.1944
  %302 = load i64, i64* %numargs, align 8
  %mul1949 = mul i64 %302, 8
  br label %cond.end.1954

cond.false.1950:                                  ; preds = %cond.true.1944
  %303 = load i64, i64* %numargs, align 8
  %mul1951 = mul i64 %303, 8
  %sub1952 = sub i64 %mul1951, -9223372036854775808
  %add1953 = add nsw i64 %sub1952, -9223372036854775808
  br label %cond.end.1954

cond.end.1954:                                    ; preds = %cond.false.1950, %cond.true.1948
  %cond1955 = phi i64 [ %mul1949, %cond.true.1948 ], [ %add1953, %cond.false.1950 ]
  store i64 %cond1955, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then, label %lor.lhs.false.2161

cond.false.1956:                                  ; preds = %lor.lhs.false.1940
  %304 = load i64, i64* %numargs, align 8
  %mul1957 = mul i64 %304, 8
  %cmp1958 = icmp ule i64 %mul1957, 9223372036854775807
  br i1 %cmp1958, label %cond.true.1960, label %cond.false.1962

cond.true.1960:                                   ; preds = %cond.false.1956
  %305 = load i64, i64* %numargs, align 8
  %mul1961 = mul i64 %305, 8
  br label %cond.end.1966

cond.false.1962:                                  ; preds = %cond.false.1956
  %306 = load i64, i64* %numargs, align 8
  %mul1963 = mul i64 %306, 8
  %sub1964 = sub i64 %mul1963, -9223372036854775808
  %add1965 = add nsw i64 %sub1964, -9223372036854775808
  br label %cond.end.1966

cond.end.1966:                                    ; preds = %cond.false.1962, %cond.true.1960
  %cond1967 = phi i64 [ %mul1961, %cond.true.1960 ], [ %add1965, %cond.false.1962 ]
  store i64 %cond1967, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then, label %lor.lhs.false.2161

cond.false.1968:                                  ; preds = %cond.false.1774
  %307 = load i64, i64* %numargs, align 8
  %add1969 = add nsw i64 0, %307
  %mul1970 = mul nsw i64 0, %add1969
  %sub1971 = sub nsw i64 %mul1970, 1
  %cmp1972 = icmp slt i64 %sub1971, 0
  br i1 %cmp1972, label %cond.true.1974, label %cond.false.1991

cond.true.1974:                                   ; preds = %cond.false.1968
  %308 = load i64, i64* %numargs, align 8
  %add1975 = add nsw i64 0, %308
  %mul1976 = mul nsw i64 0, %add1975
  %add1977 = add nsw i64 %mul1976, 0
  %neg1978 = xor i64 %add1977, -1
  %cmp1979 = icmp eq i64 %neg1978, -1
  %conv1980 = zext i1 %cmp1979 to i32
  %sub1981 = sub nsw i32 0, %conv1980
  %conv1982 = sext i32 %sub1981 to i64
  %309 = load i64, i64* %numargs, align 8
  %add1983 = add nsw i64 0, %309
  %mul1984 = mul nsw i64 0, %add1983
  %add1985 = add nsw i64 %mul1984, 1
  %shl1986 = shl i64 %add1985, 62
  %sub1987 = sub nsw i64 %shl1986, 1
  %mul1988 = mul nsw i64 %sub1987, 2
  %add1989 = add nsw i64 %mul1988, 1
  %sub1990 = sub nsw i64 %conv1982, %add1989
  br label %cond.end.1995

cond.false.1991:                                  ; preds = %cond.false.1968
  %310 = load i64, i64* %numargs, align 8
  %add1992 = add nsw i64 0, %310
  %mul1993 = mul nsw i64 0, %add1992
  %add1994 = add nsw i64 %mul1993, 0
  br label %cond.end.1995

cond.end.1995:                                    ; preds = %cond.false.1991, %cond.true.1974
  %cond1996 = phi i64 [ %sub1990, %cond.true.1974 ], [ %add1994, %cond.false.1991 ]
  %cmp1997 = icmp eq i64 %cond1996, 0
  br i1 %cmp1997, label %land.lhs.true.1999, label %lor.lhs.false.2002

land.lhs.true.1999:                               ; preds = %cond.end.1995
  %311 = load i64, i64* %numargs, align 8
  %cmp2000 = icmp slt i64 %311, 0
  br i1 %cmp2000, label %cond.true.2137, label %lor.lhs.false.2002

lor.lhs.false.2002:                               ; preds = %land.lhs.true.1999, %cond.end.1995
  br i1 false, label %cond.true.2003, label %cond.false.2063

cond.true.2003:                                   ; preds = %lor.lhs.false.2002
  %312 = load i64, i64* %numargs, align 8
  %cmp2004 = icmp slt i64 %312, 0
  br i1 %cmp2004, label %cond.true.2006, label %cond.false.2029

cond.true.2006:                                   ; preds = %cond.true.2003
  %313 = load i64, i64* %numargs, align 8
  %314 = load i64, i64* %numargs, align 8
  %add2007 = add nsw i64 0, %314
  %mul2008 = mul nsw i64 0, %add2007
  %sub2009 = sub nsw i64 %mul2008, 1
  %cmp2010 = icmp slt i64 %sub2009, 0
  br i1 %cmp2010, label %cond.true.2012, label %cond.false.2020

cond.true.2012:                                   ; preds = %cond.true.2006
  %315 = load i64, i64* %numargs, align 8
  %add2013 = add nsw i64 0, %315
  %mul2014 = mul nsw i64 0, %add2013
  %add2015 = add nsw i64 %mul2014, 1
  %shl2016 = shl i64 %add2015, 62
  %sub2017 = sub nsw i64 %shl2016, 1
  %mul2018 = mul nsw i64 %sub2017, 2
  %add2019 = add nsw i64 %mul2018, 1
  br label %cond.end.2024

cond.false.2020:                                  ; preds = %cond.true.2006
  %316 = load i64, i64* %numargs, align 8
  %add2021 = add nsw i64 0, %316
  %mul2022 = mul nsw i64 0, %add2021
  %sub2023 = sub nsw i64 %mul2022, 1
  br label %cond.end.2024

cond.end.2024:                                    ; preds = %cond.false.2020, %cond.true.2012
  %cond2025 = phi i64 [ %add2019, %cond.true.2012 ], [ %sub2023, %cond.false.2020 ]
  %div2026 = sdiv i64 %cond2025, 8
  %cmp2027 = icmp slt i64 %313, %div2026
  br i1 %cmp2027, label %cond.true.2137, label %lor.lhs.false.2123

cond.false.2029:                                  ; preds = %cond.true.2003
  br i1 false, label %cond.true.2030, label %cond.false.2031

cond.true.2030:                                   ; preds = %cond.false.2029
  br i1 false, label %cond.true.2137, label %lor.lhs.false.2123

cond.false.2031:                                  ; preds = %cond.false.2029
  %317 = load i64, i64* %numargs, align 8
  %add2032 = add nsw i64 0, %317
  %mul2033 = mul nsw i64 0, %add2032
  %sub2034 = sub nsw i64 %mul2033, 1
  %cmp2035 = icmp slt i64 %sub2034, 0
  br i1 %cmp2035, label %cond.true.2037, label %cond.false.2054

cond.true.2037:                                   ; preds = %cond.false.2031
  %318 = load i64, i64* %numargs, align 8
  %add2038 = add nsw i64 0, %318
  %mul2039 = mul nsw i64 0, %add2038
  %add2040 = add nsw i64 %mul2039, 0
  %neg2041 = xor i64 %add2040, -1
  %cmp2042 = icmp eq i64 %neg2041, -1
  %conv2043 = zext i1 %cmp2042 to i32
  %sub2044 = sub nsw i32 0, %conv2043
  %conv2045 = sext i32 %sub2044 to i64
  %319 = load i64, i64* %numargs, align 8
  %add2046 = add nsw i64 0, %319
  %mul2047 = mul nsw i64 0, %add2046
  %add2048 = add nsw i64 %mul2047, 1
  %shl2049 = shl i64 %add2048, 62
  %sub2050 = sub nsw i64 %shl2049, 1
  %mul2051 = mul nsw i64 %sub2050, 2
  %add2052 = add nsw i64 %mul2051, 1
  %sub2053 = sub nsw i64 %conv2045, %add2052
  br label %cond.end.2058

cond.false.2054:                                  ; preds = %cond.false.2031
  %320 = load i64, i64* %numargs, align 8
  %add2055 = add nsw i64 0, %320
  %mul2056 = mul nsw i64 0, %add2055
  %add2057 = add nsw i64 %mul2056, 0
  br label %cond.end.2058

cond.end.2058:                                    ; preds = %cond.false.2054, %cond.true.2037
  %cond2059 = phi i64 [ %sub2053, %cond.true.2037 ], [ %add2057, %cond.false.2054 ]
  %div2060 = sdiv i64 %cond2059, 8
  %321 = load i64, i64* %numargs, align 8
  %cmp2061 = icmp slt i64 %div2060, %321
  br i1 %cmp2061, label %cond.true.2137, label %lor.lhs.false.2123

cond.false.2063:                                  ; preds = %lor.lhs.false.2002
  br i1 false, label %cond.true.2064, label %cond.false.2065

cond.true.2064:                                   ; preds = %cond.false.2063
  br i1 false, label %cond.true.2137, label %lor.lhs.false.2123

cond.false.2065:                                  ; preds = %cond.false.2063
  %322 = load i64, i64* %numargs, align 8
  %cmp2066 = icmp slt i64 %322, 0
  br i1 %cmp2066, label %cond.true.2068, label %cond.false.2100

cond.true.2068:                                   ; preds = %cond.false.2065
  %323 = load i64, i64* %numargs, align 8
  %324 = load i64, i64* %numargs, align 8
  %add2069 = add nsw i64 0, %324
  %mul2070 = mul nsw i64 0, %add2069
  %sub2071 = sub nsw i64 %mul2070, 1
  %cmp2072 = icmp slt i64 %sub2071, 0
  br i1 %cmp2072, label %cond.true.2074, label %cond.false.2091

cond.true.2074:                                   ; preds = %cond.true.2068
  %325 = load i64, i64* %numargs, align 8
  %add2075 = add nsw i64 0, %325
  %mul2076 = mul nsw i64 0, %add2075
  %add2077 = add nsw i64 %mul2076, 0
  %neg2078 = xor i64 %add2077, -1
  %cmp2079 = icmp eq i64 %neg2078, -1
  %conv2080 = zext i1 %cmp2079 to i32
  %sub2081 = sub nsw i32 0, %conv2080
  %conv2082 = sext i32 %sub2081 to i64
  %326 = load i64, i64* %numargs, align 8
  %add2083 = add nsw i64 0, %326
  %mul2084 = mul nsw i64 0, %add2083
  %add2085 = add nsw i64 %mul2084, 1
  %shl2086 = shl i64 %add2085, 62
  %sub2087 = sub nsw i64 %shl2086, 1
  %mul2088 = mul nsw i64 %sub2087, 2
  %add2089 = add nsw i64 %mul2088, 1
  %sub2090 = sub nsw i64 %conv2082, %add2089
  br label %cond.end.2095

cond.false.2091:                                  ; preds = %cond.true.2068
  %327 = load i64, i64* %numargs, align 8
  %add2092 = add nsw i64 0, %327
  %mul2093 = mul nsw i64 0, %add2092
  %add2094 = add nsw i64 %mul2093, 0
  br label %cond.end.2095

cond.end.2095:                                    ; preds = %cond.false.2091, %cond.true.2074
  %cond2096 = phi i64 [ %sub2090, %cond.true.2074 ], [ %add2094, %cond.false.2091 ]
  %div2097 = sdiv i64 %cond2096, 8
  %cmp2098 = icmp slt i64 %323, %div2097
  br i1 %cmp2098, label %cond.true.2137, label %lor.lhs.false.2123

cond.false.2100:                                  ; preds = %cond.false.2065
  %328 = load i64, i64* %numargs, align 8
  %add2101 = add nsw i64 0, %328
  %mul2102 = mul nsw i64 0, %add2101
  %sub2103 = sub nsw i64 %mul2102, 1
  %cmp2104 = icmp slt i64 %sub2103, 0
  br i1 %cmp2104, label %cond.true.2106, label %cond.false.2114

cond.true.2106:                                   ; preds = %cond.false.2100
  %329 = load i64, i64* %numargs, align 8
  %add2107 = add nsw i64 0, %329
  %mul2108 = mul nsw i64 0, %add2107
  %add2109 = add nsw i64 %mul2108, 1
  %shl2110 = shl i64 %add2109, 62
  %sub2111 = sub nsw i64 %shl2110, 1
  %mul2112 = mul nsw i64 %sub2111, 2
  %add2113 = add nsw i64 %mul2112, 1
  br label %cond.end.2118

cond.false.2114:                                  ; preds = %cond.false.2100
  %330 = load i64, i64* %numargs, align 8
  %add2115 = add nsw i64 0, %330
  %mul2116 = mul nsw i64 0, %add2115
  %sub2117 = sub nsw i64 %mul2116, 1
  br label %cond.end.2118

cond.end.2118:                                    ; preds = %cond.false.2114, %cond.true.2106
  %cond2119 = phi i64 [ %add2113, %cond.true.2106 ], [ %sub2117, %cond.false.2114 ]
  %div2120 = sdiv i64 %cond2119, 8
  %331 = load i64, i64* %numargs, align 8
  %cmp2121 = icmp slt i64 %div2120, %331
  br i1 %cmp2121, label %cond.true.2137, label %lor.lhs.false.2123

lor.lhs.false.2123:                               ; preds = %cond.end.2118, %cond.end.2095, %cond.true.2064, %cond.end.2058, %cond.true.2030, %cond.end.2024
  %332 = load i64, i64* %numargs, align 8
  %mul2124 = mul nsw i64 %332, 8
  %mul2125 = mul nsw i64 0, %mul2124
  %sub2126 = sub nsw i64 %mul2125, 1
  %cmp2127 = icmp slt i64 %sub2126, 0
  br i1 %cmp2127, label %land.lhs.true.2129, label %lor.lhs.false.2133

land.lhs.true.2129:                               ; preds = %lor.lhs.false.2123
  %333 = load i64, i64* %numargs, align 8
  %mul2130 = mul nsw i64 %333, 8
  %cmp2131 = icmp slt i64 %mul2130, -9223372036854775808
  br i1 %cmp2131, label %cond.true.2137, label %lor.lhs.false.2133

lor.lhs.false.2133:                               ; preds = %land.lhs.true.2129, %lor.lhs.false.2123
  %334 = load i64, i64* %numargs, align 8
  %mul2134 = mul nsw i64 %334, 8
  %cmp2135 = icmp slt i64 9223372036854775807, %mul2134
  br i1 %cmp2135, label %cond.true.2137, label %cond.false.2149

cond.true.2137:                                   ; preds = %lor.lhs.false.2133, %land.lhs.true.2129, %cond.end.2118, %cond.end.2095, %cond.true.2064, %cond.end.2058, %cond.true.2030, %cond.end.2024, %land.lhs.true.1999
  %335 = load i64, i64* %numargs, align 8
  %mul2138 = mul i64 %335, 8
  %cmp2139 = icmp ule i64 %mul2138, 9223372036854775807
  br i1 %cmp2139, label %cond.true.2141, label %cond.false.2143

cond.true.2141:                                   ; preds = %cond.true.2137
  %336 = load i64, i64* %numargs, align 8
  %mul2142 = mul i64 %336, 8
  br label %cond.end.2147

cond.false.2143:                                  ; preds = %cond.true.2137
  %337 = load i64, i64* %numargs, align 8
  %mul2144 = mul i64 %337, 8
  %sub2145 = sub i64 %mul2144, -9223372036854775808
  %add2146 = add nsw i64 %sub2145, -9223372036854775808
  br label %cond.end.2147

cond.end.2147:                                    ; preds = %cond.false.2143, %cond.true.2141
  %cond2148 = phi i64 [ %mul2142, %cond.true.2141 ], [ %add2146, %cond.false.2143 ]
  store i64 %cond2148, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then, label %lor.lhs.false.2161

cond.false.2149:                                  ; preds = %lor.lhs.false.2133
  %338 = load i64, i64* %numargs, align 8
  %mul2150 = mul i64 %338, 8
  %cmp2151 = icmp ule i64 %mul2150, 9223372036854775807
  br i1 %cmp2151, label %cond.true.2153, label %cond.false.2155

cond.true.2153:                                   ; preds = %cond.false.2149
  %339 = load i64, i64* %numargs, align 8
  %mul2154 = mul i64 %339, 8
  br label %cond.end.2159

cond.false.2155:                                  ; preds = %cond.false.2149
  %340 = load i64, i64* %numargs, align 8
  %mul2156 = mul i64 %340, 8
  %sub2157 = sub i64 %mul2156, -9223372036854775808
  %add2158 = add nsw i64 %sub2157, -9223372036854775808
  br label %cond.end.2159

cond.end.2159:                                    ; preds = %cond.false.2155, %cond.true.2153
  %cond2160 = phi i64 [ %mul2154, %cond.true.2153 ], [ %add2158, %cond.false.2155 ]
  store i64 %cond2160, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then, label %lor.lhs.false.2161

lor.lhs.false.2161:                               ; preds = %cond.end.2159, %cond.end.2147, %cond.end.1966, %cond.end.1954, %cond.end.1772, %cond.end.1760, %cond.end.1579, %cond.end.1567, %cond.end.1383, %cond.end.1367, %cond.end.1182, %cond.end.1166, %cond.end.954, %cond.end.931, %cond.end.739, %cond.end.716, %cond.end.469, %cond.end.446, %cond.end.254, %cond.end.231
  %341 = load i64, i64* %alloca_nbytes, align 8
  %cmp2162 = icmp ult i64 -1, %341
  br i1 %cmp2162, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false.2161, %cond.end.2159, %cond.end.2147, %cond.end.1966, %cond.end.1954, %cond.end.1772, %cond.end.1760, %cond.end.1579, %cond.end.1567, %cond.end.1383, %cond.end.1367, %cond.end.1182, %cond.end.1166, %cond.end.954, %cond.end.931, %cond.end.739, %cond.end.716, %cond.end.469, %cond.end.446, %cond.end.254, %cond.end.231
  call void @memory_full(i64 -1) #8
  unreachable

if.else:                                          ; preds = %lor.lhs.false.2161
  %342 = load i64, i64* %alloca_nbytes, align 8
  %343 = load i64, i64* %sa_avail, align 8
  %cmp2164 = icmp sle i64 %342, %343
  br i1 %cmp2164, label %if.then.2166, label %if.else.2168

if.then.2166:                                     ; preds = %if.else
  %344 = load i64, i64* %alloca_nbytes, align 8
  %345 = load i64, i64* %sa_avail, align 8
  %sub2167 = sub nsw i64 %345, %344
  store i64 %sub2167, i64* %sa_avail, align 8
  %346 = load i64, i64* %alloca_nbytes, align 8
  %347 = alloca i8, i64 %346
  %348 = bitcast i8* %347 to i64*
  store i64* %348, i64** %arg_vector, align 8
  br label %if.end

if.else.2168:                                     ; preds = %if.else
  %349 = load i64, i64* %alloca_nbytes, align 8
  %call2169 = call noalias i8* @xmalloc(i64 %349)
  %350 = bitcast i8* %call2169 to i64*
  store i64* %350, i64** %arg_vector, align 8
  %351 = load i64*, i64** %arg_vector, align 8
  %352 = load i64, i64* %numargs, align 8
  %call2170 = call i64 @make_save_memory(i64* %351, i64 %352)
  store i64 %call2170, i64* %arg_, align 8
  store i8 1, i8* %sa_must_free, align 1
  %353 = load i64, i64* %arg_, align 8
  call void @record_unwind_protect(void (i64)* @free_save_value, i64 %353)
  br label %if.end

if.end:                                           ; preds = %if.else.2168, %if.then.2166
  br label %if.end.2171

if.end.2171:                                      ; preds = %if.end
  br label %do.end

do.end:                                           ; preds = %if.end.2171
  %354 = load i64, i64* %args.addr, align 8
  store i64 %354, i64* %args_left, align 8
  store i64 0, i64* %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.body, %do.end
  %355 = load i64, i64* %i, align 8
  %356 = load i64, i64* %numargs, align 8
  %cmp2172 = icmp slt i64 %355, %356
  br i1 %cmp2172, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %357 = load i64, i64* %args_left, align 8
  %call2174 = call i64 @Fcar(i64 %357)
  store i64 %call2174, i64* %tem, align 8
  %358 = load i64, i64* %args_left, align 8
  %call2175 = call i64 @Fcdr(i64 %358)
  store i64 %call2175, i64* %args_left, align 8
  %359 = load i64, i64* %tem, align 8
  %call2176 = call i64 @eval_sub(i64 %359)
  store i64 %call2176, i64* %tem, align 8
  %360 = load i64, i64* %tem, align 8
  %361 = load i64, i64* %i, align 8
  %inc = add nsw i64 %361, 1
  store i64 %inc, i64* %i, align 8
  %362 = load i64*, i64** %arg_vector, align 8
  %arrayidx = getelementptr inbounds i64, i64* %362, i64 %361
  store i64 %360, i64* %arrayidx, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %363 = load %union.specbinding*, %union.specbinding** @specpdl, align 8
  %364 = load i64, i64* %count.addr, align 8
  %add.ptr = getelementptr inbounds %union.specbinding, %union.specbinding* %363, i64 %364
  %365 = load i64*, i64** %arg_vector, align 8
  %366 = load i64, i64* %i, align 8
  call void @set_backtrace_args(%union.specbinding* %add.ptr, i64* %365, i64 %366)
  %367 = load i64, i64* %fun.addr, align 8
  %368 = load i64, i64* %numargs, align 8
  %369 = load i64*, i64** %arg_vector, align 8
  %call2177 = call i64 @funcall_lambda(i64 %367, i64 %368, i64* %369)
  store i64 %call2177, i64* %tem, align 8
  %370 = load i64, i64* @lisp_eval_depth, align 8
  %dec = add nsw i64 %370, -1
  store i64 %dec, i64* @lisp_eval_depth, align 8
  %371 = load %union.specbinding*, %union.specbinding** @specpdl, align 8
  %372 = load i64, i64* %count.addr, align 8
  %add.ptr2178 = getelementptr inbounds %union.specbinding, %union.specbinding* %371, i64 %372
  %call2179 = call zeroext i1 @backtrace_debug_on_exit(%union.specbinding* %add.ptr2178)
  br i1 %call2179, label %if.then.2180, label %if.end.2184

if.then.2180:                                     ; preds = %for.end
  %call2181 = call i64 @builtin_lisp_symbol(i32 387)
  %373 = load i64, i64* %tem, align 8
  %call2182 = call i64 @list2(i64 %call2181, i64 %373)
  %call2183 = call i64 @call_debugger(i64 %call2182)
  store i64 %call2183, i64* %tem, align 8
  br label %if.end.2184

if.end.2184:                                      ; preds = %if.then.2180, %for.end
  br label %do.body.2185

do.body.2185:                                     ; preds = %if.end.2184
  %374 = load i8, i8* %sa_must_free, align 1
  %tobool = trunc i8 %374 to i1
  br i1 %tobool, label %if.then.2186, label %if.end.2189

if.then.2186:                                     ; preds = %do.body.2185
  store i8 0, i8* %sa_must_free, align 1
  %375 = load i64, i64* %sa_count, align 8
  %call2187 = call i64 @builtin_lisp_symbol(i32 0)
  %call2188 = call i64 @unbind_to(i64 %375, i64 %call2187)
  br label %if.end.2189

if.end.2189:                                      ; preds = %if.then.2186, %do.body.2185
  br label %do.end.2190

do.end.2190:                                      ; preds = %if.end.2189
  %376 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %incdec.ptr = getelementptr inbounds %union.specbinding, %union.specbinding* %376, i32 -1
  store %union.specbinding* %incdec.ptr, %union.specbinding** @specpdl_ptr, align 8
  %377 = load i64, i64* %tem, align 8
  ret i64 %377
}

; Function Attrs: nounwind uwtable
define i64 @Fapply(i64 %nargs, i64* %args) #0 {
entry:
  %retval = alloca i64, align 8
  %nargs.addr = alloca i64, align 8
  %args.addr = alloca i64*, align 8
  %i = alloca i64, align 8
  %numargs = alloca i64, align 8
  %funcall_nargs = alloca i64, align 8
  %funcall_args = alloca i64*, align 8
  %spread_arg = alloca i64, align 8
  %fun = alloca i64, align 8
  %retval2 = alloca i64, align 8
  %sa_avail = alloca i64, align 8
  %sa_count = alloca i64, align 8
  %sa_must_free = alloca i8, align 1
  %alloca_nbytes = alloca i64, align 8
  %arg_ = alloca i64, align 8
  %alloca_nbytes3633 = alloca i64, align 8
  %arg_6157 = alloca i64, align 8
  store i64 %nargs, i64* %nargs.addr, align 8
  store i64* %args, i64** %args.addr, align 8
  store i64* null, i64** %funcall_args, align 8
  %0 = load i64, i64* %nargs.addr, align 8
  %sub = sub nsw i64 %0, 1
  %1 = load i64*, i64** %args.addr, align 8
  %arrayidx = getelementptr inbounds i64, i64* %1, i64 %sub
  %2 = load i64, i64* %arrayidx, align 8
  store i64 %2, i64* %spread_arg, align 8
  %3 = load i64*, i64** %args.addr, align 8
  %arrayidx1 = getelementptr inbounds i64, i64* %3, i64 0
  %4 = load i64, i64* %arrayidx1, align 8
  store i64 %4, i64* %fun, align 8
  store i64 16384, i64* %sa_avail, align 8
  %call = call i64 @SPECPDL_INDEX()
  store i64 %call, i64* %sa_count, align 8
  store i8 0, i8* %sa_must_free, align 1
  %5 = load i64, i64* %spread_arg, align 8
  call void @CHECK_LIST(i64 %5)
  %6 = load i64, i64* %spread_arg, align 8
  %call3 = call i64 @Flength(i64 %6)
  %shr = ashr i64 %call3, 2
  store i64 %shr, i64* %numargs, align 8
  %7 = load i64, i64* %numargs, align 8
  %cmp = icmp eq i64 %7, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %8 = load i64, i64* %nargs.addr, align 8
  %sub4 = sub nsw i64 %8, 1
  %9 = load i64*, i64** %args.addr, align 8
  %call5 = call i64 @Ffuncall(i64 %sub4, i64* %9)
  store i64 %call5, i64* %retval
  br label %return

if.else:                                          ; preds = %entry
  %10 = load i64, i64* %numargs, align 8
  %cmp6 = icmp eq i64 %10, 1
  br i1 %cmp6, label %if.then.7, label %if.end

if.then.7:                                        ; preds = %if.else
  %11 = load i64, i64* %spread_arg, align 8
  %sub8 = sub nsw i64 %11, 3
  %12 = inttoptr i64 %sub8 to i8*
  %13 = bitcast i8* %12 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %13, i32 0, i32 0
  %14 = load i64, i64* %car, align 8
  %15 = load i64, i64* %nargs.addr, align 8
  %sub9 = sub nsw i64 %15, 1
  %16 = load i64*, i64** %args.addr, align 8
  %arrayidx10 = getelementptr inbounds i64, i64* %16, i64 %sub9
  store i64 %14, i64* %arrayidx10, align 8
  %17 = load i64, i64* %nargs.addr, align 8
  %18 = load i64*, i64** %args.addr, align 8
  %call11 = call i64 @Ffuncall(i64 %17, i64* %18)
  store i64 %call11, i64* %retval
  br label %return

if.end:                                           ; preds = %if.else
  br label %if.end.12

if.end.12:                                        ; preds = %if.end
  %19 = load i64, i64* %nargs.addr, align 8
  %sub13 = sub nsw i64 %19, 2
  %20 = load i64, i64* %numargs, align 8
  %add = add nsw i64 %20, %sub13
  store i64 %add, i64* %numargs, align 8
  %21 = load i64, i64* %fun, align 8
  %and = and i64 %21, 7
  %conv = trunc i64 %and to i32
  %cmp14 = icmp eq i32 %conv, 0
  br i1 %cmp14, label %land.lhs.true, label %if.end.33

land.lhs.true:                                    ; preds = %if.end.12
  %22 = load i64, i64* %fun, align 8
  %call16 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp17 = icmp eq i64 %22, %call16
  br i1 %cmp17, label %if.end.33, label %land.lhs.true.19

land.lhs.true.19:                                 ; preds = %land.lhs.true
  %23 = load i64, i64* %fun, align 8
  %sub20 = sub nsw i64 %23, 0
  %add.ptr = getelementptr inbounds i8, i8* bitcast ([1074 x %struct.Lisp_Symbol]* @lispsym to i8*), i64 %sub20
  %24 = bitcast i8* %add.ptr to %struct.Lisp_Symbol*
  %function = getelementptr inbounds %struct.Lisp_Symbol, %struct.Lisp_Symbol* %24, i32 0, i32 3
  %25 = load i64, i64* %function, align 8
  store i64 %25, i64* %fun, align 8
  %26 = load i64, i64* %fun, align 8
  %and21 = and i64 %26, 7
  %conv22 = trunc i64 %and21 to i32
  %cmp23 = icmp eq i32 %conv22, 0
  br i1 %cmp23, label %if.then.25, label %if.end.33

if.then.25:                                       ; preds = %land.lhs.true.19
  %27 = load i64, i64* %fun, align 8
  %call26 = call i64 @indirect_function(i64 %27)
  store i64 %call26, i64* %fun, align 8
  %28 = load i64, i64* %fun, align 8
  %call27 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp28 = icmp eq i64 %28, %call27
  br i1 %cmp28, label %if.then.30, label %if.end.32

if.then.30:                                       ; preds = %if.then.25
  %29 = load i64*, i64** %args.addr, align 8
  %arrayidx31 = getelementptr inbounds i64, i64* %29, i64 0
  %30 = load i64, i64* %arrayidx31, align 8
  store i64 %30, i64* %fun, align 8
  br label %if.end.32

if.end.32:                                        ; preds = %if.then.30, %if.then.25
  br label %if.end.33

if.end.33:                                        ; preds = %if.end.32, %land.lhs.true.19, %land.lhs.true, %if.end.12
  %31 = load i64, i64* %fun, align 8
  %call34 = call zeroext i1 @SUBRP(i64 %31)
  br i1 %call34, label %land.lhs.true.36, label %if.else.3631

land.lhs.true.36:                                 ; preds = %if.end.33
  %32 = load i64, i64* %fun, align 8
  %call37 = call %struct.Lisp_Subr* @XSUBR(i64 %32)
  %max_args = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call37, i32 0, i32 3
  %33 = load i16, i16* %max_args, align 2
  %conv38 = sext i16 %33 to i64
  %34 = load i64, i64* %numargs, align 8
  %cmp39 = icmp sgt i64 %conv38, %34
  br i1 %cmp39, label %land.lhs.true.41, label %if.else.3631

land.lhs.true.41:                                 ; preds = %land.lhs.true.36
  %35 = load i64, i64* %numargs, align 8
  %36 = load i64, i64* %fun, align 8
  %call42 = call %struct.Lisp_Subr* @XSUBR(i64 %36)
  %min_args = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call42, i32 0, i32 2
  %37 = load i16, i16* %min_args, align 2
  %conv43 = sext i16 %37 to i64
  %cmp44 = icmp sge i64 %35, %conv43
  br i1 %cmp44, label %if.then.46, label %if.else.3631

if.then.46:                                       ; preds = %land.lhs.true.41
  br label %do.body

do.body:                                          ; preds = %if.then.46
  br i1 false, label %cond.true, label %cond.false.791

cond.true:                                        ; preds = %do.body
  br i1 false, label %cond.true.47, label %cond.false.443

cond.true.47:                                     ; preds = %cond.true
  %38 = load i64, i64* %fun, align 8
  %call48 = call %struct.Lisp_Subr* @XSUBR(i64 %38)
  %max_args49 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call48, i32 0, i32 3
  %39 = load i16, i16* %max_args49, align 2
  %conv50 = sext i16 %39 to i32
  %add51 = add nsw i32 1, %conv50
  %conv52 = trunc i32 %add51 to i8
  %conv53 = sext i8 %conv52 to i32
  %add54 = add nsw i32 0, %conv53
  %mul = mul nsw i32 0, %add54
  %sub55 = sub nsw i32 %mul, 1
  %cmp56 = icmp slt i32 %sub55, 0
  br i1 %cmp56, label %cond.true.58, label %cond.false

cond.true.58:                                     ; preds = %cond.true.47
  %40 = load i64, i64* %fun, align 8
  %call59 = call %struct.Lisp_Subr* @XSUBR(i64 %40)
  %max_args60 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call59, i32 0, i32 3
  %41 = load i16, i16* %max_args60, align 2
  %conv61 = sext i16 %41 to i32
  %add62 = add nsw i32 1, %conv61
  %conv63 = trunc i32 %add62 to i8
  %conv64 = sext i8 %conv63 to i32
  %add65 = add nsw i32 0, %conv64
  %mul66 = mul nsw i32 0, %add65
  %add67 = add nsw i32 %mul66, 0
  %neg = xor i32 %add67, -1
  %cmp68 = icmp eq i32 %neg, -1
  %conv69 = zext i1 %cmp68 to i32
  %sub70 = sub nsw i32 0, %conv69
  %42 = load i64, i64* %fun, align 8
  %call71 = call %struct.Lisp_Subr* @XSUBR(i64 %42)
  %max_args72 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call71, i32 0, i32 3
  %43 = load i16, i16* %max_args72, align 2
  %conv73 = sext i16 %43 to i32
  %add74 = add nsw i32 1, %conv73
  %conv75 = trunc i32 %add74 to i8
  %conv76 = sext i8 %conv75 to i32
  %add77 = add nsw i32 0, %conv76
  %mul78 = mul nsw i32 0, %add77
  %add79 = add nsw i32 %mul78, 1
  %shl = shl i32 %add79, 30
  %sub80 = sub nsw i32 %shl, 1
  %mul81 = mul nsw i32 %sub80, 2
  %add82 = add nsw i32 %mul81, 1
  %sub83 = sub nsw i32 %sub70, %add82
  br label %cond.end

cond.false:                                       ; preds = %cond.true.47
  %44 = load i64, i64* %fun, align 8
  %call84 = call %struct.Lisp_Subr* @XSUBR(i64 %44)
  %max_args85 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call84, i32 0, i32 3
  %45 = load i16, i16* %max_args85, align 2
  %conv86 = sext i16 %45 to i32
  %add87 = add nsw i32 1, %conv86
  %conv88 = trunc i32 %add87 to i8
  %conv89 = sext i8 %conv88 to i32
  %add90 = add nsw i32 0, %conv89
  %mul91 = mul nsw i32 0, %add90
  %add92 = add nsw i32 %mul91, 0
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true.58
  %cond = phi i32 [ %sub83, %cond.true.58 ], [ %add92, %cond.false ]
  %cmp93 = icmp eq i32 %cond, 0
  br i1 %cmp93, label %land.lhs.true.95, label %lor.lhs.false

land.lhs.true.95:                                 ; preds = %cond.end
  %46 = load i64, i64* %fun, align 8
  %call96 = call %struct.Lisp_Subr* @XSUBR(i64 %46)
  %max_args97 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call96, i32 0, i32 3
  %47 = load i16, i16* %max_args97, align 2
  %conv98 = sext i16 %47 to i32
  %add99 = add nsw i32 1, %conv98
  %conv100 = trunc i32 %add99 to i8
  %conv101 = sext i8 %conv100 to i32
  %cmp102 = icmp slt i32 %conv101, 0
  br i1 %cmp102, label %cond.true.373, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true.95, %cond.end
  br i1 false, label %cond.true.104, label %cond.false.222

cond.true.104:                                    ; preds = %lor.lhs.false
  %48 = load i64, i64* %fun, align 8
  %call105 = call %struct.Lisp_Subr* @XSUBR(i64 %48)
  %max_args106 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call105, i32 0, i32 3
  %49 = load i16, i16* %max_args106, align 2
  %conv107 = sext i16 %49 to i32
  %add108 = add nsw i32 1, %conv107
  %conv109 = trunc i32 %add108 to i8
  %conv110 = sext i8 %conv109 to i32
  %cmp111 = icmp slt i32 %conv110, 0
  br i1 %cmp111, label %cond.true.113, label %cond.false.159

cond.true.113:                                    ; preds = %cond.true.104
  %50 = load i64, i64* %fun, align 8
  %call114 = call %struct.Lisp_Subr* @XSUBR(i64 %50)
  %max_args115 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call114, i32 0, i32 3
  %51 = load i16, i16* %max_args115, align 2
  %conv116 = sext i16 %51 to i32
  %add117 = add nsw i32 1, %conv116
  %conv118 = trunc i32 %add117 to i8
  %conv119 = sext i8 %conv118 to i32
  %52 = load i64, i64* %fun, align 8
  %call120 = call %struct.Lisp_Subr* @XSUBR(i64 %52)
  %max_args121 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call120, i32 0, i32 3
  %53 = load i16, i16* %max_args121, align 2
  %conv122 = sext i16 %53 to i32
  %add123 = add nsw i32 1, %conv122
  %conv124 = trunc i32 %add123 to i8
  %conv125 = sext i8 %conv124 to i32
  %add126 = add nsw i32 0, %conv125
  %mul127 = mul nsw i32 0, %add126
  %sub128 = sub nsw i32 %mul127, 1
  %cmp129 = icmp slt i32 %sub128, 0
  br i1 %cmp129, label %cond.true.131, label %cond.false.145

cond.true.131:                                    ; preds = %cond.true.113
  %54 = load i64, i64* %fun, align 8
  %call132 = call %struct.Lisp_Subr* @XSUBR(i64 %54)
  %max_args133 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call132, i32 0, i32 3
  %55 = load i16, i16* %max_args133, align 2
  %conv134 = sext i16 %55 to i32
  %add135 = add nsw i32 1, %conv134
  %conv136 = trunc i32 %add135 to i8
  %conv137 = sext i8 %conv136 to i32
  %add138 = add nsw i32 0, %conv137
  %mul139 = mul nsw i32 0, %add138
  %add140 = add nsw i32 %mul139, 1
  %shl141 = shl i32 %add140, 30
  %sub142 = sub nsw i32 %shl141, 1
  %mul143 = mul nsw i32 %sub142, 2
  %add144 = add nsw i32 %mul143, 1
  br label %cond.end.155

cond.false.145:                                   ; preds = %cond.true.113
  %56 = load i64, i64* %fun, align 8
  %call146 = call %struct.Lisp_Subr* @XSUBR(i64 %56)
  %max_args147 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call146, i32 0, i32 3
  %57 = load i16, i16* %max_args147, align 2
  %conv148 = sext i16 %57 to i32
  %add149 = add nsw i32 1, %conv148
  %conv150 = trunc i32 %add149 to i8
  %conv151 = sext i8 %conv150 to i32
  %add152 = add nsw i32 0, %conv151
  %mul153 = mul nsw i32 0, %add152
  %sub154 = sub nsw i32 %mul153, 1
  br label %cond.end.155

cond.end.155:                                     ; preds = %cond.false.145, %cond.true.131
  %cond156 = phi i32 [ %add144, %cond.true.131 ], [ %sub154, %cond.false.145 ]
  %div = sdiv i32 %cond156, 8
  %cmp157 = icmp slt i32 %conv119, %div
  br i1 %cmp157, label %cond.true.373, label %lor.lhs.false.341

cond.false.159:                                   ; preds = %cond.true.104
  br i1 false, label %cond.true.160, label %cond.false.161

cond.true.160:                                    ; preds = %cond.false.159
  br i1 false, label %cond.true.373, label %lor.lhs.false.341

cond.false.161:                                   ; preds = %cond.false.159
  %58 = load i64, i64* %fun, align 8
  %call162 = call %struct.Lisp_Subr* @XSUBR(i64 %58)
  %max_args163 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call162, i32 0, i32 3
  %59 = load i16, i16* %max_args163, align 2
  %conv164 = sext i16 %59 to i32
  %add165 = add nsw i32 1, %conv164
  %conv166 = trunc i32 %add165 to i8
  %conv167 = sext i8 %conv166 to i32
  %add168 = add nsw i32 0, %conv167
  %mul169 = mul nsw i32 0, %add168
  %sub170 = sub nsw i32 %mul169, 1
  %cmp171 = icmp slt i32 %sub170, 0
  br i1 %cmp171, label %cond.true.173, label %cond.false.201

cond.true.173:                                    ; preds = %cond.false.161
  %60 = load i64, i64* %fun, align 8
  %call174 = call %struct.Lisp_Subr* @XSUBR(i64 %60)
  %max_args175 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call174, i32 0, i32 3
  %61 = load i16, i16* %max_args175, align 2
  %conv176 = sext i16 %61 to i32
  %add177 = add nsw i32 1, %conv176
  %conv178 = trunc i32 %add177 to i8
  %conv179 = sext i8 %conv178 to i32
  %add180 = add nsw i32 0, %conv179
  %mul181 = mul nsw i32 0, %add180
  %add182 = add nsw i32 %mul181, 0
  %neg183 = xor i32 %add182, -1
  %cmp184 = icmp eq i32 %neg183, -1
  %conv185 = zext i1 %cmp184 to i32
  %sub186 = sub nsw i32 0, %conv185
  %62 = load i64, i64* %fun, align 8
  %call187 = call %struct.Lisp_Subr* @XSUBR(i64 %62)
  %max_args188 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call187, i32 0, i32 3
  %63 = load i16, i16* %max_args188, align 2
  %conv189 = sext i16 %63 to i32
  %add190 = add nsw i32 1, %conv189
  %conv191 = trunc i32 %add190 to i8
  %conv192 = sext i8 %conv191 to i32
  %add193 = add nsw i32 0, %conv192
  %mul194 = mul nsw i32 0, %add193
  %add195 = add nsw i32 %mul194, 1
  %shl196 = shl i32 %add195, 30
  %sub197 = sub nsw i32 %shl196, 1
  %mul198 = mul nsw i32 %sub197, 2
  %add199 = add nsw i32 %mul198, 1
  %sub200 = sub nsw i32 %sub186, %add199
  br label %cond.end.211

cond.false.201:                                   ; preds = %cond.false.161
  %64 = load i64, i64* %fun, align 8
  %call202 = call %struct.Lisp_Subr* @XSUBR(i64 %64)
  %max_args203 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call202, i32 0, i32 3
  %65 = load i16, i16* %max_args203, align 2
  %conv204 = sext i16 %65 to i32
  %add205 = add nsw i32 1, %conv204
  %conv206 = trunc i32 %add205 to i8
  %conv207 = sext i8 %conv206 to i32
  %add208 = add nsw i32 0, %conv207
  %mul209 = mul nsw i32 0, %add208
  %add210 = add nsw i32 %mul209, 0
  br label %cond.end.211

cond.end.211:                                     ; preds = %cond.false.201, %cond.true.173
  %cond212 = phi i32 [ %sub200, %cond.true.173 ], [ %add210, %cond.false.201 ]
  %div213 = sdiv i32 %cond212, 8
  %66 = load i64, i64* %fun, align 8
  %call214 = call %struct.Lisp_Subr* @XSUBR(i64 %66)
  %max_args215 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call214, i32 0, i32 3
  %67 = load i16, i16* %max_args215, align 2
  %conv216 = sext i16 %67 to i32
  %add217 = add nsw i32 1, %conv216
  %conv218 = trunc i32 %add217 to i8
  %conv219 = sext i8 %conv218 to i32
  %cmp220 = icmp slt i32 %div213, %conv219
  br i1 %cmp220, label %cond.true.373, label %lor.lhs.false.341

cond.false.222:                                   ; preds = %lor.lhs.false
  br i1 false, label %cond.true.223, label %cond.false.224

cond.true.223:                                    ; preds = %cond.false.222
  br i1 false, label %cond.true.373, label %lor.lhs.false.341

cond.false.224:                                   ; preds = %cond.false.222
  %68 = load i64, i64* %fun, align 8
  %call225 = call %struct.Lisp_Subr* @XSUBR(i64 %68)
  %max_args226 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call225, i32 0, i32 3
  %69 = load i16, i16* %max_args226, align 2
  %conv227 = sext i16 %69 to i32
  %add228 = add nsw i32 1, %conv227
  %conv229 = trunc i32 %add228 to i8
  %conv230 = sext i8 %conv229 to i32
  %cmp231 = icmp slt i32 %conv230, 0
  br i1 %cmp231, label %cond.true.233, label %cond.false.294

cond.true.233:                                    ; preds = %cond.false.224
  %70 = load i64, i64* %fun, align 8
  %call234 = call %struct.Lisp_Subr* @XSUBR(i64 %70)
  %max_args235 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call234, i32 0, i32 3
  %71 = load i16, i16* %max_args235, align 2
  %conv236 = sext i16 %71 to i32
  %add237 = add nsw i32 1, %conv236
  %conv238 = trunc i32 %add237 to i8
  %conv239 = sext i8 %conv238 to i32
  %72 = load i64, i64* %fun, align 8
  %call240 = call %struct.Lisp_Subr* @XSUBR(i64 %72)
  %max_args241 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call240, i32 0, i32 3
  %73 = load i16, i16* %max_args241, align 2
  %conv242 = sext i16 %73 to i32
  %add243 = add nsw i32 1, %conv242
  %conv244 = trunc i32 %add243 to i8
  %conv245 = sext i8 %conv244 to i32
  %add246 = add nsw i32 0, %conv245
  %mul247 = mul nsw i32 0, %add246
  %sub248 = sub nsw i32 %mul247, 1
  %cmp249 = icmp slt i32 %sub248, 0
  br i1 %cmp249, label %cond.true.251, label %cond.false.279

cond.true.251:                                    ; preds = %cond.true.233
  %74 = load i64, i64* %fun, align 8
  %call252 = call %struct.Lisp_Subr* @XSUBR(i64 %74)
  %max_args253 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call252, i32 0, i32 3
  %75 = load i16, i16* %max_args253, align 2
  %conv254 = sext i16 %75 to i32
  %add255 = add nsw i32 1, %conv254
  %conv256 = trunc i32 %add255 to i8
  %conv257 = sext i8 %conv256 to i32
  %add258 = add nsw i32 0, %conv257
  %mul259 = mul nsw i32 0, %add258
  %add260 = add nsw i32 %mul259, 0
  %neg261 = xor i32 %add260, -1
  %cmp262 = icmp eq i32 %neg261, -1
  %conv263 = zext i1 %cmp262 to i32
  %sub264 = sub nsw i32 0, %conv263
  %76 = load i64, i64* %fun, align 8
  %call265 = call %struct.Lisp_Subr* @XSUBR(i64 %76)
  %max_args266 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call265, i32 0, i32 3
  %77 = load i16, i16* %max_args266, align 2
  %conv267 = sext i16 %77 to i32
  %add268 = add nsw i32 1, %conv267
  %conv269 = trunc i32 %add268 to i8
  %conv270 = sext i8 %conv269 to i32
  %add271 = add nsw i32 0, %conv270
  %mul272 = mul nsw i32 0, %add271
  %add273 = add nsw i32 %mul272, 1
  %shl274 = shl i32 %add273, 30
  %sub275 = sub nsw i32 %shl274, 1
  %mul276 = mul nsw i32 %sub275, 2
  %add277 = add nsw i32 %mul276, 1
  %sub278 = sub nsw i32 %sub264, %add277
  br label %cond.end.289

cond.false.279:                                   ; preds = %cond.true.233
  %78 = load i64, i64* %fun, align 8
  %call280 = call %struct.Lisp_Subr* @XSUBR(i64 %78)
  %max_args281 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call280, i32 0, i32 3
  %79 = load i16, i16* %max_args281, align 2
  %conv282 = sext i16 %79 to i32
  %add283 = add nsw i32 1, %conv282
  %conv284 = trunc i32 %add283 to i8
  %conv285 = sext i8 %conv284 to i32
  %add286 = add nsw i32 0, %conv285
  %mul287 = mul nsw i32 0, %add286
  %add288 = add nsw i32 %mul287, 0
  br label %cond.end.289

cond.end.289:                                     ; preds = %cond.false.279, %cond.true.251
  %cond290 = phi i32 [ %sub278, %cond.true.251 ], [ %add288, %cond.false.279 ]
  %div291 = sdiv i32 %cond290, 8
  %cmp292 = icmp slt i32 %conv239, %div291
  br i1 %cmp292, label %cond.true.373, label %lor.lhs.false.341

cond.false.294:                                   ; preds = %cond.false.224
  %80 = load i64, i64* %fun, align 8
  %call295 = call %struct.Lisp_Subr* @XSUBR(i64 %80)
  %max_args296 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call295, i32 0, i32 3
  %81 = load i16, i16* %max_args296, align 2
  %conv297 = sext i16 %81 to i32
  %add298 = add nsw i32 1, %conv297
  %conv299 = trunc i32 %add298 to i8
  %conv300 = sext i8 %conv299 to i32
  %add301 = add nsw i32 0, %conv300
  %mul302 = mul nsw i32 0, %add301
  %sub303 = sub nsw i32 %mul302, 1
  %cmp304 = icmp slt i32 %sub303, 0
  br i1 %cmp304, label %cond.true.306, label %cond.false.320

cond.true.306:                                    ; preds = %cond.false.294
  %82 = load i64, i64* %fun, align 8
  %call307 = call %struct.Lisp_Subr* @XSUBR(i64 %82)
  %max_args308 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call307, i32 0, i32 3
  %83 = load i16, i16* %max_args308, align 2
  %conv309 = sext i16 %83 to i32
  %add310 = add nsw i32 1, %conv309
  %conv311 = trunc i32 %add310 to i8
  %conv312 = sext i8 %conv311 to i32
  %add313 = add nsw i32 0, %conv312
  %mul314 = mul nsw i32 0, %add313
  %add315 = add nsw i32 %mul314, 1
  %shl316 = shl i32 %add315, 30
  %sub317 = sub nsw i32 %shl316, 1
  %mul318 = mul nsw i32 %sub317, 2
  %add319 = add nsw i32 %mul318, 1
  br label %cond.end.330

cond.false.320:                                   ; preds = %cond.false.294
  %84 = load i64, i64* %fun, align 8
  %call321 = call %struct.Lisp_Subr* @XSUBR(i64 %84)
  %max_args322 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call321, i32 0, i32 3
  %85 = load i16, i16* %max_args322, align 2
  %conv323 = sext i16 %85 to i32
  %add324 = add nsw i32 1, %conv323
  %conv325 = trunc i32 %add324 to i8
  %conv326 = sext i8 %conv325 to i32
  %add327 = add nsw i32 0, %conv326
  %mul328 = mul nsw i32 0, %add327
  %sub329 = sub nsw i32 %mul328, 1
  br label %cond.end.330

cond.end.330:                                     ; preds = %cond.false.320, %cond.true.306
  %cond331 = phi i32 [ %add319, %cond.true.306 ], [ %sub329, %cond.false.320 ]
  %div332 = sdiv i32 %cond331, 8
  %86 = load i64, i64* %fun, align 8
  %call333 = call %struct.Lisp_Subr* @XSUBR(i64 %86)
  %max_args334 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call333, i32 0, i32 3
  %87 = load i16, i16* %max_args334, align 2
  %conv335 = sext i16 %87 to i32
  %add336 = add nsw i32 1, %conv335
  %conv337 = trunc i32 %add336 to i8
  %conv338 = sext i8 %conv337 to i32
  %cmp339 = icmp slt i32 %div332, %conv338
  br i1 %cmp339, label %cond.true.373, label %lor.lhs.false.341

lor.lhs.false.341:                                ; preds = %cond.end.330, %cond.end.289, %cond.true.223, %cond.end.211, %cond.true.160, %cond.end.155
  %88 = load i64, i64* %fun, align 8
  %call342 = call %struct.Lisp_Subr* @XSUBR(i64 %88)
  %max_args343 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call342, i32 0, i32 3
  %89 = load i16, i16* %max_args343, align 2
  %conv344 = sext i16 %89 to i32
  %add345 = add nsw i32 1, %conv344
  %conv346 = trunc i32 %add345 to i8
  %conv347 = sext i8 %conv346 to i32
  %mul348 = mul nsw i32 %conv347, 8
  %mul349 = mul nsw i32 0, %mul348
  %sub350 = sub nsw i32 %mul349, 1
  %cmp351 = icmp slt i32 %sub350, 0
  br i1 %cmp351, label %land.lhs.true.353, label %lor.lhs.false.363

land.lhs.true.353:                                ; preds = %lor.lhs.false.341
  %90 = load i64, i64* %fun, align 8
  %call354 = call %struct.Lisp_Subr* @XSUBR(i64 %90)
  %max_args355 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call354, i32 0, i32 3
  %91 = load i16, i16* %max_args355, align 2
  %conv356 = sext i16 %91 to i32
  %add357 = add nsw i32 1, %conv356
  %conv358 = trunc i32 %add357 to i8
  %conv359 = sext i8 %conv358 to i32
  %mul360 = mul nsw i32 %conv359, 8
  %cmp361 = icmp slt i32 %mul360, -128
  br i1 %cmp361, label %cond.true.373, label %lor.lhs.false.363

lor.lhs.false.363:                                ; preds = %land.lhs.true.353, %lor.lhs.false.341
  %92 = load i64, i64* %fun, align 8
  %call364 = call %struct.Lisp_Subr* @XSUBR(i64 %92)
  %max_args365 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call364, i32 0, i32 3
  %93 = load i16, i16* %max_args365, align 2
  %conv366 = sext i16 %93 to i32
  %add367 = add nsw i32 1, %conv366
  %conv368 = trunc i32 %add367 to i8
  %conv369 = sext i8 %conv368 to i32
  %mul370 = mul nsw i32 %conv369, 8
  %cmp371 = icmp slt i32 127, %mul370
  br i1 %cmp371, label %cond.true.373, label %cond.false.408

cond.true.373:                                    ; preds = %lor.lhs.false.363, %land.lhs.true.353, %cond.end.330, %cond.end.289, %cond.true.223, %cond.end.211, %cond.true.160, %cond.end.155, %land.lhs.true.95
  %94 = load i64, i64* %fun, align 8
  %call374 = call %struct.Lisp_Subr* @XSUBR(i64 %94)
  %max_args375 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call374, i32 0, i32 3
  %95 = load i16, i16* %max_args375, align 2
  %conv376 = sext i16 %95 to i32
  %add377 = add nsw i32 1, %conv376
  %conv378 = trunc i32 %add377 to i8
  %conv379 = zext i8 %conv378 to i32
  %mul380 = mul nsw i32 %conv379, 8
  %cmp381 = icmp sle i32 %mul380, 127
  br i1 %cmp381, label %cond.true.383, label %cond.false.393

cond.true.383:                                    ; preds = %cond.true.373
  %96 = load i64, i64* %fun, align 8
  %call384 = call %struct.Lisp_Subr* @XSUBR(i64 %96)
  %max_args385 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call384, i32 0, i32 3
  %97 = load i16, i16* %max_args385, align 2
  %conv386 = sext i16 %97 to i32
  %add387 = add nsw i32 1, %conv386
  %conv388 = trunc i32 %add387 to i8
  %conv389 = zext i8 %conv388 to i32
  %mul390 = mul nsw i32 %conv389, 8
  %conv391 = trunc i32 %mul390 to i8
  %conv392 = sext i8 %conv391 to i32
  br label %cond.end.405

cond.false.393:                                   ; preds = %cond.true.373
  %98 = load i64, i64* %fun, align 8
  %call394 = call %struct.Lisp_Subr* @XSUBR(i64 %98)
  %max_args395 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call394, i32 0, i32 3
  %99 = load i16, i16* %max_args395, align 2
  %conv396 = sext i16 %99 to i32
  %add397 = add nsw i32 1, %conv396
  %conv398 = trunc i32 %add397 to i8
  %conv399 = zext i8 %conv398 to i32
  %mul400 = mul nsw i32 %conv399, 8
  %sub401 = sub nsw i32 %mul400, -128
  %conv402 = trunc i32 %sub401 to i8
  %conv403 = sext i8 %conv402 to i32
  %add404 = add nsw i32 %conv403, -128
  br label %cond.end.405

cond.end.405:                                     ; preds = %cond.false.393, %cond.true.383
  %cond406 = phi i32 [ %conv392, %cond.true.383 ], [ %add404, %cond.false.393 ]
  %conv407 = sext i32 %cond406 to i64
  store i64 %conv407, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.3603, label %lor.lhs.false.3600

cond.false.408:                                   ; preds = %lor.lhs.false.363
  %100 = load i64, i64* %fun, align 8
  %call409 = call %struct.Lisp_Subr* @XSUBR(i64 %100)
  %max_args410 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call409, i32 0, i32 3
  %101 = load i16, i16* %max_args410, align 2
  %conv411 = sext i16 %101 to i32
  %add412 = add nsw i32 1, %conv411
  %conv413 = trunc i32 %add412 to i8
  %conv414 = zext i8 %conv413 to i32
  %mul415 = mul nsw i32 %conv414, 8
  %cmp416 = icmp sle i32 %mul415, 127
  br i1 %cmp416, label %cond.true.418, label %cond.false.428

cond.true.418:                                    ; preds = %cond.false.408
  %102 = load i64, i64* %fun, align 8
  %call419 = call %struct.Lisp_Subr* @XSUBR(i64 %102)
  %max_args420 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call419, i32 0, i32 3
  %103 = load i16, i16* %max_args420, align 2
  %conv421 = sext i16 %103 to i32
  %add422 = add nsw i32 1, %conv421
  %conv423 = trunc i32 %add422 to i8
  %conv424 = zext i8 %conv423 to i32
  %mul425 = mul nsw i32 %conv424, 8
  %conv426 = trunc i32 %mul425 to i8
  %conv427 = sext i8 %conv426 to i32
  br label %cond.end.440

cond.false.428:                                   ; preds = %cond.false.408
  %104 = load i64, i64* %fun, align 8
  %call429 = call %struct.Lisp_Subr* @XSUBR(i64 %104)
  %max_args430 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call429, i32 0, i32 3
  %105 = load i16, i16* %max_args430, align 2
  %conv431 = sext i16 %105 to i32
  %add432 = add nsw i32 1, %conv431
  %conv433 = trunc i32 %add432 to i8
  %conv434 = zext i8 %conv433 to i32
  %mul435 = mul nsw i32 %conv434, 8
  %sub436 = sub nsw i32 %mul435, -128
  %conv437 = trunc i32 %sub436 to i8
  %conv438 = sext i8 %conv437 to i32
  %add439 = add nsw i32 %conv438, -128
  br label %cond.end.440

cond.end.440:                                     ; preds = %cond.false.428, %cond.true.418
  %cond441 = phi i32 [ %conv427, %cond.true.418 ], [ %add439, %cond.false.428 ]
  %conv442 = sext i32 %cond441 to i64
  store i64 %conv442, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.3603, label %lor.lhs.false.3600

cond.false.443:                                   ; preds = %cond.true
  %106 = load i64, i64* %fun, align 8
  %call444 = call %struct.Lisp_Subr* @XSUBR(i64 %106)
  %max_args445 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call444, i32 0, i32 3
  %107 = load i16, i16* %max_args445, align 2
  %conv446 = sext i16 %107 to i32
  %add447 = add nsw i32 1, %conv446
  %add448 = add nsw i32 0, %add447
  %mul449 = mul nsw i32 0, %add448
  %sub450 = sub nsw i32 %mul449, 1
  %cmp451 = icmp slt i32 %sub450, 0
  br i1 %cmp451, label %cond.true.453, label %cond.false.477

cond.true.453:                                    ; preds = %cond.false.443
  %108 = load i64, i64* %fun, align 8
  %call454 = call %struct.Lisp_Subr* @XSUBR(i64 %108)
  %max_args455 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call454, i32 0, i32 3
  %109 = load i16, i16* %max_args455, align 2
  %conv456 = sext i16 %109 to i32
  %add457 = add nsw i32 1, %conv456
  %add458 = add nsw i32 0, %add457
  %mul459 = mul nsw i32 0, %add458
  %add460 = add nsw i32 %mul459, 0
  %neg461 = xor i32 %add460, -1
  %cmp462 = icmp eq i32 %neg461, -1
  %conv463 = zext i1 %cmp462 to i32
  %sub464 = sub nsw i32 0, %conv463
  %110 = load i64, i64* %fun, align 8
  %call465 = call %struct.Lisp_Subr* @XSUBR(i64 %110)
  %max_args466 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call465, i32 0, i32 3
  %111 = load i16, i16* %max_args466, align 2
  %conv467 = sext i16 %111 to i32
  %add468 = add nsw i32 1, %conv467
  %add469 = add nsw i32 0, %add468
  %mul470 = mul nsw i32 0, %add469
  %add471 = add nsw i32 %mul470, 1
  %shl472 = shl i32 %add471, 30
  %sub473 = sub nsw i32 %shl472, 1
  %mul474 = mul nsw i32 %sub473, 2
  %add475 = add nsw i32 %mul474, 1
  %sub476 = sub nsw i32 %sub464, %add475
  br label %cond.end.485

cond.false.477:                                   ; preds = %cond.false.443
  %112 = load i64, i64* %fun, align 8
  %call478 = call %struct.Lisp_Subr* @XSUBR(i64 %112)
  %max_args479 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call478, i32 0, i32 3
  %113 = load i16, i16* %max_args479, align 2
  %conv480 = sext i16 %113 to i32
  %add481 = add nsw i32 1, %conv480
  %add482 = add nsw i32 0, %add481
  %mul483 = mul nsw i32 0, %add482
  %add484 = add nsw i32 %mul483, 0
  br label %cond.end.485

cond.end.485:                                     ; preds = %cond.false.477, %cond.true.453
  %cond486 = phi i32 [ %sub476, %cond.true.453 ], [ %add484, %cond.false.477 ]
  %cmp487 = icmp eq i32 %cond486, 0
  br i1 %cmp487, label %land.lhs.true.489, label %lor.lhs.false.496

land.lhs.true.489:                                ; preds = %cond.end.485
  %114 = load i64, i64* %fun, align 8
  %call490 = call %struct.Lisp_Subr* @XSUBR(i64 %114)
  %max_args491 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call490, i32 0, i32 3
  %115 = load i16, i16* %max_args491, align 2
  %conv492 = sext i16 %115 to i32
  %add493 = add nsw i32 1, %conv492
  %cmp494 = icmp slt i32 %add493, 0
  br i1 %cmp494, label %cond.true.721, label %lor.lhs.false.496

lor.lhs.false.496:                                ; preds = %land.lhs.true.489, %cond.end.485
  br i1 false, label %cond.true.497, label %cond.false.596

cond.true.497:                                    ; preds = %lor.lhs.false.496
  %116 = load i64, i64* %fun, align 8
  %call498 = call %struct.Lisp_Subr* @XSUBR(i64 %116)
  %max_args499 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call498, i32 0, i32 3
  %117 = load i16, i16* %max_args499, align 2
  %conv500 = sext i16 %117 to i32
  %add501 = add nsw i32 1, %conv500
  %cmp502 = icmp slt i32 %add501, 0
  br i1 %cmp502, label %cond.true.504, label %cond.false.543

cond.true.504:                                    ; preds = %cond.true.497
  %118 = load i64, i64* %fun, align 8
  %call505 = call %struct.Lisp_Subr* @XSUBR(i64 %118)
  %max_args506 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call505, i32 0, i32 3
  %119 = load i16, i16* %max_args506, align 2
  %conv507 = sext i16 %119 to i32
  %add508 = add nsw i32 1, %conv507
  %120 = load i64, i64* %fun, align 8
  %call509 = call %struct.Lisp_Subr* @XSUBR(i64 %120)
  %max_args510 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call509, i32 0, i32 3
  %121 = load i16, i16* %max_args510, align 2
  %conv511 = sext i16 %121 to i32
  %add512 = add nsw i32 1, %conv511
  %add513 = add nsw i32 0, %add512
  %mul514 = mul nsw i32 0, %add513
  %sub515 = sub nsw i32 %mul514, 1
  %cmp516 = icmp slt i32 %sub515, 0
  br i1 %cmp516, label %cond.true.518, label %cond.false.530

cond.true.518:                                    ; preds = %cond.true.504
  %122 = load i64, i64* %fun, align 8
  %call519 = call %struct.Lisp_Subr* @XSUBR(i64 %122)
  %max_args520 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call519, i32 0, i32 3
  %123 = load i16, i16* %max_args520, align 2
  %conv521 = sext i16 %123 to i32
  %add522 = add nsw i32 1, %conv521
  %add523 = add nsw i32 0, %add522
  %mul524 = mul nsw i32 0, %add523
  %add525 = add nsw i32 %mul524, 1
  %shl526 = shl i32 %add525, 30
  %sub527 = sub nsw i32 %shl526, 1
  %mul528 = mul nsw i32 %sub527, 2
  %add529 = add nsw i32 %mul528, 1
  br label %cond.end.538

cond.false.530:                                   ; preds = %cond.true.504
  %124 = load i64, i64* %fun, align 8
  %call531 = call %struct.Lisp_Subr* @XSUBR(i64 %124)
  %max_args532 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call531, i32 0, i32 3
  %125 = load i16, i16* %max_args532, align 2
  %conv533 = sext i16 %125 to i32
  %add534 = add nsw i32 1, %conv533
  %add535 = add nsw i32 0, %add534
  %mul536 = mul nsw i32 0, %add535
  %sub537 = sub nsw i32 %mul536, 1
  br label %cond.end.538

cond.end.538:                                     ; preds = %cond.false.530, %cond.true.518
  %cond539 = phi i32 [ %add529, %cond.true.518 ], [ %sub537, %cond.false.530 ]
  %div540 = sdiv i32 %cond539, 8
  %cmp541 = icmp slt i32 %add508, %div540
  br i1 %cmp541, label %cond.true.721, label %lor.lhs.false.695

cond.false.543:                                   ; preds = %cond.true.497
  br i1 false, label %cond.true.544, label %cond.false.545

cond.true.544:                                    ; preds = %cond.false.543
  br i1 false, label %cond.true.721, label %lor.lhs.false.695

cond.false.545:                                   ; preds = %cond.false.543
  %126 = load i64, i64* %fun, align 8
  %call546 = call %struct.Lisp_Subr* @XSUBR(i64 %126)
  %max_args547 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call546, i32 0, i32 3
  %127 = load i16, i16* %max_args547, align 2
  %conv548 = sext i16 %127 to i32
  %add549 = add nsw i32 1, %conv548
  %add550 = add nsw i32 0, %add549
  %mul551 = mul nsw i32 0, %add550
  %sub552 = sub nsw i32 %mul551, 1
  %cmp553 = icmp slt i32 %sub552, 0
  br i1 %cmp553, label %cond.true.555, label %cond.false.579

cond.true.555:                                    ; preds = %cond.false.545
  %128 = load i64, i64* %fun, align 8
  %call556 = call %struct.Lisp_Subr* @XSUBR(i64 %128)
  %max_args557 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call556, i32 0, i32 3
  %129 = load i16, i16* %max_args557, align 2
  %conv558 = sext i16 %129 to i32
  %add559 = add nsw i32 1, %conv558
  %add560 = add nsw i32 0, %add559
  %mul561 = mul nsw i32 0, %add560
  %add562 = add nsw i32 %mul561, 0
  %neg563 = xor i32 %add562, -1
  %cmp564 = icmp eq i32 %neg563, -1
  %conv565 = zext i1 %cmp564 to i32
  %sub566 = sub nsw i32 0, %conv565
  %130 = load i64, i64* %fun, align 8
  %call567 = call %struct.Lisp_Subr* @XSUBR(i64 %130)
  %max_args568 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call567, i32 0, i32 3
  %131 = load i16, i16* %max_args568, align 2
  %conv569 = sext i16 %131 to i32
  %add570 = add nsw i32 1, %conv569
  %add571 = add nsw i32 0, %add570
  %mul572 = mul nsw i32 0, %add571
  %add573 = add nsw i32 %mul572, 1
  %shl574 = shl i32 %add573, 30
  %sub575 = sub nsw i32 %shl574, 1
  %mul576 = mul nsw i32 %sub575, 2
  %add577 = add nsw i32 %mul576, 1
  %sub578 = sub nsw i32 %sub566, %add577
  br label %cond.end.587

cond.false.579:                                   ; preds = %cond.false.545
  %132 = load i64, i64* %fun, align 8
  %call580 = call %struct.Lisp_Subr* @XSUBR(i64 %132)
  %max_args581 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call580, i32 0, i32 3
  %133 = load i16, i16* %max_args581, align 2
  %conv582 = sext i16 %133 to i32
  %add583 = add nsw i32 1, %conv582
  %add584 = add nsw i32 0, %add583
  %mul585 = mul nsw i32 0, %add584
  %add586 = add nsw i32 %mul585, 0
  br label %cond.end.587

cond.end.587:                                     ; preds = %cond.false.579, %cond.true.555
  %cond588 = phi i32 [ %sub578, %cond.true.555 ], [ %add586, %cond.false.579 ]
  %div589 = sdiv i32 %cond588, 8
  %134 = load i64, i64* %fun, align 8
  %call590 = call %struct.Lisp_Subr* @XSUBR(i64 %134)
  %max_args591 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call590, i32 0, i32 3
  %135 = load i16, i16* %max_args591, align 2
  %conv592 = sext i16 %135 to i32
  %add593 = add nsw i32 1, %conv592
  %cmp594 = icmp slt i32 %div589, %add593
  br i1 %cmp594, label %cond.true.721, label %lor.lhs.false.695

cond.false.596:                                   ; preds = %lor.lhs.false.496
  br i1 false, label %cond.true.597, label %cond.false.598

cond.true.597:                                    ; preds = %cond.false.596
  br i1 false, label %cond.true.721, label %lor.lhs.false.695

cond.false.598:                                   ; preds = %cond.false.596
  %136 = load i64, i64* %fun, align 8
  %call599 = call %struct.Lisp_Subr* @XSUBR(i64 %136)
  %max_args600 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call599, i32 0, i32 3
  %137 = load i16, i16* %max_args600, align 2
  %conv601 = sext i16 %137 to i32
  %add602 = add nsw i32 1, %conv601
  %cmp603 = icmp slt i32 %add602, 0
  br i1 %cmp603, label %cond.true.605, label %cond.false.656

cond.true.605:                                    ; preds = %cond.false.598
  %138 = load i64, i64* %fun, align 8
  %call606 = call %struct.Lisp_Subr* @XSUBR(i64 %138)
  %max_args607 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call606, i32 0, i32 3
  %139 = load i16, i16* %max_args607, align 2
  %conv608 = sext i16 %139 to i32
  %add609 = add nsw i32 1, %conv608
  %140 = load i64, i64* %fun, align 8
  %call610 = call %struct.Lisp_Subr* @XSUBR(i64 %140)
  %max_args611 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call610, i32 0, i32 3
  %141 = load i16, i16* %max_args611, align 2
  %conv612 = sext i16 %141 to i32
  %add613 = add nsw i32 1, %conv612
  %add614 = add nsw i32 0, %add613
  %mul615 = mul nsw i32 0, %add614
  %sub616 = sub nsw i32 %mul615, 1
  %cmp617 = icmp slt i32 %sub616, 0
  br i1 %cmp617, label %cond.true.619, label %cond.false.643

cond.true.619:                                    ; preds = %cond.true.605
  %142 = load i64, i64* %fun, align 8
  %call620 = call %struct.Lisp_Subr* @XSUBR(i64 %142)
  %max_args621 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call620, i32 0, i32 3
  %143 = load i16, i16* %max_args621, align 2
  %conv622 = sext i16 %143 to i32
  %add623 = add nsw i32 1, %conv622
  %add624 = add nsw i32 0, %add623
  %mul625 = mul nsw i32 0, %add624
  %add626 = add nsw i32 %mul625, 0
  %neg627 = xor i32 %add626, -1
  %cmp628 = icmp eq i32 %neg627, -1
  %conv629 = zext i1 %cmp628 to i32
  %sub630 = sub nsw i32 0, %conv629
  %144 = load i64, i64* %fun, align 8
  %call631 = call %struct.Lisp_Subr* @XSUBR(i64 %144)
  %max_args632 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call631, i32 0, i32 3
  %145 = load i16, i16* %max_args632, align 2
  %conv633 = sext i16 %145 to i32
  %add634 = add nsw i32 1, %conv633
  %add635 = add nsw i32 0, %add634
  %mul636 = mul nsw i32 0, %add635
  %add637 = add nsw i32 %mul636, 1
  %shl638 = shl i32 %add637, 30
  %sub639 = sub nsw i32 %shl638, 1
  %mul640 = mul nsw i32 %sub639, 2
  %add641 = add nsw i32 %mul640, 1
  %sub642 = sub nsw i32 %sub630, %add641
  br label %cond.end.651

cond.false.643:                                   ; preds = %cond.true.605
  %146 = load i64, i64* %fun, align 8
  %call644 = call %struct.Lisp_Subr* @XSUBR(i64 %146)
  %max_args645 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call644, i32 0, i32 3
  %147 = load i16, i16* %max_args645, align 2
  %conv646 = sext i16 %147 to i32
  %add647 = add nsw i32 1, %conv646
  %add648 = add nsw i32 0, %add647
  %mul649 = mul nsw i32 0, %add648
  %add650 = add nsw i32 %mul649, 0
  br label %cond.end.651

cond.end.651:                                     ; preds = %cond.false.643, %cond.true.619
  %cond652 = phi i32 [ %sub642, %cond.true.619 ], [ %add650, %cond.false.643 ]
  %div653 = sdiv i32 %cond652, 8
  %cmp654 = icmp slt i32 %add609, %div653
  br i1 %cmp654, label %cond.true.721, label %lor.lhs.false.695

cond.false.656:                                   ; preds = %cond.false.598
  %148 = load i64, i64* %fun, align 8
  %call657 = call %struct.Lisp_Subr* @XSUBR(i64 %148)
  %max_args658 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call657, i32 0, i32 3
  %149 = load i16, i16* %max_args658, align 2
  %conv659 = sext i16 %149 to i32
  %add660 = add nsw i32 1, %conv659
  %add661 = add nsw i32 0, %add660
  %mul662 = mul nsw i32 0, %add661
  %sub663 = sub nsw i32 %mul662, 1
  %cmp664 = icmp slt i32 %sub663, 0
  br i1 %cmp664, label %cond.true.666, label %cond.false.678

cond.true.666:                                    ; preds = %cond.false.656
  %150 = load i64, i64* %fun, align 8
  %call667 = call %struct.Lisp_Subr* @XSUBR(i64 %150)
  %max_args668 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call667, i32 0, i32 3
  %151 = load i16, i16* %max_args668, align 2
  %conv669 = sext i16 %151 to i32
  %add670 = add nsw i32 1, %conv669
  %add671 = add nsw i32 0, %add670
  %mul672 = mul nsw i32 0, %add671
  %add673 = add nsw i32 %mul672, 1
  %shl674 = shl i32 %add673, 30
  %sub675 = sub nsw i32 %shl674, 1
  %mul676 = mul nsw i32 %sub675, 2
  %add677 = add nsw i32 %mul676, 1
  br label %cond.end.686

cond.false.678:                                   ; preds = %cond.false.656
  %152 = load i64, i64* %fun, align 8
  %call679 = call %struct.Lisp_Subr* @XSUBR(i64 %152)
  %max_args680 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call679, i32 0, i32 3
  %153 = load i16, i16* %max_args680, align 2
  %conv681 = sext i16 %153 to i32
  %add682 = add nsw i32 1, %conv681
  %add683 = add nsw i32 0, %add682
  %mul684 = mul nsw i32 0, %add683
  %sub685 = sub nsw i32 %mul684, 1
  br label %cond.end.686

cond.end.686:                                     ; preds = %cond.false.678, %cond.true.666
  %cond687 = phi i32 [ %add677, %cond.true.666 ], [ %sub685, %cond.false.678 ]
  %div688 = sdiv i32 %cond687, 8
  %154 = load i64, i64* %fun, align 8
  %call689 = call %struct.Lisp_Subr* @XSUBR(i64 %154)
  %max_args690 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call689, i32 0, i32 3
  %155 = load i16, i16* %max_args690, align 2
  %conv691 = sext i16 %155 to i32
  %add692 = add nsw i32 1, %conv691
  %cmp693 = icmp slt i32 %div688, %add692
  br i1 %cmp693, label %cond.true.721, label %lor.lhs.false.695

lor.lhs.false.695:                                ; preds = %cond.end.686, %cond.end.651, %cond.true.597, %cond.end.587, %cond.true.544, %cond.end.538
  %156 = load i64, i64* %fun, align 8
  %call696 = call %struct.Lisp_Subr* @XSUBR(i64 %156)
  %max_args697 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call696, i32 0, i32 3
  %157 = load i16, i16* %max_args697, align 2
  %conv698 = sext i16 %157 to i32
  %add699 = add nsw i32 1, %conv698
  %mul700 = mul nsw i32 %add699, 8
  %mul701 = mul nsw i32 0, %mul700
  %sub702 = sub nsw i32 %mul701, 1
  %cmp703 = icmp slt i32 %sub702, 0
  br i1 %cmp703, label %land.lhs.true.705, label %lor.lhs.false.713

land.lhs.true.705:                                ; preds = %lor.lhs.false.695
  %158 = load i64, i64* %fun, align 8
  %call706 = call %struct.Lisp_Subr* @XSUBR(i64 %158)
  %max_args707 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call706, i32 0, i32 3
  %159 = load i16, i16* %max_args707, align 2
  %conv708 = sext i16 %159 to i32
  %add709 = add nsw i32 1, %conv708
  %mul710 = mul nsw i32 %add709, 8
  %cmp711 = icmp slt i32 %mul710, -128
  br i1 %cmp711, label %cond.true.721, label %lor.lhs.false.713

lor.lhs.false.713:                                ; preds = %land.lhs.true.705, %lor.lhs.false.695
  %160 = load i64, i64* %fun, align 8
  %call714 = call %struct.Lisp_Subr* @XSUBR(i64 %160)
  %max_args715 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call714, i32 0, i32 3
  %161 = load i16, i16* %max_args715, align 2
  %conv716 = sext i16 %161 to i32
  %add717 = add nsw i32 1, %conv716
  %mul718 = mul nsw i32 %add717, 8
  %cmp719 = icmp slt i32 127, %mul718
  br i1 %cmp719, label %cond.true.721, label %cond.false.756

cond.true.721:                                    ; preds = %lor.lhs.false.713, %land.lhs.true.705, %cond.end.686, %cond.end.651, %cond.true.597, %cond.end.587, %cond.true.544, %cond.end.538, %land.lhs.true.489
  %162 = load i64, i64* %fun, align 8
  %call722 = call %struct.Lisp_Subr* @XSUBR(i64 %162)
  %max_args723 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call722, i32 0, i32 3
  %163 = load i16, i16* %max_args723, align 2
  %conv724 = sext i16 %163 to i32
  %add725 = add nsw i32 1, %conv724
  %conv726 = trunc i32 %add725 to i8
  %conv727 = zext i8 %conv726 to i32
  %mul728 = mul nsw i32 %conv727, 8
  %cmp729 = icmp sle i32 %mul728, 127
  br i1 %cmp729, label %cond.true.731, label %cond.false.741

cond.true.731:                                    ; preds = %cond.true.721
  %164 = load i64, i64* %fun, align 8
  %call732 = call %struct.Lisp_Subr* @XSUBR(i64 %164)
  %max_args733 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call732, i32 0, i32 3
  %165 = load i16, i16* %max_args733, align 2
  %conv734 = sext i16 %165 to i32
  %add735 = add nsw i32 1, %conv734
  %conv736 = trunc i32 %add735 to i8
  %conv737 = zext i8 %conv736 to i32
  %mul738 = mul nsw i32 %conv737, 8
  %conv739 = trunc i32 %mul738 to i8
  %conv740 = sext i8 %conv739 to i32
  br label %cond.end.753

cond.false.741:                                   ; preds = %cond.true.721
  %166 = load i64, i64* %fun, align 8
  %call742 = call %struct.Lisp_Subr* @XSUBR(i64 %166)
  %max_args743 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call742, i32 0, i32 3
  %167 = load i16, i16* %max_args743, align 2
  %conv744 = sext i16 %167 to i32
  %add745 = add nsw i32 1, %conv744
  %conv746 = trunc i32 %add745 to i8
  %conv747 = zext i8 %conv746 to i32
  %mul748 = mul nsw i32 %conv747, 8
  %sub749 = sub nsw i32 %mul748, -128
  %conv750 = trunc i32 %sub749 to i8
  %conv751 = sext i8 %conv750 to i32
  %add752 = add nsw i32 %conv751, -128
  br label %cond.end.753

cond.end.753:                                     ; preds = %cond.false.741, %cond.true.731
  %cond754 = phi i32 [ %conv740, %cond.true.731 ], [ %add752, %cond.false.741 ]
  %conv755 = sext i32 %cond754 to i64
  store i64 %conv755, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.3603, label %lor.lhs.false.3600

cond.false.756:                                   ; preds = %lor.lhs.false.713
  %168 = load i64, i64* %fun, align 8
  %call757 = call %struct.Lisp_Subr* @XSUBR(i64 %168)
  %max_args758 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call757, i32 0, i32 3
  %169 = load i16, i16* %max_args758, align 2
  %conv759 = sext i16 %169 to i32
  %add760 = add nsw i32 1, %conv759
  %conv761 = trunc i32 %add760 to i8
  %conv762 = zext i8 %conv761 to i32
  %mul763 = mul nsw i32 %conv762, 8
  %cmp764 = icmp sle i32 %mul763, 127
  br i1 %cmp764, label %cond.true.766, label %cond.false.776

cond.true.766:                                    ; preds = %cond.false.756
  %170 = load i64, i64* %fun, align 8
  %call767 = call %struct.Lisp_Subr* @XSUBR(i64 %170)
  %max_args768 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call767, i32 0, i32 3
  %171 = load i16, i16* %max_args768, align 2
  %conv769 = sext i16 %171 to i32
  %add770 = add nsw i32 1, %conv769
  %conv771 = trunc i32 %add770 to i8
  %conv772 = zext i8 %conv771 to i32
  %mul773 = mul nsw i32 %conv772, 8
  %conv774 = trunc i32 %mul773 to i8
  %conv775 = sext i8 %conv774 to i32
  br label %cond.end.788

cond.false.776:                                   ; preds = %cond.false.756
  %172 = load i64, i64* %fun, align 8
  %call777 = call %struct.Lisp_Subr* @XSUBR(i64 %172)
  %max_args778 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call777, i32 0, i32 3
  %173 = load i16, i16* %max_args778, align 2
  %conv779 = sext i16 %173 to i32
  %add780 = add nsw i32 1, %conv779
  %conv781 = trunc i32 %add780 to i8
  %conv782 = zext i8 %conv781 to i32
  %mul783 = mul nsw i32 %conv782, 8
  %sub784 = sub nsw i32 %mul783, -128
  %conv785 = trunc i32 %sub784 to i8
  %conv786 = sext i8 %conv785 to i32
  %add787 = add nsw i32 %conv786, -128
  br label %cond.end.788

cond.end.788:                                     ; preds = %cond.false.776, %cond.true.766
  %cond789 = phi i32 [ %conv775, %cond.true.766 ], [ %add787, %cond.false.776 ]
  %conv790 = sext i32 %cond789 to i64
  store i64 %conv790, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.3603, label %lor.lhs.false.3600

cond.false.791:                                   ; preds = %do.body
  br i1 false, label %cond.true.792, label %cond.false.1545

cond.true.792:                                    ; preds = %cond.false.791
  br i1 false, label %cond.true.793, label %cond.false.1197

cond.true.793:                                    ; preds = %cond.true.792
  %174 = load i64, i64* %fun, align 8
  %call794 = call %struct.Lisp_Subr* @XSUBR(i64 %174)
  %max_args795 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call794, i32 0, i32 3
  %175 = load i16, i16* %max_args795, align 2
  %conv796 = sext i16 %175 to i32
  %add797 = add nsw i32 1, %conv796
  %conv798 = trunc i32 %add797 to i16
  %conv799 = sext i16 %conv798 to i32
  %add800 = add nsw i32 0, %conv799
  %mul801 = mul nsw i32 0, %add800
  %sub802 = sub nsw i32 %mul801, 1
  %cmp803 = icmp slt i32 %sub802, 0
  br i1 %cmp803, label %cond.true.805, label %cond.false.833

cond.true.805:                                    ; preds = %cond.true.793
  %176 = load i64, i64* %fun, align 8
  %call806 = call %struct.Lisp_Subr* @XSUBR(i64 %176)
  %max_args807 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call806, i32 0, i32 3
  %177 = load i16, i16* %max_args807, align 2
  %conv808 = sext i16 %177 to i32
  %add809 = add nsw i32 1, %conv808
  %conv810 = trunc i32 %add809 to i16
  %conv811 = sext i16 %conv810 to i32
  %add812 = add nsw i32 0, %conv811
  %mul813 = mul nsw i32 0, %add812
  %add814 = add nsw i32 %mul813, 0
  %neg815 = xor i32 %add814, -1
  %cmp816 = icmp eq i32 %neg815, -1
  %conv817 = zext i1 %cmp816 to i32
  %sub818 = sub nsw i32 0, %conv817
  %178 = load i64, i64* %fun, align 8
  %call819 = call %struct.Lisp_Subr* @XSUBR(i64 %178)
  %max_args820 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call819, i32 0, i32 3
  %179 = load i16, i16* %max_args820, align 2
  %conv821 = sext i16 %179 to i32
  %add822 = add nsw i32 1, %conv821
  %conv823 = trunc i32 %add822 to i16
  %conv824 = sext i16 %conv823 to i32
  %add825 = add nsw i32 0, %conv824
  %mul826 = mul nsw i32 0, %add825
  %add827 = add nsw i32 %mul826, 1
  %shl828 = shl i32 %add827, 30
  %sub829 = sub nsw i32 %shl828, 1
  %mul830 = mul nsw i32 %sub829, 2
  %add831 = add nsw i32 %mul830, 1
  %sub832 = sub nsw i32 %sub818, %add831
  br label %cond.end.843

cond.false.833:                                   ; preds = %cond.true.793
  %180 = load i64, i64* %fun, align 8
  %call834 = call %struct.Lisp_Subr* @XSUBR(i64 %180)
  %max_args835 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call834, i32 0, i32 3
  %181 = load i16, i16* %max_args835, align 2
  %conv836 = sext i16 %181 to i32
  %add837 = add nsw i32 1, %conv836
  %conv838 = trunc i32 %add837 to i16
  %conv839 = sext i16 %conv838 to i32
  %add840 = add nsw i32 0, %conv839
  %mul841 = mul nsw i32 0, %add840
  %add842 = add nsw i32 %mul841, 0
  br label %cond.end.843

cond.end.843:                                     ; preds = %cond.false.833, %cond.true.805
  %cond844 = phi i32 [ %sub832, %cond.true.805 ], [ %add842, %cond.false.833 ]
  %cmp845 = icmp eq i32 %cond844, 0
  br i1 %cmp845, label %land.lhs.true.847, label %lor.lhs.false.856

land.lhs.true.847:                                ; preds = %cond.end.843
  %182 = load i64, i64* %fun, align 8
  %call848 = call %struct.Lisp_Subr* @XSUBR(i64 %182)
  %max_args849 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call848, i32 0, i32 3
  %183 = load i16, i16* %max_args849, align 2
  %conv850 = sext i16 %183 to i32
  %add851 = add nsw i32 1, %conv850
  %conv852 = trunc i32 %add851 to i16
  %conv853 = sext i16 %conv852 to i32
  %cmp854 = icmp slt i32 %conv853, 0
  br i1 %cmp854, label %cond.true.1127, label %lor.lhs.false.856

lor.lhs.false.856:                                ; preds = %land.lhs.true.847, %cond.end.843
  br i1 false, label %cond.true.857, label %cond.false.976

cond.true.857:                                    ; preds = %lor.lhs.false.856
  %184 = load i64, i64* %fun, align 8
  %call858 = call %struct.Lisp_Subr* @XSUBR(i64 %184)
  %max_args859 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call858, i32 0, i32 3
  %185 = load i16, i16* %max_args859, align 2
  %conv860 = sext i16 %185 to i32
  %add861 = add nsw i32 1, %conv860
  %conv862 = trunc i32 %add861 to i16
  %conv863 = sext i16 %conv862 to i32
  %cmp864 = icmp slt i32 %conv863, 0
  br i1 %cmp864, label %cond.true.866, label %cond.false.913

cond.true.866:                                    ; preds = %cond.true.857
  %186 = load i64, i64* %fun, align 8
  %call867 = call %struct.Lisp_Subr* @XSUBR(i64 %186)
  %max_args868 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call867, i32 0, i32 3
  %187 = load i16, i16* %max_args868, align 2
  %conv869 = sext i16 %187 to i32
  %add870 = add nsw i32 1, %conv869
  %conv871 = trunc i32 %add870 to i16
  %conv872 = sext i16 %conv871 to i32
  %188 = load i64, i64* %fun, align 8
  %call873 = call %struct.Lisp_Subr* @XSUBR(i64 %188)
  %max_args874 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call873, i32 0, i32 3
  %189 = load i16, i16* %max_args874, align 2
  %conv875 = sext i16 %189 to i32
  %add876 = add nsw i32 1, %conv875
  %conv877 = trunc i32 %add876 to i16
  %conv878 = sext i16 %conv877 to i32
  %add879 = add nsw i32 0, %conv878
  %mul880 = mul nsw i32 0, %add879
  %sub881 = sub nsw i32 %mul880, 1
  %cmp882 = icmp slt i32 %sub881, 0
  br i1 %cmp882, label %cond.true.884, label %cond.false.898

cond.true.884:                                    ; preds = %cond.true.866
  %190 = load i64, i64* %fun, align 8
  %call885 = call %struct.Lisp_Subr* @XSUBR(i64 %190)
  %max_args886 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call885, i32 0, i32 3
  %191 = load i16, i16* %max_args886, align 2
  %conv887 = sext i16 %191 to i32
  %add888 = add nsw i32 1, %conv887
  %conv889 = trunc i32 %add888 to i16
  %conv890 = sext i16 %conv889 to i32
  %add891 = add nsw i32 0, %conv890
  %mul892 = mul nsw i32 0, %add891
  %add893 = add nsw i32 %mul892, 1
  %shl894 = shl i32 %add893, 30
  %sub895 = sub nsw i32 %shl894, 1
  %mul896 = mul nsw i32 %sub895, 2
  %add897 = add nsw i32 %mul896, 1
  br label %cond.end.908

cond.false.898:                                   ; preds = %cond.true.866
  %192 = load i64, i64* %fun, align 8
  %call899 = call %struct.Lisp_Subr* @XSUBR(i64 %192)
  %max_args900 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call899, i32 0, i32 3
  %193 = load i16, i16* %max_args900, align 2
  %conv901 = sext i16 %193 to i32
  %add902 = add nsw i32 1, %conv901
  %conv903 = trunc i32 %add902 to i16
  %conv904 = sext i16 %conv903 to i32
  %add905 = add nsw i32 0, %conv904
  %mul906 = mul nsw i32 0, %add905
  %sub907 = sub nsw i32 %mul906, 1
  br label %cond.end.908

cond.end.908:                                     ; preds = %cond.false.898, %cond.true.884
  %cond909 = phi i32 [ %add897, %cond.true.884 ], [ %sub907, %cond.false.898 ]
  %div910 = sdiv i32 %cond909, 8
  %cmp911 = icmp slt i32 %conv872, %div910
  br i1 %cmp911, label %cond.true.1127, label %lor.lhs.false.1095

cond.false.913:                                   ; preds = %cond.true.857
  br i1 false, label %cond.true.914, label %cond.false.915

cond.true.914:                                    ; preds = %cond.false.913
  br i1 false, label %cond.true.1127, label %lor.lhs.false.1095

cond.false.915:                                   ; preds = %cond.false.913
  %194 = load i64, i64* %fun, align 8
  %call916 = call %struct.Lisp_Subr* @XSUBR(i64 %194)
  %max_args917 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call916, i32 0, i32 3
  %195 = load i16, i16* %max_args917, align 2
  %conv918 = sext i16 %195 to i32
  %add919 = add nsw i32 1, %conv918
  %conv920 = trunc i32 %add919 to i16
  %conv921 = sext i16 %conv920 to i32
  %add922 = add nsw i32 0, %conv921
  %mul923 = mul nsw i32 0, %add922
  %sub924 = sub nsw i32 %mul923, 1
  %cmp925 = icmp slt i32 %sub924, 0
  br i1 %cmp925, label %cond.true.927, label %cond.false.955

cond.true.927:                                    ; preds = %cond.false.915
  %196 = load i64, i64* %fun, align 8
  %call928 = call %struct.Lisp_Subr* @XSUBR(i64 %196)
  %max_args929 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call928, i32 0, i32 3
  %197 = load i16, i16* %max_args929, align 2
  %conv930 = sext i16 %197 to i32
  %add931 = add nsw i32 1, %conv930
  %conv932 = trunc i32 %add931 to i16
  %conv933 = sext i16 %conv932 to i32
  %add934 = add nsw i32 0, %conv933
  %mul935 = mul nsw i32 0, %add934
  %add936 = add nsw i32 %mul935, 0
  %neg937 = xor i32 %add936, -1
  %cmp938 = icmp eq i32 %neg937, -1
  %conv939 = zext i1 %cmp938 to i32
  %sub940 = sub nsw i32 0, %conv939
  %198 = load i64, i64* %fun, align 8
  %call941 = call %struct.Lisp_Subr* @XSUBR(i64 %198)
  %max_args942 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call941, i32 0, i32 3
  %199 = load i16, i16* %max_args942, align 2
  %conv943 = sext i16 %199 to i32
  %add944 = add nsw i32 1, %conv943
  %conv945 = trunc i32 %add944 to i16
  %conv946 = sext i16 %conv945 to i32
  %add947 = add nsw i32 0, %conv946
  %mul948 = mul nsw i32 0, %add947
  %add949 = add nsw i32 %mul948, 1
  %shl950 = shl i32 %add949, 30
  %sub951 = sub nsw i32 %shl950, 1
  %mul952 = mul nsw i32 %sub951, 2
  %add953 = add nsw i32 %mul952, 1
  %sub954 = sub nsw i32 %sub940, %add953
  br label %cond.end.965

cond.false.955:                                   ; preds = %cond.false.915
  %200 = load i64, i64* %fun, align 8
  %call956 = call %struct.Lisp_Subr* @XSUBR(i64 %200)
  %max_args957 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call956, i32 0, i32 3
  %201 = load i16, i16* %max_args957, align 2
  %conv958 = sext i16 %201 to i32
  %add959 = add nsw i32 1, %conv958
  %conv960 = trunc i32 %add959 to i16
  %conv961 = sext i16 %conv960 to i32
  %add962 = add nsw i32 0, %conv961
  %mul963 = mul nsw i32 0, %add962
  %add964 = add nsw i32 %mul963, 0
  br label %cond.end.965

cond.end.965:                                     ; preds = %cond.false.955, %cond.true.927
  %cond966 = phi i32 [ %sub954, %cond.true.927 ], [ %add964, %cond.false.955 ]
  %div967 = sdiv i32 %cond966, 8
  %202 = load i64, i64* %fun, align 8
  %call968 = call %struct.Lisp_Subr* @XSUBR(i64 %202)
  %max_args969 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call968, i32 0, i32 3
  %203 = load i16, i16* %max_args969, align 2
  %conv970 = sext i16 %203 to i32
  %add971 = add nsw i32 1, %conv970
  %conv972 = trunc i32 %add971 to i16
  %conv973 = sext i16 %conv972 to i32
  %cmp974 = icmp slt i32 %div967, %conv973
  br i1 %cmp974, label %cond.true.1127, label %lor.lhs.false.1095

cond.false.976:                                   ; preds = %lor.lhs.false.856
  br i1 false, label %cond.true.977, label %cond.false.978

cond.true.977:                                    ; preds = %cond.false.976
  br i1 false, label %cond.true.1127, label %lor.lhs.false.1095

cond.false.978:                                   ; preds = %cond.false.976
  %204 = load i64, i64* %fun, align 8
  %call979 = call %struct.Lisp_Subr* @XSUBR(i64 %204)
  %max_args980 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call979, i32 0, i32 3
  %205 = load i16, i16* %max_args980, align 2
  %conv981 = sext i16 %205 to i32
  %add982 = add nsw i32 1, %conv981
  %conv983 = trunc i32 %add982 to i16
  %conv984 = sext i16 %conv983 to i32
  %cmp985 = icmp slt i32 %conv984, 0
  br i1 %cmp985, label %cond.true.987, label %cond.false.1048

cond.true.987:                                    ; preds = %cond.false.978
  %206 = load i64, i64* %fun, align 8
  %call988 = call %struct.Lisp_Subr* @XSUBR(i64 %206)
  %max_args989 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call988, i32 0, i32 3
  %207 = load i16, i16* %max_args989, align 2
  %conv990 = sext i16 %207 to i32
  %add991 = add nsw i32 1, %conv990
  %conv992 = trunc i32 %add991 to i16
  %conv993 = sext i16 %conv992 to i32
  %208 = load i64, i64* %fun, align 8
  %call994 = call %struct.Lisp_Subr* @XSUBR(i64 %208)
  %max_args995 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call994, i32 0, i32 3
  %209 = load i16, i16* %max_args995, align 2
  %conv996 = sext i16 %209 to i32
  %add997 = add nsw i32 1, %conv996
  %conv998 = trunc i32 %add997 to i16
  %conv999 = sext i16 %conv998 to i32
  %add1000 = add nsw i32 0, %conv999
  %mul1001 = mul nsw i32 0, %add1000
  %sub1002 = sub nsw i32 %mul1001, 1
  %cmp1003 = icmp slt i32 %sub1002, 0
  br i1 %cmp1003, label %cond.true.1005, label %cond.false.1033

cond.true.1005:                                   ; preds = %cond.true.987
  %210 = load i64, i64* %fun, align 8
  %call1006 = call %struct.Lisp_Subr* @XSUBR(i64 %210)
  %max_args1007 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1006, i32 0, i32 3
  %211 = load i16, i16* %max_args1007, align 2
  %conv1008 = sext i16 %211 to i32
  %add1009 = add nsw i32 1, %conv1008
  %conv1010 = trunc i32 %add1009 to i16
  %conv1011 = sext i16 %conv1010 to i32
  %add1012 = add nsw i32 0, %conv1011
  %mul1013 = mul nsw i32 0, %add1012
  %add1014 = add nsw i32 %mul1013, 0
  %neg1015 = xor i32 %add1014, -1
  %cmp1016 = icmp eq i32 %neg1015, -1
  %conv1017 = zext i1 %cmp1016 to i32
  %sub1018 = sub nsw i32 0, %conv1017
  %212 = load i64, i64* %fun, align 8
  %call1019 = call %struct.Lisp_Subr* @XSUBR(i64 %212)
  %max_args1020 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1019, i32 0, i32 3
  %213 = load i16, i16* %max_args1020, align 2
  %conv1021 = sext i16 %213 to i32
  %add1022 = add nsw i32 1, %conv1021
  %conv1023 = trunc i32 %add1022 to i16
  %conv1024 = sext i16 %conv1023 to i32
  %add1025 = add nsw i32 0, %conv1024
  %mul1026 = mul nsw i32 0, %add1025
  %add1027 = add nsw i32 %mul1026, 1
  %shl1028 = shl i32 %add1027, 30
  %sub1029 = sub nsw i32 %shl1028, 1
  %mul1030 = mul nsw i32 %sub1029, 2
  %add1031 = add nsw i32 %mul1030, 1
  %sub1032 = sub nsw i32 %sub1018, %add1031
  br label %cond.end.1043

cond.false.1033:                                  ; preds = %cond.true.987
  %214 = load i64, i64* %fun, align 8
  %call1034 = call %struct.Lisp_Subr* @XSUBR(i64 %214)
  %max_args1035 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1034, i32 0, i32 3
  %215 = load i16, i16* %max_args1035, align 2
  %conv1036 = sext i16 %215 to i32
  %add1037 = add nsw i32 1, %conv1036
  %conv1038 = trunc i32 %add1037 to i16
  %conv1039 = sext i16 %conv1038 to i32
  %add1040 = add nsw i32 0, %conv1039
  %mul1041 = mul nsw i32 0, %add1040
  %add1042 = add nsw i32 %mul1041, 0
  br label %cond.end.1043

cond.end.1043:                                    ; preds = %cond.false.1033, %cond.true.1005
  %cond1044 = phi i32 [ %sub1032, %cond.true.1005 ], [ %add1042, %cond.false.1033 ]
  %div1045 = sdiv i32 %cond1044, 8
  %cmp1046 = icmp slt i32 %conv993, %div1045
  br i1 %cmp1046, label %cond.true.1127, label %lor.lhs.false.1095

cond.false.1048:                                  ; preds = %cond.false.978
  %216 = load i64, i64* %fun, align 8
  %call1049 = call %struct.Lisp_Subr* @XSUBR(i64 %216)
  %max_args1050 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1049, i32 0, i32 3
  %217 = load i16, i16* %max_args1050, align 2
  %conv1051 = sext i16 %217 to i32
  %add1052 = add nsw i32 1, %conv1051
  %conv1053 = trunc i32 %add1052 to i16
  %conv1054 = sext i16 %conv1053 to i32
  %add1055 = add nsw i32 0, %conv1054
  %mul1056 = mul nsw i32 0, %add1055
  %sub1057 = sub nsw i32 %mul1056, 1
  %cmp1058 = icmp slt i32 %sub1057, 0
  br i1 %cmp1058, label %cond.true.1060, label %cond.false.1074

cond.true.1060:                                   ; preds = %cond.false.1048
  %218 = load i64, i64* %fun, align 8
  %call1061 = call %struct.Lisp_Subr* @XSUBR(i64 %218)
  %max_args1062 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1061, i32 0, i32 3
  %219 = load i16, i16* %max_args1062, align 2
  %conv1063 = sext i16 %219 to i32
  %add1064 = add nsw i32 1, %conv1063
  %conv1065 = trunc i32 %add1064 to i16
  %conv1066 = sext i16 %conv1065 to i32
  %add1067 = add nsw i32 0, %conv1066
  %mul1068 = mul nsw i32 0, %add1067
  %add1069 = add nsw i32 %mul1068, 1
  %shl1070 = shl i32 %add1069, 30
  %sub1071 = sub nsw i32 %shl1070, 1
  %mul1072 = mul nsw i32 %sub1071, 2
  %add1073 = add nsw i32 %mul1072, 1
  br label %cond.end.1084

cond.false.1074:                                  ; preds = %cond.false.1048
  %220 = load i64, i64* %fun, align 8
  %call1075 = call %struct.Lisp_Subr* @XSUBR(i64 %220)
  %max_args1076 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1075, i32 0, i32 3
  %221 = load i16, i16* %max_args1076, align 2
  %conv1077 = sext i16 %221 to i32
  %add1078 = add nsw i32 1, %conv1077
  %conv1079 = trunc i32 %add1078 to i16
  %conv1080 = sext i16 %conv1079 to i32
  %add1081 = add nsw i32 0, %conv1080
  %mul1082 = mul nsw i32 0, %add1081
  %sub1083 = sub nsw i32 %mul1082, 1
  br label %cond.end.1084

cond.end.1084:                                    ; preds = %cond.false.1074, %cond.true.1060
  %cond1085 = phi i32 [ %add1073, %cond.true.1060 ], [ %sub1083, %cond.false.1074 ]
  %div1086 = sdiv i32 %cond1085, 8
  %222 = load i64, i64* %fun, align 8
  %call1087 = call %struct.Lisp_Subr* @XSUBR(i64 %222)
  %max_args1088 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1087, i32 0, i32 3
  %223 = load i16, i16* %max_args1088, align 2
  %conv1089 = sext i16 %223 to i32
  %add1090 = add nsw i32 1, %conv1089
  %conv1091 = trunc i32 %add1090 to i16
  %conv1092 = sext i16 %conv1091 to i32
  %cmp1093 = icmp slt i32 %div1086, %conv1092
  br i1 %cmp1093, label %cond.true.1127, label %lor.lhs.false.1095

lor.lhs.false.1095:                               ; preds = %cond.end.1084, %cond.end.1043, %cond.true.977, %cond.end.965, %cond.true.914, %cond.end.908
  %224 = load i64, i64* %fun, align 8
  %call1096 = call %struct.Lisp_Subr* @XSUBR(i64 %224)
  %max_args1097 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1096, i32 0, i32 3
  %225 = load i16, i16* %max_args1097, align 2
  %conv1098 = sext i16 %225 to i32
  %add1099 = add nsw i32 1, %conv1098
  %conv1100 = trunc i32 %add1099 to i16
  %conv1101 = sext i16 %conv1100 to i32
  %mul1102 = mul nsw i32 %conv1101, 8
  %mul1103 = mul nsw i32 0, %mul1102
  %sub1104 = sub nsw i32 %mul1103, 1
  %cmp1105 = icmp slt i32 %sub1104, 0
  br i1 %cmp1105, label %land.lhs.true.1107, label %lor.lhs.false.1117

land.lhs.true.1107:                               ; preds = %lor.lhs.false.1095
  %226 = load i64, i64* %fun, align 8
  %call1108 = call %struct.Lisp_Subr* @XSUBR(i64 %226)
  %max_args1109 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1108, i32 0, i32 3
  %227 = load i16, i16* %max_args1109, align 2
  %conv1110 = sext i16 %227 to i32
  %add1111 = add nsw i32 1, %conv1110
  %conv1112 = trunc i32 %add1111 to i16
  %conv1113 = sext i16 %conv1112 to i32
  %mul1114 = mul nsw i32 %conv1113, 8
  %cmp1115 = icmp slt i32 %mul1114, -32768
  br i1 %cmp1115, label %cond.true.1127, label %lor.lhs.false.1117

lor.lhs.false.1117:                               ; preds = %land.lhs.true.1107, %lor.lhs.false.1095
  %228 = load i64, i64* %fun, align 8
  %call1118 = call %struct.Lisp_Subr* @XSUBR(i64 %228)
  %max_args1119 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1118, i32 0, i32 3
  %229 = load i16, i16* %max_args1119, align 2
  %conv1120 = sext i16 %229 to i32
  %add1121 = add nsw i32 1, %conv1120
  %conv1122 = trunc i32 %add1121 to i16
  %conv1123 = sext i16 %conv1122 to i32
  %mul1124 = mul nsw i32 %conv1123, 8
  %cmp1125 = icmp slt i32 32767, %mul1124
  br i1 %cmp1125, label %cond.true.1127, label %cond.false.1162

cond.true.1127:                                   ; preds = %lor.lhs.false.1117, %land.lhs.true.1107, %cond.end.1084, %cond.end.1043, %cond.true.977, %cond.end.965, %cond.true.914, %cond.end.908, %land.lhs.true.847
  %230 = load i64, i64* %fun, align 8
  %call1128 = call %struct.Lisp_Subr* @XSUBR(i64 %230)
  %max_args1129 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1128, i32 0, i32 3
  %231 = load i16, i16* %max_args1129, align 2
  %conv1130 = sext i16 %231 to i32
  %add1131 = add nsw i32 1, %conv1130
  %conv1132 = trunc i32 %add1131 to i16
  %conv1133 = zext i16 %conv1132 to i32
  %mul1134 = mul nsw i32 %conv1133, 8
  %cmp1135 = icmp sle i32 %mul1134, 32767
  br i1 %cmp1135, label %cond.true.1137, label %cond.false.1147

cond.true.1137:                                   ; preds = %cond.true.1127
  %232 = load i64, i64* %fun, align 8
  %call1138 = call %struct.Lisp_Subr* @XSUBR(i64 %232)
  %max_args1139 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1138, i32 0, i32 3
  %233 = load i16, i16* %max_args1139, align 2
  %conv1140 = sext i16 %233 to i32
  %add1141 = add nsw i32 1, %conv1140
  %conv1142 = trunc i32 %add1141 to i16
  %conv1143 = zext i16 %conv1142 to i32
  %mul1144 = mul nsw i32 %conv1143, 8
  %conv1145 = trunc i32 %mul1144 to i16
  %conv1146 = sext i16 %conv1145 to i32
  br label %cond.end.1159

cond.false.1147:                                  ; preds = %cond.true.1127
  %234 = load i64, i64* %fun, align 8
  %call1148 = call %struct.Lisp_Subr* @XSUBR(i64 %234)
  %max_args1149 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1148, i32 0, i32 3
  %235 = load i16, i16* %max_args1149, align 2
  %conv1150 = sext i16 %235 to i32
  %add1151 = add nsw i32 1, %conv1150
  %conv1152 = trunc i32 %add1151 to i16
  %conv1153 = zext i16 %conv1152 to i32
  %mul1154 = mul nsw i32 %conv1153, 8
  %sub1155 = sub nsw i32 %mul1154, -32768
  %conv1156 = trunc i32 %sub1155 to i16
  %conv1157 = sext i16 %conv1156 to i32
  %add1158 = add nsw i32 %conv1157, -32768
  br label %cond.end.1159

cond.end.1159:                                    ; preds = %cond.false.1147, %cond.true.1137
  %cond1160 = phi i32 [ %conv1146, %cond.true.1137 ], [ %add1158, %cond.false.1147 ]
  %conv1161 = sext i32 %cond1160 to i64
  store i64 %conv1161, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.3603, label %lor.lhs.false.3600

cond.false.1162:                                  ; preds = %lor.lhs.false.1117
  %236 = load i64, i64* %fun, align 8
  %call1163 = call %struct.Lisp_Subr* @XSUBR(i64 %236)
  %max_args1164 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1163, i32 0, i32 3
  %237 = load i16, i16* %max_args1164, align 2
  %conv1165 = sext i16 %237 to i32
  %add1166 = add nsw i32 1, %conv1165
  %conv1167 = trunc i32 %add1166 to i16
  %conv1168 = zext i16 %conv1167 to i32
  %mul1169 = mul nsw i32 %conv1168, 8
  %cmp1170 = icmp sle i32 %mul1169, 32767
  br i1 %cmp1170, label %cond.true.1172, label %cond.false.1182

cond.true.1172:                                   ; preds = %cond.false.1162
  %238 = load i64, i64* %fun, align 8
  %call1173 = call %struct.Lisp_Subr* @XSUBR(i64 %238)
  %max_args1174 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1173, i32 0, i32 3
  %239 = load i16, i16* %max_args1174, align 2
  %conv1175 = sext i16 %239 to i32
  %add1176 = add nsw i32 1, %conv1175
  %conv1177 = trunc i32 %add1176 to i16
  %conv1178 = zext i16 %conv1177 to i32
  %mul1179 = mul nsw i32 %conv1178, 8
  %conv1180 = trunc i32 %mul1179 to i16
  %conv1181 = sext i16 %conv1180 to i32
  br label %cond.end.1194

cond.false.1182:                                  ; preds = %cond.false.1162
  %240 = load i64, i64* %fun, align 8
  %call1183 = call %struct.Lisp_Subr* @XSUBR(i64 %240)
  %max_args1184 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1183, i32 0, i32 3
  %241 = load i16, i16* %max_args1184, align 2
  %conv1185 = sext i16 %241 to i32
  %add1186 = add nsw i32 1, %conv1185
  %conv1187 = trunc i32 %add1186 to i16
  %conv1188 = zext i16 %conv1187 to i32
  %mul1189 = mul nsw i32 %conv1188, 8
  %sub1190 = sub nsw i32 %mul1189, -32768
  %conv1191 = trunc i32 %sub1190 to i16
  %conv1192 = sext i16 %conv1191 to i32
  %add1193 = add nsw i32 %conv1192, -32768
  br label %cond.end.1194

cond.end.1194:                                    ; preds = %cond.false.1182, %cond.true.1172
  %cond1195 = phi i32 [ %conv1181, %cond.true.1172 ], [ %add1193, %cond.false.1182 ]
  %conv1196 = sext i32 %cond1195 to i64
  store i64 %conv1196, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.3603, label %lor.lhs.false.3600

cond.false.1197:                                  ; preds = %cond.true.792
  %242 = load i64, i64* %fun, align 8
  %call1198 = call %struct.Lisp_Subr* @XSUBR(i64 %242)
  %max_args1199 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1198, i32 0, i32 3
  %243 = load i16, i16* %max_args1199, align 2
  %conv1200 = sext i16 %243 to i32
  %add1201 = add nsw i32 1, %conv1200
  %add1202 = add nsw i32 0, %add1201
  %mul1203 = mul nsw i32 0, %add1202
  %sub1204 = sub nsw i32 %mul1203, 1
  %cmp1205 = icmp slt i32 %sub1204, 0
  br i1 %cmp1205, label %cond.true.1207, label %cond.false.1231

cond.true.1207:                                   ; preds = %cond.false.1197
  %244 = load i64, i64* %fun, align 8
  %call1208 = call %struct.Lisp_Subr* @XSUBR(i64 %244)
  %max_args1209 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1208, i32 0, i32 3
  %245 = load i16, i16* %max_args1209, align 2
  %conv1210 = sext i16 %245 to i32
  %add1211 = add nsw i32 1, %conv1210
  %add1212 = add nsw i32 0, %add1211
  %mul1213 = mul nsw i32 0, %add1212
  %add1214 = add nsw i32 %mul1213, 0
  %neg1215 = xor i32 %add1214, -1
  %cmp1216 = icmp eq i32 %neg1215, -1
  %conv1217 = zext i1 %cmp1216 to i32
  %sub1218 = sub nsw i32 0, %conv1217
  %246 = load i64, i64* %fun, align 8
  %call1219 = call %struct.Lisp_Subr* @XSUBR(i64 %246)
  %max_args1220 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1219, i32 0, i32 3
  %247 = load i16, i16* %max_args1220, align 2
  %conv1221 = sext i16 %247 to i32
  %add1222 = add nsw i32 1, %conv1221
  %add1223 = add nsw i32 0, %add1222
  %mul1224 = mul nsw i32 0, %add1223
  %add1225 = add nsw i32 %mul1224, 1
  %shl1226 = shl i32 %add1225, 30
  %sub1227 = sub nsw i32 %shl1226, 1
  %mul1228 = mul nsw i32 %sub1227, 2
  %add1229 = add nsw i32 %mul1228, 1
  %sub1230 = sub nsw i32 %sub1218, %add1229
  br label %cond.end.1239

cond.false.1231:                                  ; preds = %cond.false.1197
  %248 = load i64, i64* %fun, align 8
  %call1232 = call %struct.Lisp_Subr* @XSUBR(i64 %248)
  %max_args1233 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1232, i32 0, i32 3
  %249 = load i16, i16* %max_args1233, align 2
  %conv1234 = sext i16 %249 to i32
  %add1235 = add nsw i32 1, %conv1234
  %add1236 = add nsw i32 0, %add1235
  %mul1237 = mul nsw i32 0, %add1236
  %add1238 = add nsw i32 %mul1237, 0
  br label %cond.end.1239

cond.end.1239:                                    ; preds = %cond.false.1231, %cond.true.1207
  %cond1240 = phi i32 [ %sub1230, %cond.true.1207 ], [ %add1238, %cond.false.1231 ]
  %cmp1241 = icmp eq i32 %cond1240, 0
  br i1 %cmp1241, label %land.lhs.true.1243, label %lor.lhs.false.1250

land.lhs.true.1243:                               ; preds = %cond.end.1239
  %250 = load i64, i64* %fun, align 8
  %call1244 = call %struct.Lisp_Subr* @XSUBR(i64 %250)
  %max_args1245 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1244, i32 0, i32 3
  %251 = load i16, i16* %max_args1245, align 2
  %conv1246 = sext i16 %251 to i32
  %add1247 = add nsw i32 1, %conv1246
  %cmp1248 = icmp slt i32 %add1247, 0
  br i1 %cmp1248, label %cond.true.1475, label %lor.lhs.false.1250

lor.lhs.false.1250:                               ; preds = %land.lhs.true.1243, %cond.end.1239
  br i1 false, label %cond.true.1251, label %cond.false.1350

cond.true.1251:                                   ; preds = %lor.lhs.false.1250
  %252 = load i64, i64* %fun, align 8
  %call1252 = call %struct.Lisp_Subr* @XSUBR(i64 %252)
  %max_args1253 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1252, i32 0, i32 3
  %253 = load i16, i16* %max_args1253, align 2
  %conv1254 = sext i16 %253 to i32
  %add1255 = add nsw i32 1, %conv1254
  %cmp1256 = icmp slt i32 %add1255, 0
  br i1 %cmp1256, label %cond.true.1258, label %cond.false.1297

cond.true.1258:                                   ; preds = %cond.true.1251
  %254 = load i64, i64* %fun, align 8
  %call1259 = call %struct.Lisp_Subr* @XSUBR(i64 %254)
  %max_args1260 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1259, i32 0, i32 3
  %255 = load i16, i16* %max_args1260, align 2
  %conv1261 = sext i16 %255 to i32
  %add1262 = add nsw i32 1, %conv1261
  %256 = load i64, i64* %fun, align 8
  %call1263 = call %struct.Lisp_Subr* @XSUBR(i64 %256)
  %max_args1264 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1263, i32 0, i32 3
  %257 = load i16, i16* %max_args1264, align 2
  %conv1265 = sext i16 %257 to i32
  %add1266 = add nsw i32 1, %conv1265
  %add1267 = add nsw i32 0, %add1266
  %mul1268 = mul nsw i32 0, %add1267
  %sub1269 = sub nsw i32 %mul1268, 1
  %cmp1270 = icmp slt i32 %sub1269, 0
  br i1 %cmp1270, label %cond.true.1272, label %cond.false.1284

cond.true.1272:                                   ; preds = %cond.true.1258
  %258 = load i64, i64* %fun, align 8
  %call1273 = call %struct.Lisp_Subr* @XSUBR(i64 %258)
  %max_args1274 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1273, i32 0, i32 3
  %259 = load i16, i16* %max_args1274, align 2
  %conv1275 = sext i16 %259 to i32
  %add1276 = add nsw i32 1, %conv1275
  %add1277 = add nsw i32 0, %add1276
  %mul1278 = mul nsw i32 0, %add1277
  %add1279 = add nsw i32 %mul1278, 1
  %shl1280 = shl i32 %add1279, 30
  %sub1281 = sub nsw i32 %shl1280, 1
  %mul1282 = mul nsw i32 %sub1281, 2
  %add1283 = add nsw i32 %mul1282, 1
  br label %cond.end.1292

cond.false.1284:                                  ; preds = %cond.true.1258
  %260 = load i64, i64* %fun, align 8
  %call1285 = call %struct.Lisp_Subr* @XSUBR(i64 %260)
  %max_args1286 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1285, i32 0, i32 3
  %261 = load i16, i16* %max_args1286, align 2
  %conv1287 = sext i16 %261 to i32
  %add1288 = add nsw i32 1, %conv1287
  %add1289 = add nsw i32 0, %add1288
  %mul1290 = mul nsw i32 0, %add1289
  %sub1291 = sub nsw i32 %mul1290, 1
  br label %cond.end.1292

cond.end.1292:                                    ; preds = %cond.false.1284, %cond.true.1272
  %cond1293 = phi i32 [ %add1283, %cond.true.1272 ], [ %sub1291, %cond.false.1284 ]
  %div1294 = sdiv i32 %cond1293, 8
  %cmp1295 = icmp slt i32 %add1262, %div1294
  br i1 %cmp1295, label %cond.true.1475, label %lor.lhs.false.1449

cond.false.1297:                                  ; preds = %cond.true.1251
  br i1 false, label %cond.true.1298, label %cond.false.1299

cond.true.1298:                                   ; preds = %cond.false.1297
  br i1 false, label %cond.true.1475, label %lor.lhs.false.1449

cond.false.1299:                                  ; preds = %cond.false.1297
  %262 = load i64, i64* %fun, align 8
  %call1300 = call %struct.Lisp_Subr* @XSUBR(i64 %262)
  %max_args1301 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1300, i32 0, i32 3
  %263 = load i16, i16* %max_args1301, align 2
  %conv1302 = sext i16 %263 to i32
  %add1303 = add nsw i32 1, %conv1302
  %add1304 = add nsw i32 0, %add1303
  %mul1305 = mul nsw i32 0, %add1304
  %sub1306 = sub nsw i32 %mul1305, 1
  %cmp1307 = icmp slt i32 %sub1306, 0
  br i1 %cmp1307, label %cond.true.1309, label %cond.false.1333

cond.true.1309:                                   ; preds = %cond.false.1299
  %264 = load i64, i64* %fun, align 8
  %call1310 = call %struct.Lisp_Subr* @XSUBR(i64 %264)
  %max_args1311 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1310, i32 0, i32 3
  %265 = load i16, i16* %max_args1311, align 2
  %conv1312 = sext i16 %265 to i32
  %add1313 = add nsw i32 1, %conv1312
  %add1314 = add nsw i32 0, %add1313
  %mul1315 = mul nsw i32 0, %add1314
  %add1316 = add nsw i32 %mul1315, 0
  %neg1317 = xor i32 %add1316, -1
  %cmp1318 = icmp eq i32 %neg1317, -1
  %conv1319 = zext i1 %cmp1318 to i32
  %sub1320 = sub nsw i32 0, %conv1319
  %266 = load i64, i64* %fun, align 8
  %call1321 = call %struct.Lisp_Subr* @XSUBR(i64 %266)
  %max_args1322 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1321, i32 0, i32 3
  %267 = load i16, i16* %max_args1322, align 2
  %conv1323 = sext i16 %267 to i32
  %add1324 = add nsw i32 1, %conv1323
  %add1325 = add nsw i32 0, %add1324
  %mul1326 = mul nsw i32 0, %add1325
  %add1327 = add nsw i32 %mul1326, 1
  %shl1328 = shl i32 %add1327, 30
  %sub1329 = sub nsw i32 %shl1328, 1
  %mul1330 = mul nsw i32 %sub1329, 2
  %add1331 = add nsw i32 %mul1330, 1
  %sub1332 = sub nsw i32 %sub1320, %add1331
  br label %cond.end.1341

cond.false.1333:                                  ; preds = %cond.false.1299
  %268 = load i64, i64* %fun, align 8
  %call1334 = call %struct.Lisp_Subr* @XSUBR(i64 %268)
  %max_args1335 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1334, i32 0, i32 3
  %269 = load i16, i16* %max_args1335, align 2
  %conv1336 = sext i16 %269 to i32
  %add1337 = add nsw i32 1, %conv1336
  %add1338 = add nsw i32 0, %add1337
  %mul1339 = mul nsw i32 0, %add1338
  %add1340 = add nsw i32 %mul1339, 0
  br label %cond.end.1341

cond.end.1341:                                    ; preds = %cond.false.1333, %cond.true.1309
  %cond1342 = phi i32 [ %sub1332, %cond.true.1309 ], [ %add1340, %cond.false.1333 ]
  %div1343 = sdiv i32 %cond1342, 8
  %270 = load i64, i64* %fun, align 8
  %call1344 = call %struct.Lisp_Subr* @XSUBR(i64 %270)
  %max_args1345 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1344, i32 0, i32 3
  %271 = load i16, i16* %max_args1345, align 2
  %conv1346 = sext i16 %271 to i32
  %add1347 = add nsw i32 1, %conv1346
  %cmp1348 = icmp slt i32 %div1343, %add1347
  br i1 %cmp1348, label %cond.true.1475, label %lor.lhs.false.1449

cond.false.1350:                                  ; preds = %lor.lhs.false.1250
  br i1 false, label %cond.true.1351, label %cond.false.1352

cond.true.1351:                                   ; preds = %cond.false.1350
  br i1 false, label %cond.true.1475, label %lor.lhs.false.1449

cond.false.1352:                                  ; preds = %cond.false.1350
  %272 = load i64, i64* %fun, align 8
  %call1353 = call %struct.Lisp_Subr* @XSUBR(i64 %272)
  %max_args1354 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1353, i32 0, i32 3
  %273 = load i16, i16* %max_args1354, align 2
  %conv1355 = sext i16 %273 to i32
  %add1356 = add nsw i32 1, %conv1355
  %cmp1357 = icmp slt i32 %add1356, 0
  br i1 %cmp1357, label %cond.true.1359, label %cond.false.1410

cond.true.1359:                                   ; preds = %cond.false.1352
  %274 = load i64, i64* %fun, align 8
  %call1360 = call %struct.Lisp_Subr* @XSUBR(i64 %274)
  %max_args1361 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1360, i32 0, i32 3
  %275 = load i16, i16* %max_args1361, align 2
  %conv1362 = sext i16 %275 to i32
  %add1363 = add nsw i32 1, %conv1362
  %276 = load i64, i64* %fun, align 8
  %call1364 = call %struct.Lisp_Subr* @XSUBR(i64 %276)
  %max_args1365 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1364, i32 0, i32 3
  %277 = load i16, i16* %max_args1365, align 2
  %conv1366 = sext i16 %277 to i32
  %add1367 = add nsw i32 1, %conv1366
  %add1368 = add nsw i32 0, %add1367
  %mul1369 = mul nsw i32 0, %add1368
  %sub1370 = sub nsw i32 %mul1369, 1
  %cmp1371 = icmp slt i32 %sub1370, 0
  br i1 %cmp1371, label %cond.true.1373, label %cond.false.1397

cond.true.1373:                                   ; preds = %cond.true.1359
  %278 = load i64, i64* %fun, align 8
  %call1374 = call %struct.Lisp_Subr* @XSUBR(i64 %278)
  %max_args1375 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1374, i32 0, i32 3
  %279 = load i16, i16* %max_args1375, align 2
  %conv1376 = sext i16 %279 to i32
  %add1377 = add nsw i32 1, %conv1376
  %add1378 = add nsw i32 0, %add1377
  %mul1379 = mul nsw i32 0, %add1378
  %add1380 = add nsw i32 %mul1379, 0
  %neg1381 = xor i32 %add1380, -1
  %cmp1382 = icmp eq i32 %neg1381, -1
  %conv1383 = zext i1 %cmp1382 to i32
  %sub1384 = sub nsw i32 0, %conv1383
  %280 = load i64, i64* %fun, align 8
  %call1385 = call %struct.Lisp_Subr* @XSUBR(i64 %280)
  %max_args1386 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1385, i32 0, i32 3
  %281 = load i16, i16* %max_args1386, align 2
  %conv1387 = sext i16 %281 to i32
  %add1388 = add nsw i32 1, %conv1387
  %add1389 = add nsw i32 0, %add1388
  %mul1390 = mul nsw i32 0, %add1389
  %add1391 = add nsw i32 %mul1390, 1
  %shl1392 = shl i32 %add1391, 30
  %sub1393 = sub nsw i32 %shl1392, 1
  %mul1394 = mul nsw i32 %sub1393, 2
  %add1395 = add nsw i32 %mul1394, 1
  %sub1396 = sub nsw i32 %sub1384, %add1395
  br label %cond.end.1405

cond.false.1397:                                  ; preds = %cond.true.1359
  %282 = load i64, i64* %fun, align 8
  %call1398 = call %struct.Lisp_Subr* @XSUBR(i64 %282)
  %max_args1399 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1398, i32 0, i32 3
  %283 = load i16, i16* %max_args1399, align 2
  %conv1400 = sext i16 %283 to i32
  %add1401 = add nsw i32 1, %conv1400
  %add1402 = add nsw i32 0, %add1401
  %mul1403 = mul nsw i32 0, %add1402
  %add1404 = add nsw i32 %mul1403, 0
  br label %cond.end.1405

cond.end.1405:                                    ; preds = %cond.false.1397, %cond.true.1373
  %cond1406 = phi i32 [ %sub1396, %cond.true.1373 ], [ %add1404, %cond.false.1397 ]
  %div1407 = sdiv i32 %cond1406, 8
  %cmp1408 = icmp slt i32 %add1363, %div1407
  br i1 %cmp1408, label %cond.true.1475, label %lor.lhs.false.1449

cond.false.1410:                                  ; preds = %cond.false.1352
  %284 = load i64, i64* %fun, align 8
  %call1411 = call %struct.Lisp_Subr* @XSUBR(i64 %284)
  %max_args1412 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1411, i32 0, i32 3
  %285 = load i16, i16* %max_args1412, align 2
  %conv1413 = sext i16 %285 to i32
  %add1414 = add nsw i32 1, %conv1413
  %add1415 = add nsw i32 0, %add1414
  %mul1416 = mul nsw i32 0, %add1415
  %sub1417 = sub nsw i32 %mul1416, 1
  %cmp1418 = icmp slt i32 %sub1417, 0
  br i1 %cmp1418, label %cond.true.1420, label %cond.false.1432

cond.true.1420:                                   ; preds = %cond.false.1410
  %286 = load i64, i64* %fun, align 8
  %call1421 = call %struct.Lisp_Subr* @XSUBR(i64 %286)
  %max_args1422 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1421, i32 0, i32 3
  %287 = load i16, i16* %max_args1422, align 2
  %conv1423 = sext i16 %287 to i32
  %add1424 = add nsw i32 1, %conv1423
  %add1425 = add nsw i32 0, %add1424
  %mul1426 = mul nsw i32 0, %add1425
  %add1427 = add nsw i32 %mul1426, 1
  %shl1428 = shl i32 %add1427, 30
  %sub1429 = sub nsw i32 %shl1428, 1
  %mul1430 = mul nsw i32 %sub1429, 2
  %add1431 = add nsw i32 %mul1430, 1
  br label %cond.end.1440

cond.false.1432:                                  ; preds = %cond.false.1410
  %288 = load i64, i64* %fun, align 8
  %call1433 = call %struct.Lisp_Subr* @XSUBR(i64 %288)
  %max_args1434 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1433, i32 0, i32 3
  %289 = load i16, i16* %max_args1434, align 2
  %conv1435 = sext i16 %289 to i32
  %add1436 = add nsw i32 1, %conv1435
  %add1437 = add nsw i32 0, %add1436
  %mul1438 = mul nsw i32 0, %add1437
  %sub1439 = sub nsw i32 %mul1438, 1
  br label %cond.end.1440

cond.end.1440:                                    ; preds = %cond.false.1432, %cond.true.1420
  %cond1441 = phi i32 [ %add1431, %cond.true.1420 ], [ %sub1439, %cond.false.1432 ]
  %div1442 = sdiv i32 %cond1441, 8
  %290 = load i64, i64* %fun, align 8
  %call1443 = call %struct.Lisp_Subr* @XSUBR(i64 %290)
  %max_args1444 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1443, i32 0, i32 3
  %291 = load i16, i16* %max_args1444, align 2
  %conv1445 = sext i16 %291 to i32
  %add1446 = add nsw i32 1, %conv1445
  %cmp1447 = icmp slt i32 %div1442, %add1446
  br i1 %cmp1447, label %cond.true.1475, label %lor.lhs.false.1449

lor.lhs.false.1449:                               ; preds = %cond.end.1440, %cond.end.1405, %cond.true.1351, %cond.end.1341, %cond.true.1298, %cond.end.1292
  %292 = load i64, i64* %fun, align 8
  %call1450 = call %struct.Lisp_Subr* @XSUBR(i64 %292)
  %max_args1451 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1450, i32 0, i32 3
  %293 = load i16, i16* %max_args1451, align 2
  %conv1452 = sext i16 %293 to i32
  %add1453 = add nsw i32 1, %conv1452
  %mul1454 = mul nsw i32 %add1453, 8
  %mul1455 = mul nsw i32 0, %mul1454
  %sub1456 = sub nsw i32 %mul1455, 1
  %cmp1457 = icmp slt i32 %sub1456, 0
  br i1 %cmp1457, label %land.lhs.true.1459, label %lor.lhs.false.1467

land.lhs.true.1459:                               ; preds = %lor.lhs.false.1449
  %294 = load i64, i64* %fun, align 8
  %call1460 = call %struct.Lisp_Subr* @XSUBR(i64 %294)
  %max_args1461 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1460, i32 0, i32 3
  %295 = load i16, i16* %max_args1461, align 2
  %conv1462 = sext i16 %295 to i32
  %add1463 = add nsw i32 1, %conv1462
  %mul1464 = mul nsw i32 %add1463, 8
  %cmp1465 = icmp slt i32 %mul1464, -32768
  br i1 %cmp1465, label %cond.true.1475, label %lor.lhs.false.1467

lor.lhs.false.1467:                               ; preds = %land.lhs.true.1459, %lor.lhs.false.1449
  %296 = load i64, i64* %fun, align 8
  %call1468 = call %struct.Lisp_Subr* @XSUBR(i64 %296)
  %max_args1469 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1468, i32 0, i32 3
  %297 = load i16, i16* %max_args1469, align 2
  %conv1470 = sext i16 %297 to i32
  %add1471 = add nsw i32 1, %conv1470
  %mul1472 = mul nsw i32 %add1471, 8
  %cmp1473 = icmp slt i32 32767, %mul1472
  br i1 %cmp1473, label %cond.true.1475, label %cond.false.1510

cond.true.1475:                                   ; preds = %lor.lhs.false.1467, %land.lhs.true.1459, %cond.end.1440, %cond.end.1405, %cond.true.1351, %cond.end.1341, %cond.true.1298, %cond.end.1292, %land.lhs.true.1243
  %298 = load i64, i64* %fun, align 8
  %call1476 = call %struct.Lisp_Subr* @XSUBR(i64 %298)
  %max_args1477 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1476, i32 0, i32 3
  %299 = load i16, i16* %max_args1477, align 2
  %conv1478 = sext i16 %299 to i32
  %add1479 = add nsw i32 1, %conv1478
  %conv1480 = trunc i32 %add1479 to i16
  %conv1481 = zext i16 %conv1480 to i32
  %mul1482 = mul nsw i32 %conv1481, 8
  %cmp1483 = icmp sle i32 %mul1482, 32767
  br i1 %cmp1483, label %cond.true.1485, label %cond.false.1495

cond.true.1485:                                   ; preds = %cond.true.1475
  %300 = load i64, i64* %fun, align 8
  %call1486 = call %struct.Lisp_Subr* @XSUBR(i64 %300)
  %max_args1487 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1486, i32 0, i32 3
  %301 = load i16, i16* %max_args1487, align 2
  %conv1488 = sext i16 %301 to i32
  %add1489 = add nsw i32 1, %conv1488
  %conv1490 = trunc i32 %add1489 to i16
  %conv1491 = zext i16 %conv1490 to i32
  %mul1492 = mul nsw i32 %conv1491, 8
  %conv1493 = trunc i32 %mul1492 to i16
  %conv1494 = sext i16 %conv1493 to i32
  br label %cond.end.1507

cond.false.1495:                                  ; preds = %cond.true.1475
  %302 = load i64, i64* %fun, align 8
  %call1496 = call %struct.Lisp_Subr* @XSUBR(i64 %302)
  %max_args1497 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1496, i32 0, i32 3
  %303 = load i16, i16* %max_args1497, align 2
  %conv1498 = sext i16 %303 to i32
  %add1499 = add nsw i32 1, %conv1498
  %conv1500 = trunc i32 %add1499 to i16
  %conv1501 = zext i16 %conv1500 to i32
  %mul1502 = mul nsw i32 %conv1501, 8
  %sub1503 = sub nsw i32 %mul1502, -32768
  %conv1504 = trunc i32 %sub1503 to i16
  %conv1505 = sext i16 %conv1504 to i32
  %add1506 = add nsw i32 %conv1505, -32768
  br label %cond.end.1507

cond.end.1507:                                    ; preds = %cond.false.1495, %cond.true.1485
  %cond1508 = phi i32 [ %conv1494, %cond.true.1485 ], [ %add1506, %cond.false.1495 ]
  %conv1509 = sext i32 %cond1508 to i64
  store i64 %conv1509, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.3603, label %lor.lhs.false.3600

cond.false.1510:                                  ; preds = %lor.lhs.false.1467
  %304 = load i64, i64* %fun, align 8
  %call1511 = call %struct.Lisp_Subr* @XSUBR(i64 %304)
  %max_args1512 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1511, i32 0, i32 3
  %305 = load i16, i16* %max_args1512, align 2
  %conv1513 = sext i16 %305 to i32
  %add1514 = add nsw i32 1, %conv1513
  %conv1515 = trunc i32 %add1514 to i16
  %conv1516 = zext i16 %conv1515 to i32
  %mul1517 = mul nsw i32 %conv1516, 8
  %cmp1518 = icmp sle i32 %mul1517, 32767
  br i1 %cmp1518, label %cond.true.1520, label %cond.false.1530

cond.true.1520:                                   ; preds = %cond.false.1510
  %306 = load i64, i64* %fun, align 8
  %call1521 = call %struct.Lisp_Subr* @XSUBR(i64 %306)
  %max_args1522 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1521, i32 0, i32 3
  %307 = load i16, i16* %max_args1522, align 2
  %conv1523 = sext i16 %307 to i32
  %add1524 = add nsw i32 1, %conv1523
  %conv1525 = trunc i32 %add1524 to i16
  %conv1526 = zext i16 %conv1525 to i32
  %mul1527 = mul nsw i32 %conv1526, 8
  %conv1528 = trunc i32 %mul1527 to i16
  %conv1529 = sext i16 %conv1528 to i32
  br label %cond.end.1542

cond.false.1530:                                  ; preds = %cond.false.1510
  %308 = load i64, i64* %fun, align 8
  %call1531 = call %struct.Lisp_Subr* @XSUBR(i64 %308)
  %max_args1532 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1531, i32 0, i32 3
  %309 = load i16, i16* %max_args1532, align 2
  %conv1533 = sext i16 %309 to i32
  %add1534 = add nsw i32 1, %conv1533
  %conv1535 = trunc i32 %add1534 to i16
  %conv1536 = zext i16 %conv1535 to i32
  %mul1537 = mul nsw i32 %conv1536, 8
  %sub1538 = sub nsw i32 %mul1537, -32768
  %conv1539 = trunc i32 %sub1538 to i16
  %conv1540 = sext i16 %conv1539 to i32
  %add1541 = add nsw i32 %conv1540, -32768
  br label %cond.end.1542

cond.end.1542:                                    ; preds = %cond.false.1530, %cond.true.1520
  %cond1543 = phi i32 [ %conv1529, %cond.true.1520 ], [ %add1541, %cond.false.1530 ]
  %conv1544 = sext i32 %cond1543 to i64
  store i64 %conv1544, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.3603, label %lor.lhs.false.3600

cond.false.1545:                                  ; preds = %cond.false.791
  br i1 false, label %cond.true.1546, label %cond.false.2203

cond.true.1546:                                   ; preds = %cond.false.1545
  br i1 false, label %cond.true.1547, label %cond.false.1875

cond.true.1547:                                   ; preds = %cond.true.1546
  %310 = load i64, i64* %fun, align 8
  %call1548 = call %struct.Lisp_Subr* @XSUBR(i64 %310)
  %max_args1549 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1548, i32 0, i32 3
  %311 = load i16, i16* %max_args1549, align 2
  %conv1550 = sext i16 %311 to i32
  %add1551 = add nsw i32 1, %conv1550
  %add1552 = add nsw i32 0, %add1551
  %mul1553 = mul nsw i32 0, %add1552
  %sub1554 = sub nsw i32 %mul1553, 1
  %cmp1555 = icmp slt i32 %sub1554, 0
  br i1 %cmp1555, label %cond.true.1557, label %cond.false.1581

cond.true.1557:                                   ; preds = %cond.true.1547
  %312 = load i64, i64* %fun, align 8
  %call1558 = call %struct.Lisp_Subr* @XSUBR(i64 %312)
  %max_args1559 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1558, i32 0, i32 3
  %313 = load i16, i16* %max_args1559, align 2
  %conv1560 = sext i16 %313 to i32
  %add1561 = add nsw i32 1, %conv1560
  %add1562 = add nsw i32 0, %add1561
  %mul1563 = mul nsw i32 0, %add1562
  %add1564 = add nsw i32 %mul1563, 0
  %neg1565 = xor i32 %add1564, -1
  %cmp1566 = icmp eq i32 %neg1565, -1
  %conv1567 = zext i1 %cmp1566 to i32
  %sub1568 = sub nsw i32 0, %conv1567
  %314 = load i64, i64* %fun, align 8
  %call1569 = call %struct.Lisp_Subr* @XSUBR(i64 %314)
  %max_args1570 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1569, i32 0, i32 3
  %315 = load i16, i16* %max_args1570, align 2
  %conv1571 = sext i16 %315 to i32
  %add1572 = add nsw i32 1, %conv1571
  %add1573 = add nsw i32 0, %add1572
  %mul1574 = mul nsw i32 0, %add1573
  %add1575 = add nsw i32 %mul1574, 1
  %shl1576 = shl i32 %add1575, 30
  %sub1577 = sub nsw i32 %shl1576, 1
  %mul1578 = mul nsw i32 %sub1577, 2
  %add1579 = add nsw i32 %mul1578, 1
  %sub1580 = sub nsw i32 %sub1568, %add1579
  br label %cond.end.1589

cond.false.1581:                                  ; preds = %cond.true.1547
  %316 = load i64, i64* %fun, align 8
  %call1582 = call %struct.Lisp_Subr* @XSUBR(i64 %316)
  %max_args1583 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1582, i32 0, i32 3
  %317 = load i16, i16* %max_args1583, align 2
  %conv1584 = sext i16 %317 to i32
  %add1585 = add nsw i32 1, %conv1584
  %add1586 = add nsw i32 0, %add1585
  %mul1587 = mul nsw i32 0, %add1586
  %add1588 = add nsw i32 %mul1587, 0
  br label %cond.end.1589

cond.end.1589:                                    ; preds = %cond.false.1581, %cond.true.1557
  %cond1590 = phi i32 [ %sub1580, %cond.true.1557 ], [ %add1588, %cond.false.1581 ]
  %cmp1591 = icmp eq i32 %cond1590, 0
  br i1 %cmp1591, label %land.lhs.true.1593, label %lor.lhs.false.1600

land.lhs.true.1593:                               ; preds = %cond.end.1589
  %318 = load i64, i64* %fun, align 8
  %call1594 = call %struct.Lisp_Subr* @XSUBR(i64 %318)
  %max_args1595 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1594, i32 0, i32 3
  %319 = load i16, i16* %max_args1595, align 2
  %conv1596 = sext i16 %319 to i32
  %add1597 = add nsw i32 1, %conv1596
  %cmp1598 = icmp slt i32 %add1597, 0
  br i1 %cmp1598, label %cond.true.1825, label %lor.lhs.false.1600

lor.lhs.false.1600:                               ; preds = %land.lhs.true.1593, %cond.end.1589
  br i1 false, label %cond.true.1601, label %cond.false.1700

cond.true.1601:                                   ; preds = %lor.lhs.false.1600
  %320 = load i64, i64* %fun, align 8
  %call1602 = call %struct.Lisp_Subr* @XSUBR(i64 %320)
  %max_args1603 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1602, i32 0, i32 3
  %321 = load i16, i16* %max_args1603, align 2
  %conv1604 = sext i16 %321 to i32
  %add1605 = add nsw i32 1, %conv1604
  %cmp1606 = icmp slt i32 %add1605, 0
  br i1 %cmp1606, label %cond.true.1608, label %cond.false.1647

cond.true.1608:                                   ; preds = %cond.true.1601
  %322 = load i64, i64* %fun, align 8
  %call1609 = call %struct.Lisp_Subr* @XSUBR(i64 %322)
  %max_args1610 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1609, i32 0, i32 3
  %323 = load i16, i16* %max_args1610, align 2
  %conv1611 = sext i16 %323 to i32
  %add1612 = add nsw i32 1, %conv1611
  %324 = load i64, i64* %fun, align 8
  %call1613 = call %struct.Lisp_Subr* @XSUBR(i64 %324)
  %max_args1614 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1613, i32 0, i32 3
  %325 = load i16, i16* %max_args1614, align 2
  %conv1615 = sext i16 %325 to i32
  %add1616 = add nsw i32 1, %conv1615
  %add1617 = add nsw i32 0, %add1616
  %mul1618 = mul nsw i32 0, %add1617
  %sub1619 = sub nsw i32 %mul1618, 1
  %cmp1620 = icmp slt i32 %sub1619, 0
  br i1 %cmp1620, label %cond.true.1622, label %cond.false.1634

cond.true.1622:                                   ; preds = %cond.true.1608
  %326 = load i64, i64* %fun, align 8
  %call1623 = call %struct.Lisp_Subr* @XSUBR(i64 %326)
  %max_args1624 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1623, i32 0, i32 3
  %327 = load i16, i16* %max_args1624, align 2
  %conv1625 = sext i16 %327 to i32
  %add1626 = add nsw i32 1, %conv1625
  %add1627 = add nsw i32 0, %add1626
  %mul1628 = mul nsw i32 0, %add1627
  %add1629 = add nsw i32 %mul1628, 1
  %shl1630 = shl i32 %add1629, 30
  %sub1631 = sub nsw i32 %shl1630, 1
  %mul1632 = mul nsw i32 %sub1631, 2
  %add1633 = add nsw i32 %mul1632, 1
  br label %cond.end.1642

cond.false.1634:                                  ; preds = %cond.true.1608
  %328 = load i64, i64* %fun, align 8
  %call1635 = call %struct.Lisp_Subr* @XSUBR(i64 %328)
  %max_args1636 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1635, i32 0, i32 3
  %329 = load i16, i16* %max_args1636, align 2
  %conv1637 = sext i16 %329 to i32
  %add1638 = add nsw i32 1, %conv1637
  %add1639 = add nsw i32 0, %add1638
  %mul1640 = mul nsw i32 0, %add1639
  %sub1641 = sub nsw i32 %mul1640, 1
  br label %cond.end.1642

cond.end.1642:                                    ; preds = %cond.false.1634, %cond.true.1622
  %cond1643 = phi i32 [ %add1633, %cond.true.1622 ], [ %sub1641, %cond.false.1634 ]
  %div1644 = sdiv i32 %cond1643, 8
  %cmp1645 = icmp slt i32 %add1612, %div1644
  br i1 %cmp1645, label %cond.true.1825, label %lor.lhs.false.1799

cond.false.1647:                                  ; preds = %cond.true.1601
  br i1 false, label %cond.true.1648, label %cond.false.1649

cond.true.1648:                                   ; preds = %cond.false.1647
  br i1 false, label %cond.true.1825, label %lor.lhs.false.1799

cond.false.1649:                                  ; preds = %cond.false.1647
  %330 = load i64, i64* %fun, align 8
  %call1650 = call %struct.Lisp_Subr* @XSUBR(i64 %330)
  %max_args1651 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1650, i32 0, i32 3
  %331 = load i16, i16* %max_args1651, align 2
  %conv1652 = sext i16 %331 to i32
  %add1653 = add nsw i32 1, %conv1652
  %add1654 = add nsw i32 0, %add1653
  %mul1655 = mul nsw i32 0, %add1654
  %sub1656 = sub nsw i32 %mul1655, 1
  %cmp1657 = icmp slt i32 %sub1656, 0
  br i1 %cmp1657, label %cond.true.1659, label %cond.false.1683

cond.true.1659:                                   ; preds = %cond.false.1649
  %332 = load i64, i64* %fun, align 8
  %call1660 = call %struct.Lisp_Subr* @XSUBR(i64 %332)
  %max_args1661 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1660, i32 0, i32 3
  %333 = load i16, i16* %max_args1661, align 2
  %conv1662 = sext i16 %333 to i32
  %add1663 = add nsw i32 1, %conv1662
  %add1664 = add nsw i32 0, %add1663
  %mul1665 = mul nsw i32 0, %add1664
  %add1666 = add nsw i32 %mul1665, 0
  %neg1667 = xor i32 %add1666, -1
  %cmp1668 = icmp eq i32 %neg1667, -1
  %conv1669 = zext i1 %cmp1668 to i32
  %sub1670 = sub nsw i32 0, %conv1669
  %334 = load i64, i64* %fun, align 8
  %call1671 = call %struct.Lisp_Subr* @XSUBR(i64 %334)
  %max_args1672 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1671, i32 0, i32 3
  %335 = load i16, i16* %max_args1672, align 2
  %conv1673 = sext i16 %335 to i32
  %add1674 = add nsw i32 1, %conv1673
  %add1675 = add nsw i32 0, %add1674
  %mul1676 = mul nsw i32 0, %add1675
  %add1677 = add nsw i32 %mul1676, 1
  %shl1678 = shl i32 %add1677, 30
  %sub1679 = sub nsw i32 %shl1678, 1
  %mul1680 = mul nsw i32 %sub1679, 2
  %add1681 = add nsw i32 %mul1680, 1
  %sub1682 = sub nsw i32 %sub1670, %add1681
  br label %cond.end.1691

cond.false.1683:                                  ; preds = %cond.false.1649
  %336 = load i64, i64* %fun, align 8
  %call1684 = call %struct.Lisp_Subr* @XSUBR(i64 %336)
  %max_args1685 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1684, i32 0, i32 3
  %337 = load i16, i16* %max_args1685, align 2
  %conv1686 = sext i16 %337 to i32
  %add1687 = add nsw i32 1, %conv1686
  %add1688 = add nsw i32 0, %add1687
  %mul1689 = mul nsw i32 0, %add1688
  %add1690 = add nsw i32 %mul1689, 0
  br label %cond.end.1691

cond.end.1691:                                    ; preds = %cond.false.1683, %cond.true.1659
  %cond1692 = phi i32 [ %sub1682, %cond.true.1659 ], [ %add1690, %cond.false.1683 ]
  %div1693 = sdiv i32 %cond1692, 8
  %338 = load i64, i64* %fun, align 8
  %call1694 = call %struct.Lisp_Subr* @XSUBR(i64 %338)
  %max_args1695 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1694, i32 0, i32 3
  %339 = load i16, i16* %max_args1695, align 2
  %conv1696 = sext i16 %339 to i32
  %add1697 = add nsw i32 1, %conv1696
  %cmp1698 = icmp slt i32 %div1693, %add1697
  br i1 %cmp1698, label %cond.true.1825, label %lor.lhs.false.1799

cond.false.1700:                                  ; preds = %lor.lhs.false.1600
  br i1 false, label %cond.true.1701, label %cond.false.1702

cond.true.1701:                                   ; preds = %cond.false.1700
  br i1 false, label %cond.true.1825, label %lor.lhs.false.1799

cond.false.1702:                                  ; preds = %cond.false.1700
  %340 = load i64, i64* %fun, align 8
  %call1703 = call %struct.Lisp_Subr* @XSUBR(i64 %340)
  %max_args1704 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1703, i32 0, i32 3
  %341 = load i16, i16* %max_args1704, align 2
  %conv1705 = sext i16 %341 to i32
  %add1706 = add nsw i32 1, %conv1705
  %cmp1707 = icmp slt i32 %add1706, 0
  br i1 %cmp1707, label %cond.true.1709, label %cond.false.1760

cond.true.1709:                                   ; preds = %cond.false.1702
  %342 = load i64, i64* %fun, align 8
  %call1710 = call %struct.Lisp_Subr* @XSUBR(i64 %342)
  %max_args1711 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1710, i32 0, i32 3
  %343 = load i16, i16* %max_args1711, align 2
  %conv1712 = sext i16 %343 to i32
  %add1713 = add nsw i32 1, %conv1712
  %344 = load i64, i64* %fun, align 8
  %call1714 = call %struct.Lisp_Subr* @XSUBR(i64 %344)
  %max_args1715 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1714, i32 0, i32 3
  %345 = load i16, i16* %max_args1715, align 2
  %conv1716 = sext i16 %345 to i32
  %add1717 = add nsw i32 1, %conv1716
  %add1718 = add nsw i32 0, %add1717
  %mul1719 = mul nsw i32 0, %add1718
  %sub1720 = sub nsw i32 %mul1719, 1
  %cmp1721 = icmp slt i32 %sub1720, 0
  br i1 %cmp1721, label %cond.true.1723, label %cond.false.1747

cond.true.1723:                                   ; preds = %cond.true.1709
  %346 = load i64, i64* %fun, align 8
  %call1724 = call %struct.Lisp_Subr* @XSUBR(i64 %346)
  %max_args1725 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1724, i32 0, i32 3
  %347 = load i16, i16* %max_args1725, align 2
  %conv1726 = sext i16 %347 to i32
  %add1727 = add nsw i32 1, %conv1726
  %add1728 = add nsw i32 0, %add1727
  %mul1729 = mul nsw i32 0, %add1728
  %add1730 = add nsw i32 %mul1729, 0
  %neg1731 = xor i32 %add1730, -1
  %cmp1732 = icmp eq i32 %neg1731, -1
  %conv1733 = zext i1 %cmp1732 to i32
  %sub1734 = sub nsw i32 0, %conv1733
  %348 = load i64, i64* %fun, align 8
  %call1735 = call %struct.Lisp_Subr* @XSUBR(i64 %348)
  %max_args1736 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1735, i32 0, i32 3
  %349 = load i16, i16* %max_args1736, align 2
  %conv1737 = sext i16 %349 to i32
  %add1738 = add nsw i32 1, %conv1737
  %add1739 = add nsw i32 0, %add1738
  %mul1740 = mul nsw i32 0, %add1739
  %add1741 = add nsw i32 %mul1740, 1
  %shl1742 = shl i32 %add1741, 30
  %sub1743 = sub nsw i32 %shl1742, 1
  %mul1744 = mul nsw i32 %sub1743, 2
  %add1745 = add nsw i32 %mul1744, 1
  %sub1746 = sub nsw i32 %sub1734, %add1745
  br label %cond.end.1755

cond.false.1747:                                  ; preds = %cond.true.1709
  %350 = load i64, i64* %fun, align 8
  %call1748 = call %struct.Lisp_Subr* @XSUBR(i64 %350)
  %max_args1749 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1748, i32 0, i32 3
  %351 = load i16, i16* %max_args1749, align 2
  %conv1750 = sext i16 %351 to i32
  %add1751 = add nsw i32 1, %conv1750
  %add1752 = add nsw i32 0, %add1751
  %mul1753 = mul nsw i32 0, %add1752
  %add1754 = add nsw i32 %mul1753, 0
  br label %cond.end.1755

cond.end.1755:                                    ; preds = %cond.false.1747, %cond.true.1723
  %cond1756 = phi i32 [ %sub1746, %cond.true.1723 ], [ %add1754, %cond.false.1747 ]
  %div1757 = sdiv i32 %cond1756, 8
  %cmp1758 = icmp slt i32 %add1713, %div1757
  br i1 %cmp1758, label %cond.true.1825, label %lor.lhs.false.1799

cond.false.1760:                                  ; preds = %cond.false.1702
  %352 = load i64, i64* %fun, align 8
  %call1761 = call %struct.Lisp_Subr* @XSUBR(i64 %352)
  %max_args1762 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1761, i32 0, i32 3
  %353 = load i16, i16* %max_args1762, align 2
  %conv1763 = sext i16 %353 to i32
  %add1764 = add nsw i32 1, %conv1763
  %add1765 = add nsw i32 0, %add1764
  %mul1766 = mul nsw i32 0, %add1765
  %sub1767 = sub nsw i32 %mul1766, 1
  %cmp1768 = icmp slt i32 %sub1767, 0
  br i1 %cmp1768, label %cond.true.1770, label %cond.false.1782

cond.true.1770:                                   ; preds = %cond.false.1760
  %354 = load i64, i64* %fun, align 8
  %call1771 = call %struct.Lisp_Subr* @XSUBR(i64 %354)
  %max_args1772 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1771, i32 0, i32 3
  %355 = load i16, i16* %max_args1772, align 2
  %conv1773 = sext i16 %355 to i32
  %add1774 = add nsw i32 1, %conv1773
  %add1775 = add nsw i32 0, %add1774
  %mul1776 = mul nsw i32 0, %add1775
  %add1777 = add nsw i32 %mul1776, 1
  %shl1778 = shl i32 %add1777, 30
  %sub1779 = sub nsw i32 %shl1778, 1
  %mul1780 = mul nsw i32 %sub1779, 2
  %add1781 = add nsw i32 %mul1780, 1
  br label %cond.end.1790

cond.false.1782:                                  ; preds = %cond.false.1760
  %356 = load i64, i64* %fun, align 8
  %call1783 = call %struct.Lisp_Subr* @XSUBR(i64 %356)
  %max_args1784 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1783, i32 0, i32 3
  %357 = load i16, i16* %max_args1784, align 2
  %conv1785 = sext i16 %357 to i32
  %add1786 = add nsw i32 1, %conv1785
  %add1787 = add nsw i32 0, %add1786
  %mul1788 = mul nsw i32 0, %add1787
  %sub1789 = sub nsw i32 %mul1788, 1
  br label %cond.end.1790

cond.end.1790:                                    ; preds = %cond.false.1782, %cond.true.1770
  %cond1791 = phi i32 [ %add1781, %cond.true.1770 ], [ %sub1789, %cond.false.1782 ]
  %div1792 = sdiv i32 %cond1791, 8
  %358 = load i64, i64* %fun, align 8
  %call1793 = call %struct.Lisp_Subr* @XSUBR(i64 %358)
  %max_args1794 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1793, i32 0, i32 3
  %359 = load i16, i16* %max_args1794, align 2
  %conv1795 = sext i16 %359 to i32
  %add1796 = add nsw i32 1, %conv1795
  %cmp1797 = icmp slt i32 %div1792, %add1796
  br i1 %cmp1797, label %cond.true.1825, label %lor.lhs.false.1799

lor.lhs.false.1799:                               ; preds = %cond.end.1790, %cond.end.1755, %cond.true.1701, %cond.end.1691, %cond.true.1648, %cond.end.1642
  %360 = load i64, i64* %fun, align 8
  %call1800 = call %struct.Lisp_Subr* @XSUBR(i64 %360)
  %max_args1801 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1800, i32 0, i32 3
  %361 = load i16, i16* %max_args1801, align 2
  %conv1802 = sext i16 %361 to i32
  %add1803 = add nsw i32 1, %conv1802
  %mul1804 = mul nsw i32 %add1803, 8
  %mul1805 = mul nsw i32 0, %mul1804
  %sub1806 = sub nsw i32 %mul1805, 1
  %cmp1807 = icmp slt i32 %sub1806, 0
  br i1 %cmp1807, label %land.lhs.true.1809, label %lor.lhs.false.1817

land.lhs.true.1809:                               ; preds = %lor.lhs.false.1799
  %362 = load i64, i64* %fun, align 8
  %call1810 = call %struct.Lisp_Subr* @XSUBR(i64 %362)
  %max_args1811 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1810, i32 0, i32 3
  %363 = load i16, i16* %max_args1811, align 2
  %conv1812 = sext i16 %363 to i32
  %add1813 = add nsw i32 1, %conv1812
  %mul1814 = mul nsw i32 %add1813, 8
  %cmp1815 = icmp slt i32 %mul1814, -2147483648
  br i1 %cmp1815, label %cond.true.1825, label %lor.lhs.false.1817

lor.lhs.false.1817:                               ; preds = %land.lhs.true.1809, %lor.lhs.false.1799
  %364 = load i64, i64* %fun, align 8
  %call1818 = call %struct.Lisp_Subr* @XSUBR(i64 %364)
  %max_args1819 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1818, i32 0, i32 3
  %365 = load i16, i16* %max_args1819, align 2
  %conv1820 = sext i16 %365 to i32
  %add1821 = add nsw i32 1, %conv1820
  %mul1822 = mul nsw i32 %add1821, 8
  %cmp1823 = icmp slt i32 2147483647, %mul1822
  br i1 %cmp1823, label %cond.true.1825, label %cond.false.1850

cond.true.1825:                                   ; preds = %lor.lhs.false.1817, %land.lhs.true.1809, %cond.end.1790, %cond.end.1755, %cond.true.1701, %cond.end.1691, %cond.true.1648, %cond.end.1642, %land.lhs.true.1593
  %366 = load i64, i64* %fun, align 8
  %call1826 = call %struct.Lisp_Subr* @XSUBR(i64 %366)
  %max_args1827 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1826, i32 0, i32 3
  %367 = load i16, i16* %max_args1827, align 2
  %conv1828 = sext i16 %367 to i32
  %add1829 = add nsw i32 1, %conv1828
  %mul1830 = mul i32 %add1829, 8
  %cmp1831 = icmp ule i32 %mul1830, 2147483647
  br i1 %cmp1831, label %cond.true.1833, label %cond.false.1839

cond.true.1833:                                   ; preds = %cond.true.1825
  %368 = load i64, i64* %fun, align 8
  %call1834 = call %struct.Lisp_Subr* @XSUBR(i64 %368)
  %max_args1835 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1834, i32 0, i32 3
  %369 = load i16, i16* %max_args1835, align 2
  %conv1836 = sext i16 %369 to i32
  %add1837 = add nsw i32 1, %conv1836
  %mul1838 = mul i32 %add1837, 8
  br label %cond.end.1847

cond.false.1839:                                  ; preds = %cond.true.1825
  %370 = load i64, i64* %fun, align 8
  %call1840 = call %struct.Lisp_Subr* @XSUBR(i64 %370)
  %max_args1841 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1840, i32 0, i32 3
  %371 = load i16, i16* %max_args1841, align 2
  %conv1842 = sext i16 %371 to i32
  %add1843 = add nsw i32 1, %conv1842
  %mul1844 = mul i32 %add1843, 8
  %sub1845 = sub i32 %mul1844, -2147483648
  %add1846 = add nsw i32 %sub1845, -2147483648
  br label %cond.end.1847

cond.end.1847:                                    ; preds = %cond.false.1839, %cond.true.1833
  %cond1848 = phi i32 [ %mul1838, %cond.true.1833 ], [ %add1846, %cond.false.1839 ]
  %conv1849 = sext i32 %cond1848 to i64
  store i64 %conv1849, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.3603, label %lor.lhs.false.3600

cond.false.1850:                                  ; preds = %lor.lhs.false.1817
  %372 = load i64, i64* %fun, align 8
  %call1851 = call %struct.Lisp_Subr* @XSUBR(i64 %372)
  %max_args1852 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1851, i32 0, i32 3
  %373 = load i16, i16* %max_args1852, align 2
  %conv1853 = sext i16 %373 to i32
  %add1854 = add nsw i32 1, %conv1853
  %mul1855 = mul i32 %add1854, 8
  %cmp1856 = icmp ule i32 %mul1855, 2147483647
  br i1 %cmp1856, label %cond.true.1858, label %cond.false.1864

cond.true.1858:                                   ; preds = %cond.false.1850
  %374 = load i64, i64* %fun, align 8
  %call1859 = call %struct.Lisp_Subr* @XSUBR(i64 %374)
  %max_args1860 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1859, i32 0, i32 3
  %375 = load i16, i16* %max_args1860, align 2
  %conv1861 = sext i16 %375 to i32
  %add1862 = add nsw i32 1, %conv1861
  %mul1863 = mul i32 %add1862, 8
  br label %cond.end.1872

cond.false.1864:                                  ; preds = %cond.false.1850
  %376 = load i64, i64* %fun, align 8
  %call1865 = call %struct.Lisp_Subr* @XSUBR(i64 %376)
  %max_args1866 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1865, i32 0, i32 3
  %377 = load i16, i16* %max_args1866, align 2
  %conv1867 = sext i16 %377 to i32
  %add1868 = add nsw i32 1, %conv1867
  %mul1869 = mul i32 %add1868, 8
  %sub1870 = sub i32 %mul1869, -2147483648
  %add1871 = add nsw i32 %sub1870, -2147483648
  br label %cond.end.1872

cond.end.1872:                                    ; preds = %cond.false.1864, %cond.true.1858
  %cond1873 = phi i32 [ %mul1863, %cond.true.1858 ], [ %add1871, %cond.false.1864 ]
  %conv1874 = sext i32 %cond1873 to i64
  store i64 %conv1874, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.3603, label %lor.lhs.false.3600

cond.false.1875:                                  ; preds = %cond.true.1546
  %378 = load i64, i64* %fun, align 8
  %call1876 = call %struct.Lisp_Subr* @XSUBR(i64 %378)
  %max_args1877 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1876, i32 0, i32 3
  %379 = load i16, i16* %max_args1877, align 2
  %conv1878 = sext i16 %379 to i32
  %add1879 = add nsw i32 1, %conv1878
  %add1880 = add nsw i32 0, %add1879
  %mul1881 = mul nsw i32 0, %add1880
  %sub1882 = sub nsw i32 %mul1881, 1
  %cmp1883 = icmp slt i32 %sub1882, 0
  br i1 %cmp1883, label %cond.true.1885, label %cond.false.1909

cond.true.1885:                                   ; preds = %cond.false.1875
  %380 = load i64, i64* %fun, align 8
  %call1886 = call %struct.Lisp_Subr* @XSUBR(i64 %380)
  %max_args1887 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1886, i32 0, i32 3
  %381 = load i16, i16* %max_args1887, align 2
  %conv1888 = sext i16 %381 to i32
  %add1889 = add nsw i32 1, %conv1888
  %add1890 = add nsw i32 0, %add1889
  %mul1891 = mul nsw i32 0, %add1890
  %add1892 = add nsw i32 %mul1891, 0
  %neg1893 = xor i32 %add1892, -1
  %cmp1894 = icmp eq i32 %neg1893, -1
  %conv1895 = zext i1 %cmp1894 to i32
  %sub1896 = sub nsw i32 0, %conv1895
  %382 = load i64, i64* %fun, align 8
  %call1897 = call %struct.Lisp_Subr* @XSUBR(i64 %382)
  %max_args1898 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1897, i32 0, i32 3
  %383 = load i16, i16* %max_args1898, align 2
  %conv1899 = sext i16 %383 to i32
  %add1900 = add nsw i32 1, %conv1899
  %add1901 = add nsw i32 0, %add1900
  %mul1902 = mul nsw i32 0, %add1901
  %add1903 = add nsw i32 %mul1902, 1
  %shl1904 = shl i32 %add1903, 30
  %sub1905 = sub nsw i32 %shl1904, 1
  %mul1906 = mul nsw i32 %sub1905, 2
  %add1907 = add nsw i32 %mul1906, 1
  %sub1908 = sub nsw i32 %sub1896, %add1907
  br label %cond.end.1917

cond.false.1909:                                  ; preds = %cond.false.1875
  %384 = load i64, i64* %fun, align 8
  %call1910 = call %struct.Lisp_Subr* @XSUBR(i64 %384)
  %max_args1911 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1910, i32 0, i32 3
  %385 = load i16, i16* %max_args1911, align 2
  %conv1912 = sext i16 %385 to i32
  %add1913 = add nsw i32 1, %conv1912
  %add1914 = add nsw i32 0, %add1913
  %mul1915 = mul nsw i32 0, %add1914
  %add1916 = add nsw i32 %mul1915, 0
  br label %cond.end.1917

cond.end.1917:                                    ; preds = %cond.false.1909, %cond.true.1885
  %cond1918 = phi i32 [ %sub1908, %cond.true.1885 ], [ %add1916, %cond.false.1909 ]
  %cmp1919 = icmp eq i32 %cond1918, 0
  br i1 %cmp1919, label %land.lhs.true.1921, label %lor.lhs.false.1928

land.lhs.true.1921:                               ; preds = %cond.end.1917
  %386 = load i64, i64* %fun, align 8
  %call1922 = call %struct.Lisp_Subr* @XSUBR(i64 %386)
  %max_args1923 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1922, i32 0, i32 3
  %387 = load i16, i16* %max_args1923, align 2
  %conv1924 = sext i16 %387 to i32
  %add1925 = add nsw i32 1, %conv1924
  %cmp1926 = icmp slt i32 %add1925, 0
  br i1 %cmp1926, label %cond.true.2153, label %lor.lhs.false.1928

lor.lhs.false.1928:                               ; preds = %land.lhs.true.1921, %cond.end.1917
  br i1 false, label %cond.true.1929, label %cond.false.2028

cond.true.1929:                                   ; preds = %lor.lhs.false.1928
  %388 = load i64, i64* %fun, align 8
  %call1930 = call %struct.Lisp_Subr* @XSUBR(i64 %388)
  %max_args1931 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1930, i32 0, i32 3
  %389 = load i16, i16* %max_args1931, align 2
  %conv1932 = sext i16 %389 to i32
  %add1933 = add nsw i32 1, %conv1932
  %cmp1934 = icmp slt i32 %add1933, 0
  br i1 %cmp1934, label %cond.true.1936, label %cond.false.1975

cond.true.1936:                                   ; preds = %cond.true.1929
  %390 = load i64, i64* %fun, align 8
  %call1937 = call %struct.Lisp_Subr* @XSUBR(i64 %390)
  %max_args1938 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1937, i32 0, i32 3
  %391 = load i16, i16* %max_args1938, align 2
  %conv1939 = sext i16 %391 to i32
  %add1940 = add nsw i32 1, %conv1939
  %392 = load i64, i64* %fun, align 8
  %call1941 = call %struct.Lisp_Subr* @XSUBR(i64 %392)
  %max_args1942 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1941, i32 0, i32 3
  %393 = load i16, i16* %max_args1942, align 2
  %conv1943 = sext i16 %393 to i32
  %add1944 = add nsw i32 1, %conv1943
  %add1945 = add nsw i32 0, %add1944
  %mul1946 = mul nsw i32 0, %add1945
  %sub1947 = sub nsw i32 %mul1946, 1
  %cmp1948 = icmp slt i32 %sub1947, 0
  br i1 %cmp1948, label %cond.true.1950, label %cond.false.1962

cond.true.1950:                                   ; preds = %cond.true.1936
  %394 = load i64, i64* %fun, align 8
  %call1951 = call %struct.Lisp_Subr* @XSUBR(i64 %394)
  %max_args1952 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1951, i32 0, i32 3
  %395 = load i16, i16* %max_args1952, align 2
  %conv1953 = sext i16 %395 to i32
  %add1954 = add nsw i32 1, %conv1953
  %add1955 = add nsw i32 0, %add1954
  %mul1956 = mul nsw i32 0, %add1955
  %add1957 = add nsw i32 %mul1956, 1
  %shl1958 = shl i32 %add1957, 30
  %sub1959 = sub nsw i32 %shl1958, 1
  %mul1960 = mul nsw i32 %sub1959, 2
  %add1961 = add nsw i32 %mul1960, 1
  br label %cond.end.1970

cond.false.1962:                                  ; preds = %cond.true.1936
  %396 = load i64, i64* %fun, align 8
  %call1963 = call %struct.Lisp_Subr* @XSUBR(i64 %396)
  %max_args1964 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1963, i32 0, i32 3
  %397 = load i16, i16* %max_args1964, align 2
  %conv1965 = sext i16 %397 to i32
  %add1966 = add nsw i32 1, %conv1965
  %add1967 = add nsw i32 0, %add1966
  %mul1968 = mul nsw i32 0, %add1967
  %sub1969 = sub nsw i32 %mul1968, 1
  br label %cond.end.1970

cond.end.1970:                                    ; preds = %cond.false.1962, %cond.true.1950
  %cond1971 = phi i32 [ %add1961, %cond.true.1950 ], [ %sub1969, %cond.false.1962 ]
  %div1972 = sdiv i32 %cond1971, 8
  %cmp1973 = icmp slt i32 %add1940, %div1972
  br i1 %cmp1973, label %cond.true.2153, label %lor.lhs.false.2127

cond.false.1975:                                  ; preds = %cond.true.1929
  br i1 false, label %cond.true.1976, label %cond.false.1977

cond.true.1976:                                   ; preds = %cond.false.1975
  br i1 false, label %cond.true.2153, label %lor.lhs.false.2127

cond.false.1977:                                  ; preds = %cond.false.1975
  %398 = load i64, i64* %fun, align 8
  %call1978 = call %struct.Lisp_Subr* @XSUBR(i64 %398)
  %max_args1979 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1978, i32 0, i32 3
  %399 = load i16, i16* %max_args1979, align 2
  %conv1980 = sext i16 %399 to i32
  %add1981 = add nsw i32 1, %conv1980
  %add1982 = add nsw i32 0, %add1981
  %mul1983 = mul nsw i32 0, %add1982
  %sub1984 = sub nsw i32 %mul1983, 1
  %cmp1985 = icmp slt i32 %sub1984, 0
  br i1 %cmp1985, label %cond.true.1987, label %cond.false.2011

cond.true.1987:                                   ; preds = %cond.false.1977
  %400 = load i64, i64* %fun, align 8
  %call1988 = call %struct.Lisp_Subr* @XSUBR(i64 %400)
  %max_args1989 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1988, i32 0, i32 3
  %401 = load i16, i16* %max_args1989, align 2
  %conv1990 = sext i16 %401 to i32
  %add1991 = add nsw i32 1, %conv1990
  %add1992 = add nsw i32 0, %add1991
  %mul1993 = mul nsw i32 0, %add1992
  %add1994 = add nsw i32 %mul1993, 0
  %neg1995 = xor i32 %add1994, -1
  %cmp1996 = icmp eq i32 %neg1995, -1
  %conv1997 = zext i1 %cmp1996 to i32
  %sub1998 = sub nsw i32 0, %conv1997
  %402 = load i64, i64* %fun, align 8
  %call1999 = call %struct.Lisp_Subr* @XSUBR(i64 %402)
  %max_args2000 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call1999, i32 0, i32 3
  %403 = load i16, i16* %max_args2000, align 2
  %conv2001 = sext i16 %403 to i32
  %add2002 = add nsw i32 1, %conv2001
  %add2003 = add nsw i32 0, %add2002
  %mul2004 = mul nsw i32 0, %add2003
  %add2005 = add nsw i32 %mul2004, 1
  %shl2006 = shl i32 %add2005, 30
  %sub2007 = sub nsw i32 %shl2006, 1
  %mul2008 = mul nsw i32 %sub2007, 2
  %add2009 = add nsw i32 %mul2008, 1
  %sub2010 = sub nsw i32 %sub1998, %add2009
  br label %cond.end.2019

cond.false.2011:                                  ; preds = %cond.false.1977
  %404 = load i64, i64* %fun, align 8
  %call2012 = call %struct.Lisp_Subr* @XSUBR(i64 %404)
  %max_args2013 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2012, i32 0, i32 3
  %405 = load i16, i16* %max_args2013, align 2
  %conv2014 = sext i16 %405 to i32
  %add2015 = add nsw i32 1, %conv2014
  %add2016 = add nsw i32 0, %add2015
  %mul2017 = mul nsw i32 0, %add2016
  %add2018 = add nsw i32 %mul2017, 0
  br label %cond.end.2019

cond.end.2019:                                    ; preds = %cond.false.2011, %cond.true.1987
  %cond2020 = phi i32 [ %sub2010, %cond.true.1987 ], [ %add2018, %cond.false.2011 ]
  %div2021 = sdiv i32 %cond2020, 8
  %406 = load i64, i64* %fun, align 8
  %call2022 = call %struct.Lisp_Subr* @XSUBR(i64 %406)
  %max_args2023 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2022, i32 0, i32 3
  %407 = load i16, i16* %max_args2023, align 2
  %conv2024 = sext i16 %407 to i32
  %add2025 = add nsw i32 1, %conv2024
  %cmp2026 = icmp slt i32 %div2021, %add2025
  br i1 %cmp2026, label %cond.true.2153, label %lor.lhs.false.2127

cond.false.2028:                                  ; preds = %lor.lhs.false.1928
  br i1 false, label %cond.true.2029, label %cond.false.2030

cond.true.2029:                                   ; preds = %cond.false.2028
  br i1 false, label %cond.true.2153, label %lor.lhs.false.2127

cond.false.2030:                                  ; preds = %cond.false.2028
  %408 = load i64, i64* %fun, align 8
  %call2031 = call %struct.Lisp_Subr* @XSUBR(i64 %408)
  %max_args2032 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2031, i32 0, i32 3
  %409 = load i16, i16* %max_args2032, align 2
  %conv2033 = sext i16 %409 to i32
  %add2034 = add nsw i32 1, %conv2033
  %cmp2035 = icmp slt i32 %add2034, 0
  br i1 %cmp2035, label %cond.true.2037, label %cond.false.2088

cond.true.2037:                                   ; preds = %cond.false.2030
  %410 = load i64, i64* %fun, align 8
  %call2038 = call %struct.Lisp_Subr* @XSUBR(i64 %410)
  %max_args2039 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2038, i32 0, i32 3
  %411 = load i16, i16* %max_args2039, align 2
  %conv2040 = sext i16 %411 to i32
  %add2041 = add nsw i32 1, %conv2040
  %412 = load i64, i64* %fun, align 8
  %call2042 = call %struct.Lisp_Subr* @XSUBR(i64 %412)
  %max_args2043 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2042, i32 0, i32 3
  %413 = load i16, i16* %max_args2043, align 2
  %conv2044 = sext i16 %413 to i32
  %add2045 = add nsw i32 1, %conv2044
  %add2046 = add nsw i32 0, %add2045
  %mul2047 = mul nsw i32 0, %add2046
  %sub2048 = sub nsw i32 %mul2047, 1
  %cmp2049 = icmp slt i32 %sub2048, 0
  br i1 %cmp2049, label %cond.true.2051, label %cond.false.2075

cond.true.2051:                                   ; preds = %cond.true.2037
  %414 = load i64, i64* %fun, align 8
  %call2052 = call %struct.Lisp_Subr* @XSUBR(i64 %414)
  %max_args2053 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2052, i32 0, i32 3
  %415 = load i16, i16* %max_args2053, align 2
  %conv2054 = sext i16 %415 to i32
  %add2055 = add nsw i32 1, %conv2054
  %add2056 = add nsw i32 0, %add2055
  %mul2057 = mul nsw i32 0, %add2056
  %add2058 = add nsw i32 %mul2057, 0
  %neg2059 = xor i32 %add2058, -1
  %cmp2060 = icmp eq i32 %neg2059, -1
  %conv2061 = zext i1 %cmp2060 to i32
  %sub2062 = sub nsw i32 0, %conv2061
  %416 = load i64, i64* %fun, align 8
  %call2063 = call %struct.Lisp_Subr* @XSUBR(i64 %416)
  %max_args2064 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2063, i32 0, i32 3
  %417 = load i16, i16* %max_args2064, align 2
  %conv2065 = sext i16 %417 to i32
  %add2066 = add nsw i32 1, %conv2065
  %add2067 = add nsw i32 0, %add2066
  %mul2068 = mul nsw i32 0, %add2067
  %add2069 = add nsw i32 %mul2068, 1
  %shl2070 = shl i32 %add2069, 30
  %sub2071 = sub nsw i32 %shl2070, 1
  %mul2072 = mul nsw i32 %sub2071, 2
  %add2073 = add nsw i32 %mul2072, 1
  %sub2074 = sub nsw i32 %sub2062, %add2073
  br label %cond.end.2083

cond.false.2075:                                  ; preds = %cond.true.2037
  %418 = load i64, i64* %fun, align 8
  %call2076 = call %struct.Lisp_Subr* @XSUBR(i64 %418)
  %max_args2077 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2076, i32 0, i32 3
  %419 = load i16, i16* %max_args2077, align 2
  %conv2078 = sext i16 %419 to i32
  %add2079 = add nsw i32 1, %conv2078
  %add2080 = add nsw i32 0, %add2079
  %mul2081 = mul nsw i32 0, %add2080
  %add2082 = add nsw i32 %mul2081, 0
  br label %cond.end.2083

cond.end.2083:                                    ; preds = %cond.false.2075, %cond.true.2051
  %cond2084 = phi i32 [ %sub2074, %cond.true.2051 ], [ %add2082, %cond.false.2075 ]
  %div2085 = sdiv i32 %cond2084, 8
  %cmp2086 = icmp slt i32 %add2041, %div2085
  br i1 %cmp2086, label %cond.true.2153, label %lor.lhs.false.2127

cond.false.2088:                                  ; preds = %cond.false.2030
  %420 = load i64, i64* %fun, align 8
  %call2089 = call %struct.Lisp_Subr* @XSUBR(i64 %420)
  %max_args2090 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2089, i32 0, i32 3
  %421 = load i16, i16* %max_args2090, align 2
  %conv2091 = sext i16 %421 to i32
  %add2092 = add nsw i32 1, %conv2091
  %add2093 = add nsw i32 0, %add2092
  %mul2094 = mul nsw i32 0, %add2093
  %sub2095 = sub nsw i32 %mul2094, 1
  %cmp2096 = icmp slt i32 %sub2095, 0
  br i1 %cmp2096, label %cond.true.2098, label %cond.false.2110

cond.true.2098:                                   ; preds = %cond.false.2088
  %422 = load i64, i64* %fun, align 8
  %call2099 = call %struct.Lisp_Subr* @XSUBR(i64 %422)
  %max_args2100 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2099, i32 0, i32 3
  %423 = load i16, i16* %max_args2100, align 2
  %conv2101 = sext i16 %423 to i32
  %add2102 = add nsw i32 1, %conv2101
  %add2103 = add nsw i32 0, %add2102
  %mul2104 = mul nsw i32 0, %add2103
  %add2105 = add nsw i32 %mul2104, 1
  %shl2106 = shl i32 %add2105, 30
  %sub2107 = sub nsw i32 %shl2106, 1
  %mul2108 = mul nsw i32 %sub2107, 2
  %add2109 = add nsw i32 %mul2108, 1
  br label %cond.end.2118

cond.false.2110:                                  ; preds = %cond.false.2088
  %424 = load i64, i64* %fun, align 8
  %call2111 = call %struct.Lisp_Subr* @XSUBR(i64 %424)
  %max_args2112 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2111, i32 0, i32 3
  %425 = load i16, i16* %max_args2112, align 2
  %conv2113 = sext i16 %425 to i32
  %add2114 = add nsw i32 1, %conv2113
  %add2115 = add nsw i32 0, %add2114
  %mul2116 = mul nsw i32 0, %add2115
  %sub2117 = sub nsw i32 %mul2116, 1
  br label %cond.end.2118

cond.end.2118:                                    ; preds = %cond.false.2110, %cond.true.2098
  %cond2119 = phi i32 [ %add2109, %cond.true.2098 ], [ %sub2117, %cond.false.2110 ]
  %div2120 = sdiv i32 %cond2119, 8
  %426 = load i64, i64* %fun, align 8
  %call2121 = call %struct.Lisp_Subr* @XSUBR(i64 %426)
  %max_args2122 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2121, i32 0, i32 3
  %427 = load i16, i16* %max_args2122, align 2
  %conv2123 = sext i16 %427 to i32
  %add2124 = add nsw i32 1, %conv2123
  %cmp2125 = icmp slt i32 %div2120, %add2124
  br i1 %cmp2125, label %cond.true.2153, label %lor.lhs.false.2127

lor.lhs.false.2127:                               ; preds = %cond.end.2118, %cond.end.2083, %cond.true.2029, %cond.end.2019, %cond.true.1976, %cond.end.1970
  %428 = load i64, i64* %fun, align 8
  %call2128 = call %struct.Lisp_Subr* @XSUBR(i64 %428)
  %max_args2129 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2128, i32 0, i32 3
  %429 = load i16, i16* %max_args2129, align 2
  %conv2130 = sext i16 %429 to i32
  %add2131 = add nsw i32 1, %conv2130
  %mul2132 = mul nsw i32 %add2131, 8
  %mul2133 = mul nsw i32 0, %mul2132
  %sub2134 = sub nsw i32 %mul2133, 1
  %cmp2135 = icmp slt i32 %sub2134, 0
  br i1 %cmp2135, label %land.lhs.true.2137, label %lor.lhs.false.2145

land.lhs.true.2137:                               ; preds = %lor.lhs.false.2127
  %430 = load i64, i64* %fun, align 8
  %call2138 = call %struct.Lisp_Subr* @XSUBR(i64 %430)
  %max_args2139 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2138, i32 0, i32 3
  %431 = load i16, i16* %max_args2139, align 2
  %conv2140 = sext i16 %431 to i32
  %add2141 = add nsw i32 1, %conv2140
  %mul2142 = mul nsw i32 %add2141, 8
  %cmp2143 = icmp slt i32 %mul2142, -2147483648
  br i1 %cmp2143, label %cond.true.2153, label %lor.lhs.false.2145

lor.lhs.false.2145:                               ; preds = %land.lhs.true.2137, %lor.lhs.false.2127
  %432 = load i64, i64* %fun, align 8
  %call2146 = call %struct.Lisp_Subr* @XSUBR(i64 %432)
  %max_args2147 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2146, i32 0, i32 3
  %433 = load i16, i16* %max_args2147, align 2
  %conv2148 = sext i16 %433 to i32
  %add2149 = add nsw i32 1, %conv2148
  %mul2150 = mul nsw i32 %add2149, 8
  %cmp2151 = icmp slt i32 2147483647, %mul2150
  br i1 %cmp2151, label %cond.true.2153, label %cond.false.2178

cond.true.2153:                                   ; preds = %lor.lhs.false.2145, %land.lhs.true.2137, %cond.end.2118, %cond.end.2083, %cond.true.2029, %cond.end.2019, %cond.true.1976, %cond.end.1970, %land.lhs.true.1921
  %434 = load i64, i64* %fun, align 8
  %call2154 = call %struct.Lisp_Subr* @XSUBR(i64 %434)
  %max_args2155 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2154, i32 0, i32 3
  %435 = load i16, i16* %max_args2155, align 2
  %conv2156 = sext i16 %435 to i32
  %add2157 = add nsw i32 1, %conv2156
  %mul2158 = mul i32 %add2157, 8
  %cmp2159 = icmp ule i32 %mul2158, 2147483647
  br i1 %cmp2159, label %cond.true.2161, label %cond.false.2167

cond.true.2161:                                   ; preds = %cond.true.2153
  %436 = load i64, i64* %fun, align 8
  %call2162 = call %struct.Lisp_Subr* @XSUBR(i64 %436)
  %max_args2163 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2162, i32 0, i32 3
  %437 = load i16, i16* %max_args2163, align 2
  %conv2164 = sext i16 %437 to i32
  %add2165 = add nsw i32 1, %conv2164
  %mul2166 = mul i32 %add2165, 8
  br label %cond.end.2175

cond.false.2167:                                  ; preds = %cond.true.2153
  %438 = load i64, i64* %fun, align 8
  %call2168 = call %struct.Lisp_Subr* @XSUBR(i64 %438)
  %max_args2169 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2168, i32 0, i32 3
  %439 = load i16, i16* %max_args2169, align 2
  %conv2170 = sext i16 %439 to i32
  %add2171 = add nsw i32 1, %conv2170
  %mul2172 = mul i32 %add2171, 8
  %sub2173 = sub i32 %mul2172, -2147483648
  %add2174 = add nsw i32 %sub2173, -2147483648
  br label %cond.end.2175

cond.end.2175:                                    ; preds = %cond.false.2167, %cond.true.2161
  %cond2176 = phi i32 [ %mul2166, %cond.true.2161 ], [ %add2174, %cond.false.2167 ]
  %conv2177 = sext i32 %cond2176 to i64
  store i64 %conv2177, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.3603, label %lor.lhs.false.3600

cond.false.2178:                                  ; preds = %lor.lhs.false.2145
  %440 = load i64, i64* %fun, align 8
  %call2179 = call %struct.Lisp_Subr* @XSUBR(i64 %440)
  %max_args2180 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2179, i32 0, i32 3
  %441 = load i16, i16* %max_args2180, align 2
  %conv2181 = sext i16 %441 to i32
  %add2182 = add nsw i32 1, %conv2181
  %mul2183 = mul i32 %add2182, 8
  %cmp2184 = icmp ule i32 %mul2183, 2147483647
  br i1 %cmp2184, label %cond.true.2186, label %cond.false.2192

cond.true.2186:                                   ; preds = %cond.false.2178
  %442 = load i64, i64* %fun, align 8
  %call2187 = call %struct.Lisp_Subr* @XSUBR(i64 %442)
  %max_args2188 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2187, i32 0, i32 3
  %443 = load i16, i16* %max_args2188, align 2
  %conv2189 = sext i16 %443 to i32
  %add2190 = add nsw i32 1, %conv2189
  %mul2191 = mul i32 %add2190, 8
  br label %cond.end.2200

cond.false.2192:                                  ; preds = %cond.false.2178
  %444 = load i64, i64* %fun, align 8
  %call2193 = call %struct.Lisp_Subr* @XSUBR(i64 %444)
  %max_args2194 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2193, i32 0, i32 3
  %445 = load i16, i16* %max_args2194, align 2
  %conv2195 = sext i16 %445 to i32
  %add2196 = add nsw i32 1, %conv2195
  %mul2197 = mul i32 %add2196, 8
  %sub2198 = sub i32 %mul2197, -2147483648
  %add2199 = add nsw i32 %sub2198, -2147483648
  br label %cond.end.2200

cond.end.2200:                                    ; preds = %cond.false.2192, %cond.true.2186
  %cond2201 = phi i32 [ %mul2191, %cond.true.2186 ], [ %add2199, %cond.false.2192 ]
  %conv2202 = sext i32 %cond2201 to i64
  store i64 %conv2202, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.3603, label %lor.lhs.false.3600

cond.false.2203:                                  ; preds = %cond.false.1545
  br i1 true, label %cond.true.2204, label %cond.false.2902

cond.true.2204:                                   ; preds = %cond.false.2203
  br i1 true, label %cond.true.2205, label %cond.false.2568

cond.true.2205:                                   ; preds = %cond.true.2204
  %446 = load i64, i64* %fun, align 8
  %call2206 = call %struct.Lisp_Subr* @XSUBR(i64 %446)
  %max_args2207 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2206, i32 0, i32 3
  %447 = load i16, i16* %max_args2207, align 2
  %conv2208 = sext i16 %447 to i32
  %add2209 = add nsw i32 1, %conv2208
  %conv2210 = sext i32 %add2209 to i64
  %add2211 = add nsw i64 0, %conv2210
  %mul2212 = mul nsw i64 0, %add2211
  %sub2213 = sub nsw i64 %mul2212, 1
  %cmp2214 = icmp slt i64 %sub2213, 0
  br i1 %cmp2214, label %cond.true.2216, label %cond.false.2243

cond.true.2216:                                   ; preds = %cond.true.2205
  %448 = load i64, i64* %fun, align 8
  %call2217 = call %struct.Lisp_Subr* @XSUBR(i64 %448)
  %max_args2218 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2217, i32 0, i32 3
  %449 = load i16, i16* %max_args2218, align 2
  %conv2219 = sext i16 %449 to i32
  %add2220 = add nsw i32 1, %conv2219
  %conv2221 = sext i32 %add2220 to i64
  %add2222 = add nsw i64 0, %conv2221
  %mul2223 = mul nsw i64 0, %add2222
  %add2224 = add nsw i64 %mul2223, 0
  %neg2225 = xor i64 %add2224, -1
  %cmp2226 = icmp eq i64 %neg2225, -1
  %conv2227 = zext i1 %cmp2226 to i32
  %sub2228 = sub nsw i32 0, %conv2227
  %conv2229 = sext i32 %sub2228 to i64
  %450 = load i64, i64* %fun, align 8
  %call2230 = call %struct.Lisp_Subr* @XSUBR(i64 %450)
  %max_args2231 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2230, i32 0, i32 3
  %451 = load i16, i16* %max_args2231, align 2
  %conv2232 = sext i16 %451 to i32
  %add2233 = add nsw i32 1, %conv2232
  %conv2234 = sext i32 %add2233 to i64
  %add2235 = add nsw i64 0, %conv2234
  %mul2236 = mul nsw i64 0, %add2235
  %add2237 = add nsw i64 %mul2236, 1
  %shl2238 = shl i64 %add2237, 62
  %sub2239 = sub nsw i64 %shl2238, 1
  %mul2240 = mul nsw i64 %sub2239, 2
  %add2241 = add nsw i64 %mul2240, 1
  %sub2242 = sub nsw i64 %conv2229, %add2241
  br label %cond.end.2252

cond.false.2243:                                  ; preds = %cond.true.2205
  %452 = load i64, i64* %fun, align 8
  %call2244 = call %struct.Lisp_Subr* @XSUBR(i64 %452)
  %max_args2245 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2244, i32 0, i32 3
  %453 = load i16, i16* %max_args2245, align 2
  %conv2246 = sext i16 %453 to i32
  %add2247 = add nsw i32 1, %conv2246
  %conv2248 = sext i32 %add2247 to i64
  %add2249 = add nsw i64 0, %conv2248
  %mul2250 = mul nsw i64 0, %add2249
  %add2251 = add nsw i64 %mul2250, 0
  br label %cond.end.2252

cond.end.2252:                                    ; preds = %cond.false.2243, %cond.true.2216
  %cond2253 = phi i64 [ %sub2242, %cond.true.2216 ], [ %add2251, %cond.false.2243 ]
  %cmp2254 = icmp eq i64 %cond2253, 0
  br i1 %cmp2254, label %land.lhs.true.2256, label %lor.lhs.false.2264

land.lhs.true.2256:                               ; preds = %cond.end.2252
  %454 = load i64, i64* %fun, align 8
  %call2257 = call %struct.Lisp_Subr* @XSUBR(i64 %454)
  %max_args2258 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2257, i32 0, i32 3
  %455 = load i16, i16* %max_args2258, align 2
  %conv2259 = sext i16 %455 to i32
  %add2260 = add nsw i32 1, %conv2259
  %conv2261 = sext i32 %add2260 to i64
  %cmp2262 = icmp slt i64 %conv2261, 0
  br i1 %cmp2262, label %cond.true.2514, label %lor.lhs.false.2264

lor.lhs.false.2264:                               ; preds = %land.lhs.true.2256, %cond.end.2252
  br i1 false, label %cond.true.2265, label %cond.false.2375

cond.true.2265:                                   ; preds = %lor.lhs.false.2264
  %456 = load i64, i64* %fun, align 8
  %call2266 = call %struct.Lisp_Subr* @XSUBR(i64 %456)
  %max_args2267 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2266, i32 0, i32 3
  %457 = load i16, i16* %max_args2267, align 2
  %conv2268 = sext i16 %457 to i32
  %add2269 = add nsw i32 1, %conv2268
  %conv2270 = sext i32 %add2269 to i64
  %cmp2271 = icmp slt i64 %conv2270, 0
  br i1 %cmp2271, label %cond.true.2273, label %cond.false.2316

cond.true.2273:                                   ; preds = %cond.true.2265
  %458 = load i64, i64* %fun, align 8
  %call2274 = call %struct.Lisp_Subr* @XSUBR(i64 %458)
  %max_args2275 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2274, i32 0, i32 3
  %459 = load i16, i16* %max_args2275, align 2
  %conv2276 = sext i16 %459 to i32
  %add2277 = add nsw i32 1, %conv2276
  %conv2278 = sext i32 %add2277 to i64
  %460 = load i64, i64* %fun, align 8
  %call2279 = call %struct.Lisp_Subr* @XSUBR(i64 %460)
  %max_args2280 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2279, i32 0, i32 3
  %461 = load i16, i16* %max_args2280, align 2
  %conv2281 = sext i16 %461 to i32
  %add2282 = add nsw i32 1, %conv2281
  %conv2283 = sext i32 %add2282 to i64
  %add2284 = add nsw i64 0, %conv2283
  %mul2285 = mul nsw i64 0, %add2284
  %sub2286 = sub nsw i64 %mul2285, 1
  %cmp2287 = icmp slt i64 %sub2286, 0
  br i1 %cmp2287, label %cond.true.2289, label %cond.false.2302

cond.true.2289:                                   ; preds = %cond.true.2273
  %462 = load i64, i64* %fun, align 8
  %call2290 = call %struct.Lisp_Subr* @XSUBR(i64 %462)
  %max_args2291 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2290, i32 0, i32 3
  %463 = load i16, i16* %max_args2291, align 2
  %conv2292 = sext i16 %463 to i32
  %add2293 = add nsw i32 1, %conv2292
  %conv2294 = sext i32 %add2293 to i64
  %add2295 = add nsw i64 0, %conv2294
  %mul2296 = mul nsw i64 0, %add2295
  %add2297 = add nsw i64 %mul2296, 1
  %shl2298 = shl i64 %add2297, 62
  %sub2299 = sub nsw i64 %shl2298, 1
  %mul2300 = mul nsw i64 %sub2299, 2
  %add2301 = add nsw i64 %mul2300, 1
  br label %cond.end.2311

cond.false.2302:                                  ; preds = %cond.true.2273
  %464 = load i64, i64* %fun, align 8
  %call2303 = call %struct.Lisp_Subr* @XSUBR(i64 %464)
  %max_args2304 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2303, i32 0, i32 3
  %465 = load i16, i16* %max_args2304, align 2
  %conv2305 = sext i16 %465 to i32
  %add2306 = add nsw i32 1, %conv2305
  %conv2307 = sext i32 %add2306 to i64
  %add2308 = add nsw i64 0, %conv2307
  %mul2309 = mul nsw i64 0, %add2308
  %sub2310 = sub nsw i64 %mul2309, 1
  br label %cond.end.2311

cond.end.2311:                                    ; preds = %cond.false.2302, %cond.true.2289
  %cond2312 = phi i64 [ %add2301, %cond.true.2289 ], [ %sub2310, %cond.false.2302 ]
  %div2313 = sdiv i64 %cond2312, 8
  %cmp2314 = icmp slt i64 %conv2278, %div2313
  br i1 %cmp2314, label %cond.true.2514, label %lor.lhs.false.2485

cond.false.2316:                                  ; preds = %cond.true.2265
  br i1 false, label %cond.true.2317, label %cond.false.2318

cond.true.2317:                                   ; preds = %cond.false.2316
  br i1 false, label %cond.true.2514, label %lor.lhs.false.2485

cond.false.2318:                                  ; preds = %cond.false.2316
  %466 = load i64, i64* %fun, align 8
  %call2319 = call %struct.Lisp_Subr* @XSUBR(i64 %466)
  %max_args2320 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2319, i32 0, i32 3
  %467 = load i16, i16* %max_args2320, align 2
  %conv2321 = sext i16 %467 to i32
  %add2322 = add nsw i32 1, %conv2321
  %conv2323 = sext i32 %add2322 to i64
  %add2324 = add nsw i64 0, %conv2323
  %mul2325 = mul nsw i64 0, %add2324
  %sub2326 = sub nsw i64 %mul2325, 1
  %cmp2327 = icmp slt i64 %sub2326, 0
  br i1 %cmp2327, label %cond.true.2329, label %cond.false.2356

cond.true.2329:                                   ; preds = %cond.false.2318
  %468 = load i64, i64* %fun, align 8
  %call2330 = call %struct.Lisp_Subr* @XSUBR(i64 %468)
  %max_args2331 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2330, i32 0, i32 3
  %469 = load i16, i16* %max_args2331, align 2
  %conv2332 = sext i16 %469 to i32
  %add2333 = add nsw i32 1, %conv2332
  %conv2334 = sext i32 %add2333 to i64
  %add2335 = add nsw i64 0, %conv2334
  %mul2336 = mul nsw i64 0, %add2335
  %add2337 = add nsw i64 %mul2336, 0
  %neg2338 = xor i64 %add2337, -1
  %cmp2339 = icmp eq i64 %neg2338, -1
  %conv2340 = zext i1 %cmp2339 to i32
  %sub2341 = sub nsw i32 0, %conv2340
  %conv2342 = sext i32 %sub2341 to i64
  %470 = load i64, i64* %fun, align 8
  %call2343 = call %struct.Lisp_Subr* @XSUBR(i64 %470)
  %max_args2344 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2343, i32 0, i32 3
  %471 = load i16, i16* %max_args2344, align 2
  %conv2345 = sext i16 %471 to i32
  %add2346 = add nsw i32 1, %conv2345
  %conv2347 = sext i32 %add2346 to i64
  %add2348 = add nsw i64 0, %conv2347
  %mul2349 = mul nsw i64 0, %add2348
  %add2350 = add nsw i64 %mul2349, 1
  %shl2351 = shl i64 %add2350, 62
  %sub2352 = sub nsw i64 %shl2351, 1
  %mul2353 = mul nsw i64 %sub2352, 2
  %add2354 = add nsw i64 %mul2353, 1
  %sub2355 = sub nsw i64 %conv2342, %add2354
  br label %cond.end.2365

cond.false.2356:                                  ; preds = %cond.false.2318
  %472 = load i64, i64* %fun, align 8
  %call2357 = call %struct.Lisp_Subr* @XSUBR(i64 %472)
  %max_args2358 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2357, i32 0, i32 3
  %473 = load i16, i16* %max_args2358, align 2
  %conv2359 = sext i16 %473 to i32
  %add2360 = add nsw i32 1, %conv2359
  %conv2361 = sext i32 %add2360 to i64
  %add2362 = add nsw i64 0, %conv2361
  %mul2363 = mul nsw i64 0, %add2362
  %add2364 = add nsw i64 %mul2363, 0
  br label %cond.end.2365

cond.end.2365:                                    ; preds = %cond.false.2356, %cond.true.2329
  %cond2366 = phi i64 [ %sub2355, %cond.true.2329 ], [ %add2364, %cond.false.2356 ]
  %div2367 = sdiv i64 %cond2366, 8
  %474 = load i64, i64* %fun, align 8
  %call2368 = call %struct.Lisp_Subr* @XSUBR(i64 %474)
  %max_args2369 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2368, i32 0, i32 3
  %475 = load i16, i16* %max_args2369, align 2
  %conv2370 = sext i16 %475 to i32
  %add2371 = add nsw i32 1, %conv2370
  %conv2372 = sext i32 %add2371 to i64
  %cmp2373 = icmp slt i64 %div2367, %conv2372
  br i1 %cmp2373, label %cond.true.2514, label %lor.lhs.false.2485

cond.false.2375:                                  ; preds = %lor.lhs.false.2264
  br i1 false, label %cond.true.2376, label %cond.false.2377

cond.true.2376:                                   ; preds = %cond.false.2375
  br i1 false, label %cond.true.2514, label %lor.lhs.false.2485

cond.false.2377:                                  ; preds = %cond.false.2375
  %476 = load i64, i64* %fun, align 8
  %call2378 = call %struct.Lisp_Subr* @XSUBR(i64 %476)
  %max_args2379 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2378, i32 0, i32 3
  %477 = load i16, i16* %max_args2379, align 2
  %conv2380 = sext i16 %477 to i32
  %add2381 = add nsw i32 1, %conv2380
  %conv2382 = sext i32 %add2381 to i64
  %cmp2383 = icmp slt i64 %conv2382, 0
  br i1 %cmp2383, label %cond.true.2385, label %cond.false.2442

cond.true.2385:                                   ; preds = %cond.false.2377
  %478 = load i64, i64* %fun, align 8
  %call2386 = call %struct.Lisp_Subr* @XSUBR(i64 %478)
  %max_args2387 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2386, i32 0, i32 3
  %479 = load i16, i16* %max_args2387, align 2
  %conv2388 = sext i16 %479 to i32
  %add2389 = add nsw i32 1, %conv2388
  %conv2390 = sext i32 %add2389 to i64
  %480 = load i64, i64* %fun, align 8
  %call2391 = call %struct.Lisp_Subr* @XSUBR(i64 %480)
  %max_args2392 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2391, i32 0, i32 3
  %481 = load i16, i16* %max_args2392, align 2
  %conv2393 = sext i16 %481 to i32
  %add2394 = add nsw i32 1, %conv2393
  %conv2395 = sext i32 %add2394 to i64
  %add2396 = add nsw i64 0, %conv2395
  %mul2397 = mul nsw i64 0, %add2396
  %sub2398 = sub nsw i64 %mul2397, 1
  %cmp2399 = icmp slt i64 %sub2398, 0
  br i1 %cmp2399, label %cond.true.2401, label %cond.false.2428

cond.true.2401:                                   ; preds = %cond.true.2385
  %482 = load i64, i64* %fun, align 8
  %call2402 = call %struct.Lisp_Subr* @XSUBR(i64 %482)
  %max_args2403 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2402, i32 0, i32 3
  %483 = load i16, i16* %max_args2403, align 2
  %conv2404 = sext i16 %483 to i32
  %add2405 = add nsw i32 1, %conv2404
  %conv2406 = sext i32 %add2405 to i64
  %add2407 = add nsw i64 0, %conv2406
  %mul2408 = mul nsw i64 0, %add2407
  %add2409 = add nsw i64 %mul2408, 0
  %neg2410 = xor i64 %add2409, -1
  %cmp2411 = icmp eq i64 %neg2410, -1
  %conv2412 = zext i1 %cmp2411 to i32
  %sub2413 = sub nsw i32 0, %conv2412
  %conv2414 = sext i32 %sub2413 to i64
  %484 = load i64, i64* %fun, align 8
  %call2415 = call %struct.Lisp_Subr* @XSUBR(i64 %484)
  %max_args2416 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2415, i32 0, i32 3
  %485 = load i16, i16* %max_args2416, align 2
  %conv2417 = sext i16 %485 to i32
  %add2418 = add nsw i32 1, %conv2417
  %conv2419 = sext i32 %add2418 to i64
  %add2420 = add nsw i64 0, %conv2419
  %mul2421 = mul nsw i64 0, %add2420
  %add2422 = add nsw i64 %mul2421, 1
  %shl2423 = shl i64 %add2422, 62
  %sub2424 = sub nsw i64 %shl2423, 1
  %mul2425 = mul nsw i64 %sub2424, 2
  %add2426 = add nsw i64 %mul2425, 1
  %sub2427 = sub nsw i64 %conv2414, %add2426
  br label %cond.end.2437

cond.false.2428:                                  ; preds = %cond.true.2385
  %486 = load i64, i64* %fun, align 8
  %call2429 = call %struct.Lisp_Subr* @XSUBR(i64 %486)
  %max_args2430 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2429, i32 0, i32 3
  %487 = load i16, i16* %max_args2430, align 2
  %conv2431 = sext i16 %487 to i32
  %add2432 = add nsw i32 1, %conv2431
  %conv2433 = sext i32 %add2432 to i64
  %add2434 = add nsw i64 0, %conv2433
  %mul2435 = mul nsw i64 0, %add2434
  %add2436 = add nsw i64 %mul2435, 0
  br label %cond.end.2437

cond.end.2437:                                    ; preds = %cond.false.2428, %cond.true.2401
  %cond2438 = phi i64 [ %sub2427, %cond.true.2401 ], [ %add2436, %cond.false.2428 ]
  %div2439 = sdiv i64 %cond2438, 8
  %cmp2440 = icmp slt i64 %conv2390, %div2439
  br i1 %cmp2440, label %cond.true.2514, label %lor.lhs.false.2485

cond.false.2442:                                  ; preds = %cond.false.2377
  %488 = load i64, i64* %fun, align 8
  %call2443 = call %struct.Lisp_Subr* @XSUBR(i64 %488)
  %max_args2444 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2443, i32 0, i32 3
  %489 = load i16, i16* %max_args2444, align 2
  %conv2445 = sext i16 %489 to i32
  %add2446 = add nsw i32 1, %conv2445
  %conv2447 = sext i32 %add2446 to i64
  %add2448 = add nsw i64 0, %conv2447
  %mul2449 = mul nsw i64 0, %add2448
  %sub2450 = sub nsw i64 %mul2449, 1
  %cmp2451 = icmp slt i64 %sub2450, 0
  br i1 %cmp2451, label %cond.true.2453, label %cond.false.2466

cond.true.2453:                                   ; preds = %cond.false.2442
  %490 = load i64, i64* %fun, align 8
  %call2454 = call %struct.Lisp_Subr* @XSUBR(i64 %490)
  %max_args2455 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2454, i32 0, i32 3
  %491 = load i16, i16* %max_args2455, align 2
  %conv2456 = sext i16 %491 to i32
  %add2457 = add nsw i32 1, %conv2456
  %conv2458 = sext i32 %add2457 to i64
  %add2459 = add nsw i64 0, %conv2458
  %mul2460 = mul nsw i64 0, %add2459
  %add2461 = add nsw i64 %mul2460, 1
  %shl2462 = shl i64 %add2461, 62
  %sub2463 = sub nsw i64 %shl2462, 1
  %mul2464 = mul nsw i64 %sub2463, 2
  %add2465 = add nsw i64 %mul2464, 1
  br label %cond.end.2475

cond.false.2466:                                  ; preds = %cond.false.2442
  %492 = load i64, i64* %fun, align 8
  %call2467 = call %struct.Lisp_Subr* @XSUBR(i64 %492)
  %max_args2468 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2467, i32 0, i32 3
  %493 = load i16, i16* %max_args2468, align 2
  %conv2469 = sext i16 %493 to i32
  %add2470 = add nsw i32 1, %conv2469
  %conv2471 = sext i32 %add2470 to i64
  %add2472 = add nsw i64 0, %conv2471
  %mul2473 = mul nsw i64 0, %add2472
  %sub2474 = sub nsw i64 %mul2473, 1
  br label %cond.end.2475

cond.end.2475:                                    ; preds = %cond.false.2466, %cond.true.2453
  %cond2476 = phi i64 [ %add2465, %cond.true.2453 ], [ %sub2474, %cond.false.2466 ]
  %div2477 = sdiv i64 %cond2476, 8
  %494 = load i64, i64* %fun, align 8
  %call2478 = call %struct.Lisp_Subr* @XSUBR(i64 %494)
  %max_args2479 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2478, i32 0, i32 3
  %495 = load i16, i16* %max_args2479, align 2
  %conv2480 = sext i16 %495 to i32
  %add2481 = add nsw i32 1, %conv2480
  %conv2482 = sext i32 %add2481 to i64
  %cmp2483 = icmp slt i64 %div2477, %conv2482
  br i1 %cmp2483, label %cond.true.2514, label %lor.lhs.false.2485

lor.lhs.false.2485:                               ; preds = %cond.end.2475, %cond.end.2437, %cond.true.2376, %cond.end.2365, %cond.true.2317, %cond.end.2311
  %496 = load i64, i64* %fun, align 8
  %call2486 = call %struct.Lisp_Subr* @XSUBR(i64 %496)
  %max_args2487 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2486, i32 0, i32 3
  %497 = load i16, i16* %max_args2487, align 2
  %conv2488 = sext i16 %497 to i32
  %add2489 = add nsw i32 1, %conv2488
  %conv2490 = sext i32 %add2489 to i64
  %mul2491 = mul nsw i64 %conv2490, 8
  %mul2492 = mul nsw i64 0, %mul2491
  %sub2493 = sub nsw i64 %mul2492, 1
  %cmp2494 = icmp slt i64 %sub2493, 0
  br i1 %cmp2494, label %land.lhs.true.2496, label %lor.lhs.false.2505

land.lhs.true.2496:                               ; preds = %lor.lhs.false.2485
  %498 = load i64, i64* %fun, align 8
  %call2497 = call %struct.Lisp_Subr* @XSUBR(i64 %498)
  %max_args2498 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2497, i32 0, i32 3
  %499 = load i16, i16* %max_args2498, align 2
  %conv2499 = sext i16 %499 to i32
  %add2500 = add nsw i32 1, %conv2499
  %conv2501 = sext i32 %add2500 to i64
  %mul2502 = mul nsw i64 %conv2501, 8
  %cmp2503 = icmp slt i64 %mul2502, -9223372036854775808
  br i1 %cmp2503, label %cond.true.2514, label %lor.lhs.false.2505

lor.lhs.false.2505:                               ; preds = %land.lhs.true.2496, %lor.lhs.false.2485
  %500 = load i64, i64* %fun, align 8
  %call2506 = call %struct.Lisp_Subr* @XSUBR(i64 %500)
  %max_args2507 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2506, i32 0, i32 3
  %501 = load i16, i16* %max_args2507, align 2
  %conv2508 = sext i16 %501 to i32
  %add2509 = add nsw i32 1, %conv2508
  %conv2510 = sext i32 %add2509 to i64
  %mul2511 = mul nsw i64 %conv2510, 8
  %cmp2512 = icmp slt i64 9223372036854775807, %mul2511
  br i1 %cmp2512, label %cond.true.2514, label %cond.false.2541

cond.true.2514:                                   ; preds = %lor.lhs.false.2505, %land.lhs.true.2496, %cond.end.2475, %cond.end.2437, %cond.true.2376, %cond.end.2365, %cond.true.2317, %cond.end.2311, %land.lhs.true.2256
  %502 = load i64, i64* %fun, align 8
  %call2515 = call %struct.Lisp_Subr* @XSUBR(i64 %502)
  %max_args2516 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2515, i32 0, i32 3
  %503 = load i16, i16* %max_args2516, align 2
  %conv2517 = sext i16 %503 to i32
  %add2518 = add nsw i32 1, %conv2517
  %conv2519 = sext i32 %add2518 to i64
  %mul2520 = mul i64 %conv2519, 8
  %cmp2521 = icmp ule i64 %mul2520, 9223372036854775807
  br i1 %cmp2521, label %cond.true.2523, label %cond.false.2530

cond.true.2523:                                   ; preds = %cond.true.2514
  %504 = load i64, i64* %fun, align 8
  %call2524 = call %struct.Lisp_Subr* @XSUBR(i64 %504)
  %max_args2525 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2524, i32 0, i32 3
  %505 = load i16, i16* %max_args2525, align 2
  %conv2526 = sext i16 %505 to i32
  %add2527 = add nsw i32 1, %conv2526
  %conv2528 = sext i32 %add2527 to i64
  %mul2529 = mul i64 %conv2528, 8
  br label %cond.end.2539

cond.false.2530:                                  ; preds = %cond.true.2514
  %506 = load i64, i64* %fun, align 8
  %call2531 = call %struct.Lisp_Subr* @XSUBR(i64 %506)
  %max_args2532 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2531, i32 0, i32 3
  %507 = load i16, i16* %max_args2532, align 2
  %conv2533 = sext i16 %507 to i32
  %add2534 = add nsw i32 1, %conv2533
  %conv2535 = sext i32 %add2534 to i64
  %mul2536 = mul i64 %conv2535, 8
  %sub2537 = sub i64 %mul2536, -9223372036854775808
  %add2538 = add nsw i64 %sub2537, -9223372036854775808
  br label %cond.end.2539

cond.end.2539:                                    ; preds = %cond.false.2530, %cond.true.2523
  %cond2540 = phi i64 [ %mul2529, %cond.true.2523 ], [ %add2538, %cond.false.2530 ]
  store i64 %cond2540, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.3603, label %lor.lhs.false.3600

cond.false.2541:                                  ; preds = %lor.lhs.false.2505
  %508 = load i64, i64* %fun, align 8
  %call2542 = call %struct.Lisp_Subr* @XSUBR(i64 %508)
  %max_args2543 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2542, i32 0, i32 3
  %509 = load i16, i16* %max_args2543, align 2
  %conv2544 = sext i16 %509 to i32
  %add2545 = add nsw i32 1, %conv2544
  %conv2546 = sext i32 %add2545 to i64
  %mul2547 = mul i64 %conv2546, 8
  %cmp2548 = icmp ule i64 %mul2547, 9223372036854775807
  br i1 %cmp2548, label %cond.true.2550, label %cond.false.2557

cond.true.2550:                                   ; preds = %cond.false.2541
  %510 = load i64, i64* %fun, align 8
  %call2551 = call %struct.Lisp_Subr* @XSUBR(i64 %510)
  %max_args2552 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2551, i32 0, i32 3
  %511 = load i16, i16* %max_args2552, align 2
  %conv2553 = sext i16 %511 to i32
  %add2554 = add nsw i32 1, %conv2553
  %conv2555 = sext i32 %add2554 to i64
  %mul2556 = mul i64 %conv2555, 8
  br label %cond.end.2566

cond.false.2557:                                  ; preds = %cond.false.2541
  %512 = load i64, i64* %fun, align 8
  %call2558 = call %struct.Lisp_Subr* @XSUBR(i64 %512)
  %max_args2559 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2558, i32 0, i32 3
  %513 = load i16, i16* %max_args2559, align 2
  %conv2560 = sext i16 %513 to i32
  %add2561 = add nsw i32 1, %conv2560
  %conv2562 = sext i32 %add2561 to i64
  %mul2563 = mul i64 %conv2562, 8
  %sub2564 = sub i64 %mul2563, -9223372036854775808
  %add2565 = add nsw i64 %sub2564, -9223372036854775808
  br label %cond.end.2566

cond.end.2566:                                    ; preds = %cond.false.2557, %cond.true.2550
  %cond2567 = phi i64 [ %mul2556, %cond.true.2550 ], [ %add2565, %cond.false.2557 ]
  store i64 %cond2567, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.3603, label %lor.lhs.false.3600

cond.false.2568:                                  ; preds = %cond.true.2204
  %514 = load i64, i64* %fun, align 8
  %call2569 = call %struct.Lisp_Subr* @XSUBR(i64 %514)
  %max_args2570 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2569, i32 0, i32 3
  %515 = load i16, i16* %max_args2570, align 2
  %conv2571 = sext i16 %515 to i32
  %add2572 = add nsw i32 1, %conv2571
  %add2573 = add nsw i32 0, %add2572
  %mul2574 = mul nsw i32 0, %add2573
  %sub2575 = sub nsw i32 %mul2574, 1
  %cmp2576 = icmp slt i32 %sub2575, 0
  br i1 %cmp2576, label %cond.true.2578, label %cond.false.2602

cond.true.2578:                                   ; preds = %cond.false.2568
  %516 = load i64, i64* %fun, align 8
  %call2579 = call %struct.Lisp_Subr* @XSUBR(i64 %516)
  %max_args2580 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2579, i32 0, i32 3
  %517 = load i16, i16* %max_args2580, align 2
  %conv2581 = sext i16 %517 to i32
  %add2582 = add nsw i32 1, %conv2581
  %add2583 = add nsw i32 0, %add2582
  %mul2584 = mul nsw i32 0, %add2583
  %add2585 = add nsw i32 %mul2584, 0
  %neg2586 = xor i32 %add2585, -1
  %cmp2587 = icmp eq i32 %neg2586, -1
  %conv2588 = zext i1 %cmp2587 to i32
  %sub2589 = sub nsw i32 0, %conv2588
  %518 = load i64, i64* %fun, align 8
  %call2590 = call %struct.Lisp_Subr* @XSUBR(i64 %518)
  %max_args2591 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2590, i32 0, i32 3
  %519 = load i16, i16* %max_args2591, align 2
  %conv2592 = sext i16 %519 to i32
  %add2593 = add nsw i32 1, %conv2592
  %add2594 = add nsw i32 0, %add2593
  %mul2595 = mul nsw i32 0, %add2594
  %add2596 = add nsw i32 %mul2595, 1
  %shl2597 = shl i32 %add2596, 30
  %sub2598 = sub nsw i32 %shl2597, 1
  %mul2599 = mul nsw i32 %sub2598, 2
  %add2600 = add nsw i32 %mul2599, 1
  %sub2601 = sub nsw i32 %sub2589, %add2600
  br label %cond.end.2610

cond.false.2602:                                  ; preds = %cond.false.2568
  %520 = load i64, i64* %fun, align 8
  %call2603 = call %struct.Lisp_Subr* @XSUBR(i64 %520)
  %max_args2604 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2603, i32 0, i32 3
  %521 = load i16, i16* %max_args2604, align 2
  %conv2605 = sext i16 %521 to i32
  %add2606 = add nsw i32 1, %conv2605
  %add2607 = add nsw i32 0, %add2606
  %mul2608 = mul nsw i32 0, %add2607
  %add2609 = add nsw i32 %mul2608, 0
  br label %cond.end.2610

cond.end.2610:                                    ; preds = %cond.false.2602, %cond.true.2578
  %cond2611 = phi i32 [ %sub2601, %cond.true.2578 ], [ %add2609, %cond.false.2602 ]
  %cmp2612 = icmp eq i32 %cond2611, 0
  br i1 %cmp2612, label %land.lhs.true.2614, label %lor.lhs.false.2621

land.lhs.true.2614:                               ; preds = %cond.end.2610
  %522 = load i64, i64* %fun, align 8
  %call2615 = call %struct.Lisp_Subr* @XSUBR(i64 %522)
  %max_args2616 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2615, i32 0, i32 3
  %523 = load i16, i16* %max_args2616, align 2
  %conv2617 = sext i16 %523 to i32
  %add2618 = add nsw i32 1, %conv2617
  %cmp2619 = icmp slt i32 %add2618, 0
  br i1 %cmp2619, label %cond.true.2848, label %lor.lhs.false.2621

lor.lhs.false.2621:                               ; preds = %land.lhs.true.2614, %cond.end.2610
  br i1 false, label %cond.true.2622, label %cond.false.2721

cond.true.2622:                                   ; preds = %lor.lhs.false.2621
  %524 = load i64, i64* %fun, align 8
  %call2623 = call %struct.Lisp_Subr* @XSUBR(i64 %524)
  %max_args2624 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2623, i32 0, i32 3
  %525 = load i16, i16* %max_args2624, align 2
  %conv2625 = sext i16 %525 to i32
  %add2626 = add nsw i32 1, %conv2625
  %cmp2627 = icmp slt i32 %add2626, 0
  br i1 %cmp2627, label %cond.true.2629, label %cond.false.2668

cond.true.2629:                                   ; preds = %cond.true.2622
  %526 = load i64, i64* %fun, align 8
  %call2630 = call %struct.Lisp_Subr* @XSUBR(i64 %526)
  %max_args2631 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2630, i32 0, i32 3
  %527 = load i16, i16* %max_args2631, align 2
  %conv2632 = sext i16 %527 to i32
  %add2633 = add nsw i32 1, %conv2632
  %528 = load i64, i64* %fun, align 8
  %call2634 = call %struct.Lisp_Subr* @XSUBR(i64 %528)
  %max_args2635 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2634, i32 0, i32 3
  %529 = load i16, i16* %max_args2635, align 2
  %conv2636 = sext i16 %529 to i32
  %add2637 = add nsw i32 1, %conv2636
  %add2638 = add nsw i32 0, %add2637
  %mul2639 = mul nsw i32 0, %add2638
  %sub2640 = sub nsw i32 %mul2639, 1
  %cmp2641 = icmp slt i32 %sub2640, 0
  br i1 %cmp2641, label %cond.true.2643, label %cond.false.2655

cond.true.2643:                                   ; preds = %cond.true.2629
  %530 = load i64, i64* %fun, align 8
  %call2644 = call %struct.Lisp_Subr* @XSUBR(i64 %530)
  %max_args2645 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2644, i32 0, i32 3
  %531 = load i16, i16* %max_args2645, align 2
  %conv2646 = sext i16 %531 to i32
  %add2647 = add nsw i32 1, %conv2646
  %add2648 = add nsw i32 0, %add2647
  %mul2649 = mul nsw i32 0, %add2648
  %add2650 = add nsw i32 %mul2649, 1
  %shl2651 = shl i32 %add2650, 30
  %sub2652 = sub nsw i32 %shl2651, 1
  %mul2653 = mul nsw i32 %sub2652, 2
  %add2654 = add nsw i32 %mul2653, 1
  br label %cond.end.2663

cond.false.2655:                                  ; preds = %cond.true.2629
  %532 = load i64, i64* %fun, align 8
  %call2656 = call %struct.Lisp_Subr* @XSUBR(i64 %532)
  %max_args2657 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2656, i32 0, i32 3
  %533 = load i16, i16* %max_args2657, align 2
  %conv2658 = sext i16 %533 to i32
  %add2659 = add nsw i32 1, %conv2658
  %add2660 = add nsw i32 0, %add2659
  %mul2661 = mul nsw i32 0, %add2660
  %sub2662 = sub nsw i32 %mul2661, 1
  br label %cond.end.2663

cond.end.2663:                                    ; preds = %cond.false.2655, %cond.true.2643
  %cond2664 = phi i32 [ %add2654, %cond.true.2643 ], [ %sub2662, %cond.false.2655 ]
  %div2665 = sdiv i32 %cond2664, 8
  %cmp2666 = icmp slt i32 %add2633, %div2665
  br i1 %cmp2666, label %cond.true.2848, label %lor.lhs.false.2820

cond.false.2668:                                  ; preds = %cond.true.2622
  br i1 false, label %cond.true.2669, label %cond.false.2670

cond.true.2669:                                   ; preds = %cond.false.2668
  br i1 false, label %cond.true.2848, label %lor.lhs.false.2820

cond.false.2670:                                  ; preds = %cond.false.2668
  %534 = load i64, i64* %fun, align 8
  %call2671 = call %struct.Lisp_Subr* @XSUBR(i64 %534)
  %max_args2672 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2671, i32 0, i32 3
  %535 = load i16, i16* %max_args2672, align 2
  %conv2673 = sext i16 %535 to i32
  %add2674 = add nsw i32 1, %conv2673
  %add2675 = add nsw i32 0, %add2674
  %mul2676 = mul nsw i32 0, %add2675
  %sub2677 = sub nsw i32 %mul2676, 1
  %cmp2678 = icmp slt i32 %sub2677, 0
  br i1 %cmp2678, label %cond.true.2680, label %cond.false.2704

cond.true.2680:                                   ; preds = %cond.false.2670
  %536 = load i64, i64* %fun, align 8
  %call2681 = call %struct.Lisp_Subr* @XSUBR(i64 %536)
  %max_args2682 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2681, i32 0, i32 3
  %537 = load i16, i16* %max_args2682, align 2
  %conv2683 = sext i16 %537 to i32
  %add2684 = add nsw i32 1, %conv2683
  %add2685 = add nsw i32 0, %add2684
  %mul2686 = mul nsw i32 0, %add2685
  %add2687 = add nsw i32 %mul2686, 0
  %neg2688 = xor i32 %add2687, -1
  %cmp2689 = icmp eq i32 %neg2688, -1
  %conv2690 = zext i1 %cmp2689 to i32
  %sub2691 = sub nsw i32 0, %conv2690
  %538 = load i64, i64* %fun, align 8
  %call2692 = call %struct.Lisp_Subr* @XSUBR(i64 %538)
  %max_args2693 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2692, i32 0, i32 3
  %539 = load i16, i16* %max_args2693, align 2
  %conv2694 = sext i16 %539 to i32
  %add2695 = add nsw i32 1, %conv2694
  %add2696 = add nsw i32 0, %add2695
  %mul2697 = mul nsw i32 0, %add2696
  %add2698 = add nsw i32 %mul2697, 1
  %shl2699 = shl i32 %add2698, 30
  %sub2700 = sub nsw i32 %shl2699, 1
  %mul2701 = mul nsw i32 %sub2700, 2
  %add2702 = add nsw i32 %mul2701, 1
  %sub2703 = sub nsw i32 %sub2691, %add2702
  br label %cond.end.2712

cond.false.2704:                                  ; preds = %cond.false.2670
  %540 = load i64, i64* %fun, align 8
  %call2705 = call %struct.Lisp_Subr* @XSUBR(i64 %540)
  %max_args2706 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2705, i32 0, i32 3
  %541 = load i16, i16* %max_args2706, align 2
  %conv2707 = sext i16 %541 to i32
  %add2708 = add nsw i32 1, %conv2707
  %add2709 = add nsw i32 0, %add2708
  %mul2710 = mul nsw i32 0, %add2709
  %add2711 = add nsw i32 %mul2710, 0
  br label %cond.end.2712

cond.end.2712:                                    ; preds = %cond.false.2704, %cond.true.2680
  %cond2713 = phi i32 [ %sub2703, %cond.true.2680 ], [ %add2711, %cond.false.2704 ]
  %div2714 = sdiv i32 %cond2713, 8
  %542 = load i64, i64* %fun, align 8
  %call2715 = call %struct.Lisp_Subr* @XSUBR(i64 %542)
  %max_args2716 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2715, i32 0, i32 3
  %543 = load i16, i16* %max_args2716, align 2
  %conv2717 = sext i16 %543 to i32
  %add2718 = add nsw i32 1, %conv2717
  %cmp2719 = icmp slt i32 %div2714, %add2718
  br i1 %cmp2719, label %cond.true.2848, label %lor.lhs.false.2820

cond.false.2721:                                  ; preds = %lor.lhs.false.2621
  br i1 false, label %cond.true.2722, label %cond.false.2723

cond.true.2722:                                   ; preds = %cond.false.2721
  br i1 false, label %cond.true.2848, label %lor.lhs.false.2820

cond.false.2723:                                  ; preds = %cond.false.2721
  %544 = load i64, i64* %fun, align 8
  %call2724 = call %struct.Lisp_Subr* @XSUBR(i64 %544)
  %max_args2725 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2724, i32 0, i32 3
  %545 = load i16, i16* %max_args2725, align 2
  %conv2726 = sext i16 %545 to i32
  %add2727 = add nsw i32 1, %conv2726
  %cmp2728 = icmp slt i32 %add2727, 0
  br i1 %cmp2728, label %cond.true.2730, label %cond.false.2781

cond.true.2730:                                   ; preds = %cond.false.2723
  %546 = load i64, i64* %fun, align 8
  %call2731 = call %struct.Lisp_Subr* @XSUBR(i64 %546)
  %max_args2732 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2731, i32 0, i32 3
  %547 = load i16, i16* %max_args2732, align 2
  %conv2733 = sext i16 %547 to i32
  %add2734 = add nsw i32 1, %conv2733
  %548 = load i64, i64* %fun, align 8
  %call2735 = call %struct.Lisp_Subr* @XSUBR(i64 %548)
  %max_args2736 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2735, i32 0, i32 3
  %549 = load i16, i16* %max_args2736, align 2
  %conv2737 = sext i16 %549 to i32
  %add2738 = add nsw i32 1, %conv2737
  %add2739 = add nsw i32 0, %add2738
  %mul2740 = mul nsw i32 0, %add2739
  %sub2741 = sub nsw i32 %mul2740, 1
  %cmp2742 = icmp slt i32 %sub2741, 0
  br i1 %cmp2742, label %cond.true.2744, label %cond.false.2768

cond.true.2744:                                   ; preds = %cond.true.2730
  %550 = load i64, i64* %fun, align 8
  %call2745 = call %struct.Lisp_Subr* @XSUBR(i64 %550)
  %max_args2746 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2745, i32 0, i32 3
  %551 = load i16, i16* %max_args2746, align 2
  %conv2747 = sext i16 %551 to i32
  %add2748 = add nsw i32 1, %conv2747
  %add2749 = add nsw i32 0, %add2748
  %mul2750 = mul nsw i32 0, %add2749
  %add2751 = add nsw i32 %mul2750, 0
  %neg2752 = xor i32 %add2751, -1
  %cmp2753 = icmp eq i32 %neg2752, -1
  %conv2754 = zext i1 %cmp2753 to i32
  %sub2755 = sub nsw i32 0, %conv2754
  %552 = load i64, i64* %fun, align 8
  %call2756 = call %struct.Lisp_Subr* @XSUBR(i64 %552)
  %max_args2757 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2756, i32 0, i32 3
  %553 = load i16, i16* %max_args2757, align 2
  %conv2758 = sext i16 %553 to i32
  %add2759 = add nsw i32 1, %conv2758
  %add2760 = add nsw i32 0, %add2759
  %mul2761 = mul nsw i32 0, %add2760
  %add2762 = add nsw i32 %mul2761, 1
  %shl2763 = shl i32 %add2762, 30
  %sub2764 = sub nsw i32 %shl2763, 1
  %mul2765 = mul nsw i32 %sub2764, 2
  %add2766 = add nsw i32 %mul2765, 1
  %sub2767 = sub nsw i32 %sub2755, %add2766
  br label %cond.end.2776

cond.false.2768:                                  ; preds = %cond.true.2730
  %554 = load i64, i64* %fun, align 8
  %call2769 = call %struct.Lisp_Subr* @XSUBR(i64 %554)
  %max_args2770 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2769, i32 0, i32 3
  %555 = load i16, i16* %max_args2770, align 2
  %conv2771 = sext i16 %555 to i32
  %add2772 = add nsw i32 1, %conv2771
  %add2773 = add nsw i32 0, %add2772
  %mul2774 = mul nsw i32 0, %add2773
  %add2775 = add nsw i32 %mul2774, 0
  br label %cond.end.2776

cond.end.2776:                                    ; preds = %cond.false.2768, %cond.true.2744
  %cond2777 = phi i32 [ %sub2767, %cond.true.2744 ], [ %add2775, %cond.false.2768 ]
  %div2778 = sdiv i32 %cond2777, 8
  %cmp2779 = icmp slt i32 %add2734, %div2778
  br i1 %cmp2779, label %cond.true.2848, label %lor.lhs.false.2820

cond.false.2781:                                  ; preds = %cond.false.2723
  %556 = load i64, i64* %fun, align 8
  %call2782 = call %struct.Lisp_Subr* @XSUBR(i64 %556)
  %max_args2783 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2782, i32 0, i32 3
  %557 = load i16, i16* %max_args2783, align 2
  %conv2784 = sext i16 %557 to i32
  %add2785 = add nsw i32 1, %conv2784
  %add2786 = add nsw i32 0, %add2785
  %mul2787 = mul nsw i32 0, %add2786
  %sub2788 = sub nsw i32 %mul2787, 1
  %cmp2789 = icmp slt i32 %sub2788, 0
  br i1 %cmp2789, label %cond.true.2791, label %cond.false.2803

cond.true.2791:                                   ; preds = %cond.false.2781
  %558 = load i64, i64* %fun, align 8
  %call2792 = call %struct.Lisp_Subr* @XSUBR(i64 %558)
  %max_args2793 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2792, i32 0, i32 3
  %559 = load i16, i16* %max_args2793, align 2
  %conv2794 = sext i16 %559 to i32
  %add2795 = add nsw i32 1, %conv2794
  %add2796 = add nsw i32 0, %add2795
  %mul2797 = mul nsw i32 0, %add2796
  %add2798 = add nsw i32 %mul2797, 1
  %shl2799 = shl i32 %add2798, 30
  %sub2800 = sub nsw i32 %shl2799, 1
  %mul2801 = mul nsw i32 %sub2800, 2
  %add2802 = add nsw i32 %mul2801, 1
  br label %cond.end.2811

cond.false.2803:                                  ; preds = %cond.false.2781
  %560 = load i64, i64* %fun, align 8
  %call2804 = call %struct.Lisp_Subr* @XSUBR(i64 %560)
  %max_args2805 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2804, i32 0, i32 3
  %561 = load i16, i16* %max_args2805, align 2
  %conv2806 = sext i16 %561 to i32
  %add2807 = add nsw i32 1, %conv2806
  %add2808 = add nsw i32 0, %add2807
  %mul2809 = mul nsw i32 0, %add2808
  %sub2810 = sub nsw i32 %mul2809, 1
  br label %cond.end.2811

cond.end.2811:                                    ; preds = %cond.false.2803, %cond.true.2791
  %cond2812 = phi i32 [ %add2802, %cond.true.2791 ], [ %sub2810, %cond.false.2803 ]
  %div2813 = sdiv i32 %cond2812, 8
  %562 = load i64, i64* %fun, align 8
  %call2814 = call %struct.Lisp_Subr* @XSUBR(i64 %562)
  %max_args2815 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2814, i32 0, i32 3
  %563 = load i16, i16* %max_args2815, align 2
  %conv2816 = sext i16 %563 to i32
  %add2817 = add nsw i32 1, %conv2816
  %cmp2818 = icmp slt i32 %div2813, %add2817
  br i1 %cmp2818, label %cond.true.2848, label %lor.lhs.false.2820

lor.lhs.false.2820:                               ; preds = %cond.end.2811, %cond.end.2776, %cond.true.2722, %cond.end.2712, %cond.true.2669, %cond.end.2663
  %564 = load i64, i64* %fun, align 8
  %call2821 = call %struct.Lisp_Subr* @XSUBR(i64 %564)
  %max_args2822 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2821, i32 0, i32 3
  %565 = load i16, i16* %max_args2822, align 2
  %conv2823 = sext i16 %565 to i32
  %add2824 = add nsw i32 1, %conv2823
  %mul2825 = mul nsw i32 %add2824, 8
  %mul2826 = mul nsw i32 0, %mul2825
  %sub2827 = sub nsw i32 %mul2826, 1
  %cmp2828 = icmp slt i32 %sub2827, 0
  br i1 %cmp2828, label %land.lhs.true.2830, label %lor.lhs.false.2839

land.lhs.true.2830:                               ; preds = %lor.lhs.false.2820
  %566 = load i64, i64* %fun, align 8
  %call2831 = call %struct.Lisp_Subr* @XSUBR(i64 %566)
  %max_args2832 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2831, i32 0, i32 3
  %567 = load i16, i16* %max_args2832, align 2
  %conv2833 = sext i16 %567 to i32
  %add2834 = add nsw i32 1, %conv2833
  %mul2835 = mul nsw i32 %add2834, 8
  %conv2836 = sext i32 %mul2835 to i64
  %cmp2837 = icmp slt i64 %conv2836, -9223372036854775808
  br i1 %cmp2837, label %cond.true.2848, label %lor.lhs.false.2839

lor.lhs.false.2839:                               ; preds = %land.lhs.true.2830, %lor.lhs.false.2820
  %568 = load i64, i64* %fun, align 8
  %call2840 = call %struct.Lisp_Subr* @XSUBR(i64 %568)
  %max_args2841 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2840, i32 0, i32 3
  %569 = load i16, i16* %max_args2841, align 2
  %conv2842 = sext i16 %569 to i32
  %add2843 = add nsw i32 1, %conv2842
  %mul2844 = mul nsw i32 %add2843, 8
  %conv2845 = sext i32 %mul2844 to i64
  %cmp2846 = icmp slt i64 9223372036854775807, %conv2845
  br i1 %cmp2846, label %cond.true.2848, label %cond.false.2875

cond.true.2848:                                   ; preds = %lor.lhs.false.2839, %land.lhs.true.2830, %cond.end.2811, %cond.end.2776, %cond.true.2722, %cond.end.2712, %cond.true.2669, %cond.end.2663, %land.lhs.true.2614
  %570 = load i64, i64* %fun, align 8
  %call2849 = call %struct.Lisp_Subr* @XSUBR(i64 %570)
  %max_args2850 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2849, i32 0, i32 3
  %571 = load i16, i16* %max_args2850, align 2
  %conv2851 = sext i16 %571 to i32
  %add2852 = add nsw i32 1, %conv2851
  %conv2853 = sext i32 %add2852 to i64
  %mul2854 = mul i64 %conv2853, 8
  %cmp2855 = icmp ule i64 %mul2854, 9223372036854775807
  br i1 %cmp2855, label %cond.true.2857, label %cond.false.2864

cond.true.2857:                                   ; preds = %cond.true.2848
  %572 = load i64, i64* %fun, align 8
  %call2858 = call %struct.Lisp_Subr* @XSUBR(i64 %572)
  %max_args2859 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2858, i32 0, i32 3
  %573 = load i16, i16* %max_args2859, align 2
  %conv2860 = sext i16 %573 to i32
  %add2861 = add nsw i32 1, %conv2860
  %conv2862 = sext i32 %add2861 to i64
  %mul2863 = mul i64 %conv2862, 8
  br label %cond.end.2873

cond.false.2864:                                  ; preds = %cond.true.2848
  %574 = load i64, i64* %fun, align 8
  %call2865 = call %struct.Lisp_Subr* @XSUBR(i64 %574)
  %max_args2866 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2865, i32 0, i32 3
  %575 = load i16, i16* %max_args2866, align 2
  %conv2867 = sext i16 %575 to i32
  %add2868 = add nsw i32 1, %conv2867
  %conv2869 = sext i32 %add2868 to i64
  %mul2870 = mul i64 %conv2869, 8
  %sub2871 = sub i64 %mul2870, -9223372036854775808
  %add2872 = add nsw i64 %sub2871, -9223372036854775808
  br label %cond.end.2873

cond.end.2873:                                    ; preds = %cond.false.2864, %cond.true.2857
  %cond2874 = phi i64 [ %mul2863, %cond.true.2857 ], [ %add2872, %cond.false.2864 ]
  store i64 %cond2874, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.3603, label %lor.lhs.false.3600

cond.false.2875:                                  ; preds = %lor.lhs.false.2839
  %576 = load i64, i64* %fun, align 8
  %call2876 = call %struct.Lisp_Subr* @XSUBR(i64 %576)
  %max_args2877 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2876, i32 0, i32 3
  %577 = load i16, i16* %max_args2877, align 2
  %conv2878 = sext i16 %577 to i32
  %add2879 = add nsw i32 1, %conv2878
  %conv2880 = sext i32 %add2879 to i64
  %mul2881 = mul i64 %conv2880, 8
  %cmp2882 = icmp ule i64 %mul2881, 9223372036854775807
  br i1 %cmp2882, label %cond.true.2884, label %cond.false.2891

cond.true.2884:                                   ; preds = %cond.false.2875
  %578 = load i64, i64* %fun, align 8
  %call2885 = call %struct.Lisp_Subr* @XSUBR(i64 %578)
  %max_args2886 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2885, i32 0, i32 3
  %579 = load i16, i16* %max_args2886, align 2
  %conv2887 = sext i16 %579 to i32
  %add2888 = add nsw i32 1, %conv2887
  %conv2889 = sext i32 %add2888 to i64
  %mul2890 = mul i64 %conv2889, 8
  br label %cond.end.2900

cond.false.2891:                                  ; preds = %cond.false.2875
  %580 = load i64, i64* %fun, align 8
  %call2892 = call %struct.Lisp_Subr* @XSUBR(i64 %580)
  %max_args2893 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2892, i32 0, i32 3
  %581 = load i16, i16* %max_args2893, align 2
  %conv2894 = sext i16 %581 to i32
  %add2895 = add nsw i32 1, %conv2894
  %conv2896 = sext i32 %add2895 to i64
  %mul2897 = mul i64 %conv2896, 8
  %sub2898 = sub i64 %mul2897, -9223372036854775808
  %add2899 = add nsw i64 %sub2898, -9223372036854775808
  br label %cond.end.2900

cond.end.2900:                                    ; preds = %cond.false.2891, %cond.true.2884
  %cond2901 = phi i64 [ %mul2890, %cond.true.2884 ], [ %add2899, %cond.false.2891 ]
  store i64 %cond2901, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.3603, label %lor.lhs.false.3600

cond.false.2902:                                  ; preds = %cond.false.2203
  br i1 true, label %cond.true.2903, label %cond.false.3266

cond.true.2903:                                   ; preds = %cond.false.2902
  %582 = load i64, i64* %fun, align 8
  %call2904 = call %struct.Lisp_Subr* @XSUBR(i64 %582)
  %max_args2905 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2904, i32 0, i32 3
  %583 = load i16, i16* %max_args2905, align 2
  %conv2906 = sext i16 %583 to i32
  %add2907 = add nsw i32 1, %conv2906
  %conv2908 = sext i32 %add2907 to i64
  %add2909 = add nsw i64 0, %conv2908
  %mul2910 = mul nsw i64 0, %add2909
  %sub2911 = sub nsw i64 %mul2910, 1
  %cmp2912 = icmp slt i64 %sub2911, 0
  br i1 %cmp2912, label %cond.true.2914, label %cond.false.2941

cond.true.2914:                                   ; preds = %cond.true.2903
  %584 = load i64, i64* %fun, align 8
  %call2915 = call %struct.Lisp_Subr* @XSUBR(i64 %584)
  %max_args2916 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2915, i32 0, i32 3
  %585 = load i16, i16* %max_args2916, align 2
  %conv2917 = sext i16 %585 to i32
  %add2918 = add nsw i32 1, %conv2917
  %conv2919 = sext i32 %add2918 to i64
  %add2920 = add nsw i64 0, %conv2919
  %mul2921 = mul nsw i64 0, %add2920
  %add2922 = add nsw i64 %mul2921, 0
  %neg2923 = xor i64 %add2922, -1
  %cmp2924 = icmp eq i64 %neg2923, -1
  %conv2925 = zext i1 %cmp2924 to i32
  %sub2926 = sub nsw i32 0, %conv2925
  %conv2927 = sext i32 %sub2926 to i64
  %586 = load i64, i64* %fun, align 8
  %call2928 = call %struct.Lisp_Subr* @XSUBR(i64 %586)
  %max_args2929 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2928, i32 0, i32 3
  %587 = load i16, i16* %max_args2929, align 2
  %conv2930 = sext i16 %587 to i32
  %add2931 = add nsw i32 1, %conv2930
  %conv2932 = sext i32 %add2931 to i64
  %add2933 = add nsw i64 0, %conv2932
  %mul2934 = mul nsw i64 0, %add2933
  %add2935 = add nsw i64 %mul2934, 1
  %shl2936 = shl i64 %add2935, 62
  %sub2937 = sub nsw i64 %shl2936, 1
  %mul2938 = mul nsw i64 %sub2937, 2
  %add2939 = add nsw i64 %mul2938, 1
  %sub2940 = sub nsw i64 %conv2927, %add2939
  br label %cond.end.2950

cond.false.2941:                                  ; preds = %cond.true.2903
  %588 = load i64, i64* %fun, align 8
  %call2942 = call %struct.Lisp_Subr* @XSUBR(i64 %588)
  %max_args2943 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2942, i32 0, i32 3
  %589 = load i16, i16* %max_args2943, align 2
  %conv2944 = sext i16 %589 to i32
  %add2945 = add nsw i32 1, %conv2944
  %conv2946 = sext i32 %add2945 to i64
  %add2947 = add nsw i64 0, %conv2946
  %mul2948 = mul nsw i64 0, %add2947
  %add2949 = add nsw i64 %mul2948, 0
  br label %cond.end.2950

cond.end.2950:                                    ; preds = %cond.false.2941, %cond.true.2914
  %cond2951 = phi i64 [ %sub2940, %cond.true.2914 ], [ %add2949, %cond.false.2941 ]
  %cmp2952 = icmp eq i64 %cond2951, 0
  br i1 %cmp2952, label %land.lhs.true.2954, label %lor.lhs.false.2962

land.lhs.true.2954:                               ; preds = %cond.end.2950
  %590 = load i64, i64* %fun, align 8
  %call2955 = call %struct.Lisp_Subr* @XSUBR(i64 %590)
  %max_args2956 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2955, i32 0, i32 3
  %591 = load i16, i16* %max_args2956, align 2
  %conv2957 = sext i16 %591 to i32
  %add2958 = add nsw i32 1, %conv2957
  %conv2959 = sext i32 %add2958 to i64
  %cmp2960 = icmp slt i64 %conv2959, 0
  br i1 %cmp2960, label %cond.true.3212, label %lor.lhs.false.2962

lor.lhs.false.2962:                               ; preds = %land.lhs.true.2954, %cond.end.2950
  br i1 false, label %cond.true.2963, label %cond.false.3073

cond.true.2963:                                   ; preds = %lor.lhs.false.2962
  %592 = load i64, i64* %fun, align 8
  %call2964 = call %struct.Lisp_Subr* @XSUBR(i64 %592)
  %max_args2965 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2964, i32 0, i32 3
  %593 = load i16, i16* %max_args2965, align 2
  %conv2966 = sext i16 %593 to i32
  %add2967 = add nsw i32 1, %conv2966
  %conv2968 = sext i32 %add2967 to i64
  %cmp2969 = icmp slt i64 %conv2968, 0
  br i1 %cmp2969, label %cond.true.2971, label %cond.false.3014

cond.true.2971:                                   ; preds = %cond.true.2963
  %594 = load i64, i64* %fun, align 8
  %call2972 = call %struct.Lisp_Subr* @XSUBR(i64 %594)
  %max_args2973 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2972, i32 0, i32 3
  %595 = load i16, i16* %max_args2973, align 2
  %conv2974 = sext i16 %595 to i32
  %add2975 = add nsw i32 1, %conv2974
  %conv2976 = sext i32 %add2975 to i64
  %596 = load i64, i64* %fun, align 8
  %call2977 = call %struct.Lisp_Subr* @XSUBR(i64 %596)
  %max_args2978 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2977, i32 0, i32 3
  %597 = load i16, i16* %max_args2978, align 2
  %conv2979 = sext i16 %597 to i32
  %add2980 = add nsw i32 1, %conv2979
  %conv2981 = sext i32 %add2980 to i64
  %add2982 = add nsw i64 0, %conv2981
  %mul2983 = mul nsw i64 0, %add2982
  %sub2984 = sub nsw i64 %mul2983, 1
  %cmp2985 = icmp slt i64 %sub2984, 0
  br i1 %cmp2985, label %cond.true.2987, label %cond.false.3000

cond.true.2987:                                   ; preds = %cond.true.2971
  %598 = load i64, i64* %fun, align 8
  %call2988 = call %struct.Lisp_Subr* @XSUBR(i64 %598)
  %max_args2989 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call2988, i32 0, i32 3
  %599 = load i16, i16* %max_args2989, align 2
  %conv2990 = sext i16 %599 to i32
  %add2991 = add nsw i32 1, %conv2990
  %conv2992 = sext i32 %add2991 to i64
  %add2993 = add nsw i64 0, %conv2992
  %mul2994 = mul nsw i64 0, %add2993
  %add2995 = add nsw i64 %mul2994, 1
  %shl2996 = shl i64 %add2995, 62
  %sub2997 = sub nsw i64 %shl2996, 1
  %mul2998 = mul nsw i64 %sub2997, 2
  %add2999 = add nsw i64 %mul2998, 1
  br label %cond.end.3009

cond.false.3000:                                  ; preds = %cond.true.2971
  %600 = load i64, i64* %fun, align 8
  %call3001 = call %struct.Lisp_Subr* @XSUBR(i64 %600)
  %max_args3002 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3001, i32 0, i32 3
  %601 = load i16, i16* %max_args3002, align 2
  %conv3003 = sext i16 %601 to i32
  %add3004 = add nsw i32 1, %conv3003
  %conv3005 = sext i32 %add3004 to i64
  %add3006 = add nsw i64 0, %conv3005
  %mul3007 = mul nsw i64 0, %add3006
  %sub3008 = sub nsw i64 %mul3007, 1
  br label %cond.end.3009

cond.end.3009:                                    ; preds = %cond.false.3000, %cond.true.2987
  %cond3010 = phi i64 [ %add2999, %cond.true.2987 ], [ %sub3008, %cond.false.3000 ]
  %div3011 = sdiv i64 %cond3010, 8
  %cmp3012 = icmp slt i64 %conv2976, %div3011
  br i1 %cmp3012, label %cond.true.3212, label %lor.lhs.false.3183

cond.false.3014:                                  ; preds = %cond.true.2963
  br i1 false, label %cond.true.3015, label %cond.false.3016

cond.true.3015:                                   ; preds = %cond.false.3014
  br i1 false, label %cond.true.3212, label %lor.lhs.false.3183

cond.false.3016:                                  ; preds = %cond.false.3014
  %602 = load i64, i64* %fun, align 8
  %call3017 = call %struct.Lisp_Subr* @XSUBR(i64 %602)
  %max_args3018 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3017, i32 0, i32 3
  %603 = load i16, i16* %max_args3018, align 2
  %conv3019 = sext i16 %603 to i32
  %add3020 = add nsw i32 1, %conv3019
  %conv3021 = sext i32 %add3020 to i64
  %add3022 = add nsw i64 0, %conv3021
  %mul3023 = mul nsw i64 0, %add3022
  %sub3024 = sub nsw i64 %mul3023, 1
  %cmp3025 = icmp slt i64 %sub3024, 0
  br i1 %cmp3025, label %cond.true.3027, label %cond.false.3054

cond.true.3027:                                   ; preds = %cond.false.3016
  %604 = load i64, i64* %fun, align 8
  %call3028 = call %struct.Lisp_Subr* @XSUBR(i64 %604)
  %max_args3029 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3028, i32 0, i32 3
  %605 = load i16, i16* %max_args3029, align 2
  %conv3030 = sext i16 %605 to i32
  %add3031 = add nsw i32 1, %conv3030
  %conv3032 = sext i32 %add3031 to i64
  %add3033 = add nsw i64 0, %conv3032
  %mul3034 = mul nsw i64 0, %add3033
  %add3035 = add nsw i64 %mul3034, 0
  %neg3036 = xor i64 %add3035, -1
  %cmp3037 = icmp eq i64 %neg3036, -1
  %conv3038 = zext i1 %cmp3037 to i32
  %sub3039 = sub nsw i32 0, %conv3038
  %conv3040 = sext i32 %sub3039 to i64
  %606 = load i64, i64* %fun, align 8
  %call3041 = call %struct.Lisp_Subr* @XSUBR(i64 %606)
  %max_args3042 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3041, i32 0, i32 3
  %607 = load i16, i16* %max_args3042, align 2
  %conv3043 = sext i16 %607 to i32
  %add3044 = add nsw i32 1, %conv3043
  %conv3045 = sext i32 %add3044 to i64
  %add3046 = add nsw i64 0, %conv3045
  %mul3047 = mul nsw i64 0, %add3046
  %add3048 = add nsw i64 %mul3047, 1
  %shl3049 = shl i64 %add3048, 62
  %sub3050 = sub nsw i64 %shl3049, 1
  %mul3051 = mul nsw i64 %sub3050, 2
  %add3052 = add nsw i64 %mul3051, 1
  %sub3053 = sub nsw i64 %conv3040, %add3052
  br label %cond.end.3063

cond.false.3054:                                  ; preds = %cond.false.3016
  %608 = load i64, i64* %fun, align 8
  %call3055 = call %struct.Lisp_Subr* @XSUBR(i64 %608)
  %max_args3056 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3055, i32 0, i32 3
  %609 = load i16, i16* %max_args3056, align 2
  %conv3057 = sext i16 %609 to i32
  %add3058 = add nsw i32 1, %conv3057
  %conv3059 = sext i32 %add3058 to i64
  %add3060 = add nsw i64 0, %conv3059
  %mul3061 = mul nsw i64 0, %add3060
  %add3062 = add nsw i64 %mul3061, 0
  br label %cond.end.3063

cond.end.3063:                                    ; preds = %cond.false.3054, %cond.true.3027
  %cond3064 = phi i64 [ %sub3053, %cond.true.3027 ], [ %add3062, %cond.false.3054 ]
  %div3065 = sdiv i64 %cond3064, 8
  %610 = load i64, i64* %fun, align 8
  %call3066 = call %struct.Lisp_Subr* @XSUBR(i64 %610)
  %max_args3067 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3066, i32 0, i32 3
  %611 = load i16, i16* %max_args3067, align 2
  %conv3068 = sext i16 %611 to i32
  %add3069 = add nsw i32 1, %conv3068
  %conv3070 = sext i32 %add3069 to i64
  %cmp3071 = icmp slt i64 %div3065, %conv3070
  br i1 %cmp3071, label %cond.true.3212, label %lor.lhs.false.3183

cond.false.3073:                                  ; preds = %lor.lhs.false.2962
  br i1 false, label %cond.true.3074, label %cond.false.3075

cond.true.3074:                                   ; preds = %cond.false.3073
  br i1 false, label %cond.true.3212, label %lor.lhs.false.3183

cond.false.3075:                                  ; preds = %cond.false.3073
  %612 = load i64, i64* %fun, align 8
  %call3076 = call %struct.Lisp_Subr* @XSUBR(i64 %612)
  %max_args3077 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3076, i32 0, i32 3
  %613 = load i16, i16* %max_args3077, align 2
  %conv3078 = sext i16 %613 to i32
  %add3079 = add nsw i32 1, %conv3078
  %conv3080 = sext i32 %add3079 to i64
  %cmp3081 = icmp slt i64 %conv3080, 0
  br i1 %cmp3081, label %cond.true.3083, label %cond.false.3140

cond.true.3083:                                   ; preds = %cond.false.3075
  %614 = load i64, i64* %fun, align 8
  %call3084 = call %struct.Lisp_Subr* @XSUBR(i64 %614)
  %max_args3085 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3084, i32 0, i32 3
  %615 = load i16, i16* %max_args3085, align 2
  %conv3086 = sext i16 %615 to i32
  %add3087 = add nsw i32 1, %conv3086
  %conv3088 = sext i32 %add3087 to i64
  %616 = load i64, i64* %fun, align 8
  %call3089 = call %struct.Lisp_Subr* @XSUBR(i64 %616)
  %max_args3090 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3089, i32 0, i32 3
  %617 = load i16, i16* %max_args3090, align 2
  %conv3091 = sext i16 %617 to i32
  %add3092 = add nsw i32 1, %conv3091
  %conv3093 = sext i32 %add3092 to i64
  %add3094 = add nsw i64 0, %conv3093
  %mul3095 = mul nsw i64 0, %add3094
  %sub3096 = sub nsw i64 %mul3095, 1
  %cmp3097 = icmp slt i64 %sub3096, 0
  br i1 %cmp3097, label %cond.true.3099, label %cond.false.3126

cond.true.3099:                                   ; preds = %cond.true.3083
  %618 = load i64, i64* %fun, align 8
  %call3100 = call %struct.Lisp_Subr* @XSUBR(i64 %618)
  %max_args3101 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3100, i32 0, i32 3
  %619 = load i16, i16* %max_args3101, align 2
  %conv3102 = sext i16 %619 to i32
  %add3103 = add nsw i32 1, %conv3102
  %conv3104 = sext i32 %add3103 to i64
  %add3105 = add nsw i64 0, %conv3104
  %mul3106 = mul nsw i64 0, %add3105
  %add3107 = add nsw i64 %mul3106, 0
  %neg3108 = xor i64 %add3107, -1
  %cmp3109 = icmp eq i64 %neg3108, -1
  %conv3110 = zext i1 %cmp3109 to i32
  %sub3111 = sub nsw i32 0, %conv3110
  %conv3112 = sext i32 %sub3111 to i64
  %620 = load i64, i64* %fun, align 8
  %call3113 = call %struct.Lisp_Subr* @XSUBR(i64 %620)
  %max_args3114 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3113, i32 0, i32 3
  %621 = load i16, i16* %max_args3114, align 2
  %conv3115 = sext i16 %621 to i32
  %add3116 = add nsw i32 1, %conv3115
  %conv3117 = sext i32 %add3116 to i64
  %add3118 = add nsw i64 0, %conv3117
  %mul3119 = mul nsw i64 0, %add3118
  %add3120 = add nsw i64 %mul3119, 1
  %shl3121 = shl i64 %add3120, 62
  %sub3122 = sub nsw i64 %shl3121, 1
  %mul3123 = mul nsw i64 %sub3122, 2
  %add3124 = add nsw i64 %mul3123, 1
  %sub3125 = sub nsw i64 %conv3112, %add3124
  br label %cond.end.3135

cond.false.3126:                                  ; preds = %cond.true.3083
  %622 = load i64, i64* %fun, align 8
  %call3127 = call %struct.Lisp_Subr* @XSUBR(i64 %622)
  %max_args3128 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3127, i32 0, i32 3
  %623 = load i16, i16* %max_args3128, align 2
  %conv3129 = sext i16 %623 to i32
  %add3130 = add nsw i32 1, %conv3129
  %conv3131 = sext i32 %add3130 to i64
  %add3132 = add nsw i64 0, %conv3131
  %mul3133 = mul nsw i64 0, %add3132
  %add3134 = add nsw i64 %mul3133, 0
  br label %cond.end.3135

cond.end.3135:                                    ; preds = %cond.false.3126, %cond.true.3099
  %cond3136 = phi i64 [ %sub3125, %cond.true.3099 ], [ %add3134, %cond.false.3126 ]
  %div3137 = sdiv i64 %cond3136, 8
  %cmp3138 = icmp slt i64 %conv3088, %div3137
  br i1 %cmp3138, label %cond.true.3212, label %lor.lhs.false.3183

cond.false.3140:                                  ; preds = %cond.false.3075
  %624 = load i64, i64* %fun, align 8
  %call3141 = call %struct.Lisp_Subr* @XSUBR(i64 %624)
  %max_args3142 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3141, i32 0, i32 3
  %625 = load i16, i16* %max_args3142, align 2
  %conv3143 = sext i16 %625 to i32
  %add3144 = add nsw i32 1, %conv3143
  %conv3145 = sext i32 %add3144 to i64
  %add3146 = add nsw i64 0, %conv3145
  %mul3147 = mul nsw i64 0, %add3146
  %sub3148 = sub nsw i64 %mul3147, 1
  %cmp3149 = icmp slt i64 %sub3148, 0
  br i1 %cmp3149, label %cond.true.3151, label %cond.false.3164

cond.true.3151:                                   ; preds = %cond.false.3140
  %626 = load i64, i64* %fun, align 8
  %call3152 = call %struct.Lisp_Subr* @XSUBR(i64 %626)
  %max_args3153 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3152, i32 0, i32 3
  %627 = load i16, i16* %max_args3153, align 2
  %conv3154 = sext i16 %627 to i32
  %add3155 = add nsw i32 1, %conv3154
  %conv3156 = sext i32 %add3155 to i64
  %add3157 = add nsw i64 0, %conv3156
  %mul3158 = mul nsw i64 0, %add3157
  %add3159 = add nsw i64 %mul3158, 1
  %shl3160 = shl i64 %add3159, 62
  %sub3161 = sub nsw i64 %shl3160, 1
  %mul3162 = mul nsw i64 %sub3161, 2
  %add3163 = add nsw i64 %mul3162, 1
  br label %cond.end.3173

cond.false.3164:                                  ; preds = %cond.false.3140
  %628 = load i64, i64* %fun, align 8
  %call3165 = call %struct.Lisp_Subr* @XSUBR(i64 %628)
  %max_args3166 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3165, i32 0, i32 3
  %629 = load i16, i16* %max_args3166, align 2
  %conv3167 = sext i16 %629 to i32
  %add3168 = add nsw i32 1, %conv3167
  %conv3169 = sext i32 %add3168 to i64
  %add3170 = add nsw i64 0, %conv3169
  %mul3171 = mul nsw i64 0, %add3170
  %sub3172 = sub nsw i64 %mul3171, 1
  br label %cond.end.3173

cond.end.3173:                                    ; preds = %cond.false.3164, %cond.true.3151
  %cond3174 = phi i64 [ %add3163, %cond.true.3151 ], [ %sub3172, %cond.false.3164 ]
  %div3175 = sdiv i64 %cond3174, 8
  %630 = load i64, i64* %fun, align 8
  %call3176 = call %struct.Lisp_Subr* @XSUBR(i64 %630)
  %max_args3177 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3176, i32 0, i32 3
  %631 = load i16, i16* %max_args3177, align 2
  %conv3178 = sext i16 %631 to i32
  %add3179 = add nsw i32 1, %conv3178
  %conv3180 = sext i32 %add3179 to i64
  %cmp3181 = icmp slt i64 %div3175, %conv3180
  br i1 %cmp3181, label %cond.true.3212, label %lor.lhs.false.3183

lor.lhs.false.3183:                               ; preds = %cond.end.3173, %cond.end.3135, %cond.true.3074, %cond.end.3063, %cond.true.3015, %cond.end.3009
  %632 = load i64, i64* %fun, align 8
  %call3184 = call %struct.Lisp_Subr* @XSUBR(i64 %632)
  %max_args3185 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3184, i32 0, i32 3
  %633 = load i16, i16* %max_args3185, align 2
  %conv3186 = sext i16 %633 to i32
  %add3187 = add nsw i32 1, %conv3186
  %conv3188 = sext i32 %add3187 to i64
  %mul3189 = mul nsw i64 %conv3188, 8
  %mul3190 = mul nsw i64 0, %mul3189
  %sub3191 = sub nsw i64 %mul3190, 1
  %cmp3192 = icmp slt i64 %sub3191, 0
  br i1 %cmp3192, label %land.lhs.true.3194, label %lor.lhs.false.3203

land.lhs.true.3194:                               ; preds = %lor.lhs.false.3183
  %634 = load i64, i64* %fun, align 8
  %call3195 = call %struct.Lisp_Subr* @XSUBR(i64 %634)
  %max_args3196 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3195, i32 0, i32 3
  %635 = load i16, i16* %max_args3196, align 2
  %conv3197 = sext i16 %635 to i32
  %add3198 = add nsw i32 1, %conv3197
  %conv3199 = sext i32 %add3198 to i64
  %mul3200 = mul nsw i64 %conv3199, 8
  %cmp3201 = icmp slt i64 %mul3200, -9223372036854775808
  br i1 %cmp3201, label %cond.true.3212, label %lor.lhs.false.3203

lor.lhs.false.3203:                               ; preds = %land.lhs.true.3194, %lor.lhs.false.3183
  %636 = load i64, i64* %fun, align 8
  %call3204 = call %struct.Lisp_Subr* @XSUBR(i64 %636)
  %max_args3205 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3204, i32 0, i32 3
  %637 = load i16, i16* %max_args3205, align 2
  %conv3206 = sext i16 %637 to i32
  %add3207 = add nsw i32 1, %conv3206
  %conv3208 = sext i32 %add3207 to i64
  %mul3209 = mul nsw i64 %conv3208, 8
  %cmp3210 = icmp slt i64 9223372036854775807, %mul3209
  br i1 %cmp3210, label %cond.true.3212, label %cond.false.3239

cond.true.3212:                                   ; preds = %lor.lhs.false.3203, %land.lhs.true.3194, %cond.end.3173, %cond.end.3135, %cond.true.3074, %cond.end.3063, %cond.true.3015, %cond.end.3009, %land.lhs.true.2954
  %638 = load i64, i64* %fun, align 8
  %call3213 = call %struct.Lisp_Subr* @XSUBR(i64 %638)
  %max_args3214 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3213, i32 0, i32 3
  %639 = load i16, i16* %max_args3214, align 2
  %conv3215 = sext i16 %639 to i32
  %add3216 = add nsw i32 1, %conv3215
  %conv3217 = sext i32 %add3216 to i64
  %mul3218 = mul i64 %conv3217, 8
  %cmp3219 = icmp ule i64 %mul3218, 9223372036854775807
  br i1 %cmp3219, label %cond.true.3221, label %cond.false.3228

cond.true.3221:                                   ; preds = %cond.true.3212
  %640 = load i64, i64* %fun, align 8
  %call3222 = call %struct.Lisp_Subr* @XSUBR(i64 %640)
  %max_args3223 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3222, i32 0, i32 3
  %641 = load i16, i16* %max_args3223, align 2
  %conv3224 = sext i16 %641 to i32
  %add3225 = add nsw i32 1, %conv3224
  %conv3226 = sext i32 %add3225 to i64
  %mul3227 = mul i64 %conv3226, 8
  br label %cond.end.3237

cond.false.3228:                                  ; preds = %cond.true.3212
  %642 = load i64, i64* %fun, align 8
  %call3229 = call %struct.Lisp_Subr* @XSUBR(i64 %642)
  %max_args3230 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3229, i32 0, i32 3
  %643 = load i16, i16* %max_args3230, align 2
  %conv3231 = sext i16 %643 to i32
  %add3232 = add nsw i32 1, %conv3231
  %conv3233 = sext i32 %add3232 to i64
  %mul3234 = mul i64 %conv3233, 8
  %sub3235 = sub i64 %mul3234, -9223372036854775808
  %add3236 = add nsw i64 %sub3235, -9223372036854775808
  br label %cond.end.3237

cond.end.3237:                                    ; preds = %cond.false.3228, %cond.true.3221
  %cond3238 = phi i64 [ %mul3227, %cond.true.3221 ], [ %add3236, %cond.false.3228 ]
  store i64 %cond3238, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.3603, label %lor.lhs.false.3600

cond.false.3239:                                  ; preds = %lor.lhs.false.3203
  %644 = load i64, i64* %fun, align 8
  %call3240 = call %struct.Lisp_Subr* @XSUBR(i64 %644)
  %max_args3241 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3240, i32 0, i32 3
  %645 = load i16, i16* %max_args3241, align 2
  %conv3242 = sext i16 %645 to i32
  %add3243 = add nsw i32 1, %conv3242
  %conv3244 = sext i32 %add3243 to i64
  %mul3245 = mul i64 %conv3244, 8
  %cmp3246 = icmp ule i64 %mul3245, 9223372036854775807
  br i1 %cmp3246, label %cond.true.3248, label %cond.false.3255

cond.true.3248:                                   ; preds = %cond.false.3239
  %646 = load i64, i64* %fun, align 8
  %call3249 = call %struct.Lisp_Subr* @XSUBR(i64 %646)
  %max_args3250 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3249, i32 0, i32 3
  %647 = load i16, i16* %max_args3250, align 2
  %conv3251 = sext i16 %647 to i32
  %add3252 = add nsw i32 1, %conv3251
  %conv3253 = sext i32 %add3252 to i64
  %mul3254 = mul i64 %conv3253, 8
  br label %cond.end.3264

cond.false.3255:                                  ; preds = %cond.false.3239
  %648 = load i64, i64* %fun, align 8
  %call3256 = call %struct.Lisp_Subr* @XSUBR(i64 %648)
  %max_args3257 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3256, i32 0, i32 3
  %649 = load i16, i16* %max_args3257, align 2
  %conv3258 = sext i16 %649 to i32
  %add3259 = add nsw i32 1, %conv3258
  %conv3260 = sext i32 %add3259 to i64
  %mul3261 = mul i64 %conv3260, 8
  %sub3262 = sub i64 %mul3261, -9223372036854775808
  %add3263 = add nsw i64 %sub3262, -9223372036854775808
  br label %cond.end.3264

cond.end.3264:                                    ; preds = %cond.false.3255, %cond.true.3248
  %cond3265 = phi i64 [ %mul3254, %cond.true.3248 ], [ %add3263, %cond.false.3255 ]
  store i64 %cond3265, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.3603, label %lor.lhs.false.3600

cond.false.3266:                                  ; preds = %cond.false.2902
  %650 = load i64, i64* %fun, align 8
  %call3267 = call %struct.Lisp_Subr* @XSUBR(i64 %650)
  %max_args3268 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3267, i32 0, i32 3
  %651 = load i16, i16* %max_args3268, align 2
  %conv3269 = sext i16 %651 to i32
  %add3270 = add nsw i32 1, %conv3269
  %add3271 = add nsw i32 0, %add3270
  %mul3272 = mul nsw i32 0, %add3271
  %sub3273 = sub nsw i32 %mul3272, 1
  %cmp3274 = icmp slt i32 %sub3273, 0
  br i1 %cmp3274, label %cond.true.3276, label %cond.false.3300

cond.true.3276:                                   ; preds = %cond.false.3266
  %652 = load i64, i64* %fun, align 8
  %call3277 = call %struct.Lisp_Subr* @XSUBR(i64 %652)
  %max_args3278 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3277, i32 0, i32 3
  %653 = load i16, i16* %max_args3278, align 2
  %conv3279 = sext i16 %653 to i32
  %add3280 = add nsw i32 1, %conv3279
  %add3281 = add nsw i32 0, %add3280
  %mul3282 = mul nsw i32 0, %add3281
  %add3283 = add nsw i32 %mul3282, 0
  %neg3284 = xor i32 %add3283, -1
  %cmp3285 = icmp eq i32 %neg3284, -1
  %conv3286 = zext i1 %cmp3285 to i32
  %sub3287 = sub nsw i32 0, %conv3286
  %654 = load i64, i64* %fun, align 8
  %call3288 = call %struct.Lisp_Subr* @XSUBR(i64 %654)
  %max_args3289 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3288, i32 0, i32 3
  %655 = load i16, i16* %max_args3289, align 2
  %conv3290 = sext i16 %655 to i32
  %add3291 = add nsw i32 1, %conv3290
  %add3292 = add nsw i32 0, %add3291
  %mul3293 = mul nsw i32 0, %add3292
  %add3294 = add nsw i32 %mul3293, 1
  %shl3295 = shl i32 %add3294, 30
  %sub3296 = sub nsw i32 %shl3295, 1
  %mul3297 = mul nsw i32 %sub3296, 2
  %add3298 = add nsw i32 %mul3297, 1
  %sub3299 = sub nsw i32 %sub3287, %add3298
  br label %cond.end.3308

cond.false.3300:                                  ; preds = %cond.false.3266
  %656 = load i64, i64* %fun, align 8
  %call3301 = call %struct.Lisp_Subr* @XSUBR(i64 %656)
  %max_args3302 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3301, i32 0, i32 3
  %657 = load i16, i16* %max_args3302, align 2
  %conv3303 = sext i16 %657 to i32
  %add3304 = add nsw i32 1, %conv3303
  %add3305 = add nsw i32 0, %add3304
  %mul3306 = mul nsw i32 0, %add3305
  %add3307 = add nsw i32 %mul3306, 0
  br label %cond.end.3308

cond.end.3308:                                    ; preds = %cond.false.3300, %cond.true.3276
  %cond3309 = phi i32 [ %sub3299, %cond.true.3276 ], [ %add3307, %cond.false.3300 ]
  %cmp3310 = icmp eq i32 %cond3309, 0
  br i1 %cmp3310, label %land.lhs.true.3312, label %lor.lhs.false.3319

land.lhs.true.3312:                               ; preds = %cond.end.3308
  %658 = load i64, i64* %fun, align 8
  %call3313 = call %struct.Lisp_Subr* @XSUBR(i64 %658)
  %max_args3314 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3313, i32 0, i32 3
  %659 = load i16, i16* %max_args3314, align 2
  %conv3315 = sext i16 %659 to i32
  %add3316 = add nsw i32 1, %conv3315
  %cmp3317 = icmp slt i32 %add3316, 0
  br i1 %cmp3317, label %cond.true.3546, label %lor.lhs.false.3319

lor.lhs.false.3319:                               ; preds = %land.lhs.true.3312, %cond.end.3308
  br i1 false, label %cond.true.3320, label %cond.false.3419

cond.true.3320:                                   ; preds = %lor.lhs.false.3319
  %660 = load i64, i64* %fun, align 8
  %call3321 = call %struct.Lisp_Subr* @XSUBR(i64 %660)
  %max_args3322 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3321, i32 0, i32 3
  %661 = load i16, i16* %max_args3322, align 2
  %conv3323 = sext i16 %661 to i32
  %add3324 = add nsw i32 1, %conv3323
  %cmp3325 = icmp slt i32 %add3324, 0
  br i1 %cmp3325, label %cond.true.3327, label %cond.false.3366

cond.true.3327:                                   ; preds = %cond.true.3320
  %662 = load i64, i64* %fun, align 8
  %call3328 = call %struct.Lisp_Subr* @XSUBR(i64 %662)
  %max_args3329 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3328, i32 0, i32 3
  %663 = load i16, i16* %max_args3329, align 2
  %conv3330 = sext i16 %663 to i32
  %add3331 = add nsw i32 1, %conv3330
  %664 = load i64, i64* %fun, align 8
  %call3332 = call %struct.Lisp_Subr* @XSUBR(i64 %664)
  %max_args3333 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3332, i32 0, i32 3
  %665 = load i16, i16* %max_args3333, align 2
  %conv3334 = sext i16 %665 to i32
  %add3335 = add nsw i32 1, %conv3334
  %add3336 = add nsw i32 0, %add3335
  %mul3337 = mul nsw i32 0, %add3336
  %sub3338 = sub nsw i32 %mul3337, 1
  %cmp3339 = icmp slt i32 %sub3338, 0
  br i1 %cmp3339, label %cond.true.3341, label %cond.false.3353

cond.true.3341:                                   ; preds = %cond.true.3327
  %666 = load i64, i64* %fun, align 8
  %call3342 = call %struct.Lisp_Subr* @XSUBR(i64 %666)
  %max_args3343 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3342, i32 0, i32 3
  %667 = load i16, i16* %max_args3343, align 2
  %conv3344 = sext i16 %667 to i32
  %add3345 = add nsw i32 1, %conv3344
  %add3346 = add nsw i32 0, %add3345
  %mul3347 = mul nsw i32 0, %add3346
  %add3348 = add nsw i32 %mul3347, 1
  %shl3349 = shl i32 %add3348, 30
  %sub3350 = sub nsw i32 %shl3349, 1
  %mul3351 = mul nsw i32 %sub3350, 2
  %add3352 = add nsw i32 %mul3351, 1
  br label %cond.end.3361

cond.false.3353:                                  ; preds = %cond.true.3327
  %668 = load i64, i64* %fun, align 8
  %call3354 = call %struct.Lisp_Subr* @XSUBR(i64 %668)
  %max_args3355 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3354, i32 0, i32 3
  %669 = load i16, i16* %max_args3355, align 2
  %conv3356 = sext i16 %669 to i32
  %add3357 = add nsw i32 1, %conv3356
  %add3358 = add nsw i32 0, %add3357
  %mul3359 = mul nsw i32 0, %add3358
  %sub3360 = sub nsw i32 %mul3359, 1
  br label %cond.end.3361

cond.end.3361:                                    ; preds = %cond.false.3353, %cond.true.3341
  %cond3362 = phi i32 [ %add3352, %cond.true.3341 ], [ %sub3360, %cond.false.3353 ]
  %div3363 = sdiv i32 %cond3362, 8
  %cmp3364 = icmp slt i32 %add3331, %div3363
  br i1 %cmp3364, label %cond.true.3546, label %lor.lhs.false.3518

cond.false.3366:                                  ; preds = %cond.true.3320
  br i1 false, label %cond.true.3367, label %cond.false.3368

cond.true.3367:                                   ; preds = %cond.false.3366
  br i1 false, label %cond.true.3546, label %lor.lhs.false.3518

cond.false.3368:                                  ; preds = %cond.false.3366
  %670 = load i64, i64* %fun, align 8
  %call3369 = call %struct.Lisp_Subr* @XSUBR(i64 %670)
  %max_args3370 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3369, i32 0, i32 3
  %671 = load i16, i16* %max_args3370, align 2
  %conv3371 = sext i16 %671 to i32
  %add3372 = add nsw i32 1, %conv3371
  %add3373 = add nsw i32 0, %add3372
  %mul3374 = mul nsw i32 0, %add3373
  %sub3375 = sub nsw i32 %mul3374, 1
  %cmp3376 = icmp slt i32 %sub3375, 0
  br i1 %cmp3376, label %cond.true.3378, label %cond.false.3402

cond.true.3378:                                   ; preds = %cond.false.3368
  %672 = load i64, i64* %fun, align 8
  %call3379 = call %struct.Lisp_Subr* @XSUBR(i64 %672)
  %max_args3380 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3379, i32 0, i32 3
  %673 = load i16, i16* %max_args3380, align 2
  %conv3381 = sext i16 %673 to i32
  %add3382 = add nsw i32 1, %conv3381
  %add3383 = add nsw i32 0, %add3382
  %mul3384 = mul nsw i32 0, %add3383
  %add3385 = add nsw i32 %mul3384, 0
  %neg3386 = xor i32 %add3385, -1
  %cmp3387 = icmp eq i32 %neg3386, -1
  %conv3388 = zext i1 %cmp3387 to i32
  %sub3389 = sub nsw i32 0, %conv3388
  %674 = load i64, i64* %fun, align 8
  %call3390 = call %struct.Lisp_Subr* @XSUBR(i64 %674)
  %max_args3391 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3390, i32 0, i32 3
  %675 = load i16, i16* %max_args3391, align 2
  %conv3392 = sext i16 %675 to i32
  %add3393 = add nsw i32 1, %conv3392
  %add3394 = add nsw i32 0, %add3393
  %mul3395 = mul nsw i32 0, %add3394
  %add3396 = add nsw i32 %mul3395, 1
  %shl3397 = shl i32 %add3396, 30
  %sub3398 = sub nsw i32 %shl3397, 1
  %mul3399 = mul nsw i32 %sub3398, 2
  %add3400 = add nsw i32 %mul3399, 1
  %sub3401 = sub nsw i32 %sub3389, %add3400
  br label %cond.end.3410

cond.false.3402:                                  ; preds = %cond.false.3368
  %676 = load i64, i64* %fun, align 8
  %call3403 = call %struct.Lisp_Subr* @XSUBR(i64 %676)
  %max_args3404 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3403, i32 0, i32 3
  %677 = load i16, i16* %max_args3404, align 2
  %conv3405 = sext i16 %677 to i32
  %add3406 = add nsw i32 1, %conv3405
  %add3407 = add nsw i32 0, %add3406
  %mul3408 = mul nsw i32 0, %add3407
  %add3409 = add nsw i32 %mul3408, 0
  br label %cond.end.3410

cond.end.3410:                                    ; preds = %cond.false.3402, %cond.true.3378
  %cond3411 = phi i32 [ %sub3401, %cond.true.3378 ], [ %add3409, %cond.false.3402 ]
  %div3412 = sdiv i32 %cond3411, 8
  %678 = load i64, i64* %fun, align 8
  %call3413 = call %struct.Lisp_Subr* @XSUBR(i64 %678)
  %max_args3414 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3413, i32 0, i32 3
  %679 = load i16, i16* %max_args3414, align 2
  %conv3415 = sext i16 %679 to i32
  %add3416 = add nsw i32 1, %conv3415
  %cmp3417 = icmp slt i32 %div3412, %add3416
  br i1 %cmp3417, label %cond.true.3546, label %lor.lhs.false.3518

cond.false.3419:                                  ; preds = %lor.lhs.false.3319
  br i1 false, label %cond.true.3420, label %cond.false.3421

cond.true.3420:                                   ; preds = %cond.false.3419
  br i1 false, label %cond.true.3546, label %lor.lhs.false.3518

cond.false.3421:                                  ; preds = %cond.false.3419
  %680 = load i64, i64* %fun, align 8
  %call3422 = call %struct.Lisp_Subr* @XSUBR(i64 %680)
  %max_args3423 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3422, i32 0, i32 3
  %681 = load i16, i16* %max_args3423, align 2
  %conv3424 = sext i16 %681 to i32
  %add3425 = add nsw i32 1, %conv3424
  %cmp3426 = icmp slt i32 %add3425, 0
  br i1 %cmp3426, label %cond.true.3428, label %cond.false.3479

cond.true.3428:                                   ; preds = %cond.false.3421
  %682 = load i64, i64* %fun, align 8
  %call3429 = call %struct.Lisp_Subr* @XSUBR(i64 %682)
  %max_args3430 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3429, i32 0, i32 3
  %683 = load i16, i16* %max_args3430, align 2
  %conv3431 = sext i16 %683 to i32
  %add3432 = add nsw i32 1, %conv3431
  %684 = load i64, i64* %fun, align 8
  %call3433 = call %struct.Lisp_Subr* @XSUBR(i64 %684)
  %max_args3434 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3433, i32 0, i32 3
  %685 = load i16, i16* %max_args3434, align 2
  %conv3435 = sext i16 %685 to i32
  %add3436 = add nsw i32 1, %conv3435
  %add3437 = add nsw i32 0, %add3436
  %mul3438 = mul nsw i32 0, %add3437
  %sub3439 = sub nsw i32 %mul3438, 1
  %cmp3440 = icmp slt i32 %sub3439, 0
  br i1 %cmp3440, label %cond.true.3442, label %cond.false.3466

cond.true.3442:                                   ; preds = %cond.true.3428
  %686 = load i64, i64* %fun, align 8
  %call3443 = call %struct.Lisp_Subr* @XSUBR(i64 %686)
  %max_args3444 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3443, i32 0, i32 3
  %687 = load i16, i16* %max_args3444, align 2
  %conv3445 = sext i16 %687 to i32
  %add3446 = add nsw i32 1, %conv3445
  %add3447 = add nsw i32 0, %add3446
  %mul3448 = mul nsw i32 0, %add3447
  %add3449 = add nsw i32 %mul3448, 0
  %neg3450 = xor i32 %add3449, -1
  %cmp3451 = icmp eq i32 %neg3450, -1
  %conv3452 = zext i1 %cmp3451 to i32
  %sub3453 = sub nsw i32 0, %conv3452
  %688 = load i64, i64* %fun, align 8
  %call3454 = call %struct.Lisp_Subr* @XSUBR(i64 %688)
  %max_args3455 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3454, i32 0, i32 3
  %689 = load i16, i16* %max_args3455, align 2
  %conv3456 = sext i16 %689 to i32
  %add3457 = add nsw i32 1, %conv3456
  %add3458 = add nsw i32 0, %add3457
  %mul3459 = mul nsw i32 0, %add3458
  %add3460 = add nsw i32 %mul3459, 1
  %shl3461 = shl i32 %add3460, 30
  %sub3462 = sub nsw i32 %shl3461, 1
  %mul3463 = mul nsw i32 %sub3462, 2
  %add3464 = add nsw i32 %mul3463, 1
  %sub3465 = sub nsw i32 %sub3453, %add3464
  br label %cond.end.3474

cond.false.3466:                                  ; preds = %cond.true.3428
  %690 = load i64, i64* %fun, align 8
  %call3467 = call %struct.Lisp_Subr* @XSUBR(i64 %690)
  %max_args3468 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3467, i32 0, i32 3
  %691 = load i16, i16* %max_args3468, align 2
  %conv3469 = sext i16 %691 to i32
  %add3470 = add nsw i32 1, %conv3469
  %add3471 = add nsw i32 0, %add3470
  %mul3472 = mul nsw i32 0, %add3471
  %add3473 = add nsw i32 %mul3472, 0
  br label %cond.end.3474

cond.end.3474:                                    ; preds = %cond.false.3466, %cond.true.3442
  %cond3475 = phi i32 [ %sub3465, %cond.true.3442 ], [ %add3473, %cond.false.3466 ]
  %div3476 = sdiv i32 %cond3475, 8
  %cmp3477 = icmp slt i32 %add3432, %div3476
  br i1 %cmp3477, label %cond.true.3546, label %lor.lhs.false.3518

cond.false.3479:                                  ; preds = %cond.false.3421
  %692 = load i64, i64* %fun, align 8
  %call3480 = call %struct.Lisp_Subr* @XSUBR(i64 %692)
  %max_args3481 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3480, i32 0, i32 3
  %693 = load i16, i16* %max_args3481, align 2
  %conv3482 = sext i16 %693 to i32
  %add3483 = add nsw i32 1, %conv3482
  %add3484 = add nsw i32 0, %add3483
  %mul3485 = mul nsw i32 0, %add3484
  %sub3486 = sub nsw i32 %mul3485, 1
  %cmp3487 = icmp slt i32 %sub3486, 0
  br i1 %cmp3487, label %cond.true.3489, label %cond.false.3501

cond.true.3489:                                   ; preds = %cond.false.3479
  %694 = load i64, i64* %fun, align 8
  %call3490 = call %struct.Lisp_Subr* @XSUBR(i64 %694)
  %max_args3491 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3490, i32 0, i32 3
  %695 = load i16, i16* %max_args3491, align 2
  %conv3492 = sext i16 %695 to i32
  %add3493 = add nsw i32 1, %conv3492
  %add3494 = add nsw i32 0, %add3493
  %mul3495 = mul nsw i32 0, %add3494
  %add3496 = add nsw i32 %mul3495, 1
  %shl3497 = shl i32 %add3496, 30
  %sub3498 = sub nsw i32 %shl3497, 1
  %mul3499 = mul nsw i32 %sub3498, 2
  %add3500 = add nsw i32 %mul3499, 1
  br label %cond.end.3509

cond.false.3501:                                  ; preds = %cond.false.3479
  %696 = load i64, i64* %fun, align 8
  %call3502 = call %struct.Lisp_Subr* @XSUBR(i64 %696)
  %max_args3503 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3502, i32 0, i32 3
  %697 = load i16, i16* %max_args3503, align 2
  %conv3504 = sext i16 %697 to i32
  %add3505 = add nsw i32 1, %conv3504
  %add3506 = add nsw i32 0, %add3505
  %mul3507 = mul nsw i32 0, %add3506
  %sub3508 = sub nsw i32 %mul3507, 1
  br label %cond.end.3509

cond.end.3509:                                    ; preds = %cond.false.3501, %cond.true.3489
  %cond3510 = phi i32 [ %add3500, %cond.true.3489 ], [ %sub3508, %cond.false.3501 ]
  %div3511 = sdiv i32 %cond3510, 8
  %698 = load i64, i64* %fun, align 8
  %call3512 = call %struct.Lisp_Subr* @XSUBR(i64 %698)
  %max_args3513 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3512, i32 0, i32 3
  %699 = load i16, i16* %max_args3513, align 2
  %conv3514 = sext i16 %699 to i32
  %add3515 = add nsw i32 1, %conv3514
  %cmp3516 = icmp slt i32 %div3511, %add3515
  br i1 %cmp3516, label %cond.true.3546, label %lor.lhs.false.3518

lor.lhs.false.3518:                               ; preds = %cond.end.3509, %cond.end.3474, %cond.true.3420, %cond.end.3410, %cond.true.3367, %cond.end.3361
  %700 = load i64, i64* %fun, align 8
  %call3519 = call %struct.Lisp_Subr* @XSUBR(i64 %700)
  %max_args3520 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3519, i32 0, i32 3
  %701 = load i16, i16* %max_args3520, align 2
  %conv3521 = sext i16 %701 to i32
  %add3522 = add nsw i32 1, %conv3521
  %mul3523 = mul nsw i32 %add3522, 8
  %mul3524 = mul nsw i32 0, %mul3523
  %sub3525 = sub nsw i32 %mul3524, 1
  %cmp3526 = icmp slt i32 %sub3525, 0
  br i1 %cmp3526, label %land.lhs.true.3528, label %lor.lhs.false.3537

land.lhs.true.3528:                               ; preds = %lor.lhs.false.3518
  %702 = load i64, i64* %fun, align 8
  %call3529 = call %struct.Lisp_Subr* @XSUBR(i64 %702)
  %max_args3530 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3529, i32 0, i32 3
  %703 = load i16, i16* %max_args3530, align 2
  %conv3531 = sext i16 %703 to i32
  %add3532 = add nsw i32 1, %conv3531
  %mul3533 = mul nsw i32 %add3532, 8
  %conv3534 = sext i32 %mul3533 to i64
  %cmp3535 = icmp slt i64 %conv3534, -9223372036854775808
  br i1 %cmp3535, label %cond.true.3546, label %lor.lhs.false.3537

lor.lhs.false.3537:                               ; preds = %land.lhs.true.3528, %lor.lhs.false.3518
  %704 = load i64, i64* %fun, align 8
  %call3538 = call %struct.Lisp_Subr* @XSUBR(i64 %704)
  %max_args3539 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3538, i32 0, i32 3
  %705 = load i16, i16* %max_args3539, align 2
  %conv3540 = sext i16 %705 to i32
  %add3541 = add nsw i32 1, %conv3540
  %mul3542 = mul nsw i32 %add3541, 8
  %conv3543 = sext i32 %mul3542 to i64
  %cmp3544 = icmp slt i64 9223372036854775807, %conv3543
  br i1 %cmp3544, label %cond.true.3546, label %cond.false.3573

cond.true.3546:                                   ; preds = %lor.lhs.false.3537, %land.lhs.true.3528, %cond.end.3509, %cond.end.3474, %cond.true.3420, %cond.end.3410, %cond.true.3367, %cond.end.3361, %land.lhs.true.3312
  %706 = load i64, i64* %fun, align 8
  %call3547 = call %struct.Lisp_Subr* @XSUBR(i64 %706)
  %max_args3548 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3547, i32 0, i32 3
  %707 = load i16, i16* %max_args3548, align 2
  %conv3549 = sext i16 %707 to i32
  %add3550 = add nsw i32 1, %conv3549
  %conv3551 = sext i32 %add3550 to i64
  %mul3552 = mul i64 %conv3551, 8
  %cmp3553 = icmp ule i64 %mul3552, 9223372036854775807
  br i1 %cmp3553, label %cond.true.3555, label %cond.false.3562

cond.true.3555:                                   ; preds = %cond.true.3546
  %708 = load i64, i64* %fun, align 8
  %call3556 = call %struct.Lisp_Subr* @XSUBR(i64 %708)
  %max_args3557 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3556, i32 0, i32 3
  %709 = load i16, i16* %max_args3557, align 2
  %conv3558 = sext i16 %709 to i32
  %add3559 = add nsw i32 1, %conv3558
  %conv3560 = sext i32 %add3559 to i64
  %mul3561 = mul i64 %conv3560, 8
  br label %cond.end.3571

cond.false.3562:                                  ; preds = %cond.true.3546
  %710 = load i64, i64* %fun, align 8
  %call3563 = call %struct.Lisp_Subr* @XSUBR(i64 %710)
  %max_args3564 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3563, i32 0, i32 3
  %711 = load i16, i16* %max_args3564, align 2
  %conv3565 = sext i16 %711 to i32
  %add3566 = add nsw i32 1, %conv3565
  %conv3567 = sext i32 %add3566 to i64
  %mul3568 = mul i64 %conv3567, 8
  %sub3569 = sub i64 %mul3568, -9223372036854775808
  %add3570 = add nsw i64 %sub3569, -9223372036854775808
  br label %cond.end.3571

cond.end.3571:                                    ; preds = %cond.false.3562, %cond.true.3555
  %cond3572 = phi i64 [ %mul3561, %cond.true.3555 ], [ %add3570, %cond.false.3562 ]
  store i64 %cond3572, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.3603, label %lor.lhs.false.3600

cond.false.3573:                                  ; preds = %lor.lhs.false.3537
  %712 = load i64, i64* %fun, align 8
  %call3574 = call %struct.Lisp_Subr* @XSUBR(i64 %712)
  %max_args3575 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3574, i32 0, i32 3
  %713 = load i16, i16* %max_args3575, align 2
  %conv3576 = sext i16 %713 to i32
  %add3577 = add nsw i32 1, %conv3576
  %conv3578 = sext i32 %add3577 to i64
  %mul3579 = mul i64 %conv3578, 8
  %cmp3580 = icmp ule i64 %mul3579, 9223372036854775807
  br i1 %cmp3580, label %cond.true.3582, label %cond.false.3589

cond.true.3582:                                   ; preds = %cond.false.3573
  %714 = load i64, i64* %fun, align 8
  %call3583 = call %struct.Lisp_Subr* @XSUBR(i64 %714)
  %max_args3584 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3583, i32 0, i32 3
  %715 = load i16, i16* %max_args3584, align 2
  %conv3585 = sext i16 %715 to i32
  %add3586 = add nsw i32 1, %conv3585
  %conv3587 = sext i32 %add3586 to i64
  %mul3588 = mul i64 %conv3587, 8
  br label %cond.end.3598

cond.false.3589:                                  ; preds = %cond.false.3573
  %716 = load i64, i64* %fun, align 8
  %call3590 = call %struct.Lisp_Subr* @XSUBR(i64 %716)
  %max_args3591 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3590, i32 0, i32 3
  %717 = load i16, i16* %max_args3591, align 2
  %conv3592 = sext i16 %717 to i32
  %add3593 = add nsw i32 1, %conv3592
  %conv3594 = sext i32 %add3593 to i64
  %mul3595 = mul i64 %conv3594, 8
  %sub3596 = sub i64 %mul3595, -9223372036854775808
  %add3597 = add nsw i64 %sub3596, -9223372036854775808
  br label %cond.end.3598

cond.end.3598:                                    ; preds = %cond.false.3589, %cond.true.3582
  %cond3599 = phi i64 [ %mul3588, %cond.true.3582 ], [ %add3597, %cond.false.3589 ]
  store i64 %cond3599, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.3603, label %lor.lhs.false.3600

lor.lhs.false.3600:                               ; preds = %cond.end.3598, %cond.end.3571, %cond.end.3264, %cond.end.3237, %cond.end.2900, %cond.end.2873, %cond.end.2566, %cond.end.2539, %cond.end.2200, %cond.end.2175, %cond.end.1872, %cond.end.1847, %cond.end.1542, %cond.end.1507, %cond.end.1194, %cond.end.1159, %cond.end.788, %cond.end.753, %cond.end.440, %cond.end.405
  %718 = load i64, i64* %alloca_nbytes, align 8
  %cmp3601 = icmp ult i64 -1, %718
  br i1 %cmp3601, label %if.then.3603, label %if.else.3604

if.then.3603:                                     ; preds = %lor.lhs.false.3600, %cond.end.3598, %cond.end.3571, %cond.end.3264, %cond.end.3237, %cond.end.2900, %cond.end.2873, %cond.end.2566, %cond.end.2539, %cond.end.2200, %cond.end.2175, %cond.end.1872, %cond.end.1847, %cond.end.1542, %cond.end.1507, %cond.end.1194, %cond.end.1159, %cond.end.788, %cond.end.753, %cond.end.440, %cond.end.405
  call void @memory_full(i64 -1) #8
  unreachable

if.else.3604:                                     ; preds = %lor.lhs.false.3600
  %719 = load i64, i64* %alloca_nbytes, align 8
  %720 = load i64, i64* %sa_avail, align 8
  %cmp3605 = icmp sle i64 %719, %720
  br i1 %cmp3605, label %if.then.3607, label %if.else.3609

if.then.3607:                                     ; preds = %if.else.3604
  %721 = load i64, i64* %alloca_nbytes, align 8
  %722 = load i64, i64* %sa_avail, align 8
  %sub3608 = sub nsw i64 %722, %721
  store i64 %sub3608, i64* %sa_avail, align 8
  %723 = load i64, i64* %alloca_nbytes, align 8
  %724 = alloca i8, i64 %723
  %725 = bitcast i8* %724 to i64*
  store i64* %725, i64** %funcall_args, align 8
  br label %if.end.3617

if.else.3609:                                     ; preds = %if.else.3604
  %726 = load i64, i64* %alloca_nbytes, align 8
  %call3610 = call noalias i8* @xmalloc(i64 %726)
  %727 = bitcast i8* %call3610 to i64*
  store i64* %727, i64** %funcall_args, align 8
  %728 = load i64*, i64** %funcall_args, align 8
  %729 = load i64, i64* %fun, align 8
  %call3611 = call %struct.Lisp_Subr* @XSUBR(i64 %729)
  %max_args3612 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3611, i32 0, i32 3
  %730 = load i16, i16* %max_args3612, align 2
  %conv3613 = sext i16 %730 to i32
  %add3614 = add nsw i32 1, %conv3613
  %conv3615 = sext i32 %add3614 to i64
  %call3616 = call i64 @make_save_memory(i64* %728, i64 %conv3615)
  store i64 %call3616, i64* %arg_, align 8
  store i8 1, i8* %sa_must_free, align 1
  %731 = load i64, i64* %arg_, align 8
  call void @record_unwind_protect(void (i64)* @free_save_value, i64 %731)
  br label %if.end.3617

if.end.3617:                                      ; preds = %if.else.3609, %if.then.3607
  br label %if.end.3618

if.end.3618:                                      ; preds = %if.end.3617
  br label %do.end

do.end:                                           ; preds = %if.end.3618
  %732 = load i64*, i64** %funcall_args, align 8
  %733 = load i64, i64* %numargs, align 8
  %add.ptr3619 = getelementptr inbounds i64, i64* %732, i64 %733
  %add.ptr3620 = getelementptr inbounds i64, i64* %add.ptr3619, i64 1
  %734 = bitcast i64* %add.ptr3620 to i8*
  %735 = load i64, i64* %fun, align 8
  %call3621 = call %struct.Lisp_Subr* @XSUBR(i64 %735)
  %max_args3622 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3621, i32 0, i32 3
  %736 = load i16, i16* %max_args3622, align 2
  %conv3623 = sext i16 %736 to i64
  %737 = load i64, i64* %numargs, align 8
  %sub3624 = sub nsw i64 %conv3623, %737
  %mul3625 = mul nsw i64 %sub3624, 8
  call void @memclear(i8* %734, i64 %mul3625)
  %738 = load i64, i64* %fun, align 8
  %call3626 = call %struct.Lisp_Subr* @XSUBR(i64 %738)
  %max_args3627 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call3626, i32 0, i32 3
  %739 = load i16, i16* %max_args3627, align 2
  %conv3628 = sext i16 %739 to i32
  %add3629 = add nsw i32 1, %conv3628
  %conv3630 = sext i32 %add3629 to i64
  store i64 %conv3630, i64* %funcall_nargs, align 8
  br label %if.end.6165

if.else.3631:                                     ; preds = %land.lhs.true.41, %land.lhs.true.36, %if.end.33
  br label %do.body.3632

do.body.3632:                                     ; preds = %if.else.3631
  br i1 false, label %cond.true.3634, label %cond.false.4186

cond.true.3634:                                   ; preds = %do.body.3632
  br i1 false, label %cond.true.3635, label %cond.false.3937

cond.true.3635:                                   ; preds = %cond.true.3634
  %740 = load i64, i64* %numargs, align 8
  %add3636 = add nsw i64 1, %740
  %conv3637 = trunc i64 %add3636 to i8
  %conv3638 = sext i8 %conv3637 to i32
  %add3639 = add nsw i32 0, %conv3638
  %mul3640 = mul nsw i32 0, %add3639
  %sub3641 = sub nsw i32 %mul3640, 1
  %cmp3642 = icmp slt i32 %sub3641, 0
  br i1 %cmp3642, label %cond.true.3644, label %cond.false.3666

cond.true.3644:                                   ; preds = %cond.true.3635
  %741 = load i64, i64* %numargs, align 8
  %add3645 = add nsw i64 1, %741
  %conv3646 = trunc i64 %add3645 to i8
  %conv3647 = sext i8 %conv3646 to i32
  %add3648 = add nsw i32 0, %conv3647
  %mul3649 = mul nsw i32 0, %add3648
  %add3650 = add nsw i32 %mul3649, 0
  %neg3651 = xor i32 %add3650, -1
  %cmp3652 = icmp eq i32 %neg3651, -1
  %conv3653 = zext i1 %cmp3652 to i32
  %sub3654 = sub nsw i32 0, %conv3653
  %742 = load i64, i64* %numargs, align 8
  %add3655 = add nsw i64 1, %742
  %conv3656 = trunc i64 %add3655 to i8
  %conv3657 = sext i8 %conv3656 to i32
  %add3658 = add nsw i32 0, %conv3657
  %mul3659 = mul nsw i32 0, %add3658
  %add3660 = add nsw i32 %mul3659, 1
  %shl3661 = shl i32 %add3660, 30
  %sub3662 = sub nsw i32 %shl3661, 1
  %mul3663 = mul nsw i32 %sub3662, 2
  %add3664 = add nsw i32 %mul3663, 1
  %sub3665 = sub nsw i32 %sub3654, %add3664
  br label %cond.end.3673

cond.false.3666:                                  ; preds = %cond.true.3635
  %743 = load i64, i64* %numargs, align 8
  %add3667 = add nsw i64 1, %743
  %conv3668 = trunc i64 %add3667 to i8
  %conv3669 = sext i8 %conv3668 to i32
  %add3670 = add nsw i32 0, %conv3669
  %mul3671 = mul nsw i32 0, %add3670
  %add3672 = add nsw i32 %mul3671, 0
  br label %cond.end.3673

cond.end.3673:                                    ; preds = %cond.false.3666, %cond.true.3644
  %cond3674 = phi i32 [ %sub3665, %cond.true.3644 ], [ %add3672, %cond.false.3666 ]
  %cmp3675 = icmp eq i32 %cond3674, 0
  br i1 %cmp3675, label %land.lhs.true.3677, label %lor.lhs.false.3683

land.lhs.true.3677:                               ; preds = %cond.end.3673
  %744 = load i64, i64* %numargs, align 8
  %add3678 = add nsw i64 1, %744
  %conv3679 = trunc i64 %add3678 to i8
  %conv3680 = sext i8 %conv3679 to i32
  %cmp3681 = icmp slt i32 %conv3680, 0
  br i1 %cmp3681, label %cond.true.3885, label %lor.lhs.false.3683

lor.lhs.false.3683:                               ; preds = %land.lhs.true.3677, %cond.end.3673
  br i1 false, label %cond.true.3684, label %cond.false.3773

cond.true.3684:                                   ; preds = %lor.lhs.false.3683
  %745 = load i64, i64* %numargs, align 8
  %add3685 = add nsw i64 1, %745
  %conv3686 = trunc i64 %add3685 to i8
  %conv3687 = sext i8 %conv3686 to i32
  %cmp3688 = icmp slt i32 %conv3687, 0
  br i1 %cmp3688, label %cond.true.3690, label %cond.false.3725

cond.true.3690:                                   ; preds = %cond.true.3684
  %746 = load i64, i64* %numargs, align 8
  %add3691 = add nsw i64 1, %746
  %conv3692 = trunc i64 %add3691 to i8
  %conv3693 = sext i8 %conv3692 to i32
  %747 = load i64, i64* %numargs, align 8
  %add3694 = add nsw i64 1, %747
  %conv3695 = trunc i64 %add3694 to i8
  %conv3696 = sext i8 %conv3695 to i32
  %add3697 = add nsw i32 0, %conv3696
  %mul3698 = mul nsw i32 0, %add3697
  %sub3699 = sub nsw i32 %mul3698, 1
  %cmp3700 = icmp slt i32 %sub3699, 0
  br i1 %cmp3700, label %cond.true.3702, label %cond.false.3713

cond.true.3702:                                   ; preds = %cond.true.3690
  %748 = load i64, i64* %numargs, align 8
  %add3703 = add nsw i64 1, %748
  %conv3704 = trunc i64 %add3703 to i8
  %conv3705 = sext i8 %conv3704 to i32
  %add3706 = add nsw i32 0, %conv3705
  %mul3707 = mul nsw i32 0, %add3706
  %add3708 = add nsw i32 %mul3707, 1
  %shl3709 = shl i32 %add3708, 30
  %sub3710 = sub nsw i32 %shl3709, 1
  %mul3711 = mul nsw i32 %sub3710, 2
  %add3712 = add nsw i32 %mul3711, 1
  br label %cond.end.3720

cond.false.3713:                                  ; preds = %cond.true.3690
  %749 = load i64, i64* %numargs, align 8
  %add3714 = add nsw i64 1, %749
  %conv3715 = trunc i64 %add3714 to i8
  %conv3716 = sext i8 %conv3715 to i32
  %add3717 = add nsw i32 0, %conv3716
  %mul3718 = mul nsw i32 0, %add3717
  %sub3719 = sub nsw i32 %mul3718, 1
  br label %cond.end.3720

cond.end.3720:                                    ; preds = %cond.false.3713, %cond.true.3702
  %cond3721 = phi i32 [ %add3712, %cond.true.3702 ], [ %sub3719, %cond.false.3713 ]
  %div3722 = sdiv i32 %cond3721, 8
  %cmp3723 = icmp slt i32 %conv3693, %div3722
  br i1 %cmp3723, label %cond.true.3885, label %lor.lhs.false.3862

cond.false.3725:                                  ; preds = %cond.true.3684
  br i1 false, label %cond.true.3726, label %cond.false.3727

cond.true.3726:                                   ; preds = %cond.false.3725
  br i1 false, label %cond.true.3885, label %lor.lhs.false.3862

cond.false.3727:                                  ; preds = %cond.false.3725
  %750 = load i64, i64* %numargs, align 8
  %add3728 = add nsw i64 1, %750
  %conv3729 = trunc i64 %add3728 to i8
  %conv3730 = sext i8 %conv3729 to i32
  %add3731 = add nsw i32 0, %conv3730
  %mul3732 = mul nsw i32 0, %add3731
  %sub3733 = sub nsw i32 %mul3732, 1
  %cmp3734 = icmp slt i32 %sub3733, 0
  br i1 %cmp3734, label %cond.true.3736, label %cond.false.3758

cond.true.3736:                                   ; preds = %cond.false.3727
  %751 = load i64, i64* %numargs, align 8
  %add3737 = add nsw i64 1, %751
  %conv3738 = trunc i64 %add3737 to i8
  %conv3739 = sext i8 %conv3738 to i32
  %add3740 = add nsw i32 0, %conv3739
  %mul3741 = mul nsw i32 0, %add3740
  %add3742 = add nsw i32 %mul3741, 0
  %neg3743 = xor i32 %add3742, -1
  %cmp3744 = icmp eq i32 %neg3743, -1
  %conv3745 = zext i1 %cmp3744 to i32
  %sub3746 = sub nsw i32 0, %conv3745
  %752 = load i64, i64* %numargs, align 8
  %add3747 = add nsw i64 1, %752
  %conv3748 = trunc i64 %add3747 to i8
  %conv3749 = sext i8 %conv3748 to i32
  %add3750 = add nsw i32 0, %conv3749
  %mul3751 = mul nsw i32 0, %add3750
  %add3752 = add nsw i32 %mul3751, 1
  %shl3753 = shl i32 %add3752, 30
  %sub3754 = sub nsw i32 %shl3753, 1
  %mul3755 = mul nsw i32 %sub3754, 2
  %add3756 = add nsw i32 %mul3755, 1
  %sub3757 = sub nsw i32 %sub3746, %add3756
  br label %cond.end.3765

cond.false.3758:                                  ; preds = %cond.false.3727
  %753 = load i64, i64* %numargs, align 8
  %add3759 = add nsw i64 1, %753
  %conv3760 = trunc i64 %add3759 to i8
  %conv3761 = sext i8 %conv3760 to i32
  %add3762 = add nsw i32 0, %conv3761
  %mul3763 = mul nsw i32 0, %add3762
  %add3764 = add nsw i32 %mul3763, 0
  br label %cond.end.3765

cond.end.3765:                                    ; preds = %cond.false.3758, %cond.true.3736
  %cond3766 = phi i32 [ %sub3757, %cond.true.3736 ], [ %add3764, %cond.false.3758 ]
  %div3767 = sdiv i32 %cond3766, 8
  %754 = load i64, i64* %numargs, align 8
  %add3768 = add nsw i64 1, %754
  %conv3769 = trunc i64 %add3768 to i8
  %conv3770 = sext i8 %conv3769 to i32
  %cmp3771 = icmp slt i32 %div3767, %conv3770
  br i1 %cmp3771, label %cond.true.3885, label %lor.lhs.false.3862

cond.false.3773:                                  ; preds = %lor.lhs.false.3683
  br i1 false, label %cond.true.3774, label %cond.false.3775

cond.true.3774:                                   ; preds = %cond.false.3773
  br i1 false, label %cond.true.3885, label %lor.lhs.false.3862

cond.false.3775:                                  ; preds = %cond.false.3773
  %755 = load i64, i64* %numargs, align 8
  %add3776 = add nsw i64 1, %755
  %conv3777 = trunc i64 %add3776 to i8
  %conv3778 = sext i8 %conv3777 to i32
  %cmp3779 = icmp slt i32 %conv3778, 0
  br i1 %cmp3779, label %cond.true.3781, label %cond.false.3827

cond.true.3781:                                   ; preds = %cond.false.3775
  %756 = load i64, i64* %numargs, align 8
  %add3782 = add nsw i64 1, %756
  %conv3783 = trunc i64 %add3782 to i8
  %conv3784 = sext i8 %conv3783 to i32
  %757 = load i64, i64* %numargs, align 8
  %add3785 = add nsw i64 1, %757
  %conv3786 = trunc i64 %add3785 to i8
  %conv3787 = sext i8 %conv3786 to i32
  %add3788 = add nsw i32 0, %conv3787
  %mul3789 = mul nsw i32 0, %add3788
  %sub3790 = sub nsw i32 %mul3789, 1
  %cmp3791 = icmp slt i32 %sub3790, 0
  br i1 %cmp3791, label %cond.true.3793, label %cond.false.3815

cond.true.3793:                                   ; preds = %cond.true.3781
  %758 = load i64, i64* %numargs, align 8
  %add3794 = add nsw i64 1, %758
  %conv3795 = trunc i64 %add3794 to i8
  %conv3796 = sext i8 %conv3795 to i32
  %add3797 = add nsw i32 0, %conv3796
  %mul3798 = mul nsw i32 0, %add3797
  %add3799 = add nsw i32 %mul3798, 0
  %neg3800 = xor i32 %add3799, -1
  %cmp3801 = icmp eq i32 %neg3800, -1
  %conv3802 = zext i1 %cmp3801 to i32
  %sub3803 = sub nsw i32 0, %conv3802
  %759 = load i64, i64* %numargs, align 8
  %add3804 = add nsw i64 1, %759
  %conv3805 = trunc i64 %add3804 to i8
  %conv3806 = sext i8 %conv3805 to i32
  %add3807 = add nsw i32 0, %conv3806
  %mul3808 = mul nsw i32 0, %add3807
  %add3809 = add nsw i32 %mul3808, 1
  %shl3810 = shl i32 %add3809, 30
  %sub3811 = sub nsw i32 %shl3810, 1
  %mul3812 = mul nsw i32 %sub3811, 2
  %add3813 = add nsw i32 %mul3812, 1
  %sub3814 = sub nsw i32 %sub3803, %add3813
  br label %cond.end.3822

cond.false.3815:                                  ; preds = %cond.true.3781
  %760 = load i64, i64* %numargs, align 8
  %add3816 = add nsw i64 1, %760
  %conv3817 = trunc i64 %add3816 to i8
  %conv3818 = sext i8 %conv3817 to i32
  %add3819 = add nsw i32 0, %conv3818
  %mul3820 = mul nsw i32 0, %add3819
  %add3821 = add nsw i32 %mul3820, 0
  br label %cond.end.3822

cond.end.3822:                                    ; preds = %cond.false.3815, %cond.true.3793
  %cond3823 = phi i32 [ %sub3814, %cond.true.3793 ], [ %add3821, %cond.false.3815 ]
  %div3824 = sdiv i32 %cond3823, 8
  %cmp3825 = icmp slt i32 %conv3784, %div3824
  br i1 %cmp3825, label %cond.true.3885, label %lor.lhs.false.3862

cond.false.3827:                                  ; preds = %cond.false.3775
  %761 = load i64, i64* %numargs, align 8
  %add3828 = add nsw i64 1, %761
  %conv3829 = trunc i64 %add3828 to i8
  %conv3830 = sext i8 %conv3829 to i32
  %add3831 = add nsw i32 0, %conv3830
  %mul3832 = mul nsw i32 0, %add3831
  %sub3833 = sub nsw i32 %mul3832, 1
  %cmp3834 = icmp slt i32 %sub3833, 0
  br i1 %cmp3834, label %cond.true.3836, label %cond.false.3847

cond.true.3836:                                   ; preds = %cond.false.3827
  %762 = load i64, i64* %numargs, align 8
  %add3837 = add nsw i64 1, %762
  %conv3838 = trunc i64 %add3837 to i8
  %conv3839 = sext i8 %conv3838 to i32
  %add3840 = add nsw i32 0, %conv3839
  %mul3841 = mul nsw i32 0, %add3840
  %add3842 = add nsw i32 %mul3841, 1
  %shl3843 = shl i32 %add3842, 30
  %sub3844 = sub nsw i32 %shl3843, 1
  %mul3845 = mul nsw i32 %sub3844, 2
  %add3846 = add nsw i32 %mul3845, 1
  br label %cond.end.3854

cond.false.3847:                                  ; preds = %cond.false.3827
  %763 = load i64, i64* %numargs, align 8
  %add3848 = add nsw i64 1, %763
  %conv3849 = trunc i64 %add3848 to i8
  %conv3850 = sext i8 %conv3849 to i32
  %add3851 = add nsw i32 0, %conv3850
  %mul3852 = mul nsw i32 0, %add3851
  %sub3853 = sub nsw i32 %mul3852, 1
  br label %cond.end.3854

cond.end.3854:                                    ; preds = %cond.false.3847, %cond.true.3836
  %cond3855 = phi i32 [ %add3846, %cond.true.3836 ], [ %sub3853, %cond.false.3847 ]
  %div3856 = sdiv i32 %cond3855, 8
  %764 = load i64, i64* %numargs, align 8
  %add3857 = add nsw i64 1, %764
  %conv3858 = trunc i64 %add3857 to i8
  %conv3859 = sext i8 %conv3858 to i32
  %cmp3860 = icmp slt i32 %div3856, %conv3859
  br i1 %cmp3860, label %cond.true.3885, label %lor.lhs.false.3862

lor.lhs.false.3862:                               ; preds = %cond.end.3854, %cond.end.3822, %cond.true.3774, %cond.end.3765, %cond.true.3726, %cond.end.3720
  %765 = load i64, i64* %numargs, align 8
  %add3863 = add nsw i64 1, %765
  %conv3864 = trunc i64 %add3863 to i8
  %conv3865 = sext i8 %conv3864 to i32
  %mul3866 = mul nsw i32 %conv3865, 8
  %mul3867 = mul nsw i32 0, %mul3866
  %sub3868 = sub nsw i32 %mul3867, 1
  %cmp3869 = icmp slt i32 %sub3868, 0
  br i1 %cmp3869, label %land.lhs.true.3871, label %lor.lhs.false.3878

land.lhs.true.3871:                               ; preds = %lor.lhs.false.3862
  %766 = load i64, i64* %numargs, align 8
  %add3872 = add nsw i64 1, %766
  %conv3873 = trunc i64 %add3872 to i8
  %conv3874 = sext i8 %conv3873 to i32
  %mul3875 = mul nsw i32 %conv3874, 8
  %cmp3876 = icmp slt i32 %mul3875, -128
  br i1 %cmp3876, label %cond.true.3885, label %lor.lhs.false.3878

lor.lhs.false.3878:                               ; preds = %land.lhs.true.3871, %lor.lhs.false.3862
  %767 = load i64, i64* %numargs, align 8
  %add3879 = add nsw i64 1, %767
  %conv3880 = trunc i64 %add3879 to i8
  %conv3881 = sext i8 %conv3880 to i32
  %mul3882 = mul nsw i32 %conv3881, 8
  %cmp3883 = icmp slt i32 127, %mul3882
  br i1 %cmp3883, label %cond.true.3885, label %cond.false.3911

cond.true.3885:                                   ; preds = %lor.lhs.false.3878, %land.lhs.true.3871, %cond.end.3854, %cond.end.3822, %cond.true.3774, %cond.end.3765, %cond.true.3726, %cond.end.3720, %land.lhs.true.3677
  %768 = load i64, i64* %numargs, align 8
  %add3886 = add nsw i64 1, %768
  %conv3887 = trunc i64 %add3886 to i8
  %conv3888 = zext i8 %conv3887 to i32
  %mul3889 = mul nsw i32 %conv3888, 8
  %cmp3890 = icmp sle i32 %mul3889, 127
  br i1 %cmp3890, label %cond.true.3892, label %cond.false.3899

cond.true.3892:                                   ; preds = %cond.true.3885
  %769 = load i64, i64* %numargs, align 8
  %add3893 = add nsw i64 1, %769
  %conv3894 = trunc i64 %add3893 to i8
  %conv3895 = zext i8 %conv3894 to i32
  %mul3896 = mul nsw i32 %conv3895, 8
  %conv3897 = trunc i32 %mul3896 to i8
  %conv3898 = sext i8 %conv3897 to i32
  br label %cond.end.3908

cond.false.3899:                                  ; preds = %cond.true.3885
  %770 = load i64, i64* %numargs, align 8
  %add3900 = add nsw i64 1, %770
  %conv3901 = trunc i64 %add3900 to i8
  %conv3902 = zext i8 %conv3901 to i32
  %mul3903 = mul nsw i32 %conv3902, 8
  %sub3904 = sub nsw i32 %mul3903, -128
  %conv3905 = trunc i32 %sub3904 to i8
  %conv3906 = sext i8 %conv3905 to i32
  %add3907 = add nsw i32 %conv3906, -128
  br label %cond.end.3908

cond.end.3908:                                    ; preds = %cond.false.3899, %cond.true.3892
  %cond3909 = phi i32 [ %conv3898, %cond.true.3892 ], [ %add3907, %cond.false.3899 ]
  %conv3910 = sext i32 %cond3909 to i64
  store i64 %conv3910, i64* %alloca_nbytes3633, align 8
  br i1 true, label %if.then.6150, label %lor.lhs.false.6147

cond.false.3911:                                  ; preds = %lor.lhs.false.3878
  %771 = load i64, i64* %numargs, align 8
  %add3912 = add nsw i64 1, %771
  %conv3913 = trunc i64 %add3912 to i8
  %conv3914 = zext i8 %conv3913 to i32
  %mul3915 = mul nsw i32 %conv3914, 8
  %cmp3916 = icmp sle i32 %mul3915, 127
  br i1 %cmp3916, label %cond.true.3918, label %cond.false.3925

cond.true.3918:                                   ; preds = %cond.false.3911
  %772 = load i64, i64* %numargs, align 8
  %add3919 = add nsw i64 1, %772
  %conv3920 = trunc i64 %add3919 to i8
  %conv3921 = zext i8 %conv3920 to i32
  %mul3922 = mul nsw i32 %conv3921, 8
  %conv3923 = trunc i32 %mul3922 to i8
  %conv3924 = sext i8 %conv3923 to i32
  br label %cond.end.3934

cond.false.3925:                                  ; preds = %cond.false.3911
  %773 = load i64, i64* %numargs, align 8
  %add3926 = add nsw i64 1, %773
  %conv3927 = trunc i64 %add3926 to i8
  %conv3928 = zext i8 %conv3927 to i32
  %mul3929 = mul nsw i32 %conv3928, 8
  %sub3930 = sub nsw i32 %mul3929, -128
  %conv3931 = trunc i32 %sub3930 to i8
  %conv3932 = sext i8 %conv3931 to i32
  %add3933 = add nsw i32 %conv3932, -128
  br label %cond.end.3934

cond.end.3934:                                    ; preds = %cond.false.3925, %cond.true.3918
  %cond3935 = phi i32 [ %conv3924, %cond.true.3918 ], [ %add3933, %cond.false.3925 ]
  %conv3936 = sext i32 %cond3935 to i64
  store i64 %conv3936, i64* %alloca_nbytes3633, align 8
  br i1 false, label %if.then.6150, label %lor.lhs.false.6147

cond.false.3937:                                  ; preds = %cond.true.3634
  %774 = load i64, i64* %numargs, align 8
  %add3938 = add nsw i64 1, %774
  %add3939 = add nsw i64 0, %add3938
  %mul3940 = mul nsw i64 0, %add3939
  %sub3941 = sub nsw i64 %mul3940, 1
  %cmp3942 = icmp slt i64 %sub3941, 0
  br i1 %cmp3942, label %cond.true.3944, label %cond.false.3963

cond.true.3944:                                   ; preds = %cond.false.3937
  %775 = load i64, i64* %numargs, align 8
  %add3945 = add nsw i64 1, %775
  %add3946 = add nsw i64 0, %add3945
  %mul3947 = mul nsw i64 0, %add3946
  %add3948 = add nsw i64 %mul3947, 0
  %neg3949 = xor i64 %add3948, -1
  %cmp3950 = icmp eq i64 %neg3949, -1
  %conv3951 = zext i1 %cmp3950 to i32
  %sub3952 = sub nsw i32 0, %conv3951
  %conv3953 = sext i32 %sub3952 to i64
  %776 = load i64, i64* %numargs, align 8
  %add3954 = add nsw i64 1, %776
  %add3955 = add nsw i64 0, %add3954
  %mul3956 = mul nsw i64 0, %add3955
  %add3957 = add nsw i64 %mul3956, 1
  %shl3958 = shl i64 %add3957, 62
  %sub3959 = sub nsw i64 %shl3958, 1
  %mul3960 = mul nsw i64 %sub3959, 2
  %add3961 = add nsw i64 %mul3960, 1
  %sub3962 = sub nsw i64 %conv3953, %add3961
  br label %cond.end.3968

cond.false.3963:                                  ; preds = %cond.false.3937
  %777 = load i64, i64* %numargs, align 8
  %add3964 = add nsw i64 1, %777
  %add3965 = add nsw i64 0, %add3964
  %mul3966 = mul nsw i64 0, %add3965
  %add3967 = add nsw i64 %mul3966, 0
  br label %cond.end.3968

cond.end.3968:                                    ; preds = %cond.false.3963, %cond.true.3944
  %cond3969 = phi i64 [ %sub3962, %cond.true.3944 ], [ %add3967, %cond.false.3963 ]
  %cmp3970 = icmp eq i64 %cond3969, 0
  br i1 %cmp3970, label %land.lhs.true.3972, label %lor.lhs.false.3976

land.lhs.true.3972:                               ; preds = %cond.end.3968
  %778 = load i64, i64* %numargs, align 8
  %add3973 = add nsw i64 1, %778
  %cmp3974 = icmp slt i64 %add3973, 0
  br i1 %cmp3974, label %cond.true.4134, label %lor.lhs.false.3976

lor.lhs.false.3976:                               ; preds = %land.lhs.true.3972, %cond.end.3968
  br i1 false, label %cond.true.3977, label %cond.false.4047

cond.true.3977:                                   ; preds = %lor.lhs.false.3976
  %779 = load i64, i64* %numargs, align 8
  %add3978 = add nsw i64 1, %779
  %cmp3979 = icmp slt i64 %add3978, 0
  br i1 %cmp3979, label %cond.true.3981, label %cond.false.4008

cond.true.3981:                                   ; preds = %cond.true.3977
  %780 = load i64, i64* %numargs, align 8
  %add3982 = add nsw i64 1, %780
  %781 = load i64, i64* %numargs, align 8
  %add3983 = add nsw i64 1, %781
  %add3984 = add nsw i64 0, %add3983
  %mul3985 = mul nsw i64 0, %add3984
  %sub3986 = sub nsw i64 %mul3985, 1
  %cmp3987 = icmp slt i64 %sub3986, 0
  br i1 %cmp3987, label %cond.true.3989, label %cond.false.3998

cond.true.3989:                                   ; preds = %cond.true.3981
  %782 = load i64, i64* %numargs, align 8
  %add3990 = add nsw i64 1, %782
  %add3991 = add nsw i64 0, %add3990
  %mul3992 = mul nsw i64 0, %add3991
  %add3993 = add nsw i64 %mul3992, 1
  %shl3994 = shl i64 %add3993, 62
  %sub3995 = sub nsw i64 %shl3994, 1
  %mul3996 = mul nsw i64 %sub3995, 2
  %add3997 = add nsw i64 %mul3996, 1
  br label %cond.end.4003

cond.false.3998:                                  ; preds = %cond.true.3981
  %783 = load i64, i64* %numargs, align 8
  %add3999 = add nsw i64 1, %783
  %add4000 = add nsw i64 0, %add3999
  %mul4001 = mul nsw i64 0, %add4000
  %sub4002 = sub nsw i64 %mul4001, 1
  br label %cond.end.4003

cond.end.4003:                                    ; preds = %cond.false.3998, %cond.true.3989
  %cond4004 = phi i64 [ %add3997, %cond.true.3989 ], [ %sub4002, %cond.false.3998 ]
  %div4005 = sdiv i64 %cond4004, 8
  %cmp4006 = icmp slt i64 %add3982, %div4005
  br i1 %cmp4006, label %cond.true.4134, label %lor.lhs.false.4117

cond.false.4008:                                  ; preds = %cond.true.3977
  br i1 false, label %cond.true.4009, label %cond.false.4010

cond.true.4009:                                   ; preds = %cond.false.4008
  br i1 false, label %cond.true.4134, label %lor.lhs.false.4117

cond.false.4010:                                  ; preds = %cond.false.4008
  %784 = load i64, i64* %numargs, align 8
  %add4011 = add nsw i64 1, %784
  %add4012 = add nsw i64 0, %add4011
  %mul4013 = mul nsw i64 0, %add4012
  %sub4014 = sub nsw i64 %mul4013, 1
  %cmp4015 = icmp slt i64 %sub4014, 0
  br i1 %cmp4015, label %cond.true.4017, label %cond.false.4036

cond.true.4017:                                   ; preds = %cond.false.4010
  %785 = load i64, i64* %numargs, align 8
  %add4018 = add nsw i64 1, %785
  %add4019 = add nsw i64 0, %add4018
  %mul4020 = mul nsw i64 0, %add4019
  %add4021 = add nsw i64 %mul4020, 0
  %neg4022 = xor i64 %add4021, -1
  %cmp4023 = icmp eq i64 %neg4022, -1
  %conv4024 = zext i1 %cmp4023 to i32
  %sub4025 = sub nsw i32 0, %conv4024
  %conv4026 = sext i32 %sub4025 to i64
  %786 = load i64, i64* %numargs, align 8
  %add4027 = add nsw i64 1, %786
  %add4028 = add nsw i64 0, %add4027
  %mul4029 = mul nsw i64 0, %add4028
  %add4030 = add nsw i64 %mul4029, 1
  %shl4031 = shl i64 %add4030, 62
  %sub4032 = sub nsw i64 %shl4031, 1
  %mul4033 = mul nsw i64 %sub4032, 2
  %add4034 = add nsw i64 %mul4033, 1
  %sub4035 = sub nsw i64 %conv4026, %add4034
  br label %cond.end.4041

cond.false.4036:                                  ; preds = %cond.false.4010
  %787 = load i64, i64* %numargs, align 8
  %add4037 = add nsw i64 1, %787
  %add4038 = add nsw i64 0, %add4037
  %mul4039 = mul nsw i64 0, %add4038
  %add4040 = add nsw i64 %mul4039, 0
  br label %cond.end.4041

cond.end.4041:                                    ; preds = %cond.false.4036, %cond.true.4017
  %cond4042 = phi i64 [ %sub4035, %cond.true.4017 ], [ %add4040, %cond.false.4036 ]
  %div4043 = sdiv i64 %cond4042, 8
  %788 = load i64, i64* %numargs, align 8
  %add4044 = add nsw i64 1, %788
  %cmp4045 = icmp slt i64 %div4043, %add4044
  br i1 %cmp4045, label %cond.true.4134, label %lor.lhs.false.4117

cond.false.4047:                                  ; preds = %lor.lhs.false.3976
  br i1 false, label %cond.true.4048, label %cond.false.4049

cond.true.4048:                                   ; preds = %cond.false.4047
  br i1 false, label %cond.true.4134, label %lor.lhs.false.4117

cond.false.4049:                                  ; preds = %cond.false.4047
  %789 = load i64, i64* %numargs, align 8
  %add4050 = add nsw i64 1, %789
  %cmp4051 = icmp slt i64 %add4050, 0
  br i1 %cmp4051, label %cond.true.4053, label %cond.false.4090

cond.true.4053:                                   ; preds = %cond.false.4049
  %790 = load i64, i64* %numargs, align 8
  %add4054 = add nsw i64 1, %790
  %791 = load i64, i64* %numargs, align 8
  %add4055 = add nsw i64 1, %791
  %add4056 = add nsw i64 0, %add4055
  %mul4057 = mul nsw i64 0, %add4056
  %sub4058 = sub nsw i64 %mul4057, 1
  %cmp4059 = icmp slt i64 %sub4058, 0
  br i1 %cmp4059, label %cond.true.4061, label %cond.false.4080

cond.true.4061:                                   ; preds = %cond.true.4053
  %792 = load i64, i64* %numargs, align 8
  %add4062 = add nsw i64 1, %792
  %add4063 = add nsw i64 0, %add4062
  %mul4064 = mul nsw i64 0, %add4063
  %add4065 = add nsw i64 %mul4064, 0
  %neg4066 = xor i64 %add4065, -1
  %cmp4067 = icmp eq i64 %neg4066, -1
  %conv4068 = zext i1 %cmp4067 to i32
  %sub4069 = sub nsw i32 0, %conv4068
  %conv4070 = sext i32 %sub4069 to i64
  %793 = load i64, i64* %numargs, align 8
  %add4071 = add nsw i64 1, %793
  %add4072 = add nsw i64 0, %add4071
  %mul4073 = mul nsw i64 0, %add4072
  %add4074 = add nsw i64 %mul4073, 1
  %shl4075 = shl i64 %add4074, 62
  %sub4076 = sub nsw i64 %shl4075, 1
  %mul4077 = mul nsw i64 %sub4076, 2
  %add4078 = add nsw i64 %mul4077, 1
  %sub4079 = sub nsw i64 %conv4070, %add4078
  br label %cond.end.4085

cond.false.4080:                                  ; preds = %cond.true.4053
  %794 = load i64, i64* %numargs, align 8
  %add4081 = add nsw i64 1, %794
  %add4082 = add nsw i64 0, %add4081
  %mul4083 = mul nsw i64 0, %add4082
  %add4084 = add nsw i64 %mul4083, 0
  br label %cond.end.4085

cond.end.4085:                                    ; preds = %cond.false.4080, %cond.true.4061
  %cond4086 = phi i64 [ %sub4079, %cond.true.4061 ], [ %add4084, %cond.false.4080 ]
  %div4087 = sdiv i64 %cond4086, 8
  %cmp4088 = icmp slt i64 %add4054, %div4087
  br i1 %cmp4088, label %cond.true.4134, label %lor.lhs.false.4117

cond.false.4090:                                  ; preds = %cond.false.4049
  %795 = load i64, i64* %numargs, align 8
  %add4091 = add nsw i64 1, %795
  %add4092 = add nsw i64 0, %add4091
  %mul4093 = mul nsw i64 0, %add4092
  %sub4094 = sub nsw i64 %mul4093, 1
  %cmp4095 = icmp slt i64 %sub4094, 0
  br i1 %cmp4095, label %cond.true.4097, label %cond.false.4106

cond.true.4097:                                   ; preds = %cond.false.4090
  %796 = load i64, i64* %numargs, align 8
  %add4098 = add nsw i64 1, %796
  %add4099 = add nsw i64 0, %add4098
  %mul4100 = mul nsw i64 0, %add4099
  %add4101 = add nsw i64 %mul4100, 1
  %shl4102 = shl i64 %add4101, 62
  %sub4103 = sub nsw i64 %shl4102, 1
  %mul4104 = mul nsw i64 %sub4103, 2
  %add4105 = add nsw i64 %mul4104, 1
  br label %cond.end.4111

cond.false.4106:                                  ; preds = %cond.false.4090
  %797 = load i64, i64* %numargs, align 8
  %add4107 = add nsw i64 1, %797
  %add4108 = add nsw i64 0, %add4107
  %mul4109 = mul nsw i64 0, %add4108
  %sub4110 = sub nsw i64 %mul4109, 1
  br label %cond.end.4111

cond.end.4111:                                    ; preds = %cond.false.4106, %cond.true.4097
  %cond4112 = phi i64 [ %add4105, %cond.true.4097 ], [ %sub4110, %cond.false.4106 ]
  %div4113 = sdiv i64 %cond4112, 8
  %798 = load i64, i64* %numargs, align 8
  %add4114 = add nsw i64 1, %798
  %cmp4115 = icmp slt i64 %div4113, %add4114
  br i1 %cmp4115, label %cond.true.4134, label %lor.lhs.false.4117

lor.lhs.false.4117:                               ; preds = %cond.end.4111, %cond.end.4085, %cond.true.4048, %cond.end.4041, %cond.true.4009, %cond.end.4003
  %799 = load i64, i64* %numargs, align 8
  %add4118 = add nsw i64 1, %799
  %mul4119 = mul nsw i64 %add4118, 8
  %mul4120 = mul nsw i64 0, %mul4119
  %sub4121 = sub nsw i64 %mul4120, 1
  %cmp4122 = icmp slt i64 %sub4121, 0
  br i1 %cmp4122, label %land.lhs.true.4124, label %lor.lhs.false.4129

land.lhs.true.4124:                               ; preds = %lor.lhs.false.4117
  %800 = load i64, i64* %numargs, align 8
  %add4125 = add nsw i64 1, %800
  %mul4126 = mul nsw i64 %add4125, 8
  %cmp4127 = icmp slt i64 %mul4126, -128
  br i1 %cmp4127, label %cond.true.4134, label %lor.lhs.false.4129

lor.lhs.false.4129:                               ; preds = %land.lhs.true.4124, %lor.lhs.false.4117
  %801 = load i64, i64* %numargs, align 8
  %add4130 = add nsw i64 1, %801
  %mul4131 = mul nsw i64 %add4130, 8
  %cmp4132 = icmp slt i64 127, %mul4131
  br i1 %cmp4132, label %cond.true.4134, label %cond.false.4160

cond.true.4134:                                   ; preds = %lor.lhs.false.4129, %land.lhs.true.4124, %cond.end.4111, %cond.end.4085, %cond.true.4048, %cond.end.4041, %cond.true.4009, %cond.end.4003, %land.lhs.true.3972
  %802 = load i64, i64* %numargs, align 8
  %add4135 = add nsw i64 1, %802
  %conv4136 = trunc i64 %add4135 to i8
  %conv4137 = zext i8 %conv4136 to i32
  %mul4138 = mul nsw i32 %conv4137, 8
  %cmp4139 = icmp sle i32 %mul4138, 127
  br i1 %cmp4139, label %cond.true.4141, label %cond.false.4148

cond.true.4141:                                   ; preds = %cond.true.4134
  %803 = load i64, i64* %numargs, align 8
  %add4142 = add nsw i64 1, %803
  %conv4143 = trunc i64 %add4142 to i8
  %conv4144 = zext i8 %conv4143 to i32
  %mul4145 = mul nsw i32 %conv4144, 8
  %conv4146 = trunc i32 %mul4145 to i8
  %conv4147 = sext i8 %conv4146 to i32
  br label %cond.end.4157

cond.false.4148:                                  ; preds = %cond.true.4134
  %804 = load i64, i64* %numargs, align 8
  %add4149 = add nsw i64 1, %804
  %conv4150 = trunc i64 %add4149 to i8
  %conv4151 = zext i8 %conv4150 to i32
  %mul4152 = mul nsw i32 %conv4151, 8
  %sub4153 = sub nsw i32 %mul4152, -128
  %conv4154 = trunc i32 %sub4153 to i8
  %conv4155 = sext i8 %conv4154 to i32
  %add4156 = add nsw i32 %conv4155, -128
  br label %cond.end.4157

cond.end.4157:                                    ; preds = %cond.false.4148, %cond.true.4141
  %cond4158 = phi i32 [ %conv4147, %cond.true.4141 ], [ %add4156, %cond.false.4148 ]
  %conv4159 = sext i32 %cond4158 to i64
  store i64 %conv4159, i64* %alloca_nbytes3633, align 8
  br i1 true, label %if.then.6150, label %lor.lhs.false.6147

cond.false.4160:                                  ; preds = %lor.lhs.false.4129
  %805 = load i64, i64* %numargs, align 8
  %add4161 = add nsw i64 1, %805
  %conv4162 = trunc i64 %add4161 to i8
  %conv4163 = zext i8 %conv4162 to i32
  %mul4164 = mul nsw i32 %conv4163, 8
  %cmp4165 = icmp sle i32 %mul4164, 127
  br i1 %cmp4165, label %cond.true.4167, label %cond.false.4174

cond.true.4167:                                   ; preds = %cond.false.4160
  %806 = load i64, i64* %numargs, align 8
  %add4168 = add nsw i64 1, %806
  %conv4169 = trunc i64 %add4168 to i8
  %conv4170 = zext i8 %conv4169 to i32
  %mul4171 = mul nsw i32 %conv4170, 8
  %conv4172 = trunc i32 %mul4171 to i8
  %conv4173 = sext i8 %conv4172 to i32
  br label %cond.end.4183

cond.false.4174:                                  ; preds = %cond.false.4160
  %807 = load i64, i64* %numargs, align 8
  %add4175 = add nsw i64 1, %807
  %conv4176 = trunc i64 %add4175 to i8
  %conv4177 = zext i8 %conv4176 to i32
  %mul4178 = mul nsw i32 %conv4177, 8
  %sub4179 = sub nsw i32 %mul4178, -128
  %conv4180 = trunc i32 %sub4179 to i8
  %conv4181 = sext i8 %conv4180 to i32
  %add4182 = add nsw i32 %conv4181, -128
  br label %cond.end.4183

cond.end.4183:                                    ; preds = %cond.false.4174, %cond.true.4167
  %cond4184 = phi i32 [ %conv4173, %cond.true.4167 ], [ %add4182, %cond.false.4174 ]
  %conv4185 = sext i32 %cond4184 to i64
  store i64 %conv4185, i64* %alloca_nbytes3633, align 8
  br i1 false, label %if.then.6150, label %lor.lhs.false.6147

cond.false.4186:                                  ; preds = %do.body.3632
  br i1 false, label %cond.true.4187, label %cond.false.4739

cond.true.4187:                                   ; preds = %cond.false.4186
  br i1 false, label %cond.true.4188, label %cond.false.4490

cond.true.4188:                                   ; preds = %cond.true.4187
  %808 = load i64, i64* %numargs, align 8
  %add4189 = add nsw i64 1, %808
  %conv4190 = trunc i64 %add4189 to i16
  %conv4191 = sext i16 %conv4190 to i32
  %add4192 = add nsw i32 0, %conv4191
  %mul4193 = mul nsw i32 0, %add4192
  %sub4194 = sub nsw i32 %mul4193, 1
  %cmp4195 = icmp slt i32 %sub4194, 0
  br i1 %cmp4195, label %cond.true.4197, label %cond.false.4219

cond.true.4197:                                   ; preds = %cond.true.4188
  %809 = load i64, i64* %numargs, align 8
  %add4198 = add nsw i64 1, %809
  %conv4199 = trunc i64 %add4198 to i16
  %conv4200 = sext i16 %conv4199 to i32
  %add4201 = add nsw i32 0, %conv4200
  %mul4202 = mul nsw i32 0, %add4201
  %add4203 = add nsw i32 %mul4202, 0
  %neg4204 = xor i32 %add4203, -1
  %cmp4205 = icmp eq i32 %neg4204, -1
  %conv4206 = zext i1 %cmp4205 to i32
  %sub4207 = sub nsw i32 0, %conv4206
  %810 = load i64, i64* %numargs, align 8
  %add4208 = add nsw i64 1, %810
  %conv4209 = trunc i64 %add4208 to i16
  %conv4210 = sext i16 %conv4209 to i32
  %add4211 = add nsw i32 0, %conv4210
  %mul4212 = mul nsw i32 0, %add4211
  %add4213 = add nsw i32 %mul4212, 1
  %shl4214 = shl i32 %add4213, 30
  %sub4215 = sub nsw i32 %shl4214, 1
  %mul4216 = mul nsw i32 %sub4215, 2
  %add4217 = add nsw i32 %mul4216, 1
  %sub4218 = sub nsw i32 %sub4207, %add4217
  br label %cond.end.4226

cond.false.4219:                                  ; preds = %cond.true.4188
  %811 = load i64, i64* %numargs, align 8
  %add4220 = add nsw i64 1, %811
  %conv4221 = trunc i64 %add4220 to i16
  %conv4222 = sext i16 %conv4221 to i32
  %add4223 = add nsw i32 0, %conv4222
  %mul4224 = mul nsw i32 0, %add4223
  %add4225 = add nsw i32 %mul4224, 0
  br label %cond.end.4226

cond.end.4226:                                    ; preds = %cond.false.4219, %cond.true.4197
  %cond4227 = phi i32 [ %sub4218, %cond.true.4197 ], [ %add4225, %cond.false.4219 ]
  %cmp4228 = icmp eq i32 %cond4227, 0
  br i1 %cmp4228, label %land.lhs.true.4230, label %lor.lhs.false.4236

land.lhs.true.4230:                               ; preds = %cond.end.4226
  %812 = load i64, i64* %numargs, align 8
  %add4231 = add nsw i64 1, %812
  %conv4232 = trunc i64 %add4231 to i16
  %conv4233 = sext i16 %conv4232 to i32
  %cmp4234 = icmp slt i32 %conv4233, 0
  br i1 %cmp4234, label %cond.true.4438, label %lor.lhs.false.4236

lor.lhs.false.4236:                               ; preds = %land.lhs.true.4230, %cond.end.4226
  br i1 false, label %cond.true.4237, label %cond.false.4326

cond.true.4237:                                   ; preds = %lor.lhs.false.4236
  %813 = load i64, i64* %numargs, align 8
  %add4238 = add nsw i64 1, %813
  %conv4239 = trunc i64 %add4238 to i16
  %conv4240 = sext i16 %conv4239 to i32
  %cmp4241 = icmp slt i32 %conv4240, 0
  br i1 %cmp4241, label %cond.true.4243, label %cond.false.4278

cond.true.4243:                                   ; preds = %cond.true.4237
  %814 = load i64, i64* %numargs, align 8
  %add4244 = add nsw i64 1, %814
  %conv4245 = trunc i64 %add4244 to i16
  %conv4246 = sext i16 %conv4245 to i32
  %815 = load i64, i64* %numargs, align 8
  %add4247 = add nsw i64 1, %815
  %conv4248 = trunc i64 %add4247 to i16
  %conv4249 = sext i16 %conv4248 to i32
  %add4250 = add nsw i32 0, %conv4249
  %mul4251 = mul nsw i32 0, %add4250
  %sub4252 = sub nsw i32 %mul4251, 1
  %cmp4253 = icmp slt i32 %sub4252, 0
  br i1 %cmp4253, label %cond.true.4255, label %cond.false.4266

cond.true.4255:                                   ; preds = %cond.true.4243
  %816 = load i64, i64* %numargs, align 8
  %add4256 = add nsw i64 1, %816
  %conv4257 = trunc i64 %add4256 to i16
  %conv4258 = sext i16 %conv4257 to i32
  %add4259 = add nsw i32 0, %conv4258
  %mul4260 = mul nsw i32 0, %add4259
  %add4261 = add nsw i32 %mul4260, 1
  %shl4262 = shl i32 %add4261, 30
  %sub4263 = sub nsw i32 %shl4262, 1
  %mul4264 = mul nsw i32 %sub4263, 2
  %add4265 = add nsw i32 %mul4264, 1
  br label %cond.end.4273

cond.false.4266:                                  ; preds = %cond.true.4243
  %817 = load i64, i64* %numargs, align 8
  %add4267 = add nsw i64 1, %817
  %conv4268 = trunc i64 %add4267 to i16
  %conv4269 = sext i16 %conv4268 to i32
  %add4270 = add nsw i32 0, %conv4269
  %mul4271 = mul nsw i32 0, %add4270
  %sub4272 = sub nsw i32 %mul4271, 1
  br label %cond.end.4273

cond.end.4273:                                    ; preds = %cond.false.4266, %cond.true.4255
  %cond4274 = phi i32 [ %add4265, %cond.true.4255 ], [ %sub4272, %cond.false.4266 ]
  %div4275 = sdiv i32 %cond4274, 8
  %cmp4276 = icmp slt i32 %conv4246, %div4275
  br i1 %cmp4276, label %cond.true.4438, label %lor.lhs.false.4415

cond.false.4278:                                  ; preds = %cond.true.4237
  br i1 false, label %cond.true.4279, label %cond.false.4280

cond.true.4279:                                   ; preds = %cond.false.4278
  br i1 false, label %cond.true.4438, label %lor.lhs.false.4415

cond.false.4280:                                  ; preds = %cond.false.4278
  %818 = load i64, i64* %numargs, align 8
  %add4281 = add nsw i64 1, %818
  %conv4282 = trunc i64 %add4281 to i16
  %conv4283 = sext i16 %conv4282 to i32
  %add4284 = add nsw i32 0, %conv4283
  %mul4285 = mul nsw i32 0, %add4284
  %sub4286 = sub nsw i32 %mul4285, 1
  %cmp4287 = icmp slt i32 %sub4286, 0
  br i1 %cmp4287, label %cond.true.4289, label %cond.false.4311

cond.true.4289:                                   ; preds = %cond.false.4280
  %819 = load i64, i64* %numargs, align 8
  %add4290 = add nsw i64 1, %819
  %conv4291 = trunc i64 %add4290 to i16
  %conv4292 = sext i16 %conv4291 to i32
  %add4293 = add nsw i32 0, %conv4292
  %mul4294 = mul nsw i32 0, %add4293
  %add4295 = add nsw i32 %mul4294, 0
  %neg4296 = xor i32 %add4295, -1
  %cmp4297 = icmp eq i32 %neg4296, -1
  %conv4298 = zext i1 %cmp4297 to i32
  %sub4299 = sub nsw i32 0, %conv4298
  %820 = load i64, i64* %numargs, align 8
  %add4300 = add nsw i64 1, %820
  %conv4301 = trunc i64 %add4300 to i16
  %conv4302 = sext i16 %conv4301 to i32
  %add4303 = add nsw i32 0, %conv4302
  %mul4304 = mul nsw i32 0, %add4303
  %add4305 = add nsw i32 %mul4304, 1
  %shl4306 = shl i32 %add4305, 30
  %sub4307 = sub nsw i32 %shl4306, 1
  %mul4308 = mul nsw i32 %sub4307, 2
  %add4309 = add nsw i32 %mul4308, 1
  %sub4310 = sub nsw i32 %sub4299, %add4309
  br label %cond.end.4318

cond.false.4311:                                  ; preds = %cond.false.4280
  %821 = load i64, i64* %numargs, align 8
  %add4312 = add nsw i64 1, %821
  %conv4313 = trunc i64 %add4312 to i16
  %conv4314 = sext i16 %conv4313 to i32
  %add4315 = add nsw i32 0, %conv4314
  %mul4316 = mul nsw i32 0, %add4315
  %add4317 = add nsw i32 %mul4316, 0
  br label %cond.end.4318

cond.end.4318:                                    ; preds = %cond.false.4311, %cond.true.4289
  %cond4319 = phi i32 [ %sub4310, %cond.true.4289 ], [ %add4317, %cond.false.4311 ]
  %div4320 = sdiv i32 %cond4319, 8
  %822 = load i64, i64* %numargs, align 8
  %add4321 = add nsw i64 1, %822
  %conv4322 = trunc i64 %add4321 to i16
  %conv4323 = sext i16 %conv4322 to i32
  %cmp4324 = icmp slt i32 %div4320, %conv4323
  br i1 %cmp4324, label %cond.true.4438, label %lor.lhs.false.4415

cond.false.4326:                                  ; preds = %lor.lhs.false.4236
  br i1 false, label %cond.true.4327, label %cond.false.4328

cond.true.4327:                                   ; preds = %cond.false.4326
  br i1 false, label %cond.true.4438, label %lor.lhs.false.4415

cond.false.4328:                                  ; preds = %cond.false.4326
  %823 = load i64, i64* %numargs, align 8
  %add4329 = add nsw i64 1, %823
  %conv4330 = trunc i64 %add4329 to i16
  %conv4331 = sext i16 %conv4330 to i32
  %cmp4332 = icmp slt i32 %conv4331, 0
  br i1 %cmp4332, label %cond.true.4334, label %cond.false.4380

cond.true.4334:                                   ; preds = %cond.false.4328
  %824 = load i64, i64* %numargs, align 8
  %add4335 = add nsw i64 1, %824
  %conv4336 = trunc i64 %add4335 to i16
  %conv4337 = sext i16 %conv4336 to i32
  %825 = load i64, i64* %numargs, align 8
  %add4338 = add nsw i64 1, %825
  %conv4339 = trunc i64 %add4338 to i16
  %conv4340 = sext i16 %conv4339 to i32
  %add4341 = add nsw i32 0, %conv4340
  %mul4342 = mul nsw i32 0, %add4341
  %sub4343 = sub nsw i32 %mul4342, 1
  %cmp4344 = icmp slt i32 %sub4343, 0
  br i1 %cmp4344, label %cond.true.4346, label %cond.false.4368

cond.true.4346:                                   ; preds = %cond.true.4334
  %826 = load i64, i64* %numargs, align 8
  %add4347 = add nsw i64 1, %826
  %conv4348 = trunc i64 %add4347 to i16
  %conv4349 = sext i16 %conv4348 to i32
  %add4350 = add nsw i32 0, %conv4349
  %mul4351 = mul nsw i32 0, %add4350
  %add4352 = add nsw i32 %mul4351, 0
  %neg4353 = xor i32 %add4352, -1
  %cmp4354 = icmp eq i32 %neg4353, -1
  %conv4355 = zext i1 %cmp4354 to i32
  %sub4356 = sub nsw i32 0, %conv4355
  %827 = load i64, i64* %numargs, align 8
  %add4357 = add nsw i64 1, %827
  %conv4358 = trunc i64 %add4357 to i16
  %conv4359 = sext i16 %conv4358 to i32
  %add4360 = add nsw i32 0, %conv4359
  %mul4361 = mul nsw i32 0, %add4360
  %add4362 = add nsw i32 %mul4361, 1
  %shl4363 = shl i32 %add4362, 30
  %sub4364 = sub nsw i32 %shl4363, 1
  %mul4365 = mul nsw i32 %sub4364, 2
  %add4366 = add nsw i32 %mul4365, 1
  %sub4367 = sub nsw i32 %sub4356, %add4366
  br label %cond.end.4375

cond.false.4368:                                  ; preds = %cond.true.4334
  %828 = load i64, i64* %numargs, align 8
  %add4369 = add nsw i64 1, %828
  %conv4370 = trunc i64 %add4369 to i16
  %conv4371 = sext i16 %conv4370 to i32
  %add4372 = add nsw i32 0, %conv4371
  %mul4373 = mul nsw i32 0, %add4372
  %add4374 = add nsw i32 %mul4373, 0
  br label %cond.end.4375

cond.end.4375:                                    ; preds = %cond.false.4368, %cond.true.4346
  %cond4376 = phi i32 [ %sub4367, %cond.true.4346 ], [ %add4374, %cond.false.4368 ]
  %div4377 = sdiv i32 %cond4376, 8
  %cmp4378 = icmp slt i32 %conv4337, %div4377
  br i1 %cmp4378, label %cond.true.4438, label %lor.lhs.false.4415

cond.false.4380:                                  ; preds = %cond.false.4328
  %829 = load i64, i64* %numargs, align 8
  %add4381 = add nsw i64 1, %829
  %conv4382 = trunc i64 %add4381 to i16
  %conv4383 = sext i16 %conv4382 to i32
  %add4384 = add nsw i32 0, %conv4383
  %mul4385 = mul nsw i32 0, %add4384
  %sub4386 = sub nsw i32 %mul4385, 1
  %cmp4387 = icmp slt i32 %sub4386, 0
  br i1 %cmp4387, label %cond.true.4389, label %cond.false.4400

cond.true.4389:                                   ; preds = %cond.false.4380
  %830 = load i64, i64* %numargs, align 8
  %add4390 = add nsw i64 1, %830
  %conv4391 = trunc i64 %add4390 to i16
  %conv4392 = sext i16 %conv4391 to i32
  %add4393 = add nsw i32 0, %conv4392
  %mul4394 = mul nsw i32 0, %add4393
  %add4395 = add nsw i32 %mul4394, 1
  %shl4396 = shl i32 %add4395, 30
  %sub4397 = sub nsw i32 %shl4396, 1
  %mul4398 = mul nsw i32 %sub4397, 2
  %add4399 = add nsw i32 %mul4398, 1
  br label %cond.end.4407

cond.false.4400:                                  ; preds = %cond.false.4380
  %831 = load i64, i64* %numargs, align 8
  %add4401 = add nsw i64 1, %831
  %conv4402 = trunc i64 %add4401 to i16
  %conv4403 = sext i16 %conv4402 to i32
  %add4404 = add nsw i32 0, %conv4403
  %mul4405 = mul nsw i32 0, %add4404
  %sub4406 = sub nsw i32 %mul4405, 1
  br label %cond.end.4407

cond.end.4407:                                    ; preds = %cond.false.4400, %cond.true.4389
  %cond4408 = phi i32 [ %add4399, %cond.true.4389 ], [ %sub4406, %cond.false.4400 ]
  %div4409 = sdiv i32 %cond4408, 8
  %832 = load i64, i64* %numargs, align 8
  %add4410 = add nsw i64 1, %832
  %conv4411 = trunc i64 %add4410 to i16
  %conv4412 = sext i16 %conv4411 to i32
  %cmp4413 = icmp slt i32 %div4409, %conv4412
  br i1 %cmp4413, label %cond.true.4438, label %lor.lhs.false.4415

lor.lhs.false.4415:                               ; preds = %cond.end.4407, %cond.end.4375, %cond.true.4327, %cond.end.4318, %cond.true.4279, %cond.end.4273
  %833 = load i64, i64* %numargs, align 8
  %add4416 = add nsw i64 1, %833
  %conv4417 = trunc i64 %add4416 to i16
  %conv4418 = sext i16 %conv4417 to i32
  %mul4419 = mul nsw i32 %conv4418, 8
  %mul4420 = mul nsw i32 0, %mul4419
  %sub4421 = sub nsw i32 %mul4420, 1
  %cmp4422 = icmp slt i32 %sub4421, 0
  br i1 %cmp4422, label %land.lhs.true.4424, label %lor.lhs.false.4431

land.lhs.true.4424:                               ; preds = %lor.lhs.false.4415
  %834 = load i64, i64* %numargs, align 8
  %add4425 = add nsw i64 1, %834
  %conv4426 = trunc i64 %add4425 to i16
  %conv4427 = sext i16 %conv4426 to i32
  %mul4428 = mul nsw i32 %conv4427, 8
  %cmp4429 = icmp slt i32 %mul4428, -32768
  br i1 %cmp4429, label %cond.true.4438, label %lor.lhs.false.4431

lor.lhs.false.4431:                               ; preds = %land.lhs.true.4424, %lor.lhs.false.4415
  %835 = load i64, i64* %numargs, align 8
  %add4432 = add nsw i64 1, %835
  %conv4433 = trunc i64 %add4432 to i16
  %conv4434 = sext i16 %conv4433 to i32
  %mul4435 = mul nsw i32 %conv4434, 8
  %cmp4436 = icmp slt i32 32767, %mul4435
  br i1 %cmp4436, label %cond.true.4438, label %cond.false.4464

cond.true.4438:                                   ; preds = %lor.lhs.false.4431, %land.lhs.true.4424, %cond.end.4407, %cond.end.4375, %cond.true.4327, %cond.end.4318, %cond.true.4279, %cond.end.4273, %land.lhs.true.4230
  %836 = load i64, i64* %numargs, align 8
  %add4439 = add nsw i64 1, %836
  %conv4440 = trunc i64 %add4439 to i16
  %conv4441 = zext i16 %conv4440 to i32
  %mul4442 = mul nsw i32 %conv4441, 8
  %cmp4443 = icmp sle i32 %mul4442, 32767
  br i1 %cmp4443, label %cond.true.4445, label %cond.false.4452

cond.true.4445:                                   ; preds = %cond.true.4438
  %837 = load i64, i64* %numargs, align 8
  %add4446 = add nsw i64 1, %837
  %conv4447 = trunc i64 %add4446 to i16
  %conv4448 = zext i16 %conv4447 to i32
  %mul4449 = mul nsw i32 %conv4448, 8
  %conv4450 = trunc i32 %mul4449 to i16
  %conv4451 = sext i16 %conv4450 to i32
  br label %cond.end.4461

cond.false.4452:                                  ; preds = %cond.true.4438
  %838 = load i64, i64* %numargs, align 8
  %add4453 = add nsw i64 1, %838
  %conv4454 = trunc i64 %add4453 to i16
  %conv4455 = zext i16 %conv4454 to i32
  %mul4456 = mul nsw i32 %conv4455, 8
  %sub4457 = sub nsw i32 %mul4456, -32768
  %conv4458 = trunc i32 %sub4457 to i16
  %conv4459 = sext i16 %conv4458 to i32
  %add4460 = add nsw i32 %conv4459, -32768
  br label %cond.end.4461

cond.end.4461:                                    ; preds = %cond.false.4452, %cond.true.4445
  %cond4462 = phi i32 [ %conv4451, %cond.true.4445 ], [ %add4460, %cond.false.4452 ]
  %conv4463 = sext i32 %cond4462 to i64
  store i64 %conv4463, i64* %alloca_nbytes3633, align 8
  br i1 true, label %if.then.6150, label %lor.lhs.false.6147

cond.false.4464:                                  ; preds = %lor.lhs.false.4431
  %839 = load i64, i64* %numargs, align 8
  %add4465 = add nsw i64 1, %839
  %conv4466 = trunc i64 %add4465 to i16
  %conv4467 = zext i16 %conv4466 to i32
  %mul4468 = mul nsw i32 %conv4467, 8
  %cmp4469 = icmp sle i32 %mul4468, 32767
  br i1 %cmp4469, label %cond.true.4471, label %cond.false.4478

cond.true.4471:                                   ; preds = %cond.false.4464
  %840 = load i64, i64* %numargs, align 8
  %add4472 = add nsw i64 1, %840
  %conv4473 = trunc i64 %add4472 to i16
  %conv4474 = zext i16 %conv4473 to i32
  %mul4475 = mul nsw i32 %conv4474, 8
  %conv4476 = trunc i32 %mul4475 to i16
  %conv4477 = sext i16 %conv4476 to i32
  br label %cond.end.4487

cond.false.4478:                                  ; preds = %cond.false.4464
  %841 = load i64, i64* %numargs, align 8
  %add4479 = add nsw i64 1, %841
  %conv4480 = trunc i64 %add4479 to i16
  %conv4481 = zext i16 %conv4480 to i32
  %mul4482 = mul nsw i32 %conv4481, 8
  %sub4483 = sub nsw i32 %mul4482, -32768
  %conv4484 = trunc i32 %sub4483 to i16
  %conv4485 = sext i16 %conv4484 to i32
  %add4486 = add nsw i32 %conv4485, -32768
  br label %cond.end.4487

cond.end.4487:                                    ; preds = %cond.false.4478, %cond.true.4471
  %cond4488 = phi i32 [ %conv4477, %cond.true.4471 ], [ %add4486, %cond.false.4478 ]
  %conv4489 = sext i32 %cond4488 to i64
  store i64 %conv4489, i64* %alloca_nbytes3633, align 8
  br i1 false, label %if.then.6150, label %lor.lhs.false.6147

cond.false.4490:                                  ; preds = %cond.true.4187
  %842 = load i64, i64* %numargs, align 8
  %add4491 = add nsw i64 1, %842
  %add4492 = add nsw i64 0, %add4491
  %mul4493 = mul nsw i64 0, %add4492
  %sub4494 = sub nsw i64 %mul4493, 1
  %cmp4495 = icmp slt i64 %sub4494, 0
  br i1 %cmp4495, label %cond.true.4497, label %cond.false.4516

cond.true.4497:                                   ; preds = %cond.false.4490
  %843 = load i64, i64* %numargs, align 8
  %add4498 = add nsw i64 1, %843
  %add4499 = add nsw i64 0, %add4498
  %mul4500 = mul nsw i64 0, %add4499
  %add4501 = add nsw i64 %mul4500, 0
  %neg4502 = xor i64 %add4501, -1
  %cmp4503 = icmp eq i64 %neg4502, -1
  %conv4504 = zext i1 %cmp4503 to i32
  %sub4505 = sub nsw i32 0, %conv4504
  %conv4506 = sext i32 %sub4505 to i64
  %844 = load i64, i64* %numargs, align 8
  %add4507 = add nsw i64 1, %844
  %add4508 = add nsw i64 0, %add4507
  %mul4509 = mul nsw i64 0, %add4508
  %add4510 = add nsw i64 %mul4509, 1
  %shl4511 = shl i64 %add4510, 62
  %sub4512 = sub nsw i64 %shl4511, 1
  %mul4513 = mul nsw i64 %sub4512, 2
  %add4514 = add nsw i64 %mul4513, 1
  %sub4515 = sub nsw i64 %conv4506, %add4514
  br label %cond.end.4521

cond.false.4516:                                  ; preds = %cond.false.4490
  %845 = load i64, i64* %numargs, align 8
  %add4517 = add nsw i64 1, %845
  %add4518 = add nsw i64 0, %add4517
  %mul4519 = mul nsw i64 0, %add4518
  %add4520 = add nsw i64 %mul4519, 0
  br label %cond.end.4521

cond.end.4521:                                    ; preds = %cond.false.4516, %cond.true.4497
  %cond4522 = phi i64 [ %sub4515, %cond.true.4497 ], [ %add4520, %cond.false.4516 ]
  %cmp4523 = icmp eq i64 %cond4522, 0
  br i1 %cmp4523, label %land.lhs.true.4525, label %lor.lhs.false.4529

land.lhs.true.4525:                               ; preds = %cond.end.4521
  %846 = load i64, i64* %numargs, align 8
  %add4526 = add nsw i64 1, %846
  %cmp4527 = icmp slt i64 %add4526, 0
  br i1 %cmp4527, label %cond.true.4687, label %lor.lhs.false.4529

lor.lhs.false.4529:                               ; preds = %land.lhs.true.4525, %cond.end.4521
  br i1 false, label %cond.true.4530, label %cond.false.4600

cond.true.4530:                                   ; preds = %lor.lhs.false.4529
  %847 = load i64, i64* %numargs, align 8
  %add4531 = add nsw i64 1, %847
  %cmp4532 = icmp slt i64 %add4531, 0
  br i1 %cmp4532, label %cond.true.4534, label %cond.false.4561

cond.true.4534:                                   ; preds = %cond.true.4530
  %848 = load i64, i64* %numargs, align 8
  %add4535 = add nsw i64 1, %848
  %849 = load i64, i64* %numargs, align 8
  %add4536 = add nsw i64 1, %849
  %add4537 = add nsw i64 0, %add4536
  %mul4538 = mul nsw i64 0, %add4537
  %sub4539 = sub nsw i64 %mul4538, 1
  %cmp4540 = icmp slt i64 %sub4539, 0
  br i1 %cmp4540, label %cond.true.4542, label %cond.false.4551

cond.true.4542:                                   ; preds = %cond.true.4534
  %850 = load i64, i64* %numargs, align 8
  %add4543 = add nsw i64 1, %850
  %add4544 = add nsw i64 0, %add4543
  %mul4545 = mul nsw i64 0, %add4544
  %add4546 = add nsw i64 %mul4545, 1
  %shl4547 = shl i64 %add4546, 62
  %sub4548 = sub nsw i64 %shl4547, 1
  %mul4549 = mul nsw i64 %sub4548, 2
  %add4550 = add nsw i64 %mul4549, 1
  br label %cond.end.4556

cond.false.4551:                                  ; preds = %cond.true.4534
  %851 = load i64, i64* %numargs, align 8
  %add4552 = add nsw i64 1, %851
  %add4553 = add nsw i64 0, %add4552
  %mul4554 = mul nsw i64 0, %add4553
  %sub4555 = sub nsw i64 %mul4554, 1
  br label %cond.end.4556

cond.end.4556:                                    ; preds = %cond.false.4551, %cond.true.4542
  %cond4557 = phi i64 [ %add4550, %cond.true.4542 ], [ %sub4555, %cond.false.4551 ]
  %div4558 = sdiv i64 %cond4557, 8
  %cmp4559 = icmp slt i64 %add4535, %div4558
  br i1 %cmp4559, label %cond.true.4687, label %lor.lhs.false.4670

cond.false.4561:                                  ; preds = %cond.true.4530
  br i1 false, label %cond.true.4562, label %cond.false.4563

cond.true.4562:                                   ; preds = %cond.false.4561
  br i1 false, label %cond.true.4687, label %lor.lhs.false.4670

cond.false.4563:                                  ; preds = %cond.false.4561
  %852 = load i64, i64* %numargs, align 8
  %add4564 = add nsw i64 1, %852
  %add4565 = add nsw i64 0, %add4564
  %mul4566 = mul nsw i64 0, %add4565
  %sub4567 = sub nsw i64 %mul4566, 1
  %cmp4568 = icmp slt i64 %sub4567, 0
  br i1 %cmp4568, label %cond.true.4570, label %cond.false.4589

cond.true.4570:                                   ; preds = %cond.false.4563
  %853 = load i64, i64* %numargs, align 8
  %add4571 = add nsw i64 1, %853
  %add4572 = add nsw i64 0, %add4571
  %mul4573 = mul nsw i64 0, %add4572
  %add4574 = add nsw i64 %mul4573, 0
  %neg4575 = xor i64 %add4574, -1
  %cmp4576 = icmp eq i64 %neg4575, -1
  %conv4577 = zext i1 %cmp4576 to i32
  %sub4578 = sub nsw i32 0, %conv4577
  %conv4579 = sext i32 %sub4578 to i64
  %854 = load i64, i64* %numargs, align 8
  %add4580 = add nsw i64 1, %854
  %add4581 = add nsw i64 0, %add4580
  %mul4582 = mul nsw i64 0, %add4581
  %add4583 = add nsw i64 %mul4582, 1
  %shl4584 = shl i64 %add4583, 62
  %sub4585 = sub nsw i64 %shl4584, 1
  %mul4586 = mul nsw i64 %sub4585, 2
  %add4587 = add nsw i64 %mul4586, 1
  %sub4588 = sub nsw i64 %conv4579, %add4587
  br label %cond.end.4594

cond.false.4589:                                  ; preds = %cond.false.4563
  %855 = load i64, i64* %numargs, align 8
  %add4590 = add nsw i64 1, %855
  %add4591 = add nsw i64 0, %add4590
  %mul4592 = mul nsw i64 0, %add4591
  %add4593 = add nsw i64 %mul4592, 0
  br label %cond.end.4594

cond.end.4594:                                    ; preds = %cond.false.4589, %cond.true.4570
  %cond4595 = phi i64 [ %sub4588, %cond.true.4570 ], [ %add4593, %cond.false.4589 ]
  %div4596 = sdiv i64 %cond4595, 8
  %856 = load i64, i64* %numargs, align 8
  %add4597 = add nsw i64 1, %856
  %cmp4598 = icmp slt i64 %div4596, %add4597
  br i1 %cmp4598, label %cond.true.4687, label %lor.lhs.false.4670

cond.false.4600:                                  ; preds = %lor.lhs.false.4529
  br i1 false, label %cond.true.4601, label %cond.false.4602

cond.true.4601:                                   ; preds = %cond.false.4600
  br i1 false, label %cond.true.4687, label %lor.lhs.false.4670

cond.false.4602:                                  ; preds = %cond.false.4600
  %857 = load i64, i64* %numargs, align 8
  %add4603 = add nsw i64 1, %857
  %cmp4604 = icmp slt i64 %add4603, 0
  br i1 %cmp4604, label %cond.true.4606, label %cond.false.4643

cond.true.4606:                                   ; preds = %cond.false.4602
  %858 = load i64, i64* %numargs, align 8
  %add4607 = add nsw i64 1, %858
  %859 = load i64, i64* %numargs, align 8
  %add4608 = add nsw i64 1, %859
  %add4609 = add nsw i64 0, %add4608
  %mul4610 = mul nsw i64 0, %add4609
  %sub4611 = sub nsw i64 %mul4610, 1
  %cmp4612 = icmp slt i64 %sub4611, 0
  br i1 %cmp4612, label %cond.true.4614, label %cond.false.4633

cond.true.4614:                                   ; preds = %cond.true.4606
  %860 = load i64, i64* %numargs, align 8
  %add4615 = add nsw i64 1, %860
  %add4616 = add nsw i64 0, %add4615
  %mul4617 = mul nsw i64 0, %add4616
  %add4618 = add nsw i64 %mul4617, 0
  %neg4619 = xor i64 %add4618, -1
  %cmp4620 = icmp eq i64 %neg4619, -1
  %conv4621 = zext i1 %cmp4620 to i32
  %sub4622 = sub nsw i32 0, %conv4621
  %conv4623 = sext i32 %sub4622 to i64
  %861 = load i64, i64* %numargs, align 8
  %add4624 = add nsw i64 1, %861
  %add4625 = add nsw i64 0, %add4624
  %mul4626 = mul nsw i64 0, %add4625
  %add4627 = add nsw i64 %mul4626, 1
  %shl4628 = shl i64 %add4627, 62
  %sub4629 = sub nsw i64 %shl4628, 1
  %mul4630 = mul nsw i64 %sub4629, 2
  %add4631 = add nsw i64 %mul4630, 1
  %sub4632 = sub nsw i64 %conv4623, %add4631
  br label %cond.end.4638

cond.false.4633:                                  ; preds = %cond.true.4606
  %862 = load i64, i64* %numargs, align 8
  %add4634 = add nsw i64 1, %862
  %add4635 = add nsw i64 0, %add4634
  %mul4636 = mul nsw i64 0, %add4635
  %add4637 = add nsw i64 %mul4636, 0
  br label %cond.end.4638

cond.end.4638:                                    ; preds = %cond.false.4633, %cond.true.4614
  %cond4639 = phi i64 [ %sub4632, %cond.true.4614 ], [ %add4637, %cond.false.4633 ]
  %div4640 = sdiv i64 %cond4639, 8
  %cmp4641 = icmp slt i64 %add4607, %div4640
  br i1 %cmp4641, label %cond.true.4687, label %lor.lhs.false.4670

cond.false.4643:                                  ; preds = %cond.false.4602
  %863 = load i64, i64* %numargs, align 8
  %add4644 = add nsw i64 1, %863
  %add4645 = add nsw i64 0, %add4644
  %mul4646 = mul nsw i64 0, %add4645
  %sub4647 = sub nsw i64 %mul4646, 1
  %cmp4648 = icmp slt i64 %sub4647, 0
  br i1 %cmp4648, label %cond.true.4650, label %cond.false.4659

cond.true.4650:                                   ; preds = %cond.false.4643
  %864 = load i64, i64* %numargs, align 8
  %add4651 = add nsw i64 1, %864
  %add4652 = add nsw i64 0, %add4651
  %mul4653 = mul nsw i64 0, %add4652
  %add4654 = add nsw i64 %mul4653, 1
  %shl4655 = shl i64 %add4654, 62
  %sub4656 = sub nsw i64 %shl4655, 1
  %mul4657 = mul nsw i64 %sub4656, 2
  %add4658 = add nsw i64 %mul4657, 1
  br label %cond.end.4664

cond.false.4659:                                  ; preds = %cond.false.4643
  %865 = load i64, i64* %numargs, align 8
  %add4660 = add nsw i64 1, %865
  %add4661 = add nsw i64 0, %add4660
  %mul4662 = mul nsw i64 0, %add4661
  %sub4663 = sub nsw i64 %mul4662, 1
  br label %cond.end.4664

cond.end.4664:                                    ; preds = %cond.false.4659, %cond.true.4650
  %cond4665 = phi i64 [ %add4658, %cond.true.4650 ], [ %sub4663, %cond.false.4659 ]
  %div4666 = sdiv i64 %cond4665, 8
  %866 = load i64, i64* %numargs, align 8
  %add4667 = add nsw i64 1, %866
  %cmp4668 = icmp slt i64 %div4666, %add4667
  br i1 %cmp4668, label %cond.true.4687, label %lor.lhs.false.4670

lor.lhs.false.4670:                               ; preds = %cond.end.4664, %cond.end.4638, %cond.true.4601, %cond.end.4594, %cond.true.4562, %cond.end.4556
  %867 = load i64, i64* %numargs, align 8
  %add4671 = add nsw i64 1, %867
  %mul4672 = mul nsw i64 %add4671, 8
  %mul4673 = mul nsw i64 0, %mul4672
  %sub4674 = sub nsw i64 %mul4673, 1
  %cmp4675 = icmp slt i64 %sub4674, 0
  br i1 %cmp4675, label %land.lhs.true.4677, label %lor.lhs.false.4682

land.lhs.true.4677:                               ; preds = %lor.lhs.false.4670
  %868 = load i64, i64* %numargs, align 8
  %add4678 = add nsw i64 1, %868
  %mul4679 = mul nsw i64 %add4678, 8
  %cmp4680 = icmp slt i64 %mul4679, -32768
  br i1 %cmp4680, label %cond.true.4687, label %lor.lhs.false.4682

lor.lhs.false.4682:                               ; preds = %land.lhs.true.4677, %lor.lhs.false.4670
  %869 = load i64, i64* %numargs, align 8
  %add4683 = add nsw i64 1, %869
  %mul4684 = mul nsw i64 %add4683, 8
  %cmp4685 = icmp slt i64 32767, %mul4684
  br i1 %cmp4685, label %cond.true.4687, label %cond.false.4713

cond.true.4687:                                   ; preds = %lor.lhs.false.4682, %land.lhs.true.4677, %cond.end.4664, %cond.end.4638, %cond.true.4601, %cond.end.4594, %cond.true.4562, %cond.end.4556, %land.lhs.true.4525
  %870 = load i64, i64* %numargs, align 8
  %add4688 = add nsw i64 1, %870
  %conv4689 = trunc i64 %add4688 to i16
  %conv4690 = zext i16 %conv4689 to i32
  %mul4691 = mul nsw i32 %conv4690, 8
  %cmp4692 = icmp sle i32 %mul4691, 32767
  br i1 %cmp4692, label %cond.true.4694, label %cond.false.4701

cond.true.4694:                                   ; preds = %cond.true.4687
  %871 = load i64, i64* %numargs, align 8
  %add4695 = add nsw i64 1, %871
  %conv4696 = trunc i64 %add4695 to i16
  %conv4697 = zext i16 %conv4696 to i32
  %mul4698 = mul nsw i32 %conv4697, 8
  %conv4699 = trunc i32 %mul4698 to i16
  %conv4700 = sext i16 %conv4699 to i32
  br label %cond.end.4710

cond.false.4701:                                  ; preds = %cond.true.4687
  %872 = load i64, i64* %numargs, align 8
  %add4702 = add nsw i64 1, %872
  %conv4703 = trunc i64 %add4702 to i16
  %conv4704 = zext i16 %conv4703 to i32
  %mul4705 = mul nsw i32 %conv4704, 8
  %sub4706 = sub nsw i32 %mul4705, -32768
  %conv4707 = trunc i32 %sub4706 to i16
  %conv4708 = sext i16 %conv4707 to i32
  %add4709 = add nsw i32 %conv4708, -32768
  br label %cond.end.4710

cond.end.4710:                                    ; preds = %cond.false.4701, %cond.true.4694
  %cond4711 = phi i32 [ %conv4700, %cond.true.4694 ], [ %add4709, %cond.false.4701 ]
  %conv4712 = sext i32 %cond4711 to i64
  store i64 %conv4712, i64* %alloca_nbytes3633, align 8
  br i1 true, label %if.then.6150, label %lor.lhs.false.6147

cond.false.4713:                                  ; preds = %lor.lhs.false.4682
  %873 = load i64, i64* %numargs, align 8
  %add4714 = add nsw i64 1, %873
  %conv4715 = trunc i64 %add4714 to i16
  %conv4716 = zext i16 %conv4715 to i32
  %mul4717 = mul nsw i32 %conv4716, 8
  %cmp4718 = icmp sle i32 %mul4717, 32767
  br i1 %cmp4718, label %cond.true.4720, label %cond.false.4727

cond.true.4720:                                   ; preds = %cond.false.4713
  %874 = load i64, i64* %numargs, align 8
  %add4721 = add nsw i64 1, %874
  %conv4722 = trunc i64 %add4721 to i16
  %conv4723 = zext i16 %conv4722 to i32
  %mul4724 = mul nsw i32 %conv4723, 8
  %conv4725 = trunc i32 %mul4724 to i16
  %conv4726 = sext i16 %conv4725 to i32
  br label %cond.end.4736

cond.false.4727:                                  ; preds = %cond.false.4713
  %875 = load i64, i64* %numargs, align 8
  %add4728 = add nsw i64 1, %875
  %conv4729 = trunc i64 %add4728 to i16
  %conv4730 = zext i16 %conv4729 to i32
  %mul4731 = mul nsw i32 %conv4730, 8
  %sub4732 = sub nsw i32 %mul4731, -32768
  %conv4733 = trunc i32 %sub4732 to i16
  %conv4734 = sext i16 %conv4733 to i32
  %add4735 = add nsw i32 %conv4734, -32768
  br label %cond.end.4736

cond.end.4736:                                    ; preds = %cond.false.4727, %cond.true.4720
  %cond4737 = phi i32 [ %conv4726, %cond.true.4720 ], [ %add4735, %cond.false.4727 ]
  %conv4738 = sext i32 %cond4737 to i64
  store i64 %conv4738, i64* %alloca_nbytes3633, align 8
  br i1 false, label %if.then.6150, label %lor.lhs.false.6147

cond.false.4739:                                  ; preds = %cond.false.4186
  br i1 false, label %cond.true.4740, label %cond.false.5236

cond.true.4740:                                   ; preds = %cond.false.4739
  br i1 false, label %cond.true.4741, label %cond.false.5001

cond.true.4741:                                   ; preds = %cond.true.4740
  %876 = load i64, i64* %numargs, align 8
  %add4742 = add nsw i64 1, %876
  %conv4743 = trunc i64 %add4742 to i32
  %add4744 = add nsw i32 0, %conv4743
  %mul4745 = mul nsw i32 0, %add4744
  %sub4746 = sub nsw i32 %mul4745, 1
  %cmp4747 = icmp slt i32 %sub4746, 0
  br i1 %cmp4747, label %cond.true.4749, label %cond.false.4769

cond.true.4749:                                   ; preds = %cond.true.4741
  %877 = load i64, i64* %numargs, align 8
  %add4750 = add nsw i64 1, %877
  %conv4751 = trunc i64 %add4750 to i32
  %add4752 = add nsw i32 0, %conv4751
  %mul4753 = mul nsw i32 0, %add4752
  %add4754 = add nsw i32 %mul4753, 0
  %neg4755 = xor i32 %add4754, -1
  %cmp4756 = icmp eq i32 %neg4755, -1
  %conv4757 = zext i1 %cmp4756 to i32
  %sub4758 = sub nsw i32 0, %conv4757
  %878 = load i64, i64* %numargs, align 8
  %add4759 = add nsw i64 1, %878
  %conv4760 = trunc i64 %add4759 to i32
  %add4761 = add nsw i32 0, %conv4760
  %mul4762 = mul nsw i32 0, %add4761
  %add4763 = add nsw i32 %mul4762, 1
  %shl4764 = shl i32 %add4763, 30
  %sub4765 = sub nsw i32 %shl4764, 1
  %mul4766 = mul nsw i32 %sub4765, 2
  %add4767 = add nsw i32 %mul4766, 1
  %sub4768 = sub nsw i32 %sub4758, %add4767
  br label %cond.end.4775

cond.false.4769:                                  ; preds = %cond.true.4741
  %879 = load i64, i64* %numargs, align 8
  %add4770 = add nsw i64 1, %879
  %conv4771 = trunc i64 %add4770 to i32
  %add4772 = add nsw i32 0, %conv4771
  %mul4773 = mul nsw i32 0, %add4772
  %add4774 = add nsw i32 %mul4773, 0
  br label %cond.end.4775

cond.end.4775:                                    ; preds = %cond.false.4769, %cond.true.4749
  %cond4776 = phi i32 [ %sub4768, %cond.true.4749 ], [ %add4774, %cond.false.4769 ]
  %cmp4777 = icmp eq i32 %cond4776, 0
  br i1 %cmp4777, label %land.lhs.true.4779, label %lor.lhs.false.4784

land.lhs.true.4779:                               ; preds = %cond.end.4775
  %880 = load i64, i64* %numargs, align 8
  %add4780 = add nsw i64 1, %880
  %conv4781 = trunc i64 %add4780 to i32
  %cmp4782 = icmp slt i32 %conv4781, 0
  br i1 %cmp4782, label %cond.true.4963, label %lor.lhs.false.4784

lor.lhs.false.4784:                               ; preds = %land.lhs.true.4779, %cond.end.4775
  br i1 false, label %cond.true.4785, label %cond.false.4864

cond.true.4785:                                   ; preds = %lor.lhs.false.4784
  %881 = load i64, i64* %numargs, align 8
  %add4786 = add nsw i64 1, %881
  %conv4787 = trunc i64 %add4786 to i32
  %cmp4788 = icmp slt i32 %conv4787, 0
  br i1 %cmp4788, label %cond.true.4790, label %cond.false.4821

cond.true.4790:                                   ; preds = %cond.true.4785
  %882 = load i64, i64* %numargs, align 8
  %add4791 = add nsw i64 1, %882
  %conv4792 = trunc i64 %add4791 to i32
  %883 = load i64, i64* %numargs, align 8
  %add4793 = add nsw i64 1, %883
  %conv4794 = trunc i64 %add4793 to i32
  %add4795 = add nsw i32 0, %conv4794
  %mul4796 = mul nsw i32 0, %add4795
  %sub4797 = sub nsw i32 %mul4796, 1
  %cmp4798 = icmp slt i32 %sub4797, 0
  br i1 %cmp4798, label %cond.true.4800, label %cond.false.4810

cond.true.4800:                                   ; preds = %cond.true.4790
  %884 = load i64, i64* %numargs, align 8
  %add4801 = add nsw i64 1, %884
  %conv4802 = trunc i64 %add4801 to i32
  %add4803 = add nsw i32 0, %conv4802
  %mul4804 = mul nsw i32 0, %add4803
  %add4805 = add nsw i32 %mul4804, 1
  %shl4806 = shl i32 %add4805, 30
  %sub4807 = sub nsw i32 %shl4806, 1
  %mul4808 = mul nsw i32 %sub4807, 2
  %add4809 = add nsw i32 %mul4808, 1
  br label %cond.end.4816

cond.false.4810:                                  ; preds = %cond.true.4790
  %885 = load i64, i64* %numargs, align 8
  %add4811 = add nsw i64 1, %885
  %conv4812 = trunc i64 %add4811 to i32
  %add4813 = add nsw i32 0, %conv4812
  %mul4814 = mul nsw i32 0, %add4813
  %sub4815 = sub nsw i32 %mul4814, 1
  br label %cond.end.4816

cond.end.4816:                                    ; preds = %cond.false.4810, %cond.true.4800
  %cond4817 = phi i32 [ %add4809, %cond.true.4800 ], [ %sub4815, %cond.false.4810 ]
  %div4818 = sdiv i32 %cond4817, 8
  %cmp4819 = icmp slt i32 %conv4792, %div4818
  br i1 %cmp4819, label %cond.true.4963, label %lor.lhs.false.4943

cond.false.4821:                                  ; preds = %cond.true.4785
  br i1 false, label %cond.true.4822, label %cond.false.4823

cond.true.4822:                                   ; preds = %cond.false.4821
  br i1 false, label %cond.true.4963, label %lor.lhs.false.4943

cond.false.4823:                                  ; preds = %cond.false.4821
  %886 = load i64, i64* %numargs, align 8
  %add4824 = add nsw i64 1, %886
  %conv4825 = trunc i64 %add4824 to i32
  %add4826 = add nsw i32 0, %conv4825
  %mul4827 = mul nsw i32 0, %add4826
  %sub4828 = sub nsw i32 %mul4827, 1
  %cmp4829 = icmp slt i32 %sub4828, 0
  br i1 %cmp4829, label %cond.true.4831, label %cond.false.4851

cond.true.4831:                                   ; preds = %cond.false.4823
  %887 = load i64, i64* %numargs, align 8
  %add4832 = add nsw i64 1, %887
  %conv4833 = trunc i64 %add4832 to i32
  %add4834 = add nsw i32 0, %conv4833
  %mul4835 = mul nsw i32 0, %add4834
  %add4836 = add nsw i32 %mul4835, 0
  %neg4837 = xor i32 %add4836, -1
  %cmp4838 = icmp eq i32 %neg4837, -1
  %conv4839 = zext i1 %cmp4838 to i32
  %sub4840 = sub nsw i32 0, %conv4839
  %888 = load i64, i64* %numargs, align 8
  %add4841 = add nsw i64 1, %888
  %conv4842 = trunc i64 %add4841 to i32
  %add4843 = add nsw i32 0, %conv4842
  %mul4844 = mul nsw i32 0, %add4843
  %add4845 = add nsw i32 %mul4844, 1
  %shl4846 = shl i32 %add4845, 30
  %sub4847 = sub nsw i32 %shl4846, 1
  %mul4848 = mul nsw i32 %sub4847, 2
  %add4849 = add nsw i32 %mul4848, 1
  %sub4850 = sub nsw i32 %sub4840, %add4849
  br label %cond.end.4857

cond.false.4851:                                  ; preds = %cond.false.4823
  %889 = load i64, i64* %numargs, align 8
  %add4852 = add nsw i64 1, %889
  %conv4853 = trunc i64 %add4852 to i32
  %add4854 = add nsw i32 0, %conv4853
  %mul4855 = mul nsw i32 0, %add4854
  %add4856 = add nsw i32 %mul4855, 0
  br label %cond.end.4857

cond.end.4857:                                    ; preds = %cond.false.4851, %cond.true.4831
  %cond4858 = phi i32 [ %sub4850, %cond.true.4831 ], [ %add4856, %cond.false.4851 ]
  %div4859 = sdiv i32 %cond4858, 8
  %890 = load i64, i64* %numargs, align 8
  %add4860 = add nsw i64 1, %890
  %conv4861 = trunc i64 %add4860 to i32
  %cmp4862 = icmp slt i32 %div4859, %conv4861
  br i1 %cmp4862, label %cond.true.4963, label %lor.lhs.false.4943

cond.false.4864:                                  ; preds = %lor.lhs.false.4784
  br i1 false, label %cond.true.4865, label %cond.false.4866

cond.true.4865:                                   ; preds = %cond.false.4864
  br i1 false, label %cond.true.4963, label %lor.lhs.false.4943

cond.false.4866:                                  ; preds = %cond.false.4864
  %891 = load i64, i64* %numargs, align 8
  %add4867 = add nsw i64 1, %891
  %conv4868 = trunc i64 %add4867 to i32
  %cmp4869 = icmp slt i32 %conv4868, 0
  br i1 %cmp4869, label %cond.true.4871, label %cond.false.4912

cond.true.4871:                                   ; preds = %cond.false.4866
  %892 = load i64, i64* %numargs, align 8
  %add4872 = add nsw i64 1, %892
  %conv4873 = trunc i64 %add4872 to i32
  %893 = load i64, i64* %numargs, align 8
  %add4874 = add nsw i64 1, %893
  %conv4875 = trunc i64 %add4874 to i32
  %add4876 = add nsw i32 0, %conv4875
  %mul4877 = mul nsw i32 0, %add4876
  %sub4878 = sub nsw i32 %mul4877, 1
  %cmp4879 = icmp slt i32 %sub4878, 0
  br i1 %cmp4879, label %cond.true.4881, label %cond.false.4901

cond.true.4881:                                   ; preds = %cond.true.4871
  %894 = load i64, i64* %numargs, align 8
  %add4882 = add nsw i64 1, %894
  %conv4883 = trunc i64 %add4882 to i32
  %add4884 = add nsw i32 0, %conv4883
  %mul4885 = mul nsw i32 0, %add4884
  %add4886 = add nsw i32 %mul4885, 0
  %neg4887 = xor i32 %add4886, -1
  %cmp4888 = icmp eq i32 %neg4887, -1
  %conv4889 = zext i1 %cmp4888 to i32
  %sub4890 = sub nsw i32 0, %conv4889
  %895 = load i64, i64* %numargs, align 8
  %add4891 = add nsw i64 1, %895
  %conv4892 = trunc i64 %add4891 to i32
  %add4893 = add nsw i32 0, %conv4892
  %mul4894 = mul nsw i32 0, %add4893
  %add4895 = add nsw i32 %mul4894, 1
  %shl4896 = shl i32 %add4895, 30
  %sub4897 = sub nsw i32 %shl4896, 1
  %mul4898 = mul nsw i32 %sub4897, 2
  %add4899 = add nsw i32 %mul4898, 1
  %sub4900 = sub nsw i32 %sub4890, %add4899
  br label %cond.end.4907

cond.false.4901:                                  ; preds = %cond.true.4871
  %896 = load i64, i64* %numargs, align 8
  %add4902 = add nsw i64 1, %896
  %conv4903 = trunc i64 %add4902 to i32
  %add4904 = add nsw i32 0, %conv4903
  %mul4905 = mul nsw i32 0, %add4904
  %add4906 = add nsw i32 %mul4905, 0
  br label %cond.end.4907

cond.end.4907:                                    ; preds = %cond.false.4901, %cond.true.4881
  %cond4908 = phi i32 [ %sub4900, %cond.true.4881 ], [ %add4906, %cond.false.4901 ]
  %div4909 = sdiv i32 %cond4908, 8
  %cmp4910 = icmp slt i32 %conv4873, %div4909
  br i1 %cmp4910, label %cond.true.4963, label %lor.lhs.false.4943

cond.false.4912:                                  ; preds = %cond.false.4866
  %897 = load i64, i64* %numargs, align 8
  %add4913 = add nsw i64 1, %897
  %conv4914 = trunc i64 %add4913 to i32
  %add4915 = add nsw i32 0, %conv4914
  %mul4916 = mul nsw i32 0, %add4915
  %sub4917 = sub nsw i32 %mul4916, 1
  %cmp4918 = icmp slt i32 %sub4917, 0
  br i1 %cmp4918, label %cond.true.4920, label %cond.false.4930

cond.true.4920:                                   ; preds = %cond.false.4912
  %898 = load i64, i64* %numargs, align 8
  %add4921 = add nsw i64 1, %898
  %conv4922 = trunc i64 %add4921 to i32
  %add4923 = add nsw i32 0, %conv4922
  %mul4924 = mul nsw i32 0, %add4923
  %add4925 = add nsw i32 %mul4924, 1
  %shl4926 = shl i32 %add4925, 30
  %sub4927 = sub nsw i32 %shl4926, 1
  %mul4928 = mul nsw i32 %sub4927, 2
  %add4929 = add nsw i32 %mul4928, 1
  br label %cond.end.4936

cond.false.4930:                                  ; preds = %cond.false.4912
  %899 = load i64, i64* %numargs, align 8
  %add4931 = add nsw i64 1, %899
  %conv4932 = trunc i64 %add4931 to i32
  %add4933 = add nsw i32 0, %conv4932
  %mul4934 = mul nsw i32 0, %add4933
  %sub4935 = sub nsw i32 %mul4934, 1
  br label %cond.end.4936

cond.end.4936:                                    ; preds = %cond.false.4930, %cond.true.4920
  %cond4937 = phi i32 [ %add4929, %cond.true.4920 ], [ %sub4935, %cond.false.4930 ]
  %div4938 = sdiv i32 %cond4937, 8
  %900 = load i64, i64* %numargs, align 8
  %add4939 = add nsw i64 1, %900
  %conv4940 = trunc i64 %add4939 to i32
  %cmp4941 = icmp slt i32 %div4938, %conv4940
  br i1 %cmp4941, label %cond.true.4963, label %lor.lhs.false.4943

lor.lhs.false.4943:                               ; preds = %cond.end.4936, %cond.end.4907, %cond.true.4865, %cond.end.4857, %cond.true.4822, %cond.end.4816
  %901 = load i64, i64* %numargs, align 8
  %add4944 = add nsw i64 1, %901
  %conv4945 = trunc i64 %add4944 to i32
  %mul4946 = mul nsw i32 %conv4945, 8
  %mul4947 = mul nsw i32 0, %mul4946
  %sub4948 = sub nsw i32 %mul4947, 1
  %cmp4949 = icmp slt i32 %sub4948, 0
  br i1 %cmp4949, label %land.lhs.true.4951, label %lor.lhs.false.4957

land.lhs.true.4951:                               ; preds = %lor.lhs.false.4943
  %902 = load i64, i64* %numargs, align 8
  %add4952 = add nsw i64 1, %902
  %conv4953 = trunc i64 %add4952 to i32
  %mul4954 = mul nsw i32 %conv4953, 8
  %cmp4955 = icmp slt i32 %mul4954, -2147483648
  br i1 %cmp4955, label %cond.true.4963, label %lor.lhs.false.4957

lor.lhs.false.4957:                               ; preds = %land.lhs.true.4951, %lor.lhs.false.4943
  %903 = load i64, i64* %numargs, align 8
  %add4958 = add nsw i64 1, %903
  %conv4959 = trunc i64 %add4958 to i32
  %mul4960 = mul nsw i32 %conv4959, 8
  %cmp4961 = icmp slt i32 2147483647, %mul4960
  br i1 %cmp4961, label %cond.true.4963, label %cond.false.4982

cond.true.4963:                                   ; preds = %lor.lhs.false.4957, %land.lhs.true.4951, %cond.end.4936, %cond.end.4907, %cond.true.4865, %cond.end.4857, %cond.true.4822, %cond.end.4816, %land.lhs.true.4779
  %904 = load i64, i64* %numargs, align 8
  %add4964 = add nsw i64 1, %904
  %conv4965 = trunc i64 %add4964 to i32
  %mul4966 = mul i32 %conv4965, 8
  %cmp4967 = icmp ule i32 %mul4966, 2147483647
  br i1 %cmp4967, label %cond.true.4969, label %cond.false.4973

cond.true.4969:                                   ; preds = %cond.true.4963
  %905 = load i64, i64* %numargs, align 8
  %add4970 = add nsw i64 1, %905
  %conv4971 = trunc i64 %add4970 to i32
  %mul4972 = mul i32 %conv4971, 8
  br label %cond.end.4979

cond.false.4973:                                  ; preds = %cond.true.4963
  %906 = load i64, i64* %numargs, align 8
  %add4974 = add nsw i64 1, %906
  %conv4975 = trunc i64 %add4974 to i32
  %mul4976 = mul i32 %conv4975, 8
  %sub4977 = sub i32 %mul4976, -2147483648
  %add4978 = add nsw i32 %sub4977, -2147483648
  br label %cond.end.4979

cond.end.4979:                                    ; preds = %cond.false.4973, %cond.true.4969
  %cond4980 = phi i32 [ %mul4972, %cond.true.4969 ], [ %add4978, %cond.false.4973 ]
  %conv4981 = sext i32 %cond4980 to i64
  store i64 %conv4981, i64* %alloca_nbytes3633, align 8
  br i1 true, label %if.then.6150, label %lor.lhs.false.6147

cond.false.4982:                                  ; preds = %lor.lhs.false.4957
  %907 = load i64, i64* %numargs, align 8
  %add4983 = add nsw i64 1, %907
  %conv4984 = trunc i64 %add4983 to i32
  %mul4985 = mul i32 %conv4984, 8
  %cmp4986 = icmp ule i32 %mul4985, 2147483647
  br i1 %cmp4986, label %cond.true.4988, label %cond.false.4992

cond.true.4988:                                   ; preds = %cond.false.4982
  %908 = load i64, i64* %numargs, align 8
  %add4989 = add nsw i64 1, %908
  %conv4990 = trunc i64 %add4989 to i32
  %mul4991 = mul i32 %conv4990, 8
  br label %cond.end.4998

cond.false.4992:                                  ; preds = %cond.false.4982
  %909 = load i64, i64* %numargs, align 8
  %add4993 = add nsw i64 1, %909
  %conv4994 = trunc i64 %add4993 to i32
  %mul4995 = mul i32 %conv4994, 8
  %sub4996 = sub i32 %mul4995, -2147483648
  %add4997 = add nsw i32 %sub4996, -2147483648
  br label %cond.end.4998

cond.end.4998:                                    ; preds = %cond.false.4992, %cond.true.4988
  %cond4999 = phi i32 [ %mul4991, %cond.true.4988 ], [ %add4997, %cond.false.4992 ]
  %conv5000 = sext i32 %cond4999 to i64
  store i64 %conv5000, i64* %alloca_nbytes3633, align 8
  br i1 false, label %if.then.6150, label %lor.lhs.false.6147

cond.false.5001:                                  ; preds = %cond.true.4740
  %910 = load i64, i64* %numargs, align 8
  %add5002 = add nsw i64 1, %910
  %add5003 = add nsw i64 0, %add5002
  %mul5004 = mul nsw i64 0, %add5003
  %sub5005 = sub nsw i64 %mul5004, 1
  %cmp5006 = icmp slt i64 %sub5005, 0
  br i1 %cmp5006, label %cond.true.5008, label %cond.false.5027

cond.true.5008:                                   ; preds = %cond.false.5001
  %911 = load i64, i64* %numargs, align 8
  %add5009 = add nsw i64 1, %911
  %add5010 = add nsw i64 0, %add5009
  %mul5011 = mul nsw i64 0, %add5010
  %add5012 = add nsw i64 %mul5011, 0
  %neg5013 = xor i64 %add5012, -1
  %cmp5014 = icmp eq i64 %neg5013, -1
  %conv5015 = zext i1 %cmp5014 to i32
  %sub5016 = sub nsw i32 0, %conv5015
  %conv5017 = sext i32 %sub5016 to i64
  %912 = load i64, i64* %numargs, align 8
  %add5018 = add nsw i64 1, %912
  %add5019 = add nsw i64 0, %add5018
  %mul5020 = mul nsw i64 0, %add5019
  %add5021 = add nsw i64 %mul5020, 1
  %shl5022 = shl i64 %add5021, 62
  %sub5023 = sub nsw i64 %shl5022, 1
  %mul5024 = mul nsw i64 %sub5023, 2
  %add5025 = add nsw i64 %mul5024, 1
  %sub5026 = sub nsw i64 %conv5017, %add5025
  br label %cond.end.5032

cond.false.5027:                                  ; preds = %cond.false.5001
  %913 = load i64, i64* %numargs, align 8
  %add5028 = add nsw i64 1, %913
  %add5029 = add nsw i64 0, %add5028
  %mul5030 = mul nsw i64 0, %add5029
  %add5031 = add nsw i64 %mul5030, 0
  br label %cond.end.5032

cond.end.5032:                                    ; preds = %cond.false.5027, %cond.true.5008
  %cond5033 = phi i64 [ %sub5026, %cond.true.5008 ], [ %add5031, %cond.false.5027 ]
  %cmp5034 = icmp eq i64 %cond5033, 0
  br i1 %cmp5034, label %land.lhs.true.5036, label %lor.lhs.false.5040

land.lhs.true.5036:                               ; preds = %cond.end.5032
  %914 = load i64, i64* %numargs, align 8
  %add5037 = add nsw i64 1, %914
  %cmp5038 = icmp slt i64 %add5037, 0
  br i1 %cmp5038, label %cond.true.5198, label %lor.lhs.false.5040

lor.lhs.false.5040:                               ; preds = %land.lhs.true.5036, %cond.end.5032
  br i1 false, label %cond.true.5041, label %cond.false.5111

cond.true.5041:                                   ; preds = %lor.lhs.false.5040
  %915 = load i64, i64* %numargs, align 8
  %add5042 = add nsw i64 1, %915
  %cmp5043 = icmp slt i64 %add5042, 0
  br i1 %cmp5043, label %cond.true.5045, label %cond.false.5072

cond.true.5045:                                   ; preds = %cond.true.5041
  %916 = load i64, i64* %numargs, align 8
  %add5046 = add nsw i64 1, %916
  %917 = load i64, i64* %numargs, align 8
  %add5047 = add nsw i64 1, %917
  %add5048 = add nsw i64 0, %add5047
  %mul5049 = mul nsw i64 0, %add5048
  %sub5050 = sub nsw i64 %mul5049, 1
  %cmp5051 = icmp slt i64 %sub5050, 0
  br i1 %cmp5051, label %cond.true.5053, label %cond.false.5062

cond.true.5053:                                   ; preds = %cond.true.5045
  %918 = load i64, i64* %numargs, align 8
  %add5054 = add nsw i64 1, %918
  %add5055 = add nsw i64 0, %add5054
  %mul5056 = mul nsw i64 0, %add5055
  %add5057 = add nsw i64 %mul5056, 1
  %shl5058 = shl i64 %add5057, 62
  %sub5059 = sub nsw i64 %shl5058, 1
  %mul5060 = mul nsw i64 %sub5059, 2
  %add5061 = add nsw i64 %mul5060, 1
  br label %cond.end.5067

cond.false.5062:                                  ; preds = %cond.true.5045
  %919 = load i64, i64* %numargs, align 8
  %add5063 = add nsw i64 1, %919
  %add5064 = add nsw i64 0, %add5063
  %mul5065 = mul nsw i64 0, %add5064
  %sub5066 = sub nsw i64 %mul5065, 1
  br label %cond.end.5067

cond.end.5067:                                    ; preds = %cond.false.5062, %cond.true.5053
  %cond5068 = phi i64 [ %add5061, %cond.true.5053 ], [ %sub5066, %cond.false.5062 ]
  %div5069 = sdiv i64 %cond5068, 8
  %cmp5070 = icmp slt i64 %add5046, %div5069
  br i1 %cmp5070, label %cond.true.5198, label %lor.lhs.false.5181

cond.false.5072:                                  ; preds = %cond.true.5041
  br i1 false, label %cond.true.5073, label %cond.false.5074

cond.true.5073:                                   ; preds = %cond.false.5072
  br i1 false, label %cond.true.5198, label %lor.lhs.false.5181

cond.false.5074:                                  ; preds = %cond.false.5072
  %920 = load i64, i64* %numargs, align 8
  %add5075 = add nsw i64 1, %920
  %add5076 = add nsw i64 0, %add5075
  %mul5077 = mul nsw i64 0, %add5076
  %sub5078 = sub nsw i64 %mul5077, 1
  %cmp5079 = icmp slt i64 %sub5078, 0
  br i1 %cmp5079, label %cond.true.5081, label %cond.false.5100

cond.true.5081:                                   ; preds = %cond.false.5074
  %921 = load i64, i64* %numargs, align 8
  %add5082 = add nsw i64 1, %921
  %add5083 = add nsw i64 0, %add5082
  %mul5084 = mul nsw i64 0, %add5083
  %add5085 = add nsw i64 %mul5084, 0
  %neg5086 = xor i64 %add5085, -1
  %cmp5087 = icmp eq i64 %neg5086, -1
  %conv5088 = zext i1 %cmp5087 to i32
  %sub5089 = sub nsw i32 0, %conv5088
  %conv5090 = sext i32 %sub5089 to i64
  %922 = load i64, i64* %numargs, align 8
  %add5091 = add nsw i64 1, %922
  %add5092 = add nsw i64 0, %add5091
  %mul5093 = mul nsw i64 0, %add5092
  %add5094 = add nsw i64 %mul5093, 1
  %shl5095 = shl i64 %add5094, 62
  %sub5096 = sub nsw i64 %shl5095, 1
  %mul5097 = mul nsw i64 %sub5096, 2
  %add5098 = add nsw i64 %mul5097, 1
  %sub5099 = sub nsw i64 %conv5090, %add5098
  br label %cond.end.5105

cond.false.5100:                                  ; preds = %cond.false.5074
  %923 = load i64, i64* %numargs, align 8
  %add5101 = add nsw i64 1, %923
  %add5102 = add nsw i64 0, %add5101
  %mul5103 = mul nsw i64 0, %add5102
  %add5104 = add nsw i64 %mul5103, 0
  br label %cond.end.5105

cond.end.5105:                                    ; preds = %cond.false.5100, %cond.true.5081
  %cond5106 = phi i64 [ %sub5099, %cond.true.5081 ], [ %add5104, %cond.false.5100 ]
  %div5107 = sdiv i64 %cond5106, 8
  %924 = load i64, i64* %numargs, align 8
  %add5108 = add nsw i64 1, %924
  %cmp5109 = icmp slt i64 %div5107, %add5108
  br i1 %cmp5109, label %cond.true.5198, label %lor.lhs.false.5181

cond.false.5111:                                  ; preds = %lor.lhs.false.5040
  br i1 false, label %cond.true.5112, label %cond.false.5113

cond.true.5112:                                   ; preds = %cond.false.5111
  br i1 false, label %cond.true.5198, label %lor.lhs.false.5181

cond.false.5113:                                  ; preds = %cond.false.5111
  %925 = load i64, i64* %numargs, align 8
  %add5114 = add nsw i64 1, %925
  %cmp5115 = icmp slt i64 %add5114, 0
  br i1 %cmp5115, label %cond.true.5117, label %cond.false.5154

cond.true.5117:                                   ; preds = %cond.false.5113
  %926 = load i64, i64* %numargs, align 8
  %add5118 = add nsw i64 1, %926
  %927 = load i64, i64* %numargs, align 8
  %add5119 = add nsw i64 1, %927
  %add5120 = add nsw i64 0, %add5119
  %mul5121 = mul nsw i64 0, %add5120
  %sub5122 = sub nsw i64 %mul5121, 1
  %cmp5123 = icmp slt i64 %sub5122, 0
  br i1 %cmp5123, label %cond.true.5125, label %cond.false.5144

cond.true.5125:                                   ; preds = %cond.true.5117
  %928 = load i64, i64* %numargs, align 8
  %add5126 = add nsw i64 1, %928
  %add5127 = add nsw i64 0, %add5126
  %mul5128 = mul nsw i64 0, %add5127
  %add5129 = add nsw i64 %mul5128, 0
  %neg5130 = xor i64 %add5129, -1
  %cmp5131 = icmp eq i64 %neg5130, -1
  %conv5132 = zext i1 %cmp5131 to i32
  %sub5133 = sub nsw i32 0, %conv5132
  %conv5134 = sext i32 %sub5133 to i64
  %929 = load i64, i64* %numargs, align 8
  %add5135 = add nsw i64 1, %929
  %add5136 = add nsw i64 0, %add5135
  %mul5137 = mul nsw i64 0, %add5136
  %add5138 = add nsw i64 %mul5137, 1
  %shl5139 = shl i64 %add5138, 62
  %sub5140 = sub nsw i64 %shl5139, 1
  %mul5141 = mul nsw i64 %sub5140, 2
  %add5142 = add nsw i64 %mul5141, 1
  %sub5143 = sub nsw i64 %conv5134, %add5142
  br label %cond.end.5149

cond.false.5144:                                  ; preds = %cond.true.5117
  %930 = load i64, i64* %numargs, align 8
  %add5145 = add nsw i64 1, %930
  %add5146 = add nsw i64 0, %add5145
  %mul5147 = mul nsw i64 0, %add5146
  %add5148 = add nsw i64 %mul5147, 0
  br label %cond.end.5149

cond.end.5149:                                    ; preds = %cond.false.5144, %cond.true.5125
  %cond5150 = phi i64 [ %sub5143, %cond.true.5125 ], [ %add5148, %cond.false.5144 ]
  %div5151 = sdiv i64 %cond5150, 8
  %cmp5152 = icmp slt i64 %add5118, %div5151
  br i1 %cmp5152, label %cond.true.5198, label %lor.lhs.false.5181

cond.false.5154:                                  ; preds = %cond.false.5113
  %931 = load i64, i64* %numargs, align 8
  %add5155 = add nsw i64 1, %931
  %add5156 = add nsw i64 0, %add5155
  %mul5157 = mul nsw i64 0, %add5156
  %sub5158 = sub nsw i64 %mul5157, 1
  %cmp5159 = icmp slt i64 %sub5158, 0
  br i1 %cmp5159, label %cond.true.5161, label %cond.false.5170

cond.true.5161:                                   ; preds = %cond.false.5154
  %932 = load i64, i64* %numargs, align 8
  %add5162 = add nsw i64 1, %932
  %add5163 = add nsw i64 0, %add5162
  %mul5164 = mul nsw i64 0, %add5163
  %add5165 = add nsw i64 %mul5164, 1
  %shl5166 = shl i64 %add5165, 62
  %sub5167 = sub nsw i64 %shl5166, 1
  %mul5168 = mul nsw i64 %sub5167, 2
  %add5169 = add nsw i64 %mul5168, 1
  br label %cond.end.5175

cond.false.5170:                                  ; preds = %cond.false.5154
  %933 = load i64, i64* %numargs, align 8
  %add5171 = add nsw i64 1, %933
  %add5172 = add nsw i64 0, %add5171
  %mul5173 = mul nsw i64 0, %add5172
  %sub5174 = sub nsw i64 %mul5173, 1
  br label %cond.end.5175

cond.end.5175:                                    ; preds = %cond.false.5170, %cond.true.5161
  %cond5176 = phi i64 [ %add5169, %cond.true.5161 ], [ %sub5174, %cond.false.5170 ]
  %div5177 = sdiv i64 %cond5176, 8
  %934 = load i64, i64* %numargs, align 8
  %add5178 = add nsw i64 1, %934
  %cmp5179 = icmp slt i64 %div5177, %add5178
  br i1 %cmp5179, label %cond.true.5198, label %lor.lhs.false.5181

lor.lhs.false.5181:                               ; preds = %cond.end.5175, %cond.end.5149, %cond.true.5112, %cond.end.5105, %cond.true.5073, %cond.end.5067
  %935 = load i64, i64* %numargs, align 8
  %add5182 = add nsw i64 1, %935
  %mul5183 = mul nsw i64 %add5182, 8
  %mul5184 = mul nsw i64 0, %mul5183
  %sub5185 = sub nsw i64 %mul5184, 1
  %cmp5186 = icmp slt i64 %sub5185, 0
  br i1 %cmp5186, label %land.lhs.true.5188, label %lor.lhs.false.5193

land.lhs.true.5188:                               ; preds = %lor.lhs.false.5181
  %936 = load i64, i64* %numargs, align 8
  %add5189 = add nsw i64 1, %936
  %mul5190 = mul nsw i64 %add5189, 8
  %cmp5191 = icmp slt i64 %mul5190, -2147483648
  br i1 %cmp5191, label %cond.true.5198, label %lor.lhs.false.5193

lor.lhs.false.5193:                               ; preds = %land.lhs.true.5188, %lor.lhs.false.5181
  %937 = load i64, i64* %numargs, align 8
  %add5194 = add nsw i64 1, %937
  %mul5195 = mul nsw i64 %add5194, 8
  %cmp5196 = icmp slt i64 2147483647, %mul5195
  br i1 %cmp5196, label %cond.true.5198, label %cond.false.5217

cond.true.5198:                                   ; preds = %lor.lhs.false.5193, %land.lhs.true.5188, %cond.end.5175, %cond.end.5149, %cond.true.5112, %cond.end.5105, %cond.true.5073, %cond.end.5067, %land.lhs.true.5036
  %938 = load i64, i64* %numargs, align 8
  %add5199 = add nsw i64 1, %938
  %conv5200 = trunc i64 %add5199 to i32
  %mul5201 = mul i32 %conv5200, 8
  %cmp5202 = icmp ule i32 %mul5201, 2147483647
  br i1 %cmp5202, label %cond.true.5204, label %cond.false.5208

cond.true.5204:                                   ; preds = %cond.true.5198
  %939 = load i64, i64* %numargs, align 8
  %add5205 = add nsw i64 1, %939
  %conv5206 = trunc i64 %add5205 to i32
  %mul5207 = mul i32 %conv5206, 8
  br label %cond.end.5214

cond.false.5208:                                  ; preds = %cond.true.5198
  %940 = load i64, i64* %numargs, align 8
  %add5209 = add nsw i64 1, %940
  %conv5210 = trunc i64 %add5209 to i32
  %mul5211 = mul i32 %conv5210, 8
  %sub5212 = sub i32 %mul5211, -2147483648
  %add5213 = add nsw i32 %sub5212, -2147483648
  br label %cond.end.5214

cond.end.5214:                                    ; preds = %cond.false.5208, %cond.true.5204
  %cond5215 = phi i32 [ %mul5207, %cond.true.5204 ], [ %add5213, %cond.false.5208 ]
  %conv5216 = sext i32 %cond5215 to i64
  store i64 %conv5216, i64* %alloca_nbytes3633, align 8
  br i1 true, label %if.then.6150, label %lor.lhs.false.6147

cond.false.5217:                                  ; preds = %lor.lhs.false.5193
  %941 = load i64, i64* %numargs, align 8
  %add5218 = add nsw i64 1, %941
  %conv5219 = trunc i64 %add5218 to i32
  %mul5220 = mul i32 %conv5219, 8
  %cmp5221 = icmp ule i32 %mul5220, 2147483647
  br i1 %cmp5221, label %cond.true.5223, label %cond.false.5227

cond.true.5223:                                   ; preds = %cond.false.5217
  %942 = load i64, i64* %numargs, align 8
  %add5224 = add nsw i64 1, %942
  %conv5225 = trunc i64 %add5224 to i32
  %mul5226 = mul i32 %conv5225, 8
  br label %cond.end.5233

cond.false.5227:                                  ; preds = %cond.false.5217
  %943 = load i64, i64* %numargs, align 8
  %add5228 = add nsw i64 1, %943
  %conv5229 = trunc i64 %add5228 to i32
  %mul5230 = mul i32 %conv5229, 8
  %sub5231 = sub i32 %mul5230, -2147483648
  %add5232 = add nsw i32 %sub5231, -2147483648
  br label %cond.end.5233

cond.end.5233:                                    ; preds = %cond.false.5227, %cond.true.5223
  %cond5234 = phi i32 [ %mul5226, %cond.true.5223 ], [ %add5232, %cond.false.5227 ]
  %conv5235 = sext i32 %cond5234 to i64
  store i64 %conv5235, i64* %alloca_nbytes3633, align 8
  br i1 false, label %if.then.6150, label %lor.lhs.false.6147

cond.false.5236:                                  ; preds = %cond.false.4739
  br i1 true, label %cond.true.5237, label %cond.false.5692

cond.true.5237:                                   ; preds = %cond.false.5236
  br i1 false, label %cond.true.5238, label %cond.false.5465

cond.true.5238:                                   ; preds = %cond.true.5237
  %944 = load i64, i64* %numargs, align 8
  %add5239 = add nsw i64 1, %944
  %add5240 = add nsw i64 0, %add5239
  %mul5241 = mul nsw i64 0, %add5240
  %sub5242 = sub nsw i64 %mul5241, 1
  %cmp5243 = icmp slt i64 %sub5242, 0
  br i1 %cmp5243, label %cond.true.5245, label %cond.false.5264

cond.true.5245:                                   ; preds = %cond.true.5238
  %945 = load i64, i64* %numargs, align 8
  %add5246 = add nsw i64 1, %945
  %add5247 = add nsw i64 0, %add5246
  %mul5248 = mul nsw i64 0, %add5247
  %add5249 = add nsw i64 %mul5248, 0
  %neg5250 = xor i64 %add5249, -1
  %cmp5251 = icmp eq i64 %neg5250, -1
  %conv5252 = zext i1 %cmp5251 to i32
  %sub5253 = sub nsw i32 0, %conv5252
  %conv5254 = sext i32 %sub5253 to i64
  %946 = load i64, i64* %numargs, align 8
  %add5255 = add nsw i64 1, %946
  %add5256 = add nsw i64 0, %add5255
  %mul5257 = mul nsw i64 0, %add5256
  %add5258 = add nsw i64 %mul5257, 1
  %shl5259 = shl i64 %add5258, 62
  %sub5260 = sub nsw i64 %shl5259, 1
  %mul5261 = mul nsw i64 %sub5260, 2
  %add5262 = add nsw i64 %mul5261, 1
  %sub5263 = sub nsw i64 %conv5254, %add5262
  br label %cond.end.5269

cond.false.5264:                                  ; preds = %cond.true.5238
  %947 = load i64, i64* %numargs, align 8
  %add5265 = add nsw i64 1, %947
  %add5266 = add nsw i64 0, %add5265
  %mul5267 = mul nsw i64 0, %add5266
  %add5268 = add nsw i64 %mul5267, 0
  br label %cond.end.5269

cond.end.5269:                                    ; preds = %cond.false.5264, %cond.true.5245
  %cond5270 = phi i64 [ %sub5263, %cond.true.5245 ], [ %add5268, %cond.false.5264 ]
  %cmp5271 = icmp eq i64 %cond5270, 0
  br i1 %cmp5271, label %land.lhs.true.5273, label %lor.lhs.false.5277

land.lhs.true.5273:                               ; preds = %cond.end.5269
  %948 = load i64, i64* %numargs, align 8
  %add5274 = add nsw i64 1, %948
  %cmp5275 = icmp slt i64 %add5274, 0
  br i1 %cmp5275, label %cond.true.5435, label %lor.lhs.false.5277

lor.lhs.false.5277:                               ; preds = %land.lhs.true.5273, %cond.end.5269
  br i1 false, label %cond.true.5278, label %cond.false.5348

cond.true.5278:                                   ; preds = %lor.lhs.false.5277
  %949 = load i64, i64* %numargs, align 8
  %add5279 = add nsw i64 1, %949
  %cmp5280 = icmp slt i64 %add5279, 0
  br i1 %cmp5280, label %cond.true.5282, label %cond.false.5309

cond.true.5282:                                   ; preds = %cond.true.5278
  %950 = load i64, i64* %numargs, align 8
  %add5283 = add nsw i64 1, %950
  %951 = load i64, i64* %numargs, align 8
  %add5284 = add nsw i64 1, %951
  %add5285 = add nsw i64 0, %add5284
  %mul5286 = mul nsw i64 0, %add5285
  %sub5287 = sub nsw i64 %mul5286, 1
  %cmp5288 = icmp slt i64 %sub5287, 0
  br i1 %cmp5288, label %cond.true.5290, label %cond.false.5299

cond.true.5290:                                   ; preds = %cond.true.5282
  %952 = load i64, i64* %numargs, align 8
  %add5291 = add nsw i64 1, %952
  %add5292 = add nsw i64 0, %add5291
  %mul5293 = mul nsw i64 0, %add5292
  %add5294 = add nsw i64 %mul5293, 1
  %shl5295 = shl i64 %add5294, 62
  %sub5296 = sub nsw i64 %shl5295, 1
  %mul5297 = mul nsw i64 %sub5296, 2
  %add5298 = add nsw i64 %mul5297, 1
  br label %cond.end.5304

cond.false.5299:                                  ; preds = %cond.true.5282
  %953 = load i64, i64* %numargs, align 8
  %add5300 = add nsw i64 1, %953
  %add5301 = add nsw i64 0, %add5300
  %mul5302 = mul nsw i64 0, %add5301
  %sub5303 = sub nsw i64 %mul5302, 1
  br label %cond.end.5304

cond.end.5304:                                    ; preds = %cond.false.5299, %cond.true.5290
  %cond5305 = phi i64 [ %add5298, %cond.true.5290 ], [ %sub5303, %cond.false.5299 ]
  %div5306 = sdiv i64 %cond5305, 8
  %cmp5307 = icmp slt i64 %add5283, %div5306
  br i1 %cmp5307, label %cond.true.5435, label %lor.lhs.false.5418

cond.false.5309:                                  ; preds = %cond.true.5278
  br i1 false, label %cond.true.5310, label %cond.false.5311

cond.true.5310:                                   ; preds = %cond.false.5309
  br i1 false, label %cond.true.5435, label %lor.lhs.false.5418

cond.false.5311:                                  ; preds = %cond.false.5309
  %954 = load i64, i64* %numargs, align 8
  %add5312 = add nsw i64 1, %954
  %add5313 = add nsw i64 0, %add5312
  %mul5314 = mul nsw i64 0, %add5313
  %sub5315 = sub nsw i64 %mul5314, 1
  %cmp5316 = icmp slt i64 %sub5315, 0
  br i1 %cmp5316, label %cond.true.5318, label %cond.false.5337

cond.true.5318:                                   ; preds = %cond.false.5311
  %955 = load i64, i64* %numargs, align 8
  %add5319 = add nsw i64 1, %955
  %add5320 = add nsw i64 0, %add5319
  %mul5321 = mul nsw i64 0, %add5320
  %add5322 = add nsw i64 %mul5321, 0
  %neg5323 = xor i64 %add5322, -1
  %cmp5324 = icmp eq i64 %neg5323, -1
  %conv5325 = zext i1 %cmp5324 to i32
  %sub5326 = sub nsw i32 0, %conv5325
  %conv5327 = sext i32 %sub5326 to i64
  %956 = load i64, i64* %numargs, align 8
  %add5328 = add nsw i64 1, %956
  %add5329 = add nsw i64 0, %add5328
  %mul5330 = mul nsw i64 0, %add5329
  %add5331 = add nsw i64 %mul5330, 1
  %shl5332 = shl i64 %add5331, 62
  %sub5333 = sub nsw i64 %shl5332, 1
  %mul5334 = mul nsw i64 %sub5333, 2
  %add5335 = add nsw i64 %mul5334, 1
  %sub5336 = sub nsw i64 %conv5327, %add5335
  br label %cond.end.5342

cond.false.5337:                                  ; preds = %cond.false.5311
  %957 = load i64, i64* %numargs, align 8
  %add5338 = add nsw i64 1, %957
  %add5339 = add nsw i64 0, %add5338
  %mul5340 = mul nsw i64 0, %add5339
  %add5341 = add nsw i64 %mul5340, 0
  br label %cond.end.5342

cond.end.5342:                                    ; preds = %cond.false.5337, %cond.true.5318
  %cond5343 = phi i64 [ %sub5336, %cond.true.5318 ], [ %add5341, %cond.false.5337 ]
  %div5344 = sdiv i64 %cond5343, 8
  %958 = load i64, i64* %numargs, align 8
  %add5345 = add nsw i64 1, %958
  %cmp5346 = icmp slt i64 %div5344, %add5345
  br i1 %cmp5346, label %cond.true.5435, label %lor.lhs.false.5418

cond.false.5348:                                  ; preds = %lor.lhs.false.5277
  br i1 false, label %cond.true.5349, label %cond.false.5350

cond.true.5349:                                   ; preds = %cond.false.5348
  br i1 false, label %cond.true.5435, label %lor.lhs.false.5418

cond.false.5350:                                  ; preds = %cond.false.5348
  %959 = load i64, i64* %numargs, align 8
  %add5351 = add nsw i64 1, %959
  %cmp5352 = icmp slt i64 %add5351, 0
  br i1 %cmp5352, label %cond.true.5354, label %cond.false.5391

cond.true.5354:                                   ; preds = %cond.false.5350
  %960 = load i64, i64* %numargs, align 8
  %add5355 = add nsw i64 1, %960
  %961 = load i64, i64* %numargs, align 8
  %add5356 = add nsw i64 1, %961
  %add5357 = add nsw i64 0, %add5356
  %mul5358 = mul nsw i64 0, %add5357
  %sub5359 = sub nsw i64 %mul5358, 1
  %cmp5360 = icmp slt i64 %sub5359, 0
  br i1 %cmp5360, label %cond.true.5362, label %cond.false.5381

cond.true.5362:                                   ; preds = %cond.true.5354
  %962 = load i64, i64* %numargs, align 8
  %add5363 = add nsw i64 1, %962
  %add5364 = add nsw i64 0, %add5363
  %mul5365 = mul nsw i64 0, %add5364
  %add5366 = add nsw i64 %mul5365, 0
  %neg5367 = xor i64 %add5366, -1
  %cmp5368 = icmp eq i64 %neg5367, -1
  %conv5369 = zext i1 %cmp5368 to i32
  %sub5370 = sub nsw i32 0, %conv5369
  %conv5371 = sext i32 %sub5370 to i64
  %963 = load i64, i64* %numargs, align 8
  %add5372 = add nsw i64 1, %963
  %add5373 = add nsw i64 0, %add5372
  %mul5374 = mul nsw i64 0, %add5373
  %add5375 = add nsw i64 %mul5374, 1
  %shl5376 = shl i64 %add5375, 62
  %sub5377 = sub nsw i64 %shl5376, 1
  %mul5378 = mul nsw i64 %sub5377, 2
  %add5379 = add nsw i64 %mul5378, 1
  %sub5380 = sub nsw i64 %conv5371, %add5379
  br label %cond.end.5386

cond.false.5381:                                  ; preds = %cond.true.5354
  %964 = load i64, i64* %numargs, align 8
  %add5382 = add nsw i64 1, %964
  %add5383 = add nsw i64 0, %add5382
  %mul5384 = mul nsw i64 0, %add5383
  %add5385 = add nsw i64 %mul5384, 0
  br label %cond.end.5386

cond.end.5386:                                    ; preds = %cond.false.5381, %cond.true.5362
  %cond5387 = phi i64 [ %sub5380, %cond.true.5362 ], [ %add5385, %cond.false.5381 ]
  %div5388 = sdiv i64 %cond5387, 8
  %cmp5389 = icmp slt i64 %add5355, %div5388
  br i1 %cmp5389, label %cond.true.5435, label %lor.lhs.false.5418

cond.false.5391:                                  ; preds = %cond.false.5350
  %965 = load i64, i64* %numargs, align 8
  %add5392 = add nsw i64 1, %965
  %add5393 = add nsw i64 0, %add5392
  %mul5394 = mul nsw i64 0, %add5393
  %sub5395 = sub nsw i64 %mul5394, 1
  %cmp5396 = icmp slt i64 %sub5395, 0
  br i1 %cmp5396, label %cond.true.5398, label %cond.false.5407

cond.true.5398:                                   ; preds = %cond.false.5391
  %966 = load i64, i64* %numargs, align 8
  %add5399 = add nsw i64 1, %966
  %add5400 = add nsw i64 0, %add5399
  %mul5401 = mul nsw i64 0, %add5400
  %add5402 = add nsw i64 %mul5401, 1
  %shl5403 = shl i64 %add5402, 62
  %sub5404 = sub nsw i64 %shl5403, 1
  %mul5405 = mul nsw i64 %sub5404, 2
  %add5406 = add nsw i64 %mul5405, 1
  br label %cond.end.5412

cond.false.5407:                                  ; preds = %cond.false.5391
  %967 = load i64, i64* %numargs, align 8
  %add5408 = add nsw i64 1, %967
  %add5409 = add nsw i64 0, %add5408
  %mul5410 = mul nsw i64 0, %add5409
  %sub5411 = sub nsw i64 %mul5410, 1
  br label %cond.end.5412

cond.end.5412:                                    ; preds = %cond.false.5407, %cond.true.5398
  %cond5413 = phi i64 [ %add5406, %cond.true.5398 ], [ %sub5411, %cond.false.5407 ]
  %div5414 = sdiv i64 %cond5413, 8
  %968 = load i64, i64* %numargs, align 8
  %add5415 = add nsw i64 1, %968
  %cmp5416 = icmp slt i64 %div5414, %add5415
  br i1 %cmp5416, label %cond.true.5435, label %lor.lhs.false.5418

lor.lhs.false.5418:                               ; preds = %cond.end.5412, %cond.end.5386, %cond.true.5349, %cond.end.5342, %cond.true.5310, %cond.end.5304
  %969 = load i64, i64* %numargs, align 8
  %add5419 = add nsw i64 1, %969
  %mul5420 = mul nsw i64 %add5419, 8
  %mul5421 = mul nsw i64 0, %mul5420
  %sub5422 = sub nsw i64 %mul5421, 1
  %cmp5423 = icmp slt i64 %sub5422, 0
  br i1 %cmp5423, label %land.lhs.true.5425, label %lor.lhs.false.5430

land.lhs.true.5425:                               ; preds = %lor.lhs.false.5418
  %970 = load i64, i64* %numargs, align 8
  %add5426 = add nsw i64 1, %970
  %mul5427 = mul nsw i64 %add5426, 8
  %cmp5428 = icmp slt i64 %mul5427, -9223372036854775808
  br i1 %cmp5428, label %cond.true.5435, label %lor.lhs.false.5430

lor.lhs.false.5430:                               ; preds = %land.lhs.true.5425, %lor.lhs.false.5418
  %971 = load i64, i64* %numargs, align 8
  %add5431 = add nsw i64 1, %971
  %mul5432 = mul nsw i64 %add5431, 8
  %cmp5433 = icmp slt i64 9223372036854775807, %mul5432
  br i1 %cmp5433, label %cond.true.5435, label %cond.false.5450

cond.true.5435:                                   ; preds = %lor.lhs.false.5430, %land.lhs.true.5425, %cond.end.5412, %cond.end.5386, %cond.true.5349, %cond.end.5342, %cond.true.5310, %cond.end.5304, %land.lhs.true.5273
  %972 = load i64, i64* %numargs, align 8
  %add5436 = add nsw i64 1, %972
  %mul5437 = mul i64 %add5436, 8
  %cmp5438 = icmp ule i64 %mul5437, 9223372036854775807
  br i1 %cmp5438, label %cond.true.5440, label %cond.false.5443

cond.true.5440:                                   ; preds = %cond.true.5435
  %973 = load i64, i64* %numargs, align 8
  %add5441 = add nsw i64 1, %973
  %mul5442 = mul i64 %add5441, 8
  br label %cond.end.5448

cond.false.5443:                                  ; preds = %cond.true.5435
  %974 = load i64, i64* %numargs, align 8
  %add5444 = add nsw i64 1, %974
  %mul5445 = mul i64 %add5444, 8
  %sub5446 = sub i64 %mul5445, -9223372036854775808
  %add5447 = add nsw i64 %sub5446, -9223372036854775808
  br label %cond.end.5448

cond.end.5448:                                    ; preds = %cond.false.5443, %cond.true.5440
  %cond5449 = phi i64 [ %mul5442, %cond.true.5440 ], [ %add5447, %cond.false.5443 ]
  store i64 %cond5449, i64* %alloca_nbytes3633, align 8
  br i1 true, label %if.then.6150, label %lor.lhs.false.6147

cond.false.5450:                                  ; preds = %lor.lhs.false.5430
  %975 = load i64, i64* %numargs, align 8
  %add5451 = add nsw i64 1, %975
  %mul5452 = mul i64 %add5451, 8
  %cmp5453 = icmp ule i64 %mul5452, 9223372036854775807
  br i1 %cmp5453, label %cond.true.5455, label %cond.false.5458

cond.true.5455:                                   ; preds = %cond.false.5450
  %976 = load i64, i64* %numargs, align 8
  %add5456 = add nsw i64 1, %976
  %mul5457 = mul i64 %add5456, 8
  br label %cond.end.5463

cond.false.5458:                                  ; preds = %cond.false.5450
  %977 = load i64, i64* %numargs, align 8
  %add5459 = add nsw i64 1, %977
  %mul5460 = mul i64 %add5459, 8
  %sub5461 = sub i64 %mul5460, -9223372036854775808
  %add5462 = add nsw i64 %sub5461, -9223372036854775808
  br label %cond.end.5463

cond.end.5463:                                    ; preds = %cond.false.5458, %cond.true.5455
  %cond5464 = phi i64 [ %mul5457, %cond.true.5455 ], [ %add5462, %cond.false.5458 ]
  store i64 %cond5464, i64* %alloca_nbytes3633, align 8
  br i1 false, label %if.then.6150, label %lor.lhs.false.6147

cond.false.5465:                                  ; preds = %cond.true.5237
  %978 = load i64, i64* %numargs, align 8
  %add5466 = add nsw i64 1, %978
  %add5467 = add nsw i64 0, %add5466
  %mul5468 = mul nsw i64 0, %add5467
  %sub5469 = sub nsw i64 %mul5468, 1
  %cmp5470 = icmp slt i64 %sub5469, 0
  br i1 %cmp5470, label %cond.true.5472, label %cond.false.5491

cond.true.5472:                                   ; preds = %cond.false.5465
  %979 = load i64, i64* %numargs, align 8
  %add5473 = add nsw i64 1, %979
  %add5474 = add nsw i64 0, %add5473
  %mul5475 = mul nsw i64 0, %add5474
  %add5476 = add nsw i64 %mul5475, 0
  %neg5477 = xor i64 %add5476, -1
  %cmp5478 = icmp eq i64 %neg5477, -1
  %conv5479 = zext i1 %cmp5478 to i32
  %sub5480 = sub nsw i32 0, %conv5479
  %conv5481 = sext i32 %sub5480 to i64
  %980 = load i64, i64* %numargs, align 8
  %add5482 = add nsw i64 1, %980
  %add5483 = add nsw i64 0, %add5482
  %mul5484 = mul nsw i64 0, %add5483
  %add5485 = add nsw i64 %mul5484, 1
  %shl5486 = shl i64 %add5485, 62
  %sub5487 = sub nsw i64 %shl5486, 1
  %mul5488 = mul nsw i64 %sub5487, 2
  %add5489 = add nsw i64 %mul5488, 1
  %sub5490 = sub nsw i64 %conv5481, %add5489
  br label %cond.end.5496

cond.false.5491:                                  ; preds = %cond.false.5465
  %981 = load i64, i64* %numargs, align 8
  %add5492 = add nsw i64 1, %981
  %add5493 = add nsw i64 0, %add5492
  %mul5494 = mul nsw i64 0, %add5493
  %add5495 = add nsw i64 %mul5494, 0
  br label %cond.end.5496

cond.end.5496:                                    ; preds = %cond.false.5491, %cond.true.5472
  %cond5497 = phi i64 [ %sub5490, %cond.true.5472 ], [ %add5495, %cond.false.5491 ]
  %cmp5498 = icmp eq i64 %cond5497, 0
  br i1 %cmp5498, label %land.lhs.true.5500, label %lor.lhs.false.5504

land.lhs.true.5500:                               ; preds = %cond.end.5496
  %982 = load i64, i64* %numargs, align 8
  %add5501 = add nsw i64 1, %982
  %cmp5502 = icmp slt i64 %add5501, 0
  br i1 %cmp5502, label %cond.true.5662, label %lor.lhs.false.5504

lor.lhs.false.5504:                               ; preds = %land.lhs.true.5500, %cond.end.5496
  br i1 false, label %cond.true.5505, label %cond.false.5575

cond.true.5505:                                   ; preds = %lor.lhs.false.5504
  %983 = load i64, i64* %numargs, align 8
  %add5506 = add nsw i64 1, %983
  %cmp5507 = icmp slt i64 %add5506, 0
  br i1 %cmp5507, label %cond.true.5509, label %cond.false.5536

cond.true.5509:                                   ; preds = %cond.true.5505
  %984 = load i64, i64* %numargs, align 8
  %add5510 = add nsw i64 1, %984
  %985 = load i64, i64* %numargs, align 8
  %add5511 = add nsw i64 1, %985
  %add5512 = add nsw i64 0, %add5511
  %mul5513 = mul nsw i64 0, %add5512
  %sub5514 = sub nsw i64 %mul5513, 1
  %cmp5515 = icmp slt i64 %sub5514, 0
  br i1 %cmp5515, label %cond.true.5517, label %cond.false.5526

cond.true.5517:                                   ; preds = %cond.true.5509
  %986 = load i64, i64* %numargs, align 8
  %add5518 = add nsw i64 1, %986
  %add5519 = add nsw i64 0, %add5518
  %mul5520 = mul nsw i64 0, %add5519
  %add5521 = add nsw i64 %mul5520, 1
  %shl5522 = shl i64 %add5521, 62
  %sub5523 = sub nsw i64 %shl5522, 1
  %mul5524 = mul nsw i64 %sub5523, 2
  %add5525 = add nsw i64 %mul5524, 1
  br label %cond.end.5531

cond.false.5526:                                  ; preds = %cond.true.5509
  %987 = load i64, i64* %numargs, align 8
  %add5527 = add nsw i64 1, %987
  %add5528 = add nsw i64 0, %add5527
  %mul5529 = mul nsw i64 0, %add5528
  %sub5530 = sub nsw i64 %mul5529, 1
  br label %cond.end.5531

cond.end.5531:                                    ; preds = %cond.false.5526, %cond.true.5517
  %cond5532 = phi i64 [ %add5525, %cond.true.5517 ], [ %sub5530, %cond.false.5526 ]
  %div5533 = sdiv i64 %cond5532, 8
  %cmp5534 = icmp slt i64 %add5510, %div5533
  br i1 %cmp5534, label %cond.true.5662, label %lor.lhs.false.5645

cond.false.5536:                                  ; preds = %cond.true.5505
  br i1 false, label %cond.true.5537, label %cond.false.5538

cond.true.5537:                                   ; preds = %cond.false.5536
  br i1 false, label %cond.true.5662, label %lor.lhs.false.5645

cond.false.5538:                                  ; preds = %cond.false.5536
  %988 = load i64, i64* %numargs, align 8
  %add5539 = add nsw i64 1, %988
  %add5540 = add nsw i64 0, %add5539
  %mul5541 = mul nsw i64 0, %add5540
  %sub5542 = sub nsw i64 %mul5541, 1
  %cmp5543 = icmp slt i64 %sub5542, 0
  br i1 %cmp5543, label %cond.true.5545, label %cond.false.5564

cond.true.5545:                                   ; preds = %cond.false.5538
  %989 = load i64, i64* %numargs, align 8
  %add5546 = add nsw i64 1, %989
  %add5547 = add nsw i64 0, %add5546
  %mul5548 = mul nsw i64 0, %add5547
  %add5549 = add nsw i64 %mul5548, 0
  %neg5550 = xor i64 %add5549, -1
  %cmp5551 = icmp eq i64 %neg5550, -1
  %conv5552 = zext i1 %cmp5551 to i32
  %sub5553 = sub nsw i32 0, %conv5552
  %conv5554 = sext i32 %sub5553 to i64
  %990 = load i64, i64* %numargs, align 8
  %add5555 = add nsw i64 1, %990
  %add5556 = add nsw i64 0, %add5555
  %mul5557 = mul nsw i64 0, %add5556
  %add5558 = add nsw i64 %mul5557, 1
  %shl5559 = shl i64 %add5558, 62
  %sub5560 = sub nsw i64 %shl5559, 1
  %mul5561 = mul nsw i64 %sub5560, 2
  %add5562 = add nsw i64 %mul5561, 1
  %sub5563 = sub nsw i64 %conv5554, %add5562
  br label %cond.end.5569

cond.false.5564:                                  ; preds = %cond.false.5538
  %991 = load i64, i64* %numargs, align 8
  %add5565 = add nsw i64 1, %991
  %add5566 = add nsw i64 0, %add5565
  %mul5567 = mul nsw i64 0, %add5566
  %add5568 = add nsw i64 %mul5567, 0
  br label %cond.end.5569

cond.end.5569:                                    ; preds = %cond.false.5564, %cond.true.5545
  %cond5570 = phi i64 [ %sub5563, %cond.true.5545 ], [ %add5568, %cond.false.5564 ]
  %div5571 = sdiv i64 %cond5570, 8
  %992 = load i64, i64* %numargs, align 8
  %add5572 = add nsw i64 1, %992
  %cmp5573 = icmp slt i64 %div5571, %add5572
  br i1 %cmp5573, label %cond.true.5662, label %lor.lhs.false.5645

cond.false.5575:                                  ; preds = %lor.lhs.false.5504
  br i1 false, label %cond.true.5576, label %cond.false.5577

cond.true.5576:                                   ; preds = %cond.false.5575
  br i1 false, label %cond.true.5662, label %lor.lhs.false.5645

cond.false.5577:                                  ; preds = %cond.false.5575
  %993 = load i64, i64* %numargs, align 8
  %add5578 = add nsw i64 1, %993
  %cmp5579 = icmp slt i64 %add5578, 0
  br i1 %cmp5579, label %cond.true.5581, label %cond.false.5618

cond.true.5581:                                   ; preds = %cond.false.5577
  %994 = load i64, i64* %numargs, align 8
  %add5582 = add nsw i64 1, %994
  %995 = load i64, i64* %numargs, align 8
  %add5583 = add nsw i64 1, %995
  %add5584 = add nsw i64 0, %add5583
  %mul5585 = mul nsw i64 0, %add5584
  %sub5586 = sub nsw i64 %mul5585, 1
  %cmp5587 = icmp slt i64 %sub5586, 0
  br i1 %cmp5587, label %cond.true.5589, label %cond.false.5608

cond.true.5589:                                   ; preds = %cond.true.5581
  %996 = load i64, i64* %numargs, align 8
  %add5590 = add nsw i64 1, %996
  %add5591 = add nsw i64 0, %add5590
  %mul5592 = mul nsw i64 0, %add5591
  %add5593 = add nsw i64 %mul5592, 0
  %neg5594 = xor i64 %add5593, -1
  %cmp5595 = icmp eq i64 %neg5594, -1
  %conv5596 = zext i1 %cmp5595 to i32
  %sub5597 = sub nsw i32 0, %conv5596
  %conv5598 = sext i32 %sub5597 to i64
  %997 = load i64, i64* %numargs, align 8
  %add5599 = add nsw i64 1, %997
  %add5600 = add nsw i64 0, %add5599
  %mul5601 = mul nsw i64 0, %add5600
  %add5602 = add nsw i64 %mul5601, 1
  %shl5603 = shl i64 %add5602, 62
  %sub5604 = sub nsw i64 %shl5603, 1
  %mul5605 = mul nsw i64 %sub5604, 2
  %add5606 = add nsw i64 %mul5605, 1
  %sub5607 = sub nsw i64 %conv5598, %add5606
  br label %cond.end.5613

cond.false.5608:                                  ; preds = %cond.true.5581
  %998 = load i64, i64* %numargs, align 8
  %add5609 = add nsw i64 1, %998
  %add5610 = add nsw i64 0, %add5609
  %mul5611 = mul nsw i64 0, %add5610
  %add5612 = add nsw i64 %mul5611, 0
  br label %cond.end.5613

cond.end.5613:                                    ; preds = %cond.false.5608, %cond.true.5589
  %cond5614 = phi i64 [ %sub5607, %cond.true.5589 ], [ %add5612, %cond.false.5608 ]
  %div5615 = sdiv i64 %cond5614, 8
  %cmp5616 = icmp slt i64 %add5582, %div5615
  br i1 %cmp5616, label %cond.true.5662, label %lor.lhs.false.5645

cond.false.5618:                                  ; preds = %cond.false.5577
  %999 = load i64, i64* %numargs, align 8
  %add5619 = add nsw i64 1, %999
  %add5620 = add nsw i64 0, %add5619
  %mul5621 = mul nsw i64 0, %add5620
  %sub5622 = sub nsw i64 %mul5621, 1
  %cmp5623 = icmp slt i64 %sub5622, 0
  br i1 %cmp5623, label %cond.true.5625, label %cond.false.5634

cond.true.5625:                                   ; preds = %cond.false.5618
  %1000 = load i64, i64* %numargs, align 8
  %add5626 = add nsw i64 1, %1000
  %add5627 = add nsw i64 0, %add5626
  %mul5628 = mul nsw i64 0, %add5627
  %add5629 = add nsw i64 %mul5628, 1
  %shl5630 = shl i64 %add5629, 62
  %sub5631 = sub nsw i64 %shl5630, 1
  %mul5632 = mul nsw i64 %sub5631, 2
  %add5633 = add nsw i64 %mul5632, 1
  br label %cond.end.5639

cond.false.5634:                                  ; preds = %cond.false.5618
  %1001 = load i64, i64* %numargs, align 8
  %add5635 = add nsw i64 1, %1001
  %add5636 = add nsw i64 0, %add5635
  %mul5637 = mul nsw i64 0, %add5636
  %sub5638 = sub nsw i64 %mul5637, 1
  br label %cond.end.5639

cond.end.5639:                                    ; preds = %cond.false.5634, %cond.true.5625
  %cond5640 = phi i64 [ %add5633, %cond.true.5625 ], [ %sub5638, %cond.false.5634 ]
  %div5641 = sdiv i64 %cond5640, 8
  %1002 = load i64, i64* %numargs, align 8
  %add5642 = add nsw i64 1, %1002
  %cmp5643 = icmp slt i64 %div5641, %add5642
  br i1 %cmp5643, label %cond.true.5662, label %lor.lhs.false.5645

lor.lhs.false.5645:                               ; preds = %cond.end.5639, %cond.end.5613, %cond.true.5576, %cond.end.5569, %cond.true.5537, %cond.end.5531
  %1003 = load i64, i64* %numargs, align 8
  %add5646 = add nsw i64 1, %1003
  %mul5647 = mul nsw i64 %add5646, 8
  %mul5648 = mul nsw i64 0, %mul5647
  %sub5649 = sub nsw i64 %mul5648, 1
  %cmp5650 = icmp slt i64 %sub5649, 0
  br i1 %cmp5650, label %land.lhs.true.5652, label %lor.lhs.false.5657

land.lhs.true.5652:                               ; preds = %lor.lhs.false.5645
  %1004 = load i64, i64* %numargs, align 8
  %add5653 = add nsw i64 1, %1004
  %mul5654 = mul nsw i64 %add5653, 8
  %cmp5655 = icmp slt i64 %mul5654, -9223372036854775808
  br i1 %cmp5655, label %cond.true.5662, label %lor.lhs.false.5657

lor.lhs.false.5657:                               ; preds = %land.lhs.true.5652, %lor.lhs.false.5645
  %1005 = load i64, i64* %numargs, align 8
  %add5658 = add nsw i64 1, %1005
  %mul5659 = mul nsw i64 %add5658, 8
  %cmp5660 = icmp slt i64 9223372036854775807, %mul5659
  br i1 %cmp5660, label %cond.true.5662, label %cond.false.5677

cond.true.5662:                                   ; preds = %lor.lhs.false.5657, %land.lhs.true.5652, %cond.end.5639, %cond.end.5613, %cond.true.5576, %cond.end.5569, %cond.true.5537, %cond.end.5531, %land.lhs.true.5500
  %1006 = load i64, i64* %numargs, align 8
  %add5663 = add nsw i64 1, %1006
  %mul5664 = mul i64 %add5663, 8
  %cmp5665 = icmp ule i64 %mul5664, 9223372036854775807
  br i1 %cmp5665, label %cond.true.5667, label %cond.false.5670

cond.true.5667:                                   ; preds = %cond.true.5662
  %1007 = load i64, i64* %numargs, align 8
  %add5668 = add nsw i64 1, %1007
  %mul5669 = mul i64 %add5668, 8
  br label %cond.end.5675

cond.false.5670:                                  ; preds = %cond.true.5662
  %1008 = load i64, i64* %numargs, align 8
  %add5671 = add nsw i64 1, %1008
  %mul5672 = mul i64 %add5671, 8
  %sub5673 = sub i64 %mul5672, -9223372036854775808
  %add5674 = add nsw i64 %sub5673, -9223372036854775808
  br label %cond.end.5675

cond.end.5675:                                    ; preds = %cond.false.5670, %cond.true.5667
  %cond5676 = phi i64 [ %mul5669, %cond.true.5667 ], [ %add5674, %cond.false.5670 ]
  store i64 %cond5676, i64* %alloca_nbytes3633, align 8
  br i1 true, label %if.then.6150, label %lor.lhs.false.6147

cond.false.5677:                                  ; preds = %lor.lhs.false.5657
  %1009 = load i64, i64* %numargs, align 8
  %add5678 = add nsw i64 1, %1009
  %mul5679 = mul i64 %add5678, 8
  %cmp5680 = icmp ule i64 %mul5679, 9223372036854775807
  br i1 %cmp5680, label %cond.true.5682, label %cond.false.5685

cond.true.5682:                                   ; preds = %cond.false.5677
  %1010 = load i64, i64* %numargs, align 8
  %add5683 = add nsw i64 1, %1010
  %mul5684 = mul i64 %add5683, 8
  br label %cond.end.5690

cond.false.5685:                                  ; preds = %cond.false.5677
  %1011 = load i64, i64* %numargs, align 8
  %add5686 = add nsw i64 1, %1011
  %mul5687 = mul i64 %add5686, 8
  %sub5688 = sub i64 %mul5687, -9223372036854775808
  %add5689 = add nsw i64 %sub5688, -9223372036854775808
  br label %cond.end.5690

cond.end.5690:                                    ; preds = %cond.false.5685, %cond.true.5682
  %cond5691 = phi i64 [ %mul5684, %cond.true.5682 ], [ %add5689, %cond.false.5685 ]
  store i64 %cond5691, i64* %alloca_nbytes3633, align 8
  br i1 false, label %if.then.6150, label %lor.lhs.false.6147

cond.false.5692:                                  ; preds = %cond.false.5236
  br i1 false, label %cond.true.5693, label %cond.false.5920

cond.true.5693:                                   ; preds = %cond.false.5692
  %1012 = load i64, i64* %numargs, align 8
  %add5694 = add nsw i64 1, %1012
  %add5695 = add nsw i64 0, %add5694
  %mul5696 = mul nsw i64 0, %add5695
  %sub5697 = sub nsw i64 %mul5696, 1
  %cmp5698 = icmp slt i64 %sub5697, 0
  br i1 %cmp5698, label %cond.true.5700, label %cond.false.5719

cond.true.5700:                                   ; preds = %cond.true.5693
  %1013 = load i64, i64* %numargs, align 8
  %add5701 = add nsw i64 1, %1013
  %add5702 = add nsw i64 0, %add5701
  %mul5703 = mul nsw i64 0, %add5702
  %add5704 = add nsw i64 %mul5703, 0
  %neg5705 = xor i64 %add5704, -1
  %cmp5706 = icmp eq i64 %neg5705, -1
  %conv5707 = zext i1 %cmp5706 to i32
  %sub5708 = sub nsw i32 0, %conv5707
  %conv5709 = sext i32 %sub5708 to i64
  %1014 = load i64, i64* %numargs, align 8
  %add5710 = add nsw i64 1, %1014
  %add5711 = add nsw i64 0, %add5710
  %mul5712 = mul nsw i64 0, %add5711
  %add5713 = add nsw i64 %mul5712, 1
  %shl5714 = shl i64 %add5713, 62
  %sub5715 = sub nsw i64 %shl5714, 1
  %mul5716 = mul nsw i64 %sub5715, 2
  %add5717 = add nsw i64 %mul5716, 1
  %sub5718 = sub nsw i64 %conv5709, %add5717
  br label %cond.end.5724

cond.false.5719:                                  ; preds = %cond.true.5693
  %1015 = load i64, i64* %numargs, align 8
  %add5720 = add nsw i64 1, %1015
  %add5721 = add nsw i64 0, %add5720
  %mul5722 = mul nsw i64 0, %add5721
  %add5723 = add nsw i64 %mul5722, 0
  br label %cond.end.5724

cond.end.5724:                                    ; preds = %cond.false.5719, %cond.true.5700
  %cond5725 = phi i64 [ %sub5718, %cond.true.5700 ], [ %add5723, %cond.false.5719 ]
  %cmp5726 = icmp eq i64 %cond5725, 0
  br i1 %cmp5726, label %land.lhs.true.5728, label %lor.lhs.false.5732

land.lhs.true.5728:                               ; preds = %cond.end.5724
  %1016 = load i64, i64* %numargs, align 8
  %add5729 = add nsw i64 1, %1016
  %cmp5730 = icmp slt i64 %add5729, 0
  br i1 %cmp5730, label %cond.true.5890, label %lor.lhs.false.5732

lor.lhs.false.5732:                               ; preds = %land.lhs.true.5728, %cond.end.5724
  br i1 false, label %cond.true.5733, label %cond.false.5803

cond.true.5733:                                   ; preds = %lor.lhs.false.5732
  %1017 = load i64, i64* %numargs, align 8
  %add5734 = add nsw i64 1, %1017
  %cmp5735 = icmp slt i64 %add5734, 0
  br i1 %cmp5735, label %cond.true.5737, label %cond.false.5764

cond.true.5737:                                   ; preds = %cond.true.5733
  %1018 = load i64, i64* %numargs, align 8
  %add5738 = add nsw i64 1, %1018
  %1019 = load i64, i64* %numargs, align 8
  %add5739 = add nsw i64 1, %1019
  %add5740 = add nsw i64 0, %add5739
  %mul5741 = mul nsw i64 0, %add5740
  %sub5742 = sub nsw i64 %mul5741, 1
  %cmp5743 = icmp slt i64 %sub5742, 0
  br i1 %cmp5743, label %cond.true.5745, label %cond.false.5754

cond.true.5745:                                   ; preds = %cond.true.5737
  %1020 = load i64, i64* %numargs, align 8
  %add5746 = add nsw i64 1, %1020
  %add5747 = add nsw i64 0, %add5746
  %mul5748 = mul nsw i64 0, %add5747
  %add5749 = add nsw i64 %mul5748, 1
  %shl5750 = shl i64 %add5749, 62
  %sub5751 = sub nsw i64 %shl5750, 1
  %mul5752 = mul nsw i64 %sub5751, 2
  %add5753 = add nsw i64 %mul5752, 1
  br label %cond.end.5759

cond.false.5754:                                  ; preds = %cond.true.5737
  %1021 = load i64, i64* %numargs, align 8
  %add5755 = add nsw i64 1, %1021
  %add5756 = add nsw i64 0, %add5755
  %mul5757 = mul nsw i64 0, %add5756
  %sub5758 = sub nsw i64 %mul5757, 1
  br label %cond.end.5759

cond.end.5759:                                    ; preds = %cond.false.5754, %cond.true.5745
  %cond5760 = phi i64 [ %add5753, %cond.true.5745 ], [ %sub5758, %cond.false.5754 ]
  %div5761 = sdiv i64 %cond5760, 8
  %cmp5762 = icmp slt i64 %add5738, %div5761
  br i1 %cmp5762, label %cond.true.5890, label %lor.lhs.false.5873

cond.false.5764:                                  ; preds = %cond.true.5733
  br i1 false, label %cond.true.5765, label %cond.false.5766

cond.true.5765:                                   ; preds = %cond.false.5764
  br i1 false, label %cond.true.5890, label %lor.lhs.false.5873

cond.false.5766:                                  ; preds = %cond.false.5764
  %1022 = load i64, i64* %numargs, align 8
  %add5767 = add nsw i64 1, %1022
  %add5768 = add nsw i64 0, %add5767
  %mul5769 = mul nsw i64 0, %add5768
  %sub5770 = sub nsw i64 %mul5769, 1
  %cmp5771 = icmp slt i64 %sub5770, 0
  br i1 %cmp5771, label %cond.true.5773, label %cond.false.5792

cond.true.5773:                                   ; preds = %cond.false.5766
  %1023 = load i64, i64* %numargs, align 8
  %add5774 = add nsw i64 1, %1023
  %add5775 = add nsw i64 0, %add5774
  %mul5776 = mul nsw i64 0, %add5775
  %add5777 = add nsw i64 %mul5776, 0
  %neg5778 = xor i64 %add5777, -1
  %cmp5779 = icmp eq i64 %neg5778, -1
  %conv5780 = zext i1 %cmp5779 to i32
  %sub5781 = sub nsw i32 0, %conv5780
  %conv5782 = sext i32 %sub5781 to i64
  %1024 = load i64, i64* %numargs, align 8
  %add5783 = add nsw i64 1, %1024
  %add5784 = add nsw i64 0, %add5783
  %mul5785 = mul nsw i64 0, %add5784
  %add5786 = add nsw i64 %mul5785, 1
  %shl5787 = shl i64 %add5786, 62
  %sub5788 = sub nsw i64 %shl5787, 1
  %mul5789 = mul nsw i64 %sub5788, 2
  %add5790 = add nsw i64 %mul5789, 1
  %sub5791 = sub nsw i64 %conv5782, %add5790
  br label %cond.end.5797

cond.false.5792:                                  ; preds = %cond.false.5766
  %1025 = load i64, i64* %numargs, align 8
  %add5793 = add nsw i64 1, %1025
  %add5794 = add nsw i64 0, %add5793
  %mul5795 = mul nsw i64 0, %add5794
  %add5796 = add nsw i64 %mul5795, 0
  br label %cond.end.5797

cond.end.5797:                                    ; preds = %cond.false.5792, %cond.true.5773
  %cond5798 = phi i64 [ %sub5791, %cond.true.5773 ], [ %add5796, %cond.false.5792 ]
  %div5799 = sdiv i64 %cond5798, 8
  %1026 = load i64, i64* %numargs, align 8
  %add5800 = add nsw i64 1, %1026
  %cmp5801 = icmp slt i64 %div5799, %add5800
  br i1 %cmp5801, label %cond.true.5890, label %lor.lhs.false.5873

cond.false.5803:                                  ; preds = %lor.lhs.false.5732
  br i1 false, label %cond.true.5804, label %cond.false.5805

cond.true.5804:                                   ; preds = %cond.false.5803
  br i1 false, label %cond.true.5890, label %lor.lhs.false.5873

cond.false.5805:                                  ; preds = %cond.false.5803
  %1027 = load i64, i64* %numargs, align 8
  %add5806 = add nsw i64 1, %1027
  %cmp5807 = icmp slt i64 %add5806, 0
  br i1 %cmp5807, label %cond.true.5809, label %cond.false.5846

cond.true.5809:                                   ; preds = %cond.false.5805
  %1028 = load i64, i64* %numargs, align 8
  %add5810 = add nsw i64 1, %1028
  %1029 = load i64, i64* %numargs, align 8
  %add5811 = add nsw i64 1, %1029
  %add5812 = add nsw i64 0, %add5811
  %mul5813 = mul nsw i64 0, %add5812
  %sub5814 = sub nsw i64 %mul5813, 1
  %cmp5815 = icmp slt i64 %sub5814, 0
  br i1 %cmp5815, label %cond.true.5817, label %cond.false.5836

cond.true.5817:                                   ; preds = %cond.true.5809
  %1030 = load i64, i64* %numargs, align 8
  %add5818 = add nsw i64 1, %1030
  %add5819 = add nsw i64 0, %add5818
  %mul5820 = mul nsw i64 0, %add5819
  %add5821 = add nsw i64 %mul5820, 0
  %neg5822 = xor i64 %add5821, -1
  %cmp5823 = icmp eq i64 %neg5822, -1
  %conv5824 = zext i1 %cmp5823 to i32
  %sub5825 = sub nsw i32 0, %conv5824
  %conv5826 = sext i32 %sub5825 to i64
  %1031 = load i64, i64* %numargs, align 8
  %add5827 = add nsw i64 1, %1031
  %add5828 = add nsw i64 0, %add5827
  %mul5829 = mul nsw i64 0, %add5828
  %add5830 = add nsw i64 %mul5829, 1
  %shl5831 = shl i64 %add5830, 62
  %sub5832 = sub nsw i64 %shl5831, 1
  %mul5833 = mul nsw i64 %sub5832, 2
  %add5834 = add nsw i64 %mul5833, 1
  %sub5835 = sub nsw i64 %conv5826, %add5834
  br label %cond.end.5841

cond.false.5836:                                  ; preds = %cond.true.5809
  %1032 = load i64, i64* %numargs, align 8
  %add5837 = add nsw i64 1, %1032
  %add5838 = add nsw i64 0, %add5837
  %mul5839 = mul nsw i64 0, %add5838
  %add5840 = add nsw i64 %mul5839, 0
  br label %cond.end.5841

cond.end.5841:                                    ; preds = %cond.false.5836, %cond.true.5817
  %cond5842 = phi i64 [ %sub5835, %cond.true.5817 ], [ %add5840, %cond.false.5836 ]
  %div5843 = sdiv i64 %cond5842, 8
  %cmp5844 = icmp slt i64 %add5810, %div5843
  br i1 %cmp5844, label %cond.true.5890, label %lor.lhs.false.5873

cond.false.5846:                                  ; preds = %cond.false.5805
  %1033 = load i64, i64* %numargs, align 8
  %add5847 = add nsw i64 1, %1033
  %add5848 = add nsw i64 0, %add5847
  %mul5849 = mul nsw i64 0, %add5848
  %sub5850 = sub nsw i64 %mul5849, 1
  %cmp5851 = icmp slt i64 %sub5850, 0
  br i1 %cmp5851, label %cond.true.5853, label %cond.false.5862

cond.true.5853:                                   ; preds = %cond.false.5846
  %1034 = load i64, i64* %numargs, align 8
  %add5854 = add nsw i64 1, %1034
  %add5855 = add nsw i64 0, %add5854
  %mul5856 = mul nsw i64 0, %add5855
  %add5857 = add nsw i64 %mul5856, 1
  %shl5858 = shl i64 %add5857, 62
  %sub5859 = sub nsw i64 %shl5858, 1
  %mul5860 = mul nsw i64 %sub5859, 2
  %add5861 = add nsw i64 %mul5860, 1
  br label %cond.end.5867

cond.false.5862:                                  ; preds = %cond.false.5846
  %1035 = load i64, i64* %numargs, align 8
  %add5863 = add nsw i64 1, %1035
  %add5864 = add nsw i64 0, %add5863
  %mul5865 = mul nsw i64 0, %add5864
  %sub5866 = sub nsw i64 %mul5865, 1
  br label %cond.end.5867

cond.end.5867:                                    ; preds = %cond.false.5862, %cond.true.5853
  %cond5868 = phi i64 [ %add5861, %cond.true.5853 ], [ %sub5866, %cond.false.5862 ]
  %div5869 = sdiv i64 %cond5868, 8
  %1036 = load i64, i64* %numargs, align 8
  %add5870 = add nsw i64 1, %1036
  %cmp5871 = icmp slt i64 %div5869, %add5870
  br i1 %cmp5871, label %cond.true.5890, label %lor.lhs.false.5873

lor.lhs.false.5873:                               ; preds = %cond.end.5867, %cond.end.5841, %cond.true.5804, %cond.end.5797, %cond.true.5765, %cond.end.5759
  %1037 = load i64, i64* %numargs, align 8
  %add5874 = add nsw i64 1, %1037
  %mul5875 = mul nsw i64 %add5874, 8
  %mul5876 = mul nsw i64 0, %mul5875
  %sub5877 = sub nsw i64 %mul5876, 1
  %cmp5878 = icmp slt i64 %sub5877, 0
  br i1 %cmp5878, label %land.lhs.true.5880, label %lor.lhs.false.5885

land.lhs.true.5880:                               ; preds = %lor.lhs.false.5873
  %1038 = load i64, i64* %numargs, align 8
  %add5881 = add nsw i64 1, %1038
  %mul5882 = mul nsw i64 %add5881, 8
  %cmp5883 = icmp slt i64 %mul5882, -9223372036854775808
  br i1 %cmp5883, label %cond.true.5890, label %lor.lhs.false.5885

lor.lhs.false.5885:                               ; preds = %land.lhs.true.5880, %lor.lhs.false.5873
  %1039 = load i64, i64* %numargs, align 8
  %add5886 = add nsw i64 1, %1039
  %mul5887 = mul nsw i64 %add5886, 8
  %cmp5888 = icmp slt i64 9223372036854775807, %mul5887
  br i1 %cmp5888, label %cond.true.5890, label %cond.false.5905

cond.true.5890:                                   ; preds = %lor.lhs.false.5885, %land.lhs.true.5880, %cond.end.5867, %cond.end.5841, %cond.true.5804, %cond.end.5797, %cond.true.5765, %cond.end.5759, %land.lhs.true.5728
  %1040 = load i64, i64* %numargs, align 8
  %add5891 = add nsw i64 1, %1040
  %mul5892 = mul i64 %add5891, 8
  %cmp5893 = icmp ule i64 %mul5892, 9223372036854775807
  br i1 %cmp5893, label %cond.true.5895, label %cond.false.5898

cond.true.5895:                                   ; preds = %cond.true.5890
  %1041 = load i64, i64* %numargs, align 8
  %add5896 = add nsw i64 1, %1041
  %mul5897 = mul i64 %add5896, 8
  br label %cond.end.5903

cond.false.5898:                                  ; preds = %cond.true.5890
  %1042 = load i64, i64* %numargs, align 8
  %add5899 = add nsw i64 1, %1042
  %mul5900 = mul i64 %add5899, 8
  %sub5901 = sub i64 %mul5900, -9223372036854775808
  %add5902 = add nsw i64 %sub5901, -9223372036854775808
  br label %cond.end.5903

cond.end.5903:                                    ; preds = %cond.false.5898, %cond.true.5895
  %cond5904 = phi i64 [ %mul5897, %cond.true.5895 ], [ %add5902, %cond.false.5898 ]
  store i64 %cond5904, i64* %alloca_nbytes3633, align 8
  br i1 true, label %if.then.6150, label %lor.lhs.false.6147

cond.false.5905:                                  ; preds = %lor.lhs.false.5885
  %1043 = load i64, i64* %numargs, align 8
  %add5906 = add nsw i64 1, %1043
  %mul5907 = mul i64 %add5906, 8
  %cmp5908 = icmp ule i64 %mul5907, 9223372036854775807
  br i1 %cmp5908, label %cond.true.5910, label %cond.false.5913

cond.true.5910:                                   ; preds = %cond.false.5905
  %1044 = load i64, i64* %numargs, align 8
  %add5911 = add nsw i64 1, %1044
  %mul5912 = mul i64 %add5911, 8
  br label %cond.end.5918

cond.false.5913:                                  ; preds = %cond.false.5905
  %1045 = load i64, i64* %numargs, align 8
  %add5914 = add nsw i64 1, %1045
  %mul5915 = mul i64 %add5914, 8
  %sub5916 = sub i64 %mul5915, -9223372036854775808
  %add5917 = add nsw i64 %sub5916, -9223372036854775808
  br label %cond.end.5918

cond.end.5918:                                    ; preds = %cond.false.5913, %cond.true.5910
  %cond5919 = phi i64 [ %mul5912, %cond.true.5910 ], [ %add5917, %cond.false.5913 ]
  store i64 %cond5919, i64* %alloca_nbytes3633, align 8
  br i1 false, label %if.then.6150, label %lor.lhs.false.6147

cond.false.5920:                                  ; preds = %cond.false.5692
  %1046 = load i64, i64* %numargs, align 8
  %add5921 = add nsw i64 1, %1046
  %add5922 = add nsw i64 0, %add5921
  %mul5923 = mul nsw i64 0, %add5922
  %sub5924 = sub nsw i64 %mul5923, 1
  %cmp5925 = icmp slt i64 %sub5924, 0
  br i1 %cmp5925, label %cond.true.5927, label %cond.false.5946

cond.true.5927:                                   ; preds = %cond.false.5920
  %1047 = load i64, i64* %numargs, align 8
  %add5928 = add nsw i64 1, %1047
  %add5929 = add nsw i64 0, %add5928
  %mul5930 = mul nsw i64 0, %add5929
  %add5931 = add nsw i64 %mul5930, 0
  %neg5932 = xor i64 %add5931, -1
  %cmp5933 = icmp eq i64 %neg5932, -1
  %conv5934 = zext i1 %cmp5933 to i32
  %sub5935 = sub nsw i32 0, %conv5934
  %conv5936 = sext i32 %sub5935 to i64
  %1048 = load i64, i64* %numargs, align 8
  %add5937 = add nsw i64 1, %1048
  %add5938 = add nsw i64 0, %add5937
  %mul5939 = mul nsw i64 0, %add5938
  %add5940 = add nsw i64 %mul5939, 1
  %shl5941 = shl i64 %add5940, 62
  %sub5942 = sub nsw i64 %shl5941, 1
  %mul5943 = mul nsw i64 %sub5942, 2
  %add5944 = add nsw i64 %mul5943, 1
  %sub5945 = sub nsw i64 %conv5936, %add5944
  br label %cond.end.5951

cond.false.5946:                                  ; preds = %cond.false.5920
  %1049 = load i64, i64* %numargs, align 8
  %add5947 = add nsw i64 1, %1049
  %add5948 = add nsw i64 0, %add5947
  %mul5949 = mul nsw i64 0, %add5948
  %add5950 = add nsw i64 %mul5949, 0
  br label %cond.end.5951

cond.end.5951:                                    ; preds = %cond.false.5946, %cond.true.5927
  %cond5952 = phi i64 [ %sub5945, %cond.true.5927 ], [ %add5950, %cond.false.5946 ]
  %cmp5953 = icmp eq i64 %cond5952, 0
  br i1 %cmp5953, label %land.lhs.true.5955, label %lor.lhs.false.5959

land.lhs.true.5955:                               ; preds = %cond.end.5951
  %1050 = load i64, i64* %numargs, align 8
  %add5956 = add nsw i64 1, %1050
  %cmp5957 = icmp slt i64 %add5956, 0
  br i1 %cmp5957, label %cond.true.6117, label %lor.lhs.false.5959

lor.lhs.false.5959:                               ; preds = %land.lhs.true.5955, %cond.end.5951
  br i1 false, label %cond.true.5960, label %cond.false.6030

cond.true.5960:                                   ; preds = %lor.lhs.false.5959
  %1051 = load i64, i64* %numargs, align 8
  %add5961 = add nsw i64 1, %1051
  %cmp5962 = icmp slt i64 %add5961, 0
  br i1 %cmp5962, label %cond.true.5964, label %cond.false.5991

cond.true.5964:                                   ; preds = %cond.true.5960
  %1052 = load i64, i64* %numargs, align 8
  %add5965 = add nsw i64 1, %1052
  %1053 = load i64, i64* %numargs, align 8
  %add5966 = add nsw i64 1, %1053
  %add5967 = add nsw i64 0, %add5966
  %mul5968 = mul nsw i64 0, %add5967
  %sub5969 = sub nsw i64 %mul5968, 1
  %cmp5970 = icmp slt i64 %sub5969, 0
  br i1 %cmp5970, label %cond.true.5972, label %cond.false.5981

cond.true.5972:                                   ; preds = %cond.true.5964
  %1054 = load i64, i64* %numargs, align 8
  %add5973 = add nsw i64 1, %1054
  %add5974 = add nsw i64 0, %add5973
  %mul5975 = mul nsw i64 0, %add5974
  %add5976 = add nsw i64 %mul5975, 1
  %shl5977 = shl i64 %add5976, 62
  %sub5978 = sub nsw i64 %shl5977, 1
  %mul5979 = mul nsw i64 %sub5978, 2
  %add5980 = add nsw i64 %mul5979, 1
  br label %cond.end.5986

cond.false.5981:                                  ; preds = %cond.true.5964
  %1055 = load i64, i64* %numargs, align 8
  %add5982 = add nsw i64 1, %1055
  %add5983 = add nsw i64 0, %add5982
  %mul5984 = mul nsw i64 0, %add5983
  %sub5985 = sub nsw i64 %mul5984, 1
  br label %cond.end.5986

cond.end.5986:                                    ; preds = %cond.false.5981, %cond.true.5972
  %cond5987 = phi i64 [ %add5980, %cond.true.5972 ], [ %sub5985, %cond.false.5981 ]
  %div5988 = sdiv i64 %cond5987, 8
  %cmp5989 = icmp slt i64 %add5965, %div5988
  br i1 %cmp5989, label %cond.true.6117, label %lor.lhs.false.6100

cond.false.5991:                                  ; preds = %cond.true.5960
  br i1 false, label %cond.true.5992, label %cond.false.5993

cond.true.5992:                                   ; preds = %cond.false.5991
  br i1 false, label %cond.true.6117, label %lor.lhs.false.6100

cond.false.5993:                                  ; preds = %cond.false.5991
  %1056 = load i64, i64* %numargs, align 8
  %add5994 = add nsw i64 1, %1056
  %add5995 = add nsw i64 0, %add5994
  %mul5996 = mul nsw i64 0, %add5995
  %sub5997 = sub nsw i64 %mul5996, 1
  %cmp5998 = icmp slt i64 %sub5997, 0
  br i1 %cmp5998, label %cond.true.6000, label %cond.false.6019

cond.true.6000:                                   ; preds = %cond.false.5993
  %1057 = load i64, i64* %numargs, align 8
  %add6001 = add nsw i64 1, %1057
  %add6002 = add nsw i64 0, %add6001
  %mul6003 = mul nsw i64 0, %add6002
  %add6004 = add nsw i64 %mul6003, 0
  %neg6005 = xor i64 %add6004, -1
  %cmp6006 = icmp eq i64 %neg6005, -1
  %conv6007 = zext i1 %cmp6006 to i32
  %sub6008 = sub nsw i32 0, %conv6007
  %conv6009 = sext i32 %sub6008 to i64
  %1058 = load i64, i64* %numargs, align 8
  %add6010 = add nsw i64 1, %1058
  %add6011 = add nsw i64 0, %add6010
  %mul6012 = mul nsw i64 0, %add6011
  %add6013 = add nsw i64 %mul6012, 1
  %shl6014 = shl i64 %add6013, 62
  %sub6015 = sub nsw i64 %shl6014, 1
  %mul6016 = mul nsw i64 %sub6015, 2
  %add6017 = add nsw i64 %mul6016, 1
  %sub6018 = sub nsw i64 %conv6009, %add6017
  br label %cond.end.6024

cond.false.6019:                                  ; preds = %cond.false.5993
  %1059 = load i64, i64* %numargs, align 8
  %add6020 = add nsw i64 1, %1059
  %add6021 = add nsw i64 0, %add6020
  %mul6022 = mul nsw i64 0, %add6021
  %add6023 = add nsw i64 %mul6022, 0
  br label %cond.end.6024

cond.end.6024:                                    ; preds = %cond.false.6019, %cond.true.6000
  %cond6025 = phi i64 [ %sub6018, %cond.true.6000 ], [ %add6023, %cond.false.6019 ]
  %div6026 = sdiv i64 %cond6025, 8
  %1060 = load i64, i64* %numargs, align 8
  %add6027 = add nsw i64 1, %1060
  %cmp6028 = icmp slt i64 %div6026, %add6027
  br i1 %cmp6028, label %cond.true.6117, label %lor.lhs.false.6100

cond.false.6030:                                  ; preds = %lor.lhs.false.5959
  br i1 false, label %cond.true.6031, label %cond.false.6032

cond.true.6031:                                   ; preds = %cond.false.6030
  br i1 false, label %cond.true.6117, label %lor.lhs.false.6100

cond.false.6032:                                  ; preds = %cond.false.6030
  %1061 = load i64, i64* %numargs, align 8
  %add6033 = add nsw i64 1, %1061
  %cmp6034 = icmp slt i64 %add6033, 0
  br i1 %cmp6034, label %cond.true.6036, label %cond.false.6073

cond.true.6036:                                   ; preds = %cond.false.6032
  %1062 = load i64, i64* %numargs, align 8
  %add6037 = add nsw i64 1, %1062
  %1063 = load i64, i64* %numargs, align 8
  %add6038 = add nsw i64 1, %1063
  %add6039 = add nsw i64 0, %add6038
  %mul6040 = mul nsw i64 0, %add6039
  %sub6041 = sub nsw i64 %mul6040, 1
  %cmp6042 = icmp slt i64 %sub6041, 0
  br i1 %cmp6042, label %cond.true.6044, label %cond.false.6063

cond.true.6044:                                   ; preds = %cond.true.6036
  %1064 = load i64, i64* %numargs, align 8
  %add6045 = add nsw i64 1, %1064
  %add6046 = add nsw i64 0, %add6045
  %mul6047 = mul nsw i64 0, %add6046
  %add6048 = add nsw i64 %mul6047, 0
  %neg6049 = xor i64 %add6048, -1
  %cmp6050 = icmp eq i64 %neg6049, -1
  %conv6051 = zext i1 %cmp6050 to i32
  %sub6052 = sub nsw i32 0, %conv6051
  %conv6053 = sext i32 %sub6052 to i64
  %1065 = load i64, i64* %numargs, align 8
  %add6054 = add nsw i64 1, %1065
  %add6055 = add nsw i64 0, %add6054
  %mul6056 = mul nsw i64 0, %add6055
  %add6057 = add nsw i64 %mul6056, 1
  %shl6058 = shl i64 %add6057, 62
  %sub6059 = sub nsw i64 %shl6058, 1
  %mul6060 = mul nsw i64 %sub6059, 2
  %add6061 = add nsw i64 %mul6060, 1
  %sub6062 = sub nsw i64 %conv6053, %add6061
  br label %cond.end.6068

cond.false.6063:                                  ; preds = %cond.true.6036
  %1066 = load i64, i64* %numargs, align 8
  %add6064 = add nsw i64 1, %1066
  %add6065 = add nsw i64 0, %add6064
  %mul6066 = mul nsw i64 0, %add6065
  %add6067 = add nsw i64 %mul6066, 0
  br label %cond.end.6068

cond.end.6068:                                    ; preds = %cond.false.6063, %cond.true.6044
  %cond6069 = phi i64 [ %sub6062, %cond.true.6044 ], [ %add6067, %cond.false.6063 ]
  %div6070 = sdiv i64 %cond6069, 8
  %cmp6071 = icmp slt i64 %add6037, %div6070
  br i1 %cmp6071, label %cond.true.6117, label %lor.lhs.false.6100

cond.false.6073:                                  ; preds = %cond.false.6032
  %1067 = load i64, i64* %numargs, align 8
  %add6074 = add nsw i64 1, %1067
  %add6075 = add nsw i64 0, %add6074
  %mul6076 = mul nsw i64 0, %add6075
  %sub6077 = sub nsw i64 %mul6076, 1
  %cmp6078 = icmp slt i64 %sub6077, 0
  br i1 %cmp6078, label %cond.true.6080, label %cond.false.6089

cond.true.6080:                                   ; preds = %cond.false.6073
  %1068 = load i64, i64* %numargs, align 8
  %add6081 = add nsw i64 1, %1068
  %add6082 = add nsw i64 0, %add6081
  %mul6083 = mul nsw i64 0, %add6082
  %add6084 = add nsw i64 %mul6083, 1
  %shl6085 = shl i64 %add6084, 62
  %sub6086 = sub nsw i64 %shl6085, 1
  %mul6087 = mul nsw i64 %sub6086, 2
  %add6088 = add nsw i64 %mul6087, 1
  br label %cond.end.6094

cond.false.6089:                                  ; preds = %cond.false.6073
  %1069 = load i64, i64* %numargs, align 8
  %add6090 = add nsw i64 1, %1069
  %add6091 = add nsw i64 0, %add6090
  %mul6092 = mul nsw i64 0, %add6091
  %sub6093 = sub nsw i64 %mul6092, 1
  br label %cond.end.6094

cond.end.6094:                                    ; preds = %cond.false.6089, %cond.true.6080
  %cond6095 = phi i64 [ %add6088, %cond.true.6080 ], [ %sub6093, %cond.false.6089 ]
  %div6096 = sdiv i64 %cond6095, 8
  %1070 = load i64, i64* %numargs, align 8
  %add6097 = add nsw i64 1, %1070
  %cmp6098 = icmp slt i64 %div6096, %add6097
  br i1 %cmp6098, label %cond.true.6117, label %lor.lhs.false.6100

lor.lhs.false.6100:                               ; preds = %cond.end.6094, %cond.end.6068, %cond.true.6031, %cond.end.6024, %cond.true.5992, %cond.end.5986
  %1071 = load i64, i64* %numargs, align 8
  %add6101 = add nsw i64 1, %1071
  %mul6102 = mul nsw i64 %add6101, 8
  %mul6103 = mul nsw i64 0, %mul6102
  %sub6104 = sub nsw i64 %mul6103, 1
  %cmp6105 = icmp slt i64 %sub6104, 0
  br i1 %cmp6105, label %land.lhs.true.6107, label %lor.lhs.false.6112

land.lhs.true.6107:                               ; preds = %lor.lhs.false.6100
  %1072 = load i64, i64* %numargs, align 8
  %add6108 = add nsw i64 1, %1072
  %mul6109 = mul nsw i64 %add6108, 8
  %cmp6110 = icmp slt i64 %mul6109, -9223372036854775808
  br i1 %cmp6110, label %cond.true.6117, label %lor.lhs.false.6112

lor.lhs.false.6112:                               ; preds = %land.lhs.true.6107, %lor.lhs.false.6100
  %1073 = load i64, i64* %numargs, align 8
  %add6113 = add nsw i64 1, %1073
  %mul6114 = mul nsw i64 %add6113, 8
  %cmp6115 = icmp slt i64 9223372036854775807, %mul6114
  br i1 %cmp6115, label %cond.true.6117, label %cond.false.6132

cond.true.6117:                                   ; preds = %lor.lhs.false.6112, %land.lhs.true.6107, %cond.end.6094, %cond.end.6068, %cond.true.6031, %cond.end.6024, %cond.true.5992, %cond.end.5986, %land.lhs.true.5955
  %1074 = load i64, i64* %numargs, align 8
  %add6118 = add nsw i64 1, %1074
  %mul6119 = mul i64 %add6118, 8
  %cmp6120 = icmp ule i64 %mul6119, 9223372036854775807
  br i1 %cmp6120, label %cond.true.6122, label %cond.false.6125

cond.true.6122:                                   ; preds = %cond.true.6117
  %1075 = load i64, i64* %numargs, align 8
  %add6123 = add nsw i64 1, %1075
  %mul6124 = mul i64 %add6123, 8
  br label %cond.end.6130

cond.false.6125:                                  ; preds = %cond.true.6117
  %1076 = load i64, i64* %numargs, align 8
  %add6126 = add nsw i64 1, %1076
  %mul6127 = mul i64 %add6126, 8
  %sub6128 = sub i64 %mul6127, -9223372036854775808
  %add6129 = add nsw i64 %sub6128, -9223372036854775808
  br label %cond.end.6130

cond.end.6130:                                    ; preds = %cond.false.6125, %cond.true.6122
  %cond6131 = phi i64 [ %mul6124, %cond.true.6122 ], [ %add6129, %cond.false.6125 ]
  store i64 %cond6131, i64* %alloca_nbytes3633, align 8
  br i1 true, label %if.then.6150, label %lor.lhs.false.6147

cond.false.6132:                                  ; preds = %lor.lhs.false.6112
  %1077 = load i64, i64* %numargs, align 8
  %add6133 = add nsw i64 1, %1077
  %mul6134 = mul i64 %add6133, 8
  %cmp6135 = icmp ule i64 %mul6134, 9223372036854775807
  br i1 %cmp6135, label %cond.true.6137, label %cond.false.6140

cond.true.6137:                                   ; preds = %cond.false.6132
  %1078 = load i64, i64* %numargs, align 8
  %add6138 = add nsw i64 1, %1078
  %mul6139 = mul i64 %add6138, 8
  br label %cond.end.6145

cond.false.6140:                                  ; preds = %cond.false.6132
  %1079 = load i64, i64* %numargs, align 8
  %add6141 = add nsw i64 1, %1079
  %mul6142 = mul i64 %add6141, 8
  %sub6143 = sub i64 %mul6142, -9223372036854775808
  %add6144 = add nsw i64 %sub6143, -9223372036854775808
  br label %cond.end.6145

cond.end.6145:                                    ; preds = %cond.false.6140, %cond.true.6137
  %cond6146 = phi i64 [ %mul6139, %cond.true.6137 ], [ %add6144, %cond.false.6140 ]
  store i64 %cond6146, i64* %alloca_nbytes3633, align 8
  br i1 false, label %if.then.6150, label %lor.lhs.false.6147

lor.lhs.false.6147:                               ; preds = %cond.end.6145, %cond.end.6130, %cond.end.5918, %cond.end.5903, %cond.end.5690, %cond.end.5675, %cond.end.5463, %cond.end.5448, %cond.end.5233, %cond.end.5214, %cond.end.4998, %cond.end.4979, %cond.end.4736, %cond.end.4710, %cond.end.4487, %cond.end.4461, %cond.end.4183, %cond.end.4157, %cond.end.3934, %cond.end.3908
  %1080 = load i64, i64* %alloca_nbytes3633, align 8
  %cmp6148 = icmp ult i64 -1, %1080
  br i1 %cmp6148, label %if.then.6150, label %if.else.6151

if.then.6150:                                     ; preds = %lor.lhs.false.6147, %cond.end.6145, %cond.end.6130, %cond.end.5918, %cond.end.5903, %cond.end.5690, %cond.end.5675, %cond.end.5463, %cond.end.5448, %cond.end.5233, %cond.end.5214, %cond.end.4998, %cond.end.4979, %cond.end.4736, %cond.end.4710, %cond.end.4487, %cond.end.4461, %cond.end.4183, %cond.end.4157, %cond.end.3934, %cond.end.3908
  call void @memory_full(i64 -1) #8
  unreachable

if.else.6151:                                     ; preds = %lor.lhs.false.6147
  %1081 = load i64, i64* %alloca_nbytes3633, align 8
  %1082 = load i64, i64* %sa_avail, align 8
  %cmp6152 = icmp sle i64 %1081, %1082
  br i1 %cmp6152, label %if.then.6154, label %if.else.6156

if.then.6154:                                     ; preds = %if.else.6151
  %1083 = load i64, i64* %alloca_nbytes3633, align 8
  %1084 = load i64, i64* %sa_avail, align 8
  %sub6155 = sub nsw i64 %1084, %1083
  store i64 %sub6155, i64* %sa_avail, align 8
  %1085 = load i64, i64* %alloca_nbytes3633, align 8
  %1086 = alloca i8, i64 %1085
  %1087 = bitcast i8* %1086 to i64*
  store i64* %1087, i64** %funcall_args, align 8
  br label %if.end.6161

if.else.6156:                                     ; preds = %if.else.6151
  %1088 = load i64, i64* %alloca_nbytes3633, align 8
  %call6158 = call noalias i8* @xmalloc(i64 %1088)
  %1089 = bitcast i8* %call6158 to i64*
  store i64* %1089, i64** %funcall_args, align 8
  %1090 = load i64*, i64** %funcall_args, align 8
  %1091 = load i64, i64* %numargs, align 8
  %add6159 = add nsw i64 1, %1091
  %call6160 = call i64 @make_save_memory(i64* %1090, i64 %add6159)
  store i64 %call6160, i64* %arg_6157, align 8
  store i8 1, i8* %sa_must_free, align 1
  %1092 = load i64, i64* %arg_6157, align 8
  call void @record_unwind_protect(void (i64)* @free_save_value, i64 %1092)
  br label %if.end.6161

if.end.6161:                                      ; preds = %if.else.6156, %if.then.6154
  br label %if.end.6162

if.end.6162:                                      ; preds = %if.end.6161
  br label %do.end.6163

do.end.6163:                                      ; preds = %if.end.6162
  %1093 = load i64, i64* %numargs, align 8
  %add6164 = add nsw i64 1, %1093
  store i64 %add6164, i64* %funcall_nargs, align 8
  br label %if.end.6165

if.end.6165:                                      ; preds = %do.end.6163, %do.end
  %1094 = load i64*, i64** %funcall_args, align 8
  %1095 = bitcast i64* %1094 to i8*
  %1096 = load i64*, i64** %args.addr, align 8
  %1097 = bitcast i64* %1096 to i8*
  %1098 = load i64, i64* %nargs.addr, align 8
  %mul6166 = mul nsw i64 %1098, 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1095, i8* %1097, i64 %mul6166, i32 8, i1 false)
  %1099 = load i64, i64* %nargs.addr, align 8
  %sub6167 = sub nsw i64 %1099, 1
  store i64 %sub6167, i64* %i, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end.6165
  %1100 = load i64, i64* %spread_arg, align 8
  %call6168 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp6169 = icmp eq i64 %1100, %call6168
  %lnot = xor i1 %cmp6169, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1101 = load i64, i64* %spread_arg, align 8
  %sub6171 = sub nsw i64 %1101, 3
  %1102 = inttoptr i64 %sub6171 to i8*
  %1103 = bitcast i8* %1102 to %struct.Lisp_Cons*
  %car6172 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %1103, i32 0, i32 0
  %1104 = load i64, i64* %car6172, align 8
  %1105 = load i64, i64* %i, align 8
  %inc = add nsw i64 %1105, 1
  store i64 %inc, i64* %i, align 8
  %1106 = load i64*, i64** %funcall_args, align 8
  %arrayidx6173 = getelementptr inbounds i64, i64* %1106, i64 %1105
  store i64 %1104, i64* %arrayidx6173, align 8
  %1107 = load i64, i64* %spread_arg, align 8
  %sub6174 = sub nsw i64 %1107, 3
  %1108 = inttoptr i64 %sub6174 to i8*
  %1109 = bitcast i8* %1108 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %1109, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %1110 = load i64, i64* %cdr, align 8
  store i64 %1110, i64* %spread_arg, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %1111 = load i64, i64* %funcall_nargs, align 8
  %1112 = load i64*, i64** %funcall_args, align 8
  %call6175 = call i64 @Ffuncall(i64 %1111, i64* %1112)
  store i64 %call6175, i64* %retval2, align 8
  br label %do.body.6176

do.body.6176:                                     ; preds = %while.end
  %1113 = load i8, i8* %sa_must_free, align 1
  %tobool = trunc i8 %1113 to i1
  br i1 %tobool, label %if.then.6177, label %if.end.6180

if.then.6177:                                     ; preds = %do.body.6176
  store i8 0, i8* %sa_must_free, align 1
  %1114 = load i64, i64* %sa_count, align 8
  %call6178 = call i64 @builtin_lisp_symbol(i32 0)
  %call6179 = call i64 @unbind_to(i64 %1114, i64 %call6178)
  br label %if.end.6180

if.end.6180:                                      ; preds = %if.then.6177, %do.body.6176
  br label %do.end.6181

do.end.6181:                                      ; preds = %if.end.6180
  %1115 = load i64, i64* %retval2, align 8
  store i64 %1115, i64* %retval
  br label %return

return:                                           ; preds = %do.end.6181, %if.then.7, %if.then
  %1116 = load i64, i64* %retval
  ret i64 %1116
}

declare void @CHECK_LIST(i64) #1

; Function Attrs: nounwind uwtable
define i64 @Ffuncall(i64 %nargs, i64* %args) #0 {
entry:
  %nargs.addr = alloca i64, align 8
  %args.addr = alloca i64*, align 8
  %fun = alloca i64, align 8
  %original_fun = alloca i64, align 8
  %funcar = alloca i64, align 8
  %numargs = alloca i64, align 8
  %lisp_numargs = alloca i64, align 8
  %val = alloca i64, align 8
  %internal_args = alloca i64*, align 8
  %count = alloca i64, align 8
  %internal_argbuf = alloca [8 x i64], align 16
  store i64 %nargs, i64* %nargs.addr, align 8
  store i64* %args, i64** %args.addr, align 8
  %0 = load i64, i64* %nargs.addr, align 8
  %sub = sub nsw i64 %0, 1
  store i64 %sub, i64* %numargs, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %1 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %1, %call
  br i1 %cmp, label %if.else, label %land.lhs.true

land.lhs.true:                                    ; preds = %do.body
  %2 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp2 = icmp eq i64 %2, %call1
  br i1 %cmp2, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  call void @process_quit_flag()
  br label %if.end.4

if.else:                                          ; preds = %land.lhs.true, %do.body
  %3 = load volatile i8, i8* @pending_signals, align 1
  %tobool = trunc i8 %3 to i1
  br i1 %tobool, label %if.then.3, label %if.end

if.then.3:                                        ; preds = %if.else
  call void @process_pending_signals()
  br label %if.end

if.end:                                           ; preds = %if.then.3, %if.else
  br label %if.end.4

if.end.4:                                         ; preds = %if.end, %if.then
  br label %do.end

do.end:                                           ; preds = %if.end.4
  %4 = load i64, i64* @lisp_eval_depth, align 8
  %inc = add nsw i64 %4, 1
  store i64 %inc, i64* @lisp_eval_depth, align 8
  %5 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 396), align 8
  %cmp5 = icmp sgt i64 %inc, %5
  br i1 %cmp5, label %if.then.6, label %if.end.13

if.then.6:                                        ; preds = %do.end
  %6 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 396), align 8
  %cmp7 = icmp slt i64 %6, 100
  br i1 %cmp7, label %if.then.8, label %if.end.9

if.then.8:                                        ; preds = %if.then.6
  store i64 100, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 396), align 8
  br label %if.end.9

if.end.9:                                         ; preds = %if.then.8, %if.then.6
  %7 = load i64, i64* @lisp_eval_depth, align 8
  %8 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 396), align 8
  %cmp10 = icmp sgt i64 %7, %8
  br i1 %cmp10, label %if.then.11, label %if.end.12

if.then.11:                                       ; preds = %if.end.9
  call void (i8*, ...) @error(i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.11, i32 0, i32 0)) #8
  unreachable

if.end.12:                                        ; preds = %if.end.9
  br label %if.end.13

if.end.13:                                        ; preds = %if.end.12, %do.end
  %9 = load i64*, i64** %args.addr, align 8
  %arrayidx = getelementptr inbounds i64, i64* %9, i64 0
  %10 = load i64, i64* %arrayidx, align 8
  %11 = load i64*, i64** %args.addr, align 8
  %arrayidx14 = getelementptr inbounds i64, i64* %11, i64 1
  %12 = load i64, i64* %nargs.addr, align 8
  %sub15 = sub nsw i64 %12, 1
  %call16 = call i64 @record_in_backtrace(i64 %10, i64* %arrayidx14, i64 %sub15)
  store i64 %call16, i64* %count, align 8
  call void @maybe_gc()
  %13 = load i8, i8* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 432), align 1
  %tobool17 = trunc i8 %13 to i1
  br i1 %tobool17, label %if.then.18, label %if.end.20

if.then.18:                                       ; preds = %if.end.13
  %call19 = call i64 @builtin_lisp_symbol(i32 598)
  %14 = load i64, i64* %count, align 8
  call void @do_debug_on_call(i64 %call19, i64 %14)
  br label %if.end.20

if.end.20:                                        ; preds = %if.then.18, %if.end.13
  %15 = load i64*, i64** %args.addr, align 8
  %arrayidx21 = getelementptr inbounds i64, i64* %15, i64 0
  %16 = load i64, i64* %arrayidx21, align 8
  store i64 %16, i64* %original_fun, align 8
  br label %retry

retry:                                            ; preds = %if.then.210, %if.end.20
  %17 = load i64, i64* %original_fun, align 8
  store i64 %17, i64* %fun, align 8
  %18 = load i64, i64* %fun, align 8
  %and = and i64 %18, 7
  %conv = trunc i64 %and to i32
  %cmp22 = icmp eq i32 %conv, 0
  br i1 %cmp22, label %land.lhs.true.24, label %if.end.36

land.lhs.true.24:                                 ; preds = %retry
  %19 = load i64, i64* %fun, align 8
  %call25 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp26 = icmp eq i64 %19, %call25
  br i1 %cmp26, label %if.end.36, label %land.lhs.true.28

land.lhs.true.28:                                 ; preds = %land.lhs.true.24
  %20 = load i64, i64* %fun, align 8
  %sub29 = sub nsw i64 %20, 0
  %add.ptr = getelementptr inbounds i8, i8* bitcast ([1074 x %struct.Lisp_Symbol]* @lispsym to i8*), i64 %sub29
  %21 = bitcast i8* %add.ptr to %struct.Lisp_Symbol*
  %function = getelementptr inbounds %struct.Lisp_Symbol, %struct.Lisp_Symbol* %21, i32 0, i32 3
  %22 = load i64, i64* %function, align 8
  store i64 %22, i64* %fun, align 8
  %23 = load i64, i64* %fun, align 8
  %and30 = and i64 %23, 7
  %conv31 = trunc i64 %and30 to i32
  %cmp32 = icmp eq i32 %conv31, 0
  br i1 %cmp32, label %if.then.34, label %if.end.36

if.then.34:                                       ; preds = %land.lhs.true.28
  %24 = load i64, i64* %fun, align 8
  %call35 = call i64 @indirect_function(i64 %24)
  store i64 %call35, i64* %fun, align 8
  br label %if.end.36

if.end.36:                                        ; preds = %if.then.34, %land.lhs.true.28, %land.lhs.true.24, %retry
  %25 = load i64, i64* %fun, align 8
  %call37 = call zeroext i1 @SUBRP(i64 %25)
  br i1 %call37, label %if.then.38, label %if.else.169

if.then.38:                                       ; preds = %if.end.36
  %26 = load i64, i64* %numargs, align 8
  %27 = load i64, i64* %fun, align 8
  %call39 = call %struct.Lisp_Subr* @XSUBR(i64 %27)
  %min_args = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call39, i32 0, i32 2
  %28 = load i16, i16* %min_args, align 2
  %conv40 = sext i16 %28 to i64
  %cmp41 = icmp slt i64 %26, %conv40
  br i1 %cmp41, label %if.then.53, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then.38
  %29 = load i64, i64* %fun, align 8
  %call43 = call %struct.Lisp_Subr* @XSUBR(i64 %29)
  %max_args = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call43, i32 0, i32 3
  %30 = load i16, i16* %max_args, align 2
  %conv44 = sext i16 %30 to i32
  %cmp45 = icmp sge i32 %conv44, 0
  br i1 %cmp45, label %land.lhs.true.47, label %if.else.56

land.lhs.true.47:                                 ; preds = %lor.lhs.false
  %31 = load i64, i64* %fun, align 8
  %call48 = call %struct.Lisp_Subr* @XSUBR(i64 %31)
  %max_args49 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call48, i32 0, i32 3
  %32 = load i16, i16* %max_args49, align 2
  %conv50 = sext i16 %32 to i64
  %33 = load i64, i64* %numargs, align 8
  %cmp51 = icmp slt i64 %conv50, %33
  br i1 %cmp51, label %if.then.53, label %if.else.56

if.then.53:                                       ; preds = %land.lhs.true.47, %if.then.38
  %34 = load i64, i64* %numargs, align 8
  %call54 = call i64 @make_natnum(i64 %34)
  store i64 %call54, i64* %lisp_numargs, align 8
  %call55 = call i64 @builtin_lisp_symbol(i32 1043)
  %35 = load i64, i64* %original_fun, align 8
  %36 = load i64, i64* %lisp_numargs, align 8
  call void @xsignal2(i64 %call55, i64 %35, i64 %36) #8
  unreachable

if.else.56:                                       ; preds = %land.lhs.true.47, %lor.lhs.false
  %37 = load i64, i64* %fun, align 8
  %call57 = call %struct.Lisp_Subr* @XSUBR(i64 %37)
  %max_args58 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call57, i32 0, i32 3
  %38 = load i16, i16* %max_args58, align 2
  %conv59 = sext i16 %38 to i32
  %cmp60 = icmp eq i32 %conv59, -1
  br i1 %cmp60, label %if.then.62, label %if.else.64

if.then.62:                                       ; preds = %if.else.56
  %call63 = call i64 @builtin_lisp_symbol(i32 570)
  %39 = load i64, i64* %original_fun, align 8
  call void @xsignal1(i64 %call63, i64 %39) #8
  unreachable

if.else.64:                                       ; preds = %if.else.56
  %40 = load i64, i64* %fun, align 8
  %call65 = call %struct.Lisp_Subr* @XSUBR(i64 %40)
  %max_args66 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call65, i32 0, i32 3
  %41 = load i16, i16* %max_args66, align 2
  %conv67 = sext i16 %41 to i32
  %cmp68 = icmp eq i32 %conv67, -2
  br i1 %cmp68, label %if.then.70, label %if.else.75

if.then.70:                                       ; preds = %if.else.64
  %42 = load i64, i64* %fun, align 8
  %call71 = call %struct.Lisp_Subr* @XSUBR(i64 %42)
  %function72 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call71, i32 0, i32 1
  %aMANY = bitcast %union.anon.6* %function72 to i64 (i64, i64*)**
  %43 = load i64 (i64, i64*)*, i64 (i64, i64*)** %aMANY, align 8
  %44 = load i64, i64* %numargs, align 8
  %45 = load i64*, i64** %args.addr, align 8
  %add.ptr73 = getelementptr inbounds i64, i64* %45, i64 1
  %call74 = call i64 %43(i64 %44, i64* %add.ptr73)
  store i64 %call74, i64* %val, align 8
  br label %if.end.166

if.else.75:                                       ; preds = %if.else.64
  %46 = load i64, i64* %fun, align 8
  %call76 = call %struct.Lisp_Subr* @XSUBR(i64 %46)
  %max_args77 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call76, i32 0, i32 3
  %47 = load i16, i16* %max_args77, align 2
  %conv78 = sext i16 %47 to i64
  %48 = load i64, i64* %numargs, align 8
  %cmp79 = icmp sgt i64 %conv78, %48
  br i1 %cmp79, label %if.then.81, label %if.else.89

if.then.81:                                       ; preds = %if.else.75
  %arraydecay = getelementptr inbounds [8 x i64], [8 x i64]* %internal_argbuf, i32 0, i32 0
  store i64* %arraydecay, i64** %internal_args, align 8
  %49 = load i64*, i64** %internal_args, align 8
  %50 = bitcast i64* %49 to i8*
  %51 = load i64*, i64** %args.addr, align 8
  %add.ptr82 = getelementptr inbounds i64, i64* %51, i64 1
  %52 = bitcast i64* %add.ptr82 to i8*
  %53 = load i64, i64* %numargs, align 8
  %mul = mul nsw i64 %53, 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %50, i8* %52, i64 %mul, i32 8, i1 false)
  %54 = load i64*, i64** %internal_args, align 8
  %55 = load i64, i64* %numargs, align 8
  %add.ptr83 = getelementptr inbounds i64, i64* %54, i64 %55
  %56 = bitcast i64* %add.ptr83 to i8*
  %57 = load i64, i64* %fun, align 8
  %call84 = call %struct.Lisp_Subr* @XSUBR(i64 %57)
  %max_args85 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call84, i32 0, i32 3
  %58 = load i16, i16* %max_args85, align 2
  %conv86 = sext i16 %58 to i64
  %59 = load i64, i64* %numargs, align 8
  %sub87 = sub nsw i64 %conv86, %59
  %mul88 = mul nsw i64 %sub87, 8
  call void @memclear(i8* %56, i64 %mul88)
  br label %if.end.91

if.else.89:                                       ; preds = %if.else.75
  %60 = load i64*, i64** %args.addr, align 8
  %add.ptr90 = getelementptr inbounds i64, i64* %60, i64 1
  store i64* %add.ptr90, i64** %internal_args, align 8
  br label %if.end.91

if.end.91:                                        ; preds = %if.else.89, %if.then.81
  %61 = load i64, i64* %fun, align 8
  %call92 = call %struct.Lisp_Subr* @XSUBR(i64 %61)
  %max_args93 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call92, i32 0, i32 3
  %62 = load i16, i16* %max_args93, align 2
  %conv94 = sext i16 %62 to i32
  switch i32 %conv94, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb.98
    i32 2, label %sw.bb.103
    i32 3, label %sw.bb.109
    i32 4, label %sw.bb.116
    i32 5, label %sw.bb.124
    i32 6, label %sw.bb.133
    i32 7, label %sw.bb.143
    i32 8, label %sw.bb.154
  ]

sw.bb:                                            ; preds = %if.end.91
  %63 = load i64, i64* %fun, align 8
  %call95 = call %struct.Lisp_Subr* @XSUBR(i64 %63)
  %function96 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call95, i32 0, i32 1
  %a0 = bitcast %union.anon.6* %function96 to i64 ()**
  %64 = load i64 ()*, i64 ()** %a0, align 8
  %call97 = call i64 %64()
  store i64 %call97, i64* %val, align 8
  br label %sw.epilog

sw.bb.98:                                         ; preds = %if.end.91
  %65 = load i64, i64* %fun, align 8
  %call99 = call %struct.Lisp_Subr* @XSUBR(i64 %65)
  %function100 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call99, i32 0, i32 1
  %a1 = bitcast %union.anon.6* %function100 to i64 (i64)**
  %66 = load i64 (i64)*, i64 (i64)** %a1, align 8
  %67 = load i64*, i64** %internal_args, align 8
  %arrayidx101 = getelementptr inbounds i64, i64* %67, i64 0
  %68 = load i64, i64* %arrayidx101, align 8
  %call102 = call i64 %66(i64 %68)
  store i64 %call102, i64* %val, align 8
  br label %sw.epilog

sw.bb.103:                                        ; preds = %if.end.91
  %69 = load i64, i64* %fun, align 8
  %call104 = call %struct.Lisp_Subr* @XSUBR(i64 %69)
  %function105 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call104, i32 0, i32 1
  %a2 = bitcast %union.anon.6* %function105 to i64 (i64, i64)**
  %70 = load i64 (i64, i64)*, i64 (i64, i64)** %a2, align 8
  %71 = load i64*, i64** %internal_args, align 8
  %arrayidx106 = getelementptr inbounds i64, i64* %71, i64 0
  %72 = load i64, i64* %arrayidx106, align 8
  %73 = load i64*, i64** %internal_args, align 8
  %arrayidx107 = getelementptr inbounds i64, i64* %73, i64 1
  %74 = load i64, i64* %arrayidx107, align 8
  %call108 = call i64 %70(i64 %72, i64 %74)
  store i64 %call108, i64* %val, align 8
  br label %sw.epilog

sw.bb.109:                                        ; preds = %if.end.91
  %75 = load i64, i64* %fun, align 8
  %call110 = call %struct.Lisp_Subr* @XSUBR(i64 %75)
  %function111 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call110, i32 0, i32 1
  %a3 = bitcast %union.anon.6* %function111 to i64 (i64, i64, i64)**
  %76 = load i64 (i64, i64, i64)*, i64 (i64, i64, i64)** %a3, align 8
  %77 = load i64*, i64** %internal_args, align 8
  %arrayidx112 = getelementptr inbounds i64, i64* %77, i64 0
  %78 = load i64, i64* %arrayidx112, align 8
  %79 = load i64*, i64** %internal_args, align 8
  %arrayidx113 = getelementptr inbounds i64, i64* %79, i64 1
  %80 = load i64, i64* %arrayidx113, align 8
  %81 = load i64*, i64** %internal_args, align 8
  %arrayidx114 = getelementptr inbounds i64, i64* %81, i64 2
  %82 = load i64, i64* %arrayidx114, align 8
  %call115 = call i64 %76(i64 %78, i64 %80, i64 %82)
  store i64 %call115, i64* %val, align 8
  br label %sw.epilog

sw.bb.116:                                        ; preds = %if.end.91
  %83 = load i64, i64* %fun, align 8
  %call117 = call %struct.Lisp_Subr* @XSUBR(i64 %83)
  %function118 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call117, i32 0, i32 1
  %a4 = bitcast %union.anon.6* %function118 to i64 (i64, i64, i64, i64)**
  %84 = load i64 (i64, i64, i64, i64)*, i64 (i64, i64, i64, i64)** %a4, align 8
  %85 = load i64*, i64** %internal_args, align 8
  %arrayidx119 = getelementptr inbounds i64, i64* %85, i64 0
  %86 = load i64, i64* %arrayidx119, align 8
  %87 = load i64*, i64** %internal_args, align 8
  %arrayidx120 = getelementptr inbounds i64, i64* %87, i64 1
  %88 = load i64, i64* %arrayidx120, align 8
  %89 = load i64*, i64** %internal_args, align 8
  %arrayidx121 = getelementptr inbounds i64, i64* %89, i64 2
  %90 = load i64, i64* %arrayidx121, align 8
  %91 = load i64*, i64** %internal_args, align 8
  %arrayidx122 = getelementptr inbounds i64, i64* %91, i64 3
  %92 = load i64, i64* %arrayidx122, align 8
  %call123 = call i64 %84(i64 %86, i64 %88, i64 %90, i64 %92)
  store i64 %call123, i64* %val, align 8
  br label %sw.epilog

sw.bb.124:                                        ; preds = %if.end.91
  %93 = load i64, i64* %fun, align 8
  %call125 = call %struct.Lisp_Subr* @XSUBR(i64 %93)
  %function126 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call125, i32 0, i32 1
  %a5 = bitcast %union.anon.6* %function126 to i64 (i64, i64, i64, i64, i64)**
  %94 = load i64 (i64, i64, i64, i64, i64)*, i64 (i64, i64, i64, i64, i64)** %a5, align 8
  %95 = load i64*, i64** %internal_args, align 8
  %arrayidx127 = getelementptr inbounds i64, i64* %95, i64 0
  %96 = load i64, i64* %arrayidx127, align 8
  %97 = load i64*, i64** %internal_args, align 8
  %arrayidx128 = getelementptr inbounds i64, i64* %97, i64 1
  %98 = load i64, i64* %arrayidx128, align 8
  %99 = load i64*, i64** %internal_args, align 8
  %arrayidx129 = getelementptr inbounds i64, i64* %99, i64 2
  %100 = load i64, i64* %arrayidx129, align 8
  %101 = load i64*, i64** %internal_args, align 8
  %arrayidx130 = getelementptr inbounds i64, i64* %101, i64 3
  %102 = load i64, i64* %arrayidx130, align 8
  %103 = load i64*, i64** %internal_args, align 8
  %arrayidx131 = getelementptr inbounds i64, i64* %103, i64 4
  %104 = load i64, i64* %arrayidx131, align 8
  %call132 = call i64 %94(i64 %96, i64 %98, i64 %100, i64 %102, i64 %104)
  store i64 %call132, i64* %val, align 8
  br label %sw.epilog

sw.bb.133:                                        ; preds = %if.end.91
  %105 = load i64, i64* %fun, align 8
  %call134 = call %struct.Lisp_Subr* @XSUBR(i64 %105)
  %function135 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call134, i32 0, i32 1
  %a6 = bitcast %union.anon.6* %function135 to i64 (i64, i64, i64, i64, i64, i64)**
  %106 = load i64 (i64, i64, i64, i64, i64, i64)*, i64 (i64, i64, i64, i64, i64, i64)** %a6, align 8
  %107 = load i64*, i64** %internal_args, align 8
  %arrayidx136 = getelementptr inbounds i64, i64* %107, i64 0
  %108 = load i64, i64* %arrayidx136, align 8
  %109 = load i64*, i64** %internal_args, align 8
  %arrayidx137 = getelementptr inbounds i64, i64* %109, i64 1
  %110 = load i64, i64* %arrayidx137, align 8
  %111 = load i64*, i64** %internal_args, align 8
  %arrayidx138 = getelementptr inbounds i64, i64* %111, i64 2
  %112 = load i64, i64* %arrayidx138, align 8
  %113 = load i64*, i64** %internal_args, align 8
  %arrayidx139 = getelementptr inbounds i64, i64* %113, i64 3
  %114 = load i64, i64* %arrayidx139, align 8
  %115 = load i64*, i64** %internal_args, align 8
  %arrayidx140 = getelementptr inbounds i64, i64* %115, i64 4
  %116 = load i64, i64* %arrayidx140, align 8
  %117 = load i64*, i64** %internal_args, align 8
  %arrayidx141 = getelementptr inbounds i64, i64* %117, i64 5
  %118 = load i64, i64* %arrayidx141, align 8
  %call142 = call i64 %106(i64 %108, i64 %110, i64 %112, i64 %114, i64 %116, i64 %118)
  store i64 %call142, i64* %val, align 8
  br label %sw.epilog

sw.bb.143:                                        ; preds = %if.end.91
  %119 = load i64, i64* %fun, align 8
  %call144 = call %struct.Lisp_Subr* @XSUBR(i64 %119)
  %function145 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call144, i32 0, i32 1
  %a7 = bitcast %union.anon.6* %function145 to i64 (i64, i64, i64, i64, i64, i64, i64)**
  %120 = load i64 (i64, i64, i64, i64, i64, i64, i64)*, i64 (i64, i64, i64, i64, i64, i64, i64)** %a7, align 8
  %121 = load i64*, i64** %internal_args, align 8
  %arrayidx146 = getelementptr inbounds i64, i64* %121, i64 0
  %122 = load i64, i64* %arrayidx146, align 8
  %123 = load i64*, i64** %internal_args, align 8
  %arrayidx147 = getelementptr inbounds i64, i64* %123, i64 1
  %124 = load i64, i64* %arrayidx147, align 8
  %125 = load i64*, i64** %internal_args, align 8
  %arrayidx148 = getelementptr inbounds i64, i64* %125, i64 2
  %126 = load i64, i64* %arrayidx148, align 8
  %127 = load i64*, i64** %internal_args, align 8
  %arrayidx149 = getelementptr inbounds i64, i64* %127, i64 3
  %128 = load i64, i64* %arrayidx149, align 8
  %129 = load i64*, i64** %internal_args, align 8
  %arrayidx150 = getelementptr inbounds i64, i64* %129, i64 4
  %130 = load i64, i64* %arrayidx150, align 8
  %131 = load i64*, i64** %internal_args, align 8
  %arrayidx151 = getelementptr inbounds i64, i64* %131, i64 5
  %132 = load i64, i64* %arrayidx151, align 8
  %133 = load i64*, i64** %internal_args, align 8
  %arrayidx152 = getelementptr inbounds i64, i64* %133, i64 6
  %134 = load i64, i64* %arrayidx152, align 8
  %call153 = call i64 %120(i64 %122, i64 %124, i64 %126, i64 %128, i64 %130, i64 %132, i64 %134)
  store i64 %call153, i64* %val, align 8
  br label %sw.epilog

sw.bb.154:                                        ; preds = %if.end.91
  %135 = load i64, i64* %fun, align 8
  %call155 = call %struct.Lisp_Subr* @XSUBR(i64 %135)
  %function156 = getelementptr inbounds %struct.Lisp_Subr, %struct.Lisp_Subr* %call155, i32 0, i32 1
  %a8 = bitcast %union.anon.6* %function156 to i64 (i64, i64, i64, i64, i64, i64, i64, i64)**
  %136 = load i64 (i64, i64, i64, i64, i64, i64, i64, i64)*, i64 (i64, i64, i64, i64, i64, i64, i64, i64)** %a8, align 8
  %137 = load i64*, i64** %internal_args, align 8
  %arrayidx157 = getelementptr inbounds i64, i64* %137, i64 0
  %138 = load i64, i64* %arrayidx157, align 8
  %139 = load i64*, i64** %internal_args, align 8
  %arrayidx158 = getelementptr inbounds i64, i64* %139, i64 1
  %140 = load i64, i64* %arrayidx158, align 8
  %141 = load i64*, i64** %internal_args, align 8
  %arrayidx159 = getelementptr inbounds i64, i64* %141, i64 2
  %142 = load i64, i64* %arrayidx159, align 8
  %143 = load i64*, i64** %internal_args, align 8
  %arrayidx160 = getelementptr inbounds i64, i64* %143, i64 3
  %144 = load i64, i64* %arrayidx160, align 8
  %145 = load i64*, i64** %internal_args, align 8
  %arrayidx161 = getelementptr inbounds i64, i64* %145, i64 4
  %146 = load i64, i64* %arrayidx161, align 8
  %147 = load i64*, i64** %internal_args, align 8
  %arrayidx162 = getelementptr inbounds i64, i64* %147, i64 5
  %148 = load i64, i64* %arrayidx162, align 8
  %149 = load i64*, i64** %internal_args, align 8
  %arrayidx163 = getelementptr inbounds i64, i64* %149, i64 6
  %150 = load i64, i64* %arrayidx163, align 8
  %151 = load i64*, i64** %internal_args, align 8
  %arrayidx164 = getelementptr inbounds i64, i64* %151, i64 7
  %152 = load i64, i64* %arrayidx164, align 8
  %call165 = call i64 %136(i64 %138, i64 %140, i64 %142, i64 %144, i64 %146, i64 %148, i64 %150, i64 %152)
  store i64 %call165, i64* %val, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %if.end.91
  call void @emacs_abort() #8
  unreachable

sw.epilog:                                        ; preds = %sw.bb.154, %sw.bb.143, %sw.bb.133, %sw.bb.124, %sw.bb.116, %sw.bb.109, %sw.bb.103, %sw.bb.98, %sw.bb
  br label %if.end.166

if.end.166:                                       ; preds = %sw.epilog, %if.then.70
  br label %if.end.167

if.end.167:                                       ; preds = %if.end.166
  br label %if.end.168

if.end.168:                                       ; preds = %if.end.167
  br label %if.end.217

if.else.169:                                      ; preds = %if.end.36
  %153 = load i64, i64* %fun, align 8
  %call170 = call zeroext i1 @COMPILEDP(i64 %153)
  br i1 %call170, label %if.then.171, label %if.else.174

if.then.171:                                      ; preds = %if.else.169
  %154 = load i64, i64* %fun, align 8
  %155 = load i64, i64* %numargs, align 8
  %156 = load i64*, i64** %args.addr, align 8
  %add.ptr172 = getelementptr inbounds i64, i64* %156, i64 1
  %call173 = call i64 @funcall_lambda(i64 %154, i64 %155, i64* %add.ptr172)
  store i64 %call173, i64* %val, align 8
  br label %if.end.216

if.else.174:                                      ; preds = %if.else.169
  %157 = load i64, i64* %fun, align 8
  %call175 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp176 = icmp eq i64 %157, %call175
  br i1 %cmp176, label %if.then.178, label %if.end.180

if.then.178:                                      ; preds = %if.else.174
  %call179 = call i64 @builtin_lisp_symbol(i32 1006)
  %158 = load i64, i64* %original_fun, align 8
  call void @xsignal1(i64 %call179, i64 %158) #8
  unreachable

if.end.180:                                       ; preds = %if.else.174
  %159 = load i64, i64* %fun, align 8
  %and181 = and i64 %159, 7
  %conv182 = trunc i64 %and181 to i32
  %cmp183 = icmp eq i32 %conv182, 3
  br i1 %cmp183, label %if.end.187, label %if.then.185

if.then.185:                                      ; preds = %if.end.180
  %call186 = call i64 @builtin_lisp_symbol(i32 570)
  %160 = load i64, i64* %original_fun, align 8
  call void @xsignal1(i64 %call186, i64 %160) #8
  unreachable

if.end.187:                                       ; preds = %if.end.180
  %161 = load i64, i64* %fun, align 8
  %sub188 = sub nsw i64 %161, 3
  %162 = inttoptr i64 %sub188 to i8*
  %163 = bitcast i8* %162 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %163, i32 0, i32 0
  %164 = load i64, i64* %car, align 8
  store i64 %164, i64* %funcar, align 8
  %165 = load i64, i64* %funcar, align 8
  %and189 = and i64 %165, 7
  %conv190 = trunc i64 %and189 to i32
  %cmp191 = icmp eq i32 %conv190, 0
  br i1 %cmp191, label %if.end.195, label %if.then.193

if.then.193:                                      ; preds = %if.end.187
  %call194 = call i64 @builtin_lisp_symbol(i32 570)
  %166 = load i64, i64* %original_fun, align 8
  call void @xsignal1(i64 %call194, i64 %166) #8
  unreachable

if.end.195:                                       ; preds = %if.end.187
  %167 = load i64, i64* %funcar, align 8
  %call196 = call i64 @builtin_lisp_symbol(i32 598)
  %cmp197 = icmp eq i64 %167, %call196
  br i1 %cmp197, label %if.then.203, label %lor.lhs.false.199

lor.lhs.false.199:                                ; preds = %if.end.195
  %168 = load i64, i64* %funcar, align 8
  %call200 = call i64 @builtin_lisp_symbol(i32 271)
  %cmp201 = icmp eq i64 %168, %call200
  br i1 %cmp201, label %if.then.203, label %if.else.206

if.then.203:                                      ; preds = %lor.lhs.false.199, %if.end.195
  %169 = load i64, i64* %fun, align 8
  %170 = load i64, i64* %numargs, align 8
  %171 = load i64*, i64** %args.addr, align 8
  %add.ptr204 = getelementptr inbounds i64, i64* %171, i64 1
  %call205 = call i64 @funcall_lambda(i64 %169, i64 %170, i64* %add.ptr204)
  store i64 %call205, i64* %val, align 8
  br label %if.end.215

if.else.206:                                      ; preds = %lor.lhs.false.199
  %172 = load i64, i64* %funcar, align 8
  %call207 = call i64 @builtin_lisp_symbol(i32 191)
  %cmp208 = icmp eq i64 %172, %call207
  br i1 %cmp208, label %if.then.210, label %if.else.213

if.then.210:                                      ; preds = %if.else.206
  %173 = load i64, i64* %fun, align 8
  %174 = load i64, i64* %original_fun, align 8
  %call211 = call i64 @builtin_lisp_symbol(i32 0)
  %call212 = call i64 @Fautoload_do_load(i64 %173, i64 %174, i64 %call211)
  br label %retry

if.else.213:                                      ; preds = %if.else.206
  %call214 = call i64 @builtin_lisp_symbol(i32 570)
  %175 = load i64, i64* %original_fun, align 8
  call void @xsignal1(i64 %call214, i64 %175) #8
  unreachable

if.end.215:                                       ; preds = %if.then.203
  br label %if.end.216

if.end.216:                                       ; preds = %if.end.215, %if.then.171
  br label %if.end.217

if.end.217:                                       ; preds = %if.end.216, %if.end.168
  %176 = load i64, i64* @lisp_eval_depth, align 8
  %dec = add nsw i64 %176, -1
  store i64 %dec, i64* @lisp_eval_depth, align 8
  %177 = load %union.specbinding*, %union.specbinding** @specpdl, align 8
  %178 = load i64, i64* %count, align 8
  %add.ptr218 = getelementptr inbounds %union.specbinding, %union.specbinding* %177, i64 %178
  %call219 = call zeroext i1 @backtrace_debug_on_exit(%union.specbinding* %add.ptr218)
  br i1 %call219, label %if.then.220, label %if.end.224

if.then.220:                                      ; preds = %if.end.217
  %call221 = call i64 @builtin_lisp_symbol(i32 387)
  %179 = load i64, i64* %val, align 8
  %call222 = call i64 @list2(i64 %call221, i64 %179)
  %call223 = call i64 @call_debugger(i64 %call222)
  store i64 %call223, i64* %val, align 8
  br label %if.end.224

if.end.224:                                       ; preds = %if.then.220, %if.end.217
  %180 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %incdec.ptr = getelementptr inbounds %union.specbinding, %union.specbinding* %180, i32 -1
  store %union.specbinding* %incdec.ptr, %union.specbinding** @specpdl_ptr, align 8
  %181 = load i64, i64* %val, align 8
  ret i64 %181
}

declare void @memclear(i8*, i64) #1

; Function Attrs: nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture, i8* nocapture readonly, i64, i32, i1) #6

; Function Attrs: nounwind uwtable
define i64 @Frun_hooks(i64 %nargs, i64* %args) #0 {
entry:
  %nargs.addr = alloca i64, align 8
  %args.addr = alloca i64*, align 8
  %i = alloca i64, align 8
  store i64 %nargs, i64* %nargs.addr, align 8
  store i64* %args, i64** %args.addr, align 8
  store i64 0, i64* %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, i64* %i, align 8
  %1 = load i64, i64* %nargs.addr, align 8
  %cmp = icmp slt i64 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i64, i64* %i, align 8
  %3 = load i64*, i64** %args.addr, align 8
  %arrayidx = getelementptr inbounds i64, i64* %3, i64 %2
  %4 = load i64, i64* %arrayidx, align 8
  call void @run_hook(i64 %4)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %5 = load i64, i64* %i, align 8
  %inc = add nsw i64 %5, 1
  store i64 %inc, i64* %i, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call = call i64 @builtin_lisp_symbol(i32 0)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define void @run_hook(i64 %hook) #0 {
entry:
  %hook.addr = alloca i64, align 8
  store i64 %hook, i64* %hook.addr, align 8
  %call = call i64 @Frun_hook_with_args(i64 1, i64* %hook.addr)
  ret void
}

; Function Attrs: nounwind uwtable
define i64 @Frun_hook_with_args(i64 %nargs, i64* %args) #0 {
entry:
  %nargs.addr = alloca i64, align 8
  %args.addr = alloca i64*, align 8
  store i64 %nargs, i64* %nargs.addr, align 8
  store i64* %args, i64** %args.addr, align 8
  %0 = load i64, i64* %nargs.addr, align 8
  %1 = load i64*, i64** %args.addr, align 8
  %call = call i64 @run_hook_with_args(i64 %0, i64* %1, i64 (i64, i64*)* @funcall_nil)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define i64 @run_hook_with_args(i64 %nargs, i64* %args, i64 (i64, i64*)* %funcall) #0 {
entry:
  %retval = alloca i64, align 8
  %nargs.addr = alloca i64, align 8
  %args.addr = alloca i64*, align 8
  %funcall.addr = alloca i64 (i64, i64*)*, align 8
  %sym = alloca i64, align 8
  %val = alloca i64, align 8
  %ret = alloca i64, align 8
  %global_vals = alloca i64, align 8
  store i64 %nargs, i64* %nargs.addr, align 8
  store i64* %args, i64** %args.addr, align 8
  store i64 (i64, i64*)* %funcall, i64 (i64, i64*)** %funcall.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call, i64* %ret, align 8
  %0 = load i64, i64* @Vrun_hooks, align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %0, %call1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call2, i64* %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64*, i64** %args.addr, align 8
  %arrayidx = getelementptr inbounds i64, i64* %1, i64 0
  %2 = load i64, i64* %arrayidx, align 8
  store i64 %2, i64* %sym, align 8
  %3 = load i64, i64* %sym, align 8
  %call3 = call i64 @find_symbol_value(i64 %3)
  store i64 %call3, i64* %val, align 8
  %4 = load i64, i64* %val, align 8
  %call4 = call i64 @builtin_lisp_symbol(i32 957)
  %cmp5 = icmp eq i64 %4, %call4
  br i1 %cmp5, label %if.then.8, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %5 = load i64, i64* %val, align 8
  %call6 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp7 = icmp eq i64 %5, %call6
  br i1 %cmp7, label %if.then.8, label %if.else

if.then.8:                                        ; preds = %lor.lhs.false, %if.end
  %6 = load i64, i64* %ret, align 8
  store i64 %6, i64* %retval
  br label %return

if.else:                                          ; preds = %lor.lhs.false
  %7 = load i64, i64* %val, align 8
  %and = and i64 %7, 7
  %conv = trunc i64 %and to i32
  %cmp9 = icmp eq i32 %conv, 3
  br i1 %cmp9, label %lor.lhs.false.11, label %if.then.14

lor.lhs.false.11:                                 ; preds = %if.else
  %8 = load i64, i64* %val, align 8
  %call12 = call zeroext i1 @FUNCTIONP(i64 %8)
  br i1 %call12, label %if.then.14, label %if.else.17

if.then.14:                                       ; preds = %lor.lhs.false.11, %if.else
  %9 = load i64, i64* %val, align 8
  %10 = load i64*, i64** %args.addr, align 8
  %arrayidx15 = getelementptr inbounds i64, i64* %10, i64 0
  store i64 %9, i64* %arrayidx15, align 8
  %11 = load i64 (i64, i64*)*, i64 (i64, i64*)** %funcall.addr, align 8
  %12 = load i64, i64* %nargs.addr, align 8
  %13 = load i64*, i64** %args.addr, align 8
  %call16 = call i64 %11(i64 %12, i64* %13)
  store i64 %call16, i64* %retval
  br label %return

if.else.17:                                       ; preds = %lor.lhs.false.11
  %call18 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call18, i64* %global_vals, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc.79, %if.else.17
  %14 = load i64, i64* %val, align 8
  %and19 = and i64 %14, 7
  %conv20 = trunc i64 %and19 to i32
  %cmp21 = icmp eq i32 %conv20, 3
  br i1 %cmp21, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %15 = load i64, i64* %ret, align 8
  %call23 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp24 = icmp eq i64 %15, %call23
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %16 = phi i1 [ false, %for.cond ], [ %cmp24, %land.rhs ]
  br i1 %16, label %for.body, label %for.end.83

for.body:                                         ; preds = %land.end
  %17 = load i64, i64* %val, align 8
  %sub = sub nsw i64 %17, 3
  %18 = inttoptr i64 %sub to i8*
  %19 = bitcast i8* %18 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %19, i32 0, i32 0
  %20 = load i64, i64* %car, align 8
  %call26 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp27 = icmp eq i64 %20, %call26
  br i1 %cmp27, label %if.then.29, label %if.else.73

if.then.29:                                       ; preds = %for.body
  %21 = load i64, i64* %sym, align 8
  %call30 = call i64 @Fdefault_value(i64 %21)
  store i64 %call30, i64* %global_vals, align 8
  %22 = load i64, i64* %global_vals, align 8
  %call31 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp32 = icmp eq i64 %22, %call31
  br i1 %cmp32, label %if.then.34, label %if.end.35

if.then.34:                                       ; preds = %if.then.29
  br label %for.inc.79

if.end.35:                                        ; preds = %if.then.29
  %23 = load i64, i64* %global_vals, align 8
  %and36 = and i64 %23, 7
  %conv37 = trunc i64 %and36 to i32
  %cmp38 = icmp eq i32 %conv37, 3
  br i1 %cmp38, label %lor.lhs.false.40, label %if.then.46

lor.lhs.false.40:                                 ; preds = %if.end.35
  %24 = load i64, i64* %global_vals, align 8
  %sub41 = sub nsw i64 %24, 3
  %25 = inttoptr i64 %sub41 to i8*
  %26 = bitcast i8* %25 to %struct.Lisp_Cons*
  %car42 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %26, i32 0, i32 0
  %27 = load i64, i64* %car42, align 8
  %call43 = call i64 @builtin_lisp_symbol(i32 598)
  %cmp44 = icmp eq i64 %27, %call43
  br i1 %cmp44, label %if.then.46, label %if.else.49

if.then.46:                                       ; preds = %lor.lhs.false.40, %if.end.35
  %28 = load i64, i64* %global_vals, align 8
  %29 = load i64*, i64** %args.addr, align 8
  %arrayidx47 = getelementptr inbounds i64, i64* %29, i64 0
  store i64 %28, i64* %arrayidx47, align 8
  %30 = load i64 (i64, i64*)*, i64 (i64, i64*)** %funcall.addr, align 8
  %31 = load i64, i64* %nargs.addr, align 8
  %32 = load i64*, i64** %args.addr, align 8
  %call48 = call i64 %30(i64 %31, i64* %32)
  store i64 %call48, i64* %ret, align 8
  br label %if.end.72

if.else.49:                                       ; preds = %lor.lhs.false.40
  br label %for.cond.50

for.cond.50:                                      ; preds = %for.inc, %if.else.49
  %33 = load i64, i64* %global_vals, align 8
  %and51 = and i64 %33, 7
  %conv52 = trunc i64 %and51 to i32
  %cmp53 = icmp eq i32 %conv52, 3
  br i1 %cmp53, label %land.rhs.55, label %land.end.59

land.rhs.55:                                      ; preds = %for.cond.50
  %34 = load i64, i64* %ret, align 8
  %call56 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp57 = icmp eq i64 %34, %call56
  br label %land.end.59

land.end.59:                                      ; preds = %land.rhs.55, %for.cond.50
  %35 = phi i1 [ false, %for.cond.50 ], [ %cmp57, %land.rhs.55 ]
  br i1 %35, label %for.body.60, label %for.end

for.body.60:                                      ; preds = %land.end.59
  %36 = load i64, i64* %global_vals, align 8
  %sub61 = sub nsw i64 %36, 3
  %37 = inttoptr i64 %sub61 to i8*
  %38 = bitcast i8* %37 to %struct.Lisp_Cons*
  %car62 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %38, i32 0, i32 0
  %39 = load i64, i64* %car62, align 8
  %40 = load i64*, i64** %args.addr, align 8
  %arrayidx63 = getelementptr inbounds i64, i64* %40, i64 0
  store i64 %39, i64* %arrayidx63, align 8
  %41 = load i64*, i64** %args.addr, align 8
  %arrayidx64 = getelementptr inbounds i64, i64* %41, i64 0
  %42 = load i64, i64* %arrayidx64, align 8
  %call65 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp66 = icmp eq i64 %42, %call65
  br i1 %cmp66, label %if.end.70, label %if.then.68

if.then.68:                                       ; preds = %for.body.60
  %43 = load i64 (i64, i64*)*, i64 (i64, i64*)** %funcall.addr, align 8
  %44 = load i64, i64* %nargs.addr, align 8
  %45 = load i64*, i64** %args.addr, align 8
  %call69 = call i64 %43(i64 %44, i64* %45)
  store i64 %call69, i64* %ret, align 8
  br label %if.end.70

if.end.70:                                        ; preds = %if.then.68, %for.body.60
  br label %for.inc

for.inc:                                          ; preds = %if.end.70
  %46 = load i64, i64* %global_vals, align 8
  %sub71 = sub nsw i64 %46, 3
  %47 = inttoptr i64 %sub71 to i8*
  %48 = bitcast i8* %47 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %48, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %49 = load i64, i64* %cdr, align 8
  store i64 %49, i64* %global_vals, align 8
  br label %for.cond.50

for.end:                                          ; preds = %land.end.59
  br label %if.end.72

if.end.72:                                        ; preds = %for.end, %if.then.46
  br label %if.end.78

if.else.73:                                       ; preds = %for.body
  %50 = load i64, i64* %val, align 8
  %sub74 = sub nsw i64 %50, 3
  %51 = inttoptr i64 %sub74 to i8*
  %52 = bitcast i8* %51 to %struct.Lisp_Cons*
  %car75 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %52, i32 0, i32 0
  %53 = load i64, i64* %car75, align 8
  %54 = load i64*, i64** %args.addr, align 8
  %arrayidx76 = getelementptr inbounds i64, i64* %54, i64 0
  store i64 %53, i64* %arrayidx76, align 8
  %55 = load i64 (i64, i64*)*, i64 (i64, i64*)** %funcall.addr, align 8
  %56 = load i64, i64* %nargs.addr, align 8
  %57 = load i64*, i64** %args.addr, align 8
  %call77 = call i64 %55(i64 %56, i64* %57)
  store i64 %call77, i64* %ret, align 8
  br label %if.end.78

if.end.78:                                        ; preds = %if.else.73, %if.end.72
  br label %for.inc.79

for.inc.79:                                       ; preds = %if.end.78, %if.then.34
  %58 = load i64, i64* %val, align 8
  %sub80 = sub nsw i64 %58, 3
  %59 = inttoptr i64 %sub80 to i8*
  %60 = bitcast i8* %59 to %struct.Lisp_Cons*
  %u81 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %60, i32 0, i32 1
  %cdr82 = bitcast %union.anon* %u81 to i64*
  %61 = load i64, i64* %cdr82, align 8
  store i64 %61, i64* %val, align 8
  br label %for.cond

for.end.83:                                       ; preds = %land.end
  %62 = load i64, i64* %ret, align 8
  store i64 %62, i64* %retval
  br label %return

return:                                           ; preds = %for.end.83, %if.then.14, %if.then.8, %if.then
  %63 = load i64, i64* %retval
  ret i64 %63
}

; Function Attrs: nounwind uwtable
define internal i64 @funcall_nil(i64 %nargs, i64* %args) #0 {
entry:
  %nargs.addr = alloca i64, align 8
  %args.addr = alloca i64*, align 8
  store i64 %nargs, i64* %nargs.addr, align 8
  store i64* %args, i64** %args.addr, align 8
  %0 = load i64, i64* %nargs.addr, align 8
  %1 = load i64*, i64** %args.addr, align 8
  %call = call i64 @Ffuncall(i64 %0, i64* %1)
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  ret i64 %call1
}

; Function Attrs: nounwind uwtable
define i64 @Frun_hook_with_args_until_success(i64 %nargs, i64* %args) #0 {
entry:
  %nargs.addr = alloca i64, align 8
  %args.addr = alloca i64*, align 8
  store i64 %nargs, i64* %nargs.addr, align 8
  store i64* %args, i64** %args.addr, align 8
  %0 = load i64, i64* %nargs.addr, align 8
  %1 = load i64*, i64** %args.addr, align 8
  %call = call i64 @run_hook_with_args(i64 %0, i64* %1, i64 (i64, i64*)* @Ffuncall)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define i64 @Frun_hook_with_args_until_failure(i64 %nargs, i64* %args) #0 {
entry:
  %nargs.addr = alloca i64, align 8
  %args.addr = alloca i64*, align 8
  store i64 %nargs, i64* %nargs.addr, align 8
  store i64* %args, i64** %args.addr, align 8
  %0 = load i64, i64* %nargs.addr, align 8
  %1 = load i64*, i64** %args.addr, align 8
  %call = call i64 @run_hook_with_args(i64 %0, i64* %1, i64 (i64, i64*)* @funcall_not)
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %call, %call1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %call2 = call i64 @builtin_lisp_symbol(i32 901)
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call2, %cond.true ], [ %call3, %cond.false ]
  ret i64 %cond
}

; Function Attrs: nounwind uwtable
define internal i64 @funcall_not(i64 %nargs, i64* %args) #0 {
entry:
  %nargs.addr = alloca i64, align 8
  %args.addr = alloca i64*, align 8
  store i64 %nargs, i64* %nargs.addr, align 8
  store i64* %args, i64** %args.addr, align 8
  %0 = load i64, i64* %nargs.addr, align 8
  %1 = load i64*, i64** %args.addr, align 8
  %call = call i64 @Ffuncall(i64 %0, i64* %1)
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %call, %call1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %call2 = call i64 @builtin_lisp_symbol(i32 901)
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call2, %cond.true ], [ %call3, %cond.false ]
  ret i64 %cond
}

; Function Attrs: nounwind uwtable
define i64 @Frun_hook_wrapped(i64 %nargs, i64* %args) #0 {
entry:
  %nargs.addr = alloca i64, align 8
  %args.addr = alloca i64*, align 8
  store i64 %nargs, i64* %nargs.addr, align 8
  store i64* %args, i64** %args.addr, align 8
  %0 = load i64, i64* %nargs.addr, align 8
  %1 = load i64*, i64** %args.addr, align 8
  %call = call i64 @run_hook_with_args(i64 %0, i64* %1, i64 (i64, i64*)* @run_hook_wrapped_funcall)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define internal i64 @run_hook_wrapped_funcall(i64 %nargs, i64* %args) #0 {
entry:
  %nargs.addr = alloca i64, align 8
  %args.addr = alloca i64*, align 8
  %tmp = alloca i64, align 8
  %ret = alloca i64, align 8
  store i64 %nargs, i64* %nargs.addr, align 8
  store i64* %args, i64** %args.addr, align 8
  %0 = load i64*, i64** %args.addr, align 8
  %arrayidx = getelementptr inbounds i64, i64* %0, i64 0
  %1 = load i64, i64* %arrayidx, align 8
  store i64 %1, i64* %tmp, align 8
  %2 = load i64*, i64** %args.addr, align 8
  %arrayidx2 = getelementptr inbounds i64, i64* %2, i64 1
  %3 = load i64, i64* %arrayidx2, align 8
  %4 = load i64*, i64** %args.addr, align 8
  %arrayidx3 = getelementptr inbounds i64, i64* %4, i64 0
  store i64 %3, i64* %arrayidx3, align 8
  %5 = load i64, i64* %tmp, align 8
  %6 = load i64*, i64** %args.addr, align 8
  %arrayidx4 = getelementptr inbounds i64, i64* %6, i64 1
  store i64 %5, i64* %arrayidx4, align 8
  %7 = load i64, i64* %nargs.addr, align 8
  %8 = load i64*, i64** %args.addr, align 8
  %call = call i64 @Ffuncall(i64 %7, i64* %8)
  store i64 %call, i64* %ret, align 8
  %9 = load i64*, i64** %args.addr, align 8
  %arrayidx5 = getelementptr inbounds i64, i64* %9, i64 0
  %10 = load i64, i64* %arrayidx5, align 8
  %11 = load i64*, i64** %args.addr, align 8
  %arrayidx6 = getelementptr inbounds i64, i64* %11, i64 1
  store i64 %10, i64* %arrayidx6, align 8
  %12 = load i64, i64* %tmp, align 8
  %13 = load i64*, i64** %args.addr, align 8
  %arrayidx7 = getelementptr inbounds i64, i64* %13, i64 0
  store i64 %12, i64* %arrayidx7, align 8
  %14 = load i64, i64* %ret, align 8
  ret i64 %14
}

declare zeroext i1 @FUNCTIONP(i64) #1

; Function Attrs: nounwind uwtable
define void @run_hook_with_args_2(i64 %hook, i64 %arg1, i64 %arg2) #0 {
entry:
  %hook.addr = alloca i64, align 8
  %arg1.addr = alloca i64, align 8
  %arg2.addr = alloca i64, align 8
  %.compoundliteral = alloca [3 x i64], align 8
  store i64 %hook, i64* %hook.addr, align 8
  store i64 %arg1, i64* %arg1.addr, align 8
  store i64 %arg2, i64* %arg2.addr, align 8
  %arrayinit.begin = getelementptr inbounds [3 x i64], [3 x i64]* %.compoundliteral, i64 0, i64 0
  %0 = load i64, i64* %hook.addr, align 8
  store i64 %0, i64* %arrayinit.begin
  %arrayinit.element = getelementptr inbounds i64, i64* %arrayinit.begin, i64 1
  %1 = load i64, i64* %arg1.addr, align 8
  store i64 %1, i64* %arrayinit.element
  %arrayinit.element1 = getelementptr inbounds i64, i64* %arrayinit.element, i64 1
  %2 = load i64, i64* %arg2.addr, align 8
  store i64 %2, i64* %arrayinit.element1
  %arraydecay = getelementptr inbounds [3 x i64], [3 x i64]* %.compoundliteral, i32 0, i32 0
  %call = call i64 @Frun_hook_with_args(i64 3, i64* %arraydecay)
  ret void
}

; Function Attrs: nounwind uwtable
define i64 @call0(i64 %fn) #0 {
entry:
  %fn.addr = alloca i64, align 8
  store i64 %fn, i64* %fn.addr, align 8
  %call = call i64 @Ffuncall(i64 1, i64* %fn.addr)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define i64 @call1(i64 %fn, i64 %arg1) #0 {
entry:
  %fn.addr = alloca i64, align 8
  %arg1.addr = alloca i64, align 8
  %.compoundliteral = alloca [2 x i64], align 8
  store i64 %fn, i64* %fn.addr, align 8
  store i64 %arg1, i64* %arg1.addr, align 8
  %arrayinit.begin = getelementptr inbounds [2 x i64], [2 x i64]* %.compoundliteral, i64 0, i64 0
  %0 = load i64, i64* %fn.addr, align 8
  store i64 %0, i64* %arrayinit.begin
  %arrayinit.element = getelementptr inbounds i64, i64* %arrayinit.begin, i64 1
  %1 = load i64, i64* %arg1.addr, align 8
  store i64 %1, i64* %arrayinit.element
  %arraydecay = getelementptr inbounds [2 x i64], [2 x i64]* %.compoundliteral, i32 0, i32 0
  %call = call i64 @Ffuncall(i64 2, i64* %arraydecay)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define i64 @call3(i64 %fn, i64 %arg1, i64 %arg2, i64 %arg3) #0 {
entry:
  %fn.addr = alloca i64, align 8
  %arg1.addr = alloca i64, align 8
  %arg2.addr = alloca i64, align 8
  %arg3.addr = alloca i64, align 8
  %.compoundliteral = alloca [4 x i64], align 8
  store i64 %fn, i64* %fn.addr, align 8
  store i64 %arg1, i64* %arg1.addr, align 8
  store i64 %arg2, i64* %arg2.addr, align 8
  store i64 %arg3, i64* %arg3.addr, align 8
  %arrayinit.begin = getelementptr inbounds [4 x i64], [4 x i64]* %.compoundliteral, i64 0, i64 0
  %0 = load i64, i64* %fn.addr, align 8
  store i64 %0, i64* %arrayinit.begin
  %arrayinit.element = getelementptr inbounds i64, i64* %arrayinit.begin, i64 1
  %1 = load i64, i64* %arg1.addr, align 8
  store i64 %1, i64* %arrayinit.element
  %arrayinit.element1 = getelementptr inbounds i64, i64* %arrayinit.element, i64 1
  %2 = load i64, i64* %arg2.addr, align 8
  store i64 %2, i64* %arrayinit.element1
  %arrayinit.element2 = getelementptr inbounds i64, i64* %arrayinit.element1, i64 1
  %3 = load i64, i64* %arg3.addr, align 8
  store i64 %3, i64* %arrayinit.element2
  %arraydecay = getelementptr inbounds [4 x i64], [4 x i64]* %.compoundliteral, i32 0, i32 0
  %call = call i64 @Ffuncall(i64 4, i64* %arraydecay)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define i64 @call4(i64 %fn, i64 %arg1, i64 %arg2, i64 %arg3, i64 %arg4) #0 {
entry:
  %fn.addr = alloca i64, align 8
  %arg1.addr = alloca i64, align 8
  %arg2.addr = alloca i64, align 8
  %arg3.addr = alloca i64, align 8
  %arg4.addr = alloca i64, align 8
  %.compoundliteral = alloca [5 x i64], align 8
  store i64 %fn, i64* %fn.addr, align 8
  store i64 %arg1, i64* %arg1.addr, align 8
  store i64 %arg2, i64* %arg2.addr, align 8
  store i64 %arg3, i64* %arg3.addr, align 8
  store i64 %arg4, i64* %arg4.addr, align 8
  %arrayinit.begin = getelementptr inbounds [5 x i64], [5 x i64]* %.compoundliteral, i64 0, i64 0
  %0 = load i64, i64* %fn.addr, align 8
  store i64 %0, i64* %arrayinit.begin
  %arrayinit.element = getelementptr inbounds i64, i64* %arrayinit.begin, i64 1
  %1 = load i64, i64* %arg1.addr, align 8
  store i64 %1, i64* %arrayinit.element
  %arrayinit.element1 = getelementptr inbounds i64, i64* %arrayinit.element, i64 1
  %2 = load i64, i64* %arg2.addr, align 8
  store i64 %2, i64* %arrayinit.element1
  %arrayinit.element2 = getelementptr inbounds i64, i64* %arrayinit.element1, i64 1
  %3 = load i64, i64* %arg3.addr, align 8
  store i64 %3, i64* %arrayinit.element2
  %arrayinit.element3 = getelementptr inbounds i64, i64* %arrayinit.element2, i64 1
  %4 = load i64, i64* %arg4.addr, align 8
  store i64 %4, i64* %arrayinit.element3
  %arraydecay = getelementptr inbounds [5 x i64], [5 x i64]* %.compoundliteral, i32 0, i32 0
  %call = call i64 @Ffuncall(i64 5, i64* %arraydecay)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define i64 @call5(i64 %fn, i64 %arg1, i64 %arg2, i64 %arg3, i64 %arg4, i64 %arg5) #0 {
entry:
  %fn.addr = alloca i64, align 8
  %arg1.addr = alloca i64, align 8
  %arg2.addr = alloca i64, align 8
  %arg3.addr = alloca i64, align 8
  %arg4.addr = alloca i64, align 8
  %arg5.addr = alloca i64, align 8
  %.compoundliteral = alloca [6 x i64], align 8
  store i64 %fn, i64* %fn.addr, align 8
  store i64 %arg1, i64* %arg1.addr, align 8
  store i64 %arg2, i64* %arg2.addr, align 8
  store i64 %arg3, i64* %arg3.addr, align 8
  store i64 %arg4, i64* %arg4.addr, align 8
  store i64 %arg5, i64* %arg5.addr, align 8
  %arrayinit.begin = getelementptr inbounds [6 x i64], [6 x i64]* %.compoundliteral, i64 0, i64 0
  %0 = load i64, i64* %fn.addr, align 8
  store i64 %0, i64* %arrayinit.begin
  %arrayinit.element = getelementptr inbounds i64, i64* %arrayinit.begin, i64 1
  %1 = load i64, i64* %arg1.addr, align 8
  store i64 %1, i64* %arrayinit.element
  %arrayinit.element1 = getelementptr inbounds i64, i64* %arrayinit.element, i64 1
  %2 = load i64, i64* %arg2.addr, align 8
  store i64 %2, i64* %arrayinit.element1
  %arrayinit.element2 = getelementptr inbounds i64, i64* %arrayinit.element1, i64 1
  %3 = load i64, i64* %arg3.addr, align 8
  store i64 %3, i64* %arrayinit.element2
  %arrayinit.element3 = getelementptr inbounds i64, i64* %arrayinit.element2, i64 1
  %4 = load i64, i64* %arg4.addr, align 8
  store i64 %4, i64* %arrayinit.element3
  %arrayinit.element4 = getelementptr inbounds i64, i64* %arrayinit.element3, i64 1
  %5 = load i64, i64* %arg5.addr, align 8
  store i64 %5, i64* %arrayinit.element4
  %arraydecay = getelementptr inbounds [6 x i64], [6 x i64]* %.compoundliteral, i32 0, i32 0
  %call = call i64 @Ffuncall(i64 6, i64* %arraydecay)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define i64 @call6(i64 %fn, i64 %arg1, i64 %arg2, i64 %arg3, i64 %arg4, i64 %arg5, i64 %arg6) #0 {
entry:
  %fn.addr = alloca i64, align 8
  %arg1.addr = alloca i64, align 8
  %arg2.addr = alloca i64, align 8
  %arg3.addr = alloca i64, align 8
  %arg4.addr = alloca i64, align 8
  %arg5.addr = alloca i64, align 8
  %arg6.addr = alloca i64, align 8
  %.compoundliteral = alloca [7 x i64], align 8
  store i64 %fn, i64* %fn.addr, align 8
  store i64 %arg1, i64* %arg1.addr, align 8
  store i64 %arg2, i64* %arg2.addr, align 8
  store i64 %arg3, i64* %arg3.addr, align 8
  store i64 %arg4, i64* %arg4.addr, align 8
  store i64 %arg5, i64* %arg5.addr, align 8
  store i64 %arg6, i64* %arg6.addr, align 8
  %arrayinit.begin = getelementptr inbounds [7 x i64], [7 x i64]* %.compoundliteral, i64 0, i64 0
  %0 = load i64, i64* %fn.addr, align 8
  store i64 %0, i64* %arrayinit.begin
  %arrayinit.element = getelementptr inbounds i64, i64* %arrayinit.begin, i64 1
  %1 = load i64, i64* %arg1.addr, align 8
  store i64 %1, i64* %arrayinit.element
  %arrayinit.element1 = getelementptr inbounds i64, i64* %arrayinit.element, i64 1
  %2 = load i64, i64* %arg2.addr, align 8
  store i64 %2, i64* %arrayinit.element1
  %arrayinit.element2 = getelementptr inbounds i64, i64* %arrayinit.element1, i64 1
  %3 = load i64, i64* %arg3.addr, align 8
  store i64 %3, i64* %arrayinit.element2
  %arrayinit.element3 = getelementptr inbounds i64, i64* %arrayinit.element2, i64 1
  %4 = load i64, i64* %arg4.addr, align 8
  store i64 %4, i64* %arrayinit.element3
  %arrayinit.element4 = getelementptr inbounds i64, i64* %arrayinit.element3, i64 1
  %5 = load i64, i64* %arg5.addr, align 8
  store i64 %5, i64* %arrayinit.element4
  %arrayinit.element5 = getelementptr inbounds i64, i64* %arrayinit.element4, i64 1
  %6 = load i64, i64* %arg6.addr, align 8
  store i64 %6, i64* %arrayinit.element5
  %arraydecay = getelementptr inbounds [7 x i64], [7 x i64]* %.compoundliteral, i32 0, i32 0
  %call = call i64 @Ffuncall(i64 7, i64* %arraydecay)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define i64 @call7(i64 %fn, i64 %arg1, i64 %arg2, i64 %arg3, i64 %arg4, i64 %arg5, i64 %arg6, i64 %arg7) #0 {
entry:
  %fn.addr = alloca i64, align 8
  %arg1.addr = alloca i64, align 8
  %arg2.addr = alloca i64, align 8
  %arg3.addr = alloca i64, align 8
  %arg4.addr = alloca i64, align 8
  %arg5.addr = alloca i64, align 8
  %arg6.addr = alloca i64, align 8
  %arg7.addr = alloca i64, align 8
  %.compoundliteral = alloca [8 x i64], align 8
  store i64 %fn, i64* %fn.addr, align 8
  store i64 %arg1, i64* %arg1.addr, align 8
  store i64 %arg2, i64* %arg2.addr, align 8
  store i64 %arg3, i64* %arg3.addr, align 8
  store i64 %arg4, i64* %arg4.addr, align 8
  store i64 %arg5, i64* %arg5.addr, align 8
  store i64 %arg6, i64* %arg6.addr, align 8
  store i64 %arg7, i64* %arg7.addr, align 8
  %arrayinit.begin = getelementptr inbounds [8 x i64], [8 x i64]* %.compoundliteral, i64 0, i64 0
  %0 = load i64, i64* %fn.addr, align 8
  store i64 %0, i64* %arrayinit.begin
  %arrayinit.element = getelementptr inbounds i64, i64* %arrayinit.begin, i64 1
  %1 = load i64, i64* %arg1.addr, align 8
  store i64 %1, i64* %arrayinit.element
  %arrayinit.element1 = getelementptr inbounds i64, i64* %arrayinit.element, i64 1
  %2 = load i64, i64* %arg2.addr, align 8
  store i64 %2, i64* %arrayinit.element1
  %arrayinit.element2 = getelementptr inbounds i64, i64* %arrayinit.element1, i64 1
  %3 = load i64, i64* %arg3.addr, align 8
  store i64 %3, i64* %arrayinit.element2
  %arrayinit.element3 = getelementptr inbounds i64, i64* %arrayinit.element2, i64 1
  %4 = load i64, i64* %arg4.addr, align 8
  store i64 %4, i64* %arrayinit.element3
  %arrayinit.element4 = getelementptr inbounds i64, i64* %arrayinit.element3, i64 1
  %5 = load i64, i64* %arg5.addr, align 8
  store i64 %5, i64* %arrayinit.element4
  %arrayinit.element5 = getelementptr inbounds i64, i64* %arrayinit.element4, i64 1
  %6 = load i64, i64* %arg6.addr, align 8
  store i64 %6, i64* %arrayinit.element5
  %arrayinit.element6 = getelementptr inbounds i64, i64* %arrayinit.element5, i64 1
  %7 = load i64, i64* %arg7.addr, align 8
  store i64 %7, i64* %arrayinit.element6
  %arraydecay = getelementptr inbounds [8 x i64], [8 x i64]* %.compoundliteral, i32 0, i32 0
  %call = call i64 @Ffuncall(i64 8, i64* %arraydecay)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define i64 @Ffunctionp(i64 %object) #0 {
entry:
  %retval = alloca i64, align 8
  %object.addr = alloca i64, align 8
  store i64 %object, i64* %object.addr, align 8
  %0 = load i64, i64* %object.addr, align 8
  %call = call zeroext i1 @FUNCTIONP(i64 %0)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i64 @builtin_lisp_symbol(i32 901)
  store i64 %call1, i64* %retval
  br label %return

if.end:                                           ; preds = %entry
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call2, i64* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %1 = load i64, i64* %retval
  ret i64 %1
}

declare i64 @make_natnum(i64) #1

; Function Attrs: nounwind uwtable
define internal i64 @funcall_lambda(i64 %fun, i64 %nargs, i64* %arg_vector) #0 {
entry:
  %retval = alloca i64, align 8
  %fun.addr = alloca i64, align 8
  %nargs.addr = alloca i64, align 8
  %arg_vector.addr = alloca i64*, align 8
  %val = alloca i64, align 8
  %syms_left = alloca i64, align 8
  %next = alloca i64, align 8
  %lexenv = alloca i64, align 8
  %count = alloca i64, align 8
  %i = alloca i64, align 8
  %optional = alloca i8, align 1
  %rest = alloca i8, align 1
  %size = alloca i64, align 8
  %arg = alloca i64, align 8
  store i64 %fun, i64* %fun.addr, align 8
  store i64 %nargs, i64* %nargs.addr, align 8
  store i64* %arg_vector, i64** %arg_vector.addr, align 8
  %call = call i64 @SPECPDL_INDEX()
  store i64 %call, i64* %count, align 8
  %0 = load i64, i64* %fun.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %if.then, label %if.else.28

if.then:                                          ; preds = %entry
  %1 = load i64, i64* %fun.addr, align 8
  %sub = sub nsw i64 %1, 3
  %2 = inttoptr i64 %sub to i8*
  %3 = bitcast i8* %2 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %3, i32 0, i32 0
  %4 = load i64, i64* %car, align 8
  %call2 = call i64 @builtin_lisp_symbol(i32 271)
  %cmp3 = icmp eq i64 %4, %call2
  br i1 %cmp3, label %if.then.5, label %if.else

if.then.5:                                        ; preds = %if.then
  %5 = load i64, i64* %fun.addr, align 8
  %sub6 = sub nsw i64 %5, 3
  %6 = inttoptr i64 %sub6 to i8*
  %7 = bitcast i8* %6 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %7, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %8 = load i64, i64* %cdr, align 8
  store i64 %8, i64* %fun.addr, align 8
  %9 = load i64, i64* %fun.addr, align 8
  %sub7 = sub nsw i64 %9, 3
  %10 = inttoptr i64 %sub7 to i8*
  %11 = bitcast i8* %10 to %struct.Lisp_Cons*
  %car8 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %11, i32 0, i32 0
  %12 = load i64, i64* %car8, align 8
  store i64 %12, i64* %lexenv, align 8
  %13 = load i64, i64* %fun.addr, align 8
  %and9 = and i64 %13, 7
  %conv10 = trunc i64 %and9 to i32
  %cmp11 = icmp eq i32 %conv10, 3
  br i1 %cmp11, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.5
  br label %cond.end

cond.false:                                       ; preds = %if.then.5
  %call13 = call i64 @builtin_lisp_symbol(i32 626)
  %14 = load i64, i64* %fun.addr, align 8
  %15 = call i64 @wrong_type_argument(i64 %call13, i64 %14) #8
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %16, %cond.true
  br label %if.end

if.else:                                          ; preds = %if.then
  %call14 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call14, i64* %lexenv, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %cond.end
  %17 = load i64, i64* %fun.addr, align 8
  %sub15 = sub nsw i64 %17, 3
  %18 = inttoptr i64 %sub15 to i8*
  %19 = bitcast i8* %18 to %struct.Lisp_Cons*
  %u16 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %19, i32 0, i32 1
  %cdr17 = bitcast %union.anon* %u16 to i64*
  %20 = load i64, i64* %cdr17, align 8
  store i64 %20, i64* %syms_left, align 8
  %21 = load i64, i64* %syms_left, align 8
  %and18 = and i64 %21, 7
  %conv19 = trunc i64 %and18 to i32
  %cmp20 = icmp eq i32 %conv19, 3
  br i1 %cmp20, label %if.then.22, label %if.else.25

if.then.22:                                       ; preds = %if.end
  %22 = load i64, i64* %syms_left, align 8
  %sub23 = sub nsw i64 %22, 3
  %23 = inttoptr i64 %sub23 to i8*
  %24 = bitcast i8* %23 to %struct.Lisp_Cons*
  %car24 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %24, i32 0, i32 0
  %25 = load i64, i64* %car24, align 8
  store i64 %25, i64* %syms_left, align 8
  br label %if.end.27

if.else.25:                                       ; preds = %if.end
  %call26 = call i64 @builtin_lisp_symbol(i32 570)
  %26 = load i64, i64* %fun.addr, align 8
  call void @xsignal1(i64 %call26, i64 %26) #8
  unreachable

if.end.27:                                        ; preds = %if.then.22
  br label %if.end.61

if.else.28:                                       ; preds = %entry
  %27 = load i64, i64* %fun.addr, align 8
  %call29 = call zeroext i1 @COMPILEDP(i64 %27)
  br i1 %call29, label %if.then.30, label %if.else.59

if.then.30:                                       ; preds = %if.else.28
  %28 = load i64, i64* %fun.addr, align 8
  %call31 = call i64 @ASIZE(i64 %28)
  %and32 = and i64 %call31, 4095
  store i64 %and32, i64* %size, align 8
  %29 = load i64, i64* %size, align 8
  %cmp33 = icmp sle i64 %29, 3
  br i1 %cmp33, label %if.then.35, label %if.end.37

if.then.35:                                       ; preds = %if.then.30
  %call36 = call i64 @builtin_lisp_symbol(i32 570)
  %30 = load i64, i64* %fun.addr, align 8
  call void @xsignal1(i64 %call36, i64 %30) #8
  unreachable

if.end.37:                                        ; preds = %if.then.30
  %31 = load i64, i64* %fun.addr, align 8
  %call38 = call i64 @AREF(i64 %31, i64 0)
  store i64 %call38, i64* %syms_left, align 8
  %32 = load i64, i64* %syms_left, align 8
  %and39 = and i64 %32, 7
  %conv40 = trunc i64 %and39 to i32
  %and41 = and i32 %conv40, -5
  %cmp42 = icmp eq i32 %and41, 2
  br i1 %cmp42, label %if.then.44, label %if.end.57

if.then.44:                                       ; preds = %if.end.37
  %33 = load i64, i64* %fun.addr, align 8
  %call45 = call i64 @AREF(i64 %33, i64 1)
  %and46 = and i64 %call45, 7
  %conv47 = trunc i64 %and46 to i32
  %cmp48 = icmp eq i32 %conv47, 3
  br i1 %cmp48, label %if.then.50, label %if.end.52

if.then.50:                                       ; preds = %if.then.44
  %34 = load i64, i64* %fun.addr, align 8
  %call51 = call i64 @Ffetch_bytecode(i64 %34)
  br label %if.end.52

if.end.52:                                        ; preds = %if.then.50, %if.then.44
  %35 = load i64, i64* %fun.addr, align 8
  %call53 = call i64 @AREF(i64 %35, i64 1)
  %36 = load i64, i64* %fun.addr, align 8
  %call54 = call i64 @AREF(i64 %36, i64 2)
  %37 = load i64, i64* %fun.addr, align 8
  %call55 = call i64 @AREF(i64 %37, i64 3)
  %38 = load i64, i64* %syms_left, align 8
  %39 = load i64, i64* %nargs.addr, align 8
  %40 = load i64*, i64** %arg_vector.addr, align 8
  %call56 = call i64 @exec_byte_code(i64 %call53, i64 %call54, i64 %call55, i64 %38, i64 %39, i64* %40)
  store i64 %call56, i64* %retval
  br label %return

if.end.57:                                        ; preds = %if.end.37
  %call58 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call58, i64* %lexenv, align 8
  br label %if.end.60

if.else.59:                                       ; preds = %if.else.28
  call void @emacs_abort() #8
  unreachable

if.end.60:                                        ; preds = %if.end.57
  br label %if.end.61

if.end.61:                                        ; preds = %if.end.60, %if.end.27
  store i8 0, i8* %rest, align 1
  store i8 0, i8* %optional, align 1
  store i64 0, i64* %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end.61
  %41 = load i64, i64* %syms_left, align 8
  %and62 = and i64 %41, 7
  %conv63 = trunc i64 %and62 to i32
  %cmp64 = icmp eq i32 %conv63, 3
  br i1 %cmp64, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %do.body

do.body:                                          ; preds = %for.body
  %42 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call66 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp67 = icmp eq i64 %42, %call66
  br i1 %cmp67, label %if.else.73, label %land.lhs.true

land.lhs.true:                                    ; preds = %do.body
  %43 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  %call69 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp70 = icmp eq i64 %43, %call69
  br i1 %cmp70, label %if.then.72, label %if.else.73

if.then.72:                                       ; preds = %land.lhs.true
  call void @process_quit_flag()
  br label %if.end.76

if.else.73:                                       ; preds = %land.lhs.true, %do.body
  %44 = load volatile i8, i8* @pending_signals, align 1
  %tobool = trunc i8 %44 to i1
  br i1 %tobool, label %if.then.74, label %if.end.75

if.then.74:                                       ; preds = %if.else.73
  call void @process_pending_signals()
  br label %if.end.75

if.end.75:                                        ; preds = %if.then.74, %if.else.73
  br label %if.end.76

if.end.76:                                        ; preds = %if.end.75, %if.then.72
  br label %do.end

do.end:                                           ; preds = %if.end.76
  %45 = load i64, i64* %syms_left, align 8
  %sub77 = sub nsw i64 %45, 3
  %46 = inttoptr i64 %sub77 to i8*
  %47 = bitcast i8* %46 to %struct.Lisp_Cons*
  %car78 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %47, i32 0, i32 0
  %48 = load i64, i64* %car78, align 8
  store i64 %48, i64* %next, align 8
  %49 = load i64, i64* %next, align 8
  %and79 = and i64 %49, 7
  %conv80 = trunc i64 %and79 to i32
  %cmp81 = icmp eq i32 %conv80, 0
  br i1 %cmp81, label %if.end.85, label %if.then.83

if.then.83:                                       ; preds = %do.end
  %call84 = call i64 @builtin_lisp_symbol(i32 570)
  %50 = load i64, i64* %fun.addr, align 8
  call void @xsignal1(i64 %call84, i64 %50) #8
  unreachable

if.end.85:                                        ; preds = %do.end
  %51 = load i64, i64* %next, align 8
  %call86 = call i64 @builtin_lisp_symbol(i32 173)
  %cmp87 = icmp eq i64 %51, %call86
  br i1 %cmp87, label %if.then.89, label %if.else.90

if.then.89:                                       ; preds = %if.end.85
  store i8 1, i8* %rest, align 1
  br label %if.end.128

if.else.90:                                       ; preds = %if.end.85
  %52 = load i64, i64* %next, align 8
  %call91 = call i64 @builtin_lisp_symbol(i32 172)
  %cmp92 = icmp eq i64 %52, %call91
  br i1 %cmp92, label %if.then.94, label %if.else.95

if.then.94:                                       ; preds = %if.else.90
  store i8 1, i8* %optional, align 1
  br label %if.end.127

if.else.95:                                       ; preds = %if.else.90
  %53 = load i8, i8* %rest, align 1
  %tobool96 = trunc i8 %53 to i1
  br i1 %tobool96, label %if.then.97, label %if.else.100

if.then.97:                                       ; preds = %if.else.95
  %54 = load i64, i64* %nargs.addr, align 8
  %55 = load i64, i64* %i, align 8
  %sub98 = sub nsw i64 %54, %55
  %56 = load i64, i64* %i, align 8
  %57 = load i64*, i64** %arg_vector.addr, align 8
  %arrayidx = getelementptr inbounds i64, i64* %57, i64 %56
  %call99 = call i64 @Flist(i64 %sub98, i64* %arrayidx)
  store i64 %call99, i64* %arg, align 8
  %58 = load i64, i64* %nargs.addr, align 8
  store i64 %58, i64* %i, align 8
  br label %if.end.113

if.else.100:                                      ; preds = %if.else.95
  %59 = load i64, i64* %i, align 8
  %60 = load i64, i64* %nargs.addr, align 8
  %cmp101 = icmp slt i64 %59, %60
  br i1 %cmp101, label %if.then.103, label %if.else.105

if.then.103:                                      ; preds = %if.else.100
  %61 = load i64, i64* %i, align 8
  %inc = add nsw i64 %61, 1
  store i64 %inc, i64* %i, align 8
  %62 = load i64*, i64** %arg_vector.addr, align 8
  %arrayidx104 = getelementptr inbounds i64, i64* %62, i64 %61
  %63 = load i64, i64* %arrayidx104, align 8
  store i64 %63, i64* %arg, align 8
  br label %if.end.112

if.else.105:                                      ; preds = %if.else.100
  %64 = load i8, i8* %optional, align 1
  %tobool106 = trunc i8 %64 to i1
  br i1 %tobool106, label %if.else.109, label %if.then.107

if.then.107:                                      ; preds = %if.else.105
  %call108 = call i64 @builtin_lisp_symbol(i32 1043)
  %65 = load i64, i64* %fun.addr, align 8
  %66 = load i64, i64* %nargs.addr, align 8
  %shl = shl i64 %66, 2
  %add = add i64 %shl, 2
  call void @xsignal2(i64 %call108, i64 %65, i64 %add) #8
  unreachable

if.else.109:                                      ; preds = %if.else.105
  %call110 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call110, i64* %arg, align 8
  br label %if.end.111

if.end.111:                                       ; preds = %if.else.109
  br label %if.end.112

if.end.112:                                       ; preds = %if.end.111, %if.then.103
  br label %if.end.113

if.end.113:                                       ; preds = %if.end.112, %if.then.97
  %67 = load i64, i64* %lexenv, align 8
  %call114 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp115 = icmp eq i64 %67, %call114
  br i1 %cmp115, label %if.else.125, label %land.lhs.true.117

land.lhs.true.117:                                ; preds = %if.end.113
  %68 = load i64, i64* %next, align 8
  %and118 = and i64 %68, 7
  %conv119 = trunc i64 %and118 to i32
  %cmp120 = icmp eq i32 %conv119, 0
  br i1 %cmp120, label %if.then.122, label %if.else.125

if.then.122:                                      ; preds = %land.lhs.true.117
  %69 = load i64, i64* %next, align 8
  %70 = load i64, i64* %arg, align 8
  %call123 = call i64 @Fcons(i64 %69, i64 %70)
  %71 = load i64, i64* %lexenv, align 8
  %call124 = call i64 @Fcons(i64 %call123, i64 %71)
  store i64 %call124, i64* %lexenv, align 8
  br label %if.end.126

if.else.125:                                      ; preds = %land.lhs.true.117, %if.end.113
  %72 = load i64, i64* %next, align 8
  %73 = load i64, i64* %arg, align 8
  call void @specbind(i64 %72, i64 %73)
  br label %if.end.126

if.end.126:                                       ; preds = %if.else.125, %if.then.122
  br label %if.end.127

if.end.127:                                       ; preds = %if.end.126, %if.then.94
  br label %if.end.128

if.end.128:                                       ; preds = %if.end.127, %if.then.89
  br label %for.inc

for.inc:                                          ; preds = %if.end.128
  %74 = load i64, i64* %syms_left, align 8
  %sub129 = sub nsw i64 %74, 3
  %75 = inttoptr i64 %sub129 to i8*
  %76 = bitcast i8* %75 to %struct.Lisp_Cons*
  %u130 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %76, i32 0, i32 1
  %cdr131 = bitcast %union.anon* %u130 to i64*
  %77 = load i64, i64* %cdr131, align 8
  store i64 %77, i64* %syms_left, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %78 = load i64, i64* %syms_left, align 8
  %call132 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp133 = icmp eq i64 %78, %call132
  br i1 %cmp133, label %if.else.137, label %if.then.135

if.then.135:                                      ; preds = %for.end
  %call136 = call i64 @builtin_lisp_symbol(i32 570)
  %79 = load i64, i64* %fun.addr, align 8
  call void @xsignal1(i64 %call136, i64 %79) #8
  unreachable

if.else.137:                                      ; preds = %for.end
  %80 = load i64, i64* %i, align 8
  %81 = load i64, i64* %nargs.addr, align 8
  %cmp138 = icmp slt i64 %80, %81
  br i1 %cmp138, label %if.then.140, label %if.end.144

if.then.140:                                      ; preds = %if.else.137
  %call141 = call i64 @builtin_lisp_symbol(i32 1043)
  %82 = load i64, i64* %fun.addr, align 8
  %83 = load i64, i64* %nargs.addr, align 8
  %shl142 = shl i64 %83, 2
  %add143 = add i64 %shl142, 2
  call void @xsignal2(i64 %call141, i64 %82, i64 %add143) #8
  unreachable

if.end.144:                                       ; preds = %if.else.137
  br label %if.end.145

if.end.145:                                       ; preds = %if.end.144
  %84 = load i64, i64* %lexenv, align 8
  %85 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 147), align 8
  %cmp146 = icmp eq i64 %84, %85
  br i1 %cmp146, label %if.end.150, label %if.then.148

if.then.148:                                      ; preds = %if.end.145
  %call149 = call i64 @builtin_lisp_symbol(i32 567)
  %86 = load i64, i64* %lexenv, align 8
  call void @specbind(i64 %call149, i64 %86)
  br label %if.end.150

if.end.150:                                       ; preds = %if.then.148, %if.end.145
  %87 = load i64, i64* %fun.addr, align 8
  %and151 = and i64 %87, 7
  %conv152 = trunc i64 %and151 to i32
  %cmp153 = icmp eq i32 %conv152, 3
  br i1 %cmp153, label %if.then.155, label %if.else.163

if.then.155:                                      ; preds = %if.end.150
  %88 = load i64, i64* %fun.addr, align 8
  %sub156 = sub nsw i64 %88, 3
  %89 = inttoptr i64 %sub156 to i8*
  %90 = bitcast i8* %89 to %struct.Lisp_Cons*
  %u157 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %90, i32 0, i32 1
  %cdr158 = bitcast %union.anon* %u157 to i64*
  %91 = load i64, i64* %cdr158, align 8
  %sub159 = sub nsw i64 %91, 3
  %92 = inttoptr i64 %sub159 to i8*
  %93 = bitcast i8* %92 to %struct.Lisp_Cons*
  %u160 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %93, i32 0, i32 1
  %cdr161 = bitcast %union.anon* %u160 to i64*
  %94 = load i64, i64* %cdr161, align 8
  %call162 = call i64 @Fprogn(i64 %94)
  store i64 %call162, i64* %val, align 8
  br label %if.end.177

if.else.163:                                      ; preds = %if.end.150
  %95 = load i64, i64* %fun.addr, align 8
  %call164 = call i64 @AREF(i64 %95, i64 1)
  %and165 = and i64 %call164, 7
  %conv166 = trunc i64 %and165 to i32
  %cmp167 = icmp eq i32 %conv166, 3
  br i1 %cmp167, label %if.then.169, label %if.end.171

if.then.169:                                      ; preds = %if.else.163
  %96 = load i64, i64* %fun.addr, align 8
  %call170 = call i64 @Ffetch_bytecode(i64 %96)
  br label %if.end.171

if.end.171:                                       ; preds = %if.then.169, %if.else.163
  %97 = load i64, i64* %fun.addr, align 8
  %call172 = call i64 @AREF(i64 %97, i64 1)
  %98 = load i64, i64* %fun.addr, align 8
  %call173 = call i64 @AREF(i64 %98, i64 2)
  %99 = load i64, i64* %fun.addr, align 8
  %call174 = call i64 @AREF(i64 %99, i64 3)
  %call175 = call i64 @builtin_lisp_symbol(i32 0)
  %call176 = call i64 @exec_byte_code(i64 %call172, i64 %call173, i64 %call174, i64 %call175, i64 0, i64* null)
  store i64 %call176, i64* %val, align 8
  br label %if.end.177

if.end.177:                                       ; preds = %if.end.171, %if.then.155
  %100 = load i64, i64* %count, align 8
  %101 = load i64, i64* %val, align 8
  %call178 = call i64 @unbind_to(i64 %100, i64 %101)
  store i64 %call178, i64* %retval
  br label %return

return:                                           ; preds = %if.end.177, %if.end.52
  %102 = load i64, i64* %retval
  ret i64 %102
}

; Function Attrs: nounwind uwtable
define i64 @Ffetch_bytecode(i64 %object) #0 {
entry:
  %object.addr = alloca i64, align 8
  %tem = alloca i64, align 8
  %size = alloca i64, align 8
  store i64 %object, i64* %object.addr, align 8
  %0 = load i64, i64* %object.addr, align 8
  %call = call zeroext i1 @COMPILEDP(i64 %0)
  br i1 %call, label %if.then, label %if.end.32

if.then:                                          ; preds = %entry
  %1 = load i64, i64* %object.addr, align 8
  %call1 = call i64 @ASIZE(i64 %1)
  %and = and i64 %call1, 4095
  store i64 %and, i64* %size, align 8
  %2 = load i64, i64* %size, align 8
  %cmp = icmp sle i64 %2, 3
  br i1 %cmp, label %if.then.2, label %if.end

if.then.2:                                        ; preds = %if.then
  %call3 = call i64 @builtin_lisp_symbol(i32 570)
  %3 = load i64, i64* %object.addr, align 8
  call void @xsignal1(i64 %call3, i64 %3) #8
  unreachable

if.end:                                           ; preds = %if.then
  %4 = load i64, i64* %object.addr, align 8
  %call4 = call i64 @AREF(i64 %4, i64 1)
  %and5 = and i64 %call4, 7
  %conv = trunc i64 %and5 to i32
  %cmp6 = icmp eq i32 %conv, 3
  br i1 %cmp6, label %if.then.8, label %if.end.31

if.then.8:                                        ; preds = %if.end
  %5 = load i64, i64* %object.addr, align 8
  %call9 = call i64 @AREF(i64 %5, i64 1)
  %call10 = call i64 @read_doc_string(i64 %call9)
  store i64 %call10, i64* %tem, align 8
  %6 = load i64, i64* %tem, align 8
  %and11 = and i64 %6, 7
  %conv12 = trunc i64 %and11 to i32
  %cmp13 = icmp eq i32 %conv12, 3
  br i1 %cmp13, label %if.end.27, label %if.then.15

if.then.15:                                       ; preds = %if.then.8
  %7 = load i64, i64* %object.addr, align 8
  %call16 = call i64 @AREF(i64 %7, i64 1)
  store i64 %call16, i64* %tem, align 8
  %8 = load i64, i64* %tem, align 8
  %and17 = and i64 %8, 7
  %conv18 = trunc i64 %and17 to i32
  %cmp19 = icmp eq i32 %conv18, 3
  br i1 %cmp19, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.then.15
  %9 = load i64, i64* %tem, align 8
  %sub = sub nsw i64 %9, 3
  %10 = inttoptr i64 %sub to i8*
  %11 = bitcast i8* %10 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %11, i32 0, i32 0
  %12 = load i64, i64* %car, align 8
  %call21 = call zeroext i1 @STRINGP(i64 %12)
  br i1 %call21, label %if.then.23, label %if.else

if.then.23:                                       ; preds = %land.lhs.true
  %13 = load i64, i64* %tem, align 8
  %sub24 = sub nsw i64 %13, 3
  %14 = inttoptr i64 %sub24 to i8*
  %15 = bitcast i8* %14 to %struct.Lisp_Cons*
  %car25 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %15, i32 0, i32 0
  %16 = load i64, i64* %car25, align 8
  %call26 = call i8* @SDATA(i64 %16)
  call void (i8*, ...) @error(i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.12, i32 0, i32 0), i8* %call26) #8
  unreachable

if.else:                                          ; preds = %land.lhs.true, %if.then.15
  call void (i8*, ...) @error(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.13, i32 0, i32 0)) #8
  unreachable

if.end.27:                                        ; preds = %if.then.8
  %17 = load i64, i64* %object.addr, align 8
  %18 = load i64, i64* %tem, align 8
  %sub28 = sub nsw i64 %18, 3
  %19 = inttoptr i64 %sub28 to i8*
  %20 = bitcast i8* %19 to %struct.Lisp_Cons*
  %car29 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %20, i32 0, i32 0
  %21 = load i64, i64* %car29, align 8
  call void @ASET(i64 %17, i64 1, i64 %21)
  %22 = load i64, i64* %object.addr, align 8
  %23 = load i64, i64* %tem, align 8
  %sub30 = sub nsw i64 %23, 3
  %24 = inttoptr i64 %sub30 to i8*
  %25 = bitcast i8* %24 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %25, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %26 = load i64, i64* %cdr, align 8
  call void @ASET(i64 %22, i64 2, i64 %26)
  br label %if.end.31

if.end.31:                                        ; preds = %if.end.27, %if.end
  br label %if.end.32

if.end.32:                                        ; preds = %if.end.31, %entry
  %27 = load i64, i64* %object.addr, align 8
  ret i64 %27
}

declare i64 @AREF(i64, i64) #1

declare i64 @read_doc_string(i64) #1

declare void @ASET(i64, i64, i64) #1

; Function Attrs: nounwind uwtable
define zeroext i1 @let_shadows_buffer_binding_p(%struct.Lisp_Symbol* %symbol) #0 {
entry:
  %retval = alloca i1, align 1
  %symbol.addr = alloca %struct.Lisp_Symbol*, align 8
  %p = alloca %union.specbinding*, align 8
  %buf = alloca i64, align 8
  %let_bound_symbol = alloca %struct.Lisp_Symbol*, align 8
  store %struct.Lisp_Symbol* %symbol, %struct.Lisp_Symbol** %symbol.addr, align 8
  %call = call i64 @Fcurrent_buffer()
  store i64 %call, i64* %buf, align 8
  %0 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  store %union.specbinding* %0, %union.specbinding** %p, align 8
  br label %for.cond

for.cond:                                         ; preds = %if.end.7, %entry
  %1 = load %union.specbinding*, %union.specbinding** %p, align 8
  %2 = load %union.specbinding*, %union.specbinding** @specpdl, align 8
  %cmp = icmp ugt %union.specbinding* %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load %union.specbinding*, %union.specbinding** %p, align 8
  %incdec.ptr = getelementptr inbounds %union.specbinding, %union.specbinding* %3, i32 -1
  store %union.specbinding* %incdec.ptr, %union.specbinding** %p, align 8
  %4 = bitcast %union.specbinding* %incdec.ptr to i8*
  %bf.load = load i8, i8* %4, align 8
  %bf.cast = zext i8 %bf.load to i32
  %cmp1 = icmp sgt i32 %bf.cast, 5
  br i1 %cmp1, label %if.then, label %if.end.7

if.then:                                          ; preds = %for.body
  %5 = load %union.specbinding*, %union.specbinding** %p, align 8
  %call2 = call i64 @specpdl_symbol(%union.specbinding* %5)
  %sub = sub nsw i64 %call2, 0
  %add.ptr = getelementptr inbounds i8, i8* bitcast ([1074 x %struct.Lisp_Symbol]* @lispsym to i8*), i64 %sub
  %6 = bitcast i8* %add.ptr to %struct.Lisp_Symbol*
  store %struct.Lisp_Symbol* %6, %struct.Lisp_Symbol** %let_bound_symbol, align 8
  %7 = load %struct.Lisp_Symbol*, %struct.Lisp_Symbol** %symbol.addr, align 8
  %8 = load %struct.Lisp_Symbol*, %struct.Lisp_Symbol** %let_bound_symbol, align 8
  %cmp3 = icmp eq %struct.Lisp_Symbol* %7, %8
  br i1 %cmp3, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then
  %9 = load %union.specbinding*, %union.specbinding** %p, align 8
  %call4 = call i64 @specpdl_where(%union.specbinding* %9)
  %10 = load i64, i64* %buf, align 8
  %cmp5 = icmp eq i64 %call4, %10
  br i1 %cmp5, label %if.then.6, label %if.end

if.then.6:                                        ; preds = %land.lhs.true
  store i1 true, i1* %retval
  br label %return

if.end:                                           ; preds = %land.lhs.true, %if.then
  br label %if.end.7

if.end.7:                                         ; preds = %if.end, %for.body
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i1 false, i1* %retval
  br label %return

return:                                           ; preds = %for.end, %if.then.6
  %11 = load i1, i1* %retval
  ret i1 %11
}

declare i64 @Fcurrent_buffer() #1

; Function Attrs: nounwind uwtable
define internal i64 @specpdl_where(%union.specbinding* %pdl) #0 {
entry:
  %pdl.addr = alloca %union.specbinding*, align 8
  store %union.specbinding* %pdl, %union.specbinding** %pdl.addr, align 8
  %0 = load %union.specbinding*, %union.specbinding** %pdl.addr, align 8
  %let = bitcast %union.specbinding* %0 to %struct.anon.3*
  %where = getelementptr inbounds %struct.anon.3, %struct.anon.3* %let, i32 0, i32 3
  %1 = load i64, i64* %where, align 8
  ret i64 %1
}

; Function Attrs: nounwind uwtable
define zeroext i1 @let_shadows_global_binding_p(i64 %symbol) #0 {
entry:
  %retval = alloca i1, align 1
  %symbol.addr = alloca i64, align 8
  %p = alloca %union.specbinding*, align 8
  store i64 %symbol, i64* %symbol.addr, align 8
  %0 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  store %union.specbinding* %0, %union.specbinding** %p, align 8
  br label %for.cond

for.cond:                                         ; preds = %if.end, %entry
  %1 = load %union.specbinding*, %union.specbinding** %p, align 8
  %2 = load %union.specbinding*, %union.specbinding** @specpdl, align 8
  %cmp = icmp ugt %union.specbinding* %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load %union.specbinding*, %union.specbinding** %p, align 8
  %incdec.ptr = getelementptr inbounds %union.specbinding, %union.specbinding* %3, i32 -1
  store %union.specbinding* %incdec.ptr, %union.specbinding** %p, align 8
  %4 = bitcast %union.specbinding* %incdec.ptr to i8*
  %bf.load = load i8, i8* %4, align 8
  %bf.cast = zext i8 %bf.load to i32
  %cmp1 = icmp sge i32 %bf.cast, 5
  br i1 %cmp1, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.body
  %5 = load %union.specbinding*, %union.specbinding** %p, align 8
  %call = call i64 @specpdl_symbol(%union.specbinding* %5)
  %6 = load i64, i64* %symbol.addr, align 8
  %cmp2 = icmp eq i64 %call, %6
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store i1 true, i1* %retval
  br label %return

if.end:                                           ; preds = %land.lhs.true, %for.body
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i1 false, i1* %retval
  br label %return

return:                                           ; preds = %for.end, %if.then
  %7 = load i1, i1* %retval
  ret i1 %7
}

declare %struct.Lisp_Symbol* @indirect_variable(%struct.Lisp_Symbol*) #1

declare i64 @make_lisp_symbol(%struct.Lisp_Symbol*) #1

declare %struct.Lisp_Buffer_Local_Value* @SYMBOL_BLV(%struct.Lisp_Symbol*) #1

declare i32 @blv_found(%struct.Lisp_Buffer_Local_Value*) #1

declare zeroext i1 @BUFFER_OBJFWDP(%union.Lisp_Fwd*) #1

declare %union.Lisp_Fwd* @SYMBOL_FWD(%struct.Lisp_Symbol*) #1

declare i64 @Flocal_variable_p(i64, i64) #1

; Function Attrs: nounwind uwtable
define void @record_unwind_protect_ptr(void (i8*)* %function, i8* %arg) #0 {
entry:
  %function.addr = alloca void (i8*)*, align 8
  %arg.addr = alloca i8*, align 8
  store void (i8*)* %function, void (i8*)** %function.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  %0 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %unwind_ptr = bitcast %union.specbinding* %0 to %struct.anon.0*
  %1 = bitcast %struct.anon.0* %unwind_ptr to i8*
  store i8 1, i8* %1, align 8
  %2 = load void (i8*)*, void (i8*)** %function.addr, align 8
  %3 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %unwind_ptr1 = bitcast %union.specbinding* %3 to %struct.anon.0*
  %func = getelementptr inbounds %struct.anon.0, %struct.anon.0* %unwind_ptr1, i32 0, i32 1
  store void (i8*)* %2, void (i8*)** %func, align 8
  %4 = load i8*, i8** %arg.addr, align 8
  %5 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %unwind_ptr2 = bitcast %union.specbinding* %5 to %struct.anon.0*
  %arg3 = getelementptr inbounds %struct.anon.0, %struct.anon.0* %unwind_ptr2, i32 0, i32 2
  store i8* %4, i8** %arg3, align 8
  call void @grow_specpdl()
  ret void
}

; Function Attrs: nounwind uwtable
define void @record_unwind_protect_int(void (i32)* %function, i32 %arg) #0 {
entry:
  %function.addr = alloca void (i32)*, align 8
  %arg.addr = alloca i32, align 4
  store void (i32)* %function, void (i32)** %function.addr, align 8
  store i32 %arg, i32* %arg.addr, align 4
  %0 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %unwind_int = bitcast %union.specbinding* %0 to %struct.anon.1*
  %1 = bitcast %struct.anon.1* %unwind_int to i8*
  store i8 2, i8* %1, align 8
  %2 = load void (i32)*, void (i32)** %function.addr, align 8
  %3 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %unwind_int1 = bitcast %union.specbinding* %3 to %struct.anon.1*
  %func = getelementptr inbounds %struct.anon.1, %struct.anon.1* %unwind_int1, i32 0, i32 1
  store void (i32)* %2, void (i32)** %func, align 8
  %4 = load i32, i32* %arg.addr, align 4
  %5 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %unwind_int2 = bitcast %union.specbinding* %5 to %struct.anon.1*
  %arg3 = getelementptr inbounds %struct.anon.1, %struct.anon.1* %unwind_int2, i32 0, i32 2
  store i32 %4, i32* %arg3, align 4
  call void @grow_specpdl()
  ret void
}

; Function Attrs: nounwind uwtable
define void @record_unwind_protect_void(void ()* %function) #0 {
entry:
  %function.addr = alloca void ()*, align 8
  store void ()* %function, void ()** %function.addr, align 8
  %0 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %unwind_void = bitcast %union.specbinding* %0 to %struct.anon.2*
  %1 = bitcast %struct.anon.2* %unwind_void to i8*
  store i8 3, i8* %1, align 8
  %2 = load void ()*, void ()** %function.addr, align 8
  %3 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %unwind_void1 = bitcast %union.specbinding* %3 to %struct.anon.2*
  %func = getelementptr inbounds %struct.anon.2, %struct.anon.2* %unwind_void1, i32 0, i32 1
  store void ()* %2, void ()** %func, align 8
  call void @grow_specpdl()
  ret void
}

; Function Attrs: nounwind uwtable
define void @record_unwind_protect_nothing() #0 {
entry:
  call void @record_unwind_protect_void(void ()* @do_nothing)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @do_nothing() #0 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define void @clear_unwind_protect(i64 %count) #0 {
entry:
  %count.addr = alloca i64, align 8
  %p = alloca %union.specbinding*, align 8
  store i64 %count, i64* %count.addr, align 8
  %0 = load %union.specbinding*, %union.specbinding** @specpdl, align 8
  %1 = load i64, i64* %count.addr, align 8
  %add.ptr = getelementptr inbounds %union.specbinding, %union.specbinding* %0, i64 %1
  store %union.specbinding* %add.ptr, %union.specbinding** %p, align 8
  %2 = load %union.specbinding*, %union.specbinding** %p, align 8
  %unwind_void = bitcast %union.specbinding* %2 to %struct.anon.2*
  %3 = bitcast %struct.anon.2* %unwind_void to i8*
  store i8 3, i8* %3, align 8
  %4 = load %union.specbinding*, %union.specbinding** %p, align 8
  %unwind_void1 = bitcast %union.specbinding* %4 to %struct.anon.2*
  %func = getelementptr inbounds %struct.anon.2, %struct.anon.2* %unwind_void1, i32 0, i32 1
  store void ()* @do_nothing, void ()** %func, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define void @set_unwind_protect(i64 %count, void (i64)* %func, i64 %arg) #0 {
entry:
  %count.addr = alloca i64, align 8
  %func.addr = alloca void (i64)*, align 8
  %arg.addr = alloca i64, align 8
  %p = alloca %union.specbinding*, align 8
  store i64 %count, i64* %count.addr, align 8
  store void (i64)* %func, void (i64)** %func.addr, align 8
  store i64 %arg, i64* %arg.addr, align 8
  %0 = load %union.specbinding*, %union.specbinding** @specpdl, align 8
  %1 = load i64, i64* %count.addr, align 8
  %add.ptr = getelementptr inbounds %union.specbinding, %union.specbinding* %0, i64 %1
  store %union.specbinding* %add.ptr, %union.specbinding** %p, align 8
  %2 = load %union.specbinding*, %union.specbinding** %p, align 8
  %unwind = bitcast %union.specbinding* %2 to %struct.anon*
  %3 = bitcast %struct.anon* %unwind to i8*
  store i8 0, i8* %3, align 8
  %4 = load void (i64)*, void (i64)** %func.addr, align 8
  %5 = load %union.specbinding*, %union.specbinding** %p, align 8
  %unwind1 = bitcast %union.specbinding* %5 to %struct.anon*
  %func2 = getelementptr inbounds %struct.anon, %struct.anon* %unwind1, i32 0, i32 1
  store void (i64)* %4, void (i64)** %func2, align 8
  %6 = load i64, i64* %arg.addr, align 8
  %7 = load %union.specbinding*, %union.specbinding** %p, align 8
  %unwind3 = bitcast %union.specbinding* %7 to %struct.anon*
  %arg4 = getelementptr inbounds %struct.anon, %struct.anon* %unwind3, i32 0, i32 2
  store i64 %6, i64* %arg4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define void @set_unwind_protect_ptr(i64 %count, void (i8*)* %func, i8* %arg) #0 {
entry:
  %count.addr = alloca i64, align 8
  %func.addr = alloca void (i8*)*, align 8
  %arg.addr = alloca i8*, align 8
  %p = alloca %union.specbinding*, align 8
  store i64 %count, i64* %count.addr, align 8
  store void (i8*)* %func, void (i8*)** %func.addr, align 8
  store i8* %arg, i8** %arg.addr, align 8
  %0 = load %union.specbinding*, %union.specbinding** @specpdl, align 8
  %1 = load i64, i64* %count.addr, align 8
  %add.ptr = getelementptr inbounds %union.specbinding, %union.specbinding* %0, i64 %1
  store %union.specbinding* %add.ptr, %union.specbinding** %p, align 8
  %2 = load %union.specbinding*, %union.specbinding** %p, align 8
  %unwind_ptr = bitcast %union.specbinding* %2 to %struct.anon.0*
  %3 = bitcast %struct.anon.0* %unwind_ptr to i8*
  store i8 1, i8* %3, align 8
  %4 = load void (i8*)*, void (i8*)** %func.addr, align 8
  %5 = load %union.specbinding*, %union.specbinding** %p, align 8
  %unwind_ptr1 = bitcast %union.specbinding* %5 to %struct.anon.0*
  %func2 = getelementptr inbounds %struct.anon.0, %struct.anon.0* %unwind_ptr1, i32 0, i32 1
  store void (i8*)* %4, void (i8*)** %func2, align 8
  %6 = load i8*, i8** %arg.addr, align 8
  %7 = load %union.specbinding*, %union.specbinding** %p, align 8
  %unwind_ptr3 = bitcast %union.specbinding* %7 to %struct.anon.0*
  %arg4 = getelementptr inbounds %struct.anon.0, %struct.anon.0* %unwind_ptr3, i32 0, i32 2
  store i8* %6, i8** %arg4, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define i64 @Fspecial_variable_p(i64 %symbol) #0 {
entry:
  %symbol.addr = alloca i64, align 8
  store i64 %symbol, i64* %symbol.addr, align 8
  %0 = load i64, i64* %symbol.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = call i64 @builtin_lisp_symbol(i32 897)
  %1 = load i64, i64* %symbol.addr, align 8
  %2 = call i64 @wrong_type_argument(i64 %call, i64 %1) #8
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %3, %cond.true
  %4 = load i64, i64* %symbol.addr, align 8
  %sub = sub nsw i64 %4, 0
  %add.ptr = getelementptr inbounds i8, i8* bitcast ([1074 x %struct.Lisp_Symbol]* @lispsym to i8*), i64 %sub
  %5 = bitcast i8* %add.ptr to %struct.Lisp_Symbol*
  %6 = bitcast %struct.Lisp_Symbol* %5 to i16*
  %bf.load = load i16, i16* %6, align 8
  %bf.lshr = lshr i16 %bf.load, 8
  %bf.clear = and i16 %bf.lshr, 1
  %bf.cast = trunc i16 %bf.clear to i1
  br i1 %bf.cast, label %cond.true.3, label %cond.false.5

cond.true.3:                                      ; preds = %cond.end
  %call4 = call i64 @builtin_lisp_symbol(i32 901)
  br label %cond.end.7

cond.false.5:                                     ; preds = %cond.end
  %call6 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end.7

cond.end.7:                                       ; preds = %cond.false.5, %cond.true.3
  %cond = phi i64 [ %call4, %cond.true.3 ], [ %call6, %cond.false.5 ]
  ret i64 %cond
}

; Function Attrs: nounwind uwtable
define i64 @Fbacktrace_debug(i64 %level, i64 %flag) #0 {
entry:
  %level.addr = alloca i64, align 8
  %flag.addr = alloca i64, align 8
  %pdl = alloca %union.specbinding*, align 8
  %i = alloca i64, align 8
  store i64 %level, i64* %level.addr, align 8
  store i64 %flag, i64* %flag.addr, align 8
  %call = call %union.specbinding* @backtrace_top()
  store %union.specbinding* %call, %union.specbinding** %pdl, align 8
  %0 = load i64, i64* %level.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %and1 = and i32 %conv, -5
  %cmp = icmp eq i32 %and1, 2
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call3 = call i64 @builtin_lisp_symbol(i32 559)
  %1 = load i64, i64* %level.addr, align 8
  %2 = call i64 @wrong_type_argument(i64 %call3, i64 %1) #8
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %3, %cond.true
  store i64 0, i64* %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %4 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %call4 = call zeroext i1 @backtrace_p(%union.specbinding* %4)
  br i1 %call4, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %5 = load i64, i64* %i, align 8
  %6 = load i64, i64* %level.addr, align 8
  %shr = ashr i64 %6, 2
  %cmp6 = icmp slt i64 %5, %shr
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %7 = phi i1 [ false, %for.cond ], [ %cmp6, %land.rhs ]
  br i1 %7, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %8 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %call8 = call %union.specbinding* @backtrace_next(%union.specbinding* %8)
  store %union.specbinding* %call8, %union.specbinding** %pdl, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %9 = load i64, i64* %i, align 8
  %inc = add nsw i64 %9, 1
  store i64 %inc, i64* %i, align 8
  br label %for.cond

for.end:                                          ; preds = %land.end
  %10 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %call9 = call zeroext i1 @backtrace_p(%union.specbinding* %10)
  br i1 %call9, label %if.then, label %if.end

if.then:                                          ; preds = %for.end
  %11 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %12 = load i64, i64* %flag.addr, align 8
  %call10 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp11 = icmp eq i64 %12, %call10
  %lnot = xor i1 %cmp11, true
  call void @set_backtrace_debug_on_exit(%union.specbinding* %11, i1 zeroext %lnot)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.end
  %13 = load i64, i64* %flag.addr, align 8
  ret i64 %13
}

; Function Attrs: nounwind uwtable
define internal void @set_backtrace_debug_on_exit(%union.specbinding* %pdl, i1 zeroext %doe) #0 {
entry:
  %pdl.addr = alloca %union.specbinding*, align 8
  %doe.addr = alloca i8, align 1
  store %union.specbinding* %pdl, %union.specbinding** %pdl.addr, align 8
  %frombool = zext i1 %doe to i8
  store i8 %frombool, i8* %doe.addr, align 1
  %0 = load i8, i8* %doe.addr, align 1
  %tobool = trunc i8 %0 to i1
  %1 = load %union.specbinding*, %union.specbinding** %pdl.addr, align 8
  %bt = bitcast %union.specbinding* %1 to %struct.anon.4*
  %2 = bitcast %struct.anon.4* %bt to i16*
  %3 = zext i1 %tobool to i16
  %bf.load = load i16, i16* %2, align 8
  %bf.shl = shl i16 %3, 8
  %bf.clear = and i16 %bf.load, -257
  %bf.set = or i16 %bf.clear, %bf.shl
  store i16 %bf.set, i16* %2, align 8
  %bf.result.cast = trunc i16 %3 to i8
  %tobool1 = trunc i8 %bf.result.cast to i1
  ret void
}

; Function Attrs: nounwind uwtable
define i64 @Fbacktrace() #0 {
entry:
  %pdl = alloca %union.specbinding*, align 8
  %tem = alloca i64, align 8
  %old_print_level = alloca i64, align 8
  %i = alloca i64, align 8
  %call = call %union.specbinding* @backtrace_top()
  store %union.specbinding* %call, %union.specbinding** %pdl, align 8
  %0 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 233), align 8
  store i64 %0, i64* %old_print_level, align 8
  %1 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 233), align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %1, %call1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call2 = call i64 @make_natnum(i64 8)
  store i64 %call2, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 233), align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  br label %while.cond

while.cond:                                       ; preds = %if.end.23, %if.end
  %2 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %call3 = call zeroext i1 @backtrace_p(%union.specbinding* %2)
  br i1 %call3, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %call4 = call zeroext i1 @backtrace_debug_on_exit(%union.specbinding* %3)
  %cond = select i1 %call4, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.15, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.16, i32 0, i32 0)
  call void @write_string(i8* %cond)
  %4 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %call5 = call i64 @backtrace_nargs(%union.specbinding* %4)
  %cmp6 = icmp eq i64 %call5, -1
  br i1 %cmp6, label %if.then.7, label %if.else

if.then.7:                                        ; preds = %while.body
  %5 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %call8 = call i64 @backtrace_function(%union.specbinding* %5)
  %6 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %call9 = call i64* @backtrace_args(%union.specbinding* %6)
  %7 = load i64, i64* %call9, align 8
  %call10 = call i64 @Fcons(i64 %call8, i64 %7)
  %call11 = call i64 @builtin_lisp_symbol(i32 0)
  %call12 = call i64 @Fprin1(i64 %call10, i64 %call11)
  call void @write_string(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.17, i32 0, i32 0))
  br label %if.end.23

if.else:                                          ; preds = %while.body
  %8 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %call13 = call i64 @backtrace_function(%union.specbinding* %8)
  store i64 %call13, i64* %tem, align 8
  %9 = load i64, i64* %tem, align 8
  %call14 = call i64 @builtin_lisp_symbol(i32 0)
  %call15 = call i64 @Fprin1(i64 %9, i64 %call14)
  call void @write_string(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.18, i32 0, i32 0))
  store i64 0, i64* %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.else
  %10 = load i64, i64* %i, align 8
  %11 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %call16 = call i64 @backtrace_nargs(%union.specbinding* %11)
  %cmp17 = icmp slt i64 %10, %call16
  br i1 %cmp17, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i64, i64* %i, align 8
  %tobool = icmp ne i64 %12, 0
  br i1 %tobool, label %if.then.18, label %if.end.19

if.then.18:                                       ; preds = %for.body
  call void @write_string(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.19, i32 0, i32 0))
  br label %if.end.19

if.end.19:                                        ; preds = %if.then.18, %for.body
  %13 = load i64, i64* %i, align 8
  %14 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %call20 = call i64* @backtrace_args(%union.specbinding* %14)
  %arrayidx = getelementptr inbounds i64, i64* %call20, i64 %13
  %15 = load i64, i64* %arrayidx, align 8
  %call21 = call i64 @builtin_lisp_symbol(i32 0)
  %call22 = call i64 @Fprin1(i64 %15, i64 %call21)
  br label %for.inc

for.inc:                                          ; preds = %if.end.19
  %16 = load i64, i64* %i, align 8
  %inc = add nsw i64 %16, 1
  store i64 %inc, i64* %i, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  call void @write_string(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.20, i32 0, i32 0))
  br label %if.end.23

if.end.23:                                        ; preds = %for.end, %if.then.7
  %17 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %call24 = call %union.specbinding* @backtrace_next(%union.specbinding* %17)
  store %union.specbinding* %call24, %union.specbinding** %pdl, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %18 = load i64, i64* %old_print_level, align 8
  store i64 %18, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 233), align 8
  %call25 = call i64 @builtin_lisp_symbol(i32 0)
  ret i64 %call25
}

declare void @write_string(i8*) #1

; Function Attrs: nounwind uwtable
define internal i64 @backtrace_nargs(%union.specbinding* %pdl) #0 {
entry:
  %pdl.addr = alloca %union.specbinding*, align 8
  store %union.specbinding* %pdl, %union.specbinding** %pdl.addr, align 8
  %0 = load %union.specbinding*, %union.specbinding** %pdl.addr, align 8
  %bt = bitcast %union.specbinding* %0 to %struct.anon.4*
  %nargs = getelementptr inbounds %struct.anon.4, %struct.anon.4* %bt, i32 0, i32 3
  %1 = load i64, i64* %nargs, align 8
  ret i64 %1
}

declare i64 @Fprin1(i64, i64) #1

; Function Attrs: nounwind uwtable
define i64 @Fbacktrace_frame(i64 %nframes, i64 %base) #0 {
entry:
  %retval = alloca i64, align 8
  %nframes.addr = alloca i64, align 8
  %base.addr = alloca i64, align 8
  %pdl = alloca %union.specbinding*, align 8
  %tem = alloca i64, align 8
  store i64 %nframes, i64* %nframes.addr, align 8
  store i64 %base, i64* %base.addr, align 8
  %0 = load i64, i64* %nframes.addr, align 8
  %1 = load i64, i64* %base.addr, align 8
  %call = call %union.specbinding* @get_backtrace_frame(i64 %0, i64 %1)
  store %union.specbinding* %call, %union.specbinding** %pdl, align 8
  %2 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %call1 = call zeroext i1 @backtrace_p(%union.specbinding* %2)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call2, i64* %retval
  br label %return

if.end:                                           ; preds = %entry
  %3 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %call3 = call i64 @backtrace_nargs(%union.specbinding* %3)
  %cmp = icmp eq i64 %call3, -1
  br i1 %cmp, label %if.then.4, label %if.else

if.then.4:                                        ; preds = %if.end
  %call5 = call i64 @builtin_lisp_symbol(i32 0)
  %4 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %call6 = call i64 @backtrace_function(%union.specbinding* %4)
  %5 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %call7 = call i64* @backtrace_args(%union.specbinding* %5)
  %6 = load i64, i64* %call7, align 8
  %call8 = call i64 @Fcons(i64 %call6, i64 %6)
  %call9 = call i64 @Fcons(i64 %call5, i64 %call8)
  store i64 %call9, i64* %retval
  br label %return

if.else:                                          ; preds = %if.end
  %7 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %call10 = call i64 @backtrace_nargs(%union.specbinding* %7)
  %8 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %call11 = call i64* @backtrace_args(%union.specbinding* %8)
  %call12 = call i64 @Flist(i64 %call10, i64* %call11)
  store i64 %call12, i64* %tem, align 8
  %call13 = call i64 @builtin_lisp_symbol(i32 901)
  %9 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %call14 = call i64 @backtrace_function(%union.specbinding* %9)
  %10 = load i64, i64* %tem, align 8
  %call15 = call i64 @Fcons(i64 %call14, i64 %10)
  %call16 = call i64 @Fcons(i64 %call13, i64 %call15)
  store i64 %call16, i64* %retval
  br label %return

return:                                           ; preds = %if.else, %if.then.4, %if.then
  %11 = load i64, i64* %retval
  ret i64 %11
}

; Function Attrs: nounwind uwtable
define internal %union.specbinding* @get_backtrace_frame(i64 %nframes, i64 %base) #0 {
entry:
  %nframes.addr = alloca i64, align 8
  %base.addr = alloca i64, align 8
  %pdl = alloca %union.specbinding*, align 8
  %i = alloca i64, align 8
  store i64 %nframes, i64* %nframes.addr, align 8
  store i64 %base, i64* %base.addr, align 8
  %call = call %union.specbinding* @backtrace_top()
  store %union.specbinding* %call, %union.specbinding** %pdl, align 8
  %0 = load i64, i64* %nframes.addr, align 8
  call void @CHECK_NATNUM(i64 %0)
  %1 = load i64, i64* %base.addr, align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %1, %call1
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i64, i64* %base.addr, align 8
  %call2 = call i64 @builtin_lisp_symbol(i32 901)
  %call3 = call i64 @Findirect_function(i64 %2, i64 %call2)
  store i64 %call3, i64* %base.addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then
  %3 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %call4 = call zeroext i1 @backtrace_p(%union.specbinding* %3)
  br i1 %call4, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %4 = load i64, i64* %base.addr, align 8
  %5 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %call5 = call i64 @backtrace_function(%union.specbinding* %5)
  %call6 = call i64 @builtin_lisp_symbol(i32 901)
  %call7 = call i64 @Findirect_function(i64 %call5, i64 %call6)
  %cmp8 = icmp eq i64 %4, %call7
  %lnot = xor i1 %cmp8, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %6 = phi i1 [ false, %while.cond ], [ %lnot, %land.rhs ]
  br i1 %6, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %7 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %call9 = call %union.specbinding* @backtrace_next(%union.specbinding* %7)
  store %union.specbinding* %call9, %union.specbinding** %pdl, align 8
  br label %while.cond

while.end:                                        ; preds = %land.end
  br label %if.end

if.end:                                           ; preds = %while.end, %entry
  %8 = load i64, i64* %nframes.addr, align 8
  %shr = ashr i64 %8, 2
  store i64 %shr, i64* %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %9 = load i64, i64* %i, align 8
  %cmp10 = icmp sgt i64 %9, 0
  br i1 %cmp10, label %land.rhs.11, label %land.end.13

land.rhs.11:                                      ; preds = %for.cond
  %10 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %call12 = call zeroext i1 @backtrace_p(%union.specbinding* %10)
  br label %land.end.13

land.end.13:                                      ; preds = %land.rhs.11, %for.cond
  %11 = phi i1 [ false, %for.cond ], [ %call12, %land.rhs.11 ]
  br i1 %11, label %for.body, label %for.end

for.body:                                         ; preds = %land.end.13
  %12 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %call14 = call %union.specbinding* @backtrace_next(%union.specbinding* %12)
  store %union.specbinding* %call14, %union.specbinding** %pdl, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %13 = load i64, i64* %i, align 8
  %dec = add nsw i64 %13, -1
  store i64 %dec, i64* %i, align 8
  br label %for.cond

for.end:                                          ; preds = %land.end.13
  %14 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  ret %union.specbinding* %14
}

declare i64 @Flist(i64, i64*) #1

; Function Attrs: nounwind uwtable
define i64 @Fbacktrace_eval(i64 %exp, i64 %nframes, i64 %base) #0 {
entry:
  %exp.addr = alloca i64, align 8
  %nframes.addr = alloca i64, align 8
  %base.addr = alloca i64, align 8
  %pdl = alloca %union.specbinding*, align 8
  %count = alloca i64, align 8
  %distance = alloca i64, align 8
  store i64 %exp, i64* %exp.addr, align 8
  store i64 %nframes, i64* %nframes.addr, align 8
  store i64 %base, i64* %base.addr, align 8
  %0 = load i64, i64* %nframes.addr, align 8
  %1 = load i64, i64* %base.addr, align 8
  %call = call %union.specbinding* @get_backtrace_frame(i64 %0, i64 %1)
  store %union.specbinding* %call, %union.specbinding** %pdl, align 8
  %call1 = call i64 @SPECPDL_INDEX()
  store i64 %call1, i64* %count, align 8
  %2 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %3 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %sub.ptr.lhs.cast = ptrtoint %union.specbinding* %2 to i64
  %sub.ptr.rhs.cast = ptrtoint %union.specbinding* %3 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 32
  store i64 %sub.ptr.div, i64* %distance, align 8
  %4 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %call2 = call zeroext i1 @backtrace_p(%union.specbinding* %4)
  br i1 %call2, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call void (i8*, ...) @error(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.21, i32 0, i32 0)) #8
  unreachable

if.end:                                           ; preds = %entry
  %5 = load i64, i64* %distance, align 8
  %conv = trunc i64 %5 to i32
  call void @backtrace_eval_unrewind(i32 %conv)
  %6 = load i64, i64* %distance, align 8
  %sub = sub nsw i64 0, %6
  %conv3 = trunc i64 %sub to i32
  call void @record_unwind_protect_int(void (i32)* @backtrace_eval_unrewind, i32 %conv3)
  %7 = load i64, i64* %count, align 8
  %8 = load i64, i64* %exp.addr, align 8
  %call4 = call i64 @eval_sub(i64 %8)
  %call5 = call i64 @unbind_to(i64 %7, i64 %call4)
  ret i64 %call5
}

; Function Attrs: nounwind uwtable
define internal void @backtrace_eval_unrewind(i32 %distance) #0 {
entry:
  %distance.addr = alloca i32, align 4
  %tmp = alloca %union.specbinding*, align 8
  %step = alloca i32, align 4
  %oldarg = alloca i64, align 8
  %sym = alloca i64, align 8
  %old_value = alloca i64, align 8
  %sym49 = alloca i64, align 8
  %old_value52 = alloca i64, align 8
  %symbol = alloca i64, align 8
  %where = alloca i64, align 8
  %old_value62 = alloca i64, align 8
  store i32 %distance, i32* %distance.addr, align 4
  %0 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  store %union.specbinding* %0, %union.specbinding** %tmp, align 8
  store i32 -1, i32* %step, align 4
  %1 = load i32, i32* %distance.addr, align 4
  %cmp = icmp slt i32 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32, i32* %distance.addr, align 4
  %sub = sub nsw i32 %2, 1
  %3 = load %union.specbinding*, %union.specbinding** %tmp, align 8
  %idx.ext = sext i32 %sub to i64
  %add.ptr = getelementptr inbounds %union.specbinding, %union.specbinding* %3, i64 %idx.ext
  store %union.specbinding* %add.ptr, %union.specbinding** %tmp, align 8
  store i32 1, i32* %step, align 4
  %4 = load i32, i32* %distance.addr, align 4
  %sub2 = sub nsw i32 0, %4
  store i32 %sub2, i32* %distance.addr, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %5 = load i32, i32* %distance.addr, align 4
  %cmp3 = icmp sgt i32 %5, 0
  br i1 %cmp3, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load i32, i32* %step, align 4
  %7 = load %union.specbinding*, %union.specbinding** %tmp, align 8
  %idx.ext4 = sext i32 %6 to i64
  %add.ptr5 = getelementptr inbounds %union.specbinding, %union.specbinding* %7, i64 %idx.ext4
  store %union.specbinding* %add.ptr5, %union.specbinding** %tmp, align 8
  %8 = load %union.specbinding*, %union.specbinding** %tmp, align 8
  %9 = bitcast %union.specbinding* %8 to i8*
  %bf.load = load i8, i8* %9, align 8
  %bf.cast = zext i8 %bf.load to i32
  switch i32 %bf.cast, label %sw.epilog [
    i32 0, label %sw.bb
    i32 1, label %sw.bb.24
    i32 2, label %sw.bb.24
    i32 3, label %sw.bb.24
    i32 4, label %sw.bb.24
    i32 5, label %sw.bb.25
    i32 7, label %sw.bb.47
    i32 6, label %sw.bb.56
  ]

sw.bb:                                            ; preds = %for.body
  %10 = load %union.specbinding*, %union.specbinding** %tmp, align 8
  %unwind = bitcast %union.specbinding* %10 to %struct.anon*
  %arg = getelementptr inbounds %struct.anon, %struct.anon* %unwind, i32 0, i32 2
  %11 = load i64, i64* %arg, align 8
  store i64 %11, i64* %oldarg, align 8
  %12 = load %union.specbinding*, %union.specbinding** %tmp, align 8
  %unwind7 = bitcast %union.specbinding* %12 to %struct.anon*
  %func = getelementptr inbounds %struct.anon, %struct.anon* %unwind7, i32 0, i32 1
  %13 = load void (i64)*, void (i64)** %func, align 8
  %cmp8 = icmp eq void (i64)* %13, @set_buffer_if_live
  br i1 %cmp8, label %if.then.9, label %if.else

if.then.9:                                        ; preds = %sw.bb
  %call = call i64 @Fcurrent_buffer()
  %14 = load %union.specbinding*, %union.specbinding** %tmp, align 8
  %unwind10 = bitcast %union.specbinding* %14 to %struct.anon*
  %arg11 = getelementptr inbounds %struct.anon, %struct.anon* %unwind10, i32 0, i32 2
  store i64 %call, i64* %arg11, align 8
  br label %if.end.21

if.else:                                          ; preds = %sw.bb
  %15 = load %union.specbinding*, %union.specbinding** %tmp, align 8
  %unwind12 = bitcast %union.specbinding* %15 to %struct.anon*
  %func13 = getelementptr inbounds %struct.anon, %struct.anon* %unwind12, i32 0, i32 1
  %16 = load void (i64)*, void (i64)** %func13, align 8
  %cmp14 = icmp eq void (i64)* %16, @save_excursion_restore
  br i1 %cmp14, label %if.then.15, label %if.else.19

if.then.15:                                       ; preds = %if.else
  %call16 = call i64 @save_excursion_save()
  %17 = load %union.specbinding*, %union.specbinding** %tmp, align 8
  %unwind17 = bitcast %union.specbinding* %17 to %struct.anon*
  %arg18 = getelementptr inbounds %struct.anon, %struct.anon* %unwind17, i32 0, i32 2
  store i64 %call16, i64* %arg18, align 8
  br label %if.end.20

if.else.19:                                       ; preds = %if.else
  br label %sw.epilog

if.end.20:                                        ; preds = %if.then.15
  br label %if.end.21

if.end.21:                                        ; preds = %if.end.20, %if.then.9
  %18 = load %union.specbinding*, %union.specbinding** %tmp, align 8
  %unwind22 = bitcast %union.specbinding* %18 to %struct.anon*
  %func23 = getelementptr inbounds %struct.anon, %struct.anon* %unwind22, i32 0, i32 1
  %19 = load void (i64)*, void (i64)** %func23, align 8
  %20 = load i64, i64* %oldarg, align 8
  call void %19(i64 %20)
  br label %sw.epilog

sw.bb.24:                                         ; preds = %for.body, %for.body, %for.body, %for.body
  br label %sw.epilog

sw.bb.25:                                         ; preds = %for.body
  %21 = load %union.specbinding*, %union.specbinding** %tmp, align 8
  %call27 = call i64 @specpdl_symbol(%union.specbinding* %21)
  store i64 %call27, i64* %sym, align 8
  %22 = load i64, i64* %sym, align 8
  %and = and i64 %22, 7
  %conv = trunc i64 %and to i32
  %cmp28 = icmp eq i32 %conv, 0
  br i1 %cmp28, label %land.lhs.true, label %if.else.45

land.lhs.true:                                    ; preds = %sw.bb.25
  %23 = load i64, i64* %sym, align 8
  %sub30 = sub nsw i64 %23, 0
  %add.ptr31 = getelementptr inbounds i8, i8* bitcast ([1074 x %struct.Lisp_Symbol]* @lispsym to i8*), i64 %sub30
  %24 = bitcast i8* %add.ptr31 to %struct.Lisp_Symbol*
  %25 = bitcast %struct.Lisp_Symbol* %24 to i16*
  %bf.load32 = load i16, i16* %25, align 8
  %bf.lshr = lshr i16 %bf.load32, 1
  %bf.clear = and i16 %bf.lshr, 7
  %bf.cast33 = zext i16 %bf.clear to i32
  %cmp34 = icmp eq i32 %bf.cast33, 4
  br i1 %cmp34, label %if.then.36, label %if.else.45

if.then.36:                                       ; preds = %land.lhs.true
  %26 = load %union.specbinding*, %union.specbinding** %tmp, align 8
  %call38 = call i64 @specpdl_old_value(%union.specbinding* %26)
  store i64 %call38, i64* %old_value, align 8
  %27 = load %union.specbinding*, %union.specbinding** %tmp, align 8
  %28 = load i64, i64* %sym, align 8
  %sub39 = sub nsw i64 %28, 0
  %add.ptr40 = getelementptr inbounds i8, i8* bitcast ([1074 x %struct.Lisp_Symbol]* @lispsym to i8*), i64 %sub39
  %29 = bitcast i8* %add.ptr40 to %struct.Lisp_Symbol*
  %val = getelementptr inbounds %struct.Lisp_Symbol, %struct.Lisp_Symbol* %29, i32 0, i32 2
  %value = bitcast %union.anon.5* %val to i64*
  %30 = load i64, i64* %value, align 8
  call void @set_specpdl_old_value(%union.specbinding* %27, i64 %30)
  %31 = load i64, i64* %old_value, align 8
  %32 = load i64, i64* %sym, align 8
  %sub41 = sub nsw i64 %32, 0
  %add.ptr42 = getelementptr inbounds i8, i8* bitcast ([1074 x %struct.Lisp_Symbol]* @lispsym to i8*), i64 %sub41
  %33 = bitcast i8* %add.ptr42 to %struct.Lisp_Symbol*
  %val43 = getelementptr inbounds %struct.Lisp_Symbol, %struct.Lisp_Symbol* %33, i32 0, i32 2
  %value44 = bitcast %union.anon.5* %val43 to i64*
  store i64 %31, i64* %value44, align 8
  br label %sw.epilog

if.else.45:                                       ; preds = %land.lhs.true, %sw.bb.25
  br label %if.end.46

if.end.46:                                        ; preds = %if.else.45
  br label %sw.bb.47

sw.bb.47:                                         ; preds = %for.body, %if.end.46
  %34 = load %union.specbinding*, %union.specbinding** %tmp, align 8
  %call50 = call i64 @specpdl_symbol(%union.specbinding* %34)
  store i64 %call50, i64* %sym49, align 8
  %35 = load %union.specbinding*, %union.specbinding** %tmp, align 8
  %call53 = call i64 @specpdl_old_value(%union.specbinding* %35)
  store i64 %call53, i64* %old_value52, align 8
  %36 = load %union.specbinding*, %union.specbinding** %tmp, align 8
  %37 = load i64, i64* %sym49, align 8
  %call54 = call i64 @Fdefault_value(i64 %37)
  call void @set_specpdl_old_value(%union.specbinding* %36, i64 %call54)
  %38 = load i64, i64* %sym49, align 8
  %39 = load i64, i64* %old_value52, align 8
  %call55 = call i64 @Fset_default(i64 %38, i64 %39)
  br label %sw.epilog

sw.bb.56:                                         ; preds = %for.body
  %40 = load %union.specbinding*, %union.specbinding** %tmp, align 8
  %call58 = call i64 @specpdl_symbol(%union.specbinding* %40)
  store i64 %call58, i64* %symbol, align 8
  %41 = load %union.specbinding*, %union.specbinding** %tmp, align 8
  %call60 = call i64 @specpdl_where(%union.specbinding* %41)
  store i64 %call60, i64* %where, align 8
  %42 = load %union.specbinding*, %union.specbinding** %tmp, align 8
  %call63 = call i64 @specpdl_old_value(%union.specbinding* %42)
  store i64 %call63, i64* %old_value62, align 8
  %43 = load i64, i64* %symbol, align 8
  %44 = load i64, i64* %where, align 8
  %call64 = call i64 @Flocal_variable_p(i64 %43, i64 %44)
  %call65 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp66 = icmp eq i64 %call64, %call65
  br i1 %cmp66, label %if.end.70, label %if.then.68

if.then.68:                                       ; preds = %sw.bb.56
  %45 = load %union.specbinding*, %union.specbinding** %tmp, align 8
  %46 = load i64, i64* %symbol, align 8
  %47 = load i64, i64* %where, align 8
  %call69 = call i64 @Fbuffer_local_value(i64 %46, i64 %47)
  call void @set_specpdl_old_value(%union.specbinding* %45, i64 %call69)
  %48 = load i64, i64* %symbol, align 8
  %49 = load i64, i64* %old_value62, align 8
  %50 = load i64, i64* %where, align 8
  call void @set_internal(i64 %48, i64 %49, i64 %50, i1 zeroext true)
  br label %if.end.70

if.end.70:                                        ; preds = %if.then.68, %sw.bb.56
  br label %sw.epilog

sw.epilog:                                        ; preds = %for.body, %if.end.70, %sw.bb.47, %if.then.36, %sw.bb.24, %if.end.21, %if.else.19
  br label %for.inc

for.inc:                                          ; preds = %sw.epilog
  %51 = load i32, i32* %distance.addr, align 4
  %dec = add nsw i32 %51, -1
  store i32 %dec, i32* %distance.addr, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define i64 @Fbacktrace__locals(i64 %nframes, i64 %base) #0 {
entry:
  %nframes.addr = alloca i64, align 8
  %base.addr = alloca i64, align 8
  %frame = alloca %union.specbinding*, align 8
  %prevframe = alloca %union.specbinding*, align 8
  %distance = alloca i64, align 8
  %result = alloca i64, align 8
  %tmp = alloca %union.specbinding*, align 8
  %sym = alloca i64, align 8
  %val = alloca i64, align 8
  %env = alloca i64, align 8
  %binding = alloca i64, align 8
  store i64 %nframes, i64* %nframes.addr, align 8
  store i64 %base, i64* %base.addr, align 8
  %0 = load i64, i64* %nframes.addr, align 8
  %1 = load i64, i64* %base.addr, align 8
  %call = call %union.specbinding* @get_backtrace_frame(i64 %0, i64 %1)
  store %union.specbinding* %call, %union.specbinding** %frame, align 8
  %2 = load i64, i64* %nframes.addr, align 8
  %shr = ashr i64 %2, 2
  %sub = sub nsw i64 %shr, 1
  %shl = shl i64 %sub, 2
  %add = add i64 %shl, 2
  %3 = load i64, i64* %base.addr, align 8
  %call1 = call %union.specbinding* @get_backtrace_frame(i64 %add, i64 %3)
  store %union.specbinding* %call1, %union.specbinding** %prevframe, align 8
  %4 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %5 = load %union.specbinding*, %union.specbinding** %frame, align 8
  %sub.ptr.lhs.cast = ptrtoint %union.specbinding* %4 to i64
  %sub.ptr.rhs.cast = ptrtoint %union.specbinding* %5 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 32
  store i64 %sub.ptr.div, i64* %distance, align 8
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call2, i64* %result, align 8
  %6 = load %union.specbinding*, %union.specbinding** %prevframe, align 8
  %call3 = call zeroext i1 @backtrace_p(%union.specbinding* %6)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call void (i8*, ...) @error(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.21, i32 0, i32 0)) #8
  unreachable

if.end:                                           ; preds = %entry
  %7 = load %union.specbinding*, %union.specbinding** %frame, align 8
  %call4 = call zeroext i1 @backtrace_p(%union.specbinding* %7)
  br i1 %call4, label %if.end.6, label %if.then.5

if.then.5:                                        ; preds = %if.end
  call void (i8*, ...) @error(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.21, i32 0, i32 0)) #8
  unreachable

if.end.6:                                         ; preds = %if.end
  %8 = load i64, i64* %distance, align 8
  %conv = trunc i64 %8 to i32
  call void @backtrace_eval_unrewind(i32 %conv)
  %9 = load %union.specbinding*, %union.specbinding** %prevframe, align 8
  store %union.specbinding* %9, %union.specbinding** %tmp, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc.42, %if.end.6
  %10 = load %union.specbinding*, %union.specbinding** %tmp, align 8
  %11 = load %union.specbinding*, %union.specbinding** %frame, align 8
  %cmp = icmp ugt %union.specbinding* %10, %11
  br i1 %cmp, label %for.body, label %for.end.43

for.body:                                         ; preds = %for.cond
  %12 = load %union.specbinding*, %union.specbinding** %tmp, align 8
  %13 = bitcast %union.specbinding* %12 to i8*
  %bf.load = load i8, i8* %13, align 8
  %bf.cast = zext i8 %bf.load to i32
  switch i32 %bf.cast, label %sw.default [
    i32 5, label %sw.bb
    i32 7, label %sw.bb
    i32 6, label %sw.bb
    i32 0, label %sw.bb.41
    i32 1, label %sw.bb.41
    i32 2, label %sw.bb.41
    i32 3, label %sw.bb.41
    i32 4, label %sw.bb.41
  ]

sw.bb:                                            ; preds = %for.body, %for.body, %for.body
  %14 = load %union.specbinding*, %union.specbinding** %tmp, align 8
  %call9 = call i64 @specpdl_symbol(%union.specbinding* %14)
  store i64 %call9, i64* %sym, align 8
  %15 = load %union.specbinding*, %union.specbinding** %tmp, align 8
  %call11 = call i64 @specpdl_old_value(%union.specbinding* %15)
  store i64 %call11, i64* %val, align 8
  %16 = load i64, i64* %sym, align 8
  %call12 = call i64 @builtin_lisp_symbol(i32 567)
  %cmp13 = icmp eq i64 %16, %call12
  br i1 %cmp13, label %if.then.15, label %if.else

if.then.15:                                       ; preds = %sw.bb
  %17 = load i64, i64* %val, align 8
  store i64 %17, i64* %env, align 8
  br label %for.cond.17

for.cond.17:                                      ; preds = %for.inc, %if.then.15
  %18 = load i64, i64* %env, align 8
  %and = and i64 %18, 7
  %conv18 = trunc i64 %and to i32
  %cmp19 = icmp eq i32 %conv18, 3
  br i1 %cmp19, label %for.body.21, label %for.end

for.body.21:                                      ; preds = %for.cond.17
  %19 = load i64, i64* %env, align 8
  %sub23 = sub nsw i64 %19, 3
  %20 = inttoptr i64 %sub23 to i8*
  %21 = bitcast i8* %20 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %21, i32 0, i32 0
  %22 = load i64, i64* %car, align 8
  store i64 %22, i64* %binding, align 8
  %23 = load i64, i64* %binding, align 8
  %and24 = and i64 %23, 7
  %conv25 = trunc i64 %and24 to i32
  %cmp26 = icmp eq i32 %conv25, 3
  br i1 %cmp26, label %if.then.28, label %if.end.34

if.then.28:                                       ; preds = %for.body.21
  %24 = load i64, i64* %binding, align 8
  %sub29 = sub nsw i64 %24, 3
  %25 = inttoptr i64 %sub29 to i8*
  %26 = bitcast i8* %25 to %struct.Lisp_Cons*
  %car30 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %26, i32 0, i32 0
  %27 = load i64, i64* %car30, align 8
  %28 = load i64, i64* %binding, align 8
  %sub31 = sub nsw i64 %28, 3
  %29 = inttoptr i64 %sub31 to i8*
  %30 = bitcast i8* %29 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %30, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %31 = load i64, i64* %cdr, align 8
  %call32 = call i64 @Fcons(i64 %27, i64 %31)
  %32 = load i64, i64* %result, align 8
  %call33 = call i64 @Fcons(i64 %call32, i64 %32)
  store i64 %call33, i64* %result, align 8
  br label %if.end.34

if.end.34:                                        ; preds = %if.then.28, %for.body.21
  br label %for.inc

for.inc:                                          ; preds = %if.end.34
  %33 = load i64, i64* %env, align 8
  %sub35 = sub nsw i64 %33, 3
  %34 = inttoptr i64 %sub35 to i8*
  %35 = bitcast i8* %34 to %struct.Lisp_Cons*
  %u36 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %35, i32 0, i32 1
  %cdr37 = bitcast %union.anon* %u36 to i64*
  %36 = load i64, i64* %cdr37, align 8
  store i64 %36, i64* %env, align 8
  br label %for.cond.17

for.end:                                          ; preds = %for.cond.17
  br label %if.end.40

if.else:                                          ; preds = %sw.bb
  %37 = load i64, i64* %sym, align 8
  %38 = load i64, i64* %val, align 8
  %call38 = call i64 @Fcons(i64 %37, i64 %38)
  %39 = load i64, i64* %result, align 8
  %call39 = call i64 @Fcons(i64 %call38, i64 %39)
  store i64 %call39, i64* %result, align 8
  br label %if.end.40

if.end.40:                                        ; preds = %if.else, %for.end
  br label %sw.epilog

sw.bb.41:                                         ; preds = %for.body, %for.body, %for.body, %for.body, %for.body
  br label %sw.epilog

sw.default:                                       ; preds = %for.body
  call void @emacs_abort() #8
  unreachable

sw.epilog:                                        ; preds = %sw.bb.41, %if.end.40
  br label %for.inc.42

for.inc.42:                                       ; preds = %sw.epilog
  %40 = load %union.specbinding*, %union.specbinding** %tmp, align 8
  %incdec.ptr = getelementptr inbounds %union.specbinding, %union.specbinding* %40, i32 -1
  store %union.specbinding* %incdec.ptr, %union.specbinding** %tmp, align 8
  br label %for.cond

for.end.43:                                       ; preds = %for.cond
  %41 = load i64, i64* %distance, align 8
  %sub44 = sub nsw i64 0, %41
  %conv45 = trunc i64 %sub44 to i32
  call void @backtrace_eval_unrewind(i32 %conv45)
  %42 = load i64, i64* %result, align 8
  ret i64 %42
}

; Function Attrs: nounwind uwtable
define void @mark_specpdl() #0 {
entry:
  %pdl = alloca %union.specbinding*, align 8
  %nargs = alloca i64, align 8
  %0 = load %union.specbinding*, %union.specbinding** @specpdl, align 8
  store %union.specbinding* %0, %union.specbinding** %pdl, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %2 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %cmp = icmp ne %union.specbinding* %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %4 = bitcast %union.specbinding* %3 to i8*
  %bf.load = load i8, i8* %4, align 8
  %bf.cast = zext i8 %bf.load to i32
  switch i32 %bf.cast, label %sw.default [
    i32 0, label %sw.bb
    i32 4, label %sw.bb.1
    i32 7, label %sw.bb.6
    i32 6, label %sw.bb.6
    i32 5, label %sw.bb.8
    i32 1, label %sw.bb.11
    i32 2, label %sw.bb.11
    i32 3, label %sw.bb.11
  ]

sw.bb:                                            ; preds = %for.body
  %5 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %call = call i64 @specpdl_arg(%union.specbinding* %5)
  call void @mark_object(i64 %call)
  br label %sw.epilog

sw.bb.1:                                          ; preds = %for.body
  %6 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %call2 = call i64 @backtrace_nargs(%union.specbinding* %6)
  store i64 %call2, i64* %nargs, align 8
  %7 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %call3 = call i64 @backtrace_function(%union.specbinding* %7)
  call void @mark_object(i64 %call3)
  %8 = load i64, i64* %nargs, align 8
  %cmp4 = icmp eq i64 %8, -1
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb.1
  store i64 1, i64* %nargs, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %sw.bb.1
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end
  %9 = load i64, i64* %nargs, align 8
  %dec = add nsw i64 %9, -1
  store i64 %dec, i64* %nargs, align 8
  %tobool = icmp ne i64 %9, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %10 = load i64, i64* %nargs, align 8
  %11 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %call5 = call i64* @backtrace_args(%union.specbinding* %11)
  %arrayidx = getelementptr inbounds i64, i64* %call5, i64 %10
  %12 = load i64, i64* %arrayidx, align 8
  call void @mark_object(i64 %12)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  br label %sw.epilog

sw.bb.6:                                          ; preds = %for.body, %for.body
  %13 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %call7 = call i64 @specpdl_where(%union.specbinding* %13)
  call void @mark_object(i64 %call7)
  br label %sw.bb.8

sw.bb.8:                                          ; preds = %for.body, %sw.bb.6
  %14 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %call9 = call i64 @specpdl_symbol(%union.specbinding* %14)
  call void @mark_object(i64 %call9)
  %15 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %call10 = call i64 @specpdl_old_value(%union.specbinding* %15)
  call void @mark_object(i64 %call10)
  br label %sw.epilog

sw.bb.11:                                         ; preds = %for.body, %for.body, %for.body
  br label %sw.epilog

sw.default:                                       ; preds = %for.body
  call void @emacs_abort() #8
  unreachable

sw.epilog:                                        ; preds = %sw.bb.11, %sw.bb.8, %while.end, %sw.bb
  br label %for.inc

for.inc:                                          ; preds = %sw.epilog
  %16 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %incdec.ptr = getelementptr inbounds %union.specbinding, %union.specbinding* %16, i32 1
  store %union.specbinding* %incdec.ptr, %union.specbinding** %pdl, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

declare void @mark_object(i64) #1

; Function Attrs: nounwind uwtable
define internal i64 @specpdl_arg(%union.specbinding* %pdl) #0 {
entry:
  %pdl.addr = alloca %union.specbinding*, align 8
  store %union.specbinding* %pdl, %union.specbinding** %pdl.addr, align 8
  %0 = load %union.specbinding*, %union.specbinding** %pdl.addr, align 8
  %unwind = bitcast %union.specbinding* %0 to %struct.anon*
  %arg = getelementptr inbounds %struct.anon, %struct.anon* %unwind, i32 0, i32 2
  %1 = load i64, i64* %arg, align 8
  ret i64 %1
}

; Function Attrs: nounwind uwtable
define void @get_backtrace(i64 %array) #0 {
entry:
  %array.addr = alloca i64, align 8
  %pdl = alloca %union.specbinding*, align 8
  %i = alloca i64, align 8
  %asize = alloca i64, align 8
  store i64 %array, i64* %array.addr, align 8
  %call = call %union.specbinding* @backtrace_top()
  %call1 = call %union.specbinding* @backtrace_next(%union.specbinding* %call)
  store %union.specbinding* %call1, %union.specbinding** %pdl, align 8
  store i64 0, i64* %i, align 8
  %0 = load i64, i64* %array.addr, align 8
  %call2 = call i64 @ASIZE(i64 %0)
  store i64 %call2, i64* %asize, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i64, i64* %i, align 8
  %2 = load i64, i64* %asize, align 8
  %cmp = icmp slt i64 %1, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %call3 = call zeroext i1 @backtrace_p(%union.specbinding* %3)
  br i1 %call3, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  %4 = load i64, i64* %array.addr, align 8
  %5 = load i64, i64* %i, align 8
  %6 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %call4 = call i64 @backtrace_function(%union.specbinding* %6)
  call void @ASET(i64 %4, i64 %5, i64 %call4)
  %7 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %call5 = call %union.specbinding* @backtrace_next(%union.specbinding* %7)
  store %union.specbinding* %call5, %union.specbinding** %pdl, align 8
  br label %if.end

if.else:                                          ; preds = %for.body
  %8 = load i64, i64* %array.addr, align 8
  %9 = load i64, i64* %i, align 8
  %call6 = call i64 @builtin_lisp_symbol(i32 0)
  call void @ASET(i64 %8, i64 %9, i64 %call6)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %10 = load i64, i64* %i, align 8
  %inc = add nsw i64 %10, 1
  store i64 %inc, i64* %i, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind uwtable
define i64 @backtrace_top_function() #0 {
entry:
  %pdl = alloca %union.specbinding*, align 8
  %call = call %union.specbinding* @backtrace_top()
  store %union.specbinding* %call, %union.specbinding** %pdl, align 8
  %0 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %call1 = call zeroext i1 @backtrace_p(%union.specbinding* %0)
  br i1 %call1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load %union.specbinding*, %union.specbinding** %pdl, align 8
  %call2 = call i64 @backtrace_function(%union.specbinding* %1)
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call2, %cond.true ], [ %call3, %cond.false ]
  ret i64 %cond
}

; Function Attrs: nounwind uwtable
define void @syms_of_eval() #0 {
entry:
  br label %do.body

do.body:                                          ; preds = %entry
  call void @defvar_int(%struct.Lisp_Intfwd* @syms_of_eval.i_fwd, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.22, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 397))
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %do.body.1

do.body.1:                                        ; preds = %do.end
  call void @defvar_int(%struct.Lisp_Intfwd* @syms_of_eval.i_fwd.23, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.24, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 396))
  br label %do.end.2

do.end.2:                                         ; preds = %do.body.1
  br label %do.body.3

do.body.3:                                        ; preds = %do.end.2
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_eval.o_fwd, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.25, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241))
  br label %do.end.4

do.end.4:                                         ; preds = %do.body.3
  %call = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  br label %do.body.5

do.body.5:                                        ; preds = %do.end.4
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_eval.o_fwd.26, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.27, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138))
  br label %do.end.6

do.end.6:                                         ; preds = %do.body.5
  %call7 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call7, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  br label %do.body.8

do.body.8:                                        ; preds = %do.end.6
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_eval.o_fwd.28, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.29, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 133))
  br label %do.end.9

do.end.9:                                         ; preds = %do.body.8
  %call10 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call10, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 133), align 8
  br label %do.body.11

do.body.11:                                       ; preds = %do.end.9
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_eval.o_fwd.30, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.31, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 54))
  br label %do.end.12

do.end.12:                                        ; preds = %do.body.11
  %call13 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call13, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 54), align 8
  br label %do.body.14

do.body.14:                                       ; preds = %do.end.12
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_eval.o_fwd.32, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.33, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 53))
  br label %do.end.15

do.end.15:                                        ; preds = %do.body.14
  %call16 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call16, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 53), align 8
  br label %do.body.17

do.body.17:                                       ; preds = %do.end.15
  call void @defvar_bool(%struct.Lisp_Boolfwd* @syms_of_eval.b_fwd, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.34, i32 0, i32 0), i8* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 433))
  br label %do.end.18

do.end.18:                                        ; preds = %do.body.17
  store i8 0, i8* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 433), align 1
  br label %do.body.19

do.body.19:                                       ; preds = %do.end.18
  call void @defvar_bool(%struct.Lisp_Boolfwd* @syms_of_eval.b_fwd.35, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.36, i32 0, i32 0), i8* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 432))
  br label %do.end.20

do.end.20:                                        ; preds = %do.body.19
  br label %do.body.21

do.body.21:                                       ; preds = %do.end.20
  call void @defvar_bool(%struct.Lisp_Boolfwd* @syms_of_eval.b_fwd.37, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 434))
  br label %do.end.22

do.end.22:                                        ; preds = %do.body.21
  store i8 1, i8* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 434), align 1
  br label %do.body.23

do.body.23:                                       ; preds = %do.end.22
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_eval.o_fwd.38, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.39, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 58))
  br label %do.end.24

do.end.24:                                        ; preds = %do.body.23
  %call25 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call25, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 58), align 8
  br label %do.body.26

do.body.26:                                       ; preds = %do.end.24
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_eval.o_fwd.40, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.41, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 272))
  br label %do.end.27

do.end.27:                                        ; preds = %do.body.26
  %call28 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call28, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 272), align 8
  br label %do.body.29

do.body.29:                                       ; preds = %do.end.27
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_eval.o_fwd.42, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.43, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 57))
  br label %do.end.30

do.end.30:                                        ; preds = %do.body.29
  %call31 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call31, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 57), align 8
  br label %do.body.32

do.body.32:                                       ; preds = %do.end.30
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_eval.o_fwd.44, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.45, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 147))
  br label %do.end.33

do.end.33:                                        ; preds = %do.body.32
  %call34 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call34, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 147), align 8
  %call35 = call i64 @builtin_lisp_symbol(i32 567)
  %call36 = call i64 @builtin_lisp_symbol(i32 0)
  %call37 = call i64 @Funintern(i64 %call35, i64 %call36)
  %call38 = call i64 @intern_c_string(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.46, i32 0, i32 0))
  store i64 %call38, i64* @Vrun_hooks, align 8
  call void @staticpro(i64* @Vrun_hooks)
  call void @staticpro(i64* @Vautoload_queue)
  %call39 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call39, i64* @Vautoload_queue, align 8
  call void @staticpro(i64* @Vsignaling_function)
  %call40 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call40, i64* @Vsignaling_function, align 8
  %call41 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call41, i64* @inhibit_lisp_code, align 8
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sor to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sand to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sif to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Scond to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sprogn to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sprog1 to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sprog2 to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Ssetq to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Squote to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sfunction to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sdefault_toplevel_value to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sset_default_toplevel_value to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sdefvar to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sdefvaralias to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sdefconst to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Smake_var_non_special to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Slet to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @SletX to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Swhile to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Smacroexpand to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Scatch to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sthrow to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sunwind_protect to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Scondition_case to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Ssignal to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Scommandp to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64, i64, i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sautoload to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sautoload_do_load to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Seval to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* }* @Sapply to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* }* @Sfuncall to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* }* @Srun_hooks to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* }* @Srun_hook_with_args to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* }* @Srun_hook_with_args_until_success to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* }* @Srun_hook_with_args_until_failure to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* }* @Srun_hook_wrapped to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sfetch_bytecode to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sbacktrace_debug to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* @Sbacktrace)
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sbacktrace_frame to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sbacktrace_eval to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sbacktrace__locals to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sspecial_variable_p to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sfunctionp to %struct.Lisp_Subr*))
  ret void
}

declare void @defvar_int(%struct.Lisp_Intfwd*, i8*, i64*) #1

declare void @defvar_lisp(%struct.Lisp_Objfwd*, i8*, i64*) #1

declare void @defvar_bool(%struct.Lisp_Boolfwd*, i8*, i8*) #1

declare i64 @Funintern(i64, i64) #1

declare i64 @intern_c_string(i8*) #1

declare void @staticpro(i64*) #1

declare void @defsubr(%struct.Lisp_Subr*) #1

declare void @set_poll_suppress_count(i32) #1

declare void @unblock_input_to(i32) #1

; Function Attrs: noreturn nounwind
declare void @_longjmp(%struct.__jmp_buf_tag*, i32) #7

declare zeroext i1 @input_blocked_p() #1

; Function Attrs: nounwind uwtable
define internal zeroext i1 @wants_debugger(i64 %list, i64 %conditions) #0 {
entry:
  %retval = alloca i1, align 1
  %list.addr = alloca i64, align 8
  %conditions.addr = alloca i64, align 8
  %this = alloca i64, align 8
  %tail = alloca i64, align 8
  store i64 %list, i64* %list.addr, align 8
  store i64 %conditions, i64* %conditions.addr, align 8
  %0 = load i64, i64* %list.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %0, %call
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64, i64* %list.addr, align 8
  %and = and i64 %1, 7
  %conv = trunc i64 %and to i32
  %cmp1 = icmp eq i32 %conv, 3
  br i1 %cmp1, label %if.end.4, label %if.then.3

if.then.3:                                        ; preds = %if.end
  store i1 true, i1* %retval
  br label %return

if.end.4:                                         ; preds = %if.end
  br label %while.cond

while.cond:                                       ; preds = %for.end, %if.end.4
  %2 = load i64, i64* %conditions.addr, align 8
  %and5 = and i64 %2, 7
  %conv6 = trunc i64 %and5 to i32
  %cmp7 = icmp eq i32 %conv6, 3
  br i1 %cmp7, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load i64, i64* %conditions.addr, align 8
  %sub = sub nsw i64 %3, 3
  %4 = inttoptr i64 %sub to i8*
  %5 = bitcast i8* %4 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %5, i32 0, i32 0
  %6 = load i64, i64* %car, align 8
  store i64 %6, i64* %this, align 8
  %7 = load i64, i64* %list.addr, align 8
  store i64 %7, i64* %tail, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %while.body
  %8 = load i64, i64* %tail, align 8
  %and9 = and i64 %8, 7
  %conv10 = trunc i64 %and9 to i32
  %cmp11 = icmp eq i32 %conv10, 3
  br i1 %cmp11, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load i64, i64* %tail, align 8
  %sub13 = sub nsw i64 %9, 3
  %10 = inttoptr i64 %sub13 to i8*
  %11 = bitcast i8* %10 to %struct.Lisp_Cons*
  %car14 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %11, i32 0, i32 0
  %12 = load i64, i64* %car14, align 8
  %13 = load i64, i64* %this, align 8
  %cmp15 = icmp eq i64 %12, %13
  br i1 %cmp15, label %if.then.17, label %if.end.18

if.then.17:                                       ; preds = %for.body
  store i1 true, i1* %retval
  br label %return

if.end.18:                                        ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end.18
  %14 = load i64, i64* %tail, align 8
  %sub19 = sub nsw i64 %14, 3
  %15 = inttoptr i64 %sub19 to i8*
  %16 = bitcast i8* %15 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %16, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %17 = load i64, i64* %cdr, align 8
  store i64 %17, i64* %tail, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %18 = load i64, i64* %conditions.addr, align 8
  %sub20 = sub nsw i64 %18, 3
  %19 = inttoptr i64 %sub20 to i8*
  %20 = bitcast i8* %19 to %struct.Lisp_Cons*
  %u21 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %20, i32 0, i32 1
  %cdr22 = bitcast %union.anon* %u21 to i64*
  %21 = load i64, i64* %cdr22, align 8
  store i64 %21, i64* %conditions.addr, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  store i1 false, i1* %retval
  br label %return

return:                                           ; preds = %while.end, %if.then.17, %if.then.3, %if.then
  %22 = load i1, i1* %retval
  ret i1 %22
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @skip_debugger(i64 %conditions, i64 %data) #0 {
entry:
  %retval = alloca i1, align 1
  %conditions.addr = alloca i64, align 8
  %data.addr = alloca i64, align 8
  %tail = alloca i64, align 8
  %first_string = alloca i8, align 1
  %error_message = alloca i64, align 8
  %contail = alloca i64, align 8
  store i64 %conditions, i64* %conditions.addr, align 8
  store i64 %data, i64* %data.addr, align 8
  store i8 1, i8* %first_string, align 1
  %call = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call, i64* %error_message, align 8
  %0 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 53), align 8
  store i64 %0, i64* %tail, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc.28, %entry
  %1 = load i64, i64* %tail, align 8
  %and = and i64 %1, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %for.body, label %for.end.32

for.body:                                         ; preds = %for.cond
  %2 = load i64, i64* %tail, align 8
  %sub = sub nsw i64 %2, 3
  %3 = inttoptr i64 %sub to i8*
  %4 = bitcast i8* %3 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %4, i32 0, i32 0
  %5 = load i64, i64* %car, align 8
  %call2 = call zeroext i1 @STRINGP(i64 %5)
  br i1 %call2, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  %6 = load i8, i8* %first_string, align 1
  %tobool = trunc i8 %6 to i1
  br i1 %tobool, label %if.then.3, label %if.end

if.then.3:                                        ; preds = %if.then
  %7 = load i64, i64* %data.addr, align 8
  %call4 = call i64 @Ferror_message_string(i64 %7)
  store i64 %call4, i64* %error_message, align 8
  store i8 0, i8* %first_string, align 1
  br label %if.end

if.end:                                           ; preds = %if.then.3, %if.then
  %8 = load i64, i64* %tail, align 8
  %sub5 = sub nsw i64 %8, 3
  %9 = inttoptr i64 %sub5 to i8*
  %10 = bitcast i8* %9 to %struct.Lisp_Cons*
  %car6 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %10, i32 0, i32 0
  %11 = load i64, i64* %car6, align 8
  %12 = load i64, i64* %error_message, align 8
  %call7 = call i64 @fast_string_match(i64 %11, i64 %12)
  %cmp8 = icmp sge i64 %call7, 0
  br i1 %cmp8, label %if.then.10, label %if.end.11

if.then.10:                                       ; preds = %if.end
  store i1 true, i1* %retval
  br label %return

if.end.11:                                        ; preds = %if.end
  br label %if.end.27

if.else:                                          ; preds = %for.body
  %13 = load i64, i64* %conditions.addr, align 8
  store i64 %13, i64* %contail, align 8
  br label %for.cond.12

for.cond.12:                                      ; preds = %for.inc, %if.else
  %14 = load i64, i64* %contail, align 8
  %and13 = and i64 %14, 7
  %conv14 = trunc i64 %and13 to i32
  %cmp15 = icmp eq i32 %conv14, 3
  br i1 %cmp15, label %for.body.17, label %for.end

for.body.17:                                      ; preds = %for.cond.12
  %15 = load i64, i64* %tail, align 8
  %sub18 = sub nsw i64 %15, 3
  %16 = inttoptr i64 %sub18 to i8*
  %17 = bitcast i8* %16 to %struct.Lisp_Cons*
  %car19 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %17, i32 0, i32 0
  %18 = load i64, i64* %car19, align 8
  %19 = load i64, i64* %contail, align 8
  %sub20 = sub nsw i64 %19, 3
  %20 = inttoptr i64 %sub20 to i8*
  %21 = bitcast i8* %20 to %struct.Lisp_Cons*
  %car21 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %21, i32 0, i32 0
  %22 = load i64, i64* %car21, align 8
  %cmp22 = icmp eq i64 %18, %22
  br i1 %cmp22, label %if.then.24, label %if.end.25

if.then.24:                                       ; preds = %for.body.17
  store i1 true, i1* %retval
  br label %return

if.end.25:                                        ; preds = %for.body.17
  br label %for.inc

for.inc:                                          ; preds = %if.end.25
  %23 = load i64, i64* %contail, align 8
  %sub26 = sub nsw i64 %23, 3
  %24 = inttoptr i64 %sub26 to i8*
  %25 = bitcast i8* %24 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %25, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %26 = load i64, i64* %cdr, align 8
  store i64 %26, i64* %contail, align 8
  br label %for.cond.12

for.end:                                          ; preds = %for.cond.12
  br label %if.end.27

if.end.27:                                        ; preds = %for.end, %if.end.11
  br label %for.inc.28

for.inc.28:                                       ; preds = %if.end.27
  %27 = load i64, i64* %tail, align 8
  %sub29 = sub nsw i64 %27, 3
  %28 = inttoptr i64 %sub29 to i8*
  %29 = bitcast i8* %28 to %struct.Lisp_Cons*
  %u30 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %29, i32 0, i32 1
  %cdr31 = bitcast %union.anon* %u30 to i64*
  %30 = load i64, i64* %cdr31, align 8
  store i64 %30, i64* %tail, align 8
  br label %for.cond

for.end.32:                                       ; preds = %for.cond
  store i1 false, i1* %retval
  br label %return

return:                                           ; preds = %for.end.32, %if.then.24, %if.then.10
  %31 = load i1, i1* %retval
  ret i1 %31
}

declare i64 @fast_string_match(i64, i64) #1

declare i8* @xpalloc(i8*, i64*, i64, i64, i64) #1

declare i64 @exec_byte_code(i64, i64, i64, i64, i64, i64*) #1

declare void @CHECK_NATNUM(i64) #1

declare void @set_buffer_if_live(i64) #1

declare void @save_excursion_restore(i64) #1

declare i64 @save_excursion_save() #1

declare i64 @Fbuffer_local_value(i64, i64) #1

attributes #0 = { nounwind uwtable "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { noreturn "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { noreturn nounwind uwtable "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind returns_twice "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { nounwind }
attributes #7 = { noreturn nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #8 = { noreturn }
attributes #9 = { nounwind returns_twice }
attributes #10 = { noreturn nounwind }

!llvm.ident = !{!0}

!0 = !{!"clang version 3.7.0 (tags/RELEASE_370/final)"}
