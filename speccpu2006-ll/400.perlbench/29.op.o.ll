; ModuleID = 'op.c'
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.hv = type { %struct.xpvhv*, i32, i32 }
%struct.xpvhv = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, i32, %struct.he*, %struct.pmop*, i8* }
%struct.magic = type { %struct.magic*, %struct.mgvtbl*, i16, i8, i8, %struct.sv*, i8*, i32 }
%struct.mgvtbl = type { i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*, %struct.sv*, i8*, i32)*, i32 (%struct.magic*, %struct.clone_params*)* }
%struct.clone_params = type { %struct.av*, i64, %struct.interpreter* }
%struct.av = type { %struct.xpvav*, i32, i32 }
%struct.xpvav = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct.sv**, %struct.sv*, i8 }
%struct.interpreter = type { i8 }
%struct.sv = type { i8*, i32, i32 }
%struct.he = type { %struct.he*, %struct.hek*, %struct.sv* }
%struct.hek = type { i32, i32, [1 x i8] }
%struct.pmop = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8, %struct.op*, %struct.op*, %struct.op*, %struct.op*, %struct.pmop*, %struct.regexp*, i32, i32, i8, %struct.hv* }
%struct.op = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8 }
%struct.regexp = type { i32*, i32*, %struct.regnode*, %struct.reg_substr_data*, i8*, %struct.reg_data*, i8*, i32*, i32, i32, i32, i32, i32, i32, i32, i32, [1 x %struct.regnode] }
%struct.regnode = type { i8, i8, i16 }
%struct.reg_substr_data = type opaque
%struct.reg_data = type opaque
%struct.cop = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8, i8*, %struct.hv*, %struct.gv*, i32, i32, i32, %struct.sv*, %struct.sv* }
%struct.gv = type { %struct.xpvgv*, i32, i32 }
%struct.xpvgv = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct.gp*, i8*, i64, %struct.hv*, i8 }
%struct.gp = type { %struct.sv*, i32, %struct.io*, %struct.cv*, %struct.av*, %struct.hv*, %struct.gv*, %struct.cv*, i32, i32, i32, i8* }
%struct.io = type { %struct.xpvio*, i32, i32 }
%struct.xpvio = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct._PerlIO**, %struct._PerlIO**, %union.anon, i64, i64, i64, i64, i8*, %struct.gv*, i8*, %struct.gv*, i8*, %struct.gv*, i16, i8, i8 }
%struct._PerlIO = type opaque
%union.anon = type { %struct.__dirstream* }
%struct.__dirstream = type opaque
%struct.cv = type { %struct.xpvcv*, i32, i32 }
%struct.xpvcv = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct.hv*, %struct.op*, %struct.op*, void (%struct.cv*)*, %union.any, %struct.gv*, i8*, i64, %struct.av*, %struct.cv*, i16, i32 }
%union.any = type { i8* }
%struct.xpv = type { i8*, i64, i64 }
%struct.stackinfo = type { %struct.av*, %struct.context*, i32, i32, i32, %struct.stackinfo*, %struct.stackinfo*, i32 }
%struct.context = type { i32, %union.anon.0 }
%union.anon.0 = type { %struct.block }
%struct.block = type { i32, %struct.cop*, i32, i32, i32, %struct.pmop*, i8, %union.anon.1 }
%union.anon.1 = type { %struct.block_loop }
%struct.block_loop = type { i8*, i32, %struct.op*, %struct.op*, %struct.op*, %struct.sv**, %struct.sv*, %struct.sv*, %struct.av*, i64, i64 }
%struct.unop = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8, %struct.op* }
%struct.svop = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8, %struct.sv* }
%struct.pvop = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8, i8* }
%struct.listop = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8, %struct.op*, %struct.op* }
%struct.binop = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8, %struct.op*, %struct.op* }
%struct.xpvnv = type { i8*, i64, i64, i64, double }
%struct.xpviv = type { i8*, i64, i64, i64 }
%struct.__va_list_tag = type { i32, i32, i8*, i8* }
%struct.xpvmg = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv* }
%struct.logop = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8, %struct.op*, %struct.op* }
%struct.xrv = type { %struct.sv* }
%struct.padop = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8, i64 }
%struct.xpvuv = type { i8*, i64, i64, i64 }
%struct.loop = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8, %struct.op*, %struct.op*, %struct.op*, %struct.op*, %struct.op* }

@PL_in_my = external global i32, align 4
@PL_hints = external global i32, align 4
@.str = private unnamed_addr constant [5 x i8] c"\09\0A\0D\0C\00", align 1
@.str.1 = private unnamed_addr constant [4 x i8] c"...\00", align 1
@.str.2 = private unnamed_addr constant [28 x i8] c"Can't use global %s in \22my\22\00", align 1
@PL_curstash = external global %struct.hv*, align 8
@PL_defstash = external global %struct.hv*, align 8
@PL_in_my_stash = external global %struct.hv*, align 8
@.str.3 = private unnamed_addr constant [46 x i8] c"Can't declare class for non-scalar %s in \22%s\22\00", align 1
@.str.4 = private unnamed_addr constant [4 x i8] c"our\00", align 1
@.str.5 = private unnamed_addr constant [3 x i8] c"my\00", align 1
@PL_check = external global [0 x %struct.op* (%struct.op*)*], align 8
@PL_regfree = external global void (%struct.regexp*)*, align 8
@PL_ppaddr = external global [0 x %struct.op* ()*], align 8
@PL_error_count = external global i32, align 4
@.str.6 = private unnamed_addr constant [21 x i8] c"implicit split to @_\00", align 1
@PL_compiling = external global %struct.cop, align 8
@PL_curcop = external global %struct.cop*, align 8
@PL_dowarn = external global i8, align 1
@.str.7 = private unnamed_addr constant [38 x i8] c"Useless use of sort in scalar context\00", align 1
@PL_opargs = external global [0 x i32], align 4
@PL_op_desc = external global [0 x i8*], align 8
@.str.8 = private unnamed_addr constant [11 x i8] c"a variable\00", align 1
@.str.9 = private unnamed_addr constant [11 x i8] c"a constant\00", align 1
@.str.10 = private unnamed_addr constant [3 x i8] c"di\00", align 1
@.str.11 = private unnamed_addr constant [3 x i8] c"ds\00", align 1
@.str.12 = private unnamed_addr constant [3 x i8] c"ig\00", align 1
@.str.13 = private unnamed_addr constant [34 x i8] c"Useless use of %s in void context\00", align 1
@PL_modcount = external global i32, align 4
@PL_eval_start = external global %struct.op*, align 8
@.str.14 = private unnamed_addr constant [30 x i8] c"That use of $[ is unsupported\00", align 1
@.str.15 = private unnamed_addr constant [58 x i8] c"panic: unexpected lvalue entersub args: type/targ %ld:%lu\00", align 1
@.str.16 = private unnamed_addr constant [62 x i8] c"panic: unexpected lvalue entersub entry via type/targ %ld:%lu\00", align 1
@.str.17 = private unnamed_addr constant [64 x i8] c"Unexpected constant lvalue entersub entry via type/targ %ld:%lu\00", align 1
@.str.18 = private unnamed_addr constant [22 x i8] c"Can't modify %s in %s\00", align 1
@.str.19 = private unnamed_addr constant [9 x i8] c"do block\00", align 1
@.str.20 = private unnamed_addr constant [27 x i8] c"non-lvalue subroutine call\00", align 1
@.str.21 = private unnamed_addr constant [6 x i8] c"local\00", align 1
@.str.22 = private unnamed_addr constant [35 x i8] c"Can't localize lexical variable %s\00", align 1
@PL_comppad_name = external global %struct.av*, align 8
@.str.23 = private unnamed_addr constant [11 x i8] c"attributes\00", align 1
@.str.24 = private unnamed_addr constant [7 x i8] c"@array\00", align 1
@.str.25 = private unnamed_addr constant [6 x i8] c"%hash\00", align 1
@.str.26 = private unnamed_addr constant [41 x i8] c"Applying %s to %s will act on scalar(%s)\00", align 1
@PL_perldb = external global i32, align 4
@PL_tainting = external global i8, align 1
@.str.27 = private unnamed_addr constant [54 x i8] c"internal error: obsolete function save_hints() called\00", align 1
@PL_savestack_ix = external global i32, align 4
@PL_yynerrs = external global i32, align 4
@PL_savestack_max = external global i32, align 4
@PL_hintgv = external global %struct.gv*, align 8
@PL_savestack = external global %union.any*, align 8
@PL_in_eval = external global i32, align 4
@PL_eval_root = external global %struct.op*, align 8
@PL_peepp = external global void (%struct.op*)*, align 8
@PL_compcv = external global %struct.cv*, align 8
@PL_main_root = external global %struct.op*, align 8
@PL_main_start = external global %struct.op*, align 8
@.str.28 = private unnamed_addr constant [14 x i8] c"DB::postponed\00", align 1
@PL_stack_sp = external global %struct.sv**, align 8
@PL_markstack_ptr = external global i32*, align 8
@PL_markstack_max = external global i32*, align 8
@PL_stack_base = external global %struct.sv**, align 8
@PL_stack_max = external global %struct.sv**, align 8
@PL_bufptr = external global i8*, align 8
@PL_oldbufptr = external global i8*, align 8
@.str.29 = private unnamed_addr constant [5 x i8] c", \09\0A\00", align 1
@.str.30 = private unnamed_addr constant [5 x i8] c"@$%*\00", align 1
@.str.31 = private unnamed_addr constant [37 x i8] c"Parentheses missing around \22%s\22 list\00", align 1
@.str.32 = private unnamed_addr constant [2 x i8] c";\00", align 1
@PL_op = external global %struct.op*, align 8
@PL_runops = external global i32 ()*, align 8
@PL_curpad = external global %struct.sv**, align 8
@PL_Sv = external global %struct.sv*, align 8
@PL_tmps_floor = external global i32, align 4
@PL_op_mask = external global i8*, align 8
@.str.33 = private unnamed_addr constant [31 x i8] c"'%s' trapped by operation mask\00", align 1
@.str.34 = private unnamed_addr constant [11 x i8] c"# comment\0A\00", align 1
@.str.35 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.36 = private unnamed_addr constant [18 x i8] c"%04lx\09%04lx\09XXXX\0A\00", align 1
@.str.37 = private unnamed_addr constant [13 x i8] c"%04lx\09\09XXXX\0A\00", align 1
@.str.38 = private unnamed_addr constant [19 x i8] c"%04lx\09%04lx\09%04lx\0A\00", align 1
@.str.39 = private unnamed_addr constant [14 x i8] c"%04lx\09\09%04lx\0A\00", align 1
@.str.40 = private unnamed_addr constant [5 x i8] c"utf8\00", align 1
@.str.41 = private unnamed_addr constant [6 x i8] c"FINAL\00", align 1
@.str.42 = private unnamed_addr constant [4 x i8] c"\5Cs+\00", align 1
@PL_regcompp = external global %struct.regexp* (i8*, i8*, %struct.pmop*)*, align 8
@PL_multi_end = external global i32, align 4
@.str.43 = private unnamed_addr constant [17 x i8] c"&`'123456789+-\0E\12\00", align 1
@PL_curstname = external global %struct.sv*, align 8
@.str.44 = private unnamed_addr constant [28 x i8] c"\22package\22 with no arguments\00", align 1
@.str.45 = private unnamed_addr constant [7 x i8] c"<none>\00", align 1
@PL_copline = external global i32, align 4
@PL_expect = external global i32, align 4
@.str.46 = private unnamed_addr constant [29 x i8] c"Module name must be constant\00", align 1
@.str.47 = private unnamed_addr constant [39 x i8] c"Version number must be constant number\00", align 1
@.str.48 = private unnamed_addr constant [8 x i8] c"VERSION\00", align 1
@.str.49 = private unnamed_addr constant [7 x i8] c"import\00", align 1
@.str.50 = private unnamed_addr constant [9 x i8] c"unimport\00", align 1
@.str.51 = private unnamed_addr constant [6 x i8] c"BEGIN\00", align 1
@PL_cop_seqmax = external global i32, align 4
@.str.52 = private unnamed_addr constant [3 x i8] c"do\00", align 1
@.str.53 = private unnamed_addr constant [17 x i8] c"CORE::GLOBAL::do\00", align 1
@PL_generation = external global i32, align 4
@PL_defgv = external global %struct.gv*, align 8
@PL_debstash = external global %struct.hv*, align 8
@PL_sv_undef = external global %struct.sv, align 8
@PL_Xpv = external global %struct.xpv*, align 8
@.str.54 = private unnamed_addr constant [31 x i8] c"Can't use %s for loop variable\00", align 1
@.str.55 = private unnamed_addr constant [30 x i8] c"Can't undef active subroutine\00", align 1
@PL_comppad = external global %struct.av*, align 8
@.str.56 = private unnamed_addr constant [20 x i8] c"Prototype mismatch:\00", align 1
@.str.57 = private unnamed_addr constant [8 x i8] c" sub %_\00", align 1
@.str.58 = private unnamed_addr constant [6 x i8] c" (%_)\00", align 1
@.str.59 = private unnamed_addr constant [7 x i8] c": none\00", align 1
@.str.60 = private unnamed_addr constant [5 x i8] c" vs \00", align 1
@.str.61 = private unnamed_addr constant [5 x i8] c"(%s)\00", align 1
@.str.62 = private unnamed_addr constant [5 x i8] c"none\00", align 1
@.str.63 = private unnamed_addr constant [3 x i8] c"%_\00", align 1
@.str.64 = private unnamed_addr constant [29 x i8] c"\22my sub\22 not yet implemented\00", align 1
@.str.65 = private unnamed_addr constant [11 x i8] c"%s[%s:%ld]\00", align 1
@.str.66 = private unnamed_addr constant [9 x i8] c"__ANON__\00", align 1
@.str.67 = private unnamed_addr constant [19 x i8] c"__ANON__::__ANON__\00", align 1
@.str.68 = private unnamed_addr constant [18 x i8] c"Runaway prototype\00", align 1
@PL_sub_generation = external global i32, align 4
@PL_curstackinfo = external global %struct.stackinfo*, align 8
@PL_sortcop = external global %struct.op*, align 8
@.str.69 = private unnamed_addr constant [41 x i8] c"Can't redefine active sort subroutine %s\00", align 1
@.str.70 = private unnamed_addr constant [33 x i8] c"Constant subroutine %s redefined\00", align 1
@.str.71 = private unnamed_addr constant [24 x i8] c"Subroutine %s redefined\00", align 1
@.str.72 = private unnamed_addr constant [49 x i8] c"BEGIN not safe after errors--compilation aborted\00", align 1
@PL_errgv = external global %struct.gv*, align 8
@.str.73 = private unnamed_addr constant [11 x i8] c"%s:%ld-%ld\00", align 1
@PL_subline = external global i32, align 4
@PL_DBsub = external global %struct.gv*, align 8
@PL_scopestack_ix = external global i32, align 4
@PL_beginav = external global %struct.av*, align 8
@.str.74 = private unnamed_addr constant [4 x i8] c"END\00", align 1
@PL_endav = external global %struct.av*, align 8
@.str.75 = private unnamed_addr constant [6 x i8] c"CHECK\00", align 1
@PL_checkav = external global %struct.av*, align 8
@.str.76 = private unnamed_addr constant [28 x i8] c"Too late to run CHECK block\00", align 1
@.str.77 = private unnamed_addr constant [5 x i8] c"INIT\00", align 1
@PL_initav = external global %struct.av*, align 8
@.str.78 = private unnamed_addr constant [27 x i8] c"Too late to run INIT block\00", align 1
@.str.79 = private unnamed_addr constant [8 x i8] c"autouse\00", align 1
@.str.80 = private unnamed_addr constant [7 x i8] c"STDOUT\00", align 1
@.str.81 = private unnamed_addr constant [20 x i8] c"Format %s redefined\00", align 1
@.str.82 = private unnamed_addr constant [13 x i8] c"oops: oopsAV\00", align 1
@.str.83 = private unnamed_addr constant [13 x i8] c"oops: oopsHV\00", align 1
@.str.84 = private unnamed_addr constant [44 x i8] c"Using an array as a reference is deprecated\00", align 1
@.str.85 = private unnamed_addr constant [42 x i8] c"Using a hash as a reference is deprecated\00", align 1
@.str.86 = private unnamed_addr constant [17 x i8] c"NOT IMPL LINE %d\00", align 1
@.str.87 = private unnamed_addr constant [51 x i8] c"Possible precedence problem on bitwise %c operator\00", align 1
@.str.88 = private unnamed_addr constant [52 x i8] c"%s argument is not a HASH or ARRAY element or slice\00", align 1
@PL_argvgv = external global %struct.gv*, align 8
@.str.89 = private unnamed_addr constant [37 x i8] c"%s argument is not a subroutine name\00", align 1
@.str.90 = private unnamed_addr constant [43 x i8] c"%s argument is not a HASH or ARRAY element\00", align 1
@.str.91 = private unnamed_addr constant [9 x i8] c"a SCALAR\00", align 1
@.str.92 = private unnamed_addr constant [9 x i8] c"an ARRAY\00", align 1
@.str.93 = private unnamed_addr constant [7 x i8] c"a HASH\00", align 1
@.str.94 = private unnamed_addr constant [7 x i8] c"a CODE\00", align 1
@.str.95 = private unnamed_addr constant [29 x i8] c"Constant is not %s reference\00", align 1
@.str.96 = private unnamed_addr constant [63 x i8] c"Can't use bareword (\22%s\22) as %s ref while \22strict refs\22 in use\00", align 1
@PL_stdingv = external global %struct.gv*, align 8
@.str.97 = private unnamed_addr constant [33 x i8] c"Useless use of %s with no values\00", align 1
@.str.98 = private unnamed_addr constant [48 x i8] c"Array @%s missing the @ in argument %ld of %s()\00", align 1
@.str.99 = private unnamed_addr constant [6 x i8] c"array\00", align 1
@.str.100 = private unnamed_addr constant [49 x i8] c"Hash %%%s missing the %% in argument %ld of %s()\00", align 1
@.str.101 = private unnamed_addr constant [5 x i8] c"hash\00", align 1
@.str.102 = private unnamed_addr constant [7 x i8] c"HANDLE\00", align 1
@.str.103 = private unnamed_addr constant [3 x i8] c"[]\00", align 1
@.str.104 = private unnamed_addr constant [3 x i8] c"{}\00", align 1
@.str.105 = private unnamed_addr constant [10 x i8] c"%s%c...%c\00", align 1
@.str.106 = private unnamed_addr constant [11 x i8] c"__ANONIO__\00", align 1
@.str.107 = private unnamed_addr constant [2 x i8] c"$\00", align 1
@.str.108 = private unnamed_addr constant [5 x i8] c"glob\00", align 1
@.str.109 = private unnamed_addr constant [19 x i8] c"CORE::GLOBAL::glob\00", align 1
@.str.110 = private unnamed_addr constant [11 x i8] c"File::Glob\00", align 1
@.str.111 = private unnamed_addr constant [21 x i8] c"File::Glob::csh_glob\00", align 1
@PL_glob_index = external global i32, align 4
@.str.112 = private unnamed_addr constant [5 x i8] c"main\00", align 1
@.str.113 = private unnamed_addr constant [15 x i8] c"panic: ck_grep\00", align 1
@.str.114 = private unnamed_addr constant [30 x i8] c"defined(@array) is deprecated\00", align 1
@.str.115 = private unnamed_addr constant [46 x i8] c"\09(Maybe you should just omit the defined()?)\0A\00", align 1
@.str.116 = private unnamed_addr constant [30 x i8] c"defined(%%hash) is deprecated\00", align 1
@.str.117 = private unnamed_addr constant [8 x i8] c"open_IN\00", align 1
@.str.118 = private unnamed_addr constant [9 x i8] c"open_OUT\00", align 1
@.str.119 = private unnamed_addr constant [4 x i8] c".pm\00", align 1
@.str.120 = private unnamed_addr constant [8 x i8] c"require\00", align 1
@.str.121 = private unnamed_addr constant [22 x i8] c"CORE::GLOBAL::require\00", align 1
@.str.122 = private unnamed_addr constant [16 x i8] c"panic: ck_split\00", align 1
@.str.123 = private unnamed_addr constant [2 x i8] c" \00", align 1
@.str.124 = private unnamed_addr constant [43 x i8] c"Use of /g modifier is meaningless in split\00", align 1
@.str.125 = private unnamed_addr constant [7 x i8] c"STRING\00", align 1
@.str.126 = private unnamed_addr constant [40 x i8] c"/%s/ should probably be written as \22%s\22\00", align 1
@.str.127 = private unnamed_addr constant [16 x i8] c"block or sub {}\00", align 1
@.str.128 = private unnamed_addr constant [7 x i8] c"sub {}\00", align 1
@.str.129 = private unnamed_addr constant [10 x i8] c"one of %s\00", align 1
@.str.130 = private unnamed_addr constant [7 x i8] c"symbol\00", align 1
@.str.131 = private unnamed_addr constant [17 x i8] c"subroutine entry\00", align 1
@.str.132 = private unnamed_addr constant [7 x i8] c"scalar\00", align 1
@.str.133 = private unnamed_addr constant [31 x i8] c"Malformed prototype for %s: %_\00", align 1
@PL_op_seqmax = external global i16, align 2
@.str.134 = private unnamed_addr constant [41 x i8] c"%_() called too early to check prototype\00", align 1
@.str.135 = private unnamed_addr constant [33 x i8] c"Statement unlikely to be reached\00", align 1
@.str.136 = private unnamed_addr constant [51 x i8] c"\09(Maybe you meant system() when you said exec()?)\0A\00", align 1
@.str.137 = private unnamed_addr constant [7 x i8] c"FIELDS\00", align 1
@.str.138 = private unnamed_addr constant [57 x i8] c"No such pseudo-hash field \22%s\22 in variable %s of type %s\00", align 1
@.str.139 = private unnamed_addr constant [41 x i8] c"Bad index while coercing array into hash\00", align 1
@PL_custom_op_names = external global %struct.hv*, align 8
@PL_op_name = external global [0 x i8*], align 8
@PL_custom_op_descs = external global %struct.hv*, align 8
@.str.140 = private unnamed_addr constant [53 x i8] c"Bareword \22%_\22 not allowed while \22strict subs\22 in use\00", align 1
@.str.141 = private unnamed_addr constant [23 x i8] c"Can't declare %s in %s\00", align 1
@.str.142 = private unnamed_addr constant [25 x i8] c"Can't declare %s in \22%s\22\00", align 1
@PL_sv_no = external global %struct.sv, align 8
@.str.143 = private unnamed_addr constant [39 x i8] c"Assignment to both a list and a scalar\00", align 1
@.str.144 = private unnamed_addr constant [30 x i8] c"Bareword found in conditional\00", align 1
@.str.145 = private unnamed_addr constant [46 x i8] c"Value of %s%s can be \220\22; test with defined()\00", align 1
@.str.146 = private unnamed_addr constant [11 x i8] c" construct\00", align 1
@.str.147 = private unnamed_addr constant [12 x i8] c"() operator\00", align 1
@.str.148 = private unnamed_addr constant [37 x i8] c"Found = in conditional, should be ==\00", align 1
@PL_incgv = external global %struct.gv*, align 8
@.str.149 = private unnamed_addr constant [14 x i8] c"attributes.pm\00", align 1
@.str.150 = private unnamed_addr constant [50 x i8] c"Missing comma after first argument to %s function\00", align 1
@.str.151 = private unnamed_addr constant [26 x i8] c"Too many arguments for %s\00", align 1
@.str.152 = private unnamed_addr constant [41 x i8] c"Type of arg %d to %s must be %s (not %s)\00", align 1
@.str.153 = private unnamed_addr constant [28 x i8] c"Not enough arguments for %s\00", align 1
@.str.154 = private unnamed_addr constant [2 x i8] c"a\00", align 1
@.str.155 = private unnamed_addr constant [2 x i8] c"b\00", align 1

; Function Attrs: nounwind uwtable
define i64 @Perl_allocmy(i8* %name) #0 {
entry:
  %name.addr = alloca i8*, align 8
  %off = alloca i64, align 8
  %p = alloca i8*, align 8
  store i8* %name, i8** %name.addr, align 8
  %0 = load i32, i32* @PL_in_my, align 4
  %cmp = icmp eq i32 %0, 137
  br i1 %cmp, label %if.end.89, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i8*, i8** %name.addr, align 8
  %arrayidx = getelementptr inbounds i8, i8* %1, i64 1
  %2 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %2 to i32
  %cmp1 = icmp sge i32 %conv, 65
  br i1 %cmp1, label %land.lhs.true, label %lor.lhs.false.7

land.lhs.true:                                    ; preds = %lor.lhs.false
  %3 = load i8*, i8** %name.addr, align 8
  %arrayidx3 = getelementptr inbounds i8, i8* %3, i64 1
  %4 = load i8, i8* %arrayidx3, align 1
  %conv4 = sext i8 %4 to i32
  %cmp5 = icmp sle i32 %conv4, 90
  br i1 %cmp5, label %if.end.89, label %lor.lhs.false.7

lor.lhs.false.7:                                  ; preds = %land.lhs.true, %lor.lhs.false
  %5 = load i8*, i8** %name.addr, align 8
  %arrayidx8 = getelementptr inbounds i8, i8* %5, i64 1
  %6 = load i8, i8* %arrayidx8, align 1
  %conv9 = sext i8 %6 to i32
  %cmp10 = icmp sge i32 %conv9, 97
  br i1 %cmp10, label %land.lhs.true.12, label %lor.lhs.false.17

land.lhs.true.12:                                 ; preds = %lor.lhs.false.7
  %7 = load i8*, i8** %name.addr, align 8
  %arrayidx13 = getelementptr inbounds i8, i8* %7, i64 1
  %8 = load i8, i8* %arrayidx13, align 1
  %conv14 = sext i8 %8 to i32
  %cmp15 = icmp sle i32 %conv14, 122
  br i1 %cmp15, label %if.end.89, label %lor.lhs.false.17

lor.lhs.false.17:                                 ; preds = %land.lhs.true.12, %lor.lhs.false.7
  %9 = load i32, i32* @PL_hints, align 4
  %and = and i32 %9, 8388608
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true.18, label %lor.lhs.false.28

land.lhs.true.18:                                 ; preds = %lor.lhs.false.17
  %10 = load i8*, i8** %name.addr, align 8
  %arrayidx19 = getelementptr inbounds i8, i8* %10, i64 1
  %11 = load i8, i8* %arrayidx19, align 1
  %conv20 = zext i8 %11 to i32
  %cmp21 = icmp sge i32 %conv20, 192
  br i1 %cmp21, label %land.lhs.true.23, label %lor.lhs.false.28

land.lhs.true.23:                                 ; preds = %land.lhs.true.18
  %12 = load i8*, i8** %name.addr, align 8
  %arrayidx24 = getelementptr inbounds i8, i8* %12, i64 1
  %13 = load i8, i8* %arrayidx24, align 1
  %conv25 = zext i8 %13 to i32
  %cmp26 = icmp sle i32 %conv25, 253
  br i1 %cmp26, label %if.end.89, label %lor.lhs.false.28

lor.lhs.false.28:                                 ; preds = %land.lhs.true.23, %land.lhs.true.18, %lor.lhs.false.17
  %14 = load i8*, i8** %name.addr, align 8
  %arrayidx29 = getelementptr inbounds i8, i8* %14, i64 1
  %15 = load i8, i8* %arrayidx29, align 1
  %conv30 = sext i8 %15 to i32
  %cmp31 = icmp eq i32 %conv30, 95
  br i1 %cmp31, label %land.lhs.true.33, label %if.then

land.lhs.true.33:                                 ; preds = %lor.lhs.false.28
  %16 = load i8*, i8** %name.addr, align 8
  %call = call i64 @strlen(i8* %16)
  %conv34 = trunc i64 %call to i32
  %cmp35 = icmp sgt i32 %conv34, 2
  br i1 %cmp35, label %if.end.89, label %if.then

if.then:                                          ; preds = %land.lhs.true.33, %lor.lhs.false.28
  %17 = load i8*, i8** %name.addr, align 8
  %arrayidx37 = getelementptr inbounds i8, i8* %17, i64 1
  %18 = load i8, i8* %arrayidx37, align 1
  %conv38 = sext i8 %18 to i32
  %cmp39 = icmp sgt i32 %conv38, 32
  br i1 %cmp39, label %land.lhs.true.41, label %lor.lhs.false.46

land.lhs.true.41:                                 ; preds = %if.then
  %19 = load i8*, i8** %name.addr, align 8
  %arrayidx42 = getelementptr inbounds i8, i8* %19, i64 1
  %20 = load i8, i8* %arrayidx42, align 1
  %conv43 = sext i8 %20 to i32
  %cmp44 = icmp slt i32 %conv43, 127
  br i1 %cmp44, label %lor.lhs.false.51, label %lor.lhs.false.46

lor.lhs.false.46:                                 ; preds = %land.lhs.true.41, %if.then
  %21 = load i8*, i8** %name.addr, align 8
  %arrayidx47 = getelementptr inbounds i8, i8* %21, i64 1
  %22 = load i8, i8* %arrayidx47, align 1
  %conv48 = sext i8 %22 to i32
  %cmp49 = icmp eq i32 %conv48, 32
  br i1 %cmp49, label %lor.lhs.false.51, label %if.then.56

lor.lhs.false.51:                                 ; preds = %lor.lhs.false.46, %land.lhs.true.41
  %23 = load i8*, i8** %name.addr, align 8
  %arrayidx52 = getelementptr inbounds i8, i8* %23, i64 1
  %24 = load i8, i8* %arrayidx52, align 1
  %conv53 = sext i8 %24 to i32
  %call54 = call i8* @strchr(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str, i32 0, i32 0), i32 %conv53)
  %tobool55 = icmp ne i8* %call54, null
  br i1 %tobool55, label %if.then.56, label %if.end.86

if.then.56:                                       ; preds = %lor.lhs.false.51, %lor.lhs.false.46
  %25 = load i8*, i8** %name.addr, align 8
  %call57 = call i8* @strchr(i8* %25, i32 0)
  store i8* %call57, i8** %p, align 8
  %26 = load i8*, i8** %p, align 8
  %27 = load i8*, i8** %name.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %26 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %27 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %cmp58 = icmp sgt i64 %sub.ptr.sub, 200
  br i1 %cmp58, label %if.then.60, label %if.else

if.then.60:                                       ; preds = %if.then.56
  %28 = load i8*, i8** %name.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %28, i64 200
  %call61 = call i8* @strcpy(i8* %add.ptr, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.1, i32 0, i32 0))
  %29 = load i8*, i8** %name.addr, align 8
  %add.ptr62 = getelementptr inbounds i8, i8* %29, i64 199
  store i8* %add.ptr62, i8** %p, align 8
  br label %if.end

if.else:                                          ; preds = %if.then.56
  %30 = load i8*, i8** %p, align 8
  %arrayidx63 = getelementptr inbounds i8, i8* %30, i64 1
  store i8 0, i8* %arrayidx63, align 1
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then.60
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %31 = load i8*, i8** %p, align 8
  %32 = load i8*, i8** %name.addr, align 8
  %sub.ptr.lhs.cast64 = ptrtoint i8* %31 to i64
  %sub.ptr.rhs.cast65 = ptrtoint i8* %32 to i64
  %sub.ptr.sub66 = sub i64 %sub.ptr.lhs.cast64, %sub.ptr.rhs.cast65
  %cmp67 = icmp sgt i64 %sub.ptr.sub66, 2
  br i1 %cmp67, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %33 = load i8*, i8** %p, align 8
  %add.ptr69 = getelementptr inbounds i8, i8* %33, i64 -1
  %34 = load i8, i8* %add.ptr69, align 1
  %35 = load i8*, i8** %p, align 8
  store i8 %34, i8* %35, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %36 = load i8*, i8** %p, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %36, i32 -1
  store i8* %incdec.ptr, i8** %p, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %37 = load i8*, i8** %name.addr, align 8
  %arrayidx70 = getelementptr inbounds i8, i8* %37, i64 1
  %38 = load i8, i8* %arrayidx70, align 1
  %conv71 = sext i8 %38 to i32
  %cmp72 = icmp sge i32 %conv71, 97
  br i1 %cmp72, label %land.lhs.true.74, label %cond.false

land.lhs.true.74:                                 ; preds = %for.end
  %39 = load i8*, i8** %name.addr, align 8
  %arrayidx75 = getelementptr inbounds i8, i8* %39, i64 1
  %40 = load i8, i8* %arrayidx75, align 1
  %conv76 = sext i8 %40 to i32
  %cmp77 = icmp sle i32 %conv76, 122
  br i1 %cmp77, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true.74
  %41 = load i8*, i8** %name.addr, align 8
  %arrayidx79 = getelementptr inbounds i8, i8* %41, i64 1
  %42 = load i8, i8* %arrayidx79, align 1
  %conv80 = sext i8 %42 to i32
  %sub = sub nsw i32 %conv80, 32
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true.74, %for.end
  %43 = load i8*, i8** %name.addr, align 8
  %arrayidx81 = getelementptr inbounds i8, i8* %43, i64 1
  %44 = load i8, i8* %arrayidx81, align 1
  %conv82 = sext i8 %44 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %sub, %cond.true ], [ %conv82, %cond.false ]
  %xor = xor i32 %cond, 64
  %conv83 = trunc i32 %xor to i8
  %45 = load i8*, i8** %name.addr, align 8
  %arrayidx84 = getelementptr inbounds i8, i8* %45, i64 2
  store i8 %conv83, i8* %arrayidx84, align 1
  %46 = load i8*, i8** %name.addr, align 8
  %arrayidx85 = getelementptr inbounds i8, i8* %46, i64 1
  store i8 94, i8* %arrayidx85, align 1
  br label %if.end.86

if.end.86:                                        ; preds = %cond.end, %lor.lhs.false.51
  %47 = load i8*, i8** %name.addr, align 8
  %call87 = call i8* (i8*, ...) @Perl_form(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.2, i32 0, i32 0), i8* %47)
  %call88 = call i32 @Perl_yyerror(i8* %call87)
  br label %if.end.89

if.end.89:                                        ; preds = %if.end.86, %land.lhs.true.33, %land.lhs.true.23, %land.lhs.true.12, %land.lhs.true, %entry
  %48 = load i8*, i8** %name.addr, align 8
  %49 = load i32, i32* @PL_in_my, align 4
  %cmp90 = icmp eq i32 %49, 137
  %conv91 = zext i1 %cmp90 to i32
  %conv92 = trunc i32 %conv91 to i8
  %50 = load %struct.hv*, %struct.hv** @PL_curstash, align 8
  %tobool93 = icmp ne %struct.hv* %50, null
  br i1 %tobool93, label %cond.true.94, label %cond.false.95

cond.true.94:                                     ; preds = %if.end.89
  %51 = load %struct.hv*, %struct.hv** @PL_curstash, align 8
  br label %cond.end.96

cond.false.95:                                    ; preds = %if.end.89
  %52 = load %struct.hv*, %struct.hv** @PL_defstash, align 8
  br label %cond.end.96

cond.end.96:                                      ; preds = %cond.false.95, %cond.true.94
  %cond97 = phi %struct.hv* [ %51, %cond.true.94 ], [ %52, %cond.false.95 ]
  call void @Perl_pad_check_dup(i8* %48, i8 signext %conv92, %struct.hv* %cond97)
  %53 = load %struct.hv*, %struct.hv** @PL_in_my_stash, align 8
  %tobool98 = icmp ne %struct.hv* %53, null
  br i1 %tobool98, label %land.lhs.true.99, label %if.end.109

land.lhs.true.99:                                 ; preds = %cond.end.96
  %54 = load i8*, i8** %name.addr, align 8
  %55 = load i8, i8* %54, align 1
  %conv100 = sext i8 %55 to i32
  %cmp101 = icmp ne i32 %conv100, 36
  br i1 %cmp101, label %if.then.103, label %if.end.109

if.then.103:                                      ; preds = %land.lhs.true.99
  %56 = load i8*, i8** %name.addr, align 8
  %57 = load i32, i32* @PL_in_my, align 4
  %cmp104 = icmp eq i32 %57, 137
  %cond106 = select i1 %cmp104, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.4, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.5, i32 0, i32 0)
  %call107 = call i8* (i8*, ...) @Perl_form(i8* getelementptr inbounds ([46 x i8], [46 x i8]* @.str.3, i32 0, i32 0), i8* %56, i8* %cond106)
  %call108 = call i32 @Perl_yyerror(i8* %call107)
  br label %if.end.109

if.end.109:                                       ; preds = %if.then.103, %land.lhs.true.99, %cond.end.96
  %58 = load i8*, i8** %name.addr, align 8
  %59 = load %struct.hv*, %struct.hv** @PL_in_my_stash, align 8
  %60 = load i32, i32* @PL_in_my, align 4
  %cmp110 = icmp eq i32 %60, 137
  br i1 %cmp110, label %cond.true.112, label %cond.false.118

cond.true.112:                                    ; preds = %if.end.109
  %61 = load %struct.hv*, %struct.hv** @PL_curstash, align 8
  %tobool113 = icmp ne %struct.hv* %61, null
  br i1 %tobool113, label %cond.true.114, label %cond.false.115

cond.true.114:                                    ; preds = %cond.true.112
  %62 = load %struct.hv*, %struct.hv** @PL_curstash, align 8
  br label %cond.end.116

cond.false.115:                                   ; preds = %cond.true.112
  %63 = load %struct.hv*, %struct.hv** @PL_defstash, align 8
  br label %cond.end.116

cond.end.116:                                     ; preds = %cond.false.115, %cond.true.114
  %cond117 = phi %struct.hv* [ %62, %cond.true.114 ], [ %63, %cond.false.115 ]
  br label %cond.end.119

cond.false.118:                                   ; preds = %if.end.109
  br label %cond.end.119

cond.end.119:                                     ; preds = %cond.false.118, %cond.end.116
  %cond120 = phi %struct.hv* [ %cond117, %cond.end.116 ], [ null, %cond.false.118 ]
  %call121 = call i64 @Perl_pad_add_name(i8* %58, %struct.hv* %59, %struct.hv* %cond120, i8 signext 0)
  store i64 %call121, i64* %off, align 8
  %64 = load i64, i64* %off, align 8
  ret i64 %64
}

declare i64 @strlen(i8*) #1

declare i8* @strchr(i8*, i32) #1

declare i8* @strcpy(i8*, i8*) #1

declare i32 @Perl_yyerror(i8*) #1

declare i8* @Perl_form(i8*, ...) #1

declare void @Perl_pad_check_dup(i8*, i8 signext, %struct.hv*) #1

declare i64 @Perl_pad_add_name(i8*, %struct.hv*, %struct.hv*, i8 signext) #1

; Function Attrs: nounwind uwtable
define void @Perl_op_free(%struct.op* %o) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  %kid = alloca %struct.op*, align 8
  %nextkid = alloca %struct.op*, align 8
  %type = alloca i16, align 2
  %refcnt = alloca i64, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %tobool = icmp ne %struct.op* %0, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_seq = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 5
  %2 = load i16, i16* %op_seq, align 2
  %conv = zext i16 %2 to i32
  %cmp = icmp eq i32 %conv, 65535
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %3 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %3, i32 0, i32 7
  %4 = load i8, i8* %op_private, align 1
  %conv2 = zext i8 %4 to i32
  %and = and i32 %conv2, 64
  %tobool3 = icmp ne i32 %and, 0
  br i1 %tobool3, label %if.then.4, label %if.end.9

if.then.4:                                        ; preds = %if.end
  %5 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %5, i32 0, i32 4
  %6 = load i16, i16* %op_type, align 2
  %conv5 = zext i16 %6 to i32
  switch i32 %conv5, label %sw.default [
    i32 167, label %sw.bb
    i32 168, label %sw.bb
    i32 312, label %sw.bb
    i32 178, label %sw.bb
    i32 179, label %sw.bb
    i32 207, label %sw.bb
  ]

sw.bb:                                            ; preds = %if.then.4, %if.then.4, %if.then.4, %if.then.4, %if.then.4, %if.then.4
  %7 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %7, i32 0, i32 3
  %8 = load i64, i64* %op_targ, align 8
  %dec = add i64 %8, -1
  store i64 %dec, i64* %op_targ, align 8
  store i64 %dec, i64* %refcnt, align 8
  %9 = load i64, i64* %refcnt, align 8
  %tobool6 = icmp ne i64 %9, 0
  br i1 %tobool6, label %if.then.7, label %if.end.8

if.then.7:                                        ; preds = %sw.bb
  br label %return

if.end.8:                                         ; preds = %sw.bb
  br label %sw.epilog

sw.default:                                       ; preds = %if.then.4
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.end.8
  br label %if.end.9

if.end.9:                                         ; preds = %sw.epilog, %if.end
  %10 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %10, i32 0, i32 6
  %11 = load i8, i8* %op_flags, align 1
  %conv10 = zext i8 %11 to i32
  %and11 = and i32 %conv10, 4
  %tobool12 = icmp ne i32 %and11, 0
  br i1 %tobool12, label %if.then.13, label %if.end.15

if.then.13:                                       ; preds = %if.end.9
  %12 = load %struct.op*, %struct.op** %o.addr, align 8
  %13 = bitcast %struct.op* %12 to %struct.unop*
  %op_first = getelementptr inbounds %struct.unop, %struct.unop* %13, i32 0, i32 8
  %14 = load %struct.op*, %struct.op** %op_first, align 8
  store %struct.op* %14, %struct.op** %kid, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then.13
  %15 = load %struct.op*, %struct.op** %kid, align 8
  %tobool14 = icmp ne %struct.op* %15, null
  br i1 %tobool14, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %16 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %16, i32 0, i32 1
  %17 = load %struct.op*, %struct.op** %op_sibling, align 8
  store %struct.op* %17, %struct.op** %nextkid, align 8
  %18 = load %struct.op*, %struct.op** %kid, align 8
  call void @Perl_op_free(%struct.op* %18)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %19 = load %struct.op*, %struct.op** %nextkid, align 8
  store %struct.op* %19, %struct.op** %kid, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end.15

if.end.15:                                        ; preds = %for.end, %if.end.9
  %20 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type16 = getelementptr inbounds %struct.op, %struct.op* %20, i32 0, i32 4
  %21 = load i16, i16* %op_type16, align 2
  store i16 %21, i16* %type, align 2
  %22 = load i16, i16* %type, align 2
  %conv17 = zext i16 %22 to i32
  %cmp18 = icmp eq i32 %conv17, 0
  br i1 %cmp18, label %if.then.20, label %if.end.23

if.then.20:                                       ; preds = %if.end.15
  %23 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_targ21 = getelementptr inbounds %struct.op, %struct.op* %23, i32 0, i32 3
  %24 = load i64, i64* %op_targ21, align 8
  %conv22 = trunc i64 %24 to i16
  store i16 %conv22, i16* %type, align 2
  br label %if.end.23

if.end.23:                                        ; preds = %if.then.20, %if.end.15
  %25 = load i16, i16* %type, align 2
  %conv24 = zext i16 %25 to i32
  %cmp25 = icmp eq i32 %conv24, 174
  br i1 %cmp25, label %if.then.35, label %lor.lhs.false.27

lor.lhs.false.27:                                 ; preds = %if.end.23
  %26 = load i16, i16* %type, align 2
  %conv28 = zext i16 %26 to i32
  %cmp29 = icmp eq i32 %conv28, 349
  br i1 %cmp29, label %if.then.35, label %lor.lhs.false.31

lor.lhs.false.31:                                 ; preds = %lor.lhs.false.27
  %27 = load i16, i16* %type, align 2
  %conv32 = zext i16 %27 to i32
  %cmp33 = icmp eq i32 %conv32, 175
  br i1 %cmp33, label %if.then.35, label %if.end.36

if.then.35:                                       ; preds = %lor.lhs.false.31, %lor.lhs.false.27, %if.end.23
  %28 = load %struct.op*, %struct.op** %o.addr, align 8
  %29 = bitcast %struct.op* %28 to %struct.cop*
  call void @S_cop_free(%struct.cop* %29)
  br label %if.end.36

if.end.36:                                        ; preds = %if.then.35, %lor.lhs.false.31
  %30 = load %struct.op*, %struct.op** %o.addr, align 8
  call void @Perl_op_clear(%struct.op* %30)
  %31 = load %struct.op*, %struct.op** %o.addr, align 8
  %32 = bitcast %struct.op* %31 to i8*
  call void @Perl_safesysfree(i8* %32)
  br label %return

return:                                           ; preds = %if.end.36, %if.then.7, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @S_cop_free(%struct.cop* %cop) #0 {
entry:
  %cop.addr = alloca %struct.cop*, align 8
  store %struct.cop* %cop, %struct.cop** %cop.addr, align 8
  %0 = load %struct.cop*, %struct.cop** %cop.addr, align 8
  %cop_label = getelementptr inbounds %struct.cop, %struct.cop* %0, i32 0, i32 8
  %1 = load i8*, i8** %cop_label, align 8
  call void @Perl_safesysfree(i8* %1)
  %2 = load %struct.cop*, %struct.cop** %cop.addr, align 8
  %cop_filegv = getelementptr inbounds %struct.cop, %struct.cop* %2, i32 0, i32 10
  %3 = load %struct.gv*, %struct.gv** %cop_filegv, align 8
  %4 = bitcast %struct.gv* %3 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %4)
  %5 = load %struct.cop*, %struct.cop** %cop.addr, align 8
  %cop_filegv1 = getelementptr inbounds %struct.cop, %struct.cop* %5, i32 0, i32 10
  store %struct.gv* null, %struct.gv** %cop_filegv1, align 8
  %6 = load %struct.cop*, %struct.cop** %cop.addr, align 8
  %cop_warnings = getelementptr inbounds %struct.cop, %struct.cop* %6, i32 0, i32 14
  %7 = load %struct.sv*, %struct.sv** %cop_warnings, align 8
  %cmp = icmp eq %struct.sv* %7, null
  br i1 %cmp, label %if.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %8 = load %struct.cop*, %struct.cop** %cop.addr, align 8
  %cop_warnings2 = getelementptr inbounds %struct.cop, %struct.cop* %8, i32 0, i32 14
  %9 = load %struct.sv*, %struct.sv** %cop_warnings2, align 8
  %cmp3 = icmp eq %struct.sv* %9, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 1)
  br i1 %cmp3, label %if.end, label %lor.lhs.false.4

lor.lhs.false.4:                                  ; preds = %lor.lhs.false
  %10 = load %struct.cop*, %struct.cop** %cop.addr, align 8
  %cop_warnings5 = getelementptr inbounds %struct.cop, %struct.cop* %10, i32 0, i32 14
  %11 = load %struct.sv*, %struct.sv** %cop_warnings5, align 8
  %cmp6 = icmp eq %struct.sv* %11, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 2)
  br i1 %cmp6, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false.4
  %12 = load %struct.cop*, %struct.cop** %cop.addr, align 8
  %cop_warnings7 = getelementptr inbounds %struct.cop, %struct.cop* %12, i32 0, i32 14
  %13 = load %struct.sv*, %struct.sv** %cop_warnings7, align 8
  call void @Perl_sv_free(%struct.sv* %13)
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false.4, %lor.lhs.false, %entry
  %14 = load %struct.cop*, %struct.cop** %cop.addr, align 8
  %cop_io = getelementptr inbounds %struct.cop, %struct.cop* %14, i32 0, i32 15
  %15 = load %struct.sv*, %struct.sv** %cop_io, align 8
  %cmp8 = icmp eq %struct.sv* %15, null
  br i1 %cmp8, label %if.end.11, label %if.then.9

if.then.9:                                        ; preds = %if.end
  %16 = load %struct.cop*, %struct.cop** %cop.addr, align 8
  %cop_io10 = getelementptr inbounds %struct.cop, %struct.cop* %16, i32 0, i32 15
  %17 = load %struct.sv*, %struct.sv** %cop_io10, align 8
  call void @Perl_sv_free(%struct.sv* %17)
  br label %if.end.11

if.end.11:                                        ; preds = %if.then.9, %if.end
  ret void
}

; Function Attrs: nounwind uwtable
define void @Perl_op_clear(%struct.op* %o) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  %pmstash = alloca %struct.hv*, align 8
  %pmop = alloca %struct.pmop*, align 8
  %lastpmop = alloca %struct.pmop*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %0, i32 0, i32 4
  %1 = load i16, i16* %op_type, align 2
  %conv = zext i16 %1 to i32
  switch i32 %conv, label %sw.default [
    i32 0, label %sw.bb
    i32 311, label %sw.bb
    i32 6, label %sw.bb.4
    i32 7, label %sw.bb.4
    i32 126, label %sw.bb.4
    i32 350, label %sw.bb.16
    i32 5, label %sw.bb.16
    i32 189, label %sw.bb.19
    i32 186, label %sw.bb.19
    i32 185, label %sw.bb.19
    i32 187, label %sw.bb.19
    i32 35, label %sw.bb.26
    i32 33, label %sw.bb.35
    i32 13, label %sw.bb.36
    i32 31, label %sw.bb.38
    i32 32, label %sw.bb.38
  ]

sw.bb:                                            ; preds = %entry, %entry
  %2 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %2, i32 0, i32 3
  store i64 0, i64* %op_targ, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %3 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %3, i32 0, i32 6
  %4 = load i8, i8* %op_flags, align 1
  %conv1 = zext i8 %4 to i32
  %and = and i32 %conv1, 16
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %sw.default
  %5 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type2 = getelementptr inbounds %struct.op, %struct.op* %5, i32 0, i32 4
  %6 = load i16, i16* %op_type2, align 2
  %idxprom = zext i16 %6 to i64
  %arrayidx = getelementptr inbounds [0 x %struct.op* (%struct.op*)*], [0 x %struct.op* (%struct.op*)*]* @PL_check, i32 0, i64 %idxprom
  %7 = load %struct.op* (%struct.op*)*, %struct.op* (%struct.op*)** %arrayidx, align 8
  %cmp = icmp ne %struct.op* (%struct.op*)* %7, @Perl_ck_ftst
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %sw.default
  br label %sw.epilog

if.end:                                           ; preds = %lor.lhs.false
  br label %sw.bb.4

sw.bb.4:                                          ; preds = %entry, %entry, %entry, %if.end
  %8 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type5 = getelementptr inbounds %struct.op, %struct.op* %8, i32 0, i32 4
  %9 = load i16, i16* %op_type5, align 2
  %conv6 = zext i16 %9 to i32
  %cmp7 = icmp eq i32 %conv6, 126
  br i1 %cmp7, label %land.lhs.true, label %if.then.13

land.lhs.true:                                    ; preds = %sw.bb.4
  %10 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags9 = getelementptr inbounds %struct.op, %struct.op* %10, i32 0, i32 6
  %11 = load i8, i8* %op_flags9, align 1
  %conv10 = zext i8 %11 to i32
  %and11 = and i32 %conv10, 128
  %tobool12 = icmp ne i32 %and11, 0
  br i1 %tobool12, label %if.end.15, label %if.then.13

if.then.13:                                       ; preds = %land.lhs.true, %sw.bb.4
  %12 = load %struct.op*, %struct.op** %o.addr, align 8
  %13 = bitcast %struct.op* %12 to %struct.svop*
  %op_sv = getelementptr inbounds %struct.svop, %struct.svop* %13, i32 0, i32 8
  %14 = load %struct.sv*, %struct.sv** %op_sv, align 8
  call void @Perl_sv_free(%struct.sv* %14)
  %15 = load %struct.op*, %struct.op** %o.addr, align 8
  %16 = bitcast %struct.op* %15 to %struct.svop*
  %op_sv14 = getelementptr inbounds %struct.svop, %struct.svop* %16, i32 0, i32 8
  store %struct.sv* null, %struct.sv** %op_sv14, align 8
  br label %if.end.15

if.end.15:                                        ; preds = %if.then.13, %land.lhs.true
  br label %sw.epilog

sw.bb.16:                                         ; preds = %entry, %entry
  %17 = load %struct.op*, %struct.op** %o.addr, align 8
  %18 = bitcast %struct.op* %17 to %struct.svop*
  %op_sv17 = getelementptr inbounds %struct.svop, %struct.svop* %18, i32 0, i32 8
  %19 = load %struct.sv*, %struct.sv** %op_sv17, align 8
  call void @Perl_sv_free(%struct.sv* %19)
  %20 = load %struct.op*, %struct.op** %o.addr, align 8
  %21 = bitcast %struct.op* %20 to %struct.svop*
  %op_sv18 = getelementptr inbounds %struct.svop, %struct.svop* %21, i32 0, i32 8
  store %struct.sv* null, %struct.sv** %op_sv18, align 8
  br label %sw.epilog

sw.bb.19:                                         ; preds = %entry, %entry, %entry, %entry
  %22 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags20 = getelementptr inbounds %struct.op, %struct.op* %22, i32 0, i32 6
  %23 = load i8, i8* %op_flags20, align 1
  %conv21 = zext i8 %23 to i32
  %and22 = and i32 %conv21, 196
  %tobool23 = icmp ne i32 %and22, 0
  br i1 %tobool23, label %if.then.24, label %if.end.25

if.then.24:                                       ; preds = %sw.bb.19
  br label %sw.epilog

if.end.25:                                        ; preds = %sw.bb.19
  br label %sw.bb.26

sw.bb.26:                                         ; preds = %entry, %if.end.25
  %24 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %24, i32 0, i32 7
  %25 = load i8, i8* %op_private, align 1
  %conv27 = zext i8 %25 to i32
  %and28 = and i32 %conv27, 3
  %tobool29 = icmp ne i32 %and28, 0
  br i1 %tobool29, label %if.then.30, label %if.else

if.then.30:                                       ; preds = %sw.bb.26
  %26 = load %struct.op*, %struct.op** %o.addr, align 8
  %27 = bitcast %struct.op* %26 to %struct.svop*
  %op_sv31 = getelementptr inbounds %struct.svop, %struct.svop* %27, i32 0, i32 8
  %28 = load %struct.sv*, %struct.sv** %op_sv31, align 8
  call void @Perl_sv_free(%struct.sv* %28)
  %29 = load %struct.op*, %struct.op** %o.addr, align 8
  %30 = bitcast %struct.op* %29 to %struct.svop*
  %op_sv32 = getelementptr inbounds %struct.svop, %struct.svop* %30, i32 0, i32 8
  store %struct.sv* null, %struct.sv** %op_sv32, align 8
  br label %if.end.34

if.else:                                          ; preds = %sw.bb.26
  %31 = load %struct.op*, %struct.op** %o.addr, align 8
  %32 = bitcast %struct.op* %31 to %struct.pvop*
  %op_pv = getelementptr inbounds %struct.pvop, %struct.pvop* %32, i32 0, i32 8
  %33 = load i8*, i8** %op_pv, align 8
  call void @Perl_safesysfree(i8* %33)
  %34 = load %struct.op*, %struct.op** %o.addr, align 8
  %35 = bitcast %struct.op* %34 to %struct.pvop*
  %op_pv33 = getelementptr inbounds %struct.pvop, %struct.pvop* %35, i32 0, i32 8
  store i8* null, i8** %op_pv33, align 8
  br label %if.end.34

if.end.34:                                        ; preds = %if.else, %if.then.30
  br label %sw.epilog

sw.bb.35:                                         ; preds = %entry
  %36 = load %struct.op*, %struct.op** %o.addr, align 8
  %37 = bitcast %struct.op* %36 to %struct.pmop*
  %op_pmreplroot = getelementptr inbounds %struct.pmop, %struct.pmop* %37, i32 0, i32 10
  %38 = load %struct.op*, %struct.op** %op_pmreplroot, align 8
  call void @Perl_op_free(%struct.op* %38)
  br label %clear_pmop

sw.bb.36:                                         ; preds = %entry
  %39 = load %struct.op*, %struct.op** %o.addr, align 8
  %40 = bitcast %struct.op* %39 to %struct.pmop*
  %op_pmreplroot37 = getelementptr inbounds %struct.pmop, %struct.pmop* %40, i32 0, i32 10
  %41 = load %struct.op*, %struct.op** %op_pmreplroot37, align 8
  %42 = bitcast %struct.op* %41 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %42)
  br label %sw.bb.38

sw.bb.38:                                         ; preds = %entry, %entry, %sw.bb.36
  br label %clear_pmop

clear_pmop:                                       ; preds = %sw.bb.38, %sw.bb.35
  %43 = load %struct.op*, %struct.op** %o.addr, align 8
  %44 = bitcast %struct.op* %43 to %struct.pmop*
  %op_pmstash = getelementptr inbounds %struct.pmop, %struct.pmop* %44, i32 0, i32 17
  %45 = load %struct.hv*, %struct.hv** %op_pmstash, align 8
  store %struct.hv* %45, %struct.hv** %pmstash, align 8
  %46 = load %struct.hv*, %struct.hv** %pmstash, align 8
  %tobool39 = icmp ne %struct.hv* %46, null
  br i1 %tobool39, label %land.lhs.true.40, label %if.end.57

land.lhs.true.40:                                 ; preds = %clear_pmop
  %47 = load %struct.hv*, %struct.hv** %pmstash, align 8
  %sv_refcnt = getelementptr inbounds %struct.hv, %struct.hv* %47, i32 0, i32 1
  %48 = load i32, i32* %sv_refcnt, align 4
  %tobool41 = icmp ne i32 %48, 0
  br i1 %tobool41, label %if.then.42, label %if.end.57

if.then.42:                                       ; preds = %land.lhs.true.40
  %49 = load %struct.hv*, %struct.hv** %pmstash, align 8
  %sv_any = getelementptr inbounds %struct.hv, %struct.hv* %49, i32 0, i32 0
  %50 = load %struct.xpvhv*, %struct.xpvhv** %sv_any, align 8
  %xhv_pmroot = getelementptr inbounds %struct.xpvhv, %struct.xpvhv* %50, i32 0, i32 9
  %51 = load %struct.pmop*, %struct.pmop** %xhv_pmroot, align 8
  store %struct.pmop* %51, %struct.pmop** %pmop, align 8
  store %struct.pmop* null, %struct.pmop** %lastpmop, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end.55, %if.then.42
  %52 = load %struct.pmop*, %struct.pmop** %pmop, align 8
  %tobool43 = icmp ne %struct.pmop* %52, null
  br i1 %tobool43, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %53 = load %struct.op*, %struct.op** %o.addr, align 8
  %54 = bitcast %struct.op* %53 to %struct.pmop*
  %55 = load %struct.pmop*, %struct.pmop** %pmop, align 8
  %cmp44 = icmp eq %struct.pmop* %54, %55
  br i1 %cmp44, label %if.then.46, label %if.end.55

if.then.46:                                       ; preds = %while.body
  %56 = load %struct.pmop*, %struct.pmop** %lastpmop, align 8
  %tobool47 = icmp ne %struct.pmop* %56, null
  br i1 %tobool47, label %if.then.48, label %if.else.50

if.then.48:                                       ; preds = %if.then.46
  %57 = load %struct.pmop*, %struct.pmop** %pmop, align 8
  %op_pmnext = getelementptr inbounds %struct.pmop, %struct.pmop* %57, i32 0, i32 12
  %58 = load %struct.pmop*, %struct.pmop** %op_pmnext, align 8
  %59 = load %struct.pmop*, %struct.pmop** %lastpmop, align 8
  %op_pmnext49 = getelementptr inbounds %struct.pmop, %struct.pmop* %59, i32 0, i32 12
  store %struct.pmop* %58, %struct.pmop** %op_pmnext49, align 8
  br label %if.end.54

if.else.50:                                       ; preds = %if.then.46
  %60 = load %struct.pmop*, %struct.pmop** %pmop, align 8
  %op_pmnext51 = getelementptr inbounds %struct.pmop, %struct.pmop* %60, i32 0, i32 12
  %61 = load %struct.pmop*, %struct.pmop** %op_pmnext51, align 8
  %62 = load %struct.hv*, %struct.hv** %pmstash, align 8
  %sv_any52 = getelementptr inbounds %struct.hv, %struct.hv* %62, i32 0, i32 0
  %63 = load %struct.xpvhv*, %struct.xpvhv** %sv_any52, align 8
  %xhv_pmroot53 = getelementptr inbounds %struct.xpvhv, %struct.xpvhv* %63, i32 0, i32 9
  store %struct.pmop* %61, %struct.pmop** %xhv_pmroot53, align 8
  br label %if.end.54

if.end.54:                                        ; preds = %if.else.50, %if.then.48
  br label %while.end

if.end.55:                                        ; preds = %while.body
  %64 = load %struct.pmop*, %struct.pmop** %pmop, align 8
  store %struct.pmop* %64, %struct.pmop** %lastpmop, align 8
  %65 = load %struct.pmop*, %struct.pmop** %pmop, align 8
  %op_pmnext56 = getelementptr inbounds %struct.pmop, %struct.pmop* %65, i32 0, i32 12
  %66 = load %struct.pmop*, %struct.pmop** %op_pmnext56, align 8
  store %struct.pmop* %66, %struct.pmop** %pmop, align 8
  br label %while.cond

while.end:                                        ; preds = %if.end.54, %while.cond
  br label %if.end.57

if.end.57:                                        ; preds = %while.end, %land.lhs.true.40, %clear_pmop
  %67 = load %struct.op*, %struct.op** %o.addr, align 8
  %68 = bitcast %struct.op* %67 to %struct.pmop*
  %op_pmreplroot58 = getelementptr inbounds %struct.pmop, %struct.pmop* %68, i32 0, i32 10
  store %struct.op* null, %struct.op** %op_pmreplroot58, align 8
  %69 = load void (%struct.regexp*)*, void (%struct.regexp*)** @PL_regfree, align 8
  %70 = load %struct.op*, %struct.op** %o.addr, align 8
  %71 = bitcast %struct.op* %70 to %struct.pmop*
  %op_pmregexp = getelementptr inbounds %struct.pmop, %struct.pmop* %71, i32 0, i32 13
  %72 = load %struct.regexp*, %struct.regexp** %op_pmregexp, align 8
  call void %69(%struct.regexp* %72)
  %73 = load %struct.op*, %struct.op** %o.addr, align 8
  %74 = bitcast %struct.op* %73 to %struct.pmop*
  %op_pmregexp59 = getelementptr inbounds %struct.pmop, %struct.pmop* %74, i32 0, i32 13
  store %struct.regexp* null, %struct.regexp** %op_pmregexp59, align 8
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end.57, %if.end.34, %if.then.24, %sw.bb.16, %if.end.15, %if.then, %sw.bb
  %75 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_targ60 = getelementptr inbounds %struct.op, %struct.op* %75, i32 0, i32 3
  %76 = load i64, i64* %op_targ60, align 8
  %cmp61 = icmp ugt i64 %76, 0
  br i1 %cmp61, label %if.then.63, label %if.end.66

if.then.63:                                       ; preds = %sw.epilog
  %77 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_targ64 = getelementptr inbounds %struct.op, %struct.op* %77, i32 0, i32 3
  %78 = load i64, i64* %op_targ64, align 8
  call void @Perl_pad_free(i64 %78)
  %79 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_targ65 = getelementptr inbounds %struct.op, %struct.op* %79, i32 0, i32 3
  store i64 0, i64* %op_targ65, align 8
  br label %if.end.66

if.end.66:                                        ; preds = %if.then.63, %sw.epilog
  ret void
}

declare void @Perl_safesysfree(i8*) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_ftst(%struct.op* %o) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  %type = alloca i32, align 4
  %kid = alloca %struct.svop*, align 8
  %n_a = alloca i64, align 8
  %newop = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %0, i32 0, i32 4
  %1 = load i16, i16* %op_type, align 2
  %conv = zext i16 %1 to i32
  store i32 %conv, i32* %type, align 4
  %2 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %2, i32 0, i32 6
  %3 = load i8, i8* %op_flags, align 1
  %conv1 = zext i8 %3 to i32
  %and = and i32 %conv1, 16
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end.73

if.else:                                          ; preds = %entry
  %4 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags2 = getelementptr inbounds %struct.op, %struct.op* %4, i32 0, i32 6
  %5 = load i8, i8* %op_flags2, align 1
  %conv3 = zext i8 %5 to i32
  %and4 = and i32 %conv3, 4
  %tobool5 = icmp ne i32 %and4, 0
  br i1 %tobool5, label %land.lhs.true, label %if.else.63

land.lhs.true:                                    ; preds = %if.else
  %6 = load %struct.op*, %struct.op** %o.addr, align 8
  %7 = bitcast %struct.op* %6 to %struct.unop*
  %op_first = getelementptr inbounds %struct.unop, %struct.unop* %7, i32 0, i32 8
  %8 = load %struct.op*, %struct.op** %op_first, align 8
  %op_type6 = getelementptr inbounds %struct.op, %struct.op* %8, i32 0, i32 4
  %9 = load i16, i16* %op_type6, align 2
  %conv7 = zext i16 %9 to i32
  %cmp = icmp ne i32 %conv7, 1
  br i1 %cmp, label %if.then.9, label %if.else.63

if.then.9:                                        ; preds = %land.lhs.true
  %10 = load %struct.op*, %struct.op** %o.addr, align 8
  %11 = bitcast %struct.op* %10 to %struct.unop*
  %op_first10 = getelementptr inbounds %struct.unop, %struct.unop* %11, i32 0, i32 8
  %12 = load %struct.op*, %struct.op** %op_first10, align 8
  %13 = bitcast %struct.op* %12 to %struct.svop*
  store %struct.svop* %13, %struct.svop** %kid, align 8
  %14 = load %struct.svop*, %struct.svop** %kid, align 8
  %op_type11 = getelementptr inbounds %struct.svop, %struct.svop* %14, i32 0, i32 4
  %15 = load i16, i16* %op_type11, align 2
  %conv12 = zext i16 %15 to i32
  %cmp13 = icmp eq i32 %conv12, 5
  br i1 %cmp13, label %land.lhs.true.15, label %if.else.26

land.lhs.true.15:                                 ; preds = %if.then.9
  %16 = load %struct.svop*, %struct.svop** %kid, align 8
  %op_private = getelementptr inbounds %struct.svop, %struct.svop* %16, i32 0, i32 7
  %17 = load i8, i8* %op_private, align 1
  %conv16 = zext i8 %17 to i32
  %and17 = and i32 %conv16, 64
  %tobool18 = icmp ne i32 %and17, 0
  br i1 %tobool18, label %if.then.19, label %if.else.26

if.then.19:                                       ; preds = %land.lhs.true.15
  %18 = load i32, i32* %type, align 4
  %19 = load %struct.svop*, %struct.svop** %kid, align 8
  %op_sv = getelementptr inbounds %struct.svop, %struct.svop* %19, i32 0, i32 8
  %20 = load %struct.sv*, %struct.sv** %op_sv, align 8
  store %struct.sv* %20, %struct.sv** @PL_Sv, align 8
  %21 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %21, i32 0, i32 2
  %22 = load i32, i32* %sv_flags, align 4
  %and20 = and i32 %22, 262144
  %cmp21 = icmp eq i32 %and20, 262144
  br i1 %cmp21, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.19
  %23 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %23, i32 0, i32 0
  %24 = load i8*, i8** %sv_any, align 8
  %25 = bitcast i8* %24 to %struct.xpv*
  %xpv_cur = getelementptr inbounds %struct.xpv, %struct.xpv* %25, i32 0, i32 1
  %26 = load i64, i64* %xpv_cur, align 8
  store i64 %26, i64* %n_a, align 8
  %27 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any23 = getelementptr inbounds %struct.sv, %struct.sv* %27, i32 0, i32 0
  %28 = load i8*, i8** %sv_any23, align 8
  %29 = bitcast i8* %28 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %29, i32 0, i32 0
  %30 = load i8*, i8** %xpv_pv, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then.19
  %31 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call = call i8* @Perl_sv_2pv_flags(%struct.sv* %31, i64* %n_a, i32 2)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %30, %cond.true ], [ %call, %cond.false ]
  %call24 = call %struct.gv* @Perl_gv_fetchpv(i8* %cond, i32 1, i32 15)
  %call25 = call %struct.op* @Perl_newGVOP(i32 %18, i32 16, %struct.gv* %call24)
  store %struct.op* %call25, %struct.op** %newop, align 8
  %32 = load %struct.op*, %struct.op** %o.addr, align 8
  call void @Perl_op_free(%struct.op* %32)
  %33 = load %struct.op*, %struct.op** %newop, align 8
  store %struct.op* %33, %struct.op** %o.addr, align 8
  br label %if.end.62

if.else.26:                                       ; preds = %land.lhs.true.15, %if.then.9
  %34 = load i32, i32* @PL_hints, align 4
  %and27 = and i32 %34, 4194304
  %tobool28 = icmp ne i32 %and27, 0
  br i1 %tobool28, label %land.lhs.true.29, label %if.end

land.lhs.true.29:                                 ; preds = %if.else.26
  %35 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type30 = getelementptr inbounds %struct.op, %struct.op* %35, i32 0, i32 4
  %36 = load i16, i16* %op_type30, align 2
  %conv31 = zext i16 %36 to i32
  %cmp32 = icmp eq i32 %conv31, 236
  br i1 %cmp32, label %if.then.58, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true.29
  %37 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type34 = getelementptr inbounds %struct.op, %struct.op* %37, i32 0, i32 4
  %38 = load i16, i16* %op_type34, align 2
  %conv35 = zext i16 %38 to i32
  %cmp36 = icmp eq i32 %conv35, 237
  br i1 %cmp36, label %if.then.58, label %lor.lhs.false.38

lor.lhs.false.38:                                 ; preds = %lor.lhs.false
  %39 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type39 = getelementptr inbounds %struct.op, %struct.op* %39, i32 0, i32 4
  %40 = load i16, i16* %op_type39, align 2
  %conv40 = zext i16 %40 to i32
  %cmp41 = icmp eq i32 %conv40, 238
  br i1 %cmp41, label %if.then.58, label %lor.lhs.false.43

lor.lhs.false.43:                                 ; preds = %lor.lhs.false.38
  %41 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type44 = getelementptr inbounds %struct.op, %struct.op* %41, i32 0, i32 4
  %42 = load i16, i16* %op_type44, align 2
  %conv45 = zext i16 %42 to i32
  %cmp46 = icmp eq i32 %conv45, 239
  br i1 %cmp46, label %if.then.58, label %lor.lhs.false.48

lor.lhs.false.48:                                 ; preds = %lor.lhs.false.43
  %43 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type49 = getelementptr inbounds %struct.op, %struct.op* %43, i32 0, i32 4
  %44 = load i16, i16* %op_type49, align 2
  %conv50 = zext i16 %44 to i32
  %cmp51 = icmp eq i32 %conv50, 240
  br i1 %cmp51, label %if.then.58, label %lor.lhs.false.53

lor.lhs.false.53:                                 ; preds = %lor.lhs.false.48
  %45 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type54 = getelementptr inbounds %struct.op, %struct.op* %45, i32 0, i32 4
  %46 = load i16, i16* %op_type54, align 2
  %conv55 = zext i16 %46 to i32
  %cmp56 = icmp eq i32 %conv55, 241
  br i1 %cmp56, label %if.then.58, label %if.end

if.then.58:                                       ; preds = %lor.lhs.false.53, %lor.lhs.false.48, %lor.lhs.false.43, %lor.lhs.false.38, %lor.lhs.false, %land.lhs.true.29
  %47 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private59 = getelementptr inbounds %struct.op, %struct.op* %47, i32 0, i32 7
  %48 = load i8, i8* %op_private59, align 1
  %conv60 = zext i8 %48 to i32
  %or = or i32 %conv60, 2
  %conv61 = trunc i32 %or to i8
  store i8 %conv61, i8* %op_private59, align 1
  br label %if.end

if.end:                                           ; preds = %if.then.58, %lor.lhs.false.53, %if.else.26
  br label %if.end.62

if.end.62:                                        ; preds = %if.end, %cond.end
  br label %if.end.72

if.else.63:                                       ; preds = %land.lhs.true, %if.else
  %49 = load %struct.op*, %struct.op** %o.addr, align 8
  call void @Perl_op_free(%struct.op* %49)
  %50 = load i32, i32* %type, align 4
  %cmp64 = icmp eq i32 %50, 260
  br i1 %cmp64, label %if.then.66, label %if.else.68

if.then.66:                                       ; preds = %if.else.63
  %51 = load i32, i32* %type, align 4
  %52 = load %struct.gv*, %struct.gv** @PL_stdingv, align 8
  %call67 = call %struct.op* @Perl_newGVOP(i32 %51, i32 16, %struct.gv* %52)
  store %struct.op* %call67, %struct.op** %o.addr, align 8
  br label %if.end.71

if.else.68:                                       ; preds = %if.else.63
  %53 = load i32, i32* %type, align 4
  %call69 = call %struct.op* @S_newDEFSVOP()
  %call70 = call %struct.op* @Perl_newUNOP(i32 %53, i32 0, %struct.op* %call69)
  store %struct.op* %call70, %struct.op** %o.addr, align 8
  br label %if.end.71

if.end.71:                                        ; preds = %if.else.68, %if.then.66
  br label %if.end.72

if.end.72:                                        ; preds = %if.end.71, %if.end.62
  br label %if.end.73

if.end.73:                                        ; preds = %if.end.72, %if.then
  %54 = load %struct.op*, %struct.op** %o.addr, align 8
  ret %struct.op* %54
}

declare void @Perl_sv_free(%struct.sv*) #1

declare void @Perl_pad_free(i64) #1

; Function Attrs: nounwind uwtable
define void @Perl_op_null(%struct.op* %o) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %0, i32 0, i32 4
  %1 = load i16, i16* %op_type, align 2
  %conv = zext i16 %1 to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.op*, %struct.op** %o.addr, align 8
  call void @Perl_op_clear(%struct.op* %2)
  %3 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type2 = getelementptr inbounds %struct.op, %struct.op* %3, i32 0, i32 4
  %4 = load i16, i16* %op_type2, align 2
  %conv3 = zext i16 %4 to i64
  %5 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %5, i32 0, i32 3
  store i64 %conv3, i64* %op_targ, align 8
  %6 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type4 = getelementptr inbounds %struct.op, %struct.op* %6, i32 0, i32 4
  store i16 0, i16* %op_type4, align 2
  %7 = load %struct.op* ()*, %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 0), align 8
  %8 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_ppaddr = getelementptr inbounds %struct.op, %struct.op* %8, i32 0, i32 2
  store %struct.op* ()* %7, %struct.op* ()** %op_ppaddr, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define void @Perl_op_refcnt_lock() #0 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define void @Perl_op_refcnt_unlock() #0 {
entry:
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_linklist(%struct.op* %o) #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %o.addr = alloca %struct.op*, align 8
  %kid = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %0, i32 0, i32 0
  %1 = load %struct.op*, %struct.op** %op_next, align 8
  %tobool = icmp ne %struct.op* %1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next1 = getelementptr inbounds %struct.op, %struct.op* %2, i32 0, i32 0
  %3 = load %struct.op*, %struct.op** %op_next1, align 8
  store %struct.op* %3, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %entry
  %4 = load %struct.op*, %struct.op** %o.addr, align 8
  %5 = bitcast %struct.op* %4 to %struct.unop*
  %op_first = getelementptr inbounds %struct.unop, %struct.unop* %5, i32 0, i32 8
  %6 = load %struct.op*, %struct.op** %op_first, align 8
  %tobool2 = icmp ne %struct.op* %6, null
  br i1 %tobool2, label %if.then.3, label %if.else.30

if.then.3:                                        ; preds = %if.end
  %7 = load %struct.op*, %struct.op** %o.addr, align 8
  %8 = bitcast %struct.op* %7 to %struct.unop*
  %op_first4 = getelementptr inbounds %struct.unop, %struct.unop* %8, i32 0, i32 8
  %9 = load %struct.op*, %struct.op** %op_first4, align 8
  %op_next5 = getelementptr inbounds %struct.op, %struct.op* %9, i32 0, i32 0
  %10 = load %struct.op*, %struct.op** %op_next5, align 8
  %tobool6 = icmp ne %struct.op* %10, null
  br i1 %tobool6, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.3
  %11 = load %struct.op*, %struct.op** %o.addr, align 8
  %12 = bitcast %struct.op* %11 to %struct.unop*
  %op_first7 = getelementptr inbounds %struct.unop, %struct.unop* %12, i32 0, i32 8
  %13 = load %struct.op*, %struct.op** %op_first7, align 8
  %op_next8 = getelementptr inbounds %struct.op, %struct.op* %13, i32 0, i32 0
  %14 = load %struct.op*, %struct.op** %op_next8, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then.3
  %15 = load %struct.op*, %struct.op** %o.addr, align 8
  %16 = bitcast %struct.op* %15 to %struct.unop*
  %op_first9 = getelementptr inbounds %struct.unop, %struct.unop* %16, i32 0, i32 8
  %17 = load %struct.op*, %struct.op** %op_first9, align 8
  %call = call %struct.op* @Perl_linklist(%struct.op* %17)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.op* [ %14, %cond.true ], [ %call, %cond.false ]
  %18 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next10 = getelementptr inbounds %struct.op, %struct.op* %18, i32 0, i32 0
  store %struct.op* %cond, %struct.op** %op_next10, align 8
  %19 = load %struct.op*, %struct.op** %o.addr, align 8
  %20 = bitcast %struct.op* %19 to %struct.unop*
  %op_first11 = getelementptr inbounds %struct.unop, %struct.unop* %20, i32 0, i32 8
  %21 = load %struct.op*, %struct.op** %op_first11, align 8
  store %struct.op* %21, %struct.op** %kid, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %22 = load %struct.op*, %struct.op** %kid, align 8
  %tobool12 = icmp ne %struct.op* %22, null
  br i1 %tobool12, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %23 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %23, i32 0, i32 1
  %24 = load %struct.op*, %struct.op** %op_sibling, align 8
  %tobool13 = icmp ne %struct.op* %24, null
  br i1 %tobool13, label %if.then.14, label %if.else

if.then.14:                                       ; preds = %for.body
  %25 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling15 = getelementptr inbounds %struct.op, %struct.op* %25, i32 0, i32 1
  %26 = load %struct.op*, %struct.op** %op_sibling15, align 8
  %op_next16 = getelementptr inbounds %struct.op, %struct.op* %26, i32 0, i32 0
  %27 = load %struct.op*, %struct.op** %op_next16, align 8
  %tobool17 = icmp ne %struct.op* %27, null
  br i1 %tobool17, label %cond.true.18, label %cond.false.21

cond.true.18:                                     ; preds = %if.then.14
  %28 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling19 = getelementptr inbounds %struct.op, %struct.op* %28, i32 0, i32 1
  %29 = load %struct.op*, %struct.op** %op_sibling19, align 8
  %op_next20 = getelementptr inbounds %struct.op, %struct.op* %29, i32 0, i32 0
  %30 = load %struct.op*, %struct.op** %op_next20, align 8
  br label %cond.end.24

cond.false.21:                                    ; preds = %if.then.14
  %31 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling22 = getelementptr inbounds %struct.op, %struct.op* %31, i32 0, i32 1
  %32 = load %struct.op*, %struct.op** %op_sibling22, align 8
  %call23 = call %struct.op* @Perl_linklist(%struct.op* %32)
  br label %cond.end.24

cond.end.24:                                      ; preds = %cond.false.21, %cond.true.18
  %cond25 = phi %struct.op* [ %30, %cond.true.18 ], [ %call23, %cond.false.21 ]
  %33 = load %struct.op*, %struct.op** %kid, align 8
  %op_next26 = getelementptr inbounds %struct.op, %struct.op* %33, i32 0, i32 0
  store %struct.op* %cond25, %struct.op** %op_next26, align 8
  br label %if.end.28

if.else:                                          ; preds = %for.body
  %34 = load %struct.op*, %struct.op** %o.addr, align 8
  %35 = load %struct.op*, %struct.op** %kid, align 8
  %op_next27 = getelementptr inbounds %struct.op, %struct.op* %35, i32 0, i32 0
  store %struct.op* %34, %struct.op** %op_next27, align 8
  br label %if.end.28

if.end.28:                                        ; preds = %if.else, %cond.end.24
  br label %for.inc

for.inc:                                          ; preds = %if.end.28
  %36 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling29 = getelementptr inbounds %struct.op, %struct.op* %36, i32 0, i32 1
  %37 = load %struct.op*, %struct.op** %op_sibling29, align 8
  store %struct.op* %37, %struct.op** %kid, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end.32

if.else.30:                                       ; preds = %if.end
  %38 = load %struct.op*, %struct.op** %o.addr, align 8
  %39 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next31 = getelementptr inbounds %struct.op, %struct.op* %39, i32 0, i32 0
  store %struct.op* %38, %struct.op** %op_next31, align 8
  br label %if.end.32

if.end.32:                                        ; preds = %if.else.30, %for.end
  %40 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next33 = getelementptr inbounds %struct.op, %struct.op* %40, i32 0, i32 0
  %41 = load %struct.op*, %struct.op** %op_next33, align 8
  store %struct.op* %41, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.32, %if.then
  %42 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %42
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_scalarkids(%struct.op* %o) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  %kid = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %tobool = icmp ne %struct.op* %0, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 6
  %2 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 4
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %3 = load %struct.op*, %struct.op** %o.addr, align 8
  %4 = bitcast %struct.op* %3 to %struct.listop*
  %op_first = getelementptr inbounds %struct.listop, %struct.listop* %4, i32 0, i32 8
  %5 = load %struct.op*, %struct.op** %op_first, align 8
  store %struct.op* %5, %struct.op** %kid, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %6 = load %struct.op*, %struct.op** %kid, align 8
  %tobool2 = icmp ne %struct.op* %6, null
  br i1 %tobool2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load %struct.op*, %struct.op** %kid, align 8
  %call = call %struct.op* @Perl_scalar(%struct.op* %7)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %8 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %8, i32 0, i32 1
  %9 = load %struct.op*, %struct.op** %op_sibling, align 8
  store %struct.op* %9, %struct.op** %kid, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end

if.end:                                           ; preds = %for.end, %land.lhs.true, %entry
  %10 = load %struct.op*, %struct.op** %o.addr, align 8
  ret %struct.op* %10
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_scalar(%struct.op* %o) #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %o.addr = alloca %struct.op*, align 8
  %kid = alloca %struct.op*, align 8
  %tmp = alloca %struct.cop*, align 8
  %tmp72 = alloca %struct.cop*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %tobool = icmp ne %struct.op* %0, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 6
  %2 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 3
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %if.then, label %lor.lhs.false.2

lor.lhs.false.2:                                  ; preds = %lor.lhs.false
  %3 = load i32, i32* @PL_error_count, align 4
  %tobool3 = icmp ne i32 %3, 0
  br i1 %tobool3, label %if.then, label %lor.lhs.false.4

lor.lhs.false.4:                                  ; preds = %lor.lhs.false.2
  %4 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %4, i32 0, i32 4
  %5 = load i16, i16* %op_type, align 2
  %conv5 = zext i16 %5 to i32
  %cmp = icmp eq i32 %conv5, 184
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false.4, %lor.lhs.false.2, %lor.lhs.false, %entry
  %6 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %6, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %lor.lhs.false.4
  %7 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags7 = getelementptr inbounds %struct.op, %struct.op* %7, i32 0, i32 6
  %8 = load i8, i8* %op_flags7, align 1
  %conv8 = zext i8 %8 to i32
  %and9 = and i32 %conv8, -4
  %or = or i32 %and9, 2
  %conv10 = trunc i32 %or to i8
  %9 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags11 = getelementptr inbounds %struct.op, %struct.op* %9, i32 0, i32 6
  store i8 %conv10, i8* %op_flags11, align 1
  %10 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type12 = getelementptr inbounds %struct.op, %struct.op* %10, i32 0, i32 4
  %11 = load i16, i16* %op_type12, align 2
  %conv13 = zext i16 %11 to i32
  switch i32 %conv13, label %sw.default [
    i32 61, label %sw.bb
    i32 160, label %sw.bb.14
    i32 159, label %sw.bb.14
    i32 162, label %sw.bb.14
    i32 139, label %sw.bb.19
    i32 31, label %sw.bb.31
    i32 32, label %sw.bb.31
    i32 33, label %sw.bb.31
    i32 0, label %sw.bb.31
    i32 178, label %sw.bb.46
    i32 314, label %sw.bb.46
    i32 179, label %sw.bb.57
    i32 173, label %sw.bb.57
    i32 141, label %sw.bb.57
    i32 150, label %sw.bb.73
  ]

sw.bb:                                            ; preds = %if.end
  %12 = load %struct.op*, %struct.op** %o.addr, align 8
  %13 = bitcast %struct.op* %12 to %struct.binop*
  %op_first = getelementptr inbounds %struct.binop, %struct.binop* %13, i32 0, i32 8
  %14 = load %struct.op*, %struct.op** %op_first, align 8
  %call = call %struct.op* @Perl_scalar(%struct.op* %14)
  br label %sw.epilog

sw.bb.14:                                         ; preds = %if.end, %if.end, %if.end
  %15 = load %struct.op*, %struct.op** %o.addr, align 8
  %16 = bitcast %struct.op* %15 to %struct.unop*
  %op_first15 = getelementptr inbounds %struct.unop, %struct.unop* %16, i32 0, i32 8
  %17 = load %struct.op*, %struct.op** %op_first15, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %17, i32 0, i32 1
  %18 = load %struct.op*, %struct.op** %op_sibling, align 8
  store %struct.op* %18, %struct.op** %kid, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %sw.bb.14
  %19 = load %struct.op*, %struct.op** %kid, align 8
  %tobool16 = icmp ne %struct.op* %19, null
  br i1 %tobool16, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %20 = load %struct.op*, %struct.op** %kid, align 8
  %call17 = call %struct.op* @Perl_scalar(%struct.op* %20)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %21 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling18 = getelementptr inbounds %struct.op, %struct.op* %21, i32 0, i32 1
  %22 = load %struct.op*, %struct.op** %op_sibling18, align 8
  store %struct.op* %22, %struct.op** %kid, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %sw.epilog

sw.bb.19:                                         ; preds = %if.end
  %23 = load %struct.op*, %struct.op** %o.addr, align 8
  %24 = bitcast %struct.op* %23 to %struct.listop*
  %op_first20 = getelementptr inbounds %struct.listop, %struct.listop* %24, i32 0, i32 8
  %25 = load %struct.op*, %struct.op** %op_first20, align 8
  store %struct.op* %25, %struct.op** %kid, align 8
  %tobool21 = icmp ne %struct.op* %25, null
  br i1 %tobool21, label %land.lhs.true, label %if.end.30

land.lhs.true:                                    ; preds = %sw.bb.19
  %26 = load %struct.op*, %struct.op** %kid, align 8
  %op_type22 = getelementptr inbounds %struct.op, %struct.op* %26, i32 0, i32 4
  %27 = load i16, i16* %op_type22, align 2
  %conv23 = zext i16 %27 to i32
  %cmp24 = icmp eq i32 %conv23, 13
  br i1 %cmp24, label %if.then.26, label %if.end.30

if.then.26:                                       ; preds = %land.lhs.true
  %28 = load %struct.op*, %struct.op** %kid, align 8
  %29 = bitcast %struct.op* %28 to %struct.pmop*
  %op_pmreplroot = getelementptr inbounds %struct.pmop, %struct.pmop* %29, i32 0, i32 10
  %30 = load %struct.op*, %struct.op** %op_pmreplroot, align 8
  %tobool27 = icmp ne %struct.op* %30, null
  br i1 %tobool27, label %if.end.29, label %if.then.28

if.then.28:                                       ; preds = %if.then.26
  call void @Perl_deprecate_old(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.6, i32 0, i32 0))
  br label %if.end.29

if.end.29:                                        ; preds = %if.then.28, %if.then.26
  br label %if.end.30

if.end.30:                                        ; preds = %if.end.29, %land.lhs.true, %sw.bb.19
  br label %sw.bb.31

sw.bb.31:                                         ; preds = %if.end, %if.end, %if.end, %if.end, %if.end.30
  br label %sw.default

sw.default:                                       ; preds = %if.end, %sw.bb.31
  %31 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags32 = getelementptr inbounds %struct.op, %struct.op* %31, i32 0, i32 6
  %32 = load i8, i8* %op_flags32, align 1
  %conv33 = zext i8 %32 to i32
  %and34 = and i32 %conv33, 4
  %tobool35 = icmp ne i32 %and34, 0
  br i1 %tobool35, label %if.then.36, label %if.end.45

if.then.36:                                       ; preds = %sw.default
  %33 = load %struct.op*, %struct.op** %o.addr, align 8
  %34 = bitcast %struct.op* %33 to %struct.unop*
  %op_first37 = getelementptr inbounds %struct.unop, %struct.unop* %34, i32 0, i32 8
  %35 = load %struct.op*, %struct.op** %op_first37, align 8
  store %struct.op* %35, %struct.op** %kid, align 8
  br label %for.cond.38

for.cond.38:                                      ; preds = %for.inc.42, %if.then.36
  %36 = load %struct.op*, %struct.op** %kid, align 8
  %tobool39 = icmp ne %struct.op* %36, null
  br i1 %tobool39, label %for.body.40, label %for.end.44

for.body.40:                                      ; preds = %for.cond.38
  %37 = load %struct.op*, %struct.op** %kid, align 8
  %call41 = call %struct.op* @Perl_scalar(%struct.op* %37)
  br label %for.inc.42

for.inc.42:                                       ; preds = %for.body.40
  %38 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling43 = getelementptr inbounds %struct.op, %struct.op* %38, i32 0, i32 1
  %39 = load %struct.op*, %struct.op** %op_sibling43, align 8
  store %struct.op* %39, %struct.op** %kid, align 8
  br label %for.cond.38

for.end.44:                                       ; preds = %for.cond.38
  br label %if.end.45

if.end.45:                                        ; preds = %for.end.44, %sw.default
  br label %sw.epilog

sw.bb.46:                                         ; preds = %if.end, %if.end
  %40 = load %struct.op*, %struct.op** %o.addr, align 8
  %41 = bitcast %struct.op* %40 to %struct.listop*
  %op_first47 = getelementptr inbounds %struct.listop, %struct.listop* %41, i32 0, i32 8
  %42 = load %struct.op*, %struct.op** %op_first47, align 8
  store %struct.op* %42, %struct.op** %kid, align 8
  %43 = load %struct.op*, %struct.op** %kid, align 8
  %call48 = call %struct.op* @Perl_scalar(%struct.op* %43)
  br label %while.cond

while.cond:                                       ; preds = %if.end.56, %sw.bb.46
  %44 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling49 = getelementptr inbounds %struct.op, %struct.op* %44, i32 0, i32 1
  %45 = load %struct.op*, %struct.op** %op_sibling49, align 8
  store %struct.op* %45, %struct.op** %kid, align 8
  %tobool50 = icmp ne %struct.op* %45, null
  br i1 %tobool50, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %46 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling51 = getelementptr inbounds %struct.op, %struct.op* %46, i32 0, i32 1
  %47 = load %struct.op*, %struct.op** %op_sibling51, align 8
  %tobool52 = icmp ne %struct.op* %47, null
  br i1 %tobool52, label %if.then.53, label %if.else

if.then.53:                                       ; preds = %while.body
  %48 = load %struct.op*, %struct.op** %kid, align 8
  %call54 = call %struct.op* @Perl_scalarvoid(%struct.op* %48)
  br label %if.end.56

if.else:                                          ; preds = %while.body
  %49 = load %struct.op*, %struct.op** %kid, align 8
  %call55 = call %struct.op* @Perl_scalar(%struct.op* %49)
  br label %if.end.56

if.end.56:                                        ; preds = %if.else, %if.then.53
  br label %while.cond

while.end:                                        ; preds = %while.cond
  store volatile %struct.cop* @PL_compiling, %struct.cop** @PL_curcop, align 8
  store %struct.cop* @PL_compiling, %struct.cop** %tmp
  %50 = load %struct.cop*, %struct.cop** %tmp
  br label %sw.epilog

sw.bb.57:                                         ; preds = %if.end, %if.end, %if.end
  %51 = load %struct.op*, %struct.op** %o.addr, align 8
  %52 = bitcast %struct.op* %51 to %struct.listop*
  %op_first58 = getelementptr inbounds %struct.listop, %struct.listop* %52, i32 0, i32 8
  %53 = load %struct.op*, %struct.op** %op_first58, align 8
  store %struct.op* %53, %struct.op** %kid, align 8
  br label %for.cond.59

for.cond.59:                                      ; preds = %for.inc.69, %sw.bb.57
  %54 = load %struct.op*, %struct.op** %kid, align 8
  %tobool60 = icmp ne %struct.op* %54, null
  br i1 %tobool60, label %for.body.61, label %for.end.71

for.body.61:                                      ; preds = %for.cond.59
  %55 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling62 = getelementptr inbounds %struct.op, %struct.op* %55, i32 0, i32 1
  %56 = load %struct.op*, %struct.op** %op_sibling62, align 8
  %tobool63 = icmp ne %struct.op* %56, null
  br i1 %tobool63, label %if.then.64, label %if.else.66

if.then.64:                                       ; preds = %for.body.61
  %57 = load %struct.op*, %struct.op** %kid, align 8
  %call65 = call %struct.op* @Perl_scalarvoid(%struct.op* %57)
  br label %if.end.68

if.else.66:                                       ; preds = %for.body.61
  %58 = load %struct.op*, %struct.op** %kid, align 8
  %call67 = call %struct.op* @Perl_scalar(%struct.op* %58)
  br label %if.end.68

if.end.68:                                        ; preds = %if.else.66, %if.then.64
  br label %for.inc.69

for.inc.69:                                       ; preds = %if.end.68
  %59 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling70 = getelementptr inbounds %struct.op, %struct.op* %59, i32 0, i32 1
  %60 = load %struct.op*, %struct.op** %op_sibling70, align 8
  store %struct.op* %60, %struct.op** %kid, align 8
  br label %for.cond.59

for.end.71:                                       ; preds = %for.cond.59
  store volatile %struct.cop* @PL_compiling, %struct.cop** @PL_curcop, align 8
  store %struct.cop* @PL_compiling, %struct.cop** %tmp72
  %61 = load %struct.cop*, %struct.cop** %tmp72
  br label %sw.epilog

sw.bb.73:                                         ; preds = %if.end
  %62 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings = getelementptr inbounds %struct.cop, %struct.cop* %62, i32 0, i32 14
  %63 = load %struct.sv*, %struct.sv** %cop_warnings, align 8
  %cmp74 = icmp ne %struct.sv* %63, null
  br i1 %cmp74, label %land.lhs.true.76, label %lor.lhs.false.89

land.lhs.true.76:                                 ; preds = %sw.bb.73
  %64 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings77 = getelementptr inbounds %struct.cop, %struct.cop* %64, i32 0, i32 14
  %65 = load %struct.sv*, %struct.sv** %cop_warnings77, align 8
  %cmp78 = icmp ne %struct.sv* %65, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 2)
  br i1 %cmp78, label %land.lhs.true.80, label %lor.lhs.false.89

land.lhs.true.80:                                 ; preds = %land.lhs.true.76
  %66 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings81 = getelementptr inbounds %struct.cop, %struct.cop* %66, i32 0, i32 14
  %67 = load %struct.sv*, %struct.sv** %cop_warnings81, align 8
  %cmp82 = icmp eq %struct.sv* %67, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 1)
  br i1 %cmp82, label %if.then.97, label %lor.lhs.false.84

lor.lhs.false.84:                                 ; preds = %land.lhs.true.80
  %68 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings85 = getelementptr inbounds %struct.cop, %struct.cop* %68, i32 0, i32 14
  %69 = load %struct.sv*, %struct.sv** %cop_warnings85, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %69, i32 0, i32 0
  %70 = load i8*, i8** %sv_any, align 8
  %71 = bitcast i8* %70 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %71, i32 0, i32 0
  %72 = load i8*, i8** %xpv_pv, align 8
  %arrayidx = getelementptr inbounds i8, i8* %72, i64 11
  %73 = load i8, i8* %arrayidx, align 1
  %conv86 = sext i8 %73 to i32
  %and87 = and i32 %conv86, 4
  %tobool88 = icmp ne i32 %and87, 0
  br i1 %tobool88, label %if.then.97, label %lor.lhs.false.89

lor.lhs.false.89:                                 ; preds = %lor.lhs.false.84, %land.lhs.true.76, %sw.bb.73
  %74 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings90 = getelementptr inbounds %struct.cop, %struct.cop* %74, i32 0, i32 14
  %75 = load %struct.sv*, %struct.sv** %cop_warnings90, align 8
  %cmp91 = icmp eq %struct.sv* %75, null
  br i1 %cmp91, label %land.lhs.true.93, label %if.end.98

land.lhs.true.93:                                 ; preds = %lor.lhs.false.89
  %76 = load i8, i8* @PL_dowarn, align 1
  %conv94 = zext i8 %76 to i32
  %and95 = and i32 %conv94, 1
  %tobool96 = icmp ne i32 %and95, 0
  br i1 %tobool96, label %if.then.97, label %if.end.98

if.then.97:                                       ; preds = %land.lhs.true.93, %lor.lhs.false.84, %land.lhs.true.80
  call void (i32, i8*, ...) @Perl_warner(i32 45, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.7, i32 0, i32 0))
  br label %if.end.98

if.end.98:                                        ; preds = %if.then.97, %land.lhs.true.93, %lor.lhs.false.89
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end.98, %for.end.71, %while.end, %if.end.45, %for.end, %sw.bb
  %77 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %77, %struct.op** %retval
  br label %return

return:                                           ; preds = %sw.epilog, %if.then
  %78 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %78
}

declare void @Perl_deprecate_old(i8*) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_scalarvoid(%struct.op* %o) #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %o.addr = alloca %struct.op*, align 8
  %kid = alloca %struct.op*, align 8
  %useless = alloca i8*, align 8
  %sv = alloca %struct.sv*, align 8
  %want = alloca i8, align 1
  store %struct.op* %o, %struct.op** %o.addr, align 8
  store i8* null, i8** %useless, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %0, i32 0, i32 4
  %1 = load i16, i16* %op_type, align 2
  %conv = zext i16 %1 to i32
  %cmp = icmp eq i32 %conv, 174
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type2 = getelementptr inbounds %struct.op, %struct.op* %2, i32 0, i32 4
  %3 = load i16, i16* %op_type2, align 2
  %conv3 = zext i16 %3 to i32
  %cmp4 = icmp eq i32 %conv3, 349
  br i1 %cmp4, label %if.then, label %lor.lhs.false.6

lor.lhs.false.6:                                  ; preds = %lor.lhs.false
  %4 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type7 = getelementptr inbounds %struct.op, %struct.op* %4, i32 0, i32 4
  %5 = load i16, i16* %op_type7, align 2
  %conv8 = zext i16 %5 to i32
  %cmp9 = icmp eq i32 %conv8, 175
  br i1 %cmp9, label %if.then, label %lor.lhs.false.11

lor.lhs.false.11:                                 ; preds = %lor.lhs.false.6
  %6 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type12 = getelementptr inbounds %struct.op, %struct.op* %6, i32 0, i32 4
  %7 = load i16, i16* %op_type12, align 2
  %conv13 = zext i16 %7 to i32
  %cmp14 = icmp eq i32 %conv13, 0
  br i1 %cmp14, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.lhs.false.11
  %8 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %8, i32 0, i32 3
  %9 = load i64, i64* %op_targ, align 8
  %cmp16 = icmp eq i64 %9, 174
  br i1 %cmp16, label %if.then, label %lor.lhs.false.18

lor.lhs.false.18:                                 ; preds = %land.lhs.true
  %10 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_targ19 = getelementptr inbounds %struct.op, %struct.op* %10, i32 0, i32 3
  %11 = load i64, i64* %op_targ19, align 8
  %cmp20 = icmp eq i64 %11, 349
  br i1 %cmp20, label %if.then, label %lor.lhs.false.22

lor.lhs.false.22:                                 ; preds = %lor.lhs.false.18
  %12 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_targ23 = getelementptr inbounds %struct.op, %struct.op* %12, i32 0, i32 3
  %13 = load i64, i64* %op_targ23, align 8
  %cmp24 = icmp eq i64 %13, 175
  br i1 %cmp24, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false.22, %lor.lhs.false.18, %land.lhs.true, %lor.lhs.false.6, %lor.lhs.false, %entry
  %14 = load %struct.op*, %struct.op** %o.addr, align 8
  %15 = bitcast %struct.op* %14 to %struct.cop*
  store volatile %struct.cop* %15, %struct.cop** @PL_curcop, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false.22, %lor.lhs.false.11
  %16 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %16, i32 0, i32 6
  %17 = load i8, i8* %op_flags, align 1
  %conv26 = zext i8 %17 to i32
  %and = and i32 %conv26, 3
  %conv27 = trunc i32 %and to i8
  store i8 %conv27, i8* %want, align 1
  %18 = load i8, i8* %want, align 1
  %conv28 = zext i8 %18 to i32
  %tobool = icmp ne i32 %conv28, 0
  br i1 %tobool, label %land.lhs.true.29, label %lor.lhs.false.33

land.lhs.true.29:                                 ; preds = %if.end
  %19 = load i8, i8* %want, align 1
  %conv30 = zext i8 %19 to i32
  %cmp31 = icmp ne i32 %conv30, 2
  br i1 %cmp31, label %if.then.40, label %lor.lhs.false.33

lor.lhs.false.33:                                 ; preds = %land.lhs.true.29, %if.end
  %20 = load i32, i32* @PL_error_count, align 4
  %tobool34 = icmp ne i32 %20, 0
  br i1 %tobool34, label %if.then.40, label %lor.lhs.false.35

lor.lhs.false.35:                                 ; preds = %lor.lhs.false.33
  %21 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type36 = getelementptr inbounds %struct.op, %struct.op* %21, i32 0, i32 4
  %22 = load i16, i16* %op_type36, align 2
  %conv37 = zext i16 %22 to i32
  %cmp38 = icmp eq i32 %conv37, 184
  br i1 %cmp38, label %if.then.40, label %if.end.41

if.then.40:                                       ; preds = %lor.lhs.false.35, %lor.lhs.false.33, %land.lhs.true.29
  %23 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %23, %struct.op** %retval
  br label %return

if.end.41:                                        ; preds = %lor.lhs.false.35
  %24 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %24, i32 0, i32 7
  %25 = load i8, i8* %op_private, align 1
  %conv42 = zext i8 %25 to i32
  %and43 = and i32 %conv42, 16
  %tobool44 = icmp ne i32 %and43, 0
  br i1 %tobool44, label %land.lhs.true.45, label %if.end.50

land.lhs.true.45:                                 ; preds = %if.end.41
  %26 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type46 = getelementptr inbounds %struct.op, %struct.op* %26, i32 0, i32 4
  %27 = load i16, i16* %op_type46, align 2
  %idxprom = zext i16 %27 to i64
  %arrayidx = getelementptr inbounds [0 x i32], [0 x i32]* @PL_opargs, i32 0, i64 %idxprom
  %28 = load i32, i32* %arrayidx, align 4
  %and47 = and i32 %28, 256
  %tobool48 = icmp ne i32 %and47, 0
  br i1 %tobool48, label %if.then.49, label %if.end.50

if.then.49:                                       ; preds = %land.lhs.true.45
  %29 = load %struct.op*, %struct.op** %o.addr, align 8
  %call = call %struct.op* @Perl_scalar(%struct.op* %29)
  store %struct.op* %call, %struct.op** %retval
  br label %return

if.end.50:                                        ; preds = %land.lhs.true.45, %if.end.41
  %30 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags51 = getelementptr inbounds %struct.op, %struct.op* %30, i32 0, i32 6
  %31 = load i8, i8* %op_flags51, align 1
  %conv52 = zext i8 %31 to i32
  %and53 = and i32 %conv52, -4
  %or = or i32 %and53, 1
  %conv54 = trunc i32 %or to i8
  %32 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags55 = getelementptr inbounds %struct.op, %struct.op* %32, i32 0, i32 6
  store i8 %conv54, i8* %op_flags55, align 1
  %33 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type56 = getelementptr inbounds %struct.op, %struct.op* %33, i32 0, i32 4
  %34 = load i16, i16* %op_type56, align 2
  %conv57 = zext i16 %34 to i32
  switch i32 %conv57, label %sw.default [
    i32 61, label %sw.bb
    i32 111, label %sw.bb.71
    i32 6, label %sw.bb.78
    i32 4, label %sw.bb.78
    i32 7, label %sw.bb.78
    i32 9, label %sw.bb.78
    i32 10, label %sw.bb.78
    i32 11, label %sw.bb.78
    i32 12, label %sw.bb.78
    i32 16, label %sw.bb.78
    i32 22, label %sw.bb.78
    i32 20, label %sw.bb.78
    i32 21, label %sw.bb.78
    i32 42, label %sw.bb.78
    i32 107, label %sw.bb.78
    i32 108, label %sw.bb.78
    i32 110, label %sw.bb.78
    i32 112, label %sw.bb.78
    i32 113, label %sw.bb.78
    i32 114, label %sw.bb.78
    i32 115, label %sw.bb.78
    i32 127, label %sw.bb.78
    i32 126, label %sw.bb.78
    i32 128, label %sw.bb.78
    i32 135, label %sw.bb.78
    i32 136, label %sw.bb.78
    i32 137, label %sw.bb.78
    i32 138, label %sw.bb.78
    i32 140, label %sw.bb.78
    i32 142, label %sw.bb.78
    i32 143, label %sw.bb.78
    i32 144, label %sw.bb.78
    i32 150, label %sw.bb.78
    i32 151, label %sw.bb.78
    i32 156, label %sw.bb.78
    i32 157, label %sw.bb.78
    i32 158, label %sw.bb.78
    i32 169, label %sw.bb.78
    i32 194, label %sw.bb.78
    i32 216, label %sw.bb.78
    i32 217, label %sw.bb.78
    i32 232, label %sw.bb.78
    i32 233, label %sw.bb.78
    i32 272, label %sw.bb.78
    i32 277, label %sw.bb.78
    i32 287, label %sw.bb.78
    i32 288, label %sw.bb.78
    i32 290, label %sw.bb.78
    i32 292, label %sw.bb.78
    i32 293, label %sw.bb.78
    i32 294, label %sw.bb.78
    i32 295, label %sw.bb.78
    i32 315, label %sw.bb.78
    i32 316, label %sw.bb.78
    i32 317, label %sw.bb.78
    i32 318, label %sw.bb.78
    i32 319, label %sw.bb.78
    i32 320, label %sw.bb.78
    i32 321, label %sw.bb.78
    i32 322, label %sw.bb.78
    i32 323, label %sw.bb.78
    i32 324, label %sw.bb.78
    i32 325, label %sw.bb.78
    i32 326, label %sw.bb.78
    i32 335, label %sw.bb.78
    i32 336, label %sw.bb.78
    i32 340, label %sw.bb.78
    i32 341, label %sw.bb.78
    i32 345, label %sw.bb.78
    i32 19, label %sw.bb.78
    i32 14, label %sw.bb.93
    i32 15, label %sw.bb.93
    i32 125, label %sw.bb.93
    i32 134, label %sw.bb.93
    i32 5, label %sw.bb.108
    i32 50, label %sw.bb.199
    i32 52, label %sw.bb.201
    i32 160, label %sw.bb.204
    i32 159, label %sw.bb.204
    i32 162, label %sw.bb.204
    i32 0, label %sw.bb.209
    i32 174, label %sw.bb.216
    i32 175, label %sw.bb.216
    i32 313, label %sw.bb.216
    i32 177, label %sw.bb.216
    i32 179, label %sw.bb.223
    i32 178, label %sw.bb.223
    i32 314, label %sw.bb.223
    i32 183, label %sw.bb.223
    i32 173, label %sw.bb.223
    i32 141, label %sw.bb.223
    i32 311, label %sw.bb.232
    i32 309, label %sw.bb.234
    i32 2, label %sw.bb.239
    i32 139, label %sw.bb.241
  ]

sw.default:                                       ; preds = %if.end.50
  %35 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type58 = getelementptr inbounds %struct.op, %struct.op* %35, i32 0, i32 4
  %36 = load i16, i16* %op_type58, align 2
  %idxprom59 = zext i16 %36 to i64
  %arrayidx60 = getelementptr inbounds [0 x i32], [0 x i32]* @PL_opargs, i32 0, i64 %idxprom59
  %37 = load i32, i32* %arrayidx60, align 4
  %and61 = and i32 %37, 2
  %tobool62 = icmp ne i32 %and61, 0
  br i1 %tobool62, label %if.end.64, label %if.then.63

if.then.63:                                       ; preds = %sw.default
  br label %sw.epilog

if.end.64:                                        ; preds = %sw.default
  br label %sw.bb

sw.bb:                                            ; preds = %if.end.50, %if.end.64
  %38 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags65 = getelementptr inbounds %struct.op, %struct.op* %38, i32 0, i32 6
  %39 = load i8, i8* %op_flags65, align 1
  %conv66 = zext i8 %39 to i32
  %and67 = and i32 %conv66, 64
  %tobool68 = icmp ne i32 %and67, 0
  br i1 %tobool68, label %if.then.69, label %if.end.70

if.then.69:                                       ; preds = %sw.bb
  br label %sw.epilog

if.end.70:                                        ; preds = %sw.bb
  br label %func_ops

sw.bb.71:                                         ; preds = %if.end.50
  %40 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private72 = getelementptr inbounds %struct.op, %struct.op* %40, i32 0, i32 7
  %41 = load i8, i8* %op_private72, align 1
  %conv73 = zext i8 %41 to i32
  %cmp74 = icmp eq i32 %conv73, 4
  br i1 %cmp74, label %if.then.76, label %if.end.77

if.then.76:                                       ; preds = %sw.bb.71
  br label %sw.epilog

if.end.77:                                        ; preds = %sw.bb.71
  br label %sw.bb.78

sw.bb.78:                                         ; preds = %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.77
  br label %func_ops

func_ops:                                         ; preds = %sw.bb.78, %if.end.70
  %42 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private79 = getelementptr inbounds %struct.op, %struct.op* %42, i32 0, i32 7
  %43 = load i8, i8* %op_private79, align 1
  %conv80 = zext i8 %43 to i32
  %and81 = and i32 %conv80, 144
  %tobool82 = icmp ne i32 %and81, 0
  br i1 %tobool82, label %if.end.92, label %if.then.83

if.then.83:                                       ; preds = %func_ops
  %44 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type84 = getelementptr inbounds %struct.op, %struct.op* %44, i32 0, i32 4
  %45 = load i16, i16* %op_type84, align 2
  %conv85 = zext i16 %45 to i32
  %cmp86 = icmp eq i32 %conv85, 351
  br i1 %cmp86, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.83
  %46 = load %struct.op*, %struct.op** %o.addr, align 8
  %call88 = call i8* @Perl_custom_op_desc(%struct.op* %46)
  br label %cond.end

cond.false:                                       ; preds = %if.then.83
  %47 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type89 = getelementptr inbounds %struct.op, %struct.op* %47, i32 0, i32 4
  %48 = load i16, i16* %op_type89, align 2
  %idxprom90 = zext i16 %48 to i64
  %arrayidx91 = getelementptr inbounds [0 x i8*], [0 x i8*]* @PL_op_desc, i32 0, i64 %idxprom90
  %49 = load i8*, i8** %arrayidx91, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %call88, %cond.true ], [ %49, %cond.false ]
  store i8* %cond, i8** %useless, align 8
  br label %if.end.92

if.end.92:                                        ; preds = %cond.end, %func_ops
  br label %sw.epilog

sw.bb.93:                                         ; preds = %if.end.50, %if.end.50, %if.end.50, %if.end.50
  %50 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private94 = getelementptr inbounds %struct.op, %struct.op* %50, i32 0, i32 7
  %51 = load i8, i8* %op_private94, align 1
  %conv95 = zext i8 %51 to i32
  %and96 = and i32 %conv95, 144
  %tobool97 = icmp ne i32 %and96, 0
  br i1 %tobool97, label %if.end.107, label %land.lhs.true.98

land.lhs.true.98:                                 ; preds = %sw.bb.93
  %52 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %52, i32 0, i32 1
  %53 = load %struct.op*, %struct.op** %op_sibling, align 8
  %tobool99 = icmp ne %struct.op* %53, null
  br i1 %tobool99, label %lor.lhs.false.100, label %if.then.106

lor.lhs.false.100:                                ; preds = %land.lhs.true.98
  %54 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_sibling101 = getelementptr inbounds %struct.op, %struct.op* %54, i32 0, i32 1
  %55 = load %struct.op*, %struct.op** %op_sibling101, align 8
  %op_type102 = getelementptr inbounds %struct.op, %struct.op* %55, i32 0, i32 4
  %56 = load i16, i16* %op_type102, align 2
  %conv103 = zext i16 %56 to i32
  %cmp104 = icmp ne i32 %conv103, 26
  br i1 %cmp104, label %if.then.106, label %if.end.107

if.then.106:                                      ; preds = %lor.lhs.false.100, %land.lhs.true.98
  store i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.8, i32 0, i32 0), i8** %useless, align 8
  br label %if.end.107

if.end.107:                                       ; preds = %if.then.106, %lor.lhs.false.100, %sw.bb.93
  br label %sw.epilog

sw.bb.108:                                        ; preds = %if.end.50
  %57 = load %struct.op*, %struct.op** %o.addr, align 8
  %58 = bitcast %struct.op* %57 to %struct.svop*
  %op_sv = getelementptr inbounds %struct.svop, %struct.svop* %58, i32 0, i32 8
  %59 = load %struct.sv*, %struct.sv** %op_sv, align 8
  store %struct.sv* %59, %struct.sv** %sv, align 8
  %60 = load %struct.op*, %struct.op** %o.addr, align 8
  %61 = bitcast %struct.op* %60 to %struct.svop*
  %op_private109 = getelementptr inbounds %struct.svop, %struct.svop* %61, i32 0, i32 7
  %62 = load i8, i8* %op_private109, align 1
  %conv110 = zext i8 %62 to i32
  %and111 = and i32 %conv110, 8
  %tobool112 = icmp ne i32 %and111, 0
  br i1 %tobool112, label %if.then.113, label %if.else

if.then.113:                                      ; preds = %sw.bb.108
  %63 = load %struct.op*, %struct.op** %o.addr, align 8
  call void @S_no_bareword_allowed(%struct.op* %63)
  br label %if.end.198

if.else:                                          ; preds = %sw.bb.108
  %64 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings = getelementptr inbounds %struct.cop, %struct.cop* %64, i32 0, i32 14
  %65 = load %struct.sv*, %struct.sv** %cop_warnings, align 8
  %cmp114 = icmp ne %struct.sv* %65, null
  br i1 %cmp114, label %land.lhs.true.116, label %lor.lhs.false.130

land.lhs.true.116:                                ; preds = %if.else
  %66 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings117 = getelementptr inbounds %struct.cop, %struct.cop* %66, i32 0, i32 14
  %67 = load %struct.sv*, %struct.sv** %cop_warnings117, align 8
  %cmp118 = icmp ne %struct.sv* %67, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 2)
  br i1 %cmp118, label %land.lhs.true.120, label %lor.lhs.false.130

land.lhs.true.120:                                ; preds = %land.lhs.true.116
  %68 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings121 = getelementptr inbounds %struct.cop, %struct.cop* %68, i32 0, i32 14
  %69 = load %struct.sv*, %struct.sv** %cop_warnings121, align 8
  %cmp122 = icmp eq %struct.sv* %69, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 1)
  br i1 %cmp122, label %if.then.138, label %lor.lhs.false.124

lor.lhs.false.124:                                ; preds = %land.lhs.true.120
  %70 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings125 = getelementptr inbounds %struct.cop, %struct.cop* %70, i32 0, i32 14
  %71 = load %struct.sv*, %struct.sv** %cop_warnings125, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %71, i32 0, i32 0
  %72 = load i8*, i8** %sv_any, align 8
  %73 = bitcast i8* %72 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %73, i32 0, i32 0
  %74 = load i8*, i8** %xpv_pv, align 8
  %arrayidx126 = getelementptr inbounds i8, i8* %74, i64 11
  %75 = load i8, i8* %arrayidx126, align 1
  %conv127 = sext i8 %75 to i32
  %and128 = and i32 %conv127, 4
  %tobool129 = icmp ne i32 %and128, 0
  br i1 %tobool129, label %if.then.138, label %lor.lhs.false.130

lor.lhs.false.130:                                ; preds = %lor.lhs.false.124, %land.lhs.true.116, %if.else
  %76 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings131 = getelementptr inbounds %struct.cop, %struct.cop* %76, i32 0, i32 14
  %77 = load %struct.sv*, %struct.sv** %cop_warnings131, align 8
  %cmp132 = icmp eq %struct.sv* %77, null
  br i1 %cmp132, label %land.lhs.true.134, label %if.end.197

land.lhs.true.134:                                ; preds = %lor.lhs.false.130
  %78 = load i8, i8* @PL_dowarn, align 1
  %conv135 = zext i8 %78 to i32
  %and136 = and i32 %conv135, 1
  %tobool137 = icmp ne i32 %and136, 0
  br i1 %tobool137, label %if.then.138, label %if.end.197

if.then.138:                                      ; preds = %land.lhs.true.134, %lor.lhs.false.124, %land.lhs.true.120
  store i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.9, i32 0, i32 0), i8** %useless, align 8
  %79 = load %struct.op*, %struct.op** %o.addr, align 8
  %80 = bitcast %struct.op* %79 to %struct.svop*
  %op_private139 = getelementptr inbounds %struct.svop, %struct.svop* %80, i32 0, i32 7
  %81 = load i8, i8* %op_private139, align 1
  %conv140 = zext i8 %81 to i32
  %and141 = and i32 %conv140, 4
  %tobool142 = icmp ne i32 %and141, 0
  br i1 %tobool142, label %if.then.143, label %if.else.144

if.then.143:                                      ; preds = %if.then.138
  store i8* null, i8** %useless, align 8
  br label %if.end.196

if.else.144:                                      ; preds = %if.then.138
  %82 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %82, i32 0, i32 2
  %83 = load i32, i32* %sv_flags, align 4
  %and145 = and i32 %83, 196608
  %tobool146 = icmp ne i32 %and145, 0
  br i1 %tobool146, label %land.lhs.true.147, label %if.else.173

land.lhs.true.147:                                ; preds = %if.else.144
  %84 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags148 = getelementptr inbounds %struct.sv, %struct.sv* %84, i32 0, i32 2
  %85 = load i32, i32* %sv_flags148, align 4
  %and149 = and i32 %85, 131072
  %tobool150 = icmp ne i32 %and149, 0
  br i1 %tobool150, label %cond.true.151, label %cond.false.153

cond.true.151:                                    ; preds = %land.lhs.true.147
  %86 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any152 = getelementptr inbounds %struct.sv, %struct.sv* %86, i32 0, i32 0
  %87 = load i8*, i8** %sv_any152, align 8
  %88 = bitcast i8* %87 to %struct.xpvnv*
  %xnv_nv = getelementptr inbounds %struct.xpvnv, %struct.xpvnv* %88, i32 0, i32 4
  %89 = load double, double* %xnv_nv, align 8
  br label %cond.end.155

cond.false.153:                                   ; preds = %land.lhs.true.147
  %90 = load %struct.sv*, %struct.sv** %sv, align 8
  %call154 = call double @Perl_sv_2nv(%struct.sv* %90)
  br label %cond.end.155

cond.end.155:                                     ; preds = %cond.false.153, %cond.true.151
  %cond156 = phi double [ %89, %cond.true.151 ], [ %call154, %cond.false.153 ]
  %cmp157 = fcmp oeq double %cond156, 0.000000e+00
  br i1 %cmp157, label %if.then.172, label %lor.lhs.false.159

lor.lhs.false.159:                                ; preds = %cond.end.155
  %91 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags160 = getelementptr inbounds %struct.sv, %struct.sv* %91, i32 0, i32 2
  %92 = load i32, i32* %sv_flags160, align 4
  %and161 = and i32 %92, 131072
  %tobool162 = icmp ne i32 %and161, 0
  br i1 %tobool162, label %cond.true.163, label %cond.false.166

cond.true.163:                                    ; preds = %lor.lhs.false.159
  %93 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any164 = getelementptr inbounds %struct.sv, %struct.sv* %93, i32 0, i32 0
  %94 = load i8*, i8** %sv_any164, align 8
  %95 = bitcast i8* %94 to %struct.xpvnv*
  %xnv_nv165 = getelementptr inbounds %struct.xpvnv, %struct.xpvnv* %95, i32 0, i32 4
  %96 = load double, double* %xnv_nv165, align 8
  br label %cond.end.168

cond.false.166:                                   ; preds = %lor.lhs.false.159
  %97 = load %struct.sv*, %struct.sv** %sv, align 8
  %call167 = call double @Perl_sv_2nv(%struct.sv* %97)
  br label %cond.end.168

cond.end.168:                                     ; preds = %cond.false.166, %cond.true.163
  %cond169 = phi double [ %96, %cond.true.163 ], [ %call167, %cond.false.166 ]
  %cmp170 = fcmp oeq double %cond169, 1.000000e+00
  br i1 %cmp170, label %if.then.172, label %if.else.173

if.then.172:                                      ; preds = %cond.end.168, %cond.end.155
  store i8* null, i8** %useless, align 8
  br label %if.end.195

if.else.173:                                      ; preds = %cond.end.168, %if.else.144
  %98 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags174 = getelementptr inbounds %struct.sv, %struct.sv* %98, i32 0, i32 2
  %99 = load i32, i32* %sv_flags174, align 4
  %and175 = and i32 %99, 262144
  %tobool176 = icmp ne i32 %and175, 0
  br i1 %tobool176, label %if.then.177, label %if.end.194

if.then.177:                                      ; preds = %if.else.173
  %100 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any178 = getelementptr inbounds %struct.sv, %struct.sv* %100, i32 0, i32 0
  %101 = load i8*, i8** %sv_any178, align 8
  %102 = bitcast i8* %101 to %struct.xpv*
  %xpv_pv179 = getelementptr inbounds %struct.xpv, %struct.xpv* %102, i32 0, i32 0
  %103 = load i8*, i8** %xpv_pv179, align 8
  %call180 = call i32 @strncmp(i8* %103, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.10, i32 0, i32 0), i64 2)
  %tobool181 = icmp ne i32 %call180, 0
  br i1 %tobool181, label %lor.lhs.false.182, label %if.then.192

lor.lhs.false.182:                                ; preds = %if.then.177
  %104 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any183 = getelementptr inbounds %struct.sv, %struct.sv* %104, i32 0, i32 0
  %105 = load i8*, i8** %sv_any183, align 8
  %106 = bitcast i8* %105 to %struct.xpv*
  %xpv_pv184 = getelementptr inbounds %struct.xpv, %struct.xpv* %106, i32 0, i32 0
  %107 = load i8*, i8** %xpv_pv184, align 8
  %call185 = call i32 @strncmp(i8* %107, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.11, i32 0, i32 0), i64 2)
  %tobool186 = icmp ne i32 %call185, 0
  br i1 %tobool186, label %lor.lhs.false.187, label %if.then.192

lor.lhs.false.187:                                ; preds = %lor.lhs.false.182
  %108 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any188 = getelementptr inbounds %struct.sv, %struct.sv* %108, i32 0, i32 0
  %109 = load i8*, i8** %sv_any188, align 8
  %110 = bitcast i8* %109 to %struct.xpv*
  %xpv_pv189 = getelementptr inbounds %struct.xpv, %struct.xpv* %110, i32 0, i32 0
  %111 = load i8*, i8** %xpv_pv189, align 8
  %call190 = call i32 @strncmp(i8* %111, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.12, i32 0, i32 0), i64 2)
  %tobool191 = icmp ne i32 %call190, 0
  br i1 %tobool191, label %if.end.193, label %if.then.192

if.then.192:                                      ; preds = %lor.lhs.false.187, %lor.lhs.false.182, %if.then.177
  store i8* null, i8** %useless, align 8
  br label %if.end.193

if.end.193:                                       ; preds = %if.then.192, %lor.lhs.false.187
  br label %if.end.194

if.end.194:                                       ; preds = %if.end.193, %if.else.173
  br label %if.end.195

if.end.195:                                       ; preds = %if.end.194, %if.then.172
  br label %if.end.196

if.end.196:                                       ; preds = %if.end.195, %if.then.143
  br label %if.end.197

if.end.197:                                       ; preds = %if.end.196, %land.lhs.true.134, %lor.lhs.false.130
  br label %if.end.198

if.end.198:                                       ; preds = %if.end.197, %if.then.113
  %112 = load %struct.op*, %struct.op** %o.addr, align 8
  call void @Perl_op_null(%struct.op* %112)
  br label %sw.epilog

sw.bb.199:                                        ; preds = %if.end.50
  %113 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type200 = getelementptr inbounds %struct.op, %struct.op* %113, i32 0, i32 4
  store i16 46, i16* %op_type200, align 2
  %114 = load %struct.op* ()*, %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 46), align 8
  %115 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_ppaddr = getelementptr inbounds %struct.op, %struct.op* %115, i32 0, i32 2
  store %struct.op* ()* %114, %struct.op* ()** %op_ppaddr, align 8
  br label %sw.epilog

sw.bb.201:                                        ; preds = %if.end.50
  %116 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type202 = getelementptr inbounds %struct.op, %struct.op* %116, i32 0, i32 4
  store i16 48, i16* %op_type202, align 2
  %117 = load %struct.op* ()*, %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 48), align 8
  %118 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_ppaddr203 = getelementptr inbounds %struct.op, %struct.op* %118, i32 0, i32 2
  store %struct.op* ()* %117, %struct.op* ()** %op_ppaddr203, align 8
  br label %sw.epilog

sw.bb.204:                                        ; preds = %if.end.50, %if.end.50, %if.end.50
  %119 = load %struct.op*, %struct.op** %o.addr, align 8
  %120 = bitcast %struct.op* %119 to %struct.unop*
  %op_first = getelementptr inbounds %struct.unop, %struct.unop* %120, i32 0, i32 8
  %121 = load %struct.op*, %struct.op** %op_first, align 8
  %op_sibling205 = getelementptr inbounds %struct.op, %struct.op* %121, i32 0, i32 1
  %122 = load %struct.op*, %struct.op** %op_sibling205, align 8
  store %struct.op* %122, %struct.op** %kid, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %sw.bb.204
  %123 = load %struct.op*, %struct.op** %kid, align 8
  %tobool206 = icmp ne %struct.op* %123, null
  br i1 %tobool206, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %124 = load %struct.op*, %struct.op** %kid, align 8
  %call207 = call %struct.op* @Perl_scalarvoid(%struct.op* %124)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %125 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling208 = getelementptr inbounds %struct.op, %struct.op* %125, i32 0, i32 1
  %126 = load %struct.op*, %struct.op** %op_sibling208, align 8
  store %struct.op* %126, %struct.op** %kid, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %sw.epilog

sw.bb.209:                                        ; preds = %if.end.50
  %127 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags210 = getelementptr inbounds %struct.op, %struct.op* %127, i32 0, i32 6
  %128 = load i8, i8* %op_flags210, align 1
  %conv211 = zext i8 %128 to i32
  %and212 = and i32 %conv211, 64
  %tobool213 = icmp ne i32 %and212, 0
  br i1 %tobool213, label %if.then.214, label %if.end.215

if.then.214:                                      ; preds = %sw.bb.209
  br label %sw.epilog

if.end.215:                                       ; preds = %sw.bb.209
  br label %sw.bb.216

sw.bb.216:                                        ; preds = %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.215
  %129 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags217 = getelementptr inbounds %struct.op, %struct.op* %129, i32 0, i32 6
  %130 = load i8, i8* %op_flags217, align 1
  %conv218 = zext i8 %130 to i32
  %and219 = and i32 %conv218, 4
  %tobool220 = icmp ne i32 %and219, 0
  br i1 %tobool220, label %if.end.222, label %if.then.221

if.then.221:                                      ; preds = %sw.bb.216
  br label %sw.epilog

if.end.222:                                       ; preds = %sw.bb.216
  br label %sw.bb.223

sw.bb.223:                                        ; preds = %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.50, %if.end.222
  %131 = load %struct.op*, %struct.op** %o.addr, align 8
  %132 = bitcast %struct.op* %131 to %struct.listop*
  %op_first224 = getelementptr inbounds %struct.listop, %struct.listop* %132, i32 0, i32 8
  %133 = load %struct.op*, %struct.op** %op_first224, align 8
  store %struct.op* %133, %struct.op** %kid, align 8
  br label %for.cond.225

for.cond.225:                                     ; preds = %for.inc.229, %sw.bb.223
  %134 = load %struct.op*, %struct.op** %kid, align 8
  %tobool226 = icmp ne %struct.op* %134, null
  br i1 %tobool226, label %for.body.227, label %for.end.231

for.body.227:                                     ; preds = %for.cond.225
  %135 = load %struct.op*, %struct.op** %kid, align 8
  %call228 = call %struct.op* @Perl_scalarvoid(%struct.op* %135)
  br label %for.inc.229

for.inc.229:                                      ; preds = %for.body.227
  %136 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling230 = getelementptr inbounds %struct.op, %struct.op* %136, i32 0, i32 1
  %137 = load %struct.op*, %struct.op** %op_sibling230, align 8
  store %struct.op* %137, %struct.op** %kid, align 8
  br label %for.cond.225

for.end.231:                                      ; preds = %for.cond.225
  br label %sw.epilog

sw.bb.232:                                        ; preds = %if.end.50
  %138 = load %struct.op*, %struct.op** %o.addr, align 8
  %call233 = call %struct.op* @Perl_scalarkids(%struct.op* %138)
  br label %sw.epilog

sw.bb.234:                                        ; preds = %if.end.50
  %139 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags235 = getelementptr inbounds %struct.op, %struct.op* %139, i32 0, i32 6
  %140 = load i8, i8* %op_flags235, align 1
  %conv236 = zext i8 %140 to i32
  %and237 = and i32 %conv236, -4
  %conv238 = trunc i32 %and237 to i8
  store i8 %conv238, i8* %op_flags235, align 1
  br label %sw.bb.239

sw.bb.239:                                        ; preds = %if.end.50, %sw.bb.234
  %141 = load %struct.op*, %struct.op** %o.addr, align 8
  %call240 = call %struct.op* @Perl_scalar(%struct.op* %141)
  store %struct.op* %call240, %struct.op** %retval
  br label %return

sw.bb.241:                                        ; preds = %if.end.50
  %142 = load %struct.op*, %struct.op** %o.addr, align 8
  %143 = bitcast %struct.op* %142 to %struct.listop*
  %op_first242 = getelementptr inbounds %struct.listop, %struct.listop* %143, i32 0, i32 8
  %144 = load %struct.op*, %struct.op** %op_first242, align 8
  store %struct.op* %144, %struct.op** %kid, align 8
  %tobool243 = icmp ne %struct.op* %144, null
  br i1 %tobool243, label %land.lhs.true.244, label %if.end.253

land.lhs.true.244:                                ; preds = %sw.bb.241
  %145 = load %struct.op*, %struct.op** %kid, align 8
  %op_type245 = getelementptr inbounds %struct.op, %struct.op* %145, i32 0, i32 4
  %146 = load i16, i16* %op_type245, align 2
  %conv246 = zext i16 %146 to i32
  %cmp247 = icmp eq i32 %conv246, 13
  br i1 %cmp247, label %if.then.249, label %if.end.253

if.then.249:                                      ; preds = %land.lhs.true.244
  %147 = load %struct.op*, %struct.op** %kid, align 8
  %148 = bitcast %struct.op* %147 to %struct.pmop*
  %op_pmreplroot = getelementptr inbounds %struct.pmop, %struct.pmop* %148, i32 0, i32 10
  %149 = load %struct.op*, %struct.op** %op_pmreplroot, align 8
  %tobool250 = icmp ne %struct.op* %149, null
  br i1 %tobool250, label %if.end.252, label %if.then.251

if.then.251:                                      ; preds = %if.then.249
  call void @Perl_deprecate_old(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.6, i32 0, i32 0))
  br label %if.end.252

if.end.252:                                       ; preds = %if.then.251, %if.then.249
  br label %if.end.253

if.end.253:                                       ; preds = %if.end.252, %land.lhs.true.244, %sw.bb.241
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end.253, %sw.bb.232, %for.end.231, %if.then.221, %if.then.214, %for.end, %sw.bb.201, %sw.bb.199, %if.end.198, %if.end.107, %if.end.92, %if.then.76, %if.then.69, %if.then.63
  %150 = load i8*, i8** %useless, align 8
  %tobool254 = icmp ne i8* %150, null
  br i1 %tobool254, label %land.lhs.true.255, label %if.end.284

land.lhs.true.255:                                ; preds = %sw.epilog
  %151 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings256 = getelementptr inbounds %struct.cop, %struct.cop* %151, i32 0, i32 14
  %152 = load %struct.sv*, %struct.sv** %cop_warnings256, align 8
  %cmp257 = icmp ne %struct.sv* %152, null
  br i1 %cmp257, label %land.lhs.true.259, label %lor.lhs.false.275

land.lhs.true.259:                                ; preds = %land.lhs.true.255
  %153 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings260 = getelementptr inbounds %struct.cop, %struct.cop* %153, i32 0, i32 14
  %154 = load %struct.sv*, %struct.sv** %cop_warnings260, align 8
  %cmp261 = icmp ne %struct.sv* %154, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 2)
  br i1 %cmp261, label %land.lhs.true.263, label %lor.lhs.false.275

land.lhs.true.263:                                ; preds = %land.lhs.true.259
  %155 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings264 = getelementptr inbounds %struct.cop, %struct.cop* %155, i32 0, i32 14
  %156 = load %struct.sv*, %struct.sv** %cop_warnings264, align 8
  %cmp265 = icmp eq %struct.sv* %156, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 1)
  br i1 %cmp265, label %if.then.283, label %lor.lhs.false.267

lor.lhs.false.267:                                ; preds = %land.lhs.true.263
  %157 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings268 = getelementptr inbounds %struct.cop, %struct.cop* %157, i32 0, i32 14
  %158 = load %struct.sv*, %struct.sv** %cop_warnings268, align 8
  %sv_any269 = getelementptr inbounds %struct.sv, %struct.sv* %158, i32 0, i32 0
  %159 = load i8*, i8** %sv_any269, align 8
  %160 = bitcast i8* %159 to %struct.xpv*
  %xpv_pv270 = getelementptr inbounds %struct.xpv, %struct.xpv* %160, i32 0, i32 0
  %161 = load i8*, i8** %xpv_pv270, align 8
  %arrayidx271 = getelementptr inbounds i8, i8* %161, i64 11
  %162 = load i8, i8* %arrayidx271, align 1
  %conv272 = sext i8 %162 to i32
  %and273 = and i32 %conv272, 4
  %tobool274 = icmp ne i32 %and273, 0
  br i1 %tobool274, label %if.then.283, label %lor.lhs.false.275

lor.lhs.false.275:                                ; preds = %lor.lhs.false.267, %land.lhs.true.259, %land.lhs.true.255
  %163 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings276 = getelementptr inbounds %struct.cop, %struct.cop* %163, i32 0, i32 14
  %164 = load %struct.sv*, %struct.sv** %cop_warnings276, align 8
  %cmp277 = icmp eq %struct.sv* %164, null
  br i1 %cmp277, label %land.lhs.true.279, label %if.end.284

land.lhs.true.279:                                ; preds = %lor.lhs.false.275
  %165 = load i8, i8* @PL_dowarn, align 1
  %conv280 = zext i8 %165 to i32
  %and281 = and i32 %conv280, 1
  %tobool282 = icmp ne i32 %and281, 0
  br i1 %tobool282, label %if.then.283, label %if.end.284

if.then.283:                                      ; preds = %land.lhs.true.279, %lor.lhs.false.267, %land.lhs.true.263
  %166 = load i8*, i8** %useless, align 8
  call void (i32, i8*, ...) @Perl_warner(i32 45, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.13, i32 0, i32 0), i8* %166)
  br label %if.end.284

if.end.284:                                       ; preds = %if.then.283, %land.lhs.true.279, %lor.lhs.false.275, %sw.epilog
  %167 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %167, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.284, %sw.bb.239, %if.then.49, %if.then.40
  %168 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %168
}

declare void @Perl_warner(i32, i8*, ...) #1

; Function Attrs: nounwind uwtable
define i8* @Perl_custom_op_desc(%struct.op* %o) #0 {
entry:
  %retval = alloca i8*, align 8
  %o.addr = alloca %struct.op*, align 8
  %index = alloca i64, align 8
  %keysv = alloca %struct.sv*, align 8
  %he = alloca %struct.he*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_ppaddr = getelementptr inbounds %struct.op, %struct.op* %0, i32 0, i32 2
  %1 = load %struct.op* ()*, %struct.op* ()** %op_ppaddr, align 8
  %2 = ptrtoint %struct.op* ()* %1 to i64
  store i64 %2, i64* %index, align 8
  %3 = load %struct.hv*, %struct.hv** @PL_custom_op_descs, align 8
  %tobool = icmp ne %struct.hv* %3, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %4 = load i8*, i8** getelementptr inbounds ([0 x i8*], [0 x i8*]* @PL_op_desc, i32 0, i64 351), align 8
  store i8* %4, i8** %retval
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i64, i64* %index, align 8
  %call = call %struct.sv* @Perl_newSViv(i64 %5)
  %call1 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call)
  store %struct.sv* %call1, %struct.sv** %keysv, align 8
  %6 = load %struct.hv*, %struct.hv** @PL_custom_op_descs, align 8
  %7 = load %struct.sv*, %struct.sv** %keysv, align 8
  %call2 = call %struct.he* @Perl_hv_fetch_ent(%struct.hv* %6, %struct.sv* %7, i32 0, i32 0)
  store %struct.he* %call2, %struct.he** %he, align 8
  %8 = load %struct.he*, %struct.he** %he, align 8
  %tobool3 = icmp ne %struct.he* %8, null
  br i1 %tobool3, label %if.end.5, label %if.then.4

if.then.4:                                        ; preds = %if.end
  %9 = load i8*, i8** getelementptr inbounds ([0 x i8*], [0 x i8*]* @PL_op_desc, i32 0, i64 351), align 8
  store i8* %9, i8** %retval
  br label %return

if.end.5:                                         ; preds = %if.end
  %10 = load %struct.he*, %struct.he** %he, align 8
  %hent_val = getelementptr inbounds %struct.he, %struct.he* %10, i32 0, i32 2
  %11 = load %struct.sv*, %struct.sv** %hent_val, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %11, i32 0, i32 2
  %12 = load i32, i32* %sv_flags, align 4
  %and = and i32 %12, 262144
  %cmp = icmp eq i32 %and, 262144
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.5
  %13 = load %struct.he*, %struct.he** %he, align 8
  %hent_val6 = getelementptr inbounds %struct.he, %struct.he* %13, i32 0, i32 2
  %14 = load %struct.sv*, %struct.sv** %hent_val6, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %14, i32 0, i32 0
  %15 = load i8*, i8** %sv_any, align 8
  %16 = bitcast i8* %15 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %16, i32 0, i32 0
  %17 = load i8*, i8** %xpv_pv, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end.5
  %18 = load %struct.he*, %struct.he** %he, align 8
  %hent_val7 = getelementptr inbounds %struct.he, %struct.he* %18, i32 0, i32 2
  %19 = load %struct.sv*, %struct.sv** %hent_val7, align 8
  %call8 = call i8* @Perl_sv_2pv_nolen(%struct.sv* %19)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %17, %cond.true ], [ %call8, %cond.false ]
  store i8* %cond, i8** %retval
  br label %return

return:                                           ; preds = %cond.end, %if.then.4, %if.then
  %20 = load i8*, i8** %retval
  ret i8* %20
}

; Function Attrs: nounwind uwtable
define internal void @S_no_bareword_allowed(%struct.op* %o) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %1 = bitcast %struct.op* %0 to %struct.svop*
  %op_sv = getelementptr inbounds %struct.svop, %struct.svop* %1, i32 0, i32 8
  %2 = load %struct.sv*, %struct.sv** %op_sv, align 8
  %call = call %struct.sv* (i8*, ...) @Perl_mess(i8* getelementptr inbounds ([53 x i8], [53 x i8]* @.str.140, i32 0, i32 0), %struct.sv* %2)
  call void @Perl_qerror(%struct.sv* %call)
  ret void
}

declare double @Perl_sv_2nv(%struct.sv*) #1

declare i32 @strncmp(i8*, i8*, i64) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_listkids(%struct.op* %o) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  %kid = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %tobool = icmp ne %struct.op* %0, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 6
  %2 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 4
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %3 = load %struct.op*, %struct.op** %o.addr, align 8
  %4 = bitcast %struct.op* %3 to %struct.listop*
  %op_first = getelementptr inbounds %struct.listop, %struct.listop* %4, i32 0, i32 8
  %5 = load %struct.op*, %struct.op** %op_first, align 8
  store %struct.op* %5, %struct.op** %kid, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %6 = load %struct.op*, %struct.op** %kid, align 8
  %tobool2 = icmp ne %struct.op* %6, null
  br i1 %tobool2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load %struct.op*, %struct.op** %kid, align 8
  %call = call %struct.op* @Perl_list(%struct.op* %7)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %8 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %8, i32 0, i32 1
  %9 = load %struct.op*, %struct.op** %op_sibling, align 8
  store %struct.op* %9, %struct.op** %kid, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end

if.end:                                           ; preds = %for.end, %land.lhs.true, %entry
  %10 = load %struct.op*, %struct.op** %o.addr, align 8
  ret %struct.op* %10
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_list(%struct.op* %o) #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %o.addr = alloca %struct.op*, align 8
  %kid = alloca %struct.op*, align 8
  %tmp = alloca %struct.cop*, align 8
  %tmp74 = alloca %struct.cop*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %tobool = icmp ne %struct.op* %0, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 6
  %2 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 3
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %if.then, label %lor.lhs.false.2

lor.lhs.false.2:                                  ; preds = %lor.lhs.false
  %3 = load i32, i32* @PL_error_count, align 4
  %tobool3 = icmp ne i32 %3, 0
  br i1 %tobool3, label %if.then, label %lor.lhs.false.4

lor.lhs.false.4:                                  ; preds = %lor.lhs.false.2
  %4 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %4, i32 0, i32 4
  %5 = load i16, i16* %op_type, align 2
  %conv5 = zext i16 %5 to i32
  %cmp = icmp eq i32 %conv5, 184
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false.4, %lor.lhs.false.2, %lor.lhs.false, %entry
  %6 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %6, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %lor.lhs.false.4
  %7 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %7, i32 0, i32 7
  %8 = load i8, i8* %op_private, align 1
  %conv7 = zext i8 %8 to i32
  %and8 = and i32 %conv7, 16
  %tobool9 = icmp ne i32 %and8, 0
  br i1 %tobool9, label %land.lhs.true, label %if.end.14

land.lhs.true:                                    ; preds = %if.end
  %9 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type10 = getelementptr inbounds %struct.op, %struct.op* %9, i32 0, i32 4
  %10 = load i16, i16* %op_type10, align 2
  %idxprom = zext i16 %10 to i64
  %arrayidx = getelementptr inbounds [0 x i32], [0 x i32]* @PL_opargs, i32 0, i64 %idxprom
  %11 = load i32, i32* %arrayidx, align 4
  %and11 = and i32 %11, 256
  %tobool12 = icmp ne i32 %and11, 0
  br i1 %tobool12, label %if.then.13, label %if.end.14

if.then.13:                                       ; preds = %land.lhs.true
  %12 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %12, %struct.op** %retval
  br label %return

if.end.14:                                        ; preds = %land.lhs.true, %if.end
  %13 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags15 = getelementptr inbounds %struct.op, %struct.op* %13, i32 0, i32 6
  %14 = load i8, i8* %op_flags15, align 1
  %conv16 = zext i8 %14 to i32
  %and17 = and i32 %conv16, -4
  %or = or i32 %and17, 3
  %conv18 = trunc i32 %or to i8
  %15 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags19 = getelementptr inbounds %struct.op, %struct.op* %15, i32 0, i32 6
  store i8 %conv18, i8* %op_flags19, align 1
  %16 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type20 = getelementptr inbounds %struct.op, %struct.op* %16, i32 0, i32 4
  %17 = load i16, i16* %op_type20, align 2
  %conv21 = zext i16 %17 to i32
  switch i32 %conv21, label %sw.default [
    i32 158, label %sw.bb
    i32 61, label %sw.bb
    i32 160, label %sw.bb.22
    i32 159, label %sw.bb.22
    i32 162, label %sw.bb.22
    i32 31, label %sw.bb.27
    i32 32, label %sw.bb.27
    i32 33, label %sw.bb.27
    i32 0, label %sw.bb.27
    i32 141, label %sw.bb.46
    i32 178, label %sw.bb.48
    i32 314, label %sw.bb.48
    i32 179, label %sw.bb.59
    i32 173, label %sw.bb.59
    i32 309, label %sw.bb.75
  ]

sw.bb:                                            ; preds = %if.end.14, %if.end.14
  %18 = load %struct.op*, %struct.op** %o.addr, align 8
  %19 = bitcast %struct.op* %18 to %struct.binop*
  %op_first = getelementptr inbounds %struct.binop, %struct.binop* %19, i32 0, i32 8
  %20 = load %struct.op*, %struct.op** %op_first, align 8
  %call = call %struct.op* @Perl_list(%struct.op* %20)
  br label %sw.epilog

sw.bb.22:                                         ; preds = %if.end.14, %if.end.14, %if.end.14
  %21 = load %struct.op*, %struct.op** %o.addr, align 8
  %22 = bitcast %struct.op* %21 to %struct.unop*
  %op_first23 = getelementptr inbounds %struct.unop, %struct.unop* %22, i32 0, i32 8
  %23 = load %struct.op*, %struct.op** %op_first23, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %23, i32 0, i32 1
  %24 = load %struct.op*, %struct.op** %op_sibling, align 8
  store %struct.op* %24, %struct.op** %kid, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %sw.bb.22
  %25 = load %struct.op*, %struct.op** %kid, align 8
  %tobool24 = icmp ne %struct.op* %25, null
  br i1 %tobool24, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %26 = load %struct.op*, %struct.op** %kid, align 8
  %call25 = call %struct.op* @Perl_list(%struct.op* %26)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %27 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling26 = getelementptr inbounds %struct.op, %struct.op* %27, i32 0, i32 1
  %28 = load %struct.op*, %struct.op** %op_sibling26, align 8
  store %struct.op* %28, %struct.op** %kid, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %sw.epilog

sw.default:                                       ; preds = %if.end.14
  br label %sw.bb.27

sw.bb.27:                                         ; preds = %if.end.14, %if.end.14, %if.end.14, %if.end.14, %sw.default
  %29 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags28 = getelementptr inbounds %struct.op, %struct.op* %29, i32 0, i32 6
  %30 = load i8, i8* %op_flags28, align 1
  %conv29 = zext i8 %30 to i32
  %and30 = and i32 %conv29, 4
  %tobool31 = icmp ne i32 %and30, 0
  br i1 %tobool31, label %if.end.33, label %if.then.32

if.then.32:                                       ; preds = %sw.bb.27
  br label %sw.epilog

if.end.33:                                        ; preds = %sw.bb.27
  %31 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %31, i32 0, i32 0
  %32 = load %struct.op*, %struct.op** %op_next, align 8
  %tobool34 = icmp ne %struct.op* %32, null
  br i1 %tobool34, label %if.end.45, label %land.lhs.true.35

land.lhs.true.35:                                 ; preds = %if.end.33
  %33 = load %struct.op*, %struct.op** %o.addr, align 8
  %34 = bitcast %struct.op* %33 to %struct.unop*
  %op_first36 = getelementptr inbounds %struct.unop, %struct.unop* %34, i32 0, i32 8
  %35 = load %struct.op*, %struct.op** %op_first36, align 8
  %op_type37 = getelementptr inbounds %struct.op, %struct.op* %35, i32 0, i32 4
  %36 = load i16, i16* %op_type37, align 2
  %conv38 = zext i16 %36 to i32
  %cmp39 = icmp eq i32 %conv38, 158
  br i1 %cmp39, label %if.then.41, label %if.end.45

if.then.41:                                       ; preds = %land.lhs.true.35
  %37 = load %struct.op*, %struct.op** %o.addr, align 8
  %38 = bitcast %struct.op* %37 to %struct.binop*
  %op_first42 = getelementptr inbounds %struct.binop, %struct.binop* %38, i32 0, i32 8
  %39 = load %struct.op*, %struct.op** %op_first42, align 8
  %call43 = call %struct.op* @Perl_list(%struct.op* %39)
  %40 = load %struct.op*, %struct.op** %o.addr, align 8
  %call44 = call %struct.op* @Perl_gen_constant_list(%struct.op* %40)
  store %struct.op* %call44, %struct.op** %retval
  br label %return

if.end.45:                                        ; preds = %land.lhs.true.35, %if.end.33
  br label %sw.bb.46

sw.bb.46:                                         ; preds = %if.end.14, %if.end.45
  %41 = load %struct.op*, %struct.op** %o.addr, align 8
  %call47 = call %struct.op* @Perl_listkids(%struct.op* %41)
  br label %sw.epilog

sw.bb.48:                                         ; preds = %if.end.14, %if.end.14
  %42 = load %struct.op*, %struct.op** %o.addr, align 8
  %43 = bitcast %struct.op* %42 to %struct.listop*
  %op_first49 = getelementptr inbounds %struct.listop, %struct.listop* %43, i32 0, i32 8
  %44 = load %struct.op*, %struct.op** %op_first49, align 8
  store %struct.op* %44, %struct.op** %kid, align 8
  %45 = load %struct.op*, %struct.op** %kid, align 8
  %call50 = call %struct.op* @Perl_list(%struct.op* %45)
  br label %while.cond

while.cond:                                       ; preds = %if.end.58, %sw.bb.48
  %46 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling51 = getelementptr inbounds %struct.op, %struct.op* %46, i32 0, i32 1
  %47 = load %struct.op*, %struct.op** %op_sibling51, align 8
  store %struct.op* %47, %struct.op** %kid, align 8
  %tobool52 = icmp ne %struct.op* %47, null
  br i1 %tobool52, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %48 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling53 = getelementptr inbounds %struct.op, %struct.op* %48, i32 0, i32 1
  %49 = load %struct.op*, %struct.op** %op_sibling53, align 8
  %tobool54 = icmp ne %struct.op* %49, null
  br i1 %tobool54, label %if.then.55, label %if.else

if.then.55:                                       ; preds = %while.body
  %50 = load %struct.op*, %struct.op** %kid, align 8
  %call56 = call %struct.op* @Perl_scalarvoid(%struct.op* %50)
  br label %if.end.58

if.else:                                          ; preds = %while.body
  %51 = load %struct.op*, %struct.op** %kid, align 8
  %call57 = call %struct.op* @Perl_list(%struct.op* %51)
  br label %if.end.58

if.end.58:                                        ; preds = %if.else, %if.then.55
  br label %while.cond

while.end:                                        ; preds = %while.cond
  store volatile %struct.cop* @PL_compiling, %struct.cop** @PL_curcop, align 8
  store %struct.cop* @PL_compiling, %struct.cop** %tmp
  %52 = load %struct.cop*, %struct.cop** %tmp
  br label %sw.epilog

sw.bb.59:                                         ; preds = %if.end.14, %if.end.14
  %53 = load %struct.op*, %struct.op** %o.addr, align 8
  %54 = bitcast %struct.op* %53 to %struct.listop*
  %op_first60 = getelementptr inbounds %struct.listop, %struct.listop* %54, i32 0, i32 8
  %55 = load %struct.op*, %struct.op** %op_first60, align 8
  store %struct.op* %55, %struct.op** %kid, align 8
  br label %for.cond.61

for.cond.61:                                      ; preds = %for.inc.71, %sw.bb.59
  %56 = load %struct.op*, %struct.op** %kid, align 8
  %tobool62 = icmp ne %struct.op* %56, null
  br i1 %tobool62, label %for.body.63, label %for.end.73

for.body.63:                                      ; preds = %for.cond.61
  %57 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling64 = getelementptr inbounds %struct.op, %struct.op* %57, i32 0, i32 1
  %58 = load %struct.op*, %struct.op** %op_sibling64, align 8
  %tobool65 = icmp ne %struct.op* %58, null
  br i1 %tobool65, label %if.then.66, label %if.else.68

if.then.66:                                       ; preds = %for.body.63
  %59 = load %struct.op*, %struct.op** %kid, align 8
  %call67 = call %struct.op* @Perl_scalarvoid(%struct.op* %59)
  br label %if.end.70

if.else.68:                                       ; preds = %for.body.63
  %60 = load %struct.op*, %struct.op** %kid, align 8
  %call69 = call %struct.op* @Perl_list(%struct.op* %60)
  br label %if.end.70

if.end.70:                                        ; preds = %if.else.68, %if.then.66
  br label %for.inc.71

for.inc.71:                                       ; preds = %if.end.70
  %61 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling72 = getelementptr inbounds %struct.op, %struct.op* %61, i32 0, i32 1
  %62 = load %struct.op*, %struct.op** %op_sibling72, align 8
  store %struct.op* %62, %struct.op** %kid, align 8
  br label %for.cond.61

for.end.73:                                       ; preds = %for.cond.61
  store volatile %struct.cop* @PL_compiling, %struct.cop** @PL_curcop, align 8
  store %struct.cop* @PL_compiling, %struct.cop** %tmp74
  %63 = load %struct.cop*, %struct.cop** %tmp74
  br label %sw.epilog

sw.bb.75:                                         ; preds = %if.end.14
  %64 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags76 = getelementptr inbounds %struct.op, %struct.op* %64, i32 0, i32 6
  %65 = load i8, i8* %op_flags76, align 1
  %conv77 = zext i8 %65 to i32
  %and78 = and i32 %conv77, -4
  %conv79 = trunc i32 %and78 to i8
  store i8 %conv79, i8* %op_flags76, align 1
  %66 = load %struct.op*, %struct.op** %o.addr, align 8
  %call80 = call %struct.op* @Perl_scalar(%struct.op* %66)
  store %struct.op* %call80, %struct.op** %retval
  br label %return

sw.epilog:                                        ; preds = %for.end.73, %while.end, %sw.bb.46, %if.then.32, %for.end, %sw.bb
  %67 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %67, %struct.op** %retval
  br label %return

return:                                           ; preds = %sw.epilog, %sw.bb.75, %if.then.41, %if.then.13, %if.then
  %68 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %68
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_gen_constant_list(%struct.op* %o) #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %o.addr = alloca %struct.op*, align 8
  %curop = alloca %struct.op*, align 8
  %oldtmps_floor = alloca i32, align 4
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load i32, i32* @PL_tmps_floor, align 4
  store i32 %0, i32* %oldtmps_floor, align 4
  %1 = load %struct.op*, %struct.op** %o.addr, align 8
  %call = call %struct.op* @Perl_list(%struct.op* %1)
  %2 = load i32, i32* @PL_error_count, align 4
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %3, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %entry
  %4 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %4, i32 0, i32 0
  %5 = load %struct.op*, %struct.op** %op_next, align 8
  %tobool1 = icmp ne %struct.op* %5, null
  br i1 %tobool1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %6 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next2 = getelementptr inbounds %struct.op, %struct.op* %6, i32 0, i32 0
  %7 = load %struct.op*, %struct.op** %op_next2, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %8 = load %struct.op*, %struct.op** %o.addr, align 8
  %call3 = call %struct.op* @Perl_linklist(%struct.op* %8)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.op* [ %7, %cond.true ], [ %call3, %cond.false ]
  store %struct.op* %cond, %struct.op** %curop, align 8
  store %struct.op* %cond, %struct.op** @PL_op, align 8
  %9 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next4 = getelementptr inbounds %struct.op, %struct.op* %9, i32 0, i32 0
  store %struct.op* null, %struct.op** %op_next4, align 8
  %10 = load void (%struct.op*)*, void (%struct.op*)** @PL_peepp, align 8
  %11 = load %struct.op*, %struct.op** %curop, align 8
  call void %10(%struct.op* %11)
  %call5 = call %struct.op* @Perl_pp_pushmark()
  %12 = load i32 ()*, i32 ()** @PL_runops, align 8
  %call6 = call i32 %12()
  %13 = load %struct.op*, %struct.op** %curop, align 8
  store %struct.op* %13, %struct.op** @PL_op, align 8
  %call7 = call %struct.op* @Perl_pp_anonlist()
  %14 = load i32, i32* %oldtmps_floor, align 4
  store i32 %14, i32* @PL_tmps_floor, align 4
  %15 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %15, i32 0, i32 4
  store i16 125, i16* %op_type, align 2
  %16 = load %struct.op* ()*, %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 125), align 8
  %17 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_ppaddr = getelementptr inbounds %struct.op, %struct.op* %17, i32 0, i32 2
  store %struct.op* ()* %16, %struct.op* ()** %op_ppaddr, align 8
  %18 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %18, i32 0, i32 6
  %19 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %19 to i32
  %and = and i32 %conv, -17
  %conv8 = trunc i32 %and to i8
  store i8 %conv8, i8* %op_flags, align 1
  %20 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags9 = getelementptr inbounds %struct.op, %struct.op* %20, i32 0, i32 6
  %21 = load i8, i8* %op_flags9, align 1
  %conv10 = zext i8 %21 to i32
  %or = or i32 %conv10, 8
  %conv11 = trunc i32 %or to i8
  store i8 %conv11, i8* %op_flags9, align 1
  %22 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_seq = getelementptr inbounds %struct.op, %struct.op* %22, i32 0, i32 5
  store i16 0, i16* %op_seq, align 2
  %23 = load %struct.op*, %struct.op** %o.addr, align 8
  %24 = bitcast %struct.op* %23 to %struct.unop*
  %op_first = getelementptr inbounds %struct.unop, %struct.unop* %24, i32 0, i32 8
  %25 = load %struct.op*, %struct.op** %op_first, align 8
  store %struct.op* %25, %struct.op** %curop, align 8
  %26 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %26, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** @PL_stack_sp, align 8
  %27 = load %struct.sv*, %struct.sv** %26, align 8
  store %struct.sv* %27, %struct.sv** @PL_Sv, align 8
  %28 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %tobool12 = icmp ne %struct.sv* %28, null
  br i1 %tobool12, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %cond.end
  %29 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_refcnt = getelementptr inbounds %struct.sv, %struct.sv* %29, i32 0, i32 1
  %30 = load i32, i32* %sv_refcnt, align 4
  %inc = add i32 %30, 1
  store i32 %inc, i32* %sv_refcnt, align 4
  %tobool13 = icmp ne i32 %inc, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %cond.end
  %31 = phi i1 [ false, %cond.end ], [ %tobool13, %land.rhs ]
  %land.ext = zext i1 %31 to i32
  %32 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call14 = call %struct.op* @Perl_newSVOP(i32 5, i32 0, %struct.sv* %32)
  %33 = load %struct.op*, %struct.op** %o.addr, align 8
  %34 = bitcast %struct.op* %33 to %struct.unop*
  %op_first15 = getelementptr inbounds %struct.unop, %struct.unop* %34, i32 0, i32 8
  store %struct.op* %call14, %struct.op** %op_first15, align 8
  %35 = load %struct.op*, %struct.op** %curop, align 8
  call void @Perl_op_free(%struct.op* %35)
  %36 = load %struct.op*, %struct.op** %o.addr, align 8
  %call16 = call %struct.op* @Perl_linklist(%struct.op* %36)
  %37 = load %struct.op*, %struct.op** %o.addr, align 8
  %call17 = call %struct.op* @Perl_list(%struct.op* %37)
  store %struct.op* %call17, %struct.op** %retval
  br label %return

return:                                           ; preds = %land.end, %if.then
  %38 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %38
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_scalarseq(%struct.op* %o) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  %kid = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %tobool = icmp ne %struct.op* %0, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 4
  %2 = load i16, i16* %op_type, align 2
  %conv = zext i16 %2 to i32
  %cmp = icmp eq i32 %conv, 173
  br i1 %cmp, label %if.then.16, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %3 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type2 = getelementptr inbounds %struct.op, %struct.op* %3, i32 0, i32 4
  %4 = load i16, i16* %op_type2, align 2
  %conv3 = zext i16 %4 to i32
  %cmp4 = icmp eq i32 %conv3, 179
  br i1 %cmp4, label %if.then.16, label %lor.lhs.false.6

lor.lhs.false.6:                                  ; preds = %lor.lhs.false
  %5 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type7 = getelementptr inbounds %struct.op, %struct.op* %5, i32 0, i32 4
  %6 = load i16, i16* %op_type7, align 2
  %conv8 = zext i16 %6 to i32
  %cmp9 = icmp eq i32 %conv8, 178
  br i1 %cmp9, label %if.then.16, label %lor.lhs.false.11

lor.lhs.false.11:                                 ; preds = %lor.lhs.false.6
  %7 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type12 = getelementptr inbounds %struct.op, %struct.op* %7, i32 0, i32 4
  %8 = load i16, i16* %op_type12, align 2
  %conv13 = zext i16 %8 to i32
  %cmp14 = icmp eq i32 %conv13, 314
  br i1 %cmp14, label %if.then.16, label %if.end.21

if.then.16:                                       ; preds = %lor.lhs.false.11, %lor.lhs.false.6, %lor.lhs.false, %if.then
  %9 = load %struct.op*, %struct.op** %o.addr, align 8
  %10 = bitcast %struct.op* %9 to %struct.listop*
  %op_first = getelementptr inbounds %struct.listop, %struct.listop* %10, i32 0, i32 8
  %11 = load %struct.op*, %struct.op** %op_first, align 8
  store %struct.op* %11, %struct.op** %kid, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then.16
  %12 = load %struct.op*, %struct.op** %kid, align 8
  %tobool17 = icmp ne %struct.op* %12, null
  br i1 %tobool17, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %13 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %13, i32 0, i32 1
  %14 = load %struct.op*, %struct.op** %op_sibling, align 8
  %tobool18 = icmp ne %struct.op* %14, null
  br i1 %tobool18, label %if.then.19, label %if.end

if.then.19:                                       ; preds = %for.body
  %15 = load %struct.op*, %struct.op** %kid, align 8
  %call = call %struct.op* @Perl_scalarvoid(%struct.op* %15)
  br label %if.end

if.end:                                           ; preds = %if.then.19, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %16 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling20 = getelementptr inbounds %struct.op, %struct.op* %16, i32 0, i32 1
  %17 = load %struct.op*, %struct.op** %op_sibling20, align 8
  store %struct.op* %17, %struct.op** %kid, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store volatile %struct.cop* @PL_compiling, %struct.cop** @PL_curcop, align 8
  br label %if.end.21

if.end.21:                                        ; preds = %for.end, %lor.lhs.false.11
  %18 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %18, i32 0, i32 6
  %19 = load i8, i8* %op_flags, align 1
  %conv22 = zext i8 %19 to i32
  %and = and i32 %conv22, -9
  %conv23 = trunc i32 %and to i8
  store i8 %conv23, i8* %op_flags, align 1
  %20 = load i32, i32* @PL_hints, align 4
  %and24 = and i32 %20, 256
  %tobool25 = icmp ne i32 %and24, 0
  br i1 %tobool25, label %if.then.26, label %if.end.30

if.then.26:                                       ; preds = %if.end.21
  %21 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags27 = getelementptr inbounds %struct.op, %struct.op* %21, i32 0, i32 6
  %22 = load i8, i8* %op_flags27, align 1
  %conv28 = zext i8 %22 to i32
  %or = or i32 %conv28, 8
  %conv29 = trunc i32 %or to i8
  store i8 %conv29, i8* %op_flags27, align 1
  br label %if.end.30

if.end.30:                                        ; preds = %if.then.26, %if.end.21
  br label %if.end.32

if.else:                                          ; preds = %entry
  %call31 = call %struct.op* @Perl_newOP(i32 1, i32 0)
  store %struct.op* %call31, %struct.op** %o.addr, align 8
  br label %if.end.32

if.end.32:                                        ; preds = %if.else, %if.end.30
  %23 = load %struct.op*, %struct.op** %o.addr, align 8
  ret %struct.op* %23
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newOP(i32 %type, i32 %flags) #0 {
entry:
  %type.addr = alloca i32, align 4
  %flags.addr = alloca i32, align 4
  %o = alloca %struct.op*, align 8
  store i32 %type, i32* %type.addr, align 4
  store i32 %flags, i32* %flags.addr, align 4
  %call = call i8* @Perl_safesysmalloc(i64 40)
  %0 = bitcast i8* %call to %struct.op*
  store %struct.op* %0, %struct.op** %o, align 8
  %1 = load %struct.op*, %struct.op** %o, align 8
  %2 = bitcast %struct.op* %1 to i8*
  call void @llvm.memset.p0i8.i64(i8* %2, i8 0, i64 40, i32 1, i1 false)
  %3 = load i32, i32* %type.addr, align 4
  %conv = trunc i32 %3 to i16
  %4 = load %struct.op*, %struct.op** %o, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %4, i32 0, i32 4
  store i16 %conv, i16* %op_type, align 2
  %5 = load i32, i32* %type.addr, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds [0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 %idxprom
  %6 = load %struct.op* ()*, %struct.op* ()** %arrayidx, align 8
  %7 = load %struct.op*, %struct.op** %o, align 8
  %op_ppaddr = getelementptr inbounds %struct.op, %struct.op* %7, i32 0, i32 2
  store %struct.op* ()* %6, %struct.op* ()** %op_ppaddr, align 8
  %8 = load i32, i32* %flags.addr, align 4
  %conv1 = trunc i32 %8 to i8
  %9 = load %struct.op*, %struct.op** %o, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %9, i32 0, i32 6
  store i8 %conv1, i8* %op_flags, align 1
  %10 = load %struct.op*, %struct.op** %o, align 8
  %11 = load %struct.op*, %struct.op** %o, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %11, i32 0, i32 0
  store %struct.op* %10, %struct.op** %op_next, align 8
  %12 = load i32, i32* %flags.addr, align 4
  %shr = ashr i32 %12, 8
  %or = or i32 0, %shr
  %conv2 = trunc i32 %or to i8
  %13 = load %struct.op*, %struct.op** %o, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %13, i32 0, i32 7
  store i8 %conv2, i8* %op_private, align 1
  %14 = load i32, i32* %type.addr, align 4
  %idxprom3 = sext i32 %14 to i64
  %arrayidx4 = getelementptr inbounds [0 x i32], [0 x i32]* @PL_opargs, i32 0, i64 %idxprom3
  %15 = load i32, i32* %arrayidx4, align 4
  %and = and i32 %15, 4
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %16 = load %struct.op*, %struct.op** %o, align 8
  %call5 = call %struct.op* @Perl_scalar(%struct.op* %16)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %17 = load i32, i32* %type.addr, align 4
  %idxprom6 = sext i32 %17 to i64
  %arrayidx7 = getelementptr inbounds [0 x i32], [0 x i32]* @PL_opargs, i32 0, i64 %idxprom6
  %18 = load i32, i32* %arrayidx7, align 4
  %and8 = and i32 %18, 8
  %tobool9 = icmp ne i32 %and8, 0
  br i1 %tobool9, label %if.then.10, label %if.end.12

if.then.10:                                       ; preds = %if.end
  %19 = load i32, i32* %type.addr, align 4
  %call11 = call i64 @Perl_pad_alloc(i32 %19, i32 512)
  %20 = load %struct.op*, %struct.op** %o, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %20, i32 0, i32 3
  store i64 %call11, i64* %op_targ, align 8
  br label %if.end.12

if.end.12:                                        ; preds = %if.then.10, %if.end
  %21 = load i8*, i8** @PL_op_mask, align 8
  %tobool13 = icmp ne i8* %21, null
  br i1 %tobool13, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %if.end.12
  %22 = load i32, i32* %type.addr, align 4
  %idxprom14 = sext i32 %22 to i64
  %23 = load i8*, i8** @PL_op_mask, align 8
  %arrayidx15 = getelementptr inbounds i8, i8* %23, i64 %idxprom14
  %24 = load i8, i8* %arrayidx15, align 1
  %conv16 = sext i8 %24 to i32
  %tobool17 = icmp ne i32 %conv16, 0
  br i1 %tobool17, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true
  %25 = load %struct.op*, %struct.op** %o, align 8
  call void @Perl_op_free(%struct.op* %25)
  %26 = load i32, i32* %type.addr, align 4
  %idxprom18 = sext i32 %26 to i64
  %arrayidx19 = getelementptr inbounds [0 x i8*], [0 x i8*]* @PL_op_desc, i32 0, i64 %idxprom18
  %27 = load i8*, i8** %arrayidx19, align 8
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.33, i32 0, i32 0), i8* %27)
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %if.end.12
  %28 = load i32, i32* %type.addr, align 4
  %idxprom20 = sext i32 %28 to i64
  %arrayidx21 = getelementptr inbounds [0 x %struct.op* (%struct.op*)*], [0 x %struct.op* (%struct.op*)*]* @PL_check, i32 0, i64 %idxprom20
  %29 = load %struct.op* (%struct.op*)*, %struct.op* (%struct.op*)** %arrayidx21, align 8
  %30 = load %struct.op*, %struct.op** %o, align 8
  %call22 = call %struct.op* %29(%struct.op* %30)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.op* [ null, %cond.true ], [ %call22, %cond.false ]
  ret %struct.op* %cond
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_mod(%struct.op* %o, i32 %type) #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %o.addr = alloca %struct.op*, align 8
  %type.addr = alloca i32, align 4
  %kid = alloca %struct.op*, align 8
  %kid81 = alloca %struct.op*, align 8
  %cv = alloca %struct.cv*, align 8
  %okid = alloca %struct.op*, align 8
  %newop = alloca %struct.unop*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  store i32 %type, i32* %type.addr, align 4
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %tobool = icmp ne %struct.op* %0, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* @PL_error_count, align 4
  %tobool1 = icmp ne i32 %1, 0
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %2 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %2, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %3 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %3, i32 0, i32 7
  %4 = load i8, i8* %op_private, align 1
  %conv = zext i8 %4 to i32
  %and = and i32 %conv, 16
  %tobool2 = icmp ne i32 %and, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end.6

land.lhs.true:                                    ; preds = %if.end
  %5 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %5, i32 0, i32 4
  %6 = load i16, i16* %op_type, align 2
  %idxprom = zext i16 %6 to i64
  %arrayidx = getelementptr inbounds [0 x i32], [0 x i32]* @PL_opargs, i32 0, i64 %idxprom
  %7 = load i32, i32* %arrayidx, align 4
  %and3 = and i32 %7, 256
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %if.then.5, label %if.end.6

if.then.5:                                        ; preds = %land.lhs.true
  %8 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %8, %struct.op** %retval
  br label %return

if.end.6:                                         ; preds = %land.lhs.true, %if.end
  %9 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type7 = getelementptr inbounds %struct.op, %struct.op* %9, i32 0, i32 4
  %10 = load i16, i16* %op_type7, align 2
  %conv8 = zext i16 %10 to i32
  switch i32 %conv8, label %sw.default [
    i32 43, label %sw.bb
    i32 5, label %sw.bb.9
    i32 1, label %sw.bb.37
    i32 166, label %sw.bb.43
    i32 46, label %sw.bb.260
    i32 48, label %sw.bb.260
    i32 54, label %sw.bb.260
    i32 55, label %sw.bb.260
    i32 57, label %sw.bb.260
    i32 59, label %sw.bb.260
    i32 61, label %sw.bb.260
    i32 62, label %sw.bb.260
    i32 64, label %sw.bb.260
    i32 66, label %sw.bb.260
    i32 68, label %sw.bb.260
    i32 69, label %sw.bb.260
    i32 91, label %sw.bb.260
    i32 92, label %sw.bb.260
    i32 93, label %sw.bb.260
    i32 56, label %sw.bb.260
    i32 58, label %sw.bb.260
    i32 60, label %sw.bb.260
    i32 63, label %sw.bb.260
    i32 65, label %sw.bb.260
    i32 162, label %sw.bb.268
    i32 125, label %sw.bb.274
    i32 134, label %sw.bb.274
    i32 14, label %sw.bb.284
    i32 128, label %sw.bb.293
    i32 136, label %sw.bb.293
    i32 37, label %sw.bb.302
    i32 174, label %sw.bb.302
    i32 175, label %sw.bb.302
    i32 15, label %sw.bb.303
    i32 7, label %sw.bb.308
    i32 16, label %sw.bb.308
    i32 36, label %sw.bb.310
    i32 163, label %sw.bb.310
    i32 164, label %sw.bb.310
    i32 126, label %sw.bb.310
    i32 10, label %sw.bb.312
    i32 11, label %sw.bb.312
    i32 9, label %sw.bb.334
    i32 3, label %sw.bb.358
    i32 131, label %sw.bb.359
    i32 111, label %sw.bb.364
    i32 45, label %sw.bb.371
    i32 112, label %sw.bb.371
    i32 127, label %sw.bb.394
    i32 135, label %sw.bb.394
    i32 179, label %sw.bb.421
    i32 178, label %sw.bb.421
    i32 177, label %sw.bb.421
    i32 173, label %sw.bb.421
    i32 0, label %sw.bb.429
    i32 141, label %sw.bb.450
    i32 184, label %sw.bb.459
  ]

sw.bb:                                            ; preds = %if.end.6
  %11 = load i32, i32* @PL_modcount, align 4
  %inc = add nsw i32 %11, 1
  store i32 %inc, i32* @PL_modcount, align 4
  %12 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %12, %struct.op** %retval
  br label %return

sw.bb.9:                                          ; preds = %if.end.6
  %13 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private10 = getelementptr inbounds %struct.op, %struct.op* %13, i32 0, i32 7
  %14 = load i8, i8* %op_private10, align 1
  %conv11 = zext i8 %14 to i32
  %and12 = and i32 %conv11, 32
  %tobool13 = icmp ne i32 %and12, 0
  br i1 %tobool13, label %if.end.15, label %if.then.14

if.then.14:                                       ; preds = %sw.bb.9
  br label %nomod

if.end.15:                                        ; preds = %sw.bb.9
  %15 = load %struct.op*, %struct.op** @PL_eval_start, align 8
  %tobool16 = icmp ne %struct.op* %15, null
  br i1 %tobool16, label %land.lhs.true.17, label %if.else

land.lhs.true.17:                                 ; preds = %if.end.15
  %16 = load %struct.op*, %struct.op** @PL_eval_start, align 8
  %op_type18 = getelementptr inbounds %struct.op, %struct.op* %16, i32 0, i32 4
  %17 = load i16, i16* %op_type18, align 2
  %conv19 = zext i16 %17 to i32
  %cmp = icmp eq i32 %conv19, 5
  br i1 %cmp, label %if.then.21, label %if.else

if.then.21:                                       ; preds = %land.lhs.true.17
  %18 = load %struct.op*, %struct.op** @PL_eval_start, align 8
  %19 = bitcast %struct.op* %18 to %struct.svop*
  %op_sv = getelementptr inbounds %struct.svop, %struct.svop* %19, i32 0, i32 8
  %20 = load %struct.sv*, %struct.sv** %op_sv, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %20, i32 0, i32 2
  %21 = load i32, i32* %sv_flags, align 4
  %and22 = and i32 %21, 65536
  %tobool23 = icmp ne i32 %and22, 0
  br i1 %tobool23, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.21
  %22 = load %struct.op*, %struct.op** @PL_eval_start, align 8
  %23 = bitcast %struct.op* %22 to %struct.svop*
  %op_sv24 = getelementptr inbounds %struct.svop, %struct.svop* %23, i32 0, i32 8
  %24 = load %struct.sv*, %struct.sv** %op_sv24, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %24, i32 0, i32 0
  %25 = load i8*, i8** %sv_any, align 8
  %26 = bitcast i8* %25 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %26, i32 0, i32 3
  %27 = load i64, i64* %xiv_iv, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then.21
  %28 = load %struct.op*, %struct.op** @PL_eval_start, align 8
  %29 = bitcast %struct.op* %28 to %struct.svop*
  %op_sv25 = getelementptr inbounds %struct.svop, %struct.svop* %29, i32 0, i32 8
  %30 = load %struct.sv*, %struct.sv** %op_sv25, align 8
  %call = call i64 @Perl_sv_2iv(%struct.sv* %30)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %27, %cond.true ], [ %call, %cond.false ]
  %conv26 = trunc i64 %cond to i32
  store i32 %conv26, i32* getelementptr inbounds (%struct.cop, %struct.cop* @PL_compiling, i32 0, i32 12), align 4
  store %struct.op* null, %struct.op** @PL_eval_start, align 8
  br label %if.end.36

if.else:                                          ; preds = %land.lhs.true.17, %if.end.15
  %31 = load i32, i32* %type.addr, align 4
  %tobool27 = icmp ne i32 %31, 0
  br i1 %tobool27, label %if.else.29, label %if.then.28

if.then.28:                                       ; preds = %if.else
  call void @Perl_save_I32(i32* getelementptr inbounds (%struct.cop, %struct.cop* @PL_compiling, i32 0, i32 12))
  store i32 0, i32* getelementptr inbounds (%struct.cop, %struct.cop* @PL_compiling, i32 0, i32 12), align 4
  br label %if.end.35

if.else.29:                                       ; preds = %if.else
  %32 = load i32, i32* %type.addr, align 4
  %cmp30 = icmp eq i32 %32, 20
  br i1 %cmp30, label %if.then.32, label %if.else.33

if.then.32:                                       ; preds = %if.else.29
  br label %nomod

if.else.33:                                       ; preds = %if.else.29
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.14, i32 0, i32 0))
  br label %if.end.34

if.end.34:                                        ; preds = %if.else.33
  br label %if.end.35

if.end.35:                                        ; preds = %if.end.34, %if.then.28
  br label %if.end.36

if.end.36:                                        ; preds = %if.end.35, %cond.end
  br label %sw.epilog

sw.bb.37:                                         ; preds = %if.end.6
  %33 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %33, i32 0, i32 6
  %34 = load i8, i8* %op_flags, align 1
  %conv38 = zext i8 %34 to i32
  %and39 = and i32 %conv38, 8
  %tobool40 = icmp ne i32 %and39, 0
  br i1 %tobool40, label %if.then.41, label %if.end.42

if.then.41:                                       ; preds = %sw.bb.37
  br label %sw.epilog

if.end.42:                                        ; preds = %sw.bb.37
  br label %nomod

sw.bb.43:                                         ; preds = %if.end.6
  %35 = load i32, i32* %type.addr, align 4
  %cmp44 = icmp eq i32 %35, 43
  br i1 %cmp44, label %land.lhs.true.49, label %lor.lhs.false.46

lor.lhs.false.46:                                 ; preds = %sw.bb.43
  %36 = load i32, i32* %type.addr, align 4
  %cmp47 = icmp eq i32 %36, 20
  br i1 %cmp47, label %land.lhs.true.49, label %if.else.57

land.lhs.true.49:                                 ; preds = %lor.lhs.false.46, %sw.bb.43
  %37 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags50 = getelementptr inbounds %struct.op, %struct.op* %37, i32 0, i32 6
  %38 = load i8, i8* %op_flags50, align 1
  %conv51 = zext i8 %38 to i32
  %and52 = and i32 %conv51, 64
  %tobool53 = icmp ne i32 %and52, 0
  br i1 %tobool53, label %if.else.57, label %if.then.54

if.then.54:                                       ; preds = %land.lhs.true.49
  %39 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type55 = getelementptr inbounds %struct.op, %struct.op* %39, i32 0, i32 4
  store i16 17, i16* %op_type55, align 2
  %40 = load %struct.op* ()*, %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 17), align 8
  %41 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_ppaddr = getelementptr inbounds %struct.op, %struct.op* %41, i32 0, i32 2
  store %struct.op* ()* %40, %struct.op* ()** %op_ppaddr, align 8
  %42 = load %struct.op*, %struct.op** %o.addr, align 8
  %43 = bitcast %struct.op* %42 to %struct.unop*
  %op_first = getelementptr inbounds %struct.unop, %struct.unop* %43, i32 0, i32 8
  %44 = load %struct.op*, %struct.op** %op_first, align 8
  %45 = bitcast %struct.op* %44 to %struct.listop*
  %op_first56 = getelementptr inbounds %struct.listop, %struct.listop* %45, i32 0, i32 8
  %46 = load %struct.op*, %struct.op** %op_first56, align 8
  call void @Perl_op_null(%struct.op* %46)
  br label %sw.epilog

if.else.57:                                       ; preds = %land.lhs.true.49, %lor.lhs.false.46
  %47 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private58 = getelementptr inbounds %struct.op, %struct.op* %47, i32 0, i32 7
  %48 = load i8, i8* %op_private58, align 1
  %conv59 = zext i8 %48 to i32
  %and60 = and i32 %conv59, 64
  %tobool61 = icmp ne i32 %and60, 0
  br i1 %tobool61, label %if.then.62, label %if.else.63

if.then.62:                                       ; preds = %if.else.57
  %49 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %49, %struct.op** %retval
  br label %return

if.else.63:                                       ; preds = %if.else.57
  %50 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private64 = getelementptr inbounds %struct.op, %struct.op* %50, i32 0, i32 7
  %51 = load i8, i8* %op_private64, align 1
  %conv65 = zext i8 %51 to i32
  %or = or i32 %conv65, 128
  %conv66 = trunc i32 %or to i8
  store i8 %conv66, i8* %op_private64, align 1
  store i32 1073741823, i32* @PL_modcount, align 4
  %52 = load i32, i32* %type.addr, align 4
  %cmp67 = icmp eq i32 %52, 152
  br i1 %cmp67, label %if.then.75, label %lor.lhs.false.69

lor.lhs.false.69:                                 ; preds = %if.else.63
  %53 = load i32, i32* %type.addr, align 4
  %cmp70 = icmp eq i32 %53, 166
  br i1 %cmp70, label %if.then.75, label %lor.lhs.false.72

lor.lhs.false.72:                                 ; preds = %lor.lhs.false.69
  %54 = load i32, i32* %type.addr, align 4
  %cmp73 = icmp eq i32 %54, 20
  br i1 %cmp73, label %if.then.75, label %if.else.80

if.then.75:                                       ; preds = %lor.lhs.false.72, %lor.lhs.false.69, %if.else.63
  %55 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private76 = getelementptr inbounds %struct.op, %struct.op* %55, i32 0, i32 7
  %56 = load i8, i8* %op_private76, align 1
  %conv77 = zext i8 %56 to i32
  %or78 = or i32 %conv77, 4
  %conv79 = trunc i32 %or78 to i8
  store i8 %conv79, i8* %op_private76, align 1
  br label %sw.epilog

if.else.80:                                       ; preds = %lor.lhs.false.72
  %57 = load %struct.op*, %struct.op** %o.addr, align 8
  %58 = bitcast %struct.op* %57 to %struct.unop*
  %op_first82 = getelementptr inbounds %struct.unop, %struct.unop* %58, i32 0, i32 8
  %59 = load %struct.op*, %struct.op** %op_first82, align 8
  store %struct.op* %59, %struct.op** %kid81, align 8
  %60 = load %struct.op*, %struct.op** %kid81, align 8
  %op_type83 = getelementptr inbounds %struct.op, %struct.op* %60, i32 0, i32 4
  %61 = load i16, i16* %op_type83, align 2
  %conv84 = zext i16 %61 to i32
  %cmp85 = icmp eq i32 %conv84, 3
  br i1 %cmp85, label %if.then.87, label %if.end.88

if.then.87:                                       ; preds = %if.else.80
  br label %skip_kids

if.end.88:                                        ; preds = %if.else.80
  %62 = load %struct.op*, %struct.op** %kid81, align 8
  %op_type89 = getelementptr inbounds %struct.op, %struct.op* %62, i32 0, i32 4
  %63 = load i16, i16* %op_type89, align 2
  %conv90 = zext i16 %63 to i32
  %cmp91 = icmp ne i32 %conv90, 0
  br i1 %cmp91, label %if.then.96, label %lor.lhs.false.93

lor.lhs.false.93:                                 ; preds = %if.end.88
  %64 = load %struct.op*, %struct.op** %kid81, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %64, i32 0, i32 3
  %65 = load i64, i64* %op_targ, align 8
  %cmp94 = icmp ne i64 %65, 141
  br i1 %cmp94, label %if.then.96, label %if.end.100

if.then.96:                                       ; preds = %lor.lhs.false.93, %if.end.88
  %66 = load %struct.op*, %struct.op** %kid81, align 8
  %op_type97 = getelementptr inbounds %struct.op, %struct.op* %66, i32 0, i32 4
  %67 = load i16, i16* %op_type97, align 2
  %conv98 = zext i16 %67 to i64
  %68 = load %struct.op*, %struct.op** %kid81, align 8
  %op_targ99 = getelementptr inbounds %struct.op, %struct.op* %68, i32 0, i32 3
  %69 = load i64, i64* %op_targ99, align 8
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([58 x i8], [58 x i8]* @.str.15, i32 0, i32 0), i64 %conv98, i64 %69)
  br label %if.end.100

if.end.100:                                       ; preds = %if.then.96, %lor.lhs.false.93
  %70 = load %struct.op*, %struct.op** %kid81, align 8
  %71 = bitcast %struct.op* %70 to %struct.listop*
  %op_first101 = getelementptr inbounds %struct.listop, %struct.listop* %71, i32 0, i32 8
  %72 = load %struct.op*, %struct.op** %op_first101, align 8
  store %struct.op* %72, %struct.op** %kid81, align 8
  br label %skip_kids

skip_kids:                                        ; preds = %if.end.100, %if.then.87
  br label %while.cond

while.cond:                                       ; preds = %while.body, %skip_kids
  %73 = load %struct.op*, %struct.op** %kid81, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %73, i32 0, i32 1
  %74 = load %struct.op*, %struct.op** %op_sibling, align 8
  %tobool102 = icmp ne %struct.op* %74, null
  br i1 %tobool102, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %75 = load %struct.op*, %struct.op** %kid81, align 8
  %op_sibling103 = getelementptr inbounds %struct.op, %struct.op* %75, i32 0, i32 1
  %76 = load %struct.op*, %struct.op** %op_sibling103, align 8
  store %struct.op* %76, %struct.op** %kid81, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %77 = load %struct.op*, %struct.op** %kid81, align 8
  %op_type104 = getelementptr inbounds %struct.op, %struct.op* %77, i32 0, i32 4
  %78 = load i16, i16* %op_type104, align 2
  %conv105 = zext i16 %78 to i32
  %cmp106 = icmp eq i32 %conv105, 0
  br i1 %cmp106, label %land.lhs.true.108, label %if.then.112

land.lhs.true.108:                                ; preds = %while.end
  %79 = load %struct.op*, %struct.op** %kid81, align 8
  %op_targ109 = getelementptr inbounds %struct.op, %struct.op* %79, i32 0, i32 3
  %80 = load i64, i64* %op_targ109, align 8
  %cmp110 = icmp eq i64 %80, 17
  br i1 %cmp110, label %if.end.146, label %if.then.112

if.then.112:                                      ; preds = %land.lhs.true.108, %while.end
  %81 = load %struct.op*, %struct.op** %kid81, align 8
  %op_type113 = getelementptr inbounds %struct.op, %struct.op* %81, i32 0, i32 4
  %82 = load i16, i16* %op_type113, align 2
  %conv114 = zext i16 %82 to i32
  %cmp115 = icmp eq i32 %conv114, 350
  br i1 %cmp115, label %if.then.122, label %lor.lhs.false.117

lor.lhs.false.117:                                ; preds = %if.then.112
  %83 = load %struct.op*, %struct.op** %kid81, align 8
  %op_type118 = getelementptr inbounds %struct.op, %struct.op* %83, i32 0, i32 4
  %84 = load i16, i16* %op_type118, align 2
  %conv119 = zext i16 %84 to i32
  %cmp120 = icmp eq i32 %conv119, 165
  br i1 %cmp120, label %if.then.122, label %if.end.132

if.then.122:                                      ; preds = %lor.lhs.false.117, %if.then.112
  %call123 = call i8* @Perl_safesysmalloc(i64 48)
  %85 = bitcast i8* %call123 to %struct.unop*
  store %struct.unop* %85, %struct.unop** %newop, align 8
  %86 = load %struct.unop*, %struct.unop** %newop, align 8
  %87 = bitcast %struct.unop* %86 to i8*
  call void @llvm.memset.p0i8.i64(i8* %87, i8 0, i64 48, i32 1, i1 false)
  %88 = load %struct.unop*, %struct.unop** %newop, align 8
  %op_type124 = getelementptr inbounds %struct.unop, %struct.unop* %88, i32 0, i32 4
  store i16 17, i16* %op_type124, align 2
  %89 = load %struct.op* ()*, %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 17), align 8
  %90 = load %struct.unop*, %struct.unop** %newop, align 8
  %op_ppaddr125 = getelementptr inbounds %struct.unop, %struct.unop* %90, i32 0, i32 2
  store %struct.op* ()* %89, %struct.op* ()** %op_ppaddr125, align 8
  %91 = load %struct.unop*, %struct.unop** %newop, align 8
  %op_first126 = getelementptr inbounds %struct.unop, %struct.unop* %91, i32 0, i32 8
  store %struct.op* null, %struct.op** %op_first126, align 8
  %92 = load %struct.unop*, %struct.unop** %newop, align 8
  %93 = bitcast %struct.unop* %92 to %struct.op*
  %94 = load %struct.unop*, %struct.unop** %newop, align 8
  %op_next = getelementptr inbounds %struct.unop, %struct.unop* %94, i32 0, i32 0
  store %struct.op* %93, %struct.op** %op_next, align 8
  %95 = load %struct.unop*, %struct.unop** %newop, align 8
  %96 = bitcast %struct.unop* %95 to %struct.op*
  %97 = load %struct.op*, %struct.op** %kid81, align 8
  %op_sibling127 = getelementptr inbounds %struct.op, %struct.op* %97, i32 0, i32 1
  store %struct.op* %96, %struct.op** %op_sibling127, align 8
  %98 = load %struct.unop*, %struct.unop** %newop, align 8
  %op_private128 = getelementptr inbounds %struct.unop, %struct.unop* %98, i32 0, i32 7
  %99 = load i8, i8* %op_private128, align 1
  %conv129 = zext i8 %99 to i32
  %or130 = or i32 %conv129, 128
  %conv131 = trunc i32 %or130 to i8
  store i8 %conv131, i8* %op_private128, align 1
  br label %sw.epilog

if.end.132:                                       ; preds = %lor.lhs.false.117
  %100 = load %struct.op*, %struct.op** %kid81, align 8
  %op_type133 = getelementptr inbounds %struct.op, %struct.op* %100, i32 0, i32 4
  %101 = load i16, i16* %op_type133, align 2
  %conv134 = zext i16 %101 to i32
  %cmp135 = icmp ne i32 %conv134, 17
  br i1 %cmp135, label %if.then.137, label %if.end.141

if.then.137:                                      ; preds = %if.end.132
  %102 = load %struct.op*, %struct.op** %kid81, align 8
  %op_type138 = getelementptr inbounds %struct.op, %struct.op* %102, i32 0, i32 4
  %103 = load i16, i16* %op_type138, align 2
  %conv139 = zext i16 %103 to i64
  %104 = load %struct.op*, %struct.op** %kid81, align 8
  %op_targ140 = getelementptr inbounds %struct.op, %struct.op* %104, i32 0, i32 3
  %105 = load i64, i64* %op_targ140, align 8
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([62 x i8], [62 x i8]* @.str.16, i32 0, i32 0), i64 %conv139, i64 %105)
  br label %if.end.141

if.end.141:                                       ; preds = %if.then.137, %if.end.132
  %106 = load %struct.op*, %struct.op** %kid81, align 8
  %op_private142 = getelementptr inbounds %struct.op, %struct.op* %106, i32 0, i32 7
  %107 = load i8, i8* %op_private142, align 1
  %conv143 = zext i8 %107 to i32
  %or144 = or i32 %conv143, 128
  %conv145 = trunc i32 %or144 to i8
  store i8 %conv145, i8* %op_private142, align 1
  br label %sw.epilog

if.end.146:                                       ; preds = %land.lhs.true.108
  %108 = load %struct.op*, %struct.op** %kid81, align 8
  store %struct.op* %108, %struct.op** %okid, align 8
  %109 = load %struct.op*, %struct.op** %kid81, align 8
  %110 = bitcast %struct.op* %109 to %struct.unop*
  %op_first147 = getelementptr inbounds %struct.unop, %struct.unop* %110, i32 0, i32 8
  %111 = load %struct.op*, %struct.op** %op_first147, align 8
  store %struct.op* %111, %struct.op** %kid81, align 8
  %112 = load %struct.op*, %struct.op** %kid81, align 8
  %op_type148 = getelementptr inbounds %struct.op, %struct.op* %112, i32 0, i32 4
  %113 = load i16, i16* %op_type148, align 2
  %conv149 = zext i16 %113 to i32
  %cmp150 = icmp eq i32 %conv149, 0
  br i1 %cmp150, label %land.lhs.true.152, label %if.end.158

land.lhs.true.152:                                ; preds = %if.end.146
  %114 = load %struct.op*, %struct.op** %kid81, align 8
  %op_targ153 = getelementptr inbounds %struct.op, %struct.op* %114, i32 0, i32 3
  %115 = load i64, i64* %op_targ153, align 8
  %cmp154 = icmp eq i64 %115, 15
  br i1 %cmp154, label %if.then.156, label %if.end.158

if.then.156:                                      ; preds = %land.lhs.true.152
  %116 = load %struct.op*, %struct.op** %kid81, align 8
  %117 = bitcast %struct.op* %116 to %struct.unop*
  %op_first157 = getelementptr inbounds %struct.unop, %struct.unop* %117, i32 0, i32 8
  %118 = load %struct.op*, %struct.op** %op_first157, align 8
  store %struct.op* %118, %struct.op** %kid81, align 8
  br label %if.end.158

if.end.158:                                       ; preds = %if.then.156, %land.lhs.true.152, %if.end.146
  %119 = load %struct.op*, %struct.op** %kid81, align 8
  %op_type159 = getelementptr inbounds %struct.op, %struct.op* %119, i32 0, i32 4
  %120 = load i16, i16* %op_type159, align 2
  %conv160 = zext i16 %120 to i32
  %cmp161 = icmp eq i32 %conv160, 0
  br i1 %cmp161, label %if.then.163, label %if.end.167

if.then.163:                                      ; preds = %if.end.158
  %121 = load %struct.op*, %struct.op** %kid81, align 8
  %op_type164 = getelementptr inbounds %struct.op, %struct.op* %121, i32 0, i32 4
  %122 = load i16, i16* %op_type164, align 2
  %conv165 = zext i16 %122 to i64
  %123 = load %struct.op*, %struct.op** %kid81, align 8
  %op_targ166 = getelementptr inbounds %struct.op, %struct.op* %123, i32 0, i32 3
  %124 = load i64, i64* %op_targ166, align 8
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([64 x i8], [64 x i8]* @.str.17, i32 0, i32 0), i64 %conv165, i64 %124)
  br label %if.end.167

if.end.167:                                       ; preds = %if.then.163, %if.end.158
  %125 = load %struct.op*, %struct.op** %kid81, align 8
  %op_type168 = getelementptr inbounds %struct.op, %struct.op* %125, i32 0, i32 4
  %126 = load i16, i16* %op_type168, align 2
  %conv169 = zext i16 %126 to i32
  %cmp170 = icmp ne i32 %conv169, 7
  br i1 %cmp170, label %if.then.172, label %if.end.193

if.then.172:                                      ; preds = %if.end.167
  br label %restore_2cv

restore_2cv:                                      ; preds = %if.then.197, %if.then.172
  %127 = load %struct.op*, %struct.op** %kid81, align 8
  %op_next173 = getelementptr inbounds %struct.op, %struct.op* %127, i32 0, i32 0
  %128 = load %struct.op*, %struct.op** %op_next173, align 8
  %tobool174 = icmp ne %struct.op* %128, null
  br i1 %tobool174, label %land.lhs.true.175, label %if.else.183

land.lhs.true.175:                                ; preds = %restore_2cv
  %129 = load %struct.op*, %struct.op** %kid81, align 8
  %op_next176 = getelementptr inbounds %struct.op, %struct.op* %129, i32 0, i32 0
  %130 = load %struct.op*, %struct.op** %op_next176, align 8
  %131 = load %struct.op*, %struct.op** %kid81, align 8
  %cmp177 = icmp ne %struct.op* %130, %131
  br i1 %cmp177, label %if.then.179, label %if.else.183

if.then.179:                                      ; preds = %land.lhs.true.175
  %132 = load %struct.op*, %struct.op** %kid81, align 8
  %op_next180 = getelementptr inbounds %struct.op, %struct.op* %132, i32 0, i32 0
  %133 = load %struct.op*, %struct.op** %op_next180, align 8
  %134 = load %struct.op*, %struct.op** %okid, align 8
  %op_next181 = getelementptr inbounds %struct.op, %struct.op* %134, i32 0, i32 0
  store %struct.op* %133, %struct.op** %op_next181, align 8
  %135 = load %struct.op*, %struct.op** %okid, align 8
  %136 = load %struct.op*, %struct.op** %kid81, align 8
  %op_next182 = getelementptr inbounds %struct.op, %struct.op* %136, i32 0, i32 0
  store %struct.op* %135, %struct.op** %op_next182, align 8
  br label %if.end.185

if.else.183:                                      ; preds = %land.lhs.true.175, %restore_2cv
  %137 = load %struct.op*, %struct.op** %okid, align 8
  %op_next184 = getelementptr inbounds %struct.op, %struct.op* %137, i32 0, i32 0
  store %struct.op* null, %struct.op** %op_next184, align 8
  br label %if.end.185

if.end.185:                                       ; preds = %if.else.183, %if.then.179
  %138 = load %struct.op*, %struct.op** %okid, align 8
  %op_type186 = getelementptr inbounds %struct.op, %struct.op* %138, i32 0, i32 4
  store i16 17, i16* %op_type186, align 2
  %139 = load %struct.op*, %struct.op** %okid, align 8
  %op_targ187 = getelementptr inbounds %struct.op, %struct.op* %139, i32 0, i32 3
  store i64 0, i64* %op_targ187, align 8
  %140 = load %struct.op* ()*, %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 17), align 8
  %141 = load %struct.op*, %struct.op** %okid, align 8
  %op_ppaddr188 = getelementptr inbounds %struct.op, %struct.op* %141, i32 0, i32 2
  store %struct.op* ()* %140, %struct.op* ()** %op_ppaddr188, align 8
  %142 = load %struct.op*, %struct.op** %okid, align 8
  %op_private189 = getelementptr inbounds %struct.op, %struct.op* %142, i32 0, i32 7
  %143 = load i8, i8* %op_private189, align 1
  %conv190 = zext i8 %143 to i32
  %or191 = or i32 %conv190, 128
  %conv192 = trunc i32 %or191 to i8
  store i8 %conv192, i8* %op_private189, align 1
  br label %sw.epilog

if.end.193:                                       ; preds = %if.end.167
  %144 = load %struct.op*, %struct.op** %kid81, align 8
  %145 = bitcast %struct.op* %144 to %struct.svop*
  %op_sv194 = getelementptr inbounds %struct.svop, %struct.svop* %145, i32 0, i32 8
  %146 = load %struct.sv*, %struct.sv** %op_sv194, align 8
  %147 = bitcast %struct.sv* %146 to %struct.gv*
  %sv_any195 = getelementptr inbounds %struct.gv, %struct.gv* %147, i32 0, i32 0
  %148 = load %struct.xpvgv*, %struct.xpvgv** %sv_any195, align 8
  %xgv_gp = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %148, i32 0, i32 7
  %149 = load %struct.gp*, %struct.gp** %xgv_gp, align 8
  %gp_cv = getelementptr inbounds %struct.gp, %struct.gp* %149, i32 0, i32 7
  %150 = load %struct.cv*, %struct.cv** %gp_cv, align 8
  store %struct.cv* %150, %struct.cv** %cv, align 8
  %151 = load %struct.cv*, %struct.cv** %cv, align 8
  %tobool196 = icmp ne %struct.cv* %151, null
  br i1 %tobool196, label %if.end.198, label %if.then.197

if.then.197:                                      ; preds = %if.end.193
  br label %restore_2cv

if.end.198:                                       ; preds = %if.end.193
  %152 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any199 = getelementptr inbounds %struct.cv, %struct.cv* %152, i32 0, i32 0
  %153 = load %struct.xpvcv*, %struct.xpvcv** %sv_any199, align 8
  %xcv_flags = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %153, i32 0, i32 17
  %154 = load i16, i16* %xcv_flags, align 2
  %conv200 = zext i16 %154 to i32
  %and201 = and i32 %conv200, 256
  %tobool202 = icmp ne i32 %and201, 0
  br i1 %tobool202, label %if.then.203, label %if.end.204

if.then.203:                                      ; preds = %if.end.198
  br label %sw.epilog

if.end.204:                                       ; preds = %if.end.198
  br label %if.end.205

if.end.205:                                       ; preds = %if.end.204
  br label %if.end.206

if.end.206:                                       ; preds = %if.end.205
  br label %if.end.207

if.end.207:                                       ; preds = %if.end.206
  br label %sw.default

sw.default:                                       ; preds = %if.end.6, %if.end.207
  br label %nomod

nomod:                                            ; preds = %if.then.462, %if.then.434, %if.then.369, %if.then.362, %if.then.324, %if.then.287, %if.then.265, %sw.default, %if.end.42, %if.then.32, %if.then.14
  %155 = load i32, i32* %type.addr, align 4
  %cmp208 = icmp eq i32 %155, 152
  br i1 %cmp208, label %if.then.216, label %lor.lhs.false.210

lor.lhs.false.210:                                ; preds = %nomod
  %156 = load i32, i32* %type.addr, align 4
  %cmp211 = icmp eq i32 %156, 166
  br i1 %cmp211, label %if.then.216, label %lor.lhs.false.213

lor.lhs.false.213:                                ; preds = %lor.lhs.false.210
  %157 = load i32, i32* %type.addr, align 4
  %cmp214 = icmp eq i32 %157, 20
  br i1 %cmp214, label %if.then.216, label %if.end.217

if.then.216:                                      ; preds = %lor.lhs.false.213, %lor.lhs.false.210, %nomod
  br label %sw.epilog

if.end.217:                                       ; preds = %lor.lhs.false.213
  %158 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type218 = getelementptr inbounds %struct.op, %struct.op* %158, i32 0, i32 4
  %159 = load i16, i16* %op_type218, align 2
  %conv219 = zext i16 %159 to i32
  %cmp220 = icmp eq i32 %conv219, 0
  br i1 %cmp220, label %land.lhs.true.222, label %cond.false.228

land.lhs.true.222:                                ; preds = %if.end.217
  %160 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags223 = getelementptr inbounds %struct.op, %struct.op* %160, i32 0, i32 6
  %161 = load i8, i8* %op_flags223, align 1
  %conv224 = zext i8 %161 to i32
  %and225 = and i32 %conv224, 128
  %tobool226 = icmp ne i32 %and225, 0
  br i1 %tobool226, label %cond.true.227, label %cond.false.228

cond.true.227:                                    ; preds = %land.lhs.true.222
  br label %cond.end.249

cond.false.228:                                   ; preds = %land.lhs.true.222, %if.end.217
  %162 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type229 = getelementptr inbounds %struct.op, %struct.op* %162, i32 0, i32 4
  %163 = load i16, i16* %op_type229, align 2
  %conv230 = zext i16 %163 to i32
  %cmp231 = icmp eq i32 %conv230, 166
  br i1 %cmp231, label %cond.true.233, label %cond.false.234

cond.true.233:                                    ; preds = %cond.false.228
  br label %cond.end.247

cond.false.234:                                   ; preds = %cond.false.228
  %164 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type235 = getelementptr inbounds %struct.op, %struct.op* %164, i32 0, i32 4
  %165 = load i16, i16* %op_type235, align 2
  %conv236 = zext i16 %165 to i32
  %cmp237 = icmp eq i32 %conv236, 351
  br i1 %cmp237, label %cond.true.239, label %cond.false.241

cond.true.239:                                    ; preds = %cond.false.234
  %166 = load %struct.op*, %struct.op** %o.addr, align 8
  %call240 = call i8* @Perl_custom_op_desc(%struct.op* %166)
  br label %cond.end.245

cond.false.241:                                   ; preds = %cond.false.234
  %167 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type242 = getelementptr inbounds %struct.op, %struct.op* %167, i32 0, i32 4
  %168 = load i16, i16* %op_type242, align 2
  %idxprom243 = zext i16 %168 to i64
  %arrayidx244 = getelementptr inbounds [0 x i8*], [0 x i8*]* @PL_op_desc, i32 0, i64 %idxprom243
  %169 = load i8*, i8** %arrayidx244, align 8
  br label %cond.end.245

cond.end.245:                                     ; preds = %cond.false.241, %cond.true.239
  %cond246 = phi i8* [ %call240, %cond.true.239 ], [ %169, %cond.false.241 ]
  br label %cond.end.247

cond.end.247:                                     ; preds = %cond.end.245, %cond.true.233
  %cond248 = phi i8* [ getelementptr inbounds ([27 x i8], [27 x i8]* @.str.20, i32 0, i32 0), %cond.true.233 ], [ %cond246, %cond.end.245 ]
  br label %cond.end.249

cond.end.249:                                     ; preds = %cond.end.247, %cond.true.227
  %cond250 = phi i8* [ getelementptr inbounds ([9 x i8], [9 x i8]* @.str.19, i32 0, i32 0), %cond.true.227 ], [ %cond248, %cond.end.247 ]
  %170 = load i32, i32* %type.addr, align 4
  %tobool251 = icmp ne i32 %170, 0
  br i1 %tobool251, label %cond.true.252, label %cond.false.255

cond.true.252:                                    ; preds = %cond.end.249
  %171 = load i32, i32* %type.addr, align 4
  %idxprom253 = sext i32 %171 to i64
  %arrayidx254 = getelementptr inbounds [0 x i8*], [0 x i8*]* @PL_op_desc, i32 0, i64 %idxprom253
  %172 = load i8*, i8** %arrayidx254, align 8
  br label %cond.end.256

cond.false.255:                                   ; preds = %cond.end.249
  br label %cond.end.256

cond.end.256:                                     ; preds = %cond.false.255, %cond.true.252
  %cond257 = phi i8* [ %172, %cond.true.252 ], [ getelementptr inbounds ([6 x i8], [6 x i8]* @.str.21, i32 0, i32 0), %cond.false.255 ]
  %call258 = call i8* (i8*, ...) @Perl_form(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.18, i32 0, i32 0), i8* %cond250, i8* %cond257)
  %call259 = call i32 @Perl_yyerror(i8* %call258)
  %173 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %173, %struct.op** %retval
  br label %return

sw.bb.260:                                        ; preds = %if.end.6, %if.end.6, %if.end.6, %if.end.6, %if.end.6, %if.end.6, %if.end.6, %if.end.6, %if.end.6, %if.end.6, %if.end.6, %if.end.6, %if.end.6, %if.end.6, %if.end.6, %if.end.6, %if.end.6, %if.end.6, %if.end.6, %if.end.6
  %174 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags261 = getelementptr inbounds %struct.op, %struct.op* %174, i32 0, i32 6
  %175 = load i8, i8* %op_flags261, align 1
  %conv262 = zext i8 %175 to i32
  %and263 = and i32 %conv262, 64
  %tobool264 = icmp ne i32 %and263, 0
  br i1 %tobool264, label %if.end.266, label %if.then.265

if.then.265:                                      ; preds = %sw.bb.260
  br label %nomod

if.end.266:                                       ; preds = %sw.bb.260
  %176 = load i32, i32* @PL_modcount, align 4
  %inc267 = add nsw i32 %176, 1
  store i32 %inc267, i32* @PL_modcount, align 4
  br label %sw.epilog

sw.bb.268:                                        ; preds = %if.end.6
  %177 = load %struct.op*, %struct.op** %o.addr, align 8
  %178 = bitcast %struct.op* %177 to %struct.unop*
  %op_first269 = getelementptr inbounds %struct.unop, %struct.unop* %178, i32 0, i32 8
  %179 = load %struct.op*, %struct.op** %op_first269, align 8
  %op_sibling270 = getelementptr inbounds %struct.op, %struct.op* %179, i32 0, i32 1
  %180 = load %struct.op*, %struct.op** %op_sibling270, align 8
  store %struct.op* %180, %struct.op** %kid, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %sw.bb.268
  %181 = load %struct.op*, %struct.op** %kid, align 8
  %tobool271 = icmp ne %struct.op* %181, null
  br i1 %tobool271, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %182 = load %struct.op*, %struct.op** %kid, align 8
  %183 = load i32, i32* %type.addr, align 4
  %call272 = call %struct.op* @Perl_mod(%struct.op* %182, i32 %183)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %184 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling273 = getelementptr inbounds %struct.op, %struct.op* %184, i32 0, i32 1
  %185 = load %struct.op*, %struct.op** %op_sibling273, align 8
  store %struct.op* %185, %struct.op** %kid, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %sw.epilog

sw.bb.274:                                        ; preds = %if.end.6, %if.end.6
  %186 = load i32, i32* %type.addr, align 4
  %cmp275 = icmp eq i32 %186, 20
  br i1 %cmp275, label %land.lhs.true.277, label %if.end.283

land.lhs.true.277:                                ; preds = %sw.bb.274
  %187 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags278 = getelementptr inbounds %struct.op, %struct.op* %187, i32 0, i32 6
  %188 = load i8, i8* %op_flags278, align 1
  %conv279 = zext i8 %188 to i32
  %and280 = and i32 %conv279, 8
  %tobool281 = icmp ne i32 %and280, 0
  br i1 %tobool281, label %if.then.282, label %if.end.283

if.then.282:                                      ; preds = %land.lhs.true.277
  store i32 1073741823, i32* @PL_modcount, align 4
  %189 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %189, %struct.op** %retval
  br label %return

if.end.283:                                       ; preds = %land.lhs.true.277, %sw.bb.274
  br label %sw.bb.284

sw.bb.284:                                        ; preds = %if.end.6, %if.end.283
  %190 = load %struct.op*, %struct.op** %o.addr, align 8
  %191 = load i32, i32* %type.addr, align 4
  %call285 = call signext i8 @S_scalar_mod_type(%struct.op* %190, i32 %191)
  %tobool286 = icmp ne i8 %call285, 0
  br i1 %tobool286, label %if.then.287, label %if.end.288

if.then.287:                                      ; preds = %sw.bb.284
  br label %nomod

if.end.288:                                       ; preds = %sw.bb.284
  %192 = load %struct.op*, %struct.op** %o.addr, align 8
  %193 = bitcast %struct.op* %192 to %struct.unop*
  %op_first289 = getelementptr inbounds %struct.unop, %struct.unop* %193, i32 0, i32 8
  %194 = load %struct.op*, %struct.op** %op_first289, align 8
  %195 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type290 = getelementptr inbounds %struct.op, %struct.op* %195, i32 0, i32 4
  %196 = load i16, i16* %op_type290, align 2
  %conv291 = zext i16 %196 to i32
  %call292 = call %struct.op* @Perl_ref(%struct.op* %194, i32 %conv291)
  br label %sw.bb.293

sw.bb.293:                                        ; preds = %if.end.6, %if.end.6, %if.end.288
  %197 = load i32, i32* %type.addr, align 4
  %cmp294 = icmp eq i32 %197, 168
  br i1 %cmp294, label %if.then.296, label %if.end.301

if.then.296:                                      ; preds = %sw.bb.293
  %198 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private297 = getelementptr inbounds %struct.op, %struct.op* %198, i32 0, i32 7
  %199 = load i8, i8* %op_private297, align 1
  %conv298 = zext i8 %199 to i32
  %or299 = or i32 %conv298, 8
  %conv300 = trunc i32 %or299 to i8
  store i8 %conv300, i8* %op_private297, align 1
  br label %if.end.301

if.end.301:                                       ; preds = %if.then.296, %sw.bb.293
  br label %sw.bb.302

sw.bb.302:                                        ; preds = %if.end.6, %if.end.6, %if.end.6, %if.end.301
  store i32 1073741823, i32* @PL_modcount, align 4
  br label %sw.epilog

sw.bb.303:                                        ; preds = %if.end.6
  %200 = load %struct.op*, %struct.op** %o.addr, align 8
  %201 = bitcast %struct.op* %200 to %struct.unop*
  %op_first304 = getelementptr inbounds %struct.unop, %struct.unop* %201, i32 0, i32 8
  %202 = load %struct.op*, %struct.op** %op_first304, align 8
  %203 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type305 = getelementptr inbounds %struct.op, %struct.op* %203, i32 0, i32 4
  %204 = load i16, i16* %op_type305, align 2
  %conv306 = zext i16 %204 to i32
  %call307 = call %struct.op* @Perl_ref(%struct.op* %202, i32 %conv306)
  br label %sw.bb.308

sw.bb.308:                                        ; preds = %if.end.6, %if.end.6, %sw.bb.303
  %205 = load i32, i32* @PL_hints, align 4
  %or309 = or i32 %205, 256
  store i32 %or309, i32* @PL_hints, align 4
  br label %sw.bb.310

sw.bb.310:                                        ; preds = %if.end.6, %if.end.6, %if.end.6, %if.end.6, %sw.bb.308
  %206 = load i32, i32* @PL_modcount, align 4
  %inc311 = add nsw i32 %206, 1
  store i32 %inc311, i32* @PL_modcount, align 4
  br label %sw.epilog

sw.bb.312:                                        ; preds = %if.end.6, %if.end.6
  store i32 1073741823, i32* @PL_modcount, align 4
  %207 = load i32, i32* %type.addr, align 4
  %cmp313 = icmp eq i32 %207, 20
  br i1 %cmp313, label %land.lhs.true.315, label %if.end.321

land.lhs.true.315:                                ; preds = %sw.bb.312
  %208 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags316 = getelementptr inbounds %struct.op, %struct.op* %208, i32 0, i32 6
  %209 = load i8, i8* %op_flags316, align 1
  %conv317 = zext i8 %209 to i32
  %and318 = and i32 %conv317, 8
  %tobool319 = icmp ne i32 %and318, 0
  br i1 %tobool319, label %if.then.320, label %if.end.321

if.then.320:                                      ; preds = %land.lhs.true.315
  %210 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %210, %struct.op** %retval
  br label %return

if.end.321:                                       ; preds = %land.lhs.true.315, %sw.bb.312
  %211 = load %struct.op*, %struct.op** %o.addr, align 8
  %212 = load i32, i32* %type.addr, align 4
  %call322 = call signext i8 @S_scalar_mod_type(%struct.op* %211, i32 %212)
  %tobool323 = icmp ne i8 %call322, 0
  br i1 %tobool323, label %if.then.324, label %if.end.325

if.then.324:                                      ; preds = %if.end.321
  br label %nomod

if.end.325:                                       ; preds = %if.end.321
  %213 = load i32, i32* %type.addr, align 4
  %cmp326 = icmp eq i32 %213, 168
  br i1 %cmp326, label %if.then.328, label %if.end.333

if.then.328:                                      ; preds = %if.end.325
  %214 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private329 = getelementptr inbounds %struct.op, %struct.op* %214, i32 0, i32 7
  %215 = load i8, i8* %op_private329, align 1
  %conv330 = zext i8 %215 to i32
  %or331 = or i32 %conv330, 8
  %conv332 = trunc i32 %or331 to i8
  store i8 %conv332, i8* %op_private329, align 1
  br label %if.end.333

if.end.333:                                       ; preds = %if.then.328, %if.end.325
  br label %sw.bb.334

sw.bb.334:                                        ; preds = %if.end.6, %if.end.333
  %216 = load i32, i32* @PL_modcount, align 4
  %inc335 = add nsw i32 %216, 1
  store i32 %inc335, i32* @PL_modcount, align 4
  %217 = load i32, i32* %type.addr, align 4
  %tobool336 = icmp ne i32 %217, 0
  br i1 %tobool336, label %if.end.357, label %if.then.337

if.then.337:                                      ; preds = %sw.bb.334
  %218 = load %struct.av*, %struct.av** @PL_comppad_name, align 8
  %219 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_targ338 = getelementptr inbounds %struct.op, %struct.op* %219, i32 0, i32 3
  %220 = load i64, i64* %op_targ338, align 8
  %conv339 = trunc i64 %220 to i32
  %call340 = call %struct.sv** @Perl_av_fetch(%struct.av* %218, i32 %conv339, i32 0)
  %221 = load %struct.sv*, %struct.sv** %call340, align 8
  %sv_flags341 = getelementptr inbounds %struct.sv, %struct.sv* %221, i32 0, i32 2
  %222 = load i32, i32* %sv_flags341, align 4
  %and342 = and i32 %222, 262144
  %cmp343 = icmp eq i32 %and342, 262144
  br i1 %cmp343, label %cond.true.345, label %cond.false.350

cond.true.345:                                    ; preds = %if.then.337
  %223 = load %struct.av*, %struct.av** @PL_comppad_name, align 8
  %224 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_targ346 = getelementptr inbounds %struct.op, %struct.op* %224, i32 0, i32 3
  %225 = load i64, i64* %op_targ346, align 8
  %conv347 = trunc i64 %225 to i32
  %call348 = call %struct.sv** @Perl_av_fetch(%struct.av* %223, i32 %conv347, i32 0)
  %226 = load %struct.sv*, %struct.sv** %call348, align 8
  %sv_any349 = getelementptr inbounds %struct.sv, %struct.sv* %226, i32 0, i32 0
  %227 = load i8*, i8** %sv_any349, align 8
  %228 = bitcast i8* %227 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %228, i32 0, i32 0
  %229 = load i8*, i8** %xpv_pv, align 8
  br label %cond.end.355

cond.false.350:                                   ; preds = %if.then.337
  %230 = load %struct.av*, %struct.av** @PL_comppad_name, align 8
  %231 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_targ351 = getelementptr inbounds %struct.op, %struct.op* %231, i32 0, i32 3
  %232 = load i64, i64* %op_targ351, align 8
  %conv352 = trunc i64 %232 to i32
  %call353 = call %struct.sv** @Perl_av_fetch(%struct.av* %230, i32 %conv352, i32 0)
  %233 = load %struct.sv*, %struct.sv** %call353, align 8
  %call354 = call i8* @Perl_sv_2pv_nolen(%struct.sv* %233)
  br label %cond.end.355

cond.end.355:                                     ; preds = %cond.false.350, %cond.true.345
  %cond356 = phi i8* [ %229, %cond.true.345 ], [ %call354, %cond.false.350 ]
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.22, i32 0, i32 0), i8* %cond356)
  br label %if.end.357

if.end.357:                                       ; preds = %cond.end.355, %sw.bb.334
  br label %sw.epilog

sw.bb.358:                                        ; preds = %if.end.6
  br label %sw.epilog

sw.bb.359:                                        ; preds = %if.end.6
  %234 = load i32, i32* %type.addr, align 4
  %cmp360 = icmp ne i32 %234, 36
  br i1 %cmp360, label %if.then.362, label %if.end.363

if.then.362:                                      ; preds = %sw.bb.359
  br label %nomod

if.end.363:                                       ; preds = %sw.bb.359
  br label %lvalue_func

sw.bb.364:                                        ; preds = %if.end.6
  %235 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private365 = getelementptr inbounds %struct.op, %struct.op* %235, i32 0, i32 7
  %236 = load i8, i8* %op_private365, align 1
  %conv366 = zext i8 %236 to i32
  %cmp367 = icmp eq i32 %conv366, 4
  br i1 %cmp367, label %if.then.369, label %if.end.370

if.then.369:                                      ; preds = %sw.bb.364
  br label %nomod

if.end.370:                                       ; preds = %sw.bb.364
  br label %sw.bb.371

sw.bb.371:                                        ; preds = %if.end.6, %if.end.6, %if.end.370
  %237 = load i32, i32* %type.addr, align 4
  %cmp372 = icmp eq i32 %237, 168
  br i1 %cmp372, label %if.then.374, label %if.end.379

if.then.374:                                      ; preds = %sw.bb.371
  %238 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private375 = getelementptr inbounds %struct.op, %struct.op* %238, i32 0, i32 7
  %239 = load i8, i8* %op_private375, align 1
  %conv376 = zext i8 %239 to i32
  %or377 = or i32 %conv376, 8
  %conv378 = trunc i32 %or377 to i8
  store i8 %conv378, i8* %op_private375, align 1
  br label %if.end.379

if.end.379:                                       ; preds = %if.then.374, %sw.bb.371
  br label %lvalue_func

lvalue_func:                                      ; preds = %if.end.379, %if.end.363
  %240 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_targ380 = getelementptr inbounds %struct.op, %struct.op* %240, i32 0, i32 3
  %241 = load i64, i64* %op_targ380, align 8
  call void @Perl_pad_free(i64 %241)
  %242 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type381 = getelementptr inbounds %struct.op, %struct.op* %242, i32 0, i32 4
  %243 = load i16, i16* %op_type381, align 2
  %conv382 = zext i16 %243 to i32
  %call383 = call i64 @Perl_pad_alloc(i32 %conv382, i32 1024)
  %244 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_targ384 = getelementptr inbounds %struct.op, %struct.op* %244, i32 0, i32 3
  store i64 %call383, i64* %op_targ384, align 8
  %245 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags385 = getelementptr inbounds %struct.op, %struct.op* %245, i32 0, i32 6
  %246 = load i8, i8* %op_flags385, align 1
  %conv386 = zext i8 %246 to i32
  %and387 = and i32 %conv386, 4
  %tobool388 = icmp ne i32 %and387, 0
  br i1 %tobool388, label %if.then.389, label %if.end.393

if.then.389:                                      ; preds = %lvalue_func
  %247 = load %struct.op*, %struct.op** %o.addr, align 8
  %248 = bitcast %struct.op* %247 to %struct.binop*
  %op_first390 = getelementptr inbounds %struct.binop, %struct.binop* %248, i32 0, i32 8
  %249 = load %struct.op*, %struct.op** %op_first390, align 8
  %op_sibling391 = getelementptr inbounds %struct.op, %struct.op* %249, i32 0, i32 1
  %250 = load %struct.op*, %struct.op** %op_sibling391, align 8
  %251 = load i32, i32* %type.addr, align 4
  %call392 = call %struct.op* @Perl_mod(%struct.op* %250, i32 %251)
  br label %if.end.393

if.end.393:                                       ; preds = %if.then.389, %lvalue_func
  br label %sw.epilog

sw.bb.394:                                        ; preds = %if.end.6, %if.end.6
  %252 = load %struct.op*, %struct.op** %o.addr, align 8
  %253 = bitcast %struct.op* %252 to %struct.binop*
  %op_first395 = getelementptr inbounds %struct.binop, %struct.binop* %253, i32 0, i32 8
  %254 = load %struct.op*, %struct.op** %op_first395, align 8
  %255 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type396 = getelementptr inbounds %struct.op, %struct.op* %255, i32 0, i32 4
  %256 = load i16, i16* %op_type396, align 2
  %conv397 = zext i16 %256 to i32
  %call398 = call %struct.op* @Perl_ref(%struct.op* %254, i32 %conv397)
  %257 = load i32, i32* %type.addr, align 4
  %cmp399 = icmp eq i32 %257, 166
  br i1 %cmp399, label %land.lhs.true.401, label %if.end.411

land.lhs.true.401:                                ; preds = %sw.bb.394
  %258 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private402 = getelementptr inbounds %struct.op, %struct.op* %258, i32 0, i32 7
  %259 = load i8, i8* %op_private402, align 1
  %conv403 = zext i8 %259 to i32
  %and404 = and i32 %conv403, 224
  %tobool405 = icmp ne i32 %and404, 0
  br i1 %tobool405, label %if.end.411, label %if.then.406

if.then.406:                                      ; preds = %land.lhs.true.401
  %260 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private407 = getelementptr inbounds %struct.op, %struct.op* %260, i32 0, i32 7
  %261 = load i8, i8* %op_private407, align 1
  %conv408 = zext i8 %261 to i32
  %or409 = or i32 %conv408, 16
  %conv410 = trunc i32 %or409 to i8
  store i8 %conv410, i8* %op_private407, align 1
  br label %if.end.411

if.end.411:                                       ; preds = %if.then.406, %land.lhs.true.401, %sw.bb.394
  %262 = load i32, i32* %type.addr, align 4
  %cmp412 = icmp eq i32 %262, 168
  br i1 %cmp412, label %if.then.414, label %if.end.419

if.then.414:                                      ; preds = %if.end.411
  %263 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private415 = getelementptr inbounds %struct.op, %struct.op* %263, i32 0, i32 7
  %264 = load i8, i8* %op_private415, align 1
  %conv416 = zext i8 %264 to i32
  %or417 = or i32 %conv416, 8
  %conv418 = trunc i32 %or417 to i8
  store i8 %conv418, i8* %op_private415, align 1
  br label %if.end.419

if.end.419:                                       ; preds = %if.then.414, %if.end.411
  %265 = load i32, i32* @PL_modcount, align 4
  %inc420 = add nsw i32 %265, 1
  store i32 %inc420, i32* @PL_modcount, align 4
  br label %sw.epilog

sw.bb.421:                                        ; preds = %if.end.6, %if.end.6, %if.end.6, %if.end.6
  %266 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags422 = getelementptr inbounds %struct.op, %struct.op* %266, i32 0, i32 6
  %267 = load i8, i8* %op_flags422, align 1
  %conv423 = zext i8 %267 to i32
  %and424 = and i32 %conv423, 4
  %tobool425 = icmp ne i32 %and424, 0
  br i1 %tobool425, label %if.then.426, label %if.end.428

if.then.426:                                      ; preds = %sw.bb.421
  %268 = load %struct.op*, %struct.op** %o.addr, align 8
  %269 = bitcast %struct.op* %268 to %struct.listop*
  %op_last = getelementptr inbounds %struct.listop, %struct.listop* %269, i32 0, i32 9
  %270 = load %struct.op*, %struct.op** %op_last, align 8
  %271 = load i32, i32* %type.addr, align 4
  %call427 = call %struct.op* @Perl_mod(%struct.op* %270, i32 %271)
  br label %if.end.428

if.end.428:                                       ; preds = %if.then.426, %sw.bb.421
  br label %sw.epilog

sw.bb.429:                                        ; preds = %if.end.6
  %272 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags430 = getelementptr inbounds %struct.op, %struct.op* %272, i32 0, i32 6
  %273 = load i8, i8* %op_flags430, align 1
  %conv431 = zext i8 %273 to i32
  %and432 = and i32 %conv431, 128
  %tobool433 = icmp ne i32 %and432, 0
  br i1 %tobool433, label %if.then.434, label %if.else.435

if.then.434:                                      ; preds = %sw.bb.429
  br label %nomod

if.else.435:                                      ; preds = %sw.bb.429
  %274 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags436 = getelementptr inbounds %struct.op, %struct.op* %274, i32 0, i32 6
  %275 = load i8, i8* %op_flags436, align 1
  %conv437 = zext i8 %275 to i32
  %and438 = and i32 %conv437, 4
  %tobool439 = icmp ne i32 %and438, 0
  br i1 %tobool439, label %if.end.441, label %if.then.440

if.then.440:                                      ; preds = %if.else.435
  br label %sw.epilog

if.end.441:                                       ; preds = %if.else.435
  br label %if.end.442

if.end.442:                                       ; preds = %if.end.441
  %276 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_targ443 = getelementptr inbounds %struct.op, %struct.op* %276, i32 0, i32 3
  %277 = load i64, i64* %op_targ443, align 8
  %cmp444 = icmp ne i64 %277, 141
  br i1 %cmp444, label %if.then.446, label %if.end.449

if.then.446:                                      ; preds = %if.end.442
  %278 = load %struct.op*, %struct.op** %o.addr, align 8
  %279 = bitcast %struct.op* %278 to %struct.binop*
  %op_first447 = getelementptr inbounds %struct.binop, %struct.binop* %279, i32 0, i32 8
  %280 = load %struct.op*, %struct.op** %op_first447, align 8
  %281 = load i32, i32* %type.addr, align 4
  %call448 = call %struct.op* @Perl_mod(%struct.op* %280, i32 %281)
  br label %sw.epilog

if.end.449:                                       ; preds = %if.end.442
  br label %sw.bb.450

sw.bb.450:                                        ; preds = %if.end.6, %if.end.449
  %282 = load %struct.op*, %struct.op** %o.addr, align 8
  %283 = bitcast %struct.op* %282 to %struct.listop*
  %op_first451 = getelementptr inbounds %struct.listop, %struct.listop* %283, i32 0, i32 8
  %284 = load %struct.op*, %struct.op** %op_first451, align 8
  store %struct.op* %284, %struct.op** %kid, align 8
  br label %for.cond.452

for.cond.452:                                     ; preds = %for.inc.456, %sw.bb.450
  %285 = load %struct.op*, %struct.op** %kid, align 8
  %tobool453 = icmp ne %struct.op* %285, null
  br i1 %tobool453, label %for.body.454, label %for.end.458

for.body.454:                                     ; preds = %for.cond.452
  %286 = load %struct.op*, %struct.op** %kid, align 8
  %287 = load i32, i32* %type.addr, align 4
  %call455 = call %struct.op* @Perl_mod(%struct.op* %286, i32 %287)
  br label %for.inc.456

for.inc.456:                                      ; preds = %for.body.454
  %288 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling457 = getelementptr inbounds %struct.op, %struct.op* %288, i32 0, i32 1
  %289 = load %struct.op*, %struct.op** %op_sibling457, align 8
  store %struct.op* %289, %struct.op** %kid, align 8
  br label %for.cond.452

for.end.458:                                      ; preds = %for.cond.452
  br label %sw.epilog

sw.bb.459:                                        ; preds = %if.end.6
  %290 = load i32, i32* %type.addr, align 4
  %cmp460 = icmp ne i32 %290, 168
  br i1 %cmp460, label %if.then.462, label %if.end.463

if.then.462:                                      ; preds = %sw.bb.459
  br label %nomod

if.end.463:                                       ; preds = %sw.bb.459
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end.463, %for.end.458, %if.then.446, %if.then.440, %if.end.428, %if.end.419, %if.end.393, %sw.bb.358, %if.end.357, %sw.bb.310, %sw.bb.302, %for.end, %if.end.266, %if.then.216, %if.then.203, %if.end.185, %if.end.141, %if.then.122, %if.then.75, %if.then.54, %if.then.41, %if.end.36
  %291 = load i32, i32* %type.addr, align 4
  %cmp464 = icmp eq i32 %291, 20
  br i1 %cmp464, label %land.lhs.true.466, label %if.end.473

land.lhs.true.466:                                ; preds = %sw.epilog
  %292 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type467 = getelementptr inbounds %struct.op, %struct.op* %292, i32 0, i32 4
  %293 = load i16, i16* %op_type467, align 2
  %idxprom468 = zext i16 %293 to i64
  %arrayidx469 = getelementptr inbounds [0 x %struct.op* (%struct.op*)*], [0 x %struct.op* (%struct.op*)*]* @PL_check, i32 0, i64 %idxprom468
  %294 = load %struct.op* (%struct.op*)*, %struct.op* (%struct.op*)** %arrayidx469, align 8
  %cmp470 = icmp eq %struct.op* (%struct.op*)* %294, @Perl_ck_ftst
  br i1 %cmp470, label %if.then.472, label %if.end.473

if.then.472:                                      ; preds = %land.lhs.true.466
  %295 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %295, %struct.op** %retval
  br label %return

if.end.473:                                       ; preds = %land.lhs.true.466, %sw.epilog
  %296 = load i32, i32* %type.addr, align 4
  %cmp474 = icmp ne i32 %296, 168
  br i1 %cmp474, label %if.then.476, label %if.end.481

if.then.476:                                      ; preds = %if.end.473
  %297 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags477 = getelementptr inbounds %struct.op, %struct.op* %297, i32 0, i32 6
  %298 = load i8, i8* %op_flags477, align 1
  %conv478 = zext i8 %298 to i32
  %or479 = or i32 %conv478, 32
  %conv480 = trunc i32 %or479 to i8
  store i8 %conv480, i8* %op_flags477, align 1
  br label %if.end.481

if.end.481:                                       ; preds = %if.then.476, %if.end.473
  %299 = load i32, i32* %type.addr, align 4
  %cmp482 = icmp eq i32 %299, 37
  br i1 %cmp482, label %if.then.487, label %lor.lhs.false.484

lor.lhs.false.484:                                ; preds = %if.end.481
  %300 = load i32, i32* %type.addr, align 4
  %cmp485 = icmp eq i32 %300, 36
  br i1 %cmp485, label %if.then.487, label %if.else.492

if.then.487:                                      ; preds = %lor.lhs.false.484, %if.end.481
  %301 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags488 = getelementptr inbounds %struct.op, %struct.op* %301, i32 0, i32 6
  %302 = load i8, i8* %op_flags488, align 1
  %conv489 = zext i8 %302 to i32
  %or490 = or i32 %conv489, 144
  %conv491 = trunc i32 %or490 to i8
  store i8 %conv491, i8* %op_flags488, align 1
  br label %if.end.520

if.else.492:                                      ; preds = %lor.lhs.false.484
  %303 = load i32, i32* %type.addr, align 4
  %tobool493 = icmp ne i32 %303, 0
  br i1 %tobool493, label %if.else.504, label %if.then.494

if.then.494:                                      ; preds = %if.else.492
  %304 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private495 = getelementptr inbounds %struct.op, %struct.op* %304, i32 0, i32 7
  %305 = load i8, i8* %op_private495, align 1
  %conv496 = zext i8 %305 to i32
  %or497 = or i32 %conv496, 128
  %conv498 = trunc i32 %or497 to i8
  store i8 %conv498, i8* %op_private495, align 1
  %306 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags499 = getelementptr inbounds %struct.op, %struct.op* %306, i32 0, i32 6
  %307 = load i8, i8* %op_flags499, align 1
  %conv500 = zext i8 %307 to i32
  %and501 = and i32 %conv500, -129
  %conv502 = trunc i32 %and501 to i8
  store i8 %conv502, i8* %op_flags499, align 1
  %308 = load i32, i32* @PL_hints, align 4
  %or503 = or i32 %308, 256
  store i32 %or503, i32* @PL_hints, align 4
  br label %if.end.519

if.else.504:                                      ; preds = %if.else.492
  %309 = load i32, i32* %type.addr, align 4
  %cmp505 = icmp ne i32 %309, 152
  br i1 %cmp505, label %land.lhs.true.507, label %if.end.518

land.lhs.true.507:                                ; preds = %if.else.504
  %310 = load i32, i32* %type.addr, align 4
  %cmp508 = icmp ne i32 %310, 166
  br i1 %cmp508, label %land.lhs.true.510, label %if.end.518

land.lhs.true.510:                                ; preds = %land.lhs.true.507
  %311 = load i32, i32* %type.addr, align 4
  %cmp511 = icmp ne i32 %311, 168
  br i1 %cmp511, label %if.then.513, label %if.end.518

if.then.513:                                      ; preds = %land.lhs.true.510
  %312 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags514 = getelementptr inbounds %struct.op, %struct.op* %312, i32 0, i32 6
  %313 = load i8, i8* %op_flags514, align 1
  %conv515 = zext i8 %313 to i32
  %or516 = or i32 %conv515, 16
  %conv517 = trunc i32 %or516 to i8
  store i8 %conv517, i8* %op_flags514, align 1
  br label %if.end.518

if.end.518:                                       ; preds = %if.then.513, %land.lhs.true.510, %land.lhs.true.507, %if.else.504
  br label %if.end.519

if.end.519:                                       ; preds = %if.end.518, %if.then.494
  br label %if.end.520

if.end.520:                                       ; preds = %if.end.519, %if.then.487
  %314 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %314, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.520, %if.then.472, %if.then.320, %if.then.282, %cond.end.256, %if.then.62, %sw.bb, %if.then.5, %if.then
  %315 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %315
}

declare i64 @Perl_sv_2iv(%struct.sv*) #1

declare void @Perl_save_I32(i32*) #1

declare void @Perl_croak(i8*, ...) #1

declare i8* @Perl_safesysmalloc(i64) #1

; Function Attrs: nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture, i8, i64, i32, i1) #2

; Function Attrs: nounwind uwtable
define internal signext i8 @S_scalar_mod_type(%struct.op* %o, i32 %type) #0 {
entry:
  %retval = alloca i8, align 1
  %o.addr = alloca %struct.op*, align 8
  %type.addr = alloca i32, align 4
  store %struct.op* %o, %struct.op** %o.addr, align 8
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32, i32* %type.addr, align 4
  switch i32 %0, label %sw.default [
    i32 36, label %sw.bb
    i32 46, label %sw.bb.2
    i32 48, label %sw.bb.2
    i32 50, label %sw.bb.2
    i32 52, label %sw.bb.2
    i32 47, label %sw.bb.2
    i32 49, label %sw.bb.2
    i32 51, label %sw.bb.2
    i32 53, label %sw.bb.2
    i32 54, label %sw.bb.2
    i32 55, label %sw.bb.2
    i32 57, label %sw.bb.2
    i32 59, label %sw.bb.2
    i32 61, label %sw.bb.2
    i32 62, label %sw.bb.2
    i32 64, label %sw.bb.2
    i32 56, label %sw.bb.2
    i32 58, label %sw.bb.2
    i32 60, label %sw.bb.2
    i32 63, label %sw.bb.2
    i32 65, label %sw.bb.2
    i32 68, label %sw.bb.2
    i32 69, label %sw.bb.2
    i32 91, label %sw.bb.2
    i32 92, label %sw.bb.2
    i32 93, label %sw.bb.2
    i32 66, label %sw.bb.2
    i32 33, label %sw.bb.2
    i32 35, label %sw.bb.2
    i32 205, label %sw.bb.2
    i32 212, label %sw.bb.2
    i32 215, label %sw.bb.2
    i32 163, label %sw.bb.2
    i32 164, label %sw.bb.2
  ]

sw.bb:                                            ; preds = %entry
  %1 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 4
  %2 = load i16, i16* %op_type, align 2
  %conv = zext i16 %2 to i32
  %cmp = icmp eq i32 %conv, 14
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb
  store i8 0, i8* %retval
  br label %return

if.end:                                           ; preds = %sw.bb
  br label %sw.bb.2

sw.bb.2:                                          ; preds = %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %entry, %if.end
  store i8 1, i8* %retval
  br label %return

sw.default:                                       ; preds = %entry
  store i8 0, i8* %retval
  br label %return

return:                                           ; preds = %sw.default, %sw.bb.2, %if.then
  %3 = load i8, i8* %retval
  ret i8 %3
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ref(%struct.op* %o, i32 %type) #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %o.addr = alloca %struct.op*, align 8
  %type.addr = alloca i32, align 4
  %kid = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  store i32 %type, i32* %type.addr, align 4
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %tobool = icmp ne %struct.op* %0, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* @PL_error_count, align 4
  %tobool1 = icmp ne i32 %1, 0
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %2 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %2, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %3 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %3, i32 0, i32 4
  %4 = load i16, i16* %op_type, align 2
  %conv = zext i16 %4 to i32
  switch i32 %conv, label %sw.default [
    i32 166, label %sw.bb
    i32 162, label %sw.bb.18
    i32 15, label %sw.bb.22
    i32 9, label %sw.bb.35
    i32 348, label %sw.bb.58
    i32 125, label %sw.bb.63
    i32 134, label %sw.bb.63
    i32 14, label %sw.bb.68
    i32 10, label %sw.bb.81
    i32 11, label %sw.bb.81
    i32 2, label %sw.bb.86
    i32 0, label %sw.bb.86
    i32 127, label %sw.bb.95
    i32 135, label %sw.bb.95
    i32 179, label %sw.bb.127
    i32 178, label %sw.bb.127
    i32 177, label %sw.bb.127
    i32 141, label %sw.bb.127
  ]

sw.bb:                                            ; preds = %if.end
  %5 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %5, 133
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false.3

lor.lhs.false.3:                                  ; preds = %sw.bb
  %6 = load i32, i32* %type.addr, align 4
  %cmp4 = icmp eq i32 %6, 42
  br i1 %cmp4, label %land.lhs.true, label %lor.lhs.false.6

lor.lhs.false.6:                                  ; preds = %lor.lhs.false.3
  %7 = load i32, i32* %type.addr, align 4
  %cmp7 = icmp eq i32 %7, 347
  br i1 %cmp7, label %land.lhs.true, label %if.end.17

land.lhs.true:                                    ; preds = %lor.lhs.false.6, %lor.lhs.false.3, %sw.bb
  %8 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %8, i32 0, i32 6
  %9 = load i8, i8* %op_flags, align 1
  %conv9 = zext i8 %9 to i32
  %and = and i32 %conv9, 64
  %tobool10 = icmp ne i32 %and, 0
  br i1 %tobool10, label %if.end.17, label %if.then.11

if.then.11:                                       ; preds = %land.lhs.true
  %10 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type12 = getelementptr inbounds %struct.op, %struct.op* %10, i32 0, i32 4
  store i16 17, i16* %op_type12, align 2
  %11 = load %struct.op* ()*, %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 17), align 8
  %12 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_ppaddr = getelementptr inbounds %struct.op, %struct.op* %12, i32 0, i32 2
  store %struct.op* ()* %11, %struct.op* ()** %op_ppaddr, align 8
  %13 = load %struct.op*, %struct.op** %o.addr, align 8
  %14 = bitcast %struct.op* %13 to %struct.unop*
  %op_first = getelementptr inbounds %struct.unop, %struct.unop* %14, i32 0, i32 8
  %15 = load %struct.op*, %struct.op** %op_first, align 8
  %16 = bitcast %struct.op* %15 to %struct.listop*
  %op_first13 = getelementptr inbounds %struct.listop, %struct.listop* %16, i32 0, i32 8
  %17 = load %struct.op*, %struct.op** %op_first13, align 8
  call void @Perl_op_null(%struct.op* %17)
  %18 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags14 = getelementptr inbounds %struct.op, %struct.op* %18, i32 0, i32 6
  %19 = load i8, i8* %op_flags14, align 1
  %conv15 = zext i8 %19 to i32
  %or = or i32 %conv15, 128
  %conv16 = trunc i32 %or to i8
  store i8 %conv16, i8* %op_flags14, align 1
  br label %if.end.17

if.end.17:                                        ; preds = %if.then.11, %land.lhs.true, %lor.lhs.false.6
  br label %sw.epilog

sw.bb.18:                                         ; preds = %if.end
  %20 = load %struct.op*, %struct.op** %o.addr, align 8
  %21 = bitcast %struct.op* %20 to %struct.unop*
  %op_first19 = getelementptr inbounds %struct.unop, %struct.unop* %21, i32 0, i32 8
  %22 = load %struct.op*, %struct.op** %op_first19, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %22, i32 0, i32 1
  %23 = load %struct.op*, %struct.op** %op_sibling, align 8
  store %struct.op* %23, %struct.op** %kid, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %sw.bb.18
  %24 = load %struct.op*, %struct.op** %kid, align 8
  %tobool20 = icmp ne %struct.op* %24, null
  br i1 %tobool20, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %25 = load %struct.op*, %struct.op** %kid, align 8
  %26 = load i32, i32* %type.addr, align 4
  %call = call %struct.op* @Perl_ref(%struct.op* %25, i32 %26)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %27 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling21 = getelementptr inbounds %struct.op, %struct.op* %27, i32 0, i32 1
  %28 = load %struct.op*, %struct.op** %op_sibling21, align 8
  store %struct.op* %28, %struct.op** %kid, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %sw.epilog

sw.bb.22:                                         ; preds = %if.end
  %29 = load i32, i32* %type.addr, align 4
  %cmp23 = icmp eq i32 %29, 42
  br i1 %cmp23, label %if.then.25, label %if.end.30

if.then.25:                                       ; preds = %sw.bb.22
  %30 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags26 = getelementptr inbounds %struct.op, %struct.op* %30, i32 0, i32 6
  %31 = load i8, i8* %op_flags26, align 1
  %conv27 = zext i8 %31 to i32
  %or28 = or i32 %conv27, 128
  %conv29 = trunc i32 %or28 to i8
  store i8 %conv29, i8* %op_flags26, align 1
  br label %if.end.30

if.end.30:                                        ; preds = %if.then.25, %sw.bb.22
  %32 = load %struct.op*, %struct.op** %o.addr, align 8
  %33 = bitcast %struct.op* %32 to %struct.unop*
  %op_first31 = getelementptr inbounds %struct.unop, %struct.unop* %33, i32 0, i32 8
  %34 = load %struct.op*, %struct.op** %op_first31, align 8
  %35 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type32 = getelementptr inbounds %struct.op, %struct.op* %35, i32 0, i32 4
  %36 = load i16, i16* %op_type32, align 2
  %conv33 = zext i16 %36 to i32
  %call34 = call %struct.op* @Perl_ref(%struct.op* %34, i32 %conv33)
  br label %sw.bb.35

sw.bb.35:                                         ; preds = %if.end, %if.end.30
  %37 = load i32, i32* %type.addr, align 4
  %cmp36 = icmp eq i32 %37, 15
  br i1 %cmp36, label %if.then.44, label %lor.lhs.false.38

lor.lhs.false.38:                                 ; preds = %sw.bb.35
  %38 = load i32, i32* %type.addr, align 4
  %cmp39 = icmp eq i32 %38, 125
  br i1 %cmp39, label %if.then.44, label %lor.lhs.false.41

lor.lhs.false.41:                                 ; preds = %lor.lhs.false.38
  %39 = load i32, i32* %type.addr, align 4
  %cmp42 = icmp eq i32 %39, 134
  br i1 %cmp42, label %if.then.44, label %if.end.57

if.then.44:                                       ; preds = %lor.lhs.false.41, %lor.lhs.false.38, %sw.bb.35
  %40 = load i32, i32* %type.addr, align 4
  %cmp45 = icmp eq i32 %40, 125
  br i1 %cmp45, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.44
  br label %cond.end

cond.false:                                       ; preds = %if.then.44
  %41 = load i32, i32* %type.addr, align 4
  %cmp47 = icmp eq i32 %41, 134
  %cond = select i1 %cmp47, i32 64, i32 96
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond49 = phi i32 [ 32, %cond.true ], [ %cond, %cond.false ]
  %42 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %42, i32 0, i32 7
  %43 = load i8, i8* %op_private, align 1
  %conv50 = zext i8 %43 to i32
  %or51 = or i32 %conv50, %cond49
  %conv52 = trunc i32 %or51 to i8
  store i8 %conv52, i8* %op_private, align 1
  %44 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags53 = getelementptr inbounds %struct.op, %struct.op* %44, i32 0, i32 6
  %45 = load i8, i8* %op_flags53, align 1
  %conv54 = zext i8 %45 to i32
  %or55 = or i32 %conv54, 32
  %conv56 = trunc i32 %or55 to i8
  store i8 %conv56, i8* %op_flags53, align 1
  br label %if.end.57

if.end.57:                                        ; preds = %cond.end, %lor.lhs.false.41
  br label %sw.epilog

sw.bb.58:                                         ; preds = %if.end
  %46 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags59 = getelementptr inbounds %struct.op, %struct.op* %46, i32 0, i32 6
  %47 = load i8, i8* %op_flags59, align 1
  %conv60 = zext i8 %47 to i32
  %or61 = or i32 %conv60, 32
  %conv62 = trunc i32 %or61 to i8
  store i8 %conv62, i8* %op_flags59, align 1
  br label %sw.epilog

sw.bb.63:                                         ; preds = %if.end, %if.end
  %48 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags64 = getelementptr inbounds %struct.op, %struct.op* %48, i32 0, i32 6
  %49 = load i8, i8* %op_flags64, align 1
  %conv65 = zext i8 %49 to i32
  %or66 = or i32 %conv65, 16
  %conv67 = trunc i32 %or66 to i8
  store i8 %conv67, i8* %op_flags64, align 1
  br label %sw.bb.68

sw.bb.68:                                         ; preds = %if.end, %sw.bb.63
  %50 = load i32, i32* %type.addr, align 4
  %cmp69 = icmp eq i32 %50, 42
  br i1 %cmp69, label %if.then.71, label %if.end.76

if.then.71:                                       ; preds = %sw.bb.68
  %51 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags72 = getelementptr inbounds %struct.op, %struct.op* %51, i32 0, i32 6
  %52 = load i8, i8* %op_flags72, align 1
  %conv73 = zext i8 %52 to i32
  %or74 = or i32 %conv73, 128
  %conv75 = trunc i32 %or74 to i8
  store i8 %conv75, i8* %op_flags72, align 1
  br label %if.end.76

if.end.76:                                        ; preds = %if.then.71, %sw.bb.68
  %53 = load %struct.op*, %struct.op** %o.addr, align 8
  %54 = bitcast %struct.op* %53 to %struct.unop*
  %op_first77 = getelementptr inbounds %struct.unop, %struct.unop* %54, i32 0, i32 8
  %55 = load %struct.op*, %struct.op** %op_first77, align 8
  %56 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type78 = getelementptr inbounds %struct.op, %struct.op* %56, i32 0, i32 4
  %57 = load i16, i16* %op_type78, align 2
  %conv79 = zext i16 %57 to i32
  %call80 = call %struct.op* @Perl_ref(%struct.op* %55, i32 %conv79)
  br label %sw.epilog

sw.bb.81:                                         ; preds = %if.end, %if.end
  %58 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags82 = getelementptr inbounds %struct.op, %struct.op* %58, i32 0, i32 6
  %59 = load i8, i8* %op_flags82, align 1
  %conv83 = zext i8 %59 to i32
  %or84 = or i32 %conv83, 16
  %conv85 = trunc i32 %or84 to i8
  store i8 %conv85, i8* %op_flags82, align 1
  br label %sw.epilog

sw.bb.86:                                         ; preds = %if.end, %if.end
  %60 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags87 = getelementptr inbounds %struct.op, %struct.op* %60, i32 0, i32 6
  %61 = load i8, i8* %op_flags87, align 1
  %conv88 = zext i8 %61 to i32
  %and89 = and i32 %conv88, 4
  %tobool90 = icmp ne i32 %and89, 0
  br i1 %tobool90, label %if.end.92, label %if.then.91

if.then.91:                                       ; preds = %sw.bb.86
  br label %sw.epilog

if.end.92:                                        ; preds = %sw.bb.86
  %62 = load %struct.op*, %struct.op** %o.addr, align 8
  %63 = bitcast %struct.op* %62 to %struct.binop*
  %op_first93 = getelementptr inbounds %struct.binop, %struct.binop* %63, i32 0, i32 8
  %64 = load %struct.op*, %struct.op** %op_first93, align 8
  %65 = load i32, i32* %type.addr, align 4
  %call94 = call %struct.op* @Perl_ref(%struct.op* %64, i32 %65)
  br label %sw.epilog

sw.bb.95:                                         ; preds = %if.end, %if.end
  %66 = load %struct.op*, %struct.op** %o.addr, align 8
  %67 = bitcast %struct.op* %66 to %struct.binop*
  %op_first96 = getelementptr inbounds %struct.binop, %struct.binop* %67, i32 0, i32 8
  %68 = load %struct.op*, %struct.op** %op_first96, align 8
  %69 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type97 = getelementptr inbounds %struct.op, %struct.op* %69, i32 0, i32 4
  %70 = load i16, i16* %op_type97, align 2
  %conv98 = zext i16 %70 to i32
  %call99 = call %struct.op* @Perl_ref(%struct.op* %68, i32 %conv98)
  %71 = load i32, i32* %type.addr, align 4
  %cmp100 = icmp eq i32 %71, 15
  br i1 %cmp100, label %if.then.108, label %lor.lhs.false.102

lor.lhs.false.102:                                ; preds = %sw.bb.95
  %72 = load i32, i32* %type.addr, align 4
  %cmp103 = icmp eq i32 %72, 125
  br i1 %cmp103, label %if.then.108, label %lor.lhs.false.105

lor.lhs.false.105:                                ; preds = %lor.lhs.false.102
  %73 = load i32, i32* %type.addr, align 4
  %cmp106 = icmp eq i32 %73, 134
  br i1 %cmp106, label %if.then.108, label %if.end.126

if.then.108:                                      ; preds = %lor.lhs.false.105, %lor.lhs.false.102, %sw.bb.95
  %74 = load i32, i32* %type.addr, align 4
  %cmp109 = icmp eq i32 %74, 125
  br i1 %cmp109, label %cond.true.111, label %cond.false.112

cond.true.111:                                    ; preds = %if.then.108
  br label %cond.end.116

cond.false.112:                                   ; preds = %if.then.108
  %75 = load i32, i32* %type.addr, align 4
  %cmp113 = icmp eq i32 %75, 134
  %cond115 = select i1 %cmp113, i32 64, i32 96
  br label %cond.end.116

cond.end.116:                                     ; preds = %cond.false.112, %cond.true.111
  %cond117 = phi i32 [ 32, %cond.true.111 ], [ %cond115, %cond.false.112 ]
  %76 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private118 = getelementptr inbounds %struct.op, %struct.op* %76, i32 0, i32 7
  %77 = load i8, i8* %op_private118, align 1
  %conv119 = zext i8 %77 to i32
  %or120 = or i32 %conv119, %cond117
  %conv121 = trunc i32 %or120 to i8
  store i8 %conv121, i8* %op_private118, align 1
  %78 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags122 = getelementptr inbounds %struct.op, %struct.op* %78, i32 0, i32 6
  %79 = load i8, i8* %op_flags122, align 1
  %conv123 = zext i8 %79 to i32
  %or124 = or i32 %conv123, 32
  %conv125 = trunc i32 %or124 to i8
  store i8 %conv125, i8* %op_flags122, align 1
  br label %if.end.126

if.end.126:                                       ; preds = %cond.end.116, %lor.lhs.false.105
  br label %sw.epilog

sw.bb.127:                                        ; preds = %if.end, %if.end, %if.end, %if.end
  %80 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags128 = getelementptr inbounds %struct.op, %struct.op* %80, i32 0, i32 6
  %81 = load i8, i8* %op_flags128, align 1
  %conv129 = zext i8 %81 to i32
  %and130 = and i32 %conv129, 4
  %tobool131 = icmp ne i32 %and130, 0
  br i1 %tobool131, label %if.end.133, label %if.then.132

if.then.132:                                      ; preds = %sw.bb.127
  br label %sw.epilog

if.end.133:                                       ; preds = %sw.bb.127
  %82 = load %struct.op*, %struct.op** %o.addr, align 8
  %83 = bitcast %struct.op* %82 to %struct.listop*
  %op_last = getelementptr inbounds %struct.listop, %struct.listop* %83, i32 0, i32 9
  %84 = load %struct.op*, %struct.op** %op_last, align 8
  %85 = load i32, i32* %type.addr, align 4
  %call134 = call %struct.op* @Perl_ref(%struct.op* %84, i32 %85)
  br label %sw.epilog

sw.default:                                       ; preds = %if.end
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.end.133, %if.then.132, %if.end.126, %if.end.92, %if.then.91, %sw.bb.81, %if.end.76, %sw.bb.58, %if.end.57, %for.end, %if.end.17
  %86 = load %struct.op*, %struct.op** %o.addr, align 8
  %call135 = call %struct.op* @Perl_scalar(%struct.op* %86)
  store %struct.op* %call135, %struct.op** %retval
  br label %return

return:                                           ; preds = %sw.epilog, %if.then
  %87 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %87
}

declare %struct.sv** @Perl_av_fetch(%struct.av*, i32, i32) #1

declare i8* @Perl_sv_2pv_nolen(%struct.sv*) #1

declare i64 @Perl_pad_alloc(i32, i32) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_refkids(%struct.op* %o, i32 %type) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  %type.addr = alloca i32, align 4
  %kid = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  store i32 %type, i32* %type.addr, align 4
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %tobool = icmp ne %struct.op* %0, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 6
  %2 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 4
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %3 = load %struct.op*, %struct.op** %o.addr, align 8
  %4 = bitcast %struct.op* %3 to %struct.listop*
  %op_first = getelementptr inbounds %struct.listop, %struct.listop* %4, i32 0, i32 8
  %5 = load %struct.op*, %struct.op** %op_first, align 8
  store %struct.op* %5, %struct.op** %kid, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %6 = load %struct.op*, %struct.op** %kid, align 8
  %tobool2 = icmp ne %struct.op* %6, null
  br i1 %tobool2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load %struct.op*, %struct.op** %kid, align 8
  %8 = load i32, i32* %type.addr, align 4
  %call = call %struct.op* @Perl_ref(%struct.op* %7, i32 %8)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %9 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %9, i32 0, i32 1
  %10 = load %struct.op*, %struct.op** %op_sibling, align 8
  store %struct.op* %10, %struct.op** %kid, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end

if.end:                                           ; preds = %for.end, %land.lhs.true, %entry
  %11 = load %struct.op*, %struct.op** %o.addr, align 8
  ret %struct.op* %11
}

; Function Attrs: nounwind uwtable
define void @Perl_apply_attrs_string(i8* %stashpv, %struct.cv* %cv, i8* %attrstr, i64 %len) #0 {
entry:
  %stashpv.addr = alloca i8*, align 8
  %cv.addr = alloca %struct.cv*, align 8
  %attrstr.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %attrs = alloca %struct.op*, align 8
  %sstr = alloca i8*, align 8
  store i8* %stashpv, i8** %stashpv.addr, align 8
  store %struct.cv* %cv, %struct.cv** %cv.addr, align 8
  store i8* %attrstr, i8** %attrstr.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store %struct.op* null, %struct.op** %attrs, align 8
  %0 = load i64, i64* %len.addr, align 8
  %tobool = icmp ne i64 %0, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load i8*, i8** %attrstr.addr, align 8
  %call = call i64 @strlen(i8* %1)
  store i64 %call, i64* %len.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  br label %while.cond

while.cond:                                       ; preds = %if.end.52, %if.end
  %2 = load i64, i64* %len.addr, align 8
  %tobool1 = icmp ne i64 %2, 0
  br i1 %tobool1, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %while.body
  %3 = load i8*, i8** %attrstr.addr, align 8
  %4 = load i8, i8* %3, align 1
  %conv = sext i8 %4 to i32
  %cmp = icmp eq i32 %conv, 32
  br i1 %cmp, label %land.rhs, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.cond
  %5 = load i8*, i8** %attrstr.addr, align 8
  %6 = load i8, i8* %5, align 1
  %conv3 = sext i8 %6 to i32
  %cmp4 = icmp eq i32 %conv3, 9
  br i1 %cmp4, label %land.rhs, label %lor.lhs.false.6

lor.lhs.false.6:                                  ; preds = %lor.lhs.false
  %7 = load i8*, i8** %attrstr.addr, align 8
  %8 = load i8, i8* %7, align 1
  %conv7 = sext i8 %8 to i32
  %cmp8 = icmp eq i32 %conv7, 10
  br i1 %cmp8, label %land.rhs, label %lor.lhs.false.10

lor.lhs.false.10:                                 ; preds = %lor.lhs.false.6
  %9 = load i8*, i8** %attrstr.addr, align 8
  %10 = load i8, i8* %9, align 1
  %conv11 = sext i8 %10 to i32
  %cmp12 = icmp eq i32 %conv11, 13
  br i1 %cmp12, label %land.rhs, label %lor.lhs.false.14

lor.lhs.false.14:                                 ; preds = %lor.lhs.false.10
  %11 = load i8*, i8** %attrstr.addr, align 8
  %12 = load i8, i8* %11, align 1
  %conv15 = sext i8 %12 to i32
  %cmp16 = icmp eq i32 %conv15, 12
  br i1 %cmp16, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %lor.lhs.false.14, %lor.lhs.false.10, %lor.lhs.false.6, %lor.lhs.false, %for.cond
  %13 = load i64, i64* %len.addr, align 8
  %tobool18 = icmp ne i64 %13, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %lor.lhs.false.14
  %14 = phi i1 [ false, %lor.lhs.false.14 ], [ %tobool18, %land.rhs ]
  br i1 %14, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %15 = load i64, i64* %len.addr, align 8
  %dec = add i64 %15, -1
  store i64 %dec, i64* %len.addr, align 8
  %16 = load i8*, i8** %attrstr.addr, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %16, i32 1
  store i8* %incdec.ptr, i8** %attrstr.addr, align 8
  br label %for.cond

for.end:                                          ; preds = %land.end
  %17 = load i64, i64* %len.addr, align 8
  %tobool19 = icmp ne i64 %17, 0
  br i1 %tobool19, label %if.then.20, label %if.end.52

if.then.20:                                       ; preds = %for.end
  %18 = load i8*, i8** %attrstr.addr, align 8
  store i8* %18, i8** %sstr, align 8
  br label %for.cond.21

for.cond.21:                                      ; preds = %for.inc.45, %if.then.20
  %19 = load i8*, i8** %attrstr.addr, align 8
  %20 = load i8, i8* %19, align 1
  %conv22 = sext i8 %20 to i32
  %cmp23 = icmp eq i32 %conv22, 32
  br i1 %cmp23, label %land.end.43, label %lor.lhs.false.25

lor.lhs.false.25:                                 ; preds = %for.cond.21
  %21 = load i8*, i8** %attrstr.addr, align 8
  %22 = load i8, i8* %21, align 1
  %conv26 = sext i8 %22 to i32
  %cmp27 = icmp eq i32 %conv26, 9
  br i1 %cmp27, label %land.end.43, label %lor.lhs.false.29

lor.lhs.false.29:                                 ; preds = %lor.lhs.false.25
  %23 = load i8*, i8** %attrstr.addr, align 8
  %24 = load i8, i8* %23, align 1
  %conv30 = sext i8 %24 to i32
  %cmp31 = icmp eq i32 %conv30, 10
  br i1 %cmp31, label %land.end.43, label %lor.lhs.false.33

lor.lhs.false.33:                                 ; preds = %lor.lhs.false.29
  %25 = load i8*, i8** %attrstr.addr, align 8
  %26 = load i8, i8* %25, align 1
  %conv34 = sext i8 %26 to i32
  %cmp35 = icmp eq i32 %conv34, 13
  br i1 %cmp35, label %land.end.43, label %lor.lhs.false.37

lor.lhs.false.37:                                 ; preds = %lor.lhs.false.33
  %27 = load i8*, i8** %attrstr.addr, align 8
  %28 = load i8, i8* %27, align 1
  %conv38 = sext i8 %28 to i32
  %cmp39 = icmp eq i32 %conv38, 12
  br i1 %cmp39, label %land.end.43, label %land.rhs.41

land.rhs.41:                                      ; preds = %lor.lhs.false.37
  %29 = load i64, i64* %len.addr, align 8
  %tobool42 = icmp ne i64 %29, 0
  br label %land.end.43

land.end.43:                                      ; preds = %land.rhs.41, %lor.lhs.false.37, %lor.lhs.false.33, %lor.lhs.false.29, %lor.lhs.false.25, %for.cond.21
  %30 = phi i1 [ false, %lor.lhs.false.37 ], [ false, %lor.lhs.false.33 ], [ false, %lor.lhs.false.29 ], [ false, %lor.lhs.false.25 ], [ false, %for.cond.21 ], [ %tobool42, %land.rhs.41 ]
  br i1 %30, label %for.body.44, label %for.end.48

for.body.44:                                      ; preds = %land.end.43
  br label %for.inc.45

for.inc.45:                                       ; preds = %for.body.44
  %31 = load i64, i64* %len.addr, align 8
  %dec46 = add i64 %31, -1
  store i64 %dec46, i64* %len.addr, align 8
  %32 = load i8*, i8** %attrstr.addr, align 8
  %incdec.ptr47 = getelementptr inbounds i8, i8* %32, i32 1
  store i8* %incdec.ptr47, i8** %attrstr.addr, align 8
  br label %for.cond.21

for.end.48:                                       ; preds = %land.end.43
  %33 = load %struct.op*, %struct.op** %attrs, align 8
  %34 = load i8*, i8** %sstr, align 8
  %35 = load i8*, i8** %attrstr.addr, align 8
  %36 = load i8*, i8** %sstr, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %35 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %36 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %call49 = call %struct.sv* @Perl_newSVpvn(i8* %34, i64 %sub.ptr.sub)
  %call50 = call %struct.op* @Perl_newSVOP(i32 5, i32 0, %struct.sv* %call49)
  %call51 = call %struct.op* @Perl_append_elem(i32 141, %struct.op* %33, %struct.op* %call50)
  store %struct.op* %call51, %struct.op** %attrs, align 8
  br label %if.end.52

if.end.52:                                        ; preds = %for.end.48, %for.end
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %call53 = call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.23, i32 0, i32 0), i64 10)
  %37 = load i8*, i8** %stashpv.addr, align 8
  %call54 = call %struct.sv* @Perl_newSVpv(i8* %37, i64 0)
  %call55 = call %struct.op* @Perl_newSVOP(i32 5, i32 0, %struct.sv* %call54)
  %38 = load %struct.cv*, %struct.cv** %cv.addr, align 8
  %39 = bitcast %struct.cv* %38 to %struct.sv*
  %call56 = call %struct.sv* @Perl_newRV(%struct.sv* %39)
  %call57 = call %struct.op* @Perl_newSVOP(i32 5, i32 0, %struct.sv* %call56)
  %40 = load %struct.op*, %struct.op** %attrs, align 8
  %call58 = call %struct.op* @Perl_prepend_elem(i32 141, %struct.op* %call57, %struct.op* %40)
  %call59 = call %struct.op* @Perl_prepend_elem(i32 141, %struct.op* %call55, %struct.op* %call58)
  call void (i32, %struct.sv*, %struct.sv*, ...) @Perl_load_module(i32 4, %struct.sv* %call53, %struct.sv* null, %struct.op* %call59)
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_append_elem(i32 %type, %struct.op* %first, %struct.op* %last) #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %type.addr = alloca i32, align 4
  %first.addr = alloca %struct.op*, align 8
  %last.addr = alloca %struct.op*, align 8
  store i32 %type, i32* %type.addr, align 4
  store %struct.op* %first, %struct.op** %first.addr, align 8
  store %struct.op* %last, %struct.op** %last.addr, align 8
  %0 = load %struct.op*, %struct.op** %first.addr, align 8
  %tobool = icmp ne %struct.op* %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load %struct.op*, %struct.op** %last.addr, align 8
  store %struct.op* %1, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.op*, %struct.op** %last.addr, align 8
  %tobool1 = icmp ne %struct.op* %2, null
  br i1 %tobool1, label %if.end.3, label %if.then.2

if.then.2:                                        ; preds = %if.end
  %3 = load %struct.op*, %struct.op** %first.addr, align 8
  store %struct.op* %3, %struct.op** %retval
  br label %return

if.end.3:                                         ; preds = %if.end
  %4 = load %struct.op*, %struct.op** %first.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %4, i32 0, i32 4
  %5 = load i16, i16* %op_type, align 2
  %conv = zext i16 %5 to i32
  %6 = load i32, i32* %type.addr, align 4
  %cmp = icmp ne i32 %conv, %6
  br i1 %cmp, label %if.then.9, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end.3
  %7 = load i32, i32* %type.addr, align 4
  %cmp5 = icmp eq i32 %7, 141
  br i1 %cmp5, label %land.lhs.true, label %if.end.10

land.lhs.true:                                    ; preds = %lor.lhs.false
  %8 = load %struct.op*, %struct.op** %first.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %8, i32 0, i32 6
  %9 = load i8, i8* %op_flags, align 1
  %conv7 = zext i8 %9 to i32
  %and = and i32 %conv7, 8
  %tobool8 = icmp ne i32 %and, 0
  br i1 %tobool8, label %if.then.9, label %if.end.10

if.then.9:                                        ; preds = %land.lhs.true, %if.end.3
  %10 = load i32, i32* %type.addr, align 4
  %11 = load %struct.op*, %struct.op** %first.addr, align 8
  %12 = load %struct.op*, %struct.op** %last.addr, align 8
  %call = call %struct.op* @Perl_newLISTOP(i32 %10, i32 0, %struct.op* %11, %struct.op* %12)
  store %struct.op* %call, %struct.op** %retval
  br label %return

if.end.10:                                        ; preds = %land.lhs.true, %lor.lhs.false
  %13 = load %struct.op*, %struct.op** %first.addr, align 8
  %op_flags11 = getelementptr inbounds %struct.op, %struct.op* %13, i32 0, i32 6
  %14 = load i8, i8* %op_flags11, align 1
  %conv12 = zext i8 %14 to i32
  %and13 = and i32 %conv12, 4
  %tobool14 = icmp ne i32 %and13, 0
  br i1 %tobool14, label %if.then.15, label %if.else

if.then.15:                                       ; preds = %if.end.10
  %15 = load %struct.op*, %struct.op** %last.addr, align 8
  %16 = load %struct.op*, %struct.op** %first.addr, align 8
  %17 = bitcast %struct.op* %16 to %struct.listop*
  %op_last = getelementptr inbounds %struct.listop, %struct.listop* %17, i32 0, i32 9
  %18 = load %struct.op*, %struct.op** %op_last, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %18, i32 0, i32 1
  store %struct.op* %15, %struct.op** %op_sibling, align 8
  br label %if.end.19

if.else:                                          ; preds = %if.end.10
  %19 = load %struct.op*, %struct.op** %first.addr, align 8
  %op_flags16 = getelementptr inbounds %struct.op, %struct.op* %19, i32 0, i32 6
  %20 = load i8, i8* %op_flags16, align 1
  %conv17 = zext i8 %20 to i32
  %or = or i32 %conv17, 4
  %conv18 = trunc i32 %or to i8
  store i8 %conv18, i8* %op_flags16, align 1
  %21 = load %struct.op*, %struct.op** %last.addr, align 8
  %22 = load %struct.op*, %struct.op** %first.addr, align 8
  %23 = bitcast %struct.op* %22 to %struct.listop*
  %op_first = getelementptr inbounds %struct.listop, %struct.listop* %23, i32 0, i32 8
  store %struct.op* %21, %struct.op** %op_first, align 8
  br label %if.end.19

if.end.19:                                        ; preds = %if.else, %if.then.15
  %24 = load %struct.op*, %struct.op** %last.addr, align 8
  %25 = load %struct.op*, %struct.op** %first.addr, align 8
  %26 = bitcast %struct.op* %25 to %struct.listop*
  %op_last20 = getelementptr inbounds %struct.listop, %struct.listop* %26, i32 0, i32 9
  store %struct.op* %24, %struct.op** %op_last20, align 8
  %27 = load %struct.op*, %struct.op** %first.addr, align 8
  store %struct.op* %27, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.19, %if.then.9, %if.then.2, %if.then
  %28 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %28
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newSVOP(i32 %type, i32 %flags, %struct.sv* %sv) #0 {
entry:
  %type.addr = alloca i32, align 4
  %flags.addr = alloca i32, align 4
  %sv.addr = alloca %struct.sv*, align 8
  %svop = alloca %struct.svop*, align 8
  store i32 %type, i32* %type.addr, align 4
  store i32 %flags, i32* %flags.addr, align 4
  store %struct.sv* %sv, %struct.sv** %sv.addr, align 8
  %call = call i8* @Perl_safesysmalloc(i64 48)
  %0 = bitcast i8* %call to %struct.svop*
  store %struct.svop* %0, %struct.svop** %svop, align 8
  %1 = load %struct.svop*, %struct.svop** %svop, align 8
  %2 = bitcast %struct.svop* %1 to i8*
  call void @llvm.memset.p0i8.i64(i8* %2, i8 0, i64 48, i32 1, i1 false)
  %3 = load i32, i32* %type.addr, align 4
  %conv = trunc i32 %3 to i16
  %4 = load %struct.svop*, %struct.svop** %svop, align 8
  %op_type = getelementptr inbounds %struct.svop, %struct.svop* %4, i32 0, i32 4
  store i16 %conv, i16* %op_type, align 2
  %5 = load i32, i32* %type.addr, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds [0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 %idxprom
  %6 = load %struct.op* ()*, %struct.op* ()** %arrayidx, align 8
  %7 = load %struct.svop*, %struct.svop** %svop, align 8
  %op_ppaddr = getelementptr inbounds %struct.svop, %struct.svop* %7, i32 0, i32 2
  store %struct.op* ()* %6, %struct.op* ()** %op_ppaddr, align 8
  %8 = load %struct.sv*, %struct.sv** %sv.addr, align 8
  %9 = load %struct.svop*, %struct.svop** %svop, align 8
  %op_sv = getelementptr inbounds %struct.svop, %struct.svop* %9, i32 0, i32 8
  store %struct.sv* %8, %struct.sv** %op_sv, align 8
  %10 = load %struct.svop*, %struct.svop** %svop, align 8
  %11 = bitcast %struct.svop* %10 to %struct.op*
  %12 = load %struct.svop*, %struct.svop** %svop, align 8
  %op_next = getelementptr inbounds %struct.svop, %struct.svop* %12, i32 0, i32 0
  store %struct.op* %11, %struct.op** %op_next, align 8
  %13 = load i32, i32* %flags.addr, align 4
  %conv1 = trunc i32 %13 to i8
  %14 = load %struct.svop*, %struct.svop** %svop, align 8
  %op_flags = getelementptr inbounds %struct.svop, %struct.svop* %14, i32 0, i32 6
  store i8 %conv1, i8* %op_flags, align 1
  %15 = load i32, i32* %type.addr, align 4
  %idxprom2 = sext i32 %15 to i64
  %arrayidx3 = getelementptr inbounds [0 x i32], [0 x i32]* @PL_opargs, i32 0, i64 %idxprom2
  %16 = load i32, i32* %arrayidx3, align 4
  %and = and i32 %16, 4
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %17 = load %struct.svop*, %struct.svop** %svop, align 8
  %18 = bitcast %struct.svop* %17 to %struct.op*
  %call4 = call %struct.op* @Perl_scalar(%struct.op* %18)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %19 = load i32, i32* %type.addr, align 4
  %idxprom5 = sext i32 %19 to i64
  %arrayidx6 = getelementptr inbounds [0 x i32], [0 x i32]* @PL_opargs, i32 0, i64 %idxprom5
  %20 = load i32, i32* %arrayidx6, align 4
  %and7 = and i32 %20, 8
  %tobool8 = icmp ne i32 %and7, 0
  br i1 %tobool8, label %if.then.9, label %if.end.11

if.then.9:                                        ; preds = %if.end
  %21 = load i32, i32* %type.addr, align 4
  %call10 = call i64 @Perl_pad_alloc(i32 %21, i32 512)
  %22 = load %struct.svop*, %struct.svop** %svop, align 8
  %op_targ = getelementptr inbounds %struct.svop, %struct.svop* %22, i32 0, i32 3
  store i64 %call10, i64* %op_targ, align 8
  br label %if.end.11

if.end.11:                                        ; preds = %if.then.9, %if.end
  %23 = load i8*, i8** @PL_op_mask, align 8
  %tobool12 = icmp ne i8* %23, null
  br i1 %tobool12, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %if.end.11
  %24 = load i32, i32* %type.addr, align 4
  %idxprom13 = sext i32 %24 to i64
  %25 = load i8*, i8** @PL_op_mask, align 8
  %arrayidx14 = getelementptr inbounds i8, i8* %25, i64 %idxprom13
  %26 = load i8, i8* %arrayidx14, align 1
  %conv15 = sext i8 %26 to i32
  %tobool16 = icmp ne i32 %conv15, 0
  br i1 %tobool16, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true
  %27 = load %struct.svop*, %struct.svop** %svop, align 8
  %28 = bitcast %struct.svop* %27 to %struct.op*
  call void @Perl_op_free(%struct.op* %28)
  %29 = load i32, i32* %type.addr, align 4
  %idxprom17 = sext i32 %29 to i64
  %arrayidx18 = getelementptr inbounds [0 x i8*], [0 x i8*]* @PL_op_desc, i32 0, i64 %idxprom17
  %30 = load i8*, i8** %arrayidx18, align 8
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.33, i32 0, i32 0), i8* %30)
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %if.end.11
  %31 = load i32, i32* %type.addr, align 4
  %idxprom19 = sext i32 %31 to i64
  %arrayidx20 = getelementptr inbounds [0 x %struct.op* (%struct.op*)*], [0 x %struct.op* (%struct.op*)*]* @PL_check, i32 0, i64 %idxprom19
  %32 = load %struct.op* (%struct.op*)*, %struct.op* (%struct.op*)** %arrayidx20, align 8
  %33 = load %struct.svop*, %struct.svop** %svop, align 8
  %34 = bitcast %struct.svop* %33 to %struct.op*
  %call21 = call %struct.op* %32(%struct.op* %34)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.op* [ null, %cond.true ], [ %call21, %cond.false ]
  ret %struct.op* %cond
}

declare %struct.sv* @Perl_newSVpvn(i8*, i64) #1

; Function Attrs: nounwind uwtable
define void @Perl_load_module(i32 %flags, %struct.sv* %name, %struct.sv* %ver, ...) #0 {
entry:
  %flags.addr = alloca i32, align 4
  %name.addr = alloca %struct.sv*, align 8
  %ver.addr = alloca %struct.sv*, align 8
  %args = alloca [1 x %struct.__va_list_tag], align 16
  store i32 %flags, i32* %flags.addr, align 4
  store %struct.sv* %name, %struct.sv** %name.addr, align 8
  store %struct.sv* %ver, %struct.sv** %ver.addr, align 8
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i32 0, i32 0
  %arraydecay1 = bitcast %struct.__va_list_tag* %arraydecay to i8*
  call void @llvm.va_start(i8* %arraydecay1)
  %0 = load i32, i32* %flags.addr, align 4
  %1 = load %struct.sv*, %struct.sv** %name.addr, align 8
  %2 = load %struct.sv*, %struct.sv** %ver.addr, align 8
  call void @Perl_vload_module(i32 %0, %struct.sv* %1, %struct.sv* %2, [1 x %struct.__va_list_tag]* %args)
  %arraydecay2 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %args, i32 0, i32 0
  %arraydecay23 = bitcast %struct.__va_list_tag* %arraydecay2 to i8*
  call void @llvm.va_end(i8* %arraydecay23)
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_prepend_elem(i32 %type, %struct.op* %first, %struct.op* %last) #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %type.addr = alloca i32, align 4
  %first.addr = alloca %struct.op*, align 8
  %last.addr = alloca %struct.op*, align 8
  store i32 %type, i32* %type.addr, align 4
  store %struct.op* %first, %struct.op** %first.addr, align 8
  store %struct.op* %last, %struct.op** %last.addr, align 8
  %0 = load %struct.op*, %struct.op** %first.addr, align 8
  %tobool = icmp ne %struct.op* %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load %struct.op*, %struct.op** %last.addr, align 8
  store %struct.op* %1, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.op*, %struct.op** %last.addr, align 8
  %tobool1 = icmp ne %struct.op* %2, null
  br i1 %tobool1, label %if.end.3, label %if.then.2

if.then.2:                                        ; preds = %if.end
  %3 = load %struct.op*, %struct.op** %first.addr, align 8
  store %struct.op* %3, %struct.op** %retval
  br label %return

if.end.3:                                         ; preds = %if.end
  %4 = load %struct.op*, %struct.op** %last.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %4, i32 0, i32 4
  %5 = load i16, i16* %op_type, align 2
  %conv = zext i16 %5 to i32
  %6 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %conv, %6
  br i1 %cmp, label %if.then.5, label %if.end.37

if.then.5:                                        ; preds = %if.end.3
  %7 = load i32, i32* %type.addr, align 4
  %cmp6 = icmp eq i32 %7, 141
  br i1 %cmp6, label %if.then.8, label %if.else

if.then.8:                                        ; preds = %if.then.5
  %8 = load %struct.op*, %struct.op** %last.addr, align 8
  %9 = bitcast %struct.op* %8 to %struct.listop*
  %op_first = getelementptr inbounds %struct.listop, %struct.listop* %9, i32 0, i32 8
  %10 = load %struct.op*, %struct.op** %op_first, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %10, i32 0, i32 1
  %11 = load %struct.op*, %struct.op** %op_sibling, align 8
  %12 = load %struct.op*, %struct.op** %first.addr, align 8
  %op_sibling9 = getelementptr inbounds %struct.op, %struct.op* %12, i32 0, i32 1
  store %struct.op* %11, %struct.op** %op_sibling9, align 8
  %13 = load %struct.op*, %struct.op** %first.addr, align 8
  %14 = load %struct.op*, %struct.op** %last.addr, align 8
  %15 = bitcast %struct.op* %14 to %struct.listop*
  %op_first10 = getelementptr inbounds %struct.listop, %struct.listop* %15, i32 0, i32 8
  %16 = load %struct.op*, %struct.op** %op_first10, align 8
  %op_sibling11 = getelementptr inbounds %struct.op, %struct.op* %16, i32 0, i32 1
  store %struct.op* %13, %struct.op** %op_sibling11, align 8
  %17 = load %struct.op*, %struct.op** %first.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %17, i32 0, i32 6
  %18 = load i8, i8* %op_flags, align 1
  %conv12 = zext i8 %18 to i32
  %and = and i32 %conv12, 8
  %tobool13 = icmp ne i32 %and, 0
  br i1 %tobool13, label %if.end.19, label %if.then.14

if.then.14:                                       ; preds = %if.then.8
  %19 = load %struct.op*, %struct.op** %last.addr, align 8
  %op_flags15 = getelementptr inbounds %struct.op, %struct.op* %19, i32 0, i32 6
  %20 = load i8, i8* %op_flags15, align 1
  %conv16 = zext i8 %20 to i32
  %and17 = and i32 %conv16, -9
  %conv18 = trunc i32 %and17 to i8
  store i8 %conv18, i8* %op_flags15, align 1
  br label %if.end.19

if.end.19:                                        ; preds = %if.then.14, %if.then.8
  br label %if.end.32

if.else:                                          ; preds = %if.then.5
  %21 = load %struct.op*, %struct.op** %last.addr, align 8
  %op_flags20 = getelementptr inbounds %struct.op, %struct.op* %21, i32 0, i32 6
  %22 = load i8, i8* %op_flags20, align 1
  %conv21 = zext i8 %22 to i32
  %and22 = and i32 %conv21, 4
  %tobool23 = icmp ne i32 %and22, 0
  br i1 %tobool23, label %if.end.28, label %if.then.24

if.then.24:                                       ; preds = %if.else
  %23 = load %struct.op*, %struct.op** %first.addr, align 8
  %24 = load %struct.op*, %struct.op** %last.addr, align 8
  %25 = bitcast %struct.op* %24 to %struct.listop*
  %op_last = getelementptr inbounds %struct.listop, %struct.listop* %25, i32 0, i32 9
  store %struct.op* %23, %struct.op** %op_last, align 8
  %26 = load %struct.op*, %struct.op** %last.addr, align 8
  %op_flags25 = getelementptr inbounds %struct.op, %struct.op* %26, i32 0, i32 6
  %27 = load i8, i8* %op_flags25, align 1
  %conv26 = zext i8 %27 to i32
  %or = or i32 %conv26, 4
  %conv27 = trunc i32 %or to i8
  store i8 %conv27, i8* %op_flags25, align 1
  br label %if.end.28

if.end.28:                                        ; preds = %if.then.24, %if.else
  %28 = load %struct.op*, %struct.op** %last.addr, align 8
  %29 = bitcast %struct.op* %28 to %struct.listop*
  %op_first29 = getelementptr inbounds %struct.listop, %struct.listop* %29, i32 0, i32 8
  %30 = load %struct.op*, %struct.op** %op_first29, align 8
  %31 = load %struct.op*, %struct.op** %first.addr, align 8
  %op_sibling30 = getelementptr inbounds %struct.op, %struct.op* %31, i32 0, i32 1
  store %struct.op* %30, %struct.op** %op_sibling30, align 8
  %32 = load %struct.op*, %struct.op** %first.addr, align 8
  %33 = load %struct.op*, %struct.op** %last.addr, align 8
  %34 = bitcast %struct.op* %33 to %struct.listop*
  %op_first31 = getelementptr inbounds %struct.listop, %struct.listop* %34, i32 0, i32 8
  store %struct.op* %32, %struct.op** %op_first31, align 8
  br label %if.end.32

if.end.32:                                        ; preds = %if.end.28, %if.end.19
  %35 = load %struct.op*, %struct.op** %last.addr, align 8
  %op_flags33 = getelementptr inbounds %struct.op, %struct.op* %35, i32 0, i32 6
  %36 = load i8, i8* %op_flags33, align 1
  %conv34 = zext i8 %36 to i32
  %or35 = or i32 %conv34, 4
  %conv36 = trunc i32 %or35 to i8
  store i8 %conv36, i8* %op_flags33, align 1
  %37 = load %struct.op*, %struct.op** %last.addr, align 8
  store %struct.op* %37, %struct.op** %retval
  br label %return

if.end.37:                                        ; preds = %if.end.3
  %38 = load i32, i32* %type.addr, align 4
  %39 = load %struct.op*, %struct.op** %first.addr, align 8
  %40 = load %struct.op*, %struct.op** %last.addr, align 8
  %call = call %struct.op* @Perl_newLISTOP(i32 %38, i32 0, %struct.op* %39, %struct.op* %40)
  store %struct.op* %call, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.37, %if.end.32, %if.then.2, %if.then
  %41 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %41
}

declare %struct.sv* @Perl_newSVpv(i8*, i64) #1

declare %struct.sv* @Perl_newRV(%struct.sv*) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_my_attrs(%struct.op* %o, %struct.op* %attrs) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  %attrs.addr = alloca %struct.op*, align 8
  %rops = alloca %struct.op*, align 8
  %maybe_scalar = alloca i32, align 4
  store %struct.op* %o, %struct.op** %o.addr, align 8
  store %struct.op* %attrs, %struct.op** %attrs.addr, align 8
  store %struct.op* null, %struct.op** %rops, align 8
  store i32 0, i32* %maybe_scalar, align 4
  store i32 1, i32* %maybe_scalar, align 4
  %0 = load %struct.op*, %struct.op** %attrs.addr, align 8
  %tobool = icmp ne %struct.op* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.op*, %struct.op** %attrs.addr, align 8
  call void @Perl_save_freeop(%struct.op* %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load %struct.op*, %struct.op** %o.addr, align 8
  %3 = load %struct.op*, %struct.op** %attrs.addr, align 8
  %call = call %struct.op* @S_my_kid(%struct.op* %2, %struct.op* %3, %struct.op** %rops)
  store %struct.op* %call, %struct.op** %o.addr, align 8
  %4 = load %struct.op*, %struct.op** %rops, align 8
  %tobool1 = icmp ne %struct.op* %4, null
  br i1 %tobool1, label %if.then.2, label %if.end.12

if.then.2:                                        ; preds = %if.end
  %5 = load i32, i32* %maybe_scalar, align 4
  %tobool3 = icmp ne i32 %5, 0
  br i1 %tobool3, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.then.2
  %6 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %6, i32 0, i32 4
  %7 = load i16, i16* %op_type, align 2
  %conv = zext i16 %7 to i32
  %cmp = icmp eq i32 %conv, 9
  br i1 %cmp, label %if.then.5, label %if.else

if.then.5:                                        ; preds = %land.lhs.true
  %8 = load %struct.op*, %struct.op** %rops, align 8
  %9 = bitcast %struct.op* %8 to %struct.listop*
  %10 = load %struct.op*, %struct.op** %o.addr, align 8
  %11 = bitcast %struct.op* %10 to %struct.listop*
  %call6 = call %struct.op* @Perl_append_list(i32 141, %struct.listop* %9, %struct.listop* %11)
  %call7 = call %struct.op* @Perl_scalar(%struct.op* %call6)
  store %struct.op* %call7, %struct.op** %o.addr, align 8
  %12 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %12, i32 0, i32 7
  %13 = load i8, i8* %op_private, align 1
  %conv8 = zext i8 %13 to i32
  %or = or i32 %conv8, 128
  %conv9 = trunc i32 %or to i8
  store i8 %conv9, i8* %op_private, align 1
  br label %if.end.11

if.else:                                          ; preds = %land.lhs.true, %if.then.2
  %14 = load %struct.op*, %struct.op** %o.addr, align 8
  %15 = bitcast %struct.op* %14 to %struct.listop*
  %16 = load %struct.op*, %struct.op** %rops, align 8
  %17 = bitcast %struct.op* %16 to %struct.listop*
  %call10 = call %struct.op* @Perl_append_list(i32 141, %struct.listop* %15, %struct.listop* %17)
  store %struct.op* %call10, %struct.op** %o.addr, align 8
  br label %if.end.11

if.end.11:                                        ; preds = %if.else, %if.then.5
  br label %if.end.12

if.end.12:                                        ; preds = %if.end.11, %if.end
  store i32 0, i32* @PL_in_my, align 4
  store %struct.hv* null, %struct.hv** @PL_in_my_stash, align 8
  %18 = load %struct.op*, %struct.op** %o.addr, align 8
  ret %struct.op* %18
}

declare void @Perl_save_freeop(%struct.op*) #1

; Function Attrs: nounwind uwtable
define internal %struct.op* @S_my_kid(%struct.op* %o, %struct.op* %attrs, %struct.op** %imopsp) #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %o.addr = alloca %struct.op*, align 8
  %attrs.addr = alloca %struct.op*, align 8
  %imopsp.addr = alloca %struct.op**, align 8
  %kid = alloca %struct.op*, align 8
  %type = alloca i32, align 4
  %gv = alloca %struct.gv*, align 8
  %stash = alloca %struct.hv*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  store %struct.op* %attrs, %struct.op** %attrs.addr, align 8
  store %struct.op** %imopsp, %struct.op*** %imopsp.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %tobool = icmp ne %struct.op* %0, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* @PL_error_count, align 4
  %tobool1 = icmp ne i32 %1, 0
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %2 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %2, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %3 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %3, i32 0, i32 4
  %4 = load i16, i16* %op_type, align 2
  %conv = zext i16 %4 to i32
  store i32 %conv, i32* %type, align 4
  %5 = load i32, i32* %type, align 4
  %cmp = icmp eq i32 %5, 141
  br i1 %cmp, label %if.then.3, label %if.else

if.then.3:                                        ; preds = %if.end
  %6 = load %struct.op*, %struct.op** %o.addr, align 8
  %7 = bitcast %struct.op* %6 to %struct.listop*
  %op_first = getelementptr inbounds %struct.listop, %struct.listop* %7, i32 0, i32 8
  %8 = load %struct.op*, %struct.op** %op_first, align 8
  store %struct.op* %8, %struct.op** %kid, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then.3
  %9 = load %struct.op*, %struct.op** %kid, align 8
  %tobool4 = icmp ne %struct.op* %9, null
  br i1 %tobool4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load %struct.op*, %struct.op** %kid, align 8
  %11 = load %struct.op*, %struct.op** %attrs.addr, align 8
  %12 = load %struct.op**, %struct.op*** %imopsp.addr, align 8
  %call = call %struct.op* @S_my_kid(%struct.op* %10, %struct.op* %11, %struct.op** %12)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %13 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %13, i32 0, i32 1
  %14 = load %struct.op*, %struct.op** %op_sibling, align 8
  store %struct.op* %14, %struct.op** %kid, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end.119

if.else:                                          ; preds = %if.end
  %15 = load i32, i32* %type, align 4
  %cmp5 = icmp eq i32 %15, 43
  br i1 %cmp5, label %if.then.7, label %if.else.8

if.then.7:                                        ; preds = %if.else
  %16 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %16, %struct.op** %retval
  br label %return

if.else.8:                                        ; preds = %if.else
  %17 = load i32, i32* %type, align 4
  %cmp9 = icmp eq i32 %17, 15
  br i1 %cmp9, label %if.then.17, label %lor.lhs.false.11

lor.lhs.false.11:                                 ; preds = %if.else.8
  %18 = load i32, i32* %type, align 4
  %cmp12 = icmp eq i32 %18, 125
  br i1 %cmp12, label %if.then.17, label %lor.lhs.false.14

lor.lhs.false.14:                                 ; preds = %lor.lhs.false.11
  %19 = load i32, i32* %type, align 4
  %cmp15 = icmp eq i32 %19, 134
  br i1 %cmp15, label %if.then.17, label %if.else.66

if.then.17:                                       ; preds = %lor.lhs.false.14, %lor.lhs.false.11, %if.else.8
  %20 = load %struct.op*, %struct.op** %o.addr, align 8
  %21 = bitcast %struct.op* %20 to %struct.unop*
  %op_first18 = getelementptr inbounds %struct.unop, %struct.unop* %21, i32 0, i32 8
  %22 = load %struct.op*, %struct.op** %op_first18, align 8
  %op_type19 = getelementptr inbounds %struct.op, %struct.op* %22, i32 0, i32 4
  %23 = load i16, i16* %op_type19, align 2
  %conv20 = zext i16 %23 to i32
  %cmp21 = icmp ne i32 %conv20, 7
  br i1 %cmp21, label %if.then.23, label %if.else.35

if.then.23:                                       ; preds = %if.then.17
  %24 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type24 = getelementptr inbounds %struct.op, %struct.op* %24, i32 0, i32 4
  %25 = load i16, i16* %op_type24, align 2
  %conv25 = zext i16 %25 to i32
  %cmp26 = icmp eq i32 %conv25, 351
  br i1 %cmp26, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.23
  %26 = load %struct.op*, %struct.op** %o.addr, align 8
  %call28 = call i8* @Perl_custom_op_desc(%struct.op* %26)
  br label %cond.end

cond.false:                                       ; preds = %if.then.23
  %27 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type29 = getelementptr inbounds %struct.op, %struct.op* %27, i32 0, i32 4
  %28 = load i16, i16* %op_type29, align 2
  %idxprom = zext i16 %28 to i64
  %arrayidx = getelementptr inbounds [0 x i8*], [0 x i8*]* @PL_op_desc, i32 0, i64 %idxprom
  %29 = load i8*, i8** %arrayidx, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %call28, %cond.true ], [ %29, %cond.false ]
  %30 = load i32, i32* @PL_in_my, align 4
  %cmp30 = icmp eq i32 %30, 137
  %cond32 = select i1 %cmp30, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.4, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.5, i32 0, i32 0)
  %call33 = call i8* (i8*, ...) @Perl_form(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.141, i32 0, i32 0), i8* %cond, i8* %cond32)
  %call34 = call i32 @Perl_yyerror(i8* %call33)
  br label %if.end.63

if.else.35:                                       ; preds = %if.then.17
  %31 = load %struct.op*, %struct.op** %attrs.addr, align 8
  %tobool36 = icmp ne %struct.op* %31, null
  br i1 %tobool36, label %if.then.37, label %if.end.62

if.then.37:                                       ; preds = %if.else.35
  %32 = load %struct.op*, %struct.op** %o.addr, align 8
  %33 = bitcast %struct.op* %32 to %struct.unop*
  %op_first38 = getelementptr inbounds %struct.unop, %struct.unop* %33, i32 0, i32 8
  %34 = load %struct.op*, %struct.op** %op_first38, align 8
  %35 = bitcast %struct.op* %34 to %struct.svop*
  %op_sv = getelementptr inbounds %struct.svop, %struct.svop* %35, i32 0, i32 8
  %36 = load %struct.sv*, %struct.sv** %op_sv, align 8
  %37 = bitcast %struct.sv* %36 to %struct.gv*
  store %struct.gv* %37, %struct.gv** %gv, align 8
  store i32 0, i32* @PL_in_my, align 4
  store %struct.hv* null, %struct.hv** @PL_in_my_stash, align 8
  %38 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any = getelementptr inbounds %struct.gv, %struct.gv* %38, i32 0, i32 0
  %39 = load %struct.xpvgv*, %struct.xpvgv** %sv_any, align 8
  %xgv_stash = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %39, i32 0, i32 10
  %40 = load %struct.hv*, %struct.hv** %xgv_stash, align 8
  %41 = load i32, i32* %type, align 4
  %cmp39 = icmp eq i32 %41, 15
  br i1 %cmp39, label %cond.true.41, label %cond.false.43

cond.true.41:                                     ; preds = %if.then.37
  %42 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any42 = getelementptr inbounds %struct.gv, %struct.gv* %42, i32 0, i32 0
  %43 = load %struct.xpvgv*, %struct.xpvgv** %sv_any42, align 8
  %xgv_gp = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %43, i32 0, i32 7
  %44 = load %struct.gp*, %struct.gp** %xgv_gp, align 8
  %gp_sv = getelementptr inbounds %struct.gp, %struct.gp* %44, i32 0, i32 0
  %45 = load %struct.sv*, %struct.sv** %gp_sv, align 8
  br label %cond.end.60

cond.false.43:                                    ; preds = %if.then.37
  %46 = load i32, i32* %type, align 4
  %cmp44 = icmp eq i32 %46, 125
  br i1 %cmp44, label %cond.true.46, label %cond.false.49

cond.true.46:                                     ; preds = %cond.false.43
  %47 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any47 = getelementptr inbounds %struct.gv, %struct.gv* %47, i32 0, i32 0
  %48 = load %struct.xpvgv*, %struct.xpvgv** %sv_any47, align 8
  %xgv_gp48 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %48, i32 0, i32 7
  %49 = load %struct.gp*, %struct.gp** %xgv_gp48, align 8
  %gp_av = getelementptr inbounds %struct.gp, %struct.gp* %49, i32 0, i32 4
  %50 = load %struct.av*, %struct.av** %gp_av, align 8
  %51 = bitcast %struct.av* %50 to %struct.sv*
  br label %cond.end.58

cond.false.49:                                    ; preds = %cond.false.43
  %52 = load i32, i32* %type, align 4
  %cmp50 = icmp eq i32 %52, 134
  br i1 %cmp50, label %cond.true.52, label %cond.false.55

cond.true.52:                                     ; preds = %cond.false.49
  %53 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any53 = getelementptr inbounds %struct.gv, %struct.gv* %53, i32 0, i32 0
  %54 = load %struct.xpvgv*, %struct.xpvgv** %sv_any53, align 8
  %xgv_gp54 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %54, i32 0, i32 7
  %55 = load %struct.gp*, %struct.gp** %xgv_gp54, align 8
  %gp_hv = getelementptr inbounds %struct.gp, %struct.gp* %55, i32 0, i32 5
  %56 = load %struct.hv*, %struct.hv** %gp_hv, align 8
  %57 = bitcast %struct.hv* %56 to %struct.sv*
  br label %cond.end.56

cond.false.55:                                    ; preds = %cond.false.49
  %58 = load %struct.gv*, %struct.gv** %gv, align 8
  %59 = bitcast %struct.gv* %58 to %struct.sv*
  br label %cond.end.56

cond.end.56:                                      ; preds = %cond.false.55, %cond.true.52
  %cond57 = phi %struct.sv* [ %57, %cond.true.52 ], [ %59, %cond.false.55 ]
  br label %cond.end.58

cond.end.58:                                      ; preds = %cond.end.56, %cond.true.46
  %cond59 = phi %struct.sv* [ %51, %cond.true.46 ], [ %cond57, %cond.end.56 ]
  br label %cond.end.60

cond.end.60:                                      ; preds = %cond.end.58, %cond.true.41
  %cond61 = phi %struct.sv* [ %45, %cond.true.41 ], [ %cond59, %cond.end.58 ]
  %60 = load %struct.op*, %struct.op** %attrs.addr, align 8
  call void @S_apply_attrs(%struct.hv* %40, %struct.sv* %cond61, %struct.op* %60, i8 signext 0)
  br label %if.end.62

if.end.62:                                        ; preds = %cond.end.60, %if.else.35
  br label %if.end.63

if.end.63:                                        ; preds = %if.end.62, %cond.end
  %61 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %61, i32 0, i32 7
  %62 = load i8, i8* %op_private, align 1
  %conv64 = zext i8 %62 to i32
  %or = or i32 %conv64, 16
  %conv65 = trunc i32 %or to i8
  store i8 %conv65, i8* %op_private, align 1
  %63 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %63, %struct.op** %retval
  br label %return

if.else.66:                                       ; preds = %lor.lhs.false.14
  %64 = load i32, i32* %type, align 4
  %cmp67 = icmp ne i32 %64, 9
  br i1 %cmp67, label %land.lhs.true, label %if.else.95

land.lhs.true:                                    ; preds = %if.else.66
  %65 = load i32, i32* %type, align 4
  %cmp69 = icmp ne i32 %65, 10
  br i1 %cmp69, label %land.lhs.true.71, label %if.else.95

land.lhs.true.71:                                 ; preds = %land.lhs.true
  %66 = load i32, i32* %type, align 4
  %cmp72 = icmp ne i32 %66, 11
  br i1 %cmp72, label %land.lhs.true.74, label %if.else.95

land.lhs.true.74:                                 ; preds = %land.lhs.true.71
  %67 = load i32, i32* %type, align 4
  %cmp75 = icmp ne i32 %67, 3
  br i1 %cmp75, label %if.then.77, label %if.else.95

if.then.77:                                       ; preds = %land.lhs.true.74
  %68 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type78 = getelementptr inbounds %struct.op, %struct.op* %68, i32 0, i32 4
  %69 = load i16, i16* %op_type78, align 2
  %conv79 = zext i16 %69 to i32
  %cmp80 = icmp eq i32 %conv79, 351
  br i1 %cmp80, label %cond.true.82, label %cond.false.84

cond.true.82:                                     ; preds = %if.then.77
  %70 = load %struct.op*, %struct.op** %o.addr, align 8
  %call83 = call i8* @Perl_custom_op_desc(%struct.op* %70)
  br label %cond.end.88

cond.false.84:                                    ; preds = %if.then.77
  %71 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type85 = getelementptr inbounds %struct.op, %struct.op* %71, i32 0, i32 4
  %72 = load i16, i16* %op_type85, align 2
  %idxprom86 = zext i16 %72 to i64
  %arrayidx87 = getelementptr inbounds [0 x i8*], [0 x i8*]* @PL_op_desc, i32 0, i64 %idxprom86
  %73 = load i8*, i8** %arrayidx87, align 8
  br label %cond.end.88

cond.end.88:                                      ; preds = %cond.false.84, %cond.true.82
  %cond89 = phi i8* [ %call83, %cond.true.82 ], [ %73, %cond.false.84 ]
  %74 = load i32, i32* @PL_in_my, align 4
  %cmp90 = icmp eq i32 %74, 137
  %cond92 = select i1 %cmp90, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.4, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.5, i32 0, i32 0)
  %call93 = call i8* (i8*, ...) @Perl_form(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.142, i32 0, i32 0), i8* %cond89, i8* %cond92)
  %call94 = call i32 @Perl_yyerror(i8* %call93)
  %75 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %75, %struct.op** %retval
  br label %return

if.else.95:                                       ; preds = %land.lhs.true.74, %land.lhs.true.71, %land.lhs.true, %if.else.66
  %76 = load %struct.op*, %struct.op** %attrs.addr, align 8
  %tobool96 = icmp ne %struct.op* %76, null
  br i1 %tobool96, label %land.lhs.true.97, label %if.end.115

land.lhs.true.97:                                 ; preds = %if.else.95
  %77 = load i32, i32* %type, align 4
  %cmp98 = icmp ne i32 %77, 3
  br i1 %cmp98, label %if.then.100, label %if.end.115

if.then.100:                                      ; preds = %land.lhs.true.97
  store i32 0, i32* @PL_in_my, align 4
  store %struct.hv* null, %struct.hv** @PL_in_my_stash, align 8
  %78 = load %struct.av*, %struct.av** @PL_comppad_name, align 8
  %79 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %79, i32 0, i32 3
  %80 = load i64, i64* %op_targ, align 8
  %conv101 = trunc i64 %80 to i32
  %call102 = call %struct.sv** @Perl_av_fetch(%struct.av* %78, i32 %conv101, i32 0)
  %81 = load %struct.sv*, %struct.sv** %call102, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %81, i32 0, i32 2
  %82 = load i32, i32* %sv_flags, align 4
  %and = and i32 %82, 1073741824
  %tobool103 = icmp ne i32 %and, 0
  br i1 %tobool103, label %cond.true.104, label %cond.false.109

cond.true.104:                                    ; preds = %if.then.100
  %83 = load %struct.av*, %struct.av** @PL_comppad_name, align 8
  %84 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_targ105 = getelementptr inbounds %struct.op, %struct.op* %84, i32 0, i32 3
  %85 = load i64, i64* %op_targ105, align 8
  %conv106 = trunc i64 %85 to i32
  %call107 = call %struct.sv** @Perl_av_fetch(%struct.av* %83, i32 %conv106, i32 0)
  %86 = load %struct.sv*, %struct.sv** %call107, align 8
  %sv_any108 = getelementptr inbounds %struct.sv, %struct.sv* %86, i32 0, i32 0
  %87 = load i8*, i8** %sv_any108, align 8
  %88 = bitcast i8* %87 to %struct.xpvmg*
  %xmg_stash = getelementptr inbounds %struct.xpvmg, %struct.xpvmg* %88, i32 0, i32 6
  %89 = load %struct.hv*, %struct.hv** %xmg_stash, align 8
  br label %cond.end.110

cond.false.109:                                   ; preds = %if.then.100
  br label %cond.end.110

cond.end.110:                                     ; preds = %cond.false.109, %cond.true.104
  %cond111 = phi %struct.hv* [ %89, %cond.true.104 ], [ null, %cond.false.109 ]
  store %struct.hv* %cond111, %struct.hv** %stash, align 8
  %90 = load %struct.hv*, %struct.hv** %stash, align 8
  %tobool112 = icmp ne %struct.hv* %90, null
  br i1 %tobool112, label %if.end.114, label %if.then.113

if.then.113:                                      ; preds = %cond.end.110
  %91 = load %struct.hv*, %struct.hv** @PL_curstash, align 8
  store %struct.hv* %91, %struct.hv** %stash, align 8
  br label %if.end.114

if.end.114:                                       ; preds = %if.then.113, %cond.end.110
  %92 = load %struct.hv*, %struct.hv** %stash, align 8
  %93 = load %struct.op*, %struct.op** %o.addr, align 8
  %94 = load %struct.op*, %struct.op** %attrs.addr, align 8
  %95 = load %struct.op**, %struct.op*** %imopsp.addr, align 8
  call void @S_apply_attrs_my(%struct.hv* %92, %struct.op* %93, %struct.op* %94, %struct.op** %95)
  br label %if.end.115

if.end.115:                                       ; preds = %if.end.114, %land.lhs.true.97, %if.else.95
  br label %if.end.116

if.end.116:                                       ; preds = %if.end.115
  br label %if.end.117

if.end.117:                                       ; preds = %if.end.116
  br label %if.end.118

if.end.118:                                       ; preds = %if.end.117
  br label %if.end.119

if.end.119:                                       ; preds = %if.end.118, %for.end
  %96 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %96, i32 0, i32 6
  %97 = load i8, i8* %op_flags, align 1
  %conv120 = zext i8 %97 to i32
  %or121 = or i32 %conv120, 32
  %conv122 = trunc i32 %or121 to i8
  store i8 %conv122, i8* %op_flags, align 1
  %98 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private123 = getelementptr inbounds %struct.op, %struct.op* %98, i32 0, i32 7
  %99 = load i8, i8* %op_private123, align 1
  %conv124 = zext i8 %99 to i32
  %or125 = or i32 %conv124, 128
  %conv126 = trunc i32 %or125 to i8
  store i8 %conv126, i8* %op_private123, align 1
  %100 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %100, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.119, %cond.end.88, %if.end.63, %if.then.7, %if.then
  %101 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %101
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_append_list(i32 %type, %struct.listop* %first, %struct.listop* %last) #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %type.addr = alloca i32, align 4
  %first.addr = alloca %struct.listop*, align 8
  %last.addr = alloca %struct.listop*, align 8
  store i32 %type, i32* %type.addr, align 4
  store %struct.listop* %first, %struct.listop** %first.addr, align 8
  store %struct.listop* %last, %struct.listop** %last.addr, align 8
  %0 = load %struct.listop*, %struct.listop** %first.addr, align 8
  %tobool = icmp ne %struct.listop* %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load %struct.listop*, %struct.listop** %last.addr, align 8
  %2 = bitcast %struct.listop* %1 to %struct.op*
  store %struct.op* %2, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %entry
  %3 = load %struct.listop*, %struct.listop** %last.addr, align 8
  %tobool1 = icmp ne %struct.listop* %3, null
  br i1 %tobool1, label %if.end.3, label %if.then.2

if.then.2:                                        ; preds = %if.end
  %4 = load %struct.listop*, %struct.listop** %first.addr, align 8
  %5 = bitcast %struct.listop* %4 to %struct.op*
  store %struct.op* %5, %struct.op** %retval
  br label %return

if.end.3:                                         ; preds = %if.end
  %6 = load %struct.listop*, %struct.listop** %first.addr, align 8
  %op_type = getelementptr inbounds %struct.listop, %struct.listop* %6, i32 0, i32 4
  %7 = load i16, i16* %op_type, align 2
  %conv = zext i16 %7 to i32
  %8 = load i32, i32* %type.addr, align 4
  %cmp = icmp ne i32 %conv, %8
  br i1 %cmp, label %if.then.5, label %if.end.6

if.then.5:                                        ; preds = %if.end.3
  %9 = load i32, i32* %type.addr, align 4
  %10 = load %struct.listop*, %struct.listop** %first.addr, align 8
  %11 = bitcast %struct.listop* %10 to %struct.op*
  %12 = load %struct.listop*, %struct.listop** %last.addr, align 8
  %13 = bitcast %struct.listop* %12 to %struct.op*
  %call = call %struct.op* @Perl_prepend_elem(i32 %9, %struct.op* %11, %struct.op* %13)
  store %struct.op* %call, %struct.op** %retval
  br label %return

if.end.6:                                         ; preds = %if.end.3
  %14 = load %struct.listop*, %struct.listop** %last.addr, align 8
  %op_type7 = getelementptr inbounds %struct.listop, %struct.listop* %14, i32 0, i32 4
  %15 = load i16, i16* %op_type7, align 2
  %conv8 = zext i16 %15 to i32
  %16 = load i32, i32* %type.addr, align 4
  %cmp9 = icmp ne i32 %conv8, %16
  br i1 %cmp9, label %if.then.11, label %if.end.13

if.then.11:                                       ; preds = %if.end.6
  %17 = load i32, i32* %type.addr, align 4
  %18 = load %struct.listop*, %struct.listop** %first.addr, align 8
  %19 = bitcast %struct.listop* %18 to %struct.op*
  %20 = load %struct.listop*, %struct.listop** %last.addr, align 8
  %21 = bitcast %struct.listop* %20 to %struct.op*
  %call12 = call %struct.op* @Perl_append_elem(i32 %17, %struct.op* %19, %struct.op* %21)
  store %struct.op* %call12, %struct.op** %retval
  br label %return

if.end.13:                                        ; preds = %if.end.6
  %22 = load %struct.listop*, %struct.listop** %last.addr, align 8
  %op_first = getelementptr inbounds %struct.listop, %struct.listop* %22, i32 0, i32 8
  %23 = load %struct.op*, %struct.op** %op_first, align 8
  %24 = load %struct.listop*, %struct.listop** %first.addr, align 8
  %op_last = getelementptr inbounds %struct.listop, %struct.listop* %24, i32 0, i32 9
  %25 = load %struct.op*, %struct.op** %op_last, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %25, i32 0, i32 1
  store %struct.op* %23, %struct.op** %op_sibling, align 8
  %26 = load %struct.listop*, %struct.listop** %last.addr, align 8
  %op_last14 = getelementptr inbounds %struct.listop, %struct.listop* %26, i32 0, i32 9
  %27 = load %struct.op*, %struct.op** %op_last14, align 8
  %28 = load %struct.listop*, %struct.listop** %first.addr, align 8
  %op_last15 = getelementptr inbounds %struct.listop, %struct.listop* %28, i32 0, i32 9
  store %struct.op* %27, %struct.op** %op_last15, align 8
  %29 = load %struct.listop*, %struct.listop** %last.addr, align 8
  %op_flags = getelementptr inbounds %struct.listop, %struct.listop* %29, i32 0, i32 6
  %30 = load i8, i8* %op_flags, align 1
  %conv16 = zext i8 %30 to i32
  %and = and i32 %conv16, 4
  %31 = load %struct.listop*, %struct.listop** %first.addr, align 8
  %op_flags17 = getelementptr inbounds %struct.listop, %struct.listop* %31, i32 0, i32 6
  %32 = load i8, i8* %op_flags17, align 1
  %conv18 = zext i8 %32 to i32
  %or = or i32 %conv18, %and
  %conv19 = trunc i32 %or to i8
  store i8 %conv19, i8* %op_flags17, align 1
  %33 = load %struct.listop*, %struct.listop** %last.addr, align 8
  %34 = bitcast %struct.listop* %33 to i8*
  call void @Perl_safesysfree(i8* %34)
  %35 = load %struct.listop*, %struct.listop** %first.addr, align 8
  %36 = bitcast %struct.listop* %35 to %struct.op*
  store %struct.op* %36, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.13, %if.then.11, %if.then.5, %if.then.2, %if.then
  %37 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %37
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_my(%struct.op* %o) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %call = call %struct.op* @Perl_my_attrs(%struct.op* %0, %struct.op* null)
  ret %struct.op* %call
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_sawparens(%struct.op* %o) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %tobool = icmp ne %struct.op* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 6
  %2 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %2 to i32
  %or = or i32 %conv, 8
  %conv1 = trunc i32 %or to i8
  store i8 %conv1, i8* %op_flags, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load %struct.op*, %struct.op** %o.addr, align 8
  ret %struct.op* %3
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_bind_match(i32 %type, %struct.op* %left, %struct.op* %right) #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %type.addr = alloca i32, align 4
  %left.addr = alloca %struct.op*, align 8
  %right.addr = alloca %struct.op*, align 8
  %o = alloca %struct.op*, align 8
  %desc = alloca i8*, align 8
  %sample = alloca i8*, align 8
  store i32 %type, i32* %type.addr, align 4
  store %struct.op* %left, %struct.op** %left.addr, align 8
  store %struct.op* %right, %struct.op** %right.addr, align 8
  %0 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings = getelementptr inbounds %struct.cop, %struct.cop* %0, i32 0, i32 14
  %1 = load %struct.sv*, %struct.sv** %cop_warnings, align 8
  %cmp = icmp ne %struct.sv* %1, null
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false.7

land.lhs.true:                                    ; preds = %entry
  %2 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings1 = getelementptr inbounds %struct.cop, %struct.cop* %2, i32 0, i32 14
  %3 = load %struct.sv*, %struct.sv** %cop_warnings1, align 8
  %cmp2 = icmp ne %struct.sv* %3, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 2)
  br i1 %cmp2, label %land.lhs.true.3, label %lor.lhs.false.7

land.lhs.true.3:                                  ; preds = %land.lhs.true
  %4 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings4 = getelementptr inbounds %struct.cop, %struct.cop* %4, i32 0, i32 14
  %5 = load %struct.sv*, %struct.sv** %cop_warnings4, align 8
  %cmp5 = icmp eq %struct.sv* %5, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 1)
  br i1 %cmp5, label %land.lhs.true.15, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true.3
  %6 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings6 = getelementptr inbounds %struct.cop, %struct.cop* %6, i32 0, i32 14
  %7 = load %struct.sv*, %struct.sv** %cop_warnings6, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %7, i32 0, i32 0
  %8 = load i8*, i8** %sv_any, align 8
  %9 = bitcast i8* %8 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %9, i32 0, i32 0
  %10 = load i8*, i8** %xpv_pv, align 8
  %arrayidx = getelementptr inbounds i8, i8* %10, i64 3
  %11 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %11 to i32
  %and = and i32 %conv, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true.15, label %lor.lhs.false.7

lor.lhs.false.7:                                  ; preds = %lor.lhs.false, %land.lhs.true, %entry
  %12 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings8 = getelementptr inbounds %struct.cop, %struct.cop* %12, i32 0, i32 14
  %13 = load %struct.sv*, %struct.sv** %cop_warnings8, align 8
  %cmp9 = icmp eq %struct.sv* %13, null
  br i1 %cmp9, label %land.lhs.true.11, label %if.end

land.lhs.true.11:                                 ; preds = %lor.lhs.false.7
  %14 = load i8, i8* @PL_dowarn, align 1
  %conv12 = zext i8 %14 to i32
  %and13 = and i32 %conv12, 1
  %tobool14 = icmp ne i32 %and13, 0
  br i1 %tobool14, label %land.lhs.true.15, label %if.end

land.lhs.true.15:                                 ; preds = %land.lhs.true.11, %lor.lhs.false, %land.lhs.true.3
  %15 = load %struct.op*, %struct.op** %left.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %15, i32 0, i32 4
  %16 = load i16, i16* %op_type, align 2
  %conv16 = zext i16 %16 to i32
  %cmp17 = icmp eq i32 %conv16, 125
  br i1 %cmp17, label %if.then, label %lor.lhs.false.19

lor.lhs.false.19:                                 ; preds = %land.lhs.true.15
  %17 = load %struct.op*, %struct.op** %left.addr, align 8
  %op_type20 = getelementptr inbounds %struct.op, %struct.op* %17, i32 0, i32 4
  %18 = load i16, i16* %op_type20, align 2
  %conv21 = zext i16 %18 to i32
  %cmp22 = icmp eq i32 %conv21, 134
  br i1 %cmp22, label %if.then, label %lor.lhs.false.24

lor.lhs.false.24:                                 ; preds = %lor.lhs.false.19
  %19 = load %struct.op*, %struct.op** %left.addr, align 8
  %op_type25 = getelementptr inbounds %struct.op, %struct.op* %19, i32 0, i32 4
  %20 = load i16, i16* %op_type25, align 2
  %conv26 = zext i16 %20 to i32
  %cmp27 = icmp eq i32 %conv26, 10
  br i1 %cmp27, label %if.then, label %lor.lhs.false.29

lor.lhs.false.29:                                 ; preds = %lor.lhs.false.24
  %21 = load %struct.op*, %struct.op** %left.addr, align 8
  %op_type30 = getelementptr inbounds %struct.op, %struct.op* %21, i32 0, i32 4
  %22 = load i16, i16* %op_type30, align 2
  %conv31 = zext i16 %22 to i32
  %cmp32 = icmp eq i32 %conv31, 11
  br i1 %cmp32, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false.29, %lor.lhs.false.24, %lor.lhs.false.19, %land.lhs.true.15
  %23 = load %struct.op*, %struct.op** %right.addr, align 8
  %op_type34 = getelementptr inbounds %struct.op, %struct.op* %23, i32 0, i32 4
  %24 = load i16, i16* %op_type34, align 2
  %conv35 = zext i16 %24 to i32
  %cmp36 = icmp eq i32 %conv35, 33
  br i1 %cmp36, label %cond.true, label %lor.lhs.false.38

lor.lhs.false.38:                                 ; preds = %if.then
  %25 = load %struct.op*, %struct.op** %right.addr, align 8
  %op_type39 = getelementptr inbounds %struct.op, %struct.op* %25, i32 0, i32 4
  %26 = load i16, i16* %op_type39, align 2
  %conv40 = zext i16 %26 to i32
  %cmp41 = icmp eq i32 %conv40, 35
  br i1 %cmp41, label %cond.true, label %cond.false

cond.true:                                        ; preds = %lor.lhs.false.38, %if.then
  %27 = load %struct.op*, %struct.op** %right.addr, align 8
  %op_type43 = getelementptr inbounds %struct.op, %struct.op* %27, i32 0, i32 4
  %28 = load i16, i16* %op_type43, align 2
  %conv44 = zext i16 %28 to i32
  br label %cond.end

cond.false:                                       ; preds = %lor.lhs.false.38
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv44, %cond.true ], [ 31, %cond.false ]
  %idxprom = sext i32 %cond to i64
  %arrayidx45 = getelementptr inbounds [0 x i8*], [0 x i8*]* @PL_op_desc, i32 0, i64 %idxprom
  %29 = load i8*, i8** %arrayidx45, align 8
  store i8* %29, i8** %desc, align 8
  %30 = load %struct.op*, %struct.op** %left.addr, align 8
  %op_type46 = getelementptr inbounds %struct.op, %struct.op* %30, i32 0, i32 4
  %31 = load i16, i16* %op_type46, align 2
  %conv47 = zext i16 %31 to i32
  %cmp48 = icmp eq i32 %conv47, 125
  br i1 %cmp48, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %cond.end
  %32 = load %struct.op*, %struct.op** %left.addr, align 8
  %op_type50 = getelementptr inbounds %struct.op, %struct.op* %32, i32 0, i32 4
  %33 = load i16, i16* %op_type50, align 2
  %conv51 = zext i16 %33 to i32
  %cmp52 = icmp eq i32 %conv51, 10
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %cond.end
  %34 = phi i1 [ true, %cond.end ], [ %cmp52, %lor.rhs ]
  %cond54 = select i1 %34, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.24, i32 0, i32 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.25, i32 0, i32 0)
  store i8* %cond54, i8** %sample, align 8
  %35 = load i8*, i8** %desc, align 8
  %36 = load i8*, i8** %sample, align 8
  %37 = load i8*, i8** %sample, align 8
  call void (i32, i8*, ...) @Perl_warner(i32 12, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.26, i32 0, i32 0), i8* %35, i8* %36, i8* %37)
  br label %if.end

if.end:                                           ; preds = %lor.end, %lor.lhs.false.29, %land.lhs.true.11, %lor.lhs.false.7
  %38 = load %struct.op*, %struct.op** %right.addr, align 8
  %op_type55 = getelementptr inbounds %struct.op, %struct.op* %38, i32 0, i32 4
  %39 = load i16, i16* %op_type55, align 2
  %conv56 = zext i16 %39 to i32
  %cmp57 = icmp eq i32 %conv56, 5
  br i1 %cmp57, label %land.lhs.true.59, label %if.end.69

land.lhs.true.59:                                 ; preds = %if.end
  %40 = load %struct.op*, %struct.op** %right.addr, align 8
  %41 = bitcast %struct.op* %40 to %struct.svop*
  %op_private = getelementptr inbounds %struct.svop, %struct.svop* %41, i32 0, i32 7
  %42 = load i8, i8* %op_private, align 1
  %conv60 = zext i8 %42 to i32
  %and61 = and i32 %conv60, 64
  %tobool62 = icmp ne i32 %and61, 0
  br i1 %tobool62, label %land.lhs.true.63, label %if.end.69

land.lhs.true.63:                                 ; preds = %land.lhs.true.59
  %43 = load %struct.op*, %struct.op** %right.addr, align 8
  %44 = bitcast %struct.op* %43 to %struct.svop*
  %op_private64 = getelementptr inbounds %struct.svop, %struct.svop* %44, i32 0, i32 7
  %45 = load i8, i8* %op_private64, align 1
  %conv65 = zext i8 %45 to i32
  %and66 = and i32 %conv65, 8
  %tobool67 = icmp ne i32 %and66, 0
  br i1 %tobool67, label %if.then.68, label %if.end.69

if.then.68:                                       ; preds = %land.lhs.true.63
  %46 = load %struct.op*, %struct.op** %right.addr, align 8
  call void @S_no_bareword_allowed(%struct.op* %46)
  br label %if.end.69

if.end.69:                                        ; preds = %if.then.68, %land.lhs.true.63, %land.lhs.true.59, %if.end
  %47 = load %struct.op*, %struct.op** %right.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %47, i32 0, i32 6
  %48 = load i8, i8* %op_flags, align 1
  %conv70 = zext i8 %48 to i32
  %and71 = and i32 %conv70, 64
  %tobool72 = icmp ne i32 %and71, 0
  br i1 %tobool72, label %if.else.128, label %land.lhs.true.73

land.lhs.true.73:                                 ; preds = %if.end.69
  %49 = load %struct.op*, %struct.op** %right.addr, align 8
  %op_type74 = getelementptr inbounds %struct.op, %struct.op* %49, i32 0, i32 4
  %50 = load i16, i16* %op_type74, align 2
  %conv75 = zext i16 %50 to i32
  %cmp76 = icmp eq i32 %conv75, 31
  br i1 %cmp76, label %if.then.88, label %lor.lhs.false.78

lor.lhs.false.78:                                 ; preds = %land.lhs.true.73
  %51 = load %struct.op*, %struct.op** %right.addr, align 8
  %op_type79 = getelementptr inbounds %struct.op, %struct.op* %51, i32 0, i32 4
  %52 = load i16, i16* %op_type79, align 2
  %conv80 = zext i16 %52 to i32
  %cmp81 = icmp eq i32 %conv80, 33
  br i1 %cmp81, label %if.then.88, label %lor.lhs.false.83

lor.lhs.false.83:                                 ; preds = %lor.lhs.false.78
  %53 = load %struct.op*, %struct.op** %right.addr, align 8
  %op_type84 = getelementptr inbounds %struct.op, %struct.op* %53, i32 0, i32 4
  %54 = load i16, i16* %op_type84, align 2
  %conv85 = zext i16 %54 to i32
  %cmp86 = icmp eq i32 %conv85, 35
  br i1 %cmp86, label %if.then.88, label %if.else.128

if.then.88:                                       ; preds = %lor.lhs.false.83, %lor.lhs.false.78, %land.lhs.true.73
  %55 = load %struct.op*, %struct.op** %right.addr, align 8
  %op_flags89 = getelementptr inbounds %struct.op, %struct.op* %55, i32 0, i32 6
  %56 = load i8, i8* %op_flags89, align 1
  %conv90 = zext i8 %56 to i32
  %or = or i32 %conv90, 64
  %conv91 = trunc i32 %or to i8
  store i8 %conv91, i8* %op_flags89, align 1
  %57 = load %struct.op*, %struct.op** %right.addr, align 8
  %op_type92 = getelementptr inbounds %struct.op, %struct.op* %57, i32 0, i32 4
  %58 = load i16, i16* %op_type92, align 2
  %conv93 = zext i16 %58 to i32
  %cmp94 = icmp ne i32 %conv93, 31
  br i1 %cmp94, label %land.lhs.true.96, label %if.end.109

land.lhs.true.96:                                 ; preds = %if.then.88
  %59 = load %struct.op*, %struct.op** %right.addr, align 8
  %op_type97 = getelementptr inbounds %struct.op, %struct.op* %59, i32 0, i32 4
  %60 = load i16, i16* %op_type97, align 2
  %conv98 = zext i16 %60 to i32
  %cmp99 = icmp eq i32 %conv98, 35
  br i1 %cmp99, label %land.lhs.true.101, label %if.then.106

land.lhs.true.101:                                ; preds = %land.lhs.true.96
  %61 = load %struct.op*, %struct.op** %right.addr, align 8
  %op_private102 = getelementptr inbounds %struct.op, %struct.op* %61, i32 0, i32 7
  %62 = load i8, i8* %op_private102, align 1
  %conv103 = zext i8 %62 to i32
  %and104 = and i32 %conv103, 4
  %tobool105 = icmp ne i32 %and104, 0
  br i1 %tobool105, label %if.end.109, label %if.then.106

if.then.106:                                      ; preds = %land.lhs.true.101, %land.lhs.true.96
  %63 = load %struct.op*, %struct.op** %left.addr, align 8
  %64 = load %struct.op*, %struct.op** %right.addr, align 8
  %op_type107 = getelementptr inbounds %struct.op, %struct.op* %64, i32 0, i32 4
  %65 = load i16, i16* %op_type107, align 2
  %conv108 = zext i16 %65 to i32
  %call = call %struct.op* @Perl_mod(%struct.op* %63, i32 %conv108)
  store %struct.op* %call, %struct.op** %left.addr, align 8
  br label %if.end.109

if.end.109:                                       ; preds = %if.then.106, %land.lhs.true.101, %if.then.88
  %66 = load %struct.op*, %struct.op** %right.addr, align 8
  %op_type110 = getelementptr inbounds %struct.op, %struct.op* %66, i32 0, i32 4
  %67 = load i16, i16* %op_type110, align 2
  %conv111 = zext i16 %67 to i32
  %cmp112 = icmp eq i32 %conv111, 35
  br i1 %cmp112, label %if.then.114, label %if.else

if.then.114:                                      ; preds = %if.end.109
  %68 = load %struct.op*, %struct.op** %left.addr, align 8
  %call115 = call %struct.op* @Perl_scalar(%struct.op* %68)
  %69 = load %struct.op*, %struct.op** %right.addr, align 8
  %call116 = call %struct.op* @Perl_newBINOP(i32 0, i32 64, %struct.op* %call115, %struct.op* %69)
  store %struct.op* %call116, %struct.op** %o, align 8
  br label %if.end.121

if.else:                                          ; preds = %if.end.109
  %70 = load %struct.op*, %struct.op** %right.addr, align 8
  %op_type117 = getelementptr inbounds %struct.op, %struct.op* %70, i32 0, i32 4
  %71 = load i16, i16* %op_type117, align 2
  %conv118 = zext i16 %71 to i32
  %72 = load %struct.op*, %struct.op** %left.addr, align 8
  %call119 = call %struct.op* @Perl_scalar(%struct.op* %72)
  %73 = load %struct.op*, %struct.op** %right.addr, align 8
  %call120 = call %struct.op* @Perl_prepend_elem(i32 %conv118, %struct.op* %call119, %struct.op* %73)
  store %struct.op* %call120, %struct.op** %o, align 8
  br label %if.end.121

if.end.121:                                       ; preds = %if.else, %if.then.114
  %74 = load i32, i32* %type.addr, align 4
  %cmp122 = icmp eq i32 %74, 96
  br i1 %cmp122, label %if.then.124, label %if.end.127

if.then.124:                                      ; preds = %if.end.121
  %75 = load %struct.op*, %struct.op** %o, align 8
  %call125 = call %struct.op* @Perl_scalar(%struct.op* %75)
  %call126 = call %struct.op* @Perl_newUNOP(i32 96, i32 0, %struct.op* %call125)
  store %struct.op* %call126, %struct.op** %retval
  br label %return

if.end.127:                                       ; preds = %if.end.121
  %76 = load %struct.op*, %struct.op** %o, align 8
  store %struct.op* %76, %struct.op** %retval
  br label %return

if.else.128:                                      ; preds = %lor.lhs.false.83, %if.end.69
  %77 = load i32, i32* %type.addr, align 4
  %78 = load %struct.op*, %struct.op** %left.addr, align 8
  %call129 = call %struct.op* @Perl_newPMOP(i32 31, i32 0)
  %79 = load %struct.op*, %struct.op** %right.addr, align 8
  %call130 = call %struct.op* @Perl_pmruntime(%struct.op* %call129, %struct.op* %79, %struct.op* null)
  %call131 = call %struct.op* @Perl_bind_match(i32 %77, %struct.op* %78, %struct.op* %call130)
  store %struct.op* %call131, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.else.128, %if.end.127, %if.then.124
  %80 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %80
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newBINOP(i32 %type, i32 %flags, %struct.op* %first, %struct.op* %last) #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %type.addr = alloca i32, align 4
  %flags.addr = alloca i32, align 4
  %first.addr = alloca %struct.op*, align 8
  %last.addr = alloca %struct.op*, align 8
  %binop = alloca %struct.binop*, align 8
  store i32 %type, i32* %type.addr, align 4
  store i32 %flags, i32* %flags.addr, align 4
  store %struct.op* %first, %struct.op** %first.addr, align 8
  store %struct.op* %last, %struct.op** %last.addr, align 8
  %call = call i8* @Perl_safesysmalloc(i64 56)
  %0 = bitcast i8* %call to %struct.binop*
  store %struct.binop* %0, %struct.binop** %binop, align 8
  %1 = load %struct.binop*, %struct.binop** %binop, align 8
  %2 = bitcast %struct.binop* %1 to i8*
  call void @llvm.memset.p0i8.i64(i8* %2, i8 0, i64 56, i32 1, i1 false)
  %3 = load %struct.op*, %struct.op** %first.addr, align 8
  %tobool = icmp ne %struct.op* %3, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call1 = call %struct.op* @Perl_newOP(i32 0, i32 0)
  store %struct.op* %call1, %struct.op** %first.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load i32, i32* %type.addr, align 4
  %conv = trunc i32 %4 to i16
  %5 = load %struct.binop*, %struct.binop** %binop, align 8
  %op_type = getelementptr inbounds %struct.binop, %struct.binop* %5, i32 0, i32 4
  store i16 %conv, i16* %op_type, align 2
  %6 = load i32, i32* %type.addr, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr inbounds [0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 %idxprom
  %7 = load %struct.op* ()*, %struct.op* ()** %arrayidx, align 8
  %8 = load %struct.binop*, %struct.binop** %binop, align 8
  %op_ppaddr = getelementptr inbounds %struct.binop, %struct.binop* %8, i32 0, i32 2
  store %struct.op* ()* %7, %struct.op* ()** %op_ppaddr, align 8
  %9 = load %struct.op*, %struct.op** %first.addr, align 8
  %10 = load %struct.binop*, %struct.binop** %binop, align 8
  %op_first = getelementptr inbounds %struct.binop, %struct.binop* %10, i32 0, i32 8
  store %struct.op* %9, %struct.op** %op_first, align 8
  %11 = load i32, i32* %flags.addr, align 4
  %or = or i32 %11, 4
  %conv2 = trunc i32 %or to i8
  %12 = load %struct.binop*, %struct.binop** %binop, align 8
  %op_flags = getelementptr inbounds %struct.binop, %struct.binop* %12, i32 0, i32 6
  store i8 %conv2, i8* %op_flags, align 1
  %13 = load %struct.op*, %struct.op** %last.addr, align 8
  %tobool3 = icmp ne %struct.op* %13, null
  br i1 %tobool3, label %if.else, label %if.then.4

if.then.4:                                        ; preds = %if.end
  %14 = load %struct.op*, %struct.op** %first.addr, align 8
  store %struct.op* %14, %struct.op** %last.addr, align 8
  %15 = load i32, i32* %flags.addr, align 4
  %shr = ashr i32 %15, 8
  %or5 = or i32 1, %shr
  %conv6 = trunc i32 %or5 to i8
  %16 = load %struct.binop*, %struct.binop** %binop, align 8
  %op_private = getelementptr inbounds %struct.binop, %struct.binop* %16, i32 0, i32 7
  store i8 %conv6, i8* %op_private, align 1
  br label %if.end.11

if.else:                                          ; preds = %if.end
  %17 = load i32, i32* %flags.addr, align 4
  %shr7 = ashr i32 %17, 8
  %or8 = or i32 2, %shr7
  %conv9 = trunc i32 %or8 to i8
  %18 = load %struct.binop*, %struct.binop** %binop, align 8
  %op_private10 = getelementptr inbounds %struct.binop, %struct.binop* %18, i32 0, i32 7
  store i8 %conv9, i8* %op_private10, align 1
  %19 = load %struct.op*, %struct.op** %last.addr, align 8
  %20 = load %struct.op*, %struct.op** %first.addr, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %20, i32 0, i32 1
  store %struct.op* %19, %struct.op** %op_sibling, align 8
  br label %if.end.11

if.end.11:                                        ; preds = %if.else, %if.then.4
  %21 = load i8*, i8** @PL_op_mask, align 8
  %tobool12 = icmp ne i8* %21, null
  br i1 %tobool12, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %if.end.11
  %22 = load i32, i32* %type.addr, align 4
  %idxprom13 = sext i32 %22 to i64
  %23 = load i8*, i8** @PL_op_mask, align 8
  %arrayidx14 = getelementptr inbounds i8, i8* %23, i64 %idxprom13
  %24 = load i8, i8* %arrayidx14, align 1
  %conv15 = sext i8 %24 to i32
  %tobool16 = icmp ne i32 %conv15, 0
  br i1 %tobool16, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true
  %25 = load %struct.binop*, %struct.binop** %binop, align 8
  %26 = bitcast %struct.binop* %25 to %struct.op*
  call void @Perl_op_free(%struct.op* %26)
  %27 = load i32, i32* %type.addr, align 4
  %idxprom17 = sext i32 %27 to i64
  %arrayidx18 = getelementptr inbounds [0 x i8*], [0 x i8*]* @PL_op_desc, i32 0, i64 %idxprom17
  %28 = load i8*, i8** %arrayidx18, align 8
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.33, i32 0, i32 0), i8* %28)
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %if.end.11
  %29 = load i32, i32* %type.addr, align 4
  %idxprom19 = sext i32 %29 to i64
  %arrayidx20 = getelementptr inbounds [0 x %struct.op* (%struct.op*)*], [0 x %struct.op* (%struct.op*)*]* @PL_check, i32 0, i64 %idxprom19
  %30 = load %struct.op* (%struct.op*)*, %struct.op* (%struct.op*)** %arrayidx20, align 8
  %31 = load %struct.binop*, %struct.binop** %binop, align 8
  %32 = bitcast %struct.binop* %31 to %struct.op*
  %call21 = call %struct.op* %30(%struct.op* %32)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.op* [ null, %cond.true ], [ %call21, %cond.false ]
  %33 = bitcast %struct.op* %cond to %struct.binop*
  store %struct.binop* %33, %struct.binop** %binop, align 8
  %34 = load %struct.binop*, %struct.binop** %binop, align 8
  %op_next = getelementptr inbounds %struct.binop, %struct.binop* %34, i32 0, i32 0
  %35 = load %struct.op*, %struct.op** %op_next, align 8
  %tobool22 = icmp ne %struct.op* %35, null
  br i1 %tobool22, label %if.then.28, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end
  %36 = load %struct.binop*, %struct.binop** %binop, align 8
  %op_type23 = getelementptr inbounds %struct.binop, %struct.binop* %36, i32 0, i32 4
  %37 = load i16, i16* %op_type23, align 2
  %conv24 = zext i16 %37 to i32
  %38 = load i32, i32* %type.addr, align 4
  %conv25 = trunc i32 %38 to i16
  %conv26 = zext i16 %conv25 to i32
  %cmp = icmp ne i32 %conv24, %conv26
  br i1 %cmp, label %if.then.28, label %if.end.29

if.then.28:                                       ; preds = %lor.lhs.false, %cond.end
  %39 = load %struct.binop*, %struct.binop** %binop, align 8
  %40 = bitcast %struct.binop* %39 to %struct.op*
  store %struct.op* %40, %struct.op** %retval
  br label %return

if.end.29:                                        ; preds = %lor.lhs.false
  %41 = load %struct.binop*, %struct.binop** %binop, align 8
  %op_first30 = getelementptr inbounds %struct.binop, %struct.binop* %41, i32 0, i32 8
  %42 = load %struct.op*, %struct.op** %op_first30, align 8
  %op_sibling31 = getelementptr inbounds %struct.op, %struct.op* %42, i32 0, i32 1
  %43 = load %struct.op*, %struct.op** %op_sibling31, align 8
  %44 = load %struct.binop*, %struct.binop** %binop, align 8
  %op_last = getelementptr inbounds %struct.binop, %struct.binop* %44, i32 0, i32 9
  store %struct.op* %43, %struct.op** %op_last, align 8
  %45 = load %struct.binop*, %struct.binop** %binop, align 8
  %46 = bitcast %struct.binop* %45 to %struct.op*
  %call32 = call %struct.op* @Perl_fold_constants(%struct.op* %46)
  store %struct.op* %call32, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.29, %if.then.28
  %47 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %47
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newUNOP(i32 %type, i32 %flags, %struct.op* %first) #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %type.addr = alloca i32, align 4
  %flags.addr = alloca i32, align 4
  %first.addr = alloca %struct.op*, align 8
  %unop = alloca %struct.unop*, align 8
  store i32 %type, i32* %type.addr, align 4
  store i32 %flags, i32* %flags.addr, align 4
  store %struct.op* %first, %struct.op** %first.addr, align 8
  %0 = load %struct.op*, %struct.op** %first.addr, align 8
  %tobool = icmp ne %struct.op* %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call = call %struct.op* @Perl_newOP(i32 1, i32 0)
  store %struct.op* %call, %struct.op** %first.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %1 = load i32, i32* %type.addr, align 4
  %idxprom = sext i32 %1 to i64
  %arrayidx = getelementptr inbounds [0 x i32], [0 x i32]* @PL_opargs, i32 0, i64 %idxprom
  %2 = load i32, i32* %arrayidx, align 4
  %and = and i32 %2, 1
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %if.then.2, label %if.end.4

if.then.2:                                        ; preds = %if.end
  %3 = load %struct.op*, %struct.op** %first.addr, align 8
  %call3 = call %struct.op* @Perl_force_list(%struct.op* %3)
  store %struct.op* %call3, %struct.op** %first.addr, align 8
  br label %if.end.4

if.end.4:                                         ; preds = %if.then.2, %if.end
  %call5 = call i8* @Perl_safesysmalloc(i64 48)
  %4 = bitcast i8* %call5 to %struct.unop*
  store %struct.unop* %4, %struct.unop** %unop, align 8
  %5 = load %struct.unop*, %struct.unop** %unop, align 8
  %6 = bitcast %struct.unop* %5 to i8*
  call void @llvm.memset.p0i8.i64(i8* %6, i8 0, i64 48, i32 1, i1 false)
  %7 = load i32, i32* %type.addr, align 4
  %conv = trunc i32 %7 to i16
  %8 = load %struct.unop*, %struct.unop** %unop, align 8
  %op_type = getelementptr inbounds %struct.unop, %struct.unop* %8, i32 0, i32 4
  store i16 %conv, i16* %op_type, align 2
  %9 = load i32, i32* %type.addr, align 4
  %idxprom6 = sext i32 %9 to i64
  %arrayidx7 = getelementptr inbounds [0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 %idxprom6
  %10 = load %struct.op* ()*, %struct.op* ()** %arrayidx7, align 8
  %11 = load %struct.unop*, %struct.unop** %unop, align 8
  %op_ppaddr = getelementptr inbounds %struct.unop, %struct.unop* %11, i32 0, i32 2
  store %struct.op* ()* %10, %struct.op* ()** %op_ppaddr, align 8
  %12 = load %struct.op*, %struct.op** %first.addr, align 8
  %13 = load %struct.unop*, %struct.unop** %unop, align 8
  %op_first = getelementptr inbounds %struct.unop, %struct.unop* %13, i32 0, i32 8
  store %struct.op* %12, %struct.op** %op_first, align 8
  %14 = load i32, i32* %flags.addr, align 4
  %or = or i32 %14, 4
  %conv8 = trunc i32 %or to i8
  %15 = load %struct.unop*, %struct.unop** %unop, align 8
  %op_flags = getelementptr inbounds %struct.unop, %struct.unop* %15, i32 0, i32 6
  store i8 %conv8, i8* %op_flags, align 1
  %16 = load i32, i32* %flags.addr, align 4
  %shr = ashr i32 %16, 8
  %or9 = or i32 1, %shr
  %conv10 = trunc i32 %or9 to i8
  %17 = load %struct.unop*, %struct.unop** %unop, align 8
  %op_private = getelementptr inbounds %struct.unop, %struct.unop* %17, i32 0, i32 7
  store i8 %conv10, i8* %op_private, align 1
  %18 = load i8*, i8** @PL_op_mask, align 8
  %tobool11 = icmp ne i8* %18, null
  br i1 %tobool11, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %if.end.4
  %19 = load i32, i32* %type.addr, align 4
  %idxprom12 = sext i32 %19 to i64
  %20 = load i8*, i8** @PL_op_mask, align 8
  %arrayidx13 = getelementptr inbounds i8, i8* %20, i64 %idxprom12
  %21 = load i8, i8* %arrayidx13, align 1
  %conv14 = sext i8 %21 to i32
  %tobool15 = icmp ne i32 %conv14, 0
  br i1 %tobool15, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true
  %22 = load %struct.unop*, %struct.unop** %unop, align 8
  %23 = bitcast %struct.unop* %22 to %struct.op*
  call void @Perl_op_free(%struct.op* %23)
  %24 = load i32, i32* %type.addr, align 4
  %idxprom16 = sext i32 %24 to i64
  %arrayidx17 = getelementptr inbounds [0 x i8*], [0 x i8*]* @PL_op_desc, i32 0, i64 %idxprom16
  %25 = load i8*, i8** %arrayidx17, align 8
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.33, i32 0, i32 0), i8* %25)
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %if.end.4
  %26 = load i32, i32* %type.addr, align 4
  %idxprom18 = sext i32 %26 to i64
  %arrayidx19 = getelementptr inbounds [0 x %struct.op* (%struct.op*)*], [0 x %struct.op* (%struct.op*)*]* @PL_check, i32 0, i64 %idxprom18
  %27 = load %struct.op* (%struct.op*)*, %struct.op* (%struct.op*)** %arrayidx19, align 8
  %28 = load %struct.unop*, %struct.unop** %unop, align 8
  %29 = bitcast %struct.unop* %28 to %struct.op*
  %call20 = call %struct.op* %27(%struct.op* %29)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.op* [ null, %cond.true ], [ %call20, %cond.false ]
  %30 = bitcast %struct.op* %cond to %struct.unop*
  store %struct.unop* %30, %struct.unop** %unop, align 8
  %31 = load %struct.unop*, %struct.unop** %unop, align 8
  %op_next = getelementptr inbounds %struct.unop, %struct.unop* %31, i32 0, i32 0
  %32 = load %struct.op*, %struct.op** %op_next, align 8
  %tobool21 = icmp ne %struct.op* %32, null
  br i1 %tobool21, label %if.then.22, label %if.end.23

if.then.22:                                       ; preds = %cond.end
  %33 = load %struct.unop*, %struct.unop** %unop, align 8
  %34 = bitcast %struct.unop* %33 to %struct.op*
  store %struct.op* %34, %struct.op** %retval
  br label %return

if.end.23:                                        ; preds = %cond.end
  %35 = load %struct.unop*, %struct.unop** %unop, align 8
  %36 = bitcast %struct.unop* %35 to %struct.op*
  %call24 = call %struct.op* @Perl_fold_constants(%struct.op* %36)
  store %struct.op* %call24, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.23, %if.then.22
  %37 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %37
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pmruntime(%struct.op* %o, %struct.op* %expr, %struct.op* %repl) #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %o.addr = alloca %struct.op*, align 8
  %expr.addr = alloca %struct.op*, align 8
  %repl.addr = alloca %struct.op*, align 8
  %pm = alloca %struct.pmop*, align 8
  %rcop = alloca %struct.logop*, align 8
  %repl_has_vars = alloca i32, align 4
  %plen = alloca i64, align 8
  %pat = alloca %struct.sv*, align 8
  %p = alloca i8*, align 8
  %curop = alloca %struct.op*, align 8
  %lastop = alloca %struct.op*, align 8
  %gv = alloca %struct.gv*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  store %struct.op* %expr, %struct.op** %expr.addr, align 8
  store %struct.op* %repl, %struct.op** %repl.addr, align 8
  store i32 0, i32* %repl_has_vars, align 4
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %0, i32 0, i32 4
  %1 = load i16, i16* %op_type, align 2
  %conv = zext i16 %1 to i32
  %cmp = icmp eq i32 %conv, 35
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.op*, %struct.op** %o.addr, align 8
  %3 = load %struct.op*, %struct.op** %expr.addr, align 8
  %4 = load %struct.op*, %struct.op** %repl.addr, align 8
  %call = call %struct.op* @Perl_pmtrans(%struct.op* %2, %struct.op* %3, %struct.op* %4)
  store %struct.op* %call, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i32, i32* @PL_hints, align 4
  %or = or i32 %5, 256
  store i32 %or, i32* @PL_hints, align 4
  %6 = load %struct.op*, %struct.op** %o.addr, align 8
  %7 = bitcast %struct.op* %6 to %struct.pmop*
  store %struct.pmop* %7, %struct.pmop** %pm, align 8
  %8 = load %struct.op*, %struct.op** %expr.addr, align 8
  %op_type2 = getelementptr inbounds %struct.op, %struct.op* %8, i32 0, i32 4
  %9 = load i16, i16* %op_type2, align 2
  %conv3 = zext i16 %9 to i32
  %cmp4 = icmp eq i32 %conv3, 5
  br i1 %cmp4, label %if.then.6, label %if.else

if.then.6:                                        ; preds = %if.end
  %10 = load %struct.op*, %struct.op** %expr.addr, align 8
  %11 = bitcast %struct.op* %10 to %struct.svop*
  %op_sv = getelementptr inbounds %struct.svop, %struct.svop* %11, i32 0, i32 8
  %12 = load %struct.sv*, %struct.sv** %op_sv, align 8
  store %struct.sv* %12, %struct.sv** %pat, align 8
  %13 = load %struct.sv*, %struct.sv** %pat, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %13, i32 0, i32 2
  %14 = load i32, i32* %sv_flags, align 4
  %and = and i32 %14, 262144
  %cmp7 = icmp eq i32 %and, 262144
  br i1 %cmp7, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.6
  %15 = load %struct.sv*, %struct.sv** %pat, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %15, i32 0, i32 0
  %16 = load i8*, i8** %sv_any, align 8
  %17 = bitcast i8* %16 to %struct.xpv*
  %xpv_cur = getelementptr inbounds %struct.xpv, %struct.xpv* %17, i32 0, i32 1
  %18 = load i64, i64* %xpv_cur, align 8
  store i64 %18, i64* %plen, align 8
  %19 = load %struct.sv*, %struct.sv** %pat, align 8
  %sv_any9 = getelementptr inbounds %struct.sv, %struct.sv* %19, i32 0, i32 0
  %20 = load i8*, i8** %sv_any9, align 8
  %21 = bitcast i8* %20 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %21, i32 0, i32 0
  %22 = load i8*, i8** %xpv_pv, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then.6
  %23 = load %struct.sv*, %struct.sv** %pat, align 8
  %call10 = call i8* @Perl_sv_2pv_flags(%struct.sv* %23, i64* %plen, i32 2)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %22, %cond.true ], [ %call10, %cond.false ]
  store i8* %cond, i8** %p, align 8
  %24 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %24, i32 0, i32 6
  %25 = load i8, i8* %op_flags, align 1
  %conv11 = zext i8 %25 to i32
  %and12 = and i32 %conv11, 128
  %tobool = icmp ne i32 %and12, 0
  br i1 %tobool, label %land.lhs.true, label %if.end.35

land.lhs.true:                                    ; preds = %cond.end
  %26 = load i8*, i8** %p, align 8
  %27 = load i8, i8* %26, align 1
  %conv13 = sext i8 %27 to i32
  %cmp14 = icmp eq i32 %conv13, 32
  br i1 %cmp14, label %land.lhs.true.16, label %if.end.35

land.lhs.true.16:                                 ; preds = %land.lhs.true
  %28 = load i8*, i8** %p, align 8
  %arrayidx = getelementptr inbounds i8, i8* %28, i64 1
  %29 = load i8, i8* %arrayidx, align 1
  %conv17 = sext i8 %29 to i32
  %cmp18 = icmp eq i32 %conv17, 0
  br i1 %cmp18, label %if.then.20, label %if.end.35

if.then.20:                                       ; preds = %land.lhs.true.16
  %30 = load %struct.sv*, %struct.sv** %pat, align 8
  call void @Perl_sv_setpvn(%struct.sv* %30, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.42, i32 0, i32 0), i64 3)
  %31 = load %struct.sv*, %struct.sv** %pat, align 8
  %sv_flags21 = getelementptr inbounds %struct.sv, %struct.sv* %31, i32 0, i32 2
  %32 = load i32, i32* %sv_flags21, align 4
  %and22 = and i32 %32, 262144
  %cmp23 = icmp eq i32 %and22, 262144
  br i1 %cmp23, label %cond.true.25, label %cond.false.30

cond.true.25:                                     ; preds = %if.then.20
  %33 = load %struct.sv*, %struct.sv** %pat, align 8
  %sv_any26 = getelementptr inbounds %struct.sv, %struct.sv* %33, i32 0, i32 0
  %34 = load i8*, i8** %sv_any26, align 8
  %35 = bitcast i8* %34 to %struct.xpv*
  %xpv_cur27 = getelementptr inbounds %struct.xpv, %struct.xpv* %35, i32 0, i32 1
  %36 = load i64, i64* %xpv_cur27, align 8
  store i64 %36, i64* %plen, align 8
  %37 = load %struct.sv*, %struct.sv** %pat, align 8
  %sv_any28 = getelementptr inbounds %struct.sv, %struct.sv* %37, i32 0, i32 0
  %38 = load i8*, i8** %sv_any28, align 8
  %39 = bitcast i8* %38 to %struct.xpv*
  %xpv_pv29 = getelementptr inbounds %struct.xpv, %struct.xpv* %39, i32 0, i32 0
  %40 = load i8*, i8** %xpv_pv29, align 8
  br label %cond.end.32

cond.false.30:                                    ; preds = %if.then.20
  %41 = load %struct.sv*, %struct.sv** %pat, align 8
  %call31 = call i8* @Perl_sv_2pv_flags(%struct.sv* %41, i64* %plen, i32 2)
  br label %cond.end.32

cond.end.32:                                      ; preds = %cond.false.30, %cond.true.25
  %cond33 = phi i8* [ %40, %cond.true.25 ], [ %call31, %cond.false.30 ]
  store i8* %cond33, i8** %p, align 8
  %42 = load %struct.pmop*, %struct.pmop** %pm, align 8
  %op_pmflags = getelementptr inbounds %struct.pmop, %struct.pmop* %42, i32 0, i32 14
  %43 = load i32, i32* %op_pmflags, align 4
  %or34 = or i32 %43, 16
  store i32 %or34, i32* %op_pmflags, align 4
  br label %if.end.35

if.end.35:                                        ; preds = %cond.end.32, %land.lhs.true.16, %land.lhs.true, %cond.end
  %44 = load %struct.sv*, %struct.sv** %pat, align 8
  %sv_flags36 = getelementptr inbounds %struct.sv, %struct.sv* %44, i32 0, i32 2
  %45 = load i32, i32* %sv_flags36, align 4
  %and37 = and i32 %45, 536870912
  %tobool38 = icmp ne i32 %and37, 0
  br i1 %tobool38, label %land.lhs.true.39, label %if.end.47

land.lhs.true.39:                                 ; preds = %if.end.35
  %46 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %op_private = getelementptr inbounds %struct.cop, %struct.cop* %46, i32 0, i32 7
  %47 = load i8, i8* %op_private, align 1
  %conv40 = zext i8 %47 to i32
  %and41 = and i32 %conv40, 8
  %tobool42 = icmp ne i32 %and41, 0
  br i1 %tobool42, label %if.end.47, label %if.then.43

if.then.43:                                       ; preds = %land.lhs.true.39
  %48 = load %struct.pmop*, %struct.pmop** %pm, align 8
  %op_pmdynflags = getelementptr inbounds %struct.pmop, %struct.pmop* %48, i32 0, i32 16
  %49 = load i8, i8* %op_pmdynflags, align 1
  %conv44 = zext i8 %49 to i32
  %or45 = or i32 %conv44, 4
  %conv46 = trunc i32 %or45 to i8
  store i8 %conv46, i8* %op_pmdynflags, align 1
  br label %if.end.47

if.end.47:                                        ; preds = %if.then.43, %land.lhs.true.39, %if.end.35
  %50 = load %struct.regexp* (i8*, i8*, %struct.pmop*)*, %struct.regexp* (i8*, i8*, %struct.pmop*)** @PL_regcompp, align 8
  %51 = load i8*, i8** %p, align 8
  %52 = load i8*, i8** %p, align 8
  %53 = load i64, i64* %plen, align 8
  %add.ptr = getelementptr inbounds i8, i8* %52, i64 %53
  %54 = load %struct.pmop*, %struct.pmop** %pm, align 8
  %call48 = call %struct.regexp* %50(i8* %51, i8* %add.ptr, %struct.pmop* %54)
  %55 = load %struct.pmop*, %struct.pmop** %pm, align 8
  %op_pmregexp = getelementptr inbounds %struct.pmop, %struct.pmop* %55, i32 0, i32 13
  store %struct.regexp* %call48, %struct.regexp** %op_pmregexp, align 8
  %56 = load %struct.pmop*, %struct.pmop** %pm, align 8
  %op_pmregexp49 = getelementptr inbounds %struct.pmop, %struct.pmop* %56, i32 0, i32 13
  %57 = load %struct.regexp*, %struct.regexp** %op_pmregexp49, align 8
  %precomp = getelementptr inbounds %struct.regexp, %struct.regexp* %57, i32 0, i32 4
  %58 = load i8*, i8** %precomp, align 8
  %call50 = call i32 @strcmp(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.42, i32 0, i32 0), i8* %58)
  %tobool51 = icmp ne i32 %call50, 0
  br i1 %tobool51, label %if.end.55, label %if.then.52

if.then.52:                                       ; preds = %if.end.47
  %59 = load %struct.pmop*, %struct.pmop** %pm, align 8
  %op_pmflags53 = getelementptr inbounds %struct.pmop, %struct.pmop* %59, i32 0, i32 14
  %60 = load i32, i32* %op_pmflags53, align 4
  %or54 = or i32 %60, 32
  store i32 %or54, i32* %op_pmflags53, align 4
  br label %if.end.55

if.end.55:                                        ; preds = %if.then.52, %if.end.47
  %61 = load %struct.op*, %struct.op** %expr.addr, align 8
  call void @Perl_op_free(%struct.op* %61)
  br label %if.end.111

if.else:                                          ; preds = %if.end
  %62 = load %struct.pmop*, %struct.pmop** %pm, align 8
  %op_pmflags56 = getelementptr inbounds %struct.pmop, %struct.pmop* %62, i32 0, i32 14
  %63 = load i32, i32* %op_pmflags56, align 4
  %and57 = and i32 %63, 128
  %tobool58 = icmp ne i32 %and57, 0
  br i1 %tobool58, label %if.then.61, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else
  %64 = load i32, i32* @PL_hints, align 4
  %and59 = and i32 %64, 2097152
  %tobool60 = icmp ne i32 %and59, 0
  br i1 %tobool60, label %if.end.66, label %if.then.61

if.then.61:                                       ; preds = %lor.lhs.false, %if.else
  %65 = load i32, i32* @PL_hints, align 4
  %and62 = and i32 %65, 2097152
  %tobool63 = icmp ne i32 %and62, 0
  %lnot = xor i1 %tobool63, true
  %cond64 = select i1 %lnot, i32 29, i32 28
  %66 = load %struct.op*, %struct.op** %expr.addr, align 8
  %call65 = call %struct.op* @Perl_newUNOP(i32 %cond64, i32 0, %struct.op* %66)
  store %struct.op* %call65, %struct.op** %expr.addr, align 8
  br label %if.end.66

if.end.66:                                        ; preds = %if.then.61, %lor.lhs.false
  %call67 = call i8* @Perl_safesysmalloc(i64 56)
  %67 = bitcast i8* %call67 to %struct.logop*
  store %struct.logop* %67, %struct.logop** %rcop, align 8
  %68 = load %struct.logop*, %struct.logop** %rcop, align 8
  %69 = bitcast %struct.logop* %68 to i8*
  call void @llvm.memset.p0i8.i64(i8* %69, i8 0, i64 56, i32 1, i1 false)
  %70 = load %struct.logop*, %struct.logop** %rcop, align 8
  %op_type68 = getelementptr inbounds %struct.logop, %struct.logop* %70, i32 0, i32 4
  store i16 30, i16* %op_type68, align 2
  %71 = load %struct.op* ()*, %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 30), align 8
  %72 = load %struct.logop*, %struct.logop** %rcop, align 8
  %op_ppaddr = getelementptr inbounds %struct.logop, %struct.logop* %72, i32 0, i32 2
  store %struct.op* ()* %71, %struct.op* ()** %op_ppaddr, align 8
  %73 = load %struct.op*, %struct.op** %expr.addr, align 8
  %call69 = call %struct.op* @Perl_scalar(%struct.op* %73)
  %74 = load %struct.logop*, %struct.logop** %rcop, align 8
  %op_first = getelementptr inbounds %struct.logop, %struct.logop* %74, i32 0, i32 8
  store %struct.op* %call69, %struct.op** %op_first, align 8
  %75 = load i32, i32* @PL_hints, align 4
  %and70 = and i32 %75, 2097152
  %tobool71 = icmp ne i32 %and70, 0
  %cond72 = select i1 %tobool71, i32 132, i32 4
  %76 = load %struct.logop*, %struct.logop** %rcop, align 8
  %op_flags73 = getelementptr inbounds %struct.logop, %struct.logop* %76, i32 0, i32 6
  %77 = load i8, i8* %op_flags73, align 1
  %conv74 = zext i8 %77 to i32
  %or75 = or i32 %conv74, %cond72
  %conv76 = trunc i32 %or75 to i8
  store i8 %conv76, i8* %op_flags73, align 1
  %78 = load %struct.logop*, %struct.logop** %rcop, align 8
  %op_private77 = getelementptr inbounds %struct.logop, %struct.logop* %78, i32 0, i32 7
  store i8 1, i8* %op_private77, align 1
  %79 = load %struct.op*, %struct.op** %o.addr, align 8
  %80 = load %struct.logop*, %struct.logop** %rcop, align 8
  %op_other = getelementptr inbounds %struct.logop, %struct.logop* %80, i32 0, i32 9
  store %struct.op* %79, %struct.op** %op_other, align 8
  %81 = load %struct.pmop*, %struct.pmop** %pm, align 8
  %op_pmflags78 = getelementptr inbounds %struct.pmop, %struct.pmop* %81, i32 0, i32 14
  %82 = load i32, i32* %op_pmflags78, align 4
  %and79 = and i32 %82, 128
  %tobool80 = icmp ne i32 %and79, 0
  br i1 %tobool80, label %if.then.84, label %lor.lhs.false.81

lor.lhs.false.81:                                 ; preds = %if.end.66
  %83 = load i32, i32* @PL_hints, align 4
  %and82 = and i32 %83, 2097152
  %tobool83 = icmp ne i32 %and82, 0
  br i1 %tobool83, label %if.else.95, label %if.then.84

if.then.84:                                       ; preds = %lor.lhs.false.81, %if.end.66
  %84 = load %struct.op*, %struct.op** %expr.addr, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %84, i32 0, i32 0
  %85 = load %struct.op*, %struct.op** %op_next, align 8
  %tobool85 = icmp ne %struct.op* %85, null
  br i1 %tobool85, label %cond.true.86, label %cond.false.88

cond.true.86:                                     ; preds = %if.then.84
  %86 = load %struct.op*, %struct.op** %expr.addr, align 8
  %op_next87 = getelementptr inbounds %struct.op, %struct.op* %86, i32 0, i32 0
  %87 = load %struct.op*, %struct.op** %op_next87, align 8
  br label %cond.end.90

cond.false.88:                                    ; preds = %if.then.84
  %88 = load %struct.op*, %struct.op** %expr.addr, align 8
  %call89 = call %struct.op* @Perl_linklist(%struct.op* %88)
  br label %cond.end.90

cond.end.90:                                      ; preds = %cond.false.88, %cond.true.86
  %cond91 = phi %struct.op* [ %87, %cond.true.86 ], [ %call89, %cond.false.88 ]
  %89 = load %struct.op*, %struct.op** %expr.addr, align 8
  %90 = load %struct.logop*, %struct.logop** %rcop, align 8
  %op_next92 = getelementptr inbounds %struct.logop, %struct.logop* %90, i32 0, i32 0
  store %struct.op* %89, %struct.op** %op_next92, align 8
  %91 = load %struct.logop*, %struct.logop** %rcop, align 8
  %92 = bitcast %struct.logop* %91 to %struct.op*
  %93 = load %struct.op*, %struct.op** %expr.addr, align 8
  %94 = bitcast %struct.op* %93 to %struct.unop*
  %op_first93 = getelementptr inbounds %struct.unop, %struct.unop* %94, i32 0, i32 8
  %95 = load %struct.op*, %struct.op** %op_first93, align 8
  %op_next94 = getelementptr inbounds %struct.op, %struct.op* %95, i32 0, i32 0
  store %struct.op* %92, %struct.op** %op_next94, align 8
  br label %if.end.106

if.else.95:                                       ; preds = %lor.lhs.false.81
  %96 = load %struct.op*, %struct.op** %expr.addr, align 8
  %op_next96 = getelementptr inbounds %struct.op, %struct.op* %96, i32 0, i32 0
  %97 = load %struct.op*, %struct.op** %op_next96, align 8
  %tobool97 = icmp ne %struct.op* %97, null
  br i1 %tobool97, label %cond.true.98, label %cond.false.100

cond.true.98:                                     ; preds = %if.else.95
  %98 = load %struct.op*, %struct.op** %expr.addr, align 8
  %op_next99 = getelementptr inbounds %struct.op, %struct.op* %98, i32 0, i32 0
  %99 = load %struct.op*, %struct.op** %op_next99, align 8
  br label %cond.end.102

cond.false.100:                                   ; preds = %if.else.95
  %100 = load %struct.op*, %struct.op** %expr.addr, align 8
  %call101 = call %struct.op* @Perl_linklist(%struct.op* %100)
  br label %cond.end.102

cond.end.102:                                     ; preds = %cond.false.100, %cond.true.98
  %cond103 = phi %struct.op* [ %99, %cond.true.98 ], [ %call101, %cond.false.100 ]
  %101 = load %struct.logop*, %struct.logop** %rcop, align 8
  %op_next104 = getelementptr inbounds %struct.logop, %struct.logop* %101, i32 0, i32 0
  store %struct.op* %cond103, %struct.op** %op_next104, align 8
  %102 = load %struct.logop*, %struct.logop** %rcop, align 8
  %103 = bitcast %struct.logop* %102 to %struct.op*
  %104 = load %struct.op*, %struct.op** %expr.addr, align 8
  %op_next105 = getelementptr inbounds %struct.op, %struct.op* %104, i32 0, i32 0
  store %struct.op* %103, %struct.op** %op_next105, align 8
  br label %if.end.106

if.end.106:                                       ; preds = %cond.end.102, %cond.end.90
  %105 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type107 = getelementptr inbounds %struct.op, %struct.op* %105, i32 0, i32 4
  %106 = load i16, i16* %op_type107, align 2
  %conv108 = zext i16 %106 to i32
  %107 = load %struct.logop*, %struct.logop** %rcop, align 8
  %108 = bitcast %struct.logop* %107 to %struct.op*
  %call109 = call %struct.op* @Perl_scalar(%struct.op* %108)
  %109 = load %struct.op*, %struct.op** %o.addr, align 8
  %call110 = call %struct.op* @Perl_prepend_elem(i32 %conv108, %struct.op* %call109, %struct.op* %109)
  br label %if.end.111

if.end.111:                                       ; preds = %if.end.106, %if.end.55
  %110 = load %struct.op*, %struct.op** %repl.addr, align 8
  %tobool112 = icmp ne %struct.op* %110, null
  br i1 %tobool112, label %if.then.113, label %if.end.308

if.then.113:                                      ; preds = %if.end.111
  %111 = load %struct.pmop*, %struct.pmop** %pm, align 8
  %op_pmflags114 = getelementptr inbounds %struct.pmop, %struct.pmop* %111, i32 0, i32 14
  %112 = load i32, i32* %op_pmflags114, align 4
  %and115 = and i32 %112, 1024
  %tobool116 = icmp ne i32 %and115, 0
  br i1 %tobool116, label %if.then.117, label %if.else.123

if.then.117:                                      ; preds = %if.then.113
  store %struct.op* null, %struct.op** %curop, align 8
  %113 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_line = getelementptr inbounds %struct.cop, %struct.cop* %113, i32 0, i32 13
  %114 = load i32, i32* %cop_line, align 4
  %115 = load i32, i32* @PL_multi_end, align 4
  %cmp118 = icmp ult i32 %114, %115
  br i1 %cmp118, label %if.then.120, label %if.end.122

if.then.120:                                      ; preds = %if.then.117
  %116 = load i32, i32* @PL_multi_end, align 4
  %117 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_line121 = getelementptr inbounds %struct.cop, %struct.cop* %117, i32 0, i32 13
  store i32 %116, i32* %cop_line121, align 4
  br label %if.end.122

if.end.122:                                       ; preds = %if.then.120, %if.then.117
  br label %if.end.244

if.else.123:                                      ; preds = %if.then.113
  %118 = load %struct.op*, %struct.op** %repl.addr, align 8
  %op_type124 = getelementptr inbounds %struct.op, %struct.op* %118, i32 0, i32 4
  %119 = load i16, i16* %op_type124, align 2
  %conv125 = zext i16 %119 to i32
  %cmp126 = icmp eq i32 %conv125, 5
  br i1 %cmp126, label %if.then.128, label %if.else.129

if.then.128:                                      ; preds = %if.else.123
  %120 = load %struct.op*, %struct.op** %repl.addr, align 8
  store %struct.op* %120, %struct.op** %curop, align 8
  br label %if.end.243

if.else.129:                                      ; preds = %if.else.123
  store %struct.op* null, %struct.op** %lastop, align 8
  %121 = load %struct.op*, %struct.op** %repl.addr, align 8
  %op_next130 = getelementptr inbounds %struct.op, %struct.op* %121, i32 0, i32 0
  %122 = load %struct.op*, %struct.op** %op_next130, align 8
  %tobool131 = icmp ne %struct.op* %122, null
  br i1 %tobool131, label %cond.true.132, label %cond.false.134

cond.true.132:                                    ; preds = %if.else.129
  %123 = load %struct.op*, %struct.op** %repl.addr, align 8
  %op_next133 = getelementptr inbounds %struct.op, %struct.op* %123, i32 0, i32 0
  %124 = load %struct.op*, %struct.op** %op_next133, align 8
  br label %cond.end.136

cond.false.134:                                   ; preds = %if.else.129
  %125 = load %struct.op*, %struct.op** %repl.addr, align 8
  %call135 = call %struct.op* @Perl_linklist(%struct.op* %125)
  br label %cond.end.136

cond.end.136:                                     ; preds = %cond.false.134, %cond.true.132
  %cond137 = phi %struct.op* [ %124, %cond.true.132 ], [ %call135, %cond.false.134 ]
  store %struct.op* %cond137, %struct.op** %curop, align 8
  br label %for.cond

for.cond:                                         ; preds = %cond.end.241, %cond.end.136
  %126 = load %struct.op*, %struct.op** %curop, align 8
  %127 = load %struct.op*, %struct.op** %repl.addr, align 8
  %cmp138 = icmp ne %struct.op* %126, %127
  br i1 %cmp138, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %128 = load %struct.op*, %struct.op** %curop, align 8
  %op_type140 = getelementptr inbounds %struct.op, %struct.op* %128, i32 0, i32 4
  %129 = load i16, i16* %op_type140, align 2
  %idxprom = zext i16 %129 to i64
  %arrayidx141 = getelementptr inbounds [0 x i32], [0 x i32]* @PL_opargs, i32 0, i64 %idxprom
  %130 = load i32, i32* %arrayidx141, align 4
  %and142 = and i32 %130, 64
  %tobool143 = icmp ne i32 %and142, 0
  br i1 %tobool143, label %if.then.144, label %if.end.234

if.then.144:                                      ; preds = %for.body
  %131 = load %struct.op*, %struct.op** %curop, align 8
  %op_type145 = getelementptr inbounds %struct.op, %struct.op* %131, i32 0, i32 4
  %132 = load i16, i16* %op_type145, align 2
  %conv146 = zext i16 %132 to i32
  %cmp147 = icmp eq i32 %conv146, 7
  br i1 %cmp147, label %if.then.149, label %if.else.166

if.then.149:                                      ; preds = %if.then.144
  %133 = load %struct.op*, %struct.op** %curop, align 8
  %134 = bitcast %struct.op* %133 to %struct.svop*
  %op_sv150 = getelementptr inbounds %struct.svop, %struct.svop* %134, i32 0, i32 8
  %135 = load %struct.sv*, %struct.sv** %op_sv150, align 8
  %136 = bitcast %struct.sv* %135 to %struct.gv*
  store %struct.gv* %136, %struct.gv** %gv, align 8
  store i32 1, i32* %repl_has_vars, align 4
  %137 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any151 = getelementptr inbounds %struct.gv, %struct.gv* %137, i32 0, i32 0
  %138 = load %struct.xpvgv*, %struct.xpvgv** %sv_any151, align 8
  %xgv_gp = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %138, i32 0, i32 7
  %139 = load %struct.gp*, %struct.gp** %xgv_gp, align 8
  %gp_egv = getelementptr inbounds %struct.gp, %struct.gp* %139, i32 0, i32 6
  %140 = load %struct.gv*, %struct.gv** %gp_egv, align 8
  %tobool152 = icmp ne %struct.gv* %140, null
  br i1 %tobool152, label %cond.true.153, label %cond.false.157

cond.true.153:                                    ; preds = %if.then.149
  %141 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any154 = getelementptr inbounds %struct.gv, %struct.gv* %141, i32 0, i32 0
  %142 = load %struct.xpvgv*, %struct.xpvgv** %sv_any154, align 8
  %xgv_gp155 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %142, i32 0, i32 7
  %143 = load %struct.gp*, %struct.gp** %xgv_gp155, align 8
  %gp_egv156 = getelementptr inbounds %struct.gp, %struct.gp* %143, i32 0, i32 6
  %144 = load %struct.gv*, %struct.gv** %gp_egv156, align 8
  br label %cond.end.158

cond.false.157:                                   ; preds = %if.then.149
  %145 = load %struct.gv*, %struct.gv** %gv, align 8
  br label %cond.end.158

cond.end.158:                                     ; preds = %cond.false.157, %cond.true.153
  %cond159 = phi %struct.gv* [ %144, %cond.true.153 ], [ %145, %cond.false.157 ]
  %sv_any160 = getelementptr inbounds %struct.gv, %struct.gv* %cond159, i32 0, i32 0
  %146 = load %struct.xpvgv*, %struct.xpvgv** %sv_any160, align 8
  %xgv_name = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %146, i32 0, i32 8
  %147 = load i8*, i8** %xgv_name, align 8
  %148 = load i8, i8* %147, align 1
  %conv161 = sext i8 %148 to i32
  %call162 = call i8* @strchr(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.43, i32 0, i32 0), i32 %conv161)
  %tobool163 = icmp ne i8* %call162, null
  br i1 %tobool163, label %if.then.164, label %if.end.165

if.then.164:                                      ; preds = %cond.end.158
  br label %for.end

if.end.165:                                       ; preds = %cond.end.158
  br label %if.end.233

if.else.166:                                      ; preds = %if.then.144
  %149 = load %struct.op*, %struct.op** %curop, align 8
  %op_type167 = getelementptr inbounds %struct.op, %struct.op* %149, i32 0, i32 4
  %150 = load i16, i16* %op_type167, align 2
  %conv168 = zext i16 %150 to i32
  %cmp169 = icmp eq i32 %conv168, 17
  br i1 %cmp169, label %if.then.171, label %if.else.172

if.then.171:                                      ; preds = %if.else.166
  br label %for.end

if.else.172:                                      ; preds = %if.else.166
  %151 = load %struct.op*, %struct.op** %curop, align 8
  %op_type173 = getelementptr inbounds %struct.op, %struct.op* %151, i32 0, i32 4
  %152 = load i16, i16* %op_type173, align 2
  %conv174 = zext i16 %152 to i32
  %cmp175 = icmp eq i32 %conv174, 15
  br i1 %cmp175, label %if.then.192, label %lor.lhs.false.177

lor.lhs.false.177:                                ; preds = %if.else.172
  %153 = load %struct.op*, %struct.op** %curop, align 8
  %op_type178 = getelementptr inbounds %struct.op, %struct.op* %153, i32 0, i32 4
  %154 = load i16, i16* %op_type178, align 2
  %conv179 = zext i16 %154 to i32
  %cmp180 = icmp eq i32 %conv179, 125
  br i1 %cmp180, label %if.then.192, label %lor.lhs.false.182

lor.lhs.false.182:                                ; preds = %lor.lhs.false.177
  %155 = load %struct.op*, %struct.op** %curop, align 8
  %op_type183 = getelementptr inbounds %struct.op, %struct.op* %155, i32 0, i32 4
  %156 = load i16, i16* %op_type183, align 2
  %conv184 = zext i16 %156 to i32
  %cmp185 = icmp eq i32 %conv184, 134
  br i1 %cmp185, label %if.then.192, label %lor.lhs.false.187

lor.lhs.false.187:                                ; preds = %lor.lhs.false.182
  %157 = load %struct.op*, %struct.op** %curop, align 8
  %op_type188 = getelementptr inbounds %struct.op, %struct.op* %157, i32 0, i32 4
  %158 = load i16, i16* %op_type188, align 2
  %conv189 = zext i16 %158 to i32
  %cmp190 = icmp eq i32 %conv189, 14
  br i1 %cmp190, label %if.then.192, label %if.else.201

if.then.192:                                      ; preds = %lor.lhs.false.187, %lor.lhs.false.182, %lor.lhs.false.177, %if.else.172
  %159 = load %struct.op*, %struct.op** %lastop, align 8
  %tobool193 = icmp ne %struct.op* %159, null
  br i1 %tobool193, label %land.lhs.true.194, label %if.end.200

land.lhs.true.194:                                ; preds = %if.then.192
  %160 = load %struct.op*, %struct.op** %lastop, align 8
  %op_type195 = getelementptr inbounds %struct.op, %struct.op* %160, i32 0, i32 4
  %161 = load i16, i16* %op_type195, align 2
  %conv196 = zext i16 %161 to i32
  %cmp197 = icmp ne i32 %conv196, 7
  br i1 %cmp197, label %if.then.199, label %if.end.200

if.then.199:                                      ; preds = %land.lhs.true.194
  br label %for.end

if.end.200:                                       ; preds = %land.lhs.true.194, %if.then.192
  br label %if.end.231

if.else.201:                                      ; preds = %lor.lhs.false.187
  %162 = load %struct.op*, %struct.op** %curop, align 8
  %op_type202 = getelementptr inbounds %struct.op, %struct.op* %162, i32 0, i32 4
  %163 = load i16, i16* %op_type202, align 2
  %conv203 = zext i16 %163 to i32
  %cmp204 = icmp eq i32 %conv203, 9
  br i1 %cmp204, label %if.then.221, label %lor.lhs.false.206

lor.lhs.false.206:                                ; preds = %if.else.201
  %164 = load %struct.op*, %struct.op** %curop, align 8
  %op_type207 = getelementptr inbounds %struct.op, %struct.op* %164, i32 0, i32 4
  %165 = load i16, i16* %op_type207, align 2
  %conv208 = zext i16 %165 to i32
  %cmp209 = icmp eq i32 %conv208, 10
  br i1 %cmp209, label %if.then.221, label %lor.lhs.false.211

lor.lhs.false.211:                                ; preds = %lor.lhs.false.206
  %166 = load %struct.op*, %struct.op** %curop, align 8
  %op_type212 = getelementptr inbounds %struct.op, %struct.op* %166, i32 0, i32 4
  %167 = load i16, i16* %op_type212, align 2
  %conv213 = zext i16 %167 to i32
  %cmp214 = icmp eq i32 %conv213, 11
  br i1 %cmp214, label %if.then.221, label %lor.lhs.false.216

lor.lhs.false.216:                                ; preds = %lor.lhs.false.211
  %168 = load %struct.op*, %struct.op** %curop, align 8
  %op_type217 = getelementptr inbounds %struct.op, %struct.op* %168, i32 0, i32 4
  %169 = load i16, i16* %op_type217, align 2
  %conv218 = zext i16 %169 to i32
  %cmp219 = icmp eq i32 %conv218, 12
  br i1 %cmp219, label %if.then.221, label %if.else.222

if.then.221:                                      ; preds = %lor.lhs.false.216, %lor.lhs.false.211, %lor.lhs.false.206, %if.else.201
  store i32 1, i32* %repl_has_vars, align 4
  br label %if.end.230

if.else.222:                                      ; preds = %lor.lhs.false.216
  %170 = load %struct.op*, %struct.op** %curop, align 8
  %op_type223 = getelementptr inbounds %struct.op, %struct.op* %170, i32 0, i32 4
  %171 = load i16, i16* %op_type223, align 2
  %conv224 = zext i16 %171 to i32
  %cmp225 = icmp eq i32 %conv224, 13
  br i1 %cmp225, label %if.then.227, label %if.else.228

if.then.227:                                      ; preds = %if.else.222
  br label %if.end.229

if.else.228:                                      ; preds = %if.else.222
  br label %for.end

if.end.229:                                       ; preds = %if.then.227
  br label %if.end.230

if.end.230:                                       ; preds = %if.end.229, %if.then.221
  br label %if.end.231

if.end.231:                                       ; preds = %if.end.230, %if.end.200
  br label %if.end.232

if.end.232:                                       ; preds = %if.end.231
  br label %if.end.233

if.end.233:                                       ; preds = %if.end.232, %if.end.165
  br label %if.end.234

if.end.234:                                       ; preds = %if.end.233, %for.body
  %172 = load %struct.op*, %struct.op** %curop, align 8
  store %struct.op* %172, %struct.op** %lastop, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end.234
  %173 = load %struct.op*, %struct.op** %curop, align 8
  %op_next235 = getelementptr inbounds %struct.op, %struct.op* %173, i32 0, i32 0
  %174 = load %struct.op*, %struct.op** %op_next235, align 8
  %tobool236 = icmp ne %struct.op* %174, null
  br i1 %tobool236, label %cond.true.237, label %cond.false.239

cond.true.237:                                    ; preds = %for.inc
  %175 = load %struct.op*, %struct.op** %curop, align 8
  %op_next238 = getelementptr inbounds %struct.op, %struct.op* %175, i32 0, i32 0
  %176 = load %struct.op*, %struct.op** %op_next238, align 8
  br label %cond.end.241

cond.false.239:                                   ; preds = %for.inc
  %177 = load %struct.op*, %struct.op** %curop, align 8
  %call240 = call %struct.op* @Perl_linklist(%struct.op* %177)
  br label %cond.end.241

cond.end.241:                                     ; preds = %cond.false.239, %cond.true.237
  %cond242 = phi %struct.op* [ %176, %cond.true.237 ], [ %call240, %cond.false.239 ]
  store %struct.op* %cond242, %struct.op** %curop, align 8
  br label %for.cond

for.end:                                          ; preds = %if.else.228, %if.then.199, %if.then.171, %if.then.164, %for.cond
  br label %if.end.243

if.end.243:                                       ; preds = %for.end, %if.then.128
  br label %if.end.244

if.end.244:                                       ; preds = %if.end.243, %if.end.122
  %178 = load %struct.op*, %struct.op** %curop, align 8
  %179 = load %struct.op*, %struct.op** %repl.addr, align 8
  %cmp245 = icmp eq %struct.op* %178, %179
  br i1 %cmp245, label %land.lhs.true.247, label %if.else.264

land.lhs.true.247:                                ; preds = %if.end.244
  %180 = load i32, i32* %repl_has_vars, align 4
  %tobool248 = icmp ne i32 %180, 0
  br i1 %tobool248, label %land.lhs.true.249, label %if.then.256

land.lhs.true.249:                                ; preds = %land.lhs.true.247
  %181 = load %struct.pmop*, %struct.pmop** %pm, align 8
  %op_pmregexp250 = getelementptr inbounds %struct.pmop, %struct.pmop* %181, i32 0, i32 13
  %182 = load %struct.regexp*, %struct.regexp** %op_pmregexp250, align 8
  %tobool251 = icmp ne %struct.regexp* %182, null
  br i1 %tobool251, label %lor.lhs.false.252, label %if.else.264

lor.lhs.false.252:                                ; preds = %land.lhs.true.249
  %183 = load %struct.pmop*, %struct.pmop** %pm, align 8
  %op_pmregexp253 = getelementptr inbounds %struct.pmop, %struct.pmop* %183, i32 0, i32 13
  %184 = load %struct.regexp*, %struct.regexp** %op_pmregexp253, align 8
  %reganch = getelementptr inbounds %struct.regexp, %struct.regexp* %184, i32 0, i32 15
  %185 = load i32, i32* %reganch, align 4
  %and254 = and i32 %185, 1024
  %tobool255 = icmp ne i32 %and254, 0
  br i1 %tobool255, label %if.else.264, label %if.then.256

if.then.256:                                      ; preds = %lor.lhs.false.252, %land.lhs.true.247
  %186 = load %struct.pmop*, %struct.pmop** %pm, align 8
  %op_pmflags257 = getelementptr inbounds %struct.pmop, %struct.pmop* %186, i32 0, i32 14
  %187 = load i32, i32* %op_pmflags257, align 4
  %or258 = or i32 %187, 64
  store i32 %or258, i32* %op_pmflags257, align 4
  %188 = load %struct.pmop*, %struct.pmop** %pm, align 8
  %op_pmpermflags = getelementptr inbounds %struct.pmop, %struct.pmop* %188, i32 0, i32 15
  %189 = load i32, i32* %op_pmpermflags, align 4
  %or259 = or i32 %189, 64
  store i32 %or259, i32* %op_pmpermflags, align 4
  %190 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type260 = getelementptr inbounds %struct.op, %struct.op* %190, i32 0, i32 4
  %191 = load i16, i16* %op_type260, align 2
  %conv261 = zext i16 %191 to i32
  %192 = load %struct.op*, %struct.op** %repl.addr, align 8
  %call262 = call %struct.op* @Perl_scalar(%struct.op* %192)
  %193 = load %struct.op*, %struct.op** %o.addr, align 8
  %call263 = call %struct.op* @Perl_prepend_elem(i32 %conv261, %struct.op* %call262, %struct.op* %193)
  br label %if.end.307

if.else.264:                                      ; preds = %lor.lhs.false.252, %land.lhs.true.249, %if.end.244
  %194 = load %struct.op*, %struct.op** %curop, align 8
  %195 = load %struct.op*, %struct.op** %repl.addr, align 8
  %cmp265 = icmp eq %struct.op* %194, %195
  br i1 %cmp265, label %land.lhs.true.267, label %if.end.275

land.lhs.true.267:                                ; preds = %if.else.264
  %196 = load %struct.pmop*, %struct.pmop** %pm, align 8
  %op_pmregexp268 = getelementptr inbounds %struct.pmop, %struct.pmop* %196, i32 0, i32 13
  %197 = load %struct.regexp*, %struct.regexp** %op_pmregexp268, align 8
  %tobool269 = icmp ne %struct.regexp* %197, null
  br i1 %tobool269, label %if.end.275, label %if.then.270

if.then.270:                                      ; preds = %land.lhs.true.267
  %198 = load %struct.pmop*, %struct.pmop** %pm, align 8
  %op_pmflags271 = getelementptr inbounds %struct.pmop, %struct.pmop* %198, i32 0, i32 14
  %199 = load i32, i32* %op_pmflags271, align 4
  %or272 = or i32 %199, 8
  store i32 %or272, i32* %op_pmflags271, align 4
  %200 = load %struct.pmop*, %struct.pmop** %pm, align 8
  %op_pmpermflags273 = getelementptr inbounds %struct.pmop, %struct.pmop* %200, i32 0, i32 15
  %201 = load i32, i32* %op_pmpermflags273, align 4
  %or274 = or i32 %201, 8
  store i32 %or274, i32* %op_pmpermflags273, align 4
  br label %if.end.275

if.end.275:                                       ; preds = %if.then.270, %land.lhs.true.267, %if.else.264
  %call276 = call i8* @Perl_safesysmalloc(i64 56)
  %202 = bitcast i8* %call276 to %struct.logop*
  store %struct.logop* %202, %struct.logop** %rcop, align 8
  %203 = load %struct.logop*, %struct.logop** %rcop, align 8
  %204 = bitcast %struct.logop* %203 to i8*
  call void @llvm.memset.p0i8.i64(i8* %204, i8 0, i64 56, i32 1, i1 false)
  %205 = load %struct.logop*, %struct.logop** %rcop, align 8
  %op_type277 = getelementptr inbounds %struct.logop, %struct.logop* %205, i32 0, i32 4
  store i16 34, i16* %op_type277, align 2
  %206 = load %struct.op* ()*, %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 34), align 8
  %207 = load %struct.logop*, %struct.logop** %rcop, align 8
  %op_ppaddr278 = getelementptr inbounds %struct.logop, %struct.logop* %207, i32 0, i32 2
  store %struct.op* ()* %206, %struct.op* ()** %op_ppaddr278, align 8
  %208 = load %struct.op*, %struct.op** %repl.addr, align 8
  %call279 = call %struct.op* @Perl_scalar(%struct.op* %208)
  %209 = load %struct.logop*, %struct.logop** %rcop, align 8
  %op_first280 = getelementptr inbounds %struct.logop, %struct.logop* %209, i32 0, i32 8
  store %struct.op* %call279, %struct.op** %op_first280, align 8
  %210 = load %struct.logop*, %struct.logop** %rcop, align 8
  %op_flags281 = getelementptr inbounds %struct.logop, %struct.logop* %210, i32 0, i32 6
  %211 = load i8, i8* %op_flags281, align 1
  %conv282 = zext i8 %211 to i32
  %or283 = or i32 %conv282, 4
  %conv284 = trunc i32 %or283 to i8
  store i8 %conv284, i8* %op_flags281, align 1
  %212 = load %struct.logop*, %struct.logop** %rcop, align 8
  %op_private285 = getelementptr inbounds %struct.logop, %struct.logop* %212, i32 0, i32 7
  store i8 1, i8* %op_private285, align 1
  %213 = load %struct.op*, %struct.op** %o.addr, align 8
  %214 = load %struct.logop*, %struct.logop** %rcop, align 8
  %op_other286 = getelementptr inbounds %struct.logop, %struct.logop* %214, i32 0, i32 9
  store %struct.op* %213, %struct.op** %op_other286, align 8
  %215 = load %struct.op*, %struct.op** %repl.addr, align 8
  %op_next287 = getelementptr inbounds %struct.op, %struct.op* %215, i32 0, i32 0
  %216 = load %struct.op*, %struct.op** %op_next287, align 8
  %tobool288 = icmp ne %struct.op* %216, null
  br i1 %tobool288, label %cond.true.289, label %cond.false.291

cond.true.289:                                    ; preds = %if.end.275
  %217 = load %struct.op*, %struct.op** %repl.addr, align 8
  %op_next290 = getelementptr inbounds %struct.op, %struct.op* %217, i32 0, i32 0
  %218 = load %struct.op*, %struct.op** %op_next290, align 8
  br label %cond.end.293

cond.false.291:                                   ; preds = %if.end.275
  %219 = load %struct.op*, %struct.op** %repl.addr, align 8
  %call292 = call %struct.op* @Perl_linklist(%struct.op* %219)
  br label %cond.end.293

cond.end.293:                                     ; preds = %cond.false.291, %cond.true.289
  %cond294 = phi %struct.op* [ %218, %cond.true.289 ], [ %call292, %cond.false.291 ]
  %220 = load %struct.logop*, %struct.logop** %rcop, align 8
  %op_next295 = getelementptr inbounds %struct.logop, %struct.logop* %220, i32 0, i32 0
  store %struct.op* %cond294, %struct.op** %op_next295, align 8
  %221 = load %struct.logop*, %struct.logop** %rcop, align 8
  %222 = bitcast %struct.logop* %221 to %struct.op*
  %223 = load %struct.op*, %struct.op** %repl.addr, align 8
  %op_next296 = getelementptr inbounds %struct.op, %struct.op* %223, i32 0, i32 0
  store %struct.op* %222, %struct.op** %op_next296, align 8
  %224 = load %struct.logop*, %struct.logop** %rcop, align 8
  %225 = bitcast %struct.logop* %224 to %struct.op*
  %call297 = call %struct.op* @Perl_scalar(%struct.op* %225)
  %226 = load %struct.pmop*, %struct.pmop** %pm, align 8
  %op_pmreplroot = getelementptr inbounds %struct.pmop, %struct.pmop* %226, i32 0, i32 10
  store %struct.op* %call297, %struct.op** %op_pmreplroot, align 8
  %227 = load %struct.logop*, %struct.logop** %rcop, align 8
  %op_next298 = getelementptr inbounds %struct.logop, %struct.logop* %227, i32 0, i32 0
  %228 = load %struct.op*, %struct.op** %op_next298, align 8
  %tobool299 = icmp ne %struct.op* %228, null
  br i1 %tobool299, label %cond.true.300, label %cond.false.302

cond.true.300:                                    ; preds = %cond.end.293
  %229 = load %struct.logop*, %struct.logop** %rcop, align 8
  %op_next301 = getelementptr inbounds %struct.logop, %struct.logop* %229, i32 0, i32 0
  %230 = load %struct.op*, %struct.op** %op_next301, align 8
  br label %cond.end.304

cond.false.302:                                   ; preds = %cond.end.293
  %231 = load %struct.logop*, %struct.logop** %rcop, align 8
  %232 = bitcast %struct.logop* %231 to %struct.op*
  %call303 = call %struct.op* @Perl_linklist(%struct.op* %232)
  br label %cond.end.304

cond.end.304:                                     ; preds = %cond.false.302, %cond.true.300
  %cond305 = phi %struct.op* [ %230, %cond.true.300 ], [ %call303, %cond.false.302 ]
  %233 = load %struct.pmop*, %struct.pmop** %pm, align 8
  %op_pmreplstart = getelementptr inbounds %struct.pmop, %struct.pmop* %233, i32 0, i32 11
  store %struct.op* %cond305, %struct.op** %op_pmreplstart, align 8
  %234 = load %struct.logop*, %struct.logop** %rcop, align 8
  %op_next306 = getelementptr inbounds %struct.logop, %struct.logop* %234, i32 0, i32 0
  store %struct.op* null, %struct.op** %op_next306, align 8
  br label %if.end.307

if.end.307:                                       ; preds = %cond.end.304, %if.then.256
  br label %if.end.308

if.end.308:                                       ; preds = %if.end.307, %if.end.111
  %235 = load %struct.pmop*, %struct.pmop** %pm, align 8
  %236 = bitcast %struct.pmop* %235 to %struct.op*
  store %struct.op* %236, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.308, %if.then
  %237 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %237
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newPMOP(i32 %type, i32 %flags) #0 {
entry:
  %type.addr = alloca i32, align 4
  %flags.addr = alloca i32, align 4
  %pmop = alloca %struct.pmop*, align 8
  store i32 %type, i32* %type.addr, align 4
  store i32 %flags, i32* %flags.addr, align 4
  %call = call i8* @Perl_safesysmalloc(i64 112)
  %0 = bitcast i8* %call to %struct.pmop*
  store %struct.pmop* %0, %struct.pmop** %pmop, align 8
  %1 = load %struct.pmop*, %struct.pmop** %pmop, align 8
  %2 = bitcast %struct.pmop* %1 to i8*
  call void @llvm.memset.p0i8.i64(i8* %2, i8 0, i64 112, i32 1, i1 false)
  %3 = load i32, i32* %type.addr, align 4
  %conv = trunc i32 %3 to i16
  %4 = load %struct.pmop*, %struct.pmop** %pmop, align 8
  %op_type = getelementptr inbounds %struct.pmop, %struct.pmop* %4, i32 0, i32 4
  store i16 %conv, i16* %op_type, align 2
  %5 = load i32, i32* %type.addr, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds [0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 %idxprom
  %6 = load %struct.op* ()*, %struct.op* ()** %arrayidx, align 8
  %7 = load %struct.pmop*, %struct.pmop** %pmop, align 8
  %op_ppaddr = getelementptr inbounds %struct.pmop, %struct.pmop* %7, i32 0, i32 2
  store %struct.op* ()* %6, %struct.op* ()** %op_ppaddr, align 8
  %8 = load i32, i32* %flags.addr, align 4
  %conv1 = trunc i32 %8 to i8
  %9 = load %struct.pmop*, %struct.pmop** %pmop, align 8
  %op_flags = getelementptr inbounds %struct.pmop, %struct.pmop* %9, i32 0, i32 6
  store i8 %conv1, i8* %op_flags, align 1
  %10 = load i32, i32* %flags.addr, align 4
  %shr = ashr i32 %10, 8
  %or = or i32 0, %shr
  %conv2 = trunc i32 %or to i8
  %11 = load %struct.pmop*, %struct.pmop** %pmop, align 8
  %op_private = getelementptr inbounds %struct.pmop, %struct.pmop* %11, i32 0, i32 7
  store i8 %conv2, i8* %op_private, align 1
  %12 = load i32, i32* @PL_hints, align 4
  %and = and i32 %12, 1048576
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %13 = load %struct.pmop*, %struct.pmop** %pmop, align 8
  %op_pmpermflags = getelementptr inbounds %struct.pmop, %struct.pmop* %13, i32 0, i32 15
  %14 = load i32, i32* %op_pmpermflags, align 4
  %or3 = or i32 %14, 1
  store i32 %or3, i32* %op_pmpermflags, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %15 = load i32, i32* @PL_hints, align 4
  %and4 = and i32 %15, 4
  %tobool5 = icmp ne i32 %and4, 0
  br i1 %tobool5, label %if.then.6, label %if.end.9

if.then.6:                                        ; preds = %if.end
  %16 = load %struct.pmop*, %struct.pmop** %pmop, align 8
  %op_pmpermflags7 = getelementptr inbounds %struct.pmop, %struct.pmop* %16, i32 0, i32 15
  %17 = load i32, i32* %op_pmpermflags7, align 4
  %or8 = or i32 %17, 2048
  store i32 %or8, i32* %op_pmpermflags7, align 4
  br label %if.end.9

if.end.9:                                         ; preds = %if.then.6, %if.end
  %18 = load %struct.pmop*, %struct.pmop** %pmop, align 8
  %op_pmpermflags10 = getelementptr inbounds %struct.pmop, %struct.pmop* %18, i32 0, i32 15
  %19 = load i32, i32* %op_pmpermflags10, align 4
  %20 = load %struct.pmop*, %struct.pmop** %pmop, align 8
  %op_pmflags = getelementptr inbounds %struct.pmop, %struct.pmop* %20, i32 0, i32 14
  store i32 %19, i32* %op_pmflags, align 4
  %21 = load i32, i32* %type.addr, align 4
  %cmp = icmp ne i32 %21, 35
  br i1 %cmp, label %land.lhs.true, label %if.end.16

land.lhs.true:                                    ; preds = %if.end.9
  %22 = load %struct.hv*, %struct.hv** @PL_curstash, align 8
  %tobool12 = icmp ne %struct.hv* %22, null
  br i1 %tobool12, label %if.then.13, label %if.end.16

if.then.13:                                       ; preds = %land.lhs.true
  %23 = load %struct.hv*, %struct.hv** @PL_curstash, align 8
  %sv_any = getelementptr inbounds %struct.hv, %struct.hv* %23, i32 0, i32 0
  %24 = load %struct.xpvhv*, %struct.xpvhv** %sv_any, align 8
  %xhv_pmroot = getelementptr inbounds %struct.xpvhv, %struct.xpvhv* %24, i32 0, i32 9
  %25 = load %struct.pmop*, %struct.pmop** %xhv_pmroot, align 8
  %26 = load %struct.pmop*, %struct.pmop** %pmop, align 8
  %op_pmnext = getelementptr inbounds %struct.pmop, %struct.pmop* %26, i32 0, i32 12
  store %struct.pmop* %25, %struct.pmop** %op_pmnext, align 8
  %27 = load %struct.pmop*, %struct.pmop** %pmop, align 8
  %28 = load %struct.hv*, %struct.hv** @PL_curstash, align 8
  %sv_any14 = getelementptr inbounds %struct.hv, %struct.hv* %28, i32 0, i32 0
  %29 = load %struct.xpvhv*, %struct.xpvhv** %sv_any14, align 8
  %xhv_pmroot15 = getelementptr inbounds %struct.xpvhv, %struct.xpvhv* %29, i32 0, i32 9
  store %struct.pmop* %27, %struct.pmop** %xhv_pmroot15, align 8
  %30 = load %struct.hv*, %struct.hv** @PL_curstash, align 8
  %31 = load %struct.pmop*, %struct.pmop** %pmop, align 8
  %op_pmstash = getelementptr inbounds %struct.pmop, %struct.pmop* %31, i32 0, i32 17
  store %struct.hv* %30, %struct.hv** %op_pmstash, align 8
  br label %if.end.16

if.end.16:                                        ; preds = %if.then.13, %land.lhs.true, %if.end.9
  %32 = load i8*, i8** @PL_op_mask, align 8
  %tobool17 = icmp ne i8* %32, null
  br i1 %tobool17, label %land.lhs.true.18, label %cond.false

land.lhs.true.18:                                 ; preds = %if.end.16
  %33 = load i32, i32* %type.addr, align 4
  %idxprom19 = sext i32 %33 to i64
  %34 = load i8*, i8** @PL_op_mask, align 8
  %arrayidx20 = getelementptr inbounds i8, i8* %34, i64 %idxprom19
  %35 = load i8, i8* %arrayidx20, align 1
  %conv21 = sext i8 %35 to i32
  %tobool22 = icmp ne i32 %conv21, 0
  br i1 %tobool22, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true.18
  %36 = load %struct.pmop*, %struct.pmop** %pmop, align 8
  %37 = bitcast %struct.pmop* %36 to %struct.op*
  call void @Perl_op_free(%struct.op* %37)
  %38 = load i32, i32* %type.addr, align 4
  %idxprom23 = sext i32 %38 to i64
  %arrayidx24 = getelementptr inbounds [0 x i8*], [0 x i8*]* @PL_op_desc, i32 0, i64 %idxprom23
  %39 = load i8*, i8** %arrayidx24, align 8
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.33, i32 0, i32 0), i8* %39)
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true.18, %if.end.16
  %40 = load i32, i32* %type.addr, align 4
  %idxprom25 = sext i32 %40 to i64
  %arrayidx26 = getelementptr inbounds [0 x %struct.op* (%struct.op*)*], [0 x %struct.op* (%struct.op*)*]* @PL_check, i32 0, i64 %idxprom25
  %41 = load %struct.op* (%struct.op*)*, %struct.op* (%struct.op*)** %arrayidx26, align 8
  %42 = load %struct.pmop*, %struct.pmop** %pmop, align 8
  %43 = bitcast %struct.pmop* %42 to %struct.op*
  %call27 = call %struct.op* %41(%struct.op* %43)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.op* [ null, %cond.true ], [ %call27, %cond.false ]
  ret %struct.op* %cond
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_invert(%struct.op* %o) #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %o.addr = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %tobool = icmp ne %struct.op* %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %1, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.op*, %struct.op** %o.addr, align 8
  %call = call %struct.op* @Perl_scalar(%struct.op* %2)
  %call1 = call %struct.op* @Perl_newUNOP(i32 96, i32 128, %struct.op* %call)
  store %struct.op* %call1, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %3
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_scope(%struct.op* %o) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  %kid = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %tobool = icmp ne %struct.op* %0, null
  br i1 %tobool, label %if.then, label %if.end.30

if.then:                                          ; preds = %entry
  %1 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 6
  %2 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 8
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %if.then.8, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %3 = load i32, i32* @PL_perldb, align 4
  %tobool2 = icmp ne i32 %3, 0
  br i1 %tobool2, label %land.lhs.true, label %lor.lhs.false.5

land.lhs.true:                                    ; preds = %lor.lhs.false
  %4 = load i32, i32* @PL_perldb, align 4
  %and3 = and i32 %4, 4
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %if.then.8, label %lor.lhs.false.5

lor.lhs.false.5:                                  ; preds = %land.lhs.true, %lor.lhs.false
  %5 = load i8, i8* @PL_tainting, align 1
  %conv6 = sext i8 %5 to i32
  %tobool7 = icmp ne i32 %conv6, 0
  br i1 %tobool7, label %if.then.8, label %if.else

if.then.8:                                        ; preds = %lor.lhs.false.5, %land.lhs.true, %if.then
  %call = call %struct.op* @Perl_newOP(i32 177, i32 0)
  %6 = load %struct.op*, %struct.op** %o.addr, align 8
  %call9 = call %struct.op* @Perl_prepend_elem(i32 173, %struct.op* %call, %struct.op* %6)
  store %struct.op* %call9, %struct.op** %o.addr, align 8
  %7 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %7, i32 0, i32 4
  store i16 178, i16* %op_type, align 2
  %8 = load %struct.op* ()*, %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 178), align 8
  %9 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_ppaddr = getelementptr inbounds %struct.op, %struct.op* %9, i32 0, i32 2
  store %struct.op* ()* %8, %struct.op* ()** %op_ppaddr, align 8
  br label %if.end.29

if.else:                                          ; preds = %lor.lhs.false.5
  %10 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type10 = getelementptr inbounds %struct.op, %struct.op* %10, i32 0, i32 4
  %11 = load i16, i16* %op_type10, align 2
  %conv11 = zext i16 %11 to i32
  %cmp = icmp eq i32 %conv11, 173
  br i1 %cmp, label %if.then.13, label %if.else.26

if.then.13:                                       ; preds = %if.else
  %12 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type14 = getelementptr inbounds %struct.op, %struct.op* %12, i32 0, i32 4
  store i16 179, i16* %op_type14, align 2
  %13 = load %struct.op* ()*, %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 179), align 8
  %14 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_ppaddr15 = getelementptr inbounds %struct.op, %struct.op* %14, i32 0, i32 2
  store %struct.op* ()* %13, %struct.op* ()** %op_ppaddr15, align 8
  %15 = load %struct.op*, %struct.op** %o.addr, align 8
  %16 = bitcast %struct.op* %15 to %struct.listop*
  %op_first = getelementptr inbounds %struct.listop, %struct.listop* %16, i32 0, i32 8
  %17 = load %struct.op*, %struct.op** %op_first, align 8
  store %struct.op* %17, %struct.op** %kid, align 8
  %18 = load %struct.op*, %struct.op** %kid, align 8
  %op_type16 = getelementptr inbounds %struct.op, %struct.op* %18, i32 0, i32 4
  %19 = load i16, i16* %op_type16, align 2
  %conv17 = zext i16 %19 to i32
  %cmp18 = icmp eq i32 %conv17, 174
  br i1 %cmp18, label %if.then.25, label %lor.lhs.false.20

lor.lhs.false.20:                                 ; preds = %if.then.13
  %20 = load %struct.op*, %struct.op** %kid, align 8
  %op_type21 = getelementptr inbounds %struct.op, %struct.op* %20, i32 0, i32 4
  %21 = load i16, i16* %op_type21, align 2
  %conv22 = zext i16 %21 to i32
  %cmp23 = icmp eq i32 %conv22, 175
  br i1 %cmp23, label %if.then.25, label %if.end

if.then.25:                                       ; preds = %lor.lhs.false.20, %if.then.13
  %22 = load %struct.op*, %struct.op** %kid, align 8
  call void @Perl_op_null(%struct.op* %22)
  br label %if.end

if.end:                                           ; preds = %if.then.25, %lor.lhs.false.20
  br label %if.end.28

if.else.26:                                       ; preds = %if.else
  %23 = load %struct.op*, %struct.op** %o.addr, align 8
  %call27 = call %struct.op* @Perl_newLISTOP(i32 179, i32 0, %struct.op* %23, %struct.op* null)
  store %struct.op* %call27, %struct.op** %o.addr, align 8
  br label %if.end.28

if.end.28:                                        ; preds = %if.else.26, %if.end
  br label %if.end.29

if.end.29:                                        ; preds = %if.end.28, %if.then.8
  br label %if.end.30

if.end.30:                                        ; preds = %if.end.29, %entry
  %24 = load %struct.op*, %struct.op** %o.addr, align 8
  ret %struct.op* %24
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newLISTOP(i32 %type, i32 %flags, %struct.op* %first, %struct.op* %last) #0 {
entry:
  %type.addr = alloca i32, align 4
  %flags.addr = alloca i32, align 4
  %first.addr = alloca %struct.op*, align 8
  %last.addr = alloca %struct.op*, align 8
  %listop = alloca %struct.listop*, align 8
  %pushop = alloca %struct.op*, align 8
  store i32 %type, i32* %type.addr, align 4
  store i32 %flags, i32* %flags.addr, align 4
  store %struct.op* %first, %struct.op** %first.addr, align 8
  store %struct.op* %last, %struct.op** %last.addr, align 8
  %call = call i8* @Perl_safesysmalloc(i64 56)
  %0 = bitcast i8* %call to %struct.listop*
  store %struct.listop* %0, %struct.listop** %listop, align 8
  %1 = load %struct.listop*, %struct.listop** %listop, align 8
  %2 = bitcast %struct.listop* %1 to i8*
  call void @llvm.memset.p0i8.i64(i8* %2, i8 0, i64 56, i32 1, i1 false)
  %3 = load i32, i32* %type.addr, align 4
  %conv = trunc i32 %3 to i16
  %4 = load %struct.listop*, %struct.listop** %listop, align 8
  %op_type = getelementptr inbounds %struct.listop, %struct.listop* %4, i32 0, i32 4
  store i16 %conv, i16* %op_type, align 2
  %5 = load i32, i32* %type.addr, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds [0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 %idxprom
  %6 = load %struct.op* ()*, %struct.op* ()** %arrayidx, align 8
  %7 = load %struct.listop*, %struct.listop** %listop, align 8
  %op_ppaddr = getelementptr inbounds %struct.listop, %struct.listop* %7, i32 0, i32 2
  store %struct.op* ()* %6, %struct.op* ()** %op_ppaddr, align 8
  %8 = load %struct.op*, %struct.op** %first.addr, align 8
  %tobool = icmp ne %struct.op* %8, null
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %9 = load %struct.op*, %struct.op** %last.addr, align 8
  %tobool1 = icmp ne %struct.op* %9, null
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %10 = load i32, i32* %flags.addr, align 4
  %or = or i32 %10, 4
  store i32 %or, i32* %flags.addr, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  %11 = load i32, i32* %flags.addr, align 4
  %conv2 = trunc i32 %11 to i8
  %12 = load %struct.listop*, %struct.listop** %listop, align 8
  %op_flags = getelementptr inbounds %struct.listop, %struct.listop* %12, i32 0, i32 6
  store i8 %conv2, i8* %op_flags, align 1
  %13 = load %struct.op*, %struct.op** %last.addr, align 8
  %tobool3 = icmp ne %struct.op* %13, null
  br i1 %tobool3, label %if.else, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %14 = load %struct.op*, %struct.op** %first.addr, align 8
  %tobool4 = icmp ne %struct.op* %14, null
  br i1 %tobool4, label %if.then.5, label %if.else

if.then.5:                                        ; preds = %land.lhs.true
  %15 = load %struct.op*, %struct.op** %first.addr, align 8
  store %struct.op* %15, %struct.op** %last.addr, align 8
  br label %if.end.15

if.else:                                          ; preds = %land.lhs.true, %if.end
  %16 = load %struct.op*, %struct.op** %first.addr, align 8
  %tobool6 = icmp ne %struct.op* %16, null
  br i1 %tobool6, label %if.else.10, label %land.lhs.true.7

land.lhs.true.7:                                  ; preds = %if.else
  %17 = load %struct.op*, %struct.op** %last.addr, align 8
  %tobool8 = icmp ne %struct.op* %17, null
  br i1 %tobool8, label %if.then.9, label %if.else.10

if.then.9:                                        ; preds = %land.lhs.true.7
  %18 = load %struct.op*, %struct.op** %last.addr, align 8
  store %struct.op* %18, %struct.op** %first.addr, align 8
  br label %if.end.14

if.else.10:                                       ; preds = %land.lhs.true.7, %if.else
  %19 = load %struct.op*, %struct.op** %first.addr, align 8
  %tobool11 = icmp ne %struct.op* %19, null
  br i1 %tobool11, label %if.then.12, label %if.end.13

if.then.12:                                       ; preds = %if.else.10
  %20 = load %struct.op*, %struct.op** %last.addr, align 8
  %21 = load %struct.op*, %struct.op** %first.addr, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %21, i32 0, i32 1
  store %struct.op* %20, %struct.op** %op_sibling, align 8
  br label %if.end.13

if.end.13:                                        ; preds = %if.then.12, %if.else.10
  br label %if.end.14

if.end.14:                                        ; preds = %if.end.13, %if.then.9
  br label %if.end.15

if.end.15:                                        ; preds = %if.end.14, %if.then.5
  %22 = load %struct.op*, %struct.op** %first.addr, align 8
  %23 = load %struct.listop*, %struct.listop** %listop, align 8
  %op_first = getelementptr inbounds %struct.listop, %struct.listop* %23, i32 0, i32 8
  store %struct.op* %22, %struct.op** %op_first, align 8
  %24 = load %struct.op*, %struct.op** %last.addr, align 8
  %25 = load %struct.listop*, %struct.listop** %listop, align 8
  %op_last = getelementptr inbounds %struct.listop, %struct.listop* %25, i32 0, i32 9
  store %struct.op* %24, %struct.op** %op_last, align 8
  %26 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %26, 141
  br i1 %cmp, label %if.then.17, label %if.end.29

if.then.17:                                       ; preds = %if.end.15
  %call18 = call %struct.op* @Perl_newOP(i32 3, i32 0)
  store %struct.op* %call18, %struct.op** %pushop, align 8
  %27 = load %struct.op*, %struct.op** %first.addr, align 8
  %28 = load %struct.op*, %struct.op** %pushop, align 8
  %op_sibling19 = getelementptr inbounds %struct.op, %struct.op* %28, i32 0, i32 1
  store %struct.op* %27, %struct.op** %op_sibling19, align 8
  %29 = load %struct.op*, %struct.op** %pushop, align 8
  %30 = load %struct.listop*, %struct.listop** %listop, align 8
  %op_first20 = getelementptr inbounds %struct.listop, %struct.listop* %30, i32 0, i32 8
  store %struct.op* %29, %struct.op** %op_first20, align 8
  %31 = load %struct.listop*, %struct.listop** %listop, align 8
  %op_flags21 = getelementptr inbounds %struct.listop, %struct.listop* %31, i32 0, i32 6
  %32 = load i8, i8* %op_flags21, align 1
  %conv22 = zext i8 %32 to i32
  %or23 = or i32 %conv22, 4
  %conv24 = trunc i32 %or23 to i8
  store i8 %conv24, i8* %op_flags21, align 1
  %33 = load %struct.op*, %struct.op** %last.addr, align 8
  %tobool25 = icmp ne %struct.op* %33, null
  br i1 %tobool25, label %if.end.28, label %if.then.26

if.then.26:                                       ; preds = %if.then.17
  %34 = load %struct.op*, %struct.op** %pushop, align 8
  %35 = load %struct.listop*, %struct.listop** %listop, align 8
  %op_last27 = getelementptr inbounds %struct.listop, %struct.listop* %35, i32 0, i32 9
  store %struct.op* %34, %struct.op** %op_last27, align 8
  br label %if.end.28

if.end.28:                                        ; preds = %if.then.26, %if.then.17
  br label %if.end.29

if.end.29:                                        ; preds = %if.end.28, %if.end.15
  %36 = load i8*, i8** @PL_op_mask, align 8
  %tobool30 = icmp ne i8* %36, null
  br i1 %tobool30, label %land.lhs.true.31, label %cond.false

land.lhs.true.31:                                 ; preds = %if.end.29
  %37 = load i32, i32* %type.addr, align 4
  %idxprom32 = sext i32 %37 to i64
  %38 = load i8*, i8** @PL_op_mask, align 8
  %arrayidx33 = getelementptr inbounds i8, i8* %38, i64 %idxprom32
  %39 = load i8, i8* %arrayidx33, align 1
  %conv34 = sext i8 %39 to i32
  %tobool35 = icmp ne i32 %conv34, 0
  br i1 %tobool35, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true.31
  %40 = load %struct.listop*, %struct.listop** %listop, align 8
  %41 = bitcast %struct.listop* %40 to %struct.op*
  call void @Perl_op_free(%struct.op* %41)
  %42 = load i32, i32* %type.addr, align 4
  %idxprom36 = sext i32 %42 to i64
  %arrayidx37 = getelementptr inbounds [0 x i8*], [0 x i8*]* @PL_op_desc, i32 0, i64 %idxprom36
  %43 = load i8*, i8** %arrayidx37, align 8
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.33, i32 0, i32 0), i8* %43)
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true.31, %if.end.29
  %44 = load i32, i32* %type.addr, align 4
  %idxprom38 = sext i32 %44 to i64
  %arrayidx39 = getelementptr inbounds [0 x %struct.op* (%struct.op*)*], [0 x %struct.op* (%struct.op*)*]* @PL_check, i32 0, i64 %idxprom38
  %45 = load %struct.op* (%struct.op*)*, %struct.op* (%struct.op*)** %arrayidx39, align 8
  %46 = load %struct.listop*, %struct.listop** %listop, align 8
  %47 = bitcast %struct.listop* %46 to %struct.op*
  %call40 = call %struct.op* %45(%struct.op* %47)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.op* [ null, %cond.true ], [ %call40, %cond.false ]
  ret %struct.op* %cond
}

; Function Attrs: nounwind uwtable
define void @Perl_save_hints() #0 {
entry:
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([54 x i8], [54 x i8]* @.str.27, i32 0, i32 0))
  ret void
}

; Function Attrs: nounwind uwtable
define i32 @Perl_block_start(i32 %full) #0 {
entry:
  %retval = alloca i32, align 4
  %full.addr = alloca i32, align 4
  %retval1 = alloca i32, align 4
  %tmp = alloca i32, align 4
  store i32 %full, i32* %full.addr, align 4
  %0 = load i32, i32* @PL_savestack_ix, align 4
  store i32 %0, i32* %retval1, align 4
  %1 = load i32, i32* @PL_yynerrs, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32, i32* %retval1, align 4
  store i32 %2, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %3 = load i32, i32* %full.addr, align 4
  call void @Perl_pad_block_start(i32 %3)
  %4 = load i32, i32* @PL_savestack_ix, align 4
  %add = add nsw i32 %4, 3
  %5 = load i32, i32* @PL_savestack_max, align 4
  %cmp = icmp sgt i32 %add, %5
  br i1 %cmp, label %if.then.2, label %if.end.3

if.then.2:                                        ; preds = %if.end
  call void @Perl_savestack_grow()
  br label %if.end.3

if.end.3:                                         ; preds = %if.then.2, %if.end
  %6 = load i32, i32* @PL_hints, align 4
  %and = and i32 %6, 131072
  %tobool4 = icmp ne i32 %and, 0
  br i1 %tobool4, label %if.then.5, label %if.end.12

if.then.5:                                        ; preds = %if.end.3
  %7 = load %struct.gv*, %struct.gv** @PL_hintgv, align 8
  %sv_any = getelementptr inbounds %struct.gv, %struct.gv* %7, i32 0, i32 0
  %8 = load %struct.xpvgv*, %struct.xpvgv** %sv_any, align 8
  %xgv_gp = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %8, i32 0, i32 7
  %9 = load %struct.gp*, %struct.gp** %xgv_gp, align 8
  %gp_hv = getelementptr inbounds %struct.gp, %struct.gp* %9, i32 0, i32 5
  %10 = load %struct.hv*, %struct.hv** %gp_hv, align 8
  %11 = bitcast %struct.hv* %10 to i8*
  %12 = load i32, i32* @PL_savestack_ix, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* @PL_savestack_ix, align 4
  %idxprom = sext i32 %12 to i64
  %13 = load %union.any*, %union.any** @PL_savestack, align 8
  %arrayidx = getelementptr inbounds %union.any, %union.any* %13, i64 %idxprom
  %any_ptr = bitcast %union.any* %arrayidx to i8**
  store i8* %11, i8** %any_ptr, align 8
  %14 = load %struct.gv*, %struct.gv** @PL_hintgv, align 8
  %sv_any6 = getelementptr inbounds %struct.gv, %struct.gv* %14, i32 0, i32 0
  %15 = load %struct.xpvgv*, %struct.xpvgv** %sv_any6, align 8
  %xgv_gp7 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %15, i32 0, i32 7
  %16 = load %struct.gp*, %struct.gp** %xgv_gp7, align 8
  %gp_hv8 = getelementptr inbounds %struct.gp, %struct.gp* %16, i32 0, i32 5
  %17 = load %struct.hv*, %struct.hv** %gp_hv8, align 8
  %call = call %struct.hv* @Perl_newHVhv(%struct.hv* %17)
  %18 = load %struct.gv*, %struct.gv** @PL_hintgv, align 8
  %sv_any9 = getelementptr inbounds %struct.gv, %struct.gv* %18, i32 0, i32 0
  %19 = load %struct.xpvgv*, %struct.xpvgv** %sv_any9, align 8
  %xgv_gp10 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %19, i32 0, i32 7
  %20 = load %struct.gp*, %struct.gp** %xgv_gp10, align 8
  %gp_hv11 = getelementptr inbounds %struct.gp, %struct.gp* %20, i32 0, i32 5
  store %struct.hv* %call, %struct.hv** %gp_hv11, align 8
  br label %if.end.12

if.end.12:                                        ; preds = %if.then.5, %if.end.3
  %21 = load i32, i32* @PL_hints, align 4
  %22 = load i32, i32* @PL_savestack_ix, align 4
  %inc13 = add nsw i32 %22, 1
  store i32 %inc13, i32* @PL_savestack_ix, align 4
  %idxprom14 = sext i32 %22 to i64
  %23 = load %union.any*, %union.any** @PL_savestack, align 8
  %arrayidx15 = getelementptr inbounds %union.any, %union.any* %23, i64 %idxprom14
  %any_i32 = bitcast %union.any* %arrayidx15 to i32*
  store i32 %21, i32* %any_i32, align 4
  %24 = load i32, i32* @PL_savestack_ix, align 4
  %inc16 = add nsw i32 %24, 1
  store i32 %inc16, i32* @PL_savestack_ix, align 4
  %idxprom17 = sext i32 %24 to i64
  %25 = load %union.any*, %union.any** @PL_savestack, align 8
  %arrayidx18 = getelementptr inbounds %union.any, %union.any* %25, i64 %idxprom17
  %any_i3219 = bitcast %union.any* %arrayidx18 to i32*
  store i32 27, i32* %any_i3219, align 4
  store i32 27, i32* %tmp
  %26 = load i32, i32* %tmp
  %27 = load i32, i32* @PL_hints, align 4
  %and20 = and i32 %27, -257
  store i32 %and20, i32* @PL_hints, align 4
  call void @Perl_save_sptr(%struct.sv** getelementptr inbounds (%struct.cop, %struct.cop* @PL_compiling, i32 0, i32 14))
  %28 = load %struct.sv*, %struct.sv** getelementptr inbounds (%struct.cop, %struct.cop* @PL_compiling, i32 0, i32 14), align 8
  %cmp21 = icmp eq %struct.sv* %28, null
  br i1 %cmp21, label %if.end.27, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end.12
  %29 = load %struct.sv*, %struct.sv** getelementptr inbounds (%struct.cop, %struct.cop* @PL_compiling, i32 0, i32 14), align 8
  %cmp22 = icmp eq %struct.sv* %29, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 1)
  br i1 %cmp22, label %if.end.27, label %lor.lhs.false.23

lor.lhs.false.23:                                 ; preds = %lor.lhs.false
  %30 = load %struct.sv*, %struct.sv** getelementptr inbounds (%struct.cop, %struct.cop* @PL_compiling, i32 0, i32 14), align 8
  %cmp24 = icmp eq %struct.sv* %30, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 2)
  br i1 %cmp24, label %if.end.27, label %if.then.25

if.then.25:                                       ; preds = %lor.lhs.false.23
  %31 = load %struct.sv*, %struct.sv** getelementptr inbounds (%struct.cop, %struct.cop* @PL_compiling, i32 0, i32 14), align 8
  %call26 = call %struct.sv* @Perl_newSVsv(%struct.sv* %31)
  store %struct.sv* %call26, %struct.sv** getelementptr inbounds (%struct.cop, %struct.cop* @PL_compiling, i32 0, i32 14), align 8
  %32 = load %struct.sv*, %struct.sv** getelementptr inbounds (%struct.cop, %struct.cop* @PL_compiling, i32 0, i32 14), align 8
  call void @Perl_save_freesv(%struct.sv* %32)
  br label %if.end.27

if.end.27:                                        ; preds = %if.then.25, %lor.lhs.false.23, %lor.lhs.false, %if.end.12
  call void @Perl_save_sptr(%struct.sv** getelementptr inbounds (%struct.cop, %struct.cop* @PL_compiling, i32 0, i32 15))
  %33 = load %struct.sv*, %struct.sv** getelementptr inbounds (%struct.cop, %struct.cop* @PL_compiling, i32 0, i32 15), align 8
  %cmp28 = icmp eq %struct.sv* %33, null
  br i1 %cmp28, label %if.end.31, label %if.then.29

if.then.29:                                       ; preds = %if.end.27
  %34 = load %struct.sv*, %struct.sv** getelementptr inbounds (%struct.cop, %struct.cop* @PL_compiling, i32 0, i32 15), align 8
  %call30 = call %struct.sv* @Perl_newSVsv(%struct.sv* %34)
  store %struct.sv* %call30, %struct.sv** getelementptr inbounds (%struct.cop, %struct.cop* @PL_compiling, i32 0, i32 15), align 8
  %35 = load %struct.sv*, %struct.sv** getelementptr inbounds (%struct.cop, %struct.cop* @PL_compiling, i32 0, i32 15), align 8
  call void @Perl_save_freesv(%struct.sv* %35)
  br label %if.end.31

if.end.31:                                        ; preds = %if.then.29, %if.end.27
  %36 = load i32, i32* %retval1, align 4
  store i32 %36, i32* %retval
  br label %return

return:                                           ; preds = %if.end.31, %if.then
  %37 = load i32, i32* %retval
  ret i32 %37
}

declare void @Perl_pad_block_start(i32) #1

declare void @Perl_savestack_grow() #1

declare %struct.hv* @Perl_newHVhv(%struct.hv*) #1

declare void @Perl_save_sptr(%struct.sv**) #1

declare %struct.sv* @Perl_newSVsv(%struct.sv*) #1

declare void @Perl_save_freesv(%struct.sv*) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_block_end(i32 %floor, %struct.op* %seq) #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %floor.addr = alloca i32, align 4
  %seq.addr = alloca %struct.op*, align 8
  %needblockscope = alloca i32, align 4
  %retval1 = alloca %struct.op*, align 8
  store i32 %floor, i32* %floor.addr, align 4
  store %struct.op* %seq, %struct.op** %seq.addr, align 8
  %0 = load i32, i32* @PL_hints, align 4
  %and = and i32 %0, 256
  store i32 %and, i32* %needblockscope, align 4
  %1 = load %struct.op*, %struct.op** %seq.addr, align 8
  %call = call %struct.op* @Perl_scalarseq(%struct.op* %1)
  store %struct.op* %call, %struct.op** %retval1, align 8
  %2 = load i32, i32* @PL_yynerrs, align 4
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load %struct.op*, %struct.op** %retval1, align 8
  store %struct.op* %3, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %entry
  %4 = load i32, i32* @PL_savestack_ix, align 4
  %5 = load i32, i32* %floor.addr, align 4
  %cmp = icmp sgt i32 %4, %5
  br i1 %cmp, label %if.then.2, label %if.end.3

if.then.2:                                        ; preds = %if.end
  %6 = load i32, i32* %floor.addr, align 4
  call void @Perl_leave_scope(i32 %6)
  br label %if.end.3

if.end.3:                                         ; preds = %if.then.2, %if.end
  %7 = load i32, i32* @PL_hints, align 4
  %and4 = and i32 %7, 255
  %conv = trunc i32 %and4 to i8
  store i8 %conv, i8* getelementptr inbounds (%struct.cop, %struct.cop* @PL_compiling, i32 0, i32 7), align 1
  %8 = load i32, i32* %needblockscope, align 4
  %tobool5 = icmp ne i32 %8, 0
  br i1 %tobool5, label %if.then.6, label %if.end.7

if.then.6:                                        ; preds = %if.end.3
  %9 = load i32, i32* @PL_hints, align 4
  %or = or i32 %9, 256
  store i32 %or, i32* @PL_hints, align 4
  br label %if.end.7

if.end.7:                                         ; preds = %if.then.6, %if.end.3
  call void @Perl_pad_leavemy()
  %10 = load %struct.op*, %struct.op** %retval1, align 8
  store %struct.op* %10, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.7, %if.then
  %11 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %11
}

declare void @Perl_leave_scope(i32) #1

declare void @Perl_pad_leavemy() #1

; Function Attrs: nounwind uwtable
define void @Perl_newPROG(%struct.op* %o) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  %cv = alloca %struct.cv*, align 8
  %sp = alloca %struct.sv**, align 8
  %tmp = alloca i32, align 4
  %tmp45 = alloca %struct.sv*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load volatile i32, i32* @PL_in_eval, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load %struct.op*, %struct.op** @PL_eval_root, align 8
  %tobool1 = icmp ne %struct.op* %1, null
  br i1 %tobool1, label %if.then.2, label %if.end

if.then.2:                                        ; preds = %if.then
  br label %if.end.50

if.end:                                           ; preds = %if.then
  %2 = load volatile i32, i32* @PL_in_eval, align 4
  %and = and i32 %2, 4
  %tobool3 = icmp ne i32 %and, 0
  %cond = select i1 %tobool3, i32 128, i32 0
  %3 = load %struct.op*, %struct.op** %o.addr, align 8
  %call = call %struct.op* @Perl_newUNOP(i32 312, i32 %cond, %struct.op* %3)
  store %struct.op* %call, %struct.op** @PL_eval_root, align 8
  %4 = load %struct.op*, %struct.op** @PL_eval_root, align 8
  %call4 = call %struct.op* @Perl_linklist(%struct.op* %4)
  store %struct.op* %call4, %struct.op** @PL_eval_start, align 8
  %5 = load %struct.op*, %struct.op** @PL_eval_root, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %5, i32 0, i32 7
  %6 = load i8, i8* %op_private, align 1
  %conv = zext i8 %6 to i32
  %or = or i32 %conv, 64
  %conv5 = trunc i32 %or to i8
  store i8 %conv5, i8* %op_private, align 1
  %7 = load %struct.op*, %struct.op** @PL_eval_root, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %7, i32 0, i32 3
  store i64 1, i64* %op_targ, align 8
  %8 = load %struct.op*, %struct.op** @PL_eval_root, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %8, i32 0, i32 0
  store %struct.op* null, %struct.op** %op_next, align 8
  %9 = load void (%struct.op*)*, void (%struct.op*)** @PL_peepp, align 8
  %10 = load %struct.op*, %struct.op** @PL_eval_start, align 8
  call void %9(%struct.op* %10)
  br label %if.end.50

if.else:                                          ; preds = %entry
  %11 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %11, i32 0, i32 4
  %12 = load i16, i16* %op_type, align 2
  %conv6 = zext i16 %12 to i32
  %cmp = icmp eq i32 %conv6, 1
  br i1 %cmp, label %if.then.8, label %if.end.9

if.then.8:                                        ; preds = %if.else
  store %struct.av* null, %struct.av** @PL_comppad_name, align 8
  store %struct.cv* null, %struct.cv** @PL_compcv, align 8
  %13 = load %struct.op*, %struct.op** %o.addr, align 8
  %14 = bitcast %struct.op* %13 to i8*
  call void @Perl_safesysfree(i8* %14)
  br label %if.end.50

if.end.9:                                         ; preds = %if.else
  %15 = load %struct.op*, %struct.op** %o.addr, align 8
  %call10 = call %struct.op* @Perl_scalarvoid(%struct.op* %15)
  %call11 = call %struct.op* @Perl_sawparens(%struct.op* %call10)
  %call12 = call %struct.op* @Perl_scope(%struct.op* %call11)
  store %struct.op* %call12, %struct.op** @PL_main_root, align 8
  store volatile %struct.cop* @PL_compiling, %struct.cop** @PL_curcop, align 8
  %16 = load %struct.op*, %struct.op** @PL_main_root, align 8
  %op_next13 = getelementptr inbounds %struct.op, %struct.op* %16, i32 0, i32 0
  %17 = load %struct.op*, %struct.op** %op_next13, align 8
  %tobool14 = icmp ne %struct.op* %17, null
  br i1 %tobool14, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.9
  %18 = load %struct.op*, %struct.op** @PL_main_root, align 8
  %op_next15 = getelementptr inbounds %struct.op, %struct.op* %18, i32 0, i32 0
  %19 = load %struct.op*, %struct.op** %op_next15, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end.9
  %20 = load %struct.op*, %struct.op** @PL_main_root, align 8
  %call16 = call %struct.op* @Perl_linklist(%struct.op* %20)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond17 = phi %struct.op* [ %19, %cond.true ], [ %call16, %cond.false ]
  store %struct.op* %cond17, %struct.op** @PL_main_start, align 8
  %21 = load %struct.op*, %struct.op** @PL_main_root, align 8
  %op_private18 = getelementptr inbounds %struct.op, %struct.op* %21, i32 0, i32 7
  %22 = load i8, i8* %op_private18, align 1
  %conv19 = zext i8 %22 to i32
  %or20 = or i32 %conv19, 64
  %conv21 = trunc i32 %or20 to i8
  store i8 %conv21, i8* %op_private18, align 1
  %23 = load %struct.op*, %struct.op** @PL_main_root, align 8
  %op_targ22 = getelementptr inbounds %struct.op, %struct.op* %23, i32 0, i32 3
  store i64 1, i64* %op_targ22, align 8
  %24 = load %struct.op*, %struct.op** @PL_main_root, align 8
  %op_next23 = getelementptr inbounds %struct.op, %struct.op* %24, i32 0, i32 0
  store %struct.op* null, %struct.op** %op_next23, align 8
  %25 = load void (%struct.op*)*, void (%struct.op*)** @PL_peepp, align 8
  %26 = load %struct.op*, %struct.op** @PL_main_start, align 8
  call void %25(%struct.op* %26)
  store %struct.cv* null, %struct.cv** @PL_compcv, align 8
  %27 = load i32, i32* @PL_perldb, align 4
  %tobool24 = icmp ne i32 %27, 0
  br i1 %tobool24, label %land.lhs.true, label %if.end.49

land.lhs.true:                                    ; preds = %cond.end
  %28 = load i32, i32* @PL_perldb, align 4
  %and25 = and i32 %28, 8
  %tobool26 = icmp ne i32 %and25, 0
  br i1 %tobool26, label %if.then.27, label %if.end.49

if.then.27:                                       ; preds = %land.lhs.true
  %call28 = call %struct.cv* @Perl_get_cv(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.28, i32 0, i32 0), i32 0)
  store %struct.cv* %call28, %struct.cv** %cv, align 8
  %29 = load %struct.cv*, %struct.cv** %cv, align 8
  %tobool29 = icmp ne %struct.cv* %29, null
  br i1 %tobool29, label %if.then.30, label %if.end.48

if.then.30:                                       ; preds = %if.then.27
  %30 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %30, %struct.sv*** %sp, align 8
  %31 = load i32*, i32** @PL_markstack_ptr, align 8
  %incdec.ptr = getelementptr inbounds i32, i32* %31, i32 1
  store i32* %incdec.ptr, i32** @PL_markstack_ptr, align 8
  %32 = load i32*, i32** @PL_markstack_max, align 8
  %cmp31 = icmp eq i32* %incdec.ptr, %32
  br i1 %cmp31, label %if.then.33, label %if.end.34

if.then.33:                                       ; preds = %if.then.30
  call void @Perl_markstack_grow()
  br label %if.end.34

if.end.34:                                        ; preds = %if.then.33, %if.then.30
  %33 = load %struct.sv**, %struct.sv*** %sp, align 8
  %34 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %33 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %34 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %conv35 = trunc i64 %sub.ptr.div to i32
  %35 = load i32*, i32** @PL_markstack_ptr, align 8
  store i32 %conv35, i32* %35, align 4
  store i32 %conv35, i32* %tmp
  %36 = load i32, i32* %tmp
  %37 = load %struct.sv**, %struct.sv*** @PL_stack_max, align 8
  %38 = load %struct.sv**, %struct.sv*** %sp, align 8
  %sub.ptr.lhs.cast36 = ptrtoint %struct.sv** %37 to i64
  %sub.ptr.rhs.cast37 = ptrtoint %struct.sv** %38 to i64
  %sub.ptr.sub38 = sub i64 %sub.ptr.lhs.cast36, %sub.ptr.rhs.cast37
  %sub.ptr.div39 = sdiv exact i64 %sub.ptr.sub38, 8
  %cmp40 = icmp slt i64 %sub.ptr.div39, 1
  br i1 %cmp40, label %if.then.42, label %if.end.44

if.then.42:                                       ; preds = %if.end.34
  %39 = load %struct.sv**, %struct.sv*** %sp, align 8
  %40 = load %struct.sv**, %struct.sv*** %sp, align 8
  %call43 = call %struct.sv** @Perl_stack_grow(%struct.sv** %39, %struct.sv** %40, i32 1)
  store %struct.sv** %call43, %struct.sv*** %sp, align 8
  br label %if.end.44

if.end.44:                                        ; preds = %if.then.42, %if.end.34
  %41 = load %struct.gv*, %struct.gv** getelementptr inbounds (%struct.cop, %struct.cop* @PL_compiling, i32 0, i32 10), align 8
  %42 = bitcast %struct.gv* %41 to %struct.sv*
  %43 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr46 = getelementptr inbounds %struct.sv*, %struct.sv** %43, i32 1
  store %struct.sv** %incdec.ptr46, %struct.sv*** %sp, align 8
  store %struct.sv* %42, %struct.sv** %incdec.ptr46, align 8
  store %struct.sv* %42, %struct.sv** %tmp45
  %44 = load %struct.sv*, %struct.sv** %tmp45
  %45 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %45, %struct.sv*** @PL_stack_sp, align 8
  %46 = load %struct.cv*, %struct.cv** %cv, align 8
  %47 = bitcast %struct.cv* %46 to %struct.sv*
  %call47 = call i32 @Perl_call_sv(%struct.sv* %47, i32 2)
  br label %if.end.48

if.end.48:                                        ; preds = %if.end.44, %if.then.27
  br label %if.end.49

if.end.49:                                        ; preds = %if.end.48, %land.lhs.true, %cond.end
  br label %if.end.50

if.end.50:                                        ; preds = %if.then.2, %if.then.8, %if.end.49, %if.end
  ret void
}

declare %struct.cv* @Perl_get_cv(i8*, i32) #1

declare void @Perl_markstack_grow() #1

declare %struct.sv** @Perl_stack_grow(%struct.sv**, %struct.sv**, i32) #1

declare i32 @Perl_call_sv(%struct.sv*, i32) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_localize(%struct.op* %o, i32 %lex) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  %lex.addr = alloca i32, align 4
  %s = alloca i8*, align 8
  %sigil = alloca i8, align 1
  store %struct.op* %o, %struct.op** %o.addr, align 8
  store i32 %lex, i32* %lex.addr, align 4
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %0, i32 0, i32 6
  %1 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %1 to i32
  %and = and i32 %conv, 8
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end.148

if.else:                                          ; preds = %entry
  %2 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings = getelementptr inbounds %struct.cop, %struct.cop* %2, i32 0, i32 14
  %3 = load %struct.sv*, %struct.sv** %cop_warnings, align 8
  %cmp = icmp ne %struct.sv* %3, null
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false.13

land.lhs.true:                                    ; preds = %if.else
  %4 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings2 = getelementptr inbounds %struct.cop, %struct.cop* %4, i32 0, i32 14
  %5 = load %struct.sv*, %struct.sv** %cop_warnings2, align 8
  %cmp3 = icmp ne %struct.sv* %5, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 2)
  br i1 %cmp3, label %land.lhs.true.5, label %lor.lhs.false.13

land.lhs.true.5:                                  ; preds = %land.lhs.true
  %6 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings6 = getelementptr inbounds %struct.cop, %struct.cop* %6, i32 0, i32 14
  %7 = load %struct.sv*, %struct.sv** %cop_warnings6, align 8
  %cmp7 = icmp eq %struct.sv* %7, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 1)
  br i1 %cmp7, label %land.lhs.true.21, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true.5
  %8 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings9 = getelementptr inbounds %struct.cop, %struct.cop* %8, i32 0, i32 14
  %9 = load %struct.sv*, %struct.sv** %cop_warnings9, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %9, i32 0, i32 0
  %10 = load i8*, i8** %sv_any, align 8
  %11 = bitcast i8* %10 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %11, i32 0, i32 0
  %12 = load i8*, i8** %xpv_pv, align 8
  %arrayidx = getelementptr inbounds i8, i8* %12, i64 8
  %13 = load i8, i8* %arrayidx, align 1
  %conv10 = sext i8 %13 to i32
  %and11 = and i32 %conv10, 1
  %tobool12 = icmp ne i32 %and11, 0
  br i1 %tobool12, label %land.lhs.true.21, label %lor.lhs.false.13

lor.lhs.false.13:                                 ; preds = %lor.lhs.false, %land.lhs.true, %if.else
  %14 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings14 = getelementptr inbounds %struct.cop, %struct.cop* %14, i32 0, i32 14
  %15 = load %struct.sv*, %struct.sv** %cop_warnings14, align 8
  %cmp15 = icmp eq %struct.sv* %15, null
  br i1 %cmp15, label %land.lhs.true.17, label %if.end.147

land.lhs.true.17:                                 ; preds = %lor.lhs.false.13
  %16 = load i8, i8* @PL_dowarn, align 1
  %conv18 = zext i8 %16 to i32
  %and19 = and i32 %conv18, 1
  %tobool20 = icmp ne i32 %and19, 0
  br i1 %tobool20, label %land.lhs.true.21, label %if.end.147

land.lhs.true.21:                                 ; preds = %land.lhs.true.17, %lor.lhs.false, %land.lhs.true.5
  %17 = load i8*, i8** @PL_bufptr, align 8
  %18 = load i8*, i8** @PL_oldbufptr, align 8
  %cmp22 = icmp ugt i8* %17, %18
  br i1 %cmp22, label %land.lhs.true.24, label %if.end.147

land.lhs.true.24:                                 ; preds = %land.lhs.true.21
  %19 = load i8*, i8** @PL_bufptr, align 8
  %arrayidx25 = getelementptr inbounds i8, i8* %19, i64 -1
  %20 = load i8, i8* %arrayidx25, align 1
  %conv26 = sext i8 %20 to i32
  %cmp27 = icmp eq i32 %conv26, 44
  br i1 %cmp27, label %if.then.29, label %if.end.147

if.then.29:                                       ; preds = %land.lhs.true.24
  %21 = load i8*, i8** @PL_bufptr, align 8
  store i8* %21, i8** %s, align 8
  store i8 0, i8* %sigil, align 1
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then.29
  %22 = load i8*, i8** %s, align 8
  %23 = load i8, i8* %22, align 1
  %conv30 = sext i8 %23 to i32
  %tobool31 = icmp ne i32 %conv30, 0
  br i1 %tobool31, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %24 = load i8*, i8** %s, align 8
  %25 = load i8, i8* %24, align 1
  %conv32 = sext i8 %25 to i32
  %call = call i8* @strchr(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.29, i32 0, i32 0), i32 %conv32)
  %tobool33 = icmp ne i8* %call, null
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %26 = phi i1 [ false, %while.cond ], [ %tobool33, %land.rhs ]
  br i1 %26, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %27 = load i8*, i8** %s, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %27, i32 1
  store i8* %incdec.ptr, i8** %s, align 8
  br label %while.cond

while.end:                                        ; preds = %land.end
  br label %while.body.35

while.body.35:                                    ; preds = %while.end, %if.end
  %28 = load i8*, i8** %s, align 8
  %29 = load i8, i8* %28, align 1
  %conv36 = sext i8 %29 to i32
  %tobool37 = icmp ne i32 %conv36, 0
  br i1 %tobool37, label %land.lhs.true.38, label %if.else.129

land.lhs.true.38:                                 ; preds = %while.body.35
  %30 = load i8*, i8** %s, align 8
  %31 = load i8, i8* %30, align 1
  %conv39 = sext i8 %31 to i32
  %call40 = call i8* @strchr(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.30, i32 0, i32 0), i32 %conv39)
  %tobool41 = icmp ne i8* %call40, null
  br i1 %tobool41, label %land.lhs.true.42, label %if.else.129

land.lhs.true.42:                                 ; preds = %land.lhs.true.38
  %32 = load i8*, i8** %s, align 8
  %incdec.ptr43 = getelementptr inbounds i8, i8* %32, i32 1
  store i8* %incdec.ptr43, i8** %s, align 8
  %33 = load i8, i8* %incdec.ptr43, align 1
  %conv44 = sext i8 %33 to i32
  %tobool45 = icmp ne i32 %conv44, 0
  br i1 %tobool45, label %land.lhs.true.46, label %if.else.129

land.lhs.true.46:                                 ; preds = %land.lhs.true.42
  %34 = load i8*, i8** %s, align 8
  %35 = load i8, i8* %34, align 1
  %conv47 = sext i8 %35 to i32
  %cmp48 = icmp sge i32 %conv47, 65
  br i1 %cmp48, label %land.lhs.true.50, label %lor.lhs.false.54

land.lhs.true.50:                                 ; preds = %land.lhs.true.46
  %36 = load i8*, i8** %s, align 8
  %37 = load i8, i8* %36, align 1
  %conv51 = sext i8 %37 to i32
  %cmp52 = icmp sle i32 %conv51, 90
  br i1 %cmp52, label %if.then.78, label %lor.lhs.false.54

lor.lhs.false.54:                                 ; preds = %land.lhs.true.50, %land.lhs.true.46
  %38 = load i8*, i8** %s, align 8
  %39 = load i8, i8* %38, align 1
  %conv55 = sext i8 %39 to i32
  %cmp56 = icmp sge i32 %conv55, 97
  br i1 %cmp56, label %land.lhs.true.58, label %lor.lhs.false.62

land.lhs.true.58:                                 ; preds = %lor.lhs.false.54
  %40 = load i8*, i8** %s, align 8
  %41 = load i8, i8* %40, align 1
  %conv59 = sext i8 %41 to i32
  %cmp60 = icmp sle i32 %conv59, 122
  br i1 %cmp60, label %if.then.78, label %lor.lhs.false.62

lor.lhs.false.62:                                 ; preds = %land.lhs.true.58, %lor.lhs.false.54
  %42 = load i8*, i8** %s, align 8
  %43 = load i8, i8* %42, align 1
  %conv63 = sext i8 %43 to i32
  %cmp64 = icmp sge i32 %conv63, 48
  br i1 %cmp64, label %land.lhs.true.66, label %lor.lhs.false.70

land.lhs.true.66:                                 ; preds = %lor.lhs.false.62
  %44 = load i8*, i8** %s, align 8
  %45 = load i8, i8* %44, align 1
  %conv67 = sext i8 %45 to i32
  %cmp68 = icmp sle i32 %conv67, 57
  br i1 %cmp68, label %if.then.78, label %lor.lhs.false.70

lor.lhs.false.70:                                 ; preds = %land.lhs.true.66, %lor.lhs.false.62
  %46 = load i8*, i8** %s, align 8
  %47 = load i8, i8* %46, align 1
  %conv71 = sext i8 %47 to i32
  %cmp72 = icmp eq i32 %conv71, 95
  br i1 %cmp72, label %if.then.78, label %lor.lhs.false.74

lor.lhs.false.74:                                 ; preds = %lor.lhs.false.70
  %48 = load i8*, i8** %s, align 8
  %49 = load i8, i8* %48, align 1
  %conv75 = zext i8 %49 to i32
  %and76 = and i32 %conv75, 128
  %tobool77 = icmp ne i32 %and76, 0
  br i1 %tobool77, label %if.then.78, label %if.else.129

if.then.78:                                       ; preds = %lor.lhs.false.74, %lor.lhs.false.70, %land.lhs.true.66, %land.lhs.true.58, %land.lhs.true.50
  %50 = load i8*, i8** %s, align 8
  %incdec.ptr79 = getelementptr inbounds i8, i8* %50, i32 1
  store i8* %incdec.ptr79, i8** %s, align 8
  store i8 1, i8* %sigil, align 1
  br label %while.cond.80

while.cond.80:                                    ; preds = %while.body.115, %if.then.78
  %51 = load i8*, i8** %s, align 8
  %52 = load i8, i8* %51, align 1
  %conv81 = sext i8 %52 to i32
  %tobool82 = icmp ne i32 %conv81, 0
  br i1 %tobool82, label %land.rhs.83, label %land.end.114

land.rhs.83:                                      ; preds = %while.cond.80
  %53 = load i8*, i8** %s, align 8
  %54 = load i8, i8* %53, align 1
  %conv84 = sext i8 %54 to i32
  %cmp85 = icmp sge i32 %conv84, 65
  br i1 %cmp85, label %land.lhs.true.87, label %lor.lhs.false.91

land.lhs.true.87:                                 ; preds = %land.rhs.83
  %55 = load i8*, i8** %s, align 8
  %56 = load i8, i8* %55, align 1
  %conv88 = sext i8 %56 to i32
  %cmp89 = icmp sle i32 %conv88, 90
  br i1 %cmp89, label %lor.end, label %lor.lhs.false.91

lor.lhs.false.91:                                 ; preds = %land.lhs.true.87, %land.rhs.83
  %57 = load i8*, i8** %s, align 8
  %58 = load i8, i8* %57, align 1
  %conv92 = sext i8 %58 to i32
  %cmp93 = icmp sge i32 %conv92, 97
  br i1 %cmp93, label %land.lhs.true.95, label %lor.lhs.false.99

land.lhs.true.95:                                 ; preds = %lor.lhs.false.91
  %59 = load i8*, i8** %s, align 8
  %60 = load i8, i8* %59, align 1
  %conv96 = sext i8 %60 to i32
  %cmp97 = icmp sle i32 %conv96, 122
  br i1 %cmp97, label %lor.end, label %lor.lhs.false.99

lor.lhs.false.99:                                 ; preds = %land.lhs.true.95, %lor.lhs.false.91
  %61 = load i8*, i8** %s, align 8
  %62 = load i8, i8* %61, align 1
  %conv100 = sext i8 %62 to i32
  %cmp101 = icmp sge i32 %conv100, 48
  br i1 %cmp101, label %land.lhs.true.103, label %lor.lhs.false.107

land.lhs.true.103:                                ; preds = %lor.lhs.false.99
  %63 = load i8*, i8** %s, align 8
  %64 = load i8, i8* %63, align 1
  %conv104 = sext i8 %64 to i32
  %cmp105 = icmp sle i32 %conv104, 57
  br i1 %cmp105, label %lor.end, label %lor.lhs.false.107

lor.lhs.false.107:                                ; preds = %land.lhs.true.103, %lor.lhs.false.99
  %65 = load i8*, i8** %s, align 8
  %66 = load i8, i8* %65, align 1
  %conv108 = sext i8 %66 to i32
  %cmp109 = icmp eq i32 %conv108, 95
  br i1 %cmp109, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false.107
  %67 = load i8*, i8** %s, align 8
  %68 = load i8, i8* %67, align 1
  %conv111 = zext i8 %68 to i32
  %and112 = and i32 %conv111, 128
  %tobool113 = icmp ne i32 %and112, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false.107, %land.lhs.true.103, %land.lhs.true.95, %land.lhs.true.87
  %69 = phi i1 [ true, %lor.lhs.false.107 ], [ true, %land.lhs.true.103 ], [ true, %land.lhs.true.95 ], [ true, %land.lhs.true.87 ], [ %tobool113, %lor.rhs ]
  br label %land.end.114

land.end.114:                                     ; preds = %lor.end, %while.cond.80
  %70 = phi i1 [ false, %while.cond.80 ], [ %69, %lor.end ]
  br i1 %70, label %while.body.115, label %while.end.117

while.body.115:                                   ; preds = %land.end.114
  %71 = load i8*, i8** %s, align 8
  %incdec.ptr116 = getelementptr inbounds i8, i8* %71, i32 1
  store i8* %incdec.ptr116, i8** %s, align 8
  br label %while.cond.80

while.end.117:                                    ; preds = %land.end.114
  br label %while.cond.118

while.cond.118:                                   ; preds = %while.body.126, %while.end.117
  %72 = load i8*, i8** %s, align 8
  %73 = load i8, i8* %72, align 1
  %conv119 = sext i8 %73 to i32
  %tobool120 = icmp ne i32 %conv119, 0
  br i1 %tobool120, label %land.rhs.121, label %land.end.125

land.rhs.121:                                     ; preds = %while.cond.118
  %74 = load i8*, i8** %s, align 8
  %75 = load i8, i8* %74, align 1
  %conv122 = sext i8 %75 to i32
  %call123 = call i8* @strchr(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.29, i32 0, i32 0), i32 %conv122)
  %tobool124 = icmp ne i8* %call123, null
  br label %land.end.125

land.end.125:                                     ; preds = %land.rhs.121, %while.cond.118
  %76 = phi i1 [ false, %while.cond.118 ], [ %tobool124, %land.rhs.121 ]
  br i1 %76, label %while.body.126, label %while.end.128

while.body.126:                                   ; preds = %land.end.125
  %77 = load i8*, i8** %s, align 8
  %incdec.ptr127 = getelementptr inbounds i8, i8* %77, i32 1
  store i8* %incdec.ptr127, i8** %s, align 8
  br label %while.cond.118

while.end.128:                                    ; preds = %land.end.125
  br label %if.end

if.else.129:                                      ; preds = %lor.lhs.false.74, %land.lhs.true.42, %land.lhs.true.38, %while.body.35
  br label %while.end.130

if.end:                                           ; preds = %while.end.128
  br label %while.body.35

while.end.130:                                    ; preds = %if.else.129
  %78 = load i8, i8* %sigil, align 1
  %conv131 = sext i8 %78 to i32
  %tobool132 = icmp ne i32 %conv131, 0
  br i1 %tobool132, label %land.lhs.true.133, label %if.end.146

land.lhs.true.133:                                ; preds = %while.end.130
  %79 = load i8*, i8** %s, align 8
  %80 = load i8, i8* %79, align 1
  %conv134 = sext i8 %80 to i32
  %cmp135 = icmp eq i32 %conv134, 59
  br i1 %cmp135, label %if.then.141, label %lor.lhs.false.137

lor.lhs.false.137:                                ; preds = %land.lhs.true.133
  %81 = load i8*, i8** %s, align 8
  %82 = load i8, i8* %81, align 1
  %conv138 = sext i8 %82 to i32
  %cmp139 = icmp eq i32 %conv138, 61
  br i1 %cmp139, label %if.then.141, label %if.end.146

if.then.141:                                      ; preds = %lor.lhs.false.137, %land.lhs.true.133
  %83 = load i32, i32* %lex.addr, align 4
  %tobool142 = icmp ne i32 %83, 0
  br i1 %tobool142, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.141
  %84 = load i32, i32* @PL_in_my, align 4
  %cmp143 = icmp eq i32 %84, 137
  %cond = select i1 %cmp143, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.4, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.5, i32 0, i32 0)
  br label %cond.end

cond.false:                                       ; preds = %if.then.141
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond145 = phi i8* [ %cond, %cond.true ], [ getelementptr inbounds ([6 x i8], [6 x i8]* @.str.21, i32 0, i32 0), %cond.false ]
  call void (i32, i8*, ...) @Perl_warner(i32 32, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.31, i32 0, i32 0), i8* %cond145)
  br label %if.end.146

if.end.146:                                       ; preds = %cond.end, %lor.lhs.false.137, %while.end.130
  br label %if.end.147

if.end.147:                                       ; preds = %if.end.146, %land.lhs.true.24, %land.lhs.true.21, %land.lhs.true.17, %lor.lhs.false.13
  br label %if.end.148

if.end.148:                                       ; preds = %if.end.147, %if.then
  %85 = load i32, i32* %lex.addr, align 4
  %tobool149 = icmp ne i32 %85, 0
  br i1 %tobool149, label %if.then.150, label %if.else.152

if.then.150:                                      ; preds = %if.end.148
  %86 = load %struct.op*, %struct.op** %o.addr, align 8
  %call151 = call %struct.op* @Perl_my(%struct.op* %86)
  store %struct.op* %call151, %struct.op** %o.addr, align 8
  br label %if.end.154

if.else.152:                                      ; preds = %if.end.148
  %87 = load %struct.op*, %struct.op** %o.addr, align 8
  %call153 = call %struct.op* @Perl_mod(%struct.op* %87, i32 0)
  store %struct.op* %call153, %struct.op** %o.addr, align 8
  br label %if.end.154

if.end.154:                                       ; preds = %if.else.152, %if.then.150
  store i32 0, i32* @PL_in_my, align 4
  store %struct.hv* null, %struct.hv** @PL_in_my_stash, align 8
  %88 = load %struct.op*, %struct.op** %o.addr, align 8
  ret %struct.op* %88
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_jmaybe(%struct.op* %o) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  %o2 = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %0, i32 0, i32 4
  %1 = load i16, i16* %op_type, align 2
  %conv = zext i16 %1 to i32
  %cmp = icmp eq i32 %conv, 141
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.32, i32 0, i32 0), i32 1, i32 4)
  %call2 = call %struct.op* @Perl_newGVOP(i32 7, i32 0, %struct.gv* %call)
  %call3 = call %struct.op* @Perl_newSVREF(%struct.op* %call2)
  store %struct.op* %call3, %struct.op** %o2, align 8
  %2 = load %struct.op*, %struct.op** %o2, align 8
  %3 = load %struct.op*, %struct.op** %o.addr, align 8
  %call4 = call %struct.op* @Perl_prepend_elem(i32 141, %struct.op* %2, %struct.op* %3)
  %call5 = call %struct.op* @Perl_convert(i32 140, i32 0, %struct.op* %call4)
  store %struct.op* %call5, %struct.op** %o.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load %struct.op*, %struct.op** %o.addr, align 8
  ret %struct.op* %4
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newSVREF(%struct.op* %o) #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %o.addr = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %0, i32 0, i32 4
  %1 = load i16, i16* %op_type, align 2
  %conv = zext i16 %1 to i32
  %cmp = icmp eq i32 %conv, 12
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type2 = getelementptr inbounds %struct.op, %struct.op* %2, i32 0, i32 4
  store i16 9, i16* %op_type2, align 2
  %3 = load %struct.op* ()*, %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 9), align 8
  %4 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_ppaddr = getelementptr inbounds %struct.op, %struct.op* %4, i32 0, i32 2
  store %struct.op* ()* %3, %struct.op* ()** %op_ppaddr, align 8
  %5 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %5, %struct.op** %retval
  br label %return

if.else:                                          ; preds = %entry
  %6 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type3 = getelementptr inbounds %struct.op, %struct.op* %6, i32 0, i32 4
  %7 = load i16, i16* %op_type3, align 2
  %conv4 = zext i16 %7 to i32
  %cmp5 = icmp eq i32 %conv4, 348
  br i1 %cmp5, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.else
  %8 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %8, i32 0, i32 6
  %9 = load i8, i8* %op_flags, align 1
  %conv7 = zext i8 %9 to i32
  %and = and i32 %conv7, 64
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then.8

if.then.8:                                        ; preds = %land.lhs.true
  %10 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags9 = getelementptr inbounds %struct.op, %struct.op* %10, i32 0, i32 6
  %11 = load i8, i8* %op_flags9, align 1
  %conv10 = zext i8 %11 to i32
  %or = or i32 %conv10, 64
  %conv11 = trunc i32 %or to i8
  store i8 %conv11, i8* %op_flags9, align 1
  %12 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %12, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %land.lhs.true, %if.else
  br label %if.end.12

if.end.12:                                        ; preds = %if.end
  %13 = load %struct.op*, %struct.op** %o.addr, align 8
  %call = call %struct.op* @Perl_scalar(%struct.op* %13)
  %call13 = call %struct.op* @Perl_newUNOP(i32 15, i32 0, %struct.op* %call)
  store %struct.op* %call13, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.12, %if.then.8, %if.then
  %14 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %14
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newGVOP(i32 %type, i32 %flags, %struct.gv* %gv) #0 {
entry:
  %type.addr = alloca i32, align 4
  %flags.addr = alloca i32, align 4
  %gv.addr = alloca %struct.gv*, align 8
  store i32 %type, i32* %type.addr, align 4
  store i32 %flags, i32* %flags.addr, align 4
  store %struct.gv* %gv, %struct.gv** %gv.addr, align 8
  %0 = load i32, i32* %type.addr, align 4
  %1 = load i32, i32* %flags.addr, align 4
  %2 = load %struct.gv*, %struct.gv** %gv.addr, align 8
  %3 = bitcast %struct.gv* %2 to %struct.sv*
  store %struct.sv* %3, %struct.sv** @PL_Sv, align 8
  %4 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %tobool = icmp ne %struct.sv* %4, null
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %5 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_refcnt = getelementptr inbounds %struct.sv, %struct.sv* %5, i32 0, i32 1
  %6 = load i32, i32* %sv_refcnt, align 4
  %inc = add i32 %6, 1
  store i32 %inc, i32* %sv_refcnt, align 4
  %tobool1 = icmp ne i32 %inc, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %7 = phi i1 [ false, %entry ], [ %tobool1, %land.rhs ]
  %land.ext = zext i1 %7 to i32
  %8 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call = call %struct.op* @Perl_newSVOP(i32 %0, i32 %1, %struct.sv* %8)
  ret %struct.op* %call
}

declare %struct.gv* @Perl_gv_fetchpv(i8*, i32, i32) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_convert(i32 %type, i32 %flags, %struct.op* %o) #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %type.addr = alloca i32, align 4
  %flags.addr = alloca i32, align 4
  %o.addr = alloca %struct.op*, align 8
  store i32 %type, i32* %type.addr, align 4
  store i32 %flags, i32* %flags.addr, align 4
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %tobool = icmp ne %struct.op* %0, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 4
  %2 = load i16, i16* %op_type, align 2
  %conv = zext i16 %2 to i32
  %cmp = icmp ne i32 %conv, 141
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  %3 = load %struct.op*, %struct.op** %o.addr, align 8
  %call = call %struct.op* @Perl_newLISTOP(i32 141, i32 0, %struct.op* %3, %struct.op* null)
  store %struct.op* %call, %struct.op** %o.addr, align 8
  br label %if.end

if.else:                                          ; preds = %lor.lhs.false
  %4 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %4, i32 0, i32 6
  %5 = load i8, i8* %op_flags, align 1
  %conv2 = zext i8 %5 to i32
  %and = and i32 %conv2, -4
  %conv3 = trunc i32 %and to i8
  store i8 %conv3, i8* %op_flags, align 1
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %6 = load i32, i32* %type.addr, align 4
  %idxprom = sext i32 %6 to i64
  %arrayidx = getelementptr inbounds [0 x i32], [0 x i32]* @PL_opargs, i32 0, i64 %idxprom
  %7 = load i32, i32* %arrayidx, align 4
  %and4 = and i32 %7, 1
  %tobool5 = icmp ne i32 %and4, 0
  br i1 %tobool5, label %if.end.7, label %if.then.6

if.then.6:                                        ; preds = %if.end
  %8 = load %struct.op*, %struct.op** %o.addr, align 8
  %9 = bitcast %struct.op* %8 to %struct.listop*
  %op_first = getelementptr inbounds %struct.listop, %struct.listop* %9, i32 0, i32 8
  %10 = load %struct.op*, %struct.op** %op_first, align 8
  call void @Perl_op_null(%struct.op* %10)
  br label %if.end.7

if.end.7:                                         ; preds = %if.then.6, %if.end
  %11 = load i32, i32* %type.addr, align 4
  %conv8 = trunc i32 %11 to i16
  %12 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type9 = getelementptr inbounds %struct.op, %struct.op* %12, i32 0, i32 4
  store i16 %conv8, i16* %op_type9, align 2
  %13 = load i32, i32* %type.addr, align 4
  %idxprom10 = sext i32 %13 to i64
  %arrayidx11 = getelementptr inbounds [0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 %idxprom10
  %14 = load %struct.op* ()*, %struct.op* ()** %arrayidx11, align 8
  %15 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_ppaddr = getelementptr inbounds %struct.op, %struct.op* %15, i32 0, i32 2
  store %struct.op* ()* %14, %struct.op* ()** %op_ppaddr, align 8
  %16 = load i32, i32* %flags.addr, align 4
  %17 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags12 = getelementptr inbounds %struct.op, %struct.op* %17, i32 0, i32 6
  %18 = load i8, i8* %op_flags12, align 1
  %conv13 = zext i8 %18 to i32
  %or = or i32 %conv13, %16
  %conv14 = trunc i32 %or to i8
  store i8 %conv14, i8* %op_flags12, align 1
  %19 = load i8*, i8** @PL_op_mask, align 8
  %tobool15 = icmp ne i8* %19, null
  br i1 %tobool15, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %if.end.7
  %20 = load i32, i32* %type.addr, align 4
  %idxprom16 = sext i32 %20 to i64
  %21 = load i8*, i8** @PL_op_mask, align 8
  %arrayidx17 = getelementptr inbounds i8, i8* %21, i64 %idxprom16
  %22 = load i8, i8* %arrayidx17, align 1
  %conv18 = sext i8 %22 to i32
  %tobool19 = icmp ne i32 %conv18, 0
  br i1 %tobool19, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true
  %23 = load %struct.op*, %struct.op** %o.addr, align 8
  call void @Perl_op_free(%struct.op* %23)
  %24 = load i32, i32* %type.addr, align 4
  %idxprom20 = sext i32 %24 to i64
  %arrayidx21 = getelementptr inbounds [0 x i8*], [0 x i8*]* @PL_op_desc, i32 0, i64 %idxprom20
  %25 = load i8*, i8** %arrayidx21, align 8
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.33, i32 0, i32 0), i8* %25)
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %if.end.7
  %26 = load i32, i32* %type.addr, align 4
  %idxprom22 = sext i32 %26 to i64
  %arrayidx23 = getelementptr inbounds [0 x %struct.op* (%struct.op*)*], [0 x %struct.op* (%struct.op*)*]* @PL_check, i32 0, i64 %idxprom22
  %27 = load %struct.op* (%struct.op*)*, %struct.op* (%struct.op*)** %arrayidx23, align 8
  %28 = load %struct.op*, %struct.op** %o.addr, align 8
  %call24 = call %struct.op* %27(%struct.op* %28)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.op* [ null, %cond.true ], [ %call24, %cond.false ]
  store %struct.op* %cond, %struct.op** %o.addr, align 8
  %29 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type25 = getelementptr inbounds %struct.op, %struct.op* %29, i32 0, i32 4
  %30 = load i16, i16* %op_type25, align 2
  %conv26 = zext i16 %30 to i32
  %31 = load i32, i32* %type.addr, align 4
  %cmp27 = icmp ne i32 %conv26, %31
  br i1 %cmp27, label %if.then.29, label %if.end.30

if.then.29:                                       ; preds = %cond.end
  %32 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %32, %struct.op** %retval
  br label %return

if.end.30:                                        ; preds = %cond.end
  %33 = load %struct.op*, %struct.op** %o.addr, align 8
  %call31 = call %struct.op* @Perl_fold_constants(%struct.op* %33)
  store %struct.op* %call31, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.30, %if.then.29
  %34 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %34
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_fold_constants(%struct.op* %o) #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %o.addr = alloca %struct.op*, align 8
  %curop = alloca %struct.op*, align 8
  %type = alloca i32, align 4
  %sv = alloca %struct.sv*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %0, i32 0, i32 4
  %1 = load i16, i16* %op_type, align 2
  %conv = zext i16 %1 to i32
  store i32 %conv, i32* %type, align 4
  %2 = load i32, i32* %type, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [0 x i32], [0 x i32]* @PL_opargs, i32 0, i64 %idxprom
  %3 = load i32, i32* %arrayidx, align 4
  %and = and i32 %3, 4
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load %struct.op*, %struct.op** %o.addr, align 8
  %call = call %struct.op* @Perl_scalar(%struct.op* %4)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load i32, i32* %type, align 4
  %idxprom1 = sext i32 %5 to i64
  %arrayidx2 = getelementptr inbounds [0 x i32], [0 x i32]* @PL_opargs, i32 0, i64 %idxprom1
  %6 = load i32, i32* %arrayidx2, align 4
  %and3 = and i32 %6, 8
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %land.lhs.true, label %if.end.9

land.lhs.true:                                    ; preds = %if.end
  %7 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %7, i32 0, i32 3
  %8 = load i64, i64* %op_targ, align 8
  %tobool5 = icmp ne i64 %8, 0
  br i1 %tobool5, label %if.end.9, label %if.then.6

if.then.6:                                        ; preds = %land.lhs.true
  %9 = load i32, i32* %type, align 4
  %call7 = call i64 @Perl_pad_alloc(i32 %9, i32 512)
  %10 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_targ8 = getelementptr inbounds %struct.op, %struct.op* %10, i32 0, i32 3
  store i64 %call7, i64* %op_targ8, align 8
  br label %if.end.9

if.end.9:                                         ; preds = %if.then.6, %land.lhs.true, %if.end
  %11 = load i32, i32* %type, align 4
  %idxprom10 = sext i32 %11 to i64
  %arrayidx11 = getelementptr inbounds [0 x i32], [0 x i32]* @PL_opargs, i32 0, i64 %idxprom10
  %12 = load i32, i32* %arrayidx11, align 4
  %and12 = and i32 %12, 32
  %tobool13 = icmp ne i32 %and12, 0
  br i1 %tobool13, label %land.lhs.true.14, label %if.end.34

land.lhs.true.14:                                 ; preds = %if.end.9
  %13 = load i32, i32* @PL_hints, align 4
  %and15 = and i32 %13, 1
  %tobool16 = icmp ne i32 %and15, 0
  br i1 %tobool16, label %land.lhs.true.17, label %if.end.34

land.lhs.true.17:                                 ; preds = %land.lhs.true.14
  %14 = load i32, i32* %type, align 4
  %cmp = icmp eq i32 %14, 94
  br i1 %cmp, label %land.lhs.true.19, label %if.then.29

land.lhs.true.19:                                 ; preds = %land.lhs.true.17
  %15 = load %struct.op*, %struct.op** %o.addr, align 8
  %16 = bitcast %struct.op* %15 to %struct.unop*
  %op_first = getelementptr inbounds %struct.unop, %struct.unop* %16, i32 0, i32 8
  %17 = load %struct.op*, %struct.op** %op_first, align 8
  %op_type20 = getelementptr inbounds %struct.op, %struct.op* %17, i32 0, i32 4
  %18 = load i16, i16* %op_type20, align 2
  %conv21 = zext i16 %18 to i32
  %cmp22 = icmp eq i32 %conv21, 5
  br i1 %cmp22, label %land.lhs.true.24, label %if.then.29

land.lhs.true.24:                                 ; preds = %land.lhs.true.19
  %19 = load %struct.op*, %struct.op** %o.addr, align 8
  %20 = bitcast %struct.op* %19 to %struct.unop*
  %op_first25 = getelementptr inbounds %struct.unop, %struct.unop* %20, i32 0, i32 8
  %21 = load %struct.op*, %struct.op** %op_first25, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %21, i32 0, i32 7
  %22 = load i8, i8* %op_private, align 1
  %conv26 = zext i8 %22 to i32
  %and27 = and i32 %conv26, 64
  %tobool28 = icmp ne i32 %and27, 0
  br i1 %tobool28, label %if.end.34, label %if.then.29

if.then.29:                                       ; preds = %land.lhs.true.24, %land.lhs.true.19, %land.lhs.true.17
  %23 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type30 = getelementptr inbounds %struct.op, %struct.op* %23, i32 0, i32 4
  %24 = load i16, i16* %op_type30, align 2
  %inc = add i16 %24, 1
  store i16 %inc, i16* %op_type30, align 2
  %conv31 = zext i16 %inc to i32
  store i32 %conv31, i32* %type, align 4
  %idxprom32 = sext i32 %conv31 to i64
  %arrayidx33 = getelementptr inbounds [0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 %idxprom32
  %25 = load %struct.op* ()*, %struct.op* ()** %arrayidx33, align 8
  %26 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_ppaddr = getelementptr inbounds %struct.op, %struct.op* %26, i32 0, i32 2
  store %struct.op* ()* %25, %struct.op* ()** %op_ppaddr, align 8
  br label %if.end.34

if.end.34:                                        ; preds = %if.then.29, %land.lhs.true.24, %land.lhs.true.14, %if.end.9
  %27 = load i32, i32* %type, align 4
  %idxprom35 = sext i32 %27 to i64
  %arrayidx36 = getelementptr inbounds [0 x i32], [0 x i32]* @PL_opargs, i32 0, i64 %idxprom35
  %28 = load i32, i32* %arrayidx36, align 4
  %and37 = and i32 %28, 2
  %tobool38 = icmp ne i32 %and37, 0
  br i1 %tobool38, label %if.end.40, label %if.then.39

if.then.39:                                       ; preds = %if.end.34
  br label %nope

if.end.40:                                        ; preds = %if.end.34
  %29 = load i32, i32* %type, align 4
  switch i32 %29, label %sw.epilog [
    i32 94, label %sw.bb
    i32 115, label %sw.bb.46
    i32 120, label %sw.bb.46
    i32 121, label %sw.bb.46
    i32 122, label %sw.bb.46
    i32 123, label %sw.bb.46
    i32 84, label %sw.bb.46
    i32 85, label %sw.bb.46
    i32 86, label %sw.bb.46
    i32 87, label %sw.bb.46
    i32 90, label %sw.bb.46
  ]

sw.bb:                                            ; preds = %if.end.40
  %30 = load %struct.op*, %struct.op** %o.addr, align 8
  %31 = bitcast %struct.op* %30 to %struct.unop*
  %op_first41 = getelementptr inbounds %struct.unop, %struct.unop* %31, i32 0, i32 8
  %32 = load %struct.op*, %struct.op** %op_first41, align 8
  %op_private42 = getelementptr inbounds %struct.op, %struct.op* %32, i32 0, i32 7
  %33 = load i8, i8* %op_private42, align 1
  %conv43 = zext i8 %33 to i32
  %and44 = and i32 %conv43, -9
  %conv45 = trunc i32 %and44 to i8
  store i8 %conv45, i8* %op_private42, align 1
  br label %sw.epilog

sw.bb.46:                                         ; preds = %if.end.40, %if.end.40, %if.end.40, %if.end.40, %if.end.40, %if.end.40, %if.end.40, %if.end.40, %if.end.40, %if.end.40
  %34 = load i32, i32* @PL_hints, align 4
  %and47 = and i32 %34, 4
  %tobool48 = icmp ne i32 %and47, 0
  br i1 %tobool48, label %if.then.49, label %if.end.50

if.then.49:                                       ; preds = %sw.bb.46
  br label %nope

if.end.50:                                        ; preds = %sw.bb.46
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end.50, %if.end.40, %sw.bb
  %35 = load i32, i32* @PL_error_count, align 4
  %tobool51 = icmp ne i32 %35, 0
  br i1 %tobool51, label %if.then.52, label %if.end.53

if.then.52:                                       ; preds = %sw.epilog
  br label %nope

if.end.53:                                        ; preds = %sw.epilog
  %36 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %36, i32 0, i32 0
  %37 = load %struct.op*, %struct.op** %op_next, align 8
  %tobool54 = icmp ne %struct.op* %37, null
  br i1 %tobool54, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.53
  %38 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next55 = getelementptr inbounds %struct.op, %struct.op* %38, i32 0, i32 0
  %39 = load %struct.op*, %struct.op** %op_next55, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end.53
  %40 = load %struct.op*, %struct.op** %o.addr, align 8
  %call56 = call %struct.op* @Perl_linklist(%struct.op* %40)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.op* [ %39, %cond.true ], [ %call56, %cond.false ]
  store %struct.op* %cond, %struct.op** %curop, align 8
  br label %for.cond

for.cond:                                         ; preds = %cond.end.95, %cond.end
  %41 = load %struct.op*, %struct.op** %curop, align 8
  %42 = load %struct.op*, %struct.op** %o.addr, align 8
  %cmp57 = icmp ne %struct.op* %41, %42
  br i1 %cmp57, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %43 = load %struct.op*, %struct.op** %curop, align 8
  %op_type59 = getelementptr inbounds %struct.op, %struct.op* %43, i32 0, i32 4
  %44 = load i16, i16* %op_type59, align 2
  %conv60 = zext i16 %44 to i32
  %cmp61 = icmp ne i32 %conv60, 5
  br i1 %cmp61, label %land.lhs.true.67, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %45 = load %struct.op*, %struct.op** %curop, align 8
  %op_private63 = getelementptr inbounds %struct.op, %struct.op* %45, i32 0, i32 7
  %46 = load i8, i8* %op_private63, align 1
  %conv64 = zext i8 %46 to i32
  %and65 = and i32 %conv64, 64
  %tobool66 = icmp ne i32 %and65, 0
  br i1 %tobool66, label %land.lhs.true.67, label %if.end.88

land.lhs.true.67:                                 ; preds = %lor.lhs.false, %for.body
  %47 = load %struct.op*, %struct.op** %curop, align 8
  %op_type68 = getelementptr inbounds %struct.op, %struct.op* %47, i32 0, i32 4
  %48 = load i16, i16* %op_type68, align 2
  %conv69 = zext i16 %48 to i32
  %cmp70 = icmp ne i32 %conv69, 141
  br i1 %cmp70, label %land.lhs.true.72, label %if.end.88

land.lhs.true.72:                                 ; preds = %land.lhs.true.67
  %49 = load %struct.op*, %struct.op** %curop, align 8
  %op_type73 = getelementptr inbounds %struct.op, %struct.op* %49, i32 0, i32 4
  %50 = load i16, i16* %op_type73, align 2
  %conv74 = zext i16 %50 to i32
  %cmp75 = icmp ne i32 %conv74, 2
  br i1 %cmp75, label %land.lhs.true.77, label %if.end.88

land.lhs.true.77:                                 ; preds = %land.lhs.true.72
  %51 = load %struct.op*, %struct.op** %curop, align 8
  %op_type78 = getelementptr inbounds %struct.op, %struct.op* %51, i32 0, i32 4
  %52 = load i16, i16* %op_type78, align 2
  %conv79 = zext i16 %52 to i32
  %cmp80 = icmp ne i32 %conv79, 0
  br i1 %cmp80, label %land.lhs.true.82, label %if.end.88

land.lhs.true.82:                                 ; preds = %land.lhs.true.77
  %53 = load %struct.op*, %struct.op** %curop, align 8
  %op_type83 = getelementptr inbounds %struct.op, %struct.op* %53, i32 0, i32 4
  %54 = load i16, i16* %op_type83, align 2
  %conv84 = zext i16 %54 to i32
  %cmp85 = icmp ne i32 %conv84, 3
  br i1 %cmp85, label %if.then.87, label %if.end.88

if.then.87:                                       ; preds = %land.lhs.true.82
  br label %nope

if.end.88:                                        ; preds = %land.lhs.true.82, %land.lhs.true.77, %land.lhs.true.72, %land.lhs.true.67, %lor.lhs.false
  br label %for.inc

for.inc:                                          ; preds = %if.end.88
  %55 = load %struct.op*, %struct.op** %curop, align 8
  %op_next89 = getelementptr inbounds %struct.op, %struct.op* %55, i32 0, i32 0
  %56 = load %struct.op*, %struct.op** %op_next89, align 8
  %tobool90 = icmp ne %struct.op* %56, null
  br i1 %tobool90, label %cond.true.91, label %cond.false.93

cond.true.91:                                     ; preds = %for.inc
  %57 = load %struct.op*, %struct.op** %curop, align 8
  %op_next92 = getelementptr inbounds %struct.op, %struct.op* %57, i32 0, i32 0
  %58 = load %struct.op*, %struct.op** %op_next92, align 8
  br label %cond.end.95

cond.false.93:                                    ; preds = %for.inc
  %59 = load %struct.op*, %struct.op** %curop, align 8
  %call94 = call %struct.op* @Perl_linklist(%struct.op* %59)
  br label %cond.end.95

cond.end.95:                                      ; preds = %cond.false.93, %cond.true.91
  %cond96 = phi %struct.op* [ %58, %cond.true.91 ], [ %call94, %cond.false.93 ]
  store %struct.op* %cond96, %struct.op** %curop, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %60 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next97 = getelementptr inbounds %struct.op, %struct.op* %60, i32 0, i32 0
  %61 = load %struct.op*, %struct.op** %op_next97, align 8
  %tobool98 = icmp ne %struct.op* %61, null
  br i1 %tobool98, label %cond.true.99, label %cond.false.101

cond.true.99:                                     ; preds = %for.end
  %62 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next100 = getelementptr inbounds %struct.op, %struct.op* %62, i32 0, i32 0
  %63 = load %struct.op*, %struct.op** %op_next100, align 8
  br label %cond.end.103

cond.false.101:                                   ; preds = %for.end
  %64 = load %struct.op*, %struct.op** %o.addr, align 8
  %call102 = call %struct.op* @Perl_linklist(%struct.op* %64)
  br label %cond.end.103

cond.end.103:                                     ; preds = %cond.false.101, %cond.true.99
  %cond104 = phi %struct.op* [ %63, %cond.true.99 ], [ %call102, %cond.false.101 ]
  store %struct.op* %cond104, %struct.op** %curop, align 8
  %65 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next105 = getelementptr inbounds %struct.op, %struct.op* %65, i32 0, i32 0
  store %struct.op* null, %struct.op** %op_next105, align 8
  %66 = load %struct.op*, %struct.op** %curop, align 8
  store %struct.op* %66, %struct.op** @PL_op, align 8
  %67 = load i32 ()*, i32 ()** @PL_runops, align 8
  %call106 = call i32 %67()
  %68 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %68, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** @PL_stack_sp, align 8
  %69 = load %struct.sv*, %struct.sv** %68, align 8
  store %struct.sv* %69, %struct.sv** %sv, align 8
  %70 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_targ107 = getelementptr inbounds %struct.op, %struct.op* %70, i32 0, i32 3
  %71 = load i64, i64* %op_targ107, align 8
  %tobool108 = icmp ne i64 %71, 0
  br i1 %tobool108, label %land.lhs.true.109, label %if.else

land.lhs.true.109:                                ; preds = %cond.end.103
  %72 = load %struct.sv*, %struct.sv** %sv, align 8
  %73 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_targ110 = getelementptr inbounds %struct.op, %struct.op* %73, i32 0, i32 3
  %74 = load i64, i64* %op_targ110, align 8
  %75 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx111 = getelementptr inbounds %struct.sv*, %struct.sv** %75, i64 %74
  %76 = load %struct.sv*, %struct.sv** %arrayidx111, align 8
  %cmp112 = icmp eq %struct.sv* %72, %76
  br i1 %cmp112, label %if.then.114, label %if.else

if.then.114:                                      ; preds = %land.lhs.true.109
  %77 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_targ115 = getelementptr inbounds %struct.op, %struct.op* %77, i32 0, i32 3
  %78 = load i64, i64* %op_targ115, align 8
  call void @Perl_pad_swipe(i64 %78, i8 signext 0)
  br label %if.end.125

if.else:                                          ; preds = %land.lhs.true.109, %cond.end.103
  %79 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %79, i32 0, i32 2
  %80 = load i32, i32* %sv_flags, align 4
  %and116 = and i32 %80, 2048
  %tobool117 = icmp ne i32 %and116, 0
  br i1 %tobool117, label %if.then.118, label %if.end.124

if.then.118:                                      ; preds = %if.else
  %81 = load %struct.sv*, %struct.sv** %sv, align 8
  store %struct.sv* %81, %struct.sv** @PL_Sv, align 8
  %82 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %tobool119 = icmp ne %struct.sv* %82, null
  br i1 %tobool119, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then.118
  %83 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_refcnt = getelementptr inbounds %struct.sv, %struct.sv* %83, i32 0, i32 1
  %84 = load i32, i32* %sv_refcnt, align 4
  %inc120 = add i32 %84, 1
  store i32 %inc120, i32* %sv_refcnt, align 4
  %tobool121 = icmp ne i32 %inc120, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then.118
  %85 = phi i1 [ false, %if.then.118 ], [ %tobool121, %land.rhs ]
  %land.ext = zext i1 %85 to i32
  %86 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %87 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags122 = getelementptr inbounds %struct.sv, %struct.sv* %87, i32 0, i32 2
  %88 = load i32, i32* %sv_flags122, align 4
  %and123 = and i32 %88, -2049
  store i32 %and123, i32* %sv_flags122, align 4
  br label %if.end.124

if.end.124:                                       ; preds = %land.end, %if.else
  br label %if.end.125

if.end.125:                                       ; preds = %if.end.124, %if.then.114
  %89 = load %struct.op*, %struct.op** %o.addr, align 8
  call void @Perl_op_free(%struct.op* %89)
  %90 = load i32, i32* %type, align 4
  %cmp126 = icmp eq i32 %90, 14
  br i1 %cmp126, label %if.then.128, label %if.end.130

if.then.128:                                      ; preds = %if.end.125
  %91 = load %struct.sv*, %struct.sv** %sv, align 8
  %92 = bitcast %struct.sv* %91 to %struct.gv*
  %call129 = call %struct.op* @Perl_newGVOP(i32 7, i32 0, %struct.gv* %92)
  store %struct.op* %call129, %struct.op** %retval
  br label %return

if.end.130:                                       ; preds = %if.end.125
  %93 = load %struct.sv*, %struct.sv** %sv, align 8
  %call131 = call %struct.op* @Perl_newSVOP(i32 5, i32 0, %struct.sv* %93)
  store %struct.op* %call131, %struct.op** %retval
  br label %return

nope:                                             ; preds = %if.then.87, %if.then.52, %if.then.49, %if.then.39
  %94 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %94, %struct.op** %retval
  br label %return

return:                                           ; preds = %nope, %if.end.130, %if.then.128
  %95 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %95
}

declare void @Perl_pad_swipe(i64, i8 signext) #1

declare %struct.op* @Perl_pp_pushmark() #1

declare %struct.op* @Perl_pp_anonlist() #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newNULLLIST() #0 {
entry:
  %call = call %struct.op* @Perl_newOP(i32 1, i32 0)
  ret %struct.op* %call
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_force_list(%struct.op* %o) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %tobool = icmp ne %struct.op* %0, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 4
  %2 = load i16, i16* %op_type, align 2
  %conv = zext i16 %2 to i32
  %cmp = icmp ne i32 %conv, 141
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %3 = load %struct.op*, %struct.op** %o.addr, align 8
  %call = call %struct.op* @Perl_newLISTOP(i32 141, i32 0, %struct.op* %3, %struct.op* null)
  store %struct.op* %call, %struct.op** %o.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  %4 = load %struct.op*, %struct.op** %o.addr, align 8
  call void @Perl_op_null(%struct.op* %4)
  %5 = load %struct.op*, %struct.op** %o.addr, align 8
  ret %struct.op* %5
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pmtrans(%struct.op* %o, %struct.op* %expr, %struct.op* %repl) #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %o.addr = alloca %struct.op*, align 8
  %expr.addr = alloca %struct.op*, align 8
  %repl.addr = alloca %struct.op*, align 8
  %tstr = alloca %struct.sv*, align 8
  %rstr = alloca %struct.sv*, align 8
  %tlen = alloca i64, align 8
  %rlen = alloca i64, align 8
  %t = alloca i8*, align 8
  %r = alloca i8*, align 8
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %del = alloca i32, align 4
  %complement = alloca i32, align 4
  %squash = alloca i32, align 4
  %grows = alloca i32, align 4
  %tbl = alloca i16*, align 8
  %listsv = alloca %struct.sv*, align 8
  %transv = alloca %struct.sv*, align 8
  %tend = alloca i8*, align 8
  %rend = alloca i8*, align 8
  %ulen = alloca i64, align 8
  %tfirst = alloca i64, align 8
  %tlast = alloca i64, align 8
  %tdiff = alloca i64, align 8
  %rfirst = alloca i64, align 8
  %rlast = alloca i64, align 8
  %rdiff = alloca i64, align 8
  %diff = alloca i64, align 8
  %none = alloca i32, align 4
  %max = alloca i32, align 4
  %bits = alloca i32, align 4
  %havefinal = alloca i32, align 4
  %final = alloca i32, align 4
  %from_utf = alloca i32, align 4
  %to_utf = alloca i32, align 4
  %tsave = alloca i8*, align 8
  %rsave = alloca i8*, align 8
  %len = alloca i64, align 8
  %len58 = alloca i64, align 8
  %tmpbuf = alloca [14 x i8], align 1
  %cp = alloca i64*, align 8
  %nextmin = alloca i64, align 8
  %val = alloca i64, align 8
  %range_mark = alloca i8, align 1
  %range_mark140 = alloca i8, align 1
  store %struct.op* %o, %struct.op** %o.addr, align 8
  store %struct.op* %expr, %struct.op** %expr.addr, align 8
  store %struct.op* %repl, %struct.op** %repl.addr, align 8
  %0 = load %struct.op*, %struct.op** %expr.addr, align 8
  %1 = bitcast %struct.op* %0 to %struct.svop*
  %op_sv = getelementptr inbounds %struct.svop, %struct.svop* %1, i32 0, i32 8
  %2 = load %struct.sv*, %struct.sv** %op_sv, align 8
  store %struct.sv* %2, %struct.sv** %tstr, align 8
  %3 = load %struct.op*, %struct.op** %repl.addr, align 8
  %4 = bitcast %struct.op* %3 to %struct.svop*
  %op_sv1 = getelementptr inbounds %struct.svop, %struct.svop* %4, i32 0, i32 8
  %5 = load %struct.sv*, %struct.sv** %op_sv1, align 8
  store %struct.sv* %5, %struct.sv** %rstr, align 8
  %6 = load %struct.sv*, %struct.sv** %tstr, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %6, i32 0, i32 2
  %7 = load i32, i32* %sv_flags, align 4
  %and = and i32 %7, 262144
  %cmp = icmp eq i32 %and, 262144
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %8 = load %struct.sv*, %struct.sv** %tstr, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %8, i32 0, i32 0
  %9 = load i8*, i8** %sv_any, align 8
  %10 = bitcast i8* %9 to %struct.xpv*
  %xpv_cur = getelementptr inbounds %struct.xpv, %struct.xpv* %10, i32 0, i32 1
  %11 = load i64, i64* %xpv_cur, align 8
  store i64 %11, i64* %tlen, align 8
  %12 = load %struct.sv*, %struct.sv** %tstr, align 8
  %sv_any2 = getelementptr inbounds %struct.sv, %struct.sv* %12, i32 0, i32 0
  %13 = load i8*, i8** %sv_any2, align 8
  %14 = bitcast i8* %13 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %14, i32 0, i32 0
  %15 = load i8*, i8** %xpv_pv, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %16 = load %struct.sv*, %struct.sv** %tstr, align 8
  %call = call i8* @Perl_sv_2pv_flags(%struct.sv* %16, i64* %tlen, i32 2)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %15, %cond.true ], [ %call, %cond.false ]
  store i8* %cond, i8** %t, align 8
  %17 = load %struct.sv*, %struct.sv** %rstr, align 8
  %sv_flags3 = getelementptr inbounds %struct.sv, %struct.sv* %17, i32 0, i32 2
  %18 = load i32, i32* %sv_flags3, align 4
  %and4 = and i32 %18, 262144
  %cmp5 = icmp eq i32 %and4, 262144
  br i1 %cmp5, label %cond.true.6, label %cond.false.11

cond.true.6:                                      ; preds = %cond.end
  %19 = load %struct.sv*, %struct.sv** %rstr, align 8
  %sv_any7 = getelementptr inbounds %struct.sv, %struct.sv* %19, i32 0, i32 0
  %20 = load i8*, i8** %sv_any7, align 8
  %21 = bitcast i8* %20 to %struct.xpv*
  %xpv_cur8 = getelementptr inbounds %struct.xpv, %struct.xpv* %21, i32 0, i32 1
  %22 = load i64, i64* %xpv_cur8, align 8
  store i64 %22, i64* %rlen, align 8
  %23 = load %struct.sv*, %struct.sv** %rstr, align 8
  %sv_any9 = getelementptr inbounds %struct.sv, %struct.sv* %23, i32 0, i32 0
  %24 = load i8*, i8** %sv_any9, align 8
  %25 = bitcast i8* %24 to %struct.xpv*
  %xpv_pv10 = getelementptr inbounds %struct.xpv, %struct.xpv* %25, i32 0, i32 0
  %26 = load i8*, i8** %xpv_pv10, align 8
  br label %cond.end.13

cond.false.11:                                    ; preds = %cond.end
  %27 = load %struct.sv*, %struct.sv** %rstr, align 8
  %call12 = call i8* @Perl_sv_2pv_flags(%struct.sv* %27, i64* %rlen, i32 2)
  br label %cond.end.13

cond.end.13:                                      ; preds = %cond.false.11, %cond.true.6
  %cond14 = phi i8* [ %26, %cond.true.6 ], [ %call12, %cond.false.11 ]
  store i8* %cond14, i8** %r, align 8
  store i32 0, i32* %grows, align 4
  %28 = load i32, i32* @PL_hints, align 4
  %or = or i32 %28, 256
  store i32 %or, i32* @PL_hints, align 4
  %29 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %29, i32 0, i32 7
  %30 = load i8, i8* %op_private, align 1
  %conv = zext i8 %30 to i32
  %and15 = and i32 %conv, 32
  store i32 %and15, i32* %complement, align 4
  %31 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private16 = getelementptr inbounds %struct.op, %struct.op* %31, i32 0, i32 7
  %32 = load i8, i8* %op_private16, align 1
  %conv17 = zext i8 %32 to i32
  %and18 = and i32 %conv17, 16
  store i32 %and18, i32* %del, align 4
  %33 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private19 = getelementptr inbounds %struct.op, %struct.op* %33, i32 0, i32 7
  %34 = load i8, i8* %op_private19, align 1
  %conv20 = zext i8 %34 to i32
  %and21 = and i32 %conv20, 8
  store i32 %and21, i32* %squash, align 4
  %35 = load %struct.sv*, %struct.sv** %tstr, align 8
  %sv_flags22 = getelementptr inbounds %struct.sv, %struct.sv* %35, i32 0, i32 2
  %36 = load i32, i32* %sv_flags22, align 4
  %and23 = and i32 %36, 536870912
  %tobool = icmp ne i32 %and23, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end.13
  %37 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private24 = getelementptr inbounds %struct.op, %struct.op* %37, i32 0, i32 7
  %38 = load i8, i8* %op_private24, align 1
  %conv25 = zext i8 %38 to i32
  %or26 = or i32 %conv25, 1
  %conv27 = trunc i32 %or26 to i8
  store i8 %conv27, i8* %op_private24, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end.13
  %39 = load %struct.sv*, %struct.sv** %rstr, align 8
  %sv_flags28 = getelementptr inbounds %struct.sv, %struct.sv* %39, i32 0, i32 2
  %40 = load i32, i32* %sv_flags28, align 4
  %and29 = and i32 %40, 536870912
  %tobool30 = icmp ne i32 %and29, 0
  br i1 %tobool30, label %if.then.31, label %if.end.36

if.then.31:                                       ; preds = %if.end
  %41 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private32 = getelementptr inbounds %struct.op, %struct.op* %41, i32 0, i32 7
  %42 = load i8, i8* %op_private32, align 1
  %conv33 = zext i8 %42 to i32
  %or34 = or i32 %conv33, 2
  %conv35 = trunc i32 %or34 to i8
  store i8 %conv35, i8* %op_private32, align 1
  br label %if.end.36

if.end.36:                                        ; preds = %if.then.31, %if.end
  %43 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private37 = getelementptr inbounds %struct.op, %struct.op* %43, i32 0, i32 7
  %44 = load i8, i8* %op_private37, align 1
  %conv38 = zext i8 %44 to i32
  %and39 = and i32 %conv38, 3
  %tobool40 = icmp ne i32 %and39, 0
  br i1 %tobool40, label %if.then.41, label %if.end.425

if.then.41:                                       ; preds = %if.end.36
  %call42 = call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.34, i32 0, i32 0), i64 10)
  store %struct.sv* %call42, %struct.sv** %listsv, align 8
  store %struct.sv* null, %struct.sv** %transv, align 8
  %45 = load i8*, i8** %t, align 8
  %46 = load i64, i64* %tlen, align 8
  %add.ptr = getelementptr inbounds i8, i8* %45, i64 %46
  store i8* %add.ptr, i8** %tend, align 8
  %47 = load i8*, i8** %r, align 8
  %48 = load i64, i64* %rlen, align 8
  %add.ptr43 = getelementptr inbounds i8, i8* %47, i64 %48
  store i8* %add.ptr43, i8** %rend, align 8
  store i64 1, i64* %tfirst, align 8
  store i64 0, i64* %tlast, align 8
  store i64 1, i64* %rfirst, align 8
  store i64 0, i64* %rlast, align 8
  store i32 0, i32* %none, align 4
  store i32 0, i32* %max, align 4
  store i32 0, i32* %havefinal, align 4
  store i32 0, i32* %final, align 4
  %49 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private44 = getelementptr inbounds %struct.op, %struct.op* %49, i32 0, i32 7
  %50 = load i8, i8* %op_private44, align 1
  %conv45 = zext i8 %50 to i32
  %and46 = and i32 %conv45, 1
  store i32 %and46, i32* %from_utf, align 4
  %51 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private47 = getelementptr inbounds %struct.op, %struct.op* %51, i32 0, i32 7
  %52 = load i8, i8* %op_private47, align 1
  %conv48 = zext i8 %52 to i32
  %and49 = and i32 %conv48, 2
  store i32 %and49, i32* %to_utf, align 4
  store i8* null, i8** %tsave, align 8
  store i8* null, i8** %rsave, align 8
  %53 = load i32, i32* %from_utf, align 4
  %tobool50 = icmp ne i32 %53, 0
  br i1 %tobool50, label %if.end.54, label %if.then.51

if.then.51:                                       ; preds = %if.then.41
  %54 = load i64, i64* %tlen, align 8
  store i64 %54, i64* %len, align 8
  %55 = load i8*, i8** %t, align 8
  %call52 = call i8* @Perl_bytes_to_utf8(i8* %55, i64* %len)
  store i8* %call52, i8** %t, align 8
  store i8* %call52, i8** %tsave, align 8
  %56 = load i8*, i8** %t, align 8
  %57 = load i64, i64* %len, align 8
  %add.ptr53 = getelementptr inbounds i8, i8* %56, i64 %57
  store i8* %add.ptr53, i8** %tend, align 8
  br label %if.end.54

if.end.54:                                        ; preds = %if.then.51, %if.then.41
  %58 = load i32, i32* %to_utf, align 4
  %tobool55 = icmp ne i32 %58, 0
  br i1 %tobool55, label %if.end.61, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end.54
  %59 = load i64, i64* %rlen, align 8
  %tobool56 = icmp ne i64 %59, 0
  br i1 %tobool56, label %if.then.57, label %if.end.61

if.then.57:                                       ; preds = %land.lhs.true
  %60 = load i64, i64* %rlen, align 8
  store i64 %60, i64* %len58, align 8
  %61 = load i8*, i8** %r, align 8
  %call59 = call i8* @Perl_bytes_to_utf8(i8* %61, i64* %len58)
  store i8* %call59, i8** %r, align 8
  store i8* %call59, i8** %rsave, align 8
  %62 = load i8*, i8** %r, align 8
  %63 = load i64, i64* %len58, align 8
  %add.ptr60 = getelementptr inbounds i8, i8* %62, i64 %63
  store i8* %add.ptr60, i8** %rend, align 8
  br label %if.end.61

if.end.61:                                        ; preds = %if.then.57, %land.lhs.true, %if.end.54
  %64 = load i32, i32* %complement, align 4
  %tobool62 = icmp ne i32 %64, 0
  br i1 %tobool62, label %if.then.63, label %if.else.153

if.then.63:                                       ; preds = %if.end.61
  store i64 0, i64* %nextmin, align 8
  %65 = load i64, i64* %tlen, align 8
  %mul = mul i64 2, %65
  %mul64 = mul i64 %mul, 8
  %call65 = call i8* @Perl_safesysmalloc(i64 %mul64)
  %66 = bitcast i8* %call65 to i64*
  store i64* %66, i64** %cp, align 8
  store i32 0, i32* %i, align 4
  %call66 = call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.35, i32 0, i32 0), i64 0)
  store %struct.sv* %call66, %struct.sv** %transv, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end.94, %if.then.63
  %67 = load i8*, i8** %t, align 8
  %68 = load i8*, i8** %tend, align 8
  %cmp67 = icmp ult i8* %67, %68
  br i1 %cmp67, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %69 = load i8*, i8** %t, align 8
  %70 = load i8*, i8** %tend, align 8
  %71 = load i8*, i8** %t, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %70 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %71 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %call69 = call i64 @Perl_utf8n_to_uvuni(i8* %69, i64 %sub.ptr.sub, i64* %ulen, i32 0)
  %72 = load i32, i32* %i, align 4
  %mul70 = mul nsw i32 2, %72
  %idxprom = sext i32 %mul70 to i64
  %73 = load i64*, i64** %cp, align 8
  %arrayidx = getelementptr inbounds i64, i64* %73, i64 %idxprom
  store i64 %call69, i64* %arrayidx, align 8
  %74 = load i64, i64* %ulen, align 8
  %75 = load i8*, i8** %t, align 8
  %add.ptr71 = getelementptr inbounds i8, i8* %75, i64 %74
  store i8* %add.ptr71, i8** %t, align 8
  %76 = load i8*, i8** %t, align 8
  %77 = load i8*, i8** %tend, align 8
  %cmp72 = icmp ult i8* %76, %77
  br i1 %cmp72, label %land.lhs.true.74, label %if.else

land.lhs.true.74:                                 ; preds = %while.body
  %78 = load i8*, i8** %t, align 8
  %79 = load i8, i8* %78, align 1
  %conv75 = zext i8 %79 to i32
  %cmp76 = icmp eq i32 %conv75, 255
  br i1 %cmp76, label %if.then.78, label %if.else

if.then.78:                                       ; preds = %land.lhs.true.74
  %80 = load i8*, i8** %t, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %80, i32 1
  store i8* %incdec.ptr, i8** %t, align 8
  %81 = load i8*, i8** %t, align 8
  %82 = load i8*, i8** %tend, align 8
  %83 = load i8*, i8** %t, align 8
  %sub.ptr.lhs.cast79 = ptrtoint i8* %82 to i64
  %sub.ptr.rhs.cast80 = ptrtoint i8* %83 to i64
  %sub.ptr.sub81 = sub i64 %sub.ptr.lhs.cast79, %sub.ptr.rhs.cast80
  %call82 = call i64 @Perl_utf8n_to_uvuni(i8* %81, i64 %sub.ptr.sub81, i64* %ulen, i32 0)
  %84 = load i32, i32* %i, align 4
  %mul83 = mul nsw i32 2, %84
  %add = add nsw i32 %mul83, 1
  %idxprom84 = sext i32 %add to i64
  %85 = load i64*, i64** %cp, align 8
  %arrayidx85 = getelementptr inbounds i64, i64* %85, i64 %idxprom84
  store i64 %call82, i64* %arrayidx85, align 8
  %86 = load i64, i64* %ulen, align 8
  %87 = load i8*, i8** %t, align 8
  %add.ptr86 = getelementptr inbounds i8, i8* %87, i64 %86
  store i8* %add.ptr86, i8** %t, align 8
  br label %if.end.94

if.else:                                          ; preds = %land.lhs.true.74, %while.body
  %88 = load i32, i32* %i, align 4
  %mul87 = mul nsw i32 2, %88
  %idxprom88 = sext i32 %mul87 to i64
  %89 = load i64*, i64** %cp, align 8
  %arrayidx89 = getelementptr inbounds i64, i64* %89, i64 %idxprom88
  %90 = load i64, i64* %arrayidx89, align 8
  %91 = load i32, i32* %i, align 4
  %mul90 = mul nsw i32 2, %91
  %add91 = add nsw i32 %mul90, 1
  %idxprom92 = sext i32 %add91 to i64
  %92 = load i64*, i64** %cp, align 8
  %arrayidx93 = getelementptr inbounds i64, i64* %92, i64 %idxprom92
  store i64 %90, i64* %arrayidx93, align 8
  br label %if.end.94

if.end.94:                                        ; preds = %if.else, %if.then.78
  %93 = load i32, i32* %i, align 4
  %inc = add nsw i32 %93, 1
  store i32 %inc, i32* %i, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %94 = load i64*, i64** %cp, align 8
  %95 = bitcast i64* %94 to i8*
  %96 = load i32, i32* %i, align 4
  %conv95 = sext i32 %96 to i64
  call void @qsort(i8* %95, i64 %conv95, i64 16, i32 (i8*, i8*)* @uvcompare)
  store i32 0, i32* %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %while.end
  %97 = load i32, i32* %j, align 4
  %98 = load i32, i32* %i, align 4
  %cmp96 = icmp slt i32 %97, %98
  br i1 %cmp96, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %99 = load i32, i32* %j, align 4
  %mul98 = mul nsw i32 2, %99
  %idxprom99 = sext i32 %mul98 to i64
  %100 = load i64*, i64** %cp, align 8
  %arrayidx100 = getelementptr inbounds i64, i64* %100, i64 %idxprom99
  %101 = load i64, i64* %arrayidx100, align 8
  store i64 %101, i64* %val, align 8
  %102 = load i64, i64* %val, align 8
  %103 = load i64, i64* %nextmin, align 8
  %sub = sub i64 %102, %103
  store i64 %sub, i64* %diff, align 8
  %104 = load i64, i64* %diff, align 8
  %cmp101 = icmp sgt i64 %104, 0
  br i1 %cmp101, label %if.then.103, label %if.end.122

if.then.103:                                      ; preds = %for.body
  %arraydecay = getelementptr inbounds [14 x i8], [14 x i8]* %tmpbuf, i32 0, i32 0
  %105 = load i64, i64* %nextmin, align 8
  %call104 = call i8* @Perl_uvuni_to_utf8(i8* %arraydecay, i64 %105)
  store i8* %call104, i8** %t, align 8
  %106 = load %struct.sv*, %struct.sv** %transv, align 8
  %arraydecay105 = getelementptr inbounds [14 x i8], [14 x i8]* %tmpbuf, i32 0, i32 0
  %107 = load i8*, i8** %t, align 8
  %arraydecay106 = getelementptr inbounds [14 x i8], [14 x i8]* %tmpbuf, i32 0, i32 0
  %sub.ptr.lhs.cast107 = ptrtoint i8* %107 to i64
  %sub.ptr.rhs.cast108 = ptrtoint i8* %arraydecay106 to i64
  %sub.ptr.sub109 = sub i64 %sub.ptr.lhs.cast107, %sub.ptr.rhs.cast108
  call void @Perl_sv_catpvn_flags(%struct.sv* %106, i8* %arraydecay105, i64 %sub.ptr.sub109, i32 2)
  %108 = load i64, i64* %diff, align 8
  %cmp110 = icmp sgt i64 %108, 1
  br i1 %cmp110, label %if.then.112, label %if.end.121

if.then.112:                                      ; preds = %if.then.103
  store i8 -1, i8* %range_mark, align 1
  %arraydecay113 = getelementptr inbounds [14 x i8], [14 x i8]* %tmpbuf, i32 0, i32 0
  %109 = load i64, i64* %val, align 8
  %sub114 = sub i64 %109, 1
  %call115 = call i8* @Perl_uvuni_to_utf8(i8* %arraydecay113, i64 %sub114)
  store i8* %call115, i8** %t, align 8
  %110 = load %struct.sv*, %struct.sv** %transv, align 8
  call void @Perl_sv_catpvn_flags(%struct.sv* %110, i8* %range_mark, i64 1, i32 2)
  %111 = load %struct.sv*, %struct.sv** %transv, align 8
  %arraydecay116 = getelementptr inbounds [14 x i8], [14 x i8]* %tmpbuf, i32 0, i32 0
  %112 = load i8*, i8** %t, align 8
  %arraydecay117 = getelementptr inbounds [14 x i8], [14 x i8]* %tmpbuf, i32 0, i32 0
  %sub.ptr.lhs.cast118 = ptrtoint i8* %112 to i64
  %sub.ptr.rhs.cast119 = ptrtoint i8* %arraydecay117 to i64
  %sub.ptr.sub120 = sub i64 %sub.ptr.lhs.cast118, %sub.ptr.rhs.cast119
  call void @Perl_sv_catpvn_flags(%struct.sv* %111, i8* %arraydecay116, i64 %sub.ptr.sub120, i32 2)
  br label %if.end.121

if.end.121:                                       ; preds = %if.then.112, %if.then.103
  br label %if.end.122

if.end.122:                                       ; preds = %if.end.121, %for.body
  %113 = load i32, i32* %j, align 4
  %mul123 = mul nsw i32 2, %113
  %add124 = add nsw i32 %mul123, 1
  %idxprom125 = sext i32 %add124 to i64
  %114 = load i64*, i64** %cp, align 8
  %arrayidx126 = getelementptr inbounds i64, i64* %114, i64 %idxprom125
  %115 = load i64, i64* %arrayidx126, align 8
  store i64 %115, i64* %val, align 8
  %116 = load i64, i64* %val, align 8
  %117 = load i64, i64* %nextmin, align 8
  %cmp127 = icmp uge i64 %116, %117
  br i1 %cmp127, label %if.then.129, label %if.end.131

if.then.129:                                      ; preds = %if.end.122
  %118 = load i64, i64* %val, align 8
  %add130 = add i64 %118, 1
  store i64 %add130, i64* %nextmin, align 8
  br label %if.end.131

if.end.131:                                       ; preds = %if.then.129, %if.end.122
  br label %for.inc

for.inc:                                          ; preds = %if.end.131
  %119 = load i32, i32* %j, align 4
  %inc132 = add nsw i32 %119, 1
  store i32 %inc132, i32* %j, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %arraydecay133 = getelementptr inbounds [14 x i8], [14 x i8]* %tmpbuf, i32 0, i32 0
  %120 = load i64, i64* %nextmin, align 8
  %call134 = call i8* @Perl_uvuni_to_utf8(i8* %arraydecay133, i64 %120)
  store i8* %call134, i8** %t, align 8
  %121 = load %struct.sv*, %struct.sv** %transv, align 8
  %arraydecay135 = getelementptr inbounds [14 x i8], [14 x i8]* %tmpbuf, i32 0, i32 0
  %122 = load i8*, i8** %t, align 8
  %arraydecay136 = getelementptr inbounds [14 x i8], [14 x i8]* %tmpbuf, i32 0, i32 0
  %sub.ptr.lhs.cast137 = ptrtoint i8* %122 to i64
  %sub.ptr.rhs.cast138 = ptrtoint i8* %arraydecay136 to i64
  %sub.ptr.sub139 = sub i64 %sub.ptr.lhs.cast137, %sub.ptr.rhs.cast138
  call void @Perl_sv_catpvn_flags(%struct.sv* %121, i8* %arraydecay135, i64 %sub.ptr.sub139, i32 2)
  store i8 -1, i8* %range_mark140, align 1
  %123 = load %struct.sv*, %struct.sv** %transv, align 8
  call void @Perl_sv_catpvn_flags(%struct.sv* %123, i8* %range_mark140, i64 1, i32 2)
  %arraydecay141 = getelementptr inbounds [14 x i8], [14 x i8]* %tmpbuf, i32 0, i32 0
  %call142 = call i8* @Perl_uvuni_to_utf8_flags(i8* %arraydecay141, i64 2147483647, i64 8)
  store i8* %call142, i8** %t, align 8
  %124 = load %struct.sv*, %struct.sv** %transv, align 8
  %arraydecay143 = getelementptr inbounds [14 x i8], [14 x i8]* %tmpbuf, i32 0, i32 0
  %125 = load i8*, i8** %t, align 8
  %arraydecay144 = getelementptr inbounds [14 x i8], [14 x i8]* %tmpbuf, i32 0, i32 0
  %sub.ptr.lhs.cast145 = ptrtoint i8* %125 to i64
  %sub.ptr.rhs.cast146 = ptrtoint i8* %arraydecay144 to i64
  %sub.ptr.sub147 = sub i64 %sub.ptr.lhs.cast145, %sub.ptr.rhs.cast146
  call void @Perl_sv_catpvn_flags(%struct.sv* %124, i8* %arraydecay143, i64 %sub.ptr.sub147, i32 2)
  %126 = load %struct.sv*, %struct.sv** %transv, align 8
  %sv_any148 = getelementptr inbounds %struct.sv, %struct.sv* %126, i32 0, i32 0
  %127 = load i8*, i8** %sv_any148, align 8
  %128 = bitcast i8* %127 to %struct.xpv*
  %xpv_pv149 = getelementptr inbounds %struct.xpv, %struct.xpv* %128, i32 0, i32 0
  %129 = load i8*, i8** %xpv_pv149, align 8
  store i8* %129, i8** %t, align 8
  %130 = load %struct.sv*, %struct.sv** %transv, align 8
  %sv_any150 = getelementptr inbounds %struct.sv, %struct.sv* %130, i32 0, i32 0
  %131 = load i8*, i8** %sv_any150, align 8
  %132 = bitcast i8* %131 to %struct.xpv*
  %xpv_cur151 = getelementptr inbounds %struct.xpv, %struct.xpv* %132, i32 0, i32 1
  %133 = load i64, i64* %xpv_cur151, align 8
  store i64 %133, i64* %tlen, align 8
  %134 = load i8*, i8** %t, align 8
  %135 = load i64, i64* %tlen, align 8
  %add.ptr152 = getelementptr inbounds i8, i8* %134, i64 %135
  store i8* %add.ptr152, i8** %tend, align 8
  %136 = load i64*, i64** %cp, align 8
  %137 = bitcast i64* %136 to i8*
  call void @Perl_safesysfree(i8* %137)
  br label %if.end.159

if.else.153:                                      ; preds = %if.end.61
  %138 = load i64, i64* %rlen, align 8
  %tobool154 = icmp ne i64 %138, 0
  br i1 %tobool154, label %if.end.158, label %land.lhs.true.155

land.lhs.true.155:                                ; preds = %if.else.153
  %139 = load i32, i32* %del, align 4
  %tobool156 = icmp ne i32 %139, 0
  br i1 %tobool156, label %if.end.158, label %if.then.157

if.then.157:                                      ; preds = %land.lhs.true.155
  %140 = load i8*, i8** %t, align 8
  store i8* %140, i8** %r, align 8
  %141 = load i64, i64* %tlen, align 8
  store i64 %141, i64* %rlen, align 8
  %142 = load i8*, i8** %tend, align 8
  store i8* %142, i8** %rend, align 8
  br label %if.end.158

if.end.158:                                       ; preds = %if.then.157, %land.lhs.true.155, %if.else.153
  br label %if.end.159

if.end.159:                                       ; preds = %if.end.158, %for.end
  %143 = load i32, i32* %squash, align 4
  %tobool160 = icmp ne i32 %143, 0
  br i1 %tobool160, label %if.end.179, label %if.then.161

if.then.161:                                      ; preds = %if.end.159
  %144 = load i64, i64* %rlen, align 8
  %tobool162 = icmp ne i64 %144, 0
  br i1 %tobool162, label %lor.lhs.false, label %land.lhs.true.163

land.lhs.true.163:                                ; preds = %if.then.161
  %145 = load i32, i32* %del, align 4
  %tobool164 = icmp ne i32 %145, 0
  br i1 %tobool164, label %lor.lhs.false, label %if.then.173

lor.lhs.false:                                    ; preds = %land.lhs.true.163, %if.then.161
  %146 = load i8*, i8** %t, align 8
  %147 = load i8*, i8** %r, align 8
  %cmp165 = icmp eq i8* %146, %147
  br i1 %cmp165, label %if.then.173, label %lor.lhs.false.167

lor.lhs.false.167:                                ; preds = %lor.lhs.false
  %148 = load i64, i64* %tlen, align 8
  %149 = load i64, i64* %rlen, align 8
  %cmp168 = icmp eq i64 %148, %149
  br i1 %cmp168, label %land.lhs.true.170, label %if.end.178

land.lhs.true.170:                                ; preds = %lor.lhs.false.167
  %150 = load i8*, i8** %t, align 8
  %151 = load i8*, i8** %r, align 8
  %152 = load i64, i64* %tlen, align 8
  %call171 = call i32 @memcmp(i8* %150, i8* %151, i64 %152)
  %tobool172 = icmp ne i32 %call171, 0
  br i1 %tobool172, label %if.end.178, label %if.then.173

if.then.173:                                      ; preds = %land.lhs.true.170, %lor.lhs.false, %land.lhs.true.163
  %153 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private174 = getelementptr inbounds %struct.op, %struct.op* %153, i32 0, i32 7
  %154 = load i8, i8* %op_private174, align 1
  %conv175 = zext i8 %154 to i32
  %or176 = or i32 %conv175, 4
  %conv177 = trunc i32 %or176 to i8
  store i8 %conv177, i8* %op_private174, align 1
  br label %if.end.178

if.end.178:                                       ; preds = %if.then.173, %land.lhs.true.170, %lor.lhs.false.167
  br label %if.end.179

if.end.179:                                       ; preds = %if.end.178, %if.end.159
  br label %while.cond.180

while.cond.180:                                   ; preds = %if.end.376, %if.end.179
  %155 = load i8*, i8** %t, align 8
  %156 = load i8*, i8** %tend, align 8
  %cmp181 = icmp ult i8* %155, %156
  br i1 %cmp181, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %while.cond.180
  %157 = load i64, i64* %tfirst, align 8
  %158 = load i64, i64* %tlast, align 8
  %cmp183 = icmp ule i64 %157, %158
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %while.cond.180
  %159 = phi i1 [ true, %while.cond.180 ], [ %cmp183, %lor.rhs ]
  br i1 %159, label %while.body.185, label %while.end.379

while.body.185:                                   ; preds = %lor.end
  %160 = load i64, i64* %tfirst, align 8
  %161 = load i64, i64* %tlast, align 8
  %cmp186 = icmp ugt i64 %160, %161
  br i1 %cmp186, label %if.then.188, label %if.end.213

if.then.188:                                      ; preds = %while.body.185
  %162 = load i8*, i8** %t, align 8
  %163 = load i8*, i8** %tend, align 8
  %164 = load i8*, i8** %t, align 8
  %sub.ptr.lhs.cast189 = ptrtoint i8* %163 to i64
  %sub.ptr.rhs.cast190 = ptrtoint i8* %164 to i64
  %sub.ptr.sub191 = sub i64 %sub.ptr.lhs.cast189, %sub.ptr.rhs.cast190
  %call192 = call i64 @Perl_utf8n_to_uvuni(i8* %162, i64 %sub.ptr.sub191, i64* %ulen, i32 0)
  %conv193 = trunc i64 %call192 to i32
  %conv194 = sext i32 %conv193 to i64
  store i64 %conv194, i64* %tfirst, align 8
  %165 = load i64, i64* %ulen, align 8
  %166 = load i8*, i8** %t, align 8
  %add.ptr195 = getelementptr inbounds i8, i8* %166, i64 %165
  store i8* %add.ptr195, i8** %t, align 8
  %167 = load i8*, i8** %t, align 8
  %168 = load i8*, i8** %tend, align 8
  %cmp196 = icmp ult i8* %167, %168
  br i1 %cmp196, label %land.lhs.true.198, label %if.else.211

land.lhs.true.198:                                ; preds = %if.then.188
  %169 = load i8*, i8** %t, align 8
  %170 = load i8, i8* %169, align 1
  %conv199 = zext i8 %170 to i32
  %cmp200 = icmp eq i32 %conv199, 255
  br i1 %cmp200, label %if.then.202, label %if.else.211

if.then.202:                                      ; preds = %land.lhs.true.198
  %171 = load i8*, i8** %t, align 8
  %incdec.ptr203 = getelementptr inbounds i8, i8* %171, i32 1
  store i8* %incdec.ptr203, i8** %t, align 8
  %172 = load i8*, i8** %t, align 8
  %173 = load i8*, i8** %tend, align 8
  %174 = load i8*, i8** %t, align 8
  %sub.ptr.lhs.cast204 = ptrtoint i8* %173 to i64
  %sub.ptr.rhs.cast205 = ptrtoint i8* %174 to i64
  %sub.ptr.sub206 = sub i64 %sub.ptr.lhs.cast204, %sub.ptr.rhs.cast205
  %call207 = call i64 @Perl_utf8n_to_uvuni(i8* %172, i64 %sub.ptr.sub206, i64* %ulen, i32 0)
  %conv208 = trunc i64 %call207 to i32
  %conv209 = sext i32 %conv208 to i64
  store i64 %conv209, i64* %tlast, align 8
  %175 = load i64, i64* %ulen, align 8
  %176 = load i8*, i8** %t, align 8
  %add.ptr210 = getelementptr inbounds i8, i8* %176, i64 %175
  store i8* %add.ptr210, i8** %t, align 8
  br label %if.end.212

if.else.211:                                      ; preds = %land.lhs.true.198, %if.then.188
  %177 = load i64, i64* %tfirst, align 8
  store i64 %177, i64* %tlast, align 8
  br label %if.end.212

if.end.212:                                       ; preds = %if.else.211, %if.then.202
  br label %if.end.213

if.end.213:                                       ; preds = %if.end.212, %while.body.185
  %178 = load i64, i64* %rfirst, align 8
  %179 = load i64, i64* %rlast, align 8
  %cmp214 = icmp ugt i64 %178, %179
  br i1 %cmp214, label %if.then.216, label %if.end.251

if.then.216:                                      ; preds = %if.end.213
  %180 = load i8*, i8** %r, align 8
  %181 = load i8*, i8** %rend, align 8
  %cmp217 = icmp ult i8* %180, %181
  br i1 %cmp217, label %if.then.219, label %if.else.244

if.then.219:                                      ; preds = %if.then.216
  %182 = load i8*, i8** %r, align 8
  %183 = load i8*, i8** %rend, align 8
  %184 = load i8*, i8** %r, align 8
  %sub.ptr.lhs.cast220 = ptrtoint i8* %183 to i64
  %sub.ptr.rhs.cast221 = ptrtoint i8* %184 to i64
  %sub.ptr.sub222 = sub i64 %sub.ptr.lhs.cast220, %sub.ptr.rhs.cast221
  %call223 = call i64 @Perl_utf8n_to_uvuni(i8* %182, i64 %sub.ptr.sub222, i64* %ulen, i32 0)
  %conv224 = trunc i64 %call223 to i32
  %conv225 = sext i32 %conv224 to i64
  store i64 %conv225, i64* %rfirst, align 8
  %185 = load i64, i64* %ulen, align 8
  %186 = load i8*, i8** %r, align 8
  %add.ptr226 = getelementptr inbounds i8, i8* %186, i64 %185
  store i8* %add.ptr226, i8** %r, align 8
  %187 = load i8*, i8** %r, align 8
  %188 = load i8*, i8** %rend, align 8
  %cmp227 = icmp ult i8* %187, %188
  br i1 %cmp227, label %land.lhs.true.229, label %if.else.242

land.lhs.true.229:                                ; preds = %if.then.219
  %189 = load i8*, i8** %r, align 8
  %190 = load i8, i8* %189, align 1
  %conv230 = zext i8 %190 to i32
  %cmp231 = icmp eq i32 %conv230, 255
  br i1 %cmp231, label %if.then.233, label %if.else.242

if.then.233:                                      ; preds = %land.lhs.true.229
  %191 = load i8*, i8** %r, align 8
  %incdec.ptr234 = getelementptr inbounds i8, i8* %191, i32 1
  store i8* %incdec.ptr234, i8** %r, align 8
  %192 = load i8*, i8** %r, align 8
  %193 = load i8*, i8** %rend, align 8
  %194 = load i8*, i8** %r, align 8
  %sub.ptr.lhs.cast235 = ptrtoint i8* %193 to i64
  %sub.ptr.rhs.cast236 = ptrtoint i8* %194 to i64
  %sub.ptr.sub237 = sub i64 %sub.ptr.lhs.cast235, %sub.ptr.rhs.cast236
  %call238 = call i64 @Perl_utf8n_to_uvuni(i8* %192, i64 %sub.ptr.sub237, i64* %ulen, i32 0)
  %conv239 = trunc i64 %call238 to i32
  %conv240 = sext i32 %conv239 to i64
  store i64 %conv240, i64* %rlast, align 8
  %195 = load i64, i64* %ulen, align 8
  %196 = load i8*, i8** %r, align 8
  %add.ptr241 = getelementptr inbounds i8, i8* %196, i64 %195
  store i8* %add.ptr241, i8** %r, align 8
  br label %if.end.243

if.else.242:                                      ; preds = %land.lhs.true.229, %if.then.219
  %197 = load i64, i64* %rfirst, align 8
  store i64 %197, i64* %rlast, align 8
  br label %if.end.243

if.end.243:                                       ; preds = %if.else.242, %if.then.233
  br label %if.end.250

if.else.244:                                      ; preds = %if.then.216
  %198 = load i32, i32* %havefinal, align 4
  %inc245 = add nsw i32 %198, 1
  store i32 %inc245, i32* %havefinal, align 4
  %tobool246 = icmp ne i32 %198, 0
  br i1 %tobool246, label %if.end.249, label %if.then.247

if.then.247:                                      ; preds = %if.else.244
  %199 = load i64, i64* %rlast, align 8
  %conv248 = trunc i64 %199 to i32
  store i32 %conv248, i32* %final, align 4
  br label %if.end.249

if.end.249:                                       ; preds = %if.then.247, %if.else.244
  store i64 4294967295, i64* %rlast, align 8
  store i64 4294967295, i64* %rfirst, align 8
  br label %if.end.250

if.end.250:                                       ; preds = %if.end.249, %if.end.243
  br label %if.end.251

if.end.251:                                       ; preds = %if.end.250, %if.end.213
  %200 = load i64, i64* %tlast, align 8
  %201 = load i64, i64* %tfirst, align 8
  %sub252 = sub i64 %200, %201
  store i64 %sub252, i64* %tdiff, align 8
  %202 = load i64, i64* %rlast, align 8
  %203 = load i64, i64* %rfirst, align 8
  %sub253 = sub i64 %202, %203
  store i64 %sub253, i64* %rdiff, align 8
  %204 = load i64, i64* %tdiff, align 8
  %205 = load i64, i64* %rdiff, align 8
  %cmp254 = icmp sle i64 %204, %205
  br i1 %cmp254, label %if.then.256, label %if.else.257

if.then.256:                                      ; preds = %if.end.251
  %206 = load i64, i64* %tdiff, align 8
  store i64 %206, i64* %diff, align 8
  br label %if.end.258

if.else.257:                                      ; preds = %if.end.251
  %207 = load i64, i64* %rdiff, align 8
  store i64 %207, i64* %diff, align 8
  br label %if.end.258

if.end.258:                                       ; preds = %if.else.257, %if.then.256
  %208 = load i64, i64* %rfirst, align 8
  %cmp259 = icmp eq i64 %208, 4294967295
  br i1 %cmp259, label %if.then.261, label %if.else.267

if.then.261:                                      ; preds = %if.end.258
  %209 = load i64, i64* %tdiff, align 8
  store i64 %209, i64* %diff, align 8
  %210 = load i64, i64* %diff, align 8
  %cmp262 = icmp sgt i64 %210, 0
  br i1 %cmp262, label %if.then.264, label %if.else.265

if.then.264:                                      ; preds = %if.then.261
  %211 = load %struct.sv*, %struct.sv** %listsv, align 8
  %212 = load i64, i64* %tfirst, align 8
  %213 = load i64, i64* %tlast, align 8
  call void (%struct.sv*, i8*, ...) @Perl_sv_catpvf(%struct.sv* %211, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.36, i32 0, i32 0), i64 %212, i64 %213)
  br label %if.end.266

if.else.265:                                      ; preds = %if.then.261
  %214 = load %struct.sv*, %struct.sv** %listsv, align 8
  %215 = load i64, i64* %tfirst, align 8
  call void (%struct.sv*, i8*, ...) @Perl_sv_catpvf(%struct.sv* %214, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.37, i32 0, i32 0), i64 %215)
  br label %if.end.266

if.end.266:                                       ; preds = %if.else.265, %if.then.264
  br label %if.end.376

if.else.267:                                      ; preds = %if.end.258
  %216 = load i64, i64* %diff, align 8
  %cmp268 = icmp sgt i64 %216, 0
  br i1 %cmp268, label %if.then.270, label %if.else.272

if.then.270:                                      ; preds = %if.else.267
  %217 = load %struct.sv*, %struct.sv** %listsv, align 8
  %218 = load i64, i64* %tfirst, align 8
  %219 = load i64, i64* %tfirst, align 8
  %220 = load i64, i64* %diff, align 8
  %add271 = add i64 %219, %220
  %221 = load i64, i64* %rfirst, align 8
  call void (%struct.sv*, i8*, ...) @Perl_sv_catpvf(%struct.sv* %217, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.38, i32 0, i32 0), i64 %218, i64 %add271, i64 %221)
  br label %if.end.273

if.else.272:                                      ; preds = %if.else.267
  %222 = load %struct.sv*, %struct.sv** %listsv, align 8
  %223 = load i64, i64* %tfirst, align 8
  %224 = load i64, i64* %rfirst, align 8
  call void (%struct.sv*, i8*, ...) @Perl_sv_catpvf(%struct.sv* %222, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.39, i32 0, i32 0), i64 %223, i64 %224)
  br label %if.end.273

if.end.273:                                       ; preds = %if.else.272, %if.then.270
  %225 = load i64, i64* %rfirst, align 8
  %226 = load i64, i64* %diff, align 8
  %add274 = add i64 %225, %226
  %227 = load i32, i32* %max, align 4
  %conv275 = zext i32 %227 to i64
  %cmp276 = icmp ugt i64 %add274, %conv275
  br i1 %cmp276, label %if.then.278, label %if.end.281

if.then.278:                                      ; preds = %if.end.273
  %228 = load i64, i64* %rfirst, align 8
  %229 = load i64, i64* %diff, align 8
  %add279 = add i64 %228, %229
  %conv280 = trunc i64 %add279 to i32
  store i32 %conv280, i32* %max, align 4
  br label %if.end.281

if.end.281:                                       ; preds = %if.then.278, %if.end.273
  %230 = load i32, i32* %grows, align 4
  %tobool282 = icmp ne i32 %230, 0
  br i1 %tobool282, label %if.end.373, label %if.then.283

if.then.283:                                      ; preds = %if.end.281
  %231 = load i64, i64* %tfirst, align 8
  %232 = load i64, i64* %rfirst, align 8
  %cmp284 = icmp ult i64 %231, %232
  br i1 %cmp284, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then.283
  %233 = load i64, i64* %tfirst, align 8
  %cmp286 = icmp ult i64 %233, 128
  br i1 %cmp286, label %cond.true.288, label %cond.false.289

cond.true.288:                                    ; preds = %land.rhs
  br label %cond.end.323

cond.false.289:                                   ; preds = %land.rhs
  %234 = load i64, i64* %tfirst, align 8
  %cmp290 = icmp ult i64 %234, 2048
  br i1 %cmp290, label %cond.true.292, label %cond.false.293

cond.true.292:                                    ; preds = %cond.false.289
  br label %cond.end.321

cond.false.293:                                   ; preds = %cond.false.289
  %235 = load i64, i64* %tfirst, align 8
  %cmp294 = icmp ult i64 %235, 65536
  br i1 %cmp294, label %cond.true.296, label %cond.false.297

cond.true.296:                                    ; preds = %cond.false.293
  br label %cond.end.319

cond.false.297:                                   ; preds = %cond.false.293
  %236 = load i64, i64* %tfirst, align 8
  %cmp298 = icmp ult i64 %236, 2097152
  br i1 %cmp298, label %cond.true.300, label %cond.false.301

cond.true.300:                                    ; preds = %cond.false.297
  br label %cond.end.317

cond.false.301:                                   ; preds = %cond.false.297
  %237 = load i64, i64* %tfirst, align 8
  %cmp302 = icmp ult i64 %237, 67108864
  br i1 %cmp302, label %cond.true.304, label %cond.false.305

cond.true.304:                                    ; preds = %cond.false.301
  br label %cond.end.315

cond.false.305:                                   ; preds = %cond.false.301
  %238 = load i64, i64* %tfirst, align 8
  %cmp306 = icmp ult i64 %238, 2147483648
  br i1 %cmp306, label %cond.true.308, label %cond.false.309

cond.true.308:                                    ; preds = %cond.false.305
  br label %cond.end.313

cond.false.309:                                   ; preds = %cond.false.305
  %239 = load i64, i64* %tfirst, align 8
  %cmp310 = icmp ult i64 %239, 68719476736
  %cond312 = select i1 %cmp310, i32 7, i32 13
  br label %cond.end.313

cond.end.313:                                     ; preds = %cond.false.309, %cond.true.308
  %cond314 = phi i32 [ 6, %cond.true.308 ], [ %cond312, %cond.false.309 ]
  br label %cond.end.315

cond.end.315:                                     ; preds = %cond.end.313, %cond.true.304
  %cond316 = phi i32 [ 5, %cond.true.304 ], [ %cond314, %cond.end.313 ]
  br label %cond.end.317

cond.end.317:                                     ; preds = %cond.end.315, %cond.true.300
  %cond318 = phi i32 [ 4, %cond.true.300 ], [ %cond316, %cond.end.315 ]
  br label %cond.end.319

cond.end.319:                                     ; preds = %cond.end.317, %cond.true.296
  %cond320 = phi i32 [ 3, %cond.true.296 ], [ %cond318, %cond.end.317 ]
  br label %cond.end.321

cond.end.321:                                     ; preds = %cond.end.319, %cond.true.292
  %cond322 = phi i32 [ 2, %cond.true.292 ], [ %cond320, %cond.end.319 ]
  br label %cond.end.323

cond.end.323:                                     ; preds = %cond.end.321, %cond.true.288
  %cond324 = phi i32 [ 1, %cond.true.288 ], [ %cond322, %cond.end.321 ]
  %240 = load i64, i64* %rfirst, align 8
  %241 = load i64, i64* %diff, align 8
  %add325 = add i64 %240, %241
  %cmp326 = icmp ult i64 %add325, 128
  br i1 %cmp326, label %cond.true.328, label %cond.false.329

cond.true.328:                                    ; preds = %cond.end.323
  br label %cond.end.369

cond.false.329:                                   ; preds = %cond.end.323
  %242 = load i64, i64* %rfirst, align 8
  %243 = load i64, i64* %diff, align 8
  %add330 = add i64 %242, %243
  %cmp331 = icmp ult i64 %add330, 2048
  br i1 %cmp331, label %cond.true.333, label %cond.false.334

cond.true.333:                                    ; preds = %cond.false.329
  br label %cond.end.367

cond.false.334:                                   ; preds = %cond.false.329
  %244 = load i64, i64* %rfirst, align 8
  %245 = load i64, i64* %diff, align 8
  %add335 = add i64 %244, %245
  %cmp336 = icmp ult i64 %add335, 65536
  br i1 %cmp336, label %cond.true.338, label %cond.false.339

cond.true.338:                                    ; preds = %cond.false.334
  br label %cond.end.365

cond.false.339:                                   ; preds = %cond.false.334
  %246 = load i64, i64* %rfirst, align 8
  %247 = load i64, i64* %diff, align 8
  %add340 = add i64 %246, %247
  %cmp341 = icmp ult i64 %add340, 2097152
  br i1 %cmp341, label %cond.true.343, label %cond.false.344

cond.true.343:                                    ; preds = %cond.false.339
  br label %cond.end.363

cond.false.344:                                   ; preds = %cond.false.339
  %248 = load i64, i64* %rfirst, align 8
  %249 = load i64, i64* %diff, align 8
  %add345 = add i64 %248, %249
  %cmp346 = icmp ult i64 %add345, 67108864
  br i1 %cmp346, label %cond.true.348, label %cond.false.349

cond.true.348:                                    ; preds = %cond.false.344
  br label %cond.end.361

cond.false.349:                                   ; preds = %cond.false.344
  %250 = load i64, i64* %rfirst, align 8
  %251 = load i64, i64* %diff, align 8
  %add350 = add i64 %250, %251
  %cmp351 = icmp ult i64 %add350, 2147483648
  br i1 %cmp351, label %cond.true.353, label %cond.false.354

cond.true.353:                                    ; preds = %cond.false.349
  br label %cond.end.359

cond.false.354:                                   ; preds = %cond.false.349
  %252 = load i64, i64* %rfirst, align 8
  %253 = load i64, i64* %diff, align 8
  %add355 = add i64 %252, %253
  %cmp356 = icmp ult i64 %add355, 68719476736
  %cond358 = select i1 %cmp356, i32 7, i32 13
  br label %cond.end.359

cond.end.359:                                     ; preds = %cond.false.354, %cond.true.353
  %cond360 = phi i32 [ 6, %cond.true.353 ], [ %cond358, %cond.false.354 ]
  br label %cond.end.361

cond.end.361:                                     ; preds = %cond.end.359, %cond.true.348
  %cond362 = phi i32 [ 5, %cond.true.348 ], [ %cond360, %cond.end.359 ]
  br label %cond.end.363

cond.end.363:                                     ; preds = %cond.end.361, %cond.true.343
  %cond364 = phi i32 [ 4, %cond.true.343 ], [ %cond362, %cond.end.361 ]
  br label %cond.end.365

cond.end.365:                                     ; preds = %cond.end.363, %cond.true.338
  %cond366 = phi i32 [ 3, %cond.true.338 ], [ %cond364, %cond.end.363 ]
  br label %cond.end.367

cond.end.367:                                     ; preds = %cond.end.365, %cond.true.333
  %cond368 = phi i32 [ 2, %cond.true.333 ], [ %cond366, %cond.end.365 ]
  br label %cond.end.369

cond.end.369:                                     ; preds = %cond.end.367, %cond.true.328
  %cond370 = phi i32 [ 1, %cond.true.328 ], [ %cond368, %cond.end.367 ]
  %cmp371 = icmp slt i32 %cond324, %cond370
  br label %land.end

land.end:                                         ; preds = %cond.end.369, %if.then.283
  %254 = phi i1 [ false, %if.then.283 ], [ %cmp371, %cond.end.369 ]
  %land.ext = zext i1 %254 to i32
  store i32 %land.ext, i32* %grows, align 4
  br label %if.end.373

if.end.373:                                       ; preds = %land.end, %if.end.281
  %255 = load i64, i64* %diff, align 8
  %add374 = add nsw i64 %255, 1
  %256 = load i64, i64* %rfirst, align 8
  %add375 = add i64 %256, %add374
  store i64 %add375, i64* %rfirst, align 8
  br label %if.end.376

if.end.376:                                       ; preds = %if.end.373, %if.end.266
  %257 = load i64, i64* %diff, align 8
  %add377 = add nsw i64 %257, 1
  %258 = load i64, i64* %tfirst, align 8
  %add378 = add i64 %258, %add377
  store i64 %add378, i64* %tfirst, align 8
  br label %while.cond.180

while.end.379:                                    ; preds = %lor.end
  %259 = load i32, i32* %max, align 4
  %inc380 = add i32 %259, 1
  store i32 %inc380, i32* %max, align 4
  store i32 %inc380, i32* %none, align 4
  %260 = load i32, i32* %del, align 4
  %tobool381 = icmp ne i32 %260, 0
  br i1 %tobool381, label %if.then.382, label %if.end.384

if.then.382:                                      ; preds = %while.end.379
  %261 = load i32, i32* %max, align 4
  %inc383 = add i32 %261, 1
  store i32 %inc383, i32* %max, align 4
  store i32 %inc383, i32* %del, align 4
  br label %if.end.384

if.end.384:                                       ; preds = %if.then.382, %while.end.379
  %262 = load i32, i32* %max, align 4
  %cmp385 = icmp ugt i32 %262, 65535
  br i1 %cmp385, label %if.then.387, label %if.else.388

if.then.387:                                      ; preds = %if.end.384
  store i32 32, i32* %bits, align 4
  br label %if.end.394

if.else.388:                                      ; preds = %if.end.384
  %263 = load i32, i32* %max, align 4
  %cmp389 = icmp ugt i32 %263, 255
  br i1 %cmp389, label %if.then.391, label %if.else.392

if.then.391:                                      ; preds = %if.else.388
  store i32 16, i32* %bits, align 4
  br label %if.end.393

if.else.392:                                      ; preds = %if.else.388
  store i32 8, i32* %bits, align 4
  br label %if.end.393

if.end.393:                                       ; preds = %if.else.392, %if.then.391
  br label %if.end.394

if.end.394:                                       ; preds = %if.end.393, %if.then.387
  %264 = load %struct.op*, %struct.op** %o.addr, align 8
  %265 = bitcast %struct.op* %264 to %struct.pvop*
  %op_pv = getelementptr inbounds %struct.pvop, %struct.pvop* %265, i32 0, i32 8
  %266 = load i8*, i8** %op_pv, align 8
  call void @Perl_safesysfree(i8* %266)
  %267 = load %struct.sv*, %struct.sv** %listsv, align 8
  %268 = load i32, i32* %bits, align 4
  %269 = load i32, i32* %none, align 4
  %call395 = call %struct.sv* @Perl_swash_init(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.40, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.35, i32 0, i32 0), %struct.sv* %267, i32 %268, i32 %269)
  %270 = load %struct.op*, %struct.op** %o.addr, align 8
  %271 = bitcast %struct.op* %270 to %struct.svop*
  %op_sv396 = getelementptr inbounds %struct.svop, %struct.svop* %271, i32 0, i32 8
  store %struct.sv* %call395, %struct.sv** %op_sv396, align 8
  %272 = load %struct.sv*, %struct.sv** %listsv, align 8
  call void @Perl_sv_free(%struct.sv* %272)
  %273 = load %struct.sv*, %struct.sv** %transv, align 8
  %tobool397 = icmp ne %struct.sv* %273, null
  br i1 %tobool397, label %if.then.398, label %if.end.399

if.then.398:                                      ; preds = %if.end.394
  %274 = load %struct.sv*, %struct.sv** %transv, align 8
  call void @Perl_sv_free(%struct.sv* %274)
  br label %if.end.399

if.end.399:                                       ; preds = %if.then.398, %if.end.394
  %275 = load i32, i32* %del, align 4
  %tobool400 = icmp ne i32 %275, 0
  br i1 %tobool400, label %if.end.411, label %land.lhs.true.401

land.lhs.true.401:                                ; preds = %if.end.399
  %276 = load i32, i32* %havefinal, align 4
  %tobool402 = icmp ne i32 %276, 0
  br i1 %tobool402, label %land.lhs.true.403, label %if.end.411

land.lhs.true.403:                                ; preds = %land.lhs.true.401
  %277 = load i64, i64* %rlen, align 8
  %tobool404 = icmp ne i64 %277, 0
  br i1 %tobool404, label %if.then.405, label %if.end.411

if.then.405:                                      ; preds = %land.lhs.true.403
  %278 = load %struct.op*, %struct.op** %o.addr, align 8
  %279 = bitcast %struct.op* %278 to %struct.svop*
  %op_sv406 = getelementptr inbounds %struct.svop, %struct.svop* %279, i32 0, i32 8
  %280 = load %struct.sv*, %struct.sv** %op_sv406, align 8
  %sv_any407 = getelementptr inbounds %struct.sv, %struct.sv* %280, i32 0, i32 0
  %281 = load i8*, i8** %sv_any407, align 8
  %282 = bitcast i8* %281 to %struct.xrv*
  %xrv_rv = getelementptr inbounds %struct.xrv, %struct.xrv* %282, i32 0, i32 0
  %283 = load %struct.sv*, %struct.sv** %xrv_rv, align 8
  %284 = bitcast %struct.sv* %283 to %struct.hv*
  %285 = load i32, i32* %final, align 4
  %conv408 = zext i32 %285 to i64
  %call409 = call %struct.sv* @Perl_newSVuv(i64 %conv408)
  %call410 = call %struct.sv** @Perl_hv_store(%struct.hv* %284, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.41, i32 0, i32 0), i32 5, %struct.sv* %call409, i32 0)
  br label %if.end.411

if.end.411:                                       ; preds = %if.then.405, %land.lhs.true.403, %land.lhs.true.401, %if.end.399
  %286 = load i32, i32* %grows, align 4
  %tobool412 = icmp ne i32 %286, 0
  br i1 %tobool412, label %if.then.413, label %if.end.418

if.then.413:                                      ; preds = %if.end.411
  %287 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private414 = getelementptr inbounds %struct.op, %struct.op* %287, i32 0, i32 7
  %288 = load i8, i8* %op_private414, align 1
  %conv415 = zext i8 %288 to i32
  %or416 = or i32 %conv415, 64
  %conv417 = trunc i32 %or416 to i8
  store i8 %conv417, i8* %op_private414, align 1
  br label %if.end.418

if.end.418:                                       ; preds = %if.then.413, %if.end.411
  %289 = load i8*, i8** %tsave, align 8
  %tobool419 = icmp ne i8* %289, null
  br i1 %tobool419, label %if.then.420, label %if.end.421

if.then.420:                                      ; preds = %if.end.418
  %290 = load i8*, i8** %tsave, align 8
  call void @Perl_safesysfree(i8* %290)
  br label %if.end.421

if.end.421:                                       ; preds = %if.then.420, %if.end.418
  %291 = load i8*, i8** %rsave, align 8
  %tobool422 = icmp ne i8* %291, null
  br i1 %tobool422, label %if.then.423, label %if.end.424

if.then.423:                                      ; preds = %if.end.421
  %292 = load i8*, i8** %rsave, align 8
  call void @Perl_safesysfree(i8* %292)
  br label %if.end.424

if.end.424:                                       ; preds = %if.then.423, %if.end.421
  %293 = load %struct.op*, %struct.op** %expr.addr, align 8
  call void @Perl_op_free(%struct.op* %293)
  %294 = load %struct.op*, %struct.op** %repl.addr, align 8
  call void @Perl_op_free(%struct.op* %294)
  %295 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %295, %struct.op** %retval
  br label %return

if.end.425:                                       ; preds = %if.end.36
  %296 = load %struct.op*, %struct.op** %o.addr, align 8
  %297 = bitcast %struct.op* %296 to %struct.pvop*
  %op_pv426 = getelementptr inbounds %struct.pvop, %struct.pvop* %297, i32 0, i32 8
  %298 = load i8*, i8** %op_pv426, align 8
  %299 = bitcast i8* %298 to i16*
  store i16* %299, i16** %tbl, align 8
  %300 = load i32, i32* %complement, align 4
  %tobool427 = icmp ne i32 %300, 0
  br i1 %tobool427, label %if.then.428, label %if.else.543

if.then.428:                                      ; preds = %if.end.425
  %301 = load i16*, i16** %tbl, align 8
  %302 = bitcast i16* %301 to i8*
  call void @llvm.memset.p0i8.i64(i8* %302, i8 0, i64 512, i32 1, i1 false)
  store i32 0, i32* %i, align 4
  br label %for.cond.429

for.cond.429:                                     ; preds = %for.inc.438, %if.then.428
  %303 = load i32, i32* %i, align 4
  %304 = load i64, i64* %tlen, align 8
  %conv430 = trunc i64 %304 to i32
  %cmp431 = icmp slt i32 %303, %conv430
  br i1 %cmp431, label %for.body.433, label %for.end.440

for.body.433:                                     ; preds = %for.cond.429
  %305 = load i32, i32* %i, align 4
  %idxprom434 = sext i32 %305 to i64
  %306 = load i8*, i8** %t, align 8
  %arrayidx435 = getelementptr inbounds i8, i8* %306, i64 %idxprom434
  %307 = load i8, i8* %arrayidx435, align 1
  %idxprom436 = zext i8 %307 to i64
  %308 = load i16*, i16** %tbl, align 8
  %arrayidx437 = getelementptr inbounds i16, i16* %308, i64 %idxprom436
  store i16 -1, i16* %arrayidx437, align 2
  br label %for.inc.438

for.inc.438:                                      ; preds = %for.body.433
  %309 = load i32, i32* %i, align 4
  %inc439 = add nsw i32 %309, 1
  store i32 %inc439, i32* %i, align 4
  br label %for.cond.429

for.end.440:                                      ; preds = %for.cond.429
  store i32 0, i32* %i, align 4
  store i32 0, i32* %j, align 4
  br label %for.cond.441

for.cond.441:                                     ; preds = %for.inc.491, %for.end.440
  %310 = load i32, i32* %i, align 4
  %cmp442 = icmp slt i32 %310, 256
  br i1 %cmp442, label %for.body.444, label %for.end.493

for.body.444:                                     ; preds = %for.cond.441
  %311 = load i32, i32* %i, align 4
  %idxprom445 = sext i32 %311 to i64
  %312 = load i16*, i16** %tbl, align 8
  %arrayidx446 = getelementptr inbounds i16, i16* %312, i64 %idxprom445
  %313 = load i16, i16* %arrayidx446, align 2
  %tobool447 = icmp ne i16 %313, 0
  br i1 %tobool447, label %if.end.490, label %if.then.448

if.then.448:                                      ; preds = %for.body.444
  %314 = load i32, i32* %j, align 4
  %315 = load i64, i64* %rlen, align 8
  %conv449 = trunc i64 %315 to i32
  %cmp450 = icmp sge i32 %314, %conv449
  br i1 %cmp450, label %if.then.452, label %if.else.472

if.then.452:                                      ; preds = %if.then.448
  %316 = load i32, i32* %del, align 4
  %tobool453 = icmp ne i32 %316, 0
  br i1 %tobool453, label %if.then.454, label %if.else.457

if.then.454:                                      ; preds = %if.then.452
  %317 = load i32, i32* %i, align 4
  %idxprom455 = sext i32 %317 to i64
  %318 = load i16*, i16** %tbl, align 8
  %arrayidx456 = getelementptr inbounds i16, i16* %318, i64 %idxprom455
  store i16 -2, i16* %arrayidx456, align 2
  br label %if.end.471

if.else.457:                                      ; preds = %if.then.452
  %319 = load i64, i64* %rlen, align 8
  %tobool458 = icmp ne i64 %319, 0
  br i1 %tobool458, label %if.then.459, label %if.else.466

if.then.459:                                      ; preds = %if.else.457
  %320 = load i32, i32* %j, align 4
  %sub460 = sub nsw i32 %320, 1
  %idxprom461 = sext i32 %sub460 to i64
  %321 = load i8*, i8** %r, align 8
  %arrayidx462 = getelementptr inbounds i8, i8* %321, i64 %idxprom461
  %322 = load i8, i8* %arrayidx462, align 1
  %conv463 = zext i8 %322 to i16
  %323 = load i32, i32* %i, align 4
  %idxprom464 = sext i32 %323 to i64
  %324 = load i16*, i16** %tbl, align 8
  %arrayidx465 = getelementptr inbounds i16, i16* %324, i64 %idxprom464
  store i16 %conv463, i16* %arrayidx465, align 2
  br label %if.end.470

if.else.466:                                      ; preds = %if.else.457
  %325 = load i32, i32* %i, align 4
  %conv467 = trunc i32 %325 to i16
  %326 = load i32, i32* %i, align 4
  %idxprom468 = sext i32 %326 to i64
  %327 = load i16*, i16** %tbl, align 8
  %arrayidx469 = getelementptr inbounds i16, i16* %327, i64 %idxprom468
  store i16 %conv467, i16* %arrayidx469, align 2
  br label %if.end.470

if.end.470:                                       ; preds = %if.else.466, %if.then.459
  br label %if.end.471

if.end.471:                                       ; preds = %if.end.470, %if.then.454
  br label %if.end.489

if.else.472:                                      ; preds = %if.then.448
  %328 = load i32, i32* %i, align 4
  %cmp473 = icmp slt i32 %328, 128
  br i1 %cmp473, label %land.lhs.true.475, label %if.end.482

land.lhs.true.475:                                ; preds = %if.else.472
  %329 = load i32, i32* %j, align 4
  %idxprom476 = sext i32 %329 to i64
  %330 = load i8*, i8** %r, align 8
  %arrayidx477 = getelementptr inbounds i8, i8* %330, i64 %idxprom476
  %331 = load i8, i8* %arrayidx477, align 1
  %conv478 = zext i8 %331 to i32
  %cmp479 = icmp sge i32 %conv478, 128
  br i1 %cmp479, label %if.then.481, label %if.end.482

if.then.481:                                      ; preds = %land.lhs.true.475
  store i32 1, i32* %grows, align 4
  br label %if.end.482

if.end.482:                                       ; preds = %if.then.481, %land.lhs.true.475, %if.else.472
  %332 = load i32, i32* %j, align 4
  %inc483 = add nsw i32 %332, 1
  store i32 %inc483, i32* %j, align 4
  %idxprom484 = sext i32 %332 to i64
  %333 = load i8*, i8** %r, align 8
  %arrayidx485 = getelementptr inbounds i8, i8* %333, i64 %idxprom484
  %334 = load i8, i8* %arrayidx485, align 1
  %conv486 = zext i8 %334 to i16
  %335 = load i32, i32* %i, align 4
  %idxprom487 = sext i32 %335 to i64
  %336 = load i16*, i16** %tbl, align 8
  %arrayidx488 = getelementptr inbounds i16, i16* %336, i64 %idxprom487
  store i16 %conv486, i16* %arrayidx488, align 2
  br label %if.end.489

if.end.489:                                       ; preds = %if.end.482, %if.end.471
  br label %if.end.490

if.end.490:                                       ; preds = %if.end.489, %for.body.444
  br label %for.inc.491

for.inc.491:                                      ; preds = %if.end.490
  %337 = load i32, i32* %i, align 4
  %inc492 = add nsw i32 %337, 1
  store i32 %inc492, i32* %i, align 4
  br label %for.cond.441

for.end.493:                                      ; preds = %for.cond.441
  %338 = load i32, i32* %del, align 4
  %tobool494 = icmp ne i32 %338, 0
  br i1 %tobool494, label %if.end.542, label %if.then.495

if.then.495:                                      ; preds = %for.end.493
  %339 = load i64, i64* %rlen, align 8
  %tobool496 = icmp ne i64 %339, 0
  br i1 %tobool496, label %if.else.506, label %if.then.497

if.then.497:                                      ; preds = %if.then.495
  %340 = load i64, i64* %rlen, align 8
  %conv498 = trunc i64 %340 to i32
  store i32 %conv498, i32* %j, align 4
  %341 = load i32, i32* %squash, align 4
  %tobool499 = icmp ne i32 %341, 0
  br i1 %tobool499, label %if.end.505, label %if.then.500

if.then.500:                                      ; preds = %if.then.497
  %342 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private501 = getelementptr inbounds %struct.op, %struct.op* %342, i32 0, i32 7
  %343 = load i8, i8* %op_private501, align 1
  %conv502 = zext i8 %343 to i32
  %or503 = or i32 %conv502, 4
  %conv504 = trunc i32 %or503 to i8
  store i8 %conv504, i8* %op_private501, align 1
  br label %if.end.505

if.end.505:                                       ; preds = %if.then.500, %if.then.497
  br label %if.end.521

if.else.506:                                      ; preds = %if.then.495
  %344 = load i32, i32* %j, align 4
  %345 = load i64, i64* %rlen, align 8
  %conv507 = trunc i64 %345 to i32
  %cmp508 = icmp sge i32 %344, %conv507
  br i1 %cmp508, label %if.then.510, label %if.else.513

if.then.510:                                      ; preds = %if.else.506
  %346 = load i64, i64* %rlen, align 8
  %sub511 = sub i64 %346, 1
  %conv512 = trunc i64 %sub511 to i32
  store i32 %conv512, i32* %j, align 4
  br label %if.end.520

if.else.513:                                      ; preds = %if.else.506
  %347 = load i16*, i16** %tbl, align 8
  %348 = bitcast i16* %347 to i8*
  %349 = load i64, i64* %rlen, align 8
  %add514 = add i64 257, %349
  %350 = load i32, i32* %j, align 4
  %conv515 = sext i32 %350 to i64
  %sub516 = sub i64 %add514, %conv515
  %mul517 = mul i64 %sub516, 2
  %call518 = call i8* @Perl_safesysrealloc(i8* %348, i64 %mul517)
  %351 = bitcast i8* %call518 to i16*
  store i16* %351, i16** %tbl, align 8
  %352 = bitcast i16* %351 to i8*
  %353 = load %struct.op*, %struct.op** %o.addr, align 8
  %354 = bitcast %struct.op* %353 to %struct.pvop*
  %op_pv519 = getelementptr inbounds %struct.pvop, %struct.pvop* %354, i32 0, i32 8
  store i8* %352, i8** %op_pv519, align 8
  br label %if.end.520

if.end.520:                                       ; preds = %if.else.513, %if.then.510
  br label %if.end.521

if.end.521:                                       ; preds = %if.end.520, %if.end.505
  %355 = load i64, i64* %rlen, align 8
  %356 = load i32, i32* %j, align 4
  %conv522 = sext i32 %356 to i64
  %sub523 = sub i64 %355, %conv522
  %conv524 = trunc i64 %sub523 to i16
  %357 = load i16*, i16** %tbl, align 8
  %arrayidx525 = getelementptr inbounds i16, i16* %357, i64 256
  store i16 %conv524, i16* %arrayidx525, align 2
  store i32 0, i32* %i, align 4
  br label %for.cond.526

for.cond.526:                                     ; preds = %for.inc.539, %if.end.521
  %358 = load i32, i32* %i, align 4
  %359 = load i64, i64* %rlen, align 8
  %conv527 = trunc i64 %359 to i32
  %360 = load i32, i32* %j, align 4
  %sub528 = sub nsw i32 %conv527, %360
  %cmp529 = icmp slt i32 %358, %sub528
  br i1 %cmp529, label %for.body.531, label %for.end.541

for.body.531:                                     ; preds = %for.cond.526
  %361 = load i32, i32* %j, align 4
  %362 = load i32, i32* %i, align 4
  %add532 = add nsw i32 %361, %362
  %idxprom533 = sext i32 %add532 to i64
  %363 = load i8*, i8** %r, align 8
  %arrayidx534 = getelementptr inbounds i8, i8* %363, i64 %idxprom533
  %364 = load i8, i8* %arrayidx534, align 1
  %conv535 = zext i8 %364 to i16
  %365 = load i32, i32* %i, align 4
  %add536 = add nsw i32 257, %365
  %idxprom537 = sext i32 %add536 to i64
  %366 = load i16*, i16** %tbl, align 8
  %arrayidx538 = getelementptr inbounds i16, i16* %366, i64 %idxprom537
  store i16 %conv535, i16* %arrayidx538, align 2
  br label %for.inc.539

for.inc.539:                                      ; preds = %for.body.531
  %367 = load i32, i32* %i, align 4
  %inc540 = add nsw i32 %367, 1
  store i32 %inc540, i32* %i, align 4
  br label %for.cond.526

for.end.541:                                      ; preds = %for.cond.526
  br label %if.end.542

if.end.542:                                       ; preds = %for.end.541, %for.end.493
  br label %if.end.638

if.else.543:                                      ; preds = %if.end.425
  %368 = load i64, i64* %rlen, align 8
  %tobool544 = icmp ne i64 %368, 0
  br i1 %tobool544, label %if.else.555, label %land.lhs.true.545

land.lhs.true.545:                                ; preds = %if.else.543
  %369 = load i32, i32* %del, align 4
  %tobool546 = icmp ne i32 %369, 0
  br i1 %tobool546, label %if.else.555, label %if.then.547

if.then.547:                                      ; preds = %land.lhs.true.545
  %370 = load i8*, i8** %t, align 8
  store i8* %370, i8** %r, align 8
  %371 = load i64, i64* %tlen, align 8
  store i64 %371, i64* %rlen, align 8
  %372 = load i32, i32* %squash, align 4
  %tobool548 = icmp ne i32 %372, 0
  br i1 %tobool548, label %if.end.554, label %if.then.549

if.then.549:                                      ; preds = %if.then.547
  %373 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private550 = getelementptr inbounds %struct.op, %struct.op* %373, i32 0, i32 7
  %374 = load i8, i8* %op_private550, align 1
  %conv551 = zext i8 %374 to i32
  %or552 = or i32 %conv551, 4
  %conv553 = trunc i32 %or552 to i8
  store i8 %conv553, i8* %op_private550, align 1
  br label %if.end.554

if.end.554:                                       ; preds = %if.then.549, %if.then.547
  br label %if.end.569

if.else.555:                                      ; preds = %land.lhs.true.545, %if.else.543
  %375 = load i32, i32* %squash, align 4
  %tobool556 = icmp ne i32 %375, 0
  br i1 %tobool556, label %if.end.568, label %land.lhs.true.557

land.lhs.true.557:                                ; preds = %if.else.555
  %376 = load i64, i64* %rlen, align 8
  %377 = load i64, i64* %tlen, align 8
  %cmp558 = icmp eq i64 %376, %377
  br i1 %cmp558, label %land.lhs.true.560, label %if.end.568

land.lhs.true.560:                                ; preds = %land.lhs.true.557
  %378 = load i8*, i8** %t, align 8
  %379 = load i8*, i8** %r, align 8
  %380 = load i64, i64* %tlen, align 8
  %call561 = call i32 @memcmp(i8* %378, i8* %379, i64 %380)
  %tobool562 = icmp ne i32 %call561, 0
  br i1 %tobool562, label %if.end.568, label %if.then.563

if.then.563:                                      ; preds = %land.lhs.true.560
  %381 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private564 = getelementptr inbounds %struct.op, %struct.op* %381, i32 0, i32 7
  %382 = load i8, i8* %op_private564, align 1
  %conv565 = zext i8 %382 to i32
  %or566 = or i32 %conv565, 4
  %conv567 = trunc i32 %or566 to i8
  store i8 %conv567, i8* %op_private564, align 1
  br label %if.end.568

if.end.568:                                       ; preds = %if.then.563, %land.lhs.true.560, %land.lhs.true.557, %if.else.555
  br label %if.end.569

if.end.569:                                       ; preds = %if.end.568, %if.end.554
  store i32 0, i32* %i, align 4
  br label %for.cond.570

for.cond.570:                                     ; preds = %for.inc.576, %if.end.569
  %383 = load i32, i32* %i, align 4
  %cmp571 = icmp slt i32 %383, 256
  br i1 %cmp571, label %for.body.573, label %for.end.578

for.body.573:                                     ; preds = %for.cond.570
  %384 = load i32, i32* %i, align 4
  %idxprom574 = sext i32 %384 to i64
  %385 = load i16*, i16** %tbl, align 8
  %arrayidx575 = getelementptr inbounds i16, i16* %385, i64 %idxprom574
  store i16 -1, i16* %arrayidx575, align 2
  br label %for.inc.576

for.inc.576:                                      ; preds = %for.body.573
  %386 = load i32, i32* %i, align 4
  %inc577 = add nsw i32 %386, 1
  store i32 %inc577, i32* %i, align 4
  br label %for.cond.570

for.end.578:                                      ; preds = %for.cond.570
  store i32 0, i32* %i, align 4
  store i32 0, i32* %j, align 4
  br label %for.cond.579

for.cond.579:                                     ; preds = %for.inc.634, %for.end.578
  %387 = load i32, i32* %i, align 4
  %388 = load i64, i64* %tlen, align 8
  %conv580 = trunc i64 %388 to i32
  %cmp581 = icmp slt i32 %387, %conv580
  br i1 %cmp581, label %for.body.583, label %for.end.637

for.body.583:                                     ; preds = %for.cond.579
  %389 = load i32, i32* %j, align 4
  %390 = load i64, i64* %rlen, align 8
  %conv584 = trunc i64 %390 to i32
  %cmp585 = icmp sge i32 %389, %conv584
  br i1 %cmp585, label %if.then.587, label %if.end.604

if.then.587:                                      ; preds = %for.body.583
  %391 = load i32, i32* %del, align 4
  %tobool588 = icmp ne i32 %391, 0
  br i1 %tobool588, label %if.then.589, label %if.end.603

if.then.589:                                      ; preds = %if.then.587
  %392 = load i32, i32* %i, align 4
  %idxprom590 = sext i32 %392 to i64
  %393 = load i8*, i8** %t, align 8
  %arrayidx591 = getelementptr inbounds i8, i8* %393, i64 %idxprom590
  %394 = load i8, i8* %arrayidx591, align 1
  %idxprom592 = zext i8 %394 to i64
  %395 = load i16*, i16** %tbl, align 8
  %arrayidx593 = getelementptr inbounds i16, i16* %395, i64 %idxprom592
  %396 = load i16, i16* %arrayidx593, align 2
  %conv594 = sext i16 %396 to i32
  %cmp595 = icmp eq i32 %conv594, -1
  br i1 %cmp595, label %if.then.597, label %if.end.602

if.then.597:                                      ; preds = %if.then.589
  %397 = load i32, i32* %i, align 4
  %idxprom598 = sext i32 %397 to i64
  %398 = load i8*, i8** %t, align 8
  %arrayidx599 = getelementptr inbounds i8, i8* %398, i64 %idxprom598
  %399 = load i8, i8* %arrayidx599, align 1
  %idxprom600 = zext i8 %399 to i64
  %400 = load i16*, i16** %tbl, align 8
  %arrayidx601 = getelementptr inbounds i16, i16* %400, i64 %idxprom600
  store i16 -2, i16* %arrayidx601, align 2
  br label %if.end.602

if.end.602:                                       ; preds = %if.then.597, %if.then.589
  br label %for.inc.634

if.end.603:                                       ; preds = %if.then.587
  %401 = load i32, i32* %j, align 4
  %dec = add nsw i32 %401, -1
  store i32 %dec, i32* %j, align 4
  br label %if.end.604

if.end.604:                                       ; preds = %if.end.603, %for.body.583
  %402 = load i32, i32* %i, align 4
  %idxprom605 = sext i32 %402 to i64
  %403 = load i8*, i8** %t, align 8
  %arrayidx606 = getelementptr inbounds i8, i8* %403, i64 %idxprom605
  %404 = load i8, i8* %arrayidx606, align 1
  %idxprom607 = zext i8 %404 to i64
  %405 = load i16*, i16** %tbl, align 8
  %arrayidx608 = getelementptr inbounds i16, i16* %405, i64 %idxprom607
  %406 = load i16, i16* %arrayidx608, align 2
  %conv609 = sext i16 %406 to i32
  %cmp610 = icmp eq i32 %conv609, -1
  br i1 %cmp610, label %if.then.612, label %if.end.633

if.then.612:                                      ; preds = %if.end.604
  %407 = load i32, i32* %i, align 4
  %idxprom613 = sext i32 %407 to i64
  %408 = load i8*, i8** %t, align 8
  %arrayidx614 = getelementptr inbounds i8, i8* %408, i64 %idxprom613
  %409 = load i8, i8* %arrayidx614, align 1
  %conv615 = zext i8 %409 to i32
  %cmp616 = icmp slt i32 %conv615, 128
  br i1 %cmp616, label %land.lhs.true.618, label %if.end.625

land.lhs.true.618:                                ; preds = %if.then.612
  %410 = load i32, i32* %j, align 4
  %idxprom619 = sext i32 %410 to i64
  %411 = load i8*, i8** %r, align 8
  %arrayidx620 = getelementptr inbounds i8, i8* %411, i64 %idxprom619
  %412 = load i8, i8* %arrayidx620, align 1
  %conv621 = zext i8 %412 to i32
  %cmp622 = icmp sge i32 %conv621, 128
  br i1 %cmp622, label %if.then.624, label %if.end.625

if.then.624:                                      ; preds = %land.lhs.true.618
  store i32 1, i32* %grows, align 4
  br label %if.end.625

if.end.625:                                       ; preds = %if.then.624, %land.lhs.true.618, %if.then.612
  %413 = load i32, i32* %j, align 4
  %idxprom626 = sext i32 %413 to i64
  %414 = load i8*, i8** %r, align 8
  %arrayidx627 = getelementptr inbounds i8, i8* %414, i64 %idxprom626
  %415 = load i8, i8* %arrayidx627, align 1
  %conv628 = zext i8 %415 to i16
  %416 = load i32, i32* %i, align 4
  %idxprom629 = sext i32 %416 to i64
  %417 = load i8*, i8** %t, align 8
  %arrayidx630 = getelementptr inbounds i8, i8* %417, i64 %idxprom629
  %418 = load i8, i8* %arrayidx630, align 1
  %idxprom631 = zext i8 %418 to i64
  %419 = load i16*, i16** %tbl, align 8
  %arrayidx632 = getelementptr inbounds i16, i16* %419, i64 %idxprom631
  store i16 %conv628, i16* %arrayidx632, align 2
  br label %if.end.633

if.end.633:                                       ; preds = %if.end.625, %if.end.604
  br label %for.inc.634

for.inc.634:                                      ; preds = %if.end.633, %if.end.602
  %420 = load i32, i32* %i, align 4
  %inc635 = add nsw i32 %420, 1
  store i32 %inc635, i32* %i, align 4
  %421 = load i32, i32* %j, align 4
  %inc636 = add nsw i32 %421, 1
  store i32 %inc636, i32* %j, align 4
  br label %for.cond.579

for.end.637:                                      ; preds = %for.cond.579
  br label %if.end.638

if.end.638:                                       ; preds = %for.end.637, %if.end.542
  %422 = load i32, i32* %grows, align 4
  %tobool639 = icmp ne i32 %422, 0
  br i1 %tobool639, label %if.then.640, label %if.end.645

if.then.640:                                      ; preds = %if.end.638
  %423 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private641 = getelementptr inbounds %struct.op, %struct.op* %423, i32 0, i32 7
  %424 = load i8, i8* %op_private641, align 1
  %conv642 = zext i8 %424 to i32
  %or643 = or i32 %conv642, 64
  %conv644 = trunc i32 %or643 to i8
  store i8 %conv644, i8* %op_private641, align 1
  br label %if.end.645

if.end.645:                                       ; preds = %if.then.640, %if.end.638
  %425 = load %struct.op*, %struct.op** %expr.addr, align 8
  call void @Perl_op_free(%struct.op* %425)
  %426 = load %struct.op*, %struct.op** %repl.addr, align 8
  call void @Perl_op_free(%struct.op* %426)
  %427 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %427, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.645, %if.end.424
  %428 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %428
}

declare i8* @Perl_sv_2pv_flags(%struct.sv*, i64*, i32) #1

declare i8* @Perl_bytes_to_utf8(i8*, i64*) #1

declare i64 @Perl_utf8n_to_uvuni(i8*, i64, i64*, i32) #1

declare void @qsort(i8*, i64, i64, i32 (i8*, i8*)*) #1

; Function Attrs: nounwind uwtable
define internal i32 @uvcompare(i8* %a, i8* %b) #0 {
entry:
  %retval = alloca i32, align 4
  %a.addr = alloca i8*, align 8
  %b.addr = alloca i8*, align 8
  store i8* %a, i8** %a.addr, align 8
  store i8* %b, i8** %b.addr, align 8
  %0 = load i8*, i8** %a.addr, align 8
  %1 = bitcast i8* %0 to i64*
  %2 = load i64, i64* %1, align 8
  %3 = load i8*, i8** %b.addr, align 8
  %4 = bitcast i8* %3 to i64*
  %5 = load i64, i64* %4, align 8
  %cmp = icmp ult i64 %2, %5
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -1, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %6 = load i8*, i8** %a.addr, align 8
  %7 = bitcast i8* %6 to i64*
  %8 = load i64, i64* %7, align 8
  %9 = load i8*, i8** %b.addr, align 8
  %10 = bitcast i8* %9 to i64*
  %11 = load i64, i64* %10, align 8
  %cmp1 = icmp ugt i64 %8, %11
  br i1 %cmp1, label %if.then.2, label %if.end.3

if.then.2:                                        ; preds = %if.end
  store i32 1, i32* %retval
  br label %return

if.end.3:                                         ; preds = %if.end
  %12 = load i8*, i8** %a.addr, align 8
  %13 = bitcast i8* %12 to i64*
  %add.ptr = getelementptr inbounds i64, i64* %13, i64 1
  %14 = load i64, i64* %add.ptr, align 8
  %15 = load i8*, i8** %b.addr, align 8
  %16 = bitcast i8* %15 to i64*
  %17 = load i64, i64* %16, align 8
  %add = add i64 %17, 1
  %cmp4 = icmp ult i64 %14, %add
  br i1 %cmp4, label %if.then.5, label %if.end.6

if.then.5:                                        ; preds = %if.end.3
  store i32 -1, i32* %retval
  br label %return

if.end.6:                                         ; preds = %if.end.3
  %18 = load i8*, i8** %a.addr, align 8
  %19 = bitcast i8* %18 to i64*
  %add.ptr7 = getelementptr inbounds i64, i64* %19, i64 1
  %20 = load i64, i64* %add.ptr7, align 8
  %21 = load i8*, i8** %b.addr, align 8
  %22 = bitcast i8* %21 to i64*
  %23 = load i64, i64* %22, align 8
  %add8 = add i64 %23, 1
  %cmp9 = icmp ugt i64 %20, %add8
  br i1 %cmp9, label %if.then.10, label %if.end.11

if.then.10:                                       ; preds = %if.end.6
  store i32 1, i32* %retval
  br label %return

if.end.11:                                        ; preds = %if.end.6
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.end.11, %if.then.10, %if.then.5, %if.then.2, %if.then
  %24 = load i32, i32* %retval
  ret i32 %24
}

declare i8* @Perl_uvuni_to_utf8(i8*, i64) #1

declare void @Perl_sv_catpvn_flags(%struct.sv*, i8*, i64, i32) #1

declare i8* @Perl_uvuni_to_utf8_flags(i8*, i64, i64) #1

declare i32 @memcmp(i8*, i8*, i64) #1

declare void @Perl_sv_catpvf(%struct.sv*, i8*, ...) #1

declare %struct.sv* @Perl_swash_init(i8*, i8*, %struct.sv*, i32, i32) #1

declare %struct.sv** @Perl_hv_store(%struct.hv*, i8*, i32, %struct.sv*, i32) #1

declare %struct.sv* @Perl_newSVuv(i64) #1

declare i8* @Perl_safesysrealloc(i8*, i64) #1

declare void @Perl_sv_setpvn(%struct.sv*, i8*, i64) #1

declare i32 @strcmp(i8*, i8*) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newPADOP(i32 %type, i32 %flags, %struct.sv* %sv) #0 {
entry:
  %type.addr = alloca i32, align 4
  %flags.addr = alloca i32, align 4
  %sv.addr = alloca %struct.sv*, align 8
  %padop = alloca %struct.padop*, align 8
  store i32 %type, i32* %type.addr, align 4
  store i32 %flags, i32* %flags.addr, align 4
  store %struct.sv* %sv, %struct.sv** %sv.addr, align 8
  %call = call i8* @Perl_safesysmalloc(i64 48)
  %0 = bitcast i8* %call to %struct.padop*
  store %struct.padop* %0, %struct.padop** %padop, align 8
  %1 = load %struct.padop*, %struct.padop** %padop, align 8
  %2 = bitcast %struct.padop* %1 to i8*
  call void @llvm.memset.p0i8.i64(i8* %2, i8 0, i64 48, i32 1, i1 false)
  %3 = load i32, i32* %type.addr, align 4
  %conv = trunc i32 %3 to i16
  %4 = load %struct.padop*, %struct.padop** %padop, align 8
  %op_type = getelementptr inbounds %struct.padop, %struct.padop* %4, i32 0, i32 4
  store i16 %conv, i16* %op_type, align 2
  %5 = load i32, i32* %type.addr, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds [0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 %idxprom
  %6 = load %struct.op* ()*, %struct.op* ()** %arrayidx, align 8
  %7 = load %struct.padop*, %struct.padop** %padop, align 8
  %op_ppaddr = getelementptr inbounds %struct.padop, %struct.padop* %7, i32 0, i32 2
  store %struct.op* ()* %6, %struct.op* ()** %op_ppaddr, align 8
  %8 = load i32, i32* %type.addr, align 4
  %call1 = call i64 @Perl_pad_alloc(i32 %8, i32 512)
  %9 = load %struct.padop*, %struct.padop** %padop, align 8
  %op_padix = getelementptr inbounds %struct.padop, %struct.padop* %9, i32 0, i32 8
  store i64 %call1, i64* %op_padix, align 8
  %10 = load %struct.padop*, %struct.padop** %padop, align 8
  %op_padix2 = getelementptr inbounds %struct.padop, %struct.padop* %10, i32 0, i32 8
  %11 = load i64, i64* %op_padix2, align 8
  %12 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx3 = getelementptr inbounds %struct.sv*, %struct.sv** %12, i64 %11
  %13 = load %struct.sv*, %struct.sv** %arrayidx3, align 8
  call void @Perl_sv_free(%struct.sv* %13)
  %14 = load %struct.sv*, %struct.sv** %sv.addr, align 8
  %15 = load %struct.padop*, %struct.padop** %padop, align 8
  %op_padix4 = getelementptr inbounds %struct.padop, %struct.padop* %15, i32 0, i32 8
  %16 = load i64, i64* %op_padix4, align 8
  %17 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx5 = getelementptr inbounds %struct.sv*, %struct.sv** %17, i64 %16
  store %struct.sv* %14, %struct.sv** %arrayidx5, align 8
  %18 = load %struct.sv*, %struct.sv** %sv.addr, align 8
  %tobool = icmp ne %struct.sv* %18, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %19 = load %struct.sv*, %struct.sv** %sv.addr, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %19, i32 0, i32 2
  %20 = load i32, i32* %sv_flags, align 4
  %or = or i32 %20, 768
  store i32 %or, i32* %sv_flags, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %21 = load %struct.padop*, %struct.padop** %padop, align 8
  %22 = bitcast %struct.padop* %21 to %struct.op*
  %23 = load %struct.padop*, %struct.padop** %padop, align 8
  %op_next = getelementptr inbounds %struct.padop, %struct.padop* %23, i32 0, i32 0
  store %struct.op* %22, %struct.op** %op_next, align 8
  %24 = load i32, i32* %flags.addr, align 4
  %conv6 = trunc i32 %24 to i8
  %25 = load %struct.padop*, %struct.padop** %padop, align 8
  %op_flags = getelementptr inbounds %struct.padop, %struct.padop* %25, i32 0, i32 6
  store i8 %conv6, i8* %op_flags, align 1
  %26 = load i32, i32* %type.addr, align 4
  %idxprom7 = sext i32 %26 to i64
  %arrayidx8 = getelementptr inbounds [0 x i32], [0 x i32]* @PL_opargs, i32 0, i64 %idxprom7
  %27 = load i32, i32* %arrayidx8, align 4
  %and = and i32 %27, 4
  %tobool9 = icmp ne i32 %and, 0
  br i1 %tobool9, label %if.then.10, label %if.end.12

if.then.10:                                       ; preds = %if.end
  %28 = load %struct.padop*, %struct.padop** %padop, align 8
  %29 = bitcast %struct.padop* %28 to %struct.op*
  %call11 = call %struct.op* @Perl_scalar(%struct.op* %29)
  br label %if.end.12

if.end.12:                                        ; preds = %if.then.10, %if.end
  %30 = load i32, i32* %type.addr, align 4
  %idxprom13 = sext i32 %30 to i64
  %arrayidx14 = getelementptr inbounds [0 x i32], [0 x i32]* @PL_opargs, i32 0, i64 %idxprom13
  %31 = load i32, i32* %arrayidx14, align 4
  %and15 = and i32 %31, 8
  %tobool16 = icmp ne i32 %and15, 0
  br i1 %tobool16, label %if.then.17, label %if.end.19

if.then.17:                                       ; preds = %if.end.12
  %32 = load i32, i32* %type.addr, align 4
  %call18 = call i64 @Perl_pad_alloc(i32 %32, i32 512)
  %33 = load %struct.padop*, %struct.padop** %padop, align 8
  %op_targ = getelementptr inbounds %struct.padop, %struct.padop* %33, i32 0, i32 3
  store i64 %call18, i64* %op_targ, align 8
  br label %if.end.19

if.end.19:                                        ; preds = %if.then.17, %if.end.12
  %34 = load i8*, i8** @PL_op_mask, align 8
  %tobool20 = icmp ne i8* %34, null
  br i1 %tobool20, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %if.end.19
  %35 = load i32, i32* %type.addr, align 4
  %idxprom21 = sext i32 %35 to i64
  %36 = load i8*, i8** @PL_op_mask, align 8
  %arrayidx22 = getelementptr inbounds i8, i8* %36, i64 %idxprom21
  %37 = load i8, i8* %arrayidx22, align 1
  %conv23 = sext i8 %37 to i32
  %tobool24 = icmp ne i32 %conv23, 0
  br i1 %tobool24, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true
  %38 = load %struct.padop*, %struct.padop** %padop, align 8
  %39 = bitcast %struct.padop* %38 to %struct.op*
  call void @Perl_op_free(%struct.op* %39)
  %40 = load i32, i32* %type.addr, align 4
  %idxprom25 = sext i32 %40 to i64
  %arrayidx26 = getelementptr inbounds [0 x i8*], [0 x i8*]* @PL_op_desc, i32 0, i64 %idxprom25
  %41 = load i8*, i8** %arrayidx26, align 8
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.33, i32 0, i32 0), i8* %41)
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %if.end.19
  %42 = load i32, i32* %type.addr, align 4
  %idxprom27 = sext i32 %42 to i64
  %arrayidx28 = getelementptr inbounds [0 x %struct.op* (%struct.op*)*], [0 x %struct.op* (%struct.op*)*]* @PL_check, i32 0, i64 %idxprom27
  %43 = load %struct.op* (%struct.op*)*, %struct.op* (%struct.op*)** %arrayidx28, align 8
  %44 = load %struct.padop*, %struct.padop** %padop, align 8
  %45 = bitcast %struct.padop* %44 to %struct.op*
  %call29 = call %struct.op* %43(%struct.op* %45)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.op* [ null, %cond.true ], [ %call29, %cond.false ]
  ret %struct.op* %cond
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newPVOP(i32 %type, i32 %flags, i8* %pv) #0 {
entry:
  %type.addr = alloca i32, align 4
  %flags.addr = alloca i32, align 4
  %pv.addr = alloca i8*, align 8
  %pvop = alloca %struct.pvop*, align 8
  store i32 %type, i32* %type.addr, align 4
  store i32 %flags, i32* %flags.addr, align 4
  store i8* %pv, i8** %pv.addr, align 8
  %call = call i8* @Perl_safesysmalloc(i64 48)
  %0 = bitcast i8* %call to %struct.pvop*
  store %struct.pvop* %0, %struct.pvop** %pvop, align 8
  %1 = load %struct.pvop*, %struct.pvop** %pvop, align 8
  %2 = bitcast %struct.pvop* %1 to i8*
  call void @llvm.memset.p0i8.i64(i8* %2, i8 0, i64 48, i32 1, i1 false)
  %3 = load i32, i32* %type.addr, align 4
  %conv = trunc i32 %3 to i16
  %4 = load %struct.pvop*, %struct.pvop** %pvop, align 8
  %op_type = getelementptr inbounds %struct.pvop, %struct.pvop* %4, i32 0, i32 4
  store i16 %conv, i16* %op_type, align 2
  %5 = load i32, i32* %type.addr, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds [0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 %idxprom
  %6 = load %struct.op* ()*, %struct.op* ()** %arrayidx, align 8
  %7 = load %struct.pvop*, %struct.pvop** %pvop, align 8
  %op_ppaddr = getelementptr inbounds %struct.pvop, %struct.pvop* %7, i32 0, i32 2
  store %struct.op* ()* %6, %struct.op* ()** %op_ppaddr, align 8
  %8 = load i8*, i8** %pv.addr, align 8
  %9 = load %struct.pvop*, %struct.pvop** %pvop, align 8
  %op_pv = getelementptr inbounds %struct.pvop, %struct.pvop* %9, i32 0, i32 8
  store i8* %8, i8** %op_pv, align 8
  %10 = load %struct.pvop*, %struct.pvop** %pvop, align 8
  %11 = bitcast %struct.pvop* %10 to %struct.op*
  %12 = load %struct.pvop*, %struct.pvop** %pvop, align 8
  %op_next = getelementptr inbounds %struct.pvop, %struct.pvop* %12, i32 0, i32 0
  store %struct.op* %11, %struct.op** %op_next, align 8
  %13 = load i32, i32* %flags.addr, align 4
  %conv1 = trunc i32 %13 to i8
  %14 = load %struct.pvop*, %struct.pvop** %pvop, align 8
  %op_flags = getelementptr inbounds %struct.pvop, %struct.pvop* %14, i32 0, i32 6
  store i8 %conv1, i8* %op_flags, align 1
  %15 = load i32, i32* %type.addr, align 4
  %idxprom2 = sext i32 %15 to i64
  %arrayidx3 = getelementptr inbounds [0 x i32], [0 x i32]* @PL_opargs, i32 0, i64 %idxprom2
  %16 = load i32, i32* %arrayidx3, align 4
  %and = and i32 %16, 4
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %17 = load %struct.pvop*, %struct.pvop** %pvop, align 8
  %18 = bitcast %struct.pvop* %17 to %struct.op*
  %call4 = call %struct.op* @Perl_scalar(%struct.op* %18)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %19 = load i32, i32* %type.addr, align 4
  %idxprom5 = sext i32 %19 to i64
  %arrayidx6 = getelementptr inbounds [0 x i32], [0 x i32]* @PL_opargs, i32 0, i64 %idxprom5
  %20 = load i32, i32* %arrayidx6, align 4
  %and7 = and i32 %20, 8
  %tobool8 = icmp ne i32 %and7, 0
  br i1 %tobool8, label %if.then.9, label %if.end.11

if.then.9:                                        ; preds = %if.end
  %21 = load i32, i32* %type.addr, align 4
  %call10 = call i64 @Perl_pad_alloc(i32 %21, i32 512)
  %22 = load %struct.pvop*, %struct.pvop** %pvop, align 8
  %op_targ = getelementptr inbounds %struct.pvop, %struct.pvop* %22, i32 0, i32 3
  store i64 %call10, i64* %op_targ, align 8
  br label %if.end.11

if.end.11:                                        ; preds = %if.then.9, %if.end
  %23 = load i8*, i8** @PL_op_mask, align 8
  %tobool12 = icmp ne i8* %23, null
  br i1 %tobool12, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %if.end.11
  %24 = load i32, i32* %type.addr, align 4
  %idxprom13 = sext i32 %24 to i64
  %25 = load i8*, i8** @PL_op_mask, align 8
  %arrayidx14 = getelementptr inbounds i8, i8* %25, i64 %idxprom13
  %26 = load i8, i8* %arrayidx14, align 1
  %conv15 = sext i8 %26 to i32
  %tobool16 = icmp ne i32 %conv15, 0
  br i1 %tobool16, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true
  %27 = load %struct.pvop*, %struct.pvop** %pvop, align 8
  %28 = bitcast %struct.pvop* %27 to %struct.op*
  call void @Perl_op_free(%struct.op* %28)
  %29 = load i32, i32* %type.addr, align 4
  %idxprom17 = sext i32 %29 to i64
  %arrayidx18 = getelementptr inbounds [0 x i8*], [0 x i8*]* @PL_op_desc, i32 0, i64 %idxprom17
  %30 = load i8*, i8** %arrayidx18, align 8
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.33, i32 0, i32 0), i8* %30)
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %if.end.11
  %31 = load i32, i32* %type.addr, align 4
  %idxprom19 = sext i32 %31 to i64
  %arrayidx20 = getelementptr inbounds [0 x %struct.op* (%struct.op*)*], [0 x %struct.op* (%struct.op*)*]* @PL_check, i32 0, i64 %idxprom19
  %32 = load %struct.op* (%struct.op*)*, %struct.op* (%struct.op*)** %arrayidx20, align 8
  %33 = load %struct.pvop*, %struct.pvop** %pvop, align 8
  %34 = bitcast %struct.pvop* %33 to %struct.op*
  %call21 = call %struct.op* %32(%struct.op* %34)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.op* [ null, %cond.true ], [ %call21, %cond.false ]
  ret %struct.op* %cond
}

; Function Attrs: nounwind uwtable
define void @Perl_package(%struct.op* %o) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  %sv = alloca %struct.sv*, align 8
  %len = alloca i64, align 8
  %name = alloca i8*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  call void @Perl_save_hptr(%struct.hv** @PL_curstash)
  %0 = load %struct.sv*, %struct.sv** @PL_curstname, align 8
  call void @Perl_save_item(%struct.sv* %0)
  %1 = load %struct.op*, %struct.op** %o.addr, align 8
  %tobool = icmp ne %struct.op* %1, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load %struct.op*, %struct.op** %o.addr, align 8
  %3 = bitcast %struct.op* %2 to %struct.svop*
  %op_sv = getelementptr inbounds %struct.svop, %struct.svop* %3, i32 0, i32 8
  %4 = load %struct.sv*, %struct.sv** %op_sv, align 8
  store %struct.sv* %4, %struct.sv** %sv, align 8
  %5 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %5, i32 0, i32 2
  %6 = load i32, i32* %sv_flags, align 4
  %and = and i32 %6, 262144
  %cmp = icmp eq i32 %and, 262144
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  %7 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %7, i32 0, i32 0
  %8 = load i8*, i8** %sv_any, align 8
  %9 = bitcast i8* %8 to %struct.xpv*
  %xpv_cur = getelementptr inbounds %struct.xpv, %struct.xpv* %9, i32 0, i32 1
  %10 = load i64, i64* %xpv_cur, align 8
  store i64 %10, i64* %len, align 8
  %11 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any1 = getelementptr inbounds %struct.sv, %struct.sv* %11, i32 0, i32 0
  %12 = load i8*, i8** %sv_any1, align 8
  %13 = bitcast i8* %12 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %13, i32 0, i32 0
  %14 = load i8*, i8** %xpv_pv, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then
  %15 = load %struct.sv*, %struct.sv** %sv, align 8
  %call = call i8* @Perl_sv_2pv_flags(%struct.sv* %15, i64* %len, i32 2)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %14, %cond.true ], [ %call, %cond.false ]
  store i8* %cond, i8** %name, align 8
  %16 = load i8*, i8** %name, align 8
  %17 = load i64, i64* %len, align 8
  %conv = trunc i64 %17 to i32
  %call2 = call %struct.hv* @Perl_gv_stashpvn(i8* %16, i32 %conv, i32 1)
  store %struct.hv* %call2, %struct.hv** @PL_curstash, align 8
  %18 = load %struct.sv*, %struct.sv** @PL_curstname, align 8
  %19 = load i8*, i8** %name, align 8
  %20 = load i64, i64* %len, align 8
  call void @Perl_sv_setpvn(%struct.sv* %18, i8* %19, i64 %20)
  %21 = load %struct.op*, %struct.op** %o.addr, align 8
  call void @Perl_op_free(%struct.op* %21)
  br label %if.end

if.else:                                          ; preds = %entry
  call void @Perl_deprecate(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.44, i32 0, i32 0))
  %22 = load %struct.sv*, %struct.sv** @PL_curstname, align 8
  call void @Perl_sv_setpv(%struct.sv* %22, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.45, i32 0, i32 0))
  store %struct.hv* null, %struct.hv** @PL_curstash, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %cond.end
  %23 = load i32, i32* @PL_hints, align 4
  %or = or i32 %23, 256
  store i32 %or, i32* @PL_hints, align 4
  store i32 -1, i32* @PL_copline, align 4
  store i32 3, i32* @PL_expect, align 4
  ret void
}

declare void @Perl_save_hptr(%struct.hv**) #1

declare void @Perl_save_item(%struct.sv*) #1

declare %struct.hv* @Perl_gv_stashpvn(i8*, i32, i32) #1

declare void @Perl_deprecate(i8*) #1

declare void @Perl_sv_setpv(%struct.sv*, i8*) #1

; Function Attrs: nounwind uwtable
define void @Perl_utilize(i32 %aver, i32 %floor, %struct.op* %version, %struct.op* %idop, %struct.op* %arg) #0 {
entry:
  %aver.addr = alloca i32, align 4
  %floor.addr = alloca i32, align 4
  %version.addr = alloca %struct.op*, align 8
  %idop.addr = alloca %struct.op*, align 8
  %arg.addr = alloca %struct.op*, align 8
  %pack = alloca %struct.op*, align 8
  %imop = alloca %struct.op*, align 8
  %veop = alloca %struct.op*, align 8
  %vesv = alloca %struct.sv*, align 8
  %pack8 = alloca %struct.op*, align 8
  %meth = alloca %struct.sv*, align 8
  %s_PeRlHaSh_tmp = alloca i8*, align 8
  %s_PeRlHaSh = alloca i8*, align 8
  %i_PeRlHaSh = alloca i32, align 4
  %hash_PeRlHaSh = alloca i32, align 4
  %tmp = alloca i64, align 8
  %meth63 = alloca %struct.sv*, align 8
  %s_PeRlHaSh_tmp88 = alloca i8*, align 8
  %s_PeRlHaSh92 = alloca i8*, align 8
  %i_PeRlHaSh94 = alloca i32, align 4
  %hash_PeRlHaSh99 = alloca i32, align 4
  %tmp116 = alloca i64, align 8
  store i32 %aver, i32* %aver.addr, align 4
  store i32 %floor, i32* %floor.addr, align 4
  store %struct.op* %version, %struct.op** %version.addr, align 8
  store %struct.op* %idop, %struct.op** %idop.addr, align 8
  store %struct.op* %arg, %struct.op** %arg.addr, align 8
  %0 = load %struct.op*, %struct.op** %idop.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %0, i32 0, i32 4
  %1 = load i16, i16* %op_type, align 2
  %conv = zext i16 %1 to i32
  %cmp = icmp ne i32 %conv, 5
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.46, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  store %struct.op* null, %struct.op** %veop, align 8
  %2 = load %struct.op*, %struct.op** %version.addr, align 8
  %cmp2 = icmp ne %struct.op* %2, null
  br i1 %cmp2, label %if.then.4, label %if.end.47

if.then.4:                                        ; preds = %if.end
  %3 = load %struct.op*, %struct.op** %version.addr, align 8
  %4 = bitcast %struct.op* %3 to %struct.svop*
  %op_sv = getelementptr inbounds %struct.svop, %struct.svop* %4, i32 0, i32 8
  %5 = load %struct.sv*, %struct.sv** %op_sv, align 8
  store %struct.sv* %5, %struct.sv** %vesv, align 8
  %6 = load %struct.op*, %struct.op** %arg.addr, align 8
  %cmp5 = icmp eq %struct.op* %6, null
  br i1 %cmp5, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.then.4
  %7 = load %struct.sv*, %struct.sv** %vesv, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %7, i32 0, i32 2
  %8 = load i32, i32* %sv_flags, align 4
  %and = and i32 %8, 50331648
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.else, label %if.then.7

if.then.7:                                        ; preds = %land.lhs.true
  %9 = load %struct.op*, %struct.op** %version.addr, align 8
  store %struct.op* %9, %struct.op** %arg.addr, align 8
  br label %if.end.46

if.else:                                          ; preds = %land.lhs.true, %if.then.4
  %10 = load %struct.op*, %struct.op** %version.addr, align 8
  %op_type9 = getelementptr inbounds %struct.op, %struct.op* %10, i32 0, i32 4
  %11 = load i16, i16* %op_type9, align 2
  %conv10 = zext i16 %11 to i32
  %cmp11 = icmp ne i32 %conv10, 5
  br i1 %cmp11, label %if.then.16, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else
  %12 = load %struct.sv*, %struct.sv** %vesv, align 8
  %sv_flags13 = getelementptr inbounds %struct.sv, %struct.sv* %12, i32 0, i32 2
  %13 = load i32, i32* %sv_flags13, align 4
  %and14 = and i32 %13, 50331648
  %tobool15 = icmp ne i32 %and14, 0
  br i1 %tobool15, label %if.end.17, label %if.then.16

if.then.16:                                       ; preds = %lor.lhs.false, %if.else
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.47, i32 0, i32 0))
  br label %if.end.17

if.end.17:                                        ; preds = %if.then.16, %lor.lhs.false
  %14 = load %struct.op*, %struct.op** %idop.addr, align 8
  %15 = bitcast %struct.op* %14 to %struct.svop*
  %op_sv18 = getelementptr inbounds %struct.svop, %struct.svop* %15, i32 0, i32 8
  %16 = load %struct.sv*, %struct.sv** %op_sv18, align 8
  %call = call %struct.sv* @Perl_newSVsv(%struct.sv* %16)
  %call19 = call %struct.op* @Perl_newSVOP(i32 5, i32 0, %struct.sv* %call)
  store %struct.op* %call19, %struct.op** %pack8, align 8
  %call20 = call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.48, i32 0, i32 0), i64 7)
  store %struct.sv* %call20, %struct.sv** %meth, align 8
  %17 = load %struct.sv*, %struct.sv** %meth, align 8
  %call21 = call signext i8 @Perl_sv_upgrade(%struct.sv* %17, i32 5)
  %18 = load %struct.sv*, %struct.sv** %meth, align 8
  %sv_flags22 = getelementptr inbounds %struct.sv, %struct.sv* %18, i32 0, i32 2
  %19 = load i32, i32* %sv_flags22, align 4
  %and23 = and i32 %19, 2097152
  %tobool24 = icmp ne i32 %and23, 0
  br i1 %tobool24, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end.17
  %20 = load %struct.sv*, %struct.sv** %meth, align 8
  %call25 = call i32 @Perl_sv_backoff(%struct.sv* %20)
  %tobool26 = icmp ne i32 %call25, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end.17
  %21 = phi i1 [ false, %if.end.17 ], [ %tobool26, %land.rhs ]
  %land.ext = zext i1 %21 to i32
  %22 = load %struct.sv*, %struct.sv** %meth, align 8
  %sv_flags27 = getelementptr inbounds %struct.sv, %struct.sv* %22, i32 0, i32 2
  %23 = load i32, i32* %sv_flags27, align 4
  %or = or i32 %23, 16842752
  store i32 %or, i32* %sv_flags27, align 4
  %24 = load %struct.sv*, %struct.sv** %meth, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %24, i32 0, i32 0
  %25 = load i8*, i8** %sv_any, align 8
  %26 = bitcast i8* %25 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %26, i32 0, i32 0
  %27 = load i8*, i8** %xpv_pv, align 8
  store i8* %27, i8** %s_PeRlHaSh_tmp, align 8
  %28 = load i8*, i8** %s_PeRlHaSh_tmp, align 8
  store i8* %28, i8** %s_PeRlHaSh, align 8
  %29 = load %struct.sv*, %struct.sv** %meth, align 8
  %sv_any28 = getelementptr inbounds %struct.sv, %struct.sv* %29, i32 0, i32 0
  %30 = load i8*, i8** %sv_any28, align 8
  %31 = bitcast i8* %30 to %struct.xpv*
  %xpv_cur = getelementptr inbounds %struct.xpv, %struct.xpv* %31, i32 0, i32 1
  %32 = load i64, i64* %xpv_cur, align 8
  %conv29 = trunc i64 %32 to i32
  store i32 %conv29, i32* %i_PeRlHaSh, align 4
  store i32 0, i32* %hash_PeRlHaSh, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %land.end
  %33 = load i32, i32* %i_PeRlHaSh, align 4
  %dec = add nsw i32 %33, -1
  store i32 %dec, i32* %i_PeRlHaSh, align 4
  %tobool30 = icmp ne i32 %33, 0
  br i1 %tobool30, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %34 = load i8*, i8** %s_PeRlHaSh, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %34, i32 1
  store i8* %incdec.ptr, i8** %s_PeRlHaSh, align 8
  %35 = load i8, i8* %34, align 1
  %conv31 = zext i8 %35 to i32
  %36 = load i32, i32* %hash_PeRlHaSh, align 4
  %add = add i32 %36, %conv31
  store i32 %add, i32* %hash_PeRlHaSh, align 4
  %37 = load i32, i32* %hash_PeRlHaSh, align 4
  %shl = shl i32 %37, 10
  %38 = load i32, i32* %hash_PeRlHaSh, align 4
  %add32 = add i32 %38, %shl
  store i32 %add32, i32* %hash_PeRlHaSh, align 4
  %39 = load i32, i32* %hash_PeRlHaSh, align 4
  %shr = lshr i32 %39, 6
  %40 = load i32, i32* %hash_PeRlHaSh, align 4
  %xor = xor i32 %40, %shr
  store i32 %xor, i32* %hash_PeRlHaSh, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %41 = load i32, i32* %hash_PeRlHaSh, align 4
  %shl33 = shl i32 %41, 3
  %42 = load i32, i32* %hash_PeRlHaSh, align 4
  %add34 = add i32 %42, %shl33
  store i32 %add34, i32* %hash_PeRlHaSh, align 4
  %43 = load i32, i32* %hash_PeRlHaSh, align 4
  %shr35 = lshr i32 %43, 11
  %44 = load i32, i32* %hash_PeRlHaSh, align 4
  %xor36 = xor i32 %44, %shr35
  store i32 %xor36, i32* %hash_PeRlHaSh, align 4
  %45 = load i32, i32* %hash_PeRlHaSh, align 4
  %46 = load i32, i32* %hash_PeRlHaSh, align 4
  %shl37 = shl i32 %46, 15
  %add38 = add i32 %45, %shl37
  %conv39 = zext i32 %add38 to i64
  %47 = load %struct.sv*, %struct.sv** %meth, align 8
  %sv_any40 = getelementptr inbounds %struct.sv, %struct.sv* %47, i32 0, i32 0
  %48 = load i8*, i8** %sv_any40, align 8
  %49 = bitcast i8* %48 to %struct.xpvuv*
  %xuv_uv = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %49, i32 0, i32 3
  store i64 %conv39, i64* %xuv_uv, align 8
  store i64 %conv39, i64* %tmp
  %50 = load i64, i64* %tmp
  %51 = load %struct.op*, %struct.op** %pack8, align 8
  %52 = load %struct.op*, %struct.op** %version.addr, align 8
  %call41 = call %struct.op* @Perl_list(%struct.op* %52)
  %call42 = call %struct.op* @Perl_prepend_elem(i32 141, %struct.op* %51, %struct.op* %call41)
  %53 = load %struct.sv*, %struct.sv** %meth, align 8
  %call43 = call %struct.op* @Perl_newSVOP(i32 350, i32 0, %struct.sv* %53)
  %call44 = call %struct.op* @Perl_append_elem(i32 141, %struct.op* %call42, %struct.op* %call43)
  %call45 = call %struct.op* @Perl_convert(i32 166, i32 192, %struct.op* %call44)
  store %struct.op* %call45, %struct.op** %veop, align 8
  br label %if.end.46

if.end.46:                                        ; preds = %while.end, %if.then.7
  br label %if.end.47

if.end.47:                                        ; preds = %if.end.46, %if.end
  %54 = load %struct.op*, %struct.op** %arg.addr, align 8
  %tobool48 = icmp ne %struct.op* %54, null
  br i1 %tobool48, label %land.lhs.true.49, label %if.else.55

land.lhs.true.49:                                 ; preds = %if.end.47
  %55 = load %struct.op*, %struct.op** %arg.addr, align 8
  %op_type50 = getelementptr inbounds %struct.op, %struct.op* %55, i32 0, i32 4
  %56 = load i16, i16* %op_type50, align 2
  %conv51 = zext i16 %56 to i32
  %cmp52 = icmp eq i32 %conv51, 1
  br i1 %cmp52, label %if.then.54, label %if.else.55

if.then.54:                                       ; preds = %land.lhs.true.49
  %57 = load %struct.op*, %struct.op** %arg.addr, align 8
  store %struct.op* %57, %struct.op** %imop, align 8
  br label %if.end.128

if.else.55:                                       ; preds = %land.lhs.true.49, %if.end.47
  %58 = load %struct.op*, %struct.op** %idop.addr, align 8
  %59 = bitcast %struct.op* %58 to %struct.svop*
  %op_sv56 = getelementptr inbounds %struct.svop, %struct.svop* %59, i32 0, i32 8
  %60 = load %struct.sv*, %struct.sv** %op_sv56, align 8
  %sv_flags57 = getelementptr inbounds %struct.sv, %struct.sv* %60, i32 0, i32 2
  %61 = load i32, i32* %sv_flags57, align 4
  %and58 = and i32 %61, 50331648
  %tobool59 = icmp ne i32 %and58, 0
  br i1 %tobool59, label %if.then.60, label %if.else.61

if.then.60:                                       ; preds = %if.else.55
  store %struct.op* null, %struct.op** %imop, align 8
  br label %if.end.127

if.else.61:                                       ; preds = %if.else.55
  %62 = load %struct.op*, %struct.op** %idop.addr, align 8
  %63 = bitcast %struct.op* %62 to %struct.svop*
  %op_sv64 = getelementptr inbounds %struct.svop, %struct.svop* %63, i32 0, i32 8
  %64 = load %struct.sv*, %struct.sv** %op_sv64, align 8
  %call65 = call %struct.sv* @Perl_newSVsv(%struct.sv* %64)
  %call66 = call %struct.op* @Perl_newSVOP(i32 5, i32 0, %struct.sv* %call65)
  store %struct.op* %call66, %struct.op** %pack, align 8
  %65 = load i32, i32* %aver.addr, align 4
  %tobool67 = icmp ne i32 %65, 0
  br i1 %tobool67, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.else.61
  %call68 = call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.49, i32 0, i32 0), i64 6)
  br label %cond.end

cond.false:                                       ; preds = %if.else.61
  %call69 = call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.50, i32 0, i32 0), i64 8)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.sv* [ %call68, %cond.true ], [ %call69, %cond.false ]
  store %struct.sv* %cond, %struct.sv** %meth63, align 8
  %66 = load %struct.sv*, %struct.sv** %meth63, align 8
  %sv_flags70 = getelementptr inbounds %struct.sv, %struct.sv* %66, i32 0, i32 2
  %67 = load i32, i32* %sv_flags70, align 4
  %and71 = and i32 %67, 255
  %cmp72 = icmp uge i32 %and71, 5
  br i1 %cmp72, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %cond.end
  %68 = load %struct.sv*, %struct.sv** %meth63, align 8
  %call74 = call signext i8 @Perl_sv_upgrade(%struct.sv* %68, i32 5)
  %conv75 = sext i8 %call74 to i32
  %tobool76 = icmp ne i32 %conv75, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %cond.end
  %69 = phi i1 [ true, %cond.end ], [ %tobool76, %lor.rhs ]
  %lor.ext = zext i1 %69 to i32
  %70 = load %struct.sv*, %struct.sv** %meth63, align 8
  %sv_flags77 = getelementptr inbounds %struct.sv, %struct.sv* %70, i32 0, i32 2
  %71 = load i32, i32* %sv_flags77, align 4
  %and78 = and i32 %71, 2097152
  %tobool79 = icmp ne i32 %and78, 0
  br i1 %tobool79, label %land.rhs.80, label %land.end.83

land.rhs.80:                                      ; preds = %lor.end
  %72 = load %struct.sv*, %struct.sv** %meth63, align 8
  %call81 = call i32 @Perl_sv_backoff(%struct.sv* %72)
  %tobool82 = icmp ne i32 %call81, 0
  br label %land.end.83

land.end.83:                                      ; preds = %land.rhs.80, %lor.end
  %73 = phi i1 [ false, %lor.end ], [ %tobool82, %land.rhs.80 ]
  %land.ext84 = zext i1 %73 to i32
  %74 = load %struct.sv*, %struct.sv** %meth63, align 8
  %sv_flags85 = getelementptr inbounds %struct.sv, %struct.sv* %74, i32 0, i32 2
  %75 = load i32, i32* %sv_flags85, align 4
  %or86 = or i32 %75, 16842752
  store i32 %or86, i32* %sv_flags85, align 4
  %76 = load %struct.sv*, %struct.sv** %meth63, align 8
  %sv_any89 = getelementptr inbounds %struct.sv, %struct.sv* %76, i32 0, i32 0
  %77 = load i8*, i8** %sv_any89, align 8
  %78 = bitcast i8* %77 to %struct.xpv*
  %xpv_pv90 = getelementptr inbounds %struct.xpv, %struct.xpv* %78, i32 0, i32 0
  %79 = load i8*, i8** %xpv_pv90, align 8
  store i8* %79, i8** %s_PeRlHaSh_tmp88, align 8
  %80 = load i8*, i8** %s_PeRlHaSh_tmp88, align 8
  store i8* %80, i8** %s_PeRlHaSh92, align 8
  %81 = load %struct.sv*, %struct.sv** %meth63, align 8
  %sv_any95 = getelementptr inbounds %struct.sv, %struct.sv* %81, i32 0, i32 0
  %82 = load i8*, i8** %sv_any95, align 8
  %83 = bitcast i8* %82 to %struct.xpv*
  %xpv_cur96 = getelementptr inbounds %struct.xpv, %struct.xpv* %83, i32 0, i32 1
  %84 = load i64, i64* %xpv_cur96, align 8
  %conv97 = trunc i64 %84 to i32
  store i32 %conv97, i32* %i_PeRlHaSh94, align 4
  store i32 0, i32* %hash_PeRlHaSh99, align 4
  br label %while.cond.100

while.cond.100:                                   ; preds = %while.body.103, %land.end.83
  %85 = load i32, i32* %i_PeRlHaSh94, align 4
  %dec101 = add nsw i32 %85, -1
  store i32 %dec101, i32* %i_PeRlHaSh94, align 4
  %tobool102 = icmp ne i32 %85, 0
  br i1 %tobool102, label %while.body.103, label %while.end.111

while.body.103:                                   ; preds = %while.cond.100
  %86 = load i8*, i8** %s_PeRlHaSh92, align 8
  %incdec.ptr104 = getelementptr inbounds i8, i8* %86, i32 1
  store i8* %incdec.ptr104, i8** %s_PeRlHaSh92, align 8
  %87 = load i8, i8* %86, align 1
  %conv105 = zext i8 %87 to i32
  %88 = load i32, i32* %hash_PeRlHaSh99, align 4
  %add106 = add i32 %88, %conv105
  store i32 %add106, i32* %hash_PeRlHaSh99, align 4
  %89 = load i32, i32* %hash_PeRlHaSh99, align 4
  %shl107 = shl i32 %89, 10
  %90 = load i32, i32* %hash_PeRlHaSh99, align 4
  %add108 = add i32 %90, %shl107
  store i32 %add108, i32* %hash_PeRlHaSh99, align 4
  %91 = load i32, i32* %hash_PeRlHaSh99, align 4
  %shr109 = lshr i32 %91, 6
  %92 = load i32, i32* %hash_PeRlHaSh99, align 4
  %xor110 = xor i32 %92, %shr109
  store i32 %xor110, i32* %hash_PeRlHaSh99, align 4
  br label %while.cond.100

while.end.111:                                    ; preds = %while.cond.100
  %93 = load i32, i32* %hash_PeRlHaSh99, align 4
  %shl112 = shl i32 %93, 3
  %94 = load i32, i32* %hash_PeRlHaSh99, align 4
  %add113 = add i32 %94, %shl112
  store i32 %add113, i32* %hash_PeRlHaSh99, align 4
  %95 = load i32, i32* %hash_PeRlHaSh99, align 4
  %shr114 = lshr i32 %95, 11
  %96 = load i32, i32* %hash_PeRlHaSh99, align 4
  %xor115 = xor i32 %96, %shr114
  store i32 %xor115, i32* %hash_PeRlHaSh99, align 4
  %97 = load i32, i32* %hash_PeRlHaSh99, align 4
  %98 = load i32, i32* %hash_PeRlHaSh99, align 4
  %shl117 = shl i32 %98, 15
  %add118 = add i32 %97, %shl117
  %conv119 = zext i32 %add118 to i64
  %99 = load %struct.sv*, %struct.sv** %meth63, align 8
  %sv_any120 = getelementptr inbounds %struct.sv, %struct.sv* %99, i32 0, i32 0
  %100 = load i8*, i8** %sv_any120, align 8
  %101 = bitcast i8* %100 to %struct.xpvuv*
  %xuv_uv121 = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %101, i32 0, i32 3
  store i64 %conv119, i64* %xuv_uv121, align 8
  store i64 %conv119, i64* %tmp116
  %102 = load i64, i64* %tmp116
  %103 = load %struct.op*, %struct.op** %pack, align 8
  %104 = load %struct.op*, %struct.op** %arg.addr, align 8
  %call122 = call %struct.op* @Perl_list(%struct.op* %104)
  %call123 = call %struct.op* @Perl_prepend_elem(i32 141, %struct.op* %103, %struct.op* %call122)
  %105 = load %struct.sv*, %struct.sv** %meth63, align 8
  %call124 = call %struct.op* @Perl_newSVOP(i32 350, i32 0, %struct.sv* %105)
  %call125 = call %struct.op* @Perl_append_elem(i32 141, %struct.op* %call123, %struct.op* %call124)
  %call126 = call %struct.op* @Perl_convert(i32 166, i32 192, %struct.op* %call125)
  store %struct.op* %call126, %struct.op** %imop, align 8
  br label %if.end.127

if.end.127:                                       ; preds = %while.end.111, %if.then.60
  br label %if.end.128

if.end.128:                                       ; preds = %if.end.127, %if.then.54
  %106 = load i32, i32* %floor.addr, align 4
  %call129 = call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.51, i32 0, i32 0), i64 5)
  %call130 = call %struct.op* @Perl_newSVOP(i32 5, i32 0, %struct.sv* %call129)
  %107 = load %struct.op*, %struct.op** %idop.addr, align 8
  %call131 = call %struct.op* @Perl_newUNOP(i32 309, i32 0, %struct.op* %107)
  %call132 = call %struct.op* @Perl_newSTATEOP(i32 0, i8* null, %struct.op* %call131)
  %108 = load %struct.op*, %struct.op** %veop, align 8
  %call133 = call %struct.op* @Perl_newSTATEOP(i32 0, i8* null, %struct.op* %108)
  %call134 = call %struct.op* @Perl_append_elem(i32 173, %struct.op* %call132, %struct.op* %call133)
  %109 = load %struct.op*, %struct.op** %imop, align 8
  %call135 = call %struct.op* @Perl_newSTATEOP(i32 0, i8* null, %struct.op* %109)
  %call136 = call %struct.op* @Perl_append_elem(i32 173, %struct.op* %call134, %struct.op* %call135)
  %call137 = call %struct.cv* @Perl_newATTRSUB(i32 %106, %struct.op* %call130, %struct.op* null, %struct.op* null, %struct.op* %call136)
  %110 = load i32, i32* @PL_hints, align 4
  %or138 = or i32 %110, 256
  store i32 %or138, i32* @PL_hints, align 4
  store i32 -1, i32* @PL_copline, align 4
  store i32 3, i32* @PL_expect, align 4
  %111 = load i32, i32* @PL_cop_seqmax, align 4
  %inc = add i32 %111, 1
  store i32 %inc, i32* @PL_cop_seqmax, align 4
  ret void
}

declare signext i8 @Perl_sv_upgrade(%struct.sv*, i32) #1

declare i32 @Perl_sv_backoff(%struct.sv*) #1

; Function Attrs: nounwind uwtable
define %struct.cv* @Perl_newATTRSUB(i32 %floor, %struct.op* %o, %struct.op* %proto, %struct.op* %attrs, %struct.op* %block) #0 {
entry:
  %floor.addr = alloca i32, align 4
  %o.addr = alloca %struct.op*, align 8
  %proto.addr = alloca %struct.op*, align 8
  %attrs.addr = alloca %struct.op*, align 8
  %block.addr = alloca %struct.op*, align 8
  %n_a = alloca i64, align 8
  %name = alloca i8*, align 8
  %aname = alloca i8*, align 8
  %gv = alloca %struct.gv*, align 8
  %ps = alloca i8*, align 8
  %cv = alloca %struct.cv*, align 8
  %const_sv = alloca %struct.sv*, align 8
  %sv = alloca %struct.sv*, align 8
  %exists = alloca i8, align 1
  %oldline = alloca i32, align 4
  %stash = alloca %struct.hv*, align 8
  %rcv = alloca %struct.sv*, align 8
  %s = alloca i8*, align 8
  %not_safe = alloca i8*, align 8
  %s529 = alloca i8*, align 8
  %tname = alloca i8*, align 8
  %sv543 = alloca %struct.sv*, align 8
  %tmpstr = alloca %struct.sv*, align 8
  %db_postponed = alloca %struct.gv*, align 8
  %pcv = alloca %struct.cv*, align 8
  %hv = alloca %struct.hv*, align 8
  %sp = alloca %struct.sv**, align 8
  %tmp = alloca i32, align 4
  %tmp630 = alloca %struct.sv*, align 8
  %oldscope = alloca i32, align 4
  store i32 %floor, i32* %floor.addr, align 4
  store %struct.op* %o, %struct.op** %o.addr, align 8
  store %struct.op* %proto, %struct.op** %proto.addr, align 8
  store %struct.op* %attrs, %struct.op** %attrs.addr, align 8
  store %struct.op* %block, %struct.op** %block.addr, align 8
  store %struct.cv* null, %struct.cv** %cv, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %tobool = icmp ne %struct.op* %0, null
  br i1 %tobool, label %cond.true, label %cond.false.3

cond.true:                                        ; preds = %entry
  %1 = load %struct.op*, %struct.op** %o.addr, align 8
  %2 = bitcast %struct.op* %1 to %struct.svop*
  %op_sv = getelementptr inbounds %struct.svop, %struct.svop* %2, i32 0, i32 8
  %3 = load %struct.sv*, %struct.sv** %op_sv, align 8
  store %struct.sv* %3, %struct.sv** @PL_Sv, align 8
  %4 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %4, i32 0, i32 2
  %5 = load i32, i32* %sv_flags, align 4
  %and = and i32 %5, 262144
  %cmp = icmp eq i32 %and, 262144
  br i1 %cmp, label %cond.true.1, label %cond.false

cond.true.1:                                      ; preds = %cond.true
  %6 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %6, i32 0, i32 0
  %7 = load i8*, i8** %sv_any, align 8
  %8 = bitcast i8* %7 to %struct.xpv*
  %xpv_cur = getelementptr inbounds %struct.xpv, %struct.xpv* %8, i32 0, i32 1
  %9 = load i64, i64* %xpv_cur, align 8
  store i64 %9, i64* %n_a, align 8
  %10 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any2 = getelementptr inbounds %struct.sv, %struct.sv* %10, i32 0, i32 0
  %11 = load i8*, i8** %sv_any2, align 8
  %12 = bitcast i8* %11 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %12, i32 0, i32 0
  %13 = load i8*, i8** %xpv_pv, align 8
  br label %cond.end

cond.false:                                       ; preds = %cond.true
  %14 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call = call i8* @Perl_sv_2pv_flags(%struct.sv* %14, i64* %n_a, i32 2)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true.1
  %cond = phi i8* [ %13, %cond.true.1 ], [ %call, %cond.false ]
  br label %cond.end.4

cond.false.3:                                     ; preds = %entry
  br label %cond.end.4

cond.end.4:                                       ; preds = %cond.false.3, %cond.end
  %cond5 = phi i8* [ %cond, %cond.end ], [ null, %cond.false.3 ]
  store i8* %cond5, i8** %name, align 8
  %15 = load %struct.op*, %struct.op** %proto.addr, align 8
  %tobool6 = icmp ne %struct.op* %15, null
  br i1 %tobool6, label %if.then, label %if.else

if.then:                                          ; preds = %cond.end.4
  %16 = load %struct.op*, %struct.op** %proto.addr, align 8
  %17 = bitcast %struct.op* %16 to %struct.svop*
  %op_sv7 = getelementptr inbounds %struct.svop, %struct.svop* %17, i32 0, i32 8
  %18 = load %struct.sv*, %struct.sv** %op_sv7, align 8
  store %struct.sv* %18, %struct.sv** @PL_Sv, align 8
  %19 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags8 = getelementptr inbounds %struct.sv, %struct.sv* %19, i32 0, i32 2
  %20 = load i32, i32* %sv_flags8, align 4
  %and9 = and i32 %20, 262144
  %cmp10 = icmp eq i32 %and9, 262144
  br i1 %cmp10, label %cond.true.11, label %cond.false.16

cond.true.11:                                     ; preds = %if.then
  %21 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any12 = getelementptr inbounds %struct.sv, %struct.sv* %21, i32 0, i32 0
  %22 = load i8*, i8** %sv_any12, align 8
  %23 = bitcast i8* %22 to %struct.xpv*
  %xpv_cur13 = getelementptr inbounds %struct.xpv, %struct.xpv* %23, i32 0, i32 1
  %24 = load i64, i64* %xpv_cur13, align 8
  store i64 %24, i64* %n_a, align 8
  %25 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any14 = getelementptr inbounds %struct.sv, %struct.sv* %25, i32 0, i32 0
  %26 = load i8*, i8** %sv_any14, align 8
  %27 = bitcast i8* %26 to %struct.xpv*
  %xpv_pv15 = getelementptr inbounds %struct.xpv, %struct.xpv* %27, i32 0, i32 0
  %28 = load i8*, i8** %xpv_pv15, align 8
  br label %cond.end.18

cond.false.16:                                    ; preds = %if.then
  %29 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call17 = call i8* @Perl_sv_2pv_flags(%struct.sv* %29, i64* %n_a, i32 2)
  br label %cond.end.18

cond.end.18:                                      ; preds = %cond.false.16, %cond.true.11
  %cond19 = phi i8* [ %28, %cond.true.11 ], [ %call17, %cond.false.16 ]
  store i8* %cond19, i8** %ps, align 8
  br label %if.end

if.else:                                          ; preds = %cond.end.4
  store i8* null, i8** %ps, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %cond.end.18
  %30 = load i8*, i8** %name, align 8
  %tobool20 = icmp ne i8* %30, null
  br i1 %tobool20, label %if.else.56, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %31 = load i32, i32* @PL_perldb, align 4
  %tobool21 = icmp ne i32 %31, 0
  br i1 %tobool21, label %land.lhs.true.22, label %if.else.56

land.lhs.true.22:                                 ; preds = %land.lhs.true
  %32 = load i32, i32* @PL_perldb, align 4
  %and23 = and i32 %32, 512
  %tobool24 = icmp ne i32 %and23, 0
  br i1 %tobool24, label %land.lhs.true.25, label %if.else.56

land.lhs.true.25:                                 ; preds = %land.lhs.true.22
  %33 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_line = getelementptr inbounds %struct.cop, %struct.cop* %33, i32 0, i32 13
  %34 = load i32, i32* %cop_line, align 4
  %tobool26 = icmp ne i32 %34, 0
  br i1 %tobool26, label %if.then.27, label %if.else.56

if.then.27:                                       ; preds = %land.lhs.true.25
  %call28 = call %struct.sv* @Perl_sv_newmortal()
  store %struct.sv* %call28, %struct.sv** %sv, align 8
  %35 = load %struct.sv*, %struct.sv** %sv, align 8
  %36 = load %struct.hv*, %struct.hv** @PL_curstash, align 8
  %tobool29 = icmp ne %struct.hv* %36, null
  %cond30 = select i1 %tobool29, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.66, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.67, i32 0, i32 0)
  %37 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_filegv = getelementptr inbounds %struct.cop, %struct.cop* %37, i32 0, i32 10
  %38 = load %struct.gv*, %struct.gv** %cop_filegv, align 8
  %tobool31 = icmp ne %struct.gv* %38, null
  br i1 %tobool31, label %cond.true.32, label %cond.false.36

cond.true.32:                                     ; preds = %if.then.27
  %39 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_filegv33 = getelementptr inbounds %struct.cop, %struct.cop* %39, i32 0, i32 10
  %40 = load %struct.gv*, %struct.gv** %cop_filegv33, align 8
  %sv_any34 = getelementptr inbounds %struct.gv, %struct.gv* %40, i32 0, i32 0
  %41 = load %struct.xpvgv*, %struct.xpvgv** %sv_any34, align 8
  %xgv_gp = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %41, i32 0, i32 7
  %42 = load %struct.gp*, %struct.gp** %xgv_gp, align 8
  %gp_sv = getelementptr inbounds %struct.gp, %struct.gp* %42, i32 0, i32 0
  %43 = load %struct.sv*, %struct.sv** %gp_sv, align 8
  %tobool35 = icmp ne %struct.sv* %43, null
  br i1 %tobool35, label %cond.true.37, label %cond.false.50

cond.false.36:                                    ; preds = %if.then.27
  br i1 false, label %cond.true.37, label %cond.false.50

cond.true.37:                                     ; preds = %cond.false.36, %cond.true.32
  %44 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_filegv38 = getelementptr inbounds %struct.cop, %struct.cop* %44, i32 0, i32 10
  %45 = load %struct.gv*, %struct.gv** %cop_filegv38, align 8
  %tobool39 = icmp ne %struct.gv* %45, null
  br i1 %tobool39, label %cond.true.40, label %cond.false.45

cond.true.40:                                     ; preds = %cond.true.37
  %46 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_filegv41 = getelementptr inbounds %struct.cop, %struct.cop* %46, i32 0, i32 10
  %47 = load %struct.gv*, %struct.gv** %cop_filegv41, align 8
  %sv_any42 = getelementptr inbounds %struct.gv, %struct.gv* %47, i32 0, i32 0
  %48 = load %struct.xpvgv*, %struct.xpvgv** %sv_any42, align 8
  %xgv_gp43 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %48, i32 0, i32 7
  %49 = load %struct.gp*, %struct.gp** %xgv_gp43, align 8
  %gp_sv44 = getelementptr inbounds %struct.gp, %struct.gp* %49, i32 0, i32 0
  %50 = load %struct.sv*, %struct.sv** %gp_sv44, align 8
  br label %cond.end.46

cond.false.45:                                    ; preds = %cond.true.37
  br label %cond.end.46

cond.end.46:                                      ; preds = %cond.false.45, %cond.true.40
  %cond47 = phi %struct.sv* [ %50, %cond.true.40 ], [ null, %cond.false.45 ]
  %sv_any48 = getelementptr inbounds %struct.sv, %struct.sv* %cond47, i32 0, i32 0
  %51 = load i8*, i8** %sv_any48, align 8
  %52 = bitcast i8* %51 to %struct.xpv*
  %xpv_pv49 = getelementptr inbounds %struct.xpv, %struct.xpv* %52, i32 0, i32 0
  %53 = load i8*, i8** %xpv_pv49, align 8
  br label %cond.end.51

cond.false.50:                                    ; preds = %cond.false.36, %cond.true.32
  br label %cond.end.51

cond.end.51:                                      ; preds = %cond.false.50, %cond.end.46
  %cond52 = phi i8* [ %53, %cond.end.46 ], [ null, %cond.false.50 ]
  %54 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_line53 = getelementptr inbounds %struct.cop, %struct.cop* %54, i32 0, i32 13
  %55 = load i32, i32* %cop_line53, align 4
  %conv = zext i32 %55 to i64
  call void (%struct.sv*, i8*, ...) @Perl_sv_setpvf(%struct.sv* %35, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.65, i32 0, i32 0), i8* %cond30, i8* %cond52, i64 %conv)
  %56 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any54 = getelementptr inbounds %struct.sv, %struct.sv* %56, i32 0, i32 0
  %57 = load i8*, i8** %sv_any54, align 8
  %58 = bitcast i8* %57 to %struct.xpv*
  %xpv_pv55 = getelementptr inbounds %struct.xpv, %struct.xpv* %58, i32 0, i32 0
  %59 = load i8*, i8** %xpv_pv55, align 8
  store i8* %59, i8** %aname, align 8
  br label %if.end.57

if.else.56:                                       ; preds = %land.lhs.true.25, %land.lhs.true.22, %land.lhs.true, %if.end
  store i8* null, i8** %aname, align 8
  br label %if.end.57

if.end.57:                                        ; preds = %if.else.56, %cond.end.51
  %60 = load i8*, i8** %name, align 8
  %tobool58 = icmp ne i8* %60, null
  br i1 %tobool58, label %cond.true.59, label %cond.false.60

cond.true.59:                                     ; preds = %if.end.57
  %61 = load i8*, i8** %name, align 8
  br label %cond.end.68

cond.false.60:                                    ; preds = %if.end.57
  %62 = load i8*, i8** %aname, align 8
  %tobool61 = icmp ne i8* %62, null
  br i1 %tobool61, label %cond.true.62, label %cond.false.63

cond.true.62:                                     ; preds = %cond.false.60
  %63 = load i8*, i8** %aname, align 8
  br label %cond.end.66

cond.false.63:                                    ; preds = %cond.false.60
  %64 = load %struct.hv*, %struct.hv** @PL_curstash, align 8
  %tobool64 = icmp ne %struct.hv* %64, null
  %cond65 = select i1 %tobool64, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.66, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.67, i32 0, i32 0)
  br label %cond.end.66

cond.end.66:                                      ; preds = %cond.false.63, %cond.true.62
  %cond67 = phi i8* [ %63, %cond.true.62 ], [ %cond65, %cond.false.63 ]
  br label %cond.end.68

cond.end.68:                                      ; preds = %cond.end.66, %cond.true.59
  %cond69 = phi i8* [ %61, %cond.true.59 ], [ %cond67, %cond.end.66 ]
  %65 = load %struct.op*, %struct.op** %block.addr, align 8
  %tobool70 = icmp ne %struct.op* %65, null
  br i1 %tobool70, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %cond.end.68
  %66 = load %struct.op*, %struct.op** %attrs.addr, align 8
  %tobool71 = icmp ne %struct.op* %66, null
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %cond.end.68
  %67 = phi i1 [ true, %cond.end.68 ], [ %tobool71, %lor.rhs ]
  %cond72 = select i1 %67, i32 0, i32 16
  %or = or i32 2, %cond72
  %call73 = call %struct.gv* @Perl_gv_fetchpv(i8* %cond69, i32 %or, i32 12)
  store %struct.gv* %call73, %struct.gv** %gv, align 8
  %68 = load %struct.op*, %struct.op** %o.addr, align 8
  %tobool74 = icmp ne %struct.op* %68, null
  br i1 %tobool74, label %if.then.75, label %if.end.76

if.then.75:                                       ; preds = %lor.end
  %69 = load %struct.op*, %struct.op** %o.addr, align 8
  call void @Perl_save_freeop(%struct.op* %69)
  br label %if.end.76

if.end.76:                                        ; preds = %if.then.75, %lor.end
  %70 = load %struct.op*, %struct.op** %proto.addr, align 8
  %tobool77 = icmp ne %struct.op* %70, null
  br i1 %tobool77, label %if.then.78, label %if.end.79

if.then.78:                                       ; preds = %if.end.76
  %71 = load %struct.op*, %struct.op** %proto.addr, align 8
  call void @Perl_save_freeop(%struct.op* %71)
  br label %if.end.79

if.end.79:                                        ; preds = %if.then.78, %if.end.76
  %72 = load %struct.op*, %struct.op** %attrs.addr, align 8
  %tobool80 = icmp ne %struct.op* %72, null
  br i1 %tobool80, label %if.then.81, label %if.end.82

if.then.81:                                       ; preds = %if.end.79
  %73 = load %struct.op*, %struct.op** %attrs.addr, align 8
  call void @Perl_save_freeop(%struct.op* %73)
  br label %if.end.82

if.end.82:                                        ; preds = %if.then.81, %if.end.79
  %74 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_flags83 = getelementptr inbounds %struct.gv, %struct.gv* %74, i32 0, i32 2
  %75 = load i32, i32* %sv_flags83, align 4
  %and84 = and i32 %75, 255
  %cmp85 = icmp ne i32 %and84, 13
  br i1 %cmp85, label %if.then.87, label %if.end.128

if.then.87:                                       ; preds = %if.end.82
  %76 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_flags88 = getelementptr inbounds %struct.gv, %struct.gv* %76, i32 0, i32 2
  %77 = load i32, i32* %sv_flags88, align 4
  %and89 = and i32 %77, 255
  %cmp90 = icmp ugt i32 %and89, 0
  br i1 %cmp90, label %if.then.92, label %if.end.123

if.then.92:                                       ; preds = %if.then.87
  %78 = load %struct.gv*, %struct.gv** %gv, align 8
  %79 = bitcast %struct.gv* %78 to %struct.sv*
  %sv_flags93 = getelementptr inbounds %struct.sv, %struct.sv* %79, i32 0, i32 2
  %80 = load i32, i32* %sv_flags93, align 4
  %and94 = and i32 %80, 262144
  %tobool95 = icmp ne i32 %and94, 0
  br i1 %tobool95, label %if.end.122, label %land.lhs.true.96

land.lhs.true.96:                                 ; preds = %if.then.92
  %81 = load %struct.gv*, %struct.gv** %gv, align 8
  %82 = bitcast %struct.gv* %81 to %struct.sv*
  %sv_flags97 = getelementptr inbounds %struct.sv, %struct.sv* %82, i32 0, i32 2
  %83 = load i32, i32* %sv_flags97, align 4
  %and98 = and i32 %83, 65536
  %tobool99 = icmp ne i32 %and98, 0
  br i1 %tobool99, label %land.lhs.true.100, label %land.lhs.true.104

land.lhs.true.100:                                ; preds = %land.lhs.true.96
  %84 = load %struct.gv*, %struct.gv** %gv, align 8
  %85 = bitcast %struct.gv* %84 to %struct.sv*
  %sv_any101 = getelementptr inbounds %struct.sv, %struct.sv* %85, i32 0, i32 0
  %86 = load i8*, i8** %sv_any101, align 8
  %87 = bitcast i8* %86 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %87, i32 0, i32 3
  %88 = load i64, i64* %xiv_iv, align 8
  %cmp102 = icmp eq i64 %88, -1
  br i1 %cmp102, label %if.end.122, label %land.lhs.true.104

land.lhs.true.104:                                ; preds = %land.lhs.true.100, %land.lhs.true.96
  %89 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings = getelementptr inbounds %struct.cop, %struct.cop* %89, i32 0, i32 14
  %90 = load %struct.sv*, %struct.sv** %cop_warnings, align 8
  %cmp105 = icmp eq %struct.sv* %90, null
  br i1 %cmp105, label %if.then.121, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true.104
  %91 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings107 = getelementptr inbounds %struct.cop, %struct.cop* %91, i32 0, i32 14
  %92 = load %struct.sv*, %struct.sv** %cop_warnings107, align 8
  %cmp108 = icmp eq %struct.sv* %92, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 1)
  br i1 %cmp108, label %if.then.121, label %lor.lhs.false.110

lor.lhs.false.110:                                ; preds = %lor.lhs.false
  %93 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings111 = getelementptr inbounds %struct.cop, %struct.cop* %93, i32 0, i32 14
  %94 = load %struct.sv*, %struct.sv** %cop_warnings111, align 8
  %cmp112 = icmp ne %struct.sv* %94, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 2)
  br i1 %cmp112, label %land.lhs.true.114, label %if.end.122

land.lhs.true.114:                                ; preds = %lor.lhs.false.110
  %95 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings115 = getelementptr inbounds %struct.cop, %struct.cop* %95, i32 0, i32 14
  %96 = load %struct.sv*, %struct.sv** %cop_warnings115, align 8
  %sv_any116 = getelementptr inbounds %struct.sv, %struct.sv* %96, i32 0, i32 0
  %97 = load i8*, i8** %sv_any116, align 8
  %98 = bitcast i8* %97 to %struct.xpv*
  %xpv_pv117 = getelementptr inbounds %struct.xpv, %struct.xpv* %98, i32 0, i32 0
  %99 = load i8*, i8** %xpv_pv117, align 8
  %arrayidx = getelementptr inbounds i8, i8* %99, i64 8
  %100 = load i8, i8* %arrayidx, align 1
  %conv118 = sext i8 %100 to i32
  %and119 = and i32 %conv118, 64
  %tobool120 = icmp ne i32 %and119, 0
  br i1 %tobool120, label %if.then.121, label %if.end.122

if.then.121:                                      ; preds = %land.lhs.true.114, %lor.lhs.false, %land.lhs.true.104
  call void (i32, i8*, ...) @Perl_warner(i32 35, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.68, i32 0, i32 0))
  br label %if.end.122

if.end.122:                                       ; preds = %if.then.121, %land.lhs.true.114, %lor.lhs.false.110, %land.lhs.true.100, %if.then.92
  %101 = load %struct.gv*, %struct.gv** %gv, align 8
  %102 = bitcast %struct.gv* %101 to %struct.cv*
  %103 = load i8*, i8** %ps, align 8
  call void @Perl_cv_ckproto(%struct.cv* %102, %struct.gv* null, i8* %103)
  br label %if.end.123

if.end.123:                                       ; preds = %if.end.122, %if.then.87
  %104 = load i8*, i8** %ps, align 8
  %tobool124 = icmp ne i8* %104, null
  br i1 %tobool124, label %if.then.125, label %if.else.126

if.then.125:                                      ; preds = %if.end.123
  %105 = load %struct.gv*, %struct.gv** %gv, align 8
  %106 = bitcast %struct.gv* %105 to %struct.sv*
  %107 = load i8*, i8** %ps, align 8
  call void @Perl_sv_setpv(%struct.sv* %106, i8* %107)
  br label %if.end.127

if.else.126:                                      ; preds = %if.end.123
  %108 = load %struct.gv*, %struct.gv** %gv, align 8
  %109 = bitcast %struct.gv* %108 to %struct.sv*
  call void @Perl_sv_setiv(%struct.sv* %109, i64 -1)
  br label %if.end.127

if.end.127:                                       ; preds = %if.else.126, %if.then.125
  %110 = load %struct.cv*, %struct.cv** @PL_compcv, align 8
  %111 = bitcast %struct.cv* %110 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %111)
  store %struct.cv* null, %struct.cv** @PL_compcv, align 8
  store %struct.cv* null, %struct.cv** %cv, align 8
  %112 = load i32, i32* @PL_sub_generation, align 4
  %inc = add i32 %112, 1
  store i32 %inc, i32* @PL_sub_generation, align 4
  br label %done

if.end.128:                                       ; preds = %if.end.82
  %113 = load i8*, i8** %name, align 8
  %tobool129 = icmp ne i8* %113, null
  br i1 %tobool129, label %lor.lhs.false.130, label %cond.true.134

lor.lhs.false.130:                                ; preds = %if.end.128
  %114 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any131 = getelementptr inbounds %struct.gv, %struct.gv* %114, i32 0, i32 0
  %115 = load %struct.xpvgv*, %struct.xpvgv** %sv_any131, align 8
  %xgv_gp132 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %115, i32 0, i32 7
  %116 = load %struct.gp*, %struct.gp** %xgv_gp132, align 8
  %gp_cvgen = getelementptr inbounds %struct.gp, %struct.gp* %116, i32 0, i32 8
  %117 = load i32, i32* %gp_cvgen, align 4
  %tobool133 = icmp ne i32 %117, 0
  br i1 %tobool133, label %cond.true.134, label %cond.false.135

cond.true.134:                                    ; preds = %lor.lhs.false.130, %if.end.128
  br label %cond.end.138

cond.false.135:                                   ; preds = %lor.lhs.false.130
  %118 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any136 = getelementptr inbounds %struct.gv, %struct.gv* %118, i32 0, i32 0
  %119 = load %struct.xpvgv*, %struct.xpvgv** %sv_any136, align 8
  %xgv_gp137 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %119, i32 0, i32 7
  %120 = load %struct.gp*, %struct.gp** %xgv_gp137, align 8
  %gp_cv = getelementptr inbounds %struct.gp, %struct.gp* %120, i32 0, i32 7
  %121 = load %struct.cv*, %struct.cv** %gp_cv, align 8
  br label %cond.end.138

cond.end.138:                                     ; preds = %cond.false.135, %cond.true.134
  %cond139 = phi %struct.cv* [ null, %cond.true.134 ], [ %121, %cond.false.135 ]
  store %struct.cv* %cond139, %struct.cv** %cv, align 8
  %122 = load %struct.op*, %struct.op** %block.addr, align 8
  %tobool140 = icmp ne %struct.op* %122, null
  br i1 %tobool140, label %lor.lhs.false.141, label %if.then.148

lor.lhs.false.141:                                ; preds = %cond.end.138
  %123 = load i8*, i8** %ps, align 8
  %tobool142 = icmp ne i8* %123, null
  br i1 %tobool142, label %lor.lhs.false.143, label %if.then.148

lor.lhs.false.143:                                ; preds = %lor.lhs.false.141
  %124 = load i8*, i8** %ps, align 8
  %125 = load i8, i8* %124, align 1
  %conv144 = sext i8 %125 to i32
  %tobool145 = icmp ne i32 %conv144, 0
  br i1 %tobool145, label %if.then.148, label %lor.lhs.false.146

lor.lhs.false.146:                                ; preds = %lor.lhs.false.143
  %126 = load %struct.op*, %struct.op** %attrs.addr, align 8
  %tobool147 = icmp ne %struct.op* %126, null
  br i1 %tobool147, label %if.then.148, label %if.else.149

if.then.148:                                      ; preds = %lor.lhs.false.146, %lor.lhs.false.143, %lor.lhs.false.141, %cond.end.138
  store %struct.sv* null, %struct.sv** %const_sv, align 8
  br label %if.end.151

if.else.149:                                      ; preds = %lor.lhs.false.146
  %127 = load %struct.op*, %struct.op** %block.addr, align 8
  %call150 = call %struct.sv* @Perl_op_const_sv(%struct.op* %127, %struct.cv* null)
  store %struct.sv* %call150, %struct.sv** %const_sv, align 8
  br label %if.end.151

if.end.151:                                       ; preds = %if.else.149, %if.then.148
  %128 = load %struct.cv*, %struct.cv** %cv, align 8
  %tobool152 = icmp ne %struct.cv* %128, null
  br i1 %tobool152, label %if.then.153, label %if.end.261

if.then.153:                                      ; preds = %if.end.151
  %129 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any154 = getelementptr inbounds %struct.cv, %struct.cv* %129, i32 0, i32 0
  %130 = load %struct.xpvcv*, %struct.xpvcv** %sv_any154, align 8
  %xcv_root = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %130, i32 0, i32 9
  %131 = load %struct.op*, %struct.op** %xcv_root, align 8
  %tobool155 = icmp ne %struct.op* %131, null
  br i1 %tobool155, label %lor.end.159, label %lor.rhs.156

lor.rhs.156:                                      ; preds = %if.then.153
  %132 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any157 = getelementptr inbounds %struct.cv, %struct.cv* %132, i32 0, i32 0
  %133 = load %struct.xpvcv*, %struct.xpvcv** %sv_any157, align 8
  %xcv_xsub = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %133, i32 0, i32 10
  %134 = load void (%struct.cv*)*, void (%struct.cv*)** %xcv_xsub, align 8
  %tobool158 = icmp ne void (%struct.cv*)* %134, null
  br label %lor.end.159

lor.end.159:                                      ; preds = %lor.rhs.156, %if.then.153
  %135 = phi i1 [ true, %if.then.153 ], [ %tobool158, %lor.rhs.156 ]
  %lor.ext = zext i1 %135 to i32
  %conv160 = trunc i32 %lor.ext to i8
  store i8 %conv160, i8* %exists, align 1
  %136 = load i8, i8* %exists, align 1
  %conv161 = sext i8 %136 to i32
  %tobool162 = icmp ne i32 %conv161, 0
  br i1 %tobool162, label %if.then.167, label %lor.lhs.false.163

lor.lhs.false.163:                                ; preds = %lor.end.159
  %137 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_flags164 = getelementptr inbounds %struct.cv, %struct.cv* %137, i32 0, i32 2
  %138 = load i32, i32* %sv_flags164, align 4
  %and165 = and i32 %138, 262144
  %tobool166 = icmp ne i32 %and165, 0
  br i1 %tobool166, label %if.then.167, label %if.end.168

if.then.167:                                      ; preds = %lor.lhs.false.163, %lor.end.159
  %139 = load %struct.cv*, %struct.cv** %cv, align 8
  %140 = load %struct.gv*, %struct.gv** %gv, align 8
  %141 = load i8*, i8** %ps, align 8
  call void @Perl_cv_ckproto(%struct.cv* %139, %struct.gv* %140, i8* %141)
  br label %if.end.168

if.end.168:                                       ; preds = %if.then.167, %lor.lhs.false.163
  %142 = load i8, i8* %exists, align 1
  %conv169 = sext i8 %142 to i32
  %tobool170 = icmp ne i32 %conv169, 0
  br i1 %tobool170, label %if.then.176, label %lor.lhs.false.171

lor.lhs.false.171:                                ; preds = %if.end.168
  %143 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any172 = getelementptr inbounds %struct.gv, %struct.gv* %143, i32 0, i32 0
  %144 = load %struct.xpvgv*, %struct.xpvgv** %sv_any172, align 8
  %xgv_flags = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %144, i32 0, i32 11
  %145 = load i8, i8* %xgv_flags, align 1
  %conv173 = zext i8 %145 to i32
  %and174 = and i32 %conv173, 4
  %tobool175 = icmp ne i32 %and174, 0
  br i1 %tobool175, label %if.then.176, label %if.end.260

if.then.176:                                      ; preds = %lor.lhs.false.171, %if.end.168
  %146 = load %struct.op*, %struct.op** %block.addr, align 8
  %tobool177 = icmp ne %struct.op* %146, null
  br i1 %tobool177, label %if.end.194, label %land.lhs.true.178

land.lhs.true.178:                                ; preds = %if.then.176
  %147 = load %struct.op*, %struct.op** %attrs.addr, align 8
  %tobool179 = icmp ne %struct.op* %147, null
  br i1 %tobool179, label %if.end.194, label %if.then.180

if.then.180:                                      ; preds = %land.lhs.true.178
  %148 = load %struct.cv*, %struct.cv** @PL_compcv, align 8
  %sv_any181 = getelementptr inbounds %struct.cv, %struct.cv* %148, i32 0, i32 0
  %149 = load %struct.xpvcv*, %struct.xpvcv** %sv_any181, align 8
  %xcv_flags = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %149, i32 0, i32 17
  %150 = load i16, i16* %xcv_flags, align 2
  %tobool182 = icmp ne i16 %150, 0
  br i1 %tobool182, label %if.then.183, label %if.end.193

if.then.183:                                      ; preds = %if.then.180
  %151 = load %struct.cv*, %struct.cv** @PL_compcv, align 8
  %sv_any184 = getelementptr inbounds %struct.cv, %struct.cv* %151, i32 0, i32 0
  %152 = load %struct.xpvcv*, %struct.xpvcv** %sv_any184, align 8
  %xcv_flags185 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %152, i32 0, i32 17
  %153 = load i16, i16* %xcv_flags185, align 2
  %conv186 = zext i16 %153 to i32
  %and187 = and i32 %conv186, 448
  %154 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any188 = getelementptr inbounds %struct.cv, %struct.cv* %154, i32 0, i32 0
  %155 = load %struct.xpvcv*, %struct.xpvcv** %sv_any188, align 8
  %xcv_flags189 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %155, i32 0, i32 17
  %156 = load i16, i16* %xcv_flags189, align 2
  %conv190 = zext i16 %156 to i32
  %or191 = or i32 %conv190, %and187
  %conv192 = trunc i32 %or191 to i16
  store i16 %conv192, i16* %xcv_flags189, align 2
  br label %if.end.193

if.end.193:                                       ; preds = %if.then.183, %if.then.180
  %157 = load %struct.cv*, %struct.cv** @PL_compcv, align 8
  %158 = bitcast %struct.cv* %157 to %struct.sv*
  call void @Perl_save_freesv(%struct.sv* %158)
  br label %done

if.end.194:                                       ; preds = %land.lhs.true.178, %if.then.176
  %159 = load %struct.stackinfo*, %struct.stackinfo** @PL_curstackinfo, align 8
  %si_type = getelementptr inbounds %struct.stackinfo, %struct.stackinfo* %159, i32 0, i32 4
  %160 = load i32, i32* %si_type, align 4
  %cmp195 = icmp eq i32 %160, 3
  br i1 %cmp195, label %land.lhs.true.197, label %if.end.202

land.lhs.true.197:                                ; preds = %if.end.194
  %161 = load %struct.op*, %struct.op** @PL_sortcop, align 8
  %162 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any198 = getelementptr inbounds %struct.cv, %struct.cv* %162, i32 0, i32 0
  %163 = load %struct.xpvcv*, %struct.xpvcv** %sv_any198, align 8
  %xcv_start = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %163, i32 0, i32 8
  %164 = load %struct.op*, %struct.op** %xcv_start, align 8
  %cmp199 = icmp eq %struct.op* %161, %164
  br i1 %cmp199, label %if.then.201, label %if.end.202

if.then.201:                                      ; preds = %land.lhs.true.197
  %165 = load i8*, i8** %name, align 8
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.69, i32 0, i32 0), i8* %165)
  br label %if.end.202

if.end.202:                                       ; preds = %if.then.201, %land.lhs.true.197, %if.end.194
  %166 = load %struct.op*, %struct.op** %block.addr, align 8
  %tobool203 = icmp ne %struct.op* %166, null
  br i1 %tobool203, label %if.then.204, label %if.end.259

if.then.204:                                      ; preds = %if.end.202
  %167 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings205 = getelementptr inbounds %struct.cop, %struct.cop* %167, i32 0, i32 14
  %168 = load %struct.sv*, %struct.sv** %cop_warnings205, align 8
  %cmp206 = icmp ne %struct.sv* %168, null
  br i1 %cmp206, label %land.lhs.true.208, label %lor.lhs.false.224

land.lhs.true.208:                                ; preds = %if.then.204
  %169 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings209 = getelementptr inbounds %struct.cop, %struct.cop* %169, i32 0, i32 14
  %170 = load %struct.sv*, %struct.sv** %cop_warnings209, align 8
  %cmp210 = icmp ne %struct.sv* %170, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 2)
  br i1 %cmp210, label %land.lhs.true.212, label %lor.lhs.false.224

land.lhs.true.212:                                ; preds = %land.lhs.true.208
  %171 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings213 = getelementptr inbounds %struct.cop, %struct.cop* %171, i32 0, i32 14
  %172 = load %struct.sv*, %struct.sv** %cop_warnings213, align 8
  %cmp214 = icmp eq %struct.sv* %172, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 1)
  br i1 %cmp214, label %if.then.244, label %lor.lhs.false.216

lor.lhs.false.216:                                ; preds = %land.lhs.true.212
  %173 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings217 = getelementptr inbounds %struct.cop, %struct.cop* %173, i32 0, i32 14
  %174 = load %struct.sv*, %struct.sv** %cop_warnings217, align 8
  %sv_any218 = getelementptr inbounds %struct.sv, %struct.sv* %174, i32 0, i32 0
  %175 = load i8*, i8** %sv_any218, align 8
  %176 = bitcast i8* %175 to %struct.xpv*
  %xpv_pv219 = getelementptr inbounds %struct.xpv, %struct.xpv* %176, i32 0, i32 0
  %177 = load i8*, i8** %xpv_pv219, align 8
  %arrayidx220 = getelementptr inbounds i8, i8* %177, i64 4
  %178 = load i8, i8* %arrayidx220, align 1
  %conv221 = sext i8 %178 to i32
  %and222 = and i32 %conv221, 64
  %tobool223 = icmp ne i32 %and222, 0
  br i1 %tobool223, label %if.then.244, label %lor.lhs.false.224

lor.lhs.false.224:                                ; preds = %lor.lhs.false.216, %land.lhs.true.208, %if.then.204
  %179 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings225 = getelementptr inbounds %struct.cop, %struct.cop* %179, i32 0, i32 14
  %180 = load %struct.sv*, %struct.sv** %cop_warnings225, align 8
  %cmp226 = icmp eq %struct.sv* %180, null
  br i1 %cmp226, label %land.lhs.true.228, label %lor.lhs.false.232

land.lhs.true.228:                                ; preds = %lor.lhs.false.224
  %181 = load i8, i8* @PL_dowarn, align 1
  %conv229 = zext i8 %181 to i32
  %and230 = and i32 %conv229, 1
  %tobool231 = icmp ne i32 %and230, 0
  br i1 %tobool231, label %if.then.244, label %lor.lhs.false.232

lor.lhs.false.232:                                ; preds = %land.lhs.true.228, %lor.lhs.false.224
  %182 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any233 = getelementptr inbounds %struct.cv, %struct.cv* %182, i32 0, i32 0
  %183 = load %struct.xpvcv*, %struct.xpvcv** %sv_any233, align 8
  %xcv_flags234 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %183, i32 0, i32 17
  %184 = load i16, i16* %xcv_flags234, align 2
  %conv235 = zext i16 %184 to i32
  %and236 = and i32 %conv235, 512
  %tobool237 = icmp ne i32 %and236, 0
  br i1 %tobool237, label %land.lhs.true.238, label %if.end.258

land.lhs.true.238:                                ; preds = %lor.lhs.false.232
  %185 = load %struct.sv*, %struct.sv** %const_sv, align 8
  %tobool239 = icmp ne %struct.sv* %185, null
  br i1 %tobool239, label %lor.lhs.false.240, label %if.then.244

lor.lhs.false.240:                                ; preds = %land.lhs.true.238
  %186 = load %struct.cv*, %struct.cv** %cv, align 8
  %call241 = call %struct.sv* @Perl_cv_const_sv(%struct.cv* %186)
  %187 = load %struct.sv*, %struct.sv** %const_sv, align 8
  %call242 = call i32 @Perl_sv_cmp(%struct.sv* %call241, %struct.sv* %187)
  %tobool243 = icmp ne i32 %call242, 0
  br i1 %tobool243, label %if.then.244, label %if.end.258

if.then.244:                                      ; preds = %lor.lhs.false.240, %land.lhs.true.238, %land.lhs.true.228, %lor.lhs.false.216, %land.lhs.true.212
  %188 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_line245 = getelementptr inbounds %struct.cop, %struct.cop* %188, i32 0, i32 13
  %189 = load i32, i32* %cop_line245, align 4
  store i32 %189, i32* %oldline, align 4
  %190 = load i32, i32* @PL_copline, align 4
  %cmp246 = icmp ne i32 %190, -1
  br i1 %cmp246, label %if.then.248, label %if.end.250

if.then.248:                                      ; preds = %if.then.244
  %191 = load i32, i32* @PL_copline, align 4
  %192 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_line249 = getelementptr inbounds %struct.cop, %struct.cop* %192, i32 0, i32 13
  store i32 %191, i32* %cop_line249, align 4
  br label %if.end.250

if.end.250:                                       ; preds = %if.then.248, %if.then.244
  %193 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any251 = getelementptr inbounds %struct.cv, %struct.cv* %193, i32 0, i32 0
  %194 = load %struct.xpvcv*, %struct.xpvcv** %sv_any251, align 8
  %xcv_flags252 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %194, i32 0, i32 17
  %195 = load i16, i16* %xcv_flags252, align 2
  %conv253 = zext i16 %195 to i32
  %and254 = and i32 %conv253, 512
  %tobool255 = icmp ne i32 %and254, 0
  %cond256 = select i1 %tobool255, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.70, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.71, i32 0, i32 0)
  %196 = load i8*, i8** %name, align 8
  call void (i32, i8*, ...) @Perl_warner(i32 19, i8* %cond256, i8* %196)
  %197 = load i32, i32* %oldline, align 4
  %198 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_line257 = getelementptr inbounds %struct.cop, %struct.cop* %198, i32 0, i32 13
  store i32 %197, i32* %cop_line257, align 4
  br label %if.end.258

if.end.258:                                       ; preds = %if.end.250, %lor.lhs.false.240, %lor.lhs.false.232
  %199 = load %struct.cv*, %struct.cv** %cv, align 8
  %200 = bitcast %struct.cv* %199 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %200)
  store %struct.cv* null, %struct.cv** %cv, align 8
  br label %if.end.259

if.end.259:                                       ; preds = %if.end.258, %if.end.202
  br label %if.end.260

if.end.260:                                       ; preds = %if.end.259, %lor.lhs.false.171
  br label %if.end.261

if.end.261:                                       ; preds = %if.end.260, %if.end.151
  %201 = load %struct.sv*, %struct.sv** %const_sv, align 8
  %tobool262 = icmp ne %struct.sv* %201, null
  br i1 %tobool262, label %if.then.263, label %if.end.284

if.then.263:                                      ; preds = %if.end.261
  %202 = load %struct.sv*, %struct.sv** %const_sv, align 8
  store %struct.sv* %202, %struct.sv** @PL_Sv, align 8
  %203 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %tobool264 = icmp ne %struct.sv* %203, null
  br i1 %tobool264, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then.263
  %204 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_refcnt = getelementptr inbounds %struct.sv, %struct.sv* %204, i32 0, i32 1
  %205 = load i32, i32* %sv_refcnt, align 4
  %inc265 = add i32 %205, 1
  store i32 %inc265, i32* %sv_refcnt, align 4
  %tobool266 = icmp ne i32 %inc265, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then.263
  %206 = phi i1 [ false, %if.then.263 ], [ %tobool266, %land.rhs ]
  %land.ext = zext i1 %206 to i32
  %207 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %208 = load %struct.cv*, %struct.cv** %cv, align 8
  %tobool267 = icmp ne %struct.cv* %208, null
  br i1 %tobool267, label %if.then.268, label %if.else.277

if.then.268:                                      ; preds = %land.end
  %209 = load %struct.cv*, %struct.cv** %cv, align 8
  %210 = bitcast %struct.cv* %209 to %struct.sv*
  call void @Perl_sv_setpv(%struct.sv* %210, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.35, i32 0, i32 0))
  %211 = load %struct.sv*, %struct.sv** %const_sv, align 8
  %212 = bitcast %struct.sv* %211 to i8*
  %213 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any269 = getelementptr inbounds %struct.cv, %struct.cv* %213, i32 0, i32 0
  %214 = load %struct.xpvcv*, %struct.xpvcv** %sv_any269, align 8
  %xcv_xsubany = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %214, i32 0, i32 11
  %any_ptr = bitcast %union.any* %xcv_xsubany to i8**
  store i8* %212, i8** %any_ptr, align 8
  %215 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any270 = getelementptr inbounds %struct.cv, %struct.cv* %215, i32 0, i32 0
  %216 = load %struct.xpvcv*, %struct.xpvcv** %sv_any270, align 8
  %xcv_xsub271 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %216, i32 0, i32 10
  store void (%struct.cv*)* @const_sv_xsub, void (%struct.cv*)** %xcv_xsub271, align 8
  %217 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any272 = getelementptr inbounds %struct.cv, %struct.cv* %217, i32 0, i32 0
  %218 = load %struct.xpvcv*, %struct.xpvcv** %sv_any272, align 8
  %xcv_flags273 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %218, i32 0, i32 17
  %219 = load i16, i16* %xcv_flags273, align 2
  %conv274 = zext i16 %219 to i32
  %or275 = or i32 %conv274, 512
  %conv276 = trunc i32 %or275 to i16
  store i16 %conv276, i16* %xcv_flags273, align 2
  br label %if.end.282

if.else.277:                                      ; preds = %land.end
  %220 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any278 = getelementptr inbounds %struct.gv, %struct.gv* %220, i32 0, i32 0
  %221 = load %struct.xpvgv*, %struct.xpvgv** %sv_any278, align 8
  %xgv_gp279 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %221, i32 0, i32 7
  %222 = load %struct.gp*, %struct.gp** %xgv_gp279, align 8
  %gp_cv280 = getelementptr inbounds %struct.gp, %struct.gp* %222, i32 0, i32 7
  store %struct.cv* null, %struct.cv** %gp_cv280, align 8
  %223 = load i8*, i8** %name, align 8
  %224 = load %struct.sv*, %struct.sv** %const_sv, align 8
  %call281 = call %struct.cv* @Perl_newCONSTSUB(%struct.hv* null, i8* %223, %struct.sv* %224)
  store %struct.cv* %call281, %struct.cv** %cv, align 8
  br label %if.end.282

if.end.282:                                       ; preds = %if.else.277, %if.then.268
  %225 = load %struct.op*, %struct.op** %block.addr, align 8
  call void @Perl_op_free(%struct.op* %225)
  %226 = load %struct.cv*, %struct.cv** @PL_compcv, align 8
  %227 = bitcast %struct.cv* %226 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %227)
  store %struct.cv* null, %struct.cv** @PL_compcv, align 8
  %228 = load i32, i32* @PL_sub_generation, align 4
  %inc283 = add i32 %228, 1
  store i32 %inc283, i32* @PL_sub_generation, align 4
  br label %done

if.end.284:                                       ; preds = %if.end.261
  %229 = load %struct.op*, %struct.op** %attrs.addr, align 8
  %tobool285 = icmp ne %struct.op* %229, null
  br i1 %tobool285, label %if.then.286, label %if.end.333

if.then.286:                                      ; preds = %if.end.284
  %230 = load %struct.cv*, %struct.cv** %cv, align 8
  %tobool287 = icmp ne %struct.cv* %230, null
  br i1 %tobool287, label %land.lhs.true.288, label %if.else.321

land.lhs.true.288:                                ; preds = %if.then.286
  %231 = load %struct.op*, %struct.op** %block.addr, align 8
  %tobool289 = icmp ne %struct.op* %231, null
  br i1 %tobool289, label %if.else.321, label %if.then.290

if.then.290:                                      ; preds = %land.lhs.true.288
  %232 = load %struct.cv*, %struct.cv** %cv, align 8
  %233 = bitcast %struct.cv* %232 to %struct.sv*
  store %struct.sv* %233, %struct.sv** %rcv, align 8
  %234 = load %struct.cv*, %struct.cv** @PL_compcv, align 8
  %sv_any291 = getelementptr inbounds %struct.cv, %struct.cv* %234, i32 0, i32 0
  %235 = load %struct.xpvcv*, %struct.xpvcv** %sv_any291, align 8
  %xcv_flags292 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %235, i32 0, i32 17
  %236 = load i16, i16* %xcv_flags292, align 2
  %conv293 = zext i16 %236 to i32
  %and294 = and i32 %conv293, 448
  %237 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any295 = getelementptr inbounds %struct.cv, %struct.cv* %237, i32 0, i32 0
  %238 = load %struct.xpvcv*, %struct.xpvcv** %sv_any295, align 8
  %xcv_flags296 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %238, i32 0, i32 17
  %239 = load i16, i16* %xcv_flags296, align 2
  %conv297 = zext i16 %239 to i32
  %or298 = or i32 %conv297, %and294
  %conv299 = trunc i32 %or298 to i16
  store i16 %conv299, i16* %xcv_flags296, align 2
  %240 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any300 = getelementptr inbounds %struct.cv, %struct.cv* %240, i32 0, i32 0
  %241 = load %struct.xpvcv*, %struct.xpvcv** %sv_any300, align 8
  %xcv_gv = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %241, i32 0, i32 12
  %242 = load %struct.gv*, %struct.gv** %xcv_gv, align 8
  %tobool301 = icmp ne %struct.gv* %242, null
  br i1 %tobool301, label %land.lhs.true.302, label %if.else.312

land.lhs.true.302:                                ; preds = %if.then.290
  %243 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any303 = getelementptr inbounds %struct.cv, %struct.cv* %243, i32 0, i32 0
  %244 = load %struct.xpvcv*, %struct.xpvcv** %sv_any303, align 8
  %xcv_gv304 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %244, i32 0, i32 12
  %245 = load %struct.gv*, %struct.gv** %xcv_gv304, align 8
  %sv_any305 = getelementptr inbounds %struct.gv, %struct.gv* %245, i32 0, i32 0
  %246 = load %struct.xpvgv*, %struct.xpvgv** %sv_any305, align 8
  %xgv_stash = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %246, i32 0, i32 10
  %247 = load %struct.hv*, %struct.hv** %xgv_stash, align 8
  %tobool306 = icmp ne %struct.hv* %247, null
  br i1 %tobool306, label %if.then.307, label %if.else.312

if.then.307:                                      ; preds = %land.lhs.true.302
  %248 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any308 = getelementptr inbounds %struct.cv, %struct.cv* %248, i32 0, i32 0
  %249 = load %struct.xpvcv*, %struct.xpvcv** %sv_any308, align 8
  %xcv_gv309 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %249, i32 0, i32 12
  %250 = load %struct.gv*, %struct.gv** %xcv_gv309, align 8
  %sv_any310 = getelementptr inbounds %struct.gv, %struct.gv* %250, i32 0, i32 0
  %251 = load %struct.xpvgv*, %struct.xpvgv** %sv_any310, align 8
  %xgv_stash311 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %251, i32 0, i32 10
  %252 = load %struct.hv*, %struct.hv** %xgv_stash311, align 8
  store %struct.hv* %252, %struct.hv** %stash, align 8
  br label %if.end.320

if.else.312:                                      ; preds = %land.lhs.true.302, %if.then.290
  %253 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any313 = getelementptr inbounds %struct.cv, %struct.cv* %253, i32 0, i32 0
  %254 = load %struct.xpvcv*, %struct.xpvcv** %sv_any313, align 8
  %xcv_stash = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %254, i32 0, i32 7
  %255 = load %struct.hv*, %struct.hv** %xcv_stash, align 8
  %tobool314 = icmp ne %struct.hv* %255, null
  br i1 %tobool314, label %if.then.315, label %if.else.318

if.then.315:                                      ; preds = %if.else.312
  %256 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any316 = getelementptr inbounds %struct.cv, %struct.cv* %256, i32 0, i32 0
  %257 = load %struct.xpvcv*, %struct.xpvcv** %sv_any316, align 8
  %xcv_stash317 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %257, i32 0, i32 7
  %258 = load %struct.hv*, %struct.hv** %xcv_stash317, align 8
  store %struct.hv* %258, %struct.hv** %stash, align 8
  br label %if.end.319

if.else.318:                                      ; preds = %if.else.312
  %259 = load %struct.hv*, %struct.hv** @PL_curstash, align 8
  store %struct.hv* %259, %struct.hv** %stash, align 8
  br label %if.end.319

if.end.319:                                       ; preds = %if.else.318, %if.then.315
  br label %if.end.320

if.end.320:                                       ; preds = %if.end.319, %if.then.307
  br label %if.end.332

if.else.321:                                      ; preds = %land.lhs.true.288, %if.then.286
  %260 = load %struct.cv*, %struct.cv** @PL_compcv, align 8
  %261 = bitcast %struct.cv* %260 to %struct.sv*
  store %struct.sv* %261, %struct.sv** %rcv, align 8
  %262 = load i8*, i8** %name, align 8
  %tobool322 = icmp ne i8* %262, null
  br i1 %tobool322, label %land.lhs.true.323, label %if.else.330

land.lhs.true.323:                                ; preds = %if.else.321
  %263 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any324 = getelementptr inbounds %struct.gv, %struct.gv* %263, i32 0, i32 0
  %264 = load %struct.xpvgv*, %struct.xpvgv** %sv_any324, align 8
  %xgv_stash325 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %264, i32 0, i32 10
  %265 = load %struct.hv*, %struct.hv** %xgv_stash325, align 8
  %tobool326 = icmp ne %struct.hv* %265, null
  br i1 %tobool326, label %if.then.327, label %if.else.330

if.then.327:                                      ; preds = %land.lhs.true.323
  %266 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any328 = getelementptr inbounds %struct.gv, %struct.gv* %266, i32 0, i32 0
  %267 = load %struct.xpvgv*, %struct.xpvgv** %sv_any328, align 8
  %xgv_stash329 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %267, i32 0, i32 10
  %268 = load %struct.hv*, %struct.hv** %xgv_stash329, align 8
  store %struct.hv* %268, %struct.hv** %stash, align 8
  br label %if.end.331

if.else.330:                                      ; preds = %land.lhs.true.323, %if.else.321
  %269 = load %struct.hv*, %struct.hv** @PL_curstash, align 8
  store %struct.hv* %269, %struct.hv** %stash, align 8
  br label %if.end.331

if.end.331:                                       ; preds = %if.else.330, %if.then.327
  br label %if.end.332

if.end.332:                                       ; preds = %if.end.331, %if.end.320
  %270 = load %struct.hv*, %struct.hv** %stash, align 8
  %271 = load %struct.sv*, %struct.sv** %rcv, align 8
  %272 = load %struct.op*, %struct.op** %attrs.addr, align 8
  call void @S_apply_attrs(%struct.hv* %270, %struct.sv* %271, %struct.op* %272, i8 signext 0)
  br label %if.end.333

if.end.333:                                       ; preds = %if.end.332, %if.end.284
  %273 = load %struct.cv*, %struct.cv** %cv, align 8
  %tobool334 = icmp ne %struct.cv* %273, null
  br i1 %tobool334, label %if.then.335, label %if.else.374

if.then.335:                                      ; preds = %if.end.333
  %274 = load %struct.op*, %struct.op** %block.addr, align 8
  %tobool336 = icmp ne %struct.op* %274, null
  br i1 %tobool336, label %if.end.338, label %if.then.337

if.then.337:                                      ; preds = %if.then.335
  %275 = load %struct.cv*, %struct.cv** @PL_compcv, align 8
  %276 = bitcast %struct.cv* %275 to %struct.sv*
  call void @Perl_save_freesv(%struct.sv* %276)
  br label %done

if.end.338:                                       ; preds = %if.then.335
  %277 = load %struct.cv*, %struct.cv** %cv, align 8
  call void @Perl_cv_undef(%struct.cv* %277)
  %278 = load %struct.cv*, %struct.cv** @PL_compcv, align 8
  %sv_any339 = getelementptr inbounds %struct.cv, %struct.cv* %278, i32 0, i32 0
  %279 = load %struct.xpvcv*, %struct.xpvcv** %sv_any339, align 8
  %xcv_flags340 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %279, i32 0, i32 17
  %280 = load i16, i16* %xcv_flags340, align 2
  %281 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any341 = getelementptr inbounds %struct.cv, %struct.cv* %281, i32 0, i32 0
  %282 = load %struct.xpvcv*, %struct.xpvcv** %sv_any341, align 8
  %xcv_flags342 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %282, i32 0, i32 17
  store i16 %280, i16* %xcv_flags342, align 2
  %283 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any343 = getelementptr inbounds %struct.cv, %struct.cv* %283, i32 0, i32 0
  %284 = load %struct.xpvcv*, %struct.xpvcv** %sv_any343, align 8
  %xcv_flags344 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %284, i32 0, i32 17
  %285 = load i16, i16* %xcv_flags344, align 2
  %conv345 = zext i16 %285 to i32
  %and346 = and i32 %conv345, 1024
  %tobool347 = icmp ne i32 %and346, 0
  br i1 %tobool347, label %if.end.350, label %if.then.348

if.then.348:                                      ; preds = %if.end.338
  %286 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any349 = getelementptr inbounds %struct.cv, %struct.cv* %286, i32 0, i32 0
  %287 = load %struct.xpvcv*, %struct.xpvcv** %sv_any349, align 8
  %xcv_outside = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %287, i32 0, i32 16
  %288 = load %struct.cv*, %struct.cv** %xcv_outside, align 8
  %289 = bitcast %struct.cv* %288 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %289)
  br label %if.end.350

if.end.350:                                       ; preds = %if.then.348, %if.end.338
  %290 = load %struct.cv*, %struct.cv** @PL_compcv, align 8
  %sv_any351 = getelementptr inbounds %struct.cv, %struct.cv* %290, i32 0, i32 0
  %291 = load %struct.xpvcv*, %struct.xpvcv** %sv_any351, align 8
  %xcv_outside352 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %291, i32 0, i32 16
  %292 = load %struct.cv*, %struct.cv** %xcv_outside352, align 8
  %293 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any353 = getelementptr inbounds %struct.cv, %struct.cv* %293, i32 0, i32 0
  %294 = load %struct.xpvcv*, %struct.xpvcv** %sv_any353, align 8
  %xcv_outside354 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %294, i32 0, i32 16
  store %struct.cv* %292, %struct.cv** %xcv_outside354, align 8
  %295 = load %struct.cv*, %struct.cv** @PL_compcv, align 8
  %sv_any355 = getelementptr inbounds %struct.cv, %struct.cv* %295, i32 0, i32 0
  %296 = load %struct.xpvcv*, %struct.xpvcv** %sv_any355, align 8
  %xcv_outside_seq = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %296, i32 0, i32 18
  %297 = load i32, i32* %xcv_outside_seq, align 4
  %298 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any356 = getelementptr inbounds %struct.cv, %struct.cv* %298, i32 0, i32 0
  %299 = load %struct.xpvcv*, %struct.xpvcv** %sv_any356, align 8
  %xcv_outside_seq357 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %299, i32 0, i32 18
  store i32 %297, i32* %xcv_outside_seq357, align 4
  %300 = load %struct.cv*, %struct.cv** @PL_compcv, align 8
  %sv_any358 = getelementptr inbounds %struct.cv, %struct.cv* %300, i32 0, i32 0
  %301 = load %struct.xpvcv*, %struct.xpvcv** %sv_any358, align 8
  %xcv_outside359 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %301, i32 0, i32 16
  store %struct.cv* null, %struct.cv** %xcv_outside359, align 8
  %302 = load %struct.cv*, %struct.cv** @PL_compcv, align 8
  %sv_any360 = getelementptr inbounds %struct.cv, %struct.cv* %302, i32 0, i32 0
  %303 = load %struct.xpvcv*, %struct.xpvcv** %sv_any360, align 8
  %xcv_padlist = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %303, i32 0, i32 15
  %304 = load %struct.av*, %struct.av** %xcv_padlist, align 8
  %305 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any361 = getelementptr inbounds %struct.cv, %struct.cv* %305, i32 0, i32 0
  %306 = load %struct.xpvcv*, %struct.xpvcv** %sv_any361, align 8
  %xcv_padlist362 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %306, i32 0, i32 15
  store %struct.av* %304, %struct.av** %xcv_padlist362, align 8
  %307 = load %struct.cv*, %struct.cv** @PL_compcv, align 8
  %sv_any363 = getelementptr inbounds %struct.cv, %struct.cv* %307, i32 0, i32 0
  %308 = load %struct.xpvcv*, %struct.xpvcv** %sv_any363, align 8
  %xcv_padlist364 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %308, i32 0, i32 15
  store %struct.av* null, %struct.av** %xcv_padlist364, align 8
  %309 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any365 = getelementptr inbounds %struct.cv, %struct.cv* %309, i32 0, i32 0
  %310 = load %struct.xpvcv*, %struct.xpvcv** %sv_any365, align 8
  %xcv_padlist366 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %310, i32 0, i32 15
  %311 = load %struct.av*, %struct.av** %xcv_padlist366, align 8
  %312 = load %struct.cv*, %struct.cv** @PL_compcv, align 8
  %313 = load %struct.cv*, %struct.cv** %cv, align 8
  call void @Perl_pad_fixup_inner_anons(%struct.av* %311, %struct.cv* %312, %struct.cv* %313)
  %314 = load %struct.cv*, %struct.cv** @PL_compcv, align 8
  %315 = bitcast %struct.cv* %314 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %315)
  %316 = load i32, i32* @PL_perldb, align 4
  %tobool367 = icmp ne i32 %316, 0
  br i1 %tobool367, label %land.lhs.true.368, label %if.end.373

land.lhs.true.368:                                ; preds = %if.end.350
  %317 = load i32, i32* @PL_perldb, align 4
  %and369 = and i32 %317, 8
  %tobool370 = icmp ne i32 %and369, 0
  br i1 %tobool370, label %if.then.371, label %if.end.373

if.then.371:                                      ; preds = %land.lhs.true.368
  %318 = load i32, i32* @PL_sub_generation, align 4
  %inc372 = add i32 %318, 1
  store i32 %inc372, i32* @PL_sub_generation, align 4
  br label %if.end.373

if.end.373:                                       ; preds = %if.then.371, %land.lhs.true.368, %if.end.350
  br label %if.end.385

if.else.374:                                      ; preds = %if.end.333
  %319 = load %struct.cv*, %struct.cv** @PL_compcv, align 8
  store %struct.cv* %319, %struct.cv** %cv, align 8
  %320 = load i8*, i8** %name, align 8
  %tobool375 = icmp ne i8* %320, null
  br i1 %tobool375, label %if.then.376, label %if.end.384

if.then.376:                                      ; preds = %if.else.374
  %321 = load %struct.cv*, %struct.cv** %cv, align 8
  %322 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any377 = getelementptr inbounds %struct.gv, %struct.gv* %322, i32 0, i32 0
  %323 = load %struct.xpvgv*, %struct.xpvgv** %sv_any377, align 8
  %xgv_gp378 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %323, i32 0, i32 7
  %324 = load %struct.gp*, %struct.gp** %xgv_gp378, align 8
  %gp_cv379 = getelementptr inbounds %struct.gp, %struct.gp* %324, i32 0, i32 7
  store %struct.cv* %321, %struct.cv** %gp_cv379, align 8
  %325 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any380 = getelementptr inbounds %struct.gv, %struct.gv* %325, i32 0, i32 0
  %326 = load %struct.xpvgv*, %struct.xpvgv** %sv_any380, align 8
  %xgv_gp381 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %326, i32 0, i32 7
  %327 = load %struct.gp*, %struct.gp** %xgv_gp381, align 8
  %gp_cvgen382 = getelementptr inbounds %struct.gp, %struct.gp* %327, i32 0, i32 8
  store i32 0, i32* %gp_cvgen382, align 4
  %328 = load i32, i32* @PL_sub_generation, align 4
  %inc383 = add i32 %328, 1
  store i32 %inc383, i32* @PL_sub_generation, align 4
  br label %if.end.384

if.end.384:                                       ; preds = %if.then.376, %if.else.374
  br label %if.end.385

if.end.385:                                       ; preds = %if.end.384, %if.end.373
  %329 = load %struct.gv*, %struct.gv** %gv, align 8
  %330 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any386 = getelementptr inbounds %struct.cv, %struct.cv* %330, i32 0, i32 0
  %331 = load %struct.xpvcv*, %struct.xpvcv** %sv_any386, align 8
  %xcv_gv387 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %331, i32 0, i32 12
  store %struct.gv* %329, %struct.gv** %xcv_gv387, align 8
  %332 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_filegv388 = getelementptr inbounds %struct.cop, %struct.cop* %332, i32 0, i32 10
  %333 = load %struct.gv*, %struct.gv** %cop_filegv388, align 8
  %tobool389 = icmp ne %struct.gv* %333, null
  br i1 %tobool389, label %cond.true.390, label %cond.false.396

cond.true.390:                                    ; preds = %if.end.385
  %334 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_filegv391 = getelementptr inbounds %struct.cop, %struct.cop* %334, i32 0, i32 10
  %335 = load %struct.gv*, %struct.gv** %cop_filegv391, align 8
  %sv_any392 = getelementptr inbounds %struct.gv, %struct.gv* %335, i32 0, i32 0
  %336 = load %struct.xpvgv*, %struct.xpvgv** %sv_any392, align 8
  %xgv_gp393 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %336, i32 0, i32 7
  %337 = load %struct.gp*, %struct.gp** %xgv_gp393, align 8
  %gp_sv394 = getelementptr inbounds %struct.gp, %struct.gp* %337, i32 0, i32 0
  %338 = load %struct.sv*, %struct.sv** %gp_sv394, align 8
  %tobool395 = icmp ne %struct.sv* %338, null
  br i1 %tobool395, label %cond.true.397, label %cond.false.410

cond.false.396:                                   ; preds = %if.end.385
  br i1 false, label %cond.true.397, label %cond.false.410

cond.true.397:                                    ; preds = %cond.false.396, %cond.true.390
  %339 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_filegv398 = getelementptr inbounds %struct.cop, %struct.cop* %339, i32 0, i32 10
  %340 = load %struct.gv*, %struct.gv** %cop_filegv398, align 8
  %tobool399 = icmp ne %struct.gv* %340, null
  br i1 %tobool399, label %cond.true.400, label %cond.false.405

cond.true.400:                                    ; preds = %cond.true.397
  %341 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_filegv401 = getelementptr inbounds %struct.cop, %struct.cop* %341, i32 0, i32 10
  %342 = load %struct.gv*, %struct.gv** %cop_filegv401, align 8
  %sv_any402 = getelementptr inbounds %struct.gv, %struct.gv* %342, i32 0, i32 0
  %343 = load %struct.xpvgv*, %struct.xpvgv** %sv_any402, align 8
  %xgv_gp403 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %343, i32 0, i32 7
  %344 = load %struct.gp*, %struct.gp** %xgv_gp403, align 8
  %gp_sv404 = getelementptr inbounds %struct.gp, %struct.gp* %344, i32 0, i32 0
  %345 = load %struct.sv*, %struct.sv** %gp_sv404, align 8
  br label %cond.end.406

cond.false.405:                                   ; preds = %cond.true.397
  br label %cond.end.406

cond.end.406:                                     ; preds = %cond.false.405, %cond.true.400
  %cond407 = phi %struct.sv* [ %345, %cond.true.400 ], [ null, %cond.false.405 ]
  %sv_any408 = getelementptr inbounds %struct.sv, %struct.sv* %cond407, i32 0, i32 0
  %346 = load i8*, i8** %sv_any408, align 8
  %347 = bitcast i8* %346 to %struct.xpv*
  %xpv_pv409 = getelementptr inbounds %struct.xpv, %struct.xpv* %347, i32 0, i32 0
  %348 = load i8*, i8** %xpv_pv409, align 8
  br label %cond.end.411

cond.false.410:                                   ; preds = %cond.false.396, %cond.true.390
  br label %cond.end.411

cond.end.411:                                     ; preds = %cond.false.410, %cond.end.406
  %cond412 = phi i8* [ %348, %cond.end.406 ], [ null, %cond.false.410 ]
  %349 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any413 = getelementptr inbounds %struct.cv, %struct.cv* %349, i32 0, i32 0
  %350 = load %struct.xpvcv*, %struct.xpvcv** %sv_any413, align 8
  %xcv_file = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %350, i32 0, i32 13
  store i8* %cond412, i8** %xcv_file, align 8
  %351 = load %struct.hv*, %struct.hv** @PL_curstash, align 8
  %352 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any414 = getelementptr inbounds %struct.cv, %struct.cv* %352, i32 0, i32 0
  %353 = load %struct.xpvcv*, %struct.xpvcv** %sv_any414, align 8
  %xcv_stash415 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %353, i32 0, i32 7
  store %struct.hv* %351, %struct.hv** %xcv_stash415, align 8
  %354 = load i8*, i8** %ps, align 8
  %tobool416 = icmp ne i8* %354, null
  br i1 %tobool416, label %if.then.417, label %if.end.418

if.then.417:                                      ; preds = %cond.end.411
  %355 = load %struct.cv*, %struct.cv** %cv, align 8
  %356 = bitcast %struct.cv* %355 to %struct.sv*
  %357 = load i8*, i8** %ps, align 8
  call void @Perl_sv_setpv(%struct.sv* %356, i8* %357)
  br label %if.end.418

if.end.418:                                       ; preds = %if.then.417, %cond.end.411
  %358 = load i32, i32* @PL_error_count, align 4
  %tobool419 = icmp ne i32 %358, 0
  br i1 %tobool419, label %if.then.420, label %if.end.445

if.then.420:                                      ; preds = %if.end.418
  %359 = load %struct.op*, %struct.op** %block.addr, align 8
  call void @Perl_op_free(%struct.op* %359)
  store %struct.op* null, %struct.op** %block.addr, align 8
  %360 = load i8*, i8** %name, align 8
  %tobool421 = icmp ne i8* %360, null
  br i1 %tobool421, label %if.then.422, label %if.end.444

if.then.422:                                      ; preds = %if.then.420
  %361 = load i8*, i8** %name, align 8
  %call423 = call i8* @strrchr(i8* %361, i32 58)
  store i8* %call423, i8** %s, align 8
  %362 = load i8*, i8** %s, align 8
  %tobool424 = icmp ne i8* %362, null
  br i1 %tobool424, label %cond.true.425, label %cond.false.426

cond.true.425:                                    ; preds = %if.then.422
  %363 = load i8*, i8** %s, align 8
  %add.ptr = getelementptr inbounds i8, i8* %363, i64 1
  br label %cond.end.427

cond.false.426:                                   ; preds = %if.then.422
  %364 = load i8*, i8** %name, align 8
  br label %cond.end.427

cond.end.427:                                     ; preds = %cond.false.426, %cond.true.425
  %cond428 = phi i8* [ %add.ptr, %cond.true.425 ], [ %364, %cond.false.426 ]
  store i8* %cond428, i8** %s, align 8
  %365 = load i8*, i8** %s, align 8
  %call429 = call i32 @strcmp(i8* %365, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.51, i32 0, i32 0))
  %tobool430 = icmp ne i32 %call429, 0
  br i1 %tobool430, label %if.end.443, label %if.then.431

if.then.431:                                      ; preds = %cond.end.427
  store i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.72, i32 0, i32 0), i8** %not_safe, align 8
  %366 = load volatile i32, i32* @PL_in_eval, align 4
  %and432 = and i32 %366, 4
  %tobool433 = icmp ne i32 %and432, 0
  br i1 %tobool433, label %if.then.434, label %if.else.435

if.then.434:                                      ; preds = %if.then.431
  %367 = load i8*, i8** %not_safe, align 8
  call void (i8*, ...) @Perl_croak(i8* %367)
  br label %if.end.442

if.else.435:                                      ; preds = %if.then.431
  %368 = load %struct.gv*, %struct.gv** @PL_errgv, align 8
  %sv_any436 = getelementptr inbounds %struct.gv, %struct.gv* %368, i32 0, i32 0
  %369 = load %struct.xpvgv*, %struct.xpvgv** %sv_any436, align 8
  %xgv_gp437 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %369, i32 0, i32 7
  %370 = load %struct.gp*, %struct.gp** %xgv_gp437, align 8
  %gp_sv438 = getelementptr inbounds %struct.gp, %struct.gp* %370, i32 0, i32 0
  %371 = load %struct.sv*, %struct.sv** %gp_sv438, align 8
  %372 = load i8*, i8** %not_safe, align 8
  call void @Perl_sv_catpv(%struct.sv* %371, i8* %372)
  %373 = load %struct.gv*, %struct.gv** @PL_errgv, align 8
  %sv_any439 = getelementptr inbounds %struct.gv, %struct.gv* %373, i32 0, i32 0
  %374 = load %struct.xpvgv*, %struct.xpvgv** %sv_any439, align 8
  %xgv_gp440 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %374, i32 0, i32 7
  %375 = load %struct.gp*, %struct.gp** %xgv_gp440, align 8
  %gp_sv441 = getelementptr inbounds %struct.gp, %struct.gp* %375, i32 0, i32 0
  %376 = load %struct.sv*, %struct.sv** %gp_sv441, align 8
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.63, i32 0, i32 0), %struct.sv* %376)
  br label %if.end.442

if.end.442:                                       ; preds = %if.else.435, %if.then.434
  br label %if.end.443

if.end.443:                                       ; preds = %if.end.442, %cond.end.427
  br label %if.end.444

if.end.444:                                       ; preds = %if.end.443, %if.then.420
  br label %if.end.445

if.end.445:                                       ; preds = %if.end.444, %if.end.418
  %377 = load %struct.op*, %struct.op** %block.addr, align 8
  %tobool446 = icmp ne %struct.op* %377, null
  br i1 %tobool446, label %if.end.448, label %if.then.447

if.then.447:                                      ; preds = %if.end.445
  br label %done

if.end.448:                                       ; preds = %if.end.445
  %378 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any449 = getelementptr inbounds %struct.cv, %struct.cv* %378, i32 0, i32 0
  %379 = load %struct.xpvcv*, %struct.xpvcv** %sv_any449, align 8
  %xcv_flags450 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %379, i32 0, i32 17
  %380 = load i16, i16* %xcv_flags450, align 2
  %conv451 = zext i16 %380 to i32
  %and452 = and i32 %conv451, 256
  %tobool453 = icmp ne i32 %and452, 0
  br i1 %tobool453, label %if.then.454, label %if.else.460

if.then.454:                                      ; preds = %if.end.448
  %381 = load %struct.op*, %struct.op** %block.addr, align 8
  %call455 = call %struct.op* @Perl_scalarseq(%struct.op* %381)
  %call456 = call %struct.op* @Perl_mod(%struct.op* %call455, i32 168)
  %call457 = call %struct.op* @Perl_newUNOP(i32 168, i32 0, %struct.op* %call456)
  %382 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any458 = getelementptr inbounds %struct.cv, %struct.cv* %382, i32 0, i32 0
  %383 = load %struct.xpvcv*, %struct.xpvcv** %sv_any458, align 8
  %xcv_root459 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %383, i32 0, i32 9
  store %struct.op* %call457, %struct.op** %xcv_root459, align 8
  br label %if.end.471

if.else.460:                                      ; preds = %if.end.448
  %384 = load %struct.op*, %struct.op** %block.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %384, i32 0, i32 4
  %385 = load i16, i16* %op_type, align 2
  %conv461 = zext i16 %385 to i32
  %cmp462 = icmp eq i32 %conv461, 1
  br i1 %cmp462, label %if.then.464, label %if.end.466

if.then.464:                                      ; preds = %if.else.460
  %386 = load %struct.op*, %struct.op** %block.addr, align 8
  call void @Perl_op_free(%struct.op* %386)
  %call465 = call %struct.op* @Perl_newSTATEOP(i32 0, i8* null, %struct.op* null)
  store %struct.op* %call465, %struct.op** %block.addr, align 8
  br label %if.end.466

if.end.466:                                       ; preds = %if.then.464, %if.else.460
  %387 = load %struct.op*, %struct.op** %block.addr, align 8
  %call467 = call %struct.op* @Perl_scalarseq(%struct.op* %387)
  %call468 = call %struct.op* @Perl_newUNOP(i32 167, i32 0, %struct.op* %call467)
  %388 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any469 = getelementptr inbounds %struct.cv, %struct.cv* %388, i32 0, i32 0
  %389 = load %struct.xpvcv*, %struct.xpvcv** %sv_any469, align 8
  %xcv_root470 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %389, i32 0, i32 9
  store %struct.op* %call468, %struct.op** %xcv_root470, align 8
  br label %if.end.471

if.end.471:                                       ; preds = %if.end.466, %if.then.454
  %390 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any472 = getelementptr inbounds %struct.cv, %struct.cv* %390, i32 0, i32 0
  %391 = load %struct.xpvcv*, %struct.xpvcv** %sv_any472, align 8
  %xcv_root473 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %391, i32 0, i32 9
  %392 = load %struct.op*, %struct.op** %xcv_root473, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %392, i32 0, i32 7
  %393 = load i8, i8* %op_private, align 1
  %conv474 = zext i8 %393 to i32
  %or475 = or i32 %conv474, 64
  %conv476 = trunc i32 %or475 to i8
  store i8 %conv476, i8* %op_private, align 1
  %394 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any477 = getelementptr inbounds %struct.cv, %struct.cv* %394, i32 0, i32 0
  %395 = load %struct.xpvcv*, %struct.xpvcv** %sv_any477, align 8
  %xcv_root478 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %395, i32 0, i32 9
  %396 = load %struct.op*, %struct.op** %xcv_root478, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %396, i32 0, i32 3
  store i64 1, i64* %op_targ, align 8
  %397 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any479 = getelementptr inbounds %struct.cv, %struct.cv* %397, i32 0, i32 0
  %398 = load %struct.xpvcv*, %struct.xpvcv** %sv_any479, align 8
  %xcv_root480 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %398, i32 0, i32 9
  %399 = load %struct.op*, %struct.op** %xcv_root480, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %399, i32 0, i32 0
  %400 = load %struct.op*, %struct.op** %op_next, align 8
  %tobool481 = icmp ne %struct.op* %400, null
  br i1 %tobool481, label %cond.true.482, label %cond.false.486

cond.true.482:                                    ; preds = %if.end.471
  %401 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any483 = getelementptr inbounds %struct.cv, %struct.cv* %401, i32 0, i32 0
  %402 = load %struct.xpvcv*, %struct.xpvcv** %sv_any483, align 8
  %xcv_root484 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %402, i32 0, i32 9
  %403 = load %struct.op*, %struct.op** %xcv_root484, align 8
  %op_next485 = getelementptr inbounds %struct.op, %struct.op* %403, i32 0, i32 0
  %404 = load %struct.op*, %struct.op** %op_next485, align 8
  br label %cond.end.490

cond.false.486:                                   ; preds = %if.end.471
  %405 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any487 = getelementptr inbounds %struct.cv, %struct.cv* %405, i32 0, i32 0
  %406 = load %struct.xpvcv*, %struct.xpvcv** %sv_any487, align 8
  %xcv_root488 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %406, i32 0, i32 9
  %407 = load %struct.op*, %struct.op** %xcv_root488, align 8
  %call489 = call %struct.op* @Perl_linklist(%struct.op* %407)
  br label %cond.end.490

cond.end.490:                                     ; preds = %cond.false.486, %cond.true.482
  %cond491 = phi %struct.op* [ %404, %cond.true.482 ], [ %call489, %cond.false.486 ]
  %408 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any492 = getelementptr inbounds %struct.cv, %struct.cv* %408, i32 0, i32 0
  %409 = load %struct.xpvcv*, %struct.xpvcv** %sv_any492, align 8
  %xcv_start493 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %409, i32 0, i32 8
  store %struct.op* %cond491, %struct.op** %xcv_start493, align 8
  %410 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any494 = getelementptr inbounds %struct.cv, %struct.cv* %410, i32 0, i32 0
  %411 = load %struct.xpvcv*, %struct.xpvcv** %sv_any494, align 8
  %xcv_root495 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %411, i32 0, i32 9
  %412 = load %struct.op*, %struct.op** %xcv_root495, align 8
  %op_next496 = getelementptr inbounds %struct.op, %struct.op* %412, i32 0, i32 0
  store %struct.op* null, %struct.op** %op_next496, align 8
  %413 = load void (%struct.op*)*, void (%struct.op*)** @PL_peepp, align 8
  %414 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any497 = getelementptr inbounds %struct.cv, %struct.cv* %414, i32 0, i32 0
  %415 = load %struct.xpvcv*, %struct.xpvcv** %sv_any497, align 8
  %xcv_start498 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %415, i32 0, i32 8
  %416 = load %struct.op*, %struct.op** %xcv_start498, align 8
  call void %413(%struct.op* %416)
  %417 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any499 = getelementptr inbounds %struct.cv, %struct.cv* %417, i32 0, i32 0
  %418 = load %struct.xpvcv*, %struct.xpvcv** %sv_any499, align 8
  %xcv_flags500 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %418, i32 0, i32 17
  %419 = load i16, i16* %xcv_flags500, align 2
  %conv501 = zext i16 %419 to i32
  %and502 = and i32 %conv501, 1
  %tobool503 = icmp ne i32 %and502, 0
  %cond504 = select i1 %tobool503, i32 1, i32 0
  call void @Perl_pad_tidy(i32 %cond504)
  %420 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any505 = getelementptr inbounds %struct.cv, %struct.cv* %420, i32 0, i32 0
  %421 = load %struct.xpvcv*, %struct.xpvcv** %sv_any505, align 8
  %xcv_flags506 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %421, i32 0, i32 17
  %422 = load i16, i16* %xcv_flags506, align 2
  %conv507 = zext i16 %422 to i32
  %and508 = and i32 %conv507, 1
  %tobool509 = icmp ne i32 %and508, 0
  br i1 %tobool509, label %if.then.510, label %if.end.524

if.then.510:                                      ; preds = %cond.end.490
  %423 = load i8*, i8** %ps, align 8
  %tobool511 = icmp ne i8* %423, null
  br i1 %tobool511, label %land.lhs.true.512, label %if.end.523

land.lhs.true.512:                                ; preds = %if.then.510
  %424 = load i8*, i8** %ps, align 8
  %425 = load i8, i8* %424, align 1
  %tobool513 = icmp ne i8 %425, 0
  br i1 %tobool513, label %if.end.523, label %land.lhs.true.514

land.lhs.true.514:                                ; preds = %land.lhs.true.512
  %426 = load %struct.op*, %struct.op** %block.addr, align 8
  %427 = load %struct.cv*, %struct.cv** %cv, align 8
  %call515 = call %struct.sv* @Perl_op_const_sv(%struct.op* %426, %struct.cv* %427)
  %tobool516 = icmp ne %struct.sv* %call515, null
  br i1 %tobool516, label %if.then.517, label %if.end.523

if.then.517:                                      ; preds = %land.lhs.true.514
  %428 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any518 = getelementptr inbounds %struct.cv, %struct.cv* %428, i32 0, i32 0
  %429 = load %struct.xpvcv*, %struct.xpvcv** %sv_any518, align 8
  %xcv_flags519 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %429, i32 0, i32 17
  %430 = load i16, i16* %xcv_flags519, align 2
  %conv520 = zext i16 %430 to i32
  %or521 = or i32 %conv520, 512
  %conv522 = trunc i32 %or521 to i16
  store i16 %conv522, i16* %xcv_flags519, align 2
  br label %if.end.523

if.end.523:                                       ; preds = %if.then.517, %land.lhs.true.514, %land.lhs.true.512, %if.then.510
  br label %if.end.524

if.end.524:                                       ; preds = %if.end.523, %cond.end.490
  %431 = load i8*, i8** %name, align 8
  %tobool525 = icmp ne i8* %431, null
  br i1 %tobool525, label %if.then.528, label %lor.lhs.false.526

lor.lhs.false.526:                                ; preds = %if.end.524
  %432 = load i8*, i8** %aname, align 8
  %tobool527 = icmp ne i8* %432, null
  br i1 %tobool527, label %if.then.528, label %if.end.778

if.then.528:                                      ; preds = %lor.lhs.false.526, %if.end.524
  %433 = load i8*, i8** %name, align 8
  %tobool530 = icmp ne i8* %433, null
  br i1 %tobool530, label %cond.true.531, label %cond.false.532

cond.true.531:                                    ; preds = %if.then.528
  %434 = load i8*, i8** %name, align 8
  br label %cond.end.533

cond.false.532:                                   ; preds = %if.then.528
  %435 = load i8*, i8** %aname, align 8
  br label %cond.end.533

cond.end.533:                                     ; preds = %cond.false.532, %cond.true.531
  %cond534 = phi i8* [ %434, %cond.true.531 ], [ %435, %cond.false.532 ]
  store i8* %cond534, i8** %tname, align 8
  %436 = load i32, i32* @PL_perldb, align 4
  %tobool535 = icmp ne i32 %436, 0
  br i1 %tobool535, label %land.lhs.true.536, label %if.end.634

land.lhs.true.536:                                ; preds = %cond.end.533
  %437 = load i32, i32* @PL_perldb, align 4
  %and537 = and i32 %437, 16
  %tobool538 = icmp ne i32 %and537, 0
  br i1 %tobool538, label %land.lhs.true.539, label %if.end.634

land.lhs.true.539:                                ; preds = %land.lhs.true.536
  %438 = load %struct.hv*, %struct.hv** @PL_curstash, align 8
  %439 = load %struct.hv*, %struct.hv** @PL_debstash, align 8
  %cmp540 = icmp ne %struct.hv* %438, %439
  br i1 %cmp540, label %if.then.542, label %if.end.634

if.then.542:                                      ; preds = %land.lhs.true.539
  %call544 = call %struct.sv* @Perl_newSV(i64 0)
  store %struct.sv* %call544, %struct.sv** %sv543, align 8
  %call545 = call %struct.sv* @Perl_sv_newmortal()
  store %struct.sv* %call545, %struct.sv** %tmpstr, align 8
  %call546 = call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.28, i32 0, i32 0), i32 2, i32 11)
  store %struct.gv* %call546, %struct.gv** %db_postponed, align 8
  %440 = load %struct.sv*, %struct.sv** %sv543, align 8
  %441 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_filegv547 = getelementptr inbounds %struct.cop, %struct.cop* %441, i32 0, i32 10
  %442 = load %struct.gv*, %struct.gv** %cop_filegv547, align 8
  %tobool548 = icmp ne %struct.gv* %442, null
  br i1 %tobool548, label %cond.true.549, label %cond.false.555

cond.true.549:                                    ; preds = %if.then.542
  %443 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_filegv550 = getelementptr inbounds %struct.cop, %struct.cop* %443, i32 0, i32 10
  %444 = load %struct.gv*, %struct.gv** %cop_filegv550, align 8
  %sv_any551 = getelementptr inbounds %struct.gv, %struct.gv* %444, i32 0, i32 0
  %445 = load %struct.xpvgv*, %struct.xpvgv** %sv_any551, align 8
  %xgv_gp552 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %445, i32 0, i32 7
  %446 = load %struct.gp*, %struct.gp** %xgv_gp552, align 8
  %gp_sv553 = getelementptr inbounds %struct.gp, %struct.gp* %446, i32 0, i32 0
  %447 = load %struct.sv*, %struct.sv** %gp_sv553, align 8
  %tobool554 = icmp ne %struct.sv* %447, null
  br i1 %tobool554, label %cond.true.556, label %cond.false.569

cond.false.555:                                   ; preds = %if.then.542
  br i1 false, label %cond.true.556, label %cond.false.569

cond.true.556:                                    ; preds = %cond.false.555, %cond.true.549
  %448 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_filegv557 = getelementptr inbounds %struct.cop, %struct.cop* %448, i32 0, i32 10
  %449 = load %struct.gv*, %struct.gv** %cop_filegv557, align 8
  %tobool558 = icmp ne %struct.gv* %449, null
  br i1 %tobool558, label %cond.true.559, label %cond.false.564

cond.true.559:                                    ; preds = %cond.true.556
  %450 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_filegv560 = getelementptr inbounds %struct.cop, %struct.cop* %450, i32 0, i32 10
  %451 = load %struct.gv*, %struct.gv** %cop_filegv560, align 8
  %sv_any561 = getelementptr inbounds %struct.gv, %struct.gv* %451, i32 0, i32 0
  %452 = load %struct.xpvgv*, %struct.xpvgv** %sv_any561, align 8
  %xgv_gp562 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %452, i32 0, i32 7
  %453 = load %struct.gp*, %struct.gp** %xgv_gp562, align 8
  %gp_sv563 = getelementptr inbounds %struct.gp, %struct.gp* %453, i32 0, i32 0
  %454 = load %struct.sv*, %struct.sv** %gp_sv563, align 8
  br label %cond.end.565

cond.false.564:                                   ; preds = %cond.true.556
  br label %cond.end.565

cond.end.565:                                     ; preds = %cond.false.564, %cond.true.559
  %cond566 = phi %struct.sv* [ %454, %cond.true.559 ], [ null, %cond.false.564 ]
  %sv_any567 = getelementptr inbounds %struct.sv, %struct.sv* %cond566, i32 0, i32 0
  %455 = load i8*, i8** %sv_any567, align 8
  %456 = bitcast i8* %455 to %struct.xpv*
  %xpv_pv568 = getelementptr inbounds %struct.xpv, %struct.xpv* %456, i32 0, i32 0
  %457 = load i8*, i8** %xpv_pv568, align 8
  br label %cond.end.570

cond.false.569:                                   ; preds = %cond.false.555, %cond.true.549
  br label %cond.end.570

cond.end.570:                                     ; preds = %cond.false.569, %cond.end.565
  %cond571 = phi i8* [ %457, %cond.end.565 ], [ null, %cond.false.569 ]
  %458 = load i32, i32* @PL_subline, align 4
  %conv572 = sext i32 %458 to i64
  %459 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_line573 = getelementptr inbounds %struct.cop, %struct.cop* %459, i32 0, i32 13
  %460 = load i32, i32* %cop_line573, align 4
  %conv574 = zext i32 %460 to i64
  call void (%struct.sv*, i8*, ...) @Perl_sv_setpvf(%struct.sv* %440, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.73, i32 0, i32 0), i8* %cond571, i64 %conv572, i64 %conv574)
  %461 = load %struct.sv*, %struct.sv** %tmpstr, align 8
  %462 = load %struct.gv*, %struct.gv** %gv, align 8
  call void @Perl_gv_efullname4(%struct.sv* %461, %struct.gv* %462, i8* null, i8 signext 1)
  %463 = load %struct.gv*, %struct.gv** @PL_DBsub, align 8
  %sv_any575 = getelementptr inbounds %struct.gv, %struct.gv* %463, i32 0, i32 0
  %464 = load %struct.xpvgv*, %struct.xpvgv** %sv_any575, align 8
  %xgv_gp576 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %464, i32 0, i32 7
  %465 = load %struct.gp*, %struct.gp** %xgv_gp576, align 8
  %gp_hv = getelementptr inbounds %struct.gp, %struct.gp* %465, i32 0, i32 5
  %466 = load %struct.hv*, %struct.hv** %gp_hv, align 8
  %467 = load %struct.sv*, %struct.sv** %tmpstr, align 8
  %sv_any577 = getelementptr inbounds %struct.sv, %struct.sv* %467, i32 0, i32 0
  %468 = load i8*, i8** %sv_any577, align 8
  %469 = bitcast i8* %468 to %struct.xpv*
  %xpv_pv578 = getelementptr inbounds %struct.xpv, %struct.xpv* %469, i32 0, i32 0
  %470 = load i8*, i8** %xpv_pv578, align 8
  %471 = load %struct.sv*, %struct.sv** %tmpstr, align 8
  %sv_any579 = getelementptr inbounds %struct.sv, %struct.sv* %471, i32 0, i32 0
  %472 = load i8*, i8** %sv_any579, align 8
  %473 = bitcast i8* %472 to %struct.xpv*
  %xpv_cur580 = getelementptr inbounds %struct.xpv, %struct.xpv* %473, i32 0, i32 1
  %474 = load i64, i64* %xpv_cur580, align 8
  %conv581 = trunc i64 %474 to i32
  %475 = load %struct.sv*, %struct.sv** %sv543, align 8
  %call582 = call %struct.sv** @Perl_hv_store(%struct.hv* %466, i8* %470, i32 %conv581, %struct.sv* %475, i32 0)
  %476 = load %struct.gv*, %struct.gv** %db_postponed, align 8
  %sv_any583 = getelementptr inbounds %struct.gv, %struct.gv* %476, i32 0, i32 0
  %477 = load %struct.xpvgv*, %struct.xpvgv** %sv_any583, align 8
  %xgv_gp584 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %477, i32 0, i32 7
  %478 = load %struct.gp*, %struct.gp** %xgv_gp584, align 8
  %gp_hv585 = getelementptr inbounds %struct.gp, %struct.gp* %478, i32 0, i32 5
  %479 = load %struct.hv*, %struct.hv** %gp_hv585, align 8
  %tobool586 = icmp ne %struct.hv* %479, null
  br i1 %tobool586, label %cond.true.587, label %cond.false.591

cond.true.587:                                    ; preds = %cond.end.570
  %480 = load %struct.gv*, %struct.gv** %db_postponed, align 8
  %sv_any588 = getelementptr inbounds %struct.gv, %struct.gv* %480, i32 0, i32 0
  %481 = load %struct.xpvgv*, %struct.xpvgv** %sv_any588, align 8
  %xgv_gp589 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %481, i32 0, i32 7
  %482 = load %struct.gp*, %struct.gp** %xgv_gp589, align 8
  %gp_hv590 = getelementptr inbounds %struct.gp, %struct.gp* %482, i32 0, i32 5
  %483 = load %struct.hv*, %struct.hv** %gp_hv590, align 8
  br label %cond.end.596

cond.false.591:                                   ; preds = %cond.end.570
  %484 = load %struct.gv*, %struct.gv** %db_postponed, align 8
  %call592 = call %struct.gv* @Perl_gv_HVadd(%struct.gv* %484)
  %sv_any593 = getelementptr inbounds %struct.gv, %struct.gv* %call592, i32 0, i32 0
  %485 = load %struct.xpvgv*, %struct.xpvgv** %sv_any593, align 8
  %xgv_gp594 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %485, i32 0, i32 7
  %486 = load %struct.gp*, %struct.gp** %xgv_gp594, align 8
  %gp_hv595 = getelementptr inbounds %struct.gp, %struct.gp* %486, i32 0, i32 5
  %487 = load %struct.hv*, %struct.hv** %gp_hv595, align 8
  br label %cond.end.596

cond.end.596:                                     ; preds = %cond.false.591, %cond.true.587
  %cond597 = phi %struct.hv* [ %483, %cond.true.587 ], [ %487, %cond.false.591 ]
  store %struct.hv* %cond597, %struct.hv** %hv, align 8
  %488 = load %struct.hv*, %struct.hv** %hv, align 8
  %sv_any598 = getelementptr inbounds %struct.hv, %struct.hv* %488, i32 0, i32 0
  %489 = load %struct.xpvhv*, %struct.xpvhv** %sv_any598, align 8
  %xhv_fill = getelementptr inbounds %struct.xpvhv, %struct.xpvhv* %489, i32 0, i32 1
  %490 = load i64, i64* %xhv_fill, align 8
  %cmp599 = icmp ugt i64 %490, 0
  br i1 %cmp599, label %land.lhs.true.601, label %if.end.633

land.lhs.true.601:                                ; preds = %cond.end.596
  %491 = load %struct.hv*, %struct.hv** %hv, align 8
  %492 = load %struct.sv*, %struct.sv** %tmpstr, align 8
  %sv_any602 = getelementptr inbounds %struct.sv, %struct.sv* %492, i32 0, i32 0
  %493 = load i8*, i8** %sv_any602, align 8
  %494 = bitcast i8* %493 to %struct.xpv*
  %xpv_pv603 = getelementptr inbounds %struct.xpv, %struct.xpv* %494, i32 0, i32 0
  %495 = load i8*, i8** %xpv_pv603, align 8
  %496 = load %struct.sv*, %struct.sv** %tmpstr, align 8
  %sv_any604 = getelementptr inbounds %struct.sv, %struct.sv* %496, i32 0, i32 0
  %497 = load i8*, i8** %sv_any604, align 8
  %498 = bitcast i8* %497 to %struct.xpv*
  %xpv_cur605 = getelementptr inbounds %struct.xpv, %struct.xpv* %498, i32 0, i32 1
  %499 = load i64, i64* %xpv_cur605, align 8
  %conv606 = trunc i64 %499 to i32
  %call607 = call signext i8 @Perl_hv_exists(%struct.hv* %491, i8* %495, i32 %conv606)
  %conv608 = sext i8 %call607 to i32
  %tobool609 = icmp ne i32 %conv608, 0
  br i1 %tobool609, label %land.lhs.true.610, label %if.end.633

land.lhs.true.610:                                ; preds = %land.lhs.true.601
  %500 = load %struct.gv*, %struct.gv** %db_postponed, align 8
  %sv_any611 = getelementptr inbounds %struct.gv, %struct.gv* %500, i32 0, i32 0
  %501 = load %struct.xpvgv*, %struct.xpvgv** %sv_any611, align 8
  %xgv_gp612 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %501, i32 0, i32 7
  %502 = load %struct.gp*, %struct.gp** %xgv_gp612, align 8
  %gp_cv613 = getelementptr inbounds %struct.gp, %struct.gp* %502, i32 0, i32 7
  %503 = load %struct.cv*, %struct.cv** %gp_cv613, align 8
  store %struct.cv* %503, %struct.cv** %pcv, align 8
  %tobool614 = icmp ne %struct.cv* %503, null
  br i1 %tobool614, label %if.then.615, label %if.end.633

if.then.615:                                      ; preds = %land.lhs.true.610
  %504 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %504, %struct.sv*** %sp, align 8
  %505 = load i32*, i32** @PL_markstack_ptr, align 8
  %incdec.ptr = getelementptr inbounds i32, i32* %505, i32 1
  store i32* %incdec.ptr, i32** @PL_markstack_ptr, align 8
  %506 = load i32*, i32** @PL_markstack_max, align 8
  %cmp616 = icmp eq i32* %incdec.ptr, %506
  br i1 %cmp616, label %if.then.618, label %if.end.619

if.then.618:                                      ; preds = %if.then.615
  call void @Perl_markstack_grow()
  br label %if.end.619

if.end.619:                                       ; preds = %if.then.618, %if.then.615
  %507 = load %struct.sv**, %struct.sv*** %sp, align 8
  %508 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %507 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %508 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %conv620 = trunc i64 %sub.ptr.div to i32
  %509 = load i32*, i32** @PL_markstack_ptr, align 8
  store i32 %conv620, i32* %509, align 4
  store i32 %conv620, i32* %tmp
  %510 = load i32, i32* %tmp
  %511 = load %struct.sv**, %struct.sv*** @PL_stack_max, align 8
  %512 = load %struct.sv**, %struct.sv*** %sp, align 8
  %sub.ptr.lhs.cast621 = ptrtoint %struct.sv** %511 to i64
  %sub.ptr.rhs.cast622 = ptrtoint %struct.sv** %512 to i64
  %sub.ptr.sub623 = sub i64 %sub.ptr.lhs.cast621, %sub.ptr.rhs.cast622
  %sub.ptr.div624 = sdiv exact i64 %sub.ptr.sub623, 8
  %cmp625 = icmp slt i64 %sub.ptr.div624, 1
  br i1 %cmp625, label %if.then.627, label %if.end.629

if.then.627:                                      ; preds = %if.end.619
  %513 = load %struct.sv**, %struct.sv*** %sp, align 8
  %514 = load %struct.sv**, %struct.sv*** %sp, align 8
  %call628 = call %struct.sv** @Perl_stack_grow(%struct.sv** %513, %struct.sv** %514, i32 1)
  store %struct.sv** %call628, %struct.sv*** %sp, align 8
  br label %if.end.629

if.end.629:                                       ; preds = %if.then.627, %if.end.619
  %515 = load %struct.sv*, %struct.sv** %tmpstr, align 8
  %516 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr631 = getelementptr inbounds %struct.sv*, %struct.sv** %516, i32 1
  store %struct.sv** %incdec.ptr631, %struct.sv*** %sp, align 8
  store %struct.sv* %515, %struct.sv** %incdec.ptr631, align 8
  store %struct.sv* %515, %struct.sv** %tmp630
  %517 = load %struct.sv*, %struct.sv** %tmp630
  %518 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %518, %struct.sv*** @PL_stack_sp, align 8
  %519 = load %struct.cv*, %struct.cv** %pcv, align 8
  %520 = bitcast %struct.cv* %519 to %struct.sv*
  %call632 = call i32 @Perl_call_sv(%struct.sv* %520, i32 2)
  br label %if.end.633

if.end.633:                                       ; preds = %if.end.629, %land.lhs.true.610, %land.lhs.true.601, %cond.end.596
  br label %if.end.634

if.end.634:                                       ; preds = %if.end.633, %land.lhs.true.539, %land.lhs.true.536, %cond.end.533
  %521 = load i8*, i8** %tname, align 8
  %call635 = call i8* @strrchr(i8* %521, i32 58)
  store i8* %call635, i8** %s529, align 8
  %tobool636 = icmp ne i8* %call635, null
  br i1 %tobool636, label %if.then.637, label %if.else.639

if.then.637:                                      ; preds = %if.end.634
  %522 = load i8*, i8** %s529, align 8
  %incdec.ptr638 = getelementptr inbounds i8, i8* %522, i32 1
  store i8* %incdec.ptr638, i8** %s529, align 8
  br label %if.end.640

if.else.639:                                      ; preds = %if.end.634
  %523 = load i8*, i8** %tname, align 8
  store i8* %523, i8** %s529, align 8
  br label %if.end.640

if.end.640:                                       ; preds = %if.else.639, %if.then.637
  %524 = load i8*, i8** %s529, align 8
  %525 = load i8, i8* %524, align 1
  %conv641 = sext i8 %525 to i32
  %cmp642 = icmp ne i32 %conv641, 66
  br i1 %cmp642, label %land.lhs.true.644, label %if.end.657

land.lhs.true.644:                                ; preds = %if.end.640
  %526 = load i8*, i8** %s529, align 8
  %527 = load i8, i8* %526, align 1
  %conv645 = sext i8 %527 to i32
  %cmp646 = icmp ne i32 %conv645, 69
  br i1 %cmp646, label %land.lhs.true.648, label %if.end.657

land.lhs.true.648:                                ; preds = %land.lhs.true.644
  %528 = load i8*, i8** %s529, align 8
  %529 = load i8, i8* %528, align 1
  %conv649 = sext i8 %529 to i32
  %cmp650 = icmp ne i32 %conv649, 67
  br i1 %cmp650, label %land.lhs.true.652, label %if.end.657

land.lhs.true.652:                                ; preds = %land.lhs.true.648
  %530 = load i8*, i8** %s529, align 8
  %531 = load i8, i8* %530, align 1
  %conv653 = sext i8 %531 to i32
  %cmp654 = icmp ne i32 %conv653, 73
  br i1 %cmp654, label %if.then.656, label %if.end.657

if.then.656:                                      ; preds = %land.lhs.true.652
  br label %done

if.end.657:                                       ; preds = %land.lhs.true.652, %land.lhs.true.648, %land.lhs.true.644, %if.end.640
  %532 = load i8*, i8** %s529, align 8
  %call658 = call i32 @strcmp(i8* %532, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.51, i32 0, i32 0))
  %tobool659 = icmp ne i32 %call658, 0
  br i1 %tobool659, label %if.else.671, label %if.then.660

if.then.660:                                      ; preds = %if.end.657
  %533 = load i32, i32* @PL_scopestack_ix, align 4
  store i32 %533, i32* %oldscope, align 4
  call void @Perl_push_scope()
  call void @Perl_save_sptr(%struct.sv** bitcast (%struct.gv** getelementptr inbounds (%struct.cop, %struct.cop* @PL_compiling, i32 0, i32 10) to %struct.sv**))
  call void @Perl_save_I32(i32* getelementptr inbounds (%struct.cop, %struct.cop* @PL_compiling, i32 0, i32 13))
  %534 = load %struct.av*, %struct.av** @PL_beginav, align 8
  %tobool662 = icmp ne %struct.av* %534, null
  br i1 %tobool662, label %if.end.665, label %if.then.663

if.then.663:                                      ; preds = %if.then.660
  %call664 = call %struct.av* @Perl_newAV()
  store %struct.av* %call664, %struct.av** @PL_beginav, align 8
  br label %if.end.665

if.end.665:                                       ; preds = %if.then.663, %if.then.660
  %535 = load %struct.av*, %struct.av** @PL_beginav, align 8
  %536 = load %struct.cv*, %struct.cv** %cv, align 8
  %537 = bitcast %struct.cv* %536 to %struct.sv*
  call void @Perl_av_push(%struct.av* %535, %struct.sv* %537)
  %538 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any666 = getelementptr inbounds %struct.gv, %struct.gv* %538, i32 0, i32 0
  %539 = load %struct.xpvgv*, %struct.xpvgv** %sv_any666, align 8
  %xgv_gp667 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %539, i32 0, i32 7
  %540 = load %struct.gp*, %struct.gp** %xgv_gp667, align 8
  %gp_cv668 = getelementptr inbounds %struct.gp, %struct.gp* %540, i32 0, i32 7
  store %struct.cv* null, %struct.cv** %gp_cv668, align 8
  %541 = load i32, i32* %oldscope, align 4
  %542 = load %struct.av*, %struct.av** @PL_beginav, align 8
  call void @Perl_call_list(i32 %541, %struct.av* %542)
  store volatile %struct.cop* @PL_compiling, %struct.cop** @PL_curcop, align 8
  %543 = load i32, i32* @PL_hints, align 4
  %and669 = and i32 %543, 255
  %conv670 = trunc i32 %and669 to i8
  store i8 %conv670, i8* getelementptr inbounds (%struct.cop, %struct.cop* @PL_compiling, i32 0, i32 7), align 1
  call void @Perl_pop_scope()
  br label %if.end.777

if.else.671:                                      ; preds = %if.end.657
  %544 = load i8*, i8** %s529, align 8
  %call672 = call i32 @strcmp(i8* %544, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.74, i32 0, i32 0))
  %tobool673 = icmp ne i32 %call672, 0
  br i1 %tobool673, label %if.else.685, label %land.lhs.true.674

land.lhs.true.674:                                ; preds = %if.else.671
  %545 = load i32, i32* @PL_error_count, align 4
  %tobool675 = icmp ne i32 %545, 0
  br i1 %tobool675, label %if.else.685, label %if.then.676

if.then.676:                                      ; preds = %land.lhs.true.674
  %546 = load %struct.av*, %struct.av** @PL_endav, align 8
  %tobool677 = icmp ne %struct.av* %546, null
  br i1 %tobool677, label %if.end.680, label %if.then.678

if.then.678:                                      ; preds = %if.then.676
  %call679 = call %struct.av* @Perl_newAV()
  store %struct.av* %call679, %struct.av** @PL_endav, align 8
  br label %if.end.680

if.end.680:                                       ; preds = %if.then.678, %if.then.676
  %547 = load %struct.av*, %struct.av** @PL_endav, align 8
  call void @Perl_av_unshift(%struct.av* %547, i32 1)
  %548 = load %struct.av*, %struct.av** @PL_endav, align 8
  %549 = load %struct.cv*, %struct.cv** %cv, align 8
  %550 = bitcast %struct.cv* %549 to %struct.sv*
  %call681 = call %struct.sv** @Perl_av_store(%struct.av* %548, i32 0, %struct.sv* %550)
  %551 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any682 = getelementptr inbounds %struct.gv, %struct.gv* %551, i32 0, i32 0
  %552 = load %struct.xpvgv*, %struct.xpvgv** %sv_any682, align 8
  %xgv_gp683 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %552, i32 0, i32 7
  %553 = load %struct.gp*, %struct.gp** %xgv_gp683, align 8
  %gp_cv684 = getelementptr inbounds %struct.gp, %struct.gp* %553, i32 0, i32 7
  store %struct.cv* null, %struct.cv** %gp_cv684, align 8
  br label %if.end.776

if.else.685:                                      ; preds = %land.lhs.true.674, %if.else.671
  %554 = load i8*, i8** %s529, align 8
  %call686 = call i32 @strcmp(i8* %554, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.75, i32 0, i32 0))
  %tobool687 = icmp ne i32 %call686, 0
  br i1 %tobool687, label %if.else.730, label %land.lhs.true.688

land.lhs.true.688:                                ; preds = %if.else.685
  %555 = load i32, i32* @PL_error_count, align 4
  %tobool689 = icmp ne i32 %555, 0
  br i1 %tobool689, label %if.else.730, label %if.then.690

if.then.690:                                      ; preds = %land.lhs.true.688
  %556 = load %struct.av*, %struct.av** @PL_checkav, align 8
  %tobool691 = icmp ne %struct.av* %556, null
  br i1 %tobool691, label %if.end.694, label %if.then.692

if.then.692:                                      ; preds = %if.then.690
  %call693 = call %struct.av* @Perl_newAV()
  store %struct.av* %call693, %struct.av** @PL_checkav, align 8
  br label %if.end.694

if.end.694:                                       ; preds = %if.then.692, %if.then.690
  %557 = load %struct.op*, %struct.op** @PL_main_start, align 8
  %tobool695 = icmp ne %struct.op* %557, null
  br i1 %tobool695, label %land.lhs.true.696, label %if.end.725

land.lhs.true.696:                                ; preds = %if.end.694
  %558 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings697 = getelementptr inbounds %struct.cop, %struct.cop* %558, i32 0, i32 14
  %559 = load %struct.sv*, %struct.sv** %cop_warnings697, align 8
  %cmp698 = icmp ne %struct.sv* %559, null
  br i1 %cmp698, label %land.lhs.true.700, label %lor.lhs.false.716

land.lhs.true.700:                                ; preds = %land.lhs.true.696
  %560 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings701 = getelementptr inbounds %struct.cop, %struct.cop* %560, i32 0, i32 14
  %561 = load %struct.sv*, %struct.sv** %cop_warnings701, align 8
  %cmp702 = icmp ne %struct.sv* %561, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 2)
  br i1 %cmp702, label %land.lhs.true.704, label %lor.lhs.false.716

land.lhs.true.704:                                ; preds = %land.lhs.true.700
  %562 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings705 = getelementptr inbounds %struct.cop, %struct.cop* %562, i32 0, i32 14
  %563 = load %struct.sv*, %struct.sv** %cop_warnings705, align 8
  %cmp706 = icmp eq %struct.sv* %563, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 1)
  br i1 %cmp706, label %if.then.724, label %lor.lhs.false.708

lor.lhs.false.708:                                ; preds = %land.lhs.true.704
  %564 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings709 = getelementptr inbounds %struct.cop, %struct.cop* %564, i32 0, i32 14
  %565 = load %struct.sv*, %struct.sv** %cop_warnings709, align 8
  %sv_any710 = getelementptr inbounds %struct.sv, %struct.sv* %565, i32 0, i32 0
  %566 = load i8*, i8** %sv_any710, align 8
  %567 = bitcast i8* %566 to %struct.xpv*
  %xpv_pv711 = getelementptr inbounds %struct.xpv, %struct.xpv* %567, i32 0, i32 0
  %568 = load i8*, i8** %xpv_pv711, align 8
  %arrayidx712 = getelementptr inbounds i8, i8* %568, i64 11
  %569 = load i8, i8* %arrayidx712, align 1
  %conv713 = sext i8 %569 to i32
  %and714 = and i32 %conv713, 4
  %tobool715 = icmp ne i32 %and714, 0
  br i1 %tobool715, label %if.then.724, label %lor.lhs.false.716

lor.lhs.false.716:                                ; preds = %lor.lhs.false.708, %land.lhs.true.700, %land.lhs.true.696
  %570 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings717 = getelementptr inbounds %struct.cop, %struct.cop* %570, i32 0, i32 14
  %571 = load %struct.sv*, %struct.sv** %cop_warnings717, align 8
  %cmp718 = icmp eq %struct.sv* %571, null
  br i1 %cmp718, label %land.lhs.true.720, label %if.end.725

land.lhs.true.720:                                ; preds = %lor.lhs.false.716
  %572 = load i8, i8* @PL_dowarn, align 1
  %conv721 = zext i8 %572 to i32
  %and722 = and i32 %conv721, 1
  %tobool723 = icmp ne i32 %and722, 0
  br i1 %tobool723, label %if.then.724, label %if.end.725

if.then.724:                                      ; preds = %land.lhs.true.720, %lor.lhs.false.708, %land.lhs.true.704
  call void (i32, i8*, ...) @Perl_warner(i32 45, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.76, i32 0, i32 0))
  br label %if.end.725

if.end.725:                                       ; preds = %if.then.724, %land.lhs.true.720, %lor.lhs.false.716, %if.end.694
  %573 = load %struct.av*, %struct.av** @PL_checkav, align 8
  call void @Perl_av_unshift(%struct.av* %573, i32 1)
  %574 = load %struct.av*, %struct.av** @PL_checkav, align 8
  %575 = load %struct.cv*, %struct.cv** %cv, align 8
  %576 = bitcast %struct.cv* %575 to %struct.sv*
  %call726 = call %struct.sv** @Perl_av_store(%struct.av* %574, i32 0, %struct.sv* %576)
  %577 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any727 = getelementptr inbounds %struct.gv, %struct.gv* %577, i32 0, i32 0
  %578 = load %struct.xpvgv*, %struct.xpvgv** %sv_any727, align 8
  %xgv_gp728 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %578, i32 0, i32 7
  %579 = load %struct.gp*, %struct.gp** %xgv_gp728, align 8
  %gp_cv729 = getelementptr inbounds %struct.gp, %struct.gp* %579, i32 0, i32 7
  store %struct.cv* null, %struct.cv** %gp_cv729, align 8
  br label %if.end.775

if.else.730:                                      ; preds = %land.lhs.true.688, %if.else.685
  %580 = load i8*, i8** %s529, align 8
  %call731 = call i32 @strcmp(i8* %580, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.77, i32 0, i32 0))
  %tobool732 = icmp ne i32 %call731, 0
  br i1 %tobool732, label %if.end.774, label %land.lhs.true.733

land.lhs.true.733:                                ; preds = %if.else.730
  %581 = load i32, i32* @PL_error_count, align 4
  %tobool734 = icmp ne i32 %581, 0
  br i1 %tobool734, label %if.end.774, label %if.then.735

if.then.735:                                      ; preds = %land.lhs.true.733
  %582 = load %struct.av*, %struct.av** @PL_initav, align 8
  %tobool736 = icmp ne %struct.av* %582, null
  br i1 %tobool736, label %if.end.739, label %if.then.737

if.then.737:                                      ; preds = %if.then.735
  %call738 = call %struct.av* @Perl_newAV()
  store %struct.av* %call738, %struct.av** @PL_initav, align 8
  br label %if.end.739

if.end.739:                                       ; preds = %if.then.737, %if.then.735
  %583 = load %struct.op*, %struct.op** @PL_main_start, align 8
  %tobool740 = icmp ne %struct.op* %583, null
  br i1 %tobool740, label %land.lhs.true.741, label %if.end.770

land.lhs.true.741:                                ; preds = %if.end.739
  %584 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings742 = getelementptr inbounds %struct.cop, %struct.cop* %584, i32 0, i32 14
  %585 = load %struct.sv*, %struct.sv** %cop_warnings742, align 8
  %cmp743 = icmp ne %struct.sv* %585, null
  br i1 %cmp743, label %land.lhs.true.745, label %lor.lhs.false.761

land.lhs.true.745:                                ; preds = %land.lhs.true.741
  %586 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings746 = getelementptr inbounds %struct.cop, %struct.cop* %586, i32 0, i32 14
  %587 = load %struct.sv*, %struct.sv** %cop_warnings746, align 8
  %cmp747 = icmp ne %struct.sv* %587, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 2)
  br i1 %cmp747, label %land.lhs.true.749, label %lor.lhs.false.761

land.lhs.true.749:                                ; preds = %land.lhs.true.745
  %588 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings750 = getelementptr inbounds %struct.cop, %struct.cop* %588, i32 0, i32 14
  %589 = load %struct.sv*, %struct.sv** %cop_warnings750, align 8
  %cmp751 = icmp eq %struct.sv* %589, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 1)
  br i1 %cmp751, label %if.then.769, label %lor.lhs.false.753

lor.lhs.false.753:                                ; preds = %land.lhs.true.749
  %590 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings754 = getelementptr inbounds %struct.cop, %struct.cop* %590, i32 0, i32 14
  %591 = load %struct.sv*, %struct.sv** %cop_warnings754, align 8
  %sv_any755 = getelementptr inbounds %struct.sv, %struct.sv* %591, i32 0, i32 0
  %592 = load i8*, i8** %sv_any755, align 8
  %593 = bitcast i8* %592 to %struct.xpv*
  %xpv_pv756 = getelementptr inbounds %struct.xpv, %struct.xpv* %593, i32 0, i32 0
  %594 = load i8*, i8** %xpv_pv756, align 8
  %arrayidx757 = getelementptr inbounds i8, i8* %594, i64 11
  %595 = load i8, i8* %arrayidx757, align 1
  %conv758 = sext i8 %595 to i32
  %and759 = and i32 %conv758, 4
  %tobool760 = icmp ne i32 %and759, 0
  br i1 %tobool760, label %if.then.769, label %lor.lhs.false.761

lor.lhs.false.761:                                ; preds = %lor.lhs.false.753, %land.lhs.true.745, %land.lhs.true.741
  %596 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings762 = getelementptr inbounds %struct.cop, %struct.cop* %596, i32 0, i32 14
  %597 = load %struct.sv*, %struct.sv** %cop_warnings762, align 8
  %cmp763 = icmp eq %struct.sv* %597, null
  br i1 %cmp763, label %land.lhs.true.765, label %if.end.770

land.lhs.true.765:                                ; preds = %lor.lhs.false.761
  %598 = load i8, i8* @PL_dowarn, align 1
  %conv766 = zext i8 %598 to i32
  %and767 = and i32 %conv766, 1
  %tobool768 = icmp ne i32 %and767, 0
  br i1 %tobool768, label %if.then.769, label %if.end.770

if.then.769:                                      ; preds = %land.lhs.true.765, %lor.lhs.false.753, %land.lhs.true.749
  call void (i32, i8*, ...) @Perl_warner(i32 45, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.78, i32 0, i32 0))
  br label %if.end.770

if.end.770:                                       ; preds = %if.then.769, %land.lhs.true.765, %lor.lhs.false.761, %if.end.739
  %599 = load %struct.av*, %struct.av** @PL_initav, align 8
  %600 = load %struct.cv*, %struct.cv** %cv, align 8
  %601 = bitcast %struct.cv* %600 to %struct.sv*
  call void @Perl_av_push(%struct.av* %599, %struct.sv* %601)
  %602 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any771 = getelementptr inbounds %struct.gv, %struct.gv* %602, i32 0, i32 0
  %603 = load %struct.xpvgv*, %struct.xpvgv** %sv_any771, align 8
  %xgv_gp772 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %603, i32 0, i32 7
  %604 = load %struct.gp*, %struct.gp** %xgv_gp772, align 8
  %gp_cv773 = getelementptr inbounds %struct.gp, %struct.gp* %604, i32 0, i32 7
  store %struct.cv* null, %struct.cv** %gp_cv773, align 8
  br label %if.end.774

if.end.774:                                       ; preds = %if.end.770, %land.lhs.true.733, %if.else.730
  br label %if.end.775

if.end.775:                                       ; preds = %if.end.774, %if.end.725
  br label %if.end.776

if.end.776:                                       ; preds = %if.end.775, %if.end.680
  br label %if.end.777

if.end.777:                                       ; preds = %if.end.776, %if.end.665
  br label %if.end.778

if.end.778:                                       ; preds = %if.end.777, %lor.lhs.false.526
  br label %done

done:                                             ; preds = %if.end.778, %if.then.656, %if.then.447, %if.then.337, %if.end.282, %if.end.193, %if.end.127
  store i32 -1, i32* @PL_copline, align 4
  %605 = load i32, i32* @PL_savestack_ix, align 4
  %606 = load i32, i32* %floor.addr, align 4
  %cmp779 = icmp sgt i32 %605, %606
  br i1 %cmp779, label %if.then.781, label %if.end.782

if.then.781:                                      ; preds = %done
  %607 = load i32, i32* %floor.addr, align 4
  call void @Perl_leave_scope(i32 %607)
  br label %if.end.782

if.end.782:                                       ; preds = %if.then.781, %done
  %608 = load %struct.cv*, %struct.cv** %cv, align 8
  ret %struct.cv* %608
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newSTATEOP(i32 %flags, i8* %label, %struct.op* %o) #0 {
entry:
  %flags.addr = alloca i32, align 4
  %label.addr = alloca i8*, align 8
  %o.addr = alloca %struct.op*, align 8
  %seq = alloca i32, align 4
  %cop = alloca %struct.cop*, align 8
  %svp = alloca %struct.sv**, align 8
  store i32 %flags, i32* %flags.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %call = call i32 @Perl_intro_my()
  store i32 %call, i32* %seq, align 4
  %call1 = call i8* @Perl_safesysmalloc(i64 96)
  %0 = bitcast i8* %call1 to %struct.cop*
  store %struct.cop* %0, %struct.cop** %cop, align 8
  %1 = load %struct.cop*, %struct.cop** %cop, align 8
  %2 = bitcast %struct.cop* %1 to i8*
  call void @llvm.memset.p0i8.i64(i8* %2, i8 0, i64 96, i32 1, i1 false)
  %3 = load i32, i32* @PL_perldb, align 4
  %tobool = icmp ne i32 %3, 0
  br i1 %tobool, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %4 = load i32, i32* @PL_perldb, align 4
  %and = and i32 %4, 2
  %tobool2 = icmp ne i32 %and, 0
  br i1 %tobool2, label %land.lhs.true.3, label %if.else

land.lhs.true.3:                                  ; preds = %land.lhs.true
  %5 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_line = getelementptr inbounds %struct.cop, %struct.cop* %5, i32 0, i32 13
  %6 = load i32, i32* %cop_line, align 4
  %tobool4 = icmp ne i32 %6, 0
  br i1 %tobool4, label %land.lhs.true.5, label %if.else

land.lhs.true.5:                                  ; preds = %land.lhs.true.3
  %7 = load %struct.hv*, %struct.hv** @PL_curstash, align 8
  %8 = load %struct.hv*, %struct.hv** @PL_debstash, align 8
  %cmp = icmp ne %struct.hv* %7, %8
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true.5
  %9 = load %struct.cop*, %struct.cop** %cop, align 8
  %op_type = getelementptr inbounds %struct.cop, %struct.cop* %9, i32 0, i32 4
  store i16 175, i16* %op_type, align 2
  %10 = load %struct.op* ()*, %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 175), align 8
  %11 = load %struct.cop*, %struct.cop** %cop, align 8
  %op_ppaddr = getelementptr inbounds %struct.cop, %struct.cop* %11, i32 0, i32 2
  store %struct.op* ()* %10, %struct.op* ()** %op_ppaddr, align 8
  br label %if.end

if.else:                                          ; preds = %land.lhs.true.5, %land.lhs.true.3, %land.lhs.true, %entry
  %12 = load %struct.cop*, %struct.cop** %cop, align 8
  %op_type6 = getelementptr inbounds %struct.cop, %struct.cop* %12, i32 0, i32 4
  store i16 174, i16* %op_type6, align 2
  %13 = load %struct.op* ()*, %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 174), align 8
  %14 = load %struct.cop*, %struct.cop** %cop, align 8
  %op_ppaddr7 = getelementptr inbounds %struct.cop, %struct.cop* %14, i32 0, i32 2
  store %struct.op* ()* %13, %struct.op* ()** %op_ppaddr7, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %15 = load i32, i32* %flags.addr, align 4
  %conv = trunc i32 %15 to i8
  %16 = load %struct.cop*, %struct.cop** %cop, align 8
  %op_flags = getelementptr inbounds %struct.cop, %struct.cop* %16, i32 0, i32 6
  store i8 %conv, i8* %op_flags, align 1
  %17 = load i32, i32* @PL_hints, align 4
  %and8 = and i32 %17, 255
  %conv9 = trunc i32 %and8 to i8
  %18 = load %struct.cop*, %struct.cop** %cop, align 8
  %op_private = getelementptr inbounds %struct.cop, %struct.cop* %18, i32 0, i32 7
  store i8 %conv9, i8* %op_private, align 1
  %19 = load %struct.cop*, %struct.cop** %cop, align 8
  %op_private10 = getelementptr inbounds %struct.cop, %struct.cop* %19, i32 0, i32 7
  %20 = load i8, i8* %op_private10, align 1
  store i8 %20, i8* getelementptr inbounds (%struct.cop, %struct.cop* @PL_compiling, i32 0, i32 7), align 1
  %21 = load %struct.cop*, %struct.cop** %cop, align 8
  %22 = bitcast %struct.cop* %21 to %struct.op*
  %23 = load %struct.cop*, %struct.cop** %cop, align 8
  %op_next = getelementptr inbounds %struct.cop, %struct.cop* %23, i32 0, i32 0
  store %struct.op* %22, %struct.op** %op_next, align 8
  %24 = load i8*, i8** %label.addr, align 8
  %tobool11 = icmp ne i8* %24, null
  br i1 %tobool11, label %if.then.12, label %if.end.13

if.then.12:                                       ; preds = %if.end
  %25 = load i8*, i8** %label.addr, align 8
  %26 = load %struct.cop*, %struct.cop** %cop, align 8
  %cop_label = getelementptr inbounds %struct.cop, %struct.cop* %26, i32 0, i32 8
  store i8* %25, i8** %cop_label, align 8
  %27 = load i32, i32* @PL_hints, align 4
  %or = or i32 %27, 256
  store i32 %or, i32* @PL_hints, align 4
  br label %if.end.13

if.end.13:                                        ; preds = %if.then.12, %if.end
  %28 = load i32, i32* %seq, align 4
  %29 = load %struct.cop*, %struct.cop** %cop, align 8
  %cop_seq = getelementptr inbounds %struct.cop, %struct.cop* %29, i32 0, i32 11
  store i32 %28, i32* %cop_seq, align 4
  %30 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_arybase = getelementptr inbounds %struct.cop, %struct.cop* %30, i32 0, i32 12
  %31 = load i32, i32* %cop_arybase, align 4
  %32 = load %struct.cop*, %struct.cop** %cop, align 8
  %cop_arybase14 = getelementptr inbounds %struct.cop, %struct.cop* %32, i32 0, i32 12
  store i32 %31, i32* %cop_arybase14, align 4
  %33 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings = getelementptr inbounds %struct.cop, %struct.cop* %33, i32 0, i32 14
  %34 = load %struct.sv*, %struct.sv** %cop_warnings, align 8
  %cmp15 = icmp eq %struct.sv* %34, null
  br i1 %cmp15, label %if.then.24, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end.13
  %35 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings17 = getelementptr inbounds %struct.cop, %struct.cop* %35, i32 0, i32 14
  %36 = load %struct.sv*, %struct.sv** %cop_warnings17, align 8
  %cmp18 = icmp eq %struct.sv* %36, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 1)
  br i1 %cmp18, label %if.then.24, label %lor.lhs.false.20

lor.lhs.false.20:                                 ; preds = %lor.lhs.false
  %37 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings21 = getelementptr inbounds %struct.cop, %struct.cop* %37, i32 0, i32 14
  %38 = load %struct.sv*, %struct.sv** %cop_warnings21, align 8
  %cmp22 = icmp eq %struct.sv* %38, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 2)
  br i1 %cmp22, label %if.then.24, label %if.else.27

if.then.24:                                       ; preds = %lor.lhs.false.20, %lor.lhs.false, %if.end.13
  %39 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings25 = getelementptr inbounds %struct.cop, %struct.cop* %39, i32 0, i32 14
  %40 = load %struct.sv*, %struct.sv** %cop_warnings25, align 8
  %41 = load %struct.cop*, %struct.cop** %cop, align 8
  %cop_warnings26 = getelementptr inbounds %struct.cop, %struct.cop* %41, i32 0, i32 14
  store %struct.sv* %40, %struct.sv** %cop_warnings26, align 8
  br label %if.end.31

if.else.27:                                       ; preds = %lor.lhs.false.20
  %42 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings28 = getelementptr inbounds %struct.cop, %struct.cop* %42, i32 0, i32 14
  %43 = load %struct.sv*, %struct.sv** %cop_warnings28, align 8
  %call29 = call %struct.sv* @Perl_newSVsv(%struct.sv* %43)
  %44 = load %struct.cop*, %struct.cop** %cop, align 8
  %cop_warnings30 = getelementptr inbounds %struct.cop, %struct.cop* %44, i32 0, i32 14
  store %struct.sv* %call29, %struct.sv** %cop_warnings30, align 8
  br label %if.end.31

if.end.31:                                        ; preds = %if.else.27, %if.then.24
  %45 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_io = getelementptr inbounds %struct.cop, %struct.cop* %45, i32 0, i32 15
  %46 = load %struct.sv*, %struct.sv** %cop_io, align 8
  %cmp32 = icmp eq %struct.sv* %46, null
  br i1 %cmp32, label %if.then.34, label %if.else.37

if.then.34:                                       ; preds = %if.end.31
  %47 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_io35 = getelementptr inbounds %struct.cop, %struct.cop* %47, i32 0, i32 15
  %48 = load %struct.sv*, %struct.sv** %cop_io35, align 8
  %49 = load %struct.cop*, %struct.cop** %cop, align 8
  %cop_io36 = getelementptr inbounds %struct.cop, %struct.cop* %49, i32 0, i32 15
  store %struct.sv* %48, %struct.sv** %cop_io36, align 8
  br label %if.end.41

if.else.37:                                       ; preds = %if.end.31
  %50 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_io38 = getelementptr inbounds %struct.cop, %struct.cop* %50, i32 0, i32 15
  %51 = load %struct.sv*, %struct.sv** %cop_io38, align 8
  %call39 = call %struct.sv* @Perl_newSVsv(%struct.sv* %51)
  %52 = load %struct.cop*, %struct.cop** %cop, align 8
  %cop_io40 = getelementptr inbounds %struct.cop, %struct.cop* %52, i32 0, i32 15
  store %struct.sv* %call39, %struct.sv** %cop_io40, align 8
  br label %if.end.41

if.end.41:                                        ; preds = %if.else.37, %if.then.34
  %53 = load i32, i32* @PL_copline, align 4
  %cmp42 = icmp eq i32 %53, -1
  br i1 %cmp42, label %if.then.44, label %if.else.47

if.then.44:                                       ; preds = %if.end.41
  %54 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_line45 = getelementptr inbounds %struct.cop, %struct.cop* %54, i32 0, i32 13
  %55 = load i32, i32* %cop_line45, align 4
  %56 = load %struct.cop*, %struct.cop** %cop, align 8
  %cop_line46 = getelementptr inbounds %struct.cop, %struct.cop* %56, i32 0, i32 13
  store i32 %55, i32* %cop_line46, align 4
  br label %if.end.49

if.else.47:                                       ; preds = %if.end.41
  %57 = load i32, i32* @PL_copline, align 4
  %58 = load %struct.cop*, %struct.cop** %cop, align 8
  %cop_line48 = getelementptr inbounds %struct.cop, %struct.cop* %58, i32 0, i32 13
  store i32 %57, i32* %cop_line48, align 4
  store i32 -1, i32* @PL_copline, align 4
  br label %if.end.49

if.end.49:                                        ; preds = %if.else.47, %if.then.44
  %59 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_filegv = getelementptr inbounds %struct.cop, %struct.cop* %59, i32 0, i32 10
  %60 = load %struct.gv*, %struct.gv** %cop_filegv, align 8
  %61 = bitcast %struct.gv* %60 to %struct.sv*
  store %struct.sv* %61, %struct.sv** @PL_Sv, align 8
  %62 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %tobool50 = icmp ne %struct.sv* %62, null
  br i1 %tobool50, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end.49
  %63 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_refcnt = getelementptr inbounds %struct.sv, %struct.sv* %63, i32 0, i32 1
  %64 = load i32, i32* %sv_refcnt, align 4
  %inc = add i32 %64, 1
  store i32 %inc, i32* %sv_refcnt, align 4
  %tobool51 = icmp ne i32 %inc, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end.49
  %65 = phi i1 [ false, %if.end.49 ], [ %tobool51, %land.rhs ]
  %land.ext = zext i1 %65 to i32
  %66 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %67 = bitcast %struct.sv* %66 to %struct.gv*
  %68 = load %struct.cop*, %struct.cop** %cop, align 8
  %cop_filegv52 = getelementptr inbounds %struct.cop, %struct.cop* %68, i32 0, i32 10
  store %struct.gv* %67, %struct.gv** %cop_filegv52, align 8
  %69 = load %struct.hv*, %struct.hv** @PL_curstash, align 8
  %70 = load %struct.cop*, %struct.cop** %cop, align 8
  %cop_stash = getelementptr inbounds %struct.cop, %struct.cop* %70, i32 0, i32 9
  store %struct.hv* %69, %struct.hv** %cop_stash, align 8
  %71 = load i32, i32* @PL_perldb, align 4
  %tobool53 = icmp ne i32 %71, 0
  br i1 %tobool53, label %land.lhs.true.54, label %if.end.82

land.lhs.true.54:                                 ; preds = %land.end
  %72 = load i32, i32* @PL_perldb, align 4
  %and55 = and i32 %72, 2
  %tobool56 = icmp ne i32 %and55, 0
  br i1 %tobool56, label %land.lhs.true.57, label %if.end.82

land.lhs.true.57:                                 ; preds = %land.lhs.true.54
  %73 = load %struct.hv*, %struct.hv** @PL_curstash, align 8
  %74 = load %struct.hv*, %struct.hv** @PL_debstash, align 8
  %cmp58 = icmp ne %struct.hv* %73, %74
  br i1 %cmp58, label %if.then.60, label %if.end.82

if.then.60:                                       ; preds = %land.lhs.true.57
  %75 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_filegv61 = getelementptr inbounds %struct.cop, %struct.cop* %75, i32 0, i32 10
  %76 = load %struct.gv*, %struct.gv** %cop_filegv61, align 8
  %tobool62 = icmp ne %struct.gv* %76, null
  br i1 %tobool62, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.60
  %77 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_filegv63 = getelementptr inbounds %struct.cop, %struct.cop* %77, i32 0, i32 10
  %78 = load %struct.gv*, %struct.gv** %cop_filegv63, align 8
  %sv_any = getelementptr inbounds %struct.gv, %struct.gv* %78, i32 0, i32 0
  %79 = load %struct.xpvgv*, %struct.xpvgv** %sv_any, align 8
  %xgv_gp = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %79, i32 0, i32 7
  %80 = load %struct.gp*, %struct.gp** %xgv_gp, align 8
  %gp_av = getelementptr inbounds %struct.gp, %struct.gp* %80, i32 0, i32 4
  %81 = load %struct.av*, %struct.av** %gp_av, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then.60
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.av* [ %81, %cond.true ], [ null, %cond.false ]
  %82 = load %struct.cop*, %struct.cop** %cop, align 8
  %cop_line64 = getelementptr inbounds %struct.cop, %struct.cop* %82, i32 0, i32 13
  %83 = load i32, i32* %cop_line64, align 4
  %call65 = call %struct.sv** @Perl_av_fetch(%struct.av* %cond, i32 %83, i32 0)
  store %struct.sv** %call65, %struct.sv*** %svp, align 8
  %84 = load %struct.sv**, %struct.sv*** %svp, align 8
  %tobool66 = icmp ne %struct.sv** %84, null
  br i1 %tobool66, label %land.lhs.true.67, label %if.end.81

land.lhs.true.67:                                 ; preds = %cond.end
  %85 = load %struct.sv**, %struct.sv*** %svp, align 8
  %86 = load %struct.sv*, %struct.sv** %85, align 8
  %cmp68 = icmp ne %struct.sv* %86, @PL_sv_undef
  br i1 %cmp68, label %if.then.70, label %if.end.81

if.then.70:                                       ; preds = %land.lhs.true.67
  %87 = load %struct.sv**, %struct.sv*** %svp, align 8
  %88 = load %struct.sv*, %struct.sv** %87, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %88, i32 0, i32 2
  %89 = load i32, i32* %sv_flags, align 4
  %and71 = and i32 %89, 2097152
  %tobool72 = icmp ne i32 %and71, 0
  br i1 %tobool72, label %land.rhs.73, label %land.end.76

land.rhs.73:                                      ; preds = %if.then.70
  %90 = load %struct.sv**, %struct.sv*** %svp, align 8
  %91 = load %struct.sv*, %struct.sv** %90, align 8
  %call74 = call i32 @Perl_sv_backoff(%struct.sv* %91)
  %tobool75 = icmp ne i32 %call74, 0
  br label %land.end.76

land.end.76:                                      ; preds = %land.rhs.73, %if.then.70
  %92 = phi i1 [ false, %if.then.70 ], [ %tobool75, %land.rhs.73 ]
  %land.ext77 = zext i1 %92 to i32
  %93 = load %struct.sv**, %struct.sv*** %svp, align 8
  %94 = load %struct.sv*, %struct.sv** %93, align 8
  %sv_flags78 = getelementptr inbounds %struct.sv, %struct.sv* %94, i32 0, i32 2
  %95 = load i32, i32* %sv_flags78, align 4
  %or79 = or i32 %95, 16842752
  store i32 %or79, i32* %sv_flags78, align 4
  %96 = load %struct.cop*, %struct.cop** %cop, align 8
  %97 = ptrtoint %struct.cop* %96 to i64
  %98 = load %struct.sv**, %struct.sv*** %svp, align 8
  %99 = load %struct.sv*, %struct.sv** %98, align 8
  %sv_any80 = getelementptr inbounds %struct.sv, %struct.sv* %99, i32 0, i32 0
  %100 = load i8*, i8** %sv_any80, align 8
  %101 = bitcast i8* %100 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %101, i32 0, i32 3
  store i64 %97, i64* %xiv_iv, align 8
  br label %if.end.81

if.end.81:                                        ; preds = %land.end.76, %land.lhs.true.67, %cond.end
  br label %if.end.82

if.end.82:                                        ; preds = %if.end.81, %land.lhs.true.57, %land.lhs.true.54, %land.end
  %102 = load %struct.cop*, %struct.cop** %cop, align 8
  %103 = bitcast %struct.cop* %102 to %struct.op*
  %104 = load %struct.op*, %struct.op** %o.addr, align 8
  %call83 = call %struct.op* @Perl_prepend_elem(i32 173, %struct.op* %103, %struct.op* %104)
  ret %struct.op* %call83
}

; Function Attrs: nounwind
declare void @llvm.va_start(i8*) #2

; Function Attrs: nounwind uwtable
define void @Perl_vload_module(i32 %flags, %struct.sv* %name, %struct.sv* %ver, [1 x %struct.__va_list_tag]* %args) #0 {
entry:
  %flags.addr = alloca i32, align 4
  %name.addr = alloca %struct.sv*, align 8
  %ver.addr = alloca %struct.sv*, align 8
  %args.addr = alloca [1 x %struct.__va_list_tag]*, align 8
  %modname = alloca %struct.op*, align 8
  %veop = alloca %struct.op*, align 8
  %imop = alloca %struct.op*, align 8
  %sv = alloca %struct.sv*, align 8
  %ocopline = alloca i32, align 4
  %ocurcop = alloca %struct.cop*, align 8
  %oexpect = alloca i32, align 4
  store i32 %flags, i32* %flags.addr, align 4
  store %struct.sv* %name, %struct.sv** %name.addr, align 8
  store %struct.sv* %ver, %struct.sv** %ver.addr, align 8
  store [1 x %struct.__va_list_tag]* %args, [1 x %struct.__va_list_tag]** %args.addr, align 8
  %0 = load %struct.sv*, %struct.sv** %name.addr, align 8
  %call = call %struct.op* @Perl_newSVOP(i32 5, i32 0, %struct.sv* %0)
  store %struct.op* %call, %struct.op** %modname, align 8
  %1 = load %struct.op*, %struct.op** %modname, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 7
  %2 = load i8, i8* %op_private, align 1
  %conv = zext i8 %2 to i32
  %or = or i32 %conv, 64
  %conv1 = trunc i32 %or to i8
  store i8 %conv1, i8* %op_private, align 1
  %3 = load %struct.sv*, %struct.sv** %ver.addr, align 8
  %tobool = icmp ne %struct.sv* %3, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %4 = load %struct.sv*, %struct.sv** %ver.addr, align 8
  %call2 = call %struct.op* @Perl_newSVOP(i32 5, i32 0, %struct.sv* %4)
  store %struct.op* %call2, %struct.op** %veop, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  store %struct.op* null, %struct.op** %veop, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %5 = load i32, i32* %flags.addr, align 4
  %and = and i32 %5, 2
  %tobool3 = icmp ne i32 %and, 0
  br i1 %tobool3, label %if.then.4, label %if.else.7

if.then.4:                                        ; preds = %if.end
  %call5 = call %struct.op* @Perl_newNULLLIST()
  %call6 = call %struct.op* @Perl_sawparens(%struct.op* %call5)
  store %struct.op* %call6, %struct.op** %imop, align 8
  br label %if.end.40

if.else.7:                                        ; preds = %if.end
  %6 = load i32, i32* %flags.addr, align 4
  %and8 = and i32 %6, 4
  %tobool9 = icmp ne i32 %and8, 0
  br i1 %tobool9, label %if.then.10, label %if.else.11

if.then.10:                                       ; preds = %if.else.7
  %7 = load [1 x %struct.__va_list_tag]*, [1 x %struct.__va_list_tag]** %args.addr, align 8
  %arraydecay = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %7, i32 0, i32 0
  %gp_offset_p = getelementptr inbounds %struct.__va_list_tag, %struct.__va_list_tag* %arraydecay, i32 0, i32 0
  %gp_offset = load i32, i32* %gp_offset_p
  %fits_in_gp = icmp ule i32 %gp_offset, 40
  br i1 %fits_in_gp, label %vaarg.in_reg, label %vaarg.in_mem

vaarg.in_reg:                                     ; preds = %if.then.10
  %8 = getelementptr inbounds %struct.__va_list_tag, %struct.__va_list_tag* %arraydecay, i32 0, i32 3
  %reg_save_area = load i8*, i8** %8
  %9 = getelementptr i8, i8* %reg_save_area, i32 %gp_offset
  %10 = bitcast i8* %9 to %struct.op**
  %11 = add i32 %gp_offset, 8
  store i32 %11, i32* %gp_offset_p
  br label %vaarg.end

vaarg.in_mem:                                     ; preds = %if.then.10
  %overflow_arg_area_p = getelementptr inbounds %struct.__va_list_tag, %struct.__va_list_tag* %arraydecay, i32 0, i32 2
  %overflow_arg_area = load i8*, i8** %overflow_arg_area_p
  %12 = bitcast i8* %overflow_arg_area to %struct.op**
  %overflow_arg_area.next = getelementptr i8, i8* %overflow_arg_area, i32 8
  store i8* %overflow_arg_area.next, i8** %overflow_arg_area_p
  br label %vaarg.end

vaarg.end:                                        ; preds = %vaarg.in_mem, %vaarg.in_reg
  %vaarg.addr = phi %struct.op** [ %10, %vaarg.in_reg ], [ %12, %vaarg.in_mem ]
  %13 = load %struct.op*, %struct.op** %vaarg.addr
  store %struct.op* %13, %struct.op** %imop, align 8
  br label %if.end.39

if.else.11:                                       ; preds = %if.else.7
  store %struct.op* null, %struct.op** %imop, align 8
  %14 = load [1 x %struct.__va_list_tag]*, [1 x %struct.__va_list_tag]** %args.addr, align 8
  %arraydecay12 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %14, i32 0, i32 0
  %gp_offset_p13 = getelementptr inbounds %struct.__va_list_tag, %struct.__va_list_tag* %arraydecay12, i32 0, i32 0
  %gp_offset14 = load i32, i32* %gp_offset_p13
  %fits_in_gp15 = icmp ule i32 %gp_offset14, 40
  br i1 %fits_in_gp15, label %vaarg.in_reg.16, label %vaarg.in_mem.18

vaarg.in_reg.16:                                  ; preds = %if.else.11
  %15 = getelementptr inbounds %struct.__va_list_tag, %struct.__va_list_tag* %arraydecay12, i32 0, i32 3
  %reg_save_area17 = load i8*, i8** %15
  %16 = getelementptr i8, i8* %reg_save_area17, i32 %gp_offset14
  %17 = bitcast i8* %16 to %struct.sv**
  %18 = add i32 %gp_offset14, 8
  store i32 %18, i32* %gp_offset_p13
  br label %vaarg.end.22

vaarg.in_mem.18:                                  ; preds = %if.else.11
  %overflow_arg_area_p19 = getelementptr inbounds %struct.__va_list_tag, %struct.__va_list_tag* %arraydecay12, i32 0, i32 2
  %overflow_arg_area20 = load i8*, i8** %overflow_arg_area_p19
  %19 = bitcast i8* %overflow_arg_area20 to %struct.sv**
  %overflow_arg_area.next21 = getelementptr i8, i8* %overflow_arg_area20, i32 8
  store i8* %overflow_arg_area.next21, i8** %overflow_arg_area_p19
  br label %vaarg.end.22

vaarg.end.22:                                     ; preds = %vaarg.in_mem.18, %vaarg.in_reg.16
  %vaarg.addr23 = phi %struct.sv** [ %17, %vaarg.in_reg.16 ], [ %19, %vaarg.in_mem.18 ]
  %20 = load %struct.sv*, %struct.sv** %vaarg.addr23
  store %struct.sv* %20, %struct.sv** %sv, align 8
  br label %while.cond

while.cond:                                       ; preds = %vaarg.end.37, %vaarg.end.22
  %21 = load %struct.sv*, %struct.sv** %sv, align 8
  %tobool24 = icmp ne %struct.sv* %21, null
  br i1 %tobool24, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %22 = load %struct.op*, %struct.op** %imop, align 8
  %23 = load %struct.sv*, %struct.sv** %sv, align 8
  %call25 = call %struct.op* @Perl_newSVOP(i32 5, i32 0, %struct.sv* %23)
  %call26 = call %struct.op* @Perl_append_elem(i32 141, %struct.op* %22, %struct.op* %call25)
  store %struct.op* %call26, %struct.op** %imop, align 8
  %24 = load [1 x %struct.__va_list_tag]*, [1 x %struct.__va_list_tag]** %args.addr, align 8
  %arraydecay27 = getelementptr inbounds [1 x %struct.__va_list_tag], [1 x %struct.__va_list_tag]* %24, i32 0, i32 0
  %gp_offset_p28 = getelementptr inbounds %struct.__va_list_tag, %struct.__va_list_tag* %arraydecay27, i32 0, i32 0
  %gp_offset29 = load i32, i32* %gp_offset_p28
  %fits_in_gp30 = icmp ule i32 %gp_offset29, 40
  br i1 %fits_in_gp30, label %vaarg.in_reg.31, label %vaarg.in_mem.33

vaarg.in_reg.31:                                  ; preds = %while.body
  %25 = getelementptr inbounds %struct.__va_list_tag, %struct.__va_list_tag* %arraydecay27, i32 0, i32 3
  %reg_save_area32 = load i8*, i8** %25
  %26 = getelementptr i8, i8* %reg_save_area32, i32 %gp_offset29
  %27 = bitcast i8* %26 to %struct.sv**
  %28 = add i32 %gp_offset29, 8
  store i32 %28, i32* %gp_offset_p28
  br label %vaarg.end.37

vaarg.in_mem.33:                                  ; preds = %while.body
  %overflow_arg_area_p34 = getelementptr inbounds %struct.__va_list_tag, %struct.__va_list_tag* %arraydecay27, i32 0, i32 2
  %overflow_arg_area35 = load i8*, i8** %overflow_arg_area_p34
  %29 = bitcast i8* %overflow_arg_area35 to %struct.sv**
  %overflow_arg_area.next36 = getelementptr i8, i8* %overflow_arg_area35, i32 8
  store i8* %overflow_arg_area.next36, i8** %overflow_arg_area_p34
  br label %vaarg.end.37

vaarg.end.37:                                     ; preds = %vaarg.in_mem.33, %vaarg.in_reg.31
  %vaarg.addr38 = phi %struct.sv** [ %27, %vaarg.in_reg.31 ], [ %29, %vaarg.in_mem.33 ]
  %30 = load %struct.sv*, %struct.sv** %vaarg.addr38
  store %struct.sv* %30, %struct.sv** %sv, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  br label %if.end.39

if.end.39:                                        ; preds = %while.end, %vaarg.end
  br label %if.end.40

if.end.40:                                        ; preds = %if.end.39, %if.then.4
  %31 = load i32, i32* @PL_copline, align 4
  store i32 %31, i32* %ocopline, align 4
  %32 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  store %struct.cop* %32, %struct.cop** %ocurcop, align 8
  %33 = load i32, i32* @PL_expect, align 4
  store i32 %33, i32* %oexpect, align 4
  %34 = load i32, i32* %flags.addr, align 4
  %and41 = and i32 %34, 1
  %tobool42 = icmp ne i32 %and41, 0
  %lnot = xor i1 %tobool42, true
  %lnot.ext = zext i1 %lnot to i32
  %call43 = call i32 @Perl_start_subparse(i32 0, i32 0)
  %35 = load %struct.op*, %struct.op** %veop, align 8
  %36 = load %struct.op*, %struct.op** %modname, align 8
  %37 = load %struct.op*, %struct.op** %imop, align 8
  call void @Perl_utilize(i32 %lnot.ext, i32 %call43, %struct.op* %35, %struct.op* %36, %struct.op* %37)
  %38 = load i32, i32* %oexpect, align 4
  store i32 %38, i32* @PL_expect, align 4
  %39 = load i32, i32* %ocopline, align 4
  store i32 %39, i32* @PL_copline, align 4
  %40 = load %struct.cop*, %struct.cop** %ocurcop, align 8
  store volatile %struct.cop* %40, %struct.cop** @PL_curcop, align 8
  ret void
}

; Function Attrs: nounwind
declare void @llvm.va_end(i8*) #2

declare i32 @Perl_start_subparse(i32, i32) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_dofile(%struct.op* %term) #0 {
entry:
  %term.addr = alloca %struct.op*, align 8
  %doop = alloca %struct.op*, align 8
  %gv = alloca %struct.gv*, align 8
  store %struct.op* %term, %struct.op** %term.addr, align 8
  %call = call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.52, i32 0, i32 0), i32 0, i32 12)
  store %struct.gv* %call, %struct.gv** %gv, align 8
  %0 = load %struct.gv*, %struct.gv** %gv, align 8
  %tobool = icmp ne %struct.gv* %0, null
  br i1 %tobool, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %entry
  %1 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any = getelementptr inbounds %struct.gv, %struct.gv* %1, i32 0, i32 0
  %2 = load %struct.xpvgv*, %struct.xpvgv** %sv_any, align 8
  %xgv_gp = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %2, i32 0, i32 7
  %3 = load %struct.gp*, %struct.gp** %xgv_gp, align 8
  %gp_cvgen = getelementptr inbounds %struct.gp, %struct.gp* %3, i32 0, i32 8
  %4 = load i32, i32* %gp_cvgen, align 4
  %tobool1 = icmp ne i32 %4, 0
  br i1 %tobool1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true
  br i1 false, label %land.lhs.true.5, label %if.then

cond.false:                                       ; preds = %land.lhs.true
  %5 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any2 = getelementptr inbounds %struct.gv, %struct.gv* %5, i32 0, i32 0
  %6 = load %struct.xpvgv*, %struct.xpvgv** %sv_any2, align 8
  %xgv_gp3 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %6, i32 0, i32 7
  %7 = load %struct.gp*, %struct.gp** %xgv_gp3, align 8
  %gp_cv = getelementptr inbounds %struct.gp, %struct.gp* %7, i32 0, i32 7
  %8 = load %struct.cv*, %struct.cv** %gp_cv, align 8
  %tobool4 = icmp ne %struct.cv* %8, null
  br i1 %tobool4, label %land.lhs.true.5, label %if.then

land.lhs.true.5:                                  ; preds = %cond.false, %cond.true
  %9 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any6 = getelementptr inbounds %struct.gv, %struct.gv* %9, i32 0, i32 0
  %10 = load %struct.xpvgv*, %struct.xpvgv** %sv_any6, align 8
  %xgv_flags = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %10, i32 0, i32 11
  %11 = load i8, i8* %xgv_flags, align 1
  %conv = zext i8 %11 to i32
  %and = and i32 %conv, 128
  %tobool7 = icmp ne i32 %and, 0
  br i1 %tobool7, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true.5, %cond.false, %cond.true, %entry
  %call8 = call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.53, i32 0, i32 0), i32 0, i32 12)
  store %struct.gv* %call8, %struct.gv** %gv, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true.5
  %12 = load %struct.gv*, %struct.gv** %gv, align 8
  %tobool9 = icmp ne %struct.gv* %12, null
  br i1 %tobool9, label %land.lhs.true.10, label %if.else

land.lhs.true.10:                                 ; preds = %if.end
  %13 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any11 = getelementptr inbounds %struct.gv, %struct.gv* %13, i32 0, i32 0
  %14 = load %struct.xpvgv*, %struct.xpvgv** %sv_any11, align 8
  %xgv_gp12 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %14, i32 0, i32 7
  %15 = load %struct.gp*, %struct.gp** %xgv_gp12, align 8
  %gp_cvgen13 = getelementptr inbounds %struct.gp, %struct.gp* %15, i32 0, i32 8
  %16 = load i32, i32* %gp_cvgen13, align 4
  %tobool14 = icmp ne i32 %16, 0
  br i1 %tobool14, label %cond.true.15, label %cond.false.16

cond.true.15:                                     ; preds = %land.lhs.true.10
  br i1 false, label %land.lhs.true.21, label %if.else

cond.false.16:                                    ; preds = %land.lhs.true.10
  %17 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any17 = getelementptr inbounds %struct.gv, %struct.gv* %17, i32 0, i32 0
  %18 = load %struct.xpvgv*, %struct.xpvgv** %sv_any17, align 8
  %xgv_gp18 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %18, i32 0, i32 7
  %19 = load %struct.gp*, %struct.gp** %xgv_gp18, align 8
  %gp_cv19 = getelementptr inbounds %struct.gp, %struct.gp* %19, i32 0, i32 7
  %20 = load %struct.cv*, %struct.cv** %gp_cv19, align 8
  %tobool20 = icmp ne %struct.cv* %20, null
  br i1 %tobool20, label %land.lhs.true.21, label %if.else

land.lhs.true.21:                                 ; preds = %cond.false.16, %cond.true.15
  %21 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any22 = getelementptr inbounds %struct.gv, %struct.gv* %21, i32 0, i32 0
  %22 = load %struct.xpvgv*, %struct.xpvgv** %sv_any22, align 8
  %xgv_flags23 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %22, i32 0, i32 11
  %23 = load i8, i8* %xgv_flags23, align 1
  %conv24 = zext i8 %23 to i32
  %and25 = and i32 %conv24, 128
  %tobool26 = icmp ne i32 %and25, 0
  br i1 %tobool26, label %if.then.27, label %if.else

if.then.27:                                       ; preds = %land.lhs.true.21
  %24 = load %struct.op*, %struct.op** %term.addr, align 8
  %25 = load %struct.gv*, %struct.gv** %gv, align 8
  %call28 = call %struct.op* @Perl_newGVOP(i32 7, i32 0, %struct.gv* %25)
  %call29 = call %struct.op* @Perl_newUNOP(i32 17, i32 0, %struct.op* %call28)
  %call30 = call %struct.op* @Perl_scalar(%struct.op* %call29)
  %call31 = call %struct.op* @Perl_append_elem(i32 141, %struct.op* %24, %struct.op* %call30)
  %call32 = call %struct.op* @Perl_newUNOP(i32 166, i32 64, %struct.op* %call31)
  %call33 = call %struct.op* @Perl_ck_subr(%struct.op* %call32)
  store %struct.op* %call33, %struct.op** %doop, align 8
  br label %if.end.36

if.else:                                          ; preds = %land.lhs.true.21, %cond.false.16, %cond.true.15, %if.end
  %26 = load %struct.op*, %struct.op** %term.addr, align 8
  %call34 = call %struct.op* @Perl_scalar(%struct.op* %26)
  %call35 = call %struct.op* @Perl_newUNOP(i32 310, i32 0, %struct.op* %call34)
  store %struct.op* %call35, %struct.op** %doop, align 8
  br label %if.end.36

if.end.36:                                        ; preds = %if.else, %if.then.27
  %27 = load %struct.op*, %struct.op** %doop, align 8
  ret %struct.op* %27
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_subr(%struct.op* %o) #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %o.addr = alloca %struct.op*, align 8
  %prev = alloca %struct.op*, align 8
  %o2 = alloca %struct.op*, align 8
  %cvop = alloca %struct.op*, align 8
  %proto = alloca i8*, align 8
  %cv = alloca %struct.cv*, align 8
  %namegv = alloca %struct.gv*, align 8
  %optional = alloca i32, align 4
  %arg = alloca i32, align 4
  %contextclass = alloca i32, align 4
  %e = alloca i8*, align 8
  %n_a = alloca i64, align 8
  %tmpop = alloca %struct.svop*, align 8
  %gv = alloca %struct.gv*, align 8
  %o88 = alloca %struct.op*, align 8
  %gvop = alloca %struct.op*, align 8
  %gv214 = alloca %struct.gv*, align 8
  %sibling = alloca %struct.op*, align 8
  %n = alloca %struct.sv*, align 8
  %p = alloca i8*, align 8
  %s = alloca i8, align 1
  %kid = alloca %struct.op*, align 8
  %sib = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %1 = bitcast %struct.op* %0 to %struct.unop*
  %op_first = getelementptr inbounds %struct.unop, %struct.unop* %1, i32 0, i32 8
  %2 = load %struct.op*, %struct.op** %op_first, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %2, i32 0, i32 1
  %3 = load %struct.op*, %struct.op** %op_sibling, align 8
  %tobool = icmp ne %struct.op* %3, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %4 = load %struct.op*, %struct.op** %o.addr, align 8
  %5 = bitcast %struct.op* %4 to %struct.unop*
  br label %cond.end

cond.false:                                       ; preds = %entry
  %6 = load %struct.op*, %struct.op** %o.addr, align 8
  %7 = bitcast %struct.op* %6 to %struct.unop*
  %op_first1 = getelementptr inbounds %struct.unop, %struct.unop* %7, i32 0, i32 8
  %8 = load %struct.op*, %struct.op** %op_first1, align 8
  %9 = bitcast %struct.op* %8 to %struct.unop*
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.unop* [ %5, %cond.true ], [ %9, %cond.false ]
  %op_first2 = getelementptr inbounds %struct.unop, %struct.unop* %cond, i32 0, i32 8
  %10 = load %struct.op*, %struct.op** %op_first2, align 8
  store %struct.op* %10, %struct.op** %prev, align 8
  %11 = load %struct.op*, %struct.op** %prev, align 8
  %op_sibling3 = getelementptr inbounds %struct.op, %struct.op* %11, i32 0, i32 1
  %12 = load %struct.op*, %struct.op** %op_sibling3, align 8
  store %struct.op* %12, %struct.op** %o2, align 8
  store i8* null, i8** %proto, align 8
  store %struct.cv* null, %struct.cv** %cv, align 8
  store %struct.gv* null, %struct.gv** %namegv, align 8
  store i32 0, i32* %optional, align 4
  store i32 0, i32* %arg, align 4
  store i32 0, i32* %contextclass, align 4
  store i8* null, i8** %e, align 8
  %13 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %13, i32 0, i32 7
  %14 = load i8, i8* %op_private, align 1
  %conv = zext i8 %14 to i32
  %or = or i32 %conv, 32
  %conv4 = trunc i32 %or to i8
  store i8 %conv4, i8* %op_private, align 1
  %15 = load %struct.op*, %struct.op** %o2, align 8
  store %struct.op* %15, %struct.op** %cvop, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %16 = load %struct.op*, %struct.op** %cvop, align 8
  %op_sibling5 = getelementptr inbounds %struct.op, %struct.op* %16, i32 0, i32 1
  %17 = load %struct.op*, %struct.op** %op_sibling5, align 8
  %tobool6 = icmp ne %struct.op* %17, null
  br i1 %tobool6, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %18 = load %struct.op*, %struct.op** %cvop, align 8
  %op_sibling7 = getelementptr inbounds %struct.op, %struct.op* %18, i32 0, i32 1
  %19 = load %struct.op*, %struct.op** %op_sibling7, align 8
  store %struct.op* %19, %struct.op** %cvop, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %20 = load %struct.op*, %struct.op** %cvop, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %20, i32 0, i32 4
  %21 = load i16, i16* %op_type, align 2
  %conv8 = zext i16 %21 to i32
  %cmp = icmp eq i32 %conv8, 17
  br i1 %cmp, label %if.then, label %if.else.63

if.then:                                          ; preds = %for.end
  %22 = load %struct.op*, %struct.op** %cvop, align 8
  %op_private10 = getelementptr inbounds %struct.op, %struct.op* %22, i32 0, i32 7
  %23 = load i8, i8* %op_private10, align 1
  %conv11 = zext i8 %23 to i32
  %and = and i32 %conv11, 8
  %24 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private12 = getelementptr inbounds %struct.op, %struct.op* %24, i32 0, i32 7
  %25 = load i8, i8* %op_private12, align 1
  %conv13 = zext i8 %25 to i32
  %or14 = or i32 %conv13, %and
  %conv15 = trunc i32 %or14 to i8
  store i8 %conv15, i8* %op_private12, align 1
  %26 = load %struct.op*, %struct.op** %cvop, align 8
  call void @Perl_op_null(%struct.op* %26)
  %27 = load %struct.op*, %struct.op** %cvop, align 8
  %28 = bitcast %struct.op* %27 to %struct.unop*
  %op_first16 = getelementptr inbounds %struct.unop, %struct.unop* %28, i32 0, i32 8
  %29 = load %struct.op*, %struct.op** %op_first16, align 8
  %30 = bitcast %struct.op* %29 to %struct.svop*
  store %struct.svop* %30, %struct.svop** %tmpop, align 8
  %31 = load %struct.svop*, %struct.svop** %tmpop, align 8
  %op_type17 = getelementptr inbounds %struct.svop, %struct.svop* %31, i32 0, i32 4
  %32 = load i16, i16* %op_type17, align 2
  %conv18 = zext i16 %32 to i32
  %cmp19 = icmp eq i32 %conv18, 7
  br i1 %cmp19, label %land.lhs.true, label %if.end.62

land.lhs.true:                                    ; preds = %if.then
  %33 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private21 = getelementptr inbounds %struct.op, %struct.op* %33, i32 0, i32 7
  %34 = load i8, i8* %op_private21, align 1
  %conv22 = zext i8 %34 to i32
  %and23 = and i32 %conv22, 8
  %tobool24 = icmp ne i32 %and23, 0
  br i1 %tobool24, label %if.end.62, label %if.then.25

if.then.25:                                       ; preds = %land.lhs.true
  %35 = load %struct.svop*, %struct.svop** %tmpop, align 8
  %op_sv = getelementptr inbounds %struct.svop, %struct.svop* %35, i32 0, i32 8
  %36 = load %struct.sv*, %struct.sv** %op_sv, align 8
  %37 = bitcast %struct.sv* %36 to %struct.gv*
  store %struct.gv* %37, %struct.gv** %gv, align 8
  %38 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any = getelementptr inbounds %struct.gv, %struct.gv* %38, i32 0, i32 0
  %39 = load %struct.xpvgv*, %struct.xpvgv** %sv_any, align 8
  %xgv_gp = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %39, i32 0, i32 7
  %40 = load %struct.gp*, %struct.gp** %xgv_gp, align 8
  %gp_cvgen = getelementptr inbounds %struct.gp, %struct.gp* %40, i32 0, i32 8
  %41 = load i32, i32* %gp_cvgen, align 4
  %tobool26 = icmp ne i32 %41, 0
  br i1 %tobool26, label %cond.true.27, label %cond.false.28

cond.true.27:                                     ; preds = %if.then.25
  br label %cond.end.31

cond.false.28:                                    ; preds = %if.then.25
  %42 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any29 = getelementptr inbounds %struct.gv, %struct.gv* %42, i32 0, i32 0
  %43 = load %struct.xpvgv*, %struct.xpvgv** %sv_any29, align 8
  %xgv_gp30 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %43, i32 0, i32 7
  %44 = load %struct.gp*, %struct.gp** %xgv_gp30, align 8
  %gp_cv = getelementptr inbounds %struct.gp, %struct.gp* %44, i32 0, i32 7
  %45 = load %struct.cv*, %struct.cv** %gp_cv, align 8
  br label %cond.end.31

cond.end.31:                                      ; preds = %cond.false.28, %cond.true.27
  %cond32 = phi %struct.cv* [ null, %cond.true.27 ], [ %45, %cond.false.28 ]
  store %struct.cv* %cond32, %struct.cv** %cv, align 8
  %46 = load %struct.cv*, %struct.cv** %cv, align 8
  %tobool33 = icmp ne %struct.cv* %46, null
  br i1 %tobool33, label %if.else, label %if.then.34

if.then.34:                                       ; preds = %cond.end.31
  %47 = load %struct.svop*, %struct.svop** %tmpop, align 8
  %op_private35 = getelementptr inbounds %struct.svop, %struct.svop* %47, i32 0, i32 7
  %48 = load i8, i8* %op_private35, align 1
  %conv36 = zext i8 %48 to i32
  %or37 = or i32 %conv36, 32
  %conv38 = trunc i32 %or37 to i8
  store i8 %conv38, i8* %op_private35, align 1
  br label %if.end.61

if.else:                                          ; preds = %cond.end.31
  %49 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_flags = getelementptr inbounds %struct.cv, %struct.cv* %49, i32 0, i32 2
  %50 = load i32, i32* %sv_flags, align 4
  %and39 = and i32 %50, 262144
  %tobool40 = icmp ne i32 %and39, 0
  br i1 %tobool40, label %if.then.41, label %if.end

if.then.41:                                       ; preds = %if.else
  %51 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any42 = getelementptr inbounds %struct.cv, %struct.cv* %51, i32 0, i32 0
  %52 = load %struct.xpvcv*, %struct.xpvcv** %sv_any42, align 8
  %xcv_flags = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %52, i32 0, i32 17
  %53 = load i16, i16* %xcv_flags, align 2
  %conv43 = zext i16 %53 to i32
  %and44 = and i32 %conv43, 4
  %tobool45 = icmp ne i32 %and44, 0
  br i1 %tobool45, label %cond.true.46, label %cond.false.47

cond.true.46:                                     ; preds = %if.then.41
  %54 = load %struct.gv*, %struct.gv** %gv, align 8
  br label %cond.end.49

cond.false.47:                                    ; preds = %if.then.41
  %55 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any48 = getelementptr inbounds %struct.cv, %struct.cv* %55, i32 0, i32 0
  %56 = load %struct.xpvcv*, %struct.xpvcv** %sv_any48, align 8
  %xcv_gv = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %56, i32 0, i32 12
  %57 = load %struct.gv*, %struct.gv** %xcv_gv, align 8
  br label %cond.end.49

cond.end.49:                                      ; preds = %cond.false.47, %cond.true.46
  %cond50 = phi %struct.gv* [ %54, %cond.true.46 ], [ %57, %cond.false.47 ]
  store %struct.gv* %cond50, %struct.gv** %namegv, align 8
  %58 = load %struct.cv*, %struct.cv** %cv, align 8
  %59 = bitcast %struct.cv* %58 to %struct.sv*
  %sv_flags51 = getelementptr inbounds %struct.sv, %struct.sv* %59, i32 0, i32 2
  %60 = load i32, i32* %sv_flags51, align 4
  %and52 = and i32 %60, 262144
  %cmp53 = icmp eq i32 %and52, 262144
  br i1 %cmp53, label %cond.true.55, label %cond.false.58

cond.true.55:                                     ; preds = %cond.end.49
  %61 = load %struct.cv*, %struct.cv** %cv, align 8
  %62 = bitcast %struct.cv* %61 to %struct.sv*
  %sv_any56 = getelementptr inbounds %struct.sv, %struct.sv* %62, i32 0, i32 0
  %63 = load i8*, i8** %sv_any56, align 8
  %64 = bitcast i8* %63 to %struct.xpv*
  %xpv_cur = getelementptr inbounds %struct.xpv, %struct.xpv* %64, i32 0, i32 1
  %65 = load i64, i64* %xpv_cur, align 8
  store i64 %65, i64* %n_a, align 8
  %66 = load %struct.cv*, %struct.cv** %cv, align 8
  %67 = bitcast %struct.cv* %66 to %struct.sv*
  %sv_any57 = getelementptr inbounds %struct.sv, %struct.sv* %67, i32 0, i32 0
  %68 = load i8*, i8** %sv_any57, align 8
  %69 = bitcast i8* %68 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %69, i32 0, i32 0
  %70 = load i8*, i8** %xpv_pv, align 8
  br label %cond.end.59

cond.false.58:                                    ; preds = %cond.end.49
  %71 = load %struct.cv*, %struct.cv** %cv, align 8
  %72 = bitcast %struct.cv* %71 to %struct.sv*
  %call = call i8* @Perl_sv_2pv_flags(%struct.sv* %72, i64* %n_a, i32 2)
  br label %cond.end.59

cond.end.59:                                      ; preds = %cond.false.58, %cond.true.55
  %cond60 = phi i8* [ %70, %cond.true.55 ], [ %call, %cond.false.58 ]
  store i8* %cond60, i8** %proto, align 8
  br label %if.end

if.end:                                           ; preds = %cond.end.59, %if.else
  br label %if.end.61

if.end.61:                                        ; preds = %if.end, %if.then.34
  br label %if.end.62

if.end.62:                                        ; preds = %if.end.61, %land.lhs.true, %if.then
  br label %if.end.106

if.else.63:                                       ; preds = %for.end
  %73 = load %struct.op*, %struct.op** %cvop, align 8
  %op_type64 = getelementptr inbounds %struct.op, %struct.op* %73, i32 0, i32 4
  %74 = load i16, i16* %op_type64, align 2
  %conv65 = zext i16 %74 to i32
  %cmp66 = icmp eq i32 %conv65, 165
  br i1 %cmp66, label %if.then.72, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else.63
  %75 = load %struct.op*, %struct.op** %cvop, align 8
  %op_type68 = getelementptr inbounds %struct.op, %struct.op* %75, i32 0, i32 4
  %76 = load i16, i16* %op_type68, align 2
  %conv69 = zext i16 %76 to i32
  %cmp70 = icmp eq i32 %conv69, 350
  br i1 %cmp70, label %if.then.72, label %if.end.105

if.then.72:                                       ; preds = %lor.lhs.false, %if.else.63
  %77 = load %struct.op*, %struct.op** %o2, align 8
  %op_type73 = getelementptr inbounds %struct.op, %struct.op* %77, i32 0, i32 4
  %78 = load i16, i16* %op_type73, align 2
  %conv74 = zext i16 %78 to i32
  %cmp75 = icmp eq i32 %conv74, 5
  br i1 %cmp75, label %if.then.77, label %if.else.82

if.then.77:                                       ; preds = %if.then.72
  %79 = load %struct.op*, %struct.op** %o2, align 8
  %op_private78 = getelementptr inbounds %struct.op, %struct.op* %79, i32 0, i32 7
  %80 = load i8, i8* %op_private78, align 1
  %conv79 = zext i8 %80 to i32
  %and80 = and i32 %conv79, -9
  %conv81 = trunc i32 %and80 to i8
  store i8 %conv81, i8* %op_private78, align 1
  br label %if.end.104

if.else.82:                                       ; preds = %if.then.72
  %81 = load %struct.op*, %struct.op** %o2, align 8
  %op_type83 = getelementptr inbounds %struct.op, %struct.op* %81, i32 0, i32 4
  %82 = load i16, i16* %op_type83, align 2
  %conv84 = zext i16 %82 to i32
  %cmp85 = icmp eq i32 %conv84, 141
  br i1 %cmp85, label %if.then.87, label %if.end.103

if.then.87:                                       ; preds = %if.else.82
  %83 = load %struct.op*, %struct.op** %o2, align 8
  %84 = bitcast %struct.op* %83 to %struct.unop*
  %op_first89 = getelementptr inbounds %struct.unop, %struct.unop* %84, i32 0, i32 8
  %85 = load %struct.op*, %struct.op** %op_first89, align 8
  %op_sibling90 = getelementptr inbounds %struct.op, %struct.op* %85, i32 0, i32 1
  %86 = load %struct.op*, %struct.op** %op_sibling90, align 8
  store %struct.op* %86, %struct.op** %o88, align 8
  %87 = load %struct.op*, %struct.op** %o88, align 8
  %tobool91 = icmp ne %struct.op* %87, null
  br i1 %tobool91, label %land.lhs.true.92, label %if.end.102

land.lhs.true.92:                                 ; preds = %if.then.87
  %88 = load %struct.op*, %struct.op** %o88, align 8
  %op_type93 = getelementptr inbounds %struct.op, %struct.op* %88, i32 0, i32 4
  %89 = load i16, i16* %op_type93, align 2
  %conv94 = zext i16 %89 to i32
  %cmp95 = icmp eq i32 %conv94, 5
  br i1 %cmp95, label %if.then.97, label %if.end.102

if.then.97:                                       ; preds = %land.lhs.true.92
  %90 = load %struct.op*, %struct.op** %o88, align 8
  %op_private98 = getelementptr inbounds %struct.op, %struct.op* %90, i32 0, i32 7
  %91 = load i8, i8* %op_private98, align 1
  %conv99 = zext i8 %91 to i32
  %and100 = and i32 %conv99, -9
  %conv101 = trunc i32 %and100 to i8
  store i8 %conv101, i8* %op_private98, align 1
  br label %if.end.102

if.end.102:                                       ; preds = %if.then.97, %land.lhs.true.92, %if.then.87
  br label %if.end.103

if.end.103:                                       ; preds = %if.end.102, %if.else.82
  br label %if.end.104

if.end.104:                                       ; preds = %if.end.103, %if.then.77
  br label %if.end.105

if.end.105:                                       ; preds = %if.end.104, %lor.lhs.false
  br label %if.end.106

if.end.106:                                       ; preds = %if.end.105, %if.end.62
  %92 = load i32, i32* @PL_hints, align 4
  %and107 = and i32 %92, 2
  %93 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private108 = getelementptr inbounds %struct.op, %struct.op* %93, i32 0, i32 7
  %94 = load i8, i8* %op_private108, align 1
  %conv109 = zext i8 %94 to i32
  %or110 = or i32 %conv109, %and107
  %conv111 = trunc i32 %or110 to i8
  store i8 %conv111, i8* %op_private108, align 1
  %95 = load i32, i32* @PL_perldb, align 4
  %tobool112 = icmp ne i32 %95, 0
  br i1 %tobool112, label %land.lhs.true.113, label %if.end.124

land.lhs.true.113:                                ; preds = %if.end.106
  %96 = load i32, i32* @PL_perldb, align 4
  %and114 = and i32 %96, 1
  %tobool115 = icmp ne i32 %and114, 0
  br i1 %tobool115, label %land.lhs.true.116, label %if.end.124

land.lhs.true.116:                                ; preds = %land.lhs.true.113
  %97 = load %struct.hv*, %struct.hv** @PL_curstash, align 8
  %98 = load %struct.hv*, %struct.hv** @PL_debstash, align 8
  %cmp117 = icmp ne %struct.hv* %97, %98
  br i1 %cmp117, label %if.then.119, label %if.end.124

if.then.119:                                      ; preds = %land.lhs.true.116
  %99 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private120 = getelementptr inbounds %struct.op, %struct.op* %99, i32 0, i32 7
  %100 = load i8, i8* %op_private120, align 1
  %conv121 = zext i8 %100 to i32
  %or122 = or i32 %conv121, 16
  %conv123 = trunc i32 %or122 to i8
  store i8 %conv123, i8* %op_private120, align 1
  br label %if.end.124

if.end.124:                                       ; preds = %if.then.119, %land.lhs.true.116, %land.lhs.true.113, %if.end.106
  br label %while.cond

while.cond:                                       ; preds = %if.end.366, %sw.bb.359, %sw.bb.132, %if.end.124
  %101 = load %struct.op*, %struct.op** %o2, align 8
  %102 = load %struct.op*, %struct.op** %cvop, align 8
  %cmp125 = icmp ne %struct.op* %101, %102
  br i1 %cmp125, label %while.body, label %while.end.369

while.body:                                       ; preds = %while.cond
  %103 = load i8*, i8** %proto, align 8
  %tobool127 = icmp ne i8* %103, null
  br i1 %tobool127, label %if.then.128, label %if.else.364

if.then.128:                                      ; preds = %while.body
  %104 = load i8*, i8** %proto, align 8
  %105 = load i8, i8* %104, align 1
  %conv129 = sext i8 %105 to i32
  switch i32 %conv129, label %sw.default.361 [
    i32 0, label %sw.bb
    i32 59, label %sw.bb.132
    i32 36, label %sw.bb.133
    i32 37, label %sw.bb.136
    i32 64, label %sw.bb.136
    i32 38, label %sw.bb.139
    i32 42, label %sw.bb.157
    i32 91, label %sw.bb.228
    i32 93, label %sw.bb.228
    i32 92, label %sw.bb.229
    i32 32, label %sw.bb.359
  ]

sw.bb:                                            ; preds = %if.then.128
  %106 = load %struct.op*, %struct.op** %o.addr, align 8
  %107 = load %struct.gv*, %struct.gv** %namegv, align 8
  %call130 = call i8* @S_gv_ename(%struct.gv* %107)
  %call131 = call %struct.op* @S_too_many_arguments(%struct.op* %106, i8* %call130)
  store %struct.op* %call131, %struct.op** %retval
  br label %return

sw.bb.132:                                        ; preds = %if.then.128
  store i32 1, i32* %optional, align 4
  %108 = load i8*, i8** %proto, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %108, i32 1
  store i8* %incdec.ptr, i8** %proto, align 8
  br label %while.cond

sw.bb.133:                                        ; preds = %if.then.128
  %109 = load i8*, i8** %proto, align 8
  %incdec.ptr134 = getelementptr inbounds i8, i8* %109, i32 1
  store i8* %incdec.ptr134, i8** %proto, align 8
  %110 = load i32, i32* %arg, align 4
  %inc = add nsw i32 %110, 1
  store i32 %inc, i32* %arg, align 4
  %111 = load %struct.op*, %struct.op** %o2, align 8
  %call135 = call %struct.op* @Perl_scalar(%struct.op* %111)
  br label %sw.epilog.363

sw.bb.136:                                        ; preds = %if.then.128, %if.then.128
  %112 = load %struct.op*, %struct.op** %o2, align 8
  %call137 = call %struct.op* @Perl_list(%struct.op* %112)
  %113 = load i32, i32* %arg, align 4
  %inc138 = add nsw i32 %113, 1
  store i32 %inc138, i32* %arg, align 4
  br label %sw.epilog.363

sw.bb.139:                                        ; preds = %if.then.128
  %114 = load i8*, i8** %proto, align 8
  %incdec.ptr140 = getelementptr inbounds i8, i8* %114, i32 1
  store i8* %incdec.ptr140, i8** %proto, align 8
  %115 = load i32, i32* %arg, align 4
  %inc141 = add nsw i32 %115, 1
  store i32 %inc141, i32* %arg, align 4
  %116 = load %struct.op*, %struct.op** %o2, align 8
  %op_type142 = getelementptr inbounds %struct.op, %struct.op* %116, i32 0, i32 4
  %117 = load i16, i16* %op_type142, align 2
  %conv143 = zext i16 %117 to i32
  %cmp144 = icmp ne i32 %conv143, 20
  br i1 %cmp144, label %land.lhs.true.146, label %if.end.156

land.lhs.true.146:                                ; preds = %sw.bb.139
  %118 = load %struct.op*, %struct.op** %o2, align 8
  %op_type147 = getelementptr inbounds %struct.op, %struct.op* %118, i32 0, i32 4
  %119 = load i16, i16* %op_type147, align 2
  %conv148 = zext i16 %119 to i32
  %cmp149 = icmp ne i32 %conv148, 43
  br i1 %cmp149, label %if.then.151, label %if.end.156

if.then.151:                                      ; preds = %land.lhs.true.146
  %120 = load i32, i32* %arg, align 4
  %121 = load i32, i32* %arg, align 4
  %cmp152 = icmp eq i32 %121, 1
  %cond154 = select i1 %cmp152, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.127, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.128, i32 0, i32 0)
  %122 = load %struct.gv*, %struct.gv** %namegv, align 8
  %call155 = call i8* @S_gv_ename(%struct.gv* %122)
  %123 = load %struct.op*, %struct.op** %o2, align 8
  call void @S_bad_type(i32 %120, i8* %cond154, i8* %call155, %struct.op* %123)
  br label %if.end.156

if.end.156:                                       ; preds = %if.then.151, %land.lhs.true.146, %sw.bb.139
  br label %sw.epilog.363

sw.bb.157:                                        ; preds = %if.then.128
  %124 = load i8*, i8** %proto, align 8
  %incdec.ptr158 = getelementptr inbounds i8, i8* %124, i32 1
  store i8* %incdec.ptr158, i8** %proto, align 8
  %125 = load i32, i32* %arg, align 4
  %inc159 = add nsw i32 %125, 1
  store i32 %inc159, i32* %arg, align 4
  %126 = load %struct.op*, %struct.op** %o2, align 8
  %op_type160 = getelementptr inbounds %struct.op, %struct.op* %126, i32 0, i32 4
  %127 = load i16, i16* %op_type160, align 2
  %conv161 = zext i16 %127 to i32
  %cmp162 = icmp eq i32 %conv161, 14
  br i1 %cmp162, label %if.then.164, label %if.else.165

if.then.164:                                      ; preds = %sw.bb.157
  br label %wrapref

if.else.165:                                      ; preds = %sw.bb.157
  %128 = load %struct.op*, %struct.op** %o2, align 8
  %op_type166 = getelementptr inbounds %struct.op, %struct.op* %128, i32 0, i32 4
  %129 = load i16, i16* %op_type166, align 2
  %conv167 = zext i16 %129 to i32
  %cmp168 = icmp eq i32 %conv167, 5
  br i1 %cmp168, label %if.then.170, label %if.else.175

if.then.170:                                      ; preds = %if.else.165
  %130 = load %struct.op*, %struct.op** %o2, align 8
  %op_private171 = getelementptr inbounds %struct.op, %struct.op* %130, i32 0, i32 7
  %131 = load i8, i8* %op_private171, align 1
  %conv172 = zext i8 %131 to i32
  %and173 = and i32 %conv172, -9
  %conv174 = trunc i32 %and173 to i8
  store i8 %conv174, i8* %op_private171, align 1
  br label %if.end.225

if.else.175:                                      ; preds = %if.else.165
  %132 = load %struct.op*, %struct.op** %o2, align 8
  %op_type176 = getelementptr inbounds %struct.op, %struct.op* %132, i32 0, i32 4
  %133 = load i16, i16* %op_type176, align 2
  %conv177 = zext i16 %133 to i32
  %cmp178 = icmp eq i32 %conv177, 166
  br i1 %cmp178, label %if.then.180, label %if.end.224

if.then.180:                                      ; preds = %if.else.175
  %134 = load %struct.op*, %struct.op** %o2, align 8
  %135 = bitcast %struct.op* %134 to %struct.unop*
  %op_first181 = getelementptr inbounds %struct.unop, %struct.unop* %135, i32 0, i32 8
  %136 = load %struct.op*, %struct.op** %op_first181, align 8
  store %struct.op* %136, %struct.op** %gvop, align 8
  %137 = load %struct.op*, %struct.op** %gvop, align 8
  %tobool182 = icmp ne %struct.op* %137, null
  br i1 %tobool182, label %land.lhs.true.183, label %if.end.223

land.lhs.true.183:                                ; preds = %if.then.180
  %138 = load %struct.op*, %struct.op** %gvop, align 8
  %op_type184 = getelementptr inbounds %struct.op, %struct.op* %138, i32 0, i32 4
  %139 = load i16, i16* %op_type184, align 2
  %conv185 = zext i16 %139 to i32
  %cmp186 = icmp eq i32 %conv185, 0
  br i1 %cmp186, label %if.then.188, label %if.end.223

if.then.188:                                      ; preds = %land.lhs.true.183
  %140 = load %struct.op*, %struct.op** %gvop, align 8
  %141 = bitcast %struct.op* %140 to %struct.unop*
  %op_first189 = getelementptr inbounds %struct.unop, %struct.unop* %141, i32 0, i32 8
  %142 = load %struct.op*, %struct.op** %op_first189, align 8
  store %struct.op* %142, %struct.op** %gvop, align 8
  %143 = load %struct.op*, %struct.op** %gvop, align 8
  %tobool190 = icmp ne %struct.op* %143, null
  br i1 %tobool190, label %if.then.191, label %if.end.222

if.then.191:                                      ; preds = %if.then.188
  br label %for.cond.192

for.cond.192:                                     ; preds = %for.inc.196, %if.then.191
  %144 = load %struct.op*, %struct.op** %gvop, align 8
  %op_sibling193 = getelementptr inbounds %struct.op, %struct.op* %144, i32 0, i32 1
  %145 = load %struct.op*, %struct.op** %op_sibling193, align 8
  %tobool194 = icmp ne %struct.op* %145, null
  br i1 %tobool194, label %for.body.195, label %for.end.198

for.body.195:                                     ; preds = %for.cond.192
  br label %for.inc.196

for.inc.196:                                      ; preds = %for.body.195
  %146 = load %struct.op*, %struct.op** %gvop, align 8
  %op_sibling197 = getelementptr inbounds %struct.op, %struct.op* %146, i32 0, i32 1
  %147 = load %struct.op*, %struct.op** %op_sibling197, align 8
  store %struct.op* %147, %struct.op** %gvop, align 8
  br label %for.cond.192

for.end.198:                                      ; preds = %for.cond.192
  %148 = load %struct.op*, %struct.op** %gvop, align 8
  %tobool199 = icmp ne %struct.op* %148, null
  br i1 %tobool199, label %land.lhs.true.200, label %if.end.221

land.lhs.true.200:                                ; preds = %for.end.198
  %149 = load %struct.op*, %struct.op** %gvop, align 8
  %op_private201 = getelementptr inbounds %struct.op, %struct.op* %149, i32 0, i32 7
  %150 = load i8, i8* %op_private201, align 1
  %conv202 = zext i8 %150 to i32
  %and203 = and i32 %conv202, 128
  %tobool204 = icmp ne i32 %and203, 0
  br i1 %tobool204, label %land.lhs.true.205, label %if.end.221

land.lhs.true.205:                                ; preds = %land.lhs.true.200
  %151 = load %struct.op*, %struct.op** %gvop, align 8
  %152 = bitcast %struct.op* %151 to %struct.unop*
  %op_first206 = getelementptr inbounds %struct.unop, %struct.unop* %152, i32 0, i32 8
  %153 = load %struct.op*, %struct.op** %op_first206, align 8
  store %struct.op* %153, %struct.op** %gvop, align 8
  %tobool207 = icmp ne %struct.op* %153, null
  br i1 %tobool207, label %land.lhs.true.208, label %if.end.221

land.lhs.true.208:                                ; preds = %land.lhs.true.205
  %154 = load %struct.op*, %struct.op** %gvop, align 8
  %op_type209 = getelementptr inbounds %struct.op, %struct.op* %154, i32 0, i32 4
  %155 = load i16, i16* %op_type209, align 2
  %conv210 = zext i16 %155 to i32
  %cmp211 = icmp eq i32 %conv210, 7
  br i1 %cmp211, label %if.then.213, label %if.end.221

if.then.213:                                      ; preds = %land.lhs.true.208
  %156 = load %struct.op*, %struct.op** %gvop, align 8
  %157 = bitcast %struct.op* %156 to %struct.svop*
  %op_sv215 = getelementptr inbounds %struct.svop, %struct.svop* %157, i32 0, i32 8
  %158 = load %struct.sv*, %struct.sv** %op_sv215, align 8
  %159 = bitcast %struct.sv* %158 to %struct.gv*
  store %struct.gv* %159, %struct.gv** %gv214, align 8
  %160 = load %struct.op*, %struct.op** %o2, align 8
  %op_sibling216 = getelementptr inbounds %struct.op, %struct.op* %160, i32 0, i32 1
  %161 = load %struct.op*, %struct.op** %op_sibling216, align 8
  store %struct.op* %161, %struct.op** %sibling, align 8
  %call217 = call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.35, i32 0, i32 0), i64 0)
  store %struct.sv* %call217, %struct.sv** %n, align 8
  %162 = load %struct.op*, %struct.op** %o2, align 8
  call void @Perl_op_free(%struct.op* %162)
  %163 = load %struct.sv*, %struct.sv** %n, align 8
  %164 = load %struct.gv*, %struct.gv** %gv214, align 8
  call void @Perl_gv_fullname4(%struct.sv* %163, %struct.gv* %164, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.35, i32 0, i32 0), i8 signext 0)
  %165 = load %struct.sv*, %struct.sv** %n, align 8
  %call218 = call %struct.op* @Perl_newSVOP(i32 5, i32 0, %struct.sv* %165)
  store %struct.op* %call218, %struct.op** %o2, align 8
  %166 = load %struct.op*, %struct.op** %o2, align 8
  %167 = load %struct.op*, %struct.op** %prev, align 8
  %op_sibling219 = getelementptr inbounds %struct.op, %struct.op* %167, i32 0, i32 1
  store %struct.op* %166, %struct.op** %op_sibling219, align 8
  %168 = load %struct.op*, %struct.op** %sibling, align 8
  %169 = load %struct.op*, %struct.op** %o2, align 8
  %op_sibling220 = getelementptr inbounds %struct.op, %struct.op* %169, i32 0, i32 1
  store %struct.op* %168, %struct.op** %op_sibling220, align 8
  br label %if.end.221

if.end.221:                                       ; preds = %if.then.213, %land.lhs.true.208, %land.lhs.true.205, %land.lhs.true.200, %for.end.198
  br label %if.end.222

if.end.222:                                       ; preds = %if.end.221, %if.then.188
  br label %if.end.223

if.end.223:                                       ; preds = %if.end.222, %land.lhs.true.183, %if.then.180
  br label %if.end.224

if.end.224:                                       ; preds = %if.end.223, %if.else.175
  br label %if.end.225

if.end.225:                                       ; preds = %if.end.224, %if.then.170
  br label %if.end.226

if.end.226:                                       ; preds = %if.end.225
  %170 = load %struct.op*, %struct.op** %o2, align 8
  %call227 = call %struct.op* @Perl_scalar(%struct.op* %170)
  br label %sw.epilog.363

sw.bb.228:                                        ; preds = %if.then.128, %if.then.128
  br label %oops

sw.bb.229:                                        ; preds = %if.then.128
  %171 = load i8*, i8** %proto, align 8
  %incdec.ptr230 = getelementptr inbounds i8, i8* %171, i32 1
  store i8* %incdec.ptr230, i8** %proto, align 8
  %172 = load i32, i32* %arg, align 4
  %inc231 = add nsw i32 %172, 1
  store i32 %inc231, i32* %arg, align 4
  br label %again

again:                                            ; preds = %if.then.357, %if.end.247, %sw.bb.229
  %173 = load i8*, i8** %proto, align 8
  %incdec.ptr232 = getelementptr inbounds i8, i8* %173, i32 1
  store i8* %incdec.ptr232, i8** %proto, align 8
  %174 = load i8, i8* %173, align 1
  %conv233 = sext i8 %174 to i32
  switch i32 %conv233, label %sw.default [
    i32 91, label %sw.bb.234
    i32 93, label %sw.bb.248
    i32 42, label %sw.bb.261
    i32 38, label %sw.bb.272
    i32 36, label %sw.bb.283
    i32 64, label %sw.bb.314
    i32 37, label %sw.bb.330
  ]

sw.bb.234:                                        ; preds = %again
  %175 = load i32, i32* %contextclass, align 4
  %inc235 = add nsw i32 %175, 1
  store i32 %inc235, i32* %contextclass, align 4
  %cmp236 = icmp eq i32 %175, 0
  br i1 %cmp236, label %if.then.238, label %if.else.246

if.then.238:                                      ; preds = %sw.bb.234
  %176 = load i8*, i8** %proto, align 8
  %call239 = call i8* @strchr(i8* %176, i32 93)
  store i8* %call239, i8** %e, align 8
  %177 = load i8*, i8** %e, align 8
  %tobool240 = icmp ne i8* %177, null
  br i1 %tobool240, label %lor.lhs.false.241, label %if.then.244

lor.lhs.false.241:                                ; preds = %if.then.238
  %178 = load i8*, i8** %e, align 8
  %179 = load i8*, i8** %proto, align 8
  %cmp242 = icmp eq i8* %178, %179
  br i1 %cmp242, label %if.then.244, label %if.end.245

if.then.244:                                      ; preds = %lor.lhs.false.241, %if.then.238
  br label %oops

if.end.245:                                       ; preds = %lor.lhs.false.241
  br label %if.end.247

if.else.246:                                      ; preds = %sw.bb.234
  br label %oops

if.end.247:                                       ; preds = %if.end.245
  br label %again

sw.bb.248:                                        ; preds = %again
  %180 = load i32, i32* %contextclass, align 4
  %tobool249 = icmp ne i32 %180, 0
  br i1 %tobool249, label %if.then.250, label %if.else.259

if.then.250:                                      ; preds = %sw.bb.248
  %181 = load i8*, i8** %proto, align 8
  store i8* %181, i8** %p, align 8
  %182 = load i8*, i8** %p, align 8
  %183 = load i8, i8* %182, align 1
  store i8 %183, i8* %s, align 1
  store i32 0, i32* %contextclass, align 4
  %184 = load i8*, i8** %p, align 8
  store i8 0, i8* %184, align 1
  br label %while.cond.251

while.cond.251:                                   ; preds = %while.body.256, %if.then.250
  %185 = load i8*, i8** %p, align 8
  %incdec.ptr252 = getelementptr inbounds i8, i8* %185, i32 -1
  store i8* %incdec.ptr252, i8** %p, align 8
  %186 = load i8, i8* %incdec.ptr252, align 1
  %conv253 = sext i8 %186 to i32
  %cmp254 = icmp ne i32 %conv253, 91
  br i1 %cmp254, label %while.body.256, label %while.end

while.body.256:                                   ; preds = %while.cond.251
  br label %while.cond.251

while.end:                                        ; preds = %while.cond.251
  %187 = load i32, i32* %arg, align 4
  %188 = load i8*, i8** %p, align 8
  %call257 = call i8* (i8*, ...) @Perl_form(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.129, i32 0, i32 0), i8* %188)
  %189 = load %struct.gv*, %struct.gv** %namegv, align 8
  %call258 = call i8* @S_gv_ename(%struct.gv* %189)
  %190 = load %struct.op*, %struct.op** %o2, align 8
  call void @S_bad_type(i32 %187, i8* %call257, i8* %call258, %struct.op* %190)
  %191 = load i8, i8* %s, align 1
  %192 = load i8*, i8** %proto, align 8
  store i8 %191, i8* %192, align 1
  br label %if.end.260

if.else.259:                                      ; preds = %sw.bb.248
  br label %oops

if.end.260:                                       ; preds = %while.end
  br label %sw.epilog

sw.bb.261:                                        ; preds = %again
  %193 = load %struct.op*, %struct.op** %o2, align 8
  %op_type262 = getelementptr inbounds %struct.op, %struct.op* %193, i32 0, i32 4
  %194 = load i16, i16* %op_type262, align 2
  %conv263 = zext i16 %194 to i32
  %cmp264 = icmp eq i32 %conv263, 14
  br i1 %cmp264, label %if.then.266, label %if.end.267

if.then.266:                                      ; preds = %sw.bb.261
  br label %wrapref

if.end.267:                                       ; preds = %sw.bb.261
  %195 = load i32, i32* %contextclass, align 4
  %tobool268 = icmp ne i32 %195, 0
  br i1 %tobool268, label %if.end.271, label %if.then.269

if.then.269:                                      ; preds = %if.end.267
  %196 = load i32, i32* %arg, align 4
  %197 = load %struct.gv*, %struct.gv** %namegv, align 8
  %call270 = call i8* @S_gv_ename(%struct.gv* %197)
  %198 = load %struct.op*, %struct.op** %o2, align 8
  call void @S_bad_type(i32 %196, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.130, i32 0, i32 0), i8* %call270, %struct.op* %198)
  br label %if.end.271

if.end.271:                                       ; preds = %if.then.269, %if.end.267
  br label %sw.epilog

sw.bb.272:                                        ; preds = %again
  %199 = load %struct.op*, %struct.op** %o2, align 8
  %op_type273 = getelementptr inbounds %struct.op, %struct.op* %199, i32 0, i32 4
  %200 = load i16, i16* %op_type273, align 2
  %conv274 = zext i16 %200 to i32
  %cmp275 = icmp eq i32 %conv274, 166
  br i1 %cmp275, label %if.then.277, label %if.end.278

if.then.277:                                      ; preds = %sw.bb.272
  br label %wrapref

if.end.278:                                       ; preds = %sw.bb.272
  %201 = load i32, i32* %contextclass, align 4
  %tobool279 = icmp ne i32 %201, 0
  br i1 %tobool279, label %if.end.282, label %if.then.280

if.then.280:                                      ; preds = %if.end.278
  %202 = load i32, i32* %arg, align 4
  %203 = load %struct.gv*, %struct.gv** %namegv, align 8
  %call281 = call i8* @S_gv_ename(%struct.gv* %203)
  %204 = load %struct.op*, %struct.op** %o2, align 8
  call void @S_bad_type(i32 %202, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.131, i32 0, i32 0), i8* %call281, %struct.op* %204)
  br label %if.end.282

if.end.282:                                       ; preds = %if.then.280, %if.end.278
  br label %sw.epilog

sw.bb.283:                                        ; preds = %again
  %205 = load %struct.op*, %struct.op** %o2, align 8
  %op_type284 = getelementptr inbounds %struct.op, %struct.op* %205, i32 0, i32 4
  %206 = load i16, i16* %op_type284, align 2
  %conv285 = zext i16 %206 to i32
  %cmp286 = icmp eq i32 %conv285, 15
  br i1 %cmp286, label %if.then.308, label %lor.lhs.false.288

lor.lhs.false.288:                                ; preds = %sw.bb.283
  %207 = load %struct.op*, %struct.op** %o2, align 8
  %op_type289 = getelementptr inbounds %struct.op, %struct.op* %207, i32 0, i32 4
  %208 = load i16, i16* %op_type289, align 2
  %conv290 = zext i16 %208 to i32
  %cmp291 = icmp eq i32 %conv290, 9
  br i1 %cmp291, label %if.then.308, label %lor.lhs.false.293

lor.lhs.false.293:                                ; preds = %lor.lhs.false.288
  %209 = load %struct.op*, %struct.op** %o2, align 8
  %op_type294 = getelementptr inbounds %struct.op, %struct.op* %209, i32 0, i32 4
  %210 = load i16, i16* %op_type294, align 2
  %conv295 = zext i16 %210 to i32
  %cmp296 = icmp eq i32 %conv295, 135
  br i1 %cmp296, label %if.then.308, label %lor.lhs.false.298

lor.lhs.false.298:                                ; preds = %lor.lhs.false.293
  %211 = load %struct.op*, %struct.op** %o2, align 8
  %op_type299 = getelementptr inbounds %struct.op, %struct.op* %211, i32 0, i32 4
  %212 = load i16, i16* %op_type299, align 2
  %conv300 = zext i16 %212 to i32
  %cmp301 = icmp eq i32 %conv300, 127
  br i1 %cmp301, label %if.then.308, label %lor.lhs.false.303

lor.lhs.false.303:                                ; preds = %lor.lhs.false.298
  %213 = load %struct.op*, %struct.op** %o2, align 8
  %op_type304 = getelementptr inbounds %struct.op, %struct.op* %213, i32 0, i32 4
  %214 = load i16, i16* %op_type304, align 2
  %conv305 = zext i16 %214 to i32
  %cmp306 = icmp eq i32 %conv305, 348
  br i1 %cmp306, label %if.then.308, label %if.end.309

if.then.308:                                      ; preds = %lor.lhs.false.303, %lor.lhs.false.298, %lor.lhs.false.293, %lor.lhs.false.288, %sw.bb.283
  br label %wrapref

if.end.309:                                       ; preds = %lor.lhs.false.303
  %215 = load i32, i32* %contextclass, align 4
  %tobool310 = icmp ne i32 %215, 0
  br i1 %tobool310, label %if.end.313, label %if.then.311

if.then.311:                                      ; preds = %if.end.309
  %216 = load i32, i32* %arg, align 4
  %217 = load %struct.gv*, %struct.gv** %namegv, align 8
  %call312 = call i8* @S_gv_ename(%struct.gv* %217)
  %218 = load %struct.op*, %struct.op** %o2, align 8
  call void @S_bad_type(i32 %216, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.132, i32 0, i32 0), i8* %call312, %struct.op* %218)
  br label %if.end.313

if.end.313:                                       ; preds = %if.then.311, %if.end.309
  br label %sw.epilog

sw.bb.314:                                        ; preds = %again
  %219 = load %struct.op*, %struct.op** %o2, align 8
  %op_type315 = getelementptr inbounds %struct.op, %struct.op* %219, i32 0, i32 4
  %220 = load i16, i16* %op_type315, align 2
  %conv316 = zext i16 %220 to i32
  %cmp317 = icmp eq i32 %conv316, 125
  br i1 %cmp317, label %if.then.324, label %lor.lhs.false.319

lor.lhs.false.319:                                ; preds = %sw.bb.314
  %221 = load %struct.op*, %struct.op** %o2, align 8
  %op_type320 = getelementptr inbounds %struct.op, %struct.op* %221, i32 0, i32 4
  %222 = load i16, i16* %op_type320, align 2
  %conv321 = zext i16 %222 to i32
  %cmp322 = icmp eq i32 %conv321, 10
  br i1 %cmp322, label %if.then.324, label %if.end.325

if.then.324:                                      ; preds = %lor.lhs.false.319, %sw.bb.314
  br label %wrapref

if.end.325:                                       ; preds = %lor.lhs.false.319
  %223 = load i32, i32* %contextclass, align 4
  %tobool326 = icmp ne i32 %223, 0
  br i1 %tobool326, label %if.end.329, label %if.then.327

if.then.327:                                      ; preds = %if.end.325
  %224 = load i32, i32* %arg, align 4
  %225 = load %struct.gv*, %struct.gv** %namegv, align 8
  %call328 = call i8* @S_gv_ename(%struct.gv* %225)
  %226 = load %struct.op*, %struct.op** %o2, align 8
  call void @S_bad_type(i32 %224, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.99, i32 0, i32 0), i8* %call328, %struct.op* %226)
  br label %if.end.329

if.end.329:                                       ; preds = %if.then.327, %if.end.325
  br label %sw.epilog

sw.bb.330:                                        ; preds = %again
  %227 = load %struct.op*, %struct.op** %o2, align 8
  %op_type331 = getelementptr inbounds %struct.op, %struct.op* %227, i32 0, i32 4
  %228 = load i16, i16* %op_type331, align 2
  %conv332 = zext i16 %228 to i32
  %cmp333 = icmp eq i32 %conv332, 134
  br i1 %cmp333, label %if.then.340, label %lor.lhs.false.335

lor.lhs.false.335:                                ; preds = %sw.bb.330
  %229 = load %struct.op*, %struct.op** %o2, align 8
  %op_type336 = getelementptr inbounds %struct.op, %struct.op* %229, i32 0, i32 4
  %230 = load i16, i16* %op_type336, align 2
  %conv337 = zext i16 %230 to i32
  %cmp338 = icmp eq i32 %conv337, 11
  br i1 %cmp338, label %if.then.340, label %if.end.341

if.then.340:                                      ; preds = %lor.lhs.false.335, %sw.bb.330
  br label %wrapref

if.end.341:                                       ; preds = %lor.lhs.false.335
  %231 = load i32, i32* %contextclass, align 4
  %tobool342 = icmp ne i32 %231, 0
  br i1 %tobool342, label %if.end.345, label %if.then.343

if.then.343:                                      ; preds = %if.end.341
  %232 = load i32, i32* %arg, align 4
  %233 = load %struct.gv*, %struct.gv** %namegv, align 8
  %call344 = call i8* @S_gv_ename(%struct.gv* %233)
  %234 = load %struct.op*, %struct.op** %o2, align 8
  call void @S_bad_type(i32 %232, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.101, i32 0, i32 0), i8* %call344, %struct.op* %234)
  br label %if.end.345

if.end.345:                                       ; preds = %if.then.343, %if.end.341
  br label %sw.epilog

wrapref:                                          ; preds = %if.then.340, %if.then.324, %if.then.308, %if.then.277, %if.then.266, %if.then.164
  %235 = load %struct.op*, %struct.op** %o2, align 8
  store %struct.op* %235, %struct.op** %kid, align 8
  %236 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling346 = getelementptr inbounds %struct.op, %struct.op* %236, i32 0, i32 1
  %237 = load %struct.op*, %struct.op** %op_sibling346, align 8
  store %struct.op* %237, %struct.op** %sib, align 8
  %238 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling347 = getelementptr inbounds %struct.op, %struct.op* %238, i32 0, i32 1
  store %struct.op* null, %struct.op** %op_sibling347, align 8
  %239 = load %struct.op*, %struct.op** %kid, align 8
  %call348 = call %struct.op* @Perl_newUNOP(i32 20, i32 0, %struct.op* %239)
  store %struct.op* %call348, %struct.op** %o2, align 8
  %240 = load %struct.op*, %struct.op** %sib, align 8
  %241 = load %struct.op*, %struct.op** %o2, align 8
  %op_sibling349 = getelementptr inbounds %struct.op, %struct.op* %241, i32 0, i32 1
  store %struct.op* %240, %struct.op** %op_sibling349, align 8
  %242 = load %struct.op*, %struct.op** %o2, align 8
  %243 = load %struct.op*, %struct.op** %prev, align 8
  %op_sibling350 = getelementptr inbounds %struct.op, %struct.op* %243, i32 0, i32 1
  store %struct.op* %242, %struct.op** %op_sibling350, align 8
  %244 = load i32, i32* %contextclass, align 4
  %tobool351 = icmp ne i32 %244, 0
  br i1 %tobool351, label %land.lhs.true.352, label %if.end.355

land.lhs.true.352:                                ; preds = %wrapref
  %245 = load i8*, i8** %e, align 8
  %tobool353 = icmp ne i8* %245, null
  br i1 %tobool353, label %if.then.354, label %if.end.355

if.then.354:                                      ; preds = %land.lhs.true.352
  %246 = load i8*, i8** %e, align 8
  %add.ptr = getelementptr inbounds i8, i8* %246, i64 1
  store i8* %add.ptr, i8** %proto, align 8
  store i32 0, i32* %contextclass, align 4
  br label %if.end.355

if.end.355:                                       ; preds = %if.then.354, %land.lhs.true.352, %wrapref
  br label %sw.epilog

sw.default:                                       ; preds = %again
  br label %oops

sw.epilog:                                        ; preds = %if.end.355, %if.end.345, %if.end.329, %if.end.313, %if.end.282, %if.end.271, %if.end.260
  %247 = load i32, i32* %contextclass, align 4
  %tobool356 = icmp ne i32 %247, 0
  br i1 %tobool356, label %if.then.357, label %if.end.358

if.then.357:                                      ; preds = %sw.epilog
  br label %again

if.end.358:                                       ; preds = %sw.epilog
  br label %sw.epilog.363

sw.bb.359:                                        ; preds = %if.then.128
  %248 = load i8*, i8** %proto, align 8
  %incdec.ptr360 = getelementptr inbounds i8, i8* %248, i32 1
  store i8* %incdec.ptr360, i8** %proto, align 8
  br label %while.cond

sw.default.361:                                   ; preds = %if.then.128
  br label %oops

oops:                                             ; preds = %sw.default.361, %sw.default, %if.else.259, %if.else.246, %if.then.244, %sw.bb.228
  %249 = load %struct.gv*, %struct.gv** %namegv, align 8
  %call362 = call i8* @S_gv_ename(%struct.gv* %249)
  %250 = load %struct.cv*, %struct.cv** %cv, align 8
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.133, i32 0, i32 0), i8* %call362, %struct.cv* %250)
  br label %sw.epilog.363

sw.epilog.363:                                    ; preds = %oops, %if.end.358, %if.end.226, %if.end.156, %sw.bb.136, %sw.bb.133
  br label %if.end.366

if.else.364:                                      ; preds = %while.body
  %251 = load %struct.op*, %struct.op** %o2, align 8
  %call365 = call %struct.op* @Perl_list(%struct.op* %251)
  br label %if.end.366

if.end.366:                                       ; preds = %if.else.364, %sw.epilog.363
  %252 = load %struct.op*, %struct.op** %o2, align 8
  %call367 = call %struct.op* @Perl_mod(%struct.op* %252, i32 166)
  %253 = load %struct.op*, %struct.op** %o2, align 8
  store %struct.op* %253, %struct.op** %prev, align 8
  %254 = load %struct.op*, %struct.op** %o2, align 8
  %op_sibling368 = getelementptr inbounds %struct.op, %struct.op* %254, i32 0, i32 1
  %255 = load %struct.op*, %struct.op** %op_sibling368, align 8
  store %struct.op* %255, %struct.op** %o2, align 8
  br label %while.cond

while.end.369:                                    ; preds = %while.cond
  %256 = load i8*, i8** %proto, align 8
  %tobool370 = icmp ne i8* %256, null
  br i1 %tobool370, label %land.lhs.true.371, label %if.end.391

land.lhs.true.371:                                ; preds = %while.end.369
  %257 = load i32, i32* %optional, align 4
  %tobool372 = icmp ne i32 %257, 0
  br i1 %tobool372, label %if.end.391, label %land.lhs.true.373

land.lhs.true.373:                                ; preds = %land.lhs.true.371
  %258 = load i8*, i8** %proto, align 8
  %259 = load i8, i8* %258, align 1
  %conv374 = sext i8 %259 to i32
  %tobool375 = icmp ne i32 %conv374, 0
  br i1 %tobool375, label %land.lhs.true.376, label %if.end.391

land.lhs.true.376:                                ; preds = %land.lhs.true.373
  %260 = load i8*, i8** %proto, align 8
  %261 = load i8, i8* %260, align 1
  %conv377 = sext i8 %261 to i32
  %cmp378 = icmp ne i32 %conv377, 64
  br i1 %cmp378, label %land.lhs.true.380, label %if.end.391

land.lhs.true.380:                                ; preds = %land.lhs.true.376
  %262 = load i8*, i8** %proto, align 8
  %263 = load i8, i8* %262, align 1
  %conv381 = sext i8 %263 to i32
  %cmp382 = icmp ne i32 %conv381, 37
  br i1 %cmp382, label %land.lhs.true.384, label %if.end.391

land.lhs.true.384:                                ; preds = %land.lhs.true.380
  %264 = load i8*, i8** %proto, align 8
  %265 = load i8, i8* %264, align 1
  %conv385 = sext i8 %265 to i32
  %cmp386 = icmp ne i32 %conv385, 59
  br i1 %cmp386, label %if.then.388, label %if.end.391

if.then.388:                                      ; preds = %land.lhs.true.384
  %266 = load %struct.op*, %struct.op** %o.addr, align 8
  %267 = load %struct.gv*, %struct.gv** %namegv, align 8
  %call389 = call i8* @S_gv_ename(%struct.gv* %267)
  %call390 = call %struct.op* @S_too_few_arguments(%struct.op* %266, i8* %call389)
  store %struct.op* %call390, %struct.op** %retval
  br label %return

if.end.391:                                       ; preds = %land.lhs.true.384, %land.lhs.true.380, %land.lhs.true.376, %land.lhs.true.373, %land.lhs.true.371, %while.end.369
  %268 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %268, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.391, %if.then.388, %sw.bb
  %269 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %269
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newSLICEOP(i32 %flags, %struct.op* %subscript, %struct.op* %listval) #0 {
entry:
  %flags.addr = alloca i32, align 4
  %subscript.addr = alloca %struct.op*, align 8
  %listval.addr = alloca %struct.op*, align 8
  store i32 %flags, i32* %flags.addr, align 4
  store %struct.op* %subscript, %struct.op** %subscript.addr, align 8
  store %struct.op* %listval, %struct.op** %listval.addr, align 8
  %0 = load i32, i32* %flags.addr, align 4
  %1 = load %struct.op*, %struct.op** %subscript.addr, align 8
  %call = call %struct.op* @Perl_force_list(%struct.op* %1)
  %call1 = call %struct.op* @Perl_list(%struct.op* %call)
  %2 = load %struct.op*, %struct.op** %listval.addr, align 8
  %call2 = call %struct.op* @Perl_force_list(%struct.op* %2)
  %call3 = call %struct.op* @Perl_list(%struct.op* %call2)
  %call4 = call %struct.op* @Perl_newBINOP(i32 142, i32 %0, %struct.op* %call1, %struct.op* %call3)
  ret %struct.op* %call4
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newASSIGNOP(i32 %flags, %struct.op* %left, i32 %optype, %struct.op* %right) #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %flags.addr = alloca i32, align 4
  %left.addr = alloca %struct.op*, align 8
  %optype.addr = alloca i32, align 4
  %right.addr = alloca %struct.op*, align 8
  %o = alloca %struct.op*, align 8
  %curop = alloca %struct.op*, align 8
  %lastop = alloca %struct.op*, align 8
  %gv = alloca %struct.gv*, align 8
  %gv172 = alloca %struct.gv*, align 8
  %tmpop = alloca %struct.op*, align 8
  %pm = alloca %struct.pmop*, align 8
  %sv = alloca %struct.sv*, align 8
  store i32 %flags, i32* %flags.addr, align 4
  store %struct.op* %left, %struct.op** %left.addr, align 8
  store i32 %optype, i32* %optype.addr, align 4
  store %struct.op* %right, %struct.op** %right.addr, align 8
  %0 = load i32, i32* %optype.addr, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i32, i32* %optype.addr, align 4
  %cmp = icmp eq i32 %1, 163
  br i1 %cmp, label %if.then.2, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %2 = load i32, i32* %optype.addr, align 4
  %cmp1 = icmp eq i32 %2, 164
  br i1 %cmp1, label %if.then.2, label %if.else

if.then.2:                                        ; preds = %lor.lhs.false, %if.then
  %3 = load i32, i32* %optype.addr, align 4
  %4 = load %struct.op*, %struct.op** %left.addr, align 8
  %call = call %struct.op* @Perl_scalar(%struct.op* %4)
  %5 = load i32, i32* %optype.addr, align 4
  %call3 = call %struct.op* @Perl_mod(%struct.op* %call, i32 %5)
  %6 = load %struct.op*, %struct.op** %right.addr, align 8
  %call4 = call %struct.op* @Perl_scalar(%struct.op* %6)
  %call5 = call %struct.op* @Perl_newUNOP(i32 36, i32 0, %struct.op* %call4)
  %call6 = call %struct.op* @Perl_newLOGOP(i32 %3, i32 0, %struct.op* %call3, %struct.op* %call5)
  store %struct.op* %call6, %struct.op** %retval
  br label %return

if.else:                                          ; preds = %lor.lhs.false
  %7 = load i32, i32* %optype.addr, align 4
  %8 = load %struct.op*, %struct.op** %left.addr, align 8
  %call7 = call %struct.op* @Perl_scalar(%struct.op* %8)
  %9 = load i32, i32* %optype.addr, align 4
  %call8 = call %struct.op* @Perl_mod(%struct.op* %call7, i32 %9)
  %10 = load %struct.op*, %struct.op** %right.addr, align 8
  %call9 = call %struct.op* @Perl_scalar(%struct.op* %10)
  %call10 = call %struct.op* @Perl_newBINOP(i32 %7, i32 64, %struct.op* %call8, %struct.op* %call9)
  store %struct.op* %call10, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %entry
  %11 = load %struct.op*, %struct.op** %left.addr, align 8
  %call11 = call i32 @S_list_assignment(%struct.op* %11)
  %tobool12 = icmp ne i32 %call11, 0
  br i1 %tobool12, label %if.then.13, label %if.end.288

if.then.13:                                       ; preds = %if.end
  store i32 0, i32* @PL_modcount, align 4
  %12 = load %struct.op*, %struct.op** %right.addr, align 8
  store %struct.op* %12, %struct.op** @PL_eval_start, align 8
  %13 = load %struct.op*, %struct.op** %left.addr, align 8
  %call14 = call %struct.op* @Perl_mod(%struct.op* %13, i32 37)
  store %struct.op* %call14, %struct.op** %left.addr, align 8
  %14 = load %struct.op*, %struct.op** @PL_eval_start, align 8
  %tobool15 = icmp ne %struct.op* %14, null
  br i1 %tobool15, label %if.then.16, label %if.else.17

if.then.16:                                       ; preds = %if.then.13
  store %struct.op* null, %struct.op** @PL_eval_start, align 8
  br label %if.end.18

if.else.17:                                       ; preds = %if.then.13
  %15 = load %struct.op*, %struct.op** %left.addr, align 8
  call void @Perl_op_free(%struct.op* %15)
  %16 = load %struct.op*, %struct.op** %right.addr, align 8
  call void @Perl_op_free(%struct.op* %16)
  store %struct.op* null, %struct.op** %retval
  br label %return

if.end.18:                                        ; preds = %if.then.16
  %17 = load %struct.op*, %struct.op** %left.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %17, i32 0, i32 4
  %18 = load i16, i16* %op_type, align 2
  %conv = zext i16 %18 to i32
  %cmp19 = icmp eq i32 %conv, 10
  br i1 %cmp19, label %land.lhs.true, label %lor.lhs.false.21

lor.lhs.false.21:                                 ; preds = %if.end.18
  %19 = load %struct.op*, %struct.op** %left.addr, align 8
  %op_type22 = getelementptr inbounds %struct.op, %struct.op* %19, i32 0, i32 4
  %20 = load i16, i16* %op_type22, align 2
  %conv23 = zext i16 %20 to i32
  %cmp24 = icmp eq i32 %conv23, 11
  br i1 %cmp24, label %land.lhs.true, label %if.end.37

land.lhs.true:                                    ; preds = %lor.lhs.false.21, %if.end.18
  %21 = load %struct.op*, %struct.op** %right.addr, align 8
  %op_type26 = getelementptr inbounds %struct.op, %struct.op* %21, i32 0, i32 4
  %22 = load i16, i16* %op_type26, align 2
  %conv27 = zext i16 %22 to i32
  %cmp28 = icmp eq i32 %conv27, 1
  br i1 %cmp28, label %land.lhs.true.30, label %if.end.37

land.lhs.true.30:                                 ; preds = %land.lhs.true
  %23 = load %struct.op*, %struct.op** %left.addr, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %23, i32 0, i32 7
  %24 = load i8, i8* %op_private, align 1
  %conv31 = zext i8 %24 to i32
  %and = and i32 %conv31, 128
  %tobool32 = icmp ne i32 %and, 0
  br i1 %tobool32, label %if.then.33, label %if.end.37

if.then.33:                                       ; preds = %land.lhs.true.30
  %25 = load %struct.op*, %struct.op** %right.addr, align 8
  call void @Perl_op_free(%struct.op* %25)
  %26 = load %struct.op*, %struct.op** %left.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %26, i32 0, i32 6
  %27 = load i8, i8* %op_flags, align 1
  %conv34 = zext i8 %27 to i32
  %and35 = and i32 %conv34, -145
  %conv36 = trunc i32 %and35 to i8
  store i8 %conv36, i8* %op_flags, align 1
  %28 = load %struct.op*, %struct.op** %left.addr, align 8
  store %struct.op* %28, %struct.op** %retval
  br label %return

if.end.37:                                        ; preds = %land.lhs.true.30, %land.lhs.true, %lor.lhs.false.21
  %29 = load %struct.op*, %struct.op** %left.addr, align 8
  %call38 = call %struct.op* @Perl_force_list(%struct.op* %29)
  %call39 = call %struct.op* @Perl_list(%struct.op* %call38)
  store %struct.op* %call39, %struct.op** %curop, align 8
  %30 = load i32, i32* %flags.addr, align 4
  %31 = load %struct.op*, %struct.op** %right.addr, align 8
  %call40 = call %struct.op* @Perl_force_list(%struct.op* %31)
  %call41 = call %struct.op* @Perl_list(%struct.op* %call40)
  %32 = load %struct.op*, %struct.op** %curop, align 8
  %call42 = call %struct.op* @Perl_newBINOP(i32 37, i32 %30, %struct.op* %call41, %struct.op* %32)
  store %struct.op* %call42, %struct.op** %o, align 8
  %33 = load i32, i32* %flags.addr, align 4
  %shr = ashr i32 %33, 8
  %or = or i32 0, %shr
  %conv43 = trunc i32 %or to i8
  %34 = load %struct.op*, %struct.op** %o, align 8
  %op_private44 = getelementptr inbounds %struct.op, %struct.op* %34, i32 0, i32 7
  store i8 %conv43, i8* %op_private44, align 1
  %35 = load %struct.op*, %struct.op** %curop, align 8
  %36 = bitcast %struct.op* %35 to %struct.listop*
  %op_first = getelementptr inbounds %struct.listop, %struct.listop* %36, i32 0, i32 8
  %37 = load %struct.op*, %struct.op** %op_first, align 8
  store %struct.op* %37, %struct.op** %curop, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end.37
  %38 = load %struct.op*, %struct.op** %curop, align 8
  %tobool45 = icmp ne %struct.op* %38, null
  br i1 %tobool45, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %39 = load %struct.op*, %struct.op** %curop, align 8
  %op_type46 = getelementptr inbounds %struct.op, %struct.op* %39, i32 0, i32 4
  %40 = load i16, i16* %op_type46, align 2
  %conv47 = zext i16 %40 to i32
  %cmp48 = icmp eq i32 %conv47, 134
  br i1 %cmp48, label %land.lhs.true.50, label %if.end.61

land.lhs.true.50:                                 ; preds = %for.body
  %41 = load %struct.op*, %struct.op** %curop, align 8
  %42 = bitcast %struct.op* %41 to %struct.unop*
  %op_first51 = getelementptr inbounds %struct.unop, %struct.unop* %42, i32 0, i32 8
  %43 = load %struct.op*, %struct.op** %op_first51, align 8
  %op_type52 = getelementptr inbounds %struct.op, %struct.op* %43, i32 0, i32 4
  %44 = load i16, i16* %op_type52, align 2
  %conv53 = zext i16 %44 to i32
  %cmp54 = icmp ne i32 %conv53, 7
  br i1 %cmp54, label %if.then.56, label %if.end.61

if.then.56:                                       ; preds = %land.lhs.true.50
  %45 = load %struct.op*, %struct.op** %o, align 8
  %op_private57 = getelementptr inbounds %struct.op, %struct.op* %45, i32 0, i32 7
  %46 = load i8, i8* %op_private57, align 1
  %conv58 = zext i8 %46 to i32
  %or59 = or i32 %conv58, 32
  %conv60 = trunc i32 %or59 to i8
  store i8 %conv60, i8* %op_private57, align 1
  br label %for.end

if.end.61:                                        ; preds = %land.lhs.true.50, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end.61
  %47 = load %struct.op*, %struct.op** %curop, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %47, i32 0, i32 1
  %48 = load %struct.op*, %struct.op** %op_sibling, align 8
  store %struct.op* %48, %struct.op** %curop, align 8
  br label %for.cond

for.end:                                          ; preds = %if.then.56, %for.cond
  %49 = load %struct.op*, %struct.op** %left.addr, align 8
  %op_private62 = getelementptr inbounds %struct.op, %struct.op* %49, i32 0, i32 7
  %50 = load i8, i8* %op_private62, align 1
  %conv63 = zext i8 %50 to i32
  %and64 = and i32 %conv63, 128
  %tobool65 = icmp ne i32 %and64, 0
  br i1 %tobool65, label %if.end.213, label %if.then.66

if.then.66:                                       ; preds = %for.end
  %51 = load %struct.op*, %struct.op** %o, align 8
  store %struct.op* %51, %struct.op** %lastop, align 8
  %52 = load i32, i32* @PL_generation, align 4
  %inc = add nsw i32 %52, 1
  store i32 %inc, i32* @PL_generation, align 4
  %53 = load %struct.op*, %struct.op** %o, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %53, i32 0, i32 0
  %54 = load %struct.op*, %struct.op** %op_next, align 8
  %tobool67 = icmp ne %struct.op* %54, null
  br i1 %tobool67, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.66
  %55 = load %struct.op*, %struct.op** %o, align 8
  %op_next68 = getelementptr inbounds %struct.op, %struct.op* %55, i32 0, i32 0
  %56 = load %struct.op*, %struct.op** %op_next68, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then.66
  %57 = load %struct.op*, %struct.op** %o, align 8
  %call69 = call %struct.op* @Perl_linklist(%struct.op* %57)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.op* [ %56, %cond.true ], [ %call69, %cond.false ]
  store %struct.op* %cond, %struct.op** %curop, align 8
  br label %for.cond.70

for.cond.70:                                      ; preds = %cond.end.202, %cond.end
  %58 = load %struct.op*, %struct.op** %curop, align 8
  %59 = load %struct.op*, %struct.op** %o, align 8
  %cmp71 = icmp ne %struct.op* %58, %59
  br i1 %cmp71, label %for.body.73, label %for.end.204

for.body.73:                                      ; preds = %for.cond.70
  %60 = load %struct.op*, %struct.op** %curop, align 8
  %op_type74 = getelementptr inbounds %struct.op, %struct.op* %60, i32 0, i32 4
  %61 = load i16, i16* %op_type74, align 2
  %idxprom = zext i16 %61 to i64
  %arrayidx = getelementptr inbounds [0 x i32], [0 x i32]* @PL_opargs, i32 0, i64 %idxprom
  %62 = load i32, i32* %arrayidx, align 4
  %and75 = and i32 %62, 64
  %tobool76 = icmp ne i32 %and75, 0
  br i1 %tobool76, label %if.then.77, label %if.end.194

if.then.77:                                       ; preds = %for.body.73
  %63 = load %struct.op*, %struct.op** %curop, align 8
  %op_type78 = getelementptr inbounds %struct.op, %struct.op* %63, i32 0, i32 4
  %64 = load i16, i16* %op_type78, align 2
  %conv79 = zext i16 %64 to i32
  %cmp80 = icmp eq i32 %conv79, 7
  br i1 %cmp80, label %if.then.82, label %if.else.94

if.then.82:                                       ; preds = %if.then.77
  %65 = load %struct.op*, %struct.op** %curop, align 8
  %66 = bitcast %struct.op* %65 to %struct.svop*
  %op_sv = getelementptr inbounds %struct.svop, %struct.svop* %66, i32 0, i32 8
  %67 = load %struct.sv*, %struct.sv** %op_sv, align 8
  %68 = bitcast %struct.sv* %67 to %struct.gv*
  store %struct.gv* %68, %struct.gv** %gv, align 8
  %69 = load %struct.gv*, %struct.gv** %gv, align 8
  %70 = load %struct.gv*, %struct.gv** @PL_defgv, align 8
  %cmp83 = icmp eq %struct.gv* %69, %70
  br i1 %cmp83, label %if.then.89, label %lor.lhs.false.85

lor.lhs.false.85:                                 ; preds = %if.then.82
  %71 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any = getelementptr inbounds %struct.gv, %struct.gv* %71, i32 0, i32 0
  %72 = load %struct.xpvgv*, %struct.xpvgv** %sv_any, align 8
  %73 = bitcast %struct.xpvgv* %72 to %struct.xpv*
  %xpv_cur = getelementptr inbounds %struct.xpv, %struct.xpv* %73, i32 0, i32 1
  %74 = load i64, i64* %xpv_cur, align 8
  %conv86 = trunc i64 %74 to i32
  %75 = load i32, i32* @PL_generation, align 4
  %cmp87 = icmp eq i32 %conv86, %75
  br i1 %cmp87, label %if.then.89, label %if.end.90

if.then.89:                                       ; preds = %lor.lhs.false.85, %if.then.82
  br label %for.end.204

if.end.90:                                        ; preds = %lor.lhs.false.85
  %76 = load i32, i32* @PL_generation, align 4
  %conv91 = sext i32 %76 to i64
  %77 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any92 = getelementptr inbounds %struct.gv, %struct.gv* %77, i32 0, i32 0
  %78 = load %struct.xpvgv*, %struct.xpvgv** %sv_any92, align 8
  %79 = bitcast %struct.xpvgv* %78 to %struct.xpv*
  %xpv_cur93 = getelementptr inbounds %struct.xpv, %struct.xpv* %79, i32 0, i32 1
  store i64 %conv91, i64* %xpv_cur93, align 8
  br label %if.end.193

if.else.94:                                       ; preds = %if.then.77
  %80 = load %struct.op*, %struct.op** %curop, align 8
  %op_type95 = getelementptr inbounds %struct.op, %struct.op* %80, i32 0, i32 4
  %81 = load i16, i16* %op_type95, align 2
  %conv96 = zext i16 %81 to i32
  %cmp97 = icmp eq i32 %conv96, 9
  br i1 %cmp97, label %if.then.114, label %lor.lhs.false.99

lor.lhs.false.99:                                 ; preds = %if.else.94
  %82 = load %struct.op*, %struct.op** %curop, align 8
  %op_type100 = getelementptr inbounds %struct.op, %struct.op* %82, i32 0, i32 4
  %83 = load i16, i16* %op_type100, align 2
  %conv101 = zext i16 %83 to i32
  %cmp102 = icmp eq i32 %conv101, 10
  br i1 %cmp102, label %if.then.114, label %lor.lhs.false.104

lor.lhs.false.104:                                ; preds = %lor.lhs.false.99
  %84 = load %struct.op*, %struct.op** %curop, align 8
  %op_type105 = getelementptr inbounds %struct.op, %struct.op* %84, i32 0, i32 4
  %85 = load i16, i16* %op_type105, align 2
  %conv106 = zext i16 %85 to i32
  %cmp107 = icmp eq i32 %conv106, 11
  br i1 %cmp107, label %if.then.114, label %lor.lhs.false.109

lor.lhs.false.109:                                ; preds = %lor.lhs.false.104
  %86 = load %struct.op*, %struct.op** %curop, align 8
  %op_type110 = getelementptr inbounds %struct.op, %struct.op* %86, i32 0, i32 4
  %87 = load i16, i16* %op_type110, align 2
  %conv111 = zext i16 %87 to i32
  %cmp112 = icmp eq i32 %conv111, 12
  br i1 %cmp112, label %if.then.114, label %if.else.131

if.then.114:                                      ; preds = %lor.lhs.false.109, %lor.lhs.false.104, %lor.lhs.false.99, %if.else.94
  %88 = load %struct.op*, %struct.op** %curop, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %88, i32 0, i32 3
  %89 = load i64, i64* %op_targ, align 8
  %90 = load %struct.av*, %struct.av** @PL_comppad_name, align 8
  %sv_any115 = getelementptr inbounds %struct.av, %struct.av* %90, i32 0, i32 0
  %91 = load %struct.xpvav*, %struct.xpvav** %sv_any115, align 8
  %xav_array = getelementptr inbounds %struct.xpvav, %struct.xpvav* %91, i32 0, i32 0
  %92 = load i8*, i8** %xav_array, align 8
  %93 = bitcast i8* %92 to %struct.sv**
  %arrayidx116 = getelementptr inbounds %struct.sv*, %struct.sv** %93, i64 %89
  %94 = load %struct.sv*, %struct.sv** %arrayidx116, align 8
  %sv_any117 = getelementptr inbounds %struct.sv, %struct.sv* %94, i32 0, i32 0
  %95 = load i8*, i8** %sv_any117, align 8
  %96 = bitcast i8* %95 to %struct.xpv*
  %xpv_cur118 = getelementptr inbounds %struct.xpv, %struct.xpv* %96, i32 0, i32 1
  %97 = load i64, i64* %xpv_cur118, align 8
  %conv119 = trunc i64 %97 to i32
  %98 = load i32, i32* @PL_generation, align 4
  %cmp120 = icmp eq i32 %conv119, %98
  br i1 %cmp120, label %if.then.122, label %if.end.123

if.then.122:                                      ; preds = %if.then.114
  br label %for.end.204

if.end.123:                                       ; preds = %if.then.114
  %99 = load i32, i32* @PL_generation, align 4
  %conv124 = sext i32 %99 to i64
  %100 = load %struct.op*, %struct.op** %curop, align 8
  %op_targ125 = getelementptr inbounds %struct.op, %struct.op* %100, i32 0, i32 3
  %101 = load i64, i64* %op_targ125, align 8
  %102 = load %struct.av*, %struct.av** @PL_comppad_name, align 8
  %sv_any126 = getelementptr inbounds %struct.av, %struct.av* %102, i32 0, i32 0
  %103 = load %struct.xpvav*, %struct.xpvav** %sv_any126, align 8
  %xav_array127 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %103, i32 0, i32 0
  %104 = load i8*, i8** %xav_array127, align 8
  %105 = bitcast i8* %104 to %struct.sv**
  %arrayidx128 = getelementptr inbounds %struct.sv*, %struct.sv** %105, i64 %101
  %106 = load %struct.sv*, %struct.sv** %arrayidx128, align 8
  %sv_any129 = getelementptr inbounds %struct.sv, %struct.sv* %106, i32 0, i32 0
  %107 = load i8*, i8** %sv_any129, align 8
  %108 = bitcast i8* %107 to %struct.xpv*
  %xpv_cur130 = getelementptr inbounds %struct.xpv, %struct.xpv* %108, i32 0, i32 1
  store i64 %conv124, i64* %xpv_cur130, align 8
  br label %if.end.192

if.else.131:                                      ; preds = %lor.lhs.false.109
  %109 = load %struct.op*, %struct.op** %curop, align 8
  %op_type132 = getelementptr inbounds %struct.op, %struct.op* %109, i32 0, i32 4
  %110 = load i16, i16* %op_type132, align 2
  %conv133 = zext i16 %110 to i32
  %cmp134 = icmp eq i32 %conv133, 17
  br i1 %cmp134, label %if.then.136, label %if.else.137

if.then.136:                                      ; preds = %if.else.131
  br label %for.end.204

if.else.137:                                      ; preds = %if.else.131
  %111 = load %struct.op*, %struct.op** %curop, align 8
  %op_type138 = getelementptr inbounds %struct.op, %struct.op* %111, i32 0, i32 4
  %112 = load i16, i16* %op_type138, align 2
  %conv139 = zext i16 %112 to i32
  %cmp140 = icmp eq i32 %conv139, 15
  br i1 %cmp140, label %if.then.157, label %lor.lhs.false.142

lor.lhs.false.142:                                ; preds = %if.else.137
  %113 = load %struct.op*, %struct.op** %curop, align 8
  %op_type143 = getelementptr inbounds %struct.op, %struct.op* %113, i32 0, i32 4
  %114 = load i16, i16* %op_type143, align 2
  %conv144 = zext i16 %114 to i32
  %cmp145 = icmp eq i32 %conv144, 125
  br i1 %cmp145, label %if.then.157, label %lor.lhs.false.147

lor.lhs.false.147:                                ; preds = %lor.lhs.false.142
  %115 = load %struct.op*, %struct.op** %curop, align 8
  %op_type148 = getelementptr inbounds %struct.op, %struct.op* %115, i32 0, i32 4
  %116 = load i16, i16* %op_type148, align 2
  %conv149 = zext i16 %116 to i32
  %cmp150 = icmp eq i32 %conv149, 134
  br i1 %cmp150, label %if.then.157, label %lor.lhs.false.152

lor.lhs.false.152:                                ; preds = %lor.lhs.false.147
  %117 = load %struct.op*, %struct.op** %curop, align 8
  %op_type153 = getelementptr inbounds %struct.op, %struct.op* %117, i32 0, i32 4
  %118 = load i16, i16* %op_type153, align 2
  %conv154 = zext i16 %118 to i32
  %cmp155 = icmp eq i32 %conv154, 14
  br i1 %cmp155, label %if.then.157, label %if.else.164

if.then.157:                                      ; preds = %lor.lhs.false.152, %lor.lhs.false.147, %lor.lhs.false.142, %if.else.137
  %119 = load %struct.op*, %struct.op** %lastop, align 8
  %op_type158 = getelementptr inbounds %struct.op, %struct.op* %119, i32 0, i32 4
  %120 = load i16, i16* %op_type158, align 2
  %conv159 = zext i16 %120 to i32
  %cmp160 = icmp ne i32 %conv159, 7
  br i1 %cmp160, label %if.then.162, label %if.end.163

if.then.162:                                      ; preds = %if.then.157
  br label %for.end.204

if.end.163:                                       ; preds = %if.then.157
  br label %if.end.190

if.else.164:                                      ; preds = %lor.lhs.false.152
  %121 = load %struct.op*, %struct.op** %curop, align 8
  %op_type165 = getelementptr inbounds %struct.op, %struct.op* %121, i32 0, i32 4
  %122 = load i16, i16* %op_type165, align 2
  %conv166 = zext i16 %122 to i32
  %cmp167 = icmp eq i32 %conv166, 13
  br i1 %cmp167, label %if.then.169, label %if.else.188

if.then.169:                                      ; preds = %if.else.164
  %123 = load %struct.op*, %struct.op** %curop, align 8
  %124 = bitcast %struct.op* %123 to %struct.pmop*
  %op_pmreplroot = getelementptr inbounds %struct.pmop, %struct.pmop* %124, i32 0, i32 10
  %125 = load %struct.op*, %struct.op** %op_pmreplroot, align 8
  %tobool170 = icmp ne %struct.op* %125, null
  br i1 %tobool170, label %if.then.171, label %if.end.187

if.then.171:                                      ; preds = %if.then.169
  %126 = load %struct.op*, %struct.op** %curop, align 8
  %127 = bitcast %struct.op* %126 to %struct.pmop*
  %op_pmreplroot173 = getelementptr inbounds %struct.pmop, %struct.pmop* %127, i32 0, i32 10
  %128 = load %struct.op*, %struct.op** %op_pmreplroot173, align 8
  %129 = bitcast %struct.op* %128 to %struct.gv*
  store %struct.gv* %129, %struct.gv** %gv172, align 8
  %130 = load %struct.gv*, %struct.gv** %gv172, align 8
  %131 = load %struct.gv*, %struct.gv** @PL_defgv, align 8
  %cmp174 = icmp eq %struct.gv* %130, %131
  br i1 %cmp174, label %if.then.182, label %lor.lhs.false.176

lor.lhs.false.176:                                ; preds = %if.then.171
  %132 = load %struct.gv*, %struct.gv** %gv172, align 8
  %sv_any177 = getelementptr inbounds %struct.gv, %struct.gv* %132, i32 0, i32 0
  %133 = load %struct.xpvgv*, %struct.xpvgv** %sv_any177, align 8
  %134 = bitcast %struct.xpvgv* %133 to %struct.xpv*
  %xpv_cur178 = getelementptr inbounds %struct.xpv, %struct.xpv* %134, i32 0, i32 1
  %135 = load i64, i64* %xpv_cur178, align 8
  %conv179 = trunc i64 %135 to i32
  %136 = load i32, i32* @PL_generation, align 4
  %cmp180 = icmp eq i32 %conv179, %136
  br i1 %cmp180, label %if.then.182, label %if.end.183

if.then.182:                                      ; preds = %lor.lhs.false.176, %if.then.171
  br label %for.end.204

if.end.183:                                       ; preds = %lor.lhs.false.176
  %137 = load i32, i32* @PL_generation, align 4
  %conv184 = sext i32 %137 to i64
  %138 = load %struct.gv*, %struct.gv** %gv172, align 8
  %sv_any185 = getelementptr inbounds %struct.gv, %struct.gv* %138, i32 0, i32 0
  %139 = load %struct.xpvgv*, %struct.xpvgv** %sv_any185, align 8
  %140 = bitcast %struct.xpvgv* %139 to %struct.xpv*
  %xpv_cur186 = getelementptr inbounds %struct.xpv, %struct.xpv* %140, i32 0, i32 1
  store i64 %conv184, i64* %xpv_cur186, align 8
  br label %if.end.187

if.end.187:                                       ; preds = %if.end.183, %if.then.169
  br label %if.end.189

if.else.188:                                      ; preds = %if.else.164
  br label %for.end.204

if.end.189:                                       ; preds = %if.end.187
  br label %if.end.190

if.end.190:                                       ; preds = %if.end.189, %if.end.163
  br label %if.end.191

if.end.191:                                       ; preds = %if.end.190
  br label %if.end.192

if.end.192:                                       ; preds = %if.end.191, %if.end.123
  br label %if.end.193

if.end.193:                                       ; preds = %if.end.192, %if.end.90
  br label %if.end.194

if.end.194:                                       ; preds = %if.end.193, %for.body.73
  %141 = load %struct.op*, %struct.op** %curop, align 8
  store %struct.op* %141, %struct.op** %lastop, align 8
  br label %for.inc.195

for.inc.195:                                      ; preds = %if.end.194
  %142 = load %struct.op*, %struct.op** %curop, align 8
  %op_next196 = getelementptr inbounds %struct.op, %struct.op* %142, i32 0, i32 0
  %143 = load %struct.op*, %struct.op** %op_next196, align 8
  %tobool197 = icmp ne %struct.op* %143, null
  br i1 %tobool197, label %cond.true.198, label %cond.false.200

cond.true.198:                                    ; preds = %for.inc.195
  %144 = load %struct.op*, %struct.op** %curop, align 8
  %op_next199 = getelementptr inbounds %struct.op, %struct.op* %144, i32 0, i32 0
  %145 = load %struct.op*, %struct.op** %op_next199, align 8
  br label %cond.end.202

cond.false.200:                                   ; preds = %for.inc.195
  %146 = load %struct.op*, %struct.op** %curop, align 8
  %call201 = call %struct.op* @Perl_linklist(%struct.op* %146)
  br label %cond.end.202

cond.end.202:                                     ; preds = %cond.false.200, %cond.true.198
  %cond203 = phi %struct.op* [ %145, %cond.true.198 ], [ %call201, %cond.false.200 ]
  store %struct.op* %cond203, %struct.op** %curop, align 8
  br label %for.cond.70

for.end.204:                                      ; preds = %if.else.188, %if.then.182, %if.then.162, %if.then.136, %if.then.122, %if.then.89, %for.cond.70
  %147 = load %struct.op*, %struct.op** %curop, align 8
  %148 = load %struct.op*, %struct.op** %o, align 8
  %cmp205 = icmp ne %struct.op* %147, %148
  br i1 %cmp205, label %if.then.207, label %if.end.212

if.then.207:                                      ; preds = %for.end.204
  %149 = load %struct.op*, %struct.op** %o, align 8
  %op_private208 = getelementptr inbounds %struct.op, %struct.op* %149, i32 0, i32 7
  %150 = load i8, i8* %op_private208, align 1
  %conv209 = zext i8 %150 to i32
  %or210 = or i32 %conv209, 64
  %conv211 = trunc i32 %or210 to i8
  store i8 %conv211, i8* %op_private208, align 1
  br label %if.end.212

if.end.212:                                       ; preds = %if.then.207, %for.end.204
  br label %if.end.213

if.end.213:                                       ; preds = %if.end.212, %for.end
  %151 = load %struct.op*, %struct.op** %right.addr, align 8
  %tobool214 = icmp ne %struct.op* %151, null
  br i1 %tobool214, label %land.lhs.true.215, label %if.end.287

land.lhs.true.215:                                ; preds = %if.end.213
  %152 = load %struct.op*, %struct.op** %right.addr, align 8
  %op_type216 = getelementptr inbounds %struct.op, %struct.op* %152, i32 0, i32 4
  %153 = load i16, i16* %op_type216, align 2
  %conv217 = zext i16 %153 to i32
  %cmp218 = icmp eq i32 %conv217, 139
  br i1 %cmp218, label %if.then.220, label %if.end.287

if.then.220:                                      ; preds = %land.lhs.true.215
  %154 = load %struct.op*, %struct.op** %right.addr, align 8
  %155 = bitcast %struct.op* %154 to %struct.listop*
  %op_first221 = getelementptr inbounds %struct.listop, %struct.listop* %155, i32 0, i32 8
  %156 = load %struct.op*, %struct.op** %op_first221, align 8
  store %struct.op* %156, %struct.op** %tmpop, align 8
  %tobool222 = icmp ne %struct.op* %156, null
  br i1 %tobool222, label %land.lhs.true.223, label %if.end.286

land.lhs.true.223:                                ; preds = %if.then.220
  %157 = load %struct.op*, %struct.op** %tmpop, align 8
  %op_type224 = getelementptr inbounds %struct.op, %struct.op* %157, i32 0, i32 4
  %158 = load i16, i16* %op_type224, align 2
  %conv225 = zext i16 %158 to i32
  %cmp226 = icmp eq i32 %conv225, 13
  br i1 %cmp226, label %if.then.228, label %if.end.286

if.then.228:                                      ; preds = %land.lhs.true.223
  %159 = load %struct.op*, %struct.op** %tmpop, align 8
  %160 = bitcast %struct.op* %159 to %struct.pmop*
  store %struct.pmop* %160, %struct.pmop** %pm, align 8
  %161 = load %struct.op*, %struct.op** %left.addr, align 8
  %op_type229 = getelementptr inbounds %struct.op, %struct.op* %161, i32 0, i32 4
  %162 = load i16, i16* %op_type229, align 2
  %conv230 = zext i16 %162 to i32
  %cmp231 = icmp eq i32 %conv230, 125
  br i1 %cmp231, label %land.lhs.true.233, label %if.else.267

land.lhs.true.233:                                ; preds = %if.then.228
  %163 = load %struct.op*, %struct.op** %left.addr, align 8
  %op_private234 = getelementptr inbounds %struct.op, %struct.op* %163, i32 0, i32 7
  %164 = load i8, i8* %op_private234, align 1
  %conv235 = zext i8 %164 to i32
  %and236 = and i32 %conv235, 128
  %tobool237 = icmp ne i32 %and236, 0
  br i1 %tobool237, label %if.else.267, label %land.lhs.true.238

land.lhs.true.238:                                ; preds = %land.lhs.true.233
  %165 = load %struct.op*, %struct.op** %o, align 8
  %op_private239 = getelementptr inbounds %struct.op, %struct.op* %165, i32 0, i32 7
  %166 = load i8, i8* %op_private239, align 1
  %conv240 = zext i8 %166 to i32
  %and241 = and i32 %conv240, 64
  %tobool242 = icmp ne i32 %and241, 0
  br i1 %tobool242, label %if.else.267, label %if.then.243

if.then.243:                                      ; preds = %land.lhs.true.238
  %167 = load %struct.op*, %struct.op** %left.addr, align 8
  %168 = bitcast %struct.op* %167 to %struct.unop*
  %op_first244 = getelementptr inbounds %struct.unop, %struct.unop* %168, i32 0, i32 8
  %169 = load %struct.op*, %struct.op** %op_first244, align 8
  store %struct.op* %169, %struct.op** %tmpop, align 8
  %170 = load %struct.op*, %struct.op** %tmpop, align 8
  %op_type245 = getelementptr inbounds %struct.op, %struct.op* %170, i32 0, i32 4
  %171 = load i16, i16* %op_type245, align 2
  %conv246 = zext i16 %171 to i32
  %cmp247 = icmp eq i32 %conv246, 7
  br i1 %cmp247, label %land.lhs.true.249, label %if.end.266

land.lhs.true.249:                                ; preds = %if.then.243
  %172 = load %struct.pmop*, %struct.pmop** %pm, align 8
  %op_pmreplroot250 = getelementptr inbounds %struct.pmop, %struct.pmop* %172, i32 0, i32 10
  %173 = load %struct.op*, %struct.op** %op_pmreplroot250, align 8
  %tobool251 = icmp ne %struct.op* %173, null
  br i1 %tobool251, label %if.end.266, label %if.then.252

if.then.252:                                      ; preds = %land.lhs.true.249
  %174 = load %struct.op*, %struct.op** %tmpop, align 8
  %175 = bitcast %struct.op* %174 to %struct.svop*
  %op_sv253 = getelementptr inbounds %struct.svop, %struct.svop* %175, i32 0, i32 8
  %176 = load %struct.sv*, %struct.sv** %op_sv253, align 8
  %177 = bitcast %struct.sv* %176 to %struct.op*
  %178 = load %struct.pmop*, %struct.pmop** %pm, align 8
  %op_pmreplroot254 = getelementptr inbounds %struct.pmop, %struct.pmop* %178, i32 0, i32 10
  store %struct.op* %177, %struct.op** %op_pmreplroot254, align 8
  %179 = load %struct.op*, %struct.op** %tmpop, align 8
  %180 = bitcast %struct.op* %179 to %struct.svop*
  %op_sv255 = getelementptr inbounds %struct.svop, %struct.svop* %180, i32 0, i32 8
  store %struct.sv* null, %struct.sv** %op_sv255, align 8
  %181 = load %struct.pmop*, %struct.pmop** %pm, align 8
  %op_pmflags = getelementptr inbounds %struct.pmop, %struct.pmop* %181, i32 0, i32 14
  %182 = load i32, i32* %op_pmflags, align 4
  %or256 = or i32 %182, 2
  store i32 %or256, i32* %op_pmflags, align 4
  %183 = load %struct.op*, %struct.op** %o, align 8
  %184 = bitcast %struct.op* %183 to %struct.unop*
  %op_first257 = getelementptr inbounds %struct.unop, %struct.unop* %184, i32 0, i32 8
  %185 = load %struct.op*, %struct.op** %op_first257, align 8
  store %struct.op* %185, %struct.op** %tmpop, align 8
  %186 = load %struct.op*, %struct.op** %tmpop, align 8
  %187 = bitcast %struct.op* %186 to %struct.unop*
  %op_first258 = getelementptr inbounds %struct.unop, %struct.unop* %187, i32 0, i32 8
  %188 = load %struct.op*, %struct.op** %op_first258, align 8
  store %struct.op* %188, %struct.op** %tmpop, align 8
  %189 = load %struct.op*, %struct.op** %tmpop, align 8
  %op_sibling259 = getelementptr inbounds %struct.op, %struct.op* %189, i32 0, i32 1
  store %struct.op* null, %struct.op** %op_sibling259, align 8
  %190 = load %struct.op*, %struct.op** %tmpop, align 8
  %op_next260 = getelementptr inbounds %struct.op, %struct.op* %190, i32 0, i32 0
  %191 = load %struct.op*, %struct.op** %op_next260, align 8
  %192 = load %struct.op*, %struct.op** %right.addr, align 8
  %op_next261 = getelementptr inbounds %struct.op, %struct.op* %192, i32 0, i32 0
  store %struct.op* %191, %struct.op** %op_next261, align 8
  %193 = load %struct.op*, %struct.op** %o, align 8
  call void @Perl_op_free(%struct.op* %193)
  %194 = load %struct.op*, %struct.op** %right.addr, align 8
  %op_flags262 = getelementptr inbounds %struct.op, %struct.op* %194, i32 0, i32 6
  %195 = load i8, i8* %op_flags262, align 1
  %conv263 = zext i8 %195 to i32
  %and264 = and i32 %conv263, -4
  %conv265 = trunc i32 %and264 to i8
  store i8 %conv265, i8* %op_flags262, align 1
  %196 = load %struct.op*, %struct.op** %right.addr, align 8
  store %struct.op* %196, %struct.op** %retval
  br label %return

if.end.266:                                       ; preds = %land.lhs.true.249, %if.then.243
  br label %if.end.285

if.else.267:                                      ; preds = %land.lhs.true.238, %land.lhs.true.233, %if.then.228
  %197 = load i32, i32* @PL_modcount, align 4
  %cmp268 = icmp slt i32 %197, 1073741823
  br i1 %cmp268, label %land.lhs.true.270, label %if.end.284

land.lhs.true.270:                                ; preds = %if.else.267
  %198 = load %struct.op*, %struct.op** %right.addr, align 8
  %199 = bitcast %struct.op* %198 to %struct.listop*
  %op_last = getelementptr inbounds %struct.listop, %struct.listop* %199, i32 0, i32 9
  %200 = load %struct.op*, %struct.op** %op_last, align 8
  %op_type271 = getelementptr inbounds %struct.op, %struct.op* %200, i32 0, i32 4
  %201 = load i16, i16* %op_type271, align 2
  %conv272 = zext i16 %201 to i32
  %cmp273 = icmp eq i32 %conv272, 5
  br i1 %cmp273, label %if.then.275, label %if.end.284

if.then.275:                                      ; preds = %land.lhs.true.270
  %202 = load %struct.op*, %struct.op** %right.addr, align 8
  %203 = bitcast %struct.op* %202 to %struct.listop*
  %op_last276 = getelementptr inbounds %struct.listop, %struct.listop* %203, i32 0, i32 9
  %204 = load %struct.op*, %struct.op** %op_last276, align 8
  %205 = bitcast %struct.op* %204 to %struct.svop*
  %op_sv277 = getelementptr inbounds %struct.svop, %struct.svop* %205, i32 0, i32 8
  %206 = load %struct.sv*, %struct.sv** %op_sv277, align 8
  store %struct.sv* %206, %struct.sv** %sv, align 8
  %207 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any278 = getelementptr inbounds %struct.sv, %struct.sv* %207, i32 0, i32 0
  %208 = load i8*, i8** %sv_any278, align 8
  %209 = bitcast i8* %208 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %209, i32 0, i32 3
  %210 = load i64, i64* %xiv_iv, align 8
  %cmp279 = icmp eq i64 %210, 0
  br i1 %cmp279, label %if.then.281, label %if.end.283

if.then.281:                                      ; preds = %if.then.275
  %211 = load %struct.sv*, %struct.sv** %sv, align 8
  %212 = load i32, i32* @PL_modcount, align 4
  %add = add nsw i32 %212, 1
  %conv282 = sext i32 %add to i64
  call void @Perl_sv_setiv(%struct.sv* %211, i64 %conv282)
  br label %if.end.283

if.end.283:                                       ; preds = %if.then.281, %if.then.275
  br label %if.end.284

if.end.284:                                       ; preds = %if.end.283, %land.lhs.true.270, %if.else.267
  br label %if.end.285

if.end.285:                                       ; preds = %if.end.284, %if.end.266
  br label %if.end.286

if.end.286:                                       ; preds = %if.end.285, %land.lhs.true.223, %if.then.220
  br label %if.end.287

if.end.287:                                       ; preds = %if.end.286, %land.lhs.true.215, %if.end.213
  %213 = load %struct.op*, %struct.op** %o, align 8
  store %struct.op* %213, %struct.op** %retval
  br label %return

if.end.288:                                       ; preds = %if.end
  %214 = load %struct.op*, %struct.op** %right.addr, align 8
  %tobool289 = icmp ne %struct.op* %214, null
  br i1 %tobool289, label %if.end.292, label %if.then.290

if.then.290:                                      ; preds = %if.end.288
  %call291 = call %struct.op* @Perl_newOP(i32 43, i32 0)
  store %struct.op* %call291, %struct.op** %right.addr, align 8
  br label %if.end.292

if.end.292:                                       ; preds = %if.then.290, %if.end.288
  %215 = load %struct.op*, %struct.op** %right.addr, align 8
  %op_type293 = getelementptr inbounds %struct.op, %struct.op* %215, i32 0, i32 4
  %216 = load i16, i16* %op_type293, align 2
  %conv294 = zext i16 %216 to i32
  %cmp295 = icmp eq i32 %conv294, 26
  br i1 %cmp295, label %if.then.297, label %if.else.306

if.then.297:                                      ; preds = %if.end.292
  %217 = load %struct.op*, %struct.op** %right.addr, align 8
  %op_flags298 = getelementptr inbounds %struct.op, %struct.op* %217, i32 0, i32 6
  %218 = load i8, i8* %op_flags298, align 1
  %conv299 = zext i8 %218 to i32
  %or300 = or i32 %conv299, 64
  %conv301 = trunc i32 %or300 to i8
  store i8 %conv301, i8* %op_flags298, align 1
  %219 = load i32, i32* %flags.addr, align 4
  %220 = load %struct.op*, %struct.op** %left.addr, align 8
  %call302 = call %struct.op* @Perl_scalar(%struct.op* %220)
  %call303 = call %struct.op* @Perl_mod(%struct.op* %call302, i32 36)
  %221 = load %struct.op*, %struct.op** %right.addr, align 8
  %call304 = call %struct.op* @Perl_scalar(%struct.op* %221)
  %call305 = call %struct.op* @Perl_newBINOP(i32 0, i32 %219, %struct.op* %call303, %struct.op* %call304)
  store %struct.op* %call305, %struct.op** %retval
  br label %return

if.else.306:                                      ; preds = %if.end.292
  %222 = load %struct.op*, %struct.op** %right.addr, align 8
  store %struct.op* %222, %struct.op** @PL_eval_start, align 8
  %223 = load i32, i32* %flags.addr, align 4
  %224 = load %struct.op*, %struct.op** %right.addr, align 8
  %call307 = call %struct.op* @Perl_scalar(%struct.op* %224)
  %225 = load %struct.op*, %struct.op** %left.addr, align 8
  %call308 = call %struct.op* @Perl_scalar(%struct.op* %225)
  %call309 = call %struct.op* @Perl_mod(%struct.op* %call308, i32 36)
  %call310 = call %struct.op* @Perl_newBINOP(i32 36, i32 %223, %struct.op* %call307, %struct.op* %call309)
  store %struct.op* %call310, %struct.op** %o, align 8
  %226 = load %struct.op*, %struct.op** @PL_eval_start, align 8
  %tobool311 = icmp ne %struct.op* %226, null
  br i1 %tobool311, label %if.then.312, label %if.else.313

if.then.312:                                      ; preds = %if.else.306
  store %struct.op* null, %struct.op** @PL_eval_start, align 8
  br label %if.end.314

if.else.313:                                      ; preds = %if.else.306
  %227 = load %struct.op*, %struct.op** %o, align 8
  call void @Perl_op_free(%struct.op* %227)
  store %struct.op* null, %struct.op** %retval
  br label %return

if.end.314:                                       ; preds = %if.then.312
  br label %if.end.315

if.end.315:                                       ; preds = %if.end.314
  %228 = load %struct.op*, %struct.op** %o, align 8
  store %struct.op* %228, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.315, %if.else.313, %if.then.297, %if.end.287, %if.then.252, %if.then.33, %if.else.17, %if.else, %if.then.2
  %229 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %229
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newLOGOP(i32 %type, i32 %flags, %struct.op* %first, %struct.op* %other) #0 {
entry:
  %type.addr = alloca i32, align 4
  %flags.addr = alloca i32, align 4
  %first.addr = alloca %struct.op*, align 8
  %other.addr = alloca %struct.op*, align 8
  store i32 %type, i32* %type.addr, align 4
  store i32 %flags, i32* %flags.addr, align 4
  store %struct.op* %first, %struct.op** %first.addr, align 8
  store %struct.op* %other, %struct.op** %other.addr, align 8
  %0 = load i32, i32* %type.addr, align 4
  %1 = load i32, i32* %flags.addr, align 4
  %call = call %struct.op* @S_new_logop(i32 %0, i32 %1, %struct.op** %first.addr, %struct.op** %other.addr)
  ret %struct.op* %call
}

; Function Attrs: nounwind uwtable
define internal i32 @S_list_assignment(%struct.op* %o) #0 {
entry:
  %retval = alloca i32, align 4
  %o.addr = alloca %struct.op*, align 8
  %t = alloca i32, align 4
  %f = alloca i32, align 4
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %tobool = icmp ne %struct.op* %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 4
  %2 = load i16, i16* %op_type, align 2
  %conv = zext i16 %2 to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %land.lhs.true, label %if.end.5

land.lhs.true:                                    ; preds = %if.end
  %3 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %3, i32 0, i32 6
  %4 = load i8, i8* %op_flags, align 1
  %conv2 = zext i8 %4 to i32
  %and = and i32 %conv2, 4
  %tobool3 = icmp ne i32 %and, 0
  br i1 %tobool3, label %if.then.4, label %if.end.5

if.then.4:                                        ; preds = %land.lhs.true
  %5 = load %struct.op*, %struct.op** %o.addr, align 8
  %6 = bitcast %struct.op* %5 to %struct.unop*
  %op_first = getelementptr inbounds %struct.unop, %struct.unop* %6, i32 0, i32 8
  %7 = load %struct.op*, %struct.op** %op_first, align 8
  store %struct.op* %7, %struct.op** %o.addr, align 8
  br label %if.end.5

if.end.5:                                         ; preds = %if.then.4, %land.lhs.true, %if.end
  %8 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type6 = getelementptr inbounds %struct.op, %struct.op* %8, i32 0, i32 4
  %9 = load i16, i16* %op_type6, align 2
  %conv7 = zext i16 %9 to i32
  %cmp8 = icmp eq i32 %conv7, 162
  br i1 %cmp8, label %if.then.10, label %if.end.26

if.then.10:                                       ; preds = %if.end.5
  %10 = load %struct.op*, %struct.op** %o.addr, align 8
  %11 = bitcast %struct.op* %10 to %struct.logop*
  %op_first11 = getelementptr inbounds %struct.logop, %struct.logop* %11, i32 0, i32 8
  %12 = load %struct.op*, %struct.op** %op_first11, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %12, i32 0, i32 1
  %13 = load %struct.op*, %struct.op** %op_sibling, align 8
  %call = call i32 @S_list_assignment(%struct.op* %13)
  store i32 %call, i32* %t, align 4
  %14 = load %struct.op*, %struct.op** %o.addr, align 8
  %15 = bitcast %struct.op* %14 to %struct.logop*
  %op_first12 = getelementptr inbounds %struct.logop, %struct.logop* %15, i32 0, i32 8
  %16 = load %struct.op*, %struct.op** %op_first12, align 8
  %op_sibling13 = getelementptr inbounds %struct.op, %struct.op* %16, i32 0, i32 1
  %17 = load %struct.op*, %struct.op** %op_sibling13, align 8
  %op_sibling14 = getelementptr inbounds %struct.op, %struct.op* %17, i32 0, i32 1
  %18 = load %struct.op*, %struct.op** %op_sibling14, align 8
  %call15 = call i32 @S_list_assignment(%struct.op* %18)
  store i32 %call15, i32* %f, align 4
  %19 = load i32, i32* %t, align 4
  %tobool16 = icmp ne i32 %19, 0
  br i1 %tobool16, label %land.lhs.true.17, label %if.end.20

land.lhs.true.17:                                 ; preds = %if.then.10
  %20 = load i32, i32* %f, align 4
  %tobool18 = icmp ne i32 %20, 0
  br i1 %tobool18, label %if.then.19, label %if.end.20

if.then.19:                                       ; preds = %land.lhs.true.17
  store i32 1, i32* %retval
  br label %return

if.end.20:                                        ; preds = %land.lhs.true.17, %if.then.10
  %21 = load i32, i32* %t, align 4
  %tobool21 = icmp ne i32 %21, 0
  br i1 %tobool21, label %if.then.23, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end.20
  %22 = load i32, i32* %f, align 4
  %tobool22 = icmp ne i32 %22, 0
  br i1 %tobool22, label %if.then.23, label %if.end.25

if.then.23:                                       ; preds = %lor.lhs.false, %if.end.20
  %call24 = call i32 @Perl_yyerror(i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.143, i32 0, i32 0))
  br label %if.end.25

if.end.25:                                        ; preds = %if.then.23, %lor.lhs.false
  store i32 0, i32* %retval
  br label %return

if.end.26:                                        ; preds = %if.end.5
  %23 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type27 = getelementptr inbounds %struct.op, %struct.op* %23, i32 0, i32 4
  %24 = load i16, i16* %op_type27, align 2
  %conv28 = zext i16 %24 to i32
  %cmp29 = icmp eq i32 %conv28, 141
  br i1 %cmp29, label %land.lhs.true.31, label %if.end.42

land.lhs.true.31:                                 ; preds = %if.end.26
  %25 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags32 = getelementptr inbounds %struct.op, %struct.op* %25, i32 0, i32 6
  %26 = load i8, i8* %op_flags32, align 1
  %conv33 = zext i8 %26 to i32
  %and34 = and i32 %conv33, 3
  %cmp35 = icmp eq i32 %and34, 2
  br i1 %cmp35, label %land.lhs.true.37, label %if.end.42

land.lhs.true.37:                                 ; preds = %land.lhs.true.31
  %27 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %27, i32 0, i32 7
  %28 = load i8, i8* %op_private, align 1
  %conv38 = zext i8 %28 to i32
  %and39 = and i32 %conv38, 128
  %tobool40 = icmp ne i32 %and39, 0
  br i1 %tobool40, label %if.then.41, label %if.end.42

if.then.41:                                       ; preds = %land.lhs.true.37
  store i32 0, i32* %retval
  br label %return

if.end.42:                                        ; preds = %land.lhs.true.37, %land.lhs.true.31, %if.end.26
  %29 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type43 = getelementptr inbounds %struct.op, %struct.op* %29, i32 0, i32 4
  %30 = load i16, i16* %op_type43, align 2
  %conv44 = zext i16 %30 to i32
  %cmp45 = icmp eq i32 %conv44, 141
  br i1 %cmp45, label %if.then.72, label %lor.lhs.false.47

lor.lhs.false.47:                                 ; preds = %if.end.42
  %31 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags48 = getelementptr inbounds %struct.op, %struct.op* %31, i32 0, i32 6
  %32 = load i8, i8* %op_flags48, align 1
  %conv49 = zext i8 %32 to i32
  %and50 = and i32 %conv49, 8
  %tobool51 = icmp ne i32 %and50, 0
  br i1 %tobool51, label %if.then.72, label %lor.lhs.false.52

lor.lhs.false.52:                                 ; preds = %lor.lhs.false.47
  %33 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type53 = getelementptr inbounds %struct.op, %struct.op* %33, i32 0, i32 4
  %34 = load i16, i16* %op_type53, align 2
  %conv54 = zext i16 %34 to i32
  %cmp55 = icmp eq i32 %conv54, 125
  br i1 %cmp55, label %if.then.72, label %lor.lhs.false.57

lor.lhs.false.57:                                 ; preds = %lor.lhs.false.52
  %35 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type58 = getelementptr inbounds %struct.op, %struct.op* %35, i32 0, i32 4
  %36 = load i16, i16* %op_type58, align 2
  %conv59 = zext i16 %36 to i32
  %cmp60 = icmp eq i32 %conv59, 134
  br i1 %cmp60, label %if.then.72, label %lor.lhs.false.62

lor.lhs.false.62:                                 ; preds = %lor.lhs.false.57
  %37 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type63 = getelementptr inbounds %struct.op, %struct.op* %37, i32 0, i32 4
  %38 = load i16, i16* %op_type63, align 2
  %conv64 = zext i16 %38 to i32
  %cmp65 = icmp eq i32 %conv64, 128
  br i1 %cmp65, label %if.then.72, label %lor.lhs.false.67

lor.lhs.false.67:                                 ; preds = %lor.lhs.false.62
  %39 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type68 = getelementptr inbounds %struct.op, %struct.op* %39, i32 0, i32 4
  %40 = load i16, i16* %op_type68, align 2
  %conv69 = zext i16 %40 to i32
  %cmp70 = icmp eq i32 %conv69, 136
  br i1 %cmp70, label %if.then.72, label %if.end.73

if.then.72:                                       ; preds = %lor.lhs.false.67, %lor.lhs.false.62, %lor.lhs.false.57, %lor.lhs.false.52, %lor.lhs.false.47, %if.end.42
  store i32 1, i32* %retval
  br label %return

if.end.73:                                        ; preds = %lor.lhs.false.67
  %41 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type74 = getelementptr inbounds %struct.op, %struct.op* %41, i32 0, i32 4
  %42 = load i16, i16* %op_type74, align 2
  %conv75 = zext i16 %42 to i32
  %cmp76 = icmp eq i32 %conv75, 10
  br i1 %cmp76, label %if.then.83, label %lor.lhs.false.78

lor.lhs.false.78:                                 ; preds = %if.end.73
  %43 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type79 = getelementptr inbounds %struct.op, %struct.op* %43, i32 0, i32 4
  %44 = load i16, i16* %op_type79, align 2
  %conv80 = zext i16 %44 to i32
  %cmp81 = icmp eq i32 %conv80, 11
  br i1 %cmp81, label %if.then.83, label %if.end.84

if.then.83:                                       ; preds = %lor.lhs.false.78, %if.end.73
  store i32 1, i32* %retval
  br label %return

if.end.84:                                        ; preds = %lor.lhs.false.78
  %45 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type85 = getelementptr inbounds %struct.op, %struct.op* %45, i32 0, i32 4
  %46 = load i16, i16* %op_type85, align 2
  %conv86 = zext i16 %46 to i32
  %cmp87 = icmp eq i32 %conv86, 15
  br i1 %cmp87, label %if.then.89, label %if.end.90

if.then.89:                                       ; preds = %if.end.84
  store i32 0, i32* %retval
  br label %return

if.end.90:                                        ; preds = %if.end.84
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.end.90, %if.then.89, %if.then.83, %if.then.72, %if.then.41, %if.end.25, %if.then.19, %if.then
  %47 = load i32, i32* %retval
  ret i32 %47
}

declare void @Perl_sv_setiv(%struct.sv*, i64) #1

declare i32 @Perl_intro_my() #1

; Function Attrs: nounwind uwtable
define internal %struct.op* @S_new_logop(i32 %type, i32 %flags, %struct.op** %firstp, %struct.op** %otherp) #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %type.addr = alloca i32, align 4
  %flags.addr = alloca i32, align 4
  %firstp.addr = alloca %struct.op**, align 8
  %otherp.addr = alloca %struct.op**, align 8
  %logop = alloca %struct.logop*, align 8
  %o = alloca %struct.op*, align 8
  %first = alloca %struct.op*, align 8
  %other = alloca %struct.op*, align 8
  %k1 = alloca %struct.op*, align 8
  %k2 = alloca %struct.op*, align 8
  %warnop = alloca i16, align 2
  %oldline = alloca i32, align 4
  store i32 %type, i32* %type.addr, align 4
  store i32 %flags, i32* %flags.addr, align 4
  store %struct.op** %firstp, %struct.op*** %firstp.addr, align 8
  store %struct.op** %otherp, %struct.op*** %otherp.addr, align 8
  %0 = load %struct.op**, %struct.op*** %firstp.addr, align 8
  %1 = load %struct.op*, %struct.op** %0, align 8
  store %struct.op* %1, %struct.op** %first, align 8
  %2 = load %struct.op**, %struct.op*** %otherp.addr, align 8
  %3 = load %struct.op*, %struct.op** %2, align 8
  store %struct.op* %3, %struct.op** %other, align 8
  %4 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %4, 161
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load i32, i32* %type.addr, align 4
  %6 = load i32, i32* %flags.addr, align 4
  %7 = load %struct.op*, %struct.op** %first, align 8
  %call = call %struct.op* @Perl_scalar(%struct.op* %7)
  %8 = load %struct.op*, %struct.op** %other, align 8
  %call1 = call %struct.op* @Perl_scalar(%struct.op* %8)
  %call2 = call %struct.op* @Perl_newBINOP(i32 %5, i32 %6, %struct.op* %call, %struct.op* %call1)
  store %struct.op* %call2, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %entry
  %9 = load %struct.op*, %struct.op** %first, align 8
  %call3 = call %struct.op* @S_scalarboolean(%struct.op* %9)
  %10 = load %struct.op*, %struct.op** %first, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %10, i32 0, i32 4
  %11 = load i16, i16* %op_type, align 2
  %conv = zext i16 %11 to i32
  %cmp4 = icmp eq i32 %conv, 96
  br i1 %cmp4, label %land.lhs.true, label %if.end.24

land.lhs.true:                                    ; preds = %if.end
  %12 = load %struct.op*, %struct.op** %first, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %12, i32 0, i32 6
  %13 = load i8, i8* %op_flags, align 1
  %conv6 = zext i8 %13 to i32
  %and = and i32 %conv6, 128
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then.7, label %if.end.24

if.then.7:                                        ; preds = %land.lhs.true
  %14 = load i32, i32* %type.addr, align 4
  %cmp8 = icmp eq i32 %14, 159
  br i1 %cmp8, label %if.then.12, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then.7
  %15 = load i32, i32* %type.addr, align 4
  %cmp10 = icmp eq i32 %15, 160
  br i1 %cmp10, label %if.then.12, label %if.end.23

if.then.12:                                       ; preds = %lor.lhs.false, %if.then.7
  %16 = load i32, i32* %type.addr, align 4
  %cmp13 = icmp eq i32 %16, 159
  br i1 %cmp13, label %if.then.15, label %if.else

if.then.15:                                       ; preds = %if.then.12
  store i32 160, i32* %type.addr, align 4
  br label %if.end.16

if.else:                                          ; preds = %if.then.12
  store i32 159, i32* %type.addr, align 4
  br label %if.end.16

if.end.16:                                        ; preds = %if.else, %if.then.15
  %17 = load %struct.op*, %struct.op** %first, align 8
  store %struct.op* %17, %struct.op** %o, align 8
  %18 = load %struct.op*, %struct.op** %o, align 8
  %19 = bitcast %struct.op* %18 to %struct.unop*
  %op_first = getelementptr inbounds %struct.unop, %struct.unop* %19, i32 0, i32 8
  %20 = load %struct.op*, %struct.op** %op_first, align 8
  %21 = load %struct.op**, %struct.op*** %firstp.addr, align 8
  store %struct.op* %20, %struct.op** %21, align 8
  store %struct.op* %20, %struct.op** %first, align 8
  %22 = load %struct.op*, %struct.op** %o, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %22, i32 0, i32 0
  %23 = load %struct.op*, %struct.op** %op_next, align 8
  %tobool17 = icmp ne %struct.op* %23, null
  br i1 %tobool17, label %if.then.18, label %if.end.21

if.then.18:                                       ; preds = %if.end.16
  %24 = load %struct.op*, %struct.op** %o, align 8
  %op_next19 = getelementptr inbounds %struct.op, %struct.op* %24, i32 0, i32 0
  %25 = load %struct.op*, %struct.op** %op_next19, align 8
  %26 = load %struct.op*, %struct.op** %first, align 8
  %op_next20 = getelementptr inbounds %struct.op, %struct.op* %26, i32 0, i32 0
  store %struct.op* %25, %struct.op** %op_next20, align 8
  br label %if.end.21

if.end.21:                                        ; preds = %if.then.18, %if.end.16
  %27 = load %struct.op*, %struct.op** %o, align 8
  %28 = bitcast %struct.op* %27 to %struct.unop*
  %op_first22 = getelementptr inbounds %struct.unop, %struct.unop* %28, i32 0, i32 8
  store %struct.op* null, %struct.op** %op_first22, align 8
  %29 = load %struct.op*, %struct.op** %o, align 8
  call void @Perl_op_free(%struct.op* %29)
  br label %if.end.23

if.end.23:                                        ; preds = %if.end.21, %lor.lhs.false
  br label %if.end.24

if.end.24:                                        ; preds = %if.end.23, %land.lhs.true, %if.end
  %30 = load %struct.op*, %struct.op** %first, align 8
  %op_type25 = getelementptr inbounds %struct.op, %struct.op* %30, i32 0, i32 4
  %31 = load i16, i16* %op_type25, align 2
  %conv26 = zext i16 %31 to i32
  %cmp27 = icmp eq i32 %conv26, 5
  br i1 %cmp27, label %if.then.29, label %if.else.140

if.then.29:                                       ; preds = %if.end.24
  %32 = load %struct.op*, %struct.op** %first, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %32, i32 0, i32 7
  %33 = load i8, i8* %op_private, align 1
  %conv30 = zext i8 %33 to i32
  %and31 = and i32 %conv30, 8
  %tobool32 = icmp ne i32 %and31, 0
  br i1 %tobool32, label %if.then.33, label %if.else.34

if.then.33:                                       ; preds = %if.then.29
  %34 = load %struct.op*, %struct.op** %first, align 8
  call void @S_no_bareword_allowed(%struct.op* %34)
  br label %if.end.65

if.else.34:                                       ; preds = %if.then.29
  %35 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings = getelementptr inbounds %struct.cop, %struct.cop* %35, i32 0, i32 14
  %36 = load %struct.sv*, %struct.sv** %cop_warnings, align 8
  %cmp35 = icmp ne %struct.sv* %36, null
  br i1 %cmp35, label %land.lhs.true.37, label %lor.lhs.false.50

land.lhs.true.37:                                 ; preds = %if.else.34
  %37 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings38 = getelementptr inbounds %struct.cop, %struct.cop* %37, i32 0, i32 14
  %38 = load %struct.sv*, %struct.sv** %cop_warnings38, align 8
  %cmp39 = icmp ne %struct.sv* %38, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 2)
  br i1 %cmp39, label %land.lhs.true.41, label %lor.lhs.false.50

land.lhs.true.41:                                 ; preds = %land.lhs.true.37
  %39 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings42 = getelementptr inbounds %struct.cop, %struct.cop* %39, i32 0, i32 14
  %40 = load %struct.sv*, %struct.sv** %cop_warnings42, align 8
  %cmp43 = icmp eq %struct.sv* %40, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 1)
  br i1 %cmp43, label %land.lhs.true.58, label %lor.lhs.false.45

lor.lhs.false.45:                                 ; preds = %land.lhs.true.41
  %41 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings46 = getelementptr inbounds %struct.cop, %struct.cop* %41, i32 0, i32 14
  %42 = load %struct.sv*, %struct.sv** %cop_warnings46, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %42, i32 0, i32 0
  %43 = load i8*, i8** %sv_any, align 8
  %44 = bitcast i8* %43 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %44, i32 0, i32 0
  %45 = load i8*, i8** %xpv_pv, align 8
  %arrayidx = getelementptr inbounds i8, i8* %45, i64 7
  %46 = load i8, i8* %arrayidx, align 1
  %conv47 = sext i8 %46 to i32
  %and48 = and i32 %conv47, 16
  %tobool49 = icmp ne i32 %and48, 0
  br i1 %tobool49, label %land.lhs.true.58, label %lor.lhs.false.50

lor.lhs.false.50:                                 ; preds = %lor.lhs.false.45, %land.lhs.true.37, %if.else.34
  %47 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings51 = getelementptr inbounds %struct.cop, %struct.cop* %47, i32 0, i32 14
  %48 = load %struct.sv*, %struct.sv** %cop_warnings51, align 8
  %cmp52 = icmp eq %struct.sv* %48, null
  br i1 %cmp52, label %land.lhs.true.54, label %if.end.64

land.lhs.true.54:                                 ; preds = %lor.lhs.false.50
  %49 = load i8, i8* @PL_dowarn, align 1
  %conv55 = zext i8 %49 to i32
  %and56 = and i32 %conv55, 1
  %tobool57 = icmp ne i32 %and56, 0
  br i1 %tobool57, label %land.lhs.true.58, label %if.end.64

land.lhs.true.58:                                 ; preds = %land.lhs.true.54, %lor.lhs.false.45, %land.lhs.true.41
  %50 = load %struct.op*, %struct.op** %first, align 8
  %op_private59 = getelementptr inbounds %struct.op, %struct.op* %50, i32 0, i32 7
  %51 = load i8, i8* %op_private59, align 1
  %conv60 = zext i8 %51 to i32
  %and61 = and i32 %conv60, 64
  %tobool62 = icmp ne i32 %and61, 0
  br i1 %tobool62, label %if.then.63, label %if.end.64

if.then.63:                                       ; preds = %land.lhs.true.58
  call void (i32, i8*, ...) @Perl_warner(i32 30, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.144, i32 0, i32 0))
  br label %if.end.64

if.end.64:                                        ; preds = %if.then.63, %land.lhs.true.58, %land.lhs.true.54, %lor.lhs.false.50
  br label %if.end.65

if.end.65:                                        ; preds = %if.end.64, %if.then.33
  %52 = load i32, i32* %type.addr, align 4
  %cmp66 = icmp eq i32 %52, 159
  %conv67 = zext i1 %cmp66 to i32
  %53 = load %struct.op*, %struct.op** %first, align 8
  %54 = bitcast %struct.op* %53 to %struct.svop*
  %op_sv = getelementptr inbounds %struct.svop, %struct.svop* %54, i32 0, i32 8
  %55 = load %struct.sv*, %struct.sv** %op_sv, align 8
  %tobool68 = icmp ne %struct.sv* %55, null
  br i1 %tobool68, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end.65
  br label %cond.end.115

cond.false:                                       ; preds = %if.end.65
  %56 = load %struct.op*, %struct.op** %first, align 8
  %57 = bitcast %struct.op* %56 to %struct.svop*
  %op_sv69 = getelementptr inbounds %struct.svop, %struct.svop* %57, i32 0, i32 8
  %58 = load %struct.sv*, %struct.sv** %op_sv69, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %58, i32 0, i32 2
  %59 = load i32, i32* %sv_flags, align 4
  %and70 = and i32 %59, 262144
  %tobool71 = icmp ne i32 %and70, 0
  br i1 %tobool71, label %cond.true.72, label %cond.false.86

cond.true.72:                                     ; preds = %cond.false
  %60 = load %struct.op*, %struct.op** %first, align 8
  %61 = bitcast %struct.op* %60 to %struct.svop*
  %op_sv73 = getelementptr inbounds %struct.svop, %struct.svop* %61, i32 0, i32 8
  %62 = load %struct.sv*, %struct.sv** %op_sv73, align 8
  %sv_any74 = getelementptr inbounds %struct.sv, %struct.sv* %62, i32 0, i32 0
  %63 = load i8*, i8** %sv_any74, align 8
  %64 = bitcast i8* %63 to %struct.xpv*
  store %struct.xpv* %64, %struct.xpv** @PL_Xpv, align 8
  %tobool75 = icmp ne %struct.xpv* %64, null
  br i1 %tobool75, label %land.rhs, label %land.end.85

land.rhs:                                         ; preds = %cond.true.72
  %65 = load %struct.xpv*, %struct.xpv** @PL_Xpv, align 8
  %xpv_cur = getelementptr inbounds %struct.xpv, %struct.xpv* %65, i32 0, i32 1
  %66 = load i64, i64* %xpv_cur, align 8
  %cmp76 = icmp ugt i64 %66, 1
  br i1 %cmp76, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.rhs
  %67 = load %struct.xpv*, %struct.xpv** @PL_Xpv, align 8
  %xpv_cur78 = getelementptr inbounds %struct.xpv, %struct.xpv* %67, i32 0, i32 1
  %68 = load i64, i64* %xpv_cur78, align 8
  %tobool79 = icmp ne i64 %68, 0
  br i1 %tobool79, label %land.rhs.80, label %land.end

land.rhs.80:                                      ; preds = %lor.rhs
  %69 = load %struct.xpv*, %struct.xpv** @PL_Xpv, align 8
  %xpv_pv81 = getelementptr inbounds %struct.xpv, %struct.xpv* %69, i32 0, i32 0
  %70 = load i8*, i8** %xpv_pv81, align 8
  %71 = load i8, i8* %70, align 1
  %conv82 = sext i8 %71 to i32
  %cmp83 = icmp ne i32 %conv82, 48
  br label %land.end

land.end:                                         ; preds = %land.rhs.80, %lor.rhs
  %72 = phi i1 [ false, %lor.rhs ], [ %cmp83, %land.rhs.80 ]
  br label %lor.end

lor.end:                                          ; preds = %land.end, %land.rhs
  %73 = phi i1 [ true, %land.rhs ], [ %72, %land.end ]
  br label %land.end.85

land.end.85:                                      ; preds = %lor.end, %cond.true.72
  %74 = phi i1 [ false, %cond.true.72 ], [ %73, %lor.end ]
  %cond = select i1 %74, i32 1, i32 0
  br label %cond.end.113

cond.false.86:                                    ; preds = %cond.false
  %75 = load %struct.op*, %struct.op** %first, align 8
  %76 = bitcast %struct.op* %75 to %struct.svop*
  %op_sv87 = getelementptr inbounds %struct.svop, %struct.svop* %76, i32 0, i32 8
  %77 = load %struct.sv*, %struct.sv** %op_sv87, align 8
  %sv_flags88 = getelementptr inbounds %struct.sv, %struct.sv* %77, i32 0, i32 2
  %78 = load i32, i32* %sv_flags88, align 4
  %and89 = and i32 %78, 65536
  %tobool90 = icmp ne i32 %and89, 0
  br i1 %tobool90, label %cond.true.91, label %cond.false.96

cond.true.91:                                     ; preds = %cond.false.86
  %79 = load %struct.op*, %struct.op** %first, align 8
  %80 = bitcast %struct.op* %79 to %struct.svop*
  %op_sv92 = getelementptr inbounds %struct.svop, %struct.svop* %80, i32 0, i32 8
  %81 = load %struct.sv*, %struct.sv** %op_sv92, align 8
  %sv_any93 = getelementptr inbounds %struct.sv, %struct.sv* %81, i32 0, i32 0
  %82 = load i8*, i8** %sv_any93, align 8
  %83 = bitcast i8* %82 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %83, i32 0, i32 3
  %84 = load i64, i64* %xiv_iv, align 8
  %cmp94 = icmp ne i64 %84, 0
  %conv95 = zext i1 %cmp94 to i32
  br label %cond.end.111

cond.false.96:                                    ; preds = %cond.false.86
  %85 = load %struct.op*, %struct.op** %first, align 8
  %86 = bitcast %struct.op* %85 to %struct.svop*
  %op_sv97 = getelementptr inbounds %struct.svop, %struct.svop* %86, i32 0, i32 8
  %87 = load %struct.sv*, %struct.sv** %op_sv97, align 8
  %sv_flags98 = getelementptr inbounds %struct.sv, %struct.sv* %87, i32 0, i32 2
  %88 = load i32, i32* %sv_flags98, align 4
  %and99 = and i32 %88, 131072
  %tobool100 = icmp ne i32 %and99, 0
  br i1 %tobool100, label %cond.true.101, label %cond.false.106

cond.true.101:                                    ; preds = %cond.false.96
  %89 = load %struct.op*, %struct.op** %first, align 8
  %90 = bitcast %struct.op* %89 to %struct.svop*
  %op_sv102 = getelementptr inbounds %struct.svop, %struct.svop* %90, i32 0, i32 8
  %91 = load %struct.sv*, %struct.sv** %op_sv102, align 8
  %sv_any103 = getelementptr inbounds %struct.sv, %struct.sv* %91, i32 0, i32 0
  %92 = load i8*, i8** %sv_any103, align 8
  %93 = bitcast i8* %92 to %struct.xpvnv*
  %xnv_nv = getelementptr inbounds %struct.xpvnv, %struct.xpvnv* %93, i32 0, i32 4
  %94 = load double, double* %xnv_nv, align 8
  %cmp104 = fcmp une double %94, 0.000000e+00
  %conv105 = zext i1 %cmp104 to i32
  br label %cond.end

cond.false.106:                                   ; preds = %cond.false.96
  %95 = load %struct.op*, %struct.op** %first, align 8
  %96 = bitcast %struct.op* %95 to %struct.svop*
  %op_sv107 = getelementptr inbounds %struct.svop, %struct.svop* %96, i32 0, i32 8
  %97 = load %struct.sv*, %struct.sv** %op_sv107, align 8
  %call108 = call signext i8 @Perl_sv_2bool(%struct.sv* %97)
  %conv109 = sext i8 %call108 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false.106, %cond.true.101
  %cond110 = phi i32 [ %conv105, %cond.true.101 ], [ %conv109, %cond.false.106 ]
  br label %cond.end.111

cond.end.111:                                     ; preds = %cond.end, %cond.true.91
  %cond112 = phi i32 [ %conv95, %cond.true.91 ], [ %cond110, %cond.end ]
  br label %cond.end.113

cond.end.113:                                     ; preds = %cond.end.111, %land.end.85
  %cond114 = phi i32 [ %cond, %land.end.85 ], [ %cond112, %cond.end.111 ]
  br label %cond.end.115

cond.end.115:                                     ; preds = %cond.end.113, %cond.true
  %cond116 = phi i32 [ 0, %cond.true ], [ %cond114, %cond.end.113 ]
  %cmp117 = icmp eq i32 %conv67, %cond116
  br i1 %cmp117, label %if.then.119, label %if.else.129

if.then.119:                                      ; preds = %cond.end.115
  %98 = load %struct.op*, %struct.op** %first, align 8
  call void @Perl_op_free(%struct.op* %98)
  %99 = load %struct.op**, %struct.op*** %firstp.addr, align 8
  store %struct.op* null, %struct.op** %99, align 8
  %100 = load %struct.op*, %struct.op** %other, align 8
  %op_type120 = getelementptr inbounds %struct.op, %struct.op* %100, i32 0, i32 4
  %101 = load i16, i16* %op_type120, align 2
  %conv121 = zext i16 %101 to i32
  %cmp122 = icmp eq i32 %conv121, 5
  br i1 %cmp122, label %if.then.124, label %if.end.128

if.then.124:                                      ; preds = %if.then.119
  %102 = load %struct.op*, %struct.op** %other, align 8
  %op_private125 = getelementptr inbounds %struct.op, %struct.op* %102, i32 0, i32 7
  %103 = load i8, i8* %op_private125, align 1
  %conv126 = zext i8 %103 to i32
  %or = or i32 %conv126, 4
  %conv127 = trunc i32 %or to i8
  store i8 %conv127, i8* %op_private125, align 1
  br label %if.end.128

if.end.128:                                       ; preds = %if.then.124, %if.then.119
  %104 = load %struct.op*, %struct.op** %other, align 8
  store %struct.op* %104, %struct.op** %retval
  br label %return

if.else.129:                                      ; preds = %cond.end.115
  %105 = load %struct.op*, %struct.op** %other, align 8
  call void @Perl_op_free(%struct.op* %105)
  %106 = load %struct.op**, %struct.op*** %otherp.addr, align 8
  store %struct.op* null, %struct.op** %106, align 8
  %107 = load %struct.op*, %struct.op** %first, align 8
  %op_type130 = getelementptr inbounds %struct.op, %struct.op* %107, i32 0, i32 4
  %108 = load i16, i16* %op_type130, align 2
  %conv131 = zext i16 %108 to i32
  %cmp132 = icmp eq i32 %conv131, 5
  br i1 %cmp132, label %if.then.134, label %if.end.139

if.then.134:                                      ; preds = %if.else.129
  %109 = load %struct.op*, %struct.op** %first, align 8
  %op_private135 = getelementptr inbounds %struct.op, %struct.op* %109, i32 0, i32 7
  %110 = load i8, i8* %op_private135, align 1
  %conv136 = zext i8 %110 to i32
  %or137 = or i32 %conv136, 4
  %conv138 = trunc i32 %or137 to i8
  store i8 %conv138, i8* %op_private135, align 1
  br label %if.end.139

if.end.139:                                       ; preds = %if.then.134, %if.else.129
  %111 = load %struct.op*, %struct.op** %first, align 8
  store %struct.op* %111, %struct.op** %retval
  br label %return

if.else.140:                                      ; preds = %if.end.24
  %112 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings141 = getelementptr inbounds %struct.cop, %struct.cop* %112, i32 0, i32 14
  %113 = load %struct.sv*, %struct.sv** %cop_warnings141, align 8
  %cmp142 = icmp ne %struct.sv* %113, null
  br i1 %cmp142, label %land.lhs.true.144, label %lor.lhs.false.160

land.lhs.true.144:                                ; preds = %if.else.140
  %114 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings145 = getelementptr inbounds %struct.cop, %struct.cop* %114, i32 0, i32 14
  %115 = load %struct.sv*, %struct.sv** %cop_warnings145, align 8
  %cmp146 = icmp ne %struct.sv* %115, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 2)
  br i1 %cmp146, label %land.lhs.true.148, label %lor.lhs.false.160

land.lhs.true.148:                                ; preds = %land.lhs.true.144
  %116 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings149 = getelementptr inbounds %struct.cop, %struct.cop* %116, i32 0, i32 14
  %117 = load %struct.sv*, %struct.sv** %cop_warnings149, align 8
  %cmp150 = icmp eq %struct.sv* %117, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 1)
  br i1 %cmp150, label %land.lhs.true.168, label %lor.lhs.false.152

lor.lhs.false.152:                                ; preds = %land.lhs.true.148
  %118 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings153 = getelementptr inbounds %struct.cop, %struct.cop* %118, i32 0, i32 14
  %119 = load %struct.sv*, %struct.sv** %cop_warnings153, align 8
  %sv_any154 = getelementptr inbounds %struct.sv, %struct.sv* %119, i32 0, i32 0
  %120 = load i8*, i8** %sv_any154, align 8
  %121 = bitcast i8* %120 to %struct.xpv*
  %xpv_pv155 = getelementptr inbounds %struct.xpv, %struct.xpv* %121, i32 0, i32 0
  %122 = load i8*, i8** %xpv_pv155, align 8
  %arrayidx156 = getelementptr inbounds i8, i8* %122, i64 3
  %123 = load i8, i8* %arrayidx156, align 1
  %conv157 = sext i8 %123 to i32
  %and158 = and i32 %conv157, 1
  %tobool159 = icmp ne i32 %and158, 0
  br i1 %tobool159, label %land.lhs.true.168, label %lor.lhs.false.160

lor.lhs.false.160:                                ; preds = %lor.lhs.false.152, %land.lhs.true.144, %if.else.140
  %124 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings161 = getelementptr inbounds %struct.cop, %struct.cop* %124, i32 0, i32 14
  %125 = load %struct.sv*, %struct.sv** %cop_warnings161, align 8
  %cmp162 = icmp eq %struct.sv* %125, null
  br i1 %cmp162, label %land.lhs.true.164, label %if.end.251

land.lhs.true.164:                                ; preds = %lor.lhs.false.160
  %126 = load i8, i8* @PL_dowarn, align 1
  %conv165 = zext i8 %126 to i32
  %and166 = and i32 %conv165, 1
  %tobool167 = icmp ne i32 %and166, 0
  br i1 %tobool167, label %land.lhs.true.168, label %if.end.251

land.lhs.true.168:                                ; preds = %land.lhs.true.164, %lor.lhs.false.152, %land.lhs.true.148
  %127 = load %struct.op*, %struct.op** %first, align 8
  %op_flags169 = getelementptr inbounds %struct.op, %struct.op* %127, i32 0, i32 6
  %128 = load i8, i8* %op_flags169, align 1
  %conv170 = zext i8 %128 to i32
  %and171 = and i32 %conv170, 4
  %tobool172 = icmp ne i32 %and171, 0
  br i1 %tobool172, label %if.then.173, label %if.end.251

if.then.173:                                      ; preds = %land.lhs.true.168
  %129 = load %struct.op*, %struct.op** %first, align 8
  %130 = bitcast %struct.op* %129 to %struct.unop*
  %op_first174 = getelementptr inbounds %struct.unop, %struct.unop* %130, i32 0, i32 8
  %131 = load %struct.op*, %struct.op** %op_first174, align 8
  store %struct.op* %131, %struct.op** %k1, align 8
  %132 = load %struct.op*, %struct.op** %k1, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %132, i32 0, i32 1
  %133 = load %struct.op*, %struct.op** %op_sibling, align 8
  store %struct.op* %133, %struct.op** %k2, align 8
  store i16 0, i16* %warnop, align 2
  %134 = load %struct.op*, %struct.op** %first, align 8
  %op_type175 = getelementptr inbounds %struct.op, %struct.op* %134, i32 0, i32 4
  %135 = load i16, i16* %op_type175, align 2
  %conv176 = zext i16 %135 to i32
  switch i32 %conv176, label %sw.epilog [
    i32 0, label %sw.bb
    i32 36, label %sw.bb.197
  ]

sw.bb:                                            ; preds = %if.then.173
  %136 = load %struct.op*, %struct.op** %k2, align 8
  %tobool177 = icmp ne %struct.op* %136, null
  br i1 %tobool177, label %land.lhs.true.178, label %if.end.196

land.lhs.true.178:                                ; preds = %sw.bb
  %137 = load %struct.op*, %struct.op** %k2, align 8
  %op_type179 = getelementptr inbounds %struct.op, %struct.op* %137, i32 0, i32 4
  %138 = load i16, i16* %op_type179, align 2
  %conv180 = zext i16 %138 to i32
  %cmp181 = icmp eq i32 %conv180, 26
  br i1 %cmp181, label %land.lhs.true.183, label %if.end.196

land.lhs.true.183:                                ; preds = %land.lhs.true.178
  %139 = load %struct.op*, %struct.op** %k2, align 8
  %op_flags184 = getelementptr inbounds %struct.op, %struct.op* %139, i32 0, i32 6
  %140 = load i8, i8* %op_flags184, align 1
  %conv185 = zext i8 %140 to i32
  %and186 = and i32 %conv185, 64
  %tobool187 = icmp ne i32 %and186, 0
  br i1 %tobool187, label %land.lhs.true.188, label %if.end.196

land.lhs.true.188:                                ; preds = %land.lhs.true.183
  %141 = load %struct.op*, %struct.op** %k1, align 8
  %op_flags189 = getelementptr inbounds %struct.op, %struct.op* %141, i32 0, i32 6
  %142 = load i8, i8* %op_flags189, align 1
  %conv190 = zext i8 %142 to i32
  %and191 = and i32 %conv190, 3
  %cmp192 = icmp eq i32 %and191, 2
  br i1 %cmp192, label %if.then.194, label %if.end.196

if.then.194:                                      ; preds = %land.lhs.true.188
  %143 = load %struct.op*, %struct.op** %k2, align 8
  %op_type195 = getelementptr inbounds %struct.op, %struct.op* %143, i32 0, i32 4
  %144 = load i16, i16* %op_type195, align 2
  store i16 %144, i16* %warnop, align 2
  br label %if.end.196

if.end.196:                                       ; preds = %if.then.194, %land.lhs.true.188, %land.lhs.true.183, %land.lhs.true.178, %sw.bb
  br label %sw.epilog

sw.bb.197:                                        ; preds = %if.then.173
  %145 = load %struct.op*, %struct.op** %k1, align 8
  %op_type198 = getelementptr inbounds %struct.op, %struct.op* %145, i32 0, i32 4
  %146 = load i16, i16* %op_type198, align 2
  %conv199 = zext i16 %146 to i32
  %cmp200 = icmp eq i32 %conv199, 276
  br i1 %cmp200, label %if.then.220, label %lor.lhs.false.202

lor.lhs.false.202:                                ; preds = %sw.bb.197
  %147 = load %struct.op*, %struct.op** %k1, align 8
  %op_type203 = getelementptr inbounds %struct.op, %struct.op* %147, i32 0, i32 4
  %148 = load i16, i16* %op_type203, align 2
  %conv204 = zext i16 %148 to i32
  %cmp205 = icmp eq i32 %conv204, 25
  br i1 %cmp205, label %if.then.220, label %lor.lhs.false.207

lor.lhs.false.207:                                ; preds = %lor.lhs.false.202
  %149 = load %struct.op*, %struct.op** %k1, align 8
  %op_type208 = getelementptr inbounds %struct.op, %struct.op* %149, i32 0, i32 4
  %150 = load i16, i16* %op_type208, align 2
  %conv209 = zext i16 %150 to i32
  %cmp210 = icmp eq i32 %conv209, 0
  br i1 %cmp210, label %land.lhs.true.212, label %lor.lhs.false.215

land.lhs.true.212:                                ; preds = %lor.lhs.false.207
  %151 = load %struct.op*, %struct.op** %k1, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %151, i32 0, i32 3
  %152 = load i64, i64* %op_targ, align 8
  %cmp213 = icmp eq i64 %152, 25
  br i1 %cmp213, label %if.then.220, label %lor.lhs.false.215

lor.lhs.false.215:                                ; preds = %land.lhs.true.212, %lor.lhs.false.207
  %153 = load %struct.op*, %struct.op** %k1, align 8
  %op_type216 = getelementptr inbounds %struct.op, %struct.op* %153, i32 0, i32 4
  %154 = load i16, i16* %op_type216, align 2
  %conv217 = zext i16 %154 to i32
  %cmp218 = icmp eq i32 %conv217, 129
  br i1 %cmp218, label %if.then.220, label %if.end.235

if.then.220:                                      ; preds = %lor.lhs.false.215, %land.lhs.true.212, %lor.lhs.false.202, %sw.bb.197
  %155 = load %struct.op*, %struct.op** %k1, align 8
  %op_type221 = getelementptr inbounds %struct.op, %struct.op* %155, i32 0, i32 4
  %156 = load i16, i16* %op_type221, align 2
  %conv222 = zext i16 %156 to i32
  %cmp223 = icmp eq i32 %conv222, 0
  br i1 %cmp223, label %cond.true.225, label %cond.false.229

cond.true.225:                                    ; preds = %if.then.220
  %157 = load %struct.op*, %struct.op** %k1, align 8
  %op_targ226 = getelementptr inbounds %struct.op, %struct.op* %157, i32 0, i32 3
  %158 = load i64, i64* %op_targ226, align 8
  %conv227 = trunc i64 %158 to i16
  %conv228 = zext i16 %conv227 to i32
  br label %cond.end.232

cond.false.229:                                   ; preds = %if.then.220
  %159 = load %struct.op*, %struct.op** %k1, align 8
  %op_type230 = getelementptr inbounds %struct.op, %struct.op* %159, i32 0, i32 4
  %160 = load i16, i16* %op_type230, align 2
  %conv231 = zext i16 %160 to i32
  br label %cond.end.232

cond.end.232:                                     ; preds = %cond.false.229, %cond.true.225
  %cond233 = phi i32 [ %conv228, %cond.true.225 ], [ %conv231, %cond.false.229 ]
  %conv234 = trunc i32 %cond233 to i16
  store i16 %conv234, i16* %warnop, align 2
  br label %if.end.235

if.end.235:                                       ; preds = %cond.end.232, %lor.lhs.false.215
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.then.173, %if.end.235, %if.end.196
  %161 = load i16, i16* %warnop, align 2
  %tobool236 = icmp ne i16 %161, 0
  br i1 %tobool236, label %if.then.237, label %if.end.250

if.then.237:                                      ; preds = %sw.epilog
  %162 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_line = getelementptr inbounds %struct.cop, %struct.cop* %162, i32 0, i32 13
  %163 = load i32, i32* %cop_line, align 4
  store i32 %163, i32* %oldline, align 4
  %164 = load i32, i32* @PL_copline, align 4
  %165 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_line238 = getelementptr inbounds %struct.cop, %struct.cop* %165, i32 0, i32 13
  store i32 %164, i32* %cop_line238, align 4
  %166 = load i16, i16* %warnop, align 2
  %idxprom = zext i16 %166 to i64
  %arrayidx239 = getelementptr inbounds [0 x i8*], [0 x i8*]* @PL_op_desc, i32 0, i64 %idxprom
  %167 = load i8*, i8** %arrayidx239, align 8
  %168 = load i16, i16* %warnop, align 2
  %conv240 = zext i16 %168 to i32
  %cmp241 = icmp eq i32 %conv240, 26
  br i1 %cmp241, label %lor.end.247, label %lor.rhs.243

lor.rhs.243:                                      ; preds = %if.then.237
  %169 = load i16, i16* %warnop, align 2
  %conv244 = zext i16 %169 to i32
  %cmp245 = icmp eq i32 %conv244, 25
  br label %lor.end.247

lor.end.247:                                      ; preds = %lor.rhs.243, %if.then.237
  %170 = phi i1 [ true, %if.then.237 ], [ %cmp245, %lor.rhs.243 ]
  %cond248 = select i1 %170, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.146, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.147, i32 0, i32 0)
  call void (i32, i8*, ...) @Perl_warner(i32 12, i8* getelementptr inbounds ([46 x i8], [46 x i8]* @.str.145, i32 0, i32 0), i8* %167, i8* %cond248)
  %171 = load i32, i32* %oldline, align 4
  %172 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_line249 = getelementptr inbounds %struct.cop, %struct.cop* %172, i32 0, i32 13
  store i32 %171, i32* %cop_line249, align 4
  br label %if.end.250

if.end.250:                                       ; preds = %lor.end.247, %sw.epilog
  br label %if.end.251

if.end.251:                                       ; preds = %if.end.250, %land.lhs.true.168, %land.lhs.true.164, %lor.lhs.false.160
  br label %if.end.252

if.end.252:                                       ; preds = %if.end.251
  %173 = load %struct.op*, %struct.op** %other, align 8
  %tobool253 = icmp ne %struct.op* %173, null
  br i1 %tobool253, label %if.end.255, label %if.then.254

if.then.254:                                      ; preds = %if.end.252
  %174 = load %struct.op*, %struct.op** %first, align 8
  store %struct.op* %174, %struct.op** %retval
  br label %return

if.end.255:                                       ; preds = %if.end.252
  %175 = load i32, i32* %type.addr, align 4
  %cmp256 = icmp eq i32 %175, 163
  br i1 %cmp256, label %if.then.261, label %lor.lhs.false.258

lor.lhs.false.258:                                ; preds = %if.end.255
  %176 = load i32, i32* %type.addr, align 4
  %cmp259 = icmp eq i32 %176, 164
  br i1 %cmp259, label %if.then.261, label %if.end.266

if.then.261:                                      ; preds = %lor.lhs.false.258, %if.end.255
  %177 = load %struct.op*, %struct.op** %other, align 8
  %op_private262 = getelementptr inbounds %struct.op, %struct.op* %177, i32 0, i32 7
  %178 = load i8, i8* %op_private262, align 1
  %conv263 = zext i8 %178 to i32
  %or264 = or i32 %conv263, 64
  %conv265 = trunc i32 %or264 to i8
  store i8 %conv265, i8* %op_private262, align 1
  br label %if.end.266

if.end.266:                                       ; preds = %if.then.261, %lor.lhs.false.258
  %call267 = call i8* @Perl_safesysmalloc(i64 56)
  %179 = bitcast i8* %call267 to %struct.logop*
  store %struct.logop* %179, %struct.logop** %logop, align 8
  %180 = load %struct.logop*, %struct.logop** %logop, align 8
  %181 = bitcast %struct.logop* %180 to i8*
  call void @llvm.memset.p0i8.i64(i8* %181, i8 0, i64 56, i32 1, i1 false)
  %182 = load i32, i32* %type.addr, align 4
  %conv268 = trunc i32 %182 to i16
  %183 = load %struct.logop*, %struct.logop** %logop, align 8
  %op_type269 = getelementptr inbounds %struct.logop, %struct.logop* %183, i32 0, i32 4
  store i16 %conv268, i16* %op_type269, align 2
  %184 = load i32, i32* %type.addr, align 4
  %idxprom270 = sext i32 %184 to i64
  %arrayidx271 = getelementptr inbounds [0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 %idxprom270
  %185 = load %struct.op* ()*, %struct.op* ()** %arrayidx271, align 8
  %186 = load %struct.logop*, %struct.logop** %logop, align 8
  %op_ppaddr = getelementptr inbounds %struct.logop, %struct.logop* %186, i32 0, i32 2
  store %struct.op* ()* %185, %struct.op* ()** %op_ppaddr, align 8
  %187 = load %struct.op*, %struct.op** %first, align 8
  %188 = load %struct.logop*, %struct.logop** %logop, align 8
  %op_first272 = getelementptr inbounds %struct.logop, %struct.logop* %188, i32 0, i32 8
  store %struct.op* %187, %struct.op** %op_first272, align 8
  %189 = load i32, i32* %flags.addr, align 4
  %or273 = or i32 %189, 4
  %conv274 = trunc i32 %or273 to i8
  %190 = load %struct.logop*, %struct.logop** %logop, align 8
  %op_flags275 = getelementptr inbounds %struct.logop, %struct.logop* %190, i32 0, i32 6
  store i8 %conv274, i8* %op_flags275, align 1
  %191 = load %struct.op*, %struct.op** %other, align 8
  %op_next276 = getelementptr inbounds %struct.op, %struct.op* %191, i32 0, i32 0
  %192 = load %struct.op*, %struct.op** %op_next276, align 8
  %tobool277 = icmp ne %struct.op* %192, null
  br i1 %tobool277, label %cond.true.278, label %cond.false.280

cond.true.278:                                    ; preds = %if.end.266
  %193 = load %struct.op*, %struct.op** %other, align 8
  %op_next279 = getelementptr inbounds %struct.op, %struct.op* %193, i32 0, i32 0
  %194 = load %struct.op*, %struct.op** %op_next279, align 8
  br label %cond.end.282

cond.false.280:                                   ; preds = %if.end.266
  %195 = load %struct.op*, %struct.op** %other, align 8
  %call281 = call %struct.op* @Perl_linklist(%struct.op* %195)
  br label %cond.end.282

cond.end.282:                                     ; preds = %cond.false.280, %cond.true.278
  %cond283 = phi %struct.op* [ %194, %cond.true.278 ], [ %call281, %cond.false.280 ]
  %196 = load %struct.logop*, %struct.logop** %logop, align 8
  %op_other = getelementptr inbounds %struct.logop, %struct.logop* %196, i32 0, i32 9
  store %struct.op* %cond283, %struct.op** %op_other, align 8
  %197 = load i32, i32* %flags.addr, align 4
  %shr = ashr i32 %197, 8
  %or284 = or i32 1, %shr
  %conv285 = trunc i32 %or284 to i8
  %198 = load %struct.logop*, %struct.logop** %logop, align 8
  %op_private286 = getelementptr inbounds %struct.logop, %struct.logop* %198, i32 0, i32 7
  store i8 %conv285, i8* %op_private286, align 1
  %199 = load %struct.op*, %struct.op** %first, align 8
  %op_next287 = getelementptr inbounds %struct.op, %struct.op* %199, i32 0, i32 0
  %200 = load %struct.op*, %struct.op** %op_next287, align 8
  %tobool288 = icmp ne %struct.op* %200, null
  br i1 %tobool288, label %cond.true.289, label %cond.false.291

cond.true.289:                                    ; preds = %cond.end.282
  %201 = load %struct.op*, %struct.op** %first, align 8
  %op_next290 = getelementptr inbounds %struct.op, %struct.op* %201, i32 0, i32 0
  %202 = load %struct.op*, %struct.op** %op_next290, align 8
  br label %cond.end.293

cond.false.291:                                   ; preds = %cond.end.282
  %203 = load %struct.op*, %struct.op** %first, align 8
  %call292 = call %struct.op* @Perl_linklist(%struct.op* %203)
  br label %cond.end.293

cond.end.293:                                     ; preds = %cond.false.291, %cond.true.289
  %cond294 = phi %struct.op* [ %202, %cond.true.289 ], [ %call292, %cond.false.291 ]
  %204 = load %struct.logop*, %struct.logop** %logop, align 8
  %op_next295 = getelementptr inbounds %struct.logop, %struct.logop* %204, i32 0, i32 0
  store %struct.op* %cond294, %struct.op** %op_next295, align 8
  %205 = load %struct.logop*, %struct.logop** %logop, align 8
  %206 = bitcast %struct.logop* %205 to %struct.op*
  %207 = load %struct.op*, %struct.op** %first, align 8
  %op_next296 = getelementptr inbounds %struct.op, %struct.op* %207, i32 0, i32 0
  store %struct.op* %206, %struct.op** %op_next296, align 8
  %208 = load %struct.op*, %struct.op** %other, align 8
  %209 = load %struct.op*, %struct.op** %first, align 8
  %op_sibling297 = getelementptr inbounds %struct.op, %struct.op* %209, i32 0, i32 1
  store %struct.op* %208, %struct.op** %op_sibling297, align 8
  %210 = load i8*, i8** @PL_op_mask, align 8
  %tobool298 = icmp ne i8* %210, null
  br i1 %tobool298, label %land.lhs.true.299, label %cond.false.307

land.lhs.true.299:                                ; preds = %cond.end.293
  %211 = load i32, i32* %type.addr, align 4
  %idxprom300 = sext i32 %211 to i64
  %212 = load i8*, i8** @PL_op_mask, align 8
  %arrayidx301 = getelementptr inbounds i8, i8* %212, i64 %idxprom300
  %213 = load i8, i8* %arrayidx301, align 1
  %conv302 = sext i8 %213 to i32
  %tobool303 = icmp ne i32 %conv302, 0
  br i1 %tobool303, label %cond.true.304, label %cond.false.307

cond.true.304:                                    ; preds = %land.lhs.true.299
  %214 = load %struct.logop*, %struct.logop** %logop, align 8
  %215 = bitcast %struct.logop* %214 to %struct.op*
  call void @Perl_op_free(%struct.op* %215)
  %216 = load i32, i32* %type.addr, align 4
  %idxprom305 = sext i32 %216 to i64
  %arrayidx306 = getelementptr inbounds [0 x i8*], [0 x i8*]* @PL_op_desc, i32 0, i64 %idxprom305
  %217 = load i8*, i8** %arrayidx306, align 8
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.33, i32 0, i32 0), i8* %217)
  br label %cond.end.311

cond.false.307:                                   ; preds = %land.lhs.true.299, %cond.end.293
  %218 = load i32, i32* %type.addr, align 4
  %idxprom308 = sext i32 %218 to i64
  %arrayidx309 = getelementptr inbounds [0 x %struct.op* (%struct.op*)*], [0 x %struct.op* (%struct.op*)*]* @PL_check, i32 0, i64 %idxprom308
  %219 = load %struct.op* (%struct.op*)*, %struct.op* (%struct.op*)** %arrayidx309, align 8
  %220 = load %struct.logop*, %struct.logop** %logop, align 8
  %221 = bitcast %struct.logop* %220 to %struct.op*
  %call310 = call %struct.op* %219(%struct.op* %221)
  br label %cond.end.311

cond.end.311:                                     ; preds = %cond.false.307, %cond.true.304
  %cond312 = phi %struct.op* [ null, %cond.true.304 ], [ %call310, %cond.false.307 ]
  %222 = load %struct.logop*, %struct.logop** %logop, align 8
  %223 = bitcast %struct.logop* %222 to %struct.op*
  %call313 = call %struct.op* @Perl_newUNOP(i32 0, i32 0, %struct.op* %223)
  store %struct.op* %call313, %struct.op** %o, align 8
  %224 = load %struct.op*, %struct.op** %o, align 8
  %225 = load %struct.op*, %struct.op** %other, align 8
  %op_next314 = getelementptr inbounds %struct.op, %struct.op* %225, i32 0, i32 0
  store %struct.op* %224, %struct.op** %op_next314, align 8
  %226 = load %struct.op*, %struct.op** %o, align 8
  store %struct.op* %226, %struct.op** %retval
  br label %return

return:                                           ; preds = %cond.end.311, %if.then.254, %if.end.139, %if.end.128, %if.then
  %227 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %227
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newCONDOP(i32 %flags, %struct.op* %first, %struct.op* %trueop, %struct.op* %falseop) #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %flags.addr = alloca i32, align 4
  %first.addr = alloca %struct.op*, align 8
  %trueop.addr = alloca %struct.op*, align 8
  %falseop.addr = alloca %struct.op*, align 8
  %logop = alloca %struct.logop*, align 8
  %start = alloca %struct.op*, align 8
  %o = alloca %struct.op*, align 8
  store i32 %flags, i32* %flags.addr, align 4
  store %struct.op* %first, %struct.op** %first.addr, align 8
  store %struct.op* %trueop, %struct.op** %trueop.addr, align 8
  store %struct.op* %falseop, %struct.op** %falseop.addr, align 8
  %0 = load %struct.op*, %struct.op** %falseop.addr, align 8
  %tobool = icmp ne %struct.op* %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load %struct.op*, %struct.op** %first.addr, align 8
  %2 = load %struct.op*, %struct.op** %trueop.addr, align 8
  %call = call %struct.op* @Perl_newLOGOP(i32 159, i32 0, %struct.op* %1, %struct.op* %2)
  store %struct.op* %call, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %entry
  %3 = load %struct.op*, %struct.op** %trueop.addr, align 8
  %tobool1 = icmp ne %struct.op* %3, null
  br i1 %tobool1, label %if.end.4, label %if.then.2

if.then.2:                                        ; preds = %if.end
  %4 = load %struct.op*, %struct.op** %first.addr, align 8
  %5 = load %struct.op*, %struct.op** %falseop.addr, align 8
  %call3 = call %struct.op* @Perl_newLOGOP(i32 160, i32 0, %struct.op* %4, %struct.op* %5)
  store %struct.op* %call3, %struct.op** %retval
  br label %return

if.end.4:                                         ; preds = %if.end
  %6 = load %struct.op*, %struct.op** %first.addr, align 8
  %call5 = call %struct.op* @S_scalarboolean(%struct.op* %6)
  %7 = load %struct.op*, %struct.op** %first.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %7, i32 0, i32 4
  %8 = load i16, i16* %op_type, align 2
  %conv = zext i16 %8 to i32
  %cmp = icmp eq i32 %conv, 5
  br i1 %cmp, label %if.then.7, label %if.end.60

if.then.7:                                        ; preds = %if.end.4
  %9 = load %struct.op*, %struct.op** %first.addr, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %9, i32 0, i32 7
  %10 = load i8, i8* %op_private, align 1
  %conv8 = zext i8 %10 to i32
  %and = and i32 %conv8, 64
  %tobool9 = icmp ne i32 %and, 0
  br i1 %tobool9, label %land.lhs.true, label %if.end.15

land.lhs.true:                                    ; preds = %if.then.7
  %11 = load %struct.op*, %struct.op** %first.addr, align 8
  %op_private10 = getelementptr inbounds %struct.op, %struct.op* %11, i32 0, i32 7
  %12 = load i8, i8* %op_private10, align 1
  %conv11 = zext i8 %12 to i32
  %and12 = and i32 %conv11, 8
  %tobool13 = icmp ne i32 %and12, 0
  br i1 %tobool13, label %if.then.14, label %if.end.15

if.then.14:                                       ; preds = %land.lhs.true
  %13 = load %struct.op*, %struct.op** %first.addr, align 8
  call void @S_no_bareword_allowed(%struct.op* %13)
  br label %if.end.15

if.end.15:                                        ; preds = %if.then.14, %land.lhs.true, %if.then.7
  %14 = load %struct.op*, %struct.op** %first.addr, align 8
  %15 = bitcast %struct.op* %14 to %struct.svop*
  %op_sv = getelementptr inbounds %struct.svop, %struct.svop* %15, i32 0, i32 8
  %16 = load %struct.sv*, %struct.sv** %op_sv, align 8
  %tobool16 = icmp ne %struct.sv* %16, null
  br i1 %tobool16, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end.15
  br i1 false, label %if.then.59, label %if.else

cond.false:                                       ; preds = %if.end.15
  %17 = load %struct.op*, %struct.op** %first.addr, align 8
  %18 = bitcast %struct.op* %17 to %struct.svop*
  %op_sv17 = getelementptr inbounds %struct.svop, %struct.svop* %18, i32 0, i32 8
  %19 = load %struct.sv*, %struct.sv** %op_sv17, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %19, i32 0, i32 2
  %20 = load i32, i32* %sv_flags, align 4
  %and18 = and i32 %20, 262144
  %tobool19 = icmp ne i32 %and18, 0
  br i1 %tobool19, label %cond.true.20, label %cond.false.34

cond.true.20:                                     ; preds = %cond.false
  %21 = load %struct.op*, %struct.op** %first.addr, align 8
  %22 = bitcast %struct.op* %21 to %struct.svop*
  %op_sv21 = getelementptr inbounds %struct.svop, %struct.svop* %22, i32 0, i32 8
  %23 = load %struct.sv*, %struct.sv** %op_sv21, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %23, i32 0, i32 0
  %24 = load i8*, i8** %sv_any, align 8
  %25 = bitcast i8* %24 to %struct.xpv*
  store %struct.xpv* %25, %struct.xpv** @PL_Xpv, align 8
  %tobool22 = icmp ne %struct.xpv* %25, null
  br i1 %tobool22, label %land.lhs.true.23, label %cond.false.33

land.lhs.true.23:                                 ; preds = %cond.true.20
  %26 = load %struct.xpv*, %struct.xpv** @PL_Xpv, align 8
  %xpv_cur = getelementptr inbounds %struct.xpv, %struct.xpv* %26, i32 0, i32 1
  %27 = load i64, i64* %xpv_cur, align 8
  %cmp24 = icmp ugt i64 %27, 1
  br i1 %cmp24, label %cond.true.32, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true.23
  %28 = load %struct.xpv*, %struct.xpv** @PL_Xpv, align 8
  %xpv_cur26 = getelementptr inbounds %struct.xpv, %struct.xpv* %28, i32 0, i32 1
  %29 = load i64, i64* %xpv_cur26, align 8
  %tobool27 = icmp ne i64 %29, 0
  br i1 %tobool27, label %land.lhs.true.28, label %cond.false.33

land.lhs.true.28:                                 ; preds = %lor.lhs.false
  %30 = load %struct.xpv*, %struct.xpv** @PL_Xpv, align 8
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %30, i32 0, i32 0
  %31 = load i8*, i8** %xpv_pv, align 8
  %32 = load i8, i8* %31, align 1
  %conv29 = sext i8 %32 to i32
  %cmp30 = icmp ne i32 %conv29, 48
  br i1 %cmp30, label %cond.true.32, label %cond.false.33

cond.true.32:                                     ; preds = %land.lhs.true.28, %land.lhs.true.23
  br i1 true, label %if.then.59, label %if.else

cond.false.33:                                    ; preds = %land.lhs.true.28, %lor.lhs.false, %cond.true.20
  br i1 false, label %if.then.59, label %if.else

cond.false.34:                                    ; preds = %cond.false
  %33 = load %struct.op*, %struct.op** %first.addr, align 8
  %34 = bitcast %struct.op* %33 to %struct.svop*
  %op_sv35 = getelementptr inbounds %struct.svop, %struct.svop* %34, i32 0, i32 8
  %35 = load %struct.sv*, %struct.sv** %op_sv35, align 8
  %sv_flags36 = getelementptr inbounds %struct.sv, %struct.sv* %35, i32 0, i32 2
  %36 = load i32, i32* %sv_flags36, align 4
  %and37 = and i32 %36, 65536
  %tobool38 = icmp ne i32 %and37, 0
  br i1 %tobool38, label %cond.true.39, label %cond.false.44

cond.true.39:                                     ; preds = %cond.false.34
  %37 = load %struct.op*, %struct.op** %first.addr, align 8
  %38 = bitcast %struct.op* %37 to %struct.svop*
  %op_sv40 = getelementptr inbounds %struct.svop, %struct.svop* %38, i32 0, i32 8
  %39 = load %struct.sv*, %struct.sv** %op_sv40, align 8
  %sv_any41 = getelementptr inbounds %struct.sv, %struct.sv* %39, i32 0, i32 0
  %40 = load i8*, i8** %sv_any41, align 8
  %41 = bitcast i8* %40 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %41, i32 0, i32 3
  %42 = load i64, i64* %xiv_iv, align 8
  %cmp42 = icmp ne i64 %42, 0
  br i1 %cmp42, label %if.then.59, label %if.else

cond.false.44:                                    ; preds = %cond.false.34
  %43 = load %struct.op*, %struct.op** %first.addr, align 8
  %44 = bitcast %struct.op* %43 to %struct.svop*
  %op_sv45 = getelementptr inbounds %struct.svop, %struct.svop* %44, i32 0, i32 8
  %45 = load %struct.sv*, %struct.sv** %op_sv45, align 8
  %sv_flags46 = getelementptr inbounds %struct.sv, %struct.sv* %45, i32 0, i32 2
  %46 = load i32, i32* %sv_flags46, align 4
  %and47 = and i32 %46, 131072
  %tobool48 = icmp ne i32 %and47, 0
  br i1 %tobool48, label %cond.true.49, label %cond.false.54

cond.true.49:                                     ; preds = %cond.false.44
  %47 = load %struct.op*, %struct.op** %first.addr, align 8
  %48 = bitcast %struct.op* %47 to %struct.svop*
  %op_sv50 = getelementptr inbounds %struct.svop, %struct.svop* %48, i32 0, i32 8
  %49 = load %struct.sv*, %struct.sv** %op_sv50, align 8
  %sv_any51 = getelementptr inbounds %struct.sv, %struct.sv* %49, i32 0, i32 0
  %50 = load i8*, i8** %sv_any51, align 8
  %51 = bitcast i8* %50 to %struct.xpvnv*
  %xnv_nv = getelementptr inbounds %struct.xpvnv, %struct.xpvnv* %51, i32 0, i32 4
  %52 = load double, double* %xnv_nv, align 8
  %cmp52 = fcmp une double %52, 0.000000e+00
  br i1 %cmp52, label %if.then.59, label %if.else

cond.false.54:                                    ; preds = %cond.false.44
  %53 = load %struct.op*, %struct.op** %first.addr, align 8
  %54 = bitcast %struct.op* %53 to %struct.svop*
  %op_sv55 = getelementptr inbounds %struct.svop, %struct.svop* %54, i32 0, i32 8
  %55 = load %struct.sv*, %struct.sv** %op_sv55, align 8
  %call56 = call signext i8 @Perl_sv_2bool(%struct.sv* %55)
  %conv57 = sext i8 %call56 to i32
  %tobool58 = icmp ne i32 %conv57, 0
  br i1 %tobool58, label %if.then.59, label %if.else

if.then.59:                                       ; preds = %cond.false.54, %cond.true.49, %cond.true.39, %cond.false.33, %cond.true.32, %cond.true
  %56 = load %struct.op*, %struct.op** %first.addr, align 8
  call void @Perl_op_free(%struct.op* %56)
  %57 = load %struct.op*, %struct.op** %falseop.addr, align 8
  call void @Perl_op_free(%struct.op* %57)
  %58 = load %struct.op*, %struct.op** %trueop.addr, align 8
  store %struct.op* %58, %struct.op** %retval
  br label %return

if.else:                                          ; preds = %cond.false.54, %cond.true.49, %cond.true.39, %cond.false.33, %cond.true.32, %cond.true
  %59 = load %struct.op*, %struct.op** %first.addr, align 8
  call void @Perl_op_free(%struct.op* %59)
  %60 = load %struct.op*, %struct.op** %trueop.addr, align 8
  call void @Perl_op_free(%struct.op* %60)
  %61 = load %struct.op*, %struct.op** %falseop.addr, align 8
  store %struct.op* %61, %struct.op** %retval
  br label %return

if.end.60:                                        ; preds = %if.end.4
  %call61 = call i8* @Perl_safesysmalloc(i64 56)
  %62 = bitcast i8* %call61 to %struct.logop*
  store %struct.logop* %62, %struct.logop** %logop, align 8
  %63 = load %struct.logop*, %struct.logop** %logop, align 8
  %64 = bitcast %struct.logop* %63 to i8*
  call void @llvm.memset.p0i8.i64(i8* %64, i8 0, i64 56, i32 1, i1 false)
  %65 = load %struct.logop*, %struct.logop** %logop, align 8
  %op_type62 = getelementptr inbounds %struct.logop, %struct.logop* %65, i32 0, i32 4
  store i16 162, i16* %op_type62, align 2
  %66 = load %struct.op* ()*, %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 162), align 8
  %67 = load %struct.logop*, %struct.logop** %logop, align 8
  %op_ppaddr = getelementptr inbounds %struct.logop, %struct.logop* %67, i32 0, i32 2
  store %struct.op* ()* %66, %struct.op* ()** %op_ppaddr, align 8
  %68 = load %struct.op*, %struct.op** %first.addr, align 8
  %69 = load %struct.logop*, %struct.logop** %logop, align 8
  %op_first = getelementptr inbounds %struct.logop, %struct.logop* %69, i32 0, i32 8
  store %struct.op* %68, %struct.op** %op_first, align 8
  %70 = load i32, i32* %flags.addr, align 4
  %or = or i32 %70, 4
  %conv63 = trunc i32 %or to i8
  %71 = load %struct.logop*, %struct.logop** %logop, align 8
  %op_flags = getelementptr inbounds %struct.logop, %struct.logop* %71, i32 0, i32 6
  store i8 %conv63, i8* %op_flags, align 1
  %72 = load i32, i32* %flags.addr, align 4
  %shr = ashr i32 %72, 8
  %or64 = or i32 1, %shr
  %conv65 = trunc i32 %or64 to i8
  %73 = load %struct.logop*, %struct.logop** %logop, align 8
  %op_private66 = getelementptr inbounds %struct.logop, %struct.logop* %73, i32 0, i32 7
  store i8 %conv65, i8* %op_private66, align 1
  %74 = load %struct.op*, %struct.op** %trueop.addr, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %74, i32 0, i32 0
  %75 = load %struct.op*, %struct.op** %op_next, align 8
  %tobool67 = icmp ne %struct.op* %75, null
  br i1 %tobool67, label %cond.true.68, label %cond.false.70

cond.true.68:                                     ; preds = %if.end.60
  %76 = load %struct.op*, %struct.op** %trueop.addr, align 8
  %op_next69 = getelementptr inbounds %struct.op, %struct.op* %76, i32 0, i32 0
  %77 = load %struct.op*, %struct.op** %op_next69, align 8
  br label %cond.end

cond.false.70:                                    ; preds = %if.end.60
  %78 = load %struct.op*, %struct.op** %trueop.addr, align 8
  %call71 = call %struct.op* @Perl_linklist(%struct.op* %78)
  br label %cond.end

cond.end:                                         ; preds = %cond.false.70, %cond.true.68
  %cond = phi %struct.op* [ %77, %cond.true.68 ], [ %call71, %cond.false.70 ]
  %79 = load %struct.logop*, %struct.logop** %logop, align 8
  %op_other = getelementptr inbounds %struct.logop, %struct.logop* %79, i32 0, i32 9
  store %struct.op* %cond, %struct.op** %op_other, align 8
  %80 = load %struct.op*, %struct.op** %falseop.addr, align 8
  %op_next72 = getelementptr inbounds %struct.op, %struct.op* %80, i32 0, i32 0
  %81 = load %struct.op*, %struct.op** %op_next72, align 8
  %tobool73 = icmp ne %struct.op* %81, null
  br i1 %tobool73, label %cond.true.74, label %cond.false.76

cond.true.74:                                     ; preds = %cond.end
  %82 = load %struct.op*, %struct.op** %falseop.addr, align 8
  %op_next75 = getelementptr inbounds %struct.op, %struct.op* %82, i32 0, i32 0
  %83 = load %struct.op*, %struct.op** %op_next75, align 8
  br label %cond.end.78

cond.false.76:                                    ; preds = %cond.end
  %84 = load %struct.op*, %struct.op** %falseop.addr, align 8
  %call77 = call %struct.op* @Perl_linklist(%struct.op* %84)
  br label %cond.end.78

cond.end.78:                                      ; preds = %cond.false.76, %cond.true.74
  %cond79 = phi %struct.op* [ %83, %cond.true.74 ], [ %call77, %cond.false.76 ]
  %85 = load %struct.logop*, %struct.logop** %logop, align 8
  %op_next80 = getelementptr inbounds %struct.logop, %struct.logop* %85, i32 0, i32 0
  store %struct.op* %cond79, %struct.op** %op_next80, align 8
  %86 = load i8*, i8** @PL_op_mask, align 8
  %tobool81 = icmp ne i8* %86, null
  br i1 %tobool81, label %land.lhs.true.82, label %cond.false.86

land.lhs.true.82:                                 ; preds = %cond.end.78
  %87 = load i8*, i8** @PL_op_mask, align 8
  %arrayidx = getelementptr inbounds i8, i8* %87, i64 162
  %88 = load i8, i8* %arrayidx, align 1
  %conv83 = sext i8 %88 to i32
  %tobool84 = icmp ne i32 %conv83, 0
  br i1 %tobool84, label %cond.true.85, label %cond.false.86

cond.true.85:                                     ; preds = %land.lhs.true.82
  %89 = load %struct.logop*, %struct.logop** %logop, align 8
  %90 = bitcast %struct.logop* %89 to %struct.op*
  call void @Perl_op_free(%struct.op* %90)
  %91 = load i8*, i8** getelementptr inbounds ([0 x i8*], [0 x i8*]* @PL_op_desc, i32 0, i64 162), align 8
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.33, i32 0, i32 0), i8* %91)
  br label %cond.end.88

cond.false.86:                                    ; preds = %land.lhs.true.82, %cond.end.78
  %92 = load %struct.op* (%struct.op*)*, %struct.op* (%struct.op*)** getelementptr inbounds ([0 x %struct.op* (%struct.op*)*], [0 x %struct.op* (%struct.op*)*]* @PL_check, i32 0, i64 162), align 8
  %93 = load %struct.logop*, %struct.logop** %logop, align 8
  %94 = bitcast %struct.logop* %93 to %struct.op*
  %call87 = call %struct.op* %92(%struct.op* %94)
  br label %cond.end.88

cond.end.88:                                      ; preds = %cond.false.86, %cond.true.85
  %cond89 = phi %struct.op* [ null, %cond.true.85 ], [ %call87, %cond.false.86 ]
  %95 = load %struct.op*, %struct.op** %first.addr, align 8
  %op_next90 = getelementptr inbounds %struct.op, %struct.op* %95, i32 0, i32 0
  %96 = load %struct.op*, %struct.op** %op_next90, align 8
  %tobool91 = icmp ne %struct.op* %96, null
  br i1 %tobool91, label %cond.true.92, label %cond.false.94

cond.true.92:                                     ; preds = %cond.end.88
  %97 = load %struct.op*, %struct.op** %first.addr, align 8
  %op_next93 = getelementptr inbounds %struct.op, %struct.op* %97, i32 0, i32 0
  %98 = load %struct.op*, %struct.op** %op_next93, align 8
  br label %cond.end.96

cond.false.94:                                    ; preds = %cond.end.88
  %99 = load %struct.op*, %struct.op** %first.addr, align 8
  %call95 = call %struct.op* @Perl_linklist(%struct.op* %99)
  br label %cond.end.96

cond.end.96:                                      ; preds = %cond.false.94, %cond.true.92
  %cond97 = phi %struct.op* [ %98, %cond.true.92 ], [ %call95, %cond.false.94 ]
  store %struct.op* %cond97, %struct.op** %start, align 8
  %100 = load %struct.logop*, %struct.logop** %logop, align 8
  %101 = bitcast %struct.logop* %100 to %struct.op*
  %102 = load %struct.op*, %struct.op** %first.addr, align 8
  %op_next98 = getelementptr inbounds %struct.op, %struct.op* %102, i32 0, i32 0
  store %struct.op* %101, %struct.op** %op_next98, align 8
  %103 = load %struct.op*, %struct.op** %trueop.addr, align 8
  %104 = load %struct.op*, %struct.op** %first.addr, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %104, i32 0, i32 1
  store %struct.op* %103, %struct.op** %op_sibling, align 8
  %105 = load %struct.op*, %struct.op** %falseop.addr, align 8
  %106 = load %struct.op*, %struct.op** %trueop.addr, align 8
  %op_sibling99 = getelementptr inbounds %struct.op, %struct.op* %106, i32 0, i32 1
  store %struct.op* %105, %struct.op** %op_sibling99, align 8
  %107 = load %struct.logop*, %struct.logop** %logop, align 8
  %108 = bitcast %struct.logop* %107 to %struct.op*
  %call100 = call %struct.op* @Perl_newUNOP(i32 0, i32 0, %struct.op* %108)
  store %struct.op* %call100, %struct.op** %o, align 8
  %109 = load %struct.op*, %struct.op** %o, align 8
  %110 = load %struct.op*, %struct.op** %falseop.addr, align 8
  %op_next101 = getelementptr inbounds %struct.op, %struct.op* %110, i32 0, i32 0
  store %struct.op* %109, %struct.op** %op_next101, align 8
  %111 = load %struct.op*, %struct.op** %trueop.addr, align 8
  %op_next102 = getelementptr inbounds %struct.op, %struct.op* %111, i32 0, i32 0
  store %struct.op* %109, %struct.op** %op_next102, align 8
  %112 = load %struct.op*, %struct.op** %start, align 8
  %113 = load %struct.op*, %struct.op** %o, align 8
  %op_next103 = getelementptr inbounds %struct.op, %struct.op* %113, i32 0, i32 0
  store %struct.op* %112, %struct.op** %op_next103, align 8
  %114 = load %struct.op*, %struct.op** %o, align 8
  store %struct.op* %114, %struct.op** %retval
  br label %return

return:                                           ; preds = %cond.end.96, %if.else, %if.then.59, %if.then.2, %if.then
  %115 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %115
}

; Function Attrs: nounwind uwtable
define internal %struct.op* @S_scalarboolean(%struct.op* %o) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  %oldline = alloca i32, align 4
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %0, i32 0, i32 4
  %1 = load i16, i16* %op_type, align 2
  %conv = zext i16 %1 to i32
  %cmp = icmp eq i32 %conv, 36
  br i1 %cmp, label %land.lhs.true, label %if.end.33

land.lhs.true:                                    ; preds = %entry
  %2 = load %struct.op*, %struct.op** %o.addr, align 8
  %3 = bitcast %struct.op* %2 to %struct.binop*
  %op_first = getelementptr inbounds %struct.binop, %struct.binop* %3, i32 0, i32 8
  %4 = load %struct.op*, %struct.op** %op_first, align 8
  %op_type2 = getelementptr inbounds %struct.op, %struct.op* %4, i32 0, i32 4
  %5 = load i16, i16* %op_type2, align 2
  %conv3 = zext i16 %5 to i32
  %cmp4 = icmp eq i32 %conv3, 5
  br i1 %cmp4, label %if.then, label %if.end.33

if.then:                                          ; preds = %land.lhs.true
  %6 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings = getelementptr inbounds %struct.cop, %struct.cop* %6, i32 0, i32 14
  %7 = load %struct.sv*, %struct.sv** %cop_warnings, align 8
  %cmp6 = icmp ne %struct.sv* %7, null
  br i1 %cmp6, label %land.lhs.true.8, label %lor.lhs.false.18

land.lhs.true.8:                                  ; preds = %if.then
  %8 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings9 = getelementptr inbounds %struct.cop, %struct.cop* %8, i32 0, i32 14
  %9 = load %struct.sv*, %struct.sv** %cop_warnings9, align 8
  %cmp10 = icmp ne %struct.sv* %9, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 2)
  br i1 %cmp10, label %land.lhs.true.12, label %lor.lhs.false.18

land.lhs.true.12:                                 ; preds = %land.lhs.true.8
  %10 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings13 = getelementptr inbounds %struct.cop, %struct.cop* %10, i32 0, i32 14
  %11 = load %struct.sv*, %struct.sv** %cop_warnings13, align 8
  %cmp14 = icmp eq %struct.sv* %11, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 1)
  br i1 %cmp14, label %if.then.26, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true.12
  %12 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings16 = getelementptr inbounds %struct.cop, %struct.cop* %12, i32 0, i32 14
  %13 = load %struct.sv*, %struct.sv** %cop_warnings16, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %13, i32 0, i32 0
  %14 = load i8*, i8** %sv_any, align 8
  %15 = bitcast i8* %14 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %15, i32 0, i32 0
  %16 = load i8*, i8** %xpv_pv, align 8
  %arrayidx = getelementptr inbounds i8, i8* %16, i64 7
  %17 = load i8, i8* %arrayidx, align 1
  %conv17 = sext i8 %17 to i32
  %and = and i32 %conv17, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then.26, label %lor.lhs.false.18

lor.lhs.false.18:                                 ; preds = %lor.lhs.false, %land.lhs.true.8, %if.then
  %18 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings19 = getelementptr inbounds %struct.cop, %struct.cop* %18, i32 0, i32 14
  %19 = load %struct.sv*, %struct.sv** %cop_warnings19, align 8
  %cmp20 = icmp eq %struct.sv* %19, null
  br i1 %cmp20, label %land.lhs.true.22, label %if.end.32

land.lhs.true.22:                                 ; preds = %lor.lhs.false.18
  %20 = load i8, i8* @PL_dowarn, align 1
  %conv23 = zext i8 %20 to i32
  %and24 = and i32 %conv23, 1
  %tobool25 = icmp ne i32 %and24, 0
  br i1 %tobool25, label %if.then.26, label %if.end.32

if.then.26:                                       ; preds = %land.lhs.true.22, %lor.lhs.false, %land.lhs.true.12
  %21 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_line = getelementptr inbounds %struct.cop, %struct.cop* %21, i32 0, i32 13
  %22 = load i32, i32* %cop_line, align 4
  store i32 %22, i32* %oldline, align 4
  %23 = load i32, i32* @PL_copline, align 4
  %cmp27 = icmp ne i32 %23, -1
  br i1 %cmp27, label %if.then.29, label %if.end

if.then.29:                                       ; preds = %if.then.26
  %24 = load i32, i32* @PL_copline, align 4
  %25 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_line30 = getelementptr inbounds %struct.cop, %struct.cop* %25, i32 0, i32 13
  store i32 %24, i32* %cop_line30, align 4
  br label %if.end

if.end:                                           ; preds = %if.then.29, %if.then.26
  call void (i32, i8*, ...) @Perl_warner(i32 28, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.148, i32 0, i32 0))
  %26 = load i32, i32* %oldline, align 4
  %27 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_line31 = getelementptr inbounds %struct.cop, %struct.cop* %27, i32 0, i32 13
  store i32 %26, i32* %cop_line31, align 4
  br label %if.end.32

if.end.32:                                        ; preds = %if.end, %land.lhs.true.22, %lor.lhs.false.18
  br label %if.end.33

if.end.33:                                        ; preds = %if.end.32, %land.lhs.true, %entry
  %28 = load %struct.op*, %struct.op** %o.addr, align 8
  %call = call %struct.op* @Perl_scalar(%struct.op* %28)
  ret %struct.op* %call
}

declare signext i8 @Perl_sv_2bool(%struct.sv*) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newRANGE(i32 %flags, %struct.op* %left, %struct.op* %right) #0 {
entry:
  %flags.addr = alloca i32, align 4
  %left.addr = alloca %struct.op*, align 8
  %right.addr = alloca %struct.op*, align 8
  %range = alloca %struct.logop*, align 8
  %flip = alloca %struct.op*, align 8
  %flop = alloca %struct.op*, align 8
  %leftstart = alloca %struct.op*, align 8
  %o = alloca %struct.op*, align 8
  store i32 %flags, i32* %flags.addr, align 4
  store %struct.op* %left, %struct.op** %left.addr, align 8
  store %struct.op* %right, %struct.op** %right.addr, align 8
  %call = call i8* @Perl_safesysmalloc(i64 56)
  %0 = bitcast i8* %call to %struct.logop*
  store %struct.logop* %0, %struct.logop** %range, align 8
  %1 = load %struct.logop*, %struct.logop** %range, align 8
  %2 = bitcast %struct.logop* %1 to i8*
  call void @llvm.memset.p0i8.i64(i8* %2, i8 0, i64 56, i32 1, i1 false)
  %3 = load %struct.logop*, %struct.logop** %range, align 8
  %op_type = getelementptr inbounds %struct.logop, %struct.logop* %3, i32 0, i32 4
  store i16 156, i16* %op_type, align 2
  %4 = load %struct.op* ()*, %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 156), align 8
  %5 = load %struct.logop*, %struct.logop** %range, align 8
  %op_ppaddr = getelementptr inbounds %struct.logop, %struct.logop* %5, i32 0, i32 2
  store %struct.op* ()* %4, %struct.op* ()** %op_ppaddr, align 8
  %6 = load %struct.op*, %struct.op** %left.addr, align 8
  %7 = load %struct.logop*, %struct.logop** %range, align 8
  %op_first = getelementptr inbounds %struct.logop, %struct.logop* %7, i32 0, i32 8
  store %struct.op* %6, %struct.op** %op_first, align 8
  %8 = load %struct.logop*, %struct.logop** %range, align 8
  %op_flags = getelementptr inbounds %struct.logop, %struct.logop* %8, i32 0, i32 6
  store i8 4, i8* %op_flags, align 1
  %9 = load %struct.op*, %struct.op** %left.addr, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %9, i32 0, i32 0
  %10 = load %struct.op*, %struct.op** %op_next, align 8
  %tobool = icmp ne %struct.op* %10, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %11 = load %struct.op*, %struct.op** %left.addr, align 8
  %op_next1 = getelementptr inbounds %struct.op, %struct.op* %11, i32 0, i32 0
  %12 = load %struct.op*, %struct.op** %op_next1, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %13 = load %struct.op*, %struct.op** %left.addr, align 8
  %call2 = call %struct.op* @Perl_linklist(%struct.op* %13)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.op* [ %12, %cond.true ], [ %call2, %cond.false ]
  store %struct.op* %cond, %struct.op** %leftstart, align 8
  %14 = load %struct.op*, %struct.op** %right.addr, align 8
  %op_next3 = getelementptr inbounds %struct.op, %struct.op* %14, i32 0, i32 0
  %15 = load %struct.op*, %struct.op** %op_next3, align 8
  %tobool4 = icmp ne %struct.op* %15, null
  br i1 %tobool4, label %cond.true.5, label %cond.false.7

cond.true.5:                                      ; preds = %cond.end
  %16 = load %struct.op*, %struct.op** %right.addr, align 8
  %op_next6 = getelementptr inbounds %struct.op, %struct.op* %16, i32 0, i32 0
  %17 = load %struct.op*, %struct.op** %op_next6, align 8
  br label %cond.end.9

cond.false.7:                                     ; preds = %cond.end
  %18 = load %struct.op*, %struct.op** %right.addr, align 8
  %call8 = call %struct.op* @Perl_linklist(%struct.op* %18)
  br label %cond.end.9

cond.end.9:                                       ; preds = %cond.false.7, %cond.true.5
  %cond10 = phi %struct.op* [ %17, %cond.true.5 ], [ %call8, %cond.false.7 ]
  %19 = load %struct.logop*, %struct.logop** %range, align 8
  %op_other = getelementptr inbounds %struct.logop, %struct.logop* %19, i32 0, i32 9
  store %struct.op* %cond10, %struct.op** %op_other, align 8
  %20 = load i32, i32* %flags.addr, align 4
  %shr = ashr i32 %20, 8
  %or = or i32 1, %shr
  %conv = trunc i32 %or to i8
  %21 = load %struct.logop*, %struct.logop** %range, align 8
  %op_private = getelementptr inbounds %struct.logop, %struct.logop* %21, i32 0, i32 7
  store i8 %conv, i8* %op_private, align 1
  %22 = load %struct.op*, %struct.op** %right.addr, align 8
  %23 = load %struct.op*, %struct.op** %left.addr, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %23, i32 0, i32 1
  store %struct.op* %22, %struct.op** %op_sibling, align 8
  %24 = load %struct.logop*, %struct.logop** %range, align 8
  %25 = bitcast %struct.logop* %24 to %struct.op*
  %26 = load %struct.logop*, %struct.logop** %range, align 8
  %op_next11 = getelementptr inbounds %struct.logop, %struct.logop* %26, i32 0, i32 0
  store %struct.op* %25, %struct.op** %op_next11, align 8
  %27 = load i32, i32* %flags.addr, align 4
  %28 = load %struct.logop*, %struct.logop** %range, align 8
  %29 = bitcast %struct.logop* %28 to %struct.op*
  %call12 = call %struct.op* @Perl_newUNOP(i32 157, i32 %27, %struct.op* %29)
  store %struct.op* %call12, %struct.op** %flip, align 8
  %30 = load %struct.op*, %struct.op** %flip, align 8
  %call13 = call %struct.op* @Perl_newUNOP(i32 158, i32 0, %struct.op* %30)
  store %struct.op* %call13, %struct.op** %flop, align 8
  %31 = load %struct.op*, %struct.op** %flop, align 8
  %call14 = call %struct.op* @Perl_newUNOP(i32 0, i32 0, %struct.op* %31)
  store %struct.op* %call14, %struct.op** %o, align 8
  %32 = load %struct.op*, %struct.op** %flop, align 8
  %call15 = call %struct.op* @Perl_linklist(%struct.op* %32)
  %33 = load %struct.op*, %struct.op** %leftstart, align 8
  %34 = load %struct.logop*, %struct.logop** %range, align 8
  %op_next16 = getelementptr inbounds %struct.logop, %struct.logop* %34, i32 0, i32 0
  store %struct.op* %33, %struct.op** %op_next16, align 8
  %35 = load %struct.op*, %struct.op** %flip, align 8
  %36 = load %struct.op*, %struct.op** %left.addr, align 8
  %op_next17 = getelementptr inbounds %struct.op, %struct.op* %36, i32 0, i32 0
  store %struct.op* %35, %struct.op** %op_next17, align 8
  %37 = load %struct.op*, %struct.op** %flop, align 8
  %38 = load %struct.op*, %struct.op** %right.addr, align 8
  %op_next18 = getelementptr inbounds %struct.op, %struct.op* %38, i32 0, i32 0
  store %struct.op* %37, %struct.op** %op_next18, align 8
  %call19 = call i64 @Perl_pad_alloc(i32 156, i32 1024)
  %39 = load %struct.logop*, %struct.logop** %range, align 8
  %op_targ = getelementptr inbounds %struct.logop, %struct.logop* %39, i32 0, i32 3
  store i64 %call19, i64* %op_targ, align 8
  %40 = load %struct.logop*, %struct.logop** %range, align 8
  %op_targ20 = getelementptr inbounds %struct.logop, %struct.logop* %40, i32 0, i32 3
  %41 = load i64, i64* %op_targ20, align 8
  %42 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %42, i64 %41
  %43 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  %call21 = call signext i8 @Perl_sv_upgrade(%struct.sv* %43, i32 6)
  %call22 = call i64 @Perl_pad_alloc(i32 156, i32 1024)
  %44 = load %struct.op*, %struct.op** %flip, align 8
  %op_targ23 = getelementptr inbounds %struct.op, %struct.op* %44, i32 0, i32 3
  store i64 %call22, i64* %op_targ23, align 8
  %45 = load %struct.op*, %struct.op** %flip, align 8
  %op_targ24 = getelementptr inbounds %struct.op, %struct.op* %45, i32 0, i32 3
  %46 = load i64, i64* %op_targ24, align 8
  %47 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx25 = getelementptr inbounds %struct.sv*, %struct.sv** %47, i64 %46
  %48 = load %struct.sv*, %struct.sv** %arrayidx25, align 8
  %call26 = call signext i8 @Perl_sv_upgrade(%struct.sv* %48, i32 6)
  %49 = load %struct.op*, %struct.op** %left.addr, align 8
  %op_type27 = getelementptr inbounds %struct.op, %struct.op* %49, i32 0, i32 4
  %50 = load i16, i16* %op_type27, align 2
  %conv28 = zext i16 %50 to i32
  %cmp = icmp eq i32 %conv28, 5
  %cond30 = select i1 %cmp, i32 64, i32 0
  %conv31 = trunc i32 %cond30 to i8
  %51 = load %struct.op*, %struct.op** %flip, align 8
  %op_private32 = getelementptr inbounds %struct.op, %struct.op* %51, i32 0, i32 7
  store i8 %conv31, i8* %op_private32, align 1
  %52 = load %struct.op*, %struct.op** %right.addr, align 8
  %op_type33 = getelementptr inbounds %struct.op, %struct.op* %52, i32 0, i32 4
  %53 = load i16, i16* %op_type33, align 2
  %conv34 = zext i16 %53 to i32
  %cmp35 = icmp eq i32 %conv34, 5
  %cond37 = select i1 %cmp35, i32 64, i32 0
  %conv38 = trunc i32 %cond37 to i8
  %54 = load %struct.op*, %struct.op** %flop, align 8
  %op_private39 = getelementptr inbounds %struct.op, %struct.op* %54, i32 0, i32 7
  store i8 %conv38, i8* %op_private39, align 1
  %55 = load %struct.op*, %struct.op** %o, align 8
  %56 = load %struct.op*, %struct.op** %flip, align 8
  %op_next40 = getelementptr inbounds %struct.op, %struct.op* %56, i32 0, i32 0
  store %struct.op* %55, %struct.op** %op_next40, align 8
  %57 = load %struct.op*, %struct.op** %flip, align 8
  %op_private41 = getelementptr inbounds %struct.op, %struct.op* %57, i32 0, i32 7
  %58 = load i8, i8* %op_private41, align 1
  %tobool42 = icmp ne i8 %58, 0
  br i1 %tobool42, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %cond.end.9
  %59 = load %struct.op*, %struct.op** %flop, align 8
  %op_private43 = getelementptr inbounds %struct.op, %struct.op* %59, i32 0, i32 7
  %60 = load i8, i8* %op_private43, align 1
  %tobool44 = icmp ne i8 %60, 0
  br i1 %tobool44, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %cond.end.9
  %61 = load %struct.op*, %struct.op** %o, align 8
  %call45 = call %struct.op* @Perl_linklist(%struct.op* %61)
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  %62 = load %struct.op*, %struct.op** %o, align 8
  ret %struct.op* %62
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newLOOPOP(i32 %flags, i32 %debuggable, %struct.op* %expr, %struct.op* %block) #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %flags.addr = alloca i32, align 4
  %debuggable.addr = alloca i32, align 4
  %expr.addr = alloca %struct.op*, align 8
  %block.addr = alloca %struct.op*, align 8
  %listop = alloca %struct.op*, align 8
  %o = alloca %struct.op*, align 8
  %once = alloca i32, align 4
  %k1 = alloca %struct.op*, align 8
  %k2 = alloca %struct.op*, align 8
  store i32 %flags, i32* %flags.addr, align 4
  store i32 %debuggable, i32* %debuggable.addr, align 4
  store %struct.op* %expr, %struct.op** %expr.addr, align 8
  store %struct.op* %block, %struct.op** %block.addr, align 8
  %0 = load %struct.op*, %struct.op** %block.addr, align 8
  %tobool = icmp ne %struct.op* %0, null
  br i1 %tobool, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %1 = load %struct.op*, %struct.op** %block.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 6
  %2 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 128
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %3 = load %struct.op*, %struct.op** %block.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %3, i32 0, i32 4
  %4 = load i16, i16* %op_type, align 2
  %conv2 = zext i16 %4 to i32
  %cmp = icmp eq i32 %conv2, 166
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.rhs
  %5 = load %struct.op*, %struct.op** %block.addr, align 8
  %op_type4 = getelementptr inbounds %struct.op, %struct.op* %5, i32 0, i32 4
  %6 = load i16, i16* %op_type4, align 2
  %conv5 = zext i16 %6 to i32
  %cmp6 = icmp eq i32 %conv5, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.rhs
  %7 = phi i1 [ true, %land.rhs ], [ %cmp6, %lor.rhs ]
  br label %land.end

land.end:                                         ; preds = %lor.end, %land.lhs.true, %entry
  %8 = phi i1 [ false, %land.lhs.true ], [ false, %entry ], [ %7, %lor.end ]
  %land.ext = zext i1 %8 to i32
  store i32 %land.ext, i32* %once, align 4
  %9 = load %struct.op*, %struct.op** %expr.addr, align 8
  %tobool8 = icmp ne %struct.op* %9, null
  br i1 %tobool8, label %if.then, label %if.end.139

if.then:                                          ; preds = %land.end
  %10 = load i32, i32* %once, align 4
  %tobool9 = icmp ne i32 %10, 0
  br i1 %tobool9, label %land.lhs.true.10, label %if.end

land.lhs.true.10:                                 ; preds = %if.then
  %11 = load %struct.op*, %struct.op** %expr.addr, align 8
  %op_type11 = getelementptr inbounds %struct.op, %struct.op* %11, i32 0, i32 4
  %12 = load i16, i16* %op_type11, align 2
  %conv12 = zext i16 %12 to i32
  %cmp13 = icmp eq i32 %conv12, 5
  br i1 %cmp13, label %land.lhs.true.15, label %if.end

land.lhs.true.15:                                 ; preds = %land.lhs.true.10
  %13 = load %struct.op*, %struct.op** %expr.addr, align 8
  %14 = bitcast %struct.op* %13 to %struct.svop*
  %op_sv = getelementptr inbounds %struct.svop, %struct.svop* %14, i32 0, i32 8
  %15 = load %struct.sv*, %struct.sv** %op_sv, align 8
  %tobool16 = icmp ne %struct.sv* %15, null
  br i1 %tobool16, label %cond.false, label %cond.true

cond.true:                                        ; preds = %land.lhs.true.15
  br i1 false, label %if.end, label %if.then.58

cond.false:                                       ; preds = %land.lhs.true.15
  %16 = load %struct.op*, %struct.op** %expr.addr, align 8
  %17 = bitcast %struct.op* %16 to %struct.svop*
  %op_sv17 = getelementptr inbounds %struct.svop, %struct.svop* %17, i32 0, i32 8
  %18 = load %struct.sv*, %struct.sv** %op_sv17, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %18, i32 0, i32 2
  %19 = load i32, i32* %sv_flags, align 4
  %and18 = and i32 %19, 262144
  %tobool19 = icmp ne i32 %and18, 0
  br i1 %tobool19, label %cond.true.20, label %cond.false.34

cond.true.20:                                     ; preds = %cond.false
  %20 = load %struct.op*, %struct.op** %expr.addr, align 8
  %21 = bitcast %struct.op* %20 to %struct.svop*
  %op_sv21 = getelementptr inbounds %struct.svop, %struct.svop* %21, i32 0, i32 8
  %22 = load %struct.sv*, %struct.sv** %op_sv21, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %22, i32 0, i32 0
  %23 = load i8*, i8** %sv_any, align 8
  %24 = bitcast i8* %23 to %struct.xpv*
  store %struct.xpv* %24, %struct.xpv** @PL_Xpv, align 8
  %tobool22 = icmp ne %struct.xpv* %24, null
  br i1 %tobool22, label %land.lhs.true.23, label %cond.false.33

land.lhs.true.23:                                 ; preds = %cond.true.20
  %25 = load %struct.xpv*, %struct.xpv** @PL_Xpv, align 8
  %xpv_cur = getelementptr inbounds %struct.xpv, %struct.xpv* %25, i32 0, i32 1
  %26 = load i64, i64* %xpv_cur, align 8
  %cmp24 = icmp ugt i64 %26, 1
  br i1 %cmp24, label %cond.true.32, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true.23
  %27 = load %struct.xpv*, %struct.xpv** @PL_Xpv, align 8
  %xpv_cur26 = getelementptr inbounds %struct.xpv, %struct.xpv* %27, i32 0, i32 1
  %28 = load i64, i64* %xpv_cur26, align 8
  %tobool27 = icmp ne i64 %28, 0
  br i1 %tobool27, label %land.lhs.true.28, label %cond.false.33

land.lhs.true.28:                                 ; preds = %lor.lhs.false
  %29 = load %struct.xpv*, %struct.xpv** @PL_Xpv, align 8
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %29, i32 0, i32 0
  %30 = load i8*, i8** %xpv_pv, align 8
  %31 = load i8, i8* %30, align 1
  %conv29 = sext i8 %31 to i32
  %cmp30 = icmp ne i32 %conv29, 48
  br i1 %cmp30, label %cond.true.32, label %cond.false.33

cond.true.32:                                     ; preds = %land.lhs.true.28, %land.lhs.true.23
  br i1 true, label %if.end, label %if.then.58

cond.false.33:                                    ; preds = %land.lhs.true.28, %lor.lhs.false, %cond.true.20
  br i1 false, label %if.end, label %if.then.58

cond.false.34:                                    ; preds = %cond.false
  %32 = load %struct.op*, %struct.op** %expr.addr, align 8
  %33 = bitcast %struct.op* %32 to %struct.svop*
  %op_sv35 = getelementptr inbounds %struct.svop, %struct.svop* %33, i32 0, i32 8
  %34 = load %struct.sv*, %struct.sv** %op_sv35, align 8
  %sv_flags36 = getelementptr inbounds %struct.sv, %struct.sv* %34, i32 0, i32 2
  %35 = load i32, i32* %sv_flags36, align 4
  %and37 = and i32 %35, 65536
  %tobool38 = icmp ne i32 %and37, 0
  br i1 %tobool38, label %cond.true.39, label %cond.false.44

cond.true.39:                                     ; preds = %cond.false.34
  %36 = load %struct.op*, %struct.op** %expr.addr, align 8
  %37 = bitcast %struct.op* %36 to %struct.svop*
  %op_sv40 = getelementptr inbounds %struct.svop, %struct.svop* %37, i32 0, i32 8
  %38 = load %struct.sv*, %struct.sv** %op_sv40, align 8
  %sv_any41 = getelementptr inbounds %struct.sv, %struct.sv* %38, i32 0, i32 0
  %39 = load i8*, i8** %sv_any41, align 8
  %40 = bitcast i8* %39 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %40, i32 0, i32 3
  %41 = load i64, i64* %xiv_iv, align 8
  %cmp42 = icmp ne i64 %41, 0
  br i1 %cmp42, label %if.end, label %if.then.58

cond.false.44:                                    ; preds = %cond.false.34
  %42 = load %struct.op*, %struct.op** %expr.addr, align 8
  %43 = bitcast %struct.op* %42 to %struct.svop*
  %op_sv45 = getelementptr inbounds %struct.svop, %struct.svop* %43, i32 0, i32 8
  %44 = load %struct.sv*, %struct.sv** %op_sv45, align 8
  %sv_flags46 = getelementptr inbounds %struct.sv, %struct.sv* %44, i32 0, i32 2
  %45 = load i32, i32* %sv_flags46, align 4
  %and47 = and i32 %45, 131072
  %tobool48 = icmp ne i32 %and47, 0
  br i1 %tobool48, label %cond.true.49, label %cond.false.54

cond.true.49:                                     ; preds = %cond.false.44
  %46 = load %struct.op*, %struct.op** %expr.addr, align 8
  %47 = bitcast %struct.op* %46 to %struct.svop*
  %op_sv50 = getelementptr inbounds %struct.svop, %struct.svop* %47, i32 0, i32 8
  %48 = load %struct.sv*, %struct.sv** %op_sv50, align 8
  %sv_any51 = getelementptr inbounds %struct.sv, %struct.sv* %48, i32 0, i32 0
  %49 = load i8*, i8** %sv_any51, align 8
  %50 = bitcast i8* %49 to %struct.xpvnv*
  %xnv_nv = getelementptr inbounds %struct.xpvnv, %struct.xpvnv* %50, i32 0, i32 4
  %51 = load double, double* %xnv_nv, align 8
  %cmp52 = fcmp une double %51, 0.000000e+00
  br i1 %cmp52, label %if.end, label %if.then.58

cond.false.54:                                    ; preds = %cond.false.44
  %52 = load %struct.op*, %struct.op** %expr.addr, align 8
  %53 = bitcast %struct.op* %52 to %struct.svop*
  %op_sv55 = getelementptr inbounds %struct.svop, %struct.svop* %53, i32 0, i32 8
  %54 = load %struct.sv*, %struct.sv** %op_sv55, align 8
  %call = call signext i8 @Perl_sv_2bool(%struct.sv* %54)
  %conv56 = sext i8 %call to i32
  %tobool57 = icmp ne i32 %conv56, 0
  br i1 %tobool57, label %if.end, label %if.then.58

if.then.58:                                       ; preds = %cond.false.54, %cond.true.49, %cond.true.39, %cond.false.33, %cond.true.32, %cond.true
  %55 = load %struct.op*, %struct.op** %block.addr, align 8
  store %struct.op* %55, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %cond.false.54, %cond.true.49, %cond.true.39, %cond.false.33, %cond.true.32, %cond.true, %land.lhs.true.10, %if.then
  %56 = load %struct.op*, %struct.op** %expr.addr, align 8
  %op_type59 = getelementptr inbounds %struct.op, %struct.op* %56, i32 0, i32 4
  %57 = load i16, i16* %op_type59, align 2
  %conv60 = zext i16 %57 to i32
  %cmp61 = icmp eq i32 %conv60, 26
  br i1 %cmp61, label %if.then.76, label %lor.lhs.false.63

lor.lhs.false.63:                                 ; preds = %if.end
  %58 = load %struct.op*, %struct.op** %expr.addr, align 8
  %op_type64 = getelementptr inbounds %struct.op, %struct.op* %58, i32 0, i32 4
  %59 = load i16, i16* %op_type64, align 2
  %conv65 = zext i16 %59 to i32
  %cmp66 = icmp eq i32 %conv65, 25
  br i1 %cmp66, label %if.then.76, label %lor.lhs.false.68

lor.lhs.false.68:                                 ; preds = %lor.lhs.false.63
  %60 = load %struct.op*, %struct.op** %expr.addr, align 8
  %op_type69 = getelementptr inbounds %struct.op, %struct.op* %60, i32 0, i32 4
  %61 = load i16, i16* %op_type69, align 2
  %conv70 = zext i16 %61 to i32
  %cmp71 = icmp eq i32 %conv70, 0
  br i1 %cmp71, label %land.lhs.true.73, label %if.else

land.lhs.true.73:                                 ; preds = %lor.lhs.false.68
  %62 = load %struct.op*, %struct.op** %expr.addr, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %62, i32 0, i32 3
  %63 = load i64, i64* %op_targ, align 8
  %cmp74 = icmp eq i64 %63, 25
  br i1 %cmp74, label %if.then.76, label %if.else

if.then.76:                                       ; preds = %land.lhs.true.73, %lor.lhs.false.63, %if.end
  %call77 = call %struct.op* @S_newDEFSVOP()
  %64 = load %struct.op*, %struct.op** %expr.addr, align 8
  %call78 = call %struct.op* @Perl_newASSIGNOP(i32 0, %struct.op* %call77, i32 0, %struct.op* %64)
  %call79 = call %struct.op* @Perl_newUNOP(i32 42, i32 0, %struct.op* %call78)
  store %struct.op* %call79, %struct.op** %expr.addr, align 8
  br label %if.end.138

if.else:                                          ; preds = %land.lhs.true.73, %lor.lhs.false.68
  %65 = load %struct.op*, %struct.op** %expr.addr, align 8
  %op_flags80 = getelementptr inbounds %struct.op, %struct.op* %65, i32 0, i32 6
  %66 = load i8, i8* %op_flags80, align 1
  %conv81 = zext i8 %66 to i32
  %and82 = and i32 %conv81, 4
  %tobool83 = icmp ne i32 %and82, 0
  br i1 %tobool83, label %if.then.84, label %if.end.137

if.then.84:                                       ; preds = %if.else
  %67 = load %struct.op*, %struct.op** %expr.addr, align 8
  %68 = bitcast %struct.op* %67 to %struct.unop*
  %op_first = getelementptr inbounds %struct.unop, %struct.unop* %68, i32 0, i32 8
  %69 = load %struct.op*, %struct.op** %op_first, align 8
  store %struct.op* %69, %struct.op** %k1, align 8
  %70 = load %struct.op*, %struct.op** %k1, align 8
  %tobool85 = icmp ne %struct.op* %70, null
  br i1 %tobool85, label %cond.true.86, label %cond.false.87

cond.true.86:                                     ; preds = %if.then.84
  %71 = load %struct.op*, %struct.op** %k1, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %71, i32 0, i32 1
  %72 = load %struct.op*, %struct.op** %op_sibling, align 8
  br label %cond.end

cond.false.87:                                    ; preds = %if.then.84
  br label %cond.end

cond.end:                                         ; preds = %cond.false.87, %cond.true.86
  %cond = phi %struct.op* [ %72, %cond.true.86 ], [ null, %cond.false.87 ]
  store %struct.op* %cond, %struct.op** %k2, align 8
  %73 = load %struct.op*, %struct.op** %expr.addr, align 8
  %op_type88 = getelementptr inbounds %struct.op, %struct.op* %73, i32 0, i32 4
  %74 = load i16, i16* %op_type88, align 2
  %conv89 = zext i16 %74 to i32
  switch i32 %conv89, label %sw.epilog [
    i32 0, label %sw.bb
    i32 36, label %sw.bb.110
  ]

sw.bb:                                            ; preds = %cond.end
  %75 = load %struct.op*, %struct.op** %k2, align 8
  %tobool90 = icmp ne %struct.op* %75, null
  br i1 %tobool90, label %land.lhs.true.91, label %if.end.109

land.lhs.true.91:                                 ; preds = %sw.bb
  %76 = load %struct.op*, %struct.op** %k2, align 8
  %op_type92 = getelementptr inbounds %struct.op, %struct.op* %76, i32 0, i32 4
  %77 = load i16, i16* %op_type92, align 2
  %conv93 = zext i16 %77 to i32
  %cmp94 = icmp eq i32 %conv93, 26
  br i1 %cmp94, label %land.lhs.true.96, label %if.end.109

land.lhs.true.96:                                 ; preds = %land.lhs.true.91
  %78 = load %struct.op*, %struct.op** %k2, align 8
  %op_flags97 = getelementptr inbounds %struct.op, %struct.op* %78, i32 0, i32 6
  %79 = load i8, i8* %op_flags97, align 1
  %conv98 = zext i8 %79 to i32
  %and99 = and i32 %conv98, 64
  %tobool100 = icmp ne i32 %and99, 0
  br i1 %tobool100, label %land.lhs.true.101, label %if.end.109

land.lhs.true.101:                                ; preds = %land.lhs.true.96
  %80 = load %struct.op*, %struct.op** %k1, align 8
  %op_flags102 = getelementptr inbounds %struct.op, %struct.op* %80, i32 0, i32 6
  %81 = load i8, i8* %op_flags102, align 1
  %conv103 = zext i8 %81 to i32
  %and104 = and i32 %conv103, 3
  %cmp105 = icmp eq i32 %and104, 2
  br i1 %cmp105, label %if.then.107, label %if.end.109

if.then.107:                                      ; preds = %land.lhs.true.101
  %82 = load %struct.op*, %struct.op** %expr.addr, align 8
  %call108 = call %struct.op* @Perl_newUNOP(i32 42, i32 0, %struct.op* %82)
  store %struct.op* %call108, %struct.op** %expr.addr, align 8
  br label %if.end.109

if.end.109:                                       ; preds = %if.then.107, %land.lhs.true.101, %land.lhs.true.96, %land.lhs.true.91, %sw.bb
  br label %sw.epilog

sw.bb.110:                                        ; preds = %cond.end
  %83 = load %struct.op*, %struct.op** %k1, align 8
  %op_type111 = getelementptr inbounds %struct.op, %struct.op* %83, i32 0, i32 4
  %84 = load i16, i16* %op_type111, align 2
  %conv112 = zext i16 %84 to i32
  %cmp113 = icmp eq i32 %conv112, 276
  br i1 %cmp113, label %if.then.134, label %lor.lhs.false.115

lor.lhs.false.115:                                ; preds = %sw.bb.110
  %85 = load %struct.op*, %struct.op** %k1, align 8
  %op_type116 = getelementptr inbounds %struct.op, %struct.op* %85, i32 0, i32 4
  %86 = load i16, i16* %op_type116, align 2
  %conv117 = zext i16 %86 to i32
  %cmp118 = icmp eq i32 %conv117, 25
  br i1 %cmp118, label %if.then.134, label %lor.lhs.false.120

lor.lhs.false.120:                                ; preds = %lor.lhs.false.115
  %87 = load %struct.op*, %struct.op** %k1, align 8
  %op_type121 = getelementptr inbounds %struct.op, %struct.op* %87, i32 0, i32 4
  %88 = load i16, i16* %op_type121, align 2
  %conv122 = zext i16 %88 to i32
  %cmp123 = icmp eq i32 %conv122, 0
  br i1 %cmp123, label %land.lhs.true.125, label %lor.lhs.false.129

land.lhs.true.125:                                ; preds = %lor.lhs.false.120
  %89 = load %struct.op*, %struct.op** %k1, align 8
  %op_targ126 = getelementptr inbounds %struct.op, %struct.op* %89, i32 0, i32 3
  %90 = load i64, i64* %op_targ126, align 8
  %cmp127 = icmp eq i64 %90, 25
  br i1 %cmp127, label %if.then.134, label %lor.lhs.false.129

lor.lhs.false.129:                                ; preds = %land.lhs.true.125, %lor.lhs.false.120
  %91 = load %struct.op*, %struct.op** %k1, align 8
  %op_type130 = getelementptr inbounds %struct.op, %struct.op* %91, i32 0, i32 4
  %92 = load i16, i16* %op_type130, align 2
  %conv131 = zext i16 %92 to i32
  %cmp132 = icmp eq i32 %conv131, 129
  br i1 %cmp132, label %if.then.134, label %if.end.136

if.then.134:                                      ; preds = %lor.lhs.false.129, %land.lhs.true.125, %lor.lhs.false.115, %sw.bb.110
  %93 = load %struct.op*, %struct.op** %expr.addr, align 8
  %call135 = call %struct.op* @Perl_newUNOP(i32 42, i32 0, %struct.op* %93)
  store %struct.op* %call135, %struct.op** %expr.addr, align 8
  br label %if.end.136

if.end.136:                                       ; preds = %if.then.134, %lor.lhs.false.129
  br label %sw.epilog

sw.epilog:                                        ; preds = %cond.end, %if.end.136, %if.end.109
  br label %if.end.137

if.end.137:                                       ; preds = %sw.epilog, %if.else
  br label %if.end.138

if.end.138:                                       ; preds = %if.end.137, %if.then.76
  br label %if.end.139

if.end.139:                                       ; preds = %if.end.138, %land.end
  %94 = load %struct.op*, %struct.op** %block.addr, align 8
  %tobool140 = icmp ne %struct.op* %94, null
  br i1 %tobool140, label %if.end.143, label %if.then.141

if.then.141:                                      ; preds = %if.end.139
  %call142 = call %struct.op* @Perl_newOP(i32 0, i32 0)
  store %struct.op* %call142, %struct.op** %block.addr, align 8
  br label %if.end.143

if.end.143:                                       ; preds = %if.then.141, %if.end.139
  %95 = load %struct.op*, %struct.op** %block.addr, align 8
  %call144 = call %struct.op* @Perl_newOP(i32 176, i32 0)
  %call145 = call %struct.op* @Perl_append_elem(i32 173, %struct.op* %95, %struct.op* %call144)
  store %struct.op* %call145, %struct.op** %listop, align 8
  %call146 = call %struct.op* @S_new_logop(i32 159, i32 0, %struct.op** %expr.addr, %struct.op** %listop)
  store %struct.op* %call146, %struct.op** %o, align 8
  %96 = load %struct.op*, %struct.op** %listop, align 8
  %tobool147 = icmp ne %struct.op* %96, null
  br i1 %tobool147, label %if.then.148, label %if.end.157

if.then.148:                                      ; preds = %if.end.143
  %97 = load %struct.op*, %struct.op** %o, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %97, i32 0, i32 0
  %98 = load %struct.op*, %struct.op** %op_next, align 8
  %tobool149 = icmp ne %struct.op* %98, null
  br i1 %tobool149, label %cond.true.150, label %cond.false.152

cond.true.150:                                    ; preds = %if.then.148
  %99 = load %struct.op*, %struct.op** %o, align 8
  %op_next151 = getelementptr inbounds %struct.op, %struct.op* %99, i32 0, i32 0
  %100 = load %struct.op*, %struct.op** %op_next151, align 8
  br label %cond.end.154

cond.false.152:                                   ; preds = %if.then.148
  %101 = load %struct.op*, %struct.op** %o, align 8
  %call153 = call %struct.op* @Perl_linklist(%struct.op* %101)
  br label %cond.end.154

cond.end.154:                                     ; preds = %cond.false.152, %cond.true.150
  %cond155 = phi %struct.op* [ %100, %cond.true.150 ], [ %call153, %cond.false.152 ]
  %102 = load %struct.op*, %struct.op** %listop, align 8
  %103 = bitcast %struct.op* %102 to %struct.listop*
  %op_last = getelementptr inbounds %struct.listop, %struct.listop* %103, i32 0, i32 9
  %104 = load %struct.op*, %struct.op** %op_last, align 8
  %op_next156 = getelementptr inbounds %struct.op, %struct.op* %104, i32 0, i32 0
  store %struct.op* %cond155, %struct.op** %op_next156, align 8
  br label %if.end.157

if.end.157:                                       ; preds = %cond.end.154, %if.end.143
  %105 = load i32, i32* %once, align 4
  %tobool158 = icmp ne i32 %105, 0
  br i1 %tobool158, label %land.lhs.true.159, label %if.end.165

land.lhs.true.159:                                ; preds = %if.end.157
  %106 = load %struct.op*, %struct.op** %o, align 8
  %107 = load %struct.op*, %struct.op** %listop, align 8
  %cmp160 = icmp ne %struct.op* %106, %107
  br i1 %cmp160, label %if.then.162, label %if.end.165

if.then.162:                                      ; preds = %land.lhs.true.159
  %108 = load %struct.op*, %struct.op** %o, align 8
  %109 = bitcast %struct.op* %108 to %struct.unop*
  %op_first163 = getelementptr inbounds %struct.unop, %struct.unop* %109, i32 0, i32 8
  %110 = load %struct.op*, %struct.op** %op_first163, align 8
  %111 = bitcast %struct.op* %110 to %struct.logop*
  %op_other = getelementptr inbounds %struct.logop, %struct.logop* %111, i32 0, i32 9
  %112 = load %struct.op*, %struct.op** %op_other, align 8
  %113 = load %struct.op*, %struct.op** %o, align 8
  %op_next164 = getelementptr inbounds %struct.op, %struct.op* %113, i32 0, i32 0
  store %struct.op* %112, %struct.op** %op_next164, align 8
  br label %if.end.165

if.end.165:                                       ; preds = %if.then.162, %land.lhs.true.159, %if.end.157
  %114 = load %struct.op*, %struct.op** %o, align 8
  %115 = load %struct.op*, %struct.op** %listop, align 8
  %cmp166 = icmp eq %struct.op* %114, %115
  br i1 %cmp166, label %if.then.168, label %if.end.170

if.then.168:                                      ; preds = %if.end.165
  %116 = load %struct.op*, %struct.op** %o, align 8
  %call169 = call %struct.op* @Perl_newUNOP(i32 0, i32 0, %struct.op* %116)
  store %struct.op* %call169, %struct.op** %o, align 8
  br label %if.end.170

if.end.170:                                       ; preds = %if.then.168, %if.end.165
  %117 = load i32, i32* %flags.addr, align 4
  %118 = load %struct.op*, %struct.op** %o, align 8
  %op_flags171 = getelementptr inbounds %struct.op, %struct.op* %118, i32 0, i32 6
  %119 = load i8, i8* %op_flags171, align 1
  %conv172 = zext i8 %119 to i32
  %or = or i32 %conv172, %117
  %conv173 = trunc i32 %or to i8
  store i8 %conv173, i8* %op_flags171, align 1
  %120 = load %struct.op*, %struct.op** %o, align 8
  %call174 = call %struct.op* @Perl_scope(%struct.op* %120)
  store %struct.op* %call174, %struct.op** %o, align 8
  %121 = load %struct.op*, %struct.op** %o, align 8
  %op_flags175 = getelementptr inbounds %struct.op, %struct.op* %121, i32 0, i32 6
  %122 = load i8, i8* %op_flags175, align 1
  %conv176 = zext i8 %122 to i32
  %or177 = or i32 %conv176, 128
  %conv178 = trunc i32 %or177 to i8
  store i8 %conv178, i8* %op_flags175, align 1
  %123 = load %struct.op*, %struct.op** %o, align 8
  store %struct.op* %123, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.170, %if.then.58
  %124 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %124
}

; Function Attrs: nounwind uwtable
define internal %struct.op* @S_newDEFSVOP() #0 {
entry:
  %0 = load %struct.gv*, %struct.gv** @PL_defgv, align 8
  %call = call %struct.op* @Perl_newGVOP(i32 7, i32 0, %struct.gv* %0)
  %call1 = call %struct.op* @Perl_newSVREF(%struct.op* %call)
  ret %struct.op* %call1
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newWHILEOP(i32 %flags, i32 %debuggable, %struct.loop* %loop, i32 %whileline, %struct.op* %expr, %struct.op* %block, %struct.op* %cont) #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %flags.addr = alloca i32, align 4
  %debuggable.addr = alloca i32, align 4
  %loop.addr = alloca %struct.loop*, align 8
  %whileline.addr = alloca i32, align 4
  %expr.addr = alloca %struct.op*, align 8
  %block.addr = alloca %struct.op*, align 8
  %cont.addr = alloca %struct.op*, align 8
  %redo = alloca %struct.op*, align 8
  %next = alloca %struct.op*, align 8
  %listop = alloca %struct.op*, align 8
  %o = alloca %struct.op*, align 8
  %loopflags = alloca i8, align 1
  %k1 = alloca %struct.op*, align 8
  %k2 = alloca %struct.op*, align 8
  %unstack = alloca %struct.op*, align 8
  store i32 %flags, i32* %flags.addr, align 4
  store i32 %debuggable, i32* %debuggable.addr, align 4
  store %struct.loop* %loop, %struct.loop** %loop.addr, align 8
  store i32 %whileline, i32* %whileline.addr, align 4
  store %struct.op* %expr, %struct.op** %expr.addr, align 8
  store %struct.op* %block, %struct.op** %block.addr, align 8
  store %struct.op* %cont, %struct.op** %cont.addr, align 8
  store %struct.op* null, %struct.op** %next, align 8
  store i8 0, i8* %loopflags, align 1
  %0 = load %struct.op*, %struct.op** %expr.addr, align 8
  %tobool = icmp ne %struct.op* %0, null
  br i1 %tobool, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %1 = load %struct.op*, %struct.op** %expr.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 4
  %2 = load i16, i16* %op_type, align 2
  %conv = zext i16 %2 to i32
  %cmp = icmp eq i32 %conv, 26
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %3 = load %struct.op*, %struct.op** %expr.addr, align 8
  %op_type2 = getelementptr inbounds %struct.op, %struct.op* %3, i32 0, i32 4
  %4 = load i16, i16* %op_type2, align 2
  %conv3 = zext i16 %4 to i32
  %cmp4 = icmp eq i32 %conv3, 25
  br i1 %cmp4, label %if.then, label %lor.lhs.false.6

lor.lhs.false.6:                                  ; preds = %lor.lhs.false
  %5 = load %struct.op*, %struct.op** %expr.addr, align 8
  %op_type7 = getelementptr inbounds %struct.op, %struct.op* %5, i32 0, i32 4
  %6 = load i16, i16* %op_type7, align 2
  %conv8 = zext i16 %6 to i32
  %cmp9 = icmp eq i32 %conv8, 0
  br i1 %cmp9, label %land.lhs.true.11, label %if.else

land.lhs.true.11:                                 ; preds = %lor.lhs.false.6
  %7 = load %struct.op*, %struct.op** %expr.addr, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %7, i32 0, i32 3
  %8 = load i64, i64* %op_targ, align 8
  %cmp12 = icmp eq i64 %8, 25
  br i1 %cmp12, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true.11, %lor.lhs.false, %land.lhs.true
  %call = call %struct.op* @S_newDEFSVOP()
  %9 = load %struct.op*, %struct.op** %expr.addr, align 8
  %call14 = call %struct.op* @Perl_newASSIGNOP(i32 0, %struct.op* %call, i32 0, %struct.op* %9)
  %call15 = call %struct.op* @Perl_newUNOP(i32 42, i32 0, %struct.op* %call14)
  store %struct.op* %call15, %struct.op** %expr.addr, align 8
  br label %if.end.71

if.else:                                          ; preds = %land.lhs.true.11, %lor.lhs.false.6, %entry
  %10 = load %struct.op*, %struct.op** %expr.addr, align 8
  %tobool16 = icmp ne %struct.op* %10, null
  br i1 %tobool16, label %land.lhs.true.17, label %if.end.70

land.lhs.true.17:                                 ; preds = %if.else
  %11 = load %struct.op*, %struct.op** %expr.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %11, i32 0, i32 6
  %12 = load i8, i8* %op_flags, align 1
  %conv18 = zext i8 %12 to i32
  %and = and i32 %conv18, 4
  %tobool19 = icmp ne i32 %and, 0
  br i1 %tobool19, label %if.then.20, label %if.end.70

if.then.20:                                       ; preds = %land.lhs.true.17
  %13 = load %struct.op*, %struct.op** %expr.addr, align 8
  %14 = bitcast %struct.op* %13 to %struct.unop*
  %op_first = getelementptr inbounds %struct.unop, %struct.unop* %14, i32 0, i32 8
  %15 = load %struct.op*, %struct.op** %op_first, align 8
  store %struct.op* %15, %struct.op** %k1, align 8
  %16 = load %struct.op*, %struct.op** %k1, align 8
  %tobool21 = icmp ne %struct.op* %16, null
  br i1 %tobool21, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.20
  %17 = load %struct.op*, %struct.op** %k1, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %17, i32 0, i32 1
  %18 = load %struct.op*, %struct.op** %op_sibling, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then.20
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.op* [ %18, %cond.true ], [ null, %cond.false ]
  store %struct.op* %cond, %struct.op** %k2, align 8
  %19 = load %struct.op*, %struct.op** %expr.addr, align 8
  %op_type22 = getelementptr inbounds %struct.op, %struct.op* %19, i32 0, i32 4
  %20 = load i16, i16* %op_type22, align 2
  %conv23 = zext i16 %20 to i32
  switch i32 %conv23, label %sw.epilog [
    i32 0, label %sw.bb
    i32 36, label %sw.bb.43
  ]

sw.bb:                                            ; preds = %cond.end
  %21 = load %struct.op*, %struct.op** %k2, align 8
  %tobool24 = icmp ne %struct.op* %21, null
  br i1 %tobool24, label %land.lhs.true.25, label %if.end

land.lhs.true.25:                                 ; preds = %sw.bb
  %22 = load %struct.op*, %struct.op** %k2, align 8
  %op_type26 = getelementptr inbounds %struct.op, %struct.op* %22, i32 0, i32 4
  %23 = load i16, i16* %op_type26, align 2
  %conv27 = zext i16 %23 to i32
  %cmp28 = icmp eq i32 %conv27, 26
  br i1 %cmp28, label %land.lhs.true.30, label %if.end

land.lhs.true.30:                                 ; preds = %land.lhs.true.25
  %24 = load %struct.op*, %struct.op** %k2, align 8
  %op_flags31 = getelementptr inbounds %struct.op, %struct.op* %24, i32 0, i32 6
  %25 = load i8, i8* %op_flags31, align 1
  %conv32 = zext i8 %25 to i32
  %and33 = and i32 %conv32, 64
  %tobool34 = icmp ne i32 %and33, 0
  br i1 %tobool34, label %land.lhs.true.35, label %if.end

land.lhs.true.35:                                 ; preds = %land.lhs.true.30
  %26 = load %struct.op*, %struct.op** %k1, align 8
  %op_flags36 = getelementptr inbounds %struct.op, %struct.op* %26, i32 0, i32 6
  %27 = load i8, i8* %op_flags36, align 1
  %conv37 = zext i8 %27 to i32
  %and38 = and i32 %conv37, 3
  %cmp39 = icmp eq i32 %and38, 2
  br i1 %cmp39, label %if.then.41, label %if.end

if.then.41:                                       ; preds = %land.lhs.true.35
  %28 = load %struct.op*, %struct.op** %expr.addr, align 8
  %call42 = call %struct.op* @Perl_newUNOP(i32 42, i32 0, %struct.op* %28)
  store %struct.op* %call42, %struct.op** %expr.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then.41, %land.lhs.true.35, %land.lhs.true.30, %land.lhs.true.25, %sw.bb
  br label %sw.epilog

sw.bb.43:                                         ; preds = %cond.end
  %29 = load %struct.op*, %struct.op** %k1, align 8
  %op_type44 = getelementptr inbounds %struct.op, %struct.op* %29, i32 0, i32 4
  %30 = load i16, i16* %op_type44, align 2
  %conv45 = zext i16 %30 to i32
  %cmp46 = icmp eq i32 %conv45, 276
  br i1 %cmp46, label %if.then.67, label %lor.lhs.false.48

lor.lhs.false.48:                                 ; preds = %sw.bb.43
  %31 = load %struct.op*, %struct.op** %k1, align 8
  %op_type49 = getelementptr inbounds %struct.op, %struct.op* %31, i32 0, i32 4
  %32 = load i16, i16* %op_type49, align 2
  %conv50 = zext i16 %32 to i32
  %cmp51 = icmp eq i32 %conv50, 25
  br i1 %cmp51, label %if.then.67, label %lor.lhs.false.53

lor.lhs.false.53:                                 ; preds = %lor.lhs.false.48
  %33 = load %struct.op*, %struct.op** %k1, align 8
  %op_type54 = getelementptr inbounds %struct.op, %struct.op* %33, i32 0, i32 4
  %34 = load i16, i16* %op_type54, align 2
  %conv55 = zext i16 %34 to i32
  %cmp56 = icmp eq i32 %conv55, 0
  br i1 %cmp56, label %land.lhs.true.58, label %lor.lhs.false.62

land.lhs.true.58:                                 ; preds = %lor.lhs.false.53
  %35 = load %struct.op*, %struct.op** %k1, align 8
  %op_targ59 = getelementptr inbounds %struct.op, %struct.op* %35, i32 0, i32 3
  %36 = load i64, i64* %op_targ59, align 8
  %cmp60 = icmp eq i64 %36, 25
  br i1 %cmp60, label %if.then.67, label %lor.lhs.false.62

lor.lhs.false.62:                                 ; preds = %land.lhs.true.58, %lor.lhs.false.53
  %37 = load %struct.op*, %struct.op** %k1, align 8
  %op_type63 = getelementptr inbounds %struct.op, %struct.op* %37, i32 0, i32 4
  %38 = load i16, i16* %op_type63, align 2
  %conv64 = zext i16 %38 to i32
  %cmp65 = icmp eq i32 %conv64, 129
  br i1 %cmp65, label %if.then.67, label %if.end.69

if.then.67:                                       ; preds = %lor.lhs.false.62, %land.lhs.true.58, %lor.lhs.false.48, %sw.bb.43
  %39 = load %struct.op*, %struct.op** %expr.addr, align 8
  %call68 = call %struct.op* @Perl_newUNOP(i32 42, i32 0, %struct.op* %39)
  store %struct.op* %call68, %struct.op** %expr.addr, align 8
  br label %if.end.69

if.end.69:                                        ; preds = %if.then.67, %lor.lhs.false.62
  br label %sw.epilog

sw.epilog:                                        ; preds = %cond.end, %if.end.69, %if.end
  br label %if.end.70

if.end.70:                                        ; preds = %sw.epilog, %land.lhs.true.17, %if.else
  br label %if.end.71

if.end.71:                                        ; preds = %if.end.70, %if.then
  %40 = load %struct.op*, %struct.op** %block.addr, align 8
  %tobool72 = icmp ne %struct.op* %40, null
  br i1 %tobool72, label %if.else.75, label %if.then.73

if.then.73:                                       ; preds = %if.end.71
  %call74 = call %struct.op* @Perl_newOP(i32 0, i32 0)
  store %struct.op* %call74, %struct.op** %block.addr, align 8
  br label %if.end.80

if.else.75:                                       ; preds = %if.end.71
  %41 = load %struct.op*, %struct.op** %cont.addr, align 8
  %tobool76 = icmp ne %struct.op* %41, null
  br i1 %tobool76, label %if.then.77, label %if.end.79

if.then.77:                                       ; preds = %if.else.75
  %42 = load %struct.op*, %struct.op** %block.addr, align 8
  %call78 = call %struct.op* @Perl_scope(%struct.op* %42)
  store %struct.op* %call78, %struct.op** %block.addr, align 8
  br label %if.end.79

if.end.79:                                        ; preds = %if.then.77, %if.else.75
  br label %if.end.80

if.end.80:                                        ; preds = %if.end.79, %if.then.73
  %43 = load %struct.op*, %struct.op** %cont.addr, align 8
  %tobool81 = icmp ne %struct.op* %43, null
  br i1 %tobool81, label %if.then.82, label %if.end.90

if.then.82:                                       ; preds = %if.end.80
  %44 = load %struct.op*, %struct.op** %cont.addr, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %44, i32 0, i32 0
  %45 = load %struct.op*, %struct.op** %op_next, align 8
  %tobool83 = icmp ne %struct.op* %45, null
  br i1 %tobool83, label %cond.true.84, label %cond.false.86

cond.true.84:                                     ; preds = %if.then.82
  %46 = load %struct.op*, %struct.op** %cont.addr, align 8
  %op_next85 = getelementptr inbounds %struct.op, %struct.op* %46, i32 0, i32 0
  %47 = load %struct.op*, %struct.op** %op_next85, align 8
  br label %cond.end.88

cond.false.86:                                    ; preds = %if.then.82
  %48 = load %struct.op*, %struct.op** %cont.addr, align 8
  %call87 = call %struct.op* @Perl_linklist(%struct.op* %48)
  br label %cond.end.88

cond.end.88:                                      ; preds = %cond.false.86, %cond.true.84
  %cond89 = phi %struct.op* [ %47, %cond.true.84 ], [ %call87, %cond.false.86 ]
  store %struct.op* %cond89, %struct.op** %next, align 8
  br label %if.end.90

if.end.90:                                        ; preds = %cond.end.88, %if.end.80
  %49 = load %struct.op*, %struct.op** %expr.addr, align 8
  %tobool91 = icmp ne %struct.op* %49, null
  br i1 %tobool91, label %if.then.92, label %if.end.98

if.then.92:                                       ; preds = %if.end.90
  %call93 = call %struct.op* @Perl_newOP(i32 176, i32 0)
  store %struct.op* %call93, %struct.op** %unstack, align 8
  %50 = load %struct.op*, %struct.op** %next, align 8
  %tobool94 = icmp ne %struct.op* %50, null
  br i1 %tobool94, label %if.end.96, label %if.then.95

if.then.95:                                       ; preds = %if.then.92
  %51 = load %struct.op*, %struct.op** %unstack, align 8
  store %struct.op* %51, %struct.op** %next, align 8
  br label %if.end.96

if.end.96:                                        ; preds = %if.then.95, %if.then.92
  %52 = load %struct.op*, %struct.op** %cont.addr, align 8
  %53 = load %struct.op*, %struct.op** %unstack, align 8
  %call97 = call %struct.op* @Perl_append_elem(i32 173, %struct.op* %52, %struct.op* %53)
  store %struct.op* %call97, %struct.op** %cont.addr, align 8
  br label %if.end.98

if.end.98:                                        ; preds = %if.end.96, %if.end.90
  %54 = load %struct.op*, %struct.op** %block.addr, align 8
  %55 = bitcast %struct.op* %54 to %struct.listop*
  %56 = load %struct.op*, %struct.op** %cont.addr, align 8
  %57 = bitcast %struct.op* %56 to %struct.listop*
  %call99 = call %struct.op* @Perl_append_list(i32 173, %struct.listop* %55, %struct.listop* %57)
  store %struct.op* %call99, %struct.op** %listop, align 8
  %58 = load %struct.op*, %struct.op** %listop, align 8
  %op_next100 = getelementptr inbounds %struct.op, %struct.op* %58, i32 0, i32 0
  %59 = load %struct.op*, %struct.op** %op_next100, align 8
  %tobool101 = icmp ne %struct.op* %59, null
  br i1 %tobool101, label %cond.true.102, label %cond.false.104

cond.true.102:                                    ; preds = %if.end.98
  %60 = load %struct.op*, %struct.op** %listop, align 8
  %op_next103 = getelementptr inbounds %struct.op, %struct.op* %60, i32 0, i32 0
  %61 = load %struct.op*, %struct.op** %op_next103, align 8
  br label %cond.end.106

cond.false.104:                                   ; preds = %if.end.98
  %62 = load %struct.op*, %struct.op** %listop, align 8
  %call105 = call %struct.op* @Perl_linklist(%struct.op* %62)
  br label %cond.end.106

cond.end.106:                                     ; preds = %cond.false.104, %cond.true.102
  %cond107 = phi %struct.op* [ %61, %cond.true.102 ], [ %call105, %cond.false.104 ]
  store %struct.op* %cond107, %struct.op** %redo, align 8
  %63 = load %struct.op*, %struct.op** %expr.addr, align 8
  %tobool108 = icmp ne %struct.op* %63, null
  br i1 %tobool108, label %if.then.109, label %if.else.186

if.then.109:                                      ; preds = %cond.end.106
  %64 = load i32, i32* %whileline.addr, align 4
  store i32 %64, i32* @PL_copline, align 4
  %65 = load %struct.op*, %struct.op** %listop, align 8
  %call110 = call %struct.op* @Perl_scalar(%struct.op* %65)
  %call111 = call %struct.op* @S_new_logop(i32 159, i32 0, %struct.op** %expr.addr, %struct.op** %listop)
  store %struct.op* %call111, %struct.op** %o, align 8
  %66 = load %struct.op*, %struct.op** %o, align 8
  %67 = load %struct.op*, %struct.op** %expr.addr, align 8
  %cmp112 = icmp eq %struct.op* %66, %67
  br i1 %cmp112, label %land.lhs.true.114, label %if.end.167

land.lhs.true.114:                                ; preds = %if.then.109
  %68 = load %struct.op*, %struct.op** %o, align 8
  %op_type115 = getelementptr inbounds %struct.op, %struct.op* %68, i32 0, i32 4
  %69 = load i16, i16* %op_type115, align 2
  %conv116 = zext i16 %69 to i32
  %cmp117 = icmp eq i32 %conv116, 5
  br i1 %cmp117, label %land.lhs.true.119, label %if.end.167

land.lhs.true.119:                                ; preds = %land.lhs.true.114
  %70 = load %struct.op*, %struct.op** %o, align 8
  %71 = bitcast %struct.op* %70 to %struct.svop*
  %op_sv = getelementptr inbounds %struct.svop, %struct.svop* %71, i32 0, i32 8
  %72 = load %struct.sv*, %struct.sv** %op_sv, align 8
  %tobool120 = icmp ne %struct.sv* %72, null
  br i1 %tobool120, label %cond.false.122, label %cond.true.121

cond.true.121:                                    ; preds = %land.lhs.true.119
  br i1 false, label %if.end.167, label %if.then.166

cond.false.122:                                   ; preds = %land.lhs.true.119
  %73 = load %struct.op*, %struct.op** %o, align 8
  %74 = bitcast %struct.op* %73 to %struct.svop*
  %op_sv123 = getelementptr inbounds %struct.svop, %struct.svop* %74, i32 0, i32 8
  %75 = load %struct.sv*, %struct.sv** %op_sv123, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %75, i32 0, i32 2
  %76 = load i32, i32* %sv_flags, align 4
  %and124 = and i32 %76, 262144
  %tobool125 = icmp ne i32 %and124, 0
  br i1 %tobool125, label %cond.true.126, label %cond.false.141

cond.true.126:                                    ; preds = %cond.false.122
  %77 = load %struct.op*, %struct.op** %o, align 8
  %78 = bitcast %struct.op* %77 to %struct.svop*
  %op_sv127 = getelementptr inbounds %struct.svop, %struct.svop* %78, i32 0, i32 8
  %79 = load %struct.sv*, %struct.sv** %op_sv127, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %79, i32 0, i32 0
  %80 = load i8*, i8** %sv_any, align 8
  %81 = bitcast i8* %80 to %struct.xpv*
  store %struct.xpv* %81, %struct.xpv** @PL_Xpv, align 8
  %tobool128 = icmp ne %struct.xpv* %81, null
  br i1 %tobool128, label %land.lhs.true.129, label %cond.false.140

land.lhs.true.129:                                ; preds = %cond.true.126
  %82 = load %struct.xpv*, %struct.xpv** @PL_Xpv, align 8
  %xpv_cur = getelementptr inbounds %struct.xpv, %struct.xpv* %82, i32 0, i32 1
  %83 = load i64, i64* %xpv_cur, align 8
  %cmp130 = icmp ugt i64 %83, 1
  br i1 %cmp130, label %cond.true.139, label %lor.lhs.false.132

lor.lhs.false.132:                                ; preds = %land.lhs.true.129
  %84 = load %struct.xpv*, %struct.xpv** @PL_Xpv, align 8
  %xpv_cur133 = getelementptr inbounds %struct.xpv, %struct.xpv* %84, i32 0, i32 1
  %85 = load i64, i64* %xpv_cur133, align 8
  %tobool134 = icmp ne i64 %85, 0
  br i1 %tobool134, label %land.lhs.true.135, label %cond.false.140

land.lhs.true.135:                                ; preds = %lor.lhs.false.132
  %86 = load %struct.xpv*, %struct.xpv** @PL_Xpv, align 8
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %86, i32 0, i32 0
  %87 = load i8*, i8** %xpv_pv, align 8
  %88 = load i8, i8* %87, align 1
  %conv136 = sext i8 %88 to i32
  %cmp137 = icmp ne i32 %conv136, 48
  br i1 %cmp137, label %cond.true.139, label %cond.false.140

cond.true.139:                                    ; preds = %land.lhs.true.135, %land.lhs.true.129
  br i1 true, label %if.end.167, label %if.then.166

cond.false.140:                                   ; preds = %land.lhs.true.135, %lor.lhs.false.132, %cond.true.126
  br i1 false, label %if.end.167, label %if.then.166

cond.false.141:                                   ; preds = %cond.false.122
  %89 = load %struct.op*, %struct.op** %o, align 8
  %90 = bitcast %struct.op* %89 to %struct.svop*
  %op_sv142 = getelementptr inbounds %struct.svop, %struct.svop* %90, i32 0, i32 8
  %91 = load %struct.sv*, %struct.sv** %op_sv142, align 8
  %sv_flags143 = getelementptr inbounds %struct.sv, %struct.sv* %91, i32 0, i32 2
  %92 = load i32, i32* %sv_flags143, align 4
  %and144 = and i32 %92, 65536
  %tobool145 = icmp ne i32 %and144, 0
  br i1 %tobool145, label %cond.true.146, label %cond.false.151

cond.true.146:                                    ; preds = %cond.false.141
  %93 = load %struct.op*, %struct.op** %o, align 8
  %94 = bitcast %struct.op* %93 to %struct.svop*
  %op_sv147 = getelementptr inbounds %struct.svop, %struct.svop* %94, i32 0, i32 8
  %95 = load %struct.sv*, %struct.sv** %op_sv147, align 8
  %sv_any148 = getelementptr inbounds %struct.sv, %struct.sv* %95, i32 0, i32 0
  %96 = load i8*, i8** %sv_any148, align 8
  %97 = bitcast i8* %96 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %97, i32 0, i32 3
  %98 = load i64, i64* %xiv_iv, align 8
  %cmp149 = icmp ne i64 %98, 0
  br i1 %cmp149, label %if.end.167, label %if.then.166

cond.false.151:                                   ; preds = %cond.false.141
  %99 = load %struct.op*, %struct.op** %o, align 8
  %100 = bitcast %struct.op* %99 to %struct.svop*
  %op_sv152 = getelementptr inbounds %struct.svop, %struct.svop* %100, i32 0, i32 8
  %101 = load %struct.sv*, %struct.sv** %op_sv152, align 8
  %sv_flags153 = getelementptr inbounds %struct.sv, %struct.sv* %101, i32 0, i32 2
  %102 = load i32, i32* %sv_flags153, align 4
  %and154 = and i32 %102, 131072
  %tobool155 = icmp ne i32 %and154, 0
  br i1 %tobool155, label %cond.true.156, label %cond.false.161

cond.true.156:                                    ; preds = %cond.false.151
  %103 = load %struct.op*, %struct.op** %o, align 8
  %104 = bitcast %struct.op* %103 to %struct.svop*
  %op_sv157 = getelementptr inbounds %struct.svop, %struct.svop* %104, i32 0, i32 8
  %105 = load %struct.sv*, %struct.sv** %op_sv157, align 8
  %sv_any158 = getelementptr inbounds %struct.sv, %struct.sv* %105, i32 0, i32 0
  %106 = load i8*, i8** %sv_any158, align 8
  %107 = bitcast i8* %106 to %struct.xpvnv*
  %xnv_nv = getelementptr inbounds %struct.xpvnv, %struct.xpvnv* %107, i32 0, i32 4
  %108 = load double, double* %xnv_nv, align 8
  %cmp159 = fcmp une double %108, 0.000000e+00
  br i1 %cmp159, label %if.end.167, label %if.then.166

cond.false.161:                                   ; preds = %cond.false.151
  %109 = load %struct.op*, %struct.op** %o, align 8
  %110 = bitcast %struct.op* %109 to %struct.svop*
  %op_sv162 = getelementptr inbounds %struct.svop, %struct.svop* %110, i32 0, i32 8
  %111 = load %struct.sv*, %struct.sv** %op_sv162, align 8
  %call163 = call signext i8 @Perl_sv_2bool(%struct.sv* %111)
  %conv164 = sext i8 %call163 to i32
  %tobool165 = icmp ne i32 %conv164, 0
  br i1 %tobool165, label %if.end.167, label %if.then.166

if.then.166:                                      ; preds = %cond.false.161, %cond.true.156, %cond.true.146, %cond.false.140, %cond.true.139, %cond.true.121
  %112 = load %struct.op*, %struct.op** %expr.addr, align 8
  call void @Perl_op_free(%struct.op* %112)
  %113 = load %struct.loop*, %struct.loop** %loop.addr, align 8
  %114 = bitcast %struct.loop* %113 to %struct.op*
  call void @Perl_op_free(%struct.op* %114)
  store %struct.op* null, %struct.op** %retval
  br label %return

if.end.167:                                       ; preds = %cond.false.161, %cond.true.156, %cond.true.146, %cond.false.140, %cond.true.139, %cond.true.121, %land.lhs.true.114, %if.then.109
  %115 = load %struct.op*, %struct.op** %listop, align 8
  %tobool168 = icmp ne %struct.op* %115, null
  br i1 %tobool168, label %if.then.169, label %if.end.185

if.then.169:                                      ; preds = %if.end.167
  %116 = load %struct.op*, %struct.op** %o, align 8
  %117 = load %struct.op*, %struct.op** %listop, align 8
  %cmp170 = icmp eq %struct.op* %116, %117
  br i1 %cmp170, label %cond.true.172, label %cond.false.173

cond.true.172:                                    ; preds = %if.then.169
  %118 = load %struct.op*, %struct.op** %redo, align 8
  br label %cond.end.182

cond.false.173:                                   ; preds = %if.then.169
  %119 = load %struct.op*, %struct.op** %o, align 8
  %op_next174 = getelementptr inbounds %struct.op, %struct.op* %119, i32 0, i32 0
  %120 = load %struct.op*, %struct.op** %op_next174, align 8
  %tobool175 = icmp ne %struct.op* %120, null
  br i1 %tobool175, label %cond.true.176, label %cond.false.178

cond.true.176:                                    ; preds = %cond.false.173
  %121 = load %struct.op*, %struct.op** %o, align 8
  %op_next177 = getelementptr inbounds %struct.op, %struct.op* %121, i32 0, i32 0
  %122 = load %struct.op*, %struct.op** %op_next177, align 8
  br label %cond.end.180

cond.false.178:                                   ; preds = %cond.false.173
  %123 = load %struct.op*, %struct.op** %o, align 8
  %call179 = call %struct.op* @Perl_linklist(%struct.op* %123)
  br label %cond.end.180

cond.end.180:                                     ; preds = %cond.false.178, %cond.true.176
  %cond181 = phi %struct.op* [ %122, %cond.true.176 ], [ %call179, %cond.false.178 ]
  br label %cond.end.182

cond.end.182:                                     ; preds = %cond.end.180, %cond.true.172
  %cond183 = phi %struct.op* [ %118, %cond.true.172 ], [ %cond181, %cond.end.180 ]
  %124 = load %struct.op*, %struct.op** %listop, align 8
  %125 = bitcast %struct.op* %124 to %struct.listop*
  %op_last = getelementptr inbounds %struct.listop, %struct.listop* %125, i32 0, i32 9
  %126 = load %struct.op*, %struct.op** %op_last, align 8
  %op_next184 = getelementptr inbounds %struct.op, %struct.op* %126, i32 0, i32 0
  store %struct.op* %cond183, %struct.op** %op_next184, align 8
  br label %if.end.185

if.end.185:                                       ; preds = %cond.end.182, %if.end.167
  br label %if.end.187

if.else.186:                                      ; preds = %cond.end.106
  %127 = load %struct.op*, %struct.op** %listop, align 8
  store %struct.op* %127, %struct.op** %o, align 8
  br label %if.end.187

if.end.187:                                       ; preds = %if.else.186, %if.end.185
  %128 = load %struct.loop*, %struct.loop** %loop.addr, align 8
  %tobool188 = icmp ne %struct.loop* %128, null
  br i1 %tobool188, label %if.end.193, label %if.then.189

if.then.189:                                      ; preds = %if.end.187
  %call190 = call i8* @Perl_safesysmalloc(i64 80)
  %129 = bitcast i8* %call190 to %struct.loop*
  store %struct.loop* %129, %struct.loop** %loop.addr, align 8
  %130 = load %struct.loop*, %struct.loop** %loop.addr, align 8
  %131 = bitcast %struct.loop* %130 to i8*
  call void @llvm.memset.p0i8.i64(i8* %131, i8 0, i64 80, i32 1, i1 false)
  %132 = load %struct.loop*, %struct.loop** %loop.addr, align 8
  %op_type191 = getelementptr inbounds %struct.loop, %struct.loop* %132, i32 0, i32 4
  store i16 182, i16* %op_type191, align 2
  %133 = load %struct.op* ()*, %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 182), align 8
  %134 = load %struct.loop*, %struct.loop** %loop.addr, align 8
  %op_ppaddr = getelementptr inbounds %struct.loop, %struct.loop* %134, i32 0, i32 2
  store %struct.op* ()* %133, %struct.op* ()** %op_ppaddr, align 8
  %135 = load %struct.loop*, %struct.loop** %loop.addr, align 8
  %op_private = getelementptr inbounds %struct.loop, %struct.loop* %135, i32 0, i32 7
  store i8 0, i8* %op_private, align 1
  %136 = load %struct.loop*, %struct.loop** %loop.addr, align 8
  %137 = bitcast %struct.loop* %136 to %struct.op*
  %138 = load %struct.loop*, %struct.loop** %loop.addr, align 8
  %op_next192 = getelementptr inbounds %struct.loop, %struct.loop* %138, i32 0, i32 0
  store %struct.op* %137, %struct.op** %op_next192, align 8
  br label %if.end.193

if.end.193:                                       ; preds = %if.then.189, %if.end.187
  %139 = load %struct.loop*, %struct.loop** %loop.addr, align 8
  %140 = bitcast %struct.loop* %139 to %struct.op*
  %141 = load %struct.op*, %struct.op** %o, align 8
  %call194 = call %struct.op* @Perl_newBINOP(i32 183, i32 0, %struct.op* %140, %struct.op* %141)
  store %struct.op* %call194, %struct.op** %o, align 8
  %142 = load %struct.op*, %struct.op** %redo, align 8
  %143 = load %struct.loop*, %struct.loop** %loop.addr, align 8
  %op_redoop = getelementptr inbounds %struct.loop, %struct.loop* %143, i32 0, i32 10
  store %struct.op* %142, %struct.op** %op_redoop, align 8
  %144 = load %struct.op*, %struct.op** %o, align 8
  %145 = load %struct.loop*, %struct.loop** %loop.addr, align 8
  %op_lastop = getelementptr inbounds %struct.loop, %struct.loop* %145, i32 0, i32 12
  store %struct.op* %144, %struct.op** %op_lastop, align 8
  %146 = load i8, i8* %loopflags, align 1
  %conv195 = zext i8 %146 to i32
  %147 = load %struct.op*, %struct.op** %o, align 8
  %op_private196 = getelementptr inbounds %struct.op, %struct.op* %147, i32 0, i32 7
  %148 = load i8, i8* %op_private196, align 1
  %conv197 = zext i8 %148 to i32
  %or = or i32 %conv197, %conv195
  %conv198 = trunc i32 %or to i8
  store i8 %conv198, i8* %op_private196, align 1
  %149 = load %struct.op*, %struct.op** %next, align 8
  %tobool199 = icmp ne %struct.op* %149, null
  br i1 %tobool199, label %if.then.200, label %if.else.201

if.then.200:                                      ; preds = %if.end.193
  %150 = load %struct.op*, %struct.op** %next, align 8
  %151 = load %struct.loop*, %struct.loop** %loop.addr, align 8
  %op_nextop = getelementptr inbounds %struct.loop, %struct.loop* %151, i32 0, i32 11
  store %struct.op* %150, %struct.op** %op_nextop, align 8
  br label %if.end.203

if.else.201:                                      ; preds = %if.end.193
  %152 = load %struct.op*, %struct.op** %o, align 8
  %153 = load %struct.loop*, %struct.loop** %loop.addr, align 8
  %op_nextop202 = getelementptr inbounds %struct.loop, %struct.loop* %153, i32 0, i32 11
  store %struct.op* %152, %struct.op** %op_nextop202, align 8
  br label %if.end.203

if.end.203:                                       ; preds = %if.else.201, %if.then.200
  %154 = load i32, i32* %flags.addr, align 4
  %155 = load %struct.op*, %struct.op** %o, align 8
  %op_flags204 = getelementptr inbounds %struct.op, %struct.op* %155, i32 0, i32 6
  %156 = load i8, i8* %op_flags204, align 1
  %conv205 = zext i8 %156 to i32
  %or206 = or i32 %conv205, %154
  %conv207 = trunc i32 %or206 to i8
  store i8 %conv207, i8* %op_flags204, align 1
  %157 = load i32, i32* %flags.addr, align 4
  %shr = ashr i32 %157, 8
  %158 = load %struct.op*, %struct.op** %o, align 8
  %op_private208 = getelementptr inbounds %struct.op, %struct.op* %158, i32 0, i32 7
  %159 = load i8, i8* %op_private208, align 1
  %conv209 = zext i8 %159 to i32
  %or210 = or i32 %conv209, %shr
  %conv211 = trunc i32 %or210 to i8
  store i8 %conv211, i8* %op_private208, align 1
  %160 = load %struct.op*, %struct.op** %o, align 8
  store %struct.op* %160, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.203, %if.then.166
  %161 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %161
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newFOROP(i32 %flags, i8* %label, i32 %forline, %struct.op* %sv, %struct.op* %expr, %struct.op* %block, %struct.op* %cont) #0 {
entry:
  %flags.addr = alloca i32, align 4
  %label.addr = alloca i8*, align 8
  %forline.addr = alloca i32, align 4
  %sv.addr = alloca %struct.op*, align 8
  %expr.addr = alloca %struct.op*, align 8
  %block.addr = alloca %struct.op*, align 8
  %cont.addr = alloca %struct.op*, align 8
  %loop = alloca %struct.loop*, align 8
  %wop = alloca %struct.op*, align 8
  %padoff = alloca i64, align 8
  %iterflags = alloca i32, align 4
  %iterpflags = alloca i32, align 4
  %flip = alloca %struct.unop*, align 8
  %range = alloca %struct.logop*, align 8
  %left = alloca %struct.op*, align 8
  %right = alloca %struct.op*, align 8
  %listop = alloca %struct.listop*, align 8
  store i32 %flags, i32* %flags.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  store i32 %forline, i32* %forline.addr, align 4
  store %struct.op* %sv, %struct.op** %sv.addr, align 8
  store %struct.op* %expr, %struct.op** %expr.addr, align 8
  store %struct.op* %block, %struct.op** %block.addr, align 8
  store %struct.op* %cont, %struct.op** %cont.addr, align 8
  store i64 0, i64* %padoff, align 8
  store i32 0, i32* %iterflags, align 4
  store i32 0, i32* %iterpflags, align 4
  %0 = load %struct.op*, %struct.op** %sv.addr, align 8
  %tobool = icmp ne %struct.op* %0, null
  br i1 %tobool, label %if.then, label %if.else.26

if.then:                                          ; preds = %entry
  %1 = load %struct.op*, %struct.op** %sv.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 4
  %2 = load i16, i16* %op_type, align 2
  %conv = zext i16 %2 to i32
  %cmp = icmp eq i32 %conv, 15
  br i1 %cmp, label %if.then.2, label %if.else

if.then.2:                                        ; preds = %if.then
  %3 = load %struct.op*, %struct.op** %sv.addr, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %3, i32 0, i32 7
  %4 = load i8, i8* %op_private, align 1
  %conv3 = zext i8 %4 to i32
  %and = and i32 %conv3, 16
  store i32 %and, i32* %iterpflags, align 4
  %5 = load %struct.op*, %struct.op** %sv.addr, align 8
  %op_type4 = getelementptr inbounds %struct.op, %struct.op* %5, i32 0, i32 4
  store i16 14, i16* %op_type4, align 2
  %6 = load %struct.op* ()*, %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 14), align 8
  %7 = load %struct.op*, %struct.op** %sv.addr, align 8
  %op_ppaddr = getelementptr inbounds %struct.op, %struct.op* %7, i32 0, i32 2
  store %struct.op* ()* %6, %struct.op* ()** %op_ppaddr, align 8
  br label %if.end.25

if.else:                                          ; preds = %if.then
  %8 = load %struct.op*, %struct.op** %sv.addr, align 8
  %op_type5 = getelementptr inbounds %struct.op, %struct.op* %8, i32 0, i32 4
  %9 = load i16, i16* %op_type5, align 2
  %conv6 = zext i16 %9 to i32
  %cmp7 = icmp eq i32 %conv6, 9
  br i1 %cmp7, label %if.then.9, label %if.else.14

if.then.9:                                        ; preds = %if.else
  %10 = load %struct.op*, %struct.op** %sv.addr, align 8
  %op_private10 = getelementptr inbounds %struct.op, %struct.op* %10, i32 0, i32 7
  %11 = load i8, i8* %op_private10, align 1
  %conv11 = zext i8 %11 to i32
  %and12 = and i32 %conv11, 128
  store i32 %and12, i32* %iterpflags, align 4
  %12 = load %struct.op*, %struct.op** %sv.addr, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %12, i32 0, i32 3
  %13 = load i64, i64* %op_targ, align 8
  store i64 %13, i64* %padoff, align 8
  %14 = load %struct.op*, %struct.op** %sv.addr, align 8
  %op_targ13 = getelementptr inbounds %struct.op, %struct.op* %14, i32 0, i32 3
  store i64 0, i64* %op_targ13, align 8
  %15 = load %struct.op*, %struct.op** %sv.addr, align 8
  call void @Perl_op_free(%struct.op* %15)
  store %struct.op* null, %struct.op** %sv.addr, align 8
  br label %if.end.24

if.else.14:                                       ; preds = %if.else
  %16 = load %struct.op*, %struct.op** %sv.addr, align 8
  %op_type15 = getelementptr inbounds %struct.op, %struct.op* %16, i32 0, i32 4
  %17 = load i16, i16* %op_type15, align 2
  %conv16 = zext i16 %17 to i32
  %cmp17 = icmp eq i32 %conv16, 348
  br i1 %cmp17, label %if.then.19, label %if.else.22

if.then.19:                                       ; preds = %if.else.14
  %18 = load %struct.op*, %struct.op** %sv.addr, align 8
  %op_targ20 = getelementptr inbounds %struct.op, %struct.op* %18, i32 0, i32 3
  %19 = load i64, i64* %op_targ20, align 8
  store i64 %19, i64* %padoff, align 8
  %20 = load %struct.op*, %struct.op** %sv.addr, align 8
  %op_targ21 = getelementptr inbounds %struct.op, %struct.op* %20, i32 0, i32 3
  store i64 0, i64* %op_targ21, align 8
  %21 = load i32, i32* %iterflags, align 4
  %or = or i32 %21, 128
  store i32 %or, i32* %iterflags, align 4
  %22 = load %struct.op*, %struct.op** %sv.addr, align 8
  call void @Perl_op_free(%struct.op* %22)
  store %struct.op* null, %struct.op** %sv.addr, align 8
  br label %if.end

if.else.22:                                       ; preds = %if.else.14
  %23 = load %struct.op*, %struct.op** %sv.addr, align 8
  %op_type23 = getelementptr inbounds %struct.op, %struct.op* %23, i32 0, i32 4
  %24 = load i16, i16* %op_type23, align 2
  %idxprom = zext i16 %24 to i64
  %arrayidx = getelementptr inbounds [0 x i8*], [0 x i8*]* @PL_op_desc, i32 0, i64 %idxprom
  %25 = load i8*, i8** %arrayidx, align 8
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.54, i32 0, i32 0), i8* %25)
  br label %if.end

if.end:                                           ; preds = %if.else.22, %if.then.19
  br label %if.end.24

if.end.24:                                        ; preds = %if.end, %if.then.9
  br label %if.end.25

if.end.25:                                        ; preds = %if.end.24, %if.then.2
  br label %if.end.27

if.else.26:                                       ; preds = %entry
  %26 = load %struct.gv*, %struct.gv** @PL_defgv, align 8
  %call = call %struct.op* @Perl_newGVOP(i32 7, i32 0, %struct.gv* %26)
  store %struct.op* %call, %struct.op** %sv.addr, align 8
  br label %if.end.27

if.end.27:                                        ; preds = %if.else.26, %if.end.25
  %27 = load %struct.op*, %struct.op** %expr.addr, align 8
  %op_type28 = getelementptr inbounds %struct.op, %struct.op* %27, i32 0, i32 4
  %28 = load i16, i16* %op_type28, align 2
  %conv29 = zext i16 %28 to i32
  %cmp30 = icmp eq i32 %conv29, 125
  br i1 %cmp30, label %if.then.36, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end.27
  %29 = load %struct.op*, %struct.op** %expr.addr, align 8
  %op_type32 = getelementptr inbounds %struct.op, %struct.op* %29, i32 0, i32 4
  %30 = load i16, i16* %op_type32, align 2
  %conv33 = zext i16 %30 to i32
  %cmp34 = icmp eq i32 %conv33, 10
  br i1 %cmp34, label %if.then.36, label %if.else.42

if.then.36:                                       ; preds = %lor.lhs.false, %if.end.27
  %31 = load %struct.op*, %struct.op** %expr.addr, align 8
  %call37 = call %struct.op* @Perl_ref(%struct.op* %31, i32 181)
  %call38 = call %struct.op* @Perl_scalar(%struct.op* %call37)
  %call39 = call %struct.op* @Perl_force_list(%struct.op* %call38)
  %call40 = call %struct.op* @Perl_mod(%struct.op* %call39, i32 152)
  store %struct.op* %call40, %struct.op** %expr.addr, align 8
  %32 = load i32, i32* %iterflags, align 4
  %or41 = or i32 %32, 64
  store i32 %or41, i32* %iterflags, align 4
  br label %if.end.77

if.else.42:                                       ; preds = %lor.lhs.false
  %33 = load %struct.op*, %struct.op** %expr.addr, align 8
  %op_type43 = getelementptr inbounds %struct.op, %struct.op* %33, i32 0, i32 4
  %34 = load i16, i16* %op_type43, align 2
  %conv44 = zext i16 %34 to i32
  %cmp45 = icmp eq i32 %conv44, 0
  br i1 %cmp45, label %land.lhs.true, label %if.else.73

land.lhs.true:                                    ; preds = %if.else.42
  %35 = load %struct.op*, %struct.op** %expr.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %35, i32 0, i32 6
  %36 = load i8, i8* %op_flags, align 1
  %conv47 = zext i8 %36 to i32
  %and48 = and i32 %conv47, 4
  %tobool49 = icmp ne i32 %and48, 0
  br i1 %tobool49, label %land.lhs.true.50, label %if.else.73

land.lhs.true.50:                                 ; preds = %land.lhs.true
  %37 = load %struct.op*, %struct.op** %expr.addr, align 8
  %38 = bitcast %struct.op* %37 to %struct.binop*
  %op_first = getelementptr inbounds %struct.binop, %struct.binop* %38, i32 0, i32 8
  %39 = load %struct.op*, %struct.op** %op_first, align 8
  %op_type51 = getelementptr inbounds %struct.op, %struct.op* %39, i32 0, i32 4
  %40 = load i16, i16* %op_type51, align 2
  %conv52 = zext i16 %40 to i32
  %cmp53 = icmp eq i32 %conv52, 158
  br i1 %cmp53, label %if.then.55, label %if.else.73

if.then.55:                                       ; preds = %land.lhs.true.50
  %41 = load %struct.op*, %struct.op** %expr.addr, align 8
  %42 = bitcast %struct.op* %41 to %struct.binop*
  %op_first56 = getelementptr inbounds %struct.binop, %struct.binop* %42, i32 0, i32 8
  %43 = load %struct.op*, %struct.op** %op_first56, align 8
  %44 = bitcast %struct.op* %43 to %struct.unop*
  %op_first57 = getelementptr inbounds %struct.unop, %struct.unop* %44, i32 0, i32 8
  %45 = load %struct.op*, %struct.op** %op_first57, align 8
  %46 = bitcast %struct.op* %45 to %struct.unop*
  store %struct.unop* %46, %struct.unop** %flip, align 8
  %47 = load %struct.unop*, %struct.unop** %flip, align 8
  %op_first58 = getelementptr inbounds %struct.unop, %struct.unop* %47, i32 0, i32 8
  %48 = load %struct.op*, %struct.op** %op_first58, align 8
  %49 = bitcast %struct.op* %48 to %struct.logop*
  store %struct.logop* %49, %struct.logop** %range, align 8
  %50 = load %struct.logop*, %struct.logop** %range, align 8
  %op_first59 = getelementptr inbounds %struct.logop, %struct.logop* %50, i32 0, i32 8
  %51 = load %struct.op*, %struct.op** %op_first59, align 8
  store %struct.op* %51, %struct.op** %left, align 8
  %52 = load %struct.op*, %struct.op** %left, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %52, i32 0, i32 1
  %53 = load %struct.op*, %struct.op** %op_sibling, align 8
  store %struct.op* %53, %struct.op** %right, align 8
  %54 = load %struct.logop*, %struct.logop** %range, align 8
  %op_flags60 = getelementptr inbounds %struct.logop, %struct.logop* %54, i32 0, i32 6
  %55 = load i8, i8* %op_flags60, align 1
  %conv61 = zext i8 %55 to i32
  %and62 = and i32 %conv61, -5
  %conv63 = trunc i32 %and62 to i8
  store i8 %conv63, i8* %op_flags60, align 1
  %56 = load %struct.logop*, %struct.logop** %range, align 8
  %op_first64 = getelementptr inbounds %struct.logop, %struct.logop* %56, i32 0, i32 8
  store %struct.op* null, %struct.op** %op_first64, align 8
  %57 = load %struct.op*, %struct.op** %left, align 8
  %58 = load %struct.op*, %struct.op** %right, align 8
  %call65 = call %struct.op* @Perl_newLISTOP(i32 141, i32 0, %struct.op* %57, %struct.op* %58)
  %59 = bitcast %struct.op* %call65 to %struct.listop*
  store %struct.listop* %59, %struct.listop** %listop, align 8
  %60 = load %struct.logop*, %struct.logop** %range, align 8
  %op_next = getelementptr inbounds %struct.logop, %struct.logop* %60, i32 0, i32 0
  %61 = load %struct.op*, %struct.op** %op_next, align 8
  %62 = load %struct.listop*, %struct.listop** %listop, align 8
  %op_first66 = getelementptr inbounds %struct.listop, %struct.listop* %62, i32 0, i32 8
  %63 = load %struct.op*, %struct.op** %op_first66, align 8
  %op_next67 = getelementptr inbounds %struct.op, %struct.op* %63, i32 0, i32 0
  store %struct.op* %61, %struct.op** %op_next67, align 8
  %64 = load %struct.logop*, %struct.logop** %range, align 8
  %op_other = getelementptr inbounds %struct.logop, %struct.logop* %64, i32 0, i32 9
  %65 = load %struct.op*, %struct.op** %op_other, align 8
  %66 = load %struct.op*, %struct.op** %left, align 8
  %op_next68 = getelementptr inbounds %struct.op, %struct.op* %66, i32 0, i32 0
  store %struct.op* %65, %struct.op** %op_next68, align 8
  %67 = load %struct.listop*, %struct.listop** %listop, align 8
  %68 = bitcast %struct.listop* %67 to %struct.op*
  %69 = load %struct.op*, %struct.op** %right, align 8
  %op_next69 = getelementptr inbounds %struct.op, %struct.op* %69, i32 0, i32 0
  store %struct.op* %68, %struct.op** %op_next69, align 8
  %70 = load %struct.listop*, %struct.listop** %listop, align 8
  %op_first70 = getelementptr inbounds %struct.listop, %struct.listop* %70, i32 0, i32 8
  %71 = load %struct.op*, %struct.op** %op_first70, align 8
  %72 = load %struct.listop*, %struct.listop** %listop, align 8
  %op_next71 = getelementptr inbounds %struct.listop, %struct.listop* %72, i32 0, i32 0
  store %struct.op* %71, %struct.op** %op_next71, align 8
  %73 = load %struct.op*, %struct.op** %expr.addr, align 8
  call void @Perl_op_free(%struct.op* %73)
  %74 = load %struct.listop*, %struct.listop** %listop, align 8
  %75 = bitcast %struct.listop* %74 to %struct.op*
  store %struct.op* %75, %struct.op** %expr.addr, align 8
  %76 = load %struct.op*, %struct.op** %expr.addr, align 8
  call void @Perl_op_null(%struct.op* %76)
  %77 = load i32, i32* %iterflags, align 4
  %or72 = or i32 %77, 64
  store i32 %or72, i32* %iterflags, align 4
  br label %if.end.76

if.else.73:                                       ; preds = %land.lhs.true.50, %land.lhs.true, %if.else.42
  %78 = load %struct.op*, %struct.op** %expr.addr, align 8
  %call74 = call %struct.op* @Perl_force_list(%struct.op* %78)
  %call75 = call %struct.op* @Perl_mod(%struct.op* %call74, i32 152)
  store %struct.op* %call75, %struct.op** %expr.addr, align 8
  br label %if.end.76

if.end.76:                                        ; preds = %if.else.73, %if.then.55
  br label %if.end.77

if.end.77:                                        ; preds = %if.end.76, %if.then.36
  %79 = load i32, i32* %iterflags, align 4
  %80 = load %struct.op*, %struct.op** %expr.addr, align 8
  %81 = load %struct.op*, %struct.op** %sv.addr, align 8
  %call78 = call %struct.op* @Perl_scalar(%struct.op* %81)
  %call79 = call %struct.op* @Perl_append_elem(i32 141, %struct.op* %80, %struct.op* %call78)
  %call80 = call %struct.op* @Perl_convert(i32 180, i32 %79, %struct.op* %call79)
  %call81 = call %struct.op* @Perl_list(%struct.op* %call80)
  %82 = bitcast %struct.op* %call81 to %struct.loop*
  store %struct.loop* %82, %struct.loop** %loop, align 8
  %83 = load i32, i32* %iterpflags, align 4
  %conv82 = trunc i32 %83 to i8
  %84 = load %struct.loop*, %struct.loop** %loop, align 8
  %op_private83 = getelementptr inbounds %struct.loop, %struct.loop* %84, i32 0, i32 7
  store i8 %conv82, i8* %op_private83, align 1
  %85 = load %struct.loop*, %struct.loop** %loop, align 8
  %86 = bitcast %struct.loop* %85 to i8*
  %call84 = call i8* @Perl_safesysrealloc(i8* %86, i64 80)
  %87 = bitcast i8* %call84 to %struct.loop*
  store %struct.loop* %87, %struct.loop** %loop, align 8
  %88 = load i64, i64* %padoff, align 8
  %89 = load %struct.loop*, %struct.loop** %loop, align 8
  %op_targ85 = getelementptr inbounds %struct.loop, %struct.loop* %89, i32 0, i32 3
  store i64 %88, i64* %op_targ85, align 8
  %90 = load i32, i32* %flags.addr, align 4
  %91 = load %struct.loop*, %struct.loop** %loop, align 8
  %92 = load i32, i32* %forline.addr, align 4
  %call86 = call %struct.op* @Perl_newOP(i32 181, i32 0)
  %93 = load %struct.op*, %struct.op** %block.addr, align 8
  %94 = load %struct.op*, %struct.op** %cont.addr, align 8
  %call87 = call %struct.op* @Perl_newWHILEOP(i32 %90, i32 1, %struct.loop* %91, i32 %92, %struct.op* %call86, %struct.op* %93, %struct.op* %94)
  store %struct.op* %call87, %struct.op** %wop, align 8
  %95 = load i32, i32* %forline.addr, align 4
  store i32 %95, i32* @PL_copline, align 4
  %96 = load i8*, i8** %label.addr, align 8
  %97 = load %struct.op*, %struct.op** %wop, align 8
  %call88 = call %struct.op* @Perl_newSTATEOP(i32 0, i8* %96, %struct.op* %97)
  ret %struct.op* %call88
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newLOOPEX(i32 %type, %struct.op* %label) #0 {
entry:
  %type.addr = alloca i32, align 4
  %label.addr = alloca %struct.op*, align 8
  %o = alloca %struct.op*, align 8
  %n_a = alloca i64, align 8
  store i32 %type, i32* %type.addr, align 4
  store %struct.op* %label, %struct.op** %label.addr, align 8
  %0 = load i32, i32* %type.addr, align 4
  %cmp = icmp ne i32 %0, 189
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load %struct.op*, %struct.op** %label.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 4
  %2 = load i16, i16* %op_type, align 2
  %conv = zext i16 %2 to i32
  %cmp1 = icmp eq i32 %conv, 5
  br i1 %cmp1, label %if.then, label %if.else.24

if.then:                                          ; preds = %lor.lhs.false, %entry
  %3 = load %struct.op*, %struct.op** %label.addr, align 8
  %op_type3 = getelementptr inbounds %struct.op, %struct.op* %3, i32 0, i32 4
  %4 = load i16, i16* %op_type3, align 2
  %conv4 = zext i16 %4 to i32
  %cmp5 = icmp eq i32 %conv4, 1
  br i1 %cmp5, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.then
  %5 = load %struct.op*, %struct.op** %label.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %5, i32 0, i32 6
  %6 = load i8, i8* %op_flags, align 1
  %conv7 = zext i8 %6 to i32
  %and = and i32 %conv7, 8
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then.8, label %if.else

if.then.8:                                        ; preds = %land.lhs.true
  %7 = load i32, i32* %type.addr, align 4
  %call = call %struct.op* @Perl_newOP(i32 %7, i32 128)
  store %struct.op* %call, %struct.op** %o, align 8
  br label %if.end

if.else:                                          ; preds = %land.lhs.true, %if.then
  %8 = load i32, i32* %type.addr, align 4
  %9 = load %struct.op*, %struct.op** %label.addr, align 8
  %op_type9 = getelementptr inbounds %struct.op, %struct.op* %9, i32 0, i32 4
  %10 = load i16, i16* %op_type9, align 2
  %conv10 = zext i16 %10 to i32
  %cmp11 = icmp eq i32 %conv10, 5
  br i1 %cmp11, label %cond.true, label %cond.false.19

cond.true:                                        ; preds = %if.else
  %11 = load %struct.op*, %struct.op** %label.addr, align 8
  %12 = bitcast %struct.op* %11 to %struct.svop*
  %op_sv = getelementptr inbounds %struct.svop, %struct.svop* %12, i32 0, i32 8
  %13 = load %struct.sv*, %struct.sv** %op_sv, align 8
  store %struct.sv* %13, %struct.sv** @PL_Sv, align 8
  %14 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %14, i32 0, i32 2
  %15 = load i32, i32* %sv_flags, align 4
  %and13 = and i32 %15, 262144
  %cmp14 = icmp eq i32 %and13, 262144
  br i1 %cmp14, label %cond.true.16, label %cond.false

cond.true.16:                                     ; preds = %cond.true
  %16 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %16, i32 0, i32 0
  %17 = load i8*, i8** %sv_any, align 8
  %18 = bitcast i8* %17 to %struct.xpv*
  %xpv_cur = getelementptr inbounds %struct.xpv, %struct.xpv* %18, i32 0, i32 1
  %19 = load i64, i64* %xpv_cur, align 8
  store i64 %19, i64* %n_a, align 8
  %20 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any17 = getelementptr inbounds %struct.sv, %struct.sv* %20, i32 0, i32 0
  %21 = load i8*, i8** %sv_any17, align 8
  %22 = bitcast i8* %21 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %22, i32 0, i32 0
  %23 = load i8*, i8** %xpv_pv, align 8
  br label %cond.end

cond.false:                                       ; preds = %cond.true
  %24 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call18 = call i8* @Perl_sv_2pv_flags(%struct.sv* %24, i64* %n_a, i32 2)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true.16
  %cond = phi i8* [ %23, %cond.true.16 ], [ %call18, %cond.false ]
  br label %cond.end.20

cond.false.19:                                    ; preds = %if.else
  br label %cond.end.20

cond.end.20:                                      ; preds = %cond.false.19, %cond.end
  %cond21 = phi i8* [ %cond, %cond.end ], [ getelementptr inbounds ([1 x i8], [1 x i8]* @.str.35, i32 0, i32 0), %cond.false.19 ]
  %call22 = call i8* @Perl_savepv(i8* %cond21)
  %call23 = call %struct.op* @Perl_newPVOP(i32 %8, i32 0, i8* %call22)
  store %struct.op* %call23, %struct.op** %o, align 8
  br label %if.end

if.end:                                           ; preds = %cond.end.20, %if.then.8
  %25 = load %struct.op*, %struct.op** %label.addr, align 8
  call void @Perl_op_free(%struct.op* %25)
  br label %if.end.39

if.else.24:                                       ; preds = %lor.lhs.false
  %26 = load %struct.op*, %struct.op** %label.addr, align 8
  %op_type25 = getelementptr inbounds %struct.op, %struct.op* %26, i32 0, i32 4
  %27 = load i16, i16* %op_type25, align 2
  %conv26 = zext i16 %27 to i32
  %cmp27 = icmp eq i32 %conv26, 166
  br i1 %cmp27, label %land.lhs.true.29, label %if.end.37

land.lhs.true.29:                                 ; preds = %if.else.24
  %28 = load %struct.op*, %struct.op** %label.addr, align 8
  %op_flags30 = getelementptr inbounds %struct.op, %struct.op* %28, i32 0, i32 6
  %29 = load i8, i8* %op_flags30, align 1
  %conv31 = zext i8 %29 to i32
  %and32 = and i32 %conv31, 64
  %tobool33 = icmp ne i32 %and32, 0
  br i1 %tobool33, label %if.end.37, label %if.then.34

if.then.34:                                       ; preds = %land.lhs.true.29
  %30 = load %struct.op*, %struct.op** %label.addr, align 8
  %call35 = call %struct.op* @Perl_mod(%struct.op* %30, i32 20)
  %call36 = call %struct.op* @Perl_newUNOP(i32 20, i32 0, %struct.op* %call35)
  store %struct.op* %call36, %struct.op** %label.addr, align 8
  br label %if.end.37

if.end.37:                                        ; preds = %if.then.34, %land.lhs.true.29, %if.else.24
  %31 = load i32, i32* %type.addr, align 4
  %32 = load %struct.op*, %struct.op** %label.addr, align 8
  %call38 = call %struct.op* @Perl_newUNOP(i32 %31, i32 64, %struct.op* %32)
  store %struct.op* %call38, %struct.op** %o, align 8
  br label %if.end.39

if.end.39:                                        ; preds = %if.end.37, %if.end
  %33 = load i32, i32* @PL_hints, align 4
  %or = or i32 %33, 256
  store i32 %or, i32* @PL_hints, align 4
  %34 = load %struct.op*, %struct.op** %o, align 8
  ret %struct.op* %34
}

declare i8* @Perl_savepv(i8*) #1

; Function Attrs: nounwind uwtable
define void @Perl_cv_undef(%struct.cv* %cv) #0 {
entry:
  %cv.addr = alloca %struct.cv*, align 8
  %tmp = alloca i32, align 4
  store %struct.cv* %cv, %struct.cv** %cv.addr, align 8
  %0 = load %struct.cv*, %struct.cv** %cv.addr, align 8
  %sv_any = getelementptr inbounds %struct.cv, %struct.cv* %0, i32 0, i32 0
  %1 = load %struct.xpvcv*, %struct.xpvcv** %sv_any, align 8
  %xcv_xsub = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %1, i32 0, i32 10
  %2 = load void (%struct.cv*)*, void (%struct.cv*)** %xcv_xsub, align 8
  %tobool = icmp ne void (%struct.cv*)* %2, null
  br i1 %tobool, label %if.end.15, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %3 = load %struct.cv*, %struct.cv** %cv.addr, align 8
  %sv_any1 = getelementptr inbounds %struct.cv, %struct.cv* %3, i32 0, i32 0
  %4 = load %struct.xpvcv*, %struct.xpvcv** %sv_any1, align 8
  %xcv_root = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %4, i32 0, i32 9
  %5 = load %struct.op*, %struct.op** %xcv_root, align 8
  %tobool2 = icmp ne %struct.op* %5, null
  br i1 %tobool2, label %if.then, label %if.end.15

if.then:                                          ; preds = %land.lhs.true
  %6 = load %struct.cv*, %struct.cv** %cv.addr, align 8
  %sv_any3 = getelementptr inbounds %struct.cv, %struct.cv* %6, i32 0, i32 0
  %7 = load %struct.xpvcv*, %struct.xpvcv** %sv_any3, align 8
  %xcv_depth = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %7, i32 0, i32 14
  %8 = load i64, i64* %xcv_depth, align 8
  %tobool4 = icmp ne i64 %8, 0
  br i1 %tobool4, label %if.then.5, label %if.end

if.then.5:                                        ; preds = %if.then
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.55, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then.5, %if.then
  call void @Perl_push_scope()
  %9 = load i32, i32* @PL_savestack_ix, align 4
  %add = add nsw i32 %9, 2
  %10 = load i32, i32* @PL_savestack_max, align 4
  %cmp = icmp sgt i32 %add, %10
  br i1 %cmp, label %if.then.6, label %if.end.7

if.then.6:                                        ; preds = %if.end
  call void @Perl_savestack_grow()
  br label %if.end.7

if.end.7:                                         ; preds = %if.then.6, %if.end
  %11 = load %struct.av*, %struct.av** @PL_comppad, align 8
  %12 = bitcast %struct.av* %11 to %struct.sv*
  %13 = bitcast %struct.sv* %12 to i8*
  %14 = load i32, i32* @PL_savestack_ix, align 4
  %inc = add nsw i32 %14, 1
  store i32 %inc, i32* @PL_savestack_ix, align 4
  %idxprom = sext i32 %14 to i64
  %15 = load %union.any*, %union.any** @PL_savestack, align 8
  %arrayidx = getelementptr inbounds %union.any, %union.any* %15, i64 %idxprom
  %any_ptr = bitcast %union.any* %arrayidx to i8**
  store i8* %13, i8** %any_ptr, align 8
  %16 = load i32, i32* @PL_savestack_ix, align 4
  %inc8 = add nsw i32 %16, 1
  store i32 %inc8, i32* @PL_savestack_ix, align 4
  %idxprom9 = sext i32 %16 to i64
  %17 = load %union.any*, %union.any** @PL_savestack, align 8
  %arrayidx10 = getelementptr inbounds %union.any, %union.any* %17, i64 %idxprom9
  %any_i32 = bitcast %union.any* %arrayidx10 to i32*
  store i32 33, i32* %any_i32, align 4
  store i32 33, i32* %tmp
  %18 = load i32, i32* %tmp
  store %struct.av* null, %struct.av** @PL_comppad, align 8
  store %struct.sv** null, %struct.sv*** @PL_curpad, align 8
  %19 = load %struct.cv*, %struct.cv** %cv.addr, align 8
  %sv_any11 = getelementptr inbounds %struct.cv, %struct.cv* %19, i32 0, i32 0
  %20 = load %struct.xpvcv*, %struct.xpvcv** %sv_any11, align 8
  %xcv_root12 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %20, i32 0, i32 9
  %21 = load %struct.op*, %struct.op** %xcv_root12, align 8
  call void @Perl_op_free(%struct.op* %21)
  %22 = load %struct.cv*, %struct.cv** %cv.addr, align 8
  %sv_any13 = getelementptr inbounds %struct.cv, %struct.cv* %22, i32 0, i32 0
  %23 = load %struct.xpvcv*, %struct.xpvcv** %sv_any13, align 8
  %xcv_root14 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %23, i32 0, i32 9
  store %struct.op* null, %struct.op** %xcv_root14, align 8
  call void @Perl_pop_scope()
  br label %if.end.15

if.end.15:                                        ; preds = %if.end.7, %land.lhs.true, %entry
  %24 = load %struct.cv*, %struct.cv** %cv.addr, align 8
  %25 = bitcast %struct.cv* %24 to %struct.sv*
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %25, i32 0, i32 2
  %26 = load i32, i32* %sv_flags, align 4
  %and = and i32 %26, -67371009
  store i32 %and, i32* %sv_flags, align 4
  %27 = load %struct.cv*, %struct.cv** %cv.addr, align 8
  %sv_any16 = getelementptr inbounds %struct.cv, %struct.cv* %27, i32 0, i32 0
  %28 = load %struct.xpvcv*, %struct.xpvcv** %sv_any16, align 8
  %xcv_gv = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %28, i32 0, i32 12
  store %struct.gv* null, %struct.gv** %xcv_gv, align 8
  %29 = load %struct.cv*, %struct.cv** %cv.addr, align 8
  call void @Perl_pad_undef(%struct.cv* %29)
  %30 = load %struct.cv*, %struct.cv** %cv.addr, align 8
  %sv_refcnt = getelementptr inbounds %struct.cv, %struct.cv* %30, i32 0, i32 1
  %31 = load i32, i32* %sv_refcnt, align 4
  %tobool17 = icmp ne i32 %31, 0
  br i1 %tobool17, label %if.end.31, label %land.lhs.true.18

land.lhs.true.18:                                 ; preds = %if.end.15
  %32 = load %struct.cv*, %struct.cv** %cv.addr, align 8
  %sv_any19 = getelementptr inbounds %struct.cv, %struct.cv* %32, i32 0, i32 0
  %33 = load %struct.xpvcv*, %struct.xpvcv** %sv_any19, align 8
  %xcv_outside = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %33, i32 0, i32 16
  %34 = load %struct.cv*, %struct.cv** %xcv_outside, align 8
  %tobool20 = icmp ne %struct.cv* %34, null
  br i1 %tobool20, label %if.then.21, label %if.end.31

if.then.21:                                       ; preds = %land.lhs.true.18
  %35 = load %struct.cv*, %struct.cv** %cv.addr, align 8
  %sv_any22 = getelementptr inbounds %struct.cv, %struct.cv* %35, i32 0, i32 0
  %36 = load %struct.xpvcv*, %struct.xpvcv** %sv_any22, align 8
  %xcv_flags = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %36, i32 0, i32 17
  %37 = load i16, i16* %xcv_flags, align 2
  %conv = zext i16 %37 to i32
  %and23 = and i32 %conv, 1024
  %tobool24 = icmp ne i32 %and23, 0
  br i1 %tobool24, label %if.end.28, label %if.then.25

if.then.25:                                       ; preds = %if.then.21
  %38 = load %struct.cv*, %struct.cv** %cv.addr, align 8
  %sv_any26 = getelementptr inbounds %struct.cv, %struct.cv* %38, i32 0, i32 0
  %39 = load %struct.xpvcv*, %struct.xpvcv** %sv_any26, align 8
  %xcv_outside27 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %39, i32 0, i32 16
  %40 = load %struct.cv*, %struct.cv** %xcv_outside27, align 8
  %41 = bitcast %struct.cv* %40 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %41)
  br label %if.end.28

if.end.28:                                        ; preds = %if.then.25, %if.then.21
  %42 = load %struct.cv*, %struct.cv** %cv.addr, align 8
  %sv_any29 = getelementptr inbounds %struct.cv, %struct.cv* %42, i32 0, i32 0
  %43 = load %struct.xpvcv*, %struct.xpvcv** %sv_any29, align 8
  %xcv_outside30 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %43, i32 0, i32 16
  store %struct.cv* null, %struct.cv** %xcv_outside30, align 8
  br label %if.end.31

if.end.31:                                        ; preds = %if.end.28, %land.lhs.true.18, %if.end.15
  %44 = load %struct.cv*, %struct.cv** %cv.addr, align 8
  %sv_any32 = getelementptr inbounds %struct.cv, %struct.cv* %44, i32 0, i32 0
  %45 = load %struct.xpvcv*, %struct.xpvcv** %sv_any32, align 8
  %xcv_flags33 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %45, i32 0, i32 17
  %46 = load i16, i16* %xcv_flags33, align 2
  %conv34 = zext i16 %46 to i32
  %and35 = and i32 %conv34, 512
  %tobool36 = icmp ne i32 %and35, 0
  br i1 %tobool36, label %if.then.37, label %if.end.45

if.then.37:                                       ; preds = %if.end.31
  %47 = load %struct.cv*, %struct.cv** %cv.addr, align 8
  %sv_any38 = getelementptr inbounds %struct.cv, %struct.cv* %47, i32 0, i32 0
  %48 = load %struct.xpvcv*, %struct.xpvcv** %sv_any38, align 8
  %xcv_xsubany = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %48, i32 0, i32 11
  %any_ptr39 = bitcast %union.any* %xcv_xsubany to i8**
  %49 = load i8*, i8** %any_ptr39, align 8
  %50 = bitcast i8* %49 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %50)
  %51 = load %struct.cv*, %struct.cv** %cv.addr, align 8
  %sv_any40 = getelementptr inbounds %struct.cv, %struct.cv* %51, i32 0, i32 0
  %52 = load %struct.xpvcv*, %struct.xpvcv** %sv_any40, align 8
  %xcv_flags41 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %52, i32 0, i32 17
  %53 = load i16, i16* %xcv_flags41, align 2
  %conv42 = zext i16 %53 to i32
  %and43 = and i32 %conv42, -513
  %conv44 = trunc i32 %and43 to i16
  store i16 %conv44, i16* %xcv_flags41, align 2
  br label %if.end.45

if.end.45:                                        ; preds = %if.then.37, %if.end.31
  %54 = load %struct.cv*, %struct.cv** %cv.addr, align 8
  %sv_any46 = getelementptr inbounds %struct.cv, %struct.cv* %54, i32 0, i32 0
  %55 = load %struct.xpvcv*, %struct.xpvcv** %sv_any46, align 8
  %xcv_xsub47 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %55, i32 0, i32 10
  %56 = load void (%struct.cv*)*, void (%struct.cv*)** %xcv_xsub47, align 8
  %tobool48 = icmp ne void (%struct.cv*)* %56, null
  br i1 %tobool48, label %if.then.49, label %if.end.52

if.then.49:                                       ; preds = %if.end.45
  %57 = load %struct.cv*, %struct.cv** %cv.addr, align 8
  %sv_any50 = getelementptr inbounds %struct.cv, %struct.cv* %57, i32 0, i32 0
  %58 = load %struct.xpvcv*, %struct.xpvcv** %sv_any50, align 8
  %xcv_xsub51 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %58, i32 0, i32 10
  store void (%struct.cv*)* null, void (%struct.cv*)** %xcv_xsub51, align 8
  br label %if.end.52

if.end.52:                                        ; preds = %if.then.49, %if.end.45
  %59 = load %struct.cv*, %struct.cv** %cv.addr, align 8
  %sv_any53 = getelementptr inbounds %struct.cv, %struct.cv* %59, i32 0, i32 0
  %60 = load %struct.xpvcv*, %struct.xpvcv** %sv_any53, align 8
  %xcv_flags54 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %60, i32 0, i32 17
  %61 = load i16, i16* %xcv_flags54, align 2
  %conv55 = zext i16 %61 to i32
  %and56 = and i32 %conv55, 1024
  %conv57 = trunc i32 %and56 to i16
  store i16 %conv57, i16* %xcv_flags54, align 2
  ret void
}

declare void @Perl_push_scope() #1

declare void @Perl_pop_scope() #1

declare void @Perl_pad_undef(%struct.cv*) #1

; Function Attrs: nounwind uwtable
define void @Perl_cv_ckproto(%struct.cv* %cv, %struct.gv* %gv, i8* %p) #0 {
entry:
  %cv.addr = alloca %struct.cv*, align 8
  %gv.addr = alloca %struct.gv*, align 8
  %p.addr = alloca i8*, align 8
  %msg = alloca %struct.sv*, align 8
  %name = alloca %struct.sv*, align 8
  store %struct.cv* %cv, %struct.cv** %cv.addr, align 8
  store %struct.gv* %gv, %struct.gv** %gv.addr, align 8
  store i8* %p, i8** %p.addr, align 8
  %0 = load i8*, i8** %p.addr, align 8
  %tobool = icmp ne i8* %0, null
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  %1 = load %struct.cv*, %struct.cv** %cv.addr, align 8
  %sv_flags = getelementptr inbounds %struct.cv, %struct.cv* %1, i32 0, i32 2
  %2 = load i32, i32* %sv_flags, align 4
  %and = and i32 %2, 262144
  %tobool1 = icmp ne i32 %and, 0
  %lnot2 = xor i1 %tobool1, true
  %lnot.ext3 = zext i1 %lnot2 to i32
  %cmp = icmp ne i32 %lnot.ext, %lnot.ext3
  br i1 %cmp, label %land.lhs.true.6, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %3 = load i8*, i8** %p.addr, align 8
  %tobool4 = icmp ne i8* %3, null
  br i1 %tobool4, label %land.lhs.true, label %if.end.36

land.lhs.true:                                    ; preds = %lor.lhs.false
  %4 = load i8*, i8** %p.addr, align 8
  %5 = load %struct.cv*, %struct.cv** %cv.addr, align 8
  %sv_any = getelementptr inbounds %struct.cv, %struct.cv* %5, i32 0, i32 0
  %6 = load %struct.xpvcv*, %struct.xpvcv** %sv_any, align 8
  %7 = bitcast %struct.xpvcv* %6 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %7, i32 0, i32 0
  %8 = load i8*, i8** %xpv_pv, align 8
  %call = call i32 @strcmp(i8* %4, i8* %8)
  %tobool5 = icmp ne i32 %call, 0
  br i1 %tobool5, label %land.lhs.true.6, label %if.end.36

land.lhs.true.6:                                  ; preds = %land.lhs.true, %entry
  %9 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings = getelementptr inbounds %struct.cop, %struct.cop* %9, i32 0, i32 14
  %10 = load %struct.sv*, %struct.sv** %cop_warnings, align 8
  %cmp7 = icmp eq %struct.sv* %10, null
  br i1 %cmp7, label %if.then, label %lor.lhs.false.8

lor.lhs.false.8:                                  ; preds = %land.lhs.true.6
  %11 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings9 = getelementptr inbounds %struct.cop, %struct.cop* %11, i32 0, i32 14
  %12 = load %struct.sv*, %struct.sv** %cop_warnings9, align 8
  %cmp10 = icmp eq %struct.sv* %12, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 1)
  br i1 %cmp10, label %if.then, label %lor.lhs.false.11

lor.lhs.false.11:                                 ; preds = %lor.lhs.false.8
  %13 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings12 = getelementptr inbounds %struct.cop, %struct.cop* %13, i32 0, i32 14
  %14 = load %struct.sv*, %struct.sv** %cop_warnings12, align 8
  %cmp13 = icmp ne %struct.sv* %14, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 2)
  br i1 %cmp13, label %land.lhs.true.14, label %if.end.36

land.lhs.true.14:                                 ; preds = %lor.lhs.false.11
  %15 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings15 = getelementptr inbounds %struct.cop, %struct.cop* %15, i32 0, i32 14
  %16 = load %struct.sv*, %struct.sv** %cop_warnings15, align 8
  %sv_any16 = getelementptr inbounds %struct.sv, %struct.sv* %16, i32 0, i32 0
  %17 = load i8*, i8** %sv_any16, align 8
  %18 = bitcast i8* %17 to %struct.xpv*
  %xpv_pv17 = getelementptr inbounds %struct.xpv, %struct.xpv* %18, i32 0, i32 0
  %19 = load i8*, i8** %xpv_pv17, align 8
  %arrayidx = getelementptr inbounds i8, i8* %19, i64 8
  %20 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %20 to i32
  %and18 = and i32 %conv, 64
  %tobool19 = icmp ne i32 %and18, 0
  br i1 %tobool19, label %if.then, label %if.end.36

if.then:                                          ; preds = %land.lhs.true.14, %lor.lhs.false.8, %land.lhs.true.6
  %call20 = call %struct.sv* @Perl_sv_newmortal()
  store %struct.sv* %call20, %struct.sv** %msg, align 8
  store %struct.sv* null, %struct.sv** %name, align 8
  %21 = load %struct.gv*, %struct.gv** %gv.addr, align 8
  %tobool21 = icmp ne %struct.gv* %21, null
  br i1 %tobool21, label %if.then.22, label %if.end

if.then.22:                                       ; preds = %if.then
  %call23 = call %struct.sv* @Perl_sv_newmortal()
  store %struct.sv* %call23, %struct.sv** %name, align 8
  %22 = load %struct.gv*, %struct.gv** %gv.addr, align 8
  call void @Perl_gv_efullname4(%struct.sv* %call23, %struct.gv* %22, i8* null, i8 signext 1)
  br label %if.end

if.end:                                           ; preds = %if.then.22, %if.then
  %23 = load %struct.sv*, %struct.sv** %msg, align 8
  call void @Perl_sv_setpv(%struct.sv* %23, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.56, i32 0, i32 0))
  %24 = load %struct.sv*, %struct.sv** %name, align 8
  %tobool24 = icmp ne %struct.sv* %24, null
  br i1 %tobool24, label %if.then.25, label %if.end.26

if.then.25:                                       ; preds = %if.end
  %25 = load %struct.sv*, %struct.sv** %msg, align 8
  %26 = load %struct.sv*, %struct.sv** %name, align 8
  call void (%struct.sv*, i8*, ...) @Perl_sv_catpvf(%struct.sv* %25, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.57, i32 0, i32 0), %struct.sv* %26)
  br label %if.end.26

if.end.26:                                        ; preds = %if.then.25, %if.end
  %27 = load %struct.cv*, %struct.cv** %cv.addr, align 8
  %sv_flags27 = getelementptr inbounds %struct.cv, %struct.cv* %27, i32 0, i32 2
  %28 = load i32, i32* %sv_flags27, align 4
  %and28 = and i32 %28, 262144
  %tobool29 = icmp ne i32 %and28, 0
  br i1 %tobool29, label %if.then.30, label %if.else

if.then.30:                                       ; preds = %if.end.26
  %29 = load %struct.sv*, %struct.sv** %msg, align 8
  %30 = load %struct.cv*, %struct.cv** %cv.addr, align 8
  %31 = bitcast %struct.cv* %30 to %struct.sv*
  call void (%struct.sv*, i8*, ...) @Perl_sv_catpvf(%struct.sv* %29, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.58, i32 0, i32 0), %struct.sv* %31)
  br label %if.end.31

if.else:                                          ; preds = %if.end.26
  %32 = load %struct.sv*, %struct.sv** %msg, align 8
  call void @Perl_sv_catpv(%struct.sv* %32, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.59, i32 0, i32 0))
  br label %if.end.31

if.end.31:                                        ; preds = %if.else, %if.then.30
  %33 = load %struct.sv*, %struct.sv** %msg, align 8
  call void @Perl_sv_catpv(%struct.sv* %33, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.60, i32 0, i32 0))
  %34 = load i8*, i8** %p.addr, align 8
  %tobool32 = icmp ne i8* %34, null
  br i1 %tobool32, label %if.then.33, label %if.else.34

if.then.33:                                       ; preds = %if.end.31
  %35 = load %struct.sv*, %struct.sv** %msg, align 8
  %36 = load i8*, i8** %p.addr, align 8
  call void (%struct.sv*, i8*, ...) @Perl_sv_catpvf(%struct.sv* %35, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.61, i32 0, i32 0), i8* %36)
  br label %if.end.35

if.else.34:                                       ; preds = %if.end.31
  %37 = load %struct.sv*, %struct.sv** %msg, align 8
  call void @Perl_sv_catpv(%struct.sv* %37, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.62, i32 0, i32 0))
  br label %if.end.35

if.end.35:                                        ; preds = %if.else.34, %if.then.33
  %38 = load %struct.sv*, %struct.sv** %msg, align 8
  call void (i32, i8*, ...) @Perl_warner(i32 35, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.63, i32 0, i32 0), %struct.sv* %38)
  br label %if.end.36

if.end.36:                                        ; preds = %if.end.35, %land.lhs.true.14, %lor.lhs.false.11, %land.lhs.true, %lor.lhs.false
  ret void
}

declare %struct.sv* @Perl_sv_newmortal() #1

declare void @Perl_gv_efullname4(%struct.sv*, %struct.gv*, i8*, i8 signext) #1

declare void @Perl_sv_catpv(%struct.sv*, i8*) #1

; Function Attrs: nounwind uwtable
define %struct.sv* @Perl_cv_const_sv(%struct.cv* %cv) #0 {
entry:
  %retval = alloca %struct.sv*, align 8
  %cv.addr = alloca %struct.cv*, align 8
  store %struct.cv* %cv, %struct.cv** %cv.addr, align 8
  %0 = load %struct.cv*, %struct.cv** %cv.addr, align 8
  %tobool = icmp ne %struct.cv* %0, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load %struct.cv*, %struct.cv** %cv.addr, align 8
  %sv_any = getelementptr inbounds %struct.cv, %struct.cv* %1, i32 0, i32 0
  %2 = load %struct.xpvcv*, %struct.xpvcv** %sv_any, align 8
  %xcv_flags = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %2, i32 0, i32 17
  %3 = load i16, i16* %xcv_flags, align 2
  %conv = zext i16 %3 to i32
  %and = and i32 %conv, 512
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  store %struct.sv* null, %struct.sv** %retval
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %4 = load %struct.cv*, %struct.cv** %cv.addr, align 8
  %sv_any2 = getelementptr inbounds %struct.cv, %struct.cv* %4, i32 0, i32 0
  %5 = load %struct.xpvcv*, %struct.xpvcv** %sv_any2, align 8
  %xcv_xsubany = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %5, i32 0, i32 11
  %any_ptr = bitcast %union.any* %xcv_xsubany to i8**
  %6 = load i8*, i8** %any_ptr, align 8
  %7 = bitcast i8* %6 to %struct.sv*
  store %struct.sv* %7, %struct.sv** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %8 = load %struct.sv*, %struct.sv** %retval
  ret %struct.sv* %8
}

; Function Attrs: nounwind uwtable
define %struct.sv* @Perl_op_const_sv(%struct.op* %o, %struct.cv* %cv) #0 {
entry:
  %retval = alloca %struct.sv*, align 8
  %o.addr = alloca %struct.op*, align 8
  %cv.addr = alloca %struct.cv*, align 8
  %sv = alloca %struct.sv*, align 8
  %type = alloca i16, align 2
  store %struct.op* %o, %struct.op** %o.addr, align 8
  store %struct.cv* %cv, %struct.cv** %cv.addr, align 8
  store %struct.sv* null, %struct.sv** %sv, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %tobool = icmp ne %struct.op* %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct.sv* null, %struct.sv** %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 4
  %2 = load i16, i16* %op_type, align 2
  %conv = zext i16 %2 to i32
  %cmp = icmp eq i32 %conv, 173
  br i1 %cmp, label %land.lhs.true, label %if.end.5

land.lhs.true:                                    ; preds = %if.end
  %3 = load %struct.op*, %struct.op** %o.addr, align 8
  %4 = bitcast %struct.op* %3 to %struct.listop*
  %op_first = getelementptr inbounds %struct.listop, %struct.listop* %4, i32 0, i32 8
  %5 = load %struct.op*, %struct.op** %op_first, align 8
  %tobool2 = icmp ne %struct.op* %5, null
  br i1 %tobool2, label %if.then.3, label %if.end.5

if.then.3:                                        ; preds = %land.lhs.true
  %6 = load %struct.op*, %struct.op** %o.addr, align 8
  %7 = bitcast %struct.op* %6 to %struct.listop*
  %op_first4 = getelementptr inbounds %struct.listop, %struct.listop* %7, i32 0, i32 8
  %8 = load %struct.op*, %struct.op** %op_first4, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %8, i32 0, i32 1
  %9 = load %struct.op*, %struct.op** %op_sibling, align 8
  store %struct.op* %9, %struct.op** %o.addr, align 8
  br label %if.end.5

if.end.5:                                         ; preds = %if.then.3, %land.lhs.true, %if.end
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end.5
  %10 = load %struct.op*, %struct.op** %o.addr, align 8
  %tobool6 = icmp ne %struct.op* %10, null
  br i1 %tobool6, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %11 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type7 = getelementptr inbounds %struct.op, %struct.op* %11, i32 0, i32 4
  %12 = load i16, i16* %op_type7, align 2
  store i16 %12, i16* %type, align 2
  %13 = load %struct.sv*, %struct.sv** %sv, align 8
  %tobool8 = icmp ne %struct.sv* %13, null
  br i1 %tobool8, label %land.lhs.true.9, label %if.end.13

land.lhs.true.9:                                  ; preds = %for.body
  %14 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %14, i32 0, i32 0
  %15 = load %struct.op*, %struct.op** %op_next, align 8
  %16 = load %struct.op*, %struct.op** %o.addr, align 8
  %cmp10 = icmp eq %struct.op* %15, %16
  br i1 %cmp10, label %if.then.12, label %if.end.13

if.then.12:                                       ; preds = %land.lhs.true.9
  %17 = load %struct.sv*, %struct.sv** %sv, align 8
  store %struct.sv* %17, %struct.sv** %retval
  br label %return

if.end.13:                                        ; preds = %land.lhs.true.9, %for.body
  %18 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next14 = getelementptr inbounds %struct.op, %struct.op* %18, i32 0, i32 0
  %19 = load %struct.op*, %struct.op** %op_next14, align 8
  %20 = load %struct.op*, %struct.op** %o.addr, align 8
  %cmp15 = icmp ne %struct.op* %19, %20
  br i1 %cmp15, label %if.then.17, label %if.end.35

if.then.17:                                       ; preds = %if.end.13
  %21 = load i16, i16* %type, align 2
  %conv18 = zext i16 %21 to i32
  %cmp19 = icmp eq i32 %conv18, 174
  br i1 %cmp19, label %if.then.28, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then.17
  %22 = load i16, i16* %type, align 2
  %conv21 = zext i16 %22 to i32
  %cmp22 = icmp eq i32 %conv21, 0
  br i1 %cmp22, label %if.then.28, label %lor.lhs.false.24

lor.lhs.false.24:                                 ; preds = %lor.lhs.false
  %23 = load i16, i16* %type, align 2
  %conv25 = zext i16 %23 to i32
  %cmp26 = icmp eq i32 %conv25, 3
  br i1 %cmp26, label %if.then.28, label %if.end.29

if.then.28:                                       ; preds = %lor.lhs.false.24, %lor.lhs.false, %if.then.17
  br label %for.inc

if.end.29:                                        ; preds = %lor.lhs.false.24
  %24 = load i16, i16* %type, align 2
  %conv30 = zext i16 %24 to i32
  %cmp31 = icmp eq i32 %conv30, 175
  br i1 %cmp31, label %if.then.33, label %if.end.34

if.then.33:                                       ; preds = %if.end.29
  br label %for.inc

if.end.34:                                        ; preds = %if.end.29
  br label %if.end.35

if.end.35:                                        ; preds = %if.end.34, %if.end.13
  %25 = load i16, i16* %type, align 2
  %conv36 = zext i16 %25 to i32
  %cmp37 = icmp eq i32 %conv36, 167
  br i1 %cmp37, label %if.then.43, label %lor.lhs.false.39

lor.lhs.false.39:                                 ; preds = %if.end.35
  %26 = load i16, i16* %type, align 2
  %conv40 = zext i16 %26 to i32
  %cmp41 = icmp eq i32 %conv40, 184
  br i1 %cmp41, label %if.then.43, label %if.end.44

if.then.43:                                       ; preds = %lor.lhs.false.39, %if.end.35
  br label %for.end

if.end.44:                                        ; preds = %lor.lhs.false.39
  %27 = load %struct.sv*, %struct.sv** %sv, align 8
  %tobool45 = icmp ne %struct.sv* %27, null
  br i1 %tobool45, label %if.then.46, label %if.end.47

if.then.46:                                       ; preds = %if.end.44
  store %struct.sv* null, %struct.sv** %retval
  br label %return

if.end.47:                                        ; preds = %if.end.44
  %28 = load i16, i16* %type, align 2
  %conv48 = zext i16 %28 to i32
  %cmp49 = icmp eq i32 %conv48, 5
  br i1 %cmp49, label %land.lhs.true.51, label %if.else

land.lhs.true.51:                                 ; preds = %if.end.47
  %29 = load %struct.op*, %struct.op** %o.addr, align 8
  %30 = bitcast %struct.op* %29 to %struct.svop*
  %op_sv = getelementptr inbounds %struct.svop, %struct.svop* %30, i32 0, i32 8
  %31 = load %struct.sv*, %struct.sv** %op_sv, align 8
  %tobool52 = icmp ne %struct.sv* %31, null
  br i1 %tobool52, label %if.then.53, label %if.else

if.then.53:                                       ; preds = %land.lhs.true.51
  %32 = load %struct.op*, %struct.op** %o.addr, align 8
  %33 = bitcast %struct.op* %32 to %struct.svop*
  %op_sv54 = getelementptr inbounds %struct.svop, %struct.svop* %33, i32 0, i32 8
  %34 = load %struct.sv*, %struct.sv** %op_sv54, align 8
  store %struct.sv* %34, %struct.sv** %sv, align 8
  br label %if.end.92

if.else:                                          ; preds = %land.lhs.true.51, %if.end.47
  %35 = load i16, i16* %type, align 2
  %conv55 = zext i16 %35 to i32
  %cmp56 = icmp eq i32 %conv55, 9
  br i1 %cmp56, label %land.lhs.true.62, label %lor.lhs.false.58

lor.lhs.false.58:                                 ; preds = %if.else
  %36 = load i16, i16* %type, align 2
  %conv59 = zext i16 %36 to i32
  %cmp60 = icmp eq i32 %conv59, 5
  br i1 %cmp60, label %land.lhs.true.62, label %if.else.90

land.lhs.true.62:                                 ; preds = %lor.lhs.false.58, %if.else
  %37 = load %struct.cv*, %struct.cv** %cv.addr, align 8
  %tobool63 = icmp ne %struct.cv* %37, null
  br i1 %tobool63, label %if.then.64, label %if.else.90

if.then.64:                                       ; preds = %land.lhs.true.62
  %38 = load %struct.cv*, %struct.cv** %cv.addr, align 8
  %sv_any = getelementptr inbounds %struct.cv, %struct.cv* %38, i32 0, i32 0
  %39 = load %struct.xpvcv*, %struct.xpvcv** %sv_any, align 8
  %xcv_padlist = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %39, i32 0, i32 15
  %40 = load %struct.av*, %struct.av** %xcv_padlist, align 8
  %sv_any65 = getelementptr inbounds %struct.av, %struct.av* %40, i32 0, i32 0
  %41 = load %struct.xpvav*, %struct.xpvav** %sv_any65, align 8
  %xav_array = getelementptr inbounds %struct.xpvav, %struct.xpvav* %41, i32 0, i32 0
  %42 = load i8*, i8** %xav_array, align 8
  %43 = bitcast i8* %42 to %struct.sv**
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %43, i64 1
  %44 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  %tobool66 = icmp ne %struct.sv* %44, null
  br i1 %tobool66, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.64
  %45 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %45, i32 0, i32 3
  %46 = load i64, i64* %op_targ, align 8
  %47 = load %struct.cv*, %struct.cv** %cv.addr, align 8
  %sv_any67 = getelementptr inbounds %struct.cv, %struct.cv* %47, i32 0, i32 0
  %48 = load %struct.xpvcv*, %struct.xpvcv** %sv_any67, align 8
  %xcv_padlist68 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %48, i32 0, i32 15
  %49 = load %struct.av*, %struct.av** %xcv_padlist68, align 8
  %sv_any69 = getelementptr inbounds %struct.av, %struct.av* %49, i32 0, i32 0
  %50 = load %struct.xpvav*, %struct.xpvav** %sv_any69, align 8
  %xav_array70 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %50, i32 0, i32 0
  %51 = load i8*, i8** %xav_array70, align 8
  %52 = bitcast i8* %51 to %struct.sv**
  %arrayidx71 = getelementptr inbounds %struct.sv*, %struct.sv** %52, i64 1
  %53 = load %struct.sv*, %struct.sv** %arrayidx71, align 8
  %54 = bitcast %struct.sv* %53 to %struct.av*
  %sv_any72 = getelementptr inbounds %struct.av, %struct.av* %54, i32 0, i32 0
  %55 = load %struct.xpvav*, %struct.xpvav** %sv_any72, align 8
  %xav_array73 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %55, i32 0, i32 0
  %56 = load i8*, i8** %xav_array73, align 8
  %57 = bitcast i8* %56 to %struct.sv**
  %arrayidx74 = getelementptr inbounds %struct.sv*, %struct.sv** %57, i64 %46
  %58 = load %struct.sv*, %struct.sv** %arrayidx74, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then.64
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.sv* [ %58, %cond.true ], [ null, %cond.false ]
  store %struct.sv* %cond, %struct.sv** %sv, align 8
  %59 = load %struct.sv*, %struct.sv** %sv, align 8
  %tobool75 = icmp ne %struct.sv* %59, null
  br i1 %tobool75, label %if.end.77, label %if.then.76

if.then.76:                                       ; preds = %cond.end
  store %struct.sv* null, %struct.sv** %retval
  br label %return

if.end.77:                                        ; preds = %cond.end
  %60 = load %struct.cv*, %struct.cv** %cv.addr, align 8
  %sv_any78 = getelementptr inbounds %struct.cv, %struct.cv* %60, i32 0, i32 0
  %61 = load %struct.xpvcv*, %struct.xpvcv** %sv_any78, align 8
  %xcv_flags = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %61, i32 0, i32 17
  %62 = load i16, i16* %xcv_flags, align 2
  %conv79 = zext i16 %62 to i32
  %and = and i32 %conv79, 512
  %tobool80 = icmp ne i32 %and, 0
  br i1 %tobool80, label %if.then.81, label %if.end.82

if.then.81:                                       ; preds = %if.end.77
  %63 = load %struct.sv*, %struct.sv** %sv, align 8
  %call = call %struct.sv* @Perl_newSVsv(%struct.sv* %63)
  store %struct.sv* %call, %struct.sv** %sv, align 8
  br label %if.end.82

if.end.82:                                        ; preds = %if.then.81, %if.end.77
  %64 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %64, i32 0, i32 2
  %65 = load i32, i32* %sv_flags, align 4
  %and83 = and i32 %65, 8388608
  %tobool84 = icmp ne i32 %and83, 0
  br i1 %tobool84, label %if.end.89, label %land.lhs.true.85

land.lhs.true.85:                                 ; preds = %if.end.82
  %66 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_refcnt = getelementptr inbounds %struct.sv, %struct.sv* %66, i32 0, i32 1
  %67 = load i32, i32* %sv_refcnt, align 4
  %cmp86 = icmp ugt i32 %67, 1
  br i1 %cmp86, label %if.then.88, label %if.end.89

if.then.88:                                       ; preds = %land.lhs.true.85
  store %struct.sv* null, %struct.sv** %retval
  br label %return

if.end.89:                                        ; preds = %land.lhs.true.85, %if.end.82
  br label %if.end.91

if.else.90:                                       ; preds = %land.lhs.true.62, %lor.lhs.false.58
  store %struct.sv* null, %struct.sv** %retval
  br label %return

if.end.91:                                        ; preds = %if.end.89
  br label %if.end.92

if.end.92:                                        ; preds = %if.end.91, %if.then.53
  br label %for.inc

for.inc:                                          ; preds = %if.end.92, %if.then.33, %if.then.28
  %68 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next93 = getelementptr inbounds %struct.op, %struct.op* %68, i32 0, i32 0
  %69 = load %struct.op*, %struct.op** %op_next93, align 8
  store %struct.op* %69, %struct.op** %o.addr, align 8
  br label %for.cond

for.end:                                          ; preds = %if.then.43, %for.cond
  %70 = load %struct.sv*, %struct.sv** %sv, align 8
  %tobool94 = icmp ne %struct.sv* %70, null
  br i1 %tobool94, label %if.then.95, label %if.end.97

if.then.95:                                       ; preds = %for.end
  %71 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags96 = getelementptr inbounds %struct.sv, %struct.sv* %71, i32 0, i32 2
  %72 = load i32, i32* %sv_flags96, align 4
  %or = or i32 %72, 8388608
  store i32 %or, i32* %sv_flags96, align 4
  br label %if.end.97

if.end.97:                                        ; preds = %if.then.95, %for.end
  %73 = load %struct.sv*, %struct.sv** %sv, align 8
  store %struct.sv* %73, %struct.sv** %retval
  br label %return

return:                                           ; preds = %if.end.97, %if.else.90, %if.then.88, %if.then.76, %if.then.46, %if.then.12, %if.then
  %74 = load %struct.sv*, %struct.sv** %retval
  ret %struct.sv* %74
}

; Function Attrs: nounwind uwtable
define void @Perl_newMYSUB(i32 %floor, %struct.op* %o, %struct.op* %proto, %struct.op* %attrs, %struct.op* %block) #0 {
entry:
  %floor.addr = alloca i32, align 4
  %o.addr = alloca %struct.op*, align 8
  %proto.addr = alloca %struct.op*, align 8
  %attrs.addr = alloca %struct.op*, align 8
  %block.addr = alloca %struct.op*, align 8
  store i32 %floor, i32* %floor.addr, align 4
  store %struct.op* %o, %struct.op** %o.addr, align 8
  store %struct.op* %proto, %struct.op** %proto.addr, align 8
  store %struct.op* %attrs, %struct.op** %attrs.addr, align 8
  store %struct.op* %block, %struct.op** %block.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %tobool = icmp ne %struct.op* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.op*, %struct.op** %o.addr, align 8
  call void @Perl_save_freeop(%struct.op* %1)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load %struct.op*, %struct.op** %proto.addr, align 8
  %tobool1 = icmp ne %struct.op* %2, null
  br i1 %tobool1, label %if.then.2, label %if.end.3

if.then.2:                                        ; preds = %if.end
  %3 = load %struct.op*, %struct.op** %proto.addr, align 8
  call void @Perl_save_freeop(%struct.op* %3)
  br label %if.end.3

if.end.3:                                         ; preds = %if.then.2, %if.end
  %4 = load %struct.op*, %struct.op** %attrs.addr, align 8
  %tobool4 = icmp ne %struct.op* %4, null
  br i1 %tobool4, label %if.then.5, label %if.end.6

if.then.5:                                        ; preds = %if.end.3
  %5 = load %struct.op*, %struct.op** %attrs.addr, align 8
  call void @Perl_save_freeop(%struct.op* %5)
  br label %if.end.6

if.end.6:                                         ; preds = %if.then.5, %if.end.3
  %6 = load %struct.op*, %struct.op** %block.addr, align 8
  %tobool7 = icmp ne %struct.op* %6, null
  br i1 %tobool7, label %if.then.8, label %if.end.9

if.then.8:                                        ; preds = %if.end.6
  %7 = load %struct.op*, %struct.op** %block.addr, align 8
  call void @Perl_save_freeop(%struct.op* %7)
  br label %if.end.9

if.end.9:                                         ; preds = %if.then.8, %if.end.6
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.64, i32 0, i32 0))
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.cv* @Perl_newSUB(i32 %floor, %struct.op* %o, %struct.op* %proto, %struct.op* %block) #0 {
entry:
  %floor.addr = alloca i32, align 4
  %o.addr = alloca %struct.op*, align 8
  %proto.addr = alloca %struct.op*, align 8
  %block.addr = alloca %struct.op*, align 8
  store i32 %floor, i32* %floor.addr, align 4
  store %struct.op* %o, %struct.op** %o.addr, align 8
  store %struct.op* %proto, %struct.op** %proto.addr, align 8
  store %struct.op* %block, %struct.op** %block.addr, align 8
  %0 = load i32, i32* %floor.addr, align 4
  %1 = load %struct.op*, %struct.op** %o.addr, align 8
  %2 = load %struct.op*, %struct.op** %proto.addr, align 8
  %3 = load %struct.op*, %struct.op** %block.addr, align 8
  %call = call %struct.cv* @Perl_newATTRSUB(i32 %0, %struct.op* %1, %struct.op* %2, %struct.op* null, %struct.op* %3)
  ret %struct.cv* %call
}

declare void @Perl_sv_setpvf(%struct.sv*, i8*, ...) #1

declare i32 @Perl_sv_cmp(%struct.sv*, %struct.sv*) #1

; Function Attrs: nounwind uwtable
define internal void @const_sv_xsub(%struct.cv* %cv) #0 {
entry:
  %cv.addr = alloca %struct.cv*, align 8
  %sp = alloca %struct.sv**, align 8
  %mark = alloca %struct.sv**, align 8
  %ax = alloca i32, align 4
  %items = alloca i32, align 4
  %tmpXSoff = alloca i64, align 8
  store %struct.cv* %cv, %struct.cv** %cv.addr, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %2 = load i32*, i32** @PL_markstack_ptr, align 8
  %incdec.ptr = getelementptr inbounds i32, i32* %2, i32 -1
  store i32* %incdec.ptr, i32** @PL_markstack_ptr, align 8
  %3 = load i32, i32* %2, align 4
  %idx.ext = sext i32 %3 to i64
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %1, i64 %idx.ext
  store %struct.sv** %add.ptr, %struct.sv*** %mark, align 8
  %4 = load %struct.sv**, %struct.sv*** %mark, align 8
  %5 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %4 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %5 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %add = add nsw i64 %sub.ptr.div, 1
  %conv = trunc i64 %add to i32
  store i32 %conv, i32* %ax, align 4
  %6 = load %struct.sv**, %struct.sv*** %sp, align 8
  %7 = load %struct.sv**, %struct.sv*** %mark, align 8
  %sub.ptr.lhs.cast1 = ptrtoint %struct.sv** %6 to i64
  %sub.ptr.rhs.cast2 = ptrtoint %struct.sv** %7 to i64
  %sub.ptr.sub3 = sub i64 %sub.ptr.lhs.cast1, %sub.ptr.rhs.cast2
  %sub.ptr.div4 = sdiv exact i64 %sub.ptr.sub3, 8
  %conv5 = trunc i64 %sub.ptr.div4 to i32
  store i32 %conv5, i32* %items, align 4
  %8 = load i32, i32* %items, align 4
  %cmp = icmp ne i32 %8, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %9 = load %struct.sv**, %struct.sv*** @PL_stack_max, align 8
  %10 = load %struct.sv**, %struct.sv*** %sp, align 8
  %sub.ptr.lhs.cast7 = ptrtoint %struct.sv** %9 to i64
  %sub.ptr.rhs.cast8 = ptrtoint %struct.sv** %10 to i64
  %sub.ptr.sub9 = sub i64 %sub.ptr.lhs.cast7, %sub.ptr.rhs.cast8
  %sub.ptr.div10 = sdiv exact i64 %sub.ptr.sub9, 8
  %cmp11 = icmp slt i64 %sub.ptr.div10, 1
  br i1 %cmp11, label %if.then.13, label %if.end.14

if.then.13:                                       ; preds = %if.end
  %11 = load %struct.sv**, %struct.sv*** %sp, align 8
  %12 = load %struct.sv**, %struct.sv*** %sp, align 8
  %call = call %struct.sv** @Perl_stack_grow(%struct.sv** %11, %struct.sv** %12, i32 1)
  store %struct.sv** %call, %struct.sv*** %sp, align 8
  br label %if.end.14

if.end.14:                                        ; preds = %if.then.13, %if.end
  %13 = load %struct.cv*, %struct.cv** %cv.addr, align 8
  %sv_any = getelementptr inbounds %struct.cv, %struct.cv* %13, i32 0, i32 0
  %14 = load %struct.xpvcv*, %struct.xpvcv** %sv_any, align 8
  %xcv_xsubany = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %14, i32 0, i32 11
  %any_ptr = bitcast %union.any* %xcv_xsubany to i8**
  %15 = load i8*, i8** %any_ptr, align 8
  %16 = bitcast i8* %15 to %struct.sv*
  %17 = load i32, i32* %ax, align 4
  %add15 = add nsw i32 %17, 0
  %idxprom = sext i32 %add15 to i64
  %18 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %18, i64 %idxprom
  store %struct.sv* %16, %struct.sv** %arrayidx, align 8
  store i64 1, i64* %tmpXSoff, align 8
  %19 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %20 = load i32, i32* %ax, align 4
  %idx.ext16 = sext i32 %20 to i64
  %add.ptr17 = getelementptr inbounds %struct.sv*, %struct.sv** %19, i64 %idx.ext16
  %21 = load i64, i64* %tmpXSoff, align 8
  %sub = sub nsw i64 %21, 1
  %add.ptr18 = getelementptr inbounds %struct.sv*, %struct.sv** %add.ptr17, i64 %sub
  store %struct.sv** %add.ptr18, %struct.sv*** @PL_stack_sp, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.cv* @Perl_newCONSTSUB(%struct.hv* %stash, i8* %name, %struct.sv* %sv) #0 {
entry:
  %stash.addr = alloca %struct.hv*, align 8
  %name.addr = alloca i8*, align 8
  %sv.addr = alloca %struct.sv*, align 8
  %cv = alloca %struct.cv*, align 8
  %tmp = alloca i32, align 4
  store %struct.hv* %stash, %struct.hv** %stash.addr, align 8
  store i8* %name, i8** %name.addr, align 8
  store %struct.sv* %sv, %struct.sv** %sv.addr, align 8
  call void @Perl_push_scope()
  %0 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_line = getelementptr inbounds %struct.cop, %struct.cop* %0, i32 0, i32 13
  call void @Perl_save_I32(i32* %cop_line)
  %1 = load i32, i32* @PL_copline, align 4
  %2 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_line1 = getelementptr inbounds %struct.cop, %struct.cop* %2, i32 0, i32 13
  store i32 %1, i32* %cop_line1, align 4
  %3 = load i32, i32* @PL_savestack_ix, align 4
  %add = add nsw i32 %3, 3
  %4 = load i32, i32* @PL_savestack_max, align 4
  %cmp = icmp sgt i32 %add, %4
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @Perl_savestack_grow()
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load i32, i32* @PL_hints, align 4
  %and = and i32 %5, 131072
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then.2, label %if.end.9

if.then.2:                                        ; preds = %if.end
  %6 = load %struct.gv*, %struct.gv** @PL_hintgv, align 8
  %sv_any = getelementptr inbounds %struct.gv, %struct.gv* %6, i32 0, i32 0
  %7 = load %struct.xpvgv*, %struct.xpvgv** %sv_any, align 8
  %xgv_gp = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %7, i32 0, i32 7
  %8 = load %struct.gp*, %struct.gp** %xgv_gp, align 8
  %gp_hv = getelementptr inbounds %struct.gp, %struct.gp* %8, i32 0, i32 5
  %9 = load %struct.hv*, %struct.hv** %gp_hv, align 8
  %10 = bitcast %struct.hv* %9 to i8*
  %11 = load i32, i32* @PL_savestack_ix, align 4
  %inc = add nsw i32 %11, 1
  store i32 %inc, i32* @PL_savestack_ix, align 4
  %idxprom = sext i32 %11 to i64
  %12 = load %union.any*, %union.any** @PL_savestack, align 8
  %arrayidx = getelementptr inbounds %union.any, %union.any* %12, i64 %idxprom
  %any_ptr = bitcast %union.any* %arrayidx to i8**
  store i8* %10, i8** %any_ptr, align 8
  %13 = load %struct.gv*, %struct.gv** @PL_hintgv, align 8
  %sv_any3 = getelementptr inbounds %struct.gv, %struct.gv* %13, i32 0, i32 0
  %14 = load %struct.xpvgv*, %struct.xpvgv** %sv_any3, align 8
  %xgv_gp4 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %14, i32 0, i32 7
  %15 = load %struct.gp*, %struct.gp** %xgv_gp4, align 8
  %gp_hv5 = getelementptr inbounds %struct.gp, %struct.gp* %15, i32 0, i32 5
  %16 = load %struct.hv*, %struct.hv** %gp_hv5, align 8
  %call = call %struct.hv* @Perl_newHVhv(%struct.hv* %16)
  %17 = load %struct.gv*, %struct.gv** @PL_hintgv, align 8
  %sv_any6 = getelementptr inbounds %struct.gv, %struct.gv* %17, i32 0, i32 0
  %18 = load %struct.xpvgv*, %struct.xpvgv** %sv_any6, align 8
  %xgv_gp7 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %18, i32 0, i32 7
  %19 = load %struct.gp*, %struct.gp** %xgv_gp7, align 8
  %gp_hv8 = getelementptr inbounds %struct.gp, %struct.gp* %19, i32 0, i32 5
  store %struct.hv* %call, %struct.hv** %gp_hv8, align 8
  br label %if.end.9

if.end.9:                                         ; preds = %if.then.2, %if.end
  %20 = load i32, i32* @PL_hints, align 4
  %21 = load i32, i32* @PL_savestack_ix, align 4
  %inc10 = add nsw i32 %21, 1
  store i32 %inc10, i32* @PL_savestack_ix, align 4
  %idxprom11 = sext i32 %21 to i64
  %22 = load %union.any*, %union.any** @PL_savestack, align 8
  %arrayidx12 = getelementptr inbounds %union.any, %union.any* %22, i64 %idxprom11
  %any_i32 = bitcast %union.any* %arrayidx12 to i32*
  store i32 %20, i32* %any_i32, align 4
  %23 = load i32, i32* @PL_savestack_ix, align 4
  %inc13 = add nsw i32 %23, 1
  store i32 %inc13, i32* @PL_savestack_ix, align 4
  %idxprom14 = sext i32 %23 to i64
  %24 = load %union.any*, %union.any** @PL_savestack, align 8
  %arrayidx15 = getelementptr inbounds %union.any, %union.any* %24, i64 %idxprom14
  %any_i3216 = bitcast %union.any* %arrayidx15 to i32*
  store i32 27, i32* %any_i3216, align 4
  store i32 27, i32* %tmp
  %25 = load i32, i32* %tmp
  %26 = load i32, i32* @PL_hints, align 4
  %and17 = and i32 %26, -257
  store i32 %and17, i32* @PL_hints, align 4
  %27 = load %struct.hv*, %struct.hv** %stash.addr, align 8
  %tobool18 = icmp ne %struct.hv* %27, null
  br i1 %tobool18, label %if.then.19, label %if.end.21

if.then.19:                                       ; preds = %if.end.9
  call void @Perl_save_sptr(%struct.sv** bitcast (%struct.hv** @PL_curstash to %struct.sv**))
  %28 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_stash = getelementptr inbounds %struct.cop, %struct.cop* %28, i32 0, i32 9
  %29 = bitcast %struct.hv** %cop_stash to %struct.sv**
  call void @Perl_save_sptr(%struct.sv** %29)
  %30 = load %struct.hv*, %struct.hv** %stash.addr, align 8
  store %struct.hv* %30, %struct.hv** @PL_curstash, align 8
  %31 = load %struct.hv*, %struct.hv** %stash.addr, align 8
  %32 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_stash20 = getelementptr inbounds %struct.cop, %struct.cop* %32, i32 0, i32 9
  store %struct.hv* %31, %struct.hv** %cop_stash20, align 8
  br label %if.end.21

if.end.21:                                        ; preds = %if.then.19, %if.end.9
  %33 = load i8*, i8** %name.addr, align 8
  %34 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_filegv = getelementptr inbounds %struct.cop, %struct.cop* %34, i32 0, i32 10
  %35 = load %struct.gv*, %struct.gv** %cop_filegv, align 8
  %tobool22 = icmp ne %struct.gv* %35, null
  br i1 %tobool22, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.21
  %36 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_filegv23 = getelementptr inbounds %struct.cop, %struct.cop* %36, i32 0, i32 10
  %37 = load %struct.gv*, %struct.gv** %cop_filegv23, align 8
  %sv_any24 = getelementptr inbounds %struct.gv, %struct.gv* %37, i32 0, i32 0
  %38 = load %struct.xpvgv*, %struct.xpvgv** %sv_any24, align 8
  %xgv_gp25 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %38, i32 0, i32 7
  %39 = load %struct.gp*, %struct.gp** %xgv_gp25, align 8
  %gp_sv = getelementptr inbounds %struct.gp, %struct.gp* %39, i32 0, i32 0
  %40 = load %struct.sv*, %struct.sv** %gp_sv, align 8
  %tobool26 = icmp ne %struct.sv* %40, null
  br i1 %tobool26, label %cond.true.27, label %cond.false.37

cond.false:                                       ; preds = %if.end.21
  br i1 false, label %cond.true.27, label %cond.false.37

cond.true.27:                                     ; preds = %cond.false, %cond.true
  %41 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_filegv28 = getelementptr inbounds %struct.cop, %struct.cop* %41, i32 0, i32 10
  %42 = load %struct.gv*, %struct.gv** %cop_filegv28, align 8
  %tobool29 = icmp ne %struct.gv* %42, null
  br i1 %tobool29, label %cond.true.30, label %cond.false.35

cond.true.30:                                     ; preds = %cond.true.27
  %43 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_filegv31 = getelementptr inbounds %struct.cop, %struct.cop* %43, i32 0, i32 10
  %44 = load %struct.gv*, %struct.gv** %cop_filegv31, align 8
  %sv_any32 = getelementptr inbounds %struct.gv, %struct.gv* %44, i32 0, i32 0
  %45 = load %struct.xpvgv*, %struct.xpvgv** %sv_any32, align 8
  %xgv_gp33 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %45, i32 0, i32 7
  %46 = load %struct.gp*, %struct.gp** %xgv_gp33, align 8
  %gp_sv34 = getelementptr inbounds %struct.gp, %struct.gp* %46, i32 0, i32 0
  %47 = load %struct.sv*, %struct.sv** %gp_sv34, align 8
  br label %cond.end

cond.false.35:                                    ; preds = %cond.true.27
  br label %cond.end

cond.end:                                         ; preds = %cond.false.35, %cond.true.30
  %cond = phi %struct.sv* [ %47, %cond.true.30 ], [ null, %cond.false.35 ]
  %sv_any36 = getelementptr inbounds %struct.sv, %struct.sv* %cond, i32 0, i32 0
  %48 = load i8*, i8** %sv_any36, align 8
  %49 = bitcast i8* %48 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %49, i32 0, i32 0
  %50 = load i8*, i8** %xpv_pv, align 8
  br label %cond.end.38

cond.false.37:                                    ; preds = %cond.false, %cond.true
  br label %cond.end.38

cond.end.38:                                      ; preds = %cond.false.37, %cond.end
  %cond39 = phi i8* [ %50, %cond.end ], [ null, %cond.false.37 ]
  %call40 = call i8* @Perl_savepv(i8* %cond39)
  %call41 = call %struct.cv* @Perl_newXS(i8* %33, void (%struct.cv*)* @const_sv_xsub, i8* %call40)
  store %struct.cv* %call41, %struct.cv** %cv, align 8
  %51 = load %struct.sv*, %struct.sv** %sv.addr, align 8
  %52 = bitcast %struct.sv* %51 to i8*
  %53 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any42 = getelementptr inbounds %struct.cv, %struct.cv* %53, i32 0, i32 0
  %54 = load %struct.xpvcv*, %struct.xpvcv** %sv_any42, align 8
  %xcv_xsubany = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %54, i32 0, i32 11
  %any_ptr43 = bitcast %union.any* %xcv_xsubany to i8**
  store i8* %52, i8** %any_ptr43, align 8
  %55 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any44 = getelementptr inbounds %struct.cv, %struct.cv* %55, i32 0, i32 0
  %56 = load %struct.xpvcv*, %struct.xpvcv** %sv_any44, align 8
  %xcv_flags = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %56, i32 0, i32 17
  %57 = load i16, i16* %xcv_flags, align 2
  %conv = zext i16 %57 to i32
  %or = or i32 %conv, 512
  %conv45 = trunc i32 %or to i16
  store i16 %conv45, i16* %xcv_flags, align 2
  %58 = load %struct.cv*, %struct.cv** %cv, align 8
  %59 = bitcast %struct.cv* %58 to %struct.sv*
  call void @Perl_sv_setpv(%struct.sv* %59, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.35, i32 0, i32 0))
  %60 = load %struct.hv*, %struct.hv** %stash.addr, align 8
  %tobool46 = icmp ne %struct.hv* %60, null
  br i1 %tobool46, label %if.then.47, label %if.end.48

if.then.47:                                       ; preds = %cond.end.38
  br label %if.end.48

if.end.48:                                        ; preds = %if.then.47, %cond.end.38
  call void @Perl_pop_scope()
  %61 = load %struct.cv*, %struct.cv** %cv, align 8
  ret %struct.cv* %61
}

; Function Attrs: nounwind uwtable
define internal void @S_apply_attrs(%struct.hv* %stash, %struct.sv* %target, %struct.op* %attrs, i8 signext %for_my) #0 {
entry:
  %stash.addr = alloca %struct.hv*, align 8
  %target.addr = alloca %struct.sv*, align 8
  %attrs.addr = alloca %struct.op*, align 8
  %for_my.addr = alloca i8, align 1
  %stashsv = alloca %struct.sv*, align 8
  %svp = alloca %struct.sv**, align 8
  store %struct.hv* %stash, %struct.hv** %stash.addr, align 8
  store %struct.sv* %target, %struct.sv** %target.addr, align 8
  store %struct.op* %attrs, %struct.op** %attrs.addr, align 8
  store i8 %for_my, i8* %for_my.addr, align 1
  call void @Perl_push_scope()
  call void @Perl_save_int(i32* @PL_expect)
  %0 = load %struct.hv*, %struct.hv** %stash.addr, align 8
  %tobool = icmp ne %struct.hv* %0, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load %struct.hv*, %struct.hv** %stash.addr, align 8
  %sv_any = getelementptr inbounds %struct.hv, %struct.hv* %1, i32 0, i32 0
  %2 = load %struct.xpvhv*, %struct.xpvhv** %sv_any, align 8
  %xhv_name = getelementptr inbounds %struct.xpvhv, %struct.xpvhv* %2, i32 0, i32 10
  %3 = load i8*, i8** %xhv_name, align 8
  %call = call %struct.sv* @Perl_newSVpv(i8* %3, i64 0)
  store %struct.sv* %call, %struct.sv** %stashsv, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  store %struct.sv* @PL_sv_no, %struct.sv** %stashsv, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %4 = load i8, i8* %for_my.addr, align 1
  %tobool1 = icmp ne i8 %4, 0
  br i1 %tobool1, label %if.then.2, label %if.else.18

if.then.2:                                        ; preds = %if.end
  %5 = load %struct.gv*, %struct.gv** @PL_incgv, align 8
  %sv_any3 = getelementptr inbounds %struct.gv, %struct.gv* %5, i32 0, i32 0
  %6 = load %struct.xpvgv*, %struct.xpvgv** %sv_any3, align 8
  %xgv_gp = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %6, i32 0, i32 7
  %7 = load %struct.gp*, %struct.gp** %xgv_gp, align 8
  %gp_hv = getelementptr inbounds %struct.gp, %struct.gp* %7, i32 0, i32 5
  %8 = load %struct.hv*, %struct.hv** %gp_hv, align 8
  %tobool4 = icmp ne %struct.hv* %8, null
  br i1 %tobool4, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.2
  %9 = load %struct.gv*, %struct.gv** @PL_incgv, align 8
  %sv_any5 = getelementptr inbounds %struct.gv, %struct.gv* %9, i32 0, i32 0
  %10 = load %struct.xpvgv*, %struct.xpvgv** %sv_any5, align 8
  %xgv_gp6 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %10, i32 0, i32 7
  %11 = load %struct.gp*, %struct.gp** %xgv_gp6, align 8
  %gp_hv7 = getelementptr inbounds %struct.gp, %struct.gp* %11, i32 0, i32 5
  %12 = load %struct.hv*, %struct.hv** %gp_hv7, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then.2
  %13 = load %struct.gv*, %struct.gv** @PL_incgv, align 8
  %call8 = call %struct.gv* @Perl_gv_HVadd(%struct.gv* %13)
  %sv_any9 = getelementptr inbounds %struct.gv, %struct.gv* %call8, i32 0, i32 0
  %14 = load %struct.xpvgv*, %struct.xpvgv** %sv_any9, align 8
  %xgv_gp10 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %14, i32 0, i32 7
  %15 = load %struct.gp*, %struct.gp** %xgv_gp10, align 8
  %gp_hv11 = getelementptr inbounds %struct.gp, %struct.gp* %15, i32 0, i32 5
  %16 = load %struct.hv*, %struct.hv** %gp_hv11, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.hv* [ %12, %cond.true ], [ %16, %cond.false ]
  %call12 = call %struct.sv** @Perl_hv_fetch(%struct.hv* %cond, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.149, i32 0, i32 0), i32 13, i32 0)
  store %struct.sv** %call12, %struct.sv*** %svp, align 8
  %17 = load %struct.sv**, %struct.sv*** %svp, align 8
  %tobool13 = icmp ne %struct.sv** %17, null
  br i1 %tobool13, label %land.lhs.true, label %if.else.15

land.lhs.true:                                    ; preds = %cond.end
  %18 = load %struct.sv**, %struct.sv*** %svp, align 8
  %19 = load %struct.sv*, %struct.sv** %18, align 8
  %cmp = icmp ne %struct.sv* %19, @PL_sv_undef
  br i1 %cmp, label %if.then.14, label %if.else.15

if.then.14:                                       ; preds = %land.lhs.true
  br label %if.end.17

if.else.15:                                       ; preds = %land.lhs.true, %cond.end
  %call16 = call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.23, i32 0, i32 0), i64 10)
  call void (i32, %struct.sv*, %struct.sv*, ...) @Perl_load_module(i32 2, %struct.sv* %call16, %struct.sv* null)
  br label %if.end.17

if.end.17:                                        ; preds = %if.else.15, %if.then.14
  br label %if.end.26

if.else.18:                                       ; preds = %if.end
  %call19 = call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.23, i32 0, i32 0), i64 10)
  %20 = load %struct.sv*, %struct.sv** %stashsv, align 8
  %call20 = call %struct.op* @Perl_newSVOP(i32 5, i32 0, %struct.sv* %20)
  %21 = load %struct.sv*, %struct.sv** %target.addr, align 8
  %call21 = call %struct.sv* @Perl_newRV(%struct.sv* %21)
  %call22 = call %struct.op* @Perl_newSVOP(i32 5, i32 0, %struct.sv* %call21)
  %22 = load %struct.op*, %struct.op** %attrs.addr, align 8
  %call23 = call %struct.op* @S_dup_attrlist(%struct.op* %22)
  %call24 = call %struct.op* @Perl_prepend_elem(i32 141, %struct.op* %call22, %struct.op* %call23)
  %call25 = call %struct.op* @Perl_prepend_elem(i32 141, %struct.op* %call20, %struct.op* %call24)
  call void (i32, %struct.sv*, %struct.sv*, ...) @Perl_load_module(i32 4, %struct.sv* %call19, %struct.sv* null, %struct.op* %call25)
  br label %if.end.26

if.end.26:                                        ; preds = %if.else.18, %if.end.17
  call void @Perl_pop_scope()
  ret void
}

declare void @Perl_pad_fixup_inner_anons(%struct.av*, %struct.cv*, %struct.cv*) #1

declare i8* @strrchr(i8*, i32) #1

declare void @Perl_pad_tidy(i32) #1

declare %struct.sv* @Perl_newSV(i64) #1

declare %struct.gv* @Perl_gv_HVadd(%struct.gv*) #1

declare signext i8 @Perl_hv_exists(%struct.hv*, i8*, i32) #1

declare %struct.av* @Perl_newAV() #1

declare void @Perl_av_push(%struct.av*, %struct.sv*) #1

declare void @Perl_call_list(i32, %struct.av*) #1

declare void @Perl_av_unshift(%struct.av*, i32) #1

declare %struct.sv** @Perl_av_store(%struct.av*, i32, %struct.sv*) #1

; Function Attrs: nounwind uwtable
define %struct.cv* @Perl_newXS(i8* %name, void (%struct.cv*)* %subaddr, i8* %filename) #0 {
entry:
  %name.addr = alloca i8*, align 8
  %subaddr.addr = alloca void (%struct.cv*)*, align 8
  %filename.addr = alloca i8*, align 8
  %gv = alloca %struct.gv*, align 8
  %cv = alloca %struct.cv*, align 8
  %oldline = alloca i32, align 4
  %s = alloca i8*, align 8
  store i8* %name, i8** %name.addr, align 8
  store void (%struct.cv*)* %subaddr, void (%struct.cv*)** %subaddr.addr, align 8
  store i8* %filename, i8** %filename.addr, align 8
  %0 = load i8*, i8** %name.addr, align 8
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load i8*, i8** %name.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %2 = load %struct.hv*, %struct.hv** @PL_curstash, align 8
  %tobool1 = icmp ne %struct.hv* %2, null
  %cond = select i1 %tobool1, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.66, i32 0, i32 0), i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.67, i32 0, i32 0)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond2 = phi i8* [ %1, %cond.true ], [ %cond, %cond.false ]
  %call = call %struct.gv* @Perl_gv_fetchpv(i8* %cond2, i32 2, i32 12)
  store %struct.gv* %call, %struct.gv** %gv, align 8
  %3 = load i8*, i8** %name.addr, align 8
  %tobool3 = icmp ne i8* %3, null
  br i1 %tobool3, label %cond.true.4, label %cond.false.5

cond.true.4:                                      ; preds = %cond.end
  %4 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any = getelementptr inbounds %struct.gv, %struct.gv* %4, i32 0, i32 0
  %5 = load %struct.xpvgv*, %struct.xpvgv** %sv_any, align 8
  %xgv_gp = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %5, i32 0, i32 7
  %6 = load %struct.gp*, %struct.gp** %xgv_gp, align 8
  %gp_cv = getelementptr inbounds %struct.gp, %struct.gp* %6, i32 0, i32 7
  %7 = load %struct.cv*, %struct.cv** %gp_cv, align 8
  br label %cond.end.6

cond.false.5:                                     ; preds = %cond.end
  br label %cond.end.6

cond.end.6:                                       ; preds = %cond.false.5, %cond.true.4
  %cond7 = phi %struct.cv* [ %7, %cond.true.4 ], [ null, %cond.false.5 ]
  store %struct.cv* %cond7, %struct.cv** %cv, align 8
  %tobool8 = icmp ne %struct.cv* %cond7, null
  br i1 %tobool8, label %if.then, label %if.end.73

if.then:                                          ; preds = %cond.end.6
  %8 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any9 = getelementptr inbounds %struct.gv, %struct.gv* %8, i32 0, i32 0
  %9 = load %struct.xpvgv*, %struct.xpvgv** %sv_any9, align 8
  %xgv_gp10 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %9, i32 0, i32 7
  %10 = load %struct.gp*, %struct.gp** %xgv_gp10, align 8
  %gp_cvgen = getelementptr inbounds %struct.gp, %struct.gp* %10, i32 0, i32 8
  %11 = load i32, i32* %gp_cvgen, align 4
  %tobool11 = icmp ne i32 %11, 0
  br i1 %tobool11, label %if.then.12, label %if.else

if.then.12:                                       ; preds = %if.then
  %12 = load %struct.cv*, %struct.cv** %cv, align 8
  %13 = bitcast %struct.cv* %12 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %13)
  store %struct.cv* null, %struct.cv** %cv, align 8
  br label %if.end.72

if.else:                                          ; preds = %if.then
  %14 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any13 = getelementptr inbounds %struct.cv, %struct.cv* %14, i32 0, i32 0
  %15 = load %struct.xpvcv*, %struct.xpvcv** %sv_any13, align 8
  %xcv_root = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %15, i32 0, i32 9
  %16 = load %struct.op*, %struct.op** %xcv_root, align 8
  %tobool14 = icmp ne %struct.op* %16, null
  br i1 %tobool14, label %if.then.20, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else
  %17 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any15 = getelementptr inbounds %struct.cv, %struct.cv* %17, i32 0, i32 0
  %18 = load %struct.xpvcv*, %struct.xpvcv** %sv_any15, align 8
  %xcv_xsub = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %18, i32 0, i32 10
  %19 = load void (%struct.cv*)*, void (%struct.cv*)** %xcv_xsub, align 8
  %tobool16 = icmp ne void (%struct.cv*)* %19, null
  br i1 %tobool16, label %if.then.20, label %lor.lhs.false.17

lor.lhs.false.17:                                 ; preds = %lor.lhs.false
  %20 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any18 = getelementptr inbounds %struct.gv, %struct.gv* %20, i32 0, i32 0
  %21 = load %struct.xpvgv*, %struct.xpvgv** %sv_any18, align 8
  %xgv_flags = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %21, i32 0, i32 11
  %22 = load i8, i8* %xgv_flags, align 1
  %conv = zext i8 %22 to i32
  %and = and i32 %conv, 4
  %tobool19 = icmp ne i32 %and, 0
  br i1 %tobool19, label %if.then.20, label %if.end.71

if.then.20:                                       ; preds = %lor.lhs.false.17, %lor.lhs.false, %if.else
  %23 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings = getelementptr inbounds %struct.cop, %struct.cop* %23, i32 0, i32 14
  %24 = load %struct.sv*, %struct.sv** %cop_warnings, align 8
  %cmp = icmp ne %struct.sv* %24, null
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false.35

land.lhs.true:                                    ; preds = %if.then.20
  %25 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings22 = getelementptr inbounds %struct.cop, %struct.cop* %25, i32 0, i32 14
  %26 = load %struct.sv*, %struct.sv** %cop_warnings22, align 8
  %cmp23 = icmp ne %struct.sv* %26, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 2)
  br i1 %cmp23, label %land.lhs.true.25, label %lor.lhs.false.35

land.lhs.true.25:                                 ; preds = %land.lhs.true
  %27 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings26 = getelementptr inbounds %struct.cop, %struct.cop* %27, i32 0, i32 14
  %28 = load %struct.sv*, %struct.sv** %cop_warnings26, align 8
  %cmp27 = icmp eq %struct.sv* %28, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 1)
  br i1 %cmp27, label %land.lhs.true.43, label %lor.lhs.false.29

lor.lhs.false.29:                                 ; preds = %land.lhs.true.25
  %29 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings30 = getelementptr inbounds %struct.cop, %struct.cop* %29, i32 0, i32 14
  %30 = load %struct.sv*, %struct.sv** %cop_warnings30, align 8
  %sv_any31 = getelementptr inbounds %struct.sv, %struct.sv* %30, i32 0, i32 0
  %31 = load i8*, i8** %sv_any31, align 8
  %32 = bitcast i8* %31 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %32, i32 0, i32 0
  %33 = load i8*, i8** %xpv_pv, align 8
  %arrayidx = getelementptr inbounds i8, i8* %33, i64 4
  %34 = load i8, i8* %arrayidx, align 1
  %conv32 = sext i8 %34 to i32
  %and33 = and i32 %conv32, 64
  %tobool34 = icmp ne i32 %and33, 0
  br i1 %tobool34, label %land.lhs.true.43, label %lor.lhs.false.35

lor.lhs.false.35:                                 ; preds = %lor.lhs.false.29, %land.lhs.true, %if.then.20
  %35 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings36 = getelementptr inbounds %struct.cop, %struct.cop* %35, i32 0, i32 14
  %36 = load %struct.sv*, %struct.sv** %cop_warnings36, align 8
  %cmp37 = icmp eq %struct.sv* %36, null
  br i1 %cmp37, label %land.lhs.true.39, label %if.end.70

land.lhs.true.39:                                 ; preds = %lor.lhs.false.35
  %37 = load i8, i8* @PL_dowarn, align 1
  %conv40 = zext i8 %37 to i32
  %and41 = and i32 %conv40, 1
  %tobool42 = icmp ne i32 %and41, 0
  br i1 %tobool42, label %land.lhs.true.43, label %if.end.70

land.lhs.true.43:                                 ; preds = %land.lhs.true.39, %lor.lhs.false.29, %land.lhs.true.25
  %38 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any44 = getelementptr inbounds %struct.cv, %struct.cv* %38, i32 0, i32 0
  %39 = load %struct.xpvcv*, %struct.xpvcv** %sv_any44, align 8
  %xcv_gv = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %39, i32 0, i32 12
  %40 = load %struct.gv*, %struct.gv** %xcv_gv, align 8
  %tobool45 = icmp ne %struct.gv* %40, null
  br i1 %tobool45, label %land.lhs.true.46, label %if.then.59

land.lhs.true.46:                                 ; preds = %land.lhs.true.43
  %41 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any47 = getelementptr inbounds %struct.cv, %struct.cv* %41, i32 0, i32 0
  %42 = load %struct.xpvcv*, %struct.xpvcv** %sv_any47, align 8
  %xcv_gv48 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %42, i32 0, i32 12
  %43 = load %struct.gv*, %struct.gv** %xcv_gv48, align 8
  %sv_any49 = getelementptr inbounds %struct.gv, %struct.gv* %43, i32 0, i32 0
  %44 = load %struct.xpvgv*, %struct.xpvgv** %sv_any49, align 8
  %xgv_stash = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %44, i32 0, i32 10
  %45 = load %struct.hv*, %struct.hv** %xgv_stash, align 8
  %tobool50 = icmp ne %struct.hv* %45, null
  br i1 %tobool50, label %land.lhs.true.51, label %if.then.59

land.lhs.true.51:                                 ; preds = %land.lhs.true.46
  %46 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any52 = getelementptr inbounds %struct.cv, %struct.cv* %46, i32 0, i32 0
  %47 = load %struct.xpvcv*, %struct.xpvcv** %sv_any52, align 8
  %xcv_gv53 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %47, i32 0, i32 12
  %48 = load %struct.gv*, %struct.gv** %xcv_gv53, align 8
  %sv_any54 = getelementptr inbounds %struct.gv, %struct.gv* %48, i32 0, i32 0
  %49 = load %struct.xpvgv*, %struct.xpvgv** %sv_any54, align 8
  %xgv_stash55 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %49, i32 0, i32 10
  %50 = load %struct.hv*, %struct.hv** %xgv_stash55, align 8
  %sv_any56 = getelementptr inbounds %struct.hv, %struct.hv* %50, i32 0, i32 0
  %51 = load %struct.xpvhv*, %struct.xpvhv** %sv_any56, align 8
  %xhv_name = getelementptr inbounds %struct.xpvhv, %struct.xpvhv* %51, i32 0, i32 10
  %52 = load i8*, i8** %xhv_name, align 8
  %call57 = call i32 @strcmp(i8* %52, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.79, i32 0, i32 0))
  %tobool58 = icmp ne i32 %call57, 0
  br i1 %tobool58, label %if.then.59, label %if.end.70

if.then.59:                                       ; preds = %land.lhs.true.51, %land.lhs.true.46, %land.lhs.true.43
  %53 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_line = getelementptr inbounds %struct.cop, %struct.cop* %53, i32 0, i32 13
  %54 = load i32, i32* %cop_line, align 4
  store i32 %54, i32* %oldline, align 4
  %55 = load i32, i32* @PL_copline, align 4
  %cmp60 = icmp ne i32 %55, -1
  br i1 %cmp60, label %if.then.62, label %if.end

if.then.62:                                       ; preds = %if.then.59
  %56 = load i32, i32* @PL_copline, align 4
  %57 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_line63 = getelementptr inbounds %struct.cop, %struct.cop* %57, i32 0, i32 13
  store i32 %56, i32* %cop_line63, align 4
  br label %if.end

if.end:                                           ; preds = %if.then.62, %if.then.59
  %58 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any64 = getelementptr inbounds %struct.cv, %struct.cv* %58, i32 0, i32 0
  %59 = load %struct.xpvcv*, %struct.xpvcv** %sv_any64, align 8
  %xcv_flags = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %59, i32 0, i32 17
  %60 = load i16, i16* %xcv_flags, align 2
  %conv65 = zext i16 %60 to i32
  %and66 = and i32 %conv65, 512
  %tobool67 = icmp ne i32 %and66, 0
  %cond68 = select i1 %tobool67, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.70, i32 0, i32 0), i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.71, i32 0, i32 0)
  %61 = load i8*, i8** %name.addr, align 8
  call void (i32, i8*, ...) @Perl_warner(i32 19, i8* %cond68, i8* %61)
  %62 = load i32, i32* %oldline, align 4
  %63 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_line69 = getelementptr inbounds %struct.cop, %struct.cop* %63, i32 0, i32 13
  store i32 %62, i32* %cop_line69, align 4
  br label %if.end.70

if.end.70:                                        ; preds = %if.end, %land.lhs.true.51, %land.lhs.true.39, %lor.lhs.false.35
  %64 = load %struct.cv*, %struct.cv** %cv, align 8
  %65 = bitcast %struct.cv* %64 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %65)
  store %struct.cv* null, %struct.cv** %cv, align 8
  br label %if.end.71

if.end.71:                                        ; preds = %if.end.70, %lor.lhs.false.17
  br label %if.end.72

if.end.72:                                        ; preds = %if.end.71, %if.then.12
  br label %if.end.73

if.end.73:                                        ; preds = %if.end.72, %cond.end.6
  %66 = load %struct.cv*, %struct.cv** %cv, align 8
  %tobool74 = icmp ne %struct.cv* %66, null
  br i1 %tobool74, label %if.then.75, label %if.else.76

if.then.75:                                       ; preds = %if.end.73
  %67 = load %struct.cv*, %struct.cv** %cv, align 8
  call void @Perl_cv_undef(%struct.cv* %67)
  br label %if.end.88

if.else.76:                                       ; preds = %if.end.73
  %call77 = call %struct.sv* @Perl_newSV(i64 0)
  %68 = bitcast %struct.sv* %call77 to %struct.cv*
  store %struct.cv* %68, %struct.cv** %cv, align 8
  %69 = load %struct.cv*, %struct.cv** %cv, align 8
  %70 = bitcast %struct.cv* %69 to %struct.sv*
  %call78 = call signext i8 @Perl_sv_upgrade(%struct.sv* %70, i32 12)
  %71 = load i8*, i8** %name.addr, align 8
  %tobool79 = icmp ne i8* %71, null
  br i1 %tobool79, label %if.then.80, label %if.end.87

if.then.80:                                       ; preds = %if.else.76
  %72 = load %struct.cv*, %struct.cv** %cv, align 8
  %73 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any81 = getelementptr inbounds %struct.gv, %struct.gv* %73, i32 0, i32 0
  %74 = load %struct.xpvgv*, %struct.xpvgv** %sv_any81, align 8
  %xgv_gp82 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %74, i32 0, i32 7
  %75 = load %struct.gp*, %struct.gp** %xgv_gp82, align 8
  %gp_cv83 = getelementptr inbounds %struct.gp, %struct.gp* %75, i32 0, i32 7
  store %struct.cv* %72, %struct.cv** %gp_cv83, align 8
  %76 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any84 = getelementptr inbounds %struct.gv, %struct.gv* %76, i32 0, i32 0
  %77 = load %struct.xpvgv*, %struct.xpvgv** %sv_any84, align 8
  %xgv_gp85 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %77, i32 0, i32 7
  %78 = load %struct.gp*, %struct.gp** %xgv_gp85, align 8
  %gp_cvgen86 = getelementptr inbounds %struct.gp, %struct.gp* %78, i32 0, i32 8
  store i32 0, i32* %gp_cvgen86, align 4
  %79 = load i32, i32* @PL_sub_generation, align 4
  %inc = add i32 %79, 1
  store i32 %inc, i32* @PL_sub_generation, align 4
  br label %if.end.87

if.end.87:                                        ; preds = %if.then.80, %if.else.76
  br label %if.end.88

if.end.88:                                        ; preds = %if.end.87, %if.then.75
  %80 = load %struct.gv*, %struct.gv** %gv, align 8
  %81 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any89 = getelementptr inbounds %struct.cv, %struct.cv* %81, i32 0, i32 0
  %82 = load %struct.xpvcv*, %struct.xpvcv** %sv_any89, align 8
  %xcv_gv90 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %82, i32 0, i32 12
  store %struct.gv* %80, %struct.gv** %xcv_gv90, align 8
  %83 = load i8*, i8** %filename.addr, align 8
  %call91 = call %struct.gv* @Perl_gv_fetchfile(i8* %83)
  %84 = load i8*, i8** %filename.addr, align 8
  %85 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any92 = getelementptr inbounds %struct.cv, %struct.cv* %85, i32 0, i32 0
  %86 = load %struct.xpvcv*, %struct.xpvcv** %sv_any92, align 8
  %xcv_file = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %86, i32 0, i32 13
  store i8* %84, i8** %xcv_file, align 8
  %87 = load void (%struct.cv*)*, void (%struct.cv*)** %subaddr.addr, align 8
  %88 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any93 = getelementptr inbounds %struct.cv, %struct.cv* %88, i32 0, i32 0
  %89 = load %struct.xpvcv*, %struct.xpvcv** %sv_any93, align 8
  %xcv_xsub94 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %89, i32 0, i32 10
  store void (%struct.cv*)* %87, void (%struct.cv*)** %xcv_xsub94, align 8
  %90 = load i8*, i8** %name.addr, align 8
  %tobool95 = icmp ne i8* %90, null
  br i1 %tobool95, label %if.then.96, label %if.else.230

if.then.96:                                       ; preds = %if.end.88
  %91 = load i8*, i8** %name.addr, align 8
  %call97 = call i8* @strrchr(i8* %91, i32 58)
  store i8* %call97, i8** %s, align 8
  %92 = load i8*, i8** %s, align 8
  %tobool98 = icmp ne i8* %92, null
  br i1 %tobool98, label %if.then.99, label %if.else.100

if.then.99:                                       ; preds = %if.then.96
  %93 = load i8*, i8** %s, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %93, i32 1
  store i8* %incdec.ptr, i8** %s, align 8
  br label %if.end.101

if.else.100:                                      ; preds = %if.then.96
  %94 = load i8*, i8** %name.addr, align 8
  store i8* %94, i8** %s, align 8
  br label %if.end.101

if.end.101:                                       ; preds = %if.else.100, %if.then.99
  %95 = load i8*, i8** %s, align 8
  %96 = load i8, i8* %95, align 1
  %conv102 = sext i8 %96 to i32
  %cmp103 = icmp ne i32 %conv102, 66
  br i1 %cmp103, label %land.lhs.true.105, label %if.end.118

land.lhs.true.105:                                ; preds = %if.end.101
  %97 = load i8*, i8** %s, align 8
  %98 = load i8, i8* %97, align 1
  %conv106 = sext i8 %98 to i32
  %cmp107 = icmp ne i32 %conv106, 69
  br i1 %cmp107, label %land.lhs.true.109, label %if.end.118

land.lhs.true.109:                                ; preds = %land.lhs.true.105
  %99 = load i8*, i8** %s, align 8
  %100 = load i8, i8* %99, align 1
  %conv110 = sext i8 %100 to i32
  %cmp111 = icmp ne i32 %conv110, 67
  br i1 %cmp111, label %land.lhs.true.113, label %if.end.118

land.lhs.true.113:                                ; preds = %land.lhs.true.109
  %101 = load i8*, i8** %s, align 8
  %102 = load i8, i8* %101, align 1
  %conv114 = sext i8 %102 to i32
  %cmp115 = icmp ne i32 %conv114, 73
  br i1 %cmp115, label %if.then.117, label %if.end.118

if.then.117:                                      ; preds = %land.lhs.true.113
  br label %done

if.end.118:                                       ; preds = %land.lhs.true.113, %land.lhs.true.109, %land.lhs.true.105, %if.end.101
  %103 = load i8*, i8** %s, align 8
  %call119 = call i32 @strcmp(i8* %103, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.51, i32 0, i32 0))
  %tobool120 = icmp ne i32 %call119, 0
  br i1 %tobool120, label %if.else.129, label %if.then.121

if.then.121:                                      ; preds = %if.end.118
  %104 = load %struct.av*, %struct.av** @PL_beginav, align 8
  %tobool122 = icmp ne %struct.av* %104, null
  br i1 %tobool122, label %if.end.125, label %if.then.123

if.then.123:                                      ; preds = %if.then.121
  %call124 = call %struct.av* @Perl_newAV()
  store %struct.av* %call124, %struct.av** @PL_beginav, align 8
  br label %if.end.125

if.end.125:                                       ; preds = %if.then.123, %if.then.121
  %105 = load %struct.av*, %struct.av** @PL_beginav, align 8
  %106 = load %struct.cv*, %struct.cv** %cv, align 8
  %107 = bitcast %struct.cv* %106 to %struct.sv*
  call void @Perl_av_push(%struct.av* %105, %struct.sv* %107)
  %108 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any126 = getelementptr inbounds %struct.gv, %struct.gv* %108, i32 0, i32 0
  %109 = load %struct.xpvgv*, %struct.xpvgv** %sv_any126, align 8
  %xgv_gp127 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %109, i32 0, i32 7
  %110 = load %struct.gp*, %struct.gp** %xgv_gp127, align 8
  %gp_cv128 = getelementptr inbounds %struct.gp, %struct.gp* %110, i32 0, i32 7
  store %struct.cv* null, %struct.cv** %gp_cv128, align 8
  br label %if.end.229

if.else.129:                                      ; preds = %if.end.118
  %111 = load i8*, i8** %s, align 8
  %call130 = call i32 @strcmp(i8* %111, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.74, i32 0, i32 0))
  %tobool131 = icmp ne i32 %call130, 0
  br i1 %tobool131, label %if.else.141, label %if.then.132

if.then.132:                                      ; preds = %if.else.129
  %112 = load %struct.av*, %struct.av** @PL_endav, align 8
  %tobool133 = icmp ne %struct.av* %112, null
  br i1 %tobool133, label %if.end.136, label %if.then.134

if.then.134:                                      ; preds = %if.then.132
  %call135 = call %struct.av* @Perl_newAV()
  store %struct.av* %call135, %struct.av** @PL_endav, align 8
  br label %if.end.136

if.end.136:                                       ; preds = %if.then.134, %if.then.132
  %113 = load %struct.av*, %struct.av** @PL_endav, align 8
  call void @Perl_av_unshift(%struct.av* %113, i32 1)
  %114 = load %struct.av*, %struct.av** @PL_endav, align 8
  %115 = load %struct.cv*, %struct.cv** %cv, align 8
  %116 = bitcast %struct.cv* %115 to %struct.sv*
  %call137 = call %struct.sv** @Perl_av_store(%struct.av* %114, i32 0, %struct.sv* %116)
  %117 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any138 = getelementptr inbounds %struct.gv, %struct.gv* %117, i32 0, i32 0
  %118 = load %struct.xpvgv*, %struct.xpvgv** %sv_any138, align 8
  %xgv_gp139 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %118, i32 0, i32 7
  %119 = load %struct.gp*, %struct.gp** %xgv_gp139, align 8
  %gp_cv140 = getelementptr inbounds %struct.gp, %struct.gp* %119, i32 0, i32 7
  store %struct.cv* null, %struct.cv** %gp_cv140, align 8
  br label %if.end.228

if.else.141:                                      ; preds = %if.else.129
  %120 = load i8*, i8** %s, align 8
  %call142 = call i32 @strcmp(i8* %120, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.75, i32 0, i32 0))
  %tobool143 = icmp ne i32 %call142, 0
  br i1 %tobool143, label %if.else.184, label %if.then.144

if.then.144:                                      ; preds = %if.else.141
  %121 = load %struct.av*, %struct.av** @PL_checkav, align 8
  %tobool145 = icmp ne %struct.av* %121, null
  br i1 %tobool145, label %if.end.148, label %if.then.146

if.then.146:                                      ; preds = %if.then.144
  %call147 = call %struct.av* @Perl_newAV()
  store %struct.av* %call147, %struct.av** @PL_checkav, align 8
  br label %if.end.148

if.end.148:                                       ; preds = %if.then.146, %if.then.144
  %122 = load %struct.op*, %struct.op** @PL_main_start, align 8
  %tobool149 = icmp ne %struct.op* %122, null
  br i1 %tobool149, label %land.lhs.true.150, label %if.end.179

land.lhs.true.150:                                ; preds = %if.end.148
  %123 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings151 = getelementptr inbounds %struct.cop, %struct.cop* %123, i32 0, i32 14
  %124 = load %struct.sv*, %struct.sv** %cop_warnings151, align 8
  %cmp152 = icmp ne %struct.sv* %124, null
  br i1 %cmp152, label %land.lhs.true.154, label %lor.lhs.false.170

land.lhs.true.154:                                ; preds = %land.lhs.true.150
  %125 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings155 = getelementptr inbounds %struct.cop, %struct.cop* %125, i32 0, i32 14
  %126 = load %struct.sv*, %struct.sv** %cop_warnings155, align 8
  %cmp156 = icmp ne %struct.sv* %126, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 2)
  br i1 %cmp156, label %land.lhs.true.158, label %lor.lhs.false.170

land.lhs.true.158:                                ; preds = %land.lhs.true.154
  %127 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings159 = getelementptr inbounds %struct.cop, %struct.cop* %127, i32 0, i32 14
  %128 = load %struct.sv*, %struct.sv** %cop_warnings159, align 8
  %cmp160 = icmp eq %struct.sv* %128, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 1)
  br i1 %cmp160, label %if.then.178, label %lor.lhs.false.162

lor.lhs.false.162:                                ; preds = %land.lhs.true.158
  %129 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings163 = getelementptr inbounds %struct.cop, %struct.cop* %129, i32 0, i32 14
  %130 = load %struct.sv*, %struct.sv** %cop_warnings163, align 8
  %sv_any164 = getelementptr inbounds %struct.sv, %struct.sv* %130, i32 0, i32 0
  %131 = load i8*, i8** %sv_any164, align 8
  %132 = bitcast i8* %131 to %struct.xpv*
  %xpv_pv165 = getelementptr inbounds %struct.xpv, %struct.xpv* %132, i32 0, i32 0
  %133 = load i8*, i8** %xpv_pv165, align 8
  %arrayidx166 = getelementptr inbounds i8, i8* %133, i64 11
  %134 = load i8, i8* %arrayidx166, align 1
  %conv167 = sext i8 %134 to i32
  %and168 = and i32 %conv167, 4
  %tobool169 = icmp ne i32 %and168, 0
  br i1 %tobool169, label %if.then.178, label %lor.lhs.false.170

lor.lhs.false.170:                                ; preds = %lor.lhs.false.162, %land.lhs.true.154, %land.lhs.true.150
  %135 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings171 = getelementptr inbounds %struct.cop, %struct.cop* %135, i32 0, i32 14
  %136 = load %struct.sv*, %struct.sv** %cop_warnings171, align 8
  %cmp172 = icmp eq %struct.sv* %136, null
  br i1 %cmp172, label %land.lhs.true.174, label %if.end.179

land.lhs.true.174:                                ; preds = %lor.lhs.false.170
  %137 = load i8, i8* @PL_dowarn, align 1
  %conv175 = zext i8 %137 to i32
  %and176 = and i32 %conv175, 1
  %tobool177 = icmp ne i32 %and176, 0
  br i1 %tobool177, label %if.then.178, label %if.end.179

if.then.178:                                      ; preds = %land.lhs.true.174, %lor.lhs.false.162, %land.lhs.true.158
  call void (i32, i8*, ...) @Perl_warner(i32 45, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.76, i32 0, i32 0))
  br label %if.end.179

if.end.179:                                       ; preds = %if.then.178, %land.lhs.true.174, %lor.lhs.false.170, %if.end.148
  %138 = load %struct.av*, %struct.av** @PL_checkav, align 8
  call void @Perl_av_unshift(%struct.av* %138, i32 1)
  %139 = load %struct.av*, %struct.av** @PL_checkav, align 8
  %140 = load %struct.cv*, %struct.cv** %cv, align 8
  %141 = bitcast %struct.cv* %140 to %struct.sv*
  %call180 = call %struct.sv** @Perl_av_store(%struct.av* %139, i32 0, %struct.sv* %141)
  %142 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any181 = getelementptr inbounds %struct.gv, %struct.gv* %142, i32 0, i32 0
  %143 = load %struct.xpvgv*, %struct.xpvgv** %sv_any181, align 8
  %xgv_gp182 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %143, i32 0, i32 7
  %144 = load %struct.gp*, %struct.gp** %xgv_gp182, align 8
  %gp_cv183 = getelementptr inbounds %struct.gp, %struct.gp* %144, i32 0, i32 7
  store %struct.cv* null, %struct.cv** %gp_cv183, align 8
  br label %if.end.227

if.else.184:                                      ; preds = %if.else.141
  %145 = load i8*, i8** %s, align 8
  %call185 = call i32 @strcmp(i8* %145, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.77, i32 0, i32 0))
  %tobool186 = icmp ne i32 %call185, 0
  br i1 %tobool186, label %if.end.226, label %if.then.187

if.then.187:                                      ; preds = %if.else.184
  %146 = load %struct.av*, %struct.av** @PL_initav, align 8
  %tobool188 = icmp ne %struct.av* %146, null
  br i1 %tobool188, label %if.end.191, label %if.then.189

if.then.189:                                      ; preds = %if.then.187
  %call190 = call %struct.av* @Perl_newAV()
  store %struct.av* %call190, %struct.av** @PL_initav, align 8
  br label %if.end.191

if.end.191:                                       ; preds = %if.then.189, %if.then.187
  %147 = load %struct.op*, %struct.op** @PL_main_start, align 8
  %tobool192 = icmp ne %struct.op* %147, null
  br i1 %tobool192, label %land.lhs.true.193, label %if.end.222

land.lhs.true.193:                                ; preds = %if.end.191
  %148 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings194 = getelementptr inbounds %struct.cop, %struct.cop* %148, i32 0, i32 14
  %149 = load %struct.sv*, %struct.sv** %cop_warnings194, align 8
  %cmp195 = icmp ne %struct.sv* %149, null
  br i1 %cmp195, label %land.lhs.true.197, label %lor.lhs.false.213

land.lhs.true.197:                                ; preds = %land.lhs.true.193
  %150 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings198 = getelementptr inbounds %struct.cop, %struct.cop* %150, i32 0, i32 14
  %151 = load %struct.sv*, %struct.sv** %cop_warnings198, align 8
  %cmp199 = icmp ne %struct.sv* %151, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 2)
  br i1 %cmp199, label %land.lhs.true.201, label %lor.lhs.false.213

land.lhs.true.201:                                ; preds = %land.lhs.true.197
  %152 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings202 = getelementptr inbounds %struct.cop, %struct.cop* %152, i32 0, i32 14
  %153 = load %struct.sv*, %struct.sv** %cop_warnings202, align 8
  %cmp203 = icmp eq %struct.sv* %153, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 1)
  br i1 %cmp203, label %if.then.221, label %lor.lhs.false.205

lor.lhs.false.205:                                ; preds = %land.lhs.true.201
  %154 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings206 = getelementptr inbounds %struct.cop, %struct.cop* %154, i32 0, i32 14
  %155 = load %struct.sv*, %struct.sv** %cop_warnings206, align 8
  %sv_any207 = getelementptr inbounds %struct.sv, %struct.sv* %155, i32 0, i32 0
  %156 = load i8*, i8** %sv_any207, align 8
  %157 = bitcast i8* %156 to %struct.xpv*
  %xpv_pv208 = getelementptr inbounds %struct.xpv, %struct.xpv* %157, i32 0, i32 0
  %158 = load i8*, i8** %xpv_pv208, align 8
  %arrayidx209 = getelementptr inbounds i8, i8* %158, i64 11
  %159 = load i8, i8* %arrayidx209, align 1
  %conv210 = sext i8 %159 to i32
  %and211 = and i32 %conv210, 4
  %tobool212 = icmp ne i32 %and211, 0
  br i1 %tobool212, label %if.then.221, label %lor.lhs.false.213

lor.lhs.false.213:                                ; preds = %lor.lhs.false.205, %land.lhs.true.197, %land.lhs.true.193
  %160 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings214 = getelementptr inbounds %struct.cop, %struct.cop* %160, i32 0, i32 14
  %161 = load %struct.sv*, %struct.sv** %cop_warnings214, align 8
  %cmp215 = icmp eq %struct.sv* %161, null
  br i1 %cmp215, label %land.lhs.true.217, label %if.end.222

land.lhs.true.217:                                ; preds = %lor.lhs.false.213
  %162 = load i8, i8* @PL_dowarn, align 1
  %conv218 = zext i8 %162 to i32
  %and219 = and i32 %conv218, 1
  %tobool220 = icmp ne i32 %and219, 0
  br i1 %tobool220, label %if.then.221, label %if.end.222

if.then.221:                                      ; preds = %land.lhs.true.217, %lor.lhs.false.205, %land.lhs.true.201
  call void (i32, i8*, ...) @Perl_warner(i32 45, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.78, i32 0, i32 0))
  br label %if.end.222

if.end.222:                                       ; preds = %if.then.221, %land.lhs.true.217, %lor.lhs.false.213, %if.end.191
  %163 = load %struct.av*, %struct.av** @PL_initav, align 8
  %164 = load %struct.cv*, %struct.cv** %cv, align 8
  %165 = bitcast %struct.cv* %164 to %struct.sv*
  call void @Perl_av_push(%struct.av* %163, %struct.sv* %165)
  %166 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any223 = getelementptr inbounds %struct.gv, %struct.gv* %166, i32 0, i32 0
  %167 = load %struct.xpvgv*, %struct.xpvgv** %sv_any223, align 8
  %xgv_gp224 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %167, i32 0, i32 7
  %168 = load %struct.gp*, %struct.gp** %xgv_gp224, align 8
  %gp_cv225 = getelementptr inbounds %struct.gp, %struct.gp* %168, i32 0, i32 7
  store %struct.cv* null, %struct.cv** %gp_cv225, align 8
  br label %if.end.226

if.end.226:                                       ; preds = %if.end.222, %if.else.184
  br label %if.end.227

if.end.227:                                       ; preds = %if.end.226, %if.end.179
  br label %if.end.228

if.end.228:                                       ; preds = %if.end.227, %if.end.136
  br label %if.end.229

if.end.229:                                       ; preds = %if.end.228, %if.end.125
  br label %if.end.235

if.else.230:                                      ; preds = %if.end.88
  %169 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any231 = getelementptr inbounds %struct.cv, %struct.cv* %169, i32 0, i32 0
  %170 = load %struct.xpvcv*, %struct.xpvcv** %sv_any231, align 8
  %xcv_flags232 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %170, i32 0, i32 17
  %171 = load i16, i16* %xcv_flags232, align 2
  %conv233 = zext i16 %171 to i32
  %or = or i32 %conv233, 4
  %conv234 = trunc i32 %or to i16
  store i16 %conv234, i16* %xcv_flags232, align 2
  br label %if.end.235

if.end.235:                                       ; preds = %if.else.230, %if.end.229
  br label %done

done:                                             ; preds = %if.end.235, %if.then.117
  %172 = load %struct.cv*, %struct.cv** %cv, align 8
  ret %struct.cv* %172
}

declare %struct.gv* @Perl_gv_fetchfile(i8*) #1

; Function Attrs: nounwind uwtable
define void @Perl_newFORM(i32 %floor, %struct.op* %o, %struct.op* %block) #0 {
entry:
  %floor.addr = alloca i32, align 4
  %o.addr = alloca %struct.op*, align 8
  %block.addr = alloca %struct.op*, align 8
  %cv = alloca %struct.cv*, align 8
  %name = alloca i8*, align 8
  %gv = alloca %struct.gv*, align 8
  %n_a = alloca i64, align 8
  %oldline = alloca i32, align 4
  store i32 %floor, i32* %floor.addr, align 4
  store %struct.op* %o, %struct.op** %o.addr, align 8
  store %struct.op* %block, %struct.op** %block.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %tobool = icmp ne %struct.op* %0, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load %struct.op*, %struct.op** %o.addr, align 8
  %2 = bitcast %struct.op* %1 to %struct.svop*
  %op_sv = getelementptr inbounds %struct.svop, %struct.svop* %2, i32 0, i32 8
  %3 = load %struct.sv*, %struct.sv** %op_sv, align 8
  store %struct.sv* %3, %struct.sv** @PL_Sv, align 8
  %4 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %4, i32 0, i32 2
  %5 = load i32, i32* %sv_flags, align 4
  %and = and i32 %5, 262144
  %cmp = icmp eq i32 %and, 262144
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  %6 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %6, i32 0, i32 0
  %7 = load i8*, i8** %sv_any, align 8
  %8 = bitcast i8* %7 to %struct.xpv*
  %xpv_cur = getelementptr inbounds %struct.xpv, %struct.xpv* %8, i32 0, i32 1
  %9 = load i64, i64* %xpv_cur, align 8
  store i64 %9, i64* %n_a, align 8
  %10 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any1 = getelementptr inbounds %struct.sv, %struct.sv* %10, i32 0, i32 0
  %11 = load i8*, i8** %sv_any1, align 8
  %12 = bitcast i8* %11 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %12, i32 0, i32 0
  %13 = load i8*, i8** %xpv_pv, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then
  %14 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call = call i8* @Perl_sv_2pv_flags(%struct.sv* %14, i64* %n_a, i32 2)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %13, %cond.true ], [ %call, %cond.false ]
  store i8* %cond, i8** %name, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  store i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.80, i32 0, i32 0), i8** %name, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %cond.end
  %15 = load i8*, i8** %name, align 8
  %call2 = call %struct.gv* @Perl_gv_fetchpv(i8* %15, i32 1, i32 14)
  store %struct.gv* %call2, %struct.gv** %gv, align 8
  %16 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any3 = getelementptr inbounds %struct.gv, %struct.gv* %16, i32 0, i32 0
  %17 = load %struct.xpvgv*, %struct.xpvgv** %sv_any3, align 8
  %xgv_flags = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %17, i32 0, i32 11
  %18 = load i8, i8* %xgv_flags, align 1
  %conv = zext i8 %18 to i32
  %or = or i32 %conv, 2
  %conv4 = trunc i32 %or to i8
  store i8 %conv4, i8* %xgv_flags, align 1
  %19 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any5 = getelementptr inbounds %struct.gv, %struct.gv* %19, i32 0, i32 0
  %20 = load %struct.xpvgv*, %struct.xpvgv** %sv_any5, align 8
  %xgv_gp = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %20, i32 0, i32 7
  %21 = load %struct.gp*, %struct.gp** %xgv_gp, align 8
  %gp_form = getelementptr inbounds %struct.gp, %struct.gp* %21, i32 0, i32 3
  %22 = load %struct.cv*, %struct.cv** %gp_form, align 8
  store %struct.cv* %22, %struct.cv** %cv, align 8
  %tobool6 = icmp ne %struct.cv* %22, null
  br i1 %tobool6, label %if.then.7, label %if.end.39

if.then.7:                                        ; preds = %if.end
  %23 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings = getelementptr inbounds %struct.cop, %struct.cop* %23, i32 0, i32 14
  %24 = load %struct.sv*, %struct.sv** %cop_warnings, align 8
  %cmp8 = icmp ne %struct.sv* %24, null
  br i1 %cmp8, label %land.lhs.true, label %lor.lhs.false.23

land.lhs.true:                                    ; preds = %if.then.7
  %25 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings10 = getelementptr inbounds %struct.cop, %struct.cop* %25, i32 0, i32 14
  %26 = load %struct.sv*, %struct.sv** %cop_warnings10, align 8
  %cmp11 = icmp ne %struct.sv* %26, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 2)
  br i1 %cmp11, label %land.lhs.true.13, label %lor.lhs.false.23

land.lhs.true.13:                                 ; preds = %land.lhs.true
  %27 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings14 = getelementptr inbounds %struct.cop, %struct.cop* %27, i32 0, i32 14
  %28 = load %struct.sv*, %struct.sv** %cop_warnings14, align 8
  %cmp15 = icmp eq %struct.sv* %28, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 1)
  br i1 %cmp15, label %if.then.31, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true.13
  %29 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings17 = getelementptr inbounds %struct.cop, %struct.cop* %29, i32 0, i32 14
  %30 = load %struct.sv*, %struct.sv** %cop_warnings17, align 8
  %sv_any18 = getelementptr inbounds %struct.sv, %struct.sv* %30, i32 0, i32 0
  %31 = load i8*, i8** %sv_any18, align 8
  %32 = bitcast i8* %31 to %struct.xpv*
  %xpv_pv19 = getelementptr inbounds %struct.xpv, %struct.xpv* %32, i32 0, i32 0
  %33 = load i8*, i8** %xpv_pv19, align 8
  %arrayidx = getelementptr inbounds i8, i8* %33, i64 4
  %34 = load i8, i8* %arrayidx, align 1
  %conv20 = sext i8 %34 to i32
  %and21 = and i32 %conv20, 64
  %tobool22 = icmp ne i32 %and21, 0
  br i1 %tobool22, label %if.then.31, label %lor.lhs.false.23

lor.lhs.false.23:                                 ; preds = %lor.lhs.false, %land.lhs.true, %if.then.7
  %35 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings24 = getelementptr inbounds %struct.cop, %struct.cop* %35, i32 0, i32 14
  %36 = load %struct.sv*, %struct.sv** %cop_warnings24, align 8
  %cmp25 = icmp eq %struct.sv* %36, null
  br i1 %cmp25, label %land.lhs.true.27, label %if.end.38

land.lhs.true.27:                                 ; preds = %lor.lhs.false.23
  %37 = load i8, i8* @PL_dowarn, align 1
  %conv28 = zext i8 %37 to i32
  %and29 = and i32 %conv28, 1
  %tobool30 = icmp ne i32 %and29, 0
  br i1 %tobool30, label %if.then.31, label %if.end.38

if.then.31:                                       ; preds = %land.lhs.true.27, %lor.lhs.false, %land.lhs.true.13
  %38 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_line = getelementptr inbounds %struct.cop, %struct.cop* %38, i32 0, i32 13
  %39 = load i32, i32* %cop_line, align 4
  store i32 %39, i32* %oldline, align 4
  %40 = load i32, i32* @PL_copline, align 4
  %cmp32 = icmp ne i32 %40, -1
  br i1 %cmp32, label %if.then.34, label %if.end.36

if.then.34:                                       ; preds = %if.then.31
  %41 = load i32, i32* @PL_copline, align 4
  %42 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_line35 = getelementptr inbounds %struct.cop, %struct.cop* %42, i32 0, i32 13
  store i32 %41, i32* %cop_line35, align 4
  br label %if.end.36

if.end.36:                                        ; preds = %if.then.34, %if.then.31
  %43 = load i8*, i8** %name, align 8
  call void (i32, i8*, ...) @Perl_warner(i32 19, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.81, i32 0, i32 0), i8* %43)
  %44 = load i32, i32* %oldline, align 4
  %45 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_line37 = getelementptr inbounds %struct.cop, %struct.cop* %45, i32 0, i32 13
  store i32 %44, i32* %cop_line37, align 4
  br label %if.end.38

if.end.38:                                        ; preds = %if.end.36, %land.lhs.true.27, %lor.lhs.false.23
  %46 = load %struct.cv*, %struct.cv** %cv, align 8
  %47 = bitcast %struct.cv* %46 to %struct.sv*
  call void @Perl_sv_free(%struct.sv* %47)
  br label %if.end.39

if.end.39:                                        ; preds = %if.end.38, %if.end
  %48 = load %struct.cv*, %struct.cv** @PL_compcv, align 8
  store %struct.cv* %48, %struct.cv** %cv, align 8
  %49 = load %struct.cv*, %struct.cv** %cv, align 8
  %50 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any40 = getelementptr inbounds %struct.gv, %struct.gv* %50, i32 0, i32 0
  %51 = load %struct.xpvgv*, %struct.xpvgv** %sv_any40, align 8
  %xgv_gp41 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %51, i32 0, i32 7
  %52 = load %struct.gp*, %struct.gp** %xgv_gp41, align 8
  %gp_form42 = getelementptr inbounds %struct.gp, %struct.gp* %52, i32 0, i32 3
  store %struct.cv* %49, %struct.cv** %gp_form42, align 8
  %53 = load %struct.gv*, %struct.gv** %gv, align 8
  %54 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any43 = getelementptr inbounds %struct.cv, %struct.cv* %54, i32 0, i32 0
  %55 = load %struct.xpvcv*, %struct.xpvcv** %sv_any43, align 8
  %xcv_gv = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %55, i32 0, i32 12
  store %struct.gv* %53, %struct.gv** %xcv_gv, align 8
  %56 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_filegv = getelementptr inbounds %struct.cop, %struct.cop* %56, i32 0, i32 10
  %57 = load %struct.gv*, %struct.gv** %cop_filegv, align 8
  %tobool44 = icmp ne %struct.gv* %57, null
  br i1 %tobool44, label %cond.true.45, label %cond.false.50

cond.true.45:                                     ; preds = %if.end.39
  %58 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_filegv46 = getelementptr inbounds %struct.cop, %struct.cop* %58, i32 0, i32 10
  %59 = load %struct.gv*, %struct.gv** %cop_filegv46, align 8
  %sv_any47 = getelementptr inbounds %struct.gv, %struct.gv* %59, i32 0, i32 0
  %60 = load %struct.xpvgv*, %struct.xpvgv** %sv_any47, align 8
  %xgv_gp48 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %60, i32 0, i32 7
  %61 = load %struct.gp*, %struct.gp** %xgv_gp48, align 8
  %gp_sv = getelementptr inbounds %struct.gp, %struct.gp* %61, i32 0, i32 0
  %62 = load %struct.sv*, %struct.sv** %gp_sv, align 8
  %tobool49 = icmp ne %struct.sv* %62, null
  br i1 %tobool49, label %cond.true.51, label %cond.false.64

cond.false.50:                                    ; preds = %if.end.39
  br i1 false, label %cond.true.51, label %cond.false.64

cond.true.51:                                     ; preds = %cond.false.50, %cond.true.45
  %63 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_filegv52 = getelementptr inbounds %struct.cop, %struct.cop* %63, i32 0, i32 10
  %64 = load %struct.gv*, %struct.gv** %cop_filegv52, align 8
  %tobool53 = icmp ne %struct.gv* %64, null
  br i1 %tobool53, label %cond.true.54, label %cond.false.59

cond.true.54:                                     ; preds = %cond.true.51
  %65 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_filegv55 = getelementptr inbounds %struct.cop, %struct.cop* %65, i32 0, i32 10
  %66 = load %struct.gv*, %struct.gv** %cop_filegv55, align 8
  %sv_any56 = getelementptr inbounds %struct.gv, %struct.gv* %66, i32 0, i32 0
  %67 = load %struct.xpvgv*, %struct.xpvgv** %sv_any56, align 8
  %xgv_gp57 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %67, i32 0, i32 7
  %68 = load %struct.gp*, %struct.gp** %xgv_gp57, align 8
  %gp_sv58 = getelementptr inbounds %struct.gp, %struct.gp* %68, i32 0, i32 0
  %69 = load %struct.sv*, %struct.sv** %gp_sv58, align 8
  br label %cond.end.60

cond.false.59:                                    ; preds = %cond.true.51
  br label %cond.end.60

cond.end.60:                                      ; preds = %cond.false.59, %cond.true.54
  %cond61 = phi %struct.sv* [ %69, %cond.true.54 ], [ null, %cond.false.59 ]
  %sv_any62 = getelementptr inbounds %struct.sv, %struct.sv* %cond61, i32 0, i32 0
  %70 = load i8*, i8** %sv_any62, align 8
  %71 = bitcast i8* %70 to %struct.xpv*
  %xpv_pv63 = getelementptr inbounds %struct.xpv, %struct.xpv* %71, i32 0, i32 0
  %72 = load i8*, i8** %xpv_pv63, align 8
  br label %cond.end.65

cond.false.64:                                    ; preds = %cond.false.50, %cond.true.45
  br label %cond.end.65

cond.end.65:                                      ; preds = %cond.false.64, %cond.end.60
  %cond66 = phi i8* [ %72, %cond.end.60 ], [ null, %cond.false.64 ]
  %73 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any67 = getelementptr inbounds %struct.cv, %struct.cv* %73, i32 0, i32 0
  %74 = load %struct.xpvcv*, %struct.xpvcv** %sv_any67, align 8
  %xcv_file = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %74, i32 0, i32 13
  store i8* %cond66, i8** %xcv_file, align 8
  call void @Perl_pad_tidy(i32 2)
  %75 = load %struct.op*, %struct.op** %block.addr, align 8
  %call68 = call %struct.op* @Perl_scalarseq(%struct.op* %75)
  %call69 = call %struct.op* @Perl_newUNOP(i32 207, i32 0, %struct.op* %call68)
  %76 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any70 = getelementptr inbounds %struct.cv, %struct.cv* %76, i32 0, i32 0
  %77 = load %struct.xpvcv*, %struct.xpvcv** %sv_any70, align 8
  %xcv_root = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %77, i32 0, i32 9
  store %struct.op* %call69, %struct.op** %xcv_root, align 8
  %78 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any71 = getelementptr inbounds %struct.cv, %struct.cv* %78, i32 0, i32 0
  %79 = load %struct.xpvcv*, %struct.xpvcv** %sv_any71, align 8
  %xcv_root72 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %79, i32 0, i32 9
  %80 = load %struct.op*, %struct.op** %xcv_root72, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %80, i32 0, i32 7
  %81 = load i8, i8* %op_private, align 1
  %conv73 = zext i8 %81 to i32
  %or74 = or i32 %conv73, 64
  %conv75 = trunc i32 %or74 to i8
  store i8 %conv75, i8* %op_private, align 1
  %82 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any76 = getelementptr inbounds %struct.cv, %struct.cv* %82, i32 0, i32 0
  %83 = load %struct.xpvcv*, %struct.xpvcv** %sv_any76, align 8
  %xcv_root77 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %83, i32 0, i32 9
  %84 = load %struct.op*, %struct.op** %xcv_root77, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %84, i32 0, i32 3
  store i64 1, i64* %op_targ, align 8
  %85 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any78 = getelementptr inbounds %struct.cv, %struct.cv* %85, i32 0, i32 0
  %86 = load %struct.xpvcv*, %struct.xpvcv** %sv_any78, align 8
  %xcv_root79 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %86, i32 0, i32 9
  %87 = load %struct.op*, %struct.op** %xcv_root79, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %87, i32 0, i32 0
  %88 = load %struct.op*, %struct.op** %op_next, align 8
  %tobool80 = icmp ne %struct.op* %88, null
  br i1 %tobool80, label %cond.true.81, label %cond.false.85

cond.true.81:                                     ; preds = %cond.end.65
  %89 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any82 = getelementptr inbounds %struct.cv, %struct.cv* %89, i32 0, i32 0
  %90 = load %struct.xpvcv*, %struct.xpvcv** %sv_any82, align 8
  %xcv_root83 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %90, i32 0, i32 9
  %91 = load %struct.op*, %struct.op** %xcv_root83, align 8
  %op_next84 = getelementptr inbounds %struct.op, %struct.op* %91, i32 0, i32 0
  %92 = load %struct.op*, %struct.op** %op_next84, align 8
  br label %cond.end.89

cond.false.85:                                    ; preds = %cond.end.65
  %93 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any86 = getelementptr inbounds %struct.cv, %struct.cv* %93, i32 0, i32 0
  %94 = load %struct.xpvcv*, %struct.xpvcv** %sv_any86, align 8
  %xcv_root87 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %94, i32 0, i32 9
  %95 = load %struct.op*, %struct.op** %xcv_root87, align 8
  %call88 = call %struct.op* @Perl_linklist(%struct.op* %95)
  br label %cond.end.89

cond.end.89:                                      ; preds = %cond.false.85, %cond.true.81
  %cond90 = phi %struct.op* [ %92, %cond.true.81 ], [ %call88, %cond.false.85 ]
  %96 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any91 = getelementptr inbounds %struct.cv, %struct.cv* %96, i32 0, i32 0
  %97 = load %struct.xpvcv*, %struct.xpvcv** %sv_any91, align 8
  %xcv_start = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %97, i32 0, i32 8
  store %struct.op* %cond90, %struct.op** %xcv_start, align 8
  %98 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any92 = getelementptr inbounds %struct.cv, %struct.cv* %98, i32 0, i32 0
  %99 = load %struct.xpvcv*, %struct.xpvcv** %sv_any92, align 8
  %xcv_root93 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %99, i32 0, i32 9
  %100 = load %struct.op*, %struct.op** %xcv_root93, align 8
  %op_next94 = getelementptr inbounds %struct.op, %struct.op* %100, i32 0, i32 0
  store %struct.op* null, %struct.op** %op_next94, align 8
  %101 = load void (%struct.op*)*, void (%struct.op*)** @PL_peepp, align 8
  %102 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any95 = getelementptr inbounds %struct.cv, %struct.cv* %102, i32 0, i32 0
  %103 = load %struct.xpvcv*, %struct.xpvcv** %sv_any95, align 8
  %xcv_start96 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %103, i32 0, i32 8
  %104 = load %struct.op*, %struct.op** %xcv_start96, align 8
  call void %101(%struct.op* %104)
  %105 = load %struct.op*, %struct.op** %o.addr, align 8
  call void @Perl_op_free(%struct.op* %105)
  store i32 -1, i32* @PL_copline, align 4
  %106 = load i32, i32* @PL_savestack_ix, align 4
  %107 = load i32, i32* %floor.addr, align 4
  %cmp97 = icmp sgt i32 %106, %107
  br i1 %cmp97, label %if.then.99, label %if.end.100

if.then.99:                                       ; preds = %cond.end.89
  %108 = load i32, i32* %floor.addr, align 4
  call void @Perl_leave_scope(i32 %108)
  br label %if.end.100

if.end.100:                                       ; preds = %if.then.99, %cond.end.89
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newANONLIST(%struct.op* %o) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %call = call %struct.op* @Perl_convert(i32 143, i32 0, %struct.op* %0)
  %call1 = call %struct.op* @Perl_list(%struct.op* %call)
  %call2 = call %struct.op* @Perl_mod(%struct.op* %call1, i32 20)
  %call3 = call %struct.op* @Perl_newUNOP(i32 20, i32 0, %struct.op* %call2)
  ret %struct.op* %call3
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newANONHASH(%struct.op* %o) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %call = call %struct.op* @Perl_convert(i32 144, i32 0, %struct.op* %0)
  %call1 = call %struct.op* @Perl_list(%struct.op* %call)
  %call2 = call %struct.op* @Perl_mod(%struct.op* %call1, i32 20)
  %call3 = call %struct.op* @Perl_newUNOP(i32 20, i32 0, %struct.op* %call2)
  ret %struct.op* %call3
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newANONSUB(i32 %floor, %struct.op* %proto, %struct.op* %block) #0 {
entry:
  %floor.addr = alloca i32, align 4
  %proto.addr = alloca %struct.op*, align 8
  %block.addr = alloca %struct.op*, align 8
  store i32 %floor, i32* %floor.addr, align 4
  store %struct.op* %proto, %struct.op** %proto.addr, align 8
  store %struct.op* %block, %struct.op** %block.addr, align 8
  %0 = load i32, i32* %floor.addr, align 4
  %1 = load %struct.op*, %struct.op** %proto.addr, align 8
  %2 = load %struct.op*, %struct.op** %block.addr, align 8
  %call = call %struct.op* @Perl_newANONATTRSUB(i32 %0, %struct.op* %1, %struct.op* null, %struct.op* %2)
  ret %struct.op* %call
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newANONATTRSUB(i32 %floor, %struct.op* %proto, %struct.op* %attrs, %struct.op* %block) #0 {
entry:
  %floor.addr = alloca i32, align 4
  %proto.addr = alloca %struct.op*, align 8
  %attrs.addr = alloca %struct.op*, align 8
  %block.addr = alloca %struct.op*, align 8
  store i32 %floor, i32* %floor.addr, align 4
  store %struct.op* %proto, %struct.op** %proto.addr, align 8
  store %struct.op* %attrs, %struct.op** %attrs.addr, align 8
  store %struct.op* %block, %struct.op** %block.addr, align 8
  %0 = load i32, i32* %floor.addr, align 4
  %1 = load %struct.op*, %struct.op** %proto.addr, align 8
  %2 = load %struct.op*, %struct.op** %attrs.addr, align 8
  %3 = load %struct.op*, %struct.op** %block.addr, align 8
  %call = call %struct.cv* @Perl_newATTRSUB(i32 %0, %struct.op* null, %struct.op* %1, %struct.op* %2, %struct.op* %3)
  %4 = bitcast %struct.cv* %call to %struct.sv*
  %call1 = call %struct.op* @Perl_newSVOP(i32 18, i32 0, %struct.sv* %4)
  %call2 = call %struct.op* @Perl_newUNOP(i32 20, i32 0, %struct.op* %call1)
  ret %struct.op* %call2
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_oopsAV(%struct.op* %o) #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %o.addr = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %0, i32 0, i32 4
  %1 = load i16, i16* %op_type, align 2
  %conv = zext i16 %1 to i32
  switch i32 %conv, label %sw.default [
    i32 9, label %sw.bb
    i32 15, label %sw.bb.2
  ]

sw.bb:                                            ; preds = %entry
  %2 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type1 = getelementptr inbounds %struct.op, %struct.op* %2, i32 0, i32 4
  store i16 10, i16* %op_type1, align 2
  %3 = load %struct.op* ()*, %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 10), align 8
  %4 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_ppaddr = getelementptr inbounds %struct.op, %struct.op* %4, i32 0, i32 2
  store %struct.op* ()* %3, %struct.op* ()** %op_ppaddr, align 8
  %5 = load %struct.op*, %struct.op** %o.addr, align 8
  %call = call %struct.op* @Perl_ref(%struct.op* %5, i32 125)
  store %struct.op* %call, %struct.op** %retval
  br label %return

sw.bb.2:                                          ; preds = %entry
  %6 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type3 = getelementptr inbounds %struct.op, %struct.op* %6, i32 0, i32 4
  store i16 125, i16* %op_type3, align 2
  %7 = load %struct.op* ()*, %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 125), align 8
  %8 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_ppaddr4 = getelementptr inbounds %struct.op, %struct.op* %8, i32 0, i32 2
  store %struct.op* ()* %7, %struct.op* ()** %op_ppaddr4, align 8
  %9 = load %struct.op*, %struct.op** %o.addr, align 8
  %call5 = call %struct.op* @Perl_ref(%struct.op* %9, i32 125)
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %10 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings = getelementptr inbounds %struct.cop, %struct.cop* %10, i32 0, i32 14
  %11 = load %struct.sv*, %struct.sv** %cop_warnings, align 8
  %cmp = icmp eq %struct.sv* %11, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %sw.default
  %12 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings7 = getelementptr inbounds %struct.cop, %struct.cop* %12, i32 0, i32 14
  %13 = load %struct.sv*, %struct.sv** %cop_warnings7, align 8
  %cmp8 = icmp eq %struct.sv* %13, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 1)
  br i1 %cmp8, label %if.then, label %lor.lhs.false.10

lor.lhs.false.10:                                 ; preds = %lor.lhs.false
  %14 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings11 = getelementptr inbounds %struct.cop, %struct.cop* %14, i32 0, i32 14
  %15 = load %struct.sv*, %struct.sv** %cop_warnings11, align 8
  %cmp12 = icmp ne %struct.sv* %15, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 2)
  br i1 %cmp12, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.lhs.false.10
  %16 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings14 = getelementptr inbounds %struct.cop, %struct.cop* %16, i32 0, i32 14
  %17 = load %struct.sv*, %struct.sv** %cop_warnings14, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %17, i32 0, i32 0
  %18 = load i8*, i8** %sv_any, align 8
  %19 = bitcast i8* %18 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %19, i32 0, i32 0
  %20 = load i8*, i8** %xpv_pv, align 8
  %arrayidx = getelementptr inbounds i8, i8* %20, i64 6
  %21 = load i8, i8* %arrayidx, align 1
  %conv15 = sext i8 %21 to i32
  %and = and i32 %conv15, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true, %lor.lhs.false, %sw.default
  call void (i32, i8*, ...) @Perl_warner(i32 24, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.82, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %lor.lhs.false.10
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end, %sw.bb.2
  %22 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %22, %struct.op** %retval
  br label %return

return:                                           ; preds = %sw.epilog, %sw.bb
  %23 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %23
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_oopsHV(%struct.op* %o) #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %o.addr = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %0, i32 0, i32 4
  %1 = load i16, i16* %op_type, align 2
  %conv = zext i16 %1 to i32
  switch i32 %conv, label %sw.default [
    i32 9, label %sw.bb
    i32 10, label %sw.bb
    i32 15, label %sw.bb.2
    i32 125, label %sw.bb.2
  ]

sw.bb:                                            ; preds = %entry, %entry
  %2 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type1 = getelementptr inbounds %struct.op, %struct.op* %2, i32 0, i32 4
  store i16 11, i16* %op_type1, align 2
  %3 = load %struct.op* ()*, %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 11), align 8
  %4 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_ppaddr = getelementptr inbounds %struct.op, %struct.op* %4, i32 0, i32 2
  store %struct.op* ()* %3, %struct.op* ()** %op_ppaddr, align 8
  %5 = load %struct.op*, %struct.op** %o.addr, align 8
  %call = call %struct.op* @Perl_ref(%struct.op* %5, i32 134)
  store %struct.op* %call, %struct.op** %retval
  br label %return

sw.bb.2:                                          ; preds = %entry, %entry
  %6 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type3 = getelementptr inbounds %struct.op, %struct.op* %6, i32 0, i32 4
  store i16 134, i16* %op_type3, align 2
  %7 = load %struct.op* ()*, %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 134), align 8
  %8 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_ppaddr4 = getelementptr inbounds %struct.op, %struct.op* %8, i32 0, i32 2
  store %struct.op* ()* %7, %struct.op* ()** %op_ppaddr4, align 8
  %9 = load %struct.op*, %struct.op** %o.addr, align 8
  %call5 = call %struct.op* @Perl_ref(%struct.op* %9, i32 134)
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %10 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings = getelementptr inbounds %struct.cop, %struct.cop* %10, i32 0, i32 14
  %11 = load %struct.sv*, %struct.sv** %cop_warnings, align 8
  %cmp = icmp eq %struct.sv* %11, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %sw.default
  %12 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings7 = getelementptr inbounds %struct.cop, %struct.cop* %12, i32 0, i32 14
  %13 = load %struct.sv*, %struct.sv** %cop_warnings7, align 8
  %cmp8 = icmp eq %struct.sv* %13, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 1)
  br i1 %cmp8, label %if.then, label %lor.lhs.false.10

lor.lhs.false.10:                                 ; preds = %lor.lhs.false
  %14 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings11 = getelementptr inbounds %struct.cop, %struct.cop* %14, i32 0, i32 14
  %15 = load %struct.sv*, %struct.sv** %cop_warnings11, align 8
  %cmp12 = icmp ne %struct.sv* %15, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 2)
  br i1 %cmp12, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.lhs.false.10
  %16 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings14 = getelementptr inbounds %struct.cop, %struct.cop* %16, i32 0, i32 14
  %17 = load %struct.sv*, %struct.sv** %cop_warnings14, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %17, i32 0, i32 0
  %18 = load i8*, i8** %sv_any, align 8
  %19 = bitcast i8* %18 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %19, i32 0, i32 0
  %20 = load i8*, i8** %xpv_pv, align 8
  %arrayidx = getelementptr inbounds i8, i8* %20, i64 6
  %21 = load i8, i8* %arrayidx, align 1
  %conv15 = sext i8 %21 to i32
  %and = and i32 %conv15, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true, %lor.lhs.false, %sw.default
  call void (i32, i8*, ...) @Perl_warner(i32 24, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.83, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %lor.lhs.false.10
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end, %sw.bb.2
  %22 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %22, %struct.op** %retval
  br label %return

return:                                           ; preds = %sw.epilog, %sw.bb
  %23 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %23
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newAVREF(%struct.op* %o) #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %o.addr = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %0, i32 0, i32 4
  %1 = load i16, i16* %op_type, align 2
  %conv = zext i16 %1 to i32
  %cmp = icmp eq i32 %conv, 12
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type2 = getelementptr inbounds %struct.op, %struct.op* %2, i32 0, i32 4
  store i16 10, i16* %op_type2, align 2
  %3 = load %struct.op* ()*, %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 10), align 8
  %4 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_ppaddr = getelementptr inbounds %struct.op, %struct.op* %4, i32 0, i32 2
  store %struct.op* ()* %3, %struct.op* ()** %op_ppaddr, align 8
  %5 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %5, %struct.op** %retval
  br label %return

if.else:                                          ; preds = %entry
  %6 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type3 = getelementptr inbounds %struct.op, %struct.op* %6, i32 0, i32 4
  %7 = load i16, i16* %op_type3, align 2
  %conv4 = zext i16 %7 to i32
  %cmp5 = icmp eq i32 %conv4, 125
  br i1 %cmp5, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else
  %8 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type7 = getelementptr inbounds %struct.op, %struct.op* %8, i32 0, i32 4
  %9 = load i16, i16* %op_type7, align 2
  %conv8 = zext i16 %9 to i32
  %cmp9 = icmp eq i32 %conv8, 10
  br i1 %cmp9, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.else
  %10 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings = getelementptr inbounds %struct.cop, %struct.cop* %10, i32 0, i32 14
  %11 = load %struct.sv*, %struct.sv** %cop_warnings, align 8
  %cmp11 = icmp ne %struct.sv* %11, null
  br i1 %cmp11, label %land.lhs.true.13, label %lor.lhs.false.24

land.lhs.true.13:                                 ; preds = %land.lhs.true
  %12 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings14 = getelementptr inbounds %struct.cop, %struct.cop* %12, i32 0, i32 14
  %13 = load %struct.sv*, %struct.sv** %cop_warnings14, align 8
  %cmp15 = icmp ne %struct.sv* %13, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 2)
  br i1 %cmp15, label %land.lhs.true.17, label %lor.lhs.false.24

land.lhs.true.17:                                 ; preds = %land.lhs.true.13
  %14 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings18 = getelementptr inbounds %struct.cop, %struct.cop* %14, i32 0, i32 14
  %15 = load %struct.sv*, %struct.sv** %cop_warnings18, align 8
  %cmp19 = icmp eq %struct.sv* %15, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 1)
  br i1 %cmp19, label %if.then.32, label %lor.lhs.false.21

lor.lhs.false.21:                                 ; preds = %land.lhs.true.17
  %16 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings22 = getelementptr inbounds %struct.cop, %struct.cop* %16, i32 0, i32 14
  %17 = load %struct.sv*, %struct.sv** %cop_warnings22, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %17, i32 0, i32 0
  %18 = load i8*, i8** %sv_any, align 8
  %19 = bitcast i8* %18 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %19, i32 0, i32 0
  %20 = load i8*, i8** %xpv_pv, align 8
  %arrayidx = getelementptr inbounds i8, i8* %20, i64 0
  %21 = load i8, i8* %arrayidx, align 1
  %conv23 = sext i8 %21 to i32
  %and = and i32 %conv23, 16
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then.32, label %lor.lhs.false.24

lor.lhs.false.24:                                 ; preds = %lor.lhs.false.21, %land.lhs.true.13, %land.lhs.true
  %22 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings25 = getelementptr inbounds %struct.cop, %struct.cop* %22, i32 0, i32 14
  %23 = load %struct.sv*, %struct.sv** %cop_warnings25, align 8
  %cmp26 = icmp eq %struct.sv* %23, null
  br i1 %cmp26, label %land.lhs.true.28, label %if.end

land.lhs.true.28:                                 ; preds = %lor.lhs.false.24
  %24 = load i8, i8* @PL_dowarn, align 1
  %conv29 = zext i8 %24 to i32
  %and30 = and i32 %conv29, 1
  %tobool31 = icmp ne i32 %and30, 0
  br i1 %tobool31, label %if.then.32, label %if.end

if.then.32:                                       ; preds = %land.lhs.true.28, %lor.lhs.false.21, %land.lhs.true.17
  call void (i32, i8*, ...) @Perl_warner(i32 2, i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str.84, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then.32, %land.lhs.true.28, %lor.lhs.false.24, %lor.lhs.false
  br label %if.end.33

if.end.33:                                        ; preds = %if.end
  %25 = load %struct.op*, %struct.op** %o.addr, align 8
  %call = call %struct.op* @Perl_scalar(%struct.op* %25)
  %call34 = call %struct.op* @Perl_newUNOP(i32 125, i32 0, %struct.op* %call)
  store %struct.op* %call34, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.33, %if.then
  %26 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %26
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newGVREF(i32 %type, %struct.op* %o) #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %type.addr = alloca i32, align 4
  %o.addr = alloca %struct.op*, align 8
  store i32 %type, i32* %type.addr, align 4
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load i32, i32* %type.addr, align 4
  %cmp = icmp eq i32 %0, 154
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %type.addr, align 4
  %cmp1 = icmp eq i32 %1, 152
  br i1 %cmp1, label %if.then, label %lor.lhs.false.2

lor.lhs.false.2:                                  ; preds = %lor.lhs.false
  %2 = load i32, i32* %type.addr, align 4
  %cmp3 = icmp eq i32 %2, 150
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false.2, %lor.lhs.false, %entry
  %3 = load %struct.op*, %struct.op** %o.addr, align 8
  %call = call %struct.op* @Perl_newUNOP(i32 0, i32 0, %struct.op* %3)
  store %struct.op* %call, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %lor.lhs.false.2
  %4 = load %struct.op*, %struct.op** %o.addr, align 8
  %call4 = call %struct.op* @Perl_newUNOP(i32 14, i32 16, %struct.op* %4)
  %5 = load i32, i32* %type.addr, align 4
  %call5 = call %struct.op* @Perl_ref(%struct.op* %call4, i32 %5)
  store %struct.op* %call5, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %6
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newHVREF(%struct.op* %o) #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %o.addr = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %0, i32 0, i32 4
  %1 = load i16, i16* %op_type, align 2
  %conv = zext i16 %1 to i32
  %cmp = icmp eq i32 %conv, 12
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type2 = getelementptr inbounds %struct.op, %struct.op* %2, i32 0, i32 4
  store i16 11, i16* %op_type2, align 2
  %3 = load %struct.op* ()*, %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 11), align 8
  %4 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_ppaddr = getelementptr inbounds %struct.op, %struct.op* %4, i32 0, i32 2
  store %struct.op* ()* %3, %struct.op* ()** %op_ppaddr, align 8
  %5 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %5, %struct.op** %retval
  br label %return

if.else:                                          ; preds = %entry
  %6 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type3 = getelementptr inbounds %struct.op, %struct.op* %6, i32 0, i32 4
  %7 = load i16, i16* %op_type3, align 2
  %conv4 = zext i16 %7 to i32
  %cmp5 = icmp eq i32 %conv4, 134
  br i1 %cmp5, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else
  %8 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type7 = getelementptr inbounds %struct.op, %struct.op* %8, i32 0, i32 4
  %9 = load i16, i16* %op_type7, align 2
  %conv8 = zext i16 %9 to i32
  %cmp9 = icmp eq i32 %conv8, 11
  br i1 %cmp9, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.else
  %10 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings = getelementptr inbounds %struct.cop, %struct.cop* %10, i32 0, i32 14
  %11 = load %struct.sv*, %struct.sv** %cop_warnings, align 8
  %cmp11 = icmp ne %struct.sv* %11, null
  br i1 %cmp11, label %land.lhs.true.13, label %lor.lhs.false.24

land.lhs.true.13:                                 ; preds = %land.lhs.true
  %12 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings14 = getelementptr inbounds %struct.cop, %struct.cop* %12, i32 0, i32 14
  %13 = load %struct.sv*, %struct.sv** %cop_warnings14, align 8
  %cmp15 = icmp ne %struct.sv* %13, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 2)
  br i1 %cmp15, label %land.lhs.true.17, label %lor.lhs.false.24

land.lhs.true.17:                                 ; preds = %land.lhs.true.13
  %14 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings18 = getelementptr inbounds %struct.cop, %struct.cop* %14, i32 0, i32 14
  %15 = load %struct.sv*, %struct.sv** %cop_warnings18, align 8
  %cmp19 = icmp eq %struct.sv* %15, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 1)
  br i1 %cmp19, label %if.then.32, label %lor.lhs.false.21

lor.lhs.false.21:                                 ; preds = %land.lhs.true.17
  %16 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings22 = getelementptr inbounds %struct.cop, %struct.cop* %16, i32 0, i32 14
  %17 = load %struct.sv*, %struct.sv** %cop_warnings22, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %17, i32 0, i32 0
  %18 = load i8*, i8** %sv_any, align 8
  %19 = bitcast i8* %18 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %19, i32 0, i32 0
  %20 = load i8*, i8** %xpv_pv, align 8
  %arrayidx = getelementptr inbounds i8, i8* %20, i64 0
  %21 = load i8, i8* %arrayidx, align 1
  %conv23 = sext i8 %21 to i32
  %and = and i32 %conv23, 16
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then.32, label %lor.lhs.false.24

lor.lhs.false.24:                                 ; preds = %lor.lhs.false.21, %land.lhs.true.13, %land.lhs.true
  %22 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings25 = getelementptr inbounds %struct.cop, %struct.cop* %22, i32 0, i32 14
  %23 = load %struct.sv*, %struct.sv** %cop_warnings25, align 8
  %cmp26 = icmp eq %struct.sv* %23, null
  br i1 %cmp26, label %land.lhs.true.28, label %if.end

land.lhs.true.28:                                 ; preds = %lor.lhs.false.24
  %24 = load i8, i8* @PL_dowarn, align 1
  %conv29 = zext i8 %24 to i32
  %and30 = and i32 %conv29, 1
  %tobool31 = icmp ne i32 %and30, 0
  br i1 %tobool31, label %if.then.32, label %if.end

if.then.32:                                       ; preds = %land.lhs.true.28, %lor.lhs.false.21, %land.lhs.true.17
  call void (i32, i8*, ...) @Perl_warner(i32 2, i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.85, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then.32, %land.lhs.true.28, %lor.lhs.false.24, %lor.lhs.false
  br label %if.end.33

if.end.33:                                        ; preds = %if.end
  %25 = load %struct.op*, %struct.op** %o.addr, align 8
  %call = call %struct.op* @Perl_scalar(%struct.op* %25)
  %call34 = call %struct.op* @Perl_newUNOP(i32 134, i32 0, %struct.op* %call)
  store %struct.op* %call34, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.33, %if.then
  %26 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %26
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_oopsCV(%struct.op* %o) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.86, i32 0, i32 0), i32 4843)
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  ret %struct.op* %0
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_newCVREF(i32 %flags, %struct.op* %o) #0 {
entry:
  %flags.addr = alloca i32, align 4
  %o.addr = alloca %struct.op*, align 8
  store i32 %flags, i32* %flags.addr, align 4
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load i32, i32* %flags.addr, align 4
  %1 = load %struct.op*, %struct.op** %o.addr, align 8
  %call = call %struct.op* @Perl_scalar(%struct.op* %1)
  %call1 = call %struct.op* @Perl_newUNOP(i32 17, i32 %0, %struct.op* %call)
  ret %struct.op* %call1
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_anoncode(%struct.op* %o) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %1 = bitcast %struct.op* %0 to %struct.svop*
  %op_sv = getelementptr inbounds %struct.svop, %struct.svop* %1, i32 0, i32 8
  %2 = load %struct.sv*, %struct.sv** %op_sv, align 8
  %3 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %3, i32 0, i32 4
  %4 = load i16, i16* %op_type, align 2
  %call = call i64 @Perl_pad_add_anon(%struct.sv* %2, i16 zeroext %4)
  %5 = load %struct.op*, %struct.op** %o.addr, align 8
  %6 = bitcast %struct.op* %5 to %struct.svop*
  %op_targ = getelementptr inbounds %struct.svop, %struct.svop* %6, i32 0, i32 3
  store i64 %call, i64* %op_targ, align 8
  %7 = load %struct.op*, %struct.op** %o.addr, align 8
  %8 = bitcast %struct.op* %7 to %struct.svop*
  %op_sv1 = getelementptr inbounds %struct.svop, %struct.svop* %8, i32 0, i32 8
  store %struct.sv* null, %struct.sv** %op_sv1, align 8
  %9 = load %struct.op*, %struct.op** %o.addr, align 8
  ret %struct.op* %9
}

declare i64 @Perl_pad_add_anon(%struct.sv*, i16 zeroext) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_bitop(%struct.op* %o) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  %left = alloca %struct.op*, align 8
  %right = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load i32, i32* @PL_hints, align 4
  %and = and i32 %0, 255
  %conv = trunc i32 %and to i8
  %1 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 7
  store i8 %conv, i8* %op_private, align 1
  %2 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %2, i32 0, i32 6
  %3 = load i8, i8* %op_flags, align 1
  %conv1 = zext i8 %3 to i32
  %and2 = and i32 %conv1, 64
  %tobool = icmp ne i32 %and2, 0
  br i1 %tobool, label %if.end.200, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %4 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %4, i32 0, i32 4
  %5 = load i16, i16* %op_type, align 2
  %conv3 = zext i16 %5 to i32
  %cmp = icmp eq i32 %conv3, 93
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %6 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type5 = getelementptr inbounds %struct.op, %struct.op* %6, i32 0, i32 4
  %7 = load i16, i16* %op_type5, align 2
  %conv6 = zext i16 %7 to i32
  %cmp7 = icmp eq i32 %conv6, 91
  br i1 %cmp7, label %if.then, label %lor.lhs.false.9

lor.lhs.false.9:                                  ; preds = %lor.lhs.false
  %8 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type10 = getelementptr inbounds %struct.op, %struct.op* %8, i32 0, i32 4
  %9 = load i16, i16* %op_type10, align 2
  %conv11 = zext i16 %9 to i32
  %cmp12 = icmp eq i32 %conv11, 92
  br i1 %cmp12, label %if.then, label %if.end.200

if.then:                                          ; preds = %lor.lhs.false.9, %lor.lhs.false, %land.lhs.true
  %10 = load %struct.op*, %struct.op** %o.addr, align 8
  %11 = bitcast %struct.op* %10 to %struct.binop*
  %op_first = getelementptr inbounds %struct.binop, %struct.binop* %11, i32 0, i32 8
  %12 = load %struct.op*, %struct.op** %op_first, align 8
  store %struct.op* %12, %struct.op** %left, align 8
  %13 = load %struct.op*, %struct.op** %left, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %13, i32 0, i32 1
  %14 = load %struct.op*, %struct.op** %op_sibling, align 8
  store %struct.op* %14, %struct.op** %right, align 8
  %15 = load %struct.op*, %struct.op** %left, align 8
  %op_type14 = getelementptr inbounds %struct.op, %struct.op* %15, i32 0, i32 4
  %16 = load i16, i16* %op_type14, align 2
  %conv15 = zext i16 %16 to i32
  %cmp16 = icmp eq i32 %conv15, 70
  br i1 %cmp16, label %land.lhs.true.83, label %lor.lhs.false.18

lor.lhs.false.18:                                 ; preds = %if.then
  %17 = load %struct.op*, %struct.op** %left, align 8
  %op_type19 = getelementptr inbounds %struct.op, %struct.op* %17, i32 0, i32 4
  %18 = load i16, i16* %op_type19, align 2
  %conv20 = zext i16 %18 to i32
  %cmp21 = icmp eq i32 %conv20, 71
  br i1 %cmp21, label %land.lhs.true.83, label %lor.lhs.false.23

lor.lhs.false.23:                                 ; preds = %lor.lhs.false.18
  %19 = load %struct.op*, %struct.op** %left, align 8
  %op_type24 = getelementptr inbounds %struct.op, %struct.op* %19, i32 0, i32 4
  %20 = load i16, i16* %op_type24, align 2
  %conv25 = zext i16 %20 to i32
  %cmp26 = icmp eq i32 %conv25, 72
  br i1 %cmp26, label %land.lhs.true.83, label %lor.lhs.false.28

lor.lhs.false.28:                                 ; preds = %lor.lhs.false.23
  %21 = load %struct.op*, %struct.op** %left, align 8
  %op_type29 = getelementptr inbounds %struct.op, %struct.op* %21, i32 0, i32 4
  %22 = load i16, i16* %op_type29, align 2
  %conv30 = zext i16 %22 to i32
  %cmp31 = icmp eq i32 %conv30, 73
  br i1 %cmp31, label %land.lhs.true.83, label %lor.lhs.false.33

lor.lhs.false.33:                                 ; preds = %lor.lhs.false.28
  %23 = load %struct.op*, %struct.op** %left, align 8
  %op_type34 = getelementptr inbounds %struct.op, %struct.op* %23, i32 0, i32 4
  %24 = load i16, i16* %op_type34, align 2
  %conv35 = zext i16 %24 to i32
  %cmp36 = icmp eq i32 %conv35, 74
  br i1 %cmp36, label %land.lhs.true.83, label %lor.lhs.false.38

lor.lhs.false.38:                                 ; preds = %lor.lhs.false.33
  %25 = load %struct.op*, %struct.op** %left, align 8
  %op_type39 = getelementptr inbounds %struct.op, %struct.op* %25, i32 0, i32 4
  %26 = load i16, i16* %op_type39, align 2
  %conv40 = zext i16 %26 to i32
  %cmp41 = icmp eq i32 %conv40, 75
  br i1 %cmp41, label %land.lhs.true.83, label %lor.lhs.false.43

lor.lhs.false.43:                                 ; preds = %lor.lhs.false.38
  %27 = load %struct.op*, %struct.op** %left, align 8
  %op_type44 = getelementptr inbounds %struct.op, %struct.op* %27, i32 0, i32 4
  %28 = load i16, i16* %op_type44, align 2
  %conv45 = zext i16 %28 to i32
  %cmp46 = icmp eq i32 %conv45, 76
  br i1 %cmp46, label %land.lhs.true.83, label %lor.lhs.false.48

lor.lhs.false.48:                                 ; preds = %lor.lhs.false.43
  %29 = load %struct.op*, %struct.op** %left, align 8
  %op_type49 = getelementptr inbounds %struct.op, %struct.op* %29, i32 0, i32 4
  %30 = load i16, i16* %op_type49, align 2
  %conv50 = zext i16 %30 to i32
  %cmp51 = icmp eq i32 %conv50, 77
  br i1 %cmp51, label %land.lhs.true.83, label %lor.lhs.false.53

lor.lhs.false.53:                                 ; preds = %lor.lhs.false.48
  %31 = load %struct.op*, %struct.op** %left, align 8
  %op_type54 = getelementptr inbounds %struct.op, %struct.op* %31, i32 0, i32 4
  %32 = load i16, i16* %op_type54, align 2
  %conv55 = zext i16 %32 to i32
  %cmp56 = icmp eq i32 %conv55, 78
  br i1 %cmp56, label %land.lhs.true.83, label %lor.lhs.false.58

lor.lhs.false.58:                                 ; preds = %lor.lhs.false.53
  %33 = load %struct.op*, %struct.op** %left, align 8
  %op_type59 = getelementptr inbounds %struct.op, %struct.op* %33, i32 0, i32 4
  %34 = load i16, i16* %op_type59, align 2
  %conv60 = zext i16 %34 to i32
  %cmp61 = icmp eq i32 %conv60, 79
  br i1 %cmp61, label %land.lhs.true.83, label %lor.lhs.false.63

lor.lhs.false.63:                                 ; preds = %lor.lhs.false.58
  %35 = load %struct.op*, %struct.op** %left, align 8
  %op_type64 = getelementptr inbounds %struct.op, %struct.op* %35, i32 0, i32 4
  %36 = load i16, i16* %op_type64, align 2
  %conv65 = zext i16 %36 to i32
  %cmp66 = icmp eq i32 %conv65, 80
  br i1 %cmp66, label %land.lhs.true.83, label %lor.lhs.false.68

lor.lhs.false.68:                                 ; preds = %lor.lhs.false.63
  %37 = load %struct.op*, %struct.op** %left, align 8
  %op_type69 = getelementptr inbounds %struct.op, %struct.op* %37, i32 0, i32 4
  %38 = load i16, i16* %op_type69, align 2
  %conv70 = zext i16 %38 to i32
  %cmp71 = icmp eq i32 %conv70, 81
  br i1 %cmp71, label %land.lhs.true.83, label %lor.lhs.false.73

lor.lhs.false.73:                                 ; preds = %lor.lhs.false.68
  %39 = load %struct.op*, %struct.op** %left, align 8
  %op_type74 = getelementptr inbounds %struct.op, %struct.op* %39, i32 0, i32 4
  %40 = load i16, i16* %op_type74, align 2
  %conv75 = zext i16 %40 to i32
  %cmp76 = icmp eq i32 %conv75, 82
  br i1 %cmp76, label %land.lhs.true.83, label %lor.lhs.false.78

lor.lhs.false.78:                                 ; preds = %lor.lhs.false.73
  %41 = load %struct.op*, %struct.op** %left, align 8
  %op_type79 = getelementptr inbounds %struct.op, %struct.op* %41, i32 0, i32 4
  %42 = load i16, i16* %op_type79, align 2
  %conv80 = zext i16 %42 to i32
  %cmp81 = icmp eq i32 %conv80, 83
  br i1 %cmp81, label %land.lhs.true.83, label %lor.lhs.false.89

land.lhs.true.83:                                 ; preds = %lor.lhs.false.78, %lor.lhs.false.73, %lor.lhs.false.68, %lor.lhs.false.63, %lor.lhs.false.58, %lor.lhs.false.53, %lor.lhs.false.48, %lor.lhs.false.43, %lor.lhs.false.38, %lor.lhs.false.33, %lor.lhs.false.28, %lor.lhs.false.23, %lor.lhs.false.18, %if.then
  %43 = load %struct.op*, %struct.op** %left, align 8
  %op_flags84 = getelementptr inbounds %struct.op, %struct.op* %43, i32 0, i32 6
  %44 = load i8, i8* %op_flags84, align 1
  %conv85 = zext i8 %44 to i32
  %and86 = and i32 %conv85, 8
  %cmp87 = icmp eq i32 %and86, 0
  br i1 %cmp87, label %if.then.165, label %lor.lhs.false.89

lor.lhs.false.89:                                 ; preds = %land.lhs.true.83, %lor.lhs.false.78
  %45 = load %struct.op*, %struct.op** %right, align 8
  %op_type90 = getelementptr inbounds %struct.op, %struct.op* %45, i32 0, i32 4
  %46 = load i16, i16* %op_type90, align 2
  %conv91 = zext i16 %46 to i32
  %cmp92 = icmp eq i32 %conv91, 70
  br i1 %cmp92, label %land.lhs.true.159, label %lor.lhs.false.94

lor.lhs.false.94:                                 ; preds = %lor.lhs.false.89
  %47 = load %struct.op*, %struct.op** %right, align 8
  %op_type95 = getelementptr inbounds %struct.op, %struct.op* %47, i32 0, i32 4
  %48 = load i16, i16* %op_type95, align 2
  %conv96 = zext i16 %48 to i32
  %cmp97 = icmp eq i32 %conv96, 71
  br i1 %cmp97, label %land.lhs.true.159, label %lor.lhs.false.99

lor.lhs.false.99:                                 ; preds = %lor.lhs.false.94
  %49 = load %struct.op*, %struct.op** %right, align 8
  %op_type100 = getelementptr inbounds %struct.op, %struct.op* %49, i32 0, i32 4
  %50 = load i16, i16* %op_type100, align 2
  %conv101 = zext i16 %50 to i32
  %cmp102 = icmp eq i32 %conv101, 72
  br i1 %cmp102, label %land.lhs.true.159, label %lor.lhs.false.104

lor.lhs.false.104:                                ; preds = %lor.lhs.false.99
  %51 = load %struct.op*, %struct.op** %right, align 8
  %op_type105 = getelementptr inbounds %struct.op, %struct.op* %51, i32 0, i32 4
  %52 = load i16, i16* %op_type105, align 2
  %conv106 = zext i16 %52 to i32
  %cmp107 = icmp eq i32 %conv106, 73
  br i1 %cmp107, label %land.lhs.true.159, label %lor.lhs.false.109

lor.lhs.false.109:                                ; preds = %lor.lhs.false.104
  %53 = load %struct.op*, %struct.op** %right, align 8
  %op_type110 = getelementptr inbounds %struct.op, %struct.op* %53, i32 0, i32 4
  %54 = load i16, i16* %op_type110, align 2
  %conv111 = zext i16 %54 to i32
  %cmp112 = icmp eq i32 %conv111, 74
  br i1 %cmp112, label %land.lhs.true.159, label %lor.lhs.false.114

lor.lhs.false.114:                                ; preds = %lor.lhs.false.109
  %55 = load %struct.op*, %struct.op** %right, align 8
  %op_type115 = getelementptr inbounds %struct.op, %struct.op* %55, i32 0, i32 4
  %56 = load i16, i16* %op_type115, align 2
  %conv116 = zext i16 %56 to i32
  %cmp117 = icmp eq i32 %conv116, 75
  br i1 %cmp117, label %land.lhs.true.159, label %lor.lhs.false.119

lor.lhs.false.119:                                ; preds = %lor.lhs.false.114
  %57 = load %struct.op*, %struct.op** %right, align 8
  %op_type120 = getelementptr inbounds %struct.op, %struct.op* %57, i32 0, i32 4
  %58 = load i16, i16* %op_type120, align 2
  %conv121 = zext i16 %58 to i32
  %cmp122 = icmp eq i32 %conv121, 76
  br i1 %cmp122, label %land.lhs.true.159, label %lor.lhs.false.124

lor.lhs.false.124:                                ; preds = %lor.lhs.false.119
  %59 = load %struct.op*, %struct.op** %right, align 8
  %op_type125 = getelementptr inbounds %struct.op, %struct.op* %59, i32 0, i32 4
  %60 = load i16, i16* %op_type125, align 2
  %conv126 = zext i16 %60 to i32
  %cmp127 = icmp eq i32 %conv126, 77
  br i1 %cmp127, label %land.lhs.true.159, label %lor.lhs.false.129

lor.lhs.false.129:                                ; preds = %lor.lhs.false.124
  %61 = load %struct.op*, %struct.op** %right, align 8
  %op_type130 = getelementptr inbounds %struct.op, %struct.op* %61, i32 0, i32 4
  %62 = load i16, i16* %op_type130, align 2
  %conv131 = zext i16 %62 to i32
  %cmp132 = icmp eq i32 %conv131, 78
  br i1 %cmp132, label %land.lhs.true.159, label %lor.lhs.false.134

lor.lhs.false.134:                                ; preds = %lor.lhs.false.129
  %63 = load %struct.op*, %struct.op** %right, align 8
  %op_type135 = getelementptr inbounds %struct.op, %struct.op* %63, i32 0, i32 4
  %64 = load i16, i16* %op_type135, align 2
  %conv136 = zext i16 %64 to i32
  %cmp137 = icmp eq i32 %conv136, 79
  br i1 %cmp137, label %land.lhs.true.159, label %lor.lhs.false.139

lor.lhs.false.139:                                ; preds = %lor.lhs.false.134
  %65 = load %struct.op*, %struct.op** %right, align 8
  %op_type140 = getelementptr inbounds %struct.op, %struct.op* %65, i32 0, i32 4
  %66 = load i16, i16* %op_type140, align 2
  %conv141 = zext i16 %66 to i32
  %cmp142 = icmp eq i32 %conv141, 80
  br i1 %cmp142, label %land.lhs.true.159, label %lor.lhs.false.144

lor.lhs.false.144:                                ; preds = %lor.lhs.false.139
  %67 = load %struct.op*, %struct.op** %right, align 8
  %op_type145 = getelementptr inbounds %struct.op, %struct.op* %67, i32 0, i32 4
  %68 = load i16, i16* %op_type145, align 2
  %conv146 = zext i16 %68 to i32
  %cmp147 = icmp eq i32 %conv146, 81
  br i1 %cmp147, label %land.lhs.true.159, label %lor.lhs.false.149

lor.lhs.false.149:                                ; preds = %lor.lhs.false.144
  %69 = load %struct.op*, %struct.op** %right, align 8
  %op_type150 = getelementptr inbounds %struct.op, %struct.op* %69, i32 0, i32 4
  %70 = load i16, i16* %op_type150, align 2
  %conv151 = zext i16 %70 to i32
  %cmp152 = icmp eq i32 %conv151, 82
  br i1 %cmp152, label %land.lhs.true.159, label %lor.lhs.false.154

lor.lhs.false.154:                                ; preds = %lor.lhs.false.149
  %71 = load %struct.op*, %struct.op** %right, align 8
  %op_type155 = getelementptr inbounds %struct.op, %struct.op* %71, i32 0, i32 4
  %72 = load i16, i16* %op_type155, align 2
  %conv156 = zext i16 %72 to i32
  %cmp157 = icmp eq i32 %conv156, 83
  br i1 %cmp157, label %land.lhs.true.159, label %if.end.199

land.lhs.true.159:                                ; preds = %lor.lhs.false.154, %lor.lhs.false.149, %lor.lhs.false.144, %lor.lhs.false.139, %lor.lhs.false.134, %lor.lhs.false.129, %lor.lhs.false.124, %lor.lhs.false.119, %lor.lhs.false.114, %lor.lhs.false.109, %lor.lhs.false.104, %lor.lhs.false.99, %lor.lhs.false.94, %lor.lhs.false.89
  %73 = load %struct.op*, %struct.op** %right, align 8
  %op_flags160 = getelementptr inbounds %struct.op, %struct.op* %73, i32 0, i32 6
  %74 = load i8, i8* %op_flags160, align 1
  %conv161 = zext i8 %74 to i32
  %and162 = and i32 %conv161, 8
  %cmp163 = icmp eq i32 %and162, 0
  br i1 %cmp163, label %if.then.165, label %if.end.199

if.then.165:                                      ; preds = %land.lhs.true.159, %land.lhs.true.83
  %75 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings = getelementptr inbounds %struct.cop, %struct.cop* %75, i32 0, i32 14
  %76 = load %struct.sv*, %struct.sv** %cop_warnings, align 8
  %cmp166 = icmp ne %struct.sv* %76, null
  br i1 %cmp166, label %land.lhs.true.168, label %lor.lhs.false.181

land.lhs.true.168:                                ; preds = %if.then.165
  %77 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings169 = getelementptr inbounds %struct.cop, %struct.cop* %77, i32 0, i32 14
  %78 = load %struct.sv*, %struct.sv** %cop_warnings169, align 8
  %cmp170 = icmp ne %struct.sv* %78, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 2)
  br i1 %cmp170, label %land.lhs.true.172, label %lor.lhs.false.181

land.lhs.true.172:                                ; preds = %land.lhs.true.168
  %79 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings173 = getelementptr inbounds %struct.cop, %struct.cop* %79, i32 0, i32 14
  %80 = load %struct.sv*, %struct.sv** %cop_warnings173, align 8
  %cmp174 = icmp eq %struct.sv* %80, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 1)
  br i1 %cmp174, label %if.then.189, label %lor.lhs.false.176

lor.lhs.false.176:                                ; preds = %land.lhs.true.172
  %81 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings177 = getelementptr inbounds %struct.cop, %struct.cop* %81, i32 0, i32 14
  %82 = load %struct.sv*, %struct.sv** %cop_warnings177, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %82, i32 0, i32 0
  %83 = load i8*, i8** %sv_any, align 8
  %84 = bitcast i8* %83 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %84, i32 0, i32 0
  %85 = load i8*, i8** %xpv_pv, align 8
  %arrayidx = getelementptr inbounds i8, i8* %85, i64 8
  %86 = load i8, i8* %arrayidx, align 1
  %conv178 = sext i8 %86 to i32
  %and179 = and i32 %conv178, 4
  %tobool180 = icmp ne i32 %and179, 0
  br i1 %tobool180, label %if.then.189, label %lor.lhs.false.181

lor.lhs.false.181:                                ; preds = %lor.lhs.false.176, %land.lhs.true.168, %if.then.165
  %87 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings182 = getelementptr inbounds %struct.cop, %struct.cop* %87, i32 0, i32 14
  %88 = load %struct.sv*, %struct.sv** %cop_warnings182, align 8
  %cmp183 = icmp eq %struct.sv* %88, null
  br i1 %cmp183, label %land.lhs.true.185, label %if.end

land.lhs.true.185:                                ; preds = %lor.lhs.false.181
  %89 = load i8, i8* @PL_dowarn, align 1
  %conv186 = zext i8 %89 to i32
  %and187 = and i32 %conv186, 1
  %tobool188 = icmp ne i32 %and187, 0
  br i1 %tobool188, label %if.then.189, label %if.end

if.then.189:                                      ; preds = %land.lhs.true.185, %lor.lhs.false.176, %land.lhs.true.172
  %90 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type190 = getelementptr inbounds %struct.op, %struct.op* %90, i32 0, i32 4
  %91 = load i16, i16* %op_type190, align 2
  %conv191 = zext i16 %91 to i32
  %cmp192 = icmp eq i32 %conv191, 93
  br i1 %cmp192, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.189
  br label %cond.end

cond.false:                                       ; preds = %if.then.189
  %92 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type194 = getelementptr inbounds %struct.op, %struct.op* %92, i32 0, i32 4
  %93 = load i16, i16* %op_type194, align 2
  %conv195 = zext i16 %93 to i32
  %cmp196 = icmp eq i32 %conv195, 91
  %cond = select i1 %cmp196, i32 38, i32 94
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond198 = phi i32 [ 124, %cond.true ], [ %cond, %cond.false ]
  call void (i32, i8*, ...) @Perl_warner(i32 33, i8* getelementptr inbounds ([51 x i8], [51 x i8]* @.str.87, i32 0, i32 0), i32 %cond198)
  br label %if.end

if.end:                                           ; preds = %cond.end, %land.lhs.true.185, %lor.lhs.false.181
  br label %if.end.199

if.end.199:                                       ; preds = %if.end, %land.lhs.true.159, %lor.lhs.false.154
  br label %if.end.200

if.end.200:                                       ; preds = %if.end.199, %lor.lhs.false.9, %entry
  %94 = load %struct.op*, %struct.op** %o.addr, align 8
  ret %struct.op* %94
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_concat(%struct.op* %o) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  %kid = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %1 = bitcast %struct.op* %0 to %struct.unop*
  %op_first = getelementptr inbounds %struct.unop, %struct.unop* %1, i32 0, i32 8
  %2 = load %struct.op*, %struct.op** %op_first, align 8
  store %struct.op* %2, %struct.op** %kid, align 8
  %3 = load %struct.op*, %struct.op** %kid, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %3, i32 0, i32 4
  %4 = load i16, i16* %op_type, align 2
  %conv = zext i16 %4 to i32
  %cmp = icmp eq i32 %conv, 66
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %5 = load %struct.op*, %struct.op** %kid, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %5, i32 0, i32 7
  %6 = load i8, i8* %op_private, align 1
  %conv2 = zext i8 %6 to i32
  %and = and i32 %conv2, 16
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %land.lhs.true.3

land.lhs.true.3:                                  ; preds = %land.lhs.true
  %7 = load %struct.op*, %struct.op** %kid, align 8
  %8 = bitcast %struct.op* %7 to %struct.unop*
  %op_first4 = getelementptr inbounds %struct.unop, %struct.unop* %8, i32 0, i32 8
  %9 = load %struct.op*, %struct.op** %op_first4, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %9, i32 0, i32 6
  %10 = load i8, i8* %op_flags, align 1
  %conv5 = zext i8 %10 to i32
  %and6 = and i32 %conv5, 32
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true.3
  %11 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags8 = getelementptr inbounds %struct.op, %struct.op* %11, i32 0, i32 6
  %12 = load i8, i8* %op_flags8, align 1
  %conv9 = zext i8 %12 to i32
  %or = or i32 %conv9, 64
  %conv10 = trunc i32 %or to i8
  store i8 %conv10, i8* %op_flags8, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true.3, %land.lhs.true, %entry
  %13 = load %struct.op*, %struct.op** %o.addr, align 8
  ret %struct.op* %13
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_spair(%struct.op* %o) #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %o.addr = alloca %struct.op*, align 8
  %newop = alloca %struct.op*, align 8
  %kid = alloca %struct.op*, align 8
  %type = alloca i16, align 2
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %0, i32 0, i32 6
  %1 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %1 to i32
  %and = and i32 %conv, 4
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end.32

if.then:                                          ; preds = %entry
  %2 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %2, i32 0, i32 4
  %3 = load i16, i16* %op_type, align 2
  store i16 %3, i16* %type, align 2
  %4 = load %struct.op*, %struct.op** %o.addr, align 8
  %call = call %struct.op* @Perl_ck_fun(%struct.op* %4)
  %5 = load i16, i16* %type, align 2
  %conv1 = zext i16 %5 to i32
  %call2 = call %struct.op* @S_modkids(%struct.op* %call, i32 %conv1)
  store %struct.op* %call2, %struct.op** %o.addr, align 8
  %6 = load %struct.op*, %struct.op** %o.addr, align 8
  %7 = bitcast %struct.op* %6 to %struct.unop*
  %op_first = getelementptr inbounds %struct.unop, %struct.unop* %7, i32 0, i32 8
  %8 = load %struct.op*, %struct.op** %op_first, align 8
  store %struct.op* %8, %struct.op** %kid, align 8
  %9 = load %struct.op*, %struct.op** %kid, align 8
  %10 = bitcast %struct.op* %9 to %struct.unop*
  %op_first3 = getelementptr inbounds %struct.unop, %struct.unop* %10, i32 0, i32 8
  %11 = load %struct.op*, %struct.op** %op_first3, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %11, i32 0, i32 1
  %12 = load %struct.op*, %struct.op** %op_sibling, align 8
  store %struct.op* %12, %struct.op** %newop, align 8
  %13 = load %struct.op*, %struct.op** %newop, align 8
  %tobool4 = icmp ne %struct.op* %13, null
  br i1 %tobool4, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then
  %14 = load %struct.op*, %struct.op** %newop, align 8
  %op_sibling5 = getelementptr inbounds %struct.op, %struct.op* %14, i32 0, i32 1
  %15 = load %struct.op*, %struct.op** %op_sibling5, align 8
  %tobool6 = icmp ne %struct.op* %15, null
  br i1 %tobool6, label %if.then.29, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true
  %16 = load %struct.op*, %struct.op** %newop, align 8
  %op_type7 = getelementptr inbounds %struct.op, %struct.op* %16, i32 0, i32 4
  %17 = load i16, i16* %op_type7, align 2
  %idxprom = zext i16 %17 to i64
  %arrayidx = getelementptr inbounds [0 x i32], [0 x i32]* @PL_opargs, i32 0, i64 %idxprom
  %18 = load i32, i32* %arrayidx, align 4
  %and8 = and i32 %18, 4
  %tobool9 = icmp ne i32 %and8, 0
  br i1 %tobool9, label %lor.lhs.false.10, label %if.then.29

lor.lhs.false.10:                                 ; preds = %lor.lhs.false
  %19 = load %struct.op*, %struct.op** %newop, align 8
  %op_type11 = getelementptr inbounds %struct.op, %struct.op* %19, i32 0, i32 4
  %20 = load i16, i16* %op_type11, align 2
  %conv12 = zext i16 %20 to i32
  %cmp = icmp eq i32 %conv12, 10
  br i1 %cmp, label %if.then.29, label %lor.lhs.false.14

lor.lhs.false.14:                                 ; preds = %lor.lhs.false.10
  %21 = load %struct.op*, %struct.op** %newop, align 8
  %op_type15 = getelementptr inbounds %struct.op, %struct.op* %21, i32 0, i32 4
  %22 = load i16, i16* %op_type15, align 2
  %conv16 = zext i16 %22 to i32
  %cmp17 = icmp eq i32 %conv16, 11
  br i1 %cmp17, label %if.then.29, label %lor.lhs.false.19

lor.lhs.false.19:                                 ; preds = %lor.lhs.false.14
  %23 = load %struct.op*, %struct.op** %newop, align 8
  %op_type20 = getelementptr inbounds %struct.op, %struct.op* %23, i32 0, i32 4
  %24 = load i16, i16* %op_type20, align 2
  %conv21 = zext i16 %24 to i32
  %cmp22 = icmp eq i32 %conv21, 125
  br i1 %cmp22, label %if.then.29, label %lor.lhs.false.24

lor.lhs.false.24:                                 ; preds = %lor.lhs.false.19
  %25 = load %struct.op*, %struct.op** %newop, align 8
  %op_type25 = getelementptr inbounds %struct.op, %struct.op* %25, i32 0, i32 4
  %26 = load i16, i16* %op_type25, align 2
  %conv26 = zext i16 %26 to i32
  %cmp27 = icmp eq i32 %conv26, 134
  br i1 %cmp27, label %if.then.29, label %if.end

if.then.29:                                       ; preds = %lor.lhs.false.24, %lor.lhs.false.19, %lor.lhs.false.14, %lor.lhs.false.10, %lor.lhs.false, %land.lhs.true
  %27 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %27, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %lor.lhs.false.24, %if.then
  %28 = load %struct.op*, %struct.op** %kid, align 8
  %29 = bitcast %struct.op* %28 to %struct.unop*
  %op_first30 = getelementptr inbounds %struct.unop, %struct.unop* %29, i32 0, i32 8
  %30 = load %struct.op*, %struct.op** %op_first30, align 8
  call void @Perl_op_free(%struct.op* %30)
  %31 = load %struct.op*, %struct.op** %newop, align 8
  %32 = load %struct.op*, %struct.op** %kid, align 8
  %33 = bitcast %struct.op* %32 to %struct.unop*
  %op_first31 = getelementptr inbounds %struct.unop, %struct.unop* %33, i32 0, i32 8
  store %struct.op* %31, %struct.op** %op_first31, align 8
  br label %if.end.32

if.end.32:                                        ; preds = %if.end, %entry
  %34 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type33 = getelementptr inbounds %struct.op, %struct.op* %34, i32 0, i32 4
  %35 = load i16, i16* %op_type33, align 2
  %inc = add i16 %35, 1
  store i16 %inc, i16* %op_type33, align 2
  %idxprom34 = zext i16 %inc to i64
  %arrayidx35 = getelementptr inbounds [0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 %idxprom34
  %36 = load %struct.op* ()*, %struct.op* ()** %arrayidx35, align 8
  %37 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_ppaddr = getelementptr inbounds %struct.op, %struct.op* %37, i32 0, i32 2
  store %struct.op* ()* %36, %struct.op* ()** %op_ppaddr, align 8
  %38 = load %struct.op*, %struct.op** %o.addr, align 8
  %call36 = call %struct.op* @Perl_ck_fun(%struct.op* %38)
  store %struct.op* %call36, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.32, %if.then.29
  %39 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %39
}

; Function Attrs: nounwind uwtable
define internal %struct.op* @S_modkids(%struct.op* %o, i32 %type) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  %type.addr = alloca i32, align 4
  %kid = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  store i32 %type, i32* %type.addr, align 4
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %tobool = icmp ne %struct.op* %0, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 6
  %2 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 4
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %3 = load %struct.op*, %struct.op** %o.addr, align 8
  %4 = bitcast %struct.op* %3 to %struct.listop*
  %op_first = getelementptr inbounds %struct.listop, %struct.listop* %4, i32 0, i32 8
  %5 = load %struct.op*, %struct.op** %op_first, align 8
  store %struct.op* %5, %struct.op** %kid, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %6 = load %struct.op*, %struct.op** %kid, align 8
  %tobool2 = icmp ne %struct.op* %6, null
  br i1 %tobool2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load %struct.op*, %struct.op** %kid, align 8
  %8 = load i32, i32* %type.addr, align 4
  %call = call %struct.op* @Perl_mod(%struct.op* %7, i32 %8)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %9 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %9, i32 0, i32 1
  %10 = load %struct.op*, %struct.op** %op_sibling, align 8
  store %struct.op* %10, %struct.op** %kid, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end

if.end:                                           ; preds = %for.end, %land.lhs.true, %entry
  %11 = load %struct.op*, %struct.op** %o.addr, align 8
  ret %struct.op* %11
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_fun(%struct.op* %o) #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %o.addr = alloca %struct.op*, align 8
  %kid = alloca %struct.op*, align 8
  %tokid = alloca %struct.op**, align 8
  %sibl = alloca %struct.op*, align 8
  %numargs = alloca i32, align 4
  %type = alloca i32, align 4
  %oa = alloca i32, align 4
  %n_a = alloca i64, align 8
  %name = alloca i8*, align 8
  %newop = alloca %struct.op*, align 8
  %name196 = alloca i8*, align 8
  %newop211 = alloca %struct.op*, align 8
  %newop273 = alloca %struct.op*, align 8
  %newop299 = alloca %struct.op*, align 8
  %flags = alloca i32, align 4
  %priv = alloca i32, align 4
  %targ = alloca i64, align 8
  %name348 = alloca i8*, align 8
  %len = alloca i64, align 8
  %gv = alloca %struct.gv*, align 8
  %op = alloca %struct.op*, align 8
  %tmpstr = alloca %struct.sv*, align 8
  %a = alloca i8*, align 8
  %gv431 = alloca %struct.gv*, align 8
  %padname = alloca i8*, align 8
  %namesv = alloca %struct.sv*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  store i32 0, i32* %numargs, align 4
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %0, i32 0, i32 4
  %1 = load i16, i16* %op_type, align 2
  %conv = zext i16 %1 to i32
  store i32 %conv, i32* %type, align 4
  %2 = load i32, i32* %type, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [0 x i32], [0 x i32]* @PL_opargs, i32 0, i64 %idxprom
  %3 = load i32, i32* %arrayidx, align 4
  %shr = lshr i32 %3, 13
  store i32 %shr, i32* %oa, align 4
  %4 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %4, i32 0, i32 6
  %5 = load i8, i8* %op_flags, align 1
  %conv1 = zext i8 %5 to i32
  %and = and i32 %conv1, 64
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end.12

if.then:                                          ; preds = %entry
  %6 = load i32, i32* %oa, align 4
  %and2 = and i32 %6, 8
  %tobool3 = icmp ne i32 %and2, 0
  br i1 %tobool3, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.then
  %7 = load i32, i32* %oa, align 4
  %shr4 = ashr i32 %7, 4
  %tobool5 = icmp ne i32 %shr4, 0
  br i1 %tobool5, label %land.lhs.true.6, label %if.else

land.lhs.true.6:                                  ; preds = %land.lhs.true
  %8 = load i32, i32* %oa, align 4
  %shr7 = ashr i32 %8, 4
  %and8 = and i32 %shr7, 8
  %tobool9 = icmp ne i32 %and8, 0
  br i1 %tobool9, label %if.else, label %if.then.10

if.then.10:                                       ; preds = %land.lhs.true.6
  %9 = load i32, i32* %oa, align 4
  %and11 = and i32 %9, -9
  store i32 %and11, i32* %oa, align 4
  br label %if.end

if.else:                                          ; preds = %land.lhs.true.6, %land.lhs.true, %if.then
  %10 = load %struct.op*, %struct.op** %o.addr, align 8
  %call = call %struct.op* @S_no_fh_allowed(%struct.op* %10)
  store %struct.op* %call, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %if.then.10
  br label %if.end.12

if.end.12:                                        ; preds = %if.end, %entry
  %11 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags13 = getelementptr inbounds %struct.op, %struct.op* %11, i32 0, i32 6
  %12 = load i8, i8* %op_flags13, align 1
  %conv14 = zext i8 %12 to i32
  %and15 = and i32 %conv14, 4
  %tobool16 = icmp ne i32 %and15, 0
  br i1 %tobool16, label %if.then.17, label %if.else.566

if.then.17:                                       ; preds = %if.end.12
  %13 = load %struct.op*, %struct.op** %o.addr, align 8
  %14 = bitcast %struct.op* %13 to %struct.listop*
  %op_first = getelementptr inbounds %struct.listop, %struct.listop* %14, i32 0, i32 8
  store %struct.op** %op_first, %struct.op*** %tokid, align 8
  %15 = load %struct.op*, %struct.op** %o.addr, align 8
  %16 = bitcast %struct.op* %15 to %struct.listop*
  %op_first18 = getelementptr inbounds %struct.listop, %struct.listop* %16, i32 0, i32 8
  %17 = load %struct.op*, %struct.op** %op_first18, align 8
  store %struct.op* %17, %struct.op** %kid, align 8
  %18 = load %struct.op*, %struct.op** %kid, align 8
  %op_type19 = getelementptr inbounds %struct.op, %struct.op* %18, i32 0, i32 4
  %19 = load i16, i16* %op_type19, align 2
  %conv20 = zext i16 %19 to i32
  %cmp = icmp eq i32 %conv20, 3
  br i1 %cmp, label %if.then.29, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then.17
  %20 = load %struct.op*, %struct.op** %kid, align 8
  %op_type22 = getelementptr inbounds %struct.op, %struct.op* %20, i32 0, i32 4
  %21 = load i16, i16* %op_type22, align 2
  %conv23 = zext i16 %21 to i32
  %cmp24 = icmp eq i32 %conv23, 0
  br i1 %cmp24, label %land.lhs.true.26, label %if.end.31

land.lhs.true.26:                                 ; preds = %lor.lhs.false
  %22 = load %struct.op*, %struct.op** %kid, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %22, i32 0, i32 3
  %23 = load i64, i64* %op_targ, align 8
  %cmp27 = icmp eq i64 %23, 3
  br i1 %cmp27, label %if.then.29, label %if.end.31

if.then.29:                                       ; preds = %land.lhs.true.26, %if.then.17
  %24 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %24, i32 0, i32 1
  store %struct.op** %op_sibling, %struct.op*** %tokid, align 8
  %25 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling30 = getelementptr inbounds %struct.op, %struct.op* %25, i32 0, i32 1
  %26 = load %struct.op*, %struct.op** %op_sibling30, align 8
  store %struct.op* %26, %struct.op** %kid, align 8
  br label %if.end.31

if.end.31:                                        ; preds = %if.then.29, %land.lhs.true.26, %lor.lhs.false
  %27 = load %struct.op*, %struct.op** %kid, align 8
  %tobool32 = icmp ne %struct.op* %27, null
  br i1 %tobool32, label %if.end.40, label %land.lhs.true.33

land.lhs.true.33:                                 ; preds = %if.end.31
  %28 = load i32, i32* %type, align 4
  %idxprom34 = sext i32 %28 to i64
  %arrayidx35 = getelementptr inbounds [0 x i32], [0 x i32]* @PL_opargs, i32 0, i64 %idxprom34
  %29 = load i32, i32* %arrayidx35, align 4
  %and36 = and i32 %29, 128
  %tobool37 = icmp ne i32 %and36, 0
  br i1 %tobool37, label %if.then.38, label %if.end.40

if.then.38:                                       ; preds = %land.lhs.true.33
  %call39 = call %struct.op* @S_newDEFSVOP()
  store %struct.op* %call39, %struct.op** %kid, align 8
  %30 = load %struct.op**, %struct.op*** %tokid, align 8
  store %struct.op* %call39, %struct.op** %30, align 8
  br label %if.end.40

if.end.40:                                        ; preds = %if.then.38, %land.lhs.true.33, %if.end.31
  br label %while.cond

while.cond:                                       ; preds = %sw.epilog, %if.then.67, %if.end.40
  %31 = load i32, i32* %oa, align 4
  %tobool41 = icmp ne i32 %31, 0
  br i1 %tobool41, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %32 = load %struct.op*, %struct.op** %kid, align 8
  %tobool42 = icmp ne %struct.op* %32, null
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %33 = phi i1 [ false, %while.cond ], [ %tobool42, %land.rhs ]
  br i1 %33, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %34 = load i32, i32* %numargs, align 4
  %inc = add nsw i32 %34, 1
  store i32 %inc, i32* %numargs, align 4
  %35 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling43 = getelementptr inbounds %struct.op, %struct.op* %35, i32 0, i32 1
  %36 = load %struct.op*, %struct.op** %op_sibling43, align 8
  store %struct.op* %36, %struct.op** %sibl, align 8
  %37 = load i32, i32* %oa, align 4
  %and44 = and i32 %37, 7
  switch i32 %and44, label %sw.epilog [
    i32 1, label %sw.bb
    i32 2, label %sw.bb.64
    i32 3, label %sw.bb.71
    i32 4, label %sw.bb.185
    i32 5, label %sw.bb.272
    i32 6, label %sw.bb.278
    i32 7, label %sw.bb.539
  ]

sw.bb:                                            ; preds = %while.body
  %38 = load i32, i32* %numargs, align 4
  %cmp45 = icmp eq i32 %38, 1
  br i1 %cmp45, label %land.lhs.true.47, label %if.end.62

land.lhs.true.47:                                 ; preds = %sw.bb
  %39 = load i32, i32* %oa, align 4
  %shr48 = ashr i32 %39, 4
  %tobool49 = icmp ne i32 %shr48, 0
  br i1 %tobool49, label %if.end.62, label %land.lhs.true.50

land.lhs.true.50:                                 ; preds = %land.lhs.true.47
  %40 = load %struct.op*, %struct.op** %kid, align 8
  %op_type51 = getelementptr inbounds %struct.op, %struct.op* %40, i32 0, i32 4
  %41 = load i16, i16* %op_type51, align 2
  %conv52 = zext i16 %41 to i32
  %cmp53 = icmp eq i32 %conv52, 141
  br i1 %cmp53, label %land.lhs.true.55, label %if.end.62

land.lhs.true.55:                                 ; preds = %land.lhs.true.50
  %42 = load i32, i32* %type, align 4
  %cmp56 = icmp ne i32 %42, 2
  br i1 %cmp56, label %if.then.58, label %if.end.62

if.then.58:                                       ; preds = %land.lhs.true.55
  %43 = load %struct.op*, %struct.op** %o.addr, align 8
  %44 = load i32, i32* %type, align 4
  %idxprom59 = sext i32 %44 to i64
  %arrayidx60 = getelementptr inbounds [0 x i8*], [0 x i8*]* @PL_op_desc, i32 0, i64 %idxprom59
  %45 = load i8*, i8** %arrayidx60, align 8
  %call61 = call %struct.op* @S_too_many_arguments(%struct.op* %43, i8* %45)
  store %struct.op* %call61, %struct.op** %retval
  br label %return

if.end.62:                                        ; preds = %land.lhs.true.55, %land.lhs.true.50, %land.lhs.true.47, %sw.bb
  %46 = load %struct.op*, %struct.op** %kid, align 8
  %call63 = call %struct.op* @Perl_scalar(%struct.op* %46)
  br label %sw.epilog

sw.bb.64:                                         ; preds = %while.body
  %47 = load i32, i32* %oa, align 4
  %cmp65 = icmp slt i32 %47, 16
  br i1 %cmp65, label %if.then.67, label %if.else.68

if.then.67:                                       ; preds = %sw.bb.64
  store %struct.op* null, %struct.op** %kid, align 8
  br label %while.cond

if.else.68:                                       ; preds = %sw.bb.64
  %48 = load %struct.op*, %struct.op** %kid, align 8
  %call69 = call %struct.op* @Perl_list(%struct.op* %48)
  br label %if.end.70

if.end.70:                                        ; preds = %if.else.68
  br label %sw.epilog

sw.bb.71:                                         ; preds = %while.body
  %49 = load i32, i32* %type, align 4
  %cmp72 = icmp eq i32 %49, 146
  br i1 %cmp72, label %land.lhs.true.77, label %lor.lhs.false.74

lor.lhs.false.74:                                 ; preds = %sw.bb.71
  %50 = load i32, i32* %type, align 4
  %cmp75 = icmp eq i32 %50, 149
  br i1 %cmp75, label %land.lhs.true.77, label %if.end.108

land.lhs.true.77:                                 ; preds = %lor.lhs.false.74, %sw.bb.71
  %51 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling78 = getelementptr inbounds %struct.op, %struct.op* %51, i32 0, i32 1
  %52 = load %struct.op*, %struct.op** %op_sibling78, align 8
  %tobool79 = icmp ne %struct.op* %52, null
  br i1 %tobool79, label %if.end.108, label %land.lhs.true.80

land.lhs.true.80:                                 ; preds = %land.lhs.true.77
  %53 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings = getelementptr inbounds %struct.cop, %struct.cop* %53, i32 0, i32 14
  %54 = load %struct.sv*, %struct.sv** %cop_warnings, align 8
  %cmp81 = icmp ne %struct.sv* %54, null
  br i1 %cmp81, label %land.lhs.true.83, label %lor.lhs.false.97

land.lhs.true.83:                                 ; preds = %land.lhs.true.80
  %55 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings84 = getelementptr inbounds %struct.cop, %struct.cop* %55, i32 0, i32 14
  %56 = load %struct.sv*, %struct.sv** %cop_warnings84, align 8
  %cmp85 = icmp ne %struct.sv* %56, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 2)
  br i1 %cmp85, label %land.lhs.true.87, label %lor.lhs.false.97

land.lhs.true.87:                                 ; preds = %land.lhs.true.83
  %57 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings88 = getelementptr inbounds %struct.cop, %struct.cop* %57, i32 0, i32 14
  %58 = load %struct.sv*, %struct.sv** %cop_warnings88, align 8
  %cmp89 = icmp eq %struct.sv* %58, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 1)
  br i1 %cmp89, label %if.then.105, label %lor.lhs.false.91

lor.lhs.false.91:                                 ; preds = %land.lhs.true.87
  %59 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings92 = getelementptr inbounds %struct.cop, %struct.cop* %59, i32 0, i32 14
  %60 = load %struct.sv*, %struct.sv** %cop_warnings92, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %60, i32 0, i32 0
  %61 = load i8*, i8** %sv_any, align 8
  %62 = bitcast i8* %61 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %62, i32 0, i32 0
  %63 = load i8*, i8** %xpv_pv, align 8
  %arrayidx93 = getelementptr inbounds i8, i8* %63, i64 7
  %64 = load i8, i8* %arrayidx93, align 1
  %conv94 = sext i8 %64 to i32
  %and95 = and i32 %conv94, 1
  %tobool96 = icmp ne i32 %and95, 0
  br i1 %tobool96, label %if.then.105, label %lor.lhs.false.97

lor.lhs.false.97:                                 ; preds = %lor.lhs.false.91, %land.lhs.true.83, %land.lhs.true.80
  %65 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings98 = getelementptr inbounds %struct.cop, %struct.cop* %65, i32 0, i32 14
  %66 = load %struct.sv*, %struct.sv** %cop_warnings98, align 8
  %cmp99 = icmp eq %struct.sv* %66, null
  br i1 %cmp99, label %land.lhs.true.101, label %if.end.108

land.lhs.true.101:                                ; preds = %lor.lhs.false.97
  %67 = load i8, i8* @PL_dowarn, align 1
  %conv102 = zext i8 %67 to i32
  %and103 = and i32 %conv102, 1
  %tobool104 = icmp ne i32 %and103, 0
  br i1 %tobool104, label %if.then.105, label %if.end.108

if.then.105:                                      ; preds = %land.lhs.true.101, %lor.lhs.false.91, %land.lhs.true.87
  %68 = load i32, i32* %type, align 4
  %idxprom106 = sext i32 %68 to i64
  %arrayidx107 = getelementptr inbounds [0 x i8*], [0 x i8*]* @PL_op_desc, i32 0, i64 %idxprom106
  %69 = load i8*, i8** %arrayidx107, align 8
  call void (i32, i8*, ...) @Perl_warner(i32 28, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.97, i32 0, i32 0), i8* %69)
  br label %if.end.108

if.end.108:                                       ; preds = %if.then.105, %land.lhs.true.101, %lor.lhs.false.97, %land.lhs.true.77, %lor.lhs.false.74
  %70 = load %struct.op*, %struct.op** %kid, align 8
  %op_type109 = getelementptr inbounds %struct.op, %struct.op* %70, i32 0, i32 4
  %71 = load i16, i16* %op_type109, align 2
  %conv110 = zext i16 %71 to i32
  %cmp111 = icmp eq i32 %conv110, 5
  br i1 %cmp111, label %land.lhs.true.113, label %if.else.169

land.lhs.true.113:                                ; preds = %if.end.108
  %72 = load %struct.op*, %struct.op** %kid, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %72, i32 0, i32 7
  %73 = load i8, i8* %op_private, align 1
  %conv114 = zext i8 %73 to i32
  %and115 = and i32 %conv114, 64
  %tobool116 = icmp ne i32 %and115, 0
  br i1 %tobool116, label %if.then.117, label %if.else.169

if.then.117:                                      ; preds = %land.lhs.true.113
  %74 = load %struct.op*, %struct.op** %kid, align 8
  %75 = bitcast %struct.op* %74 to %struct.svop*
  %op_sv = getelementptr inbounds %struct.svop, %struct.svop* %75, i32 0, i32 8
  %76 = load %struct.sv*, %struct.sv** %op_sv, align 8
  store %struct.sv* %76, %struct.sv** @PL_Sv, align 8
  %77 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %77, i32 0, i32 2
  %78 = load i32, i32* %sv_flags, align 4
  %and118 = and i32 %78, 262144
  %cmp119 = icmp eq i32 %and118, 262144
  br i1 %cmp119, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.117
  %79 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any121 = getelementptr inbounds %struct.sv, %struct.sv* %79, i32 0, i32 0
  %80 = load i8*, i8** %sv_any121, align 8
  %81 = bitcast i8* %80 to %struct.xpv*
  %xpv_cur = getelementptr inbounds %struct.xpv, %struct.xpv* %81, i32 0, i32 1
  %82 = load i64, i64* %xpv_cur, align 8
  store i64 %82, i64* %n_a, align 8
  %83 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any122 = getelementptr inbounds %struct.sv, %struct.sv* %83, i32 0, i32 0
  %84 = load i8*, i8** %sv_any122, align 8
  %85 = bitcast i8* %84 to %struct.xpv*
  %xpv_pv123 = getelementptr inbounds %struct.xpv, %struct.xpv* %85, i32 0, i32 0
  %86 = load i8*, i8** %xpv_pv123, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then.117
  %87 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call124 = call i8* @Perl_sv_2pv_flags(%struct.sv* %87, i64* %n_a, i32 2)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %86, %cond.true ], [ %call124, %cond.false ]
  store i8* %cond, i8** %name, align 8
  %88 = load i8*, i8** %name, align 8
  %call125 = call %struct.gv* @Perl_gv_fetchpv(i8* %88, i32 1, i32 10)
  %call126 = call %struct.op* @Perl_newGVOP(i32 7, i32 0, %struct.gv* %call125)
  %call127 = call %struct.op* @Perl_newAVREF(%struct.op* %call126)
  store %struct.op* %call127, %struct.op** %newop, align 8
  %89 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings128 = getelementptr inbounds %struct.cop, %struct.cop* %89, i32 0, i32 14
  %90 = load %struct.sv*, %struct.sv** %cop_warnings128, align 8
  %cmp129 = icmp ne %struct.sv* %90, null
  br i1 %cmp129, label %land.lhs.true.131, label %lor.lhs.false.155

land.lhs.true.131:                                ; preds = %cond.end
  %91 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings132 = getelementptr inbounds %struct.cop, %struct.cop* %91, i32 0, i32 14
  %92 = load %struct.sv*, %struct.sv** %cop_warnings132, align 8
  %cmp133 = icmp ne %struct.sv* %92, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 2)
  br i1 %cmp133, label %land.lhs.true.135, label %lor.lhs.false.155

land.lhs.true.135:                                ; preds = %land.lhs.true.131
  %93 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings136 = getelementptr inbounds %struct.cop, %struct.cop* %93, i32 0, i32 14
  %94 = load %struct.sv*, %struct.sv** %cop_warnings136, align 8
  %cmp137 = icmp eq %struct.sv* %94, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 1)
  br i1 %cmp137, label %if.then.163, label %lor.lhs.false.139

lor.lhs.false.139:                                ; preds = %land.lhs.true.135
  %95 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings140 = getelementptr inbounds %struct.cop, %struct.cop* %95, i32 0, i32 14
  %96 = load %struct.sv*, %struct.sv** %cop_warnings140, align 8
  %sv_any141 = getelementptr inbounds %struct.sv, %struct.sv* %96, i32 0, i32 0
  %97 = load i8*, i8** %sv_any141, align 8
  %98 = bitcast i8* %97 to %struct.xpv*
  %xpv_pv142 = getelementptr inbounds %struct.xpv, %struct.xpv* %98, i32 0, i32 0
  %99 = load i8*, i8** %xpv_pv142, align 8
  %arrayidx143 = getelementptr inbounds i8, i8* %99, i64 0
  %100 = load i8, i8* %arrayidx143, align 1
  %conv144 = sext i8 %100 to i32
  %and145 = and i32 %conv144, 16
  %tobool146 = icmp ne i32 %and145, 0
  br i1 %tobool146, label %if.then.163, label %lor.lhs.false.147

lor.lhs.false.147:                                ; preds = %lor.lhs.false.139
  %101 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings148 = getelementptr inbounds %struct.cop, %struct.cop* %101, i32 0, i32 14
  %102 = load %struct.sv*, %struct.sv** %cop_warnings148, align 8
  %sv_any149 = getelementptr inbounds %struct.sv, %struct.sv* %102, i32 0, i32 0
  %103 = load i8*, i8** %sv_any149, align 8
  %104 = bitcast i8* %103 to %struct.xpv*
  %xpv_pv150 = getelementptr inbounds %struct.xpv, %struct.xpv* %104, i32 0, i32 0
  %105 = load i8*, i8** %xpv_pv150, align 8
  %arrayidx151 = getelementptr inbounds i8, i8* %105, i64 7
  %106 = load i8, i8* %arrayidx151, align 1
  %conv152 = sext i8 %106 to i32
  %and153 = and i32 %conv152, 1
  %tobool154 = icmp ne i32 %and153, 0
  br i1 %tobool154, label %if.then.163, label %lor.lhs.false.155

lor.lhs.false.155:                                ; preds = %lor.lhs.false.147, %land.lhs.true.131, %cond.end
  %107 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings156 = getelementptr inbounds %struct.cop, %struct.cop* %107, i32 0, i32 14
  %108 = load %struct.sv*, %struct.sv** %cop_warnings156, align 8
  %cmp157 = icmp eq %struct.sv* %108, null
  br i1 %cmp157, label %land.lhs.true.159, label %if.end.167

land.lhs.true.159:                                ; preds = %lor.lhs.false.155
  %109 = load i8, i8* @PL_dowarn, align 1
  %conv160 = zext i8 %109 to i32
  %and161 = and i32 %conv160, 1
  %tobool162 = icmp ne i32 %and161, 0
  br i1 %tobool162, label %if.then.163, label %if.end.167

if.then.163:                                      ; preds = %land.lhs.true.159, %lor.lhs.false.147, %lor.lhs.false.139, %land.lhs.true.135
  %110 = load i8*, i8** %name, align 8
  %111 = load i32, i32* %numargs, align 4
  %conv164 = sext i32 %111 to i64
  %112 = load i32, i32* %type, align 4
  %idxprom165 = sext i32 %112 to i64
  %arrayidx166 = getelementptr inbounds [0 x i8*], [0 x i8*]* @PL_op_desc, i32 0, i64 %idxprom165
  %113 = load i8*, i8** %arrayidx166, align 8
  call void (i32, i8*, ...) @Perl_warner(i32 7170, i8* getelementptr inbounds ([48 x i8], [48 x i8]* @.str.98, i32 0, i32 0), i8* %110, i64 %conv164, i8* %113)
  br label %if.end.167

if.end.167:                                       ; preds = %if.then.163, %land.lhs.true.159, %lor.lhs.false.155
  %114 = load %struct.op*, %struct.op** %kid, align 8
  call void @Perl_op_free(%struct.op* %114)
  %115 = load %struct.op*, %struct.op** %newop, align 8
  store %struct.op* %115, %struct.op** %kid, align 8
  %116 = load %struct.op*, %struct.op** %sibl, align 8
  %117 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling168 = getelementptr inbounds %struct.op, %struct.op* %117, i32 0, i32 1
  store %struct.op* %116, %struct.op** %op_sibling168, align 8
  %118 = load %struct.op*, %struct.op** %kid, align 8
  %119 = load %struct.op**, %struct.op*** %tokid, align 8
  store %struct.op* %118, %struct.op** %119, align 8
  br label %if.end.183

if.else.169:                                      ; preds = %land.lhs.true.113, %if.end.108
  %120 = load %struct.op*, %struct.op** %kid, align 8
  %op_type170 = getelementptr inbounds %struct.op, %struct.op* %120, i32 0, i32 4
  %121 = load i16, i16* %op_type170, align 2
  %conv171 = zext i16 %121 to i32
  %cmp172 = icmp ne i32 %conv171, 125
  br i1 %cmp172, label %land.lhs.true.174, label %if.end.182

land.lhs.true.174:                                ; preds = %if.else.169
  %122 = load %struct.op*, %struct.op** %kid, align 8
  %op_type175 = getelementptr inbounds %struct.op, %struct.op* %122, i32 0, i32 4
  %123 = load i16, i16* %op_type175, align 2
  %conv176 = zext i16 %123 to i32
  %cmp177 = icmp ne i32 %conv176, 10
  br i1 %cmp177, label %if.then.179, label %if.end.182

if.then.179:                                      ; preds = %land.lhs.true.174
  %124 = load i32, i32* %numargs, align 4
  %125 = load i32, i32* %type, align 4
  %idxprom180 = sext i32 %125 to i64
  %arrayidx181 = getelementptr inbounds [0 x i8*], [0 x i8*]* @PL_op_desc, i32 0, i64 %idxprom180
  %126 = load i8*, i8** %arrayidx181, align 8
  %127 = load %struct.op*, %struct.op** %kid, align 8
  call void @S_bad_type(i32 %124, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.99, i32 0, i32 0), i8* %126, %struct.op* %127)
  br label %if.end.182

if.end.182:                                       ; preds = %if.then.179, %land.lhs.true.174, %if.else.169
  br label %if.end.183

if.end.183:                                       ; preds = %if.end.182, %if.end.167
  %128 = load %struct.op*, %struct.op** %kid, align 8
  %129 = load i32, i32* %type, align 4
  %call184 = call %struct.op* @Perl_mod(%struct.op* %128, i32 %129)
  br label %sw.epilog

sw.bb.185:                                        ; preds = %while.body
  %130 = load %struct.op*, %struct.op** %kid, align 8
  %op_type186 = getelementptr inbounds %struct.op, %struct.op* %130, i32 0, i32 4
  %131 = load i16, i16* %op_type186, align 2
  %conv187 = zext i16 %131 to i32
  %cmp188 = icmp eq i32 %conv187, 5
  br i1 %cmp188, label %land.lhs.true.190, label %if.else.256

land.lhs.true.190:                                ; preds = %sw.bb.185
  %132 = load %struct.op*, %struct.op** %kid, align 8
  %op_private191 = getelementptr inbounds %struct.op, %struct.op* %132, i32 0, i32 7
  %133 = load i8, i8* %op_private191, align 1
  %conv192 = zext i8 %133 to i32
  %and193 = and i32 %conv192, 64
  %tobool194 = icmp ne i32 %and193, 0
  br i1 %tobool194, label %if.then.195, label %if.else.256

if.then.195:                                      ; preds = %land.lhs.true.190
  %134 = load %struct.op*, %struct.op** %kid, align 8
  %135 = bitcast %struct.op* %134 to %struct.svop*
  %op_sv197 = getelementptr inbounds %struct.svop, %struct.svop* %135, i32 0, i32 8
  %136 = load %struct.sv*, %struct.sv** %op_sv197, align 8
  store %struct.sv* %136, %struct.sv** @PL_Sv, align 8
  %137 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags198 = getelementptr inbounds %struct.sv, %struct.sv* %137, i32 0, i32 2
  %138 = load i32, i32* %sv_flags198, align 4
  %and199 = and i32 %138, 262144
  %cmp200 = icmp eq i32 %and199, 262144
  br i1 %cmp200, label %cond.true.202, label %cond.false.207

cond.true.202:                                    ; preds = %if.then.195
  %139 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any203 = getelementptr inbounds %struct.sv, %struct.sv* %139, i32 0, i32 0
  %140 = load i8*, i8** %sv_any203, align 8
  %141 = bitcast i8* %140 to %struct.xpv*
  %xpv_cur204 = getelementptr inbounds %struct.xpv, %struct.xpv* %141, i32 0, i32 1
  %142 = load i64, i64* %xpv_cur204, align 8
  store i64 %142, i64* %n_a, align 8
  %143 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any205 = getelementptr inbounds %struct.sv, %struct.sv* %143, i32 0, i32 0
  %144 = load i8*, i8** %sv_any205, align 8
  %145 = bitcast i8* %144 to %struct.xpv*
  %xpv_pv206 = getelementptr inbounds %struct.xpv, %struct.xpv* %145, i32 0, i32 0
  %146 = load i8*, i8** %xpv_pv206, align 8
  br label %cond.end.209

cond.false.207:                                   ; preds = %if.then.195
  %147 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call208 = call i8* @Perl_sv_2pv_flags(%struct.sv* %147, i64* %n_a, i32 2)
  br label %cond.end.209

cond.end.209:                                     ; preds = %cond.false.207, %cond.true.202
  %cond210 = phi i8* [ %146, %cond.true.202 ], [ %call208, %cond.false.207 ]
  store i8* %cond210, i8** %name196, align 8
  %148 = load i8*, i8** %name196, align 8
  %call212 = call %struct.gv* @Perl_gv_fetchpv(i8* %148, i32 1, i32 11)
  %call213 = call %struct.op* @Perl_newGVOP(i32 7, i32 0, %struct.gv* %call212)
  %call214 = call %struct.op* @Perl_newHVREF(%struct.op* %call213)
  store %struct.op* %call214, %struct.op** %newop211, align 8
  %149 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings215 = getelementptr inbounds %struct.cop, %struct.cop* %149, i32 0, i32 14
  %150 = load %struct.sv*, %struct.sv** %cop_warnings215, align 8
  %cmp216 = icmp ne %struct.sv* %150, null
  br i1 %cmp216, label %land.lhs.true.218, label %lor.lhs.false.242

land.lhs.true.218:                                ; preds = %cond.end.209
  %151 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings219 = getelementptr inbounds %struct.cop, %struct.cop* %151, i32 0, i32 14
  %152 = load %struct.sv*, %struct.sv** %cop_warnings219, align 8
  %cmp220 = icmp ne %struct.sv* %152, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 2)
  br i1 %cmp220, label %land.lhs.true.222, label %lor.lhs.false.242

land.lhs.true.222:                                ; preds = %land.lhs.true.218
  %153 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings223 = getelementptr inbounds %struct.cop, %struct.cop* %153, i32 0, i32 14
  %154 = load %struct.sv*, %struct.sv** %cop_warnings223, align 8
  %cmp224 = icmp eq %struct.sv* %154, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 1)
  br i1 %cmp224, label %if.then.250, label %lor.lhs.false.226

lor.lhs.false.226:                                ; preds = %land.lhs.true.222
  %155 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings227 = getelementptr inbounds %struct.cop, %struct.cop* %155, i32 0, i32 14
  %156 = load %struct.sv*, %struct.sv** %cop_warnings227, align 8
  %sv_any228 = getelementptr inbounds %struct.sv, %struct.sv* %156, i32 0, i32 0
  %157 = load i8*, i8** %sv_any228, align 8
  %158 = bitcast i8* %157 to %struct.xpv*
  %xpv_pv229 = getelementptr inbounds %struct.xpv, %struct.xpv* %158, i32 0, i32 0
  %159 = load i8*, i8** %xpv_pv229, align 8
  %arrayidx230 = getelementptr inbounds i8, i8* %159, i64 0
  %160 = load i8, i8* %arrayidx230, align 1
  %conv231 = sext i8 %160 to i32
  %and232 = and i32 %conv231, 16
  %tobool233 = icmp ne i32 %and232, 0
  br i1 %tobool233, label %if.then.250, label %lor.lhs.false.234

lor.lhs.false.234:                                ; preds = %lor.lhs.false.226
  %161 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings235 = getelementptr inbounds %struct.cop, %struct.cop* %161, i32 0, i32 14
  %162 = load %struct.sv*, %struct.sv** %cop_warnings235, align 8
  %sv_any236 = getelementptr inbounds %struct.sv, %struct.sv* %162, i32 0, i32 0
  %163 = load i8*, i8** %sv_any236, align 8
  %164 = bitcast i8* %163 to %struct.xpv*
  %xpv_pv237 = getelementptr inbounds %struct.xpv, %struct.xpv* %164, i32 0, i32 0
  %165 = load i8*, i8** %xpv_pv237, align 8
  %arrayidx238 = getelementptr inbounds i8, i8* %165, i64 7
  %166 = load i8, i8* %arrayidx238, align 1
  %conv239 = sext i8 %166 to i32
  %and240 = and i32 %conv239, 1
  %tobool241 = icmp ne i32 %and240, 0
  br i1 %tobool241, label %if.then.250, label %lor.lhs.false.242

lor.lhs.false.242:                                ; preds = %lor.lhs.false.234, %land.lhs.true.218, %cond.end.209
  %167 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings243 = getelementptr inbounds %struct.cop, %struct.cop* %167, i32 0, i32 14
  %168 = load %struct.sv*, %struct.sv** %cop_warnings243, align 8
  %cmp244 = icmp eq %struct.sv* %168, null
  br i1 %cmp244, label %land.lhs.true.246, label %if.end.254

land.lhs.true.246:                                ; preds = %lor.lhs.false.242
  %169 = load i8, i8* @PL_dowarn, align 1
  %conv247 = zext i8 %169 to i32
  %and248 = and i32 %conv247, 1
  %tobool249 = icmp ne i32 %and248, 0
  br i1 %tobool249, label %if.then.250, label %if.end.254

if.then.250:                                      ; preds = %land.lhs.true.246, %lor.lhs.false.234, %lor.lhs.false.226, %land.lhs.true.222
  %170 = load i8*, i8** %name196, align 8
  %171 = load i32, i32* %numargs, align 4
  %conv251 = sext i32 %171 to i64
  %172 = load i32, i32* %type, align 4
  %idxprom252 = sext i32 %172 to i64
  %arrayidx253 = getelementptr inbounds [0 x i8*], [0 x i8*]* @PL_op_desc, i32 0, i64 %idxprom252
  %173 = load i8*, i8** %arrayidx253, align 8
  call void (i32, i8*, ...) @Perl_warner(i32 7170, i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.100, i32 0, i32 0), i8* %170, i64 %conv251, i8* %173)
  br label %if.end.254

if.end.254:                                       ; preds = %if.then.250, %land.lhs.true.246, %lor.lhs.false.242
  %174 = load %struct.op*, %struct.op** %kid, align 8
  call void @Perl_op_free(%struct.op* %174)
  %175 = load %struct.op*, %struct.op** %newop211, align 8
  store %struct.op* %175, %struct.op** %kid, align 8
  %176 = load %struct.op*, %struct.op** %sibl, align 8
  %177 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling255 = getelementptr inbounds %struct.op, %struct.op* %177, i32 0, i32 1
  store %struct.op* %176, %struct.op** %op_sibling255, align 8
  %178 = load %struct.op*, %struct.op** %kid, align 8
  %179 = load %struct.op**, %struct.op*** %tokid, align 8
  store %struct.op* %178, %struct.op** %179, align 8
  br label %if.end.270

if.else.256:                                      ; preds = %land.lhs.true.190, %sw.bb.185
  %180 = load %struct.op*, %struct.op** %kid, align 8
  %op_type257 = getelementptr inbounds %struct.op, %struct.op* %180, i32 0, i32 4
  %181 = load i16, i16* %op_type257, align 2
  %conv258 = zext i16 %181 to i32
  %cmp259 = icmp ne i32 %conv258, 134
  br i1 %cmp259, label %land.lhs.true.261, label %if.end.269

land.lhs.true.261:                                ; preds = %if.else.256
  %182 = load %struct.op*, %struct.op** %kid, align 8
  %op_type262 = getelementptr inbounds %struct.op, %struct.op* %182, i32 0, i32 4
  %183 = load i16, i16* %op_type262, align 2
  %conv263 = zext i16 %183 to i32
  %cmp264 = icmp ne i32 %conv263, 11
  br i1 %cmp264, label %if.then.266, label %if.end.269

if.then.266:                                      ; preds = %land.lhs.true.261
  %184 = load i32, i32* %numargs, align 4
  %185 = load i32, i32* %type, align 4
  %idxprom267 = sext i32 %185 to i64
  %arrayidx268 = getelementptr inbounds [0 x i8*], [0 x i8*]* @PL_op_desc, i32 0, i64 %idxprom267
  %186 = load i8*, i8** %arrayidx268, align 8
  %187 = load %struct.op*, %struct.op** %kid, align 8
  call void @S_bad_type(i32 %184, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.101, i32 0, i32 0), i8* %186, %struct.op* %187)
  br label %if.end.269

if.end.269:                                       ; preds = %if.then.266, %land.lhs.true.261, %if.else.256
  br label %if.end.270

if.end.270:                                       ; preds = %if.end.269, %if.end.254
  %188 = load %struct.op*, %struct.op** %kid, align 8
  %189 = load i32, i32* %type, align 4
  %call271 = call %struct.op* @Perl_mod(%struct.op* %188, i32 %189)
  br label %sw.epilog

sw.bb.272:                                        ; preds = %while.body
  %190 = load %struct.op*, %struct.op** %kid, align 8
  %call274 = call %struct.op* @Perl_newUNOP(i32 0, i32 0, %struct.op* %190)
  store %struct.op* %call274, %struct.op** %newop273, align 8
  %191 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling275 = getelementptr inbounds %struct.op, %struct.op* %191, i32 0, i32 1
  store %struct.op* null, %struct.op** %op_sibling275, align 8
  %192 = load %struct.op*, %struct.op** %kid, align 8
  %call276 = call %struct.op* @Perl_linklist(%struct.op* %192)
  %193 = load %struct.op*, %struct.op** %newop273, align 8
  %194 = load %struct.op*, %struct.op** %newop273, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %194, i32 0, i32 0
  store %struct.op* %193, %struct.op** %op_next, align 8
  %195 = load %struct.op*, %struct.op** %newop273, align 8
  store %struct.op* %195, %struct.op** %kid, align 8
  %196 = load %struct.op*, %struct.op** %sibl, align 8
  %197 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling277 = getelementptr inbounds %struct.op, %struct.op* %197, i32 0, i32 1
  store %struct.op* %196, %struct.op** %op_sibling277, align 8
  %198 = load %struct.op*, %struct.op** %kid, align 8
  %199 = load %struct.op**, %struct.op*** %tokid, align 8
  store %struct.op* %198, %struct.op** %199, align 8
  br label %sw.epilog

sw.bb.278:                                        ; preds = %while.body
  %200 = load %struct.op*, %struct.op** %kid, align 8
  %op_type279 = getelementptr inbounds %struct.op, %struct.op* %200, i32 0, i32 4
  %201 = load i16, i16* %op_type279, align 2
  %conv280 = zext i16 %201 to i32
  %cmp281 = icmp ne i32 %conv280, 7
  br i1 %cmp281, label %land.lhs.true.283, label %if.end.537

land.lhs.true.283:                                ; preds = %sw.bb.278
  %202 = load %struct.op*, %struct.op** %kid, align 8
  %op_type284 = getelementptr inbounds %struct.op, %struct.op* %202, i32 0, i32 4
  %203 = load i16, i16* %op_type284, align 2
  %conv285 = zext i16 %203 to i32
  %cmp286 = icmp ne i32 %conv285, 14
  br i1 %cmp286, label %if.then.288, label %if.end.537

if.then.288:                                      ; preds = %land.lhs.true.283
  %204 = load %struct.op*, %struct.op** %kid, align 8
  %op_type289 = getelementptr inbounds %struct.op, %struct.op* %204, i32 0, i32 4
  %205 = load i16, i16* %op_type289, align 2
  %conv290 = zext i16 %205 to i32
  %cmp291 = icmp eq i32 %conv290, 5
  br i1 %cmp291, label %land.lhs.true.293, label %if.else.326

land.lhs.true.293:                                ; preds = %if.then.288
  %206 = load %struct.op*, %struct.op** %kid, align 8
  %op_private294 = getelementptr inbounds %struct.op, %struct.op* %206, i32 0, i32 7
  %207 = load i8, i8* %op_private294, align 1
  %conv295 = zext i8 %207 to i32
  %and296 = and i32 %conv295, 64
  %tobool297 = icmp ne i32 %and296, 0
  br i1 %tobool297, label %if.then.298, label %if.else.326

if.then.298:                                      ; preds = %land.lhs.true.293
  %208 = load %struct.op*, %struct.op** %kid, align 8
  %209 = bitcast %struct.op* %208 to %struct.svop*
  %op_sv300 = getelementptr inbounds %struct.svop, %struct.svop* %209, i32 0, i32 8
  %210 = load %struct.sv*, %struct.sv** %op_sv300, align 8
  store %struct.sv* %210, %struct.sv** @PL_Sv, align 8
  %211 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags301 = getelementptr inbounds %struct.sv, %struct.sv* %211, i32 0, i32 2
  %212 = load i32, i32* %sv_flags301, align 4
  %and302 = and i32 %212, 262144
  %cmp303 = icmp eq i32 %and302, 262144
  br i1 %cmp303, label %cond.true.305, label %cond.false.310

cond.true.305:                                    ; preds = %if.then.298
  %213 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any306 = getelementptr inbounds %struct.sv, %struct.sv* %213, i32 0, i32 0
  %214 = load i8*, i8** %sv_any306, align 8
  %215 = bitcast i8* %214 to %struct.xpv*
  %xpv_cur307 = getelementptr inbounds %struct.xpv, %struct.xpv* %215, i32 0, i32 1
  %216 = load i64, i64* %xpv_cur307, align 8
  store i64 %216, i64* %n_a, align 8
  %217 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any308 = getelementptr inbounds %struct.sv, %struct.sv* %217, i32 0, i32 0
  %218 = load i8*, i8** %sv_any308, align 8
  %219 = bitcast i8* %218 to %struct.xpv*
  %xpv_pv309 = getelementptr inbounds %struct.xpv, %struct.xpv* %219, i32 0, i32 0
  %220 = load i8*, i8** %xpv_pv309, align 8
  br label %cond.end.312

cond.false.310:                                   ; preds = %if.then.298
  %221 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call311 = call i8* @Perl_sv_2pv_flags(%struct.sv* %221, i64* %n_a, i32 2)
  br label %cond.end.312

cond.end.312:                                     ; preds = %cond.false.310, %cond.true.305
  %cond313 = phi i8* [ %220, %cond.true.305 ], [ %call311, %cond.false.310 ]
  %call314 = call %struct.gv* @Perl_gv_fetchpv(i8* %cond313, i32 1, i32 15)
  %call315 = call %struct.op* @Perl_newGVOP(i32 7, i32 0, %struct.gv* %call314)
  store %struct.op* %call315, %struct.op** %newop299, align 8
  %222 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private316 = getelementptr inbounds %struct.op, %struct.op* %222, i32 0, i32 7
  %223 = load i8, i8* %op_private316, align 1
  %conv317 = zext i8 %223 to i32
  %and318 = and i32 %conv317, 1
  %tobool319 = icmp ne i32 %and318, 0
  br i1 %tobool319, label %if.end.325, label %land.lhs.true.320

land.lhs.true.320:                                ; preds = %cond.end.312
  %224 = load %struct.op*, %struct.op** %kid, align 8
  %225 = load %struct.op*, %struct.op** %o.addr, align 8
  %226 = bitcast %struct.op* %225 to %struct.listop*
  %op_last = getelementptr inbounds %struct.listop, %struct.listop* %226, i32 0, i32 9
  %227 = load %struct.op*, %struct.op** %op_last, align 8
  %cmp321 = icmp eq %struct.op* %224, %227
  br i1 %cmp321, label %if.then.323, label %if.end.325

if.then.323:                                      ; preds = %land.lhs.true.320
  %228 = load %struct.op*, %struct.op** %newop299, align 8
  %229 = load %struct.op*, %struct.op** %o.addr, align 8
  %230 = bitcast %struct.op* %229 to %struct.listop*
  %op_last324 = getelementptr inbounds %struct.listop, %struct.listop* %230, i32 0, i32 9
  store %struct.op* %228, %struct.op** %op_last324, align 8
  br label %if.end.325

if.end.325:                                       ; preds = %if.then.323, %land.lhs.true.320, %cond.end.312
  %231 = load %struct.op*, %struct.op** %kid, align 8
  call void @Perl_op_free(%struct.op* %231)
  %232 = load %struct.op*, %struct.op** %newop299, align 8
  store %struct.op* %232, %struct.op** %kid, align 8
  br label %if.end.535

if.else.326:                                      ; preds = %land.lhs.true.293, %if.then.288
  %233 = load %struct.op*, %struct.op** %kid, align 8
  %op_type327 = getelementptr inbounds %struct.op, %struct.op* %233, i32 0, i32 4
  %234 = load i16, i16* %op_type327, align 2
  %conv328 = zext i16 %234 to i32
  %cmp329 = icmp eq i32 %conv328, 26
  br i1 %cmp329, label %if.then.331, label %if.else.344

if.then.331:                                      ; preds = %if.else.326
  %235 = load i32, i32* %numargs, align 4
  %236 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type332 = getelementptr inbounds %struct.op, %struct.op* %236, i32 0, i32 4
  %237 = load i16, i16* %op_type332, align 2
  %conv333 = zext i16 %237 to i32
  %cmp334 = icmp eq i32 %conv333, 351
  br i1 %cmp334, label %cond.true.336, label %cond.false.338

cond.true.336:                                    ; preds = %if.then.331
  %238 = load %struct.op*, %struct.op** %o.addr, align 8
  %call337 = call i8* @Perl_custom_op_desc(%struct.op* %238)
  br label %cond.end.342

cond.false.338:                                   ; preds = %if.then.331
  %239 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type339 = getelementptr inbounds %struct.op, %struct.op* %239, i32 0, i32 4
  %240 = load i16, i16* %op_type339, align 2
  %idxprom340 = zext i16 %240 to i64
  %arrayidx341 = getelementptr inbounds [0 x i8*], [0 x i8*]* @PL_op_desc, i32 0, i64 %idxprom340
  %241 = load i8*, i8** %arrayidx341, align 8
  br label %cond.end.342

cond.end.342:                                     ; preds = %cond.false.338, %cond.true.336
  %cond343 = phi i8* [ %call337, %cond.true.336 ], [ %241, %cond.false.338 ]
  %242 = load %struct.op*, %struct.op** %kid, align 8
  call void @S_bad_type(i32 %235, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.102, i32 0, i32 0), i8* %cond343, %struct.op* %242)
  br label %if.end.534

if.else.344:                                      ; preds = %if.else.326
  store i32 128, i32* %flags, align 4
  store i32 0, i32* %priv, align 4
  store i64 0, i64* %targ, align 8
  %243 = load %struct.op*, %struct.op** %o.addr, align 8
  %244 = load i32, i32* %numargs, align 4
  %call345 = call signext i8 @S_is_handle_constructor(%struct.op* %243, i32 %244)
  %tobool346 = icmp ne i8 %call345, 0
  br i1 %tobool346, label %if.then.347, label %if.end.526

if.then.347:                                      ; preds = %if.else.344
  store i8* null, i8** %name348, align 8
  store i64 0, i64* %len, align 8
  store i32 0, i32* %flags, align 4
  store i32 96, i32* %priv, align 4
  %245 = load %struct.op*, %struct.op** %kid, align 8
  %op_type349 = getelementptr inbounds %struct.op, %struct.op* %245, i32 0, i32 4
  %246 = load i16, i16* %op_type349, align 2
  %conv350 = zext i16 %246 to i32
  %cmp351 = icmp eq i32 %conv350, 9
  br i1 %cmp351, label %if.then.353, label %if.else.378

if.then.353:                                      ; preds = %if.then.347
  %247 = load %struct.av*, %struct.av** @PL_comppad_name, align 8
  %248 = load %struct.op*, %struct.op** %kid, align 8
  %op_targ354 = getelementptr inbounds %struct.op, %struct.op* %248, i32 0, i32 3
  %249 = load i64, i64* %op_targ354, align 8
  %conv355 = trunc i64 %249 to i32
  %call356 = call %struct.sv** @Perl_av_fetch(%struct.av* %247, i32 %conv355, i32 0)
  %250 = load %struct.sv*, %struct.sv** %call356, align 8
  %sv_flags357 = getelementptr inbounds %struct.sv, %struct.sv* %250, i32 0, i32 2
  %251 = load i32, i32* %sv_flags357, align 4
  %and358 = and i32 %251, 262144
  %cmp359 = icmp eq i32 %and358, 262144
  br i1 %cmp359, label %cond.true.361, label %cond.false.367

cond.true.361:                                    ; preds = %if.then.353
  %252 = load %struct.av*, %struct.av** @PL_comppad_name, align 8
  %253 = load %struct.op*, %struct.op** %kid, align 8
  %op_targ362 = getelementptr inbounds %struct.op, %struct.op* %253, i32 0, i32 3
  %254 = load i64, i64* %op_targ362, align 8
  %conv363 = trunc i64 %254 to i32
  %call364 = call %struct.sv** @Perl_av_fetch(%struct.av* %252, i32 %conv363, i32 0)
  %255 = load %struct.sv*, %struct.sv** %call364, align 8
  %sv_any365 = getelementptr inbounds %struct.sv, %struct.sv* %255, i32 0, i32 0
  %256 = load i8*, i8** %sv_any365, align 8
  %257 = bitcast i8* %256 to %struct.xpv*
  %xpv_pv366 = getelementptr inbounds %struct.xpv, %struct.xpv* %257, i32 0, i32 0
  %258 = load i8*, i8** %xpv_pv366, align 8
  br label %cond.end.372

cond.false.367:                                   ; preds = %if.then.353
  %259 = load %struct.av*, %struct.av** @PL_comppad_name, align 8
  %260 = load %struct.op*, %struct.op** %kid, align 8
  %op_targ368 = getelementptr inbounds %struct.op, %struct.op* %260, i32 0, i32 3
  %261 = load i64, i64* %op_targ368, align 8
  %conv369 = trunc i64 %261 to i32
  %call370 = call %struct.sv** @Perl_av_fetch(%struct.av* %259, i32 %conv369, i32 0)
  %262 = load %struct.sv*, %struct.sv** %call370, align 8
  %call371 = call i8* @Perl_sv_2pv_nolen(%struct.sv* %262)
  br label %cond.end.372

cond.end.372:                                     ; preds = %cond.false.367, %cond.true.361
  %cond373 = phi i8* [ %258, %cond.true.361 ], [ %call371, %cond.false.367 ]
  store i8* %cond373, i8** %name348, align 8
  %263 = load i8*, i8** %name348, align 8
  %tobool374 = icmp ne i8* %263, null
  br i1 %tobool374, label %if.then.375, label %if.end.377

if.then.375:                                      ; preds = %cond.end.372
  %264 = load i8*, i8** %name348, align 8
  %call376 = call i64 @strlen(i8* %264)
  store i64 %call376, i64* %len, align 8
  br label %if.end.377

if.end.377:                                       ; preds = %if.then.375, %cond.end.372
  br label %if.end.508

if.else.378:                                      ; preds = %if.then.347
  %265 = load %struct.op*, %struct.op** %kid, align 8
  %op_type379 = getelementptr inbounds %struct.op, %struct.op* %265, i32 0, i32 4
  %266 = load i16, i16* %op_type379, align 2
  %conv380 = zext i16 %266 to i32
  %cmp381 = icmp eq i32 %conv380, 15
  br i1 %cmp381, label %land.lhs.true.383, label %if.else.394

land.lhs.true.383:                                ; preds = %if.else.378
  %267 = load %struct.op*, %struct.op** %kid, align 8
  %268 = bitcast %struct.op* %267 to %struct.unop*
  %op_first384 = getelementptr inbounds %struct.unop, %struct.unop* %268, i32 0, i32 8
  %269 = load %struct.op*, %struct.op** %op_first384, align 8
  %op_type385 = getelementptr inbounds %struct.op, %struct.op* %269, i32 0, i32 4
  %270 = load i16, i16* %op_type385, align 2
  %conv386 = zext i16 %270 to i32
  %cmp387 = icmp eq i32 %conv386, 7
  br i1 %cmp387, label %if.then.389, label %if.else.394

if.then.389:                                      ; preds = %land.lhs.true.383
  %271 = load %struct.op*, %struct.op** %kid, align 8
  %272 = bitcast %struct.op* %271 to %struct.unop*
  %op_first390 = getelementptr inbounds %struct.unop, %struct.unop* %272, i32 0, i32 8
  %273 = load %struct.op*, %struct.op** %op_first390, align 8
  %274 = bitcast %struct.op* %273 to %struct.svop*
  %op_sv391 = getelementptr inbounds %struct.svop, %struct.svop* %274, i32 0, i32 8
  %275 = load %struct.sv*, %struct.sv** %op_sv391, align 8
  %276 = bitcast %struct.sv* %275 to %struct.gv*
  store %struct.gv* %276, %struct.gv** %gv, align 8
  %277 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any392 = getelementptr inbounds %struct.gv, %struct.gv* %277, i32 0, i32 0
  %278 = load %struct.xpvgv*, %struct.xpvgv** %sv_any392, align 8
  %xgv_name = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %278, i32 0, i32 8
  %279 = load i8*, i8** %xgv_name, align 8
  store i8* %279, i8** %name348, align 8
  %280 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any393 = getelementptr inbounds %struct.gv, %struct.gv* %280, i32 0, i32 0
  %281 = load %struct.xpvgv*, %struct.xpvgv** %sv_any393, align 8
  %xgv_namelen = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %281, i32 0, i32 9
  %282 = load i64, i64* %xgv_namelen, align 8
  store i64 %282, i64* %len, align 8
  br label %if.end.507

if.else.394:                                      ; preds = %land.lhs.true.383, %if.else.378
  %283 = load %struct.op*, %struct.op** %kid, align 8
  %op_type395 = getelementptr inbounds %struct.op, %struct.op* %283, i32 0, i32 4
  %284 = load i16, i16* %op_type395, align 2
  %conv396 = zext i16 %284 to i32
  %cmp397 = icmp eq i32 %conv396, 127
  br i1 %cmp397, label %if.then.404, label %lor.lhs.false.399

lor.lhs.false.399:                                ; preds = %if.else.394
  %285 = load %struct.op*, %struct.op** %kid, align 8
  %op_type400 = getelementptr inbounds %struct.op, %struct.op* %285, i32 0, i32 4
  %286 = load i16, i16* %op_type400, align 2
  %conv401 = zext i16 %286 to i32
  %cmp402 = icmp eq i32 %conv401, 135
  br i1 %cmp402, label %if.then.404, label %if.end.506

if.then.404:                                      ; preds = %lor.lhs.false.399, %if.else.394
  store i8* null, i8** %name348, align 8
  %287 = load %struct.op*, %struct.op** %kid, align 8
  %288 = bitcast %struct.op* %287 to %struct.binop*
  %op_first405 = getelementptr inbounds %struct.binop, %struct.binop* %288, i32 0, i32 8
  %289 = load %struct.op*, %struct.op** %op_first405, align 8
  store %struct.op* %289, %struct.op** %op, align 8
  %tobool406 = icmp ne %struct.op* %289, null
  br i1 %tobool406, label %if.then.407, label %if.end.501

if.then.407:                                      ; preds = %if.then.404
  store %struct.sv* null, %struct.sv** %tmpstr, align 8
  %290 = load %struct.op*, %struct.op** %kid, align 8
  %op_type408 = getelementptr inbounds %struct.op, %struct.op* %290, i32 0, i32 4
  %291 = load i16, i16* %op_type408, align 2
  %conv409 = zext i16 %291 to i32
  %cmp410 = icmp eq i32 %conv409, 127
  %cond412 = select i1 %cmp410, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.103, i32 0, i32 0), i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.104, i32 0, i32 0)
  store i8* %cond412, i8** %a, align 8
  %292 = load %struct.op*, %struct.op** %op, align 8
  %op_type413 = getelementptr inbounds %struct.op, %struct.op* %292, i32 0, i32 4
  %293 = load i16, i16* %op_type413, align 2
  %conv414 = zext i16 %293 to i32
  %cmp415 = icmp eq i32 %conv414, 125
  br i1 %cmp415, label %land.lhs.true.422, label %lor.lhs.false.417

lor.lhs.false.417:                                ; preds = %if.then.407
  %294 = load %struct.op*, %struct.op** %op, align 8
  %op_type418 = getelementptr inbounds %struct.op, %struct.op* %294, i32 0, i32 4
  %295 = load i16, i16* %op_type418, align 2
  %conv419 = zext i16 %295 to i32
  %cmp420 = icmp eq i32 %conv419, 134
  br i1 %cmp420, label %land.lhs.true.422, label %if.else.443

land.lhs.true.422:                                ; preds = %lor.lhs.false.417, %if.then.407
  %296 = load %struct.op*, %struct.op** %op, align 8
  %297 = bitcast %struct.op* %296 to %struct.unop*
  %op_first423 = getelementptr inbounds %struct.unop, %struct.unop* %297, i32 0, i32 8
  %298 = load %struct.op*, %struct.op** %op_first423, align 8
  store %struct.op* %298, %struct.op** %op, align 8
  %tobool424 = icmp ne %struct.op* %298, null
  br i1 %tobool424, label %land.lhs.true.425, label %if.else.443

land.lhs.true.425:                                ; preds = %land.lhs.true.422
  %299 = load %struct.op*, %struct.op** %op, align 8
  %op_type426 = getelementptr inbounds %struct.op, %struct.op* %299, i32 0, i32 4
  %300 = load i16, i16* %op_type426, align 2
  %conv427 = zext i16 %300 to i32
  %cmp428 = icmp eq i32 %conv427, 7
  br i1 %cmp428, label %if.then.430, label %if.else.443

if.then.430:                                      ; preds = %land.lhs.true.425
  %301 = load %struct.op*, %struct.op** %op, align 8
  %302 = bitcast %struct.op* %301 to %struct.svop*
  %op_sv432 = getelementptr inbounds %struct.svop, %struct.svop* %302, i32 0, i32 8
  %303 = load %struct.sv*, %struct.sv** %op_sv432, align 8
  %304 = bitcast %struct.sv* %303 to %struct.gv*
  store %struct.gv* %304, %struct.gv** %gv431, align 8
  %305 = load %struct.gv*, %struct.gv** %gv431, align 8
  %tobool433 = icmp ne %struct.gv* %305, null
  br i1 %tobool433, label %if.then.434, label %if.end.442

if.then.434:                                      ; preds = %if.then.430
  %306 = load %struct.gv*, %struct.gv** %gv431, align 8
  %sv_any435 = getelementptr inbounds %struct.gv, %struct.gv* %306, i32 0, i32 0
  %307 = load %struct.xpvgv*, %struct.xpvgv** %sv_any435, align 8
  %xgv_name436 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %307, i32 0, i32 8
  %308 = load i8*, i8** %xgv_name436, align 8
  %309 = load i8*, i8** %a, align 8
  %arrayidx437 = getelementptr inbounds i8, i8* %309, i64 0
  %310 = load i8, i8* %arrayidx437, align 1
  %conv438 = sext i8 %310 to i32
  %311 = load i8*, i8** %a, align 8
  %arrayidx439 = getelementptr inbounds i8, i8* %311, i64 1
  %312 = load i8, i8* %arrayidx439, align 1
  %conv440 = sext i8 %312 to i32
  %call441 = call %struct.sv* (i8*, ...) @Perl_newSVpvf(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.105, i32 0, i32 0), i8* %308, i32 %conv438, i32 %conv440)
  store %struct.sv* %call441, %struct.sv** %tmpstr, align 8
  br label %if.end.442

if.end.442:                                       ; preds = %if.then.434, %if.then.430
  br label %if.end.483

if.else.443:                                      ; preds = %land.lhs.true.425, %land.lhs.true.422, %lor.lhs.false.417
  %313 = load %struct.op*, %struct.op** %op, align 8
  %op_type444 = getelementptr inbounds %struct.op, %struct.op* %313, i32 0, i32 4
  %314 = load i16, i16* %op_type444, align 2
  %conv445 = zext i16 %314 to i32
  %cmp446 = icmp eq i32 %conv445, 10
  br i1 %cmp446, label %if.then.453, label %lor.lhs.false.448

lor.lhs.false.448:                                ; preds = %if.else.443
  %315 = load %struct.op*, %struct.op** %op, align 8
  %op_type449 = getelementptr inbounds %struct.op, %struct.op* %315, i32 0, i32 4
  %316 = load i16, i16* %op_type449, align 2
  %conv450 = zext i16 %316 to i32
  %cmp451 = icmp eq i32 %conv450, 11
  br i1 %cmp451, label %if.then.453, label %if.end.482

if.then.453:                                      ; preds = %lor.lhs.false.448, %if.else.443
  %317 = load %struct.av*, %struct.av** @PL_comppad_name, align 8
  %318 = load %struct.op*, %struct.op** %op, align 8
  %op_targ454 = getelementptr inbounds %struct.op, %struct.op* %318, i32 0, i32 3
  %319 = load i64, i64* %op_targ454, align 8
  %conv455 = trunc i64 %319 to i32
  %call456 = call %struct.sv** @Perl_av_fetch(%struct.av* %317, i32 %conv455, i32 0)
  %320 = load %struct.sv*, %struct.sv** %call456, align 8
  %sv_flags457 = getelementptr inbounds %struct.sv, %struct.sv* %320, i32 0, i32 2
  %321 = load i32, i32* %sv_flags457, align 4
  %and458 = and i32 %321, 262144
  %cmp459 = icmp eq i32 %and458, 262144
  br i1 %cmp459, label %cond.true.461, label %cond.false.467

cond.true.461:                                    ; preds = %if.then.453
  %322 = load %struct.av*, %struct.av** @PL_comppad_name, align 8
  %323 = load %struct.op*, %struct.op** %op, align 8
  %op_targ462 = getelementptr inbounds %struct.op, %struct.op* %323, i32 0, i32 3
  %324 = load i64, i64* %op_targ462, align 8
  %conv463 = trunc i64 %324 to i32
  %call464 = call %struct.sv** @Perl_av_fetch(%struct.av* %322, i32 %conv463, i32 0)
  %325 = load %struct.sv*, %struct.sv** %call464, align 8
  %sv_any465 = getelementptr inbounds %struct.sv, %struct.sv* %325, i32 0, i32 0
  %326 = load i8*, i8** %sv_any465, align 8
  %327 = bitcast i8* %326 to %struct.xpv*
  %xpv_pv466 = getelementptr inbounds %struct.xpv, %struct.xpv* %327, i32 0, i32 0
  %328 = load i8*, i8** %xpv_pv466, align 8
  br label %cond.end.472

cond.false.467:                                   ; preds = %if.then.453
  %329 = load %struct.av*, %struct.av** @PL_comppad_name, align 8
  %330 = load %struct.op*, %struct.op** %op, align 8
  %op_targ468 = getelementptr inbounds %struct.op, %struct.op* %330, i32 0, i32 3
  %331 = load i64, i64* %op_targ468, align 8
  %conv469 = trunc i64 %331 to i32
  %call470 = call %struct.sv** @Perl_av_fetch(%struct.av* %329, i32 %conv469, i32 0)
  %332 = load %struct.sv*, %struct.sv** %call470, align 8
  %call471 = call i8* @Perl_sv_2pv_nolen(%struct.sv* %332)
  br label %cond.end.472

cond.end.472:                                     ; preds = %cond.false.467, %cond.true.461
  %cond473 = phi i8* [ %328, %cond.true.461 ], [ %call471, %cond.false.467 ]
  store i8* %cond473, i8** %padname, align 8
  %333 = load i8*, i8** %padname, align 8
  %tobool474 = icmp ne i8* %333, null
  br i1 %tobool474, label %if.then.475, label %if.end.481

if.then.475:                                      ; preds = %cond.end.472
  %334 = load i8*, i8** %padname, align 8
  %add.ptr = getelementptr inbounds i8, i8* %334, i64 1
  %335 = load i8*, i8** %a, align 8
  %arrayidx476 = getelementptr inbounds i8, i8* %335, i64 0
  %336 = load i8, i8* %arrayidx476, align 1
  %conv477 = sext i8 %336 to i32
  %337 = load i8*, i8** %a, align 8
  %arrayidx478 = getelementptr inbounds i8, i8* %337, i64 1
  %338 = load i8, i8* %arrayidx478, align 1
  %conv479 = sext i8 %338 to i32
  %call480 = call %struct.sv* (i8*, ...) @Perl_newSVpvf(i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.105, i32 0, i32 0), i8* %add.ptr, i32 %conv477, i32 %conv479)
  store %struct.sv* %call480, %struct.sv** %tmpstr, align 8
  br label %if.end.481

if.end.481:                                       ; preds = %if.then.475, %cond.end.472
  br label %if.end.482

if.end.482:                                       ; preds = %if.end.481, %lor.lhs.false.448
  br label %if.end.483

if.end.483:                                       ; preds = %if.end.482, %if.end.442
  %339 = load %struct.sv*, %struct.sv** %tmpstr, align 8
  %tobool484 = icmp ne %struct.sv* %339, null
  br i1 %tobool484, label %if.then.485, label %if.end.500

if.then.485:                                      ; preds = %if.end.483
  %340 = load %struct.sv*, %struct.sv** %tmpstr, align 8
  %sv_flags486 = getelementptr inbounds %struct.sv, %struct.sv* %340, i32 0, i32 2
  %341 = load i32, i32* %sv_flags486, align 4
  %and487 = and i32 %341, 262144
  %cmp488 = icmp eq i32 %and487, 262144
  br i1 %cmp488, label %cond.true.490, label %cond.false.495

cond.true.490:                                    ; preds = %if.then.485
  %342 = load %struct.sv*, %struct.sv** %tmpstr, align 8
  %sv_any491 = getelementptr inbounds %struct.sv, %struct.sv* %342, i32 0, i32 0
  %343 = load i8*, i8** %sv_any491, align 8
  %344 = bitcast i8* %343 to %struct.xpv*
  %xpv_cur492 = getelementptr inbounds %struct.xpv, %struct.xpv* %344, i32 0, i32 1
  %345 = load i64, i64* %xpv_cur492, align 8
  store i64 %345, i64* %len, align 8
  %346 = load %struct.sv*, %struct.sv** %tmpstr, align 8
  %sv_any493 = getelementptr inbounds %struct.sv, %struct.sv* %346, i32 0, i32 0
  %347 = load i8*, i8** %sv_any493, align 8
  %348 = bitcast i8* %347 to %struct.xpv*
  %xpv_pv494 = getelementptr inbounds %struct.xpv, %struct.xpv* %348, i32 0, i32 0
  %349 = load i8*, i8** %xpv_pv494, align 8
  br label %cond.end.497

cond.false.495:                                   ; preds = %if.then.485
  %350 = load %struct.sv*, %struct.sv** %tmpstr, align 8
  %call496 = call i8* @Perl_sv_2pv_flags(%struct.sv* %350, i64* %len, i32 2)
  br label %cond.end.497

cond.end.497:                                     ; preds = %cond.false.495, %cond.true.490
  %cond498 = phi i8* [ %349, %cond.true.490 ], [ %call496, %cond.false.495 ]
  store i8* %cond498, i8** %name348, align 8
  %351 = load %struct.sv*, %struct.sv** %tmpstr, align 8
  %call499 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %351)
  br label %if.end.500

if.end.500:                                       ; preds = %cond.end.497, %if.end.483
  br label %if.end.501

if.end.501:                                       ; preds = %if.end.500, %if.then.404
  %352 = load i8*, i8** %name348, align 8
  %tobool502 = icmp ne i8* %352, null
  br i1 %tobool502, label %if.end.504, label %if.then.503

if.then.503:                                      ; preds = %if.end.501
  store i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.106, i32 0, i32 0), i8** %name348, align 8
  store i64 10, i64* %len, align 8
  br label %if.end.504

if.end.504:                                       ; preds = %if.then.503, %if.end.501
  %353 = load %struct.op*, %struct.op** %kid, align 8
  %354 = load i32, i32* %type, align 4
  %call505 = call %struct.op* @Perl_mod(%struct.op* %353, i32 %354)
  br label %if.end.506

if.end.506:                                       ; preds = %if.end.504, %lor.lhs.false.399
  br label %if.end.507

if.end.507:                                       ; preds = %if.end.506, %if.then.389
  br label %if.end.508

if.end.508:                                       ; preds = %if.end.507, %if.end.377
  %355 = load i8*, i8** %name348, align 8
  %tobool509 = icmp ne i8* %355, null
  br i1 %tobool509, label %if.then.510, label %if.end.525

if.then.510:                                      ; preds = %if.end.508
  %call511 = call i64 @Perl_pad_alloc(i32 14, i32 512)
  store i64 %call511, i64* %targ, align 8
  %356 = load i64, i64* %targ, align 8
  %357 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx512 = getelementptr inbounds %struct.sv*, %struct.sv** %357, i64 %356
  %358 = load %struct.sv*, %struct.sv** %arrayidx512, align 8
  store %struct.sv* %358, %struct.sv** %namesv, align 8
  %359 = load %struct.sv*, %struct.sv** %namesv, align 8
  %sv_flags513 = getelementptr inbounds %struct.sv, %struct.sv* %359, i32 0, i32 2
  %360 = load i32, i32* %sv_flags513, align 4
  %and514 = and i32 %360, 255
  %cmp515 = icmp uge i32 %and514, 4
  br i1 %cmp515, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.then.510
  %361 = load %struct.sv*, %struct.sv** %namesv, align 8
  %call517 = call signext i8 @Perl_sv_upgrade(%struct.sv* %361, i32 4)
  %conv518 = sext i8 %call517 to i32
  %tobool519 = icmp ne i32 %conv518, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.then.510
  %362 = phi i1 [ true, %if.then.510 ], [ %tobool519, %lor.rhs ]
  %lor.ext = zext i1 %362 to i32
  %363 = load i8*, i8** %name348, align 8
  %364 = load i8, i8* %363, align 1
  %conv520 = sext i8 %364 to i32
  %cmp521 = icmp ne i32 %conv520, 36
  br i1 %cmp521, label %if.then.523, label %if.end.524

if.then.523:                                      ; preds = %lor.end
  %365 = load %struct.sv*, %struct.sv** %namesv, align 8
  call void @Perl_sv_setpvn(%struct.sv* %365, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.107, i32 0, i32 0), i64 1)
  br label %if.end.524

if.end.524:                                       ; preds = %if.then.523, %lor.end
  %366 = load %struct.sv*, %struct.sv** %namesv, align 8
  %367 = load i8*, i8** %name348, align 8
  %368 = load i64, i64* %len, align 8
  call void @Perl_sv_catpvn_flags(%struct.sv* %366, i8* %367, i64 %368, i32 2)
  br label %if.end.525

if.end.525:                                       ; preds = %if.end.524, %if.end.508
  br label %if.end.526

if.end.526:                                       ; preds = %if.end.525, %if.else.344
  %369 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling527 = getelementptr inbounds %struct.op, %struct.op* %369, i32 0, i32 1
  store %struct.op* null, %struct.op** %op_sibling527, align 8
  %370 = load i32, i32* %flags, align 4
  %371 = load %struct.op*, %struct.op** %kid, align 8
  %call528 = call %struct.op* @Perl_scalar(%struct.op* %371)
  %call529 = call %struct.op* @Perl_newUNOP(i32 14, i32 %370, %struct.op* %call528)
  store %struct.op* %call529, %struct.op** %kid, align 8
  %372 = load i64, i64* %targ, align 8
  %373 = load %struct.op*, %struct.op** %kid, align 8
  %op_targ530 = getelementptr inbounds %struct.op, %struct.op* %373, i32 0, i32 3
  store i64 %372, i64* %op_targ530, align 8
  %374 = load i32, i32* %priv, align 4
  %375 = load %struct.op*, %struct.op** %kid, align 8
  %op_private531 = getelementptr inbounds %struct.op, %struct.op* %375, i32 0, i32 7
  %376 = load i8, i8* %op_private531, align 1
  %conv532 = zext i8 %376 to i32
  %or = or i32 %conv532, %374
  %conv533 = trunc i32 %or to i8
  store i8 %conv533, i8* %op_private531, align 1
  br label %if.end.534

if.end.534:                                       ; preds = %if.end.526, %cond.end.342
  br label %if.end.535

if.end.535:                                       ; preds = %if.end.534, %if.end.325
  %377 = load %struct.op*, %struct.op** %sibl, align 8
  %378 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling536 = getelementptr inbounds %struct.op, %struct.op* %378, i32 0, i32 1
  store %struct.op* %377, %struct.op** %op_sibling536, align 8
  %379 = load %struct.op*, %struct.op** %kid, align 8
  %380 = load %struct.op**, %struct.op*** %tokid, align 8
  store %struct.op* %379, %struct.op** %380, align 8
  br label %if.end.537

if.end.537:                                       ; preds = %if.end.535, %land.lhs.true.283, %sw.bb.278
  %381 = load %struct.op*, %struct.op** %kid, align 8
  %call538 = call %struct.op* @Perl_scalar(%struct.op* %381)
  br label %sw.epilog

sw.bb.539:                                        ; preds = %while.body
  %382 = load %struct.op*, %struct.op** %kid, align 8
  %call540 = call %struct.op* @Perl_scalar(%struct.op* %382)
  %383 = load i32, i32* %type, align 4
  %call541 = call %struct.op* @Perl_mod(%struct.op* %call540, i32 %383)
  br label %sw.epilog

sw.epilog:                                        ; preds = %while.body, %sw.bb.539, %if.end.537, %sw.bb.272, %if.end.270, %if.end.183, %if.end.70, %if.end.62
  %384 = load i32, i32* %oa, align 4
  %shr542 = ashr i32 %384, 4
  store i32 %shr542, i32* %oa, align 4
  %385 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling543 = getelementptr inbounds %struct.op, %struct.op* %385, i32 0, i32 1
  store %struct.op** %op_sibling543, %struct.op*** %tokid, align 8
  %386 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling544 = getelementptr inbounds %struct.op, %struct.op* %386, i32 0, i32 1
  %387 = load %struct.op*, %struct.op** %op_sibling544, align 8
  store %struct.op* %387, %struct.op** %kid, align 8
  br label %while.cond

while.end:                                        ; preds = %land.end
  %388 = load i32, i32* %numargs, align 4
  %389 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private545 = getelementptr inbounds %struct.op, %struct.op* %389, i32 0, i32 7
  %390 = load i8, i8* %op_private545, align 1
  %conv546 = zext i8 %390 to i32
  %or547 = or i32 %conv546, %388
  %conv548 = trunc i32 %or547 to i8
  store i8 %conv548, i8* %op_private545, align 1
  %391 = load %struct.op*, %struct.op** %kid, align 8
  %tobool549 = icmp ne %struct.op* %391, null
  br i1 %tobool549, label %if.then.550, label %if.end.564

if.then.550:                                      ; preds = %while.end
  %392 = load %struct.op*, %struct.op** %o.addr, align 8
  %393 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type551 = getelementptr inbounds %struct.op, %struct.op* %393, i32 0, i32 4
  %394 = load i16, i16* %op_type551, align 2
  %conv552 = zext i16 %394 to i32
  %cmp553 = icmp eq i32 %conv552, 351
  br i1 %cmp553, label %cond.true.555, label %cond.false.557

cond.true.555:                                    ; preds = %if.then.550
  %395 = load %struct.op*, %struct.op** %o.addr, align 8
  %call556 = call i8* @Perl_custom_op_desc(%struct.op* %395)
  br label %cond.end.561

cond.false.557:                                   ; preds = %if.then.550
  %396 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type558 = getelementptr inbounds %struct.op, %struct.op* %396, i32 0, i32 4
  %397 = load i16, i16* %op_type558, align 2
  %idxprom559 = zext i16 %397 to i64
  %arrayidx560 = getelementptr inbounds [0 x i8*], [0 x i8*]* @PL_op_desc, i32 0, i64 %idxprom559
  %398 = load i8*, i8** %arrayidx560, align 8
  br label %cond.end.561

cond.end.561:                                     ; preds = %cond.false.557, %cond.true.555
  %cond562 = phi i8* [ %call556, %cond.true.555 ], [ %398, %cond.false.557 ]
  %call563 = call %struct.op* @S_too_many_arguments(%struct.op* %392, i8* %cond562)
  store %struct.op* %call563, %struct.op** %retval
  br label %return

if.end.564:                                       ; preds = %while.end
  %399 = load %struct.op*, %struct.op** %o.addr, align 8
  %call565 = call %struct.op* @Perl_listkids(%struct.op* %399)
  br label %if.end.575

if.else.566:                                      ; preds = %if.end.12
  %400 = load i32, i32* %type, align 4
  %idxprom567 = sext i32 %400 to i64
  %arrayidx568 = getelementptr inbounds [0 x i32], [0 x i32]* @PL_opargs, i32 0, i64 %idxprom567
  %401 = load i32, i32* %arrayidx568, align 4
  %and569 = and i32 %401, 128
  %tobool570 = icmp ne i32 %and569, 0
  br i1 %tobool570, label %if.then.571, label %if.end.574

if.then.571:                                      ; preds = %if.else.566
  %402 = load %struct.op*, %struct.op** %o.addr, align 8
  call void @Perl_op_free(%struct.op* %402)
  %403 = load i32, i32* %type, align 4
  %call572 = call %struct.op* @S_newDEFSVOP()
  %call573 = call %struct.op* @Perl_newUNOP(i32 %403, i32 0, %struct.op* %call572)
  store %struct.op* %call573, %struct.op** %retval
  br label %return

if.end.574:                                       ; preds = %if.else.566
  br label %if.end.575

if.end.575:                                       ; preds = %if.end.574, %if.end.564
  %404 = load i32, i32* %oa, align 4
  %tobool576 = icmp ne i32 %404, 0
  br i1 %tobool576, label %if.then.577, label %if.end.603

if.then.577:                                      ; preds = %if.end.575
  br label %while.cond.578

while.cond.578:                                   ; preds = %while.body.581, %if.then.577
  %405 = load i32, i32* %oa, align 4
  %and579 = and i32 %405, 8
  %tobool580 = icmp ne i32 %and579, 0
  br i1 %tobool580, label %while.body.581, label %while.end.583

while.body.581:                                   ; preds = %while.cond.578
  %406 = load i32, i32* %oa, align 4
  %shr582 = ashr i32 %406, 4
  store i32 %shr582, i32* %oa, align 4
  br label %while.cond.578

while.end.583:                                    ; preds = %while.cond.578
  %407 = load i32, i32* %oa, align 4
  %tobool584 = icmp ne i32 %407, 0
  br i1 %tobool584, label %land.lhs.true.585, label %if.end.602

land.lhs.true.585:                                ; preds = %while.end.583
  %408 = load i32, i32* %oa, align 4
  %cmp586 = icmp ne i32 %408, 2
  br i1 %cmp586, label %if.then.588, label %if.end.602

if.then.588:                                      ; preds = %land.lhs.true.585
  %409 = load %struct.op*, %struct.op** %o.addr, align 8
  %410 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type589 = getelementptr inbounds %struct.op, %struct.op* %410, i32 0, i32 4
  %411 = load i16, i16* %op_type589, align 2
  %conv590 = zext i16 %411 to i32
  %cmp591 = icmp eq i32 %conv590, 351
  br i1 %cmp591, label %cond.true.593, label %cond.false.595

cond.true.593:                                    ; preds = %if.then.588
  %412 = load %struct.op*, %struct.op** %o.addr, align 8
  %call594 = call i8* @Perl_custom_op_desc(%struct.op* %412)
  br label %cond.end.599

cond.false.595:                                   ; preds = %if.then.588
  %413 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type596 = getelementptr inbounds %struct.op, %struct.op* %413, i32 0, i32 4
  %414 = load i16, i16* %op_type596, align 2
  %idxprom597 = zext i16 %414 to i64
  %arrayidx598 = getelementptr inbounds [0 x i8*], [0 x i8*]* @PL_op_desc, i32 0, i64 %idxprom597
  %415 = load i8*, i8** %arrayidx598, align 8
  br label %cond.end.599

cond.end.599:                                     ; preds = %cond.false.595, %cond.true.593
  %cond600 = phi i8* [ %call594, %cond.true.593 ], [ %415, %cond.false.595 ]
  %call601 = call %struct.op* @S_too_few_arguments(%struct.op* %409, i8* %cond600)
  store %struct.op* %call601, %struct.op** %retval
  br label %return

if.end.602:                                       ; preds = %land.lhs.true.585, %while.end.583
  br label %if.end.603

if.end.603:                                       ; preds = %if.end.602, %if.end.575
  %416 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %416, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.603, %cond.end.599, %if.then.571, %cond.end.561, %if.then.58, %if.else
  %417 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %417
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_delete(%struct.op* %o) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  %kid = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %call = call %struct.op* @Perl_ck_fun(%struct.op* %0)
  store %struct.op* %call, %struct.op** %o.addr, align 8
  %1 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 7
  store i8 0, i8* %op_private, align 1
  %2 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %2, i32 0, i32 6
  %3 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %3 to i32
  %and = and i32 %conv, 4
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load %struct.op*, %struct.op** %o.addr, align 8
  %5 = bitcast %struct.op* %4 to %struct.unop*
  %op_first = getelementptr inbounds %struct.unop, %struct.unop* %5, i32 0, i32 8
  %6 = load %struct.op*, %struct.op** %op_first, align 8
  store %struct.op* %6, %struct.op** %kid, align 8
  %7 = load %struct.op*, %struct.op** %kid, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %7, i32 0, i32 4
  %8 = load i16, i16* %op_type, align 2
  %conv1 = zext i16 %8 to i32
  switch i32 %conv1, label %sw.default [
    i32 128, label %sw.bb
    i32 136, label %sw.bb.5
    i32 127, label %sw.bb.10
    i32 135, label %sw.bb.15
  ]

sw.bb:                                            ; preds = %if.then
  %9 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags2 = getelementptr inbounds %struct.op, %struct.op* %9, i32 0, i32 6
  %10 = load i8, i8* %op_flags2, align 1
  %conv3 = zext i8 %10 to i32
  %or = or i32 %conv3, 128
  %conv4 = trunc i32 %or to i8
  store i8 %conv4, i8* %op_flags2, align 1
  br label %sw.bb.5

sw.bb.5:                                          ; preds = %if.then, %sw.bb
  %11 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private6 = getelementptr inbounds %struct.op, %struct.op* %11, i32 0, i32 7
  %12 = load i8, i8* %op_private6, align 1
  %conv7 = zext i8 %12 to i32
  %or8 = or i32 %conv7, 64
  %conv9 = trunc i32 %or8 to i8
  store i8 %conv9, i8* %op_private6, align 1
  br label %sw.epilog

sw.bb.10:                                         ; preds = %if.then
  %13 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags11 = getelementptr inbounds %struct.op, %struct.op* %13, i32 0, i32 6
  %14 = load i8, i8* %op_flags11, align 1
  %conv12 = zext i8 %14 to i32
  %or13 = or i32 %conv12, 128
  %conv14 = trunc i32 %or13 to i8
  store i8 %conv14, i8* %op_flags11, align 1
  br label %sw.bb.15

sw.bb.15:                                         ; preds = %if.then, %sw.bb.10
  br label %sw.epilog

sw.default:                                       ; preds = %if.then
  %15 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type16 = getelementptr inbounds %struct.op, %struct.op* %15, i32 0, i32 4
  %16 = load i16, i16* %op_type16, align 2
  %conv17 = zext i16 %16 to i32
  %cmp = icmp eq i32 %conv17, 351
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %sw.default
  %17 = load %struct.op*, %struct.op** %o.addr, align 8
  %call19 = call i8* @Perl_custom_op_desc(%struct.op* %17)
  br label %cond.end

cond.false:                                       ; preds = %sw.default
  %18 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type20 = getelementptr inbounds %struct.op, %struct.op* %18, i32 0, i32 4
  %19 = load i16, i16* %op_type20, align 2
  %idxprom = zext i16 %19 to i64
  %arrayidx = getelementptr inbounds [0 x i8*], [0 x i8*]* @PL_op_desc, i32 0, i64 %idxprom
  %20 = load i8*, i8** %arrayidx, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %call19, %cond.true ], [ %20, %cond.false ]
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([52 x i8], [52 x i8]* @.str.88, i32 0, i32 0), i8* %cond)
  br label %sw.epilog

sw.epilog:                                        ; preds = %cond.end, %sw.bb.15, %sw.bb.5
  %21 = load %struct.op*, %struct.op** %kid, align 8
  call void @Perl_op_null(%struct.op* %21)
  br label %if.end

if.end:                                           ; preds = %sw.epilog, %entry
  %22 = load %struct.op*, %struct.op** %o.addr, align 8
  ret %struct.op* %22
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_die(%struct.op* %o) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %call = call %struct.op* @Perl_ck_fun(%struct.op* %0)
  ret %struct.op* %call
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_eof(%struct.op* %o) #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %o.addr = alloca %struct.op*, align 8
  %type = alloca i32, align 4
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %0, i32 0, i32 4
  %1 = load i16, i16* %op_type, align 2
  %conv = zext i16 %1 to i32
  store i32 %conv, i32* %type, align 4
  %2 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %2, i32 0, i32 6
  %3 = load i8, i8* %op_flags, align 1
  %conv1 = zext i8 %3 to i32
  %and = and i32 %conv1, 4
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end.8

if.then:                                          ; preds = %entry
  %4 = load %struct.op*, %struct.op** %o.addr, align 8
  %5 = bitcast %struct.op* %4 to %struct.listop*
  %op_first = getelementptr inbounds %struct.listop, %struct.listop* %5, i32 0, i32 8
  %6 = load %struct.op*, %struct.op** %op_first, align 8
  %op_type2 = getelementptr inbounds %struct.op, %struct.op* %6, i32 0, i32 4
  %7 = load i16, i16* %op_type2, align 2
  %conv3 = zext i16 %7 to i32
  %cmp = icmp eq i32 %conv3, 1
  br i1 %cmp, label %if.then.5, label %if.end

if.then.5:                                        ; preds = %if.then
  %8 = load %struct.op*, %struct.op** %o.addr, align 8
  call void @Perl_op_free(%struct.op* %8)
  %9 = load i32, i32* %type, align 4
  %10 = load %struct.gv*, %struct.gv** @PL_argvgv, align 8
  %call = call %struct.op* @Perl_newGVOP(i32 7, i32 0, %struct.gv* %10)
  %call6 = call %struct.op* @Perl_newUNOP(i32 %9, i32 128, %struct.op* %call)
  store %struct.op* %call6, %struct.op** %o.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then.5, %if.then
  %11 = load %struct.op*, %struct.op** %o.addr, align 8
  %call7 = call %struct.op* @Perl_ck_fun(%struct.op* %11)
  store %struct.op* %call7, %struct.op** %retval
  br label %return

if.end.8:                                         ; preds = %entry
  %12 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %12, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.8, %if.end
  %13 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %13
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_eval(%struct.op* %o) #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %o.addr = alloca %struct.op*, align 8
  %kid = alloca %struct.svop*, align 8
  %enter = alloca %struct.logop*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load i32, i32* @PL_hints, align 4
  %or = or i32 %0, 256
  store i32 %or, i32* @PL_hints, align 4
  %1 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 6
  %2 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 4
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.else.22

if.then:                                          ; preds = %entry
  %3 = load %struct.op*, %struct.op** %o.addr, align 8
  %4 = bitcast %struct.op* %3 to %struct.unop*
  %op_first = getelementptr inbounds %struct.unop, %struct.unop* %4, i32 0, i32 8
  %5 = load %struct.op*, %struct.op** %op_first, align 8
  %6 = bitcast %struct.op* %5 to %struct.svop*
  store %struct.svop* %6, %struct.svop** %kid, align 8
  %7 = load %struct.svop*, %struct.svop** %kid, align 8
  %tobool1 = icmp ne %struct.svop* %7, null
  br i1 %tobool1, label %if.else, label %if.then.2

if.then.2:                                        ; preds = %if.then
  %8 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags3 = getelementptr inbounds %struct.op, %struct.op* %8, i32 0, i32 6
  %9 = load i8, i8* %op_flags3, align 1
  %conv4 = zext i8 %9 to i32
  %and5 = and i32 %conv4, -5
  %conv6 = trunc i32 %and5 to i8
  store i8 %conv6, i8* %op_flags3, align 1
  %10 = load %struct.op*, %struct.op** %o.addr, align 8
  call void @Perl_op_null(%struct.op* %10)
  br label %if.end.21

if.else:                                          ; preds = %if.then
  %11 = load %struct.svop*, %struct.svop** %kid, align 8
  %op_type = getelementptr inbounds %struct.svop, %struct.svop* %11, i32 0, i32 4
  %12 = load i16, i16* %op_type, align 2
  %conv7 = zext i16 %12 to i32
  %cmp = icmp eq i32 %conv7, 173
  br i1 %cmp, label %if.then.13, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else
  %13 = load %struct.svop*, %struct.svop** %kid, align 8
  %op_type9 = getelementptr inbounds %struct.svop, %struct.svop* %13, i32 0, i32 4
  %14 = load i16, i16* %op_type9, align 2
  %conv10 = zext i16 %14 to i32
  %cmp11 = icmp eq i32 %conv10, 1
  br i1 %cmp11, label %if.then.13, label %if.else.19

if.then.13:                                       ; preds = %lor.lhs.false, %if.else
  %15 = load %struct.op*, %struct.op** %o.addr, align 8
  %16 = bitcast %struct.op* %15 to %struct.unop*
  %op_first14 = getelementptr inbounds %struct.unop, %struct.unop* %16, i32 0, i32 8
  store %struct.op* null, %struct.op** %op_first14, align 8
  %17 = load %struct.op*, %struct.op** %o.addr, align 8
  call void @Perl_op_free(%struct.op* %17)
  %call = call i8* @Perl_safesysmalloc(i64 56)
  %18 = bitcast i8* %call to %struct.logop*
  store %struct.logop* %18, %struct.logop** %enter, align 8
  %19 = load %struct.logop*, %struct.logop** %enter, align 8
  %20 = bitcast %struct.logop* %19 to i8*
  call void @llvm.memset.p0i8.i64(i8* %20, i8 0, i64 56, i32 1, i1 false)
  %21 = load %struct.logop*, %struct.logop** %enter, align 8
  %op_type15 = getelementptr inbounds %struct.logop, %struct.logop* %21, i32 0, i32 4
  store i16 313, i16* %op_type15, align 2
  %22 = load %struct.op* ()*, %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 313), align 8
  %23 = load %struct.logop*, %struct.logop** %enter, align 8
  %op_ppaddr = getelementptr inbounds %struct.logop, %struct.logop* %23, i32 0, i32 2
  store %struct.op* ()* %22, %struct.op* ()** %op_ppaddr, align 8
  %24 = load %struct.logop*, %struct.logop** %enter, align 8
  %op_private = getelementptr inbounds %struct.logop, %struct.logop* %24, i32 0, i32 7
  store i8 0, i8* %op_private, align 1
  %25 = load %struct.logop*, %struct.logop** %enter, align 8
  %26 = bitcast %struct.logop* %25 to %struct.op*
  %27 = load %struct.logop*, %struct.logop** %enter, align 8
  %op_next = getelementptr inbounds %struct.logop, %struct.logop* %27, i32 0, i32 0
  store %struct.op* %26, %struct.op** %op_next, align 8
  %28 = load %struct.logop*, %struct.logop** %enter, align 8
  %29 = bitcast %struct.logop* %28 to %struct.op*
  %30 = load %struct.svop*, %struct.svop** %kid, align 8
  %31 = bitcast %struct.svop* %30 to %struct.op*
  %call16 = call %struct.op* @Perl_prepend_elem(i32 173, %struct.op* %29, %struct.op* %31)
  store %struct.op* %call16, %struct.op** %o.addr, align 8
  %32 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type17 = getelementptr inbounds %struct.op, %struct.op* %32, i32 0, i32 4
  store i16 314, i16* %op_type17, align 2
  %33 = load %struct.op* ()*, %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 314), align 8
  %34 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_ppaddr18 = getelementptr inbounds %struct.op, %struct.op* %34, i32 0, i32 2
  store %struct.op* ()* %33, %struct.op* ()** %op_ppaddr18, align 8
  %35 = load %struct.op*, %struct.op** %o.addr, align 8
  %36 = load %struct.logop*, %struct.logop** %enter, align 8
  %op_other = getelementptr inbounds %struct.logop, %struct.logop* %36, i32 0, i32 9
  store %struct.op* %35, %struct.op** %op_other, align 8
  %37 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %37, %struct.op** %retval
  br label %return

if.else.19:                                       ; preds = %lor.lhs.false
  %38 = load %struct.svop*, %struct.svop** %kid, align 8
  %39 = bitcast %struct.svop* %38 to %struct.op*
  %call20 = call %struct.op* @Perl_scalar(%struct.op* %39)
  br label %if.end

if.end:                                           ; preds = %if.else.19
  br label %if.end.21

if.end.21:                                        ; preds = %if.end, %if.then.2
  br label %if.end.25

if.else.22:                                       ; preds = %entry
  %40 = load %struct.op*, %struct.op** %o.addr, align 8
  call void @Perl_op_free(%struct.op* %40)
  %call23 = call %struct.op* @S_newDEFSVOP()
  %call24 = call %struct.op* @Perl_newUNOP(i32 311, i32 0, %struct.op* %call23)
  store %struct.op* %call24, %struct.op** %o.addr, align 8
  br label %if.end.25

if.end.25:                                        ; preds = %if.else.22, %if.end.21
  %41 = load i32, i32* @PL_hints, align 4
  %conv26 = zext i32 %41 to i64
  %42 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %42, i32 0, i32 3
  store i64 %conv26, i64* %op_targ, align 8
  %43 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %43, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.25, %if.then.13
  %44 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %44
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_exit(%struct.op* %o) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %call = call %struct.op* @Perl_ck_fun(%struct.op* %0)
  ret %struct.op* %call
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_exec(%struct.op* %o) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  %kid = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %0, i32 0, i32 6
  %1 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %1 to i32
  %and = and i32 %conv, 64
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load %struct.op*, %struct.op** %o.addr, align 8
  %call = call %struct.op* @Perl_ck_fun(%struct.op* %2)
  store %struct.op* %call, %struct.op** %o.addr, align 8
  %3 = load %struct.op*, %struct.op** %o.addr, align 8
  %4 = bitcast %struct.op* %3 to %struct.unop*
  %op_first = getelementptr inbounds %struct.unop, %struct.unop* %4, i32 0, i32 8
  %5 = load %struct.op*, %struct.op** %op_first, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %5, i32 0, i32 1
  %6 = load %struct.op*, %struct.op** %op_sibling, align 8
  store %struct.op* %6, %struct.op** %kid, align 8
  %7 = load %struct.op*, %struct.op** %kid, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %7, i32 0, i32 4
  %8 = load i16, i16* %op_type, align 2
  %conv1 = zext i16 %8 to i32
  %cmp = icmp eq i32 %conv1, 14
  br i1 %cmp, label %if.then.3, label %if.end

if.then.3:                                        ; preds = %if.then
  %9 = load %struct.op*, %struct.op** %kid, align 8
  call void @Perl_op_null(%struct.op* %9)
  br label %if.end

if.end:                                           ; preds = %if.then.3, %if.then
  br label %if.end.5

if.else:                                          ; preds = %entry
  %10 = load %struct.op*, %struct.op** %o.addr, align 8
  %call4 = call %struct.op* @Perl_listkids(%struct.op* %10)
  store %struct.op* %call4, %struct.op** %o.addr, align 8
  br label %if.end.5

if.end.5:                                         ; preds = %if.else, %if.end
  %11 = load %struct.op*, %struct.op** %o.addr, align 8
  ret %struct.op* %11
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_exists(%struct.op* %o) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  %kid = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %call = call %struct.op* @Perl_ck_fun(%struct.op* %0)
  store %struct.op* %call, %struct.op** %o.addr, align 8
  %1 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 6
  %2 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 4
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end.51

if.then:                                          ; preds = %entry
  %3 = load %struct.op*, %struct.op** %o.addr, align 8
  %4 = bitcast %struct.op* %3 to %struct.unop*
  %op_first = getelementptr inbounds %struct.unop, %struct.unop* %4, i32 0, i32 8
  %5 = load %struct.op*, %struct.op** %op_first, align 8
  store %struct.op* %5, %struct.op** %kid, align 8
  %6 = load %struct.op*, %struct.op** %kid, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %6, i32 0, i32 4
  %7 = load i16, i16* %op_type, align 2
  %conv1 = zext i16 %7 to i32
  %cmp = icmp eq i32 %conv1, 166
  br i1 %cmp, label %if.then.3, label %if.else

if.then.3:                                        ; preds = %if.then
  %8 = load %struct.op*, %struct.op** %kid, align 8
  %9 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type4 = getelementptr inbounds %struct.op, %struct.op* %9, i32 0, i32 4
  %10 = load i16, i16* %op_type4, align 2
  %conv5 = zext i16 %10 to i32
  %call6 = call %struct.op* @Perl_ref(%struct.op* %8, i32 %conv5)
  %11 = load %struct.op*, %struct.op** %kid, align 8
  %op_type7 = getelementptr inbounds %struct.op, %struct.op* %11, i32 0, i32 4
  %12 = load i16, i16* %op_type7, align 2
  %conv8 = zext i16 %12 to i32
  %cmp9 = icmp ne i32 %conv8, 17
  br i1 %cmp9, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then.3
  %13 = load i32, i32* @PL_error_count, align 4
  %tobool11 = icmp ne i32 %13, 0
  br i1 %tobool11, label %if.end, label %if.then.12

if.then.12:                                       ; preds = %land.lhs.true
  %14 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type13 = getelementptr inbounds %struct.op, %struct.op* %14, i32 0, i32 4
  %15 = load i16, i16* %op_type13, align 2
  %conv14 = zext i16 %15 to i32
  %cmp15 = icmp eq i32 %conv14, 351
  br i1 %cmp15, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.12
  %16 = load %struct.op*, %struct.op** %o.addr, align 8
  %call17 = call i8* @Perl_custom_op_desc(%struct.op* %16)
  br label %cond.end

cond.false:                                       ; preds = %if.then.12
  %17 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type18 = getelementptr inbounds %struct.op, %struct.op* %17, i32 0, i32 4
  %18 = load i16, i16* %op_type18, align 2
  %idxprom = zext i16 %18 to i64
  %arrayidx = getelementptr inbounds [0 x i8*], [0 x i8*]* @PL_op_desc, i32 0, i64 %idxprom
  %19 = load i8*, i8** %arrayidx, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %call17, %cond.true ], [ %19, %cond.false ]
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.89, i32 0, i32 0), i8* %cond)
  br label %if.end

if.end:                                           ; preds = %cond.end, %land.lhs.true, %if.then.3
  %20 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %20, i32 0, i32 7
  %21 = load i8, i8* %op_private, align 1
  %conv19 = zext i8 %21 to i32
  %or = or i32 %conv19, 64
  %conv20 = trunc i32 %or to i8
  store i8 %conv20, i8* %op_private, align 1
  br label %if.end.50

if.else:                                          ; preds = %if.then
  %22 = load %struct.op*, %struct.op** %kid, align 8
  %op_type21 = getelementptr inbounds %struct.op, %struct.op* %22, i32 0, i32 4
  %23 = load i16, i16* %op_type21, align 2
  %conv22 = zext i16 %23 to i32
  %cmp23 = icmp eq i32 %conv22, 127
  br i1 %cmp23, label %if.then.25, label %if.else.30

if.then.25:                                       ; preds = %if.else
  %24 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags26 = getelementptr inbounds %struct.op, %struct.op* %24, i32 0, i32 6
  %25 = load i8, i8* %op_flags26, align 1
  %conv27 = zext i8 %25 to i32
  %or28 = or i32 %conv27, 128
  %conv29 = trunc i32 %or28 to i8
  store i8 %conv29, i8* %op_flags26, align 1
  br label %if.end.49

if.else.30:                                       ; preds = %if.else
  %26 = load %struct.op*, %struct.op** %kid, align 8
  %op_type31 = getelementptr inbounds %struct.op, %struct.op* %26, i32 0, i32 4
  %27 = load i16, i16* %op_type31, align 2
  %conv32 = zext i16 %27 to i32
  %cmp33 = icmp ne i32 %conv32, 135
  br i1 %cmp33, label %if.then.35, label %if.end.48

if.then.35:                                       ; preds = %if.else.30
  %28 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type36 = getelementptr inbounds %struct.op, %struct.op* %28, i32 0, i32 4
  %29 = load i16, i16* %op_type36, align 2
  %conv37 = zext i16 %29 to i32
  %cmp38 = icmp eq i32 %conv37, 351
  br i1 %cmp38, label %cond.true.40, label %cond.false.42

cond.true.40:                                     ; preds = %if.then.35
  %30 = load %struct.op*, %struct.op** %o.addr, align 8
  %call41 = call i8* @Perl_custom_op_desc(%struct.op* %30)
  br label %cond.end.46

cond.false.42:                                    ; preds = %if.then.35
  %31 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type43 = getelementptr inbounds %struct.op, %struct.op* %31, i32 0, i32 4
  %32 = load i16, i16* %op_type43, align 2
  %idxprom44 = zext i16 %32 to i64
  %arrayidx45 = getelementptr inbounds [0 x i8*], [0 x i8*]* @PL_op_desc, i32 0, i64 %idxprom44
  %33 = load i8*, i8** %arrayidx45, align 8
  br label %cond.end.46

cond.end.46:                                      ; preds = %cond.false.42, %cond.true.40
  %cond47 = phi i8* [ %call41, %cond.true.40 ], [ %33, %cond.false.42 ]
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.90, i32 0, i32 0), i8* %cond47)
  br label %if.end.48

if.end.48:                                        ; preds = %cond.end.46, %if.else.30
  br label %if.end.49

if.end.49:                                        ; preds = %if.end.48, %if.then.25
  br label %if.end.50

if.end.50:                                        ; preds = %if.end.49, %if.end
  %34 = load %struct.op*, %struct.op** %kid, align 8
  call void @Perl_op_null(%struct.op* %34)
  br label %if.end.51

if.end.51:                                        ; preds = %if.end.50, %entry
  %35 = load %struct.op*, %struct.op** %o.addr, align 8
  ret %struct.op* %35
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_rvconst(%struct.op* %o) #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %o.addr = alloca %struct.op*, align 8
  %kid = alloca %struct.svop*, align 8
  %name = alloca i8*, align 8
  %iscv = alloca i32, align 4
  %gv = alloca %struct.gv*, align 8
  %kidsv = alloca %struct.sv*, align 8
  %n_a = alloca i64, align 8
  %rsv = alloca %struct.sv*, align 8
  %svtype = alloca i32, align 4
  %badtype = alloca i8*, align 8
  %ksv = alloca %struct.sv**, align 8
  %badthing = alloca i8*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %1 = bitcast %struct.op* %0 to %struct.unop*
  %op_first = getelementptr inbounds %struct.unop, %struct.unop* %1, i32 0, i32 8
  %2 = load %struct.op*, %struct.op** %op_first, align 8
  %3 = bitcast %struct.op* %2 to %struct.svop*
  store %struct.svop* %3, %struct.svop** %kid, align 8
  %4 = load i32, i32* @PL_hints, align 4
  %and = and i32 %4, 2
  %5 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %5, i32 0, i32 7
  %6 = load i8, i8* %op_private, align 1
  %conv = zext i8 %6 to i32
  %or = or i32 %conv, %and
  %conv1 = trunc i32 %or to i8
  store i8 %conv1, i8* %op_private, align 1
  %7 = load %struct.svop*, %struct.svop** %kid, align 8
  %op_type = getelementptr inbounds %struct.svop, %struct.svop* %7, i32 0, i32 4
  %8 = load i16, i16* %op_type, align 2
  %conv2 = zext i16 %8 to i32
  %cmp = icmp eq i32 %conv2, 5
  br i1 %cmp, label %if.then, label %if.end.135

if.then:                                          ; preds = %entry
  %9 = load %struct.svop*, %struct.svop** %kid, align 8
  %op_sv = getelementptr inbounds %struct.svop, %struct.svop* %9, i32 0, i32 8
  %10 = load %struct.sv*, %struct.sv** %op_sv, align 8
  store %struct.sv* %10, %struct.sv** %kidsv, align 8
  %11 = load %struct.sv*, %struct.sv** %kidsv, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %11, i32 0, i32 2
  %12 = load i32, i32* %sv_flags, align 4
  %and4 = and i32 %12, 524288
  %tobool = icmp ne i32 %and4, 0
  br i1 %tobool, label %land.lhs.true, label %if.end.52

land.lhs.true:                                    ; preds = %if.then
  %13 = load %struct.sv*, %struct.sv** %kidsv, align 8
  %sv_flags5 = getelementptr inbounds %struct.sv, %struct.sv* %13, i32 0, i32 2
  %14 = load i32, i32* %sv_flags5, align 4
  %and6 = and i32 %14, 8388608
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %if.then.8, label %if.end.52

if.then.8:                                        ; preds = %land.lhs.true
  %15 = load %struct.sv*, %struct.sv** %kidsv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %15, i32 0, i32 0
  %16 = load i8*, i8** %sv_any, align 8
  %17 = bitcast i8* %16 to %struct.xrv*
  %xrv_rv = getelementptr inbounds %struct.xrv, %struct.xrv* %17, i32 0, i32 0
  %18 = load %struct.sv*, %struct.sv** %xrv_rv, align 8
  store %struct.sv* %18, %struct.sv** %rsv, align 8
  %19 = load %struct.sv*, %struct.sv** %rsv, align 8
  %sv_flags9 = getelementptr inbounds %struct.sv, %struct.sv* %19, i32 0, i32 2
  %20 = load i32, i32* %sv_flags9, align 4
  %and10 = and i32 %20, 255
  store i32 %and10, i32* %svtype, align 4
  store i8* null, i8** %badtype, align 8
  %21 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type11 = getelementptr inbounds %struct.op, %struct.op* %21, i32 0, i32 4
  %22 = load i16, i16* %op_type11, align 2
  %conv12 = zext i16 %22 to i32
  switch i32 %conv12, label %sw.epilog [
    i32 15, label %sw.bb
    i32 125, label %sw.bb.16
    i32 134, label %sw.bb.21
    i32 17, label %sw.bb.44
  ]

sw.bb:                                            ; preds = %if.then.8
  %23 = load i32, i32* %svtype, align 4
  %cmp13 = icmp sgt i32 %23, 7
  br i1 %cmp13, label %if.then.15, label %if.end

if.then.15:                                       ; preds = %sw.bb
  store i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.91, i32 0, i32 0), i8** %badtype, align 8
  br label %if.end

if.end:                                           ; preds = %if.then.15, %sw.bb
  br label %sw.epilog

sw.bb.16:                                         ; preds = %if.then.8
  %24 = load i32, i32* %svtype, align 4
  %cmp17 = icmp ne i32 %24, 10
  br i1 %cmp17, label %if.then.19, label %if.end.20

if.then.19:                                       ; preds = %sw.bb.16
  store i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.92, i32 0, i32 0), i8** %badtype, align 8
  br label %if.end.20

if.end.20:                                        ; preds = %if.then.19, %sw.bb.16
  br label %sw.epilog

sw.bb.21:                                         ; preds = %if.then.8
  %25 = load i32, i32* %svtype, align 4
  %cmp22 = icmp ne i32 %25, 11
  br i1 %cmp22, label %if.then.24, label %if.end.43

if.then.24:                                       ; preds = %sw.bb.21
  %26 = load i32, i32* %svtype, align 4
  %cmp25 = icmp eq i32 %26, 10
  br i1 %cmp25, label %if.then.27, label %if.end.42

if.then.27:                                       ; preds = %if.then.24
  %27 = load %struct.sv*, %struct.sv** %rsv, align 8
  %28 = bitcast %struct.sv* %27 to %struct.av*
  %call = call %struct.sv** @Perl_av_fetch(%struct.av* %28, i32 0, i32 0)
  store %struct.sv** %call, %struct.sv*** %ksv, align 8
  %29 = load %struct.sv**, %struct.sv*** %ksv, align 8
  %tobool28 = icmp ne %struct.sv** %29, null
  br i1 %tobool28, label %land.lhs.true.29, label %if.end.41

land.lhs.true.29:                                 ; preds = %if.then.27
  %30 = load %struct.sv**, %struct.sv*** %ksv, align 8
  %31 = load %struct.sv*, %struct.sv** %30, align 8
  %sv_flags30 = getelementptr inbounds %struct.sv, %struct.sv* %31, i32 0, i32 2
  %32 = load i32, i32* %sv_flags30, align 4
  %and31 = and i32 %32, 524288
  %tobool32 = icmp ne i32 %and31, 0
  br i1 %tobool32, label %land.lhs.true.33, label %if.end.41

land.lhs.true.33:                                 ; preds = %land.lhs.true.29
  %33 = load %struct.sv**, %struct.sv*** %ksv, align 8
  %34 = load %struct.sv*, %struct.sv** %33, align 8
  %sv_any34 = getelementptr inbounds %struct.sv, %struct.sv* %34, i32 0, i32 0
  %35 = load i8*, i8** %sv_any34, align 8
  %36 = bitcast i8* %35 to %struct.xrv*
  %xrv_rv35 = getelementptr inbounds %struct.xrv, %struct.xrv* %36, i32 0, i32 0
  %37 = load %struct.sv*, %struct.sv** %xrv_rv35, align 8
  %sv_flags36 = getelementptr inbounds %struct.sv, %struct.sv* %37, i32 0, i32 2
  %38 = load i32, i32* %sv_flags36, align 4
  %and37 = and i32 %38, 255
  %cmp38 = icmp eq i32 %and37, 11
  br i1 %cmp38, label %if.then.40, label %if.end.41

if.then.40:                                       ; preds = %land.lhs.true.33
  br label %sw.epilog

if.end.41:                                        ; preds = %land.lhs.true.33, %land.lhs.true.29, %if.then.27
  br label %if.end.42

if.end.42:                                        ; preds = %if.end.41, %if.then.24
  store i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.93, i32 0, i32 0), i8** %badtype, align 8
  br label %if.end.43

if.end.43:                                        ; preds = %if.end.42, %sw.bb.21
  br label %sw.epilog

sw.bb.44:                                         ; preds = %if.then.8
  %39 = load i32, i32* %svtype, align 4
  %cmp45 = icmp ne i32 %39, 12
  br i1 %cmp45, label %if.then.47, label %if.end.48

if.then.47:                                       ; preds = %sw.bb.44
  store i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.94, i32 0, i32 0), i8** %badtype, align 8
  br label %if.end.48

if.end.48:                                        ; preds = %if.then.47, %sw.bb.44
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.then.8, %if.end.48, %if.end.43, %if.then.40, %if.end.20, %if.end
  %40 = load i8*, i8** %badtype, align 8
  %tobool49 = icmp ne i8* %40, null
  br i1 %tobool49, label %if.then.50, label %if.end.51

if.then.50:                                       ; preds = %sw.epilog
  %41 = load i8*, i8** %badtype, align 8
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.95, i32 0, i32 0), i8* %41)
  br label %if.end.51

if.end.51:                                        ; preds = %if.then.50, %sw.epilog
  %42 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %42, %struct.op** %retval
  br label %return

if.end.52:                                        ; preds = %land.lhs.true, %if.then
  %43 = load %struct.sv*, %struct.sv** %kidsv, align 8
  %sv_flags53 = getelementptr inbounds %struct.sv, %struct.sv* %43, i32 0, i32 2
  %44 = load i32, i32* %sv_flags53, align 4
  %and54 = and i32 %44, 262144
  %cmp55 = icmp eq i32 %and54, 262144
  br i1 %cmp55, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.52
  %45 = load %struct.sv*, %struct.sv** %kidsv, align 8
  %sv_any57 = getelementptr inbounds %struct.sv, %struct.sv* %45, i32 0, i32 0
  %46 = load i8*, i8** %sv_any57, align 8
  %47 = bitcast i8* %46 to %struct.xpv*
  %xpv_cur = getelementptr inbounds %struct.xpv, %struct.xpv* %47, i32 0, i32 1
  %48 = load i64, i64* %xpv_cur, align 8
  store i64 %48, i64* %n_a, align 8
  %49 = load %struct.sv*, %struct.sv** %kidsv, align 8
  %sv_any58 = getelementptr inbounds %struct.sv, %struct.sv* %49, i32 0, i32 0
  %50 = load i8*, i8** %sv_any58, align 8
  %51 = bitcast i8* %50 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %51, i32 0, i32 0
  %52 = load i8*, i8** %xpv_pv, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end.52
  %53 = load %struct.sv*, %struct.sv** %kidsv, align 8
  %call59 = call i8* @Perl_sv_2pv_flags(%struct.sv* %53, i64* %n_a, i32 2)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %52, %cond.true ], [ %call59, %cond.false ]
  store i8* %cond, i8** %name, align 8
  %54 = load i32, i32* @PL_hints, align 4
  %and60 = and i32 %54, 2
  %tobool61 = icmp ne i32 %and60, 0
  br i1 %tobool61, label %land.lhs.true.62, label %if.end.77

land.lhs.true.62:                                 ; preds = %cond.end
  %55 = load %struct.svop*, %struct.svop** %kid, align 8
  %op_private63 = getelementptr inbounds %struct.svop, %struct.svop* %55, i32 0, i32 7
  %56 = load i8, i8* %op_private63, align 1
  %conv64 = zext i8 %56 to i32
  %and65 = and i32 %conv64, 64
  %tobool66 = icmp ne i32 %and65, 0
  br i1 %tobool66, label %if.then.67, label %if.end.77

if.then.67:                                       ; preds = %land.lhs.true.62
  store i8* null, i8** %badthing, align 8
  %57 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type68 = getelementptr inbounds %struct.op, %struct.op* %57, i32 0, i32 4
  %58 = load i16, i16* %op_type68, align 2
  %conv69 = zext i16 %58 to i32
  switch i32 %conv69, label %sw.epilog.73 [
    i32 15, label %sw.bb.70
    i32 125, label %sw.bb.71
    i32 134, label %sw.bb.72
  ]

sw.bb.70:                                         ; preds = %if.then.67
  store i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.91, i32 0, i32 0), i8** %badthing, align 8
  br label %sw.epilog.73

sw.bb.71:                                         ; preds = %if.then.67
  store i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.92, i32 0, i32 0), i8** %badthing, align 8
  br label %sw.epilog.73

sw.bb.72:                                         ; preds = %if.then.67
  store i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.93, i32 0, i32 0), i8** %badthing, align 8
  br label %sw.epilog.73

sw.epilog.73:                                     ; preds = %if.then.67, %sw.bb.72, %sw.bb.71, %sw.bb.70
  %59 = load i8*, i8** %badthing, align 8
  %tobool74 = icmp ne i8* %59, null
  br i1 %tobool74, label %if.then.75, label %if.end.76

if.then.75:                                       ; preds = %sw.epilog.73
  %60 = load i8*, i8** %name, align 8
  %61 = load i8*, i8** %badthing, align 8
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([63 x i8], [63 x i8]* @.str.96, i32 0, i32 0), i8* %60, i8* %61)
  br label %if.end.76

if.end.76:                                        ; preds = %if.then.75, %sw.epilog.73
  br label %if.end.77

if.end.77:                                        ; preds = %if.end.76, %land.lhs.true.62, %cond.end
  %62 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type78 = getelementptr inbounds %struct.op, %struct.op* %62, i32 0, i32 4
  %63 = load i16, i16* %op_type78, align 2
  %conv79 = zext i16 %63 to i32
  %cmp80 = icmp eq i32 %conv79, 17
  %conv81 = zext i1 %cmp80 to i32
  %mul = mul nsw i32 %conv81, 2
  store i32 %mul, i32* %iscv, align 4
  br label %do.body

do.body:                                          ; preds = %land.end, %if.end.77
  %64 = load i8*, i8** %name, align 8
  %65 = load i32, i32* %iscv, align 4
  %66 = load %struct.svop*, %struct.svop** %kid, align 8
  %op_private82 = getelementptr inbounds %struct.svop, %struct.svop* %66, i32 0, i32 7
  %67 = load i8, i8* %op_private82, align 1
  %conv83 = zext i8 %67 to i32
  %and84 = and i32 %conv83, 16
  %tobool85 = icmp ne i32 %and84, 0
  %lnot = xor i1 %tobool85, true
  %lnot.ext = zext i1 %lnot to i32
  %or86 = or i32 %65, %lnot.ext
  %68 = load i32, i32* %iscv, align 4
  %tobool87 = icmp ne i32 %68, 0
  br i1 %tobool87, label %cond.true.88, label %cond.false.89

cond.true.88:                                     ; preds = %do.body
  br label %cond.end.111

cond.false.89:                                    ; preds = %do.body
  %69 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type90 = getelementptr inbounds %struct.op, %struct.op* %69, i32 0, i32 4
  %70 = load i16, i16* %op_type90, align 2
  %conv91 = zext i16 %70 to i32
  %cmp92 = icmp eq i32 %conv91, 15
  br i1 %cmp92, label %cond.true.94, label %cond.false.95

cond.true.94:                                     ; preds = %cond.false.89
  br label %cond.end.109

cond.false.95:                                    ; preds = %cond.false.89
  %71 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type96 = getelementptr inbounds %struct.op, %struct.op* %71, i32 0, i32 4
  %72 = load i16, i16* %op_type96, align 2
  %conv97 = zext i16 %72 to i32
  %cmp98 = icmp eq i32 %conv97, 125
  br i1 %cmp98, label %cond.true.100, label %cond.false.101

cond.true.100:                                    ; preds = %cond.false.95
  br label %cond.end.107

cond.false.101:                                   ; preds = %cond.false.95
  %73 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type102 = getelementptr inbounds %struct.op, %struct.op* %73, i32 0, i32 4
  %74 = load i16, i16* %op_type102, align 2
  %conv103 = zext i16 %74 to i32
  %cmp104 = icmp eq i32 %conv103, 134
  %cond106 = select i1 %cmp104, i32 11, i32 13
  br label %cond.end.107

cond.end.107:                                     ; preds = %cond.false.101, %cond.true.100
  %cond108 = phi i32 [ 10, %cond.true.100 ], [ %cond106, %cond.false.101 ]
  br label %cond.end.109

cond.end.109:                                     ; preds = %cond.end.107, %cond.true.94
  %cond110 = phi i32 [ 4, %cond.true.94 ], [ %cond108, %cond.end.107 ]
  br label %cond.end.111

cond.end.111:                                     ; preds = %cond.end.109, %cond.true.88
  %cond112 = phi i32 [ 12, %cond.true.88 ], [ %cond110, %cond.end.109 ]
  %call113 = call %struct.gv* @Perl_gv_fetchpv(i8* %64, i32 %or86, i32 %cond112)
  store %struct.gv* %call113, %struct.gv** %gv, align 8
  br label %do.cond

do.cond:                                          ; preds = %cond.end.111
  %75 = load %struct.gv*, %struct.gv** %gv, align 8
  %tobool114 = icmp ne %struct.gv* %75, null
  br i1 %tobool114, label %land.end, label %land.lhs.true.115

land.lhs.true.115:                                ; preds = %do.cond
  %76 = load %struct.svop*, %struct.svop** %kid, align 8
  %op_private116 = getelementptr inbounds %struct.svop, %struct.svop* %76, i32 0, i32 7
  %77 = load i8, i8* %op_private116, align 1
  %conv117 = zext i8 %77 to i32
  %and118 = and i32 %conv117, 16
  %tobool119 = icmp ne i32 %and118, 0
  br i1 %tobool119, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %land.lhs.true.115
  %78 = load i32, i32* %iscv, align 4
  %inc = add nsw i32 %78, 1
  store i32 %inc, i32* %iscv, align 4
  %tobool120 = icmp ne i32 %78, 0
  %lnot121 = xor i1 %tobool120, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true.115, %do.cond
  %79 = phi i1 [ false, %land.lhs.true.115 ], [ false, %do.cond ], [ %lnot121, %land.rhs ]
  br i1 %79, label %do.body, label %do.end

do.end:                                           ; preds = %land.end
  %80 = load %struct.gv*, %struct.gv** %gv, align 8
  %tobool123 = icmp ne %struct.gv* %80, null
  br i1 %tobool123, label %if.then.124, label %if.end.134

if.then.124:                                      ; preds = %do.end
  %81 = load %struct.svop*, %struct.svop** %kid, align 8
  %op_type125 = getelementptr inbounds %struct.svop, %struct.svop* %81, i32 0, i32 4
  store i16 7, i16* %op_type125, align 2
  %82 = load %struct.svop*, %struct.svop** %kid, align 8
  %op_sv126 = getelementptr inbounds %struct.svop, %struct.svop* %82, i32 0, i32 8
  %83 = load %struct.sv*, %struct.sv** %op_sv126, align 8
  call void @Perl_sv_free(%struct.sv* %83)
  %84 = load %struct.gv*, %struct.gv** %gv, align 8
  %85 = bitcast %struct.gv* %84 to %struct.sv*
  store %struct.sv* %85, %struct.sv** @PL_Sv, align 8
  %86 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %tobool127 = icmp ne %struct.sv* %86, null
  br i1 %tobool127, label %land.rhs.128, label %land.end.131

land.rhs.128:                                     ; preds = %if.then.124
  %87 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_refcnt = getelementptr inbounds %struct.sv, %struct.sv* %87, i32 0, i32 1
  %88 = load i32, i32* %sv_refcnt, align 4
  %inc129 = add i32 %88, 1
  store i32 %inc129, i32* %sv_refcnt, align 4
  %tobool130 = icmp ne i32 %inc129, 0
  br label %land.end.131

land.end.131:                                     ; preds = %land.rhs.128, %if.then.124
  %89 = phi i1 [ false, %if.then.124 ], [ %tobool130, %land.rhs.128 ]
  %land.ext = zext i1 %89 to i32
  %90 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %91 = load %struct.svop*, %struct.svop** %kid, align 8
  %op_sv132 = getelementptr inbounds %struct.svop, %struct.svop* %91, i32 0, i32 8
  store %struct.sv* %90, %struct.sv** %op_sv132, align 8
  %92 = load %struct.svop*, %struct.svop** %kid, align 8
  %op_private133 = getelementptr inbounds %struct.svop, %struct.svop* %92, i32 0, i32 7
  store i8 0, i8* %op_private133, align 1
  %93 = load %struct.op* ()*, %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 7), align 8
  %94 = load %struct.svop*, %struct.svop** %kid, align 8
  %op_ppaddr = getelementptr inbounds %struct.svop, %struct.svop* %94, i32 0, i32 2
  store %struct.op* ()* %93, %struct.op* ()** %op_ppaddr, align 8
  br label %if.end.134

if.end.134:                                       ; preds = %land.end.131, %do.end
  br label %if.end.135

if.end.135:                                       ; preds = %if.end.134, %entry
  %95 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %95, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.135, %if.end.51
  %96 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %96
}

; Function Attrs: nounwind uwtable
define internal %struct.op* @S_no_fh_allowed(%struct.op* %o) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %0, i32 0, i32 4
  %1 = load i16, i16* %op_type, align 2
  %conv = zext i16 %1 to i32
  %cmp = icmp eq i32 %conv, 351
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load %struct.op*, %struct.op** %o.addr, align 8
  %call = call i8* @Perl_custom_op_desc(%struct.op* %2)
  br label %cond.end

cond.false:                                       ; preds = %entry
  %3 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type2 = getelementptr inbounds %struct.op, %struct.op* %3, i32 0, i32 4
  %4 = load i16, i16* %op_type2, align 2
  %idxprom = zext i16 %4 to i64
  %arrayidx = getelementptr inbounds [0 x i8*], [0 x i8*]* @PL_op_desc, i32 0, i64 %idxprom
  %5 = load i8*, i8** %arrayidx, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %call, %cond.true ], [ %5, %cond.false ]
  %call3 = call i8* (i8*, ...) @Perl_form(i8* getelementptr inbounds ([50 x i8], [50 x i8]* @.str.150, i32 0, i32 0), i8* %cond)
  %call4 = call i32 @Perl_yyerror(i8* %call3)
  %6 = load %struct.op*, %struct.op** %o.addr, align 8
  ret %struct.op* %6
}

; Function Attrs: nounwind uwtable
define internal %struct.op* @S_too_many_arguments(%struct.op* %o, i8* %name) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  %name.addr = alloca i8*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  store i8* %name, i8** %name.addr, align 8
  %0 = load i8*, i8** %name.addr, align 8
  %call = call i8* (i8*, ...) @Perl_form(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.151, i32 0, i32 0), i8* %0)
  %call1 = call i32 @Perl_yyerror(i8* %call)
  %1 = load %struct.op*, %struct.op** %o.addr, align 8
  ret %struct.op* %1
}

; Function Attrs: nounwind uwtable
define internal void @S_bad_type(i32 %n, i8* %t, i8* %name, %struct.op* %kid) #0 {
entry:
  %n.addr = alloca i32, align 4
  %t.addr = alloca i8*, align 8
  %name.addr = alloca i8*, align 8
  %kid.addr = alloca %struct.op*, align 8
  store i32 %n, i32* %n.addr, align 4
  store i8* %t, i8** %t.addr, align 8
  store i8* %name, i8** %name.addr, align 8
  store %struct.op* %kid, %struct.op** %kid.addr, align 8
  %0 = load i32, i32* %n.addr, align 4
  %1 = load i8*, i8** %name.addr, align 8
  %2 = load i8*, i8** %t.addr, align 8
  %3 = load %struct.op*, %struct.op** %kid.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %3, i32 0, i32 4
  %4 = load i16, i16* %op_type, align 2
  %conv = zext i16 %4 to i32
  %cmp = icmp eq i32 %conv, 351
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %5 = load %struct.op*, %struct.op** %kid.addr, align 8
  %call = call i8* @Perl_custom_op_desc(%struct.op* %5)
  br label %cond.end

cond.false:                                       ; preds = %entry
  %6 = load %struct.op*, %struct.op** %kid.addr, align 8
  %op_type2 = getelementptr inbounds %struct.op, %struct.op* %6, i32 0, i32 4
  %7 = load i16, i16* %op_type2, align 2
  %idxprom = zext i16 %7 to i64
  %arrayidx = getelementptr inbounds [0 x i8*], [0 x i8*]* @PL_op_desc, i32 0, i64 %idxprom
  %8 = load i8*, i8** %arrayidx, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %call, %cond.true ], [ %8, %cond.false ]
  %call3 = call i8* (i8*, ...) @Perl_form(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.152, i32 0, i32 0), i32 %0, i8* %1, i8* %2, i8* %cond)
  %call4 = call i32 @Perl_yyerror(i8* %call3)
  ret void
}

; Function Attrs: nounwind uwtable
define internal signext i8 @S_is_handle_constructor(%struct.op* %o, i32 %argnum) #0 {
entry:
  %retval = alloca i8, align 1
  %o.addr = alloca %struct.op*, align 8
  %argnum.addr = alloca i32, align 4
  store %struct.op* %o, %struct.op** %o.addr, align 8
  store i32 %argnum, i32* %argnum.addr, align 4
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %0, i32 0, i32 4
  %1 = load i16, i16* %op_type, align 2
  %conv = zext i16 %1 to i32
  switch i32 %conv, label %sw.default [
    i32 193, label %sw.bb
    i32 224, label %sw.bb
    i32 210, label %sw.bb.2
    i32 191, label %sw.bb.2
    i32 203, label %sw.bb.2
    i32 223, label %sw.bb.2
    i32 275, label %sw.bb.2
    i32 228, label %sw.bb.2
  ]

sw.bb:                                            ; preds = %entry, %entry
  %2 = load i32, i32* %argnum.addr, align 4
  %cmp = icmp eq i32 %2, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb
  store i8 1, i8* %retval
  br label %return

if.end:                                           ; preds = %sw.bb
  br label %sw.bb.2

sw.bb.2:                                          ; preds = %entry, %entry, %entry, %entry, %entry, %entry, %if.end
  %3 = load i32, i32* %argnum.addr, align 4
  %cmp3 = icmp eq i32 %3, 1
  br i1 %cmp3, label %if.then.5, label %if.end.6

if.then.5:                                        ; preds = %sw.bb.2
  store i8 1, i8* %retval
  br label %return

if.end.6:                                         ; preds = %sw.bb.2
  br label %sw.default

sw.default:                                       ; preds = %entry, %if.end.6
  store i8 0, i8* %retval
  br label %return

return:                                           ; preds = %sw.default, %if.then.5, %if.then
  %4 = load i8, i8* %retval
  ret i8 %4
}

declare %struct.sv* @Perl_newSVpvf(i8*, ...) #1

declare %struct.sv* @Perl_sv_2mortal(%struct.sv*) #1

; Function Attrs: nounwind uwtable
define internal %struct.op* @S_too_few_arguments(%struct.op* %o, i8* %name) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  %name.addr = alloca i8*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  store i8* %name, i8** %name.addr, align 8
  %0 = load i8*, i8** %name.addr, align 8
  %call = call i8* (i8*, ...) @Perl_form(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.153, i32 0, i32 0), i8* %0)
  %call1 = call i32 @Perl_yyerror(i8* %call)
  %1 = load %struct.op*, %struct.op** %o.addr, align 8
  ret %struct.op* %1
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_glob(%struct.op* %o) #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %o.addr = alloca %struct.op*, align 8
  %gv = alloca %struct.gv*, align 8
  %glob_gv = alloca %struct.gv*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %call = call %struct.op* @Perl_ck_fun(%struct.op* %0)
  store %struct.op* %call, %struct.op** %o.addr, align 8
  %1 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 6
  %2 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 4
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %3 = load %struct.op*, %struct.op** %o.addr, align 8
  %4 = bitcast %struct.op* %3 to %struct.listop*
  %op_first = getelementptr inbounds %struct.listop, %struct.listop* %4, i32 0, i32 8
  %5 = load %struct.op*, %struct.op** %op_first, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %5, i32 0, i32 1
  %6 = load %struct.op*, %struct.op** %op_sibling, align 8
  %tobool1 = icmp ne %struct.op* %6, null
  br i1 %tobool1, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %7 = load %struct.op*, %struct.op** %o.addr, align 8
  %call2 = call %struct.op* @S_newDEFSVOP()
  %call3 = call %struct.op* @Perl_append_elem(i32 25, %struct.op* %7, %struct.op* %call2)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %call4 = call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.108, i32 0, i32 0), i32 0, i32 12)
  store %struct.gv* %call4, %struct.gv** %gv, align 8
  %tobool5 = icmp ne %struct.gv* %call4, null
  br i1 %tobool5, label %land.lhs.true.6, label %if.then.16

land.lhs.true.6:                                  ; preds = %if.end
  %8 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any = getelementptr inbounds %struct.gv, %struct.gv* %8, i32 0, i32 0
  %9 = load %struct.xpvgv*, %struct.xpvgv** %sv_any, align 8
  %xgv_gp = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %9, i32 0, i32 7
  %10 = load %struct.gp*, %struct.gp** %xgv_gp, align 8
  %gp_cvgen = getelementptr inbounds %struct.gp, %struct.gp* %10, i32 0, i32 8
  %11 = load i32, i32* %gp_cvgen, align 4
  %tobool7 = icmp ne i32 %11, 0
  br i1 %tobool7, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true.6
  br i1 false, label %land.lhs.true.11, label %if.then.16

cond.false:                                       ; preds = %land.lhs.true.6
  %12 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any8 = getelementptr inbounds %struct.gv, %struct.gv* %12, i32 0, i32 0
  %13 = load %struct.xpvgv*, %struct.xpvgv** %sv_any8, align 8
  %xgv_gp9 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %13, i32 0, i32 7
  %14 = load %struct.gp*, %struct.gp** %xgv_gp9, align 8
  %gp_cv = getelementptr inbounds %struct.gp, %struct.gp* %14, i32 0, i32 7
  %15 = load %struct.cv*, %struct.cv** %gp_cv, align 8
  %tobool10 = icmp ne %struct.cv* %15, null
  br i1 %tobool10, label %land.lhs.true.11, label %if.then.16

land.lhs.true.11:                                 ; preds = %cond.false, %cond.true
  %16 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any12 = getelementptr inbounds %struct.gv, %struct.gv* %16, i32 0, i32 0
  %17 = load %struct.xpvgv*, %struct.xpvgv** %sv_any12, align 8
  %xgv_flags = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %17, i32 0, i32 11
  %18 = load i8, i8* %xgv_flags, align 1
  %conv13 = zext i8 %18 to i32
  %and14 = and i32 %conv13, 128
  %tobool15 = icmp ne i32 %and14, 0
  br i1 %tobool15, label %if.end.18, label %if.then.16

if.then.16:                                       ; preds = %land.lhs.true.11, %cond.false, %cond.true, %if.end
  %call17 = call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.109, i32 0, i32 0), i32 0, i32 12)
  store %struct.gv* %call17, %struct.gv** %gv, align 8
  br label %if.end.18

if.end.18:                                        ; preds = %if.then.16, %land.lhs.true.11
  %19 = load %struct.gv*, %struct.gv** %gv, align 8
  %tobool19 = icmp ne %struct.gv* %19, null
  br i1 %tobool19, label %land.lhs.true.20, label %if.then.37

land.lhs.true.20:                                 ; preds = %if.end.18
  %20 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any21 = getelementptr inbounds %struct.gv, %struct.gv* %20, i32 0, i32 0
  %21 = load %struct.xpvgv*, %struct.xpvgv** %sv_any21, align 8
  %xgv_gp22 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %21, i32 0, i32 7
  %22 = load %struct.gp*, %struct.gp** %xgv_gp22, align 8
  %gp_cvgen23 = getelementptr inbounds %struct.gp, %struct.gp* %22, i32 0, i32 8
  %23 = load i32, i32* %gp_cvgen23, align 4
  %tobool24 = icmp ne i32 %23, 0
  br i1 %tobool24, label %cond.true.25, label %cond.false.26

cond.true.25:                                     ; preds = %land.lhs.true.20
  br i1 false, label %land.lhs.true.31, label %if.then.37

cond.false.26:                                    ; preds = %land.lhs.true.20
  %24 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any27 = getelementptr inbounds %struct.gv, %struct.gv* %24, i32 0, i32 0
  %25 = load %struct.xpvgv*, %struct.xpvgv** %sv_any27, align 8
  %xgv_gp28 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %25, i32 0, i32 7
  %26 = load %struct.gp*, %struct.gp** %xgv_gp28, align 8
  %gp_cv29 = getelementptr inbounds %struct.gp, %struct.gp* %26, i32 0, i32 7
  %27 = load %struct.cv*, %struct.cv** %gp_cv29, align 8
  %tobool30 = icmp ne %struct.cv* %27, null
  br i1 %tobool30, label %land.lhs.true.31, label %if.then.37

land.lhs.true.31:                                 ; preds = %cond.false.26, %cond.true.25
  %28 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any32 = getelementptr inbounds %struct.gv, %struct.gv* %28, i32 0, i32 0
  %29 = load %struct.xpvgv*, %struct.xpvgv** %sv_any32, align 8
  %xgv_flags33 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %29, i32 0, i32 11
  %30 = load i8, i8* %xgv_flags33, align 1
  %conv34 = zext i8 %30 to i32
  %and35 = and i32 %conv34, 128
  %tobool36 = icmp ne i32 %and35, 0
  br i1 %tobool36, label %if.end.56, label %if.then.37

if.then.37:                                       ; preds = %land.lhs.true.31, %cond.false.26, %cond.true.25, %if.end.18
  call void @Perl_push_scope()
  %call38 = call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.110, i32 0, i32 0), i64 10)
  call void (i32, %struct.sv*, %struct.sv*, ...) @Perl_load_module(i32 2, %struct.sv* %call38, %struct.sv* null, %struct.sv* null, %struct.sv* null)
  %call39 = call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.109, i32 0, i32 0), i32 0, i32 12)
  store %struct.gv* %call39, %struct.gv** %gv, align 8
  %call40 = call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.111, i32 0, i32 0), i32 0, i32 12)
  store %struct.gv* %call40, %struct.gv** %glob_gv, align 8
  %31 = load %struct.gv*, %struct.gv** %glob_gv, align 8
  %sv_any41 = getelementptr inbounds %struct.gv, %struct.gv* %31, i32 0, i32 0
  %32 = load %struct.xpvgv*, %struct.xpvgv** %sv_any41, align 8
  %xgv_gp42 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %32, i32 0, i32 7
  %33 = load %struct.gp*, %struct.gp** %xgv_gp42, align 8
  %gp_cv43 = getelementptr inbounds %struct.gp, %struct.gp* %33, i32 0, i32 7
  %34 = load %struct.cv*, %struct.cv** %gp_cv43, align 8
  %35 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any44 = getelementptr inbounds %struct.gv, %struct.gv* %35, i32 0, i32 0
  %36 = load %struct.xpvgv*, %struct.xpvgv** %sv_any44, align 8
  %xgv_gp45 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %36, i32 0, i32 7
  %37 = load %struct.gp*, %struct.gp** %xgv_gp45, align 8
  %gp_cv46 = getelementptr inbounds %struct.gp, %struct.gp* %37, i32 0, i32 7
  store %struct.cv* %34, %struct.cv** %gp_cv46, align 8
  %38 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any47 = getelementptr inbounds %struct.gv, %struct.gv* %38, i32 0, i32 0
  %39 = load %struct.xpvgv*, %struct.xpvgv** %sv_any47, align 8
  %xgv_gp48 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %39, i32 0, i32 7
  %40 = load %struct.gp*, %struct.gp** %xgv_gp48, align 8
  %gp_cv49 = getelementptr inbounds %struct.gp, %struct.gp* %40, i32 0, i32 7
  %41 = load %struct.cv*, %struct.cv** %gp_cv49, align 8
  %42 = bitcast %struct.cv* %41 to %struct.sv*
  store %struct.sv* %42, %struct.sv** @PL_Sv, align 8
  %43 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %tobool50 = icmp ne %struct.sv* %43, null
  br i1 %tobool50, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then.37
  %44 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_refcnt = getelementptr inbounds %struct.sv, %struct.sv* %44, i32 0, i32 1
  %45 = load i32, i32* %sv_refcnt, align 4
  %inc = add i32 %45, 1
  store i32 %inc, i32* %sv_refcnt, align 4
  %tobool51 = icmp ne i32 %inc, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then.37
  %46 = phi i1 [ false, %if.then.37 ], [ %tobool51, %land.rhs ]
  %land.ext = zext i1 %46 to i32
  %47 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %48 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any52 = getelementptr inbounds %struct.gv, %struct.gv* %48, i32 0, i32 0
  %49 = load %struct.xpvgv*, %struct.xpvgv** %sv_any52, align 8
  %xgv_flags53 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %49, i32 0, i32 11
  %50 = load i8, i8* %xgv_flags53, align 1
  %conv54 = zext i8 %50 to i32
  %or = or i32 %conv54, 128
  %conv55 = trunc i32 %or to i8
  store i8 %conv55, i8* %xgv_flags53, align 1
  call void @Perl_pop_scope()
  br label %if.end.56

if.end.56:                                        ; preds = %land.end, %land.lhs.true.31
  %51 = load %struct.gv*, %struct.gv** %gv, align 8
  %tobool57 = icmp ne %struct.gv* %51, null
  br i1 %tobool57, label %land.lhs.true.58, label %if.end.94

land.lhs.true.58:                                 ; preds = %if.end.56
  %52 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any59 = getelementptr inbounds %struct.gv, %struct.gv* %52, i32 0, i32 0
  %53 = load %struct.xpvgv*, %struct.xpvgv** %sv_any59, align 8
  %xgv_gp60 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %53, i32 0, i32 7
  %54 = load %struct.gp*, %struct.gp** %xgv_gp60, align 8
  %gp_cvgen61 = getelementptr inbounds %struct.gp, %struct.gp* %54, i32 0, i32 8
  %55 = load i32, i32* %gp_cvgen61, align 4
  %tobool62 = icmp ne i32 %55, 0
  br i1 %tobool62, label %cond.true.63, label %cond.false.64

cond.true.63:                                     ; preds = %land.lhs.true.58
  br i1 false, label %land.lhs.true.69, label %if.end.94

cond.false.64:                                    ; preds = %land.lhs.true.58
  %56 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any65 = getelementptr inbounds %struct.gv, %struct.gv* %56, i32 0, i32 0
  %57 = load %struct.xpvgv*, %struct.xpvgv** %sv_any65, align 8
  %xgv_gp66 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %57, i32 0, i32 7
  %58 = load %struct.gp*, %struct.gp** %xgv_gp66, align 8
  %gp_cv67 = getelementptr inbounds %struct.gp, %struct.gp* %58, i32 0, i32 7
  %59 = load %struct.cv*, %struct.cv** %gp_cv67, align 8
  %tobool68 = icmp ne %struct.cv* %59, null
  br i1 %tobool68, label %land.lhs.true.69, label %if.end.94

land.lhs.true.69:                                 ; preds = %cond.false.64, %cond.true.63
  %60 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any70 = getelementptr inbounds %struct.gv, %struct.gv* %60, i32 0, i32 0
  %61 = load %struct.xpvgv*, %struct.xpvgv** %sv_any70, align 8
  %xgv_flags71 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %61, i32 0, i32 11
  %62 = load i8, i8* %xgv_flags71, align 1
  %conv72 = zext i8 %62 to i32
  %and73 = and i32 %conv72, 128
  %tobool74 = icmp ne i32 %and73, 0
  br i1 %tobool74, label %if.then.75, label %if.end.94

if.then.75:                                       ; preds = %land.lhs.true.69
  %63 = load %struct.op*, %struct.op** %o.addr, align 8
  %64 = load i32, i32* @PL_glob_index, align 4
  %inc76 = add nsw i32 %64, 1
  store i32 %inc76, i32* @PL_glob_index, align 4
  %conv77 = sext i32 %64 to i64
  %call78 = call %struct.sv* @Perl_newSViv(i64 %conv77)
  %call79 = call %struct.op* @Perl_newSVOP(i32 5, i32 0, %struct.sv* %call78)
  %call80 = call %struct.op* @Perl_append_elem(i32 25, %struct.op* %63, %struct.op* %call79)
  %65 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %65, i32 0, i32 4
  store i16 141, i16* %op_type, align 2
  %66 = load %struct.op* ()*, %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 141), align 8
  %67 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_ppaddr = getelementptr inbounds %struct.op, %struct.op* %67, i32 0, i32 2
  store %struct.op* ()* %66, %struct.op* ()** %op_ppaddr, align 8
  %68 = load %struct.op*, %struct.op** %o.addr, align 8
  %69 = bitcast %struct.op* %68 to %struct.listop*
  %op_first81 = getelementptr inbounds %struct.listop, %struct.listop* %69, i32 0, i32 8
  %70 = load %struct.op*, %struct.op** %op_first81, align 8
  %op_type82 = getelementptr inbounds %struct.op, %struct.op* %70, i32 0, i32 4
  store i16 3, i16* %op_type82, align 2
  %71 = load %struct.op* ()*, %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 3), align 8
  %72 = load %struct.op*, %struct.op** %o.addr, align 8
  %73 = bitcast %struct.op* %72 to %struct.listop*
  %op_first83 = getelementptr inbounds %struct.listop, %struct.listop* %73, i32 0, i32 8
  %74 = load %struct.op*, %struct.op** %op_first83, align 8
  %op_ppaddr84 = getelementptr inbounds %struct.op, %struct.op* %74, i32 0, i32 2
  store %struct.op* ()* %71, %struct.op* ()** %op_ppaddr84, align 8
  %75 = load %struct.op*, %struct.op** %o.addr, align 8
  %76 = bitcast %struct.op* %75 to %struct.listop*
  %op_first85 = getelementptr inbounds %struct.listop, %struct.listop* %76, i32 0, i32 8
  %77 = load %struct.op*, %struct.op** %op_first85, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %77, i32 0, i32 3
  store i64 0, i64* %op_targ, align 8
  %78 = load %struct.op*, %struct.op** %o.addr, align 8
  %79 = load %struct.gv*, %struct.gv** %gv, align 8
  %call86 = call %struct.op* @Perl_newGVOP(i32 7, i32 0, %struct.gv* %79)
  %call87 = call %struct.op* @Perl_newUNOP(i32 17, i32 0, %struct.op* %call86)
  %call88 = call %struct.op* @Perl_scalar(%struct.op* %call87)
  %call89 = call %struct.op* @Perl_append_elem(i32 141, %struct.op* %78, %struct.op* %call88)
  %call90 = call %struct.op* @Perl_newUNOP(i32 166, i32 64, %struct.op* %call89)
  store %struct.op* %call90, %struct.op** %o.addr, align 8
  %80 = load %struct.op*, %struct.op** %o.addr, align 8
  %call91 = call %struct.op* @Perl_ck_subr(%struct.op* %80)
  %call92 = call %struct.op* @Perl_newUNOP(i32 0, i32 0, %struct.op* %call91)
  store %struct.op* %call92, %struct.op** %o.addr, align 8
  %81 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_targ93 = getelementptr inbounds %struct.op, %struct.op* %81, i32 0, i32 3
  store i64 25, i64* %op_targ93, align 8
  %82 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %82, %struct.op** %retval
  br label %return

if.end.94:                                        ; preds = %land.lhs.true.69, %cond.false.64, %cond.true.63, %if.end.56
  %call95 = call %struct.gv* @Perl_newGVgen(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.112, i32 0, i32 0))
  store %struct.gv* %call95, %struct.gv** %gv, align 8
  %83 = load %struct.gv*, %struct.gv** %gv, align 8
  %call96 = call %struct.gv* @Perl_gv_IOadd(%struct.gv* %83)
  %84 = load %struct.op*, %struct.op** %o.addr, align 8
  %85 = load %struct.gv*, %struct.gv** %gv, align 8
  %call97 = call %struct.op* @Perl_newGVOP(i32 7, i32 0, %struct.gv* %85)
  %call98 = call %struct.op* @Perl_append_elem(i32 25, %struct.op* %84, %struct.op* %call97)
  %86 = load %struct.op*, %struct.op** %o.addr, align 8
  %call99 = call %struct.op* @Perl_scalarkids(%struct.op* %86)
  %87 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %87, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.94, %if.then.75
  %88 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %88
}

declare %struct.sv* @Perl_newSViv(i64) #1

declare %struct.gv* @Perl_newGVgen(i8*) #1

declare %struct.gv* @Perl_gv_IOadd(%struct.gv*) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_grep(%struct.op* %o) #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %o.addr = alloca %struct.op*, align 8
  %gwop = alloca %struct.logop*, align 8
  %kid = alloca %struct.op*, align 8
  %type = alloca i16, align 2
  %k = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %0, i32 0, i32 4
  %1 = load i16, i16* %op_type, align 2
  %conv = zext i16 %1 to i32
  %cmp = icmp eq i32 %conv, 152
  %cond = select i1 %cmp, i32 153, i32 155
  %conv2 = trunc i32 %cond to i16
  store i16 %conv2, i16* %type, align 2
  %2 = load %struct.op* ()*, %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 152), align 8
  %3 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_ppaddr = getelementptr inbounds %struct.op, %struct.op* %3, i32 0, i32 2
  store %struct.op* ()* %2, %struct.op* ()** %op_ppaddr, align 8
  %call = call i8* @Perl_safesysmalloc(i64 56)
  %4 = bitcast i8* %call to %struct.logop*
  store %struct.logop* %4, %struct.logop** %gwop, align 8
  %5 = load %struct.logop*, %struct.logop** %gwop, align 8
  %6 = bitcast %struct.logop* %5 to i8*
  call void @llvm.memset.p0i8.i64(i8* %6, i8 0, i64 56, i32 1, i1 false)
  %7 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %7, i32 0, i32 6
  %8 = load i8, i8* %op_flags, align 1
  %conv3 = zext i8 %8 to i32
  %and = and i32 %conv3, 64
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end.15

if.then:                                          ; preds = %entry
  %9 = load %struct.op*, %struct.op** %o.addr, align 8
  %call4 = call %struct.op* @Perl_ck_sort(%struct.op* %9)
  store %struct.op* %call4, %struct.op** %o.addr, align 8
  %10 = load %struct.op*, %struct.op** %o.addr, align 8
  %11 = bitcast %struct.op* %10 to %struct.listop*
  %op_first = getelementptr inbounds %struct.listop, %struct.listop* %11, i32 0, i32 8
  %12 = load %struct.op*, %struct.op** %op_first, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %12, i32 0, i32 1
  %13 = load %struct.op*, %struct.op** %op_sibling, align 8
  store %struct.op* %13, %struct.op** %kid, align 8
  %14 = load %struct.op*, %struct.op** %kid, align 8
  %15 = bitcast %struct.op* %14 to %struct.unop*
  %op_next = getelementptr inbounds %struct.unop, %struct.unop* %15, i32 0, i32 0
  %16 = load %struct.op*, %struct.op** %op_next, align 8
  %tobool5 = icmp ne %struct.op* %16, null
  br i1 %tobool5, label %if.end, label %if.then.6

if.then.6:                                        ; preds = %if.then
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.113, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then.6, %if.then
  %17 = load %struct.op*, %struct.op** %kid, align 8
  %18 = bitcast %struct.op* %17 to %struct.unop*
  %op_first7 = getelementptr inbounds %struct.unop, %struct.unop* %18, i32 0, i32 8
  %19 = load %struct.op*, %struct.op** %op_first7, align 8
  store %struct.op* %19, %struct.op** %k, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %20 = load %struct.op*, %struct.op** %k, align 8
  %tobool8 = icmp ne %struct.op* %20, null
  br i1 %tobool8, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %21 = load %struct.op*, %struct.op** %k, align 8
  store %struct.op* %21, %struct.op** %kid, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %22 = load %struct.op*, %struct.op** %k, align 8
  %op_next9 = getelementptr inbounds %struct.op, %struct.op* %22, i32 0, i32 0
  %23 = load %struct.op*, %struct.op** %op_next9, align 8
  store %struct.op* %23, %struct.op** %k, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %24 = load %struct.logop*, %struct.logop** %gwop, align 8
  %25 = bitcast %struct.logop* %24 to %struct.op*
  %26 = load %struct.op*, %struct.op** %kid, align 8
  %op_next10 = getelementptr inbounds %struct.op, %struct.op* %26, i32 0, i32 0
  store %struct.op* %25, %struct.op** %op_next10, align 8
  %27 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags11 = getelementptr inbounds %struct.op, %struct.op* %27, i32 0, i32 6
  %28 = load i8, i8* %op_flags11, align 1
  %conv12 = zext i8 %28 to i32
  %and13 = and i32 %conv12, -65
  %conv14 = trunc i32 %and13 to i8
  store i8 %conv14, i8* %op_flags11, align 1
  br label %if.end.15

if.end.15:                                        ; preds = %for.end, %entry
  %29 = load %struct.op*, %struct.op** %o.addr, align 8
  %30 = bitcast %struct.op* %29 to %struct.listop*
  %op_first16 = getelementptr inbounds %struct.listop, %struct.listop* %30, i32 0, i32 8
  %31 = load %struct.op*, %struct.op** %op_first16, align 8
  %op_sibling17 = getelementptr inbounds %struct.op, %struct.op* %31, i32 0, i32 1
  %32 = load %struct.op*, %struct.op** %op_sibling17, align 8
  store %struct.op* %32, %struct.op** %kid, align 8
  %33 = load i16, i16* %type, align 2
  %conv18 = zext i16 %33 to i32
  %cmp19 = icmp eq i32 %conv18, 155
  br i1 %cmp19, label %if.then.21, label %if.else

if.then.21:                                       ; preds = %if.end.15
  %34 = load %struct.op*, %struct.op** %kid, align 8
  %call22 = call %struct.op* @Perl_list(%struct.op* %34)
  br label %if.end.24

if.else:                                          ; preds = %if.end.15
  %35 = load %struct.op*, %struct.op** %kid, align 8
  %call23 = call %struct.op* @Perl_scalar(%struct.op* %35)
  br label %if.end.24

if.end.24:                                        ; preds = %if.else, %if.then.21
  %36 = load %struct.op*, %struct.op** %o.addr, align 8
  %call25 = call %struct.op* @Perl_ck_fun(%struct.op* %36)
  store %struct.op* %call25, %struct.op** %o.addr, align 8
  %37 = load i32, i32* @PL_error_count, align 4
  %tobool26 = icmp ne i32 %37, 0
  br i1 %tobool26, label %if.then.27, label %if.end.28

if.then.27:                                       ; preds = %if.end.24
  %38 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %38, %struct.op** %retval
  br label %return

if.end.28:                                        ; preds = %if.end.24
  %39 = load %struct.op*, %struct.op** %o.addr, align 8
  %40 = bitcast %struct.op* %39 to %struct.listop*
  %op_first29 = getelementptr inbounds %struct.listop, %struct.listop* %40, i32 0, i32 8
  %41 = load %struct.op*, %struct.op** %op_first29, align 8
  %op_sibling30 = getelementptr inbounds %struct.op, %struct.op* %41, i32 0, i32 1
  %42 = load %struct.op*, %struct.op** %op_sibling30, align 8
  store %struct.op* %42, %struct.op** %kid, align 8
  %43 = load %struct.op*, %struct.op** %kid, align 8
  %op_type31 = getelementptr inbounds %struct.op, %struct.op* %43, i32 0, i32 4
  %44 = load i16, i16* %op_type31, align 2
  %conv32 = zext i16 %44 to i32
  %cmp33 = icmp ne i32 %conv32, 0
  br i1 %cmp33, label %if.then.35, label %if.end.36

if.then.35:                                       ; preds = %if.end.28
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.113, i32 0, i32 0))
  br label %if.end.36

if.end.36:                                        ; preds = %if.then.35, %if.end.28
  %45 = load %struct.op*, %struct.op** %kid, align 8
  %46 = bitcast %struct.op* %45 to %struct.unop*
  %op_first37 = getelementptr inbounds %struct.unop, %struct.unop* %46, i32 0, i32 8
  %47 = load %struct.op*, %struct.op** %op_first37, align 8
  store %struct.op* %47, %struct.op** %kid, align 8
  %48 = load i16, i16* %type, align 2
  %49 = load %struct.logop*, %struct.logop** %gwop, align 8
  %op_type38 = getelementptr inbounds %struct.logop, %struct.logop* %49, i32 0, i32 4
  store i16 %48, i16* %op_type38, align 2
  %50 = load i16, i16* %type, align 2
  %idxprom = zext i16 %50 to i64
  %arrayidx = getelementptr inbounds [0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 %idxprom
  %51 = load %struct.op* ()*, %struct.op* ()** %arrayidx, align 8
  %52 = load %struct.logop*, %struct.logop** %gwop, align 8
  %op_ppaddr39 = getelementptr inbounds %struct.logop, %struct.logop* %52, i32 0, i32 2
  store %struct.op* ()* %51, %struct.op* ()** %op_ppaddr39, align 8
  %53 = load %struct.op*, %struct.op** %o.addr, align 8
  %call40 = call %struct.op* @Perl_listkids(%struct.op* %53)
  %54 = load %struct.logop*, %struct.logop** %gwop, align 8
  %op_first41 = getelementptr inbounds %struct.logop, %struct.logop* %54, i32 0, i32 8
  store %struct.op* %call40, %struct.op** %op_first41, align 8
  %55 = load %struct.logop*, %struct.logop** %gwop, align 8
  %op_flags42 = getelementptr inbounds %struct.logop, %struct.logop* %55, i32 0, i32 6
  %56 = load i8, i8* %op_flags42, align 1
  %conv43 = zext i8 %56 to i32
  %or = or i32 %conv43, 4
  %conv44 = trunc i32 %or to i8
  store i8 %conv44, i8* %op_flags42, align 1
  %57 = load %struct.logop*, %struct.logop** %gwop, align 8
  %op_private = getelementptr inbounds %struct.logop, %struct.logop* %57, i32 0, i32 7
  store i8 1, i8* %op_private, align 1
  %58 = load %struct.op*, %struct.op** %kid, align 8
  %op_next45 = getelementptr inbounds %struct.op, %struct.op* %58, i32 0, i32 0
  %59 = load %struct.op*, %struct.op** %op_next45, align 8
  %tobool46 = icmp ne %struct.op* %59, null
  br i1 %tobool46, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.36
  %60 = load %struct.op*, %struct.op** %kid, align 8
  %op_next47 = getelementptr inbounds %struct.op, %struct.op* %60, i32 0, i32 0
  %61 = load %struct.op*, %struct.op** %op_next47, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end.36
  %62 = load %struct.op*, %struct.op** %kid, align 8
  %call48 = call %struct.op* @Perl_linklist(%struct.op* %62)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond49 = phi %struct.op* [ %61, %cond.true ], [ %call48, %cond.false ]
  %63 = load %struct.logop*, %struct.logop** %gwop, align 8
  %op_other = getelementptr inbounds %struct.logop, %struct.logop* %63, i32 0, i32 9
  store %struct.op* %cond49, %struct.op** %op_other, align 8
  %64 = load i16, i16* %type, align 2
  %conv50 = zext i16 %64 to i32
  %call51 = call i64 @Perl_pad_alloc(i32 %conv50, i32 512)
  %65 = load %struct.logop*, %struct.logop** %gwop, align 8
  %op_targ = getelementptr inbounds %struct.logop, %struct.logop* %65, i32 0, i32 3
  store i64 %call51, i64* %op_targ, align 8
  %66 = load %struct.logop*, %struct.logop** %gwop, align 8
  %67 = bitcast %struct.logop* %66 to %struct.op*
  %68 = load %struct.op*, %struct.op** %kid, align 8
  %op_next52 = getelementptr inbounds %struct.op, %struct.op* %68, i32 0, i32 0
  store %struct.op* %67, %struct.op** %op_next52, align 8
  %69 = load %struct.op*, %struct.op** %o.addr, align 8
  %70 = bitcast %struct.op* %69 to %struct.listop*
  %op_first53 = getelementptr inbounds %struct.listop, %struct.listop* %70, i32 0, i32 8
  %71 = load %struct.op*, %struct.op** %op_first53, align 8
  %op_sibling54 = getelementptr inbounds %struct.op, %struct.op* %71, i32 0, i32 1
  %72 = load %struct.op*, %struct.op** %op_sibling54, align 8
  store %struct.op* %72, %struct.op** %kid, align 8
  %73 = load %struct.op*, %struct.op** %kid, align 8
  %tobool55 = icmp ne %struct.op* %73, null
  br i1 %tobool55, label %lor.lhs.false, label %if.then.58

lor.lhs.false:                                    ; preds = %cond.end
  %74 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling56 = getelementptr inbounds %struct.op, %struct.op* %74, i32 0, i32 1
  %75 = load %struct.op*, %struct.op** %op_sibling56, align 8
  %tobool57 = icmp ne %struct.op* %75, null
  br i1 %tobool57, label %if.end.72, label %if.then.58

if.then.58:                                       ; preds = %lor.lhs.false, %cond.end
  %76 = load %struct.op*, %struct.op** %o.addr, align 8
  %77 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type59 = getelementptr inbounds %struct.op, %struct.op* %77, i32 0, i32 4
  %78 = load i16, i16* %op_type59, align 2
  %conv60 = zext i16 %78 to i32
  %cmp61 = icmp eq i32 %conv60, 351
  br i1 %cmp61, label %cond.true.63, label %cond.false.65

cond.true.63:                                     ; preds = %if.then.58
  %79 = load %struct.op*, %struct.op** %o.addr, align 8
  %call64 = call i8* @Perl_custom_op_desc(%struct.op* %79)
  br label %cond.end.69

cond.false.65:                                    ; preds = %if.then.58
  %80 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type66 = getelementptr inbounds %struct.op, %struct.op* %80, i32 0, i32 4
  %81 = load i16, i16* %op_type66, align 2
  %idxprom67 = zext i16 %81 to i64
  %arrayidx68 = getelementptr inbounds [0 x i8*], [0 x i8*]* @PL_op_desc, i32 0, i64 %idxprom67
  %82 = load i8*, i8** %arrayidx68, align 8
  br label %cond.end.69

cond.end.69:                                      ; preds = %cond.false.65, %cond.true.63
  %cond70 = phi i8* [ %call64, %cond.true.63 ], [ %82, %cond.false.65 ]
  %call71 = call %struct.op* @S_too_few_arguments(%struct.op* %76, i8* %cond70)
  store %struct.op* %call71, %struct.op** %retval
  br label %return

if.end.72:                                        ; preds = %lor.lhs.false
  %83 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling73 = getelementptr inbounds %struct.op, %struct.op* %83, i32 0, i32 1
  %84 = load %struct.op*, %struct.op** %op_sibling73, align 8
  store %struct.op* %84, %struct.op** %kid, align 8
  br label %for.cond.74

for.cond.74:                                      ; preds = %for.inc.78, %if.end.72
  %85 = load %struct.op*, %struct.op** %kid, align 8
  %tobool75 = icmp ne %struct.op* %85, null
  br i1 %tobool75, label %for.body.76, label %for.end.80

for.body.76:                                      ; preds = %for.cond.74
  %86 = load %struct.op*, %struct.op** %kid, align 8
  %call77 = call %struct.op* @Perl_mod(%struct.op* %86, i32 152)
  br label %for.inc.78

for.inc.78:                                       ; preds = %for.body.76
  %87 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling79 = getelementptr inbounds %struct.op, %struct.op* %87, i32 0, i32 1
  %88 = load %struct.op*, %struct.op** %op_sibling79, align 8
  store %struct.op* %88, %struct.op** %kid, align 8
  br label %for.cond.74

for.end.80:                                       ; preds = %for.cond.74
  %89 = load %struct.logop*, %struct.logop** %gwop, align 8
  %90 = bitcast %struct.logop* %89 to %struct.op*
  store %struct.op* %90, %struct.op** %retval
  br label %return

return:                                           ; preds = %for.end.80, %cond.end.69, %if.then.27
  %91 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %91
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_sort(%struct.op* %o) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  %firstkid = alloca %struct.op*, align 8
  %k = alloca %struct.op*, align 8
  %kid = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %0, i32 0, i32 4
  %1 = load i16, i16* %op_type, align 2
  %conv = zext i16 %1 to i32
  %cmp = icmp eq i32 %conv, 150
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %2 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %2, i32 0, i32 6
  %3 = load i8, i8* %op_flags, align 1
  %conv2 = zext i8 %3 to i32
  %and = and i32 %conv2, 64
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %4 = load %struct.op*, %struct.op** %o.addr, align 8
  call void @S_simplify_sort(%struct.op* %4)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %5 = load %struct.op*, %struct.op** %o.addr, align 8
  %6 = bitcast %struct.op* %5 to %struct.listop*
  %op_first = getelementptr inbounds %struct.listop, %struct.listop* %6, i32 0, i32 8
  %7 = load %struct.op*, %struct.op** %op_first, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %7, i32 0, i32 1
  %8 = load %struct.op*, %struct.op** %op_sibling, align 8
  store %struct.op* %8, %struct.op** %firstkid, align 8
  %9 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags3 = getelementptr inbounds %struct.op, %struct.op* %9, i32 0, i32 6
  %10 = load i8, i8* %op_flags3, align 1
  %conv4 = zext i8 %10 to i32
  %and5 = and i32 %conv4, 64
  %tobool6 = icmp ne i32 %and5, 0
  br i1 %tobool6, label %if.then.7, label %if.end.90

if.then.7:                                        ; preds = %if.end
  store %struct.op* null, %struct.op** %k, align 8
  %11 = load %struct.op*, %struct.op** %firstkid, align 8
  %12 = bitcast %struct.op* %11 to %struct.unop*
  %op_first8 = getelementptr inbounds %struct.unop, %struct.unop* %12, i32 0, i32 8
  %13 = load %struct.op*, %struct.op** %op_first8, align 8
  store %struct.op* %13, %struct.op** %kid, align 8
  %14 = load %struct.op*, %struct.op** %kid, align 8
  %op_type9 = getelementptr inbounds %struct.op, %struct.op* %14, i32 0, i32 4
  %15 = load i16, i16* %op_type9, align 2
  %conv10 = zext i16 %15 to i32
  %cmp11 = icmp eq i32 %conv10, 179
  br i1 %cmp11, label %if.then.17, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then.7
  %16 = load %struct.op*, %struct.op** %kid, align 8
  %op_type13 = getelementptr inbounds %struct.op, %struct.op* %16, i32 0, i32 4
  %17 = load i16, i16* %op_type13, align 2
  %conv14 = zext i16 %17 to i32
  %cmp15 = icmp eq i32 %conv14, 178
  br i1 %cmp15, label %if.then.17, label %if.else.76

if.then.17:                                       ; preds = %lor.lhs.false, %if.then.7
  %18 = load %struct.op*, %struct.op** %kid, align 8
  %call = call %struct.op* @Perl_linklist(%struct.op* %18)
  %19 = load %struct.op*, %struct.op** %kid, align 8
  %op_type18 = getelementptr inbounds %struct.op, %struct.op* %19, i32 0, i32 4
  %20 = load i16, i16* %op_type18, align 2
  %conv19 = zext i16 %20 to i32
  %cmp20 = icmp eq i32 %conv19, 179
  br i1 %cmp20, label %if.then.22, label %if.else

if.then.22:                                       ; preds = %if.then.17
  %21 = load %struct.op*, %struct.op** %kid, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %21, i32 0, i32 0
  %22 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %22, %struct.op** %k, align 8
  %23 = load %struct.op*, %struct.op** %kid, align 8
  %op_next23 = getelementptr inbounds %struct.op, %struct.op* %23, i32 0, i32 0
  store %struct.op* null, %struct.op** %op_next23, align 8
  br label %if.end.62

if.else:                                          ; preds = %if.then.17
  %24 = load %struct.op*, %struct.op** %kid, align 8
  %op_type24 = getelementptr inbounds %struct.op, %struct.op* %24, i32 0, i32 4
  %25 = load i16, i16* %op_type24, align 2
  %conv25 = zext i16 %25 to i32
  %cmp26 = icmp eq i32 %conv25, 178
  br i1 %cmp26, label %if.then.28, label %if.end.61

if.then.28:                                       ; preds = %if.else
  %26 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type29 = getelementptr inbounds %struct.op, %struct.op* %26, i32 0, i32 4
  %27 = load i16, i16* %op_type29, align 2
  %conv30 = zext i16 %27 to i32
  %cmp31 = icmp eq i32 %conv30, 150
  br i1 %cmp31, label %if.then.33, label %if.else.57

if.then.33:                                       ; preds = %if.then.28
  %28 = load %struct.op*, %struct.op** %kid, align 8
  call void @Perl_op_null(%struct.op* %28)
  %29 = load %struct.op*, %struct.op** %kid, align 8
  %30 = load %struct.op*, %struct.op** %kid, align 8
  %op_next34 = getelementptr inbounds %struct.op, %struct.op* %30, i32 0, i32 0
  store %struct.op* %29, %struct.op** %op_next34, align 8
  %31 = load %struct.op*, %struct.op** %kid, align 8
  %32 = bitcast %struct.op* %31 to %struct.listop*
  %op_first35 = getelementptr inbounds %struct.listop, %struct.listop* %32, i32 0, i32 8
  %33 = load %struct.op*, %struct.op** %op_first35, align 8
  %op_next36 = getelementptr inbounds %struct.op, %struct.op* %33, i32 0, i32 0
  %34 = load %struct.op*, %struct.op** %op_next36, align 8
  store %struct.op* %34, %struct.op** %k, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then.33
  %35 = load %struct.op*, %struct.op** %k, align 8
  %tobool37 = icmp ne %struct.op* %35, null
  br i1 %tobool37, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %36 = load %struct.op*, %struct.op** %k, align 8
  %op_next38 = getelementptr inbounds %struct.op, %struct.op* %36, i32 0, i32 0
  %37 = load %struct.op*, %struct.op** %op_next38, align 8
  %38 = load %struct.op*, %struct.op** %kid, align 8
  %cmp39 = icmp eq %struct.op* %37, %38
  br i1 %cmp39, label %if.then.41, label %if.else.43

if.then.41:                                       ; preds = %for.body
  %39 = load %struct.op*, %struct.op** %k, align 8
  %op_next42 = getelementptr inbounds %struct.op, %struct.op* %39, i32 0, i32 0
  store %struct.op* null, %struct.op** %op_next42, align 8
  br label %if.end.55

if.else.43:                                       ; preds = %for.body
  %40 = load %struct.op*, %struct.op** %k, align 8
  %op_type44 = getelementptr inbounds %struct.op, %struct.op* %40, i32 0, i32 4
  %41 = load i16, i16* %op_type44, align 2
  %conv45 = zext i16 %41 to i32
  %cmp46 = icmp eq i32 %conv45, 182
  br i1 %cmp46, label %if.then.53, label %lor.lhs.false.48

lor.lhs.false.48:                                 ; preds = %if.else.43
  %42 = load %struct.op*, %struct.op** %k, align 8
  %op_type49 = getelementptr inbounds %struct.op, %struct.op* %42, i32 0, i32 4
  %43 = load i16, i16* %op_type49, align 2
  %conv50 = zext i16 %43 to i32
  %cmp51 = icmp eq i32 %conv50, 180
  br i1 %cmp51, label %if.then.53, label %if.end.54

if.then.53:                                       ; preds = %lor.lhs.false.48, %if.else.43
  %44 = load %struct.op*, %struct.op** %k, align 8
  %45 = bitcast %struct.op* %44 to %struct.loop*
  %op_lastop = getelementptr inbounds %struct.loop, %struct.loop* %45, i32 0, i32 12
  %46 = load %struct.op*, %struct.op** %op_lastop, align 8
  store %struct.op* %46, %struct.op** %k, align 8
  br label %if.end.54

if.end.54:                                        ; preds = %if.then.53, %lor.lhs.false.48
  br label %if.end.55

if.end.55:                                        ; preds = %if.end.54, %if.then.41
  br label %for.inc

for.inc:                                          ; preds = %if.end.55
  %47 = load %struct.op*, %struct.op** %k, align 8
  %op_next56 = getelementptr inbounds %struct.op, %struct.op* %47, i32 0, i32 0
  %48 = load %struct.op*, %struct.op** %op_next56, align 8
  store %struct.op* %48, %struct.op** %k, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end.59

if.else.57:                                       ; preds = %if.then.28
  %49 = load %struct.op*, %struct.op** %kid, align 8
  %op_next58 = getelementptr inbounds %struct.op, %struct.op* %49, i32 0, i32 0
  store %struct.op* null, %struct.op** %op_next58, align 8
  br label %if.end.59

if.end.59:                                        ; preds = %if.else.57, %for.end
  %50 = load %struct.op*, %struct.op** %kid, align 8
  %51 = bitcast %struct.op* %50 to %struct.listop*
  %op_first60 = getelementptr inbounds %struct.listop, %struct.listop* %51, i32 0, i32 8
  %52 = load %struct.op*, %struct.op** %op_first60, align 8
  store %struct.op* %52, %struct.op** %k, align 8
  br label %if.end.61

if.end.61:                                        ; preds = %if.end.59, %if.else
  br label %if.end.62

if.end.62:                                        ; preds = %if.end.61, %if.then.22
  %53 = load void (%struct.op*)*, void (%struct.op*)** @PL_peepp, align 8
  %54 = load %struct.op*, %struct.op** %k, align 8
  call void %53(%struct.op* %54)
  %55 = load %struct.op*, %struct.op** %firstkid, align 8
  store %struct.op* %55, %struct.op** %kid, align 8
  %56 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type63 = getelementptr inbounds %struct.op, %struct.op* %56, i32 0, i32 4
  %57 = load i16, i16* %op_type63, align 2
  %conv64 = zext i16 %57 to i32
  %cmp65 = icmp eq i32 %conv64, 150
  br i1 %cmp65, label %if.then.67, label %if.else.70

if.then.67:                                       ; preds = %if.end.62
  %58 = load %struct.op*, %struct.op** %kid, align 8
  %call68 = call %struct.op* @Perl_scalar(%struct.op* %58)
  store %struct.op* %call68, %struct.op** %kid, align 8
  %59 = load %struct.op*, %struct.op** %kid, align 8
  %60 = load %struct.op*, %struct.op** %kid, align 8
  %op_next69 = getelementptr inbounds %struct.op, %struct.op* %60, i32 0, i32 0
  store %struct.op* %59, %struct.op** %op_next69, align 8
  br label %if.end.72

if.else.70:                                       ; preds = %if.end.62
  %61 = load %struct.op*, %struct.op** %k, align 8
  %62 = load %struct.op*, %struct.op** %kid, align 8
  %op_next71 = getelementptr inbounds %struct.op, %struct.op* %62, i32 0, i32 0
  store %struct.op* %61, %struct.op** %op_next71, align 8
  br label %if.end.72

if.end.72:                                        ; preds = %if.else.70, %if.then.67
  %63 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags73 = getelementptr inbounds %struct.op, %struct.op* %63, i32 0, i32 6
  %64 = load i8, i8* %op_flags73, align 1
  %conv74 = zext i8 %64 to i32
  %or = or i32 %conv74, 128
  %conv75 = trunc i32 %or to i8
  store i8 %conv75, i8* %op_flags73, align 1
  br label %if.end.88

if.else.76:                                       ; preds = %lor.lhs.false
  %65 = load %struct.op*, %struct.op** %kid, align 8
  %op_type77 = getelementptr inbounds %struct.op, %struct.op* %65, i32 0, i32 4
  %66 = load i16, i16* %op_type77, align 2
  %conv78 = zext i16 %66 to i32
  %cmp79 = icmp eq i32 %conv78, 15
  br i1 %cmp79, label %if.then.86, label %lor.lhs.false.81

lor.lhs.false.81:                                 ; preds = %if.else.76
  %67 = load %struct.op*, %struct.op** %kid, align 8
  %op_type82 = getelementptr inbounds %struct.op, %struct.op* %67, i32 0, i32 4
  %68 = load i16, i16* %op_type82, align 2
  %conv83 = zext i16 %68 to i32
  %cmp84 = icmp eq i32 %conv83, 9
  br i1 %cmp84, label %if.then.86, label %if.end.87

if.then.86:                                       ; preds = %lor.lhs.false.81, %if.else.76
  %69 = load %struct.op*, %struct.op** %firstkid, align 8
  call void @Perl_op_null(%struct.op* %69)
  br label %if.end.87

if.end.87:                                        ; preds = %if.then.86, %lor.lhs.false.81
  br label %if.end.88

if.end.88:                                        ; preds = %if.end.87, %if.end.72
  %70 = load %struct.op*, %struct.op** %firstkid, align 8
  %op_sibling89 = getelementptr inbounds %struct.op, %struct.op* %70, i32 0, i32 1
  %71 = load %struct.op*, %struct.op** %op_sibling89, align 8
  store %struct.op* %71, %struct.op** %firstkid, align 8
  br label %if.end.90

if.end.90:                                        ; preds = %if.end.88, %if.end
  %72 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type91 = getelementptr inbounds %struct.op, %struct.op* %72, i32 0, i32 4
  %73 = load i16, i16* %op_type91, align 2
  %conv92 = zext i16 %73 to i32
  %cmp93 = icmp eq i32 %conv92, 150
  br i1 %cmp93, label %if.then.95, label %if.end.97

if.then.95:                                       ; preds = %if.end.90
  %74 = load %struct.op*, %struct.op** %firstkid, align 8
  %call96 = call %struct.op* @Perl_list(%struct.op* %74)
  br label %if.end.97

if.end.97:                                        ; preds = %if.then.95, %if.end.90
  %75 = load %struct.op*, %struct.op** %o.addr, align 8
  ret %struct.op* %75
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_index(%struct.op* %o) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  %kid = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %0, i32 0, i32 6
  %1 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %1 to i32
  %and = and i32 %conv, 4
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end.9

if.then:                                          ; preds = %entry
  %2 = load %struct.op*, %struct.op** %o.addr, align 8
  %3 = bitcast %struct.op* %2 to %struct.listop*
  %op_first = getelementptr inbounds %struct.listop, %struct.listop* %3, i32 0, i32 8
  %4 = load %struct.op*, %struct.op** %op_first, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %4, i32 0, i32 1
  %5 = load %struct.op*, %struct.op** %op_sibling, align 8
  store %struct.op* %5, %struct.op** %kid, align 8
  %6 = load %struct.op*, %struct.op** %kid, align 8
  %tobool1 = icmp ne %struct.op* %6, null
  br i1 %tobool1, label %if.then.2, label %if.end

if.then.2:                                        ; preds = %if.then
  %7 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling3 = getelementptr inbounds %struct.op, %struct.op* %7, i32 0, i32 1
  %8 = load %struct.op*, %struct.op** %op_sibling3, align 8
  store %struct.op* %8, %struct.op** %kid, align 8
  br label %if.end

if.end:                                           ; preds = %if.then.2, %if.then
  %9 = load %struct.op*, %struct.op** %kid, align 8
  %tobool4 = icmp ne %struct.op* %9, null
  br i1 %tobool4, label %land.lhs.true, label %if.end.8

land.lhs.true:                                    ; preds = %if.end
  %10 = load %struct.op*, %struct.op** %kid, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %10, i32 0, i32 4
  %11 = load i16, i16* %op_type, align 2
  %conv5 = zext i16 %11 to i32
  %cmp = icmp eq i32 %conv5, 5
  br i1 %cmp, label %if.then.7, label %if.end.8

if.then.7:                                        ; preds = %land.lhs.true
  %12 = load %struct.op*, %struct.op** %kid, align 8
  %13 = bitcast %struct.op* %12 to %struct.svop*
  %op_sv = getelementptr inbounds %struct.svop, %struct.svop* %13, i32 0, i32 8
  %14 = load %struct.sv*, %struct.sv** %op_sv, align 8
  call void @Perl_fbm_compile(%struct.sv* %14, i32 0)
  br label %if.end.8

if.end.8:                                         ; preds = %if.then.7, %land.lhs.true, %if.end
  br label %if.end.9

if.end.9:                                         ; preds = %if.end.8, %entry
  %15 = load %struct.op*, %struct.op** %o.addr, align 8
  %call = call %struct.op* @Perl_ck_fun(%struct.op* %15)
  ret %struct.op* %call
}

declare void @Perl_fbm_compile(%struct.sv*, i32) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_lengthconst(%struct.op* %o) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %call = call %struct.op* @Perl_ck_fun(%struct.op* %0)
  ret %struct.op* %call
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_lfun(%struct.op* %o) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  %type = alloca i16, align 2
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %0, i32 0, i32 4
  %1 = load i16, i16* %op_type, align 2
  store i16 %1, i16* %type, align 2
  %2 = load %struct.op*, %struct.op** %o.addr, align 8
  %call = call %struct.op* @Perl_ck_fun(%struct.op* %2)
  %3 = load i16, i16* %type, align 2
  %conv = zext i16 %3 to i32
  %call1 = call %struct.op* @S_modkids(%struct.op* %call, i32 %conv)
  ret %struct.op* %call1
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_defined(%struct.op* %o) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %0, i32 0, i32 6
  %1 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %1 to i32
  %and = and i32 %conv, 4
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %2 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings = getelementptr inbounds %struct.cop, %struct.cop* %2, i32 0, i32 14
  %3 = load %struct.sv*, %struct.sv** %cop_warnings, align 8
  %cmp = icmp ne %struct.sv* %3, null
  br i1 %cmp, label %land.lhs.true.2, label %lor.lhs.false.22

land.lhs.true.2:                                  ; preds = %land.lhs.true
  %4 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings3 = getelementptr inbounds %struct.cop, %struct.cop* %4, i32 0, i32 14
  %5 = load %struct.sv*, %struct.sv** %cop_warnings3, align 8
  %cmp4 = icmp ne %struct.sv* %5, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 2)
  br i1 %cmp4, label %land.lhs.true.6, label %lor.lhs.false.22

land.lhs.true.6:                                  ; preds = %land.lhs.true.2
  %6 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings7 = getelementptr inbounds %struct.cop, %struct.cop* %6, i32 0, i32 14
  %7 = load %struct.sv*, %struct.sv** %cop_warnings7, align 8
  %cmp8 = icmp eq %struct.sv* %7, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 1)
  br i1 %cmp8, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true.6
  %8 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings10 = getelementptr inbounds %struct.cop, %struct.cop* %8, i32 0, i32 14
  %9 = load %struct.sv*, %struct.sv** %cop_warnings10, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %9, i32 0, i32 0
  %10 = load i8*, i8** %sv_any, align 8
  %11 = bitcast i8* %10 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %11, i32 0, i32 0
  %12 = load i8*, i8** %xpv_pv, align 8
  %arrayidx = getelementptr inbounds i8, i8* %12, i64 0
  %13 = load i8, i8* %arrayidx, align 1
  %conv11 = sext i8 %13 to i32
  %and12 = and i32 %conv11, 16
  %tobool13 = icmp ne i32 %and12, 0
  br i1 %tobool13, label %if.then, label %lor.lhs.false.14

lor.lhs.false.14:                                 ; preds = %lor.lhs.false
  %14 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings15 = getelementptr inbounds %struct.cop, %struct.cop* %14, i32 0, i32 14
  %15 = load %struct.sv*, %struct.sv** %cop_warnings15, align 8
  %sv_any16 = getelementptr inbounds %struct.sv, %struct.sv* %15, i32 0, i32 0
  %16 = load i8*, i8** %sv_any16, align 8
  %17 = bitcast i8* %16 to %struct.xpv*
  %xpv_pv17 = getelementptr inbounds %struct.xpv, %struct.xpv* %17, i32 0, i32 0
  %18 = load i8*, i8** %xpv_pv17, align 8
  %arrayidx18 = getelementptr inbounds i8, i8* %18, i64 7
  %19 = load i8, i8* %arrayidx18, align 1
  %conv19 = sext i8 %19 to i32
  %and20 = and i32 %conv19, 1
  %tobool21 = icmp ne i32 %and20, 0
  br i1 %tobool21, label %if.then, label %lor.lhs.false.22

lor.lhs.false.22:                                 ; preds = %lor.lhs.false.14, %land.lhs.true.2, %land.lhs.true
  %20 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings23 = getelementptr inbounds %struct.cop, %struct.cop* %20, i32 0, i32 14
  %21 = load %struct.sv*, %struct.sv** %cop_warnings23, align 8
  %cmp24 = icmp eq %struct.sv* %21, null
  br i1 %cmp24, label %land.lhs.true.26, label %if.end

land.lhs.true.26:                                 ; preds = %lor.lhs.false.22
  %22 = load i8, i8* @PL_dowarn, align 1
  %conv27 = zext i8 %22 to i32
  %and28 = and i32 %conv27, 1
  %tobool29 = icmp ne i32 %and28, 0
  br i1 %tobool29, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true.26, %lor.lhs.false.14, %lor.lhs.false, %land.lhs.true.6
  %23 = load %struct.op*, %struct.op** %o.addr, align 8
  %24 = bitcast %struct.op* %23 to %struct.unop*
  %op_first = getelementptr inbounds %struct.unop, %struct.unop* %24, i32 0, i32 8
  %25 = load %struct.op*, %struct.op** %op_first, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %25, i32 0, i32 4
  %26 = load i16, i16* %op_type, align 2
  %conv30 = zext i16 %26 to i32
  switch i32 %conv30, label %sw.default [
    i32 125, label %sw.bb
    i32 10, label %sw.bb.31
    i32 37, label %sw.bb.31
    i32 134, label %sw.bb.32
    i32 11, label %sw.bb.33
  ]

sw.bb:                                            ; preds = %if.then
  br label %sw.epilog

sw.bb.31:                                         ; preds = %if.then, %if.then
  call void (i32, i8*, ...) @Perl_warner(i32 7170, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.114, i32 0, i32 0))
  call void (i32, i8*, ...) @Perl_warner(i32 7170, i8* getelementptr inbounds ([46 x i8], [46 x i8]* @.str.115, i32 0, i32 0))
  br label %sw.epilog

sw.bb.32:                                         ; preds = %if.then
  br label %sw.epilog

sw.bb.33:                                         ; preds = %if.then
  call void (i32, i8*, ...) @Perl_warner(i32 7170, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.116, i32 0, i32 0))
  call void (i32, i8*, ...) @Perl_warner(i32 7170, i8* getelementptr inbounds ([46 x i8], [46 x i8]* @.str.115, i32 0, i32 0))
  br label %sw.epilog

sw.default:                                       ; preds = %if.then
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb.33, %sw.bb.32, %sw.bb.31, %sw.bb
  br label %if.end

if.end:                                           ; preds = %sw.epilog, %land.lhs.true.26, %lor.lhs.false.22, %entry
  %27 = load %struct.op*, %struct.op** %o.addr, align 8
  %call = call %struct.op* @Perl_ck_rfun(%struct.op* %27)
  ret %struct.op* %call
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_rfun(%struct.op* %o) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  %type = alloca i16, align 2
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %0, i32 0, i32 4
  %1 = load i16, i16* %op_type, align 2
  store i16 %1, i16* %type, align 2
  %2 = load %struct.op*, %struct.op** %o.addr, align 8
  %call = call %struct.op* @Perl_ck_fun(%struct.op* %2)
  %3 = load i16, i16* %type, align 2
  %conv = zext i16 %3 to i32
  %call1 = call %struct.op* @Perl_refkids(%struct.op* %call, i32 %conv)
  ret %struct.op* %call1
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_listiob(%struct.op* %o) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  %kid = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %1 = bitcast %struct.op* %0 to %struct.listop*
  %op_first = getelementptr inbounds %struct.listop, %struct.listop* %1, i32 0, i32 8
  %2 = load %struct.op*, %struct.op** %op_first, align 8
  store %struct.op* %2, %struct.op** %kid, align 8
  %3 = load %struct.op*, %struct.op** %kid, align 8
  %tobool = icmp ne %struct.op* %3, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %4 = load %struct.op*, %struct.op** %o.addr, align 8
  %call = call %struct.op* @Perl_force_list(%struct.op* %4)
  store %struct.op* %call, %struct.op** %o.addr, align 8
  %5 = load %struct.op*, %struct.op** %o.addr, align 8
  %6 = bitcast %struct.op* %5 to %struct.listop*
  %op_first1 = getelementptr inbounds %struct.listop, %struct.listop* %6, i32 0, i32 8
  %7 = load %struct.op*, %struct.op** %op_first1, align 8
  store %struct.op* %7, %struct.op** %kid, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %8 = load %struct.op*, %struct.op** %kid, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %8, i32 0, i32 4
  %9 = load i16, i16* %op_type, align 2
  %conv = zext i16 %9 to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %if.then.3, label %if.end.4

if.then.3:                                        ; preds = %if.end
  %10 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %10, i32 0, i32 1
  %11 = load %struct.op*, %struct.op** %op_sibling, align 8
  store %struct.op* %11, %struct.op** %kid, align 8
  br label %if.end.4

if.end.4:                                         ; preds = %if.then.3, %if.end
  %12 = load %struct.op*, %struct.op** %kid, align 8
  %tobool5 = icmp ne %struct.op* %12, null
  br i1 %tobool5, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.end.4
  %13 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %13, i32 0, i32 6
  %14 = load i8, i8* %op_flags, align 1
  %conv6 = zext i8 %14 to i32
  %and = and i32 %conv6, 64
  %tobool7 = icmp ne i32 %and, 0
  br i1 %tobool7, label %if.then.8, label %if.else

if.then.8:                                        ; preds = %land.lhs.true
  %15 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling9 = getelementptr inbounds %struct.op, %struct.op* %15, i32 0, i32 1
  %16 = load %struct.op*, %struct.op** %op_sibling9, align 8
  store %struct.op* %16, %struct.op** %kid, align 8
  br label %if.end.34

if.else:                                          ; preds = %land.lhs.true, %if.end.4
  %17 = load %struct.op*, %struct.op** %kid, align 8
  %tobool10 = icmp ne %struct.op* %17, null
  br i1 %tobool10, label %land.lhs.true.11, label %if.end.33

land.lhs.true.11:                                 ; preds = %if.else
  %18 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling12 = getelementptr inbounds %struct.op, %struct.op* %18, i32 0, i32 1
  %19 = load %struct.op*, %struct.op** %op_sibling12, align 8
  %tobool13 = icmp ne %struct.op* %19, null
  br i1 %tobool13, label %if.end.33, label %if.then.14

if.then.14:                                       ; preds = %land.lhs.true.11
  %20 = load %struct.op*, %struct.op** %kid, align 8
  %op_type15 = getelementptr inbounds %struct.op, %struct.op* %20, i32 0, i32 4
  %21 = load i16, i16* %op_type15, align 2
  %conv16 = zext i16 %21 to i32
  %cmp17 = icmp eq i32 %conv16, 5
  br i1 %cmp17, label %land.lhs.true.19, label %if.end.32

land.lhs.true.19:                                 ; preds = %if.then.14
  %22 = load %struct.op*, %struct.op** %kid, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %22, i32 0, i32 7
  %23 = load i8, i8* %op_private, align 1
  %conv20 = zext i8 %23 to i32
  %and21 = and i32 %conv20, 64
  %tobool22 = icmp ne i32 %and21, 0
  br i1 %tobool22, label %if.then.23, label %if.end.32

if.then.23:                                       ; preds = %land.lhs.true.19
  %24 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags24 = getelementptr inbounds %struct.op, %struct.op* %24, i32 0, i32 6
  %25 = load i8, i8* %op_flags24, align 1
  %conv25 = zext i8 %25 to i32
  %or = or i32 %conv25, 64
  %conv26 = trunc i32 %or to i8
  store i8 %conv26, i8* %op_flags24, align 1
  %26 = load %struct.op*, %struct.op** %kid, align 8
  %call27 = call %struct.op* @Perl_scalar(%struct.op* %26)
  %call28 = call %struct.op* @Perl_newUNOP(i32 14, i32 16, %struct.op* %call27)
  store %struct.op* %call28, %struct.op** %kid, align 8
  %27 = load %struct.op*, %struct.op** %kid, align 8
  %28 = load %struct.op*, %struct.op** %o.addr, align 8
  %29 = bitcast %struct.op* %28 to %struct.listop*
  %op_first29 = getelementptr inbounds %struct.listop, %struct.listop* %29, i32 0, i32 8
  %30 = load %struct.op*, %struct.op** %op_first29, align 8
  %op_sibling30 = getelementptr inbounds %struct.op, %struct.op* %30, i32 0, i32 1
  store %struct.op* %27, %struct.op** %op_sibling30, align 8
  %31 = load %struct.op*, %struct.op** %kid, align 8
  %32 = load %struct.op*, %struct.op** %o.addr, align 8
  %33 = bitcast %struct.op* %32 to %struct.listop*
  %op_last = getelementptr inbounds %struct.listop, %struct.listop* %33, i32 0, i32 9
  store %struct.op* %31, %struct.op** %op_last, align 8
  %34 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling31 = getelementptr inbounds %struct.op, %struct.op* %34, i32 0, i32 1
  %35 = load %struct.op*, %struct.op** %op_sibling31, align 8
  store %struct.op* %35, %struct.op** %kid, align 8
  br label %if.end.32

if.end.32:                                        ; preds = %if.then.23, %land.lhs.true.19, %if.then.14
  br label %if.end.33

if.end.33:                                        ; preds = %if.end.32, %land.lhs.true.11, %if.else
  br label %if.end.34

if.end.34:                                        ; preds = %if.end.33, %if.then.8
  %36 = load %struct.op*, %struct.op** %kid, align 8
  %tobool35 = icmp ne %struct.op* %36, null
  br i1 %tobool35, label %if.end.41, label %if.then.36

if.then.36:                                       ; preds = %if.end.34
  %37 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type37 = getelementptr inbounds %struct.op, %struct.op* %37, i32 0, i32 4
  %38 = load i16, i16* %op_type37, align 2
  %conv38 = zext i16 %38 to i32
  %39 = load %struct.op*, %struct.op** %o.addr, align 8
  %call39 = call %struct.op* @S_newDEFSVOP()
  %call40 = call %struct.op* @Perl_append_elem(i32 %conv38, %struct.op* %39, %struct.op* %call39)
  br label %if.end.41

if.end.41:                                        ; preds = %if.then.36, %if.end.34
  %40 = load %struct.op*, %struct.op** %o.addr, align 8
  %call42 = call %struct.op* @Perl_listkids(%struct.op* %40)
  ret %struct.op* %call42
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_sassign(%struct.op* %o) #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %o.addr = alloca %struct.op*, align 8
  %kid = alloca %struct.op*, align 8
  %kkid = alloca %struct.op*, align 8
  %kkid32 = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %1 = bitcast %struct.op* %0 to %struct.listop*
  %op_first = getelementptr inbounds %struct.listop, %struct.listop* %1, i32 0, i32 8
  %2 = load %struct.op*, %struct.op** %op_first, align 8
  store %struct.op* %2, %struct.op** %kid, align 8
  %3 = load %struct.op*, %struct.op** %kid, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %3, i32 0, i32 4
  %4 = load i16, i16* %op_type, align 2
  %idxprom = zext i16 %4 to i64
  %arrayidx = getelementptr inbounds [0 x i32], [0 x i32]* @PL_opargs, i32 0, i64 %idxprom
  %5 = load i32, i32* %arrayidx, align 4
  %and = and i32 %5, 256
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end.26

land.lhs.true:                                    ; preds = %entry
  %6 = load %struct.op*, %struct.op** %kid, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %6, i32 0, i32 6
  %7 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %7 to i32
  %and1 = and i32 %conv, 64
  %tobool2 = icmp ne i32 %and1, 0
  br i1 %tobool2, label %if.end.26, label %land.lhs.true.3

land.lhs.true.3:                                  ; preds = %land.lhs.true
  %8 = load %struct.op*, %struct.op** %kid, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %8, i32 0, i32 7
  %9 = load i8, i8* %op_private, align 1
  %conv4 = zext i8 %9 to i32
  %and5 = and i32 %conv4, 16
  %tobool6 = icmp ne i32 %and5, 0
  br i1 %tobool6, label %if.end.26, label %if.then

if.then:                                          ; preds = %land.lhs.true.3
  %10 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %10, i32 0, i32 1
  %11 = load %struct.op*, %struct.op** %op_sibling, align 8
  store %struct.op* %11, %struct.op** %kkid, align 8
  %12 = load %struct.op*, %struct.op** %kkid, align 8
  %tobool7 = icmp ne %struct.op* %12, null
  br i1 %tobool7, label %land.lhs.true.8, label %if.end

land.lhs.true.8:                                  ; preds = %if.then
  %13 = load %struct.op*, %struct.op** %kkid, align 8
  %op_type9 = getelementptr inbounds %struct.op, %struct.op* %13, i32 0, i32 4
  %14 = load i16, i16* %op_type9, align 2
  %conv10 = zext i16 %14 to i32
  %cmp = icmp eq i32 %conv10, 9
  br i1 %cmp, label %land.lhs.true.12, label %if.end

land.lhs.true.12:                                 ; preds = %land.lhs.true.8
  %15 = load %struct.op*, %struct.op** %kkid, align 8
  %op_private13 = getelementptr inbounds %struct.op, %struct.op* %15, i32 0, i32 7
  %16 = load i8, i8* %op_private13, align 1
  %conv14 = zext i8 %16 to i32
  %and15 = and i32 %conv14, 128
  %tobool16 = icmp ne i32 %and15, 0
  br i1 %tobool16, label %if.end, label %if.then.17

if.then.17:                                       ; preds = %land.lhs.true.12
  %17 = load %struct.op*, %struct.op** %kkid, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %17, i32 0, i32 3
  %18 = load i64, i64* %op_targ, align 8
  %19 = load %struct.op*, %struct.op** %kid, align 8
  %op_targ18 = getelementptr inbounds %struct.op, %struct.op* %19, i32 0, i32 3
  store i64 %18, i64* %op_targ18, align 8
  %20 = load %struct.op*, %struct.op** %kkid, align 8
  %op_targ19 = getelementptr inbounds %struct.op, %struct.op* %20, i32 0, i32 3
  store i64 0, i64* %op_targ19, align 8
  %21 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_sibling20 = getelementptr inbounds %struct.op, %struct.op* %21, i32 0, i32 1
  %22 = load %struct.op*, %struct.op** %op_sibling20, align 8
  %23 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling21 = getelementptr inbounds %struct.op, %struct.op* %23, i32 0, i32 1
  store %struct.op* %22, %struct.op** %op_sibling21, align 8
  %24 = load %struct.op*, %struct.op** %o.addr, align 8
  %25 = bitcast %struct.op* %24 to %struct.listop*
  %op_first22 = getelementptr inbounds %struct.listop, %struct.listop* %25, i32 0, i32 8
  store %struct.op* null, %struct.op** %op_first22, align 8
  %26 = load %struct.op*, %struct.op** %o.addr, align 8
  call void @Perl_op_free(%struct.op* %26)
  %27 = load %struct.op*, %struct.op** %kkid, align 8
  call void @Perl_op_free(%struct.op* %27)
  %28 = load %struct.op*, %struct.op** %kid, align 8
  %op_private23 = getelementptr inbounds %struct.op, %struct.op* %28, i32 0, i32 7
  %29 = load i8, i8* %op_private23, align 1
  %conv24 = zext i8 %29 to i32
  %or = or i32 %conv24, 16
  %conv25 = trunc i32 %or to i8
  store i8 %conv25, i8* %op_private23, align 1
  %30 = load %struct.op*, %struct.op** %kid, align 8
  store %struct.op* %30, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %land.lhs.true.12, %land.lhs.true.8, %if.then
  br label %if.end.26

if.end.26:                                        ; preds = %if.end, %land.lhs.true.3, %land.lhs.true, %entry
  %31 = load %struct.op*, %struct.op** %kid, align 8
  %op_type27 = getelementptr inbounds %struct.op, %struct.op* %31, i32 0, i32 4
  %32 = load i16, i16* %op_type27, align 2
  %conv28 = zext i16 %32 to i32
  %cmp29 = icmp eq i32 %conv28, 43
  br i1 %cmp29, label %if.then.31, label %if.end.49

if.then.31:                                       ; preds = %if.end.26
  %33 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling33 = getelementptr inbounds %struct.op, %struct.op* %33, i32 0, i32 1
  %34 = load %struct.op*, %struct.op** %op_sibling33, align 8
  store %struct.op* %34, %struct.op** %kkid32, align 8
  %35 = load %struct.op*, %struct.op** %kkid32, align 8
  %tobool34 = icmp ne %struct.op* %35, null
  br i1 %tobool34, label %land.lhs.true.35, label %if.end.48

land.lhs.true.35:                                 ; preds = %if.then.31
  %36 = load %struct.op*, %struct.op** %kkid32, align 8
  %op_type36 = getelementptr inbounds %struct.op, %struct.op* %36, i32 0, i32 4
  %37 = load i16, i16* %op_type36, align 2
  %conv37 = zext i16 %37 to i32
  %cmp38 = icmp eq i32 %conv37, 9
  br i1 %cmp38, label %land.lhs.true.40, label %if.end.48

land.lhs.true.40:                                 ; preds = %land.lhs.true.35
  %38 = load %struct.op*, %struct.op** %kkid32, align 8
  %op_private41 = getelementptr inbounds %struct.op, %struct.op* %38, i32 0, i32 7
  %39 = load i8, i8* %op_private41, align 1
  %conv42 = zext i8 %39 to i32
  %and43 = and i32 %conv42, 128
  %tobool44 = icmp ne i32 %and43, 0
  br i1 %tobool44, label %if.then.45, label %if.end.48

if.then.45:                                       ; preds = %land.lhs.true.40
  %40 = load %struct.op*, %struct.op** %o.addr, align 8
  %41 = bitcast %struct.op* %40 to %struct.listop*
  %op_first46 = getelementptr inbounds %struct.listop, %struct.listop* %41, i32 0, i32 8
  store %struct.op* null, %struct.op** %op_first46, align 8
  %42 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling47 = getelementptr inbounds %struct.op, %struct.op* %42, i32 0, i32 1
  store %struct.op* null, %struct.op** %op_sibling47, align 8
  %43 = load %struct.op*, %struct.op** %o.addr, align 8
  call void @Perl_op_free(%struct.op* %43)
  %44 = load %struct.op*, %struct.op** %kid, align 8
  call void @Perl_op_free(%struct.op* %44)
  %45 = load %struct.op*, %struct.op** %kkid32, align 8
  store %struct.op* %45, %struct.op** %retval
  br label %return

if.end.48:                                        ; preds = %land.lhs.true.40, %land.lhs.true.35, %if.then.31
  br label %if.end.49

if.end.49:                                        ; preds = %if.end.48, %if.end.26
  %46 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %46, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.49, %if.then.45, %if.then.17
  %47 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %47
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_match(%struct.op* %o) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %0, i32 0, i32 7
  %1 = load i8, i8* %op_private, align 1
  %conv = zext i8 %1 to i32
  %or = or i32 %conv, 64
  %conv1 = trunc i32 %or to i8
  store i8 %conv1, i8* %op_private, align 1
  %2 = load %struct.op*, %struct.op** %o.addr, align 8
  ret %struct.op* %2
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_method(%struct.op* %o) #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %o.addr = alloca %struct.op*, align 8
  %kid = alloca %struct.op*, align 8
  %sv = alloca %struct.sv*, align 8
  %cmop = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %1 = bitcast %struct.op* %0 to %struct.unop*
  %op_first = getelementptr inbounds %struct.unop, %struct.unop* %1, i32 0, i32 8
  %2 = load %struct.op*, %struct.op** %op_first, align 8
  store %struct.op* %2, %struct.op** %kid, align 8
  %3 = load %struct.op*, %struct.op** %kid, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %3, i32 0, i32 4
  %4 = load i16, i16* %op_type, align 2
  %conv = zext i16 %4 to i32
  %cmp = icmp eq i32 %conv, 5
  br i1 %cmp, label %if.then, label %if.end.21

if.then:                                          ; preds = %entry
  %5 = load %struct.op*, %struct.op** %kid, align 8
  %6 = bitcast %struct.op* %5 to %struct.svop*
  %op_sv = getelementptr inbounds %struct.svop, %struct.svop* %6, i32 0, i32 8
  %7 = load %struct.sv*, %struct.sv** %op_sv, align 8
  store %struct.sv* %7, %struct.sv** %sv, align 8
  %8 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %8, i32 0, i32 0
  %9 = load i8*, i8** %sv_any, align 8
  %10 = bitcast i8* %9 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %10, i32 0, i32 0
  %11 = load i8*, i8** %xpv_pv, align 8
  %call = call i8* @strchr(i8* %11, i32 58)
  %tobool = icmp ne i8* %call, null
  br i1 %tobool, label %if.end.20, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %12 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any2 = getelementptr inbounds %struct.sv, %struct.sv* %12, i32 0, i32 0
  %13 = load i8*, i8** %sv_any2, align 8
  %14 = bitcast i8* %13 to %struct.xpv*
  %xpv_pv3 = getelementptr inbounds %struct.xpv, %struct.xpv* %14, i32 0, i32 0
  %15 = load i8*, i8** %xpv_pv3, align 8
  %call4 = call i8* @strchr(i8* %15, i32 39)
  %tobool5 = icmp ne i8* %call4, null
  br i1 %tobool5, label %if.end.20, label %if.then.6

if.then.6:                                        ; preds = %lor.lhs.false
  %16 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %16, i32 0, i32 2
  %17 = load i32, i32* %sv_flags, align 4
  %and = and i32 %17, 8388608
  %tobool7 = icmp ne i32 %and, 0
  br i1 %tobool7, label %lor.lhs.false.8, label %if.then.12

lor.lhs.false.8:                                  ; preds = %if.then.6
  %18 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags9 = getelementptr inbounds %struct.sv, %struct.sv* %18, i32 0, i32 2
  %19 = load i32, i32* %sv_flags9, align 4
  %and10 = and i32 %19, 1048576
  %tobool11 = icmp ne i32 %and10, 0
  br i1 %tobool11, label %if.else, label %if.then.12

if.then.12:                                       ; preds = %lor.lhs.false.8, %if.then.6
  %20 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any13 = getelementptr inbounds %struct.sv, %struct.sv* %20, i32 0, i32 0
  %21 = load i8*, i8** %sv_any13, align 8
  %22 = bitcast i8* %21 to %struct.xpv*
  %xpv_pv14 = getelementptr inbounds %struct.xpv, %struct.xpv* %22, i32 0, i32 0
  %23 = load i8*, i8** %xpv_pv14, align 8
  %24 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any15 = getelementptr inbounds %struct.sv, %struct.sv* %24, i32 0, i32 0
  %25 = load i8*, i8** %sv_any15, align 8
  %26 = bitcast i8* %25 to %struct.xpv*
  %xpv_cur = getelementptr inbounds %struct.xpv, %struct.xpv* %26, i32 0, i32 1
  %27 = load i64, i64* %xpv_cur, align 8
  %conv16 = trunc i64 %27 to i32
  %call17 = call %struct.sv* @Perl_newSVpvn_share(i8* %23, i32 %conv16, i32 0)
  store %struct.sv* %call17, %struct.sv** %sv, align 8
  br label %if.end

if.else:                                          ; preds = %lor.lhs.false.8
  %28 = load %struct.op*, %struct.op** %kid, align 8
  %29 = bitcast %struct.op* %28 to %struct.svop*
  %op_sv18 = getelementptr inbounds %struct.svop, %struct.svop* %29, i32 0, i32 8
  store %struct.sv* null, %struct.sv** %op_sv18, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then.12
  %30 = load %struct.sv*, %struct.sv** %sv, align 8
  %call19 = call %struct.op* @Perl_newSVOP(i32 350, i32 0, %struct.sv* %30)
  store %struct.op* %call19, %struct.op** %cmop, align 8
  %31 = load %struct.op*, %struct.op** %o.addr, align 8
  call void @Perl_op_free(%struct.op* %31)
  %32 = load %struct.op*, %struct.op** %cmop, align 8
  store %struct.op* %32, %struct.op** %retval
  br label %return

if.end.20:                                        ; preds = %lor.lhs.false, %if.then
  br label %if.end.21

if.end.21:                                        ; preds = %if.end.20, %entry
  %33 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %33, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.21, %if.end
  %34 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %34
}

declare %struct.sv* @Perl_newSVpvn_share(i8*, i32, i32) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_null(%struct.op* %o) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  ret %struct.op* %0
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_open(%struct.op* %o) #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %o.addr = alloca %struct.op*, align 8
  %table = alloca %struct.hv*, align 8
  %svp = alloca %struct.sv**, align 8
  %mode = alloca i32, align 4
  %first = alloca %struct.op*, align 8
  %last = alloca %struct.op*, align 8
  %oa = alloca %struct.op*, align 8
  %mode46 = alloca i8*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.gv*, %struct.gv** @PL_hintgv, align 8
  %sv_any = getelementptr inbounds %struct.gv, %struct.gv* %0, i32 0, i32 0
  %1 = load %struct.xpvgv*, %struct.xpvgv** %sv_any, align 8
  %xgv_gp = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %1, i32 0, i32 7
  %2 = load %struct.gp*, %struct.gp** %xgv_gp, align 8
  %gp_hv = getelementptr inbounds %struct.gp, %struct.gp* %2, i32 0, i32 5
  %3 = load %struct.hv*, %struct.hv** %gp_hv, align 8
  store %struct.hv* %3, %struct.hv** %table, align 8
  %4 = load %struct.hv*, %struct.hv** %table, align 8
  %tobool = icmp ne %struct.hv* %4, null
  br i1 %tobool, label %if.then, label %if.end.41

if.then:                                          ; preds = %entry
  %5 = load %struct.hv*, %struct.hv** %table, align 8
  %call = call %struct.sv** @Perl_hv_fetch(%struct.hv* %5, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.117, i32 0, i32 0), i32 7, i32 0)
  store %struct.sv** %call, %struct.sv*** %svp, align 8
  %6 = load %struct.sv**, %struct.sv*** %svp, align 8
  %tobool1 = icmp ne %struct.sv** %6, null
  br i1 %tobool1, label %land.lhs.true, label %if.end.16

land.lhs.true:                                    ; preds = %if.then
  %7 = load %struct.sv**, %struct.sv*** %svp, align 8
  %8 = load %struct.sv*, %struct.sv** %7, align 8
  %tobool2 = icmp ne %struct.sv* %8, null
  br i1 %tobool2, label %if.then.3, label %if.end.16

if.then.3:                                        ; preds = %land.lhs.true
  %9 = load %struct.sv**, %struct.sv*** %svp, align 8
  %10 = load %struct.sv*, %struct.sv** %9, align 8
  %call4 = call i32 @Perl_mode_from_discipline(%struct.sv* %10)
  store i32 %call4, i32* %mode, align 4
  %11 = load i32, i32* %mode, align 4
  %and = and i32 %11, 0
  %tobool5 = icmp ne i32 %and, 0
  br i1 %tobool5, label %if.then.6, label %if.else

if.then.6:                                        ; preds = %if.then.3
  %12 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %12, i32 0, i32 7
  %13 = load i8, i8* %op_private, align 1
  %conv = zext i8 %13 to i32
  %or = or i32 %conv, 16
  %conv7 = trunc i32 %or to i8
  store i8 %conv7, i8* %op_private, align 1
  br label %if.end.15

if.else:                                          ; preds = %if.then.3
  %14 = load i32, i32* %mode, align 4
  %and8 = and i32 %14, 0
  %tobool9 = icmp ne i32 %and8, 0
  br i1 %tobool9, label %if.then.10, label %if.end

if.then.10:                                       ; preds = %if.else
  %15 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private11 = getelementptr inbounds %struct.op, %struct.op* %15, i32 0, i32 7
  %16 = load i8, i8* %op_private11, align 1
  %conv12 = zext i8 %16 to i32
  %or13 = or i32 %conv12, 32
  %conv14 = trunc i32 %or13 to i8
  store i8 %conv14, i8* %op_private11, align 1
  br label %if.end

if.end:                                           ; preds = %if.then.10, %if.else
  br label %if.end.15

if.end.15:                                        ; preds = %if.end, %if.then.6
  br label %if.end.16

if.end.16:                                        ; preds = %if.end.15, %land.lhs.true, %if.then
  %17 = load %struct.hv*, %struct.hv** %table, align 8
  %call17 = call %struct.sv** @Perl_hv_fetch(%struct.hv* %17, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.118, i32 0, i32 0), i32 8, i32 0)
  store %struct.sv** %call17, %struct.sv*** %svp, align 8
  %18 = load %struct.sv**, %struct.sv*** %svp, align 8
  %tobool18 = icmp ne %struct.sv** %18, null
  br i1 %tobool18, label %land.lhs.true.19, label %if.end.40

land.lhs.true.19:                                 ; preds = %if.end.16
  %19 = load %struct.sv**, %struct.sv*** %svp, align 8
  %20 = load %struct.sv*, %struct.sv** %19, align 8
  %tobool20 = icmp ne %struct.sv* %20, null
  br i1 %tobool20, label %if.then.21, label %if.end.40

if.then.21:                                       ; preds = %land.lhs.true.19
  %21 = load %struct.sv**, %struct.sv*** %svp, align 8
  %22 = load %struct.sv*, %struct.sv** %21, align 8
  %call22 = call i32 @Perl_mode_from_discipline(%struct.sv* %22)
  store i32 %call22, i32* %mode, align 4
  %23 = load i32, i32* %mode, align 4
  %and23 = and i32 %23, 0
  %tobool24 = icmp ne i32 %and23, 0
  br i1 %tobool24, label %if.then.25, label %if.else.30

if.then.25:                                       ; preds = %if.then.21
  %24 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private26 = getelementptr inbounds %struct.op, %struct.op* %24, i32 0, i32 7
  %25 = load i8, i8* %op_private26, align 1
  %conv27 = zext i8 %25 to i32
  %or28 = or i32 %conv27, 64
  %conv29 = trunc i32 %or28 to i8
  store i8 %conv29, i8* %op_private26, align 1
  br label %if.end.39

if.else.30:                                       ; preds = %if.then.21
  %26 = load i32, i32* %mode, align 4
  %and31 = and i32 %26, 0
  %tobool32 = icmp ne i32 %and31, 0
  br i1 %tobool32, label %if.then.33, label %if.end.38

if.then.33:                                       ; preds = %if.else.30
  %27 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private34 = getelementptr inbounds %struct.op, %struct.op* %27, i32 0, i32 7
  %28 = load i8, i8* %op_private34, align 1
  %conv35 = zext i8 %28 to i32
  %or36 = or i32 %conv35, 128
  %conv37 = trunc i32 %or36 to i8
  store i8 %conv37, i8* %op_private34, align 1
  br label %if.end.38

if.end.38:                                        ; preds = %if.then.33, %if.else.30
  br label %if.end.39

if.end.39:                                        ; preds = %if.end.38, %if.then.25
  br label %if.end.40

if.end.40:                                        ; preds = %if.end.39, %land.lhs.true.19, %if.end.16
  br label %if.end.41

if.end.41:                                        ; preds = %if.end.40, %entry
  %29 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %29, i32 0, i32 4
  %30 = load i16, i16* %op_type, align 2
  %conv42 = zext i16 %30 to i32
  %cmp = icmp eq i32 %conv42, 24
  br i1 %cmp, label %if.then.44, label %if.end.45

if.then.44:                                       ; preds = %if.end.41
  %31 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %31, %struct.op** %retval
  br label %return

if.end.45:                                        ; preds = %if.end.41
  %32 = load %struct.op*, %struct.op** %o.addr, align 8
  %33 = bitcast %struct.op* %32 to %struct.listop*
  %op_first = getelementptr inbounds %struct.listop, %struct.listop* %33, i32 0, i32 8
  %34 = load %struct.op*, %struct.op** %op_first, align 8
  store %struct.op* %34, %struct.op** %first, align 8
  %35 = load %struct.op*, %struct.op** %o.addr, align 8
  %36 = bitcast %struct.op* %35 to %struct.listop*
  %op_last = getelementptr inbounds %struct.listop, %struct.listop* %36, i32 0, i32 9
  %37 = load %struct.op*, %struct.op** %op_last, align 8
  store %struct.op* %37, %struct.op** %last, align 8
  %38 = load %struct.op*, %struct.op** %last, align 8
  %op_type47 = getelementptr inbounds %struct.op, %struct.op* %38, i32 0, i32 4
  %39 = load i16, i16* %op_type47, align 2
  %conv48 = zext i16 %39 to i32
  %cmp49 = icmp eq i32 %conv48, 5
  br i1 %cmp49, label %land.lhs.true.51, label %if.end.91

land.lhs.true.51:                                 ; preds = %if.end.45
  %40 = load %struct.op*, %struct.op** %last, align 8
  %op_private52 = getelementptr inbounds %struct.op, %struct.op* %40, i32 0, i32 7
  %41 = load i8, i8* %op_private52, align 1
  %conv53 = zext i8 %41 to i32
  %and54 = and i32 %conv53, 64
  %tobool55 = icmp ne i32 %and54, 0
  br i1 %tobool55, label %land.lhs.true.56, label %if.end.91

land.lhs.true.56:                                 ; preds = %land.lhs.true.51
  %42 = load %struct.op*, %struct.op** %last, align 8
  %op_private57 = getelementptr inbounds %struct.op, %struct.op* %42, i32 0, i32 7
  %43 = load i8, i8* %op_private57, align 1
  %conv58 = zext i8 %43 to i32
  %and59 = and i32 %conv58, 8
  %tobool60 = icmp ne i32 %and59, 0
  br i1 %tobool60, label %land.lhs.true.61, label %if.end.91

land.lhs.true.61:                                 ; preds = %land.lhs.true.56
  %44 = load %struct.op*, %struct.op** %first, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %44, i32 0, i32 1
  %45 = load %struct.op*, %struct.op** %op_sibling, align 8
  store %struct.op* %45, %struct.op** %oa, align 8
  %tobool62 = icmp ne %struct.op* %45, null
  br i1 %tobool62, label %land.lhs.true.63, label %if.end.91

land.lhs.true.63:                                 ; preds = %land.lhs.true.61
  %46 = load %struct.op*, %struct.op** %oa, align 8
  %op_sibling64 = getelementptr inbounds %struct.op, %struct.op* %46, i32 0, i32 1
  %47 = load %struct.op*, %struct.op** %op_sibling64, align 8
  store %struct.op* %47, %struct.op** %oa, align 8
  %tobool65 = icmp ne %struct.op* %47, null
  br i1 %tobool65, label %land.lhs.true.66, label %if.end.91

land.lhs.true.66:                                 ; preds = %land.lhs.true.63
  %48 = load %struct.op*, %struct.op** %oa, align 8
  %49 = bitcast %struct.op* %48 to %struct.svop*
  %op_sv = getelementptr inbounds %struct.svop, %struct.svop* %49, i32 0, i32 8
  %50 = load %struct.sv*, %struct.sv** %op_sv, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %50, i32 0, i32 2
  %51 = load i32, i32* %sv_flags, align 4
  %and67 = and i32 %51, 262144
  %tobool68 = icmp ne i32 %and67, 0
  br i1 %tobool68, label %land.lhs.true.69, label %if.end.91

land.lhs.true.69:                                 ; preds = %land.lhs.true.66
  %52 = load %struct.op*, %struct.op** %oa, align 8
  %53 = bitcast %struct.op* %52 to %struct.svop*
  %op_sv70 = getelementptr inbounds %struct.svop, %struct.svop* %53, i32 0, i32 8
  %54 = load %struct.sv*, %struct.sv** %op_sv70, align 8
  %sv_any71 = getelementptr inbounds %struct.sv, %struct.sv* %54, i32 0, i32 0
  %55 = load i8*, i8** %sv_any71, align 8
  %56 = bitcast i8* %55 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %56, i32 0, i32 0
  %57 = load i8*, i8** %xpv_pv, align 8
  store i8* %57, i8** %mode46, align 8
  %tobool72 = icmp ne i8* %57, null
  br i1 %tobool72, label %land.lhs.true.73, label %if.end.91

land.lhs.true.73:                                 ; preds = %land.lhs.true.69
  %58 = load i8*, i8** %mode46, align 8
  %arrayidx = getelementptr inbounds i8, i8* %58, i64 0
  %59 = load i8, i8* %arrayidx, align 1
  %conv74 = sext i8 %59 to i32
  %cmp75 = icmp eq i32 %conv74, 62
  br i1 %cmp75, label %land.lhs.true.77, label %if.end.91

land.lhs.true.77:                                 ; preds = %land.lhs.true.73
  %60 = load i8*, i8** %mode46, align 8
  %arrayidx78 = getelementptr inbounds i8, i8* %60, i64 1
  %61 = load i8, i8* %arrayidx78, align 1
  %conv79 = sext i8 %61 to i32
  %cmp80 = icmp eq i32 %conv79, 38
  br i1 %cmp80, label %land.lhs.true.82, label %if.end.91

land.lhs.true.82:                                 ; preds = %land.lhs.true.77
  %62 = load %struct.op*, %struct.op** %last, align 8
  %63 = load %struct.op*, %struct.op** %oa, align 8
  %op_sibling83 = getelementptr inbounds %struct.op, %struct.op* %63, i32 0, i32 1
  %64 = load %struct.op*, %struct.op** %op_sibling83, align 8
  %cmp84 = icmp eq %struct.op* %62, %64
  br i1 %cmp84, label %if.then.86, label %if.end.91

if.then.86:                                       ; preds = %land.lhs.true.82
  %65 = load %struct.op*, %struct.op** %last, align 8
  %op_private87 = getelementptr inbounds %struct.op, %struct.op* %65, i32 0, i32 7
  %66 = load i8, i8* %op_private87, align 1
  %conv88 = zext i8 %66 to i32
  %and89 = and i32 %conv88, -9
  %conv90 = trunc i32 %and89 to i8
  store i8 %conv90, i8* %op_private87, align 1
  br label %if.end.91

if.end.91:                                        ; preds = %if.then.86, %land.lhs.true.82, %land.lhs.true.77, %land.lhs.true.73, %land.lhs.true.69, %land.lhs.true.66, %land.lhs.true.63, %land.lhs.true.61, %land.lhs.true.56, %land.lhs.true.51, %if.end.45
  %67 = load %struct.op*, %struct.op** %o.addr, align 8
  %call92 = call %struct.op* @Perl_ck_fun(%struct.op* %67)
  store %struct.op* %call92, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.91, %if.then.44
  %68 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %68
}

declare %struct.sv** @Perl_hv_fetch(%struct.hv*, i8*, i32, i32) #1

declare i32 @Perl_mode_from_discipline(%struct.sv*) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_repeat(%struct.op* %o) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %1 = bitcast %struct.op* %0 to %struct.binop*
  %op_first = getelementptr inbounds %struct.binop, %struct.binop* %1, i32 0, i32 8
  %2 = load %struct.op*, %struct.op** %op_first, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %2, i32 0, i32 6
  %3 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %3 to i32
  %and = and i32 %conv, 8
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %4 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %4, i32 0, i32 7
  %5 = load i8, i8* %op_private, align 1
  %conv1 = zext i8 %5 to i32
  %or = or i32 %conv1, 64
  %conv2 = trunc i32 %or to i8
  store i8 %conv2, i8* %op_private, align 1
  %6 = load %struct.op*, %struct.op** %o.addr, align 8
  %7 = bitcast %struct.op* %6 to %struct.binop*
  %op_first3 = getelementptr inbounds %struct.binop, %struct.binop* %7, i32 0, i32 8
  %8 = load %struct.op*, %struct.op** %op_first3, align 8
  %call = call %struct.op* @Perl_force_list(%struct.op* %8)
  %9 = load %struct.op*, %struct.op** %o.addr, align 8
  %10 = bitcast %struct.op* %9 to %struct.binop*
  %op_first4 = getelementptr inbounds %struct.binop, %struct.binop* %10, i32 0, i32 8
  store %struct.op* %call, %struct.op** %op_first4, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %11 = load %struct.op*, %struct.op** %o.addr, align 8
  %call5 = call %struct.op* @Perl_scalar(%struct.op* %11)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %12 = load %struct.op*, %struct.op** %o.addr, align 8
  ret %struct.op* %12
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_require(%struct.op* %o) #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %o.addr = alloca %struct.op*, align 8
  %gv = alloca %struct.gv*, align 8
  %kid = alloca %struct.svop*, align 8
  %s = alloca i8*, align 8
  %kid69 = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %0, i32 0, i32 6
  %1 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %1 to i32
  %and = and i32 %conv, 4
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end.33

if.then:                                          ; preds = %entry
  %2 = load %struct.op*, %struct.op** %o.addr, align 8
  %3 = bitcast %struct.op* %2 to %struct.unop*
  %op_first = getelementptr inbounds %struct.unop, %struct.unop* %3, i32 0, i32 8
  %4 = load %struct.op*, %struct.op** %op_first, align 8
  %5 = bitcast %struct.op* %4 to %struct.svop*
  store %struct.svop* %5, %struct.svop** %kid, align 8
  %6 = load %struct.svop*, %struct.svop** %kid, align 8
  %op_type = getelementptr inbounds %struct.svop, %struct.svop* %6, i32 0, i32 4
  %7 = load i16, i16* %op_type, align 2
  %conv1 = zext i16 %7 to i32
  %cmp = icmp eq i32 %conv1, 5
  br i1 %cmp, label %land.lhs.true, label %if.end.32

land.lhs.true:                                    ; preds = %if.then
  %8 = load %struct.svop*, %struct.svop** %kid, align 8
  %op_private = getelementptr inbounds %struct.svop, %struct.svop* %8, i32 0, i32 7
  %9 = load i8, i8* %op_private, align 1
  %conv3 = zext i8 %9 to i32
  %and4 = and i32 %conv3, 64
  %tobool5 = icmp ne i32 %and4, 0
  br i1 %tobool5, label %if.then.6, label %if.end.32

if.then.6:                                        ; preds = %land.lhs.true
  %10 = load %struct.svop*, %struct.svop** %kid, align 8
  %op_sv = getelementptr inbounds %struct.svop, %struct.svop* %10, i32 0, i32 8
  %11 = load %struct.sv*, %struct.sv** %op_sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %11, i32 0, i32 0
  %12 = load i8*, i8** %sv_any, align 8
  %13 = bitcast i8* %12 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %13, i32 0, i32 0
  %14 = load i8*, i8** %xpv_pv, align 8
  store i8* %14, i8** %s, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then.6
  %15 = load i8*, i8** %s, align 8
  %16 = load i8, i8* %15, align 1
  %tobool7 = icmp ne i8 %16, 0
  br i1 %tobool7, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %17 = load i8*, i8** %s, align 8
  %18 = load i8, i8* %17, align 1
  %conv8 = sext i8 %18 to i32
  %cmp9 = icmp eq i32 %conv8, 58
  br i1 %cmp9, label %land.lhs.true.11, label %if.end

land.lhs.true.11:                                 ; preds = %for.body
  %19 = load i8*, i8** %s, align 8
  %arrayidx = getelementptr inbounds i8, i8* %19, i64 1
  %20 = load i8, i8* %arrayidx, align 1
  %conv12 = sext i8 %20 to i32
  %cmp13 = icmp eq i32 %conv12, 58
  br i1 %cmp13, label %if.then.15, label %if.end

if.then.15:                                       ; preds = %land.lhs.true.11
  %21 = load i8*, i8** %s, align 8
  store i8 47, i8* %21, align 1
  %22 = load i8*, i8** %s, align 8
  %add.ptr = getelementptr inbounds i8, i8* %22, i64 1
  %23 = load i8*, i8** %s, align 8
  %add.ptr16 = getelementptr inbounds i8, i8* %23, i64 2
  %24 = load i8*, i8** %s, align 8
  %add.ptr17 = getelementptr inbounds i8, i8* %24, i64 2
  %call = call i64 @strlen(i8* %add.ptr17)
  %add = add i64 %call, 1
  %mul = mul i64 %add, 1
  call void @llvm.memmove.p0i8.p0i8.i64(i8* %add.ptr, i8* %add.ptr16, i64 %mul, i32 1, i1 false)
  %25 = load %struct.svop*, %struct.svop** %kid, align 8
  %op_sv18 = getelementptr inbounds %struct.svop, %struct.svop* %25, i32 0, i32 8
  %26 = load %struct.sv*, %struct.sv** %op_sv18, align 8
  %sv_any19 = getelementptr inbounds %struct.sv, %struct.sv* %26, i32 0, i32 0
  %27 = load i8*, i8** %sv_any19, align 8
  %28 = bitcast i8* %27 to %struct.xpv*
  %xpv_cur = getelementptr inbounds %struct.xpv, %struct.xpv* %28, i32 0, i32 1
  %29 = load i64, i64* %xpv_cur, align 8
  %dec = add i64 %29, -1
  store i64 %dec, i64* %xpv_cur, align 8
  br label %if.end

if.end:                                           ; preds = %if.then.15, %land.lhs.true.11, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %30 = load i8*, i8** %s, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %30, i32 1
  store i8* %incdec.ptr, i8** %s, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %31 = load %struct.svop*, %struct.svop** %kid, align 8
  %op_sv20 = getelementptr inbounds %struct.svop, %struct.svop* %31, i32 0, i32 8
  %32 = load %struct.sv*, %struct.sv** %op_sv20, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %32, i32 0, i32 2
  %33 = load i32, i32* %sv_flags, align 4
  %and21 = and i32 %33, 8388608
  %tobool22 = icmp ne i32 %and21, 0
  br i1 %tobool22, label %if.then.23, label %if.else

if.then.23:                                       ; preds = %for.end
  %34 = load %struct.svop*, %struct.svop** %kid, align 8
  %op_sv24 = getelementptr inbounds %struct.svop, %struct.svop* %34, i32 0, i32 8
  %35 = load %struct.sv*, %struct.sv** %op_sv24, align 8
  %sv_flags25 = getelementptr inbounds %struct.sv, %struct.sv* %35, i32 0, i32 2
  %36 = load i32, i32* %sv_flags25, align 4
  %and26 = and i32 %36, -8388609
  store i32 %and26, i32* %sv_flags25, align 4
  %37 = load %struct.svop*, %struct.svop** %kid, align 8
  %op_sv27 = getelementptr inbounds %struct.svop, %struct.svop* %37, i32 0, i32 8
  %38 = load %struct.sv*, %struct.sv** %op_sv27, align 8
  call void @Perl_sv_catpvn_flags(%struct.sv* %38, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.119, i32 0, i32 0), i64 3, i32 2)
  %39 = load %struct.svop*, %struct.svop** %kid, align 8
  %op_sv28 = getelementptr inbounds %struct.svop, %struct.svop* %39, i32 0, i32 8
  %40 = load %struct.sv*, %struct.sv** %op_sv28, align 8
  %sv_flags29 = getelementptr inbounds %struct.sv, %struct.sv* %40, i32 0, i32 2
  %41 = load i32, i32* %sv_flags29, align 4
  %or = or i32 %41, 8388608
  store i32 %or, i32* %sv_flags29, align 4
  br label %if.end.31

if.else:                                          ; preds = %for.end
  %42 = load %struct.svop*, %struct.svop** %kid, align 8
  %op_sv30 = getelementptr inbounds %struct.svop, %struct.svop* %42, i32 0, i32 8
  %43 = load %struct.sv*, %struct.sv** %op_sv30, align 8
  call void @Perl_sv_catpvn_flags(%struct.sv* %43, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.119, i32 0, i32 0), i64 3, i32 2)
  br label %if.end.31

if.end.31:                                        ; preds = %if.else, %if.then.23
  br label %if.end.32

if.end.32:                                        ; preds = %if.end.31, %land.lhs.true, %if.then
  br label %if.end.33

if.end.33:                                        ; preds = %if.end.32, %entry
  %call34 = call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.120, i32 0, i32 0), i32 0, i32 12)
  store %struct.gv* %call34, %struct.gv** %gv, align 8
  %44 = load %struct.gv*, %struct.gv** %gv, align 8
  %tobool35 = icmp ne %struct.gv* %44, null
  br i1 %tobool35, label %land.lhs.true.36, label %if.then.47

land.lhs.true.36:                                 ; preds = %if.end.33
  %45 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any37 = getelementptr inbounds %struct.gv, %struct.gv* %45, i32 0, i32 0
  %46 = load %struct.xpvgv*, %struct.xpvgv** %sv_any37, align 8
  %xgv_gp = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %46, i32 0, i32 7
  %47 = load %struct.gp*, %struct.gp** %xgv_gp, align 8
  %gp_cvgen = getelementptr inbounds %struct.gp, %struct.gp* %47, i32 0, i32 8
  %48 = load i32, i32* %gp_cvgen, align 4
  %tobool38 = icmp ne i32 %48, 0
  br i1 %tobool38, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true.36
  br i1 false, label %land.lhs.true.42, label %if.then.47

cond.false:                                       ; preds = %land.lhs.true.36
  %49 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any39 = getelementptr inbounds %struct.gv, %struct.gv* %49, i32 0, i32 0
  %50 = load %struct.xpvgv*, %struct.xpvgv** %sv_any39, align 8
  %xgv_gp40 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %50, i32 0, i32 7
  %51 = load %struct.gp*, %struct.gp** %xgv_gp40, align 8
  %gp_cv = getelementptr inbounds %struct.gp, %struct.gp* %51, i32 0, i32 7
  %52 = load %struct.cv*, %struct.cv** %gp_cv, align 8
  %tobool41 = icmp ne %struct.cv* %52, null
  br i1 %tobool41, label %land.lhs.true.42, label %if.then.47

land.lhs.true.42:                                 ; preds = %cond.false, %cond.true
  %53 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any43 = getelementptr inbounds %struct.gv, %struct.gv* %53, i32 0, i32 0
  %54 = load %struct.xpvgv*, %struct.xpvgv** %sv_any43, align 8
  %xgv_flags = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %54, i32 0, i32 11
  %55 = load i8, i8* %xgv_flags, align 1
  %conv44 = zext i8 %55 to i32
  %and45 = and i32 %conv44, 128
  %tobool46 = icmp ne i32 %and45, 0
  br i1 %tobool46, label %if.end.49, label %if.then.47

if.then.47:                                       ; preds = %land.lhs.true.42, %cond.false, %cond.true, %if.end.33
  %call48 = call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.121, i32 0, i32 0), i32 0, i32 12)
  store %struct.gv* %call48, %struct.gv** %gv, align 8
  br label %if.end.49

if.end.49:                                        ; preds = %if.then.47, %land.lhs.true.42
  %56 = load %struct.gv*, %struct.gv** %gv, align 8
  %tobool50 = icmp ne %struct.gv* %56, null
  br i1 %tobool50, label %land.lhs.true.51, label %if.end.78

land.lhs.true.51:                                 ; preds = %if.end.49
  %57 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any52 = getelementptr inbounds %struct.gv, %struct.gv* %57, i32 0, i32 0
  %58 = load %struct.xpvgv*, %struct.xpvgv** %sv_any52, align 8
  %xgv_gp53 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %58, i32 0, i32 7
  %59 = load %struct.gp*, %struct.gp** %xgv_gp53, align 8
  %gp_cvgen54 = getelementptr inbounds %struct.gp, %struct.gp* %59, i32 0, i32 8
  %60 = load i32, i32* %gp_cvgen54, align 4
  %tobool55 = icmp ne i32 %60, 0
  br i1 %tobool55, label %cond.true.56, label %cond.false.57

cond.true.56:                                     ; preds = %land.lhs.true.51
  br i1 false, label %land.lhs.true.62, label %if.end.78

cond.false.57:                                    ; preds = %land.lhs.true.51
  %61 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any58 = getelementptr inbounds %struct.gv, %struct.gv* %61, i32 0, i32 0
  %62 = load %struct.xpvgv*, %struct.xpvgv** %sv_any58, align 8
  %xgv_gp59 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %62, i32 0, i32 7
  %63 = load %struct.gp*, %struct.gp** %xgv_gp59, align 8
  %gp_cv60 = getelementptr inbounds %struct.gp, %struct.gp* %63, i32 0, i32 7
  %64 = load %struct.cv*, %struct.cv** %gp_cv60, align 8
  %tobool61 = icmp ne %struct.cv* %64, null
  br i1 %tobool61, label %land.lhs.true.62, label %if.end.78

land.lhs.true.62:                                 ; preds = %cond.false.57, %cond.true.56
  %65 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any63 = getelementptr inbounds %struct.gv, %struct.gv* %65, i32 0, i32 0
  %66 = load %struct.xpvgv*, %struct.xpvgv** %sv_any63, align 8
  %xgv_flags64 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %66, i32 0, i32 11
  %67 = load i8, i8* %xgv_flags64, align 1
  %conv65 = zext i8 %67 to i32
  %and66 = and i32 %conv65, 128
  %tobool67 = icmp ne i32 %and66, 0
  br i1 %tobool67, label %if.then.68, label %if.end.78

if.then.68:                                       ; preds = %land.lhs.true.62
  %68 = load %struct.op*, %struct.op** %o.addr, align 8
  %69 = bitcast %struct.op* %68 to %struct.unop*
  %op_first70 = getelementptr inbounds %struct.unop, %struct.unop* %69, i32 0, i32 8
  %70 = load %struct.op*, %struct.op** %op_first70, align 8
  store %struct.op* %70, %struct.op** %kid69, align 8
  %71 = load %struct.op*, %struct.op** %o.addr, align 8
  %72 = bitcast %struct.op* %71 to %struct.unop*
  %op_first71 = getelementptr inbounds %struct.unop, %struct.unop* %72, i32 0, i32 8
  store %struct.op* null, %struct.op** %op_first71, align 8
  %73 = load %struct.op*, %struct.op** %o.addr, align 8
  call void @Perl_op_free(%struct.op* %73)
  %74 = load %struct.op*, %struct.op** %kid69, align 8
  %75 = load %struct.gv*, %struct.gv** %gv, align 8
  %call72 = call %struct.op* @Perl_newGVOP(i32 7, i32 0, %struct.gv* %75)
  %call73 = call %struct.op* @Perl_newUNOP(i32 17, i32 0, %struct.op* %call72)
  %call74 = call %struct.op* @Perl_scalar(%struct.op* %call73)
  %call75 = call %struct.op* @Perl_append_elem(i32 141, %struct.op* %74, %struct.op* %call74)
  %call76 = call %struct.op* @Perl_newUNOP(i32 166, i32 64, %struct.op* %call75)
  %call77 = call %struct.op* @Perl_ck_subr(%struct.op* %call76)
  store %struct.op* %call77, %struct.op** %retval
  br label %return

if.end.78:                                        ; preds = %land.lhs.true.62, %cond.false.57, %cond.true.56, %if.end.49
  %76 = load %struct.op*, %struct.op** %o.addr, align 8
  %call79 = call %struct.op* @Perl_ck_fun(%struct.op* %76)
  store %struct.op* %call79, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.78, %if.then.68
  %77 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %77
}

; Function Attrs: nounwind
declare void @llvm.memmove.p0i8.p0i8.i64(i8* nocapture, i8* nocapture readonly, i64, i32, i1) #2

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_return(%struct.op* %o) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  %kid = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.cv*, %struct.cv** @PL_compcv, align 8
  %sv_any = getelementptr inbounds %struct.cv, %struct.cv* %0, i32 0, i32 0
  %1 = load %struct.xpvcv*, %struct.xpvcv** %sv_any, align 8
  %xcv_flags = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %1, i32 0, i32 17
  %2 = load i16, i16* %xcv_flags, align 2
  %conv = zext i16 %2 to i32
  %and = and i32 %conv, 256
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load %struct.op*, %struct.op** %o.addr, align 8
  %4 = bitcast %struct.op* %3 to %struct.listop*
  %op_first = getelementptr inbounds %struct.listop, %struct.listop* %4, i32 0, i32 8
  %5 = load %struct.op*, %struct.op** %op_first, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %5, i32 0, i32 1
  %6 = load %struct.op*, %struct.op** %op_sibling, align 8
  store %struct.op* %6, %struct.op** %kid, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %7 = load %struct.op*, %struct.op** %kid, align 8
  %tobool1 = icmp ne %struct.op* %7, null
  br i1 %tobool1, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load %struct.op*, %struct.op** %kid, align 8
  %call = call %struct.op* @Perl_mod(%struct.op* %8, i32 168)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %9 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling2 = getelementptr inbounds %struct.op, %struct.op* %9, i32 0, i32 1
  %10 = load %struct.op*, %struct.op** %op_sibling2, align 8
  store %struct.op* %10, %struct.op** %kid, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end

if.end:                                           ; preds = %for.end, %entry
  %11 = load %struct.op*, %struct.op** %o.addr, align 8
  ret %struct.op* %11
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_select(%struct.op* %o) #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %o.addr = alloca %struct.op*, align 8
  %kid = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %0, i32 0, i32 6
  %1 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %1 to i32
  %and = and i32 %conv, 4
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end.6

if.then:                                          ; preds = %entry
  %2 = load %struct.op*, %struct.op** %o.addr, align 8
  %3 = bitcast %struct.op* %2 to %struct.listop*
  %op_first = getelementptr inbounds %struct.listop, %struct.listop* %3, i32 0, i32 8
  %4 = load %struct.op*, %struct.op** %op_first, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %4, i32 0, i32 1
  %5 = load %struct.op*, %struct.op** %op_sibling, align 8
  store %struct.op* %5, %struct.op** %kid, align 8
  %6 = load %struct.op*, %struct.op** %kid, align 8
  %tobool1 = icmp ne %struct.op* %6, null
  br i1 %tobool1, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then
  %7 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling2 = getelementptr inbounds %struct.op, %struct.op* %7, i32 0, i32 1
  %8 = load %struct.op*, %struct.op** %op_sibling2, align 8
  %tobool3 = icmp ne %struct.op* %8, null
  br i1 %tobool3, label %if.then.4, label %if.end

if.then.4:                                        ; preds = %land.lhs.true
  %9 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %9, i32 0, i32 4
  store i16 202, i16* %op_type, align 2
  %10 = load %struct.op* ()*, %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 202), align 8
  %11 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_ppaddr = getelementptr inbounds %struct.op, %struct.op* %11, i32 0, i32 2
  store %struct.op* ()* %10, %struct.op* ()** %op_ppaddr, align 8
  %12 = load %struct.op*, %struct.op** %o.addr, align 8
  %call = call %struct.op* @Perl_ck_fun(%struct.op* %12)
  store %struct.op* %call, %struct.op** %o.addr, align 8
  %13 = load %struct.op*, %struct.op** %o.addr, align 8
  %call5 = call %struct.op* @Perl_fold_constants(%struct.op* %13)
  store %struct.op* %call5, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %land.lhs.true, %if.then
  br label %if.end.6

if.end.6:                                         ; preds = %if.end, %entry
  %14 = load %struct.op*, %struct.op** %o.addr, align 8
  %call7 = call %struct.op* @Perl_ck_fun(%struct.op* %14)
  store %struct.op* %call7, %struct.op** %o.addr, align 8
  %15 = load %struct.op*, %struct.op** %o.addr, align 8
  %16 = bitcast %struct.op* %15 to %struct.listop*
  %op_first8 = getelementptr inbounds %struct.listop, %struct.listop* %16, i32 0, i32 8
  %17 = load %struct.op*, %struct.op** %op_first8, align 8
  %op_sibling9 = getelementptr inbounds %struct.op, %struct.op* %17, i32 0, i32 1
  %18 = load %struct.op*, %struct.op** %op_sibling9, align 8
  store %struct.op* %18, %struct.op** %kid, align 8
  %19 = load %struct.op*, %struct.op** %kid, align 8
  %tobool10 = icmp ne %struct.op* %19, null
  br i1 %tobool10, label %land.lhs.true.11, label %if.end.19

land.lhs.true.11:                                 ; preds = %if.end.6
  %20 = load %struct.op*, %struct.op** %kid, align 8
  %op_type12 = getelementptr inbounds %struct.op, %struct.op* %20, i32 0, i32 4
  %21 = load i16, i16* %op_type12, align 2
  %conv13 = zext i16 %21 to i32
  %cmp = icmp eq i32 %conv13, 14
  br i1 %cmp, label %if.then.15, label %if.end.19

if.then.15:                                       ; preds = %land.lhs.true.11
  %22 = load %struct.op*, %struct.op** %kid, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %22, i32 0, i32 7
  %23 = load i8, i8* %op_private, align 1
  %conv16 = zext i8 %23 to i32
  %and17 = and i32 %conv16, -3
  %conv18 = trunc i32 %and17 to i8
  store i8 %conv18, i8* %op_private, align 1
  br label %if.end.19

if.end.19:                                        ; preds = %if.then.15, %land.lhs.true.11, %if.end.6
  %24 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %24, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.19, %if.then.4
  %25 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %25
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_shift(%struct.op* %o) #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %o.addr = alloca %struct.op*, align 8
  %type = alloca i32, align 4
  %argop = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %0, i32 0, i32 4
  %1 = load i16, i16* %op_type, align 2
  %conv = zext i16 %1 to i32
  store i32 %conv, i32* %type, align 4
  %2 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %2, i32 0, i32 6
  %3 = load i8, i8* %op_flags, align 1
  %conv1 = zext i8 %3 to i32
  %and = and i32 %conv1, 4
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %4 = load %struct.op*, %struct.op** %o.addr, align 8
  call void @Perl_op_free(%struct.op* %4)
  %5 = load %struct.cv*, %struct.cv** @PL_compcv, align 8
  %sv_any = getelementptr inbounds %struct.cv, %struct.cv* %5, i32 0, i32 0
  %6 = load %struct.xpvcv*, %struct.xpvcv** %sv_any, align 8
  %xcv_flags = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %6, i32 0, i32 17
  %7 = load i16, i16* %xcv_flags, align 2
  %conv2 = zext i16 %7 to i32
  %and3 = and i32 %conv2, 16
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  %8 = load %struct.gv*, %struct.gv** @PL_argvgv, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then
  %9 = load %struct.gv*, %struct.gv** @PL_defgv, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.gv* [ %8, %cond.true ], [ %9, %cond.false ]
  %call = call %struct.op* @Perl_newGVOP(i32 7, i32 0, %struct.gv* %cond)
  %call5 = call %struct.op* @Perl_scalar(%struct.op* %call)
  %call6 = call %struct.op* @Perl_newUNOP(i32 125, i32 0, %struct.op* %call5)
  store %struct.op* %call6, %struct.op** %argop, align 8
  %10 = load i32, i32* %type, align 4
  %11 = load %struct.op*, %struct.op** %argop, align 8
  %call7 = call %struct.op* @Perl_scalar(%struct.op* %11)
  %call8 = call %struct.op* @Perl_newUNOP(i32 %10, i32 0, %struct.op* %call7)
  store %struct.op* %call8, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %entry
  %12 = load %struct.op*, %struct.op** %o.addr, align 8
  %call9 = call %struct.op* @Perl_ck_fun(%struct.op* %12)
  %13 = load i32, i32* %type, align 4
  %call10 = call %struct.op* @S_modkids(%struct.op* %call9, i32 %13)
  %call11 = call %struct.op* @Perl_scalar(%struct.op* %call10)
  store %struct.op* %call11, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end, %cond.end
  %14 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %14
}

; Function Attrs: nounwind uwtable
define internal void @S_simplify_sort(%struct.op* %o) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  %kid = alloca %struct.op*, align 8
  %k = alloca %struct.op*, align 8
  %descending = alloca i32, align 4
  %gv = alloca %struct.gv*, align 8
  %gvname = alloca i8*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %1 = bitcast %struct.op* %0 to %struct.listop*
  %op_first = getelementptr inbounds %struct.listop, %struct.listop* %1, i32 0, i32 8
  %2 = load %struct.op*, %struct.op** %op_first, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %2, i32 0, i32 1
  %3 = load %struct.op*, %struct.op** %op_sibling, align 8
  store %struct.op* %3, %struct.op** %kid, align 8
  %4 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %4, i32 0, i32 6
  %5 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %5 to i32
  %and = and i32 %conv, 64
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %call = call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.154, i32 0, i32 0), i32 1, i32 4)
  %sv_any = getelementptr inbounds %struct.gv, %struct.gv* %call, i32 0, i32 0
  %6 = load %struct.xpvgv*, %struct.xpvgv** %sv_any, align 8
  %xgv_flags = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %6, i32 0, i32 11
  %7 = load i8, i8* %xgv_flags, align 1
  %conv1 = zext i8 %7 to i32
  %or = or i32 %conv1, 2
  %conv2 = trunc i32 %or to i8
  store i8 %conv2, i8* %xgv_flags, align 1
  %call3 = call %struct.gv* @Perl_gv_fetchpv(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.155, i32 0, i32 0), i32 1, i32 4)
  %sv_any4 = getelementptr inbounds %struct.gv, %struct.gv* %call3, i32 0, i32 0
  %8 = load %struct.xpvgv*, %struct.xpvgv** %sv_any4, align 8
  %xgv_flags5 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %8, i32 0, i32 11
  %9 = load i8, i8* %xgv_flags5, align 1
  %conv6 = zext i8 %9 to i32
  %or7 = or i32 %conv6, 2
  %conv8 = trunc i32 %or7 to i8
  store i8 %conv8, i8* %xgv_flags5, align 1
  %10 = load %struct.op*, %struct.op** %kid, align 8
  %11 = bitcast %struct.op* %10 to %struct.unop*
  %op_first9 = getelementptr inbounds %struct.unop, %struct.unop* %11, i32 0, i32 8
  %12 = load %struct.op*, %struct.op** %op_first9, align 8
  store %struct.op* %12, %struct.op** %kid, align 8
  %13 = load %struct.op*, %struct.op** %kid, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %13, i32 0, i32 4
  %14 = load i16, i16* %op_type, align 2
  %conv10 = zext i16 %14 to i32
  %cmp = icmp ne i32 %conv10, 179
  br i1 %cmp, label %if.then.12, label %if.end.13

if.then.12:                                       ; preds = %if.end
  br label %return

if.end.13:                                        ; preds = %if.end
  %15 = load %struct.op*, %struct.op** %kid, align 8
  %16 = bitcast %struct.op* %15 to %struct.listop*
  %op_last = getelementptr inbounds %struct.listop, %struct.listop* %16, i32 0, i32 9
  %17 = load %struct.op*, %struct.op** %op_last, align 8
  store %struct.op* %17, %struct.op** %kid, align 8
  %18 = load %struct.op*, %struct.op** %kid, align 8
  %op_type14 = getelementptr inbounds %struct.op, %struct.op* %18, i32 0, i32 4
  %19 = load i16, i16* %op_type14, align 2
  %conv15 = zext i16 %19 to i32
  switch i32 %conv15, label %sw.default [
    i32 82, label %sw.bb
    i32 83, label %sw.bb
    i32 90, label %sw.bb
  ]

sw.bb:                                            ; preds = %if.end.13, %if.end.13, %if.end.13
  br label %sw.epilog

sw.default:                                       ; preds = %if.end.13
  br label %return

sw.epilog:                                        ; preds = %sw.bb
  %20 = load %struct.op*, %struct.op** %kid, align 8
  store %struct.op* %20, %struct.op** %k, align 8
  %21 = load %struct.op*, %struct.op** %kid, align 8
  %22 = bitcast %struct.op* %21 to %struct.binop*
  %op_first16 = getelementptr inbounds %struct.binop, %struct.binop* %22, i32 0, i32 8
  %23 = load %struct.op*, %struct.op** %op_first16, align 8
  %op_type17 = getelementptr inbounds %struct.op, %struct.op* %23, i32 0, i32 4
  %24 = load i16, i16* %op_type17, align 2
  %conv18 = zext i16 %24 to i32
  %cmp19 = icmp ne i32 %conv18, 15
  br i1 %cmp19, label %if.then.21, label %if.end.22

if.then.21:                                       ; preds = %sw.epilog
  br label %return

if.end.22:                                        ; preds = %sw.epilog
  %25 = load %struct.op*, %struct.op** %kid, align 8
  %26 = bitcast %struct.op* %25 to %struct.binop*
  %op_first23 = getelementptr inbounds %struct.binop, %struct.binop* %26, i32 0, i32 8
  %27 = load %struct.op*, %struct.op** %op_first23, align 8
  store %struct.op* %27, %struct.op** %kid, align 8
  %28 = load %struct.op*, %struct.op** %kid, align 8
  %29 = bitcast %struct.op* %28 to %struct.unop*
  %op_first24 = getelementptr inbounds %struct.unop, %struct.unop* %29, i32 0, i32 8
  %30 = load %struct.op*, %struct.op** %op_first24, align 8
  %op_type25 = getelementptr inbounds %struct.op, %struct.op* %30, i32 0, i32 4
  %31 = load i16, i16* %op_type25, align 2
  %conv26 = zext i16 %31 to i32
  %cmp27 = icmp ne i32 %conv26, 7
  br i1 %cmp27, label %if.then.29, label %if.end.30

if.then.29:                                       ; preds = %if.end.22
  br label %return

if.end.30:                                        ; preds = %if.end.22
  %32 = load %struct.op*, %struct.op** %kid, align 8
  %33 = bitcast %struct.op* %32 to %struct.unop*
  %op_first31 = getelementptr inbounds %struct.unop, %struct.unop* %33, i32 0, i32 8
  %34 = load %struct.op*, %struct.op** %op_first31, align 8
  store %struct.op* %34, %struct.op** %kid, align 8
  %35 = load %struct.op*, %struct.op** %kid, align 8
  %36 = bitcast %struct.op* %35 to %struct.svop*
  %op_sv = getelementptr inbounds %struct.svop, %struct.svop* %36, i32 0, i32 8
  %37 = load %struct.sv*, %struct.sv** %op_sv, align 8
  %38 = bitcast %struct.sv* %37 to %struct.gv*
  store %struct.gv* %38, %struct.gv** %gv, align 8
  %39 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any32 = getelementptr inbounds %struct.gv, %struct.gv* %39, i32 0, i32 0
  %40 = load %struct.xpvgv*, %struct.xpvgv** %sv_any32, align 8
  %xgv_stash = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %40, i32 0, i32 10
  %41 = load %struct.hv*, %struct.hv** %xgv_stash, align 8
  %42 = load %struct.hv*, %struct.hv** @PL_curstash, align 8
  %cmp33 = icmp ne %struct.hv* %41, %42
  br i1 %cmp33, label %if.then.35, label %if.end.36

if.then.35:                                       ; preds = %if.end.30
  br label %return

if.end.36:                                        ; preds = %if.end.30
  %43 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any37 = getelementptr inbounds %struct.gv, %struct.gv* %43, i32 0, i32 0
  %44 = load %struct.xpvgv*, %struct.xpvgv** %sv_any37, align 8
  %xgv_name = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %44, i32 0, i32 8
  %45 = load i8*, i8** %xgv_name, align 8
  store i8* %45, i8** %gvname, align 8
  %46 = load i8*, i8** %gvname, align 8
  %47 = load i8, i8* %46, align 1
  %conv38 = sext i8 %47 to i32
  %cmp39 = icmp eq i32 %conv38, 97
  br i1 %cmp39, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.end.36
  %48 = load i8*, i8** %gvname, align 8
  %arrayidx = getelementptr inbounds i8, i8* %48, i64 1
  %49 = load i8, i8* %arrayidx, align 1
  %conv41 = sext i8 %49 to i32
  %cmp42 = icmp eq i32 %conv41, 0
  br i1 %cmp42, label %if.then.44, label %if.else

if.then.44:                                       ; preds = %land.lhs.true
  store i32 0, i32* %descending, align 4
  br label %if.end.56

if.else:                                          ; preds = %land.lhs.true, %if.end.36
  %50 = load i8*, i8** %gvname, align 8
  %51 = load i8, i8* %50, align 1
  %conv45 = sext i8 %51 to i32
  %cmp46 = icmp eq i32 %conv45, 98
  br i1 %cmp46, label %land.lhs.true.48, label %if.else.54

land.lhs.true.48:                                 ; preds = %if.else
  %52 = load i8*, i8** %gvname, align 8
  %arrayidx49 = getelementptr inbounds i8, i8* %52, i64 1
  %53 = load i8, i8* %arrayidx49, align 1
  %conv50 = sext i8 %53 to i32
  %cmp51 = icmp eq i32 %conv50, 0
  br i1 %cmp51, label %if.then.53, label %if.else.54

if.then.53:                                       ; preds = %land.lhs.true.48
  store i32 1, i32* %descending, align 4
  br label %if.end.55

if.else.54:                                       ; preds = %land.lhs.true.48, %if.else
  br label %return

if.end.55:                                        ; preds = %if.then.53
  br label %if.end.56

if.end.56:                                        ; preds = %if.end.55, %if.then.44
  %54 = load %struct.op*, %struct.op** %k, align 8
  store %struct.op* %54, %struct.op** %kid, align 8
  %55 = load %struct.op*, %struct.op** %kid, align 8
  %56 = bitcast %struct.op* %55 to %struct.binop*
  %op_last57 = getelementptr inbounds %struct.binop, %struct.binop* %56, i32 0, i32 9
  %57 = load %struct.op*, %struct.op** %op_last57, align 8
  %op_type58 = getelementptr inbounds %struct.op, %struct.op* %57, i32 0, i32 4
  %58 = load i16, i16* %op_type58, align 2
  %conv59 = zext i16 %58 to i32
  %cmp60 = icmp ne i32 %conv59, 15
  br i1 %cmp60, label %if.then.62, label %if.end.63

if.then.62:                                       ; preds = %if.end.56
  br label %return

if.end.63:                                        ; preds = %if.end.56
  %59 = load %struct.op*, %struct.op** %kid, align 8
  %60 = bitcast %struct.op* %59 to %struct.binop*
  %op_last64 = getelementptr inbounds %struct.binop, %struct.binop* %60, i32 0, i32 9
  %61 = load %struct.op*, %struct.op** %op_last64, align 8
  store %struct.op* %61, %struct.op** %kid, align 8
  %62 = load %struct.op*, %struct.op** %kid, align 8
  %63 = bitcast %struct.op* %62 to %struct.unop*
  %op_first65 = getelementptr inbounds %struct.unop, %struct.unop* %63, i32 0, i32 8
  %64 = load %struct.op*, %struct.op** %op_first65, align 8
  %op_type66 = getelementptr inbounds %struct.op, %struct.op* %64, i32 0, i32 4
  %65 = load i16, i16* %op_type66, align 2
  %conv67 = zext i16 %65 to i32
  %cmp68 = icmp ne i32 %conv67, 7
  br i1 %cmp68, label %if.then.70, label %if.end.71

if.then.70:                                       ; preds = %if.end.63
  br label %return

if.end.71:                                        ; preds = %if.end.63
  %66 = load %struct.op*, %struct.op** %kid, align 8
  %67 = bitcast %struct.op* %66 to %struct.unop*
  %op_first72 = getelementptr inbounds %struct.unop, %struct.unop* %67, i32 0, i32 8
  %68 = load %struct.op*, %struct.op** %op_first72, align 8
  store %struct.op* %68, %struct.op** %kid, align 8
  %69 = load %struct.op*, %struct.op** %kid, align 8
  %70 = bitcast %struct.op* %69 to %struct.svop*
  %op_sv73 = getelementptr inbounds %struct.svop, %struct.svop* %70, i32 0, i32 8
  %71 = load %struct.sv*, %struct.sv** %op_sv73, align 8
  %72 = bitcast %struct.sv* %71 to %struct.gv*
  store %struct.gv* %72, %struct.gv** %gv, align 8
  %73 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any74 = getelementptr inbounds %struct.gv, %struct.gv* %73, i32 0, i32 0
  %74 = load %struct.xpvgv*, %struct.xpvgv** %sv_any74, align 8
  %xgv_stash75 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %74, i32 0, i32 10
  %75 = load %struct.hv*, %struct.hv** %xgv_stash75, align 8
  %76 = load %struct.hv*, %struct.hv** @PL_curstash, align 8
  %cmp76 = icmp ne %struct.hv* %75, %76
  br i1 %cmp76, label %if.then.78, label %if.end.79

if.then.78:                                       ; preds = %if.end.71
  br label %return

if.end.79:                                        ; preds = %if.end.71
  %77 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any80 = getelementptr inbounds %struct.gv, %struct.gv* %77, i32 0, i32 0
  %78 = load %struct.xpvgv*, %struct.xpvgv** %sv_any80, align 8
  %xgv_name81 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %78, i32 0, i32 8
  %79 = load i8*, i8** %xgv_name81, align 8
  store i8* %79, i8** %gvname, align 8
  %80 = load i32, i32* %descending, align 4
  %tobool82 = icmp ne i32 %80, 0
  br i1 %tobool82, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.79
  %81 = load i8*, i8** %gvname, align 8
  %82 = load i8, i8* %81, align 1
  %conv83 = sext i8 %82 to i32
  %cmp84 = icmp eq i32 %conv83, 97
  br i1 %cmp84, label %land.lhs.true.86, label %if.then.99

land.lhs.true.86:                                 ; preds = %cond.true
  %83 = load i8*, i8** %gvname, align 8
  %arrayidx87 = getelementptr inbounds i8, i8* %83, i64 1
  %84 = load i8, i8* %arrayidx87, align 1
  %conv88 = sext i8 %84 to i32
  %cmp89 = icmp eq i32 %conv88, 0
  br i1 %cmp89, label %if.end.100, label %if.then.99

cond.false:                                       ; preds = %if.end.79
  %85 = load i8*, i8** %gvname, align 8
  %86 = load i8, i8* %85, align 1
  %conv91 = sext i8 %86 to i32
  %cmp92 = icmp eq i32 %conv91, 98
  br i1 %cmp92, label %land.lhs.true.94, label %if.then.99

land.lhs.true.94:                                 ; preds = %cond.false
  %87 = load i8*, i8** %gvname, align 8
  %arrayidx95 = getelementptr inbounds i8, i8* %87, i64 1
  %88 = load i8, i8* %arrayidx95, align 1
  %conv96 = sext i8 %88 to i32
  %cmp97 = icmp eq i32 %conv96, 0
  br i1 %cmp97, label %if.end.100, label %if.then.99

if.then.99:                                       ; preds = %land.lhs.true.94, %cond.false, %land.lhs.true.86, %cond.true
  br label %return

if.end.100:                                       ; preds = %land.lhs.true.94, %land.lhs.true.86
  %89 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags101 = getelementptr inbounds %struct.op, %struct.op* %89, i32 0, i32 6
  %90 = load i8, i8* %op_flags101, align 1
  %conv102 = zext i8 %90 to i32
  %and103 = and i32 %conv102, -193
  %conv104 = trunc i32 %and103 to i8
  store i8 %conv104, i8* %op_flags101, align 1
  %91 = load i32, i32* %descending, align 4
  %tobool105 = icmp ne i32 %91, 0
  br i1 %tobool105, label %if.then.106, label %if.end.110

if.then.106:                                      ; preds = %if.end.100
  %92 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %92, i32 0, i32 7
  %93 = load i8, i8* %op_private, align 1
  %conv107 = zext i8 %93 to i32
  %or108 = or i32 %conv107, 16
  %conv109 = trunc i32 %or108 to i8
  store i8 %conv109, i8* %op_private, align 1
  br label %if.end.110

if.end.110:                                       ; preds = %if.then.106, %if.end.100
  %94 = load %struct.op*, %struct.op** %k, align 8
  %op_type111 = getelementptr inbounds %struct.op, %struct.op* %94, i32 0, i32 4
  %95 = load i16, i16* %op_type111, align 2
  %conv112 = zext i16 %95 to i32
  %cmp113 = icmp eq i32 %conv112, 82
  br i1 %cmp113, label %if.then.115, label %if.end.120

if.then.115:                                      ; preds = %if.end.110
  %96 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private116 = getelementptr inbounds %struct.op, %struct.op* %96, i32 0, i32 7
  %97 = load i8, i8* %op_private116, align 1
  %conv117 = zext i8 %97 to i32
  %or118 = or i32 %conv117, 1
  %conv119 = trunc i32 %or118 to i8
  store i8 %conv119, i8* %op_private116, align 1
  br label %if.end.120

if.end.120:                                       ; preds = %if.then.115, %if.end.110
  %98 = load %struct.op*, %struct.op** %k, align 8
  %op_type121 = getelementptr inbounds %struct.op, %struct.op* %98, i32 0, i32 4
  %99 = load i16, i16* %op_type121, align 2
  %conv122 = zext i16 %99 to i32
  %cmp123 = icmp eq i32 %conv122, 83
  br i1 %cmp123, label %if.then.125, label %if.end.130

if.then.125:                                      ; preds = %if.end.120
  %100 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private126 = getelementptr inbounds %struct.op, %struct.op* %100, i32 0, i32 7
  %101 = load i8, i8* %op_private126, align 1
  %conv127 = zext i8 %101 to i32
  %or128 = or i32 %conv127, 3
  %conv129 = trunc i32 %or128 to i8
  store i8 %conv129, i8* %op_private126, align 1
  br label %if.end.130

if.end.130:                                       ; preds = %if.then.125, %if.end.120
  %102 = load %struct.op*, %struct.op** %o.addr, align 8
  %103 = bitcast %struct.op* %102 to %struct.listop*
  %op_first131 = getelementptr inbounds %struct.listop, %struct.listop* %103, i32 0, i32 8
  %104 = load %struct.op*, %struct.op** %op_first131, align 8
  %op_sibling132 = getelementptr inbounds %struct.op, %struct.op* %104, i32 0, i32 1
  %105 = load %struct.op*, %struct.op** %op_sibling132, align 8
  store %struct.op* %105, %struct.op** %kid, align 8
  %106 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling133 = getelementptr inbounds %struct.op, %struct.op* %106, i32 0, i32 1
  %107 = load %struct.op*, %struct.op** %op_sibling133, align 8
  %108 = load %struct.op*, %struct.op** %o.addr, align 8
  %109 = bitcast %struct.op* %108 to %struct.listop*
  %op_first134 = getelementptr inbounds %struct.listop, %struct.listop* %109, i32 0, i32 8
  %110 = load %struct.op*, %struct.op** %op_first134, align 8
  %op_sibling135 = getelementptr inbounds %struct.op, %struct.op* %110, i32 0, i32 1
  store %struct.op* %107, %struct.op** %op_sibling135, align 8
  %111 = load %struct.op*, %struct.op** %kid, align 8
  call void @Perl_op_free(%struct.op* %111)
  br label %return

return:                                           ; preds = %if.end.130, %if.then.99, %if.then.78, %if.then.70, %if.then.62, %if.else.54, %if.then.35, %if.then.29, %if.then.21, %sw.default, %if.then.12, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_split(%struct.op* %o) #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %o.addr = alloca %struct.op*, align 8
  %kid = alloca %struct.op*, align 8
  %sibl = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %0, i32 0, i32 6
  %1 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %1 to i32
  %and = and i32 %conv, 64
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.op*, %struct.op** %o.addr, align 8
  %call = call %struct.op* @S_no_fh_allowed(%struct.op* %2)
  store %struct.op* %call, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %entry
  %3 = load %struct.op*, %struct.op** %o.addr, align 8
  %4 = bitcast %struct.op* %3 to %struct.listop*
  %op_first = getelementptr inbounds %struct.listop, %struct.listop* %4, i32 0, i32 8
  %5 = load %struct.op*, %struct.op** %op_first, align 8
  store %struct.op* %5, %struct.op** %kid, align 8
  %6 = load %struct.op*, %struct.op** %kid, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %6, i32 0, i32 4
  %7 = load i16, i16* %op_type, align 2
  %conv1 = zext i16 %7 to i32
  %cmp = icmp ne i32 %conv1, 0
  br i1 %cmp, label %if.then.3, label %if.end.4

if.then.3:                                        ; preds = %if.end
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.122, i32 0, i32 0))
  br label %if.end.4

if.end.4:                                         ; preds = %if.then.3, %if.end
  %8 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %8, i32 0, i32 1
  %9 = load %struct.op*, %struct.op** %op_sibling, align 8
  store %struct.op* %9, %struct.op** %kid, align 8
  %10 = load %struct.op*, %struct.op** %o.addr, align 8
  %11 = bitcast %struct.op* %10 to %struct.listop*
  %op_first5 = getelementptr inbounds %struct.listop, %struct.listop* %11, i32 0, i32 8
  %12 = load %struct.op*, %struct.op** %op_first5, align 8
  call void @Perl_op_free(%struct.op* %12)
  %13 = load %struct.op*, %struct.op** %kid, align 8
  %14 = load %struct.op*, %struct.op** %o.addr, align 8
  %15 = bitcast %struct.op* %14 to %struct.listop*
  %op_first6 = getelementptr inbounds %struct.listop, %struct.listop* %15, i32 0, i32 8
  store %struct.op* %13, %struct.op** %op_first6, align 8
  %16 = load %struct.op*, %struct.op** %kid, align 8
  %tobool7 = icmp ne %struct.op* %16, null
  br i1 %tobool7, label %if.end.12, label %if.then.8

if.then.8:                                        ; preds = %if.end.4
  %call9 = call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.123, i32 0, i32 0), i64 1)
  %call10 = call %struct.op* @Perl_newSVOP(i32 5, i32 0, %struct.sv* %call9)
  store %struct.op* %call10, %struct.op** %kid, align 8
  %17 = load %struct.op*, %struct.op** %o.addr, align 8
  %18 = bitcast %struct.op* %17 to %struct.listop*
  %op_first11 = getelementptr inbounds %struct.listop, %struct.listop* %18, i32 0, i32 8
  store %struct.op* %call10, %struct.op** %op_first11, align 8
  %19 = load %struct.op*, %struct.op** %kid, align 8
  %20 = load %struct.op*, %struct.op** %o.addr, align 8
  %21 = bitcast %struct.op* %20 to %struct.listop*
  %op_last = getelementptr inbounds %struct.listop, %struct.listop* %21, i32 0, i32 9
  store %struct.op* %19, %struct.op** %op_last, align 8
  br label %if.end.12

if.end.12:                                        ; preds = %if.then.8, %if.end.4
  %22 = load %struct.op*, %struct.op** %kid, align 8
  %op_type13 = getelementptr inbounds %struct.op, %struct.op* %22, i32 0, i32 4
  %23 = load i16, i16* %op_type13, align 2
  %conv14 = zext i16 %23 to i32
  %cmp15 = icmp ne i32 %conv14, 31
  br i1 %cmp15, label %if.then.21, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end.12
  %24 = load %struct.op*, %struct.op** %kid, align 8
  %op_flags17 = getelementptr inbounds %struct.op, %struct.op* %24, i32 0, i32 6
  %25 = load i8, i8* %op_flags17, align 1
  %conv18 = zext i8 %25 to i32
  %and19 = and i32 %conv18, 64
  %tobool20 = icmp ne i32 %and19, 0
  br i1 %tobool20, label %if.then.21, label %if.end.35

if.then.21:                                       ; preds = %lor.lhs.false, %if.end.12
  %26 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling22 = getelementptr inbounds %struct.op, %struct.op* %26, i32 0, i32 1
  %27 = load %struct.op*, %struct.op** %op_sibling22, align 8
  store %struct.op* %27, %struct.op** %sibl, align 8
  %28 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling23 = getelementptr inbounds %struct.op, %struct.op* %28, i32 0, i32 1
  store %struct.op* null, %struct.op** %op_sibling23, align 8
  %call24 = call %struct.op* @Perl_newPMOP(i32 31, i32 128)
  %29 = load %struct.op*, %struct.op** %kid, align 8
  %call25 = call %struct.op* @Perl_pmruntime(%struct.op* %call24, %struct.op* %29, %struct.op* null)
  store %struct.op* %call25, %struct.op** %kid, align 8
  %30 = load %struct.op*, %struct.op** %o.addr, align 8
  %31 = bitcast %struct.op* %30 to %struct.listop*
  %op_first26 = getelementptr inbounds %struct.listop, %struct.listop* %31, i32 0, i32 8
  %32 = load %struct.op*, %struct.op** %op_first26, align 8
  %33 = load %struct.op*, %struct.op** %o.addr, align 8
  %34 = bitcast %struct.op* %33 to %struct.listop*
  %op_last27 = getelementptr inbounds %struct.listop, %struct.listop* %34, i32 0, i32 9
  %35 = load %struct.op*, %struct.op** %op_last27, align 8
  %cmp28 = icmp eq %struct.op* %32, %35
  br i1 %cmp28, label %if.then.30, label %if.end.32

if.then.30:                                       ; preds = %if.then.21
  %36 = load %struct.op*, %struct.op** %kid, align 8
  %37 = load %struct.op*, %struct.op** %o.addr, align 8
  %38 = bitcast %struct.op* %37 to %struct.listop*
  %op_last31 = getelementptr inbounds %struct.listop, %struct.listop* %38, i32 0, i32 9
  store %struct.op* %36, %struct.op** %op_last31, align 8
  br label %if.end.32

if.end.32:                                        ; preds = %if.then.30, %if.then.21
  %39 = load %struct.op*, %struct.op** %kid, align 8
  %40 = load %struct.op*, %struct.op** %o.addr, align 8
  %41 = bitcast %struct.op* %40 to %struct.listop*
  %op_first33 = getelementptr inbounds %struct.listop, %struct.listop* %41, i32 0, i32 8
  store %struct.op* %39, %struct.op** %op_first33, align 8
  %42 = load %struct.op*, %struct.op** %sibl, align 8
  %43 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling34 = getelementptr inbounds %struct.op, %struct.op* %43, i32 0, i32 1
  store %struct.op* %42, %struct.op** %op_sibling34, align 8
  br label %if.end.35

if.end.35:                                        ; preds = %if.end.32, %lor.lhs.false
  %44 = load %struct.op*, %struct.op** %kid, align 8
  %op_type36 = getelementptr inbounds %struct.op, %struct.op* %44, i32 0, i32 4
  store i16 13, i16* %op_type36, align 2
  %45 = load %struct.op* ()*, %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 13), align 8
  %46 = load %struct.op*, %struct.op** %kid, align 8
  %op_ppaddr = getelementptr inbounds %struct.op, %struct.op* %46, i32 0, i32 2
  store %struct.op* ()* %45, %struct.op* ()** %op_ppaddr, align 8
  %47 = load %struct.op*, %struct.op** %kid, align 8
  %call37 = call %struct.op* @Perl_scalar(%struct.op* %47)
  %48 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings = getelementptr inbounds %struct.cop, %struct.cop* %48, i32 0, i32 14
  %49 = load %struct.sv*, %struct.sv** %cop_warnings, align 8
  %cmp38 = icmp ne %struct.sv* %49, null
  br i1 %cmp38, label %land.lhs.true, label %lor.lhs.false.52

land.lhs.true:                                    ; preds = %if.end.35
  %50 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings40 = getelementptr inbounds %struct.cop, %struct.cop* %50, i32 0, i32 14
  %51 = load %struct.sv*, %struct.sv** %cop_warnings40, align 8
  %cmp41 = icmp ne %struct.sv* %51, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 2)
  br i1 %cmp41, label %land.lhs.true.43, label %lor.lhs.false.52

land.lhs.true.43:                                 ; preds = %land.lhs.true
  %52 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings44 = getelementptr inbounds %struct.cop, %struct.cop* %52, i32 0, i32 14
  %53 = load %struct.sv*, %struct.sv** %cop_warnings44, align 8
  %cmp45 = icmp eq %struct.sv* %53, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 1)
  br i1 %cmp45, label %land.lhs.true.60, label %lor.lhs.false.47

lor.lhs.false.47:                                 ; preds = %land.lhs.true.43
  %54 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings48 = getelementptr inbounds %struct.cop, %struct.cop* %54, i32 0, i32 14
  %55 = load %struct.sv*, %struct.sv** %cop_warnings48, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %55, i32 0, i32 0
  %56 = load i8*, i8** %sv_any, align 8
  %57 = bitcast i8* %56 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %57, i32 0, i32 0
  %58 = load i8*, i8** %xpv_pv, align 8
  %arrayidx = getelementptr inbounds i8, i8* %58, i64 5
  %59 = load i8, i8* %arrayidx, align 1
  %conv49 = sext i8 %59 to i32
  %and50 = and i32 %conv49, 1
  %tobool51 = icmp ne i32 %and50, 0
  br i1 %tobool51, label %land.lhs.true.60, label %lor.lhs.false.52

lor.lhs.false.52:                                 ; preds = %lor.lhs.false.47, %land.lhs.true, %if.end.35
  %60 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings53 = getelementptr inbounds %struct.cop, %struct.cop* %60, i32 0, i32 14
  %61 = load %struct.sv*, %struct.sv** %cop_warnings53, align 8
  %cmp54 = icmp eq %struct.sv* %61, null
  br i1 %cmp54, label %land.lhs.true.56, label %if.end.64

land.lhs.true.56:                                 ; preds = %lor.lhs.false.52
  %62 = load i8, i8* @PL_dowarn, align 1
  %conv57 = zext i8 %62 to i32
  %and58 = and i32 %conv57, 1
  %tobool59 = icmp ne i32 %and58, 0
  br i1 %tobool59, label %land.lhs.true.60, label %if.end.64

land.lhs.true.60:                                 ; preds = %land.lhs.true.56, %lor.lhs.false.47, %land.lhs.true.43
  %63 = load %struct.op*, %struct.op** %kid, align 8
  %64 = bitcast %struct.op* %63 to %struct.pmop*
  %op_pmflags = getelementptr inbounds %struct.pmop, %struct.pmop* %64, i32 0, i32 14
  %65 = load i32, i32* %op_pmflags, align 4
  %and61 = and i32 %65, 256
  %tobool62 = icmp ne i32 %and61, 0
  br i1 %tobool62, label %if.then.63, label %if.end.64

if.then.63:                                       ; preds = %land.lhs.true.60
  call void (i32, i8*, ...) @Perl_warner(i32 20, i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.124, i32 0, i32 0))
  br label %if.end.64

if.end.64:                                        ; preds = %if.then.63, %land.lhs.true.60, %land.lhs.true.56, %lor.lhs.false.52
  %66 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling65 = getelementptr inbounds %struct.op, %struct.op* %66, i32 0, i32 1
  %67 = load %struct.op*, %struct.op** %op_sibling65, align 8
  %tobool66 = icmp ne %struct.op* %67, null
  br i1 %tobool66, label %if.end.70, label %if.then.67

if.then.67:                                       ; preds = %if.end.64
  %68 = load %struct.op*, %struct.op** %o.addr, align 8
  %call68 = call %struct.op* @S_newDEFSVOP()
  %call69 = call %struct.op* @Perl_append_elem(i32 139, %struct.op* %68, %struct.op* %call68)
  br label %if.end.70

if.end.70:                                        ; preds = %if.then.67, %if.end.64
  %69 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling71 = getelementptr inbounds %struct.op, %struct.op* %69, i32 0, i32 1
  %70 = load %struct.op*, %struct.op** %op_sibling71, align 8
  store %struct.op* %70, %struct.op** %kid, align 8
  %71 = load %struct.op*, %struct.op** %kid, align 8
  %call72 = call %struct.op* @Perl_scalar(%struct.op* %71)
  %72 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling73 = getelementptr inbounds %struct.op, %struct.op* %72, i32 0, i32 1
  %73 = load %struct.op*, %struct.op** %op_sibling73, align 8
  %tobool74 = icmp ne %struct.op* %73, null
  br i1 %tobool74, label %if.end.79, label %if.then.75

if.then.75:                                       ; preds = %if.end.70
  %74 = load %struct.op*, %struct.op** %o.addr, align 8
  %call76 = call %struct.sv* @Perl_newSViv(i64 0)
  %call77 = call %struct.op* @Perl_newSVOP(i32 5, i32 0, %struct.sv* %call76)
  %call78 = call %struct.op* @Perl_append_elem(i32 139, %struct.op* %74, %struct.op* %call77)
  br label %if.end.79

if.end.79:                                        ; preds = %if.then.75, %if.end.70
  %75 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling80 = getelementptr inbounds %struct.op, %struct.op* %75, i32 0, i32 1
  %76 = load %struct.op*, %struct.op** %op_sibling80, align 8
  store %struct.op* %76, %struct.op** %kid, align 8
  %77 = load %struct.op*, %struct.op** %kid, align 8
  %call81 = call %struct.op* @Perl_scalar(%struct.op* %77)
  %78 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling82 = getelementptr inbounds %struct.op, %struct.op* %78, i32 0, i32 1
  %79 = load %struct.op*, %struct.op** %op_sibling82, align 8
  %tobool83 = icmp ne %struct.op* %79, null
  br i1 %tobool83, label %if.then.84, label %if.end.93

if.then.84:                                       ; preds = %if.end.79
  %80 = load %struct.op*, %struct.op** %o.addr, align 8
  %81 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type85 = getelementptr inbounds %struct.op, %struct.op* %81, i32 0, i32 4
  %82 = load i16, i16* %op_type85, align 2
  %conv86 = zext i16 %82 to i32
  %cmp87 = icmp eq i32 %conv86, 351
  br i1 %cmp87, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.84
  %83 = load %struct.op*, %struct.op** %o.addr, align 8
  %call89 = call i8* @Perl_custom_op_desc(%struct.op* %83)
  br label %cond.end

cond.false:                                       ; preds = %if.then.84
  %84 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type90 = getelementptr inbounds %struct.op, %struct.op* %84, i32 0, i32 4
  %85 = load i16, i16* %op_type90, align 2
  %idxprom = zext i16 %85 to i64
  %arrayidx91 = getelementptr inbounds [0 x i8*], [0 x i8*]* @PL_op_desc, i32 0, i64 %idxprom
  %86 = load i8*, i8** %arrayidx91, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %call89, %cond.true ], [ %86, %cond.false ]
  %call92 = call %struct.op* @S_too_many_arguments(%struct.op* %80, i8* %cond)
  store %struct.op* %call92, %struct.op** %retval
  br label %return

if.end.93:                                        ; preds = %if.end.79
  %87 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %87, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.93, %cond.end, %if.then
  %88 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %88
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_join(%struct.op* %o) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  %kid = alloca %struct.op*, align 8
  %pmstr = alloca i8*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings = getelementptr inbounds %struct.cop, %struct.cop* %0, i32 0, i32 14
  %1 = load %struct.sv*, %struct.sv** %cop_warnings, align 8
  %cmp = icmp ne %struct.sv* %1, null
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false.7

land.lhs.true:                                    ; preds = %entry
  %2 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings1 = getelementptr inbounds %struct.cop, %struct.cop* %2, i32 0, i32 14
  %3 = load %struct.sv*, %struct.sv** %cop_warnings1, align 8
  %cmp2 = icmp ne %struct.sv* %3, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 2)
  br i1 %cmp2, label %land.lhs.true.3, label %lor.lhs.false.7

land.lhs.true.3:                                  ; preds = %land.lhs.true
  %4 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings4 = getelementptr inbounds %struct.cop, %struct.cop* %4, i32 0, i32 14
  %5 = load %struct.sv*, %struct.sv** %cop_warnings4, align 8
  %cmp5 = icmp eq %struct.sv* %5, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 1)
  br i1 %cmp5, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true.3
  %6 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings6 = getelementptr inbounds %struct.cop, %struct.cop* %6, i32 0, i32 14
  %7 = load %struct.sv*, %struct.sv** %cop_warnings6, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %7, i32 0, i32 0
  %8 = load i8*, i8** %sv_any, align 8
  %9 = bitcast i8* %8 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %9, i32 0, i32 0
  %10 = load i8*, i8** %xpv_pv, align 8
  %arrayidx = getelementptr inbounds i8, i8* %10, i64 7
  %11 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %11 to i32
  %and = and i32 %conv, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %lor.lhs.false.7

lor.lhs.false.7:                                  ; preds = %lor.lhs.false, %land.lhs.true, %entry
  %12 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings8 = getelementptr inbounds %struct.cop, %struct.cop* %12, i32 0, i32 14
  %13 = load %struct.sv*, %struct.sv** %cop_warnings8, align 8
  %cmp9 = icmp eq %struct.sv* %13, null
  br i1 %cmp9, label %land.lhs.true.11, label %if.end.25

land.lhs.true.11:                                 ; preds = %lor.lhs.false.7
  %14 = load i8, i8* @PL_dowarn, align 1
  %conv12 = zext i8 %14 to i32
  %and13 = and i32 %conv12, 1
  %tobool14 = icmp ne i32 %and13, 0
  br i1 %tobool14, label %if.then, label %if.end.25

if.then:                                          ; preds = %land.lhs.true.11, %lor.lhs.false, %land.lhs.true.3
  %15 = load %struct.op*, %struct.op** %o.addr, align 8
  %16 = bitcast %struct.op* %15 to %struct.listop*
  %op_first = getelementptr inbounds %struct.listop, %struct.listop* %16, i32 0, i32 8
  %17 = load %struct.op*, %struct.op** %op_first, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %17, i32 0, i32 1
  %18 = load %struct.op*, %struct.op** %op_sibling, align 8
  store %struct.op* %18, %struct.op** %kid, align 8
  %19 = load %struct.op*, %struct.op** %kid, align 8
  %tobool15 = icmp ne %struct.op* %19, null
  br i1 %tobool15, label %land.lhs.true.16, label %if.end.24

land.lhs.true.16:                                 ; preds = %if.then
  %20 = load %struct.op*, %struct.op** %kid, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %20, i32 0, i32 4
  %21 = load i16, i16* %op_type, align 2
  %conv17 = zext i16 %21 to i32
  %cmp18 = icmp eq i32 %conv17, 31
  br i1 %cmp18, label %if.then.20, label %if.end.24

if.then.20:                                       ; preds = %land.lhs.true.16
  store i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.125, i32 0, i32 0), i8** %pmstr, align 8
  %22 = load %struct.op*, %struct.op** %kid, align 8
  %23 = bitcast %struct.op* %22 to %struct.pmop*
  %op_pmregexp = getelementptr inbounds %struct.pmop, %struct.pmop* %23, i32 0, i32 13
  %24 = load %struct.regexp*, %struct.regexp** %op_pmregexp, align 8
  %tobool21 = icmp ne %struct.regexp* %24, null
  br i1 %tobool21, label %if.then.22, label %if.end

if.then.22:                                       ; preds = %if.then.20
  %25 = load %struct.op*, %struct.op** %kid, align 8
  %26 = bitcast %struct.op* %25 to %struct.pmop*
  %op_pmregexp23 = getelementptr inbounds %struct.pmop, %struct.pmop* %26, i32 0, i32 13
  %27 = load %struct.regexp*, %struct.regexp** %op_pmregexp23, align 8
  %precomp = getelementptr inbounds %struct.regexp, %struct.regexp* %27, i32 0, i32 4
  %28 = load i8*, i8** %precomp, align 8
  store i8* %28, i8** %pmstr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then.22, %if.then.20
  %29 = load i8*, i8** %pmstr, align 8
  %30 = load i8*, i8** %pmstr, align 8
  call void (i32, i8*, ...) @Perl_warner(i32 28, i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.126, i32 0, i32 0), i8* %29, i8* %30)
  br label %if.end.24

if.end.24:                                        ; preds = %if.end, %land.lhs.true.16, %if.then
  br label %if.end.25

if.end.25:                                        ; preds = %if.end.24, %land.lhs.true.11, %lor.lhs.false.7
  %31 = load %struct.op*, %struct.op** %o.addr, align 8
  %call = call %struct.op* @Perl_ck_fun(%struct.op* %31)
  ret %struct.op* %call
}

; Function Attrs: nounwind uwtable
define internal i8* @S_gv_ename(%struct.gv* %gv) #0 {
entry:
  %gv.addr = alloca %struct.gv*, align 8
  %n_a = alloca i64, align 8
  %tmpsv = alloca %struct.sv*, align 8
  store %struct.gv* %gv, %struct.gv** %gv.addr, align 8
  %call = call %struct.sv* @Perl_sv_newmortal()
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %0 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %1 = load %struct.gv*, %struct.gv** %gv.addr, align 8
  call void @Perl_gv_efullname4(%struct.sv* %0, %struct.gv* %1, i8* null, i8 signext 1)
  %2 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %2, i32 0, i32 2
  %3 = load i32, i32* %sv_flags, align 4
  %and = and i32 %3, 262144
  %cmp = icmp eq i32 %and, 262144
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %4 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %4, i32 0, i32 0
  %5 = load i8*, i8** %sv_any, align 8
  %6 = bitcast i8* %5 to %struct.xpv*
  %xpv_cur = getelementptr inbounds %struct.xpv, %struct.xpv* %6, i32 0, i32 1
  %7 = load i64, i64* %xpv_cur, align 8
  store i64 %7, i64* %n_a, align 8
  %8 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %sv_any1 = getelementptr inbounds %struct.sv, %struct.sv* %8, i32 0, i32 0
  %9 = load i8*, i8** %sv_any1, align 8
  %10 = bitcast i8* %9 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %10, i32 0, i32 0
  %11 = load i8*, i8** %xpv_pv, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %12 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %call2 = call i8* @Perl_sv_2pv_flags(%struct.sv* %12, i64* %n_a, i32 2)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %11, %cond.true ], [ %call2, %cond.false ]
  ret i8* %cond
}

declare void @Perl_gv_fullname4(%struct.sv*, %struct.gv*, i8*, i8 signext) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_svconst(%struct.op* %o) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %1 = bitcast %struct.op* %0 to %struct.svop*
  %op_sv = getelementptr inbounds %struct.svop, %struct.svop* %1, i32 0, i32 8
  %2 = load %struct.sv*, %struct.sv** %op_sv, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %2, i32 0, i32 2
  %3 = load i32, i32* %sv_flags, align 4
  %or = or i32 %3, 8388608
  store i32 %or, i32* %sv_flags, align 4
  %4 = load %struct.op*, %struct.op** %o.addr, align 8
  ret %struct.op* %4
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_trunc(%struct.op* %o) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  %kid = alloca %struct.svop*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %0, i32 0, i32 6
  %1 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %1 to i32
  %and = and i32 %conv, 4
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end.22

if.then:                                          ; preds = %entry
  %2 = load %struct.op*, %struct.op** %o.addr, align 8
  %3 = bitcast %struct.op* %2 to %struct.unop*
  %op_first = getelementptr inbounds %struct.unop, %struct.unop* %3, i32 0, i32 8
  %4 = load %struct.op*, %struct.op** %op_first, align 8
  %5 = bitcast %struct.op* %4 to %struct.svop*
  store %struct.svop* %5, %struct.svop** %kid, align 8
  %6 = load %struct.svop*, %struct.svop** %kid, align 8
  %op_type = getelementptr inbounds %struct.svop, %struct.svop* %6, i32 0, i32 4
  %7 = load i16, i16* %op_type, align 2
  %conv1 = zext i16 %7 to i32
  %cmp = icmp eq i32 %conv1, 0
  br i1 %cmp, label %if.then.3, label %if.end

if.then.3:                                        ; preds = %if.then
  %8 = load %struct.svop*, %struct.svop** %kid, align 8
  %op_sibling = getelementptr inbounds %struct.svop, %struct.svop* %8, i32 0, i32 1
  %9 = load %struct.op*, %struct.op** %op_sibling, align 8
  %10 = bitcast %struct.op* %9 to %struct.svop*
  store %struct.svop* %10, %struct.svop** %kid, align 8
  br label %if.end

if.end:                                           ; preds = %if.then.3, %if.then
  %11 = load %struct.svop*, %struct.svop** %kid, align 8
  %tobool4 = icmp ne %struct.svop* %11, null
  br i1 %tobool4, label %land.lhs.true, label %if.end.21

land.lhs.true:                                    ; preds = %if.end
  %12 = load %struct.svop*, %struct.svop** %kid, align 8
  %op_type5 = getelementptr inbounds %struct.svop, %struct.svop* %12, i32 0, i32 4
  %13 = load i16, i16* %op_type5, align 2
  %conv6 = zext i16 %13 to i32
  %cmp7 = icmp eq i32 %conv6, 5
  br i1 %cmp7, label %land.lhs.true.9, label %if.end.21

land.lhs.true.9:                                  ; preds = %land.lhs.true
  %14 = load %struct.svop*, %struct.svop** %kid, align 8
  %op_private = getelementptr inbounds %struct.svop, %struct.svop* %14, i32 0, i32 7
  %15 = load i8, i8* %op_private, align 1
  %conv10 = zext i8 %15 to i32
  %and11 = and i32 %conv10, 64
  %tobool12 = icmp ne i32 %and11, 0
  br i1 %tobool12, label %if.then.13, label %if.end.21

if.then.13:                                       ; preds = %land.lhs.true.9
  %16 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags14 = getelementptr inbounds %struct.op, %struct.op* %16, i32 0, i32 6
  %17 = load i8, i8* %op_flags14, align 1
  %conv15 = zext i8 %17 to i32
  %or = or i32 %conv15, 128
  %conv16 = trunc i32 %or to i8
  store i8 %conv16, i8* %op_flags14, align 1
  %18 = load %struct.svop*, %struct.svop** %kid, align 8
  %op_private17 = getelementptr inbounds %struct.svop, %struct.svop* %18, i32 0, i32 7
  %19 = load i8, i8* %op_private17, align 1
  %conv18 = zext i8 %19 to i32
  %and19 = and i32 %conv18, -9
  %conv20 = trunc i32 %and19 to i8
  store i8 %conv20, i8* %op_private17, align 1
  br label %if.end.21

if.end.21:                                        ; preds = %if.then.13, %land.lhs.true.9, %land.lhs.true, %if.end
  br label %if.end.22

if.end.22:                                        ; preds = %if.end.21, %entry
  %20 = load %struct.op*, %struct.op** %o.addr, align 8
  %call = call %struct.op* @Perl_ck_fun(%struct.op* %20)
  ret %struct.op* %call
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_ck_substr(%struct.op* %o) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  %kid = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %call = call %struct.op* @Perl_ck_fun(%struct.op* %0)
  store %struct.op* %call, %struct.op** %o.addr, align 8
  %1 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 6
  %2 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 4
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end.13

land.lhs.true:                                    ; preds = %entry
  %3 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %3, i32 0, i32 7
  %4 = load i8, i8* %op_private, align 1
  %conv1 = zext i8 %4 to i32
  %cmp = icmp eq i32 %conv1, 4
  br i1 %cmp, label %if.then, label %if.end.13

if.then:                                          ; preds = %land.lhs.true
  %5 = load %struct.op*, %struct.op** %o.addr, align 8
  %6 = bitcast %struct.op* %5 to %struct.listop*
  %op_first = getelementptr inbounds %struct.listop, %struct.listop* %6, i32 0, i32 8
  %7 = load %struct.op*, %struct.op** %op_first, align 8
  store %struct.op* %7, %struct.op** %kid, align 8
  %8 = load %struct.op*, %struct.op** %kid, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %8, i32 0, i32 4
  %9 = load i16, i16* %op_type, align 2
  %conv3 = zext i16 %9 to i32
  %cmp4 = icmp eq i32 %conv3, 0
  br i1 %cmp4, label %if.then.6, label %if.end

if.then.6:                                        ; preds = %if.then
  %10 = load %struct.op*, %struct.op** %kid, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %10, i32 0, i32 1
  %11 = load %struct.op*, %struct.op** %op_sibling, align 8
  store %struct.op* %11, %struct.op** %kid, align 8
  br label %if.end

if.end:                                           ; preds = %if.then.6, %if.then
  %12 = load %struct.op*, %struct.op** %kid, align 8
  %tobool7 = icmp ne %struct.op* %12, null
  br i1 %tobool7, label %if.then.8, label %if.end.12

if.then.8:                                        ; preds = %if.end
  %13 = load %struct.op*, %struct.op** %kid, align 8
  %op_flags9 = getelementptr inbounds %struct.op, %struct.op* %13, i32 0, i32 6
  %14 = load i8, i8* %op_flags9, align 1
  %conv10 = zext i8 %14 to i32
  %or = or i32 %conv10, 32
  %conv11 = trunc i32 %or to i8
  store i8 %conv11, i8* %op_flags9, align 1
  br label %if.end.12

if.end.12:                                        ; preds = %if.then.8, %if.end
  br label %if.end.13

if.end.13:                                        ; preds = %if.end.12, %land.lhs.true, %entry
  %15 = load %struct.op*, %struct.op** %o.addr, align 8
  ret %struct.op* %15
}

; Function Attrs: nounwind uwtable
define void @Perl_peep(%struct.op* %o) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  %oldop = alloca %struct.op*, align 8
  %n_a = alloca i64, align 8
  %pop = alloca %struct.op*, align 8
  %i = alloca i64, align 8
  %gv = alloca %struct.gv*, align 8
  %gv267 = alloca %struct.gv*, align 8
  %sv = alloca %struct.sv*, align 8
  %oldline = alloca i32, align 4
  %rop = alloca %struct.unop*, align 8
  %lexname = alloca %struct.sv*, align 8
  %fields = alloca %struct.gv**, align 8
  %svp = alloca %struct.sv**, align 8
  %indsvp = alloca %struct.sv**, align 8
  %sv456 = alloca %struct.sv*, align 8
  %ind = alloca i32, align 4
  %key = alloca i8*, align 8
  %keylen = alloca i64, align 8
  %rop616 = alloca %struct.unop*, align 8
  %lexname617 = alloca %struct.sv*, align 8
  %fields618 = alloca %struct.gv**, align 8
  %svp619 = alloca %struct.sv**, align 8
  %indsvp620 = alloca %struct.sv**, align 8
  %sv621 = alloca %struct.sv*, align 8
  %ind622 = alloca i32, align 4
  %key623 = alloca i8*, align 8
  %keylen624 = alloca i64, align 8
  %first_key_op = alloca %struct.svop*, align 8
  %key_op = alloca %struct.svop*, align 8
  %oleft = alloca %struct.op*, align 8
  %oright = alloca %struct.op*, align 8
  %o2 = alloca %struct.op*, align 8
  %reverse = alloca %struct.op*, align 8
  %pushmark = alloca %struct.op*, align 8
  %ourmark = alloca %struct.op*, align 8
  %theirmark = alloca %struct.op*, align 8
  %ourlast = alloca %struct.op*, align 8
  %iter = alloca %struct.op*, align 8
  %expushmark = alloca %struct.op*, align 8
  %rv2av = alloca %struct.op*, align 8
  %gvop = alloca %struct.op*, align 8
  %enter = alloca %struct.listop*, align 8
  %exlist = alloca %struct.listop*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  store %struct.op* null, %struct.op** %oldop, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %tobool = icmp ne %struct.op* %0, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %1 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_seq = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 5
  %2 = load i16, i16* %op_seq, align 2
  %conv = zext i16 %2 to i32
  %tobool1 = icmp ne i32 %conv, 0
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  call void @Perl_push_scope()
  call void @Perl_save_op()
  call void @Perl_save_vptr(i8* bitcast (%struct.cop** @PL_curcop to i8*))
  br label %for.cond

for.cond:                                         ; preds = %for.inc.1173, %if.end
  %3 = load %struct.op*, %struct.op** %o.addr, align 8
  %tobool2 = icmp ne %struct.op* %3, null
  br i1 %tobool2, label %for.body, label %for.end.1175

for.body:                                         ; preds = %for.cond
  %4 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_seq3 = getelementptr inbounds %struct.op, %struct.op* %4, i32 0, i32 5
  %5 = load i16, i16* %op_seq3, align 2
  %tobool4 = icmp ne i16 %5, 0
  br i1 %tobool4, label %if.then.5, label %if.end.6

if.then.5:                                        ; preds = %for.body
  br label %for.end.1175

if.end.6:                                         ; preds = %for.body
  %6 = load i16, i16* @PL_op_seqmax, align 2
  %tobool7 = icmp ne i16 %6, 0
  br i1 %tobool7, label %lor.lhs.false.8, label %if.then.11

lor.lhs.false.8:                                  ; preds = %if.end.6
  %7 = load i16, i16* @PL_op_seqmax, align 2
  %conv9 = zext i16 %7 to i32
  %cmp = icmp eq i32 %conv9, 65535
  br i1 %cmp, label %if.then.11, label %if.end.12

if.then.11:                                       ; preds = %lor.lhs.false.8, %if.end.6
  store i16 1, i16* @PL_op_seqmax, align 2
  br label %if.end.12

if.end.12:                                        ; preds = %if.then.11, %lor.lhs.false.8
  %8 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %8, %struct.op** @PL_op, align 8
  %9 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %9, i32 0, i32 4
  %10 = load i16, i16* %op_type, align 2
  %conv13 = zext i16 %10 to i32
  switch i32 %conv13, label %sw.default [
    i32 349, label %sw.bb
    i32 174, label %sw.bb
    i32 175, label %sw.bb
    i32 5, label %sw.bb.15
    i32 66, label %sw.bb.22
    i32 1, label %sw.bb.53
    i32 0, label %sw.bb.63
    i32 2, label %sw.bb.85
    i32 173, label %sw.bb.85
    i32 179, label %sw.bb.85
    i32 10, label %sw.bb.96
    i32 7, label %sw.bb.96
    i32 155, label %sw.bb.322
    i32 153, label %sw.bb.322
    i32 159, label %sw.bb.322
    i32 160, label %sw.bb.322
    i32 163, label %sw.bb.322
    i32 164, label %sw.bb.322
    i32 162, label %sw.bb.322
    i32 156, label %sw.bb.322
    i32 182, label %sw.bb.333
    i32 180, label %sw.bb.333
    i32 32, label %sw.bb.369
    i32 31, label %sw.bb.369
    i32 33, label %sw.bb.369
    i32 285, label %sw.bb.385
    i32 135, label %sw.bb.455
    i32 136, label %sw.bb.615
    i32 150, label %sw.bb.777
    i32 151, label %sw.bb.1011
  ]

sw.bb:                                            ; preds = %if.end.12, %if.end.12, %if.end.12
  %11 = load %struct.op*, %struct.op** %o.addr, align 8
  %12 = bitcast %struct.op* %11 to %struct.cop*
  store volatile %struct.cop* %12, %struct.cop** @PL_curcop, align 8
  %13 = load i16, i16* @PL_op_seqmax, align 2
  %inc = add i16 %13, 1
  store i16 %inc, i16* @PL_op_seqmax, align 2
  %14 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_seq14 = getelementptr inbounds %struct.op, %struct.op* %14, i32 0, i32 5
  store i16 %13, i16* %op_seq14, align 2
  br label %sw.epilog

sw.bb.15:                                         ; preds = %if.end.12
  %15 = load %struct.op*, %struct.op** %o.addr, align 8
  %16 = bitcast %struct.op* %15 to %struct.svop*
  %op_private = getelementptr inbounds %struct.svop, %struct.svop* %16, i32 0, i32 7
  %17 = load i8, i8* %op_private, align 1
  %conv16 = zext i8 %17 to i32
  %and = and i32 %conv16, 8
  %tobool17 = icmp ne i32 %and, 0
  br i1 %tobool17, label %if.then.18, label %if.end.19

if.then.18:                                       ; preds = %sw.bb.15
  %18 = load %struct.op*, %struct.op** %o.addr, align 8
  call void @S_no_bareword_allowed(%struct.op* %18)
  br label %if.end.19

if.end.19:                                        ; preds = %if.then.18, %sw.bb.15
  %19 = load i16, i16* @PL_op_seqmax, align 2
  %inc20 = add i16 %19, 1
  store i16 %inc20, i16* @PL_op_seqmax, align 2
  %20 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_seq21 = getelementptr inbounds %struct.op, %struct.op* %20, i32 0, i32 5
  store i16 %19, i16* %op_seq21, align 2
  br label %sw.epilog

sw.bb.22:                                         ; preds = %if.end.12
  %21 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %21, i32 0, i32 0
  %22 = load %struct.op*, %struct.op** %op_next, align 8
  %tobool23 = icmp ne %struct.op* %22, null
  br i1 %tobool23, label %land.lhs.true, label %if.end.50

land.lhs.true:                                    ; preds = %sw.bb.22
  %23 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next24 = getelementptr inbounds %struct.op, %struct.op* %23, i32 0, i32 0
  %24 = load %struct.op*, %struct.op** %op_next24, align 8
  %op_type25 = getelementptr inbounds %struct.op, %struct.op* %24, i32 0, i32 4
  %25 = load i16, i16* %op_type25, align 2
  %conv26 = zext i16 %25 to i32
  %cmp27 = icmp eq i32 %conv26, 67
  br i1 %cmp27, label %if.then.29, label %if.end.50

if.then.29:                                       ; preds = %land.lhs.true
  %26 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next30 = getelementptr inbounds %struct.op, %struct.op* %26, i32 0, i32 0
  %27 = load %struct.op*, %struct.op** %op_next30, align 8
  %op_private31 = getelementptr inbounds %struct.op, %struct.op* %27, i32 0, i32 7
  %28 = load i8, i8* %op_private31, align 1
  %conv32 = zext i8 %28 to i32
  %and33 = and i32 %conv32, 16
  %tobool34 = icmp ne i32 %and33, 0
  br i1 %tobool34, label %if.then.35, label %if.end.48

if.then.35:                                       ; preds = %if.then.29
  %29 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %29, i32 0, i32 6
  %30 = load i8, i8* %op_flags, align 1
  %conv36 = zext i8 %30 to i32
  %and37 = and i32 %conv36, 64
  %tobool38 = icmp ne i32 %and37, 0
  br i1 %tobool38, label %if.then.39, label %if.else

if.then.39:                                       ; preds = %if.then.35
  br label %ignore_optimization

if.else:                                          ; preds = %if.then.35
  %31 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next40 = getelementptr inbounds %struct.op, %struct.op* %31, i32 0, i32 0
  %32 = load %struct.op*, %struct.op** %op_next40, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %32, i32 0, i32 3
  %33 = load i64, i64* %op_targ, align 8
  %34 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_targ41 = getelementptr inbounds %struct.op, %struct.op* %34, i32 0, i32 3
  store i64 %33, i64* %op_targ41, align 8
  %35 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next42 = getelementptr inbounds %struct.op, %struct.op* %35, i32 0, i32 0
  %36 = load %struct.op*, %struct.op** %op_next42, align 8
  %op_targ43 = getelementptr inbounds %struct.op, %struct.op* %36, i32 0, i32 3
  store i64 0, i64* %op_targ43, align 8
  %37 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private44 = getelementptr inbounds %struct.op, %struct.op* %37, i32 0, i32 7
  %38 = load i8, i8* %op_private44, align 1
  %conv45 = zext i8 %38 to i32
  %or = or i32 %conv45, 16
  %conv46 = trunc i32 %or to i8
  store i8 %conv46, i8* %op_private44, align 1
  br label %if.end.47

if.end.47:                                        ; preds = %if.else
  br label %if.end.48

if.end.48:                                        ; preds = %if.end.47, %if.then.29
  %39 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next49 = getelementptr inbounds %struct.op, %struct.op* %39, i32 0, i32 0
  %40 = load %struct.op*, %struct.op** %op_next49, align 8
  call void @Perl_op_null(%struct.op* %40)
  br label %if.end.50

if.end.50:                                        ; preds = %if.end.48, %land.lhs.true, %sw.bb.22
  br label %ignore_optimization

ignore_optimization:                              ; preds = %if.end.50, %if.then.39
  %41 = load i16, i16* @PL_op_seqmax, align 2
  %inc51 = add i16 %41, 1
  store i16 %inc51, i16* @PL_op_seqmax, align 2
  %42 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_seq52 = getelementptr inbounds %struct.op, %struct.op* %42, i32 0, i32 5
  store i16 %41, i16* %op_seq52, align 2
  br label %sw.epilog

sw.bb.53:                                         ; preds = %if.end.12
  %43 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags54 = getelementptr inbounds %struct.op, %struct.op* %43, i32 0, i32 6
  %44 = load i8, i8* %op_flags54, align 1
  %conv55 = zext i8 %44 to i32
  %and56 = and i32 %conv55, 3
  %cmp57 = icmp ne i32 %and56, 3
  br i1 %cmp57, label %if.then.59, label %if.end.62

if.then.59:                                       ; preds = %sw.bb.53
  %45 = load i16, i16* @PL_op_seqmax, align 2
  %inc60 = add i16 %45, 1
  store i16 %inc60, i16* @PL_op_seqmax, align 2
  %46 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_seq61 = getelementptr inbounds %struct.op, %struct.op* %46, i32 0, i32 5
  store i16 %45, i16* %op_seq61, align 2
  br label %sw.epilog

if.end.62:                                        ; preds = %sw.bb.53
  br label %nothin

sw.bb.63:                                         ; preds = %if.end.12
  %47 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_targ64 = getelementptr inbounds %struct.op, %struct.op* %47, i32 0, i32 3
  %48 = load i64, i64* %op_targ64, align 8
  %cmp65 = icmp eq i64 %48, 174
  br i1 %cmp65, label %if.then.75, label %lor.lhs.false.67

lor.lhs.false.67:                                 ; preds = %sw.bb.63
  %49 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_targ68 = getelementptr inbounds %struct.op, %struct.op* %49, i32 0, i32 3
  %50 = load i64, i64* %op_targ68, align 8
  %cmp69 = icmp eq i64 %50, 175
  br i1 %cmp69, label %if.then.75, label %lor.lhs.false.71

lor.lhs.false.71:                                 ; preds = %lor.lhs.false.67
  %51 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_targ72 = getelementptr inbounds %struct.op, %struct.op* %51, i32 0, i32 3
  %52 = load i64, i64* %op_targ72, align 8
  %cmp73 = icmp eq i64 %52, 349
  br i1 %cmp73, label %if.then.75, label %if.end.76

if.then.75:                                       ; preds = %lor.lhs.false.71, %lor.lhs.false.67, %sw.bb.63
  %53 = load %struct.op*, %struct.op** %o.addr, align 8
  %54 = bitcast %struct.op* %53 to %struct.cop*
  store volatile %struct.cop* %54, %struct.cop** @PL_curcop, align 8
  br label %if.end.76

if.end.76:                                        ; preds = %if.then.75, %lor.lhs.false.71
  %55 = load %struct.op*, %struct.op** %oldop, align 8
  %tobool77 = icmp ne %struct.op* %55, null
  br i1 %tobool77, label %land.lhs.true.78, label %if.end.84

land.lhs.true.78:                                 ; preds = %if.end.76
  %56 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next79 = getelementptr inbounds %struct.op, %struct.op* %56, i32 0, i32 0
  %57 = load %struct.op*, %struct.op** %op_next79, align 8
  %tobool80 = icmp ne %struct.op* %57, null
  br i1 %tobool80, label %if.then.81, label %if.end.84

if.then.81:                                       ; preds = %land.lhs.true.78
  %58 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next82 = getelementptr inbounds %struct.op, %struct.op* %58, i32 0, i32 0
  %59 = load %struct.op*, %struct.op** %op_next82, align 8
  %60 = load %struct.op*, %struct.op** %oldop, align 8
  %op_next83 = getelementptr inbounds %struct.op, %struct.op* %60, i32 0, i32 0
  store %struct.op* %59, %struct.op** %op_next83, align 8
  br label %for.inc.1173

if.end.84:                                        ; preds = %land.lhs.true.78, %if.end.76
  br label %sw.epilog

sw.bb.85:                                         ; preds = %if.end.12, %if.end.12, %if.end.12
  br label %nothin

nothin:                                           ; preds = %sw.bb.85, %if.end.62
  %61 = load %struct.op*, %struct.op** %oldop, align 8
  %tobool86 = icmp ne %struct.op* %61, null
  br i1 %tobool86, label %land.lhs.true.87, label %if.end.93

land.lhs.true.87:                                 ; preds = %nothin
  %62 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next88 = getelementptr inbounds %struct.op, %struct.op* %62, i32 0, i32 0
  %63 = load %struct.op*, %struct.op** %op_next88, align 8
  %tobool89 = icmp ne %struct.op* %63, null
  br i1 %tobool89, label %if.then.90, label %if.end.93

if.then.90:                                       ; preds = %land.lhs.true.87
  %64 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next91 = getelementptr inbounds %struct.op, %struct.op* %64, i32 0, i32 0
  %65 = load %struct.op*, %struct.op** %op_next91, align 8
  %66 = load %struct.op*, %struct.op** %oldop, align 8
  %op_next92 = getelementptr inbounds %struct.op, %struct.op* %66, i32 0, i32 0
  store %struct.op* %65, %struct.op** %op_next92, align 8
  br label %for.inc.1173

if.end.93:                                        ; preds = %land.lhs.true.87, %nothin
  %67 = load i16, i16* @PL_op_seqmax, align 2
  %inc94 = add i16 %67, 1
  store i16 %inc94, i16* @PL_op_seqmax, align 2
  %68 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_seq95 = getelementptr inbounds %struct.op, %struct.op* %68, i32 0, i32 5
  store i16 %67, i16* %op_seq95, align 2
  br label %sw.epilog

sw.bb.96:                                         ; preds = %if.end.12, %if.end.12
  %69 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type97 = getelementptr inbounds %struct.op, %struct.op* %69, i32 0, i32 4
  %70 = load i16, i16* %op_type97, align 2
  %conv98 = zext i16 %70 to i32
  %cmp99 = icmp eq i32 %conv98, 10
  br i1 %cmp99, label %if.then.107, label %lor.lhs.false.101

lor.lhs.false.101:                                ; preds = %sw.bb.96
  %71 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next102 = getelementptr inbounds %struct.op, %struct.op* %71, i32 0, i32 0
  %72 = load %struct.op*, %struct.op** %op_next102, align 8
  %op_type103 = getelementptr inbounds %struct.op, %struct.op* %72, i32 0, i32 4
  %73 = load i16, i16* %op_type103, align 2
  %conv104 = zext i16 %73 to i32
  %cmp105 = icmp eq i32 %conv104, 125
  br i1 %cmp105, label %if.then.107, label %if.end.208

if.then.107:                                      ; preds = %lor.lhs.false.101, %sw.bb.96
  %74 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type108 = getelementptr inbounds %struct.op, %struct.op* %74, i32 0, i32 4
  %75 = load i16, i16* %op_type108, align 2
  %conv109 = zext i16 %75 to i32
  %cmp110 = icmp eq i32 %conv109, 10
  br i1 %cmp110, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.107
  %76 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next112 = getelementptr inbounds %struct.op, %struct.op* %76, i32 0, i32 0
  %77 = load %struct.op*, %struct.op** %op_next112, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then.107
  %78 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next113 = getelementptr inbounds %struct.op, %struct.op* %78, i32 0, i32 0
  %79 = load %struct.op*, %struct.op** %op_next113, align 8
  %op_next114 = getelementptr inbounds %struct.op, %struct.op* %79, i32 0, i32 0
  %80 = load %struct.op*, %struct.op** %op_next114, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.op* [ %77, %cond.true ], [ %80, %cond.false ]
  store %struct.op* %cond, %struct.op** %pop, align 8
  %81 = load %struct.op*, %struct.op** %pop, align 8
  %tobool115 = icmp ne %struct.op* %81, null
  br i1 %tobool115, label %land.lhs.true.116, label %if.end.205

land.lhs.true.116:                                ; preds = %cond.end
  %82 = load %struct.op*, %struct.op** %pop, align 8
  %op_type117 = getelementptr inbounds %struct.op, %struct.op* %82, i32 0, i32 4
  %83 = load i16, i16* %op_type117, align 2
  %conv118 = zext i16 %83 to i32
  %cmp119 = icmp eq i32 %conv118, 5
  br i1 %cmp119, label %land.lhs.true.121, label %if.end.205

land.lhs.true.121:                                ; preds = %land.lhs.true.116
  %84 = load %struct.op*, %struct.op** %pop, align 8
  %op_next122 = getelementptr inbounds %struct.op, %struct.op* %84, i32 0, i32 0
  %85 = load %struct.op*, %struct.op** %op_next122, align 8
  store %struct.op* %85, %struct.op** @PL_op, align 8
  %tobool123 = icmp ne %struct.op* %85, null
  br i1 %tobool123, label %land.lhs.true.124, label %if.end.205

land.lhs.true.124:                                ; preds = %land.lhs.true.121
  %86 = load %struct.op*, %struct.op** %pop, align 8
  %op_next125 = getelementptr inbounds %struct.op, %struct.op* %86, i32 0, i32 0
  %87 = load %struct.op*, %struct.op** %op_next125, align 8
  %op_type126 = getelementptr inbounds %struct.op, %struct.op* %87, i32 0, i32 4
  %88 = load i16, i16* %op_type126, align 2
  %conv127 = zext i16 %88 to i32
  %cmp128 = icmp eq i32 %conv127, 127
  br i1 %cmp128, label %land.lhs.true.130, label %if.end.205

land.lhs.true.130:                                ; preds = %land.lhs.true.124
  %89 = load %struct.op*, %struct.op** %pop, align 8
  %op_next131 = getelementptr inbounds %struct.op, %struct.op* %89, i32 0, i32 0
  %90 = load %struct.op*, %struct.op** %op_next131, align 8
  %op_private132 = getelementptr inbounds %struct.op, %struct.op* %90, i32 0, i32 7
  %91 = load i8, i8* %op_private132, align 1
  %conv133 = zext i8 %91 to i32
  %and134 = and i32 %conv133, 248
  %tobool135 = icmp ne i32 %and134, 0
  br i1 %tobool135, label %if.end.205, label %land.lhs.true.136

land.lhs.true.136:                                ; preds = %land.lhs.true.130
  %92 = load %struct.op*, %struct.op** %pop, align 8
  %93 = bitcast %struct.op* %92 to %struct.svop*
  %op_sv = getelementptr inbounds %struct.svop, %struct.svop* %93, i32 0, i32 8
  %94 = load %struct.sv*, %struct.sv** %op_sv, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %94, i32 0, i32 2
  %95 = load i32, i32* %sv_flags, align 4
  %and137 = and i32 %95, 65536
  %tobool138 = icmp ne i32 %and137, 0
  br i1 %tobool138, label %cond.true.139, label %cond.false.141

cond.true.139:                                    ; preds = %land.lhs.true.136
  %96 = load %struct.op*, %struct.op** %pop, align 8
  %97 = bitcast %struct.op* %96 to %struct.svop*
  %op_sv140 = getelementptr inbounds %struct.svop, %struct.svop* %97, i32 0, i32 8
  %98 = load %struct.sv*, %struct.sv** %op_sv140, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %98, i32 0, i32 0
  %99 = load i8*, i8** %sv_any, align 8
  %100 = bitcast i8* %99 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %100, i32 0, i32 3
  %101 = load i64, i64* %xiv_iv, align 8
  br label %cond.end.143

cond.false.141:                                   ; preds = %land.lhs.true.136
  %102 = load %struct.op*, %struct.op** %pop, align 8
  %103 = bitcast %struct.op* %102 to %struct.svop*
  %op_sv142 = getelementptr inbounds %struct.svop, %struct.svop* %103, i32 0, i32 8
  %104 = load %struct.sv*, %struct.sv** %op_sv142, align 8
  %call = call i64 @Perl_sv_2iv(%struct.sv* %104)
  br label %cond.end.143

cond.end.143:                                     ; preds = %cond.false.141, %cond.true.139
  %cond144 = phi i64 [ %101, %cond.true.139 ], [ %call, %cond.false.141 ]
  %105 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_arybase = getelementptr inbounds %struct.cop, %struct.cop* %105, i32 0, i32 12
  %106 = load i32, i32* %cop_arybase, align 4
  %conv145 = sext i32 %106 to i64
  %sub = sub nsw i64 %cond144, %conv145
  store i64 %sub, i64* %i, align 8
  %cmp146 = icmp sle i64 %sub, 255
  br i1 %cmp146, label %land.lhs.true.148, label %if.end.205

land.lhs.true.148:                                ; preds = %cond.end.143
  %107 = load i64, i64* %i, align 8
  %cmp149 = icmp sge i64 %107, 0
  br i1 %cmp149, label %if.then.151, label %if.end.205

if.then.151:                                      ; preds = %land.lhs.true.148
  %108 = load %struct.op*, %struct.op** %pop, align 8
  %109 = bitcast %struct.op* %108 to %struct.svop*
  %op_private152 = getelementptr inbounds %struct.svop, %struct.svop* %109, i32 0, i32 7
  %110 = load i8, i8* %op_private152, align 1
  %conv153 = zext i8 %110 to i32
  %and154 = and i32 %conv153, 8
  %tobool155 = icmp ne i32 %and154, 0
  br i1 %tobool155, label %if.then.156, label %if.end.157

if.then.156:                                      ; preds = %if.then.151
  %111 = load %struct.op*, %struct.op** %pop, align 8
  call void @S_no_bareword_allowed(%struct.op* %111)
  br label %if.end.157

if.end.157:                                       ; preds = %if.then.156, %if.then.151
  %112 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type158 = getelementptr inbounds %struct.op, %struct.op* %112, i32 0, i32 4
  %113 = load i16, i16* %op_type158, align 2
  %conv159 = zext i16 %113 to i32
  %cmp160 = icmp eq i32 %conv159, 7
  br i1 %cmp160, label %if.then.162, label %if.end.164

if.then.162:                                      ; preds = %if.end.157
  %114 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next163 = getelementptr inbounds %struct.op, %struct.op* %114, i32 0, i32 0
  %115 = load %struct.op*, %struct.op** %op_next163, align 8
  call void @Perl_op_null(%struct.op* %115)
  br label %if.end.164

if.end.164:                                       ; preds = %if.then.162, %if.end.157
  %116 = load %struct.op*, %struct.op** %pop, align 8
  %op_next165 = getelementptr inbounds %struct.op, %struct.op* %116, i32 0, i32 0
  %117 = load %struct.op*, %struct.op** %op_next165, align 8
  call void @Perl_op_null(%struct.op* %117)
  %118 = load %struct.op*, %struct.op** %pop, align 8
  call void @Perl_op_null(%struct.op* %118)
  %119 = load %struct.op*, %struct.op** %pop, align 8
  %op_next166 = getelementptr inbounds %struct.op, %struct.op* %119, i32 0, i32 0
  %120 = load %struct.op*, %struct.op** %op_next166, align 8
  %op_flags167 = getelementptr inbounds %struct.op, %struct.op* %120, i32 0, i32 6
  %121 = load i8, i8* %op_flags167, align 1
  %conv168 = zext i8 %121 to i32
  %and169 = and i32 %conv168, 32
  %122 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags170 = getelementptr inbounds %struct.op, %struct.op* %122, i32 0, i32 6
  %123 = load i8, i8* %op_flags170, align 1
  %conv171 = zext i8 %123 to i32
  %or172 = or i32 %conv171, %and169
  %conv173 = trunc i32 %or172 to i8
  store i8 %conv173, i8* %op_flags170, align 1
  %124 = load %struct.op*, %struct.op** %pop, align 8
  %op_next174 = getelementptr inbounds %struct.op, %struct.op* %124, i32 0, i32 0
  %125 = load %struct.op*, %struct.op** %op_next174, align 8
  %op_next175 = getelementptr inbounds %struct.op, %struct.op* %125, i32 0, i32 0
  %126 = load %struct.op*, %struct.op** %op_next175, align 8
  %127 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next176 = getelementptr inbounds %struct.op, %struct.op* %127, i32 0, i32 0
  store %struct.op* %126, %struct.op** %op_next176, align 8
  %128 = load %struct.op* ()*, %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 126), align 8
  %129 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_ppaddr = getelementptr inbounds %struct.op, %struct.op* %129, i32 0, i32 2
  store %struct.op* ()* %128, %struct.op* ()** %op_ppaddr, align 8
  %130 = load i64, i64* %i, align 8
  %conv177 = trunc i64 %130 to i8
  %131 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private178 = getelementptr inbounds %struct.op, %struct.op* %131, i32 0, i32 7
  store i8 %conv177, i8* %op_private178, align 1
  %132 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type179 = getelementptr inbounds %struct.op, %struct.op* %132, i32 0, i32 4
  %133 = load i16, i16* %op_type179, align 2
  %conv180 = zext i16 %133 to i32
  %cmp181 = icmp eq i32 %conv180, 7
  br i1 %cmp181, label %if.then.183, label %if.else.198

if.then.183:                                      ; preds = %if.end.164
  %134 = load %struct.op*, %struct.op** %o.addr, align 8
  %135 = bitcast %struct.op* %134 to %struct.svop*
  %op_sv184 = getelementptr inbounds %struct.svop, %struct.svop* %135, i32 0, i32 8
  %136 = load %struct.sv*, %struct.sv** %op_sv184, align 8
  %137 = bitcast %struct.sv* %136 to %struct.gv*
  store %struct.gv* %137, %struct.gv** %gv, align 8
  %138 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any185 = getelementptr inbounds %struct.gv, %struct.gv* %138, i32 0, i32 0
  %139 = load %struct.xpvgv*, %struct.xpvgv** %sv_any185, align 8
  %xgv_gp = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %139, i32 0, i32 7
  %140 = load %struct.gp*, %struct.gp** %xgv_gp, align 8
  %gp_av = getelementptr inbounds %struct.gp, %struct.gp* %140, i32 0, i32 4
  %141 = load %struct.av*, %struct.av** %gp_av, align 8
  %tobool186 = icmp ne %struct.av* %141, null
  br i1 %tobool186, label %cond.true.187, label %cond.false.191

cond.true.187:                                    ; preds = %if.then.183
  %142 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any188 = getelementptr inbounds %struct.gv, %struct.gv* %142, i32 0, i32 0
  %143 = load %struct.xpvgv*, %struct.xpvgv** %sv_any188, align 8
  %xgv_gp189 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %143, i32 0, i32 7
  %144 = load %struct.gp*, %struct.gp** %xgv_gp189, align 8
  %gp_av190 = getelementptr inbounds %struct.gp, %struct.gp* %144, i32 0, i32 4
  %145 = load %struct.av*, %struct.av** %gp_av190, align 8
  br label %cond.end.196

cond.false.191:                                   ; preds = %if.then.183
  %146 = load %struct.gv*, %struct.gv** %gv, align 8
  %call192 = call %struct.gv* @Perl_gv_AVadd(%struct.gv* %146)
  %sv_any193 = getelementptr inbounds %struct.gv, %struct.gv* %call192, i32 0, i32 0
  %147 = load %struct.xpvgv*, %struct.xpvgv** %sv_any193, align 8
  %xgv_gp194 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %147, i32 0, i32 7
  %148 = load %struct.gp*, %struct.gp** %xgv_gp194, align 8
  %gp_av195 = getelementptr inbounds %struct.gp, %struct.gp* %148, i32 0, i32 4
  %149 = load %struct.av*, %struct.av** %gp_av195, align 8
  br label %cond.end.196

cond.end.196:                                     ; preds = %cond.false.191, %cond.true.187
  %cond197 = phi %struct.av* [ %145, %cond.true.187 ], [ %149, %cond.false.191 ]
  br label %if.end.203

if.else.198:                                      ; preds = %if.end.164
  %150 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags199 = getelementptr inbounds %struct.op, %struct.op* %150, i32 0, i32 6
  %151 = load i8, i8* %op_flags199, align 1
  %conv200 = zext i8 %151 to i32
  %or201 = or i32 %conv200, 128
  %conv202 = trunc i32 %or201 to i8
  store i8 %conv202, i8* %op_flags199, align 1
  br label %if.end.203

if.end.203:                                       ; preds = %if.else.198, %cond.end.196
  %152 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type204 = getelementptr inbounds %struct.op, %struct.op* %152, i32 0, i32 4
  store i16 126, i16* %op_type204, align 2
  br label %if.end.205

if.end.205:                                       ; preds = %if.end.203, %land.lhs.true.148, %cond.end.143, %land.lhs.true.130, %land.lhs.true.124, %land.lhs.true.121, %land.lhs.true.116, %cond.end
  %153 = load i16, i16* @PL_op_seqmax, align 2
  %inc206 = add i16 %153, 1
  store i16 %inc206, i16* @PL_op_seqmax, align 2
  %154 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_seq207 = getelementptr inbounds %struct.op, %struct.op* %154, i32 0, i32 5
  store i16 %153, i16* %op_seq207, align 2
  br label %sw.epilog

if.end.208:                                       ; preds = %lor.lhs.false.101
  %155 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next209 = getelementptr inbounds %struct.op, %struct.op* %155, i32 0, i32 0
  %156 = load %struct.op*, %struct.op** %op_next209, align 8
  %op_type210 = getelementptr inbounds %struct.op, %struct.op* %156, i32 0, i32 4
  %157 = load i16, i16* %op_type210, align 2
  %conv211 = zext i16 %157 to i32
  %cmp212 = icmp eq i32 %conv211, 15
  br i1 %cmp212, label %if.then.214, label %if.else.236

if.then.214:                                      ; preds = %if.end.208
  %158 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next215 = getelementptr inbounds %struct.op, %struct.op* %158, i32 0, i32 0
  %159 = load %struct.op*, %struct.op** %op_next215, align 8
  %op_private216 = getelementptr inbounds %struct.op, %struct.op* %159, i32 0, i32 7
  %160 = load i8, i8* %op_private216, align 1
  %conv217 = zext i8 %160 to i32
  %and218 = and i32 %conv217, 96
  %tobool219 = icmp ne i32 %and218, 0
  br i1 %tobool219, label %if.end.235, label %if.then.220

if.then.220:                                      ; preds = %if.then.214
  %161 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next221 = getelementptr inbounds %struct.op, %struct.op* %161, i32 0, i32 0
  %162 = load %struct.op*, %struct.op** %op_next221, align 8
  call void @Perl_op_null(%struct.op* %162)
  %163 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next222 = getelementptr inbounds %struct.op, %struct.op* %163, i32 0, i32 0
  %164 = load %struct.op*, %struct.op** %op_next222, align 8
  %op_private223 = getelementptr inbounds %struct.op, %struct.op* %164, i32 0, i32 7
  %165 = load i8, i8* %op_private223, align 1
  %conv224 = zext i8 %165 to i32
  %and225 = and i32 %conv224, 144
  %166 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private226 = getelementptr inbounds %struct.op, %struct.op* %166, i32 0, i32 7
  %167 = load i8, i8* %op_private226, align 1
  %conv227 = zext i8 %167 to i32
  %or228 = or i32 %conv227, %and225
  %conv229 = trunc i32 %or228 to i8
  store i8 %conv229, i8* %op_private226, align 1
  %168 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next230 = getelementptr inbounds %struct.op, %struct.op* %168, i32 0, i32 0
  %169 = load %struct.op*, %struct.op** %op_next230, align 8
  %op_next231 = getelementptr inbounds %struct.op, %struct.op* %169, i32 0, i32 0
  %170 = load %struct.op*, %struct.op** %op_next231, align 8
  %171 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next232 = getelementptr inbounds %struct.op, %struct.op* %171, i32 0, i32 0
  store %struct.op* %170, %struct.op** %op_next232, align 8
  %172 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type233 = getelementptr inbounds %struct.op, %struct.op* %172, i32 0, i32 4
  store i16 6, i16* %op_type233, align 2
  %173 = load %struct.op* ()*, %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 6), align 8
  %174 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_ppaddr234 = getelementptr inbounds %struct.op, %struct.op* %174, i32 0, i32 2
  store %struct.op* ()* %173, %struct.op* ()** %op_ppaddr234, align 8
  br label %if.end.235

if.end.235:                                       ; preds = %if.then.220, %if.then.214
  br label %if.end.319

if.else.236:                                      ; preds = %if.end.208
  %175 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private237 = getelementptr inbounds %struct.op, %struct.op* %175, i32 0, i32 7
  %176 = load i8, i8* %op_private237, align 1
  %conv238 = zext i8 %176 to i32
  %and239 = and i32 %conv238, 32
  %tobool240 = icmp ne i32 %and239, 0
  br i1 %tobool240, label %land.lhs.true.241, label %if.else.287

land.lhs.true.241:                                ; preds = %if.else.236
  %177 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings = getelementptr inbounds %struct.cop, %struct.cop* %177, i32 0, i32 14
  %178 = load %struct.sv*, %struct.sv** %cop_warnings, align 8
  %cmp242 = icmp ne %struct.sv* %178, null
  br i1 %cmp242, label %land.lhs.true.244, label %lor.lhs.false.258

land.lhs.true.244:                                ; preds = %land.lhs.true.241
  %179 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings245 = getelementptr inbounds %struct.cop, %struct.cop* %179, i32 0, i32 14
  %180 = load %struct.sv*, %struct.sv** %cop_warnings245, align 8
  %cmp246 = icmp ne %struct.sv* %180, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 2)
  br i1 %cmp246, label %land.lhs.true.248, label %lor.lhs.false.258

land.lhs.true.248:                                ; preds = %land.lhs.true.244
  %181 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings249 = getelementptr inbounds %struct.cop, %struct.cop* %181, i32 0, i32 14
  %182 = load %struct.sv*, %struct.sv** %cop_warnings249, align 8
  %cmp250 = icmp eq %struct.sv* %182, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 1)
  br i1 %cmp250, label %if.then.266, label %lor.lhs.false.252

lor.lhs.false.252:                                ; preds = %land.lhs.true.248
  %183 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings253 = getelementptr inbounds %struct.cop, %struct.cop* %183, i32 0, i32 14
  %184 = load %struct.sv*, %struct.sv** %cop_warnings253, align 8
  %sv_any254 = getelementptr inbounds %struct.sv, %struct.sv* %184, i32 0, i32 0
  %185 = load i8*, i8** %sv_any254, align 8
  %186 = bitcast i8* %185 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %186, i32 0, i32 0
  %187 = load i8*, i8** %xpv_pv, align 8
  %arrayidx = getelementptr inbounds i8, i8* %187, i64 8
  %188 = load i8, i8* %arrayidx, align 1
  %conv255 = sext i8 %188 to i32
  %and256 = and i32 %conv255, 64
  %tobool257 = icmp ne i32 %and256, 0
  br i1 %tobool257, label %if.then.266, label %lor.lhs.false.258

lor.lhs.false.258:                                ; preds = %lor.lhs.false.252, %land.lhs.true.244, %land.lhs.true.241
  %189 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings259 = getelementptr inbounds %struct.cop, %struct.cop* %189, i32 0, i32 14
  %190 = load %struct.sv*, %struct.sv** %cop_warnings259, align 8
  %cmp260 = icmp eq %struct.sv* %190, null
  br i1 %cmp260, label %land.lhs.true.262, label %if.else.287

land.lhs.true.262:                                ; preds = %lor.lhs.false.258
  %191 = load i8, i8* @PL_dowarn, align 1
  %conv263 = zext i8 %191 to i32
  %and264 = and i32 %conv263, 1
  %tobool265 = icmp ne i32 %and264, 0
  br i1 %tobool265, label %if.then.266, label %if.else.287

if.then.266:                                      ; preds = %land.lhs.true.262, %lor.lhs.false.252, %land.lhs.true.248
  %192 = load %struct.op*, %struct.op** %o.addr, align 8
  %193 = bitcast %struct.op* %192 to %struct.svop*
  %op_sv268 = getelementptr inbounds %struct.svop, %struct.svop* %193, i32 0, i32 8
  %194 = load %struct.sv*, %struct.sv** %op_sv268, align 8
  %195 = bitcast %struct.sv* %194 to %struct.gv*
  store %struct.gv* %195, %struct.gv** %gv267, align 8
  %196 = load %struct.gv*, %struct.gv** %gv267, align 8
  %sv_flags269 = getelementptr inbounds %struct.gv, %struct.gv* %196, i32 0, i32 2
  %197 = load i32, i32* %sv_flags269, align 4
  %and270 = and i32 %197, 255
  %cmp271 = icmp eq i32 %and270, 13
  br i1 %cmp271, label %land.lhs.true.273, label %if.end.286

land.lhs.true.273:                                ; preds = %if.then.266
  %198 = load %struct.gv*, %struct.gv** %gv267, align 8
  %sv_any274 = getelementptr inbounds %struct.gv, %struct.gv* %198, i32 0, i32 0
  %199 = load %struct.xpvgv*, %struct.xpvgv** %sv_any274, align 8
  %xgv_gp275 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %199, i32 0, i32 7
  %200 = load %struct.gp*, %struct.gp** %xgv_gp275, align 8
  %gp_cv = getelementptr inbounds %struct.gp, %struct.gp* %200, i32 0, i32 7
  %201 = load %struct.cv*, %struct.cv** %gp_cv, align 8
  %tobool276 = icmp ne %struct.cv* %201, null
  br i1 %tobool276, label %land.lhs.true.277, label %if.end.286

land.lhs.true.277:                                ; preds = %land.lhs.true.273
  %202 = load %struct.gv*, %struct.gv** %gv267, align 8
  %sv_any278 = getelementptr inbounds %struct.gv, %struct.gv* %202, i32 0, i32 0
  %203 = load %struct.xpvgv*, %struct.xpvgv** %sv_any278, align 8
  %xgv_gp279 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %203, i32 0, i32 7
  %204 = load %struct.gp*, %struct.gp** %xgv_gp279, align 8
  %gp_cv280 = getelementptr inbounds %struct.gp, %struct.gp* %204, i32 0, i32 7
  %205 = load %struct.cv*, %struct.cv** %gp_cv280, align 8
  %sv_any281 = getelementptr inbounds %struct.cv, %struct.cv* %205, i32 0, i32 0
  %206 = load %struct.xpvcv*, %struct.xpvcv** %sv_any281, align 8
  %207 = bitcast %struct.xpvcv* %206 to %struct.xpv*
  %xpv_pv282 = getelementptr inbounds %struct.xpv, %struct.xpv* %207, i32 0, i32 0
  %208 = load i8*, i8** %xpv_pv282, align 8
  %tobool283 = icmp ne i8* %208, null
  br i1 %tobool283, label %if.then.284, label %if.end.286

if.then.284:                                      ; preds = %land.lhs.true.277
  %call285 = call %struct.sv* @Perl_sv_newmortal()
  store %struct.sv* %call285, %struct.sv** %sv, align 8
  %209 = load %struct.sv*, %struct.sv** %sv, align 8
  %210 = load %struct.gv*, %struct.gv** %gv267, align 8
  call void @Perl_gv_efullname4(%struct.sv* %209, %struct.gv* %210, i8* null, i8 signext 1)
  %211 = load %struct.sv*, %struct.sv** %sv, align 8
  call void (i32, i8*, ...) @Perl_warner(i32 35, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.134, i32 0, i32 0), %struct.sv* %211)
  br label %if.end.286

if.end.286:                                       ; preds = %if.then.284, %land.lhs.true.277, %land.lhs.true.273, %if.then.266
  br label %if.end.318

if.else.287:                                      ; preds = %land.lhs.true.262, %lor.lhs.false.258, %if.else.236
  %212 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next288 = getelementptr inbounds %struct.op, %struct.op* %212, i32 0, i32 0
  %213 = load %struct.op*, %struct.op** %op_next288, align 8
  %op_type289 = getelementptr inbounds %struct.op, %struct.op* %213, i32 0, i32 4
  %214 = load i16, i16* %op_type289, align 2
  %conv290 = zext i16 %214 to i32
  %cmp291 = icmp eq i32 %conv290, 26
  br i1 %cmp291, label %land.lhs.true.293, label %if.end.317

land.lhs.true.293:                                ; preds = %if.else.287
  %215 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next294 = getelementptr inbounds %struct.op, %struct.op* %215, i32 0, i32 0
  %216 = load %struct.op*, %struct.op** %op_next294, align 8
  %op_next295 = getelementptr inbounds %struct.op, %struct.op* %216, i32 0, i32 0
  %217 = load %struct.op*, %struct.op** %op_next295, align 8
  %op_type296 = getelementptr inbounds %struct.op, %struct.op* %217, i32 0, i32 4
  %218 = load i16, i16* %op_type296, align 2
  %conv297 = zext i16 %218 to i32
  %cmp298 = icmp eq i32 %conv297, 66
  br i1 %cmp298, label %land.lhs.true.300, label %if.end.317

land.lhs.true.300:                                ; preds = %land.lhs.true.293
  %219 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next301 = getelementptr inbounds %struct.op, %struct.op* %219, i32 0, i32 0
  %220 = load %struct.op*, %struct.op** %op_next301, align 8
  %op_next302 = getelementptr inbounds %struct.op, %struct.op* %220, i32 0, i32 0
  %221 = load %struct.op*, %struct.op** %op_next302, align 8
  %op_flags303 = getelementptr inbounds %struct.op, %struct.op* %221, i32 0, i32 6
  %222 = load i8, i8* %op_flags303, align 1
  %conv304 = zext i8 %222 to i32
  %and305 = and i32 %conv304, 64
  %tobool306 = icmp ne i32 %and305, 0
  br i1 %tobool306, label %if.then.307, label %if.end.317

if.then.307:                                      ; preds = %land.lhs.true.300
  %223 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type308 = getelementptr inbounds %struct.op, %struct.op* %223, i32 0, i32 4
  store i16 27, i16* %op_type308, align 2
  %224 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags309 = getelementptr inbounds %struct.op, %struct.op* %224, i32 0, i32 6
  %225 = load i8, i8* %op_flags309, align 1
  %conv310 = zext i8 %225 to i32
  %or311 = or i32 %conv310, 64
  %conv312 = trunc i32 %or311 to i8
  store i8 %conv312, i8* %op_flags309, align 1
  %226 = load %struct.op* ()*, %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 27), align 8
  %227 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_ppaddr313 = getelementptr inbounds %struct.op, %struct.op* %227, i32 0, i32 2
  store %struct.op* ()* %226, %struct.op* ()** %op_ppaddr313, align 8
  %228 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next314 = getelementptr inbounds %struct.op, %struct.op* %228, i32 0, i32 0
  %229 = load %struct.op*, %struct.op** %op_next314, align 8
  %op_next315 = getelementptr inbounds %struct.op, %struct.op* %229, i32 0, i32 0
  %230 = load %struct.op*, %struct.op** %op_next315, align 8
  call void @Perl_op_null(%struct.op* %230)
  %231 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next316 = getelementptr inbounds %struct.op, %struct.op* %231, i32 0, i32 0
  %232 = load %struct.op*, %struct.op** %op_next316, align 8
  call void @Perl_op_null(%struct.op* %232)
  br label %if.end.317

if.end.317:                                       ; preds = %if.then.307, %land.lhs.true.300, %land.lhs.true.293, %if.else.287
  br label %if.end.318

if.end.318:                                       ; preds = %if.end.317, %if.end.286
  br label %if.end.319

if.end.319:                                       ; preds = %if.end.318, %if.end.235
  %233 = load i16, i16* @PL_op_seqmax, align 2
  %inc320 = add i16 %233, 1
  store i16 %inc320, i16* @PL_op_seqmax, align 2
  %234 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_seq321 = getelementptr inbounds %struct.op, %struct.op* %234, i32 0, i32 5
  store i16 %233, i16* %op_seq321, align 2
  br label %sw.epilog

sw.bb.322:                                        ; preds = %if.end.12, %if.end.12, %if.end.12, %if.end.12, %if.end.12, %if.end.12, %if.end.12, %if.end.12
  %235 = load i16, i16* @PL_op_seqmax, align 2
  %inc323 = add i16 %235, 1
  store i16 %inc323, i16* @PL_op_seqmax, align 2
  %236 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_seq324 = getelementptr inbounds %struct.op, %struct.op* %236, i32 0, i32 5
  store i16 %235, i16* %op_seq324, align 2
  br label %while.cond

while.cond:                                       ; preds = %while.body, %sw.bb.322
  %237 = load %struct.op*, %struct.op** @PL_op, align 8
  %238 = bitcast %struct.op* %237 to %struct.logop*
  %op_other = getelementptr inbounds %struct.logop, %struct.logop* %238, i32 0, i32 9
  %239 = load %struct.op*, %struct.op** %op_other, align 8
  %op_type325 = getelementptr inbounds %struct.op, %struct.op* %239, i32 0, i32 4
  %240 = load i16, i16* %op_type325, align 2
  %conv326 = zext i16 %240 to i32
  %cmp327 = icmp eq i32 %conv326, 0
  br i1 %cmp327, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %241 = load %struct.op*, %struct.op** @PL_op, align 8
  %242 = bitcast %struct.op* %241 to %struct.logop*
  %op_other329 = getelementptr inbounds %struct.logop, %struct.logop* %242, i32 0, i32 9
  %243 = load %struct.op*, %struct.op** %op_other329, align 8
  %op_next330 = getelementptr inbounds %struct.op, %struct.op* %243, i32 0, i32 0
  %244 = load %struct.op*, %struct.op** %op_next330, align 8
  %245 = load %struct.op*, %struct.op** @PL_op, align 8
  %246 = bitcast %struct.op* %245 to %struct.logop*
  %op_other331 = getelementptr inbounds %struct.logop, %struct.logop* %246, i32 0, i32 9
  store %struct.op* %244, %struct.op** %op_other331, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %247 = load %struct.op*, %struct.op** @PL_op, align 8
  %248 = bitcast %struct.op* %247 to %struct.logop*
  %op_other332 = getelementptr inbounds %struct.logop, %struct.logop* %248, i32 0, i32 9
  %249 = load %struct.op*, %struct.op** %op_other332, align 8
  call void @Perl_peep(%struct.op* %249)
  br label %sw.epilog

sw.bb.333:                                        ; preds = %if.end.12, %if.end.12
  %250 = load i16, i16* @PL_op_seqmax, align 2
  %inc334 = add i16 %250, 1
  store i16 %inc334, i16* @PL_op_seqmax, align 2
  %251 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_seq335 = getelementptr inbounds %struct.op, %struct.op* %251, i32 0, i32 5
  store i16 %250, i16* %op_seq335, align 2
  br label %while.cond.336

while.cond.336:                                   ; preds = %while.body.341, %sw.bb.333
  %252 = load %struct.op*, %struct.op** @PL_op, align 8
  %253 = bitcast %struct.op* %252 to %struct.loop*
  %op_redoop = getelementptr inbounds %struct.loop, %struct.loop* %253, i32 0, i32 10
  %254 = load %struct.op*, %struct.op** %op_redoop, align 8
  %op_type337 = getelementptr inbounds %struct.op, %struct.op* %254, i32 0, i32 4
  %255 = load i16, i16* %op_type337, align 2
  %conv338 = zext i16 %255 to i32
  %cmp339 = icmp eq i32 %conv338, 0
  br i1 %cmp339, label %while.body.341, label %while.end.345

while.body.341:                                   ; preds = %while.cond.336
  %256 = load %struct.op*, %struct.op** @PL_op, align 8
  %257 = bitcast %struct.op* %256 to %struct.loop*
  %op_redoop342 = getelementptr inbounds %struct.loop, %struct.loop* %257, i32 0, i32 10
  %258 = load %struct.op*, %struct.op** %op_redoop342, align 8
  %op_next343 = getelementptr inbounds %struct.op, %struct.op* %258, i32 0, i32 0
  %259 = load %struct.op*, %struct.op** %op_next343, align 8
  %260 = load %struct.op*, %struct.op** @PL_op, align 8
  %261 = bitcast %struct.op* %260 to %struct.loop*
  %op_redoop344 = getelementptr inbounds %struct.loop, %struct.loop* %261, i32 0, i32 10
  store %struct.op* %259, %struct.op** %op_redoop344, align 8
  br label %while.cond.336

while.end.345:                                    ; preds = %while.cond.336
  %262 = load %struct.op*, %struct.op** @PL_op, align 8
  %263 = bitcast %struct.op* %262 to %struct.loop*
  %op_redoop346 = getelementptr inbounds %struct.loop, %struct.loop* %263, i32 0, i32 10
  %264 = load %struct.op*, %struct.op** %op_redoop346, align 8
  call void @Perl_peep(%struct.op* %264)
  br label %while.cond.347

while.cond.347:                                   ; preds = %while.body.352, %while.end.345
  %265 = load %struct.op*, %struct.op** @PL_op, align 8
  %266 = bitcast %struct.op* %265 to %struct.loop*
  %op_nextop = getelementptr inbounds %struct.loop, %struct.loop* %266, i32 0, i32 11
  %267 = load %struct.op*, %struct.op** %op_nextop, align 8
  %op_type348 = getelementptr inbounds %struct.op, %struct.op* %267, i32 0, i32 4
  %268 = load i16, i16* %op_type348, align 2
  %conv349 = zext i16 %268 to i32
  %cmp350 = icmp eq i32 %conv349, 0
  br i1 %cmp350, label %while.body.352, label %while.end.356

while.body.352:                                   ; preds = %while.cond.347
  %269 = load %struct.op*, %struct.op** @PL_op, align 8
  %270 = bitcast %struct.op* %269 to %struct.loop*
  %op_nextop353 = getelementptr inbounds %struct.loop, %struct.loop* %270, i32 0, i32 11
  %271 = load %struct.op*, %struct.op** %op_nextop353, align 8
  %op_next354 = getelementptr inbounds %struct.op, %struct.op* %271, i32 0, i32 0
  %272 = load %struct.op*, %struct.op** %op_next354, align 8
  %273 = load %struct.op*, %struct.op** @PL_op, align 8
  %274 = bitcast %struct.op* %273 to %struct.loop*
  %op_nextop355 = getelementptr inbounds %struct.loop, %struct.loop* %274, i32 0, i32 11
  store %struct.op* %272, %struct.op** %op_nextop355, align 8
  br label %while.cond.347

while.end.356:                                    ; preds = %while.cond.347
  %275 = load %struct.op*, %struct.op** @PL_op, align 8
  %276 = bitcast %struct.op* %275 to %struct.loop*
  %op_nextop357 = getelementptr inbounds %struct.loop, %struct.loop* %276, i32 0, i32 11
  %277 = load %struct.op*, %struct.op** %op_nextop357, align 8
  call void @Perl_peep(%struct.op* %277)
  br label %while.cond.358

while.cond.358:                                   ; preds = %while.body.363, %while.end.356
  %278 = load %struct.op*, %struct.op** @PL_op, align 8
  %279 = bitcast %struct.op* %278 to %struct.loop*
  %op_lastop = getelementptr inbounds %struct.loop, %struct.loop* %279, i32 0, i32 12
  %280 = load %struct.op*, %struct.op** %op_lastop, align 8
  %op_type359 = getelementptr inbounds %struct.op, %struct.op* %280, i32 0, i32 4
  %281 = load i16, i16* %op_type359, align 2
  %conv360 = zext i16 %281 to i32
  %cmp361 = icmp eq i32 %conv360, 0
  br i1 %cmp361, label %while.body.363, label %while.end.367

while.body.363:                                   ; preds = %while.cond.358
  %282 = load %struct.op*, %struct.op** @PL_op, align 8
  %283 = bitcast %struct.op* %282 to %struct.loop*
  %op_lastop364 = getelementptr inbounds %struct.loop, %struct.loop* %283, i32 0, i32 12
  %284 = load %struct.op*, %struct.op** %op_lastop364, align 8
  %op_next365 = getelementptr inbounds %struct.op, %struct.op* %284, i32 0, i32 0
  %285 = load %struct.op*, %struct.op** %op_next365, align 8
  %286 = load %struct.op*, %struct.op** @PL_op, align 8
  %287 = bitcast %struct.op* %286 to %struct.loop*
  %op_lastop366 = getelementptr inbounds %struct.loop, %struct.loop* %287, i32 0, i32 12
  store %struct.op* %285, %struct.op** %op_lastop366, align 8
  br label %while.cond.358

while.end.367:                                    ; preds = %while.cond.358
  %288 = load %struct.op*, %struct.op** @PL_op, align 8
  %289 = bitcast %struct.op* %288 to %struct.loop*
  %op_lastop368 = getelementptr inbounds %struct.loop, %struct.loop* %289, i32 0, i32 12
  %290 = load %struct.op*, %struct.op** %op_lastop368, align 8
  call void @Perl_peep(%struct.op* %290)
  br label %sw.epilog

sw.bb.369:                                        ; preds = %if.end.12, %if.end.12, %if.end.12
  %291 = load i16, i16* @PL_op_seqmax, align 2
  %inc370 = add i16 %291, 1
  store i16 %inc370, i16* @PL_op_seqmax, align 2
  %292 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_seq371 = getelementptr inbounds %struct.op, %struct.op* %292, i32 0, i32 5
  store i16 %291, i16* %op_seq371, align 2
  br label %while.cond.372

while.cond.372:                                   ; preds = %while.body.379, %sw.bb.369
  %293 = load %struct.op*, %struct.op** @PL_op, align 8
  %294 = bitcast %struct.op* %293 to %struct.pmop*
  %op_pmreplstart = getelementptr inbounds %struct.pmop, %struct.pmop* %294, i32 0, i32 11
  %295 = load %struct.op*, %struct.op** %op_pmreplstart, align 8
  %tobool373 = icmp ne %struct.op* %295, null
  br i1 %tobool373, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond.372
  %296 = load %struct.op*, %struct.op** @PL_op, align 8
  %297 = bitcast %struct.op* %296 to %struct.pmop*
  %op_pmreplstart374 = getelementptr inbounds %struct.pmop, %struct.pmop* %297, i32 0, i32 11
  %298 = load %struct.op*, %struct.op** %op_pmreplstart374, align 8
  %op_type375 = getelementptr inbounds %struct.op, %struct.op* %298, i32 0, i32 4
  %299 = load i16, i16* %op_type375, align 2
  %conv376 = zext i16 %299 to i32
  %cmp377 = icmp eq i32 %conv376, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond.372
  %300 = phi i1 [ false, %while.cond.372 ], [ %cmp377, %land.rhs ]
  br i1 %300, label %while.body.379, label %while.end.383

while.body.379:                                   ; preds = %land.end
  %301 = load %struct.op*, %struct.op** @PL_op, align 8
  %302 = bitcast %struct.op* %301 to %struct.pmop*
  %op_pmreplstart380 = getelementptr inbounds %struct.pmop, %struct.pmop* %302, i32 0, i32 11
  %303 = load %struct.op*, %struct.op** %op_pmreplstart380, align 8
  %op_next381 = getelementptr inbounds %struct.op, %struct.op* %303, i32 0, i32 0
  %304 = load %struct.op*, %struct.op** %op_next381, align 8
  %305 = load %struct.op*, %struct.op** @PL_op, align 8
  %306 = bitcast %struct.op* %305 to %struct.pmop*
  %op_pmreplstart382 = getelementptr inbounds %struct.pmop, %struct.pmop* %306, i32 0, i32 11
  store %struct.op* %304, %struct.op** %op_pmreplstart382, align 8
  br label %while.cond.372

while.end.383:                                    ; preds = %land.end
  %307 = load %struct.op*, %struct.op** @PL_op, align 8
  %308 = bitcast %struct.op* %307 to %struct.pmop*
  %op_pmreplstart384 = getelementptr inbounds %struct.pmop, %struct.pmop* %308, i32 0, i32 11
  %309 = load %struct.op*, %struct.op** %op_pmreplstart384, align 8
  call void @Perl_peep(%struct.op* %309)
  br label %sw.epilog

sw.bb.385:                                        ; preds = %if.end.12
  %310 = load i16, i16* @PL_op_seqmax, align 2
  %inc386 = add i16 %310, 1
  store i16 %inc386, i16* @PL_op_seqmax, align 2
  %311 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_seq387 = getelementptr inbounds %struct.op, %struct.op* %311, i32 0, i32 5
  store i16 %310, i16* %op_seq387, align 2
  %312 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings388 = getelementptr inbounds %struct.cop, %struct.cop* %312, i32 0, i32 14
  %313 = load %struct.sv*, %struct.sv** %cop_warnings388, align 8
  %cmp389 = icmp ne %struct.sv* %313, null
  br i1 %cmp389, label %land.lhs.true.391, label %lor.lhs.false.407

land.lhs.true.391:                                ; preds = %sw.bb.385
  %314 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings392 = getelementptr inbounds %struct.cop, %struct.cop* %314, i32 0, i32 14
  %315 = load %struct.sv*, %struct.sv** %cop_warnings392, align 8
  %cmp393 = icmp ne %struct.sv* %315, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 2)
  br i1 %cmp393, label %land.lhs.true.395, label %lor.lhs.false.407

land.lhs.true.395:                                ; preds = %land.lhs.true.391
  %316 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings396 = getelementptr inbounds %struct.cop, %struct.cop* %316, i32 0, i32 14
  %317 = load %struct.sv*, %struct.sv** %cop_warnings396, align 8
  %cmp397 = icmp eq %struct.sv* %317, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 1)
  br i1 %cmp397, label %land.lhs.true.415, label %lor.lhs.false.399

lor.lhs.false.399:                                ; preds = %land.lhs.true.395
  %318 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings400 = getelementptr inbounds %struct.cop, %struct.cop* %318, i32 0, i32 14
  %319 = load %struct.sv*, %struct.sv** %cop_warnings400, align 8
  %sv_any401 = getelementptr inbounds %struct.sv, %struct.sv* %319, i32 0, i32 0
  %320 = load i8*, i8** %sv_any401, align 8
  %321 = bitcast i8* %320 to %struct.xpv*
  %xpv_pv402 = getelementptr inbounds %struct.xpv, %struct.xpv* %321, i32 0, i32 0
  %322 = load i8*, i8** %xpv_pv402, align 8
  %arrayidx403 = getelementptr inbounds i8, i8* %322, i64 7
  %323 = load i8, i8* %arrayidx403, align 1
  %conv404 = sext i8 %323 to i32
  %and405 = and i32 %conv404, 1
  %tobool406 = icmp ne i32 %and405, 0
  br i1 %tobool406, label %land.lhs.true.415, label %lor.lhs.false.407

lor.lhs.false.407:                                ; preds = %lor.lhs.false.399, %land.lhs.true.391, %sw.bb.385
  %324 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings408 = getelementptr inbounds %struct.cop, %struct.cop* %324, i32 0, i32 14
  %325 = load %struct.sv*, %struct.sv** %cop_warnings408, align 8
  %cmp409 = icmp eq %struct.sv* %325, null
  br i1 %cmp409, label %land.lhs.true.411, label %if.end.454

land.lhs.true.411:                                ; preds = %lor.lhs.false.407
  %326 = load i8, i8* @PL_dowarn, align 1
  %conv412 = zext i8 %326 to i32
  %and413 = and i32 %conv412, 1
  %tobool414 = icmp ne i32 %and413, 0
  br i1 %tobool414, label %land.lhs.true.415, label %if.end.454

land.lhs.true.415:                                ; preds = %land.lhs.true.411, %lor.lhs.false.399, %land.lhs.true.395
  %327 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next416 = getelementptr inbounds %struct.op, %struct.op* %327, i32 0, i32 0
  %328 = load %struct.op*, %struct.op** %op_next416, align 8
  %tobool417 = icmp ne %struct.op* %328, null
  br i1 %tobool417, label %land.lhs.true.418, label %if.end.454

land.lhs.true.418:                                ; preds = %land.lhs.true.415
  %329 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next419 = getelementptr inbounds %struct.op, %struct.op* %329, i32 0, i32 0
  %330 = load %struct.op*, %struct.op** %op_next419, align 8
  %op_type420 = getelementptr inbounds %struct.op, %struct.op* %330, i32 0, i32 4
  %331 = load i16, i16* %op_type420, align 2
  %conv421 = zext i16 %331 to i32
  %cmp422 = icmp eq i32 %conv421, 174
  br i1 %cmp422, label %if.then.424, label %if.end.454

if.then.424:                                      ; preds = %land.lhs.true.418
  %332 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next425 = getelementptr inbounds %struct.op, %struct.op* %332, i32 0, i32 0
  %333 = load %struct.op*, %struct.op** %op_next425, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %333, i32 0, i32 1
  %334 = load %struct.op*, %struct.op** %op_sibling, align 8
  %tobool426 = icmp ne %struct.op* %334, null
  br i1 %tobool426, label %land.lhs.true.427, label %if.end.453

land.lhs.true.427:                                ; preds = %if.then.424
  %335 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next428 = getelementptr inbounds %struct.op, %struct.op* %335, i32 0, i32 0
  %336 = load %struct.op*, %struct.op** %op_next428, align 8
  %op_sibling429 = getelementptr inbounds %struct.op, %struct.op* %336, i32 0, i32 1
  %337 = load %struct.op*, %struct.op** %op_sibling429, align 8
  %op_type430 = getelementptr inbounds %struct.op, %struct.op* %337, i32 0, i32 4
  %338 = load i16, i16* %op_type430, align 2
  %conv431 = zext i16 %338 to i32
  %cmp432 = icmp ne i32 %conv431, 190
  br i1 %cmp432, label %land.lhs.true.434, label %if.end.453

land.lhs.true.434:                                ; preds = %land.lhs.true.427
  %339 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next435 = getelementptr inbounds %struct.op, %struct.op* %339, i32 0, i32 0
  %340 = load %struct.op*, %struct.op** %op_next435, align 8
  %op_sibling436 = getelementptr inbounds %struct.op, %struct.op* %340, i32 0, i32 1
  %341 = load %struct.op*, %struct.op** %op_sibling436, align 8
  %op_type437 = getelementptr inbounds %struct.op, %struct.op* %341, i32 0, i32 4
  %342 = load i16, i16* %op_type437, align 2
  %conv438 = zext i16 %342 to i32
  %cmp439 = icmp ne i32 %conv438, 170
  br i1 %cmp439, label %land.lhs.true.441, label %if.end.453

land.lhs.true.441:                                ; preds = %land.lhs.true.434
  %343 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next442 = getelementptr inbounds %struct.op, %struct.op* %343, i32 0, i32 0
  %344 = load %struct.op*, %struct.op** %op_next442, align 8
  %op_sibling443 = getelementptr inbounds %struct.op, %struct.op* %344, i32 0, i32 1
  %345 = load %struct.op*, %struct.op** %op_sibling443, align 8
  %op_type444 = getelementptr inbounds %struct.op, %struct.op* %345, i32 0, i32 4
  %346 = load i16, i16* %op_type444, align 2
  %conv445 = zext i16 %346 to i32
  %cmp446 = icmp ne i32 %conv445, 171
  br i1 %cmp446, label %if.then.448, label %if.end.453

if.then.448:                                      ; preds = %land.lhs.true.441
  %347 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_line = getelementptr inbounds %struct.cop, %struct.cop* %347, i32 0, i32 13
  %348 = load i32, i32* %cop_line, align 4
  store i32 %348, i32* %oldline, align 4
  %349 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next449 = getelementptr inbounds %struct.op, %struct.op* %349, i32 0, i32 0
  %350 = load %struct.op*, %struct.op** %op_next449, align 8
  %351 = bitcast %struct.op* %350 to %struct.cop*
  %cop_line450 = getelementptr inbounds %struct.cop, %struct.cop* %351, i32 0, i32 13
  %352 = load i32, i32* %cop_line450, align 4
  %353 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_line451 = getelementptr inbounds %struct.cop, %struct.cop* %353, i32 0, i32 13
  store i32 %352, i32* %cop_line451, align 4
  call void (i32, i8*, ...) @Perl_warner(i32 7, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.135, i32 0, i32 0))
  call void (i32, i8*, ...) @Perl_warner(i32 7, i8* getelementptr inbounds ([51 x i8], [51 x i8]* @.str.136, i32 0, i32 0))
  %354 = load i32, i32* %oldline, align 4
  %355 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_line452 = getelementptr inbounds %struct.cop, %struct.cop* %355, i32 0, i32 13
  store i32 %354, i32* %cop_line452, align 4
  br label %if.end.453

if.end.453:                                       ; preds = %if.then.448, %land.lhs.true.441, %land.lhs.true.434, %land.lhs.true.427, %if.then.424
  br label %if.end.454

if.end.454:                                       ; preds = %if.end.453, %land.lhs.true.418, %land.lhs.true.415, %land.lhs.true.411, %lor.lhs.false.407
  br label %sw.epilog

sw.bb.455:                                        ; preds = %if.end.12
  store i8* null, i8** %key, align 8
  %356 = load i16, i16* @PL_op_seqmax, align 2
  %inc457 = add i16 %356, 1
  store i16 %inc457, i16* @PL_op_seqmax, align 2
  %357 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_seq458 = getelementptr inbounds %struct.op, %struct.op* %357, i32 0, i32 5
  store i16 %356, i16* %op_seq458, align 2
  %358 = load %struct.op*, %struct.op** %o.addr, align 8
  %359 = bitcast %struct.op* %358 to %struct.binop*
  %op_last = getelementptr inbounds %struct.binop, %struct.binop* %359, i32 0, i32 9
  %360 = load %struct.op*, %struct.op** %op_last, align 8
  %op_type459 = getelementptr inbounds %struct.op, %struct.op* %360, i32 0, i32 4
  %361 = load i16, i16* %op_type459, align 2
  %conv460 = zext i16 %361 to i32
  %cmp461 = icmp ne i32 %conv460, 5
  br i1 %cmp461, label %if.then.463, label %if.end.464

if.then.463:                                      ; preds = %sw.bb.455
  br label %sw.epilog

if.end.464:                                       ; preds = %sw.bb.455
  %362 = load %struct.op*, %struct.op** %o.addr, align 8
  %363 = bitcast %struct.op* %362 to %struct.binop*
  %op_last465 = getelementptr inbounds %struct.binop, %struct.binop* %363, i32 0, i32 9
  %364 = load %struct.op*, %struct.op** %op_last465, align 8
  %365 = bitcast %struct.op* %364 to %struct.svop*
  %op_sv466 = getelementptr inbounds %struct.svop, %struct.svop* %365, i32 0, i32 8
  store %struct.sv** %op_sv466, %struct.sv*** %svp, align 8
  %366 = load %struct.sv**, %struct.sv*** %svp, align 8
  %367 = load %struct.sv*, %struct.sv** %366, align 8
  store %struct.sv* %367, %struct.sv** %sv456, align 8
  %sv_flags467 = getelementptr inbounds %struct.sv, %struct.sv* %367, i32 0, i32 2
  %368 = load i32, i32* %sv_flags467, align 4
  %and468 = and i32 %368, 1048576
  %tobool469 = icmp ne i32 %and468, 0
  br i1 %tobool469, label %lor.lhs.false.470, label %if.then.474

lor.lhs.false.470:                                ; preds = %if.end.464
  %369 = load %struct.sv*, %struct.sv** %sv456, align 8
  %sv_flags471 = getelementptr inbounds %struct.sv, %struct.sv* %369, i32 0, i32 2
  %370 = load i32, i32* %sv_flags471, align 4
  %and472 = and i32 %370, 8388608
  %tobool473 = icmp ne i32 %and472, 0
  br i1 %tobool473, label %if.end.499, label %if.then.474

if.then.474:                                      ; preds = %lor.lhs.false.470, %if.end.464
  %371 = load %struct.sv*, %struct.sv** %sv456, align 8
  %sv_flags475 = getelementptr inbounds %struct.sv, %struct.sv* %371, i32 0, i32 2
  %372 = load i32, i32* %sv_flags475, align 4
  %and476 = and i32 %372, 262144
  %cmp477 = icmp eq i32 %and476, 262144
  br i1 %cmp477, label %cond.true.479, label %cond.false.483

cond.true.479:                                    ; preds = %if.then.474
  %373 = load %struct.sv*, %struct.sv** %sv456, align 8
  %sv_any480 = getelementptr inbounds %struct.sv, %struct.sv* %373, i32 0, i32 0
  %374 = load i8*, i8** %sv_any480, align 8
  %375 = bitcast i8* %374 to %struct.xpv*
  %xpv_cur = getelementptr inbounds %struct.xpv, %struct.xpv* %375, i32 0, i32 1
  %376 = load i64, i64* %xpv_cur, align 8
  store i64 %376, i64* %keylen, align 8
  %377 = load %struct.sv*, %struct.sv** %sv456, align 8
  %sv_any481 = getelementptr inbounds %struct.sv, %struct.sv* %377, i32 0, i32 0
  %378 = load i8*, i8** %sv_any481, align 8
  %379 = bitcast i8* %378 to %struct.xpv*
  %xpv_pv482 = getelementptr inbounds %struct.xpv, %struct.xpv* %379, i32 0, i32 0
  %380 = load i8*, i8** %xpv_pv482, align 8
  br label %cond.end.485

cond.false.483:                                   ; preds = %if.then.474
  %381 = load %struct.sv*, %struct.sv** %sv456, align 8
  %call484 = call i8* @Perl_sv_2pv_flags(%struct.sv* %381, i64* %keylen, i32 2)
  br label %cond.end.485

cond.end.485:                                     ; preds = %cond.false.483, %cond.true.479
  %cond486 = phi i8* [ %380, %cond.true.479 ], [ %call484, %cond.false.483 ]
  store i8* %cond486, i8** %key, align 8
  %382 = load i8*, i8** %key, align 8
  %383 = load %struct.sv*, %struct.sv** %sv456, align 8
  %sv_flags487 = getelementptr inbounds %struct.sv, %struct.sv* %383, i32 0, i32 2
  %384 = load i32, i32* %sv_flags487, align 4
  %and488 = and i32 %384, 536870912
  %tobool489 = icmp ne i32 %and488, 0
  br i1 %tobool489, label %cond.true.490, label %cond.false.494

cond.true.490:                                    ; preds = %cond.end.485
  %385 = load i64, i64* %keylen, align 8
  %conv491 = trunc i64 %385 to i32
  %sub492 = sub nsw i32 0, %conv491
  %conv493 = sext i32 %sub492 to i64
  br label %cond.end.495

cond.false.494:                                   ; preds = %cond.end.485
  %386 = load i64, i64* %keylen, align 8
  br label %cond.end.495

cond.end.495:                                     ; preds = %cond.false.494, %cond.true.490
  %cond496 = phi i64 [ %conv493, %cond.true.490 ], [ %386, %cond.false.494 ]
  %conv497 = trunc i64 %cond496 to i32
  %call498 = call %struct.sv* @Perl_newSVpvn_share(i8* %382, i32 %conv497, i32 0)
  store %struct.sv* %call498, %struct.sv** %lexname, align 8
  %387 = load %struct.sv*, %struct.sv** %sv456, align 8
  call void @Perl_sv_free(%struct.sv* %387)
  %388 = load %struct.sv*, %struct.sv** %lexname, align 8
  %389 = load %struct.sv**, %struct.sv*** %svp, align 8
  store %struct.sv* %388, %struct.sv** %389, align 8
  br label %if.end.499

if.end.499:                                       ; preds = %cond.end.495, %lor.lhs.false.470
  %390 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private500 = getelementptr inbounds %struct.op, %struct.op* %390, i32 0, i32 7
  %391 = load i8, i8* %op_private500, align 1
  %conv501 = zext i8 %391 to i32
  %and502 = and i32 %conv501, 128
  %tobool503 = icmp ne i32 %and502, 0
  br i1 %tobool503, label %if.then.504, label %if.end.505

if.then.504:                                      ; preds = %if.end.499
  br label %sw.epilog

if.end.505:                                       ; preds = %if.end.499
  %392 = load %struct.op*, %struct.op** %o.addr, align 8
  %393 = bitcast %struct.op* %392 to %struct.binop*
  %op_first = getelementptr inbounds %struct.binop, %struct.binop* %393, i32 0, i32 8
  %394 = load %struct.op*, %struct.op** %op_first, align 8
  %395 = bitcast %struct.op* %394 to %struct.unop*
  store %struct.unop* %395, %struct.unop** %rop, align 8
  %396 = load %struct.unop*, %struct.unop** %rop, align 8
  %op_type506 = getelementptr inbounds %struct.unop, %struct.unop* %396, i32 0, i32 4
  %397 = load i16, i16* %op_type506, align 2
  %conv507 = zext i16 %397 to i32
  %cmp508 = icmp ne i32 %conv507, 134
  br i1 %cmp508, label %if.then.516, label %lor.lhs.false.510

lor.lhs.false.510:                                ; preds = %if.end.505
  %398 = load %struct.unop*, %struct.unop** %rop, align 8
  %op_first511 = getelementptr inbounds %struct.unop, %struct.unop* %398, i32 0, i32 8
  %399 = load %struct.op*, %struct.op** %op_first511, align 8
  %op_type512 = getelementptr inbounds %struct.op, %struct.op* %399, i32 0, i32 4
  %400 = load i16, i16* %op_type512, align 2
  %conv513 = zext i16 %400 to i32
  %cmp514 = icmp ne i32 %conv513, 9
  br i1 %cmp514, label %if.then.516, label %if.end.517

if.then.516:                                      ; preds = %lor.lhs.false.510, %if.end.505
  br label %sw.epilog

if.end.517:                                       ; preds = %lor.lhs.false.510
  %401 = load %struct.av*, %struct.av** @PL_comppad_name, align 8
  %402 = load %struct.unop*, %struct.unop** %rop, align 8
  %op_first518 = getelementptr inbounds %struct.unop, %struct.unop* %402, i32 0, i32 8
  %403 = load %struct.op*, %struct.op** %op_first518, align 8
  %op_targ519 = getelementptr inbounds %struct.op, %struct.op* %403, i32 0, i32 3
  %404 = load i64, i64* %op_targ519, align 8
  %conv520 = trunc i64 %404 to i32
  %call521 = call %struct.sv** @Perl_av_fetch(%struct.av* %401, i32 %conv520, i32 1)
  %405 = load %struct.sv*, %struct.sv** %call521, align 8
  store %struct.sv* %405, %struct.sv** %lexname, align 8
  %406 = load %struct.sv*, %struct.sv** %lexname, align 8
  %sv_flags522 = getelementptr inbounds %struct.sv, %struct.sv* %406, i32 0, i32 2
  %407 = load i32, i32* %sv_flags522, align 4
  %and523 = and i32 %407, 1073741824
  %tobool524 = icmp ne i32 %and523, 0
  br i1 %tobool524, label %if.end.526, label %if.then.525

if.then.525:                                      ; preds = %if.end.517
  br label %sw.epilog

if.end.526:                                       ; preds = %if.end.517
  %408 = load %struct.sv*, %struct.sv** %lexname, align 8
  %sv_any527 = getelementptr inbounds %struct.sv, %struct.sv* %408, i32 0, i32 0
  %409 = load i8*, i8** %sv_any527, align 8
  %410 = bitcast i8* %409 to %struct.xpvmg*
  %xmg_stash = getelementptr inbounds %struct.xpvmg, %struct.xpvmg* %410, i32 0, i32 6
  %411 = load %struct.hv*, %struct.hv** %xmg_stash, align 8
  %call528 = call %struct.sv** @Perl_hv_fetch(%struct.hv* %411, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.137, i32 0, i32 0), i32 6, i32 0)
  %412 = bitcast %struct.sv** %call528 to %struct.gv**
  store %struct.gv** %412, %struct.gv*** %fields, align 8
  %413 = load %struct.gv**, %struct.gv*** %fields, align 8
  %tobool529 = icmp ne %struct.gv** %413, null
  br i1 %tobool529, label %lor.lhs.false.530, label %if.then.534

lor.lhs.false.530:                                ; preds = %if.end.526
  %414 = load %struct.gv**, %struct.gv*** %fields, align 8
  %415 = load %struct.gv*, %struct.gv** %414, align 8
  %sv_any531 = getelementptr inbounds %struct.gv, %struct.gv* %415, i32 0, i32 0
  %416 = load %struct.xpvgv*, %struct.xpvgv** %sv_any531, align 8
  %xgv_gp532 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %416, i32 0, i32 7
  %417 = load %struct.gp*, %struct.gp** %xgv_gp532, align 8
  %gp_hv = getelementptr inbounds %struct.gp, %struct.gp* %417, i32 0, i32 5
  %418 = load %struct.hv*, %struct.hv** %gp_hv, align 8
  %tobool533 = icmp ne %struct.hv* %418, null
  br i1 %tobool533, label %if.end.535, label %if.then.534

if.then.534:                                      ; preds = %lor.lhs.false.530, %if.end.526
  br label %sw.epilog

if.end.535:                                       ; preds = %lor.lhs.false.530
  %419 = load %struct.sv**, %struct.sv*** %svp, align 8
  %420 = load %struct.sv*, %struct.sv** %419, align 8
  %sv_flags536 = getelementptr inbounds %struct.sv, %struct.sv* %420, i32 0, i32 2
  %421 = load i32, i32* %sv_flags536, align 4
  %and537 = and i32 %421, 262144
  %cmp538 = icmp eq i32 %and537, 262144
  br i1 %cmp538, label %cond.true.540, label %cond.false.545

cond.true.540:                                    ; preds = %if.end.535
  %422 = load %struct.sv**, %struct.sv*** %svp, align 8
  %423 = load %struct.sv*, %struct.sv** %422, align 8
  %sv_any541 = getelementptr inbounds %struct.sv, %struct.sv* %423, i32 0, i32 0
  %424 = load i8*, i8** %sv_any541, align 8
  %425 = bitcast i8* %424 to %struct.xpv*
  %xpv_cur542 = getelementptr inbounds %struct.xpv, %struct.xpv* %425, i32 0, i32 1
  %426 = load i64, i64* %xpv_cur542, align 8
  store i64 %426, i64* %keylen, align 8
  %427 = load %struct.sv**, %struct.sv*** %svp, align 8
  %428 = load %struct.sv*, %struct.sv** %427, align 8
  %sv_any543 = getelementptr inbounds %struct.sv, %struct.sv* %428, i32 0, i32 0
  %429 = load i8*, i8** %sv_any543, align 8
  %430 = bitcast i8* %429 to %struct.xpv*
  %xpv_pv544 = getelementptr inbounds %struct.xpv, %struct.xpv* %430, i32 0, i32 0
  %431 = load i8*, i8** %xpv_pv544, align 8
  br label %cond.end.547

cond.false.545:                                   ; preds = %if.end.535
  %432 = load %struct.sv**, %struct.sv*** %svp, align 8
  %433 = load %struct.sv*, %struct.sv** %432, align 8
  %call546 = call i8* @Perl_sv_2pv_flags(%struct.sv* %433, i64* %keylen, i32 2)
  br label %cond.end.547

cond.end.547:                                     ; preds = %cond.false.545, %cond.true.540
  %cond548 = phi i8* [ %431, %cond.true.540 ], [ %call546, %cond.false.545 ]
  store i8* %cond548, i8** %key, align 8
  %434 = load %struct.gv**, %struct.gv*** %fields, align 8
  %435 = load %struct.gv*, %struct.gv** %434, align 8
  %sv_any549 = getelementptr inbounds %struct.gv, %struct.gv* %435, i32 0, i32 0
  %436 = load %struct.xpvgv*, %struct.xpvgv** %sv_any549, align 8
  %xgv_gp550 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %436, i32 0, i32 7
  %437 = load %struct.gp*, %struct.gp** %xgv_gp550, align 8
  %gp_hv551 = getelementptr inbounds %struct.gp, %struct.gp* %437, i32 0, i32 5
  %438 = load %struct.hv*, %struct.hv** %gp_hv551, align 8
  %439 = load i8*, i8** %key, align 8
  %440 = load %struct.sv**, %struct.sv*** %svp, align 8
  %441 = load %struct.sv*, %struct.sv** %440, align 8
  %sv_flags552 = getelementptr inbounds %struct.sv, %struct.sv* %441, i32 0, i32 2
  %442 = load i32, i32* %sv_flags552, align 4
  %and553 = and i32 %442, 536870912
  %tobool554 = icmp ne i32 %and553, 0
  br i1 %tobool554, label %cond.true.555, label %cond.false.559

cond.true.555:                                    ; preds = %cond.end.547
  %443 = load i64, i64* %keylen, align 8
  %conv556 = trunc i64 %443 to i32
  %sub557 = sub nsw i32 0, %conv556
  %conv558 = sext i32 %sub557 to i64
  br label %cond.end.560

cond.false.559:                                   ; preds = %cond.end.547
  %444 = load i64, i64* %keylen, align 8
  br label %cond.end.560

cond.end.560:                                     ; preds = %cond.false.559, %cond.true.555
  %cond561 = phi i64 [ %conv558, %cond.true.555 ], [ %444, %cond.false.559 ]
  %conv562 = trunc i64 %cond561 to i32
  %call563 = call %struct.sv** @Perl_hv_fetch(%struct.hv* %438, i8* %439, i32 %conv562, i32 0)
  store %struct.sv** %call563, %struct.sv*** %indsvp, align 8
  %445 = load %struct.sv**, %struct.sv*** %indsvp, align 8
  %tobool564 = icmp ne %struct.sv** %445, null
  br i1 %tobool564, label %if.end.582, label %if.then.565

if.then.565:                                      ; preds = %cond.end.560
  %446 = load i8*, i8** %key, align 8
  %447 = load %struct.sv*, %struct.sv** %lexname, align 8
  %sv_flags566 = getelementptr inbounds %struct.sv, %struct.sv* %447, i32 0, i32 2
  %448 = load i32, i32* %sv_flags566, align 4
  %and567 = and i32 %448, 262144
  %cmp568 = icmp eq i32 %and567, 262144
  br i1 %cmp568, label %cond.true.570, label %cond.false.575

cond.true.570:                                    ; preds = %if.then.565
  %449 = load %struct.sv*, %struct.sv** %lexname, align 8
  %sv_any571 = getelementptr inbounds %struct.sv, %struct.sv* %449, i32 0, i32 0
  %450 = load i8*, i8** %sv_any571, align 8
  %451 = bitcast i8* %450 to %struct.xpv*
  %xpv_cur572 = getelementptr inbounds %struct.xpv, %struct.xpv* %451, i32 0, i32 1
  %452 = load i64, i64* %xpv_cur572, align 8
  store i64 %452, i64* %n_a, align 8
  %453 = load %struct.sv*, %struct.sv** %lexname, align 8
  %sv_any573 = getelementptr inbounds %struct.sv, %struct.sv* %453, i32 0, i32 0
  %454 = load i8*, i8** %sv_any573, align 8
  %455 = bitcast i8* %454 to %struct.xpv*
  %xpv_pv574 = getelementptr inbounds %struct.xpv, %struct.xpv* %455, i32 0, i32 0
  %456 = load i8*, i8** %xpv_pv574, align 8
  br label %cond.end.577

cond.false.575:                                   ; preds = %if.then.565
  %457 = load %struct.sv*, %struct.sv** %lexname, align 8
  %call576 = call i8* @Perl_sv_2pv_flags(%struct.sv* %457, i64* %n_a, i32 2)
  br label %cond.end.577

cond.end.577:                                     ; preds = %cond.false.575, %cond.true.570
  %cond578 = phi i8* [ %456, %cond.true.570 ], [ %call576, %cond.false.575 ]
  %458 = load %struct.sv*, %struct.sv** %lexname, align 8
  %sv_any579 = getelementptr inbounds %struct.sv, %struct.sv* %458, i32 0, i32 0
  %459 = load i8*, i8** %sv_any579, align 8
  %460 = bitcast i8* %459 to %struct.xpvmg*
  %xmg_stash580 = getelementptr inbounds %struct.xpvmg, %struct.xpvmg* %460, i32 0, i32 6
  %461 = load %struct.hv*, %struct.hv** %xmg_stash580, align 8
  %sv_any581 = getelementptr inbounds %struct.hv, %struct.hv* %461, i32 0, i32 0
  %462 = load %struct.xpvhv*, %struct.xpvhv** %sv_any581, align 8
  %xhv_name = getelementptr inbounds %struct.xpvhv, %struct.xpvhv* %462, i32 0, i32 10
  %463 = load i8*, i8** %xhv_name, align 8
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([57 x i8], [57 x i8]* @.str.138, i32 0, i32 0), i8* %446, i8* %cond578, i8* %463)
  br label %if.end.582

if.end.582:                                       ; preds = %cond.end.577, %cond.end.560
  %464 = load %struct.sv**, %struct.sv*** %indsvp, align 8
  %465 = load %struct.sv*, %struct.sv** %464, align 8
  %sv_flags583 = getelementptr inbounds %struct.sv, %struct.sv* %465, i32 0, i32 2
  %466 = load i32, i32* %sv_flags583, align 4
  %and584 = and i32 %466, 65536
  %tobool585 = icmp ne i32 %and584, 0
  br i1 %tobool585, label %cond.true.586, label %cond.false.589

cond.true.586:                                    ; preds = %if.end.582
  %467 = load %struct.sv**, %struct.sv*** %indsvp, align 8
  %468 = load %struct.sv*, %struct.sv** %467, align 8
  %sv_any587 = getelementptr inbounds %struct.sv, %struct.sv* %468, i32 0, i32 0
  %469 = load i8*, i8** %sv_any587, align 8
  %470 = bitcast i8* %469 to %struct.xpviv*
  %xiv_iv588 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %470, i32 0, i32 3
  %471 = load i64, i64* %xiv_iv588, align 8
  br label %cond.end.591

cond.false.589:                                   ; preds = %if.end.582
  %472 = load %struct.sv**, %struct.sv*** %indsvp, align 8
  %473 = load %struct.sv*, %struct.sv** %472, align 8
  %call590 = call i64 @Perl_sv_2iv(%struct.sv* %473)
  br label %cond.end.591

cond.end.591:                                     ; preds = %cond.false.589, %cond.true.586
  %cond592 = phi i64 [ %471, %cond.true.586 ], [ %call590, %cond.false.589 ]
  %conv593 = trunc i64 %cond592 to i32
  store i32 %conv593, i32* %ind, align 4
  %474 = load i32, i32* %ind, align 4
  %cmp594 = icmp slt i32 %474, 1
  br i1 %cmp594, label %if.then.596, label %if.end.597

if.then.596:                                      ; preds = %cond.end.591
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.139, i32 0, i32 0))
  br label %if.end.597

if.end.597:                                       ; preds = %if.then.596, %cond.end.591
  %475 = load %struct.unop*, %struct.unop** %rop, align 8
  %op_type598 = getelementptr inbounds %struct.unop, %struct.unop* %475, i32 0, i32 4
  store i16 125, i16* %op_type598, align 2
  %476 = load %struct.op* ()*, %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 125), align 8
  %477 = load %struct.unop*, %struct.unop** %rop, align 8
  %op_ppaddr599 = getelementptr inbounds %struct.unop, %struct.unop* %477, i32 0, i32 2
  store %struct.op* ()* %476, %struct.op* ()** %op_ppaddr599, align 8
  %478 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type600 = getelementptr inbounds %struct.op, %struct.op* %478, i32 0, i32 4
  store i16 127, i16* %op_type600, align 2
  %479 = load %struct.op* ()*, %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 127), align 8
  %480 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_ppaddr601 = getelementptr inbounds %struct.op, %struct.op* %480, i32 0, i32 2
  store %struct.op* ()* %479, %struct.op* ()** %op_ppaddr601, align 8
  %481 = load i32, i32* %ind, align 4
  %conv602 = sext i32 %481 to i64
  %call603 = call %struct.sv* @Perl_newSViv(i64 %conv602)
  store %struct.sv* %call603, %struct.sv** %sv456, align 8
  %482 = load %struct.sv**, %struct.sv*** %svp, align 8
  %483 = load %struct.sv*, %struct.sv** %482, align 8
  %sv_flags604 = getelementptr inbounds %struct.sv, %struct.sv* %483, i32 0, i32 2
  %484 = load i32, i32* %sv_flags604, align 4
  %and605 = and i32 %484, 8388608
  %tobool606 = icmp ne i32 %and605, 0
  br i1 %tobool606, label %if.then.607, label %if.end.610

if.then.607:                                      ; preds = %if.end.597
  %485 = load %struct.sv*, %struct.sv** %sv456, align 8
  %sv_flags608 = getelementptr inbounds %struct.sv, %struct.sv* %485, i32 0, i32 2
  %486 = load i32, i32* %sv_flags608, align 4
  %or609 = or i32 %486, 8388608
  store i32 %or609, i32* %sv_flags608, align 4
  br label %if.end.610

if.end.610:                                       ; preds = %if.then.607, %if.end.597
  %487 = load %struct.sv**, %struct.sv*** %svp, align 8
  %488 = load %struct.sv*, %struct.sv** %487, align 8
  %sv_flags611 = getelementptr inbounds %struct.sv, %struct.sv* %488, i32 0, i32 2
  %489 = load i32, i32* %sv_flags611, align 4
  %and612 = and i32 %489, 1792
  %490 = load %struct.sv*, %struct.sv** %sv456, align 8
  %sv_flags613 = getelementptr inbounds %struct.sv, %struct.sv* %490, i32 0, i32 2
  %491 = load i32, i32* %sv_flags613, align 4
  %or614 = or i32 %491, %and612
  store i32 %or614, i32* %sv_flags613, align 4
  %492 = load %struct.sv**, %struct.sv*** %svp, align 8
  %493 = load %struct.sv*, %struct.sv** %492, align 8
  call void @Perl_sv_free(%struct.sv* %493)
  %494 = load %struct.sv*, %struct.sv** %sv456, align 8
  %495 = load %struct.sv**, %struct.sv*** %svp, align 8
  store %struct.sv* %494, %struct.sv** %495, align 8
  br label %sw.epilog

sw.bb.615:                                        ; preds = %if.end.12
  %496 = load i16, i16* @PL_op_seqmax, align 2
  %inc625 = add i16 %496, 1
  store i16 %inc625, i16* @PL_op_seqmax, align 2
  %497 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_seq626 = getelementptr inbounds %struct.op, %struct.op* %497, i32 0, i32 5
  store i16 %496, i16* %op_seq626, align 2
  %498 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private627 = getelementptr inbounds %struct.op, %struct.op* %498, i32 0, i32 7
  %499 = load i8, i8* %op_private627, align 1
  %conv628 = zext i8 %499 to i32
  %and629 = and i32 %conv628, 128
  %tobool630 = icmp ne i32 %and629, 0
  br i1 %tobool630, label %if.then.638, label %lor.lhs.false.631

lor.lhs.false.631:                                ; preds = %sw.bb.615
  %500 = load %struct.op*, %struct.op** %o.addr, align 8
  %501 = bitcast %struct.op* %500 to %struct.listop*
  %op_first632 = getelementptr inbounds %struct.listop, %struct.listop* %501, i32 0, i32 8
  %502 = load %struct.op*, %struct.op** %op_first632, align 8
  %op_sibling633 = getelementptr inbounds %struct.op, %struct.op* %502, i32 0, i32 1
  %503 = load %struct.op*, %struct.op** %op_sibling633, align 8
  %op_type634 = getelementptr inbounds %struct.op, %struct.op* %503, i32 0, i32 4
  %504 = load i16, i16* %op_type634, align 2
  %conv635 = zext i16 %504 to i32
  %cmp636 = icmp ne i32 %conv635, 141
  br i1 %cmp636, label %if.then.638, label %if.end.639

if.then.638:                                      ; preds = %lor.lhs.false.631, %sw.bb.615
  br label %sw.epilog

if.end.639:                                       ; preds = %lor.lhs.false.631
  %505 = load %struct.op*, %struct.op** %o.addr, align 8
  %506 = bitcast %struct.op* %505 to %struct.listop*
  %op_last640 = getelementptr inbounds %struct.listop, %struct.listop* %506, i32 0, i32 9
  %507 = load %struct.op*, %struct.op** %op_last640, align 8
  %508 = bitcast %struct.op* %507 to %struct.unop*
  store %struct.unop* %508, %struct.unop** %rop616, align 8
  %509 = load %struct.unop*, %struct.unop** %rop616, align 8
  %op_type641 = getelementptr inbounds %struct.unop, %struct.unop* %509, i32 0, i32 4
  %510 = load i16, i16* %op_type641, align 2
  %conv642 = zext i16 %510 to i32
  %cmp643 = icmp ne i32 %conv642, 134
  br i1 %cmp643, label %if.then.651, label %lor.lhs.false.645

lor.lhs.false.645:                                ; preds = %if.end.639
  %511 = load %struct.unop*, %struct.unop** %rop616, align 8
  %op_first646 = getelementptr inbounds %struct.unop, %struct.unop* %511, i32 0, i32 8
  %512 = load %struct.op*, %struct.op** %op_first646, align 8
  %op_type647 = getelementptr inbounds %struct.op, %struct.op* %512, i32 0, i32 4
  %513 = load i16, i16* %op_type647, align 2
  %conv648 = zext i16 %513 to i32
  %cmp649 = icmp ne i32 %conv648, 9
  br i1 %cmp649, label %if.then.651, label %if.end.652

if.then.651:                                      ; preds = %lor.lhs.false.645, %if.end.639
  br label %sw.epilog

if.end.652:                                       ; preds = %lor.lhs.false.645
  %514 = load %struct.av*, %struct.av** @PL_comppad_name, align 8
  %515 = load %struct.unop*, %struct.unop** %rop616, align 8
  %op_first653 = getelementptr inbounds %struct.unop, %struct.unop* %515, i32 0, i32 8
  %516 = load %struct.op*, %struct.op** %op_first653, align 8
  %op_targ654 = getelementptr inbounds %struct.op, %struct.op* %516, i32 0, i32 3
  %517 = load i64, i64* %op_targ654, align 8
  %conv655 = trunc i64 %517 to i32
  %call656 = call %struct.sv** @Perl_av_fetch(%struct.av* %514, i32 %conv655, i32 1)
  %518 = load %struct.sv*, %struct.sv** %call656, align 8
  store %struct.sv* %518, %struct.sv** %lexname617, align 8
  %519 = load %struct.sv*, %struct.sv** %lexname617, align 8
  %sv_flags657 = getelementptr inbounds %struct.sv, %struct.sv* %519, i32 0, i32 2
  %520 = load i32, i32* %sv_flags657, align 4
  %and658 = and i32 %520, 1073741824
  %tobool659 = icmp ne i32 %and658, 0
  br i1 %tobool659, label %if.end.661, label %if.then.660

if.then.660:                                      ; preds = %if.end.652
  br label %sw.epilog

if.end.661:                                       ; preds = %if.end.652
  %521 = load %struct.sv*, %struct.sv** %lexname617, align 8
  %sv_any662 = getelementptr inbounds %struct.sv, %struct.sv* %521, i32 0, i32 0
  %522 = load i8*, i8** %sv_any662, align 8
  %523 = bitcast i8* %522 to %struct.xpvmg*
  %xmg_stash663 = getelementptr inbounds %struct.xpvmg, %struct.xpvmg* %523, i32 0, i32 6
  %524 = load %struct.hv*, %struct.hv** %xmg_stash663, align 8
  %call664 = call %struct.sv** @Perl_hv_fetch(%struct.hv* %524, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.137, i32 0, i32 0), i32 6, i32 0)
  %525 = bitcast %struct.sv** %call664 to %struct.gv**
  store %struct.gv** %525, %struct.gv*** %fields618, align 8
  %526 = load %struct.gv**, %struct.gv*** %fields618, align 8
  %tobool665 = icmp ne %struct.gv** %526, null
  br i1 %tobool665, label %lor.lhs.false.666, label %if.then.671

lor.lhs.false.666:                                ; preds = %if.end.661
  %527 = load %struct.gv**, %struct.gv*** %fields618, align 8
  %528 = load %struct.gv*, %struct.gv** %527, align 8
  %sv_any667 = getelementptr inbounds %struct.gv, %struct.gv* %528, i32 0, i32 0
  %529 = load %struct.xpvgv*, %struct.xpvgv** %sv_any667, align 8
  %xgv_gp668 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %529, i32 0, i32 7
  %530 = load %struct.gp*, %struct.gp** %xgv_gp668, align 8
  %gp_hv669 = getelementptr inbounds %struct.gp, %struct.gp* %530, i32 0, i32 5
  %531 = load %struct.hv*, %struct.hv** %gp_hv669, align 8
  %tobool670 = icmp ne %struct.hv* %531, null
  br i1 %tobool670, label %if.end.672, label %if.then.671

if.then.671:                                      ; preds = %lor.lhs.false.666, %if.end.661
  br label %sw.epilog

if.end.672:                                       ; preds = %lor.lhs.false.666
  %532 = load %struct.op*, %struct.op** %o.addr, align 8
  %533 = bitcast %struct.op* %532 to %struct.listop*
  %op_first673 = getelementptr inbounds %struct.listop, %struct.listop* %533, i32 0, i32 8
  %534 = load %struct.op*, %struct.op** %op_first673, align 8
  %op_sibling674 = getelementptr inbounds %struct.op, %struct.op* %534, i32 0, i32 1
  %535 = load %struct.op*, %struct.op** %op_sibling674, align 8
  %536 = bitcast %struct.op* %535 to %struct.listop*
  %op_first675 = getelementptr inbounds %struct.listop, %struct.listop* %536, i32 0, i32 8
  %537 = load %struct.op*, %struct.op** %op_first675, align 8
  %op_sibling676 = getelementptr inbounds %struct.op, %struct.op* %537, i32 0, i32 1
  %538 = load %struct.op*, %struct.op** %op_sibling676, align 8
  %539 = bitcast %struct.op* %538 to %struct.svop*
  store %struct.svop* %539, %struct.svop** %first_key_op, align 8
  %540 = load %struct.svop*, %struct.svop** %first_key_op, align 8
  store %struct.svop* %540, %struct.svop** %key_op, align 8
  br label %for.cond.677

for.cond.677:                                     ; preds = %for.inc, %if.end.672
  %541 = load %struct.svop*, %struct.svop** %key_op, align 8
  %tobool678 = icmp ne %struct.svop* %541, null
  br i1 %tobool678, label %for.body.679, label %for.end

for.body.679:                                     ; preds = %for.cond.677
  %542 = load %struct.svop*, %struct.svop** %key_op, align 8
  %op_type680 = getelementptr inbounds %struct.svop, %struct.svop* %542, i32 0, i32 4
  %543 = load i16, i16* %op_type680, align 2
  %conv681 = zext i16 %543 to i32
  %cmp682 = icmp ne i32 %conv681, 5
  br i1 %cmp682, label %if.then.684, label %if.end.685

if.then.684:                                      ; preds = %for.body.679
  br label %for.end

if.end.685:                                       ; preds = %for.body.679
  br label %for.inc

for.inc:                                          ; preds = %if.end.685
  %544 = load %struct.svop*, %struct.svop** %key_op, align 8
  %op_sibling686 = getelementptr inbounds %struct.svop, %struct.svop* %544, i32 0, i32 1
  %545 = load %struct.op*, %struct.op** %op_sibling686, align 8
  %546 = bitcast %struct.op* %545 to %struct.svop*
  store %struct.svop* %546, %struct.svop** %key_op, align 8
  br label %for.cond.677

for.end:                                          ; preds = %if.then.684, %for.cond.677
  %547 = load %struct.svop*, %struct.svop** %key_op, align 8
  %tobool687 = icmp ne %struct.svop* %547, null
  br i1 %tobool687, label %if.then.688, label %if.end.689

if.then.688:                                      ; preds = %for.end
  br label %sw.epilog

if.end.689:                                       ; preds = %for.end
  %548 = load %struct.unop*, %struct.unop** %rop616, align 8
  %op_type690 = getelementptr inbounds %struct.unop, %struct.unop* %548, i32 0, i32 4
  store i16 125, i16* %op_type690, align 2
  %549 = load %struct.op* ()*, %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 125), align 8
  %550 = load %struct.unop*, %struct.unop** %rop616, align 8
  %op_ppaddr691 = getelementptr inbounds %struct.unop, %struct.unop* %550, i32 0, i32 2
  store %struct.op* ()* %549, %struct.op* ()** %op_ppaddr691, align 8
  %551 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type692 = getelementptr inbounds %struct.op, %struct.op* %551, i32 0, i32 4
  store i16 128, i16* %op_type692, align 2
  %552 = load %struct.op* ()*, %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 128), align 8
  %553 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_ppaddr693 = getelementptr inbounds %struct.op, %struct.op* %553, i32 0, i32 2
  store %struct.op* ()* %552, %struct.op* ()** %op_ppaddr693, align 8
  %554 = load %struct.svop*, %struct.svop** %first_key_op, align 8
  store %struct.svop* %554, %struct.svop** %key_op, align 8
  br label %for.cond.694

for.cond.694:                                     ; preds = %for.inc.774, %if.end.689
  %555 = load %struct.svop*, %struct.svop** %key_op, align 8
  %tobool695 = icmp ne %struct.svop* %555, null
  br i1 %tobool695, label %for.body.696, label %for.end.776

for.body.696:                                     ; preds = %for.cond.694
  %556 = load %struct.svop*, %struct.svop** %key_op, align 8
  %op_sv697 = getelementptr inbounds %struct.svop, %struct.svop* %556, i32 0, i32 8
  store %struct.sv** %op_sv697, %struct.sv*** %svp619, align 8
  %557 = load %struct.sv**, %struct.sv*** %svp619, align 8
  %558 = load %struct.sv*, %struct.sv** %557, align 8
  %sv_flags698 = getelementptr inbounds %struct.sv, %struct.sv* %558, i32 0, i32 2
  %559 = load i32, i32* %sv_flags698, align 4
  %and699 = and i32 %559, 262144
  %cmp700 = icmp eq i32 %and699, 262144
  br i1 %cmp700, label %cond.true.702, label %cond.false.707

cond.true.702:                                    ; preds = %for.body.696
  %560 = load %struct.sv**, %struct.sv*** %svp619, align 8
  %561 = load %struct.sv*, %struct.sv** %560, align 8
  %sv_any703 = getelementptr inbounds %struct.sv, %struct.sv* %561, i32 0, i32 0
  %562 = load i8*, i8** %sv_any703, align 8
  %563 = bitcast i8* %562 to %struct.xpv*
  %xpv_cur704 = getelementptr inbounds %struct.xpv, %struct.xpv* %563, i32 0, i32 1
  %564 = load i64, i64* %xpv_cur704, align 8
  store i64 %564, i64* %keylen624, align 8
  %565 = load %struct.sv**, %struct.sv*** %svp619, align 8
  %566 = load %struct.sv*, %struct.sv** %565, align 8
  %sv_any705 = getelementptr inbounds %struct.sv, %struct.sv* %566, i32 0, i32 0
  %567 = load i8*, i8** %sv_any705, align 8
  %568 = bitcast i8* %567 to %struct.xpv*
  %xpv_pv706 = getelementptr inbounds %struct.xpv, %struct.xpv* %568, i32 0, i32 0
  %569 = load i8*, i8** %xpv_pv706, align 8
  br label %cond.end.709

cond.false.707:                                   ; preds = %for.body.696
  %570 = load %struct.sv**, %struct.sv*** %svp619, align 8
  %571 = load %struct.sv*, %struct.sv** %570, align 8
  %call708 = call i8* @Perl_sv_2pv_flags(%struct.sv* %571, i64* %keylen624, i32 2)
  br label %cond.end.709

cond.end.709:                                     ; preds = %cond.false.707, %cond.true.702
  %cond710 = phi i8* [ %569, %cond.true.702 ], [ %call708, %cond.false.707 ]
  store i8* %cond710, i8** %key623, align 8
  %572 = load %struct.gv**, %struct.gv*** %fields618, align 8
  %573 = load %struct.gv*, %struct.gv** %572, align 8
  %sv_any711 = getelementptr inbounds %struct.gv, %struct.gv* %573, i32 0, i32 0
  %574 = load %struct.xpvgv*, %struct.xpvgv** %sv_any711, align 8
  %xgv_gp712 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %574, i32 0, i32 7
  %575 = load %struct.gp*, %struct.gp** %xgv_gp712, align 8
  %gp_hv713 = getelementptr inbounds %struct.gp, %struct.gp* %575, i32 0, i32 5
  %576 = load %struct.hv*, %struct.hv** %gp_hv713, align 8
  %577 = load i8*, i8** %key623, align 8
  %578 = load %struct.sv**, %struct.sv*** %svp619, align 8
  %579 = load %struct.sv*, %struct.sv** %578, align 8
  %sv_flags714 = getelementptr inbounds %struct.sv, %struct.sv* %579, i32 0, i32 2
  %580 = load i32, i32* %sv_flags714, align 4
  %and715 = and i32 %580, 536870912
  %tobool716 = icmp ne i32 %and715, 0
  br i1 %tobool716, label %cond.true.717, label %cond.false.721

cond.true.717:                                    ; preds = %cond.end.709
  %581 = load i64, i64* %keylen624, align 8
  %conv718 = trunc i64 %581 to i32
  %sub719 = sub nsw i32 0, %conv718
  %conv720 = sext i32 %sub719 to i64
  br label %cond.end.722

cond.false.721:                                   ; preds = %cond.end.709
  %582 = load i64, i64* %keylen624, align 8
  br label %cond.end.722

cond.end.722:                                     ; preds = %cond.false.721, %cond.true.717
  %cond723 = phi i64 [ %conv720, %cond.true.717 ], [ %582, %cond.false.721 ]
  %conv724 = trunc i64 %cond723 to i32
  %call725 = call %struct.sv** @Perl_hv_fetch(%struct.hv* %576, i8* %577, i32 %conv724, i32 0)
  store %struct.sv** %call725, %struct.sv*** %indsvp620, align 8
  %583 = load %struct.sv**, %struct.sv*** %indsvp620, align 8
  %tobool726 = icmp ne %struct.sv** %583, null
  br i1 %tobool726, label %if.end.745, label %if.then.727

if.then.727:                                      ; preds = %cond.end.722
  %584 = load i8*, i8** %key623, align 8
  %585 = load %struct.sv*, %struct.sv** %lexname617, align 8
  %sv_flags728 = getelementptr inbounds %struct.sv, %struct.sv* %585, i32 0, i32 2
  %586 = load i32, i32* %sv_flags728, align 4
  %and729 = and i32 %586, 262144
  %cmp730 = icmp eq i32 %and729, 262144
  br i1 %cmp730, label %cond.true.732, label %cond.false.737

cond.true.732:                                    ; preds = %if.then.727
  %587 = load %struct.sv*, %struct.sv** %lexname617, align 8
  %sv_any733 = getelementptr inbounds %struct.sv, %struct.sv* %587, i32 0, i32 0
  %588 = load i8*, i8** %sv_any733, align 8
  %589 = bitcast i8* %588 to %struct.xpv*
  %xpv_cur734 = getelementptr inbounds %struct.xpv, %struct.xpv* %589, i32 0, i32 1
  %590 = load i64, i64* %xpv_cur734, align 8
  store i64 %590, i64* %n_a, align 8
  %591 = load %struct.sv*, %struct.sv** %lexname617, align 8
  %sv_any735 = getelementptr inbounds %struct.sv, %struct.sv* %591, i32 0, i32 0
  %592 = load i8*, i8** %sv_any735, align 8
  %593 = bitcast i8* %592 to %struct.xpv*
  %xpv_pv736 = getelementptr inbounds %struct.xpv, %struct.xpv* %593, i32 0, i32 0
  %594 = load i8*, i8** %xpv_pv736, align 8
  br label %cond.end.739

cond.false.737:                                   ; preds = %if.then.727
  %595 = load %struct.sv*, %struct.sv** %lexname617, align 8
  %call738 = call i8* @Perl_sv_2pv_flags(%struct.sv* %595, i64* %n_a, i32 2)
  br label %cond.end.739

cond.end.739:                                     ; preds = %cond.false.737, %cond.true.732
  %cond740 = phi i8* [ %594, %cond.true.732 ], [ %call738, %cond.false.737 ]
  %596 = load %struct.sv*, %struct.sv** %lexname617, align 8
  %sv_any741 = getelementptr inbounds %struct.sv, %struct.sv* %596, i32 0, i32 0
  %597 = load i8*, i8** %sv_any741, align 8
  %598 = bitcast i8* %597 to %struct.xpvmg*
  %xmg_stash742 = getelementptr inbounds %struct.xpvmg, %struct.xpvmg* %598, i32 0, i32 6
  %599 = load %struct.hv*, %struct.hv** %xmg_stash742, align 8
  %sv_any743 = getelementptr inbounds %struct.hv, %struct.hv* %599, i32 0, i32 0
  %600 = load %struct.xpvhv*, %struct.xpvhv** %sv_any743, align 8
  %xhv_name744 = getelementptr inbounds %struct.xpvhv, %struct.xpvhv* %600, i32 0, i32 10
  %601 = load i8*, i8** %xhv_name744, align 8
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([57 x i8], [57 x i8]* @.str.138, i32 0, i32 0), i8* %584, i8* %cond740, i8* %601)
  br label %if.end.745

if.end.745:                                       ; preds = %cond.end.739, %cond.end.722
  %602 = load %struct.sv**, %struct.sv*** %indsvp620, align 8
  %603 = load %struct.sv*, %struct.sv** %602, align 8
  %sv_flags746 = getelementptr inbounds %struct.sv, %struct.sv* %603, i32 0, i32 2
  %604 = load i32, i32* %sv_flags746, align 4
  %and747 = and i32 %604, 65536
  %tobool748 = icmp ne i32 %and747, 0
  br i1 %tobool748, label %cond.true.749, label %cond.false.752

cond.true.749:                                    ; preds = %if.end.745
  %605 = load %struct.sv**, %struct.sv*** %indsvp620, align 8
  %606 = load %struct.sv*, %struct.sv** %605, align 8
  %sv_any750 = getelementptr inbounds %struct.sv, %struct.sv* %606, i32 0, i32 0
  %607 = load i8*, i8** %sv_any750, align 8
  %608 = bitcast i8* %607 to %struct.xpviv*
  %xiv_iv751 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %608, i32 0, i32 3
  %609 = load i64, i64* %xiv_iv751, align 8
  br label %cond.end.754

cond.false.752:                                   ; preds = %if.end.745
  %610 = load %struct.sv**, %struct.sv*** %indsvp620, align 8
  %611 = load %struct.sv*, %struct.sv** %610, align 8
  %call753 = call i64 @Perl_sv_2iv(%struct.sv* %611)
  br label %cond.end.754

cond.end.754:                                     ; preds = %cond.false.752, %cond.true.749
  %cond755 = phi i64 [ %609, %cond.true.749 ], [ %call753, %cond.false.752 ]
  %conv756 = trunc i64 %cond755 to i32
  store i32 %conv756, i32* %ind622, align 4
  %612 = load i32, i32* %ind622, align 4
  %cmp757 = icmp slt i32 %612, 1
  br i1 %cmp757, label %if.then.759, label %if.end.760

if.then.759:                                      ; preds = %cond.end.754
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.139, i32 0, i32 0))
  br label %if.end.760

if.end.760:                                       ; preds = %if.then.759, %cond.end.754
  %613 = load i32, i32* %ind622, align 4
  %conv761 = sext i32 %613 to i64
  %call762 = call %struct.sv* @Perl_newSViv(i64 %conv761)
  store %struct.sv* %call762, %struct.sv** %sv621, align 8
  %614 = load %struct.sv**, %struct.sv*** %svp619, align 8
  %615 = load %struct.sv*, %struct.sv** %614, align 8
  %sv_flags763 = getelementptr inbounds %struct.sv, %struct.sv* %615, i32 0, i32 2
  %616 = load i32, i32* %sv_flags763, align 4
  %and764 = and i32 %616, 8388608
  %tobool765 = icmp ne i32 %and764, 0
  br i1 %tobool765, label %if.then.766, label %if.end.769

if.then.766:                                      ; preds = %if.end.760
  %617 = load %struct.sv*, %struct.sv** %sv621, align 8
  %sv_flags767 = getelementptr inbounds %struct.sv, %struct.sv* %617, i32 0, i32 2
  %618 = load i32, i32* %sv_flags767, align 4
  %or768 = or i32 %618, 8388608
  store i32 %or768, i32* %sv_flags767, align 4
  br label %if.end.769

if.end.769:                                       ; preds = %if.then.766, %if.end.760
  %619 = load %struct.sv**, %struct.sv*** %svp619, align 8
  %620 = load %struct.sv*, %struct.sv** %619, align 8
  %sv_flags770 = getelementptr inbounds %struct.sv, %struct.sv* %620, i32 0, i32 2
  %621 = load i32, i32* %sv_flags770, align 4
  %and771 = and i32 %621, 1792
  %622 = load %struct.sv*, %struct.sv** %sv621, align 8
  %sv_flags772 = getelementptr inbounds %struct.sv, %struct.sv* %622, i32 0, i32 2
  %623 = load i32, i32* %sv_flags772, align 4
  %or773 = or i32 %623, %and771
  store i32 %or773, i32* %sv_flags772, align 4
  %624 = load %struct.sv**, %struct.sv*** %svp619, align 8
  %625 = load %struct.sv*, %struct.sv** %624, align 8
  call void @Perl_sv_free(%struct.sv* %625)
  %626 = load %struct.sv*, %struct.sv** %sv621, align 8
  %627 = load %struct.sv**, %struct.sv*** %svp619, align 8
  store %struct.sv* %626, %struct.sv** %627, align 8
  br label %for.inc.774

for.inc.774:                                      ; preds = %if.end.769
  %628 = load %struct.svop*, %struct.svop** %key_op, align 8
  %op_sibling775 = getelementptr inbounds %struct.svop, %struct.svop* %628, i32 0, i32 1
  %629 = load %struct.op*, %struct.op** %op_sibling775, align 8
  %630 = bitcast %struct.op* %629 to %struct.svop*
  store %struct.svop* %630, %struct.svop** %key_op, align 8
  br label %for.cond.694

for.end.776:                                      ; preds = %for.cond.694
  br label %sw.epilog

sw.bb.777:                                        ; preds = %if.end.12
  %631 = load %struct.op*, %struct.op** %o.addr, align 8
  %632 = bitcast %struct.op* %631 to %struct.unop*
  %op_first778 = getelementptr inbounds %struct.unop, %struct.unop* %632, i32 0, i32 8
  %633 = load %struct.op*, %struct.op** %op_first778, align 8
  store %struct.op* %633, %struct.op** %oright, align 8
  %634 = load %struct.op*, %struct.op** %oright, align 8
  %tobool779 = icmp ne %struct.op* %634, null
  br i1 %tobool779, label %lor.lhs.false.780, label %if.then.785

lor.lhs.false.780:                                ; preds = %sw.bb.777
  %635 = load %struct.op*, %struct.op** %oright, align 8
  %op_type781 = getelementptr inbounds %struct.op, %struct.op* %635, i32 0, i32 4
  %636 = load i16, i16* %op_type781, align 2
  %conv782 = zext i16 %636 to i32
  %cmp783 = icmp ne i32 %conv782, 3
  br i1 %cmp783, label %if.then.785, label %if.end.786

if.then.785:                                      ; preds = %lor.lhs.false.780, %sw.bb.777
  br label %sw.epilog

if.end.786:                                       ; preds = %lor.lhs.false.780
  %637 = load %struct.op*, %struct.op** %o.addr, align 8
  %638 = bitcast %struct.op* %637 to %struct.unop*
  %op_sibling787 = getelementptr inbounds %struct.unop, %struct.unop* %638, i32 0, i32 1
  %639 = load %struct.op*, %struct.op** %op_sibling787, align 8
  %tobool788 = icmp ne %struct.op* %639, null
  br i1 %tobool788, label %if.end.822, label %if.then.789

if.then.789:                                      ; preds = %if.end.786
  %640 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next790 = getelementptr inbounds %struct.op, %struct.op* %640, i32 0, i32 0
  %641 = load %struct.op*, %struct.op** %op_next790, align 8
  store %struct.op* %641, %struct.op** %reverse, align 8
  %642 = load %struct.op*, %struct.op** %reverse, align 8
  %op_type791 = getelementptr inbounds %struct.op, %struct.op* %642, i32 0, i32 4
  %643 = load i16, i16* %op_type791, align 2
  %conv792 = zext i16 %643 to i32
  %cmp793 = icmp eq i32 %conv792, 151
  br i1 %cmp793, label %land.lhs.true.795, label %if.end.821

land.lhs.true.795:                                ; preds = %if.then.789
  %644 = load %struct.op*, %struct.op** %reverse, align 8
  %op_flags796 = getelementptr inbounds %struct.op, %struct.op* %644, i32 0, i32 6
  %645 = load i8, i8* %op_flags796, align 1
  %conv797 = zext i8 %645 to i32
  %and798 = and i32 %conv797, 3
  %cmp799 = icmp eq i32 %and798, 3
  br i1 %cmp799, label %if.then.801, label %if.end.821

if.then.801:                                      ; preds = %land.lhs.true.795
  %646 = load %struct.op*, %struct.op** %reverse, align 8
  %647 = bitcast %struct.op* %646 to %struct.unop*
  %op_first802 = getelementptr inbounds %struct.unop, %struct.unop* %647, i32 0, i32 8
  %648 = load %struct.op*, %struct.op** %op_first802, align 8
  store %struct.op* %648, %struct.op** %pushmark, align 8
  %649 = load %struct.op*, %struct.op** %pushmark, align 8
  %tobool803 = icmp ne %struct.op* %649, null
  br i1 %tobool803, label %land.lhs.true.804, label %if.end.820

land.lhs.true.804:                                ; preds = %if.then.801
  %650 = load %struct.op*, %struct.op** %pushmark, align 8
  %op_type805 = getelementptr inbounds %struct.op, %struct.op* %650, i32 0, i32 4
  %651 = load i16, i16* %op_type805, align 2
  %conv806 = zext i16 %651 to i32
  %cmp807 = icmp eq i32 %conv806, 3
  br i1 %cmp807, label %land.lhs.true.809, label %if.end.820

land.lhs.true.809:                                ; preds = %land.lhs.true.804
  %652 = load %struct.op*, %struct.op** %pushmark, align 8
  %653 = bitcast %struct.op* %652 to %struct.unop*
  %op_sibling810 = getelementptr inbounds %struct.unop, %struct.unop* %653, i32 0, i32 1
  %654 = load %struct.op*, %struct.op** %op_sibling810, align 8
  %655 = load %struct.op*, %struct.op** %o.addr, align 8
  %cmp811 = icmp eq %struct.op* %654, %655
  br i1 %cmp811, label %if.then.813, label %if.end.820

if.then.813:                                      ; preds = %land.lhs.true.809
  %656 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private814 = getelementptr inbounds %struct.op, %struct.op* %656, i32 0, i32 7
  %657 = load i8, i8* %op_private814, align 1
  %conv815 = zext i8 %657 to i32
  %or816 = or i32 %conv815, 4
  %conv817 = trunc i32 %or816 to i8
  store i8 %conv817, i8* %op_private814, align 1
  %658 = load %struct.op*, %struct.op** %reverse, align 8
  call void @Perl_op_null(%struct.op* %658)
  %659 = load %struct.op*, %struct.op** %oright, align 8
  %op_next818 = getelementptr inbounds %struct.op, %struct.op* %659, i32 0, i32 0
  %660 = load %struct.op*, %struct.op** %op_next818, align 8
  %661 = load %struct.op*, %struct.op** %pushmark, align 8
  %op_next819 = getelementptr inbounds %struct.op, %struct.op* %661, i32 0, i32 0
  store %struct.op* %660, %struct.op** %op_next819, align 8
  %662 = load %struct.op*, %struct.op** %oright, align 8
  call void @Perl_op_null(%struct.op* %662)
  br label %if.end.820

if.end.820:                                       ; preds = %if.then.813, %land.lhs.true.809, %land.lhs.true.804, %if.then.801
  br label %if.end.821

if.end.821:                                       ; preds = %if.end.820, %land.lhs.true.795, %if.then.789
  br label %if.end.822

if.end.822:                                       ; preds = %if.end.821, %if.end.786
  %663 = load i16, i16* @PL_op_seqmax, align 2
  %inc823 = add i16 %663, 1
  store i16 %inc823, i16* @PL_op_seqmax, align 2
  %664 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_seq824 = getelementptr inbounds %struct.op, %struct.op* %664, i32 0, i32 5
  store i16 %663, i16* %op_seq824, align 2
  %665 = load %struct.op*, %struct.op** %oright, align 8
  %666 = bitcast %struct.op* %665 to %struct.unop*
  %op_sibling825 = getelementptr inbounds %struct.unop, %struct.unop* %666, i32 0, i32 1
  %667 = load %struct.op*, %struct.op** %op_sibling825, align 8
  store %struct.op* %667, %struct.op** %oright, align 8
  %668 = load %struct.op*, %struct.op** %oright, align 8
  %tobool826 = icmp ne %struct.op* %668, null
  br i1 %tobool826, label %if.end.828, label %if.then.827

if.then.827:                                      ; preds = %if.end.822
  br label %sw.epilog

if.end.828:                                       ; preds = %if.end.822
  %669 = load %struct.op*, %struct.op** %oright, align 8
  %op_type829 = getelementptr inbounds %struct.op, %struct.op* %669, i32 0, i32 4
  %670 = load i16, i16* %op_type829, align 2
  %conv830 = zext i16 %670 to i32
  %cmp831 = icmp eq i32 %conv830, 0
  br i1 %cmp831, label %if.then.833, label %if.end.835

if.then.833:                                      ; preds = %if.end.828
  %671 = load %struct.op*, %struct.op** %oright, align 8
  %672 = bitcast %struct.op* %671 to %struct.unop*
  %op_sibling834 = getelementptr inbounds %struct.unop, %struct.unop* %672, i32 0, i32 1
  %673 = load %struct.op*, %struct.op** %op_sibling834, align 8
  store %struct.op* %673, %struct.op** %oright, align 8
  br label %if.end.835

if.end.835:                                       ; preds = %if.then.833, %if.end.828
  %674 = load %struct.op*, %struct.op** %oright, align 8
  %tobool836 = icmp ne %struct.op* %674, null
  br i1 %tobool836, label %lor.lhs.false.837, label %if.then.856

lor.lhs.false.837:                                ; preds = %if.end.835
  %675 = load %struct.op*, %struct.op** %oright, align 8
  %op_type838 = getelementptr inbounds %struct.op, %struct.op* %675, i32 0, i32 4
  %676 = load i16, i16* %op_type838, align 2
  %conv839 = zext i16 %676 to i32
  %cmp840 = icmp ne i32 %conv839, 125
  br i1 %cmp840, label %land.lhs.true.842, label %lor.lhs.false.847

land.lhs.true.842:                                ; preds = %lor.lhs.false.837
  %677 = load %struct.op*, %struct.op** %oright, align 8
  %op_type843 = getelementptr inbounds %struct.op, %struct.op* %677, i32 0, i32 4
  %678 = load i16, i16* %op_type843, align 2
  %conv844 = zext i16 %678 to i32
  %cmp845 = icmp ne i32 %conv844, 10
  br i1 %cmp845, label %if.then.856, label %lor.lhs.false.847

lor.lhs.false.847:                                ; preds = %land.lhs.true.842, %lor.lhs.false.837
  %679 = load %struct.op*, %struct.op** %oright, align 8
  %op_next848 = getelementptr inbounds %struct.op, %struct.op* %679, i32 0, i32 0
  %680 = load %struct.op*, %struct.op** %op_next848, align 8
  %681 = load %struct.op*, %struct.op** %o.addr, align 8
  %cmp849 = icmp ne %struct.op* %680, %681
  br i1 %cmp849, label %if.then.856, label %lor.lhs.false.851

lor.lhs.false.851:                                ; preds = %lor.lhs.false.847
  %682 = load %struct.op*, %struct.op** %oright, align 8
  %op_private852 = getelementptr inbounds %struct.op, %struct.op* %682, i32 0, i32 7
  %683 = load i8, i8* %op_private852, align 1
  %conv853 = zext i8 %683 to i32
  %and854 = and i32 %conv853, 128
  %tobool855 = icmp ne i32 %and854, 0
  br i1 %tobool855, label %if.then.856, label %if.end.857

if.then.856:                                      ; preds = %lor.lhs.false.851, %lor.lhs.false.847, %land.lhs.true.842, %if.end.835
  br label %sw.epilog

if.end.857:                                       ; preds = %lor.lhs.false.851
  %684 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next858 = getelementptr inbounds %struct.op, %struct.op* %684, i32 0, i32 0
  %685 = load %struct.op*, %struct.op** %op_next858, align 8
  store %struct.op* %685, %struct.op** %o2, align 8
  %686 = load %struct.op*, %struct.op** %o2, align 8
  %tobool859 = icmp ne %struct.op* %686, null
  br i1 %tobool859, label %lor.lhs.false.860, label %if.then.865

lor.lhs.false.860:                                ; preds = %if.end.857
  %687 = load %struct.op*, %struct.op** %o2, align 8
  %op_type861 = getelementptr inbounds %struct.op, %struct.op* %687, i32 0, i32 4
  %688 = load i16, i16* %op_type861, align 2
  %conv862 = zext i16 %688 to i32
  %cmp863 = icmp ne i32 %conv862, 0
  br i1 %cmp863, label %if.then.865, label %if.end.866

if.then.865:                                      ; preds = %lor.lhs.false.860, %if.end.857
  br label %sw.epilog

if.end.866:                                       ; preds = %lor.lhs.false.860
  %689 = load %struct.op*, %struct.op** %o2, align 8
  %op_next867 = getelementptr inbounds %struct.op, %struct.op* %689, i32 0, i32 0
  %690 = load %struct.op*, %struct.op** %op_next867, align 8
  store %struct.op* %690, %struct.op** %o2, align 8
  %691 = load %struct.op*, %struct.op** %o2, align 8
  %tobool868 = icmp ne %struct.op* %691, null
  br i1 %tobool868, label %lor.lhs.false.869, label %if.then.874

lor.lhs.false.869:                                ; preds = %if.end.866
  %692 = load %struct.op*, %struct.op** %o2, align 8
  %op_type870 = getelementptr inbounds %struct.op, %struct.op* %692, i32 0, i32 4
  %693 = load i16, i16* %op_type870, align 2
  %conv871 = zext i16 %693 to i32
  %cmp872 = icmp ne i32 %conv871, 3
  br i1 %cmp872, label %if.then.874, label %if.end.875

if.then.874:                                      ; preds = %lor.lhs.false.869, %if.end.866
  br label %sw.epilog

if.end.875:                                       ; preds = %lor.lhs.false.869
  %694 = load %struct.op*, %struct.op** %o2, align 8
  %op_next876 = getelementptr inbounds %struct.op, %struct.op* %694, i32 0, i32 0
  %695 = load %struct.op*, %struct.op** %op_next876, align 8
  store %struct.op* %695, %struct.op** %o2, align 8
  %696 = load %struct.op*, %struct.op** %o2, align 8
  %tobool877 = icmp ne %struct.op* %696, null
  br i1 %tobool877, label %land.lhs.true.878, label %if.end.885

land.lhs.true.878:                                ; preds = %if.end.875
  %697 = load %struct.op*, %struct.op** %o2, align 8
  %op_type879 = getelementptr inbounds %struct.op, %struct.op* %697, i32 0, i32 4
  %698 = load i16, i16* %op_type879, align 2
  %conv880 = zext i16 %698 to i32
  %cmp881 = icmp eq i32 %conv880, 7
  br i1 %cmp881, label %if.then.883, label %if.end.885

if.then.883:                                      ; preds = %land.lhs.true.878
  %699 = load %struct.op*, %struct.op** %o2, align 8
  %op_next884 = getelementptr inbounds %struct.op, %struct.op* %699, i32 0, i32 0
  %700 = load %struct.op*, %struct.op** %op_next884, align 8
  store %struct.op* %700, %struct.op** %o2, align 8
  br label %if.end.885

if.end.885:                                       ; preds = %if.then.883, %land.lhs.true.878, %if.end.875
  %701 = load %struct.op*, %struct.op** %o2, align 8
  %tobool886 = icmp ne %struct.op* %701, null
  br i1 %tobool886, label %lor.lhs.false.887, label %if.then.902

lor.lhs.false.887:                                ; preds = %if.end.885
  %702 = load %struct.op*, %struct.op** %o2, align 8
  %op_type888 = getelementptr inbounds %struct.op, %struct.op* %702, i32 0, i32 4
  %703 = load i16, i16* %op_type888, align 2
  %conv889 = zext i16 %703 to i32
  %cmp890 = icmp ne i32 %conv889, 10
  br i1 %cmp890, label %land.lhs.true.892, label %lor.lhs.false.897

land.lhs.true.892:                                ; preds = %lor.lhs.false.887
  %704 = load %struct.op*, %struct.op** %o2, align 8
  %op_type893 = getelementptr inbounds %struct.op, %struct.op* %704, i32 0, i32 4
  %705 = load i16, i16* %op_type893, align 2
  %conv894 = zext i16 %705 to i32
  %cmp895 = icmp ne i32 %conv894, 125
  br i1 %cmp895, label %if.then.902, label %lor.lhs.false.897

lor.lhs.false.897:                                ; preds = %land.lhs.true.892, %lor.lhs.false.887
  %706 = load %struct.op*, %struct.op** %o2, align 8
  %op_private898 = getelementptr inbounds %struct.op, %struct.op* %706, i32 0, i32 7
  %707 = load i8, i8* %op_private898, align 1
  %conv899 = zext i8 %707 to i32
  %and900 = and i32 %conv899, 128
  %tobool901 = icmp ne i32 %and900, 0
  br i1 %tobool901, label %if.then.902, label %if.end.903

if.then.902:                                      ; preds = %lor.lhs.false.897, %land.lhs.true.892, %if.end.885
  br label %sw.epilog

if.end.903:                                       ; preds = %lor.lhs.false.897
  %708 = load %struct.op*, %struct.op** %o2, align 8
  store %struct.op* %708, %struct.op** %oleft, align 8
  %709 = load %struct.op*, %struct.op** %o2, align 8
  %op_next904 = getelementptr inbounds %struct.op, %struct.op* %709, i32 0, i32 0
  %710 = load %struct.op*, %struct.op** %op_next904, align 8
  store %struct.op* %710, %struct.op** %o2, align 8
  %711 = load %struct.op*, %struct.op** %o2, align 8
  %tobool905 = icmp ne %struct.op* %711, null
  br i1 %tobool905, label %lor.lhs.false.906, label %if.then.911

lor.lhs.false.906:                                ; preds = %if.end.903
  %712 = load %struct.op*, %struct.op** %o2, align 8
  %op_type907 = getelementptr inbounds %struct.op, %struct.op* %712, i32 0, i32 4
  %713 = load i16, i16* %op_type907, align 2
  %conv908 = zext i16 %713 to i32
  %cmp909 = icmp ne i32 %conv908, 0
  br i1 %cmp909, label %if.then.911, label %if.end.912

if.then.911:                                      ; preds = %lor.lhs.false.906, %if.end.903
  br label %sw.epilog

if.end.912:                                       ; preds = %lor.lhs.false.906
  %714 = load %struct.op*, %struct.op** %o2, align 8
  %op_next913 = getelementptr inbounds %struct.op, %struct.op* %714, i32 0, i32 0
  %715 = load %struct.op*, %struct.op** %op_next913, align 8
  store %struct.op* %715, %struct.op** %o2, align 8
  %716 = load %struct.op*, %struct.op** %o2, align 8
  %tobool914 = icmp ne %struct.op* %716, null
  br i1 %tobool914, label %lor.lhs.false.915, label %if.then.926

lor.lhs.false.915:                                ; preds = %if.end.912
  %717 = load %struct.op*, %struct.op** %o2, align 8
  %op_type916 = getelementptr inbounds %struct.op, %struct.op* %717, i32 0, i32 4
  %718 = load i16, i16* %op_type916, align 2
  %conv917 = zext i16 %718 to i32
  %cmp918 = icmp ne i32 %conv917, 37
  br i1 %cmp918, label %if.then.926, label %lor.lhs.false.920

lor.lhs.false.920:                                ; preds = %lor.lhs.false.915
  %719 = load %struct.op*, %struct.op** %o2, align 8
  %op_flags921 = getelementptr inbounds %struct.op, %struct.op* %719, i32 0, i32 6
  %720 = load i8, i8* %op_flags921, align 1
  %conv922 = zext i8 %720 to i32
  %and923 = and i32 %conv922, 3
  %cmp924 = icmp ne i32 %and923, 1
  br i1 %cmp924, label %if.then.926, label %if.end.927

if.then.926:                                      ; preds = %lor.lhs.false.920, %lor.lhs.false.915, %if.end.912
  br label %sw.epilog

if.end.927:                                       ; preds = %lor.lhs.false.920
  %721 = load %struct.op*, %struct.op** %o2, align 8
  %722 = bitcast %struct.op* %721 to %struct.unop*
  %op_first928 = getelementptr inbounds %struct.unop, %struct.unop* %722, i32 0, i32 8
  %723 = load %struct.op*, %struct.op** %op_first928, align 8
  store %struct.op* %723, %struct.op** %o2, align 8
  %724 = load %struct.op*, %struct.op** %o2, align 8
  %tobool929 = icmp ne %struct.op* %724, null
  br i1 %tobool929, label %lor.lhs.false.930, label %if.then.935

lor.lhs.false.930:                                ; preds = %if.end.927
  %725 = load %struct.op*, %struct.op** %o2, align 8
  %op_type931 = getelementptr inbounds %struct.op, %struct.op* %725, i32 0, i32 4
  %726 = load i16, i16* %op_type931, align 2
  %conv932 = zext i16 %726 to i32
  %cmp933 = icmp ne i32 %conv932, 0
  br i1 %cmp933, label %if.then.935, label %if.end.936

if.then.935:                                      ; preds = %lor.lhs.false.930, %if.end.927
  br label %sw.epilog

if.end.936:                                       ; preds = %lor.lhs.false.930
  %727 = load %struct.op*, %struct.op** %o2, align 8
  %728 = bitcast %struct.op* %727 to %struct.unop*
  %op_first937 = getelementptr inbounds %struct.unop, %struct.unop* %728, i32 0, i32 8
  %729 = load %struct.op*, %struct.op** %op_first937, align 8
  store %struct.op* %729, %struct.op** %o2, align 8
  %730 = load %struct.op*, %struct.op** %o2, align 8
  %tobool938 = icmp ne %struct.op* %730, null
  br i1 %tobool938, label %lor.lhs.false.939, label %if.then.944

lor.lhs.false.939:                                ; preds = %if.end.936
  %731 = load %struct.op*, %struct.op** %o2, align 8
  %op_type940 = getelementptr inbounds %struct.op, %struct.op* %731, i32 0, i32 4
  %732 = load i16, i16* %op_type940, align 2
  %conv941 = zext i16 %732 to i32
  %cmp942 = icmp ne i32 %conv941, 3
  br i1 %cmp942, label %if.then.944, label %if.end.945

if.then.944:                                      ; preds = %lor.lhs.false.939, %if.end.936
  br label %sw.epilog

if.end.945:                                       ; preds = %lor.lhs.false.939
  %733 = load %struct.op*, %struct.op** %o2, align 8
  %op_sibling946 = getelementptr inbounds %struct.op, %struct.op* %733, i32 0, i32 1
  %734 = load %struct.op*, %struct.op** %op_sibling946, align 8
  %735 = load %struct.op*, %struct.op** %o.addr, align 8
  %cmp947 = icmp ne %struct.op* %734, %735
  br i1 %cmp947, label %if.then.949, label %if.end.950

if.then.949:                                      ; preds = %if.end.945
  br label %sw.epilog

if.end.950:                                       ; preds = %if.end.945
  %736 = load %struct.op*, %struct.op** %oleft, align 8
  %op_type951 = getelementptr inbounds %struct.op, %struct.op* %736, i32 0, i32 4
  %737 = load i16, i16* %op_type951, align 2
  %conv952 = zext i16 %737 to i32
  %cmp953 = icmp eq i32 %conv952, 125
  br i1 %cmp953, label %if.then.955, label %if.else.978

if.then.955:                                      ; preds = %if.end.950
  %738 = load %struct.op*, %struct.op** %oright, align 8
  %op_type956 = getelementptr inbounds %struct.op, %struct.op* %738, i32 0, i32 4
  %739 = load i16, i16* %op_type956, align 2
  %conv957 = zext i16 %739 to i32
  %cmp958 = icmp ne i32 %conv957, 125
  br i1 %cmp958, label %if.then.976, label %lor.lhs.false.960

lor.lhs.false.960:                                ; preds = %if.then.955
  %740 = load %struct.op*, %struct.op** %oright, align 8
  %741 = bitcast %struct.op* %740 to %struct.unop*
  %op_first961 = getelementptr inbounds %struct.unop, %struct.unop* %741, i32 0, i32 8
  %742 = load %struct.op*, %struct.op** %op_first961, align 8
  %tobool962 = icmp ne %struct.op* %742, null
  br i1 %tobool962, label %lor.lhs.false.963, label %if.then.976

lor.lhs.false.963:                                ; preds = %lor.lhs.false.960
  %743 = load %struct.op*, %struct.op** %oright, align 8
  %744 = bitcast %struct.op* %743 to %struct.unop*
  %op_first964 = getelementptr inbounds %struct.unop, %struct.unop* %744, i32 0, i32 8
  %745 = load %struct.op*, %struct.op** %op_first964, align 8
  %op_type965 = getelementptr inbounds %struct.op, %struct.op* %745, i32 0, i32 4
  %746 = load i16, i16* %op_type965, align 2
  %conv966 = zext i16 %746 to i32
  %cmp967 = icmp ne i32 %conv966, 7
  br i1 %cmp967, label %if.then.976, label %lor.lhs.false.969

lor.lhs.false.969:                                ; preds = %lor.lhs.false.963
  %747 = load %struct.op*, %struct.op** %oleft, align 8
  %748 = bitcast %struct.op* %747 to %struct.unop*
  %op_first970 = getelementptr inbounds %struct.unop, %struct.unop* %748, i32 0, i32 8
  %749 = load %struct.op*, %struct.op** %op_first970, align 8
  %750 = bitcast %struct.op* %749 to %struct.svop*
  %op_sv971 = getelementptr inbounds %struct.svop, %struct.svop* %750, i32 0, i32 8
  %751 = load %struct.sv*, %struct.sv** %op_sv971, align 8
  %752 = bitcast %struct.sv* %751 to %struct.gv*
  %753 = load %struct.op*, %struct.op** %oright, align 8
  %754 = bitcast %struct.op* %753 to %struct.unop*
  %op_first972 = getelementptr inbounds %struct.unop, %struct.unop* %754, i32 0, i32 8
  %755 = load %struct.op*, %struct.op** %op_first972, align 8
  %756 = bitcast %struct.op* %755 to %struct.svop*
  %op_sv973 = getelementptr inbounds %struct.svop, %struct.svop* %756, i32 0, i32 8
  %757 = load %struct.sv*, %struct.sv** %op_sv973, align 8
  %758 = bitcast %struct.sv* %757 to %struct.gv*
  %cmp974 = icmp ne %struct.gv* %752, %758
  br i1 %cmp974, label %if.then.976, label %if.end.977

if.then.976:                                      ; preds = %lor.lhs.false.969, %lor.lhs.false.963, %lor.lhs.false.960, %if.then.955
  br label %sw.epilog

if.end.977:                                       ; preds = %lor.lhs.false.969
  br label %if.end.990

if.else.978:                                      ; preds = %if.end.950
  %759 = load %struct.op*, %struct.op** %oright, align 8
  %op_type979 = getelementptr inbounds %struct.op, %struct.op* %759, i32 0, i32 4
  %760 = load i16, i16* %op_type979, align 2
  %conv980 = zext i16 %760 to i32
  %cmp981 = icmp ne i32 %conv980, 10
  br i1 %cmp981, label %if.then.988, label %lor.lhs.false.983

lor.lhs.false.983:                                ; preds = %if.else.978
  %761 = load %struct.op*, %struct.op** %oright, align 8
  %op_targ984 = getelementptr inbounds %struct.op, %struct.op* %761, i32 0, i32 3
  %762 = load i64, i64* %op_targ984, align 8
  %763 = load %struct.op*, %struct.op** %oleft, align 8
  %op_targ985 = getelementptr inbounds %struct.op, %struct.op* %763, i32 0, i32 3
  %764 = load i64, i64* %op_targ985, align 8
  %cmp986 = icmp ne i64 %762, %764
  br i1 %cmp986, label %if.then.988, label %if.end.989

if.then.988:                                      ; preds = %lor.lhs.false.983, %if.else.978
  br label %sw.epilog

if.end.989:                                       ; preds = %lor.lhs.false.983
  br label %if.end.990

if.end.990:                                       ; preds = %if.end.989, %if.end.977
  %765 = load %struct.op*, %struct.op** %oleft, align 8
  %op_flags991 = getelementptr inbounds %struct.op, %struct.op* %765, i32 0, i32 6
  %766 = load i8, i8* %op_flags991, align 1
  %767 = load %struct.op*, %struct.op** %oright, align 8
  %op_flags992 = getelementptr inbounds %struct.op, %struct.op* %767, i32 0, i32 6
  store i8 %766, i8* %op_flags992, align 1
  %768 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_private993 = getelementptr inbounds %struct.op, %struct.op* %768, i32 0, i32 7
  %769 = load i8, i8* %op_private993, align 1
  %conv994 = zext i8 %769 to i32
  %or995 = or i32 %conv994, 8
  %conv996 = trunc i32 %or995 to i8
  store i8 %conv996, i8* %op_private993, align 1
  %770 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next997 = getelementptr inbounds %struct.op, %struct.op* %770, i32 0, i32 0
  %771 = load %struct.op*, %struct.op** %op_next997, align 8
  %op_next998 = getelementptr inbounds %struct.op, %struct.op* %771, i32 0, i32 0
  %772 = load %struct.op*, %struct.op** %op_next998, align 8
  store %struct.op* %772, %struct.op** %o2, align 8
  %773 = load %struct.op*, %struct.op** %o2, align 8
  call void @Perl_op_null(%struct.op* %773)
  %774 = load %struct.op*, %struct.op** %o2, align 8
  %op_next999 = getelementptr inbounds %struct.op, %struct.op* %774, i32 0, i32 0
  %775 = load %struct.op*, %struct.op** %op_next999, align 8
  store %struct.op* %775, %struct.op** %o2, align 8
  %776 = load %struct.op*, %struct.op** %o2, align 8
  %op_type1000 = getelementptr inbounds %struct.op, %struct.op* %776, i32 0, i32 4
  %777 = load i16, i16* %op_type1000, align 2
  %conv1001 = zext i16 %777 to i32
  %cmp1002 = icmp eq i32 %conv1001, 7
  br i1 %cmp1002, label %if.then.1004, label %if.end.1006

if.then.1004:                                     ; preds = %if.end.990
  %778 = load %struct.op*, %struct.op** %o2, align 8
  call void @Perl_op_null(%struct.op* %778)
  %779 = load %struct.op*, %struct.op** %o2, align 8
  %op_next1005 = getelementptr inbounds %struct.op, %struct.op* %779, i32 0, i32 0
  %780 = load %struct.op*, %struct.op** %op_next1005, align 8
  store %struct.op* %780, %struct.op** %o2, align 8
  br label %if.end.1006

if.end.1006:                                      ; preds = %if.then.1004, %if.end.990
  %781 = load %struct.op*, %struct.op** %o2, align 8
  call void @Perl_op_null(%struct.op* %781)
  %782 = load %struct.op*, %struct.op** %o2, align 8
  %op_next1007 = getelementptr inbounds %struct.op, %struct.op* %782, i32 0, i32 0
  %783 = load %struct.op*, %struct.op** %op_next1007, align 8
  %op_next1008 = getelementptr inbounds %struct.op, %struct.op* %783, i32 0, i32 0
  %784 = load %struct.op*, %struct.op** %op_next1008, align 8
  store %struct.op* %784, %struct.op** %o2, align 8
  %785 = load %struct.op*, %struct.op** %o2, align 8
  call void @Perl_op_null(%struct.op* %785)
  %786 = load %struct.op*, %struct.op** %o2, align 8
  %op_next1009 = getelementptr inbounds %struct.op, %struct.op* %786, i32 0, i32 0
  %787 = load %struct.op*, %struct.op** %op_next1009, align 8
  %788 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next1010 = getelementptr inbounds %struct.op, %struct.op* %788, i32 0, i32 0
  store %struct.op* %787, %struct.op** %op_next1010, align 8
  br label %sw.epilog

sw.bb.1011:                                       ; preds = %if.end.12
  store %struct.op* null, %struct.op** %gvop, align 8
  %789 = load i16, i16* @PL_op_seqmax, align 2
  %inc1012 = add i16 %789, 1
  store i16 %inc1012, i16* @PL_op_seqmax, align 2
  %790 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_seq1013 = getelementptr inbounds %struct.op, %struct.op* %790, i32 0, i32 5
  store i16 %789, i16* %op_seq1013, align 2
  %791 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next1014 = getelementptr inbounds %struct.op, %struct.op* %791, i32 0, i32 0
  %792 = load %struct.op*, %struct.op** %op_next1014, align 8
  %793 = bitcast %struct.op* %792 to %struct.listop*
  store %struct.listop* %793, %struct.listop** %enter, align 8
  %794 = load %struct.listop*, %struct.listop** %enter, align 8
  %tobool1015 = icmp ne %struct.listop* %794, null
  br i1 %tobool1015, label %if.end.1017, label %if.then.1016

if.then.1016:                                     ; preds = %sw.bb.1011
  br label %sw.epilog

if.end.1017:                                      ; preds = %sw.bb.1011
  %795 = load %struct.listop*, %struct.listop** %enter, align 8
  %op_type1018 = getelementptr inbounds %struct.listop, %struct.listop* %795, i32 0, i32 4
  %796 = load i16, i16* %op_type1018, align 2
  %conv1019 = zext i16 %796 to i32
  %cmp1020 = icmp eq i32 %conv1019, 0
  br i1 %cmp1020, label %if.then.1022, label %if.end.1027

if.then.1022:                                     ; preds = %if.end.1017
  %797 = load %struct.listop*, %struct.listop** %enter, align 8
  %op_next1023 = getelementptr inbounds %struct.listop, %struct.listop* %797, i32 0, i32 0
  %798 = load %struct.op*, %struct.op** %op_next1023, align 8
  %799 = bitcast %struct.op* %798 to %struct.listop*
  store %struct.listop* %799, %struct.listop** %enter, align 8
  %800 = load %struct.listop*, %struct.listop** %enter, align 8
  %tobool1024 = icmp ne %struct.listop* %800, null
  br i1 %tobool1024, label %if.end.1026, label %if.then.1025

if.then.1025:                                     ; preds = %if.then.1022
  br label %sw.epilog

if.end.1026:                                      ; preds = %if.then.1022
  br label %if.end.1027

if.end.1027:                                      ; preds = %if.end.1026, %if.end.1017
  %801 = load %struct.listop*, %struct.listop** %enter, align 8
  %op_type1028 = getelementptr inbounds %struct.listop, %struct.listop* %801, i32 0, i32 4
  %802 = load i16, i16* %op_type1028, align 2
  %conv1029 = zext i16 %802 to i32
  %cmp1030 = icmp eq i32 %conv1029, 7
  br i1 %cmp1030, label %if.then.1032, label %if.end.1047

if.then.1032:                                     ; preds = %if.end.1027
  %803 = load %struct.listop*, %struct.listop** %enter, align 8
  %804 = bitcast %struct.listop* %803 to %struct.op*
  store %struct.op* %804, %struct.op** %gvop, align 8
  %805 = load %struct.listop*, %struct.listop** %enter, align 8
  %op_next1033 = getelementptr inbounds %struct.listop, %struct.listop* %805, i32 0, i32 0
  %806 = load %struct.op*, %struct.op** %op_next1033, align 8
  %807 = bitcast %struct.op* %806 to %struct.listop*
  store %struct.listop* %807, %struct.listop** %enter, align 8
  %808 = load %struct.listop*, %struct.listop** %enter, align 8
  %tobool1034 = icmp ne %struct.listop* %808, null
  br i1 %tobool1034, label %if.end.1036, label %if.then.1035

if.then.1035:                                     ; preds = %if.then.1032
  br label %sw.epilog

if.end.1036:                                      ; preds = %if.then.1032
  %809 = load %struct.listop*, %struct.listop** %enter, align 8
  %op_type1037 = getelementptr inbounds %struct.listop, %struct.listop* %809, i32 0, i32 4
  %810 = load i16, i16* %op_type1037, align 2
  %conv1038 = zext i16 %810 to i32
  %cmp1039 = icmp eq i32 %conv1038, 14
  br i1 %cmp1039, label %if.then.1041, label %if.end.1046

if.then.1041:                                     ; preds = %if.end.1036
  %811 = load %struct.listop*, %struct.listop** %enter, align 8
  %op_next1042 = getelementptr inbounds %struct.listop, %struct.listop* %811, i32 0, i32 0
  %812 = load %struct.op*, %struct.op** %op_next1042, align 8
  %813 = bitcast %struct.op* %812 to %struct.listop*
  store %struct.listop* %813, %struct.listop** %enter, align 8
  %814 = load %struct.listop*, %struct.listop** %enter, align 8
  %tobool1043 = icmp ne %struct.listop* %814, null
  br i1 %tobool1043, label %if.end.1045, label %if.then.1044

if.then.1044:                                     ; preds = %if.then.1041
  br label %sw.epilog

if.end.1045:                                      ; preds = %if.then.1041
  br label %if.end.1046

if.end.1046:                                      ; preds = %if.end.1045, %if.end.1036
  br label %if.end.1047

if.end.1047:                                      ; preds = %if.end.1046, %if.end.1027
  %815 = load %struct.listop*, %struct.listop** %enter, align 8
  %op_type1048 = getelementptr inbounds %struct.listop, %struct.listop* %815, i32 0, i32 4
  %816 = load i16, i16* %op_type1048, align 2
  %conv1049 = zext i16 %816 to i32
  %cmp1050 = icmp ne i32 %conv1049, 180
  br i1 %cmp1050, label %if.then.1052, label %if.end.1053

if.then.1052:                                     ; preds = %if.end.1047
  br label %sw.epilog

if.end.1053:                                      ; preds = %if.end.1047
  %817 = load %struct.listop*, %struct.listop** %enter, align 8
  %op_next1054 = getelementptr inbounds %struct.listop, %struct.listop* %817, i32 0, i32 0
  %818 = load %struct.op*, %struct.op** %op_next1054, align 8
  store %struct.op* %818, %struct.op** %iter, align 8
  %819 = load %struct.op*, %struct.op** %iter, align 8
  %tobool1055 = icmp ne %struct.op* %819, null
  br i1 %tobool1055, label %lor.lhs.false.1056, label %if.then.1061

lor.lhs.false.1056:                               ; preds = %if.end.1053
  %820 = load %struct.op*, %struct.op** %iter, align 8
  %op_type1057 = getelementptr inbounds %struct.op, %struct.op* %820, i32 0, i32 4
  %821 = load i16, i16* %op_type1057, align 2
  %conv1058 = zext i16 %821 to i32
  %cmp1059 = icmp ne i32 %conv1058, 181
  br i1 %cmp1059, label %if.then.1061, label %if.end.1062

if.then.1061:                                     ; preds = %lor.lhs.false.1056, %if.end.1053
  br label %sw.epilog

if.end.1062:                                      ; preds = %lor.lhs.false.1056
  %822 = load %struct.listop*, %struct.listop** %enter, align 8
  %op_first1063 = getelementptr inbounds %struct.listop, %struct.listop* %822, i32 0, i32 8
  %823 = load %struct.op*, %struct.op** %op_first1063, align 8
  store %struct.op* %823, %struct.op** %expushmark, align 8
  %824 = load %struct.op*, %struct.op** %expushmark, align 8
  %tobool1064 = icmp ne %struct.op* %824, null
  br i1 %tobool1064, label %lor.lhs.false.1065, label %if.then.1074

lor.lhs.false.1065:                               ; preds = %if.end.1062
  %825 = load %struct.op*, %struct.op** %expushmark, align 8
  %op_type1066 = getelementptr inbounds %struct.op, %struct.op* %825, i32 0, i32 4
  %826 = load i16, i16* %op_type1066, align 2
  %conv1067 = zext i16 %826 to i32
  %cmp1068 = icmp ne i32 %conv1067, 0
  br i1 %cmp1068, label %if.then.1074, label %lor.lhs.false.1070

lor.lhs.false.1070:                               ; preds = %lor.lhs.false.1065
  %827 = load %struct.op*, %struct.op** %expushmark, align 8
  %op_targ1071 = getelementptr inbounds %struct.op, %struct.op* %827, i32 0, i32 3
  %828 = load i64, i64* %op_targ1071, align 8
  %cmp1072 = icmp ne i64 %828, 3
  br i1 %cmp1072, label %if.then.1074, label %if.end.1075

if.then.1074:                                     ; preds = %lor.lhs.false.1070, %lor.lhs.false.1065, %if.end.1062
  br label %sw.epilog

if.end.1075:                                      ; preds = %lor.lhs.false.1070
  %829 = load %struct.op*, %struct.op** %expushmark, align 8
  %op_sibling1076 = getelementptr inbounds %struct.op, %struct.op* %829, i32 0, i32 1
  %830 = load %struct.op*, %struct.op** %op_sibling1076, align 8
  %831 = bitcast %struct.op* %830 to %struct.listop*
  store %struct.listop* %831, %struct.listop** %exlist, align 8
  %832 = load %struct.listop*, %struct.listop** %exlist, align 8
  %tobool1077 = icmp ne %struct.listop* %832, null
  br i1 %tobool1077, label %lor.lhs.false.1078, label %if.then.1087

lor.lhs.false.1078:                               ; preds = %if.end.1075
  %833 = load %struct.listop*, %struct.listop** %exlist, align 8
  %op_type1079 = getelementptr inbounds %struct.listop, %struct.listop* %833, i32 0, i32 4
  %834 = load i16, i16* %op_type1079, align 2
  %conv1080 = zext i16 %834 to i32
  %cmp1081 = icmp ne i32 %conv1080, 0
  br i1 %cmp1081, label %if.then.1087, label %lor.lhs.false.1083

lor.lhs.false.1083:                               ; preds = %lor.lhs.false.1078
  %835 = load %struct.listop*, %struct.listop** %exlist, align 8
  %op_targ1084 = getelementptr inbounds %struct.listop, %struct.listop* %835, i32 0, i32 3
  %836 = load i64, i64* %op_targ1084, align 8
  %cmp1085 = icmp ne i64 %836, 141
  br i1 %cmp1085, label %if.then.1087, label %if.end.1088

if.then.1087:                                     ; preds = %lor.lhs.false.1083, %lor.lhs.false.1078, %if.end.1075
  br label %sw.epilog

if.end.1088:                                      ; preds = %lor.lhs.false.1083
  %837 = load %struct.listop*, %struct.listop** %exlist, align 8
  %op_last1089 = getelementptr inbounds %struct.listop, %struct.listop* %837, i32 0, i32 9
  %838 = load %struct.op*, %struct.op** %op_last1089, align 8
  %839 = load %struct.op*, %struct.op** %o.addr, align 8
  %cmp1090 = icmp ne %struct.op* %838, %839
  br i1 %cmp1090, label %if.then.1092, label %if.end.1093

if.then.1092:                                     ; preds = %if.end.1088
  br label %sw.epilog

if.end.1093:                                      ; preds = %if.end.1088
  %840 = load %struct.listop*, %struct.listop** %exlist, align 8
  %op_first1094 = getelementptr inbounds %struct.listop, %struct.listop* %840, i32 0, i32 8
  %841 = load %struct.op*, %struct.op** %op_first1094, align 8
  store %struct.op* %841, %struct.op** %theirmark, align 8
  %842 = load %struct.op*, %struct.op** %theirmark, align 8
  %tobool1095 = icmp ne %struct.op* %842, null
  br i1 %tobool1095, label %lor.lhs.false.1096, label %if.then.1101

lor.lhs.false.1096:                               ; preds = %if.end.1093
  %843 = load %struct.op*, %struct.op** %theirmark, align 8
  %op_type1097 = getelementptr inbounds %struct.op, %struct.op* %843, i32 0, i32 4
  %844 = load i16, i16* %op_type1097, align 2
  %conv1098 = zext i16 %844 to i32
  %cmp1099 = icmp ne i32 %conv1098, 3
  br i1 %cmp1099, label %if.then.1101, label %if.end.1102

if.then.1101:                                     ; preds = %lor.lhs.false.1096, %if.end.1093
  br label %sw.epilog

if.end.1102:                                      ; preds = %lor.lhs.false.1096
  %845 = load %struct.op*, %struct.op** %theirmark, align 8
  %op_sibling1103 = getelementptr inbounds %struct.op, %struct.op* %845, i32 0, i32 1
  %846 = load %struct.op*, %struct.op** %op_sibling1103, align 8
  %847 = load %struct.op*, %struct.op** %o.addr, align 8
  %cmp1104 = icmp ne %struct.op* %846, %847
  br i1 %cmp1104, label %if.then.1106, label %if.end.1107

if.then.1106:                                     ; preds = %if.end.1102
  br label %sw.epilog

if.end.1107:                                      ; preds = %if.end.1102
  %848 = load %struct.op*, %struct.op** %o.addr, align 8
  %849 = bitcast %struct.op* %848 to %struct.listop*
  %op_first1108 = getelementptr inbounds %struct.listop, %struct.listop* %849, i32 0, i32 8
  %850 = load %struct.op*, %struct.op** %op_first1108, align 8
  store %struct.op* %850, %struct.op** %ourmark, align 8
  %851 = load %struct.op*, %struct.op** %ourmark, align 8
  %tobool1109 = icmp ne %struct.op* %851, null
  br i1 %tobool1109, label %lor.lhs.false.1110, label %if.then.1115

lor.lhs.false.1110:                               ; preds = %if.end.1107
  %852 = load %struct.op*, %struct.op** %ourmark, align 8
  %op_type1111 = getelementptr inbounds %struct.op, %struct.op* %852, i32 0, i32 4
  %853 = load i16, i16* %op_type1111, align 2
  %conv1112 = zext i16 %853 to i32
  %cmp1113 = icmp ne i32 %conv1112, 3
  br i1 %cmp1113, label %if.then.1115, label %if.end.1116

if.then.1115:                                     ; preds = %lor.lhs.false.1110, %if.end.1107
  br label %sw.epilog

if.end.1116:                                      ; preds = %lor.lhs.false.1110
  %854 = load %struct.op*, %struct.op** %o.addr, align 8
  %855 = bitcast %struct.op* %854 to %struct.listop*
  %op_last1117 = getelementptr inbounds %struct.listop, %struct.listop* %855, i32 0, i32 9
  %856 = load %struct.op*, %struct.op** %op_last1117, align 8
  store %struct.op* %856, %struct.op** %ourlast, align 8
  %857 = load %struct.op*, %struct.op** %ourlast, align 8
  %tobool1118 = icmp ne %struct.op* %857, null
  br i1 %tobool1118, label %lor.lhs.false.1119, label %if.then.1123

lor.lhs.false.1119:                               ; preds = %if.end.1116
  %858 = load %struct.op*, %struct.op** %ourlast, align 8
  %op_next1120 = getelementptr inbounds %struct.op, %struct.op* %858, i32 0, i32 0
  %859 = load %struct.op*, %struct.op** %op_next1120, align 8
  %860 = load %struct.op*, %struct.op** %o.addr, align 8
  %cmp1121 = icmp ne %struct.op* %859, %860
  br i1 %cmp1121, label %if.then.1123, label %if.end.1124

if.then.1123:                                     ; preds = %lor.lhs.false.1119, %if.end.1116
  br label %sw.epilog

if.end.1124:                                      ; preds = %lor.lhs.false.1119
  %861 = load %struct.op*, %struct.op** %ourmark, align 8
  %op_sibling1125 = getelementptr inbounds %struct.op, %struct.op* %861, i32 0, i32 1
  %862 = load %struct.op*, %struct.op** %op_sibling1125, align 8
  store %struct.op* %862, %struct.op** %rv2av, align 8
  %863 = load %struct.op*, %struct.op** %rv2av, align 8
  %tobool1126 = icmp ne %struct.op* %863, null
  br i1 %tobool1126, label %land.lhs.true.1127, label %if.end.1152

land.lhs.true.1127:                               ; preds = %if.end.1124
  %864 = load %struct.op*, %struct.op** %rv2av, align 8
  %op_type1128 = getelementptr inbounds %struct.op, %struct.op* %864, i32 0, i32 4
  %865 = load i16, i16* %op_type1128, align 2
  %conv1129 = zext i16 %865 to i32
  %cmp1130 = icmp eq i32 %conv1129, 125
  br i1 %cmp1130, label %land.lhs.true.1132, label %if.end.1152

land.lhs.true.1132:                               ; preds = %land.lhs.true.1127
  %866 = load %struct.op*, %struct.op** %rv2av, align 8
  %op_sibling1133 = getelementptr inbounds %struct.op, %struct.op* %866, i32 0, i32 1
  %867 = load %struct.op*, %struct.op** %op_sibling1133, align 8
  %cmp1134 = icmp eq %struct.op* %867, null
  br i1 %cmp1134, label %land.lhs.true.1136, label %if.end.1152

land.lhs.true.1136:                               ; preds = %land.lhs.true.1132
  %868 = load %struct.op*, %struct.op** %rv2av, align 8
  %op_flags1137 = getelementptr inbounds %struct.op, %struct.op* %868, i32 0, i32 6
  %869 = load i8, i8* %op_flags1137, align 1
  %conv1138 = zext i8 %869 to i32
  %cmp1139 = icmp eq i32 %conv1138, 7
  br i1 %cmp1139, label %land.lhs.true.1141, label %if.end.1152

land.lhs.true.1141:                               ; preds = %land.lhs.true.1136
  %870 = load %struct.listop*, %struct.listop** %enter, align 8
  %op_flags1142 = getelementptr inbounds %struct.listop, %struct.listop* %870, i32 0, i32 6
  %871 = load i8, i8* %op_flags1142, align 1
  %conv1143 = zext i8 %871 to i32
  %cmp1144 = icmp eq i32 %conv1143, 7
  br i1 %cmp1144, label %if.then.1146, label %if.end.1152

if.then.1146:                                     ; preds = %land.lhs.true.1141
  %872 = load %struct.op*, %struct.op** %rv2av, align 8
  %op_flags1147 = getelementptr inbounds %struct.op, %struct.op* %872, i32 0, i32 6
  store i8 22, i8* %op_flags1147, align 1
  %873 = load %struct.listop*, %struct.listop** %enter, align 8
  %op_flags1148 = getelementptr inbounds %struct.listop, %struct.listop* %873, i32 0, i32 6
  %874 = load i8, i8* %op_flags1148, align 1
  %conv1149 = zext i8 %874 to i32
  %or1150 = or i32 %conv1149, 64
  %conv1151 = trunc i32 %or1150 to i8
  store i8 %conv1151, i8* %op_flags1148, align 1
  br label %if.end.1152

if.end.1152:                                      ; preds = %if.then.1146, %land.lhs.true.1141, %land.lhs.true.1136, %land.lhs.true.1132, %land.lhs.true.1127, %if.end.1124
  %875 = load %struct.op*, %struct.op** %ourmark, align 8
  %op_next1153 = getelementptr inbounds %struct.op, %struct.op* %875, i32 0, i32 0
  %876 = load %struct.op*, %struct.op** %op_next1153, align 8
  %877 = load %struct.op*, %struct.op** %theirmark, align 8
  %op_next1154 = getelementptr inbounds %struct.op, %struct.op* %877, i32 0, i32 0
  store %struct.op* %876, %struct.op** %op_next1154, align 8
  %878 = load %struct.op*, %struct.op** %ourmark, align 8
  %op_flags1155 = getelementptr inbounds %struct.op, %struct.op* %878, i32 0, i32 6
  %879 = load i8, i8* %op_flags1155, align 1
  %880 = load %struct.op*, %struct.op** %theirmark, align 8
  %op_flags1156 = getelementptr inbounds %struct.op, %struct.op* %880, i32 0, i32 6
  store i8 %879, i8* %op_flags1156, align 1
  %881 = load %struct.op*, %struct.op** %gvop, align 8
  %tobool1157 = icmp ne %struct.op* %881, null
  br i1 %tobool1157, label %cond.true.1158, label %cond.false.1159

cond.true.1158:                                   ; preds = %if.end.1152
  %882 = load %struct.op*, %struct.op** %gvop, align 8
  br label %cond.end.1160

cond.false.1159:                                  ; preds = %if.end.1152
  %883 = load %struct.listop*, %struct.listop** %enter, align 8
  %884 = bitcast %struct.listop* %883 to %struct.op*
  br label %cond.end.1160

cond.end.1160:                                    ; preds = %cond.false.1159, %cond.true.1158
  %cond1161 = phi %struct.op* [ %882, %cond.true.1158 ], [ %884, %cond.false.1159 ]
  %885 = load %struct.op*, %struct.op** %ourlast, align 8
  %op_next1162 = getelementptr inbounds %struct.op, %struct.op* %885, i32 0, i32 0
  store %struct.op* %cond1161, %struct.op** %op_next1162, align 8
  %886 = load %struct.op*, %struct.op** %ourmark, align 8
  call void @Perl_op_null(%struct.op* %886)
  %887 = load %struct.op*, %struct.op** %o.addr, align 8
  call void @Perl_op_null(%struct.op* %887)
  %888 = load %struct.listop*, %struct.listop** %enter, align 8
  %op_private1163 = getelementptr inbounds %struct.listop, %struct.listop* %888, i32 0, i32 7
  %889 = load i8, i8* %op_private1163, align 1
  %conv1164 = zext i8 %889 to i32
  %or1165 = or i32 %conv1164, 4
  %conv1166 = trunc i32 %or1165 to i8
  store i8 %conv1166, i8* %op_private1163, align 1
  %890 = load %struct.op*, %struct.op** %iter, align 8
  %op_private1167 = getelementptr inbounds %struct.op, %struct.op* %890, i32 0, i32 7
  %891 = load i8, i8* %op_private1167, align 1
  %conv1168 = zext i8 %891 to i32
  %or1169 = or i32 %conv1168, 4
  %conv1170 = trunc i32 %or1169 to i8
  store i8 %conv1170, i8* %op_private1167, align 1
  br label %sw.epilog

sw.default:                                       ; preds = %if.end.12
  %892 = load i16, i16* @PL_op_seqmax, align 2
  %inc1171 = add i16 %892, 1
  store i16 %inc1171, i16* @PL_op_seqmax, align 2
  %893 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_seq1172 = getelementptr inbounds %struct.op, %struct.op* %893, i32 0, i32 5
  store i16 %892, i16* %op_seq1172, align 2
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %cond.end.1160, %if.then.1123, %if.then.1115, %if.then.1106, %if.then.1101, %if.then.1092, %if.then.1087, %if.then.1074, %if.then.1061, %if.then.1052, %if.then.1044, %if.then.1035, %if.then.1025, %if.then.1016, %if.end.1006, %if.then.988, %if.then.976, %if.then.949, %if.then.944, %if.then.935, %if.then.926, %if.then.911, %if.then.902, %if.then.874, %if.then.865, %if.then.856, %if.then.827, %if.then.785, %for.end.776, %if.then.688, %if.then.671, %if.then.660, %if.then.651, %if.then.638, %if.end.610, %if.then.534, %if.then.525, %if.then.516, %if.then.504, %if.then.463, %if.end.454, %while.end.383, %while.end.367, %while.end, %if.end.319, %if.end.205, %if.end.93, %if.end.84, %if.then.59, %ignore_optimization, %if.end.19, %sw.bb
  %894 = load %struct.op*, %struct.op** %o.addr, align 8
  store %struct.op* %894, %struct.op** %oldop, align 8
  br label %for.inc.1173

for.inc.1173:                                     ; preds = %sw.epilog, %if.then.90, %if.then.81
  %895 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_next1174 = getelementptr inbounds %struct.op, %struct.op* %895, i32 0, i32 0
  %896 = load %struct.op*, %struct.op** %op_next1174, align 8
  store %struct.op* %896, %struct.op** %o.addr, align 8
  br label %for.cond

for.end.1175:                                     ; preds = %if.then.5, %for.cond
  call void @Perl_pop_scope()
  br label %return

return:                                           ; preds = %for.end.1175, %if.then
  ret void
}

declare void @Perl_save_op() #1

declare void @Perl_save_vptr(i8*) #1

declare %struct.gv* @Perl_gv_AVadd(%struct.gv*) #1

; Function Attrs: nounwind uwtable
define i8* @Perl_custom_op_name(%struct.op* %o) #0 {
entry:
  %retval = alloca i8*, align 8
  %o.addr = alloca %struct.op*, align 8
  %index = alloca i64, align 8
  %keysv = alloca %struct.sv*, align 8
  %he = alloca %struct.he*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_ppaddr = getelementptr inbounds %struct.op, %struct.op* %0, i32 0, i32 2
  %1 = load %struct.op* ()*, %struct.op* ()** %op_ppaddr, align 8
  %2 = ptrtoint %struct.op* ()* %1 to i64
  store i64 %2, i64* %index, align 8
  %3 = load %struct.hv*, %struct.hv** @PL_custom_op_names, align 8
  %tobool = icmp ne %struct.hv* %3, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %4 = load i8*, i8** getelementptr inbounds ([0 x i8*], [0 x i8*]* @PL_op_name, i32 0, i64 351), align 8
  store i8* %4, i8** %retval
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i64, i64* %index, align 8
  %call = call %struct.sv* @Perl_newSViv(i64 %5)
  %call1 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call)
  store %struct.sv* %call1, %struct.sv** %keysv, align 8
  %6 = load %struct.hv*, %struct.hv** @PL_custom_op_names, align 8
  %7 = load %struct.sv*, %struct.sv** %keysv, align 8
  %call2 = call %struct.he* @Perl_hv_fetch_ent(%struct.hv* %6, %struct.sv* %7, i32 0, i32 0)
  store %struct.he* %call2, %struct.he** %he, align 8
  %8 = load %struct.he*, %struct.he** %he, align 8
  %tobool3 = icmp ne %struct.he* %8, null
  br i1 %tobool3, label %if.end.5, label %if.then.4

if.then.4:                                        ; preds = %if.end
  %9 = load i8*, i8** getelementptr inbounds ([0 x i8*], [0 x i8*]* @PL_op_name, i32 0, i64 351), align 8
  store i8* %9, i8** %retval
  br label %return

if.end.5:                                         ; preds = %if.end
  %10 = load %struct.he*, %struct.he** %he, align 8
  %hent_val = getelementptr inbounds %struct.he, %struct.he* %10, i32 0, i32 2
  %11 = load %struct.sv*, %struct.sv** %hent_val, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %11, i32 0, i32 2
  %12 = load i32, i32* %sv_flags, align 4
  %and = and i32 %12, 262144
  %cmp = icmp eq i32 %and, 262144
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.5
  %13 = load %struct.he*, %struct.he** %he, align 8
  %hent_val6 = getelementptr inbounds %struct.he, %struct.he* %13, i32 0, i32 2
  %14 = load %struct.sv*, %struct.sv** %hent_val6, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %14, i32 0, i32 0
  %15 = load i8*, i8** %sv_any, align 8
  %16 = bitcast i8* %15 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %16, i32 0, i32 0
  %17 = load i8*, i8** %xpv_pv, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end.5
  %18 = load %struct.he*, %struct.he** %he, align 8
  %hent_val7 = getelementptr inbounds %struct.he, %struct.he* %18, i32 0, i32 2
  %19 = load %struct.sv*, %struct.sv** %hent_val7, align 8
  %call8 = call i8* @Perl_sv_2pv_nolen(%struct.sv* %19)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %17, %cond.true ], [ %call8, %cond.false ]
  store i8* %cond, i8** %retval
  br label %return

return:                                           ; preds = %cond.end, %if.then.4, %if.then
  %20 = load i8*, i8** %retval
  ret i8* %20
}

declare %struct.he* @Perl_hv_fetch_ent(%struct.hv*, %struct.sv*, i32, i32) #1

declare void @Perl_qerror(%struct.sv*) #1

declare %struct.sv* @Perl_mess(i8*, ...) #1

; Function Attrs: nounwind uwtable
define internal void @S_apply_attrs_my(%struct.hv* %stash, %struct.op* %target, %struct.op* %attrs, %struct.op** %imopsp) #0 {
entry:
  %stash.addr = alloca %struct.hv*, align 8
  %target.addr = alloca %struct.op*, align 8
  %attrs.addr = alloca %struct.op*, align 8
  %imopsp.addr = alloca %struct.op**, align 8
  %pack = alloca %struct.op*, align 8
  %imop = alloca %struct.op*, align 8
  %arg = alloca %struct.op*, align 8
  %meth = alloca %struct.sv*, align 8
  %stashsv = alloca %struct.sv*, align 8
  %s_PeRlHaSh_tmp = alloca i8*, align 8
  %s_PeRlHaSh = alloca i8*, align 8
  %i_PeRlHaSh = alloca i32, align 4
  %hash_PeRlHaSh = alloca i32, align 4
  %tmp = alloca i64, align 8
  store %struct.hv* %stash, %struct.hv** %stash.addr, align 8
  store %struct.op* %target, %struct.op** %target.addr, align 8
  store %struct.op* %attrs, %struct.op** %attrs.addr, align 8
  store %struct.op** %imopsp, %struct.op*** %imopsp.addr, align 8
  %0 = load %struct.op*, %struct.op** %attrs.addr, align 8
  %tobool = icmp ne %struct.op* %0, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.hv*, %struct.hv** %stash.addr, align 8
  %2 = load %struct.op*, %struct.op** %target.addr, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %2, i32 0, i32 3
  %3 = load i64, i64* %op_targ, align 8
  %4 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %4, i64 %3
  %5 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  %6 = load %struct.op*, %struct.op** %attrs.addr, align 8
  call void @S_apply_attrs(%struct.hv* %1, %struct.sv* %5, %struct.op* %6, i8 signext 1)
  %call = call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.23, i32 0, i32 0), i64 10)
  %call1 = call %struct.op* @Perl_newSVOP(i32 5, i32 0, %struct.sv* %call)
  store %struct.op* %call1, %struct.op** %pack, align 8
  %7 = load %struct.hv*, %struct.hv** %stash.addr, align 8
  %tobool2 = icmp ne %struct.hv* %7, null
  br i1 %tobool2, label %if.then.3, label %if.else

if.then.3:                                        ; preds = %if.end
  %8 = load %struct.hv*, %struct.hv** %stash.addr, align 8
  %sv_any = getelementptr inbounds %struct.hv, %struct.hv* %8, i32 0, i32 0
  %9 = load %struct.xpvhv*, %struct.xpvhv** %sv_any, align 8
  %xhv_name = getelementptr inbounds %struct.xpvhv, %struct.xpvhv* %9, i32 0, i32 10
  %10 = load i8*, i8** %xhv_name, align 8
  %call4 = call %struct.sv* @Perl_newSVpv(i8* %10, i64 0)
  store %struct.sv* %call4, %struct.sv** %stashsv, align 8
  br label %if.end.5

if.else:                                          ; preds = %if.end
  store %struct.sv* @PL_sv_no, %struct.sv** %stashsv, align 8
  br label %if.end.5

if.end.5:                                         ; preds = %if.else, %if.then.3
  %call6 = call %struct.op* @Perl_newOP(i32 9, i32 0)
  store %struct.op* %call6, %struct.op** %arg, align 8
  %11 = load %struct.op*, %struct.op** %target.addr, align 8
  %op_targ7 = getelementptr inbounds %struct.op, %struct.op* %11, i32 0, i32 3
  %12 = load i64, i64* %op_targ7, align 8
  %13 = load %struct.op*, %struct.op** %arg, align 8
  %op_targ8 = getelementptr inbounds %struct.op, %struct.op* %13, i32 0, i32 3
  store i64 %12, i64* %op_targ8, align 8
  %14 = load %struct.sv*, %struct.sv** %stashsv, align 8
  %call9 = call %struct.op* @Perl_newSVOP(i32 5, i32 0, %struct.sv* %14)
  %15 = load %struct.op*, %struct.op** %arg, align 8
  %call10 = call %struct.op* @Perl_mod(%struct.op* %15, i32 20)
  %call11 = call %struct.op* @Perl_newUNOP(i32 20, i32 0, %struct.op* %call10)
  %16 = load %struct.op*, %struct.op** %attrs.addr, align 8
  %call12 = call %struct.op* @S_dup_attrlist(%struct.op* %16)
  %call13 = call %struct.op* @Perl_prepend_elem(i32 141, %struct.op* %call11, %struct.op* %call12)
  %call14 = call %struct.op* @Perl_prepend_elem(i32 141, %struct.op* %call9, %struct.op* %call13)
  store %struct.op* %call14, %struct.op** %arg, align 8
  %call15 = call %struct.sv* @Perl_newSVpvn(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.49, i32 0, i32 0), i64 6)
  store %struct.sv* %call15, %struct.sv** %meth, align 8
  %17 = load %struct.sv*, %struct.sv** %meth, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %17, i32 0, i32 2
  %18 = load i32, i32* %sv_flags, align 4
  %and = and i32 %18, 255
  %cmp = icmp uge i32 %and, 5
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.end.5
  %19 = load %struct.sv*, %struct.sv** %meth, align 8
  %call16 = call signext i8 @Perl_sv_upgrade(%struct.sv* %19, i32 5)
  %conv = sext i8 %call16 to i32
  %tobool17 = icmp ne i32 %conv, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.end.5
  %20 = phi i1 [ true, %if.end.5 ], [ %tobool17, %lor.rhs ]
  %lor.ext = zext i1 %20 to i32
  %21 = load %struct.sv*, %struct.sv** %meth, align 8
  %sv_flags18 = getelementptr inbounds %struct.sv, %struct.sv* %21, i32 0, i32 2
  %22 = load i32, i32* %sv_flags18, align 4
  %and19 = and i32 %22, 2097152
  %tobool20 = icmp ne i32 %and19, 0
  br i1 %tobool20, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %lor.end
  %23 = load %struct.sv*, %struct.sv** %meth, align 8
  %call21 = call i32 @Perl_sv_backoff(%struct.sv* %23)
  %tobool22 = icmp ne i32 %call21, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %lor.end
  %24 = phi i1 [ false, %lor.end ], [ %tobool22, %land.rhs ]
  %land.ext = zext i1 %24 to i32
  %25 = load %struct.sv*, %struct.sv** %meth, align 8
  %sv_flags23 = getelementptr inbounds %struct.sv, %struct.sv* %25, i32 0, i32 2
  %26 = load i32, i32* %sv_flags23, align 4
  %or = or i32 %26, 16842752
  store i32 %or, i32* %sv_flags23, align 4
  %27 = load %struct.sv*, %struct.sv** %meth, align 8
  %sv_any24 = getelementptr inbounds %struct.sv, %struct.sv* %27, i32 0, i32 0
  %28 = load i8*, i8** %sv_any24, align 8
  %29 = bitcast i8* %28 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %29, i32 0, i32 0
  %30 = load i8*, i8** %xpv_pv, align 8
  store i8* %30, i8** %s_PeRlHaSh_tmp, align 8
  %31 = load i8*, i8** %s_PeRlHaSh_tmp, align 8
  store i8* %31, i8** %s_PeRlHaSh, align 8
  %32 = load %struct.sv*, %struct.sv** %meth, align 8
  %sv_any25 = getelementptr inbounds %struct.sv, %struct.sv* %32, i32 0, i32 0
  %33 = load i8*, i8** %sv_any25, align 8
  %34 = bitcast i8* %33 to %struct.xpv*
  %xpv_cur = getelementptr inbounds %struct.xpv, %struct.xpv* %34, i32 0, i32 1
  %35 = load i64, i64* %xpv_cur, align 8
  %conv26 = trunc i64 %35 to i32
  store i32 %conv26, i32* %i_PeRlHaSh, align 4
  store i32 0, i32* %hash_PeRlHaSh, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %land.end
  %36 = load i32, i32* %i_PeRlHaSh, align 4
  %dec = add nsw i32 %36, -1
  store i32 %dec, i32* %i_PeRlHaSh, align 4
  %tobool27 = icmp ne i32 %36, 0
  br i1 %tobool27, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %37 = load i8*, i8** %s_PeRlHaSh, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %37, i32 1
  store i8* %incdec.ptr, i8** %s_PeRlHaSh, align 8
  %38 = load i8, i8* %37, align 1
  %conv28 = zext i8 %38 to i32
  %39 = load i32, i32* %hash_PeRlHaSh, align 4
  %add = add i32 %39, %conv28
  store i32 %add, i32* %hash_PeRlHaSh, align 4
  %40 = load i32, i32* %hash_PeRlHaSh, align 4
  %shl = shl i32 %40, 10
  %41 = load i32, i32* %hash_PeRlHaSh, align 4
  %add29 = add i32 %41, %shl
  store i32 %add29, i32* %hash_PeRlHaSh, align 4
  %42 = load i32, i32* %hash_PeRlHaSh, align 4
  %shr = lshr i32 %42, 6
  %43 = load i32, i32* %hash_PeRlHaSh, align 4
  %xor = xor i32 %43, %shr
  store i32 %xor, i32* %hash_PeRlHaSh, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %44 = load i32, i32* %hash_PeRlHaSh, align 4
  %shl30 = shl i32 %44, 3
  %45 = load i32, i32* %hash_PeRlHaSh, align 4
  %add31 = add i32 %45, %shl30
  store i32 %add31, i32* %hash_PeRlHaSh, align 4
  %46 = load i32, i32* %hash_PeRlHaSh, align 4
  %shr32 = lshr i32 %46, 11
  %47 = load i32, i32* %hash_PeRlHaSh, align 4
  %xor33 = xor i32 %47, %shr32
  store i32 %xor33, i32* %hash_PeRlHaSh, align 4
  %48 = load i32, i32* %hash_PeRlHaSh, align 4
  %49 = load i32, i32* %hash_PeRlHaSh, align 4
  %shl34 = shl i32 %49, 15
  %add35 = add i32 %48, %shl34
  %conv36 = zext i32 %add35 to i64
  %50 = load %struct.sv*, %struct.sv** %meth, align 8
  %sv_any37 = getelementptr inbounds %struct.sv, %struct.sv* %50, i32 0, i32 0
  %51 = load i8*, i8** %sv_any37, align 8
  %52 = bitcast i8* %51 to %struct.xpvuv*
  %xuv_uv = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %52, i32 0, i32 3
  store i64 %conv36, i64* %xuv_uv, align 8
  store i64 %conv36, i64* %tmp
  %53 = load i64, i64* %tmp
  %54 = load %struct.op*, %struct.op** %pack, align 8
  %55 = load %struct.op*, %struct.op** %arg, align 8
  %call38 = call %struct.op* @Perl_list(%struct.op* %55)
  %call39 = call %struct.op* @Perl_prepend_elem(i32 141, %struct.op* %54, %struct.op* %call38)
  %56 = load %struct.sv*, %struct.sv** %meth, align 8
  %call40 = call %struct.op* @Perl_newSVOP(i32 350, i32 0, %struct.sv* %56)
  %call41 = call %struct.op* @Perl_append_elem(i32 141, %struct.op* %call39, %struct.op* %call40)
  %call42 = call %struct.op* @Perl_convert(i32 166, i32 193, %struct.op* %call41)
  store %struct.op* %call42, %struct.op** %imop, align 8
  %57 = load %struct.op*, %struct.op** %imop, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %57, i32 0, i32 7
  %58 = load i8, i8* %op_private, align 1
  %conv43 = zext i8 %58 to i32
  %or44 = or i32 %conv43, 64
  %conv45 = trunc i32 %or44 to i8
  store i8 %conv45, i8* %op_private, align 1
  %59 = load %struct.op**, %struct.op*** %imopsp.addr, align 8
  %60 = load %struct.op*, %struct.op** %59, align 8
  %61 = load %struct.op*, %struct.op** %imop, align 8
  %call46 = call %struct.op* @Perl_append_elem(i32 141, %struct.op* %60, %struct.op* %61)
  %62 = load %struct.op**, %struct.op*** %imopsp.addr, align 8
  store %struct.op* %call46, %struct.op** %62, align 8
  br label %return

return:                                           ; preds = %while.end, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal %struct.op* @S_dup_attrlist(%struct.op* %o) #0 {
entry:
  %o.addr = alloca %struct.op*, align 8
  %rop = alloca %struct.op*, align 8
  store %struct.op* %o, %struct.op** %o.addr, align 8
  store %struct.op* null, %struct.op** %rop, align 8
  %0 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %0, i32 0, i32 4
  %1 = load i16, i16* %op_type, align 2
  %conv = zext i16 %1 to i32
  %cmp = icmp eq i32 %conv, 5
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %2, i32 0, i32 6
  %3 = load i8, i8* %op_flags, align 1
  %conv2 = zext i8 %3 to i32
  %4 = load %struct.op*, %struct.op** %o.addr, align 8
  %5 = bitcast %struct.op* %4 to %struct.svop*
  %op_sv = getelementptr inbounds %struct.svop, %struct.svop* %5, i32 0, i32 8
  %6 = load %struct.sv*, %struct.sv** %op_sv, align 8
  store %struct.sv* %6, %struct.sv** @PL_Sv, align 8
  %7 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %tobool = icmp ne %struct.sv* %7, null
  br i1 %tobool, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then
  %8 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_refcnt = getelementptr inbounds %struct.sv, %struct.sv* %8, i32 0, i32 1
  %9 = load i32, i32* %sv_refcnt, align 4
  %inc = add i32 %9, 1
  store i32 %inc, i32* %sv_refcnt, align 4
  %tobool3 = icmp ne i32 %inc, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then
  %10 = phi i1 [ false, %if.then ], [ %tobool3, %land.rhs ]
  %land.ext = zext i1 %10 to i32
  %11 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call = call %struct.op* @Perl_newSVOP(i32 5, i32 %conv2, %struct.sv* %11)
  store %struct.op* %call, %struct.op** %rop, align 8
  br label %if.end.22

if.else:                                          ; preds = %entry
  %12 = load %struct.op*, %struct.op** %o.addr, align 8
  %13 = bitcast %struct.op* %12 to %struct.listop*
  %op_first = getelementptr inbounds %struct.listop, %struct.listop* %13, i32 0, i32 8
  %14 = load %struct.op*, %struct.op** %op_first, align 8
  store %struct.op* %14, %struct.op** %o.addr, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.else
  %15 = load %struct.op*, %struct.op** %o.addr, align 8
  %tobool4 = icmp ne %struct.op* %15, null
  br i1 %tobool4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %16 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_type5 = getelementptr inbounds %struct.op, %struct.op* %16, i32 0, i32 4
  %17 = load i16, i16* %op_type5, align 2
  %conv6 = zext i16 %17 to i32
  %cmp7 = icmp eq i32 %conv6, 5
  br i1 %cmp7, label %if.then.9, label %if.end

if.then.9:                                        ; preds = %for.body
  %18 = load %struct.op*, %struct.op** %rop, align 8
  %19 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_flags10 = getelementptr inbounds %struct.op, %struct.op* %19, i32 0, i32 6
  %20 = load i8, i8* %op_flags10, align 1
  %conv11 = zext i8 %20 to i32
  %21 = load %struct.op*, %struct.op** %o.addr, align 8
  %22 = bitcast %struct.op* %21 to %struct.svop*
  %op_sv12 = getelementptr inbounds %struct.svop, %struct.svop* %22, i32 0, i32 8
  %23 = load %struct.sv*, %struct.sv** %op_sv12, align 8
  store %struct.sv* %23, %struct.sv** @PL_Sv, align 8
  %24 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %tobool13 = icmp ne %struct.sv* %24, null
  br i1 %tobool13, label %land.rhs.14, label %land.end.18

land.rhs.14:                                      ; preds = %if.then.9
  %25 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_refcnt15 = getelementptr inbounds %struct.sv, %struct.sv* %25, i32 0, i32 1
  %26 = load i32, i32* %sv_refcnt15, align 4
  %inc16 = add i32 %26, 1
  store i32 %inc16, i32* %sv_refcnt15, align 4
  %tobool17 = icmp ne i32 %inc16, 0
  br label %land.end.18

land.end.18:                                      ; preds = %land.rhs.14, %if.then.9
  %27 = phi i1 [ false, %if.then.9 ], [ %tobool17, %land.rhs.14 ]
  %land.ext19 = zext i1 %27 to i32
  %28 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call20 = call %struct.op* @Perl_newSVOP(i32 5, i32 %conv11, %struct.sv* %28)
  %call21 = call %struct.op* @Perl_append_elem(i32 141, %struct.op* %18, %struct.op* %call20)
  store %struct.op* %call21, %struct.op** %rop, align 8
  br label %if.end

if.end:                                           ; preds = %land.end.18, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %29 = load %struct.op*, %struct.op** %o.addr, align 8
  %op_sibling = getelementptr inbounds %struct.op, %struct.op* %29, i32 0, i32 1
  %30 = load %struct.op*, %struct.op** %op_sibling, align 8
  store %struct.op* %30, %struct.op** %o.addr, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end.22

if.end.22:                                        ; preds = %for.end, %land.end
  %31 = load %struct.op*, %struct.op** %rop, align 8
  ret %struct.op* %31
}

declare void @Perl_save_int(i32*) #1

attributes #0 = { nounwind uwtable "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind }

!llvm.ident = !{!0}

!0 = !{!"clang version 3.7.0 (tags/RELEASE_370/final)"}
