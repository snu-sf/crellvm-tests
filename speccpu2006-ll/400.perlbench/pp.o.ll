; ModuleID = 'pp.c'
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.sv = type { i8*, i32, i32 }
%struct.op = type { %struct.op*, %struct.op*, {}*, i64, i16, i16, i8, i8 }
%struct.cop = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8, i8*, %struct.hv*, %struct.gv*, i32, i32, i32, %struct.sv*, %struct.sv* }
%struct.hv = type { %struct.xpvhv*, i32, i32 }
%struct.xpvhv = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, i32, %struct.he*, %struct.pmop*, i8* }
%struct.magic = type { %struct.magic*, %struct.mgvtbl*, i16, i8, i8, %struct.sv*, i8*, i32 }
%struct.mgvtbl = type { i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*)*, i32 (%struct.sv*, %struct.magic*, %struct.sv*, i8*, i32)*, i32 (%struct.magic*, %struct.clone_params*)* }
%struct.clone_params = type { %struct.av*, i64, %struct.interpreter* }
%struct.av = type { %struct.xpvav*, i32, i32 }
%struct.xpvav = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct.sv**, %struct.sv*, i8 }
%struct.interpreter = type { i8 }
%struct.he = type { %struct.he*, %struct.hek*, %struct.sv* }
%struct.hek = type { i32, i32, [1 x i8] }
%struct.pmop = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8, %struct.op*, %struct.op*, %struct.op*, %struct.op*, %struct.pmop*, %struct.regexp*, i32, i32, i8, %struct.hv* }
%struct.regexp = type { i32*, i32*, %struct.regnode*, %struct.reg_substr_data*, i8*, %struct.reg_data*, i8*, i32*, i32, i32, i32, i32, i32, i32, i32, i32, [1 x %struct.regnode] }
%struct.regnode = type { i8, i8, i16 }
%struct.reg_substr_data = type opaque
%struct.reg_data = type opaque
%struct.gv = type { %struct.xpvgv*, i32, i32 }
%struct.xpvgv = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct.gp*, i8*, i64, %struct.hv*, i8 }
%struct.gp = type { %struct.sv*, i32, %struct.io*, %struct.cv*, %struct.av*, %struct.hv*, %struct.gv*, %struct.cv*, i32, i32, i32, i8* }
%struct.io = type { %struct.xpvio*, i32, i32 }
%struct.xpvio = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct._PerlIO**, %struct._PerlIO**, %union.anon, i64, i64, i64, i64, i8*, %struct.gv*, i8*, %struct.gv*, i8*, %struct.gv*, i16, i8, i8 }
%struct._PerlIO = type opaque
%union.anon = type { %struct.__dirstream* }
%struct.__dirstream = type opaque
%struct.cv = type { %struct.xpvcv*, i32, i32 }
%struct.xpvcv = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, %struct.hv*, %struct.op*, %struct.op*, void (%struct.cv*)*, %union.any, %struct.gv*, i8*, i64, %struct.av*, %struct.cv*, i16, i32 }
%union.any = type { i8* }
%struct.xpv = type { i8*, i64, i64 }
%struct.stackinfo = type { %struct.av*, %struct.context*, i32, i32, i32, %struct.stackinfo*, %struct.stackinfo*, i32 }
%struct.context = type { i32, %union.anon.0 }
%union.anon.0 = type { %struct.block }
%struct.block = type { i32, %struct.cop*, i32, i32, i32, %struct.pmop*, i8, %union.anon.1 }
%union.anon.1 = type { %struct.block_loop }
%struct.block_loop = type { i8*, i32, %struct.op*, %struct.op*, %struct.op*, %struct.sv**, %struct.sv*, %struct.sv*, %struct.av*, i64, i64 }
%struct.xrv = type { %struct.sv* }
%struct.unop = type { %struct.op*, %struct.op*, %struct.op* ()*, i64, i16, i16, i8, i8, %struct.op* }
%struct.xpvlv = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv*, i64, i64, %struct.sv*, i8 }
%struct.xpvmg = type { i8*, i64, i64, i64, double, %struct.magic*, %struct.hv* }
%struct.xpviv = type { i8*, i64, i64, i64 }
%struct.xpvuv = type { i8*, i64, i64, i64 }
%struct.xpvnv = type { i8*, i64, i64, i64, double }

@PL_stack_sp = external global %struct.sv**, align 8
@PL_op = external global %struct.op*, align 8
@PL_stack_max = external global %struct.sv**, align 8
@PL_sv_undef = external global %struct.sv, align 8
@PL_curpad = external global %struct.sv**, align 8
@.str = private unnamed_addr constant [44 x i8] c"Can't return array to lvalue scalar context\00", align 1
@.str.1 = private unnamed_addr constant [43 x i8] c"Can't return hash to lvalue scalar context\00", align 1
@.str.2 = private unnamed_addr constant [17 x i8] c"NOT IMPL LINE %d\00", align 1
@PL_amagic_generation = external global i64, align 8
@.str.3 = private unnamed_addr constant [50 x i8] c"Overloaded dereference did not return a reference\00", align 1
@.str.4 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@PL_Sv = external global %struct.sv*, align 8
@.str.5 = private unnamed_addr constant [21 x i8] c"Not a GLOB reference\00", align 1
@PL_no_modify = external constant [0 x i8], align 1
@PL_curcop = external global %struct.cop*, align 8
@PL_no_usym = external constant [0 x i8], align 1
@.str.6 = private unnamed_addr constant [9 x i8] c"a symbol\00", align 1
@PL_dowarn = external global i8, align 1
@PL_no_symref = external constant [0 x i8], align 1
@.str.7 = private unnamed_addr constant [23 x i8] c"Not a SCALAR reference\00", align 1
@.str.8 = private unnamed_addr constant [9 x i8] c"a SCALAR\00", align 1
@PL_no_localize_ref = external constant [0 x i8], align 1
@.str.9 = private unnamed_addr constant [40 x i8] c"Can't modify non-lvalue subroutine call\00", align 1
@.str.10 = private unnamed_addr constant [7 x i8] c"CORE::\00", align 1
@PL_op_name = external global [0 x i8*], align 8
@PL_op_desc = external global [0 x i8*], align 8
@PL_opargs = external global [0 x i32], align 4
@.str.11 = private unnamed_addr constant [9 x i8] c"?$@@%&*$\00", align 1
@.str.12 = private unnamed_addr constant [32 x i8] c"Can't find an opnumber for \22%s\22\00", align 1
@PL_stack_base = external global %struct.sv**, align 8
@PL_markstack_ptr = external global i32*, align 8
@PL_tmps_ix = external global i32, align 4
@PL_tmps_max = external global i32, align 4
@PL_sv_no = external global %struct.sv, align 8
@.str.13 = private unnamed_addr constant [34 x i8] c"Attempt to bless into a reference\00", align 1
@.str.14 = private unnamed_addr constant [48 x i8] c"Explicit blessing to '' (assuming package main)\00", align 1
@.str.15 = private unnamed_addr constant [5 x i8] c"RRAY\00", align 1
@.str.16 = private unnamed_addr constant [4 x i8] c"ODE\00", align 1
@.str.17 = private unnamed_addr constant [10 x i8] c"ILEHANDLE\00", align 1
@.str.18 = private unnamed_addr constant [18 x i8] c"*glob{FILEHANDLE}\00", align 1
@.str.19 = private unnamed_addr constant [6 x i8] c"ORMAT\00", align 1
@.str.20 = private unnamed_addr constant [4 x i8] c"LOB\00", align 1
@.str.21 = private unnamed_addr constant [4 x i8] c"ASH\00", align 1
@.str.22 = private unnamed_addr constant [4 x i8] c"AME\00", align 1
@.str.23 = private unnamed_addr constant [7 x i8] c"ACKAGE\00", align 1
@.str.24 = private unnamed_addr constant [9 x i8] c"__ANON__\00", align 1
@.str.25 = private unnamed_addr constant [6 x i8] c"CALAR\00", align 1
@PL_lastscream = external global %struct.sv*, align 8
@PL_sv_yes = external global %struct.sv, align 8
@PL_maxscream = external global i32, align 4
@PL_screamfirst = external global i32*, align 8
@PL_screamnext = external global i32*, align 8
@.str.26 = private unnamed_addr constant [24 x i8] c"do_study: out of memory\00", align 1
@PL_defgv = external global %struct.gv*, align 8
@.str.27 = private unnamed_addr constant [33 x i8] c"Constant subroutine %s undefined\00", align 1
@.str.28 = private unnamed_addr constant [12 x i8] c"(anonymous)\00", align 1
@.str.29 = private unnamed_addr constant [25 x i8] c"Illegal division by zero\00", align 1
@.str.30 = private unnamed_addr constant [21 x i8] c"Illegal modulus zero\00", align 1
@Perl_pp_repeat.oom_list_extend = internal constant [33 x i8] c"Out of memory during list extend\00", align 16
@Perl_pp_repeat.oom_string_extend = internal constant [35 x i8] c"Out of memory during string extend\00", align 16
@.str.31 = private unnamed_addr constant [2 x i8] c"-\00", align 1
@PL_Xpv = external global %struct.xpv*, align 8
@PL_utf8skip = external constant [0 x i8], align 1
@PL_ppaddr = external global [0 x %struct.op* ()*], align 8
@PL_srand_called = external global i8, align 1
@.str.32 = private unnamed_addr constant [21 x i8] c"Can't take log of %g\00", align 1
@.str.33 = private unnamed_addr constant [22 x i8] c"Can't take sqrt of %g\00", align 1
@PL_tainting = external global i8, align 1
@.str.34 = private unnamed_addr constant [25 x i8] c"substr outside of string\00", align 1
@.str.35 = private unnamed_addr constant [45 x i8] c"Attempt to use reference as lvalue in substr\00", align 1
@PL_encoding = external global %struct.sv*, align 8
@PL_tainted = external global i8, align 1
@.str.36 = private unnamed_addr constant [5 x i8] c"\EF\BF\BD\00\00", align 1
@.str.37 = private unnamed_addr constant [65 x i8] c"The crypt() function is unimplemented due to excessive paranoia.\00", align 1
@PL_no_aelem = external constant [0 x i8], align 1
@.str.38 = private unnamed_addr constant [21 x i8] c"Not a HASH reference\00", align 1
@.str.39 = private unnamed_addr constant [7 x i8] c"EXISTS\00", align 1
@.str.40 = private unnamed_addr constant [7 x i8] c"DELETE\00", align 1
@.str.41 = private unnamed_addr constant [35 x i8] c"Can't localize pseudo-hash element\00", align 1
@PL_no_helem = external constant [0 x i8], align 1
@.str.42 = private unnamed_addr constant [41 x i8] c"Odd number of elements in anonymous hash\00", align 1
@PL_markstack_max = external global i32*, align 8
@.str.43 = private unnamed_addr constant [7 x i8] c"SPLICE\00", align 1
@.str.44 = private unnamed_addr constant [34 x i8] c"splice() offset past end of array\00", align 1
@.str.45 = private unnamed_addr constant [5 x i8] c"PUSH\00", align 1
@.str.46 = private unnamed_addr constant [8 x i8] c"UNSHIFT\00", align 1
@PL_savestack_ix = external global i32, align 4
@.str.47 = private unnamed_addr constant [16 x i8] c"panic: pp_split\00", align 1
@PL_reg_match_utf8 = external global i8, align 1
@PL_savestack_max = external global i32, align 4
@PL_curstack = external global %struct.av*, align 8
@PL_savestack = external global %union.any*, align 8
@PL_curstackinfo = external global %struct.stackinfo*, align 8
@PL_multiline = external global i32, align 4
@PL_regint_string = external global %struct.sv* (%struct.regexp*)*, align 8
@PL_regexecp = external global i32 (%struct.regexp*, i8*, i8*, i8*, i32, %struct.sv*, i8*, i32)*, align 8
@.str.48 = private unnamed_addr constant [11 x i8] c"Split loop\00", align 1
@PL_lockhook = external global void (%struct.sv*)*, align 8
@.str.49 = private unnamed_addr constant [53 x i8] c"tried to access per-thread data in non-threaded perl\00", align 1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_stub() #0 {
entry:
  %sp = alloca %struct.sv**, align 8
  %tmp = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 6
  %2 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end.18

cond.false:                                       ; preds = %entry
  %3 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags2 = getelementptr inbounds %struct.op, %struct.op* %3, i32 0, i32 6
  %4 = load i8, i8* %op_flags2, align 1
  %conv3 = zext i8 %4 to i32
  %and4 = and i32 %conv3, 3
  %cmp5 = icmp eq i32 %and4, 2
  br i1 %cmp5, label %cond.true.7, label %cond.false.8

cond.true.7:                                      ; preds = %cond.false
  br label %cond.end.16

cond.false.8:                                     ; preds = %cond.false
  %5 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags9 = getelementptr inbounds %struct.op, %struct.op* %5, i32 0, i32 6
  %6 = load i8, i8* %op_flags9, align 1
  %conv10 = zext i8 %6 to i32
  %and11 = and i32 %conv10, 3
  %cmp12 = icmp eq i32 %and11, 3
  br i1 %cmp12, label %cond.true.14, label %cond.false.15

cond.true.14:                                     ; preds = %cond.false.8
  br label %cond.end

cond.false.15:                                    ; preds = %cond.false.8
  %call = call i32 @Perl_block_gimme()
  br label %cond.end

cond.end:                                         ; preds = %cond.false.15, %cond.true.14
  %cond = phi i32 [ 1, %cond.true.14 ], [ %call, %cond.false.15 ]
  br label %cond.end.16

cond.end.16:                                      ; preds = %cond.end, %cond.true.7
  %cond17 = phi i32 [ 0, %cond.true.7 ], [ %cond, %cond.end ]
  br label %cond.end.18

cond.end.18:                                      ; preds = %cond.end.16, %cond.true
  %cond19 = phi i32 [ 128, %cond.true ], [ %cond17, %cond.end.16 ]
  %cmp20 = icmp eq i32 %cond19, 0
  br i1 %cmp20, label %if.then, label %if.end.26

if.then:                                          ; preds = %cond.end.18
  %7 = load %struct.sv**, %struct.sv*** @PL_stack_max, align 8
  %8 = load %struct.sv**, %struct.sv*** %sp, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %7 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %8 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %cmp22 = icmp slt i64 %sub.ptr.div, 1
  br i1 %cmp22, label %if.then.24, label %if.end

if.then.24:                                       ; preds = %if.then
  %9 = load %struct.sv**, %struct.sv*** %sp, align 8
  %10 = load %struct.sv**, %struct.sv*** %sp, align 8
  %call25 = call %struct.sv** @Perl_stack_grow(%struct.sv** %9, %struct.sv** %10, i32 1)
  store %struct.sv** %call25, %struct.sv*** %sp, align 8
  br label %if.end

if.end:                                           ; preds = %if.then.24, %if.then
  %11 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %11, i32 1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  store %struct.sv* @PL_sv_undef, %struct.sv** %incdec.ptr, align 8
  store %struct.sv* @PL_sv_undef, %struct.sv** %tmp
  %12 = load %struct.sv*, %struct.sv** %tmp
  br label %if.end.26

if.end.26:                                        ; preds = %if.end, %cond.end.18
  %13 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %13, %struct.sv*** @PL_stack_sp, align 8
  %14 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %14, i32 0, i32 0
  %15 = load %struct.op*, %struct.op** %op_next, align 8
  ret %struct.op* %15
}

declare i32 @Perl_block_gimme() #1

declare %struct.sv** @Perl_stack_grow(%struct.sv**, %struct.sv**, i32) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_scalar() #0 {
entry:
  %0 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %0, i32 0, i32 0
  %1 = load %struct.op*, %struct.op** %op_next, align 8
  ret %struct.op* %1
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_padav() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %gimme = alloca i32, align 4
  %maxarg = alloca i32, align 4
  %i = alloca i32, align 4
  %svp = alloca %struct.sv**, align 8
  %sv = alloca %struct.sv*, align 8
  %maxarg110 = alloca i32, align 4
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 3
  %2 = load i64, i64* %op_targ, align 8
  %3 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 %2
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %4, %struct.sv** %targ, align 8
  %5 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %5, i32 0, i32 7
  %6 = load i8, i8* %op_private, align 1
  %conv = zext i8 %6 to i32
  %and = and i32 %conv, 128
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %7 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ1 = getelementptr inbounds %struct.op, %struct.op* %7, i32 0, i32 3
  %8 = load i64, i64* %op_targ1, align 8
  %9 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx2 = getelementptr inbounds %struct.sv*, %struct.sv** %9, i64 %8
  call void @Perl_save_clearsv(%struct.sv** %arrayidx2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %10 = load %struct.sv**, %struct.sv*** @PL_stack_max, align 8
  %11 = load %struct.sv**, %struct.sv*** %sp, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %10 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %11 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %cmp = icmp slt i64 %sub.ptr.div, 1
  br i1 %cmp, label %if.then.4, label %if.end.5

if.then.4:                                        ; preds = %if.end
  %12 = load %struct.sv**, %struct.sv*** %sp, align 8
  %13 = load %struct.sv**, %struct.sv*** %sp, align 8
  %call = call %struct.sv** @Perl_stack_grow(%struct.sv** %12, %struct.sv** %13, i32 1)
  store %struct.sv** %call, %struct.sv*** %sp, align 8
  br label %if.end.5

if.end.5:                                         ; preds = %if.then.4, %if.end
  %14 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %14, i32 0, i32 6
  %15 = load i8, i8* %op_flags, align 1
  %conv6 = zext i8 %15 to i32
  %and7 = and i32 %conv6, 16
  %tobool8 = icmp ne i32 %and7, 0
  br i1 %tobool8, label %if.then.9, label %if.else

if.then.9:                                        ; preds = %if.end.5
  %16 = load %struct.sv*, %struct.sv** %targ, align 8
  %17 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %17, i32 1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  store %struct.sv* %16, %struct.sv** %incdec.ptr, align 8
  %18 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %18, %struct.sv*** @PL_stack_sp, align 8
  %19 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %19, i32 0, i32 0
  %20 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %20, %struct.op** %retval
  br label %return

if.else:                                          ; preds = %if.end.5
  %21 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_private10 = getelementptr inbounds %struct.op, %struct.op* %21, i32 0, i32 7
  %22 = load i8, i8* %op_private10, align 1
  %conv11 = zext i8 %22 to i32
  %and12 = and i32 %conv11, 8
  %tobool13 = icmp ne i32 %and12, 0
  br i1 %tobool13, label %land.lhs.true, label %if.end.34

land.lhs.true:                                    ; preds = %if.else
  %call14 = call i32 @Perl_is_lvalue_sub()
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %if.then.16, label %if.end.34

if.then.16:                                       ; preds = %land.lhs.true
  %23 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags17 = getelementptr inbounds %struct.op, %struct.op* %23, i32 0, i32 6
  %24 = load i8, i8* %op_flags17, align 1
  %conv18 = zext i8 %24 to i32
  %and19 = and i32 %conv18, 3
  %tobool20 = icmp ne i32 %and19, 0
  br i1 %tobool20, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.16
  %25 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags21 = getelementptr inbounds %struct.op, %struct.op* %25, i32 0, i32 6
  %26 = load i8, i8* %op_flags21, align 1
  %conv22 = zext i8 %26 to i32
  %and23 = and i32 %conv22, 3
  %cmp24 = icmp eq i32 %and23, 3
  %cond = select i1 %cmp24, i32 1, i32 0
  br label %cond.end

cond.false:                                       ; preds = %if.then.16
  %call26 = call i32 @Perl_dowantarray()
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond27 = phi i32 [ %cond, %cond.true ], [ %call26, %cond.false ]
  %cmp28 = icmp eq i32 %cond27, 0
  br i1 %cmp28, label %if.then.30, label %if.end.31

if.then.30:                                       ; preds = %cond.end
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([44 x i8], [44 x i8]* @.str, i32 0, i32 0))
  br label %if.end.31

if.end.31:                                        ; preds = %if.then.30, %cond.end
  %27 = load %struct.sv*, %struct.sv** %targ, align 8
  %28 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr32 = getelementptr inbounds %struct.sv*, %struct.sv** %28, i32 1
  store %struct.sv** %incdec.ptr32, %struct.sv*** %sp, align 8
  store %struct.sv* %27, %struct.sv** %incdec.ptr32, align 8
  %29 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %29, %struct.sv*** @PL_stack_sp, align 8
  %30 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next33 = getelementptr inbounds %struct.op, %struct.op* %30, i32 0, i32 0
  %31 = load %struct.op*, %struct.op** %op_next33, align 8
  store %struct.op* %31, %struct.op** %retval
  br label %return

if.end.34:                                        ; preds = %land.lhs.true, %if.else
  br label %if.end.35

if.end.35:                                        ; preds = %if.end.34
  %32 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags36 = getelementptr inbounds %struct.op, %struct.op* %32, i32 0, i32 6
  %33 = load i8, i8* %op_flags36, align 1
  %conv37 = zext i8 %33 to i32
  %and38 = and i32 %conv37, 3
  %cmp39 = icmp eq i32 %and38, 1
  br i1 %cmp39, label %cond.true.41, label %cond.false.42

cond.true.41:                                     ; preds = %if.end.35
  br label %cond.end.62

cond.false.42:                                    ; preds = %if.end.35
  %34 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags43 = getelementptr inbounds %struct.op, %struct.op* %34, i32 0, i32 6
  %35 = load i8, i8* %op_flags43, align 1
  %conv44 = zext i8 %35 to i32
  %and45 = and i32 %conv44, 3
  %cmp46 = icmp eq i32 %and45, 2
  br i1 %cmp46, label %cond.true.48, label %cond.false.49

cond.true.48:                                     ; preds = %cond.false.42
  br label %cond.end.60

cond.false.49:                                    ; preds = %cond.false.42
  %36 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags50 = getelementptr inbounds %struct.op, %struct.op* %36, i32 0, i32 6
  %37 = load i8, i8* %op_flags50, align 1
  %conv51 = zext i8 %37 to i32
  %and52 = and i32 %conv51, 3
  %cmp53 = icmp eq i32 %and52, 3
  br i1 %cmp53, label %cond.true.55, label %cond.false.56

cond.true.55:                                     ; preds = %cond.false.49
  br label %cond.end.58

cond.false.56:                                    ; preds = %cond.false.49
  %call57 = call i32 @Perl_block_gimme()
  br label %cond.end.58

cond.end.58:                                      ; preds = %cond.false.56, %cond.true.55
  %cond59 = phi i32 [ 1, %cond.true.55 ], [ %call57, %cond.false.56 ]
  br label %cond.end.60

cond.end.60:                                      ; preds = %cond.end.58, %cond.true.48
  %cond61 = phi i32 [ 0, %cond.true.48 ], [ %cond59, %cond.end.58 ]
  br label %cond.end.62

cond.end.62:                                      ; preds = %cond.end.60, %cond.true.41
  %cond63 = phi i32 [ 128, %cond.true.41 ], [ %cond61, %cond.end.60 ]
  store i32 %cond63, i32* %gimme, align 4
  %38 = load i32, i32* %gimme, align 4
  %cmp64 = icmp eq i32 %38, 1
  br i1 %cmp64, label %if.then.66, label %if.else.105

if.then.66:                                       ; preds = %cond.end.62
  %39 = load %struct.sv*, %struct.sv** %targ, align 8
  %40 = bitcast %struct.sv* %39 to %struct.av*
  %41 = bitcast %struct.av* %40 to %struct.sv*
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %41, i32 0, i32 2
  %42 = load i32, i32* %sv_flags, align 4
  %and67 = and i32 %42, 32768
  %tobool68 = icmp ne i32 %and67, 0
  br i1 %tobool68, label %cond.true.69, label %cond.false.72

cond.true.69:                                     ; preds = %if.then.66
  %43 = load %struct.sv*, %struct.sv** %targ, align 8
  %44 = bitcast %struct.sv* %43 to %struct.av*
  %45 = bitcast %struct.av* %44 to %struct.sv*
  %call70 = call i32 @Perl_mg_size(%struct.sv* %45)
  %conv71 = sext i32 %call70 to i64
  br label %cond.end.73

cond.false.72:                                    ; preds = %if.then.66
  %46 = load %struct.sv*, %struct.sv** %targ, align 8
  %47 = bitcast %struct.sv* %46 to %struct.av*
  %sv_any = getelementptr inbounds %struct.av, %struct.av* %47, i32 0, i32 0
  %48 = load %struct.xpvav*, %struct.xpvav** %sv_any, align 8
  %xav_fill = getelementptr inbounds %struct.xpvav, %struct.xpvav* %48, i32 0, i32 1
  %49 = load i64, i64* %xav_fill, align 8
  br label %cond.end.73

cond.end.73:                                      ; preds = %cond.false.72, %cond.true.69
  %cond74 = phi i64 [ %conv71, %cond.true.69 ], [ %49, %cond.false.72 ]
  %add = add nsw i64 %cond74, 1
  %conv75 = trunc i64 %add to i32
  store i32 %conv75, i32* %maxarg, align 4
  %50 = load %struct.sv**, %struct.sv*** @PL_stack_max, align 8
  %51 = load %struct.sv**, %struct.sv*** %sp, align 8
  %sub.ptr.lhs.cast76 = ptrtoint %struct.sv** %50 to i64
  %sub.ptr.rhs.cast77 = ptrtoint %struct.sv** %51 to i64
  %sub.ptr.sub78 = sub i64 %sub.ptr.lhs.cast76, %sub.ptr.rhs.cast77
  %sub.ptr.div79 = sdiv exact i64 %sub.ptr.sub78, 8
  %52 = load i32, i32* %maxarg, align 4
  %conv80 = sext i32 %52 to i64
  %cmp81 = icmp slt i64 %sub.ptr.div79, %conv80
  br i1 %cmp81, label %if.then.83, label %if.end.85

if.then.83:                                       ; preds = %cond.end.73
  %53 = load %struct.sv**, %struct.sv*** %sp, align 8
  %54 = load %struct.sv**, %struct.sv*** %sp, align 8
  %55 = load i32, i32* %maxarg, align 4
  %call84 = call %struct.sv** @Perl_stack_grow(%struct.sv** %53, %struct.sv** %54, i32 %55)
  store %struct.sv** %call84, %struct.sv*** %sp, align 8
  br label %if.end.85

if.end.85:                                        ; preds = %if.then.83, %cond.end.73
  %56 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags86 = getelementptr inbounds %struct.sv, %struct.sv* %56, i32 0, i32 2
  %57 = load i32, i32* %sv_flags86, align 4
  %and87 = and i32 %57, 57344
  %tobool88 = icmp ne i32 %and87, 0
  br i1 %tobool88, label %if.then.89, label %if.else.100

if.then.89:                                       ; preds = %if.end.85
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then.89
  %58 = load i32, i32* %i, align 4
  %59 = load i32, i32* %maxarg, align 4
  %cmp90 = icmp ult i32 %58, %59
  br i1 %cmp90, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %60 = load %struct.sv*, %struct.sv** %targ, align 8
  %61 = bitcast %struct.sv* %60 to %struct.av*
  %62 = load i32, i32* %i, align 4
  %call92 = call %struct.sv** @Perl_av_fetch(%struct.av* %61, i32 %62, i32 0)
  store %struct.sv** %call92, %struct.sv*** %svp, align 8
  %63 = load %struct.sv**, %struct.sv*** %svp, align 8
  %tobool93 = icmp ne %struct.sv** %63, null
  br i1 %tobool93, label %cond.true.94, label %cond.false.95

cond.true.94:                                     ; preds = %for.body
  %64 = load %struct.sv**, %struct.sv*** %svp, align 8
  %65 = load %struct.sv*, %struct.sv** %64, align 8
  br label %cond.end.96

cond.false.95:                                    ; preds = %for.body
  br label %cond.end.96

cond.end.96:                                      ; preds = %cond.false.95, %cond.true.94
  %cond97 = phi %struct.sv* [ %65, %cond.true.94 ], [ @PL_sv_undef, %cond.false.95 ]
  %66 = load i32, i32* %i, align 4
  %add98 = add i32 %66, 1
  %idxprom = zext i32 %add98 to i64
  %67 = load %struct.sv**, %struct.sv*** %sp, align 8
  %arrayidx99 = getelementptr inbounds %struct.sv*, %struct.sv** %67, i64 %idxprom
  store %struct.sv* %cond97, %struct.sv** %arrayidx99, align 8
  br label %for.inc

for.inc:                                          ; preds = %cond.end.96
  %68 = load i32, i32* %i, align 4
  %inc = add i32 %68, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end.103

if.else.100:                                      ; preds = %if.end.85
  %69 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %69, i64 1
  %70 = bitcast %struct.sv** %add.ptr to i8*
  %71 = load %struct.sv*, %struct.sv** %targ, align 8
  %72 = bitcast %struct.sv* %71 to %struct.av*
  %sv_any101 = getelementptr inbounds %struct.av, %struct.av* %72, i32 0, i32 0
  %73 = load %struct.xpvav*, %struct.xpvav** %sv_any101, align 8
  %xav_array = getelementptr inbounds %struct.xpvav, %struct.xpvav* %73, i32 0, i32 0
  %74 = load i8*, i8** %xav_array, align 8
  %75 = bitcast i8* %74 to %struct.sv**
  %76 = bitcast %struct.sv** %75 to i8*
  %77 = load i32, i32* %maxarg, align 4
  %conv102 = sext i32 %77 to i64
  %mul = mul i64 %conv102, 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %70, i8* %76, i64 %mul, i32 1, i1 false)
  br label %if.end.103

if.end.103:                                       ; preds = %if.else.100, %for.end
  %78 = load i32, i32* %maxarg, align 4
  %79 = load %struct.sv**, %struct.sv*** %sp, align 8
  %idx.ext = sext i32 %78 to i64
  %add.ptr104 = getelementptr inbounds %struct.sv*, %struct.sv** %79, i64 %idx.ext
  store %struct.sv** %add.ptr104, %struct.sv*** %sp, align 8
  br label %if.end.127

if.else.105:                                      ; preds = %cond.end.62
  %80 = load i32, i32* %gimme, align 4
  %cmp106 = icmp eq i32 %80, 0
  br i1 %cmp106, label %if.then.108, label %if.end.126

if.then.108:                                      ; preds = %if.else.105
  %call109 = call %struct.sv* @Perl_sv_newmortal()
  store %struct.sv* %call109, %struct.sv** %sv, align 8
  %81 = load %struct.sv*, %struct.sv** %targ, align 8
  %82 = bitcast %struct.sv* %81 to %struct.av*
  %83 = bitcast %struct.av* %82 to %struct.sv*
  %sv_flags111 = getelementptr inbounds %struct.sv, %struct.sv* %83, i32 0, i32 2
  %84 = load i32, i32* %sv_flags111, align 4
  %and112 = and i32 %84, 32768
  %tobool113 = icmp ne i32 %and112, 0
  br i1 %tobool113, label %cond.true.114, label %cond.false.117

cond.true.114:                                    ; preds = %if.then.108
  %85 = load %struct.sv*, %struct.sv** %targ, align 8
  %86 = bitcast %struct.sv* %85 to %struct.av*
  %87 = bitcast %struct.av* %86 to %struct.sv*
  %call115 = call i32 @Perl_mg_size(%struct.sv* %87)
  %conv116 = sext i32 %call115 to i64
  br label %cond.end.120

cond.false.117:                                   ; preds = %if.then.108
  %88 = load %struct.sv*, %struct.sv** %targ, align 8
  %89 = bitcast %struct.sv* %88 to %struct.av*
  %sv_any118 = getelementptr inbounds %struct.av, %struct.av* %89, i32 0, i32 0
  %90 = load %struct.xpvav*, %struct.xpvav** %sv_any118, align 8
  %xav_fill119 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %90, i32 0, i32 1
  %91 = load i64, i64* %xav_fill119, align 8
  br label %cond.end.120

cond.end.120:                                     ; preds = %cond.false.117, %cond.true.114
  %cond121 = phi i64 [ %conv116, %cond.true.114 ], [ %91, %cond.false.117 ]
  %add122 = add nsw i64 %cond121, 1
  %conv123 = trunc i64 %add122 to i32
  store i32 %conv123, i32* %maxarg110, align 4
  %92 = load %struct.sv*, %struct.sv** %sv, align 8
  %93 = load i32, i32* %maxarg110, align 4
  %conv124 = sext i32 %93 to i64
  call void @Perl_sv_setiv(%struct.sv* %92, i64 %conv124)
  %94 = load %struct.sv*, %struct.sv** %sv, align 8
  %95 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr125 = getelementptr inbounds %struct.sv*, %struct.sv** %95, i32 1
  store %struct.sv** %incdec.ptr125, %struct.sv*** %sp, align 8
  store %struct.sv* %94, %struct.sv** %incdec.ptr125, align 8
  br label %if.end.126

if.end.126:                                       ; preds = %cond.end.120, %if.else.105
  br label %if.end.127

if.end.127:                                       ; preds = %if.end.126, %if.end.103
  %96 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %96, %struct.sv*** @PL_stack_sp, align 8
  %97 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next128 = getelementptr inbounds %struct.op, %struct.op* %97, i32 0, i32 0
  %98 = load %struct.op*, %struct.op** %op_next128, align 8
  store %struct.op* %98, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.127, %if.end.31, %if.then.9
  %99 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %99
}

declare void @Perl_save_clearsv(%struct.sv**) #1

declare i32 @Perl_is_lvalue_sub() #1

declare i32 @Perl_dowantarray() #1

declare void @Perl_croak(i8*, ...) #1

declare i32 @Perl_mg_size(%struct.sv*) #1

declare %struct.sv** @Perl_av_fetch(%struct.av*, i32, i32) #1

; Function Attrs: nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture, i8* nocapture readonly, i64, i32, i1) #2

declare %struct.sv* @Perl_sv_newmortal() #1

declare void @Perl_sv_setiv(%struct.sv*, i64) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_padhv() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %gimme = alloca i32, align 4
  %tmp = alloca %struct.sv*, align 8
  %sv = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 3
  %2 = load i64, i64* %op_targ, align 8
  %3 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 %2
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %4, %struct.sv** %targ, align 8
  %5 = load %struct.sv**, %struct.sv*** @PL_stack_max, align 8
  %6 = load %struct.sv**, %struct.sv*** %sp, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %5 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %6 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %cmp = icmp slt i64 %sub.ptr.div, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %7 = load %struct.sv**, %struct.sv*** %sp, align 8
  %8 = load %struct.sv**, %struct.sv*** %sp, align 8
  %call = call %struct.sv** @Perl_stack_grow(%struct.sv** %7, %struct.sv** %8, i32 1)
  store %struct.sv** %call, %struct.sv*** %sp, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %9 = load %struct.sv*, %struct.sv** %targ, align 8
  %10 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %10, i32 1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  store %struct.sv* %9, %struct.sv** %incdec.ptr, align 8
  store %struct.sv* %9, %struct.sv** %tmp
  %11 = load %struct.sv*, %struct.sv** %tmp
  %12 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %12, i32 0, i32 7
  %13 = load i8, i8* %op_private, align 1
  %conv = zext i8 %13 to i32
  %and = and i32 %conv, 128
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then.1, label %if.end.4

if.then.1:                                        ; preds = %if.end
  %14 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ2 = getelementptr inbounds %struct.op, %struct.op* %14, i32 0, i32 3
  %15 = load i64, i64* %op_targ2, align 8
  %16 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx3 = getelementptr inbounds %struct.sv*, %struct.sv** %16, i64 %15
  call void @Perl_save_clearsv(%struct.sv** %arrayidx3)
  br label %if.end.4

if.end.4:                                         ; preds = %if.then.1, %if.end
  %17 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %17, i32 0, i32 6
  %18 = load i8, i8* %op_flags, align 1
  %conv5 = zext i8 %18 to i32
  %and6 = and i32 %conv5, 16
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %if.then.8, label %if.else

if.then.8:                                        ; preds = %if.end.4
  %19 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %19, %struct.sv*** @PL_stack_sp, align 8
  %20 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %20, i32 0, i32 0
  %21 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %21, %struct.op** %retval
  br label %return

if.else:                                          ; preds = %if.end.4
  %22 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_private9 = getelementptr inbounds %struct.op, %struct.op* %22, i32 0, i32 7
  %23 = load i8, i8* %op_private9, align 1
  %conv10 = zext i8 %23 to i32
  %and11 = and i32 %conv10, 8
  %tobool12 = icmp ne i32 %and11, 0
  br i1 %tobool12, label %land.lhs.true, label %if.end.32

land.lhs.true:                                    ; preds = %if.else
  %call13 = call i32 @Perl_is_lvalue_sub()
  %tobool14 = icmp ne i32 %call13, 0
  br i1 %tobool14, label %if.then.15, label %if.end.32

if.then.15:                                       ; preds = %land.lhs.true
  %24 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags16 = getelementptr inbounds %struct.op, %struct.op* %24, i32 0, i32 6
  %25 = load i8, i8* %op_flags16, align 1
  %conv17 = zext i8 %25 to i32
  %and18 = and i32 %conv17, 3
  %tobool19 = icmp ne i32 %and18, 0
  br i1 %tobool19, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.15
  %26 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags20 = getelementptr inbounds %struct.op, %struct.op* %26, i32 0, i32 6
  %27 = load i8, i8* %op_flags20, align 1
  %conv21 = zext i8 %27 to i32
  %and22 = and i32 %conv21, 3
  %cmp23 = icmp eq i32 %and22, 3
  %cond = select i1 %cmp23, i32 1, i32 0
  br label %cond.end

cond.false:                                       ; preds = %if.then.15
  %call25 = call i32 @Perl_dowantarray()
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond26 = phi i32 [ %cond, %cond.true ], [ %call25, %cond.false ]
  %cmp27 = icmp eq i32 %cond26, 0
  br i1 %cmp27, label %if.then.29, label %if.end.30

if.then.29:                                       ; preds = %cond.end
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.1, i32 0, i32 0))
  br label %if.end.30

if.end.30:                                        ; preds = %if.then.29, %cond.end
  %28 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %28, %struct.sv*** @PL_stack_sp, align 8
  %29 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next31 = getelementptr inbounds %struct.op, %struct.op* %29, i32 0, i32 0
  %30 = load %struct.op*, %struct.op** %op_next31, align 8
  store %struct.op* %30, %struct.op** %retval
  br label %return

if.end.32:                                        ; preds = %land.lhs.true, %if.else
  br label %if.end.33

if.end.33:                                        ; preds = %if.end.32
  %31 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags34 = getelementptr inbounds %struct.op, %struct.op* %31, i32 0, i32 6
  %32 = load i8, i8* %op_flags34, align 1
  %conv35 = zext i8 %32 to i32
  %and36 = and i32 %conv35, 3
  %cmp37 = icmp eq i32 %and36, 1
  br i1 %cmp37, label %cond.true.39, label %cond.false.40

cond.true.39:                                     ; preds = %if.end.33
  br label %cond.end.60

cond.false.40:                                    ; preds = %if.end.33
  %33 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags41 = getelementptr inbounds %struct.op, %struct.op* %33, i32 0, i32 6
  %34 = load i8, i8* %op_flags41, align 1
  %conv42 = zext i8 %34 to i32
  %and43 = and i32 %conv42, 3
  %cmp44 = icmp eq i32 %and43, 2
  br i1 %cmp44, label %cond.true.46, label %cond.false.47

cond.true.46:                                     ; preds = %cond.false.40
  br label %cond.end.58

cond.false.47:                                    ; preds = %cond.false.40
  %35 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags48 = getelementptr inbounds %struct.op, %struct.op* %35, i32 0, i32 6
  %36 = load i8, i8* %op_flags48, align 1
  %conv49 = zext i8 %36 to i32
  %and50 = and i32 %conv49, 3
  %cmp51 = icmp eq i32 %and50, 3
  br i1 %cmp51, label %cond.true.53, label %cond.false.54

cond.true.53:                                     ; preds = %cond.false.47
  br label %cond.end.56

cond.false.54:                                    ; preds = %cond.false.47
  %call55 = call i32 @Perl_block_gimme()
  br label %cond.end.56

cond.end.56:                                      ; preds = %cond.false.54, %cond.true.53
  %cond57 = phi i32 [ 1, %cond.true.53 ], [ %call55, %cond.false.54 ]
  br label %cond.end.58

cond.end.58:                                      ; preds = %cond.end.56, %cond.true.46
  %cond59 = phi i32 [ 0, %cond.true.46 ], [ %cond57, %cond.end.56 ]
  br label %cond.end.60

cond.end.60:                                      ; preds = %cond.end.58, %cond.true.39
  %cond61 = phi i32 [ 128, %cond.true.39 ], [ %cond59, %cond.end.58 ]
  store i32 %cond61, i32* %gimme, align 4
  %37 = load i32, i32* %gimme, align 4
  %cmp62 = icmp eq i32 %37, 1
  br i1 %cmp62, label %if.then.64, label %if.else.66

if.then.64:                                       ; preds = %cond.end.60
  %38 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %38, %struct.sv*** @PL_stack_sp, align 8
  %call65 = call %struct.op* @Perl_do_kv()
  store %struct.op* %call65, %struct.op** %retval
  br label %return

if.else.66:                                       ; preds = %cond.end.60
  %39 = load i32, i32* %gimme, align 4
  %cmp67 = icmp eq i32 %39, 0
  br i1 %cmp67, label %if.then.69, label %if.end.72

if.then.69:                                       ; preds = %if.else.66
  %40 = load %struct.sv*, %struct.sv** %targ, align 8
  %41 = bitcast %struct.sv* %40 to %struct.hv*
  %call71 = call %struct.sv* @Perl_hv_scalar(%struct.hv* %41)
  store %struct.sv* %call71, %struct.sv** %sv, align 8
  %42 = load %struct.sv*, %struct.sv** %sv, align 8
  %43 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %42, %struct.sv** %43, align 8
  br label %if.end.72

if.end.72:                                        ; preds = %if.then.69, %if.else.66
  br label %if.end.73

if.end.73:                                        ; preds = %if.end.72
  %44 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %44, %struct.sv*** @PL_stack_sp, align 8
  %45 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next74 = getelementptr inbounds %struct.op, %struct.op* %45, i32 0, i32 0
  %46 = load %struct.op*, %struct.op** %op_next74, align 8
  store %struct.op* %46, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.73, %if.then.64, %if.end.30, %if.then.8
  %47 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %47
}

declare %struct.op* @Perl_do_kv() #1

declare %struct.sv* @Perl_hv_scalar(%struct.hv*) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_padany() #0 {
entry:
  %call = call %struct.op* (i8*, ...) @Perl_die(i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.2, i32 0, i32 0), i32 128)
  ret %struct.op* %call
}

declare %struct.op* @Perl_die(i8*, ...) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_rv2gv() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %sv = alloca %struct.sv*, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %arg = alloca %struct.sv*, align 8
  %gv = alloca %struct.gv*, align 8
  %sym = alloca i8*, align 8
  %len = alloca i64, align 8
  %name = alloca i8*, align 8
  %gv67 = alloca %struct.gv*, align 8
  %len70 = alloca i64, align 8
  %namesv = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.sv**, %struct.sv*** %sp, align 8
  %2 = load %struct.sv*, %struct.sv** %1, align 8
  store %struct.sv* %2, %struct.sv** %sv, align 8
  %3 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %3, i32 0, i32 2
  %4 = load i32, i32* %sv_flags, align 4
  %and = and i32 %4, 524288
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.else.37

if.then:                                          ; preds = %entry
  br label %wasref

wasref:                                           ; preds = %if.end.130, %if.then.50, %if.then
  %5 = load i64, i64* @PL_amagic_generation, align 8
  %tobool1 = icmp ne i64 %5, 0
  br i1 %tobool1, label %if.then.2, label %if.end.19

if.then.2:                                        ; preds = %wasref
  %6 = load %struct.sv**, %struct.sv*** %sp, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %6, i64 0
  %7 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %7, %struct.sv** %arg, align 8
  br label %am_again

am_again:                                         ; preds = %if.then.16, %if.then.2
  %8 = load %struct.sv*, %struct.sv** %arg, align 8
  %sv_flags3 = getelementptr inbounds %struct.sv, %struct.sv* %8, i32 0, i32 2
  %9 = load i32, i32* %sv_flags3, align 4
  %and4 = and i32 %9, 268435456
  %tobool5 = icmp ne i32 %and4, 0
  br i1 %tobool5, label %land.lhs.true, label %if.end.18

land.lhs.true:                                    ; preds = %am_again
  %10 = load %struct.sv*, %struct.sv** %arg, align 8
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %10, %struct.sv* @PL_sv_undef, i32 61, i32 9)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool6 = icmp ne %struct.sv* %call, null
  br i1 %tobool6, label %if.then.7, label %if.end.18

if.then.7:                                        ; preds = %land.lhs.true
  %11 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %11, %struct.sv*** %sp, align 8
  %12 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  store %struct.sv* %12, %struct.sv** %sv, align 8
  %13 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %sv_flags8 = getelementptr inbounds %struct.sv, %struct.sv* %13, i32 0, i32 2
  %14 = load i32, i32* %sv_flags8, align 4
  %and9 = and i32 %14, 524288
  %tobool10 = icmp ne i32 %and9, 0
  br i1 %tobool10, label %if.end, label %if.then.11

if.then.11:                                       ; preds = %if.then.7
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([50 x i8], [50 x i8]* @.str.3, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then.11, %if.then.7
  %15 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %16 = load %struct.sv*, %struct.sv** %arg, align 8
  %cmp = icmp ne %struct.sv* %15, %16
  br i1 %cmp, label %land.lhs.true.12, label %if.end.17

land.lhs.true.12:                                 ; preds = %if.end
  %17 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %17, i32 0, i32 0
  %18 = load i8*, i8** %sv_any, align 8
  %19 = bitcast i8* %18 to %struct.xrv*
  %xrv_rv = getelementptr inbounds %struct.xrv, %struct.xrv* %19, i32 0, i32 0
  %20 = load %struct.sv*, %struct.sv** %xrv_rv, align 8
  %21 = load %struct.sv*, %struct.sv** %arg, align 8
  %sv_any13 = getelementptr inbounds %struct.sv, %struct.sv* %21, i32 0, i32 0
  %22 = load i8*, i8** %sv_any13, align 8
  %23 = bitcast i8* %22 to %struct.xrv*
  %xrv_rv14 = getelementptr inbounds %struct.xrv, %struct.xrv* %23, i32 0, i32 0
  %24 = load %struct.sv*, %struct.sv** %xrv_rv14, align 8
  %cmp15 = icmp ne %struct.sv* %20, %24
  br i1 %cmp15, label %if.then.16, label %if.end.17

if.then.16:                                       ; preds = %land.lhs.true.12
  %25 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  store %struct.sv* %25, %struct.sv** %arg, align 8
  br label %am_again

if.end.17:                                        ; preds = %land.lhs.true.12, %if.end
  br label %if.end.18

if.end.18:                                        ; preds = %if.end.17, %land.lhs.true, %am_again
  br label %if.end.19

if.end.19:                                        ; preds = %if.end.18, %wasref
  %26 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any20 = getelementptr inbounds %struct.sv, %struct.sv* %26, i32 0, i32 0
  %27 = load i8*, i8** %sv_any20, align 8
  %28 = bitcast i8* %27 to %struct.xrv*
  %xrv_rv21 = getelementptr inbounds %struct.xrv, %struct.xrv* %28, i32 0, i32 0
  %29 = load %struct.sv*, %struct.sv** %xrv_rv21, align 8
  store %struct.sv* %29, %struct.sv** %sv, align 8
  %30 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags22 = getelementptr inbounds %struct.sv, %struct.sv* %30, i32 0, i32 2
  %31 = load i32, i32* %sv_flags22, align 4
  %and23 = and i32 %31, 255
  %cmp24 = icmp eq i32 %and23, 15
  br i1 %cmp24, label %if.then.25, label %if.else

if.then.25:                                       ; preds = %if.end.19
  %call26 = call %struct.sv* @Perl_sv_newmortal()
  %32 = bitcast %struct.sv* %call26 to %struct.gv*
  store %struct.gv* %32, %struct.gv** %gv, align 8
  %33 = load %struct.gv*, %struct.gv** %gv, align 8
  call void @Perl_gv_init(%struct.gv* %33, %struct.hv* null, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.4, i32 0, i32 0), i64 0, i32 0)
  %34 = load %struct.sv*, %struct.sv** %sv, align 8
  %35 = bitcast %struct.sv* %34 to %struct.io*
  %36 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any27 = getelementptr inbounds %struct.gv, %struct.gv* %36, i32 0, i32 0
  %37 = load %struct.xpvgv*, %struct.xpvgv** %sv_any27, align 8
  %xgv_gp = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %37, i32 0, i32 7
  %38 = load %struct.gp*, %struct.gp** %xgv_gp, align 8
  %gp_io = getelementptr inbounds %struct.gp, %struct.gp* %38, i32 0, i32 2
  store %struct.io* %35, %struct.io** %gp_io, align 8
  %39 = load %struct.sv*, %struct.sv** %sv, align 8
  store %struct.sv* %39, %struct.sv** @PL_Sv, align 8
  %40 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %tobool28 = icmp ne %struct.sv* %40, null
  br i1 %tobool28, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then.25
  %41 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_refcnt = getelementptr inbounds %struct.sv, %struct.sv* %41, i32 0, i32 1
  %42 = load i32, i32* %sv_refcnt, align 4
  %inc = add i32 %42, 1
  store i32 %inc, i32* %sv_refcnt, align 4
  %tobool29 = icmp ne i32 %inc, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then.25
  %43 = phi i1 [ false, %if.then.25 ], [ %tobool29, %land.rhs ]
  %land.ext = zext i1 %43 to i32
  %44 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %45 = load %struct.gv*, %struct.gv** %gv, align 8
  %46 = bitcast %struct.gv* %45 to %struct.sv*
  store %struct.sv* %46, %struct.sv** %sv, align 8
  br label %if.end.36

if.else:                                          ; preds = %if.end.19
  %47 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags30 = getelementptr inbounds %struct.sv, %struct.sv* %47, i32 0, i32 2
  %48 = load i32, i32* %sv_flags30, align 4
  %and31 = and i32 %48, 255
  %cmp32 = icmp ne i32 %and31, 13
  br i1 %cmp32, label %if.then.33, label %if.end.35

if.then.33:                                       ; preds = %if.else
  %call34 = call %struct.op* (i8*, ...) @Perl_die(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.5, i32 0, i32 0))
  store %struct.op* %call34, %struct.op** %retval
  br label %return

if.end.35:                                        ; preds = %if.else
  br label %if.end.36

if.end.36:                                        ; preds = %if.end.35, %land.end
  br label %if.end.216

if.else.37:                                       ; preds = %entry
  %49 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags38 = getelementptr inbounds %struct.sv, %struct.sv* %49, i32 0, i32 2
  %50 = load i32, i32* %sv_flags38, align 4
  %and39 = and i32 %50, 255
  %cmp40 = icmp ne i32 %and39, 13
  br i1 %cmp40, label %if.then.41, label %if.end.215

if.then.41:                                       ; preds = %if.else.37
  %51 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags42 = getelementptr inbounds %struct.sv, %struct.sv* %51, i32 0, i32 2
  %52 = load i32, i32* %sv_flags42, align 4
  %and43 = and i32 %52, 8192
  %tobool44 = icmp ne i32 %and43, 0
  br i1 %tobool44, label %if.then.45, label %if.end.52

if.then.45:                                       ; preds = %if.then.41
  %53 = load %struct.sv*, %struct.sv** %sv, align 8
  %call46 = call i32 @Perl_mg_get(%struct.sv* %53)
  %54 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags47 = getelementptr inbounds %struct.sv, %struct.sv* %54, i32 0, i32 2
  %55 = load i32, i32* %sv_flags47, align 4
  %and48 = and i32 %55, 524288
  %tobool49 = icmp ne i32 %and48, 0
  br i1 %tobool49, label %if.then.50, label %if.end.51

if.then.50:                                       ; preds = %if.then.45
  br label %wasref

if.end.51:                                        ; preds = %if.then.45
  br label %if.end.52

if.end.52:                                        ; preds = %if.end.51, %if.then.41
  %56 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags53 = getelementptr inbounds %struct.sv, %struct.sv* %56, i32 0, i32 2
  %57 = load i32, i32* %sv_flags53, align 4
  %and54 = and i32 %57, 118423552
  %tobool55 = icmp ne i32 %and54, 0
  br i1 %tobool55, label %if.end.170, label %land.lhs.true.56

land.lhs.true.56:                                 ; preds = %if.end.52
  %58 = load %struct.sv*, %struct.sv** %sv, align 8
  %cmp57 = icmp ne %struct.sv* %58, @PL_sv_undef
  br i1 %cmp57, label %if.then.58, label %if.end.170

if.then.58:                                       ; preds = %land.lhs.true.56
  %59 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags59 = getelementptr inbounds %struct.sv, %struct.sv* %59, i32 0, i32 2
  %60 = load i32, i32* %sv_flags59, align 4
  %and60 = and i32 %60, 8388608
  %tobool61 = icmp ne i32 %and60, 0
  br i1 %tobool61, label %if.then.62, label %if.end.63

if.then.62:                                       ; preds = %if.then.58
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([0 x i8], [0 x i8]* @PL_no_modify, i32 0, i32 0))
  br label %if.end.63

if.end.63:                                        ; preds = %if.then.62, %if.then.58
  %61 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %61, i32 0, i32 7
  %62 = load i8, i8* %op_private, align 1
  %conv = zext i8 %62 to i32
  %and64 = and i32 %conv, 96
  %tobool65 = icmp ne i32 %and64, 0
  br i1 %tobool65, label %if.then.66, label %if.end.131

if.then.66:                                       ; preds = %if.end.63
  %63 = load %struct.op*, %struct.op** @PL_op, align 8
  %64 = bitcast %struct.op* %63 to %struct.unop*
  %op_targ = getelementptr inbounds %struct.unop, %struct.unop* %64, i32 0, i32 3
  %65 = load i64, i64* %op_targ, align 8
  %tobool68 = icmp ne i64 %65, 0
  br i1 %tobool68, label %if.then.69, label %if.else.81

if.then.69:                                       ; preds = %if.then.66
  %66 = load %struct.op*, %struct.op** @PL_op, align 8
  %67 = bitcast %struct.op* %66 to %struct.unop*
  %op_targ71 = getelementptr inbounds %struct.unop, %struct.unop* %67, i32 0, i32 3
  %68 = load i64, i64* %op_targ71, align 8
  %69 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx72 = getelementptr inbounds %struct.sv*, %struct.sv** %69, i64 %68
  %70 = load %struct.sv*, %struct.sv** %arrayidx72, align 8
  store %struct.sv* %70, %struct.sv** %namesv, align 8
  %71 = load %struct.sv*, %struct.sv** %namesv, align 8
  %sv_flags73 = getelementptr inbounds %struct.sv, %struct.sv* %71, i32 0, i32 2
  %72 = load i32, i32* %sv_flags73, align 4
  %and74 = and i32 %72, 262144
  %cmp75 = icmp eq i32 %and74, 262144
  br i1 %cmp75, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.69
  %73 = load %struct.sv*, %struct.sv** %namesv, align 8
  %sv_any77 = getelementptr inbounds %struct.sv, %struct.sv* %73, i32 0, i32 0
  %74 = load i8*, i8** %sv_any77, align 8
  %75 = bitcast i8* %74 to %struct.xpv*
  %xpv_cur = getelementptr inbounds %struct.xpv, %struct.xpv* %75, i32 0, i32 1
  %76 = load i64, i64* %xpv_cur, align 8
  store i64 %76, i64* %len70, align 8
  %77 = load %struct.sv*, %struct.sv** %namesv, align 8
  %sv_any78 = getelementptr inbounds %struct.sv, %struct.sv* %77, i32 0, i32 0
  %78 = load i8*, i8** %sv_any78, align 8
  %79 = bitcast i8* %78 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %79, i32 0, i32 0
  %80 = load i8*, i8** %xpv_pv, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then.69
  %81 = load %struct.sv*, %struct.sv** %namesv, align 8
  %call79 = call i8* @Perl_sv_2pv_flags(%struct.sv* %81, i64* %len70, i32 2)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %80, %cond.true ], [ %call79, %cond.false ]
  store i8* %cond, i8** %name, align 8
  %call80 = call %struct.sv* @Perl_newSV(i64 0)
  %82 = bitcast %struct.sv* %call80 to %struct.gv*
  store %struct.gv* %82, %struct.gv** %gv67, align 8
  %83 = load %struct.gv*, %struct.gv** %gv67, align 8
  %84 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_stash = getelementptr inbounds %struct.cop, %struct.cop* %84, i32 0, i32 9
  %85 = load %struct.hv*, %struct.hv** %cop_stash, align 8
  %86 = load i8*, i8** %name, align 8
  %87 = load i64, i64* %len70, align 8
  call void @Perl_gv_init(%struct.gv* %83, %struct.hv* %85, i8* %86, i64 %87, i32 0)
  br label %if.end.91

if.else.81:                                       ; preds = %if.then.66
  %88 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_stash82 = getelementptr inbounds %struct.cop, %struct.cop* %88, i32 0, i32 9
  %89 = load %struct.hv*, %struct.hv** %cop_stash82, align 8
  %tobool83 = icmp ne %struct.hv* %89, null
  br i1 %tobool83, label %cond.true.84, label %cond.false.87

cond.true.84:                                     ; preds = %if.else.81
  %90 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_stash85 = getelementptr inbounds %struct.cop, %struct.cop* %90, i32 0, i32 9
  %91 = load %struct.hv*, %struct.hv** %cop_stash85, align 8
  %sv_any86 = getelementptr inbounds %struct.hv, %struct.hv* %91, i32 0, i32 0
  %92 = load %struct.xpvhv*, %struct.xpvhv** %sv_any86, align 8
  %xhv_name = getelementptr inbounds %struct.xpvhv, %struct.xpvhv* %92, i32 0, i32 10
  %93 = load i8*, i8** %xhv_name, align 8
  br label %cond.end.88

cond.false.87:                                    ; preds = %if.else.81
  br label %cond.end.88

cond.end.88:                                      ; preds = %cond.false.87, %cond.true.84
  %cond89 = phi i8* [ %93, %cond.true.84 ], [ null, %cond.false.87 ]
  store i8* %cond89, i8** %name, align 8
  %94 = load i8*, i8** %name, align 8
  %call90 = call %struct.gv* @Perl_newGVgen(i8* %94)
  store %struct.gv* %call90, %struct.gv** %gv67, align 8
  br label %if.end.91

if.end.91:                                        ; preds = %cond.end.88, %cond.end
  %95 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags92 = getelementptr inbounds %struct.sv, %struct.sv* %95, i32 0, i32 2
  %96 = load i32, i32* %sv_flags92, align 4
  %and93 = and i32 %96, 255
  %cmp94 = icmp ult i32 %and93, 3
  br i1 %cmp94, label %if.then.96, label %if.end.98

if.then.96:                                       ; preds = %if.end.91
  %97 = load %struct.sv*, %struct.sv** %sv, align 8
  %call97 = call signext i8 @Perl_sv_upgrade(%struct.sv* %97, i32 3)
  br label %if.end.98

if.end.98:                                        ; preds = %if.then.96, %if.end.91
  %98 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any99 = getelementptr inbounds %struct.sv, %struct.sv* %98, i32 0, i32 0
  %99 = load i8*, i8** %sv_any99, align 8
  %100 = bitcast i8* %99 to %struct.xpv*
  %xpv_pv100 = getelementptr inbounds %struct.xpv, %struct.xpv* %100, i32 0, i32 0
  %101 = load i8*, i8** %xpv_pv100, align 8
  %tobool101 = icmp ne i8* %101, null
  br i1 %tobool101, label %if.then.102, label %if.end.121

if.then.102:                                      ; preds = %if.end.98
  %102 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags103 = getelementptr inbounds %struct.sv, %struct.sv* %102, i32 0, i32 2
  %103 = load i32, i32* %sv_flags103, align 4
  %and104 = and i32 %103, 2097152
  %tobool105 = icmp ne i32 %and104, 0
  br i1 %tobool105, label %land.rhs.106, label %land.end.109

land.rhs.106:                                     ; preds = %if.then.102
  %104 = load %struct.sv*, %struct.sv** %sv, align 8
  %call107 = call i32 @Perl_sv_backoff(%struct.sv* %104)
  %tobool108 = icmp ne i32 %call107, 0
  br label %land.end.109

land.end.109:                                     ; preds = %land.rhs.106, %if.then.102
  %105 = phi i1 [ false, %if.then.102 ], [ %tobool108, %land.rhs.106 ]
  %land.ext110 = zext i1 %105 to i32
  %106 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any111 = getelementptr inbounds %struct.sv, %struct.sv* %106, i32 0, i32 0
  %107 = load i8*, i8** %sv_any111, align 8
  %108 = bitcast i8* %107 to %struct.xpv*
  %xpv_len = getelementptr inbounds %struct.xpv, %struct.xpv* %108, i32 0, i32 2
  %109 = load i64, i64* %xpv_len, align 8
  %tobool112 = icmp ne i64 %109, 0
  br i1 %tobool112, label %if.then.113, label %if.end.116

if.then.113:                                      ; preds = %land.end.109
  %110 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any114 = getelementptr inbounds %struct.sv, %struct.sv* %110, i32 0, i32 0
  %111 = load i8*, i8** %sv_any114, align 8
  %112 = bitcast i8* %111 to %struct.xpv*
  %xpv_pv115 = getelementptr inbounds %struct.xpv, %struct.xpv* %112, i32 0, i32 0
  %113 = load i8*, i8** %xpv_pv115, align 8
  call void @Perl_safesysfree(i8* %113)
  br label %if.end.116

if.end.116:                                       ; preds = %if.then.113, %land.end.109
  %114 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any117 = getelementptr inbounds %struct.sv, %struct.sv* %114, i32 0, i32 0
  %115 = load i8*, i8** %sv_any117, align 8
  %116 = bitcast i8* %115 to %struct.xpv*
  %xpv_cur118 = getelementptr inbounds %struct.xpv, %struct.xpv* %116, i32 0, i32 1
  store i64 0, i64* %xpv_cur118, align 8
  %117 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any119 = getelementptr inbounds %struct.sv, %struct.sv* %117, i32 0, i32 0
  %118 = load i8*, i8** %sv_any119, align 8
  %119 = bitcast i8* %118 to %struct.xpv*
  %xpv_len120 = getelementptr inbounds %struct.xpv, %struct.xpv* %119, i32 0, i32 2
  store i64 0, i64* %xpv_len120, align 8
  br label %if.end.121

if.end.121:                                       ; preds = %if.end.116, %if.end.98
  %120 = load %struct.gv*, %struct.gv** %gv67, align 8
  %121 = bitcast %struct.gv* %120 to %struct.sv*
  %122 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any122 = getelementptr inbounds %struct.sv, %struct.sv* %122, i32 0, i32 0
  %123 = load i8*, i8** %sv_any122, align 8
  %124 = bitcast i8* %123 to %struct.xrv*
  %xrv_rv123 = getelementptr inbounds %struct.xrv, %struct.xrv* %124, i32 0, i32 0
  store %struct.sv* %121, %struct.sv** %xrv_rv123, align 8
  %125 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags124 = getelementptr inbounds %struct.sv, %struct.sv* %125, i32 0, i32 2
  %126 = load i32, i32* %sv_flags124, align 4
  %or = or i32 %126, 524288
  store i32 %or, i32* %sv_flags124, align 4
  %127 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags125 = getelementptr inbounds %struct.sv, %struct.sv* %127, i32 0, i32 2
  %128 = load i32, i32* %sv_flags125, align 4
  %and126 = and i32 %128, 16384
  %tobool127 = icmp ne i32 %and126, 0
  br i1 %tobool127, label %if.then.128, label %if.end.130

if.then.128:                                      ; preds = %if.end.121
  %129 = load %struct.sv*, %struct.sv** %sv, align 8
  %call129 = call i32 @Perl_mg_set(%struct.sv* %129)
  br label %if.end.130

if.end.130:                                       ; preds = %if.then.128, %if.end.121
  br label %wasref

if.end.131:                                       ; preds = %if.end.63
  %130 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %130, i32 0, i32 6
  %131 = load i8, i8* %op_flags, align 1
  %conv132 = zext i8 %131 to i32
  %and133 = and i32 %conv132, 16
  %tobool134 = icmp ne i32 %and133, 0
  br i1 %tobool134, label %if.then.139, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end.131
  %132 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_private135 = getelementptr inbounds %struct.op, %struct.op* %132, i32 0, i32 7
  %133 = load i8, i8* %op_private135, align 1
  %conv136 = zext i8 %133 to i32
  %and137 = and i32 %conv136, 2
  %tobool138 = icmp ne i32 %and137, 0
  br i1 %tobool138, label %if.then.139, label %if.end.141

if.then.139:                                      ; preds = %lor.lhs.false, %if.end.131
  %call140 = call %struct.op* (i8*, ...) @Perl_die(i8* getelementptr inbounds ([0 x i8], [0 x i8]* @PL_no_usym, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.6, i32 0, i32 0))
  store %struct.op* %call140, %struct.op** %retval
  br label %return

if.end.141:                                       ; preds = %lor.lhs.false
  %134 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings = getelementptr inbounds %struct.cop, %struct.cop* %134, i32 0, i32 14
  %135 = load %struct.sv*, %struct.sv** %cop_warnings, align 8
  %cmp142 = icmp ne %struct.sv* %135, null
  br i1 %cmp142, label %land.lhs.true.144, label %lor.lhs.false.160

land.lhs.true.144:                                ; preds = %if.end.141
  %136 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings145 = getelementptr inbounds %struct.cop, %struct.cop* %136, i32 0, i32 14
  %137 = load %struct.sv*, %struct.sv** %cop_warnings145, align 8
  %cmp146 = icmp ne %struct.sv* %137, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 2)
  br i1 %cmp146, label %land.lhs.true.148, label %lor.lhs.false.160

land.lhs.true.148:                                ; preds = %land.lhs.true.144
  %138 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings149 = getelementptr inbounds %struct.cop, %struct.cop* %138, i32 0, i32 14
  %139 = load %struct.sv*, %struct.sv** %cop_warnings149, align 8
  %cmp150 = icmp eq %struct.sv* %139, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 1)
  br i1 %cmp150, label %if.then.168, label %lor.lhs.false.152

lor.lhs.false.152:                                ; preds = %land.lhs.true.148
  %140 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings153 = getelementptr inbounds %struct.cop, %struct.cop* %140, i32 0, i32 14
  %141 = load %struct.sv*, %struct.sv** %cop_warnings153, align 8
  %sv_any154 = getelementptr inbounds %struct.sv, %struct.sv* %141, i32 0, i32 0
  %142 = load i8*, i8** %sv_any154, align 8
  %143 = bitcast i8* %142 to %struct.xpv*
  %xpv_pv155 = getelementptr inbounds %struct.xpv, %struct.xpv* %143, i32 0, i32 0
  %144 = load i8*, i8** %xpv_pv155, align 8
  %arrayidx156 = getelementptr inbounds i8, i8* %144, i64 10
  %145 = load i8, i8* %arrayidx156, align 1
  %conv157 = sext i8 %145 to i32
  %and158 = and i32 %conv157, 4
  %tobool159 = icmp ne i32 %and158, 0
  br i1 %tobool159, label %if.then.168, label %lor.lhs.false.160

lor.lhs.false.160:                                ; preds = %lor.lhs.false.152, %land.lhs.true.144, %if.end.141
  %146 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings161 = getelementptr inbounds %struct.cop, %struct.cop* %146, i32 0, i32 14
  %147 = load %struct.sv*, %struct.sv** %cop_warnings161, align 8
  %cmp162 = icmp eq %struct.sv* %147, null
  br i1 %cmp162, label %land.lhs.true.164, label %if.end.169

land.lhs.true.164:                                ; preds = %lor.lhs.false.160
  %148 = load i8, i8* @PL_dowarn, align 1
  %conv165 = zext i8 %148 to i32
  %and166 = and i32 %conv165, 1
  %tobool167 = icmp ne i32 %and166, 0
  br i1 %tobool167, label %if.then.168, label %if.end.169

if.then.168:                                      ; preds = %land.lhs.true.164, %lor.lhs.false.152, %land.lhs.true.148
  call void @Perl_report_uninit()
  br label %if.end.169

if.end.169:                                       ; preds = %if.then.168, %land.lhs.true.164, %lor.lhs.false.160
  %149 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* @PL_sv_undef, %struct.sv** %149, align 8
  %150 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %150, %struct.sv*** @PL_stack_sp, align 8
  %151 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %151, i32 0, i32 0
  %152 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %152, %struct.op** %retval
  br label %return

if.end.170:                                       ; preds = %land.lhs.true.56, %if.end.52
  %153 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags171 = getelementptr inbounds %struct.sv, %struct.sv* %153, i32 0, i32 2
  %154 = load i32, i32* %sv_flags171, align 4
  %and172 = and i32 %154, 262144
  %cmp173 = icmp eq i32 %and172, 262144
  br i1 %cmp173, label %cond.true.175, label %cond.false.180

cond.true.175:                                    ; preds = %if.end.170
  %155 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any176 = getelementptr inbounds %struct.sv, %struct.sv* %155, i32 0, i32 0
  %156 = load i8*, i8** %sv_any176, align 8
  %157 = bitcast i8* %156 to %struct.xpv*
  %xpv_cur177 = getelementptr inbounds %struct.xpv, %struct.xpv* %157, i32 0, i32 1
  %158 = load i64, i64* %xpv_cur177, align 8
  store i64 %158, i64* %len, align 8
  %159 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any178 = getelementptr inbounds %struct.sv, %struct.sv* %159, i32 0, i32 0
  %160 = load i8*, i8** %sv_any178, align 8
  %161 = bitcast i8* %160 to %struct.xpv*
  %xpv_pv179 = getelementptr inbounds %struct.xpv, %struct.xpv* %161, i32 0, i32 0
  %162 = load i8*, i8** %xpv_pv179, align 8
  br label %cond.end.182

cond.false.180:                                   ; preds = %if.end.170
  %163 = load %struct.sv*, %struct.sv** %sv, align 8
  %call181 = call i8* @Perl_sv_2pv_flags(%struct.sv* %163, i64* %len, i32 2)
  br label %cond.end.182

cond.end.182:                                     ; preds = %cond.false.180, %cond.true.175
  %cond183 = phi i8* [ %162, %cond.true.175 ], [ %call181, %cond.false.180 ]
  store i8* %cond183, i8** %sym, align 8
  %164 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags184 = getelementptr inbounds %struct.op, %struct.op* %164, i32 0, i32 6
  %165 = load i8, i8* %op_flags184, align 1
  %conv185 = zext i8 %165 to i32
  %and186 = and i32 %conv185, 128
  %tobool187 = icmp ne i32 %and186, 0
  br i1 %tobool187, label %land.lhs.true.188, label %if.else.205

land.lhs.true.188:                                ; preds = %cond.end.182
  %166 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags189 = getelementptr inbounds %struct.op, %struct.op* %166, i32 0, i32 6
  %167 = load i8, i8* %op_flags189, align 1
  %conv190 = zext i8 %167 to i32
  %and191 = and i32 %conv190, 32
  %tobool192 = icmp ne i32 %and191, 0
  br i1 %tobool192, label %if.else.205, label %if.then.193

if.then.193:                                      ; preds = %land.lhs.true.188
  %168 = load i8*, i8** %sym, align 8
  %call194 = call %struct.gv* @Perl_gv_fetchpv(i8* %168, i32 0, i32 13)
  %169 = bitcast %struct.gv* %call194 to %struct.sv*
  store %struct.sv* %169, %struct.sv** %sv, align 8
  %170 = load %struct.sv*, %struct.sv** %sv, align 8
  %tobool195 = icmp ne %struct.sv* %170, null
  br i1 %tobool195, label %if.end.204, label %land.lhs.true.196

land.lhs.true.196:                                ; preds = %if.then.193
  %171 = load i8*, i8** %sym, align 8
  %172 = load i64, i64* %len, align 8
  %call197 = call signext i8 @Perl_is_gv_magical(i8* %171, i64 %172, i32 0)
  %tobool198 = icmp ne i8 %call197, 0
  br i1 %tobool198, label %lor.lhs.false.199, label %if.then.202

lor.lhs.false.199:                                ; preds = %land.lhs.true.196
  %173 = load i8*, i8** %sym, align 8
  %call200 = call %struct.gv* @Perl_gv_fetchpv(i8* %173, i32 1, i32 13)
  %174 = bitcast %struct.gv* %call200 to %struct.sv*
  store %struct.sv* %174, %struct.sv** %sv, align 8
  %tobool201 = icmp ne %struct.sv* %174, null
  br i1 %tobool201, label %if.end.204, label %if.then.202

if.then.202:                                      ; preds = %lor.lhs.false.199, %land.lhs.true.196
  %175 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* @PL_sv_undef, %struct.sv** %175, align 8
  %176 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %176, %struct.sv*** @PL_stack_sp, align 8
  %177 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next203 = getelementptr inbounds %struct.op, %struct.op* %177, i32 0, i32 0
  %178 = load %struct.op*, %struct.op** %op_next203, align 8
  store %struct.op* %178, %struct.op** %retval
  br label %return

if.end.204:                                       ; preds = %lor.lhs.false.199, %if.then.193
  br label %if.end.214

if.else.205:                                      ; preds = %land.lhs.true.188, %cond.end.182
  %179 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_private206 = getelementptr inbounds %struct.op, %struct.op* %179, i32 0, i32 7
  %180 = load i8, i8* %op_private206, align 1
  %conv207 = zext i8 %180 to i32
  %and208 = and i32 %conv207, 2
  %tobool209 = icmp ne i32 %and208, 0
  br i1 %tobool209, label %if.then.210, label %if.end.212

if.then.210:                                      ; preds = %if.else.205
  %181 = load i8*, i8** %sym, align 8
  %call211 = call %struct.op* (i8*, ...) @Perl_die(i8* getelementptr inbounds ([0 x i8], [0 x i8]* @PL_no_symref, i32 0, i32 0), i8* %181, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.6, i32 0, i32 0))
  store %struct.op* %call211, %struct.op** %retval
  br label %return

if.end.212:                                       ; preds = %if.else.205
  %182 = load i8*, i8** %sym, align 8
  %call213 = call %struct.gv* @Perl_gv_fetchpv(i8* %182, i32 1, i32 13)
  %183 = bitcast %struct.gv* %call213 to %struct.sv*
  store %struct.sv* %183, %struct.sv** %sv, align 8
  br label %if.end.214

if.end.214:                                       ; preds = %if.end.212, %if.end.204
  br label %if.end.215

if.end.215:                                       ; preds = %if.end.214, %if.else.37
  br label %if.end.216

if.end.216:                                       ; preds = %if.end.215, %if.end.36
  %184 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_private217 = getelementptr inbounds %struct.op, %struct.op* %184, i32 0, i32 7
  %185 = load i8, i8* %op_private217, align 1
  %conv218 = zext i8 %185 to i32
  %and219 = and i32 %conv218, 128
  %tobool220 = icmp ne i32 %and219, 0
  br i1 %tobool220, label %if.then.221, label %if.end.226

if.then.221:                                      ; preds = %if.end.216
  %186 = load %struct.sv*, %struct.sv** %sv, align 8
  %187 = bitcast %struct.sv* %186 to %struct.gv*
  %188 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags222 = getelementptr inbounds %struct.op, %struct.op* %188, i32 0, i32 6
  %189 = load i8, i8* %op_flags222, align 1
  %conv223 = zext i8 %189 to i32
  %and224 = and i32 %conv223, 128
  %tobool225 = icmp ne i32 %and224, 0
  %lnot = xor i1 %tobool225, true
  %lnot.ext = zext i1 %lnot to i32
  call void @Perl_save_gp(%struct.gv* %187, i32 %lnot.ext)
  br label %if.end.226

if.end.226:                                       ; preds = %if.then.221, %if.end.216
  %190 = load %struct.sv*, %struct.sv** %sv, align 8
  %191 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %190, %struct.sv** %191, align 8
  %192 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %192, %struct.sv*** @PL_stack_sp, align 8
  %193 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next227 = getelementptr inbounds %struct.op, %struct.op* %193, i32 0, i32 0
  %194 = load %struct.op*, %struct.op** %op_next227, align 8
  store %struct.op* %194, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.226, %if.then.210, %if.then.202, %if.end.169, %if.then.139, %if.then.33
  %195 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %195
}

declare %struct.sv* @Perl_amagic_call(%struct.sv*, %struct.sv*, i32, i32) #1

declare void @Perl_gv_init(%struct.gv*, %struct.hv*, i8*, i64, i32) #1

declare i32 @Perl_mg_get(%struct.sv*) #1

declare i8* @Perl_sv_2pv_flags(%struct.sv*, i64*, i32) #1

declare %struct.sv* @Perl_newSV(i64) #1

declare %struct.gv* @Perl_newGVgen(i8*) #1

declare signext i8 @Perl_sv_upgrade(%struct.sv*, i32) #1

declare i32 @Perl_sv_backoff(%struct.sv*) #1

declare void @Perl_safesysfree(i8*) #1

declare i32 @Perl_mg_set(%struct.sv*) #1

declare void @Perl_report_uninit() #1

declare %struct.gv* @Perl_gv_fetchpv(i8*, i32, i32) #1

declare signext i8 @Perl_is_gv_magical(i8*, i64, i32) #1

declare void @Perl_save_gp(%struct.gv*, i32) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_rv2sv() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %gv = alloca %struct.gv*, align 8
  %sp = alloca %struct.sv**, align 8
  %sv = alloca %struct.sv*, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %arg = alloca %struct.sv*, align 8
  %sym = alloca i8*, align 8
  %len = alloca i64, align 8
  store %struct.gv* null, %struct.gv** %gv, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.sv**, %struct.sv*** %sp, align 8
  %2 = load %struct.sv*, %struct.sv** %1, align 8
  store %struct.sv* %2, %struct.sv** %sv, align 8
  %3 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %3, i32 0, i32 2
  %4 = load i32, i32* %sv_flags, align 4
  %and = and i32 %4, 524288
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %wasref

wasref:                                           ; preds = %if.then.37, %if.then
  %5 = load i64, i64* @PL_amagic_generation, align 8
  %tobool1 = icmp ne i64 %5, 0
  br i1 %tobool1, label %if.then.2, label %if.end.19

if.then.2:                                        ; preds = %wasref
  %6 = load %struct.sv**, %struct.sv*** %sp, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %6, i64 0
  %7 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %7, %struct.sv** %arg, align 8
  br label %am_again

am_again:                                         ; preds = %if.then.16, %if.then.2
  %8 = load %struct.sv*, %struct.sv** %arg, align 8
  %sv_flags3 = getelementptr inbounds %struct.sv, %struct.sv* %8, i32 0, i32 2
  %9 = load i32, i32* %sv_flags3, align 4
  %and4 = and i32 %9, 268435456
  %tobool5 = icmp ne i32 %and4, 0
  br i1 %tobool5, label %land.lhs.true, label %if.end.18

land.lhs.true:                                    ; preds = %am_again
  %10 = load %struct.sv*, %struct.sv** %arg, align 8
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %10, %struct.sv* @PL_sv_undef, i32 58, i32 9)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool6 = icmp ne %struct.sv* %call, null
  br i1 %tobool6, label %if.then.7, label %if.end.18

if.then.7:                                        ; preds = %land.lhs.true
  %11 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %11, %struct.sv*** %sp, align 8
  %12 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  store %struct.sv* %12, %struct.sv** %sv, align 8
  %13 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %sv_flags8 = getelementptr inbounds %struct.sv, %struct.sv* %13, i32 0, i32 2
  %14 = load i32, i32* %sv_flags8, align 4
  %and9 = and i32 %14, 524288
  %tobool10 = icmp ne i32 %and9, 0
  br i1 %tobool10, label %if.end, label %if.then.11

if.then.11:                                       ; preds = %if.then.7
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([50 x i8], [50 x i8]* @.str.3, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then.11, %if.then.7
  %15 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %16 = load %struct.sv*, %struct.sv** %arg, align 8
  %cmp = icmp ne %struct.sv* %15, %16
  br i1 %cmp, label %land.lhs.true.12, label %if.end.17

land.lhs.true.12:                                 ; preds = %if.end
  %17 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %17, i32 0, i32 0
  %18 = load i8*, i8** %sv_any, align 8
  %19 = bitcast i8* %18 to %struct.xrv*
  %xrv_rv = getelementptr inbounds %struct.xrv, %struct.xrv* %19, i32 0, i32 0
  %20 = load %struct.sv*, %struct.sv** %xrv_rv, align 8
  %21 = load %struct.sv*, %struct.sv** %arg, align 8
  %sv_any13 = getelementptr inbounds %struct.sv, %struct.sv* %21, i32 0, i32 0
  %22 = load i8*, i8** %sv_any13, align 8
  %23 = bitcast i8* %22 to %struct.xrv*
  %xrv_rv14 = getelementptr inbounds %struct.xrv, %struct.xrv* %23, i32 0, i32 0
  %24 = load %struct.sv*, %struct.sv** %xrv_rv14, align 8
  %cmp15 = icmp ne %struct.sv* %20, %24
  br i1 %cmp15, label %if.then.16, label %if.end.17

if.then.16:                                       ; preds = %land.lhs.true.12
  %25 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  store %struct.sv* %25, %struct.sv** %arg, align 8
  br label %am_again

if.end.17:                                        ; preds = %land.lhs.true.12, %if.end
  br label %if.end.18

if.end.18:                                        ; preds = %if.end.17, %land.lhs.true, %am_again
  br label %if.end.19

if.end.19:                                        ; preds = %if.end.18, %wasref
  %26 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any20 = getelementptr inbounds %struct.sv, %struct.sv* %26, i32 0, i32 0
  %27 = load i8*, i8** %sv_any20, align 8
  %28 = bitcast i8* %27 to %struct.xrv*
  %xrv_rv21 = getelementptr inbounds %struct.xrv, %struct.xrv* %28, i32 0, i32 0
  %29 = load %struct.sv*, %struct.sv** %xrv_rv21, align 8
  store %struct.sv* %29, %struct.sv** %sv, align 8
  %30 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags22 = getelementptr inbounds %struct.sv, %struct.sv* %30, i32 0, i32 2
  %31 = load i32, i32* %sv_flags22, align 4
  %and23 = and i32 %31, 255
  switch i32 %and23, label %sw.epilog [
    i32 10, label %sw.bb
    i32 11, label %sw.bb
    i32 12, label %sw.bb
  ]

sw.bb:                                            ; preds = %if.end.19, %if.end.19, %if.end.19
  %call24 = call %struct.op* (i8*, ...) @Perl_die(i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.7, i32 0, i32 0))
  store %struct.op* %call24, %struct.op** %retval
  br label %return

sw.epilog:                                        ; preds = %if.end.19
  br label %if.end.121

if.else:                                          ; preds = %entry
  %32 = load %struct.sv*, %struct.sv** %sv, align 8
  %33 = bitcast %struct.sv* %32 to %struct.gv*
  store %struct.gv* %33, %struct.gv** %gv, align 8
  %34 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_flags25 = getelementptr inbounds %struct.gv, %struct.gv* %34, i32 0, i32 2
  %35 = load i32, i32* %sv_flags25, align 4
  %and26 = and i32 %35, 255
  %cmp27 = icmp ne i32 %and26, 13
  br i1 %cmp27, label %if.then.28, label %if.end.119

if.then.28:                                       ; preds = %if.else
  %36 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags29 = getelementptr inbounds %struct.sv, %struct.sv* %36, i32 0, i32 2
  %37 = load i32, i32* %sv_flags29, align 4
  %and30 = and i32 %37, 8192
  %tobool31 = icmp ne i32 %and30, 0
  br i1 %tobool31, label %if.then.32, label %if.end.39

if.then.32:                                       ; preds = %if.then.28
  %38 = load %struct.sv*, %struct.sv** %sv, align 8
  %call33 = call i32 @Perl_mg_get(%struct.sv* %38)
  %39 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags34 = getelementptr inbounds %struct.sv, %struct.sv* %39, i32 0, i32 2
  %40 = load i32, i32* %sv_flags34, align 4
  %and35 = and i32 %40, 524288
  %tobool36 = icmp ne i32 %and35, 0
  br i1 %tobool36, label %if.then.37, label %if.end.38

if.then.37:                                       ; preds = %if.then.32
  br label %wasref

if.end.38:                                        ; preds = %if.then.32
  br label %if.end.39

if.end.39:                                        ; preds = %if.end.38, %if.then.28
  %41 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags40 = getelementptr inbounds %struct.sv, %struct.sv* %41, i32 0, i32 2
  %42 = load i32, i32* %sv_flags40, align 4
  %and41 = and i32 %42, 118423552
  %tobool42 = icmp ne i32 %and41, 0
  br i1 %tobool42, label %if.end.79, label %if.then.43

if.then.43:                                       ; preds = %if.end.39
  %43 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %43, i32 0, i32 6
  %44 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %44 to i32
  %and44 = and i32 %conv, 16
  %tobool45 = icmp ne i32 %and44, 0
  br i1 %tobool45, label %if.then.49, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then.43
  %45 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %45, i32 0, i32 7
  %46 = load i8, i8* %op_private, align 1
  %conv46 = zext i8 %46 to i32
  %and47 = and i32 %conv46, 2
  %tobool48 = icmp ne i32 %and47, 0
  br i1 %tobool48, label %if.then.49, label %if.end.51

if.then.49:                                       ; preds = %lor.lhs.false, %if.then.43
  %call50 = call %struct.op* (i8*, ...) @Perl_die(i8* getelementptr inbounds ([0 x i8], [0 x i8]* @PL_no_usym, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.8, i32 0, i32 0))
  store %struct.op* %call50, %struct.op** %retval
  br label %return

if.end.51:                                        ; preds = %lor.lhs.false
  %47 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings = getelementptr inbounds %struct.cop, %struct.cop* %47, i32 0, i32 14
  %48 = load %struct.sv*, %struct.sv** %cop_warnings, align 8
  %cmp52 = icmp ne %struct.sv* %48, null
  br i1 %cmp52, label %land.lhs.true.54, label %lor.lhs.false.69

land.lhs.true.54:                                 ; preds = %if.end.51
  %49 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings55 = getelementptr inbounds %struct.cop, %struct.cop* %49, i32 0, i32 14
  %50 = load %struct.sv*, %struct.sv** %cop_warnings55, align 8
  %cmp56 = icmp ne %struct.sv* %50, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 2)
  br i1 %cmp56, label %land.lhs.true.58, label %lor.lhs.false.69

land.lhs.true.58:                                 ; preds = %land.lhs.true.54
  %51 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings59 = getelementptr inbounds %struct.cop, %struct.cop* %51, i32 0, i32 14
  %52 = load %struct.sv*, %struct.sv** %cop_warnings59, align 8
  %cmp60 = icmp eq %struct.sv* %52, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 1)
  br i1 %cmp60, label %if.then.77, label %lor.lhs.false.62

lor.lhs.false.62:                                 ; preds = %land.lhs.true.58
  %53 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings63 = getelementptr inbounds %struct.cop, %struct.cop* %53, i32 0, i32 14
  %54 = load %struct.sv*, %struct.sv** %cop_warnings63, align 8
  %sv_any64 = getelementptr inbounds %struct.sv, %struct.sv* %54, i32 0, i32 0
  %55 = load i8*, i8** %sv_any64, align 8
  %56 = bitcast i8* %55 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %56, i32 0, i32 0
  %57 = load i8*, i8** %xpv_pv, align 8
  %arrayidx65 = getelementptr inbounds i8, i8* %57, i64 10
  %58 = load i8, i8* %arrayidx65, align 1
  %conv66 = sext i8 %58 to i32
  %and67 = and i32 %conv66, 4
  %tobool68 = icmp ne i32 %and67, 0
  br i1 %tobool68, label %if.then.77, label %lor.lhs.false.69

lor.lhs.false.69:                                 ; preds = %lor.lhs.false.62, %land.lhs.true.54, %if.end.51
  %59 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings70 = getelementptr inbounds %struct.cop, %struct.cop* %59, i32 0, i32 14
  %60 = load %struct.sv*, %struct.sv** %cop_warnings70, align 8
  %cmp71 = icmp eq %struct.sv* %60, null
  br i1 %cmp71, label %land.lhs.true.73, label %if.end.78

land.lhs.true.73:                                 ; preds = %lor.lhs.false.69
  %61 = load i8, i8* @PL_dowarn, align 1
  %conv74 = zext i8 %61 to i32
  %and75 = and i32 %conv74, 1
  %tobool76 = icmp ne i32 %and75, 0
  br i1 %tobool76, label %if.then.77, label %if.end.78

if.then.77:                                       ; preds = %land.lhs.true.73, %lor.lhs.false.62, %land.lhs.true.58
  call void @Perl_report_uninit()
  br label %if.end.78

if.end.78:                                        ; preds = %if.then.77, %land.lhs.true.73, %lor.lhs.false.69
  %62 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* @PL_sv_undef, %struct.sv** %62, align 8
  %63 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %63, %struct.sv*** @PL_stack_sp, align 8
  %64 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %64, i32 0, i32 0
  %65 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %65, %struct.op** %retval
  br label %return

if.end.79:                                        ; preds = %if.end.39
  %66 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags80 = getelementptr inbounds %struct.sv, %struct.sv* %66, i32 0, i32 2
  %67 = load i32, i32* %sv_flags80, align 4
  %and81 = and i32 %67, 262144
  %cmp82 = icmp eq i32 %and81, 262144
  br i1 %cmp82, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.79
  %68 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any84 = getelementptr inbounds %struct.sv, %struct.sv* %68, i32 0, i32 0
  %69 = load i8*, i8** %sv_any84, align 8
  %70 = bitcast i8* %69 to %struct.xpv*
  %xpv_cur = getelementptr inbounds %struct.xpv, %struct.xpv* %70, i32 0, i32 1
  %71 = load i64, i64* %xpv_cur, align 8
  store i64 %71, i64* %len, align 8
  %72 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any85 = getelementptr inbounds %struct.sv, %struct.sv* %72, i32 0, i32 0
  %73 = load i8*, i8** %sv_any85, align 8
  %74 = bitcast i8* %73 to %struct.xpv*
  %xpv_pv86 = getelementptr inbounds %struct.xpv, %struct.xpv* %74, i32 0, i32 0
  %75 = load i8*, i8** %xpv_pv86, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end.79
  %76 = load %struct.sv*, %struct.sv** %sv, align 8
  %call87 = call i8* @Perl_sv_2pv_flags(%struct.sv* %76, i64* %len, i32 2)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %75, %cond.true ], [ %call87, %cond.false ]
  store i8* %cond, i8** %sym, align 8
  %77 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags88 = getelementptr inbounds %struct.op, %struct.op* %77, i32 0, i32 6
  %78 = load i8, i8* %op_flags88, align 1
  %conv89 = zext i8 %78 to i32
  %and90 = and i32 %conv89, 128
  %tobool91 = icmp ne i32 %and90, 0
  br i1 %tobool91, label %land.lhs.true.92, label %if.else.109

land.lhs.true.92:                                 ; preds = %cond.end
  %79 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags93 = getelementptr inbounds %struct.op, %struct.op* %79, i32 0, i32 6
  %80 = load i8, i8* %op_flags93, align 1
  %conv94 = zext i8 %80 to i32
  %and95 = and i32 %conv94, 32
  %tobool96 = icmp ne i32 %and95, 0
  br i1 %tobool96, label %if.else.109, label %if.then.97

if.then.97:                                       ; preds = %land.lhs.true.92
  %81 = load i8*, i8** %sym, align 8
  %call98 = call %struct.gv* @Perl_gv_fetchpv(i8* %81, i32 0, i32 4)
  store %struct.gv* %call98, %struct.gv** %gv, align 8
  %82 = load %struct.gv*, %struct.gv** %gv, align 8
  %tobool99 = icmp ne %struct.gv* %82, null
  br i1 %tobool99, label %if.end.108, label %land.lhs.true.100

land.lhs.true.100:                                ; preds = %if.then.97
  %83 = load i8*, i8** %sym, align 8
  %84 = load i64, i64* %len, align 8
  %call101 = call signext i8 @Perl_is_gv_magical(i8* %83, i64 %84, i32 0)
  %tobool102 = icmp ne i8 %call101, 0
  br i1 %tobool102, label %lor.lhs.false.103, label %if.then.106

lor.lhs.false.103:                                ; preds = %land.lhs.true.100
  %85 = load i8*, i8** %sym, align 8
  %call104 = call %struct.gv* @Perl_gv_fetchpv(i8* %85, i32 1, i32 4)
  store %struct.gv* %call104, %struct.gv** %gv, align 8
  %tobool105 = icmp ne %struct.gv* %call104, null
  br i1 %tobool105, label %if.end.108, label %if.then.106

if.then.106:                                      ; preds = %lor.lhs.false.103, %land.lhs.true.100
  %86 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* @PL_sv_undef, %struct.sv** %86, align 8
  %87 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %87, %struct.sv*** @PL_stack_sp, align 8
  %88 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next107 = getelementptr inbounds %struct.op, %struct.op* %88, i32 0, i32 0
  %89 = load %struct.op*, %struct.op** %op_next107, align 8
  store %struct.op* %89, %struct.op** %retval
  br label %return

if.end.108:                                       ; preds = %lor.lhs.false.103, %if.then.97
  br label %if.end.118

if.else.109:                                      ; preds = %land.lhs.true.92, %cond.end
  %90 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_private110 = getelementptr inbounds %struct.op, %struct.op* %90, i32 0, i32 7
  %91 = load i8, i8* %op_private110, align 1
  %conv111 = zext i8 %91 to i32
  %and112 = and i32 %conv111, 2
  %tobool113 = icmp ne i32 %and112, 0
  br i1 %tobool113, label %if.then.114, label %if.end.116

if.then.114:                                      ; preds = %if.else.109
  %92 = load i8*, i8** %sym, align 8
  %call115 = call %struct.op* (i8*, ...) @Perl_die(i8* getelementptr inbounds ([0 x i8], [0 x i8]* @PL_no_symref, i32 0, i32 0), i8* %92, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.8, i32 0, i32 0))
  store %struct.op* %call115, %struct.op** %retval
  br label %return

if.end.116:                                       ; preds = %if.else.109
  %93 = load i8*, i8** %sym, align 8
  %call117 = call %struct.gv* @Perl_gv_fetchpv(i8* %93, i32 1, i32 4)
  store %struct.gv* %call117, %struct.gv** %gv, align 8
  br label %if.end.118

if.end.118:                                       ; preds = %if.end.116, %if.end.108
  br label %if.end.119

if.end.119:                                       ; preds = %if.end.118, %if.else
  %94 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any120 = getelementptr inbounds %struct.gv, %struct.gv* %94, i32 0, i32 0
  %95 = load %struct.xpvgv*, %struct.xpvgv** %sv_any120, align 8
  %xgv_gp = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %95, i32 0, i32 7
  %96 = load %struct.gp*, %struct.gp** %xgv_gp, align 8
  %gp_sv = getelementptr inbounds %struct.gp, %struct.gp* %96, i32 0, i32 0
  %97 = load %struct.sv*, %struct.sv** %gp_sv, align 8
  store %struct.sv* %97, %struct.sv** %sv, align 8
  br label %if.end.121

if.end.121:                                       ; preds = %if.end.119, %sw.epilog
  %98 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags122 = getelementptr inbounds %struct.op, %struct.op* %98, i32 0, i32 6
  %99 = load i8, i8* %op_flags122, align 1
  %conv123 = zext i8 %99 to i32
  %and124 = and i32 %conv123, 32
  %tobool125 = icmp ne i32 %and124, 0
  br i1 %tobool125, label %if.then.126, label %if.end.155

if.then.126:                                      ; preds = %if.end.121
  %100 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_private127 = getelementptr inbounds %struct.op, %struct.op* %100, i32 0, i32 7
  %101 = load i8, i8* %op_private127, align 1
  %conv128 = zext i8 %101 to i32
  %and129 = and i32 %conv128, 128
  %tobool130 = icmp ne i32 %and129, 0
  br i1 %tobool130, label %if.then.131, label %if.else.144

if.then.131:                                      ; preds = %if.then.126
  %102 = load %struct.op*, %struct.op** @PL_op, align 8
  %103 = bitcast %struct.op* %102 to %struct.unop*
  %op_first = getelementptr inbounds %struct.unop, %struct.unop* %103, i32 0, i32 8
  %104 = load %struct.op*, %struct.op** %op_first, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %104, i32 0, i32 4
  %105 = load i16, i16* %op_type, align 2
  %conv132 = zext i16 %105 to i32
  %cmp133 = icmp eq i32 %conv132, 0
  br i1 %cmp133, label %if.then.135, label %if.else.137

if.then.135:                                      ; preds = %if.then.131
  %106 = load %struct.sv**, %struct.sv*** %sp, align 8
  %107 = load %struct.sv*, %struct.sv** %106, align 8
  %108 = bitcast %struct.sv* %107 to %struct.gv*
  %call136 = call %struct.sv* @Perl_save_scalar(%struct.gv* %108)
  store %struct.sv* %call136, %struct.sv** %sv, align 8
  br label %if.end.143

if.else.137:                                      ; preds = %if.then.131
  %109 = load %struct.gv*, %struct.gv** %gv, align 8
  %tobool138 = icmp ne %struct.gv* %109, null
  br i1 %tobool138, label %if.then.139, label %if.else.141

if.then.139:                                      ; preds = %if.else.137
  %110 = load %struct.gv*, %struct.gv** %gv, align 8
  %call140 = call %struct.sv* @Perl_save_scalar(%struct.gv* %110)
  store %struct.sv* %call140, %struct.sv** %sv, align 8
  br label %if.end.142

if.else.141:                                      ; preds = %if.else.137
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([0 x i8], [0 x i8]* @PL_no_localize_ref, i32 0, i32 0))
  br label %if.end.142

if.end.142:                                       ; preds = %if.else.141, %if.then.139
  br label %if.end.143

if.end.143:                                       ; preds = %if.end.142, %if.then.135
  br label %if.end.154

if.else.144:                                      ; preds = %if.then.126
  %111 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_private145 = getelementptr inbounds %struct.op, %struct.op* %111, i32 0, i32 7
  %112 = load i8, i8* %op_private145, align 1
  %conv146 = zext i8 %112 to i32
  %and147 = and i32 %conv146, 96
  %tobool148 = icmp ne i32 %and147, 0
  br i1 %tobool148, label %if.then.149, label %if.end.153

if.then.149:                                      ; preds = %if.else.144
  %113 = load %struct.sv*, %struct.sv** %sv, align 8
  %114 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_private150 = getelementptr inbounds %struct.op, %struct.op* %114, i32 0, i32 7
  %115 = load i8, i8* %op_private150, align 1
  %conv151 = zext i8 %115 to i32
  %and152 = and i32 %conv151, 96
  call void @Perl_vivify_ref(%struct.sv* %113, i32 %and152)
  br label %if.end.153

if.end.153:                                       ; preds = %if.then.149, %if.else.144
  br label %if.end.154

if.end.154:                                       ; preds = %if.end.153, %if.end.143
  br label %if.end.155

if.end.155:                                       ; preds = %if.end.154, %if.end.121
  %116 = load %struct.sv*, %struct.sv** %sv, align 8
  %117 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %116, %struct.sv** %117, align 8
  %118 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %118, %struct.sv*** @PL_stack_sp, align 8
  %119 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next156 = getelementptr inbounds %struct.op, %struct.op* %119, i32 0, i32 0
  %120 = load %struct.op*, %struct.op** %op_next156, align 8
  store %struct.op* %120, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.155, %if.then.114, %if.then.106, %if.end.78, %if.then.49, %sw.bb
  %121 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %121
}

declare %struct.sv* @Perl_save_scalar(%struct.gv*) #1

declare void @Perl_vivify_ref(%struct.sv*, i32) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_av2arylen() #0 {
entry:
  %sp = alloca %struct.sv**, align 8
  %av = alloca %struct.av*, align 8
  %sv = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.sv**, %struct.sv*** %sp, align 8
  %2 = load %struct.sv*, %struct.sv** %1, align 8
  %3 = bitcast %struct.sv* %2 to %struct.av*
  store %struct.av* %3, %struct.av** %av, align 8
  %4 = load %struct.av*, %struct.av** %av, align 8
  %sv_any = getelementptr inbounds %struct.av, %struct.av* %4, i32 0, i32 0
  %5 = load %struct.xpvav*, %struct.xpvav** %sv_any, align 8
  %xav_arylen = getelementptr inbounds %struct.xpvav, %struct.xpvav* %5, i32 0, i32 8
  %6 = load %struct.sv*, %struct.sv** %xav_arylen, align 8
  store %struct.sv* %6, %struct.sv** %sv, align 8
  %7 = load %struct.sv*, %struct.sv** %sv, align 8
  %tobool = icmp ne %struct.sv* %7, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %call = call %struct.sv* @Perl_newSV(i64 0)
  store %struct.sv* %call, %struct.sv** %sv, align 8
  %8 = load %struct.av*, %struct.av** %av, align 8
  %sv_any1 = getelementptr inbounds %struct.av, %struct.av* %8, i32 0, i32 0
  %9 = load %struct.xpvav*, %struct.xpvav** %sv_any1, align 8
  %xav_arylen2 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %9, i32 0, i32 8
  store %struct.sv* %call, %struct.sv** %xav_arylen2, align 8
  %10 = load %struct.sv*, %struct.sv** %sv, align 8
  %call3 = call signext i8 @Perl_sv_upgrade(%struct.sv* %10, i32 1)
  %11 = load %struct.sv*, %struct.sv** %sv, align 8
  %12 = load %struct.av*, %struct.av** %av, align 8
  %13 = bitcast %struct.av* %12 to %struct.sv*
  call void @Perl_sv_magic(%struct.sv* %11, %struct.sv* %13, i32 35, i8* null, i32 0)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %14 = load %struct.sv*, %struct.sv** %sv, align 8
  %15 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %14, %struct.sv** %15, align 8
  %16 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %16, %struct.sv*** @PL_stack_sp, align 8
  %17 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %17, i32 0, i32 0
  %18 = load %struct.op*, %struct.op** %op_next, align 8
  ret %struct.op* %18
}

declare void @Perl_sv_magic(%struct.sv*, %struct.sv*, i32, i8*, i32) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_pos() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %sv = alloca %struct.sv*, align 8
  %mg = alloca %struct.magic*, align 8
  %i = alloca i32, align 4
  %tmp = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 3
  %2 = load i64, i64* %op_targ, align 8
  %3 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 %2
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %4, %struct.sv** %targ, align 8
  %5 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %5, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %6 = load %struct.sv*, %struct.sv** %5, align 8
  store %struct.sv* %6, %struct.sv** %sv, align 8
  %7 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %7, i32 0, i32 6
  %8 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %8 to i32
  %and = and i32 %conv, 32
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %9 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %9, i32 0, i32 7
  %10 = load i8, i8* %op_private, align 1
  %conv1 = zext i8 %10 to i32
  %and2 = and i32 %conv1, 8
  %tobool3 = icmp ne i32 %and2, 0
  br i1 %tobool3, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %lor.lhs.false
  %call = call i32 @Perl_is_lvalue_sub()
  %tobool4 = icmp ne i32 %call, 0
  br i1 %tobool4, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true, %entry
  %11 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %11, i32 0, i32 2
  %12 = load i32, i32* %sv_flags, align 4
  %and5 = and i32 %12, 255
  %cmp = icmp ult i32 %and5, 9
  br i1 %cmp, label %if.then.7, label %if.end

if.then.7:                                        ; preds = %if.then
  %13 = load %struct.sv*, %struct.sv** %targ, align 8
  %call8 = call signext i8 @Perl_sv_upgrade(%struct.sv* %13, i32 9)
  %14 = load %struct.sv*, %struct.sv** %targ, align 8
  call void @Perl_sv_magic(%struct.sv* %14, %struct.sv* null, i32 46, i8* null, i32 0)
  br label %if.end

if.end:                                           ; preds = %if.then.7, %if.then
  %15 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %15, i32 0, i32 0
  %16 = load i8*, i8** %sv_any, align 8
  %17 = bitcast i8* %16 to %struct.xpvlv*
  %xlv_type = getelementptr inbounds %struct.xpvlv, %struct.xpvlv* %17, i32 0, i32 10
  store i8 46, i8* %xlv_type, align 1
  %18 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any9 = getelementptr inbounds %struct.sv, %struct.sv* %18, i32 0, i32 0
  %19 = load i8*, i8** %sv_any9, align 8
  %20 = bitcast i8* %19 to %struct.xpvlv*
  %xlv_targ = getelementptr inbounds %struct.xpvlv, %struct.xpvlv* %20, i32 0, i32 9
  %21 = load %struct.sv*, %struct.sv** %xlv_targ, align 8
  %22 = load %struct.sv*, %struct.sv** %sv, align 8
  %cmp10 = icmp ne %struct.sv* %21, %22
  br i1 %cmp10, label %if.then.12, label %if.end.24

if.then.12:                                       ; preds = %if.end
  %23 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any13 = getelementptr inbounds %struct.sv, %struct.sv* %23, i32 0, i32 0
  %24 = load i8*, i8** %sv_any13, align 8
  %25 = bitcast i8* %24 to %struct.xpvlv*
  %xlv_targ14 = getelementptr inbounds %struct.xpvlv, %struct.xpvlv* %25, i32 0, i32 9
  %26 = load %struct.sv*, %struct.sv** %xlv_targ14, align 8
  %tobool15 = icmp ne %struct.sv* %26, null
  br i1 %tobool15, label %if.then.16, label %if.end.19

if.then.16:                                       ; preds = %if.then.12
  %27 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any17 = getelementptr inbounds %struct.sv, %struct.sv* %27, i32 0, i32 0
  %28 = load i8*, i8** %sv_any17, align 8
  %29 = bitcast i8* %28 to %struct.xpvlv*
  %xlv_targ18 = getelementptr inbounds %struct.xpvlv, %struct.xpvlv* %29, i32 0, i32 9
  %30 = load %struct.sv*, %struct.sv** %xlv_targ18, align 8
  call void @Perl_sv_free(%struct.sv* %30)
  br label %if.end.19

if.end.19:                                        ; preds = %if.then.16, %if.then.12
  %31 = load %struct.sv*, %struct.sv** %sv, align 8
  store %struct.sv* %31, %struct.sv** @PL_Sv, align 8
  %32 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %tobool20 = icmp ne %struct.sv* %32, null
  br i1 %tobool20, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end.19
  %33 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_refcnt = getelementptr inbounds %struct.sv, %struct.sv* %33, i32 0, i32 1
  %34 = load i32, i32* %sv_refcnt, align 4
  %inc = add i32 %34, 1
  store i32 %inc, i32* %sv_refcnt, align 4
  %tobool21 = icmp ne i32 %inc, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end.19
  %35 = phi i1 [ false, %if.end.19 ], [ %tobool21, %land.rhs ]
  %land.ext = zext i1 %35 to i32
  %36 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %37 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any22 = getelementptr inbounds %struct.sv, %struct.sv* %37, i32 0, i32 0
  %38 = load i8*, i8** %sv_any22, align 8
  %39 = bitcast i8* %38 to %struct.xpvlv*
  %xlv_targ23 = getelementptr inbounds %struct.xpvlv, %struct.xpvlv* %39, i32 0, i32 9
  store %struct.sv* %36, %struct.sv** %xlv_targ23, align 8
  br label %if.end.24

if.end.24:                                        ; preds = %land.end, %if.end
  %40 = load %struct.sv*, %struct.sv** %targ, align 8
  %41 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr25 = getelementptr inbounds %struct.sv*, %struct.sv** %41, i32 1
  store %struct.sv** %incdec.ptr25, %struct.sv*** %sp, align 8
  store %struct.sv* %40, %struct.sv** %incdec.ptr25, align 8
  %42 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %42, %struct.sv*** @PL_stack_sp, align 8
  %43 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %43, i32 0, i32 0
  %44 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %44, %struct.op** %retval
  br label %return

if.else:                                          ; preds = %land.lhs.true, %lor.lhs.false
  %45 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags26 = getelementptr inbounds %struct.sv, %struct.sv* %45, i32 0, i32 2
  %46 = load i32, i32* %sv_flags26, align 4
  %and27 = and i32 %46, 255
  %cmp28 = icmp uge i32 %and27, 7
  br i1 %cmp28, label %land.lhs.true.30, label %if.end.61

land.lhs.true.30:                                 ; preds = %if.else
  %47 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any31 = getelementptr inbounds %struct.sv, %struct.sv* %47, i32 0, i32 0
  %48 = load i8*, i8** %sv_any31, align 8
  %49 = bitcast i8* %48 to %struct.xpvmg*
  %xmg_magic = getelementptr inbounds %struct.xpvmg, %struct.xpvmg* %49, i32 0, i32 5
  %50 = load %struct.magic*, %struct.magic** %xmg_magic, align 8
  %tobool32 = icmp ne %struct.magic* %50, null
  br i1 %tobool32, label %if.then.33, label %if.end.61

if.then.33:                                       ; preds = %land.lhs.true.30
  %51 = load %struct.sv*, %struct.sv** %sv, align 8
  %call34 = call %struct.magic* @Perl_mg_find(%struct.sv* %51, i32 103)
  store %struct.magic* %call34, %struct.magic** %mg, align 8
  %52 = load %struct.magic*, %struct.magic** %mg, align 8
  %tobool35 = icmp ne %struct.magic* %52, null
  br i1 %tobool35, label %land.lhs.true.36, label %if.end.60

land.lhs.true.36:                                 ; preds = %if.then.33
  %53 = load %struct.magic*, %struct.magic** %mg, align 8
  %mg_len = getelementptr inbounds %struct.magic, %struct.magic* %53, i32 0, i32 7
  %54 = load i32, i32* %mg_len, align 4
  %cmp37 = icmp sge i32 %54, 0
  br i1 %cmp37, label %if.then.39, label %if.end.60

if.then.39:                                       ; preds = %land.lhs.true.36
  %55 = load %struct.magic*, %struct.magic** %mg, align 8
  %mg_len40 = getelementptr inbounds %struct.magic, %struct.magic* %55, i32 0, i32 7
  %56 = load i32, i32* %mg_len40, align 4
  store i32 %56, i32* %i, align 4
  %57 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags41 = getelementptr inbounds %struct.sv, %struct.sv* %57, i32 0, i32 2
  %58 = load i32, i32* %sv_flags41, align 4
  %and42 = and i32 %58, 536870912
  %tobool43 = icmp ne i32 %and42, 0
  br i1 %tobool43, label %land.lhs.true.44, label %if.end.50

land.lhs.true.44:                                 ; preds = %if.then.39
  %59 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %op_private45 = getelementptr inbounds %struct.cop, %struct.cop* %59, i32 0, i32 7
  %60 = load i8, i8* %op_private45, align 1
  %conv46 = zext i8 %60 to i32
  %and47 = and i32 %conv46, 8
  %tobool48 = icmp ne i32 %and47, 0
  br i1 %tobool48, label %if.end.50, label %if.then.49

if.then.49:                                       ; preds = %land.lhs.true.44
  %61 = load %struct.sv*, %struct.sv** %sv, align 8
  call void @Perl_sv_pos_b2u(%struct.sv* %61, i32* %i)
  br label %if.end.50

if.end.50:                                        ; preds = %if.then.49, %land.lhs.true.44, %if.then.39
  %62 = load %struct.sv*, %struct.sv** %targ, align 8
  %63 = load i32, i32* %i, align 4
  %64 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_arybase = getelementptr inbounds %struct.cop, %struct.cop* %64, i32 0, i32 12
  %65 = load i32, i32* %cop_arybase, align 4
  %add = add nsw i32 %63, %65
  %conv51 = sext i32 %add to i64
  call void @Perl_sv_setiv(%struct.sv* %62, i64 %conv51)
  %66 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags52 = getelementptr inbounds %struct.sv, %struct.sv* %66, i32 0, i32 2
  %67 = load i32, i32* %sv_flags52, align 4
  %and53 = and i32 %67, 16384
  %tobool54 = icmp ne i32 %and53, 0
  br i1 %tobool54, label %if.then.55, label %if.end.57

if.then.55:                                       ; preds = %if.end.50
  %68 = load %struct.sv*, %struct.sv** %targ, align 8
  %call56 = call i32 @Perl_mg_set(%struct.sv* %68)
  br label %if.end.57

if.end.57:                                        ; preds = %if.then.55, %if.end.50
  %69 = load %struct.sv*, %struct.sv** %targ, align 8
  %70 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr58 = getelementptr inbounds %struct.sv*, %struct.sv** %70, i32 1
  store %struct.sv** %incdec.ptr58, %struct.sv*** %sp, align 8
  store %struct.sv* %69, %struct.sv** %incdec.ptr58, align 8
  store %struct.sv* %69, %struct.sv** %tmp
  %71 = load %struct.sv*, %struct.sv** %tmp
  %72 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %72, %struct.sv*** @PL_stack_sp, align 8
  %73 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next59 = getelementptr inbounds %struct.op, %struct.op* %73, i32 0, i32 0
  %74 = load %struct.op*, %struct.op** %op_next59, align 8
  store %struct.op* %74, %struct.op** %retval
  br label %return

if.end.60:                                        ; preds = %land.lhs.true.36, %if.then.33
  br label %if.end.61

if.end.61:                                        ; preds = %if.end.60, %land.lhs.true.30, %if.else
  %75 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr62 = getelementptr inbounds %struct.sv*, %struct.sv** %75, i32 1
  store %struct.sv** %incdec.ptr62, %struct.sv*** %sp, align 8
  store %struct.sv* @PL_sv_undef, %struct.sv** %incdec.ptr62, align 8
  %76 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %76, %struct.sv*** @PL_stack_sp, align 8
  %77 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next63 = getelementptr inbounds %struct.op, %struct.op* %77, i32 0, i32 0
  %78 = load %struct.op*, %struct.op** %op_next63, align 8
  store %struct.op* %78, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.61, %if.end.57, %if.end.24
  %79 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %79
}

declare void @Perl_sv_free(%struct.sv*) #1

declare %struct.magic* @Perl_mg_find(%struct.sv*, i32) #1

declare void @Perl_sv_pos_b2u(%struct.sv*, i32*) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_rv2cv() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %gv = alloca %struct.gv*, align 8
  %stash = alloca %struct.hv*, align 8
  %cv = alloca %struct.cv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.sv**, %struct.sv*** %sp, align 8
  %2 = load %struct.sv*, %struct.sv** %1, align 8
  %3 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %3, i32 0, i32 6
  %4 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %4 to i32
  %and = and i32 %conv, 128
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  %call = call %struct.cv* @Perl_sv_2cv(%struct.sv* %2, %struct.hv** %stash, %struct.gv** %gv, i32 %lnot.ext)
  store %struct.cv* %call, %struct.cv** %cv, align 8
  %5 = load %struct.cv*, %struct.cv** %cv, align 8
  %tobool1 = icmp ne %struct.cv* %5, null
  br i1 %tobool1, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %6 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any = getelementptr inbounds %struct.cv, %struct.cv* %6, i32 0, i32 0
  %7 = load %struct.xpvcv*, %struct.xpvcv** %sv_any, align 8
  %xcv_flags = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %7, i32 0, i32 17
  %8 = load i16, i16* %xcv_flags, align 2
  %conv2 = zext i16 %8 to i32
  %and3 = and i32 %conv2, 1
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %if.then.5, label %if.end

if.then.5:                                        ; preds = %if.then
  %9 = load %struct.cv*, %struct.cv** %cv, align 8
  %call6 = call %struct.cv* @Perl_cv_clone(%struct.cv* %9)
  %10 = bitcast %struct.cv* %call6 to %struct.sv*
  %call7 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %10)
  %11 = bitcast %struct.sv* %call7 to %struct.cv*
  store %struct.cv* %11, %struct.cv** %cv, align 8
  br label %if.end

if.end:                                           ; preds = %if.then.5, %if.then
  %12 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %12, i32 0, i32 7
  %13 = load i8, i8* %op_private, align 1
  %conv8 = zext i8 %13 to i32
  %and9 = and i32 %conv8, 128
  %tobool10 = icmp ne i32 %and9, 0
  br i1 %tobool10, label %if.then.11, label %if.end.34

if.then.11:                                       ; preds = %if.end
  %14 = load %struct.gv*, %struct.gv** %gv, align 8
  %tobool12 = icmp ne %struct.gv* %14, null
  br i1 %tobool12, label %land.lhs.true, label %if.end.25

land.lhs.true:                                    ; preds = %if.then.11
  %15 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any13 = getelementptr inbounds %struct.gv, %struct.gv* %15, i32 0, i32 0
  %16 = load %struct.xpvgv*, %struct.xpvgv** %sv_any13, align 8
  %xgv_gp = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %16, i32 0, i32 7
  %17 = load %struct.gp*, %struct.gp** %xgv_gp, align 8
  %gp_cv = getelementptr inbounds %struct.gp, %struct.gp* %17, i32 0, i32 7
  %18 = load %struct.cv*, %struct.cv** %gp_cv, align 8
  %19 = load %struct.cv*, %struct.cv** %cv, align 8
  %cmp = icmp eq %struct.cv* %18, %19
  br i1 %cmp, label %land.lhs.true.15, label %if.end.25

land.lhs.true.15:                                 ; preds = %land.lhs.true
  %20 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any16 = getelementptr inbounds %struct.gv, %struct.gv* %20, i32 0, i32 0
  %21 = load %struct.xpvgv*, %struct.xpvgv** %sv_any16, align 8
  %xgv_stash = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %21, i32 0, i32 10
  %22 = load %struct.hv*, %struct.hv** %xgv_stash, align 8
  %23 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any17 = getelementptr inbounds %struct.gv, %struct.gv* %23, i32 0, i32 0
  %24 = load %struct.xpvgv*, %struct.xpvgv** %sv_any17, align 8
  %xgv_name = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %24, i32 0, i32 8
  %25 = load i8*, i8** %xgv_name, align 8
  %26 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any18 = getelementptr inbounds %struct.gv, %struct.gv* %26, i32 0, i32 0
  %27 = load %struct.xpvgv*, %struct.xpvgv** %sv_any18, align 8
  %xgv_namelen = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %27, i32 0, i32 9
  %28 = load i64, i64* %xgv_namelen, align 8
  %call19 = call %struct.gv* @Perl_gv_autoload4(%struct.hv* %22, i8* %25, i64 %28, i32 0)
  store %struct.gv* %call19, %struct.gv** %gv, align 8
  %tobool20 = icmp ne %struct.gv* %call19, null
  br i1 %tobool20, label %if.then.21, label %if.end.25

if.then.21:                                       ; preds = %land.lhs.true.15
  %29 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any22 = getelementptr inbounds %struct.gv, %struct.gv* %29, i32 0, i32 0
  %30 = load %struct.xpvgv*, %struct.xpvgv** %sv_any22, align 8
  %xgv_gp23 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %30, i32 0, i32 7
  %31 = load %struct.gp*, %struct.gp** %xgv_gp23, align 8
  %gp_cv24 = getelementptr inbounds %struct.gp, %struct.gp* %31, i32 0, i32 7
  %32 = load %struct.cv*, %struct.cv** %gp_cv24, align 8
  store %struct.cv* %32, %struct.cv** %cv, align 8
  br label %if.end.25

if.end.25:                                        ; preds = %if.then.21, %land.lhs.true.15, %land.lhs.true, %if.then.11
  %33 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any26 = getelementptr inbounds %struct.cv, %struct.cv* %33, i32 0, i32 0
  %34 = load %struct.xpvcv*, %struct.xpvcv** %sv_any26, align 8
  %xcv_flags27 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %34, i32 0, i32 17
  %35 = load i16, i16* %xcv_flags27, align 2
  %conv28 = zext i16 %35 to i32
  %and29 = and i32 %conv28, 256
  %tobool30 = icmp ne i32 %and29, 0
  br i1 %tobool30, label %if.end.33, label %if.then.31

if.then.31:                                       ; preds = %if.end.25
  %call32 = call %struct.op* (i8*, ...) @Perl_die(i8* getelementptr inbounds ([40 x i8], [40 x i8]* @.str.9, i32 0, i32 0))
  store %struct.op* %call32, %struct.op** %retval
  br label %return

if.end.33:                                        ; preds = %if.end.25
  br label %if.end.34

if.end.34:                                        ; preds = %if.end.33, %if.end
  br label %if.end.35

if.else:                                          ; preds = %entry
  store %struct.cv* bitcast (%struct.sv* @PL_sv_undef to %struct.cv*), %struct.cv** %cv, align 8
  br label %if.end.35

if.end.35:                                        ; preds = %if.else, %if.end.34
  %36 = load %struct.cv*, %struct.cv** %cv, align 8
  %37 = bitcast %struct.cv* %36 to %struct.sv*
  %38 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %37, %struct.sv** %38, align 8
  %39 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %39, %struct.sv*** @PL_stack_sp, align 8
  %40 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %40, i32 0, i32 0
  %41 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %41, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.35, %if.then.31
  %42 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %42
}

declare %struct.cv* @Perl_sv_2cv(%struct.sv*, %struct.hv**, %struct.gv**, i32) #1

declare %struct.sv* @Perl_sv_2mortal(%struct.sv*) #1

declare %struct.cv* @Perl_cv_clone(%struct.cv*) #1

declare %struct.gv* @Perl_gv_autoload4(%struct.hv*, i8*, i64, i32) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_prototype() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %cv = alloca %struct.cv*, align 8
  %stash = alloca %struct.hv*, align 8
  %gv = alloca %struct.gv*, align 8
  %ret = alloca %struct.sv*, align 8
  %s = alloca i8*, align 8
  %code = alloca i32, align 4
  %i = alloca i32, align 4
  %n = alloca i32, align 4
  %seen_question = alloca i32, align 4
  %oa = alloca i32, align 4
  %str = alloca [14 x i8], align 1
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  store %struct.sv* @PL_sv_undef, %struct.sv** %ret, align 8
  %1 = load %struct.sv**, %struct.sv*** %sp, align 8
  %2 = load %struct.sv*, %struct.sv** %1, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %2, i32 0, i32 2
  %3 = load i32, i32* %sv_flags, align 4
  %and = and i32 %3, 262144
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end.91

land.lhs.true:                                    ; preds = %entry
  %4 = load %struct.sv**, %struct.sv*** %sp, align 8
  %5 = load %struct.sv*, %struct.sv** %4, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %5, i32 0, i32 0
  %6 = load i8*, i8** %sv_any, align 8
  %7 = bitcast i8* %6 to %struct.xpv*
  %xpv_cur = getelementptr inbounds %struct.xpv, %struct.xpv* %7, i32 0, i32 1
  %8 = load i64, i64* %xpv_cur, align 8
  %cmp = icmp uge i64 %8, 7
  br i1 %cmp, label %if.then, label %if.end.91

if.then:                                          ; preds = %land.lhs.true
  %9 = load %struct.sv**, %struct.sv*** %sp, align 8
  %10 = load %struct.sv*, %struct.sv** %9, align 8
  %sv_any1 = getelementptr inbounds %struct.sv, %struct.sv* %10, i32 0, i32 0
  %11 = load i8*, i8** %sv_any1, align 8
  %12 = bitcast i8* %11 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %12, i32 0, i32 0
  %13 = load i8*, i8** %xpv_pv, align 8
  store i8* %13, i8** %s, align 8
  %14 = load i8*, i8** %s, align 8
  %call = call i32 @strncmp(i8* %14, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.10, i32 0, i32 0), i64 6)
  %tobool2 = icmp ne i32 %call, 0
  br i1 %tobool2, label %if.end.90, label %if.then.3

if.then.3:                                        ; preds = %if.then
  %15 = load i8*, i8** %s, align 8
  %add.ptr = getelementptr inbounds i8, i8* %15, i64 6
  %16 = load %struct.sv**, %struct.sv*** %sp, align 8
  %17 = load %struct.sv*, %struct.sv** %16, align 8
  %sv_any4 = getelementptr inbounds %struct.sv, %struct.sv* %17, i32 0, i32 0
  %18 = load i8*, i8** %sv_any4, align 8
  %19 = bitcast i8* %18 to %struct.xpv*
  %xpv_cur5 = getelementptr inbounds %struct.xpv, %struct.xpv* %19, i32 0, i32 1
  %20 = load i64, i64* %xpv_cur5, align 8
  %sub = sub i64 %20, 6
  %conv = trunc i64 %sub to i32
  %call6 = call i32 @Perl_keyword(i8* %add.ptr, i32 %conv)
  store i32 %call6, i32* %code, align 4
  %21 = load i32, i32* %code, align 4
  %cmp7 = icmp slt i32 %21, 0
  br i1 %cmp7, label %if.then.9, label %if.else.83

if.then.9:                                        ; preds = %if.then.3
  store i32 0, i32* %i, align 4
  store i32 0, i32* %n, align 4
  store i32 0, i32* %seen_question, align 4
  %22 = load i32, i32* %code, align 4
  %cmp10 = icmp eq i32 %22, -25
  br i1 %cmp10, label %if.then.14, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then.9
  %23 = load i32, i32* %code, align 4
  %cmp12 = icmp eq i32 %23, -24
  br i1 %cmp12, label %if.then.14, label %if.end

if.then.14:                                       ; preds = %lor.lhs.false, %if.then.9
  br label %set

if.end:                                           ; preds = %lor.lhs.false
  br label %while.cond

while.cond:                                       ; preds = %if.end.27, %if.end
  %24 = load i32, i32* %i, align 4
  %cmp15 = icmp slt i32 %24, 352
  br i1 %cmp15, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %25 = load i8*, i8** %s, align 8
  %add.ptr17 = getelementptr inbounds i8, i8* %25, i64 6
  %26 = load i32, i32* %i, align 4
  %idxprom = sext i32 %26 to i64
  %arrayidx = getelementptr inbounds [0 x i8*], [0 x i8*]* @PL_op_name, i32 0, i64 %idxprom
  %27 = load i8*, i8** %arrayidx, align 8
  %call18 = call i32 @strcmp(i8* %add.ptr17, i8* %27)
  %tobool19 = icmp ne i32 %call18, 0
  br i1 %tobool19, label %lor.lhs.false.20, label %if.then.26

lor.lhs.false.20:                                 ; preds = %while.body
  %28 = load i8*, i8** %s, align 8
  %add.ptr21 = getelementptr inbounds i8, i8* %28, i64 6
  %29 = load i32, i32* %i, align 4
  %idxprom22 = sext i32 %29 to i64
  %arrayidx23 = getelementptr inbounds [0 x i8*], [0 x i8*]* @PL_op_desc, i32 0, i64 %idxprom22
  %30 = load i8*, i8** %arrayidx23, align 8
  %call24 = call i32 @strcmp(i8* %add.ptr21, i8* %30)
  %tobool25 = icmp ne i32 %call24, 0
  br i1 %tobool25, label %if.end.27, label %if.then.26

if.then.26:                                       ; preds = %lor.lhs.false.20, %while.body
  br label %found

if.end.27:                                        ; preds = %lor.lhs.false.20
  %31 = load i32, i32* %i, align 4
  %inc = add nsw i32 %31, 1
  store i32 %inc, i32* %i, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  br label %nonesuch

found:                                            ; preds = %if.then.26
  %32 = load i32, i32* %i, align 4
  %idxprom28 = sext i32 %32 to i64
  %arrayidx29 = getelementptr inbounds [0 x i32], [0 x i32]* @PL_opargs, i32 0, i64 %idxprom28
  %33 = load i32, i32* %arrayidx29, align 4
  %shr = lshr i32 %33, 13
  store i32 %shr, i32* %oa, align 4
  br label %while.cond.30

while.cond.30:                                    ; preds = %if.end.67, %found
  %34 = load i32, i32* %oa, align 4
  %tobool31 = icmp ne i32 %34, 0
  br i1 %tobool31, label %while.body.32, label %while.end.75

while.body.32:                                    ; preds = %while.cond.30
  %35 = load i32, i32* %oa, align 4
  %and33 = and i32 %35, 8
  %tobool34 = icmp ne i32 %and33, 0
  br i1 %tobool34, label %land.lhs.true.35, label %if.else

land.lhs.true.35:                                 ; preds = %while.body.32
  %36 = load i32, i32* %seen_question, align 4
  %tobool36 = icmp ne i32 %36, 0
  br i1 %tobool36, label %if.else, label %if.then.37

if.then.37:                                       ; preds = %land.lhs.true.35
  store i32 1, i32* %seen_question, align 4
  %37 = load i32, i32* %n, align 4
  %inc38 = add nsw i32 %37, 1
  store i32 %inc38, i32* %n, align 4
  %idxprom39 = sext i32 %37 to i64
  %arrayidx40 = getelementptr inbounds [14 x i8], [14 x i8]* %str, i32 0, i64 %idxprom39
  store i8 59, i8* %arrayidx40, align 1
  br label %if.end.51

if.else:                                          ; preds = %land.lhs.true.35, %while.body.32
  %38 = load i32, i32* %n, align 4
  %tobool41 = icmp ne i32 %38, 0
  br i1 %tobool41, label %land.lhs.true.42, label %if.end.50

land.lhs.true.42:                                 ; preds = %if.else
  %arrayidx43 = getelementptr inbounds [14 x i8], [14 x i8]* %str, i32 0, i64 0
  %39 = load i8, i8* %arrayidx43, align 1
  %conv44 = sext i8 %39 to i32
  %cmp45 = icmp eq i32 %conv44, 59
  br i1 %cmp45, label %land.lhs.true.47, label %if.end.50

land.lhs.true.47:                                 ; preds = %land.lhs.true.42
  %40 = load i32, i32* %seen_question, align 4
  %tobool48 = icmp ne i32 %40, 0
  br i1 %tobool48, label %if.then.49, label %if.end.50

if.then.49:                                       ; preds = %land.lhs.true.47
  br label %set

if.end.50:                                        ; preds = %land.lhs.true.47, %land.lhs.true.42, %if.else
  br label %if.end.51

if.end.51:                                        ; preds = %if.end.50, %if.then.37
  %41 = load i32, i32* %oa, align 4
  %and52 = and i32 %41, 7
  %cmp53 = icmp sge i32 %and52, 3
  br i1 %cmp53, label %land.lhs.true.55, label %if.end.67

land.lhs.true.55:                                 ; preds = %if.end.51
  %42 = load i32, i32* %oa, align 4
  %and56 = and i32 %42, 7
  %cmp57 = icmp sle i32 %and56, 7
  br i1 %cmp57, label %land.lhs.true.59, label %if.end.67

land.lhs.true.59:                                 ; preds = %land.lhs.true.55
  %43 = load i32, i32* %oa, align 4
  %and60 = and i32 %43, 7
  %cmp61 = icmp ne i32 %and60, 6
  br i1 %cmp61, label %if.then.63, label %if.end.67

if.then.63:                                       ; preds = %land.lhs.true.59
  %44 = load i32, i32* %n, align 4
  %inc64 = add nsw i32 %44, 1
  store i32 %inc64, i32* %n, align 4
  %idxprom65 = sext i32 %44 to i64
  %arrayidx66 = getelementptr inbounds [14 x i8], [14 x i8]* %str, i32 0, i64 %idxprom65
  store i8 92, i8* %arrayidx66, align 1
  br label %if.end.67

if.end.67:                                        ; preds = %if.then.63, %land.lhs.true.59, %land.lhs.true.55, %if.end.51
  %45 = load i32, i32* %oa, align 4
  %and68 = and i32 %45, 7
  %idxprom69 = sext i32 %and68 to i64
  %arrayidx70 = getelementptr inbounds [9 x i8], [9 x i8]* @.str.11, i32 0, i64 %idxprom69
  %46 = load i8, i8* %arrayidx70, align 1
  %47 = load i32, i32* %n, align 4
  %inc71 = add nsw i32 %47, 1
  store i32 %inc71, i32* %n, align 4
  %idxprom72 = sext i32 %47 to i64
  %arrayidx73 = getelementptr inbounds [14 x i8], [14 x i8]* %str, i32 0, i64 %idxprom72
  store i8 %46, i8* %arrayidx73, align 1
  %48 = load i32, i32* %oa, align 4
  %shr74 = ashr i32 %48, 4
  store i32 %shr74, i32* %oa, align 4
  br label %while.cond.30

while.end.75:                                     ; preds = %while.cond.30
  %49 = load i32, i32* %n, align 4
  %inc76 = add nsw i32 %49, 1
  store i32 %inc76, i32* %n, align 4
  %idxprom77 = sext i32 %49 to i64
  %arrayidx78 = getelementptr inbounds [14 x i8], [14 x i8]* %str, i32 0, i64 %idxprom77
  store i8 0, i8* %arrayidx78, align 1
  %arraydecay = getelementptr inbounds [14 x i8], [14 x i8]* %str, i32 0, i32 0
  %50 = load i32, i32* %n, align 4
  %sub79 = sub nsw i32 %50, 1
  %conv80 = sext i32 %sub79 to i64
  %call81 = call %struct.sv* @Perl_newSVpvn(i8* %arraydecay, i64 %conv80)
  %call82 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call81)
  store %struct.sv* %call82, %struct.sv** %ret, align 8
  br label %if.end.89

if.else.83:                                       ; preds = %if.then.3
  %51 = load i32, i32* %code, align 4
  %tobool84 = icmp ne i32 %51, 0
  br i1 %tobool84, label %if.then.85, label %if.else.86

if.then.85:                                       ; preds = %if.else.83
  br label %set

if.else.86:                                       ; preds = %if.else.83
  br label %nonesuch

nonesuch:                                         ; preds = %if.else.86, %while.end
  %52 = load i8*, i8** %s, align 8
  %add.ptr87 = getelementptr inbounds i8, i8* %52, i64 6
  %call88 = call %struct.op* (i8*, ...) @Perl_die(i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.12, i32 0, i32 0), i8* %add.ptr87)
  store %struct.op* %call88, %struct.op** %retval
  br label %return

if.end.89:                                        ; preds = %while.end.75
  br label %if.end.90

if.end.90:                                        ; preds = %if.end.89, %if.then
  br label %if.end.91

if.end.91:                                        ; preds = %if.end.90, %land.lhs.true, %entry
  %53 = load %struct.sv**, %struct.sv*** %sp, align 8
  %54 = load %struct.sv*, %struct.sv** %53, align 8
  %call92 = call %struct.cv* @Perl_sv_2cv(%struct.sv* %54, %struct.hv** %stash, %struct.gv** %gv, i32 0)
  store %struct.cv* %call92, %struct.cv** %cv, align 8
  %55 = load %struct.cv*, %struct.cv** %cv, align 8
  %tobool93 = icmp ne %struct.cv* %55, null
  br i1 %tobool93, label %land.lhs.true.94, label %if.end.105

land.lhs.true.94:                                 ; preds = %if.end.91
  %56 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_flags95 = getelementptr inbounds %struct.cv, %struct.cv* %56, i32 0, i32 2
  %57 = load i32, i32* %sv_flags95, align 4
  %and96 = and i32 %57, 262144
  %tobool97 = icmp ne i32 %and96, 0
  br i1 %tobool97, label %if.then.98, label %if.end.105

if.then.98:                                       ; preds = %land.lhs.true.94
  %58 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any99 = getelementptr inbounds %struct.cv, %struct.cv* %58, i32 0, i32 0
  %59 = load %struct.xpvcv*, %struct.xpvcv** %sv_any99, align 8
  %60 = bitcast %struct.xpvcv* %59 to %struct.xpv*
  %xpv_pv100 = getelementptr inbounds %struct.xpv, %struct.xpv* %60, i32 0, i32 0
  %61 = load i8*, i8** %xpv_pv100, align 8
  %62 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any101 = getelementptr inbounds %struct.cv, %struct.cv* %62, i32 0, i32 0
  %63 = load %struct.xpvcv*, %struct.xpvcv** %sv_any101, align 8
  %64 = bitcast %struct.xpvcv* %63 to %struct.xpv*
  %xpv_cur102 = getelementptr inbounds %struct.xpv, %struct.xpv* %64, i32 0, i32 1
  %65 = load i64, i64* %xpv_cur102, align 8
  %call103 = call %struct.sv* @Perl_newSVpvn(i8* %61, i64 %65)
  %call104 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call103)
  store %struct.sv* %call104, %struct.sv** %ret, align 8
  br label %if.end.105

if.end.105:                                       ; preds = %if.then.98, %land.lhs.true.94, %if.end.91
  br label %set

set:                                              ; preds = %if.end.105, %if.then.85, %if.then.49, %if.then.14
  %66 = load %struct.sv*, %struct.sv** %ret, align 8
  %67 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %66, %struct.sv** %67, align 8
  %68 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %68, %struct.sv*** @PL_stack_sp, align 8
  %69 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %69, i32 0, i32 0
  %70 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %70, %struct.op** %retval
  br label %return

return:                                           ; preds = %set, %nonesuch
  %71 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %71
}

declare i32 @strncmp(i8*, i8*, i64) #1

declare i32 @Perl_keyword(i8*, i32) #1

declare i32 @strcmp(i8*, i8*) #1

declare %struct.sv* @Perl_newSVpvn(i8*, i64) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_anoncode() #0 {
entry:
  %sp = alloca %struct.sv**, align 8
  %cv = alloca %struct.cv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 3
  %2 = load i64, i64* %op_targ, align 8
  %3 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 %2
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  %5 = bitcast %struct.sv* %4 to %struct.cv*
  store %struct.cv* %5, %struct.cv** %cv, align 8
  %6 = load %struct.cv*, %struct.cv** %cv, align 8
  %sv_any = getelementptr inbounds %struct.cv, %struct.cv* %6, i32 0, i32 0
  %7 = load %struct.xpvcv*, %struct.xpvcv** %sv_any, align 8
  %xcv_flags = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %7, i32 0, i32 17
  %8 = load i16, i16* %xcv_flags, align 2
  %conv = zext i16 %8 to i32
  %and = and i32 %conv, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %9 = load %struct.cv*, %struct.cv** %cv, align 8
  %call = call %struct.cv* @Perl_cv_clone(%struct.cv* %9)
  %10 = bitcast %struct.cv* %call to %struct.sv*
  %call1 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %10)
  %11 = bitcast %struct.sv* %call1 to %struct.cv*
  store %struct.cv* %11, %struct.cv** %cv, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %12 = load %struct.sv**, %struct.sv*** @PL_stack_max, align 8
  %13 = load %struct.sv**, %struct.sv*** %sp, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %12 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %13 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %cmp = icmp slt i64 %sub.ptr.div, 1
  br i1 %cmp, label %if.then.3, label %if.end.5

if.then.3:                                        ; preds = %if.end
  %14 = load %struct.sv**, %struct.sv*** %sp, align 8
  %15 = load %struct.sv**, %struct.sv*** %sp, align 8
  %call4 = call %struct.sv** @Perl_stack_grow(%struct.sv** %14, %struct.sv** %15, i32 1)
  store %struct.sv** %call4, %struct.sv*** %sp, align 8
  br label %if.end.5

if.end.5:                                         ; preds = %if.then.3, %if.end
  %16 = load %struct.cv*, %struct.cv** %cv, align 8
  %17 = bitcast %struct.cv* %16 to %struct.sv*
  %18 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %18, i32 1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  store %struct.sv* %17, %struct.sv** %incdec.ptr, align 8
  %19 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %19, %struct.sv*** @PL_stack_sp, align 8
  %20 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %20, i32 0, i32 0
  %21 = load %struct.op*, %struct.op** %op_next, align 8
  ret %struct.op* %21
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_srefgen() #0 {
entry:
  %sp = alloca %struct.sv**, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.sv**, %struct.sv*** %sp, align 8
  %2 = load %struct.sv*, %struct.sv** %1, align 8
  %call = call %struct.sv* @S_refto(%struct.sv* %2)
  %3 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %call, %struct.sv** %3, align 8
  %4 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %4, %struct.sv*** @PL_stack_sp, align 8
  %5 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %5, i32 0, i32 0
  %6 = load %struct.op*, %struct.op** %op_next, align 8
  ret %struct.op* %6
}

; Function Attrs: nounwind uwtable
define internal %struct.sv* @S_refto(%struct.sv* %sv) #0 {
entry:
  %sv.addr = alloca %struct.sv*, align 8
  %rv = alloca %struct.sv*, align 8
  store %struct.sv* %sv, %struct.sv** %sv.addr, align 8
  %0 = load %struct.sv*, %struct.sv** %sv.addr, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %0, i32 0, i32 2
  %1 = load i32, i32* %sv_flags, align 4
  %and = and i32 %1, 255
  %cmp = icmp eq i32 %and, 9
  br i1 %cmp, label %land.lhs.true, label %if.else.11

land.lhs.true:                                    ; preds = %entry
  %2 = load %struct.sv*, %struct.sv** %sv.addr, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %2, i32 0, i32 0
  %3 = load i8*, i8** %sv_any, align 8
  %4 = bitcast i8* %3 to %struct.xpvlv*
  %xlv_type = getelementptr inbounds %struct.xpvlv, %struct.xpvlv* %4, i32 0, i32 10
  %5 = load i8, i8* %xlv_type, align 1
  %conv = sext i8 %5 to i32
  %cmp1 = icmp eq i32 %conv, 121
  br i1 %cmp1, label %if.then, label %if.else.11

if.then:                                          ; preds = %land.lhs.true
  %6 = load %struct.sv*, %struct.sv** %sv.addr, align 8
  %sv_any3 = getelementptr inbounds %struct.sv, %struct.sv* %6, i32 0, i32 0
  %7 = load i8*, i8** %sv_any3, align 8
  %8 = bitcast i8* %7 to %struct.xpvlv*
  %xlv_targlen = getelementptr inbounds %struct.xpvlv, %struct.xpvlv* %8, i32 0, i32 8
  %9 = load i64, i64* %xlv_targlen, align 8
  %tobool = icmp ne i64 %9, 0
  br i1 %tobool, label %if.then.4, label %if.end

if.then.4:                                        ; preds = %if.then
  %10 = load %struct.sv*, %struct.sv** %sv.addr, align 8
  call void @Perl_vivify_defelem(%struct.sv* %10)
  br label %if.end

if.end:                                           ; preds = %if.then.4, %if.then
  %11 = load %struct.sv*, %struct.sv** %sv.addr, align 8
  %sv_any5 = getelementptr inbounds %struct.sv, %struct.sv* %11, i32 0, i32 0
  %12 = load i8*, i8** %sv_any5, align 8
  %13 = bitcast i8* %12 to %struct.xpvlv*
  %xlv_targ = getelementptr inbounds %struct.xpvlv, %struct.xpvlv* %13, i32 0, i32 9
  %14 = load %struct.sv*, %struct.sv** %xlv_targ, align 8
  store %struct.sv* %14, %struct.sv** %sv.addr, align 8
  %tobool6 = icmp ne %struct.sv* %14, null
  br i1 %tobool6, label %if.else, label %if.then.7

if.then.7:                                        ; preds = %if.end
  store %struct.sv* @PL_sv_undef, %struct.sv** %sv.addr, align 8
  br label %if.end.10

if.else:                                          ; preds = %if.end
  %15 = load %struct.sv*, %struct.sv** %sv.addr, align 8
  store %struct.sv* %15, %struct.sv** @PL_Sv, align 8
  %16 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %tobool8 = icmp ne %struct.sv* %16, null
  br i1 %tobool8, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.else
  %17 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_refcnt = getelementptr inbounds %struct.sv, %struct.sv* %17, i32 0, i32 1
  %18 = load i32, i32* %sv_refcnt, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %sv_refcnt, align 4
  %tobool9 = icmp ne i32 %inc, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.else
  %19 = phi i1 [ false, %if.else ], [ %tobool9, %land.rhs ]
  %land.ext = zext i1 %19 to i32
  %20 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  br label %if.end.10

if.end.10:                                        ; preds = %land.end, %if.then.7
  br label %if.end.55

if.else.11:                                       ; preds = %land.lhs.true, %entry
  %21 = load %struct.sv*, %struct.sv** %sv.addr, align 8
  %sv_flags12 = getelementptr inbounds %struct.sv, %struct.sv* %21, i32 0, i32 2
  %22 = load i32, i32* %sv_flags12, align 4
  %and13 = and i32 %22, 255
  %cmp14 = icmp eq i32 %and13, 10
  br i1 %cmp14, label %if.then.16, label %if.else.38

if.then.16:                                       ; preds = %if.else.11
  %23 = load %struct.sv*, %struct.sv** %sv.addr, align 8
  %24 = bitcast %struct.sv* %23 to %struct.av*
  %sv_any17 = getelementptr inbounds %struct.av, %struct.av* %24, i32 0, i32 0
  %25 = load %struct.xpvav*, %struct.xpvav** %sv_any17, align 8
  %xav_flags = getelementptr inbounds %struct.xpvav, %struct.xpvav* %25, i32 0, i32 9
  %26 = load i8, i8* %xav_flags, align 1
  %conv18 = zext i8 %26 to i32
  %and19 = and i32 %conv18, 1
  %tobool20 = icmp ne i32 %and19, 0
  br i1 %tobool20, label %if.end.28, label %land.lhs.true.21

land.lhs.true.21:                                 ; preds = %if.then.16
  %27 = load %struct.sv*, %struct.sv** %sv.addr, align 8
  %28 = bitcast %struct.sv* %27 to %struct.av*
  %sv_any22 = getelementptr inbounds %struct.av, %struct.av* %28, i32 0, i32 0
  %29 = load %struct.xpvav*, %struct.xpvav** %sv_any22, align 8
  %xav_flags23 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %29, i32 0, i32 9
  %30 = load i8, i8* %xav_flags23, align 1
  %conv24 = zext i8 %30 to i32
  %and25 = and i32 %conv24, 2
  %tobool26 = icmp ne i32 %and25, 0
  br i1 %tobool26, label %if.then.27, label %if.end.28

if.then.27:                                       ; preds = %land.lhs.true.21
  %31 = load %struct.sv*, %struct.sv** %sv.addr, align 8
  %32 = bitcast %struct.sv* %31 to %struct.av*
  call void @Perl_av_reify(%struct.av* %32)
  br label %if.end.28

if.end.28:                                        ; preds = %if.then.27, %land.lhs.true.21, %if.then.16
  %33 = load %struct.sv*, %struct.sv** %sv.addr, align 8
  %sv_flags29 = getelementptr inbounds %struct.sv, %struct.sv* %33, i32 0, i32 2
  %34 = load i32, i32* %sv_flags29, align 4
  %and30 = and i32 %34, -2049
  store i32 %and30, i32* %sv_flags29, align 4
  %35 = load %struct.sv*, %struct.sv** %sv.addr, align 8
  store %struct.sv* %35, %struct.sv** @PL_Sv, align 8
  %36 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %tobool31 = icmp ne %struct.sv* %36, null
  br i1 %tobool31, label %land.rhs.32, label %land.end.36

land.rhs.32:                                      ; preds = %if.end.28
  %37 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_refcnt33 = getelementptr inbounds %struct.sv, %struct.sv* %37, i32 0, i32 1
  %38 = load i32, i32* %sv_refcnt33, align 4
  %inc34 = add i32 %38, 1
  store i32 %inc34, i32* %sv_refcnt33, align 4
  %tobool35 = icmp ne i32 %inc34, 0
  br label %land.end.36

land.end.36:                                      ; preds = %land.rhs.32, %if.end.28
  %39 = phi i1 [ false, %if.end.28 ], [ %tobool35, %land.rhs.32 ]
  %land.ext37 = zext i1 %39 to i32
  %40 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  br label %if.end.54

if.else.38:                                       ; preds = %if.else.11
  %41 = load %struct.sv*, %struct.sv** %sv.addr, align 8
  %sv_flags39 = getelementptr inbounds %struct.sv, %struct.sv* %41, i32 0, i32 2
  %42 = load i32, i32* %sv_flags39, align 4
  %and40 = and i32 %42, 512
  %tobool41 = icmp ne i32 %and40, 0
  br i1 %tobool41, label %if.then.42, label %if.else.43

if.then.42:                                       ; preds = %if.else.38
  %43 = load %struct.sv*, %struct.sv** %sv.addr, align 8
  %call = call %struct.sv* @Perl_newSVsv(%struct.sv* %43)
  store %struct.sv* %call, %struct.sv** %sv.addr, align 8
  br label %if.end.53

if.else.43:                                       ; preds = %if.else.38
  %44 = load %struct.sv*, %struct.sv** %sv.addr, align 8
  %sv_flags44 = getelementptr inbounds %struct.sv, %struct.sv* %44, i32 0, i32 2
  %45 = load i32, i32* %sv_flags44, align 4
  %and45 = and i32 %45, -2049
  store i32 %and45, i32* %sv_flags44, align 4
  %46 = load %struct.sv*, %struct.sv** %sv.addr, align 8
  store %struct.sv* %46, %struct.sv** @PL_Sv, align 8
  %47 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %tobool46 = icmp ne %struct.sv* %47, null
  br i1 %tobool46, label %land.rhs.47, label %land.end.51

land.rhs.47:                                      ; preds = %if.else.43
  %48 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_refcnt48 = getelementptr inbounds %struct.sv, %struct.sv* %48, i32 0, i32 1
  %49 = load i32, i32* %sv_refcnt48, align 4
  %inc49 = add i32 %49, 1
  store i32 %inc49, i32* %sv_refcnt48, align 4
  %tobool50 = icmp ne i32 %inc49, 0
  br label %land.end.51

land.end.51:                                      ; preds = %land.rhs.47, %if.else.43
  %50 = phi i1 [ false, %if.else.43 ], [ %tobool50, %land.rhs.47 ]
  %land.ext52 = zext i1 %50 to i32
  %51 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  br label %if.end.53

if.end.53:                                        ; preds = %land.end.51, %if.then.42
  br label %if.end.54

if.end.54:                                        ; preds = %if.end.53, %land.end.36
  br label %if.end.55

if.end.55:                                        ; preds = %if.end.54, %if.end.10
  %call56 = call %struct.sv* @Perl_sv_newmortal()
  store %struct.sv* %call56, %struct.sv** %rv, align 8
  %52 = load %struct.sv*, %struct.sv** %rv, align 8
  %call57 = call signext i8 @Perl_sv_upgrade(%struct.sv* %52, i32 3)
  %53 = load %struct.sv*, %struct.sv** %sv.addr, align 8
  %54 = load %struct.sv*, %struct.sv** %rv, align 8
  %sv_any58 = getelementptr inbounds %struct.sv, %struct.sv* %54, i32 0, i32 0
  %55 = load i8*, i8** %sv_any58, align 8
  %56 = bitcast i8* %55 to %struct.xrv*
  %xrv_rv = getelementptr inbounds %struct.xrv, %struct.xrv* %56, i32 0, i32 0
  store %struct.sv* %53, %struct.sv** %xrv_rv, align 8
  %57 = load %struct.sv*, %struct.sv** %rv, align 8
  %sv_flags59 = getelementptr inbounds %struct.sv, %struct.sv* %57, i32 0, i32 2
  %58 = load i32, i32* %sv_flags59, align 4
  %or = or i32 %58, 524288
  store i32 %or, i32* %sv_flags59, align 4
  %59 = load %struct.sv*, %struct.sv** %rv, align 8
  ret %struct.sv* %59
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_refgen() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %mark = alloca %struct.sv**, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %2 = load i32*, i32** @PL_markstack_ptr, align 8
  %incdec.ptr = getelementptr inbounds i32, i32* %2, i32 -1
  store i32* %incdec.ptr, i32** @PL_markstack_ptr, align 8
  %3 = load i32, i32* %2, align 4
  %idx.ext = sext i32 %3 to i64
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %1, i64 %idx.ext
  store %struct.sv** %add.ptr, %struct.sv*** %mark, align 8
  %4 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %4, i32 0, i32 6
  %5 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %5 to i32
  %and = and i32 %conv, 3
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %6 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags1 = getelementptr inbounds %struct.op, %struct.op* %6, i32 0, i32 6
  %7 = load i8, i8* %op_flags1, align 1
  %conv2 = zext i8 %7 to i32
  %and3 = and i32 %conv2, 3
  %cmp = icmp eq i32 %and3, 3
  %cond = select i1 %cmp, i32 1, i32 0
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = call i32 @Perl_dowantarray()
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond5 = phi i32 [ %cond, %cond.true ], [ %call, %cond.false ]
  %cmp6 = icmp ne i32 %cond5, 1
  br i1 %cmp6, label %if.then, label %if.end.13

if.then:                                          ; preds = %cond.end
  %8 = load %struct.sv**, %struct.sv*** %mark, align 8
  %incdec.ptr8 = getelementptr inbounds %struct.sv*, %struct.sv** %8, i32 1
  store %struct.sv** %incdec.ptr8, %struct.sv*** %mark, align 8
  %9 = load %struct.sv**, %struct.sv*** %sp, align 8
  %cmp9 = icmp ule %struct.sv** %incdec.ptr8, %9
  br i1 %cmp9, label %if.then.11, label %if.else

if.then.11:                                       ; preds = %if.then
  %10 = load %struct.sv**, %struct.sv*** %sp, align 8
  %11 = load %struct.sv*, %struct.sv** %10, align 8
  %12 = load %struct.sv**, %struct.sv*** %mark, align 8
  store %struct.sv* %11, %struct.sv** %12, align 8
  br label %if.end

if.else:                                          ; preds = %if.then
  %13 = load %struct.sv**, %struct.sv*** %mark, align 8
  store %struct.sv* @PL_sv_undef, %struct.sv** %13, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then.11
  %14 = load %struct.sv**, %struct.sv*** %mark, align 8
  %15 = load %struct.sv*, %struct.sv** %14, align 8
  %call12 = call %struct.sv* @S_refto(%struct.sv* %15)
  %16 = load %struct.sv**, %struct.sv*** %mark, align 8
  store %struct.sv* %call12, %struct.sv** %16, align 8
  %17 = load %struct.sv**, %struct.sv*** %mark, align 8
  store %struct.sv** %17, %struct.sv*** %sp, align 8
  %18 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %18, %struct.sv*** @PL_stack_sp, align 8
  %19 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %19, i32 0, i32 0
  %20 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %20, %struct.op** %retval
  br label %return

if.end.13:                                        ; preds = %cond.end
  %21 = load i32, i32* @PL_tmps_ix, align 4
  %conv14 = sext i32 %21 to i64
  %22 = load %struct.sv**, %struct.sv*** %sp, align 8
  %23 = load %struct.sv**, %struct.sv*** %mark, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %22 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %23 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %add = add nsw i64 %conv14, %sub.ptr.div
  %24 = load i32, i32* @PL_tmps_max, align 4
  %conv15 = sext i32 %24 to i64
  %cmp16 = icmp sge i64 %add, %conv15
  br i1 %cmp16, label %if.then.18, label %if.end.24

if.then.18:                                       ; preds = %if.end.13
  %25 = load %struct.sv**, %struct.sv*** %sp, align 8
  %26 = load %struct.sv**, %struct.sv*** %mark, align 8
  %sub.ptr.lhs.cast19 = ptrtoint %struct.sv** %25 to i64
  %sub.ptr.rhs.cast20 = ptrtoint %struct.sv** %26 to i64
  %sub.ptr.sub21 = sub i64 %sub.ptr.lhs.cast19, %sub.ptr.rhs.cast20
  %sub.ptr.div22 = sdiv exact i64 %sub.ptr.sub21, 8
  %conv23 = trunc i64 %sub.ptr.div22 to i32
  call void @Perl_tmps_grow(i32 %conv23)
  br label %if.end.24

if.end.24:                                        ; preds = %if.then.18, %if.end.13
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end.24
  %27 = load %struct.sv**, %struct.sv*** %mark, align 8
  %incdec.ptr25 = getelementptr inbounds %struct.sv*, %struct.sv** %27, i32 1
  store %struct.sv** %incdec.ptr25, %struct.sv*** %mark, align 8
  %28 = load %struct.sv**, %struct.sv*** %sp, align 8
  %cmp26 = icmp ule %struct.sv** %incdec.ptr25, %28
  br i1 %cmp26, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %29 = load %struct.sv**, %struct.sv*** %mark, align 8
  %30 = load %struct.sv*, %struct.sv** %29, align 8
  %call28 = call %struct.sv* @S_refto(%struct.sv* %30)
  %31 = load %struct.sv**, %struct.sv*** %mark, align 8
  store %struct.sv* %call28, %struct.sv** %31, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %32 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %32, %struct.sv*** @PL_stack_sp, align 8
  %33 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next29 = getelementptr inbounds %struct.op, %struct.op* %33, i32 0, i32 0
  %34 = load %struct.op*, %struct.op** %op_next29, align 8
  store %struct.op* %34, %struct.op** %retval
  br label %return

return:                                           ; preds = %while.end, %if.end
  %35 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %35
}

declare void @Perl_tmps_grow(i32) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_ref() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %sv = alloca %struct.sv*, align 8
  %pv = alloca i8*, align 8
  %tmp = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 3
  %2 = load i64, i64* %op_targ, align 8
  %3 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 %2
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %4, %struct.sv** %targ, align 8
  %5 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %5, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %6 = load %struct.sv*, %struct.sv** %5, align 8
  store %struct.sv* %6, %struct.sv** %sv, align 8
  %7 = load %struct.sv*, %struct.sv** %sv, align 8
  %tobool = icmp ne %struct.sv* %7, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %8 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %8, i32 0, i32 2
  %9 = load i32, i32* %sv_flags, align 4
  %and = and i32 %9, 8192
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %10 = load %struct.sv*, %struct.sv** %sv, align 8
  %call = call i32 @Perl_mg_get(%struct.sv* %10)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %11 = load %struct.sv*, %struct.sv** %sv, align 8
  %tobool2 = icmp ne %struct.sv* %11, null
  br i1 %tobool2, label %lor.lhs.false, label %if.then.6

lor.lhs.false:                                    ; preds = %if.end
  %12 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags3 = getelementptr inbounds %struct.sv, %struct.sv* %12, i32 0, i32 2
  %13 = load i32, i32* %sv_flags3, align 4
  %and4 = and i32 %13, 524288
  %tobool5 = icmp ne i32 %and4, 0
  br i1 %tobool5, label %if.end.8, label %if.then.6

if.then.6:                                        ; preds = %lor.lhs.false, %if.end
  %14 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr7 = getelementptr inbounds %struct.sv*, %struct.sv** %14, i32 1
  store %struct.sv** %incdec.ptr7, %struct.sv*** %sp, align 8
  store %struct.sv* @PL_sv_no, %struct.sv** %incdec.ptr7, align 8
  %15 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %15, %struct.sv*** @PL_stack_sp, align 8
  %16 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %16, i32 0, i32 0
  %17 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %17, %struct.op** %retval
  br label %return

if.end.8:                                         ; preds = %lor.lhs.false
  %18 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %18, i32 0, i32 0
  %19 = load i8*, i8** %sv_any, align 8
  %20 = bitcast i8* %19 to %struct.xrv*
  %xrv_rv = getelementptr inbounds %struct.xrv, %struct.xrv* %20, i32 0, i32 0
  %21 = load %struct.sv*, %struct.sv** %xrv_rv, align 8
  store %struct.sv* %21, %struct.sv** %sv, align 8
  %22 = load %struct.sv*, %struct.sv** %sv, align 8
  %call9 = call i8* @Perl_sv_reftype(%struct.sv* %22, i32 1)
  store i8* %call9, i8** %pv, align 8
  %23 = load %struct.sv*, %struct.sv** %targ, align 8
  %24 = load i8*, i8** %pv, align 8
  %25 = load i8*, i8** %pv, align 8
  %call10 = call i64 @strlen(i8* %25)
  call void @Perl_sv_setpvn(%struct.sv* %23, i8* %24, i64 %call10)
  %26 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags11 = getelementptr inbounds %struct.sv, %struct.sv* %26, i32 0, i32 2
  %27 = load i32, i32* %sv_flags11, align 4
  %and12 = and i32 %27, 16384
  %tobool13 = icmp ne i32 %and12, 0
  br i1 %tobool13, label %if.then.14, label %if.end.16

if.then.14:                                       ; preds = %if.end.8
  %28 = load %struct.sv*, %struct.sv** %targ, align 8
  %call15 = call i32 @Perl_mg_set(%struct.sv* %28)
  br label %if.end.16

if.end.16:                                        ; preds = %if.then.14, %if.end.8
  %29 = load %struct.sv*, %struct.sv** %targ, align 8
  %30 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr17 = getelementptr inbounds %struct.sv*, %struct.sv** %30, i32 1
  store %struct.sv** %incdec.ptr17, %struct.sv*** %sp, align 8
  store %struct.sv* %29, %struct.sv** %incdec.ptr17, align 8
  store %struct.sv* %29, %struct.sv** %tmp
  %31 = load %struct.sv*, %struct.sv** %tmp
  %32 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %32, %struct.sv*** @PL_stack_sp, align 8
  %33 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next18 = getelementptr inbounds %struct.op, %struct.op* %33, i32 0, i32 0
  %34 = load %struct.op*, %struct.op** %op_next18, align 8
  store %struct.op* %34, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.16, %if.then.6
  %35 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %35
}

declare i8* @Perl_sv_reftype(%struct.sv*, i32) #1

declare void @Perl_sv_setpvn(%struct.sv*, i8*, i64) #1

declare i64 @strlen(i8*) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_bless() #0 {
entry:
  %sp = alloca %struct.sv**, align 8
  %stash = alloca %struct.hv*, align 8
  %ssv = alloca %struct.sv*, align 8
  %len = alloca i64, align 8
  %ptr = alloca i8*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 7
  %2 = load i8, i8* %op_private, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 15
  %cmp = icmp eq i32 %and, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_stash = getelementptr inbounds %struct.cop, %struct.cop* %3, i32 0, i32 9
  %4 = load %struct.hv*, %struct.hv** %cop_stash, align 8
  store %struct.hv* %4, %struct.hv** %stash, align 8
  br label %if.end.49

if.else:                                          ; preds = %entry
  %5 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %5, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %6 = load %struct.sv*, %struct.sv** %5, align 8
  store %struct.sv* %6, %struct.sv** %ssv, align 8
  %7 = load %struct.sv*, %struct.sv** %ssv, align 8
  %tobool = icmp ne %struct.sv* %7, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.else
  %8 = load %struct.sv*, %struct.sv** %ssv, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %8, i32 0, i32 2
  %9 = load i32, i32* %sv_flags, align 4
  %and2 = and i32 %9, 8192
  %tobool3 = icmp ne i32 %and2, 0
  br i1 %tobool3, label %if.end, label %land.lhs.true.4

land.lhs.true.4:                                  ; preds = %land.lhs.true
  %10 = load %struct.sv*, %struct.sv** %ssv, align 8
  %sv_flags5 = getelementptr inbounds %struct.sv, %struct.sv* %10, i32 0, i32 2
  %11 = load i32, i32* %sv_flags5, align 4
  %and6 = and i32 %11, 268435456
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %if.end, label %land.lhs.true.8

land.lhs.true.8:                                  ; preds = %land.lhs.true.4
  %12 = load %struct.sv*, %struct.sv** %ssv, align 8
  %sv_flags9 = getelementptr inbounds %struct.sv, %struct.sv* %12, i32 0, i32 2
  %13 = load i32, i32* %sv_flags9, align 4
  %and10 = and i32 %13, 524288
  %tobool11 = icmp ne i32 %and10, 0
  br i1 %tobool11, label %if.then.12, label %if.end

if.then.12:                                       ; preds = %land.lhs.true.8
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.13, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then.12, %land.lhs.true.8, %land.lhs.true.4, %land.lhs.true, %if.else
  %14 = load %struct.sv*, %struct.sv** %ssv, align 8
  %sv_flags13 = getelementptr inbounds %struct.sv, %struct.sv* %14, i32 0, i32 2
  %15 = load i32, i32* %sv_flags13, align 4
  %and14 = and i32 %15, 262144
  %cmp15 = icmp eq i32 %and14, 262144
  br i1 %cmp15, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %16 = load %struct.sv*, %struct.sv** %ssv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %16, i32 0, i32 0
  %17 = load i8*, i8** %sv_any, align 8
  %18 = bitcast i8* %17 to %struct.xpv*
  %xpv_cur = getelementptr inbounds %struct.xpv, %struct.xpv* %18, i32 0, i32 1
  %19 = load i64, i64* %xpv_cur, align 8
  store i64 %19, i64* %len, align 8
  %20 = load %struct.sv*, %struct.sv** %ssv, align 8
  %sv_any17 = getelementptr inbounds %struct.sv, %struct.sv* %20, i32 0, i32 0
  %21 = load i8*, i8** %sv_any17, align 8
  %22 = bitcast i8* %21 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %22, i32 0, i32 0
  %23 = load i8*, i8** %xpv_pv, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %24 = load %struct.sv*, %struct.sv** %ssv, align 8
  %call = call i8* @Perl_sv_2pv_flags(%struct.sv* %24, i64* %len, i32 2)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %23, %cond.true ], [ %call, %cond.false ]
  store i8* %cond, i8** %ptr, align 8
  %25 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings = getelementptr inbounds %struct.cop, %struct.cop* %25, i32 0, i32 14
  %26 = load %struct.sv*, %struct.sv** %cop_warnings, align 8
  %cmp18 = icmp ne %struct.sv* %26, null
  br i1 %cmp18, label %land.lhs.true.20, label %lor.lhs.false.34

land.lhs.true.20:                                 ; preds = %cond.end
  %27 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings21 = getelementptr inbounds %struct.cop, %struct.cop* %27, i32 0, i32 14
  %28 = load %struct.sv*, %struct.sv** %cop_warnings21, align 8
  %cmp22 = icmp ne %struct.sv* %28, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 2)
  br i1 %cmp22, label %land.lhs.true.24, label %lor.lhs.false.34

land.lhs.true.24:                                 ; preds = %land.lhs.true.20
  %29 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings25 = getelementptr inbounds %struct.cop, %struct.cop* %29, i32 0, i32 14
  %30 = load %struct.sv*, %struct.sv** %cop_warnings25, align 8
  %cmp26 = icmp eq %struct.sv* %30, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 1)
  br i1 %cmp26, label %land.lhs.true.42, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true.24
  %31 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings28 = getelementptr inbounds %struct.cop, %struct.cop* %31, i32 0, i32 14
  %32 = load %struct.sv*, %struct.sv** %cop_warnings28, align 8
  %sv_any29 = getelementptr inbounds %struct.sv, %struct.sv* %32, i32 0, i32 0
  %33 = load i8*, i8** %sv_any29, align 8
  %34 = bitcast i8* %33 to %struct.xpv*
  %xpv_pv30 = getelementptr inbounds %struct.xpv, %struct.xpv* %34, i32 0, i32 0
  %35 = load i8*, i8** %xpv_pv30, align 8
  %arrayidx = getelementptr inbounds i8, i8* %35, i64 3
  %36 = load i8, i8* %arrayidx, align 1
  %conv31 = sext i8 %36 to i32
  %and32 = and i32 %conv31, 1
  %tobool33 = icmp ne i32 %and32, 0
  br i1 %tobool33, label %land.lhs.true.42, label %lor.lhs.false.34

lor.lhs.false.34:                                 ; preds = %lor.lhs.false, %land.lhs.true.20, %cond.end
  %37 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings35 = getelementptr inbounds %struct.cop, %struct.cop* %37, i32 0, i32 14
  %38 = load %struct.sv*, %struct.sv** %cop_warnings35, align 8
  %cmp36 = icmp eq %struct.sv* %38, null
  br i1 %cmp36, label %land.lhs.true.38, label %if.end.46

land.lhs.true.38:                                 ; preds = %lor.lhs.false.34
  %39 = load i8, i8* @PL_dowarn, align 1
  %conv39 = zext i8 %39 to i32
  %and40 = and i32 %conv39, 1
  %tobool41 = icmp ne i32 %and40, 0
  br i1 %tobool41, label %land.lhs.true.42, label %if.end.46

land.lhs.true.42:                                 ; preds = %land.lhs.true.38, %lor.lhs.false, %land.lhs.true.24
  %40 = load i64, i64* %len, align 8
  %cmp43 = icmp eq i64 %40, 0
  br i1 %cmp43, label %if.then.45, label %if.end.46

if.then.45:                                       ; preds = %land.lhs.true.42
  call void (i32, i8*, ...) @Perl_warner(i32 12, i8* getelementptr inbounds ([48 x i8], [48 x i8]* @.str.14, i32 0, i32 0))
  br label %if.end.46

if.end.46:                                        ; preds = %if.then.45, %land.lhs.true.42, %land.lhs.true.38, %lor.lhs.false.34
  %41 = load i8*, i8** %ptr, align 8
  %42 = load i64, i64* %len, align 8
  %conv47 = trunc i64 %42 to i32
  %call48 = call %struct.hv* @Perl_gv_stashpvn(i8* %41, i32 %conv47, i32 1)
  store %struct.hv* %call48, %struct.hv** %stash, align 8
  br label %if.end.49

if.end.49:                                        ; preds = %if.end.46, %if.then
  %43 = load %struct.sv**, %struct.sv*** %sp, align 8
  %44 = load %struct.sv*, %struct.sv** %43, align 8
  %45 = load %struct.hv*, %struct.hv** %stash, align 8
  %call50 = call %struct.sv* @Perl_sv_bless(%struct.sv* %44, %struct.hv* %45)
  %46 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %46, %struct.sv*** @PL_stack_sp, align 8
  %47 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %47, i32 0, i32 0
  %48 = load %struct.op*, %struct.op** %op_next, align 8
  ret %struct.op* %48
}

declare void @Perl_warner(i32, i8*, ...) #1

declare %struct.hv* @Perl_gv_stashpvn(i8*, i32, i32) #1

declare %struct.sv* @Perl_sv_bless(%struct.sv*, %struct.hv*) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_gelem() #0 {
entry:
  %gv = alloca %struct.gv*, align 8
  %sv = alloca %struct.sv*, align 8
  %tmpRef = alloca %struct.sv*, align 8
  %elem = alloca i8*, align 8
  %sp = alloca %struct.sv**, align 8
  %n_a = alloca i64, align 8
  %elem2 = alloca i8*, align 8
  %name = alloca i8*, align 8
  %tmp = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %1, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %2 = load %struct.sv*, %struct.sv** %1, align 8
  store %struct.sv* %2, %struct.sv** %sv, align 8
  %3 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %3, i32 0, i32 2
  %4 = load i32, i32* %sv_flags, align 4
  %and = and i32 %4, 262144
  %cmp = icmp eq i32 %and, 262144
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %5 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %5, i32 0, i32 0
  %6 = load i8*, i8** %sv_any, align 8
  %7 = bitcast i8* %6 to %struct.xpv*
  %xpv_cur = getelementptr inbounds %struct.xpv, %struct.xpv* %7, i32 0, i32 1
  %8 = load i64, i64* %xpv_cur, align 8
  store i64 %8, i64* %n_a, align 8
  %9 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any1 = getelementptr inbounds %struct.sv, %struct.sv* %9, i32 0, i32 0
  %10 = load i8*, i8** %sv_any1, align 8
  %11 = bitcast i8* %10 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %11, i32 0, i32 0
  %12 = load i8*, i8** %xpv_pv, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %13 = load %struct.sv*, %struct.sv** %sv, align 8
  %call = call i8* @Perl_sv_2pv_flags(%struct.sv* %13, i64* %n_a, i32 2)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %12, %cond.true ], [ %call, %cond.false ]
  store i8* %cond, i8** %elem, align 8
  %14 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr2 = getelementptr inbounds %struct.sv*, %struct.sv** %14, i32 -1
  store %struct.sv** %incdec.ptr2, %struct.sv*** %sp, align 8
  %15 = load %struct.sv*, %struct.sv** %14, align 8
  %16 = bitcast %struct.sv* %15 to %struct.gv*
  store %struct.gv* %16, %struct.gv** %gv, align 8
  store %struct.sv* null, %struct.sv** %tmpRef, align 8
  store %struct.sv* null, %struct.sv** %sv, align 8
  %17 = load i8*, i8** %elem, align 8
  %tobool = icmp ne i8* %17, null
  br i1 %tobool, label %if.then, label %if.end.84

if.then:                                          ; preds = %cond.end
  %18 = load i8*, i8** %elem, align 8
  %add.ptr = getelementptr inbounds i8, i8* %18, i64 1
  store i8* %add.ptr, i8** %elem2, align 8
  %19 = load i8*, i8** %elem, align 8
  %20 = load i8, i8* %19, align 1
  %conv = sext i8 %20 to i32
  switch i32 %conv, label %sw.epilog [
    i32 65, label %sw.bb
    i32 67, label %sw.bb.7
    i32 70, label %sw.bb.21
    i32 71, label %sw.bb.34
    i32 72, label %sw.bb.39
    i32 73, label %sw.bb.46
    i32 78, label %sw.bb.56
    i32 80, label %sw.bb.64
    i32 83, label %sw.bb.77
  ]

sw.bb:                                            ; preds = %if.then
  %21 = load i8*, i8** %elem2, align 8
  %call3 = call i32 @strcmp(i8* %21, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.15, i32 0, i32 0))
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.end, label %if.then.5

if.then.5:                                        ; preds = %sw.bb
  %22 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any6 = getelementptr inbounds %struct.gv, %struct.gv* %22, i32 0, i32 0
  %23 = load %struct.xpvgv*, %struct.xpvgv** %sv_any6, align 8
  %xgv_gp = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %23, i32 0, i32 7
  %24 = load %struct.gp*, %struct.gp** %xgv_gp, align 8
  %gp_av = getelementptr inbounds %struct.gp, %struct.gp* %24, i32 0, i32 4
  %25 = load %struct.av*, %struct.av** %gp_av, align 8
  %26 = bitcast %struct.av* %25 to %struct.sv*
  store %struct.sv* %26, %struct.sv** %tmpRef, align 8
  br label %if.end

if.end:                                           ; preds = %if.then.5, %sw.bb
  br label %sw.epilog

sw.bb.7:                                          ; preds = %if.then
  %27 = load i8*, i8** %elem2, align 8
  %call8 = call i32 @strcmp(i8* %27, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.16, i32 0, i32 0))
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end.20, label %if.then.10

if.then.10:                                       ; preds = %sw.bb.7
  %28 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any11 = getelementptr inbounds %struct.gv, %struct.gv* %28, i32 0, i32 0
  %29 = load %struct.xpvgv*, %struct.xpvgv** %sv_any11, align 8
  %xgv_gp12 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %29, i32 0, i32 7
  %30 = load %struct.gp*, %struct.gp** %xgv_gp12, align 8
  %gp_cvgen = getelementptr inbounds %struct.gp, %struct.gp* %30, i32 0, i32 8
  %31 = load i32, i32* %gp_cvgen, align 4
  %tobool13 = icmp ne i32 %31, 0
  br i1 %tobool13, label %cond.true.14, label %cond.false.15

cond.true.14:                                     ; preds = %if.then.10
  br label %cond.end.18

cond.false.15:                                    ; preds = %if.then.10
  %32 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any16 = getelementptr inbounds %struct.gv, %struct.gv* %32, i32 0, i32 0
  %33 = load %struct.xpvgv*, %struct.xpvgv** %sv_any16, align 8
  %xgv_gp17 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %33, i32 0, i32 7
  %34 = load %struct.gp*, %struct.gp** %xgv_gp17, align 8
  %gp_cv = getelementptr inbounds %struct.gp, %struct.gp* %34, i32 0, i32 7
  %35 = load %struct.cv*, %struct.cv** %gp_cv, align 8
  br label %cond.end.18

cond.end.18:                                      ; preds = %cond.false.15, %cond.true.14
  %cond19 = phi %struct.cv* [ null, %cond.true.14 ], [ %35, %cond.false.15 ]
  %36 = bitcast %struct.cv* %cond19 to %struct.sv*
  store %struct.sv* %36, %struct.sv** %tmpRef, align 8
  br label %if.end.20

if.end.20:                                        ; preds = %cond.end.18, %sw.bb.7
  br label %sw.epilog

sw.bb.21:                                         ; preds = %if.then
  %37 = load i8*, i8** %elem2, align 8
  %call22 = call i32 @strcmp(i8* %37, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.17, i32 0, i32 0))
  %tobool23 = icmp ne i32 %call22, 0
  br i1 %tobool23, label %if.else, label %if.then.24

if.then.24:                                       ; preds = %sw.bb.21
  call void @Perl_deprecate(i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.18, i32 0, i32 0))
  %38 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any25 = getelementptr inbounds %struct.gv, %struct.gv* %38, i32 0, i32 0
  %39 = load %struct.xpvgv*, %struct.xpvgv** %sv_any25, align 8
  %xgv_gp26 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %39, i32 0, i32 7
  %40 = load %struct.gp*, %struct.gp** %xgv_gp26, align 8
  %gp_io = getelementptr inbounds %struct.gp, %struct.gp* %40, i32 0, i32 2
  %41 = load %struct.io*, %struct.io** %gp_io, align 8
  %42 = bitcast %struct.io* %41 to %struct.sv*
  store %struct.sv* %42, %struct.sv** %tmpRef, align 8
  br label %if.end.33

if.else:                                          ; preds = %sw.bb.21
  %43 = load i8*, i8** %elem2, align 8
  %call27 = call i32 @strcmp(i8* %43, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.19, i32 0, i32 0))
  %tobool28 = icmp ne i32 %call27, 0
  br i1 %tobool28, label %if.end.32, label %if.then.29

if.then.29:                                       ; preds = %if.else
  %44 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any30 = getelementptr inbounds %struct.gv, %struct.gv* %44, i32 0, i32 0
  %45 = load %struct.xpvgv*, %struct.xpvgv** %sv_any30, align 8
  %xgv_gp31 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %45, i32 0, i32 7
  %46 = load %struct.gp*, %struct.gp** %xgv_gp31, align 8
  %gp_form = getelementptr inbounds %struct.gp, %struct.gp* %46, i32 0, i32 3
  %47 = load %struct.cv*, %struct.cv** %gp_form, align 8
  %48 = bitcast %struct.cv* %47 to %struct.sv*
  store %struct.sv* %48, %struct.sv** %tmpRef, align 8
  br label %if.end.32

if.end.32:                                        ; preds = %if.then.29, %if.else
  br label %if.end.33

if.end.33:                                        ; preds = %if.end.32, %if.then.24
  br label %sw.epilog

sw.bb.34:                                         ; preds = %if.then
  %49 = load i8*, i8** %elem2, align 8
  %call35 = call i32 @strcmp(i8* %49, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.20, i32 0, i32 0))
  %tobool36 = icmp ne i32 %call35, 0
  br i1 %tobool36, label %if.end.38, label %if.then.37

if.then.37:                                       ; preds = %sw.bb.34
  %50 = load %struct.gv*, %struct.gv** %gv, align 8
  %51 = bitcast %struct.gv* %50 to %struct.sv*
  store %struct.sv* %51, %struct.sv** %tmpRef, align 8
  br label %if.end.38

if.end.38:                                        ; preds = %if.then.37, %sw.bb.34
  br label %sw.epilog

sw.bb.39:                                         ; preds = %if.then
  %52 = load i8*, i8** %elem2, align 8
  %call40 = call i32 @strcmp(i8* %52, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.21, i32 0, i32 0))
  %tobool41 = icmp ne i32 %call40, 0
  br i1 %tobool41, label %if.end.45, label %if.then.42

if.then.42:                                       ; preds = %sw.bb.39
  %53 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any43 = getelementptr inbounds %struct.gv, %struct.gv* %53, i32 0, i32 0
  %54 = load %struct.xpvgv*, %struct.xpvgv** %sv_any43, align 8
  %xgv_gp44 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %54, i32 0, i32 7
  %55 = load %struct.gp*, %struct.gp** %xgv_gp44, align 8
  %gp_hv = getelementptr inbounds %struct.gp, %struct.gp* %55, i32 0, i32 5
  %56 = load %struct.hv*, %struct.hv** %gp_hv, align 8
  %57 = bitcast %struct.hv* %56 to %struct.sv*
  store %struct.sv* %57, %struct.sv** %tmpRef, align 8
  br label %if.end.45

if.end.45:                                        ; preds = %if.then.42, %sw.bb.39
  br label %sw.epilog

sw.bb.46:                                         ; preds = %if.then
  %58 = load i8*, i8** %elem2, align 8
  %59 = load i8, i8* %58, align 1
  %conv47 = sext i8 %59 to i32
  %cmp48 = icmp eq i32 %conv47, 79
  br i1 %cmp48, label %land.lhs.true, label %if.end.55

land.lhs.true:                                    ; preds = %sw.bb.46
  %60 = load i8*, i8** %elem, align 8
  %arrayidx = getelementptr inbounds i8, i8* %60, i64 2
  %61 = load i8, i8* %arrayidx, align 1
  %tobool50 = icmp ne i8 %61, 0
  br i1 %tobool50, label %if.end.55, label %if.then.51

if.then.51:                                       ; preds = %land.lhs.true
  %62 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any52 = getelementptr inbounds %struct.gv, %struct.gv* %62, i32 0, i32 0
  %63 = load %struct.xpvgv*, %struct.xpvgv** %sv_any52, align 8
  %xgv_gp53 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %63, i32 0, i32 7
  %64 = load %struct.gp*, %struct.gp** %xgv_gp53, align 8
  %gp_io54 = getelementptr inbounds %struct.gp, %struct.gp* %64, i32 0, i32 2
  %65 = load %struct.io*, %struct.io** %gp_io54, align 8
  %66 = bitcast %struct.io* %65 to %struct.sv*
  store %struct.sv* %66, %struct.sv** %tmpRef, align 8
  br label %if.end.55

if.end.55:                                        ; preds = %if.then.51, %land.lhs.true, %sw.bb.46
  br label %sw.epilog

sw.bb.56:                                         ; preds = %if.then
  %67 = load i8*, i8** %elem2, align 8
  %call57 = call i32 @strcmp(i8* %67, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.22, i32 0, i32 0))
  %tobool58 = icmp ne i32 %call57, 0
  br i1 %tobool58, label %if.end.63, label %if.then.59

if.then.59:                                       ; preds = %sw.bb.56
  %68 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any60 = getelementptr inbounds %struct.gv, %struct.gv* %68, i32 0, i32 0
  %69 = load %struct.xpvgv*, %struct.xpvgv** %sv_any60, align 8
  %xgv_name = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %69, i32 0, i32 8
  %70 = load i8*, i8** %xgv_name, align 8
  %71 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any61 = getelementptr inbounds %struct.gv, %struct.gv* %71, i32 0, i32 0
  %72 = load %struct.xpvgv*, %struct.xpvgv** %sv_any61, align 8
  %xgv_namelen = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %72, i32 0, i32 9
  %73 = load i64, i64* %xgv_namelen, align 8
  %call62 = call %struct.sv* @Perl_newSVpvn(i8* %70, i64 %73)
  store %struct.sv* %call62, %struct.sv** %sv, align 8
  br label %if.end.63

if.end.63:                                        ; preds = %if.then.59, %sw.bb.56
  br label %sw.epilog

sw.bb.64:                                         ; preds = %if.then
  %74 = load i8*, i8** %elem2, align 8
  %call65 = call i32 @strcmp(i8* %74, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.23, i32 0, i32 0))
  %tobool66 = icmp ne i32 %call65, 0
  br i1 %tobool66, label %if.end.76, label %if.then.67

if.then.67:                                       ; preds = %sw.bb.64
  %75 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any68 = getelementptr inbounds %struct.gv, %struct.gv* %75, i32 0, i32 0
  %76 = load %struct.xpvgv*, %struct.xpvgv** %sv_any68, align 8
  %xgv_stash = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %76, i32 0, i32 10
  %77 = load %struct.hv*, %struct.hv** %xgv_stash, align 8
  %sv_any69 = getelementptr inbounds %struct.hv, %struct.hv* %77, i32 0, i32 0
  %78 = load %struct.xpvhv*, %struct.xpvhv** %sv_any69, align 8
  %xhv_name = getelementptr inbounds %struct.xpvhv, %struct.xpvhv* %78, i32 0, i32 10
  %79 = load i8*, i8** %xhv_name, align 8
  store i8* %79, i8** %name, align 8
  %80 = load i8*, i8** %name, align 8
  %tobool70 = icmp ne i8* %80, null
  br i1 %tobool70, label %cond.true.71, label %cond.false.72

cond.true.71:                                     ; preds = %if.then.67
  %81 = load i8*, i8** %name, align 8
  br label %cond.end.73

cond.false.72:                                    ; preds = %if.then.67
  br label %cond.end.73

cond.end.73:                                      ; preds = %cond.false.72, %cond.true.71
  %cond74 = phi i8* [ %81, %cond.true.71 ], [ getelementptr inbounds ([9 x i8], [9 x i8]* @.str.24, i32 0, i32 0), %cond.false.72 ]
  %call75 = call %struct.sv* @Perl_newSVpv(i8* %cond74, i64 0)
  store %struct.sv* %call75, %struct.sv** %sv, align 8
  br label %if.end.76

if.end.76:                                        ; preds = %cond.end.73, %sw.bb.64
  br label %sw.epilog

sw.bb.77:                                         ; preds = %if.then
  %82 = load i8*, i8** %elem2, align 8
  %call78 = call i32 @strcmp(i8* %82, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.25, i32 0, i32 0))
  %tobool79 = icmp ne i32 %call78, 0
  br i1 %tobool79, label %if.end.83, label %if.then.80

if.then.80:                                       ; preds = %sw.bb.77
  %83 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any81 = getelementptr inbounds %struct.gv, %struct.gv* %83, i32 0, i32 0
  %84 = load %struct.xpvgv*, %struct.xpvgv** %sv_any81, align 8
  %xgv_gp82 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %84, i32 0, i32 7
  %85 = load %struct.gp*, %struct.gp** %xgv_gp82, align 8
  %gp_sv = getelementptr inbounds %struct.gp, %struct.gp* %85, i32 0, i32 0
  %86 = load %struct.sv*, %struct.sv** %gp_sv, align 8
  store %struct.sv* %86, %struct.sv** %tmpRef, align 8
  br label %if.end.83

if.end.83:                                        ; preds = %if.then.80, %sw.bb.77
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.then, %if.end.83, %if.end.76, %if.end.63, %if.end.55, %if.end.45, %if.end.38, %if.end.33, %if.end.20, %if.end
  br label %if.end.84

if.end.84:                                        ; preds = %sw.epilog, %cond.end
  %87 = load %struct.sv*, %struct.sv** %tmpRef, align 8
  %tobool85 = icmp ne %struct.sv* %87, null
  br i1 %tobool85, label %if.then.86, label %if.end.88

if.then.86:                                       ; preds = %if.end.84
  %88 = load %struct.sv*, %struct.sv** %tmpRef, align 8
  %call87 = call %struct.sv* @Perl_newRV(%struct.sv* %88)
  store %struct.sv* %call87, %struct.sv** %sv, align 8
  br label %if.end.88

if.end.88:                                        ; preds = %if.then.86, %if.end.84
  %89 = load %struct.sv*, %struct.sv** %sv, align 8
  %tobool89 = icmp ne %struct.sv* %89, null
  br i1 %tobool89, label %if.then.90, label %if.else.92

if.then.90:                                       ; preds = %if.end.88
  %90 = load %struct.sv*, %struct.sv** %sv, align 8
  %call91 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %90)
  br label %if.end.93

if.else.92:                                       ; preds = %if.end.88
  store %struct.sv* @PL_sv_undef, %struct.sv** %sv, align 8
  br label %if.end.93

if.end.93:                                        ; preds = %if.else.92, %if.then.90
  %91 = load %struct.sv**, %struct.sv*** @PL_stack_max, align 8
  %92 = load %struct.sv**, %struct.sv*** %sp, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %91 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %92 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %cmp94 = icmp slt i64 %sub.ptr.div, 1
  br i1 %cmp94, label %if.then.96, label %if.end.98

if.then.96:                                       ; preds = %if.end.93
  %93 = load %struct.sv**, %struct.sv*** %sp, align 8
  %94 = load %struct.sv**, %struct.sv*** %sp, align 8
  %call97 = call %struct.sv** @Perl_stack_grow(%struct.sv** %93, %struct.sv** %94, i32 1)
  store %struct.sv** %call97, %struct.sv*** %sp, align 8
  br label %if.end.98

if.end.98:                                        ; preds = %if.then.96, %if.end.93
  %95 = load %struct.sv*, %struct.sv** %sv, align 8
  %96 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr99 = getelementptr inbounds %struct.sv*, %struct.sv** %96, i32 1
  store %struct.sv** %incdec.ptr99, %struct.sv*** %sp, align 8
  store %struct.sv* %95, %struct.sv** %incdec.ptr99, align 8
  store %struct.sv* %95, %struct.sv** %tmp
  %97 = load %struct.sv*, %struct.sv** %tmp
  %98 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %98, %struct.sv*** @PL_stack_sp, align 8
  %99 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %99, i32 0, i32 0
  %100 = load %struct.op*, %struct.op** %op_next, align 8
  ret %struct.op* %100
}

declare void @Perl_deprecate(i8*) #1

declare %struct.sv* @Perl_newSVpv(i8*, i64) #1

declare %struct.sv* @Perl_newRV(%struct.sv*) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_study() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %sv = alloca %struct.sv*, align 8
  %s = alloca i8*, align 8
  %pos = alloca i32, align 4
  %ch = alloca i32, align 4
  %sfirst = alloca i32*, align 8
  %snext = alloca i32*, align 8
  %len = alloca i64, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %1, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %2 = load %struct.sv*, %struct.sv** %1, align 8
  store %struct.sv* %2, %struct.sv** %sv, align 8
  %3 = load %struct.sv*, %struct.sv** %sv, align 8
  %4 = load %struct.sv*, %struct.sv** @PL_lastscream, align 8
  %cmp = icmp eq %struct.sv* %3, %4
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %5 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %5, i32 0, i32 2
  %6 = load i32, i32* %sv_flags, align 4
  %and = and i32 %6, 134217728
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then.1, label %if.end

if.then.1:                                        ; preds = %if.then
  %7 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr2 = getelementptr inbounds %struct.sv*, %struct.sv** %7, i32 1
  store %struct.sv** %incdec.ptr2, %struct.sv*** %sp, align 8
  store %struct.sv* @PL_sv_yes, %struct.sv** %incdec.ptr2, align 8
  %8 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %8, %struct.sv*** @PL_stack_sp, align 8
  %9 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %9, i32 0, i32 0
  %10 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %10, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %if.then
  br label %if.end.10

if.else:                                          ; preds = %entry
  %11 = load %struct.sv*, %struct.sv** @PL_lastscream, align 8
  %tobool3 = icmp ne %struct.sv* %11, null
  br i1 %tobool3, label %if.then.4, label %if.end.7

if.then.4:                                        ; preds = %if.else
  %12 = load %struct.sv*, %struct.sv** @PL_lastscream, align 8
  %sv_flags5 = getelementptr inbounds %struct.sv, %struct.sv* %12, i32 0, i32 2
  %13 = load i32, i32* %sv_flags5, align 4
  %and6 = and i32 %13, -134217729
  store i32 %and6, i32* %sv_flags5, align 4
  %14 = load %struct.sv*, %struct.sv** @PL_lastscream, align 8
  call void @Perl_sv_free(%struct.sv* %14)
  br label %if.end.7

if.end.7:                                         ; preds = %if.then.4, %if.else
  %15 = load %struct.sv*, %struct.sv** %sv, align 8
  store %struct.sv* %15, %struct.sv** @PL_Sv, align 8
  %16 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %tobool8 = icmp ne %struct.sv* %16, null
  br i1 %tobool8, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end.7
  %17 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_refcnt = getelementptr inbounds %struct.sv, %struct.sv* %17, i32 0, i32 1
  %18 = load i32, i32* %sv_refcnt, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %sv_refcnt, align 4
  %tobool9 = icmp ne i32 %inc, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end.7
  %19 = phi i1 [ false, %if.end.7 ], [ %tobool9, %land.rhs ]
  %land.ext = zext i1 %19 to i32
  %20 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  store %struct.sv* %20, %struct.sv** @PL_lastscream, align 8
  br label %if.end.10

if.end.10:                                        ; preds = %land.end, %if.end
  %21 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags11 = getelementptr inbounds %struct.sv, %struct.sv* %21, i32 0, i32 2
  %22 = load i32, i32* %sv_flags11, align 4
  %and12 = and i32 %22, 262144
  %cmp13 = icmp eq i32 %and12, 262144
  br i1 %cmp13, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.10
  %23 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %23, i32 0, i32 0
  %24 = load i8*, i8** %sv_any, align 8
  %25 = bitcast i8* %24 to %struct.xpv*
  %xpv_cur = getelementptr inbounds %struct.xpv, %struct.xpv* %25, i32 0, i32 1
  %26 = load i64, i64* %xpv_cur, align 8
  store i64 %26, i64* %len, align 8
  %27 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any14 = getelementptr inbounds %struct.sv, %struct.sv* %27, i32 0, i32 0
  %28 = load i8*, i8** %sv_any14, align 8
  %29 = bitcast i8* %28 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %29, i32 0, i32 0
  %30 = load i8*, i8** %xpv_pv, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end.10
  %31 = load %struct.sv*, %struct.sv** %sv, align 8
  %call = call i8* @Perl_sv_2pv_flags(%struct.sv* %31, i64* %len, i32 2)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %30, %cond.true ], [ %call, %cond.false ]
  store i8* %cond, i8** %s, align 8
  %32 = load i64, i64* %len, align 8
  %conv = trunc i64 %32 to i32
  store i32 %conv, i32* %pos, align 4
  %33 = load i32, i32* %pos, align 4
  %cmp15 = icmp sle i32 %33, 0
  br i1 %cmp15, label %if.then.17, label %if.end.20

if.then.17:                                       ; preds = %cond.end
  %34 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr18 = getelementptr inbounds %struct.sv*, %struct.sv** %34, i32 1
  store %struct.sv** %incdec.ptr18, %struct.sv*** %sp, align 8
  store %struct.sv* @PL_sv_no, %struct.sv** %incdec.ptr18, align 8
  %35 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %35, %struct.sv*** @PL_stack_sp, align 8
  %36 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next19 = getelementptr inbounds %struct.op, %struct.op* %36, i32 0, i32 0
  %37 = load %struct.op*, %struct.op** %op_next19, align 8
  store %struct.op* %37, %struct.op** %retval
  br label %return

if.end.20:                                        ; preds = %cond.end
  %38 = load i32, i32* %pos, align 4
  %39 = load i32, i32* @PL_maxscream, align 4
  %cmp21 = icmp sgt i32 %38, %39
  br i1 %cmp21, label %if.then.23, label %if.end.36

if.then.23:                                       ; preds = %if.end.20
  %40 = load i32, i32* @PL_maxscream, align 4
  %cmp24 = icmp slt i32 %40, 0
  br i1 %cmp24, label %if.then.26, label %if.else.30

if.then.26:                                       ; preds = %if.then.23
  %41 = load i32, i32* %pos, align 4
  %add = add nsw i32 %41, 80
  store i32 %add, i32* @PL_maxscream, align 4
  %call27 = call i8* @Perl_safesysmalloc(i64 1024)
  %42 = bitcast i8* %call27 to i32*
  store i32* %42, i32** @PL_screamfirst, align 8
  %43 = load i32, i32* @PL_maxscream, align 4
  %conv28 = sext i32 %43 to i64
  %mul = mul i64 %conv28, 4
  %call29 = call i8* @Perl_safesysmalloc(i64 %mul)
  %44 = bitcast i8* %call29 to i32*
  store i32* %44, i32** @PL_screamnext, align 8
  br label %if.end.35

if.else.30:                                       ; preds = %if.then.23
  %45 = load i32, i32* %pos, align 4
  %46 = load i32, i32* %pos, align 4
  %div = sdiv i32 %46, 4
  %add31 = add nsw i32 %45, %div
  store i32 %add31, i32* @PL_maxscream, align 4
  %47 = load i32*, i32** @PL_screamnext, align 8
  %48 = bitcast i32* %47 to i8*
  %49 = load i32, i32* @PL_maxscream, align 4
  %conv32 = sext i32 %49 to i64
  %mul33 = mul i64 %conv32, 4
  %call34 = call i8* @Perl_safesysrealloc(i8* %48, i64 %mul33)
  %50 = bitcast i8* %call34 to i32*
  store i32* %50, i32** @PL_screamnext, align 8
  br label %if.end.35

if.end.35:                                        ; preds = %if.else.30, %if.then.26
  br label %if.end.36

if.end.36:                                        ; preds = %if.end.35, %if.end.20
  %51 = load i32*, i32** @PL_screamfirst, align 8
  store i32* %51, i32** %sfirst, align 8
  %52 = load i32*, i32** @PL_screamnext, align 8
  store i32* %52, i32** %snext, align 8
  %53 = load i32*, i32** %sfirst, align 8
  %tobool37 = icmp ne i32* %53, null
  br i1 %tobool37, label %lor.lhs.false, label %if.then.39

lor.lhs.false:                                    ; preds = %if.end.36
  %54 = load i32*, i32** %snext, align 8
  %tobool38 = icmp ne i32* %54, null
  br i1 %tobool38, label %if.end.41, label %if.then.39

if.then.39:                                       ; preds = %lor.lhs.false, %if.end.36
  %call40 = call %struct.op* (i8*, ...) @Perl_die(i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.26, i32 0, i32 0))
  store %struct.op* %call40, %struct.op** %retval
  br label %return

if.end.41:                                        ; preds = %lor.lhs.false
  store i32 256, i32* %ch, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end.41
  %55 = load i32, i32* %ch, align 4
  %tobool42 = icmp ne i32 %55, 0
  br i1 %tobool42, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %56 = load i32*, i32** %sfirst, align 8
  %incdec.ptr43 = getelementptr inbounds i32, i32* %56, i32 1
  store i32* %incdec.ptr43, i32** %sfirst, align 8
  store i32 -1, i32* %56, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %57 = load i32, i32* %ch, align 4
  %dec = add nsw i32 %57, -1
  store i32 %dec, i32* %ch, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %58 = load i32*, i32** %sfirst, align 8
  %add.ptr = getelementptr inbounds i32, i32* %58, i64 -256
  store i32* %add.ptr, i32** %sfirst, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end.61, %for.end
  %59 = load i32, i32* %pos, align 4
  %dec44 = add nsw i32 %59, -1
  store i32 %dec44, i32* %pos, align 4
  %cmp45 = icmp sge i32 %dec44, 0
  br i1 %cmp45, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %60 = load i32, i32* %pos, align 4
  %idxprom = sext i32 %60 to i64
  %61 = load i8*, i8** %s, align 8
  %arrayidx = getelementptr inbounds i8, i8* %61, i64 %idxprom
  %62 = load i8, i8* %arrayidx, align 1
  %conv47 = zext i8 %62 to i32
  store i32 %conv47, i32* %ch, align 4
  %63 = load i32, i32* %ch, align 4
  %idxprom48 = sext i32 %63 to i64
  %64 = load i32*, i32** %sfirst, align 8
  %arrayidx49 = getelementptr inbounds i32, i32* %64, i64 %idxprom48
  %65 = load i32, i32* %arrayidx49, align 4
  %cmp50 = icmp sge i32 %65, 0
  br i1 %cmp50, label %if.then.52, label %if.else.57

if.then.52:                                       ; preds = %while.body
  %66 = load i32, i32* %ch, align 4
  %idxprom53 = sext i32 %66 to i64
  %67 = load i32*, i32** %sfirst, align 8
  %arrayidx54 = getelementptr inbounds i32, i32* %67, i64 %idxprom53
  %68 = load i32, i32* %arrayidx54, align 4
  %69 = load i32, i32* %pos, align 4
  %sub = sub nsw i32 %68, %69
  %70 = load i32, i32* %pos, align 4
  %idxprom55 = sext i32 %70 to i64
  %71 = load i32*, i32** %snext, align 8
  %arrayidx56 = getelementptr inbounds i32, i32* %71, i64 %idxprom55
  store i32 %sub, i32* %arrayidx56, align 4
  br label %if.end.61

if.else.57:                                       ; preds = %while.body
  %72 = load i32, i32* %pos, align 4
  %sub58 = sub nsw i32 0, %72
  %73 = load i32, i32* %pos, align 4
  %idxprom59 = sext i32 %73 to i64
  %74 = load i32*, i32** %snext, align 8
  %arrayidx60 = getelementptr inbounds i32, i32* %74, i64 %idxprom59
  store i32 %sub58, i32* %arrayidx60, align 4
  br label %if.end.61

if.end.61:                                        ; preds = %if.else.57, %if.then.52
  %75 = load i32, i32* %pos, align 4
  %76 = load i32, i32* %ch, align 4
  %idxprom62 = sext i32 %76 to i64
  %77 = load i32*, i32** %sfirst, align 8
  %arrayidx63 = getelementptr inbounds i32, i32* %77, i64 %idxprom62
  store i32 %75, i32* %arrayidx63, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %78 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags64 = getelementptr inbounds %struct.sv, %struct.sv* %78, i32 0, i32 2
  %79 = load i32, i32* %sv_flags64, align 4
  %or = or i32 %79, 134217728
  store i32 %or, i32* %sv_flags64, align 4
  %80 = load %struct.sv*, %struct.sv** %sv, align 8
  call void @Perl_sv_magic(%struct.sv* %80, %struct.sv* null, i32 103, i8* null, i32 0)
  %81 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr65 = getelementptr inbounds %struct.sv*, %struct.sv** %81, i32 1
  store %struct.sv** %incdec.ptr65, %struct.sv*** %sp, align 8
  store %struct.sv* @PL_sv_yes, %struct.sv** %incdec.ptr65, align 8
  %82 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %82, %struct.sv*** @PL_stack_sp, align 8
  %83 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next66 = getelementptr inbounds %struct.op, %struct.op* %83, i32 0, i32 0
  %84 = load %struct.op*, %struct.op** %op_next66, align 8
  store %struct.op* %84, %struct.op** %retval
  br label %return

return:                                           ; preds = %while.end, %if.then.39, %if.then.17, %if.then.1
  %85 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %85
}

declare i8* @Perl_safesysmalloc(i64) #1

declare i8* @Perl_safesysrealloc(i8*, i64) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_trans() #0 {
entry:
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %sv = alloca %struct.sv*, align 8
  %tmp = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 6
  %2 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 64
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %3, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %4 = load %struct.sv*, %struct.sv** %3, align 8
  store %struct.sv* %4, %struct.sv** %sv, align 8
  br label %if.end.3

if.else:                                          ; preds = %entry
  %5 = load %struct.gv*, %struct.gv** @PL_defgv, align 8
  %sv_any = getelementptr inbounds %struct.gv, %struct.gv* %5, i32 0, i32 0
  %6 = load %struct.xpvgv*, %struct.xpvgv** %sv_any, align 8
  %xgv_gp = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %6, i32 0, i32 7
  %7 = load %struct.gp*, %struct.gp** %xgv_gp, align 8
  %gp_sv = getelementptr inbounds %struct.gp, %struct.gp* %7, i32 0, i32 0
  %8 = load %struct.sv*, %struct.sv** %gp_sv, align 8
  store %struct.sv* %8, %struct.sv** %sv, align 8
  %9 = load %struct.sv**, %struct.sv*** @PL_stack_max, align 8
  %10 = load %struct.sv**, %struct.sv*** %sp, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %9 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %10 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %cmp = icmp slt i64 %sub.ptr.div, 1
  br i1 %cmp, label %if.then.2, label %if.end

if.then.2:                                        ; preds = %if.else
  %11 = load %struct.sv**, %struct.sv*** %sp, align 8
  %12 = load %struct.sv**, %struct.sv*** %sp, align 8
  %call = call %struct.sv** @Perl_stack_grow(%struct.sv** %11, %struct.sv** %12, i32 1)
  store %struct.sv** %call, %struct.sv*** %sp, align 8
  br label %if.end

if.end:                                           ; preds = %if.then.2, %if.else
  br label %if.end.3

if.end.3:                                         ; preds = %if.end, %if.then
  %call4 = call %struct.sv* @Perl_sv_newmortal()
  store %struct.sv* %call4, %struct.sv** %targ, align 8
  %13 = load %struct.sv*, %struct.sv** %targ, align 8
  %14 = load %struct.sv*, %struct.sv** %sv, align 8
  %call5 = call i32 @Perl_do_trans(%struct.sv* %14)
  %conv6 = sext i32 %call5 to i64
  call void @Perl_sv_setiv(%struct.sv* %13, i64 %conv6)
  %15 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %15, i32 0, i32 2
  %16 = load i32, i32* %sv_flags, align 4
  %and7 = and i32 %16, 16384
  %tobool8 = icmp ne i32 %and7, 0
  br i1 %tobool8, label %if.then.9, label %if.end.11

if.then.9:                                        ; preds = %if.end.3
  %17 = load %struct.sv*, %struct.sv** %targ, align 8
  %call10 = call i32 @Perl_mg_set(%struct.sv* %17)
  br label %if.end.11

if.end.11:                                        ; preds = %if.then.9, %if.end.3
  %18 = load %struct.sv*, %struct.sv** %targ, align 8
  %19 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr12 = getelementptr inbounds %struct.sv*, %struct.sv** %19, i32 1
  store %struct.sv** %incdec.ptr12, %struct.sv*** %sp, align 8
  store %struct.sv* %18, %struct.sv** %incdec.ptr12, align 8
  store %struct.sv* %18, %struct.sv** %tmp
  %20 = load %struct.sv*, %struct.sv** %tmp
  %21 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %21, %struct.sv*** @PL_stack_sp, align 8
  %22 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %22, i32 0, i32 0
  %23 = load %struct.op*, %struct.op** %op_next, align 8
  ret %struct.op* %23
}

declare i32 @Perl_do_trans(%struct.sv*) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_schop() #0 {
entry:
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %tmp = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 3
  %2 = load i64, i64* %op_targ, align 8
  %3 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 %2
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %4, %struct.sv** %targ, align 8
  %5 = load %struct.sv*, %struct.sv** %targ, align 8
  %6 = load %struct.sv**, %struct.sv*** %sp, align 8
  %7 = load %struct.sv*, %struct.sv** %6, align 8
  call void @Perl_do_chop(%struct.sv* %5, %struct.sv* %7)
  %8 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %8, i32 0, i32 2
  %9 = load i32, i32* %sv_flags, align 4
  %and = and i32 %9, 16384
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %10 = load %struct.sv*, %struct.sv** %targ, align 8
  %call = call i32 @Perl_mg_set(%struct.sv* %10)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %11 = load %struct.sv*, %struct.sv** %targ, align 8
  %12 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %11, %struct.sv** %12, align 8
  store %struct.sv* %11, %struct.sv** %tmp
  %13 = load %struct.sv*, %struct.sv** %tmp
  %14 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %14, %struct.sv*** @PL_stack_sp, align 8
  %15 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %15, i32 0, i32 0
  %16 = load %struct.op*, %struct.op** %op_next, align 8
  ret %struct.op* %16
}

declare void @Perl_do_chop(%struct.sv*, %struct.sv*) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_chop() #0 {
entry:
  %sp = alloca %struct.sv**, align 8
  %mark = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %origmark = alloca i32, align 4
  %tmp = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %2 = load i32*, i32** @PL_markstack_ptr, align 8
  %incdec.ptr = getelementptr inbounds i32, i32* %2, i32 -1
  store i32* %incdec.ptr, i32** @PL_markstack_ptr, align 8
  %3 = load i32, i32* %2, align 4
  %idx.ext = sext i32 %3 to i64
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %1, i64 %idx.ext
  store %struct.sv** %add.ptr, %struct.sv*** %mark, align 8
  %4 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %4, i32 0, i32 3
  %5 = load i64, i64* %op_targ, align 8
  %6 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %6, i64 %5
  %7 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %7, %struct.sv** %targ, align 8
  %8 = load %struct.sv**, %struct.sv*** %mark, align 8
  %9 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %8 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %9 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %conv = trunc i64 %sub.ptr.div to i32
  store i32 %conv, i32* %origmark, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %10 = load %struct.sv**, %struct.sv*** %mark, align 8
  %11 = load %struct.sv**, %struct.sv*** %sp, align 8
  %cmp = icmp ult %struct.sv** %10, %11
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %12 = load %struct.sv*, %struct.sv** %targ, align 8
  %13 = load %struct.sv**, %struct.sv*** %mark, align 8
  %incdec.ptr2 = getelementptr inbounds %struct.sv*, %struct.sv** %13, i32 1
  store %struct.sv** %incdec.ptr2, %struct.sv*** %mark, align 8
  %14 = load %struct.sv*, %struct.sv** %incdec.ptr2, align 8
  call void @Perl_do_chop(%struct.sv* %12, %struct.sv* %14)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %15 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %16 = load i32, i32* %origmark, align 4
  %idx.ext3 = sext i32 %16 to i64
  %add.ptr4 = getelementptr inbounds %struct.sv*, %struct.sv** %15, i64 %idx.ext3
  store %struct.sv** %add.ptr4, %struct.sv*** %sp, align 8
  %17 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %17, i32 0, i32 2
  %18 = load i32, i32* %sv_flags, align 4
  %and = and i32 %18, 16384
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %while.end
  %19 = load %struct.sv*, %struct.sv** %targ, align 8
  %call = call i32 @Perl_mg_set(%struct.sv* %19)
  br label %if.end

if.end:                                           ; preds = %if.then, %while.end
  %20 = load %struct.sv*, %struct.sv** %targ, align 8
  %21 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr5 = getelementptr inbounds %struct.sv*, %struct.sv** %21, i32 1
  store %struct.sv** %incdec.ptr5, %struct.sv*** %sp, align 8
  store %struct.sv* %20, %struct.sv** %incdec.ptr5, align 8
  store %struct.sv* %20, %struct.sv** %tmp
  %22 = load %struct.sv*, %struct.sv** %tmp
  %23 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %23, %struct.sv*** @PL_stack_sp, align 8
  %24 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %24, i32 0, i32 0
  %25 = load %struct.op*, %struct.op** %op_next, align 8
  ret %struct.op* %25
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_schomp() #0 {
entry:
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %tmp = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 3
  %2 = load i64, i64* %op_targ, align 8
  %3 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 %2
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %4, %struct.sv** %targ, align 8
  %5 = load %struct.sv*, %struct.sv** %targ, align 8
  %6 = load %struct.sv**, %struct.sv*** %sp, align 8
  %7 = load %struct.sv*, %struct.sv** %6, align 8
  %call = call i32 @Perl_do_chomp(%struct.sv* %7)
  %conv = sext i32 %call to i64
  call void @Perl_sv_setiv(%struct.sv* %5, i64 %conv)
  %8 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %8, i32 0, i32 2
  %9 = load i32, i32* %sv_flags, align 4
  %and = and i32 %9, 16384
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %10 = load %struct.sv*, %struct.sv** %targ, align 8
  %call1 = call i32 @Perl_mg_set(%struct.sv* %10)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %11 = load %struct.sv*, %struct.sv** %targ, align 8
  %12 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %11, %struct.sv** %12, align 8
  store %struct.sv* %11, %struct.sv** %tmp
  %13 = load %struct.sv*, %struct.sv** %tmp
  %14 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %14, %struct.sv*** @PL_stack_sp, align 8
  %15 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %15, i32 0, i32 0
  %16 = load %struct.op*, %struct.op** %op_next, align 8
  ret %struct.op* %16
}

declare i32 @Perl_do_chomp(%struct.sv*) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_chomp() #0 {
entry:
  %sp = alloca %struct.sv**, align 8
  %mark = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %count = alloca i32, align 4
  %tmp = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %2 = load i32*, i32** @PL_markstack_ptr, align 8
  %incdec.ptr = getelementptr inbounds i32, i32* %2, i32 -1
  store i32* %incdec.ptr, i32** @PL_markstack_ptr, align 8
  %3 = load i32, i32* %2, align 4
  %idx.ext = sext i32 %3 to i64
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %1, i64 %idx.ext
  store %struct.sv** %add.ptr, %struct.sv*** %mark, align 8
  %4 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %4, i32 0, i32 3
  %5 = load i64, i64* %op_targ, align 8
  %6 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %6, i64 %5
  %7 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %7, %struct.sv** %targ, align 8
  store i32 0, i32* %count, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %8 = load %struct.sv**, %struct.sv*** %sp, align 8
  %9 = load %struct.sv**, %struct.sv*** %mark, align 8
  %cmp = icmp ugt %struct.sv** %8, %9
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %10 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr1 = getelementptr inbounds %struct.sv*, %struct.sv** %10, i32 -1
  store %struct.sv** %incdec.ptr1, %struct.sv*** %sp, align 8
  %11 = load %struct.sv*, %struct.sv** %10, align 8
  %call = call i32 @Perl_do_chomp(%struct.sv* %11)
  %12 = load i32, i32* %count, align 4
  %add = add nsw i32 %12, %call
  store i32 %add, i32* %count, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %13 = load %struct.sv*, %struct.sv** %targ, align 8
  %14 = load i32, i32* %count, align 4
  %conv = sext i32 %14 to i64
  call void @Perl_sv_setiv(%struct.sv* %13, i64 %conv)
  %15 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %15, i32 0, i32 2
  %16 = load i32, i32* %sv_flags, align 4
  %and = and i32 %16, 16384
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %while.end
  %17 = load %struct.sv*, %struct.sv** %targ, align 8
  %call2 = call i32 @Perl_mg_set(%struct.sv* %17)
  br label %if.end

if.end:                                           ; preds = %if.then, %while.end
  %18 = load %struct.sv*, %struct.sv** %targ, align 8
  %19 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr3 = getelementptr inbounds %struct.sv*, %struct.sv** %19, i32 1
  store %struct.sv** %incdec.ptr3, %struct.sv*** %sp, align 8
  store %struct.sv* %18, %struct.sv** %incdec.ptr3, align 8
  store %struct.sv* %18, %struct.sv** %tmp
  %20 = load %struct.sv*, %struct.sv** %tmp
  %21 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %21, %struct.sv*** @PL_stack_sp, align 8
  %22 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %22, i32 0, i32 0
  %23 = load %struct.op*, %struct.op** %op_next, align 8
  ret %struct.op* %23
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_defined() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %sv = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %1, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %2 = load %struct.sv*, %struct.sv** %1, align 8
  store %struct.sv* %2, %struct.sv** %sv, align 8
  %3 = load %struct.sv*, %struct.sv** %sv, align 8
  %tobool = icmp ne %struct.sv* %3, null
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %4 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %4, i32 0, i32 0
  %5 = load i8*, i8** %sv_any, align 8
  %tobool1 = icmp ne i8* %5, null
  br i1 %tobool1, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  %6 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr2 = getelementptr inbounds %struct.sv*, %struct.sv** %6, i32 1
  store %struct.sv** %incdec.ptr2, %struct.sv*** %sp, align 8
  store %struct.sv* @PL_sv_no, %struct.sv** %incdec.ptr2, align 8
  %7 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %7, %struct.sv*** @PL_stack_sp, align 8
  %8 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %8, i32 0, i32 0
  %9 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %9, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %10 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %10, i32 0, i32 2
  %11 = load i32, i32* %sv_flags, align 4
  %and = and i32 %11, 255
  switch i32 %and, label %sw.default [
    i32 10, label %sw.bb
    i32 11, label %sw.bb.17
    i32 12, label %sw.bb.35
  ]

sw.bb:                                            ; preds = %if.end
  %12 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any3 = getelementptr inbounds %struct.sv, %struct.sv* %12, i32 0, i32 0
  %13 = load i8*, i8** %sv_any3, align 8
  %14 = bitcast i8* %13 to %struct.xpvav*
  %xav_max = getelementptr inbounds %struct.xpvav, %struct.xpvav* %14, i32 0, i32 2
  %15 = load i64, i64* %xav_max, align 8
  %cmp = icmp sge i64 %15, 0
  br i1 %cmp, label %if.then.13, label %lor.lhs.false.4

lor.lhs.false.4:                                  ; preds = %sw.bb
  %16 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags5 = getelementptr inbounds %struct.sv, %struct.sv* %16, i32 0, i32 2
  %17 = load i32, i32* %sv_flags5, align 4
  %and6 = and i32 %17, 8192
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %if.then.13, label %lor.lhs.false.8

lor.lhs.false.8:                                  ; preds = %lor.lhs.false.4
  %18 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags9 = getelementptr inbounds %struct.sv, %struct.sv* %18, i32 0, i32 2
  %19 = load i32, i32* %sv_flags9, align 4
  %and10 = and i32 %19, 32768
  %tobool11 = icmp ne i32 %and10, 0
  br i1 %tobool11, label %land.lhs.true, label %if.end.16

land.lhs.true:                                    ; preds = %lor.lhs.false.8
  %20 = load %struct.sv*, %struct.sv** %sv, align 8
  %call = call %struct.magic* @Perl_mg_find(%struct.sv* %20, i32 80)
  %tobool12 = icmp ne %struct.magic* %call, null
  br i1 %tobool12, label %if.then.13, label %if.end.16

if.then.13:                                       ; preds = %land.lhs.true, %lor.lhs.false.4, %sw.bb
  %21 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr14 = getelementptr inbounds %struct.sv*, %struct.sv** %21, i32 1
  store %struct.sv** %incdec.ptr14, %struct.sv*** %sp, align 8
  store %struct.sv* @PL_sv_yes, %struct.sv** %incdec.ptr14, align 8
  %22 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %22, %struct.sv*** @PL_stack_sp, align 8
  %23 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next15 = getelementptr inbounds %struct.op, %struct.op* %23, i32 0, i32 0
  %24 = load %struct.op*, %struct.op** %op_next15, align 8
  store %struct.op* %24, %struct.op** %retval
  br label %return

if.end.16:                                        ; preds = %land.lhs.true, %lor.lhs.false.8
  br label %sw.epilog

sw.bb.17:                                         ; preds = %if.end
  %25 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any18 = getelementptr inbounds %struct.sv, %struct.sv* %25, i32 0, i32 0
  %26 = load i8*, i8** %sv_any18, align 8
  %27 = bitcast i8* %26 to %struct.xpvhv*
  %xhv_array = getelementptr inbounds %struct.xpvhv, %struct.xpvhv* %27, i32 0, i32 0
  %28 = bitcast i8** %xhv_array to %struct.he***
  %29 = load %struct.he**, %struct.he*** %28, align 8
  %tobool19 = icmp ne %struct.he** %29, null
  br i1 %tobool19, label %if.then.31, label %lor.lhs.false.20

lor.lhs.false.20:                                 ; preds = %sw.bb.17
  %30 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags21 = getelementptr inbounds %struct.sv, %struct.sv* %30, i32 0, i32 2
  %31 = load i32, i32* %sv_flags21, align 4
  %and22 = and i32 %31, 8192
  %tobool23 = icmp ne i32 %and22, 0
  br i1 %tobool23, label %if.then.31, label %lor.lhs.false.24

lor.lhs.false.24:                                 ; preds = %lor.lhs.false.20
  %32 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags25 = getelementptr inbounds %struct.sv, %struct.sv* %32, i32 0, i32 2
  %33 = load i32, i32* %sv_flags25, align 4
  %and26 = and i32 %33, 32768
  %tobool27 = icmp ne i32 %and26, 0
  br i1 %tobool27, label %land.lhs.true.28, label %if.end.34

land.lhs.true.28:                                 ; preds = %lor.lhs.false.24
  %34 = load %struct.sv*, %struct.sv** %sv, align 8
  %call29 = call %struct.magic* @Perl_mg_find(%struct.sv* %34, i32 80)
  %tobool30 = icmp ne %struct.magic* %call29, null
  br i1 %tobool30, label %if.then.31, label %if.end.34

if.then.31:                                       ; preds = %land.lhs.true.28, %lor.lhs.false.20, %sw.bb.17
  %35 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr32 = getelementptr inbounds %struct.sv*, %struct.sv** %35, i32 1
  store %struct.sv** %incdec.ptr32, %struct.sv*** %sp, align 8
  store %struct.sv* @PL_sv_yes, %struct.sv** %incdec.ptr32, align 8
  %36 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %36, %struct.sv*** @PL_stack_sp, align 8
  %37 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next33 = getelementptr inbounds %struct.op, %struct.op* %37, i32 0, i32 0
  %38 = load %struct.op*, %struct.op** %op_next33, align 8
  store %struct.op* %38, %struct.op** %retval
  br label %return

if.end.34:                                        ; preds = %land.lhs.true.28, %lor.lhs.false.24
  br label %sw.epilog

sw.bb.35:                                         ; preds = %if.end
  %39 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any36 = getelementptr inbounds %struct.sv, %struct.sv* %39, i32 0, i32 0
  %40 = load i8*, i8** %sv_any36, align 8
  %41 = bitcast i8* %40 to %struct.xpvcv*
  %xcv_root = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %41, i32 0, i32 9
  %42 = load %struct.op*, %struct.op** %xcv_root, align 8
  %tobool37 = icmp ne %struct.op* %42, null
  br i1 %tobool37, label %if.then.41, label %lor.lhs.false.38

lor.lhs.false.38:                                 ; preds = %sw.bb.35
  %43 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any39 = getelementptr inbounds %struct.sv, %struct.sv* %43, i32 0, i32 0
  %44 = load i8*, i8** %sv_any39, align 8
  %45 = bitcast i8* %44 to %struct.xpvcv*
  %xcv_xsub = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %45, i32 0, i32 10
  %46 = load void (%struct.cv*)*, void (%struct.cv*)** %xcv_xsub, align 8
  %tobool40 = icmp ne void (%struct.cv*)* %46, null
  br i1 %tobool40, label %if.then.41, label %if.end.44

if.then.41:                                       ; preds = %lor.lhs.false.38, %sw.bb.35
  %47 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr42 = getelementptr inbounds %struct.sv*, %struct.sv** %47, i32 1
  store %struct.sv** %incdec.ptr42, %struct.sv*** %sp, align 8
  store %struct.sv* @PL_sv_yes, %struct.sv** %incdec.ptr42, align 8
  %48 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %48, %struct.sv*** @PL_stack_sp, align 8
  %49 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next43 = getelementptr inbounds %struct.op, %struct.op* %49, i32 0, i32 0
  %50 = load %struct.op*, %struct.op** %op_next43, align 8
  store %struct.op* %50, %struct.op** %retval
  br label %return

if.end.44:                                        ; preds = %lor.lhs.false.38
  br label %sw.epilog

sw.default:                                       ; preds = %if.end
  %51 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags45 = getelementptr inbounds %struct.sv, %struct.sv* %51, i32 0, i32 2
  %52 = load i32, i32* %sv_flags45, align 4
  %and46 = and i32 %52, 8192
  %tobool47 = icmp ne i32 %and46, 0
  br i1 %tobool47, label %if.then.48, label %if.end.50

if.then.48:                                       ; preds = %sw.default
  %53 = load %struct.sv*, %struct.sv** %sv, align 8
  %call49 = call i32 @Perl_mg_get(%struct.sv* %53)
  br label %if.end.50

if.end.50:                                        ; preds = %if.then.48, %sw.default
  %54 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags51 = getelementptr inbounds %struct.sv, %struct.sv* %54, i32 0, i32 2
  %55 = load i32, i32* %sv_flags51, align 4
  %and52 = and i32 %55, 118423552
  %tobool53 = icmp ne i32 %and52, 0
  br i1 %tobool53, label %if.then.54, label %if.end.57

if.then.54:                                       ; preds = %if.end.50
  %56 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr55 = getelementptr inbounds %struct.sv*, %struct.sv** %56, i32 1
  store %struct.sv** %incdec.ptr55, %struct.sv*** %sp, align 8
  store %struct.sv* @PL_sv_yes, %struct.sv** %incdec.ptr55, align 8
  %57 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %57, %struct.sv*** @PL_stack_sp, align 8
  %58 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next56 = getelementptr inbounds %struct.op, %struct.op* %58, i32 0, i32 0
  %59 = load %struct.op*, %struct.op** %op_next56, align 8
  store %struct.op* %59, %struct.op** %retval
  br label %return

if.end.57:                                        ; preds = %if.end.50
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end.57, %if.end.44, %if.end.34, %if.end.16
  %60 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr58 = getelementptr inbounds %struct.sv*, %struct.sv** %60, i32 1
  store %struct.sv** %incdec.ptr58, %struct.sv*** %sp, align 8
  store %struct.sv* @PL_sv_no, %struct.sv** %incdec.ptr58, align 8
  %61 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %61, %struct.sv*** @PL_stack_sp, align 8
  %62 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next59 = getelementptr inbounds %struct.op, %struct.op* %62, i32 0, i32 0
  %63 = load %struct.op*, %struct.op** %op_next59, align 8
  store %struct.op* %63, %struct.op** %retval
  br label %return

return:                                           ; preds = %sw.epilog, %if.then.54, %if.then.41, %if.then.31, %if.then.13, %if.then
  %64 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %64
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_undef() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %sv = alloca %struct.sv*, align 8
  %gv = alloca %struct.gv*, align 8
  %gp = alloca %struct.gp*, align 8
  %tmp = alloca i8*, align 8
  %tmp115 = alloca i64, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 7
  %2 = load i8, i8* %op_private, align 1
  %tobool = icmp ne i8 %2, 0
  br i1 %tobool, label %if.end.2, label %if.then

if.then:                                          ; preds = %entry
  %3 = load %struct.sv**, %struct.sv*** @PL_stack_max, align 8
  %4 = load %struct.sv**, %struct.sv*** %sp, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %3 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %4 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %cmp = icmp slt i64 %sub.ptr.div, 1
  br i1 %cmp, label %if.then.1, label %if.end

if.then.1:                                        ; preds = %if.then
  %5 = load %struct.sv**, %struct.sv*** %sp, align 8
  %6 = load %struct.sv**, %struct.sv*** %sp, align 8
  %call = call %struct.sv** @Perl_stack_grow(%struct.sv** %5, %struct.sv** %6, i32 1)
  store %struct.sv** %call, %struct.sv*** %sp, align 8
  br label %if.end

if.end:                                           ; preds = %if.then.1, %if.then
  %7 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %7, i32 1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  store %struct.sv* @PL_sv_undef, %struct.sv** %incdec.ptr, align 8
  %8 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %8, %struct.sv*** @PL_stack_sp, align 8
  %9 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %9, i32 0, i32 0
  %10 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %10, %struct.op** %retval
  br label %return

if.end.2:                                         ; preds = %entry
  %11 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr3 = getelementptr inbounds %struct.sv*, %struct.sv** %11, i32 -1
  store %struct.sv** %incdec.ptr3, %struct.sv*** %sp, align 8
  %12 = load %struct.sv*, %struct.sv** %11, align 8
  store %struct.sv* %12, %struct.sv** %sv, align 8
  %13 = load %struct.sv*, %struct.sv** %sv, align 8
  %tobool4 = icmp ne %struct.sv* %13, null
  br i1 %tobool4, label %if.end.8, label %if.then.5

if.then.5:                                        ; preds = %if.end.2
  %14 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr6 = getelementptr inbounds %struct.sv*, %struct.sv** %14, i32 1
  store %struct.sv** %incdec.ptr6, %struct.sv*** %sp, align 8
  store %struct.sv* @PL_sv_undef, %struct.sv** %incdec.ptr6, align 8
  %15 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %15, %struct.sv*** @PL_stack_sp, align 8
  %16 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next7 = getelementptr inbounds %struct.op, %struct.op* %16, i32 0, i32 0
  %17 = load %struct.op*, %struct.op** %op_next7, align 8
  store %struct.op* %17, %struct.op** %retval
  br label %return

if.end.8:                                         ; preds = %if.end.2
  %18 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %18, i32 0, i32 2
  %19 = load i32, i32* %sv_flags, align 4
  %and = and i32 %19, 9961472
  %tobool9 = icmp ne i32 %and, 0
  br i1 %tobool9, label %if.then.10, label %if.end.11

if.then.10:                                       ; preds = %if.end.8
  %20 = load %struct.sv*, %struct.sv** %sv, align 8
  call void @Perl_sv_force_normal(%struct.sv* %20)
  br label %if.end.11

if.end.11:                                        ; preds = %if.then.10, %if.end.8
  %21 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags12 = getelementptr inbounds %struct.sv, %struct.sv* %21, i32 0, i32 2
  %22 = load i32, i32* %sv_flags12, align 4
  %and13 = and i32 %22, 255
  switch i32 %and13, label %sw.default [
    i32 0, label %sw.bb
    i32 10, label %sw.bb.14
    i32 11, label %sw.bb.15
    i32 12, label %sw.bb.16
    i32 14, label %sw.bb.58
    i32 13, label %sw.bb.63
  ]

sw.bb:                                            ; preds = %if.end.11
  br label %sw.epilog

sw.bb.14:                                         ; preds = %if.end.11
  %23 = load %struct.sv*, %struct.sv** %sv, align 8
  %24 = bitcast %struct.sv* %23 to %struct.av*
  call void @Perl_av_undef(%struct.av* %24)
  br label %sw.epilog

sw.bb.15:                                         ; preds = %if.end.11
  %25 = load %struct.sv*, %struct.sv** %sv, align 8
  %26 = bitcast %struct.sv* %25 to %struct.hv*
  call void @Perl_hv_undef(%struct.hv* %26)
  br label %sw.epilog

sw.bb.16:                                         ; preds = %if.end.11
  %27 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings = getelementptr inbounds %struct.cop, %struct.cop* %27, i32 0, i32 14
  %28 = load %struct.sv*, %struct.sv** %cop_warnings, align 8
  %cmp17 = icmp ne %struct.sv* %28, null
  br i1 %cmp17, label %land.lhs.true, label %lor.lhs.false.26

land.lhs.true:                                    ; preds = %sw.bb.16
  %29 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings18 = getelementptr inbounds %struct.cop, %struct.cop* %29, i32 0, i32 14
  %30 = load %struct.sv*, %struct.sv** %cop_warnings18, align 8
  %cmp19 = icmp ne %struct.sv* %30, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 2)
  br i1 %cmp19, label %land.lhs.true.20, label %lor.lhs.false.26

land.lhs.true.20:                                 ; preds = %land.lhs.true
  %31 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings21 = getelementptr inbounds %struct.cop, %struct.cop* %31, i32 0, i32 14
  %32 = load %struct.sv*, %struct.sv** %cop_warnings21, align 8
  %cmp22 = icmp eq %struct.sv* %32, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 1)
  br i1 %cmp22, label %land.lhs.true.34, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true.20
  %33 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings23 = getelementptr inbounds %struct.cop, %struct.cop* %33, i32 0, i32 14
  %34 = load %struct.sv*, %struct.sv** %cop_warnings23, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %34, i32 0, i32 0
  %35 = load i8*, i8** %sv_any, align 8
  %36 = bitcast i8* %35 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %36, i32 0, i32 0
  %37 = load i8*, i8** %xpv_pv, align 8
  %arrayidx = getelementptr inbounds i8, i8* %37, i64 3
  %38 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %38 to i32
  %and24 = and i32 %conv, 1
  %tobool25 = icmp ne i32 %and24, 0
  br i1 %tobool25, label %land.lhs.true.34, label %lor.lhs.false.26

lor.lhs.false.26:                                 ; preds = %lor.lhs.false, %land.lhs.true, %sw.bb.16
  %39 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings27 = getelementptr inbounds %struct.cop, %struct.cop* %39, i32 0, i32 14
  %40 = load %struct.sv*, %struct.sv** %cop_warnings27, align 8
  %cmp28 = icmp eq %struct.sv* %40, null
  br i1 %cmp28, label %land.lhs.true.30, label %if.end.57

land.lhs.true.30:                                 ; preds = %lor.lhs.false.26
  %41 = load i8, i8* @PL_dowarn, align 1
  %conv31 = zext i8 %41 to i32
  %and32 = and i32 %conv31, 1
  %tobool33 = icmp ne i32 %and32, 0
  br i1 %tobool33, label %land.lhs.true.34, label %if.end.57

land.lhs.true.34:                                 ; preds = %land.lhs.true.30, %lor.lhs.false, %land.lhs.true.20
  %42 = load %struct.sv*, %struct.sv** %sv, align 8
  %43 = bitcast %struct.sv* %42 to %struct.cv*
  %call35 = call %struct.sv* @Perl_cv_const_sv(%struct.cv* %43)
  %tobool36 = icmp ne %struct.sv* %call35, null
  br i1 %tobool36, label %if.then.37, label %if.end.57

if.then.37:                                       ; preds = %land.lhs.true.34
  %44 = load %struct.sv*, %struct.sv** %sv, align 8
  %45 = bitcast %struct.sv* %44 to %struct.cv*
  %sv_any38 = getelementptr inbounds %struct.cv, %struct.cv* %45, i32 0, i32 0
  %46 = load %struct.xpvcv*, %struct.xpvcv** %sv_any38, align 8
  %xcv_flags = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %46, i32 0, i32 17
  %47 = load i16, i16* %xcv_flags, align 2
  %conv39 = zext i16 %47 to i32
  %and40 = and i32 %conv39, 4
  %tobool41 = icmp ne i32 %and40, 0
  br i1 %tobool41, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.37
  br label %cond.end.55

cond.false:                                       ; preds = %if.then.37
  %48 = load %struct.sv*, %struct.sv** %sv, align 8
  %49 = bitcast %struct.sv* %48 to %struct.cv*
  %sv_any42 = getelementptr inbounds %struct.cv, %struct.cv* %49, i32 0, i32 0
  %50 = load %struct.xpvcv*, %struct.xpvcv** %sv_any42, align 8
  %xcv_gv = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %50, i32 0, i32 12
  %51 = load %struct.gv*, %struct.gv** %xcv_gv, align 8
  %sv_any43 = getelementptr inbounds %struct.gv, %struct.gv* %51, i32 0, i32 0
  %52 = load %struct.xpvgv*, %struct.xpvgv** %sv_any43, align 8
  %xgv_gp = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %52, i32 0, i32 7
  %53 = load %struct.gp*, %struct.gp** %xgv_gp, align 8
  %gp_egv = getelementptr inbounds %struct.gp, %struct.gp* %53, i32 0, i32 6
  %54 = load %struct.gv*, %struct.gv** %gp_egv, align 8
  %tobool44 = icmp ne %struct.gv* %54, null
  br i1 %tobool44, label %cond.true.45, label %cond.false.51

cond.true.45:                                     ; preds = %cond.false
  %55 = load %struct.sv*, %struct.sv** %sv, align 8
  %56 = bitcast %struct.sv* %55 to %struct.cv*
  %sv_any46 = getelementptr inbounds %struct.cv, %struct.cv* %56, i32 0, i32 0
  %57 = load %struct.xpvcv*, %struct.xpvcv** %sv_any46, align 8
  %xcv_gv47 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %57, i32 0, i32 12
  %58 = load %struct.gv*, %struct.gv** %xcv_gv47, align 8
  %sv_any48 = getelementptr inbounds %struct.gv, %struct.gv* %58, i32 0, i32 0
  %59 = load %struct.xpvgv*, %struct.xpvgv** %sv_any48, align 8
  %xgv_gp49 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %59, i32 0, i32 7
  %60 = load %struct.gp*, %struct.gp** %xgv_gp49, align 8
  %gp_egv50 = getelementptr inbounds %struct.gp, %struct.gp* %60, i32 0, i32 6
  %61 = load %struct.gv*, %struct.gv** %gp_egv50, align 8
  br label %cond.end

cond.false.51:                                    ; preds = %cond.false
  %62 = load %struct.sv*, %struct.sv** %sv, align 8
  %63 = bitcast %struct.sv* %62 to %struct.cv*
  %sv_any52 = getelementptr inbounds %struct.cv, %struct.cv* %63, i32 0, i32 0
  %64 = load %struct.xpvcv*, %struct.xpvcv** %sv_any52, align 8
  %xcv_gv53 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %64, i32 0, i32 12
  %65 = load %struct.gv*, %struct.gv** %xcv_gv53, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false.51, %cond.true.45
  %cond = phi %struct.gv* [ %61, %cond.true.45 ], [ %65, %cond.false.51 ]
  %sv_any54 = getelementptr inbounds %struct.gv, %struct.gv* %cond, i32 0, i32 0
  %66 = load %struct.xpvgv*, %struct.xpvgv** %sv_any54, align 8
  %xgv_name = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %66, i32 0, i32 8
  %67 = load i8*, i8** %xgv_name, align 8
  br label %cond.end.55

cond.end.55:                                      ; preds = %cond.end, %cond.true
  %cond56 = phi i8* [ getelementptr inbounds ([12 x i8], [12 x i8]* @.str.28, i32 0, i32 0), %cond.true ], [ %67, %cond.end ]
  call void (i32, i8*, ...) @Perl_warner(i32 12, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.27, i32 0, i32 0), i8* %cond56)
  br label %if.end.57

if.end.57:                                        ; preds = %cond.end.55, %land.lhs.true.34, %land.lhs.true.30, %lor.lhs.false.26
  br label %sw.bb.58

sw.bb.58:                                         ; preds = %if.end.11, %if.end.57
  %68 = load %struct.sv*, %struct.sv** %sv, align 8
  %69 = bitcast %struct.sv* %68 to %struct.cv*
  %sv_any59 = getelementptr inbounds %struct.cv, %struct.cv* %69, i32 0, i32 0
  %70 = load %struct.xpvcv*, %struct.xpvcv** %sv_any59, align 8
  %xcv_gv60 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %70, i32 0, i32 12
  %71 = load %struct.gv*, %struct.gv** %xcv_gv60, align 8
  store %struct.gv* %71, %struct.gv** %gv, align 8
  %72 = load %struct.sv*, %struct.sv** %sv, align 8
  %73 = bitcast %struct.sv* %72 to %struct.cv*
  call void @Perl_cv_undef(%struct.cv* %73)
  %74 = load %struct.gv*, %struct.gv** %gv, align 8
  %75 = load %struct.sv*, %struct.sv** %sv, align 8
  %76 = bitcast %struct.sv* %75 to %struct.cv*
  %sv_any61 = getelementptr inbounds %struct.cv, %struct.cv* %76, i32 0, i32 0
  %77 = load %struct.xpvcv*, %struct.xpvcv** %sv_any61, align 8
  %xcv_gv62 = getelementptr inbounds %struct.xpvcv, %struct.xpvcv* %77, i32 0, i32 12
  store %struct.gv* %74, %struct.gv** %xcv_gv62, align 8
  br label %sw.epilog

sw.bb.63:                                         ; preds = %if.end.11
  %78 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags64 = getelementptr inbounds %struct.sv, %struct.sv* %78, i32 0, i32 2
  %79 = load i32, i32* %sv_flags64, align 4
  %and65 = and i32 %79, 1048576
  %tobool66 = icmp ne i32 %and65, 0
  br i1 %tobool66, label %if.then.67, label %if.else

if.then.67:                                       ; preds = %sw.bb.63
  %80 = load %struct.sv*, %struct.sv** %sv, align 8
  %cmp68 = icmp ne %struct.sv* %80, @PL_sv_undef
  br i1 %cmp68, label %if.then.70, label %if.end.77

if.then.70:                                       ; preds = %if.then.67
  %81 = load %struct.sv*, %struct.sv** %sv, align 8
  call void @Perl_sv_setsv_flags(%struct.sv* %81, %struct.sv* @PL_sv_undef, i32 2)
  %82 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags71 = getelementptr inbounds %struct.sv, %struct.sv* %82, i32 0, i32 2
  %83 = load i32, i32* %sv_flags71, align 4
  %and72 = and i32 %83, 16384
  %tobool73 = icmp ne i32 %and72, 0
  br i1 %tobool73, label %if.then.74, label %if.end.76

if.then.74:                                       ; preds = %if.then.70
  %84 = load %struct.sv*, %struct.sv** %sv, align 8
  %call75 = call i32 @Perl_mg_set(%struct.sv* %84)
  br label %if.end.76

if.end.76:                                        ; preds = %if.then.74, %if.then.70
  br label %if.end.77

if.end.77:                                        ; preds = %if.end.76, %if.then.67
  br label %if.end.93

if.else:                                          ; preds = %sw.bb.63
  %85 = load %struct.sv*, %struct.sv** %sv, align 8
  %86 = bitcast %struct.sv* %85 to %struct.gv*
  call void @Perl_gp_free(%struct.gv* %86)
  %call78 = call i8* @Perl_safesysmalloc(i64 88)
  %87 = bitcast i8* %call78 to %struct.gp*
  store %struct.gp* %87, %struct.gp** %gp, align 8
  %88 = load %struct.gp*, %struct.gp** %gp, align 8
  %89 = bitcast %struct.gp* %88 to i8*
  call void @llvm.memset.p0i8.i64(i8* %89, i8 0, i64 88, i32 1, i1 false)
  %90 = load %struct.gp*, %struct.gp** %gp, align 8
  %call79 = call %struct.gp* @Perl_gp_ref(%struct.gp* %90)
  %91 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any80 = getelementptr inbounds %struct.sv, %struct.sv* %91, i32 0, i32 0
  %92 = load i8*, i8** %sv_any80, align 8
  %93 = bitcast i8* %92 to %struct.xpvgv*
  %xgv_gp81 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %93, i32 0, i32 7
  store %struct.gp* %call79, %struct.gp** %xgv_gp81, align 8
  %call82 = call %struct.sv* @Perl_newSV(i64 0)
  %94 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any83 = getelementptr inbounds %struct.sv, %struct.sv* %94, i32 0, i32 0
  %95 = load i8*, i8** %sv_any83, align 8
  %96 = bitcast i8* %95 to %struct.xpvgv*
  %xgv_gp84 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %96, i32 0, i32 7
  %97 = load %struct.gp*, %struct.gp** %xgv_gp84, align 8
  %gp_sv = getelementptr inbounds %struct.gp, %struct.gp* %97, i32 0, i32 0
  store %struct.sv* %call82, %struct.sv** %gp_sv, align 8
  %98 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_line = getelementptr inbounds %struct.cop, %struct.cop* %98, i32 0, i32 13
  %99 = load i32, i32* %cop_line, align 4
  %100 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any85 = getelementptr inbounds %struct.sv, %struct.sv* %100, i32 0, i32 0
  %101 = load i8*, i8** %sv_any85, align 8
  %102 = bitcast i8* %101 to %struct.xpvgv*
  %xgv_gp86 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %102, i32 0, i32 7
  %103 = load %struct.gp*, %struct.gp** %xgv_gp86, align 8
  %gp_line = getelementptr inbounds %struct.gp, %struct.gp* %103, i32 0, i32 10
  store i32 %99, i32* %gp_line, align 4
  %104 = load %struct.sv*, %struct.sv** %sv, align 8
  %105 = bitcast %struct.sv* %104 to %struct.gv*
  %106 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any87 = getelementptr inbounds %struct.sv, %struct.sv* %106, i32 0, i32 0
  %107 = load i8*, i8** %sv_any87, align 8
  %108 = bitcast i8* %107 to %struct.xpvgv*
  %xgv_gp88 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %108, i32 0, i32 7
  %109 = load %struct.gp*, %struct.gp** %xgv_gp88, align 8
  %gp_egv89 = getelementptr inbounds %struct.gp, %struct.gp* %109, i32 0, i32 6
  store %struct.gv* %105, %struct.gv** %gp_egv89, align 8
  %110 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any90 = getelementptr inbounds %struct.sv, %struct.sv* %110, i32 0, i32 0
  %111 = load i8*, i8** %sv_any90, align 8
  %112 = bitcast i8* %111 to %struct.xpvgv*
  %xgv_flags = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %112, i32 0, i32 11
  %113 = load i8, i8* %xgv_flags, align 1
  %conv91 = zext i8 %113 to i32
  %or = or i32 %conv91, 2
  %conv92 = trunc i32 %or to i8
  store i8 %conv92, i8* %xgv_flags, align 1
  br label %if.end.93

if.end.93:                                        ; preds = %if.else, %if.end.77
  br label %sw.epilog

sw.default:                                       ; preds = %if.end.11
  %114 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags94 = getelementptr inbounds %struct.sv, %struct.sv* %114, i32 0, i32 2
  %115 = load i32, i32* %sv_flags94, align 4
  %and95 = and i32 %115, 255
  %cmp96 = icmp uge i32 %and95, 4
  br i1 %cmp96, label %land.lhs.true.98, label %if.end.118

land.lhs.true.98:                                 ; preds = %sw.default
  %116 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any99 = getelementptr inbounds %struct.sv, %struct.sv* %116, i32 0, i32 0
  %117 = load i8*, i8** %sv_any99, align 8
  %118 = bitcast i8* %117 to %struct.xpv*
  %xpv_pv100 = getelementptr inbounds %struct.xpv, %struct.xpv* %118, i32 0, i32 0
  %119 = load i8*, i8** %xpv_pv100, align 8
  %tobool101 = icmp ne i8* %119, null
  br i1 %tobool101, label %land.lhs.true.102, label %if.end.118

land.lhs.true.102:                                ; preds = %land.lhs.true.98
  %120 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any103 = getelementptr inbounds %struct.sv, %struct.sv* %120, i32 0, i32 0
  %121 = load i8*, i8** %sv_any103, align 8
  %122 = bitcast i8* %121 to %struct.xpv*
  %xpv_len = getelementptr inbounds %struct.xpv, %struct.xpv* %122, i32 0, i32 2
  %123 = load i64, i64* %xpv_len, align 8
  %tobool104 = icmp ne i64 %123, 0
  br i1 %tobool104, label %if.then.105, label %if.end.118

if.then.105:                                      ; preds = %land.lhs.true.102
  %124 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags106 = getelementptr inbounds %struct.sv, %struct.sv* %124, i32 0, i32 2
  %125 = load i32, i32* %sv_flags106, align 4
  %and107 = and i32 %125, 2097152
  %tobool108 = icmp ne i32 %and107, 0
  br i1 %tobool108, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then.105
  %126 = load %struct.sv*, %struct.sv** %sv, align 8
  %call109 = call i32 @Perl_sv_backoff(%struct.sv* %126)
  %tobool110 = icmp ne i32 %call109, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then.105
  %127 = phi i1 [ false, %if.then.105 ], [ %tobool110, %land.rhs ]
  %land.ext = zext i1 %127 to i32
  %128 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any111 = getelementptr inbounds %struct.sv, %struct.sv* %128, i32 0, i32 0
  %129 = load i8*, i8** %sv_any111, align 8
  %130 = bitcast i8* %129 to %struct.xpv*
  %xpv_pv112 = getelementptr inbounds %struct.xpv, %struct.xpv* %130, i32 0, i32 0
  %131 = load i8*, i8** %xpv_pv112, align 8
  call void @Perl_safesysfree(i8* %131)
  %132 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any113 = getelementptr inbounds %struct.sv, %struct.sv* %132, i32 0, i32 0
  %133 = load i8*, i8** %sv_any113, align 8
  %134 = bitcast i8* %133 to %struct.xpv*
  %xpv_pv114 = getelementptr inbounds %struct.xpv, %struct.xpv* %134, i32 0, i32 0
  store i8* null, i8** %xpv_pv114, align 8
  store i8* null, i8** %tmp
  %135 = load i8*, i8** %tmp
  %136 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any116 = getelementptr inbounds %struct.sv, %struct.sv* %136, i32 0, i32 0
  %137 = load i8*, i8** %sv_any116, align 8
  %138 = bitcast i8* %137 to %struct.xpv*
  %xpv_len117 = getelementptr inbounds %struct.xpv, %struct.xpv* %138, i32 0, i32 2
  store i64 0, i64* %xpv_len117, align 8
  store i64 0, i64* %tmp115
  %139 = load i64, i64* %tmp115
  br label %if.end.118

if.end.118:                                       ; preds = %land.end, %land.lhs.true.102, %land.lhs.true.98, %sw.default
  %140 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags119 = getelementptr inbounds %struct.sv, %struct.sv* %140, i32 0, i32 2
  %141 = load i32, i32* %sv_flags119, align 4
  %and120 = and i32 %141, 1223753727
  store i32 %and120, i32* %sv_flags119, align 4
  %142 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags121 = getelementptr inbounds %struct.sv, %struct.sv* %142, i32 0, i32 2
  %143 = load i32, i32* %sv_flags121, align 4
  %and122 = and i32 %143, 2097152
  %tobool123 = icmp ne i32 %and122, 0
  br i1 %tobool123, label %land.rhs.124, label %land.end.127

land.rhs.124:                                     ; preds = %if.end.118
  %144 = load %struct.sv*, %struct.sv** %sv, align 8
  %call125 = call i32 @Perl_sv_backoff(%struct.sv* %144)
  %tobool126 = icmp ne i32 %call125, 0
  br label %land.end.127

land.end.127:                                     ; preds = %land.rhs.124, %if.end.118
  %145 = phi i1 [ false, %if.end.118 ], [ %tobool126, %land.rhs.124 ]
  %land.ext128 = zext i1 %145 to i32
  %146 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags129 = getelementptr inbounds %struct.sv, %struct.sv* %146, i32 0, i32 2
  %147 = load i32, i32* %sv_flags129, align 4
  %and130 = and i32 %147, 16384
  %tobool131 = icmp ne i32 %and130, 0
  br i1 %tobool131, label %if.then.132, label %if.end.134

if.then.132:                                      ; preds = %land.end.127
  %148 = load %struct.sv*, %struct.sv** %sv, align 8
  %call133 = call i32 @Perl_mg_set(%struct.sv* %148)
  br label %if.end.134

if.end.134:                                       ; preds = %if.then.132, %land.end.127
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end.134, %if.end.93, %sw.bb.58, %sw.bb.15, %sw.bb.14, %sw.bb
  %149 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr135 = getelementptr inbounds %struct.sv*, %struct.sv** %149, i32 1
  store %struct.sv** %incdec.ptr135, %struct.sv*** %sp, align 8
  store %struct.sv* @PL_sv_undef, %struct.sv** %incdec.ptr135, align 8
  %150 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %150, %struct.sv*** @PL_stack_sp, align 8
  %151 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next136 = getelementptr inbounds %struct.op, %struct.op* %151, i32 0, i32 0
  %152 = load %struct.op*, %struct.op** %op_next136, align 8
  store %struct.op* %152, %struct.op** %retval
  br label %return

return:                                           ; preds = %sw.epilog, %if.then.5, %if.end
  %153 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %153
}

declare void @Perl_sv_force_normal(%struct.sv*) #1

declare void @Perl_av_undef(%struct.av*) #1

declare void @Perl_hv_undef(%struct.hv*) #1

declare %struct.sv* @Perl_cv_const_sv(%struct.cv*) #1

declare void @Perl_cv_undef(%struct.cv*) #1

declare void @Perl_sv_setsv_flags(%struct.sv*, %struct.sv*, i32) #1

declare void @Perl_gp_free(%struct.gv*) #1

; Function Attrs: nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture, i8, i64, i32, i1) #2

declare %struct.gp* @Perl_gp_ref(%struct.gp*) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_predec() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.sv**, %struct.sv*** %sp, align 8
  %2 = load %struct.sv*, %struct.sv** %1, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %2, i32 0, i32 2
  %3 = load i32, i32* %sv_flags, align 4
  %and = and i32 %3, 255
  %cmp = icmp ugt i32 %and, 9
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call %struct.op* (i8*, ...) @Perl_die(i8* getelementptr inbounds ([0 x i8], [0 x i8]* @PL_no_modify, i32 0, i32 0))
  store %struct.op* %call, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %entry
  %4 = load %struct.sv**, %struct.sv*** %sp, align 8
  %5 = load %struct.sv*, %struct.sv** %4, align 8
  %sv_flags1 = getelementptr inbounds %struct.sv, %struct.sv* %5, i32 0, i32 2
  %6 = load i32, i32* %sv_flags1, align 4
  %and2 = and i32 %6, 8388608
  %tobool = icmp ne i32 %and2, 0
  br i1 %tobool, label %if.else, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %7 = load %struct.sv**, %struct.sv*** %sp, align 8
  %8 = load %struct.sv*, %struct.sv** %7, align 8
  %sv_flags3 = getelementptr inbounds %struct.sv, %struct.sv* %8, i32 0, i32 2
  %9 = load i32, i32* %sv_flags3, align 4
  %and4 = and i32 %9, -2147418112
  %cmp5 = icmp eq i32 %and4, 65536
  br i1 %cmp5, label %land.lhs.true.6, label %if.else

land.lhs.true.6:                                  ; preds = %land.lhs.true
  %10 = load %struct.sv**, %struct.sv*** %sp, align 8
  %11 = load %struct.sv*, %struct.sv** %10, align 8
  %sv_flags7 = getelementptr inbounds %struct.sv, %struct.sv* %11, i32 0, i32 2
  %12 = load i32, i32* %sv_flags7, align 4
  %and8 = and i32 %12, 131072
  %tobool9 = icmp ne i32 %and8, 0
  br i1 %tobool9, label %if.else, label %land.lhs.true.10

land.lhs.true.10:                                 ; preds = %land.lhs.true.6
  %13 = load %struct.sv**, %struct.sv*** %sp, align 8
  %14 = load %struct.sv*, %struct.sv** %13, align 8
  %sv_flags11 = getelementptr inbounds %struct.sv, %struct.sv* %14, i32 0, i32 2
  %15 = load i32, i32* %sv_flags11, align 4
  %and12 = and i32 %15, 262144
  %tobool13 = icmp ne i32 %and12, 0
  br i1 %tobool13, label %if.else, label %land.lhs.true.14

land.lhs.true.14:                                 ; preds = %land.lhs.true.10
  %16 = load %struct.sv**, %struct.sv*** %sp, align 8
  %17 = load %struct.sv*, %struct.sv** %16, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %17, i32 0, i32 0
  %18 = load i8*, i8** %sv_any, align 8
  %19 = bitcast i8* %18 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %19, i32 0, i32 3
  %20 = load i64, i64* %xiv_iv, align 8
  %cmp15 = icmp ne i64 %20, -9223372036854775808
  br i1 %cmp15, label %if.then.16, label %if.else

if.then.16:                                       ; preds = %land.lhs.true.14
  %21 = load %struct.sv**, %struct.sv*** %sp, align 8
  %22 = load %struct.sv*, %struct.sv** %21, align 8
  %sv_any17 = getelementptr inbounds %struct.sv, %struct.sv* %22, i32 0, i32 0
  %23 = load i8*, i8** %sv_any17, align 8
  %24 = bitcast i8* %23 to %struct.xpviv*
  %xiv_iv18 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %24, i32 0, i32 3
  %25 = load i64, i64* %xiv_iv18, align 8
  %dec = add nsw i64 %25, -1
  store i64 %dec, i64* %xiv_iv18, align 8
  %26 = load %struct.sv**, %struct.sv*** %sp, align 8
  %27 = load %struct.sv*, %struct.sv** %26, align 8
  %sv_flags19 = getelementptr inbounds %struct.sv, %struct.sv* %27, i32 0, i32 2
  %28 = load i32, i32* %sv_flags19, align 4
  %and20 = and i32 %28, -100663297
  store i32 %and20, i32* %sv_flags19, align 4
  br label %if.end.21

if.else:                                          ; preds = %land.lhs.true.14, %land.lhs.true.10, %land.lhs.true.6, %land.lhs.true, %if.end
  %29 = load %struct.sv**, %struct.sv*** %sp, align 8
  %30 = load %struct.sv*, %struct.sv** %29, align 8
  call void @Perl_sv_dec(%struct.sv* %30)
  br label %if.end.21

if.end.21:                                        ; preds = %if.else, %if.then.16
  %31 = load %struct.sv**, %struct.sv*** %sp, align 8
  %32 = load %struct.sv*, %struct.sv** %31, align 8
  %sv_flags22 = getelementptr inbounds %struct.sv, %struct.sv* %32, i32 0, i32 2
  %33 = load i32, i32* %sv_flags22, align 4
  %and23 = and i32 %33, 16384
  %tobool24 = icmp ne i32 %and23, 0
  br i1 %tobool24, label %if.then.25, label %if.end.27

if.then.25:                                       ; preds = %if.end.21
  %34 = load %struct.sv**, %struct.sv*** %sp, align 8
  %35 = load %struct.sv*, %struct.sv** %34, align 8
  %call26 = call i32 @Perl_mg_set(%struct.sv* %35)
  br label %if.end.27

if.end.27:                                        ; preds = %if.then.25, %if.end.21
  %36 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %36, i32 0, i32 0
  %37 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %37, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.27, %if.then
  %38 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %38
}

declare void @Perl_sv_dec(%struct.sv*) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_postinc() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 3
  %2 = load i64, i64* %op_targ, align 8
  %3 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 %2
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %4, %struct.sv** %targ, align 8
  %5 = load %struct.sv**, %struct.sv*** %sp, align 8
  %6 = load %struct.sv*, %struct.sv** %5, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %6, i32 0, i32 2
  %7 = load i32, i32* %sv_flags, align 4
  %and = and i32 %7, 255
  %cmp = icmp ugt i32 %and, 9
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call %struct.op* (i8*, ...) @Perl_die(i8* getelementptr inbounds ([0 x i8], [0 x i8]* @PL_no_modify, i32 0, i32 0))
  store %struct.op* %call, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %entry
  %8 = load %struct.sv*, %struct.sv** %targ, align 8
  %9 = load %struct.sv**, %struct.sv*** %sp, align 8
  %10 = load %struct.sv*, %struct.sv** %9, align 8
  call void @Perl_sv_setsv_flags(%struct.sv* %8, %struct.sv* %10, i32 2)
  %11 = load %struct.sv**, %struct.sv*** %sp, align 8
  %12 = load %struct.sv*, %struct.sv** %11, align 8
  %sv_flags1 = getelementptr inbounds %struct.sv, %struct.sv* %12, i32 0, i32 2
  %13 = load i32, i32* %sv_flags1, align 4
  %and2 = and i32 %13, 8388608
  %tobool = icmp ne i32 %and2, 0
  br i1 %tobool, label %if.else, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %14 = load %struct.sv**, %struct.sv*** %sp, align 8
  %15 = load %struct.sv*, %struct.sv** %14, align 8
  %sv_flags3 = getelementptr inbounds %struct.sv, %struct.sv* %15, i32 0, i32 2
  %16 = load i32, i32* %sv_flags3, align 4
  %and4 = and i32 %16, -2147418112
  %cmp5 = icmp eq i32 %and4, 65536
  br i1 %cmp5, label %land.lhs.true.6, label %if.else

land.lhs.true.6:                                  ; preds = %land.lhs.true
  %17 = load %struct.sv**, %struct.sv*** %sp, align 8
  %18 = load %struct.sv*, %struct.sv** %17, align 8
  %sv_flags7 = getelementptr inbounds %struct.sv, %struct.sv* %18, i32 0, i32 2
  %19 = load i32, i32* %sv_flags7, align 4
  %and8 = and i32 %19, 131072
  %tobool9 = icmp ne i32 %and8, 0
  br i1 %tobool9, label %if.else, label %land.lhs.true.10

land.lhs.true.10:                                 ; preds = %land.lhs.true.6
  %20 = load %struct.sv**, %struct.sv*** %sp, align 8
  %21 = load %struct.sv*, %struct.sv** %20, align 8
  %sv_flags11 = getelementptr inbounds %struct.sv, %struct.sv* %21, i32 0, i32 2
  %22 = load i32, i32* %sv_flags11, align 4
  %and12 = and i32 %22, 262144
  %tobool13 = icmp ne i32 %and12, 0
  br i1 %tobool13, label %if.else, label %land.lhs.true.14

land.lhs.true.14:                                 ; preds = %land.lhs.true.10
  %23 = load %struct.sv**, %struct.sv*** %sp, align 8
  %24 = load %struct.sv*, %struct.sv** %23, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %24, i32 0, i32 0
  %25 = load i8*, i8** %sv_any, align 8
  %26 = bitcast i8* %25 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %26, i32 0, i32 3
  %27 = load i64, i64* %xiv_iv, align 8
  %cmp15 = icmp ne i64 %27, 9223372036854775807
  br i1 %cmp15, label %if.then.16, label %if.else

if.then.16:                                       ; preds = %land.lhs.true.14
  %28 = load %struct.sv**, %struct.sv*** %sp, align 8
  %29 = load %struct.sv*, %struct.sv** %28, align 8
  %sv_any17 = getelementptr inbounds %struct.sv, %struct.sv* %29, i32 0, i32 0
  %30 = load i8*, i8** %sv_any17, align 8
  %31 = bitcast i8* %30 to %struct.xpviv*
  %xiv_iv18 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %31, i32 0, i32 3
  %32 = load i64, i64* %xiv_iv18, align 8
  %inc = add nsw i64 %32, 1
  store i64 %inc, i64* %xiv_iv18, align 8
  %33 = load %struct.sv**, %struct.sv*** %sp, align 8
  %34 = load %struct.sv*, %struct.sv** %33, align 8
  %sv_flags19 = getelementptr inbounds %struct.sv, %struct.sv* %34, i32 0, i32 2
  %35 = load i32, i32* %sv_flags19, align 4
  %and20 = and i32 %35, -100663297
  store i32 %and20, i32* %sv_flags19, align 4
  br label %if.end.21

if.else:                                          ; preds = %land.lhs.true.14, %land.lhs.true.10, %land.lhs.true.6, %land.lhs.true, %if.end
  %36 = load %struct.sv**, %struct.sv*** %sp, align 8
  %37 = load %struct.sv*, %struct.sv** %36, align 8
  call void @Perl_sv_inc(%struct.sv* %37)
  br label %if.end.21

if.end.21:                                        ; preds = %if.else, %if.then.16
  %38 = load %struct.sv**, %struct.sv*** %sp, align 8
  %39 = load %struct.sv*, %struct.sv** %38, align 8
  %sv_flags22 = getelementptr inbounds %struct.sv, %struct.sv* %39, i32 0, i32 2
  %40 = load i32, i32* %sv_flags22, align 4
  %and23 = and i32 %40, 16384
  %tobool24 = icmp ne i32 %and23, 0
  br i1 %tobool24, label %if.then.25, label %if.end.27

if.then.25:                                       ; preds = %if.end.21
  %41 = load %struct.sv**, %struct.sv*** %sp, align 8
  %42 = load %struct.sv*, %struct.sv** %41, align 8
  %call26 = call i32 @Perl_mg_set(%struct.sv* %42)
  br label %if.end.27

if.end.27:                                        ; preds = %if.then.25, %if.end.21
  %43 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags28 = getelementptr inbounds %struct.sv, %struct.sv* %43, i32 0, i32 2
  %44 = load i32, i32* %sv_flags28, align 4
  %and29 = and i32 %44, 118423552
  %tobool30 = icmp ne i32 %and29, 0
  br i1 %tobool30, label %if.end.32, label %if.then.31

if.then.31:                                       ; preds = %if.end.27
  %45 = load %struct.sv*, %struct.sv** %targ, align 8
  call void @Perl_sv_setiv(%struct.sv* %45, i64 0)
  br label %if.end.32

if.end.32:                                        ; preds = %if.then.31, %if.end.27
  %46 = load %struct.sv*, %struct.sv** %targ, align 8
  %47 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %46, %struct.sv** %47, align 8
  %48 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %48, i32 0, i32 0
  %49 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %49, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.32, %if.then
  %50 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %50
}

declare void @Perl_sv_inc(%struct.sv*) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_postdec() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 3
  %2 = load i64, i64* %op_targ, align 8
  %3 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 %2
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %4, %struct.sv** %targ, align 8
  %5 = load %struct.sv**, %struct.sv*** %sp, align 8
  %6 = load %struct.sv*, %struct.sv** %5, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %6, i32 0, i32 2
  %7 = load i32, i32* %sv_flags, align 4
  %and = and i32 %7, 255
  %cmp = icmp ugt i32 %and, 9
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call %struct.op* (i8*, ...) @Perl_die(i8* getelementptr inbounds ([0 x i8], [0 x i8]* @PL_no_modify, i32 0, i32 0))
  store %struct.op* %call, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %entry
  %8 = load %struct.sv*, %struct.sv** %targ, align 8
  %9 = load %struct.sv**, %struct.sv*** %sp, align 8
  %10 = load %struct.sv*, %struct.sv** %9, align 8
  call void @Perl_sv_setsv_flags(%struct.sv* %8, %struct.sv* %10, i32 2)
  %11 = load %struct.sv**, %struct.sv*** %sp, align 8
  %12 = load %struct.sv*, %struct.sv** %11, align 8
  %sv_flags1 = getelementptr inbounds %struct.sv, %struct.sv* %12, i32 0, i32 2
  %13 = load i32, i32* %sv_flags1, align 4
  %and2 = and i32 %13, 8388608
  %tobool = icmp ne i32 %and2, 0
  br i1 %tobool, label %if.else, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %14 = load %struct.sv**, %struct.sv*** %sp, align 8
  %15 = load %struct.sv*, %struct.sv** %14, align 8
  %sv_flags3 = getelementptr inbounds %struct.sv, %struct.sv* %15, i32 0, i32 2
  %16 = load i32, i32* %sv_flags3, align 4
  %and4 = and i32 %16, -2147418112
  %cmp5 = icmp eq i32 %and4, 65536
  br i1 %cmp5, label %land.lhs.true.6, label %if.else

land.lhs.true.6:                                  ; preds = %land.lhs.true
  %17 = load %struct.sv**, %struct.sv*** %sp, align 8
  %18 = load %struct.sv*, %struct.sv** %17, align 8
  %sv_flags7 = getelementptr inbounds %struct.sv, %struct.sv* %18, i32 0, i32 2
  %19 = load i32, i32* %sv_flags7, align 4
  %and8 = and i32 %19, 131072
  %tobool9 = icmp ne i32 %and8, 0
  br i1 %tobool9, label %if.else, label %land.lhs.true.10

land.lhs.true.10:                                 ; preds = %land.lhs.true.6
  %20 = load %struct.sv**, %struct.sv*** %sp, align 8
  %21 = load %struct.sv*, %struct.sv** %20, align 8
  %sv_flags11 = getelementptr inbounds %struct.sv, %struct.sv* %21, i32 0, i32 2
  %22 = load i32, i32* %sv_flags11, align 4
  %and12 = and i32 %22, 262144
  %tobool13 = icmp ne i32 %and12, 0
  br i1 %tobool13, label %if.else, label %land.lhs.true.14

land.lhs.true.14:                                 ; preds = %land.lhs.true.10
  %23 = load %struct.sv**, %struct.sv*** %sp, align 8
  %24 = load %struct.sv*, %struct.sv** %23, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %24, i32 0, i32 0
  %25 = load i8*, i8** %sv_any, align 8
  %26 = bitcast i8* %25 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %26, i32 0, i32 3
  %27 = load i64, i64* %xiv_iv, align 8
  %cmp15 = icmp ne i64 %27, -9223372036854775808
  br i1 %cmp15, label %if.then.16, label %if.else

if.then.16:                                       ; preds = %land.lhs.true.14
  %28 = load %struct.sv**, %struct.sv*** %sp, align 8
  %29 = load %struct.sv*, %struct.sv** %28, align 8
  %sv_any17 = getelementptr inbounds %struct.sv, %struct.sv* %29, i32 0, i32 0
  %30 = load i8*, i8** %sv_any17, align 8
  %31 = bitcast i8* %30 to %struct.xpviv*
  %xiv_iv18 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %31, i32 0, i32 3
  %32 = load i64, i64* %xiv_iv18, align 8
  %dec = add nsw i64 %32, -1
  store i64 %dec, i64* %xiv_iv18, align 8
  %33 = load %struct.sv**, %struct.sv*** %sp, align 8
  %34 = load %struct.sv*, %struct.sv** %33, align 8
  %sv_flags19 = getelementptr inbounds %struct.sv, %struct.sv* %34, i32 0, i32 2
  %35 = load i32, i32* %sv_flags19, align 4
  %and20 = and i32 %35, -100663297
  store i32 %and20, i32* %sv_flags19, align 4
  br label %if.end.21

if.else:                                          ; preds = %land.lhs.true.14, %land.lhs.true.10, %land.lhs.true.6, %land.lhs.true, %if.end
  %36 = load %struct.sv**, %struct.sv*** %sp, align 8
  %37 = load %struct.sv*, %struct.sv** %36, align 8
  call void @Perl_sv_dec(%struct.sv* %37)
  br label %if.end.21

if.end.21:                                        ; preds = %if.else, %if.then.16
  %38 = load %struct.sv**, %struct.sv*** %sp, align 8
  %39 = load %struct.sv*, %struct.sv** %38, align 8
  %sv_flags22 = getelementptr inbounds %struct.sv, %struct.sv* %39, i32 0, i32 2
  %40 = load i32, i32* %sv_flags22, align 4
  %and23 = and i32 %40, 16384
  %tobool24 = icmp ne i32 %and23, 0
  br i1 %tobool24, label %if.then.25, label %if.end.27

if.then.25:                                       ; preds = %if.end.21
  %41 = load %struct.sv**, %struct.sv*** %sp, align 8
  %42 = load %struct.sv*, %struct.sv** %41, align 8
  %call26 = call i32 @Perl_mg_set(%struct.sv* %42)
  br label %if.end.27

if.end.27:                                        ; preds = %if.then.25, %if.end.21
  %43 = load %struct.sv*, %struct.sv** %targ, align 8
  %44 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %43, %struct.sv** %44, align 8
  %45 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %45, i32 0, i32 0
  %46 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %46, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.27, %if.then
  %47 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %47
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_pow() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %is_int = alloca i8, align 1
  %tmpsv = alloca %struct.sv*, align 8
  %right = alloca %struct.sv*, align 8
  %left = alloca %struct.sv*, align 8
  %tmp = alloca %struct.sv*, align 8
  %baseuok = alloca i8, align 1
  %baseuv = alloca i64, align 8
  %iv = alloca i64, align 8
  %power = alloca i64, align 8
  %iv123 = alloca i64, align 8
  %result = alloca double, align 8
  %base = alloca double, align 8
  %n = alloca i32, align 4
  %bit = alloca i64, align 8
  %tmp168 = alloca %struct.sv*, align 8
  %highbit = alloca i32, align 4
  %lowbit = alloca i32, align 4
  %diff = alloca i32, align 4
  %odd_power = alloca i8, align 1
  %result218 = alloca i64, align 8
  %base220 = alloca i64, align 8
  %n222 = alloca i32, align 4
  %bit227 = alloca i64, align 8
  %tmp256 = alloca %struct.sv*, align 8
  %tmp268 = alloca %struct.sv*, align 8
  %tmp279 = alloca %struct.sv*, align 8
  %tmp289 = alloca %struct.sv*, align 8
  %right299 = alloca double, align 8
  %left311 = alloca double, align 8
  %tmp329 = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 6
  %2 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 64
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load %struct.sv**, %struct.sv*** %sp, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 -1
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %5 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %5, i32 0, i32 3
  %6 = load i64, i64* %op_targ, align 8
  %7 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx1 = getelementptr inbounds %struct.sv*, %struct.sv** %7, i64 %6
  %8 = load %struct.sv*, %struct.sv** %arrayidx1, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.sv* [ %4, %cond.true ], [ %8, %cond.false ]
  store %struct.sv* %cond, %struct.sv** %targ, align 8
  store i8 0, i8* %is_int, align 1
  %9 = load i64, i64* @PL_amagic_generation, align 8
  %tobool2 = icmp ne i64 %9, 0
  br i1 %tobool2, label %if.then, label %if.end.31

if.then:                                          ; preds = %cond.end
  %10 = load %struct.sv**, %struct.sv*** %sp, align 8
  %11 = load %struct.sv*, %struct.sv** %10, align 8
  store %struct.sv* %11, %struct.sv** %right, align 8
  %12 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %12, i64 -1
  %13 = load %struct.sv*, %struct.sv** %add.ptr, align 8
  store %struct.sv* %13, %struct.sv** %left, align 8
  %14 = load %struct.sv*, %struct.sv** %left, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %14, i32 0, i32 2
  %15 = load i32, i32* %sv_flags, align 4
  %and3 = and i32 %15, 268435456
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %16 = load %struct.sv*, %struct.sv** %right, align 8
  %sv_flags5 = getelementptr inbounds %struct.sv, %struct.sv* %16, i32 0, i32 2
  %17 = load i32, i32* %sv_flags5, align 4
  %and6 = and i32 %17, 268435456
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %land.lhs.true, label %if.end.30

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %18 = load %struct.sv*, %struct.sv** %left, align 8
  %19 = load %struct.sv*, %struct.sv** %right, align 8
  %20 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags8 = getelementptr inbounds %struct.op, %struct.op* %20, i32 0, i32 6
  %21 = load i8, i8* %op_flags8, align 1
  %conv9 = zext i8 %21 to i32
  %and10 = and i32 %conv9, 64
  %tobool11 = icmp ne i32 %and10, 0
  %cond12 = select i1 %tobool11, i32 4, i32 0
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %18, %struct.sv* %19, i32 16, i32 %cond12)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool13 = icmp ne %struct.sv* %call, null
  br i1 %tobool13, label %if.then.14, label %if.end.30

if.then.14:                                       ; preds = %land.lhs.true
  %22 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %22, %struct.sv*** %sp, align 8
  %23 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %23, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %24 = load %struct.sv*, %struct.sv** %23, align 8
  %25 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags15 = getelementptr inbounds %struct.op, %struct.op* %25, i32 0, i32 6
  %26 = load i8, i8* %op_flags15, align 1
  %conv16 = zext i8 %26 to i32
  %and17 = and i32 %conv16, 64
  %tobool18 = icmp ne i32 %and17, 0
  br i1 %tobool18, label %if.then.23, label %lor.lhs.false.19

lor.lhs.false.19:                                 ; preds = %if.then.14
  %27 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags20 = getelementptr inbounds %struct.sv, %struct.sv* %27, i32 0, i32 2
  %28 = load i32, i32* %sv_flags20, align 4
  %and21 = and i32 %28, 1024
  %tobool22 = icmp ne i32 %and21, 0
  br i1 %tobool22, label %if.then.23, label %if.else

if.then.23:                                       ; preds = %lor.lhs.false.19, %if.then.14
  %29 = load %struct.sv*, %struct.sv** %targ, align 8
  %30 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  call void @Perl_sv_setsv_flags(%struct.sv* %29, %struct.sv* %30, i32 2)
  %31 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags24 = getelementptr inbounds %struct.sv, %struct.sv* %31, i32 0, i32 2
  %32 = load i32, i32* %sv_flags24, align 4
  %and25 = and i32 %32, 16384
  %tobool26 = icmp ne i32 %and25, 0
  br i1 %tobool26, label %if.then.27, label %if.end

if.then.27:                                       ; preds = %if.then.23
  %33 = load %struct.sv*, %struct.sv** %targ, align 8
  %call28 = call i32 @Perl_mg_set(%struct.sv* %33)
  br label %if.end

if.end:                                           ; preds = %if.then.27, %if.then.23
  %34 = load %struct.sv*, %struct.sv** %targ, align 8
  %35 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %34, %struct.sv** %35, align 8
  store %struct.sv* %34, %struct.sv** %tmp
  %36 = load %struct.sv*, %struct.sv** %tmp
  br label %if.end.29

if.else:                                          ; preds = %lor.lhs.false.19
  %37 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %38 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %37, %struct.sv** %38, align 8
  br label %if.end.29

if.end.29:                                        ; preds = %if.else, %if.end
  %39 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %39, %struct.sv*** @PL_stack_sp, align 8
  %40 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %40, i32 0, i32 0
  %41 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %41, %struct.op** %retval
  br label %return

if.end.30:                                        ; preds = %land.lhs.true, %lor.lhs.false
  br label %if.end.31

if.end.31:                                        ; preds = %if.end.30, %cond.end
  %42 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr32 = getelementptr inbounds %struct.sv*, %struct.sv** %42, i64 -1
  %43 = load %struct.sv*, %struct.sv** %add.ptr32, align 8
  %sv_flags33 = getelementptr inbounds %struct.sv, %struct.sv* %43, i32 0, i32 2
  %44 = load i32, i32* %sv_flags33, align 4
  %and34 = and i32 %44, 16777216
  %tobool35 = icmp ne i32 %and34, 0
  br i1 %tobool35, label %if.end.58, label %land.lhs.true.36

land.lhs.true.36:                                 ; preds = %if.end.31
  %45 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr37 = getelementptr inbounds %struct.sv*, %struct.sv** %45, i64 -1
  %46 = load %struct.sv*, %struct.sv** %add.ptr37, align 8
  %sv_flags38 = getelementptr inbounds %struct.sv, %struct.sv* %46, i32 0, i32 2
  %47 = load i32, i32* %sv_flags38, align 4
  %and39 = and i32 %47, 131072
  %tobool40 = icmp ne i32 %and39, 0
  br i1 %tobool40, label %if.then.46, label %lor.lhs.false.41

lor.lhs.false.41:                                 ; preds = %land.lhs.true.36
  %48 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr42 = getelementptr inbounds %struct.sv*, %struct.sv** %48, i64 -1
  %49 = load %struct.sv*, %struct.sv** %add.ptr42, align 8
  %sv_flags43 = getelementptr inbounds %struct.sv, %struct.sv* %49, i32 0, i32 2
  %50 = load i32, i32* %sv_flags43, align 4
  %and44 = and i32 %50, 262144
  %tobool45 = icmp ne i32 %and44, 0
  br i1 %tobool45, label %if.then.46, label %if.end.58

if.then.46:                                       ; preds = %lor.lhs.false.41, %land.lhs.true.36
  %51 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr47 = getelementptr inbounds %struct.sv*, %struct.sv** %51, i64 -1
  %52 = load %struct.sv*, %struct.sv** %add.ptr47, align 8
  %sv_flags48 = getelementptr inbounds %struct.sv, %struct.sv* %52, i32 0, i32 2
  %53 = load i32, i32* %sv_flags48, align 4
  %and49 = and i32 %53, 65536
  %tobool50 = icmp ne i32 %and49, 0
  br i1 %tobool50, label %cond.true.51, label %cond.false.53

cond.true.51:                                     ; preds = %if.then.46
  %54 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr52 = getelementptr inbounds %struct.sv*, %struct.sv** %54, i64 -1
  %55 = load %struct.sv*, %struct.sv** %add.ptr52, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %55, i32 0, i32 0
  %56 = load i8*, i8** %sv_any, align 8
  %57 = bitcast i8* %56 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %57, i32 0, i32 3
  %58 = load i64, i64* %xiv_iv, align 8
  br label %cond.end.56

cond.false.53:                                    ; preds = %if.then.46
  %59 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr54 = getelementptr inbounds %struct.sv*, %struct.sv** %59, i64 -1
  %60 = load %struct.sv*, %struct.sv** %add.ptr54, align 8
  %call55 = call i64 @Perl_sv_2iv(%struct.sv* %60)
  br label %cond.end.56

cond.end.56:                                      ; preds = %cond.false.53, %cond.true.51
  %cond57 = phi i64 [ %58, %cond.true.51 ], [ %call55, %cond.false.53 ]
  br label %if.end.58

if.end.58:                                        ; preds = %cond.end.56, %lor.lhs.false.41, %if.end.31
  %61 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr59 = getelementptr inbounds %struct.sv*, %struct.sv** %61, i64 -1
  %62 = load %struct.sv*, %struct.sv** %add.ptr59, align 8
  %sv_flags60 = getelementptr inbounds %struct.sv, %struct.sv* %62, i32 0, i32 2
  %63 = load i32, i32* %sv_flags60, align 4
  %and61 = and i32 %63, 65536
  %tobool62 = icmp ne i32 %and61, 0
  br i1 %tobool62, label %if.then.63, label %if.end.297

if.then.63:                                       ; preds = %if.end.58
  %64 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr65 = getelementptr inbounds %struct.sv*, %struct.sv** %64, i64 -1
  %65 = load %struct.sv*, %struct.sv** %add.ptr65, align 8
  %sv_flags66 = getelementptr inbounds %struct.sv, %struct.sv* %65, i32 0, i32 2
  %66 = load i32, i32* %sv_flags66, align 4
  %and67 = and i32 %66, -2147418112
  %cmp = icmp eq i32 %and67, -2147418112
  %conv68 = zext i1 %cmp to i32
  %conv69 = trunc i32 %conv68 to i8
  store i8 %conv69, i8* %baseuok, align 1
  %67 = load i8, i8* %baseuok, align 1
  %tobool71 = icmp ne i8 %67, 0
  br i1 %tobool71, label %if.then.72, label %if.else.75

if.then.72:                                       ; preds = %if.then.63
  %68 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr73 = getelementptr inbounds %struct.sv*, %struct.sv** %68, i64 -1
  %69 = load %struct.sv*, %struct.sv** %add.ptr73, align 8
  %sv_any74 = getelementptr inbounds %struct.sv, %struct.sv* %69, i32 0, i32 0
  %70 = load i8*, i8** %sv_any74, align 8
  %71 = bitcast i8* %70 to %struct.xpvuv*
  %xuv_uv = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %71, i32 0, i32 3
  %72 = load i64, i64* %xuv_uv, align 8
  store i64 %72, i64* %baseuv, align 8
  br label %if.end.85

if.else.75:                                       ; preds = %if.then.63
  %73 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr77 = getelementptr inbounds %struct.sv*, %struct.sv** %73, i64 -1
  %74 = load %struct.sv*, %struct.sv** %add.ptr77, align 8
  %sv_any78 = getelementptr inbounds %struct.sv, %struct.sv* %74, i32 0, i32 0
  %75 = load i8*, i8** %sv_any78, align 8
  %76 = bitcast i8* %75 to %struct.xpviv*
  %xiv_iv79 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %76, i32 0, i32 3
  %77 = load i64, i64* %xiv_iv79, align 8
  store i64 %77, i64* %iv, align 8
  %78 = load i64, i64* %iv, align 8
  %cmp80 = icmp sge i64 %78, 0
  br i1 %cmp80, label %if.then.82, label %if.else.83

if.then.82:                                       ; preds = %if.else.75
  %79 = load i64, i64* %iv, align 8
  store i64 %79, i64* %baseuv, align 8
  store i8 1, i8* %baseuok, align 1
  br label %if.end.84

if.else.83:                                       ; preds = %if.else.75
  %80 = load i64, i64* %iv, align 8
  %sub = sub nsw i64 0, %80
  store i64 %sub, i64* %baseuv, align 8
  br label %if.end.84

if.end.84:                                        ; preds = %if.else.83, %if.then.82
  br label %if.end.85

if.end.85:                                        ; preds = %if.end.84, %if.then.72
  %81 = load %struct.sv**, %struct.sv*** %sp, align 8
  %82 = load %struct.sv*, %struct.sv** %81, align 8
  %sv_flags86 = getelementptr inbounds %struct.sv, %struct.sv* %82, i32 0, i32 2
  %83 = load i32, i32* %sv_flags86, align 4
  %and87 = and i32 %83, 16777216
  %tobool88 = icmp ne i32 %and87, 0
  br i1 %tobool88, label %if.end.108, label %land.lhs.true.89

land.lhs.true.89:                                 ; preds = %if.end.85
  %84 = load %struct.sv**, %struct.sv*** %sp, align 8
  %85 = load %struct.sv*, %struct.sv** %84, align 8
  %sv_flags90 = getelementptr inbounds %struct.sv, %struct.sv* %85, i32 0, i32 2
  %86 = load i32, i32* %sv_flags90, align 4
  %and91 = and i32 %86, 131072
  %tobool92 = icmp ne i32 %and91, 0
  br i1 %tobool92, label %if.then.97, label %lor.lhs.false.93

lor.lhs.false.93:                                 ; preds = %land.lhs.true.89
  %87 = load %struct.sv**, %struct.sv*** %sp, align 8
  %88 = load %struct.sv*, %struct.sv** %87, align 8
  %sv_flags94 = getelementptr inbounds %struct.sv, %struct.sv* %88, i32 0, i32 2
  %89 = load i32, i32* %sv_flags94, align 4
  %and95 = and i32 %89, 262144
  %tobool96 = icmp ne i32 %and95, 0
  br i1 %tobool96, label %if.then.97, label %if.end.108

if.then.97:                                       ; preds = %lor.lhs.false.93, %land.lhs.true.89
  %90 = load %struct.sv**, %struct.sv*** %sp, align 8
  %91 = load %struct.sv*, %struct.sv** %90, align 8
  %sv_flags98 = getelementptr inbounds %struct.sv, %struct.sv* %91, i32 0, i32 2
  %92 = load i32, i32* %sv_flags98, align 4
  %and99 = and i32 %92, 65536
  %tobool100 = icmp ne i32 %and99, 0
  br i1 %tobool100, label %cond.true.101, label %cond.false.104

cond.true.101:                                    ; preds = %if.then.97
  %93 = load %struct.sv**, %struct.sv*** %sp, align 8
  %94 = load %struct.sv*, %struct.sv** %93, align 8
  %sv_any102 = getelementptr inbounds %struct.sv, %struct.sv* %94, i32 0, i32 0
  %95 = load i8*, i8** %sv_any102, align 8
  %96 = bitcast i8* %95 to %struct.xpviv*
  %xiv_iv103 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %96, i32 0, i32 3
  %97 = load i64, i64* %xiv_iv103, align 8
  br label %cond.end.106

cond.false.104:                                   ; preds = %if.then.97
  %98 = load %struct.sv**, %struct.sv*** %sp, align 8
  %99 = load %struct.sv*, %struct.sv** %98, align 8
  %call105 = call i64 @Perl_sv_2iv(%struct.sv* %99)
  br label %cond.end.106

cond.end.106:                                     ; preds = %cond.false.104, %cond.true.101
  %cond107 = phi i64 [ %97, %cond.true.101 ], [ %call105, %cond.false.104 ]
  br label %if.end.108

if.end.108:                                       ; preds = %cond.end.106, %lor.lhs.false.93, %if.end.85
  %100 = load %struct.sv**, %struct.sv*** %sp, align 8
  %101 = load %struct.sv*, %struct.sv** %100, align 8
  %sv_flags109 = getelementptr inbounds %struct.sv, %struct.sv* %101, i32 0, i32 2
  %102 = load i32, i32* %sv_flags109, align 4
  %and110 = and i32 %102, 65536
  %tobool111 = icmp ne i32 %and110, 0
  br i1 %tobool111, label %if.then.112, label %if.end.296

if.then.112:                                      ; preds = %if.end.108
  %103 = load %struct.sv**, %struct.sv*** %sp, align 8
  %104 = load %struct.sv*, %struct.sv** %103, align 8
  %sv_flags114 = getelementptr inbounds %struct.sv, %struct.sv* %104, i32 0, i32 2
  %105 = load i32, i32* %sv_flags114, align 4
  %and115 = and i32 %105, -2147418112
  %cmp116 = icmp eq i32 %and115, -2147418112
  br i1 %cmp116, label %if.then.118, label %if.else.121

if.then.118:                                      ; preds = %if.then.112
  %106 = load %struct.sv**, %struct.sv*** %sp, align 8
  %107 = load %struct.sv*, %struct.sv** %106, align 8
  %sv_any119 = getelementptr inbounds %struct.sv, %struct.sv* %107, i32 0, i32 0
  %108 = load i8*, i8** %sv_any119, align 8
  %109 = bitcast i8* %108 to %struct.xpvuv*
  %xuv_uv120 = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %109, i32 0, i32 3
  %110 = load i64, i64* %xuv_uv120, align 8
  store i64 %110, i64* %power, align 8
  br label %if.end.131

if.else.121:                                      ; preds = %if.then.112
  %111 = load %struct.sv**, %struct.sv*** %sp, align 8
  %112 = load %struct.sv*, %struct.sv** %111, align 8
  %sv_any124 = getelementptr inbounds %struct.sv, %struct.sv* %112, i32 0, i32 0
  %113 = load i8*, i8** %sv_any124, align 8
  %114 = bitcast i8* %113 to %struct.xpviv*
  %xiv_iv125 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %114, i32 0, i32 3
  %115 = load i64, i64* %xiv_iv125, align 8
  store i64 %115, i64* %iv123, align 8
  %116 = load i64, i64* %iv123, align 8
  %cmp126 = icmp sge i64 %116, 0
  br i1 %cmp126, label %if.then.128, label %if.else.129

if.then.128:                                      ; preds = %if.else.121
  %117 = load i64, i64* %iv123, align 8
  store i64 %117, i64* %power, align 8
  br label %if.end.130

if.else.129:                                      ; preds = %if.else.121
  br label %float_it

if.end.130:                                       ; preds = %if.then.128
  br label %if.end.131

if.end.131:                                       ; preds = %if.end.130, %if.then.118
  store i8 1, i8* %is_int, align 1
  %118 = load i64, i64* %baseuv, align 8
  %119 = load i64, i64* %baseuv, align 8
  %sub132 = sub i64 %119, 1
  %and133 = and i64 %118, %sub132
  %tobool134 = icmp ne i64 %and133, 0
  br i1 %tobool134, label %if.else.193, label %if.then.135

if.then.135:                                      ; preds = %if.end.131
  store double 1.000000e+00, double* %result, align 8
  %120 = load i8, i8* %baseuok, align 1
  %conv138 = sext i8 %120 to i32
  %tobool139 = icmp ne i32 %conv138, 0
  br i1 %tobool139, label %cond.true.140, label %cond.false.142

cond.true.140:                                    ; preds = %if.then.135
  %121 = load i64, i64* %baseuv, align 8
  %conv141 = uitofp i64 %121 to double
  br label %cond.end.145

cond.false.142:                                   ; preds = %if.then.135
  %122 = load i64, i64* %baseuv, align 8
  %conv143 = uitofp i64 %122 to double
  %sub144 = fsub double -0.000000e+00, %conv143
  br label %cond.end.145

cond.end.145:                                     ; preds = %cond.false.142, %cond.true.140
  %cond146 = phi double [ %conv141, %cond.true.140 ], [ %sub144, %cond.false.142 ]
  store double %cond146, double* %base, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end.145
  %123 = load i64, i64* %power, align 8
  %tobool148 = icmp ne i64 %123, 0
  br i1 %tobool148, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %124 = load i32, i32* %n, align 4
  %conv150 = sext i32 %124 to i64
  %shl = shl i64 1, %conv150
  store i64 %shl, i64* %bit, align 8
  %125 = load i64, i64* %power, align 8
  %126 = load i64, i64* %bit, align 8
  %and151 = and i64 %125, %126
  %tobool152 = icmp ne i64 %and151, 0
  br i1 %tobool152, label %if.then.153, label %if.end.159

if.then.153:                                      ; preds = %for.body
  %127 = load double, double* %base, align 8
  %128 = load double, double* %result, align 8
  %mul = fmul double %128, %127
  store double %mul, double* %result, align 8
  %129 = load i64, i64* %bit, align 8
  %130 = load i64, i64* %power, align 8
  %sub154 = sub i64 %130, %129
  store i64 %sub154, i64* %power, align 8
  %131 = load i64, i64* %power, align 8
  %cmp155 = icmp eq i64 %131, 0
  br i1 %cmp155, label %if.then.157, label %if.end.158

if.then.157:                                      ; preds = %if.then.153
  br label %for.end

if.end.158:                                       ; preds = %if.then.153
  br label %if.end.159

if.end.159:                                       ; preds = %if.end.158, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end.159
  %132 = load double, double* %base, align 8
  %133 = load double, double* %base, align 8
  %mul160 = fmul double %133, %132
  store double %mul160, double* %base, align 8
  %134 = load i32, i32* %n, align 4
  %inc = add nsw i32 %134, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then.157, %for.cond
  %135 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr161 = getelementptr inbounds %struct.sv*, %struct.sv** %135, i32 -1
  store %struct.sv** %incdec.ptr161, %struct.sv*** %sp, align 8
  %136 = load %struct.sv*, %struct.sv** %targ, align 8
  %137 = load double, double* %result, align 8
  call void @Perl_sv_setnv(%struct.sv* %136, double %137)
  %138 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags162 = getelementptr inbounds %struct.sv, %struct.sv* %138, i32 0, i32 2
  %139 = load i32, i32* %sv_flags162, align 4
  %and163 = and i32 %139, 16384
  %tobool164 = icmp ne i32 %and163, 0
  br i1 %tobool164, label %if.then.165, label %if.end.167

if.then.165:                                      ; preds = %for.end
  %140 = load %struct.sv*, %struct.sv** %targ, align 8
  %call166 = call i32 @Perl_mg_set(%struct.sv* %140)
  br label %if.end.167

if.end.167:                                       ; preds = %if.then.165, %for.end
  %141 = load %struct.sv*, %struct.sv** %targ, align 8
  %142 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %141, %struct.sv** %142, align 8
  store %struct.sv* %141, %struct.sv** %tmp168
  %143 = load %struct.sv*, %struct.sv** %tmp168
  %144 = load %struct.sv**, %struct.sv*** %sp, align 8
  %145 = load %struct.sv*, %struct.sv** %144, align 8
  %sv_flags169 = getelementptr inbounds %struct.sv, %struct.sv* %145, i32 0, i32 2
  %146 = load i32, i32* %sv_flags169, align 4
  %and170 = and i32 %146, 16777216
  %tobool171 = icmp ne i32 %and170, 0
  br i1 %tobool171, label %if.end.191, label %land.lhs.true.172

land.lhs.true.172:                                ; preds = %if.end.167
  %147 = load %struct.sv**, %struct.sv*** %sp, align 8
  %148 = load %struct.sv*, %struct.sv** %147, align 8
  %sv_flags173 = getelementptr inbounds %struct.sv, %struct.sv* %148, i32 0, i32 2
  %149 = load i32, i32* %sv_flags173, align 4
  %and174 = and i32 %149, 131072
  %tobool175 = icmp ne i32 %and174, 0
  br i1 %tobool175, label %if.then.180, label %lor.lhs.false.176

lor.lhs.false.176:                                ; preds = %land.lhs.true.172
  %150 = load %struct.sv**, %struct.sv*** %sp, align 8
  %151 = load %struct.sv*, %struct.sv** %150, align 8
  %sv_flags177 = getelementptr inbounds %struct.sv, %struct.sv* %151, i32 0, i32 2
  %152 = load i32, i32* %sv_flags177, align 4
  %and178 = and i32 %152, 262144
  %tobool179 = icmp ne i32 %and178, 0
  br i1 %tobool179, label %if.then.180, label %if.end.191

if.then.180:                                      ; preds = %lor.lhs.false.176, %land.lhs.true.172
  %153 = load %struct.sv**, %struct.sv*** %sp, align 8
  %154 = load %struct.sv*, %struct.sv** %153, align 8
  %sv_flags181 = getelementptr inbounds %struct.sv, %struct.sv* %154, i32 0, i32 2
  %155 = load i32, i32* %sv_flags181, align 4
  %and182 = and i32 %155, 65536
  %tobool183 = icmp ne i32 %and182, 0
  br i1 %tobool183, label %cond.true.184, label %cond.false.187

cond.true.184:                                    ; preds = %if.then.180
  %156 = load %struct.sv**, %struct.sv*** %sp, align 8
  %157 = load %struct.sv*, %struct.sv** %156, align 8
  %sv_any185 = getelementptr inbounds %struct.sv, %struct.sv* %157, i32 0, i32 0
  %158 = load i8*, i8** %sv_any185, align 8
  %159 = bitcast i8* %158 to %struct.xpviv*
  %xiv_iv186 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %159, i32 0, i32 3
  %160 = load i64, i64* %xiv_iv186, align 8
  br label %cond.end.189

cond.false.187:                                   ; preds = %if.then.180
  %161 = load %struct.sv**, %struct.sv*** %sp, align 8
  %162 = load %struct.sv*, %struct.sv** %161, align 8
  %call188 = call i64 @Perl_sv_2iv(%struct.sv* %162)
  br label %cond.end.189

cond.end.189:                                     ; preds = %cond.false.187, %cond.true.184
  %cond190 = phi i64 [ %160, %cond.true.184 ], [ %call188, %cond.false.187 ]
  br label %if.end.191

if.end.191:                                       ; preds = %cond.end.189, %lor.lhs.false.176, %if.end.167
  %163 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %163, %struct.sv*** @PL_stack_sp, align 8
  %164 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next192 = getelementptr inbounds %struct.op, %struct.op* %164, i32 0, i32 0
  %165 = load %struct.op*, %struct.op** %op_next192, align 8
  store %struct.op* %165, %struct.op** %retval
  br label %return

if.else.193:                                      ; preds = %if.end.131
  store i32 64, i32* %highbit, align 4
  store i32 0, i32* %lowbit, align 4
  %166 = load i64, i64* %power, align 8
  %and198 = and i64 %166, 1
  %conv199 = trunc i64 %and198 to i8
  store i8 %conv199, i8* %odd_power, align 1
  br label %while.cond

while.cond:                                       ; preds = %if.end.211, %if.else.193
  %167 = load i32, i32* %highbit, align 4
  %168 = load i32, i32* %lowbit, align 4
  %sub200 = sub i32 %167, %168
  %shr = lshr i32 %sub200, 1
  store i32 %shr, i32* %diff, align 4
  %tobool201 = icmp ne i32 %shr, 0
  br i1 %tobool201, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %169 = load i64, i64* %baseuv, align 8
  %170 = load i32, i32* %lowbit, align 4
  %171 = load i32, i32* %diff, align 4
  %add = add i32 %170, %171
  %shl202 = shl i32 1, %add
  %sub203 = sub nsw i32 %shl202, 1
  %neg = xor i32 %sub203, -1
  %conv204 = sext i32 %neg to i64
  %and205 = and i64 %169, %conv204
  %tobool206 = icmp ne i64 %and205, 0
  br i1 %tobool206, label %if.then.207, label %if.else.209

if.then.207:                                      ; preds = %while.body
  %172 = load i32, i32* %diff, align 4
  %173 = load i32, i32* %lowbit, align 4
  %add208 = add i32 %173, %172
  store i32 %add208, i32* %lowbit, align 4
  br label %if.end.211

if.else.209:                                      ; preds = %while.body
  %174 = load i32, i32* %diff, align 4
  %175 = load i32, i32* %highbit, align 4
  %sub210 = sub i32 %175, %174
  store i32 %sub210, i32* %highbit, align 4
  br label %if.end.211

if.end.211:                                       ; preds = %if.else.209, %if.then.207
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %176 = load i64, i64* %power, align 8
  %177 = load i32, i32* %highbit, align 4
  %conv212 = zext i32 %177 to i64
  %mul213 = mul i64 %176, %conv212
  %cmp214 = icmp ule i64 %mul213, 64
  br i1 %cmp214, label %if.then.216, label %if.end.294

if.then.216:                                      ; preds = %while.end
  store i64 1, i64* %result218, align 8
  %178 = load i64, i64* %baseuv, align 8
  store i64 %178, i64* %base220, align 8
  store i32 0, i32* %n222, align 4
  br label %for.cond.223

for.cond.223:                                     ; preds = %for.inc.240, %if.then.216
  %179 = load i64, i64* %power, align 8
  %tobool224 = icmp ne i64 %179, 0
  br i1 %tobool224, label %for.body.225, label %for.end.243

for.body.225:                                     ; preds = %for.cond.223
  %180 = load i32, i32* %n222, align 4
  %conv228 = sext i32 %180 to i64
  %shl229 = shl i64 1, %conv228
  store i64 %shl229, i64* %bit227, align 8
  %181 = load i64, i64* %power, align 8
  %182 = load i64, i64* %bit227, align 8
  %and230 = and i64 %181, %182
  %tobool231 = icmp ne i64 %and230, 0
  br i1 %tobool231, label %if.then.232, label %if.end.239

if.then.232:                                      ; preds = %for.body.225
  %183 = load i64, i64* %base220, align 8
  %184 = load i64, i64* %result218, align 8
  %mul233 = mul i64 %184, %183
  store i64 %mul233, i64* %result218, align 8
  %185 = load i64, i64* %bit227, align 8
  %186 = load i64, i64* %power, align 8
  %sub234 = sub i64 %186, %185
  store i64 %sub234, i64* %power, align 8
  %187 = load i64, i64* %power, align 8
  %cmp235 = icmp eq i64 %187, 0
  br i1 %cmp235, label %if.then.237, label %if.end.238

if.then.237:                                      ; preds = %if.then.232
  br label %for.end.243

if.end.238:                                       ; preds = %if.then.232
  br label %if.end.239

if.end.239:                                       ; preds = %if.end.238, %for.body.225
  br label %for.inc.240

for.inc.240:                                      ; preds = %if.end.239
  %188 = load i64, i64* %base220, align 8
  %189 = load i64, i64* %base220, align 8
  %mul241 = mul i64 %189, %188
  store i64 %mul241, i64* %base220, align 8
  %190 = load i32, i32* %n222, align 4
  %inc242 = add nsw i32 %190, 1
  store i32 %inc242, i32* %n222, align 4
  br label %for.cond.223

for.end.243:                                      ; preds = %if.then.237, %for.cond.223
  %191 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr244 = getelementptr inbounds %struct.sv*, %struct.sv** %191, i32 -1
  store %struct.sv** %incdec.ptr244, %struct.sv*** %sp, align 8
  %192 = load i8, i8* %baseuok, align 1
  %conv245 = sext i8 %192 to i32
  %tobool246 = icmp ne i32 %conv245, 0
  br i1 %tobool246, label %if.then.249, label %lor.lhs.false.247

lor.lhs.false.247:                                ; preds = %for.end.243
  %193 = load i8, i8* %odd_power, align 1
  %tobool248 = icmp ne i8 %193, 0
  br i1 %tobool248, label %if.else.257, label %if.then.249

if.then.249:                                      ; preds = %lor.lhs.false.247, %for.end.243
  %194 = load %struct.sv*, %struct.sv** %targ, align 8
  %195 = load i64, i64* %result218, align 8
  call void @Perl_sv_setuv(%struct.sv* %194, i64 %195)
  %196 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags250 = getelementptr inbounds %struct.sv, %struct.sv* %196, i32 0, i32 2
  %197 = load i32, i32* %sv_flags250, align 4
  %and251 = and i32 %197, 16384
  %tobool252 = icmp ne i32 %and251, 0
  br i1 %tobool252, label %if.then.253, label %if.end.255

if.then.253:                                      ; preds = %if.then.249
  %198 = load %struct.sv*, %struct.sv** %targ, align 8
  %call254 = call i32 @Perl_mg_set(%struct.sv* %198)
  br label %if.end.255

if.end.255:                                       ; preds = %if.then.253, %if.then.249
  %199 = load %struct.sv*, %struct.sv** %targ, align 8
  %200 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %199, %struct.sv** %200, align 8
  store %struct.sv* %199, %struct.sv** %tmp256
  %201 = load %struct.sv*, %struct.sv** %tmp256
  br label %if.end.292

if.else.257:                                      ; preds = %lor.lhs.false.247
  %202 = load i64, i64* %result218, align 8
  %cmp258 = icmp ule i64 %202, 9223372036854775807
  br i1 %cmp258, label %if.then.260, label %if.else.269

if.then.260:                                      ; preds = %if.else.257
  %203 = load %struct.sv*, %struct.sv** %targ, align 8
  %204 = load i64, i64* %result218, align 8
  %sub261 = sub nsw i64 0, %204
  call void @Perl_sv_setiv(%struct.sv* %203, i64 %sub261)
  %205 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags262 = getelementptr inbounds %struct.sv, %struct.sv* %205, i32 0, i32 2
  %206 = load i32, i32* %sv_flags262, align 4
  %and263 = and i32 %206, 16384
  %tobool264 = icmp ne i32 %and263, 0
  br i1 %tobool264, label %if.then.265, label %if.end.267

if.then.265:                                      ; preds = %if.then.260
  %207 = load %struct.sv*, %struct.sv** %targ, align 8
  %call266 = call i32 @Perl_mg_set(%struct.sv* %207)
  br label %if.end.267

if.end.267:                                       ; preds = %if.then.265, %if.then.260
  %208 = load %struct.sv*, %struct.sv** %targ, align 8
  %209 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %208, %struct.sv** %209, align 8
  store %struct.sv* %208, %struct.sv** %tmp268
  %210 = load %struct.sv*, %struct.sv** %tmp268
  br label %if.end.291

if.else.269:                                      ; preds = %if.else.257
  %211 = load i64, i64* %result218, align 8
  %cmp270 = icmp eq i64 %211, -9223372036854775808
  br i1 %cmp270, label %if.then.272, label %if.else.280

if.then.272:                                      ; preds = %if.else.269
  %212 = load %struct.sv*, %struct.sv** %targ, align 8
  call void @Perl_sv_setiv(%struct.sv* %212, i64 -9223372036854775808)
  %213 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags273 = getelementptr inbounds %struct.sv, %struct.sv* %213, i32 0, i32 2
  %214 = load i32, i32* %sv_flags273, align 4
  %and274 = and i32 %214, 16384
  %tobool275 = icmp ne i32 %and274, 0
  br i1 %tobool275, label %if.then.276, label %if.end.278

if.then.276:                                      ; preds = %if.then.272
  %215 = load %struct.sv*, %struct.sv** %targ, align 8
  %call277 = call i32 @Perl_mg_set(%struct.sv* %215)
  br label %if.end.278

if.end.278:                                       ; preds = %if.then.276, %if.then.272
  %216 = load %struct.sv*, %struct.sv** %targ, align 8
  %217 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %216, %struct.sv** %217, align 8
  store %struct.sv* %216, %struct.sv** %tmp279
  %218 = load %struct.sv*, %struct.sv** %tmp279
  br label %if.end.290

if.else.280:                                      ; preds = %if.else.269
  %219 = load %struct.sv*, %struct.sv** %targ, align 8
  %220 = load i64, i64* %result218, align 8
  %conv281 = uitofp i64 %220 to double
  %sub282 = fsub double -0.000000e+00, %conv281
  call void @Perl_sv_setnv(%struct.sv* %219, double %sub282)
  %221 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags283 = getelementptr inbounds %struct.sv, %struct.sv* %221, i32 0, i32 2
  %222 = load i32, i32* %sv_flags283, align 4
  %and284 = and i32 %222, 16384
  %tobool285 = icmp ne i32 %and284, 0
  br i1 %tobool285, label %if.then.286, label %if.end.288

if.then.286:                                      ; preds = %if.else.280
  %223 = load %struct.sv*, %struct.sv** %targ, align 8
  %call287 = call i32 @Perl_mg_set(%struct.sv* %223)
  br label %if.end.288

if.end.288:                                       ; preds = %if.then.286, %if.else.280
  %224 = load %struct.sv*, %struct.sv** %targ, align 8
  %225 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %224, %struct.sv** %225, align 8
  store %struct.sv* %224, %struct.sv** %tmp289
  %226 = load %struct.sv*, %struct.sv** %tmp289
  br label %if.end.290

if.end.290:                                       ; preds = %if.end.288, %if.end.278
  br label %if.end.291

if.end.291:                                       ; preds = %if.end.290, %if.end.267
  br label %if.end.292

if.end.292:                                       ; preds = %if.end.291, %if.end.255
  %227 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %227, %struct.sv*** @PL_stack_sp, align 8
  %228 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next293 = getelementptr inbounds %struct.op, %struct.op* %228, i32 0, i32 0
  %229 = load %struct.op*, %struct.op** %op_next293, align 8
  store %struct.op* %229, %struct.op** %retval
  br label %return

if.end.294:                                       ; preds = %while.end
  br label %if.end.295

if.end.295:                                       ; preds = %if.end.294
  br label %if.end.296

if.end.296:                                       ; preds = %if.end.295, %if.end.108
  br label %if.end.297

if.end.297:                                       ; preds = %if.end.296, %if.end.58
  br label %float_it

float_it:                                         ; preds = %if.end.297, %if.else.129
  %230 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr300 = getelementptr inbounds %struct.sv*, %struct.sv** %230, i32 -1
  store %struct.sv** %incdec.ptr300, %struct.sv*** %sp, align 8
  %231 = load %struct.sv*, %struct.sv** %230, align 8
  store %struct.sv* %231, %struct.sv** @PL_Sv, align 8
  %232 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags301 = getelementptr inbounds %struct.sv, %struct.sv* %232, i32 0, i32 2
  %233 = load i32, i32* %sv_flags301, align 4
  %and302 = and i32 %233, 131072
  %tobool303 = icmp ne i32 %and302, 0
  br i1 %tobool303, label %cond.true.304, label %cond.false.306

cond.true.304:                                    ; preds = %float_it
  %234 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any305 = getelementptr inbounds %struct.sv, %struct.sv* %234, i32 0, i32 0
  %235 = load i8*, i8** %sv_any305, align 8
  %236 = bitcast i8* %235 to %struct.xpvnv*
  %xnv_nv = getelementptr inbounds %struct.xpvnv, %struct.xpvnv* %236, i32 0, i32 4
  %237 = load double, double* %xnv_nv, align 8
  br label %cond.end.308

cond.false.306:                                   ; preds = %float_it
  %238 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call307 = call double @Perl_sv_2nv(%struct.sv* %238)
  br label %cond.end.308

cond.end.308:                                     ; preds = %cond.false.306, %cond.true.304
  %cond309 = phi double [ %237, %cond.true.304 ], [ %call307, %cond.false.306 ]
  store double %cond309, double* %right299, align 8
  %239 = load %struct.sv**, %struct.sv*** %sp, align 8
  %240 = load %struct.sv*, %struct.sv** %239, align 8
  %sv_flags312 = getelementptr inbounds %struct.sv, %struct.sv* %240, i32 0, i32 2
  %241 = load i32, i32* %sv_flags312, align 4
  %and313 = and i32 %241, 131072
  %tobool314 = icmp ne i32 %and313, 0
  br i1 %tobool314, label %cond.true.315, label %cond.false.318

cond.true.315:                                    ; preds = %cond.end.308
  %242 = load %struct.sv**, %struct.sv*** %sp, align 8
  %243 = load %struct.sv*, %struct.sv** %242, align 8
  %sv_any316 = getelementptr inbounds %struct.sv, %struct.sv* %243, i32 0, i32 0
  %244 = load i8*, i8** %sv_any316, align 8
  %245 = bitcast i8* %244 to %struct.xpvnv*
  %xnv_nv317 = getelementptr inbounds %struct.xpvnv, %struct.xpvnv* %245, i32 0, i32 4
  %246 = load double, double* %xnv_nv317, align 8
  br label %cond.end.320

cond.false.318:                                   ; preds = %cond.end.308
  %247 = load %struct.sv**, %struct.sv*** %sp, align 8
  %248 = load %struct.sv*, %struct.sv** %247, align 8
  %call319 = call double @Perl_sv_2nv(%struct.sv* %248)
  br label %cond.end.320

cond.end.320:                                     ; preds = %cond.false.318, %cond.true.315
  %cond321 = phi double [ %246, %cond.true.315 ], [ %call319, %cond.false.318 ]
  store double %cond321, double* %left311, align 8
  %249 = load %struct.sv*, %struct.sv** %targ, align 8
  %250 = load double, double* %left311, align 8
  %251 = load double, double* %right299, align 8
  %call322 = call double @pow(double %250, double %251) #2
  call void @Perl_sv_setnv(%struct.sv* %249, double %call322)
  %252 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags323 = getelementptr inbounds %struct.sv, %struct.sv* %252, i32 0, i32 2
  %253 = load i32, i32* %sv_flags323, align 4
  %and324 = and i32 %253, 16384
  %tobool325 = icmp ne i32 %and324, 0
  br i1 %tobool325, label %if.then.326, label %if.end.328

if.then.326:                                      ; preds = %cond.end.320
  %254 = load %struct.sv*, %struct.sv** %targ, align 8
  %call327 = call i32 @Perl_mg_set(%struct.sv* %254)
  br label %if.end.328

if.end.328:                                       ; preds = %if.then.326, %cond.end.320
  %255 = load %struct.sv*, %struct.sv** %targ, align 8
  %256 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %255, %struct.sv** %256, align 8
  store %struct.sv* %255, %struct.sv** %tmp329
  %257 = load %struct.sv*, %struct.sv** %tmp329
  %258 = load i8, i8* %is_int, align 1
  %tobool330 = icmp ne i8 %258, 0
  br i1 %tobool330, label %if.then.331, label %if.end.355

if.then.331:                                      ; preds = %if.end.328
  %259 = load %struct.sv**, %struct.sv*** %sp, align 8
  %260 = load %struct.sv*, %struct.sv** %259, align 8
  %sv_flags332 = getelementptr inbounds %struct.sv, %struct.sv* %260, i32 0, i32 2
  %261 = load i32, i32* %sv_flags332, align 4
  %and333 = and i32 %261, 16777216
  %tobool334 = icmp ne i32 %and333, 0
  br i1 %tobool334, label %if.end.354, label %land.lhs.true.335

land.lhs.true.335:                                ; preds = %if.then.331
  %262 = load %struct.sv**, %struct.sv*** %sp, align 8
  %263 = load %struct.sv*, %struct.sv** %262, align 8
  %sv_flags336 = getelementptr inbounds %struct.sv, %struct.sv* %263, i32 0, i32 2
  %264 = load i32, i32* %sv_flags336, align 4
  %and337 = and i32 %264, 131072
  %tobool338 = icmp ne i32 %and337, 0
  br i1 %tobool338, label %if.then.343, label %lor.lhs.false.339

lor.lhs.false.339:                                ; preds = %land.lhs.true.335
  %265 = load %struct.sv**, %struct.sv*** %sp, align 8
  %266 = load %struct.sv*, %struct.sv** %265, align 8
  %sv_flags340 = getelementptr inbounds %struct.sv, %struct.sv* %266, i32 0, i32 2
  %267 = load i32, i32* %sv_flags340, align 4
  %and341 = and i32 %267, 262144
  %tobool342 = icmp ne i32 %and341, 0
  br i1 %tobool342, label %if.then.343, label %if.end.354

if.then.343:                                      ; preds = %lor.lhs.false.339, %land.lhs.true.335
  %268 = load %struct.sv**, %struct.sv*** %sp, align 8
  %269 = load %struct.sv*, %struct.sv** %268, align 8
  %sv_flags344 = getelementptr inbounds %struct.sv, %struct.sv* %269, i32 0, i32 2
  %270 = load i32, i32* %sv_flags344, align 4
  %and345 = and i32 %270, 65536
  %tobool346 = icmp ne i32 %and345, 0
  br i1 %tobool346, label %cond.true.347, label %cond.false.350

cond.true.347:                                    ; preds = %if.then.343
  %271 = load %struct.sv**, %struct.sv*** %sp, align 8
  %272 = load %struct.sv*, %struct.sv** %271, align 8
  %sv_any348 = getelementptr inbounds %struct.sv, %struct.sv* %272, i32 0, i32 0
  %273 = load i8*, i8** %sv_any348, align 8
  %274 = bitcast i8* %273 to %struct.xpviv*
  %xiv_iv349 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %274, i32 0, i32 3
  %275 = load i64, i64* %xiv_iv349, align 8
  br label %cond.end.352

cond.false.350:                                   ; preds = %if.then.343
  %276 = load %struct.sv**, %struct.sv*** %sp, align 8
  %277 = load %struct.sv*, %struct.sv** %276, align 8
  %call351 = call i64 @Perl_sv_2iv(%struct.sv* %277)
  br label %cond.end.352

cond.end.352:                                     ; preds = %cond.false.350, %cond.true.347
  %cond353 = phi i64 [ %275, %cond.true.347 ], [ %call351, %cond.false.350 ]
  br label %if.end.354

if.end.354:                                       ; preds = %cond.end.352, %lor.lhs.false.339, %if.then.331
  br label %if.end.355

if.end.355:                                       ; preds = %if.end.354, %if.end.328
  %278 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %278, %struct.sv*** @PL_stack_sp, align 8
  %279 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next356 = getelementptr inbounds %struct.op, %struct.op* %279, i32 0, i32 0
  %280 = load %struct.op*, %struct.op** %op_next356, align 8
  store %struct.op* %280, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.355, %if.end.292, %if.end.191, %if.end.29
  %281 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %281
}

declare i64 @Perl_sv_2iv(%struct.sv*) #1

declare void @Perl_sv_setnv(%struct.sv*, double) #1

declare void @Perl_sv_setuv(%struct.sv*, i64) #1

declare double @Perl_sv_2nv(%struct.sv*) #1

; Function Attrs: nounwind
declare double @pow(double, double) #3

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_multiply() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %right = alloca %struct.sv*, align 8
  %left = alloca %struct.sv*, align 8
  %tmp = alloca %struct.sv*, align 8
  %auvok = alloca i8, align 1
  %buvok = alloca i8, align 1
  %topmask = alloca i64, align 8
  %botmask = alloca i64, align 8
  %alow = alloca i64, align 8
  %ahigh = alloca i64, align 8
  %blow = alloca i64, align 8
  %bhigh = alloca i64, align 8
  %aiv = alloca i64, align 8
  %biv = alloca i64, align 8
  %product = alloca i64, align 8
  %tmp164 = alloca %struct.sv*, align 8
  %tmp178 = alloca %struct.sv*, align 8
  %product_middle = alloca i64, align 8
  %product_low = alloca i64, align 8
  %tmp208 = alloca %struct.sv*, align 8
  %tmp222 = alloca %struct.sv*, align 8
  %right233 = alloca double, align 8
  %left245 = alloca double, align 8
  %tmp263 = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 6
  %2 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 64
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load %struct.sv**, %struct.sv*** %sp, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 -1
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %5 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %5, i32 0, i32 3
  %6 = load i64, i64* %op_targ, align 8
  %7 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx1 = getelementptr inbounds %struct.sv*, %struct.sv** %7, i64 %6
  %8 = load %struct.sv*, %struct.sv** %arrayidx1, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.sv* [ %4, %cond.true ], [ %8, %cond.false ]
  store %struct.sv* %cond, %struct.sv** %targ, align 8
  %9 = load i64, i64* @PL_amagic_generation, align 8
  %tobool2 = icmp ne i64 %9, 0
  br i1 %tobool2, label %if.then, label %if.end.31

if.then:                                          ; preds = %cond.end
  %10 = load %struct.sv**, %struct.sv*** %sp, align 8
  %11 = load %struct.sv*, %struct.sv** %10, align 8
  store %struct.sv* %11, %struct.sv** %right, align 8
  %12 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %12, i64 -1
  %13 = load %struct.sv*, %struct.sv** %add.ptr, align 8
  store %struct.sv* %13, %struct.sv** %left, align 8
  %14 = load %struct.sv*, %struct.sv** %left, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %14, i32 0, i32 2
  %15 = load i32, i32* %sv_flags, align 4
  %and3 = and i32 %15, 268435456
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %16 = load %struct.sv*, %struct.sv** %right, align 8
  %sv_flags5 = getelementptr inbounds %struct.sv, %struct.sv* %16, i32 0, i32 2
  %17 = load i32, i32* %sv_flags5, align 4
  %and6 = and i32 %17, 268435456
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %land.lhs.true, label %if.end.30

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %18 = load %struct.sv*, %struct.sv** %left, align 8
  %19 = load %struct.sv*, %struct.sv** %right, align 8
  %20 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags8 = getelementptr inbounds %struct.op, %struct.op* %20, i32 0, i32 6
  %21 = load i8, i8* %op_flags8, align 1
  %conv9 = zext i8 %21 to i32
  %and10 = and i32 %conv9, 64
  %tobool11 = icmp ne i32 %and10, 0
  %cond12 = select i1 %tobool11, i32 4, i32 0
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %18, %struct.sv* %19, i32 10, i32 %cond12)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool13 = icmp ne %struct.sv* %call, null
  br i1 %tobool13, label %if.then.14, label %if.end.30

if.then.14:                                       ; preds = %land.lhs.true
  %22 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %22, %struct.sv*** %sp, align 8
  %23 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %23, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %24 = load %struct.sv*, %struct.sv** %23, align 8
  %25 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags15 = getelementptr inbounds %struct.op, %struct.op* %25, i32 0, i32 6
  %26 = load i8, i8* %op_flags15, align 1
  %conv16 = zext i8 %26 to i32
  %and17 = and i32 %conv16, 64
  %tobool18 = icmp ne i32 %and17, 0
  br i1 %tobool18, label %if.then.23, label %lor.lhs.false.19

lor.lhs.false.19:                                 ; preds = %if.then.14
  %27 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags20 = getelementptr inbounds %struct.sv, %struct.sv* %27, i32 0, i32 2
  %28 = load i32, i32* %sv_flags20, align 4
  %and21 = and i32 %28, 1024
  %tobool22 = icmp ne i32 %and21, 0
  br i1 %tobool22, label %if.then.23, label %if.else

if.then.23:                                       ; preds = %lor.lhs.false.19, %if.then.14
  %29 = load %struct.sv*, %struct.sv** %targ, align 8
  %30 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  call void @Perl_sv_setsv_flags(%struct.sv* %29, %struct.sv* %30, i32 2)
  %31 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags24 = getelementptr inbounds %struct.sv, %struct.sv* %31, i32 0, i32 2
  %32 = load i32, i32* %sv_flags24, align 4
  %and25 = and i32 %32, 16384
  %tobool26 = icmp ne i32 %and25, 0
  br i1 %tobool26, label %if.then.27, label %if.end

if.then.27:                                       ; preds = %if.then.23
  %33 = load %struct.sv*, %struct.sv** %targ, align 8
  %call28 = call i32 @Perl_mg_set(%struct.sv* %33)
  br label %if.end

if.end:                                           ; preds = %if.then.27, %if.then.23
  %34 = load %struct.sv*, %struct.sv** %targ, align 8
  %35 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %34, %struct.sv** %35, align 8
  store %struct.sv* %34, %struct.sv** %tmp
  %36 = load %struct.sv*, %struct.sv** %tmp
  br label %if.end.29

if.else:                                          ; preds = %lor.lhs.false.19
  %37 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %38 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %37, %struct.sv** %38, align 8
  br label %if.end.29

if.end.29:                                        ; preds = %if.else, %if.end
  %39 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %39, %struct.sv*** @PL_stack_sp, align 8
  %40 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %40, i32 0, i32 0
  %41 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %41, %struct.op** %retval
  br label %return

if.end.30:                                        ; preds = %land.lhs.true, %lor.lhs.false
  br label %if.end.31

if.end.31:                                        ; preds = %if.end.30, %cond.end
  %42 = load %struct.sv**, %struct.sv*** %sp, align 8
  %43 = load %struct.sv*, %struct.sv** %42, align 8
  %sv_flags32 = getelementptr inbounds %struct.sv, %struct.sv* %43, i32 0, i32 2
  %44 = load i32, i32* %sv_flags32, align 4
  %and33 = and i32 %44, 16777216
  %tobool34 = icmp ne i32 %and33, 0
  br i1 %tobool34, label %if.end.52, label %land.lhs.true.35

land.lhs.true.35:                                 ; preds = %if.end.31
  %45 = load %struct.sv**, %struct.sv*** %sp, align 8
  %46 = load %struct.sv*, %struct.sv** %45, align 8
  %sv_flags36 = getelementptr inbounds %struct.sv, %struct.sv* %46, i32 0, i32 2
  %47 = load i32, i32* %sv_flags36, align 4
  %and37 = and i32 %47, 131072
  %tobool38 = icmp ne i32 %and37, 0
  br i1 %tobool38, label %if.then.43, label %lor.lhs.false.39

lor.lhs.false.39:                                 ; preds = %land.lhs.true.35
  %48 = load %struct.sv**, %struct.sv*** %sp, align 8
  %49 = load %struct.sv*, %struct.sv** %48, align 8
  %sv_flags40 = getelementptr inbounds %struct.sv, %struct.sv* %49, i32 0, i32 2
  %50 = load i32, i32* %sv_flags40, align 4
  %and41 = and i32 %50, 262144
  %tobool42 = icmp ne i32 %and41, 0
  br i1 %tobool42, label %if.then.43, label %if.end.52

if.then.43:                                       ; preds = %lor.lhs.false.39, %land.lhs.true.35
  %51 = load %struct.sv**, %struct.sv*** %sp, align 8
  %52 = load %struct.sv*, %struct.sv** %51, align 8
  %sv_flags44 = getelementptr inbounds %struct.sv, %struct.sv* %52, i32 0, i32 2
  %53 = load i32, i32* %sv_flags44, align 4
  %and45 = and i32 %53, 65536
  %tobool46 = icmp ne i32 %and45, 0
  br i1 %tobool46, label %cond.true.47, label %cond.false.48

cond.true.47:                                     ; preds = %if.then.43
  %54 = load %struct.sv**, %struct.sv*** %sp, align 8
  %55 = load %struct.sv*, %struct.sv** %54, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %55, i32 0, i32 0
  %56 = load i8*, i8** %sv_any, align 8
  %57 = bitcast i8* %56 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %57, i32 0, i32 3
  %58 = load i64, i64* %xiv_iv, align 8
  br label %cond.end.50

cond.false.48:                                    ; preds = %if.then.43
  %59 = load %struct.sv**, %struct.sv*** %sp, align 8
  %60 = load %struct.sv*, %struct.sv** %59, align 8
  %call49 = call i64 @Perl_sv_2iv(%struct.sv* %60)
  br label %cond.end.50

cond.end.50:                                      ; preds = %cond.false.48, %cond.true.47
  %cond51 = phi i64 [ %58, %cond.true.47 ], [ %call49, %cond.false.48 ]
  br label %if.end.52

if.end.52:                                        ; preds = %cond.end.50, %lor.lhs.false.39, %if.end.31
  %61 = load %struct.sv**, %struct.sv*** %sp, align 8
  %62 = load %struct.sv*, %struct.sv** %61, align 8
  %sv_flags53 = getelementptr inbounds %struct.sv, %struct.sv* %62, i32 0, i32 2
  %63 = load i32, i32* %sv_flags53, align 4
  %and54 = and i32 %63, 65536
  %tobool55 = icmp ne i32 %and54, 0
  br i1 %tobool55, label %if.then.56, label %if.end.231

if.then.56:                                       ; preds = %if.end.52
  %64 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr57 = getelementptr inbounds %struct.sv*, %struct.sv** %64, i64 -1
  %65 = load %struct.sv*, %struct.sv** %add.ptr57, align 8
  %sv_flags58 = getelementptr inbounds %struct.sv, %struct.sv* %65, i32 0, i32 2
  %66 = load i32, i32* %sv_flags58, align 4
  %and59 = and i32 %66, 16777216
  %tobool60 = icmp ne i32 %and59, 0
  br i1 %tobool60, label %if.end.85, label %land.lhs.true.61

land.lhs.true.61:                                 ; preds = %if.then.56
  %67 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr62 = getelementptr inbounds %struct.sv*, %struct.sv** %67, i64 -1
  %68 = load %struct.sv*, %struct.sv** %add.ptr62, align 8
  %sv_flags63 = getelementptr inbounds %struct.sv, %struct.sv* %68, i32 0, i32 2
  %69 = load i32, i32* %sv_flags63, align 4
  %and64 = and i32 %69, 131072
  %tobool65 = icmp ne i32 %and64, 0
  br i1 %tobool65, label %if.then.71, label %lor.lhs.false.66

lor.lhs.false.66:                                 ; preds = %land.lhs.true.61
  %70 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr67 = getelementptr inbounds %struct.sv*, %struct.sv** %70, i64 -1
  %71 = load %struct.sv*, %struct.sv** %add.ptr67, align 8
  %sv_flags68 = getelementptr inbounds %struct.sv, %struct.sv* %71, i32 0, i32 2
  %72 = load i32, i32* %sv_flags68, align 4
  %and69 = and i32 %72, 262144
  %tobool70 = icmp ne i32 %and69, 0
  br i1 %tobool70, label %if.then.71, label %if.end.85

if.then.71:                                       ; preds = %lor.lhs.false.66, %land.lhs.true.61
  %73 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr72 = getelementptr inbounds %struct.sv*, %struct.sv** %73, i64 -1
  %74 = load %struct.sv*, %struct.sv** %add.ptr72, align 8
  %sv_flags73 = getelementptr inbounds %struct.sv, %struct.sv* %74, i32 0, i32 2
  %75 = load i32, i32* %sv_flags73, align 4
  %and74 = and i32 %75, 65536
  %tobool75 = icmp ne i32 %and74, 0
  br i1 %tobool75, label %cond.true.76, label %cond.false.80

cond.true.76:                                     ; preds = %if.then.71
  %76 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr77 = getelementptr inbounds %struct.sv*, %struct.sv** %76, i64 -1
  %77 = load %struct.sv*, %struct.sv** %add.ptr77, align 8
  %sv_any78 = getelementptr inbounds %struct.sv, %struct.sv* %77, i32 0, i32 0
  %78 = load i8*, i8** %sv_any78, align 8
  %79 = bitcast i8* %78 to %struct.xpviv*
  %xiv_iv79 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %79, i32 0, i32 3
  %80 = load i64, i64* %xiv_iv79, align 8
  br label %cond.end.83

cond.false.80:                                    ; preds = %if.then.71
  %81 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr81 = getelementptr inbounds %struct.sv*, %struct.sv** %81, i64 -1
  %82 = load %struct.sv*, %struct.sv** %add.ptr81, align 8
  %call82 = call i64 @Perl_sv_2iv(%struct.sv* %82)
  br label %cond.end.83

cond.end.83:                                      ; preds = %cond.false.80, %cond.true.76
  %cond84 = phi i64 [ %80, %cond.true.76 ], [ %call82, %cond.false.80 ]
  br label %if.end.85

if.end.85:                                        ; preds = %cond.end.83, %lor.lhs.false.66, %if.then.56
  %83 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr86 = getelementptr inbounds %struct.sv*, %struct.sv** %83, i64 -1
  %84 = load %struct.sv*, %struct.sv** %add.ptr86, align 8
  %sv_flags87 = getelementptr inbounds %struct.sv, %struct.sv* %84, i32 0, i32 2
  %85 = load i32, i32* %sv_flags87, align 4
  %and88 = and i32 %85, 65536
  %tobool89 = icmp ne i32 %and88, 0
  br i1 %tobool89, label %if.then.90, label %if.end.230

if.then.90:                                       ; preds = %if.end.85
  %86 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr92 = getelementptr inbounds %struct.sv*, %struct.sv** %86, i64 -1
  %87 = load %struct.sv*, %struct.sv** %add.ptr92, align 8
  %sv_flags93 = getelementptr inbounds %struct.sv, %struct.sv* %87, i32 0, i32 2
  %88 = load i32, i32* %sv_flags93, align 4
  %and94 = and i32 %88, -2147418112
  %cmp = icmp eq i32 %and94, -2147418112
  %conv95 = zext i1 %cmp to i32
  %conv96 = trunc i32 %conv95 to i8
  store i8 %conv96, i8* %auvok, align 1
  %89 = load %struct.sv**, %struct.sv*** %sp, align 8
  %90 = load %struct.sv*, %struct.sv** %89, align 8
  %sv_flags98 = getelementptr inbounds %struct.sv, %struct.sv* %90, i32 0, i32 2
  %91 = load i32, i32* %sv_flags98, align 4
  %and99 = and i32 %91, -2147418112
  %cmp100 = icmp eq i32 %and99, -2147418112
  %conv101 = zext i1 %cmp100 to i32
  %conv102 = trunc i32 %conv101 to i8
  store i8 %conv102, i8* %buvok, align 1
  store i64 -4294967296, i64* %topmask, align 8
  store i64 4294967295, i64* %botmask, align 8
  %92 = load i8, i8* %auvok, align 1
  %tobool109 = icmp ne i8 %92, 0
  br i1 %tobool109, label %if.then.110, label %if.else.113

if.then.110:                                      ; preds = %if.then.90
  %93 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr111 = getelementptr inbounds %struct.sv*, %struct.sv** %93, i64 -1
  %94 = load %struct.sv*, %struct.sv** %add.ptr111, align 8
  %sv_any112 = getelementptr inbounds %struct.sv, %struct.sv* %94, i32 0, i32 0
  %95 = load i8*, i8** %sv_any112, align 8
  %96 = bitcast i8* %95 to %struct.xpvuv*
  %xuv_uv = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %96, i32 0, i32 3
  %97 = load i64, i64* %xuv_uv, align 8
  store i64 %97, i64* %alow, align 8
  br label %if.end.123

if.else.113:                                      ; preds = %if.then.90
  %98 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr115 = getelementptr inbounds %struct.sv*, %struct.sv** %98, i64 -1
  %99 = load %struct.sv*, %struct.sv** %add.ptr115, align 8
  %sv_any116 = getelementptr inbounds %struct.sv, %struct.sv* %99, i32 0, i32 0
  %100 = load i8*, i8** %sv_any116, align 8
  %101 = bitcast i8* %100 to %struct.xpviv*
  %xiv_iv117 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %101, i32 0, i32 3
  %102 = load i64, i64* %xiv_iv117, align 8
  store i64 %102, i64* %aiv, align 8
  %103 = load i64, i64* %aiv, align 8
  %cmp118 = icmp sge i64 %103, 0
  br i1 %cmp118, label %if.then.120, label %if.else.121

if.then.120:                                      ; preds = %if.else.113
  %104 = load i64, i64* %aiv, align 8
  store i64 %104, i64* %alow, align 8
  store i8 1, i8* %auvok, align 1
  br label %if.end.122

if.else.121:                                      ; preds = %if.else.113
  %105 = load i64, i64* %aiv, align 8
  %sub = sub nsw i64 0, %105
  store i64 %sub, i64* %alow, align 8
  br label %if.end.122

if.end.122:                                       ; preds = %if.else.121, %if.then.120
  br label %if.end.123

if.end.123:                                       ; preds = %if.end.122, %if.then.110
  %106 = load i8, i8* %buvok, align 1
  %tobool124 = icmp ne i8 %106, 0
  br i1 %tobool124, label %if.then.125, label %if.else.128

if.then.125:                                      ; preds = %if.end.123
  %107 = load %struct.sv**, %struct.sv*** %sp, align 8
  %108 = load %struct.sv*, %struct.sv** %107, align 8
  %sv_any126 = getelementptr inbounds %struct.sv, %struct.sv* %108, i32 0, i32 0
  %109 = load i8*, i8** %sv_any126, align 8
  %110 = bitcast i8* %109 to %struct.xpvuv*
  %xuv_uv127 = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %110, i32 0, i32 3
  %111 = load i64, i64* %xuv_uv127, align 8
  store i64 %111, i64* %blow, align 8
  br label %if.end.138

if.else.128:                                      ; preds = %if.end.123
  %112 = load %struct.sv**, %struct.sv*** %sp, align 8
  %113 = load %struct.sv*, %struct.sv** %112, align 8
  %sv_any130 = getelementptr inbounds %struct.sv, %struct.sv* %113, i32 0, i32 0
  %114 = load i8*, i8** %sv_any130, align 8
  %115 = bitcast i8* %114 to %struct.xpviv*
  %xiv_iv131 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %115, i32 0, i32 3
  %116 = load i64, i64* %xiv_iv131, align 8
  store i64 %116, i64* %biv, align 8
  %117 = load i64, i64* %biv, align 8
  %cmp132 = icmp sge i64 %117, 0
  br i1 %cmp132, label %if.then.134, label %if.else.135

if.then.134:                                      ; preds = %if.else.128
  %118 = load i64, i64* %biv, align 8
  store i64 %118, i64* %blow, align 8
  store i8 1, i8* %buvok, align 1
  br label %if.end.137

if.else.135:                                      ; preds = %if.else.128
  %119 = load i64, i64* %biv, align 8
  %sub136 = sub nsw i64 0, %119
  store i64 %sub136, i64* %blow, align 8
  br label %if.end.137

if.end.137:                                       ; preds = %if.else.135, %if.then.134
  br label %if.end.138

if.end.138:                                       ; preds = %if.end.137, %if.then.125
  %120 = load i64, i64* %alow, align 8
  %shr = lshr i64 %120, 32
  store i64 %shr, i64* %ahigh, align 8
  %121 = load i64, i64* %alow, align 8
  %and139 = and i64 %121, 4294967295
  store i64 %and139, i64* %alow, align 8
  %122 = load i64, i64* %blow, align 8
  %shr140 = lshr i64 %122, 32
  store i64 %shr140, i64* %bhigh, align 8
  %123 = load i64, i64* %blow, align 8
  %and141 = and i64 %123, 4294967295
  store i64 %and141, i64* %blow, align 8
  %124 = load i64, i64* %ahigh, align 8
  %tobool142 = icmp ne i64 %124, 0
  br i1 %tobool142, label %land.lhs.true.143, label %if.else.146

land.lhs.true.143:                                ; preds = %if.end.138
  %125 = load i64, i64* %bhigh, align 8
  %tobool144 = icmp ne i64 %125, 0
  br i1 %tobool144, label %if.then.145, label %if.else.146

if.then.145:                                      ; preds = %land.lhs.true.143
  br label %if.end.229

if.else.146:                                      ; preds = %land.lhs.true.143, %if.end.138
  %126 = load i64, i64* %ahigh, align 8
  %tobool147 = icmp ne i64 %126, 0
  br i1 %tobool147, label %if.else.182, label %land.lhs.true.148

land.lhs.true.148:                                ; preds = %if.else.146
  %127 = load i64, i64* %bhigh, align 8
  %tobool149 = icmp ne i64 %127, 0
  br i1 %tobool149, label %if.else.182, label %if.then.150

if.then.150:                                      ; preds = %land.lhs.true.148
  %128 = load i64, i64* %alow, align 8
  %129 = load i64, i64* %blow, align 8
  %mul = mul i64 %128, %129
  store i64 %mul, i64* %product, align 8
  %130 = load i8, i8* %auvok, align 1
  %conv152 = sext i8 %130 to i32
  %131 = load i8, i8* %buvok, align 1
  %conv153 = sext i8 %131 to i32
  %cmp154 = icmp eq i32 %conv152, %conv153
  br i1 %cmp154, label %if.then.156, label %if.else.166

if.then.156:                                      ; preds = %if.then.150
  %132 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr157 = getelementptr inbounds %struct.sv*, %struct.sv** %132, i32 -1
  store %struct.sv** %incdec.ptr157, %struct.sv*** %sp, align 8
  %133 = load %struct.sv*, %struct.sv** %targ, align 8
  %134 = load i64, i64* %product, align 8
  call void @Perl_sv_setuv(%struct.sv* %133, i64 %134)
  %135 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags158 = getelementptr inbounds %struct.sv, %struct.sv* %135, i32 0, i32 2
  %136 = load i32, i32* %sv_flags158, align 4
  %and159 = and i32 %136, 16384
  %tobool160 = icmp ne i32 %and159, 0
  br i1 %tobool160, label %if.then.161, label %if.end.163

if.then.161:                                      ; preds = %if.then.156
  %137 = load %struct.sv*, %struct.sv** %targ, align 8
  %call162 = call i32 @Perl_mg_set(%struct.sv* %137)
  br label %if.end.163

if.end.163:                                       ; preds = %if.then.161, %if.then.156
  %138 = load %struct.sv*, %struct.sv** %targ, align 8
  %139 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %138, %struct.sv** %139, align 8
  store %struct.sv* %138, %struct.sv** %tmp164
  %140 = load %struct.sv*, %struct.sv** %tmp164
  %141 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %141, %struct.sv*** @PL_stack_sp, align 8
  %142 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next165 = getelementptr inbounds %struct.op, %struct.op* %142, i32 0, i32 0
  %143 = load %struct.op*, %struct.op** %op_next165, align 8
  store %struct.op* %143, %struct.op** %retval
  br label %return

if.else.166:                                      ; preds = %if.then.150
  %144 = load i64, i64* %product, align 8
  %cmp167 = icmp ule i64 %144, -9223372036854775808
  br i1 %cmp167, label %if.then.169, label %if.end.180

if.then.169:                                      ; preds = %if.else.166
  %145 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr170 = getelementptr inbounds %struct.sv*, %struct.sv** %145, i32 -1
  store %struct.sv** %incdec.ptr170, %struct.sv*** %sp, align 8
  %146 = load %struct.sv*, %struct.sv** %targ, align 8
  %147 = load i64, i64* %product, align 8
  %sub171 = sub nsw i64 0, %147
  call void @Perl_sv_setiv(%struct.sv* %146, i64 %sub171)
  %148 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags172 = getelementptr inbounds %struct.sv, %struct.sv* %148, i32 0, i32 2
  %149 = load i32, i32* %sv_flags172, align 4
  %and173 = and i32 %149, 16384
  %tobool174 = icmp ne i32 %and173, 0
  br i1 %tobool174, label %if.then.175, label %if.end.177

if.then.175:                                      ; preds = %if.then.169
  %150 = load %struct.sv*, %struct.sv** %targ, align 8
  %call176 = call i32 @Perl_mg_set(%struct.sv* %150)
  br label %if.end.177

if.end.177:                                       ; preds = %if.then.175, %if.then.169
  %151 = load %struct.sv*, %struct.sv** %targ, align 8
  %152 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %151, %struct.sv** %152, align 8
  store %struct.sv* %151, %struct.sv** %tmp178
  %153 = load %struct.sv*, %struct.sv** %tmp178
  %154 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %154, %struct.sv*** @PL_stack_sp, align 8
  %155 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next179 = getelementptr inbounds %struct.op, %struct.op* %155, i32 0, i32 0
  %156 = load %struct.op*, %struct.op** %op_next179, align 8
  store %struct.op* %156, %struct.op** %retval
  br label %return

if.end.180:                                       ; preds = %if.else.166
  br label %if.end.181

if.end.181:                                       ; preds = %if.end.180
  br label %if.end.228

if.else.182:                                      ; preds = %land.lhs.true.148, %if.else.146
  %157 = load i64, i64* %bhigh, align 8
  %tobool184 = icmp ne i64 %157, 0
  br i1 %tobool184, label %if.then.185, label %if.end.186

if.then.185:                                      ; preds = %if.else.182
  %158 = load i64, i64* %bhigh, align 8
  store i64 %158, i64* %ahigh, align 8
  %159 = load i64, i64* %blow, align 8
  store i64 %159, i64* %bhigh, align 8
  %160 = load i64, i64* %alow, align 8
  store i64 %160, i64* %blow, align 8
  %161 = load i64, i64* %bhigh, align 8
  store i64 %161, i64* %alow, align 8
  br label %if.end.186

if.end.186:                                       ; preds = %if.then.185, %if.else.182
  %162 = load i64, i64* %ahigh, align 8
  %163 = load i64, i64* %blow, align 8
  %mul187 = mul i64 %162, %163
  store i64 %mul187, i64* %product_middle, align 8
  %164 = load i64, i64* %product_middle, align 8
  %and188 = and i64 %164, -4294967296
  %tobool189 = icmp ne i64 %and188, 0
  br i1 %tobool189, label %if.end.227, label %if.then.190

if.then.190:                                      ; preds = %if.end.186
  %165 = load i64, i64* %product_middle, align 8
  %shl = shl i64 %165, 32
  store i64 %shl, i64* %product_middle, align 8
  %166 = load i64, i64* %alow, align 8
  %167 = load i64, i64* %blow, align 8
  %mul192 = mul i64 %166, %167
  store i64 %mul192, i64* %product_low, align 8
  %168 = load i64, i64* %product_middle, align 8
  %169 = load i64, i64* %product_low, align 8
  %add = add i64 %169, %168
  store i64 %add, i64* %product_low, align 8
  %170 = load i64, i64* %product_low, align 8
  %171 = load i64, i64* %product_middle, align 8
  %cmp193 = icmp uge i64 %170, %171
  br i1 %cmp193, label %if.then.195, label %if.end.226

if.then.195:                                      ; preds = %if.then.190
  %172 = load i8, i8* %auvok, align 1
  %conv196 = sext i8 %172 to i32
  %173 = load i8, i8* %buvok, align 1
  %conv197 = sext i8 %173 to i32
  %cmp198 = icmp eq i32 %conv196, %conv197
  br i1 %cmp198, label %if.then.200, label %if.else.210

if.then.200:                                      ; preds = %if.then.195
  %174 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr201 = getelementptr inbounds %struct.sv*, %struct.sv** %174, i32 -1
  store %struct.sv** %incdec.ptr201, %struct.sv*** %sp, align 8
  %175 = load %struct.sv*, %struct.sv** %targ, align 8
  %176 = load i64, i64* %product_low, align 8
  call void @Perl_sv_setuv(%struct.sv* %175, i64 %176)
  %177 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags202 = getelementptr inbounds %struct.sv, %struct.sv* %177, i32 0, i32 2
  %178 = load i32, i32* %sv_flags202, align 4
  %and203 = and i32 %178, 16384
  %tobool204 = icmp ne i32 %and203, 0
  br i1 %tobool204, label %if.then.205, label %if.end.207

if.then.205:                                      ; preds = %if.then.200
  %179 = load %struct.sv*, %struct.sv** %targ, align 8
  %call206 = call i32 @Perl_mg_set(%struct.sv* %179)
  br label %if.end.207

if.end.207:                                       ; preds = %if.then.205, %if.then.200
  %180 = load %struct.sv*, %struct.sv** %targ, align 8
  %181 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %180, %struct.sv** %181, align 8
  store %struct.sv* %180, %struct.sv** %tmp208
  %182 = load %struct.sv*, %struct.sv** %tmp208
  %183 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %183, %struct.sv*** @PL_stack_sp, align 8
  %184 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next209 = getelementptr inbounds %struct.op, %struct.op* %184, i32 0, i32 0
  %185 = load %struct.op*, %struct.op** %op_next209, align 8
  store %struct.op* %185, %struct.op** %retval
  br label %return

if.else.210:                                      ; preds = %if.then.195
  %186 = load i64, i64* %product_low, align 8
  %cmp211 = icmp ule i64 %186, -9223372036854775808
  br i1 %cmp211, label %if.then.213, label %if.end.224

if.then.213:                                      ; preds = %if.else.210
  %187 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr214 = getelementptr inbounds %struct.sv*, %struct.sv** %187, i32 -1
  store %struct.sv** %incdec.ptr214, %struct.sv*** %sp, align 8
  %188 = load %struct.sv*, %struct.sv** %targ, align 8
  %189 = load i64, i64* %product_low, align 8
  %sub215 = sub nsw i64 0, %189
  call void @Perl_sv_setiv(%struct.sv* %188, i64 %sub215)
  %190 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags216 = getelementptr inbounds %struct.sv, %struct.sv* %190, i32 0, i32 2
  %191 = load i32, i32* %sv_flags216, align 4
  %and217 = and i32 %191, 16384
  %tobool218 = icmp ne i32 %and217, 0
  br i1 %tobool218, label %if.then.219, label %if.end.221

if.then.219:                                      ; preds = %if.then.213
  %192 = load %struct.sv*, %struct.sv** %targ, align 8
  %call220 = call i32 @Perl_mg_set(%struct.sv* %192)
  br label %if.end.221

if.end.221:                                       ; preds = %if.then.219, %if.then.213
  %193 = load %struct.sv*, %struct.sv** %targ, align 8
  %194 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %193, %struct.sv** %194, align 8
  store %struct.sv* %193, %struct.sv** %tmp222
  %195 = load %struct.sv*, %struct.sv** %tmp222
  %196 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %196, %struct.sv*** @PL_stack_sp, align 8
  %197 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next223 = getelementptr inbounds %struct.op, %struct.op* %197, i32 0, i32 0
  %198 = load %struct.op*, %struct.op** %op_next223, align 8
  store %struct.op* %198, %struct.op** %retval
  br label %return

if.end.224:                                       ; preds = %if.else.210
  br label %if.end.225

if.end.225:                                       ; preds = %if.end.224
  br label %if.end.226

if.end.226:                                       ; preds = %if.end.225, %if.then.190
  br label %if.end.227

if.end.227:                                       ; preds = %if.end.226, %if.end.186
  br label %if.end.228

if.end.228:                                       ; preds = %if.end.227, %if.end.181
  br label %if.end.229

if.end.229:                                       ; preds = %if.end.228, %if.then.145
  br label %if.end.230

if.end.230:                                       ; preds = %if.end.229, %if.end.85
  br label %if.end.231

if.end.231:                                       ; preds = %if.end.230, %if.end.52
  %199 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr234 = getelementptr inbounds %struct.sv*, %struct.sv** %199, i32 -1
  store %struct.sv** %incdec.ptr234, %struct.sv*** %sp, align 8
  %200 = load %struct.sv*, %struct.sv** %199, align 8
  store %struct.sv* %200, %struct.sv** @PL_Sv, align 8
  %201 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags235 = getelementptr inbounds %struct.sv, %struct.sv* %201, i32 0, i32 2
  %202 = load i32, i32* %sv_flags235, align 4
  %and236 = and i32 %202, 131072
  %tobool237 = icmp ne i32 %and236, 0
  br i1 %tobool237, label %cond.true.238, label %cond.false.240

cond.true.238:                                    ; preds = %if.end.231
  %203 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any239 = getelementptr inbounds %struct.sv, %struct.sv* %203, i32 0, i32 0
  %204 = load i8*, i8** %sv_any239, align 8
  %205 = bitcast i8* %204 to %struct.xpvnv*
  %xnv_nv = getelementptr inbounds %struct.xpvnv, %struct.xpvnv* %205, i32 0, i32 4
  %206 = load double, double* %xnv_nv, align 8
  br label %cond.end.242

cond.false.240:                                   ; preds = %if.end.231
  %207 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call241 = call double @Perl_sv_2nv(%struct.sv* %207)
  br label %cond.end.242

cond.end.242:                                     ; preds = %cond.false.240, %cond.true.238
  %cond243 = phi double [ %206, %cond.true.238 ], [ %call241, %cond.false.240 ]
  store double %cond243, double* %right233, align 8
  %208 = load %struct.sv**, %struct.sv*** %sp, align 8
  %209 = load %struct.sv*, %struct.sv** %208, align 8
  %sv_flags246 = getelementptr inbounds %struct.sv, %struct.sv* %209, i32 0, i32 2
  %210 = load i32, i32* %sv_flags246, align 4
  %and247 = and i32 %210, 131072
  %tobool248 = icmp ne i32 %and247, 0
  br i1 %tobool248, label %cond.true.249, label %cond.false.252

cond.true.249:                                    ; preds = %cond.end.242
  %211 = load %struct.sv**, %struct.sv*** %sp, align 8
  %212 = load %struct.sv*, %struct.sv** %211, align 8
  %sv_any250 = getelementptr inbounds %struct.sv, %struct.sv* %212, i32 0, i32 0
  %213 = load i8*, i8** %sv_any250, align 8
  %214 = bitcast i8* %213 to %struct.xpvnv*
  %xnv_nv251 = getelementptr inbounds %struct.xpvnv, %struct.xpvnv* %214, i32 0, i32 4
  %215 = load double, double* %xnv_nv251, align 8
  br label %cond.end.254

cond.false.252:                                   ; preds = %cond.end.242
  %216 = load %struct.sv**, %struct.sv*** %sp, align 8
  %217 = load %struct.sv*, %struct.sv** %216, align 8
  %call253 = call double @Perl_sv_2nv(%struct.sv* %217)
  br label %cond.end.254

cond.end.254:                                     ; preds = %cond.false.252, %cond.true.249
  %cond255 = phi double [ %215, %cond.true.249 ], [ %call253, %cond.false.252 ]
  store double %cond255, double* %left245, align 8
  %218 = load %struct.sv*, %struct.sv** %targ, align 8
  %219 = load double, double* %left245, align 8
  %220 = load double, double* %right233, align 8
  %mul256 = fmul double %219, %220
  call void @Perl_sv_setnv(%struct.sv* %218, double %mul256)
  %221 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags257 = getelementptr inbounds %struct.sv, %struct.sv* %221, i32 0, i32 2
  %222 = load i32, i32* %sv_flags257, align 4
  %and258 = and i32 %222, 16384
  %tobool259 = icmp ne i32 %and258, 0
  br i1 %tobool259, label %if.then.260, label %if.end.262

if.then.260:                                      ; preds = %cond.end.254
  %223 = load %struct.sv*, %struct.sv** %targ, align 8
  %call261 = call i32 @Perl_mg_set(%struct.sv* %223)
  br label %if.end.262

if.end.262:                                       ; preds = %if.then.260, %cond.end.254
  %224 = load %struct.sv*, %struct.sv** %targ, align 8
  %225 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %224, %struct.sv** %225, align 8
  store %struct.sv* %224, %struct.sv** %tmp263
  %226 = load %struct.sv*, %struct.sv** %tmp263
  %227 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %227, %struct.sv*** @PL_stack_sp, align 8
  %228 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next264 = getelementptr inbounds %struct.op, %struct.op* %228, i32 0, i32 0
  %229 = load %struct.op*, %struct.op** %op_next264, align 8
  store %struct.op* %229, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.262, %if.end.221, %if.end.207, %if.end.177, %if.end.163, %if.end.29
  %230 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %230
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_divide() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %right = alloca %struct.sv*, align 8
  %left = alloca %struct.sv*, align 8
  %tmp = alloca %struct.sv*, align 8
  %left_non_neg = alloca i8, align 1
  %right_non_neg = alloca i8, align 1
  %left104 = alloca i64, align 8
  %right106 = alloca i64, align 8
  %biv = alloca i64, align 8
  %aiv = alloca i64, align 8
  %result = alloca i64, align 8
  %tmp164 = alloca %struct.sv*, align 8
  %tmp177 = alloca %struct.sv*, align 8
  %tmp187 = alloca %struct.sv*, align 8
  %right195 = alloca double, align 8
  %left207 = alloca double, align 8
  %tmp231 = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 6
  %2 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 64
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load %struct.sv**, %struct.sv*** %sp, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 -1
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %5 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %5, i32 0, i32 3
  %6 = load i64, i64* %op_targ, align 8
  %7 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx1 = getelementptr inbounds %struct.sv*, %struct.sv** %7, i64 %6
  %8 = load %struct.sv*, %struct.sv** %arrayidx1, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.sv* [ %4, %cond.true ], [ %8, %cond.false ]
  store %struct.sv* %cond, %struct.sv** %targ, align 8
  %9 = load i64, i64* @PL_amagic_generation, align 8
  %tobool2 = icmp ne i64 %9, 0
  br i1 %tobool2, label %if.then, label %if.end.31

if.then:                                          ; preds = %cond.end
  %10 = load %struct.sv**, %struct.sv*** %sp, align 8
  %11 = load %struct.sv*, %struct.sv** %10, align 8
  store %struct.sv* %11, %struct.sv** %right, align 8
  %12 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %12, i64 -1
  %13 = load %struct.sv*, %struct.sv** %add.ptr, align 8
  store %struct.sv* %13, %struct.sv** %left, align 8
  %14 = load %struct.sv*, %struct.sv** %left, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %14, i32 0, i32 2
  %15 = load i32, i32* %sv_flags, align 4
  %and3 = and i32 %15, 268435456
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %16 = load %struct.sv*, %struct.sv** %right, align 8
  %sv_flags5 = getelementptr inbounds %struct.sv, %struct.sv* %16, i32 0, i32 2
  %17 = load i32, i32* %sv_flags5, align 4
  %and6 = and i32 %17, 268435456
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %land.lhs.true, label %if.end.30

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %18 = load %struct.sv*, %struct.sv** %left, align 8
  %19 = load %struct.sv*, %struct.sv** %right, align 8
  %20 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags8 = getelementptr inbounds %struct.op, %struct.op* %20, i32 0, i32 6
  %21 = load i8, i8* %op_flags8, align 1
  %conv9 = zext i8 %21 to i32
  %and10 = and i32 %conv9, 64
  %tobool11 = icmp ne i32 %and10, 0
  %cond12 = select i1 %tobool11, i32 4, i32 0
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %18, %struct.sv* %19, i32 12, i32 %cond12)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool13 = icmp ne %struct.sv* %call, null
  br i1 %tobool13, label %if.then.14, label %if.end.30

if.then.14:                                       ; preds = %land.lhs.true
  %22 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %22, %struct.sv*** %sp, align 8
  %23 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %23, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %24 = load %struct.sv*, %struct.sv** %23, align 8
  %25 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags15 = getelementptr inbounds %struct.op, %struct.op* %25, i32 0, i32 6
  %26 = load i8, i8* %op_flags15, align 1
  %conv16 = zext i8 %26 to i32
  %and17 = and i32 %conv16, 64
  %tobool18 = icmp ne i32 %and17, 0
  br i1 %tobool18, label %if.then.23, label %lor.lhs.false.19

lor.lhs.false.19:                                 ; preds = %if.then.14
  %27 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags20 = getelementptr inbounds %struct.sv, %struct.sv* %27, i32 0, i32 2
  %28 = load i32, i32* %sv_flags20, align 4
  %and21 = and i32 %28, 1024
  %tobool22 = icmp ne i32 %and21, 0
  br i1 %tobool22, label %if.then.23, label %if.else

if.then.23:                                       ; preds = %lor.lhs.false.19, %if.then.14
  %29 = load %struct.sv*, %struct.sv** %targ, align 8
  %30 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  call void @Perl_sv_setsv_flags(%struct.sv* %29, %struct.sv* %30, i32 2)
  %31 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags24 = getelementptr inbounds %struct.sv, %struct.sv* %31, i32 0, i32 2
  %32 = load i32, i32* %sv_flags24, align 4
  %and25 = and i32 %32, 16384
  %tobool26 = icmp ne i32 %and25, 0
  br i1 %tobool26, label %if.then.27, label %if.end

if.then.27:                                       ; preds = %if.then.23
  %33 = load %struct.sv*, %struct.sv** %targ, align 8
  %call28 = call i32 @Perl_mg_set(%struct.sv* %33)
  br label %if.end

if.end:                                           ; preds = %if.then.27, %if.then.23
  %34 = load %struct.sv*, %struct.sv** %targ, align 8
  %35 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %34, %struct.sv** %35, align 8
  store %struct.sv* %34, %struct.sv** %tmp
  %36 = load %struct.sv*, %struct.sv** %tmp
  br label %if.end.29

if.else:                                          ; preds = %lor.lhs.false.19
  %37 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %38 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %37, %struct.sv** %38, align 8
  br label %if.end.29

if.end.29:                                        ; preds = %if.else, %if.end
  %39 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %39, %struct.sv*** @PL_stack_sp, align 8
  %40 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %40, i32 0, i32 0
  %41 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %41, %struct.op** %retval
  br label %return

if.end.30:                                        ; preds = %land.lhs.true, %lor.lhs.false
  br label %if.end.31

if.end.31:                                        ; preds = %if.end.30, %cond.end
  %42 = load %struct.sv**, %struct.sv*** %sp, align 8
  %43 = load %struct.sv*, %struct.sv** %42, align 8
  %sv_flags32 = getelementptr inbounds %struct.sv, %struct.sv* %43, i32 0, i32 2
  %44 = load i32, i32* %sv_flags32, align 4
  %and33 = and i32 %44, 16777216
  %tobool34 = icmp ne i32 %and33, 0
  br i1 %tobool34, label %if.end.52, label %land.lhs.true.35

land.lhs.true.35:                                 ; preds = %if.end.31
  %45 = load %struct.sv**, %struct.sv*** %sp, align 8
  %46 = load %struct.sv*, %struct.sv** %45, align 8
  %sv_flags36 = getelementptr inbounds %struct.sv, %struct.sv* %46, i32 0, i32 2
  %47 = load i32, i32* %sv_flags36, align 4
  %and37 = and i32 %47, 131072
  %tobool38 = icmp ne i32 %and37, 0
  br i1 %tobool38, label %if.then.43, label %lor.lhs.false.39

lor.lhs.false.39:                                 ; preds = %land.lhs.true.35
  %48 = load %struct.sv**, %struct.sv*** %sp, align 8
  %49 = load %struct.sv*, %struct.sv** %48, align 8
  %sv_flags40 = getelementptr inbounds %struct.sv, %struct.sv* %49, i32 0, i32 2
  %50 = load i32, i32* %sv_flags40, align 4
  %and41 = and i32 %50, 262144
  %tobool42 = icmp ne i32 %and41, 0
  br i1 %tobool42, label %if.then.43, label %if.end.52

if.then.43:                                       ; preds = %lor.lhs.false.39, %land.lhs.true.35
  %51 = load %struct.sv**, %struct.sv*** %sp, align 8
  %52 = load %struct.sv*, %struct.sv** %51, align 8
  %sv_flags44 = getelementptr inbounds %struct.sv, %struct.sv* %52, i32 0, i32 2
  %53 = load i32, i32* %sv_flags44, align 4
  %and45 = and i32 %53, 65536
  %tobool46 = icmp ne i32 %and45, 0
  br i1 %tobool46, label %cond.true.47, label %cond.false.48

cond.true.47:                                     ; preds = %if.then.43
  %54 = load %struct.sv**, %struct.sv*** %sp, align 8
  %55 = load %struct.sv*, %struct.sv** %54, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %55, i32 0, i32 0
  %56 = load i8*, i8** %sv_any, align 8
  %57 = bitcast i8* %56 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %57, i32 0, i32 3
  %58 = load i64, i64* %xiv_iv, align 8
  br label %cond.end.50

cond.false.48:                                    ; preds = %if.then.43
  %59 = load %struct.sv**, %struct.sv*** %sp, align 8
  %60 = load %struct.sv*, %struct.sv** %59, align 8
  %call49 = call i64 @Perl_sv_2iv(%struct.sv* %60)
  br label %cond.end.50

cond.end.50:                                      ; preds = %cond.false.48, %cond.true.47
  %cond51 = phi i64 [ %58, %cond.true.47 ], [ %call49, %cond.false.48 ]
  br label %if.end.52

if.end.52:                                        ; preds = %cond.end.50, %lor.lhs.false.39, %if.end.31
  %61 = load %struct.sv**, %struct.sv*** %sp, align 8
  %62 = load %struct.sv*, %struct.sv** %61, align 8
  %sv_flags53 = getelementptr inbounds %struct.sv, %struct.sv* %62, i32 0, i32 2
  %63 = load i32, i32* %sv_flags53, align 4
  %and54 = and i32 %63, 65536
  %tobool55 = icmp ne i32 %and54, 0
  br i1 %tobool55, label %if.then.56, label %if.end.193

if.then.56:                                       ; preds = %if.end.52
  %64 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr57 = getelementptr inbounds %struct.sv*, %struct.sv** %64, i64 -1
  %65 = load %struct.sv*, %struct.sv** %add.ptr57, align 8
  %sv_flags58 = getelementptr inbounds %struct.sv, %struct.sv* %65, i32 0, i32 2
  %66 = load i32, i32* %sv_flags58, align 4
  %and59 = and i32 %66, 16777216
  %tobool60 = icmp ne i32 %and59, 0
  br i1 %tobool60, label %if.end.85, label %land.lhs.true.61

land.lhs.true.61:                                 ; preds = %if.then.56
  %67 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr62 = getelementptr inbounds %struct.sv*, %struct.sv** %67, i64 -1
  %68 = load %struct.sv*, %struct.sv** %add.ptr62, align 8
  %sv_flags63 = getelementptr inbounds %struct.sv, %struct.sv* %68, i32 0, i32 2
  %69 = load i32, i32* %sv_flags63, align 4
  %and64 = and i32 %69, 131072
  %tobool65 = icmp ne i32 %and64, 0
  br i1 %tobool65, label %if.then.71, label %lor.lhs.false.66

lor.lhs.false.66:                                 ; preds = %land.lhs.true.61
  %70 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr67 = getelementptr inbounds %struct.sv*, %struct.sv** %70, i64 -1
  %71 = load %struct.sv*, %struct.sv** %add.ptr67, align 8
  %sv_flags68 = getelementptr inbounds %struct.sv, %struct.sv* %71, i32 0, i32 2
  %72 = load i32, i32* %sv_flags68, align 4
  %and69 = and i32 %72, 262144
  %tobool70 = icmp ne i32 %and69, 0
  br i1 %tobool70, label %if.then.71, label %if.end.85

if.then.71:                                       ; preds = %lor.lhs.false.66, %land.lhs.true.61
  %73 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr72 = getelementptr inbounds %struct.sv*, %struct.sv** %73, i64 -1
  %74 = load %struct.sv*, %struct.sv** %add.ptr72, align 8
  %sv_flags73 = getelementptr inbounds %struct.sv, %struct.sv* %74, i32 0, i32 2
  %75 = load i32, i32* %sv_flags73, align 4
  %and74 = and i32 %75, 65536
  %tobool75 = icmp ne i32 %and74, 0
  br i1 %tobool75, label %cond.true.76, label %cond.false.80

cond.true.76:                                     ; preds = %if.then.71
  %76 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr77 = getelementptr inbounds %struct.sv*, %struct.sv** %76, i64 -1
  %77 = load %struct.sv*, %struct.sv** %add.ptr77, align 8
  %sv_any78 = getelementptr inbounds %struct.sv, %struct.sv* %77, i32 0, i32 0
  %78 = load i8*, i8** %sv_any78, align 8
  %79 = bitcast i8* %78 to %struct.xpviv*
  %xiv_iv79 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %79, i32 0, i32 3
  %80 = load i64, i64* %xiv_iv79, align 8
  br label %cond.end.83

cond.false.80:                                    ; preds = %if.then.71
  %81 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr81 = getelementptr inbounds %struct.sv*, %struct.sv** %81, i64 -1
  %82 = load %struct.sv*, %struct.sv** %add.ptr81, align 8
  %call82 = call i64 @Perl_sv_2iv(%struct.sv* %82)
  br label %cond.end.83

cond.end.83:                                      ; preds = %cond.false.80, %cond.true.76
  %cond84 = phi i64 [ %80, %cond.true.76 ], [ %call82, %cond.false.80 ]
  br label %if.end.85

if.end.85:                                        ; preds = %cond.end.83, %lor.lhs.false.66, %if.then.56
  %83 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr86 = getelementptr inbounds %struct.sv*, %struct.sv** %83, i64 -1
  %84 = load %struct.sv*, %struct.sv** %add.ptr86, align 8
  %sv_flags87 = getelementptr inbounds %struct.sv, %struct.sv* %84, i32 0, i32 2
  %85 = load i32, i32* %sv_flags87, align 4
  %and88 = and i32 %85, 65536
  %tobool89 = icmp ne i32 %and88, 0
  br i1 %tobool89, label %if.then.90, label %if.end.192

if.then.90:                                       ; preds = %if.end.85
  %86 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr92 = getelementptr inbounds %struct.sv*, %struct.sv** %86, i64 -1
  %87 = load %struct.sv*, %struct.sv** %add.ptr92, align 8
  %sv_flags93 = getelementptr inbounds %struct.sv, %struct.sv* %87, i32 0, i32 2
  %88 = load i32, i32* %sv_flags93, align 4
  %and94 = and i32 %88, -2147418112
  %cmp = icmp eq i32 %and94, -2147418112
  %conv95 = zext i1 %cmp to i32
  %conv96 = trunc i32 %conv95 to i8
  store i8 %conv96, i8* %left_non_neg, align 1
  %89 = load %struct.sv**, %struct.sv*** %sp, align 8
  %90 = load %struct.sv*, %struct.sv** %89, align 8
  %sv_flags98 = getelementptr inbounds %struct.sv, %struct.sv* %90, i32 0, i32 2
  %91 = load i32, i32* %sv_flags98, align 4
  %and99 = and i32 %91, -2147418112
  %cmp100 = icmp eq i32 %and99, -2147418112
  %conv101 = zext i1 %cmp100 to i32
  %conv102 = trunc i32 %conv101 to i8
  store i8 %conv102, i8* %right_non_neg, align 1
  %92 = load i8, i8* %right_non_neg, align 1
  %tobool107 = icmp ne i8 %92, 0
  br i1 %tobool107, label %if.then.108, label %if.else.110

if.then.108:                                      ; preds = %if.then.90
  %93 = load %struct.sv**, %struct.sv*** %sp, align 8
  %94 = load %struct.sv*, %struct.sv** %93, align 8
  %sv_any109 = getelementptr inbounds %struct.sv, %struct.sv* %94, i32 0, i32 0
  %95 = load i8*, i8** %sv_any109, align 8
  %96 = bitcast i8* %95 to %struct.xpvuv*
  %xuv_uv = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %96, i32 0, i32 3
  %97 = load i64, i64* %xuv_uv, align 8
  store i64 %97, i64* %right106, align 8
  br label %if.end.119

if.else.110:                                      ; preds = %if.then.90
  %98 = load %struct.sv**, %struct.sv*** %sp, align 8
  %99 = load %struct.sv*, %struct.sv** %98, align 8
  %sv_any112 = getelementptr inbounds %struct.sv, %struct.sv* %99, i32 0, i32 0
  %100 = load i8*, i8** %sv_any112, align 8
  %101 = bitcast i8* %100 to %struct.xpviv*
  %xiv_iv113 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %101, i32 0, i32 3
  %102 = load i64, i64* %xiv_iv113, align 8
  store i64 %102, i64* %biv, align 8
  %103 = load i64, i64* %biv, align 8
  %cmp114 = icmp sge i64 %103, 0
  br i1 %cmp114, label %if.then.116, label %if.else.117

if.then.116:                                      ; preds = %if.else.110
  %104 = load i64, i64* %biv, align 8
  store i64 %104, i64* %right106, align 8
  store i8 1, i8* %right_non_neg, align 1
  br label %if.end.118

if.else.117:                                      ; preds = %if.else.110
  %105 = load i64, i64* %biv, align 8
  %sub = sub nsw i64 0, %105
  store i64 %sub, i64* %right106, align 8
  br label %if.end.118

if.end.118:                                       ; preds = %if.else.117, %if.then.116
  br label %if.end.119

if.end.119:                                       ; preds = %if.end.118, %if.then.108
  %106 = load i64, i64* %right106, align 8
  %cmp120 = icmp eq i64 %106, 0
  br i1 %cmp120, label %if.then.122, label %if.end.124

if.then.122:                                      ; preds = %if.end.119
  %call123 = call %struct.op* (i8*, ...) @Perl_die(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.29, i32 0, i32 0))
  store %struct.op* %call123, %struct.op** %retval
  br label %return

if.end.124:                                       ; preds = %if.end.119
  %107 = load i8, i8* %left_non_neg, align 1
  %tobool125 = icmp ne i8 %107, 0
  br i1 %tobool125, label %if.then.126, label %if.else.130

if.then.126:                                      ; preds = %if.end.124
  %108 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr127 = getelementptr inbounds %struct.sv*, %struct.sv** %108, i64 -1
  %109 = load %struct.sv*, %struct.sv** %add.ptr127, align 8
  %sv_any128 = getelementptr inbounds %struct.sv, %struct.sv* %109, i32 0, i32 0
  %110 = load i8*, i8** %sv_any128, align 8
  %111 = bitcast i8* %110 to %struct.xpvuv*
  %xuv_uv129 = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %111, i32 0, i32 3
  %112 = load i64, i64* %xuv_uv129, align 8
  store i64 %112, i64* %left104, align 8
  br label %if.end.141

if.else.130:                                      ; preds = %if.end.124
  %113 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr132 = getelementptr inbounds %struct.sv*, %struct.sv** %113, i64 -1
  %114 = load %struct.sv*, %struct.sv** %add.ptr132, align 8
  %sv_any133 = getelementptr inbounds %struct.sv, %struct.sv* %114, i32 0, i32 0
  %115 = load i8*, i8** %sv_any133, align 8
  %116 = bitcast i8* %115 to %struct.xpviv*
  %xiv_iv134 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %116, i32 0, i32 3
  %117 = load i64, i64* %xiv_iv134, align 8
  store i64 %117, i64* %aiv, align 8
  %118 = load i64, i64* %aiv, align 8
  %cmp135 = icmp sge i64 %118, 0
  br i1 %cmp135, label %if.then.137, label %if.else.138

if.then.137:                                      ; preds = %if.else.130
  %119 = load i64, i64* %aiv, align 8
  store i64 %119, i64* %left104, align 8
  store i8 1, i8* %left_non_neg, align 1
  br label %if.end.140

if.else.138:                                      ; preds = %if.else.130
  %120 = load i64, i64* %aiv, align 8
  %sub139 = sub nsw i64 0, %120
  store i64 %sub139, i64* %left104, align 8
  br label %if.end.140

if.end.140:                                       ; preds = %if.else.138, %if.then.137
  br label %if.end.141

if.end.141:                                       ; preds = %if.end.140, %if.then.126
  %121 = load i64, i64* %left104, align 8
  %122 = load i64, i64* %right106, align 8
  %cmp142 = icmp uge i64 %121, %122
  br i1 %cmp142, label %land.lhs.true.144, label %if.end.191

land.lhs.true.144:                                ; preds = %if.end.141
  %123 = load i64, i64* %left104, align 8
  %cmp145 = icmp ugt i64 %123, 4294967296
  br i1 %cmp145, label %if.then.147, label %if.end.191

if.then.147:                                      ; preds = %land.lhs.true.144
  %124 = load i64, i64* %left104, align 8
  %125 = load i64, i64* %right106, align 8
  %div = udiv i64 %124, %125
  store i64 %div, i64* %result, align 8
  %126 = load i64, i64* %result, align 8
  %127 = load i64, i64* %right106, align 8
  %mul = mul i64 %126, %127
  %128 = load i64, i64* %left104, align 8
  %cmp149 = icmp eq i64 %mul, %128
  br i1 %cmp149, label %if.then.151, label %if.end.190

if.then.151:                                      ; preds = %if.then.147
  %129 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr152 = getelementptr inbounds %struct.sv*, %struct.sv** %129, i32 -1
  store %struct.sv** %incdec.ptr152, %struct.sv*** %sp, align 8
  %130 = load i8, i8* %left_non_neg, align 1
  %conv153 = sext i8 %130 to i32
  %131 = load i8, i8* %right_non_neg, align 1
  %conv154 = sext i8 %131 to i32
  %cmp155 = icmp eq i32 %conv153, %conv154
  br i1 %cmp155, label %if.then.157, label %if.end.166

if.then.157:                                      ; preds = %if.then.151
  %132 = load %struct.sv*, %struct.sv** %targ, align 8
  %133 = load i64, i64* %result, align 8
  call void @Perl_sv_setuv(%struct.sv* %132, i64 %133)
  %134 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags158 = getelementptr inbounds %struct.sv, %struct.sv* %134, i32 0, i32 2
  %135 = load i32, i32* %sv_flags158, align 4
  %and159 = and i32 %135, 16384
  %tobool160 = icmp ne i32 %and159, 0
  br i1 %tobool160, label %if.then.161, label %if.end.163

if.then.161:                                      ; preds = %if.then.157
  %136 = load %struct.sv*, %struct.sv** %targ, align 8
  %call162 = call i32 @Perl_mg_set(%struct.sv* %136)
  br label %if.end.163

if.end.163:                                       ; preds = %if.then.161, %if.then.157
  %137 = load %struct.sv*, %struct.sv** %targ, align 8
  %138 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %137, %struct.sv** %138, align 8
  store %struct.sv* %137, %struct.sv** %tmp164
  %139 = load %struct.sv*, %struct.sv** %tmp164
  %140 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %140, %struct.sv*** @PL_stack_sp, align 8
  %141 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next165 = getelementptr inbounds %struct.op, %struct.op* %141, i32 0, i32 0
  %142 = load %struct.op*, %struct.op** %op_next165, align 8
  store %struct.op* %142, %struct.op** %retval
  br label %return

if.end.166:                                       ; preds = %if.then.151
  %143 = load i64, i64* %result, align 8
  %cmp167 = icmp ule i64 %143, -9223372036854775808
  br i1 %cmp167, label %if.then.169, label %if.else.178

if.then.169:                                      ; preds = %if.end.166
  %144 = load %struct.sv*, %struct.sv** %targ, align 8
  %145 = load i64, i64* %result, align 8
  %sub170 = sub nsw i64 0, %145
  call void @Perl_sv_setiv(%struct.sv* %144, i64 %sub170)
  %146 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags171 = getelementptr inbounds %struct.sv, %struct.sv* %146, i32 0, i32 2
  %147 = load i32, i32* %sv_flags171, align 4
  %and172 = and i32 %147, 16384
  %tobool173 = icmp ne i32 %and172, 0
  br i1 %tobool173, label %if.then.174, label %if.end.176

if.then.174:                                      ; preds = %if.then.169
  %148 = load %struct.sv*, %struct.sv** %targ, align 8
  %call175 = call i32 @Perl_mg_set(%struct.sv* %148)
  br label %if.end.176

if.end.176:                                       ; preds = %if.then.174, %if.then.169
  %149 = load %struct.sv*, %struct.sv** %targ, align 8
  %150 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %149, %struct.sv** %150, align 8
  store %struct.sv* %149, %struct.sv** %tmp177
  %151 = load %struct.sv*, %struct.sv** %tmp177
  br label %if.end.188

if.else.178:                                      ; preds = %if.end.166
  %152 = load %struct.sv*, %struct.sv** %targ, align 8
  %153 = load i64, i64* %result, align 8
  %conv179 = uitofp i64 %153 to double
  %sub180 = fsub double -0.000000e+00, %conv179
  call void @Perl_sv_setnv(%struct.sv* %152, double %sub180)
  %154 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags181 = getelementptr inbounds %struct.sv, %struct.sv* %154, i32 0, i32 2
  %155 = load i32, i32* %sv_flags181, align 4
  %and182 = and i32 %155, 16384
  %tobool183 = icmp ne i32 %and182, 0
  br i1 %tobool183, label %if.then.184, label %if.end.186

if.then.184:                                      ; preds = %if.else.178
  %156 = load %struct.sv*, %struct.sv** %targ, align 8
  %call185 = call i32 @Perl_mg_set(%struct.sv* %156)
  br label %if.end.186

if.end.186:                                       ; preds = %if.then.184, %if.else.178
  %157 = load %struct.sv*, %struct.sv** %targ, align 8
  %158 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %157, %struct.sv** %158, align 8
  store %struct.sv* %157, %struct.sv** %tmp187
  %159 = load %struct.sv*, %struct.sv** %tmp187
  br label %if.end.188

if.end.188:                                       ; preds = %if.end.186, %if.end.176
  %160 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %160, %struct.sv*** @PL_stack_sp, align 8
  %161 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next189 = getelementptr inbounds %struct.op, %struct.op* %161, i32 0, i32 0
  %162 = load %struct.op*, %struct.op** %op_next189, align 8
  store %struct.op* %162, %struct.op** %retval
  br label %return

if.end.190:                                       ; preds = %if.then.147
  br label %if.end.191

if.end.191:                                       ; preds = %if.end.190, %land.lhs.true.144, %if.end.141
  br label %if.end.192

if.end.192:                                       ; preds = %if.end.191, %if.end.85
  br label %if.end.193

if.end.193:                                       ; preds = %if.end.192, %if.end.52
  %163 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr196 = getelementptr inbounds %struct.sv*, %struct.sv** %163, i32 -1
  store %struct.sv** %incdec.ptr196, %struct.sv*** %sp, align 8
  %164 = load %struct.sv*, %struct.sv** %163, align 8
  store %struct.sv* %164, %struct.sv** @PL_Sv, align 8
  %165 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags197 = getelementptr inbounds %struct.sv, %struct.sv* %165, i32 0, i32 2
  %166 = load i32, i32* %sv_flags197, align 4
  %and198 = and i32 %166, 131072
  %tobool199 = icmp ne i32 %and198, 0
  br i1 %tobool199, label %cond.true.200, label %cond.false.202

cond.true.200:                                    ; preds = %if.end.193
  %167 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any201 = getelementptr inbounds %struct.sv, %struct.sv* %167, i32 0, i32 0
  %168 = load i8*, i8** %sv_any201, align 8
  %169 = bitcast i8* %168 to %struct.xpvnv*
  %xnv_nv = getelementptr inbounds %struct.xpvnv, %struct.xpvnv* %169, i32 0, i32 4
  %170 = load double, double* %xnv_nv, align 8
  br label %cond.end.204

cond.false.202:                                   ; preds = %if.end.193
  %171 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call203 = call double @Perl_sv_2nv(%struct.sv* %171)
  br label %cond.end.204

cond.end.204:                                     ; preds = %cond.false.202, %cond.true.200
  %cond205 = phi double [ %170, %cond.true.200 ], [ %call203, %cond.false.202 ]
  store double %cond205, double* %right195, align 8
  %172 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr208 = getelementptr inbounds %struct.sv*, %struct.sv** %172, i32 -1
  store %struct.sv** %incdec.ptr208, %struct.sv*** %sp, align 8
  %173 = load %struct.sv*, %struct.sv** %172, align 8
  store %struct.sv* %173, %struct.sv** @PL_Sv, align 8
  %174 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags209 = getelementptr inbounds %struct.sv, %struct.sv* %174, i32 0, i32 2
  %175 = load i32, i32* %sv_flags209, align 4
  %and210 = and i32 %175, 131072
  %tobool211 = icmp ne i32 %and210, 0
  br i1 %tobool211, label %cond.true.212, label %cond.false.215

cond.true.212:                                    ; preds = %cond.end.204
  %176 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any213 = getelementptr inbounds %struct.sv, %struct.sv* %176, i32 0, i32 0
  %177 = load i8*, i8** %sv_any213, align 8
  %178 = bitcast i8* %177 to %struct.xpvnv*
  %xnv_nv214 = getelementptr inbounds %struct.xpvnv, %struct.xpvnv* %178, i32 0, i32 4
  %179 = load double, double* %xnv_nv214, align 8
  br label %cond.end.217

cond.false.215:                                   ; preds = %cond.end.204
  %180 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call216 = call double @Perl_sv_2nv(%struct.sv* %180)
  br label %cond.end.217

cond.end.217:                                     ; preds = %cond.false.215, %cond.true.212
  %cond218 = phi double [ %179, %cond.true.212 ], [ %call216, %cond.false.215 ]
  store double %cond218, double* %left207, align 8
  %181 = load double, double* %right195, align 8
  %cmp219 = fcmp oeq double %181, 0.000000e+00
  br i1 %cmp219, label %if.then.221, label %if.end.223

if.then.221:                                      ; preds = %cond.end.217
  %call222 = call %struct.op* (i8*, ...) @Perl_die(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.29, i32 0, i32 0))
  store %struct.op* %call222, %struct.op** %retval
  br label %return

if.end.223:                                       ; preds = %cond.end.217
  %182 = load %struct.sv*, %struct.sv** %targ, align 8
  %183 = load double, double* %left207, align 8
  %184 = load double, double* %right195, align 8
  %div224 = fdiv double %183, %184
  call void @Perl_sv_setnv(%struct.sv* %182, double %div224)
  %185 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags225 = getelementptr inbounds %struct.sv, %struct.sv* %185, i32 0, i32 2
  %186 = load i32, i32* %sv_flags225, align 4
  %and226 = and i32 %186, 16384
  %tobool227 = icmp ne i32 %and226, 0
  br i1 %tobool227, label %if.then.228, label %if.end.230

if.then.228:                                      ; preds = %if.end.223
  %187 = load %struct.sv*, %struct.sv** %targ, align 8
  %call229 = call i32 @Perl_mg_set(%struct.sv* %187)
  br label %if.end.230

if.end.230:                                       ; preds = %if.then.228, %if.end.223
  %188 = load %struct.sv*, %struct.sv** %targ, align 8
  %189 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr232 = getelementptr inbounds %struct.sv*, %struct.sv** %189, i32 1
  store %struct.sv** %incdec.ptr232, %struct.sv*** %sp, align 8
  store %struct.sv* %188, %struct.sv** %incdec.ptr232, align 8
  store %struct.sv* %188, %struct.sv** %tmp231
  %190 = load %struct.sv*, %struct.sv** %tmp231
  %191 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %191, %struct.sv*** @PL_stack_sp, align 8
  %192 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next233 = getelementptr inbounds %struct.op, %struct.op* %192, i32 0, i32 0
  %193 = load %struct.op*, %struct.op** %op_next233, align 8
  store %struct.op* %193, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.230, %if.then.221, %if.end.188, %if.end.163, %if.then.122, %if.end.29
  %194 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %194
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_modulo() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %right = alloca %struct.sv*, align 8
  %left = alloca %struct.sv*, align 8
  %tmp = alloca %struct.sv*, align 8
  %left33 = alloca i64, align 8
  %right35 = alloca i64, align 8
  %left_neg = alloca i8, align 1
  %right_neg = alloca i8, align 1
  %use_double = alloca i8, align 1
  %dright_valid = alloca i8, align 1
  %dright = alloca double, align 8
  %dleft = alloca double, align 8
  %biv = alloca i64, align 8
  %aiv = alloca i64, align 8
  %dans = alloca double, align 8
  %ans = alloca i64, align 8
  %tmp261 = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 6
  %2 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 64
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load %struct.sv**, %struct.sv*** %sp, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 -1
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %5 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %5, i32 0, i32 3
  %6 = load i64, i64* %op_targ, align 8
  %7 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx1 = getelementptr inbounds %struct.sv*, %struct.sv** %7, i64 %6
  %8 = load %struct.sv*, %struct.sv** %arrayidx1, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.sv* [ %4, %cond.true ], [ %8, %cond.false ]
  store %struct.sv* %cond, %struct.sv** %targ, align 8
  %9 = load i64, i64* @PL_amagic_generation, align 8
  %tobool2 = icmp ne i64 %9, 0
  br i1 %tobool2, label %if.then, label %if.end.31

if.then:                                          ; preds = %cond.end
  %10 = load %struct.sv**, %struct.sv*** %sp, align 8
  %11 = load %struct.sv*, %struct.sv** %10, align 8
  store %struct.sv* %11, %struct.sv** %right, align 8
  %12 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %12, i64 -1
  %13 = load %struct.sv*, %struct.sv** %add.ptr, align 8
  store %struct.sv* %13, %struct.sv** %left, align 8
  %14 = load %struct.sv*, %struct.sv** %left, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %14, i32 0, i32 2
  %15 = load i32, i32* %sv_flags, align 4
  %and3 = and i32 %15, 268435456
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %16 = load %struct.sv*, %struct.sv** %right, align 8
  %sv_flags5 = getelementptr inbounds %struct.sv, %struct.sv* %16, i32 0, i32 2
  %17 = load i32, i32* %sv_flags5, align 4
  %and6 = and i32 %17, 268435456
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %land.lhs.true, label %if.end.30

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %18 = load %struct.sv*, %struct.sv** %left, align 8
  %19 = load %struct.sv*, %struct.sv** %right, align 8
  %20 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags8 = getelementptr inbounds %struct.op, %struct.op* %20, i32 0, i32 6
  %21 = load i8, i8* %op_flags8, align 1
  %conv9 = zext i8 %21 to i32
  %and10 = and i32 %conv9, 64
  %tobool11 = icmp ne i32 %and10, 0
  %cond12 = select i1 %tobool11, i32 4, i32 0
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %18, %struct.sv* %19, i32 14, i32 %cond12)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool13 = icmp ne %struct.sv* %call, null
  br i1 %tobool13, label %if.then.14, label %if.end.30

if.then.14:                                       ; preds = %land.lhs.true
  %22 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %22, %struct.sv*** %sp, align 8
  %23 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %23, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %24 = load %struct.sv*, %struct.sv** %23, align 8
  %25 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags15 = getelementptr inbounds %struct.op, %struct.op* %25, i32 0, i32 6
  %26 = load i8, i8* %op_flags15, align 1
  %conv16 = zext i8 %26 to i32
  %and17 = and i32 %conv16, 64
  %tobool18 = icmp ne i32 %and17, 0
  br i1 %tobool18, label %if.then.23, label %lor.lhs.false.19

lor.lhs.false.19:                                 ; preds = %if.then.14
  %27 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags20 = getelementptr inbounds %struct.sv, %struct.sv* %27, i32 0, i32 2
  %28 = load i32, i32* %sv_flags20, align 4
  %and21 = and i32 %28, 1024
  %tobool22 = icmp ne i32 %and21, 0
  br i1 %tobool22, label %if.then.23, label %if.else

if.then.23:                                       ; preds = %lor.lhs.false.19, %if.then.14
  %29 = load %struct.sv*, %struct.sv** %targ, align 8
  %30 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  call void @Perl_sv_setsv_flags(%struct.sv* %29, %struct.sv* %30, i32 2)
  %31 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags24 = getelementptr inbounds %struct.sv, %struct.sv* %31, i32 0, i32 2
  %32 = load i32, i32* %sv_flags24, align 4
  %and25 = and i32 %32, 16384
  %tobool26 = icmp ne i32 %and25, 0
  br i1 %tobool26, label %if.then.27, label %if.end

if.then.27:                                       ; preds = %if.then.23
  %33 = load %struct.sv*, %struct.sv** %targ, align 8
  %call28 = call i32 @Perl_mg_set(%struct.sv* %33)
  br label %if.end

if.end:                                           ; preds = %if.then.27, %if.then.23
  %34 = load %struct.sv*, %struct.sv** %targ, align 8
  %35 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %34, %struct.sv** %35, align 8
  store %struct.sv* %34, %struct.sv** %tmp
  %36 = load %struct.sv*, %struct.sv** %tmp
  br label %if.end.29

if.else:                                          ; preds = %lor.lhs.false.19
  %37 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %38 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %37, %struct.sv** %38, align 8
  br label %if.end.29

if.end.29:                                        ; preds = %if.else, %if.end
  %39 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %39, %struct.sv*** @PL_stack_sp, align 8
  %40 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %40, i32 0, i32 0
  %41 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %41, %struct.op** %retval
  br label %return

if.end.30:                                        ; preds = %land.lhs.true, %lor.lhs.false
  br label %if.end.31

if.end.31:                                        ; preds = %if.end.30, %cond.end
  store i64 0, i64* %left33, align 8
  store i64 0, i64* %right35, align 8
  store i8 0, i8* %left_neg, align 1
  store i8 0, i8* %right_neg, align 1
  store i8 0, i8* %use_double, align 1
  store i8 0, i8* %dright_valid, align 1
  store double 0.000000e+00, double* %dright, align 8
  store double 0.000000e+00, double* %dleft, align 8
  %42 = load %struct.sv**, %struct.sv*** %sp, align 8
  %43 = load %struct.sv*, %struct.sv** %42, align 8
  %sv_flags42 = getelementptr inbounds %struct.sv, %struct.sv* %43, i32 0, i32 2
  %44 = load i32, i32* %sv_flags42, align 4
  %and43 = and i32 %44, 16777216
  %tobool44 = icmp ne i32 %and43, 0
  br i1 %tobool44, label %if.end.62, label %land.lhs.true.45

land.lhs.true.45:                                 ; preds = %if.end.31
  %45 = load %struct.sv**, %struct.sv*** %sp, align 8
  %46 = load %struct.sv*, %struct.sv** %45, align 8
  %sv_flags46 = getelementptr inbounds %struct.sv, %struct.sv* %46, i32 0, i32 2
  %47 = load i32, i32* %sv_flags46, align 4
  %and47 = and i32 %47, 131072
  %tobool48 = icmp ne i32 %and47, 0
  br i1 %tobool48, label %if.then.53, label %lor.lhs.false.49

lor.lhs.false.49:                                 ; preds = %land.lhs.true.45
  %48 = load %struct.sv**, %struct.sv*** %sp, align 8
  %49 = load %struct.sv*, %struct.sv** %48, align 8
  %sv_flags50 = getelementptr inbounds %struct.sv, %struct.sv* %49, i32 0, i32 2
  %50 = load i32, i32* %sv_flags50, align 4
  %and51 = and i32 %50, 262144
  %tobool52 = icmp ne i32 %and51, 0
  br i1 %tobool52, label %if.then.53, label %if.end.62

if.then.53:                                       ; preds = %lor.lhs.false.49, %land.lhs.true.45
  %51 = load %struct.sv**, %struct.sv*** %sp, align 8
  %52 = load %struct.sv*, %struct.sv** %51, align 8
  %sv_flags54 = getelementptr inbounds %struct.sv, %struct.sv* %52, i32 0, i32 2
  %53 = load i32, i32* %sv_flags54, align 4
  %and55 = and i32 %53, 65536
  %tobool56 = icmp ne i32 %and55, 0
  br i1 %tobool56, label %cond.true.57, label %cond.false.58

cond.true.57:                                     ; preds = %if.then.53
  %54 = load %struct.sv**, %struct.sv*** %sp, align 8
  %55 = load %struct.sv*, %struct.sv** %54, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %55, i32 0, i32 0
  %56 = load i8*, i8** %sv_any, align 8
  %57 = bitcast i8* %56 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %57, i32 0, i32 3
  %58 = load i64, i64* %xiv_iv, align 8
  br label %cond.end.60

cond.false.58:                                    ; preds = %if.then.53
  %59 = load %struct.sv**, %struct.sv*** %sp, align 8
  %60 = load %struct.sv*, %struct.sv** %59, align 8
  %call59 = call i64 @Perl_sv_2iv(%struct.sv* %60)
  br label %cond.end.60

cond.end.60:                                      ; preds = %cond.false.58, %cond.true.57
  %cond61 = phi i64 [ %58, %cond.true.57 ], [ %call59, %cond.false.58 ]
  br label %if.end.62

if.end.62:                                        ; preds = %cond.end.60, %lor.lhs.false.49, %if.end.31
  %61 = load %struct.sv**, %struct.sv*** %sp, align 8
  %62 = load %struct.sv*, %struct.sv** %61, align 8
  %sv_flags63 = getelementptr inbounds %struct.sv, %struct.sv* %62, i32 0, i32 2
  %63 = load i32, i32* %sv_flags63, align 4
  %and64 = and i32 %63, 65536
  %tobool65 = icmp ne i32 %and64, 0
  br i1 %tobool65, label %if.then.66, label %if.else.86

if.then.66:                                       ; preds = %if.end.62
  %64 = load %struct.sv**, %struct.sv*** %sp, align 8
  %65 = load %struct.sv*, %struct.sv** %64, align 8
  %sv_flags67 = getelementptr inbounds %struct.sv, %struct.sv* %65, i32 0, i32 2
  %66 = load i32, i32* %sv_flags67, align 4
  %and68 = and i32 %66, -2147418112
  %cmp = icmp eq i32 %and68, -2147418112
  %lnot = xor i1 %cmp, true
  %lnot.ext = zext i1 %lnot to i32
  %conv70 = trunc i32 %lnot.ext to i8
  store i8 %conv70, i8* %right_neg, align 1
  %67 = load i8, i8* %right_neg, align 1
  %tobool71 = icmp ne i8 %67, 0
  br i1 %tobool71, label %if.else.75, label %if.then.72

if.then.72:                                       ; preds = %if.then.66
  %68 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr73 = getelementptr inbounds %struct.sv*, %struct.sv** %68, i32 -1
  store %struct.sv** %incdec.ptr73, %struct.sv*** %sp, align 8
  %69 = load %struct.sv*, %struct.sv** %68, align 8
  %sv_any74 = getelementptr inbounds %struct.sv, %struct.sv* %69, i32 0, i32 0
  %70 = load i8*, i8** %sv_any74, align 8
  %71 = bitcast i8* %70 to %struct.xpvuv*
  %xuv_uv = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %71, i32 0, i32 3
  %72 = load i64, i64* %xuv_uv, align 8
  store i64 %72, i64* %right35, align 8
  br label %if.end.85

if.else.75:                                       ; preds = %if.then.66
  %73 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr77 = getelementptr inbounds %struct.sv*, %struct.sv** %73, i32 -1
  store %struct.sv** %incdec.ptr77, %struct.sv*** %sp, align 8
  %74 = load %struct.sv*, %struct.sv** %73, align 8
  %sv_any78 = getelementptr inbounds %struct.sv, %struct.sv* %74, i32 0, i32 0
  %75 = load i8*, i8** %sv_any78, align 8
  %76 = bitcast i8* %75 to %struct.xpviv*
  %xiv_iv79 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %76, i32 0, i32 3
  %77 = load i64, i64* %xiv_iv79, align 8
  store i64 %77, i64* %biv, align 8
  %78 = load i64, i64* %biv, align 8
  %cmp80 = icmp sge i64 %78, 0
  br i1 %cmp80, label %if.then.82, label %if.else.83

if.then.82:                                       ; preds = %if.else.75
  %79 = load i64, i64* %biv, align 8
  store i64 %79, i64* %right35, align 8
  store i8 0, i8* %right_neg, align 1
  br label %if.end.84

if.else.83:                                       ; preds = %if.else.75
  %80 = load i64, i64* %biv, align 8
  %sub = sub nsw i64 0, %80
  store i64 %sub, i64* %right35, align 8
  br label %if.end.84

if.end.84:                                        ; preds = %if.else.83, %if.then.82
  br label %if.end.85

if.end.85:                                        ; preds = %if.end.84, %if.then.72
  br label %if.end.110

if.else.86:                                       ; preds = %if.end.62
  %81 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr87 = getelementptr inbounds %struct.sv*, %struct.sv** %81, i32 -1
  store %struct.sv** %incdec.ptr87, %struct.sv*** %sp, align 8
  %82 = load %struct.sv*, %struct.sv** %81, align 8
  store %struct.sv* %82, %struct.sv** @PL_Sv, align 8
  %83 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags88 = getelementptr inbounds %struct.sv, %struct.sv* %83, i32 0, i32 2
  %84 = load i32, i32* %sv_flags88, align 4
  %and89 = and i32 %84, 131072
  %tobool90 = icmp ne i32 %and89, 0
  br i1 %tobool90, label %cond.true.91, label %cond.false.93

cond.true.91:                                     ; preds = %if.else.86
  %85 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any92 = getelementptr inbounds %struct.sv, %struct.sv* %85, i32 0, i32 0
  %86 = load i8*, i8** %sv_any92, align 8
  %87 = bitcast i8* %86 to %struct.xpvnv*
  %xnv_nv = getelementptr inbounds %struct.xpvnv, %struct.xpvnv* %87, i32 0, i32 4
  %88 = load double, double* %xnv_nv, align 8
  br label %cond.end.95

cond.false.93:                                    ; preds = %if.else.86
  %89 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call94 = call double @Perl_sv_2nv(%struct.sv* %89)
  br label %cond.end.95

cond.end.95:                                      ; preds = %cond.false.93, %cond.true.91
  %cond96 = phi double [ %88, %cond.true.91 ], [ %call94, %cond.false.93 ]
  store double %cond96, double* %dright, align 8
  %90 = load double, double* %dright, align 8
  %cmp97 = fcmp olt double %90, 0.000000e+00
  %conv98 = zext i1 %cmp97 to i32
  %conv99 = trunc i32 %conv98 to i8
  store i8 %conv99, i8* %right_neg, align 1
  %91 = load i8, i8* %right_neg, align 1
  %tobool100 = icmp ne i8 %91, 0
  br i1 %tobool100, label %if.then.101, label %if.end.103

if.then.101:                                      ; preds = %cond.end.95
  %92 = load double, double* %dright, align 8
  %sub102 = fsub double -0.000000e+00, %92
  store double %sub102, double* %dright, align 8
  br label %if.end.103

if.end.103:                                       ; preds = %if.then.101, %cond.end.95
  %93 = load double, double* %dright, align 8
  %cmp104 = fcmp olt double %93, 0x43F0000000000000
  br i1 %cmp104, label %if.then.106, label %if.else.108

if.then.106:                                      ; preds = %if.end.103
  %94 = load double, double* %dright, align 8
  %call107 = call i64 @Perl_cast_uv(double %94)
  store i64 %call107, i64* %right35, align 8
  store i8 1, i8* %dright_valid, align 1
  br label %if.end.109

if.else.108:                                      ; preds = %if.end.103
  store i8 1, i8* %use_double, align 1
  br label %if.end.109

if.end.109:                                       ; preds = %if.else.108, %if.then.106
  br label %if.end.110

if.end.110:                                       ; preds = %if.end.109, %if.end.85
  %95 = load %struct.sv**, %struct.sv*** %sp, align 8
  %96 = load %struct.sv*, %struct.sv** %95, align 8
  %sv_flags111 = getelementptr inbounds %struct.sv, %struct.sv* %96, i32 0, i32 2
  %97 = load i32, i32* %sv_flags111, align 4
  %and112 = and i32 %97, 16777216
  %tobool113 = icmp ne i32 %and112, 0
  br i1 %tobool113, label %if.end.133, label %land.lhs.true.114

land.lhs.true.114:                                ; preds = %if.end.110
  %98 = load %struct.sv**, %struct.sv*** %sp, align 8
  %99 = load %struct.sv*, %struct.sv** %98, align 8
  %sv_flags115 = getelementptr inbounds %struct.sv, %struct.sv* %99, i32 0, i32 2
  %100 = load i32, i32* %sv_flags115, align 4
  %and116 = and i32 %100, 131072
  %tobool117 = icmp ne i32 %and116, 0
  br i1 %tobool117, label %if.then.122, label %lor.lhs.false.118

lor.lhs.false.118:                                ; preds = %land.lhs.true.114
  %101 = load %struct.sv**, %struct.sv*** %sp, align 8
  %102 = load %struct.sv*, %struct.sv** %101, align 8
  %sv_flags119 = getelementptr inbounds %struct.sv, %struct.sv* %102, i32 0, i32 2
  %103 = load i32, i32* %sv_flags119, align 4
  %and120 = and i32 %103, 262144
  %tobool121 = icmp ne i32 %and120, 0
  br i1 %tobool121, label %if.then.122, label %if.end.133

if.then.122:                                      ; preds = %lor.lhs.false.118, %land.lhs.true.114
  %104 = load %struct.sv**, %struct.sv*** %sp, align 8
  %105 = load %struct.sv*, %struct.sv** %104, align 8
  %sv_flags123 = getelementptr inbounds %struct.sv, %struct.sv* %105, i32 0, i32 2
  %106 = load i32, i32* %sv_flags123, align 4
  %and124 = and i32 %106, 65536
  %tobool125 = icmp ne i32 %and124, 0
  br i1 %tobool125, label %cond.true.126, label %cond.false.129

cond.true.126:                                    ; preds = %if.then.122
  %107 = load %struct.sv**, %struct.sv*** %sp, align 8
  %108 = load %struct.sv*, %struct.sv** %107, align 8
  %sv_any127 = getelementptr inbounds %struct.sv, %struct.sv* %108, i32 0, i32 0
  %109 = load i8*, i8** %sv_any127, align 8
  %110 = bitcast i8* %109 to %struct.xpviv*
  %xiv_iv128 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %110, i32 0, i32 3
  %111 = load i64, i64* %xiv_iv128, align 8
  br label %cond.end.131

cond.false.129:                                   ; preds = %if.then.122
  %112 = load %struct.sv**, %struct.sv*** %sp, align 8
  %113 = load %struct.sv*, %struct.sv** %112, align 8
  %call130 = call i64 @Perl_sv_2iv(%struct.sv* %113)
  br label %cond.end.131

cond.end.131:                                     ; preds = %cond.false.129, %cond.true.126
  %cond132 = phi i64 [ %111, %cond.true.126 ], [ %call130, %cond.false.129 ]
  br label %if.end.133

if.end.133:                                       ; preds = %cond.end.131, %lor.lhs.false.118, %if.end.110
  %114 = load i8, i8* %use_double, align 1
  %tobool134 = icmp ne i8 %114, 0
  br i1 %tobool134, label %if.else.169, label %land.lhs.true.135

land.lhs.true.135:                                ; preds = %if.end.133
  %115 = load %struct.sv**, %struct.sv*** %sp, align 8
  %116 = load %struct.sv*, %struct.sv** %115, align 8
  %sv_flags136 = getelementptr inbounds %struct.sv, %struct.sv* %116, i32 0, i32 2
  %117 = load i32, i32* %sv_flags136, align 4
  %and137 = and i32 %117, 65536
  %tobool138 = icmp ne i32 %and137, 0
  br i1 %tobool138, label %if.then.139, label %if.else.169

if.then.139:                                      ; preds = %land.lhs.true.135
  %118 = load %struct.sv**, %struct.sv*** %sp, align 8
  %119 = load %struct.sv*, %struct.sv** %118, align 8
  %sv_flags140 = getelementptr inbounds %struct.sv, %struct.sv* %119, i32 0, i32 2
  %120 = load i32, i32* %sv_flags140, align 4
  %and141 = and i32 %120, 65536
  %tobool142 = icmp ne i32 %and141, 0
  br i1 %tobool142, label %if.then.143, label %if.end.168

if.then.143:                                      ; preds = %if.then.139
  %121 = load %struct.sv**, %struct.sv*** %sp, align 8
  %122 = load %struct.sv*, %struct.sv** %121, align 8
  %sv_flags144 = getelementptr inbounds %struct.sv, %struct.sv* %122, i32 0, i32 2
  %123 = load i32, i32* %sv_flags144, align 4
  %and145 = and i32 %123, -2147418112
  %cmp146 = icmp eq i32 %and145, -2147418112
  %lnot148 = xor i1 %cmp146, true
  %lnot.ext149 = zext i1 %lnot148 to i32
  %conv150 = trunc i32 %lnot.ext149 to i8
  store i8 %conv150, i8* %left_neg, align 1
  %124 = load i8, i8* %left_neg, align 1
  %tobool151 = icmp ne i8 %124, 0
  br i1 %tobool151, label %if.else.156, label %if.then.152

if.then.152:                                      ; preds = %if.then.143
  %125 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr153 = getelementptr inbounds %struct.sv*, %struct.sv** %125, i32 -1
  store %struct.sv** %incdec.ptr153, %struct.sv*** %sp, align 8
  %126 = load %struct.sv*, %struct.sv** %125, align 8
  %sv_any154 = getelementptr inbounds %struct.sv, %struct.sv* %126, i32 0, i32 0
  %127 = load i8*, i8** %sv_any154, align 8
  %128 = bitcast i8* %127 to %struct.xpvuv*
  %xuv_uv155 = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %128, i32 0, i32 3
  %129 = load i64, i64* %xuv_uv155, align 8
  store i64 %129, i64* %left33, align 8
  br label %if.end.167

if.else.156:                                      ; preds = %if.then.143
  %130 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr158 = getelementptr inbounds %struct.sv*, %struct.sv** %130, i32 -1
  store %struct.sv** %incdec.ptr158, %struct.sv*** %sp, align 8
  %131 = load %struct.sv*, %struct.sv** %130, align 8
  %sv_any159 = getelementptr inbounds %struct.sv, %struct.sv* %131, i32 0, i32 0
  %132 = load i8*, i8** %sv_any159, align 8
  %133 = bitcast i8* %132 to %struct.xpviv*
  %xiv_iv160 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %133, i32 0, i32 3
  %134 = load i64, i64* %xiv_iv160, align 8
  store i64 %134, i64* %aiv, align 8
  %135 = load i64, i64* %aiv, align 8
  %cmp161 = icmp sge i64 %135, 0
  br i1 %cmp161, label %if.then.163, label %if.else.164

if.then.163:                                      ; preds = %if.else.156
  %136 = load i64, i64* %aiv, align 8
  store i64 %136, i64* %left33, align 8
  store i8 0, i8* %left_neg, align 1
  br label %if.end.166

if.else.164:                                      ; preds = %if.else.156
  %137 = load i64, i64* %aiv, align 8
  %sub165 = sub nsw i64 0, %137
  store i64 %sub165, i64* %left33, align 8
  br label %if.end.166

if.end.166:                                       ; preds = %if.else.164, %if.then.163
  br label %if.end.167

if.end.167:                                       ; preds = %if.end.166, %if.then.152
  br label %if.end.168

if.end.168:                                       ; preds = %if.end.167, %if.then.139
  br label %if.end.205

if.else.169:                                      ; preds = %land.lhs.true.135, %if.end.133
  %138 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr170 = getelementptr inbounds %struct.sv*, %struct.sv** %138, i32 -1
  store %struct.sv** %incdec.ptr170, %struct.sv*** %sp, align 8
  %139 = load %struct.sv*, %struct.sv** %138, align 8
  store %struct.sv* %139, %struct.sv** @PL_Sv, align 8
  %140 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags171 = getelementptr inbounds %struct.sv, %struct.sv* %140, i32 0, i32 2
  %141 = load i32, i32* %sv_flags171, align 4
  %and172 = and i32 %141, 131072
  %tobool173 = icmp ne i32 %and172, 0
  br i1 %tobool173, label %cond.true.174, label %cond.false.177

cond.true.174:                                    ; preds = %if.else.169
  %142 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any175 = getelementptr inbounds %struct.sv, %struct.sv* %142, i32 0, i32 0
  %143 = load i8*, i8** %sv_any175, align 8
  %144 = bitcast i8* %143 to %struct.xpvnv*
  %xnv_nv176 = getelementptr inbounds %struct.xpvnv, %struct.xpvnv* %144, i32 0, i32 4
  %145 = load double, double* %xnv_nv176, align 8
  br label %cond.end.179

cond.false.177:                                   ; preds = %if.else.169
  %146 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call178 = call double @Perl_sv_2nv(%struct.sv* %146)
  br label %cond.end.179

cond.end.179:                                     ; preds = %cond.false.177, %cond.true.174
  %cond180 = phi double [ %145, %cond.true.174 ], [ %call178, %cond.false.177 ]
  store double %cond180, double* %dleft, align 8
  %147 = load double, double* %dleft, align 8
  %cmp181 = fcmp olt double %147, 0.000000e+00
  %conv182 = zext i1 %cmp181 to i32
  %conv183 = trunc i32 %conv182 to i8
  store i8 %conv183, i8* %left_neg, align 1
  %148 = load i8, i8* %left_neg, align 1
  %tobool184 = icmp ne i8 %148, 0
  br i1 %tobool184, label %if.then.185, label %if.end.187

if.then.185:                                      ; preds = %cond.end.179
  %149 = load double, double* %dleft, align 8
  %sub186 = fsub double -0.000000e+00, %149
  store double %sub186, double* %dleft, align 8
  br label %if.end.187

if.end.187:                                       ; preds = %if.then.185, %cond.end.179
  %150 = load i8, i8* %use_double, align 1
  %tobool188 = icmp ne i8 %150, 0
  br i1 %tobool188, label %if.end.204, label %if.then.189

if.then.189:                                      ; preds = %if.end.187
  %151 = load double, double* %dleft, align 8
  %cmp190 = fcmp olt double %151, 0x43F0000000000000
  br i1 %cmp190, label %if.then.192, label %if.else.194

if.then.192:                                      ; preds = %if.then.189
  %152 = load double, double* %dleft, align 8
  %call193 = call i64 @Perl_cast_uv(double %152)
  store i64 %call193, i64* %left33, align 8
  br label %if.end.203

if.else.194:                                      ; preds = %if.then.189
  %153 = load double, double* %dleft, align 8
  %add = fadd double %153, 5.000000e-01
  %call195 = call double @floor(double %add) #5
  store double %call195, double* %dleft, align 8
  store i8 1, i8* %use_double, align 1
  %154 = load i8, i8* %dright_valid, align 1
  %tobool196 = icmp ne i8 %154, 0
  br i1 %tobool196, label %if.then.197, label %if.else.200

if.then.197:                                      ; preds = %if.else.194
  %155 = load double, double* %dright, align 8
  %add198 = fadd double %155, 5.000000e-01
  %call199 = call double @floor(double %add198) #5
  store double %call199, double* %dright, align 8
  br label %if.end.202

if.else.200:                                      ; preds = %if.else.194
  %156 = load i64, i64* %right35, align 8
  %conv201 = uitofp i64 %156 to double
  store double %conv201, double* %dright, align 8
  br label %if.end.202

if.end.202:                                       ; preds = %if.else.200, %if.then.197
  br label %if.end.203

if.end.203:                                       ; preds = %if.end.202, %if.then.192
  br label %if.end.204

if.end.204:                                       ; preds = %if.end.203, %if.end.187
  br label %if.end.205

if.end.205:                                       ; preds = %if.end.204, %if.end.168
  %157 = load i8, i8* %use_double, align 1
  %tobool206 = icmp ne i8 %157, 0
  br i1 %tobool206, label %if.then.207, label %if.else.227

if.then.207:                                      ; preds = %if.end.205
  %158 = load double, double* %dright, align 8
  %tobool209 = fcmp une double %158, 0.000000e+00
  br i1 %tobool209, label %if.end.212, label %if.then.210

if.then.210:                                      ; preds = %if.then.207
  %call211 = call %struct.op* (i8*, ...) @Perl_die(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.30, i32 0, i32 0))
  store %struct.op* %call211, %struct.op** %retval
  br label %return

if.end.212:                                       ; preds = %if.then.207
  %159 = load double, double* %dleft, align 8
  %160 = load double, double* %dright, align 8
  %call213 = call double @fmod(double %159, double %160) #2
  store double %call213, double* %dans, align 8
  %161 = load i8, i8* %left_neg, align 1
  %conv214 = sext i8 %161 to i32
  %162 = load i8, i8* %right_neg, align 1
  %conv215 = sext i8 %162 to i32
  %cmp216 = icmp ne i32 %conv214, %conv215
  br i1 %cmp216, label %land.lhs.true.218, label %if.end.222

land.lhs.true.218:                                ; preds = %if.end.212
  %163 = load double, double* %dans, align 8
  %tobool219 = fcmp une double %163, 0.000000e+00
  br i1 %tobool219, label %if.then.220, label %if.end.222

if.then.220:                                      ; preds = %land.lhs.true.218
  %164 = load double, double* %dright, align 8
  %165 = load double, double* %dans, align 8
  %sub221 = fsub double %164, %165
  store double %sub221, double* %dans, align 8
  br label %if.end.222

if.end.222:                                       ; preds = %if.then.220, %land.lhs.true.218, %if.end.212
  %166 = load i8, i8* %right_neg, align 1
  %tobool223 = icmp ne i8 %166, 0
  br i1 %tobool223, label %if.then.224, label %if.end.226

if.then.224:                                      ; preds = %if.end.222
  %167 = load double, double* %dans, align 8
  %sub225 = fsub double -0.000000e+00, %167
  store double %sub225, double* %dans, align 8
  br label %if.end.226

if.end.226:                                       ; preds = %if.then.224, %if.end.222
  %168 = load %struct.sv*, %struct.sv** %targ, align 8
  %169 = load double, double* %dans, align 8
  call void @Perl_sv_setnv(%struct.sv* %168, double %169)
  br label %if.end.254

if.else.227:                                      ; preds = %if.end.205
  %170 = load i64, i64* %right35, align 8
  %tobool229 = icmp ne i64 %170, 0
  br i1 %tobool229, label %if.end.232, label %if.then.230

if.then.230:                                      ; preds = %if.else.227
  %call231 = call %struct.op* (i8*, ...) @Perl_die(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.30, i32 0, i32 0))
  store %struct.op* %call231, %struct.op** %retval
  br label %return

if.end.232:                                       ; preds = %if.else.227
  %171 = load i64, i64* %left33, align 8
  %172 = load i64, i64* %right35, align 8
  %rem = urem i64 %171, %172
  store i64 %rem, i64* %ans, align 8
  %173 = load i8, i8* %left_neg, align 1
  %conv233 = sext i8 %173 to i32
  %174 = load i8, i8* %right_neg, align 1
  %conv234 = sext i8 %174 to i32
  %cmp235 = icmp ne i32 %conv233, %conv234
  br i1 %cmp235, label %land.lhs.true.237, label %if.end.241

land.lhs.true.237:                                ; preds = %if.end.232
  %175 = load i64, i64* %ans, align 8
  %tobool238 = icmp ne i64 %175, 0
  br i1 %tobool238, label %if.then.239, label %if.end.241

if.then.239:                                      ; preds = %land.lhs.true.237
  %176 = load i64, i64* %right35, align 8
  %177 = load i64, i64* %ans, align 8
  %sub240 = sub i64 %176, %177
  store i64 %sub240, i64* %ans, align 8
  br label %if.end.241

if.end.241:                                       ; preds = %if.then.239, %land.lhs.true.237, %if.end.232
  %178 = load i8, i8* %right_neg, align 1
  %tobool242 = icmp ne i8 %178, 0
  br i1 %tobool242, label %if.then.243, label %if.else.252

if.then.243:                                      ; preds = %if.end.241
  %179 = load i64, i64* %ans, align 8
  %cmp244 = icmp ule i64 %179, -9223372036854775807
  br i1 %cmp244, label %if.then.246, label %if.else.248

if.then.246:                                      ; preds = %if.then.243
  %180 = load %struct.sv*, %struct.sv** %targ, align 8
  %181 = load i64, i64* %ans, align 8
  %neg = xor i64 %181, -1
  %add247 = add i64 %neg, 1
  call void @Perl_sv_setiv(%struct.sv* %180, i64 %add247)
  br label %if.end.251

if.else.248:                                      ; preds = %if.then.243
  %182 = load %struct.sv*, %struct.sv** %targ, align 8
  %183 = load i64, i64* %ans, align 8
  %conv249 = uitofp i64 %183 to double
  %sub250 = fsub double -0.000000e+00, %conv249
  call void @Perl_sv_setnv(%struct.sv* %182, double %sub250)
  br label %if.end.251

if.end.251:                                       ; preds = %if.else.248, %if.then.246
  br label %if.end.253

if.else.252:                                      ; preds = %if.end.241
  %184 = load %struct.sv*, %struct.sv** %targ, align 8
  %185 = load i64, i64* %ans, align 8
  call void @Perl_sv_setuv(%struct.sv* %184, i64 %185)
  br label %if.end.253

if.end.253:                                       ; preds = %if.else.252, %if.end.251
  br label %if.end.254

if.end.254:                                       ; preds = %if.end.253, %if.end.226
  %186 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags255 = getelementptr inbounds %struct.sv, %struct.sv* %186, i32 0, i32 2
  %187 = load i32, i32* %sv_flags255, align 4
  %and256 = and i32 %187, 16384
  %tobool257 = icmp ne i32 %and256, 0
  br i1 %tobool257, label %if.then.258, label %if.end.260

if.then.258:                                      ; preds = %if.end.254
  %188 = load %struct.sv*, %struct.sv** %targ, align 8
  %call259 = call i32 @Perl_mg_set(%struct.sv* %188)
  br label %if.end.260

if.end.260:                                       ; preds = %if.then.258, %if.end.254
  %189 = load %struct.sv*, %struct.sv** %targ, align 8
  %190 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr262 = getelementptr inbounds %struct.sv*, %struct.sv** %190, i32 1
  store %struct.sv** %incdec.ptr262, %struct.sv*** %sp, align 8
  store %struct.sv* %189, %struct.sv** %incdec.ptr262, align 8
  store %struct.sv* %189, %struct.sv** %tmp261
  %191 = load %struct.sv*, %struct.sv** %tmp261
  %192 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %192, %struct.sv*** @PL_stack_sp, align 8
  %193 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next263 = getelementptr inbounds %struct.op, %struct.op* %193, i32 0, i32 0
  %194 = load %struct.op*, %struct.op** %op_next263, align 8
  store %struct.op* %194, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.260, %if.then.230, %if.then.210, %if.end.29
  %195 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %195
}

declare i64 @Perl_cast_uv(double) #1

; Function Attrs: nounwind readnone
declare double @floor(double) #4

; Function Attrs: nounwind
declare double @fmod(double, double) #3

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_repeat() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %right = alloca %struct.sv*, align 8
  %left = alloca %struct.sv*, align 8
  %tmp = alloca %struct.sv*, align 8
  %count = alloca i64, align 8
  %sv = alloca %struct.sv*, align 8
  %uv = alloca i64, align 8
  %iv = alloca i64, align 8
  %nv = alloca double, align 8
  %mark = alloca %struct.sv**, align 8
  %items = alloca i32, align 4
  %max = alloca i32, align 4
  %markoff = alloca i32, align 4
  %tmpstr = alloca %struct.sv*, align 8
  %len = alloca i64, align 8
  %isutf = alloca i8, align 1
  %tmp238 = alloca i64, align 8
  %max243 = alloca i64, align 8
  %mark295 = alloca %struct.sv**, align 8
  %tmp306 = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 6
  %2 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 64
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load %struct.sv**, %struct.sv*** %sp, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 -1
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %5 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %5, i32 0, i32 3
  %6 = load i64, i64* %op_targ, align 8
  %7 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx1 = getelementptr inbounds %struct.sv*, %struct.sv** %7, i64 %6
  %8 = load %struct.sv*, %struct.sv** %arrayidx1, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.sv* [ %4, %cond.true ], [ %8, %cond.false ]
  store %struct.sv* %cond, %struct.sv** %targ, align 8
  %9 = load i64, i64* @PL_amagic_generation, align 8
  %tobool2 = icmp ne i64 %9, 0
  br i1 %tobool2, label %if.then, label %if.end.31

if.then:                                          ; preds = %cond.end
  %10 = load %struct.sv**, %struct.sv*** %sp, align 8
  %11 = load %struct.sv*, %struct.sv** %10, align 8
  store %struct.sv* %11, %struct.sv** %right, align 8
  %12 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %12, i64 -1
  %13 = load %struct.sv*, %struct.sv** %add.ptr, align 8
  store %struct.sv* %13, %struct.sv** %left, align 8
  %14 = load %struct.sv*, %struct.sv** %left, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %14, i32 0, i32 2
  %15 = load i32, i32* %sv_flags, align 4
  %and3 = and i32 %15, 268435456
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %16 = load %struct.sv*, %struct.sv** %right, align 8
  %sv_flags5 = getelementptr inbounds %struct.sv, %struct.sv* %16, i32 0, i32 2
  %17 = load i32, i32* %sv_flags5, align 4
  %and6 = and i32 %17, 268435456
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %land.lhs.true, label %if.end.30

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %18 = load %struct.sv*, %struct.sv** %left, align 8
  %19 = load %struct.sv*, %struct.sv** %right, align 8
  %20 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags8 = getelementptr inbounds %struct.op, %struct.op* %20, i32 0, i32 6
  %21 = load i8, i8* %op_flags8, align 1
  %conv9 = zext i8 %21 to i32
  %and10 = and i32 %conv9, 64
  %tobool11 = icmp ne i32 %and10, 0
  %cond12 = select i1 %tobool11, i32 4, i32 0
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %18, %struct.sv* %19, i32 52, i32 %cond12)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool13 = icmp ne %struct.sv* %call, null
  br i1 %tobool13, label %if.then.14, label %if.end.30

if.then.14:                                       ; preds = %land.lhs.true
  %22 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %22, %struct.sv*** %sp, align 8
  %23 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %23, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %24 = load %struct.sv*, %struct.sv** %23, align 8
  %25 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags15 = getelementptr inbounds %struct.op, %struct.op* %25, i32 0, i32 6
  %26 = load i8, i8* %op_flags15, align 1
  %conv16 = zext i8 %26 to i32
  %and17 = and i32 %conv16, 64
  %tobool18 = icmp ne i32 %and17, 0
  br i1 %tobool18, label %if.then.23, label %lor.lhs.false.19

lor.lhs.false.19:                                 ; preds = %if.then.14
  %27 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags20 = getelementptr inbounds %struct.sv, %struct.sv* %27, i32 0, i32 2
  %28 = load i32, i32* %sv_flags20, align 4
  %and21 = and i32 %28, 1024
  %tobool22 = icmp ne i32 %and21, 0
  br i1 %tobool22, label %if.then.23, label %if.else

if.then.23:                                       ; preds = %lor.lhs.false.19, %if.then.14
  %29 = load %struct.sv*, %struct.sv** %targ, align 8
  %30 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  call void @Perl_sv_setsv_flags(%struct.sv* %29, %struct.sv* %30, i32 2)
  %31 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags24 = getelementptr inbounds %struct.sv, %struct.sv* %31, i32 0, i32 2
  %32 = load i32, i32* %sv_flags24, align 4
  %and25 = and i32 %32, 16384
  %tobool26 = icmp ne i32 %and25, 0
  br i1 %tobool26, label %if.then.27, label %if.end

if.then.27:                                       ; preds = %if.then.23
  %33 = load %struct.sv*, %struct.sv** %targ, align 8
  %call28 = call i32 @Perl_mg_set(%struct.sv* %33)
  br label %if.end

if.end:                                           ; preds = %if.then.27, %if.then.23
  %34 = load %struct.sv*, %struct.sv** %targ, align 8
  %35 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %34, %struct.sv** %35, align 8
  store %struct.sv* %34, %struct.sv** %tmp
  %36 = load %struct.sv*, %struct.sv** %tmp
  br label %if.end.29

if.else:                                          ; preds = %lor.lhs.false.19
  %37 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %38 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %37, %struct.sv** %38, align 8
  br label %if.end.29

if.end.29:                                        ; preds = %if.else, %if.end
  %39 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %39, %struct.sv*** @PL_stack_sp, align 8
  %40 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %40, i32 0, i32 0
  %41 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %41, %struct.op** %retval
  br label %return

if.end.30:                                        ; preds = %land.lhs.true, %lor.lhs.false
  br label %if.end.31

if.end.31:                                        ; preds = %if.end.30, %cond.end
  %42 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr34 = getelementptr inbounds %struct.sv*, %struct.sv** %42, i32 -1
  store %struct.sv** %incdec.ptr34, %struct.sv*** %sp, align 8
  %43 = load %struct.sv*, %struct.sv** %42, align 8
  store %struct.sv* %43, %struct.sv** %sv, align 8
  %44 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags35 = getelementptr inbounds %struct.sv, %struct.sv* %44, i32 0, i32 2
  %45 = load i32, i32* %sv_flags35, align 4
  %and36 = and i32 %45, 8192
  %tobool37 = icmp ne i32 %and36, 0
  br i1 %tobool37, label %if.then.38, label %if.end.40

if.then.38:                                       ; preds = %if.end.31
  %46 = load %struct.sv*, %struct.sv** %sv, align 8
  %call39 = call i32 @Perl_mg_get(%struct.sv* %46)
  br label %if.end.40

if.end.40:                                        ; preds = %if.then.38, %if.end.31
  %47 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags41 = getelementptr inbounds %struct.sv, %struct.sv* %47, i32 0, i32 2
  %48 = load i32, i32* %sv_flags41, align 4
  %and42 = and i32 %48, 16777216
  %tobool43 = icmp ne i32 %and42, 0
  br i1 %tobool43, label %if.then.44, label %if.else.80

if.then.44:                                       ; preds = %if.end.40
  %49 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags45 = getelementptr inbounds %struct.sv, %struct.sv* %49, i32 0, i32 2
  %50 = load i32, i32* %sv_flags45, align 4
  %and46 = and i32 %50, -2147418112
  %cmp = icmp eq i32 %and46, -2147418112
  br i1 %cmp, label %if.then.48, label %if.else.63

if.then.48:                                       ; preds = %if.then.44
  %51 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags50 = getelementptr inbounds %struct.sv, %struct.sv* %51, i32 0, i32 2
  %52 = load i32, i32* %sv_flags50, align 4
  %and51 = and i32 %52, 65536
  %tobool52 = icmp ne i32 %and51, 0
  br i1 %tobool52, label %cond.true.53, label %cond.false.54

cond.true.53:                                     ; preds = %if.then.48
  %53 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %53, i32 0, i32 0
  %54 = load i8*, i8** %sv_any, align 8
  %55 = bitcast i8* %54 to %struct.xpvuv*
  %xuv_uv = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %55, i32 0, i32 3
  %56 = load i64, i64* %xuv_uv, align 8
  br label %cond.end.56

cond.false.54:                                    ; preds = %if.then.48
  %57 = load %struct.sv*, %struct.sv** %sv, align 8
  %call55 = call i64 @Perl_sv_2uv(%struct.sv* %57)
  br label %cond.end.56

cond.end.56:                                      ; preds = %cond.false.54, %cond.true.53
  %cond57 = phi i64 [ %56, %cond.true.53 ], [ %call55, %cond.false.54 ]
  store i64 %cond57, i64* %uv, align 8
  %58 = load i64, i64* %uv, align 8
  %cmp58 = icmp ugt i64 %58, 9223372036854775807
  br i1 %cmp58, label %if.then.60, label %if.else.61

if.then.60:                                       ; preds = %cond.end.56
  store i64 9223372036854775807, i64* %count, align 8
  br label %if.end.62

if.else.61:                                       ; preds = %cond.end.56
  %59 = load i64, i64* %uv, align 8
  store i64 %59, i64* %count, align 8
  br label %if.end.62

if.end.62:                                        ; preds = %if.else.61, %if.then.60
  br label %if.end.79

if.else.63:                                       ; preds = %if.then.44
  %60 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags65 = getelementptr inbounds %struct.sv, %struct.sv* %60, i32 0, i32 2
  %61 = load i32, i32* %sv_flags65, align 4
  %and66 = and i32 %61, 65536
  %tobool67 = icmp ne i32 %and66, 0
  br i1 %tobool67, label %cond.true.68, label %cond.false.70

cond.true.68:                                     ; preds = %if.else.63
  %62 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any69 = getelementptr inbounds %struct.sv, %struct.sv* %62, i32 0, i32 0
  %63 = load i8*, i8** %sv_any69, align 8
  %64 = bitcast i8* %63 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %64, i32 0, i32 3
  %65 = load i64, i64* %xiv_iv, align 8
  br label %cond.end.72

cond.false.70:                                    ; preds = %if.else.63
  %66 = load %struct.sv*, %struct.sv** %sv, align 8
  %call71 = call i64 @Perl_sv_2iv(%struct.sv* %66)
  br label %cond.end.72

cond.end.72:                                      ; preds = %cond.false.70, %cond.true.68
  %cond73 = phi i64 [ %65, %cond.true.68 ], [ %call71, %cond.false.70 ]
  store i64 %cond73, i64* %iv, align 8
  %67 = load i64, i64* %iv, align 8
  %cmp74 = icmp slt i64 %67, 0
  br i1 %cmp74, label %if.then.76, label %if.else.77

if.then.76:                                       ; preds = %cond.end.72
  store i64 0, i64* %count, align 8
  br label %if.end.78

if.else.77:                                       ; preds = %cond.end.72
  %68 = load i64, i64* %iv, align 8
  store i64 %68, i64* %count, align 8
  br label %if.end.78

if.end.78:                                        ; preds = %if.else.77, %if.then.76
  br label %if.end.79

if.end.79:                                        ; preds = %if.end.78, %if.end.62
  br label %if.end.113

if.else.80:                                       ; preds = %if.end.40
  %69 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags81 = getelementptr inbounds %struct.sv, %struct.sv* %69, i32 0, i32 2
  %70 = load i32, i32* %sv_flags81, align 4
  %and82 = and i32 %70, 33554432
  %tobool83 = icmp ne i32 %and82, 0
  br i1 %tobool83, label %if.then.84, label %if.else.101

if.then.84:                                       ; preds = %if.else.80
  %71 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags86 = getelementptr inbounds %struct.sv, %struct.sv* %71, i32 0, i32 2
  %72 = load i32, i32* %sv_flags86, align 4
  %and87 = and i32 %72, 131072
  %tobool88 = icmp ne i32 %and87, 0
  br i1 %tobool88, label %cond.true.89, label %cond.false.91

cond.true.89:                                     ; preds = %if.then.84
  %73 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any90 = getelementptr inbounds %struct.sv, %struct.sv* %73, i32 0, i32 0
  %74 = load i8*, i8** %sv_any90, align 8
  %75 = bitcast i8* %74 to %struct.xpvnv*
  %xnv_nv = getelementptr inbounds %struct.xpvnv, %struct.xpvnv* %75, i32 0, i32 4
  %76 = load double, double* %xnv_nv, align 8
  br label %cond.end.93

cond.false.91:                                    ; preds = %if.then.84
  %77 = load %struct.sv*, %struct.sv** %sv, align 8
  %call92 = call double @Perl_sv_2nv(%struct.sv* %77)
  br label %cond.end.93

cond.end.93:                                      ; preds = %cond.false.91, %cond.true.89
  %cond94 = phi double [ %76, %cond.true.89 ], [ %call92, %cond.false.91 ]
  store double %cond94, double* %nv, align 8
  %78 = load double, double* %nv, align 8
  %cmp95 = fcmp olt double %78, 0.000000e+00
  br i1 %cmp95, label %if.then.97, label %if.else.98

if.then.97:                                       ; preds = %cond.end.93
  store i64 0, i64* %count, align 8
  br label %if.end.100

if.else.98:                                       ; preds = %cond.end.93
  %79 = load double, double* %nv, align 8
  %conv99 = fptosi double %79 to i64
  store i64 %conv99, i64* %count, align 8
  br label %if.end.100

if.end.100:                                       ; preds = %if.else.98, %if.then.97
  br label %if.end.112

if.else.101:                                      ; preds = %if.else.80
  %80 = load %struct.sv*, %struct.sv** %sv, align 8
  store %struct.sv* %80, %struct.sv** @PL_Sv, align 8
  %81 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags102 = getelementptr inbounds %struct.sv, %struct.sv* %81, i32 0, i32 2
  %82 = load i32, i32* %sv_flags102, align 4
  %and103 = and i32 %82, 65536
  %tobool104 = icmp ne i32 %and103, 0
  br i1 %tobool104, label %cond.true.105, label %cond.false.108

cond.true.105:                                    ; preds = %if.else.101
  %83 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any106 = getelementptr inbounds %struct.sv, %struct.sv* %83, i32 0, i32 0
  %84 = load i8*, i8** %sv_any106, align 8
  %85 = bitcast i8* %84 to %struct.xpviv*
  %xiv_iv107 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %85, i32 0, i32 3
  %86 = load i64, i64* %xiv_iv107, align 8
  br label %cond.end.110

cond.false.108:                                   ; preds = %if.else.101
  %87 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call109 = call i64 @Perl_sv_2iv(%struct.sv* %87)
  br label %cond.end.110

cond.end.110:                                     ; preds = %cond.false.108, %cond.true.105
  %cond111 = phi i64 [ %86, %cond.true.105 ], [ %call109, %cond.false.108 ]
  store i64 %cond111, i64* %count, align 8
  br label %if.end.112

if.end.112:                                       ; preds = %cond.end.110, %if.end.100
  br label %if.end.113

if.end.113:                                       ; preds = %if.end.112, %if.end.79
  %88 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags114 = getelementptr inbounds %struct.op, %struct.op* %88, i32 0, i32 6
  %89 = load i8, i8* %op_flags114, align 1
  %conv115 = zext i8 %89 to i32
  %and116 = and i32 %conv115, 3
  %tobool117 = icmp ne i32 %and116, 0
  br i1 %tobool117, label %cond.true.118, label %cond.false.125

cond.true.118:                                    ; preds = %if.end.113
  %90 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags119 = getelementptr inbounds %struct.op, %struct.op* %90, i32 0, i32 6
  %91 = load i8, i8* %op_flags119, align 1
  %conv120 = zext i8 %91 to i32
  %and121 = and i32 %conv120, 3
  %cmp122 = icmp eq i32 %and121, 3
  %cond124 = select i1 %cmp122, i32 1, i32 0
  br label %cond.end.127

cond.false.125:                                   ; preds = %if.end.113
  %call126 = call i32 @Perl_dowantarray()
  br label %cond.end.127

cond.end.127:                                     ; preds = %cond.false.125, %cond.true.118
  %cond128 = phi i32 [ %cond124, %cond.true.118 ], [ %call126, %cond.false.125 ]
  %cmp129 = icmp eq i32 %cond128, 1
  br i1 %cmp129, label %land.lhs.true.131, label %if.else.204

land.lhs.true.131:                                ; preds = %cond.end.127
  %92 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %92, i32 0, i32 7
  %93 = load i8, i8* %op_private, align 1
  %conv132 = zext i8 %93 to i32
  %and133 = and i32 %conv132, 64
  %tobool134 = icmp ne i32 %and133, 0
  br i1 %tobool134, label %if.then.135, label %if.else.204

if.then.135:                                      ; preds = %land.lhs.true.131
  %94 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %95 = load i32*, i32** @PL_markstack_ptr, align 8
  %incdec.ptr137 = getelementptr inbounds i32, i32* %95, i32 -1
  store i32* %incdec.ptr137, i32** @PL_markstack_ptr, align 8
  %96 = load i32, i32* %95, align 4
  %idx.ext = sext i32 %96 to i64
  %add.ptr138 = getelementptr inbounds %struct.sv*, %struct.sv** %94, i64 %idx.ext
  store %struct.sv** %add.ptr138, %struct.sv*** %mark, align 8
  %97 = load %struct.sv**, %struct.sv*** %sp, align 8
  %98 = load %struct.sv**, %struct.sv*** %mark, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %97 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %98 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %conv140 = trunc i64 %sub.ptr.div to i32
  store i32 %conv140, i32* %items, align 4
  %99 = load i32, i32* %items, align 4
  %conv142 = sext i32 %99 to i64
  %100 = load i64, i64* %count, align 8
  %mul = mul nsw i64 %conv142, %100
  %conv143 = trunc i64 %mul to i32
  store i32 %conv143, i32* %max, align 4
  %101 = load i32, i32* %items, align 4
  %cmp144 = icmp sgt i32 %101, 0
  br i1 %cmp144, label %land.lhs.true.146, label %if.end.157

land.lhs.true.146:                                ; preds = %if.then.135
  %102 = load i32, i32* %max, align 4
  %cmp147 = icmp sgt i32 %102, 0
  br i1 %cmp147, label %land.lhs.true.149, label %if.end.157

land.lhs.true.149:                                ; preds = %land.lhs.true.146
  %103 = load i32, i32* %max, align 4
  %104 = load i32, i32* %items, align 4
  %cmp150 = icmp slt i32 %103, %104
  br i1 %cmp150, label %if.then.156, label %lor.lhs.false.152

lor.lhs.false.152:                                ; preds = %land.lhs.true.149
  %105 = load i32, i32* %max, align 4
  %conv153 = sext i32 %105 to i64
  %106 = load i64, i64* %count, align 8
  %cmp154 = icmp slt i64 %conv153, %106
  br i1 %cmp154, label %if.then.156, label %if.end.157

if.then.156:                                      ; preds = %lor.lhs.false.152, %land.lhs.true.149
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([33 x i8], [33 x i8]* @Perl_pp_repeat.oom_list_extend, i32 0, i32 0))
  br label %if.end.157

if.end.157:                                       ; preds = %if.then.156, %lor.lhs.false.152, %land.lhs.true.146, %if.then.135
  %107 = load %struct.sv**, %struct.sv*** @PL_stack_max, align 8
  %108 = load %struct.sv**, %struct.sv*** %mark, align 8
  %sub.ptr.lhs.cast158 = ptrtoint %struct.sv** %107 to i64
  %sub.ptr.rhs.cast159 = ptrtoint %struct.sv** %108 to i64
  %sub.ptr.sub160 = sub i64 %sub.ptr.lhs.cast158, %sub.ptr.rhs.cast159
  %sub.ptr.div161 = sdiv exact i64 %sub.ptr.sub160, 8
  %109 = load i32, i32* %max, align 4
  %conv162 = sext i32 %109 to i64
  %cmp163 = icmp slt i64 %sub.ptr.div161, %conv162
  br i1 %cmp163, label %if.then.165, label %if.end.175

if.then.165:                                      ; preds = %if.end.157
  %110 = load %struct.sv**, %struct.sv*** %mark, align 8
  %111 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %sub.ptr.lhs.cast167 = ptrtoint %struct.sv** %110 to i64
  %sub.ptr.rhs.cast168 = ptrtoint %struct.sv** %111 to i64
  %sub.ptr.sub169 = sub i64 %sub.ptr.lhs.cast167, %sub.ptr.rhs.cast168
  %sub.ptr.div170 = sdiv exact i64 %sub.ptr.sub169, 8
  %conv171 = trunc i64 %sub.ptr.div170 to i32
  store i32 %conv171, i32* %markoff, align 4
  %112 = load %struct.sv**, %struct.sv*** %sp, align 8
  %113 = load %struct.sv**, %struct.sv*** %mark, align 8
  %114 = load i32, i32* %max, align 4
  %call172 = call %struct.sv** @Perl_stack_grow(%struct.sv** %112, %struct.sv** %113, i32 %114)
  store %struct.sv** %call172, %struct.sv*** %sp, align 8
  %115 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %116 = load i32, i32* %markoff, align 4
  %idx.ext173 = sext i32 %116 to i64
  %add.ptr174 = getelementptr inbounds %struct.sv*, %struct.sv** %115, i64 %idx.ext173
  store %struct.sv** %add.ptr174, %struct.sv*** %mark, align 8
  br label %if.end.175

if.end.175:                                       ; preds = %if.then.165, %if.end.157
  %117 = load i64, i64* %count, align 8
  %cmp176 = icmp sgt i64 %117, 1
  br i1 %cmp176, label %if.then.178, label %if.else.196

if.then.178:                                      ; preds = %if.end.175
  br label %while.cond

while.cond:                                       ; preds = %if.end.185, %if.then.178
  %118 = load %struct.sv**, %struct.sv*** %sp, align 8
  %119 = load %struct.sv**, %struct.sv*** %mark, align 8
  %cmp179 = icmp ugt %struct.sv** %118, %119
  br i1 %cmp179, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %120 = load %struct.sv**, %struct.sv*** %sp, align 8
  %121 = load %struct.sv*, %struct.sv** %120, align 8
  %tobool181 = icmp ne %struct.sv* %121, null
  br i1 %tobool181, label %if.then.182, label %if.end.185

if.then.182:                                      ; preds = %while.body
  %122 = load %struct.sv**, %struct.sv*** %sp, align 8
  %123 = load %struct.sv*, %struct.sv** %122, align 8
  %sv_flags183 = getelementptr inbounds %struct.sv, %struct.sv* %123, i32 0, i32 2
  %124 = load i32, i32* %sv_flags183, align 4
  %and184 = and i32 %124, -2049
  store i32 %and184, i32* %sv_flags183, align 4
  br label %if.end.185

if.end.185:                                       ; preds = %if.then.182, %while.body
  %125 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr186 = getelementptr inbounds %struct.sv*, %struct.sv** %125, i32 -1
  store %struct.sv** %incdec.ptr186, %struct.sv*** %sp, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %126 = load %struct.sv**, %struct.sv*** %mark, align 8
  %incdec.ptr187 = getelementptr inbounds %struct.sv*, %struct.sv** %126, i32 1
  store %struct.sv** %incdec.ptr187, %struct.sv*** %mark, align 8
  %127 = load %struct.sv**, %struct.sv*** %mark, align 8
  %128 = load i32, i32* %items, align 4
  %idx.ext188 = sext i32 %128 to i64
  %add.ptr189 = getelementptr inbounds %struct.sv*, %struct.sv** %127, i64 %idx.ext188
  %129 = bitcast %struct.sv** %add.ptr189 to i8*
  %130 = load %struct.sv**, %struct.sv*** %mark, align 8
  %131 = bitcast %struct.sv** %130 to i8*
  %132 = load i32, i32* %items, align 4
  %conv190 = sext i32 %132 to i64
  %mul191 = mul i64 %conv190, 8
  %conv192 = trunc i64 %mul191 to i32
  %133 = load i64, i64* %count, align 8
  %sub = sub nsw i64 %133, 1
  %conv193 = trunc i64 %sub to i32
  call void @Perl_repeatcpy(i8* %129, i8* %131, i32 %conv192, i32 %conv193)
  %134 = load i32, i32* %max, align 4
  %135 = load %struct.sv**, %struct.sv*** %sp, align 8
  %idx.ext194 = sext i32 %134 to i64
  %add.ptr195 = getelementptr inbounds %struct.sv*, %struct.sv** %135, i64 %idx.ext194
  store %struct.sv** %add.ptr195, %struct.sv*** %sp, align 8
  br label %if.end.203

if.else.196:                                      ; preds = %if.end.175
  %136 = load i64, i64* %count, align 8
  %cmp197 = icmp sle i64 %136, 0
  br i1 %cmp197, label %if.then.199, label %if.end.202

if.then.199:                                      ; preds = %if.else.196
  %137 = load i32, i32* %items, align 4
  %138 = load %struct.sv**, %struct.sv*** %sp, align 8
  %idx.ext200 = sext i32 %137 to i64
  %idx.neg = sub i64 0, %idx.ext200
  %add.ptr201 = getelementptr inbounds %struct.sv*, %struct.sv** %138, i64 %idx.neg
  store %struct.sv** %add.ptr201, %struct.sv*** %sp, align 8
  br label %if.end.202

if.end.202:                                       ; preds = %if.then.199, %if.else.196
  br label %if.end.203

if.end.203:                                       ; preds = %if.end.202, %while.end
  br label %if.end.308

if.else.204:                                      ; preds = %land.lhs.true.131, %cond.end.127
  %139 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr206 = getelementptr inbounds %struct.sv*, %struct.sv** %139, i32 -1
  store %struct.sv** %incdec.ptr206, %struct.sv*** %sp, align 8
  %140 = load %struct.sv*, %struct.sv** %139, align 8
  store %struct.sv* %140, %struct.sv** %tmpstr, align 8
  %141 = load %struct.sv*, %struct.sv** %targ, align 8
  %142 = load %struct.sv*, %struct.sv** %tmpstr, align 8
  %cmp209 = icmp ne %struct.sv* %141, %142
  br i1 %cmp209, label %if.then.211, label %if.end.212

if.then.211:                                      ; preds = %if.else.204
  %143 = load %struct.sv*, %struct.sv** %targ, align 8
  %144 = load %struct.sv*, %struct.sv** %tmpstr, align 8
  call void @Perl_sv_setsv_flags(%struct.sv* %143, %struct.sv* %144, i32 2)
  br label %if.end.212

if.end.212:                                       ; preds = %if.then.211, %if.else.204
  %145 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags213 = getelementptr inbounds %struct.sv, %struct.sv* %145, i32 0, i32 2
  %146 = load i32, i32* %sv_flags213, align 4
  %and214 = and i32 %146, 10223616
  %cmp215 = icmp eq i32 %and214, 262144
  br i1 %cmp215, label %cond.true.217, label %cond.false.220

cond.true.217:                                    ; preds = %if.end.212
  %147 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any218 = getelementptr inbounds %struct.sv, %struct.sv* %147, i32 0, i32 0
  %148 = load i8*, i8** %sv_any218, align 8
  %149 = bitcast i8* %148 to %struct.xpv*
  %xpv_cur = getelementptr inbounds %struct.xpv, %struct.xpv* %149, i32 0, i32 1
  %150 = load i64, i64* %xpv_cur, align 8
  store i64 %150, i64* %len, align 8
  %151 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any219 = getelementptr inbounds %struct.sv, %struct.sv* %151, i32 0, i32 0
  %152 = load i8*, i8** %sv_any219, align 8
  %153 = bitcast i8* %152 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %153, i32 0, i32 0
  %154 = load i8*, i8** %xpv_pv, align 8
  br label %cond.end.222

cond.false.220:                                   ; preds = %if.end.212
  %155 = load %struct.sv*, %struct.sv** %targ, align 8
  %call221 = call i8* @Perl_sv_pvn_force_flags(%struct.sv* %155, i64* %len, i32 2)
  br label %cond.end.222

cond.end.222:                                     ; preds = %cond.false.220, %cond.true.217
  %cond223 = phi i8* [ %154, %cond.true.217 ], [ %call221, %cond.false.220 ]
  %156 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags224 = getelementptr inbounds %struct.sv, %struct.sv* %156, i32 0, i32 2
  %157 = load i32, i32* %sv_flags224, align 4
  %and225 = and i32 %157, 536870912
  %tobool226 = icmp ne i32 %and225, 0
  br i1 %tobool226, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %cond.end.222
  %158 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %op_private227 = getelementptr inbounds %struct.cop, %struct.cop* %158, i32 0, i32 7
  %159 = load i8, i8* %op_private227, align 1
  %conv228 = zext i8 %159 to i32
  %and229 = and i32 %conv228, 8
  %tobool230 = icmp ne i32 %and229, 0
  %lnot = xor i1 %tobool230, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %cond.end.222
  %160 = phi i1 [ false, %cond.end.222 ], [ %lnot, %land.rhs ]
  %land.ext = zext i1 %160 to i32
  %conv231 = trunc i32 %land.ext to i8
  store i8 %conv231, i8* %isutf, align 1
  %161 = load i64, i64* %count, align 8
  %cmp232 = icmp ne i64 %161, 1
  br i1 %cmp232, label %if.then.234, label %if.end.277

if.then.234:                                      ; preds = %land.end
  %162 = load i64, i64* %count, align 8
  %cmp235 = icmp slt i64 %162, 1
  br i1 %cmp235, label %if.then.237, label %if.else.241

if.then.237:                                      ; preds = %if.then.234
  %163 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any239 = getelementptr inbounds %struct.sv, %struct.sv* %163, i32 0, i32 0
  %164 = load i8*, i8** %sv_any239, align 8
  %165 = bitcast i8* %164 to %struct.xpv*
  %xpv_cur240 = getelementptr inbounds %struct.xpv, %struct.xpv* %165, i32 0, i32 1
  store i64 0, i64* %xpv_cur240, align 8
  store i64 0, i64* %tmp238
  %166 = load i64, i64* %tmp238
  br label %if.end.271

if.else.241:                                      ; preds = %if.then.234
  %167 = load i64, i64* %count, align 8
  %168 = load i64, i64* %len, align 8
  %mul244 = mul i64 %167, %168
  store i64 %mul244, i64* %max243, align 8
  %169 = load i64, i64* %len, align 8
  %170 = load i64, i64* %count, align 8
  %div = udiv i64 -1, %170
  %cmp245 = icmp ugt i64 %169, %div
  br i1 %cmp245, label %if.then.247, label %if.end.248

if.then.247:                                      ; preds = %if.else.241
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([35 x i8], [35 x i8]* @Perl_pp_repeat.oom_string_extend, i32 0, i32 0))
  br label %if.end.248

if.end.248:                                       ; preds = %if.then.247, %if.else.241
  %171 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any249 = getelementptr inbounds %struct.sv, %struct.sv* %171, i32 0, i32 0
  %172 = load i8*, i8** %sv_any249, align 8
  %173 = bitcast i8* %172 to %struct.xpv*
  %xpv_len = getelementptr inbounds %struct.xpv, %struct.xpv* %173, i32 0, i32 2
  %174 = load i64, i64* %xpv_len, align 8
  %175 = load i64, i64* %max243, align 8
  %add = add i64 %175, 1
  %cmp250 = icmp ult i64 %174, %add
  br i1 %cmp250, label %cond.true.252, label %cond.false.255

cond.true.252:                                    ; preds = %if.end.248
  %176 = load %struct.sv*, %struct.sv** %targ, align 8
  %177 = load i64, i64* %max243, align 8
  %add253 = add i64 %177, 1
  %call254 = call i8* @Perl_sv_grow(%struct.sv* %176, i64 %add253)
  br label %cond.end.258

cond.false.255:                                   ; preds = %if.end.248
  %178 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any256 = getelementptr inbounds %struct.sv, %struct.sv* %178, i32 0, i32 0
  %179 = load i8*, i8** %sv_any256, align 8
  %180 = bitcast i8* %179 to %struct.xpv*
  %xpv_pv257 = getelementptr inbounds %struct.xpv, %struct.xpv* %180, i32 0, i32 0
  %181 = load i8*, i8** %xpv_pv257, align 8
  br label %cond.end.258

cond.end.258:                                     ; preds = %cond.false.255, %cond.true.252
  %cond259 = phi i8* [ %call254, %cond.true.252 ], [ %181, %cond.false.255 ]
  %182 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any260 = getelementptr inbounds %struct.sv, %struct.sv* %182, i32 0, i32 0
  %183 = load i8*, i8** %sv_any260, align 8
  %184 = bitcast i8* %183 to %struct.xpv*
  %xpv_pv261 = getelementptr inbounds %struct.xpv, %struct.xpv* %184, i32 0, i32 0
  %185 = load i8*, i8** %xpv_pv261, align 8
  %186 = load i64, i64* %len, align 8
  %add.ptr262 = getelementptr inbounds i8, i8* %185, i64 %186
  %187 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any263 = getelementptr inbounds %struct.sv, %struct.sv* %187, i32 0, i32 0
  %188 = load i8*, i8** %sv_any263, align 8
  %189 = bitcast i8* %188 to %struct.xpv*
  %xpv_pv264 = getelementptr inbounds %struct.xpv, %struct.xpv* %189, i32 0, i32 0
  %190 = load i8*, i8** %xpv_pv264, align 8
  %191 = load i64, i64* %len, align 8
  %conv265 = trunc i64 %191 to i32
  %192 = load i64, i64* %count, align 8
  %sub266 = sub nsw i64 %192, 1
  %conv267 = trunc i64 %sub266 to i32
  call void @Perl_repeatcpy(i8* %add.ptr262, i8* %190, i32 %conv265, i32 %conv267)
  %193 = load i64, i64* %count, align 8
  %194 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any268 = getelementptr inbounds %struct.sv, %struct.sv* %194, i32 0, i32 0
  %195 = load i8*, i8** %sv_any268, align 8
  %196 = bitcast i8* %195 to %struct.xpv*
  %xpv_cur269 = getelementptr inbounds %struct.xpv, %struct.xpv* %196, i32 0, i32 1
  %197 = load i64, i64* %xpv_cur269, align 8
  %mul270 = mul i64 %197, %193
  store i64 %mul270, i64* %xpv_cur269, align 8
  br label %if.end.271

if.end.271:                                       ; preds = %cond.end.258, %if.then.237
  %198 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any272 = getelementptr inbounds %struct.sv, %struct.sv* %198, i32 0, i32 0
  %199 = load i8*, i8** %sv_any272, align 8
  %200 = bitcast i8* %199 to %struct.xpv*
  %xpv_pv273 = getelementptr inbounds %struct.xpv, %struct.xpv* %200, i32 0, i32 0
  %201 = load i8*, i8** %xpv_pv273, align 8
  %202 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any274 = getelementptr inbounds %struct.sv, %struct.sv* %202, i32 0, i32 0
  %203 = load i8*, i8** %sv_any274, align 8
  %204 = bitcast i8* %203 to %struct.xpv*
  %xpv_cur275 = getelementptr inbounds %struct.xpv, %struct.xpv* %204, i32 0, i32 1
  %205 = load i64, i64* %xpv_cur275, align 8
  %add.ptr276 = getelementptr inbounds i8, i8* %201, i64 %205
  store i8 0, i8* %add.ptr276, align 1
  br label %if.end.277

if.end.277:                                       ; preds = %if.end.271, %land.end
  %206 = load i8, i8* %isutf, align 1
  %tobool278 = icmp ne i8 %206, 0
  br i1 %tobool278, label %if.then.279, label %if.else.283

if.then.279:                                      ; preds = %if.end.277
  %207 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags280 = getelementptr inbounds %struct.sv, %struct.sv* %207, i32 0, i32 2
  %208 = load i32, i32* %sv_flags280, align 4
  %and281 = and i32 %208, 1760624639
  store i32 %and281, i32* %sv_flags280, align 4
  %209 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags282 = getelementptr inbounds %struct.sv, %struct.sv* %209, i32 0, i32 2
  %210 = load i32, i32* %sv_flags282, align 4
  %or = or i32 %210, 67371008
  store i32 %or, i32* %sv_flags282, align 4
  br label %if.end.288

if.else.283:                                      ; preds = %if.end.277
  %211 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags284 = getelementptr inbounds %struct.sv, %struct.sv* %211, i32 0, i32 2
  %212 = load i32, i32* %sv_flags284, align 4
  %and285 = and i32 %212, 1223753727
  store i32 %and285, i32* %sv_flags284, align 4
  %213 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags286 = getelementptr inbounds %struct.sv, %struct.sv* %213, i32 0, i32 2
  %214 = load i32, i32* %sv_flags286, align 4
  %or287 = or i32 %214, 67371008
  store i32 %or287, i32* %sv_flags286, align 4
  br label %if.end.288

if.end.288:                                       ; preds = %if.else.283, %if.then.279
  %215 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_private289 = getelementptr inbounds %struct.op, %struct.op* %215, i32 0, i32 7
  %216 = load i8, i8* %op_private289, align 1
  %conv290 = zext i8 %216 to i32
  %and291 = and i32 %conv290, 64
  %tobool292 = icmp ne i32 %and291, 0
  br i1 %tobool292, label %if.then.293, label %if.end.299

if.then.293:                                      ; preds = %if.end.288
  %217 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %218 = load i32*, i32** @PL_markstack_ptr, align 8
  %incdec.ptr296 = getelementptr inbounds i32, i32* %218, i32 -1
  store i32* %incdec.ptr296, i32** @PL_markstack_ptr, align 8
  %219 = load i32, i32* %218, align 4
  %idx.ext297 = sext i32 %219 to i64
  %add.ptr298 = getelementptr inbounds %struct.sv*, %struct.sv** %217, i64 %idx.ext297
  store %struct.sv** %add.ptr298, %struct.sv*** %mark295, align 8
  %220 = load %struct.sv**, %struct.sv*** %mark295, align 8
  store %struct.sv** %220, %struct.sv*** %sp, align 8
  br label %if.end.299

if.end.299:                                       ; preds = %if.then.293, %if.end.288
  %221 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags300 = getelementptr inbounds %struct.sv, %struct.sv* %221, i32 0, i32 2
  %222 = load i32, i32* %sv_flags300, align 4
  %and301 = and i32 %222, 16384
  %tobool302 = icmp ne i32 %and301, 0
  br i1 %tobool302, label %if.then.303, label %if.end.305

if.then.303:                                      ; preds = %if.end.299
  %223 = load %struct.sv*, %struct.sv** %targ, align 8
  %call304 = call i32 @Perl_mg_set(%struct.sv* %223)
  br label %if.end.305

if.end.305:                                       ; preds = %if.then.303, %if.end.299
  %224 = load %struct.sv*, %struct.sv** %targ, align 8
  %225 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr307 = getelementptr inbounds %struct.sv*, %struct.sv** %225, i32 1
  store %struct.sv** %incdec.ptr307, %struct.sv*** %sp, align 8
  store %struct.sv* %224, %struct.sv** %incdec.ptr307, align 8
  store %struct.sv* %224, %struct.sv** %tmp306
  %226 = load %struct.sv*, %struct.sv** %tmp306
  br label %if.end.308

if.end.308:                                       ; preds = %if.end.305, %if.end.203
  %227 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %227, %struct.sv*** @PL_stack_sp, align 8
  %228 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next309 = getelementptr inbounds %struct.op, %struct.op* %228, i32 0, i32 0
  %229 = load %struct.op*, %struct.op** %op_next309, align 8
  store %struct.op* %229, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.308, %if.end.29
  %230 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %230
}

declare i64 @Perl_sv_2uv(%struct.sv*) #1

declare void @Perl_repeatcpy(i8*, i8*, i32, i32) #1

declare i8* @Perl_sv_pvn_force_flags(%struct.sv*, i64*, i32) #1

declare i8* @Perl_sv_grow(%struct.sv*, i64) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_subtract() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %useleft = alloca i8, align 1
  %tmpsv = alloca %struct.sv*, align 8
  %right = alloca %struct.sv*, align 8
  %left = alloca %struct.sv*, align 8
  %tmp = alloca %struct.sv*, align 8
  %auv = alloca i64, align 8
  %auvok = alloca i8, align 1
  %a_valid = alloca i8, align 1
  %aiv = alloca i64, align 8
  %result_good = alloca i8, align 1
  %result = alloca i64, align 8
  %buv = alloca i64, align 8
  %buvok = alloca i8, align 1
  %biv = alloca i64, align 8
  %tmp198 = alloca %struct.sv*, align 8
  %tmp210 = alloca %struct.sv*, align 8
  %tmp220 = alloca %struct.sv*, align 8
  %value = alloca double, align 8
  %tmp266 = alloca %struct.sv*, align 8
  %tmp286 = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 6
  %2 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 64
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load %struct.sv**, %struct.sv*** %sp, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 -1
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %5 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %5, i32 0, i32 3
  %6 = load i64, i64* %op_targ, align 8
  %7 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx1 = getelementptr inbounds %struct.sv*, %struct.sv** %7, i64 %6
  %8 = load %struct.sv*, %struct.sv** %arrayidx1, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.sv* [ %4, %cond.true ], [ %8, %cond.false ]
  store %struct.sv* %cond, %struct.sv** %targ, align 8
  %9 = load i64, i64* @PL_amagic_generation, align 8
  %tobool2 = icmp ne i64 %9, 0
  br i1 %tobool2, label %if.then, label %if.end.31

if.then:                                          ; preds = %cond.end
  %10 = load %struct.sv**, %struct.sv*** %sp, align 8
  %11 = load %struct.sv*, %struct.sv** %10, align 8
  store %struct.sv* %11, %struct.sv** %right, align 8
  %12 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %12, i64 -1
  %13 = load %struct.sv*, %struct.sv** %add.ptr, align 8
  store %struct.sv* %13, %struct.sv** %left, align 8
  %14 = load %struct.sv*, %struct.sv** %left, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %14, i32 0, i32 2
  %15 = load i32, i32* %sv_flags, align 4
  %and3 = and i32 %15, 268435456
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %16 = load %struct.sv*, %struct.sv** %right, align 8
  %sv_flags5 = getelementptr inbounds %struct.sv, %struct.sv* %16, i32 0, i32 2
  %17 = load i32, i32* %sv_flags5, align 4
  %and6 = and i32 %17, 268435456
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %land.lhs.true, label %if.end.30

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %18 = load %struct.sv*, %struct.sv** %left, align 8
  %19 = load %struct.sv*, %struct.sv** %right, align 8
  %20 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags8 = getelementptr inbounds %struct.op, %struct.op* %20, i32 0, i32 6
  %21 = load i8, i8* %op_flags8, align 1
  %conv9 = zext i8 %21 to i32
  %and10 = and i32 %conv9, 64
  %tobool11 = icmp ne i32 %and10, 0
  %cond12 = select i1 %tobool11, i32 4, i32 0
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %18, %struct.sv* %19, i32 8, i32 %cond12)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool13 = icmp ne %struct.sv* %call, null
  br i1 %tobool13, label %if.then.14, label %if.end.30

if.then.14:                                       ; preds = %land.lhs.true
  %22 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %22, %struct.sv*** %sp, align 8
  %23 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %23, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %24 = load %struct.sv*, %struct.sv** %23, align 8
  %25 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags15 = getelementptr inbounds %struct.op, %struct.op* %25, i32 0, i32 6
  %26 = load i8, i8* %op_flags15, align 1
  %conv16 = zext i8 %26 to i32
  %and17 = and i32 %conv16, 64
  %tobool18 = icmp ne i32 %and17, 0
  br i1 %tobool18, label %if.then.23, label %lor.lhs.false.19

lor.lhs.false.19:                                 ; preds = %if.then.14
  %27 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags20 = getelementptr inbounds %struct.sv, %struct.sv* %27, i32 0, i32 2
  %28 = load i32, i32* %sv_flags20, align 4
  %and21 = and i32 %28, 1024
  %tobool22 = icmp ne i32 %and21, 0
  br i1 %tobool22, label %if.then.23, label %if.else

if.then.23:                                       ; preds = %lor.lhs.false.19, %if.then.14
  %29 = load %struct.sv*, %struct.sv** %targ, align 8
  %30 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  call void @Perl_sv_setsv_flags(%struct.sv* %29, %struct.sv* %30, i32 2)
  %31 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags24 = getelementptr inbounds %struct.sv, %struct.sv* %31, i32 0, i32 2
  %32 = load i32, i32* %sv_flags24, align 4
  %and25 = and i32 %32, 16384
  %tobool26 = icmp ne i32 %and25, 0
  br i1 %tobool26, label %if.then.27, label %if.end

if.then.27:                                       ; preds = %if.then.23
  %33 = load %struct.sv*, %struct.sv** %targ, align 8
  %call28 = call i32 @Perl_mg_set(%struct.sv* %33)
  br label %if.end

if.end:                                           ; preds = %if.then.27, %if.then.23
  %34 = load %struct.sv*, %struct.sv** %targ, align 8
  %35 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %34, %struct.sv** %35, align 8
  store %struct.sv* %34, %struct.sv** %tmp
  %36 = load %struct.sv*, %struct.sv** %tmp
  br label %if.end.29

if.else:                                          ; preds = %lor.lhs.false.19
  %37 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %38 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %37, %struct.sv** %38, align 8
  br label %if.end.29

if.end.29:                                        ; preds = %if.else, %if.end
  %39 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %39, %struct.sv*** @PL_stack_sp, align 8
  %40 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %40, i32 0, i32 0
  %41 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %41, %struct.op** %retval
  br label %return

if.end.30:                                        ; preds = %land.lhs.true, %lor.lhs.false
  br label %if.end.31

if.end.31:                                        ; preds = %if.end.30, %cond.end
  %42 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr32 = getelementptr inbounds %struct.sv*, %struct.sv** %42, i64 -1
  %43 = load %struct.sv*, %struct.sv** %add.ptr32, align 8
  %sv_flags33 = getelementptr inbounds %struct.sv, %struct.sv* %43, i32 0, i32 2
  %44 = load i32, i32* %sv_flags33, align 4
  %and34 = and i32 %44, 118423552
  %tobool35 = icmp ne i32 %and34, 0
  br i1 %tobool35, label %lor.end, label %lor.lhs.false.36

lor.lhs.false.36:                                 ; preds = %if.end.31
  %45 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr37 = getelementptr inbounds %struct.sv*, %struct.sv** %45, i64 -1
  %46 = load %struct.sv*, %struct.sv** %add.ptr37, align 8
  %sv_flags38 = getelementptr inbounds %struct.sv, %struct.sv* %46, i32 0, i32 2
  %47 = load i32, i32* %sv_flags38, align 4
  %and39 = and i32 %47, 8192
  %tobool40 = icmp ne i32 %and39, 0
  br i1 %tobool40, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false.36
  %48 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags41 = getelementptr inbounds %struct.op, %struct.op* %48, i32 0, i32 6
  %49 = load i8, i8* %op_flags41, align 1
  %conv42 = zext i8 %49 to i32
  %and43 = and i32 %conv42, 64
  %tobool44 = icmp ne i32 %and43, 0
  %lnot = xor i1 %tobool44, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false.36, %if.end.31
  %50 = phi i1 [ true, %lor.lhs.false.36 ], [ true, %if.end.31 ], [ %lnot, %lor.rhs ]
  %lor.ext = zext i1 %50 to i32
  %conv45 = trunc i32 %lor.ext to i8
  store i8 %conv45, i8* %useleft, align 1
  %51 = load %struct.sv**, %struct.sv*** %sp, align 8
  %52 = load %struct.sv*, %struct.sv** %51, align 8
  %sv_flags46 = getelementptr inbounds %struct.sv, %struct.sv* %52, i32 0, i32 2
  %53 = load i32, i32* %sv_flags46, align 4
  %and47 = and i32 %53, 16777216
  %tobool48 = icmp ne i32 %and47, 0
  br i1 %tobool48, label %if.end.66, label %land.lhs.true.49

land.lhs.true.49:                                 ; preds = %lor.end
  %54 = load %struct.sv**, %struct.sv*** %sp, align 8
  %55 = load %struct.sv*, %struct.sv** %54, align 8
  %sv_flags50 = getelementptr inbounds %struct.sv, %struct.sv* %55, i32 0, i32 2
  %56 = load i32, i32* %sv_flags50, align 4
  %and51 = and i32 %56, 131072
  %tobool52 = icmp ne i32 %and51, 0
  br i1 %tobool52, label %if.then.57, label %lor.lhs.false.53

lor.lhs.false.53:                                 ; preds = %land.lhs.true.49
  %57 = load %struct.sv**, %struct.sv*** %sp, align 8
  %58 = load %struct.sv*, %struct.sv** %57, align 8
  %sv_flags54 = getelementptr inbounds %struct.sv, %struct.sv* %58, i32 0, i32 2
  %59 = load i32, i32* %sv_flags54, align 4
  %and55 = and i32 %59, 262144
  %tobool56 = icmp ne i32 %and55, 0
  br i1 %tobool56, label %if.then.57, label %if.end.66

if.then.57:                                       ; preds = %lor.lhs.false.53, %land.lhs.true.49
  %60 = load %struct.sv**, %struct.sv*** %sp, align 8
  %61 = load %struct.sv*, %struct.sv** %60, align 8
  %sv_flags58 = getelementptr inbounds %struct.sv, %struct.sv* %61, i32 0, i32 2
  %62 = load i32, i32* %sv_flags58, align 4
  %and59 = and i32 %62, 65536
  %tobool60 = icmp ne i32 %and59, 0
  br i1 %tobool60, label %cond.true.61, label %cond.false.62

cond.true.61:                                     ; preds = %if.then.57
  %63 = load %struct.sv**, %struct.sv*** %sp, align 8
  %64 = load %struct.sv*, %struct.sv** %63, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %64, i32 0, i32 0
  %65 = load i8*, i8** %sv_any, align 8
  %66 = bitcast i8* %65 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %66, i32 0, i32 3
  %67 = load i64, i64* %xiv_iv, align 8
  br label %cond.end.64

cond.false.62:                                    ; preds = %if.then.57
  %68 = load %struct.sv**, %struct.sv*** %sp, align 8
  %69 = load %struct.sv*, %struct.sv** %68, align 8
  %call63 = call i64 @Perl_sv_2iv(%struct.sv* %69)
  br label %cond.end.64

cond.end.64:                                      ; preds = %cond.false.62, %cond.true.61
  %cond65 = phi i64 [ %67, %cond.true.61 ], [ %call63, %cond.false.62 ]
  br label %if.end.66

if.end.66:                                        ; preds = %cond.end.64, %lor.lhs.false.53, %lor.end
  %70 = load %struct.sv**, %struct.sv*** %sp, align 8
  %71 = load %struct.sv*, %struct.sv** %70, align 8
  %sv_flags67 = getelementptr inbounds %struct.sv, %struct.sv* %71, i32 0, i32 2
  %72 = load i32, i32* %sv_flags67, align 4
  %and68 = and i32 %72, 65536
  %tobool69 = icmp ne i32 %and68, 0
  br i1 %tobool69, label %if.then.70, label %if.end.226

if.then.70:                                       ; preds = %if.end.66
  store i64 0, i64* %auv, align 8
  store i8 0, i8* %auvok, align 1
  store i8 0, i8* %a_valid, align 1
  %73 = load i8, i8* %useleft, align 1
  %tobool74 = icmp ne i8 %73, 0
  br i1 %tobool74, label %if.else.76, label %if.then.75

if.then.75:                                       ; preds = %if.then.70
  store i64 0, i64* %auv, align 8
  store i8 1, i8* %auvok, align 1
  store i8 1, i8* %a_valid, align 1
  br label %if.end.132

if.else.76:                                       ; preds = %if.then.70
  %74 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr77 = getelementptr inbounds %struct.sv*, %struct.sv** %74, i64 -1
  %75 = load %struct.sv*, %struct.sv** %add.ptr77, align 8
  %sv_flags78 = getelementptr inbounds %struct.sv, %struct.sv* %75, i32 0, i32 2
  %76 = load i32, i32* %sv_flags78, align 4
  %and79 = and i32 %76, 16777216
  %tobool80 = icmp ne i32 %and79, 0
  br i1 %tobool80, label %if.end.105, label %land.lhs.true.81

land.lhs.true.81:                                 ; preds = %if.else.76
  %77 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr82 = getelementptr inbounds %struct.sv*, %struct.sv** %77, i64 -1
  %78 = load %struct.sv*, %struct.sv** %add.ptr82, align 8
  %sv_flags83 = getelementptr inbounds %struct.sv, %struct.sv* %78, i32 0, i32 2
  %79 = load i32, i32* %sv_flags83, align 4
  %and84 = and i32 %79, 131072
  %tobool85 = icmp ne i32 %and84, 0
  br i1 %tobool85, label %if.then.91, label %lor.lhs.false.86

lor.lhs.false.86:                                 ; preds = %land.lhs.true.81
  %80 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr87 = getelementptr inbounds %struct.sv*, %struct.sv** %80, i64 -1
  %81 = load %struct.sv*, %struct.sv** %add.ptr87, align 8
  %sv_flags88 = getelementptr inbounds %struct.sv, %struct.sv* %81, i32 0, i32 2
  %82 = load i32, i32* %sv_flags88, align 4
  %and89 = and i32 %82, 262144
  %tobool90 = icmp ne i32 %and89, 0
  br i1 %tobool90, label %if.then.91, label %if.end.105

if.then.91:                                       ; preds = %lor.lhs.false.86, %land.lhs.true.81
  %83 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr92 = getelementptr inbounds %struct.sv*, %struct.sv** %83, i64 -1
  %84 = load %struct.sv*, %struct.sv** %add.ptr92, align 8
  %sv_flags93 = getelementptr inbounds %struct.sv, %struct.sv* %84, i32 0, i32 2
  %85 = load i32, i32* %sv_flags93, align 4
  %and94 = and i32 %85, 65536
  %tobool95 = icmp ne i32 %and94, 0
  br i1 %tobool95, label %cond.true.96, label %cond.false.100

cond.true.96:                                     ; preds = %if.then.91
  %86 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr97 = getelementptr inbounds %struct.sv*, %struct.sv** %86, i64 -1
  %87 = load %struct.sv*, %struct.sv** %add.ptr97, align 8
  %sv_any98 = getelementptr inbounds %struct.sv, %struct.sv* %87, i32 0, i32 0
  %88 = load i8*, i8** %sv_any98, align 8
  %89 = bitcast i8* %88 to %struct.xpviv*
  %xiv_iv99 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %89, i32 0, i32 3
  %90 = load i64, i64* %xiv_iv99, align 8
  br label %cond.end.103

cond.false.100:                                   ; preds = %if.then.91
  %91 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr101 = getelementptr inbounds %struct.sv*, %struct.sv** %91, i64 -1
  %92 = load %struct.sv*, %struct.sv** %add.ptr101, align 8
  %call102 = call i64 @Perl_sv_2iv(%struct.sv* %92)
  br label %cond.end.103

cond.end.103:                                     ; preds = %cond.false.100, %cond.true.96
  %cond104 = phi i64 [ %90, %cond.true.96 ], [ %call102, %cond.false.100 ]
  br label %if.end.105

if.end.105:                                       ; preds = %cond.end.103, %lor.lhs.false.86, %if.else.76
  %93 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr106 = getelementptr inbounds %struct.sv*, %struct.sv** %93, i64 -1
  %94 = load %struct.sv*, %struct.sv** %add.ptr106, align 8
  %sv_flags107 = getelementptr inbounds %struct.sv, %struct.sv* %94, i32 0, i32 2
  %95 = load i32, i32* %sv_flags107, align 4
  %and108 = and i32 %95, 65536
  %tobool109 = icmp ne i32 %and108, 0
  br i1 %tobool109, label %if.then.110, label %if.end.131

if.then.110:                                      ; preds = %if.end.105
  %96 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr111 = getelementptr inbounds %struct.sv*, %struct.sv** %96, i64 -1
  %97 = load %struct.sv*, %struct.sv** %add.ptr111, align 8
  %sv_flags112 = getelementptr inbounds %struct.sv, %struct.sv* %97, i32 0, i32 2
  %98 = load i32, i32* %sv_flags112, align 4
  %and113 = and i32 %98, -2147418112
  %cmp = icmp eq i32 %and113, -2147418112
  %conv114 = zext i1 %cmp to i32
  %conv115 = trunc i32 %conv114 to i8
  store i8 %conv115, i8* %auvok, align 1
  %tobool116 = icmp ne i8 %conv115, 0
  br i1 %tobool116, label %if.then.117, label %if.else.120

if.then.117:                                      ; preds = %if.then.110
  %99 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr118 = getelementptr inbounds %struct.sv*, %struct.sv** %99, i64 -1
  %100 = load %struct.sv*, %struct.sv** %add.ptr118, align 8
  %sv_any119 = getelementptr inbounds %struct.sv, %struct.sv* %100, i32 0, i32 0
  %101 = load i8*, i8** %sv_any119, align 8
  %102 = bitcast i8* %101 to %struct.xpvuv*
  %xuv_uv = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %102, i32 0, i32 3
  %103 = load i64, i64* %xuv_uv, align 8
  store i64 %103, i64* %auv, align 8
  br label %if.end.130

if.else.120:                                      ; preds = %if.then.110
  %104 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr122 = getelementptr inbounds %struct.sv*, %struct.sv** %104, i64 -1
  %105 = load %struct.sv*, %struct.sv** %add.ptr122, align 8
  %sv_any123 = getelementptr inbounds %struct.sv, %struct.sv* %105, i32 0, i32 0
  %106 = load i8*, i8** %sv_any123, align 8
  %107 = bitcast i8* %106 to %struct.xpviv*
  %xiv_iv124 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %107, i32 0, i32 3
  %108 = load i64, i64* %xiv_iv124, align 8
  store i64 %108, i64* %aiv, align 8
  %109 = load i64, i64* %aiv, align 8
  %cmp125 = icmp sge i64 %109, 0
  br i1 %cmp125, label %if.then.127, label %if.else.128

if.then.127:                                      ; preds = %if.else.120
  %110 = load i64, i64* %aiv, align 8
  store i64 %110, i64* %auv, align 8
  store i8 1, i8* %auvok, align 1
  br label %if.end.129

if.else.128:                                      ; preds = %if.else.120
  %111 = load i64, i64* %aiv, align 8
  %sub = sub nsw i64 0, %111
  store i64 %sub, i64* %auv, align 8
  br label %if.end.129

if.end.129:                                       ; preds = %if.else.128, %if.then.127
  br label %if.end.130

if.end.130:                                       ; preds = %if.end.129, %if.then.117
  store i8 1, i8* %a_valid, align 1
  br label %if.end.131

if.end.131:                                       ; preds = %if.end.130, %if.end.105
  br label %if.end.132

if.end.132:                                       ; preds = %if.end.131, %if.then.75
  %112 = load i8, i8* %a_valid, align 1
  %tobool133 = icmp ne i8 %112, 0
  br i1 %tobool133, label %if.then.134, label %if.end.225

if.then.134:                                      ; preds = %if.end.132
  store i8 0, i8* %result_good, align 1
  %113 = load %struct.sv**, %struct.sv*** %sp, align 8
  %114 = load %struct.sv*, %struct.sv** %113, align 8
  %sv_flags139 = getelementptr inbounds %struct.sv, %struct.sv* %114, i32 0, i32 2
  %115 = load i32, i32* %sv_flags139, align 4
  %and140 = and i32 %115, -2147418112
  %cmp141 = icmp eq i32 %and140, -2147418112
  %conv142 = zext i1 %cmp141 to i32
  %conv143 = trunc i32 %conv142 to i8
  store i8 %conv143, i8* %buvok, align 1
  %116 = load i8, i8* %buvok, align 1
  %tobool144 = icmp ne i8 %116, 0
  br i1 %tobool144, label %if.then.145, label %if.else.148

if.then.145:                                      ; preds = %if.then.134
  %117 = load %struct.sv**, %struct.sv*** %sp, align 8
  %118 = load %struct.sv*, %struct.sv** %117, align 8
  %sv_any146 = getelementptr inbounds %struct.sv, %struct.sv* %118, i32 0, i32 0
  %119 = load i8*, i8** %sv_any146, align 8
  %120 = bitcast i8* %119 to %struct.xpvuv*
  %xuv_uv147 = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %120, i32 0, i32 3
  %121 = load i64, i64* %xuv_uv147, align 8
  store i64 %121, i64* %buv, align 8
  br label %if.end.158

if.else.148:                                      ; preds = %if.then.134
  %122 = load %struct.sv**, %struct.sv*** %sp, align 8
  %123 = load %struct.sv*, %struct.sv** %122, align 8
  %sv_any150 = getelementptr inbounds %struct.sv, %struct.sv* %123, i32 0, i32 0
  %124 = load i8*, i8** %sv_any150, align 8
  %125 = bitcast i8* %124 to %struct.xpviv*
  %xiv_iv151 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %125, i32 0, i32 3
  %126 = load i64, i64* %xiv_iv151, align 8
  store i64 %126, i64* %biv, align 8
  %127 = load i64, i64* %biv, align 8
  %cmp152 = icmp sge i64 %127, 0
  br i1 %cmp152, label %if.then.154, label %if.else.155

if.then.154:                                      ; preds = %if.else.148
  %128 = load i64, i64* %biv, align 8
  store i64 %128, i64* %buv, align 8
  store i8 1, i8* %buvok, align 1
  br label %if.end.157

if.else.155:                                      ; preds = %if.else.148
  %129 = load i64, i64* %biv, align 8
  %sub156 = sub nsw i64 0, %129
  store i64 %sub156, i64* %buv, align 8
  br label %if.end.157

if.end.157:                                       ; preds = %if.else.155, %if.then.154
  br label %if.end.158

if.end.158:                                       ; preds = %if.end.157, %if.then.145
  %130 = load i8, i8* %auvok, align 1
  %conv159 = sext i8 %130 to i32
  %131 = load i8, i8* %buvok, align 1
  %conv160 = sext i8 %131 to i32
  %xor = xor i32 %conv159, %conv160
  %tobool161 = icmp ne i32 %xor, 0
  br i1 %tobool161, label %if.then.162, label %if.else.167

if.then.162:                                      ; preds = %if.end.158
  %132 = load i64, i64* %auv, align 8
  %133 = load i64, i64* %buv, align 8
  %add = add i64 %132, %133
  store i64 %add, i64* %result, align 8
  %134 = load i64, i64* %result, align 8
  %135 = load i64, i64* %auv, align 8
  %cmp163 = icmp uge i64 %134, %135
  br i1 %cmp163, label %if.then.165, label %if.end.166

if.then.165:                                      ; preds = %if.then.162
  store i8 1, i8* %result_good, align 1
  br label %if.end.166

if.end.166:                                       ; preds = %if.then.165, %if.then.162
  br label %if.end.186

if.else.167:                                      ; preds = %if.end.158
  %136 = load i64, i64* %auv, align 8
  %137 = load i64, i64* %buv, align 8
  %cmp168 = icmp uge i64 %136, %137
  br i1 %cmp168, label %if.then.170, label %if.else.176

if.then.170:                                      ; preds = %if.else.167
  %138 = load i64, i64* %auv, align 8
  %139 = load i64, i64* %buv, align 8
  %sub171 = sub i64 %138, %139
  store i64 %sub171, i64* %result, align 8
  %140 = load i64, i64* %result, align 8
  %141 = load i64, i64* %auv, align 8
  %cmp172 = icmp ule i64 %140, %141
  br i1 %cmp172, label %if.then.174, label %if.end.175

if.then.174:                                      ; preds = %if.then.170
  store i8 1, i8* %result_good, align 1
  br label %if.end.175

if.end.175:                                       ; preds = %if.then.174, %if.then.170
  br label %if.end.185

if.else.176:                                      ; preds = %if.else.167
  %142 = load i64, i64* %buv, align 8
  %143 = load i64, i64* %auv, align 8
  %sub177 = sub i64 %142, %143
  store i64 %sub177, i64* %result, align 8
  %144 = load i64, i64* %result, align 8
  %145 = load i64, i64* %buv, align 8
  %cmp178 = icmp ule i64 %144, %145
  br i1 %cmp178, label %if.then.180, label %if.end.184

if.then.180:                                      ; preds = %if.else.176
  %146 = load i8, i8* %auvok, align 1
  %tobool181 = icmp ne i8 %146, 0
  %lnot182 = xor i1 %tobool181, true
  %lnot.ext = zext i1 %lnot182 to i32
  %conv183 = trunc i32 %lnot.ext to i8
  store i8 %conv183, i8* %auvok, align 1
  store i8 1, i8* %result_good, align 1
  br label %if.end.184

if.end.184:                                       ; preds = %if.then.180, %if.else.176
  br label %if.end.185

if.end.185:                                       ; preds = %if.end.184, %if.end.175
  br label %if.end.186

if.end.186:                                       ; preds = %if.end.185, %if.end.166
  %147 = load i8, i8* %result_good, align 1
  %tobool187 = icmp ne i8 %147, 0
  br i1 %tobool187, label %if.then.188, label %if.end.224

if.then.188:                                      ; preds = %if.end.186
  %148 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr189 = getelementptr inbounds %struct.sv*, %struct.sv** %148, i32 -1
  store %struct.sv** %incdec.ptr189, %struct.sv*** %sp, align 8
  %149 = load i8, i8* %auvok, align 1
  %tobool190 = icmp ne i8 %149, 0
  br i1 %tobool190, label %if.then.191, label %if.else.199

if.then.191:                                      ; preds = %if.then.188
  %150 = load %struct.sv*, %struct.sv** %targ, align 8
  %151 = load i64, i64* %result, align 8
  call void @Perl_sv_setuv(%struct.sv* %150, i64 %151)
  %152 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags192 = getelementptr inbounds %struct.sv, %struct.sv* %152, i32 0, i32 2
  %153 = load i32, i32* %sv_flags192, align 4
  %and193 = and i32 %153, 16384
  %tobool194 = icmp ne i32 %and193, 0
  br i1 %tobool194, label %if.then.195, label %if.end.197

if.then.195:                                      ; preds = %if.then.191
  %154 = load %struct.sv*, %struct.sv** %targ, align 8
  %call196 = call i32 @Perl_mg_set(%struct.sv* %154)
  br label %if.end.197

if.end.197:                                       ; preds = %if.then.195, %if.then.191
  %155 = load %struct.sv*, %struct.sv** %targ, align 8
  %156 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %155, %struct.sv** %156, align 8
  store %struct.sv* %155, %struct.sv** %tmp198
  %157 = load %struct.sv*, %struct.sv** %tmp198
  br label %if.end.222

if.else.199:                                      ; preds = %if.then.188
  %158 = load i64, i64* %result, align 8
  %cmp200 = icmp ule i64 %158, -9223372036854775808
  br i1 %cmp200, label %if.then.202, label %if.else.211

if.then.202:                                      ; preds = %if.else.199
  %159 = load %struct.sv*, %struct.sv** %targ, align 8
  %160 = load i64, i64* %result, align 8
  %sub203 = sub nsw i64 0, %160
  call void @Perl_sv_setiv(%struct.sv* %159, i64 %sub203)
  %161 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags204 = getelementptr inbounds %struct.sv, %struct.sv* %161, i32 0, i32 2
  %162 = load i32, i32* %sv_flags204, align 4
  %and205 = and i32 %162, 16384
  %tobool206 = icmp ne i32 %and205, 0
  br i1 %tobool206, label %if.then.207, label %if.end.209

if.then.207:                                      ; preds = %if.then.202
  %163 = load %struct.sv*, %struct.sv** %targ, align 8
  %call208 = call i32 @Perl_mg_set(%struct.sv* %163)
  br label %if.end.209

if.end.209:                                       ; preds = %if.then.207, %if.then.202
  %164 = load %struct.sv*, %struct.sv** %targ, align 8
  %165 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %164, %struct.sv** %165, align 8
  store %struct.sv* %164, %struct.sv** %tmp210
  %166 = load %struct.sv*, %struct.sv** %tmp210
  br label %if.end.221

if.else.211:                                      ; preds = %if.else.199
  %167 = load %struct.sv*, %struct.sv** %targ, align 8
  %168 = load i64, i64* %result, align 8
  %conv212 = uitofp i64 %168 to double
  %sub213 = fsub double -0.000000e+00, %conv212
  call void @Perl_sv_setnv(%struct.sv* %167, double %sub213)
  %169 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags214 = getelementptr inbounds %struct.sv, %struct.sv* %169, i32 0, i32 2
  %170 = load i32, i32* %sv_flags214, align 4
  %and215 = and i32 %170, 16384
  %tobool216 = icmp ne i32 %and215, 0
  br i1 %tobool216, label %if.then.217, label %if.end.219

if.then.217:                                      ; preds = %if.else.211
  %171 = load %struct.sv*, %struct.sv** %targ, align 8
  %call218 = call i32 @Perl_mg_set(%struct.sv* %171)
  br label %if.end.219

if.end.219:                                       ; preds = %if.then.217, %if.else.211
  %172 = load %struct.sv*, %struct.sv** %targ, align 8
  %173 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %172, %struct.sv** %173, align 8
  store %struct.sv* %172, %struct.sv** %tmp220
  %174 = load %struct.sv*, %struct.sv** %tmp220
  br label %if.end.221

if.end.221:                                       ; preds = %if.end.219, %if.end.209
  br label %if.end.222

if.end.222:                                       ; preds = %if.end.221, %if.end.197
  %175 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %175, %struct.sv*** @PL_stack_sp, align 8
  %176 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next223 = getelementptr inbounds %struct.op, %struct.op* %176, i32 0, i32 0
  %177 = load %struct.op*, %struct.op** %op_next223, align 8
  store %struct.op* %177, %struct.op** %retval
  br label %return

if.end.224:                                       ; preds = %if.end.186
  br label %if.end.225

if.end.225:                                       ; preds = %if.end.224, %if.end.132
  br label %if.end.226

if.end.226:                                       ; preds = %if.end.225, %if.end.66
  %178 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr227 = getelementptr inbounds %struct.sv*, %struct.sv** %178, i64 -1
  %179 = load %struct.sv*, %struct.sv** %add.ptr227, align 8
  %sv_flags228 = getelementptr inbounds %struct.sv, %struct.sv* %179, i32 0, i32 2
  %180 = load i32, i32* %sv_flags228, align 4
  %and229 = and i32 %180, 118423552
  %tobool230 = icmp ne i32 %and229, 0
  br i1 %tobool230, label %lor.end.243, label %lor.lhs.false.231

lor.lhs.false.231:                                ; preds = %if.end.226
  %181 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr232 = getelementptr inbounds %struct.sv*, %struct.sv** %181, i64 -1
  %182 = load %struct.sv*, %struct.sv** %add.ptr232, align 8
  %sv_flags233 = getelementptr inbounds %struct.sv, %struct.sv* %182, i32 0, i32 2
  %183 = load i32, i32* %sv_flags233, align 4
  %and234 = and i32 %183, 8192
  %tobool235 = icmp ne i32 %and234, 0
  br i1 %tobool235, label %lor.end.243, label %lor.rhs.236

lor.rhs.236:                                      ; preds = %lor.lhs.false.231
  %184 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags237 = getelementptr inbounds %struct.op, %struct.op* %184, i32 0, i32 6
  %185 = load i8, i8* %op_flags237, align 1
  %conv238 = zext i8 %185 to i32
  %and239 = and i32 %conv238, 64
  %tobool240 = icmp ne i32 %and239, 0
  %lnot241 = xor i1 %tobool240, true
  br label %lor.end.243

lor.end.243:                                      ; preds = %lor.rhs.236, %lor.lhs.false.231, %if.end.226
  %186 = phi i1 [ true, %lor.lhs.false.231 ], [ true, %if.end.226 ], [ %lnot241, %lor.rhs.236 ]
  %lor.ext244 = zext i1 %186 to i32
  %conv245 = trunc i32 %lor.ext244 to i8
  store i8 %conv245, i8* %useleft, align 1
  %187 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr247 = getelementptr inbounds %struct.sv*, %struct.sv** %187, i32 -1
  store %struct.sv** %incdec.ptr247, %struct.sv*** %sp, align 8
  %188 = load %struct.sv*, %struct.sv** %187, align 8
  store %struct.sv* %188, %struct.sv** @PL_Sv, align 8
  %189 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags248 = getelementptr inbounds %struct.sv, %struct.sv* %189, i32 0, i32 2
  %190 = load i32, i32* %sv_flags248, align 4
  %and249 = and i32 %190, 131072
  %tobool250 = icmp ne i32 %and249, 0
  br i1 %tobool250, label %cond.true.251, label %cond.false.253

cond.true.251:                                    ; preds = %lor.end.243
  %191 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any252 = getelementptr inbounds %struct.sv, %struct.sv* %191, i32 0, i32 0
  %192 = load i8*, i8** %sv_any252, align 8
  %193 = bitcast i8* %192 to %struct.xpvnv*
  %xnv_nv = getelementptr inbounds %struct.xpvnv, %struct.xpvnv* %193, i32 0, i32 4
  %194 = load double, double* %xnv_nv, align 8
  br label %cond.end.255

cond.false.253:                                   ; preds = %lor.end.243
  %195 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call254 = call double @Perl_sv_2nv(%struct.sv* %195)
  br label %cond.end.255

cond.end.255:                                     ; preds = %cond.false.253, %cond.true.251
  %cond256 = phi double [ %194, %cond.true.251 ], [ %call254, %cond.false.253 ]
  store double %cond256, double* %value, align 8
  %196 = load i8, i8* %useleft, align 1
  %tobool257 = icmp ne i8 %196, 0
  br i1 %tobool257, label %if.end.268, label %if.then.258

if.then.258:                                      ; preds = %cond.end.255
  %197 = load %struct.sv*, %struct.sv** %targ, align 8
  %198 = load double, double* %value, align 8
  %sub259 = fsub double -0.000000e+00, %198
  call void @Perl_sv_setnv(%struct.sv* %197, double %sub259)
  %199 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags260 = getelementptr inbounds %struct.sv, %struct.sv* %199, i32 0, i32 2
  %200 = load i32, i32* %sv_flags260, align 4
  %and261 = and i32 %200, 16384
  %tobool262 = icmp ne i32 %and261, 0
  br i1 %tobool262, label %if.then.263, label %if.end.265

if.then.263:                                      ; preds = %if.then.258
  %201 = load %struct.sv*, %struct.sv** %targ, align 8
  %call264 = call i32 @Perl_mg_set(%struct.sv* %201)
  br label %if.end.265

if.end.265:                                       ; preds = %if.then.263, %if.then.258
  %202 = load %struct.sv*, %struct.sv** %targ, align 8
  %203 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %202, %struct.sv** %203, align 8
  store %struct.sv* %202, %struct.sv** %tmp266
  %204 = load %struct.sv*, %struct.sv** %tmp266
  %205 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %205, %struct.sv*** @PL_stack_sp, align 8
  %206 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next267 = getelementptr inbounds %struct.op, %struct.op* %206, i32 0, i32 0
  %207 = load %struct.op*, %struct.op** %op_next267, align 8
  store %struct.op* %207, %struct.op** %retval
  br label %return

if.end.268:                                       ; preds = %cond.end.255
  %208 = load %struct.sv*, %struct.sv** %targ, align 8
  %209 = load %struct.sv**, %struct.sv*** %sp, align 8
  %210 = load %struct.sv*, %struct.sv** %209, align 8
  %sv_flags269 = getelementptr inbounds %struct.sv, %struct.sv* %210, i32 0, i32 2
  %211 = load i32, i32* %sv_flags269, align 4
  %and270 = and i32 %211, 131072
  %tobool271 = icmp ne i32 %and270, 0
  br i1 %tobool271, label %cond.true.272, label %cond.false.275

cond.true.272:                                    ; preds = %if.end.268
  %212 = load %struct.sv**, %struct.sv*** %sp, align 8
  %213 = load %struct.sv*, %struct.sv** %212, align 8
  %sv_any273 = getelementptr inbounds %struct.sv, %struct.sv* %213, i32 0, i32 0
  %214 = load i8*, i8** %sv_any273, align 8
  %215 = bitcast i8* %214 to %struct.xpvnv*
  %xnv_nv274 = getelementptr inbounds %struct.xpvnv, %struct.xpvnv* %215, i32 0, i32 4
  %216 = load double, double* %xnv_nv274, align 8
  br label %cond.end.277

cond.false.275:                                   ; preds = %if.end.268
  %217 = load %struct.sv**, %struct.sv*** %sp, align 8
  %218 = load %struct.sv*, %struct.sv** %217, align 8
  %call276 = call double @Perl_sv_2nv(%struct.sv* %218)
  br label %cond.end.277

cond.end.277:                                     ; preds = %cond.false.275, %cond.true.272
  %cond278 = phi double [ %216, %cond.true.272 ], [ %call276, %cond.false.275 ]
  %219 = load double, double* %value, align 8
  %sub279 = fsub double %cond278, %219
  call void @Perl_sv_setnv(%struct.sv* %208, double %sub279)
  %220 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags280 = getelementptr inbounds %struct.sv, %struct.sv* %220, i32 0, i32 2
  %221 = load i32, i32* %sv_flags280, align 4
  %and281 = and i32 %221, 16384
  %tobool282 = icmp ne i32 %and281, 0
  br i1 %tobool282, label %if.then.283, label %if.end.285

if.then.283:                                      ; preds = %cond.end.277
  %222 = load %struct.sv*, %struct.sv** %targ, align 8
  %call284 = call i32 @Perl_mg_set(%struct.sv* %222)
  br label %if.end.285

if.end.285:                                       ; preds = %if.then.283, %cond.end.277
  %223 = load %struct.sv*, %struct.sv** %targ, align 8
  %224 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %223, %struct.sv** %224, align 8
  store %struct.sv* %223, %struct.sv** %tmp286
  %225 = load %struct.sv*, %struct.sv** %tmp286
  %226 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %226, %struct.sv*** @PL_stack_sp, align 8
  %227 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next287 = getelementptr inbounds %struct.op, %struct.op* %227, i32 0, i32 0
  %228 = load %struct.op*, %struct.op** %op_next287, align 8
  store %struct.op* %228, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.285, %if.end.265, %if.end.222, %if.end.29
  %229 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %229
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_left_shift() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %right = alloca %struct.sv*, align 8
  %left = alloca %struct.sv*, align 8
  %tmp = alloca %struct.sv*, align 8
  %shift = alloca i64, align 8
  %i = alloca i64, align 8
  %tmp63 = alloca %struct.sv*, align 8
  %u = alloca i64, align 8
  %tmp82 = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 6
  %2 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 64
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load %struct.sv**, %struct.sv*** %sp, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 -1
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %5 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %5, i32 0, i32 3
  %6 = load i64, i64* %op_targ, align 8
  %7 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx1 = getelementptr inbounds %struct.sv*, %struct.sv** %7, i64 %6
  %8 = load %struct.sv*, %struct.sv** %arrayidx1, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.sv* [ %4, %cond.true ], [ %8, %cond.false ]
  store %struct.sv* %cond, %struct.sv** %targ, align 8
  %9 = load i64, i64* @PL_amagic_generation, align 8
  %tobool2 = icmp ne i64 %9, 0
  br i1 %tobool2, label %if.then, label %if.end.31

if.then:                                          ; preds = %cond.end
  %10 = load %struct.sv**, %struct.sv*** %sp, align 8
  %11 = load %struct.sv*, %struct.sv** %10, align 8
  store %struct.sv* %11, %struct.sv** %right, align 8
  %12 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %12, i64 -1
  %13 = load %struct.sv*, %struct.sv** %add.ptr, align 8
  store %struct.sv* %13, %struct.sv** %left, align 8
  %14 = load %struct.sv*, %struct.sv** %left, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %14, i32 0, i32 2
  %15 = load i32, i32* %sv_flags, align 4
  %and3 = and i32 %15, 268435456
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %16 = load %struct.sv*, %struct.sv** %right, align 8
  %sv_flags5 = getelementptr inbounds %struct.sv, %struct.sv* %16, i32 0, i32 2
  %17 = load i32, i32* %sv_flags5, align 4
  %and6 = and i32 %17, 268435456
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %land.lhs.true, label %if.end.30

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %18 = load %struct.sv*, %struct.sv** %left, align 8
  %19 = load %struct.sv*, %struct.sv** %right, align 8
  %20 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags8 = getelementptr inbounds %struct.op, %struct.op* %20, i32 0, i32 6
  %21 = load i8, i8* %op_flags8, align 1
  %conv9 = zext i8 %21 to i32
  %and10 = and i32 %conv9, 64
  %tobool11 = icmp ne i32 %and10, 0
  %cond12 = select i1 %tobool11, i32 4, i32 0
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %18, %struct.sv* %19, i32 18, i32 %cond12)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool13 = icmp ne %struct.sv* %call, null
  br i1 %tobool13, label %if.then.14, label %if.end.30

if.then.14:                                       ; preds = %land.lhs.true
  %22 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %22, %struct.sv*** %sp, align 8
  %23 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %23, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %24 = load %struct.sv*, %struct.sv** %23, align 8
  %25 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags15 = getelementptr inbounds %struct.op, %struct.op* %25, i32 0, i32 6
  %26 = load i8, i8* %op_flags15, align 1
  %conv16 = zext i8 %26 to i32
  %and17 = and i32 %conv16, 64
  %tobool18 = icmp ne i32 %and17, 0
  br i1 %tobool18, label %if.then.23, label %lor.lhs.false.19

lor.lhs.false.19:                                 ; preds = %if.then.14
  %27 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags20 = getelementptr inbounds %struct.sv, %struct.sv* %27, i32 0, i32 2
  %28 = load i32, i32* %sv_flags20, align 4
  %and21 = and i32 %28, 1024
  %tobool22 = icmp ne i32 %and21, 0
  br i1 %tobool22, label %if.then.23, label %if.else

if.then.23:                                       ; preds = %lor.lhs.false.19, %if.then.14
  %29 = load %struct.sv*, %struct.sv** %targ, align 8
  %30 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  call void @Perl_sv_setsv_flags(%struct.sv* %29, %struct.sv* %30, i32 2)
  %31 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags24 = getelementptr inbounds %struct.sv, %struct.sv* %31, i32 0, i32 2
  %32 = load i32, i32* %sv_flags24, align 4
  %and25 = and i32 %32, 16384
  %tobool26 = icmp ne i32 %and25, 0
  br i1 %tobool26, label %if.then.27, label %if.end

if.then.27:                                       ; preds = %if.then.23
  %33 = load %struct.sv*, %struct.sv** %targ, align 8
  %call28 = call i32 @Perl_mg_set(%struct.sv* %33)
  br label %if.end

if.end:                                           ; preds = %if.then.27, %if.then.23
  %34 = load %struct.sv*, %struct.sv** %targ, align 8
  %35 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %34, %struct.sv** %35, align 8
  store %struct.sv* %34, %struct.sv** %tmp
  %36 = load %struct.sv*, %struct.sv** %tmp
  br label %if.end.29

if.else:                                          ; preds = %lor.lhs.false.19
  %37 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %38 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %37, %struct.sv** %38, align 8
  br label %if.end.29

if.end.29:                                        ; preds = %if.else, %if.end
  %39 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %39, %struct.sv*** @PL_stack_sp, align 8
  %40 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %40, i32 0, i32 0
  %41 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %41, %struct.op** %retval
  br label %return

if.end.30:                                        ; preds = %land.lhs.true, %lor.lhs.false
  br label %if.end.31

if.end.31:                                        ; preds = %if.end.30, %cond.end
  %42 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr33 = getelementptr inbounds %struct.sv*, %struct.sv** %42, i32 -1
  store %struct.sv** %incdec.ptr33, %struct.sv*** %sp, align 8
  %43 = load %struct.sv*, %struct.sv** %42, align 8
  store %struct.sv* %43, %struct.sv** @PL_Sv, align 8
  %44 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags34 = getelementptr inbounds %struct.sv, %struct.sv* %44, i32 0, i32 2
  %45 = load i32, i32* %sv_flags34, align 4
  %and35 = and i32 %45, 65536
  %tobool36 = icmp ne i32 %and35, 0
  br i1 %tobool36, label %cond.true.37, label %cond.false.38

cond.true.37:                                     ; preds = %if.end.31
  %46 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %46, i32 0, i32 0
  %47 = load i8*, i8** %sv_any, align 8
  %48 = bitcast i8* %47 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %48, i32 0, i32 3
  %49 = load i64, i64* %xiv_iv, align 8
  br label %cond.end.40

cond.false.38:                                    ; preds = %if.end.31
  %50 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call39 = call i64 @Perl_sv_2iv(%struct.sv* %50)
  br label %cond.end.40

cond.end.40:                                      ; preds = %cond.false.38, %cond.true.37
  %cond41 = phi i64 [ %49, %cond.true.37 ], [ %call39, %cond.false.38 ]
  store i64 %cond41, i64* %shift, align 8
  %51 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %51, i32 0, i32 7
  %52 = load i8, i8* %op_private, align 1
  %conv42 = zext i8 %52 to i32
  %and43 = and i32 %conv42, 1
  %tobool44 = icmp ne i32 %and43, 0
  br i1 %tobool44, label %if.then.45, label %if.else.64

if.then.45:                                       ; preds = %cond.end.40
  %53 = load %struct.sv**, %struct.sv*** %sp, align 8
  %54 = load %struct.sv*, %struct.sv** %53, align 8
  %sv_flags47 = getelementptr inbounds %struct.sv, %struct.sv* %54, i32 0, i32 2
  %55 = load i32, i32* %sv_flags47, align 4
  %and48 = and i32 %55, 65536
  %tobool49 = icmp ne i32 %and48, 0
  br i1 %tobool49, label %cond.true.50, label %cond.false.53

cond.true.50:                                     ; preds = %if.then.45
  %56 = load %struct.sv**, %struct.sv*** %sp, align 8
  %57 = load %struct.sv*, %struct.sv** %56, align 8
  %sv_any51 = getelementptr inbounds %struct.sv, %struct.sv* %57, i32 0, i32 0
  %58 = load i8*, i8** %sv_any51, align 8
  %59 = bitcast i8* %58 to %struct.xpviv*
  %xiv_iv52 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %59, i32 0, i32 3
  %60 = load i64, i64* %xiv_iv52, align 8
  br label %cond.end.55

cond.false.53:                                    ; preds = %if.then.45
  %61 = load %struct.sv**, %struct.sv*** %sp, align 8
  %62 = load %struct.sv*, %struct.sv** %61, align 8
  %call54 = call i64 @Perl_sv_2iv(%struct.sv* %62)
  br label %cond.end.55

cond.end.55:                                      ; preds = %cond.false.53, %cond.true.50
  %cond56 = phi i64 [ %60, %cond.true.50 ], [ %call54, %cond.false.53 ]
  store i64 %cond56, i64* %i, align 8
  %63 = load %struct.sv*, %struct.sv** %targ, align 8
  %64 = load i64, i64* %i, align 8
  %65 = load i64, i64* %shift, align 8
  %shl = shl i64 %64, %65
  call void @Perl_sv_setiv(%struct.sv* %63, i64 %shl)
  %66 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags57 = getelementptr inbounds %struct.sv, %struct.sv* %66, i32 0, i32 2
  %67 = load i32, i32* %sv_flags57, align 4
  %and58 = and i32 %67, 16384
  %tobool59 = icmp ne i32 %and58, 0
  br i1 %tobool59, label %if.then.60, label %if.end.62

if.then.60:                                       ; preds = %cond.end.55
  %68 = load %struct.sv*, %struct.sv** %targ, align 8
  %call61 = call i32 @Perl_mg_set(%struct.sv* %68)
  br label %if.end.62

if.end.62:                                        ; preds = %if.then.60, %cond.end.55
  %69 = load %struct.sv*, %struct.sv** %targ, align 8
  %70 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %69, %struct.sv** %70, align 8
  store %struct.sv* %69, %struct.sv** %tmp63
  %71 = load %struct.sv*, %struct.sv** %tmp63
  br label %if.end.83

if.else.64:                                       ; preds = %cond.end.40
  %72 = load %struct.sv**, %struct.sv*** %sp, align 8
  %73 = load %struct.sv*, %struct.sv** %72, align 8
  %sv_flags66 = getelementptr inbounds %struct.sv, %struct.sv* %73, i32 0, i32 2
  %74 = load i32, i32* %sv_flags66, align 4
  %and67 = and i32 %74, 65536
  %tobool68 = icmp ne i32 %and67, 0
  br i1 %tobool68, label %cond.true.69, label %cond.false.71

cond.true.69:                                     ; preds = %if.else.64
  %75 = load %struct.sv**, %struct.sv*** %sp, align 8
  %76 = load %struct.sv*, %struct.sv** %75, align 8
  %sv_any70 = getelementptr inbounds %struct.sv, %struct.sv* %76, i32 0, i32 0
  %77 = load i8*, i8** %sv_any70, align 8
  %78 = bitcast i8* %77 to %struct.xpvuv*
  %xuv_uv = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %78, i32 0, i32 3
  %79 = load i64, i64* %xuv_uv, align 8
  br label %cond.end.73

cond.false.71:                                    ; preds = %if.else.64
  %80 = load %struct.sv**, %struct.sv*** %sp, align 8
  %81 = load %struct.sv*, %struct.sv** %80, align 8
  %call72 = call i64 @Perl_sv_2uv(%struct.sv* %81)
  br label %cond.end.73

cond.end.73:                                      ; preds = %cond.false.71, %cond.true.69
  %cond74 = phi i64 [ %79, %cond.true.69 ], [ %call72, %cond.false.71 ]
  store i64 %cond74, i64* %u, align 8
  %82 = load %struct.sv*, %struct.sv** %targ, align 8
  %83 = load i64, i64* %u, align 8
  %84 = load i64, i64* %shift, align 8
  %shl75 = shl i64 %83, %84
  call void @Perl_sv_setuv(%struct.sv* %82, i64 %shl75)
  %85 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags76 = getelementptr inbounds %struct.sv, %struct.sv* %85, i32 0, i32 2
  %86 = load i32, i32* %sv_flags76, align 4
  %and77 = and i32 %86, 16384
  %tobool78 = icmp ne i32 %and77, 0
  br i1 %tobool78, label %if.then.79, label %if.end.81

if.then.79:                                       ; preds = %cond.end.73
  %87 = load %struct.sv*, %struct.sv** %targ, align 8
  %call80 = call i32 @Perl_mg_set(%struct.sv* %87)
  br label %if.end.81

if.end.81:                                        ; preds = %if.then.79, %cond.end.73
  %88 = load %struct.sv*, %struct.sv** %targ, align 8
  %89 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %88, %struct.sv** %89, align 8
  store %struct.sv* %88, %struct.sv** %tmp82
  %90 = load %struct.sv*, %struct.sv** %tmp82
  br label %if.end.83

if.end.83:                                        ; preds = %if.end.81, %if.end.62
  %91 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %91, %struct.sv*** @PL_stack_sp, align 8
  %92 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next84 = getelementptr inbounds %struct.op, %struct.op* %92, i32 0, i32 0
  %93 = load %struct.op*, %struct.op** %op_next84, align 8
  store %struct.op* %93, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.83, %if.end.29
  %94 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %94
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_right_shift() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %right = alloca %struct.sv*, align 8
  %left = alloca %struct.sv*, align 8
  %tmp = alloca %struct.sv*, align 8
  %shift = alloca i64, align 8
  %i = alloca i64, align 8
  %tmp63 = alloca %struct.sv*, align 8
  %u = alloca i64, align 8
  %tmp82 = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 6
  %2 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 64
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load %struct.sv**, %struct.sv*** %sp, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 -1
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %5 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %5, i32 0, i32 3
  %6 = load i64, i64* %op_targ, align 8
  %7 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx1 = getelementptr inbounds %struct.sv*, %struct.sv** %7, i64 %6
  %8 = load %struct.sv*, %struct.sv** %arrayidx1, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.sv* [ %4, %cond.true ], [ %8, %cond.false ]
  store %struct.sv* %cond, %struct.sv** %targ, align 8
  %9 = load i64, i64* @PL_amagic_generation, align 8
  %tobool2 = icmp ne i64 %9, 0
  br i1 %tobool2, label %if.then, label %if.end.31

if.then:                                          ; preds = %cond.end
  %10 = load %struct.sv**, %struct.sv*** %sp, align 8
  %11 = load %struct.sv*, %struct.sv** %10, align 8
  store %struct.sv* %11, %struct.sv** %right, align 8
  %12 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %12, i64 -1
  %13 = load %struct.sv*, %struct.sv** %add.ptr, align 8
  store %struct.sv* %13, %struct.sv** %left, align 8
  %14 = load %struct.sv*, %struct.sv** %left, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %14, i32 0, i32 2
  %15 = load i32, i32* %sv_flags, align 4
  %and3 = and i32 %15, 268435456
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %16 = load %struct.sv*, %struct.sv** %right, align 8
  %sv_flags5 = getelementptr inbounds %struct.sv, %struct.sv* %16, i32 0, i32 2
  %17 = load i32, i32* %sv_flags5, align 4
  %and6 = and i32 %17, 268435456
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %land.lhs.true, label %if.end.30

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %18 = load %struct.sv*, %struct.sv** %left, align 8
  %19 = load %struct.sv*, %struct.sv** %right, align 8
  %20 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags8 = getelementptr inbounds %struct.op, %struct.op* %20, i32 0, i32 6
  %21 = load i8, i8* %op_flags8, align 1
  %conv9 = zext i8 %21 to i32
  %and10 = and i32 %conv9, 64
  %tobool11 = icmp ne i32 %and10, 0
  %cond12 = select i1 %tobool11, i32 4, i32 0
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %18, %struct.sv* %19, i32 20, i32 %cond12)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool13 = icmp ne %struct.sv* %call, null
  br i1 %tobool13, label %if.then.14, label %if.end.30

if.then.14:                                       ; preds = %land.lhs.true
  %22 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %22, %struct.sv*** %sp, align 8
  %23 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %23, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %24 = load %struct.sv*, %struct.sv** %23, align 8
  %25 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags15 = getelementptr inbounds %struct.op, %struct.op* %25, i32 0, i32 6
  %26 = load i8, i8* %op_flags15, align 1
  %conv16 = zext i8 %26 to i32
  %and17 = and i32 %conv16, 64
  %tobool18 = icmp ne i32 %and17, 0
  br i1 %tobool18, label %if.then.23, label %lor.lhs.false.19

lor.lhs.false.19:                                 ; preds = %if.then.14
  %27 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags20 = getelementptr inbounds %struct.sv, %struct.sv* %27, i32 0, i32 2
  %28 = load i32, i32* %sv_flags20, align 4
  %and21 = and i32 %28, 1024
  %tobool22 = icmp ne i32 %and21, 0
  br i1 %tobool22, label %if.then.23, label %if.else

if.then.23:                                       ; preds = %lor.lhs.false.19, %if.then.14
  %29 = load %struct.sv*, %struct.sv** %targ, align 8
  %30 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  call void @Perl_sv_setsv_flags(%struct.sv* %29, %struct.sv* %30, i32 2)
  %31 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags24 = getelementptr inbounds %struct.sv, %struct.sv* %31, i32 0, i32 2
  %32 = load i32, i32* %sv_flags24, align 4
  %and25 = and i32 %32, 16384
  %tobool26 = icmp ne i32 %and25, 0
  br i1 %tobool26, label %if.then.27, label %if.end

if.then.27:                                       ; preds = %if.then.23
  %33 = load %struct.sv*, %struct.sv** %targ, align 8
  %call28 = call i32 @Perl_mg_set(%struct.sv* %33)
  br label %if.end

if.end:                                           ; preds = %if.then.27, %if.then.23
  %34 = load %struct.sv*, %struct.sv** %targ, align 8
  %35 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %34, %struct.sv** %35, align 8
  store %struct.sv* %34, %struct.sv** %tmp
  %36 = load %struct.sv*, %struct.sv** %tmp
  br label %if.end.29

if.else:                                          ; preds = %lor.lhs.false.19
  %37 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %38 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %37, %struct.sv** %38, align 8
  br label %if.end.29

if.end.29:                                        ; preds = %if.else, %if.end
  %39 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %39, %struct.sv*** @PL_stack_sp, align 8
  %40 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %40, i32 0, i32 0
  %41 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %41, %struct.op** %retval
  br label %return

if.end.30:                                        ; preds = %land.lhs.true, %lor.lhs.false
  br label %if.end.31

if.end.31:                                        ; preds = %if.end.30, %cond.end
  %42 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr33 = getelementptr inbounds %struct.sv*, %struct.sv** %42, i32 -1
  store %struct.sv** %incdec.ptr33, %struct.sv*** %sp, align 8
  %43 = load %struct.sv*, %struct.sv** %42, align 8
  store %struct.sv* %43, %struct.sv** @PL_Sv, align 8
  %44 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags34 = getelementptr inbounds %struct.sv, %struct.sv* %44, i32 0, i32 2
  %45 = load i32, i32* %sv_flags34, align 4
  %and35 = and i32 %45, 65536
  %tobool36 = icmp ne i32 %and35, 0
  br i1 %tobool36, label %cond.true.37, label %cond.false.38

cond.true.37:                                     ; preds = %if.end.31
  %46 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %46, i32 0, i32 0
  %47 = load i8*, i8** %sv_any, align 8
  %48 = bitcast i8* %47 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %48, i32 0, i32 3
  %49 = load i64, i64* %xiv_iv, align 8
  br label %cond.end.40

cond.false.38:                                    ; preds = %if.end.31
  %50 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call39 = call i64 @Perl_sv_2iv(%struct.sv* %50)
  br label %cond.end.40

cond.end.40:                                      ; preds = %cond.false.38, %cond.true.37
  %cond41 = phi i64 [ %49, %cond.true.37 ], [ %call39, %cond.false.38 ]
  store i64 %cond41, i64* %shift, align 8
  %51 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %51, i32 0, i32 7
  %52 = load i8, i8* %op_private, align 1
  %conv42 = zext i8 %52 to i32
  %and43 = and i32 %conv42, 1
  %tobool44 = icmp ne i32 %and43, 0
  br i1 %tobool44, label %if.then.45, label %if.else.64

if.then.45:                                       ; preds = %cond.end.40
  %53 = load %struct.sv**, %struct.sv*** %sp, align 8
  %54 = load %struct.sv*, %struct.sv** %53, align 8
  %sv_flags47 = getelementptr inbounds %struct.sv, %struct.sv* %54, i32 0, i32 2
  %55 = load i32, i32* %sv_flags47, align 4
  %and48 = and i32 %55, 65536
  %tobool49 = icmp ne i32 %and48, 0
  br i1 %tobool49, label %cond.true.50, label %cond.false.53

cond.true.50:                                     ; preds = %if.then.45
  %56 = load %struct.sv**, %struct.sv*** %sp, align 8
  %57 = load %struct.sv*, %struct.sv** %56, align 8
  %sv_any51 = getelementptr inbounds %struct.sv, %struct.sv* %57, i32 0, i32 0
  %58 = load i8*, i8** %sv_any51, align 8
  %59 = bitcast i8* %58 to %struct.xpviv*
  %xiv_iv52 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %59, i32 0, i32 3
  %60 = load i64, i64* %xiv_iv52, align 8
  br label %cond.end.55

cond.false.53:                                    ; preds = %if.then.45
  %61 = load %struct.sv**, %struct.sv*** %sp, align 8
  %62 = load %struct.sv*, %struct.sv** %61, align 8
  %call54 = call i64 @Perl_sv_2iv(%struct.sv* %62)
  br label %cond.end.55

cond.end.55:                                      ; preds = %cond.false.53, %cond.true.50
  %cond56 = phi i64 [ %60, %cond.true.50 ], [ %call54, %cond.false.53 ]
  store i64 %cond56, i64* %i, align 8
  %63 = load %struct.sv*, %struct.sv** %targ, align 8
  %64 = load i64, i64* %i, align 8
  %65 = load i64, i64* %shift, align 8
  %shr = ashr i64 %64, %65
  call void @Perl_sv_setiv(%struct.sv* %63, i64 %shr)
  %66 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags57 = getelementptr inbounds %struct.sv, %struct.sv* %66, i32 0, i32 2
  %67 = load i32, i32* %sv_flags57, align 4
  %and58 = and i32 %67, 16384
  %tobool59 = icmp ne i32 %and58, 0
  br i1 %tobool59, label %if.then.60, label %if.end.62

if.then.60:                                       ; preds = %cond.end.55
  %68 = load %struct.sv*, %struct.sv** %targ, align 8
  %call61 = call i32 @Perl_mg_set(%struct.sv* %68)
  br label %if.end.62

if.end.62:                                        ; preds = %if.then.60, %cond.end.55
  %69 = load %struct.sv*, %struct.sv** %targ, align 8
  %70 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %69, %struct.sv** %70, align 8
  store %struct.sv* %69, %struct.sv** %tmp63
  %71 = load %struct.sv*, %struct.sv** %tmp63
  br label %if.end.83

if.else.64:                                       ; preds = %cond.end.40
  %72 = load %struct.sv**, %struct.sv*** %sp, align 8
  %73 = load %struct.sv*, %struct.sv** %72, align 8
  %sv_flags66 = getelementptr inbounds %struct.sv, %struct.sv* %73, i32 0, i32 2
  %74 = load i32, i32* %sv_flags66, align 4
  %and67 = and i32 %74, 65536
  %tobool68 = icmp ne i32 %and67, 0
  br i1 %tobool68, label %cond.true.69, label %cond.false.71

cond.true.69:                                     ; preds = %if.else.64
  %75 = load %struct.sv**, %struct.sv*** %sp, align 8
  %76 = load %struct.sv*, %struct.sv** %75, align 8
  %sv_any70 = getelementptr inbounds %struct.sv, %struct.sv* %76, i32 0, i32 0
  %77 = load i8*, i8** %sv_any70, align 8
  %78 = bitcast i8* %77 to %struct.xpvuv*
  %xuv_uv = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %78, i32 0, i32 3
  %79 = load i64, i64* %xuv_uv, align 8
  br label %cond.end.73

cond.false.71:                                    ; preds = %if.else.64
  %80 = load %struct.sv**, %struct.sv*** %sp, align 8
  %81 = load %struct.sv*, %struct.sv** %80, align 8
  %call72 = call i64 @Perl_sv_2uv(%struct.sv* %81)
  br label %cond.end.73

cond.end.73:                                      ; preds = %cond.false.71, %cond.true.69
  %cond74 = phi i64 [ %79, %cond.true.69 ], [ %call72, %cond.false.71 ]
  store i64 %cond74, i64* %u, align 8
  %82 = load %struct.sv*, %struct.sv** %targ, align 8
  %83 = load i64, i64* %u, align 8
  %84 = load i64, i64* %shift, align 8
  %shr75 = lshr i64 %83, %84
  call void @Perl_sv_setuv(%struct.sv* %82, i64 %shr75)
  %85 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags76 = getelementptr inbounds %struct.sv, %struct.sv* %85, i32 0, i32 2
  %86 = load i32, i32* %sv_flags76, align 4
  %and77 = and i32 %86, 16384
  %tobool78 = icmp ne i32 %and77, 0
  br i1 %tobool78, label %if.then.79, label %if.end.81

if.then.79:                                       ; preds = %cond.end.73
  %87 = load %struct.sv*, %struct.sv** %targ, align 8
  %call80 = call i32 @Perl_mg_set(%struct.sv* %87)
  br label %if.end.81

if.end.81:                                        ; preds = %if.then.79, %cond.end.73
  %88 = load %struct.sv*, %struct.sv** %targ, align 8
  %89 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %88, %struct.sv** %89, align 8
  store %struct.sv* %88, %struct.sv** %tmp82
  %90 = load %struct.sv*, %struct.sv** %tmp82
  br label %if.end.83

if.end.83:                                        ; preds = %if.end.81, %if.end.62
  %91 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %91, %struct.sv*** @PL_stack_sp, align 8
  %92 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next84 = getelementptr inbounds %struct.op, %struct.op* %92, i32 0, i32 0
  %93 = load %struct.op*, %struct.op** %op_next84, align 8
  store %struct.op* %93, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.83, %if.end.29
  %94 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %94
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_lt() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %right = alloca %struct.sv*, align 8
  %left = alloca %struct.sv*, align 8
  %auvok = alloca i8, align 1
  %buvok = alloca i8, align 1
  %aiv = alloca i64, align 8
  %biv = alloca i64, align 8
  %auv = alloca i64, align 8
  %buv = alloca i64, align 8
  %auv105 = alloca i64, align 8
  %biv106 = alloca i64, align 8
  %aiv122 = alloca i64, align 8
  %buv123 = alloca i64, align 8
  %value = alloca double, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load i64, i64* @PL_amagic_generation, align 8
  %tobool = icmp ne i64 %1, 0
  br i1 %tobool, label %if.then, label %if.end.7

if.then:                                          ; preds = %entry
  %2 = load %struct.sv**, %struct.sv*** %sp, align 8
  %3 = load %struct.sv*, %struct.sv** %2, align 8
  store %struct.sv* %3, %struct.sv** %right, align 8
  %4 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %4, i64 -1
  %5 = load %struct.sv*, %struct.sv** %add.ptr, align 8
  store %struct.sv* %5, %struct.sv** %left, align 8
  %6 = load %struct.sv*, %struct.sv** %left, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %6, i32 0, i32 2
  %7 = load i32, i32* %sv_flags, align 4
  %and = and i32 %7, 268435456
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %8 = load %struct.sv*, %struct.sv** %right, align 8
  %sv_flags2 = getelementptr inbounds %struct.sv, %struct.sv* %8, i32 0, i32 2
  %9 = load i32, i32* %sv_flags2, align 4
  %and3 = and i32 %9, 268435456
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %10 = load %struct.sv*, %struct.sv** %left, align 8
  %11 = load %struct.sv*, %struct.sv** %right, align 8
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %10, %struct.sv* %11, i32 28, i32 0)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool5 = icmp ne %struct.sv* %call, null
  br i1 %tobool5, label %if.then.6, label %if.end

if.then.6:                                        ; preds = %land.lhs.true
  %12 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %12, %struct.sv*** %sp, align 8
  %13 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %13, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %14 = load %struct.sv*, %struct.sv** %13, align 8
  %15 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %16 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %15, %struct.sv** %16, align 8
  %17 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %17, %struct.sv*** @PL_stack_sp, align 8
  %18 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %18, i32 0, i32 0
  %19 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %19, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %land.lhs.true, %lor.lhs.false
  br label %if.end.7

if.end.7:                                         ; preds = %if.end, %entry
  %20 = load %struct.sv**, %struct.sv*** %sp, align 8
  %21 = load %struct.sv*, %struct.sv** %20, align 8
  %sv_flags8 = getelementptr inbounds %struct.sv, %struct.sv* %21, i32 0, i32 2
  %22 = load i32, i32* %sv_flags8, align 4
  %and9 = and i32 %22, 16777216
  %tobool10 = icmp ne i32 %and9, 0
  br i1 %tobool10, label %if.end.24, label %land.lhs.true.11

land.lhs.true.11:                                 ; preds = %if.end.7
  %23 = load %struct.sv**, %struct.sv*** %sp, align 8
  %24 = load %struct.sv*, %struct.sv** %23, align 8
  %sv_flags12 = getelementptr inbounds %struct.sv, %struct.sv* %24, i32 0, i32 2
  %25 = load i32, i32* %sv_flags12, align 4
  %and13 = and i32 %25, 131072
  %tobool14 = icmp ne i32 %and13, 0
  br i1 %tobool14, label %if.then.19, label %lor.lhs.false.15

lor.lhs.false.15:                                 ; preds = %land.lhs.true.11
  %26 = load %struct.sv**, %struct.sv*** %sp, align 8
  %27 = load %struct.sv*, %struct.sv** %26, align 8
  %sv_flags16 = getelementptr inbounds %struct.sv, %struct.sv* %27, i32 0, i32 2
  %28 = load i32, i32* %sv_flags16, align 4
  %and17 = and i32 %28, 262144
  %tobool18 = icmp ne i32 %and17, 0
  br i1 %tobool18, label %if.then.19, label %if.end.24

if.then.19:                                       ; preds = %lor.lhs.false.15, %land.lhs.true.11
  %29 = load %struct.sv**, %struct.sv*** %sp, align 8
  %30 = load %struct.sv*, %struct.sv** %29, align 8
  %sv_flags20 = getelementptr inbounds %struct.sv, %struct.sv* %30, i32 0, i32 2
  %31 = load i32, i32* %sv_flags20, align 4
  %and21 = and i32 %31, 65536
  %tobool22 = icmp ne i32 %and21, 0
  br i1 %tobool22, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.19
  %32 = load %struct.sv**, %struct.sv*** %sp, align 8
  %33 = load %struct.sv*, %struct.sv** %32, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %33, i32 0, i32 0
  %34 = load i8*, i8** %sv_any, align 8
  %35 = bitcast i8* %34 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %35, i32 0, i32 3
  %36 = load i64, i64* %xiv_iv, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then.19
  %37 = load %struct.sv**, %struct.sv*** %sp, align 8
  %38 = load %struct.sv*, %struct.sv** %37, align 8
  %call23 = call i64 @Perl_sv_2iv(%struct.sv* %38)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %36, %cond.true ], [ %call23, %cond.false ]
  br label %if.end.24

if.end.24:                                        ; preds = %cond.end, %lor.lhs.false.15, %if.end.7
  %39 = load %struct.sv**, %struct.sv*** %sp, align 8
  %40 = load %struct.sv*, %struct.sv** %39, align 8
  %sv_flags25 = getelementptr inbounds %struct.sv, %struct.sv* %40, i32 0, i32 2
  %41 = load i32, i32* %sv_flags25, align 4
  %and26 = and i32 %41, 65536
  %tobool27 = icmp ne i32 %and26, 0
  br i1 %tobool27, label %if.then.28, label %if.else

if.then.28:                                       ; preds = %if.end.24
  %42 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr29 = getelementptr inbounds %struct.sv*, %struct.sv** %42, i64 -1
  %43 = load %struct.sv*, %struct.sv** %add.ptr29, align 8
  %sv_flags30 = getelementptr inbounds %struct.sv, %struct.sv* %43, i32 0, i32 2
  %44 = load i32, i32* %sv_flags30, align 4
  %and31 = and i32 %44, 16777216
  %tobool32 = icmp ne i32 %and31, 0
  br i1 %tobool32, label %if.end.57, label %land.lhs.true.33

land.lhs.true.33:                                 ; preds = %if.then.28
  %45 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr34 = getelementptr inbounds %struct.sv*, %struct.sv** %45, i64 -1
  %46 = load %struct.sv*, %struct.sv** %add.ptr34, align 8
  %sv_flags35 = getelementptr inbounds %struct.sv, %struct.sv* %46, i32 0, i32 2
  %47 = load i32, i32* %sv_flags35, align 4
  %and36 = and i32 %47, 131072
  %tobool37 = icmp ne i32 %and36, 0
  br i1 %tobool37, label %if.then.43, label %lor.lhs.false.38

lor.lhs.false.38:                                 ; preds = %land.lhs.true.33
  %48 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr39 = getelementptr inbounds %struct.sv*, %struct.sv** %48, i64 -1
  %49 = load %struct.sv*, %struct.sv** %add.ptr39, align 8
  %sv_flags40 = getelementptr inbounds %struct.sv, %struct.sv* %49, i32 0, i32 2
  %50 = load i32, i32* %sv_flags40, align 4
  %and41 = and i32 %50, 262144
  %tobool42 = icmp ne i32 %and41, 0
  br i1 %tobool42, label %if.then.43, label %if.end.57

if.then.43:                                       ; preds = %lor.lhs.false.38, %land.lhs.true.33
  %51 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr44 = getelementptr inbounds %struct.sv*, %struct.sv** %51, i64 -1
  %52 = load %struct.sv*, %struct.sv** %add.ptr44, align 8
  %sv_flags45 = getelementptr inbounds %struct.sv, %struct.sv* %52, i32 0, i32 2
  %53 = load i32, i32* %sv_flags45, align 4
  %and46 = and i32 %53, 65536
  %tobool47 = icmp ne i32 %and46, 0
  br i1 %tobool47, label %cond.true.48, label %cond.false.52

cond.true.48:                                     ; preds = %if.then.43
  %54 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr49 = getelementptr inbounds %struct.sv*, %struct.sv** %54, i64 -1
  %55 = load %struct.sv*, %struct.sv** %add.ptr49, align 8
  %sv_any50 = getelementptr inbounds %struct.sv, %struct.sv* %55, i32 0, i32 0
  %56 = load i8*, i8** %sv_any50, align 8
  %57 = bitcast i8* %56 to %struct.xpviv*
  %xiv_iv51 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %57, i32 0, i32 3
  %58 = load i64, i64* %xiv_iv51, align 8
  br label %cond.end.55

cond.false.52:                                    ; preds = %if.then.43
  %59 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr53 = getelementptr inbounds %struct.sv*, %struct.sv** %59, i64 -1
  %60 = load %struct.sv*, %struct.sv** %add.ptr53, align 8
  %call54 = call i64 @Perl_sv_2iv(%struct.sv* %60)
  br label %cond.end.55

cond.end.55:                                      ; preds = %cond.false.52, %cond.true.48
  %cond56 = phi i64 [ %58, %cond.true.48 ], [ %call54, %cond.false.52 ]
  br label %if.end.57

if.end.57:                                        ; preds = %cond.end.55, %lor.lhs.false.38, %if.then.28
  %61 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr58 = getelementptr inbounds %struct.sv*, %struct.sv** %61, i64 -1
  %62 = load %struct.sv*, %struct.sv** %add.ptr58, align 8
  %sv_flags59 = getelementptr inbounds %struct.sv, %struct.sv* %62, i32 0, i32 2
  %63 = load i32, i32* %sv_flags59, align 4
  %and60 = and i32 %63, 65536
  %tobool61 = icmp ne i32 %and60, 0
  br i1 %tobool61, label %if.then.62, label %if.end.140

if.then.62:                                       ; preds = %if.end.57
  %64 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr63 = getelementptr inbounds %struct.sv*, %struct.sv** %64, i64 -1
  %65 = load %struct.sv*, %struct.sv** %add.ptr63, align 8
  %sv_flags64 = getelementptr inbounds %struct.sv, %struct.sv* %65, i32 0, i32 2
  %66 = load i32, i32* %sv_flags64, align 4
  %and65 = and i32 %66, -2147418112
  %cmp = icmp eq i32 %and65, -2147418112
  %conv = zext i1 %cmp to i32
  %conv66 = trunc i32 %conv to i8
  store i8 %conv66, i8* %auvok, align 1
  %67 = load %struct.sv**, %struct.sv*** %sp, align 8
  %68 = load %struct.sv*, %struct.sv** %67, align 8
  %sv_flags67 = getelementptr inbounds %struct.sv, %struct.sv* %68, i32 0, i32 2
  %69 = load i32, i32* %sv_flags67, align 4
  %and68 = and i32 %69, -2147418112
  %cmp69 = icmp eq i32 %and68, -2147418112
  %conv70 = zext i1 %cmp69 to i32
  %conv71 = trunc i32 %conv70 to i8
  store i8 %conv71, i8* %buvok, align 1
  %70 = load i8, i8* %auvok, align 1
  %tobool72 = icmp ne i8 %70, 0
  br i1 %tobool72, label %if.end.86, label %land.lhs.true.73

land.lhs.true.73:                                 ; preds = %if.then.62
  %71 = load i8, i8* %buvok, align 1
  %tobool74 = icmp ne i8 %71, 0
  br i1 %tobool74, label %if.end.86, label %if.then.75

if.then.75:                                       ; preds = %land.lhs.true.73
  %72 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr76 = getelementptr inbounds %struct.sv*, %struct.sv** %72, i64 -1
  %73 = load %struct.sv*, %struct.sv** %add.ptr76, align 8
  %sv_any77 = getelementptr inbounds %struct.sv, %struct.sv* %73, i32 0, i32 0
  %74 = load i8*, i8** %sv_any77, align 8
  %75 = bitcast i8* %74 to %struct.xpviv*
  %xiv_iv78 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %75, i32 0, i32 3
  %76 = load i64, i64* %xiv_iv78, align 8
  store i64 %76, i64* %aiv, align 8
  %77 = load %struct.sv**, %struct.sv*** %sp, align 8
  %78 = load %struct.sv*, %struct.sv** %77, align 8
  %sv_any79 = getelementptr inbounds %struct.sv, %struct.sv* %78, i32 0, i32 0
  %79 = load i8*, i8** %sv_any79, align 8
  %80 = bitcast i8* %79 to %struct.xpviv*
  %xiv_iv80 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %80, i32 0, i32 3
  %81 = load i64, i64* %xiv_iv80, align 8
  store i64 %81, i64* %biv, align 8
  %82 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr81 = getelementptr inbounds %struct.sv*, %struct.sv** %82, i32 -1
  store %struct.sv** %incdec.ptr81, %struct.sv*** %sp, align 8
  %83 = load i64, i64* %aiv, align 8
  %84 = load i64, i64* %biv, align 8
  %cmp82 = icmp slt i64 %83, %84
  %cond84 = select i1 %cmp82, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  %85 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %cond84, %struct.sv** %85, align 8
  %86 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %86, %struct.sv*** @PL_stack_sp, align 8
  %87 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next85 = getelementptr inbounds %struct.op, %struct.op* %87, i32 0, i32 0
  %88 = load %struct.op*, %struct.op** %op_next85, align 8
  store %struct.op* %88, %struct.op** %retval
  br label %return

if.end.86:                                        ; preds = %land.lhs.true.73, %if.then.62
  %89 = load i8, i8* %auvok, align 1
  %conv87 = sext i8 %89 to i32
  %tobool88 = icmp ne i32 %conv87, 0
  br i1 %tobool88, label %land.lhs.true.89, label %if.end.102

land.lhs.true.89:                                 ; preds = %if.end.86
  %90 = load i8, i8* %buvok, align 1
  %conv90 = sext i8 %90 to i32
  %tobool91 = icmp ne i32 %conv90, 0
  br i1 %tobool91, label %if.then.92, label %if.end.102

if.then.92:                                       ; preds = %land.lhs.true.89
  %91 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr93 = getelementptr inbounds %struct.sv*, %struct.sv** %91, i64 -1
  %92 = load %struct.sv*, %struct.sv** %add.ptr93, align 8
  %sv_any94 = getelementptr inbounds %struct.sv, %struct.sv* %92, i32 0, i32 0
  %93 = load i8*, i8** %sv_any94, align 8
  %94 = bitcast i8* %93 to %struct.xpvuv*
  %xuv_uv = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %94, i32 0, i32 3
  %95 = load i64, i64* %xuv_uv, align 8
  store i64 %95, i64* %auv, align 8
  %96 = load %struct.sv**, %struct.sv*** %sp, align 8
  %97 = load %struct.sv*, %struct.sv** %96, align 8
  %sv_any95 = getelementptr inbounds %struct.sv, %struct.sv* %97, i32 0, i32 0
  %98 = load i8*, i8** %sv_any95, align 8
  %99 = bitcast i8* %98 to %struct.xpvuv*
  %xuv_uv96 = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %99, i32 0, i32 3
  %100 = load i64, i64* %xuv_uv96, align 8
  store i64 %100, i64* %buv, align 8
  %101 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr97 = getelementptr inbounds %struct.sv*, %struct.sv** %101, i32 -1
  store %struct.sv** %incdec.ptr97, %struct.sv*** %sp, align 8
  %102 = load i64, i64* %auv, align 8
  %103 = load i64, i64* %buv, align 8
  %cmp98 = icmp ult i64 %102, %103
  %cond100 = select i1 %cmp98, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  %104 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %cond100, %struct.sv** %104, align 8
  %105 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %105, %struct.sv*** @PL_stack_sp, align 8
  %106 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next101 = getelementptr inbounds %struct.op, %struct.op* %106, i32 0, i32 0
  %107 = load %struct.op*, %struct.op** %op_next101, align 8
  store %struct.op* %107, %struct.op** %retval
  br label %return

if.end.102:                                       ; preds = %land.lhs.true.89, %if.end.86
  %108 = load i8, i8* %auvok, align 1
  %tobool103 = icmp ne i8 %108, 0
  br i1 %tobool103, label %if.then.104, label %if.end.121

if.then.104:                                      ; preds = %if.end.102
  %109 = load %struct.sv**, %struct.sv*** %sp, align 8
  %110 = load %struct.sv*, %struct.sv** %109, align 8
  %sv_any107 = getelementptr inbounds %struct.sv, %struct.sv* %110, i32 0, i32 0
  %111 = load i8*, i8** %sv_any107, align 8
  %112 = bitcast i8* %111 to %struct.xpviv*
  %xiv_iv108 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %112, i32 0, i32 3
  %113 = load i64, i64* %xiv_iv108, align 8
  store i64 %113, i64* %biv106, align 8
  %114 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr109 = getelementptr inbounds %struct.sv*, %struct.sv** %114, i32 -1
  store %struct.sv** %incdec.ptr109, %struct.sv*** %sp, align 8
  %115 = load i64, i64* %biv106, align 8
  %cmp110 = icmp slt i64 %115, 0
  br i1 %cmp110, label %if.then.112, label %if.end.114

if.then.112:                                      ; preds = %if.then.104
  %116 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* @PL_sv_no, %struct.sv** %116, align 8
  %117 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %117, %struct.sv*** @PL_stack_sp, align 8
  %118 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next113 = getelementptr inbounds %struct.op, %struct.op* %118, i32 0, i32 0
  %119 = load %struct.op*, %struct.op** %op_next113, align 8
  store %struct.op* %119, %struct.op** %retval
  br label %return

if.end.114:                                       ; preds = %if.then.104
  %120 = load %struct.sv**, %struct.sv*** %sp, align 8
  %121 = load %struct.sv*, %struct.sv** %120, align 8
  %sv_any115 = getelementptr inbounds %struct.sv, %struct.sv* %121, i32 0, i32 0
  %122 = load i8*, i8** %sv_any115, align 8
  %123 = bitcast i8* %122 to %struct.xpvuv*
  %xuv_uv116 = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %123, i32 0, i32 3
  %124 = load i64, i64* %xuv_uv116, align 8
  store i64 %124, i64* %auv105, align 8
  %125 = load i64, i64* %auv105, align 8
  %126 = load i64, i64* %biv106, align 8
  %cmp117 = icmp ult i64 %125, %126
  %cond119 = select i1 %cmp117, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  %127 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %cond119, %struct.sv** %127, align 8
  %128 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %128, %struct.sv*** @PL_stack_sp, align 8
  %129 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next120 = getelementptr inbounds %struct.op, %struct.op* %129, i32 0, i32 0
  %130 = load %struct.op*, %struct.op** %op_next120, align 8
  store %struct.op* %130, %struct.op** %retval
  br label %return

if.end.121:                                       ; preds = %if.end.102
  %131 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr124 = getelementptr inbounds %struct.sv*, %struct.sv** %131, i64 -1
  %132 = load %struct.sv*, %struct.sv** %add.ptr124, align 8
  %sv_any125 = getelementptr inbounds %struct.sv, %struct.sv* %132, i32 0, i32 0
  %133 = load i8*, i8** %sv_any125, align 8
  %134 = bitcast i8* %133 to %struct.xpviv*
  %xiv_iv126 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %134, i32 0, i32 3
  %135 = load i64, i64* %xiv_iv126, align 8
  store i64 %135, i64* %aiv122, align 8
  %136 = load i64, i64* %aiv122, align 8
  %cmp127 = icmp slt i64 %136, 0
  br i1 %cmp127, label %if.then.129, label %if.end.132

if.then.129:                                      ; preds = %if.end.121
  %137 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr130 = getelementptr inbounds %struct.sv*, %struct.sv** %137, i32 -1
  store %struct.sv** %incdec.ptr130, %struct.sv*** %sp, align 8
  %138 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* @PL_sv_yes, %struct.sv** %138, align 8
  %139 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %139, %struct.sv*** @PL_stack_sp, align 8
  %140 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next131 = getelementptr inbounds %struct.op, %struct.op* %140, i32 0, i32 0
  %141 = load %struct.op*, %struct.op** %op_next131, align 8
  store %struct.op* %141, %struct.op** %retval
  br label %return

if.end.132:                                       ; preds = %if.end.121
  %142 = load %struct.sv**, %struct.sv*** %sp, align 8
  %143 = load %struct.sv*, %struct.sv** %142, align 8
  %sv_any133 = getelementptr inbounds %struct.sv, %struct.sv* %143, i32 0, i32 0
  %144 = load i8*, i8** %sv_any133, align 8
  %145 = bitcast i8* %144 to %struct.xpvuv*
  %xuv_uv134 = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %145, i32 0, i32 3
  %146 = load i64, i64* %xuv_uv134, align 8
  store i64 %146, i64* %buv123, align 8
  %147 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr135 = getelementptr inbounds %struct.sv*, %struct.sv** %147, i32 -1
  store %struct.sv** %incdec.ptr135, %struct.sv*** %sp, align 8
  %148 = load i64, i64* %aiv122, align 8
  %149 = load i64, i64* %buv123, align 8
  %cmp136 = icmp ult i64 %148, %149
  %cond138 = select i1 %cmp136, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  %150 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %cond138, %struct.sv** %150, align 8
  %151 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %151, %struct.sv*** @PL_stack_sp, align 8
  %152 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next139 = getelementptr inbounds %struct.op, %struct.op* %152, i32 0, i32 0
  %153 = load %struct.op*, %struct.op** %op_next139, align 8
  store %struct.op* %153, %struct.op** %retval
  br label %return

if.end.140:                                       ; preds = %if.end.57
  br label %if.end.169

if.else:                                          ; preds = %if.end.24
  %154 = load %struct.sv**, %struct.sv*** %sp, align 8
  %155 = load %struct.sv*, %struct.sv** %154, align 8
  %sv_flags141 = getelementptr inbounds %struct.sv, %struct.sv* %155, i32 0, i32 2
  %156 = load i32, i32* %sv_flags141, align 4
  %and142 = and i32 %156, 524288
  %tobool143 = icmp ne i32 %and142, 0
  br i1 %tobool143, label %land.lhs.true.144, label %if.end.168

land.lhs.true.144:                                ; preds = %if.else
  %157 = load %struct.sv**, %struct.sv*** %sp, align 8
  %158 = load %struct.sv*, %struct.sv** %157, align 8
  %sv_flags145 = getelementptr inbounds %struct.sv, %struct.sv* %158, i32 0, i32 2
  %159 = load i32, i32* %sv_flags145, align 4
  %and146 = and i32 %159, 268435456
  %tobool147 = icmp ne i32 %and146, 0
  br i1 %tobool147, label %if.end.168, label %land.lhs.true.148

land.lhs.true.148:                                ; preds = %land.lhs.true.144
  %160 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr149 = getelementptr inbounds %struct.sv*, %struct.sv** %160, i64 -1
  %161 = load %struct.sv*, %struct.sv** %add.ptr149, align 8
  %sv_flags150 = getelementptr inbounds %struct.sv, %struct.sv* %161, i32 0, i32 2
  %162 = load i32, i32* %sv_flags150, align 4
  %and151 = and i32 %162, 524288
  %tobool152 = icmp ne i32 %and151, 0
  br i1 %tobool152, label %land.lhs.true.153, label %if.end.168

land.lhs.true.153:                                ; preds = %land.lhs.true.148
  %163 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr154 = getelementptr inbounds %struct.sv*, %struct.sv** %163, i64 -1
  %164 = load %struct.sv*, %struct.sv** %add.ptr154, align 8
  %sv_flags155 = getelementptr inbounds %struct.sv, %struct.sv* %164, i32 0, i32 2
  %165 = load i32, i32* %sv_flags155, align 4
  %and156 = and i32 %165, 268435456
  %tobool157 = icmp ne i32 %and156, 0
  br i1 %tobool157, label %if.end.168, label %if.then.158

if.then.158:                                      ; preds = %land.lhs.true.153
  %166 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr159 = getelementptr inbounds %struct.sv*, %struct.sv** %166, i32 -1
  store %struct.sv** %incdec.ptr159, %struct.sv*** %sp, align 8
  %167 = load %struct.sv**, %struct.sv*** %sp, align 8
  %168 = load %struct.sv*, %struct.sv** %167, align 8
  %sv_any160 = getelementptr inbounds %struct.sv, %struct.sv* %168, i32 0, i32 0
  %169 = load i8*, i8** %sv_any160, align 8
  %170 = bitcast i8* %169 to %struct.xrv*
  %xrv_rv = getelementptr inbounds %struct.xrv, %struct.xrv* %170, i32 0, i32 0
  %171 = load %struct.sv*, %struct.sv** %xrv_rv, align 8
  %172 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr161 = getelementptr inbounds %struct.sv*, %struct.sv** %172, i64 1
  %173 = load %struct.sv*, %struct.sv** %add.ptr161, align 8
  %sv_any162 = getelementptr inbounds %struct.sv, %struct.sv* %173, i32 0, i32 0
  %174 = load i8*, i8** %sv_any162, align 8
  %175 = bitcast i8* %174 to %struct.xrv*
  %xrv_rv163 = getelementptr inbounds %struct.xrv, %struct.xrv* %175, i32 0, i32 0
  %176 = load %struct.sv*, %struct.sv** %xrv_rv163, align 8
  %cmp164 = icmp ult %struct.sv* %171, %176
  %cond166 = select i1 %cmp164, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  %177 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %cond166, %struct.sv** %177, align 8
  %178 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %178, %struct.sv*** @PL_stack_sp, align 8
  %179 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next167 = getelementptr inbounds %struct.op, %struct.op* %179, i32 0, i32 0
  %180 = load %struct.op*, %struct.op** %op_next167, align 8
  store %struct.op* %180, %struct.op** %retval
  br label %return

if.end.168:                                       ; preds = %land.lhs.true.153, %land.lhs.true.148, %land.lhs.true.144, %if.else
  br label %if.end.169

if.end.169:                                       ; preds = %if.end.168, %if.end.140
  %181 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr170 = getelementptr inbounds %struct.sv*, %struct.sv** %181, i32 -1
  store %struct.sv** %incdec.ptr170, %struct.sv*** %sp, align 8
  %182 = load %struct.sv*, %struct.sv** %181, align 8
  store %struct.sv* %182, %struct.sv** @PL_Sv, align 8
  %183 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags171 = getelementptr inbounds %struct.sv, %struct.sv* %183, i32 0, i32 2
  %184 = load i32, i32* %sv_flags171, align 4
  %and172 = and i32 %184, 131072
  %tobool173 = icmp ne i32 %and172, 0
  br i1 %tobool173, label %cond.true.174, label %cond.false.176

cond.true.174:                                    ; preds = %if.end.169
  %185 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any175 = getelementptr inbounds %struct.sv, %struct.sv* %185, i32 0, i32 0
  %186 = load i8*, i8** %sv_any175, align 8
  %187 = bitcast i8* %186 to %struct.xpvnv*
  %xnv_nv = getelementptr inbounds %struct.xpvnv, %struct.xpvnv* %187, i32 0, i32 4
  %188 = load double, double* %xnv_nv, align 8
  br label %cond.end.178

cond.false.176:                                   ; preds = %if.end.169
  %189 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call177 = call double @Perl_sv_2nv(%struct.sv* %189)
  br label %cond.end.178

cond.end.178:                                     ; preds = %cond.false.176, %cond.true.174
  %cond179 = phi double [ %188, %cond.true.174 ], [ %call177, %cond.false.176 ]
  store double %cond179, double* %value, align 8
  %190 = load %struct.sv**, %struct.sv*** %sp, align 8
  %191 = load %struct.sv*, %struct.sv** %190, align 8
  %sv_flags180 = getelementptr inbounds %struct.sv, %struct.sv* %191, i32 0, i32 2
  %192 = load i32, i32* %sv_flags180, align 4
  %and181 = and i32 %192, 131072
  %tobool182 = icmp ne i32 %and181, 0
  br i1 %tobool182, label %cond.true.183, label %cond.false.186

cond.true.183:                                    ; preds = %cond.end.178
  %193 = load %struct.sv**, %struct.sv*** %sp, align 8
  %194 = load %struct.sv*, %struct.sv** %193, align 8
  %sv_any184 = getelementptr inbounds %struct.sv, %struct.sv* %194, i32 0, i32 0
  %195 = load i8*, i8** %sv_any184, align 8
  %196 = bitcast i8* %195 to %struct.xpvnv*
  %xnv_nv185 = getelementptr inbounds %struct.xpvnv, %struct.xpvnv* %196, i32 0, i32 4
  %197 = load double, double* %xnv_nv185, align 8
  br label %cond.end.188

cond.false.186:                                   ; preds = %cond.end.178
  %198 = load %struct.sv**, %struct.sv*** %sp, align 8
  %199 = load %struct.sv*, %struct.sv** %198, align 8
  %call187 = call double @Perl_sv_2nv(%struct.sv* %199)
  br label %cond.end.188

cond.end.188:                                     ; preds = %cond.false.186, %cond.true.183
  %cond189 = phi double [ %197, %cond.true.183 ], [ %call187, %cond.false.186 ]
  %200 = load double, double* %value, align 8
  %cmp190 = fcmp olt double %cond189, %200
  %cond192 = select i1 %cmp190, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  %201 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %cond192, %struct.sv** %201, align 8
  %202 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %202, %struct.sv*** @PL_stack_sp, align 8
  %203 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next193 = getelementptr inbounds %struct.op, %struct.op* %203, i32 0, i32 0
  %204 = load %struct.op*, %struct.op** %op_next193, align 8
  store %struct.op* %204, %struct.op** %retval
  br label %return

return:                                           ; preds = %cond.end.188, %if.then.158, %if.end.132, %if.then.129, %if.end.114, %if.then.112, %if.then.92, %if.then.75, %if.then.6
  %205 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %205
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_gt() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %right = alloca %struct.sv*, align 8
  %left = alloca %struct.sv*, align 8
  %auvok = alloca i8, align 1
  %buvok = alloca i8, align 1
  %aiv = alloca i64, align 8
  %biv = alloca i64, align 8
  %auv = alloca i64, align 8
  %buv = alloca i64, align 8
  %auv105 = alloca i64, align 8
  %biv106 = alloca i64, align 8
  %aiv122 = alloca i64, align 8
  %buv123 = alloca i64, align 8
  %value = alloca double, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load i64, i64* @PL_amagic_generation, align 8
  %tobool = icmp ne i64 %1, 0
  br i1 %tobool, label %if.then, label %if.end.7

if.then:                                          ; preds = %entry
  %2 = load %struct.sv**, %struct.sv*** %sp, align 8
  %3 = load %struct.sv*, %struct.sv** %2, align 8
  store %struct.sv* %3, %struct.sv** %right, align 8
  %4 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %4, i64 -1
  %5 = load %struct.sv*, %struct.sv** %add.ptr, align 8
  store %struct.sv* %5, %struct.sv** %left, align 8
  %6 = load %struct.sv*, %struct.sv** %left, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %6, i32 0, i32 2
  %7 = load i32, i32* %sv_flags, align 4
  %and = and i32 %7, 268435456
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %8 = load %struct.sv*, %struct.sv** %right, align 8
  %sv_flags2 = getelementptr inbounds %struct.sv, %struct.sv* %8, i32 0, i32 2
  %9 = load i32, i32* %sv_flags2, align 4
  %and3 = and i32 %9, 268435456
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %10 = load %struct.sv*, %struct.sv** %left, align 8
  %11 = load %struct.sv*, %struct.sv** %right, align 8
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %10, %struct.sv* %11, i32 30, i32 0)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool5 = icmp ne %struct.sv* %call, null
  br i1 %tobool5, label %if.then.6, label %if.end

if.then.6:                                        ; preds = %land.lhs.true
  %12 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %12, %struct.sv*** %sp, align 8
  %13 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %13, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %14 = load %struct.sv*, %struct.sv** %13, align 8
  %15 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %16 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %15, %struct.sv** %16, align 8
  %17 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %17, %struct.sv*** @PL_stack_sp, align 8
  %18 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %18, i32 0, i32 0
  %19 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %19, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %land.lhs.true, %lor.lhs.false
  br label %if.end.7

if.end.7:                                         ; preds = %if.end, %entry
  %20 = load %struct.sv**, %struct.sv*** %sp, align 8
  %21 = load %struct.sv*, %struct.sv** %20, align 8
  %sv_flags8 = getelementptr inbounds %struct.sv, %struct.sv* %21, i32 0, i32 2
  %22 = load i32, i32* %sv_flags8, align 4
  %and9 = and i32 %22, 16777216
  %tobool10 = icmp ne i32 %and9, 0
  br i1 %tobool10, label %if.end.24, label %land.lhs.true.11

land.lhs.true.11:                                 ; preds = %if.end.7
  %23 = load %struct.sv**, %struct.sv*** %sp, align 8
  %24 = load %struct.sv*, %struct.sv** %23, align 8
  %sv_flags12 = getelementptr inbounds %struct.sv, %struct.sv* %24, i32 0, i32 2
  %25 = load i32, i32* %sv_flags12, align 4
  %and13 = and i32 %25, 131072
  %tobool14 = icmp ne i32 %and13, 0
  br i1 %tobool14, label %if.then.19, label %lor.lhs.false.15

lor.lhs.false.15:                                 ; preds = %land.lhs.true.11
  %26 = load %struct.sv**, %struct.sv*** %sp, align 8
  %27 = load %struct.sv*, %struct.sv** %26, align 8
  %sv_flags16 = getelementptr inbounds %struct.sv, %struct.sv* %27, i32 0, i32 2
  %28 = load i32, i32* %sv_flags16, align 4
  %and17 = and i32 %28, 262144
  %tobool18 = icmp ne i32 %and17, 0
  br i1 %tobool18, label %if.then.19, label %if.end.24

if.then.19:                                       ; preds = %lor.lhs.false.15, %land.lhs.true.11
  %29 = load %struct.sv**, %struct.sv*** %sp, align 8
  %30 = load %struct.sv*, %struct.sv** %29, align 8
  %sv_flags20 = getelementptr inbounds %struct.sv, %struct.sv* %30, i32 0, i32 2
  %31 = load i32, i32* %sv_flags20, align 4
  %and21 = and i32 %31, 65536
  %tobool22 = icmp ne i32 %and21, 0
  br i1 %tobool22, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.19
  %32 = load %struct.sv**, %struct.sv*** %sp, align 8
  %33 = load %struct.sv*, %struct.sv** %32, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %33, i32 0, i32 0
  %34 = load i8*, i8** %sv_any, align 8
  %35 = bitcast i8* %34 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %35, i32 0, i32 3
  %36 = load i64, i64* %xiv_iv, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then.19
  %37 = load %struct.sv**, %struct.sv*** %sp, align 8
  %38 = load %struct.sv*, %struct.sv** %37, align 8
  %call23 = call i64 @Perl_sv_2iv(%struct.sv* %38)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %36, %cond.true ], [ %call23, %cond.false ]
  br label %if.end.24

if.end.24:                                        ; preds = %cond.end, %lor.lhs.false.15, %if.end.7
  %39 = load %struct.sv**, %struct.sv*** %sp, align 8
  %40 = load %struct.sv*, %struct.sv** %39, align 8
  %sv_flags25 = getelementptr inbounds %struct.sv, %struct.sv* %40, i32 0, i32 2
  %41 = load i32, i32* %sv_flags25, align 4
  %and26 = and i32 %41, 65536
  %tobool27 = icmp ne i32 %and26, 0
  br i1 %tobool27, label %if.then.28, label %if.else

if.then.28:                                       ; preds = %if.end.24
  %42 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr29 = getelementptr inbounds %struct.sv*, %struct.sv** %42, i64 -1
  %43 = load %struct.sv*, %struct.sv** %add.ptr29, align 8
  %sv_flags30 = getelementptr inbounds %struct.sv, %struct.sv* %43, i32 0, i32 2
  %44 = load i32, i32* %sv_flags30, align 4
  %and31 = and i32 %44, 16777216
  %tobool32 = icmp ne i32 %and31, 0
  br i1 %tobool32, label %if.end.57, label %land.lhs.true.33

land.lhs.true.33:                                 ; preds = %if.then.28
  %45 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr34 = getelementptr inbounds %struct.sv*, %struct.sv** %45, i64 -1
  %46 = load %struct.sv*, %struct.sv** %add.ptr34, align 8
  %sv_flags35 = getelementptr inbounds %struct.sv, %struct.sv* %46, i32 0, i32 2
  %47 = load i32, i32* %sv_flags35, align 4
  %and36 = and i32 %47, 131072
  %tobool37 = icmp ne i32 %and36, 0
  br i1 %tobool37, label %if.then.43, label %lor.lhs.false.38

lor.lhs.false.38:                                 ; preds = %land.lhs.true.33
  %48 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr39 = getelementptr inbounds %struct.sv*, %struct.sv** %48, i64 -1
  %49 = load %struct.sv*, %struct.sv** %add.ptr39, align 8
  %sv_flags40 = getelementptr inbounds %struct.sv, %struct.sv* %49, i32 0, i32 2
  %50 = load i32, i32* %sv_flags40, align 4
  %and41 = and i32 %50, 262144
  %tobool42 = icmp ne i32 %and41, 0
  br i1 %tobool42, label %if.then.43, label %if.end.57

if.then.43:                                       ; preds = %lor.lhs.false.38, %land.lhs.true.33
  %51 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr44 = getelementptr inbounds %struct.sv*, %struct.sv** %51, i64 -1
  %52 = load %struct.sv*, %struct.sv** %add.ptr44, align 8
  %sv_flags45 = getelementptr inbounds %struct.sv, %struct.sv* %52, i32 0, i32 2
  %53 = load i32, i32* %sv_flags45, align 4
  %and46 = and i32 %53, 65536
  %tobool47 = icmp ne i32 %and46, 0
  br i1 %tobool47, label %cond.true.48, label %cond.false.52

cond.true.48:                                     ; preds = %if.then.43
  %54 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr49 = getelementptr inbounds %struct.sv*, %struct.sv** %54, i64 -1
  %55 = load %struct.sv*, %struct.sv** %add.ptr49, align 8
  %sv_any50 = getelementptr inbounds %struct.sv, %struct.sv* %55, i32 0, i32 0
  %56 = load i8*, i8** %sv_any50, align 8
  %57 = bitcast i8* %56 to %struct.xpviv*
  %xiv_iv51 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %57, i32 0, i32 3
  %58 = load i64, i64* %xiv_iv51, align 8
  br label %cond.end.55

cond.false.52:                                    ; preds = %if.then.43
  %59 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr53 = getelementptr inbounds %struct.sv*, %struct.sv** %59, i64 -1
  %60 = load %struct.sv*, %struct.sv** %add.ptr53, align 8
  %call54 = call i64 @Perl_sv_2iv(%struct.sv* %60)
  br label %cond.end.55

cond.end.55:                                      ; preds = %cond.false.52, %cond.true.48
  %cond56 = phi i64 [ %58, %cond.true.48 ], [ %call54, %cond.false.52 ]
  br label %if.end.57

if.end.57:                                        ; preds = %cond.end.55, %lor.lhs.false.38, %if.then.28
  %61 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr58 = getelementptr inbounds %struct.sv*, %struct.sv** %61, i64 -1
  %62 = load %struct.sv*, %struct.sv** %add.ptr58, align 8
  %sv_flags59 = getelementptr inbounds %struct.sv, %struct.sv* %62, i32 0, i32 2
  %63 = load i32, i32* %sv_flags59, align 4
  %and60 = and i32 %63, 65536
  %tobool61 = icmp ne i32 %and60, 0
  br i1 %tobool61, label %if.then.62, label %if.end.140

if.then.62:                                       ; preds = %if.end.57
  %64 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr63 = getelementptr inbounds %struct.sv*, %struct.sv** %64, i64 -1
  %65 = load %struct.sv*, %struct.sv** %add.ptr63, align 8
  %sv_flags64 = getelementptr inbounds %struct.sv, %struct.sv* %65, i32 0, i32 2
  %66 = load i32, i32* %sv_flags64, align 4
  %and65 = and i32 %66, -2147418112
  %cmp = icmp eq i32 %and65, -2147418112
  %conv = zext i1 %cmp to i32
  %conv66 = trunc i32 %conv to i8
  store i8 %conv66, i8* %auvok, align 1
  %67 = load %struct.sv**, %struct.sv*** %sp, align 8
  %68 = load %struct.sv*, %struct.sv** %67, align 8
  %sv_flags67 = getelementptr inbounds %struct.sv, %struct.sv* %68, i32 0, i32 2
  %69 = load i32, i32* %sv_flags67, align 4
  %and68 = and i32 %69, -2147418112
  %cmp69 = icmp eq i32 %and68, -2147418112
  %conv70 = zext i1 %cmp69 to i32
  %conv71 = trunc i32 %conv70 to i8
  store i8 %conv71, i8* %buvok, align 1
  %70 = load i8, i8* %auvok, align 1
  %tobool72 = icmp ne i8 %70, 0
  br i1 %tobool72, label %if.end.86, label %land.lhs.true.73

land.lhs.true.73:                                 ; preds = %if.then.62
  %71 = load i8, i8* %buvok, align 1
  %tobool74 = icmp ne i8 %71, 0
  br i1 %tobool74, label %if.end.86, label %if.then.75

if.then.75:                                       ; preds = %land.lhs.true.73
  %72 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr76 = getelementptr inbounds %struct.sv*, %struct.sv** %72, i64 -1
  %73 = load %struct.sv*, %struct.sv** %add.ptr76, align 8
  %sv_any77 = getelementptr inbounds %struct.sv, %struct.sv* %73, i32 0, i32 0
  %74 = load i8*, i8** %sv_any77, align 8
  %75 = bitcast i8* %74 to %struct.xpviv*
  %xiv_iv78 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %75, i32 0, i32 3
  %76 = load i64, i64* %xiv_iv78, align 8
  store i64 %76, i64* %aiv, align 8
  %77 = load %struct.sv**, %struct.sv*** %sp, align 8
  %78 = load %struct.sv*, %struct.sv** %77, align 8
  %sv_any79 = getelementptr inbounds %struct.sv, %struct.sv* %78, i32 0, i32 0
  %79 = load i8*, i8** %sv_any79, align 8
  %80 = bitcast i8* %79 to %struct.xpviv*
  %xiv_iv80 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %80, i32 0, i32 3
  %81 = load i64, i64* %xiv_iv80, align 8
  store i64 %81, i64* %biv, align 8
  %82 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr81 = getelementptr inbounds %struct.sv*, %struct.sv** %82, i32 -1
  store %struct.sv** %incdec.ptr81, %struct.sv*** %sp, align 8
  %83 = load i64, i64* %aiv, align 8
  %84 = load i64, i64* %biv, align 8
  %cmp82 = icmp sgt i64 %83, %84
  %cond84 = select i1 %cmp82, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  %85 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %cond84, %struct.sv** %85, align 8
  %86 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %86, %struct.sv*** @PL_stack_sp, align 8
  %87 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next85 = getelementptr inbounds %struct.op, %struct.op* %87, i32 0, i32 0
  %88 = load %struct.op*, %struct.op** %op_next85, align 8
  store %struct.op* %88, %struct.op** %retval
  br label %return

if.end.86:                                        ; preds = %land.lhs.true.73, %if.then.62
  %89 = load i8, i8* %auvok, align 1
  %conv87 = sext i8 %89 to i32
  %tobool88 = icmp ne i32 %conv87, 0
  br i1 %tobool88, label %land.lhs.true.89, label %if.end.102

land.lhs.true.89:                                 ; preds = %if.end.86
  %90 = load i8, i8* %buvok, align 1
  %conv90 = sext i8 %90 to i32
  %tobool91 = icmp ne i32 %conv90, 0
  br i1 %tobool91, label %if.then.92, label %if.end.102

if.then.92:                                       ; preds = %land.lhs.true.89
  %91 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr93 = getelementptr inbounds %struct.sv*, %struct.sv** %91, i64 -1
  %92 = load %struct.sv*, %struct.sv** %add.ptr93, align 8
  %sv_any94 = getelementptr inbounds %struct.sv, %struct.sv* %92, i32 0, i32 0
  %93 = load i8*, i8** %sv_any94, align 8
  %94 = bitcast i8* %93 to %struct.xpvuv*
  %xuv_uv = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %94, i32 0, i32 3
  %95 = load i64, i64* %xuv_uv, align 8
  store i64 %95, i64* %auv, align 8
  %96 = load %struct.sv**, %struct.sv*** %sp, align 8
  %97 = load %struct.sv*, %struct.sv** %96, align 8
  %sv_any95 = getelementptr inbounds %struct.sv, %struct.sv* %97, i32 0, i32 0
  %98 = load i8*, i8** %sv_any95, align 8
  %99 = bitcast i8* %98 to %struct.xpvuv*
  %xuv_uv96 = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %99, i32 0, i32 3
  %100 = load i64, i64* %xuv_uv96, align 8
  store i64 %100, i64* %buv, align 8
  %101 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr97 = getelementptr inbounds %struct.sv*, %struct.sv** %101, i32 -1
  store %struct.sv** %incdec.ptr97, %struct.sv*** %sp, align 8
  %102 = load i64, i64* %auv, align 8
  %103 = load i64, i64* %buv, align 8
  %cmp98 = icmp ugt i64 %102, %103
  %cond100 = select i1 %cmp98, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  %104 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %cond100, %struct.sv** %104, align 8
  %105 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %105, %struct.sv*** @PL_stack_sp, align 8
  %106 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next101 = getelementptr inbounds %struct.op, %struct.op* %106, i32 0, i32 0
  %107 = load %struct.op*, %struct.op** %op_next101, align 8
  store %struct.op* %107, %struct.op** %retval
  br label %return

if.end.102:                                       ; preds = %land.lhs.true.89, %if.end.86
  %108 = load i8, i8* %auvok, align 1
  %tobool103 = icmp ne i8 %108, 0
  br i1 %tobool103, label %if.then.104, label %if.end.121

if.then.104:                                      ; preds = %if.end.102
  %109 = load %struct.sv**, %struct.sv*** %sp, align 8
  %110 = load %struct.sv*, %struct.sv** %109, align 8
  %sv_any107 = getelementptr inbounds %struct.sv, %struct.sv* %110, i32 0, i32 0
  %111 = load i8*, i8** %sv_any107, align 8
  %112 = bitcast i8* %111 to %struct.xpviv*
  %xiv_iv108 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %112, i32 0, i32 3
  %113 = load i64, i64* %xiv_iv108, align 8
  store i64 %113, i64* %biv106, align 8
  %114 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr109 = getelementptr inbounds %struct.sv*, %struct.sv** %114, i32 -1
  store %struct.sv** %incdec.ptr109, %struct.sv*** %sp, align 8
  %115 = load i64, i64* %biv106, align 8
  %cmp110 = icmp slt i64 %115, 0
  br i1 %cmp110, label %if.then.112, label %if.end.114

if.then.112:                                      ; preds = %if.then.104
  %116 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* @PL_sv_yes, %struct.sv** %116, align 8
  %117 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %117, %struct.sv*** @PL_stack_sp, align 8
  %118 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next113 = getelementptr inbounds %struct.op, %struct.op* %118, i32 0, i32 0
  %119 = load %struct.op*, %struct.op** %op_next113, align 8
  store %struct.op* %119, %struct.op** %retval
  br label %return

if.end.114:                                       ; preds = %if.then.104
  %120 = load %struct.sv**, %struct.sv*** %sp, align 8
  %121 = load %struct.sv*, %struct.sv** %120, align 8
  %sv_any115 = getelementptr inbounds %struct.sv, %struct.sv* %121, i32 0, i32 0
  %122 = load i8*, i8** %sv_any115, align 8
  %123 = bitcast i8* %122 to %struct.xpvuv*
  %xuv_uv116 = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %123, i32 0, i32 3
  %124 = load i64, i64* %xuv_uv116, align 8
  store i64 %124, i64* %auv105, align 8
  %125 = load i64, i64* %auv105, align 8
  %126 = load i64, i64* %biv106, align 8
  %cmp117 = icmp ugt i64 %125, %126
  %cond119 = select i1 %cmp117, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  %127 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %cond119, %struct.sv** %127, align 8
  %128 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %128, %struct.sv*** @PL_stack_sp, align 8
  %129 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next120 = getelementptr inbounds %struct.op, %struct.op* %129, i32 0, i32 0
  %130 = load %struct.op*, %struct.op** %op_next120, align 8
  store %struct.op* %130, %struct.op** %retval
  br label %return

if.end.121:                                       ; preds = %if.end.102
  %131 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr124 = getelementptr inbounds %struct.sv*, %struct.sv** %131, i64 -1
  %132 = load %struct.sv*, %struct.sv** %add.ptr124, align 8
  %sv_any125 = getelementptr inbounds %struct.sv, %struct.sv* %132, i32 0, i32 0
  %133 = load i8*, i8** %sv_any125, align 8
  %134 = bitcast i8* %133 to %struct.xpviv*
  %xiv_iv126 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %134, i32 0, i32 3
  %135 = load i64, i64* %xiv_iv126, align 8
  store i64 %135, i64* %aiv122, align 8
  %136 = load i64, i64* %aiv122, align 8
  %cmp127 = icmp slt i64 %136, 0
  br i1 %cmp127, label %if.then.129, label %if.end.132

if.then.129:                                      ; preds = %if.end.121
  %137 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr130 = getelementptr inbounds %struct.sv*, %struct.sv** %137, i32 -1
  store %struct.sv** %incdec.ptr130, %struct.sv*** %sp, align 8
  %138 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* @PL_sv_no, %struct.sv** %138, align 8
  %139 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %139, %struct.sv*** @PL_stack_sp, align 8
  %140 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next131 = getelementptr inbounds %struct.op, %struct.op* %140, i32 0, i32 0
  %141 = load %struct.op*, %struct.op** %op_next131, align 8
  store %struct.op* %141, %struct.op** %retval
  br label %return

if.end.132:                                       ; preds = %if.end.121
  %142 = load %struct.sv**, %struct.sv*** %sp, align 8
  %143 = load %struct.sv*, %struct.sv** %142, align 8
  %sv_any133 = getelementptr inbounds %struct.sv, %struct.sv* %143, i32 0, i32 0
  %144 = load i8*, i8** %sv_any133, align 8
  %145 = bitcast i8* %144 to %struct.xpvuv*
  %xuv_uv134 = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %145, i32 0, i32 3
  %146 = load i64, i64* %xuv_uv134, align 8
  store i64 %146, i64* %buv123, align 8
  %147 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr135 = getelementptr inbounds %struct.sv*, %struct.sv** %147, i32 -1
  store %struct.sv** %incdec.ptr135, %struct.sv*** %sp, align 8
  %148 = load i64, i64* %aiv122, align 8
  %149 = load i64, i64* %buv123, align 8
  %cmp136 = icmp ugt i64 %148, %149
  %cond138 = select i1 %cmp136, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  %150 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %cond138, %struct.sv** %150, align 8
  %151 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %151, %struct.sv*** @PL_stack_sp, align 8
  %152 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next139 = getelementptr inbounds %struct.op, %struct.op* %152, i32 0, i32 0
  %153 = load %struct.op*, %struct.op** %op_next139, align 8
  store %struct.op* %153, %struct.op** %retval
  br label %return

if.end.140:                                       ; preds = %if.end.57
  br label %if.end.169

if.else:                                          ; preds = %if.end.24
  %154 = load %struct.sv**, %struct.sv*** %sp, align 8
  %155 = load %struct.sv*, %struct.sv** %154, align 8
  %sv_flags141 = getelementptr inbounds %struct.sv, %struct.sv* %155, i32 0, i32 2
  %156 = load i32, i32* %sv_flags141, align 4
  %and142 = and i32 %156, 524288
  %tobool143 = icmp ne i32 %and142, 0
  br i1 %tobool143, label %land.lhs.true.144, label %if.end.168

land.lhs.true.144:                                ; preds = %if.else
  %157 = load %struct.sv**, %struct.sv*** %sp, align 8
  %158 = load %struct.sv*, %struct.sv** %157, align 8
  %sv_flags145 = getelementptr inbounds %struct.sv, %struct.sv* %158, i32 0, i32 2
  %159 = load i32, i32* %sv_flags145, align 4
  %and146 = and i32 %159, 268435456
  %tobool147 = icmp ne i32 %and146, 0
  br i1 %tobool147, label %if.end.168, label %land.lhs.true.148

land.lhs.true.148:                                ; preds = %land.lhs.true.144
  %160 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr149 = getelementptr inbounds %struct.sv*, %struct.sv** %160, i64 -1
  %161 = load %struct.sv*, %struct.sv** %add.ptr149, align 8
  %sv_flags150 = getelementptr inbounds %struct.sv, %struct.sv* %161, i32 0, i32 2
  %162 = load i32, i32* %sv_flags150, align 4
  %and151 = and i32 %162, 524288
  %tobool152 = icmp ne i32 %and151, 0
  br i1 %tobool152, label %land.lhs.true.153, label %if.end.168

land.lhs.true.153:                                ; preds = %land.lhs.true.148
  %163 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr154 = getelementptr inbounds %struct.sv*, %struct.sv** %163, i64 -1
  %164 = load %struct.sv*, %struct.sv** %add.ptr154, align 8
  %sv_flags155 = getelementptr inbounds %struct.sv, %struct.sv* %164, i32 0, i32 2
  %165 = load i32, i32* %sv_flags155, align 4
  %and156 = and i32 %165, 268435456
  %tobool157 = icmp ne i32 %and156, 0
  br i1 %tobool157, label %if.end.168, label %if.then.158

if.then.158:                                      ; preds = %land.lhs.true.153
  %166 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr159 = getelementptr inbounds %struct.sv*, %struct.sv** %166, i32 -1
  store %struct.sv** %incdec.ptr159, %struct.sv*** %sp, align 8
  %167 = load %struct.sv**, %struct.sv*** %sp, align 8
  %168 = load %struct.sv*, %struct.sv** %167, align 8
  %sv_any160 = getelementptr inbounds %struct.sv, %struct.sv* %168, i32 0, i32 0
  %169 = load i8*, i8** %sv_any160, align 8
  %170 = bitcast i8* %169 to %struct.xrv*
  %xrv_rv = getelementptr inbounds %struct.xrv, %struct.xrv* %170, i32 0, i32 0
  %171 = load %struct.sv*, %struct.sv** %xrv_rv, align 8
  %172 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr161 = getelementptr inbounds %struct.sv*, %struct.sv** %172, i64 1
  %173 = load %struct.sv*, %struct.sv** %add.ptr161, align 8
  %sv_any162 = getelementptr inbounds %struct.sv, %struct.sv* %173, i32 0, i32 0
  %174 = load i8*, i8** %sv_any162, align 8
  %175 = bitcast i8* %174 to %struct.xrv*
  %xrv_rv163 = getelementptr inbounds %struct.xrv, %struct.xrv* %175, i32 0, i32 0
  %176 = load %struct.sv*, %struct.sv** %xrv_rv163, align 8
  %cmp164 = icmp ugt %struct.sv* %171, %176
  %cond166 = select i1 %cmp164, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  %177 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %cond166, %struct.sv** %177, align 8
  %178 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %178, %struct.sv*** @PL_stack_sp, align 8
  %179 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next167 = getelementptr inbounds %struct.op, %struct.op* %179, i32 0, i32 0
  %180 = load %struct.op*, %struct.op** %op_next167, align 8
  store %struct.op* %180, %struct.op** %retval
  br label %return

if.end.168:                                       ; preds = %land.lhs.true.153, %land.lhs.true.148, %land.lhs.true.144, %if.else
  br label %if.end.169

if.end.169:                                       ; preds = %if.end.168, %if.end.140
  %181 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr170 = getelementptr inbounds %struct.sv*, %struct.sv** %181, i32 -1
  store %struct.sv** %incdec.ptr170, %struct.sv*** %sp, align 8
  %182 = load %struct.sv*, %struct.sv** %181, align 8
  store %struct.sv* %182, %struct.sv** @PL_Sv, align 8
  %183 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags171 = getelementptr inbounds %struct.sv, %struct.sv* %183, i32 0, i32 2
  %184 = load i32, i32* %sv_flags171, align 4
  %and172 = and i32 %184, 131072
  %tobool173 = icmp ne i32 %and172, 0
  br i1 %tobool173, label %cond.true.174, label %cond.false.176

cond.true.174:                                    ; preds = %if.end.169
  %185 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any175 = getelementptr inbounds %struct.sv, %struct.sv* %185, i32 0, i32 0
  %186 = load i8*, i8** %sv_any175, align 8
  %187 = bitcast i8* %186 to %struct.xpvnv*
  %xnv_nv = getelementptr inbounds %struct.xpvnv, %struct.xpvnv* %187, i32 0, i32 4
  %188 = load double, double* %xnv_nv, align 8
  br label %cond.end.178

cond.false.176:                                   ; preds = %if.end.169
  %189 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call177 = call double @Perl_sv_2nv(%struct.sv* %189)
  br label %cond.end.178

cond.end.178:                                     ; preds = %cond.false.176, %cond.true.174
  %cond179 = phi double [ %188, %cond.true.174 ], [ %call177, %cond.false.176 ]
  store double %cond179, double* %value, align 8
  %190 = load %struct.sv**, %struct.sv*** %sp, align 8
  %191 = load %struct.sv*, %struct.sv** %190, align 8
  %sv_flags180 = getelementptr inbounds %struct.sv, %struct.sv* %191, i32 0, i32 2
  %192 = load i32, i32* %sv_flags180, align 4
  %and181 = and i32 %192, 131072
  %tobool182 = icmp ne i32 %and181, 0
  br i1 %tobool182, label %cond.true.183, label %cond.false.186

cond.true.183:                                    ; preds = %cond.end.178
  %193 = load %struct.sv**, %struct.sv*** %sp, align 8
  %194 = load %struct.sv*, %struct.sv** %193, align 8
  %sv_any184 = getelementptr inbounds %struct.sv, %struct.sv* %194, i32 0, i32 0
  %195 = load i8*, i8** %sv_any184, align 8
  %196 = bitcast i8* %195 to %struct.xpvnv*
  %xnv_nv185 = getelementptr inbounds %struct.xpvnv, %struct.xpvnv* %196, i32 0, i32 4
  %197 = load double, double* %xnv_nv185, align 8
  br label %cond.end.188

cond.false.186:                                   ; preds = %cond.end.178
  %198 = load %struct.sv**, %struct.sv*** %sp, align 8
  %199 = load %struct.sv*, %struct.sv** %198, align 8
  %call187 = call double @Perl_sv_2nv(%struct.sv* %199)
  br label %cond.end.188

cond.end.188:                                     ; preds = %cond.false.186, %cond.true.183
  %cond189 = phi double [ %197, %cond.true.183 ], [ %call187, %cond.false.186 ]
  %200 = load double, double* %value, align 8
  %cmp190 = fcmp ogt double %cond189, %200
  %cond192 = select i1 %cmp190, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  %201 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %cond192, %struct.sv** %201, align 8
  %202 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %202, %struct.sv*** @PL_stack_sp, align 8
  %203 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next193 = getelementptr inbounds %struct.op, %struct.op* %203, i32 0, i32 0
  %204 = load %struct.op*, %struct.op** %op_next193, align 8
  store %struct.op* %204, %struct.op** %retval
  br label %return

return:                                           ; preds = %cond.end.188, %if.then.158, %if.end.132, %if.then.129, %if.end.114, %if.then.112, %if.then.92, %if.then.75, %if.then.6
  %205 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %205
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_le() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %right = alloca %struct.sv*, align 8
  %left = alloca %struct.sv*, align 8
  %auvok = alloca i8, align 1
  %buvok = alloca i8, align 1
  %aiv = alloca i64, align 8
  %biv = alloca i64, align 8
  %auv = alloca i64, align 8
  %buv = alloca i64, align 8
  %auv105 = alloca i64, align 8
  %biv106 = alloca i64, align 8
  %aiv122 = alloca i64, align 8
  %buv123 = alloca i64, align 8
  %value = alloca double, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load i64, i64* @PL_amagic_generation, align 8
  %tobool = icmp ne i64 %1, 0
  br i1 %tobool, label %if.then, label %if.end.7

if.then:                                          ; preds = %entry
  %2 = load %struct.sv**, %struct.sv*** %sp, align 8
  %3 = load %struct.sv*, %struct.sv** %2, align 8
  store %struct.sv* %3, %struct.sv** %right, align 8
  %4 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %4, i64 -1
  %5 = load %struct.sv*, %struct.sv** %add.ptr, align 8
  store %struct.sv* %5, %struct.sv** %left, align 8
  %6 = load %struct.sv*, %struct.sv** %left, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %6, i32 0, i32 2
  %7 = load i32, i32* %sv_flags, align 4
  %and = and i32 %7, 268435456
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %8 = load %struct.sv*, %struct.sv** %right, align 8
  %sv_flags2 = getelementptr inbounds %struct.sv, %struct.sv* %8, i32 0, i32 2
  %9 = load i32, i32* %sv_flags2, align 4
  %and3 = and i32 %9, 268435456
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %10 = load %struct.sv*, %struct.sv** %left, align 8
  %11 = load %struct.sv*, %struct.sv** %right, align 8
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %10, %struct.sv* %11, i32 29, i32 0)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool5 = icmp ne %struct.sv* %call, null
  br i1 %tobool5, label %if.then.6, label %if.end

if.then.6:                                        ; preds = %land.lhs.true
  %12 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %12, %struct.sv*** %sp, align 8
  %13 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %13, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %14 = load %struct.sv*, %struct.sv** %13, align 8
  %15 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %16 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %15, %struct.sv** %16, align 8
  %17 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %17, %struct.sv*** @PL_stack_sp, align 8
  %18 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %18, i32 0, i32 0
  %19 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %19, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %land.lhs.true, %lor.lhs.false
  br label %if.end.7

if.end.7:                                         ; preds = %if.end, %entry
  %20 = load %struct.sv**, %struct.sv*** %sp, align 8
  %21 = load %struct.sv*, %struct.sv** %20, align 8
  %sv_flags8 = getelementptr inbounds %struct.sv, %struct.sv* %21, i32 0, i32 2
  %22 = load i32, i32* %sv_flags8, align 4
  %and9 = and i32 %22, 16777216
  %tobool10 = icmp ne i32 %and9, 0
  br i1 %tobool10, label %if.end.24, label %land.lhs.true.11

land.lhs.true.11:                                 ; preds = %if.end.7
  %23 = load %struct.sv**, %struct.sv*** %sp, align 8
  %24 = load %struct.sv*, %struct.sv** %23, align 8
  %sv_flags12 = getelementptr inbounds %struct.sv, %struct.sv* %24, i32 0, i32 2
  %25 = load i32, i32* %sv_flags12, align 4
  %and13 = and i32 %25, 131072
  %tobool14 = icmp ne i32 %and13, 0
  br i1 %tobool14, label %if.then.19, label %lor.lhs.false.15

lor.lhs.false.15:                                 ; preds = %land.lhs.true.11
  %26 = load %struct.sv**, %struct.sv*** %sp, align 8
  %27 = load %struct.sv*, %struct.sv** %26, align 8
  %sv_flags16 = getelementptr inbounds %struct.sv, %struct.sv* %27, i32 0, i32 2
  %28 = load i32, i32* %sv_flags16, align 4
  %and17 = and i32 %28, 262144
  %tobool18 = icmp ne i32 %and17, 0
  br i1 %tobool18, label %if.then.19, label %if.end.24

if.then.19:                                       ; preds = %lor.lhs.false.15, %land.lhs.true.11
  %29 = load %struct.sv**, %struct.sv*** %sp, align 8
  %30 = load %struct.sv*, %struct.sv** %29, align 8
  %sv_flags20 = getelementptr inbounds %struct.sv, %struct.sv* %30, i32 0, i32 2
  %31 = load i32, i32* %sv_flags20, align 4
  %and21 = and i32 %31, 65536
  %tobool22 = icmp ne i32 %and21, 0
  br i1 %tobool22, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.19
  %32 = load %struct.sv**, %struct.sv*** %sp, align 8
  %33 = load %struct.sv*, %struct.sv** %32, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %33, i32 0, i32 0
  %34 = load i8*, i8** %sv_any, align 8
  %35 = bitcast i8* %34 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %35, i32 0, i32 3
  %36 = load i64, i64* %xiv_iv, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then.19
  %37 = load %struct.sv**, %struct.sv*** %sp, align 8
  %38 = load %struct.sv*, %struct.sv** %37, align 8
  %call23 = call i64 @Perl_sv_2iv(%struct.sv* %38)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %36, %cond.true ], [ %call23, %cond.false ]
  br label %if.end.24

if.end.24:                                        ; preds = %cond.end, %lor.lhs.false.15, %if.end.7
  %39 = load %struct.sv**, %struct.sv*** %sp, align 8
  %40 = load %struct.sv*, %struct.sv** %39, align 8
  %sv_flags25 = getelementptr inbounds %struct.sv, %struct.sv* %40, i32 0, i32 2
  %41 = load i32, i32* %sv_flags25, align 4
  %and26 = and i32 %41, 65536
  %tobool27 = icmp ne i32 %and26, 0
  br i1 %tobool27, label %if.then.28, label %if.else

if.then.28:                                       ; preds = %if.end.24
  %42 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr29 = getelementptr inbounds %struct.sv*, %struct.sv** %42, i64 -1
  %43 = load %struct.sv*, %struct.sv** %add.ptr29, align 8
  %sv_flags30 = getelementptr inbounds %struct.sv, %struct.sv* %43, i32 0, i32 2
  %44 = load i32, i32* %sv_flags30, align 4
  %and31 = and i32 %44, 16777216
  %tobool32 = icmp ne i32 %and31, 0
  br i1 %tobool32, label %if.end.57, label %land.lhs.true.33

land.lhs.true.33:                                 ; preds = %if.then.28
  %45 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr34 = getelementptr inbounds %struct.sv*, %struct.sv** %45, i64 -1
  %46 = load %struct.sv*, %struct.sv** %add.ptr34, align 8
  %sv_flags35 = getelementptr inbounds %struct.sv, %struct.sv* %46, i32 0, i32 2
  %47 = load i32, i32* %sv_flags35, align 4
  %and36 = and i32 %47, 131072
  %tobool37 = icmp ne i32 %and36, 0
  br i1 %tobool37, label %if.then.43, label %lor.lhs.false.38

lor.lhs.false.38:                                 ; preds = %land.lhs.true.33
  %48 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr39 = getelementptr inbounds %struct.sv*, %struct.sv** %48, i64 -1
  %49 = load %struct.sv*, %struct.sv** %add.ptr39, align 8
  %sv_flags40 = getelementptr inbounds %struct.sv, %struct.sv* %49, i32 0, i32 2
  %50 = load i32, i32* %sv_flags40, align 4
  %and41 = and i32 %50, 262144
  %tobool42 = icmp ne i32 %and41, 0
  br i1 %tobool42, label %if.then.43, label %if.end.57

if.then.43:                                       ; preds = %lor.lhs.false.38, %land.lhs.true.33
  %51 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr44 = getelementptr inbounds %struct.sv*, %struct.sv** %51, i64 -1
  %52 = load %struct.sv*, %struct.sv** %add.ptr44, align 8
  %sv_flags45 = getelementptr inbounds %struct.sv, %struct.sv* %52, i32 0, i32 2
  %53 = load i32, i32* %sv_flags45, align 4
  %and46 = and i32 %53, 65536
  %tobool47 = icmp ne i32 %and46, 0
  br i1 %tobool47, label %cond.true.48, label %cond.false.52

cond.true.48:                                     ; preds = %if.then.43
  %54 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr49 = getelementptr inbounds %struct.sv*, %struct.sv** %54, i64 -1
  %55 = load %struct.sv*, %struct.sv** %add.ptr49, align 8
  %sv_any50 = getelementptr inbounds %struct.sv, %struct.sv* %55, i32 0, i32 0
  %56 = load i8*, i8** %sv_any50, align 8
  %57 = bitcast i8* %56 to %struct.xpviv*
  %xiv_iv51 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %57, i32 0, i32 3
  %58 = load i64, i64* %xiv_iv51, align 8
  br label %cond.end.55

cond.false.52:                                    ; preds = %if.then.43
  %59 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr53 = getelementptr inbounds %struct.sv*, %struct.sv** %59, i64 -1
  %60 = load %struct.sv*, %struct.sv** %add.ptr53, align 8
  %call54 = call i64 @Perl_sv_2iv(%struct.sv* %60)
  br label %cond.end.55

cond.end.55:                                      ; preds = %cond.false.52, %cond.true.48
  %cond56 = phi i64 [ %58, %cond.true.48 ], [ %call54, %cond.false.52 ]
  br label %if.end.57

if.end.57:                                        ; preds = %cond.end.55, %lor.lhs.false.38, %if.then.28
  %61 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr58 = getelementptr inbounds %struct.sv*, %struct.sv** %61, i64 -1
  %62 = load %struct.sv*, %struct.sv** %add.ptr58, align 8
  %sv_flags59 = getelementptr inbounds %struct.sv, %struct.sv* %62, i32 0, i32 2
  %63 = load i32, i32* %sv_flags59, align 4
  %and60 = and i32 %63, 65536
  %tobool61 = icmp ne i32 %and60, 0
  br i1 %tobool61, label %if.then.62, label %if.end.140

if.then.62:                                       ; preds = %if.end.57
  %64 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr63 = getelementptr inbounds %struct.sv*, %struct.sv** %64, i64 -1
  %65 = load %struct.sv*, %struct.sv** %add.ptr63, align 8
  %sv_flags64 = getelementptr inbounds %struct.sv, %struct.sv* %65, i32 0, i32 2
  %66 = load i32, i32* %sv_flags64, align 4
  %and65 = and i32 %66, -2147418112
  %cmp = icmp eq i32 %and65, -2147418112
  %conv = zext i1 %cmp to i32
  %conv66 = trunc i32 %conv to i8
  store i8 %conv66, i8* %auvok, align 1
  %67 = load %struct.sv**, %struct.sv*** %sp, align 8
  %68 = load %struct.sv*, %struct.sv** %67, align 8
  %sv_flags67 = getelementptr inbounds %struct.sv, %struct.sv* %68, i32 0, i32 2
  %69 = load i32, i32* %sv_flags67, align 4
  %and68 = and i32 %69, -2147418112
  %cmp69 = icmp eq i32 %and68, -2147418112
  %conv70 = zext i1 %cmp69 to i32
  %conv71 = trunc i32 %conv70 to i8
  store i8 %conv71, i8* %buvok, align 1
  %70 = load i8, i8* %auvok, align 1
  %tobool72 = icmp ne i8 %70, 0
  br i1 %tobool72, label %if.end.86, label %land.lhs.true.73

land.lhs.true.73:                                 ; preds = %if.then.62
  %71 = load i8, i8* %buvok, align 1
  %tobool74 = icmp ne i8 %71, 0
  br i1 %tobool74, label %if.end.86, label %if.then.75

if.then.75:                                       ; preds = %land.lhs.true.73
  %72 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr76 = getelementptr inbounds %struct.sv*, %struct.sv** %72, i64 -1
  %73 = load %struct.sv*, %struct.sv** %add.ptr76, align 8
  %sv_any77 = getelementptr inbounds %struct.sv, %struct.sv* %73, i32 0, i32 0
  %74 = load i8*, i8** %sv_any77, align 8
  %75 = bitcast i8* %74 to %struct.xpviv*
  %xiv_iv78 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %75, i32 0, i32 3
  %76 = load i64, i64* %xiv_iv78, align 8
  store i64 %76, i64* %aiv, align 8
  %77 = load %struct.sv**, %struct.sv*** %sp, align 8
  %78 = load %struct.sv*, %struct.sv** %77, align 8
  %sv_any79 = getelementptr inbounds %struct.sv, %struct.sv* %78, i32 0, i32 0
  %79 = load i8*, i8** %sv_any79, align 8
  %80 = bitcast i8* %79 to %struct.xpviv*
  %xiv_iv80 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %80, i32 0, i32 3
  %81 = load i64, i64* %xiv_iv80, align 8
  store i64 %81, i64* %biv, align 8
  %82 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr81 = getelementptr inbounds %struct.sv*, %struct.sv** %82, i32 -1
  store %struct.sv** %incdec.ptr81, %struct.sv*** %sp, align 8
  %83 = load i64, i64* %aiv, align 8
  %84 = load i64, i64* %biv, align 8
  %cmp82 = icmp sle i64 %83, %84
  %cond84 = select i1 %cmp82, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  %85 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %cond84, %struct.sv** %85, align 8
  %86 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %86, %struct.sv*** @PL_stack_sp, align 8
  %87 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next85 = getelementptr inbounds %struct.op, %struct.op* %87, i32 0, i32 0
  %88 = load %struct.op*, %struct.op** %op_next85, align 8
  store %struct.op* %88, %struct.op** %retval
  br label %return

if.end.86:                                        ; preds = %land.lhs.true.73, %if.then.62
  %89 = load i8, i8* %auvok, align 1
  %conv87 = sext i8 %89 to i32
  %tobool88 = icmp ne i32 %conv87, 0
  br i1 %tobool88, label %land.lhs.true.89, label %if.end.102

land.lhs.true.89:                                 ; preds = %if.end.86
  %90 = load i8, i8* %buvok, align 1
  %conv90 = sext i8 %90 to i32
  %tobool91 = icmp ne i32 %conv90, 0
  br i1 %tobool91, label %if.then.92, label %if.end.102

if.then.92:                                       ; preds = %land.lhs.true.89
  %91 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr93 = getelementptr inbounds %struct.sv*, %struct.sv** %91, i64 -1
  %92 = load %struct.sv*, %struct.sv** %add.ptr93, align 8
  %sv_any94 = getelementptr inbounds %struct.sv, %struct.sv* %92, i32 0, i32 0
  %93 = load i8*, i8** %sv_any94, align 8
  %94 = bitcast i8* %93 to %struct.xpvuv*
  %xuv_uv = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %94, i32 0, i32 3
  %95 = load i64, i64* %xuv_uv, align 8
  store i64 %95, i64* %auv, align 8
  %96 = load %struct.sv**, %struct.sv*** %sp, align 8
  %97 = load %struct.sv*, %struct.sv** %96, align 8
  %sv_any95 = getelementptr inbounds %struct.sv, %struct.sv* %97, i32 0, i32 0
  %98 = load i8*, i8** %sv_any95, align 8
  %99 = bitcast i8* %98 to %struct.xpvuv*
  %xuv_uv96 = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %99, i32 0, i32 3
  %100 = load i64, i64* %xuv_uv96, align 8
  store i64 %100, i64* %buv, align 8
  %101 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr97 = getelementptr inbounds %struct.sv*, %struct.sv** %101, i32 -1
  store %struct.sv** %incdec.ptr97, %struct.sv*** %sp, align 8
  %102 = load i64, i64* %auv, align 8
  %103 = load i64, i64* %buv, align 8
  %cmp98 = icmp ule i64 %102, %103
  %cond100 = select i1 %cmp98, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  %104 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %cond100, %struct.sv** %104, align 8
  %105 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %105, %struct.sv*** @PL_stack_sp, align 8
  %106 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next101 = getelementptr inbounds %struct.op, %struct.op* %106, i32 0, i32 0
  %107 = load %struct.op*, %struct.op** %op_next101, align 8
  store %struct.op* %107, %struct.op** %retval
  br label %return

if.end.102:                                       ; preds = %land.lhs.true.89, %if.end.86
  %108 = load i8, i8* %auvok, align 1
  %tobool103 = icmp ne i8 %108, 0
  br i1 %tobool103, label %if.then.104, label %if.end.121

if.then.104:                                      ; preds = %if.end.102
  %109 = load %struct.sv**, %struct.sv*** %sp, align 8
  %110 = load %struct.sv*, %struct.sv** %109, align 8
  %sv_any107 = getelementptr inbounds %struct.sv, %struct.sv* %110, i32 0, i32 0
  %111 = load i8*, i8** %sv_any107, align 8
  %112 = bitcast i8* %111 to %struct.xpviv*
  %xiv_iv108 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %112, i32 0, i32 3
  %113 = load i64, i64* %xiv_iv108, align 8
  store i64 %113, i64* %biv106, align 8
  %114 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr109 = getelementptr inbounds %struct.sv*, %struct.sv** %114, i32 -1
  store %struct.sv** %incdec.ptr109, %struct.sv*** %sp, align 8
  %115 = load i64, i64* %biv106, align 8
  %cmp110 = icmp slt i64 %115, 0
  br i1 %cmp110, label %if.then.112, label %if.end.114

if.then.112:                                      ; preds = %if.then.104
  %116 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* @PL_sv_no, %struct.sv** %116, align 8
  %117 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %117, %struct.sv*** @PL_stack_sp, align 8
  %118 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next113 = getelementptr inbounds %struct.op, %struct.op* %118, i32 0, i32 0
  %119 = load %struct.op*, %struct.op** %op_next113, align 8
  store %struct.op* %119, %struct.op** %retval
  br label %return

if.end.114:                                       ; preds = %if.then.104
  %120 = load %struct.sv**, %struct.sv*** %sp, align 8
  %121 = load %struct.sv*, %struct.sv** %120, align 8
  %sv_any115 = getelementptr inbounds %struct.sv, %struct.sv* %121, i32 0, i32 0
  %122 = load i8*, i8** %sv_any115, align 8
  %123 = bitcast i8* %122 to %struct.xpvuv*
  %xuv_uv116 = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %123, i32 0, i32 3
  %124 = load i64, i64* %xuv_uv116, align 8
  store i64 %124, i64* %auv105, align 8
  %125 = load i64, i64* %auv105, align 8
  %126 = load i64, i64* %biv106, align 8
  %cmp117 = icmp ule i64 %125, %126
  %cond119 = select i1 %cmp117, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  %127 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %cond119, %struct.sv** %127, align 8
  %128 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %128, %struct.sv*** @PL_stack_sp, align 8
  %129 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next120 = getelementptr inbounds %struct.op, %struct.op* %129, i32 0, i32 0
  %130 = load %struct.op*, %struct.op** %op_next120, align 8
  store %struct.op* %130, %struct.op** %retval
  br label %return

if.end.121:                                       ; preds = %if.end.102
  %131 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr124 = getelementptr inbounds %struct.sv*, %struct.sv** %131, i64 -1
  %132 = load %struct.sv*, %struct.sv** %add.ptr124, align 8
  %sv_any125 = getelementptr inbounds %struct.sv, %struct.sv* %132, i32 0, i32 0
  %133 = load i8*, i8** %sv_any125, align 8
  %134 = bitcast i8* %133 to %struct.xpviv*
  %xiv_iv126 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %134, i32 0, i32 3
  %135 = load i64, i64* %xiv_iv126, align 8
  store i64 %135, i64* %aiv122, align 8
  %136 = load i64, i64* %aiv122, align 8
  %cmp127 = icmp slt i64 %136, 0
  br i1 %cmp127, label %if.then.129, label %if.end.132

if.then.129:                                      ; preds = %if.end.121
  %137 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr130 = getelementptr inbounds %struct.sv*, %struct.sv** %137, i32 -1
  store %struct.sv** %incdec.ptr130, %struct.sv*** %sp, align 8
  %138 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* @PL_sv_yes, %struct.sv** %138, align 8
  %139 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %139, %struct.sv*** @PL_stack_sp, align 8
  %140 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next131 = getelementptr inbounds %struct.op, %struct.op* %140, i32 0, i32 0
  %141 = load %struct.op*, %struct.op** %op_next131, align 8
  store %struct.op* %141, %struct.op** %retval
  br label %return

if.end.132:                                       ; preds = %if.end.121
  %142 = load %struct.sv**, %struct.sv*** %sp, align 8
  %143 = load %struct.sv*, %struct.sv** %142, align 8
  %sv_any133 = getelementptr inbounds %struct.sv, %struct.sv* %143, i32 0, i32 0
  %144 = load i8*, i8** %sv_any133, align 8
  %145 = bitcast i8* %144 to %struct.xpvuv*
  %xuv_uv134 = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %145, i32 0, i32 3
  %146 = load i64, i64* %xuv_uv134, align 8
  store i64 %146, i64* %buv123, align 8
  %147 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr135 = getelementptr inbounds %struct.sv*, %struct.sv** %147, i32 -1
  store %struct.sv** %incdec.ptr135, %struct.sv*** %sp, align 8
  %148 = load i64, i64* %aiv122, align 8
  %149 = load i64, i64* %buv123, align 8
  %cmp136 = icmp ule i64 %148, %149
  %cond138 = select i1 %cmp136, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  %150 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %cond138, %struct.sv** %150, align 8
  %151 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %151, %struct.sv*** @PL_stack_sp, align 8
  %152 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next139 = getelementptr inbounds %struct.op, %struct.op* %152, i32 0, i32 0
  %153 = load %struct.op*, %struct.op** %op_next139, align 8
  store %struct.op* %153, %struct.op** %retval
  br label %return

if.end.140:                                       ; preds = %if.end.57
  br label %if.end.169

if.else:                                          ; preds = %if.end.24
  %154 = load %struct.sv**, %struct.sv*** %sp, align 8
  %155 = load %struct.sv*, %struct.sv** %154, align 8
  %sv_flags141 = getelementptr inbounds %struct.sv, %struct.sv* %155, i32 0, i32 2
  %156 = load i32, i32* %sv_flags141, align 4
  %and142 = and i32 %156, 524288
  %tobool143 = icmp ne i32 %and142, 0
  br i1 %tobool143, label %land.lhs.true.144, label %if.end.168

land.lhs.true.144:                                ; preds = %if.else
  %157 = load %struct.sv**, %struct.sv*** %sp, align 8
  %158 = load %struct.sv*, %struct.sv** %157, align 8
  %sv_flags145 = getelementptr inbounds %struct.sv, %struct.sv* %158, i32 0, i32 2
  %159 = load i32, i32* %sv_flags145, align 4
  %and146 = and i32 %159, 268435456
  %tobool147 = icmp ne i32 %and146, 0
  br i1 %tobool147, label %if.end.168, label %land.lhs.true.148

land.lhs.true.148:                                ; preds = %land.lhs.true.144
  %160 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr149 = getelementptr inbounds %struct.sv*, %struct.sv** %160, i64 -1
  %161 = load %struct.sv*, %struct.sv** %add.ptr149, align 8
  %sv_flags150 = getelementptr inbounds %struct.sv, %struct.sv* %161, i32 0, i32 2
  %162 = load i32, i32* %sv_flags150, align 4
  %and151 = and i32 %162, 524288
  %tobool152 = icmp ne i32 %and151, 0
  br i1 %tobool152, label %land.lhs.true.153, label %if.end.168

land.lhs.true.153:                                ; preds = %land.lhs.true.148
  %163 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr154 = getelementptr inbounds %struct.sv*, %struct.sv** %163, i64 -1
  %164 = load %struct.sv*, %struct.sv** %add.ptr154, align 8
  %sv_flags155 = getelementptr inbounds %struct.sv, %struct.sv* %164, i32 0, i32 2
  %165 = load i32, i32* %sv_flags155, align 4
  %and156 = and i32 %165, 268435456
  %tobool157 = icmp ne i32 %and156, 0
  br i1 %tobool157, label %if.end.168, label %if.then.158

if.then.158:                                      ; preds = %land.lhs.true.153
  %166 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr159 = getelementptr inbounds %struct.sv*, %struct.sv** %166, i32 -1
  store %struct.sv** %incdec.ptr159, %struct.sv*** %sp, align 8
  %167 = load %struct.sv**, %struct.sv*** %sp, align 8
  %168 = load %struct.sv*, %struct.sv** %167, align 8
  %sv_any160 = getelementptr inbounds %struct.sv, %struct.sv* %168, i32 0, i32 0
  %169 = load i8*, i8** %sv_any160, align 8
  %170 = bitcast i8* %169 to %struct.xrv*
  %xrv_rv = getelementptr inbounds %struct.xrv, %struct.xrv* %170, i32 0, i32 0
  %171 = load %struct.sv*, %struct.sv** %xrv_rv, align 8
  %172 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr161 = getelementptr inbounds %struct.sv*, %struct.sv** %172, i64 1
  %173 = load %struct.sv*, %struct.sv** %add.ptr161, align 8
  %sv_any162 = getelementptr inbounds %struct.sv, %struct.sv* %173, i32 0, i32 0
  %174 = load i8*, i8** %sv_any162, align 8
  %175 = bitcast i8* %174 to %struct.xrv*
  %xrv_rv163 = getelementptr inbounds %struct.xrv, %struct.xrv* %175, i32 0, i32 0
  %176 = load %struct.sv*, %struct.sv** %xrv_rv163, align 8
  %cmp164 = icmp ule %struct.sv* %171, %176
  %cond166 = select i1 %cmp164, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  %177 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %cond166, %struct.sv** %177, align 8
  %178 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %178, %struct.sv*** @PL_stack_sp, align 8
  %179 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next167 = getelementptr inbounds %struct.op, %struct.op* %179, i32 0, i32 0
  %180 = load %struct.op*, %struct.op** %op_next167, align 8
  store %struct.op* %180, %struct.op** %retval
  br label %return

if.end.168:                                       ; preds = %land.lhs.true.153, %land.lhs.true.148, %land.lhs.true.144, %if.else
  br label %if.end.169

if.end.169:                                       ; preds = %if.end.168, %if.end.140
  %181 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr170 = getelementptr inbounds %struct.sv*, %struct.sv** %181, i32 -1
  store %struct.sv** %incdec.ptr170, %struct.sv*** %sp, align 8
  %182 = load %struct.sv*, %struct.sv** %181, align 8
  store %struct.sv* %182, %struct.sv** @PL_Sv, align 8
  %183 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags171 = getelementptr inbounds %struct.sv, %struct.sv* %183, i32 0, i32 2
  %184 = load i32, i32* %sv_flags171, align 4
  %and172 = and i32 %184, 131072
  %tobool173 = icmp ne i32 %and172, 0
  br i1 %tobool173, label %cond.true.174, label %cond.false.176

cond.true.174:                                    ; preds = %if.end.169
  %185 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any175 = getelementptr inbounds %struct.sv, %struct.sv* %185, i32 0, i32 0
  %186 = load i8*, i8** %sv_any175, align 8
  %187 = bitcast i8* %186 to %struct.xpvnv*
  %xnv_nv = getelementptr inbounds %struct.xpvnv, %struct.xpvnv* %187, i32 0, i32 4
  %188 = load double, double* %xnv_nv, align 8
  br label %cond.end.178

cond.false.176:                                   ; preds = %if.end.169
  %189 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call177 = call double @Perl_sv_2nv(%struct.sv* %189)
  br label %cond.end.178

cond.end.178:                                     ; preds = %cond.false.176, %cond.true.174
  %cond179 = phi double [ %188, %cond.true.174 ], [ %call177, %cond.false.176 ]
  store double %cond179, double* %value, align 8
  %190 = load %struct.sv**, %struct.sv*** %sp, align 8
  %191 = load %struct.sv*, %struct.sv** %190, align 8
  %sv_flags180 = getelementptr inbounds %struct.sv, %struct.sv* %191, i32 0, i32 2
  %192 = load i32, i32* %sv_flags180, align 4
  %and181 = and i32 %192, 131072
  %tobool182 = icmp ne i32 %and181, 0
  br i1 %tobool182, label %cond.true.183, label %cond.false.186

cond.true.183:                                    ; preds = %cond.end.178
  %193 = load %struct.sv**, %struct.sv*** %sp, align 8
  %194 = load %struct.sv*, %struct.sv** %193, align 8
  %sv_any184 = getelementptr inbounds %struct.sv, %struct.sv* %194, i32 0, i32 0
  %195 = load i8*, i8** %sv_any184, align 8
  %196 = bitcast i8* %195 to %struct.xpvnv*
  %xnv_nv185 = getelementptr inbounds %struct.xpvnv, %struct.xpvnv* %196, i32 0, i32 4
  %197 = load double, double* %xnv_nv185, align 8
  br label %cond.end.188

cond.false.186:                                   ; preds = %cond.end.178
  %198 = load %struct.sv**, %struct.sv*** %sp, align 8
  %199 = load %struct.sv*, %struct.sv** %198, align 8
  %call187 = call double @Perl_sv_2nv(%struct.sv* %199)
  br label %cond.end.188

cond.end.188:                                     ; preds = %cond.false.186, %cond.true.183
  %cond189 = phi double [ %197, %cond.true.183 ], [ %call187, %cond.false.186 ]
  %200 = load double, double* %value, align 8
  %cmp190 = fcmp ole double %cond189, %200
  %cond192 = select i1 %cmp190, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  %201 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %cond192, %struct.sv** %201, align 8
  %202 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %202, %struct.sv*** @PL_stack_sp, align 8
  %203 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next193 = getelementptr inbounds %struct.op, %struct.op* %203, i32 0, i32 0
  %204 = load %struct.op*, %struct.op** %op_next193, align 8
  store %struct.op* %204, %struct.op** %retval
  br label %return

return:                                           ; preds = %cond.end.188, %if.then.158, %if.end.132, %if.then.129, %if.end.114, %if.then.112, %if.then.92, %if.then.75, %if.then.6
  %205 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %205
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_ge() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %right = alloca %struct.sv*, align 8
  %left = alloca %struct.sv*, align 8
  %auvok = alloca i8, align 1
  %buvok = alloca i8, align 1
  %aiv = alloca i64, align 8
  %biv = alloca i64, align 8
  %auv = alloca i64, align 8
  %buv = alloca i64, align 8
  %auv105 = alloca i64, align 8
  %biv106 = alloca i64, align 8
  %aiv122 = alloca i64, align 8
  %buv123 = alloca i64, align 8
  %value = alloca double, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load i64, i64* @PL_amagic_generation, align 8
  %tobool = icmp ne i64 %1, 0
  br i1 %tobool, label %if.then, label %if.end.7

if.then:                                          ; preds = %entry
  %2 = load %struct.sv**, %struct.sv*** %sp, align 8
  %3 = load %struct.sv*, %struct.sv** %2, align 8
  store %struct.sv* %3, %struct.sv** %right, align 8
  %4 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %4, i64 -1
  %5 = load %struct.sv*, %struct.sv** %add.ptr, align 8
  store %struct.sv* %5, %struct.sv** %left, align 8
  %6 = load %struct.sv*, %struct.sv** %left, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %6, i32 0, i32 2
  %7 = load i32, i32* %sv_flags, align 4
  %and = and i32 %7, 268435456
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %8 = load %struct.sv*, %struct.sv** %right, align 8
  %sv_flags2 = getelementptr inbounds %struct.sv, %struct.sv* %8, i32 0, i32 2
  %9 = load i32, i32* %sv_flags2, align 4
  %and3 = and i32 %9, 268435456
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %10 = load %struct.sv*, %struct.sv** %left, align 8
  %11 = load %struct.sv*, %struct.sv** %right, align 8
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %10, %struct.sv* %11, i32 31, i32 0)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool5 = icmp ne %struct.sv* %call, null
  br i1 %tobool5, label %if.then.6, label %if.end

if.then.6:                                        ; preds = %land.lhs.true
  %12 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %12, %struct.sv*** %sp, align 8
  %13 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %13, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %14 = load %struct.sv*, %struct.sv** %13, align 8
  %15 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %16 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %15, %struct.sv** %16, align 8
  %17 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %17, %struct.sv*** @PL_stack_sp, align 8
  %18 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %18, i32 0, i32 0
  %19 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %19, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %land.lhs.true, %lor.lhs.false
  br label %if.end.7

if.end.7:                                         ; preds = %if.end, %entry
  %20 = load %struct.sv**, %struct.sv*** %sp, align 8
  %21 = load %struct.sv*, %struct.sv** %20, align 8
  %sv_flags8 = getelementptr inbounds %struct.sv, %struct.sv* %21, i32 0, i32 2
  %22 = load i32, i32* %sv_flags8, align 4
  %and9 = and i32 %22, 16777216
  %tobool10 = icmp ne i32 %and9, 0
  br i1 %tobool10, label %if.end.24, label %land.lhs.true.11

land.lhs.true.11:                                 ; preds = %if.end.7
  %23 = load %struct.sv**, %struct.sv*** %sp, align 8
  %24 = load %struct.sv*, %struct.sv** %23, align 8
  %sv_flags12 = getelementptr inbounds %struct.sv, %struct.sv* %24, i32 0, i32 2
  %25 = load i32, i32* %sv_flags12, align 4
  %and13 = and i32 %25, 131072
  %tobool14 = icmp ne i32 %and13, 0
  br i1 %tobool14, label %if.then.19, label %lor.lhs.false.15

lor.lhs.false.15:                                 ; preds = %land.lhs.true.11
  %26 = load %struct.sv**, %struct.sv*** %sp, align 8
  %27 = load %struct.sv*, %struct.sv** %26, align 8
  %sv_flags16 = getelementptr inbounds %struct.sv, %struct.sv* %27, i32 0, i32 2
  %28 = load i32, i32* %sv_flags16, align 4
  %and17 = and i32 %28, 262144
  %tobool18 = icmp ne i32 %and17, 0
  br i1 %tobool18, label %if.then.19, label %if.end.24

if.then.19:                                       ; preds = %lor.lhs.false.15, %land.lhs.true.11
  %29 = load %struct.sv**, %struct.sv*** %sp, align 8
  %30 = load %struct.sv*, %struct.sv** %29, align 8
  %sv_flags20 = getelementptr inbounds %struct.sv, %struct.sv* %30, i32 0, i32 2
  %31 = load i32, i32* %sv_flags20, align 4
  %and21 = and i32 %31, 65536
  %tobool22 = icmp ne i32 %and21, 0
  br i1 %tobool22, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.19
  %32 = load %struct.sv**, %struct.sv*** %sp, align 8
  %33 = load %struct.sv*, %struct.sv** %32, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %33, i32 0, i32 0
  %34 = load i8*, i8** %sv_any, align 8
  %35 = bitcast i8* %34 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %35, i32 0, i32 3
  %36 = load i64, i64* %xiv_iv, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then.19
  %37 = load %struct.sv**, %struct.sv*** %sp, align 8
  %38 = load %struct.sv*, %struct.sv** %37, align 8
  %call23 = call i64 @Perl_sv_2iv(%struct.sv* %38)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %36, %cond.true ], [ %call23, %cond.false ]
  br label %if.end.24

if.end.24:                                        ; preds = %cond.end, %lor.lhs.false.15, %if.end.7
  %39 = load %struct.sv**, %struct.sv*** %sp, align 8
  %40 = load %struct.sv*, %struct.sv** %39, align 8
  %sv_flags25 = getelementptr inbounds %struct.sv, %struct.sv* %40, i32 0, i32 2
  %41 = load i32, i32* %sv_flags25, align 4
  %and26 = and i32 %41, 65536
  %tobool27 = icmp ne i32 %and26, 0
  br i1 %tobool27, label %if.then.28, label %if.else

if.then.28:                                       ; preds = %if.end.24
  %42 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr29 = getelementptr inbounds %struct.sv*, %struct.sv** %42, i64 -1
  %43 = load %struct.sv*, %struct.sv** %add.ptr29, align 8
  %sv_flags30 = getelementptr inbounds %struct.sv, %struct.sv* %43, i32 0, i32 2
  %44 = load i32, i32* %sv_flags30, align 4
  %and31 = and i32 %44, 16777216
  %tobool32 = icmp ne i32 %and31, 0
  br i1 %tobool32, label %if.end.57, label %land.lhs.true.33

land.lhs.true.33:                                 ; preds = %if.then.28
  %45 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr34 = getelementptr inbounds %struct.sv*, %struct.sv** %45, i64 -1
  %46 = load %struct.sv*, %struct.sv** %add.ptr34, align 8
  %sv_flags35 = getelementptr inbounds %struct.sv, %struct.sv* %46, i32 0, i32 2
  %47 = load i32, i32* %sv_flags35, align 4
  %and36 = and i32 %47, 131072
  %tobool37 = icmp ne i32 %and36, 0
  br i1 %tobool37, label %if.then.43, label %lor.lhs.false.38

lor.lhs.false.38:                                 ; preds = %land.lhs.true.33
  %48 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr39 = getelementptr inbounds %struct.sv*, %struct.sv** %48, i64 -1
  %49 = load %struct.sv*, %struct.sv** %add.ptr39, align 8
  %sv_flags40 = getelementptr inbounds %struct.sv, %struct.sv* %49, i32 0, i32 2
  %50 = load i32, i32* %sv_flags40, align 4
  %and41 = and i32 %50, 262144
  %tobool42 = icmp ne i32 %and41, 0
  br i1 %tobool42, label %if.then.43, label %if.end.57

if.then.43:                                       ; preds = %lor.lhs.false.38, %land.lhs.true.33
  %51 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr44 = getelementptr inbounds %struct.sv*, %struct.sv** %51, i64 -1
  %52 = load %struct.sv*, %struct.sv** %add.ptr44, align 8
  %sv_flags45 = getelementptr inbounds %struct.sv, %struct.sv* %52, i32 0, i32 2
  %53 = load i32, i32* %sv_flags45, align 4
  %and46 = and i32 %53, 65536
  %tobool47 = icmp ne i32 %and46, 0
  br i1 %tobool47, label %cond.true.48, label %cond.false.52

cond.true.48:                                     ; preds = %if.then.43
  %54 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr49 = getelementptr inbounds %struct.sv*, %struct.sv** %54, i64 -1
  %55 = load %struct.sv*, %struct.sv** %add.ptr49, align 8
  %sv_any50 = getelementptr inbounds %struct.sv, %struct.sv* %55, i32 0, i32 0
  %56 = load i8*, i8** %sv_any50, align 8
  %57 = bitcast i8* %56 to %struct.xpviv*
  %xiv_iv51 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %57, i32 0, i32 3
  %58 = load i64, i64* %xiv_iv51, align 8
  br label %cond.end.55

cond.false.52:                                    ; preds = %if.then.43
  %59 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr53 = getelementptr inbounds %struct.sv*, %struct.sv** %59, i64 -1
  %60 = load %struct.sv*, %struct.sv** %add.ptr53, align 8
  %call54 = call i64 @Perl_sv_2iv(%struct.sv* %60)
  br label %cond.end.55

cond.end.55:                                      ; preds = %cond.false.52, %cond.true.48
  %cond56 = phi i64 [ %58, %cond.true.48 ], [ %call54, %cond.false.52 ]
  br label %if.end.57

if.end.57:                                        ; preds = %cond.end.55, %lor.lhs.false.38, %if.then.28
  %61 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr58 = getelementptr inbounds %struct.sv*, %struct.sv** %61, i64 -1
  %62 = load %struct.sv*, %struct.sv** %add.ptr58, align 8
  %sv_flags59 = getelementptr inbounds %struct.sv, %struct.sv* %62, i32 0, i32 2
  %63 = load i32, i32* %sv_flags59, align 4
  %and60 = and i32 %63, 65536
  %tobool61 = icmp ne i32 %and60, 0
  br i1 %tobool61, label %if.then.62, label %if.end.140

if.then.62:                                       ; preds = %if.end.57
  %64 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr63 = getelementptr inbounds %struct.sv*, %struct.sv** %64, i64 -1
  %65 = load %struct.sv*, %struct.sv** %add.ptr63, align 8
  %sv_flags64 = getelementptr inbounds %struct.sv, %struct.sv* %65, i32 0, i32 2
  %66 = load i32, i32* %sv_flags64, align 4
  %and65 = and i32 %66, -2147418112
  %cmp = icmp eq i32 %and65, -2147418112
  %conv = zext i1 %cmp to i32
  %conv66 = trunc i32 %conv to i8
  store i8 %conv66, i8* %auvok, align 1
  %67 = load %struct.sv**, %struct.sv*** %sp, align 8
  %68 = load %struct.sv*, %struct.sv** %67, align 8
  %sv_flags67 = getelementptr inbounds %struct.sv, %struct.sv* %68, i32 0, i32 2
  %69 = load i32, i32* %sv_flags67, align 4
  %and68 = and i32 %69, -2147418112
  %cmp69 = icmp eq i32 %and68, -2147418112
  %conv70 = zext i1 %cmp69 to i32
  %conv71 = trunc i32 %conv70 to i8
  store i8 %conv71, i8* %buvok, align 1
  %70 = load i8, i8* %auvok, align 1
  %tobool72 = icmp ne i8 %70, 0
  br i1 %tobool72, label %if.end.86, label %land.lhs.true.73

land.lhs.true.73:                                 ; preds = %if.then.62
  %71 = load i8, i8* %buvok, align 1
  %tobool74 = icmp ne i8 %71, 0
  br i1 %tobool74, label %if.end.86, label %if.then.75

if.then.75:                                       ; preds = %land.lhs.true.73
  %72 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr76 = getelementptr inbounds %struct.sv*, %struct.sv** %72, i64 -1
  %73 = load %struct.sv*, %struct.sv** %add.ptr76, align 8
  %sv_any77 = getelementptr inbounds %struct.sv, %struct.sv* %73, i32 0, i32 0
  %74 = load i8*, i8** %sv_any77, align 8
  %75 = bitcast i8* %74 to %struct.xpviv*
  %xiv_iv78 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %75, i32 0, i32 3
  %76 = load i64, i64* %xiv_iv78, align 8
  store i64 %76, i64* %aiv, align 8
  %77 = load %struct.sv**, %struct.sv*** %sp, align 8
  %78 = load %struct.sv*, %struct.sv** %77, align 8
  %sv_any79 = getelementptr inbounds %struct.sv, %struct.sv* %78, i32 0, i32 0
  %79 = load i8*, i8** %sv_any79, align 8
  %80 = bitcast i8* %79 to %struct.xpviv*
  %xiv_iv80 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %80, i32 0, i32 3
  %81 = load i64, i64* %xiv_iv80, align 8
  store i64 %81, i64* %biv, align 8
  %82 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr81 = getelementptr inbounds %struct.sv*, %struct.sv** %82, i32 -1
  store %struct.sv** %incdec.ptr81, %struct.sv*** %sp, align 8
  %83 = load i64, i64* %aiv, align 8
  %84 = load i64, i64* %biv, align 8
  %cmp82 = icmp sge i64 %83, %84
  %cond84 = select i1 %cmp82, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  %85 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %cond84, %struct.sv** %85, align 8
  %86 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %86, %struct.sv*** @PL_stack_sp, align 8
  %87 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next85 = getelementptr inbounds %struct.op, %struct.op* %87, i32 0, i32 0
  %88 = load %struct.op*, %struct.op** %op_next85, align 8
  store %struct.op* %88, %struct.op** %retval
  br label %return

if.end.86:                                        ; preds = %land.lhs.true.73, %if.then.62
  %89 = load i8, i8* %auvok, align 1
  %conv87 = sext i8 %89 to i32
  %tobool88 = icmp ne i32 %conv87, 0
  br i1 %tobool88, label %land.lhs.true.89, label %if.end.102

land.lhs.true.89:                                 ; preds = %if.end.86
  %90 = load i8, i8* %buvok, align 1
  %conv90 = sext i8 %90 to i32
  %tobool91 = icmp ne i32 %conv90, 0
  br i1 %tobool91, label %if.then.92, label %if.end.102

if.then.92:                                       ; preds = %land.lhs.true.89
  %91 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr93 = getelementptr inbounds %struct.sv*, %struct.sv** %91, i64 -1
  %92 = load %struct.sv*, %struct.sv** %add.ptr93, align 8
  %sv_any94 = getelementptr inbounds %struct.sv, %struct.sv* %92, i32 0, i32 0
  %93 = load i8*, i8** %sv_any94, align 8
  %94 = bitcast i8* %93 to %struct.xpvuv*
  %xuv_uv = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %94, i32 0, i32 3
  %95 = load i64, i64* %xuv_uv, align 8
  store i64 %95, i64* %auv, align 8
  %96 = load %struct.sv**, %struct.sv*** %sp, align 8
  %97 = load %struct.sv*, %struct.sv** %96, align 8
  %sv_any95 = getelementptr inbounds %struct.sv, %struct.sv* %97, i32 0, i32 0
  %98 = load i8*, i8** %sv_any95, align 8
  %99 = bitcast i8* %98 to %struct.xpvuv*
  %xuv_uv96 = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %99, i32 0, i32 3
  %100 = load i64, i64* %xuv_uv96, align 8
  store i64 %100, i64* %buv, align 8
  %101 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr97 = getelementptr inbounds %struct.sv*, %struct.sv** %101, i32 -1
  store %struct.sv** %incdec.ptr97, %struct.sv*** %sp, align 8
  %102 = load i64, i64* %auv, align 8
  %103 = load i64, i64* %buv, align 8
  %cmp98 = icmp uge i64 %102, %103
  %cond100 = select i1 %cmp98, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  %104 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %cond100, %struct.sv** %104, align 8
  %105 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %105, %struct.sv*** @PL_stack_sp, align 8
  %106 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next101 = getelementptr inbounds %struct.op, %struct.op* %106, i32 0, i32 0
  %107 = load %struct.op*, %struct.op** %op_next101, align 8
  store %struct.op* %107, %struct.op** %retval
  br label %return

if.end.102:                                       ; preds = %land.lhs.true.89, %if.end.86
  %108 = load i8, i8* %auvok, align 1
  %tobool103 = icmp ne i8 %108, 0
  br i1 %tobool103, label %if.then.104, label %if.end.121

if.then.104:                                      ; preds = %if.end.102
  %109 = load %struct.sv**, %struct.sv*** %sp, align 8
  %110 = load %struct.sv*, %struct.sv** %109, align 8
  %sv_any107 = getelementptr inbounds %struct.sv, %struct.sv* %110, i32 0, i32 0
  %111 = load i8*, i8** %sv_any107, align 8
  %112 = bitcast i8* %111 to %struct.xpviv*
  %xiv_iv108 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %112, i32 0, i32 3
  %113 = load i64, i64* %xiv_iv108, align 8
  store i64 %113, i64* %biv106, align 8
  %114 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr109 = getelementptr inbounds %struct.sv*, %struct.sv** %114, i32 -1
  store %struct.sv** %incdec.ptr109, %struct.sv*** %sp, align 8
  %115 = load i64, i64* %biv106, align 8
  %cmp110 = icmp slt i64 %115, 0
  br i1 %cmp110, label %if.then.112, label %if.end.114

if.then.112:                                      ; preds = %if.then.104
  %116 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* @PL_sv_yes, %struct.sv** %116, align 8
  %117 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %117, %struct.sv*** @PL_stack_sp, align 8
  %118 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next113 = getelementptr inbounds %struct.op, %struct.op* %118, i32 0, i32 0
  %119 = load %struct.op*, %struct.op** %op_next113, align 8
  store %struct.op* %119, %struct.op** %retval
  br label %return

if.end.114:                                       ; preds = %if.then.104
  %120 = load %struct.sv**, %struct.sv*** %sp, align 8
  %121 = load %struct.sv*, %struct.sv** %120, align 8
  %sv_any115 = getelementptr inbounds %struct.sv, %struct.sv* %121, i32 0, i32 0
  %122 = load i8*, i8** %sv_any115, align 8
  %123 = bitcast i8* %122 to %struct.xpvuv*
  %xuv_uv116 = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %123, i32 0, i32 3
  %124 = load i64, i64* %xuv_uv116, align 8
  store i64 %124, i64* %auv105, align 8
  %125 = load i64, i64* %auv105, align 8
  %126 = load i64, i64* %biv106, align 8
  %cmp117 = icmp uge i64 %125, %126
  %cond119 = select i1 %cmp117, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  %127 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %cond119, %struct.sv** %127, align 8
  %128 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %128, %struct.sv*** @PL_stack_sp, align 8
  %129 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next120 = getelementptr inbounds %struct.op, %struct.op* %129, i32 0, i32 0
  %130 = load %struct.op*, %struct.op** %op_next120, align 8
  store %struct.op* %130, %struct.op** %retval
  br label %return

if.end.121:                                       ; preds = %if.end.102
  %131 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr124 = getelementptr inbounds %struct.sv*, %struct.sv** %131, i64 -1
  %132 = load %struct.sv*, %struct.sv** %add.ptr124, align 8
  %sv_any125 = getelementptr inbounds %struct.sv, %struct.sv* %132, i32 0, i32 0
  %133 = load i8*, i8** %sv_any125, align 8
  %134 = bitcast i8* %133 to %struct.xpviv*
  %xiv_iv126 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %134, i32 0, i32 3
  %135 = load i64, i64* %xiv_iv126, align 8
  store i64 %135, i64* %aiv122, align 8
  %136 = load i64, i64* %aiv122, align 8
  %cmp127 = icmp slt i64 %136, 0
  br i1 %cmp127, label %if.then.129, label %if.end.132

if.then.129:                                      ; preds = %if.end.121
  %137 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr130 = getelementptr inbounds %struct.sv*, %struct.sv** %137, i32 -1
  store %struct.sv** %incdec.ptr130, %struct.sv*** %sp, align 8
  %138 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* @PL_sv_no, %struct.sv** %138, align 8
  %139 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %139, %struct.sv*** @PL_stack_sp, align 8
  %140 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next131 = getelementptr inbounds %struct.op, %struct.op* %140, i32 0, i32 0
  %141 = load %struct.op*, %struct.op** %op_next131, align 8
  store %struct.op* %141, %struct.op** %retval
  br label %return

if.end.132:                                       ; preds = %if.end.121
  %142 = load %struct.sv**, %struct.sv*** %sp, align 8
  %143 = load %struct.sv*, %struct.sv** %142, align 8
  %sv_any133 = getelementptr inbounds %struct.sv, %struct.sv* %143, i32 0, i32 0
  %144 = load i8*, i8** %sv_any133, align 8
  %145 = bitcast i8* %144 to %struct.xpvuv*
  %xuv_uv134 = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %145, i32 0, i32 3
  %146 = load i64, i64* %xuv_uv134, align 8
  store i64 %146, i64* %buv123, align 8
  %147 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr135 = getelementptr inbounds %struct.sv*, %struct.sv** %147, i32 -1
  store %struct.sv** %incdec.ptr135, %struct.sv*** %sp, align 8
  %148 = load i64, i64* %aiv122, align 8
  %149 = load i64, i64* %buv123, align 8
  %cmp136 = icmp uge i64 %148, %149
  %cond138 = select i1 %cmp136, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  %150 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %cond138, %struct.sv** %150, align 8
  %151 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %151, %struct.sv*** @PL_stack_sp, align 8
  %152 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next139 = getelementptr inbounds %struct.op, %struct.op* %152, i32 0, i32 0
  %153 = load %struct.op*, %struct.op** %op_next139, align 8
  store %struct.op* %153, %struct.op** %retval
  br label %return

if.end.140:                                       ; preds = %if.end.57
  br label %if.end.169

if.else:                                          ; preds = %if.end.24
  %154 = load %struct.sv**, %struct.sv*** %sp, align 8
  %155 = load %struct.sv*, %struct.sv** %154, align 8
  %sv_flags141 = getelementptr inbounds %struct.sv, %struct.sv* %155, i32 0, i32 2
  %156 = load i32, i32* %sv_flags141, align 4
  %and142 = and i32 %156, 524288
  %tobool143 = icmp ne i32 %and142, 0
  br i1 %tobool143, label %land.lhs.true.144, label %if.end.168

land.lhs.true.144:                                ; preds = %if.else
  %157 = load %struct.sv**, %struct.sv*** %sp, align 8
  %158 = load %struct.sv*, %struct.sv** %157, align 8
  %sv_flags145 = getelementptr inbounds %struct.sv, %struct.sv* %158, i32 0, i32 2
  %159 = load i32, i32* %sv_flags145, align 4
  %and146 = and i32 %159, 268435456
  %tobool147 = icmp ne i32 %and146, 0
  br i1 %tobool147, label %if.end.168, label %land.lhs.true.148

land.lhs.true.148:                                ; preds = %land.lhs.true.144
  %160 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr149 = getelementptr inbounds %struct.sv*, %struct.sv** %160, i64 -1
  %161 = load %struct.sv*, %struct.sv** %add.ptr149, align 8
  %sv_flags150 = getelementptr inbounds %struct.sv, %struct.sv* %161, i32 0, i32 2
  %162 = load i32, i32* %sv_flags150, align 4
  %and151 = and i32 %162, 524288
  %tobool152 = icmp ne i32 %and151, 0
  br i1 %tobool152, label %land.lhs.true.153, label %if.end.168

land.lhs.true.153:                                ; preds = %land.lhs.true.148
  %163 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr154 = getelementptr inbounds %struct.sv*, %struct.sv** %163, i64 -1
  %164 = load %struct.sv*, %struct.sv** %add.ptr154, align 8
  %sv_flags155 = getelementptr inbounds %struct.sv, %struct.sv* %164, i32 0, i32 2
  %165 = load i32, i32* %sv_flags155, align 4
  %and156 = and i32 %165, 268435456
  %tobool157 = icmp ne i32 %and156, 0
  br i1 %tobool157, label %if.end.168, label %if.then.158

if.then.158:                                      ; preds = %land.lhs.true.153
  %166 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr159 = getelementptr inbounds %struct.sv*, %struct.sv** %166, i32 -1
  store %struct.sv** %incdec.ptr159, %struct.sv*** %sp, align 8
  %167 = load %struct.sv**, %struct.sv*** %sp, align 8
  %168 = load %struct.sv*, %struct.sv** %167, align 8
  %sv_any160 = getelementptr inbounds %struct.sv, %struct.sv* %168, i32 0, i32 0
  %169 = load i8*, i8** %sv_any160, align 8
  %170 = bitcast i8* %169 to %struct.xrv*
  %xrv_rv = getelementptr inbounds %struct.xrv, %struct.xrv* %170, i32 0, i32 0
  %171 = load %struct.sv*, %struct.sv** %xrv_rv, align 8
  %172 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr161 = getelementptr inbounds %struct.sv*, %struct.sv** %172, i64 1
  %173 = load %struct.sv*, %struct.sv** %add.ptr161, align 8
  %sv_any162 = getelementptr inbounds %struct.sv, %struct.sv* %173, i32 0, i32 0
  %174 = load i8*, i8** %sv_any162, align 8
  %175 = bitcast i8* %174 to %struct.xrv*
  %xrv_rv163 = getelementptr inbounds %struct.xrv, %struct.xrv* %175, i32 0, i32 0
  %176 = load %struct.sv*, %struct.sv** %xrv_rv163, align 8
  %cmp164 = icmp uge %struct.sv* %171, %176
  %cond166 = select i1 %cmp164, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  %177 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %cond166, %struct.sv** %177, align 8
  %178 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %178, %struct.sv*** @PL_stack_sp, align 8
  %179 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next167 = getelementptr inbounds %struct.op, %struct.op* %179, i32 0, i32 0
  %180 = load %struct.op*, %struct.op** %op_next167, align 8
  store %struct.op* %180, %struct.op** %retval
  br label %return

if.end.168:                                       ; preds = %land.lhs.true.153, %land.lhs.true.148, %land.lhs.true.144, %if.else
  br label %if.end.169

if.end.169:                                       ; preds = %if.end.168, %if.end.140
  %181 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr170 = getelementptr inbounds %struct.sv*, %struct.sv** %181, i32 -1
  store %struct.sv** %incdec.ptr170, %struct.sv*** %sp, align 8
  %182 = load %struct.sv*, %struct.sv** %181, align 8
  store %struct.sv* %182, %struct.sv** @PL_Sv, align 8
  %183 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags171 = getelementptr inbounds %struct.sv, %struct.sv* %183, i32 0, i32 2
  %184 = load i32, i32* %sv_flags171, align 4
  %and172 = and i32 %184, 131072
  %tobool173 = icmp ne i32 %and172, 0
  br i1 %tobool173, label %cond.true.174, label %cond.false.176

cond.true.174:                                    ; preds = %if.end.169
  %185 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any175 = getelementptr inbounds %struct.sv, %struct.sv* %185, i32 0, i32 0
  %186 = load i8*, i8** %sv_any175, align 8
  %187 = bitcast i8* %186 to %struct.xpvnv*
  %xnv_nv = getelementptr inbounds %struct.xpvnv, %struct.xpvnv* %187, i32 0, i32 4
  %188 = load double, double* %xnv_nv, align 8
  br label %cond.end.178

cond.false.176:                                   ; preds = %if.end.169
  %189 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call177 = call double @Perl_sv_2nv(%struct.sv* %189)
  br label %cond.end.178

cond.end.178:                                     ; preds = %cond.false.176, %cond.true.174
  %cond179 = phi double [ %188, %cond.true.174 ], [ %call177, %cond.false.176 ]
  store double %cond179, double* %value, align 8
  %190 = load %struct.sv**, %struct.sv*** %sp, align 8
  %191 = load %struct.sv*, %struct.sv** %190, align 8
  %sv_flags180 = getelementptr inbounds %struct.sv, %struct.sv* %191, i32 0, i32 2
  %192 = load i32, i32* %sv_flags180, align 4
  %and181 = and i32 %192, 131072
  %tobool182 = icmp ne i32 %and181, 0
  br i1 %tobool182, label %cond.true.183, label %cond.false.186

cond.true.183:                                    ; preds = %cond.end.178
  %193 = load %struct.sv**, %struct.sv*** %sp, align 8
  %194 = load %struct.sv*, %struct.sv** %193, align 8
  %sv_any184 = getelementptr inbounds %struct.sv, %struct.sv* %194, i32 0, i32 0
  %195 = load i8*, i8** %sv_any184, align 8
  %196 = bitcast i8* %195 to %struct.xpvnv*
  %xnv_nv185 = getelementptr inbounds %struct.xpvnv, %struct.xpvnv* %196, i32 0, i32 4
  %197 = load double, double* %xnv_nv185, align 8
  br label %cond.end.188

cond.false.186:                                   ; preds = %cond.end.178
  %198 = load %struct.sv**, %struct.sv*** %sp, align 8
  %199 = load %struct.sv*, %struct.sv** %198, align 8
  %call187 = call double @Perl_sv_2nv(%struct.sv* %199)
  br label %cond.end.188

cond.end.188:                                     ; preds = %cond.false.186, %cond.true.183
  %cond189 = phi double [ %197, %cond.true.183 ], [ %call187, %cond.false.186 ]
  %200 = load double, double* %value, align 8
  %cmp190 = fcmp oge double %cond189, %200
  %cond192 = select i1 %cmp190, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  %201 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %cond192, %struct.sv** %201, align 8
  %202 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %202, %struct.sv*** @PL_stack_sp, align 8
  %203 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next193 = getelementptr inbounds %struct.op, %struct.op* %203, i32 0, i32 0
  %204 = load %struct.op*, %struct.op** %op_next193, align 8
  store %struct.op* %204, %struct.op** %retval
  br label %return

return:                                           ; preds = %cond.end.188, %if.then.158, %if.end.132, %if.then.129, %if.end.114, %if.then.112, %if.then.92, %if.then.75, %if.then.6
  %205 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %205
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_ne() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %right = alloca %struct.sv*, align 8
  %left = alloca %struct.sv*, align 8
  %auvok = alloca i8, align 1
  %buvok = alloca i8, align 1
  %buv = alloca i64, align 8
  %auv = alloca i64, align 8
  %iv = alloca i64, align 8
  %uv = alloca i64, align 8
  %value = alloca double, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load i64, i64* @PL_amagic_generation, align 8
  %tobool = icmp ne i64 %1, 0
  br i1 %tobool, label %if.then, label %if.end.7

if.then:                                          ; preds = %entry
  %2 = load %struct.sv**, %struct.sv*** %sp, align 8
  %3 = load %struct.sv*, %struct.sv** %2, align 8
  store %struct.sv* %3, %struct.sv** %right, align 8
  %4 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %4, i64 -1
  %5 = load %struct.sv*, %struct.sv** %add.ptr, align 8
  store %struct.sv* %5, %struct.sv** %left, align 8
  %6 = load %struct.sv*, %struct.sv** %left, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %6, i32 0, i32 2
  %7 = load i32, i32* %sv_flags, align 4
  %and = and i32 %7, 268435456
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %8 = load %struct.sv*, %struct.sv** %right, align 8
  %sv_flags2 = getelementptr inbounds %struct.sv, %struct.sv* %8, i32 0, i32 2
  %9 = load i32, i32* %sv_flags2, align 4
  %and3 = and i32 %9, 268435456
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %10 = load %struct.sv*, %struct.sv** %left, align 8
  %11 = load %struct.sv*, %struct.sv** %right, align 8
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %10, %struct.sv* %11, i32 33, i32 0)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool5 = icmp ne %struct.sv* %call, null
  br i1 %tobool5, label %if.then.6, label %if.end

if.then.6:                                        ; preds = %land.lhs.true
  %12 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %12, %struct.sv*** %sp, align 8
  %13 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %13, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %14 = load %struct.sv*, %struct.sv** %13, align 8
  %15 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %16 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %15, %struct.sv** %16, align 8
  %17 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %17, %struct.sv*** @PL_stack_sp, align 8
  %18 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %18, i32 0, i32 0
  %19 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %19, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %land.lhs.true, %lor.lhs.false
  br label %if.end.7

if.end.7:                                         ; preds = %if.end, %entry
  %20 = load %struct.sv**, %struct.sv*** %sp, align 8
  %21 = load %struct.sv*, %struct.sv** %20, align 8
  %sv_flags8 = getelementptr inbounds %struct.sv, %struct.sv* %21, i32 0, i32 2
  %22 = load i32, i32* %sv_flags8, align 4
  %and9 = and i32 %22, 524288
  %tobool10 = icmp ne i32 %and9, 0
  br i1 %tobool10, label %land.lhs.true.11, label %if.end.31

land.lhs.true.11:                                 ; preds = %if.end.7
  %23 = load %struct.sv**, %struct.sv*** %sp, align 8
  %24 = load %struct.sv*, %struct.sv** %23, align 8
  %sv_flags12 = getelementptr inbounds %struct.sv, %struct.sv* %24, i32 0, i32 2
  %25 = load i32, i32* %sv_flags12, align 4
  %and13 = and i32 %25, 268435456
  %tobool14 = icmp ne i32 %and13, 0
  br i1 %tobool14, label %if.end.31, label %land.lhs.true.15

land.lhs.true.15:                                 ; preds = %land.lhs.true.11
  %26 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr16 = getelementptr inbounds %struct.sv*, %struct.sv** %26, i64 -1
  %27 = load %struct.sv*, %struct.sv** %add.ptr16, align 8
  %sv_flags17 = getelementptr inbounds %struct.sv, %struct.sv* %27, i32 0, i32 2
  %28 = load i32, i32* %sv_flags17, align 4
  %and18 = and i32 %28, 524288
  %tobool19 = icmp ne i32 %and18, 0
  br i1 %tobool19, label %land.lhs.true.20, label %if.end.31

land.lhs.true.20:                                 ; preds = %land.lhs.true.15
  %29 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr21 = getelementptr inbounds %struct.sv*, %struct.sv** %29, i64 -1
  %30 = load %struct.sv*, %struct.sv** %add.ptr21, align 8
  %sv_flags22 = getelementptr inbounds %struct.sv, %struct.sv* %30, i32 0, i32 2
  %31 = load i32, i32* %sv_flags22, align 4
  %and23 = and i32 %31, 268435456
  %tobool24 = icmp ne i32 %and23, 0
  br i1 %tobool24, label %if.end.31, label %if.then.25

if.then.25:                                       ; preds = %land.lhs.true.20
  %32 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr26 = getelementptr inbounds %struct.sv*, %struct.sv** %32, i32 -1
  store %struct.sv** %incdec.ptr26, %struct.sv*** %sp, align 8
  %33 = load %struct.sv**, %struct.sv*** %sp, align 8
  %34 = load %struct.sv*, %struct.sv** %33, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %34, i32 0, i32 0
  %35 = load i8*, i8** %sv_any, align 8
  %36 = bitcast i8* %35 to %struct.xrv*
  %xrv_rv = getelementptr inbounds %struct.xrv, %struct.xrv* %36, i32 0, i32 0
  %37 = load %struct.sv*, %struct.sv** %xrv_rv, align 8
  %38 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr27 = getelementptr inbounds %struct.sv*, %struct.sv** %38, i64 1
  %39 = load %struct.sv*, %struct.sv** %add.ptr27, align 8
  %sv_any28 = getelementptr inbounds %struct.sv, %struct.sv* %39, i32 0, i32 0
  %40 = load i8*, i8** %sv_any28, align 8
  %41 = bitcast i8* %40 to %struct.xrv*
  %xrv_rv29 = getelementptr inbounds %struct.xrv, %struct.xrv* %41, i32 0, i32 0
  %42 = load %struct.sv*, %struct.sv** %xrv_rv29, align 8
  %cmp = icmp ne %struct.sv* %37, %42
  %cond = select i1 %cmp, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  %43 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %cond, %struct.sv** %43, align 8
  %44 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %44, %struct.sv*** @PL_stack_sp, align 8
  %45 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next30 = getelementptr inbounds %struct.op, %struct.op* %45, i32 0, i32 0
  %46 = load %struct.op*, %struct.op** %op_next30, align 8
  store %struct.op* %46, %struct.op** %retval
  br label %return

if.end.31:                                        ; preds = %land.lhs.true.20, %land.lhs.true.15, %land.lhs.true.11, %if.end.7
  %47 = load %struct.sv**, %struct.sv*** %sp, align 8
  %48 = load %struct.sv*, %struct.sv** %47, align 8
  %sv_flags32 = getelementptr inbounds %struct.sv, %struct.sv* %48, i32 0, i32 2
  %49 = load i32, i32* %sv_flags32, align 4
  %and33 = and i32 %49, 16777216
  %tobool34 = icmp ne i32 %and33, 0
  br i1 %tobool34, label %if.end.50, label %land.lhs.true.35

land.lhs.true.35:                                 ; preds = %if.end.31
  %50 = load %struct.sv**, %struct.sv*** %sp, align 8
  %51 = load %struct.sv*, %struct.sv** %50, align 8
  %sv_flags36 = getelementptr inbounds %struct.sv, %struct.sv* %51, i32 0, i32 2
  %52 = load i32, i32* %sv_flags36, align 4
  %and37 = and i32 %52, 131072
  %tobool38 = icmp ne i32 %and37, 0
  br i1 %tobool38, label %if.then.43, label %lor.lhs.false.39

lor.lhs.false.39:                                 ; preds = %land.lhs.true.35
  %53 = load %struct.sv**, %struct.sv*** %sp, align 8
  %54 = load %struct.sv*, %struct.sv** %53, align 8
  %sv_flags40 = getelementptr inbounds %struct.sv, %struct.sv* %54, i32 0, i32 2
  %55 = load i32, i32* %sv_flags40, align 4
  %and41 = and i32 %55, 262144
  %tobool42 = icmp ne i32 %and41, 0
  br i1 %tobool42, label %if.then.43, label %if.end.50

if.then.43:                                       ; preds = %lor.lhs.false.39, %land.lhs.true.35
  %56 = load %struct.sv**, %struct.sv*** %sp, align 8
  %57 = load %struct.sv*, %struct.sv** %56, align 8
  %sv_flags44 = getelementptr inbounds %struct.sv, %struct.sv* %57, i32 0, i32 2
  %58 = load i32, i32* %sv_flags44, align 4
  %and45 = and i32 %58, 65536
  %tobool46 = icmp ne i32 %and45, 0
  br i1 %tobool46, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.43
  %59 = load %struct.sv**, %struct.sv*** %sp, align 8
  %60 = load %struct.sv*, %struct.sv** %59, align 8
  %sv_any47 = getelementptr inbounds %struct.sv, %struct.sv* %60, i32 0, i32 0
  %61 = load i8*, i8** %sv_any47, align 8
  %62 = bitcast i8* %61 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %62, i32 0, i32 3
  %63 = load i64, i64* %xiv_iv, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then.43
  %64 = load %struct.sv**, %struct.sv*** %sp, align 8
  %65 = load %struct.sv*, %struct.sv** %64, align 8
  %call48 = call i64 @Perl_sv_2iv(%struct.sv* %65)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond49 = phi i64 [ %63, %cond.true ], [ %call48, %cond.false ]
  br label %if.end.50

if.end.50:                                        ; preds = %cond.end, %lor.lhs.false.39, %if.end.31
  %66 = load %struct.sv**, %struct.sv*** %sp, align 8
  %67 = load %struct.sv*, %struct.sv** %66, align 8
  %sv_flags51 = getelementptr inbounds %struct.sv, %struct.sv* %67, i32 0, i32 2
  %68 = load i32, i32* %sv_flags51, align 4
  %and52 = and i32 %68, 65536
  %tobool53 = icmp ne i32 %and52, 0
  br i1 %tobool53, label %if.then.54, label %if.end.143

if.then.54:                                       ; preds = %if.end.50
  %69 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr55 = getelementptr inbounds %struct.sv*, %struct.sv** %69, i64 -1
  %70 = load %struct.sv*, %struct.sv** %add.ptr55, align 8
  %sv_flags56 = getelementptr inbounds %struct.sv, %struct.sv* %70, i32 0, i32 2
  %71 = load i32, i32* %sv_flags56, align 4
  %and57 = and i32 %71, 16777216
  %tobool58 = icmp ne i32 %and57, 0
  br i1 %tobool58, label %if.end.83, label %land.lhs.true.59

land.lhs.true.59:                                 ; preds = %if.then.54
  %72 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr60 = getelementptr inbounds %struct.sv*, %struct.sv** %72, i64 -1
  %73 = load %struct.sv*, %struct.sv** %add.ptr60, align 8
  %sv_flags61 = getelementptr inbounds %struct.sv, %struct.sv* %73, i32 0, i32 2
  %74 = load i32, i32* %sv_flags61, align 4
  %and62 = and i32 %74, 131072
  %tobool63 = icmp ne i32 %and62, 0
  br i1 %tobool63, label %if.then.69, label %lor.lhs.false.64

lor.lhs.false.64:                                 ; preds = %land.lhs.true.59
  %75 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr65 = getelementptr inbounds %struct.sv*, %struct.sv** %75, i64 -1
  %76 = load %struct.sv*, %struct.sv** %add.ptr65, align 8
  %sv_flags66 = getelementptr inbounds %struct.sv, %struct.sv* %76, i32 0, i32 2
  %77 = load i32, i32* %sv_flags66, align 4
  %and67 = and i32 %77, 262144
  %tobool68 = icmp ne i32 %and67, 0
  br i1 %tobool68, label %if.then.69, label %if.end.83

if.then.69:                                       ; preds = %lor.lhs.false.64, %land.lhs.true.59
  %78 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr70 = getelementptr inbounds %struct.sv*, %struct.sv** %78, i64 -1
  %79 = load %struct.sv*, %struct.sv** %add.ptr70, align 8
  %sv_flags71 = getelementptr inbounds %struct.sv, %struct.sv* %79, i32 0, i32 2
  %80 = load i32, i32* %sv_flags71, align 4
  %and72 = and i32 %80, 65536
  %tobool73 = icmp ne i32 %and72, 0
  br i1 %tobool73, label %cond.true.74, label %cond.false.78

cond.true.74:                                     ; preds = %if.then.69
  %81 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr75 = getelementptr inbounds %struct.sv*, %struct.sv** %81, i64 -1
  %82 = load %struct.sv*, %struct.sv** %add.ptr75, align 8
  %sv_any76 = getelementptr inbounds %struct.sv, %struct.sv* %82, i32 0, i32 0
  %83 = load i8*, i8** %sv_any76, align 8
  %84 = bitcast i8* %83 to %struct.xpviv*
  %xiv_iv77 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %84, i32 0, i32 3
  %85 = load i64, i64* %xiv_iv77, align 8
  br label %cond.end.81

cond.false.78:                                    ; preds = %if.then.69
  %86 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr79 = getelementptr inbounds %struct.sv*, %struct.sv** %86, i64 -1
  %87 = load %struct.sv*, %struct.sv** %add.ptr79, align 8
  %call80 = call i64 @Perl_sv_2iv(%struct.sv* %87)
  br label %cond.end.81

cond.end.81:                                      ; preds = %cond.false.78, %cond.true.74
  %cond82 = phi i64 [ %85, %cond.true.74 ], [ %call80, %cond.false.78 ]
  br label %if.end.83

if.end.83:                                        ; preds = %cond.end.81, %lor.lhs.false.64, %if.then.54
  %88 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr84 = getelementptr inbounds %struct.sv*, %struct.sv** %88, i64 -1
  %89 = load %struct.sv*, %struct.sv** %add.ptr84, align 8
  %sv_flags85 = getelementptr inbounds %struct.sv, %struct.sv* %89, i32 0, i32 2
  %90 = load i32, i32* %sv_flags85, align 4
  %and86 = and i32 %90, 65536
  %tobool87 = icmp ne i32 %and86, 0
  br i1 %tobool87, label %if.then.88, label %if.end.142

if.then.88:                                       ; preds = %if.end.83
  %91 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr89 = getelementptr inbounds %struct.sv*, %struct.sv** %91, i64 -1
  %92 = load %struct.sv*, %struct.sv** %add.ptr89, align 8
  %sv_flags90 = getelementptr inbounds %struct.sv, %struct.sv* %92, i32 0, i32 2
  %93 = load i32, i32* %sv_flags90, align 4
  %and91 = and i32 %93, -2147418112
  %cmp92 = icmp eq i32 %and91, -2147418112
  %conv = zext i1 %cmp92 to i32
  %conv93 = trunc i32 %conv to i8
  store i8 %conv93, i8* %auvok, align 1
  %94 = load %struct.sv**, %struct.sv*** %sp, align 8
  %95 = load %struct.sv*, %struct.sv** %94, align 8
  %sv_flags94 = getelementptr inbounds %struct.sv, %struct.sv* %95, i32 0, i32 2
  %96 = load i32, i32* %sv_flags94, align 4
  %and95 = and i32 %96, -2147418112
  %cmp96 = icmp eq i32 %and95, -2147418112
  %conv97 = zext i1 %cmp96 to i32
  %conv98 = trunc i32 %conv97 to i8
  store i8 %conv98, i8* %buvok, align 1
  %97 = load i8, i8* %auvok, align 1
  %conv99 = sext i8 %97 to i32
  %98 = load i8, i8* %buvok, align 1
  %conv100 = sext i8 %98 to i32
  %cmp101 = icmp eq i32 %conv99, %conv100
  br i1 %cmp101, label %if.then.103, label %if.end.112

if.then.103:                                      ; preds = %if.then.88
  %99 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr104 = getelementptr inbounds %struct.sv*, %struct.sv** %99, i32 -1
  store %struct.sv** %incdec.ptr104, %struct.sv*** %sp, align 8
  %100 = load %struct.sv*, %struct.sv** %99, align 8
  %sv_any105 = getelementptr inbounds %struct.sv, %struct.sv* %100, i32 0, i32 0
  %101 = load i8*, i8** %sv_any105, align 8
  %102 = bitcast i8* %101 to %struct.xpvuv*
  %xuv_uv = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %102, i32 0, i32 3
  %103 = load i64, i64* %xuv_uv, align 8
  store i64 %103, i64* %buv, align 8
  %104 = load %struct.sv**, %struct.sv*** %sp, align 8
  %105 = load %struct.sv*, %struct.sv** %104, align 8
  %sv_any106 = getelementptr inbounds %struct.sv, %struct.sv* %105, i32 0, i32 0
  %106 = load i8*, i8** %sv_any106, align 8
  %107 = bitcast i8* %106 to %struct.xpvuv*
  %xuv_uv107 = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %107, i32 0, i32 3
  %108 = load i64, i64* %xuv_uv107, align 8
  store i64 %108, i64* %auv, align 8
  %109 = load i64, i64* %auv, align 8
  %110 = load i64, i64* %buv, align 8
  %cmp108 = icmp ne i64 %109, %110
  %cond110 = select i1 %cmp108, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  %111 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %cond110, %struct.sv** %111, align 8
  %112 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %112, %struct.sv*** @PL_stack_sp, align 8
  %113 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next111 = getelementptr inbounds %struct.op, %struct.op* %113, i32 0, i32 0
  %114 = load %struct.op*, %struct.op** %op_next111, align 8
  store %struct.op* %114, %struct.op** %retval
  br label %return

if.end.112:                                       ; preds = %if.then.88
  %115 = load i8, i8* %auvok, align 1
  %tobool113 = icmp ne i8 %115, 0
  br i1 %tobool113, label %if.then.114, label %if.else

if.then.114:                                      ; preds = %if.end.112
  %116 = load %struct.sv**, %struct.sv*** %sp, align 8
  %117 = load %struct.sv*, %struct.sv** %116, align 8
  %sv_any115 = getelementptr inbounds %struct.sv, %struct.sv* %117, i32 0, i32 0
  %118 = load i8*, i8** %sv_any115, align 8
  %119 = bitcast i8* %118 to %struct.xpviv*
  %xiv_iv116 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %119, i32 0, i32 3
  %120 = load i64, i64* %xiv_iv116, align 8
  store i64 %120, i64* %iv, align 8
  %121 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr117 = getelementptr inbounds %struct.sv*, %struct.sv** %121, i32 -1
  store %struct.sv** %incdec.ptr117, %struct.sv*** %sp, align 8
  %122 = load i64, i64* %iv, align 8
  %cmp118 = icmp slt i64 %122, 0
  br i1 %cmp118, label %if.then.120, label %if.end.122

if.then.120:                                      ; preds = %if.then.114
  %123 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* @PL_sv_yes, %struct.sv** %123, align 8
  %124 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %124, %struct.sv*** @PL_stack_sp, align 8
  %125 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next121 = getelementptr inbounds %struct.op, %struct.op* %125, i32 0, i32 0
  %126 = load %struct.op*, %struct.op** %op_next121, align 8
  store %struct.op* %126, %struct.op** %retval
  br label %return

if.end.122:                                       ; preds = %if.then.114
  %127 = load %struct.sv**, %struct.sv*** %sp, align 8
  %128 = load %struct.sv*, %struct.sv** %127, align 8
  %sv_any123 = getelementptr inbounds %struct.sv, %struct.sv* %128, i32 0, i32 0
  %129 = load i8*, i8** %sv_any123, align 8
  %130 = bitcast i8* %129 to %struct.xpvuv*
  %xuv_uv124 = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %130, i32 0, i32 3
  %131 = load i64, i64* %xuv_uv124, align 8
  store i64 %131, i64* %uv, align 8
  br label %if.end.137

if.else:                                          ; preds = %if.end.112
  %132 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr125 = getelementptr inbounds %struct.sv*, %struct.sv** %132, i64 -1
  %133 = load %struct.sv*, %struct.sv** %add.ptr125, align 8
  %sv_any126 = getelementptr inbounds %struct.sv, %struct.sv* %133, i32 0, i32 0
  %134 = load i8*, i8** %sv_any126, align 8
  %135 = bitcast i8* %134 to %struct.xpviv*
  %xiv_iv127 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %135, i32 0, i32 3
  %136 = load i64, i64* %xiv_iv127, align 8
  store i64 %136, i64* %iv, align 8
  %137 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr128 = getelementptr inbounds %struct.sv*, %struct.sv** %137, i32 -1
  store %struct.sv** %incdec.ptr128, %struct.sv*** %sp, align 8
  %138 = load i64, i64* %iv, align 8
  %cmp129 = icmp slt i64 %138, 0
  br i1 %cmp129, label %if.then.131, label %if.end.133

if.then.131:                                      ; preds = %if.else
  %139 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* @PL_sv_yes, %struct.sv** %139, align 8
  %140 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %140, %struct.sv*** @PL_stack_sp, align 8
  %141 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next132 = getelementptr inbounds %struct.op, %struct.op* %141, i32 0, i32 0
  %142 = load %struct.op*, %struct.op** %op_next132, align 8
  store %struct.op* %142, %struct.op** %retval
  br label %return

if.end.133:                                       ; preds = %if.else
  %143 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr134 = getelementptr inbounds %struct.sv*, %struct.sv** %143, i64 1
  %144 = load %struct.sv*, %struct.sv** %add.ptr134, align 8
  %sv_any135 = getelementptr inbounds %struct.sv, %struct.sv* %144, i32 0, i32 0
  %145 = load i8*, i8** %sv_any135, align 8
  %146 = bitcast i8* %145 to %struct.xpvuv*
  %xuv_uv136 = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %146, i32 0, i32 3
  %147 = load i64, i64* %xuv_uv136, align 8
  store i64 %147, i64* %uv, align 8
  br label %if.end.137

if.end.137:                                       ; preds = %if.end.133, %if.end.122
  %148 = load i64, i64* %iv, align 8
  %149 = load i64, i64* %uv, align 8
  %cmp138 = icmp ne i64 %148, %149
  %cond140 = select i1 %cmp138, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  %150 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %cond140, %struct.sv** %150, align 8
  %151 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %151, %struct.sv*** @PL_stack_sp, align 8
  %152 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next141 = getelementptr inbounds %struct.op, %struct.op* %152, i32 0, i32 0
  %153 = load %struct.op*, %struct.op** %op_next141, align 8
  store %struct.op* %153, %struct.op** %retval
  br label %return

if.end.142:                                       ; preds = %if.end.83
  br label %if.end.143

if.end.143:                                       ; preds = %if.end.142, %if.end.50
  %154 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr144 = getelementptr inbounds %struct.sv*, %struct.sv** %154, i32 -1
  store %struct.sv** %incdec.ptr144, %struct.sv*** %sp, align 8
  %155 = load %struct.sv*, %struct.sv** %154, align 8
  store %struct.sv* %155, %struct.sv** @PL_Sv, align 8
  %156 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags145 = getelementptr inbounds %struct.sv, %struct.sv* %156, i32 0, i32 2
  %157 = load i32, i32* %sv_flags145, align 4
  %and146 = and i32 %157, 131072
  %tobool147 = icmp ne i32 %and146, 0
  br i1 %tobool147, label %cond.true.148, label %cond.false.150

cond.true.148:                                    ; preds = %if.end.143
  %158 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any149 = getelementptr inbounds %struct.sv, %struct.sv* %158, i32 0, i32 0
  %159 = load i8*, i8** %sv_any149, align 8
  %160 = bitcast i8* %159 to %struct.xpvnv*
  %xnv_nv = getelementptr inbounds %struct.xpvnv, %struct.xpvnv* %160, i32 0, i32 4
  %161 = load double, double* %xnv_nv, align 8
  br label %cond.end.152

cond.false.150:                                   ; preds = %if.end.143
  %162 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call151 = call double @Perl_sv_2nv(%struct.sv* %162)
  br label %cond.end.152

cond.end.152:                                     ; preds = %cond.false.150, %cond.true.148
  %cond153 = phi double [ %161, %cond.true.148 ], [ %call151, %cond.false.150 ]
  store double %cond153, double* %value, align 8
  %163 = load %struct.sv**, %struct.sv*** %sp, align 8
  %164 = load %struct.sv*, %struct.sv** %163, align 8
  %sv_flags154 = getelementptr inbounds %struct.sv, %struct.sv* %164, i32 0, i32 2
  %165 = load i32, i32* %sv_flags154, align 4
  %and155 = and i32 %165, 131072
  %tobool156 = icmp ne i32 %and155, 0
  br i1 %tobool156, label %cond.true.157, label %cond.false.160

cond.true.157:                                    ; preds = %cond.end.152
  %166 = load %struct.sv**, %struct.sv*** %sp, align 8
  %167 = load %struct.sv*, %struct.sv** %166, align 8
  %sv_any158 = getelementptr inbounds %struct.sv, %struct.sv* %167, i32 0, i32 0
  %168 = load i8*, i8** %sv_any158, align 8
  %169 = bitcast i8* %168 to %struct.xpvnv*
  %xnv_nv159 = getelementptr inbounds %struct.xpvnv, %struct.xpvnv* %169, i32 0, i32 4
  %170 = load double, double* %xnv_nv159, align 8
  br label %cond.end.162

cond.false.160:                                   ; preds = %cond.end.152
  %171 = load %struct.sv**, %struct.sv*** %sp, align 8
  %172 = load %struct.sv*, %struct.sv** %171, align 8
  %call161 = call double @Perl_sv_2nv(%struct.sv* %172)
  br label %cond.end.162

cond.end.162:                                     ; preds = %cond.false.160, %cond.true.157
  %cond163 = phi double [ %170, %cond.true.157 ], [ %call161, %cond.false.160 ]
  %173 = load double, double* %value, align 8
  %cmp164 = fcmp une double %cond163, %173
  %cond166 = select i1 %cmp164, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  %174 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %cond166, %struct.sv** %174, align 8
  %175 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %175, %struct.sv*** @PL_stack_sp, align 8
  %176 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next167 = getelementptr inbounds %struct.op, %struct.op* %176, i32 0, i32 0
  %177 = load %struct.op*, %struct.op** %op_next167, align 8
  store %struct.op* %177, %struct.op** %retval
  br label %return

return:                                           ; preds = %cond.end.162, %if.end.137, %if.then.131, %if.then.120, %if.then.103, %if.then.25, %if.then.6
  %178 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %178
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_ncmp() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %right = alloca %struct.sv*, align 8
  %left = alloca %struct.sv*, align 8
  %tmp = alloca %struct.sv*, align 8
  %right41 = alloca i64, align 8
  %left44 = alloca i64, align 8
  %tmp57 = alloca %struct.sv*, align 8
  %leftuvok = alloca i8, align 1
  %rightuvok = alloca i8, align 1
  %value = alloca i32, align 4
  %leftiv = alloca i64, align 8
  %rightiv = alloca i64, align 8
  %leftuv = alloca i64, align 8
  %rightuv = alloca i64, align 8
  %leftuv178 = alloca i64, align 8
  %rightiv180 = alloca i64, align 8
  %leftiv203 = alloca i64, align 8
  %rightuv205 = alloca i64, align 8
  %tmp237 = alloca %struct.sv*, align 8
  %right242 = alloca double, align 8
  %left254 = alloca double, align 8
  %value266 = alloca i32, align 4
  %tmp307 = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 3
  %2 = load i64, i64* %op_targ, align 8
  %3 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 %2
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %4, %struct.sv** %targ, align 8
  %5 = load i64, i64* @PL_amagic_generation, align 8
  %tobool = icmp ne i64 %5, 0
  br i1 %tobool, label %if.then, label %if.end.21

if.then:                                          ; preds = %entry
  %6 = load %struct.sv**, %struct.sv*** %sp, align 8
  %7 = load %struct.sv*, %struct.sv** %6, align 8
  store %struct.sv* %7, %struct.sv** %right, align 8
  %8 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %8, i64 -1
  %9 = load %struct.sv*, %struct.sv** %add.ptr, align 8
  store %struct.sv* %9, %struct.sv** %left, align 8
  %10 = load %struct.sv*, %struct.sv** %left, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %10, i32 0, i32 2
  %11 = load i32, i32* %sv_flags, align 4
  %and = and i32 %11, 268435456
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %12 = load %struct.sv*, %struct.sv** %right, align 8
  %sv_flags2 = getelementptr inbounds %struct.sv, %struct.sv* %12, i32 0, i32 2
  %13 = load i32, i32* %sv_flags2, align 4
  %and3 = and i32 %13, 268435456
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %land.lhs.true, label %if.end.20

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %14 = load %struct.sv*, %struct.sv** %left, align 8
  %15 = load %struct.sv*, %struct.sv** %right, align 8
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %14, %struct.sv* %15, i32 34, i32 0)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool5 = icmp ne %struct.sv* %call, null
  br i1 %tobool5, label %if.then.6, label %if.end.20

if.then.6:                                        ; preds = %land.lhs.true
  %16 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %16, %struct.sv*** %sp, align 8
  %17 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %17, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %18 = load %struct.sv*, %struct.sv** %17, align 8
  %19 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %19, i32 0, i32 6
  %20 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %20 to i32
  %and7 = and i32 %conv, 64
  %tobool8 = icmp ne i32 %and7, 0
  br i1 %tobool8, label %if.then.13, label %lor.lhs.false.9

lor.lhs.false.9:                                  ; preds = %if.then.6
  %21 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags10 = getelementptr inbounds %struct.sv, %struct.sv* %21, i32 0, i32 2
  %22 = load i32, i32* %sv_flags10, align 4
  %and11 = and i32 %22, 1024
  %tobool12 = icmp ne i32 %and11, 0
  br i1 %tobool12, label %if.then.13, label %if.else

if.then.13:                                       ; preds = %lor.lhs.false.9, %if.then.6
  %23 = load %struct.sv*, %struct.sv** %targ, align 8
  %24 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  call void @Perl_sv_setsv_flags(%struct.sv* %23, %struct.sv* %24, i32 2)
  %25 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags14 = getelementptr inbounds %struct.sv, %struct.sv* %25, i32 0, i32 2
  %26 = load i32, i32* %sv_flags14, align 4
  %and15 = and i32 %26, 16384
  %tobool16 = icmp ne i32 %and15, 0
  br i1 %tobool16, label %if.then.17, label %if.end

if.then.17:                                       ; preds = %if.then.13
  %27 = load %struct.sv*, %struct.sv** %targ, align 8
  %call18 = call i32 @Perl_mg_set(%struct.sv* %27)
  br label %if.end

if.end:                                           ; preds = %if.then.17, %if.then.13
  %28 = load %struct.sv*, %struct.sv** %targ, align 8
  %29 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %28, %struct.sv** %29, align 8
  store %struct.sv* %28, %struct.sv** %tmp
  %30 = load %struct.sv*, %struct.sv** %tmp
  br label %if.end.19

if.else:                                          ; preds = %lor.lhs.false.9
  %31 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %32 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %31, %struct.sv** %32, align 8
  br label %if.end.19

if.end.19:                                        ; preds = %if.else, %if.end
  %33 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %33, %struct.sv*** @PL_stack_sp, align 8
  %34 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %34, i32 0, i32 0
  %35 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %35, %struct.op** %retval
  br label %return

if.end.20:                                        ; preds = %land.lhs.true, %lor.lhs.false
  br label %if.end.21

if.end.21:                                        ; preds = %if.end.20, %entry
  %36 = load %struct.sv**, %struct.sv*** %sp, align 8
  %37 = load %struct.sv*, %struct.sv** %36, align 8
  %sv_flags22 = getelementptr inbounds %struct.sv, %struct.sv* %37, i32 0, i32 2
  %38 = load i32, i32* %sv_flags22, align 4
  %and23 = and i32 %38, 524288
  %tobool24 = icmp ne i32 %and23, 0
  br i1 %tobool24, label %land.lhs.true.25, label %if.end.59

land.lhs.true.25:                                 ; preds = %if.end.21
  %39 = load %struct.sv**, %struct.sv*** %sp, align 8
  %40 = load %struct.sv*, %struct.sv** %39, align 8
  %sv_flags26 = getelementptr inbounds %struct.sv, %struct.sv* %40, i32 0, i32 2
  %41 = load i32, i32* %sv_flags26, align 4
  %and27 = and i32 %41, 268435456
  %tobool28 = icmp ne i32 %and27, 0
  br i1 %tobool28, label %if.end.59, label %land.lhs.true.29

land.lhs.true.29:                                 ; preds = %land.lhs.true.25
  %42 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr30 = getelementptr inbounds %struct.sv*, %struct.sv** %42, i64 -1
  %43 = load %struct.sv*, %struct.sv** %add.ptr30, align 8
  %sv_flags31 = getelementptr inbounds %struct.sv, %struct.sv* %43, i32 0, i32 2
  %44 = load i32, i32* %sv_flags31, align 4
  %and32 = and i32 %44, 524288
  %tobool33 = icmp ne i32 %and32, 0
  br i1 %tobool33, label %land.lhs.true.34, label %if.end.59

land.lhs.true.34:                                 ; preds = %land.lhs.true.29
  %45 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr35 = getelementptr inbounds %struct.sv*, %struct.sv** %45, i64 -1
  %46 = load %struct.sv*, %struct.sv** %add.ptr35, align 8
  %sv_flags36 = getelementptr inbounds %struct.sv, %struct.sv* %46, i32 0, i32 2
  %47 = load i32, i32* %sv_flags36, align 4
  %and37 = and i32 %47, 268435456
  %tobool38 = icmp ne i32 %and37, 0
  br i1 %tobool38, label %if.end.59, label %if.then.39

if.then.39:                                       ; preds = %land.lhs.true.34
  %48 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr42 = getelementptr inbounds %struct.sv*, %struct.sv** %48, i32 -1
  store %struct.sv** %incdec.ptr42, %struct.sv*** %sp, align 8
  %49 = load %struct.sv*, %struct.sv** %48, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %49, i32 0, i32 0
  %50 = load i8*, i8** %sv_any, align 8
  %51 = bitcast i8* %50 to %struct.xrv*
  %xrv_rv = getelementptr inbounds %struct.xrv, %struct.xrv* %51, i32 0, i32 0
  %52 = load %struct.sv*, %struct.sv** %xrv_rv, align 8
  %53 = ptrtoint %struct.sv* %52 to i64
  store i64 %53, i64* %right41, align 8
  %54 = load %struct.sv**, %struct.sv*** %sp, align 8
  %55 = load %struct.sv*, %struct.sv** %54, align 8
  %sv_any45 = getelementptr inbounds %struct.sv, %struct.sv* %55, i32 0, i32 0
  %56 = load i8*, i8** %sv_any45, align 8
  %57 = bitcast i8* %56 to %struct.xrv*
  %xrv_rv46 = getelementptr inbounds %struct.xrv, %struct.xrv* %57, i32 0, i32 0
  %58 = load %struct.sv*, %struct.sv** %xrv_rv46, align 8
  %59 = ptrtoint %struct.sv* %58 to i64
  store i64 %59, i64* %left44, align 8
  %60 = load %struct.sv*, %struct.sv** %targ, align 8
  %61 = load i64, i64* %left44, align 8
  %62 = load i64, i64* %right41, align 8
  %cmp = icmp ugt i64 %61, %62
  %conv47 = zext i1 %cmp to i32
  %63 = load i64, i64* %left44, align 8
  %64 = load i64, i64* %right41, align 8
  %cmp48 = icmp ult i64 %63, %64
  %conv49 = zext i1 %cmp48 to i32
  %sub = sub nsw i32 %conv47, %conv49
  %conv50 = sext i32 %sub to i64
  call void @Perl_sv_setiv(%struct.sv* %60, i64 %conv50)
  %65 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags51 = getelementptr inbounds %struct.sv, %struct.sv* %65, i32 0, i32 2
  %66 = load i32, i32* %sv_flags51, align 4
  %and52 = and i32 %66, 16384
  %tobool53 = icmp ne i32 %and52, 0
  br i1 %tobool53, label %if.then.54, label %if.end.56

if.then.54:                                       ; preds = %if.then.39
  %67 = load %struct.sv*, %struct.sv** %targ, align 8
  %call55 = call i32 @Perl_mg_set(%struct.sv* %67)
  br label %if.end.56

if.end.56:                                        ; preds = %if.then.54, %if.then.39
  %68 = load %struct.sv*, %struct.sv** %targ, align 8
  %69 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %68, %struct.sv** %69, align 8
  store %struct.sv* %68, %struct.sv** %tmp57
  %70 = load %struct.sv*, %struct.sv** %tmp57
  %71 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %71, %struct.sv*** @PL_stack_sp, align 8
  %72 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next58 = getelementptr inbounds %struct.op, %struct.op* %72, i32 0, i32 0
  %73 = load %struct.op*, %struct.op** %op_next58, align 8
  store %struct.op* %73, %struct.op** %retval
  br label %return

if.end.59:                                        ; preds = %land.lhs.true.34, %land.lhs.true.29, %land.lhs.true.25, %if.end.21
  %74 = load %struct.sv**, %struct.sv*** %sp, align 8
  %75 = load %struct.sv*, %struct.sv** %74, align 8
  %sv_flags60 = getelementptr inbounds %struct.sv, %struct.sv* %75, i32 0, i32 2
  %76 = load i32, i32* %sv_flags60, align 4
  %and61 = and i32 %76, 16777216
  %tobool62 = icmp ne i32 %and61, 0
  br i1 %tobool62, label %if.end.77, label %land.lhs.true.63

land.lhs.true.63:                                 ; preds = %if.end.59
  %77 = load %struct.sv**, %struct.sv*** %sp, align 8
  %78 = load %struct.sv*, %struct.sv** %77, align 8
  %sv_flags64 = getelementptr inbounds %struct.sv, %struct.sv* %78, i32 0, i32 2
  %79 = load i32, i32* %sv_flags64, align 4
  %and65 = and i32 %79, 131072
  %tobool66 = icmp ne i32 %and65, 0
  br i1 %tobool66, label %if.then.71, label %lor.lhs.false.67

lor.lhs.false.67:                                 ; preds = %land.lhs.true.63
  %80 = load %struct.sv**, %struct.sv*** %sp, align 8
  %81 = load %struct.sv*, %struct.sv** %80, align 8
  %sv_flags68 = getelementptr inbounds %struct.sv, %struct.sv* %81, i32 0, i32 2
  %82 = load i32, i32* %sv_flags68, align 4
  %and69 = and i32 %82, 262144
  %tobool70 = icmp ne i32 %and69, 0
  br i1 %tobool70, label %if.then.71, label %if.end.77

if.then.71:                                       ; preds = %lor.lhs.false.67, %land.lhs.true.63
  %83 = load %struct.sv**, %struct.sv*** %sp, align 8
  %84 = load %struct.sv*, %struct.sv** %83, align 8
  %sv_flags72 = getelementptr inbounds %struct.sv, %struct.sv* %84, i32 0, i32 2
  %85 = load i32, i32* %sv_flags72, align 4
  %and73 = and i32 %85, 65536
  %tobool74 = icmp ne i32 %and73, 0
  br i1 %tobool74, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.71
  %86 = load %struct.sv**, %struct.sv*** %sp, align 8
  %87 = load %struct.sv*, %struct.sv** %86, align 8
  %sv_any75 = getelementptr inbounds %struct.sv, %struct.sv* %87, i32 0, i32 0
  %88 = load i8*, i8** %sv_any75, align 8
  %89 = bitcast i8* %88 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %89, i32 0, i32 3
  %90 = load i64, i64* %xiv_iv, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then.71
  %91 = load %struct.sv**, %struct.sv*** %sp, align 8
  %92 = load %struct.sv*, %struct.sv** %91, align 8
  %call76 = call i64 @Perl_sv_2iv(%struct.sv* %92)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %90, %cond.true ], [ %call76, %cond.false ]
  br label %if.end.77

if.end.77:                                        ; preds = %cond.end, %lor.lhs.false.67, %if.end.59
  %93 = load %struct.sv**, %struct.sv*** %sp, align 8
  %94 = load %struct.sv*, %struct.sv** %93, align 8
  %sv_flags78 = getelementptr inbounds %struct.sv, %struct.sv* %94, i32 0, i32 2
  %95 = load i32, i32* %sv_flags78, align 4
  %and79 = and i32 %95, 65536
  %tobool80 = icmp ne i32 %and79, 0
  br i1 %tobool80, label %if.then.81, label %if.end.240

if.then.81:                                       ; preds = %if.end.77
  %96 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr82 = getelementptr inbounds %struct.sv*, %struct.sv** %96, i64 -1
  %97 = load %struct.sv*, %struct.sv** %add.ptr82, align 8
  %sv_flags83 = getelementptr inbounds %struct.sv, %struct.sv* %97, i32 0, i32 2
  %98 = load i32, i32* %sv_flags83, align 4
  %and84 = and i32 %98, 16777216
  %tobool85 = icmp ne i32 %and84, 0
  br i1 %tobool85, label %if.end.110, label %land.lhs.true.86

land.lhs.true.86:                                 ; preds = %if.then.81
  %99 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr87 = getelementptr inbounds %struct.sv*, %struct.sv** %99, i64 -1
  %100 = load %struct.sv*, %struct.sv** %add.ptr87, align 8
  %sv_flags88 = getelementptr inbounds %struct.sv, %struct.sv* %100, i32 0, i32 2
  %101 = load i32, i32* %sv_flags88, align 4
  %and89 = and i32 %101, 131072
  %tobool90 = icmp ne i32 %and89, 0
  br i1 %tobool90, label %if.then.96, label %lor.lhs.false.91

lor.lhs.false.91:                                 ; preds = %land.lhs.true.86
  %102 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr92 = getelementptr inbounds %struct.sv*, %struct.sv** %102, i64 -1
  %103 = load %struct.sv*, %struct.sv** %add.ptr92, align 8
  %sv_flags93 = getelementptr inbounds %struct.sv, %struct.sv* %103, i32 0, i32 2
  %104 = load i32, i32* %sv_flags93, align 4
  %and94 = and i32 %104, 262144
  %tobool95 = icmp ne i32 %and94, 0
  br i1 %tobool95, label %if.then.96, label %if.end.110

if.then.96:                                       ; preds = %lor.lhs.false.91, %land.lhs.true.86
  %105 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr97 = getelementptr inbounds %struct.sv*, %struct.sv** %105, i64 -1
  %106 = load %struct.sv*, %struct.sv** %add.ptr97, align 8
  %sv_flags98 = getelementptr inbounds %struct.sv, %struct.sv* %106, i32 0, i32 2
  %107 = load i32, i32* %sv_flags98, align 4
  %and99 = and i32 %107, 65536
  %tobool100 = icmp ne i32 %and99, 0
  br i1 %tobool100, label %cond.true.101, label %cond.false.105

cond.true.101:                                    ; preds = %if.then.96
  %108 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr102 = getelementptr inbounds %struct.sv*, %struct.sv** %108, i64 -1
  %109 = load %struct.sv*, %struct.sv** %add.ptr102, align 8
  %sv_any103 = getelementptr inbounds %struct.sv, %struct.sv* %109, i32 0, i32 0
  %110 = load i8*, i8** %sv_any103, align 8
  %111 = bitcast i8* %110 to %struct.xpviv*
  %xiv_iv104 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %111, i32 0, i32 3
  %112 = load i64, i64* %xiv_iv104, align 8
  br label %cond.end.108

cond.false.105:                                   ; preds = %if.then.96
  %113 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr106 = getelementptr inbounds %struct.sv*, %struct.sv** %113, i64 -1
  %114 = load %struct.sv*, %struct.sv** %add.ptr106, align 8
  %call107 = call i64 @Perl_sv_2iv(%struct.sv* %114)
  br label %cond.end.108

cond.end.108:                                     ; preds = %cond.false.105, %cond.true.101
  %cond109 = phi i64 [ %112, %cond.true.101 ], [ %call107, %cond.false.105 ]
  br label %if.end.110

if.end.110:                                       ; preds = %cond.end.108, %lor.lhs.false.91, %if.then.81
  %115 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr111 = getelementptr inbounds %struct.sv*, %struct.sv** %115, i64 -1
  %116 = load %struct.sv*, %struct.sv** %add.ptr111, align 8
  %sv_flags112 = getelementptr inbounds %struct.sv, %struct.sv* %116, i32 0, i32 2
  %117 = load i32, i32* %sv_flags112, align 4
  %and113 = and i32 %117, 65536
  %tobool114 = icmp ne i32 %and113, 0
  br i1 %tobool114, label %if.then.115, label %if.end.239

if.then.115:                                      ; preds = %if.end.110
  %118 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr117 = getelementptr inbounds %struct.sv*, %struct.sv** %118, i64 -1
  %119 = load %struct.sv*, %struct.sv** %add.ptr117, align 8
  %sv_flags118 = getelementptr inbounds %struct.sv, %struct.sv* %119, i32 0, i32 2
  %120 = load i32, i32* %sv_flags118, align 4
  %and119 = and i32 %120, -2147418112
  %cmp120 = icmp eq i32 %and119, -2147418112
  %conv121 = zext i1 %cmp120 to i32
  %conv122 = trunc i32 %conv121 to i8
  store i8 %conv122, i8* %leftuvok, align 1
  %121 = load %struct.sv**, %struct.sv*** %sp, align 8
  %122 = load %struct.sv*, %struct.sv** %121, align 8
  %sv_flags124 = getelementptr inbounds %struct.sv, %struct.sv* %122, i32 0, i32 2
  %123 = load i32, i32* %sv_flags124, align 4
  %and125 = and i32 %123, -2147418112
  %cmp126 = icmp eq i32 %and125, -2147418112
  %conv127 = zext i1 %cmp126 to i32
  %conv128 = trunc i32 %conv127 to i8
  store i8 %conv128, i8* %rightuvok, align 1
  %124 = load i8, i8* %leftuvok, align 1
  %tobool130 = icmp ne i8 %124, 0
  br i1 %tobool130, label %if.else.151, label %land.lhs.true.131

land.lhs.true.131:                                ; preds = %if.then.115
  %125 = load i8, i8* %rightuvok, align 1
  %tobool132 = icmp ne i8 %125, 0
  br i1 %tobool132, label %if.else.151, label %if.then.133

if.then.133:                                      ; preds = %land.lhs.true.131
  %126 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr135 = getelementptr inbounds %struct.sv*, %struct.sv** %126, i64 -1
  %127 = load %struct.sv*, %struct.sv** %add.ptr135, align 8
  %sv_any136 = getelementptr inbounds %struct.sv, %struct.sv* %127, i32 0, i32 0
  %128 = load i8*, i8** %sv_any136, align 8
  %129 = bitcast i8* %128 to %struct.xpviv*
  %xiv_iv137 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %129, i32 0, i32 3
  %130 = load i64, i64* %xiv_iv137, align 8
  store i64 %130, i64* %leftiv, align 8
  %131 = load %struct.sv**, %struct.sv*** %sp, align 8
  %132 = load %struct.sv*, %struct.sv** %131, align 8
  %sv_any139 = getelementptr inbounds %struct.sv, %struct.sv* %132, i32 0, i32 0
  %133 = load i8*, i8** %sv_any139, align 8
  %134 = bitcast i8* %133 to %struct.xpviv*
  %xiv_iv140 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %134, i32 0, i32 3
  %135 = load i64, i64* %xiv_iv140, align 8
  store i64 %135, i64* %rightiv, align 8
  %136 = load i64, i64* %leftiv, align 8
  %137 = load i64, i64* %rightiv, align 8
  %cmp141 = icmp sgt i64 %136, %137
  br i1 %cmp141, label %if.then.143, label %if.else.144

if.then.143:                                      ; preds = %if.then.133
  store i32 1, i32* %value, align 4
  br label %if.end.150

if.else.144:                                      ; preds = %if.then.133
  %138 = load i64, i64* %leftiv, align 8
  %139 = load i64, i64* %rightiv, align 8
  %cmp145 = icmp slt i64 %138, %139
  br i1 %cmp145, label %if.then.147, label %if.else.148

if.then.147:                                      ; preds = %if.else.144
  store i32 -1, i32* %value, align 4
  br label %if.end.149

if.else.148:                                      ; preds = %if.else.144
  store i32 0, i32* %value, align 4
  br label %if.end.149

if.end.149:                                       ; preds = %if.else.148, %if.then.147
  br label %if.end.150

if.end.150:                                       ; preds = %if.end.149, %if.then.143
  br label %if.end.228

if.else.151:                                      ; preds = %land.lhs.true.131, %if.then.115
  %140 = load i8, i8* %leftuvok, align 1
  %conv152 = sext i8 %140 to i32
  %tobool153 = icmp ne i32 %conv152, 0
  br i1 %tobool153, label %land.lhs.true.154, label %if.else.174

land.lhs.true.154:                                ; preds = %if.else.151
  %141 = load i8, i8* %rightuvok, align 1
  %conv155 = sext i8 %141 to i32
  %tobool156 = icmp ne i32 %conv155, 0
  br i1 %tobool156, label %if.then.157, label %if.else.174

if.then.157:                                      ; preds = %land.lhs.true.154
  %142 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr159 = getelementptr inbounds %struct.sv*, %struct.sv** %142, i64 -1
  %143 = load %struct.sv*, %struct.sv** %add.ptr159, align 8
  %sv_any160 = getelementptr inbounds %struct.sv, %struct.sv* %143, i32 0, i32 0
  %144 = load i8*, i8** %sv_any160, align 8
  %145 = bitcast i8* %144 to %struct.xpvuv*
  %xuv_uv = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %145, i32 0, i32 3
  %146 = load i64, i64* %xuv_uv, align 8
  store i64 %146, i64* %leftuv, align 8
  %147 = load %struct.sv**, %struct.sv*** %sp, align 8
  %148 = load %struct.sv*, %struct.sv** %147, align 8
  %sv_any162 = getelementptr inbounds %struct.sv, %struct.sv* %148, i32 0, i32 0
  %149 = load i8*, i8** %sv_any162, align 8
  %150 = bitcast i8* %149 to %struct.xpvuv*
  %xuv_uv163 = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %150, i32 0, i32 3
  %151 = load i64, i64* %xuv_uv163, align 8
  store i64 %151, i64* %rightuv, align 8
  %152 = load i64, i64* %leftuv, align 8
  %153 = load i64, i64* %rightuv, align 8
  %cmp164 = icmp ugt i64 %152, %153
  br i1 %cmp164, label %if.then.166, label %if.else.167

if.then.166:                                      ; preds = %if.then.157
  store i32 1, i32* %value, align 4
  br label %if.end.173

if.else.167:                                      ; preds = %if.then.157
  %154 = load i64, i64* %leftuv, align 8
  %155 = load i64, i64* %rightuv, align 8
  %cmp168 = icmp ult i64 %154, %155
  br i1 %cmp168, label %if.then.170, label %if.else.171

if.then.170:                                      ; preds = %if.else.167
  store i32 -1, i32* %value, align 4
  br label %if.end.172

if.else.171:                                      ; preds = %if.else.167
  store i32 0, i32* %value, align 4
  br label %if.end.172

if.end.172:                                       ; preds = %if.else.171, %if.then.170
  br label %if.end.173

if.end.173:                                       ; preds = %if.end.172, %if.then.166
  br label %if.end.227

if.else.174:                                      ; preds = %land.lhs.true.154, %if.else.151
  %156 = load i8, i8* %leftuvok, align 1
  %tobool175 = icmp ne i8 %156, 0
  br i1 %tobool175, label %if.then.176, label %if.else.201

if.then.176:                                      ; preds = %if.else.174
  %157 = load %struct.sv**, %struct.sv*** %sp, align 8
  %158 = load %struct.sv*, %struct.sv** %157, align 8
  %sv_any181 = getelementptr inbounds %struct.sv, %struct.sv* %158, i32 0, i32 0
  %159 = load i8*, i8** %sv_any181, align 8
  %160 = bitcast i8* %159 to %struct.xpviv*
  %xiv_iv182 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %160, i32 0, i32 3
  %161 = load i64, i64* %xiv_iv182, align 8
  store i64 %161, i64* %rightiv180, align 8
  %162 = load i64, i64* %rightiv180, align 8
  %cmp183 = icmp slt i64 %162, 0
  br i1 %cmp183, label %if.then.185, label %if.else.186

if.then.185:                                      ; preds = %if.then.176
  store i32 1, i32* %value, align 4
  br label %if.end.200

if.else.186:                                      ; preds = %if.then.176
  %163 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr187 = getelementptr inbounds %struct.sv*, %struct.sv** %163, i64 -1
  %164 = load %struct.sv*, %struct.sv** %add.ptr187, align 8
  %sv_any188 = getelementptr inbounds %struct.sv, %struct.sv* %164, i32 0, i32 0
  %165 = load i8*, i8** %sv_any188, align 8
  %166 = bitcast i8* %165 to %struct.xpvuv*
  %xuv_uv189 = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %166, i32 0, i32 3
  %167 = load i64, i64* %xuv_uv189, align 8
  store i64 %167, i64* %leftuv178, align 8
  %168 = load i64, i64* %leftuv178, align 8
  %169 = load i64, i64* %rightiv180, align 8
  %cmp190 = icmp ugt i64 %168, %169
  br i1 %cmp190, label %if.then.192, label %if.else.193

if.then.192:                                      ; preds = %if.else.186
  store i32 1, i32* %value, align 4
  br label %if.end.199

if.else.193:                                      ; preds = %if.else.186
  %170 = load i64, i64* %leftuv178, align 8
  %171 = load i64, i64* %rightiv180, align 8
  %cmp194 = icmp ult i64 %170, %171
  br i1 %cmp194, label %if.then.196, label %if.else.197

if.then.196:                                      ; preds = %if.else.193
  store i32 -1, i32* %value, align 4
  br label %if.end.198

if.else.197:                                      ; preds = %if.else.193
  store i32 0, i32* %value, align 4
  br label %if.end.198

if.end.198:                                       ; preds = %if.else.197, %if.then.196
  br label %if.end.199

if.end.199:                                       ; preds = %if.end.198, %if.then.192
  br label %if.end.200

if.end.200:                                       ; preds = %if.end.199, %if.then.185
  br label %if.end.226

if.else.201:                                      ; preds = %if.else.174
  %172 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr206 = getelementptr inbounds %struct.sv*, %struct.sv** %172, i64 -1
  %173 = load %struct.sv*, %struct.sv** %add.ptr206, align 8
  %sv_any207 = getelementptr inbounds %struct.sv, %struct.sv* %173, i32 0, i32 0
  %174 = load i8*, i8** %sv_any207, align 8
  %175 = bitcast i8* %174 to %struct.xpviv*
  %xiv_iv208 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %175, i32 0, i32 3
  %176 = load i64, i64* %xiv_iv208, align 8
  store i64 %176, i64* %leftiv203, align 8
  %177 = load i64, i64* %leftiv203, align 8
  %cmp209 = icmp slt i64 %177, 0
  br i1 %cmp209, label %if.then.211, label %if.else.212

if.then.211:                                      ; preds = %if.else.201
  store i32 -1, i32* %value, align 4
  br label %if.end.225

if.else.212:                                      ; preds = %if.else.201
  %178 = load %struct.sv**, %struct.sv*** %sp, align 8
  %179 = load %struct.sv*, %struct.sv** %178, align 8
  %sv_any213 = getelementptr inbounds %struct.sv, %struct.sv* %179, i32 0, i32 0
  %180 = load i8*, i8** %sv_any213, align 8
  %181 = bitcast i8* %180 to %struct.xpvuv*
  %xuv_uv214 = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %181, i32 0, i32 3
  %182 = load i64, i64* %xuv_uv214, align 8
  store i64 %182, i64* %rightuv205, align 8
  %183 = load i64, i64* %leftiv203, align 8
  %184 = load i64, i64* %rightuv205, align 8
  %cmp215 = icmp ugt i64 %183, %184
  br i1 %cmp215, label %if.then.217, label %if.else.218

if.then.217:                                      ; preds = %if.else.212
  store i32 1, i32* %value, align 4
  br label %if.end.224

if.else.218:                                      ; preds = %if.else.212
  %185 = load i64, i64* %leftiv203, align 8
  %186 = load i64, i64* %rightuv205, align 8
  %cmp219 = icmp ult i64 %185, %186
  br i1 %cmp219, label %if.then.221, label %if.else.222

if.then.221:                                      ; preds = %if.else.218
  store i32 -1, i32* %value, align 4
  br label %if.end.223

if.else.222:                                      ; preds = %if.else.218
  store i32 0, i32* %value, align 4
  br label %if.end.223

if.end.223:                                       ; preds = %if.else.222, %if.then.221
  br label %if.end.224

if.end.224:                                       ; preds = %if.end.223, %if.then.217
  br label %if.end.225

if.end.225:                                       ; preds = %if.end.224, %if.then.211
  br label %if.end.226

if.end.226:                                       ; preds = %if.end.225, %if.end.200
  br label %if.end.227

if.end.227:                                       ; preds = %if.end.226, %if.end.173
  br label %if.end.228

if.end.228:                                       ; preds = %if.end.227, %if.end.150
  %187 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr229 = getelementptr inbounds %struct.sv*, %struct.sv** %187, i32 -1
  store %struct.sv** %incdec.ptr229, %struct.sv*** %sp, align 8
  %188 = load %struct.sv*, %struct.sv** %targ, align 8
  %189 = load i32, i32* %value, align 4
  %conv230 = sext i32 %189 to i64
  call void @Perl_sv_setiv(%struct.sv* %188, i64 %conv230)
  %190 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags231 = getelementptr inbounds %struct.sv, %struct.sv* %190, i32 0, i32 2
  %191 = load i32, i32* %sv_flags231, align 4
  %and232 = and i32 %191, 16384
  %tobool233 = icmp ne i32 %and232, 0
  br i1 %tobool233, label %if.then.234, label %if.end.236

if.then.234:                                      ; preds = %if.end.228
  %192 = load %struct.sv*, %struct.sv** %targ, align 8
  %call235 = call i32 @Perl_mg_set(%struct.sv* %192)
  br label %if.end.236

if.end.236:                                       ; preds = %if.then.234, %if.end.228
  %193 = load %struct.sv*, %struct.sv** %targ, align 8
  %194 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %193, %struct.sv** %194, align 8
  store %struct.sv* %193, %struct.sv** %tmp237
  %195 = load %struct.sv*, %struct.sv** %tmp237
  %196 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %196, %struct.sv*** @PL_stack_sp, align 8
  %197 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next238 = getelementptr inbounds %struct.op, %struct.op* %197, i32 0, i32 0
  %198 = load %struct.op*, %struct.op** %op_next238, align 8
  store %struct.op* %198, %struct.op** %retval
  br label %return

if.end.239:                                       ; preds = %if.end.110
  br label %if.end.240

if.end.240:                                       ; preds = %if.end.239, %if.end.77
  %199 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr243 = getelementptr inbounds %struct.sv*, %struct.sv** %199, i32 -1
  store %struct.sv** %incdec.ptr243, %struct.sv*** %sp, align 8
  %200 = load %struct.sv*, %struct.sv** %199, align 8
  store %struct.sv* %200, %struct.sv** @PL_Sv, align 8
  %201 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags244 = getelementptr inbounds %struct.sv, %struct.sv* %201, i32 0, i32 2
  %202 = load i32, i32* %sv_flags244, align 4
  %and245 = and i32 %202, 131072
  %tobool246 = icmp ne i32 %and245, 0
  br i1 %tobool246, label %cond.true.247, label %cond.false.249

cond.true.247:                                    ; preds = %if.end.240
  %203 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any248 = getelementptr inbounds %struct.sv, %struct.sv* %203, i32 0, i32 0
  %204 = load i8*, i8** %sv_any248, align 8
  %205 = bitcast i8* %204 to %struct.xpvnv*
  %xnv_nv = getelementptr inbounds %struct.xpvnv, %struct.xpvnv* %205, i32 0, i32 4
  %206 = load double, double* %xnv_nv, align 8
  br label %cond.end.251

cond.false.249:                                   ; preds = %if.end.240
  %207 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call250 = call double @Perl_sv_2nv(%struct.sv* %207)
  br label %cond.end.251

cond.end.251:                                     ; preds = %cond.false.249, %cond.true.247
  %cond252 = phi double [ %206, %cond.true.247 ], [ %call250, %cond.false.249 ]
  store double %cond252, double* %right242, align 8
  %208 = load %struct.sv**, %struct.sv*** %sp, align 8
  %209 = load %struct.sv*, %struct.sv** %208, align 8
  %sv_flags255 = getelementptr inbounds %struct.sv, %struct.sv* %209, i32 0, i32 2
  %210 = load i32, i32* %sv_flags255, align 4
  %and256 = and i32 %210, 131072
  %tobool257 = icmp ne i32 %and256, 0
  br i1 %tobool257, label %cond.true.258, label %cond.false.261

cond.true.258:                                    ; preds = %cond.end.251
  %211 = load %struct.sv**, %struct.sv*** %sp, align 8
  %212 = load %struct.sv*, %struct.sv** %211, align 8
  %sv_any259 = getelementptr inbounds %struct.sv, %struct.sv* %212, i32 0, i32 0
  %213 = load i8*, i8** %sv_any259, align 8
  %214 = bitcast i8* %213 to %struct.xpvnv*
  %xnv_nv260 = getelementptr inbounds %struct.xpvnv, %struct.xpvnv* %214, i32 0, i32 4
  %215 = load double, double* %xnv_nv260, align 8
  br label %cond.end.263

cond.false.261:                                   ; preds = %cond.end.251
  %216 = load %struct.sv**, %struct.sv*** %sp, align 8
  %217 = load %struct.sv*, %struct.sv** %216, align 8
  %call262 = call double @Perl_sv_2nv(%struct.sv* %217)
  br label %cond.end.263

cond.end.263:                                     ; preds = %cond.false.261, %cond.true.258
  %cond264 = phi double [ %215, %cond.true.258 ], [ %call262, %cond.false.261 ]
  store double %cond264, double* %left254, align 8
  br i1 false, label %cond.true.267, label %cond.false.271

cond.true.267:                                    ; preds = %cond.end.263
  %218 = load double, double* %left254, align 8
  %conv268 = fptrunc double %218 to float
  %call269 = call i32 @__isnanf(float %conv268)
  %tobool270 = icmp ne i32 %call269, 0
  br i1 %tobool270, label %if.then.292, label %lor.lhs.false.279

cond.false.271:                                   ; preds = %cond.end.263
  br i1 true, label %cond.true.272, label %cond.false.275

cond.true.272:                                    ; preds = %cond.false.271
  %219 = load double, double* %left254, align 8
  %call273 = call i32 @__isnan(double %219)
  %tobool274 = icmp ne i32 %call273, 0
  br i1 %tobool274, label %if.then.292, label %lor.lhs.false.279

cond.false.275:                                   ; preds = %cond.false.271
  %220 = load double, double* %left254, align 8
  %conv276 = fpext double %220 to x86_fp80
  %call277 = call i32 @__isnanl(x86_fp80 %conv276)
  %tobool278 = icmp ne i32 %call277, 0
  br i1 %tobool278, label %if.then.292, label %lor.lhs.false.279

lor.lhs.false.279:                                ; preds = %cond.false.275, %cond.true.272, %cond.true.267
  br i1 false, label %cond.true.280, label %cond.false.284

cond.true.280:                                    ; preds = %lor.lhs.false.279
  %221 = load double, double* %right242, align 8
  %conv281 = fptrunc double %221 to float
  %call282 = call i32 @__isnanf(float %conv281)
  %tobool283 = icmp ne i32 %call282, 0
  br i1 %tobool283, label %if.then.292, label %if.end.294

cond.false.284:                                   ; preds = %lor.lhs.false.279
  br i1 true, label %cond.true.285, label %cond.false.288

cond.true.285:                                    ; preds = %cond.false.284
  %222 = load double, double* %right242, align 8
  %call286 = call i32 @__isnan(double %222)
  %tobool287 = icmp ne i32 %call286, 0
  br i1 %tobool287, label %if.then.292, label %if.end.294

cond.false.288:                                   ; preds = %cond.false.284
  %223 = load double, double* %right242, align 8
  %conv289 = fpext double %223 to x86_fp80
  %call290 = call i32 @__isnanl(x86_fp80 %conv289)
  %tobool291 = icmp ne i32 %call290, 0
  br i1 %tobool291, label %if.then.292, label %if.end.294

if.then.292:                                      ; preds = %cond.false.288, %cond.true.285, %cond.true.280, %cond.false.275, %cond.true.272, %cond.true.267
  %224 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* @PL_sv_undef, %struct.sv** %224, align 8
  %225 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %225, %struct.sv*** @PL_stack_sp, align 8
  %226 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next293 = getelementptr inbounds %struct.op, %struct.op* %226, i32 0, i32 0
  %227 = load %struct.op*, %struct.op** %op_next293, align 8
  store %struct.op* %227, %struct.op** %retval
  br label %return

if.end.294:                                       ; preds = %cond.false.288, %cond.true.285, %cond.true.280
  %228 = load double, double* %left254, align 8
  %229 = load double, double* %right242, align 8
  %cmp295 = fcmp ogt double %228, %229
  %conv296 = zext i1 %cmp295 to i32
  %230 = load double, double* %left254, align 8
  %231 = load double, double* %right242, align 8
  %cmp297 = fcmp olt double %230, %231
  %conv298 = zext i1 %cmp297 to i32
  %sub299 = sub nsw i32 %conv296, %conv298
  store i32 %sub299, i32* %value266, align 4
  %232 = load %struct.sv*, %struct.sv** %targ, align 8
  %233 = load i32, i32* %value266, align 4
  %conv300 = sext i32 %233 to i64
  call void @Perl_sv_setiv(%struct.sv* %232, i64 %conv300)
  %234 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags301 = getelementptr inbounds %struct.sv, %struct.sv* %234, i32 0, i32 2
  %235 = load i32, i32* %sv_flags301, align 4
  %and302 = and i32 %235, 16384
  %tobool303 = icmp ne i32 %and302, 0
  br i1 %tobool303, label %if.then.304, label %if.end.306

if.then.304:                                      ; preds = %if.end.294
  %236 = load %struct.sv*, %struct.sv** %targ, align 8
  %call305 = call i32 @Perl_mg_set(%struct.sv* %236)
  br label %if.end.306

if.end.306:                                       ; preds = %if.then.304, %if.end.294
  %237 = load %struct.sv*, %struct.sv** %targ, align 8
  %238 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %237, %struct.sv** %238, align 8
  store %struct.sv* %237, %struct.sv** %tmp307
  %239 = load %struct.sv*, %struct.sv** %tmp307
  %240 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %240, %struct.sv*** @PL_stack_sp, align 8
  %241 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next308 = getelementptr inbounds %struct.op, %struct.op* %241, i32 0, i32 0
  %242 = load %struct.op*, %struct.op** %op_next308, align 8
  store %struct.op* %242, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.306, %if.then.292, %if.end.236, %if.end.56, %if.end.19
  %243 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %243
}

declare i32 @__isnanf(float) #1

declare i32 @__isnan(double) #1

declare i32 @__isnanl(x86_fp80) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_slt() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %right = alloca %struct.sv*, align 8
  %left = alloca %struct.sv*, align 8
  %right8 = alloca %struct.sv*, align 8
  %left10 = alloca %struct.sv*, align 8
  %cmp = alloca i32, align 4
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load i64, i64* @PL_amagic_generation, align 8
  %tobool = icmp ne i64 %1, 0
  br i1 %tobool, label %if.then, label %if.end.7

if.then:                                          ; preds = %entry
  %2 = load %struct.sv**, %struct.sv*** %sp, align 8
  %3 = load %struct.sv*, %struct.sv** %2, align 8
  store %struct.sv* %3, %struct.sv** %right, align 8
  %4 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %4, i64 -1
  %5 = load %struct.sv*, %struct.sv** %add.ptr, align 8
  store %struct.sv* %5, %struct.sv** %left, align 8
  %6 = load %struct.sv*, %struct.sv** %left, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %6, i32 0, i32 2
  %7 = load i32, i32* %sv_flags, align 4
  %and = and i32 %7, 268435456
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %8 = load %struct.sv*, %struct.sv** %right, align 8
  %sv_flags2 = getelementptr inbounds %struct.sv, %struct.sv* %8, i32 0, i32 2
  %9 = load i32, i32* %sv_flags2, align 4
  %and3 = and i32 %9, 268435456
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %10 = load %struct.sv*, %struct.sv** %left, align 8
  %11 = load %struct.sv*, %struct.sv** %right, align 8
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %10, %struct.sv* %11, i32 36, i32 0)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool5 = icmp ne %struct.sv* %call, null
  br i1 %tobool5, label %if.then.6, label %if.end

if.then.6:                                        ; preds = %land.lhs.true
  %12 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %12, %struct.sv*** %sp, align 8
  %13 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %13, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %14 = load %struct.sv*, %struct.sv** %13, align 8
  %15 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %16 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %15, %struct.sv** %16, align 8
  %17 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %17, %struct.sv*** @PL_stack_sp, align 8
  %18 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %18, i32 0, i32 0
  %19 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %19, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %land.lhs.true, %lor.lhs.false
  br label %if.end.7

if.end.7:                                         ; preds = %if.end, %entry
  %20 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr9 = getelementptr inbounds %struct.sv*, %struct.sv** %20, i32 -1
  store %struct.sv** %incdec.ptr9, %struct.sv*** %sp, align 8
  %21 = load %struct.sv*, %struct.sv** %20, align 8
  store %struct.sv* %21, %struct.sv** %right8, align 8
  %22 = load %struct.sv**, %struct.sv*** %sp, align 8
  %23 = load %struct.sv*, %struct.sv** %22, align 8
  store %struct.sv* %23, %struct.sv** %left10, align 8
  %24 = load %struct.sv*, %struct.sv** %left10, align 8
  %25 = load %struct.sv*, %struct.sv** %right8, align 8
  %call11 = call i32 @Perl_sv_cmp(%struct.sv* %24, %struct.sv* %25)
  store i32 %call11, i32* %cmp, align 4
  %26 = load i32, i32* %cmp, align 4
  %cmp12 = icmp slt i32 %26, 0
  %cond = select i1 %cmp12, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  %27 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %cond, %struct.sv** %27, align 8
  %28 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %28, %struct.sv*** @PL_stack_sp, align 8
  %29 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next13 = getelementptr inbounds %struct.op, %struct.op* %29, i32 0, i32 0
  %30 = load %struct.op*, %struct.op** %op_next13, align 8
  store %struct.op* %30, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.7, %if.then.6
  %31 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %31
}

declare i32 @Perl_sv_cmp(%struct.sv*, %struct.sv*) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_sgt() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %right = alloca %struct.sv*, align 8
  %left = alloca %struct.sv*, align 8
  %right8 = alloca %struct.sv*, align 8
  %left10 = alloca %struct.sv*, align 8
  %cmp = alloca i32, align 4
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load i64, i64* @PL_amagic_generation, align 8
  %tobool = icmp ne i64 %1, 0
  br i1 %tobool, label %if.then, label %if.end.7

if.then:                                          ; preds = %entry
  %2 = load %struct.sv**, %struct.sv*** %sp, align 8
  %3 = load %struct.sv*, %struct.sv** %2, align 8
  store %struct.sv* %3, %struct.sv** %right, align 8
  %4 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %4, i64 -1
  %5 = load %struct.sv*, %struct.sv** %add.ptr, align 8
  store %struct.sv* %5, %struct.sv** %left, align 8
  %6 = load %struct.sv*, %struct.sv** %left, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %6, i32 0, i32 2
  %7 = load i32, i32* %sv_flags, align 4
  %and = and i32 %7, 268435456
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %8 = load %struct.sv*, %struct.sv** %right, align 8
  %sv_flags2 = getelementptr inbounds %struct.sv, %struct.sv* %8, i32 0, i32 2
  %9 = load i32, i32* %sv_flags2, align 4
  %and3 = and i32 %9, 268435456
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %10 = load %struct.sv*, %struct.sv** %left, align 8
  %11 = load %struct.sv*, %struct.sv** %right, align 8
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %10, %struct.sv* %11, i32 38, i32 0)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool5 = icmp ne %struct.sv* %call, null
  br i1 %tobool5, label %if.then.6, label %if.end

if.then.6:                                        ; preds = %land.lhs.true
  %12 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %12, %struct.sv*** %sp, align 8
  %13 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %13, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %14 = load %struct.sv*, %struct.sv** %13, align 8
  %15 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %16 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %15, %struct.sv** %16, align 8
  %17 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %17, %struct.sv*** @PL_stack_sp, align 8
  %18 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %18, i32 0, i32 0
  %19 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %19, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %land.lhs.true, %lor.lhs.false
  br label %if.end.7

if.end.7:                                         ; preds = %if.end, %entry
  %20 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr9 = getelementptr inbounds %struct.sv*, %struct.sv** %20, i32 -1
  store %struct.sv** %incdec.ptr9, %struct.sv*** %sp, align 8
  %21 = load %struct.sv*, %struct.sv** %20, align 8
  store %struct.sv* %21, %struct.sv** %right8, align 8
  %22 = load %struct.sv**, %struct.sv*** %sp, align 8
  %23 = load %struct.sv*, %struct.sv** %22, align 8
  store %struct.sv* %23, %struct.sv** %left10, align 8
  %24 = load %struct.sv*, %struct.sv** %left10, align 8
  %25 = load %struct.sv*, %struct.sv** %right8, align 8
  %call11 = call i32 @Perl_sv_cmp(%struct.sv* %24, %struct.sv* %25)
  store i32 %call11, i32* %cmp, align 4
  %26 = load i32, i32* %cmp, align 4
  %cmp12 = icmp sgt i32 %26, 0
  %cond = select i1 %cmp12, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  %27 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %cond, %struct.sv** %27, align 8
  %28 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %28, %struct.sv*** @PL_stack_sp, align 8
  %29 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next13 = getelementptr inbounds %struct.op, %struct.op* %29, i32 0, i32 0
  %30 = load %struct.op*, %struct.op** %op_next13, align 8
  store %struct.op* %30, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.7, %if.then.6
  %31 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %31
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_sle() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %right = alloca %struct.sv*, align 8
  %left = alloca %struct.sv*, align 8
  %right8 = alloca %struct.sv*, align 8
  %left10 = alloca %struct.sv*, align 8
  %cmp = alloca i32, align 4
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load i64, i64* @PL_amagic_generation, align 8
  %tobool = icmp ne i64 %1, 0
  br i1 %tobool, label %if.then, label %if.end.7

if.then:                                          ; preds = %entry
  %2 = load %struct.sv**, %struct.sv*** %sp, align 8
  %3 = load %struct.sv*, %struct.sv** %2, align 8
  store %struct.sv* %3, %struct.sv** %right, align 8
  %4 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %4, i64 -1
  %5 = load %struct.sv*, %struct.sv** %add.ptr, align 8
  store %struct.sv* %5, %struct.sv** %left, align 8
  %6 = load %struct.sv*, %struct.sv** %left, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %6, i32 0, i32 2
  %7 = load i32, i32* %sv_flags, align 4
  %and = and i32 %7, 268435456
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %8 = load %struct.sv*, %struct.sv** %right, align 8
  %sv_flags2 = getelementptr inbounds %struct.sv, %struct.sv* %8, i32 0, i32 2
  %9 = load i32, i32* %sv_flags2, align 4
  %and3 = and i32 %9, 268435456
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %10 = load %struct.sv*, %struct.sv** %left, align 8
  %11 = load %struct.sv*, %struct.sv** %right, align 8
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %10, %struct.sv* %11, i32 37, i32 0)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool5 = icmp ne %struct.sv* %call, null
  br i1 %tobool5, label %if.then.6, label %if.end

if.then.6:                                        ; preds = %land.lhs.true
  %12 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %12, %struct.sv*** %sp, align 8
  %13 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %13, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %14 = load %struct.sv*, %struct.sv** %13, align 8
  %15 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %16 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %15, %struct.sv** %16, align 8
  %17 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %17, %struct.sv*** @PL_stack_sp, align 8
  %18 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %18, i32 0, i32 0
  %19 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %19, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %land.lhs.true, %lor.lhs.false
  br label %if.end.7

if.end.7:                                         ; preds = %if.end, %entry
  %20 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr9 = getelementptr inbounds %struct.sv*, %struct.sv** %20, i32 -1
  store %struct.sv** %incdec.ptr9, %struct.sv*** %sp, align 8
  %21 = load %struct.sv*, %struct.sv** %20, align 8
  store %struct.sv* %21, %struct.sv** %right8, align 8
  %22 = load %struct.sv**, %struct.sv*** %sp, align 8
  %23 = load %struct.sv*, %struct.sv** %22, align 8
  store %struct.sv* %23, %struct.sv** %left10, align 8
  %24 = load %struct.sv*, %struct.sv** %left10, align 8
  %25 = load %struct.sv*, %struct.sv** %right8, align 8
  %call11 = call i32 @Perl_sv_cmp(%struct.sv* %24, %struct.sv* %25)
  store i32 %call11, i32* %cmp, align 4
  %26 = load i32, i32* %cmp, align 4
  %cmp12 = icmp sle i32 %26, 0
  %cond = select i1 %cmp12, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  %27 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %cond, %struct.sv** %27, align 8
  %28 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %28, %struct.sv*** @PL_stack_sp, align 8
  %29 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next13 = getelementptr inbounds %struct.op, %struct.op* %29, i32 0, i32 0
  %30 = load %struct.op*, %struct.op** %op_next13, align 8
  store %struct.op* %30, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.7, %if.then.6
  %31 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %31
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_sge() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %right = alloca %struct.sv*, align 8
  %left = alloca %struct.sv*, align 8
  %right8 = alloca %struct.sv*, align 8
  %left10 = alloca %struct.sv*, align 8
  %cmp = alloca i32, align 4
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load i64, i64* @PL_amagic_generation, align 8
  %tobool = icmp ne i64 %1, 0
  br i1 %tobool, label %if.then, label %if.end.7

if.then:                                          ; preds = %entry
  %2 = load %struct.sv**, %struct.sv*** %sp, align 8
  %3 = load %struct.sv*, %struct.sv** %2, align 8
  store %struct.sv* %3, %struct.sv** %right, align 8
  %4 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %4, i64 -1
  %5 = load %struct.sv*, %struct.sv** %add.ptr, align 8
  store %struct.sv* %5, %struct.sv** %left, align 8
  %6 = load %struct.sv*, %struct.sv** %left, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %6, i32 0, i32 2
  %7 = load i32, i32* %sv_flags, align 4
  %and = and i32 %7, 268435456
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %8 = load %struct.sv*, %struct.sv** %right, align 8
  %sv_flags2 = getelementptr inbounds %struct.sv, %struct.sv* %8, i32 0, i32 2
  %9 = load i32, i32* %sv_flags2, align 4
  %and3 = and i32 %9, 268435456
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %10 = load %struct.sv*, %struct.sv** %left, align 8
  %11 = load %struct.sv*, %struct.sv** %right, align 8
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %10, %struct.sv* %11, i32 39, i32 0)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool5 = icmp ne %struct.sv* %call, null
  br i1 %tobool5, label %if.then.6, label %if.end

if.then.6:                                        ; preds = %land.lhs.true
  %12 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %12, %struct.sv*** %sp, align 8
  %13 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %13, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %14 = load %struct.sv*, %struct.sv** %13, align 8
  %15 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %16 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %15, %struct.sv** %16, align 8
  %17 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %17, %struct.sv*** @PL_stack_sp, align 8
  %18 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %18, i32 0, i32 0
  %19 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %19, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %land.lhs.true, %lor.lhs.false
  br label %if.end.7

if.end.7:                                         ; preds = %if.end, %entry
  %20 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr9 = getelementptr inbounds %struct.sv*, %struct.sv** %20, i32 -1
  store %struct.sv** %incdec.ptr9, %struct.sv*** %sp, align 8
  %21 = load %struct.sv*, %struct.sv** %20, align 8
  store %struct.sv* %21, %struct.sv** %right8, align 8
  %22 = load %struct.sv**, %struct.sv*** %sp, align 8
  %23 = load %struct.sv*, %struct.sv** %22, align 8
  store %struct.sv* %23, %struct.sv** %left10, align 8
  %24 = load %struct.sv*, %struct.sv** %left10, align 8
  %25 = load %struct.sv*, %struct.sv** %right8, align 8
  %call11 = call i32 @Perl_sv_cmp(%struct.sv* %24, %struct.sv* %25)
  store i32 %call11, i32* %cmp, align 4
  %26 = load i32, i32* %cmp, align 4
  %cmp12 = icmp sge i32 %26, 0
  %cond = select i1 %cmp12, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  %27 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %cond, %struct.sv** %27, align 8
  %28 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %28, %struct.sv*** @PL_stack_sp, align 8
  %29 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next13 = getelementptr inbounds %struct.op, %struct.op* %29, i32 0, i32 0
  %30 = load %struct.op*, %struct.op** %op_next13, align 8
  store %struct.op* %30, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.7, %if.then.6
  %31 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %31
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_seq() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %right = alloca %struct.sv*, align 8
  %left = alloca %struct.sv*, align 8
  %right8 = alloca %struct.sv*, align 8
  %left10 = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load i64, i64* @PL_amagic_generation, align 8
  %tobool = icmp ne i64 %1, 0
  br i1 %tobool, label %if.then, label %if.end.7

if.then:                                          ; preds = %entry
  %2 = load %struct.sv**, %struct.sv*** %sp, align 8
  %3 = load %struct.sv*, %struct.sv** %2, align 8
  store %struct.sv* %3, %struct.sv** %right, align 8
  %4 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %4, i64 -1
  %5 = load %struct.sv*, %struct.sv** %add.ptr, align 8
  store %struct.sv* %5, %struct.sv** %left, align 8
  %6 = load %struct.sv*, %struct.sv** %left, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %6, i32 0, i32 2
  %7 = load i32, i32* %sv_flags, align 4
  %and = and i32 %7, 268435456
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %8 = load %struct.sv*, %struct.sv** %right, align 8
  %sv_flags2 = getelementptr inbounds %struct.sv, %struct.sv* %8, i32 0, i32 2
  %9 = load i32, i32* %sv_flags2, align 4
  %and3 = and i32 %9, 268435456
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %10 = load %struct.sv*, %struct.sv** %left, align 8
  %11 = load %struct.sv*, %struct.sv** %right, align 8
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %10, %struct.sv* %11, i32 40, i32 0)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool5 = icmp ne %struct.sv* %call, null
  br i1 %tobool5, label %if.then.6, label %if.end

if.then.6:                                        ; preds = %land.lhs.true
  %12 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %12, %struct.sv*** %sp, align 8
  %13 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %13, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %14 = load %struct.sv*, %struct.sv** %13, align 8
  %15 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %16 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %15, %struct.sv** %16, align 8
  %17 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %17, %struct.sv*** @PL_stack_sp, align 8
  %18 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %18, i32 0, i32 0
  %19 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %19, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %land.lhs.true, %lor.lhs.false
  br label %if.end.7

if.end.7:                                         ; preds = %if.end, %entry
  %20 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr9 = getelementptr inbounds %struct.sv*, %struct.sv** %20, i32 -1
  store %struct.sv** %incdec.ptr9, %struct.sv*** %sp, align 8
  %21 = load %struct.sv*, %struct.sv** %20, align 8
  store %struct.sv* %21, %struct.sv** %right8, align 8
  %22 = load %struct.sv**, %struct.sv*** %sp, align 8
  %23 = load %struct.sv*, %struct.sv** %22, align 8
  store %struct.sv* %23, %struct.sv** %left10, align 8
  %24 = load %struct.sv*, %struct.sv** %left10, align 8
  %25 = load %struct.sv*, %struct.sv** %right8, align 8
  %call11 = call i32 @Perl_sv_eq(%struct.sv* %24, %struct.sv* %25)
  %tobool12 = icmp ne i32 %call11, 0
  %cond = select i1 %tobool12, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  %26 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %cond, %struct.sv** %26, align 8
  %27 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %27, %struct.sv*** @PL_stack_sp, align 8
  %28 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next13 = getelementptr inbounds %struct.op, %struct.op* %28, i32 0, i32 0
  %29 = load %struct.op*, %struct.op** %op_next13, align 8
  store %struct.op* %29, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.7, %if.then.6
  %30 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %30
}

declare i32 @Perl_sv_eq(%struct.sv*, %struct.sv*) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_sne() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %right = alloca %struct.sv*, align 8
  %left = alloca %struct.sv*, align 8
  %right8 = alloca %struct.sv*, align 8
  %left10 = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load i64, i64* @PL_amagic_generation, align 8
  %tobool = icmp ne i64 %1, 0
  br i1 %tobool, label %if.then, label %if.end.7

if.then:                                          ; preds = %entry
  %2 = load %struct.sv**, %struct.sv*** %sp, align 8
  %3 = load %struct.sv*, %struct.sv** %2, align 8
  store %struct.sv* %3, %struct.sv** %right, align 8
  %4 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %4, i64 -1
  %5 = load %struct.sv*, %struct.sv** %add.ptr, align 8
  store %struct.sv* %5, %struct.sv** %left, align 8
  %6 = load %struct.sv*, %struct.sv** %left, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %6, i32 0, i32 2
  %7 = load i32, i32* %sv_flags, align 4
  %and = and i32 %7, 268435456
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %8 = load %struct.sv*, %struct.sv** %right, align 8
  %sv_flags2 = getelementptr inbounds %struct.sv, %struct.sv* %8, i32 0, i32 2
  %9 = load i32, i32* %sv_flags2, align 4
  %and3 = and i32 %9, 268435456
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %10 = load %struct.sv*, %struct.sv** %left, align 8
  %11 = load %struct.sv*, %struct.sv** %right, align 8
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %10, %struct.sv* %11, i32 41, i32 0)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool5 = icmp ne %struct.sv* %call, null
  br i1 %tobool5, label %if.then.6, label %if.end

if.then.6:                                        ; preds = %land.lhs.true
  %12 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %12, %struct.sv*** %sp, align 8
  %13 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %13, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %14 = load %struct.sv*, %struct.sv** %13, align 8
  %15 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %16 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %15, %struct.sv** %16, align 8
  %17 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %17, %struct.sv*** @PL_stack_sp, align 8
  %18 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %18, i32 0, i32 0
  %19 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %19, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %land.lhs.true, %lor.lhs.false
  br label %if.end.7

if.end.7:                                         ; preds = %if.end, %entry
  %20 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr9 = getelementptr inbounds %struct.sv*, %struct.sv** %20, i32 -1
  store %struct.sv** %incdec.ptr9, %struct.sv*** %sp, align 8
  %21 = load %struct.sv*, %struct.sv** %20, align 8
  store %struct.sv* %21, %struct.sv** %right8, align 8
  %22 = load %struct.sv**, %struct.sv*** %sp, align 8
  %23 = load %struct.sv*, %struct.sv** %22, align 8
  store %struct.sv* %23, %struct.sv** %left10, align 8
  %24 = load %struct.sv*, %struct.sv** %left10, align 8
  %25 = load %struct.sv*, %struct.sv** %right8, align 8
  %call11 = call i32 @Perl_sv_eq(%struct.sv* %24, %struct.sv* %25)
  %tobool12 = icmp ne i32 %call11, 0
  %lnot = xor i1 %tobool12, true
  %cond = select i1 %lnot, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  %26 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %cond, %struct.sv** %26, align 8
  %27 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %27, %struct.sv*** @PL_stack_sp, align 8
  %28 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next13 = getelementptr inbounds %struct.op, %struct.op* %28, i32 0, i32 0
  %29 = load %struct.op*, %struct.op** %op_next13, align 8
  store %struct.op* %29, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.7, %if.then.6
  %30 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %30
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_scmp() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %right = alloca %struct.sv*, align 8
  %left = alloca %struct.sv*, align 8
  %tmp = alloca %struct.sv*, align 8
  %right23 = alloca %struct.sv*, align 8
  %left26 = alloca %struct.sv*, align 8
  %cmp = alloca i32, align 4
  %tmp36 = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 3
  %2 = load i64, i64* %op_targ, align 8
  %3 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 %2
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %4, %struct.sv** %targ, align 8
  %5 = load i64, i64* @PL_amagic_generation, align 8
  %tobool = icmp ne i64 %5, 0
  br i1 %tobool, label %if.then, label %if.end.21

if.then:                                          ; preds = %entry
  %6 = load %struct.sv**, %struct.sv*** %sp, align 8
  %7 = load %struct.sv*, %struct.sv** %6, align 8
  store %struct.sv* %7, %struct.sv** %right, align 8
  %8 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %8, i64 -1
  %9 = load %struct.sv*, %struct.sv** %add.ptr, align 8
  store %struct.sv* %9, %struct.sv** %left, align 8
  %10 = load %struct.sv*, %struct.sv** %left, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %10, i32 0, i32 2
  %11 = load i32, i32* %sv_flags, align 4
  %and = and i32 %11, 268435456
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %12 = load %struct.sv*, %struct.sv** %right, align 8
  %sv_flags2 = getelementptr inbounds %struct.sv, %struct.sv* %12, i32 0, i32 2
  %13 = load i32, i32* %sv_flags2, align 4
  %and3 = and i32 %13, 268435456
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %land.lhs.true, label %if.end.20

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %14 = load %struct.sv*, %struct.sv** %left, align 8
  %15 = load %struct.sv*, %struct.sv** %right, align 8
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %14, %struct.sv* %15, i32 35, i32 0)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool5 = icmp ne %struct.sv* %call, null
  br i1 %tobool5, label %if.then.6, label %if.end.20

if.then.6:                                        ; preds = %land.lhs.true
  %16 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %16, %struct.sv*** %sp, align 8
  %17 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %17, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %18 = load %struct.sv*, %struct.sv** %17, align 8
  %19 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %19, i32 0, i32 6
  %20 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %20 to i32
  %and7 = and i32 %conv, 64
  %tobool8 = icmp ne i32 %and7, 0
  br i1 %tobool8, label %if.then.13, label %lor.lhs.false.9

lor.lhs.false.9:                                  ; preds = %if.then.6
  %21 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags10 = getelementptr inbounds %struct.sv, %struct.sv* %21, i32 0, i32 2
  %22 = load i32, i32* %sv_flags10, align 4
  %and11 = and i32 %22, 1024
  %tobool12 = icmp ne i32 %and11, 0
  br i1 %tobool12, label %if.then.13, label %if.else

if.then.13:                                       ; preds = %lor.lhs.false.9, %if.then.6
  %23 = load %struct.sv*, %struct.sv** %targ, align 8
  %24 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  call void @Perl_sv_setsv_flags(%struct.sv* %23, %struct.sv* %24, i32 2)
  %25 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags14 = getelementptr inbounds %struct.sv, %struct.sv* %25, i32 0, i32 2
  %26 = load i32, i32* %sv_flags14, align 4
  %and15 = and i32 %26, 16384
  %tobool16 = icmp ne i32 %and15, 0
  br i1 %tobool16, label %if.then.17, label %if.end

if.then.17:                                       ; preds = %if.then.13
  %27 = load %struct.sv*, %struct.sv** %targ, align 8
  %call18 = call i32 @Perl_mg_set(%struct.sv* %27)
  br label %if.end

if.end:                                           ; preds = %if.then.17, %if.then.13
  %28 = load %struct.sv*, %struct.sv** %targ, align 8
  %29 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %28, %struct.sv** %29, align 8
  store %struct.sv* %28, %struct.sv** %tmp
  %30 = load %struct.sv*, %struct.sv** %tmp
  br label %if.end.19

if.else:                                          ; preds = %lor.lhs.false.9
  %31 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %32 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %31, %struct.sv** %32, align 8
  br label %if.end.19

if.end.19:                                        ; preds = %if.else, %if.end
  %33 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %33, %struct.sv*** @PL_stack_sp, align 8
  %34 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %34, i32 0, i32 0
  %35 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %35, %struct.op** %retval
  br label %return

if.end.20:                                        ; preds = %land.lhs.true, %lor.lhs.false
  br label %if.end.21

if.end.21:                                        ; preds = %if.end.20, %entry
  %36 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr24 = getelementptr inbounds %struct.sv*, %struct.sv** %36, i32 -1
  store %struct.sv** %incdec.ptr24, %struct.sv*** %sp, align 8
  %37 = load %struct.sv*, %struct.sv** %36, align 8
  store %struct.sv* %37, %struct.sv** %right23, align 8
  %38 = load %struct.sv**, %struct.sv*** %sp, align 8
  %39 = load %struct.sv*, %struct.sv** %38, align 8
  store %struct.sv* %39, %struct.sv** %left26, align 8
  %40 = load %struct.sv*, %struct.sv** %left26, align 8
  %41 = load %struct.sv*, %struct.sv** %right23, align 8
  %call28 = call i32 @Perl_sv_cmp(%struct.sv* %40, %struct.sv* %41)
  store i32 %call28, i32* %cmp, align 4
  %42 = load %struct.sv*, %struct.sv** %targ, align 8
  %43 = load i32, i32* %cmp, align 4
  %conv29 = sext i32 %43 to i64
  call void @Perl_sv_setiv(%struct.sv* %42, i64 %conv29)
  %44 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags30 = getelementptr inbounds %struct.sv, %struct.sv* %44, i32 0, i32 2
  %45 = load i32, i32* %sv_flags30, align 4
  %and31 = and i32 %45, 16384
  %tobool32 = icmp ne i32 %and31, 0
  br i1 %tobool32, label %if.then.33, label %if.end.35

if.then.33:                                       ; preds = %if.end.21
  %46 = load %struct.sv*, %struct.sv** %targ, align 8
  %call34 = call i32 @Perl_mg_set(%struct.sv* %46)
  br label %if.end.35

if.end.35:                                        ; preds = %if.then.33, %if.end.21
  %47 = load %struct.sv*, %struct.sv** %targ, align 8
  %48 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %47, %struct.sv** %48, align 8
  store %struct.sv* %47, %struct.sv** %tmp36
  %49 = load %struct.sv*, %struct.sv** %tmp36
  %50 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %50, %struct.sv*** @PL_stack_sp, align 8
  %51 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next37 = getelementptr inbounds %struct.op, %struct.op* %51, i32 0, i32 0
  %52 = load %struct.op*, %struct.op** %op_next37, align 8
  store %struct.op* %52, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.35, %if.end.19
  %53 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %53
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_bit_and() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %right = alloca %struct.sv*, align 8
  %left = alloca %struct.sv*, align 8
  %tmp = alloca %struct.sv*, align 8
  %right33 = alloca %struct.sv*, align 8
  %left36 = alloca %struct.sv*, align 8
  %i = alloca i64, align 8
  %tmp75 = alloca %struct.sv*, align 8
  %u = alloca i64, align 8
  %tmp104 = alloca %struct.sv*, align 8
  %tmp114 = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 6
  %2 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 64
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load %struct.sv**, %struct.sv*** %sp, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 -1
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %5 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %5, i32 0, i32 3
  %6 = load i64, i64* %op_targ, align 8
  %7 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx1 = getelementptr inbounds %struct.sv*, %struct.sv** %7, i64 %6
  %8 = load %struct.sv*, %struct.sv** %arrayidx1, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.sv* [ %4, %cond.true ], [ %8, %cond.false ]
  store %struct.sv* %cond, %struct.sv** %targ, align 8
  %9 = load i64, i64* @PL_amagic_generation, align 8
  %tobool2 = icmp ne i64 %9, 0
  br i1 %tobool2, label %if.then, label %if.end.31

if.then:                                          ; preds = %cond.end
  %10 = load %struct.sv**, %struct.sv*** %sp, align 8
  %11 = load %struct.sv*, %struct.sv** %10, align 8
  store %struct.sv* %11, %struct.sv** %right, align 8
  %12 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %12, i64 -1
  %13 = load %struct.sv*, %struct.sv** %add.ptr, align 8
  store %struct.sv* %13, %struct.sv** %left, align 8
  %14 = load %struct.sv*, %struct.sv** %left, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %14, i32 0, i32 2
  %15 = load i32, i32* %sv_flags, align 4
  %and3 = and i32 %15, 268435456
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %16 = load %struct.sv*, %struct.sv** %right, align 8
  %sv_flags5 = getelementptr inbounds %struct.sv, %struct.sv* %16, i32 0, i32 2
  %17 = load i32, i32* %sv_flags5, align 4
  %and6 = and i32 %17, 268435456
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %land.lhs.true, label %if.end.30

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %18 = load %struct.sv*, %struct.sv** %left, align 8
  %19 = load %struct.sv*, %struct.sv** %right, align 8
  %20 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags8 = getelementptr inbounds %struct.op, %struct.op* %20, i32 0, i32 6
  %21 = load i8, i8* %op_flags8, align 1
  %conv9 = zext i8 %21 to i32
  %and10 = and i32 %conv9, 64
  %tobool11 = icmp ne i32 %and10, 0
  %cond12 = select i1 %tobool11, i32 4, i32 0
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %18, %struct.sv* %19, i32 22, i32 %cond12)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool13 = icmp ne %struct.sv* %call, null
  br i1 %tobool13, label %if.then.14, label %if.end.30

if.then.14:                                       ; preds = %land.lhs.true
  %22 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %22, %struct.sv*** %sp, align 8
  %23 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %23, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %24 = load %struct.sv*, %struct.sv** %23, align 8
  %25 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags15 = getelementptr inbounds %struct.op, %struct.op* %25, i32 0, i32 6
  %26 = load i8, i8* %op_flags15, align 1
  %conv16 = zext i8 %26 to i32
  %and17 = and i32 %conv16, 64
  %tobool18 = icmp ne i32 %and17, 0
  br i1 %tobool18, label %if.then.23, label %lor.lhs.false.19

lor.lhs.false.19:                                 ; preds = %if.then.14
  %27 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags20 = getelementptr inbounds %struct.sv, %struct.sv* %27, i32 0, i32 2
  %28 = load i32, i32* %sv_flags20, align 4
  %and21 = and i32 %28, 1024
  %tobool22 = icmp ne i32 %and21, 0
  br i1 %tobool22, label %if.then.23, label %if.else

if.then.23:                                       ; preds = %lor.lhs.false.19, %if.then.14
  %29 = load %struct.sv*, %struct.sv** %targ, align 8
  %30 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  call void @Perl_sv_setsv_flags(%struct.sv* %29, %struct.sv* %30, i32 2)
  %31 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags24 = getelementptr inbounds %struct.sv, %struct.sv* %31, i32 0, i32 2
  %32 = load i32, i32* %sv_flags24, align 4
  %and25 = and i32 %32, 16384
  %tobool26 = icmp ne i32 %and25, 0
  br i1 %tobool26, label %if.then.27, label %if.end

if.then.27:                                       ; preds = %if.then.23
  %33 = load %struct.sv*, %struct.sv** %targ, align 8
  %call28 = call i32 @Perl_mg_set(%struct.sv* %33)
  br label %if.end

if.end:                                           ; preds = %if.then.27, %if.then.23
  %34 = load %struct.sv*, %struct.sv** %targ, align 8
  %35 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %34, %struct.sv** %35, align 8
  store %struct.sv* %34, %struct.sv** %tmp
  %36 = load %struct.sv*, %struct.sv** %tmp
  br label %if.end.29

if.else:                                          ; preds = %lor.lhs.false.19
  %37 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %38 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %37, %struct.sv** %38, align 8
  br label %if.end.29

if.end.29:                                        ; preds = %if.else, %if.end
  %39 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %39, %struct.sv*** @PL_stack_sp, align 8
  %40 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %40, i32 0, i32 0
  %41 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %41, %struct.op** %retval
  br label %return

if.end.30:                                        ; preds = %land.lhs.true, %lor.lhs.false
  br label %if.end.31

if.end.31:                                        ; preds = %if.end.30, %cond.end
  %42 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr34 = getelementptr inbounds %struct.sv*, %struct.sv** %42, i32 -1
  store %struct.sv** %incdec.ptr34, %struct.sv*** %sp, align 8
  %43 = load %struct.sv*, %struct.sv** %42, align 8
  store %struct.sv* %43, %struct.sv** %right33, align 8
  %44 = load %struct.sv**, %struct.sv*** %sp, align 8
  %45 = load %struct.sv*, %struct.sv** %44, align 8
  store %struct.sv* %45, %struct.sv** %left36, align 8
  %46 = load %struct.sv*, %struct.sv** %left36, align 8
  %sv_flags37 = getelementptr inbounds %struct.sv, %struct.sv* %46, i32 0, i32 2
  %47 = load i32, i32* %sv_flags37, align 4
  %and38 = and i32 %47, 50331648
  %tobool39 = icmp ne i32 %and38, 0
  br i1 %tobool39, label %if.then.44, label %lor.lhs.false.40

lor.lhs.false.40:                                 ; preds = %if.end.31
  %48 = load %struct.sv*, %struct.sv** %right33, align 8
  %sv_flags41 = getelementptr inbounds %struct.sv, %struct.sv* %48, i32 0, i32 2
  %49 = load i32, i32* %sv_flags41, align 4
  %and42 = and i32 %49, 50331648
  %tobool43 = icmp ne i32 %and42, 0
  br i1 %tobool43, label %if.then.44, label %if.else.106

if.then.44:                                       ; preds = %lor.lhs.false.40, %if.end.31
  %50 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %50, i32 0, i32 7
  %51 = load i8, i8* %op_private, align 1
  %conv45 = zext i8 %51 to i32
  %and46 = and i32 %conv45, 1
  %tobool47 = icmp ne i32 %and46, 0
  br i1 %tobool47, label %if.then.48, label %if.else.76

if.then.48:                                       ; preds = %if.then.44
  %52 = load %struct.sv*, %struct.sv** %left36, align 8
  %sv_flags50 = getelementptr inbounds %struct.sv, %struct.sv* %52, i32 0, i32 2
  %53 = load i32, i32* %sv_flags50, align 4
  %and51 = and i32 %53, 65536
  %tobool52 = icmp ne i32 %and51, 0
  br i1 %tobool52, label %cond.true.53, label %cond.false.54

cond.true.53:                                     ; preds = %if.then.48
  %54 = load %struct.sv*, %struct.sv** %left36, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %54, i32 0, i32 0
  %55 = load i8*, i8** %sv_any, align 8
  %56 = bitcast i8* %55 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %56, i32 0, i32 3
  %57 = load i64, i64* %xiv_iv, align 8
  br label %cond.end.56

cond.false.54:                                    ; preds = %if.then.48
  %58 = load %struct.sv*, %struct.sv** %left36, align 8
  %call55 = call i64 @Perl_sv_2iv(%struct.sv* %58)
  br label %cond.end.56

cond.end.56:                                      ; preds = %cond.false.54, %cond.true.53
  %cond57 = phi i64 [ %57, %cond.true.53 ], [ %call55, %cond.false.54 ]
  %59 = load %struct.sv*, %struct.sv** %right33, align 8
  %sv_flags58 = getelementptr inbounds %struct.sv, %struct.sv* %59, i32 0, i32 2
  %60 = load i32, i32* %sv_flags58, align 4
  %and59 = and i32 %60, 65536
  %tobool60 = icmp ne i32 %and59, 0
  br i1 %tobool60, label %cond.true.61, label %cond.false.64

cond.true.61:                                     ; preds = %cond.end.56
  %61 = load %struct.sv*, %struct.sv** %right33, align 8
  %sv_any62 = getelementptr inbounds %struct.sv, %struct.sv* %61, i32 0, i32 0
  %62 = load i8*, i8** %sv_any62, align 8
  %63 = bitcast i8* %62 to %struct.xpviv*
  %xiv_iv63 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %63, i32 0, i32 3
  %64 = load i64, i64* %xiv_iv63, align 8
  br label %cond.end.66

cond.false.64:                                    ; preds = %cond.end.56
  %65 = load %struct.sv*, %struct.sv** %right33, align 8
  %call65 = call i64 @Perl_sv_2iv(%struct.sv* %65)
  br label %cond.end.66

cond.end.66:                                      ; preds = %cond.false.64, %cond.true.61
  %cond67 = phi i64 [ %64, %cond.true.61 ], [ %call65, %cond.false.64 ]
  %and68 = and i64 %cond57, %cond67
  store i64 %and68, i64* %i, align 8
  %66 = load %struct.sv*, %struct.sv** %targ, align 8
  %67 = load i64, i64* %i, align 8
  call void @Perl_sv_setiv(%struct.sv* %66, i64 %67)
  %68 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags69 = getelementptr inbounds %struct.sv, %struct.sv* %68, i32 0, i32 2
  %69 = load i32, i32* %sv_flags69, align 4
  %and70 = and i32 %69, 16384
  %tobool71 = icmp ne i32 %and70, 0
  br i1 %tobool71, label %if.then.72, label %if.end.74

if.then.72:                                       ; preds = %cond.end.66
  %70 = load %struct.sv*, %struct.sv** %targ, align 8
  %call73 = call i32 @Perl_mg_set(%struct.sv* %70)
  br label %if.end.74

if.end.74:                                        ; preds = %if.then.72, %cond.end.66
  %71 = load %struct.sv*, %struct.sv** %targ, align 8
  %72 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %71, %struct.sv** %72, align 8
  store %struct.sv* %71, %struct.sv** %tmp75
  %73 = load %struct.sv*, %struct.sv** %tmp75
  br label %if.end.105

if.else.76:                                       ; preds = %if.then.44
  %74 = load %struct.sv*, %struct.sv** %left36, align 8
  %sv_flags78 = getelementptr inbounds %struct.sv, %struct.sv* %74, i32 0, i32 2
  %75 = load i32, i32* %sv_flags78, align 4
  %and79 = and i32 %75, 65536
  %tobool80 = icmp ne i32 %and79, 0
  br i1 %tobool80, label %cond.true.81, label %cond.false.83

cond.true.81:                                     ; preds = %if.else.76
  %76 = load %struct.sv*, %struct.sv** %left36, align 8
  %sv_any82 = getelementptr inbounds %struct.sv, %struct.sv* %76, i32 0, i32 0
  %77 = load i8*, i8** %sv_any82, align 8
  %78 = bitcast i8* %77 to %struct.xpvuv*
  %xuv_uv = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %78, i32 0, i32 3
  %79 = load i64, i64* %xuv_uv, align 8
  br label %cond.end.85

cond.false.83:                                    ; preds = %if.else.76
  %80 = load %struct.sv*, %struct.sv** %left36, align 8
  %call84 = call i64 @Perl_sv_2uv(%struct.sv* %80)
  br label %cond.end.85

cond.end.85:                                      ; preds = %cond.false.83, %cond.true.81
  %cond86 = phi i64 [ %79, %cond.true.81 ], [ %call84, %cond.false.83 ]
  %81 = load %struct.sv*, %struct.sv** %right33, align 8
  %sv_flags87 = getelementptr inbounds %struct.sv, %struct.sv* %81, i32 0, i32 2
  %82 = load i32, i32* %sv_flags87, align 4
  %and88 = and i32 %82, 65536
  %tobool89 = icmp ne i32 %and88, 0
  br i1 %tobool89, label %cond.true.90, label %cond.false.93

cond.true.90:                                     ; preds = %cond.end.85
  %83 = load %struct.sv*, %struct.sv** %right33, align 8
  %sv_any91 = getelementptr inbounds %struct.sv, %struct.sv* %83, i32 0, i32 0
  %84 = load i8*, i8** %sv_any91, align 8
  %85 = bitcast i8* %84 to %struct.xpvuv*
  %xuv_uv92 = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %85, i32 0, i32 3
  %86 = load i64, i64* %xuv_uv92, align 8
  br label %cond.end.95

cond.false.93:                                    ; preds = %cond.end.85
  %87 = load %struct.sv*, %struct.sv** %right33, align 8
  %call94 = call i64 @Perl_sv_2uv(%struct.sv* %87)
  br label %cond.end.95

cond.end.95:                                      ; preds = %cond.false.93, %cond.true.90
  %cond96 = phi i64 [ %86, %cond.true.90 ], [ %call94, %cond.false.93 ]
  %and97 = and i64 %cond86, %cond96
  store i64 %and97, i64* %u, align 8
  %88 = load %struct.sv*, %struct.sv** %targ, align 8
  %89 = load i64, i64* %u, align 8
  call void @Perl_sv_setuv(%struct.sv* %88, i64 %89)
  %90 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags98 = getelementptr inbounds %struct.sv, %struct.sv* %90, i32 0, i32 2
  %91 = load i32, i32* %sv_flags98, align 4
  %and99 = and i32 %91, 16384
  %tobool100 = icmp ne i32 %and99, 0
  br i1 %tobool100, label %if.then.101, label %if.end.103

if.then.101:                                      ; preds = %cond.end.95
  %92 = load %struct.sv*, %struct.sv** %targ, align 8
  %call102 = call i32 @Perl_mg_set(%struct.sv* %92)
  br label %if.end.103

if.end.103:                                       ; preds = %if.then.101, %cond.end.95
  %93 = load %struct.sv*, %struct.sv** %targ, align 8
  %94 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %93, %struct.sv** %94, align 8
  store %struct.sv* %93, %struct.sv** %tmp104
  %95 = load %struct.sv*, %struct.sv** %tmp104
  br label %if.end.105

if.end.105:                                       ; preds = %if.end.103, %if.end.74
  br label %if.end.115

if.else.106:                                      ; preds = %lor.lhs.false.40
  %96 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %96, i32 0, i32 4
  %97 = load i16, i16* %op_type, align 2
  %conv107 = zext i16 %97 to i32
  %98 = load %struct.sv*, %struct.sv** %targ, align 8
  %99 = load %struct.sv*, %struct.sv** %left36, align 8
  %100 = load %struct.sv*, %struct.sv** %right33, align 8
  call void @Perl_do_vop(i32 %conv107, %struct.sv* %98, %struct.sv* %99, %struct.sv* %100)
  %101 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags108 = getelementptr inbounds %struct.sv, %struct.sv* %101, i32 0, i32 2
  %102 = load i32, i32* %sv_flags108, align 4
  %and109 = and i32 %102, 16384
  %tobool110 = icmp ne i32 %and109, 0
  br i1 %tobool110, label %if.then.111, label %if.end.113

if.then.111:                                      ; preds = %if.else.106
  %103 = load %struct.sv*, %struct.sv** %targ, align 8
  %call112 = call i32 @Perl_mg_set(%struct.sv* %103)
  br label %if.end.113

if.end.113:                                       ; preds = %if.then.111, %if.else.106
  %104 = load %struct.sv*, %struct.sv** %targ, align 8
  %105 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %104, %struct.sv** %105, align 8
  store %struct.sv* %104, %struct.sv** %tmp114
  %106 = load %struct.sv*, %struct.sv** %tmp114
  br label %if.end.115

if.end.115:                                       ; preds = %if.end.113, %if.end.105
  %107 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %107, %struct.sv*** @PL_stack_sp, align 8
  %108 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next116 = getelementptr inbounds %struct.op, %struct.op* %108, i32 0, i32 0
  %109 = load %struct.op*, %struct.op** %op_next116, align 8
  store %struct.op* %109, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.115, %if.end.29
  %110 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %110
}

declare void @Perl_do_vop(i32, %struct.sv*, %struct.sv*, %struct.sv*) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_bit_xor() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %right = alloca %struct.sv*, align 8
  %left = alloca %struct.sv*, align 8
  %tmp = alloca %struct.sv*, align 8
  %right33 = alloca %struct.sv*, align 8
  %left36 = alloca %struct.sv*, align 8
  %i = alloca i64, align 8
  %tmp90 = alloca %struct.sv*, align 8
  %u = alloca i64, align 8
  %tmp135 = alloca %struct.sv*, align 8
  %tmp145 = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 6
  %2 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 64
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load %struct.sv**, %struct.sv*** %sp, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 -1
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %5 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %5, i32 0, i32 3
  %6 = load i64, i64* %op_targ, align 8
  %7 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx1 = getelementptr inbounds %struct.sv*, %struct.sv** %7, i64 %6
  %8 = load %struct.sv*, %struct.sv** %arrayidx1, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.sv* [ %4, %cond.true ], [ %8, %cond.false ]
  store %struct.sv* %cond, %struct.sv** %targ, align 8
  %9 = load i64, i64* @PL_amagic_generation, align 8
  %tobool2 = icmp ne i64 %9, 0
  br i1 %tobool2, label %if.then, label %if.end.31

if.then:                                          ; preds = %cond.end
  %10 = load %struct.sv**, %struct.sv*** %sp, align 8
  %11 = load %struct.sv*, %struct.sv** %10, align 8
  store %struct.sv* %11, %struct.sv** %right, align 8
  %12 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %12, i64 -1
  %13 = load %struct.sv*, %struct.sv** %add.ptr, align 8
  store %struct.sv* %13, %struct.sv** %left, align 8
  %14 = load %struct.sv*, %struct.sv** %left, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %14, i32 0, i32 2
  %15 = load i32, i32* %sv_flags, align 4
  %and3 = and i32 %15, 268435456
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %16 = load %struct.sv*, %struct.sv** %right, align 8
  %sv_flags5 = getelementptr inbounds %struct.sv, %struct.sv* %16, i32 0, i32 2
  %17 = load i32, i32* %sv_flags5, align 4
  %and6 = and i32 %17, 268435456
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %land.lhs.true, label %if.end.30

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %18 = load %struct.sv*, %struct.sv** %left, align 8
  %19 = load %struct.sv*, %struct.sv** %right, align 8
  %20 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags8 = getelementptr inbounds %struct.op, %struct.op* %20, i32 0, i32 6
  %21 = load i8, i8* %op_flags8, align 1
  %conv9 = zext i8 %21 to i32
  %and10 = and i32 %conv9, 64
  %tobool11 = icmp ne i32 %and10, 0
  %cond12 = select i1 %tobool11, i32 4, i32 0
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %18, %struct.sv* %19, i32 26, i32 %cond12)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool13 = icmp ne %struct.sv* %call, null
  br i1 %tobool13, label %if.then.14, label %if.end.30

if.then.14:                                       ; preds = %land.lhs.true
  %22 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %22, %struct.sv*** %sp, align 8
  %23 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %23, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %24 = load %struct.sv*, %struct.sv** %23, align 8
  %25 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags15 = getelementptr inbounds %struct.op, %struct.op* %25, i32 0, i32 6
  %26 = load i8, i8* %op_flags15, align 1
  %conv16 = zext i8 %26 to i32
  %and17 = and i32 %conv16, 64
  %tobool18 = icmp ne i32 %and17, 0
  br i1 %tobool18, label %if.then.23, label %lor.lhs.false.19

lor.lhs.false.19:                                 ; preds = %if.then.14
  %27 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags20 = getelementptr inbounds %struct.sv, %struct.sv* %27, i32 0, i32 2
  %28 = load i32, i32* %sv_flags20, align 4
  %and21 = and i32 %28, 1024
  %tobool22 = icmp ne i32 %and21, 0
  br i1 %tobool22, label %if.then.23, label %if.else

if.then.23:                                       ; preds = %lor.lhs.false.19, %if.then.14
  %29 = load %struct.sv*, %struct.sv** %targ, align 8
  %30 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  call void @Perl_sv_setsv_flags(%struct.sv* %29, %struct.sv* %30, i32 2)
  %31 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags24 = getelementptr inbounds %struct.sv, %struct.sv* %31, i32 0, i32 2
  %32 = load i32, i32* %sv_flags24, align 4
  %and25 = and i32 %32, 16384
  %tobool26 = icmp ne i32 %and25, 0
  br i1 %tobool26, label %if.then.27, label %if.end

if.then.27:                                       ; preds = %if.then.23
  %33 = load %struct.sv*, %struct.sv** %targ, align 8
  %call28 = call i32 @Perl_mg_set(%struct.sv* %33)
  br label %if.end

if.end:                                           ; preds = %if.then.27, %if.then.23
  %34 = load %struct.sv*, %struct.sv** %targ, align 8
  %35 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %34, %struct.sv** %35, align 8
  store %struct.sv* %34, %struct.sv** %tmp
  %36 = load %struct.sv*, %struct.sv** %tmp
  br label %if.end.29

if.else:                                          ; preds = %lor.lhs.false.19
  %37 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %38 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %37, %struct.sv** %38, align 8
  br label %if.end.29

if.end.29:                                        ; preds = %if.else, %if.end
  %39 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %39, %struct.sv*** @PL_stack_sp, align 8
  %40 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %40, i32 0, i32 0
  %41 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %41, %struct.op** %retval
  br label %return

if.end.30:                                        ; preds = %land.lhs.true, %lor.lhs.false
  br label %if.end.31

if.end.31:                                        ; preds = %if.end.30, %cond.end
  %42 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr34 = getelementptr inbounds %struct.sv*, %struct.sv** %42, i32 -1
  store %struct.sv** %incdec.ptr34, %struct.sv*** %sp, align 8
  %43 = load %struct.sv*, %struct.sv** %42, align 8
  store %struct.sv* %43, %struct.sv** %right33, align 8
  %44 = load %struct.sv**, %struct.sv*** %sp, align 8
  %45 = load %struct.sv*, %struct.sv** %44, align 8
  store %struct.sv* %45, %struct.sv** %left36, align 8
  %46 = load %struct.sv*, %struct.sv** %left36, align 8
  %sv_flags37 = getelementptr inbounds %struct.sv, %struct.sv* %46, i32 0, i32 2
  %47 = load i32, i32* %sv_flags37, align 4
  %and38 = and i32 %47, 50331648
  %tobool39 = icmp ne i32 %and38, 0
  br i1 %tobool39, label %if.then.44, label %lor.lhs.false.40

lor.lhs.false.40:                                 ; preds = %if.end.31
  %48 = load %struct.sv*, %struct.sv** %right33, align 8
  %sv_flags41 = getelementptr inbounds %struct.sv, %struct.sv* %48, i32 0, i32 2
  %49 = load i32, i32* %sv_flags41, align 4
  %and42 = and i32 %49, 50331648
  %tobool43 = icmp ne i32 %and42, 0
  br i1 %tobool43, label %if.then.44, label %if.else.137

if.then.44:                                       ; preds = %lor.lhs.false.40, %if.end.31
  %50 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %50, i32 0, i32 7
  %51 = load i8, i8* %op_private, align 1
  %conv45 = zext i8 %51 to i32
  %and46 = and i32 %conv45, 1
  %tobool47 = icmp ne i32 %and46, 0
  br i1 %tobool47, label %if.then.48, label %if.else.91

if.then.48:                                       ; preds = %if.then.44
  %52 = load %struct.sv*, %struct.sv** %left36, align 8
  %sv_flags50 = getelementptr inbounds %struct.sv, %struct.sv* %52, i32 0, i32 2
  %53 = load i32, i32* %sv_flags50, align 4
  %and51 = and i32 %53, 118423552
  %tobool52 = icmp ne i32 %and51, 0
  br i1 %tobool52, label %cond.true.62, label %lor.lhs.false.53

lor.lhs.false.53:                                 ; preds = %if.then.48
  %54 = load %struct.sv*, %struct.sv** %left36, align 8
  %sv_flags54 = getelementptr inbounds %struct.sv, %struct.sv* %54, i32 0, i32 2
  %55 = load i32, i32* %sv_flags54, align 4
  %and55 = and i32 %55, 8192
  %tobool56 = icmp ne i32 %and55, 0
  br i1 %tobool56, label %cond.true.62, label %lor.lhs.false.57

lor.lhs.false.57:                                 ; preds = %lor.lhs.false.53
  %56 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags58 = getelementptr inbounds %struct.op, %struct.op* %56, i32 0, i32 6
  %57 = load i8, i8* %op_flags58, align 1
  %conv59 = zext i8 %57 to i32
  %and60 = and i32 %conv59, 64
  %tobool61 = icmp ne i32 %and60, 0
  br i1 %tobool61, label %cond.false.71, label %cond.true.62

cond.true.62:                                     ; preds = %lor.lhs.false.57, %lor.lhs.false.53, %if.then.48
  %58 = load %struct.sv*, %struct.sv** %left36, align 8
  %sv_flags63 = getelementptr inbounds %struct.sv, %struct.sv* %58, i32 0, i32 2
  %59 = load i32, i32* %sv_flags63, align 4
  %and64 = and i32 %59, 65536
  %tobool65 = icmp ne i32 %and64, 0
  br i1 %tobool65, label %cond.true.66, label %cond.false.67

cond.true.66:                                     ; preds = %cond.true.62
  %60 = load %struct.sv*, %struct.sv** %left36, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %60, i32 0, i32 0
  %61 = load i8*, i8** %sv_any, align 8
  %62 = bitcast i8* %61 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %62, i32 0, i32 3
  %63 = load i64, i64* %xiv_iv, align 8
  br label %cond.end.69

cond.false.67:                                    ; preds = %cond.true.62
  %64 = load %struct.sv*, %struct.sv** %left36, align 8
  %call68 = call i64 @Perl_sv_2iv(%struct.sv* %64)
  br label %cond.end.69

cond.end.69:                                      ; preds = %cond.false.67, %cond.true.66
  %cond70 = phi i64 [ %63, %cond.true.66 ], [ %call68, %cond.false.67 ]
  br label %cond.end.72

cond.false.71:                                    ; preds = %lor.lhs.false.57
  br label %cond.end.72

cond.end.72:                                      ; preds = %cond.false.71, %cond.end.69
  %cond73 = phi i64 [ %cond70, %cond.end.69 ], [ 0, %cond.false.71 ]
  %65 = load %struct.sv*, %struct.sv** %right33, align 8
  %sv_flags74 = getelementptr inbounds %struct.sv, %struct.sv* %65, i32 0, i32 2
  %66 = load i32, i32* %sv_flags74, align 4
  %and75 = and i32 %66, 65536
  %tobool76 = icmp ne i32 %and75, 0
  br i1 %tobool76, label %cond.true.77, label %cond.false.80

cond.true.77:                                     ; preds = %cond.end.72
  %67 = load %struct.sv*, %struct.sv** %right33, align 8
  %sv_any78 = getelementptr inbounds %struct.sv, %struct.sv* %67, i32 0, i32 0
  %68 = load i8*, i8** %sv_any78, align 8
  %69 = bitcast i8* %68 to %struct.xpviv*
  %xiv_iv79 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %69, i32 0, i32 3
  %70 = load i64, i64* %xiv_iv79, align 8
  br label %cond.end.82

cond.false.80:                                    ; preds = %cond.end.72
  %71 = load %struct.sv*, %struct.sv** %right33, align 8
  %call81 = call i64 @Perl_sv_2iv(%struct.sv* %71)
  br label %cond.end.82

cond.end.82:                                      ; preds = %cond.false.80, %cond.true.77
  %cond83 = phi i64 [ %70, %cond.true.77 ], [ %call81, %cond.false.80 ]
  %xor = xor i64 %cond73, %cond83
  store i64 %xor, i64* %i, align 8
  %72 = load %struct.sv*, %struct.sv** %targ, align 8
  %73 = load i64, i64* %i, align 8
  call void @Perl_sv_setiv(%struct.sv* %72, i64 %73)
  %74 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags84 = getelementptr inbounds %struct.sv, %struct.sv* %74, i32 0, i32 2
  %75 = load i32, i32* %sv_flags84, align 4
  %and85 = and i32 %75, 16384
  %tobool86 = icmp ne i32 %and85, 0
  br i1 %tobool86, label %if.then.87, label %if.end.89

if.then.87:                                       ; preds = %cond.end.82
  %76 = load %struct.sv*, %struct.sv** %targ, align 8
  %call88 = call i32 @Perl_mg_set(%struct.sv* %76)
  br label %if.end.89

if.end.89:                                        ; preds = %if.then.87, %cond.end.82
  %77 = load %struct.sv*, %struct.sv** %targ, align 8
  %78 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %77, %struct.sv** %78, align 8
  store %struct.sv* %77, %struct.sv** %tmp90
  %79 = load %struct.sv*, %struct.sv** %tmp90
  br label %if.end.136

if.else.91:                                       ; preds = %if.then.44
  %80 = load %struct.sv*, %struct.sv** %left36, align 8
  %sv_flags93 = getelementptr inbounds %struct.sv, %struct.sv* %80, i32 0, i32 2
  %81 = load i32, i32* %sv_flags93, align 4
  %and94 = and i32 %81, 118423552
  %tobool95 = icmp ne i32 %and94, 0
  br i1 %tobool95, label %cond.true.105, label %lor.lhs.false.96

lor.lhs.false.96:                                 ; preds = %if.else.91
  %82 = load %struct.sv*, %struct.sv** %left36, align 8
  %sv_flags97 = getelementptr inbounds %struct.sv, %struct.sv* %82, i32 0, i32 2
  %83 = load i32, i32* %sv_flags97, align 4
  %and98 = and i32 %83, 8192
  %tobool99 = icmp ne i32 %and98, 0
  br i1 %tobool99, label %cond.true.105, label %lor.lhs.false.100

lor.lhs.false.100:                                ; preds = %lor.lhs.false.96
  %84 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags101 = getelementptr inbounds %struct.op, %struct.op* %84, i32 0, i32 6
  %85 = load i8, i8* %op_flags101, align 1
  %conv102 = zext i8 %85 to i32
  %and103 = and i32 %conv102, 64
  %tobool104 = icmp ne i32 %and103, 0
  br i1 %tobool104, label %cond.false.115, label %cond.true.105

cond.true.105:                                    ; preds = %lor.lhs.false.100, %lor.lhs.false.96, %if.else.91
  %86 = load %struct.sv*, %struct.sv** %left36, align 8
  %sv_flags106 = getelementptr inbounds %struct.sv, %struct.sv* %86, i32 0, i32 2
  %87 = load i32, i32* %sv_flags106, align 4
  %and107 = and i32 %87, 65536
  %tobool108 = icmp ne i32 %and107, 0
  br i1 %tobool108, label %cond.true.109, label %cond.false.111

cond.true.109:                                    ; preds = %cond.true.105
  %88 = load %struct.sv*, %struct.sv** %left36, align 8
  %sv_any110 = getelementptr inbounds %struct.sv, %struct.sv* %88, i32 0, i32 0
  %89 = load i8*, i8** %sv_any110, align 8
  %90 = bitcast i8* %89 to %struct.xpvuv*
  %xuv_uv = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %90, i32 0, i32 3
  %91 = load i64, i64* %xuv_uv, align 8
  br label %cond.end.113

cond.false.111:                                   ; preds = %cond.true.105
  %92 = load %struct.sv*, %struct.sv** %left36, align 8
  %call112 = call i64 @Perl_sv_2uv(%struct.sv* %92)
  br label %cond.end.113

cond.end.113:                                     ; preds = %cond.false.111, %cond.true.109
  %cond114 = phi i64 [ %91, %cond.true.109 ], [ %call112, %cond.false.111 ]
  br label %cond.end.116

cond.false.115:                                   ; preds = %lor.lhs.false.100
  br label %cond.end.116

cond.end.116:                                     ; preds = %cond.false.115, %cond.end.113
  %cond117 = phi i64 [ %cond114, %cond.end.113 ], [ 0, %cond.false.115 ]
  %93 = load %struct.sv*, %struct.sv** %right33, align 8
  %sv_flags118 = getelementptr inbounds %struct.sv, %struct.sv* %93, i32 0, i32 2
  %94 = load i32, i32* %sv_flags118, align 4
  %and119 = and i32 %94, 65536
  %tobool120 = icmp ne i32 %and119, 0
  br i1 %tobool120, label %cond.true.121, label %cond.false.124

cond.true.121:                                    ; preds = %cond.end.116
  %95 = load %struct.sv*, %struct.sv** %right33, align 8
  %sv_any122 = getelementptr inbounds %struct.sv, %struct.sv* %95, i32 0, i32 0
  %96 = load i8*, i8** %sv_any122, align 8
  %97 = bitcast i8* %96 to %struct.xpvuv*
  %xuv_uv123 = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %97, i32 0, i32 3
  %98 = load i64, i64* %xuv_uv123, align 8
  br label %cond.end.126

cond.false.124:                                   ; preds = %cond.end.116
  %99 = load %struct.sv*, %struct.sv** %right33, align 8
  %call125 = call i64 @Perl_sv_2uv(%struct.sv* %99)
  br label %cond.end.126

cond.end.126:                                     ; preds = %cond.false.124, %cond.true.121
  %cond127 = phi i64 [ %98, %cond.true.121 ], [ %call125, %cond.false.124 ]
  %xor128 = xor i64 %cond117, %cond127
  store i64 %xor128, i64* %u, align 8
  %100 = load %struct.sv*, %struct.sv** %targ, align 8
  %101 = load i64, i64* %u, align 8
  call void @Perl_sv_setuv(%struct.sv* %100, i64 %101)
  %102 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags129 = getelementptr inbounds %struct.sv, %struct.sv* %102, i32 0, i32 2
  %103 = load i32, i32* %sv_flags129, align 4
  %and130 = and i32 %103, 16384
  %tobool131 = icmp ne i32 %and130, 0
  br i1 %tobool131, label %if.then.132, label %if.end.134

if.then.132:                                      ; preds = %cond.end.126
  %104 = load %struct.sv*, %struct.sv** %targ, align 8
  %call133 = call i32 @Perl_mg_set(%struct.sv* %104)
  br label %if.end.134

if.end.134:                                       ; preds = %if.then.132, %cond.end.126
  %105 = load %struct.sv*, %struct.sv** %targ, align 8
  %106 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %105, %struct.sv** %106, align 8
  store %struct.sv* %105, %struct.sv** %tmp135
  %107 = load %struct.sv*, %struct.sv** %tmp135
  br label %if.end.136

if.end.136:                                       ; preds = %if.end.134, %if.end.89
  br label %if.end.146

if.else.137:                                      ; preds = %lor.lhs.false.40
  %108 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %108, i32 0, i32 4
  %109 = load i16, i16* %op_type, align 2
  %conv138 = zext i16 %109 to i32
  %110 = load %struct.sv*, %struct.sv** %targ, align 8
  %111 = load %struct.sv*, %struct.sv** %left36, align 8
  %112 = load %struct.sv*, %struct.sv** %right33, align 8
  call void @Perl_do_vop(i32 %conv138, %struct.sv* %110, %struct.sv* %111, %struct.sv* %112)
  %113 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags139 = getelementptr inbounds %struct.sv, %struct.sv* %113, i32 0, i32 2
  %114 = load i32, i32* %sv_flags139, align 4
  %and140 = and i32 %114, 16384
  %tobool141 = icmp ne i32 %and140, 0
  br i1 %tobool141, label %if.then.142, label %if.end.144

if.then.142:                                      ; preds = %if.else.137
  %115 = load %struct.sv*, %struct.sv** %targ, align 8
  %call143 = call i32 @Perl_mg_set(%struct.sv* %115)
  br label %if.end.144

if.end.144:                                       ; preds = %if.then.142, %if.else.137
  %116 = load %struct.sv*, %struct.sv** %targ, align 8
  %117 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %116, %struct.sv** %117, align 8
  store %struct.sv* %116, %struct.sv** %tmp145
  %118 = load %struct.sv*, %struct.sv** %tmp145
  br label %if.end.146

if.end.146:                                       ; preds = %if.end.144, %if.end.136
  %119 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %119, %struct.sv*** @PL_stack_sp, align 8
  %120 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next147 = getelementptr inbounds %struct.op, %struct.op* %120, i32 0, i32 0
  %121 = load %struct.op*, %struct.op** %op_next147, align 8
  store %struct.op* %121, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.146, %if.end.29
  %122 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %122
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_bit_or() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %right = alloca %struct.sv*, align 8
  %left = alloca %struct.sv*, align 8
  %tmp = alloca %struct.sv*, align 8
  %right33 = alloca %struct.sv*, align 8
  %left36 = alloca %struct.sv*, align 8
  %i = alloca i64, align 8
  %tmp90 = alloca %struct.sv*, align 8
  %u = alloca i64, align 8
  %tmp135 = alloca %struct.sv*, align 8
  %tmp145 = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 6
  %2 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 64
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load %struct.sv**, %struct.sv*** %sp, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 -1
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %5 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %5, i32 0, i32 3
  %6 = load i64, i64* %op_targ, align 8
  %7 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx1 = getelementptr inbounds %struct.sv*, %struct.sv** %7, i64 %6
  %8 = load %struct.sv*, %struct.sv** %arrayidx1, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.sv* [ %4, %cond.true ], [ %8, %cond.false ]
  store %struct.sv* %cond, %struct.sv** %targ, align 8
  %9 = load i64, i64* @PL_amagic_generation, align 8
  %tobool2 = icmp ne i64 %9, 0
  br i1 %tobool2, label %if.then, label %if.end.31

if.then:                                          ; preds = %cond.end
  %10 = load %struct.sv**, %struct.sv*** %sp, align 8
  %11 = load %struct.sv*, %struct.sv** %10, align 8
  store %struct.sv* %11, %struct.sv** %right, align 8
  %12 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %12, i64 -1
  %13 = load %struct.sv*, %struct.sv** %add.ptr, align 8
  store %struct.sv* %13, %struct.sv** %left, align 8
  %14 = load %struct.sv*, %struct.sv** %left, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %14, i32 0, i32 2
  %15 = load i32, i32* %sv_flags, align 4
  %and3 = and i32 %15, 268435456
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %16 = load %struct.sv*, %struct.sv** %right, align 8
  %sv_flags5 = getelementptr inbounds %struct.sv, %struct.sv* %16, i32 0, i32 2
  %17 = load i32, i32* %sv_flags5, align 4
  %and6 = and i32 %17, 268435456
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %land.lhs.true, label %if.end.30

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %18 = load %struct.sv*, %struct.sv** %left, align 8
  %19 = load %struct.sv*, %struct.sv** %right, align 8
  %20 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags8 = getelementptr inbounds %struct.op, %struct.op* %20, i32 0, i32 6
  %21 = load i8, i8* %op_flags8, align 1
  %conv9 = zext i8 %21 to i32
  %and10 = and i32 %conv9, 64
  %tobool11 = icmp ne i32 %and10, 0
  %cond12 = select i1 %tobool11, i32 4, i32 0
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %18, %struct.sv* %19, i32 24, i32 %cond12)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool13 = icmp ne %struct.sv* %call, null
  br i1 %tobool13, label %if.then.14, label %if.end.30

if.then.14:                                       ; preds = %land.lhs.true
  %22 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %22, %struct.sv*** %sp, align 8
  %23 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %23, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %24 = load %struct.sv*, %struct.sv** %23, align 8
  %25 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags15 = getelementptr inbounds %struct.op, %struct.op* %25, i32 0, i32 6
  %26 = load i8, i8* %op_flags15, align 1
  %conv16 = zext i8 %26 to i32
  %and17 = and i32 %conv16, 64
  %tobool18 = icmp ne i32 %and17, 0
  br i1 %tobool18, label %if.then.23, label %lor.lhs.false.19

lor.lhs.false.19:                                 ; preds = %if.then.14
  %27 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags20 = getelementptr inbounds %struct.sv, %struct.sv* %27, i32 0, i32 2
  %28 = load i32, i32* %sv_flags20, align 4
  %and21 = and i32 %28, 1024
  %tobool22 = icmp ne i32 %and21, 0
  br i1 %tobool22, label %if.then.23, label %if.else

if.then.23:                                       ; preds = %lor.lhs.false.19, %if.then.14
  %29 = load %struct.sv*, %struct.sv** %targ, align 8
  %30 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  call void @Perl_sv_setsv_flags(%struct.sv* %29, %struct.sv* %30, i32 2)
  %31 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags24 = getelementptr inbounds %struct.sv, %struct.sv* %31, i32 0, i32 2
  %32 = load i32, i32* %sv_flags24, align 4
  %and25 = and i32 %32, 16384
  %tobool26 = icmp ne i32 %and25, 0
  br i1 %tobool26, label %if.then.27, label %if.end

if.then.27:                                       ; preds = %if.then.23
  %33 = load %struct.sv*, %struct.sv** %targ, align 8
  %call28 = call i32 @Perl_mg_set(%struct.sv* %33)
  br label %if.end

if.end:                                           ; preds = %if.then.27, %if.then.23
  %34 = load %struct.sv*, %struct.sv** %targ, align 8
  %35 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %34, %struct.sv** %35, align 8
  store %struct.sv* %34, %struct.sv** %tmp
  %36 = load %struct.sv*, %struct.sv** %tmp
  br label %if.end.29

if.else:                                          ; preds = %lor.lhs.false.19
  %37 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %38 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %37, %struct.sv** %38, align 8
  br label %if.end.29

if.end.29:                                        ; preds = %if.else, %if.end
  %39 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %39, %struct.sv*** @PL_stack_sp, align 8
  %40 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %40, i32 0, i32 0
  %41 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %41, %struct.op** %retval
  br label %return

if.end.30:                                        ; preds = %land.lhs.true, %lor.lhs.false
  br label %if.end.31

if.end.31:                                        ; preds = %if.end.30, %cond.end
  %42 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr34 = getelementptr inbounds %struct.sv*, %struct.sv** %42, i32 -1
  store %struct.sv** %incdec.ptr34, %struct.sv*** %sp, align 8
  %43 = load %struct.sv*, %struct.sv** %42, align 8
  store %struct.sv* %43, %struct.sv** %right33, align 8
  %44 = load %struct.sv**, %struct.sv*** %sp, align 8
  %45 = load %struct.sv*, %struct.sv** %44, align 8
  store %struct.sv* %45, %struct.sv** %left36, align 8
  %46 = load %struct.sv*, %struct.sv** %left36, align 8
  %sv_flags37 = getelementptr inbounds %struct.sv, %struct.sv* %46, i32 0, i32 2
  %47 = load i32, i32* %sv_flags37, align 4
  %and38 = and i32 %47, 50331648
  %tobool39 = icmp ne i32 %and38, 0
  br i1 %tobool39, label %if.then.44, label %lor.lhs.false.40

lor.lhs.false.40:                                 ; preds = %if.end.31
  %48 = load %struct.sv*, %struct.sv** %right33, align 8
  %sv_flags41 = getelementptr inbounds %struct.sv, %struct.sv* %48, i32 0, i32 2
  %49 = load i32, i32* %sv_flags41, align 4
  %and42 = and i32 %49, 50331648
  %tobool43 = icmp ne i32 %and42, 0
  br i1 %tobool43, label %if.then.44, label %if.else.137

if.then.44:                                       ; preds = %lor.lhs.false.40, %if.end.31
  %50 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %50, i32 0, i32 7
  %51 = load i8, i8* %op_private, align 1
  %conv45 = zext i8 %51 to i32
  %and46 = and i32 %conv45, 1
  %tobool47 = icmp ne i32 %and46, 0
  br i1 %tobool47, label %if.then.48, label %if.else.91

if.then.48:                                       ; preds = %if.then.44
  %52 = load %struct.sv*, %struct.sv** %left36, align 8
  %sv_flags50 = getelementptr inbounds %struct.sv, %struct.sv* %52, i32 0, i32 2
  %53 = load i32, i32* %sv_flags50, align 4
  %and51 = and i32 %53, 118423552
  %tobool52 = icmp ne i32 %and51, 0
  br i1 %tobool52, label %cond.true.62, label %lor.lhs.false.53

lor.lhs.false.53:                                 ; preds = %if.then.48
  %54 = load %struct.sv*, %struct.sv** %left36, align 8
  %sv_flags54 = getelementptr inbounds %struct.sv, %struct.sv* %54, i32 0, i32 2
  %55 = load i32, i32* %sv_flags54, align 4
  %and55 = and i32 %55, 8192
  %tobool56 = icmp ne i32 %and55, 0
  br i1 %tobool56, label %cond.true.62, label %lor.lhs.false.57

lor.lhs.false.57:                                 ; preds = %lor.lhs.false.53
  %56 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags58 = getelementptr inbounds %struct.op, %struct.op* %56, i32 0, i32 6
  %57 = load i8, i8* %op_flags58, align 1
  %conv59 = zext i8 %57 to i32
  %and60 = and i32 %conv59, 64
  %tobool61 = icmp ne i32 %and60, 0
  br i1 %tobool61, label %cond.false.71, label %cond.true.62

cond.true.62:                                     ; preds = %lor.lhs.false.57, %lor.lhs.false.53, %if.then.48
  %58 = load %struct.sv*, %struct.sv** %left36, align 8
  %sv_flags63 = getelementptr inbounds %struct.sv, %struct.sv* %58, i32 0, i32 2
  %59 = load i32, i32* %sv_flags63, align 4
  %and64 = and i32 %59, 65536
  %tobool65 = icmp ne i32 %and64, 0
  br i1 %tobool65, label %cond.true.66, label %cond.false.67

cond.true.66:                                     ; preds = %cond.true.62
  %60 = load %struct.sv*, %struct.sv** %left36, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %60, i32 0, i32 0
  %61 = load i8*, i8** %sv_any, align 8
  %62 = bitcast i8* %61 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %62, i32 0, i32 3
  %63 = load i64, i64* %xiv_iv, align 8
  br label %cond.end.69

cond.false.67:                                    ; preds = %cond.true.62
  %64 = load %struct.sv*, %struct.sv** %left36, align 8
  %call68 = call i64 @Perl_sv_2iv(%struct.sv* %64)
  br label %cond.end.69

cond.end.69:                                      ; preds = %cond.false.67, %cond.true.66
  %cond70 = phi i64 [ %63, %cond.true.66 ], [ %call68, %cond.false.67 ]
  br label %cond.end.72

cond.false.71:                                    ; preds = %lor.lhs.false.57
  br label %cond.end.72

cond.end.72:                                      ; preds = %cond.false.71, %cond.end.69
  %cond73 = phi i64 [ %cond70, %cond.end.69 ], [ 0, %cond.false.71 ]
  %65 = load %struct.sv*, %struct.sv** %right33, align 8
  %sv_flags74 = getelementptr inbounds %struct.sv, %struct.sv* %65, i32 0, i32 2
  %66 = load i32, i32* %sv_flags74, align 4
  %and75 = and i32 %66, 65536
  %tobool76 = icmp ne i32 %and75, 0
  br i1 %tobool76, label %cond.true.77, label %cond.false.80

cond.true.77:                                     ; preds = %cond.end.72
  %67 = load %struct.sv*, %struct.sv** %right33, align 8
  %sv_any78 = getelementptr inbounds %struct.sv, %struct.sv* %67, i32 0, i32 0
  %68 = load i8*, i8** %sv_any78, align 8
  %69 = bitcast i8* %68 to %struct.xpviv*
  %xiv_iv79 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %69, i32 0, i32 3
  %70 = load i64, i64* %xiv_iv79, align 8
  br label %cond.end.82

cond.false.80:                                    ; preds = %cond.end.72
  %71 = load %struct.sv*, %struct.sv** %right33, align 8
  %call81 = call i64 @Perl_sv_2iv(%struct.sv* %71)
  br label %cond.end.82

cond.end.82:                                      ; preds = %cond.false.80, %cond.true.77
  %cond83 = phi i64 [ %70, %cond.true.77 ], [ %call81, %cond.false.80 ]
  %or = or i64 %cond73, %cond83
  store i64 %or, i64* %i, align 8
  %72 = load %struct.sv*, %struct.sv** %targ, align 8
  %73 = load i64, i64* %i, align 8
  call void @Perl_sv_setiv(%struct.sv* %72, i64 %73)
  %74 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags84 = getelementptr inbounds %struct.sv, %struct.sv* %74, i32 0, i32 2
  %75 = load i32, i32* %sv_flags84, align 4
  %and85 = and i32 %75, 16384
  %tobool86 = icmp ne i32 %and85, 0
  br i1 %tobool86, label %if.then.87, label %if.end.89

if.then.87:                                       ; preds = %cond.end.82
  %76 = load %struct.sv*, %struct.sv** %targ, align 8
  %call88 = call i32 @Perl_mg_set(%struct.sv* %76)
  br label %if.end.89

if.end.89:                                        ; preds = %if.then.87, %cond.end.82
  %77 = load %struct.sv*, %struct.sv** %targ, align 8
  %78 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %77, %struct.sv** %78, align 8
  store %struct.sv* %77, %struct.sv** %tmp90
  %79 = load %struct.sv*, %struct.sv** %tmp90
  br label %if.end.136

if.else.91:                                       ; preds = %if.then.44
  %80 = load %struct.sv*, %struct.sv** %left36, align 8
  %sv_flags93 = getelementptr inbounds %struct.sv, %struct.sv* %80, i32 0, i32 2
  %81 = load i32, i32* %sv_flags93, align 4
  %and94 = and i32 %81, 118423552
  %tobool95 = icmp ne i32 %and94, 0
  br i1 %tobool95, label %cond.true.105, label %lor.lhs.false.96

lor.lhs.false.96:                                 ; preds = %if.else.91
  %82 = load %struct.sv*, %struct.sv** %left36, align 8
  %sv_flags97 = getelementptr inbounds %struct.sv, %struct.sv* %82, i32 0, i32 2
  %83 = load i32, i32* %sv_flags97, align 4
  %and98 = and i32 %83, 8192
  %tobool99 = icmp ne i32 %and98, 0
  br i1 %tobool99, label %cond.true.105, label %lor.lhs.false.100

lor.lhs.false.100:                                ; preds = %lor.lhs.false.96
  %84 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags101 = getelementptr inbounds %struct.op, %struct.op* %84, i32 0, i32 6
  %85 = load i8, i8* %op_flags101, align 1
  %conv102 = zext i8 %85 to i32
  %and103 = and i32 %conv102, 64
  %tobool104 = icmp ne i32 %and103, 0
  br i1 %tobool104, label %cond.false.115, label %cond.true.105

cond.true.105:                                    ; preds = %lor.lhs.false.100, %lor.lhs.false.96, %if.else.91
  %86 = load %struct.sv*, %struct.sv** %left36, align 8
  %sv_flags106 = getelementptr inbounds %struct.sv, %struct.sv* %86, i32 0, i32 2
  %87 = load i32, i32* %sv_flags106, align 4
  %and107 = and i32 %87, 65536
  %tobool108 = icmp ne i32 %and107, 0
  br i1 %tobool108, label %cond.true.109, label %cond.false.111

cond.true.109:                                    ; preds = %cond.true.105
  %88 = load %struct.sv*, %struct.sv** %left36, align 8
  %sv_any110 = getelementptr inbounds %struct.sv, %struct.sv* %88, i32 0, i32 0
  %89 = load i8*, i8** %sv_any110, align 8
  %90 = bitcast i8* %89 to %struct.xpvuv*
  %xuv_uv = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %90, i32 0, i32 3
  %91 = load i64, i64* %xuv_uv, align 8
  br label %cond.end.113

cond.false.111:                                   ; preds = %cond.true.105
  %92 = load %struct.sv*, %struct.sv** %left36, align 8
  %call112 = call i64 @Perl_sv_2uv(%struct.sv* %92)
  br label %cond.end.113

cond.end.113:                                     ; preds = %cond.false.111, %cond.true.109
  %cond114 = phi i64 [ %91, %cond.true.109 ], [ %call112, %cond.false.111 ]
  br label %cond.end.116

cond.false.115:                                   ; preds = %lor.lhs.false.100
  br label %cond.end.116

cond.end.116:                                     ; preds = %cond.false.115, %cond.end.113
  %cond117 = phi i64 [ %cond114, %cond.end.113 ], [ 0, %cond.false.115 ]
  %93 = load %struct.sv*, %struct.sv** %right33, align 8
  %sv_flags118 = getelementptr inbounds %struct.sv, %struct.sv* %93, i32 0, i32 2
  %94 = load i32, i32* %sv_flags118, align 4
  %and119 = and i32 %94, 65536
  %tobool120 = icmp ne i32 %and119, 0
  br i1 %tobool120, label %cond.true.121, label %cond.false.124

cond.true.121:                                    ; preds = %cond.end.116
  %95 = load %struct.sv*, %struct.sv** %right33, align 8
  %sv_any122 = getelementptr inbounds %struct.sv, %struct.sv* %95, i32 0, i32 0
  %96 = load i8*, i8** %sv_any122, align 8
  %97 = bitcast i8* %96 to %struct.xpvuv*
  %xuv_uv123 = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %97, i32 0, i32 3
  %98 = load i64, i64* %xuv_uv123, align 8
  br label %cond.end.126

cond.false.124:                                   ; preds = %cond.end.116
  %99 = load %struct.sv*, %struct.sv** %right33, align 8
  %call125 = call i64 @Perl_sv_2uv(%struct.sv* %99)
  br label %cond.end.126

cond.end.126:                                     ; preds = %cond.false.124, %cond.true.121
  %cond127 = phi i64 [ %98, %cond.true.121 ], [ %call125, %cond.false.124 ]
  %or128 = or i64 %cond117, %cond127
  store i64 %or128, i64* %u, align 8
  %100 = load %struct.sv*, %struct.sv** %targ, align 8
  %101 = load i64, i64* %u, align 8
  call void @Perl_sv_setuv(%struct.sv* %100, i64 %101)
  %102 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags129 = getelementptr inbounds %struct.sv, %struct.sv* %102, i32 0, i32 2
  %103 = load i32, i32* %sv_flags129, align 4
  %and130 = and i32 %103, 16384
  %tobool131 = icmp ne i32 %and130, 0
  br i1 %tobool131, label %if.then.132, label %if.end.134

if.then.132:                                      ; preds = %cond.end.126
  %104 = load %struct.sv*, %struct.sv** %targ, align 8
  %call133 = call i32 @Perl_mg_set(%struct.sv* %104)
  br label %if.end.134

if.end.134:                                       ; preds = %if.then.132, %cond.end.126
  %105 = load %struct.sv*, %struct.sv** %targ, align 8
  %106 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %105, %struct.sv** %106, align 8
  store %struct.sv* %105, %struct.sv** %tmp135
  %107 = load %struct.sv*, %struct.sv** %tmp135
  br label %if.end.136

if.end.136:                                       ; preds = %if.end.134, %if.end.89
  br label %if.end.146

if.else.137:                                      ; preds = %lor.lhs.false.40
  %108 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_type = getelementptr inbounds %struct.op, %struct.op* %108, i32 0, i32 4
  %109 = load i16, i16* %op_type, align 2
  %conv138 = zext i16 %109 to i32
  %110 = load %struct.sv*, %struct.sv** %targ, align 8
  %111 = load %struct.sv*, %struct.sv** %left36, align 8
  %112 = load %struct.sv*, %struct.sv** %right33, align 8
  call void @Perl_do_vop(i32 %conv138, %struct.sv* %110, %struct.sv* %111, %struct.sv* %112)
  %113 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags139 = getelementptr inbounds %struct.sv, %struct.sv* %113, i32 0, i32 2
  %114 = load i32, i32* %sv_flags139, align 4
  %and140 = and i32 %114, 16384
  %tobool141 = icmp ne i32 %and140, 0
  br i1 %tobool141, label %if.then.142, label %if.end.144

if.then.142:                                      ; preds = %if.else.137
  %115 = load %struct.sv*, %struct.sv** %targ, align 8
  %call143 = call i32 @Perl_mg_set(%struct.sv* %115)
  br label %if.end.144

if.end.144:                                       ; preds = %if.then.142, %if.else.137
  %116 = load %struct.sv*, %struct.sv** %targ, align 8
  %117 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %116, %struct.sv** %117, align 8
  store %struct.sv* %116, %struct.sv** %tmp145
  %118 = load %struct.sv*, %struct.sv** %tmp145
  br label %if.end.146

if.end.146:                                       ; preds = %if.end.144, %if.end.136
  %119 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %119, %struct.sv*** @PL_stack_sp, align 8
  %120 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next147 = getelementptr inbounds %struct.op, %struct.op* %120, i32 0, i32 0
  %121 = load %struct.op*, %struct.op** %op_next147, align 8
  store %struct.op* %121, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.146, %if.end.29
  %122 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %122
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_negate() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %arg = alloca %struct.sv*, align 8
  %tmp = alloca %struct.sv*, align 8
  %sv = alloca %struct.sv*, align 8
  %flags = alloca i32, align 4
  %tmp44 = alloca %struct.sv*, align 8
  %tmp58 = alloca %struct.sv*, align 8
  %tmp76 = alloca %struct.sv*, align 8
  %tmp85 = alloca %struct.sv*, align 8
  %tmp105 = alloca %struct.sv*, align 8
  %len = alloca i64, align 8
  %s = alloca i8*, align 8
  %tmp272 = alloca %struct.sv*, align 8
  %tmp291 = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 3
  %2 = load i64, i64* %op_targ, align 8
  %3 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 %2
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %4, %struct.sv** %targ, align 8
  %5 = load i64, i64* @PL_amagic_generation, align 8
  %tobool = icmp ne i64 %5, 0
  br i1 %tobool, label %if.then, label %if.end.16

if.then:                                          ; preds = %entry
  %6 = load %struct.sv**, %struct.sv*** %sp, align 8
  %arrayidx1 = getelementptr inbounds %struct.sv*, %struct.sv** %6, i64 0
  %7 = load %struct.sv*, %struct.sv** %arrayidx1, align 8
  store %struct.sv* %7, %struct.sv** %arg, align 8
  br label %am_again

am_again:                                         ; preds = %if.then
  %8 = load %struct.sv*, %struct.sv** %arg, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %8, i32 0, i32 2
  %9 = load i32, i32* %sv_flags, align 4
  %and = and i32 %9, 268435456
  %tobool2 = icmp ne i32 %and, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end.15

land.lhs.true:                                    ; preds = %am_again
  %10 = load %struct.sv*, %struct.sv** %arg, align 8
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %10, %struct.sv* @PL_sv_undef, i32 57, i32 9)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool3 = icmp ne %struct.sv* %call, null
  br i1 %tobool3, label %if.then.4, label %if.end.15

if.then.4:                                        ; preds = %land.lhs.true
  %11 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %11, %struct.sv*** %sp, align 8
  %12 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags5 = getelementptr inbounds %struct.sv, %struct.sv* %12, i32 0, i32 2
  %13 = load i32, i32* %sv_flags5, align 4
  %and6 = and i32 %13, 1024
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %if.then.8, label %if.else

if.then.8:                                        ; preds = %if.then.4
  %14 = load %struct.sv*, %struct.sv** %targ, align 8
  %15 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  call void @Perl_sv_setsv_flags(%struct.sv* %14, %struct.sv* %15, i32 2)
  %16 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags9 = getelementptr inbounds %struct.sv, %struct.sv* %16, i32 0, i32 2
  %17 = load i32, i32* %sv_flags9, align 4
  %and10 = and i32 %17, 16384
  %tobool11 = icmp ne i32 %and10, 0
  br i1 %tobool11, label %if.then.12, label %if.end

if.then.12:                                       ; preds = %if.then.8
  %18 = load %struct.sv*, %struct.sv** %targ, align 8
  %call13 = call i32 @Perl_mg_set(%struct.sv* %18)
  br label %if.end

if.end:                                           ; preds = %if.then.12, %if.then.8
  %19 = load %struct.sv*, %struct.sv** %targ, align 8
  %20 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %19, %struct.sv** %20, align 8
  store %struct.sv* %19, %struct.sv** %tmp
  %21 = load %struct.sv*, %struct.sv** %tmp
  br label %if.end.14

if.else:                                          ; preds = %if.then.4
  %22 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %23 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %22, %struct.sv** %23, align 8
  br label %if.end.14

if.end.14:                                        ; preds = %if.else, %if.end
  %24 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %24, %struct.sv*** @PL_stack_sp, align 8
  %25 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %25, i32 0, i32 0
  %26 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %26, %struct.op** %retval
  br label %return

if.end.15:                                        ; preds = %land.lhs.true, %am_again
  br label %if.end.16

if.end.16:                                        ; preds = %if.end.15, %entry
  %27 = load %struct.sv**, %struct.sv*** %sp, align 8
  %28 = load %struct.sv*, %struct.sv** %27, align 8
  store %struct.sv* %28, %struct.sv** %sv, align 8
  %29 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags19 = getelementptr inbounds %struct.sv, %struct.sv* %29, i32 0, i32 2
  %30 = load i32, i32* %sv_flags19, align 4
  store i32 %30, i32* %flags, align 4
  %31 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags20 = getelementptr inbounds %struct.sv, %struct.sv* %31, i32 0, i32 2
  %32 = load i32, i32* %sv_flags20, align 4
  %and21 = and i32 %32, 8192
  %tobool22 = icmp ne i32 %and21, 0
  br i1 %tobool22, label %if.then.23, label %if.end.25

if.then.23:                                       ; preds = %if.end.16
  %33 = load %struct.sv*, %struct.sv** %sv, align 8
  %call24 = call i32 @Perl_mg_get(%struct.sv* %33)
  br label %if.end.25

if.end.25:                                        ; preds = %if.then.23, %if.end.16
  %34 = load i32, i32* %flags, align 4
  %and26 = and i32 %34, 65536
  %tobool27 = icmp ne i32 %and26, 0
  br i1 %tobool27, label %if.then.29, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end.25
  %35 = load i32, i32* %flags, align 4
  %and28 = and i32 %35, 50331648
  %cmp = icmp eq i32 %and28, 16777216
  br i1 %cmp, label %if.then.29, label %if.end.88

if.then.29:                                       ; preds = %lor.lhs.false, %if.end.25
  br label %oops_its_an_int

oops_its_an_int:                                  ; preds = %if.then.250, %if.then.204, %if.then.29
  %36 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags30 = getelementptr inbounds %struct.sv, %struct.sv* %36, i32 0, i32 2
  %37 = load i32, i32* %sv_flags30, align 4
  %and31 = and i32 %37, -2147483648
  %tobool32 = icmp ne i32 %and31, 0
  br i1 %tobool32, label %if.then.33, label %if.else.62

if.then.33:                                       ; preds = %oops_its_an_int
  %38 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %38, i32 0, i32 0
  %39 = load i8*, i8** %sv_any, align 8
  %40 = bitcast i8* %39 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %40, i32 0, i32 3
  %41 = load i64, i64* %xiv_iv, align 8
  %cmp34 = icmp eq i64 %41, -9223372036854775808
  br i1 %cmp34, label %if.then.35, label %if.else.46

if.then.35:                                       ; preds = %if.then.33
  %42 = load %struct.sv*, %struct.sv** %targ, align 8
  %43 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any36 = getelementptr inbounds %struct.sv, %struct.sv* %43, i32 0, i32 0
  %44 = load i8*, i8** %sv_any36, align 8
  %45 = bitcast i8* %44 to %struct.xpviv*
  %xiv_iv37 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %45, i32 0, i32 3
  %46 = load i64, i64* %xiv_iv37, align 8
  call void @Perl_sv_setiv(%struct.sv* %42, i64 %46)
  %47 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags38 = getelementptr inbounds %struct.sv, %struct.sv* %47, i32 0, i32 2
  %48 = load i32, i32* %sv_flags38, align 4
  %and39 = and i32 %48, 16384
  %tobool40 = icmp ne i32 %and39, 0
  br i1 %tobool40, label %if.then.41, label %if.end.43

if.then.41:                                       ; preds = %if.then.35
  %49 = load %struct.sv*, %struct.sv** %targ, align 8
  %call42 = call i32 @Perl_mg_set(%struct.sv* %49)
  br label %if.end.43

if.end.43:                                        ; preds = %if.then.41, %if.then.35
  %50 = load %struct.sv*, %struct.sv** %targ, align 8
  %51 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %50, %struct.sv** %51, align 8
  store %struct.sv* %50, %struct.sv** %tmp44
  %52 = load %struct.sv*, %struct.sv** %tmp44
  %53 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %53, %struct.sv*** @PL_stack_sp, align 8
  %54 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next45 = getelementptr inbounds %struct.op, %struct.op* %54, i32 0, i32 0
  %55 = load %struct.op*, %struct.op** %op_next45, align 8
  store %struct.op* %55, %struct.op** %retval
  br label %return

if.else.46:                                       ; preds = %if.then.33
  %56 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any47 = getelementptr inbounds %struct.sv, %struct.sv* %56, i32 0, i32 0
  %57 = load i8*, i8** %sv_any47, align 8
  %58 = bitcast i8* %57 to %struct.xpvuv*
  %xuv_uv = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %58, i32 0, i32 3
  %59 = load i64, i64* %xuv_uv, align 8
  %cmp48 = icmp ule i64 %59, 9223372036854775807
  br i1 %cmp48, label %if.then.49, label %if.end.60

if.then.49:                                       ; preds = %if.else.46
  %60 = load %struct.sv*, %struct.sv** %targ, align 8
  %61 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any50 = getelementptr inbounds %struct.sv, %struct.sv* %61, i32 0, i32 0
  %62 = load i8*, i8** %sv_any50, align 8
  %63 = bitcast i8* %62 to %struct.xpviv*
  %xiv_iv51 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %63, i32 0, i32 3
  %64 = load i64, i64* %xiv_iv51, align 8
  %sub = sub nsw i64 0, %64
  call void @Perl_sv_setiv(%struct.sv* %60, i64 %sub)
  %65 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags52 = getelementptr inbounds %struct.sv, %struct.sv* %65, i32 0, i32 2
  %66 = load i32, i32* %sv_flags52, align 4
  %and53 = and i32 %66, 16384
  %tobool54 = icmp ne i32 %and53, 0
  br i1 %tobool54, label %if.then.55, label %if.end.57

if.then.55:                                       ; preds = %if.then.49
  %67 = load %struct.sv*, %struct.sv** %targ, align 8
  %call56 = call i32 @Perl_mg_set(%struct.sv* %67)
  br label %if.end.57

if.end.57:                                        ; preds = %if.then.55, %if.then.49
  %68 = load %struct.sv*, %struct.sv** %targ, align 8
  %69 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %68, %struct.sv** %69, align 8
  store %struct.sv* %68, %struct.sv** %tmp58
  %70 = load %struct.sv*, %struct.sv** %tmp58
  %71 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %71, %struct.sv*** @PL_stack_sp, align 8
  %72 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next59 = getelementptr inbounds %struct.op, %struct.op* %72, i32 0, i32 0
  %73 = load %struct.op*, %struct.op** %op_next59, align 8
  store %struct.op* %73, %struct.op** %retval
  br label %return

if.end.60:                                        ; preds = %if.else.46
  br label %if.end.61

if.end.61:                                        ; preds = %if.end.60
  br label %if.end.87

if.else.62:                                       ; preds = %oops_its_an_int
  %74 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any63 = getelementptr inbounds %struct.sv, %struct.sv* %74, i32 0, i32 0
  %75 = load i8*, i8** %sv_any63, align 8
  %76 = bitcast i8* %75 to %struct.xpviv*
  %xiv_iv64 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %76, i32 0, i32 3
  %77 = load i64, i64* %xiv_iv64, align 8
  %cmp65 = icmp ne i64 %77, -9223372036854775808
  br i1 %cmp65, label %if.then.66, label %if.else.78

if.then.66:                                       ; preds = %if.else.62
  %78 = load %struct.sv*, %struct.sv** %targ, align 8
  %79 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any67 = getelementptr inbounds %struct.sv, %struct.sv* %79, i32 0, i32 0
  %80 = load i8*, i8** %sv_any67, align 8
  %81 = bitcast i8* %80 to %struct.xpviv*
  %xiv_iv68 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %81, i32 0, i32 3
  %82 = load i64, i64* %xiv_iv68, align 8
  %sub69 = sub nsw i64 0, %82
  call void @Perl_sv_setiv(%struct.sv* %78, i64 %sub69)
  %83 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags70 = getelementptr inbounds %struct.sv, %struct.sv* %83, i32 0, i32 2
  %84 = load i32, i32* %sv_flags70, align 4
  %and71 = and i32 %84, 16384
  %tobool72 = icmp ne i32 %and71, 0
  br i1 %tobool72, label %if.then.73, label %if.end.75

if.then.73:                                       ; preds = %if.then.66
  %85 = load %struct.sv*, %struct.sv** %targ, align 8
  %call74 = call i32 @Perl_mg_set(%struct.sv* %85)
  br label %if.end.75

if.end.75:                                        ; preds = %if.then.73, %if.then.66
  %86 = load %struct.sv*, %struct.sv** %targ, align 8
  %87 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %86, %struct.sv** %87, align 8
  store %struct.sv* %86, %struct.sv** %tmp76
  %88 = load %struct.sv*, %struct.sv** %tmp76
  %89 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %89, %struct.sv*** @PL_stack_sp, align 8
  %90 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next77 = getelementptr inbounds %struct.op, %struct.op* %90, i32 0, i32 0
  %91 = load %struct.op*, %struct.op** %op_next77, align 8
  store %struct.op* %91, %struct.op** %retval
  br label %return

if.else.78:                                       ; preds = %if.else.62
  %92 = load %struct.sv*, %struct.sv** %targ, align 8
  call void @Perl_sv_setuv(%struct.sv* %92, i64 -9223372036854775808)
  %93 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags79 = getelementptr inbounds %struct.sv, %struct.sv* %93, i32 0, i32 2
  %94 = load i32, i32* %sv_flags79, align 4
  %and80 = and i32 %94, 16384
  %tobool81 = icmp ne i32 %and80, 0
  br i1 %tobool81, label %if.then.82, label %if.end.84

if.then.82:                                       ; preds = %if.else.78
  %95 = load %struct.sv*, %struct.sv** %targ, align 8
  %call83 = call i32 @Perl_mg_set(%struct.sv* %95)
  br label %if.end.84

if.end.84:                                        ; preds = %if.then.82, %if.else.78
  %96 = load %struct.sv*, %struct.sv** %targ, align 8
  %97 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %96, %struct.sv** %97, align 8
  store %struct.sv* %96, %struct.sv** %tmp85
  %98 = load %struct.sv*, %struct.sv** %tmp85
  %99 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %99, %struct.sv*** @PL_stack_sp, align 8
  %100 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next86 = getelementptr inbounds %struct.op, %struct.op* %100, i32 0, i32 0
  %101 = load %struct.op*, %struct.op** %op_next86, align 8
  store %struct.op* %101, %struct.op** %retval
  br label %return

if.end.87:                                        ; preds = %if.end.61
  br label %if.end.88

if.end.88:                                        ; preds = %if.end.87, %lor.lhs.false
  %102 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags89 = getelementptr inbounds %struct.sv, %struct.sv* %102, i32 0, i32 2
  %103 = load i32, i32* %sv_flags89, align 4
  %and90 = and i32 %103, 50331648
  %tobool91 = icmp ne i32 %and90, 0
  br i1 %tobool91, label %if.then.92, label %if.else.106

if.then.92:                                       ; preds = %if.end.88
  %104 = load %struct.sv*, %struct.sv** %targ, align 8
  %105 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags93 = getelementptr inbounds %struct.sv, %struct.sv* %105, i32 0, i32 2
  %106 = load i32, i32* %sv_flags93, align 4
  %and94 = and i32 %106, 131072
  %tobool95 = icmp ne i32 %and94, 0
  br i1 %tobool95, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.92
  %107 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any96 = getelementptr inbounds %struct.sv, %struct.sv* %107, i32 0, i32 0
  %108 = load i8*, i8** %sv_any96, align 8
  %109 = bitcast i8* %108 to %struct.xpvnv*
  %xnv_nv = getelementptr inbounds %struct.xpvnv, %struct.xpvnv* %109, i32 0, i32 4
  %110 = load double, double* %xnv_nv, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then.92
  %111 = load %struct.sv*, %struct.sv** %sv, align 8
  %call97 = call double @Perl_sv_2nv(%struct.sv* %111)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi double [ %110, %cond.true ], [ %call97, %cond.false ]
  %sub98 = fsub double -0.000000e+00, %cond
  call void @Perl_sv_setnv(%struct.sv* %104, double %sub98)
  %112 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags99 = getelementptr inbounds %struct.sv, %struct.sv* %112, i32 0, i32 2
  %113 = load i32, i32* %sv_flags99, align 4
  %and100 = and i32 %113, 16384
  %tobool101 = icmp ne i32 %and100, 0
  br i1 %tobool101, label %if.then.102, label %if.end.104

if.then.102:                                      ; preds = %cond.end
  %114 = load %struct.sv*, %struct.sv** %targ, align 8
  %call103 = call i32 @Perl_mg_set(%struct.sv* %114)
  br label %if.end.104

if.end.104:                                       ; preds = %if.then.102, %cond.end
  %115 = load %struct.sv*, %struct.sv** %targ, align 8
  %116 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %115, %struct.sv** %116, align 8
  store %struct.sv* %115, %struct.sv** %tmp105
  %117 = load %struct.sv*, %struct.sv** %tmp105
  br label %if.end.293

if.else.106:                                      ; preds = %if.end.88
  %118 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags107 = getelementptr inbounds %struct.sv, %struct.sv* %118, i32 0, i32 2
  %119 = load i32, i32* %sv_flags107, align 4
  %and108 = and i32 %119, 67108864
  %tobool109 = icmp ne i32 %and108, 0
  br i1 %tobool109, label %if.then.110, label %if.else.273

if.then.110:                                      ; preds = %if.else.106
  %120 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags113 = getelementptr inbounds %struct.sv, %struct.sv* %120, i32 0, i32 2
  %121 = load i32, i32* %sv_flags113, align 4
  %and114 = and i32 %121, 262144
  %cmp115 = icmp eq i32 %and114, 262144
  br i1 %cmp115, label %cond.true.116, label %cond.false.119

cond.true.116:                                    ; preds = %if.then.110
  %122 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any117 = getelementptr inbounds %struct.sv, %struct.sv* %122, i32 0, i32 0
  %123 = load i8*, i8** %sv_any117, align 8
  %124 = bitcast i8* %123 to %struct.xpv*
  %xpv_cur = getelementptr inbounds %struct.xpv, %struct.xpv* %124, i32 0, i32 1
  %125 = load i64, i64* %xpv_cur, align 8
  store i64 %125, i64* %len, align 8
  %126 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any118 = getelementptr inbounds %struct.sv, %struct.sv* %126, i32 0, i32 0
  %127 = load i8*, i8** %sv_any118, align 8
  %128 = bitcast i8* %127 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %128, i32 0, i32 0
  %129 = load i8*, i8** %xpv_pv, align 8
  br label %cond.end.121

cond.false.119:                                   ; preds = %if.then.110
  %130 = load %struct.sv*, %struct.sv** %sv, align 8
  %call120 = call i8* @Perl_sv_2pv_flags(%struct.sv* %130, i64* %len, i32 2)
  br label %cond.end.121

cond.end.121:                                     ; preds = %cond.false.119, %cond.true.116
  %cond122 = phi i8* [ %129, %cond.true.116 ], [ %call120, %cond.false.119 ]
  store i8* %cond122, i8** %s, align 8
  %131 = load i8*, i8** %s, align 8
  %132 = load i8, i8* %131, align 1
  %conv = sext i8 %132 to i32
  %cmp123 = icmp sge i32 %conv, 65
  br i1 %cmp123, label %land.lhs.true.125, label %lor.lhs.false.129

land.lhs.true.125:                                ; preds = %cond.end.121
  %133 = load i8*, i8** %s, align 8
  %134 = load i8, i8* %133, align 1
  %conv126 = sext i8 %134 to i32
  %cmp127 = icmp sle i32 %conv126, 90
  br i1 %cmp127, label %if.then.141, label %lor.lhs.false.129

lor.lhs.false.129:                                ; preds = %land.lhs.true.125, %cond.end.121
  %135 = load i8*, i8** %s, align 8
  %136 = load i8, i8* %135, align 1
  %conv130 = sext i8 %136 to i32
  %cmp131 = icmp sge i32 %conv130, 97
  br i1 %cmp131, label %land.lhs.true.133, label %lor.lhs.false.137

land.lhs.true.133:                                ; preds = %lor.lhs.false.129
  %137 = load i8*, i8** %s, align 8
  %138 = load i8, i8* %137, align 1
  %conv134 = sext i8 %138 to i32
  %cmp135 = icmp sle i32 %conv134, 122
  br i1 %cmp135, label %if.then.141, label %lor.lhs.false.137

lor.lhs.false.137:                                ; preds = %land.lhs.true.133, %lor.lhs.false.129
  %139 = load i8*, i8** %s, align 8
  %140 = load i8, i8* %139, align 1
  %conv138 = sext i8 %140 to i32
  %cmp139 = icmp eq i32 %conv138, 95
  br i1 %cmp139, label %if.then.141, label %if.else.142

if.then.141:                                      ; preds = %lor.lhs.false.137, %land.lhs.true.133, %land.lhs.true.125
  %141 = load %struct.sv*, %struct.sv** %targ, align 8
  call void @Perl_sv_setpvn(%struct.sv* %141, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.31, i32 0, i32 0), i64 1)
  %142 = load %struct.sv*, %struct.sv** %targ, align 8
  %143 = load %struct.sv*, %struct.sv** %sv, align 8
  call void @Perl_sv_catsv_flags(%struct.sv* %142, %struct.sv* %143, i32 2)
  br label %if.end.265

if.else.142:                                      ; preds = %lor.lhs.false.137
  %144 = load i8*, i8** %s, align 8
  %145 = load i8, i8* %144, align 1
  %conv143 = sext i8 %145 to i32
  %cmp144 = icmp eq i32 %conv143, 43
  br i1 %cmp144, label %if.then.150, label %lor.lhs.false.146

lor.lhs.false.146:                                ; preds = %if.else.142
  %146 = load i8*, i8** %s, align 8
  %147 = load i8, i8* %146, align 1
  %conv147 = sext i8 %147 to i32
  %cmp148 = icmp eq i32 %conv147, 45
  br i1 %cmp148, label %if.then.150, label %if.else.169

if.then.150:                                      ; preds = %lor.lhs.false.146, %if.else.142
  %148 = load %struct.sv*, %struct.sv** %targ, align 8
  %149 = load %struct.sv*, %struct.sv** %sv, align 8
  call void @Perl_sv_setsv_flags(%struct.sv* %148, %struct.sv* %149, i32 2)
  %150 = load i8*, i8** %s, align 8
  %151 = load i8, i8* %150, align 1
  %conv151 = sext i8 %151 to i32
  %cmp152 = icmp eq i32 %conv151, 45
  %cond154 = select i1 %cmp152, i32 43, i32 45
  %conv155 = trunc i32 %cond154 to i8
  %152 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags156 = getelementptr inbounds %struct.sv, %struct.sv* %152, i32 0, i32 2
  %153 = load i32, i32* %sv_flags156, align 4
  %and157 = and i32 %153, 10223616
  %cmp158 = icmp eq i32 %and157, 262144
  br i1 %cmp158, label %cond.true.160, label %cond.false.165

cond.true.160:                                    ; preds = %if.then.150
  %154 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any161 = getelementptr inbounds %struct.sv, %struct.sv* %154, i32 0, i32 0
  %155 = load i8*, i8** %sv_any161, align 8
  %156 = bitcast i8* %155 to %struct.xpv*
  %xpv_cur162 = getelementptr inbounds %struct.xpv, %struct.xpv* %156, i32 0, i32 1
  %157 = load i64, i64* %xpv_cur162, align 8
  store i64 %157, i64* %len, align 8
  %158 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any163 = getelementptr inbounds %struct.sv, %struct.sv* %158, i32 0, i32 0
  %159 = load i8*, i8** %sv_any163, align 8
  %160 = bitcast i8* %159 to %struct.xpv*
  %xpv_pv164 = getelementptr inbounds %struct.xpv, %struct.xpv* %160, i32 0, i32 0
  %161 = load i8*, i8** %xpv_pv164, align 8
  br label %cond.end.167

cond.false.165:                                   ; preds = %if.then.150
  %162 = load %struct.sv*, %struct.sv** %targ, align 8
  %call166 = call i8* @Perl_sv_pvn_force_flags(%struct.sv* %162, i64* %len, i32 2)
  br label %cond.end.167

cond.end.167:                                     ; preds = %cond.false.165, %cond.true.160
  %cond168 = phi i8* [ %161, %cond.true.160 ], [ %call166, %cond.false.165 ]
  store i8 %conv155, i8* %cond168, align 1
  br label %if.end.264

if.else.169:                                      ; preds = %lor.lhs.false.146
  %163 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags170 = getelementptr inbounds %struct.sv, %struct.sv* %163, i32 0, i32 2
  %164 = load i32, i32* %sv_flags170, align 4
  %and171 = and i32 %164, 536870912
  %tobool172 = icmp ne i32 %and171, 0
  br i1 %tobool172, label %land.lhs.true.173, label %if.else.223

land.lhs.true.173:                                ; preds = %if.else.169
  %165 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %op_private = getelementptr inbounds %struct.cop, %struct.cop* %165, i32 0, i32 7
  %166 = load i8, i8* %op_private, align 1
  %conv174 = zext i8 %166 to i32
  %and175 = and i32 %conv174, 8
  %tobool176 = icmp ne i32 %and175, 0
  br i1 %tobool176, label %if.else.223, label %if.then.177

if.then.177:                                      ; preds = %land.lhs.true.173
  %167 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags178 = getelementptr inbounds %struct.sv, %struct.sv* %167, i32 0, i32 2
  %168 = load i32, i32* %sv_flags178, align 4
  %and179 = and i32 %168, 16777216
  %tobool180 = icmp ne i32 %and179, 0
  br i1 %tobool180, label %if.end.200, label %land.lhs.true.181

land.lhs.true.181:                                ; preds = %if.then.177
  %169 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags182 = getelementptr inbounds %struct.sv, %struct.sv* %169, i32 0, i32 2
  %170 = load i32, i32* %sv_flags182, align 4
  %and183 = and i32 %170, 131072
  %tobool184 = icmp ne i32 %and183, 0
  br i1 %tobool184, label %if.then.189, label %lor.lhs.false.185

lor.lhs.false.185:                                ; preds = %land.lhs.true.181
  %171 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags186 = getelementptr inbounds %struct.sv, %struct.sv* %171, i32 0, i32 2
  %172 = load i32, i32* %sv_flags186, align 4
  %and187 = and i32 %172, 262144
  %tobool188 = icmp ne i32 %and187, 0
  br i1 %tobool188, label %if.then.189, label %if.end.200

if.then.189:                                      ; preds = %lor.lhs.false.185, %land.lhs.true.181
  %173 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags190 = getelementptr inbounds %struct.sv, %struct.sv* %173, i32 0, i32 2
  %174 = load i32, i32* %sv_flags190, align 4
  %and191 = and i32 %174, 65536
  %tobool192 = icmp ne i32 %and191, 0
  br i1 %tobool192, label %cond.true.193, label %cond.false.196

cond.true.193:                                    ; preds = %if.then.189
  %175 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any194 = getelementptr inbounds %struct.sv, %struct.sv* %175, i32 0, i32 0
  %176 = load i8*, i8** %sv_any194, align 8
  %177 = bitcast i8* %176 to %struct.xpviv*
  %xiv_iv195 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %177, i32 0, i32 3
  %178 = load i64, i64* %xiv_iv195, align 8
  br label %cond.end.198

cond.false.196:                                   ; preds = %if.then.189
  %179 = load %struct.sv*, %struct.sv** %sv, align 8
  %call197 = call i64 @Perl_sv_2iv(%struct.sv* %179)
  br label %cond.end.198

cond.end.198:                                     ; preds = %cond.false.196, %cond.true.193
  %cond199 = phi i64 [ %178, %cond.true.193 ], [ %call197, %cond.false.196 ]
  br label %if.end.200

if.end.200:                                       ; preds = %cond.end.198, %lor.lhs.false.185, %if.then.177
  %180 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags201 = getelementptr inbounds %struct.sv, %struct.sv* %180, i32 0, i32 2
  %181 = load i32, i32* %sv_flags201, align 4
  %and202 = and i32 %181, 65536
  %tobool203 = icmp ne i32 %and202, 0
  br i1 %tobool203, label %if.then.204, label %if.end.205

if.then.204:                                      ; preds = %if.end.200
  br label %oops_its_an_int

if.end.205:                                       ; preds = %if.end.200
  %182 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags206 = getelementptr inbounds %struct.sv, %struct.sv* %182, i32 0, i32 2
  %183 = load i32, i32* %sv_flags206, align 4
  %and207 = and i32 %183, 131072
  %tobool208 = icmp ne i32 %and207, 0
  br i1 %tobool208, label %if.then.209, label %if.else.221

if.then.209:                                      ; preds = %if.end.205
  %184 = load %struct.sv*, %struct.sv** %targ, align 8
  %185 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags210 = getelementptr inbounds %struct.sv, %struct.sv* %185, i32 0, i32 2
  %186 = load i32, i32* %sv_flags210, align 4
  %and211 = and i32 %186, 131072
  %tobool212 = icmp ne i32 %and211, 0
  br i1 %tobool212, label %cond.true.213, label %cond.false.216

cond.true.213:                                    ; preds = %if.then.209
  %187 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any214 = getelementptr inbounds %struct.sv, %struct.sv* %187, i32 0, i32 0
  %188 = load i8*, i8** %sv_any214, align 8
  %189 = bitcast i8* %188 to %struct.xpvnv*
  %xnv_nv215 = getelementptr inbounds %struct.xpvnv, %struct.xpvnv* %189, i32 0, i32 4
  %190 = load double, double* %xnv_nv215, align 8
  br label %cond.end.218

cond.false.216:                                   ; preds = %if.then.209
  %191 = load %struct.sv*, %struct.sv** %sv, align 8
  %call217 = call double @Perl_sv_2nv(%struct.sv* %191)
  br label %cond.end.218

cond.end.218:                                     ; preds = %cond.false.216, %cond.true.213
  %cond219 = phi double [ %190, %cond.true.213 ], [ %call217, %cond.false.216 ]
  %sub220 = fsub double -0.000000e+00, %cond219
  call void @Perl_sv_setnv(%struct.sv* %184, double %sub220)
  br label %if.end.222

if.else.221:                                      ; preds = %if.end.205
  %192 = load %struct.sv*, %struct.sv** %targ, align 8
  call void @Perl_sv_setpvn(%struct.sv* %192, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.31, i32 0, i32 0), i64 1)
  %193 = load %struct.sv*, %struct.sv** %targ, align 8
  %194 = load %struct.sv*, %struct.sv** %sv, align 8
  call void @Perl_sv_catsv_flags(%struct.sv* %193, %struct.sv* %194, i32 2)
  br label %if.end.222

if.end.222:                                       ; preds = %if.else.221, %cond.end.218
  br label %if.end.263

if.else.223:                                      ; preds = %land.lhs.true.173, %if.else.169
  %195 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags224 = getelementptr inbounds %struct.sv, %struct.sv* %195, i32 0, i32 2
  %196 = load i32, i32* %sv_flags224, align 4
  %and225 = and i32 %196, 16777216
  %tobool226 = icmp ne i32 %and225, 0
  br i1 %tobool226, label %if.end.246, label %land.lhs.true.227

land.lhs.true.227:                                ; preds = %if.else.223
  %197 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags228 = getelementptr inbounds %struct.sv, %struct.sv* %197, i32 0, i32 2
  %198 = load i32, i32* %sv_flags228, align 4
  %and229 = and i32 %198, 131072
  %tobool230 = icmp ne i32 %and229, 0
  br i1 %tobool230, label %if.then.235, label %lor.lhs.false.231

lor.lhs.false.231:                                ; preds = %land.lhs.true.227
  %199 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags232 = getelementptr inbounds %struct.sv, %struct.sv* %199, i32 0, i32 2
  %200 = load i32, i32* %sv_flags232, align 4
  %and233 = and i32 %200, 262144
  %tobool234 = icmp ne i32 %and233, 0
  br i1 %tobool234, label %if.then.235, label %if.end.246

if.then.235:                                      ; preds = %lor.lhs.false.231, %land.lhs.true.227
  %201 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags236 = getelementptr inbounds %struct.sv, %struct.sv* %201, i32 0, i32 2
  %202 = load i32, i32* %sv_flags236, align 4
  %and237 = and i32 %202, 65536
  %tobool238 = icmp ne i32 %and237, 0
  br i1 %tobool238, label %cond.true.239, label %cond.false.242

cond.true.239:                                    ; preds = %if.then.235
  %203 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any240 = getelementptr inbounds %struct.sv, %struct.sv* %203, i32 0, i32 0
  %204 = load i8*, i8** %sv_any240, align 8
  %205 = bitcast i8* %204 to %struct.xpviv*
  %xiv_iv241 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %205, i32 0, i32 3
  %206 = load i64, i64* %xiv_iv241, align 8
  br label %cond.end.244

cond.false.242:                                   ; preds = %if.then.235
  %207 = load %struct.sv*, %struct.sv** %sv, align 8
  %call243 = call i64 @Perl_sv_2iv(%struct.sv* %207)
  br label %cond.end.244

cond.end.244:                                     ; preds = %cond.false.242, %cond.true.239
  %cond245 = phi i64 [ %206, %cond.true.239 ], [ %call243, %cond.false.242 ]
  br label %if.end.246

if.end.246:                                       ; preds = %cond.end.244, %lor.lhs.false.231, %if.else.223
  %208 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags247 = getelementptr inbounds %struct.sv, %struct.sv* %208, i32 0, i32 2
  %209 = load i32, i32* %sv_flags247, align 4
  %and248 = and i32 %209, 65536
  %tobool249 = icmp ne i32 %and248, 0
  br i1 %tobool249, label %if.then.250, label %if.end.251

if.then.250:                                      ; preds = %if.end.246
  br label %oops_its_an_int

if.end.251:                                       ; preds = %if.end.246
  %210 = load %struct.sv*, %struct.sv** %targ, align 8
  %211 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags252 = getelementptr inbounds %struct.sv, %struct.sv* %211, i32 0, i32 2
  %212 = load i32, i32* %sv_flags252, align 4
  %and253 = and i32 %212, 131072
  %tobool254 = icmp ne i32 %and253, 0
  br i1 %tobool254, label %cond.true.255, label %cond.false.258

cond.true.255:                                    ; preds = %if.end.251
  %213 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any256 = getelementptr inbounds %struct.sv, %struct.sv* %213, i32 0, i32 0
  %214 = load i8*, i8** %sv_any256, align 8
  %215 = bitcast i8* %214 to %struct.xpvnv*
  %xnv_nv257 = getelementptr inbounds %struct.xpvnv, %struct.xpvnv* %215, i32 0, i32 4
  %216 = load double, double* %xnv_nv257, align 8
  br label %cond.end.260

cond.false.258:                                   ; preds = %if.end.251
  %217 = load %struct.sv*, %struct.sv** %sv, align 8
  %call259 = call double @Perl_sv_2nv(%struct.sv* %217)
  br label %cond.end.260

cond.end.260:                                     ; preds = %cond.false.258, %cond.true.255
  %cond261 = phi double [ %216, %cond.true.255 ], [ %call259, %cond.false.258 ]
  %sub262 = fsub double -0.000000e+00, %cond261
  call void @Perl_sv_setnv(%struct.sv* %210, double %sub262)
  br label %if.end.263

if.end.263:                                       ; preds = %cond.end.260, %if.end.222
  br label %if.end.264

if.end.264:                                       ; preds = %if.end.263, %cond.end.167
  br label %if.end.265

if.end.265:                                       ; preds = %if.end.264, %if.then.141
  %218 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags266 = getelementptr inbounds %struct.sv, %struct.sv* %218, i32 0, i32 2
  %219 = load i32, i32* %sv_flags266, align 4
  %and267 = and i32 %219, 16384
  %tobool268 = icmp ne i32 %and267, 0
  br i1 %tobool268, label %if.then.269, label %if.end.271

if.then.269:                                      ; preds = %if.end.265
  %220 = load %struct.sv*, %struct.sv** %targ, align 8
  %call270 = call i32 @Perl_mg_set(%struct.sv* %220)
  br label %if.end.271

if.end.271:                                       ; preds = %if.then.269, %if.end.265
  %221 = load %struct.sv*, %struct.sv** %targ, align 8
  %222 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %221, %struct.sv** %222, align 8
  store %struct.sv* %221, %struct.sv** %tmp272
  %223 = load %struct.sv*, %struct.sv** %tmp272
  br label %if.end.292

if.else.273:                                      ; preds = %if.else.106
  %224 = load %struct.sv*, %struct.sv** %targ, align 8
  %225 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags274 = getelementptr inbounds %struct.sv, %struct.sv* %225, i32 0, i32 2
  %226 = load i32, i32* %sv_flags274, align 4
  %and275 = and i32 %226, 131072
  %tobool276 = icmp ne i32 %and275, 0
  br i1 %tobool276, label %cond.true.277, label %cond.false.280

cond.true.277:                                    ; preds = %if.else.273
  %227 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any278 = getelementptr inbounds %struct.sv, %struct.sv* %227, i32 0, i32 0
  %228 = load i8*, i8** %sv_any278, align 8
  %229 = bitcast i8* %228 to %struct.xpvnv*
  %xnv_nv279 = getelementptr inbounds %struct.xpvnv, %struct.xpvnv* %229, i32 0, i32 4
  %230 = load double, double* %xnv_nv279, align 8
  br label %cond.end.282

cond.false.280:                                   ; preds = %if.else.273
  %231 = load %struct.sv*, %struct.sv** %sv, align 8
  %call281 = call double @Perl_sv_2nv(%struct.sv* %231)
  br label %cond.end.282

cond.end.282:                                     ; preds = %cond.false.280, %cond.true.277
  %cond283 = phi double [ %230, %cond.true.277 ], [ %call281, %cond.false.280 ]
  %sub284 = fsub double -0.000000e+00, %cond283
  call void @Perl_sv_setnv(%struct.sv* %224, double %sub284)
  %232 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags285 = getelementptr inbounds %struct.sv, %struct.sv* %232, i32 0, i32 2
  %233 = load i32, i32* %sv_flags285, align 4
  %and286 = and i32 %233, 16384
  %tobool287 = icmp ne i32 %and286, 0
  br i1 %tobool287, label %if.then.288, label %if.end.290

if.then.288:                                      ; preds = %cond.end.282
  %234 = load %struct.sv*, %struct.sv** %targ, align 8
  %call289 = call i32 @Perl_mg_set(%struct.sv* %234)
  br label %if.end.290

if.end.290:                                       ; preds = %if.then.288, %cond.end.282
  %235 = load %struct.sv*, %struct.sv** %targ, align 8
  %236 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %235, %struct.sv** %236, align 8
  store %struct.sv* %235, %struct.sv** %tmp291
  %237 = load %struct.sv*, %struct.sv** %tmp291
  br label %if.end.292

if.end.292:                                       ; preds = %if.end.290, %if.end.271
  br label %if.end.293

if.end.293:                                       ; preds = %if.end.292, %if.end.104
  %238 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %238, %struct.sv*** @PL_stack_sp, align 8
  %239 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next294 = getelementptr inbounds %struct.op, %struct.op* %239, i32 0, i32 0
  %240 = load %struct.op*, %struct.op** %op_next294, align 8
  store %struct.op* %240, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.293, %if.end.84, %if.end.75, %if.end.57, %if.end.43, %if.end.14
  %241 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %241
}

declare void @Perl_sv_catsv_flags(%struct.sv*, %struct.sv*, i32) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_not() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %arg = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load i64, i64* @PL_amagic_generation, align 8
  %tobool = icmp ne i64 %1, 0
  br i1 %tobool, label %if.then, label %if.end.4

if.then:                                          ; preds = %entry
  %2 = load %struct.sv**, %struct.sv*** %sp, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %2, i64 0
  %3 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %3, %struct.sv** %arg, align 8
  br label %am_again

am_again:                                         ; preds = %if.then
  %4 = load %struct.sv*, %struct.sv** %arg, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %4, i32 0, i32 2
  %5 = load i32, i32* %sv_flags, align 4
  %and = and i32 %5, 268435456
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %am_again
  %6 = load %struct.sv*, %struct.sv** %arg, align 8
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %6, %struct.sv* @PL_sv_undef, i32 42, i32 9)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool2 = icmp ne %struct.sv* %call, null
  br i1 %tobool2, label %if.then.3, label %if.end

if.then.3:                                        ; preds = %land.lhs.true
  %7 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %7, %struct.sv*** %sp, align 8
  %8 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %9 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %8, %struct.sv** %9, align 8
  %10 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %10, %struct.sv*** @PL_stack_sp, align 8
  %11 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %11, i32 0, i32 0
  %12 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %12, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %land.lhs.true, %am_again
  br label %if.end.4

if.end.4:                                         ; preds = %if.end, %entry
  %13 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  %14 = load %struct.sv*, %struct.sv** %13, align 8
  %tobool5 = icmp ne %struct.sv* %14, null
  br i1 %tobool5, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.end.4
  br label %cond.end.41

cond.false:                                       ; preds = %if.end.4
  %15 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  %16 = load %struct.sv*, %struct.sv** %15, align 8
  %sv_flags6 = getelementptr inbounds %struct.sv, %struct.sv* %16, i32 0, i32 2
  %17 = load i32, i32* %sv_flags6, align 4
  %and7 = and i32 %17, 262144
  %tobool8 = icmp ne i32 %and7, 0
  br i1 %tobool8, label %cond.true.9, label %cond.false.17

cond.true.9:                                      ; preds = %cond.false
  %18 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  %19 = load %struct.sv*, %struct.sv** %18, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %19, i32 0, i32 0
  %20 = load i8*, i8** %sv_any, align 8
  %21 = bitcast i8* %20 to %struct.xpv*
  store %struct.xpv* %21, %struct.xpv** @PL_Xpv, align 8
  %tobool10 = icmp ne %struct.xpv* %21, null
  br i1 %tobool10, label %land.rhs, label %land.end.16

land.rhs:                                         ; preds = %cond.true.9
  %22 = load %struct.xpv*, %struct.xpv** @PL_Xpv, align 8
  %xpv_cur = getelementptr inbounds %struct.xpv, %struct.xpv* %22, i32 0, i32 1
  %23 = load i64, i64* %xpv_cur, align 8
  %cmp = icmp ugt i64 %23, 1
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.rhs
  %24 = load %struct.xpv*, %struct.xpv** @PL_Xpv, align 8
  %xpv_cur11 = getelementptr inbounds %struct.xpv, %struct.xpv* %24, i32 0, i32 1
  %25 = load i64, i64* %xpv_cur11, align 8
  %tobool12 = icmp ne i64 %25, 0
  br i1 %tobool12, label %land.rhs.13, label %land.end

land.rhs.13:                                      ; preds = %lor.rhs
  %26 = load %struct.xpv*, %struct.xpv** @PL_Xpv, align 8
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %26, i32 0, i32 0
  %27 = load i8*, i8** %xpv_pv, align 8
  %28 = load i8, i8* %27, align 1
  %conv = sext i8 %28 to i32
  %cmp14 = icmp ne i32 %conv, 48
  br label %land.end

land.end:                                         ; preds = %land.rhs.13, %lor.rhs
  %29 = phi i1 [ false, %lor.rhs ], [ %cmp14, %land.rhs.13 ]
  br label %lor.end

lor.end:                                          ; preds = %land.end, %land.rhs
  %30 = phi i1 [ true, %land.rhs ], [ %29, %land.end ]
  br label %land.end.16

land.end.16:                                      ; preds = %lor.end, %cond.true.9
  %31 = phi i1 [ false, %cond.true.9 ], [ %30, %lor.end ]
  %cond = select i1 %31, i32 1, i32 0
  br label %cond.end.39

cond.false.17:                                    ; preds = %cond.false
  %32 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  %33 = load %struct.sv*, %struct.sv** %32, align 8
  %sv_flags18 = getelementptr inbounds %struct.sv, %struct.sv* %33, i32 0, i32 2
  %34 = load i32, i32* %sv_flags18, align 4
  %and19 = and i32 %34, 65536
  %tobool20 = icmp ne i32 %and19, 0
  br i1 %tobool20, label %cond.true.21, label %cond.false.25

cond.true.21:                                     ; preds = %cond.false.17
  %35 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  %36 = load %struct.sv*, %struct.sv** %35, align 8
  %sv_any22 = getelementptr inbounds %struct.sv, %struct.sv* %36, i32 0, i32 0
  %37 = load i8*, i8** %sv_any22, align 8
  %38 = bitcast i8* %37 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %38, i32 0, i32 3
  %39 = load i64, i64* %xiv_iv, align 8
  %cmp23 = icmp ne i64 %39, 0
  %conv24 = zext i1 %cmp23 to i32
  br label %cond.end.37

cond.false.25:                                    ; preds = %cond.false.17
  %40 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  %41 = load %struct.sv*, %struct.sv** %40, align 8
  %sv_flags26 = getelementptr inbounds %struct.sv, %struct.sv* %41, i32 0, i32 2
  %42 = load i32, i32* %sv_flags26, align 4
  %and27 = and i32 %42, 131072
  %tobool28 = icmp ne i32 %and27, 0
  br i1 %tobool28, label %cond.true.29, label %cond.false.33

cond.true.29:                                     ; preds = %cond.false.25
  %43 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  %44 = load %struct.sv*, %struct.sv** %43, align 8
  %sv_any30 = getelementptr inbounds %struct.sv, %struct.sv* %44, i32 0, i32 0
  %45 = load i8*, i8** %sv_any30, align 8
  %46 = bitcast i8* %45 to %struct.xpvnv*
  %xnv_nv = getelementptr inbounds %struct.xpvnv, %struct.xpvnv* %46, i32 0, i32 4
  %47 = load double, double* %xnv_nv, align 8
  %cmp31 = fcmp une double %47, 0.000000e+00
  %conv32 = zext i1 %cmp31 to i32
  br label %cond.end

cond.false.33:                                    ; preds = %cond.false.25
  %48 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  %49 = load %struct.sv*, %struct.sv** %48, align 8
  %call34 = call signext i8 @Perl_sv_2bool(%struct.sv* %49)
  %conv35 = sext i8 %call34 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false.33, %cond.true.29
  %cond36 = phi i32 [ %conv32, %cond.true.29 ], [ %conv35, %cond.false.33 ]
  br label %cond.end.37

cond.end.37:                                      ; preds = %cond.end, %cond.true.21
  %cond38 = phi i32 [ %conv24, %cond.true.21 ], [ %cond36, %cond.end ]
  br label %cond.end.39

cond.end.39:                                      ; preds = %cond.end.37, %land.end.16
  %cond40 = phi i32 [ %cond, %land.end.16 ], [ %cond38, %cond.end.37 ]
  br label %cond.end.41

cond.end.41:                                      ; preds = %cond.end.39, %cond.true
  %cond42 = phi i32 [ 0, %cond.true ], [ %cond40, %cond.end.39 ]
  %tobool43 = icmp ne i32 %cond42, 0
  %lnot = xor i1 %tobool43, true
  %cond44 = select i1 %lnot, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  %50 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv* %cond44, %struct.sv** %50, align 8
  %51 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next45 = getelementptr inbounds %struct.op, %struct.op* %51, i32 0, i32 0
  %52 = load %struct.op*, %struct.op** %op_next45, align 8
  store %struct.op* %52, %struct.op** %retval
  br label %return

return:                                           ; preds = %cond.end.41, %if.then.3
  %53 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %53
}

declare signext i8 @Perl_sv_2bool(%struct.sv*) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_complement() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %arg = alloca %struct.sv*, align 8
  %tmp = alloca %struct.sv*, align 8
  %sv = alloca %struct.sv*, align 8
  %i = alloca i64, align 8
  %tmp36 = alloca %struct.sv*, align 8
  %u = alloca i64, align 8
  %tmp55 = alloca %struct.sv*, align 8
  %tmps = alloca i8*, align 8
  %anum = alloca i32, align 4
  %len = alloca i64, align 8
  %targlen = alloca i64, align 8
  %result = alloca i8*, align 8
  %send = alloca i8*, align 8
  %l = alloca i64, align 8
  %nchar = alloca i64, align 8
  %nwide = alloca i64, align 8
  %c = alloca i64, align 8
  %c170 = alloca i64, align 8
  %c197 = alloca i8, align 1
  %tmpl = alloca i64*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 3
  %2 = load i64, i64* %op_targ, align 8
  %3 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 %2
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %4, %struct.sv** %targ, align 8
  %5 = load i64, i64* @PL_amagic_generation, align 8
  %tobool = icmp ne i64 %5, 0
  br i1 %tobool, label %if.then, label %if.end.16

if.then:                                          ; preds = %entry
  %6 = load %struct.sv**, %struct.sv*** %sp, align 8
  %arrayidx1 = getelementptr inbounds %struct.sv*, %struct.sv** %6, i64 0
  %7 = load %struct.sv*, %struct.sv** %arrayidx1, align 8
  store %struct.sv* %7, %struct.sv** %arg, align 8
  br label %am_again

am_again:                                         ; preds = %if.then
  %8 = load %struct.sv*, %struct.sv** %arg, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %8, i32 0, i32 2
  %9 = load i32, i32* %sv_flags, align 4
  %and = and i32 %9, 268435456
  %tobool2 = icmp ne i32 %and, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end.15

land.lhs.true:                                    ; preds = %am_again
  %10 = load %struct.sv*, %struct.sv** %arg, align 8
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %10, %struct.sv* @PL_sv_undef, i32 43, i32 9)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool3 = icmp ne %struct.sv* %call, null
  br i1 %tobool3, label %if.then.4, label %if.end.15

if.then.4:                                        ; preds = %land.lhs.true
  %11 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %11, %struct.sv*** %sp, align 8
  %12 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags5 = getelementptr inbounds %struct.sv, %struct.sv* %12, i32 0, i32 2
  %13 = load i32, i32* %sv_flags5, align 4
  %and6 = and i32 %13, 1024
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %if.then.8, label %if.else

if.then.8:                                        ; preds = %if.then.4
  %14 = load %struct.sv*, %struct.sv** %targ, align 8
  %15 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  call void @Perl_sv_setsv_flags(%struct.sv* %14, %struct.sv* %15, i32 2)
  %16 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags9 = getelementptr inbounds %struct.sv, %struct.sv* %16, i32 0, i32 2
  %17 = load i32, i32* %sv_flags9, align 4
  %and10 = and i32 %17, 16384
  %tobool11 = icmp ne i32 %and10, 0
  br i1 %tobool11, label %if.then.12, label %if.end

if.then.12:                                       ; preds = %if.then.8
  %18 = load %struct.sv*, %struct.sv** %targ, align 8
  %call13 = call i32 @Perl_mg_set(%struct.sv* %18)
  br label %if.end

if.end:                                           ; preds = %if.then.12, %if.then.8
  %19 = load %struct.sv*, %struct.sv** %targ, align 8
  %20 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %19, %struct.sv** %20, align 8
  store %struct.sv* %19, %struct.sv** %tmp
  %21 = load %struct.sv*, %struct.sv** %tmp
  br label %if.end.14

if.else:                                          ; preds = %if.then.4
  %22 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %23 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %22, %struct.sv** %23, align 8
  br label %if.end.14

if.end.14:                                        ; preds = %if.else, %if.end
  %24 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %24, %struct.sv*** @PL_stack_sp, align 8
  %25 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %25, i32 0, i32 0
  %26 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %26, %struct.op** %retval
  br label %return

if.end.15:                                        ; preds = %land.lhs.true, %am_again
  br label %if.end.16

if.end.16:                                        ; preds = %if.end.15, %entry
  %27 = load %struct.sv**, %struct.sv*** %sp, align 8
  %28 = load %struct.sv*, %struct.sv** %27, align 8
  store %struct.sv* %28, %struct.sv** %sv, align 8
  %29 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags18 = getelementptr inbounds %struct.sv, %struct.sv* %29, i32 0, i32 2
  %30 = load i32, i32* %sv_flags18, align 4
  %and19 = and i32 %30, 50331648
  %tobool20 = icmp ne i32 %and19, 0
  br i1 %tobool20, label %if.then.21, label %if.else.57

if.then.21:                                       ; preds = %if.end.16
  %31 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %31, i32 0, i32 7
  %32 = load i8, i8* %op_private, align 1
  %conv = zext i8 %32 to i32
  %and22 = and i32 %conv, 1
  %tobool23 = icmp ne i32 %and22, 0
  br i1 %tobool23, label %if.then.24, label %if.else.37

if.then.24:                                       ; preds = %if.then.21
  %33 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags26 = getelementptr inbounds %struct.sv, %struct.sv* %33, i32 0, i32 2
  %34 = load i32, i32* %sv_flags26, align 4
  %and27 = and i32 %34, 65536
  %tobool28 = icmp ne i32 %and27, 0
  br i1 %tobool28, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.24
  %35 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %35, i32 0, i32 0
  %36 = load i8*, i8** %sv_any, align 8
  %37 = bitcast i8* %36 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %37, i32 0, i32 3
  %38 = load i64, i64* %xiv_iv, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then.24
  %39 = load %struct.sv*, %struct.sv** %sv, align 8
  %call29 = call i64 @Perl_sv_2iv(%struct.sv* %39)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %38, %cond.true ], [ %call29, %cond.false ]
  %neg = xor i64 %cond, -1
  store i64 %neg, i64* %i, align 8
  %40 = load %struct.sv*, %struct.sv** %targ, align 8
  %41 = load i64, i64* %i, align 8
  call void @Perl_sv_setiv(%struct.sv* %40, i64 %41)
  %42 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags30 = getelementptr inbounds %struct.sv, %struct.sv* %42, i32 0, i32 2
  %43 = load i32, i32* %sv_flags30, align 4
  %and31 = and i32 %43, 16384
  %tobool32 = icmp ne i32 %and31, 0
  br i1 %tobool32, label %if.then.33, label %if.end.35

if.then.33:                                       ; preds = %cond.end
  %44 = load %struct.sv*, %struct.sv** %targ, align 8
  %call34 = call i32 @Perl_mg_set(%struct.sv* %44)
  br label %if.end.35

if.end.35:                                        ; preds = %if.then.33, %cond.end
  %45 = load %struct.sv*, %struct.sv** %targ, align 8
  %46 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %45, %struct.sv** %46, align 8
  store %struct.sv* %45, %struct.sv** %tmp36
  %47 = load %struct.sv*, %struct.sv** %tmp36
  br label %if.end.56

if.else.37:                                       ; preds = %if.then.21
  %48 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags39 = getelementptr inbounds %struct.sv, %struct.sv* %48, i32 0, i32 2
  %49 = load i32, i32* %sv_flags39, align 4
  %and40 = and i32 %49, 65536
  %tobool41 = icmp ne i32 %and40, 0
  br i1 %tobool41, label %cond.true.42, label %cond.false.44

cond.true.42:                                     ; preds = %if.else.37
  %50 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any43 = getelementptr inbounds %struct.sv, %struct.sv* %50, i32 0, i32 0
  %51 = load i8*, i8** %sv_any43, align 8
  %52 = bitcast i8* %51 to %struct.xpvuv*
  %xuv_uv = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %52, i32 0, i32 3
  %53 = load i64, i64* %xuv_uv, align 8
  br label %cond.end.46

cond.false.44:                                    ; preds = %if.else.37
  %54 = load %struct.sv*, %struct.sv** %sv, align 8
  %call45 = call i64 @Perl_sv_2uv(%struct.sv* %54)
  br label %cond.end.46

cond.end.46:                                      ; preds = %cond.false.44, %cond.true.42
  %cond47 = phi i64 [ %53, %cond.true.42 ], [ %call45, %cond.false.44 ]
  %neg48 = xor i64 %cond47, -1
  store i64 %neg48, i64* %u, align 8
  %55 = load %struct.sv*, %struct.sv** %targ, align 8
  %56 = load i64, i64* %u, align 8
  call void @Perl_sv_setuv(%struct.sv* %55, i64 %56)
  %57 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags49 = getelementptr inbounds %struct.sv, %struct.sv* %57, i32 0, i32 2
  %58 = load i32, i32* %sv_flags49, align 4
  %and50 = and i32 %58, 16384
  %tobool51 = icmp ne i32 %and50, 0
  br i1 %tobool51, label %if.then.52, label %if.end.54

if.then.52:                                       ; preds = %cond.end.46
  %59 = load %struct.sv*, %struct.sv** %targ, align 8
  %call53 = call i32 @Perl_mg_set(%struct.sv* %59)
  br label %if.end.54

if.end.54:                                        ; preds = %if.then.52, %cond.end.46
  %60 = load %struct.sv*, %struct.sv** %targ, align 8
  %61 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %60, %struct.sv** %61, align 8
  store %struct.sv* %60, %struct.sv** %tmp55
  %62 = load %struct.sv*, %struct.sv** %tmp55
  br label %if.end.56

if.end.56:                                        ; preds = %if.end.54, %if.end.35
  br label %if.end.245

if.else.57:                                       ; preds = %if.end.16
  %63 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags61 = getelementptr inbounds %struct.sv, %struct.sv* %63, i32 0, i32 2
  %64 = load i32, i32* %sv_flags61, align 4
  %and62 = and i32 %64, 262144
  %cmp = icmp eq i32 %and62, 262144
  br i1 %cmp, label %cond.true.64, label %cond.false.67

cond.true.64:                                     ; preds = %if.else.57
  %65 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any65 = getelementptr inbounds %struct.sv, %struct.sv* %65, i32 0, i32 0
  %66 = load i8*, i8** %sv_any65, align 8
  %67 = bitcast i8* %66 to %struct.xpv*
  %xpv_cur = getelementptr inbounds %struct.xpv, %struct.xpv* %67, i32 0, i32 1
  %68 = load i64, i64* %xpv_cur, align 8
  store i64 %68, i64* %len, align 8
  %69 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any66 = getelementptr inbounds %struct.sv, %struct.sv* %69, i32 0, i32 0
  %70 = load i8*, i8** %sv_any66, align 8
  %71 = bitcast i8* %70 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %71, i32 0, i32 0
  %72 = load i8*, i8** %xpv_pv, align 8
  br label %cond.end.69

cond.false.67:                                    ; preds = %if.else.57
  %73 = load %struct.sv*, %struct.sv** %sv, align 8
  %call68 = call i8* @Perl_sv_2pv_flags(%struct.sv* %73, i64* %len, i32 0)
  br label %cond.end.69

cond.end.69:                                      ; preds = %cond.false.67, %cond.true.64
  %cond70 = phi i8* [ %72, %cond.true.64 ], [ %call68, %cond.false.67 ]
  %74 = load %struct.sv*, %struct.sv** %targ, align 8
  %75 = load %struct.sv*, %struct.sv** %sv, align 8
  %cmp71 = icmp ne %struct.sv* %74, %75
  br i1 %cmp71, label %if.then.73, label %if.end.74

if.then.73:                                       ; preds = %cond.end.69
  %76 = load %struct.sv*, %struct.sv** %targ, align 8
  %77 = load %struct.sv*, %struct.sv** %sv, align 8
  call void @Perl_sv_setsv_flags(%struct.sv* %76, %struct.sv* %77, i32 2)
  br label %if.end.74

if.end.74:                                        ; preds = %if.then.73, %cond.end.69
  %78 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags75 = getelementptr inbounds %struct.sv, %struct.sv* %78, i32 0, i32 2
  %79 = load i32, i32* %sv_flags75, align 4
  %and76 = and i32 %79, 10223616
  %cmp77 = icmp eq i32 %and76, 262144
  br i1 %cmp77, label %cond.true.79, label %cond.false.84

cond.true.79:                                     ; preds = %if.end.74
  %80 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any80 = getelementptr inbounds %struct.sv, %struct.sv* %80, i32 0, i32 0
  %81 = load i8*, i8** %sv_any80, align 8
  %82 = bitcast i8* %81 to %struct.xpv*
  %xpv_cur81 = getelementptr inbounds %struct.xpv, %struct.xpv* %82, i32 0, i32 1
  %83 = load i64, i64* %xpv_cur81, align 8
  store i64 %83, i64* %len, align 8
  %84 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any82 = getelementptr inbounds %struct.sv, %struct.sv* %84, i32 0, i32 0
  %85 = load i8*, i8** %sv_any82, align 8
  %86 = bitcast i8* %85 to %struct.xpv*
  %xpv_pv83 = getelementptr inbounds %struct.xpv, %struct.xpv* %86, i32 0, i32 0
  %87 = load i8*, i8** %xpv_pv83, align 8
  br label %cond.end.86

cond.false.84:                                    ; preds = %if.end.74
  %88 = load %struct.sv*, %struct.sv** %targ, align 8
  %call85 = call i8* @Perl_sv_pvn_force_flags(%struct.sv* %88, i64* %len, i32 2)
  br label %cond.end.86

cond.end.86:                                      ; preds = %cond.false.84, %cond.true.79
  %cond87 = phi i8* [ %87, %cond.true.79 ], [ %call85, %cond.false.84 ]
  store i8* %cond87, i8** %tmps, align 8
  %89 = load i64, i64* %len, align 8
  %conv88 = trunc i64 %89 to i32
  store i32 %conv88, i32* %anum, align 4
  %90 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags89 = getelementptr inbounds %struct.sv, %struct.sv* %90, i32 0, i32 2
  %91 = load i32, i32* %sv_flags89, align 4
  %and90 = and i32 %91, 536870912
  %tobool91 = icmp ne i32 %and90, 0
  br i1 %tobool91, label %if.then.92, label %if.end.215

if.then.92:                                       ; preds = %cond.end.86
  store i64 0, i64* %targlen, align 8
  store i64 0, i64* %nchar, align 8
  store i64 0, i64* %nwide, align 8
  %92 = load i8*, i8** %tmps, align 8
  %93 = load i64, i64* %len, align 8
  %add.ptr = getelementptr inbounds i8, i8* %92, i64 %93
  store i8* %add.ptr, i8** %send, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end.157, %if.then.92
  %94 = load i8*, i8** %tmps, align 8
  %95 = load i8*, i8** %send, align 8
  %cmp99 = icmp ult i8* %94, %95
  br i1 %cmp99, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %96 = load i8*, i8** %tmps, align 8
  %97 = load i8*, i8** %send, align 8
  %98 = load i8*, i8** %tmps, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %97 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %98 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %call102 = call i64 @Perl_utf8n_to_uvuni(i8* %96, i64 %sub.ptr.sub, i64* %l, i32 105)
  store i64 %call102, i64* %c, align 8
  %99 = load i8*, i8** %tmps, align 8
  %100 = load i8, i8* %99, align 1
  %idxprom = zext i8 %100 to i64
  %arrayidx103 = getelementptr inbounds [0 x i8], [0 x i8]* @PL_utf8skip, i32 0, i64 %idxprom
  %101 = load i8, i8* %arrayidx103, align 1
  %conv104 = zext i8 %101 to i32
  %102 = load i8*, i8** %tmps, align 8
  %idx.ext = sext i32 %conv104 to i64
  %add.ptr105 = getelementptr inbounds i8, i8* %102, i64 %idx.ext
  store i8* %add.ptr105, i8** %tmps, align 8
  %103 = load i64, i64* %c, align 8
  %neg106 = xor i64 %103, -1
  %cmp107 = icmp ult i64 %neg106, 128
  br i1 %cmp107, label %cond.true.109, label %cond.false.110

cond.true.109:                                    ; preds = %while.body
  br label %cond.end.150

cond.false.110:                                   ; preds = %while.body
  %104 = load i64, i64* %c, align 8
  %neg111 = xor i64 %104, -1
  %cmp112 = icmp ult i64 %neg111, 2048
  br i1 %cmp112, label %cond.true.114, label %cond.false.115

cond.true.114:                                    ; preds = %cond.false.110
  br label %cond.end.148

cond.false.115:                                   ; preds = %cond.false.110
  %105 = load i64, i64* %c, align 8
  %neg116 = xor i64 %105, -1
  %cmp117 = icmp ult i64 %neg116, 65536
  br i1 %cmp117, label %cond.true.119, label %cond.false.120

cond.true.119:                                    ; preds = %cond.false.115
  br label %cond.end.146

cond.false.120:                                   ; preds = %cond.false.115
  %106 = load i64, i64* %c, align 8
  %neg121 = xor i64 %106, -1
  %cmp122 = icmp ult i64 %neg121, 2097152
  br i1 %cmp122, label %cond.true.124, label %cond.false.125

cond.true.124:                                    ; preds = %cond.false.120
  br label %cond.end.144

cond.false.125:                                   ; preds = %cond.false.120
  %107 = load i64, i64* %c, align 8
  %neg126 = xor i64 %107, -1
  %cmp127 = icmp ult i64 %neg126, 67108864
  br i1 %cmp127, label %cond.true.129, label %cond.false.130

cond.true.129:                                    ; preds = %cond.false.125
  br label %cond.end.142

cond.false.130:                                   ; preds = %cond.false.125
  %108 = load i64, i64* %c, align 8
  %neg131 = xor i64 %108, -1
  %cmp132 = icmp ult i64 %neg131, 2147483648
  br i1 %cmp132, label %cond.true.134, label %cond.false.135

cond.true.134:                                    ; preds = %cond.false.130
  br label %cond.end.140

cond.false.135:                                   ; preds = %cond.false.130
  %109 = load i64, i64* %c, align 8
  %neg136 = xor i64 %109, -1
  %cmp137 = icmp ult i64 %neg136, 68719476736
  %cond139 = select i1 %cmp137, i32 7, i32 13
  br label %cond.end.140

cond.end.140:                                     ; preds = %cond.false.135, %cond.true.134
  %cond141 = phi i32 [ 6, %cond.true.134 ], [ %cond139, %cond.false.135 ]
  br label %cond.end.142

cond.end.142:                                     ; preds = %cond.end.140, %cond.true.129
  %cond143 = phi i32 [ 5, %cond.true.129 ], [ %cond141, %cond.end.140 ]
  br label %cond.end.144

cond.end.144:                                     ; preds = %cond.end.142, %cond.true.124
  %cond145 = phi i32 [ 4, %cond.true.124 ], [ %cond143, %cond.end.142 ]
  br label %cond.end.146

cond.end.146:                                     ; preds = %cond.end.144, %cond.true.119
  %cond147 = phi i32 [ 3, %cond.true.119 ], [ %cond145, %cond.end.144 ]
  br label %cond.end.148

cond.end.148:                                     ; preds = %cond.end.146, %cond.true.114
  %cond149 = phi i32 [ 2, %cond.true.114 ], [ %cond147, %cond.end.146 ]
  br label %cond.end.150

cond.end.150:                                     ; preds = %cond.end.148, %cond.true.109
  %cond151 = phi i32 [ 1, %cond.true.109 ], [ %cond149, %cond.end.148 ]
  %conv152 = sext i32 %cond151 to i64
  %110 = load i64, i64* %targlen, align 8
  %add = add i64 %110, %conv152
  store i64 %add, i64* %targlen, align 8
  %111 = load i64, i64* %nchar, align 8
  %inc = add i64 %111, 1
  store i64 %inc, i64* %nchar, align 8
  %112 = load i64, i64* %c, align 8
  %cmp153 = icmp ugt i64 %112, 255
  br i1 %cmp153, label %if.then.155, label %if.end.157

if.then.155:                                      ; preds = %cond.end.150
  %113 = load i64, i64* %nwide, align 8
  %inc156 = add i64 %113, 1
  store i64 %inc156, i64* %nwide, align 8
  br label %if.end.157

if.end.157:                                       ; preds = %if.then.155, %cond.end.150
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %114 = load i64, i64* %len, align 8
  %115 = load i8*, i8** %tmps, align 8
  %idx.neg = sub i64 0, %114
  %add.ptr158 = getelementptr inbounds i8, i8* %115, i64 %idx.neg
  store i8* %add.ptr158, i8** %tmps, align 8
  %116 = load i64, i64* %nwide, align 8
  %tobool159 = icmp ne i64 %116, 0
  br i1 %tobool159, label %if.then.160, label %if.else.186

if.then.160:                                      ; preds = %while.end
  %117 = load i64, i64* %targlen, align 8
  %add161 = add i64 %117, 1
  %mul = mul i64 %add161, 1
  %call162 = call i8* @Perl_safesysmalloc(i64 %mul)
  store i8* %call162, i8** %result, align 8
  %118 = load i8*, i8** %result, align 8
  %119 = load i64, i64* %targlen, align 8
  %add163 = add i64 %119, 1
  %mul164 = mul i64 %add163, 1
  call void @llvm.memset.p0i8.i64(i8* %118, i8 0, i64 %mul164, i32 1, i1 false)
  br label %while.cond.165

while.cond.165:                                   ; preds = %while.body.168, %if.then.160
  %120 = load i8*, i8** %tmps, align 8
  %121 = load i8*, i8** %send, align 8
  %cmp166 = icmp ult i8* %120, %121
  br i1 %cmp166, label %while.body.168, label %while.end.182

while.body.168:                                   ; preds = %while.cond.165
  %122 = load i8*, i8** %tmps, align 8
  %123 = load i8*, i8** %send, align 8
  %124 = load i8*, i8** %tmps, align 8
  %sub.ptr.lhs.cast171 = ptrtoint i8* %123 to i64
  %sub.ptr.rhs.cast172 = ptrtoint i8* %124 to i64
  %sub.ptr.sub173 = sub i64 %sub.ptr.lhs.cast171, %sub.ptr.rhs.cast172
  %call174 = call i64 @Perl_utf8n_to_uvuni(i8* %122, i64 %sub.ptr.sub173, i64* %l, i32 105)
  store i64 %call174, i64* %c170, align 8
  %125 = load i8*, i8** %tmps, align 8
  %126 = load i8, i8* %125, align 1
  %idxprom175 = zext i8 %126 to i64
  %arrayidx176 = getelementptr inbounds [0 x i8], [0 x i8]* @PL_utf8skip, i32 0, i64 %idxprom175
  %127 = load i8, i8* %arrayidx176, align 1
  %conv177 = zext i8 %127 to i32
  %128 = load i8*, i8** %tmps, align 8
  %idx.ext178 = sext i32 %conv177 to i64
  %add.ptr179 = getelementptr inbounds i8, i8* %128, i64 %idx.ext178
  store i8* %add.ptr179, i8** %tmps, align 8
  %129 = load i8*, i8** %result, align 8
  %130 = load i64, i64* %c170, align 8
  %neg180 = xor i64 %130, -1
  %call181 = call i8* @Perl_uvchr_to_utf8_flags(i8* %129, i64 %neg180, i64 15)
  store i8* %call181, i8** %result, align 8
  br label %while.cond.165

while.end.182:                                    ; preds = %while.cond.165
  %131 = load i8*, i8** %result, align 8
  store i8 0, i8* %131, align 1
  %132 = load i64, i64* %targlen, align 8
  %133 = load i8*, i8** %result, align 8
  %idx.neg183 = sub i64 0, %132
  %add.ptr184 = getelementptr inbounds i8, i8* %133, i64 %idx.neg183
  store i8* %add.ptr184, i8** %result, align 8
  %134 = load %struct.sv*, %struct.sv** %targ, align 8
  %135 = load i8*, i8** %result, align 8
  %136 = load i64, i64* %targlen, align 8
  call void @Perl_sv_setpvn(%struct.sv* %134, i8* %135, i64 %136)
  %137 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags185 = getelementptr inbounds %struct.sv, %struct.sv* %137, i32 0, i32 2
  %138 = load i32, i32* %sv_flags185, align 4
  %or = or i32 %138, 536870912
  store i32 %or, i32* %sv_flags185, align 4
  br label %if.end.213

if.else.186:                                      ; preds = %while.end
  %139 = load i64, i64* %nchar, align 8
  %add187 = add i64 %139, 1
  %mul188 = mul i64 %add187, 1
  %call189 = call i8* @Perl_safesysmalloc(i64 %mul188)
  store i8* %call189, i8** %result, align 8
  %140 = load i8*, i8** %result, align 8
  %141 = load i64, i64* %nchar, align 8
  %add190 = add i64 %141, 1
  %mul191 = mul i64 %add190, 1
  call void @llvm.memset.p0i8.i64(i8* %140, i8 0, i64 %mul191, i32 1, i1 false)
  br label %while.cond.192

while.cond.192:                                   ; preds = %while.body.195, %if.else.186
  %142 = load i8*, i8** %tmps, align 8
  %143 = load i8*, i8** %send, align 8
  %cmp193 = icmp ult i8* %142, %143
  br i1 %cmp193, label %while.body.195, label %while.end.208

while.body.195:                                   ; preds = %while.cond.192
  %144 = load i8*, i8** %tmps, align 8
  %call198 = call i64 @Perl_utf8n_to_uvuni(i8* %144, i64 0, i64* %l, i32 255)
  %conv199 = trunc i64 %call198 to i8
  store i8 %conv199, i8* %c197, align 1
  %145 = load i8*, i8** %tmps, align 8
  %146 = load i8, i8* %145, align 1
  %idxprom200 = zext i8 %146 to i64
  %arrayidx201 = getelementptr inbounds [0 x i8], [0 x i8]* @PL_utf8skip, i32 0, i64 %idxprom200
  %147 = load i8, i8* %arrayidx201, align 1
  %conv202 = zext i8 %147 to i32
  %148 = load i8*, i8** %tmps, align 8
  %idx.ext203 = sext i32 %conv202 to i64
  %add.ptr204 = getelementptr inbounds i8, i8* %148, i64 %idx.ext203
  store i8* %add.ptr204, i8** %tmps, align 8
  %149 = load i8, i8* %c197, align 1
  %conv205 = zext i8 %149 to i32
  %neg206 = xor i32 %conv205, -1
  %conv207 = trunc i32 %neg206 to i8
  %150 = load i8*, i8** %result, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %150, i32 1
  store i8* %incdec.ptr, i8** %result, align 8
  store i8 %conv207, i8* %150, align 1
  br label %while.cond.192

while.end.208:                                    ; preds = %while.cond.192
  %151 = load i8*, i8** %result, align 8
  store i8 0, i8* %151, align 1
  %152 = load i64, i64* %nchar, align 8
  %153 = load i8*, i8** %result, align 8
  %idx.neg209 = sub i64 0, %152
  %add.ptr210 = getelementptr inbounds i8, i8* %153, i64 %idx.neg209
  store i8* %add.ptr210, i8** %result, align 8
  %154 = load %struct.sv*, %struct.sv** %targ, align 8
  %155 = load i8*, i8** %result, align 8
  %156 = load i64, i64* %nchar, align 8
  call void @Perl_sv_setpvn(%struct.sv* %154, i8* %155, i64 %156)
  %157 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags211 = getelementptr inbounds %struct.sv, %struct.sv* %157, i32 0, i32 2
  %158 = load i32, i32* %sv_flags211, align 4
  %and212 = and i32 %158, -536870913
  store i32 %and212, i32* %sv_flags211, align 4
  br label %if.end.213

if.end.213:                                       ; preds = %while.end.208, %while.end.182
  %159 = load i8*, i8** %result, align 8
  call void @Perl_safesysfree(i8* %159)
  %160 = load %struct.sv*, %struct.sv** %targ, align 8
  %161 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %160, %struct.sv** %161, align 8
  %162 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %162, %struct.sv*** @PL_stack_sp, align 8
  %163 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next214 = getelementptr inbounds %struct.op, %struct.op* %163, i32 0, i32 0
  %164 = load %struct.op*, %struct.op** %op_next214, align 8
  store %struct.op* %164, %struct.op** %retval
  br label %return

if.end.215:                                       ; preds = %cond.end.86
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end.215
  %165 = load i32, i32* %anum, align 4
  %tobool217 = icmp ne i32 %165, 0
  br i1 %tobool217, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %166 = load i8*, i8** %tmps, align 8
  %167 = ptrtoint i8* %166 to i64
  %rem = urem i64 %167, 8
  %tobool218 = icmp ne i64 %rem, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %168 = phi i1 [ false, %for.cond ], [ %tobool218, %land.rhs ]
  br i1 %168, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %169 = load i8*, i8** %tmps, align 8
  %170 = load i8, i8* %169, align 1
  %conv219 = zext i8 %170 to i32
  %neg220 = xor i32 %conv219, -1
  %conv221 = trunc i32 %neg220 to i8
  %171 = load i8*, i8** %tmps, align 8
  store i8 %conv221, i8* %171, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %172 = load i32, i32* %anum, align 4
  %dec = add nsw i32 %172, -1
  store i32 %dec, i32* %anum, align 4
  %173 = load i8*, i8** %tmps, align 8
  %incdec.ptr222 = getelementptr inbounds i8, i8* %173, i32 1
  store i8* %incdec.ptr222, i8** %tmps, align 8
  br label %for.cond

for.end:                                          ; preds = %land.end
  %174 = load i8*, i8** %tmps, align 8
  %175 = bitcast i8* %174 to i64*
  store i64* %175, i64** %tmpl, align 8
  br label %for.cond.223

for.cond.223:                                     ; preds = %for.inc.229, %for.end
  %176 = load i32, i32* %anum, align 4
  %conv224 = sext i32 %176 to i64
  %cmp225 = icmp uge i64 %conv224, 8
  br i1 %cmp225, label %for.body.227, label %for.end.233

for.body.227:                                     ; preds = %for.cond.223
  %177 = load i64*, i64** %tmpl, align 8
  %178 = load i64, i64* %177, align 8
  %neg228 = xor i64 %178, -1
  %179 = load i64*, i64** %tmpl, align 8
  store i64 %neg228, i64* %179, align 8
  br label %for.inc.229

for.inc.229:                                      ; preds = %for.body.227
  %180 = load i32, i32* %anum, align 4
  %conv230 = sext i32 %180 to i64
  %sub = sub i64 %conv230, 8
  %conv231 = trunc i64 %sub to i32
  store i32 %conv231, i32* %anum, align 4
  %181 = load i64*, i64** %tmpl, align 8
  %incdec.ptr232 = getelementptr inbounds i64, i64* %181, i32 1
  store i64* %incdec.ptr232, i64** %tmpl, align 8
  br label %for.cond.223

for.end.233:                                      ; preds = %for.cond.223
  %182 = load i64*, i64** %tmpl, align 8
  %183 = bitcast i64* %182 to i8*
  store i8* %183, i8** %tmps, align 8
  br label %for.cond.234

for.cond.234:                                     ; preds = %for.inc.241, %for.end.233
  %184 = load i32, i32* %anum, align 4
  %cmp235 = icmp sgt i32 %184, 0
  br i1 %cmp235, label %for.body.237, label %for.end.244

for.body.237:                                     ; preds = %for.cond.234
  %185 = load i8*, i8** %tmps, align 8
  %186 = load i8, i8* %185, align 1
  %conv238 = zext i8 %186 to i32
  %neg239 = xor i32 %conv238, -1
  %conv240 = trunc i32 %neg239 to i8
  %187 = load i8*, i8** %tmps, align 8
  store i8 %conv240, i8* %187, align 1
  br label %for.inc.241

for.inc.241:                                      ; preds = %for.body.237
  %188 = load i32, i32* %anum, align 4
  %dec242 = add nsw i32 %188, -1
  store i32 %dec242, i32* %anum, align 4
  %189 = load i8*, i8** %tmps, align 8
  %incdec.ptr243 = getelementptr inbounds i8, i8* %189, i32 1
  store i8* %incdec.ptr243, i8** %tmps, align 8
  br label %for.cond.234

for.end.244:                                      ; preds = %for.cond.234
  %190 = load %struct.sv*, %struct.sv** %targ, align 8
  %191 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %190, %struct.sv** %191, align 8
  br label %if.end.245

if.end.245:                                       ; preds = %for.end.244, %if.end.56
  %192 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %192, %struct.sv*** @PL_stack_sp, align 8
  %193 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next246 = getelementptr inbounds %struct.op, %struct.op* %193, i32 0, i32 0
  %194 = load %struct.op*, %struct.op** %op_next246, align 8
  store %struct.op* %194, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.245, %if.end.213, %if.end.14
  %195 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %195
}

declare i64 @Perl_utf8n_to_uvuni(i8*, i64, i64*, i32) #1

declare i8* @Perl_uvchr_to_utf8_flags(i8*, i64, i64) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_i_multiply() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %right = alloca %struct.sv*, align 8
  %left = alloca %struct.sv*, align 8
  %tmp = alloca %struct.sv*, align 8
  %right33 = alloca i64, align 8
  %left44 = alloca i64, align 8
  %tmp61 = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 6
  %2 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 64
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load %struct.sv**, %struct.sv*** %sp, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 -1
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %5 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %5, i32 0, i32 3
  %6 = load i64, i64* %op_targ, align 8
  %7 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx1 = getelementptr inbounds %struct.sv*, %struct.sv** %7, i64 %6
  %8 = load %struct.sv*, %struct.sv** %arrayidx1, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.sv* [ %4, %cond.true ], [ %8, %cond.false ]
  store %struct.sv* %cond, %struct.sv** %targ, align 8
  %9 = load i64, i64* @PL_amagic_generation, align 8
  %tobool2 = icmp ne i64 %9, 0
  br i1 %tobool2, label %if.then, label %if.end.31

if.then:                                          ; preds = %cond.end
  %10 = load %struct.sv**, %struct.sv*** %sp, align 8
  %11 = load %struct.sv*, %struct.sv** %10, align 8
  store %struct.sv* %11, %struct.sv** %right, align 8
  %12 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %12, i64 -1
  %13 = load %struct.sv*, %struct.sv** %add.ptr, align 8
  store %struct.sv* %13, %struct.sv** %left, align 8
  %14 = load %struct.sv*, %struct.sv** %left, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %14, i32 0, i32 2
  %15 = load i32, i32* %sv_flags, align 4
  %and3 = and i32 %15, 268435456
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %16 = load %struct.sv*, %struct.sv** %right, align 8
  %sv_flags5 = getelementptr inbounds %struct.sv, %struct.sv* %16, i32 0, i32 2
  %17 = load i32, i32* %sv_flags5, align 4
  %and6 = and i32 %17, 268435456
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %land.lhs.true, label %if.end.30

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %18 = load %struct.sv*, %struct.sv** %left, align 8
  %19 = load %struct.sv*, %struct.sv** %right, align 8
  %20 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags8 = getelementptr inbounds %struct.op, %struct.op* %20, i32 0, i32 6
  %21 = load i8, i8* %op_flags8, align 1
  %conv9 = zext i8 %21 to i32
  %and10 = and i32 %conv9, 64
  %tobool11 = icmp ne i32 %and10, 0
  %cond12 = select i1 %tobool11, i32 4, i32 0
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %18, %struct.sv* %19, i32 10, i32 %cond12)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool13 = icmp ne %struct.sv* %call, null
  br i1 %tobool13, label %if.then.14, label %if.end.30

if.then.14:                                       ; preds = %land.lhs.true
  %22 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %22, %struct.sv*** %sp, align 8
  %23 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %23, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %24 = load %struct.sv*, %struct.sv** %23, align 8
  %25 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags15 = getelementptr inbounds %struct.op, %struct.op* %25, i32 0, i32 6
  %26 = load i8, i8* %op_flags15, align 1
  %conv16 = zext i8 %26 to i32
  %and17 = and i32 %conv16, 64
  %tobool18 = icmp ne i32 %and17, 0
  br i1 %tobool18, label %if.then.23, label %lor.lhs.false.19

lor.lhs.false.19:                                 ; preds = %if.then.14
  %27 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags20 = getelementptr inbounds %struct.sv, %struct.sv* %27, i32 0, i32 2
  %28 = load i32, i32* %sv_flags20, align 4
  %and21 = and i32 %28, 1024
  %tobool22 = icmp ne i32 %and21, 0
  br i1 %tobool22, label %if.then.23, label %if.else

if.then.23:                                       ; preds = %lor.lhs.false.19, %if.then.14
  %29 = load %struct.sv*, %struct.sv** %targ, align 8
  %30 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  call void @Perl_sv_setsv_flags(%struct.sv* %29, %struct.sv* %30, i32 2)
  %31 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags24 = getelementptr inbounds %struct.sv, %struct.sv* %31, i32 0, i32 2
  %32 = load i32, i32* %sv_flags24, align 4
  %and25 = and i32 %32, 16384
  %tobool26 = icmp ne i32 %and25, 0
  br i1 %tobool26, label %if.then.27, label %if.end

if.then.27:                                       ; preds = %if.then.23
  %33 = load %struct.sv*, %struct.sv** %targ, align 8
  %call28 = call i32 @Perl_mg_set(%struct.sv* %33)
  br label %if.end

if.end:                                           ; preds = %if.then.27, %if.then.23
  %34 = load %struct.sv*, %struct.sv** %targ, align 8
  %35 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %34, %struct.sv** %35, align 8
  store %struct.sv* %34, %struct.sv** %tmp
  %36 = load %struct.sv*, %struct.sv** %tmp
  br label %if.end.29

if.else:                                          ; preds = %lor.lhs.false.19
  %37 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %38 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %37, %struct.sv** %38, align 8
  br label %if.end.29

if.end.29:                                        ; preds = %if.else, %if.end
  %39 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %39, %struct.sv*** @PL_stack_sp, align 8
  %40 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %40, i32 0, i32 0
  %41 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %41, %struct.op** %retval
  br label %return

if.end.30:                                        ; preds = %land.lhs.true, %lor.lhs.false
  br label %if.end.31

if.end.31:                                        ; preds = %if.end.30, %cond.end
  %42 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr34 = getelementptr inbounds %struct.sv*, %struct.sv** %42, i32 -1
  store %struct.sv** %incdec.ptr34, %struct.sv*** %sp, align 8
  %43 = load %struct.sv*, %struct.sv** %42, align 8
  store %struct.sv* %43, %struct.sv** @PL_Sv, align 8
  %44 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags35 = getelementptr inbounds %struct.sv, %struct.sv* %44, i32 0, i32 2
  %45 = load i32, i32* %sv_flags35, align 4
  %and36 = and i32 %45, 65536
  %tobool37 = icmp ne i32 %and36, 0
  br i1 %tobool37, label %cond.true.38, label %cond.false.39

cond.true.38:                                     ; preds = %if.end.31
  %46 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %46, i32 0, i32 0
  %47 = load i8*, i8** %sv_any, align 8
  %48 = bitcast i8* %47 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %48, i32 0, i32 3
  %49 = load i64, i64* %xiv_iv, align 8
  br label %cond.end.41

cond.false.39:                                    ; preds = %if.end.31
  %50 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call40 = call i64 @Perl_sv_2iv(%struct.sv* %50)
  br label %cond.end.41

cond.end.41:                                      ; preds = %cond.false.39, %cond.true.38
  %cond42 = phi i64 [ %49, %cond.true.38 ], [ %call40, %cond.false.39 ]
  store i64 %cond42, i64* %right33, align 8
  %51 = load %struct.sv**, %struct.sv*** %sp, align 8
  %52 = load %struct.sv*, %struct.sv** %51, align 8
  %sv_flags45 = getelementptr inbounds %struct.sv, %struct.sv* %52, i32 0, i32 2
  %53 = load i32, i32* %sv_flags45, align 4
  %and46 = and i32 %53, 65536
  %tobool47 = icmp ne i32 %and46, 0
  br i1 %tobool47, label %cond.true.48, label %cond.false.51

cond.true.48:                                     ; preds = %cond.end.41
  %54 = load %struct.sv**, %struct.sv*** %sp, align 8
  %55 = load %struct.sv*, %struct.sv** %54, align 8
  %sv_any49 = getelementptr inbounds %struct.sv, %struct.sv* %55, i32 0, i32 0
  %56 = load i8*, i8** %sv_any49, align 8
  %57 = bitcast i8* %56 to %struct.xpviv*
  %xiv_iv50 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %57, i32 0, i32 3
  %58 = load i64, i64* %xiv_iv50, align 8
  br label %cond.end.53

cond.false.51:                                    ; preds = %cond.end.41
  %59 = load %struct.sv**, %struct.sv*** %sp, align 8
  %60 = load %struct.sv*, %struct.sv** %59, align 8
  %call52 = call i64 @Perl_sv_2iv(%struct.sv* %60)
  br label %cond.end.53

cond.end.53:                                      ; preds = %cond.false.51, %cond.true.48
  %cond54 = phi i64 [ %58, %cond.true.48 ], [ %call52, %cond.false.51 ]
  store i64 %cond54, i64* %left44, align 8
  %61 = load %struct.sv*, %struct.sv** %targ, align 8
  %62 = load i64, i64* %left44, align 8
  %63 = load i64, i64* %right33, align 8
  %mul = mul nsw i64 %62, %63
  call void @Perl_sv_setiv(%struct.sv* %61, i64 %mul)
  %64 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags55 = getelementptr inbounds %struct.sv, %struct.sv* %64, i32 0, i32 2
  %65 = load i32, i32* %sv_flags55, align 4
  %and56 = and i32 %65, 16384
  %tobool57 = icmp ne i32 %and56, 0
  br i1 %tobool57, label %if.then.58, label %if.end.60

if.then.58:                                       ; preds = %cond.end.53
  %66 = load %struct.sv*, %struct.sv** %targ, align 8
  %call59 = call i32 @Perl_mg_set(%struct.sv* %66)
  br label %if.end.60

if.end.60:                                        ; preds = %if.then.58, %cond.end.53
  %67 = load %struct.sv*, %struct.sv** %targ, align 8
  %68 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %67, %struct.sv** %68, align 8
  store %struct.sv* %67, %struct.sv** %tmp61
  %69 = load %struct.sv*, %struct.sv** %tmp61
  %70 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %70, %struct.sv*** @PL_stack_sp, align 8
  %71 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next62 = getelementptr inbounds %struct.op, %struct.op* %71, i32 0, i32 0
  %72 = load %struct.op*, %struct.op** %op_next62, align 8
  store %struct.op* %72, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.60, %if.end.29
  %73 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %73
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_i_divide() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %right = alloca %struct.sv*, align 8
  %left = alloca %struct.sv*, align 8
  %tmp = alloca %struct.sv*, align 8
  %value = alloca i64, align 8
  %tmp63 = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 6
  %2 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 64
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load %struct.sv**, %struct.sv*** %sp, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 -1
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %5 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %5, i32 0, i32 3
  %6 = load i64, i64* %op_targ, align 8
  %7 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx1 = getelementptr inbounds %struct.sv*, %struct.sv** %7, i64 %6
  %8 = load %struct.sv*, %struct.sv** %arrayidx1, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.sv* [ %4, %cond.true ], [ %8, %cond.false ]
  store %struct.sv* %cond, %struct.sv** %targ, align 8
  %9 = load i64, i64* @PL_amagic_generation, align 8
  %tobool2 = icmp ne i64 %9, 0
  br i1 %tobool2, label %if.then, label %if.end.31

if.then:                                          ; preds = %cond.end
  %10 = load %struct.sv**, %struct.sv*** %sp, align 8
  %11 = load %struct.sv*, %struct.sv** %10, align 8
  store %struct.sv* %11, %struct.sv** %right, align 8
  %12 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %12, i64 -1
  %13 = load %struct.sv*, %struct.sv** %add.ptr, align 8
  store %struct.sv* %13, %struct.sv** %left, align 8
  %14 = load %struct.sv*, %struct.sv** %left, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %14, i32 0, i32 2
  %15 = load i32, i32* %sv_flags, align 4
  %and3 = and i32 %15, 268435456
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %16 = load %struct.sv*, %struct.sv** %right, align 8
  %sv_flags5 = getelementptr inbounds %struct.sv, %struct.sv* %16, i32 0, i32 2
  %17 = load i32, i32* %sv_flags5, align 4
  %and6 = and i32 %17, 268435456
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %land.lhs.true, label %if.end.30

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %18 = load %struct.sv*, %struct.sv** %left, align 8
  %19 = load %struct.sv*, %struct.sv** %right, align 8
  %20 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags8 = getelementptr inbounds %struct.op, %struct.op* %20, i32 0, i32 6
  %21 = load i8, i8* %op_flags8, align 1
  %conv9 = zext i8 %21 to i32
  %and10 = and i32 %conv9, 64
  %tobool11 = icmp ne i32 %and10, 0
  %cond12 = select i1 %tobool11, i32 4, i32 0
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %18, %struct.sv* %19, i32 12, i32 %cond12)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool13 = icmp ne %struct.sv* %call, null
  br i1 %tobool13, label %if.then.14, label %if.end.30

if.then.14:                                       ; preds = %land.lhs.true
  %22 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %22, %struct.sv*** %sp, align 8
  %23 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %23, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %24 = load %struct.sv*, %struct.sv** %23, align 8
  %25 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags15 = getelementptr inbounds %struct.op, %struct.op* %25, i32 0, i32 6
  %26 = load i8, i8* %op_flags15, align 1
  %conv16 = zext i8 %26 to i32
  %and17 = and i32 %conv16, 64
  %tobool18 = icmp ne i32 %and17, 0
  br i1 %tobool18, label %if.then.23, label %lor.lhs.false.19

lor.lhs.false.19:                                 ; preds = %if.then.14
  %27 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags20 = getelementptr inbounds %struct.sv, %struct.sv* %27, i32 0, i32 2
  %28 = load i32, i32* %sv_flags20, align 4
  %and21 = and i32 %28, 1024
  %tobool22 = icmp ne i32 %and21, 0
  br i1 %tobool22, label %if.then.23, label %if.else

if.then.23:                                       ; preds = %lor.lhs.false.19, %if.then.14
  %29 = load %struct.sv*, %struct.sv** %targ, align 8
  %30 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  call void @Perl_sv_setsv_flags(%struct.sv* %29, %struct.sv* %30, i32 2)
  %31 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags24 = getelementptr inbounds %struct.sv, %struct.sv* %31, i32 0, i32 2
  %32 = load i32, i32* %sv_flags24, align 4
  %and25 = and i32 %32, 16384
  %tobool26 = icmp ne i32 %and25, 0
  br i1 %tobool26, label %if.then.27, label %if.end

if.then.27:                                       ; preds = %if.then.23
  %33 = load %struct.sv*, %struct.sv** %targ, align 8
  %call28 = call i32 @Perl_mg_set(%struct.sv* %33)
  br label %if.end

if.end:                                           ; preds = %if.then.27, %if.then.23
  %34 = load %struct.sv*, %struct.sv** %targ, align 8
  %35 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %34, %struct.sv** %35, align 8
  store %struct.sv* %34, %struct.sv** %tmp
  %36 = load %struct.sv*, %struct.sv** %tmp
  br label %if.end.29

if.else:                                          ; preds = %lor.lhs.false.19
  %37 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %38 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %37, %struct.sv** %38, align 8
  br label %if.end.29

if.end.29:                                        ; preds = %if.else, %if.end
  %39 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %39, %struct.sv*** @PL_stack_sp, align 8
  %40 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %40, i32 0, i32 0
  %41 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %41, %struct.op** %retval
  br label %return

if.end.30:                                        ; preds = %land.lhs.true, %lor.lhs.false
  br label %if.end.31

if.end.31:                                        ; preds = %if.end.30, %cond.end
  %42 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr33 = getelementptr inbounds %struct.sv*, %struct.sv** %42, i32 -1
  store %struct.sv** %incdec.ptr33, %struct.sv*** %sp, align 8
  %43 = load %struct.sv*, %struct.sv** %42, align 8
  store %struct.sv* %43, %struct.sv** @PL_Sv, align 8
  %44 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags34 = getelementptr inbounds %struct.sv, %struct.sv* %44, i32 0, i32 2
  %45 = load i32, i32* %sv_flags34, align 4
  %and35 = and i32 %45, 65536
  %tobool36 = icmp ne i32 %and35, 0
  br i1 %tobool36, label %cond.true.37, label %cond.false.38

cond.true.37:                                     ; preds = %if.end.31
  %46 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %46, i32 0, i32 0
  %47 = load i8*, i8** %sv_any, align 8
  %48 = bitcast i8* %47 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %48, i32 0, i32 3
  %49 = load i64, i64* %xiv_iv, align 8
  br label %cond.end.40

cond.false.38:                                    ; preds = %if.end.31
  %50 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call39 = call i64 @Perl_sv_2iv(%struct.sv* %50)
  br label %cond.end.40

cond.end.40:                                      ; preds = %cond.false.38, %cond.true.37
  %cond41 = phi i64 [ %49, %cond.true.37 ], [ %call39, %cond.false.38 ]
  store i64 %cond41, i64* %value, align 8
  %51 = load i64, i64* %value, align 8
  %cmp = icmp eq i64 %51, 0
  br i1 %cmp, label %if.then.43, label %if.end.45

if.then.43:                                       ; preds = %cond.end.40
  %call44 = call %struct.op* (i8*, ...) @Perl_die(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.29, i32 0, i32 0))
  store %struct.op* %call44, %struct.op** %retval
  br label %return

if.end.45:                                        ; preds = %cond.end.40
  %52 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr46 = getelementptr inbounds %struct.sv*, %struct.sv** %52, i32 -1
  store %struct.sv** %incdec.ptr46, %struct.sv*** %sp, align 8
  %53 = load %struct.sv*, %struct.sv** %52, align 8
  store %struct.sv* %53, %struct.sv** @PL_Sv, align 8
  %54 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags47 = getelementptr inbounds %struct.sv, %struct.sv* %54, i32 0, i32 2
  %55 = load i32, i32* %sv_flags47, align 4
  %and48 = and i32 %55, 65536
  %tobool49 = icmp ne i32 %and48, 0
  br i1 %tobool49, label %cond.true.50, label %cond.false.53

cond.true.50:                                     ; preds = %if.end.45
  %56 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any51 = getelementptr inbounds %struct.sv, %struct.sv* %56, i32 0, i32 0
  %57 = load i8*, i8** %sv_any51, align 8
  %58 = bitcast i8* %57 to %struct.xpviv*
  %xiv_iv52 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %58, i32 0, i32 3
  %59 = load i64, i64* %xiv_iv52, align 8
  br label %cond.end.55

cond.false.53:                                    ; preds = %if.end.45
  %60 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call54 = call i64 @Perl_sv_2iv(%struct.sv* %60)
  br label %cond.end.55

cond.end.55:                                      ; preds = %cond.false.53, %cond.true.50
  %cond56 = phi i64 [ %59, %cond.true.50 ], [ %call54, %cond.false.53 ]
  %61 = load i64, i64* %value, align 8
  %div = sdiv i64 %cond56, %61
  store i64 %div, i64* %value, align 8
  %62 = load %struct.sv*, %struct.sv** %targ, align 8
  %63 = load i64, i64* %value, align 8
  call void @Perl_sv_setiv(%struct.sv* %62, i64 %63)
  %64 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags57 = getelementptr inbounds %struct.sv, %struct.sv* %64, i32 0, i32 2
  %65 = load i32, i32* %sv_flags57, align 4
  %and58 = and i32 %65, 16384
  %tobool59 = icmp ne i32 %and58, 0
  br i1 %tobool59, label %if.then.60, label %if.end.62

if.then.60:                                       ; preds = %cond.end.55
  %66 = load %struct.sv*, %struct.sv** %targ, align 8
  %call61 = call i32 @Perl_mg_set(%struct.sv* %66)
  br label %if.end.62

if.end.62:                                        ; preds = %if.then.60, %cond.end.55
  %67 = load %struct.sv*, %struct.sv** %targ, align 8
  %68 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr64 = getelementptr inbounds %struct.sv*, %struct.sv** %68, i32 1
  store %struct.sv** %incdec.ptr64, %struct.sv*** %sp, align 8
  store %struct.sv* %67, %struct.sv** %incdec.ptr64, align 8
  store %struct.sv* %67, %struct.sv** %tmp63
  %69 = load %struct.sv*, %struct.sv** %tmp63
  %70 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %70, %struct.sv*** @PL_stack_sp, align 8
  %71 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next65 = getelementptr inbounds %struct.op, %struct.op* %71, i32 0, i32 0
  %72 = load %struct.op*, %struct.op** %op_next65, align 8
  store %struct.op* %72, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.62, %if.then.43, %if.end.29
  %73 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %73
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_i_modulo() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %right = alloca %struct.sv*, align 8
  %left = alloca %struct.sv*, align 8
  %tmp = alloca %struct.sv*, align 8
  %right33 = alloca i64, align 8
  %left44 = alloca i64, align 8
  %l = alloca i64, align 8
  %r = alloca i64, align 8
  %tmp80 = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 6
  %2 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 64
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load %struct.sv**, %struct.sv*** %sp, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 -1
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %5 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %5, i32 0, i32 3
  %6 = load i64, i64* %op_targ, align 8
  %7 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx1 = getelementptr inbounds %struct.sv*, %struct.sv** %7, i64 %6
  %8 = load %struct.sv*, %struct.sv** %arrayidx1, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.sv* [ %4, %cond.true ], [ %8, %cond.false ]
  store %struct.sv* %cond, %struct.sv** %targ, align 8
  %9 = load i64, i64* @PL_amagic_generation, align 8
  %tobool2 = icmp ne i64 %9, 0
  br i1 %tobool2, label %if.then, label %if.end.31

if.then:                                          ; preds = %cond.end
  %10 = load %struct.sv**, %struct.sv*** %sp, align 8
  %11 = load %struct.sv*, %struct.sv** %10, align 8
  store %struct.sv* %11, %struct.sv** %right, align 8
  %12 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %12, i64 -1
  %13 = load %struct.sv*, %struct.sv** %add.ptr, align 8
  store %struct.sv* %13, %struct.sv** %left, align 8
  %14 = load %struct.sv*, %struct.sv** %left, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %14, i32 0, i32 2
  %15 = load i32, i32* %sv_flags, align 4
  %and3 = and i32 %15, 268435456
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %16 = load %struct.sv*, %struct.sv** %right, align 8
  %sv_flags5 = getelementptr inbounds %struct.sv, %struct.sv* %16, i32 0, i32 2
  %17 = load i32, i32* %sv_flags5, align 4
  %and6 = and i32 %17, 268435456
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %land.lhs.true, label %if.end.30

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %18 = load %struct.sv*, %struct.sv** %left, align 8
  %19 = load %struct.sv*, %struct.sv** %right, align 8
  %20 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags8 = getelementptr inbounds %struct.op, %struct.op* %20, i32 0, i32 6
  %21 = load i8, i8* %op_flags8, align 1
  %conv9 = zext i8 %21 to i32
  %and10 = and i32 %conv9, 64
  %tobool11 = icmp ne i32 %and10, 0
  %cond12 = select i1 %tobool11, i32 4, i32 0
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %18, %struct.sv* %19, i32 14, i32 %cond12)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool13 = icmp ne %struct.sv* %call, null
  br i1 %tobool13, label %if.then.14, label %if.end.30

if.then.14:                                       ; preds = %land.lhs.true
  %22 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %22, %struct.sv*** %sp, align 8
  %23 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %23, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %24 = load %struct.sv*, %struct.sv** %23, align 8
  %25 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags15 = getelementptr inbounds %struct.op, %struct.op* %25, i32 0, i32 6
  %26 = load i8, i8* %op_flags15, align 1
  %conv16 = zext i8 %26 to i32
  %and17 = and i32 %conv16, 64
  %tobool18 = icmp ne i32 %and17, 0
  br i1 %tobool18, label %if.then.23, label %lor.lhs.false.19

lor.lhs.false.19:                                 ; preds = %if.then.14
  %27 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags20 = getelementptr inbounds %struct.sv, %struct.sv* %27, i32 0, i32 2
  %28 = load i32, i32* %sv_flags20, align 4
  %and21 = and i32 %28, 1024
  %tobool22 = icmp ne i32 %and21, 0
  br i1 %tobool22, label %if.then.23, label %if.else

if.then.23:                                       ; preds = %lor.lhs.false.19, %if.then.14
  %29 = load %struct.sv*, %struct.sv** %targ, align 8
  %30 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  call void @Perl_sv_setsv_flags(%struct.sv* %29, %struct.sv* %30, i32 2)
  %31 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags24 = getelementptr inbounds %struct.sv, %struct.sv* %31, i32 0, i32 2
  %32 = load i32, i32* %sv_flags24, align 4
  %and25 = and i32 %32, 16384
  %tobool26 = icmp ne i32 %and25, 0
  br i1 %tobool26, label %if.then.27, label %if.end

if.then.27:                                       ; preds = %if.then.23
  %33 = load %struct.sv*, %struct.sv** %targ, align 8
  %call28 = call i32 @Perl_mg_set(%struct.sv* %33)
  br label %if.end

if.end:                                           ; preds = %if.then.27, %if.then.23
  %34 = load %struct.sv*, %struct.sv** %targ, align 8
  %35 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %34, %struct.sv** %35, align 8
  store %struct.sv* %34, %struct.sv** %tmp
  %36 = load %struct.sv*, %struct.sv** %tmp
  br label %if.end.29

if.else:                                          ; preds = %lor.lhs.false.19
  %37 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %38 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %37, %struct.sv** %38, align 8
  br label %if.end.29

if.end.29:                                        ; preds = %if.else, %if.end
  %39 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %39, %struct.sv*** @PL_stack_sp, align 8
  %40 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %40, i32 0, i32 0
  %41 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %41, %struct.op** %retval
  br label %return

if.end.30:                                        ; preds = %land.lhs.true, %lor.lhs.false
  br label %if.end.31

if.end.31:                                        ; preds = %if.end.30, %cond.end
  %42 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr34 = getelementptr inbounds %struct.sv*, %struct.sv** %42, i32 -1
  store %struct.sv** %incdec.ptr34, %struct.sv*** %sp, align 8
  %43 = load %struct.sv*, %struct.sv** %42, align 8
  store %struct.sv* %43, %struct.sv** @PL_Sv, align 8
  %44 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags35 = getelementptr inbounds %struct.sv, %struct.sv* %44, i32 0, i32 2
  %45 = load i32, i32* %sv_flags35, align 4
  %and36 = and i32 %45, 65536
  %tobool37 = icmp ne i32 %and36, 0
  br i1 %tobool37, label %cond.true.38, label %cond.false.39

cond.true.38:                                     ; preds = %if.end.31
  %46 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %46, i32 0, i32 0
  %47 = load i8*, i8** %sv_any, align 8
  %48 = bitcast i8* %47 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %48, i32 0, i32 3
  %49 = load i64, i64* %xiv_iv, align 8
  br label %cond.end.41

cond.false.39:                                    ; preds = %if.end.31
  %50 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call40 = call i64 @Perl_sv_2iv(%struct.sv* %50)
  br label %cond.end.41

cond.end.41:                                      ; preds = %cond.false.39, %cond.true.38
  %cond42 = phi i64 [ %49, %cond.true.38 ], [ %call40, %cond.false.39 ]
  store i64 %cond42, i64* %right33, align 8
  %51 = load %struct.sv**, %struct.sv*** %sp, align 8
  %52 = load %struct.sv*, %struct.sv** %51, align 8
  %sv_flags45 = getelementptr inbounds %struct.sv, %struct.sv* %52, i32 0, i32 2
  %53 = load i32, i32* %sv_flags45, align 4
  %and46 = and i32 %53, 65536
  %tobool47 = icmp ne i32 %and46, 0
  br i1 %tobool47, label %cond.true.48, label %cond.false.51

cond.true.48:                                     ; preds = %cond.end.41
  %54 = load %struct.sv**, %struct.sv*** %sp, align 8
  %55 = load %struct.sv*, %struct.sv** %54, align 8
  %sv_any49 = getelementptr inbounds %struct.sv, %struct.sv* %55, i32 0, i32 0
  %56 = load i8*, i8** %sv_any49, align 8
  %57 = bitcast i8* %56 to %struct.xpviv*
  %xiv_iv50 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %57, i32 0, i32 3
  %58 = load i64, i64* %xiv_iv50, align 8
  br label %cond.end.53

cond.false.51:                                    ; preds = %cond.end.41
  %59 = load %struct.sv**, %struct.sv*** %sp, align 8
  %60 = load %struct.sv*, %struct.sv** %59, align 8
  %call52 = call i64 @Perl_sv_2iv(%struct.sv* %60)
  br label %cond.end.53

cond.end.53:                                      ; preds = %cond.false.51, %cond.true.48
  %cond54 = phi i64 [ %58, %cond.true.48 ], [ %call52, %cond.false.51 ]
  store i64 %cond54, i64* %left44, align 8
  %61 = load i64, i64* %right33, align 8
  %tobool55 = icmp ne i64 %61, 0
  br i1 %tobool55, label %if.end.58, label %if.then.56

if.then.56:                                       ; preds = %cond.end.53
  %call57 = call %struct.op* (i8*, ...) @Perl_die(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.30, i32 0, i32 0))
  store %struct.op* %call57, %struct.op** %retval
  br label %return

if.end.58:                                        ; preds = %cond.end.53
  store %struct.op* ()* @Perl_pp_i_modulo_0, %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 60), align 8
  %62 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_ppaddr = getelementptr inbounds %struct.op, %struct.op* %62, i32 0, i32 2
  %op_ppaddr59 = bitcast {}** %op_ppaddr to %struct.op* ()**
  store %struct.op* ()* @Perl_pp_i_modulo_0, %struct.op* ()** %op_ppaddr59, align 8
  store i64 3, i64* %l, align 8
  store i64 -10, i64* %r, align 8
  %63 = load i64, i64* %l, align 8
  %64 = load i64, i64* %r, align 8
  %rem = srem i64 %63, %64
  %cmp = icmp eq i64 %rem, -3
  br i1 %cmp, label %if.then.63, label %if.end.72

if.then.63:                                       ; preds = %if.end.58
  store %struct.op* ()* @Perl_pp_i_modulo_1, %struct.op* ()** getelementptr inbounds ([0 x %struct.op* ()*], [0 x %struct.op* ()*]* @PL_ppaddr, i32 0, i64 60), align 8
  %65 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_ppaddr64 = getelementptr inbounds %struct.op, %struct.op* %65, i32 0, i32 2
  %op_ppaddr65 = bitcast {}** %op_ppaddr64 to %struct.op* ()**
  store %struct.op* ()* @Perl_pp_i_modulo_1, %struct.op* ()** %op_ppaddr65, align 8
  %66 = load i64, i64* %right33, align 8
  %cmp66 = icmp slt i64 %66, 0
  br i1 %cmp66, label %cond.true.68, label %cond.false.69

cond.true.68:                                     ; preds = %if.then.63
  %67 = load i64, i64* %right33, align 8
  %sub = sub nsw i64 0, %67
  br label %cond.end.70

cond.false.69:                                    ; preds = %if.then.63
  %68 = load i64, i64* %right33, align 8
  br label %cond.end.70

cond.end.70:                                      ; preds = %cond.false.69, %cond.true.68
  %cond71 = phi i64 [ %sub, %cond.true.68 ], [ %68, %cond.false.69 ]
  store i64 %cond71, i64* %right33, align 8
  br label %if.end.72

if.end.72:                                        ; preds = %cond.end.70, %if.end.58
  %69 = load %struct.sv*, %struct.sv** %targ, align 8
  %70 = load i64, i64* %left44, align 8
  %71 = load i64, i64* %right33, align 8
  %rem73 = srem i64 %70, %71
  call void @Perl_sv_setiv(%struct.sv* %69, i64 %rem73)
  %72 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags74 = getelementptr inbounds %struct.sv, %struct.sv* %72, i32 0, i32 2
  %73 = load i32, i32* %sv_flags74, align 4
  %and75 = and i32 %73, 16384
  %tobool76 = icmp ne i32 %and75, 0
  br i1 %tobool76, label %if.then.77, label %if.end.79

if.then.77:                                       ; preds = %if.end.72
  %74 = load %struct.sv*, %struct.sv** %targ, align 8
  %call78 = call i32 @Perl_mg_set(%struct.sv* %74)
  br label %if.end.79

if.end.79:                                        ; preds = %if.then.77, %if.end.72
  %75 = load %struct.sv*, %struct.sv** %targ, align 8
  %76 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %75, %struct.sv** %76, align 8
  store %struct.sv* %75, %struct.sv** %tmp80
  %77 = load %struct.sv*, %struct.sv** %tmp80
  %78 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %78, %struct.sv*** @PL_stack_sp, align 8
  %79 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next81 = getelementptr inbounds %struct.op, %struct.op* %79, i32 0, i32 0
  %80 = load %struct.op*, %struct.op** %op_next81, align 8
  store %struct.op* %80, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.79, %if.then.56, %if.end.29
  %81 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %81
}

; Function Attrs: nounwind uwtable
define internal %struct.op* @Perl_pp_i_modulo_0() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %right = alloca %struct.sv*, align 8
  %left = alloca %struct.sv*, align 8
  %tmp = alloca %struct.sv*, align 8
  %right33 = alloca i64, align 8
  %left44 = alloca i64, align 8
  %tmp65 = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 6
  %2 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 64
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load %struct.sv**, %struct.sv*** %sp, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 -1
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %5 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %5, i32 0, i32 3
  %6 = load i64, i64* %op_targ, align 8
  %7 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx1 = getelementptr inbounds %struct.sv*, %struct.sv** %7, i64 %6
  %8 = load %struct.sv*, %struct.sv** %arrayidx1, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.sv* [ %4, %cond.true ], [ %8, %cond.false ]
  store %struct.sv* %cond, %struct.sv** %targ, align 8
  %9 = load i64, i64* @PL_amagic_generation, align 8
  %tobool2 = icmp ne i64 %9, 0
  br i1 %tobool2, label %if.then, label %if.end.31

if.then:                                          ; preds = %cond.end
  %10 = load %struct.sv**, %struct.sv*** %sp, align 8
  %11 = load %struct.sv*, %struct.sv** %10, align 8
  store %struct.sv* %11, %struct.sv** %right, align 8
  %12 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %12, i64 -1
  %13 = load %struct.sv*, %struct.sv** %add.ptr, align 8
  store %struct.sv* %13, %struct.sv** %left, align 8
  %14 = load %struct.sv*, %struct.sv** %left, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %14, i32 0, i32 2
  %15 = load i32, i32* %sv_flags, align 4
  %and3 = and i32 %15, 268435456
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %16 = load %struct.sv*, %struct.sv** %right, align 8
  %sv_flags5 = getelementptr inbounds %struct.sv, %struct.sv* %16, i32 0, i32 2
  %17 = load i32, i32* %sv_flags5, align 4
  %and6 = and i32 %17, 268435456
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %land.lhs.true, label %if.end.30

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %18 = load %struct.sv*, %struct.sv** %left, align 8
  %19 = load %struct.sv*, %struct.sv** %right, align 8
  %20 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags8 = getelementptr inbounds %struct.op, %struct.op* %20, i32 0, i32 6
  %21 = load i8, i8* %op_flags8, align 1
  %conv9 = zext i8 %21 to i32
  %and10 = and i32 %conv9, 64
  %tobool11 = icmp ne i32 %and10, 0
  %cond12 = select i1 %tobool11, i32 4, i32 0
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %18, %struct.sv* %19, i32 14, i32 %cond12)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool13 = icmp ne %struct.sv* %call, null
  br i1 %tobool13, label %if.then.14, label %if.end.30

if.then.14:                                       ; preds = %land.lhs.true
  %22 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %22, %struct.sv*** %sp, align 8
  %23 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %23, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %24 = load %struct.sv*, %struct.sv** %23, align 8
  %25 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags15 = getelementptr inbounds %struct.op, %struct.op* %25, i32 0, i32 6
  %26 = load i8, i8* %op_flags15, align 1
  %conv16 = zext i8 %26 to i32
  %and17 = and i32 %conv16, 64
  %tobool18 = icmp ne i32 %and17, 0
  br i1 %tobool18, label %if.then.23, label %lor.lhs.false.19

lor.lhs.false.19:                                 ; preds = %if.then.14
  %27 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags20 = getelementptr inbounds %struct.sv, %struct.sv* %27, i32 0, i32 2
  %28 = load i32, i32* %sv_flags20, align 4
  %and21 = and i32 %28, 1024
  %tobool22 = icmp ne i32 %and21, 0
  br i1 %tobool22, label %if.then.23, label %if.else

if.then.23:                                       ; preds = %lor.lhs.false.19, %if.then.14
  %29 = load %struct.sv*, %struct.sv** %targ, align 8
  %30 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  call void @Perl_sv_setsv_flags(%struct.sv* %29, %struct.sv* %30, i32 2)
  %31 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags24 = getelementptr inbounds %struct.sv, %struct.sv* %31, i32 0, i32 2
  %32 = load i32, i32* %sv_flags24, align 4
  %and25 = and i32 %32, 16384
  %tobool26 = icmp ne i32 %and25, 0
  br i1 %tobool26, label %if.then.27, label %if.end

if.then.27:                                       ; preds = %if.then.23
  %33 = load %struct.sv*, %struct.sv** %targ, align 8
  %call28 = call i32 @Perl_mg_set(%struct.sv* %33)
  br label %if.end

if.end:                                           ; preds = %if.then.27, %if.then.23
  %34 = load %struct.sv*, %struct.sv** %targ, align 8
  %35 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %34, %struct.sv** %35, align 8
  store %struct.sv* %34, %struct.sv** %tmp
  %36 = load %struct.sv*, %struct.sv** %tmp
  br label %if.end.29

if.else:                                          ; preds = %lor.lhs.false.19
  %37 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %38 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %37, %struct.sv** %38, align 8
  br label %if.end.29

if.end.29:                                        ; preds = %if.else, %if.end
  %39 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %39, %struct.sv*** @PL_stack_sp, align 8
  %40 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %40, i32 0, i32 0
  %41 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %41, %struct.op** %retval
  br label %return

if.end.30:                                        ; preds = %land.lhs.true, %lor.lhs.false
  br label %if.end.31

if.end.31:                                        ; preds = %if.end.30, %cond.end
  %42 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr34 = getelementptr inbounds %struct.sv*, %struct.sv** %42, i32 -1
  store %struct.sv** %incdec.ptr34, %struct.sv*** %sp, align 8
  %43 = load %struct.sv*, %struct.sv** %42, align 8
  store %struct.sv* %43, %struct.sv** @PL_Sv, align 8
  %44 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags35 = getelementptr inbounds %struct.sv, %struct.sv* %44, i32 0, i32 2
  %45 = load i32, i32* %sv_flags35, align 4
  %and36 = and i32 %45, 65536
  %tobool37 = icmp ne i32 %and36, 0
  br i1 %tobool37, label %cond.true.38, label %cond.false.39

cond.true.38:                                     ; preds = %if.end.31
  %46 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %46, i32 0, i32 0
  %47 = load i8*, i8** %sv_any, align 8
  %48 = bitcast i8* %47 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %48, i32 0, i32 3
  %49 = load i64, i64* %xiv_iv, align 8
  br label %cond.end.41

cond.false.39:                                    ; preds = %if.end.31
  %50 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call40 = call i64 @Perl_sv_2iv(%struct.sv* %50)
  br label %cond.end.41

cond.end.41:                                      ; preds = %cond.false.39, %cond.true.38
  %cond42 = phi i64 [ %49, %cond.true.38 ], [ %call40, %cond.false.39 ]
  store i64 %cond42, i64* %right33, align 8
  %51 = load %struct.sv**, %struct.sv*** %sp, align 8
  %52 = load %struct.sv*, %struct.sv** %51, align 8
  %sv_flags45 = getelementptr inbounds %struct.sv, %struct.sv* %52, i32 0, i32 2
  %53 = load i32, i32* %sv_flags45, align 4
  %and46 = and i32 %53, 65536
  %tobool47 = icmp ne i32 %and46, 0
  br i1 %tobool47, label %cond.true.48, label %cond.false.51

cond.true.48:                                     ; preds = %cond.end.41
  %54 = load %struct.sv**, %struct.sv*** %sp, align 8
  %55 = load %struct.sv*, %struct.sv** %54, align 8
  %sv_any49 = getelementptr inbounds %struct.sv, %struct.sv* %55, i32 0, i32 0
  %56 = load i8*, i8** %sv_any49, align 8
  %57 = bitcast i8* %56 to %struct.xpviv*
  %xiv_iv50 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %57, i32 0, i32 3
  %58 = load i64, i64* %xiv_iv50, align 8
  br label %cond.end.53

cond.false.51:                                    ; preds = %cond.end.41
  %59 = load %struct.sv**, %struct.sv*** %sp, align 8
  %60 = load %struct.sv*, %struct.sv** %59, align 8
  %call52 = call i64 @Perl_sv_2iv(%struct.sv* %60)
  br label %cond.end.53

cond.end.53:                                      ; preds = %cond.false.51, %cond.true.48
  %cond54 = phi i64 [ %58, %cond.true.48 ], [ %call52, %cond.false.51 ]
  store i64 %cond54, i64* %left44, align 8
  %61 = load i64, i64* %right33, align 8
  %tobool55 = icmp ne i64 %61, 0
  br i1 %tobool55, label %if.end.58, label %if.then.56

if.then.56:                                       ; preds = %cond.end.53
  %call57 = call %struct.op* (i8*, ...) @Perl_die(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.30, i32 0, i32 0))
  store %struct.op* %call57, %struct.op** %retval
  br label %return

if.end.58:                                        ; preds = %cond.end.53
  %62 = load %struct.sv*, %struct.sv** %targ, align 8
  %63 = load i64, i64* %left44, align 8
  %64 = load i64, i64* %right33, align 8
  %rem = srem i64 %63, %64
  call void @Perl_sv_setiv(%struct.sv* %62, i64 %rem)
  %65 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags59 = getelementptr inbounds %struct.sv, %struct.sv* %65, i32 0, i32 2
  %66 = load i32, i32* %sv_flags59, align 4
  %and60 = and i32 %66, 16384
  %tobool61 = icmp ne i32 %and60, 0
  br i1 %tobool61, label %if.then.62, label %if.end.64

if.then.62:                                       ; preds = %if.end.58
  %67 = load %struct.sv*, %struct.sv** %targ, align 8
  %call63 = call i32 @Perl_mg_set(%struct.sv* %67)
  br label %if.end.64

if.end.64:                                        ; preds = %if.then.62, %if.end.58
  %68 = load %struct.sv*, %struct.sv** %targ, align 8
  %69 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %68, %struct.sv** %69, align 8
  store %struct.sv* %68, %struct.sv** %tmp65
  %70 = load %struct.sv*, %struct.sv** %tmp65
  %71 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %71, %struct.sv*** @PL_stack_sp, align 8
  %72 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next66 = getelementptr inbounds %struct.op, %struct.op* %72, i32 0, i32 0
  %73 = load %struct.op*, %struct.op** %op_next66, align 8
  store %struct.op* %73, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.64, %if.then.56, %if.end.29
  %74 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %74
}

; Function Attrs: nounwind uwtable
define internal %struct.op* @Perl_pp_i_modulo_1() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %right = alloca %struct.sv*, align 8
  %left = alloca %struct.sv*, align 8
  %tmp = alloca %struct.sv*, align 8
  %right33 = alloca i64, align 8
  %left44 = alloca i64, align 8
  %tmp70 = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 6
  %2 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 64
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load %struct.sv**, %struct.sv*** %sp, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 -1
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %5 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %5, i32 0, i32 3
  %6 = load i64, i64* %op_targ, align 8
  %7 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx1 = getelementptr inbounds %struct.sv*, %struct.sv** %7, i64 %6
  %8 = load %struct.sv*, %struct.sv** %arrayidx1, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.sv* [ %4, %cond.true ], [ %8, %cond.false ]
  store %struct.sv* %cond, %struct.sv** %targ, align 8
  %9 = load i64, i64* @PL_amagic_generation, align 8
  %tobool2 = icmp ne i64 %9, 0
  br i1 %tobool2, label %if.then, label %if.end.31

if.then:                                          ; preds = %cond.end
  %10 = load %struct.sv**, %struct.sv*** %sp, align 8
  %11 = load %struct.sv*, %struct.sv** %10, align 8
  store %struct.sv* %11, %struct.sv** %right, align 8
  %12 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %12, i64 -1
  %13 = load %struct.sv*, %struct.sv** %add.ptr, align 8
  store %struct.sv* %13, %struct.sv** %left, align 8
  %14 = load %struct.sv*, %struct.sv** %left, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %14, i32 0, i32 2
  %15 = load i32, i32* %sv_flags, align 4
  %and3 = and i32 %15, 268435456
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %16 = load %struct.sv*, %struct.sv** %right, align 8
  %sv_flags5 = getelementptr inbounds %struct.sv, %struct.sv* %16, i32 0, i32 2
  %17 = load i32, i32* %sv_flags5, align 4
  %and6 = and i32 %17, 268435456
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %land.lhs.true, label %if.end.30

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %18 = load %struct.sv*, %struct.sv** %left, align 8
  %19 = load %struct.sv*, %struct.sv** %right, align 8
  %20 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags8 = getelementptr inbounds %struct.op, %struct.op* %20, i32 0, i32 6
  %21 = load i8, i8* %op_flags8, align 1
  %conv9 = zext i8 %21 to i32
  %and10 = and i32 %conv9, 64
  %tobool11 = icmp ne i32 %and10, 0
  %cond12 = select i1 %tobool11, i32 4, i32 0
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %18, %struct.sv* %19, i32 14, i32 %cond12)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool13 = icmp ne %struct.sv* %call, null
  br i1 %tobool13, label %if.then.14, label %if.end.30

if.then.14:                                       ; preds = %land.lhs.true
  %22 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %22, %struct.sv*** %sp, align 8
  %23 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %23, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %24 = load %struct.sv*, %struct.sv** %23, align 8
  %25 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags15 = getelementptr inbounds %struct.op, %struct.op* %25, i32 0, i32 6
  %26 = load i8, i8* %op_flags15, align 1
  %conv16 = zext i8 %26 to i32
  %and17 = and i32 %conv16, 64
  %tobool18 = icmp ne i32 %and17, 0
  br i1 %tobool18, label %if.then.23, label %lor.lhs.false.19

lor.lhs.false.19:                                 ; preds = %if.then.14
  %27 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags20 = getelementptr inbounds %struct.sv, %struct.sv* %27, i32 0, i32 2
  %28 = load i32, i32* %sv_flags20, align 4
  %and21 = and i32 %28, 1024
  %tobool22 = icmp ne i32 %and21, 0
  br i1 %tobool22, label %if.then.23, label %if.else

if.then.23:                                       ; preds = %lor.lhs.false.19, %if.then.14
  %29 = load %struct.sv*, %struct.sv** %targ, align 8
  %30 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  call void @Perl_sv_setsv_flags(%struct.sv* %29, %struct.sv* %30, i32 2)
  %31 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags24 = getelementptr inbounds %struct.sv, %struct.sv* %31, i32 0, i32 2
  %32 = load i32, i32* %sv_flags24, align 4
  %and25 = and i32 %32, 16384
  %tobool26 = icmp ne i32 %and25, 0
  br i1 %tobool26, label %if.then.27, label %if.end

if.then.27:                                       ; preds = %if.then.23
  %33 = load %struct.sv*, %struct.sv** %targ, align 8
  %call28 = call i32 @Perl_mg_set(%struct.sv* %33)
  br label %if.end

if.end:                                           ; preds = %if.then.27, %if.then.23
  %34 = load %struct.sv*, %struct.sv** %targ, align 8
  %35 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %34, %struct.sv** %35, align 8
  store %struct.sv* %34, %struct.sv** %tmp
  %36 = load %struct.sv*, %struct.sv** %tmp
  br label %if.end.29

if.else:                                          ; preds = %lor.lhs.false.19
  %37 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %38 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %37, %struct.sv** %38, align 8
  br label %if.end.29

if.end.29:                                        ; preds = %if.else, %if.end
  %39 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %39, %struct.sv*** @PL_stack_sp, align 8
  %40 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %40, i32 0, i32 0
  %41 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %41, %struct.op** %retval
  br label %return

if.end.30:                                        ; preds = %land.lhs.true, %lor.lhs.false
  br label %if.end.31

if.end.31:                                        ; preds = %if.end.30, %cond.end
  %42 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr34 = getelementptr inbounds %struct.sv*, %struct.sv** %42, i32 -1
  store %struct.sv** %incdec.ptr34, %struct.sv*** %sp, align 8
  %43 = load %struct.sv*, %struct.sv** %42, align 8
  store %struct.sv* %43, %struct.sv** @PL_Sv, align 8
  %44 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags35 = getelementptr inbounds %struct.sv, %struct.sv* %44, i32 0, i32 2
  %45 = load i32, i32* %sv_flags35, align 4
  %and36 = and i32 %45, 65536
  %tobool37 = icmp ne i32 %and36, 0
  br i1 %tobool37, label %cond.true.38, label %cond.false.39

cond.true.38:                                     ; preds = %if.end.31
  %46 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %46, i32 0, i32 0
  %47 = load i8*, i8** %sv_any, align 8
  %48 = bitcast i8* %47 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %48, i32 0, i32 3
  %49 = load i64, i64* %xiv_iv, align 8
  br label %cond.end.41

cond.false.39:                                    ; preds = %if.end.31
  %50 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call40 = call i64 @Perl_sv_2iv(%struct.sv* %50)
  br label %cond.end.41

cond.end.41:                                      ; preds = %cond.false.39, %cond.true.38
  %cond42 = phi i64 [ %49, %cond.true.38 ], [ %call40, %cond.false.39 ]
  store i64 %cond42, i64* %right33, align 8
  %51 = load %struct.sv**, %struct.sv*** %sp, align 8
  %52 = load %struct.sv*, %struct.sv** %51, align 8
  %sv_flags45 = getelementptr inbounds %struct.sv, %struct.sv* %52, i32 0, i32 2
  %53 = load i32, i32* %sv_flags45, align 4
  %and46 = and i32 %53, 65536
  %tobool47 = icmp ne i32 %and46, 0
  br i1 %tobool47, label %cond.true.48, label %cond.false.51

cond.true.48:                                     ; preds = %cond.end.41
  %54 = load %struct.sv**, %struct.sv*** %sp, align 8
  %55 = load %struct.sv*, %struct.sv** %54, align 8
  %sv_any49 = getelementptr inbounds %struct.sv, %struct.sv* %55, i32 0, i32 0
  %56 = load i8*, i8** %sv_any49, align 8
  %57 = bitcast i8* %56 to %struct.xpviv*
  %xiv_iv50 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %57, i32 0, i32 3
  %58 = load i64, i64* %xiv_iv50, align 8
  br label %cond.end.53

cond.false.51:                                    ; preds = %cond.end.41
  %59 = load %struct.sv**, %struct.sv*** %sp, align 8
  %60 = load %struct.sv*, %struct.sv** %59, align 8
  %call52 = call i64 @Perl_sv_2iv(%struct.sv* %60)
  br label %cond.end.53

cond.end.53:                                      ; preds = %cond.false.51, %cond.true.48
  %cond54 = phi i64 [ %58, %cond.true.48 ], [ %call52, %cond.false.51 ]
  store i64 %cond54, i64* %left44, align 8
  %61 = load i64, i64* %right33, align 8
  %tobool55 = icmp ne i64 %61, 0
  br i1 %tobool55, label %if.end.58, label %if.then.56

if.then.56:                                       ; preds = %cond.end.53
  %call57 = call %struct.op* (i8*, ...) @Perl_die(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.30, i32 0, i32 0))
  store %struct.op* %call57, %struct.op** %retval
  br label %return

if.end.58:                                        ; preds = %cond.end.53
  %62 = load %struct.sv*, %struct.sv** %targ, align 8
  %63 = load i64, i64* %left44, align 8
  %64 = load i64, i64* %right33, align 8
  %cmp = icmp slt i64 %64, 0
  br i1 %cmp, label %cond.true.60, label %cond.false.61

cond.true.60:                                     ; preds = %if.end.58
  %65 = load i64, i64* %right33, align 8
  %sub = sub nsw i64 0, %65
  br label %cond.end.62

cond.false.61:                                    ; preds = %if.end.58
  %66 = load i64, i64* %right33, align 8
  br label %cond.end.62

cond.end.62:                                      ; preds = %cond.false.61, %cond.true.60
  %cond63 = phi i64 [ %sub, %cond.true.60 ], [ %66, %cond.false.61 ]
  %rem = srem i64 %63, %cond63
  call void @Perl_sv_setiv(%struct.sv* %62, i64 %rem)
  %67 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags64 = getelementptr inbounds %struct.sv, %struct.sv* %67, i32 0, i32 2
  %68 = load i32, i32* %sv_flags64, align 4
  %and65 = and i32 %68, 16384
  %tobool66 = icmp ne i32 %and65, 0
  br i1 %tobool66, label %if.then.67, label %if.end.69

if.then.67:                                       ; preds = %cond.end.62
  %69 = load %struct.sv*, %struct.sv** %targ, align 8
  %call68 = call i32 @Perl_mg_set(%struct.sv* %69)
  br label %if.end.69

if.end.69:                                        ; preds = %if.then.67, %cond.end.62
  %70 = load %struct.sv*, %struct.sv** %targ, align 8
  %71 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %70, %struct.sv** %71, align 8
  store %struct.sv* %70, %struct.sv** %tmp70
  %72 = load %struct.sv*, %struct.sv** %tmp70
  %73 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %73, %struct.sv*** @PL_stack_sp, align 8
  %74 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next71 = getelementptr inbounds %struct.op, %struct.op* %74, i32 0, i32 0
  %75 = load %struct.op*, %struct.op** %op_next71, align 8
  store %struct.op* %75, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.69, %if.then.56, %if.end.29
  %76 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %76
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_i_add() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %right = alloca %struct.sv*, align 8
  %left = alloca %struct.sv*, align 8
  %tmp = alloca %struct.sv*, align 8
  %right33 = alloca i64, align 8
  %leftsv = alloca %struct.sv*, align 8
  %left45 = alloca i64, align 8
  %tmp78 = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 6
  %2 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 64
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load %struct.sv**, %struct.sv*** %sp, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 -1
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %5 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %5, i32 0, i32 3
  %6 = load i64, i64* %op_targ, align 8
  %7 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx1 = getelementptr inbounds %struct.sv*, %struct.sv** %7, i64 %6
  %8 = load %struct.sv*, %struct.sv** %arrayidx1, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.sv* [ %4, %cond.true ], [ %8, %cond.false ]
  store %struct.sv* %cond, %struct.sv** %targ, align 8
  %9 = load i64, i64* @PL_amagic_generation, align 8
  %tobool2 = icmp ne i64 %9, 0
  br i1 %tobool2, label %if.then, label %if.end.31

if.then:                                          ; preds = %cond.end
  %10 = load %struct.sv**, %struct.sv*** %sp, align 8
  %11 = load %struct.sv*, %struct.sv** %10, align 8
  store %struct.sv* %11, %struct.sv** %right, align 8
  %12 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %12, i64 -1
  %13 = load %struct.sv*, %struct.sv** %add.ptr, align 8
  store %struct.sv* %13, %struct.sv** %left, align 8
  %14 = load %struct.sv*, %struct.sv** %left, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %14, i32 0, i32 2
  %15 = load i32, i32* %sv_flags, align 4
  %and3 = and i32 %15, 268435456
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %16 = load %struct.sv*, %struct.sv** %right, align 8
  %sv_flags5 = getelementptr inbounds %struct.sv, %struct.sv* %16, i32 0, i32 2
  %17 = load i32, i32* %sv_flags5, align 4
  %and6 = and i32 %17, 268435456
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %land.lhs.true, label %if.end.30

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %18 = load %struct.sv*, %struct.sv** %left, align 8
  %19 = load %struct.sv*, %struct.sv** %right, align 8
  %20 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags8 = getelementptr inbounds %struct.op, %struct.op* %20, i32 0, i32 6
  %21 = load i8, i8* %op_flags8, align 1
  %conv9 = zext i8 %21 to i32
  %and10 = and i32 %conv9, 64
  %tobool11 = icmp ne i32 %and10, 0
  %cond12 = select i1 %tobool11, i32 4, i32 0
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %18, %struct.sv* %19, i32 6, i32 %cond12)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool13 = icmp ne %struct.sv* %call, null
  br i1 %tobool13, label %if.then.14, label %if.end.30

if.then.14:                                       ; preds = %land.lhs.true
  %22 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %22, %struct.sv*** %sp, align 8
  %23 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %23, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %24 = load %struct.sv*, %struct.sv** %23, align 8
  %25 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags15 = getelementptr inbounds %struct.op, %struct.op* %25, i32 0, i32 6
  %26 = load i8, i8* %op_flags15, align 1
  %conv16 = zext i8 %26 to i32
  %and17 = and i32 %conv16, 64
  %tobool18 = icmp ne i32 %and17, 0
  br i1 %tobool18, label %if.then.23, label %lor.lhs.false.19

lor.lhs.false.19:                                 ; preds = %if.then.14
  %27 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags20 = getelementptr inbounds %struct.sv, %struct.sv* %27, i32 0, i32 2
  %28 = load i32, i32* %sv_flags20, align 4
  %and21 = and i32 %28, 1024
  %tobool22 = icmp ne i32 %and21, 0
  br i1 %tobool22, label %if.then.23, label %if.else

if.then.23:                                       ; preds = %lor.lhs.false.19, %if.then.14
  %29 = load %struct.sv*, %struct.sv** %targ, align 8
  %30 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  call void @Perl_sv_setsv_flags(%struct.sv* %29, %struct.sv* %30, i32 2)
  %31 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags24 = getelementptr inbounds %struct.sv, %struct.sv* %31, i32 0, i32 2
  %32 = load i32, i32* %sv_flags24, align 4
  %and25 = and i32 %32, 16384
  %tobool26 = icmp ne i32 %and25, 0
  br i1 %tobool26, label %if.then.27, label %if.end

if.then.27:                                       ; preds = %if.then.23
  %33 = load %struct.sv*, %struct.sv** %targ, align 8
  %call28 = call i32 @Perl_mg_set(%struct.sv* %33)
  br label %if.end

if.end:                                           ; preds = %if.then.27, %if.then.23
  %34 = load %struct.sv*, %struct.sv** %targ, align 8
  %35 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %34, %struct.sv** %35, align 8
  store %struct.sv* %34, %struct.sv** %tmp
  %36 = load %struct.sv*, %struct.sv** %tmp
  br label %if.end.29

if.else:                                          ; preds = %lor.lhs.false.19
  %37 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %38 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %37, %struct.sv** %38, align 8
  br label %if.end.29

if.end.29:                                        ; preds = %if.else, %if.end
  %39 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %39, %struct.sv*** @PL_stack_sp, align 8
  %40 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %40, i32 0, i32 0
  %41 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %41, %struct.op** %retval
  br label %return

if.end.30:                                        ; preds = %land.lhs.true, %lor.lhs.false
  br label %if.end.31

if.end.31:                                        ; preds = %if.end.30, %cond.end
  %42 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr34 = getelementptr inbounds %struct.sv*, %struct.sv** %42, i32 -1
  store %struct.sv** %incdec.ptr34, %struct.sv*** %sp, align 8
  %43 = load %struct.sv*, %struct.sv** %42, align 8
  store %struct.sv* %43, %struct.sv** @PL_Sv, align 8
  %44 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags35 = getelementptr inbounds %struct.sv, %struct.sv* %44, i32 0, i32 2
  %45 = load i32, i32* %sv_flags35, align 4
  %and36 = and i32 %45, 65536
  %tobool37 = icmp ne i32 %and36, 0
  br i1 %tobool37, label %cond.true.38, label %cond.false.39

cond.true.38:                                     ; preds = %if.end.31
  %46 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %46, i32 0, i32 0
  %47 = load i8*, i8** %sv_any, align 8
  %48 = bitcast i8* %47 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %48, i32 0, i32 3
  %49 = load i64, i64* %xiv_iv, align 8
  br label %cond.end.41

cond.false.39:                                    ; preds = %if.end.31
  %50 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call40 = call i64 @Perl_sv_2iv(%struct.sv* %50)
  br label %cond.end.41

cond.end.41:                                      ; preds = %cond.false.39, %cond.true.38
  %cond42 = phi i64 [ %49, %cond.true.38 ], [ %call40, %cond.false.39 ]
  store i64 %cond42, i64* %right33, align 8
  %51 = load %struct.sv**, %struct.sv*** %sp, align 8
  %52 = load %struct.sv*, %struct.sv** %51, align 8
  store %struct.sv* %52, %struct.sv** %leftsv, align 8
  %53 = load %struct.sv*, %struct.sv** %leftsv, align 8
  %sv_flags46 = getelementptr inbounds %struct.sv, %struct.sv* %53, i32 0, i32 2
  %54 = load i32, i32* %sv_flags46, align 4
  %and47 = and i32 %54, 118423552
  %tobool48 = icmp ne i32 %and47, 0
  br i1 %tobool48, label %cond.true.58, label %lor.lhs.false.49

lor.lhs.false.49:                                 ; preds = %cond.end.41
  %55 = load %struct.sv*, %struct.sv** %leftsv, align 8
  %sv_flags50 = getelementptr inbounds %struct.sv, %struct.sv* %55, i32 0, i32 2
  %56 = load i32, i32* %sv_flags50, align 4
  %and51 = and i32 %56, 8192
  %tobool52 = icmp ne i32 %and51, 0
  br i1 %tobool52, label %cond.true.58, label %lor.lhs.false.53

lor.lhs.false.53:                                 ; preds = %lor.lhs.false.49
  %57 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags54 = getelementptr inbounds %struct.op, %struct.op* %57, i32 0, i32 6
  %58 = load i8, i8* %op_flags54, align 1
  %conv55 = zext i8 %58 to i32
  %and56 = and i32 %conv55, 64
  %tobool57 = icmp ne i32 %and56, 0
  br i1 %tobool57, label %cond.false.69, label %cond.true.58

cond.true.58:                                     ; preds = %lor.lhs.false.53, %lor.lhs.false.49, %cond.end.41
  %59 = load %struct.sv*, %struct.sv** %leftsv, align 8
  %sv_flags59 = getelementptr inbounds %struct.sv, %struct.sv* %59, i32 0, i32 2
  %60 = load i32, i32* %sv_flags59, align 4
  %and60 = and i32 %60, 65536
  %tobool61 = icmp ne i32 %and60, 0
  br i1 %tobool61, label %cond.true.62, label %cond.false.65

cond.true.62:                                     ; preds = %cond.true.58
  %61 = load %struct.sv*, %struct.sv** %leftsv, align 8
  %sv_any63 = getelementptr inbounds %struct.sv, %struct.sv* %61, i32 0, i32 0
  %62 = load i8*, i8** %sv_any63, align 8
  %63 = bitcast i8* %62 to %struct.xpviv*
  %xiv_iv64 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %63, i32 0, i32 3
  %64 = load i64, i64* %xiv_iv64, align 8
  br label %cond.end.67

cond.false.65:                                    ; preds = %cond.true.58
  %65 = load %struct.sv*, %struct.sv** %leftsv, align 8
  %call66 = call i64 @Perl_sv_2iv(%struct.sv* %65)
  br label %cond.end.67

cond.end.67:                                      ; preds = %cond.false.65, %cond.true.62
  %cond68 = phi i64 [ %64, %cond.true.62 ], [ %call66, %cond.false.65 ]
  br label %cond.end.70

cond.false.69:                                    ; preds = %lor.lhs.false.53
  br label %cond.end.70

cond.end.70:                                      ; preds = %cond.false.69, %cond.end.67
  %cond71 = phi i64 [ %cond68, %cond.end.67 ], [ 0, %cond.false.69 ]
  store i64 %cond71, i64* %left45, align 8
  %66 = load %struct.sv*, %struct.sv** %targ, align 8
  %67 = load i64, i64* %left45, align 8
  %68 = load i64, i64* %right33, align 8
  %add = add nsw i64 %67, %68
  call void @Perl_sv_setiv(%struct.sv* %66, i64 %add)
  %69 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags72 = getelementptr inbounds %struct.sv, %struct.sv* %69, i32 0, i32 2
  %70 = load i32, i32* %sv_flags72, align 4
  %and73 = and i32 %70, 16384
  %tobool74 = icmp ne i32 %and73, 0
  br i1 %tobool74, label %if.then.75, label %if.end.77

if.then.75:                                       ; preds = %cond.end.70
  %71 = load %struct.sv*, %struct.sv** %targ, align 8
  %call76 = call i32 @Perl_mg_set(%struct.sv* %71)
  br label %if.end.77

if.end.77:                                        ; preds = %if.then.75, %cond.end.70
  %72 = load %struct.sv*, %struct.sv** %targ, align 8
  %73 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %72, %struct.sv** %73, align 8
  store %struct.sv* %72, %struct.sv** %tmp78
  %74 = load %struct.sv*, %struct.sv** %tmp78
  %75 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %75, %struct.sv*** @PL_stack_sp, align 8
  %76 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next79 = getelementptr inbounds %struct.op, %struct.op* %76, i32 0, i32 0
  %77 = load %struct.op*, %struct.op** %op_next79, align 8
  store %struct.op* %77, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.77, %if.end.29
  %78 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %78
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_i_subtract() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %right = alloca %struct.sv*, align 8
  %left = alloca %struct.sv*, align 8
  %tmp = alloca %struct.sv*, align 8
  %right33 = alloca i64, align 8
  %leftsv = alloca %struct.sv*, align 8
  %left45 = alloca i64, align 8
  %tmp78 = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 6
  %2 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 64
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %3 = load %struct.sv**, %struct.sv*** %sp, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 -1
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %5 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %5, i32 0, i32 3
  %6 = load i64, i64* %op_targ, align 8
  %7 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx1 = getelementptr inbounds %struct.sv*, %struct.sv** %7, i64 %6
  %8 = load %struct.sv*, %struct.sv** %arrayidx1, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.sv* [ %4, %cond.true ], [ %8, %cond.false ]
  store %struct.sv* %cond, %struct.sv** %targ, align 8
  %9 = load i64, i64* @PL_amagic_generation, align 8
  %tobool2 = icmp ne i64 %9, 0
  br i1 %tobool2, label %if.then, label %if.end.31

if.then:                                          ; preds = %cond.end
  %10 = load %struct.sv**, %struct.sv*** %sp, align 8
  %11 = load %struct.sv*, %struct.sv** %10, align 8
  store %struct.sv* %11, %struct.sv** %right, align 8
  %12 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %12, i64 -1
  %13 = load %struct.sv*, %struct.sv** %add.ptr, align 8
  store %struct.sv* %13, %struct.sv** %left, align 8
  %14 = load %struct.sv*, %struct.sv** %left, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %14, i32 0, i32 2
  %15 = load i32, i32* %sv_flags, align 4
  %and3 = and i32 %15, 268435456
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %16 = load %struct.sv*, %struct.sv** %right, align 8
  %sv_flags5 = getelementptr inbounds %struct.sv, %struct.sv* %16, i32 0, i32 2
  %17 = load i32, i32* %sv_flags5, align 4
  %and6 = and i32 %17, 268435456
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %land.lhs.true, label %if.end.30

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %18 = load %struct.sv*, %struct.sv** %left, align 8
  %19 = load %struct.sv*, %struct.sv** %right, align 8
  %20 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags8 = getelementptr inbounds %struct.op, %struct.op* %20, i32 0, i32 6
  %21 = load i8, i8* %op_flags8, align 1
  %conv9 = zext i8 %21 to i32
  %and10 = and i32 %conv9, 64
  %tobool11 = icmp ne i32 %and10, 0
  %cond12 = select i1 %tobool11, i32 4, i32 0
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %18, %struct.sv* %19, i32 8, i32 %cond12)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool13 = icmp ne %struct.sv* %call, null
  br i1 %tobool13, label %if.then.14, label %if.end.30

if.then.14:                                       ; preds = %land.lhs.true
  %22 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %22, %struct.sv*** %sp, align 8
  %23 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %23, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %24 = load %struct.sv*, %struct.sv** %23, align 8
  %25 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags15 = getelementptr inbounds %struct.op, %struct.op* %25, i32 0, i32 6
  %26 = load i8, i8* %op_flags15, align 1
  %conv16 = zext i8 %26 to i32
  %and17 = and i32 %conv16, 64
  %tobool18 = icmp ne i32 %and17, 0
  br i1 %tobool18, label %if.then.23, label %lor.lhs.false.19

lor.lhs.false.19:                                 ; preds = %if.then.14
  %27 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags20 = getelementptr inbounds %struct.sv, %struct.sv* %27, i32 0, i32 2
  %28 = load i32, i32* %sv_flags20, align 4
  %and21 = and i32 %28, 1024
  %tobool22 = icmp ne i32 %and21, 0
  br i1 %tobool22, label %if.then.23, label %if.else

if.then.23:                                       ; preds = %lor.lhs.false.19, %if.then.14
  %29 = load %struct.sv*, %struct.sv** %targ, align 8
  %30 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  call void @Perl_sv_setsv_flags(%struct.sv* %29, %struct.sv* %30, i32 2)
  %31 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags24 = getelementptr inbounds %struct.sv, %struct.sv* %31, i32 0, i32 2
  %32 = load i32, i32* %sv_flags24, align 4
  %and25 = and i32 %32, 16384
  %tobool26 = icmp ne i32 %and25, 0
  br i1 %tobool26, label %if.then.27, label %if.end

if.then.27:                                       ; preds = %if.then.23
  %33 = load %struct.sv*, %struct.sv** %targ, align 8
  %call28 = call i32 @Perl_mg_set(%struct.sv* %33)
  br label %if.end

if.end:                                           ; preds = %if.then.27, %if.then.23
  %34 = load %struct.sv*, %struct.sv** %targ, align 8
  %35 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %34, %struct.sv** %35, align 8
  store %struct.sv* %34, %struct.sv** %tmp
  %36 = load %struct.sv*, %struct.sv** %tmp
  br label %if.end.29

if.else:                                          ; preds = %lor.lhs.false.19
  %37 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %38 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %37, %struct.sv** %38, align 8
  br label %if.end.29

if.end.29:                                        ; preds = %if.else, %if.end
  %39 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %39, %struct.sv*** @PL_stack_sp, align 8
  %40 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %40, i32 0, i32 0
  %41 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %41, %struct.op** %retval
  br label %return

if.end.30:                                        ; preds = %land.lhs.true, %lor.lhs.false
  br label %if.end.31

if.end.31:                                        ; preds = %if.end.30, %cond.end
  %42 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr34 = getelementptr inbounds %struct.sv*, %struct.sv** %42, i32 -1
  store %struct.sv** %incdec.ptr34, %struct.sv*** %sp, align 8
  %43 = load %struct.sv*, %struct.sv** %42, align 8
  store %struct.sv* %43, %struct.sv** @PL_Sv, align 8
  %44 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags35 = getelementptr inbounds %struct.sv, %struct.sv* %44, i32 0, i32 2
  %45 = load i32, i32* %sv_flags35, align 4
  %and36 = and i32 %45, 65536
  %tobool37 = icmp ne i32 %and36, 0
  br i1 %tobool37, label %cond.true.38, label %cond.false.39

cond.true.38:                                     ; preds = %if.end.31
  %46 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %46, i32 0, i32 0
  %47 = load i8*, i8** %sv_any, align 8
  %48 = bitcast i8* %47 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %48, i32 0, i32 3
  %49 = load i64, i64* %xiv_iv, align 8
  br label %cond.end.41

cond.false.39:                                    ; preds = %if.end.31
  %50 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call40 = call i64 @Perl_sv_2iv(%struct.sv* %50)
  br label %cond.end.41

cond.end.41:                                      ; preds = %cond.false.39, %cond.true.38
  %cond42 = phi i64 [ %49, %cond.true.38 ], [ %call40, %cond.false.39 ]
  store i64 %cond42, i64* %right33, align 8
  %51 = load %struct.sv**, %struct.sv*** %sp, align 8
  %52 = load %struct.sv*, %struct.sv** %51, align 8
  store %struct.sv* %52, %struct.sv** %leftsv, align 8
  %53 = load %struct.sv*, %struct.sv** %leftsv, align 8
  %sv_flags46 = getelementptr inbounds %struct.sv, %struct.sv* %53, i32 0, i32 2
  %54 = load i32, i32* %sv_flags46, align 4
  %and47 = and i32 %54, 118423552
  %tobool48 = icmp ne i32 %and47, 0
  br i1 %tobool48, label %cond.true.58, label %lor.lhs.false.49

lor.lhs.false.49:                                 ; preds = %cond.end.41
  %55 = load %struct.sv*, %struct.sv** %leftsv, align 8
  %sv_flags50 = getelementptr inbounds %struct.sv, %struct.sv* %55, i32 0, i32 2
  %56 = load i32, i32* %sv_flags50, align 4
  %and51 = and i32 %56, 8192
  %tobool52 = icmp ne i32 %and51, 0
  br i1 %tobool52, label %cond.true.58, label %lor.lhs.false.53

lor.lhs.false.53:                                 ; preds = %lor.lhs.false.49
  %57 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags54 = getelementptr inbounds %struct.op, %struct.op* %57, i32 0, i32 6
  %58 = load i8, i8* %op_flags54, align 1
  %conv55 = zext i8 %58 to i32
  %and56 = and i32 %conv55, 64
  %tobool57 = icmp ne i32 %and56, 0
  br i1 %tobool57, label %cond.false.69, label %cond.true.58

cond.true.58:                                     ; preds = %lor.lhs.false.53, %lor.lhs.false.49, %cond.end.41
  %59 = load %struct.sv*, %struct.sv** %leftsv, align 8
  %sv_flags59 = getelementptr inbounds %struct.sv, %struct.sv* %59, i32 0, i32 2
  %60 = load i32, i32* %sv_flags59, align 4
  %and60 = and i32 %60, 65536
  %tobool61 = icmp ne i32 %and60, 0
  br i1 %tobool61, label %cond.true.62, label %cond.false.65

cond.true.62:                                     ; preds = %cond.true.58
  %61 = load %struct.sv*, %struct.sv** %leftsv, align 8
  %sv_any63 = getelementptr inbounds %struct.sv, %struct.sv* %61, i32 0, i32 0
  %62 = load i8*, i8** %sv_any63, align 8
  %63 = bitcast i8* %62 to %struct.xpviv*
  %xiv_iv64 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %63, i32 0, i32 3
  %64 = load i64, i64* %xiv_iv64, align 8
  br label %cond.end.67

cond.false.65:                                    ; preds = %cond.true.58
  %65 = load %struct.sv*, %struct.sv** %leftsv, align 8
  %call66 = call i64 @Perl_sv_2iv(%struct.sv* %65)
  br label %cond.end.67

cond.end.67:                                      ; preds = %cond.false.65, %cond.true.62
  %cond68 = phi i64 [ %64, %cond.true.62 ], [ %call66, %cond.false.65 ]
  br label %cond.end.70

cond.false.69:                                    ; preds = %lor.lhs.false.53
  br label %cond.end.70

cond.end.70:                                      ; preds = %cond.false.69, %cond.end.67
  %cond71 = phi i64 [ %cond68, %cond.end.67 ], [ 0, %cond.false.69 ]
  store i64 %cond71, i64* %left45, align 8
  %66 = load %struct.sv*, %struct.sv** %targ, align 8
  %67 = load i64, i64* %left45, align 8
  %68 = load i64, i64* %right33, align 8
  %sub = sub nsw i64 %67, %68
  call void @Perl_sv_setiv(%struct.sv* %66, i64 %sub)
  %69 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags72 = getelementptr inbounds %struct.sv, %struct.sv* %69, i32 0, i32 2
  %70 = load i32, i32* %sv_flags72, align 4
  %and73 = and i32 %70, 16384
  %tobool74 = icmp ne i32 %and73, 0
  br i1 %tobool74, label %if.then.75, label %if.end.77

if.then.75:                                       ; preds = %cond.end.70
  %71 = load %struct.sv*, %struct.sv** %targ, align 8
  %call76 = call i32 @Perl_mg_set(%struct.sv* %71)
  br label %if.end.77

if.end.77:                                        ; preds = %if.then.75, %cond.end.70
  %72 = load %struct.sv*, %struct.sv** %targ, align 8
  %73 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %72, %struct.sv** %73, align 8
  store %struct.sv* %72, %struct.sv** %tmp78
  %74 = load %struct.sv*, %struct.sv** %tmp78
  %75 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %75, %struct.sv*** @PL_stack_sp, align 8
  %76 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next79 = getelementptr inbounds %struct.op, %struct.op* %76, i32 0, i32 0
  %77 = load %struct.op*, %struct.op** %op_next79, align 8
  store %struct.op* %77, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.77, %if.end.29
  %78 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %78
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_i_lt() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %right = alloca %struct.sv*, align 8
  %left = alloca %struct.sv*, align 8
  %right8 = alloca i64, align 8
  %left14 = alloca i64, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load i64, i64* @PL_amagic_generation, align 8
  %tobool = icmp ne i64 %1, 0
  br i1 %tobool, label %if.then, label %if.end.7

if.then:                                          ; preds = %entry
  %2 = load %struct.sv**, %struct.sv*** %sp, align 8
  %3 = load %struct.sv*, %struct.sv** %2, align 8
  store %struct.sv* %3, %struct.sv** %right, align 8
  %4 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %4, i64 -1
  %5 = load %struct.sv*, %struct.sv** %add.ptr, align 8
  store %struct.sv* %5, %struct.sv** %left, align 8
  %6 = load %struct.sv*, %struct.sv** %left, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %6, i32 0, i32 2
  %7 = load i32, i32* %sv_flags, align 4
  %and = and i32 %7, 268435456
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %8 = load %struct.sv*, %struct.sv** %right, align 8
  %sv_flags2 = getelementptr inbounds %struct.sv, %struct.sv* %8, i32 0, i32 2
  %9 = load i32, i32* %sv_flags2, align 4
  %and3 = and i32 %9, 268435456
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %10 = load %struct.sv*, %struct.sv** %left, align 8
  %11 = load %struct.sv*, %struct.sv** %right, align 8
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %10, %struct.sv* %11, i32 28, i32 0)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool5 = icmp ne %struct.sv* %call, null
  br i1 %tobool5, label %if.then.6, label %if.end

if.then.6:                                        ; preds = %land.lhs.true
  %12 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %12, %struct.sv*** %sp, align 8
  %13 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %13, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %14 = load %struct.sv*, %struct.sv** %13, align 8
  %15 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %16 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %15, %struct.sv** %16, align 8
  %17 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %17, %struct.sv*** @PL_stack_sp, align 8
  %18 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %18, i32 0, i32 0
  %19 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %19, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %land.lhs.true, %lor.lhs.false
  br label %if.end.7

if.end.7:                                         ; preds = %if.end, %entry
  %20 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr9 = getelementptr inbounds %struct.sv*, %struct.sv** %20, i32 -1
  store %struct.sv** %incdec.ptr9, %struct.sv*** %sp, align 8
  %21 = load %struct.sv*, %struct.sv** %20, align 8
  store %struct.sv* %21, %struct.sv** @PL_Sv, align 8
  %22 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags10 = getelementptr inbounds %struct.sv, %struct.sv* %22, i32 0, i32 2
  %23 = load i32, i32* %sv_flags10, align 4
  %and11 = and i32 %23, 65536
  %tobool12 = icmp ne i32 %and11, 0
  br i1 %tobool12, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.7
  %24 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %24, i32 0, i32 0
  %25 = load i8*, i8** %sv_any, align 8
  %26 = bitcast i8* %25 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %26, i32 0, i32 3
  %27 = load i64, i64* %xiv_iv, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end.7
  %28 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call13 = call i64 @Perl_sv_2iv(%struct.sv* %28)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %27, %cond.true ], [ %call13, %cond.false ]
  store i64 %cond, i64* %right8, align 8
  %29 = load %struct.sv**, %struct.sv*** %sp, align 8
  %30 = load %struct.sv*, %struct.sv** %29, align 8
  %sv_flags15 = getelementptr inbounds %struct.sv, %struct.sv* %30, i32 0, i32 2
  %31 = load i32, i32* %sv_flags15, align 4
  %and16 = and i32 %31, 65536
  %tobool17 = icmp ne i32 %and16, 0
  br i1 %tobool17, label %cond.true.18, label %cond.false.21

cond.true.18:                                     ; preds = %cond.end
  %32 = load %struct.sv**, %struct.sv*** %sp, align 8
  %33 = load %struct.sv*, %struct.sv** %32, align 8
  %sv_any19 = getelementptr inbounds %struct.sv, %struct.sv* %33, i32 0, i32 0
  %34 = load i8*, i8** %sv_any19, align 8
  %35 = bitcast i8* %34 to %struct.xpviv*
  %xiv_iv20 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %35, i32 0, i32 3
  %36 = load i64, i64* %xiv_iv20, align 8
  br label %cond.end.23

cond.false.21:                                    ; preds = %cond.end
  %37 = load %struct.sv**, %struct.sv*** %sp, align 8
  %38 = load %struct.sv*, %struct.sv** %37, align 8
  %call22 = call i64 @Perl_sv_2iv(%struct.sv* %38)
  br label %cond.end.23

cond.end.23:                                      ; preds = %cond.false.21, %cond.true.18
  %cond24 = phi i64 [ %36, %cond.true.18 ], [ %call22, %cond.false.21 ]
  store i64 %cond24, i64* %left14, align 8
  %39 = load i64, i64* %left14, align 8
  %40 = load i64, i64* %right8, align 8
  %cmp = icmp slt i64 %39, %40
  %cond25 = select i1 %cmp, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  %41 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %cond25, %struct.sv** %41, align 8
  %42 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %42, %struct.sv*** @PL_stack_sp, align 8
  %43 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next26 = getelementptr inbounds %struct.op, %struct.op* %43, i32 0, i32 0
  %44 = load %struct.op*, %struct.op** %op_next26, align 8
  store %struct.op* %44, %struct.op** %retval
  br label %return

return:                                           ; preds = %cond.end.23, %if.then.6
  %45 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %45
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_i_gt() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %right = alloca %struct.sv*, align 8
  %left = alloca %struct.sv*, align 8
  %right8 = alloca i64, align 8
  %left14 = alloca i64, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load i64, i64* @PL_amagic_generation, align 8
  %tobool = icmp ne i64 %1, 0
  br i1 %tobool, label %if.then, label %if.end.7

if.then:                                          ; preds = %entry
  %2 = load %struct.sv**, %struct.sv*** %sp, align 8
  %3 = load %struct.sv*, %struct.sv** %2, align 8
  store %struct.sv* %3, %struct.sv** %right, align 8
  %4 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %4, i64 -1
  %5 = load %struct.sv*, %struct.sv** %add.ptr, align 8
  store %struct.sv* %5, %struct.sv** %left, align 8
  %6 = load %struct.sv*, %struct.sv** %left, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %6, i32 0, i32 2
  %7 = load i32, i32* %sv_flags, align 4
  %and = and i32 %7, 268435456
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %8 = load %struct.sv*, %struct.sv** %right, align 8
  %sv_flags2 = getelementptr inbounds %struct.sv, %struct.sv* %8, i32 0, i32 2
  %9 = load i32, i32* %sv_flags2, align 4
  %and3 = and i32 %9, 268435456
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %10 = load %struct.sv*, %struct.sv** %left, align 8
  %11 = load %struct.sv*, %struct.sv** %right, align 8
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %10, %struct.sv* %11, i32 30, i32 0)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool5 = icmp ne %struct.sv* %call, null
  br i1 %tobool5, label %if.then.6, label %if.end

if.then.6:                                        ; preds = %land.lhs.true
  %12 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %12, %struct.sv*** %sp, align 8
  %13 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %13, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %14 = load %struct.sv*, %struct.sv** %13, align 8
  %15 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %16 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %15, %struct.sv** %16, align 8
  %17 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %17, %struct.sv*** @PL_stack_sp, align 8
  %18 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %18, i32 0, i32 0
  %19 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %19, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %land.lhs.true, %lor.lhs.false
  br label %if.end.7

if.end.7:                                         ; preds = %if.end, %entry
  %20 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr9 = getelementptr inbounds %struct.sv*, %struct.sv** %20, i32 -1
  store %struct.sv** %incdec.ptr9, %struct.sv*** %sp, align 8
  %21 = load %struct.sv*, %struct.sv** %20, align 8
  store %struct.sv* %21, %struct.sv** @PL_Sv, align 8
  %22 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags10 = getelementptr inbounds %struct.sv, %struct.sv* %22, i32 0, i32 2
  %23 = load i32, i32* %sv_flags10, align 4
  %and11 = and i32 %23, 65536
  %tobool12 = icmp ne i32 %and11, 0
  br i1 %tobool12, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.7
  %24 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %24, i32 0, i32 0
  %25 = load i8*, i8** %sv_any, align 8
  %26 = bitcast i8* %25 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %26, i32 0, i32 3
  %27 = load i64, i64* %xiv_iv, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end.7
  %28 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call13 = call i64 @Perl_sv_2iv(%struct.sv* %28)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %27, %cond.true ], [ %call13, %cond.false ]
  store i64 %cond, i64* %right8, align 8
  %29 = load %struct.sv**, %struct.sv*** %sp, align 8
  %30 = load %struct.sv*, %struct.sv** %29, align 8
  %sv_flags15 = getelementptr inbounds %struct.sv, %struct.sv* %30, i32 0, i32 2
  %31 = load i32, i32* %sv_flags15, align 4
  %and16 = and i32 %31, 65536
  %tobool17 = icmp ne i32 %and16, 0
  br i1 %tobool17, label %cond.true.18, label %cond.false.21

cond.true.18:                                     ; preds = %cond.end
  %32 = load %struct.sv**, %struct.sv*** %sp, align 8
  %33 = load %struct.sv*, %struct.sv** %32, align 8
  %sv_any19 = getelementptr inbounds %struct.sv, %struct.sv* %33, i32 0, i32 0
  %34 = load i8*, i8** %sv_any19, align 8
  %35 = bitcast i8* %34 to %struct.xpviv*
  %xiv_iv20 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %35, i32 0, i32 3
  %36 = load i64, i64* %xiv_iv20, align 8
  br label %cond.end.23

cond.false.21:                                    ; preds = %cond.end
  %37 = load %struct.sv**, %struct.sv*** %sp, align 8
  %38 = load %struct.sv*, %struct.sv** %37, align 8
  %call22 = call i64 @Perl_sv_2iv(%struct.sv* %38)
  br label %cond.end.23

cond.end.23:                                      ; preds = %cond.false.21, %cond.true.18
  %cond24 = phi i64 [ %36, %cond.true.18 ], [ %call22, %cond.false.21 ]
  store i64 %cond24, i64* %left14, align 8
  %39 = load i64, i64* %left14, align 8
  %40 = load i64, i64* %right8, align 8
  %cmp = icmp sgt i64 %39, %40
  %cond25 = select i1 %cmp, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  %41 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %cond25, %struct.sv** %41, align 8
  %42 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %42, %struct.sv*** @PL_stack_sp, align 8
  %43 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next26 = getelementptr inbounds %struct.op, %struct.op* %43, i32 0, i32 0
  %44 = load %struct.op*, %struct.op** %op_next26, align 8
  store %struct.op* %44, %struct.op** %retval
  br label %return

return:                                           ; preds = %cond.end.23, %if.then.6
  %45 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %45
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_i_le() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %right = alloca %struct.sv*, align 8
  %left = alloca %struct.sv*, align 8
  %right8 = alloca i64, align 8
  %left14 = alloca i64, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load i64, i64* @PL_amagic_generation, align 8
  %tobool = icmp ne i64 %1, 0
  br i1 %tobool, label %if.then, label %if.end.7

if.then:                                          ; preds = %entry
  %2 = load %struct.sv**, %struct.sv*** %sp, align 8
  %3 = load %struct.sv*, %struct.sv** %2, align 8
  store %struct.sv* %3, %struct.sv** %right, align 8
  %4 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %4, i64 -1
  %5 = load %struct.sv*, %struct.sv** %add.ptr, align 8
  store %struct.sv* %5, %struct.sv** %left, align 8
  %6 = load %struct.sv*, %struct.sv** %left, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %6, i32 0, i32 2
  %7 = load i32, i32* %sv_flags, align 4
  %and = and i32 %7, 268435456
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %8 = load %struct.sv*, %struct.sv** %right, align 8
  %sv_flags2 = getelementptr inbounds %struct.sv, %struct.sv* %8, i32 0, i32 2
  %9 = load i32, i32* %sv_flags2, align 4
  %and3 = and i32 %9, 268435456
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %10 = load %struct.sv*, %struct.sv** %left, align 8
  %11 = load %struct.sv*, %struct.sv** %right, align 8
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %10, %struct.sv* %11, i32 29, i32 0)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool5 = icmp ne %struct.sv* %call, null
  br i1 %tobool5, label %if.then.6, label %if.end

if.then.6:                                        ; preds = %land.lhs.true
  %12 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %12, %struct.sv*** %sp, align 8
  %13 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %13, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %14 = load %struct.sv*, %struct.sv** %13, align 8
  %15 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %16 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %15, %struct.sv** %16, align 8
  %17 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %17, %struct.sv*** @PL_stack_sp, align 8
  %18 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %18, i32 0, i32 0
  %19 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %19, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %land.lhs.true, %lor.lhs.false
  br label %if.end.7

if.end.7:                                         ; preds = %if.end, %entry
  %20 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr9 = getelementptr inbounds %struct.sv*, %struct.sv** %20, i32 -1
  store %struct.sv** %incdec.ptr9, %struct.sv*** %sp, align 8
  %21 = load %struct.sv*, %struct.sv** %20, align 8
  store %struct.sv* %21, %struct.sv** @PL_Sv, align 8
  %22 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags10 = getelementptr inbounds %struct.sv, %struct.sv* %22, i32 0, i32 2
  %23 = load i32, i32* %sv_flags10, align 4
  %and11 = and i32 %23, 65536
  %tobool12 = icmp ne i32 %and11, 0
  br i1 %tobool12, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.7
  %24 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %24, i32 0, i32 0
  %25 = load i8*, i8** %sv_any, align 8
  %26 = bitcast i8* %25 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %26, i32 0, i32 3
  %27 = load i64, i64* %xiv_iv, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end.7
  %28 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call13 = call i64 @Perl_sv_2iv(%struct.sv* %28)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %27, %cond.true ], [ %call13, %cond.false ]
  store i64 %cond, i64* %right8, align 8
  %29 = load %struct.sv**, %struct.sv*** %sp, align 8
  %30 = load %struct.sv*, %struct.sv** %29, align 8
  %sv_flags15 = getelementptr inbounds %struct.sv, %struct.sv* %30, i32 0, i32 2
  %31 = load i32, i32* %sv_flags15, align 4
  %and16 = and i32 %31, 65536
  %tobool17 = icmp ne i32 %and16, 0
  br i1 %tobool17, label %cond.true.18, label %cond.false.21

cond.true.18:                                     ; preds = %cond.end
  %32 = load %struct.sv**, %struct.sv*** %sp, align 8
  %33 = load %struct.sv*, %struct.sv** %32, align 8
  %sv_any19 = getelementptr inbounds %struct.sv, %struct.sv* %33, i32 0, i32 0
  %34 = load i8*, i8** %sv_any19, align 8
  %35 = bitcast i8* %34 to %struct.xpviv*
  %xiv_iv20 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %35, i32 0, i32 3
  %36 = load i64, i64* %xiv_iv20, align 8
  br label %cond.end.23

cond.false.21:                                    ; preds = %cond.end
  %37 = load %struct.sv**, %struct.sv*** %sp, align 8
  %38 = load %struct.sv*, %struct.sv** %37, align 8
  %call22 = call i64 @Perl_sv_2iv(%struct.sv* %38)
  br label %cond.end.23

cond.end.23:                                      ; preds = %cond.false.21, %cond.true.18
  %cond24 = phi i64 [ %36, %cond.true.18 ], [ %call22, %cond.false.21 ]
  store i64 %cond24, i64* %left14, align 8
  %39 = load i64, i64* %left14, align 8
  %40 = load i64, i64* %right8, align 8
  %cmp = icmp sle i64 %39, %40
  %cond25 = select i1 %cmp, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  %41 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %cond25, %struct.sv** %41, align 8
  %42 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %42, %struct.sv*** @PL_stack_sp, align 8
  %43 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next26 = getelementptr inbounds %struct.op, %struct.op* %43, i32 0, i32 0
  %44 = load %struct.op*, %struct.op** %op_next26, align 8
  store %struct.op* %44, %struct.op** %retval
  br label %return

return:                                           ; preds = %cond.end.23, %if.then.6
  %45 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %45
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_i_ge() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %right = alloca %struct.sv*, align 8
  %left = alloca %struct.sv*, align 8
  %right8 = alloca i64, align 8
  %left14 = alloca i64, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load i64, i64* @PL_amagic_generation, align 8
  %tobool = icmp ne i64 %1, 0
  br i1 %tobool, label %if.then, label %if.end.7

if.then:                                          ; preds = %entry
  %2 = load %struct.sv**, %struct.sv*** %sp, align 8
  %3 = load %struct.sv*, %struct.sv** %2, align 8
  store %struct.sv* %3, %struct.sv** %right, align 8
  %4 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %4, i64 -1
  %5 = load %struct.sv*, %struct.sv** %add.ptr, align 8
  store %struct.sv* %5, %struct.sv** %left, align 8
  %6 = load %struct.sv*, %struct.sv** %left, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %6, i32 0, i32 2
  %7 = load i32, i32* %sv_flags, align 4
  %and = and i32 %7, 268435456
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %8 = load %struct.sv*, %struct.sv** %right, align 8
  %sv_flags2 = getelementptr inbounds %struct.sv, %struct.sv* %8, i32 0, i32 2
  %9 = load i32, i32* %sv_flags2, align 4
  %and3 = and i32 %9, 268435456
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %10 = load %struct.sv*, %struct.sv** %left, align 8
  %11 = load %struct.sv*, %struct.sv** %right, align 8
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %10, %struct.sv* %11, i32 31, i32 0)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool5 = icmp ne %struct.sv* %call, null
  br i1 %tobool5, label %if.then.6, label %if.end

if.then.6:                                        ; preds = %land.lhs.true
  %12 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %12, %struct.sv*** %sp, align 8
  %13 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %13, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %14 = load %struct.sv*, %struct.sv** %13, align 8
  %15 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %16 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %15, %struct.sv** %16, align 8
  %17 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %17, %struct.sv*** @PL_stack_sp, align 8
  %18 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %18, i32 0, i32 0
  %19 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %19, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %land.lhs.true, %lor.lhs.false
  br label %if.end.7

if.end.7:                                         ; preds = %if.end, %entry
  %20 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr9 = getelementptr inbounds %struct.sv*, %struct.sv** %20, i32 -1
  store %struct.sv** %incdec.ptr9, %struct.sv*** %sp, align 8
  %21 = load %struct.sv*, %struct.sv** %20, align 8
  store %struct.sv* %21, %struct.sv** @PL_Sv, align 8
  %22 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags10 = getelementptr inbounds %struct.sv, %struct.sv* %22, i32 0, i32 2
  %23 = load i32, i32* %sv_flags10, align 4
  %and11 = and i32 %23, 65536
  %tobool12 = icmp ne i32 %and11, 0
  br i1 %tobool12, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.7
  %24 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %24, i32 0, i32 0
  %25 = load i8*, i8** %sv_any, align 8
  %26 = bitcast i8* %25 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %26, i32 0, i32 3
  %27 = load i64, i64* %xiv_iv, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end.7
  %28 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call13 = call i64 @Perl_sv_2iv(%struct.sv* %28)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %27, %cond.true ], [ %call13, %cond.false ]
  store i64 %cond, i64* %right8, align 8
  %29 = load %struct.sv**, %struct.sv*** %sp, align 8
  %30 = load %struct.sv*, %struct.sv** %29, align 8
  %sv_flags15 = getelementptr inbounds %struct.sv, %struct.sv* %30, i32 0, i32 2
  %31 = load i32, i32* %sv_flags15, align 4
  %and16 = and i32 %31, 65536
  %tobool17 = icmp ne i32 %and16, 0
  br i1 %tobool17, label %cond.true.18, label %cond.false.21

cond.true.18:                                     ; preds = %cond.end
  %32 = load %struct.sv**, %struct.sv*** %sp, align 8
  %33 = load %struct.sv*, %struct.sv** %32, align 8
  %sv_any19 = getelementptr inbounds %struct.sv, %struct.sv* %33, i32 0, i32 0
  %34 = load i8*, i8** %sv_any19, align 8
  %35 = bitcast i8* %34 to %struct.xpviv*
  %xiv_iv20 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %35, i32 0, i32 3
  %36 = load i64, i64* %xiv_iv20, align 8
  br label %cond.end.23

cond.false.21:                                    ; preds = %cond.end
  %37 = load %struct.sv**, %struct.sv*** %sp, align 8
  %38 = load %struct.sv*, %struct.sv** %37, align 8
  %call22 = call i64 @Perl_sv_2iv(%struct.sv* %38)
  br label %cond.end.23

cond.end.23:                                      ; preds = %cond.false.21, %cond.true.18
  %cond24 = phi i64 [ %36, %cond.true.18 ], [ %call22, %cond.false.21 ]
  store i64 %cond24, i64* %left14, align 8
  %39 = load i64, i64* %left14, align 8
  %40 = load i64, i64* %right8, align 8
  %cmp = icmp sge i64 %39, %40
  %cond25 = select i1 %cmp, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  %41 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %cond25, %struct.sv** %41, align 8
  %42 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %42, %struct.sv*** @PL_stack_sp, align 8
  %43 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next26 = getelementptr inbounds %struct.op, %struct.op* %43, i32 0, i32 0
  %44 = load %struct.op*, %struct.op** %op_next26, align 8
  store %struct.op* %44, %struct.op** %retval
  br label %return

return:                                           ; preds = %cond.end.23, %if.then.6
  %45 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %45
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_i_eq() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %right = alloca %struct.sv*, align 8
  %left = alloca %struct.sv*, align 8
  %right8 = alloca i64, align 8
  %left14 = alloca i64, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load i64, i64* @PL_amagic_generation, align 8
  %tobool = icmp ne i64 %1, 0
  br i1 %tobool, label %if.then, label %if.end.7

if.then:                                          ; preds = %entry
  %2 = load %struct.sv**, %struct.sv*** %sp, align 8
  %3 = load %struct.sv*, %struct.sv** %2, align 8
  store %struct.sv* %3, %struct.sv** %right, align 8
  %4 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %4, i64 -1
  %5 = load %struct.sv*, %struct.sv** %add.ptr, align 8
  store %struct.sv* %5, %struct.sv** %left, align 8
  %6 = load %struct.sv*, %struct.sv** %left, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %6, i32 0, i32 2
  %7 = load i32, i32* %sv_flags, align 4
  %and = and i32 %7, 268435456
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %8 = load %struct.sv*, %struct.sv** %right, align 8
  %sv_flags2 = getelementptr inbounds %struct.sv, %struct.sv* %8, i32 0, i32 2
  %9 = load i32, i32* %sv_flags2, align 4
  %and3 = and i32 %9, 268435456
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %10 = load %struct.sv*, %struct.sv** %left, align 8
  %11 = load %struct.sv*, %struct.sv** %right, align 8
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %10, %struct.sv* %11, i32 32, i32 0)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool5 = icmp ne %struct.sv* %call, null
  br i1 %tobool5, label %if.then.6, label %if.end

if.then.6:                                        ; preds = %land.lhs.true
  %12 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %12, %struct.sv*** %sp, align 8
  %13 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %13, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %14 = load %struct.sv*, %struct.sv** %13, align 8
  %15 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %16 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %15, %struct.sv** %16, align 8
  %17 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %17, %struct.sv*** @PL_stack_sp, align 8
  %18 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %18, i32 0, i32 0
  %19 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %19, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %land.lhs.true, %lor.lhs.false
  br label %if.end.7

if.end.7:                                         ; preds = %if.end, %entry
  %20 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr9 = getelementptr inbounds %struct.sv*, %struct.sv** %20, i32 -1
  store %struct.sv** %incdec.ptr9, %struct.sv*** %sp, align 8
  %21 = load %struct.sv*, %struct.sv** %20, align 8
  store %struct.sv* %21, %struct.sv** @PL_Sv, align 8
  %22 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags10 = getelementptr inbounds %struct.sv, %struct.sv* %22, i32 0, i32 2
  %23 = load i32, i32* %sv_flags10, align 4
  %and11 = and i32 %23, 65536
  %tobool12 = icmp ne i32 %and11, 0
  br i1 %tobool12, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.7
  %24 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %24, i32 0, i32 0
  %25 = load i8*, i8** %sv_any, align 8
  %26 = bitcast i8* %25 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %26, i32 0, i32 3
  %27 = load i64, i64* %xiv_iv, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end.7
  %28 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call13 = call i64 @Perl_sv_2iv(%struct.sv* %28)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %27, %cond.true ], [ %call13, %cond.false ]
  store i64 %cond, i64* %right8, align 8
  %29 = load %struct.sv**, %struct.sv*** %sp, align 8
  %30 = load %struct.sv*, %struct.sv** %29, align 8
  %sv_flags15 = getelementptr inbounds %struct.sv, %struct.sv* %30, i32 0, i32 2
  %31 = load i32, i32* %sv_flags15, align 4
  %and16 = and i32 %31, 65536
  %tobool17 = icmp ne i32 %and16, 0
  br i1 %tobool17, label %cond.true.18, label %cond.false.21

cond.true.18:                                     ; preds = %cond.end
  %32 = load %struct.sv**, %struct.sv*** %sp, align 8
  %33 = load %struct.sv*, %struct.sv** %32, align 8
  %sv_any19 = getelementptr inbounds %struct.sv, %struct.sv* %33, i32 0, i32 0
  %34 = load i8*, i8** %sv_any19, align 8
  %35 = bitcast i8* %34 to %struct.xpviv*
  %xiv_iv20 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %35, i32 0, i32 3
  %36 = load i64, i64* %xiv_iv20, align 8
  br label %cond.end.23

cond.false.21:                                    ; preds = %cond.end
  %37 = load %struct.sv**, %struct.sv*** %sp, align 8
  %38 = load %struct.sv*, %struct.sv** %37, align 8
  %call22 = call i64 @Perl_sv_2iv(%struct.sv* %38)
  br label %cond.end.23

cond.end.23:                                      ; preds = %cond.false.21, %cond.true.18
  %cond24 = phi i64 [ %36, %cond.true.18 ], [ %call22, %cond.false.21 ]
  store i64 %cond24, i64* %left14, align 8
  %39 = load i64, i64* %left14, align 8
  %40 = load i64, i64* %right8, align 8
  %cmp = icmp eq i64 %39, %40
  %cond25 = select i1 %cmp, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  %41 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %cond25, %struct.sv** %41, align 8
  %42 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %42, %struct.sv*** @PL_stack_sp, align 8
  %43 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next26 = getelementptr inbounds %struct.op, %struct.op* %43, i32 0, i32 0
  %44 = load %struct.op*, %struct.op** %op_next26, align 8
  store %struct.op* %44, %struct.op** %retval
  br label %return

return:                                           ; preds = %cond.end.23, %if.then.6
  %45 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %45
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_i_ne() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %right = alloca %struct.sv*, align 8
  %left = alloca %struct.sv*, align 8
  %right8 = alloca i64, align 8
  %left14 = alloca i64, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load i64, i64* @PL_amagic_generation, align 8
  %tobool = icmp ne i64 %1, 0
  br i1 %tobool, label %if.then, label %if.end.7

if.then:                                          ; preds = %entry
  %2 = load %struct.sv**, %struct.sv*** %sp, align 8
  %3 = load %struct.sv*, %struct.sv** %2, align 8
  store %struct.sv* %3, %struct.sv** %right, align 8
  %4 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %4, i64 -1
  %5 = load %struct.sv*, %struct.sv** %add.ptr, align 8
  store %struct.sv* %5, %struct.sv** %left, align 8
  %6 = load %struct.sv*, %struct.sv** %left, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %6, i32 0, i32 2
  %7 = load i32, i32* %sv_flags, align 4
  %and = and i32 %7, 268435456
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %8 = load %struct.sv*, %struct.sv** %right, align 8
  %sv_flags2 = getelementptr inbounds %struct.sv, %struct.sv* %8, i32 0, i32 2
  %9 = load i32, i32* %sv_flags2, align 4
  %and3 = and i32 %9, 268435456
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %10 = load %struct.sv*, %struct.sv** %left, align 8
  %11 = load %struct.sv*, %struct.sv** %right, align 8
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %10, %struct.sv* %11, i32 33, i32 0)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool5 = icmp ne %struct.sv* %call, null
  br i1 %tobool5, label %if.then.6, label %if.end

if.then.6:                                        ; preds = %land.lhs.true
  %12 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %12, %struct.sv*** %sp, align 8
  %13 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %13, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %14 = load %struct.sv*, %struct.sv** %13, align 8
  %15 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %16 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %15, %struct.sv** %16, align 8
  %17 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %17, %struct.sv*** @PL_stack_sp, align 8
  %18 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %18, i32 0, i32 0
  %19 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %19, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %land.lhs.true, %lor.lhs.false
  br label %if.end.7

if.end.7:                                         ; preds = %if.end, %entry
  %20 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr9 = getelementptr inbounds %struct.sv*, %struct.sv** %20, i32 -1
  store %struct.sv** %incdec.ptr9, %struct.sv*** %sp, align 8
  %21 = load %struct.sv*, %struct.sv** %20, align 8
  store %struct.sv* %21, %struct.sv** @PL_Sv, align 8
  %22 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags10 = getelementptr inbounds %struct.sv, %struct.sv* %22, i32 0, i32 2
  %23 = load i32, i32* %sv_flags10, align 4
  %and11 = and i32 %23, 65536
  %tobool12 = icmp ne i32 %and11, 0
  br i1 %tobool12, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.7
  %24 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %24, i32 0, i32 0
  %25 = load i8*, i8** %sv_any, align 8
  %26 = bitcast i8* %25 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %26, i32 0, i32 3
  %27 = load i64, i64* %xiv_iv, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end.7
  %28 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call13 = call i64 @Perl_sv_2iv(%struct.sv* %28)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %27, %cond.true ], [ %call13, %cond.false ]
  store i64 %cond, i64* %right8, align 8
  %29 = load %struct.sv**, %struct.sv*** %sp, align 8
  %30 = load %struct.sv*, %struct.sv** %29, align 8
  %sv_flags15 = getelementptr inbounds %struct.sv, %struct.sv* %30, i32 0, i32 2
  %31 = load i32, i32* %sv_flags15, align 4
  %and16 = and i32 %31, 65536
  %tobool17 = icmp ne i32 %and16, 0
  br i1 %tobool17, label %cond.true.18, label %cond.false.21

cond.true.18:                                     ; preds = %cond.end
  %32 = load %struct.sv**, %struct.sv*** %sp, align 8
  %33 = load %struct.sv*, %struct.sv** %32, align 8
  %sv_any19 = getelementptr inbounds %struct.sv, %struct.sv* %33, i32 0, i32 0
  %34 = load i8*, i8** %sv_any19, align 8
  %35 = bitcast i8* %34 to %struct.xpviv*
  %xiv_iv20 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %35, i32 0, i32 3
  %36 = load i64, i64* %xiv_iv20, align 8
  br label %cond.end.23

cond.false.21:                                    ; preds = %cond.end
  %37 = load %struct.sv**, %struct.sv*** %sp, align 8
  %38 = load %struct.sv*, %struct.sv** %37, align 8
  %call22 = call i64 @Perl_sv_2iv(%struct.sv* %38)
  br label %cond.end.23

cond.end.23:                                      ; preds = %cond.false.21, %cond.true.18
  %cond24 = phi i64 [ %36, %cond.true.18 ], [ %call22, %cond.false.21 ]
  store i64 %cond24, i64* %left14, align 8
  %39 = load i64, i64* %left14, align 8
  %40 = load i64, i64* %right8, align 8
  %cmp = icmp ne i64 %39, %40
  %cond25 = select i1 %cmp, %struct.sv* @PL_sv_yes, %struct.sv* @PL_sv_no
  %41 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %cond25, %struct.sv** %41, align 8
  %42 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %42, %struct.sv*** @PL_stack_sp, align 8
  %43 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next26 = getelementptr inbounds %struct.op, %struct.op* %43, i32 0, i32 0
  %44 = load %struct.op*, %struct.op** %op_next26, align 8
  store %struct.op* %44, %struct.op** %retval
  br label %return

return:                                           ; preds = %cond.end.23, %if.then.6
  %45 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %45
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_i_ncmp() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %right = alloca %struct.sv*, align 8
  %left = alloca %struct.sv*, align 8
  %tmp = alloca %struct.sv*, align 8
  %right23 = alloca i64, align 8
  %left30 = alloca i64, align 8
  %value = alloca i32, align 4
  %tmp58 = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 3
  %2 = load i64, i64* %op_targ, align 8
  %3 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 %2
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %4, %struct.sv** %targ, align 8
  %5 = load i64, i64* @PL_amagic_generation, align 8
  %tobool = icmp ne i64 %5, 0
  br i1 %tobool, label %if.then, label %if.end.21

if.then:                                          ; preds = %entry
  %6 = load %struct.sv**, %struct.sv*** %sp, align 8
  %7 = load %struct.sv*, %struct.sv** %6, align 8
  store %struct.sv* %7, %struct.sv** %right, align 8
  %8 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %8, i64 -1
  %9 = load %struct.sv*, %struct.sv** %add.ptr, align 8
  store %struct.sv* %9, %struct.sv** %left, align 8
  %10 = load %struct.sv*, %struct.sv** %left, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %10, i32 0, i32 2
  %11 = load i32, i32* %sv_flags, align 4
  %and = and i32 %11, 268435456
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %12 = load %struct.sv*, %struct.sv** %right, align 8
  %sv_flags2 = getelementptr inbounds %struct.sv, %struct.sv* %12, i32 0, i32 2
  %13 = load i32, i32* %sv_flags2, align 4
  %and3 = and i32 %13, 268435456
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %land.lhs.true, label %if.end.20

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %14 = load %struct.sv*, %struct.sv** %left, align 8
  %15 = load %struct.sv*, %struct.sv** %right, align 8
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %14, %struct.sv* %15, i32 34, i32 0)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool5 = icmp ne %struct.sv* %call, null
  br i1 %tobool5, label %if.then.6, label %if.end.20

if.then.6:                                        ; preds = %land.lhs.true
  %16 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %16, %struct.sv*** %sp, align 8
  %17 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %17, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %18 = load %struct.sv*, %struct.sv** %17, align 8
  %19 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %19, i32 0, i32 6
  %20 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %20 to i32
  %and7 = and i32 %conv, 64
  %tobool8 = icmp ne i32 %and7, 0
  br i1 %tobool8, label %if.then.13, label %lor.lhs.false.9

lor.lhs.false.9:                                  ; preds = %if.then.6
  %21 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags10 = getelementptr inbounds %struct.sv, %struct.sv* %21, i32 0, i32 2
  %22 = load i32, i32* %sv_flags10, align 4
  %and11 = and i32 %22, 1024
  %tobool12 = icmp ne i32 %and11, 0
  br i1 %tobool12, label %if.then.13, label %if.else

if.then.13:                                       ; preds = %lor.lhs.false.9, %if.then.6
  %23 = load %struct.sv*, %struct.sv** %targ, align 8
  %24 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  call void @Perl_sv_setsv_flags(%struct.sv* %23, %struct.sv* %24, i32 2)
  %25 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags14 = getelementptr inbounds %struct.sv, %struct.sv* %25, i32 0, i32 2
  %26 = load i32, i32* %sv_flags14, align 4
  %and15 = and i32 %26, 16384
  %tobool16 = icmp ne i32 %and15, 0
  br i1 %tobool16, label %if.then.17, label %if.end

if.then.17:                                       ; preds = %if.then.13
  %27 = load %struct.sv*, %struct.sv** %targ, align 8
  %call18 = call i32 @Perl_mg_set(%struct.sv* %27)
  br label %if.end

if.end:                                           ; preds = %if.then.17, %if.then.13
  %28 = load %struct.sv*, %struct.sv** %targ, align 8
  %29 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %28, %struct.sv** %29, align 8
  store %struct.sv* %28, %struct.sv** %tmp
  %30 = load %struct.sv*, %struct.sv** %tmp
  br label %if.end.19

if.else:                                          ; preds = %lor.lhs.false.9
  %31 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %32 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %31, %struct.sv** %32, align 8
  br label %if.end.19

if.end.19:                                        ; preds = %if.else, %if.end
  %33 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %33, %struct.sv*** @PL_stack_sp, align 8
  %34 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %34, i32 0, i32 0
  %35 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %35, %struct.op** %retval
  br label %return

if.end.20:                                        ; preds = %land.lhs.true, %lor.lhs.false
  br label %if.end.21

if.end.21:                                        ; preds = %if.end.20, %entry
  %36 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr24 = getelementptr inbounds %struct.sv*, %struct.sv** %36, i32 -1
  store %struct.sv** %incdec.ptr24, %struct.sv*** %sp, align 8
  %37 = load %struct.sv*, %struct.sv** %36, align 8
  store %struct.sv* %37, %struct.sv** @PL_Sv, align 8
  %38 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags25 = getelementptr inbounds %struct.sv, %struct.sv* %38, i32 0, i32 2
  %39 = load i32, i32* %sv_flags25, align 4
  %and26 = and i32 %39, 65536
  %tobool27 = icmp ne i32 %and26, 0
  br i1 %tobool27, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.21
  %40 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %40, i32 0, i32 0
  %41 = load i8*, i8** %sv_any, align 8
  %42 = bitcast i8* %41 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %42, i32 0, i32 3
  %43 = load i64, i64* %xiv_iv, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end.21
  %44 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call28 = call i64 @Perl_sv_2iv(%struct.sv* %44)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %43, %cond.true ], [ %call28, %cond.false ]
  store i64 %cond, i64* %right23, align 8
  %45 = load %struct.sv**, %struct.sv*** %sp, align 8
  %46 = load %struct.sv*, %struct.sv** %45, align 8
  %sv_flags31 = getelementptr inbounds %struct.sv, %struct.sv* %46, i32 0, i32 2
  %47 = load i32, i32* %sv_flags31, align 4
  %and32 = and i32 %47, 65536
  %tobool33 = icmp ne i32 %and32, 0
  br i1 %tobool33, label %cond.true.34, label %cond.false.37

cond.true.34:                                     ; preds = %cond.end
  %48 = load %struct.sv**, %struct.sv*** %sp, align 8
  %49 = load %struct.sv*, %struct.sv** %48, align 8
  %sv_any35 = getelementptr inbounds %struct.sv, %struct.sv* %49, i32 0, i32 0
  %50 = load i8*, i8** %sv_any35, align 8
  %51 = bitcast i8* %50 to %struct.xpviv*
  %xiv_iv36 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %51, i32 0, i32 3
  %52 = load i64, i64* %xiv_iv36, align 8
  br label %cond.end.39

cond.false.37:                                    ; preds = %cond.end
  %53 = load %struct.sv**, %struct.sv*** %sp, align 8
  %54 = load %struct.sv*, %struct.sv** %53, align 8
  %call38 = call i64 @Perl_sv_2iv(%struct.sv* %54)
  br label %cond.end.39

cond.end.39:                                      ; preds = %cond.false.37, %cond.true.34
  %cond40 = phi i64 [ %52, %cond.true.34 ], [ %call38, %cond.false.37 ]
  store i64 %cond40, i64* %left30, align 8
  %55 = load i64, i64* %left30, align 8
  %56 = load i64, i64* %right23, align 8
  %cmp = icmp sgt i64 %55, %56
  br i1 %cmp, label %if.then.43, label %if.else.44

if.then.43:                                       ; preds = %cond.end.39
  store i32 1, i32* %value, align 4
  br label %if.end.50

if.else.44:                                       ; preds = %cond.end.39
  %57 = load i64, i64* %left30, align 8
  %58 = load i64, i64* %right23, align 8
  %cmp45 = icmp slt i64 %57, %58
  br i1 %cmp45, label %if.then.47, label %if.else.48

if.then.47:                                       ; preds = %if.else.44
  store i32 -1, i32* %value, align 4
  br label %if.end.49

if.else.48:                                       ; preds = %if.else.44
  store i32 0, i32* %value, align 4
  br label %if.end.49

if.end.49:                                        ; preds = %if.else.48, %if.then.47
  br label %if.end.50

if.end.50:                                        ; preds = %if.end.49, %if.then.43
  %59 = load %struct.sv*, %struct.sv** %targ, align 8
  %60 = load i32, i32* %value, align 4
  %conv51 = sext i32 %60 to i64
  call void @Perl_sv_setiv(%struct.sv* %59, i64 %conv51)
  %61 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags52 = getelementptr inbounds %struct.sv, %struct.sv* %61, i32 0, i32 2
  %62 = load i32, i32* %sv_flags52, align 4
  %and53 = and i32 %62, 16384
  %tobool54 = icmp ne i32 %and53, 0
  br i1 %tobool54, label %if.then.55, label %if.end.57

if.then.55:                                       ; preds = %if.end.50
  %63 = load %struct.sv*, %struct.sv** %targ, align 8
  %call56 = call i32 @Perl_mg_set(%struct.sv* %63)
  br label %if.end.57

if.end.57:                                        ; preds = %if.then.55, %if.end.50
  %64 = load %struct.sv*, %struct.sv** %targ, align 8
  %65 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %64, %struct.sv** %65, align 8
  store %struct.sv* %64, %struct.sv** %tmp58
  %66 = load %struct.sv*, %struct.sv** %tmp58
  %67 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %67, %struct.sv*** @PL_stack_sp, align 8
  %68 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next59 = getelementptr inbounds %struct.op, %struct.op* %68, i32 0, i32 0
  %69 = load %struct.op*, %struct.op** %op_next59, align 8
  store %struct.op* %69, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.57, %if.end.19
  %70 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %70
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_i_negate() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %arg = alloca %struct.sv*, align 8
  %tmp = alloca %struct.sv*, align 8
  %tmp27 = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 3
  %2 = load i64, i64* %op_targ, align 8
  %3 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 %2
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %4, %struct.sv** %targ, align 8
  %5 = load i64, i64* @PL_amagic_generation, align 8
  %tobool = icmp ne i64 %5, 0
  br i1 %tobool, label %if.then, label %if.end.16

if.then:                                          ; preds = %entry
  %6 = load %struct.sv**, %struct.sv*** %sp, align 8
  %arrayidx1 = getelementptr inbounds %struct.sv*, %struct.sv** %6, i64 0
  %7 = load %struct.sv*, %struct.sv** %arrayidx1, align 8
  store %struct.sv* %7, %struct.sv** %arg, align 8
  br label %am_again

am_again:                                         ; preds = %if.then
  %8 = load %struct.sv*, %struct.sv** %arg, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %8, i32 0, i32 2
  %9 = load i32, i32* %sv_flags, align 4
  %and = and i32 %9, 268435456
  %tobool2 = icmp ne i32 %and, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end.15

land.lhs.true:                                    ; preds = %am_again
  %10 = load %struct.sv*, %struct.sv** %arg, align 8
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %10, %struct.sv* @PL_sv_undef, i32 57, i32 9)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool3 = icmp ne %struct.sv* %call, null
  br i1 %tobool3, label %if.then.4, label %if.end.15

if.then.4:                                        ; preds = %land.lhs.true
  %11 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %11, %struct.sv*** %sp, align 8
  %12 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags5 = getelementptr inbounds %struct.sv, %struct.sv* %12, i32 0, i32 2
  %13 = load i32, i32* %sv_flags5, align 4
  %and6 = and i32 %13, 1024
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %if.then.8, label %if.else

if.then.8:                                        ; preds = %if.then.4
  %14 = load %struct.sv*, %struct.sv** %targ, align 8
  %15 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  call void @Perl_sv_setsv_flags(%struct.sv* %14, %struct.sv* %15, i32 2)
  %16 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags9 = getelementptr inbounds %struct.sv, %struct.sv* %16, i32 0, i32 2
  %17 = load i32, i32* %sv_flags9, align 4
  %and10 = and i32 %17, 16384
  %tobool11 = icmp ne i32 %and10, 0
  br i1 %tobool11, label %if.then.12, label %if.end

if.then.12:                                       ; preds = %if.then.8
  %18 = load %struct.sv*, %struct.sv** %targ, align 8
  %call13 = call i32 @Perl_mg_set(%struct.sv* %18)
  br label %if.end

if.end:                                           ; preds = %if.then.12, %if.then.8
  %19 = load %struct.sv*, %struct.sv** %targ, align 8
  %20 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %19, %struct.sv** %20, align 8
  store %struct.sv* %19, %struct.sv** %tmp
  %21 = load %struct.sv*, %struct.sv** %tmp
  br label %if.end.14

if.else:                                          ; preds = %if.then.4
  %22 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %23 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %22, %struct.sv** %23, align 8
  br label %if.end.14

if.end.14:                                        ; preds = %if.else, %if.end
  %24 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %24, %struct.sv*** @PL_stack_sp, align 8
  %25 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %25, i32 0, i32 0
  %26 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %26, %struct.op** %retval
  br label %return

if.end.15:                                        ; preds = %land.lhs.true, %am_again
  br label %if.end.16

if.end.16:                                        ; preds = %if.end.15, %entry
  %27 = load %struct.sv*, %struct.sv** %targ, align 8
  %28 = load %struct.sv**, %struct.sv*** %sp, align 8
  %29 = load %struct.sv*, %struct.sv** %28, align 8
  %sv_flags17 = getelementptr inbounds %struct.sv, %struct.sv* %29, i32 0, i32 2
  %30 = load i32, i32* %sv_flags17, align 4
  %and18 = and i32 %30, 65536
  %tobool19 = icmp ne i32 %and18, 0
  br i1 %tobool19, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.16
  %31 = load %struct.sv**, %struct.sv*** %sp, align 8
  %32 = load %struct.sv*, %struct.sv** %31, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %32, i32 0, i32 0
  %33 = load i8*, i8** %sv_any, align 8
  %34 = bitcast i8* %33 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %34, i32 0, i32 3
  %35 = load i64, i64* %xiv_iv, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end.16
  %36 = load %struct.sv**, %struct.sv*** %sp, align 8
  %37 = load %struct.sv*, %struct.sv** %36, align 8
  %call20 = call i64 @Perl_sv_2iv(%struct.sv* %37)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %35, %cond.true ], [ %call20, %cond.false ]
  %sub = sub nsw i64 0, %cond
  call void @Perl_sv_setiv(%struct.sv* %27, i64 %sub)
  %38 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags21 = getelementptr inbounds %struct.sv, %struct.sv* %38, i32 0, i32 2
  %39 = load i32, i32* %sv_flags21, align 4
  %and22 = and i32 %39, 16384
  %tobool23 = icmp ne i32 %and22, 0
  br i1 %tobool23, label %if.then.24, label %if.end.26

if.then.24:                                       ; preds = %cond.end
  %40 = load %struct.sv*, %struct.sv** %targ, align 8
  %call25 = call i32 @Perl_mg_set(%struct.sv* %40)
  br label %if.end.26

if.end.26:                                        ; preds = %if.then.24, %cond.end
  %41 = load %struct.sv*, %struct.sv** %targ, align 8
  %42 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %41, %struct.sv** %42, align 8
  store %struct.sv* %41, %struct.sv** %tmp27
  %43 = load %struct.sv*, %struct.sv** %tmp27
  %44 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %44, %struct.sv*** @PL_stack_sp, align 8
  %45 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next28 = getelementptr inbounds %struct.op, %struct.op* %45, i32 0, i32 0
  %46 = load %struct.op*, %struct.op** %op_next28, align 8
  store %struct.op* %46, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.26, %if.end.14
  %47 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %47
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_atan2() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %right = alloca %struct.sv*, align 8
  %left = alloca %struct.sv*, align 8
  %tmp = alloca %struct.sv*, align 8
  %right23 = alloca double, align 8
  %left30 = alloca double, align 8
  %tmp48 = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 3
  %2 = load i64, i64* %op_targ, align 8
  %3 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 %2
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %4, %struct.sv** %targ, align 8
  %5 = load i64, i64* @PL_amagic_generation, align 8
  %tobool = icmp ne i64 %5, 0
  br i1 %tobool, label %if.then, label %if.end.21

if.then:                                          ; preds = %entry
  %6 = load %struct.sv**, %struct.sv*** %sp, align 8
  %7 = load %struct.sv*, %struct.sv** %6, align 8
  store %struct.sv* %7, %struct.sv** %right, align 8
  %8 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %8, i64 -1
  %9 = load %struct.sv*, %struct.sv** %add.ptr, align 8
  store %struct.sv* %9, %struct.sv** %left, align 8
  %10 = load %struct.sv*, %struct.sv** %left, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %10, i32 0, i32 2
  %11 = load i32, i32* %sv_flags, align 4
  %and = and i32 %11, 268435456
  %tobool1 = icmp ne i32 %and, 0
  br i1 %tobool1, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then
  %12 = load %struct.sv*, %struct.sv** %right, align 8
  %sv_flags2 = getelementptr inbounds %struct.sv, %struct.sv* %12, i32 0, i32 2
  %13 = load i32, i32* %sv_flags2, align 4
  %and3 = and i32 %13, 268435456
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %land.lhs.true, label %if.end.20

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.then
  %14 = load %struct.sv*, %struct.sv** %left, align 8
  %15 = load %struct.sv*, %struct.sv** %right, align 8
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %14, %struct.sv* %15, i32 46, i32 0)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool5 = icmp ne %struct.sv* %call, null
  br i1 %tobool5, label %if.then.6, label %if.end.20

if.then.6:                                        ; preds = %land.lhs.true
  %16 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %16, %struct.sv*** %sp, align 8
  %17 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %17, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %18 = load %struct.sv*, %struct.sv** %17, align 8
  %19 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %19, i32 0, i32 6
  %20 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %20 to i32
  %and7 = and i32 %conv, 64
  %tobool8 = icmp ne i32 %and7, 0
  br i1 %tobool8, label %if.then.13, label %lor.lhs.false.9

lor.lhs.false.9:                                  ; preds = %if.then.6
  %21 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags10 = getelementptr inbounds %struct.sv, %struct.sv* %21, i32 0, i32 2
  %22 = load i32, i32* %sv_flags10, align 4
  %and11 = and i32 %22, 1024
  %tobool12 = icmp ne i32 %and11, 0
  br i1 %tobool12, label %if.then.13, label %if.else

if.then.13:                                       ; preds = %lor.lhs.false.9, %if.then.6
  %23 = load %struct.sv*, %struct.sv** %targ, align 8
  %24 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  call void @Perl_sv_setsv_flags(%struct.sv* %23, %struct.sv* %24, i32 2)
  %25 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags14 = getelementptr inbounds %struct.sv, %struct.sv* %25, i32 0, i32 2
  %26 = load i32, i32* %sv_flags14, align 4
  %and15 = and i32 %26, 16384
  %tobool16 = icmp ne i32 %and15, 0
  br i1 %tobool16, label %if.then.17, label %if.end

if.then.17:                                       ; preds = %if.then.13
  %27 = load %struct.sv*, %struct.sv** %targ, align 8
  %call18 = call i32 @Perl_mg_set(%struct.sv* %27)
  br label %if.end

if.end:                                           ; preds = %if.then.17, %if.then.13
  %28 = load %struct.sv*, %struct.sv** %targ, align 8
  %29 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %28, %struct.sv** %29, align 8
  store %struct.sv* %28, %struct.sv** %tmp
  %30 = load %struct.sv*, %struct.sv** %tmp
  br label %if.end.19

if.else:                                          ; preds = %lor.lhs.false.9
  %31 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %32 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %31, %struct.sv** %32, align 8
  br label %if.end.19

if.end.19:                                        ; preds = %if.else, %if.end
  %33 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %33, %struct.sv*** @PL_stack_sp, align 8
  %34 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %34, i32 0, i32 0
  %35 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %35, %struct.op** %retval
  br label %return

if.end.20:                                        ; preds = %land.lhs.true, %lor.lhs.false
  br label %if.end.21

if.end.21:                                        ; preds = %if.end.20, %entry
  %36 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr24 = getelementptr inbounds %struct.sv*, %struct.sv** %36, i32 -1
  store %struct.sv** %incdec.ptr24, %struct.sv*** %sp, align 8
  %37 = load %struct.sv*, %struct.sv** %36, align 8
  store %struct.sv* %37, %struct.sv** @PL_Sv, align 8
  %38 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags25 = getelementptr inbounds %struct.sv, %struct.sv* %38, i32 0, i32 2
  %39 = load i32, i32* %sv_flags25, align 4
  %and26 = and i32 %39, 131072
  %tobool27 = icmp ne i32 %and26, 0
  br i1 %tobool27, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.21
  %40 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %40, i32 0, i32 0
  %41 = load i8*, i8** %sv_any, align 8
  %42 = bitcast i8* %41 to %struct.xpvnv*
  %xnv_nv = getelementptr inbounds %struct.xpvnv, %struct.xpvnv* %42, i32 0, i32 4
  %43 = load double, double* %xnv_nv, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end.21
  %44 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call28 = call double @Perl_sv_2nv(%struct.sv* %44)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi double [ %43, %cond.true ], [ %call28, %cond.false ]
  store double %cond, double* %right23, align 8
  %45 = load %struct.sv**, %struct.sv*** %sp, align 8
  %46 = load %struct.sv*, %struct.sv** %45, align 8
  %sv_flags31 = getelementptr inbounds %struct.sv, %struct.sv* %46, i32 0, i32 2
  %47 = load i32, i32* %sv_flags31, align 4
  %and32 = and i32 %47, 131072
  %tobool33 = icmp ne i32 %and32, 0
  br i1 %tobool33, label %cond.true.34, label %cond.false.37

cond.true.34:                                     ; preds = %cond.end
  %48 = load %struct.sv**, %struct.sv*** %sp, align 8
  %49 = load %struct.sv*, %struct.sv** %48, align 8
  %sv_any35 = getelementptr inbounds %struct.sv, %struct.sv* %49, i32 0, i32 0
  %50 = load i8*, i8** %sv_any35, align 8
  %51 = bitcast i8* %50 to %struct.xpvnv*
  %xnv_nv36 = getelementptr inbounds %struct.xpvnv, %struct.xpvnv* %51, i32 0, i32 4
  %52 = load double, double* %xnv_nv36, align 8
  br label %cond.end.39

cond.false.37:                                    ; preds = %cond.end
  %53 = load %struct.sv**, %struct.sv*** %sp, align 8
  %54 = load %struct.sv*, %struct.sv** %53, align 8
  %call38 = call double @Perl_sv_2nv(%struct.sv* %54)
  br label %cond.end.39

cond.end.39:                                      ; preds = %cond.false.37, %cond.true.34
  %cond40 = phi double [ %52, %cond.true.34 ], [ %call38, %cond.false.37 ]
  store double %cond40, double* %left30, align 8
  %55 = load %struct.sv*, %struct.sv** %targ, align 8
  %56 = load double, double* %left30, align 8
  %57 = load double, double* %right23, align 8
  %call41 = call double @atan2(double %56, double %57) #2
  call void @Perl_sv_setnv(%struct.sv* %55, double %call41)
  %58 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags42 = getelementptr inbounds %struct.sv, %struct.sv* %58, i32 0, i32 2
  %59 = load i32, i32* %sv_flags42, align 4
  %and43 = and i32 %59, 16384
  %tobool44 = icmp ne i32 %and43, 0
  br i1 %tobool44, label %if.then.45, label %if.end.47

if.then.45:                                       ; preds = %cond.end.39
  %60 = load %struct.sv*, %struct.sv** %targ, align 8
  %call46 = call i32 @Perl_mg_set(%struct.sv* %60)
  br label %if.end.47

if.end.47:                                        ; preds = %if.then.45, %cond.end.39
  %61 = load %struct.sv*, %struct.sv** %targ, align 8
  %62 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %61, %struct.sv** %62, align 8
  store %struct.sv* %61, %struct.sv** %tmp48
  %63 = load %struct.sv*, %struct.sv** %tmp48
  %64 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %64, %struct.sv*** @PL_stack_sp, align 8
  %65 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next49 = getelementptr inbounds %struct.op, %struct.op* %65, i32 0, i32 0
  %66 = load %struct.op*, %struct.op** %op_next49, align 8
  store %struct.op* %66, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.47, %if.end.19
  %67 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %67
}

; Function Attrs: nounwind
declare double @atan2(double, double) #3

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_sin() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %arg = alloca %struct.sv*, align 8
  %tmp = alloca %struct.sv*, align 8
  %value = alloca double, align 8
  %tmp32 = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 3
  %2 = load i64, i64* %op_targ, align 8
  %3 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 %2
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %4, %struct.sv** %targ, align 8
  %5 = load i64, i64* @PL_amagic_generation, align 8
  %tobool = icmp ne i64 %5, 0
  br i1 %tobool, label %if.then, label %if.end.16

if.then:                                          ; preds = %entry
  %6 = load %struct.sv**, %struct.sv*** %sp, align 8
  %arrayidx1 = getelementptr inbounds %struct.sv*, %struct.sv** %6, i64 0
  %7 = load %struct.sv*, %struct.sv** %arrayidx1, align 8
  store %struct.sv* %7, %struct.sv** %arg, align 8
  br label %am_again

am_again:                                         ; preds = %if.then
  %8 = load %struct.sv*, %struct.sv** %arg, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %8, i32 0, i32 2
  %9 = load i32, i32* %sv_flags, align 4
  %and = and i32 %9, 268435456
  %tobool2 = icmp ne i32 %and, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end.15

land.lhs.true:                                    ; preds = %am_again
  %10 = load %struct.sv*, %struct.sv** %arg, align 8
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %10, %struct.sv* @PL_sv_undef, i32 48, i32 9)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool3 = icmp ne %struct.sv* %call, null
  br i1 %tobool3, label %if.then.4, label %if.end.15

if.then.4:                                        ; preds = %land.lhs.true
  %11 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %11, %struct.sv*** %sp, align 8
  %12 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags5 = getelementptr inbounds %struct.sv, %struct.sv* %12, i32 0, i32 2
  %13 = load i32, i32* %sv_flags5, align 4
  %and6 = and i32 %13, 1024
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %if.then.8, label %if.else

if.then.8:                                        ; preds = %if.then.4
  %14 = load %struct.sv*, %struct.sv** %targ, align 8
  %15 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  call void @Perl_sv_setsv_flags(%struct.sv* %14, %struct.sv* %15, i32 2)
  %16 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags9 = getelementptr inbounds %struct.sv, %struct.sv* %16, i32 0, i32 2
  %17 = load i32, i32* %sv_flags9, align 4
  %and10 = and i32 %17, 16384
  %tobool11 = icmp ne i32 %and10, 0
  br i1 %tobool11, label %if.then.12, label %if.end

if.then.12:                                       ; preds = %if.then.8
  %18 = load %struct.sv*, %struct.sv** %targ, align 8
  %call13 = call i32 @Perl_mg_set(%struct.sv* %18)
  br label %if.end

if.end:                                           ; preds = %if.then.12, %if.then.8
  %19 = load %struct.sv*, %struct.sv** %targ, align 8
  %20 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %19, %struct.sv** %20, align 8
  store %struct.sv* %19, %struct.sv** %tmp
  %21 = load %struct.sv*, %struct.sv** %tmp
  br label %if.end.14

if.else:                                          ; preds = %if.then.4
  %22 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %23 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %22, %struct.sv** %23, align 8
  br label %if.end.14

if.end.14:                                        ; preds = %if.else, %if.end
  %24 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %24, %struct.sv*** @PL_stack_sp, align 8
  %25 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %25, i32 0, i32 0
  %26 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %26, %struct.op** %retval
  br label %return

if.end.15:                                        ; preds = %land.lhs.true, %am_again
  br label %if.end.16

if.end.16:                                        ; preds = %if.end.15, %entry
  %27 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %27, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %28 = load %struct.sv*, %struct.sv** %27, align 8
  store %struct.sv* %28, %struct.sv** @PL_Sv, align 8
  %29 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags18 = getelementptr inbounds %struct.sv, %struct.sv* %29, i32 0, i32 2
  %30 = load i32, i32* %sv_flags18, align 4
  %and19 = and i32 %30, 131072
  %tobool20 = icmp ne i32 %and19, 0
  br i1 %tobool20, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.16
  %31 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %31, i32 0, i32 0
  %32 = load i8*, i8** %sv_any, align 8
  %33 = bitcast i8* %32 to %struct.xpvnv*
  %xnv_nv = getelementptr inbounds %struct.xpvnv, %struct.xpvnv* %33, i32 0, i32 4
  %34 = load double, double* %xnv_nv, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end.16
  %35 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call21 = call double @Perl_sv_2nv(%struct.sv* %35)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi double [ %34, %cond.true ], [ %call21, %cond.false ]
  store double %cond, double* %value, align 8
  %36 = load double, double* %value, align 8
  %call22 = call double @sin(double %36) #2
  store double %call22, double* %value, align 8
  %37 = load %struct.sv*, %struct.sv** %targ, align 8
  %38 = load double, double* %value, align 8
  call void @Perl_sv_setnv(%struct.sv* %37, double %38)
  %39 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags23 = getelementptr inbounds %struct.sv, %struct.sv* %39, i32 0, i32 2
  %40 = load i32, i32* %sv_flags23, align 4
  %and24 = and i32 %40, 16384
  %tobool25 = icmp ne i32 %and24, 0
  br i1 %tobool25, label %if.then.26, label %if.end.28

if.then.26:                                       ; preds = %cond.end
  %41 = load %struct.sv*, %struct.sv** %targ, align 8
  %call27 = call i32 @Perl_mg_set(%struct.sv* %41)
  br label %if.end.28

if.end.28:                                        ; preds = %if.then.26, %cond.end
  %42 = load %struct.sv**, %struct.sv*** @PL_stack_max, align 8
  %43 = load %struct.sv**, %struct.sv*** %sp, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %42 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %43 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %cmp = icmp slt i64 %sub.ptr.div, 1
  br i1 %cmp, label %if.then.29, label %if.end.31

if.then.29:                                       ; preds = %if.end.28
  %44 = load %struct.sv**, %struct.sv*** %sp, align 8
  %45 = load %struct.sv**, %struct.sv*** %sp, align 8
  %call30 = call %struct.sv** @Perl_stack_grow(%struct.sv** %44, %struct.sv** %45, i32 1)
  store %struct.sv** %call30, %struct.sv*** %sp, align 8
  br label %if.end.31

if.end.31:                                        ; preds = %if.then.29, %if.end.28
  %46 = load %struct.sv*, %struct.sv** %targ, align 8
  %47 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr33 = getelementptr inbounds %struct.sv*, %struct.sv** %47, i32 1
  store %struct.sv** %incdec.ptr33, %struct.sv*** %sp, align 8
  store %struct.sv* %46, %struct.sv** %incdec.ptr33, align 8
  store %struct.sv* %46, %struct.sv** %tmp32
  %48 = load %struct.sv*, %struct.sv** %tmp32
  %49 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %49, %struct.sv*** @PL_stack_sp, align 8
  %50 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next34 = getelementptr inbounds %struct.op, %struct.op* %50, i32 0, i32 0
  %51 = load %struct.op*, %struct.op** %op_next34, align 8
  store %struct.op* %51, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.31, %if.end.14
  %52 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %52
}

; Function Attrs: nounwind
declare double @sin(double) #3

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_cos() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %arg = alloca %struct.sv*, align 8
  %tmp = alloca %struct.sv*, align 8
  %value = alloca double, align 8
  %tmp32 = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 3
  %2 = load i64, i64* %op_targ, align 8
  %3 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 %2
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %4, %struct.sv** %targ, align 8
  %5 = load i64, i64* @PL_amagic_generation, align 8
  %tobool = icmp ne i64 %5, 0
  br i1 %tobool, label %if.then, label %if.end.16

if.then:                                          ; preds = %entry
  %6 = load %struct.sv**, %struct.sv*** %sp, align 8
  %arrayidx1 = getelementptr inbounds %struct.sv*, %struct.sv** %6, i64 0
  %7 = load %struct.sv*, %struct.sv** %arrayidx1, align 8
  store %struct.sv* %7, %struct.sv** %arg, align 8
  br label %am_again

am_again:                                         ; preds = %if.then
  %8 = load %struct.sv*, %struct.sv** %arg, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %8, i32 0, i32 2
  %9 = load i32, i32* %sv_flags, align 4
  %and = and i32 %9, 268435456
  %tobool2 = icmp ne i32 %and, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end.15

land.lhs.true:                                    ; preds = %am_again
  %10 = load %struct.sv*, %struct.sv** %arg, align 8
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %10, %struct.sv* @PL_sv_undef, i32 47, i32 9)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool3 = icmp ne %struct.sv* %call, null
  br i1 %tobool3, label %if.then.4, label %if.end.15

if.then.4:                                        ; preds = %land.lhs.true
  %11 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %11, %struct.sv*** %sp, align 8
  %12 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags5 = getelementptr inbounds %struct.sv, %struct.sv* %12, i32 0, i32 2
  %13 = load i32, i32* %sv_flags5, align 4
  %and6 = and i32 %13, 1024
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %if.then.8, label %if.else

if.then.8:                                        ; preds = %if.then.4
  %14 = load %struct.sv*, %struct.sv** %targ, align 8
  %15 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  call void @Perl_sv_setsv_flags(%struct.sv* %14, %struct.sv* %15, i32 2)
  %16 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags9 = getelementptr inbounds %struct.sv, %struct.sv* %16, i32 0, i32 2
  %17 = load i32, i32* %sv_flags9, align 4
  %and10 = and i32 %17, 16384
  %tobool11 = icmp ne i32 %and10, 0
  br i1 %tobool11, label %if.then.12, label %if.end

if.then.12:                                       ; preds = %if.then.8
  %18 = load %struct.sv*, %struct.sv** %targ, align 8
  %call13 = call i32 @Perl_mg_set(%struct.sv* %18)
  br label %if.end

if.end:                                           ; preds = %if.then.12, %if.then.8
  %19 = load %struct.sv*, %struct.sv** %targ, align 8
  %20 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %19, %struct.sv** %20, align 8
  store %struct.sv* %19, %struct.sv** %tmp
  %21 = load %struct.sv*, %struct.sv** %tmp
  br label %if.end.14

if.else:                                          ; preds = %if.then.4
  %22 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %23 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %22, %struct.sv** %23, align 8
  br label %if.end.14

if.end.14:                                        ; preds = %if.else, %if.end
  %24 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %24, %struct.sv*** @PL_stack_sp, align 8
  %25 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %25, i32 0, i32 0
  %26 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %26, %struct.op** %retval
  br label %return

if.end.15:                                        ; preds = %land.lhs.true, %am_again
  br label %if.end.16

if.end.16:                                        ; preds = %if.end.15, %entry
  %27 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %27, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %28 = load %struct.sv*, %struct.sv** %27, align 8
  store %struct.sv* %28, %struct.sv** @PL_Sv, align 8
  %29 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags18 = getelementptr inbounds %struct.sv, %struct.sv* %29, i32 0, i32 2
  %30 = load i32, i32* %sv_flags18, align 4
  %and19 = and i32 %30, 131072
  %tobool20 = icmp ne i32 %and19, 0
  br i1 %tobool20, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.16
  %31 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %31, i32 0, i32 0
  %32 = load i8*, i8** %sv_any, align 8
  %33 = bitcast i8* %32 to %struct.xpvnv*
  %xnv_nv = getelementptr inbounds %struct.xpvnv, %struct.xpvnv* %33, i32 0, i32 4
  %34 = load double, double* %xnv_nv, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end.16
  %35 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call21 = call double @Perl_sv_2nv(%struct.sv* %35)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi double [ %34, %cond.true ], [ %call21, %cond.false ]
  store double %cond, double* %value, align 8
  %36 = load double, double* %value, align 8
  %call22 = call double @cos(double %36) #2
  store double %call22, double* %value, align 8
  %37 = load %struct.sv*, %struct.sv** %targ, align 8
  %38 = load double, double* %value, align 8
  call void @Perl_sv_setnv(%struct.sv* %37, double %38)
  %39 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags23 = getelementptr inbounds %struct.sv, %struct.sv* %39, i32 0, i32 2
  %40 = load i32, i32* %sv_flags23, align 4
  %and24 = and i32 %40, 16384
  %tobool25 = icmp ne i32 %and24, 0
  br i1 %tobool25, label %if.then.26, label %if.end.28

if.then.26:                                       ; preds = %cond.end
  %41 = load %struct.sv*, %struct.sv** %targ, align 8
  %call27 = call i32 @Perl_mg_set(%struct.sv* %41)
  br label %if.end.28

if.end.28:                                        ; preds = %if.then.26, %cond.end
  %42 = load %struct.sv**, %struct.sv*** @PL_stack_max, align 8
  %43 = load %struct.sv**, %struct.sv*** %sp, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %42 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %43 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %cmp = icmp slt i64 %sub.ptr.div, 1
  br i1 %cmp, label %if.then.29, label %if.end.31

if.then.29:                                       ; preds = %if.end.28
  %44 = load %struct.sv**, %struct.sv*** %sp, align 8
  %45 = load %struct.sv**, %struct.sv*** %sp, align 8
  %call30 = call %struct.sv** @Perl_stack_grow(%struct.sv** %44, %struct.sv** %45, i32 1)
  store %struct.sv** %call30, %struct.sv*** %sp, align 8
  br label %if.end.31

if.end.31:                                        ; preds = %if.then.29, %if.end.28
  %46 = load %struct.sv*, %struct.sv** %targ, align 8
  %47 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr33 = getelementptr inbounds %struct.sv*, %struct.sv** %47, i32 1
  store %struct.sv** %incdec.ptr33, %struct.sv*** %sp, align 8
  store %struct.sv* %46, %struct.sv** %incdec.ptr33, align 8
  store %struct.sv* %46, %struct.sv** %tmp32
  %48 = load %struct.sv*, %struct.sv** %tmp32
  %49 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %49, %struct.sv*** @PL_stack_sp, align 8
  %50 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next34 = getelementptr inbounds %struct.op, %struct.op* %50, i32 0, i32 0
  %51 = load %struct.op*, %struct.op** %op_next34, align 8
  store %struct.op* %51, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.31, %if.end.14
  %52 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %52
}

; Function Attrs: nounwind
declare double @cos(double) #3

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_rand() #0 {
entry:
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %value = alloca double, align 8
  %tmp = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 3
  %2 = load i64, i64* %op_targ, align 8
  %3 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 %2
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %4, %struct.sv** %targ, align 8
  %5 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %5, i32 0, i32 7
  %6 = load i8, i8* %op_private, align 1
  %conv = zext i8 %6 to i32
  %and = and i32 %conv, 15
  %cmp = icmp slt i32 %and, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store double 1.000000e+00, double* %value, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %7 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %7, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %8 = load %struct.sv*, %struct.sv** %7, align 8
  store %struct.sv* %8, %struct.sv** @PL_Sv, align 8
  %9 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %9, i32 0, i32 2
  %10 = load i32, i32* %sv_flags, align 4
  %and2 = and i32 %10, 131072
  %tobool = icmp ne i32 %and2, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.else
  %11 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %11, i32 0, i32 0
  %12 = load i8*, i8** %sv_any, align 8
  %13 = bitcast i8* %12 to %struct.xpvnv*
  %xnv_nv = getelementptr inbounds %struct.xpvnv, %struct.xpvnv* %13, i32 0, i32 4
  %14 = load double, double* %xnv_nv, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.else
  %15 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call = call double @Perl_sv_2nv(%struct.sv* %15)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi double [ %14, %cond.true ], [ %call, %cond.false ]
  store double %cond, double* %value, align 8
  br label %if.end

if.end:                                           ; preds = %cond.end, %if.then
  %16 = load double, double* %value, align 8
  %cmp3 = fcmp oeq double %16, 0.000000e+00
  br i1 %cmp3, label %if.then.5, label %if.end.6

if.then.5:                                        ; preds = %if.end
  store double 1.000000e+00, double* %value, align 8
  br label %if.end.6

if.end.6:                                         ; preds = %if.then.5, %if.end
  %17 = load i8, i8* @PL_srand_called, align 1
  %tobool7 = icmp ne i8 %17, 0
  br i1 %tobool7, label %if.end.10, label %if.then.8

if.then.8:                                        ; preds = %if.end.6
  %call9 = call i32 @Perl_seed()
  call void @spec_srand(i32 %call9)
  store i8 1, i8* @PL_srand_called, align 1
  br label %if.end.10

if.end.10:                                        ; preds = %if.then.8, %if.end.6
  %call11 = call double @spec_rand()
  %18 = load double, double* %value, align 8
  %mul = fmul double %18, %call11
  store double %mul, double* %value, align 8
  %19 = load %struct.sv*, %struct.sv** %targ, align 8
  %20 = load double, double* %value, align 8
  call void @Perl_sv_setnv(%struct.sv* %19, double %20)
  %21 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags12 = getelementptr inbounds %struct.sv, %struct.sv* %21, i32 0, i32 2
  %22 = load i32, i32* %sv_flags12, align 4
  %and13 = and i32 %22, 16384
  %tobool14 = icmp ne i32 %and13, 0
  br i1 %tobool14, label %if.then.15, label %if.end.17

if.then.15:                                       ; preds = %if.end.10
  %23 = load %struct.sv*, %struct.sv** %targ, align 8
  %call16 = call i32 @Perl_mg_set(%struct.sv* %23)
  br label %if.end.17

if.end.17:                                        ; preds = %if.then.15, %if.end.10
  %24 = load %struct.sv**, %struct.sv*** @PL_stack_max, align 8
  %25 = load %struct.sv**, %struct.sv*** %sp, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %24 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %25 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %cmp18 = icmp slt i64 %sub.ptr.div, 1
  br i1 %cmp18, label %if.then.20, label %if.end.22

if.then.20:                                       ; preds = %if.end.17
  %26 = load %struct.sv**, %struct.sv*** %sp, align 8
  %27 = load %struct.sv**, %struct.sv*** %sp, align 8
  %call21 = call %struct.sv** @Perl_stack_grow(%struct.sv** %26, %struct.sv** %27, i32 1)
  store %struct.sv** %call21, %struct.sv*** %sp, align 8
  br label %if.end.22

if.end.22:                                        ; preds = %if.then.20, %if.end.17
  %28 = load %struct.sv*, %struct.sv** %targ, align 8
  %29 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr23 = getelementptr inbounds %struct.sv*, %struct.sv** %29, i32 1
  store %struct.sv** %incdec.ptr23, %struct.sv*** %sp, align 8
  store %struct.sv* %28, %struct.sv** %incdec.ptr23, align 8
  store %struct.sv* %28, %struct.sv** %tmp
  %30 = load %struct.sv*, %struct.sv** %tmp
  %31 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %31, %struct.sv*** @PL_stack_sp, align 8
  %32 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %32, i32 0, i32 0
  %33 = load %struct.op*, %struct.op** %op_next, align 8
  ret %struct.op* %33
}

declare void @spec_srand(i32) #1

declare i32 @Perl_seed() #1

declare double @spec_rand() #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_srand() #0 {
entry:
  %sp = alloca %struct.sv**, align 8
  %anum = alloca i64, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 7
  %2 = load i8, i8* %op_private, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 15
  %cmp = icmp slt i32 %and, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call = call i32 @Perl_seed()
  %conv2 = zext i32 %call to i64
  store i64 %conv2, i64* %anum, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %3 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %3, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %4 = load %struct.sv*, %struct.sv** %3, align 8
  store %struct.sv* %4, %struct.sv** @PL_Sv, align 8
  %5 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %5, i32 0, i32 2
  %6 = load i32, i32* %sv_flags, align 4
  %and3 = and i32 %6, 65536
  %tobool = icmp ne i32 %and3, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.else
  %7 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %7, i32 0, i32 0
  %8 = load i8*, i8** %sv_any, align 8
  %9 = bitcast i8* %8 to %struct.xpvuv*
  %xuv_uv = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %9, i32 0, i32 3
  %10 = load i64, i64* %xuv_uv, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.else
  %11 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call4 = call i64 @Perl_sv_2uv(%struct.sv* %11)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %10, %cond.true ], [ %call4, %cond.false ]
  store i64 %cond, i64* %anum, align 8
  br label %if.end

if.end:                                           ; preds = %cond.end, %if.then
  %12 = load i64, i64* %anum, align 8
  %conv5 = trunc i64 %12 to i32
  call void @spec_srand(i32 %conv5)
  store i8 1, i8* @PL_srand_called, align 1
  %13 = load %struct.sv**, %struct.sv*** @PL_stack_max, align 8
  %14 = load %struct.sv**, %struct.sv*** %sp, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %13 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %14 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %cmp6 = icmp slt i64 %sub.ptr.div, 1
  br i1 %cmp6, label %if.then.8, label %if.end.10

if.then.8:                                        ; preds = %if.end
  %15 = load %struct.sv**, %struct.sv*** %sp, align 8
  %16 = load %struct.sv**, %struct.sv*** %sp, align 8
  %call9 = call %struct.sv** @Perl_stack_grow(%struct.sv** %15, %struct.sv** %16, i32 1)
  store %struct.sv** %call9, %struct.sv*** %sp, align 8
  br label %if.end.10

if.end.10:                                        ; preds = %if.then.8, %if.end
  %17 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr11 = getelementptr inbounds %struct.sv*, %struct.sv** %17, i32 1
  store %struct.sv** %incdec.ptr11, %struct.sv*** %sp, align 8
  store %struct.sv* @PL_sv_yes, %struct.sv** %incdec.ptr11, align 8
  %18 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %18, %struct.sv*** @PL_stack_sp, align 8
  %19 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %19, i32 0, i32 0
  %20 = load %struct.op*, %struct.op** %op_next, align 8
  ret %struct.op* %20
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_exp() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %arg = alloca %struct.sv*, align 8
  %tmp = alloca %struct.sv*, align 8
  %value = alloca double, align 8
  %tmp32 = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 3
  %2 = load i64, i64* %op_targ, align 8
  %3 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 %2
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %4, %struct.sv** %targ, align 8
  %5 = load i64, i64* @PL_amagic_generation, align 8
  %tobool = icmp ne i64 %5, 0
  br i1 %tobool, label %if.then, label %if.end.16

if.then:                                          ; preds = %entry
  %6 = load %struct.sv**, %struct.sv*** %sp, align 8
  %arrayidx1 = getelementptr inbounds %struct.sv*, %struct.sv** %6, i64 0
  %7 = load %struct.sv*, %struct.sv** %arrayidx1, align 8
  store %struct.sv* %7, %struct.sv** %arg, align 8
  br label %am_again

am_again:                                         ; preds = %if.then
  %8 = load %struct.sv*, %struct.sv** %arg, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %8, i32 0, i32 2
  %9 = load i32, i32* %sv_flags, align 4
  %and = and i32 %9, 268435456
  %tobool2 = icmp ne i32 %and, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end.15

land.lhs.true:                                    ; preds = %am_again
  %10 = load %struct.sv*, %struct.sv** %arg, align 8
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %10, %struct.sv* @PL_sv_undef, i32 49, i32 9)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool3 = icmp ne %struct.sv* %call, null
  br i1 %tobool3, label %if.then.4, label %if.end.15

if.then.4:                                        ; preds = %land.lhs.true
  %11 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %11, %struct.sv*** %sp, align 8
  %12 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags5 = getelementptr inbounds %struct.sv, %struct.sv* %12, i32 0, i32 2
  %13 = load i32, i32* %sv_flags5, align 4
  %and6 = and i32 %13, 1024
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %if.then.8, label %if.else

if.then.8:                                        ; preds = %if.then.4
  %14 = load %struct.sv*, %struct.sv** %targ, align 8
  %15 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  call void @Perl_sv_setsv_flags(%struct.sv* %14, %struct.sv* %15, i32 2)
  %16 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags9 = getelementptr inbounds %struct.sv, %struct.sv* %16, i32 0, i32 2
  %17 = load i32, i32* %sv_flags9, align 4
  %and10 = and i32 %17, 16384
  %tobool11 = icmp ne i32 %and10, 0
  br i1 %tobool11, label %if.then.12, label %if.end

if.then.12:                                       ; preds = %if.then.8
  %18 = load %struct.sv*, %struct.sv** %targ, align 8
  %call13 = call i32 @Perl_mg_set(%struct.sv* %18)
  br label %if.end

if.end:                                           ; preds = %if.then.12, %if.then.8
  %19 = load %struct.sv*, %struct.sv** %targ, align 8
  %20 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %19, %struct.sv** %20, align 8
  store %struct.sv* %19, %struct.sv** %tmp
  %21 = load %struct.sv*, %struct.sv** %tmp
  br label %if.end.14

if.else:                                          ; preds = %if.then.4
  %22 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %23 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %22, %struct.sv** %23, align 8
  br label %if.end.14

if.end.14:                                        ; preds = %if.else, %if.end
  %24 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %24, %struct.sv*** @PL_stack_sp, align 8
  %25 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %25, i32 0, i32 0
  %26 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %26, %struct.op** %retval
  br label %return

if.end.15:                                        ; preds = %land.lhs.true, %am_again
  br label %if.end.16

if.end.16:                                        ; preds = %if.end.15, %entry
  %27 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %27, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %28 = load %struct.sv*, %struct.sv** %27, align 8
  store %struct.sv* %28, %struct.sv** @PL_Sv, align 8
  %29 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags18 = getelementptr inbounds %struct.sv, %struct.sv* %29, i32 0, i32 2
  %30 = load i32, i32* %sv_flags18, align 4
  %and19 = and i32 %30, 131072
  %tobool20 = icmp ne i32 %and19, 0
  br i1 %tobool20, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.16
  %31 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %31, i32 0, i32 0
  %32 = load i8*, i8** %sv_any, align 8
  %33 = bitcast i8* %32 to %struct.xpvnv*
  %xnv_nv = getelementptr inbounds %struct.xpvnv, %struct.xpvnv* %33, i32 0, i32 4
  %34 = load double, double* %xnv_nv, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end.16
  %35 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call21 = call double @Perl_sv_2nv(%struct.sv* %35)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi double [ %34, %cond.true ], [ %call21, %cond.false ]
  store double %cond, double* %value, align 8
  %36 = load double, double* %value, align 8
  %call22 = call double @exp(double %36) #2
  store double %call22, double* %value, align 8
  %37 = load %struct.sv*, %struct.sv** %targ, align 8
  %38 = load double, double* %value, align 8
  call void @Perl_sv_setnv(%struct.sv* %37, double %38)
  %39 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags23 = getelementptr inbounds %struct.sv, %struct.sv* %39, i32 0, i32 2
  %40 = load i32, i32* %sv_flags23, align 4
  %and24 = and i32 %40, 16384
  %tobool25 = icmp ne i32 %and24, 0
  br i1 %tobool25, label %if.then.26, label %if.end.28

if.then.26:                                       ; preds = %cond.end
  %41 = load %struct.sv*, %struct.sv** %targ, align 8
  %call27 = call i32 @Perl_mg_set(%struct.sv* %41)
  br label %if.end.28

if.end.28:                                        ; preds = %if.then.26, %cond.end
  %42 = load %struct.sv**, %struct.sv*** @PL_stack_max, align 8
  %43 = load %struct.sv**, %struct.sv*** %sp, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %42 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %43 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %cmp = icmp slt i64 %sub.ptr.div, 1
  br i1 %cmp, label %if.then.29, label %if.end.31

if.then.29:                                       ; preds = %if.end.28
  %44 = load %struct.sv**, %struct.sv*** %sp, align 8
  %45 = load %struct.sv**, %struct.sv*** %sp, align 8
  %call30 = call %struct.sv** @Perl_stack_grow(%struct.sv** %44, %struct.sv** %45, i32 1)
  store %struct.sv** %call30, %struct.sv*** %sp, align 8
  br label %if.end.31

if.end.31:                                        ; preds = %if.then.29, %if.end.28
  %46 = load %struct.sv*, %struct.sv** %targ, align 8
  %47 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr33 = getelementptr inbounds %struct.sv*, %struct.sv** %47, i32 1
  store %struct.sv** %incdec.ptr33, %struct.sv*** %sp, align 8
  store %struct.sv* %46, %struct.sv** %incdec.ptr33, align 8
  store %struct.sv* %46, %struct.sv** %tmp32
  %48 = load %struct.sv*, %struct.sv** %tmp32
  %49 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %49, %struct.sv*** @PL_stack_sp, align 8
  %50 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next34 = getelementptr inbounds %struct.op, %struct.op* %50, i32 0, i32 0
  %51 = load %struct.op*, %struct.op** %op_next34, align 8
  store %struct.op* %51, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.31, %if.end.14
  %52 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %52
}

; Function Attrs: nounwind
declare double @exp(double) #3

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_log() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %arg = alloca %struct.sv*, align 8
  %tmp = alloca %struct.sv*, align 8
  %value = alloca double, align 8
  %tmp36 = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 3
  %2 = load i64, i64* %op_targ, align 8
  %3 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 %2
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %4, %struct.sv** %targ, align 8
  %5 = load i64, i64* @PL_amagic_generation, align 8
  %tobool = icmp ne i64 %5, 0
  br i1 %tobool, label %if.then, label %if.end.16

if.then:                                          ; preds = %entry
  %6 = load %struct.sv**, %struct.sv*** %sp, align 8
  %arrayidx1 = getelementptr inbounds %struct.sv*, %struct.sv** %6, i64 0
  %7 = load %struct.sv*, %struct.sv** %arrayidx1, align 8
  store %struct.sv* %7, %struct.sv** %arg, align 8
  br label %am_again

am_again:                                         ; preds = %if.then
  %8 = load %struct.sv*, %struct.sv** %arg, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %8, i32 0, i32 2
  %9 = load i32, i32* %sv_flags, align 4
  %and = and i32 %9, 268435456
  %tobool2 = icmp ne i32 %and, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end.15

land.lhs.true:                                    ; preds = %am_again
  %10 = load %struct.sv*, %struct.sv** %arg, align 8
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %10, %struct.sv* @PL_sv_undef, i32 50, i32 9)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool3 = icmp ne %struct.sv* %call, null
  br i1 %tobool3, label %if.then.4, label %if.end.15

if.then.4:                                        ; preds = %land.lhs.true
  %11 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %11, %struct.sv*** %sp, align 8
  %12 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags5 = getelementptr inbounds %struct.sv, %struct.sv* %12, i32 0, i32 2
  %13 = load i32, i32* %sv_flags5, align 4
  %and6 = and i32 %13, 1024
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %if.then.8, label %if.else

if.then.8:                                        ; preds = %if.then.4
  %14 = load %struct.sv*, %struct.sv** %targ, align 8
  %15 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  call void @Perl_sv_setsv_flags(%struct.sv* %14, %struct.sv* %15, i32 2)
  %16 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags9 = getelementptr inbounds %struct.sv, %struct.sv* %16, i32 0, i32 2
  %17 = load i32, i32* %sv_flags9, align 4
  %and10 = and i32 %17, 16384
  %tobool11 = icmp ne i32 %and10, 0
  br i1 %tobool11, label %if.then.12, label %if.end

if.then.12:                                       ; preds = %if.then.8
  %18 = load %struct.sv*, %struct.sv** %targ, align 8
  %call13 = call i32 @Perl_mg_set(%struct.sv* %18)
  br label %if.end

if.end:                                           ; preds = %if.then.12, %if.then.8
  %19 = load %struct.sv*, %struct.sv** %targ, align 8
  %20 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %19, %struct.sv** %20, align 8
  store %struct.sv* %19, %struct.sv** %tmp
  %21 = load %struct.sv*, %struct.sv** %tmp
  br label %if.end.14

if.else:                                          ; preds = %if.then.4
  %22 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %23 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %22, %struct.sv** %23, align 8
  br label %if.end.14

if.end.14:                                        ; preds = %if.else, %if.end
  %24 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %24, %struct.sv*** @PL_stack_sp, align 8
  %25 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %25, i32 0, i32 0
  %26 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %26, %struct.op** %retval
  br label %return

if.end.15:                                        ; preds = %land.lhs.true, %am_again
  br label %if.end.16

if.end.16:                                        ; preds = %if.end.15, %entry
  %27 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %27, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %28 = load %struct.sv*, %struct.sv** %27, align 8
  store %struct.sv* %28, %struct.sv** @PL_Sv, align 8
  %29 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags18 = getelementptr inbounds %struct.sv, %struct.sv* %29, i32 0, i32 2
  %30 = load i32, i32* %sv_flags18, align 4
  %and19 = and i32 %30, 131072
  %tobool20 = icmp ne i32 %and19, 0
  br i1 %tobool20, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.16
  %31 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %31, i32 0, i32 0
  %32 = load i8*, i8** %sv_any, align 8
  %33 = bitcast i8* %32 to %struct.xpvnv*
  %xnv_nv = getelementptr inbounds %struct.xpvnv, %struct.xpvnv* %33, i32 0, i32 4
  %34 = load double, double* %xnv_nv, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end.16
  %35 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call21 = call double @Perl_sv_2nv(%struct.sv* %35)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi double [ %34, %cond.true ], [ %call21, %cond.false ]
  store double %cond, double* %value, align 8
  %36 = load double, double* %value, align 8
  %cmp = fcmp ole double %36, 0.000000e+00
  br i1 %cmp, label %if.then.22, label %if.end.24

if.then.22:                                       ; preds = %cond.end
  %37 = load double, double* %value, align 8
  %call23 = call %struct.op* (i8*, ...) @Perl_die(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.32, i32 0, i32 0), double %37)
  store %struct.op* %call23, %struct.op** %retval
  br label %return

if.end.24:                                        ; preds = %cond.end
  %38 = load double, double* %value, align 8
  %call25 = call double @log(double %38) #2
  store double %call25, double* %value, align 8
  %39 = load %struct.sv*, %struct.sv** %targ, align 8
  %40 = load double, double* %value, align 8
  call void @Perl_sv_setnv(%struct.sv* %39, double %40)
  %41 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags26 = getelementptr inbounds %struct.sv, %struct.sv* %41, i32 0, i32 2
  %42 = load i32, i32* %sv_flags26, align 4
  %and27 = and i32 %42, 16384
  %tobool28 = icmp ne i32 %and27, 0
  br i1 %tobool28, label %if.then.29, label %if.end.31

if.then.29:                                       ; preds = %if.end.24
  %43 = load %struct.sv*, %struct.sv** %targ, align 8
  %call30 = call i32 @Perl_mg_set(%struct.sv* %43)
  br label %if.end.31

if.end.31:                                        ; preds = %if.then.29, %if.end.24
  %44 = load %struct.sv**, %struct.sv*** @PL_stack_max, align 8
  %45 = load %struct.sv**, %struct.sv*** %sp, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %44 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %45 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %cmp32 = icmp slt i64 %sub.ptr.div, 1
  br i1 %cmp32, label %if.then.33, label %if.end.35

if.then.33:                                       ; preds = %if.end.31
  %46 = load %struct.sv**, %struct.sv*** %sp, align 8
  %47 = load %struct.sv**, %struct.sv*** %sp, align 8
  %call34 = call %struct.sv** @Perl_stack_grow(%struct.sv** %46, %struct.sv** %47, i32 1)
  store %struct.sv** %call34, %struct.sv*** %sp, align 8
  br label %if.end.35

if.end.35:                                        ; preds = %if.then.33, %if.end.31
  %48 = load %struct.sv*, %struct.sv** %targ, align 8
  %49 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr37 = getelementptr inbounds %struct.sv*, %struct.sv** %49, i32 1
  store %struct.sv** %incdec.ptr37, %struct.sv*** %sp, align 8
  store %struct.sv* %48, %struct.sv** %incdec.ptr37, align 8
  store %struct.sv* %48, %struct.sv** %tmp36
  %50 = load %struct.sv*, %struct.sv** %tmp36
  %51 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %51, %struct.sv*** @PL_stack_sp, align 8
  %52 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next38 = getelementptr inbounds %struct.op, %struct.op* %52, i32 0, i32 0
  %53 = load %struct.op*, %struct.op** %op_next38, align 8
  store %struct.op* %53, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.35, %if.then.22, %if.end.14
  %54 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %54
}

; Function Attrs: nounwind
declare double @log(double) #3

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_sqrt() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %arg = alloca %struct.sv*, align 8
  %tmp = alloca %struct.sv*, align 8
  %value = alloca double, align 8
  %tmp36 = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 3
  %2 = load i64, i64* %op_targ, align 8
  %3 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 %2
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %4, %struct.sv** %targ, align 8
  %5 = load i64, i64* @PL_amagic_generation, align 8
  %tobool = icmp ne i64 %5, 0
  br i1 %tobool, label %if.then, label %if.end.16

if.then:                                          ; preds = %entry
  %6 = load %struct.sv**, %struct.sv*** %sp, align 8
  %arrayidx1 = getelementptr inbounds %struct.sv*, %struct.sv** %6, i64 0
  %7 = load %struct.sv*, %struct.sv** %arrayidx1, align 8
  store %struct.sv* %7, %struct.sv** %arg, align 8
  br label %am_again

am_again:                                         ; preds = %if.then
  %8 = load %struct.sv*, %struct.sv** %arg, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %8, i32 0, i32 2
  %9 = load i32, i32* %sv_flags, align 4
  %and = and i32 %9, 268435456
  %tobool2 = icmp ne i32 %and, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end.15

land.lhs.true:                                    ; preds = %am_again
  %10 = load %struct.sv*, %struct.sv** %arg, align 8
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %10, %struct.sv* @PL_sv_undef, i32 51, i32 9)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool3 = icmp ne %struct.sv* %call, null
  br i1 %tobool3, label %if.then.4, label %if.end.15

if.then.4:                                        ; preds = %land.lhs.true
  %11 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %11, %struct.sv*** %sp, align 8
  %12 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags5 = getelementptr inbounds %struct.sv, %struct.sv* %12, i32 0, i32 2
  %13 = load i32, i32* %sv_flags5, align 4
  %and6 = and i32 %13, 1024
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %if.then.8, label %if.else

if.then.8:                                        ; preds = %if.then.4
  %14 = load %struct.sv*, %struct.sv** %targ, align 8
  %15 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  call void @Perl_sv_setsv_flags(%struct.sv* %14, %struct.sv* %15, i32 2)
  %16 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags9 = getelementptr inbounds %struct.sv, %struct.sv* %16, i32 0, i32 2
  %17 = load i32, i32* %sv_flags9, align 4
  %and10 = and i32 %17, 16384
  %tobool11 = icmp ne i32 %and10, 0
  br i1 %tobool11, label %if.then.12, label %if.end

if.then.12:                                       ; preds = %if.then.8
  %18 = load %struct.sv*, %struct.sv** %targ, align 8
  %call13 = call i32 @Perl_mg_set(%struct.sv* %18)
  br label %if.end

if.end:                                           ; preds = %if.then.12, %if.then.8
  %19 = load %struct.sv*, %struct.sv** %targ, align 8
  %20 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %19, %struct.sv** %20, align 8
  store %struct.sv* %19, %struct.sv** %tmp
  %21 = load %struct.sv*, %struct.sv** %tmp
  br label %if.end.14

if.else:                                          ; preds = %if.then.4
  %22 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %23 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %22, %struct.sv** %23, align 8
  br label %if.end.14

if.end.14:                                        ; preds = %if.else, %if.end
  %24 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %24, %struct.sv*** @PL_stack_sp, align 8
  %25 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %25, i32 0, i32 0
  %26 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %26, %struct.op** %retval
  br label %return

if.end.15:                                        ; preds = %land.lhs.true, %am_again
  br label %if.end.16

if.end.16:                                        ; preds = %if.end.15, %entry
  %27 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %27, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %28 = load %struct.sv*, %struct.sv** %27, align 8
  store %struct.sv* %28, %struct.sv** @PL_Sv, align 8
  %29 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags18 = getelementptr inbounds %struct.sv, %struct.sv* %29, i32 0, i32 2
  %30 = load i32, i32* %sv_flags18, align 4
  %and19 = and i32 %30, 131072
  %tobool20 = icmp ne i32 %and19, 0
  br i1 %tobool20, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.16
  %31 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %31, i32 0, i32 0
  %32 = load i8*, i8** %sv_any, align 8
  %33 = bitcast i8* %32 to %struct.xpvnv*
  %xnv_nv = getelementptr inbounds %struct.xpvnv, %struct.xpvnv* %33, i32 0, i32 4
  %34 = load double, double* %xnv_nv, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end.16
  %35 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call21 = call double @Perl_sv_2nv(%struct.sv* %35)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi double [ %34, %cond.true ], [ %call21, %cond.false ]
  store double %cond, double* %value, align 8
  %36 = load double, double* %value, align 8
  %cmp = fcmp olt double %36, 0.000000e+00
  br i1 %cmp, label %if.then.22, label %if.end.24

if.then.22:                                       ; preds = %cond.end
  %37 = load double, double* %value, align 8
  %call23 = call %struct.op* (i8*, ...) @Perl_die(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.33, i32 0, i32 0), double %37)
  store %struct.op* %call23, %struct.op** %retval
  br label %return

if.end.24:                                        ; preds = %cond.end
  %38 = load double, double* %value, align 8
  %call25 = call double @sqrt(double %38) #2
  store double %call25, double* %value, align 8
  %39 = load %struct.sv*, %struct.sv** %targ, align 8
  %40 = load double, double* %value, align 8
  call void @Perl_sv_setnv(%struct.sv* %39, double %40)
  %41 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags26 = getelementptr inbounds %struct.sv, %struct.sv* %41, i32 0, i32 2
  %42 = load i32, i32* %sv_flags26, align 4
  %and27 = and i32 %42, 16384
  %tobool28 = icmp ne i32 %and27, 0
  br i1 %tobool28, label %if.then.29, label %if.end.31

if.then.29:                                       ; preds = %if.end.24
  %43 = load %struct.sv*, %struct.sv** %targ, align 8
  %call30 = call i32 @Perl_mg_set(%struct.sv* %43)
  br label %if.end.31

if.end.31:                                        ; preds = %if.then.29, %if.end.24
  %44 = load %struct.sv**, %struct.sv*** @PL_stack_max, align 8
  %45 = load %struct.sv**, %struct.sv*** %sp, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %44 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %45 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %cmp32 = icmp slt i64 %sub.ptr.div, 1
  br i1 %cmp32, label %if.then.33, label %if.end.35

if.then.33:                                       ; preds = %if.end.31
  %46 = load %struct.sv**, %struct.sv*** %sp, align 8
  %47 = load %struct.sv**, %struct.sv*** %sp, align 8
  %call34 = call %struct.sv** @Perl_stack_grow(%struct.sv** %46, %struct.sv** %47, i32 1)
  store %struct.sv** %call34, %struct.sv*** %sp, align 8
  br label %if.end.35

if.end.35:                                        ; preds = %if.then.33, %if.end.31
  %48 = load %struct.sv*, %struct.sv** %targ, align 8
  %49 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr37 = getelementptr inbounds %struct.sv*, %struct.sv** %49, i32 1
  store %struct.sv** %incdec.ptr37, %struct.sv*** %sp, align 8
  store %struct.sv* %48, %struct.sv** %incdec.ptr37, align 8
  store %struct.sv* %48, %struct.sv** %tmp36
  %50 = load %struct.sv*, %struct.sv** %tmp36
  %51 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %51, %struct.sv*** @PL_stack_sp, align 8
  %52 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next38 = getelementptr inbounds %struct.op, %struct.op* %52, i32 0, i32 0
  %53 = load %struct.op*, %struct.op** %op_next38, align 8
  store %struct.op* %53, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.35, %if.then.22, %if.end.14
  %54 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %54
}

; Function Attrs: nounwind
declare double @sqrt(double) #3

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_int() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %arg = alloca %struct.sv*, align 8
  %tmp = alloca %struct.sv*, align 8
  %value = alloca double, align 8
  %iv = alloca i64, align 8
  %tmp33 = alloca %struct.sv*, align 8
  %uv = alloca i64, align 8
  %tmp59 = alloca %struct.sv*, align 8
  %tmp67 = alloca %struct.sv*, align 8
  %tmp89 = alloca %struct.sv*, align 8
  %tmp98 = alloca %struct.sv*, align 8
  %tmp110 = alloca %struct.sv*, align 8
  %tmp119 = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 3
  %2 = load i64, i64* %op_targ, align 8
  %3 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 %2
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %4, %struct.sv** %targ, align 8
  %5 = load i64, i64* @PL_amagic_generation, align 8
  %tobool = icmp ne i64 %5, 0
  br i1 %tobool, label %if.then, label %if.end.16

if.then:                                          ; preds = %entry
  %6 = load %struct.sv**, %struct.sv*** %sp, align 8
  %arrayidx1 = getelementptr inbounds %struct.sv*, %struct.sv** %6, i64 0
  %7 = load %struct.sv*, %struct.sv** %arrayidx1, align 8
  store %struct.sv* %7, %struct.sv** %arg, align 8
  br label %am_again

am_again:                                         ; preds = %if.then
  %8 = load %struct.sv*, %struct.sv** %arg, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %8, i32 0, i32 2
  %9 = load i32, i32* %sv_flags, align 4
  %and = and i32 %9, 268435456
  %tobool2 = icmp ne i32 %and, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end.15

land.lhs.true:                                    ; preds = %am_again
  %10 = load %struct.sv*, %struct.sv** %arg, align 8
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %10, %struct.sv* @PL_sv_undef, i32 64, i32 9)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool3 = icmp ne %struct.sv* %call, null
  br i1 %tobool3, label %if.then.4, label %if.end.15

if.then.4:                                        ; preds = %land.lhs.true
  %11 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %11, %struct.sv*** %sp, align 8
  %12 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags5 = getelementptr inbounds %struct.sv, %struct.sv* %12, i32 0, i32 2
  %13 = load i32, i32* %sv_flags5, align 4
  %and6 = and i32 %13, 1024
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %if.then.8, label %if.else

if.then.8:                                        ; preds = %if.then.4
  %14 = load %struct.sv*, %struct.sv** %targ, align 8
  %15 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  call void @Perl_sv_setsv_flags(%struct.sv* %14, %struct.sv* %15, i32 2)
  %16 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags9 = getelementptr inbounds %struct.sv, %struct.sv* %16, i32 0, i32 2
  %17 = load i32, i32* %sv_flags9, align 4
  %and10 = and i32 %17, 16384
  %tobool11 = icmp ne i32 %and10, 0
  br i1 %tobool11, label %if.then.12, label %if.end

if.then.12:                                       ; preds = %if.then.8
  %18 = load %struct.sv*, %struct.sv** %targ, align 8
  %call13 = call i32 @Perl_mg_set(%struct.sv* %18)
  br label %if.end

if.end:                                           ; preds = %if.then.12, %if.then.8
  %19 = load %struct.sv*, %struct.sv** %targ, align 8
  %20 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %19, %struct.sv** %20, align 8
  store %struct.sv* %19, %struct.sv** %tmp
  %21 = load %struct.sv*, %struct.sv** %tmp
  br label %if.end.14

if.else:                                          ; preds = %if.then.4
  %22 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %23 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %22, %struct.sv** %23, align 8
  br label %if.end.14

if.end.14:                                        ; preds = %if.else, %if.end
  %24 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %24, %struct.sv*** @PL_stack_sp, align 8
  %25 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %25, i32 0, i32 0
  %26 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %26, %struct.op** %retval
  br label %return

if.end.15:                                        ; preds = %land.lhs.true, %am_again
  br label %if.end.16

if.end.16:                                        ; preds = %if.end.15, %entry
  %27 = load %struct.sv**, %struct.sv*** %sp, align 8
  %28 = load %struct.sv*, %struct.sv** %27, align 8
  %sv_flags19 = getelementptr inbounds %struct.sv, %struct.sv* %28, i32 0, i32 2
  %29 = load i32, i32* %sv_flags19, align 4
  %and20 = and i32 %29, 65536
  %tobool21 = icmp ne i32 %and20, 0
  br i1 %tobool21, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.16
  %30 = load %struct.sv**, %struct.sv*** %sp, align 8
  %31 = load %struct.sv*, %struct.sv** %30, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %31, i32 0, i32 0
  %32 = load i8*, i8** %sv_any, align 8
  %33 = bitcast i8* %32 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %33, i32 0, i32 3
  %34 = load i64, i64* %xiv_iv, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end.16
  %35 = load %struct.sv**, %struct.sv*** %sp, align 8
  %36 = load %struct.sv*, %struct.sv** %35, align 8
  %call22 = call i64 @Perl_sv_2iv(%struct.sv* %36)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %34, %cond.true ], [ %call22, %cond.false ]
  store i64 %cond, i64* %iv, align 8
  %37 = load %struct.sv**, %struct.sv*** %sp, align 8
  %38 = load %struct.sv*, %struct.sv** %37, align 8
  %sv_flags23 = getelementptr inbounds %struct.sv, %struct.sv* %38, i32 0, i32 2
  %39 = load i32, i32* %sv_flags23, align 4
  %and24 = and i32 %39, 118423552
  %tobool25 = icmp ne i32 %and24, 0
  br i1 %tobool25, label %if.else.34, label %if.then.26

if.then.26:                                       ; preds = %cond.end
  %40 = load %struct.sv*, %struct.sv** %targ, align 8
  call void @Perl_sv_setuv(%struct.sv* %40, i64 0)
  %41 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags27 = getelementptr inbounds %struct.sv, %struct.sv* %41, i32 0, i32 2
  %42 = load i32, i32* %sv_flags27, align 4
  %and28 = and i32 %42, 16384
  %tobool29 = icmp ne i32 %and28, 0
  br i1 %tobool29, label %if.then.30, label %if.end.32

if.then.30:                                       ; preds = %if.then.26
  %43 = load %struct.sv*, %struct.sv** %targ, align 8
  %call31 = call i32 @Perl_mg_set(%struct.sv* %43)
  br label %if.end.32

if.end.32:                                        ; preds = %if.then.30, %if.then.26
  %44 = load %struct.sv*, %struct.sv** %targ, align 8
  %45 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %44, %struct.sv** %45, align 8
  store %struct.sv* %44, %struct.sv** %tmp33
  %46 = load %struct.sv*, %struct.sv** %tmp33
  br label %if.end.123

if.else.34:                                       ; preds = %cond.end
  %47 = load %struct.sv**, %struct.sv*** %sp, align 8
  %48 = load %struct.sv*, %struct.sv** %47, align 8
  %sv_flags35 = getelementptr inbounds %struct.sv, %struct.sv* %48, i32 0, i32 2
  %49 = load i32, i32* %sv_flags35, align 4
  %and36 = and i32 %49, 65536
  %tobool37 = icmp ne i32 %and36, 0
  br i1 %tobool37, label %if.then.38, label %if.else.69

if.then.38:                                       ; preds = %if.else.34
  %50 = load %struct.sv**, %struct.sv*** %sp, align 8
  %51 = load %struct.sv*, %struct.sv** %50, align 8
  %sv_flags39 = getelementptr inbounds %struct.sv, %struct.sv* %51, i32 0, i32 2
  %52 = load i32, i32* %sv_flags39, align 4
  %and40 = and i32 %52, -2147483648
  %tobool41 = icmp ne i32 %and40, 0
  br i1 %tobool41, label %if.then.42, label %if.else.60

if.then.42:                                       ; preds = %if.then.38
  %53 = load %struct.sv**, %struct.sv*** %sp, align 8
  %54 = load %struct.sv*, %struct.sv** %53, align 8
  %sv_flags44 = getelementptr inbounds %struct.sv, %struct.sv* %54, i32 0, i32 2
  %55 = load i32, i32* %sv_flags44, align 4
  %and45 = and i32 %55, 65536
  %tobool46 = icmp ne i32 %and45, 0
  br i1 %tobool46, label %cond.true.47, label %cond.false.49

cond.true.47:                                     ; preds = %if.then.42
  %56 = load %struct.sv**, %struct.sv*** %sp, align 8
  %57 = load %struct.sv*, %struct.sv** %56, align 8
  %sv_any48 = getelementptr inbounds %struct.sv, %struct.sv* %57, i32 0, i32 0
  %58 = load i8*, i8** %sv_any48, align 8
  %59 = bitcast i8* %58 to %struct.xpvuv*
  %xuv_uv = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %59, i32 0, i32 3
  %60 = load i64, i64* %xuv_uv, align 8
  br label %cond.end.51

cond.false.49:                                    ; preds = %if.then.42
  %61 = load %struct.sv**, %struct.sv*** %sp, align 8
  %62 = load %struct.sv*, %struct.sv** %61, align 8
  %call50 = call i64 @Perl_sv_2uv(%struct.sv* %62)
  br label %cond.end.51

cond.end.51:                                      ; preds = %cond.false.49, %cond.true.47
  %cond52 = phi i64 [ %60, %cond.true.47 ], [ %call50, %cond.false.49 ]
  store i64 %cond52, i64* %uv, align 8
  %63 = load %struct.sv*, %struct.sv** %targ, align 8
  %64 = load i64, i64* %uv, align 8
  call void @Perl_sv_setuv(%struct.sv* %63, i64 %64)
  %65 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags53 = getelementptr inbounds %struct.sv, %struct.sv* %65, i32 0, i32 2
  %66 = load i32, i32* %sv_flags53, align 4
  %and54 = and i32 %66, 16384
  %tobool55 = icmp ne i32 %and54, 0
  br i1 %tobool55, label %if.then.56, label %if.end.58

if.then.56:                                       ; preds = %cond.end.51
  %67 = load %struct.sv*, %struct.sv** %targ, align 8
  %call57 = call i32 @Perl_mg_set(%struct.sv* %67)
  br label %if.end.58

if.end.58:                                        ; preds = %if.then.56, %cond.end.51
  %68 = load %struct.sv*, %struct.sv** %targ, align 8
  %69 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %68, %struct.sv** %69, align 8
  store %struct.sv* %68, %struct.sv** %tmp59
  %70 = load %struct.sv*, %struct.sv** %tmp59
  br label %if.end.68

if.else.60:                                       ; preds = %if.then.38
  %71 = load %struct.sv*, %struct.sv** %targ, align 8
  %72 = load i64, i64* %iv, align 8
  call void @Perl_sv_setiv(%struct.sv* %71, i64 %72)
  %73 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags61 = getelementptr inbounds %struct.sv, %struct.sv* %73, i32 0, i32 2
  %74 = load i32, i32* %sv_flags61, align 4
  %and62 = and i32 %74, 16384
  %tobool63 = icmp ne i32 %and62, 0
  br i1 %tobool63, label %if.then.64, label %if.end.66

if.then.64:                                       ; preds = %if.else.60
  %75 = load %struct.sv*, %struct.sv** %targ, align 8
  %call65 = call i32 @Perl_mg_set(%struct.sv* %75)
  br label %if.end.66

if.end.66:                                        ; preds = %if.then.64, %if.else.60
  %76 = load %struct.sv*, %struct.sv** %targ, align 8
  %77 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %76, %struct.sv** %77, align 8
  store %struct.sv* %76, %struct.sv** %tmp67
  %78 = load %struct.sv*, %struct.sv** %tmp67
  br label %if.end.68

if.end.68:                                        ; preds = %if.end.66, %if.end.58
  br label %if.end.122

if.else.69:                                       ; preds = %if.else.34
  %79 = load %struct.sv**, %struct.sv*** %sp, align 8
  %80 = load %struct.sv*, %struct.sv** %79, align 8
  %sv_flags70 = getelementptr inbounds %struct.sv, %struct.sv* %80, i32 0, i32 2
  %81 = load i32, i32* %sv_flags70, align 4
  %and71 = and i32 %81, 131072
  %tobool72 = icmp ne i32 %and71, 0
  br i1 %tobool72, label %cond.true.73, label %cond.false.75

cond.true.73:                                     ; preds = %if.else.69
  %82 = load %struct.sv**, %struct.sv*** %sp, align 8
  %83 = load %struct.sv*, %struct.sv** %82, align 8
  %sv_any74 = getelementptr inbounds %struct.sv, %struct.sv* %83, i32 0, i32 0
  %84 = load i8*, i8** %sv_any74, align 8
  %85 = bitcast i8* %84 to %struct.xpvnv*
  %xnv_nv = getelementptr inbounds %struct.xpvnv, %struct.xpvnv* %85, i32 0, i32 4
  %86 = load double, double* %xnv_nv, align 8
  br label %cond.end.77

cond.false.75:                                    ; preds = %if.else.69
  %87 = load %struct.sv**, %struct.sv*** %sp, align 8
  %88 = load %struct.sv*, %struct.sv** %87, align 8
  %call76 = call double @Perl_sv_2nv(%struct.sv* %88)
  br label %cond.end.77

cond.end.77:                                      ; preds = %cond.false.75, %cond.true.73
  %cond78 = phi double [ %86, %cond.true.73 ], [ %call76, %cond.false.75 ]
  store double %cond78, double* %value, align 8
  %89 = load double, double* %value, align 8
  %cmp = fcmp oge double %89, 0.000000e+00
  br i1 %cmp, label %if.then.79, label %if.else.100

if.then.79:                                       ; preds = %cond.end.77
  %90 = load double, double* %value, align 8
  %cmp80 = fcmp olt double %90, 0x43F0000000000000
  br i1 %cmp80, label %if.then.81, label %if.else.90

if.then.81:                                       ; preds = %if.then.79
  %91 = load %struct.sv*, %struct.sv** %targ, align 8
  %92 = load double, double* %value, align 8
  %call82 = call i64 @Perl_cast_uv(double %92)
  call void @Perl_sv_setuv(%struct.sv* %91, i64 %call82)
  %93 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags83 = getelementptr inbounds %struct.sv, %struct.sv* %93, i32 0, i32 2
  %94 = load i32, i32* %sv_flags83, align 4
  %and84 = and i32 %94, 16384
  %tobool85 = icmp ne i32 %and84, 0
  br i1 %tobool85, label %if.then.86, label %if.end.88

if.then.86:                                       ; preds = %if.then.81
  %95 = load %struct.sv*, %struct.sv** %targ, align 8
  %call87 = call i32 @Perl_mg_set(%struct.sv* %95)
  br label %if.end.88

if.end.88:                                        ; preds = %if.then.86, %if.then.81
  %96 = load %struct.sv*, %struct.sv** %targ, align 8
  %97 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %96, %struct.sv** %97, align 8
  store %struct.sv* %96, %struct.sv** %tmp89
  %98 = load %struct.sv*, %struct.sv** %tmp89
  br label %if.end.99

if.else.90:                                       ; preds = %if.then.79
  %99 = load %struct.sv*, %struct.sv** %targ, align 8
  %100 = load double, double* %value, align 8
  %call91 = call double @floor(double %100) #5
  call void @Perl_sv_setnv(%struct.sv* %99, double %call91)
  %101 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags92 = getelementptr inbounds %struct.sv, %struct.sv* %101, i32 0, i32 2
  %102 = load i32, i32* %sv_flags92, align 4
  %and93 = and i32 %102, 16384
  %tobool94 = icmp ne i32 %and93, 0
  br i1 %tobool94, label %if.then.95, label %if.end.97

if.then.95:                                       ; preds = %if.else.90
  %103 = load %struct.sv*, %struct.sv** %targ, align 8
  %call96 = call i32 @Perl_mg_set(%struct.sv* %103)
  br label %if.end.97

if.end.97:                                        ; preds = %if.then.95, %if.else.90
  %104 = load %struct.sv*, %struct.sv** %targ, align 8
  %105 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %104, %struct.sv** %105, align 8
  store %struct.sv* %104, %struct.sv** %tmp98
  %106 = load %struct.sv*, %struct.sv** %tmp98
  br label %if.end.99

if.end.99:                                        ; preds = %if.end.97, %if.end.88
  br label %if.end.121

if.else.100:                                      ; preds = %cond.end.77
  %107 = load double, double* %value, align 8
  %cmp101 = fcmp ogt double %107, 0xC3E0000000000000
  br i1 %cmp101, label %if.then.102, label %if.else.111

if.then.102:                                      ; preds = %if.else.100
  %108 = load %struct.sv*, %struct.sv** %targ, align 8
  %109 = load double, double* %value, align 8
  %call103 = call i64 @Perl_cast_iv(double %109)
  call void @Perl_sv_setiv(%struct.sv* %108, i64 %call103)
  %110 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags104 = getelementptr inbounds %struct.sv, %struct.sv* %110, i32 0, i32 2
  %111 = load i32, i32* %sv_flags104, align 4
  %and105 = and i32 %111, 16384
  %tobool106 = icmp ne i32 %and105, 0
  br i1 %tobool106, label %if.then.107, label %if.end.109

if.then.107:                                      ; preds = %if.then.102
  %112 = load %struct.sv*, %struct.sv** %targ, align 8
  %call108 = call i32 @Perl_mg_set(%struct.sv* %112)
  br label %if.end.109

if.end.109:                                       ; preds = %if.then.107, %if.then.102
  %113 = load %struct.sv*, %struct.sv** %targ, align 8
  %114 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %113, %struct.sv** %114, align 8
  store %struct.sv* %113, %struct.sv** %tmp110
  %115 = load %struct.sv*, %struct.sv** %tmp110
  br label %if.end.120

if.else.111:                                      ; preds = %if.else.100
  %116 = load %struct.sv*, %struct.sv** %targ, align 8
  %117 = load double, double* %value, align 8
  %call112 = call double @ceil(double %117) #5
  call void @Perl_sv_setnv(%struct.sv* %116, double %call112)
  %118 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags113 = getelementptr inbounds %struct.sv, %struct.sv* %118, i32 0, i32 2
  %119 = load i32, i32* %sv_flags113, align 4
  %and114 = and i32 %119, 16384
  %tobool115 = icmp ne i32 %and114, 0
  br i1 %tobool115, label %if.then.116, label %if.end.118

if.then.116:                                      ; preds = %if.else.111
  %120 = load %struct.sv*, %struct.sv** %targ, align 8
  %call117 = call i32 @Perl_mg_set(%struct.sv* %120)
  br label %if.end.118

if.end.118:                                       ; preds = %if.then.116, %if.else.111
  %121 = load %struct.sv*, %struct.sv** %targ, align 8
  %122 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %121, %struct.sv** %122, align 8
  store %struct.sv* %121, %struct.sv** %tmp119
  %123 = load %struct.sv*, %struct.sv** %tmp119
  br label %if.end.120

if.end.120:                                       ; preds = %if.end.118, %if.end.109
  br label %if.end.121

if.end.121:                                       ; preds = %if.end.120, %if.end.99
  br label %if.end.122

if.end.122:                                       ; preds = %if.end.121, %if.end.68
  br label %if.end.123

if.end.123:                                       ; preds = %if.end.122, %if.end.32
  %124 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %124, %struct.sv*** @PL_stack_sp, align 8
  %125 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next124 = getelementptr inbounds %struct.op, %struct.op* %125, i32 0, i32 0
  %126 = load %struct.op*, %struct.op** %op_next124, align 8
  store %struct.op* %126, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.123, %if.end.14
  %127 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %127
}

declare i64 @Perl_cast_iv(double) #1

; Function Attrs: nounwind readnone
declare double @ceil(double) #4

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_abs() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %arg = alloca %struct.sv*, align 8
  %tmp = alloca %struct.sv*, align 8
  %iv = alloca i64, align 8
  %tmp32 = alloca %struct.sv*, align 8
  %tmp57 = alloca %struct.sv*, align 8
  %tmp66 = alloca %struct.sv*, align 8
  %tmp76 = alloca %struct.sv*, align 8
  %tmp84 = alloca %struct.sv*, align 8
  %value = alloca double, align 8
  %tmp109 = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 3
  %2 = load i64, i64* %op_targ, align 8
  %3 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 %2
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %4, %struct.sv** %targ, align 8
  %5 = load i64, i64* @PL_amagic_generation, align 8
  %tobool = icmp ne i64 %5, 0
  br i1 %tobool, label %if.then, label %if.end.16

if.then:                                          ; preds = %entry
  %6 = load %struct.sv**, %struct.sv*** %sp, align 8
  %arrayidx1 = getelementptr inbounds %struct.sv*, %struct.sv** %6, i64 0
  %7 = load %struct.sv*, %struct.sv** %arrayidx1, align 8
  store %struct.sv* %7, %struct.sv** %arg, align 8
  br label %am_again

am_again:                                         ; preds = %if.then
  %8 = load %struct.sv*, %struct.sv** %arg, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %8, i32 0, i32 2
  %9 = load i32, i32* %sv_flags, align 4
  %and = and i32 %9, 268435456
  %tobool2 = icmp ne i32 %and, 0
  br i1 %tobool2, label %land.lhs.true, label %if.end.15

land.lhs.true:                                    ; preds = %am_again
  %10 = load %struct.sv*, %struct.sv** %arg, align 8
  %call = call %struct.sv* @Perl_amagic_call(%struct.sv* %10, %struct.sv* @PL_sv_undef, i32 1, i32 9)
  store %struct.sv* %call, %struct.sv** %tmpsv, align 8
  %tobool3 = icmp ne %struct.sv* %call, null
  br i1 %tobool3, label %if.then.4, label %if.end.15

if.then.4:                                        ; preds = %land.lhs.true
  %11 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %11, %struct.sv*** %sp, align 8
  %12 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags5 = getelementptr inbounds %struct.sv, %struct.sv* %12, i32 0, i32 2
  %13 = load i32, i32* %sv_flags5, align 4
  %and6 = and i32 %13, 1024
  %tobool7 = icmp ne i32 %and6, 0
  br i1 %tobool7, label %if.then.8, label %if.else

if.then.8:                                        ; preds = %if.then.4
  %14 = load %struct.sv*, %struct.sv** %targ, align 8
  %15 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  call void @Perl_sv_setsv_flags(%struct.sv* %14, %struct.sv* %15, i32 2)
  %16 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags9 = getelementptr inbounds %struct.sv, %struct.sv* %16, i32 0, i32 2
  %17 = load i32, i32* %sv_flags9, align 4
  %and10 = and i32 %17, 16384
  %tobool11 = icmp ne i32 %and10, 0
  br i1 %tobool11, label %if.then.12, label %if.end

if.then.12:                                       ; preds = %if.then.8
  %18 = load %struct.sv*, %struct.sv** %targ, align 8
  %call13 = call i32 @Perl_mg_set(%struct.sv* %18)
  br label %if.end

if.end:                                           ; preds = %if.then.12, %if.then.8
  %19 = load %struct.sv*, %struct.sv** %targ, align 8
  %20 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %19, %struct.sv** %20, align 8
  store %struct.sv* %19, %struct.sv** %tmp
  %21 = load %struct.sv*, %struct.sv** %tmp
  br label %if.end.14

if.else:                                          ; preds = %if.then.4
  %22 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %23 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %22, %struct.sv** %23, align 8
  br label %if.end.14

if.end.14:                                        ; preds = %if.else, %if.end
  %24 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %24, %struct.sv*** @PL_stack_sp, align 8
  %25 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %25, i32 0, i32 0
  %26 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %26, %struct.op** %retval
  br label %return

if.end.15:                                        ; preds = %land.lhs.true, %am_again
  br label %if.end.16

if.end.16:                                        ; preds = %if.end.15, %entry
  %27 = load %struct.sv**, %struct.sv*** %sp, align 8
  %28 = load %struct.sv*, %struct.sv** %27, align 8
  %sv_flags18 = getelementptr inbounds %struct.sv, %struct.sv* %28, i32 0, i32 2
  %29 = load i32, i32* %sv_flags18, align 4
  %and19 = and i32 %29, 65536
  %tobool20 = icmp ne i32 %and19, 0
  br i1 %tobool20, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.16
  %30 = load %struct.sv**, %struct.sv*** %sp, align 8
  %31 = load %struct.sv*, %struct.sv** %30, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %31, i32 0, i32 0
  %32 = load i8*, i8** %sv_any, align 8
  %33 = bitcast i8* %32 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %33, i32 0, i32 3
  %34 = load i64, i64* %xiv_iv, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end.16
  %35 = load %struct.sv**, %struct.sv*** %sp, align 8
  %36 = load %struct.sv*, %struct.sv** %35, align 8
  %call21 = call i64 @Perl_sv_2iv(%struct.sv* %36)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %34, %cond.true ], [ %call21, %cond.false ]
  store i64 %cond, i64* %iv, align 8
  %37 = load %struct.sv**, %struct.sv*** %sp, align 8
  %38 = load %struct.sv*, %struct.sv** %37, align 8
  %sv_flags22 = getelementptr inbounds %struct.sv, %struct.sv* %38, i32 0, i32 2
  %39 = load i32, i32* %sv_flags22, align 4
  %and23 = and i32 %39, 118423552
  %tobool24 = icmp ne i32 %and23, 0
  br i1 %tobool24, label %if.else.33, label %if.then.25

if.then.25:                                       ; preds = %cond.end
  %40 = load %struct.sv*, %struct.sv** %targ, align 8
  call void @Perl_sv_setuv(%struct.sv* %40, i64 0)
  %41 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags26 = getelementptr inbounds %struct.sv, %struct.sv* %41, i32 0, i32 2
  %42 = load i32, i32* %sv_flags26, align 4
  %and27 = and i32 %42, 16384
  %tobool28 = icmp ne i32 %and27, 0
  br i1 %tobool28, label %if.then.29, label %if.end.31

if.then.29:                                       ; preds = %if.then.25
  %43 = load %struct.sv*, %struct.sv** %targ, align 8
  %call30 = call i32 @Perl_mg_set(%struct.sv* %43)
  br label %if.end.31

if.end.31:                                        ; preds = %if.then.29, %if.then.25
  %44 = load %struct.sv*, %struct.sv** %targ, align 8
  %45 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %44, %struct.sv** %45, align 8
  store %struct.sv* %44, %struct.sv** %tmp32
  %46 = load %struct.sv*, %struct.sv** %tmp32
  br label %if.end.111

if.else.33:                                       ; preds = %cond.end
  %47 = load %struct.sv**, %struct.sv*** %sp, align 8
  %48 = load %struct.sv*, %struct.sv** %47, align 8
  %sv_flags34 = getelementptr inbounds %struct.sv, %struct.sv* %48, i32 0, i32 2
  %49 = load i32, i32* %sv_flags34, align 4
  %and35 = and i32 %49, 65536
  %tobool36 = icmp ne i32 %and35, 0
  br i1 %tobool36, label %if.then.37, label %if.else.88

if.then.37:                                       ; preds = %if.else.33
  %50 = load %struct.sv**, %struct.sv*** %sp, align 8
  %51 = load %struct.sv*, %struct.sv** %50, align 8
  %sv_flags38 = getelementptr inbounds %struct.sv, %struct.sv* %51, i32 0, i32 2
  %52 = load i32, i32* %sv_flags38, align 4
  %and39 = and i32 %52, -2147483648
  %tobool40 = icmp ne i32 %and39, 0
  br i1 %tobool40, label %if.then.41, label %if.else.58

if.then.41:                                       ; preds = %if.then.37
  %53 = load %struct.sv*, %struct.sv** %targ, align 8
  %54 = load %struct.sv**, %struct.sv*** %sp, align 8
  %55 = load %struct.sv*, %struct.sv** %54, align 8
  %sv_flags42 = getelementptr inbounds %struct.sv, %struct.sv* %55, i32 0, i32 2
  %56 = load i32, i32* %sv_flags42, align 4
  %and43 = and i32 %56, 65536
  %tobool44 = icmp ne i32 %and43, 0
  br i1 %tobool44, label %cond.true.45, label %cond.false.47

cond.true.45:                                     ; preds = %if.then.41
  %57 = load %struct.sv**, %struct.sv*** %sp, align 8
  %58 = load %struct.sv*, %struct.sv** %57, align 8
  %sv_any46 = getelementptr inbounds %struct.sv, %struct.sv* %58, i32 0, i32 0
  %59 = load i8*, i8** %sv_any46, align 8
  %60 = bitcast i8* %59 to %struct.xpvuv*
  %xuv_uv = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %60, i32 0, i32 3
  %61 = load i64, i64* %xuv_uv, align 8
  br label %cond.end.49

cond.false.47:                                    ; preds = %if.then.41
  %62 = load %struct.sv**, %struct.sv*** %sp, align 8
  %63 = load %struct.sv*, %struct.sv** %62, align 8
  %call48 = call i64 @Perl_sv_2uv(%struct.sv* %63)
  br label %cond.end.49

cond.end.49:                                      ; preds = %cond.false.47, %cond.true.45
  %cond50 = phi i64 [ %61, %cond.true.45 ], [ %call48, %cond.false.47 ]
  call void @Perl_sv_setuv(%struct.sv* %53, i64 %cond50)
  %64 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags51 = getelementptr inbounds %struct.sv, %struct.sv* %64, i32 0, i32 2
  %65 = load i32, i32* %sv_flags51, align 4
  %and52 = and i32 %65, 16384
  %tobool53 = icmp ne i32 %and52, 0
  br i1 %tobool53, label %if.then.54, label %if.end.56

if.then.54:                                       ; preds = %cond.end.49
  %66 = load %struct.sv*, %struct.sv** %targ, align 8
  %call55 = call i32 @Perl_mg_set(%struct.sv* %66)
  br label %if.end.56

if.end.56:                                        ; preds = %if.then.54, %cond.end.49
  %67 = load %struct.sv*, %struct.sv** %targ, align 8
  %68 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %67, %struct.sv** %68, align 8
  store %struct.sv* %67, %struct.sv** %tmp57
  %69 = load %struct.sv*, %struct.sv** %tmp57
  br label %if.end.87

if.else.58:                                       ; preds = %if.then.37
  %70 = load i64, i64* %iv, align 8
  %cmp = icmp sge i64 %70, 0
  br i1 %cmp, label %if.then.59, label %if.else.67

if.then.59:                                       ; preds = %if.else.58
  %71 = load %struct.sv*, %struct.sv** %targ, align 8
  %72 = load i64, i64* %iv, align 8
  call void @Perl_sv_setiv(%struct.sv* %71, i64 %72)
  %73 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags60 = getelementptr inbounds %struct.sv, %struct.sv* %73, i32 0, i32 2
  %74 = load i32, i32* %sv_flags60, align 4
  %and61 = and i32 %74, 16384
  %tobool62 = icmp ne i32 %and61, 0
  br i1 %tobool62, label %if.then.63, label %if.end.65

if.then.63:                                       ; preds = %if.then.59
  %75 = load %struct.sv*, %struct.sv** %targ, align 8
  %call64 = call i32 @Perl_mg_set(%struct.sv* %75)
  br label %if.end.65

if.end.65:                                        ; preds = %if.then.63, %if.then.59
  %76 = load %struct.sv*, %struct.sv** %targ, align 8
  %77 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %76, %struct.sv** %77, align 8
  store %struct.sv* %76, %struct.sv** %tmp66
  %78 = load %struct.sv*, %struct.sv** %tmp66
  br label %if.end.86

if.else.67:                                       ; preds = %if.else.58
  %79 = load i64, i64* %iv, align 8
  %cmp68 = icmp ne i64 %79, -9223372036854775808
  br i1 %cmp68, label %if.then.69, label %if.else.77

if.then.69:                                       ; preds = %if.else.67
  %80 = load %struct.sv*, %struct.sv** %targ, align 8
  %81 = load i64, i64* %iv, align 8
  %sub = sub nsw i64 0, %81
  call void @Perl_sv_setiv(%struct.sv* %80, i64 %sub)
  %82 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags70 = getelementptr inbounds %struct.sv, %struct.sv* %82, i32 0, i32 2
  %83 = load i32, i32* %sv_flags70, align 4
  %and71 = and i32 %83, 16384
  %tobool72 = icmp ne i32 %and71, 0
  br i1 %tobool72, label %if.then.73, label %if.end.75

if.then.73:                                       ; preds = %if.then.69
  %84 = load %struct.sv*, %struct.sv** %targ, align 8
  %call74 = call i32 @Perl_mg_set(%struct.sv* %84)
  br label %if.end.75

if.end.75:                                        ; preds = %if.then.73, %if.then.69
  %85 = load %struct.sv*, %struct.sv** %targ, align 8
  %86 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %85, %struct.sv** %86, align 8
  store %struct.sv* %85, %struct.sv** %tmp76
  %87 = load %struct.sv*, %struct.sv** %tmp76
  br label %if.end.85

if.else.77:                                       ; preds = %if.else.67
  %88 = load %struct.sv*, %struct.sv** %targ, align 8
  call void @Perl_sv_setuv(%struct.sv* %88, i64 -9223372036854775808)
  %89 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags78 = getelementptr inbounds %struct.sv, %struct.sv* %89, i32 0, i32 2
  %90 = load i32, i32* %sv_flags78, align 4
  %and79 = and i32 %90, 16384
  %tobool80 = icmp ne i32 %and79, 0
  br i1 %tobool80, label %if.then.81, label %if.end.83

if.then.81:                                       ; preds = %if.else.77
  %91 = load %struct.sv*, %struct.sv** %targ, align 8
  %call82 = call i32 @Perl_mg_set(%struct.sv* %91)
  br label %if.end.83

if.end.83:                                        ; preds = %if.then.81, %if.else.77
  %92 = load %struct.sv*, %struct.sv** %targ, align 8
  %93 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %92, %struct.sv** %93, align 8
  store %struct.sv* %92, %struct.sv** %tmp84
  %94 = load %struct.sv*, %struct.sv** %tmp84
  br label %if.end.85

if.end.85:                                        ; preds = %if.end.83, %if.end.75
  br label %if.end.86

if.end.86:                                        ; preds = %if.end.85, %if.end.65
  br label %if.end.87

if.end.87:                                        ; preds = %if.end.86, %if.end.56
  br label %if.end.110

if.else.88:                                       ; preds = %if.else.33
  %95 = load %struct.sv**, %struct.sv*** %sp, align 8
  %96 = load %struct.sv*, %struct.sv** %95, align 8
  %sv_flags90 = getelementptr inbounds %struct.sv, %struct.sv* %96, i32 0, i32 2
  %97 = load i32, i32* %sv_flags90, align 4
  %and91 = and i32 %97, 131072
  %tobool92 = icmp ne i32 %and91, 0
  br i1 %tobool92, label %cond.true.93, label %cond.false.95

cond.true.93:                                     ; preds = %if.else.88
  %98 = load %struct.sv**, %struct.sv*** %sp, align 8
  %99 = load %struct.sv*, %struct.sv** %98, align 8
  %sv_any94 = getelementptr inbounds %struct.sv, %struct.sv* %99, i32 0, i32 0
  %100 = load i8*, i8** %sv_any94, align 8
  %101 = bitcast i8* %100 to %struct.xpvnv*
  %xnv_nv = getelementptr inbounds %struct.xpvnv, %struct.xpvnv* %101, i32 0, i32 4
  %102 = load double, double* %xnv_nv, align 8
  br label %cond.end.97

cond.false.95:                                    ; preds = %if.else.88
  %103 = load %struct.sv**, %struct.sv*** %sp, align 8
  %104 = load %struct.sv*, %struct.sv** %103, align 8
  %call96 = call double @Perl_sv_2nv(%struct.sv* %104)
  br label %cond.end.97

cond.end.97:                                      ; preds = %cond.false.95, %cond.true.93
  %cond98 = phi double [ %102, %cond.true.93 ], [ %call96, %cond.false.95 ]
  store double %cond98, double* %value, align 8
  %105 = load double, double* %value, align 8
  %cmp99 = fcmp olt double %105, 0.000000e+00
  br i1 %cmp99, label %if.then.100, label %if.end.102

if.then.100:                                      ; preds = %cond.end.97
  %106 = load double, double* %value, align 8
  %sub101 = fsub double -0.000000e+00, %106
  store double %sub101, double* %value, align 8
  br label %if.end.102

if.end.102:                                       ; preds = %if.then.100, %cond.end.97
  %107 = load %struct.sv*, %struct.sv** %targ, align 8
  %108 = load double, double* %value, align 8
  call void @Perl_sv_setnv(%struct.sv* %107, double %108)
  %109 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags103 = getelementptr inbounds %struct.sv, %struct.sv* %109, i32 0, i32 2
  %110 = load i32, i32* %sv_flags103, align 4
  %and104 = and i32 %110, 16384
  %tobool105 = icmp ne i32 %and104, 0
  br i1 %tobool105, label %if.then.106, label %if.end.108

if.then.106:                                      ; preds = %if.end.102
  %111 = load %struct.sv*, %struct.sv** %targ, align 8
  %call107 = call i32 @Perl_mg_set(%struct.sv* %111)
  br label %if.end.108

if.end.108:                                       ; preds = %if.then.106, %if.end.102
  %112 = load %struct.sv*, %struct.sv** %targ, align 8
  %113 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %112, %struct.sv** %113, align 8
  store %struct.sv* %112, %struct.sv** %tmp109
  %114 = load %struct.sv*, %struct.sv** %tmp109
  br label %if.end.110

if.end.110:                                       ; preds = %if.end.108, %if.end.87
  br label %if.end.111

if.end.111:                                       ; preds = %if.end.110, %if.end.31
  %115 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %115, %struct.sv*** @PL_stack_sp, align 8
  %116 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next112 = getelementptr inbounds %struct.op, %struct.op* %116, i32 0, i32 0
  %117 = load %struct.op*, %struct.op** %op_next112, align 8
  store %struct.op* %117, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.111, %if.end.14
  %118 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %118
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_hex() #0 {
entry:
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %tmps = alloca i8*, align 8
  %flags = alloca i32, align 4
  %len = alloca i64, align 8
  %result_nv = alloca double, align 8
  %result_uv = alloca i64, align 8
  %sv = alloca %struct.sv*, align 8
  %tsv = alloca %struct.sv*, align 8
  %tmp = alloca %struct.sv*, align 8
  %tmp43 = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 3
  %2 = load i64, i64* %op_targ, align 8
  %3 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 %2
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %4, %struct.sv** %targ, align 8
  store i32 1, i32* %flags, align 4
  %5 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %5, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %6 = load %struct.sv*, %struct.sv** %5, align 8
  store %struct.sv* %6, %struct.sv** %sv, align 8
  %7 = load %struct.sv*, %struct.sv** %sv, align 8
  store %struct.sv* %7, %struct.sv** @PL_Sv, align 8
  %8 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %8, i32 0, i32 2
  %9 = load i32, i32* %sv_flags, align 4
  %and = and i32 %9, 262144
  %cmp = icmp eq i32 %and, 262144
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %10 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %10, i32 0, i32 0
  %11 = load i8*, i8** %sv_any, align 8
  %12 = bitcast i8* %11 to %struct.xpv*
  %xpv_cur = getelementptr inbounds %struct.xpv, %struct.xpv* %12, i32 0, i32 1
  %13 = load i64, i64* %xpv_cur, align 8
  store i64 %13, i64* %len, align 8
  %14 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any1 = getelementptr inbounds %struct.sv, %struct.sv* %14, i32 0, i32 0
  %15 = load i8*, i8** %sv_any1, align 8
  %16 = bitcast i8* %15 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %16, i32 0, i32 0
  %17 = load i8*, i8** %xpv_pv, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %18 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call = call i8* @Perl_sv_2pv_flags(%struct.sv* %18, i64* %len, i32 2)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %17, %cond.true ], [ %call, %cond.false ]
  store i8* %cond, i8** %tmps, align 8
  %19 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags2 = getelementptr inbounds %struct.sv, %struct.sv* %19, i32 0, i32 2
  %20 = load i32, i32* %sv_flags2, align 4
  %and3 = and i32 %20, 536870912
  %tobool = icmp ne i32 %and3, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %cond.end
  %21 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %op_private = getelementptr inbounds %struct.cop, %struct.cop* %21, i32 0, i32 7
  %22 = load i8, i8* %op_private, align 1
  %conv = zext i8 %22 to i32
  %and4 = and i32 %conv, 8
  %tobool5 = icmp ne i32 %and4, 0
  br i1 %tobool5, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %23 = load %struct.sv*, %struct.sv** %sv, align 8
  %call6 = call %struct.sv* @Perl_newSVsv(%struct.sv* %23)
  %call7 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call6)
  store %struct.sv* %call7, %struct.sv** %tsv, align 8
  %24 = load %struct.sv*, %struct.sv** %tsv, align 8
  %sv_flags8 = getelementptr inbounds %struct.sv, %struct.sv* %24, i32 0, i32 2
  %25 = load i32, i32* %sv_flags8, align 4
  %or = or i32 %25, 536870912
  store i32 %or, i32* %sv_flags8, align 4
  %26 = load %struct.sv*, %struct.sv** %tsv, align 8
  %call9 = call signext i8 @Perl_sv_utf8_downgrade(%struct.sv* %26, i8 signext 0)
  %27 = load %struct.sv*, %struct.sv** %tsv, align 8
  %sv_any10 = getelementptr inbounds %struct.sv, %struct.sv* %27, i32 0, i32 0
  %28 = load i8*, i8** %sv_any10, align 8
  %29 = bitcast i8* %28 to %struct.xpv*
  %xpv_pv11 = getelementptr inbounds %struct.xpv, %struct.xpv* %29, i32 0, i32 0
  %30 = load i8*, i8** %xpv_pv11, align 8
  store i8* %30, i8** %tmps, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %cond.end
  %31 = load i8*, i8** %tmps, align 8
  %call12 = call i64 @Perl_grok_hex(i8* %31, i64* %len, i32* %flags, double* %result_nv)
  store i64 %call12, i64* %result_uv, align 8
  %32 = load i32, i32* %flags, align 4
  %and13 = and i32 %32, 2
  %tobool14 = icmp ne i32 %and13, 0
  br i1 %tobool14, label %if.then.15, label %if.else

if.then.15:                                       ; preds = %if.end
  %33 = load %struct.sv*, %struct.sv** %targ, align 8
  %34 = load double, double* %result_nv, align 8
  call void @Perl_sv_setnv(%struct.sv* %33, double %34)
  %35 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags16 = getelementptr inbounds %struct.sv, %struct.sv* %35, i32 0, i32 2
  %36 = load i32, i32* %sv_flags16, align 4
  %and17 = and i32 %36, 16384
  %tobool18 = icmp ne i32 %and17, 0
  br i1 %tobool18, label %if.then.19, label %if.end.21

if.then.19:                                       ; preds = %if.then.15
  %37 = load %struct.sv*, %struct.sv** %targ, align 8
  %call20 = call i32 @Perl_mg_set(%struct.sv* %37)
  br label %if.end.21

if.end.21:                                        ; preds = %if.then.19, %if.then.15
  %38 = load %struct.sv**, %struct.sv*** @PL_stack_max, align 8
  %39 = load %struct.sv**, %struct.sv*** %sp, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %38 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %39 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %cmp22 = icmp slt i64 %sub.ptr.div, 1
  br i1 %cmp22, label %if.then.24, label %if.end.26

if.then.24:                                       ; preds = %if.end.21
  %40 = load %struct.sv**, %struct.sv*** %sp, align 8
  %41 = load %struct.sv**, %struct.sv*** %sp, align 8
  %call25 = call %struct.sv** @Perl_stack_grow(%struct.sv** %40, %struct.sv** %41, i32 1)
  store %struct.sv** %call25, %struct.sv*** %sp, align 8
  br label %if.end.26

if.end.26:                                        ; preds = %if.then.24, %if.end.21
  %42 = load %struct.sv*, %struct.sv** %targ, align 8
  %43 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr27 = getelementptr inbounds %struct.sv*, %struct.sv** %43, i32 1
  store %struct.sv** %incdec.ptr27, %struct.sv*** %sp, align 8
  store %struct.sv* %42, %struct.sv** %incdec.ptr27, align 8
  store %struct.sv* %42, %struct.sv** %tmp
  %44 = load %struct.sv*, %struct.sv** %tmp
  br label %if.end.45

if.else:                                          ; preds = %if.end
  %45 = load %struct.sv*, %struct.sv** %targ, align 8
  %46 = load i64, i64* %result_uv, align 8
  call void @Perl_sv_setuv(%struct.sv* %45, i64 %46)
  %47 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags28 = getelementptr inbounds %struct.sv, %struct.sv* %47, i32 0, i32 2
  %48 = load i32, i32* %sv_flags28, align 4
  %and29 = and i32 %48, 16384
  %tobool30 = icmp ne i32 %and29, 0
  br i1 %tobool30, label %if.then.31, label %if.end.33

if.then.31:                                       ; preds = %if.else
  %49 = load %struct.sv*, %struct.sv** %targ, align 8
  %call32 = call i32 @Perl_mg_set(%struct.sv* %49)
  br label %if.end.33

if.end.33:                                        ; preds = %if.then.31, %if.else
  %50 = load %struct.sv**, %struct.sv*** @PL_stack_max, align 8
  %51 = load %struct.sv**, %struct.sv*** %sp, align 8
  %sub.ptr.lhs.cast34 = ptrtoint %struct.sv** %50 to i64
  %sub.ptr.rhs.cast35 = ptrtoint %struct.sv** %51 to i64
  %sub.ptr.sub36 = sub i64 %sub.ptr.lhs.cast34, %sub.ptr.rhs.cast35
  %sub.ptr.div37 = sdiv exact i64 %sub.ptr.sub36, 8
  %cmp38 = icmp slt i64 %sub.ptr.div37, 1
  br i1 %cmp38, label %if.then.40, label %if.end.42

if.then.40:                                       ; preds = %if.end.33
  %52 = load %struct.sv**, %struct.sv*** %sp, align 8
  %53 = load %struct.sv**, %struct.sv*** %sp, align 8
  %call41 = call %struct.sv** @Perl_stack_grow(%struct.sv** %52, %struct.sv** %53, i32 1)
  store %struct.sv** %call41, %struct.sv*** %sp, align 8
  br label %if.end.42

if.end.42:                                        ; preds = %if.then.40, %if.end.33
  %54 = load %struct.sv*, %struct.sv** %targ, align 8
  %55 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr44 = getelementptr inbounds %struct.sv*, %struct.sv** %55, i32 1
  store %struct.sv** %incdec.ptr44, %struct.sv*** %sp, align 8
  store %struct.sv* %54, %struct.sv** %incdec.ptr44, align 8
  store %struct.sv* %54, %struct.sv** %tmp43
  %56 = load %struct.sv*, %struct.sv** %tmp43
  br label %if.end.45

if.end.45:                                        ; preds = %if.end.42, %if.end.26
  %57 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %57, %struct.sv*** @PL_stack_sp, align 8
  %58 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %58, i32 0, i32 0
  %59 = load %struct.op*, %struct.op** %op_next, align 8
  ret %struct.op* %59
}

declare %struct.sv* @Perl_newSVsv(%struct.sv*) #1

declare signext i8 @Perl_sv_utf8_downgrade(%struct.sv*, i8 signext) #1

declare i64 @Perl_grok_hex(i8*, i64*, i32*, double*) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_oct() #0 {
entry:
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %tmps = alloca i8*, align 8
  %flags = alloca i32, align 4
  %len = alloca i64, align 8
  %result_nv = alloca double, align 8
  %result_uv = alloca i64, align 8
  %sv = alloca %struct.sv*, align 8
  %tsv = alloca %struct.sv*, align 8
  %tmp = alloca %struct.sv*, align 8
  %tmp86 = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 3
  %2 = load i64, i64* %op_targ, align 8
  %3 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 %2
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %4, %struct.sv** %targ, align 8
  store i32 1, i32* %flags, align 4
  %5 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %5, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %6 = load %struct.sv*, %struct.sv** %5, align 8
  store %struct.sv* %6, %struct.sv** %sv, align 8
  %7 = load %struct.sv*, %struct.sv** %sv, align 8
  store %struct.sv* %7, %struct.sv** @PL_Sv, align 8
  %8 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %8, i32 0, i32 2
  %9 = load i32, i32* %sv_flags, align 4
  %and = and i32 %9, 262144
  %cmp = icmp eq i32 %and, 262144
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %10 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %10, i32 0, i32 0
  %11 = load i8*, i8** %sv_any, align 8
  %12 = bitcast i8* %11 to %struct.xpv*
  %xpv_cur = getelementptr inbounds %struct.xpv, %struct.xpv* %12, i32 0, i32 1
  %13 = load i64, i64* %xpv_cur, align 8
  store i64 %13, i64* %len, align 8
  %14 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any1 = getelementptr inbounds %struct.sv, %struct.sv* %14, i32 0, i32 0
  %15 = load i8*, i8** %sv_any1, align 8
  %16 = bitcast i8* %15 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %16, i32 0, i32 0
  %17 = load i8*, i8** %xpv_pv, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %18 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call = call i8* @Perl_sv_2pv_flags(%struct.sv* %18, i64* %len, i32 2)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %17, %cond.true ], [ %call, %cond.false ]
  store i8* %cond, i8** %tmps, align 8
  %19 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags2 = getelementptr inbounds %struct.sv, %struct.sv* %19, i32 0, i32 2
  %20 = load i32, i32* %sv_flags2, align 4
  %and3 = and i32 %20, 536870912
  %tobool = icmp ne i32 %and3, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %cond.end
  %21 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %op_private = getelementptr inbounds %struct.cop, %struct.cop* %21, i32 0, i32 7
  %22 = load i8, i8* %op_private, align 1
  %conv = zext i8 %22 to i32
  %and4 = and i32 %conv, 8
  %tobool5 = icmp ne i32 %and4, 0
  br i1 %tobool5, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %23 = load %struct.sv*, %struct.sv** %sv, align 8
  %call6 = call %struct.sv* @Perl_newSVsv(%struct.sv* %23)
  %call7 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call6)
  store %struct.sv* %call7, %struct.sv** %tsv, align 8
  %24 = load %struct.sv*, %struct.sv** %tsv, align 8
  %sv_flags8 = getelementptr inbounds %struct.sv, %struct.sv* %24, i32 0, i32 2
  %25 = load i32, i32* %sv_flags8, align 4
  %or = or i32 %25, 536870912
  store i32 %or, i32* %sv_flags8, align 4
  %26 = load %struct.sv*, %struct.sv** %tsv, align 8
  %call9 = call signext i8 @Perl_sv_utf8_downgrade(%struct.sv* %26, i8 signext 0)
  %27 = load %struct.sv*, %struct.sv** %tsv, align 8
  %sv_any10 = getelementptr inbounds %struct.sv, %struct.sv* %27, i32 0, i32 0
  %28 = load i8*, i8** %sv_any10, align 8
  %29 = bitcast i8* %28 to %struct.xpv*
  %xpv_pv11 = getelementptr inbounds %struct.xpv, %struct.xpv* %29, i32 0, i32 0
  %30 = load i8*, i8** %xpv_pv11, align 8
  store i8* %30, i8** %tmps, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %cond.end
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end
  %31 = load i8*, i8** %tmps, align 8
  %32 = load i8, i8* %31, align 1
  %conv12 = sext i8 %32 to i32
  %tobool13 = icmp ne i32 %conv12, 0
  br i1 %tobool13, label %land.lhs.true.14, label %land.end

land.lhs.true.14:                                 ; preds = %while.cond
  %33 = load i64, i64* %len, align 8
  %tobool15 = icmp ne i64 %33, 0
  br i1 %tobool15, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true.14
  %34 = load i8*, i8** %tmps, align 8
  %35 = load i8, i8* %34, align 1
  %conv16 = sext i8 %35 to i32
  %cmp17 = icmp eq i32 %conv16, 32
  br i1 %cmp17, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.rhs
  %36 = load i8*, i8** %tmps, align 8
  %37 = load i8, i8* %36, align 1
  %conv19 = sext i8 %37 to i32
  %cmp20 = icmp eq i32 %conv19, 9
  br i1 %cmp20, label %lor.end, label %lor.lhs.false.22

lor.lhs.false.22:                                 ; preds = %lor.lhs.false
  %38 = load i8*, i8** %tmps, align 8
  %39 = load i8, i8* %38, align 1
  %conv23 = sext i8 %39 to i32
  %cmp24 = icmp eq i32 %conv23, 10
  br i1 %cmp24, label %lor.end, label %lor.lhs.false.26

lor.lhs.false.26:                                 ; preds = %lor.lhs.false.22
  %40 = load i8*, i8** %tmps, align 8
  %41 = load i8, i8* %40, align 1
  %conv27 = sext i8 %41 to i32
  %cmp28 = icmp eq i32 %conv27, 13
  br i1 %cmp28, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false.26
  %42 = load i8*, i8** %tmps, align 8
  %43 = load i8, i8* %42, align 1
  %conv30 = sext i8 %43 to i32
  %cmp31 = icmp eq i32 %conv30, 12
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false.26, %lor.lhs.false.22, %lor.lhs.false, %land.rhs
  %44 = phi i1 [ true, %lor.lhs.false.26 ], [ true, %lor.lhs.false.22 ], [ true, %lor.lhs.false ], [ true, %land.rhs ], [ %cmp31, %lor.rhs ]
  br label %land.end

land.end:                                         ; preds = %lor.end, %land.lhs.true.14, %while.cond
  %45 = phi i1 [ false, %land.lhs.true.14 ], [ false, %while.cond ], [ %44, %lor.end ]
  br i1 %45, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %46 = load i8*, i8** %tmps, align 8
  %incdec.ptr33 = getelementptr inbounds i8, i8* %46, i32 1
  store i8* %incdec.ptr33, i8** %tmps, align 8
  %47 = load i64, i64* %len, align 8
  %dec = add i64 %47, -1
  store i64 %dec, i64* %len, align 8
  br label %while.cond

while.end:                                        ; preds = %land.end
  %48 = load i8*, i8** %tmps, align 8
  %49 = load i8, i8* %48, align 1
  %conv34 = sext i8 %49 to i32
  %cmp35 = icmp eq i32 %conv34, 48
  br i1 %cmp35, label %if.then.37, label %if.end.40

if.then.37:                                       ; preds = %while.end
  %50 = load i8*, i8** %tmps, align 8
  %incdec.ptr38 = getelementptr inbounds i8, i8* %50, i32 1
  store i8* %incdec.ptr38, i8** %tmps, align 8
  %51 = load i64, i64* %len, align 8
  %dec39 = add i64 %51, -1
  store i64 %dec39, i64* %len, align 8
  br label %if.end.40

if.end.40:                                        ; preds = %if.then.37, %while.end
  %52 = load i8*, i8** %tmps, align 8
  %53 = load i8, i8* %52, align 1
  %conv41 = sext i8 %53 to i32
  %cmp42 = icmp eq i32 %conv41, 120
  br i1 %cmp42, label %if.then.44, label %if.else

if.then.44:                                       ; preds = %if.end.40
  %54 = load i8*, i8** %tmps, align 8
  %call45 = call i64 @Perl_grok_hex(i8* %54, i64* %len, i32* %flags, double* %result_nv)
  store i64 %call45, i64* %result_uv, align 8
  br label %if.end.54

if.else:                                          ; preds = %if.end.40
  %55 = load i8*, i8** %tmps, align 8
  %56 = load i8, i8* %55, align 1
  %conv46 = sext i8 %56 to i32
  %cmp47 = icmp eq i32 %conv46, 98
  br i1 %cmp47, label %if.then.49, label %if.else.51

if.then.49:                                       ; preds = %if.else
  %57 = load i8*, i8** %tmps, align 8
  %call50 = call i64 @Perl_grok_bin(i8* %57, i64* %len, i32* %flags, double* %result_nv)
  store i64 %call50, i64* %result_uv, align 8
  br label %if.end.53

if.else.51:                                       ; preds = %if.else
  %58 = load i8*, i8** %tmps, align 8
  %call52 = call i64 @Perl_grok_oct(i8* %58, i64* %len, i32* %flags, double* %result_nv)
  store i64 %call52, i64* %result_uv, align 8
  br label %if.end.53

if.end.53:                                        ; preds = %if.else.51, %if.then.49
  br label %if.end.54

if.end.54:                                        ; preds = %if.end.53, %if.then.44
  %59 = load i32, i32* %flags, align 4
  %and55 = and i32 %59, 2
  %tobool56 = icmp ne i32 %and55, 0
  br i1 %tobool56, label %if.then.57, label %if.else.70

if.then.57:                                       ; preds = %if.end.54
  %60 = load %struct.sv*, %struct.sv** %targ, align 8
  %61 = load double, double* %result_nv, align 8
  call void @Perl_sv_setnv(%struct.sv* %60, double %61)
  %62 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags58 = getelementptr inbounds %struct.sv, %struct.sv* %62, i32 0, i32 2
  %63 = load i32, i32* %sv_flags58, align 4
  %and59 = and i32 %63, 16384
  %tobool60 = icmp ne i32 %and59, 0
  br i1 %tobool60, label %if.then.61, label %if.end.63

if.then.61:                                       ; preds = %if.then.57
  %64 = load %struct.sv*, %struct.sv** %targ, align 8
  %call62 = call i32 @Perl_mg_set(%struct.sv* %64)
  br label %if.end.63

if.end.63:                                        ; preds = %if.then.61, %if.then.57
  %65 = load %struct.sv**, %struct.sv*** @PL_stack_max, align 8
  %66 = load %struct.sv**, %struct.sv*** %sp, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %65 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %66 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %cmp64 = icmp slt i64 %sub.ptr.div, 1
  br i1 %cmp64, label %if.then.66, label %if.end.68

if.then.66:                                       ; preds = %if.end.63
  %67 = load %struct.sv**, %struct.sv*** %sp, align 8
  %68 = load %struct.sv**, %struct.sv*** %sp, align 8
  %call67 = call %struct.sv** @Perl_stack_grow(%struct.sv** %67, %struct.sv** %68, i32 1)
  store %struct.sv** %call67, %struct.sv*** %sp, align 8
  br label %if.end.68

if.end.68:                                        ; preds = %if.then.66, %if.end.63
  %69 = load %struct.sv*, %struct.sv** %targ, align 8
  %70 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr69 = getelementptr inbounds %struct.sv*, %struct.sv** %70, i32 1
  store %struct.sv** %incdec.ptr69, %struct.sv*** %sp, align 8
  store %struct.sv* %69, %struct.sv** %incdec.ptr69, align 8
  store %struct.sv* %69, %struct.sv** %tmp
  %71 = load %struct.sv*, %struct.sv** %tmp
  br label %if.end.88

if.else.70:                                       ; preds = %if.end.54
  %72 = load %struct.sv*, %struct.sv** %targ, align 8
  %73 = load i64, i64* %result_uv, align 8
  call void @Perl_sv_setuv(%struct.sv* %72, i64 %73)
  %74 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags71 = getelementptr inbounds %struct.sv, %struct.sv* %74, i32 0, i32 2
  %75 = load i32, i32* %sv_flags71, align 4
  %and72 = and i32 %75, 16384
  %tobool73 = icmp ne i32 %and72, 0
  br i1 %tobool73, label %if.then.74, label %if.end.76

if.then.74:                                       ; preds = %if.else.70
  %76 = load %struct.sv*, %struct.sv** %targ, align 8
  %call75 = call i32 @Perl_mg_set(%struct.sv* %76)
  br label %if.end.76

if.end.76:                                        ; preds = %if.then.74, %if.else.70
  %77 = load %struct.sv**, %struct.sv*** @PL_stack_max, align 8
  %78 = load %struct.sv**, %struct.sv*** %sp, align 8
  %sub.ptr.lhs.cast77 = ptrtoint %struct.sv** %77 to i64
  %sub.ptr.rhs.cast78 = ptrtoint %struct.sv** %78 to i64
  %sub.ptr.sub79 = sub i64 %sub.ptr.lhs.cast77, %sub.ptr.rhs.cast78
  %sub.ptr.div80 = sdiv exact i64 %sub.ptr.sub79, 8
  %cmp81 = icmp slt i64 %sub.ptr.div80, 1
  br i1 %cmp81, label %if.then.83, label %if.end.85

if.then.83:                                       ; preds = %if.end.76
  %79 = load %struct.sv**, %struct.sv*** %sp, align 8
  %80 = load %struct.sv**, %struct.sv*** %sp, align 8
  %call84 = call %struct.sv** @Perl_stack_grow(%struct.sv** %79, %struct.sv** %80, i32 1)
  store %struct.sv** %call84, %struct.sv*** %sp, align 8
  br label %if.end.85

if.end.85:                                        ; preds = %if.then.83, %if.end.76
  %81 = load %struct.sv*, %struct.sv** %targ, align 8
  %82 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr87 = getelementptr inbounds %struct.sv*, %struct.sv** %82, i32 1
  store %struct.sv** %incdec.ptr87, %struct.sv*** %sp, align 8
  store %struct.sv* %81, %struct.sv** %incdec.ptr87, align 8
  store %struct.sv* %81, %struct.sv** %tmp86
  %83 = load %struct.sv*, %struct.sv** %tmp86
  br label %if.end.88

if.end.88:                                        ; preds = %if.end.85, %if.end.68
  %84 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %84, %struct.sv*** @PL_stack_sp, align 8
  %85 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %85, i32 0, i32 0
  %86 = load %struct.op*, %struct.op** %op_next, align 8
  ret %struct.op* %86
}

declare i64 @Perl_grok_bin(i8*, i64*, i32*, double*) #1

declare i64 @Perl_grok_oct(i8*, i64*, i32*, double*) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_length() #0 {
entry:
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %sv = alloca %struct.sv*, align 8
  %tmp = alloca %struct.sv*, align 8
  %tmp15 = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 3
  %2 = load i64, i64* %op_targ, align 8
  %3 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 %2
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %4, %struct.sv** %targ, align 8
  %5 = load %struct.sv**, %struct.sv*** %sp, align 8
  %6 = load %struct.sv*, %struct.sv** %5, align 8
  store %struct.sv* %6, %struct.sv** %sv, align 8
  %7 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %7, i32 0, i32 2
  %8 = load i32, i32* %sv_flags, align 4
  %and = and i32 %8, 536870912
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %9 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %op_private = getelementptr inbounds %struct.cop, %struct.cop* %9, i32 0, i32 7
  %10 = load i8, i8* %op_private, align 1
  %conv = zext i8 %10 to i32
  %and1 = and i32 %conv, 8
  %tobool2 = icmp ne i32 %and1, 0
  br i1 %tobool2, label %if.else, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %11 = load %struct.sv*, %struct.sv** %targ, align 8
  %12 = load %struct.sv*, %struct.sv** %sv, align 8
  %call = call i64 @Perl_sv_len_utf8(%struct.sv* %12)
  call void @Perl_sv_setiv(%struct.sv* %11, i64 %call)
  %13 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags3 = getelementptr inbounds %struct.sv, %struct.sv* %13, i32 0, i32 2
  %14 = load i32, i32* %sv_flags3, align 4
  %and4 = and i32 %14, 16384
  %tobool5 = icmp ne i32 %and4, 0
  br i1 %tobool5, label %if.then.6, label %if.end

if.then.6:                                        ; preds = %if.then
  %15 = load %struct.sv*, %struct.sv** %targ, align 8
  %call7 = call i32 @Perl_mg_set(%struct.sv* %15)
  br label %if.end

if.end:                                           ; preds = %if.then.6, %if.then
  %16 = load %struct.sv*, %struct.sv** %targ, align 8
  %17 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %16, %struct.sv** %17, align 8
  store %struct.sv* %16, %struct.sv** %tmp
  %18 = load %struct.sv*, %struct.sv** %tmp
  br label %if.end.16

if.else:                                          ; preds = %land.lhs.true, %entry
  %19 = load %struct.sv*, %struct.sv** %targ, align 8
  %20 = load %struct.sv*, %struct.sv** %sv, align 8
  %call8 = call i64 @Perl_sv_len(%struct.sv* %20)
  call void @Perl_sv_setiv(%struct.sv* %19, i64 %call8)
  %21 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags9 = getelementptr inbounds %struct.sv, %struct.sv* %21, i32 0, i32 2
  %22 = load i32, i32* %sv_flags9, align 4
  %and10 = and i32 %22, 16384
  %tobool11 = icmp ne i32 %and10, 0
  br i1 %tobool11, label %if.then.12, label %if.end.14

if.then.12:                                       ; preds = %if.else
  %23 = load %struct.sv*, %struct.sv** %targ, align 8
  %call13 = call i32 @Perl_mg_set(%struct.sv* %23)
  br label %if.end.14

if.end.14:                                        ; preds = %if.then.12, %if.else
  %24 = load %struct.sv*, %struct.sv** %targ, align 8
  %25 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %24, %struct.sv** %25, align 8
  store %struct.sv* %24, %struct.sv** %tmp15
  %26 = load %struct.sv*, %struct.sv** %tmp15
  br label %if.end.16

if.end.16:                                        ; preds = %if.end.14, %if.end
  %27 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %27, %struct.sv*** @PL_stack_sp, align 8
  %28 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %28, i32 0, i32 0
  %29 = load %struct.op*, %struct.op** %op_next, align 8
  ret %struct.op* %29
}

declare i64 @Perl_sv_len_utf8(%struct.sv*) #1

declare i64 @Perl_sv_len(%struct.sv*) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_substr() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %sv = alloca %struct.sv*, align 8
  %len = alloca i32, align 4
  %curlen = alloca i64, align 8
  %utf8_curlen = alloca i64, align 8
  %pos = alloca i32, align 4
  %rem = alloca i32, align 4
  %fail = alloca i32, align 4
  %lvalue = alloca i32, align 4
  %tmps = alloca i8*, align 8
  %arybase = alloca i32, align 4
  %repl_sv = alloca %struct.sv*, align 8
  %repl = alloca i8*, align 8
  %repl_len = alloca i64, align 8
  %num_args = alloca i32, align 4
  %repl_need_utf8_upgrade = alloca i8, align 1
  %repl_is_utf8 = alloca i8, align 1
  %upos = alloca i32, align 4
  %urem = alloca i32, align 4
  %repl_sv_copy = alloca %struct.sv*, align 8
  %n_a = alloca i64, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 3
  %2 = load i64, i64* %op_targ, align 8
  %3 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 %2
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %4, %struct.sv** %targ, align 8
  store i32 0, i32* %len, align 4
  %5 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %5, i32 0, i32 6
  %6 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %6 to i32
  %and = and i32 %conv, 32
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %7 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %7, i32 0, i32 7
  %8 = load i8, i8* %op_private, align 1
  %conv1 = zext i8 %8 to i32
  %and2 = and i32 %conv1, 8
  %tobool3 = icmp ne i32 %and2, 0
  br i1 %tobool3, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %lor.rhs
  %call = call i32 @Perl_is_lvalue_sub()
  %tobool4 = icmp ne i32 %call, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %lor.rhs
  %9 = phi i1 [ false, %lor.rhs ], [ %tobool4, %land.rhs ]
  br label %lor.end

lor.end:                                          ; preds = %land.end, %entry
  %10 = phi i1 [ true, %entry ], [ %9, %land.end ]
  %lor.ext = zext i1 %10 to i32
  store i32 %lor.ext, i32* %lvalue, align 4
  %11 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_arybase = getelementptr inbounds %struct.cop, %struct.cop* %11, i32 0, i32 12
  %12 = load i32, i32* %cop_arybase, align 4
  store i32 %12, i32* %arybase, align 4
  store %struct.sv* null, %struct.sv** %repl_sv, align 8
  store i8* null, i8** %repl, align 8
  %13 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_private5 = getelementptr inbounds %struct.op, %struct.op* %13, i32 0, i32 7
  %14 = load i8, i8* %op_private5, align 1
  %conv6 = zext i8 %14 to i32
  %and7 = and i32 %conv6, 7
  store i32 %and7, i32* %num_args, align 4
  store i8 0, i8* %repl_need_utf8_upgrade, align 1
  store i8 0, i8* %repl_is_utf8, align 1
  %15 = load i8, i8* @PL_tainting, align 1
  %tobool8 = icmp ne i8 %15, 0
  br i1 %tobool8, label %if.then, label %if.end

if.then:                                          ; preds = %lor.end
  %16 = load %struct.sv*, %struct.sv** %targ, align 8
  call void @Perl_sv_untaint(%struct.sv* %16)
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.end
  %17 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %17, i32 0, i32 2
  %18 = load i32, i32* %sv_flags, align 4
  %and9 = and i32 %18, -536870913
  store i32 %and9, i32* %sv_flags, align 4
  %19 = load i32, i32* %num_args, align 4
  %cmp = icmp sgt i32 %19, 2
  br i1 %cmp, label %if.then.11, label %if.end.46

if.then.11:                                       ; preds = %if.end
  %20 = load i32, i32* %num_args, align 4
  %cmp12 = icmp sgt i32 %20, 3
  br i1 %cmp12, label %if.then.14, label %if.end.34

if.then.14:                                       ; preds = %if.then.11
  %21 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %21, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %22 = load %struct.sv*, %struct.sv** %21, align 8
  store %struct.sv* %22, %struct.sv** %repl_sv, align 8
  %23 = load %struct.sv*, %struct.sv** %repl_sv, align 8
  %sv_flags15 = getelementptr inbounds %struct.sv, %struct.sv* %23, i32 0, i32 2
  %24 = load i32, i32* %sv_flags15, align 4
  %and16 = and i32 %24, 262144
  %cmp17 = icmp eq i32 %and16, 262144
  br i1 %cmp17, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.14
  %25 = load %struct.sv*, %struct.sv** %repl_sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %25, i32 0, i32 0
  %26 = load i8*, i8** %sv_any, align 8
  %27 = bitcast i8* %26 to %struct.xpv*
  %xpv_cur = getelementptr inbounds %struct.xpv, %struct.xpv* %27, i32 0, i32 1
  %28 = load i64, i64* %xpv_cur, align 8
  store i64 %28, i64* %repl_len, align 8
  %29 = load %struct.sv*, %struct.sv** %repl_sv, align 8
  %sv_any19 = getelementptr inbounds %struct.sv, %struct.sv* %29, i32 0, i32 0
  %30 = load i8*, i8** %sv_any19, align 8
  %31 = bitcast i8* %30 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %31, i32 0, i32 0
  %32 = load i8*, i8** %xpv_pv, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then.14
  %33 = load %struct.sv*, %struct.sv** %repl_sv, align 8
  %call20 = call i8* @Perl_sv_2pv_flags(%struct.sv* %33, i64* %repl_len, i32 2)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %32, %cond.true ], [ %call20, %cond.false ]
  store i8* %cond, i8** %repl, align 8
  %34 = load %struct.sv*, %struct.sv** %repl_sv, align 8
  %sv_flags21 = getelementptr inbounds %struct.sv, %struct.sv* %34, i32 0, i32 2
  %35 = load i32, i32* %sv_flags21, align 4
  %and22 = and i32 %35, 536870912
  %tobool23 = icmp ne i32 %and22, 0
  br i1 %tobool23, label %land.lhs.true, label %land.end.32

land.lhs.true:                                    ; preds = %cond.end
  %36 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %op_private24 = getelementptr inbounds %struct.cop, %struct.cop* %36, i32 0, i32 7
  %37 = load i8, i8* %op_private24, align 1
  %conv25 = zext i8 %37 to i32
  %and26 = and i32 %conv25, 8
  %tobool27 = icmp ne i32 %and26, 0
  br i1 %tobool27, label %land.end.32, label %land.rhs.28

land.rhs.28:                                      ; preds = %land.lhs.true
  %38 = load %struct.sv*, %struct.sv** %repl_sv, align 8
  %sv_any29 = getelementptr inbounds %struct.sv, %struct.sv* %38, i32 0, i32 0
  %39 = load i8*, i8** %sv_any29, align 8
  %40 = bitcast i8* %39 to %struct.xpv*
  %xpv_cur30 = getelementptr inbounds %struct.xpv, %struct.xpv* %40, i32 0, i32 1
  %41 = load i64, i64* %xpv_cur30, align 8
  %tobool31 = icmp ne i64 %41, 0
  br label %land.end.32

land.end.32:                                      ; preds = %land.rhs.28, %land.lhs.true, %cond.end
  %42 = phi i1 [ false, %land.lhs.true ], [ false, %cond.end ], [ %tobool31, %land.rhs.28 ]
  %land.ext = zext i1 %42 to i32
  %conv33 = trunc i32 %land.ext to i8
  store i8 %conv33, i8* %repl_is_utf8, align 1
  br label %if.end.34

if.end.34:                                        ; preds = %land.end.32, %if.then.11
  %43 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr35 = getelementptr inbounds %struct.sv*, %struct.sv** %43, i32 -1
  store %struct.sv** %incdec.ptr35, %struct.sv*** %sp, align 8
  %44 = load %struct.sv*, %struct.sv** %43, align 8
  store %struct.sv* %44, %struct.sv** @PL_Sv, align 8
  %45 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags36 = getelementptr inbounds %struct.sv, %struct.sv* %45, i32 0, i32 2
  %46 = load i32, i32* %sv_flags36, align 4
  %and37 = and i32 %46, 65536
  %tobool38 = icmp ne i32 %and37, 0
  br i1 %tobool38, label %cond.true.39, label %cond.false.41

cond.true.39:                                     ; preds = %if.end.34
  %47 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any40 = getelementptr inbounds %struct.sv, %struct.sv* %47, i32 0, i32 0
  %48 = load i8*, i8** %sv_any40, align 8
  %49 = bitcast i8* %48 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %49, i32 0, i32 3
  %50 = load i64, i64* %xiv_iv, align 8
  br label %cond.end.43

cond.false.41:                                    ; preds = %if.end.34
  %51 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call42 = call i64 @Perl_sv_2iv(%struct.sv* %51)
  br label %cond.end.43

cond.end.43:                                      ; preds = %cond.false.41, %cond.true.39
  %cond44 = phi i64 [ %50, %cond.true.39 ], [ %call42, %cond.false.41 ]
  %conv45 = trunc i64 %cond44 to i32
  store i32 %conv45, i32* %len, align 4
  br label %if.end.46

if.end.46:                                        ; preds = %cond.end.43, %if.end
  %52 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr47 = getelementptr inbounds %struct.sv*, %struct.sv** %52, i32 -1
  store %struct.sv** %incdec.ptr47, %struct.sv*** %sp, align 8
  %53 = load %struct.sv*, %struct.sv** %52, align 8
  store %struct.sv* %53, %struct.sv** @PL_Sv, align 8
  %54 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags48 = getelementptr inbounds %struct.sv, %struct.sv* %54, i32 0, i32 2
  %55 = load i32, i32* %sv_flags48, align 4
  %and49 = and i32 %55, 65536
  %tobool50 = icmp ne i32 %and49, 0
  br i1 %tobool50, label %cond.true.51, label %cond.false.54

cond.true.51:                                     ; preds = %if.end.46
  %56 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any52 = getelementptr inbounds %struct.sv, %struct.sv* %56, i32 0, i32 0
  %57 = load i8*, i8** %sv_any52, align 8
  %58 = bitcast i8* %57 to %struct.xpviv*
  %xiv_iv53 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %58, i32 0, i32 3
  %59 = load i64, i64* %xiv_iv53, align 8
  br label %cond.end.56

cond.false.54:                                    ; preds = %if.end.46
  %60 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call55 = call i64 @Perl_sv_2iv(%struct.sv* %60)
  br label %cond.end.56

cond.end.56:                                      ; preds = %cond.false.54, %cond.true.51
  %cond57 = phi i64 [ %59, %cond.true.51 ], [ %call55, %cond.false.54 ]
  %conv58 = trunc i64 %cond57 to i32
  store i32 %conv58, i32* %pos, align 4
  %61 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr59 = getelementptr inbounds %struct.sv*, %struct.sv** %61, i32 -1
  store %struct.sv** %incdec.ptr59, %struct.sv*** %sp, align 8
  %62 = load %struct.sv*, %struct.sv** %61, align 8
  store %struct.sv* %62, %struct.sv** %sv, align 8
  %63 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %63, %struct.sv*** @PL_stack_sp, align 8
  %64 = load %struct.sv*, %struct.sv** %repl_sv, align 8
  %tobool60 = icmp ne %struct.sv* %64, null
  br i1 %tobool60, label %if.then.61, label %if.end.86

if.then.61:                                       ; preds = %cond.end.56
  %65 = load i8, i8* %repl_is_utf8, align 1
  %tobool62 = icmp ne i8 %65, 0
  br i1 %tobool62, label %if.then.63, label %if.else

if.then.63:                                       ; preds = %if.then.61
  %66 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags64 = getelementptr inbounds %struct.sv, %struct.sv* %66, i32 0, i32 2
  %67 = load i32, i32* %sv_flags64, align 4
  %and65 = and i32 %67, 536870912
  %tobool66 = icmp ne i32 %and65, 0
  br i1 %tobool66, label %land.lhs.true.67, label %if.then.72

land.lhs.true.67:                                 ; preds = %if.then.63
  %68 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %op_private68 = getelementptr inbounds %struct.cop, %struct.cop* %68, i32 0, i32 7
  %69 = load i8, i8* %op_private68, align 1
  %conv69 = zext i8 %69 to i32
  %and70 = and i32 %conv69, 8
  %tobool71 = icmp ne i32 %and70, 0
  br i1 %tobool71, label %if.then.72, label %if.end.74

if.then.72:                                       ; preds = %land.lhs.true.67, %if.then.63
  %70 = load %struct.sv*, %struct.sv** %sv, align 8
  %call73 = call i64 @Perl_sv_utf8_upgrade_flags(%struct.sv* %70, i32 2)
  br label %if.end.74

if.end.74:                                        ; preds = %if.then.72, %land.lhs.true.67
  br label %if.end.85

if.else:                                          ; preds = %if.then.61
  %71 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags75 = getelementptr inbounds %struct.sv, %struct.sv* %71, i32 0, i32 2
  %72 = load i32, i32* %sv_flags75, align 4
  %and76 = and i32 %72, 536870912
  %tobool77 = icmp ne i32 %and76, 0
  br i1 %tobool77, label %land.lhs.true.78, label %if.end.84

land.lhs.true.78:                                 ; preds = %if.else
  %73 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %op_private79 = getelementptr inbounds %struct.cop, %struct.cop* %73, i32 0, i32 7
  %74 = load i8, i8* %op_private79, align 1
  %conv80 = zext i8 %74 to i32
  %and81 = and i32 %conv80, 8
  %tobool82 = icmp ne i32 %and81, 0
  br i1 %tobool82, label %if.end.84, label %if.then.83

if.then.83:                                       ; preds = %land.lhs.true.78
  store i8 1, i8* %repl_need_utf8_upgrade, align 1
  br label %if.end.84

if.end.84:                                        ; preds = %if.then.83, %land.lhs.true.78, %if.else
  br label %if.end.85

if.end.85:                                        ; preds = %if.end.84, %if.end.74
  br label %if.end.86

if.end.86:                                        ; preds = %if.end.85, %cond.end.56
  %75 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags87 = getelementptr inbounds %struct.sv, %struct.sv* %75, i32 0, i32 2
  %76 = load i32, i32* %sv_flags87, align 4
  %and88 = and i32 %76, 262144
  %cmp89 = icmp eq i32 %and88, 262144
  br i1 %cmp89, label %cond.true.91, label %cond.false.96

cond.true.91:                                     ; preds = %if.end.86
  %77 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any92 = getelementptr inbounds %struct.sv, %struct.sv* %77, i32 0, i32 0
  %78 = load i8*, i8** %sv_any92, align 8
  %79 = bitcast i8* %78 to %struct.xpv*
  %xpv_cur93 = getelementptr inbounds %struct.xpv, %struct.xpv* %79, i32 0, i32 1
  %80 = load i64, i64* %xpv_cur93, align 8
  store i64 %80, i64* %curlen, align 8
  %81 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any94 = getelementptr inbounds %struct.sv, %struct.sv* %81, i32 0, i32 0
  %82 = load i8*, i8** %sv_any94, align 8
  %83 = bitcast i8* %82 to %struct.xpv*
  %xpv_pv95 = getelementptr inbounds %struct.xpv, %struct.xpv* %83, i32 0, i32 0
  %84 = load i8*, i8** %xpv_pv95, align 8
  br label %cond.end.98

cond.false.96:                                    ; preds = %if.end.86
  %85 = load %struct.sv*, %struct.sv** %sv, align 8
  %call97 = call i8* @Perl_sv_2pv_flags(%struct.sv* %85, i64* %curlen, i32 2)
  br label %cond.end.98

cond.end.98:                                      ; preds = %cond.false.96, %cond.true.91
  %cond99 = phi i8* [ %84, %cond.true.91 ], [ %call97, %cond.false.96 ]
  store i8* %cond99, i8** %tmps, align 8
  %86 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags100 = getelementptr inbounds %struct.sv, %struct.sv* %86, i32 0, i32 2
  %87 = load i32, i32* %sv_flags100, align 4
  %and101 = and i32 %87, 536870912
  %tobool102 = icmp ne i32 %and101, 0
  br i1 %tobool102, label %land.lhs.true.103, label %if.else.115

land.lhs.true.103:                                ; preds = %cond.end.98
  %88 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %op_private104 = getelementptr inbounds %struct.cop, %struct.cop* %88, i32 0, i32 7
  %89 = load i8, i8* %op_private104, align 1
  %conv105 = zext i8 %89 to i32
  %and106 = and i32 %conv105, 8
  %tobool107 = icmp ne i32 %and106, 0
  br i1 %tobool107, label %if.else.115, label %if.then.108

if.then.108:                                      ; preds = %land.lhs.true.103
  %90 = load %struct.sv*, %struct.sv** %sv, align 8
  %call109 = call i64 @Perl_sv_len_utf8(%struct.sv* %90)
  store i64 %call109, i64* %utf8_curlen, align 8
  %91 = load i64, i64* %utf8_curlen, align 8
  %92 = load i64, i64* %curlen, align 8
  %cmp110 = icmp eq i64 %91, %92
  br i1 %cmp110, label %if.then.112, label %if.else.113

if.then.112:                                      ; preds = %if.then.108
  store i64 0, i64* %utf8_curlen, align 8
  br label %if.end.114

if.else.113:                                      ; preds = %if.then.108
  %93 = load i64, i64* %utf8_curlen, align 8
  store i64 %93, i64* %curlen, align 8
  br label %if.end.114

if.end.114:                                       ; preds = %if.else.113, %if.then.112
  br label %if.end.116

if.else.115:                                      ; preds = %land.lhs.true.103, %cond.end.98
  store i64 0, i64* %utf8_curlen, align 8
  br label %if.end.116

if.end.116:                                       ; preds = %if.else.115, %if.end.114
  %94 = load i32, i32* %pos, align 4
  %95 = load i32, i32* %arybase, align 4
  %cmp117 = icmp sge i32 %94, %95
  br i1 %cmp117, label %if.then.119, label %if.else.140

if.then.119:                                      ; preds = %if.end.116
  %96 = load i32, i32* %arybase, align 4
  %97 = load i32, i32* %pos, align 4
  %sub = sub nsw i32 %97, %96
  store i32 %sub, i32* %pos, align 4
  %98 = load i64, i64* %curlen, align 8
  %99 = load i32, i32* %pos, align 4
  %conv120 = sext i32 %99 to i64
  %sub121 = sub i64 %98, %conv120
  %conv122 = trunc i64 %sub121 to i32
  store i32 %conv122, i32* %rem, align 4
  %100 = load i32, i32* %rem, align 4
  store i32 %100, i32* %fail, align 4
  %101 = load i32, i32* %num_args, align 4
  %cmp123 = icmp sgt i32 %101, 2
  br i1 %cmp123, label %if.then.125, label %if.end.139

if.then.125:                                      ; preds = %if.then.119
  %102 = load i32, i32* %len, align 4
  %cmp126 = icmp slt i32 %102, 0
  br i1 %cmp126, label %if.then.128, label %if.else.133

if.then.128:                                      ; preds = %if.then.125
  %103 = load i32, i32* %len, align 4
  %104 = load i32, i32* %rem, align 4
  %add = add nsw i32 %104, %103
  store i32 %add, i32* %rem, align 4
  %105 = load i32, i32* %rem, align 4
  %cmp129 = icmp slt i32 %105, 0
  br i1 %cmp129, label %if.then.131, label %if.end.132

if.then.131:                                      ; preds = %if.then.128
  store i32 0, i32* %rem, align 4
  br label %if.end.132

if.end.132:                                       ; preds = %if.then.131, %if.then.128
  br label %if.end.138

if.else.133:                                      ; preds = %if.then.125
  %106 = load i32, i32* %rem, align 4
  %107 = load i32, i32* %len, align 4
  %cmp134 = icmp sgt i32 %106, %107
  br i1 %cmp134, label %if.then.136, label %if.end.137

if.then.136:                                      ; preds = %if.else.133
  %108 = load i32, i32* %len, align 4
  store i32 %108, i32* %rem, align 4
  br label %if.end.137

if.end.137:                                       ; preds = %if.then.136, %if.else.133
  br label %if.end.138

if.end.138:                                       ; preds = %if.end.137, %if.end.132
  br label %if.end.139

if.end.139:                                       ; preds = %if.end.138, %if.then.119
  br label %if.end.174

if.else.140:                                      ; preds = %if.end.116
  %109 = load i64, i64* %curlen, align 8
  %110 = load i32, i32* %pos, align 4
  %conv141 = sext i32 %110 to i64
  %add142 = add i64 %conv141, %109
  %conv143 = trunc i64 %add142 to i32
  store i32 %conv143, i32* %pos, align 4
  %111 = load i32, i32* %num_args, align 4
  %cmp144 = icmp slt i32 %111, 3
  br i1 %cmp144, label %if.then.146, label %if.else.148

if.then.146:                                      ; preds = %if.else.140
  %112 = load i64, i64* %curlen, align 8
  %conv147 = trunc i64 %112 to i32
  store i32 %conv147, i32* %rem, align 4
  br label %if.end.168

if.else.148:                                      ; preds = %if.else.140
  %113 = load i32, i32* %len, align 4
  %cmp149 = icmp sge i32 %113, 0
  br i1 %cmp149, label %if.then.151, label %if.else.159

if.then.151:                                      ; preds = %if.else.148
  %114 = load i32, i32* %pos, align 4
  %115 = load i32, i32* %len, align 4
  %add152 = add nsw i32 %114, %115
  store i32 %add152, i32* %rem, align 4
  %116 = load i32, i32* %rem, align 4
  %117 = load i64, i64* %curlen, align 8
  %conv153 = trunc i64 %117 to i32
  %cmp154 = icmp sgt i32 %116, %conv153
  br i1 %cmp154, label %if.then.156, label %if.end.158

if.then.156:                                      ; preds = %if.then.151
  %118 = load i64, i64* %curlen, align 8
  %conv157 = trunc i64 %118 to i32
  store i32 %conv157, i32* %rem, align 4
  br label %if.end.158

if.end.158:                                       ; preds = %if.then.156, %if.then.151
  br label %if.end.167

if.else.159:                                      ; preds = %if.else.148
  %119 = load i64, i64* %curlen, align 8
  %120 = load i32, i32* %len, align 4
  %conv160 = sext i32 %120 to i64
  %add161 = add i64 %119, %conv160
  %conv162 = trunc i64 %add161 to i32
  store i32 %conv162, i32* %rem, align 4
  %121 = load i32, i32* %rem, align 4
  %122 = load i32, i32* %pos, align 4
  %cmp163 = icmp slt i32 %121, %122
  br i1 %cmp163, label %if.then.165, label %if.end.166

if.then.165:                                      ; preds = %if.else.159
  %123 = load i32, i32* %pos, align 4
  store i32 %123, i32* %rem, align 4
  br label %if.end.166

if.end.166:                                       ; preds = %if.then.165, %if.else.159
  br label %if.end.167

if.end.167:                                       ; preds = %if.end.166, %if.end.158
  br label %if.end.168

if.end.168:                                       ; preds = %if.end.167, %if.then.146
  %124 = load i32, i32* %pos, align 4
  %cmp169 = icmp slt i32 %124, 0
  br i1 %cmp169, label %if.then.171, label %if.end.172

if.then.171:                                      ; preds = %if.end.168
  store i32 0, i32* %pos, align 4
  br label %if.end.172

if.end.172:                                       ; preds = %if.then.171, %if.end.168
  %125 = load i32, i32* %rem, align 4
  store i32 %125, i32* %fail, align 4
  %126 = load i32, i32* %pos, align 4
  %127 = load i32, i32* %rem, align 4
  %sub173 = sub nsw i32 %127, %126
  store i32 %sub173, i32* %rem, align 4
  br label %if.end.174

if.end.174:                                       ; preds = %if.end.172, %if.end.139
  %128 = load i32, i32* %fail, align 4
  %cmp175 = icmp slt i32 %128, 0
  br i1 %cmp175, label %if.then.177, label %if.else.211

if.then.177:                                      ; preds = %if.end.174
  %129 = load i32, i32* %lvalue, align 4
  %tobool178 = icmp ne i32 %129, 0
  br i1 %tobool178, label %if.then.180, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then.177
  %130 = load i8*, i8** %repl, align 8
  %tobool179 = icmp ne i8* %130, null
  br i1 %tobool179, label %if.then.180, label %if.end.181

if.then.180:                                      ; preds = %lor.lhs.false, %if.then.177
  call void (i8*, ...) @Perl_croak(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.34, i32 0, i32 0))
  br label %if.end.181

if.end.181:                                       ; preds = %if.then.180, %lor.lhs.false
  %131 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings = getelementptr inbounds %struct.cop, %struct.cop* %131, i32 0, i32 14
  %132 = load %struct.sv*, %struct.sv** %cop_warnings, align 8
  %cmp182 = icmp ne %struct.sv* %132, null
  br i1 %cmp182, label %land.lhs.true.184, label %lor.lhs.false.200

land.lhs.true.184:                                ; preds = %if.end.181
  %133 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings185 = getelementptr inbounds %struct.cop, %struct.cop* %133, i32 0, i32 14
  %134 = load %struct.sv*, %struct.sv** %cop_warnings185, align 8
  %cmp186 = icmp ne %struct.sv* %134, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 2)
  br i1 %cmp186, label %land.lhs.true.188, label %lor.lhs.false.200

land.lhs.true.188:                                ; preds = %land.lhs.true.184
  %135 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings189 = getelementptr inbounds %struct.cop, %struct.cop* %135, i32 0, i32 14
  %136 = load %struct.sv*, %struct.sv** %cop_warnings189, align 8
  %cmp190 = icmp eq %struct.sv* %136, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 1)
  br i1 %cmp190, label %if.then.208, label %lor.lhs.false.192

lor.lhs.false.192:                                ; preds = %land.lhs.true.188
  %137 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings193 = getelementptr inbounds %struct.cop, %struct.cop* %137, i32 0, i32 14
  %138 = load %struct.sv*, %struct.sv** %cop_warnings193, align 8
  %sv_any194 = getelementptr inbounds %struct.sv, %struct.sv* %138, i32 0, i32 0
  %139 = load i8*, i8** %sv_any194, align 8
  %140 = bitcast i8* %139 to %struct.xpv*
  %xpv_pv195 = getelementptr inbounds %struct.xpv, %struct.xpv* %140, i32 0, i32 0
  %141 = load i8*, i8** %xpv_pv195, align 8
  %arrayidx196 = getelementptr inbounds i8, i8* %141, i64 6
  %142 = load i8, i8* %arrayidx196, align 1
  %conv197 = sext i8 %142 to i32
  %and198 = and i32 %conv197, 64
  %tobool199 = icmp ne i32 %and198, 0
  br i1 %tobool199, label %if.then.208, label %lor.lhs.false.200

lor.lhs.false.200:                                ; preds = %lor.lhs.false.192, %land.lhs.true.184, %if.end.181
  %143 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings201 = getelementptr inbounds %struct.cop, %struct.cop* %143, i32 0, i32 14
  %144 = load %struct.sv*, %struct.sv** %cop_warnings201, align 8
  %cmp202 = icmp eq %struct.sv* %144, null
  br i1 %cmp202, label %land.lhs.true.204, label %if.end.209

land.lhs.true.204:                                ; preds = %lor.lhs.false.200
  %145 = load i8, i8* @PL_dowarn, align 1
  %conv205 = zext i8 %145 to i32
  %and206 = and i32 %conv205, 1
  %tobool207 = icmp ne i32 %and206, 0
  br i1 %tobool207, label %if.then.208, label %if.end.209

if.then.208:                                      ; preds = %land.lhs.true.204, %lor.lhs.false.192, %land.lhs.true.188
  call void (i32, i8*, ...) @Perl_warner(i32 27, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.34, i32 0, i32 0))
  br label %if.end.209

if.end.209:                                       ; preds = %if.then.208, %land.lhs.true.204, %lor.lhs.false.200
  %146 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr210 = getelementptr inbounds %struct.sv*, %struct.sv** %146, i32 1
  store %struct.sv** %incdec.ptr210, %struct.sv*** %sp, align 8
  store %struct.sv* @PL_sv_undef, %struct.sv** %incdec.ptr210, align 8
  %147 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %147, %struct.sv*** @PL_stack_sp, align 8
  %148 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %148, i32 0, i32 0
  %149 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %149, %struct.op** %retval
  br label %return

if.else.211:                                      ; preds = %if.end.174
  %150 = load i32, i32* %pos, align 4
  store i32 %150, i32* %upos, align 4
  %151 = load i32, i32* %rem, align 4
  store i32 %151, i32* %urem, align 4
  %152 = load i64, i64* %utf8_curlen, align 8
  %tobool212 = icmp ne i64 %152, 0
  br i1 %tobool212, label %if.then.213, label %if.end.214

if.then.213:                                      ; preds = %if.else.211
  %153 = load %struct.sv*, %struct.sv** %sv, align 8
  call void @Perl_sv_pos_u2b(%struct.sv* %153, i32* %pos, i32* %rem)
  br label %if.end.214

if.end.214:                                       ; preds = %if.then.213, %if.else.211
  %154 = load i32, i32* %pos, align 4
  %155 = load i8*, i8** %tmps, align 8
  %idx.ext = sext i32 %154 to i64
  %add.ptr = getelementptr inbounds i8, i8* %155, i64 %idx.ext
  store i8* %add.ptr, i8** %tmps, align 8
  %156 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags215 = getelementptr inbounds %struct.sv, %struct.sv* %156, i32 0, i32 2
  %157 = load i32, i32* %sv_flags215, align 4
  %and216 = and i32 %157, 255
  %cmp217 = icmp ugt i32 %and216, 0
  br i1 %cmp217, label %if.then.219, label %if.end.234

if.then.219:                                      ; preds = %if.end.214
  %158 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags220 = getelementptr inbounds %struct.sv, %struct.sv* %158, i32 0, i32 2
  %159 = load i32, i32* %sv_flags220, align 4
  %and221 = and i32 %159, 255
  %cmp222 = icmp eq i32 %and221, 9
  br i1 %cmp222, label %cond.true.224, label %cond.false.229

cond.true.224:                                    ; preds = %if.then.219
  %160 = load i32, i32* %lvalue, align 4
  %tobool225 = icmp ne i32 %160, 0
  br i1 %tobool225, label %lor.lhs.false.226, label %if.then.231

lor.lhs.false.226:                                ; preds = %cond.true.224
  %161 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_refcnt = getelementptr inbounds %struct.sv, %struct.sv* %161, i32 0, i32 1
  %162 = load i32, i32* %sv_refcnt, align 4
  %cmp227 = icmp ugt i32 %162, 1
  br i1 %cmp227, label %if.then.231, label %if.end.233

cond.false.229:                                   ; preds = %if.then.219
  %163 = load i32, i32* %lvalue, align 4
  %tobool230 = icmp ne i32 %163, 0
  br i1 %tobool230, label %if.then.231, label %if.end.233

if.then.231:                                      ; preds = %cond.false.229, %lor.lhs.false.226, %cond.true.224
  %call232 = call %struct.sv* @Perl_sv_newmortal()
  store %struct.sv* %call232, %struct.sv** %targ, align 8
  br label %if.end.233

if.end.233:                                       ; preds = %if.then.231, %cond.false.229, %lor.lhs.false.226
  br label %if.end.234

if.end.234:                                       ; preds = %if.end.233, %if.end.214
  %164 = load %struct.sv*, %struct.sv** %targ, align 8
  %165 = load i8*, i8** %tmps, align 8
  %166 = load i32, i32* %rem, align 4
  %conv235 = sext i32 %166 to i64
  call void @Perl_sv_setpvn(%struct.sv* %164, i8* %165, i64 %conv235)
  %167 = load i64, i64* %utf8_curlen, align 8
  %tobool236 = icmp ne i64 %167, 0
  br i1 %tobool236, label %if.then.237, label %if.end.239

if.then.237:                                      ; preds = %if.end.234
  %168 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags238 = getelementptr inbounds %struct.sv, %struct.sv* %168, i32 0, i32 2
  %169 = load i32, i32* %sv_flags238, align 4
  %or = or i32 %169, 536870912
  store i32 %or, i32* %sv_flags238, align 4
  br label %if.end.239

if.end.239:                                       ; preds = %if.then.237, %if.end.234
  %170 = load i8*, i8** %repl, align 8
  %tobool240 = icmp ne i8* %170, null
  br i1 %tobool240, label %if.then.241, label %if.else.285

if.then.241:                                      ; preds = %if.end.239
  store %struct.sv* null, %struct.sv** %repl_sv_copy, align 8
  %171 = load i8, i8* %repl_need_utf8_upgrade, align 1
  %tobool242 = icmp ne i8 %171, 0
  br i1 %tobool242, label %if.then.243, label %if.end.274

if.then.243:                                      ; preds = %if.then.241
  %172 = load %struct.sv*, %struct.sv** %repl_sv, align 8
  %call244 = call %struct.sv* @Perl_newSVsv(%struct.sv* %172)
  store %struct.sv* %call244, %struct.sv** %repl_sv_copy, align 8
  %173 = load %struct.sv*, %struct.sv** %repl_sv_copy, align 8
  %call245 = call i64 @Perl_sv_utf8_upgrade_flags(%struct.sv* %173, i32 2)
  %174 = load %struct.sv*, %struct.sv** %repl_sv_copy, align 8
  %sv_flags246 = getelementptr inbounds %struct.sv, %struct.sv* %174, i32 0, i32 2
  %175 = load i32, i32* %sv_flags246, align 4
  %and247 = and i32 %175, 262144
  %cmp248 = icmp eq i32 %and247, 262144
  br i1 %cmp248, label %cond.true.250, label %cond.false.255

cond.true.250:                                    ; preds = %if.then.243
  %176 = load %struct.sv*, %struct.sv** %repl_sv_copy, align 8
  %sv_any251 = getelementptr inbounds %struct.sv, %struct.sv* %176, i32 0, i32 0
  %177 = load i8*, i8** %sv_any251, align 8
  %178 = bitcast i8* %177 to %struct.xpv*
  %xpv_cur252 = getelementptr inbounds %struct.xpv, %struct.xpv* %178, i32 0, i32 1
  %179 = load i64, i64* %xpv_cur252, align 8
  store i64 %179, i64* %repl_len, align 8
  %180 = load %struct.sv*, %struct.sv** %repl_sv_copy, align 8
  %sv_any253 = getelementptr inbounds %struct.sv, %struct.sv* %180, i32 0, i32 0
  %181 = load i8*, i8** %sv_any253, align 8
  %182 = bitcast i8* %181 to %struct.xpv*
  %xpv_pv254 = getelementptr inbounds %struct.xpv, %struct.xpv* %182, i32 0, i32 0
  %183 = load i8*, i8** %xpv_pv254, align 8
  br label %cond.end.257

cond.false.255:                                   ; preds = %if.then.243
  %184 = load %struct.sv*, %struct.sv** %repl_sv_copy, align 8
  %call256 = call i8* @Perl_sv_2pv_flags(%struct.sv* %184, i64* %repl_len, i32 2)
  br label %cond.end.257

cond.end.257:                                     ; preds = %cond.false.255, %cond.true.250
  %cond258 = phi i8* [ %183, %cond.true.250 ], [ %call256, %cond.false.255 ]
  store i8* %cond258, i8** %repl, align 8
  %185 = load %struct.sv*, %struct.sv** %repl_sv_copy, align 8
  %sv_flags259 = getelementptr inbounds %struct.sv, %struct.sv* %185, i32 0, i32 2
  %186 = load i32, i32* %sv_flags259, align 4
  %and260 = and i32 %186, 536870912
  %tobool261 = icmp ne i32 %and260, 0
  br i1 %tobool261, label %land.lhs.true.262, label %land.end.271

land.lhs.true.262:                                ; preds = %cond.end.257
  %187 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %op_private263 = getelementptr inbounds %struct.cop, %struct.cop* %187, i32 0, i32 7
  %188 = load i8, i8* %op_private263, align 1
  %conv264 = zext i8 %188 to i32
  %and265 = and i32 %conv264, 8
  %tobool266 = icmp ne i32 %and265, 0
  br i1 %tobool266, label %land.end.271, label %land.rhs.267

land.rhs.267:                                     ; preds = %land.lhs.true.262
  %189 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any268 = getelementptr inbounds %struct.sv, %struct.sv* %189, i32 0, i32 0
  %190 = load i8*, i8** %sv_any268, align 8
  %191 = bitcast i8* %190 to %struct.xpv*
  %xpv_cur269 = getelementptr inbounds %struct.xpv, %struct.xpv* %191, i32 0, i32 1
  %192 = load i64, i64* %xpv_cur269, align 8
  %tobool270 = icmp ne i64 %192, 0
  br label %land.end.271

land.end.271:                                     ; preds = %land.rhs.267, %land.lhs.true.262, %cond.end.257
  %193 = phi i1 [ false, %land.lhs.true.262 ], [ false, %cond.end.257 ], [ %tobool270, %land.rhs.267 ]
  %land.ext272 = zext i1 %193 to i32
  %conv273 = trunc i32 %land.ext272 to i8
  store i8 %conv273, i8* %repl_is_utf8, align 1
  br label %if.end.274

if.end.274:                                       ; preds = %land.end.271, %if.then.241
  %194 = load %struct.sv*, %struct.sv** %sv, align 8
  %195 = load i32, i32* %pos, align 4
  %conv275 = sext i32 %195 to i64
  %196 = load i32, i32* %rem, align 4
  %conv276 = sext i32 %196 to i64
  %197 = load i8*, i8** %repl, align 8
  %198 = load i64, i64* %repl_len, align 8
  call void @Perl_sv_insert(%struct.sv* %194, i64 %conv275, i64 %conv276, i8* %197, i64 %198)
  %199 = load i8, i8* %repl_is_utf8, align 1
  %tobool277 = icmp ne i8 %199, 0
  br i1 %tobool277, label %if.then.278, label %if.end.281

if.then.278:                                      ; preds = %if.end.274
  %200 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags279 = getelementptr inbounds %struct.sv, %struct.sv* %200, i32 0, i32 2
  %201 = load i32, i32* %sv_flags279, align 4
  %or280 = or i32 %201, 536870912
  store i32 %or280, i32* %sv_flags279, align 4
  br label %if.end.281

if.end.281:                                       ; preds = %if.then.278, %if.end.274
  %202 = load %struct.sv*, %struct.sv** %repl_sv_copy, align 8
  %tobool282 = icmp ne %struct.sv* %202, null
  br i1 %tobool282, label %if.then.283, label %if.end.284

if.then.283:                                      ; preds = %if.end.281
  %203 = load %struct.sv*, %struct.sv** %repl_sv_copy, align 8
  call void @Perl_sv_free(%struct.sv* %203)
  br label %if.end.284

if.end.284:                                       ; preds = %if.then.283, %if.end.281
  br label %if.end.394

if.else.285:                                      ; preds = %if.end.239
  %204 = load i32, i32* %lvalue, align 4
  %tobool286 = icmp ne i32 %204, 0
  br i1 %tobool286, label %if.then.287, label %if.end.393

if.then.287:                                      ; preds = %if.else.285
  %205 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags288 = getelementptr inbounds %struct.sv, %struct.sv* %205, i32 0, i32 2
  %206 = load i32, i32* %sv_flags288, align 4
  %and289 = and i32 %206, 8192
  %tobool290 = icmp ne i32 %and289, 0
  br i1 %tobool290, label %if.end.349, label %if.then.291

if.then.291:                                      ; preds = %if.then.287
  %207 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags292 = getelementptr inbounds %struct.sv, %struct.sv* %207, i32 0, i32 2
  %208 = load i32, i32* %sv_flags292, align 4
  %and293 = and i32 %208, 524288
  %tobool294 = icmp ne i32 %and293, 0
  br i1 %tobool294, label %if.then.295, label %if.end.338

if.then.295:                                      ; preds = %if.then.291
  %209 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags296 = getelementptr inbounds %struct.sv, %struct.sv* %209, i32 0, i32 2
  %210 = load i32, i32* %sv_flags296, align 4
  %and297 = and i32 %210, 10223616
  %cmp298 = icmp eq i32 %and297, 262144
  br i1 %cmp298, label %cond.true.300, label %cond.false.305

cond.true.300:                                    ; preds = %if.then.295
  %211 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any301 = getelementptr inbounds %struct.sv, %struct.sv* %211, i32 0, i32 0
  %212 = load i8*, i8** %sv_any301, align 8
  %213 = bitcast i8* %212 to %struct.xpv*
  %xpv_cur302 = getelementptr inbounds %struct.xpv, %struct.xpv* %213, i32 0, i32 1
  %214 = load i64, i64* %xpv_cur302, align 8
  store i64 %214, i64* %n_a, align 8
  %215 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any303 = getelementptr inbounds %struct.sv, %struct.sv* %215, i32 0, i32 0
  %216 = load i8*, i8** %sv_any303, align 8
  %217 = bitcast i8* %216 to %struct.xpv*
  %xpv_pv304 = getelementptr inbounds %struct.xpv, %struct.xpv* %217, i32 0, i32 0
  %218 = load i8*, i8** %xpv_pv304, align 8
  br label %cond.end.307

cond.false.305:                                   ; preds = %if.then.295
  %219 = load %struct.sv*, %struct.sv** %sv, align 8
  %call306 = call i8* @Perl_sv_pvn_force_flags(%struct.sv* %219, i64* %n_a, i32 2)
  br label %cond.end.307

cond.end.307:                                     ; preds = %cond.false.305, %cond.true.300
  %cond308 = phi i8* [ %218, %cond.true.300 ], [ %call306, %cond.false.305 ]
  %220 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings309 = getelementptr inbounds %struct.cop, %struct.cop* %220, i32 0, i32 14
  %221 = load %struct.sv*, %struct.sv** %cop_warnings309, align 8
  %cmp310 = icmp ne %struct.sv* %221, null
  br i1 %cmp310, label %land.lhs.true.312, label %lor.lhs.false.328

land.lhs.true.312:                                ; preds = %cond.end.307
  %222 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings313 = getelementptr inbounds %struct.cop, %struct.cop* %222, i32 0, i32 14
  %223 = load %struct.sv*, %struct.sv** %cop_warnings313, align 8
  %cmp314 = icmp ne %struct.sv* %223, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 2)
  br i1 %cmp314, label %land.lhs.true.316, label %lor.lhs.false.328

land.lhs.true.316:                                ; preds = %land.lhs.true.312
  %224 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings317 = getelementptr inbounds %struct.cop, %struct.cop* %224, i32 0, i32 14
  %225 = load %struct.sv*, %struct.sv** %cop_warnings317, align 8
  %cmp318 = icmp eq %struct.sv* %225, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 1)
  br i1 %cmp318, label %if.then.336, label %lor.lhs.false.320

lor.lhs.false.320:                                ; preds = %land.lhs.true.316
  %226 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings321 = getelementptr inbounds %struct.cop, %struct.cop* %226, i32 0, i32 14
  %227 = load %struct.sv*, %struct.sv** %cop_warnings321, align 8
  %sv_any322 = getelementptr inbounds %struct.sv, %struct.sv* %227, i32 0, i32 0
  %228 = load i8*, i8** %sv_any322, align 8
  %229 = bitcast i8* %228 to %struct.xpv*
  %xpv_pv323 = getelementptr inbounds %struct.xpv, %struct.xpv* %229, i32 0, i32 0
  %230 = load i8*, i8** %xpv_pv323, align 8
  %arrayidx324 = getelementptr inbounds i8, i8* %230, i64 6
  %231 = load i8, i8* %arrayidx324, align 1
  %conv325 = sext i8 %231 to i32
  %and326 = and i32 %conv325, 64
  %tobool327 = icmp ne i32 %and326, 0
  br i1 %tobool327, label %if.then.336, label %lor.lhs.false.328

lor.lhs.false.328:                                ; preds = %lor.lhs.false.320, %land.lhs.true.312, %cond.end.307
  %232 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings329 = getelementptr inbounds %struct.cop, %struct.cop* %232, i32 0, i32 14
  %233 = load %struct.sv*, %struct.sv** %cop_warnings329, align 8
  %cmp330 = icmp eq %struct.sv* %233, null
  br i1 %cmp330, label %land.lhs.true.332, label %if.end.337

land.lhs.true.332:                                ; preds = %lor.lhs.false.328
  %234 = load i8, i8* @PL_dowarn, align 1
  %conv333 = zext i8 %234 to i32
  %and334 = and i32 %conv333, 1
  %tobool335 = icmp ne i32 %and334, 0
  br i1 %tobool335, label %if.then.336, label %if.end.337

if.then.336:                                      ; preds = %land.lhs.true.332, %lor.lhs.false.320, %land.lhs.true.316
  call void (i32, i8*, ...) @Perl_warner(i32 27, i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.35, i32 0, i32 0))
  br label %if.end.337

if.end.337:                                       ; preds = %if.then.336, %land.lhs.true.332, %lor.lhs.false.328
  br label %if.end.338

if.end.338:                                       ; preds = %if.end.337, %if.then.291
  %235 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags339 = getelementptr inbounds %struct.sv, %struct.sv* %235, i32 0, i32 2
  %236 = load i32, i32* %sv_flags339, align 4
  %and340 = and i32 %236, 118423552
  %tobool341 = icmp ne i32 %and340, 0
  br i1 %tobool341, label %if.then.342, label %if.else.347

if.then.342:                                      ; preds = %if.end.338
  %237 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags343 = getelementptr inbounds %struct.sv, %struct.sv* %237, i32 0, i32 2
  %238 = load i32, i32* %sv_flags343, align 4
  %and344 = and i32 %238, 1760624639
  store i32 %and344, i32* %sv_flags343, align 4
  %239 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags345 = getelementptr inbounds %struct.sv, %struct.sv* %239, i32 0, i32 2
  %240 = load i32, i32* %sv_flags345, align 4
  %or346 = or i32 %240, 67371008
  store i32 %or346, i32* %sv_flags345, align 4
  br label %if.end.348

if.else.347:                                      ; preds = %if.end.338
  %241 = load %struct.sv*, %struct.sv** %sv, align 8
  call void @Perl_sv_setpvn(%struct.sv* %241, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.4, i32 0, i32 0), i64 0)
  br label %if.end.348

if.end.348:                                       ; preds = %if.else.347, %if.then.342
  br label %if.end.349

if.end.349:                                       ; preds = %if.end.348, %if.then.287
  %242 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags350 = getelementptr inbounds %struct.sv, %struct.sv* %242, i32 0, i32 2
  %243 = load i32, i32* %sv_flags350, align 4
  %and351 = and i32 %243, 255
  %cmp352 = icmp ult i32 %and351, 9
  br i1 %cmp352, label %if.then.354, label %if.else.356

if.then.354:                                      ; preds = %if.end.349
  %244 = load %struct.sv*, %struct.sv** %targ, align 8
  %call355 = call signext i8 @Perl_sv_upgrade(%struct.sv* %244, i32 9)
  %245 = load %struct.sv*, %struct.sv** %targ, align 8
  call void @Perl_sv_magic(%struct.sv* %245, %struct.sv* null, i32 120, i8* null, i32 0)
  br label %if.end.367

if.else.356:                                      ; preds = %if.end.349
  %246 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags357 = getelementptr inbounds %struct.sv, %struct.sv* %246, i32 0, i32 2
  %247 = load i32, i32* %sv_flags357, align 4
  %and358 = and i32 %247, 1223753727
  store i32 %and358, i32* %sv_flags357, align 4
  %248 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags359 = getelementptr inbounds %struct.sv, %struct.sv* %248, i32 0, i32 2
  %249 = load i32, i32* %sv_flags359, align 4
  %and360 = and i32 %249, 2097152
  %tobool361 = icmp ne i32 %and360, 0
  br i1 %tobool361, label %land.rhs.362, label %land.end.365

land.rhs.362:                                     ; preds = %if.else.356
  %250 = load %struct.sv*, %struct.sv** %targ, align 8
  %call363 = call i32 @Perl_sv_backoff(%struct.sv* %250)
  %tobool364 = icmp ne i32 %call363, 0
  br label %land.end.365

land.end.365:                                     ; preds = %land.rhs.362, %if.else.356
  %251 = phi i1 [ false, %if.else.356 ], [ %tobool364, %land.rhs.362 ]
  %land.ext366 = zext i1 %251 to i32
  br label %if.end.367

if.end.367:                                       ; preds = %land.end.365, %if.then.354
  %252 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any368 = getelementptr inbounds %struct.sv, %struct.sv* %252, i32 0, i32 0
  %253 = load i8*, i8** %sv_any368, align 8
  %254 = bitcast i8* %253 to %struct.xpvlv*
  %xlv_type = getelementptr inbounds %struct.xpvlv, %struct.xpvlv* %254, i32 0, i32 10
  store i8 120, i8* %xlv_type, align 1
  %255 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any369 = getelementptr inbounds %struct.sv, %struct.sv* %255, i32 0, i32 0
  %256 = load i8*, i8** %sv_any369, align 8
  %257 = bitcast i8* %256 to %struct.xpvlv*
  %xlv_targ = getelementptr inbounds %struct.xpvlv, %struct.xpvlv* %257, i32 0, i32 9
  %258 = load %struct.sv*, %struct.sv** %xlv_targ, align 8
  %259 = load %struct.sv*, %struct.sv** %sv, align 8
  %cmp370 = icmp ne %struct.sv* %258, %259
  br i1 %cmp370, label %if.then.372, label %if.end.388

if.then.372:                                      ; preds = %if.end.367
  %260 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any373 = getelementptr inbounds %struct.sv, %struct.sv* %260, i32 0, i32 0
  %261 = load i8*, i8** %sv_any373, align 8
  %262 = bitcast i8* %261 to %struct.xpvlv*
  %xlv_targ374 = getelementptr inbounds %struct.xpvlv, %struct.xpvlv* %262, i32 0, i32 9
  %263 = load %struct.sv*, %struct.sv** %xlv_targ374, align 8
  %tobool375 = icmp ne %struct.sv* %263, null
  br i1 %tobool375, label %if.then.376, label %if.end.379

if.then.376:                                      ; preds = %if.then.372
  %264 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any377 = getelementptr inbounds %struct.sv, %struct.sv* %264, i32 0, i32 0
  %265 = load i8*, i8** %sv_any377, align 8
  %266 = bitcast i8* %265 to %struct.xpvlv*
  %xlv_targ378 = getelementptr inbounds %struct.xpvlv, %struct.xpvlv* %266, i32 0, i32 9
  %267 = load %struct.sv*, %struct.sv** %xlv_targ378, align 8
  call void @Perl_sv_free(%struct.sv* %267)
  br label %if.end.379

if.end.379:                                       ; preds = %if.then.376, %if.then.372
  %268 = load %struct.sv*, %struct.sv** %sv, align 8
  store %struct.sv* %268, %struct.sv** @PL_Sv, align 8
  %269 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %tobool380 = icmp ne %struct.sv* %269, null
  br i1 %tobool380, label %land.rhs.381, label %land.end.384

land.rhs.381:                                     ; preds = %if.end.379
  %270 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_refcnt382 = getelementptr inbounds %struct.sv, %struct.sv* %270, i32 0, i32 1
  %271 = load i32, i32* %sv_refcnt382, align 4
  %inc = add i32 %271, 1
  store i32 %inc, i32* %sv_refcnt382, align 4
  %tobool383 = icmp ne i32 %inc, 0
  br label %land.end.384

land.end.384:                                     ; preds = %land.rhs.381, %if.end.379
  %272 = phi i1 [ false, %if.end.379 ], [ %tobool383, %land.rhs.381 ]
  %land.ext385 = zext i1 %272 to i32
  %273 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %274 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any386 = getelementptr inbounds %struct.sv, %struct.sv* %274, i32 0, i32 0
  %275 = load i8*, i8** %sv_any386, align 8
  %276 = bitcast i8* %275 to %struct.xpvlv*
  %xlv_targ387 = getelementptr inbounds %struct.xpvlv, %struct.xpvlv* %276, i32 0, i32 9
  store %struct.sv* %273, %struct.sv** %xlv_targ387, align 8
  br label %if.end.388

if.end.388:                                       ; preds = %land.end.384, %if.end.367
  %277 = load i32, i32* %upos, align 4
  %conv389 = sext i32 %277 to i64
  %278 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any390 = getelementptr inbounds %struct.sv, %struct.sv* %278, i32 0, i32 0
  %279 = load i8*, i8** %sv_any390, align 8
  %280 = bitcast i8* %279 to %struct.xpvlv*
  %xlv_targoff = getelementptr inbounds %struct.xpvlv, %struct.xpvlv* %280, i32 0, i32 7
  store i64 %conv389, i64* %xlv_targoff, align 8
  %281 = load i32, i32* %urem, align 4
  %conv391 = sext i32 %281 to i64
  %282 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any392 = getelementptr inbounds %struct.sv, %struct.sv* %282, i32 0, i32 0
  %283 = load i8*, i8** %sv_any392, align 8
  %284 = bitcast i8* %283 to %struct.xpvlv*
  %xlv_targlen = getelementptr inbounds %struct.xpvlv, %struct.xpvlv* %284, i32 0, i32 8
  store i64 %conv391, i64* %xlv_targlen, align 8
  br label %if.end.393

if.end.393:                                       ; preds = %if.end.388, %if.else.285
  br label %if.end.394

if.end.394:                                       ; preds = %if.end.393, %if.end.284
  br label %if.end.395

if.end.395:                                       ; preds = %if.end.394
  %285 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %285, %struct.sv*** %sp, align 8
  %286 = load %struct.sv*, %struct.sv** %targ, align 8
  %287 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr396 = getelementptr inbounds %struct.sv*, %struct.sv** %287, i32 1
  store %struct.sv** %incdec.ptr396, %struct.sv*** %sp, align 8
  store %struct.sv* %286, %struct.sv** %incdec.ptr396, align 8
  %288 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %288, %struct.sv*** @PL_stack_sp, align 8
  %289 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next397 = getelementptr inbounds %struct.op, %struct.op* %289, i32 0, i32 0
  %290 = load %struct.op*, %struct.op** %op_next397, align 8
  store %struct.op* %290, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.395, %if.end.209
  %291 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %291
}

declare void @Perl_sv_untaint(%struct.sv*) #1

declare i64 @Perl_sv_utf8_upgrade_flags(%struct.sv*, i32) #1

declare void @Perl_sv_pos_u2b(%struct.sv*, i32*, i32*) #1

declare void @Perl_sv_insert(%struct.sv*, i64, i64, i8*, i64) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_vec() #0 {
entry:
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %size = alloca i64, align 8
  %offset = alloca i64, align 8
  %src = alloca %struct.sv*, align 8
  %lvalue = alloca i32, align 4
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 3
  %2 = load i64, i64* %op_targ, align 8
  %3 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 %2
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %4, %struct.sv** %targ, align 8
  %5 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %5, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %6 = load %struct.sv*, %struct.sv** %5, align 8
  store %struct.sv* %6, %struct.sv** @PL_Sv, align 8
  %7 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %7, i32 0, i32 2
  %8 = load i32, i32* %sv_flags, align 4
  %and = and i32 %8, 65536
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %9 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %9, i32 0, i32 0
  %10 = load i8*, i8** %sv_any, align 8
  %11 = bitcast i8* %10 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %11, i32 0, i32 3
  %12 = load i64, i64* %xiv_iv, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %13 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call = call i64 @Perl_sv_2iv(%struct.sv* %13)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %12, %cond.true ], [ %call, %cond.false ]
  store i64 %cond, i64* %size, align 8
  %14 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr1 = getelementptr inbounds %struct.sv*, %struct.sv** %14, i32 -1
  store %struct.sv** %incdec.ptr1, %struct.sv*** %sp, align 8
  %15 = load %struct.sv*, %struct.sv** %14, align 8
  store %struct.sv* %15, %struct.sv** @PL_Sv, align 8
  %16 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags2 = getelementptr inbounds %struct.sv, %struct.sv* %16, i32 0, i32 2
  %17 = load i32, i32* %sv_flags2, align 4
  %and3 = and i32 %17, 65536
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %cond.true.5, label %cond.false.8

cond.true.5:                                      ; preds = %cond.end
  %18 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any6 = getelementptr inbounds %struct.sv, %struct.sv* %18, i32 0, i32 0
  %19 = load i8*, i8** %sv_any6, align 8
  %20 = bitcast i8* %19 to %struct.xpviv*
  %xiv_iv7 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %20, i32 0, i32 3
  %21 = load i64, i64* %xiv_iv7, align 8
  br label %cond.end.10

cond.false.8:                                     ; preds = %cond.end
  %22 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call9 = call i64 @Perl_sv_2iv(%struct.sv* %22)
  br label %cond.end.10

cond.end.10:                                      ; preds = %cond.false.8, %cond.true.5
  %cond11 = phi i64 [ %21, %cond.true.5 ], [ %call9, %cond.false.8 ]
  store i64 %cond11, i64* %offset, align 8
  %23 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr12 = getelementptr inbounds %struct.sv*, %struct.sv** %23, i32 -1
  store %struct.sv** %incdec.ptr12, %struct.sv*** %sp, align 8
  %24 = load %struct.sv*, %struct.sv** %23, align 8
  store %struct.sv* %24, %struct.sv** %src, align 8
  %25 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %25, i32 0, i32 6
  %26 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %26 to i32
  %and13 = and i32 %conv, 32
  %tobool14 = icmp ne i32 %and13, 0
  br i1 %tobool14, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %cond.end.10
  %27 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %27, i32 0, i32 7
  %28 = load i8, i8* %op_private, align 1
  %conv15 = zext i8 %28 to i32
  %and16 = and i32 %conv15, 8
  %tobool17 = icmp ne i32 %and16, 0
  br i1 %tobool17, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %lor.rhs
  %call18 = call i32 @Perl_is_lvalue_sub()
  %tobool19 = icmp ne i32 %call18, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %lor.rhs
  %29 = phi i1 [ false, %lor.rhs ], [ %tobool19, %land.rhs ]
  br label %lor.end

lor.end:                                          ; preds = %land.end, %cond.end.10
  %30 = phi i1 [ true, %cond.end.10 ], [ %29, %land.end ]
  %lor.ext = zext i1 %30 to i32
  store i32 %lor.ext, i32* %lvalue, align 4
  %31 = load i8, i8* @PL_tainting, align 1
  %tobool20 = icmp ne i8 %31, 0
  br i1 %tobool20, label %if.then, label %if.end

if.then:                                          ; preds = %lor.end
  %32 = load %struct.sv*, %struct.sv** %targ, align 8
  call void @Perl_sv_untaint(%struct.sv* %32)
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.end
  %33 = load i32, i32* %lvalue, align 4
  %tobool21 = icmp ne i32 %33, 0
  br i1 %tobool21, label %if.then.22, label %if.end.56

if.then.22:                                       ; preds = %if.end
  %34 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_refcnt = getelementptr inbounds %struct.sv, %struct.sv* %34, i32 0, i32 1
  %35 = load i32, i32* %sv_refcnt, align 4
  %cmp = icmp ugt i32 %35, 1
  br i1 %cmp, label %if.then.24, label %if.end.26

if.then.24:                                       ; preds = %if.then.22
  %call25 = call %struct.sv* @Perl_sv_newmortal()
  store %struct.sv* %call25, %struct.sv** %targ, align 8
  br label %if.end.26

if.end.26:                                        ; preds = %if.then.24, %if.then.22
  %36 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags27 = getelementptr inbounds %struct.sv, %struct.sv* %36, i32 0, i32 2
  %37 = load i32, i32* %sv_flags27, align 4
  %and28 = and i32 %37, 255
  %cmp29 = icmp ult i32 %and28, 9
  br i1 %cmp29, label %if.then.31, label %if.end.33

if.then.31:                                       ; preds = %if.end.26
  %38 = load %struct.sv*, %struct.sv** %targ, align 8
  %call32 = call signext i8 @Perl_sv_upgrade(%struct.sv* %38, i32 9)
  %39 = load %struct.sv*, %struct.sv** %targ, align 8
  call void @Perl_sv_magic(%struct.sv* %39, %struct.sv* null, i32 118, i8* null, i32 0)
  br label %if.end.33

if.end.33:                                        ; preds = %if.then.31, %if.end.26
  %40 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any34 = getelementptr inbounds %struct.sv, %struct.sv* %40, i32 0, i32 0
  %41 = load i8*, i8** %sv_any34, align 8
  %42 = bitcast i8* %41 to %struct.xpvlv*
  %xlv_type = getelementptr inbounds %struct.xpvlv, %struct.xpvlv* %42, i32 0, i32 10
  store i8 118, i8* %xlv_type, align 1
  %43 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any35 = getelementptr inbounds %struct.sv, %struct.sv* %43, i32 0, i32 0
  %44 = load i8*, i8** %sv_any35, align 8
  %45 = bitcast i8* %44 to %struct.xpvlv*
  %xlv_targ = getelementptr inbounds %struct.xpvlv, %struct.xpvlv* %45, i32 0, i32 9
  %46 = load %struct.sv*, %struct.sv** %xlv_targ, align 8
  %47 = load %struct.sv*, %struct.sv** %src, align 8
  %cmp36 = icmp ne %struct.sv* %46, %47
  br i1 %cmp36, label %if.then.38, label %if.end.53

if.then.38:                                       ; preds = %if.end.33
  %48 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any39 = getelementptr inbounds %struct.sv, %struct.sv* %48, i32 0, i32 0
  %49 = load i8*, i8** %sv_any39, align 8
  %50 = bitcast i8* %49 to %struct.xpvlv*
  %xlv_targ40 = getelementptr inbounds %struct.xpvlv, %struct.xpvlv* %50, i32 0, i32 9
  %51 = load %struct.sv*, %struct.sv** %xlv_targ40, align 8
  %tobool41 = icmp ne %struct.sv* %51, null
  br i1 %tobool41, label %if.then.42, label %if.end.45

if.then.42:                                       ; preds = %if.then.38
  %52 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any43 = getelementptr inbounds %struct.sv, %struct.sv* %52, i32 0, i32 0
  %53 = load i8*, i8** %sv_any43, align 8
  %54 = bitcast i8* %53 to %struct.xpvlv*
  %xlv_targ44 = getelementptr inbounds %struct.xpvlv, %struct.xpvlv* %54, i32 0, i32 9
  %55 = load %struct.sv*, %struct.sv** %xlv_targ44, align 8
  call void @Perl_sv_free(%struct.sv* %55)
  br label %if.end.45

if.end.45:                                        ; preds = %if.then.42, %if.then.38
  %56 = load %struct.sv*, %struct.sv** %src, align 8
  store %struct.sv* %56, %struct.sv** @PL_Sv, align 8
  %57 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %tobool46 = icmp ne %struct.sv* %57, null
  br i1 %tobool46, label %land.rhs.47, label %land.end.50

land.rhs.47:                                      ; preds = %if.end.45
  %58 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_refcnt48 = getelementptr inbounds %struct.sv, %struct.sv* %58, i32 0, i32 1
  %59 = load i32, i32* %sv_refcnt48, align 4
  %inc = add i32 %59, 1
  store i32 %inc, i32* %sv_refcnt48, align 4
  %tobool49 = icmp ne i32 %inc, 0
  br label %land.end.50

land.end.50:                                      ; preds = %land.rhs.47, %if.end.45
  %60 = phi i1 [ false, %if.end.45 ], [ %tobool49, %land.rhs.47 ]
  %land.ext = zext i1 %60 to i32
  %61 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %62 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any51 = getelementptr inbounds %struct.sv, %struct.sv* %62, i32 0, i32 0
  %63 = load i8*, i8** %sv_any51, align 8
  %64 = bitcast i8* %63 to %struct.xpvlv*
  %xlv_targ52 = getelementptr inbounds %struct.xpvlv, %struct.xpvlv* %64, i32 0, i32 9
  store %struct.sv* %61, %struct.sv** %xlv_targ52, align 8
  br label %if.end.53

if.end.53:                                        ; preds = %land.end.50, %if.end.33
  %65 = load i64, i64* %offset, align 8
  %66 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any54 = getelementptr inbounds %struct.sv, %struct.sv* %66, i32 0, i32 0
  %67 = load i8*, i8** %sv_any54, align 8
  %68 = bitcast i8* %67 to %struct.xpvlv*
  %xlv_targoff = getelementptr inbounds %struct.xpvlv, %struct.xpvlv* %68, i32 0, i32 7
  store i64 %65, i64* %xlv_targoff, align 8
  %69 = load i64, i64* %size, align 8
  %70 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any55 = getelementptr inbounds %struct.sv, %struct.sv* %70, i32 0, i32 0
  %71 = load i8*, i8** %sv_any55, align 8
  %72 = bitcast i8* %71 to %struct.xpvlv*
  %xlv_targlen = getelementptr inbounds %struct.xpvlv, %struct.xpvlv* %72, i32 0, i32 8
  store i64 %69, i64* %xlv_targlen, align 8
  br label %if.end.56

if.end.56:                                        ; preds = %if.end.53, %if.end
  %73 = load %struct.sv*, %struct.sv** %targ, align 8
  %74 = load %struct.sv*, %struct.sv** %src, align 8
  %75 = load i64, i64* %offset, align 8
  %conv57 = trunc i64 %75 to i32
  %76 = load i64, i64* %size, align 8
  %conv58 = trunc i64 %76 to i32
  %call59 = call i64 @Perl_do_vecget(%struct.sv* %74, i32 %conv57, i32 %conv58)
  call void @Perl_sv_setuv(%struct.sv* %73, i64 %call59)
  %77 = load %struct.sv*, %struct.sv** %targ, align 8
  %78 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr60 = getelementptr inbounds %struct.sv*, %struct.sv** %78, i32 1
  store %struct.sv** %incdec.ptr60, %struct.sv*** %sp, align 8
  store %struct.sv* %77, %struct.sv** %incdec.ptr60, align 8
  %79 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %79, %struct.sv*** @PL_stack_sp, align 8
  %80 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %80, i32 0, i32 0
  %81 = load %struct.op*, %struct.op** %op_next, align 8
  ret %struct.op* %81
}

declare i64 @Perl_do_vecget(%struct.sv*, i32, i32) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_index() #0 {
entry:
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %big = alloca %struct.sv*, align 8
  %little = alloca %struct.sv*, align 8
  %temp = alloca %struct.sv*, align 8
  %offset = alloca i32, align 4
  %retval1 = alloca i32, align 4
  %tmps = alloca i8*, align 8
  %tmps2 = alloca i8*, align 8
  %biglen = alloca i64, align 8
  %arybase = alloca i32, align 4
  %big_utf8 = alloca i32, align 4
  %little_utf8 = alloca i32, align 4
  %bytes = alloca %struct.sv*, align 8
  %len = alloca i64, align 8
  %p = alloca i8*, align 8
  %tmp = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 3
  %2 = load i64, i64* %op_targ, align 8
  %3 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 %2
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %4, %struct.sv** %targ, align 8
  store %struct.sv* null, %struct.sv** %temp, align 8
  %5 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_arybase = getelementptr inbounds %struct.cop, %struct.cop* %5, i32 0, i32 12
  %6 = load i32, i32* %cop_arybase, align 4
  store i32 %6, i32* %arybase, align 4
  %7 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %7, i32 0, i32 7
  %8 = load i8, i8* %op_private, align 1
  %conv = zext i8 %8 to i32
  %and = and i32 %conv, 15
  %cmp = icmp slt i32 %and, 3
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 0, i32* %offset, align 4
  br label %if.end

if.else:                                          ; preds = %entry
  %9 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %9, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %10 = load %struct.sv*, %struct.sv** %9, align 8
  store %struct.sv* %10, %struct.sv** @PL_Sv, align 8
  %11 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %11, i32 0, i32 2
  %12 = load i32, i32* %sv_flags, align 4
  %and3 = and i32 %12, 65536
  %tobool = icmp ne i32 %and3, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.else
  %13 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %13, i32 0, i32 0
  %14 = load i8*, i8** %sv_any, align 8
  %15 = bitcast i8* %14 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %15, i32 0, i32 3
  %16 = load i64, i64* %xiv_iv, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.else
  %17 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call = call i64 @Perl_sv_2iv(%struct.sv* %17)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %16, %cond.true ], [ %call, %cond.false ]
  %18 = load i32, i32* %arybase, align 4
  %conv4 = sext i32 %18 to i64
  %sub = sub nsw i64 %cond, %conv4
  %conv5 = trunc i64 %sub to i32
  store i32 %conv5, i32* %offset, align 4
  br label %if.end

if.end:                                           ; preds = %cond.end, %if.then
  %19 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr6 = getelementptr inbounds %struct.sv*, %struct.sv** %19, i32 -1
  store %struct.sv** %incdec.ptr6, %struct.sv*** %sp, align 8
  %20 = load %struct.sv*, %struct.sv** %19, align 8
  store %struct.sv* %20, %struct.sv** %little, align 8
  %21 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr7 = getelementptr inbounds %struct.sv*, %struct.sv** %21, i32 -1
  store %struct.sv** %incdec.ptr7, %struct.sv*** %sp, align 8
  %22 = load %struct.sv*, %struct.sv** %21, align 8
  store %struct.sv* %22, %struct.sv** %big, align 8
  %23 = load %struct.sv*, %struct.sv** %big, align 8
  %sv_flags8 = getelementptr inbounds %struct.sv, %struct.sv* %23, i32 0, i32 2
  %24 = load i32, i32* %sv_flags8, align 4
  %and9 = and i32 %24, 536870912
  %tobool10 = icmp ne i32 %and9, 0
  br i1 %tobool10, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end
  %25 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %op_private11 = getelementptr inbounds %struct.cop, %struct.cop* %25, i32 0, i32 7
  %26 = load i8, i8* %op_private11, align 1
  %conv12 = zext i8 %26 to i32
  %and13 = and i32 %conv12, 8
  %tobool14 = icmp ne i32 %and13, 0
  %lnot = xor i1 %tobool14, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end
  %27 = phi i1 [ false, %if.end ], [ %lnot, %land.rhs ]
  %land.ext = zext i1 %27 to i32
  store i32 %land.ext, i32* %big_utf8, align 4
  %28 = load %struct.sv*, %struct.sv** %little, align 8
  %sv_flags15 = getelementptr inbounds %struct.sv, %struct.sv* %28, i32 0, i32 2
  %29 = load i32, i32* %sv_flags15, align 4
  %and16 = and i32 %29, 536870912
  %tobool17 = icmp ne i32 %and16, 0
  br i1 %tobool17, label %land.rhs.18, label %land.end.24

land.rhs.18:                                      ; preds = %land.end
  %30 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %op_private19 = getelementptr inbounds %struct.cop, %struct.cop* %30, i32 0, i32 7
  %31 = load i8, i8* %op_private19, align 1
  %conv20 = zext i8 %31 to i32
  %and21 = and i32 %conv20, 8
  %tobool22 = icmp ne i32 %and21, 0
  %lnot23 = xor i1 %tobool22, true
  br label %land.end.24

land.end.24:                                      ; preds = %land.rhs.18, %land.end
  %32 = phi i1 [ false, %land.end ], [ %lnot23, %land.rhs.18 ]
  %land.ext25 = zext i1 %32 to i32
  store i32 %land.ext25, i32* %little_utf8, align 4
  %33 = load i32, i32* %big_utf8, align 4
  %34 = load i32, i32* %little_utf8, align 4
  %xor = xor i32 %33, %34
  %tobool26 = icmp ne i32 %xor, 0
  br i1 %tobool26, label %if.then.27, label %if.end.55

if.then.27:                                       ; preds = %land.end.24
  %35 = load i32, i32* %little_utf8, align 4
  %tobool28 = icmp ne i32 %35, 0
  br i1 %tobool28, label %cond.true.29, label %cond.false.30

cond.true.29:                                     ; preds = %if.then.27
  %36 = load %struct.sv*, %struct.sv** %big, align 8
  br label %cond.end.31

cond.false.30:                                    ; preds = %if.then.27
  %37 = load %struct.sv*, %struct.sv** %little, align 8
  br label %cond.end.31

cond.end.31:                                      ; preds = %cond.false.30, %cond.true.29
  %cond32 = phi %struct.sv* [ %36, %cond.true.29 ], [ %37, %cond.false.30 ]
  store %struct.sv* %cond32, %struct.sv** %bytes, align 8
  %38 = load %struct.sv*, %struct.sv** %bytes, align 8
  %sv_flags33 = getelementptr inbounds %struct.sv, %struct.sv* %38, i32 0, i32 2
  %39 = load i32, i32* %sv_flags33, align 4
  %and34 = and i32 %39, 262144
  %cmp35 = icmp eq i32 %and34, 262144
  br i1 %cmp35, label %cond.true.37, label %cond.false.40

cond.true.37:                                     ; preds = %cond.end.31
  %40 = load %struct.sv*, %struct.sv** %bytes, align 8
  %sv_any38 = getelementptr inbounds %struct.sv, %struct.sv* %40, i32 0, i32 0
  %41 = load i8*, i8** %sv_any38, align 8
  %42 = bitcast i8* %41 to %struct.xpv*
  %xpv_cur = getelementptr inbounds %struct.xpv, %struct.xpv* %42, i32 0, i32 1
  %43 = load i64, i64* %xpv_cur, align 8
  store i64 %43, i64* %len, align 8
  %44 = load %struct.sv*, %struct.sv** %bytes, align 8
  %sv_any39 = getelementptr inbounds %struct.sv, %struct.sv* %44, i32 0, i32 0
  %45 = load i8*, i8** %sv_any39, align 8
  %46 = bitcast i8* %45 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %46, i32 0, i32 0
  %47 = load i8*, i8** %xpv_pv, align 8
  br label %cond.end.42

cond.false.40:                                    ; preds = %cond.end.31
  %48 = load %struct.sv*, %struct.sv** %bytes, align 8
  %call41 = call i8* @Perl_sv_2pv_flags(%struct.sv* %48, i64* %len, i32 2)
  br label %cond.end.42

cond.end.42:                                      ; preds = %cond.false.40, %cond.true.37
  %cond43 = phi i8* [ %47, %cond.true.37 ], [ %call41, %cond.false.40 ]
  store i8* %cond43, i8** %p, align 8
  %49 = load i8*, i8** %p, align 8
  %50 = load i64, i64* %len, align 8
  %call44 = call %struct.sv* @Perl_newSVpvn(i8* %49, i64 %50)
  store %struct.sv* %call44, %struct.sv** %temp, align 8
  %51 = load %struct.sv*, %struct.sv** @PL_encoding, align 8
  %tobool45 = icmp ne %struct.sv* %51, null
  br i1 %tobool45, label %if.then.46, label %if.else.48

if.then.46:                                       ; preds = %cond.end.42
  %52 = load %struct.sv*, %struct.sv** %temp, align 8
  %53 = load %struct.sv*, %struct.sv** @PL_encoding, align 8
  %call47 = call i8* @Perl_sv_recode_to_utf8(%struct.sv* %52, %struct.sv* %53)
  br label %if.end.50

if.else.48:                                       ; preds = %cond.end.42
  %54 = load %struct.sv*, %struct.sv** %temp, align 8
  %call49 = call i64 @Perl_sv_utf8_upgrade_flags(%struct.sv* %54, i32 2)
  br label %if.end.50

if.end.50:                                        ; preds = %if.else.48, %if.then.46
  %55 = load i32, i32* %little_utf8, align 4
  %tobool51 = icmp ne i32 %55, 0
  br i1 %tobool51, label %if.then.52, label %if.else.53

if.then.52:                                       ; preds = %if.end.50
  %56 = load %struct.sv*, %struct.sv** %temp, align 8
  store %struct.sv* %56, %struct.sv** %big, align 8
  store i32 1, i32* %big_utf8, align 4
  br label %if.end.54

if.else.53:                                       ; preds = %if.end.50
  %57 = load %struct.sv*, %struct.sv** %temp, align 8
  store %struct.sv* %57, %struct.sv** %little, align 8
  br label %if.end.54

if.end.54:                                        ; preds = %if.else.53, %if.then.52
  br label %if.end.55

if.end.55:                                        ; preds = %if.end.54, %land.end.24
  %58 = load i32, i32* %big_utf8, align 4
  %tobool56 = icmp ne i32 %58, 0
  br i1 %tobool56, label %land.lhs.true, label %if.end.60

land.lhs.true:                                    ; preds = %if.end.55
  %59 = load i32, i32* %offset, align 4
  %cmp57 = icmp sgt i32 %59, 0
  br i1 %cmp57, label %if.then.59, label %if.end.60

if.then.59:                                       ; preds = %land.lhs.true
  %60 = load %struct.sv*, %struct.sv** %big, align 8
  call void @Perl_sv_pos_u2b(%struct.sv* %60, i32* %offset, i32* null)
  br label %if.end.60

if.end.60:                                        ; preds = %if.then.59, %land.lhs.true, %if.end.55
  %61 = load %struct.sv*, %struct.sv** %big, align 8
  %sv_flags61 = getelementptr inbounds %struct.sv, %struct.sv* %61, i32 0, i32 2
  %62 = load i32, i32* %sv_flags61, align 4
  %and62 = and i32 %62, 262144
  %cmp63 = icmp eq i32 %and62, 262144
  br i1 %cmp63, label %cond.true.65, label %cond.false.70

cond.true.65:                                     ; preds = %if.end.60
  %63 = load %struct.sv*, %struct.sv** %big, align 8
  %sv_any66 = getelementptr inbounds %struct.sv, %struct.sv* %63, i32 0, i32 0
  %64 = load i8*, i8** %sv_any66, align 8
  %65 = bitcast i8* %64 to %struct.xpv*
  %xpv_cur67 = getelementptr inbounds %struct.xpv, %struct.xpv* %65, i32 0, i32 1
  %66 = load i64, i64* %xpv_cur67, align 8
  store i64 %66, i64* %biglen, align 8
  %67 = load %struct.sv*, %struct.sv** %big, align 8
  %sv_any68 = getelementptr inbounds %struct.sv, %struct.sv* %67, i32 0, i32 0
  %68 = load i8*, i8** %sv_any68, align 8
  %69 = bitcast i8* %68 to %struct.xpv*
  %xpv_pv69 = getelementptr inbounds %struct.xpv, %struct.xpv* %69, i32 0, i32 0
  %70 = load i8*, i8** %xpv_pv69, align 8
  br label %cond.end.72

cond.false.70:                                    ; preds = %if.end.60
  %71 = load %struct.sv*, %struct.sv** %big, align 8
  %call71 = call i8* @Perl_sv_2pv_flags(%struct.sv* %71, i64* %biglen, i32 2)
  br label %cond.end.72

cond.end.72:                                      ; preds = %cond.false.70, %cond.true.65
  %cond73 = phi i8* [ %70, %cond.true.65 ], [ %call71, %cond.false.70 ]
  store i8* %cond73, i8** %tmps, align 8
  %72 = load i32, i32* %offset, align 4
  %cmp74 = icmp slt i32 %72, 0
  br i1 %cmp74, label %if.then.76, label %if.else.77

if.then.76:                                       ; preds = %cond.end.72
  store i32 0, i32* %offset, align 4
  br label %if.end.84

if.else.77:                                       ; preds = %cond.end.72
  %73 = load i32, i32* %offset, align 4
  %74 = load i64, i64* %biglen, align 8
  %conv78 = trunc i64 %74 to i32
  %cmp79 = icmp sgt i32 %73, %conv78
  br i1 %cmp79, label %if.then.81, label %if.end.83

if.then.81:                                       ; preds = %if.else.77
  %75 = load i64, i64* %biglen, align 8
  %conv82 = trunc i64 %75 to i32
  store i32 %conv82, i32* %offset, align 4
  br label %if.end.83

if.end.83:                                        ; preds = %if.then.81, %if.else.77
  br label %if.end.84

if.end.84:                                        ; preds = %if.end.83, %if.then.76
  %76 = load i8*, i8** %tmps, align 8
  %77 = load i32, i32* %offset, align 4
  %idx.ext = sext i32 %77 to i64
  %add.ptr = getelementptr inbounds i8, i8* %76, i64 %idx.ext
  %78 = load i8*, i8** %tmps, align 8
  %79 = load i64, i64* %biglen, align 8
  %add.ptr85 = getelementptr inbounds i8, i8* %78, i64 %79
  %80 = load %struct.sv*, %struct.sv** %little, align 8
  %call86 = call i8* @Perl_fbm_instr(i8* %add.ptr, i8* %add.ptr85, %struct.sv* %80, i32 0)
  store i8* %call86, i8** %tmps2, align 8
  %tobool87 = icmp ne i8* %call86, null
  br i1 %tobool87, label %if.else.89, label %if.then.88

if.then.88:                                       ; preds = %if.end.84
  store i32 -1, i32* %retval1, align 4
  br label %if.end.91

if.else.89:                                       ; preds = %if.end.84
  %81 = load i8*, i8** %tmps2, align 8
  %82 = load i8*, i8** %tmps, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %81 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %82 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv90 = trunc i64 %sub.ptr.sub to i32
  store i32 %conv90, i32* %retval1, align 4
  br label %if.end.91

if.end.91:                                        ; preds = %if.else.89, %if.then.88
  %83 = load i32, i32* %retval1, align 4
  %cmp92 = icmp sgt i32 %83, 0
  br i1 %cmp92, label %land.lhs.true.94, label %if.end.97

land.lhs.true.94:                                 ; preds = %if.end.91
  %84 = load i32, i32* %big_utf8, align 4
  %tobool95 = icmp ne i32 %84, 0
  br i1 %tobool95, label %if.then.96, label %if.end.97

if.then.96:                                       ; preds = %land.lhs.true.94
  %85 = load %struct.sv*, %struct.sv** %big, align 8
  call void @Perl_sv_pos_b2u(%struct.sv* %85, i32* %retval1)
  br label %if.end.97

if.end.97:                                        ; preds = %if.then.96, %land.lhs.true.94, %if.end.91
  %86 = load %struct.sv*, %struct.sv** %temp, align 8
  %tobool98 = icmp ne %struct.sv* %86, null
  br i1 %tobool98, label %if.then.99, label %if.end.100

if.then.99:                                       ; preds = %if.end.97
  %87 = load %struct.sv*, %struct.sv** %temp, align 8
  call void @Perl_sv_free(%struct.sv* %87)
  br label %if.end.100

if.end.100:                                       ; preds = %if.then.99, %if.end.97
  %88 = load %struct.sv*, %struct.sv** %targ, align 8
  %89 = load i32, i32* %retval1, align 4
  %90 = load i32, i32* %arybase, align 4
  %add = add nsw i32 %89, %90
  %conv101 = sext i32 %add to i64
  call void @Perl_sv_setiv(%struct.sv* %88, i64 %conv101)
  %91 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags102 = getelementptr inbounds %struct.sv, %struct.sv* %91, i32 0, i32 2
  %92 = load i32, i32* %sv_flags102, align 4
  %and103 = and i32 %92, 16384
  %tobool104 = icmp ne i32 %and103, 0
  br i1 %tobool104, label %if.then.105, label %if.end.107

if.then.105:                                      ; preds = %if.end.100
  %93 = load %struct.sv*, %struct.sv** %targ, align 8
  %call106 = call i32 @Perl_mg_set(%struct.sv* %93)
  br label %if.end.107

if.end.107:                                       ; preds = %if.then.105, %if.end.100
  %94 = load %struct.sv*, %struct.sv** %targ, align 8
  %95 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr108 = getelementptr inbounds %struct.sv*, %struct.sv** %95, i32 1
  store %struct.sv** %incdec.ptr108, %struct.sv*** %sp, align 8
  store %struct.sv* %94, %struct.sv** %incdec.ptr108, align 8
  store %struct.sv* %94, %struct.sv** %tmp
  %96 = load %struct.sv*, %struct.sv** %tmp
  %97 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %97, %struct.sv*** @PL_stack_sp, align 8
  %98 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %98, i32 0, i32 0
  %99 = load %struct.op*, %struct.op** %op_next, align 8
  ret %struct.op* %99
}

declare i8* @Perl_sv_recode_to_utf8(%struct.sv*, %struct.sv*) #1

declare i8* @Perl_fbm_instr(i8*, i8*, %struct.sv*, i32) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_rindex() #0 {
entry:
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %big = alloca %struct.sv*, align 8
  %little = alloca %struct.sv*, align 8
  %temp = alloca %struct.sv*, align 8
  %blen = alloca i64, align 8
  %llen = alloca i64, align 8
  %offset = alloca i32, align 4
  %retval1 = alloca i32, align 4
  %tmps = alloca i8*, align 8
  %tmps2 = alloca i8*, align 8
  %arybase = alloca i32, align 4
  %big_utf8 = alloca i32, align 4
  %little_utf8 = alloca i32, align 4
  %bytes = alloca %struct.sv*, align 8
  %len = alloca i64, align 8
  %p = alloca i8*, align 8
  %tmp = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 3
  %2 = load i64, i64* %op_targ, align 8
  %3 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 %2
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %4, %struct.sv** %targ, align 8
  store %struct.sv* null, %struct.sv** %temp, align 8
  %5 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_arybase = getelementptr inbounds %struct.cop, %struct.cop* %5, i32 0, i32 12
  %6 = load i32, i32* %cop_arybase, align 4
  store i32 %6, i32* %arybase, align 4
  %7 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %7, i32 0, i32 7
  %8 = load i8, i8* %op_private, align 1
  %conv = zext i8 %8 to i32
  %and = and i32 %conv, 15
  %cmp = icmp sge i32 %and, 3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %9 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %9, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %10 = load %struct.sv*, %struct.sv** %9, align 8
  store %struct.sv* %10, %struct.sv** @PL_Sv, align 8
  %11 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %11, i32 0, i32 2
  %12 = load i32, i32* %sv_flags, align 4
  %and3 = and i32 %12, 65536
  %tobool = icmp ne i32 %and3, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  %13 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %13, i32 0, i32 0
  %14 = load i8*, i8** %sv_any, align 8
  %15 = bitcast i8* %14 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %15, i32 0, i32 3
  %16 = load i64, i64* %xiv_iv, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then
  %17 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call = call i64 @Perl_sv_2iv(%struct.sv* %17)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %16, %cond.true ], [ %call, %cond.false ]
  %conv4 = trunc i64 %cond to i32
  store i32 %conv4, i32* %offset, align 4
  br label %if.end

if.end:                                           ; preds = %cond.end, %entry
  %18 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr5 = getelementptr inbounds %struct.sv*, %struct.sv** %18, i32 -1
  store %struct.sv** %incdec.ptr5, %struct.sv*** %sp, align 8
  %19 = load %struct.sv*, %struct.sv** %18, align 8
  store %struct.sv* %19, %struct.sv** %little, align 8
  %20 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr6 = getelementptr inbounds %struct.sv*, %struct.sv** %20, i32 -1
  store %struct.sv** %incdec.ptr6, %struct.sv*** %sp, align 8
  %21 = load %struct.sv*, %struct.sv** %20, align 8
  store %struct.sv* %21, %struct.sv** %big, align 8
  %22 = load %struct.sv*, %struct.sv** %big, align 8
  %sv_flags7 = getelementptr inbounds %struct.sv, %struct.sv* %22, i32 0, i32 2
  %23 = load i32, i32* %sv_flags7, align 4
  %and8 = and i32 %23, 536870912
  %tobool9 = icmp ne i32 %and8, 0
  br i1 %tobool9, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.end
  %24 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %op_private10 = getelementptr inbounds %struct.cop, %struct.cop* %24, i32 0, i32 7
  %25 = load i8, i8* %op_private10, align 1
  %conv11 = zext i8 %25 to i32
  %and12 = and i32 %conv11, 8
  %tobool13 = icmp ne i32 %and12, 0
  %lnot = xor i1 %tobool13, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.end
  %26 = phi i1 [ false, %if.end ], [ %lnot, %land.rhs ]
  %land.ext = zext i1 %26 to i32
  store i32 %land.ext, i32* %big_utf8, align 4
  %27 = load %struct.sv*, %struct.sv** %little, align 8
  %sv_flags14 = getelementptr inbounds %struct.sv, %struct.sv* %27, i32 0, i32 2
  %28 = load i32, i32* %sv_flags14, align 4
  %and15 = and i32 %28, 536870912
  %tobool16 = icmp ne i32 %and15, 0
  br i1 %tobool16, label %land.rhs.17, label %land.end.23

land.rhs.17:                                      ; preds = %land.end
  %29 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %op_private18 = getelementptr inbounds %struct.cop, %struct.cop* %29, i32 0, i32 7
  %30 = load i8, i8* %op_private18, align 1
  %conv19 = zext i8 %30 to i32
  %and20 = and i32 %conv19, 8
  %tobool21 = icmp ne i32 %and20, 0
  %lnot22 = xor i1 %tobool21, true
  br label %land.end.23

land.end.23:                                      ; preds = %land.rhs.17, %land.end
  %31 = phi i1 [ false, %land.end ], [ %lnot22, %land.rhs.17 ]
  %land.ext24 = zext i1 %31 to i32
  store i32 %land.ext24, i32* %little_utf8, align 4
  %32 = load i32, i32* %big_utf8, align 4
  %33 = load i32, i32* %little_utf8, align 4
  %xor = xor i32 %32, %33
  %tobool25 = icmp ne i32 %xor, 0
  br i1 %tobool25, label %if.then.26, label %if.end.53

if.then.26:                                       ; preds = %land.end.23
  %34 = load i32, i32* %little_utf8, align 4
  %tobool27 = icmp ne i32 %34, 0
  br i1 %tobool27, label %cond.true.28, label %cond.false.29

cond.true.28:                                     ; preds = %if.then.26
  %35 = load %struct.sv*, %struct.sv** %big, align 8
  br label %cond.end.30

cond.false.29:                                    ; preds = %if.then.26
  %36 = load %struct.sv*, %struct.sv** %little, align 8
  br label %cond.end.30

cond.end.30:                                      ; preds = %cond.false.29, %cond.true.28
  %cond31 = phi %struct.sv* [ %35, %cond.true.28 ], [ %36, %cond.false.29 ]
  store %struct.sv* %cond31, %struct.sv** %bytes, align 8
  %37 = load %struct.sv*, %struct.sv** %bytes, align 8
  %sv_flags32 = getelementptr inbounds %struct.sv, %struct.sv* %37, i32 0, i32 2
  %38 = load i32, i32* %sv_flags32, align 4
  %and33 = and i32 %38, 262144
  %cmp34 = icmp eq i32 %and33, 262144
  br i1 %cmp34, label %cond.true.36, label %cond.false.39

cond.true.36:                                     ; preds = %cond.end.30
  %39 = load %struct.sv*, %struct.sv** %bytes, align 8
  %sv_any37 = getelementptr inbounds %struct.sv, %struct.sv* %39, i32 0, i32 0
  %40 = load i8*, i8** %sv_any37, align 8
  %41 = bitcast i8* %40 to %struct.xpv*
  %xpv_cur = getelementptr inbounds %struct.xpv, %struct.xpv* %41, i32 0, i32 1
  %42 = load i64, i64* %xpv_cur, align 8
  store i64 %42, i64* %len, align 8
  %43 = load %struct.sv*, %struct.sv** %bytes, align 8
  %sv_any38 = getelementptr inbounds %struct.sv, %struct.sv* %43, i32 0, i32 0
  %44 = load i8*, i8** %sv_any38, align 8
  %45 = bitcast i8* %44 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %45, i32 0, i32 0
  %46 = load i8*, i8** %xpv_pv, align 8
  br label %cond.end.41

cond.false.39:                                    ; preds = %cond.end.30
  %47 = load %struct.sv*, %struct.sv** %bytes, align 8
  %call40 = call i8* @Perl_sv_2pv_flags(%struct.sv* %47, i64* %len, i32 2)
  br label %cond.end.41

cond.end.41:                                      ; preds = %cond.false.39, %cond.true.36
  %cond42 = phi i8* [ %46, %cond.true.36 ], [ %call40, %cond.false.39 ]
  store i8* %cond42, i8** %p, align 8
  %48 = load i8*, i8** %p, align 8
  %49 = load i64, i64* %len, align 8
  %call43 = call %struct.sv* @Perl_newSVpvn(i8* %48, i64 %49)
  store %struct.sv* %call43, %struct.sv** %temp, align 8
  %50 = load %struct.sv*, %struct.sv** @PL_encoding, align 8
  %tobool44 = icmp ne %struct.sv* %50, null
  br i1 %tobool44, label %if.then.45, label %if.else

if.then.45:                                       ; preds = %cond.end.41
  %51 = load %struct.sv*, %struct.sv** %temp, align 8
  %52 = load %struct.sv*, %struct.sv** @PL_encoding, align 8
  %call46 = call i8* @Perl_sv_recode_to_utf8(%struct.sv* %51, %struct.sv* %52)
  br label %if.end.48

if.else:                                          ; preds = %cond.end.41
  %53 = load %struct.sv*, %struct.sv** %temp, align 8
  %call47 = call i64 @Perl_sv_utf8_upgrade_flags(%struct.sv* %53, i32 2)
  br label %if.end.48

if.end.48:                                        ; preds = %if.else, %if.then.45
  %54 = load i32, i32* %little_utf8, align 4
  %tobool49 = icmp ne i32 %54, 0
  br i1 %tobool49, label %if.then.50, label %if.else.51

if.then.50:                                       ; preds = %if.end.48
  %55 = load %struct.sv*, %struct.sv** %temp, align 8
  store %struct.sv* %55, %struct.sv** %big, align 8
  store i32 1, i32* %big_utf8, align 4
  br label %if.end.52

if.else.51:                                       ; preds = %if.end.48
  %56 = load %struct.sv*, %struct.sv** %temp, align 8
  store %struct.sv* %56, %struct.sv** %little, align 8
  br label %if.end.52

if.end.52:                                        ; preds = %if.else.51, %if.then.50
  br label %if.end.53

if.end.53:                                        ; preds = %if.end.52, %land.end.23
  %57 = load %struct.sv*, %struct.sv** %little, align 8
  %sv_flags54 = getelementptr inbounds %struct.sv, %struct.sv* %57, i32 0, i32 2
  %58 = load i32, i32* %sv_flags54, align 4
  %and55 = and i32 %58, 262144
  %cmp56 = icmp eq i32 %and55, 262144
  br i1 %cmp56, label %cond.true.58, label %cond.false.63

cond.true.58:                                     ; preds = %if.end.53
  %59 = load %struct.sv*, %struct.sv** %little, align 8
  %sv_any59 = getelementptr inbounds %struct.sv, %struct.sv* %59, i32 0, i32 0
  %60 = load i8*, i8** %sv_any59, align 8
  %61 = bitcast i8* %60 to %struct.xpv*
  %xpv_cur60 = getelementptr inbounds %struct.xpv, %struct.xpv* %61, i32 0, i32 1
  %62 = load i64, i64* %xpv_cur60, align 8
  store i64 %62, i64* %llen, align 8
  %63 = load %struct.sv*, %struct.sv** %little, align 8
  %sv_any61 = getelementptr inbounds %struct.sv, %struct.sv* %63, i32 0, i32 0
  %64 = load i8*, i8** %sv_any61, align 8
  %65 = bitcast i8* %64 to %struct.xpv*
  %xpv_pv62 = getelementptr inbounds %struct.xpv, %struct.xpv* %65, i32 0, i32 0
  %66 = load i8*, i8** %xpv_pv62, align 8
  br label %cond.end.65

cond.false.63:                                    ; preds = %if.end.53
  %67 = load %struct.sv*, %struct.sv** %little, align 8
  %call64 = call i8* @Perl_sv_2pv_flags(%struct.sv* %67, i64* %llen, i32 2)
  br label %cond.end.65

cond.end.65:                                      ; preds = %cond.false.63, %cond.true.58
  %cond66 = phi i8* [ %66, %cond.true.58 ], [ %call64, %cond.false.63 ]
  store i8* %cond66, i8** %tmps2, align 8
  %68 = load %struct.sv*, %struct.sv** %big, align 8
  %sv_flags67 = getelementptr inbounds %struct.sv, %struct.sv* %68, i32 0, i32 2
  %69 = load i32, i32* %sv_flags67, align 4
  %and68 = and i32 %69, 262144
  %cmp69 = icmp eq i32 %and68, 262144
  br i1 %cmp69, label %cond.true.71, label %cond.false.76

cond.true.71:                                     ; preds = %cond.end.65
  %70 = load %struct.sv*, %struct.sv** %big, align 8
  %sv_any72 = getelementptr inbounds %struct.sv, %struct.sv* %70, i32 0, i32 0
  %71 = load i8*, i8** %sv_any72, align 8
  %72 = bitcast i8* %71 to %struct.xpv*
  %xpv_cur73 = getelementptr inbounds %struct.xpv, %struct.xpv* %72, i32 0, i32 1
  %73 = load i64, i64* %xpv_cur73, align 8
  store i64 %73, i64* %blen, align 8
  %74 = load %struct.sv*, %struct.sv** %big, align 8
  %sv_any74 = getelementptr inbounds %struct.sv, %struct.sv* %74, i32 0, i32 0
  %75 = load i8*, i8** %sv_any74, align 8
  %76 = bitcast i8* %75 to %struct.xpv*
  %xpv_pv75 = getelementptr inbounds %struct.xpv, %struct.xpv* %76, i32 0, i32 0
  %77 = load i8*, i8** %xpv_pv75, align 8
  br label %cond.end.78

cond.false.76:                                    ; preds = %cond.end.65
  %78 = load %struct.sv*, %struct.sv** %big, align 8
  %call77 = call i8* @Perl_sv_2pv_flags(%struct.sv* %78, i64* %blen, i32 2)
  br label %cond.end.78

cond.end.78:                                      ; preds = %cond.false.76, %cond.true.71
  %cond79 = phi i8* [ %77, %cond.true.71 ], [ %call77, %cond.false.76 ]
  store i8* %cond79, i8** %tmps, align 8
  %79 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_private80 = getelementptr inbounds %struct.op, %struct.op* %79, i32 0, i32 7
  %80 = load i8, i8* %op_private80, align 1
  %conv81 = zext i8 %80 to i32
  %and82 = and i32 %conv81, 15
  %cmp83 = icmp slt i32 %and82, 3
  br i1 %cmp83, label %if.then.85, label %if.else.87

if.then.85:                                       ; preds = %cond.end.78
  %81 = load i64, i64* %blen, align 8
  %conv86 = trunc i64 %81 to i32
  store i32 %conv86, i32* %offset, align 4
  br label %if.end.95

if.else.87:                                       ; preds = %cond.end.78
  %82 = load i32, i32* %offset, align 4
  %cmp88 = icmp sgt i32 %82, 0
  br i1 %cmp88, label %land.lhs.true, label %if.end.92

land.lhs.true:                                    ; preds = %if.else.87
  %83 = load i32, i32* %big_utf8, align 4
  %tobool90 = icmp ne i32 %83, 0
  br i1 %tobool90, label %if.then.91, label %if.end.92

if.then.91:                                       ; preds = %land.lhs.true
  %84 = load %struct.sv*, %struct.sv** %big, align 8
  call void @Perl_sv_pos_u2b(%struct.sv* %84, i32* %offset, i32* null)
  br label %if.end.92

if.end.92:                                        ; preds = %if.then.91, %land.lhs.true, %if.else.87
  %85 = load i32, i32* %offset, align 4
  %86 = load i32, i32* %arybase, align 4
  %sub = sub nsw i32 %85, %86
  %conv93 = sext i32 %sub to i64
  %87 = load i64, i64* %llen, align 8
  %add = add i64 %conv93, %87
  %conv94 = trunc i64 %add to i32
  store i32 %conv94, i32* %offset, align 4
  br label %if.end.95

if.end.95:                                        ; preds = %if.end.92, %if.then.85
  %88 = load i32, i32* %offset, align 4
  %cmp96 = icmp slt i32 %88, 0
  br i1 %cmp96, label %if.then.98, label %if.else.99

if.then.98:                                       ; preds = %if.end.95
  store i32 0, i32* %offset, align 4
  br label %if.end.106

if.else.99:                                       ; preds = %if.end.95
  %89 = load i32, i32* %offset, align 4
  %90 = load i64, i64* %blen, align 8
  %conv100 = trunc i64 %90 to i32
  %cmp101 = icmp sgt i32 %89, %conv100
  br i1 %cmp101, label %if.then.103, label %if.end.105

if.then.103:                                      ; preds = %if.else.99
  %91 = load i64, i64* %blen, align 8
  %conv104 = trunc i64 %91 to i32
  store i32 %conv104, i32* %offset, align 4
  br label %if.end.105

if.end.105:                                       ; preds = %if.then.103, %if.else.99
  br label %if.end.106

if.end.106:                                       ; preds = %if.end.105, %if.then.98
  %92 = load i8*, i8** %tmps, align 8
  %93 = load i8*, i8** %tmps, align 8
  %94 = load i32, i32* %offset, align 4
  %idx.ext = sext i32 %94 to i64
  %add.ptr = getelementptr inbounds i8, i8* %93, i64 %idx.ext
  %95 = load i8*, i8** %tmps2, align 8
  %96 = load i8*, i8** %tmps2, align 8
  %97 = load i64, i64* %llen, align 8
  %add.ptr107 = getelementptr inbounds i8, i8* %96, i64 %97
  %call108 = call i8* @Perl_rninstr(i8* %92, i8* %add.ptr, i8* %95, i8* %add.ptr107)
  store i8* %call108, i8** %tmps2, align 8
  %tobool109 = icmp ne i8* %call108, null
  br i1 %tobool109, label %if.else.111, label %if.then.110

if.then.110:                                      ; preds = %if.end.106
  store i32 -1, i32* %retval1, align 4
  br label %if.end.113

if.else.111:                                      ; preds = %if.end.106
  %98 = load i8*, i8** %tmps2, align 8
  %99 = load i8*, i8** %tmps, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %98 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %99 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv112 = trunc i64 %sub.ptr.sub to i32
  store i32 %conv112, i32* %retval1, align 4
  br label %if.end.113

if.end.113:                                       ; preds = %if.else.111, %if.then.110
  %100 = load i32, i32* %retval1, align 4
  %cmp114 = icmp sgt i32 %100, 0
  br i1 %cmp114, label %land.lhs.true.116, label %if.end.119

land.lhs.true.116:                                ; preds = %if.end.113
  %101 = load i32, i32* %big_utf8, align 4
  %tobool117 = icmp ne i32 %101, 0
  br i1 %tobool117, label %if.then.118, label %if.end.119

if.then.118:                                      ; preds = %land.lhs.true.116
  %102 = load %struct.sv*, %struct.sv** %big, align 8
  call void @Perl_sv_pos_b2u(%struct.sv* %102, i32* %retval1)
  br label %if.end.119

if.end.119:                                       ; preds = %if.then.118, %land.lhs.true.116, %if.end.113
  %103 = load %struct.sv*, %struct.sv** %temp, align 8
  %tobool120 = icmp ne %struct.sv* %103, null
  br i1 %tobool120, label %if.then.121, label %if.end.122

if.then.121:                                      ; preds = %if.end.119
  %104 = load %struct.sv*, %struct.sv** %temp, align 8
  call void @Perl_sv_free(%struct.sv* %104)
  br label %if.end.122

if.end.122:                                       ; preds = %if.then.121, %if.end.119
  %105 = load %struct.sv*, %struct.sv** %targ, align 8
  %106 = load i32, i32* %retval1, align 4
  %107 = load i32, i32* %arybase, align 4
  %add123 = add nsw i32 %106, %107
  %conv124 = sext i32 %add123 to i64
  call void @Perl_sv_setiv(%struct.sv* %105, i64 %conv124)
  %108 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags125 = getelementptr inbounds %struct.sv, %struct.sv* %108, i32 0, i32 2
  %109 = load i32, i32* %sv_flags125, align 4
  %and126 = and i32 %109, 16384
  %tobool127 = icmp ne i32 %and126, 0
  br i1 %tobool127, label %if.then.128, label %if.end.130

if.then.128:                                      ; preds = %if.end.122
  %110 = load %struct.sv*, %struct.sv** %targ, align 8
  %call129 = call i32 @Perl_mg_set(%struct.sv* %110)
  br label %if.end.130

if.end.130:                                       ; preds = %if.then.128, %if.end.122
  %111 = load %struct.sv*, %struct.sv** %targ, align 8
  %112 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr131 = getelementptr inbounds %struct.sv*, %struct.sv** %112, i32 1
  store %struct.sv** %incdec.ptr131, %struct.sv*** %sp, align 8
  store %struct.sv* %111, %struct.sv** %incdec.ptr131, align 8
  store %struct.sv* %111, %struct.sv** %tmp
  %113 = load %struct.sv*, %struct.sv** %tmp
  %114 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %114, %struct.sv*** @PL_stack_sp, align 8
  %115 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %115, i32 0, i32 0
  %116 = load %struct.op*, %struct.op** %op_next, align 8
  ret %struct.op* %116
}

declare i8* @Perl_rninstr(i8*, i8*, i8*, i8*) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_sprintf() #0 {
entry:
  %sp = alloca %struct.sv**, align 8
  %mark = alloca %struct.sv**, align 8
  %origmark = alloca i32, align 4
  %targ = alloca %struct.sv*, align 8
  %tmp = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %2 = load i32*, i32** @PL_markstack_ptr, align 8
  %incdec.ptr = getelementptr inbounds i32, i32* %2, i32 -1
  store i32* %incdec.ptr, i32** @PL_markstack_ptr, align 8
  %3 = load i32, i32* %2, align 4
  %idx.ext = sext i32 %3 to i64
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %1, i64 %idx.ext
  store %struct.sv** %add.ptr, %struct.sv*** %mark, align 8
  %4 = load %struct.sv**, %struct.sv*** %mark, align 8
  %5 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %4 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %5 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %conv = trunc i64 %sub.ptr.div to i32
  store i32 %conv, i32* %origmark, align 4
  %6 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %6, i32 0, i32 3
  %7 = load i64, i64* %op_targ, align 8
  %8 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %8, i64 %7
  %9 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %9, %struct.sv** %targ, align 8
  %10 = load %struct.sv*, %struct.sv** %targ, align 8
  %11 = load %struct.sv**, %struct.sv*** %sp, align 8
  %12 = load %struct.sv**, %struct.sv*** %mark, align 8
  %sub.ptr.lhs.cast1 = ptrtoint %struct.sv** %11 to i64
  %sub.ptr.rhs.cast2 = ptrtoint %struct.sv** %12 to i64
  %sub.ptr.sub3 = sub i64 %sub.ptr.lhs.cast1, %sub.ptr.rhs.cast2
  %sub.ptr.div4 = sdiv exact i64 %sub.ptr.sub3, 8
  %conv5 = trunc i64 %sub.ptr.div4 to i32
  %13 = load %struct.sv**, %struct.sv*** %mark, align 8
  %add.ptr6 = getelementptr inbounds %struct.sv*, %struct.sv** %13, i64 1
  call void @Perl_do_sprintf(%struct.sv* %10, i32 %conv5, %struct.sv** %add.ptr6)
  %14 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %14, i32 0, i32 2
  %15 = load i32, i32* %sv_flags, align 4
  %and = and i32 %15, 57344
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %16 = load %struct.sv*, %struct.sv** %targ, align 8
  %call = call signext i8 @Perl_sv_tainted(%struct.sv* %16)
  %conv7 = sext i8 %call to i32
  %tobool8 = icmp ne i32 %conv7, 0
  br i1 %tobool8, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store i8 1, i8* @PL_tainted, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %17 = load %struct.sv**, %struct.sv*** %mark, align 8
  %add.ptr9 = getelementptr inbounds %struct.sv*, %struct.sv** %17, i64 1
  %18 = load %struct.sv*, %struct.sv** %add.ptr9, align 8
  %sv_flags10 = getelementptr inbounds %struct.sv, %struct.sv* %18, i32 0, i32 2
  %19 = load i32, i32* %sv_flags10, align 4
  %and11 = and i32 %19, 536870912
  %tobool12 = icmp ne i32 %and11, 0
  br i1 %tobool12, label %land.lhs.true.13, label %if.end.19

land.lhs.true.13:                                 ; preds = %if.end
  %20 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %op_private = getelementptr inbounds %struct.cop, %struct.cop* %20, i32 0, i32 7
  %21 = load i8, i8* %op_private, align 1
  %conv14 = zext i8 %21 to i32
  %and15 = and i32 %conv14, 8
  %tobool16 = icmp ne i32 %and15, 0
  br i1 %tobool16, label %if.end.19, label %if.then.17

if.then.17:                                       ; preds = %land.lhs.true.13
  %22 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags18 = getelementptr inbounds %struct.sv, %struct.sv* %22, i32 0, i32 2
  %23 = load i32, i32* %sv_flags18, align 4
  %or = or i32 %23, 536870912
  store i32 %or, i32* %sv_flags18, align 4
  br label %if.end.19

if.end.19:                                        ; preds = %if.then.17, %land.lhs.true.13, %if.end
  %24 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %25 = load i32, i32* %origmark, align 4
  %idx.ext20 = sext i32 %25 to i64
  %add.ptr21 = getelementptr inbounds %struct.sv*, %struct.sv** %24, i64 %idx.ext20
  store %struct.sv** %add.ptr21, %struct.sv*** %sp, align 8
  %26 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags22 = getelementptr inbounds %struct.sv, %struct.sv* %26, i32 0, i32 2
  %27 = load i32, i32* %sv_flags22, align 4
  %and23 = and i32 %27, 16384
  %tobool24 = icmp ne i32 %and23, 0
  br i1 %tobool24, label %if.then.25, label %if.end.27

if.then.25:                                       ; preds = %if.end.19
  %28 = load %struct.sv*, %struct.sv** %targ, align 8
  %call26 = call i32 @Perl_mg_set(%struct.sv* %28)
  br label %if.end.27

if.end.27:                                        ; preds = %if.then.25, %if.end.19
  %29 = load %struct.sv*, %struct.sv** %targ, align 8
  %30 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr28 = getelementptr inbounds %struct.sv*, %struct.sv** %30, i32 1
  store %struct.sv** %incdec.ptr28, %struct.sv*** %sp, align 8
  store %struct.sv* %29, %struct.sv** %incdec.ptr28, align 8
  store %struct.sv* %29, %struct.sv** %tmp
  %31 = load %struct.sv*, %struct.sv** %tmp
  %32 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %32, %struct.sv*** @PL_stack_sp, align 8
  %33 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %33, i32 0, i32 0
  %34 = load %struct.op*, %struct.op** %op_next, align 8
  ret %struct.op* %34
}

declare void @Perl_do_sprintf(%struct.sv*, i32, %struct.sv**) #1

declare signext i8 @Perl_sv_tainted(%struct.sv*) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_ord() #0 {
entry:
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %argsv = alloca %struct.sv*, align 8
  %len = alloca i64, align 8
  %s = alloca i8*, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %tmp = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 3
  %2 = load i64, i64* %op_targ, align 8
  %3 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 %2
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %4, %struct.sv** %targ, align 8
  %5 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %5, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %6 = load %struct.sv*, %struct.sv** %5, align 8
  store %struct.sv* %6, %struct.sv** %argsv, align 8
  %7 = load %struct.sv*, %struct.sv** %argsv, align 8
  store %struct.sv* %7, %struct.sv** @PL_Sv, align 8
  %8 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %8, i32 0, i32 2
  %9 = load i32, i32* %sv_flags, align 4
  %and = and i32 %9, 262144
  %cmp = icmp eq i32 %and, 262144
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %10 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %10, i32 0, i32 0
  %11 = load i8*, i8** %sv_any, align 8
  %12 = bitcast i8* %11 to %struct.xpv*
  %xpv_cur = getelementptr inbounds %struct.xpv, %struct.xpv* %12, i32 0, i32 1
  %13 = load i64, i64* %xpv_cur, align 8
  store i64 %13, i64* %len, align 8
  %14 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any1 = getelementptr inbounds %struct.sv, %struct.sv* %14, i32 0, i32 0
  %15 = load i8*, i8** %sv_any1, align 8
  %16 = bitcast i8* %15 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %16, i32 0, i32 0
  %17 = load i8*, i8** %xpv_pv, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %18 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call = call i8* @Perl_sv_2pv_flags(%struct.sv* %18, i64* %len, i32 2)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %17, %cond.true ], [ %call, %cond.false ]
  store i8* %cond, i8** %s, align 8
  %19 = load %struct.sv*, %struct.sv** @PL_encoding, align 8
  %tobool = icmp ne %struct.sv* %19, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %cond.end
  %20 = load %struct.sv*, %struct.sv** %argsv, align 8
  %sv_flags2 = getelementptr inbounds %struct.sv, %struct.sv* %20, i32 0, i32 2
  %21 = load i32, i32* %sv_flags2, align 4
  %and3 = and i32 %21, 262144
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %land.lhs.true.5, label %if.end

land.lhs.true.5:                                  ; preds = %land.lhs.true
  %22 = load %struct.sv*, %struct.sv** %argsv, align 8
  %sv_flags6 = getelementptr inbounds %struct.sv, %struct.sv* %22, i32 0, i32 2
  %23 = load i32, i32* %sv_flags6, align 4
  %and7 = and i32 %23, 536870912
  %tobool8 = icmp ne i32 %and7, 0
  br i1 %tobool8, label %land.lhs.true.9, label %if.then

land.lhs.true.9:                                  ; preds = %land.lhs.true.5
  %24 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %op_private = getelementptr inbounds %struct.cop, %struct.cop* %24, i32 0, i32 7
  %25 = load i8, i8* %op_private, align 1
  %conv = zext i8 %25 to i32
  %and10 = and i32 %conv, 8
  %tobool11 = icmp ne i32 %and10, 0
  br i1 %tobool11, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true.9, %land.lhs.true.5
  %26 = load %struct.sv*, %struct.sv** %argsv, align 8
  %call12 = call %struct.sv* @Perl_newSVsv(%struct.sv* %26)
  %call13 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call12)
  store %struct.sv* %call13, %struct.sv** %tmpsv, align 8
  %27 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %28 = load %struct.sv*, %struct.sv** @PL_encoding, align 8
  %call14 = call i8* @Perl_sv_recode_to_utf8(%struct.sv* %27, %struct.sv* %28)
  store i8* %call14, i8** %s, align 8
  %29 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  store %struct.sv* %29, %struct.sv** %argsv, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true.9, %land.lhs.true, %cond.end
  %30 = load %struct.sv*, %struct.sv** %targ, align 8
  %31 = load %struct.sv*, %struct.sv** %argsv, align 8
  %sv_flags15 = getelementptr inbounds %struct.sv, %struct.sv* %31, i32 0, i32 2
  %32 = load i32, i32* %sv_flags15, align 4
  %and16 = and i32 %32, 536870912
  %tobool17 = icmp ne i32 %and16, 0
  br i1 %tobool17, label %land.lhs.true.18, label %cond.false.25

land.lhs.true.18:                                 ; preds = %if.end
  %33 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %op_private19 = getelementptr inbounds %struct.cop, %struct.cop* %33, i32 0, i32 7
  %34 = load i8, i8* %op_private19, align 1
  %conv20 = zext i8 %34 to i32
  %and21 = and i32 %conv20, 8
  %tobool22 = icmp ne i32 %and21, 0
  br i1 %tobool22, label %cond.false.25, label %cond.true.23

cond.true.23:                                     ; preds = %land.lhs.true.18
  %35 = load i8*, i8** %s, align 8
  %call24 = call i64 @Perl_utf8n_to_uvuni(i8* %35, i64 13, i64* null, i32 105)
  br label %cond.end.29

cond.false.25:                                    ; preds = %land.lhs.true.18, %if.end
  %36 = load i8*, i8** %s, align 8
  %37 = load i8, i8* %36, align 1
  %conv26 = zext i8 %37 to i32
  %and27 = and i32 %conv26, 255
  %conv28 = sext i32 %and27 to i64
  br label %cond.end.29

cond.end.29:                                      ; preds = %cond.false.25, %cond.true.23
  %cond30 = phi i64 [ %call24, %cond.true.23 ], [ %conv28, %cond.false.25 ]
  call void @Perl_sv_setuv(%struct.sv* %30, i64 %cond30)
  %38 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags31 = getelementptr inbounds %struct.sv, %struct.sv* %38, i32 0, i32 2
  %39 = load i32, i32* %sv_flags31, align 4
  %and32 = and i32 %39, 16384
  %tobool33 = icmp ne i32 %and32, 0
  br i1 %tobool33, label %if.then.34, label %if.end.36

if.then.34:                                       ; preds = %cond.end.29
  %40 = load %struct.sv*, %struct.sv** %targ, align 8
  %call35 = call i32 @Perl_mg_set(%struct.sv* %40)
  br label %if.end.36

if.end.36:                                        ; preds = %if.then.34, %cond.end.29
  %41 = load %struct.sv**, %struct.sv*** @PL_stack_max, align 8
  %42 = load %struct.sv**, %struct.sv*** %sp, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %41 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %42 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %cmp37 = icmp slt i64 %sub.ptr.div, 1
  br i1 %cmp37, label %if.then.39, label %if.end.41

if.then.39:                                       ; preds = %if.end.36
  %43 = load %struct.sv**, %struct.sv*** %sp, align 8
  %44 = load %struct.sv**, %struct.sv*** %sp, align 8
  %call40 = call %struct.sv** @Perl_stack_grow(%struct.sv** %43, %struct.sv** %44, i32 1)
  store %struct.sv** %call40, %struct.sv*** %sp, align 8
  br label %if.end.41

if.end.41:                                        ; preds = %if.then.39, %if.end.36
  %45 = load %struct.sv*, %struct.sv** %targ, align 8
  %46 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr42 = getelementptr inbounds %struct.sv*, %struct.sv** %46, i32 1
  store %struct.sv** %incdec.ptr42, %struct.sv*** %sp, align 8
  store %struct.sv* %45, %struct.sv** %incdec.ptr42, align 8
  store %struct.sv* %45, %struct.sv** %tmp
  %47 = load %struct.sv*, %struct.sv** %tmp
  %48 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %48, %struct.sv*** @PL_stack_sp, align 8
  %49 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %49, i32 0, i32 0
  %50 = load %struct.op*, %struct.op** %op_next, align 8
  ret %struct.op* %50
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_chr() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %tmps = alloca i8*, align 8
  %value = alloca i64, align 8
  %tmp = alloca i64, align 8
  %tmp118 = alloca %struct.sv*, align 8
  %tmp132 = alloca i64, align 8
  %tmp178 = alloca i64, align 8
  %tmp205 = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 3
  %2 = load i64, i64* %op_targ, align 8
  %3 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 %2
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %4, %struct.sv** %targ, align 8
  %5 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %5, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %6 = load %struct.sv*, %struct.sv** %5, align 8
  store %struct.sv* %6, %struct.sv** @PL_Sv, align 8
  %7 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %7, i32 0, i32 2
  %8 = load i32, i32* %sv_flags, align 4
  %and = and i32 %8, 65536
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %9 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %9, i32 0, i32 0
  %10 = load i8*, i8** %sv_any, align 8
  %11 = bitcast i8* %10 to %struct.xpvuv*
  %xuv_uv = getelementptr inbounds %struct.xpvuv, %struct.xpvuv* %11, i32 0, i32 3
  %12 = load i64, i64* %xuv_uv, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %13 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call = call i64 @Perl_sv_2uv(%struct.sv* %13)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %12, %cond.true ], [ %call, %cond.false ]
  store i64 %cond, i64* %value, align 8
  %14 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags1 = getelementptr inbounds %struct.sv, %struct.sv* %14, i32 0, i32 2
  %15 = load i32, i32* %sv_flags1, align 4
  %and2 = and i32 %15, 255
  %cmp = icmp uge i32 %and2, 4
  br i1 %cmp, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %cond.end
  %16 = load %struct.sv*, %struct.sv** %targ, align 8
  %call3 = call signext i8 @Perl_sv_upgrade(%struct.sv* %16, i32 4)
  %conv = sext i8 %call3 to i32
  %tobool4 = icmp ne i32 %conv, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %cond.end
  %17 = phi i1 [ true, %cond.end ], [ %tobool4, %lor.rhs ]
  %lor.ext = zext i1 %17 to i32
  %18 = load i64, i64* %value, align 8
  %cmp5 = icmp ugt i64 %18, 255
  br i1 %cmp5, label %land.lhs.true, label %if.end.120

land.lhs.true:                                    ; preds = %lor.end
  %19 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %op_private = getelementptr inbounds %struct.cop, %struct.cop* %19, i32 0, i32 7
  %20 = load i8, i8* %op_private, align 1
  %conv7 = zext i8 %20 to i32
  %and8 = and i32 %conv7, 8
  %tobool9 = icmp ne i32 %and8, 0
  br i1 %tobool9, label %if.end.120, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %21 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any10 = getelementptr inbounds %struct.sv, %struct.sv* %21, i32 0, i32 0
  %22 = load i8*, i8** %sv_any10, align 8
  %23 = bitcast i8* %22 to %struct.xpv*
  %xpv_len = getelementptr inbounds %struct.xpv, %struct.xpv* %23, i32 0, i32 2
  %24 = load i64, i64* %xpv_len, align 8
  %25 = load i64, i64* %value, align 8
  %cmp11 = icmp ult i64 %25, 128
  br i1 %cmp11, label %cond.true.13, label %cond.false.14

cond.true.13:                                     ; preds = %if.then
  br label %cond.end.48

cond.false.14:                                    ; preds = %if.then
  %26 = load i64, i64* %value, align 8
  %cmp15 = icmp ult i64 %26, 2048
  br i1 %cmp15, label %cond.true.17, label %cond.false.18

cond.true.17:                                     ; preds = %cond.false.14
  br label %cond.end.46

cond.false.18:                                    ; preds = %cond.false.14
  %27 = load i64, i64* %value, align 8
  %cmp19 = icmp ult i64 %27, 65536
  br i1 %cmp19, label %cond.true.21, label %cond.false.22

cond.true.21:                                     ; preds = %cond.false.18
  br label %cond.end.44

cond.false.22:                                    ; preds = %cond.false.18
  %28 = load i64, i64* %value, align 8
  %cmp23 = icmp ult i64 %28, 2097152
  br i1 %cmp23, label %cond.true.25, label %cond.false.26

cond.true.25:                                     ; preds = %cond.false.22
  br label %cond.end.42

cond.false.26:                                    ; preds = %cond.false.22
  %29 = load i64, i64* %value, align 8
  %cmp27 = icmp ult i64 %29, 67108864
  br i1 %cmp27, label %cond.true.29, label %cond.false.30

cond.true.29:                                     ; preds = %cond.false.26
  br label %cond.end.40

cond.false.30:                                    ; preds = %cond.false.26
  %30 = load i64, i64* %value, align 8
  %cmp31 = icmp ult i64 %30, 2147483648
  br i1 %cmp31, label %cond.true.33, label %cond.false.34

cond.true.33:                                     ; preds = %cond.false.30
  br label %cond.end.38

cond.false.34:                                    ; preds = %cond.false.30
  %31 = load i64, i64* %value, align 8
  %cmp35 = icmp ult i64 %31, 68719476736
  %cond37 = select i1 %cmp35, i32 7, i32 13
  br label %cond.end.38

cond.end.38:                                      ; preds = %cond.false.34, %cond.true.33
  %cond39 = phi i32 [ 6, %cond.true.33 ], [ %cond37, %cond.false.34 ]
  br label %cond.end.40

cond.end.40:                                      ; preds = %cond.end.38, %cond.true.29
  %cond41 = phi i32 [ 5, %cond.true.29 ], [ %cond39, %cond.end.38 ]
  br label %cond.end.42

cond.end.42:                                      ; preds = %cond.end.40, %cond.true.25
  %cond43 = phi i32 [ 4, %cond.true.25 ], [ %cond41, %cond.end.40 ]
  br label %cond.end.44

cond.end.44:                                      ; preds = %cond.end.42, %cond.true.21
  %cond45 = phi i32 [ 3, %cond.true.21 ], [ %cond43, %cond.end.42 ]
  br label %cond.end.46

cond.end.46:                                      ; preds = %cond.end.44, %cond.true.17
  %cond47 = phi i32 [ 2, %cond.true.17 ], [ %cond45, %cond.end.44 ]
  br label %cond.end.48

cond.end.48:                                      ; preds = %cond.end.46, %cond.true.13
  %cond49 = phi i32 [ 1, %cond.true.13 ], [ %cond47, %cond.end.46 ]
  %conv50 = sext i32 %cond49 to i64
  %add = add i64 %conv50, 1
  %cmp51 = icmp ult i64 %24, %add
  br i1 %cmp51, label %cond.true.53, label %cond.false.96

cond.true.53:                                     ; preds = %cond.end.48
  %32 = load %struct.sv*, %struct.sv** %targ, align 8
  %33 = load i64, i64* %value, align 8
  %cmp54 = icmp ult i64 %33, 128
  br i1 %cmp54, label %cond.true.56, label %cond.false.57

cond.true.56:                                     ; preds = %cond.true.53
  br label %cond.end.91

cond.false.57:                                    ; preds = %cond.true.53
  %34 = load i64, i64* %value, align 8
  %cmp58 = icmp ult i64 %34, 2048
  br i1 %cmp58, label %cond.true.60, label %cond.false.61

cond.true.60:                                     ; preds = %cond.false.57
  br label %cond.end.89

cond.false.61:                                    ; preds = %cond.false.57
  %35 = load i64, i64* %value, align 8
  %cmp62 = icmp ult i64 %35, 65536
  br i1 %cmp62, label %cond.true.64, label %cond.false.65

cond.true.64:                                     ; preds = %cond.false.61
  br label %cond.end.87

cond.false.65:                                    ; preds = %cond.false.61
  %36 = load i64, i64* %value, align 8
  %cmp66 = icmp ult i64 %36, 2097152
  br i1 %cmp66, label %cond.true.68, label %cond.false.69

cond.true.68:                                     ; preds = %cond.false.65
  br label %cond.end.85

cond.false.69:                                    ; preds = %cond.false.65
  %37 = load i64, i64* %value, align 8
  %cmp70 = icmp ult i64 %37, 67108864
  br i1 %cmp70, label %cond.true.72, label %cond.false.73

cond.true.72:                                     ; preds = %cond.false.69
  br label %cond.end.83

cond.false.73:                                    ; preds = %cond.false.69
  %38 = load i64, i64* %value, align 8
  %cmp74 = icmp ult i64 %38, 2147483648
  br i1 %cmp74, label %cond.true.76, label %cond.false.77

cond.true.76:                                     ; preds = %cond.false.73
  br label %cond.end.81

cond.false.77:                                    ; preds = %cond.false.73
  %39 = load i64, i64* %value, align 8
  %cmp78 = icmp ult i64 %39, 68719476736
  %cond80 = select i1 %cmp78, i32 7, i32 13
  br label %cond.end.81

cond.end.81:                                      ; preds = %cond.false.77, %cond.true.76
  %cond82 = phi i32 [ 6, %cond.true.76 ], [ %cond80, %cond.false.77 ]
  br label %cond.end.83

cond.end.83:                                      ; preds = %cond.end.81, %cond.true.72
  %cond84 = phi i32 [ 5, %cond.true.72 ], [ %cond82, %cond.end.81 ]
  br label %cond.end.85

cond.end.85:                                      ; preds = %cond.end.83, %cond.true.68
  %cond86 = phi i32 [ 4, %cond.true.68 ], [ %cond84, %cond.end.83 ]
  br label %cond.end.87

cond.end.87:                                      ; preds = %cond.end.85, %cond.true.64
  %cond88 = phi i32 [ 3, %cond.true.64 ], [ %cond86, %cond.end.85 ]
  br label %cond.end.89

cond.end.89:                                      ; preds = %cond.end.87, %cond.true.60
  %cond90 = phi i32 [ 2, %cond.true.60 ], [ %cond88, %cond.end.87 ]
  br label %cond.end.91

cond.end.91:                                      ; preds = %cond.end.89, %cond.true.56
  %cond92 = phi i32 [ 1, %cond.true.56 ], [ %cond90, %cond.end.89 ]
  %conv93 = sext i32 %cond92 to i64
  %add94 = add i64 %conv93, 1
  %call95 = call i8* @Perl_sv_grow(%struct.sv* %32, i64 %add94)
  br label %cond.end.98

cond.false.96:                                    ; preds = %cond.end.48
  %40 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any97 = getelementptr inbounds %struct.sv, %struct.sv* %40, i32 0, i32 0
  %41 = load i8*, i8** %sv_any97, align 8
  %42 = bitcast i8* %41 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %42, i32 0, i32 0
  %43 = load i8*, i8** %xpv_pv, align 8
  br label %cond.end.98

cond.end.98:                                      ; preds = %cond.false.96, %cond.end.91
  %cond99 = phi i8* [ %call95, %cond.end.91 ], [ %43, %cond.false.96 ]
  %44 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any100 = getelementptr inbounds %struct.sv, %struct.sv* %44, i32 0, i32 0
  %45 = load i8*, i8** %sv_any100, align 8
  %46 = bitcast i8* %45 to %struct.xpv*
  %xpv_pv101 = getelementptr inbounds %struct.xpv, %struct.xpv* %46, i32 0, i32 0
  %47 = load i8*, i8** %xpv_pv101, align 8
  %48 = load i64, i64* %value, align 8
  %call102 = call i8* @Perl_uvchr_to_utf8_flags(i8* %47, i64 %48, i64 0)
  store i8* %call102, i8** %tmps, align 8
  %49 = load i8*, i8** %tmps, align 8
  %50 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any103 = getelementptr inbounds %struct.sv, %struct.sv* %50, i32 0, i32 0
  %51 = load i8*, i8** %sv_any103, align 8
  %52 = bitcast i8* %51 to %struct.xpv*
  %xpv_pv104 = getelementptr inbounds %struct.xpv, %struct.xpv* %52, i32 0, i32 0
  %53 = load i8*, i8** %xpv_pv104, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %49 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %53 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %54 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any105 = getelementptr inbounds %struct.sv, %struct.sv* %54, i32 0, i32 0
  %55 = load i8*, i8** %sv_any105, align 8
  %56 = bitcast i8* %55 to %struct.xpv*
  %xpv_cur = getelementptr inbounds %struct.xpv, %struct.xpv* %56, i32 0, i32 1
  store i64 %sub.ptr.sub, i64* %xpv_cur, align 8
  store i64 %sub.ptr.sub, i64* %tmp
  %57 = load i64, i64* %tmp
  %58 = load i8*, i8** %tmps, align 8
  store i8 0, i8* %58, align 1
  %59 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags106 = getelementptr inbounds %struct.sv, %struct.sv* %59, i32 0, i32 2
  %60 = load i32, i32* %sv_flags106, align 4
  %and107 = and i32 %60, 1223753727
  store i32 %and107, i32* %sv_flags106, align 4
  %61 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags108 = getelementptr inbounds %struct.sv, %struct.sv* %61, i32 0, i32 2
  %62 = load i32, i32* %sv_flags108, align 4
  %or = or i32 %62, 67371008
  store i32 %or, i32* %sv_flags108, align 4
  %63 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags109 = getelementptr inbounds %struct.sv, %struct.sv* %63, i32 0, i32 2
  %64 = load i32, i32* %sv_flags109, align 4
  %or110 = or i32 %64, 536870912
  store i32 %or110, i32* %sv_flags109, align 4
  %65 = load %struct.sv**, %struct.sv*** @PL_stack_max, align 8
  %66 = load %struct.sv**, %struct.sv*** %sp, align 8
  %sub.ptr.lhs.cast111 = ptrtoint %struct.sv** %65 to i64
  %sub.ptr.rhs.cast112 = ptrtoint %struct.sv** %66 to i64
  %sub.ptr.sub113 = sub i64 %sub.ptr.lhs.cast111, %sub.ptr.rhs.cast112
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub113, 8
  %cmp114 = icmp slt i64 %sub.ptr.div, 1
  br i1 %cmp114, label %if.then.116, label %if.end

if.then.116:                                      ; preds = %cond.end.98
  %67 = load %struct.sv**, %struct.sv*** %sp, align 8
  %68 = load %struct.sv**, %struct.sv*** %sp, align 8
  %call117 = call %struct.sv** @Perl_stack_grow(%struct.sv** %67, %struct.sv** %68, i32 1)
  store %struct.sv** %call117, %struct.sv*** %sp, align 8
  br label %if.end

if.end:                                           ; preds = %if.then.116, %cond.end.98
  %69 = load %struct.sv*, %struct.sv** %targ, align 8
  %70 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr119 = getelementptr inbounds %struct.sv*, %struct.sv** %70, i32 1
  store %struct.sv** %incdec.ptr119, %struct.sv*** %sp, align 8
  store %struct.sv* %69, %struct.sv** %incdec.ptr119, align 8
  store %struct.sv* %69, %struct.sv** %tmp118
  %71 = load %struct.sv*, %struct.sv** %tmp118
  %72 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %72, %struct.sv*** @PL_stack_sp, align 8
  %73 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %73, i32 0, i32 0
  %74 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %74, %struct.op** %retval
  br label %return

if.end.120:                                       ; preds = %land.lhs.true, %lor.end
  %75 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any121 = getelementptr inbounds %struct.sv, %struct.sv* %75, i32 0, i32 0
  %76 = load i8*, i8** %sv_any121, align 8
  %77 = bitcast i8* %76 to %struct.xpv*
  %xpv_len122 = getelementptr inbounds %struct.xpv, %struct.xpv* %77, i32 0, i32 2
  %78 = load i64, i64* %xpv_len122, align 8
  %cmp123 = icmp ult i64 %78, 2
  br i1 %cmp123, label %cond.true.125, label %cond.false.127

cond.true.125:                                    ; preds = %if.end.120
  %79 = load %struct.sv*, %struct.sv** %targ, align 8
  %call126 = call i8* @Perl_sv_grow(%struct.sv* %79, i64 2)
  br label %cond.end.130

cond.false.127:                                   ; preds = %if.end.120
  %80 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any128 = getelementptr inbounds %struct.sv, %struct.sv* %80, i32 0, i32 0
  %81 = load i8*, i8** %sv_any128, align 8
  %82 = bitcast i8* %81 to %struct.xpv*
  %xpv_pv129 = getelementptr inbounds %struct.xpv, %struct.xpv* %82, i32 0, i32 0
  %83 = load i8*, i8** %xpv_pv129, align 8
  br label %cond.end.130

cond.end.130:                                     ; preds = %cond.false.127, %cond.true.125
  %cond131 = phi i8* [ %call126, %cond.true.125 ], [ %83, %cond.false.127 ]
  %84 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any133 = getelementptr inbounds %struct.sv, %struct.sv* %84, i32 0, i32 0
  %85 = load i8*, i8** %sv_any133, align 8
  %86 = bitcast i8* %85 to %struct.xpv*
  %xpv_cur134 = getelementptr inbounds %struct.xpv, %struct.xpv* %86, i32 0, i32 1
  store i64 1, i64* %xpv_cur134, align 8
  store i64 1, i64* %tmp132
  %87 = load i64, i64* %tmp132
  %88 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any135 = getelementptr inbounds %struct.sv, %struct.sv* %88, i32 0, i32 0
  %89 = load i8*, i8** %sv_any135, align 8
  %90 = bitcast i8* %89 to %struct.xpv*
  %xpv_pv136 = getelementptr inbounds %struct.xpv, %struct.xpv* %90, i32 0, i32 0
  %91 = load i8*, i8** %xpv_pv136, align 8
  store i8* %91, i8** %tmps, align 8
  %92 = load i64, i64* %value, align 8
  %conv137 = trunc i64 %92 to i8
  %93 = load i8*, i8** %tmps, align 8
  %incdec.ptr138 = getelementptr inbounds i8, i8* %93, i32 1
  store i8* %incdec.ptr138, i8** %tmps, align 8
  store i8 %conv137, i8* %93, align 1
  %94 = load i8*, i8** %tmps, align 8
  store i8 0, i8* %94, align 1
  %95 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags139 = getelementptr inbounds %struct.sv, %struct.sv* %95, i32 0, i32 2
  %96 = load i32, i32* %sv_flags139, align 4
  %and140 = and i32 %96, 1223753727
  store i32 %and140, i32* %sv_flags139, align 4
  %97 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags141 = getelementptr inbounds %struct.sv, %struct.sv* %97, i32 0, i32 2
  %98 = load i32, i32* %sv_flags141, align 4
  %or142 = or i32 %98, 67371008
  store i32 %or142, i32* %sv_flags141, align 4
  %99 = load %struct.sv*, %struct.sv** @PL_encoding, align 8
  %tobool143 = icmp ne %struct.sv* %99, null
  br i1 %tobool143, label %land.lhs.true.144, label %if.end.195

land.lhs.true.144:                                ; preds = %cond.end.130
  %100 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %op_private145 = getelementptr inbounds %struct.cop, %struct.cop* %100, i32 0, i32 7
  %101 = load i8, i8* %op_private145, align 1
  %conv146 = zext i8 %101 to i32
  %and147 = and i32 %conv146, 8
  %tobool148 = icmp ne i32 %and147, 0
  br i1 %tobool148, label %if.end.195, label %if.then.149

if.then.149:                                      ; preds = %land.lhs.true.144
  %102 = load %struct.sv*, %struct.sv** %targ, align 8
  %103 = load %struct.sv*, %struct.sv** @PL_encoding, align 8
  %call150 = call i8* @Perl_sv_recode_to_utf8(%struct.sv* %102, %struct.sv* %103)
  %104 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any151 = getelementptr inbounds %struct.sv, %struct.sv* %104, i32 0, i32 0
  %105 = load i8*, i8** %sv_any151, align 8
  %106 = bitcast i8* %105 to %struct.xpv*
  %xpv_pv152 = getelementptr inbounds %struct.xpv, %struct.xpv* %106, i32 0, i32 0
  %107 = load i8*, i8** %xpv_pv152, align 8
  store i8* %107, i8** %tmps, align 8
  %108 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any153 = getelementptr inbounds %struct.sv, %struct.sv* %108, i32 0, i32 0
  %109 = load i8*, i8** %sv_any153, align 8
  %110 = bitcast i8* %109 to %struct.xpv*
  %xpv_cur154 = getelementptr inbounds %struct.xpv, %struct.xpv* %110, i32 0, i32 1
  %111 = load i64, i64* %xpv_cur154, align 8
  %cmp155 = icmp eq i64 %111, 0
  br i1 %cmp155, label %if.then.164, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then.149
  %112 = load i8*, i8** %tmps, align 8
  %113 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any157 = getelementptr inbounds %struct.sv, %struct.sv* %113, i32 0, i32 0
  %114 = load i8*, i8** %sv_any157, align 8
  %115 = bitcast i8* %114 to %struct.xpv*
  %xpv_cur158 = getelementptr inbounds %struct.xpv, %struct.xpv* %115, i32 0, i32 1
  %116 = load i64, i64* %xpv_cur158, align 8
  %call159 = call signext i8 @Perl_is_utf8_string(i8* %112, i64 %116)
  %tobool160 = icmp ne i8 %call159, 0
  br i1 %tobool160, label %lor.lhs.false.161, label %if.then.164

lor.lhs.false.161:                                ; preds = %lor.lhs.false
  %117 = load i8*, i8** %tmps, align 8
  %call162 = call i32 @memcmp(i8* %117, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.36, i32 0, i32 0), i64 4)
  %tobool163 = icmp ne i32 %call162, 0
  br i1 %tobool163, label %if.end.194, label %if.then.164

if.then.164:                                      ; preds = %lor.lhs.false.161, %lor.lhs.false, %if.then.149
  %118 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any165 = getelementptr inbounds %struct.sv, %struct.sv* %118, i32 0, i32 0
  %119 = load i8*, i8** %sv_any165, align 8
  %120 = bitcast i8* %119 to %struct.xpv*
  %xpv_len166 = getelementptr inbounds %struct.xpv, %struct.xpv* %120, i32 0, i32 2
  %121 = load i64, i64* %xpv_len166, align 8
  %cmp167 = icmp ult i64 %121, 3
  br i1 %cmp167, label %cond.true.169, label %cond.false.171

cond.true.169:                                    ; preds = %if.then.164
  %122 = load %struct.sv*, %struct.sv** %targ, align 8
  %call170 = call i8* @Perl_sv_grow(%struct.sv* %122, i64 3)
  br label %cond.end.174

cond.false.171:                                   ; preds = %if.then.164
  %123 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any172 = getelementptr inbounds %struct.sv, %struct.sv* %123, i32 0, i32 0
  %124 = load i8*, i8** %sv_any172, align 8
  %125 = bitcast i8* %124 to %struct.xpv*
  %xpv_pv173 = getelementptr inbounds %struct.xpv, %struct.xpv* %125, i32 0, i32 0
  %126 = load i8*, i8** %xpv_pv173, align 8
  br label %cond.end.174

cond.end.174:                                     ; preds = %cond.false.171, %cond.true.169
  %cond175 = phi i8* [ %call170, %cond.true.169 ], [ %126, %cond.false.171 ]
  %127 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any176 = getelementptr inbounds %struct.sv, %struct.sv* %127, i32 0, i32 0
  %128 = load i8*, i8** %sv_any176, align 8
  %129 = bitcast i8* %128 to %struct.xpv*
  %xpv_pv177 = getelementptr inbounds %struct.xpv, %struct.xpv* %129, i32 0, i32 0
  %130 = load i8*, i8** %xpv_pv177, align 8
  store i8* %130, i8** %tmps, align 8
  %131 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any179 = getelementptr inbounds %struct.sv, %struct.sv* %131, i32 0, i32 0
  %132 = load i8*, i8** %sv_any179, align 8
  %133 = bitcast i8* %132 to %struct.xpv*
  %xpv_cur180 = getelementptr inbounds %struct.xpv, %struct.xpv* %133, i32 0, i32 1
  store i64 2, i64* %xpv_cur180, align 8
  store i64 2, i64* %tmp178
  %134 = load i64, i64* %tmp178
  %135 = load i64, i64* %value, align 8
  %conv181 = trunc i64 %135 to i8
  %conv182 = zext i8 %conv181 to i32
  %shr = ashr i32 %conv182, 6
  %or183 = or i32 %shr, 8128
  %conv184 = trunc i32 %or183 to i8
  %136 = load i8*, i8** %tmps, align 8
  %incdec.ptr185 = getelementptr inbounds i8, i8* %136, i32 1
  store i8* %incdec.ptr185, i8** %tmps, align 8
  store i8 %conv184, i8* %136, align 1
  %137 = load i64, i64* %value, align 8
  %conv186 = trunc i64 %137 to i8
  %conv187 = zext i8 %conv186 to i32
  %and188 = and i32 %conv187, 63
  %or189 = or i32 %and188, 128
  %conv190 = trunc i32 %or189 to i8
  %138 = load i8*, i8** %tmps, align 8
  %incdec.ptr191 = getelementptr inbounds i8, i8* %138, i32 1
  store i8* %incdec.ptr191, i8** %tmps, align 8
  store i8 %conv190, i8* %138, align 1
  %139 = load i8*, i8** %tmps, align 8
  store i8 0, i8* %139, align 1
  %140 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags192 = getelementptr inbounds %struct.sv, %struct.sv* %140, i32 0, i32 2
  %141 = load i32, i32* %sv_flags192, align 4
  %or193 = or i32 %141, 536870912
  store i32 %or193, i32* %sv_flags192, align 4
  br label %if.end.194

if.end.194:                                       ; preds = %cond.end.174, %lor.lhs.false.161
  br label %if.end.195

if.end.195:                                       ; preds = %if.end.194, %land.lhs.true.144, %cond.end.130
  %142 = load %struct.sv**, %struct.sv*** @PL_stack_max, align 8
  %143 = load %struct.sv**, %struct.sv*** %sp, align 8
  %sub.ptr.lhs.cast196 = ptrtoint %struct.sv** %142 to i64
  %sub.ptr.rhs.cast197 = ptrtoint %struct.sv** %143 to i64
  %sub.ptr.sub198 = sub i64 %sub.ptr.lhs.cast196, %sub.ptr.rhs.cast197
  %sub.ptr.div199 = sdiv exact i64 %sub.ptr.sub198, 8
  %cmp200 = icmp slt i64 %sub.ptr.div199, 1
  br i1 %cmp200, label %if.then.202, label %if.end.204

if.then.202:                                      ; preds = %if.end.195
  %144 = load %struct.sv**, %struct.sv*** %sp, align 8
  %145 = load %struct.sv**, %struct.sv*** %sp, align 8
  %call203 = call %struct.sv** @Perl_stack_grow(%struct.sv** %144, %struct.sv** %145, i32 1)
  store %struct.sv** %call203, %struct.sv*** %sp, align 8
  br label %if.end.204

if.end.204:                                       ; preds = %if.then.202, %if.end.195
  %146 = load %struct.sv*, %struct.sv** %targ, align 8
  %147 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr206 = getelementptr inbounds %struct.sv*, %struct.sv** %147, i32 1
  store %struct.sv** %incdec.ptr206, %struct.sv*** %sp, align 8
  store %struct.sv* %146, %struct.sv** %incdec.ptr206, align 8
  store %struct.sv* %146, %struct.sv** %tmp205
  %148 = load %struct.sv*, %struct.sv** %tmp205
  %149 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %149, %struct.sv*** @PL_stack_sp, align 8
  %150 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next207 = getelementptr inbounds %struct.op, %struct.op* %150, i32 0, i32 0
  %151 = load %struct.op*, %struct.op** %op_next207, align 8
  store %struct.op* %151, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.204, %if.end
  %152 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %152
}

declare signext i8 @Perl_is_utf8_string(i8*, i64) #1

declare i32 @memcmp(i8*, i8*, i64) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_crypt() #0 {
entry:
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 3
  %2 = load i64, i64* %op_targ, align 8
  %3 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 %2
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %4, %struct.sv** %targ, align 8
  %call = call %struct.op* (i8*, ...) @Perl_die(i8* getelementptr inbounds ([65 x i8], [65 x i8]* @.str.37, i32 0, i32 0))
  ret %struct.op* %call
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_ucfirst() #0 {
entry:
  %sp = alloca %struct.sv**, align 8
  %sv = alloca %struct.sv*, align 8
  %s = alloca i8*, align 8
  %slen = alloca i64, align 8
  %tmpbuf = alloca [7 x i8], align 1
  %ulen = alloca i64, align 8
  %tculen = alloca i64, align 8
  %targ = alloca %struct.sv*, align 8
  %targ65 = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.sv**, %struct.sv*** %sp, align 8
  %2 = load %struct.sv*, %struct.sv** %1, align 8
  store %struct.sv* %2, %struct.sv** %sv, align 8
  %3 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %3, i32 0, i32 2
  %4 = load i32, i32* %sv_flags, align 4
  %and = and i32 %4, 8192
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load %struct.sv*, %struct.sv** %sv, align 8
  %call = call i32 @Perl_mg_get(%struct.sv* %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags1 = getelementptr inbounds %struct.sv, %struct.sv* %6, i32 0, i32 2
  %7 = load i32, i32* %sv_flags1, align 4
  %and2 = and i32 %7, 536870912
  %tobool3 = icmp ne i32 %and2, 0
  br i1 %tobool3, label %land.lhs.true, label %if.else.56

land.lhs.true:                                    ; preds = %if.end
  %8 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %op_private = getelementptr inbounds %struct.cop, %struct.cop* %8, i32 0, i32 7
  %9 = load i8, i8* %op_private, align 1
  %conv = zext i8 %9 to i32
  %and4 = and i32 %conv, 8
  %tobool5 = icmp ne i32 %and4, 0
  br i1 %tobool5, label %if.else.56, label %land.lhs.true.6

land.lhs.true.6:                                  ; preds = %land.lhs.true
  %10 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags7 = getelementptr inbounds %struct.sv, %struct.sv* %10, i32 0, i32 2
  %11 = load i32, i32* %sv_flags7, align 4
  %and8 = and i32 %11, 262144
  %cmp = icmp eq i32 %and8, 262144
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true.6
  %12 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %12, i32 0, i32 0
  %13 = load i8*, i8** %sv_any, align 8
  %14 = bitcast i8* %13 to %struct.xpv*
  %xpv_cur = getelementptr inbounds %struct.xpv, %struct.xpv* %14, i32 0, i32 1
  %15 = load i64, i64* %xpv_cur, align 8
  store i64 %15, i64* %slen, align 8
  %16 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any10 = getelementptr inbounds %struct.sv, %struct.sv* %16, i32 0, i32 0
  %17 = load i8*, i8** %sv_any10, align 8
  %18 = bitcast i8* %17 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %18, i32 0, i32 0
  %19 = load i8*, i8** %xpv_pv, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true.6
  %20 = load %struct.sv*, %struct.sv** %sv, align 8
  %call11 = call i8* @Perl_sv_2pv_flags(%struct.sv* %20, i64* %slen, i32 0)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %19, %cond.true ], [ %call11, %cond.false ]
  store i8* %cond, i8** %s, align 8
  %tobool12 = icmp ne i8* %cond, null
  br i1 %tobool12, label %land.lhs.true.13, label %if.else.56

land.lhs.true.13:                                 ; preds = %cond.end
  %21 = load i64, i64* %slen, align 8
  %tobool14 = icmp ne i64 %21, 0
  br i1 %tobool14, label %land.lhs.true.15, label %if.else.56

land.lhs.true.15:                                 ; preds = %land.lhs.true.13
  %22 = load i8*, i8** %s, align 8
  %23 = load i8, i8* %22, align 1
  %conv16 = zext i8 %23 to i32
  %cmp17 = icmp sge i32 %conv16, 192
  br i1 %cmp17, label %land.lhs.true.19, label %if.else.56

land.lhs.true.19:                                 ; preds = %land.lhs.true.15
  %24 = load i8*, i8** %s, align 8
  %25 = load i8, i8* %24, align 1
  %conv20 = zext i8 %25 to i32
  %cmp21 = icmp sle i32 %conv20, 253
  br i1 %cmp21, label %if.then.23, label %if.else.56

if.then.23:                                       ; preds = %land.lhs.true.19
  %26 = load i8*, i8** %s, align 8
  %call24 = call i64 @Perl_utf8_to_uvchr(i8* %26, i64* %ulen)
  %27 = load i8*, i8** %s, align 8
  %arraydecay = getelementptr inbounds [7 x i8], [7 x i8]* %tmpbuf, i32 0, i32 0
  %call25 = call i64 @Perl_to_utf8_title(i8* %27, i8* %arraydecay, i64* %tculen)
  %arraydecay26 = getelementptr inbounds [7 x i8], [7 x i8]* %tmpbuf, i32 0, i32 0
  %call27 = call i64 @Perl_utf8_to_uvchr(i8* %arraydecay26, i64* null)
  %28 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags28 = getelementptr inbounds %struct.sv, %struct.sv* %28, i32 0, i32 2
  %29 = load i32, i32* %sv_flags28, align 4
  %and29 = and i32 %29, 512
  %tobool30 = icmp ne i32 %and29, 0
  br i1 %tobool30, label %lor.lhs.false, label %if.then.34

lor.lhs.false:                                    ; preds = %if.then.23
  %30 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags31 = getelementptr inbounds %struct.sv, %struct.sv* %30, i32 0, i32 2
  %31 = load i32, i32* %sv_flags31, align 4
  %and32 = and i32 %31, 8388608
  %tobool33 = icmp ne i32 %and32, 0
  br i1 %tobool33, label %if.then.34, label %if.else

if.then.34:                                       ; preds = %lor.lhs.false, %if.then.23
  %32 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %32, i32 0, i32 3
  %33 = load i64, i64* %op_targ, align 8
  %34 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %34, i64 %33
  %35 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %35, %struct.sv** %targ, align 8
  %36 = load %struct.sv*, %struct.sv** %targ, align 8
  %arraydecay35 = getelementptr inbounds [7 x i8], [7 x i8]* %tmpbuf, i32 0, i32 0
  %37 = load i64, i64* %tculen, align 8
  call void @Perl_sv_setpvn(%struct.sv* %36, i8* %arraydecay35, i64 %37)
  %38 = load i64, i64* %slen, align 8
  %39 = load i64, i64* %ulen, align 8
  %cmp36 = icmp ugt i64 %38, %39
  br i1 %cmp36, label %if.then.38, label %if.end.39

if.then.38:                                       ; preds = %if.then.34
  %40 = load %struct.sv*, %struct.sv** %targ, align 8
  %41 = load i8*, i8** %s, align 8
  %42 = load i64, i64* %ulen, align 8
  %add.ptr = getelementptr inbounds i8, i8* %41, i64 %42
  %43 = load i64, i64* %slen, align 8
  %44 = load i64, i64* %ulen, align 8
  %sub = sub i64 %43, %44
  call void @Perl_sv_catpvn_flags(%struct.sv* %40, i8* %add.ptr, i64 %sub, i32 2)
  br label %if.end.39

if.end.39:                                        ; preds = %if.then.38, %if.then.34
  %45 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags40 = getelementptr inbounds %struct.sv, %struct.sv* %45, i32 0, i32 2
  %46 = load i32, i32* %sv_flags40, align 4
  %or = or i32 %46, 536870912
  store i32 %or, i32* %sv_flags40, align 4
  %47 = load %struct.sv*, %struct.sv** %targ, align 8
  %48 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %47, %struct.sv** %48, align 8
  br label %if.end.55

if.else:                                          ; preds = %lor.lhs.false
  %49 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags41 = getelementptr inbounds %struct.sv, %struct.sv* %49, i32 0, i32 2
  %50 = load i32, i32* %sv_flags41, align 4
  %and42 = and i32 %50, 10223616
  %cmp43 = icmp eq i32 %and42, 262144
  br i1 %cmp43, label %cond.true.45, label %cond.false.50

cond.true.45:                                     ; preds = %if.else
  %51 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any46 = getelementptr inbounds %struct.sv, %struct.sv* %51, i32 0, i32 0
  %52 = load i8*, i8** %sv_any46, align 8
  %53 = bitcast i8* %52 to %struct.xpv*
  %xpv_cur47 = getelementptr inbounds %struct.xpv, %struct.xpv* %53, i32 0, i32 1
  %54 = load i64, i64* %xpv_cur47, align 8
  store i64 %54, i64* %slen, align 8
  %55 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any48 = getelementptr inbounds %struct.sv, %struct.sv* %55, i32 0, i32 0
  %56 = load i8*, i8** %sv_any48, align 8
  %57 = bitcast i8* %56 to %struct.xpv*
  %xpv_pv49 = getelementptr inbounds %struct.xpv, %struct.xpv* %57, i32 0, i32 0
  %58 = load i8*, i8** %xpv_pv49, align 8
  br label %cond.end.52

cond.false.50:                                    ; preds = %if.else
  %59 = load %struct.sv*, %struct.sv** %sv, align 8
  %call51 = call i8* @Perl_sv_pvn_force_flags(%struct.sv* %59, i64* %slen, i32 0)
  br label %cond.end.52

cond.end.52:                                      ; preds = %cond.false.50, %cond.true.45
  %cond53 = phi i8* [ %58, %cond.true.45 ], [ %call51, %cond.false.50 ]
  store i8* %cond53, i8** %s, align 8
  %60 = load i8*, i8** %s, align 8
  %arraydecay54 = getelementptr inbounds [7 x i8], [7 x i8]* %tmpbuf, i32 0, i32 0
  %61 = load i64, i64* %tculen, align 8
  %mul = mul i64 %61, 1
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %60, i8* %arraydecay54, i64 %mul, i32 1, i1 false)
  br label %if.end.55

if.end.55:                                        ; preds = %cond.end.52, %if.end.39
  br label %if.end.102

if.else.56:                                       ; preds = %land.lhs.true.19, %land.lhs.true.15, %land.lhs.true.13, %cond.end, %land.lhs.true, %if.end
  %62 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags57 = getelementptr inbounds %struct.sv, %struct.sv* %62, i32 0, i32 2
  %63 = load i32, i32* %sv_flags57, align 4
  %and58 = and i32 %63, 512
  %tobool59 = icmp ne i32 %and58, 0
  br i1 %tobool59, label %lor.lhs.false.60, label %if.then.64

lor.lhs.false.60:                                 ; preds = %if.else.56
  %64 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags61 = getelementptr inbounds %struct.sv, %struct.sv* %64, i32 0, i32 2
  %65 = load i32, i32* %sv_flags61, align 4
  %and62 = and i32 %65, 8388608
  %tobool63 = icmp ne i32 %and62, 0
  br i1 %tobool63, label %if.then.64, label %if.end.70

if.then.64:                                       ; preds = %lor.lhs.false.60, %if.else.56
  %66 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ66 = getelementptr inbounds %struct.op, %struct.op* %66, i32 0, i32 3
  %67 = load i64, i64* %op_targ66, align 8
  %68 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx67 = getelementptr inbounds %struct.sv*, %struct.sv** %68, i64 %67
  %69 = load %struct.sv*, %struct.sv** %arrayidx67, align 8
  store %struct.sv* %69, %struct.sv** %targ65, align 8
  %70 = load %struct.sv*, %struct.sv** %targ65, align 8
  %sv_flags68 = getelementptr inbounds %struct.sv, %struct.sv* %70, i32 0, i32 2
  %71 = load i32, i32* %sv_flags68, align 4
  %and69 = and i32 %71, -536870913
  store i32 %and69, i32* %sv_flags68, align 4
  %72 = load %struct.sv*, %struct.sv** %targ65, align 8
  %73 = load %struct.sv*, %struct.sv** %sv, align 8
  call void @Perl_sv_setsv_flags(%struct.sv* %72, %struct.sv* %73, i32 0)
  %74 = load %struct.sv*, %struct.sv** %targ65, align 8
  store %struct.sv* %74, %struct.sv** %sv, align 8
  %75 = load %struct.sv*, %struct.sv** %sv, align 8
  %76 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %75, %struct.sv** %76, align 8
  br label %if.end.70

if.end.70:                                        ; preds = %if.then.64, %lor.lhs.false.60
  %77 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags71 = getelementptr inbounds %struct.sv, %struct.sv* %77, i32 0, i32 2
  %78 = load i32, i32* %sv_flags71, align 4
  %and72 = and i32 %78, 10223616
  %cmp73 = icmp eq i32 %and72, 262144
  br i1 %cmp73, label %cond.true.75, label %cond.false.80

cond.true.75:                                     ; preds = %if.end.70
  %79 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any76 = getelementptr inbounds %struct.sv, %struct.sv* %79, i32 0, i32 0
  %80 = load i8*, i8** %sv_any76, align 8
  %81 = bitcast i8* %80 to %struct.xpv*
  %xpv_cur77 = getelementptr inbounds %struct.xpv, %struct.xpv* %81, i32 0, i32 1
  %82 = load i64, i64* %xpv_cur77, align 8
  store i64 %82, i64* %slen, align 8
  %83 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any78 = getelementptr inbounds %struct.sv, %struct.sv* %83, i32 0, i32 0
  %84 = load i8*, i8** %sv_any78, align 8
  %85 = bitcast i8* %84 to %struct.xpv*
  %xpv_pv79 = getelementptr inbounds %struct.xpv, %struct.xpv* %85, i32 0, i32 0
  %86 = load i8*, i8** %xpv_pv79, align 8
  br label %cond.end.82

cond.false.80:                                    ; preds = %if.end.70
  %87 = load %struct.sv*, %struct.sv** %sv, align 8
  %call81 = call i8* @Perl_sv_pvn_force_flags(%struct.sv* %87, i64* %slen, i32 0)
  br label %cond.end.82

cond.end.82:                                      ; preds = %cond.false.80, %cond.true.75
  %cond83 = phi i8* [ %86, %cond.true.75 ], [ %call81, %cond.false.80 ]
  store i8* %cond83, i8** %s, align 8
  %88 = load i8*, i8** %s, align 8
  %89 = load i8, i8* %88, align 1
  %tobool84 = icmp ne i8 %89, 0
  br i1 %tobool84, label %if.then.85, label %if.end.101

if.then.85:                                       ; preds = %cond.end.82
  %90 = load i8*, i8** %s, align 8
  %91 = load i8, i8* %90, align 1
  %conv86 = zext i8 %91 to i32
  %cmp87 = icmp sge i32 %conv86, 97
  br i1 %cmp87, label %land.lhs.true.89, label %cond.false.96

land.lhs.true.89:                                 ; preds = %if.then.85
  %92 = load i8*, i8** %s, align 8
  %93 = load i8, i8* %92, align 1
  %conv90 = zext i8 %93 to i32
  %cmp91 = icmp sle i32 %conv90, 122
  br i1 %cmp91, label %cond.true.93, label %cond.false.96

cond.true.93:                                     ; preds = %land.lhs.true.89
  %94 = load i8*, i8** %s, align 8
  %95 = load i8, i8* %94, align 1
  %conv94 = zext i8 %95 to i32
  %sub95 = sub nsw i32 %conv94, 32
  br label %cond.end.98

cond.false.96:                                    ; preds = %land.lhs.true.89, %if.then.85
  %96 = load i8*, i8** %s, align 8
  %97 = load i8, i8* %96, align 1
  %conv97 = zext i8 %97 to i32
  br label %cond.end.98

cond.end.98:                                      ; preds = %cond.false.96, %cond.true.93
  %cond99 = phi i32 [ %sub95, %cond.true.93 ], [ %conv97, %cond.false.96 ]
  %conv100 = trunc i32 %cond99 to i8
  %98 = load i8*, i8** %s, align 8
  store i8 %conv100, i8* %98, align 1
  br label %if.end.101

if.end.101:                                       ; preds = %cond.end.98, %cond.end.82
  br label %if.end.102

if.end.102:                                       ; preds = %if.end.101, %if.end.55
  %99 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags103 = getelementptr inbounds %struct.sv, %struct.sv* %99, i32 0, i32 2
  %100 = load i32, i32* %sv_flags103, align 4
  %and104 = and i32 %100, 16384
  %tobool105 = icmp ne i32 %and104, 0
  br i1 %tobool105, label %if.then.106, label %if.end.108

if.then.106:                                      ; preds = %if.end.102
  %101 = load %struct.sv*, %struct.sv** %sv, align 8
  %call107 = call i32 @Perl_mg_set(%struct.sv* %101)
  br label %if.end.108

if.end.108:                                       ; preds = %if.then.106, %if.end.102
  %102 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %102, %struct.sv*** @PL_stack_sp, align 8
  %103 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %103, i32 0, i32 0
  %104 = load %struct.op*, %struct.op** %op_next, align 8
  ret %struct.op* %104
}

declare i64 @Perl_utf8_to_uvchr(i8*, i64*) #1

declare i64 @Perl_to_utf8_title(i8*, i8*, i64*) #1

declare void @Perl_sv_catpvn_flags(%struct.sv*, i8*, i64, i32) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_lcfirst() #0 {
entry:
  %sp = alloca %struct.sv**, align 8
  %sv = alloca %struct.sv*, align 8
  %s = alloca i8*, align 8
  %slen = alloca i64, align 8
  %ulen = alloca i64, align 8
  %tmpbuf = alloca [7 x i8], align 1
  %tend = alloca i8*, align 8
  %uv = alloca i64, align 8
  %targ = alloca %struct.sv*, align 8
  %targ74 = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.sv**, %struct.sv*** %sp, align 8
  %2 = load %struct.sv*, %struct.sv** %1, align 8
  store %struct.sv* %2, %struct.sv** %sv, align 8
  %3 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %3, i32 0, i32 2
  %4 = load i32, i32* %sv_flags, align 4
  %and = and i32 %4, 8192
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load %struct.sv*, %struct.sv** %sv, align 8
  %call = call i32 @Perl_mg_get(%struct.sv* %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags1 = getelementptr inbounds %struct.sv, %struct.sv* %6, i32 0, i32 2
  %7 = load i32, i32* %sv_flags1, align 4
  %and2 = and i32 %7, 536870912
  %tobool3 = icmp ne i32 %and2, 0
  br i1 %tobool3, label %land.lhs.true, label %if.else.65

land.lhs.true:                                    ; preds = %if.end
  %8 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %op_private = getelementptr inbounds %struct.cop, %struct.cop* %8, i32 0, i32 7
  %9 = load i8, i8* %op_private, align 1
  %conv = zext i8 %9 to i32
  %and4 = and i32 %conv, 8
  %tobool5 = icmp ne i32 %and4, 0
  br i1 %tobool5, label %if.else.65, label %land.lhs.true.6

land.lhs.true.6:                                  ; preds = %land.lhs.true
  %10 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags7 = getelementptr inbounds %struct.sv, %struct.sv* %10, i32 0, i32 2
  %11 = load i32, i32* %sv_flags7, align 4
  %and8 = and i32 %11, 262144
  %cmp = icmp eq i32 %and8, 262144
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true.6
  %12 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %12, i32 0, i32 0
  %13 = load i8*, i8** %sv_any, align 8
  %14 = bitcast i8* %13 to %struct.xpv*
  %xpv_cur = getelementptr inbounds %struct.xpv, %struct.xpv* %14, i32 0, i32 1
  %15 = load i64, i64* %xpv_cur, align 8
  store i64 %15, i64* %slen, align 8
  %16 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any10 = getelementptr inbounds %struct.sv, %struct.sv* %16, i32 0, i32 0
  %17 = load i8*, i8** %sv_any10, align 8
  %18 = bitcast i8* %17 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %18, i32 0, i32 0
  %19 = load i8*, i8** %xpv_pv, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true.6
  %20 = load %struct.sv*, %struct.sv** %sv, align 8
  %call11 = call i8* @Perl_sv_2pv_flags(%struct.sv* %20, i64* %slen, i32 0)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %19, %cond.true ], [ %call11, %cond.false ]
  store i8* %cond, i8** %s, align 8
  %tobool12 = icmp ne i8* %cond, null
  br i1 %tobool12, label %land.lhs.true.13, label %if.else.65

land.lhs.true.13:                                 ; preds = %cond.end
  %21 = load i64, i64* %slen, align 8
  %tobool14 = icmp ne i64 %21, 0
  br i1 %tobool14, label %land.lhs.true.15, label %if.else.65

land.lhs.true.15:                                 ; preds = %land.lhs.true.13
  %22 = load i8*, i8** %s, align 8
  %23 = load i8, i8* %22, align 1
  %conv16 = zext i8 %23 to i32
  %cmp17 = icmp sge i32 %conv16, 192
  br i1 %cmp17, label %land.lhs.true.19, label %if.else.65

land.lhs.true.19:                                 ; preds = %land.lhs.true.15
  %24 = load i8*, i8** %s, align 8
  %25 = load i8, i8* %24, align 1
  %conv20 = zext i8 %25 to i32
  %cmp21 = icmp sle i32 %conv20, 253
  br i1 %cmp21, label %if.then.23, label %if.else.65

if.then.23:                                       ; preds = %land.lhs.true.19
  %26 = load i8*, i8** %s, align 8
  %arraydecay = getelementptr inbounds [7 x i8], [7 x i8]* %tmpbuf, i32 0, i32 0
  %call24 = call i64 @Perl_to_utf8_lower(i8* %26, i8* %arraydecay, i64* %ulen)
  %arraydecay25 = getelementptr inbounds [7 x i8], [7 x i8]* %tmpbuf, i32 0, i32 0
  %call26 = call i64 @Perl_utf8_to_uvchr(i8* %arraydecay25, i64* null)
  store i64 %call26, i64* %uv, align 8
  %arraydecay27 = getelementptr inbounds [7 x i8], [7 x i8]* %tmpbuf, i32 0, i32 0
  %27 = load i64, i64* %uv, align 8
  %call28 = call i8* @Perl_uvuni_to_utf8(i8* %arraydecay27, i64 %27)
  store i8* %call28, i8** %tend, align 8
  %28 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags29 = getelementptr inbounds %struct.sv, %struct.sv* %28, i32 0, i32 2
  %29 = load i32, i32* %sv_flags29, align 4
  %and30 = and i32 %29, 512
  %tobool31 = icmp ne i32 %and30, 0
  br i1 %tobool31, label %lor.lhs.false, label %if.then.39

lor.lhs.false:                                    ; preds = %if.then.23
  %30 = load i8*, i8** %tend, align 8
  %arraydecay32 = getelementptr inbounds [7 x i8], [7 x i8]* %tmpbuf, i32 0, i32 0
  %sub.ptr.lhs.cast = ptrtoint i8* %30 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %arraydecay32 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %31 = load i64, i64* %ulen, align 8
  %cmp33 = icmp ne i64 %sub.ptr.sub, %31
  br i1 %cmp33, label %if.then.39, label %lor.lhs.false.35

lor.lhs.false.35:                                 ; preds = %lor.lhs.false
  %32 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags36 = getelementptr inbounds %struct.sv, %struct.sv* %32, i32 0, i32 2
  %33 = load i32, i32* %sv_flags36, align 4
  %and37 = and i32 %33, 8388608
  %tobool38 = icmp ne i32 %and37, 0
  br i1 %tobool38, label %if.then.39, label %if.else

if.then.39:                                       ; preds = %lor.lhs.false.35, %lor.lhs.false, %if.then.23
  %34 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %34, i32 0, i32 3
  %35 = load i64, i64* %op_targ, align 8
  %36 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %36, i64 %35
  %37 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %37, %struct.sv** %targ, align 8
  %38 = load %struct.sv*, %struct.sv** %targ, align 8
  %arraydecay40 = getelementptr inbounds [7 x i8], [7 x i8]* %tmpbuf, i32 0, i32 0
  %39 = load i8*, i8** %tend, align 8
  %arraydecay41 = getelementptr inbounds [7 x i8], [7 x i8]* %tmpbuf, i32 0, i32 0
  %sub.ptr.lhs.cast42 = ptrtoint i8* %39 to i64
  %sub.ptr.rhs.cast43 = ptrtoint i8* %arraydecay41 to i64
  %sub.ptr.sub44 = sub i64 %sub.ptr.lhs.cast42, %sub.ptr.rhs.cast43
  call void @Perl_sv_setpvn(%struct.sv* %38, i8* %arraydecay40, i64 %sub.ptr.sub44)
  %40 = load i64, i64* %slen, align 8
  %41 = load i64, i64* %ulen, align 8
  %cmp45 = icmp ugt i64 %40, %41
  br i1 %cmp45, label %if.then.47, label %if.end.48

if.then.47:                                       ; preds = %if.then.39
  %42 = load %struct.sv*, %struct.sv** %targ, align 8
  %43 = load i8*, i8** %s, align 8
  %44 = load i64, i64* %ulen, align 8
  %add.ptr = getelementptr inbounds i8, i8* %43, i64 %44
  %45 = load i64, i64* %slen, align 8
  %46 = load i64, i64* %ulen, align 8
  %sub = sub i64 %45, %46
  call void @Perl_sv_catpvn_flags(%struct.sv* %42, i8* %add.ptr, i64 %sub, i32 2)
  br label %if.end.48

if.end.48:                                        ; preds = %if.then.47, %if.then.39
  %47 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags49 = getelementptr inbounds %struct.sv, %struct.sv* %47, i32 0, i32 2
  %48 = load i32, i32* %sv_flags49, align 4
  %or = or i32 %48, 536870912
  store i32 %or, i32* %sv_flags49, align 4
  %49 = load %struct.sv*, %struct.sv** %targ, align 8
  %50 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %49, %struct.sv** %50, align 8
  br label %if.end.64

if.else:                                          ; preds = %lor.lhs.false.35
  %51 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags50 = getelementptr inbounds %struct.sv, %struct.sv* %51, i32 0, i32 2
  %52 = load i32, i32* %sv_flags50, align 4
  %and51 = and i32 %52, 10223616
  %cmp52 = icmp eq i32 %and51, 262144
  br i1 %cmp52, label %cond.true.54, label %cond.false.59

cond.true.54:                                     ; preds = %if.else
  %53 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any55 = getelementptr inbounds %struct.sv, %struct.sv* %53, i32 0, i32 0
  %54 = load i8*, i8** %sv_any55, align 8
  %55 = bitcast i8* %54 to %struct.xpv*
  %xpv_cur56 = getelementptr inbounds %struct.xpv, %struct.xpv* %55, i32 0, i32 1
  %56 = load i64, i64* %xpv_cur56, align 8
  store i64 %56, i64* %slen, align 8
  %57 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any57 = getelementptr inbounds %struct.sv, %struct.sv* %57, i32 0, i32 0
  %58 = load i8*, i8** %sv_any57, align 8
  %59 = bitcast i8* %58 to %struct.xpv*
  %xpv_pv58 = getelementptr inbounds %struct.xpv, %struct.xpv* %59, i32 0, i32 0
  %60 = load i8*, i8** %xpv_pv58, align 8
  br label %cond.end.61

cond.false.59:                                    ; preds = %if.else
  %61 = load %struct.sv*, %struct.sv** %sv, align 8
  %call60 = call i8* @Perl_sv_pvn_force_flags(%struct.sv* %61, i64* %slen, i32 0)
  br label %cond.end.61

cond.end.61:                                      ; preds = %cond.false.59, %cond.true.54
  %cond62 = phi i8* [ %60, %cond.true.54 ], [ %call60, %cond.false.59 ]
  store i8* %cond62, i8** %s, align 8
  %62 = load i8*, i8** %s, align 8
  %arraydecay63 = getelementptr inbounds [7 x i8], [7 x i8]* %tmpbuf, i32 0, i32 0
  %63 = load i64, i64* %ulen, align 8
  %mul = mul i64 %63, 1
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %62, i8* %arraydecay63, i64 %mul, i32 1, i1 false)
  br label %if.end.64

if.end.64:                                        ; preds = %cond.end.61, %if.end.48
  br label %if.end.110

if.else.65:                                       ; preds = %land.lhs.true.19, %land.lhs.true.15, %land.lhs.true.13, %cond.end, %land.lhs.true, %if.end
  %64 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags66 = getelementptr inbounds %struct.sv, %struct.sv* %64, i32 0, i32 2
  %65 = load i32, i32* %sv_flags66, align 4
  %and67 = and i32 %65, 512
  %tobool68 = icmp ne i32 %and67, 0
  br i1 %tobool68, label %lor.lhs.false.69, label %if.then.73

lor.lhs.false.69:                                 ; preds = %if.else.65
  %66 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags70 = getelementptr inbounds %struct.sv, %struct.sv* %66, i32 0, i32 2
  %67 = load i32, i32* %sv_flags70, align 4
  %and71 = and i32 %67, 8388608
  %tobool72 = icmp ne i32 %and71, 0
  br i1 %tobool72, label %if.then.73, label %if.end.79

if.then.73:                                       ; preds = %lor.lhs.false.69, %if.else.65
  %68 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ75 = getelementptr inbounds %struct.op, %struct.op* %68, i32 0, i32 3
  %69 = load i64, i64* %op_targ75, align 8
  %70 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx76 = getelementptr inbounds %struct.sv*, %struct.sv** %70, i64 %69
  %71 = load %struct.sv*, %struct.sv** %arrayidx76, align 8
  store %struct.sv* %71, %struct.sv** %targ74, align 8
  %72 = load %struct.sv*, %struct.sv** %targ74, align 8
  %sv_flags77 = getelementptr inbounds %struct.sv, %struct.sv* %72, i32 0, i32 2
  %73 = load i32, i32* %sv_flags77, align 4
  %and78 = and i32 %73, -536870913
  store i32 %and78, i32* %sv_flags77, align 4
  %74 = load %struct.sv*, %struct.sv** %targ74, align 8
  %75 = load %struct.sv*, %struct.sv** %sv, align 8
  call void @Perl_sv_setsv_flags(%struct.sv* %74, %struct.sv* %75, i32 0)
  %76 = load %struct.sv*, %struct.sv** %targ74, align 8
  store %struct.sv* %76, %struct.sv** %sv, align 8
  %77 = load %struct.sv*, %struct.sv** %sv, align 8
  %78 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %77, %struct.sv** %78, align 8
  br label %if.end.79

if.end.79:                                        ; preds = %if.then.73, %lor.lhs.false.69
  %79 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags80 = getelementptr inbounds %struct.sv, %struct.sv* %79, i32 0, i32 2
  %80 = load i32, i32* %sv_flags80, align 4
  %and81 = and i32 %80, 10223616
  %cmp82 = icmp eq i32 %and81, 262144
  br i1 %cmp82, label %cond.true.84, label %cond.false.89

cond.true.84:                                     ; preds = %if.end.79
  %81 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any85 = getelementptr inbounds %struct.sv, %struct.sv* %81, i32 0, i32 0
  %82 = load i8*, i8** %sv_any85, align 8
  %83 = bitcast i8* %82 to %struct.xpv*
  %xpv_cur86 = getelementptr inbounds %struct.xpv, %struct.xpv* %83, i32 0, i32 1
  %84 = load i64, i64* %xpv_cur86, align 8
  store i64 %84, i64* %slen, align 8
  %85 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any87 = getelementptr inbounds %struct.sv, %struct.sv* %85, i32 0, i32 0
  %86 = load i8*, i8** %sv_any87, align 8
  %87 = bitcast i8* %86 to %struct.xpv*
  %xpv_pv88 = getelementptr inbounds %struct.xpv, %struct.xpv* %87, i32 0, i32 0
  %88 = load i8*, i8** %xpv_pv88, align 8
  br label %cond.end.91

cond.false.89:                                    ; preds = %if.end.79
  %89 = load %struct.sv*, %struct.sv** %sv, align 8
  %call90 = call i8* @Perl_sv_pvn_force_flags(%struct.sv* %89, i64* %slen, i32 0)
  br label %cond.end.91

cond.end.91:                                      ; preds = %cond.false.89, %cond.true.84
  %cond92 = phi i8* [ %88, %cond.true.84 ], [ %call90, %cond.false.89 ]
  store i8* %cond92, i8** %s, align 8
  %90 = load i8*, i8** %s, align 8
  %91 = load i8, i8* %90, align 1
  %tobool93 = icmp ne i8 %91, 0
  br i1 %tobool93, label %if.then.94, label %if.end.109

if.then.94:                                       ; preds = %cond.end.91
  %92 = load i8*, i8** %s, align 8
  %93 = load i8, i8* %92, align 1
  %conv95 = zext i8 %93 to i32
  %cmp96 = icmp sge i32 %conv95, 65
  br i1 %cmp96, label %land.lhs.true.98, label %cond.false.104

land.lhs.true.98:                                 ; preds = %if.then.94
  %94 = load i8*, i8** %s, align 8
  %95 = load i8, i8* %94, align 1
  %conv99 = zext i8 %95 to i32
  %cmp100 = icmp sle i32 %conv99, 90
  br i1 %cmp100, label %cond.true.102, label %cond.false.104

cond.true.102:                                    ; preds = %land.lhs.true.98
  %96 = load i8*, i8** %s, align 8
  %97 = load i8, i8* %96, align 1
  %conv103 = zext i8 %97 to i32
  %add = add nsw i32 %conv103, 32
  br label %cond.end.106

cond.false.104:                                   ; preds = %land.lhs.true.98, %if.then.94
  %98 = load i8*, i8** %s, align 8
  %99 = load i8, i8* %98, align 1
  %conv105 = zext i8 %99 to i32
  br label %cond.end.106

cond.end.106:                                     ; preds = %cond.false.104, %cond.true.102
  %cond107 = phi i32 [ %add, %cond.true.102 ], [ %conv105, %cond.false.104 ]
  %conv108 = trunc i32 %cond107 to i8
  %100 = load i8*, i8** %s, align 8
  store i8 %conv108, i8* %100, align 1
  br label %if.end.109

if.end.109:                                       ; preds = %cond.end.106, %cond.end.91
  br label %if.end.110

if.end.110:                                       ; preds = %if.end.109, %if.end.64
  %101 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags111 = getelementptr inbounds %struct.sv, %struct.sv* %101, i32 0, i32 2
  %102 = load i32, i32* %sv_flags111, align 4
  %and112 = and i32 %102, 16384
  %tobool113 = icmp ne i32 %and112, 0
  br i1 %tobool113, label %if.then.114, label %if.end.116

if.then.114:                                      ; preds = %if.end.110
  %103 = load %struct.sv*, %struct.sv** %sv, align 8
  %call115 = call i32 @Perl_mg_set(%struct.sv* %103)
  br label %if.end.116

if.end.116:                                       ; preds = %if.then.114, %if.end.110
  %104 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %104, %struct.sv*** @PL_stack_sp, align 8
  %105 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %105, i32 0, i32 0
  %106 = load %struct.op*, %struct.op** %op_next, align 8
  ret %struct.op* %106
}

declare i64 @Perl_to_utf8_lower(i8*, i8*, i64*) #1

declare i8* @Perl_uvuni_to_utf8(i8*, i64) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_uc() #0 {
entry:
  %sp = alloca %struct.sv**, align 8
  %sv = alloca %struct.sv*, align 8
  %s = alloca i8*, align 8
  %len = alloca i64, align 8
  %targ = alloca %struct.sv*, align 8
  %ulen = alloca i64, align 8
  %d = alloca i8*, align 8
  %send = alloca i8*, align 8
  %tmpbuf = alloca [14 x i8], align 1
  %min = alloca i64, align 8
  %u = alloca i64, align 8
  %o = alloca i64, align 8
  %tmp = alloca i64, align 8
  %targ91 = alloca %struct.sv*, align 8
  %send113 = alloca i8*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.sv**, %struct.sv*** %sp, align 8
  %2 = load %struct.sv*, %struct.sv** %1, align 8
  store %struct.sv* %2, %struct.sv** %sv, align 8
  %3 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %3, i32 0, i32 2
  %4 = load i32, i32* %sv_flags, align 4
  %and = and i32 %4, 8192
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load %struct.sv*, %struct.sv** %sv, align 8
  %call = call i32 @Perl_mg_get(%struct.sv* %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags1 = getelementptr inbounds %struct.sv, %struct.sv* %6, i32 0, i32 2
  %7 = load i32, i32* %sv_flags1, align 4
  %and2 = and i32 %7, 536870912
  %tobool3 = icmp ne i32 %and2, 0
  br i1 %tobool3, label %land.lhs.true, label %if.else.82

land.lhs.true:                                    ; preds = %if.end
  %8 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %op_private = getelementptr inbounds %struct.cop, %struct.cop* %8, i32 0, i32 7
  %9 = load i8, i8* %op_private, align 1
  %conv = zext i8 %9 to i32
  %and4 = and i32 %conv, 8
  %tobool5 = icmp ne i32 %and4, 0
  br i1 %tobool5, label %if.else.82, label %if.then.6

if.then.6:                                        ; preds = %land.lhs.true
  %10 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %10, i32 0, i32 3
  %11 = load i64, i64* %op_targ, align 8
  %12 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %12, i64 %11
  %13 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %13, %struct.sv** %targ, align 8
  %14 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags7 = getelementptr inbounds %struct.sv, %struct.sv* %14, i32 0, i32 2
  %15 = load i32, i32* %sv_flags7, align 4
  %and8 = and i32 %15, 262144
  %cmp = icmp eq i32 %and8, 262144
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.6
  %16 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %16, i32 0, i32 0
  %17 = load i8*, i8** %sv_any, align 8
  %18 = bitcast i8* %17 to %struct.xpv*
  %xpv_cur = getelementptr inbounds %struct.xpv, %struct.xpv* %18, i32 0, i32 1
  %19 = load i64, i64* %xpv_cur, align 8
  store i64 %19, i64* %len, align 8
  %20 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any10 = getelementptr inbounds %struct.sv, %struct.sv* %20, i32 0, i32 0
  %21 = load i8*, i8** %sv_any10, align 8
  %22 = bitcast i8* %21 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %22, i32 0, i32 0
  %23 = load i8*, i8** %xpv_pv, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then.6
  %24 = load %struct.sv*, %struct.sv** %sv, align 8
  %call11 = call i8* @Perl_sv_2pv_flags(%struct.sv* %24, i64* %len, i32 0)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %23, %cond.true ], [ %call11, %cond.false ]
  store i8* %cond, i8** %s, align 8
  %25 = load i64, i64* %len, align 8
  %tobool12 = icmp ne i64 %25, 0
  br i1 %tobool12, label %if.else, label %if.then.13

if.then.13:                                       ; preds = %cond.end
  %26 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags14 = getelementptr inbounds %struct.sv, %struct.sv* %26, i32 0, i32 2
  %27 = load i32, i32* %sv_flags14, align 4
  %and15 = and i32 %27, -536870913
  store i32 %and15, i32* %sv_flags14, align 4
  %28 = load %struct.sv*, %struct.sv** %targ, align 8
  call void @Perl_sv_setpvn(%struct.sv* %28, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.4, i32 0, i32 0), i64 0)
  %29 = load %struct.sv*, %struct.sv** %targ, align 8
  %30 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %29, %struct.sv** %30, align 8
  br label %if.end.81

if.else:                                          ; preds = %cond.end
  %31 = load i64, i64* %len, align 8
  %add = add i64 %31, 1
  store i64 %add, i64* %min, align 8
  %32 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags16 = getelementptr inbounds %struct.sv, %struct.sv* %32, i32 0, i32 2
  %33 = load i32, i32* %sv_flags16, align 4
  %and17 = and i32 %33, 255
  %cmp18 = icmp uge i32 %and17, 4
  br i1 %cmp18, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.else
  %34 = load %struct.sv*, %struct.sv** %targ, align 8
  %call20 = call signext i8 @Perl_sv_upgrade(%struct.sv* %34, i32 4)
  %conv21 = sext i8 %call20 to i32
  %tobool22 = icmp ne i32 %conv21, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.else
  %35 = phi i1 [ true, %if.else ], [ %tobool22, %lor.rhs ]
  %lor.ext = zext i1 %35 to i32
  %36 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any23 = getelementptr inbounds %struct.sv, %struct.sv* %36, i32 0, i32 0
  %37 = load i8*, i8** %sv_any23, align 8
  %38 = bitcast i8* %37 to %struct.xpv*
  %xpv_len = getelementptr inbounds %struct.xpv, %struct.xpv* %38, i32 0, i32 2
  %39 = load i64, i64* %xpv_len, align 8
  %40 = load i64, i64* %min, align 8
  %cmp24 = icmp ult i64 %39, %40
  br i1 %cmp24, label %cond.true.26, label %cond.false.28

cond.true.26:                                     ; preds = %lor.end
  %41 = load %struct.sv*, %struct.sv** %targ, align 8
  %42 = load i64, i64* %min, align 8
  %call27 = call i8* @Perl_sv_grow(%struct.sv* %41, i64 %42)
  br label %cond.end.31

cond.false.28:                                    ; preds = %lor.end
  %43 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any29 = getelementptr inbounds %struct.sv, %struct.sv* %43, i32 0, i32 0
  %44 = load i8*, i8** %sv_any29, align 8
  %45 = bitcast i8* %44 to %struct.xpv*
  %xpv_pv30 = getelementptr inbounds %struct.xpv, %struct.xpv* %45, i32 0, i32 0
  %46 = load i8*, i8** %xpv_pv30, align 8
  br label %cond.end.31

cond.end.31:                                      ; preds = %cond.false.28, %cond.true.26
  %cond32 = phi i8* [ %call27, %cond.true.26 ], [ %46, %cond.false.28 ]
  %47 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags33 = getelementptr inbounds %struct.sv, %struct.sv* %47, i32 0, i32 2
  %48 = load i32, i32* %sv_flags33, align 4
  %and34 = and i32 %48, 1223753727
  store i32 %and34, i32* %sv_flags33, align 4
  %49 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags35 = getelementptr inbounds %struct.sv, %struct.sv* %49, i32 0, i32 2
  %50 = load i32, i32* %sv_flags35, align 4
  %or = or i32 %50, 67371008
  store i32 %or, i32* %sv_flags35, align 4
  %51 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any36 = getelementptr inbounds %struct.sv, %struct.sv* %51, i32 0, i32 0
  %52 = load i8*, i8** %sv_any36, align 8
  %53 = bitcast i8* %52 to %struct.xpv*
  %xpv_pv37 = getelementptr inbounds %struct.xpv, %struct.xpv* %53, i32 0, i32 0
  %54 = load i8*, i8** %xpv_pv37, align 8
  store i8* %54, i8** %d, align 8
  %55 = load i8*, i8** %s, align 8
  %56 = load i64, i64* %len, align 8
  %add.ptr = getelementptr inbounds i8, i8* %55, i64 %56
  store i8* %add.ptr, i8** %send, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end.68, %cond.end.31
  %57 = load i8*, i8** %s, align 8
  %58 = load i8*, i8** %send, align 8
  %cmp38 = icmp ult i8* %57, %58
  br i1 %cmp38, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %59 = load i8*, i8** %s, align 8
  %60 = load i8, i8* %59, align 1
  %idxprom = zext i8 %60 to i64
  %arrayidx40 = getelementptr inbounds [0 x i8], [0 x i8]* @PL_utf8skip, i32 0, i64 %idxprom
  %61 = load i8, i8* %arrayidx40, align 1
  %conv41 = zext i8 %61 to i64
  store i64 %conv41, i64* %u, align 8
  %62 = load i8*, i8** %s, align 8
  %arraydecay = getelementptr inbounds [14 x i8], [14 x i8]* %tmpbuf, i32 0, i32 0
  %call42 = call i64 @Perl_to_utf8_upper(i8* %62, i8* %arraydecay, i64* %ulen)
  %63 = load i64, i64* %ulen, align 8
  %64 = load i64, i64* %u, align 8
  %cmp43 = icmp ugt i64 %63, %64
  br i1 %cmp43, label %land.lhs.true.45, label %if.end.68

land.lhs.true.45:                                 ; preds = %while.body
  %65 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any46 = getelementptr inbounds %struct.sv, %struct.sv* %65, i32 0, i32 0
  %66 = load i8*, i8** %sv_any46, align 8
  %67 = bitcast i8* %66 to %struct.xpv*
  %xpv_len47 = getelementptr inbounds %struct.xpv, %struct.xpv* %67, i32 0, i32 2
  %68 = load i64, i64* %xpv_len47, align 8
  %69 = load i64, i64* %ulen, align 8
  %70 = load i64, i64* %u, align 8
  %sub = sub i64 %69, %70
  %71 = load i64, i64* %min, align 8
  %add48 = add i64 %71, %sub
  store i64 %add48, i64* %min, align 8
  %cmp49 = icmp ult i64 %68, %add48
  br i1 %cmp49, label %if.then.51, label %if.end.68

if.then.51:                                       ; preds = %land.lhs.true.45
  %72 = load i8*, i8** %d, align 8
  %73 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any52 = getelementptr inbounds %struct.sv, %struct.sv* %73, i32 0, i32 0
  %74 = load i8*, i8** %sv_any52, align 8
  %75 = bitcast i8* %74 to %struct.xpv*
  %xpv_pv53 = getelementptr inbounds %struct.xpv, %struct.xpv* %75, i32 0, i32 0
  %76 = load i8*, i8** %xpv_pv53, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %72 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %76 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, i64* %o, align 8
  %77 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any54 = getelementptr inbounds %struct.sv, %struct.sv* %77, i32 0, i32 0
  %78 = load i8*, i8** %sv_any54, align 8
  %79 = bitcast i8* %78 to %struct.xpv*
  %xpv_len55 = getelementptr inbounds %struct.xpv, %struct.xpv* %79, i32 0, i32 2
  %80 = load i64, i64* %xpv_len55, align 8
  %81 = load i64, i64* %min, align 8
  %cmp56 = icmp ult i64 %80, %81
  br i1 %cmp56, label %cond.true.58, label %cond.false.60

cond.true.58:                                     ; preds = %if.then.51
  %82 = load %struct.sv*, %struct.sv** %targ, align 8
  %83 = load i64, i64* %min, align 8
  %call59 = call i8* @Perl_sv_grow(%struct.sv* %82, i64 %83)
  br label %cond.end.63

cond.false.60:                                    ; preds = %if.then.51
  %84 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any61 = getelementptr inbounds %struct.sv, %struct.sv* %84, i32 0, i32 0
  %85 = load i8*, i8** %sv_any61, align 8
  %86 = bitcast i8* %85 to %struct.xpv*
  %xpv_pv62 = getelementptr inbounds %struct.xpv, %struct.xpv* %86, i32 0, i32 0
  %87 = load i8*, i8** %xpv_pv62, align 8
  br label %cond.end.63

cond.end.63:                                      ; preds = %cond.false.60, %cond.true.58
  %cond64 = phi i8* [ %call59, %cond.true.58 ], [ %87, %cond.false.60 ]
  %88 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any65 = getelementptr inbounds %struct.sv, %struct.sv* %88, i32 0, i32 0
  %89 = load i8*, i8** %sv_any65, align 8
  %90 = bitcast i8* %89 to %struct.xpv*
  %xpv_pv66 = getelementptr inbounds %struct.xpv, %struct.xpv* %90, i32 0, i32 0
  %91 = load i8*, i8** %xpv_pv66, align 8
  %92 = load i64, i64* %o, align 8
  %add.ptr67 = getelementptr inbounds i8, i8* %91, i64 %92
  store i8* %add.ptr67, i8** %d, align 8
  br label %if.end.68

if.end.68:                                        ; preds = %cond.end.63, %land.lhs.true.45, %while.body
  %93 = load i8*, i8** %d, align 8
  %arraydecay69 = getelementptr inbounds [14 x i8], [14 x i8]* %tmpbuf, i32 0, i32 0
  %94 = load i64, i64* %ulen, align 8
  %mul = mul i64 %94, 1
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %93, i8* %arraydecay69, i64 %mul, i32 1, i1 false)
  %95 = load i64, i64* %ulen, align 8
  %96 = load i8*, i8** %d, align 8
  %add.ptr70 = getelementptr inbounds i8, i8* %96, i64 %95
  store i8* %add.ptr70, i8** %d, align 8
  %97 = load i64, i64* %u, align 8
  %98 = load i8*, i8** %s, align 8
  %add.ptr71 = getelementptr inbounds i8, i8* %98, i64 %97
  store i8* %add.ptr71, i8** %s, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %99 = load i8*, i8** %d, align 8
  store i8 0, i8* %99, align 1
  %100 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags72 = getelementptr inbounds %struct.sv, %struct.sv* %100, i32 0, i32 2
  %101 = load i32, i32* %sv_flags72, align 4
  %or73 = or i32 %101, 536870912
  store i32 %or73, i32* %sv_flags72, align 4
  %102 = load i8*, i8** %d, align 8
  %103 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any74 = getelementptr inbounds %struct.sv, %struct.sv* %103, i32 0, i32 0
  %104 = load i8*, i8** %sv_any74, align 8
  %105 = bitcast i8* %104 to %struct.xpv*
  %xpv_pv75 = getelementptr inbounds %struct.xpv, %struct.xpv* %105, i32 0, i32 0
  %106 = load i8*, i8** %xpv_pv75, align 8
  %sub.ptr.lhs.cast76 = ptrtoint i8* %102 to i64
  %sub.ptr.rhs.cast77 = ptrtoint i8* %106 to i64
  %sub.ptr.sub78 = sub i64 %sub.ptr.lhs.cast76, %sub.ptr.rhs.cast77
  %107 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any79 = getelementptr inbounds %struct.sv, %struct.sv* %107, i32 0, i32 0
  %108 = load i8*, i8** %sv_any79, align 8
  %109 = bitcast i8* %108 to %struct.xpv*
  %xpv_cur80 = getelementptr inbounds %struct.xpv, %struct.xpv* %109, i32 0, i32 1
  store i64 %sub.ptr.sub78, i64* %xpv_cur80, align 8
  store i64 %sub.ptr.sub78, i64* %tmp
  %110 = load i64, i64* %tmp
  %111 = load %struct.sv*, %struct.sv** %targ, align 8
  %112 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %111, %struct.sv** %112, align 8
  br label %if.end.81

if.end.81:                                        ; preds = %while.end, %if.then.13
  br label %if.end.133

if.else.82:                                       ; preds = %land.lhs.true, %if.end
  %113 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags83 = getelementptr inbounds %struct.sv, %struct.sv* %113, i32 0, i32 2
  %114 = load i32, i32* %sv_flags83, align 4
  %and84 = and i32 %114, 512
  %tobool85 = icmp ne i32 %and84, 0
  br i1 %tobool85, label %lor.lhs.false, label %if.then.89

lor.lhs.false:                                    ; preds = %if.else.82
  %115 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags86 = getelementptr inbounds %struct.sv, %struct.sv* %115, i32 0, i32 2
  %116 = load i32, i32* %sv_flags86, align 4
  %and87 = and i32 %116, 8388608
  %tobool88 = icmp ne i32 %and87, 0
  br i1 %tobool88, label %if.then.89, label %if.end.96

if.then.89:                                       ; preds = %lor.lhs.false, %if.else.82
  %117 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ92 = getelementptr inbounds %struct.op, %struct.op* %117, i32 0, i32 3
  %118 = load i64, i64* %op_targ92, align 8
  %119 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx93 = getelementptr inbounds %struct.sv*, %struct.sv** %119, i64 %118
  %120 = load %struct.sv*, %struct.sv** %arrayidx93, align 8
  store %struct.sv* %120, %struct.sv** %targ91, align 8
  %121 = load %struct.sv*, %struct.sv** %targ91, align 8
  %sv_flags94 = getelementptr inbounds %struct.sv, %struct.sv* %121, i32 0, i32 2
  %122 = load i32, i32* %sv_flags94, align 4
  %and95 = and i32 %122, -536870913
  store i32 %and95, i32* %sv_flags94, align 4
  %123 = load %struct.sv*, %struct.sv** %targ91, align 8
  %124 = load %struct.sv*, %struct.sv** %sv, align 8
  call void @Perl_sv_setsv_flags(%struct.sv* %123, %struct.sv* %124, i32 0)
  %125 = load %struct.sv*, %struct.sv** %targ91, align 8
  store %struct.sv* %125, %struct.sv** %sv, align 8
  %126 = load %struct.sv*, %struct.sv** %sv, align 8
  %127 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %126, %struct.sv** %127, align 8
  br label %if.end.96

if.end.96:                                        ; preds = %if.then.89, %lor.lhs.false
  %128 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags97 = getelementptr inbounds %struct.sv, %struct.sv* %128, i32 0, i32 2
  %129 = load i32, i32* %sv_flags97, align 4
  %and98 = and i32 %129, 10223616
  %cmp99 = icmp eq i32 %and98, 262144
  br i1 %cmp99, label %cond.true.101, label %cond.false.106

cond.true.101:                                    ; preds = %if.end.96
  %130 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any102 = getelementptr inbounds %struct.sv, %struct.sv* %130, i32 0, i32 0
  %131 = load i8*, i8** %sv_any102, align 8
  %132 = bitcast i8* %131 to %struct.xpv*
  %xpv_cur103 = getelementptr inbounds %struct.xpv, %struct.xpv* %132, i32 0, i32 1
  %133 = load i64, i64* %xpv_cur103, align 8
  store i64 %133, i64* %len, align 8
  %134 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any104 = getelementptr inbounds %struct.sv, %struct.sv* %134, i32 0, i32 0
  %135 = load i8*, i8** %sv_any104, align 8
  %136 = bitcast i8* %135 to %struct.xpv*
  %xpv_pv105 = getelementptr inbounds %struct.xpv, %struct.xpv* %136, i32 0, i32 0
  %137 = load i8*, i8** %xpv_pv105, align 8
  br label %cond.end.108

cond.false.106:                                   ; preds = %if.end.96
  %138 = load %struct.sv*, %struct.sv** %sv, align 8
  %call107 = call i8* @Perl_sv_pvn_force_flags(%struct.sv* %138, i64* %len, i32 0)
  br label %cond.end.108

cond.end.108:                                     ; preds = %cond.false.106, %cond.true.101
  %cond109 = phi i8* [ %137, %cond.true.101 ], [ %call107, %cond.false.106 ]
  store i8* %cond109, i8** %s, align 8
  %139 = load i64, i64* %len, align 8
  %tobool110 = icmp ne i64 %139, 0
  br i1 %tobool110, label %if.then.111, label %if.end.132

if.then.111:                                      ; preds = %cond.end.108
  %140 = load i8*, i8** %s, align 8
  %141 = load i64, i64* %len, align 8
  %add.ptr114 = getelementptr inbounds i8, i8* %140, i64 %141
  store i8* %add.ptr114, i8** %send113, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then.111
  %142 = load i8*, i8** %s, align 8
  %143 = load i8*, i8** %send113, align 8
  %cmp115 = icmp ult i8* %142, %143
  br i1 %cmp115, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %144 = load i8*, i8** %s, align 8
  %145 = load i8, i8* %144, align 1
  %conv117 = zext i8 %145 to i32
  %cmp118 = icmp sge i32 %conv117, 97
  br i1 %cmp118, label %land.lhs.true.120, label %cond.false.127

land.lhs.true.120:                                ; preds = %for.body
  %146 = load i8*, i8** %s, align 8
  %147 = load i8, i8* %146, align 1
  %conv121 = zext i8 %147 to i32
  %cmp122 = icmp sle i32 %conv121, 122
  br i1 %cmp122, label %cond.true.124, label %cond.false.127

cond.true.124:                                    ; preds = %land.lhs.true.120
  %148 = load i8*, i8** %s, align 8
  %149 = load i8, i8* %148, align 1
  %conv125 = zext i8 %149 to i32
  %sub126 = sub nsw i32 %conv125, 32
  br label %cond.end.129

cond.false.127:                                   ; preds = %land.lhs.true.120, %for.body
  %150 = load i8*, i8** %s, align 8
  %151 = load i8, i8* %150, align 1
  %conv128 = zext i8 %151 to i32
  br label %cond.end.129

cond.end.129:                                     ; preds = %cond.false.127, %cond.true.124
  %cond130 = phi i32 [ %sub126, %cond.true.124 ], [ %conv128, %cond.false.127 ]
  %conv131 = trunc i32 %cond130 to i8
  %152 = load i8*, i8** %s, align 8
  store i8 %conv131, i8* %152, align 1
  br label %for.inc

for.inc:                                          ; preds = %cond.end.129
  %153 = load i8*, i8** %s, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %153, i32 1
  store i8* %incdec.ptr, i8** %s, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end.132

if.end.132:                                       ; preds = %for.end, %cond.end.108
  br label %if.end.133

if.end.133:                                       ; preds = %if.end.132, %if.end.81
  %154 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags134 = getelementptr inbounds %struct.sv, %struct.sv* %154, i32 0, i32 2
  %155 = load i32, i32* %sv_flags134, align 4
  %and135 = and i32 %155, 16384
  %tobool136 = icmp ne i32 %and135, 0
  br i1 %tobool136, label %if.then.137, label %if.end.139

if.then.137:                                      ; preds = %if.end.133
  %156 = load %struct.sv*, %struct.sv** %sv, align 8
  %call138 = call i32 @Perl_mg_set(%struct.sv* %156)
  br label %if.end.139

if.end.139:                                       ; preds = %if.then.137, %if.end.133
  %157 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %157, %struct.sv*** @PL_stack_sp, align 8
  %158 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %158, i32 0, i32 0
  %159 = load %struct.op*, %struct.op** %op_next, align 8
  ret %struct.op* %159
}

declare i64 @Perl_to_utf8_upper(i8*, i8*, i64*) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_lc() #0 {
entry:
  %sp = alloca %struct.sv**, align 8
  %sv = alloca %struct.sv*, align 8
  %s = alloca i8*, align 8
  %len = alloca i64, align 8
  %targ = alloca %struct.sv*, align 8
  %ulen = alloca i64, align 8
  %d = alloca i8*, align 8
  %send = alloca i8*, align 8
  %tmpbuf = alloca [7 x i8], align 1
  %min = alloca i64, align 8
  %u = alloca i64, align 8
  %uv = alloca i64, align 8
  %o = alloca i64, align 8
  %tmp = alloca i64, align 8
  %targ95 = alloca %struct.sv*, align 8
  %send117 = alloca i8*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.sv**, %struct.sv*** %sp, align 8
  %2 = load %struct.sv*, %struct.sv** %1, align 8
  store %struct.sv* %2, %struct.sv** %sv, align 8
  %3 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %3, i32 0, i32 2
  %4 = load i32, i32* %sv_flags, align 4
  %and = and i32 %4, 8192
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load %struct.sv*, %struct.sv** %sv, align 8
  %call = call i32 @Perl_mg_get(%struct.sv* %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags1 = getelementptr inbounds %struct.sv, %struct.sv* %6, i32 0, i32 2
  %7 = load i32, i32* %sv_flags1, align 4
  %and2 = and i32 %7, 536870912
  %tobool3 = icmp ne i32 %and2, 0
  br i1 %tobool3, label %land.lhs.true, label %if.else.86

land.lhs.true:                                    ; preds = %if.end
  %8 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %op_private = getelementptr inbounds %struct.cop, %struct.cop* %8, i32 0, i32 7
  %9 = load i8, i8* %op_private, align 1
  %conv = zext i8 %9 to i32
  %and4 = and i32 %conv, 8
  %tobool5 = icmp ne i32 %and4, 0
  br i1 %tobool5, label %if.else.86, label %if.then.6

if.then.6:                                        ; preds = %land.lhs.true
  %10 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %10, i32 0, i32 3
  %11 = load i64, i64* %op_targ, align 8
  %12 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %12, i64 %11
  %13 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %13, %struct.sv** %targ, align 8
  %14 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags7 = getelementptr inbounds %struct.sv, %struct.sv* %14, i32 0, i32 2
  %15 = load i32, i32* %sv_flags7, align 4
  %and8 = and i32 %15, 262144
  %cmp = icmp eq i32 %and8, 262144
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.6
  %16 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %16, i32 0, i32 0
  %17 = load i8*, i8** %sv_any, align 8
  %18 = bitcast i8* %17 to %struct.xpv*
  %xpv_cur = getelementptr inbounds %struct.xpv, %struct.xpv* %18, i32 0, i32 1
  %19 = load i64, i64* %xpv_cur, align 8
  store i64 %19, i64* %len, align 8
  %20 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any10 = getelementptr inbounds %struct.sv, %struct.sv* %20, i32 0, i32 0
  %21 = load i8*, i8** %sv_any10, align 8
  %22 = bitcast i8* %21 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %22, i32 0, i32 0
  %23 = load i8*, i8** %xpv_pv, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then.6
  %24 = load %struct.sv*, %struct.sv** %sv, align 8
  %call11 = call i8* @Perl_sv_2pv_flags(%struct.sv* %24, i64* %len, i32 0)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %23, %cond.true ], [ %call11, %cond.false ]
  store i8* %cond, i8** %s, align 8
  %25 = load i64, i64* %len, align 8
  %tobool12 = icmp ne i64 %25, 0
  br i1 %tobool12, label %if.else, label %if.then.13

if.then.13:                                       ; preds = %cond.end
  %26 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags14 = getelementptr inbounds %struct.sv, %struct.sv* %26, i32 0, i32 2
  %27 = load i32, i32* %sv_flags14, align 4
  %and15 = and i32 %27, -536870913
  store i32 %and15, i32* %sv_flags14, align 4
  %28 = load %struct.sv*, %struct.sv** %targ, align 8
  call void @Perl_sv_setpvn(%struct.sv* %28, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.4, i32 0, i32 0), i64 0)
  %29 = load %struct.sv*, %struct.sv** %targ, align 8
  %30 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %29, %struct.sv** %30, align 8
  br label %if.end.85

if.else:                                          ; preds = %cond.end
  %31 = load i64, i64* %len, align 8
  %add = add i64 %31, 1
  store i64 %add, i64* %min, align 8
  %32 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags16 = getelementptr inbounds %struct.sv, %struct.sv* %32, i32 0, i32 2
  %33 = load i32, i32* %sv_flags16, align 4
  %and17 = and i32 %33, 255
  %cmp18 = icmp uge i32 %and17, 4
  br i1 %cmp18, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.else
  %34 = load %struct.sv*, %struct.sv** %targ, align 8
  %call20 = call signext i8 @Perl_sv_upgrade(%struct.sv* %34, i32 4)
  %conv21 = sext i8 %call20 to i32
  %tobool22 = icmp ne i32 %conv21, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.else
  %35 = phi i1 [ true, %if.else ], [ %tobool22, %lor.rhs ]
  %lor.ext = zext i1 %35 to i32
  %36 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any23 = getelementptr inbounds %struct.sv, %struct.sv* %36, i32 0, i32 0
  %37 = load i8*, i8** %sv_any23, align 8
  %38 = bitcast i8* %37 to %struct.xpv*
  %xpv_len = getelementptr inbounds %struct.xpv, %struct.xpv* %38, i32 0, i32 2
  %39 = load i64, i64* %xpv_len, align 8
  %40 = load i64, i64* %min, align 8
  %cmp24 = icmp ult i64 %39, %40
  br i1 %cmp24, label %cond.true.26, label %cond.false.28

cond.true.26:                                     ; preds = %lor.end
  %41 = load %struct.sv*, %struct.sv** %targ, align 8
  %42 = load i64, i64* %min, align 8
  %call27 = call i8* @Perl_sv_grow(%struct.sv* %41, i64 %42)
  br label %cond.end.31

cond.false.28:                                    ; preds = %lor.end
  %43 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any29 = getelementptr inbounds %struct.sv, %struct.sv* %43, i32 0, i32 0
  %44 = load i8*, i8** %sv_any29, align 8
  %45 = bitcast i8* %44 to %struct.xpv*
  %xpv_pv30 = getelementptr inbounds %struct.xpv, %struct.xpv* %45, i32 0, i32 0
  %46 = load i8*, i8** %xpv_pv30, align 8
  br label %cond.end.31

cond.end.31:                                      ; preds = %cond.false.28, %cond.true.26
  %cond32 = phi i8* [ %call27, %cond.true.26 ], [ %46, %cond.false.28 ]
  %47 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags33 = getelementptr inbounds %struct.sv, %struct.sv* %47, i32 0, i32 2
  %48 = load i32, i32* %sv_flags33, align 4
  %and34 = and i32 %48, 1223753727
  store i32 %and34, i32* %sv_flags33, align 4
  %49 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags35 = getelementptr inbounds %struct.sv, %struct.sv* %49, i32 0, i32 2
  %50 = load i32, i32* %sv_flags35, align 4
  %or = or i32 %50, 67371008
  store i32 %or, i32* %sv_flags35, align 4
  %51 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any36 = getelementptr inbounds %struct.sv, %struct.sv* %51, i32 0, i32 0
  %52 = load i8*, i8** %sv_any36, align 8
  %53 = bitcast i8* %52 to %struct.xpv*
  %xpv_pv37 = getelementptr inbounds %struct.xpv, %struct.xpv* %53, i32 0, i32 0
  %54 = load i8*, i8** %xpv_pv37, align 8
  store i8* %54, i8** %d, align 8
  %55 = load i8*, i8** %s, align 8
  %56 = load i64, i64* %len, align 8
  %add.ptr = getelementptr inbounds i8, i8* %55, i64 %56
  store i8* %add.ptr, i8** %send, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end.72, %cond.end.31
  %57 = load i8*, i8** %s, align 8
  %58 = load i8*, i8** %send, align 8
  %cmp38 = icmp ult i8* %57, %58
  br i1 %cmp38, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %59 = load i8*, i8** %s, align 8
  %60 = load i8, i8* %59, align 1
  %idxprom = zext i8 %60 to i64
  %arrayidx40 = getelementptr inbounds [0 x i8], [0 x i8]* @PL_utf8skip, i32 0, i64 %idxprom
  %61 = load i8, i8* %arrayidx40, align 1
  %conv41 = zext i8 %61 to i64
  store i64 %conv41, i64* %u, align 8
  %62 = load i8*, i8** %s, align 8
  %arraydecay = getelementptr inbounds [7 x i8], [7 x i8]* %tmpbuf, i32 0, i32 0
  %call42 = call i64 @Perl_to_utf8_lower(i8* %62, i8* %arraydecay, i64* %ulen)
  store i64 %call42, i64* %uv, align 8
  %63 = load i64, i64* %uv, align 8
  %cmp43 = icmp eq i64 %63, 931
  br i1 %cmp43, label %if.then.45, label %if.end.46

if.then.45:                                       ; preds = %while.body
  br label %if.end.46

if.end.46:                                        ; preds = %if.then.45, %while.body
  %64 = load i64, i64* %ulen, align 8
  %65 = load i64, i64* %u, align 8
  %cmp47 = icmp ugt i64 %64, %65
  br i1 %cmp47, label %land.lhs.true.49, label %if.end.72

land.lhs.true.49:                                 ; preds = %if.end.46
  %66 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any50 = getelementptr inbounds %struct.sv, %struct.sv* %66, i32 0, i32 0
  %67 = load i8*, i8** %sv_any50, align 8
  %68 = bitcast i8* %67 to %struct.xpv*
  %xpv_len51 = getelementptr inbounds %struct.xpv, %struct.xpv* %68, i32 0, i32 2
  %69 = load i64, i64* %xpv_len51, align 8
  %70 = load i64, i64* %ulen, align 8
  %71 = load i64, i64* %u, align 8
  %sub = sub i64 %70, %71
  %72 = load i64, i64* %min, align 8
  %add52 = add i64 %72, %sub
  store i64 %add52, i64* %min, align 8
  %cmp53 = icmp ult i64 %69, %add52
  br i1 %cmp53, label %if.then.55, label %if.end.72

if.then.55:                                       ; preds = %land.lhs.true.49
  %73 = load i8*, i8** %d, align 8
  %74 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any56 = getelementptr inbounds %struct.sv, %struct.sv* %74, i32 0, i32 0
  %75 = load i8*, i8** %sv_any56, align 8
  %76 = bitcast i8* %75 to %struct.xpv*
  %xpv_pv57 = getelementptr inbounds %struct.xpv, %struct.xpv* %76, i32 0, i32 0
  %77 = load i8*, i8** %xpv_pv57, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %73 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %77 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, i64* %o, align 8
  %78 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any58 = getelementptr inbounds %struct.sv, %struct.sv* %78, i32 0, i32 0
  %79 = load i8*, i8** %sv_any58, align 8
  %80 = bitcast i8* %79 to %struct.xpv*
  %xpv_len59 = getelementptr inbounds %struct.xpv, %struct.xpv* %80, i32 0, i32 2
  %81 = load i64, i64* %xpv_len59, align 8
  %82 = load i64, i64* %min, align 8
  %cmp60 = icmp ult i64 %81, %82
  br i1 %cmp60, label %cond.true.62, label %cond.false.64

cond.true.62:                                     ; preds = %if.then.55
  %83 = load %struct.sv*, %struct.sv** %targ, align 8
  %84 = load i64, i64* %min, align 8
  %call63 = call i8* @Perl_sv_grow(%struct.sv* %83, i64 %84)
  br label %cond.end.67

cond.false.64:                                    ; preds = %if.then.55
  %85 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any65 = getelementptr inbounds %struct.sv, %struct.sv* %85, i32 0, i32 0
  %86 = load i8*, i8** %sv_any65, align 8
  %87 = bitcast i8* %86 to %struct.xpv*
  %xpv_pv66 = getelementptr inbounds %struct.xpv, %struct.xpv* %87, i32 0, i32 0
  %88 = load i8*, i8** %xpv_pv66, align 8
  br label %cond.end.67

cond.end.67:                                      ; preds = %cond.false.64, %cond.true.62
  %cond68 = phi i8* [ %call63, %cond.true.62 ], [ %88, %cond.false.64 ]
  %89 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any69 = getelementptr inbounds %struct.sv, %struct.sv* %89, i32 0, i32 0
  %90 = load i8*, i8** %sv_any69, align 8
  %91 = bitcast i8* %90 to %struct.xpv*
  %xpv_pv70 = getelementptr inbounds %struct.xpv, %struct.xpv* %91, i32 0, i32 0
  %92 = load i8*, i8** %xpv_pv70, align 8
  %93 = load i64, i64* %o, align 8
  %add.ptr71 = getelementptr inbounds i8, i8* %92, i64 %93
  store i8* %add.ptr71, i8** %d, align 8
  br label %if.end.72

if.end.72:                                        ; preds = %cond.end.67, %land.lhs.true.49, %if.end.46
  %94 = load i8*, i8** %d, align 8
  %arraydecay73 = getelementptr inbounds [7 x i8], [7 x i8]* %tmpbuf, i32 0, i32 0
  %95 = load i64, i64* %ulen, align 8
  %mul = mul i64 %95, 1
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %94, i8* %arraydecay73, i64 %mul, i32 1, i1 false)
  %96 = load i64, i64* %ulen, align 8
  %97 = load i8*, i8** %d, align 8
  %add.ptr74 = getelementptr inbounds i8, i8* %97, i64 %96
  store i8* %add.ptr74, i8** %d, align 8
  %98 = load i64, i64* %u, align 8
  %99 = load i8*, i8** %s, align 8
  %add.ptr75 = getelementptr inbounds i8, i8* %99, i64 %98
  store i8* %add.ptr75, i8** %s, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %100 = load i8*, i8** %d, align 8
  store i8 0, i8* %100, align 1
  %101 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags76 = getelementptr inbounds %struct.sv, %struct.sv* %101, i32 0, i32 2
  %102 = load i32, i32* %sv_flags76, align 4
  %or77 = or i32 %102, 536870912
  store i32 %or77, i32* %sv_flags76, align 4
  %103 = load i8*, i8** %d, align 8
  %104 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any78 = getelementptr inbounds %struct.sv, %struct.sv* %104, i32 0, i32 0
  %105 = load i8*, i8** %sv_any78, align 8
  %106 = bitcast i8* %105 to %struct.xpv*
  %xpv_pv79 = getelementptr inbounds %struct.xpv, %struct.xpv* %106, i32 0, i32 0
  %107 = load i8*, i8** %xpv_pv79, align 8
  %sub.ptr.lhs.cast80 = ptrtoint i8* %103 to i64
  %sub.ptr.rhs.cast81 = ptrtoint i8* %107 to i64
  %sub.ptr.sub82 = sub i64 %sub.ptr.lhs.cast80, %sub.ptr.rhs.cast81
  %108 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any83 = getelementptr inbounds %struct.sv, %struct.sv* %108, i32 0, i32 0
  %109 = load i8*, i8** %sv_any83, align 8
  %110 = bitcast i8* %109 to %struct.xpv*
  %xpv_cur84 = getelementptr inbounds %struct.xpv, %struct.xpv* %110, i32 0, i32 1
  store i64 %sub.ptr.sub82, i64* %xpv_cur84, align 8
  store i64 %sub.ptr.sub82, i64* %tmp
  %111 = load i64, i64* %tmp
  %112 = load %struct.sv*, %struct.sv** %targ, align 8
  %113 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %112, %struct.sv** %113, align 8
  br label %if.end.85

if.end.85:                                        ; preds = %while.end, %if.then.13
  br label %if.end.137

if.else.86:                                       ; preds = %land.lhs.true, %if.end
  %114 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags87 = getelementptr inbounds %struct.sv, %struct.sv* %114, i32 0, i32 2
  %115 = load i32, i32* %sv_flags87, align 4
  %and88 = and i32 %115, 512
  %tobool89 = icmp ne i32 %and88, 0
  br i1 %tobool89, label %lor.lhs.false, label %if.then.93

lor.lhs.false:                                    ; preds = %if.else.86
  %116 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags90 = getelementptr inbounds %struct.sv, %struct.sv* %116, i32 0, i32 2
  %117 = load i32, i32* %sv_flags90, align 4
  %and91 = and i32 %117, 8388608
  %tobool92 = icmp ne i32 %and91, 0
  br i1 %tobool92, label %if.then.93, label %if.end.100

if.then.93:                                       ; preds = %lor.lhs.false, %if.else.86
  %118 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ96 = getelementptr inbounds %struct.op, %struct.op* %118, i32 0, i32 3
  %119 = load i64, i64* %op_targ96, align 8
  %120 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx97 = getelementptr inbounds %struct.sv*, %struct.sv** %120, i64 %119
  %121 = load %struct.sv*, %struct.sv** %arrayidx97, align 8
  store %struct.sv* %121, %struct.sv** %targ95, align 8
  %122 = load %struct.sv*, %struct.sv** %targ95, align 8
  %sv_flags98 = getelementptr inbounds %struct.sv, %struct.sv* %122, i32 0, i32 2
  %123 = load i32, i32* %sv_flags98, align 4
  %and99 = and i32 %123, -536870913
  store i32 %and99, i32* %sv_flags98, align 4
  %124 = load %struct.sv*, %struct.sv** %targ95, align 8
  %125 = load %struct.sv*, %struct.sv** %sv, align 8
  call void @Perl_sv_setsv_flags(%struct.sv* %124, %struct.sv* %125, i32 0)
  %126 = load %struct.sv*, %struct.sv** %targ95, align 8
  store %struct.sv* %126, %struct.sv** %sv, align 8
  %127 = load %struct.sv*, %struct.sv** %sv, align 8
  %128 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %127, %struct.sv** %128, align 8
  br label %if.end.100

if.end.100:                                       ; preds = %if.then.93, %lor.lhs.false
  %129 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags101 = getelementptr inbounds %struct.sv, %struct.sv* %129, i32 0, i32 2
  %130 = load i32, i32* %sv_flags101, align 4
  %and102 = and i32 %130, 10223616
  %cmp103 = icmp eq i32 %and102, 262144
  br i1 %cmp103, label %cond.true.105, label %cond.false.110

cond.true.105:                                    ; preds = %if.end.100
  %131 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any106 = getelementptr inbounds %struct.sv, %struct.sv* %131, i32 0, i32 0
  %132 = load i8*, i8** %sv_any106, align 8
  %133 = bitcast i8* %132 to %struct.xpv*
  %xpv_cur107 = getelementptr inbounds %struct.xpv, %struct.xpv* %133, i32 0, i32 1
  %134 = load i64, i64* %xpv_cur107, align 8
  store i64 %134, i64* %len, align 8
  %135 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any108 = getelementptr inbounds %struct.sv, %struct.sv* %135, i32 0, i32 0
  %136 = load i8*, i8** %sv_any108, align 8
  %137 = bitcast i8* %136 to %struct.xpv*
  %xpv_pv109 = getelementptr inbounds %struct.xpv, %struct.xpv* %137, i32 0, i32 0
  %138 = load i8*, i8** %xpv_pv109, align 8
  br label %cond.end.112

cond.false.110:                                   ; preds = %if.end.100
  %139 = load %struct.sv*, %struct.sv** %sv, align 8
  %call111 = call i8* @Perl_sv_pvn_force_flags(%struct.sv* %139, i64* %len, i32 0)
  br label %cond.end.112

cond.end.112:                                     ; preds = %cond.false.110, %cond.true.105
  %cond113 = phi i8* [ %138, %cond.true.105 ], [ %call111, %cond.false.110 ]
  store i8* %cond113, i8** %s, align 8
  %140 = load i64, i64* %len, align 8
  %tobool114 = icmp ne i64 %140, 0
  br i1 %tobool114, label %if.then.115, label %if.end.136

if.then.115:                                      ; preds = %cond.end.112
  %141 = load i8*, i8** %s, align 8
  %142 = load i64, i64* %len, align 8
  %add.ptr118 = getelementptr inbounds i8, i8* %141, i64 %142
  store i8* %add.ptr118, i8** %send117, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then.115
  %143 = load i8*, i8** %s, align 8
  %144 = load i8*, i8** %send117, align 8
  %cmp119 = icmp ult i8* %143, %144
  br i1 %cmp119, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %145 = load i8*, i8** %s, align 8
  %146 = load i8, i8* %145, align 1
  %conv121 = zext i8 %146 to i32
  %cmp122 = icmp sge i32 %conv121, 65
  br i1 %cmp122, label %land.lhs.true.124, label %cond.false.131

land.lhs.true.124:                                ; preds = %for.body
  %147 = load i8*, i8** %s, align 8
  %148 = load i8, i8* %147, align 1
  %conv125 = zext i8 %148 to i32
  %cmp126 = icmp sle i32 %conv125, 90
  br i1 %cmp126, label %cond.true.128, label %cond.false.131

cond.true.128:                                    ; preds = %land.lhs.true.124
  %149 = load i8*, i8** %s, align 8
  %150 = load i8, i8* %149, align 1
  %conv129 = zext i8 %150 to i32
  %add130 = add nsw i32 %conv129, 32
  br label %cond.end.133

cond.false.131:                                   ; preds = %land.lhs.true.124, %for.body
  %151 = load i8*, i8** %s, align 8
  %152 = load i8, i8* %151, align 1
  %conv132 = zext i8 %152 to i32
  br label %cond.end.133

cond.end.133:                                     ; preds = %cond.false.131, %cond.true.128
  %cond134 = phi i32 [ %add130, %cond.true.128 ], [ %conv132, %cond.false.131 ]
  %conv135 = trunc i32 %cond134 to i8
  %153 = load i8*, i8** %s, align 8
  store i8 %conv135, i8* %153, align 1
  br label %for.inc

for.inc:                                          ; preds = %cond.end.133
  %154 = load i8*, i8** %s, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %154, i32 1
  store i8* %incdec.ptr, i8** %s, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end.136

if.end.136:                                       ; preds = %for.end, %cond.end.112
  br label %if.end.137

if.end.137:                                       ; preds = %if.end.136, %if.end.85
  %155 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags138 = getelementptr inbounds %struct.sv, %struct.sv* %155, i32 0, i32 2
  %156 = load i32, i32* %sv_flags138, align 4
  %and139 = and i32 %156, 16384
  %tobool140 = icmp ne i32 %and139, 0
  br i1 %tobool140, label %if.then.141, label %if.end.143

if.then.141:                                      ; preds = %if.end.137
  %157 = load %struct.sv*, %struct.sv** %sv, align 8
  %call142 = call i32 @Perl_mg_set(%struct.sv* %157)
  br label %if.end.143

if.end.143:                                       ; preds = %if.then.141, %if.end.137
  %158 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %158, %struct.sv*** @PL_stack_sp, align 8
  %159 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %159, i32 0, i32 0
  %160 = load %struct.op*, %struct.op** %op_next, align 8
  ret %struct.op* %160
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_quotemeta() #0 {
entry:
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %sv = alloca %struct.sv*, align 8
  %len = alloca i64, align 8
  %s = alloca i8*, align 8
  %d = alloca i8*, align 8
  %ulen = alloca i64, align 8
  %tmp = alloca i64, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 3
  %2 = load i64, i64* %op_targ, align 8
  %3 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %3, i64 %2
  %4 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %4, %struct.sv** %targ, align 8
  %5 = load %struct.sv**, %struct.sv*** %sp, align 8
  %6 = load %struct.sv*, %struct.sv** %5, align 8
  store %struct.sv* %6, %struct.sv** %sv, align 8
  %7 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %7, i32 0, i32 2
  %8 = load i32, i32* %sv_flags, align 4
  %and = and i32 %8, 262144
  %cmp = icmp eq i32 %and, 262144
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %9 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %9, i32 0, i32 0
  %10 = load i8*, i8** %sv_any, align 8
  %11 = bitcast i8* %10 to %struct.xpv*
  %xpv_cur = getelementptr inbounds %struct.xpv, %struct.xpv* %11, i32 0, i32 1
  %12 = load i64, i64* %xpv_cur, align 8
  store i64 %12, i64* %len, align 8
  %13 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any1 = getelementptr inbounds %struct.sv, %struct.sv* %13, i32 0, i32 0
  %14 = load i8*, i8** %sv_any1, align 8
  %15 = bitcast i8* %14 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %15, i32 0, i32 0
  %16 = load i8*, i8** %xpv_pv, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %17 = load %struct.sv*, %struct.sv** %sv, align 8
  %call = call i8* @Perl_sv_2pv_flags(%struct.sv* %17, i64* %len, i32 2)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %16, %cond.true ], [ %call, %cond.false ]
  store i8* %cond, i8** %s, align 8
  %18 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags2 = getelementptr inbounds %struct.sv, %struct.sv* %18, i32 0, i32 2
  %19 = load i32, i32* %sv_flags2, align 4
  %and3 = and i32 %19, -536870913
  store i32 %and3, i32* %sv_flags2, align 4
  %20 = load i64, i64* %len, align 8
  %tobool = icmp ne i64 %20, 0
  br i1 %tobool, label %if.then, label %if.else.126

if.then:                                          ; preds = %cond.end
  %21 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags4 = getelementptr inbounds %struct.sv, %struct.sv* %21, i32 0, i32 2
  %22 = load i32, i32* %sv_flags4, align 4
  %and5 = and i32 %22, 255
  %cmp6 = icmp uge i32 %and5, 4
  br i1 %cmp6, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.then
  %23 = load %struct.sv*, %struct.sv** %targ, align 8
  %call7 = call signext i8 @Perl_sv_upgrade(%struct.sv* %23, i32 4)
  %conv = sext i8 %call7 to i32
  %tobool8 = icmp ne i32 %conv, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.then
  %24 = phi i1 [ true, %if.then ], [ %tobool8, %lor.rhs ]
  %lor.ext = zext i1 %24 to i32
  %25 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any9 = getelementptr inbounds %struct.sv, %struct.sv* %25, i32 0, i32 0
  %26 = load i8*, i8** %sv_any9, align 8
  %27 = bitcast i8* %26 to %struct.xpv*
  %xpv_len = getelementptr inbounds %struct.xpv, %struct.xpv* %27, i32 0, i32 2
  %28 = load i64, i64* %xpv_len, align 8
  %29 = load i64, i64* %len, align 8
  %mul = mul i64 %29, 2
  %add = add i64 %mul, 1
  %cmp10 = icmp ult i64 %28, %add
  br i1 %cmp10, label %cond.true.12, label %cond.false.16

cond.true.12:                                     ; preds = %lor.end
  %30 = load %struct.sv*, %struct.sv** %targ, align 8
  %31 = load i64, i64* %len, align 8
  %mul13 = mul i64 %31, 2
  %add14 = add i64 %mul13, 1
  %call15 = call i8* @Perl_sv_grow(%struct.sv* %30, i64 %add14)
  br label %cond.end.19

cond.false.16:                                    ; preds = %lor.end
  %32 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any17 = getelementptr inbounds %struct.sv, %struct.sv* %32, i32 0, i32 0
  %33 = load i8*, i8** %sv_any17, align 8
  %34 = bitcast i8* %33 to %struct.xpv*
  %xpv_pv18 = getelementptr inbounds %struct.xpv, %struct.xpv* %34, i32 0, i32 0
  %35 = load i8*, i8** %xpv_pv18, align 8
  br label %cond.end.19

cond.end.19:                                      ; preds = %cond.false.16, %cond.true.12
  %cond20 = phi i8* [ %call15, %cond.true.12 ], [ %35, %cond.false.16 ]
  %36 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any21 = getelementptr inbounds %struct.sv, %struct.sv* %36, i32 0, i32 0
  %37 = load i8*, i8** %sv_any21, align 8
  %38 = bitcast i8* %37 to %struct.xpv*
  %xpv_pv22 = getelementptr inbounds %struct.xpv, %struct.xpv* %38, i32 0, i32 0
  %39 = load i8*, i8** %xpv_pv22, align 8
  store i8* %39, i8** %d, align 8
  %40 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags23 = getelementptr inbounds %struct.sv, %struct.sv* %40, i32 0, i32 2
  %41 = load i32, i32* %sv_flags23, align 4
  %and24 = and i32 %41, 536870912
  %tobool25 = icmp ne i32 %and24, 0
  br i1 %tobool25, label %land.lhs.true, label %if.else.79

land.lhs.true:                                    ; preds = %cond.end.19
  %42 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %op_private = getelementptr inbounds %struct.cop, %struct.cop* %42, i32 0, i32 7
  %43 = load i8, i8* %op_private, align 1
  %conv26 = zext i8 %43 to i32
  %and27 = and i32 %conv26, 8
  %tobool28 = icmp ne i32 %and27, 0
  br i1 %tobool28, label %if.else.79, label %if.then.29

if.then.29:                                       ; preds = %land.lhs.true
  br label %while.cond

while.cond:                                       ; preds = %if.end.76, %if.then.29
  %44 = load i64, i64* %len, align 8
  %tobool30 = icmp ne i64 %44, 0
  br i1 %tobool30, label %while.body, label %while.end.77

while.body:                                       ; preds = %while.cond
  %45 = load i8*, i8** %s, align 8
  %46 = load i8, i8* %45, align 1
  %conv31 = zext i8 %46 to i32
  %and32 = and i32 %conv31, 128
  %tobool33 = icmp ne i32 %and32, 0
  br i1 %tobool33, label %if.then.34, label %if.else

if.then.34:                                       ; preds = %while.body
  %47 = load i8*, i8** %s, align 8
  %48 = load i8, i8* %47, align 1
  %idxprom = zext i8 %48 to i64
  %arrayidx35 = getelementptr inbounds [0 x i8], [0 x i8]* @PL_utf8skip, i32 0, i64 %idxprom
  %49 = load i8, i8* %arrayidx35, align 1
  %conv36 = zext i8 %49 to i64
  store i64 %conv36, i64* %ulen, align 8
  %50 = load i64, i64* %ulen, align 8
  %51 = load i64, i64* %len, align 8
  %cmp37 = icmp ugt i64 %50, %51
  br i1 %cmp37, label %if.then.39, label %if.end

if.then.39:                                       ; preds = %if.then.34
  %52 = load i64, i64* %len, align 8
  store i64 %52, i64* %ulen, align 8
  br label %if.end

if.end:                                           ; preds = %if.then.39, %if.then.34
  %53 = load i64, i64* %ulen, align 8
  %54 = load i64, i64* %len, align 8
  %sub = sub i64 %54, %53
  store i64 %sub, i64* %len, align 8
  br label %while.cond.40

while.cond.40:                                    ; preds = %while.body.42, %if.end
  %55 = load i64, i64* %ulen, align 8
  %dec = add i64 %55, -1
  store i64 %dec, i64* %ulen, align 8
  %tobool41 = icmp ne i64 %55, 0
  br i1 %tobool41, label %while.body.42, label %while.end

while.body.42:                                    ; preds = %while.cond.40
  %56 = load i8*, i8** %s, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %56, i32 1
  store i8* %incdec.ptr, i8** %s, align 8
  %57 = load i8, i8* %56, align 1
  %58 = load i8*, i8** %d, align 8
  %incdec.ptr43 = getelementptr inbounds i8, i8* %58, i32 1
  store i8* %incdec.ptr43, i8** %d, align 8
  store i8 %57, i8* %58, align 1
  br label %while.cond.40

while.end:                                        ; preds = %while.cond.40
  br label %if.end.76

if.else:                                          ; preds = %while.body
  %59 = load i8*, i8** %s, align 8
  %60 = load i8, i8* %59, align 1
  %conv44 = sext i8 %60 to i32
  %cmp45 = icmp sge i32 %conv44, 65
  br i1 %cmp45, label %land.lhs.true.47, label %lor.lhs.false

land.lhs.true.47:                                 ; preds = %if.else
  %61 = load i8*, i8** %s, align 8
  %62 = load i8, i8* %61, align 1
  %conv48 = sext i8 %62 to i32
  %cmp49 = icmp sle i32 %conv48, 90
  br i1 %cmp49, label %if.end.72, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true.47, %if.else
  %63 = load i8*, i8** %s, align 8
  %64 = load i8, i8* %63, align 1
  %conv51 = sext i8 %64 to i32
  %cmp52 = icmp sge i32 %conv51, 97
  br i1 %cmp52, label %land.lhs.true.54, label %lor.lhs.false.58

land.lhs.true.54:                                 ; preds = %lor.lhs.false
  %65 = load i8*, i8** %s, align 8
  %66 = load i8, i8* %65, align 1
  %conv55 = sext i8 %66 to i32
  %cmp56 = icmp sle i32 %conv55, 122
  br i1 %cmp56, label %if.end.72, label %lor.lhs.false.58

lor.lhs.false.58:                                 ; preds = %land.lhs.true.54, %lor.lhs.false
  %67 = load i8*, i8** %s, align 8
  %68 = load i8, i8* %67, align 1
  %conv59 = sext i8 %68 to i32
  %cmp60 = icmp sge i32 %conv59, 48
  br i1 %cmp60, label %land.lhs.true.62, label %lor.lhs.false.66

land.lhs.true.62:                                 ; preds = %lor.lhs.false.58
  %69 = load i8*, i8** %s, align 8
  %70 = load i8, i8* %69, align 1
  %conv63 = sext i8 %70 to i32
  %cmp64 = icmp sle i32 %conv63, 57
  br i1 %cmp64, label %if.end.72, label %lor.lhs.false.66

lor.lhs.false.66:                                 ; preds = %land.lhs.true.62, %lor.lhs.false.58
  %71 = load i8*, i8** %s, align 8
  %72 = load i8, i8* %71, align 1
  %conv67 = sext i8 %72 to i32
  %cmp68 = icmp eq i32 %conv67, 95
  br i1 %cmp68, label %if.end.72, label %if.then.70

if.then.70:                                       ; preds = %lor.lhs.false.66
  %73 = load i8*, i8** %d, align 8
  %incdec.ptr71 = getelementptr inbounds i8, i8* %73, i32 1
  store i8* %incdec.ptr71, i8** %d, align 8
  store i8 92, i8* %73, align 1
  br label %if.end.72

if.end.72:                                        ; preds = %if.then.70, %lor.lhs.false.66, %land.lhs.true.62, %land.lhs.true.54, %land.lhs.true.47
  %74 = load i8*, i8** %s, align 8
  %incdec.ptr73 = getelementptr inbounds i8, i8* %74, i32 1
  store i8* %incdec.ptr73, i8** %s, align 8
  %75 = load i8, i8* %74, align 1
  %76 = load i8*, i8** %d, align 8
  %incdec.ptr74 = getelementptr inbounds i8, i8* %76, i32 1
  store i8* %incdec.ptr74, i8** %d, align 8
  store i8 %75, i8* %76, align 1
  %77 = load i64, i64* %len, align 8
  %dec75 = add i64 %77, -1
  store i64 %dec75, i64* %len, align 8
  br label %if.end.76

if.end.76:                                        ; preds = %if.end.72, %while.end
  br label %while.cond

while.end.77:                                     ; preds = %while.cond
  %78 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags78 = getelementptr inbounds %struct.sv, %struct.sv* %78, i32 0, i32 2
  %79 = load i32, i32* %sv_flags78, align 4
  %or = or i32 %79, 536870912
  store i32 %or, i32* %sv_flags78, align 4
  br label %if.end.117

if.else.79:                                       ; preds = %land.lhs.true, %cond.end.19
  br label %while.cond.80

while.cond.80:                                    ; preds = %if.end.113, %if.else.79
  %80 = load i64, i64* %len, align 8
  %dec81 = add i64 %80, -1
  store i64 %dec81, i64* %len, align 8
  %tobool82 = icmp ne i64 %80, 0
  br i1 %tobool82, label %while.body.83, label %while.end.116

while.body.83:                                    ; preds = %while.cond.80
  %81 = load i8*, i8** %s, align 8
  %82 = load i8, i8* %81, align 1
  %conv84 = sext i8 %82 to i32
  %cmp85 = icmp sge i32 %conv84, 65
  br i1 %cmp85, label %land.lhs.true.87, label %lor.lhs.false.91

land.lhs.true.87:                                 ; preds = %while.body.83
  %83 = load i8*, i8** %s, align 8
  %84 = load i8, i8* %83, align 1
  %conv88 = sext i8 %84 to i32
  %cmp89 = icmp sle i32 %conv88, 90
  br i1 %cmp89, label %if.end.113, label %lor.lhs.false.91

lor.lhs.false.91:                                 ; preds = %land.lhs.true.87, %while.body.83
  %85 = load i8*, i8** %s, align 8
  %86 = load i8, i8* %85, align 1
  %conv92 = sext i8 %86 to i32
  %cmp93 = icmp sge i32 %conv92, 97
  br i1 %cmp93, label %land.lhs.true.95, label %lor.lhs.false.99

land.lhs.true.95:                                 ; preds = %lor.lhs.false.91
  %87 = load i8*, i8** %s, align 8
  %88 = load i8, i8* %87, align 1
  %conv96 = sext i8 %88 to i32
  %cmp97 = icmp sle i32 %conv96, 122
  br i1 %cmp97, label %if.end.113, label %lor.lhs.false.99

lor.lhs.false.99:                                 ; preds = %land.lhs.true.95, %lor.lhs.false.91
  %89 = load i8*, i8** %s, align 8
  %90 = load i8, i8* %89, align 1
  %conv100 = sext i8 %90 to i32
  %cmp101 = icmp sge i32 %conv100, 48
  br i1 %cmp101, label %land.lhs.true.103, label %lor.lhs.false.107

land.lhs.true.103:                                ; preds = %lor.lhs.false.99
  %91 = load i8*, i8** %s, align 8
  %92 = load i8, i8* %91, align 1
  %conv104 = sext i8 %92 to i32
  %cmp105 = icmp sle i32 %conv104, 57
  br i1 %cmp105, label %if.end.113, label %lor.lhs.false.107

lor.lhs.false.107:                                ; preds = %land.lhs.true.103, %lor.lhs.false.99
  %93 = load i8*, i8** %s, align 8
  %94 = load i8, i8* %93, align 1
  %conv108 = sext i8 %94 to i32
  %cmp109 = icmp eq i32 %conv108, 95
  br i1 %cmp109, label %if.end.113, label %if.then.111

if.then.111:                                      ; preds = %lor.lhs.false.107
  %95 = load i8*, i8** %d, align 8
  %incdec.ptr112 = getelementptr inbounds i8, i8* %95, i32 1
  store i8* %incdec.ptr112, i8** %d, align 8
  store i8 92, i8* %95, align 1
  br label %if.end.113

if.end.113:                                       ; preds = %if.then.111, %lor.lhs.false.107, %land.lhs.true.103, %land.lhs.true.95, %land.lhs.true.87
  %96 = load i8*, i8** %s, align 8
  %incdec.ptr114 = getelementptr inbounds i8, i8* %96, i32 1
  store i8* %incdec.ptr114, i8** %s, align 8
  %97 = load i8, i8* %96, align 1
  %98 = load i8*, i8** %d, align 8
  %incdec.ptr115 = getelementptr inbounds i8, i8* %98, i32 1
  store i8* %incdec.ptr115, i8** %d, align 8
  store i8 %97, i8* %98, align 1
  br label %while.cond.80

while.end.116:                                    ; preds = %while.cond.80
  br label %if.end.117

if.end.117:                                       ; preds = %while.end.116, %while.end.77
  %99 = load i8*, i8** %d, align 8
  store i8 0, i8* %99, align 1
  %100 = load i8*, i8** %d, align 8
  %101 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any118 = getelementptr inbounds %struct.sv, %struct.sv* %101, i32 0, i32 0
  %102 = load i8*, i8** %sv_any118, align 8
  %103 = bitcast i8* %102 to %struct.xpv*
  %xpv_pv119 = getelementptr inbounds %struct.xpv, %struct.xpv* %103, i32 0, i32 0
  %104 = load i8*, i8** %xpv_pv119, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %100 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %104 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %105 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any120 = getelementptr inbounds %struct.sv, %struct.sv* %105, i32 0, i32 0
  %106 = load i8*, i8** %sv_any120, align 8
  %107 = bitcast i8* %106 to %struct.xpv*
  %xpv_cur121 = getelementptr inbounds %struct.xpv, %struct.xpv* %107, i32 0, i32 1
  store i64 %sub.ptr.sub, i64* %xpv_cur121, align 8
  store i64 %sub.ptr.sub, i64* %tmp
  %108 = load i64, i64* %tmp
  %109 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags122 = getelementptr inbounds %struct.sv, %struct.sv* %109, i32 0, i32 2
  %110 = load i32, i32* %sv_flags122, align 4
  %and123 = and i32 %110, 1760624639
  store i32 %and123, i32* %sv_flags122, align 4
  %111 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags124 = getelementptr inbounds %struct.sv, %struct.sv* %111, i32 0, i32 2
  %112 = load i32, i32* %sv_flags124, align 4
  %or125 = or i32 %112, 67371008
  store i32 %or125, i32* %sv_flags124, align 4
  br label %if.end.127

if.else.126:                                      ; preds = %cond.end
  %113 = load %struct.sv*, %struct.sv** %targ, align 8
  %114 = load i8*, i8** %s, align 8
  %115 = load i64, i64* %len, align 8
  call void @Perl_sv_setpvn(%struct.sv* %113, i8* %114, i64 %115)
  br label %if.end.127

if.end.127:                                       ; preds = %if.else.126, %if.end.117
  %116 = load %struct.sv*, %struct.sv** %targ, align 8
  %117 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %116, %struct.sv** %117, align 8
  %118 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags128 = getelementptr inbounds %struct.sv, %struct.sv* %118, i32 0, i32 2
  %119 = load i32, i32* %sv_flags128, align 4
  %and129 = and i32 %119, 16384
  %tobool130 = icmp ne i32 %and129, 0
  br i1 %tobool130, label %if.then.131, label %if.end.133

if.then.131:                                      ; preds = %if.end.127
  %120 = load %struct.sv*, %struct.sv** %targ, align 8
  %call132 = call i32 @Perl_mg_set(%struct.sv* %120)
  br label %if.end.133

if.end.133:                                       ; preds = %if.then.131, %if.end.127
  %121 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %121, %struct.sv*** @PL_stack_sp, align 8
  %122 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %122, i32 0, i32 0
  %123 = load %struct.op*, %struct.op** %op_next, align 8
  ret %struct.op* %123
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_aslice() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %mark = alloca %struct.sv**, align 8
  %origmark = alloca i32, align 4
  %svp = alloca %struct.sv**, align 8
  %av = alloca %struct.av*, align 8
  %lval = alloca i32, align 4
  %arybase = alloca i32, align 4
  %elem = alloca i32, align 4
  %max = alloca i32, align 4
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %2 = load i32*, i32** @PL_markstack_ptr, align 8
  %incdec.ptr = getelementptr inbounds i32, i32* %2, i32 -1
  store i32* %incdec.ptr, i32** @PL_markstack_ptr, align 8
  %3 = load i32, i32* %2, align 4
  %idx.ext = sext i32 %3 to i64
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %1, i64 %idx.ext
  store %struct.sv** %add.ptr, %struct.sv*** %mark, align 8
  %4 = load %struct.sv**, %struct.sv*** %mark, align 8
  %5 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %4 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %5 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %conv = trunc i64 %sub.ptr.div to i32
  store i32 %conv, i32* %origmark, align 4
  %6 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr1 = getelementptr inbounds %struct.sv*, %struct.sv** %6, i32 -1
  store %struct.sv** %incdec.ptr1, %struct.sv*** %sp, align 8
  %7 = load %struct.sv*, %struct.sv** %6, align 8
  %8 = bitcast %struct.sv* %7 to %struct.av*
  store %struct.av* %8, %struct.av** %av, align 8
  %9 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %9, i32 0, i32 6
  %10 = load i8, i8* %op_flags, align 1
  %conv2 = zext i8 %10 to i32
  %and = and i32 %conv2, 32
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %11 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %11, i32 0, i32 7
  %12 = load i8, i8* %op_private, align 1
  %conv3 = zext i8 %12 to i32
  %and4 = and i32 %conv3, 8
  %tobool5 = icmp ne i32 %and4, 0
  br i1 %tobool5, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %lor.rhs
  %call = call i32 @Perl_is_lvalue_sub()
  %tobool6 = icmp ne i32 %call, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %lor.rhs
  %13 = phi i1 [ false, %lor.rhs ], [ %tobool6, %land.rhs ]
  br label %lor.end

lor.end:                                          ; preds = %land.end, %entry
  %14 = phi i1 [ true, %entry ], [ %13, %land.end ]
  %lor.ext = zext i1 %14 to i32
  store i32 %lor.ext, i32* %lval, align 4
  %15 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_arybase = getelementptr inbounds %struct.cop, %struct.cop* %15, i32 0, i32 12
  %16 = load i32, i32* %cop_arybase, align 4
  store i32 %16, i32* %arybase, align 4
  %17 = load %struct.av*, %struct.av** %av, align 8
  %sv_flags = getelementptr inbounds %struct.av, %struct.av* %17, i32 0, i32 2
  %18 = load i32, i32* %sv_flags, align 4
  %and7 = and i32 %18, 255
  %cmp = icmp eq i32 %and7, 10
  br i1 %cmp, label %if.then, label %if.end.73

if.then:                                          ; preds = %lor.end
  %19 = load i32, i32* %lval, align 4
  %tobool9 = icmp ne i32 %19, 0
  br i1 %tobool9, label %land.lhs.true, label %if.end.33

land.lhs.true:                                    ; preds = %if.then
  %20 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_private10 = getelementptr inbounds %struct.op, %struct.op* %20, i32 0, i32 7
  %21 = load i8, i8* %op_private10, align 1
  %conv11 = zext i8 %21 to i32
  %and12 = and i32 %conv11, 128
  %tobool13 = icmp ne i32 %and12, 0
  br i1 %tobool13, label %if.then.14, label %if.end.33

if.then.14:                                       ; preds = %land.lhs.true
  store i32 -1, i32* %max, align 4
  %22 = load %struct.sv**, %struct.sv*** %mark, align 8
  %add.ptr15 = getelementptr inbounds %struct.sv*, %struct.sv** %22, i64 1
  store %struct.sv** %add.ptr15, %struct.sv*** %svp, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then.14
  %23 = load %struct.sv**, %struct.sv*** %svp, align 8
  %24 = load %struct.sv**, %struct.sv*** %sp, align 8
  %cmp16 = icmp ule %struct.sv** %23, %24
  br i1 %cmp16, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %25 = load %struct.sv**, %struct.sv*** %svp, align 8
  %26 = load %struct.sv*, %struct.sv** %25, align 8
  store %struct.sv* %26, %struct.sv** @PL_Sv, align 8
  %27 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags18 = getelementptr inbounds %struct.sv, %struct.sv* %27, i32 0, i32 2
  %28 = load i32, i32* %sv_flags18, align 4
  %and19 = and i32 %28, 65536
  %tobool20 = icmp ne i32 %and19, 0
  br i1 %tobool20, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  %29 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %29, i32 0, i32 0
  %30 = load i8*, i8** %sv_any, align 8
  %31 = bitcast i8* %30 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %31, i32 0, i32 3
  %32 = load i64, i64* %xiv_iv, align 8
  br label %cond.end

cond.false:                                       ; preds = %for.body
  %33 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call21 = call i64 @Perl_sv_2iv(%struct.sv* %33)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %32, %cond.true ], [ %call21, %cond.false ]
  %conv22 = trunc i64 %cond to i32
  store i32 %conv22, i32* %elem, align 4
  %34 = load i32, i32* %elem, align 4
  %35 = load i32, i32* %max, align 4
  %cmp23 = icmp sgt i32 %34, %35
  br i1 %cmp23, label %if.then.25, label %if.end

if.then.25:                                       ; preds = %cond.end
  %36 = load i32, i32* %elem, align 4
  store i32 %36, i32* %max, align 4
  br label %if.end

if.end:                                           ; preds = %if.then.25, %cond.end
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %37 = load %struct.sv**, %struct.sv*** %svp, align 8
  %incdec.ptr26 = getelementptr inbounds %struct.sv*, %struct.sv** %37, i32 1
  store %struct.sv** %incdec.ptr26, %struct.sv*** %svp, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %38 = load i32, i32* %max, align 4
  %conv27 = sext i32 %38 to i64
  %39 = load %struct.av*, %struct.av** %av, align 8
  %sv_any28 = getelementptr inbounds %struct.av, %struct.av* %39, i32 0, i32 0
  %40 = load %struct.xpvav*, %struct.xpvav** %sv_any28, align 8
  %xav_max = getelementptr inbounds %struct.xpvav, %struct.xpvav* %40, i32 0, i32 2
  %41 = load i64, i64* %xav_max, align 8
  %cmp29 = icmp sgt i64 %conv27, %41
  br i1 %cmp29, label %if.then.31, label %if.end.32

if.then.31:                                       ; preds = %for.end
  %42 = load %struct.av*, %struct.av** %av, align 8
  %43 = load i32, i32* %max, align 4
  call void @Perl_av_extend(%struct.av* %42, i32 %43)
  br label %if.end.32

if.end.32:                                        ; preds = %if.then.31, %for.end
  br label %if.end.33

if.end.33:                                        ; preds = %if.end.32, %land.lhs.true, %if.then
  br label %while.cond

while.cond:                                       ; preds = %cond.end.71, %if.end.33
  %44 = load %struct.sv**, %struct.sv*** %mark, align 8
  %incdec.ptr34 = getelementptr inbounds %struct.sv*, %struct.sv** %44, i32 1
  store %struct.sv** %incdec.ptr34, %struct.sv*** %mark, align 8
  %45 = load %struct.sv**, %struct.sv*** %sp, align 8
  %cmp35 = icmp ule %struct.sv** %incdec.ptr34, %45
  br i1 %cmp35, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %46 = load %struct.sv**, %struct.sv*** %mark, align 8
  %47 = load %struct.sv*, %struct.sv** %46, align 8
  store %struct.sv* %47, %struct.sv** @PL_Sv, align 8
  %48 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags37 = getelementptr inbounds %struct.sv, %struct.sv* %48, i32 0, i32 2
  %49 = load i32, i32* %sv_flags37, align 4
  %and38 = and i32 %49, 65536
  %tobool39 = icmp ne i32 %and38, 0
  br i1 %tobool39, label %cond.true.40, label %cond.false.43

cond.true.40:                                     ; preds = %while.body
  %50 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any41 = getelementptr inbounds %struct.sv, %struct.sv* %50, i32 0, i32 0
  %51 = load i8*, i8** %sv_any41, align 8
  %52 = bitcast i8* %51 to %struct.xpviv*
  %xiv_iv42 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %52, i32 0, i32 3
  %53 = load i64, i64* %xiv_iv42, align 8
  br label %cond.end.45

cond.false.43:                                    ; preds = %while.body
  %54 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call44 = call i64 @Perl_sv_2iv(%struct.sv* %54)
  br label %cond.end.45

cond.end.45:                                      ; preds = %cond.false.43, %cond.true.40
  %cond46 = phi i64 [ %53, %cond.true.40 ], [ %call44, %cond.false.43 ]
  %conv47 = trunc i64 %cond46 to i32
  store i32 %conv47, i32* %elem, align 4
  %55 = load i32, i32* %elem, align 4
  %cmp48 = icmp sgt i32 %55, 0
  br i1 %cmp48, label %if.then.50, label %if.end.51

if.then.50:                                       ; preds = %cond.end.45
  %56 = load i32, i32* %arybase, align 4
  %57 = load i32, i32* %elem, align 4
  %sub = sub nsw i32 %57, %56
  store i32 %sub, i32* %elem, align 4
  br label %if.end.51

if.end.51:                                        ; preds = %if.then.50, %cond.end.45
  %58 = load %struct.av*, %struct.av** %av, align 8
  %59 = load i32, i32* %elem, align 4
  %60 = load i32, i32* %lval, align 4
  %call52 = call %struct.sv** @Perl_av_fetch(%struct.av* %58, i32 %59, i32 %60)
  store %struct.sv** %call52, %struct.sv*** %svp, align 8
  %61 = load i32, i32* %lval, align 4
  %tobool53 = icmp ne i32 %61, 0
  br i1 %tobool53, label %if.then.54, label %if.end.67

if.then.54:                                       ; preds = %if.end.51
  %62 = load %struct.sv**, %struct.sv*** %svp, align 8
  %tobool55 = icmp ne %struct.sv** %62, null
  br i1 %tobool55, label %lor.lhs.false, label %if.then.58

lor.lhs.false:                                    ; preds = %if.then.54
  %63 = load %struct.sv**, %struct.sv*** %svp, align 8
  %64 = load %struct.sv*, %struct.sv** %63, align 8
  %cmp56 = icmp eq %struct.sv* %64, @PL_sv_undef
  br i1 %cmp56, label %if.then.58, label %if.end.60

if.then.58:                                       ; preds = %lor.lhs.false, %if.then.54
  %65 = load i32, i32* %elem, align 4
  %call59 = call %struct.op* (i8*, ...) @Perl_die(i8* getelementptr inbounds ([0 x i8], [0 x i8]* @PL_no_aelem, i32 0, i32 0), i32 %65)
  store %struct.op* %call59, %struct.op** %retval
  br label %return

if.end.60:                                        ; preds = %lor.lhs.false
  %66 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_private61 = getelementptr inbounds %struct.op, %struct.op* %66, i32 0, i32 7
  %67 = load i8, i8* %op_private61, align 1
  %conv62 = zext i8 %67 to i32
  %and63 = and i32 %conv62, 128
  %tobool64 = icmp ne i32 %and63, 0
  br i1 %tobool64, label %if.then.65, label %if.end.66

if.then.65:                                       ; preds = %if.end.60
  %68 = load %struct.av*, %struct.av** %av, align 8
  %69 = load i32, i32* %elem, align 4
  %70 = load %struct.sv**, %struct.sv*** %svp, align 8
  call void @Perl_save_aelem(%struct.av* %68, i32 %69, %struct.sv** %70)
  br label %if.end.66

if.end.66:                                        ; preds = %if.then.65, %if.end.60
  br label %if.end.67

if.end.67:                                        ; preds = %if.end.66, %if.end.51
  %71 = load %struct.sv**, %struct.sv*** %svp, align 8
  %tobool68 = icmp ne %struct.sv** %71, null
  br i1 %tobool68, label %cond.true.69, label %cond.false.70

cond.true.69:                                     ; preds = %if.end.67
  %72 = load %struct.sv**, %struct.sv*** %svp, align 8
  %73 = load %struct.sv*, %struct.sv** %72, align 8
  br label %cond.end.71

cond.false.70:                                    ; preds = %if.end.67
  br label %cond.end.71

cond.end.71:                                      ; preds = %cond.false.70, %cond.true.69
  %cond72 = phi %struct.sv* [ %73, %cond.true.69 ], [ @PL_sv_undef, %cond.false.70 ]
  %74 = load %struct.sv**, %struct.sv*** %mark, align 8
  store %struct.sv* %cond72, %struct.sv** %74, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  br label %if.end.73

if.end.73:                                        ; preds = %while.end, %lor.end
  %75 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags74 = getelementptr inbounds %struct.op, %struct.op* %75, i32 0, i32 6
  %76 = load i8, i8* %op_flags74, align 1
  %conv75 = zext i8 %76 to i32
  %and76 = and i32 %conv75, 3
  %tobool77 = icmp ne i32 %and76, 0
  br i1 %tobool77, label %cond.true.78, label %cond.false.85

cond.true.78:                                     ; preds = %if.end.73
  %77 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags79 = getelementptr inbounds %struct.op, %struct.op* %77, i32 0, i32 6
  %78 = load i8, i8* %op_flags79, align 1
  %conv80 = zext i8 %78 to i32
  %and81 = and i32 %conv80, 3
  %cmp82 = icmp eq i32 %and81, 3
  %cond84 = select i1 %cmp82, i32 1, i32 0
  br label %cond.end.87

cond.false.85:                                    ; preds = %if.end.73
  %call86 = call i32 @Perl_dowantarray()
  br label %cond.end.87

cond.end.87:                                      ; preds = %cond.false.85, %cond.true.78
  %cond88 = phi i32 [ %cond84, %cond.true.78 ], [ %call86, %cond.false.85 ]
  %cmp89 = icmp ne i32 %cond88, 1
  br i1 %cmp89, label %if.then.91, label %if.end.103

if.then.91:                                       ; preds = %cond.end.87
  %79 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %80 = load i32, i32* %origmark, align 4
  %idx.ext92 = sext i32 %80 to i64
  %add.ptr93 = getelementptr inbounds %struct.sv*, %struct.sv** %79, i64 %idx.ext92
  store %struct.sv** %add.ptr93, %struct.sv*** %mark, align 8
  %81 = load %struct.sv**, %struct.sv*** %sp, align 8
  %82 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %83 = load i32, i32* %origmark, align 4
  %idx.ext94 = sext i32 %83 to i64
  %add.ptr95 = getelementptr inbounds %struct.sv*, %struct.sv** %82, i64 %idx.ext94
  %cmp96 = icmp ugt %struct.sv** %81, %add.ptr95
  br i1 %cmp96, label %cond.true.98, label %cond.false.99

cond.true.98:                                     ; preds = %if.then.91
  %84 = load %struct.sv**, %struct.sv*** %sp, align 8
  %85 = load %struct.sv*, %struct.sv** %84, align 8
  br label %cond.end.100

cond.false.99:                                    ; preds = %if.then.91
  br label %cond.end.100

cond.end.100:                                     ; preds = %cond.false.99, %cond.true.98
  %cond101 = phi %struct.sv* [ %85, %cond.true.98 ], [ @PL_sv_undef, %cond.false.99 ]
  %86 = load %struct.sv**, %struct.sv*** %mark, align 8
  %incdec.ptr102 = getelementptr inbounds %struct.sv*, %struct.sv** %86, i32 1
  store %struct.sv** %incdec.ptr102, %struct.sv*** %mark, align 8
  store %struct.sv* %cond101, %struct.sv** %incdec.ptr102, align 8
  %87 = load %struct.sv**, %struct.sv*** %mark, align 8
  store %struct.sv** %87, %struct.sv*** %sp, align 8
  br label %if.end.103

if.end.103:                                       ; preds = %cond.end.100, %cond.end.87
  %88 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %88, %struct.sv*** @PL_stack_sp, align 8
  %89 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %89, i32 0, i32 0
  %90 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %90, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.103, %if.then.58
  %91 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %91
}

declare void @Perl_av_extend(%struct.av*, i32) #1

declare void @Perl_save_aelem(%struct.av*, i32, %struct.sv**) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_each() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %hash = alloca %struct.hv*, align 8
  %entry1 = alloca %struct.he*, align 8
  %gimme = alloca i32, align 4
  %realhv = alloca i32, align 4
  %sv = alloca %struct.sv*, align 8
  %val = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %1, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %2 = load %struct.sv*, %struct.sv** %1, align 8
  %3 = bitcast %struct.sv* %2 to %struct.hv*
  store %struct.hv* %3, %struct.hv** %hash, align 8
  %4 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %4, i32 0, i32 6
  %5 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %5 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end.19

cond.false:                                       ; preds = %entry
  %6 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags3 = getelementptr inbounds %struct.op, %struct.op* %6, i32 0, i32 6
  %7 = load i8, i8* %op_flags3, align 1
  %conv4 = zext i8 %7 to i32
  %and5 = and i32 %conv4, 3
  %cmp6 = icmp eq i32 %and5, 2
  br i1 %cmp6, label %cond.true.8, label %cond.false.9

cond.true.8:                                      ; preds = %cond.false
  br label %cond.end.17

cond.false.9:                                     ; preds = %cond.false
  %8 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags10 = getelementptr inbounds %struct.op, %struct.op* %8, i32 0, i32 6
  %9 = load i8, i8* %op_flags10, align 1
  %conv11 = zext i8 %9 to i32
  %and12 = and i32 %conv11, 3
  %cmp13 = icmp eq i32 %and12, 3
  br i1 %cmp13, label %cond.true.15, label %cond.false.16

cond.true.15:                                     ; preds = %cond.false.9
  br label %cond.end

cond.false.16:                                    ; preds = %cond.false.9
  %call = call i32 @Perl_block_gimme()
  br label %cond.end

cond.end:                                         ; preds = %cond.false.16, %cond.true.15
  %cond = phi i32 [ 1, %cond.true.15 ], [ %call, %cond.false.16 ]
  br label %cond.end.17

cond.end.17:                                      ; preds = %cond.end, %cond.true.8
  %cond18 = phi i32 [ 0, %cond.true.8 ], [ %cond, %cond.end ]
  br label %cond.end.19

cond.end.19:                                      ; preds = %cond.end.17, %cond.true
  %cond20 = phi i32 [ 128, %cond.true ], [ %cond18, %cond.end.17 ]
  store i32 %cond20, i32* %gimme, align 4
  %10 = load %struct.hv*, %struct.hv** %hash, align 8
  %sv_flags = getelementptr inbounds %struct.hv, %struct.hv* %10, i32 0, i32 2
  %11 = load i32, i32* %sv_flags, align 4
  %and21 = and i32 %11, 255
  %cmp22 = icmp eq i32 %and21, 11
  %conv23 = zext i1 %cmp22 to i32
  store i32 %conv23, i32* %realhv, align 4
  %12 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %12, %struct.sv*** @PL_stack_sp, align 8
  %13 = load i32, i32* %realhv, align 4
  %tobool = icmp ne i32 %13, 0
  br i1 %tobool, label %cond.true.24, label %cond.false.26

cond.true.24:                                     ; preds = %cond.end.19
  %14 = load %struct.hv*, %struct.hv** %hash, align 8
  %call25 = call %struct.he* @Perl_hv_iternext(%struct.hv* %14)
  br label %cond.end.28

cond.false.26:                                    ; preds = %cond.end.19
  %15 = load %struct.hv*, %struct.hv** %hash, align 8
  %16 = bitcast %struct.hv* %15 to %struct.av*
  %call27 = call %struct.he* @Perl_avhv_iternext(%struct.av* %16)
  br label %cond.end.28

cond.end.28:                                      ; preds = %cond.false.26, %cond.true.24
  %cond29 = phi %struct.he* [ %call25, %cond.true.24 ], [ %call27, %cond.false.26 ]
  store %struct.he* %cond29, %struct.he** %entry1, align 8
  %17 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %17, %struct.sv*** %sp, align 8
  %18 = load %struct.sv**, %struct.sv*** @PL_stack_max, align 8
  %19 = load %struct.sv**, %struct.sv*** %sp, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %18 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %19 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %cmp30 = icmp slt i64 %sub.ptr.div, 2
  br i1 %cmp30, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end.28
  %20 = load %struct.sv**, %struct.sv*** %sp, align 8
  %21 = load %struct.sv**, %struct.sv*** %sp, align 8
  %call32 = call %struct.sv** @Perl_stack_grow(%struct.sv** %20, %struct.sv** %21, i32 2)
  store %struct.sv** %call32, %struct.sv*** %sp, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end.28
  %22 = load %struct.he*, %struct.he** %entry1, align 8
  %tobool33 = icmp ne %struct.he* %22, null
  br i1 %tobool33, label %if.then.34, label %if.else

if.then.34:                                       ; preds = %if.end
  %23 = load %struct.he*, %struct.he** %entry1, align 8
  %call35 = call %struct.sv* @Perl_hv_iterkeysv(%struct.he* %23)
  store %struct.sv* %call35, %struct.sv** %sv, align 8
  %24 = load %struct.sv*, %struct.sv** %sv, align 8
  %25 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr36 = getelementptr inbounds %struct.sv*, %struct.sv** %25, i32 1
  store %struct.sv** %incdec.ptr36, %struct.sv*** %sp, align 8
  store %struct.sv* %24, %struct.sv** %incdec.ptr36, align 8
  %26 = load i32, i32* %gimme, align 4
  %cmp37 = icmp eq i32 %26, 1
  br i1 %cmp37, label %if.then.39, label %if.end.48

if.then.39:                                       ; preds = %if.then.34
  %27 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %27, %struct.sv*** @PL_stack_sp, align 8
  %28 = load i32, i32* %realhv, align 4
  %tobool40 = icmp ne i32 %28, 0
  br i1 %tobool40, label %cond.true.41, label %cond.false.43

cond.true.41:                                     ; preds = %if.then.39
  %29 = load %struct.hv*, %struct.hv** %hash, align 8
  %30 = load %struct.he*, %struct.he** %entry1, align 8
  %call42 = call %struct.sv* @Perl_hv_iterval(%struct.hv* %29, %struct.he* %30)
  br label %cond.end.45

cond.false.43:                                    ; preds = %if.then.39
  %31 = load %struct.hv*, %struct.hv** %hash, align 8
  %32 = bitcast %struct.hv* %31 to %struct.av*
  %33 = load %struct.he*, %struct.he** %entry1, align 8
  %call44 = call %struct.sv* @Perl_avhv_iterval(%struct.av* %32, %struct.he* %33)
  br label %cond.end.45

cond.end.45:                                      ; preds = %cond.false.43, %cond.true.41
  %cond46 = phi %struct.sv* [ %call42, %cond.true.41 ], [ %call44, %cond.false.43 ]
  store %struct.sv* %cond46, %struct.sv** %val, align 8
  %34 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %34, %struct.sv*** %sp, align 8
  %35 = load %struct.sv*, %struct.sv** %val, align 8
  %36 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr47 = getelementptr inbounds %struct.sv*, %struct.sv** %36, i32 1
  store %struct.sv** %incdec.ptr47, %struct.sv*** %sp, align 8
  store %struct.sv* %35, %struct.sv** %incdec.ptr47, align 8
  br label %if.end.48

if.end.48:                                        ; preds = %cond.end.45, %if.then.34
  br label %if.end.54

if.else:                                          ; preds = %if.end
  %37 = load i32, i32* %gimme, align 4
  %cmp49 = icmp eq i32 %37, 0
  br i1 %cmp49, label %if.then.51, label %if.end.53

if.then.51:                                       ; preds = %if.else
  %38 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr52 = getelementptr inbounds %struct.sv*, %struct.sv** %38, i32 1
  store %struct.sv** %incdec.ptr52, %struct.sv*** %sp, align 8
  store %struct.sv* @PL_sv_undef, %struct.sv** %incdec.ptr52, align 8
  %39 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %39, %struct.sv*** @PL_stack_sp, align 8
  %40 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %40, i32 0, i32 0
  %41 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %41, %struct.op** %retval
  br label %return

if.end.53:                                        ; preds = %if.else
  br label %if.end.54

if.end.54:                                        ; preds = %if.end.53, %if.end.48
  %42 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %42, %struct.sv*** @PL_stack_sp, align 8
  %43 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next55 = getelementptr inbounds %struct.op, %struct.op* %43, i32 0, i32 0
  %44 = load %struct.op*, %struct.op** %op_next55, align 8
  store %struct.op* %44, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.54, %if.then.51
  %45 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %45
}

declare %struct.he* @Perl_hv_iternext(%struct.hv*) #1

declare %struct.he* @Perl_avhv_iternext(%struct.av*) #1

declare %struct.sv* @Perl_hv_iterkeysv(%struct.he*) #1

declare %struct.sv* @Perl_hv_iterval(%struct.hv*, %struct.he*) #1

declare %struct.sv* @Perl_avhv_iterval(%struct.av*, %struct.he*) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_values() #0 {
entry:
  %call = call %struct.op* @Perl_do_kv()
  ret %struct.op* %call
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_keys() #0 {
entry:
  %call = call %struct.op* @Perl_do_kv()
  ret %struct.op* %call
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_delete() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %gimme = alloca i32, align 4
  %discard = alloca i32, align 4
  %sv = alloca %struct.sv*, align 8
  %hv = alloca %struct.hv*, align 8
  %mark = alloca %struct.sv**, align 8
  %origmark = alloca i32, align 4
  %hvtype = alloca i32, align 4
  %keysv = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 6
  %2 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 3
  %cmp = icmp eq i32 %and, 1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end.18

cond.false:                                       ; preds = %entry
  %3 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags2 = getelementptr inbounds %struct.op, %struct.op* %3, i32 0, i32 6
  %4 = load i8, i8* %op_flags2, align 1
  %conv3 = zext i8 %4 to i32
  %and4 = and i32 %conv3, 3
  %cmp5 = icmp eq i32 %and4, 2
  br i1 %cmp5, label %cond.true.7, label %cond.false.8

cond.true.7:                                      ; preds = %cond.false
  br label %cond.end.16

cond.false.8:                                     ; preds = %cond.false
  %5 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags9 = getelementptr inbounds %struct.op, %struct.op* %5, i32 0, i32 6
  %6 = load i8, i8* %op_flags9, align 1
  %conv10 = zext i8 %6 to i32
  %and11 = and i32 %conv10, 3
  %cmp12 = icmp eq i32 %and11, 3
  br i1 %cmp12, label %cond.true.14, label %cond.false.15

cond.true.14:                                     ; preds = %cond.false.8
  br label %cond.end

cond.false.15:                                    ; preds = %cond.false.8
  %call = call i32 @Perl_block_gimme()
  br label %cond.end

cond.end:                                         ; preds = %cond.false.15, %cond.true.14
  %cond = phi i32 [ 1, %cond.true.14 ], [ %call, %cond.false.15 ]
  br label %cond.end.16

cond.end.16:                                      ; preds = %cond.end, %cond.true.7
  %cond17 = phi i32 [ 0, %cond.true.7 ], [ %cond, %cond.end ]
  br label %cond.end.18

cond.end.18:                                      ; preds = %cond.end.16, %cond.true
  %cond19 = phi i32 [ 128, %cond.true ], [ %cond17, %cond.end.16 ]
  store i32 %cond19, i32* %gimme, align 4
  %7 = load i32, i32* %gimme, align 4
  %cmp20 = icmp eq i32 %7, 128
  %cond22 = select i1 %cmp20, i32 2, i32 0
  store i32 %cond22, i32* %discard, align 4
  %8 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %8, i32 0, i32 7
  %9 = load i8, i8* %op_private, align 1
  %conv23 = zext i8 %9 to i32
  %and24 = and i32 %conv23, 64
  %tobool = icmp ne i32 %and24, 0
  br i1 %tobool, label %if.then, label %if.else.105

if.then:                                          ; preds = %cond.end.18
  %10 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %11 = load i32*, i32** @PL_markstack_ptr, align 8
  %incdec.ptr = getelementptr inbounds i32, i32* %11, i32 -1
  store i32* %incdec.ptr, i32** @PL_markstack_ptr, align 8
  %12 = load i32, i32* %11, align 4
  %idx.ext = sext i32 %12 to i64
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %10, i64 %idx.ext
  store %struct.sv** %add.ptr, %struct.sv*** %mark, align 8
  %13 = load %struct.sv**, %struct.sv*** %mark, align 8
  %14 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %13 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %14 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %conv25 = trunc i64 %sub.ptr.div to i32
  store i32 %conv25, i32* %origmark, align 4
  %15 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr26 = getelementptr inbounds %struct.sv*, %struct.sv** %15, i32 -1
  store %struct.sv** %incdec.ptr26, %struct.sv*** %sp, align 8
  %16 = load %struct.sv*, %struct.sv** %15, align 8
  %17 = bitcast %struct.sv* %16 to %struct.hv*
  store %struct.hv* %17, %struct.hv** %hv, align 8
  %18 = load %struct.hv*, %struct.hv** %hv, align 8
  %sv_flags = getelementptr inbounds %struct.hv, %struct.hv* %18, i32 0, i32 2
  %19 = load i32, i32* %sv_flags, align 4
  %and27 = and i32 %19, 255
  store i32 %and27, i32* %hvtype, align 4
  %20 = load i32, i32* %hvtype, align 4
  %cmp28 = icmp eq i32 %20, 11
  br i1 %cmp28, label %if.then.30, label %if.else

if.then.30:                                       ; preds = %if.then
  br label %while.cond

while.cond:                                       ; preds = %cond.end.38, %if.then.30
  %21 = load %struct.sv**, %struct.sv*** %mark, align 8
  %incdec.ptr31 = getelementptr inbounds %struct.sv*, %struct.sv** %21, i32 1
  store %struct.sv** %incdec.ptr31, %struct.sv*** %mark, align 8
  %22 = load %struct.sv**, %struct.sv*** %sp, align 8
  %cmp32 = icmp ule %struct.sv** %incdec.ptr31, %22
  br i1 %cmp32, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %23 = load %struct.hv*, %struct.hv** %hv, align 8
  %24 = load %struct.sv**, %struct.sv*** %mark, align 8
  %25 = load %struct.sv*, %struct.sv** %24, align 8
  %26 = load i32, i32* %discard, align 4
  %call34 = call %struct.sv* @Perl_hv_delete_ent(%struct.hv* %23, %struct.sv* %25, i32 %26, i32 0)
  store %struct.sv* %call34, %struct.sv** %sv, align 8
  %27 = load %struct.sv*, %struct.sv** %sv, align 8
  %tobool35 = icmp ne %struct.sv* %27, null
  br i1 %tobool35, label %cond.true.36, label %cond.false.37

cond.true.36:                                     ; preds = %while.body
  %28 = load %struct.sv*, %struct.sv** %sv, align 8
  br label %cond.end.38

cond.false.37:                                    ; preds = %while.body
  br label %cond.end.38

cond.end.38:                                      ; preds = %cond.false.37, %cond.true.36
  %cond39 = phi %struct.sv* [ %28, %cond.true.36 ], [ @PL_sv_undef, %cond.false.37 ]
  %29 = load %struct.sv**, %struct.sv*** %mark, align 8
  store %struct.sv* %cond39, %struct.sv** %29, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  br label %if.end.85

if.else:                                          ; preds = %if.then
  %30 = load i32, i32* %hvtype, align 4
  %cmp40 = icmp eq i32 %30, 10
  br i1 %cmp40, label %if.then.42, label %if.else.82

if.then.42:                                       ; preds = %if.else
  %31 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags43 = getelementptr inbounds %struct.op, %struct.op* %31, i32 0, i32 6
  %32 = load i8, i8* %op_flags43, align 1
  %conv44 = zext i8 %32 to i32
  %and45 = and i32 %conv44, 128
  %tobool46 = icmp ne i32 %and45, 0
  br i1 %tobool46, label %if.then.47, label %if.else.69

if.then.47:                                       ; preds = %if.then.42
  br label %while.cond.48

while.cond.48:                                    ; preds = %cond.end.66, %if.then.47
  %33 = load %struct.sv**, %struct.sv*** %mark, align 8
  %incdec.ptr49 = getelementptr inbounds %struct.sv*, %struct.sv** %33, i32 1
  store %struct.sv** %incdec.ptr49, %struct.sv*** %mark, align 8
  %34 = load %struct.sv**, %struct.sv*** %sp, align 8
  %cmp50 = icmp ule %struct.sv** %incdec.ptr49, %34
  br i1 %cmp50, label %while.body.52, label %while.end.68

while.body.52:                                    ; preds = %while.cond.48
  %35 = load %struct.hv*, %struct.hv** %hv, align 8
  %36 = bitcast %struct.hv* %35 to %struct.av*
  %37 = load %struct.sv**, %struct.sv*** %mark, align 8
  %38 = load %struct.sv*, %struct.sv** %37, align 8
  %sv_flags53 = getelementptr inbounds %struct.sv, %struct.sv* %38, i32 0, i32 2
  %39 = load i32, i32* %sv_flags53, align 4
  %and54 = and i32 %39, 65536
  %tobool55 = icmp ne i32 %and54, 0
  br i1 %tobool55, label %cond.true.56, label %cond.false.57

cond.true.56:                                     ; preds = %while.body.52
  %40 = load %struct.sv**, %struct.sv*** %mark, align 8
  %41 = load %struct.sv*, %struct.sv** %40, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %41, i32 0, i32 0
  %42 = load i8*, i8** %sv_any, align 8
  %43 = bitcast i8* %42 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %43, i32 0, i32 3
  %44 = load i64, i64* %xiv_iv, align 8
  br label %cond.end.59

cond.false.57:                                    ; preds = %while.body.52
  %45 = load %struct.sv**, %struct.sv*** %mark, align 8
  %46 = load %struct.sv*, %struct.sv** %45, align 8
  %call58 = call i64 @Perl_sv_2iv(%struct.sv* %46)
  br label %cond.end.59

cond.end.59:                                      ; preds = %cond.false.57, %cond.true.56
  %cond60 = phi i64 [ %44, %cond.true.56 ], [ %call58, %cond.false.57 ]
  %conv61 = trunc i64 %cond60 to i32
  %47 = load i32, i32* %discard, align 4
  %call62 = call %struct.sv* @Perl_av_delete(%struct.av* %36, i32 %conv61, i32 %47)
  store %struct.sv* %call62, %struct.sv** %sv, align 8
  %48 = load %struct.sv*, %struct.sv** %sv, align 8
  %tobool63 = icmp ne %struct.sv* %48, null
  br i1 %tobool63, label %cond.true.64, label %cond.false.65

cond.true.64:                                     ; preds = %cond.end.59
  %49 = load %struct.sv*, %struct.sv** %sv, align 8
  br label %cond.end.66

cond.false.65:                                    ; preds = %cond.end.59
  br label %cond.end.66

cond.end.66:                                      ; preds = %cond.false.65, %cond.true.64
  %cond67 = phi %struct.sv* [ %49, %cond.true.64 ], [ @PL_sv_undef, %cond.false.65 ]
  %50 = load %struct.sv**, %struct.sv*** %mark, align 8
  store %struct.sv* %cond67, %struct.sv** %50, align 8
  br label %while.cond.48

while.end.68:                                     ; preds = %while.cond.48
  br label %if.end

if.else.69:                                       ; preds = %if.then.42
  br label %while.cond.70

while.cond.70:                                    ; preds = %cond.end.79, %if.else.69
  %51 = load %struct.sv**, %struct.sv*** %mark, align 8
  %incdec.ptr71 = getelementptr inbounds %struct.sv*, %struct.sv** %51, i32 1
  store %struct.sv** %incdec.ptr71, %struct.sv*** %mark, align 8
  %52 = load %struct.sv**, %struct.sv*** %sp, align 8
  %cmp72 = icmp ule %struct.sv** %incdec.ptr71, %52
  br i1 %cmp72, label %while.body.74, label %while.end.81

while.body.74:                                    ; preds = %while.cond.70
  %53 = load %struct.hv*, %struct.hv** %hv, align 8
  %54 = bitcast %struct.hv* %53 to %struct.av*
  %55 = load %struct.sv**, %struct.sv*** %mark, align 8
  %56 = load %struct.sv*, %struct.sv** %55, align 8
  %57 = load i32, i32* %discard, align 4
  %call75 = call %struct.sv* @Perl_avhv_delete_ent(%struct.av* %54, %struct.sv* %56, i32 %57, i32 0)
  store %struct.sv* %call75, %struct.sv** %sv, align 8
  %58 = load %struct.sv*, %struct.sv** %sv, align 8
  %tobool76 = icmp ne %struct.sv* %58, null
  br i1 %tobool76, label %cond.true.77, label %cond.false.78

cond.true.77:                                     ; preds = %while.body.74
  %59 = load %struct.sv*, %struct.sv** %sv, align 8
  br label %cond.end.79

cond.false.78:                                    ; preds = %while.body.74
  br label %cond.end.79

cond.end.79:                                      ; preds = %cond.false.78, %cond.true.77
  %cond80 = phi %struct.sv* [ %59, %cond.true.77 ], [ @PL_sv_undef, %cond.false.78 ]
  %60 = load %struct.sv**, %struct.sv*** %mark, align 8
  store %struct.sv* %cond80, %struct.sv** %60, align 8
  br label %while.cond.70

while.end.81:                                     ; preds = %while.cond.70
  br label %if.end

if.end:                                           ; preds = %while.end.81, %while.end.68
  br label %if.end.84

if.else.82:                                       ; preds = %if.else
  %call83 = call %struct.op* (i8*, ...) @Perl_die(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.38, i32 0, i32 0))
  store %struct.op* %call83, %struct.op** %retval
  br label %return

if.end.84:                                        ; preds = %if.end
  br label %if.end.85

if.end.85:                                        ; preds = %if.end.84, %while.end
  %61 = load i32, i32* %discard, align 4
  %tobool86 = icmp ne i32 %61, 0
  br i1 %tobool86, label %if.then.87, label %if.else.90

if.then.87:                                       ; preds = %if.end.85
  %62 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %63 = load i32, i32* %origmark, align 4
  %idx.ext88 = sext i32 %63 to i64
  %add.ptr89 = getelementptr inbounds %struct.sv*, %struct.sv** %62, i64 %idx.ext88
  store %struct.sv** %add.ptr89, %struct.sv*** %sp, align 8
  br label %if.end.104

if.else.90:                                       ; preds = %if.end.85
  %64 = load i32, i32* %gimme, align 4
  %cmp91 = icmp eq i32 %64, 0
  br i1 %cmp91, label %if.then.93, label %if.end.103

if.then.93:                                       ; preds = %if.else.90
  %65 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %66 = load i32, i32* %origmark, align 4
  %idx.ext94 = sext i32 %66 to i64
  %add.ptr95 = getelementptr inbounds %struct.sv*, %struct.sv** %65, i64 %idx.ext94
  store %struct.sv** %add.ptr95, %struct.sv*** %mark, align 8
  %67 = load %struct.sv**, %struct.sv*** %sp, align 8
  %68 = load %struct.sv**, %struct.sv*** %mark, align 8
  %cmp96 = icmp ugt %struct.sv** %67, %68
  br i1 %cmp96, label %if.then.98, label %if.else.100

if.then.98:                                       ; preds = %if.then.93
  %69 = load %struct.sv**, %struct.sv*** %sp, align 8
  %70 = load %struct.sv*, %struct.sv** %69, align 8
  %71 = load %struct.sv**, %struct.sv*** %mark, align 8
  %incdec.ptr99 = getelementptr inbounds %struct.sv*, %struct.sv** %71, i32 1
  store %struct.sv** %incdec.ptr99, %struct.sv*** %mark, align 8
  store %struct.sv* %70, %struct.sv** %incdec.ptr99, align 8
  br label %if.end.102

if.else.100:                                      ; preds = %if.then.93
  %72 = load %struct.sv**, %struct.sv*** %mark, align 8
  %incdec.ptr101 = getelementptr inbounds %struct.sv*, %struct.sv** %72, i32 1
  store %struct.sv** %incdec.ptr101, %struct.sv*** %mark, align 8
  store %struct.sv* @PL_sv_undef, %struct.sv** %incdec.ptr101, align 8
  br label %if.end.102

if.end.102:                                       ; preds = %if.else.100, %if.then.98
  %73 = load %struct.sv**, %struct.sv*** %mark, align 8
  store %struct.sv** %73, %struct.sv*** %sp, align 8
  br label %if.end.103

if.end.103:                                       ; preds = %if.end.102, %if.else.90
  br label %if.end.104

if.end.104:                                       ; preds = %if.end.103, %if.then.87
  br label %if.end.151

if.else.105:                                      ; preds = %cond.end.18
  %74 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr106 = getelementptr inbounds %struct.sv*, %struct.sv** %74, i32 -1
  store %struct.sv** %incdec.ptr106, %struct.sv*** %sp, align 8
  %75 = load %struct.sv*, %struct.sv** %74, align 8
  store %struct.sv* %75, %struct.sv** %keysv, align 8
  %76 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr107 = getelementptr inbounds %struct.sv*, %struct.sv** %76, i32 -1
  store %struct.sv** %incdec.ptr107, %struct.sv*** %sp, align 8
  %77 = load %struct.sv*, %struct.sv** %76, align 8
  %78 = bitcast %struct.sv* %77 to %struct.hv*
  store %struct.hv* %78, %struct.hv** %hv, align 8
  %79 = load %struct.hv*, %struct.hv** %hv, align 8
  %sv_flags108 = getelementptr inbounds %struct.hv, %struct.hv* %79, i32 0, i32 2
  %80 = load i32, i32* %sv_flags108, align 4
  %and109 = and i32 %80, 255
  %cmp110 = icmp eq i32 %and109, 11
  br i1 %cmp110, label %if.then.112, label %if.else.114

if.then.112:                                      ; preds = %if.else.105
  %81 = load %struct.hv*, %struct.hv** %hv, align 8
  %82 = load %struct.sv*, %struct.sv** %keysv, align 8
  %83 = load i32, i32* %discard, align 4
  %call113 = call %struct.sv* @Perl_hv_delete_ent(%struct.hv* %81, %struct.sv* %82, i32 %83, i32 0)
  store %struct.sv* %call113, %struct.sv** %sv, align 8
  br label %if.end.143

if.else.114:                                      ; preds = %if.else.105
  %84 = load %struct.hv*, %struct.hv** %hv, align 8
  %sv_flags115 = getelementptr inbounds %struct.hv, %struct.hv* %84, i32 0, i32 2
  %85 = load i32, i32* %sv_flags115, align 4
  %and116 = and i32 %85, 255
  %cmp117 = icmp eq i32 %and116, 10
  br i1 %cmp117, label %if.then.119, label %if.else.140

if.then.119:                                      ; preds = %if.else.114
  %86 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags120 = getelementptr inbounds %struct.op, %struct.op* %86, i32 0, i32 6
  %87 = load i8, i8* %op_flags120, align 1
  %conv121 = zext i8 %87 to i32
  %and122 = and i32 %conv121, 128
  %tobool123 = icmp ne i32 %and122, 0
  br i1 %tobool123, label %if.then.124, label %if.else.137

if.then.124:                                      ; preds = %if.then.119
  %88 = load %struct.hv*, %struct.hv** %hv, align 8
  %89 = bitcast %struct.hv* %88 to %struct.av*
  %90 = load %struct.sv*, %struct.sv** %keysv, align 8
  %sv_flags125 = getelementptr inbounds %struct.sv, %struct.sv* %90, i32 0, i32 2
  %91 = load i32, i32* %sv_flags125, align 4
  %and126 = and i32 %91, 65536
  %tobool127 = icmp ne i32 %and126, 0
  br i1 %tobool127, label %cond.true.128, label %cond.false.131

cond.true.128:                                    ; preds = %if.then.124
  %92 = load %struct.sv*, %struct.sv** %keysv, align 8
  %sv_any129 = getelementptr inbounds %struct.sv, %struct.sv* %92, i32 0, i32 0
  %93 = load i8*, i8** %sv_any129, align 8
  %94 = bitcast i8* %93 to %struct.xpviv*
  %xiv_iv130 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %94, i32 0, i32 3
  %95 = load i64, i64* %xiv_iv130, align 8
  br label %cond.end.133

cond.false.131:                                   ; preds = %if.then.124
  %96 = load %struct.sv*, %struct.sv** %keysv, align 8
  %call132 = call i64 @Perl_sv_2iv(%struct.sv* %96)
  br label %cond.end.133

cond.end.133:                                     ; preds = %cond.false.131, %cond.true.128
  %cond134 = phi i64 [ %95, %cond.true.128 ], [ %call132, %cond.false.131 ]
  %conv135 = trunc i64 %cond134 to i32
  %97 = load i32, i32* %discard, align 4
  %call136 = call %struct.sv* @Perl_av_delete(%struct.av* %89, i32 %conv135, i32 %97)
  store %struct.sv* %call136, %struct.sv** %sv, align 8
  br label %if.end.139

if.else.137:                                      ; preds = %if.then.119
  %98 = load %struct.hv*, %struct.hv** %hv, align 8
  %99 = bitcast %struct.hv* %98 to %struct.av*
  %100 = load %struct.sv*, %struct.sv** %keysv, align 8
  %101 = load i32, i32* %discard, align 4
  %call138 = call %struct.sv* @Perl_avhv_delete_ent(%struct.av* %99, %struct.sv* %100, i32 %101, i32 0)
  store %struct.sv* %call138, %struct.sv** %sv, align 8
  br label %if.end.139

if.end.139:                                       ; preds = %if.else.137, %cond.end.133
  br label %if.end.142

if.else.140:                                      ; preds = %if.else.114
  %call141 = call %struct.op* (i8*, ...) @Perl_die(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.38, i32 0, i32 0))
  store %struct.op* %call141, %struct.op** %retval
  br label %return

if.end.142:                                       ; preds = %if.end.139
  br label %if.end.143

if.end.143:                                       ; preds = %if.end.142, %if.then.112
  %102 = load %struct.sv*, %struct.sv** %sv, align 8
  %tobool144 = icmp ne %struct.sv* %102, null
  br i1 %tobool144, label %if.end.146, label %if.then.145

if.then.145:                                      ; preds = %if.end.143
  store %struct.sv* @PL_sv_undef, %struct.sv** %sv, align 8
  br label %if.end.146

if.end.146:                                       ; preds = %if.then.145, %if.end.143
  %103 = load i32, i32* %discard, align 4
  %tobool147 = icmp ne i32 %103, 0
  br i1 %tobool147, label %if.end.150, label %if.then.148

if.then.148:                                      ; preds = %if.end.146
  %104 = load %struct.sv*, %struct.sv** %sv, align 8
  %105 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr149 = getelementptr inbounds %struct.sv*, %struct.sv** %105, i32 1
  store %struct.sv** %incdec.ptr149, %struct.sv*** %sp, align 8
  store %struct.sv* %104, %struct.sv** %incdec.ptr149, align 8
  br label %if.end.150

if.end.150:                                       ; preds = %if.then.148, %if.end.146
  br label %if.end.151

if.end.151:                                       ; preds = %if.end.150, %if.end.104
  %106 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %106, %struct.sv*** @PL_stack_sp, align 8
  %107 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %107, i32 0, i32 0
  %108 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %108, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.151, %if.else.140, %if.else.82
  %109 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %109
}

declare %struct.sv* @Perl_hv_delete_ent(%struct.hv*, %struct.sv*, i32, i32) #1

declare %struct.sv* @Perl_av_delete(%struct.av*, i32, i32) #1

declare %struct.sv* @Perl_avhv_delete_ent(%struct.av*, %struct.sv*, i32, i32) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_exists() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %tmpsv = alloca %struct.sv*, align 8
  %hv = alloca %struct.hv*, align 8
  %gv = alloca %struct.gv*, align 8
  %cv = alloca %struct.cv*, align 8
  %sv = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %1, i32 0, i32 7
  %2 = load i8, i8* %op_private, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 64
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end.19

if.then:                                          ; preds = %entry
  %3 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %3, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %4 = load %struct.sv*, %struct.sv** %3, align 8
  store %struct.sv* %4, %struct.sv** %sv, align 8
  %5 = load %struct.sv*, %struct.sv** %sv, align 8
  %call = call %struct.cv* @Perl_sv_2cv(%struct.sv* %5, %struct.hv** %hv, %struct.gv** %gv, i32 0)
  store %struct.cv* %call, %struct.cv** %cv, align 8
  %6 = load %struct.cv*, %struct.cv** %cv, align 8
  %tobool1 = icmp ne %struct.cv* %6, null
  br i1 %tobool1, label %if.then.2, label %if.end

if.then.2:                                        ; preds = %if.then
  %7 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr3 = getelementptr inbounds %struct.sv*, %struct.sv** %7, i32 1
  store %struct.sv** %incdec.ptr3, %struct.sv*** %sp, align 8
  store %struct.sv* @PL_sv_yes, %struct.sv** %incdec.ptr3, align 8
  %8 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %8, %struct.sv*** @PL_stack_sp, align 8
  %9 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %9, i32 0, i32 0
  %10 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %10, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %if.then
  %11 = load %struct.gv*, %struct.gv** %gv, align 8
  %tobool4 = icmp ne %struct.gv* %11, null
  br i1 %tobool4, label %land.lhs.true, label %if.end.16

land.lhs.true:                                    ; preds = %if.end
  %12 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_flags = getelementptr inbounds %struct.gv, %struct.gv* %12, i32 0, i32 2
  %13 = load i32, i32* %sv_flags, align 4
  %and5 = and i32 %13, 255
  %cmp = icmp eq i32 %and5, 13
  br i1 %cmp, label %land.lhs.true.7, label %if.end.16

land.lhs.true.7:                                  ; preds = %land.lhs.true
  %14 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any = getelementptr inbounds %struct.gv, %struct.gv* %14, i32 0, i32 0
  %15 = load %struct.xpvgv*, %struct.xpvgv** %sv_any, align 8
  %xgv_gp = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %15, i32 0, i32 7
  %16 = load %struct.gp*, %struct.gp** %xgv_gp, align 8
  %gp_cv = getelementptr inbounds %struct.gp, %struct.gp* %16, i32 0, i32 7
  %17 = load %struct.cv*, %struct.cv** %gp_cv, align 8
  %tobool8 = icmp ne %struct.cv* %17, null
  br i1 %tobool8, label %land.lhs.true.9, label %if.end.16

land.lhs.true.9:                                  ; preds = %land.lhs.true.7
  %18 = load %struct.gv*, %struct.gv** %gv, align 8
  %sv_any10 = getelementptr inbounds %struct.gv, %struct.gv* %18, i32 0, i32 0
  %19 = load %struct.xpvgv*, %struct.xpvgv** %sv_any10, align 8
  %xgv_gp11 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %19, i32 0, i32 7
  %20 = load %struct.gp*, %struct.gp** %xgv_gp11, align 8
  %gp_cvgen = getelementptr inbounds %struct.gp, %struct.gp* %20, i32 0, i32 8
  %21 = load i32, i32* %gp_cvgen, align 4
  %tobool12 = icmp ne i32 %21, 0
  br i1 %tobool12, label %if.end.16, label %if.then.13

if.then.13:                                       ; preds = %land.lhs.true.9
  %22 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr14 = getelementptr inbounds %struct.sv*, %struct.sv** %22, i32 1
  store %struct.sv** %incdec.ptr14, %struct.sv*** %sp, align 8
  store %struct.sv* @PL_sv_yes, %struct.sv** %incdec.ptr14, align 8
  %23 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %23, %struct.sv*** @PL_stack_sp, align 8
  %24 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next15 = getelementptr inbounds %struct.op, %struct.op* %24, i32 0, i32 0
  %25 = load %struct.op*, %struct.op** %op_next15, align 8
  store %struct.op* %25, %struct.op** %retval
  br label %return

if.end.16:                                        ; preds = %land.lhs.true.9, %land.lhs.true.7, %land.lhs.true, %if.end
  %26 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr17 = getelementptr inbounds %struct.sv*, %struct.sv** %26, i32 1
  store %struct.sv** %incdec.ptr17, %struct.sv*** %sp, align 8
  store %struct.sv* @PL_sv_no, %struct.sv** %incdec.ptr17, align 8
  %27 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %27, %struct.sv*** @PL_stack_sp, align 8
  %28 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next18 = getelementptr inbounds %struct.op, %struct.op* %28, i32 0, i32 0
  %29 = load %struct.op*, %struct.op** %op_next18, align 8
  store %struct.op* %29, %struct.op** %retval
  br label %return

if.end.19:                                        ; preds = %entry
  %30 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr20 = getelementptr inbounds %struct.sv*, %struct.sv** %30, i32 -1
  store %struct.sv** %incdec.ptr20, %struct.sv*** %sp, align 8
  %31 = load %struct.sv*, %struct.sv** %30, align 8
  store %struct.sv* %31, %struct.sv** %tmpsv, align 8
  %32 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr21 = getelementptr inbounds %struct.sv*, %struct.sv** %32, i32 -1
  store %struct.sv** %incdec.ptr21, %struct.sv*** %sp, align 8
  %33 = load %struct.sv*, %struct.sv** %32, align 8
  %34 = bitcast %struct.sv* %33 to %struct.hv*
  store %struct.hv* %34, %struct.hv** %hv, align 8
  %35 = load %struct.hv*, %struct.hv** %hv, align 8
  %sv_flags22 = getelementptr inbounds %struct.hv, %struct.hv* %35, i32 0, i32 2
  %36 = load i32, i32* %sv_flags22, align 4
  %and23 = and i32 %36, 255
  %cmp24 = icmp eq i32 %and23, 11
  br i1 %cmp24, label %if.then.26, label %if.else

if.then.26:                                       ; preds = %if.end.19
  %37 = load %struct.hv*, %struct.hv** %hv, align 8
  %38 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %call27 = call signext i8 @Perl_hv_exists_ent(%struct.hv* %37, %struct.sv* %38, i32 0)
  %tobool28 = icmp ne i8 %call27, 0
  br i1 %tobool28, label %if.then.29, label %if.end.32

if.then.29:                                       ; preds = %if.then.26
  %39 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr30 = getelementptr inbounds %struct.sv*, %struct.sv** %39, i32 1
  store %struct.sv** %incdec.ptr30, %struct.sv*** %sp, align 8
  store %struct.sv* @PL_sv_yes, %struct.sv** %incdec.ptr30, align 8
  %40 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %40, %struct.sv*** @PL_stack_sp, align 8
  %41 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next31 = getelementptr inbounds %struct.op, %struct.op* %41, i32 0, i32 0
  %42 = load %struct.op*, %struct.op** %op_next31, align 8
  store %struct.op* %42, %struct.op** %retval
  br label %return

if.end.32:                                        ; preds = %if.then.26
  br label %if.end.65

if.else:                                          ; preds = %if.end.19
  %43 = load %struct.hv*, %struct.hv** %hv, align 8
  %sv_flags33 = getelementptr inbounds %struct.hv, %struct.hv* %43, i32 0, i32 2
  %44 = load i32, i32* %sv_flags33, align 4
  %and34 = and i32 %44, 255
  %cmp35 = icmp eq i32 %and34, 10
  br i1 %cmp35, label %if.then.37, label %if.else.62

if.then.37:                                       ; preds = %if.else
  %45 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %45, i32 0, i32 6
  %46 = load i8, i8* %op_flags, align 1
  %conv38 = zext i8 %46 to i32
  %and39 = and i32 %conv38, 128
  %tobool40 = icmp ne i32 %and39, 0
  br i1 %tobool40, label %if.then.41, label %if.else.54

if.then.41:                                       ; preds = %if.then.37
  %47 = load %struct.hv*, %struct.hv** %hv, align 8
  %48 = bitcast %struct.hv* %47 to %struct.av*
  %49 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %sv_flags42 = getelementptr inbounds %struct.sv, %struct.sv* %49, i32 0, i32 2
  %50 = load i32, i32* %sv_flags42, align 4
  %and43 = and i32 %50, 65536
  %tobool44 = icmp ne i32 %and43, 0
  br i1 %tobool44, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.41
  %51 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %sv_any45 = getelementptr inbounds %struct.sv, %struct.sv* %51, i32 0, i32 0
  %52 = load i8*, i8** %sv_any45, align 8
  %53 = bitcast i8* %52 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %53, i32 0, i32 3
  %54 = load i64, i64* %xiv_iv, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then.41
  %55 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %call46 = call i64 @Perl_sv_2iv(%struct.sv* %55)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %54, %cond.true ], [ %call46, %cond.false ]
  %conv47 = trunc i64 %cond to i32
  %call48 = call signext i8 @Perl_av_exists(%struct.av* %48, i32 %conv47)
  %tobool49 = icmp ne i8 %call48, 0
  br i1 %tobool49, label %if.then.50, label %if.end.53

if.then.50:                                       ; preds = %cond.end
  %56 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr51 = getelementptr inbounds %struct.sv*, %struct.sv** %56, i32 1
  store %struct.sv** %incdec.ptr51, %struct.sv*** %sp, align 8
  store %struct.sv* @PL_sv_yes, %struct.sv** %incdec.ptr51, align 8
  %57 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %57, %struct.sv*** @PL_stack_sp, align 8
  %58 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next52 = getelementptr inbounds %struct.op, %struct.op* %58, i32 0, i32 0
  %59 = load %struct.op*, %struct.op** %op_next52, align 8
  store %struct.op* %59, %struct.op** %retval
  br label %return

if.end.53:                                        ; preds = %cond.end
  br label %if.end.61

if.else.54:                                       ; preds = %if.then.37
  %60 = load %struct.hv*, %struct.hv** %hv, align 8
  %61 = bitcast %struct.hv* %60 to %struct.av*
  %62 = load %struct.sv*, %struct.sv** %tmpsv, align 8
  %call55 = call signext i8 @Perl_avhv_exists_ent(%struct.av* %61, %struct.sv* %62, i32 0)
  %tobool56 = icmp ne i8 %call55, 0
  br i1 %tobool56, label %if.then.57, label %if.end.60

if.then.57:                                       ; preds = %if.else.54
  %63 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr58 = getelementptr inbounds %struct.sv*, %struct.sv** %63, i32 1
  store %struct.sv** %incdec.ptr58, %struct.sv*** %sp, align 8
  store %struct.sv* @PL_sv_yes, %struct.sv** %incdec.ptr58, align 8
  %64 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %64, %struct.sv*** @PL_stack_sp, align 8
  %65 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next59 = getelementptr inbounds %struct.op, %struct.op* %65, i32 0, i32 0
  %66 = load %struct.op*, %struct.op** %op_next59, align 8
  store %struct.op* %66, %struct.op** %retval
  br label %return

if.end.60:                                        ; preds = %if.else.54
  br label %if.end.61

if.end.61:                                        ; preds = %if.end.60, %if.end.53
  br label %if.end.64

if.else.62:                                       ; preds = %if.else
  %call63 = call %struct.op* (i8*, ...) @Perl_die(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.38, i32 0, i32 0))
  store %struct.op* %call63, %struct.op** %retval
  br label %return

if.end.64:                                        ; preds = %if.end.61
  br label %if.end.65

if.end.65:                                        ; preds = %if.end.64, %if.end.32
  %67 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr66 = getelementptr inbounds %struct.sv*, %struct.sv** %67, i32 1
  store %struct.sv** %incdec.ptr66, %struct.sv*** %sp, align 8
  store %struct.sv* @PL_sv_no, %struct.sv** %incdec.ptr66, align 8
  %68 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %68, %struct.sv*** @PL_stack_sp, align 8
  %69 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next67 = getelementptr inbounds %struct.op, %struct.op* %69, i32 0, i32 0
  %70 = load %struct.op*, %struct.op** %op_next67, align 8
  store %struct.op* %70, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.65, %if.else.62, %if.then.57, %if.then.50, %if.then.29, %if.end.16, %if.then.13, %if.then.2
  %71 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %71
}

declare signext i8 @Perl_hv_exists_ent(%struct.hv*, %struct.sv*, i32) #1

declare signext i8 @Perl_av_exists(%struct.av*, i32) #1

declare signext i8 @Perl_avhv_exists_ent(%struct.av*, %struct.sv*, i32) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_hslice() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %mark = alloca %struct.sv**, align 8
  %origmark = alloca i32, align 4
  %hv = alloca %struct.hv*, align 8
  %lval = alloca i32, align 4
  %realhv = alloca i32, align 4
  %localizing = alloca i8, align 1
  %other_magic = alloca i8, align 1
  %mg = alloca %struct.magic*, align 8
  %stash = alloca %struct.hv*, align 8
  %keysv = alloca %struct.sv*, align 8
  %svp = alloca %struct.sv**, align 8
  %preeminent = alloca i8, align 1
  %he = alloca %struct.he*, align 8
  %n_a = alloca i64, align 8
  %keylen = alloca i64, align 8
  %key = alloca i8*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %2 = load i32*, i32** @PL_markstack_ptr, align 8
  %incdec.ptr = getelementptr inbounds i32, i32* %2, i32 -1
  store i32* %incdec.ptr, i32** @PL_markstack_ptr, align 8
  %3 = load i32, i32* %2, align 4
  %idx.ext = sext i32 %3 to i64
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %1, i64 %idx.ext
  store %struct.sv** %add.ptr, %struct.sv*** %mark, align 8
  %4 = load %struct.sv**, %struct.sv*** %mark, align 8
  %5 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %4 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %5 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %conv = trunc i64 %sub.ptr.div to i32
  store i32 %conv, i32* %origmark, align 4
  %6 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr1 = getelementptr inbounds %struct.sv*, %struct.sv** %6, i32 -1
  store %struct.sv** %incdec.ptr1, %struct.sv*** %sp, align 8
  %7 = load %struct.sv*, %struct.sv** %6, align 8
  %8 = bitcast %struct.sv* %7 to %struct.hv*
  store %struct.hv* %8, %struct.hv** %hv, align 8
  %9 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %9, i32 0, i32 6
  %10 = load i8, i8* %op_flags, align 1
  %conv2 = zext i8 %10 to i32
  %and = and i32 %conv2, 32
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %entry
  %11 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_private = getelementptr inbounds %struct.op, %struct.op* %11, i32 0, i32 7
  %12 = load i8, i8* %op_private, align 1
  %conv3 = zext i8 %12 to i32
  %and4 = and i32 %conv3, 8
  %tobool5 = icmp ne i32 %and4, 0
  br i1 %tobool5, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %lor.rhs
  %call = call i32 @Perl_is_lvalue_sub()
  %tobool6 = icmp ne i32 %call, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %lor.rhs
  %13 = phi i1 [ false, %lor.rhs ], [ %tobool6, %land.rhs ]
  br label %lor.end

lor.end:                                          ; preds = %land.end, %entry
  %14 = phi i1 [ true, %entry ], [ %13, %land.end ]
  %lor.ext = zext i1 %14 to i32
  store i32 %lor.ext, i32* %lval, align 4
  %15 = load %struct.hv*, %struct.hv** %hv, align 8
  %sv_flags = getelementptr inbounds %struct.hv, %struct.hv* %15, i32 0, i32 2
  %16 = load i32, i32* %sv_flags, align 4
  %and7 = and i32 %16, 255
  %cmp = icmp eq i32 %and7, 11
  %conv8 = zext i1 %cmp to i32
  store i32 %conv8, i32* %realhv, align 4
  %17 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_private9 = getelementptr inbounds %struct.op, %struct.op* %17, i32 0, i32 7
  %18 = load i8, i8* %op_private9, align 1
  %conv10 = zext i8 %18 to i32
  %and11 = and i32 %conv10, 128
  %tobool12 = icmp ne i32 %and11, 0
  %cond = select i1 %tobool12, i32 1, i32 0
  %conv13 = trunc i32 %cond to i8
  store i8 %conv13, i8* %localizing, align 1
  store i8 0, i8* %other_magic, align 1
  %19 = load i8, i8* %localizing, align 1
  %tobool14 = icmp ne i8 %19, 0
  br i1 %tobool14, label %if.then, label %if.end

if.then:                                          ; preds = %lor.end
  %20 = load %struct.hv*, %struct.hv** %hv, align 8
  %21 = bitcast %struct.hv* %20 to %struct.sv*
  %call15 = call %struct.magic* @Perl_mg_find(%struct.sv* %21, i32 69)
  %tobool16 = icmp ne %struct.magic* %call15, null
  br i1 %tobool16, label %lor.end.34, label %lor.rhs.17

lor.rhs.17:                                       ; preds = %if.then
  %22 = load %struct.hv*, %struct.hv** %hv, align 8
  %23 = bitcast %struct.hv* %22 to %struct.sv*
  %call18 = call %struct.magic* @Perl_mg_find(%struct.sv* %23, i32 80)
  store %struct.magic* %call18, %struct.magic** %mg, align 8
  %tobool19 = icmp ne %struct.magic* %call18, null
  br i1 %tobool19, label %land.lhs.true, label %land.end.33

land.lhs.true:                                    ; preds = %lor.rhs.17
  %24 = load %struct.magic*, %struct.magic** %mg, align 8
  %mg_obj = getelementptr inbounds %struct.magic, %struct.magic* %24, i32 0, i32 5
  %25 = load %struct.sv*, %struct.sv** %mg_obj, align 8
  %tobool20 = icmp ne %struct.sv* %25, null
  br i1 %tobool20, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true
  %26 = load %struct.magic*, %struct.magic** %mg, align 8
  %mg_obj21 = getelementptr inbounds %struct.magic, %struct.magic* %26, i32 0, i32 5
  %27 = load %struct.sv*, %struct.sv** %mg_obj21, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true
  %28 = load %struct.hv*, %struct.hv** %hv, align 8
  %29 = bitcast %struct.hv* %28 to %struct.sv*
  %call22 = call %struct.sv* @Perl_newRV(%struct.sv* %29)
  %call23 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call22)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond24 = phi %struct.sv* [ %27, %cond.true ], [ %call23, %cond.false ]
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %cond24, i32 0, i32 0
  %30 = load i8*, i8** %sv_any, align 8
  %31 = bitcast i8* %30 to %struct.xrv*
  %xrv_rv = getelementptr inbounds %struct.xrv, %struct.xrv* %31, i32 0, i32 0
  %32 = load %struct.sv*, %struct.sv** %xrv_rv, align 8
  %sv_any25 = getelementptr inbounds %struct.sv, %struct.sv* %32, i32 0, i32 0
  %33 = load i8*, i8** %sv_any25, align 8
  %34 = bitcast i8* %33 to %struct.xpvmg*
  %xmg_stash = getelementptr inbounds %struct.xpvmg, %struct.xpvmg* %34, i32 0, i32 6
  %35 = load %struct.hv*, %struct.hv** %xmg_stash, align 8
  store %struct.hv* %35, %struct.hv** %stash, align 8
  %tobool26 = icmp ne %struct.hv* %35, null
  br i1 %tobool26, label %land.lhs.true.27, label %land.end.33

land.lhs.true.27:                                 ; preds = %cond.end
  %36 = load %struct.hv*, %struct.hv** %stash, align 8
  %call28 = call %struct.gv* @Perl_gv_fetchmethod_autoload(%struct.hv* %36, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.39, i32 0, i32 0), i32 1)
  %tobool29 = icmp ne %struct.gv* %call28, null
  br i1 %tobool29, label %land.rhs.30, label %land.end.33

land.rhs.30:                                      ; preds = %land.lhs.true.27
  %37 = load %struct.hv*, %struct.hv** %stash, align 8
  %call31 = call %struct.gv* @Perl_gv_fetchmethod_autoload(%struct.hv* %37, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.40, i32 0, i32 0), i32 1)
  %tobool32 = icmp ne %struct.gv* %call31, null
  br label %land.end.33

land.end.33:                                      ; preds = %land.rhs.30, %land.lhs.true.27, %cond.end, %lor.rhs.17
  %38 = phi i1 [ false, %land.lhs.true.27 ], [ false, %cond.end ], [ false, %lor.rhs.17 ], [ %tobool32, %land.rhs.30 ]
  br label %lor.end.34

lor.end.34:                                       ; preds = %land.end.33, %if.then
  %39 = phi i1 [ true, %if.then ], [ %38, %land.end.33 ]
  %lor.ext35 = zext i1 %39 to i32
  %conv36 = trunc i32 %lor.ext35 to i8
  store i8 %conv36, i8* %other_magic, align 1
  br label %if.end

if.end:                                           ; preds = %lor.end.34, %lor.end
  %40 = load i32, i32* %realhv, align 4
  %tobool37 = icmp ne i32 %40, 0
  br i1 %tobool37, label %if.end.43, label %land.lhs.true.38

land.lhs.true.38:                                 ; preds = %if.end
  %41 = load i8, i8* %localizing, align 1
  %conv39 = sext i8 %41 to i32
  %tobool40 = icmp ne i32 %conv39, 0
  br i1 %tobool40, label %if.then.41, label %if.end.43

if.then.41:                                       ; preds = %land.lhs.true.38
  %call42 = call %struct.op* (i8*, ...) @Perl_die(i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.41, i32 0, i32 0))
  store %struct.op* %call42, %struct.op** %retval
  br label %return

if.end.43:                                        ; preds = %land.lhs.true.38, %if.end
  %42 = load i32, i32* %realhv, align 4
  %tobool44 = icmp ne i32 %42, 0
  br i1 %tobool44, label %if.then.49, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end.43
  %43 = load %struct.hv*, %struct.hv** %hv, align 8
  %sv_flags45 = getelementptr inbounds %struct.hv, %struct.hv* %43, i32 0, i32 2
  %44 = load i32, i32* %sv_flags45, align 4
  %and46 = and i32 %44, 255
  %cmp47 = icmp eq i32 %and46, 10
  br i1 %cmp47, label %if.then.49, label %if.end.134

if.then.49:                                       ; preds = %lor.lhs.false, %if.end.43
  br label %while.cond

while.cond:                                       ; preds = %cond.end.132, %if.then.49
  %45 = load %struct.sv**, %struct.sv*** %mark, align 8
  %incdec.ptr50 = getelementptr inbounds %struct.sv*, %struct.sv** %45, i32 1
  store %struct.sv** %incdec.ptr50, %struct.sv*** %mark, align 8
  %46 = load %struct.sv**, %struct.sv*** %sp, align 8
  %cmp51 = icmp ule %struct.sv** %incdec.ptr50, %46
  br i1 %cmp51, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %47 = load %struct.sv**, %struct.sv*** %mark, align 8
  %48 = load %struct.sv*, %struct.sv** %47, align 8
  store %struct.sv* %48, %struct.sv** %keysv, align 8
  store i8 0, i8* %preeminent, align 1
  %49 = load i8, i8* %localizing, align 1
  %tobool53 = icmp ne i8 %49, 0
  br i1 %tobool53, label %if.then.54, label %if.end.74

if.then.54:                                       ; preds = %while.body
  %50 = load %struct.hv*, %struct.hv** %hv, align 8
  %sv_flags55 = getelementptr inbounds %struct.hv, %struct.hv* %50, i32 0, i32 2
  %51 = load i32, i32* %sv_flags55, align 4
  %and56 = and i32 %51, 32768
  %tobool57 = icmp ne i32 %and56, 0
  br i1 %tobool57, label %land.lhs.true.58, label %cond.false.61

land.lhs.true.58:                                 ; preds = %if.then.54
  %52 = load i8, i8* %other_magic, align 1
  %tobool59 = icmp ne i8 %52, 0
  br i1 %tobool59, label %cond.false.61, label %cond.true.60

cond.true.60:                                     ; preds = %land.lhs.true.58
  br label %cond.end.71

cond.false.61:                                    ; preds = %land.lhs.true.58, %if.then.54
  %53 = load i32, i32* %realhv, align 4
  %tobool62 = icmp ne i32 %53, 0
  br i1 %tobool62, label %cond.true.63, label %cond.false.66

cond.true.63:                                     ; preds = %cond.false.61
  %54 = load %struct.hv*, %struct.hv** %hv, align 8
  %55 = load %struct.sv*, %struct.sv** %keysv, align 8
  %call64 = call signext i8 @Perl_hv_exists_ent(%struct.hv* %54, %struct.sv* %55, i32 0)
  %conv65 = sext i8 %call64 to i32
  br label %cond.end.69

cond.false.66:                                    ; preds = %cond.false.61
  %56 = load %struct.hv*, %struct.hv** %hv, align 8
  %57 = bitcast %struct.hv* %56 to %struct.av*
  %58 = load %struct.sv*, %struct.sv** %keysv, align 8
  %call67 = call signext i8 @Perl_avhv_exists_ent(%struct.av* %57, %struct.sv* %58, i32 0)
  %conv68 = sext i8 %call67 to i32
  br label %cond.end.69

cond.end.69:                                      ; preds = %cond.false.66, %cond.true.63
  %cond70 = phi i32 [ %conv65, %cond.true.63 ], [ %conv68, %cond.false.66 ]
  br label %cond.end.71

cond.end.71:                                      ; preds = %cond.end.69, %cond.true.60
  %cond72 = phi i32 [ 1, %cond.true.60 ], [ %cond70, %cond.end.69 ]
  %conv73 = trunc i32 %cond72 to i8
  store i8 %conv73, i8* %preeminent, align 1
  br label %if.end.74

if.end.74:                                        ; preds = %cond.end.71, %while.body
  %59 = load i32, i32* %realhv, align 4
  %tobool75 = icmp ne i32 %59, 0
  br i1 %tobool75, label %if.then.76, label %if.else

if.then.76:                                       ; preds = %if.end.74
  %60 = load %struct.hv*, %struct.hv** %hv, align 8
  %61 = load %struct.sv*, %struct.sv** %keysv, align 8
  %62 = load i32, i32* %lval, align 4
  %call77 = call %struct.he* @Perl_hv_fetch_ent(%struct.hv* %60, %struct.sv* %61, i32 %62, i32 0)
  store %struct.he* %call77, %struct.he** %he, align 8
  %63 = load %struct.he*, %struct.he** %he, align 8
  %tobool78 = icmp ne %struct.he* %63, null
  br i1 %tobool78, label %cond.true.79, label %cond.false.80

cond.true.79:                                     ; preds = %if.then.76
  %64 = load %struct.he*, %struct.he** %he, align 8
  %hent_val = getelementptr inbounds %struct.he, %struct.he* %64, i32 0, i32 2
  br label %cond.end.81

cond.false.80:                                    ; preds = %if.then.76
  br label %cond.end.81

cond.end.81:                                      ; preds = %cond.false.80, %cond.true.79
  %cond82 = phi %struct.sv** [ %hent_val, %cond.true.79 ], [ null, %cond.false.80 ]
  store %struct.sv** %cond82, %struct.sv*** %svp, align 8
  br label %if.end.84

if.else:                                          ; preds = %if.end.74
  %65 = load %struct.hv*, %struct.hv** %hv, align 8
  %66 = bitcast %struct.hv* %65 to %struct.av*
  %67 = load %struct.sv*, %struct.sv** %keysv, align 8
  %68 = load i32, i32* %lval, align 4
  %call83 = call %struct.sv** @Perl_avhv_fetch_ent(%struct.av* %66, %struct.sv* %67, i32 %68, i32 0)
  store %struct.sv** %call83, %struct.sv*** %svp, align 8
  br label %if.end.84

if.end.84:                                        ; preds = %if.else, %cond.end.81
  %69 = load i32, i32* %lval, align 4
  %tobool85 = icmp ne i32 %69, 0
  br i1 %tobool85, label %if.then.86, label %if.end.128

if.then.86:                                       ; preds = %if.end.84
  %70 = load %struct.sv**, %struct.sv*** %svp, align 8
  %tobool87 = icmp ne %struct.sv** %70, null
  br i1 %tobool87, label %lor.lhs.false.88, label %if.then.91

lor.lhs.false.88:                                 ; preds = %if.then.86
  %71 = load %struct.sv**, %struct.sv*** %svp, align 8
  %72 = load %struct.sv*, %struct.sv** %71, align 8
  %cmp89 = icmp eq %struct.sv* %72, @PL_sv_undef
  br i1 %cmp89, label %if.then.91, label %if.end.104

if.then.91:                                       ; preds = %lor.lhs.false.88, %if.then.86
  %73 = load %struct.sv*, %struct.sv** %keysv, align 8
  %sv_flags92 = getelementptr inbounds %struct.sv, %struct.sv* %73, i32 0, i32 2
  %74 = load i32, i32* %sv_flags92, align 4
  %and93 = and i32 %74, 262144
  %cmp94 = icmp eq i32 %and93, 262144
  br i1 %cmp94, label %cond.true.96, label %cond.false.99

cond.true.96:                                     ; preds = %if.then.91
  %75 = load %struct.sv*, %struct.sv** %keysv, align 8
  %sv_any97 = getelementptr inbounds %struct.sv, %struct.sv* %75, i32 0, i32 0
  %76 = load i8*, i8** %sv_any97, align 8
  %77 = bitcast i8* %76 to %struct.xpv*
  %xpv_cur = getelementptr inbounds %struct.xpv, %struct.xpv* %77, i32 0, i32 1
  %78 = load i64, i64* %xpv_cur, align 8
  store i64 %78, i64* %n_a, align 8
  %79 = load %struct.sv*, %struct.sv** %keysv, align 8
  %sv_any98 = getelementptr inbounds %struct.sv, %struct.sv* %79, i32 0, i32 0
  %80 = load i8*, i8** %sv_any98, align 8
  %81 = bitcast i8* %80 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %81, i32 0, i32 0
  %82 = load i8*, i8** %xpv_pv, align 8
  br label %cond.end.101

cond.false.99:                                    ; preds = %if.then.91
  %83 = load %struct.sv*, %struct.sv** %keysv, align 8
  %call100 = call i8* @Perl_sv_2pv_flags(%struct.sv* %83, i64* %n_a, i32 2)
  br label %cond.end.101

cond.end.101:                                     ; preds = %cond.false.99, %cond.true.96
  %cond102 = phi i8* [ %82, %cond.true.96 ], [ %call100, %cond.false.99 ]
  %call103 = call %struct.op* (i8*, ...) @Perl_die(i8* getelementptr inbounds ([0 x i8], [0 x i8]* @PL_no_helem, i32 0, i32 0), i8* %cond102)
  store %struct.op* %call103, %struct.op** %retval
  br label %return

if.end.104:                                       ; preds = %lor.lhs.false.88
  %84 = load i8, i8* %localizing, align 1
  %tobool105 = icmp ne i8 %84, 0
  br i1 %tobool105, label %if.then.106, label %if.end.127

if.then.106:                                      ; preds = %if.end.104
  %85 = load i8, i8* %preeminent, align 1
  %tobool107 = icmp ne i8 %85, 0
  br i1 %tobool107, label %if.then.108, label %if.else.109

if.then.108:                                      ; preds = %if.then.106
  %86 = load %struct.hv*, %struct.hv** %hv, align 8
  %87 = load %struct.sv*, %struct.sv** %keysv, align 8
  %88 = load %struct.sv**, %struct.sv*** %svp, align 8
  call void @Perl_save_helem(%struct.hv* %86, %struct.sv* %87, %struct.sv** %88)
  br label %if.end.126

if.else.109:                                      ; preds = %if.then.106
  %89 = load %struct.sv*, %struct.sv** %keysv, align 8
  %sv_flags110 = getelementptr inbounds %struct.sv, %struct.sv* %89, i32 0, i32 2
  %90 = load i32, i32* %sv_flags110, align 4
  %and111 = and i32 %90, 262144
  %cmp112 = icmp eq i32 %and111, 262144
  br i1 %cmp112, label %cond.true.114, label %cond.false.119

cond.true.114:                                    ; preds = %if.else.109
  %91 = load %struct.sv*, %struct.sv** %keysv, align 8
  %sv_any115 = getelementptr inbounds %struct.sv, %struct.sv* %91, i32 0, i32 0
  %92 = load i8*, i8** %sv_any115, align 8
  %93 = bitcast i8* %92 to %struct.xpv*
  %xpv_cur116 = getelementptr inbounds %struct.xpv, %struct.xpv* %93, i32 0, i32 1
  %94 = load i64, i64* %xpv_cur116, align 8
  store i64 %94, i64* %keylen, align 8
  %95 = load %struct.sv*, %struct.sv** %keysv, align 8
  %sv_any117 = getelementptr inbounds %struct.sv, %struct.sv* %95, i32 0, i32 0
  %96 = load i8*, i8** %sv_any117, align 8
  %97 = bitcast i8* %96 to %struct.xpv*
  %xpv_pv118 = getelementptr inbounds %struct.xpv, %struct.xpv* %97, i32 0, i32 0
  %98 = load i8*, i8** %xpv_pv118, align 8
  br label %cond.end.121

cond.false.119:                                   ; preds = %if.else.109
  %99 = load %struct.sv*, %struct.sv** %keysv, align 8
  %call120 = call i8* @Perl_sv_2pv_flags(%struct.sv* %99, i64* %keylen, i32 2)
  br label %cond.end.121

cond.end.121:                                     ; preds = %cond.false.119, %cond.true.114
  %cond122 = phi i8* [ %98, %cond.true.114 ], [ %call120, %cond.false.119 ]
  store i8* %cond122, i8** %key, align 8
  %100 = load %struct.hv*, %struct.hv** %hv, align 8
  %101 = load i8*, i8** %key, align 8
  %102 = load i64, i64* %keylen, align 8
  %conv123 = trunc i64 %102 to i32
  %call124 = call i8* @Perl_savepvn(i8* %101, i32 %conv123)
  %103 = load i64, i64* %keylen, align 8
  %conv125 = trunc i64 %103 to i32
  call void @Perl_save_delete(%struct.hv* %100, i8* %call124, i32 %conv125)
  br label %if.end.126

if.end.126:                                       ; preds = %cond.end.121, %if.then.108
  br label %if.end.127

if.end.127:                                       ; preds = %if.end.126, %if.end.104
  br label %if.end.128

if.end.128:                                       ; preds = %if.end.127, %if.end.84
  %104 = load %struct.sv**, %struct.sv*** %svp, align 8
  %tobool129 = icmp ne %struct.sv** %104, null
  br i1 %tobool129, label %cond.true.130, label %cond.false.131

cond.true.130:                                    ; preds = %if.end.128
  %105 = load %struct.sv**, %struct.sv*** %svp, align 8
  %106 = load %struct.sv*, %struct.sv** %105, align 8
  br label %cond.end.132

cond.false.131:                                   ; preds = %if.end.128
  br label %cond.end.132

cond.end.132:                                     ; preds = %cond.false.131, %cond.true.130
  %cond133 = phi %struct.sv* [ %106, %cond.true.130 ], [ @PL_sv_undef, %cond.false.131 ]
  %107 = load %struct.sv**, %struct.sv*** %mark, align 8
  store %struct.sv* %cond133, %struct.sv** %107, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  br label %if.end.134

if.end.134:                                       ; preds = %while.end, %lor.lhs.false
  %108 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags135 = getelementptr inbounds %struct.op, %struct.op* %108, i32 0, i32 6
  %109 = load i8, i8* %op_flags135, align 1
  %conv136 = zext i8 %109 to i32
  %and137 = and i32 %conv136, 3
  %tobool138 = icmp ne i32 %and137, 0
  br i1 %tobool138, label %cond.true.139, label %cond.false.146

cond.true.139:                                    ; preds = %if.end.134
  %110 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags140 = getelementptr inbounds %struct.op, %struct.op* %110, i32 0, i32 6
  %111 = load i8, i8* %op_flags140, align 1
  %conv141 = zext i8 %111 to i32
  %and142 = and i32 %conv141, 3
  %cmp143 = icmp eq i32 %and142, 3
  %cond145 = select i1 %cmp143, i32 1, i32 0
  br label %cond.end.148

cond.false.146:                                   ; preds = %if.end.134
  %call147 = call i32 @Perl_dowantarray()
  br label %cond.end.148

cond.end.148:                                     ; preds = %cond.false.146, %cond.true.139
  %cond149 = phi i32 [ %cond145, %cond.true.139 ], [ %call147, %cond.false.146 ]
  %cmp150 = icmp ne i32 %cond149, 1
  br i1 %cmp150, label %if.then.152, label %if.end.164

if.then.152:                                      ; preds = %cond.end.148
  %112 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %113 = load i32, i32* %origmark, align 4
  %idx.ext153 = sext i32 %113 to i64
  %add.ptr154 = getelementptr inbounds %struct.sv*, %struct.sv** %112, i64 %idx.ext153
  store %struct.sv** %add.ptr154, %struct.sv*** %mark, align 8
  %114 = load %struct.sv**, %struct.sv*** %sp, align 8
  %115 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %116 = load i32, i32* %origmark, align 4
  %idx.ext155 = sext i32 %116 to i64
  %add.ptr156 = getelementptr inbounds %struct.sv*, %struct.sv** %115, i64 %idx.ext155
  %cmp157 = icmp ugt %struct.sv** %114, %add.ptr156
  br i1 %cmp157, label %cond.true.159, label %cond.false.160

cond.true.159:                                    ; preds = %if.then.152
  %117 = load %struct.sv**, %struct.sv*** %sp, align 8
  %118 = load %struct.sv*, %struct.sv** %117, align 8
  br label %cond.end.161

cond.false.160:                                   ; preds = %if.then.152
  br label %cond.end.161

cond.end.161:                                     ; preds = %cond.false.160, %cond.true.159
  %cond162 = phi %struct.sv* [ %118, %cond.true.159 ], [ @PL_sv_undef, %cond.false.160 ]
  %119 = load %struct.sv**, %struct.sv*** %mark, align 8
  %incdec.ptr163 = getelementptr inbounds %struct.sv*, %struct.sv** %119, i32 1
  store %struct.sv** %incdec.ptr163, %struct.sv*** %mark, align 8
  store %struct.sv* %cond162, %struct.sv** %incdec.ptr163, align 8
  %120 = load %struct.sv**, %struct.sv*** %mark, align 8
  store %struct.sv** %120, %struct.sv*** %sp, align 8
  br label %if.end.164

if.end.164:                                       ; preds = %cond.end.161, %cond.end.148
  %121 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %121, %struct.sv*** @PL_stack_sp, align 8
  %122 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %122, i32 0, i32 0
  %123 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %123, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.164, %cond.end.101, %if.then.41
  %124 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %124
}

declare %struct.gv* @Perl_gv_fetchmethod_autoload(%struct.hv*, i8*, i32) #1

declare %struct.he* @Perl_hv_fetch_ent(%struct.hv*, %struct.sv*, i32, i32) #1

declare %struct.sv** @Perl_avhv_fetch_ent(%struct.av*, %struct.sv*, i32, i32) #1

declare void @Perl_save_helem(%struct.hv*, %struct.sv*, %struct.sv**) #1

declare void @Perl_save_delete(%struct.hv*, i8*, i32) #1

declare i8* @Perl_savepvn(i8*, i32) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_list() #0 {
entry:
  %sp = alloca %struct.sv**, align 8
  %mark = alloca %struct.sv**, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %2 = load i32*, i32** @PL_markstack_ptr, align 8
  %incdec.ptr = getelementptr inbounds i32, i32* %2, i32 -1
  store i32* %incdec.ptr, i32** @PL_markstack_ptr, align 8
  %3 = load i32, i32* %2, align 4
  %idx.ext = sext i32 %3 to i64
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %1, i64 %idx.ext
  store %struct.sv** %add.ptr, %struct.sv*** %mark, align 8
  %4 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %4, i32 0, i32 6
  %5 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %5 to i32
  %and = and i32 %conv, 3
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %6 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags1 = getelementptr inbounds %struct.op, %struct.op* %6, i32 0, i32 6
  %7 = load i8, i8* %op_flags1, align 1
  %conv2 = zext i8 %7 to i32
  %and3 = and i32 %conv2, 3
  %cmp = icmp eq i32 %and3, 3
  %cond = select i1 %cmp, i32 1, i32 0
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = call i32 @Perl_dowantarray()
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond5 = phi i32 [ %cond, %cond.true ], [ %call, %cond.false ]
  %cmp6 = icmp ne i32 %cond5, 1
  br i1 %cmp6, label %if.then, label %if.end.12

if.then:                                          ; preds = %cond.end
  %8 = load %struct.sv**, %struct.sv*** %mark, align 8
  %incdec.ptr8 = getelementptr inbounds %struct.sv*, %struct.sv** %8, i32 1
  store %struct.sv** %incdec.ptr8, %struct.sv*** %mark, align 8
  %9 = load %struct.sv**, %struct.sv*** %sp, align 8
  %cmp9 = icmp ule %struct.sv** %incdec.ptr8, %9
  br i1 %cmp9, label %if.then.11, label %if.else

if.then.11:                                       ; preds = %if.then
  %10 = load %struct.sv**, %struct.sv*** %sp, align 8
  %11 = load %struct.sv*, %struct.sv** %10, align 8
  %12 = load %struct.sv**, %struct.sv*** %mark, align 8
  store %struct.sv* %11, %struct.sv** %12, align 8
  br label %if.end

if.else:                                          ; preds = %if.then
  %13 = load %struct.sv**, %struct.sv*** %mark, align 8
  store %struct.sv* @PL_sv_undef, %struct.sv** %13, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then.11
  %14 = load %struct.sv**, %struct.sv*** %mark, align 8
  store %struct.sv** %14, %struct.sv*** %sp, align 8
  br label %if.end.12

if.end.12:                                        ; preds = %if.end, %cond.end
  %15 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %15, %struct.sv*** @PL_stack_sp, align 8
  %16 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %16, i32 0, i32 0
  %17 = load %struct.op*, %struct.op** %op_next, align 8
  ret %struct.op* %17
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_lslice() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %lastrelem = alloca %struct.sv**, align 8
  %lastlelem = alloca %struct.sv**, align 8
  %firstlelem = alloca %struct.sv**, align 8
  %firstrelem = alloca %struct.sv**, align 8
  %arybase = alloca i32, align 4
  %lval = alloca i32, align 4
  %is_something_there = alloca i32, align 4
  %max = alloca i32, align 4
  %lelem = alloca %struct.sv**, align 8
  %ix = alloca i32, align 4
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %1, %struct.sv*** %lastrelem, align 8
  %2 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %3 = load i32*, i32** @PL_markstack_ptr, align 8
  %incdec.ptr = getelementptr inbounds i32, i32* %3, i32 -1
  store i32* %incdec.ptr, i32** @PL_markstack_ptr, align 8
  %4 = load i32, i32* %3, align 4
  %idx.ext = sext i32 %4 to i64
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %2, i64 %idx.ext
  store %struct.sv** %add.ptr, %struct.sv*** %lastlelem, align 8
  %5 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %6 = load i32*, i32** @PL_markstack_ptr, align 8
  %incdec.ptr1 = getelementptr inbounds i32, i32* %6, i32 -1
  store i32* %incdec.ptr1, i32** @PL_markstack_ptr, align 8
  %7 = load i32, i32* %6, align 4
  %idx.ext2 = sext i32 %7 to i64
  %add.ptr3 = getelementptr inbounds %struct.sv*, %struct.sv** %5, i64 %idx.ext2
  %add.ptr4 = getelementptr inbounds %struct.sv*, %struct.sv** %add.ptr3, i64 1
  store %struct.sv** %add.ptr4, %struct.sv*** %firstlelem, align 8
  %8 = load %struct.sv**, %struct.sv*** %lastlelem, align 8
  %add.ptr5 = getelementptr inbounds %struct.sv*, %struct.sv** %8, i64 1
  store %struct.sv** %add.ptr5, %struct.sv*** %firstrelem, align 8
  %9 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_arybase = getelementptr inbounds %struct.cop, %struct.cop* %9, i32 0, i32 12
  %10 = load i32, i32* %cop_arybase, align 4
  store i32 %10, i32* %arybase, align 4
  %11 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %11, i32 0, i32 6
  %12 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %12 to i32
  %and = and i32 %conv, 32
  store i32 %and, i32* %lval, align 4
  %13 = load i32, i32* %lval, align 4
  store i32 %13, i32* %is_something_there, align 4
  %14 = load %struct.sv**, %struct.sv*** %lastrelem, align 8
  %15 = load %struct.sv**, %struct.sv*** %lastlelem, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %14 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %15 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %conv6 = trunc i64 %sub.ptr.div to i32
  store i32 %conv6, i32* %max, align 4
  %16 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags7 = getelementptr inbounds %struct.op, %struct.op* %16, i32 0, i32 6
  %17 = load i8, i8* %op_flags7, align 1
  %conv8 = zext i8 %17 to i32
  %and9 = and i32 %conv8, 3
  %tobool = icmp ne i32 %and9, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %18 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags10 = getelementptr inbounds %struct.op, %struct.op* %18, i32 0, i32 6
  %19 = load i8, i8* %op_flags10, align 1
  %conv11 = zext i8 %19 to i32
  %and12 = and i32 %conv11, 3
  %cmp = icmp eq i32 %and12, 3
  %cond = select i1 %cmp, i32 1, i32 0
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = call i32 @Perl_dowantarray()
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond14 = phi i32 [ %cond, %cond.true ], [ %call, %cond.false ]
  %cmp15 = icmp ne i32 %cond14, 1
  br i1 %cmp15, label %if.then, label %if.end.35

if.then:                                          ; preds = %cond.end
  %20 = load %struct.sv**, %struct.sv*** %lastlelem, align 8
  %21 = load %struct.sv*, %struct.sv** %20, align 8
  store %struct.sv* %21, %struct.sv** @PL_Sv, align 8
  %22 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %22, i32 0, i32 2
  %23 = load i32, i32* %sv_flags, align 4
  %and17 = and i32 %23, 65536
  %tobool18 = icmp ne i32 %and17, 0
  br i1 %tobool18, label %cond.true.19, label %cond.false.20

cond.true.19:                                     ; preds = %if.then
  %24 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %24, i32 0, i32 0
  %25 = load i8*, i8** %sv_any, align 8
  %26 = bitcast i8* %25 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %26, i32 0, i32 3
  %27 = load i64, i64* %xiv_iv, align 8
  br label %cond.end.22

cond.false.20:                                    ; preds = %if.then
  %28 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call21 = call i64 @Perl_sv_2iv(%struct.sv* %28)
  br label %cond.end.22

cond.end.22:                                      ; preds = %cond.false.20, %cond.true.19
  %cond23 = phi i64 [ %27, %cond.true.19 ], [ %call21, %cond.false.20 ]
  %conv24 = trunc i64 %cond23 to i32
  store i32 %conv24, i32* %ix, align 4
  %29 = load i32, i32* %ix, align 4
  %cmp25 = icmp slt i32 %29, 0
  br i1 %cmp25, label %if.then.27, label %if.else

if.then.27:                                       ; preds = %cond.end.22
  %30 = load i32, i32* %max, align 4
  %31 = load i32, i32* %ix, align 4
  %add = add nsw i32 %31, %30
  store i32 %add, i32* %ix, align 4
  br label %if.end

if.else:                                          ; preds = %cond.end.22
  %32 = load i32, i32* %arybase, align 4
  %33 = load i32, i32* %ix, align 4
  %sub = sub nsw i32 %33, %32
  store i32 %sub, i32* %ix, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then.27
  %34 = load i32, i32* %ix, align 4
  %cmp28 = icmp slt i32 %34, 0
  br i1 %cmp28, label %if.then.32, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %35 = load i32, i32* %ix, align 4
  %36 = load i32, i32* %max, align 4
  %cmp30 = icmp sge i32 %35, %36
  br i1 %cmp30, label %if.then.32, label %if.else.33

if.then.32:                                       ; preds = %lor.lhs.false, %if.end
  %37 = load %struct.sv**, %struct.sv*** %firstlelem, align 8
  store %struct.sv* @PL_sv_undef, %struct.sv** %37, align 8
  br label %if.end.34

if.else.33:                                       ; preds = %lor.lhs.false
  %38 = load i32, i32* %ix, align 4
  %idxprom = sext i32 %38 to i64
  %39 = load %struct.sv**, %struct.sv*** %firstrelem, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %39, i64 %idxprom
  %40 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  %41 = load %struct.sv**, %struct.sv*** %firstlelem, align 8
  store %struct.sv* %40, %struct.sv** %41, align 8
  br label %if.end.34

if.end.34:                                        ; preds = %if.else.33, %if.then.32
  %42 = load %struct.sv**, %struct.sv*** %firstlelem, align 8
  store %struct.sv** %42, %struct.sv*** %sp, align 8
  %43 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %43, %struct.sv*** @PL_stack_sp, align 8
  %44 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %44, i32 0, i32 0
  %45 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %45, %struct.op** %retval
  br label %return

if.end.35:                                        ; preds = %cond.end
  %46 = load i32, i32* %max, align 4
  %cmp36 = icmp eq i32 %46, 0
  br i1 %cmp36, label %if.then.38, label %if.end.41

if.then.38:                                       ; preds = %if.end.35
  %47 = load %struct.sv**, %struct.sv*** %firstlelem, align 8
  %add.ptr39 = getelementptr inbounds %struct.sv*, %struct.sv** %47, i64 -1
  store %struct.sv** %add.ptr39, %struct.sv*** %sp, align 8
  %48 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %48, %struct.sv*** @PL_stack_sp, align 8
  %49 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next40 = getelementptr inbounds %struct.op, %struct.op* %49, i32 0, i32 0
  %50 = load %struct.op*, %struct.op** %op_next40, align 8
  store %struct.op* %50, %struct.op** %retval
  br label %return

if.end.41:                                        ; preds = %if.end.35
  %51 = load %struct.sv**, %struct.sv*** %firstlelem, align 8
  store %struct.sv** %51, %struct.sv*** %lelem, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end.41
  %52 = load %struct.sv**, %struct.sv*** %lelem, align 8
  %53 = load %struct.sv**, %struct.sv*** %lastlelem, align 8
  %cmp42 = icmp ule %struct.sv** %52, %53
  br i1 %cmp42, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %54 = load %struct.sv**, %struct.sv*** %lelem, align 8
  %55 = load %struct.sv*, %struct.sv** %54, align 8
  store %struct.sv* %55, %struct.sv** @PL_Sv, align 8
  %56 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags44 = getelementptr inbounds %struct.sv, %struct.sv* %56, i32 0, i32 2
  %57 = load i32, i32* %sv_flags44, align 4
  %and45 = and i32 %57, 65536
  %tobool46 = icmp ne i32 %and45, 0
  br i1 %tobool46, label %cond.true.47, label %cond.false.50

cond.true.47:                                     ; preds = %for.body
  %58 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any48 = getelementptr inbounds %struct.sv, %struct.sv* %58, i32 0, i32 0
  %59 = load i8*, i8** %sv_any48, align 8
  %60 = bitcast i8* %59 to %struct.xpviv*
  %xiv_iv49 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %60, i32 0, i32 3
  %61 = load i64, i64* %xiv_iv49, align 8
  br label %cond.end.52

cond.false.50:                                    ; preds = %for.body
  %62 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call51 = call i64 @Perl_sv_2iv(%struct.sv* %62)
  br label %cond.end.52

cond.end.52:                                      ; preds = %cond.false.50, %cond.true.47
  %cond53 = phi i64 [ %61, %cond.true.47 ], [ %call51, %cond.false.50 ]
  %conv54 = trunc i64 %cond53 to i32
  store i32 %conv54, i32* %ix, align 4
  %63 = load i32, i32* %ix, align 4
  %cmp55 = icmp slt i32 %63, 0
  br i1 %cmp55, label %if.then.57, label %if.else.59

if.then.57:                                       ; preds = %cond.end.52
  %64 = load i32, i32* %max, align 4
  %65 = load i32, i32* %ix, align 4
  %add58 = add nsw i32 %65, %64
  store i32 %add58, i32* %ix, align 4
  br label %if.end.61

if.else.59:                                       ; preds = %cond.end.52
  %66 = load i32, i32* %arybase, align 4
  %67 = load i32, i32* %ix, align 4
  %sub60 = sub nsw i32 %67, %66
  store i32 %sub60, i32* %ix, align 4
  br label %if.end.61

if.end.61:                                        ; preds = %if.else.59, %if.then.57
  %68 = load i32, i32* %ix, align 4
  %cmp62 = icmp slt i32 %68, 0
  br i1 %cmp62, label %if.then.67, label %lor.lhs.false.64

lor.lhs.false.64:                                 ; preds = %if.end.61
  %69 = load i32, i32* %ix, align 4
  %70 = load i32, i32* %max, align 4
  %cmp65 = icmp sge i32 %69, %70
  br i1 %cmp65, label %if.then.67, label %if.else.68

if.then.67:                                       ; preds = %lor.lhs.false.64, %if.end.61
  %71 = load %struct.sv**, %struct.sv*** %lelem, align 8
  store %struct.sv* @PL_sv_undef, %struct.sv** %71, align 8
  br label %if.end.74

if.else.68:                                       ; preds = %lor.lhs.false.64
  store i32 1, i32* %is_something_there, align 4
  %72 = load i32, i32* %ix, align 4
  %idxprom69 = sext i32 %72 to i64
  %73 = load %struct.sv**, %struct.sv*** %firstrelem, align 8
  %arrayidx70 = getelementptr inbounds %struct.sv*, %struct.sv** %73, i64 %idxprom69
  %74 = load %struct.sv*, %struct.sv** %arrayidx70, align 8
  %75 = load %struct.sv**, %struct.sv*** %lelem, align 8
  store %struct.sv* %74, %struct.sv** %75, align 8
  %tobool71 = icmp ne %struct.sv* %74, null
  br i1 %tobool71, label %if.end.73, label %if.then.72

if.then.72:                                       ; preds = %if.else.68
  %76 = load %struct.sv**, %struct.sv*** %lelem, align 8
  store %struct.sv* @PL_sv_undef, %struct.sv** %76, align 8
  br label %if.end.73

if.end.73:                                        ; preds = %if.then.72, %if.else.68
  br label %if.end.74

if.end.74:                                        ; preds = %if.end.73, %if.then.67
  br label %for.inc

for.inc:                                          ; preds = %if.end.74
  %77 = load %struct.sv**, %struct.sv*** %lelem, align 8
  %incdec.ptr75 = getelementptr inbounds %struct.sv*, %struct.sv** %77, i32 1
  store %struct.sv** %incdec.ptr75, %struct.sv*** %lelem, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %78 = load i32, i32* %is_something_there, align 4
  %tobool76 = icmp ne i32 %78, 0
  br i1 %tobool76, label %if.then.77, label %if.else.78

if.then.77:                                       ; preds = %for.end
  %79 = load %struct.sv**, %struct.sv*** %lastlelem, align 8
  store %struct.sv** %79, %struct.sv*** %sp, align 8
  br label %if.end.80

if.else.78:                                       ; preds = %for.end
  %80 = load %struct.sv**, %struct.sv*** %firstlelem, align 8
  %add.ptr79 = getelementptr inbounds %struct.sv*, %struct.sv** %80, i64 -1
  store %struct.sv** %add.ptr79, %struct.sv*** %sp, align 8
  br label %if.end.80

if.end.80:                                        ; preds = %if.else.78, %if.then.77
  %81 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %81, %struct.sv*** @PL_stack_sp, align 8
  %82 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next81 = getelementptr inbounds %struct.op, %struct.op* %82, i32 0, i32 0
  %83 = load %struct.op*, %struct.op** %op_next81, align 8
  store %struct.op* %83, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.80, %if.then.38, %if.end.34
  %84 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %84
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_anonlist() #0 {
entry:
  %sp = alloca %struct.sv**, align 8
  %mark = alloca %struct.sv**, align 8
  %origmark = alloca i32, align 4
  %items = alloca i32, align 4
  %av = alloca %struct.sv*, align 8
  %tmp = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %2 = load i32*, i32** @PL_markstack_ptr, align 8
  %incdec.ptr = getelementptr inbounds i32, i32* %2, i32 -1
  store i32* %incdec.ptr, i32** @PL_markstack_ptr, align 8
  %3 = load i32, i32* %2, align 4
  %idx.ext = sext i32 %3 to i64
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %1, i64 %idx.ext
  store %struct.sv** %add.ptr, %struct.sv*** %mark, align 8
  %4 = load %struct.sv**, %struct.sv*** %mark, align 8
  %5 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %4 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %5 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %conv = trunc i64 %sub.ptr.div to i32
  store i32 %conv, i32* %origmark, align 4
  %6 = load %struct.sv**, %struct.sv*** %sp, align 8
  %7 = load %struct.sv**, %struct.sv*** %mark, align 8
  %sub.ptr.lhs.cast1 = ptrtoint %struct.sv** %6 to i64
  %sub.ptr.rhs.cast2 = ptrtoint %struct.sv** %7 to i64
  %sub.ptr.sub3 = sub i64 %sub.ptr.lhs.cast1, %sub.ptr.rhs.cast2
  %sub.ptr.div4 = sdiv exact i64 %sub.ptr.sub3, 8
  %conv5 = trunc i64 %sub.ptr.div4 to i32
  store i32 %conv5, i32* %items, align 4
  %8 = load i32, i32* %items, align 4
  %9 = load %struct.sv**, %struct.sv*** %mark, align 8
  %add.ptr6 = getelementptr inbounds %struct.sv*, %struct.sv** %9, i64 1
  %call = call %struct.av* @Perl_av_make(i32 %8, %struct.sv** %add.ptr6)
  %10 = bitcast %struct.av* %call to %struct.sv*
  %call7 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %10)
  store %struct.sv* %call7, %struct.sv** %av, align 8
  %11 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %12 = load i32, i32* %origmark, align 4
  %idx.ext8 = sext i32 %12 to i64
  %add.ptr9 = getelementptr inbounds %struct.sv*, %struct.sv** %11, i64 %idx.ext8
  store %struct.sv** %add.ptr9, %struct.sv*** %sp, align 8
  %13 = load %struct.sv**, %struct.sv*** @PL_stack_max, align 8
  %14 = load %struct.sv**, %struct.sv*** %sp, align 8
  %sub.ptr.lhs.cast10 = ptrtoint %struct.sv** %13 to i64
  %sub.ptr.rhs.cast11 = ptrtoint %struct.sv** %14 to i64
  %sub.ptr.sub12 = sub i64 %sub.ptr.lhs.cast10, %sub.ptr.rhs.cast11
  %sub.ptr.div13 = sdiv exact i64 %sub.ptr.sub12, 8
  %cmp = icmp slt i64 %sub.ptr.div13, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %15 = load %struct.sv**, %struct.sv*** %sp, align 8
  %16 = load %struct.sv**, %struct.sv*** %sp, align 8
  %call15 = call %struct.sv** @Perl_stack_grow(%struct.sv** %15, %struct.sv** %16, i32 1)
  store %struct.sv** %call15, %struct.sv*** %sp, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %17 = load %struct.sv*, %struct.sv** %av, align 8
  %18 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr16 = getelementptr inbounds %struct.sv*, %struct.sv** %18, i32 1
  store %struct.sv** %incdec.ptr16, %struct.sv*** %sp, align 8
  store %struct.sv* %17, %struct.sv** %incdec.ptr16, align 8
  store %struct.sv* %17, %struct.sv** %tmp
  %19 = load %struct.sv*, %struct.sv** %tmp
  %20 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %20, %struct.sv*** @PL_stack_sp, align 8
  %21 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %21, i32 0, i32 0
  %22 = load %struct.op*, %struct.op** %op_next, align 8
  ret %struct.op* %22
}

declare %struct.av* @Perl_av_make(i32, %struct.sv**) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_anonhash() #0 {
entry:
  %sp = alloca %struct.sv**, align 8
  %mark = alloca %struct.sv**, align 8
  %origmark = alloca i32, align 4
  %hv = alloca %struct.hv*, align 8
  %key = alloca %struct.sv*, align 8
  %val = alloca %struct.sv*, align 8
  %tmp = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %2 = load i32*, i32** @PL_markstack_ptr, align 8
  %incdec.ptr = getelementptr inbounds i32, i32* %2, i32 -1
  store i32* %incdec.ptr, i32** @PL_markstack_ptr, align 8
  %3 = load i32, i32* %2, align 4
  %idx.ext = sext i32 %3 to i64
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %1, i64 %idx.ext
  store %struct.sv** %add.ptr, %struct.sv*** %mark, align 8
  %4 = load %struct.sv**, %struct.sv*** %mark, align 8
  %5 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %4 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %5 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %conv = trunc i64 %sub.ptr.div to i32
  store i32 %conv, i32* %origmark, align 4
  %call = call %struct.hv* @Perl_newHV()
  %6 = bitcast %struct.hv* %call to %struct.sv*
  %call1 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %6)
  %7 = bitcast %struct.sv* %call1 to %struct.hv*
  store %struct.hv* %7, %struct.hv** %hv, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end.28, %entry
  %8 = load %struct.sv**, %struct.sv*** %mark, align 8
  %9 = load %struct.sv**, %struct.sv*** %sp, align 8
  %cmp = icmp ult %struct.sv** %8, %9
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %10 = load %struct.sv**, %struct.sv*** %mark, align 8
  %incdec.ptr3 = getelementptr inbounds %struct.sv*, %struct.sv** %10, i32 1
  store %struct.sv** %incdec.ptr3, %struct.sv*** %mark, align 8
  %11 = load %struct.sv*, %struct.sv** %incdec.ptr3, align 8
  store %struct.sv* %11, %struct.sv** %key, align 8
  %call4 = call %struct.sv* @Perl_newSV(i64 0)
  store %struct.sv* %call4, %struct.sv** %val, align 8
  %12 = load %struct.sv**, %struct.sv*** %mark, align 8
  %13 = load %struct.sv**, %struct.sv*** %sp, align 8
  %cmp5 = icmp ult %struct.sv** %12, %13
  br i1 %cmp5, label %if.then, label %if.else

if.then:                                          ; preds = %while.body
  %14 = load %struct.sv*, %struct.sv** %val, align 8
  %15 = load %struct.sv**, %struct.sv*** %mark, align 8
  %incdec.ptr7 = getelementptr inbounds %struct.sv*, %struct.sv** %15, i32 1
  store %struct.sv** %incdec.ptr7, %struct.sv*** %mark, align 8
  %16 = load %struct.sv*, %struct.sv** %incdec.ptr7, align 8
  call void @Perl_sv_setsv_flags(%struct.sv* %14, %struct.sv* %16, i32 2)
  br label %if.end.28

if.else:                                          ; preds = %while.body
  %17 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings = getelementptr inbounds %struct.cop, %struct.cop* %17, i32 0, i32 14
  %18 = load %struct.sv*, %struct.sv** %cop_warnings, align 8
  %cmp8 = icmp ne %struct.sv* %18, null
  br i1 %cmp8, label %land.lhs.true, label %lor.lhs.false.19

land.lhs.true:                                    ; preds = %if.else
  %19 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings10 = getelementptr inbounds %struct.cop, %struct.cop* %19, i32 0, i32 14
  %20 = load %struct.sv*, %struct.sv** %cop_warnings10, align 8
  %cmp11 = icmp ne %struct.sv* %20, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 2)
  br i1 %cmp11, label %land.lhs.true.13, label %lor.lhs.false.19

land.lhs.true.13:                                 ; preds = %land.lhs.true
  %21 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings14 = getelementptr inbounds %struct.cop, %struct.cop* %21, i32 0, i32 14
  %22 = load %struct.sv*, %struct.sv** %cop_warnings14, align 8
  %cmp15 = icmp eq %struct.sv* %22, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 1)
  br i1 %cmp15, label %if.then.27, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true.13
  %23 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings17 = getelementptr inbounds %struct.cop, %struct.cop* %23, i32 0, i32 14
  %24 = load %struct.sv*, %struct.sv** %cop_warnings17, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %24, i32 0, i32 0
  %25 = load i8*, i8** %sv_any, align 8
  %26 = bitcast i8* %25 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %26, i32 0, i32 0
  %27 = load i8*, i8** %xpv_pv, align 8
  %arrayidx = getelementptr inbounds i8, i8* %27, i64 3
  %28 = load i8, i8* %arrayidx, align 1
  %conv18 = sext i8 %28 to i32
  %and = and i32 %conv18, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then.27, label %lor.lhs.false.19

lor.lhs.false.19:                                 ; preds = %lor.lhs.false, %land.lhs.true, %if.else
  %29 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings20 = getelementptr inbounds %struct.cop, %struct.cop* %29, i32 0, i32 14
  %30 = load %struct.sv*, %struct.sv** %cop_warnings20, align 8
  %cmp21 = icmp eq %struct.sv* %30, null
  br i1 %cmp21, label %land.lhs.true.23, label %if.end

land.lhs.true.23:                                 ; preds = %lor.lhs.false.19
  %31 = load i8, i8* @PL_dowarn, align 1
  %conv24 = zext i8 %31 to i32
  %and25 = and i32 %conv24, 1
  %tobool26 = icmp ne i32 %and25, 0
  br i1 %tobool26, label %if.then.27, label %if.end

if.then.27:                                       ; preds = %land.lhs.true.23, %lor.lhs.false, %land.lhs.true.13
  call void (i32, i8*, ...) @Perl_warner(i32 12, i8* getelementptr inbounds ([41 x i8], [41 x i8]* @.str.42, i32 0, i32 0))
  br label %if.end

if.end:                                           ; preds = %if.then.27, %land.lhs.true.23, %lor.lhs.false.19
  br label %if.end.28

if.end.28:                                        ; preds = %if.end, %if.then
  %32 = load %struct.hv*, %struct.hv** %hv, align 8
  %33 = load %struct.sv*, %struct.sv** %key, align 8
  %34 = load %struct.sv*, %struct.sv** %val, align 8
  %call29 = call %struct.he* @Perl_hv_store_ent(%struct.hv* %32, %struct.sv* %33, %struct.sv* %34, i32 0)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %35 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %36 = load i32, i32* %origmark, align 4
  %idx.ext30 = sext i32 %36 to i64
  %add.ptr31 = getelementptr inbounds %struct.sv*, %struct.sv** %35, i64 %idx.ext30
  store %struct.sv** %add.ptr31, %struct.sv*** %sp, align 8
  %37 = load %struct.sv**, %struct.sv*** @PL_stack_max, align 8
  %38 = load %struct.sv**, %struct.sv*** %sp, align 8
  %sub.ptr.lhs.cast32 = ptrtoint %struct.sv** %37 to i64
  %sub.ptr.rhs.cast33 = ptrtoint %struct.sv** %38 to i64
  %sub.ptr.sub34 = sub i64 %sub.ptr.lhs.cast32, %sub.ptr.rhs.cast33
  %sub.ptr.div35 = sdiv exact i64 %sub.ptr.sub34, 8
  %cmp36 = icmp slt i64 %sub.ptr.div35, 1
  br i1 %cmp36, label %if.then.38, label %if.end.40

if.then.38:                                       ; preds = %while.end
  %39 = load %struct.sv**, %struct.sv*** %sp, align 8
  %40 = load %struct.sv**, %struct.sv*** %sp, align 8
  %call39 = call %struct.sv** @Perl_stack_grow(%struct.sv** %39, %struct.sv** %40, i32 1)
  store %struct.sv** %call39, %struct.sv*** %sp, align 8
  br label %if.end.40

if.end.40:                                        ; preds = %if.then.38, %while.end
  %41 = load %struct.hv*, %struct.hv** %hv, align 8
  %42 = bitcast %struct.hv* %41 to %struct.sv*
  %43 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr41 = getelementptr inbounds %struct.sv*, %struct.sv** %43, i32 1
  store %struct.sv** %incdec.ptr41, %struct.sv*** %sp, align 8
  store %struct.sv* %42, %struct.sv** %incdec.ptr41, align 8
  store %struct.sv* %42, %struct.sv** %tmp
  %44 = load %struct.sv*, %struct.sv** %tmp
  %45 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %45, %struct.sv*** @PL_stack_sp, align 8
  %46 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %46, i32 0, i32 0
  %47 = load %struct.op*, %struct.op** %op_next, align 8
  ret %struct.op* %47
}

declare %struct.hv* @Perl_newHV() #1

declare %struct.he* @Perl_hv_store_ent(%struct.hv*, %struct.sv*, %struct.sv*, i32) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_splice() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %mark = alloca %struct.sv**, align 8
  %origmark = alloca i32, align 4
  %ary = alloca %struct.av*, align 8
  %src = alloca %struct.sv**, align 8
  %dst = alloca %struct.sv**, align 8
  %i = alloca i32, align 4
  %offset = alloca i32, align 4
  %length = alloca i32, align 4
  %newlen = alloca i32, align 4
  %after = alloca i32, align 4
  %diff = alloca i32, align 4
  %tmparyval = alloca %struct.sv**, align 8
  %mg = alloca %struct.magic*, align 8
  %tmp = alloca i32, align 4
  %h = alloca %struct.sv*, align 8
  %markoff = alloca i32, align 4
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %2 = load i32*, i32** @PL_markstack_ptr, align 8
  %incdec.ptr = getelementptr inbounds i32, i32* %2, i32 -1
  store i32* %incdec.ptr, i32** @PL_markstack_ptr, align 8
  %3 = load i32, i32* %2, align 4
  %idx.ext = sext i32 %3 to i64
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %1, i64 %idx.ext
  store %struct.sv** %add.ptr, %struct.sv*** %mark, align 8
  %4 = load %struct.sv**, %struct.sv*** %mark, align 8
  %5 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %4 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %5 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %conv = trunc i64 %sub.ptr.div to i32
  store i32 %conv, i32* %origmark, align 4
  %6 = load %struct.sv**, %struct.sv*** %mark, align 8
  %incdec.ptr1 = getelementptr inbounds %struct.sv*, %struct.sv** %6, i32 1
  store %struct.sv** %incdec.ptr1, %struct.sv*** %mark, align 8
  %7 = load %struct.sv*, %struct.sv** %incdec.ptr1, align 8
  %8 = bitcast %struct.sv* %7 to %struct.av*
  store %struct.av* %8, %struct.av** %ary, align 8
  store %struct.sv** null, %struct.sv*** %tmparyval, align 8
  %9 = load %struct.av*, %struct.av** %ary, align 8
  %10 = bitcast %struct.av* %9 to %struct.sv*
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %10, i32 0, i32 2
  %11 = load i32, i32* %sv_flags, align 4
  %and = and i32 %11, 32768
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %12 = load %struct.av*, %struct.av** %ary, align 8
  %13 = bitcast %struct.av* %12 to %struct.sv*
  %call = call %struct.magic* @Perl_mg_find(%struct.sv* %13, i32 80)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.magic* [ %call, %cond.true ], [ null, %cond.false ]
  store %struct.magic* %cond, %struct.magic** %mg, align 8
  %tobool2 = icmp ne %struct.magic* %cond, null
  br i1 %tobool2, label %if.then, label %if.end.48

if.then:                                          ; preds = %cond.end
  %14 = load %struct.magic*, %struct.magic** %mg, align 8
  %mg_obj = getelementptr inbounds %struct.magic, %struct.magic* %14, i32 0, i32 5
  %15 = load %struct.sv*, %struct.sv** %mg_obj, align 8
  %tobool3 = icmp ne %struct.sv* %15, null
  br i1 %tobool3, label %cond.true.4, label %cond.false.6

cond.true.4:                                      ; preds = %if.then
  %16 = load %struct.magic*, %struct.magic** %mg, align 8
  %mg_obj5 = getelementptr inbounds %struct.magic, %struct.magic* %16, i32 0, i32 5
  %17 = load %struct.sv*, %struct.sv** %mg_obj5, align 8
  br label %cond.end.9

cond.false.6:                                     ; preds = %if.then
  %18 = load %struct.av*, %struct.av** %ary, align 8
  %19 = bitcast %struct.av* %18 to %struct.sv*
  %call7 = call %struct.sv* @Perl_newRV(%struct.sv* %19)
  %call8 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call7)
  br label %cond.end.9

cond.end.9:                                       ; preds = %cond.false.6, %cond.true.4
  %cond10 = phi %struct.sv* [ %17, %cond.true.4 ], [ %call8, %cond.false.6 ]
  %20 = load %struct.sv**, %struct.sv*** %mark, align 8
  %incdec.ptr11 = getelementptr inbounds %struct.sv*, %struct.sv** %20, i32 -1
  store %struct.sv** %incdec.ptr11, %struct.sv*** %mark, align 8
  store %struct.sv* %cond10, %struct.sv** %20, align 8
  %21 = load i32*, i32** @PL_markstack_ptr, align 8
  %incdec.ptr12 = getelementptr inbounds i32, i32* %21, i32 1
  store i32* %incdec.ptr12, i32** @PL_markstack_ptr, align 8
  %22 = load i32*, i32** @PL_markstack_max, align 8
  %cmp = icmp eq i32* %incdec.ptr12, %22
  br i1 %cmp, label %if.then.14, label %if.end

if.then.14:                                       ; preds = %cond.end.9
  call void @Perl_markstack_grow()
  br label %if.end

if.end:                                           ; preds = %if.then.14, %cond.end.9
  %23 = load %struct.sv**, %struct.sv*** %mark, align 8
  %24 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %sub.ptr.lhs.cast15 = ptrtoint %struct.sv** %23 to i64
  %sub.ptr.rhs.cast16 = ptrtoint %struct.sv** %24 to i64
  %sub.ptr.sub17 = sub i64 %sub.ptr.lhs.cast15, %sub.ptr.rhs.cast16
  %sub.ptr.div18 = sdiv exact i64 %sub.ptr.sub17, 8
  %conv19 = trunc i64 %sub.ptr.div18 to i32
  %25 = load i32*, i32** @PL_markstack_ptr, align 8
  store i32 %conv19, i32* %25, align 4
  store i32 %conv19, i32* %tmp
  %26 = load i32, i32* %tmp
  %27 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %27, %struct.sv*** @PL_stack_sp, align 8
  call void @Perl_push_scope()
  %28 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %28, i32 0, i32 6
  %29 = load i8, i8* %op_flags, align 1
  %conv20 = zext i8 %29 to i32
  %and21 = and i32 %conv20, 3
  %cmp22 = icmp eq i32 %and21, 1
  br i1 %cmp22, label %cond.true.24, label %cond.false.25

cond.true.24:                                     ; preds = %if.end
  br label %cond.end.45

cond.false.25:                                    ; preds = %if.end
  %30 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags26 = getelementptr inbounds %struct.op, %struct.op* %30, i32 0, i32 6
  %31 = load i8, i8* %op_flags26, align 1
  %conv27 = zext i8 %31 to i32
  %and28 = and i32 %conv27, 3
  %cmp29 = icmp eq i32 %and28, 2
  br i1 %cmp29, label %cond.true.31, label %cond.false.32

cond.true.31:                                     ; preds = %cond.false.25
  br label %cond.end.43

cond.false.32:                                    ; preds = %cond.false.25
  %32 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags33 = getelementptr inbounds %struct.op, %struct.op* %32, i32 0, i32 6
  %33 = load i8, i8* %op_flags33, align 1
  %conv34 = zext i8 %33 to i32
  %and35 = and i32 %conv34, 3
  %cmp36 = icmp eq i32 %and35, 3
  br i1 %cmp36, label %cond.true.38, label %cond.false.39

cond.true.38:                                     ; preds = %cond.false.32
  br label %cond.end.41

cond.false.39:                                    ; preds = %cond.false.32
  %call40 = call i32 @Perl_block_gimme()
  br label %cond.end.41

cond.end.41:                                      ; preds = %cond.false.39, %cond.true.38
  %cond42 = phi i32 [ 1, %cond.true.38 ], [ %call40, %cond.false.39 ]
  br label %cond.end.43

cond.end.43:                                      ; preds = %cond.end.41, %cond.true.31
  %cond44 = phi i32 [ 0, %cond.true.31 ], [ %cond42, %cond.end.41 ]
  br label %cond.end.45

cond.end.45:                                      ; preds = %cond.end.43, %cond.true.24
  %cond46 = phi i32 [ 128, %cond.true.24 ], [ %cond44, %cond.end.43 ]
  %call47 = call i32 @Perl_call_method(i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.43, i32 0, i32 0), i32 %cond46)
  call void @Perl_pop_scope()
  %34 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %34, %struct.sv*** %sp, align 8
  %35 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %35, %struct.sv*** @PL_stack_sp, align 8
  %36 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %36, i32 0, i32 0
  %37 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %37, %struct.op** %retval
  br label %return

if.end.48:                                        ; preds = %cond.end
  %38 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr49 = getelementptr inbounds %struct.sv*, %struct.sv** %38, i32 1
  store %struct.sv** %incdec.ptr49, %struct.sv*** %sp, align 8
  %39 = load %struct.sv**, %struct.sv*** %mark, align 8
  %incdec.ptr50 = getelementptr inbounds %struct.sv*, %struct.sv** %39, i32 1
  store %struct.sv** %incdec.ptr50, %struct.sv*** %mark, align 8
  %40 = load %struct.sv**, %struct.sv*** %sp, align 8
  %cmp51 = icmp ult %struct.sv** %incdec.ptr50, %40
  br i1 %cmp51, label %if.then.53, label %if.else.113

if.then.53:                                       ; preds = %if.end.48
  %41 = load %struct.sv**, %struct.sv*** %mark, align 8
  %42 = load %struct.sv*, %struct.sv** %41, align 8
  store %struct.sv* %42, %struct.sv** @PL_Sv, align 8
  %43 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags54 = getelementptr inbounds %struct.sv, %struct.sv* %43, i32 0, i32 2
  %44 = load i32, i32* %sv_flags54, align 4
  %and55 = and i32 %44, 65536
  %tobool56 = icmp ne i32 %and55, 0
  br i1 %tobool56, label %cond.true.57, label %cond.false.58

cond.true.57:                                     ; preds = %if.then.53
  %45 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %45, i32 0, i32 0
  %46 = load i8*, i8** %sv_any, align 8
  %47 = bitcast i8* %46 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %47, i32 0, i32 3
  %48 = load i64, i64* %xiv_iv, align 8
  br label %cond.end.60

cond.false.58:                                    ; preds = %if.then.53
  %49 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call59 = call i64 @Perl_sv_2iv(%struct.sv* %49)
  br label %cond.end.60

cond.end.60:                                      ; preds = %cond.false.58, %cond.true.57
  %cond61 = phi i64 [ %48, %cond.true.57 ], [ %call59, %cond.false.58 ]
  %conv62 = trunc i64 %cond61 to i32
  store i32 %conv62, i32* %i, align 4
  store i32 %conv62, i32* %offset, align 4
  %50 = load i32, i32* %offset, align 4
  %cmp63 = icmp slt i32 %50, 0
  br i1 %cmp63, label %if.then.65, label %if.else

if.then.65:                                       ; preds = %cond.end.60
  %51 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any66 = getelementptr inbounds %struct.av, %struct.av* %51, i32 0, i32 0
  %52 = load %struct.xpvav*, %struct.xpvav** %sv_any66, align 8
  %xav_fill = getelementptr inbounds %struct.xpvav, %struct.xpvav* %52, i32 0, i32 1
  %53 = load i64, i64* %xav_fill, align 8
  %add = add nsw i64 %53, 1
  %54 = load i32, i32* %offset, align 4
  %conv67 = sext i32 %54 to i64
  %add68 = add nsw i64 %conv67, %add
  %conv69 = trunc i64 %add68 to i32
  store i32 %conv69, i32* %offset, align 4
  br label %if.end.70

if.else:                                          ; preds = %cond.end.60
  %55 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_arybase = getelementptr inbounds %struct.cop, %struct.cop* %55, i32 0, i32 12
  %56 = load i32, i32* %cop_arybase, align 4
  %57 = load i32, i32* %offset, align 4
  %sub = sub nsw i32 %57, %56
  store i32 %sub, i32* %offset, align 4
  br label %if.end.70

if.end.70:                                        ; preds = %if.else, %if.then.65
  %58 = load i32, i32* %offset, align 4
  %cmp71 = icmp slt i32 %58, 0
  br i1 %cmp71, label %if.then.73, label %if.end.75

if.then.73:                                       ; preds = %if.end.70
  %59 = load i32, i32* %i, align 4
  %call74 = call %struct.op* (i8*, ...) @Perl_die(i8* getelementptr inbounds ([0 x i8], [0 x i8]* @PL_no_aelem, i32 0, i32 0), i32 %59)
  store %struct.op* %call74, %struct.op** %retval
  br label %return

if.end.75:                                        ; preds = %if.end.70
  %60 = load %struct.sv**, %struct.sv*** %mark, align 8
  %incdec.ptr76 = getelementptr inbounds %struct.sv*, %struct.sv** %60, i32 1
  store %struct.sv** %incdec.ptr76, %struct.sv*** %mark, align 8
  %61 = load %struct.sv**, %struct.sv*** %sp, align 8
  %cmp77 = icmp ult %struct.sv** %incdec.ptr76, %61
  br i1 %cmp77, label %if.then.79, label %if.else.108

if.then.79:                                       ; preds = %if.end.75
  %62 = load %struct.sv**, %struct.sv*** %mark, align 8
  %incdec.ptr80 = getelementptr inbounds %struct.sv*, %struct.sv** %62, i32 1
  store %struct.sv** %incdec.ptr80, %struct.sv*** %mark, align 8
  %63 = load %struct.sv*, %struct.sv** %62, align 8
  store %struct.sv* %63, %struct.sv** @PL_Sv, align 8
  %64 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags81 = getelementptr inbounds %struct.sv, %struct.sv* %64, i32 0, i32 2
  %65 = load i32, i32* %sv_flags81, align 4
  %and82 = and i32 %65, 65536
  %tobool83 = icmp ne i32 %and82, 0
  br i1 %tobool83, label %cond.true.84, label %cond.false.87

cond.true.84:                                     ; preds = %if.then.79
  %66 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any85 = getelementptr inbounds %struct.sv, %struct.sv* %66, i32 0, i32 0
  %67 = load i8*, i8** %sv_any85, align 8
  %68 = bitcast i8* %67 to %struct.xpviv*
  %xiv_iv86 = getelementptr inbounds %struct.xpviv, %struct.xpviv* %68, i32 0, i32 3
  %69 = load i64, i64* %xiv_iv86, align 8
  br label %cond.end.89

cond.false.87:                                    ; preds = %if.then.79
  %70 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call88 = call i64 @Perl_sv_2iv(%struct.sv* %70)
  br label %cond.end.89

cond.end.89:                                      ; preds = %cond.false.87, %cond.true.84
  %cond90 = phi i64 [ %69, %cond.true.84 ], [ %call88, %cond.false.87 ]
  %conv91 = trunc i64 %cond90 to i32
  store i32 %conv91, i32* %length, align 4
  %71 = load i32, i32* %length, align 4
  %cmp92 = icmp slt i32 %71, 0
  br i1 %cmp92, label %if.then.94, label %if.end.107

if.then.94:                                       ; preds = %cond.end.89
  %72 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any95 = getelementptr inbounds %struct.av, %struct.av* %72, i32 0, i32 0
  %73 = load %struct.xpvav*, %struct.xpvav** %sv_any95, align 8
  %xav_fill96 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %73, i32 0, i32 1
  %74 = load i64, i64* %xav_fill96, align 8
  %75 = load i32, i32* %offset, align 4
  %conv97 = sext i32 %75 to i64
  %sub98 = sub nsw i64 %74, %conv97
  %add99 = add nsw i64 %sub98, 1
  %76 = load i32, i32* %length, align 4
  %conv100 = sext i32 %76 to i64
  %add101 = add nsw i64 %conv100, %add99
  %conv102 = trunc i64 %add101 to i32
  store i32 %conv102, i32* %length, align 4
  %77 = load i32, i32* %length, align 4
  %cmp103 = icmp slt i32 %77, 0
  br i1 %cmp103, label %if.then.105, label %if.end.106

if.then.105:                                      ; preds = %if.then.94
  store i32 0, i32* %length, align 4
  br label %if.end.106

if.end.106:                                       ; preds = %if.then.105, %if.then.94
  br label %if.end.107

if.end.107:                                       ; preds = %if.end.106, %cond.end.89
  br label %if.end.112

if.else.108:                                      ; preds = %if.end.75
  %78 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any109 = getelementptr inbounds %struct.av, %struct.av* %78, i32 0, i32 0
  %79 = load %struct.xpvav*, %struct.xpvav** %sv_any109, align 8
  %xav_max = getelementptr inbounds %struct.xpvav, %struct.xpvav* %79, i32 0, i32 2
  %80 = load i64, i64* %xav_max, align 8
  %add110 = add nsw i64 %80, 1
  %conv111 = trunc i64 %add110 to i32
  store i32 %conv111, i32* %length, align 4
  br label %if.end.112

if.end.112:                                       ; preds = %if.else.108, %if.end.107
  br label %if.end.118

if.else.113:                                      ; preds = %if.end.48
  store i32 0, i32* %offset, align 4
  %81 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any114 = getelementptr inbounds %struct.av, %struct.av* %81, i32 0, i32 0
  %82 = load %struct.xpvav*, %struct.xpvav** %sv_any114, align 8
  %xav_max115 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %82, i32 0, i32 2
  %83 = load i64, i64* %xav_max115, align 8
  %add116 = add nsw i64 %83, 1
  %conv117 = trunc i64 %add116 to i32
  store i32 %conv117, i32* %length, align 4
  br label %if.end.118

if.end.118:                                       ; preds = %if.else.113, %if.end.112
  %84 = load i32, i32* %offset, align 4
  %conv119 = sext i32 %84 to i64
  %85 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any120 = getelementptr inbounds %struct.av, %struct.av* %85, i32 0, i32 0
  %86 = load %struct.xpvav*, %struct.xpvav** %sv_any120, align 8
  %xav_fill121 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %86, i32 0, i32 1
  %87 = load i64, i64* %xav_fill121, align 8
  %add122 = add nsw i64 %87, 1
  %cmp123 = icmp sgt i64 %conv119, %add122
  br i1 %cmp123, label %if.then.125, label %if.end.154

if.then.125:                                      ; preds = %if.end.118
  %88 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings = getelementptr inbounds %struct.cop, %struct.cop* %88, i32 0, i32 14
  %89 = load %struct.sv*, %struct.sv** %cop_warnings, align 8
  %cmp126 = icmp ne %struct.sv* %89, null
  br i1 %cmp126, label %land.lhs.true, label %lor.lhs.false.140

land.lhs.true:                                    ; preds = %if.then.125
  %90 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings128 = getelementptr inbounds %struct.cop, %struct.cop* %90, i32 0, i32 14
  %91 = load %struct.sv*, %struct.sv** %cop_warnings128, align 8
  %cmp129 = icmp ne %struct.sv* %91, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 2)
  br i1 %cmp129, label %land.lhs.true.131, label %lor.lhs.false.140

land.lhs.true.131:                                ; preds = %land.lhs.true
  %92 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings132 = getelementptr inbounds %struct.cop, %struct.cop* %92, i32 0, i32 14
  %93 = load %struct.sv*, %struct.sv** %cop_warnings132, align 8
  %cmp133 = icmp eq %struct.sv* %93, getelementptr inbounds (%struct.sv, %struct.sv* null, i64 1)
  br i1 %cmp133, label %if.then.148, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true.131
  %94 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings135 = getelementptr inbounds %struct.cop, %struct.cop* %94, i32 0, i32 14
  %95 = load %struct.sv*, %struct.sv** %cop_warnings135, align 8
  %sv_any136 = getelementptr inbounds %struct.sv, %struct.sv* %95, i32 0, i32 0
  %96 = load i8*, i8** %sv_any136, align 8
  %97 = bitcast i8* %96 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %97, i32 0, i32 0
  %98 = load i8*, i8** %xpv_pv, align 8
  %arrayidx = getelementptr inbounds i8, i8* %98, i64 3
  %99 = load i8, i8* %arrayidx, align 1
  %conv137 = sext i8 %99 to i32
  %and138 = and i32 %conv137, 1
  %tobool139 = icmp ne i32 %and138, 0
  br i1 %tobool139, label %if.then.148, label %lor.lhs.false.140

lor.lhs.false.140:                                ; preds = %lor.lhs.false, %land.lhs.true, %if.then.125
  %100 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %cop_warnings141 = getelementptr inbounds %struct.cop, %struct.cop* %100, i32 0, i32 14
  %101 = load %struct.sv*, %struct.sv** %cop_warnings141, align 8
  %cmp142 = icmp eq %struct.sv* %101, null
  br i1 %cmp142, label %land.lhs.true.144, label %if.end.149

land.lhs.true.144:                                ; preds = %lor.lhs.false.140
  %102 = load i8, i8* @PL_dowarn, align 1
  %conv145 = zext i8 %102 to i32
  %and146 = and i32 %conv145, 1
  %tobool147 = icmp ne i32 %and146, 0
  br i1 %tobool147, label %if.then.148, label %if.end.149

if.then.148:                                      ; preds = %land.lhs.true.144, %lor.lhs.false, %land.lhs.true.131
  call void (i32, i8*, ...) @Perl_warner(i32 12, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.44, i32 0, i32 0))
  br label %if.end.149

if.end.149:                                       ; preds = %if.then.148, %land.lhs.true.144, %lor.lhs.false.140
  %103 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any150 = getelementptr inbounds %struct.av, %struct.av* %103, i32 0, i32 0
  %104 = load %struct.xpvav*, %struct.xpvav** %sv_any150, align 8
  %xav_fill151 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %104, i32 0, i32 1
  %105 = load i64, i64* %xav_fill151, align 8
  %add152 = add nsw i64 %105, 1
  %conv153 = trunc i64 %add152 to i32
  store i32 %conv153, i32* %offset, align 4
  br label %if.end.154

if.end.154:                                       ; preds = %if.end.149, %if.end.118
  %106 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any155 = getelementptr inbounds %struct.av, %struct.av* %106, i32 0, i32 0
  %107 = load %struct.xpvav*, %struct.xpvav** %sv_any155, align 8
  %xav_fill156 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %107, i32 0, i32 1
  %108 = load i64, i64* %xav_fill156, align 8
  %add157 = add nsw i64 %108, 1
  %109 = load i32, i32* %offset, align 4
  %110 = load i32, i32* %length, align 4
  %add158 = add nsw i32 %109, %110
  %conv159 = sext i32 %add158 to i64
  %sub160 = sub nsw i64 %add157, %conv159
  %conv161 = trunc i64 %sub160 to i32
  store i32 %conv161, i32* %after, align 4
  %111 = load i32, i32* %after, align 4
  %cmp162 = icmp slt i32 %111, 0
  br i1 %cmp162, label %if.then.164, label %if.end.170

if.then.164:                                      ; preds = %if.end.154
  %112 = load i32, i32* %after, align 4
  %113 = load i32, i32* %length, align 4
  %add165 = add nsw i32 %113, %112
  store i32 %add165, i32* %length, align 4
  store i32 0, i32* %after, align 4
  %114 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any166 = getelementptr inbounds %struct.av, %struct.av* %114, i32 0, i32 0
  %115 = load %struct.xpvav*, %struct.xpvav** %sv_any166, align 8
  %xav_alloc = getelementptr inbounds %struct.xpvav, %struct.xpvav* %115, i32 0, i32 7
  %116 = load %struct.sv**, %struct.sv*** %xav_alloc, align 8
  %tobool167 = icmp ne %struct.sv** %116, null
  br i1 %tobool167, label %if.end.169, label %if.then.168

if.then.168:                                      ; preds = %if.then.164
  %117 = load %struct.av*, %struct.av** %ary, align 8
  call void @Perl_av_extend(%struct.av* %117, i32 0)
  br label %if.end.169

if.end.169:                                       ; preds = %if.then.168, %if.then.164
  br label %if.end.170

if.end.170:                                       ; preds = %if.end.169, %if.end.154
  %118 = load %struct.sv**, %struct.sv*** %sp, align 8
  %119 = load %struct.sv**, %struct.sv*** %mark, align 8
  %sub.ptr.lhs.cast171 = ptrtoint %struct.sv** %118 to i64
  %sub.ptr.rhs.cast172 = ptrtoint %struct.sv** %119 to i64
  %sub.ptr.sub173 = sub i64 %sub.ptr.lhs.cast171, %sub.ptr.rhs.cast172
  %sub.ptr.div174 = sdiv exact i64 %sub.ptr.sub173, 8
  %conv175 = trunc i64 %sub.ptr.div174 to i32
  store i32 %conv175, i32* %newlen, align 4
  %120 = load i32, i32* %newlen, align 4
  %121 = load i32, i32* %length, align 4
  %sub176 = sub nsw i32 %120, %121
  store i32 %sub176, i32* %diff, align 4
  %122 = load i32, i32* %newlen, align 4
  %tobool177 = icmp ne i32 %122, 0
  br i1 %tobool177, label %land.lhs.true.178, label %if.end.190

land.lhs.true.178:                                ; preds = %if.end.170
  %123 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any179 = getelementptr inbounds %struct.av, %struct.av* %123, i32 0, i32 0
  %124 = load %struct.xpvav*, %struct.xpvav** %sv_any179, align 8
  %xav_flags = getelementptr inbounds %struct.xpvav, %struct.xpvav* %124, i32 0, i32 9
  %125 = load i8, i8* %xav_flags, align 1
  %conv180 = zext i8 %125 to i32
  %and181 = and i32 %conv180, 1
  %tobool182 = icmp ne i32 %and181, 0
  br i1 %tobool182, label %if.end.190, label %land.lhs.true.183

land.lhs.true.183:                                ; preds = %land.lhs.true.178
  %126 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any184 = getelementptr inbounds %struct.av, %struct.av* %126, i32 0, i32 0
  %127 = load %struct.xpvav*, %struct.xpvav** %sv_any184, align 8
  %xav_flags185 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %127, i32 0, i32 9
  %128 = load i8, i8* %xav_flags185, align 1
  %conv186 = zext i8 %128 to i32
  %and187 = and i32 %conv186, 2
  %tobool188 = icmp ne i32 %and187, 0
  br i1 %tobool188, label %if.then.189, label %if.end.190

if.then.189:                                      ; preds = %land.lhs.true.183
  %129 = load %struct.av*, %struct.av** %ary, align 8
  call void @Perl_av_reify(%struct.av* %129)
  br label %if.end.190

if.end.190:                                       ; preds = %if.then.189, %land.lhs.true.183, %land.lhs.true.178, %if.end.170
  %130 = load %struct.sv**, %struct.sv*** %mark, align 8
  store %struct.sv** %130, %struct.sv*** %dst, align 8
  %131 = load i32, i32* %newlen, align 4
  store i32 %131, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end.190
  %132 = load i32, i32* %i, align 4
  %tobool191 = icmp ne i32 %132, 0
  br i1 %tobool191, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %133 = load %struct.sv**, %struct.sv*** %dst, align 8
  %134 = load %struct.sv*, %struct.sv** %133, align 8
  store %struct.sv* %134, %struct.sv** %h, align 8
  %135 = load %struct.sv*, %struct.sv** %h, align 8
  %call193 = call %struct.sv* @Perl_newSVsv(%struct.sv* %135)
  %136 = load %struct.sv**, %struct.sv*** %dst, align 8
  %incdec.ptr194 = getelementptr inbounds %struct.sv*, %struct.sv** %136, i32 1
  store %struct.sv** %incdec.ptr194, %struct.sv*** %dst, align 8
  store %struct.sv* %call193, %struct.sv** %136, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %137 = load i32, i32* %i, align 4
  %dec = add nsw i32 %137, -1
  store i32 %dec, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %138 = load i32, i32* %diff, align 4
  %cmp195 = icmp slt i32 %138, 0
  br i1 %cmp195, label %if.then.197, label %if.else.374

if.then.197:                                      ; preds = %for.end
  %139 = load i32, i32* %newlen, align 4
  %tobool198 = icmp ne i32 %139, 0
  br i1 %tobool198, label %if.then.199, label %if.end.204

if.then.199:                                      ; preds = %if.then.197
  %140 = load i32, i32* %newlen, align 4
  %conv200 = sext i32 %140 to i64
  %mul = mul i64 %conv200, 8
  %call201 = call i8* @Perl_safesysmalloc(i64 %mul)
  %141 = bitcast i8* %call201 to %struct.sv**
  store %struct.sv** %141, %struct.sv*** %tmparyval, align 8
  %142 = load %struct.sv**, %struct.sv*** %tmparyval, align 8
  %143 = bitcast %struct.sv** %142 to i8*
  %144 = load %struct.sv**, %struct.sv*** %mark, align 8
  %145 = bitcast %struct.sv** %144 to i8*
  %146 = load i32, i32* %newlen, align 4
  %conv202 = sext i32 %146 to i64
  %mul203 = mul i64 %conv202, 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %143, i8* %145, i64 %mul203, i32 1, i1 false)
  br label %if.end.204

if.end.204:                                       ; preds = %if.then.199, %if.then.197
  %147 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %148 = load i32, i32* %origmark, align 4
  %idx.ext205 = sext i32 %148 to i64
  %add.ptr206 = getelementptr inbounds %struct.sv*, %struct.sv** %147, i64 %idx.ext205
  %add.ptr207 = getelementptr inbounds %struct.sv*, %struct.sv** %add.ptr206, i64 1
  store %struct.sv** %add.ptr207, %struct.sv*** %mark, align 8
  %149 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags208 = getelementptr inbounds %struct.op, %struct.op* %149, i32 0, i32 6
  %150 = load i8, i8* %op_flags208, align 1
  %conv209 = zext i8 %150 to i32
  %and210 = and i32 %conv209, 3
  %tobool211 = icmp ne i32 %and210, 0
  br i1 %tobool211, label %cond.true.212, label %cond.false.219

cond.true.212:                                    ; preds = %if.end.204
  %151 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags213 = getelementptr inbounds %struct.op, %struct.op* %151, i32 0, i32 6
  %152 = load i8, i8* %op_flags213, align 1
  %conv214 = zext i8 %152 to i32
  %and215 = and i32 %conv214, 3
  %cmp216 = icmp eq i32 %and215, 3
  %cond218 = select i1 %cmp216, i32 1, i32 0
  br label %cond.end.221

cond.false.219:                                   ; preds = %if.end.204
  %call220 = call i32 @Perl_dowantarray()
  br label %cond.end.221

cond.end.221:                                     ; preds = %cond.false.219, %cond.true.212
  %cond222 = phi i32 [ %cond218, %cond.true.212 ], [ %call220, %cond.false.219 ]
  %cmp223 = icmp eq i32 %cond222, 1
  br i1 %cmp223, label %if.then.225, label %if.else.272

if.then.225:                                      ; preds = %cond.end.221
  %153 = load %struct.sv**, %struct.sv*** @PL_stack_max, align 8
  %154 = load %struct.sv**, %struct.sv*** %mark, align 8
  %sub.ptr.lhs.cast226 = ptrtoint %struct.sv** %153 to i64
  %sub.ptr.rhs.cast227 = ptrtoint %struct.sv** %154 to i64
  %sub.ptr.sub228 = sub i64 %sub.ptr.lhs.cast226, %sub.ptr.rhs.cast227
  %sub.ptr.div229 = sdiv exact i64 %sub.ptr.sub228, 8
  %155 = load i32, i32* %length, align 4
  %conv230 = sext i32 %155 to i64
  %cmp231 = icmp slt i64 %sub.ptr.div229, %conv230
  br i1 %cmp231, label %if.then.233, label %if.end.243

if.then.233:                                      ; preds = %if.then.225
  %156 = load %struct.sv**, %struct.sv*** %mark, align 8
  %157 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %sub.ptr.lhs.cast235 = ptrtoint %struct.sv** %156 to i64
  %sub.ptr.rhs.cast236 = ptrtoint %struct.sv** %157 to i64
  %sub.ptr.sub237 = sub i64 %sub.ptr.lhs.cast235, %sub.ptr.rhs.cast236
  %sub.ptr.div238 = sdiv exact i64 %sub.ptr.sub237, 8
  %conv239 = trunc i64 %sub.ptr.div238 to i32
  store i32 %conv239, i32* %markoff, align 4
  %158 = load %struct.sv**, %struct.sv*** %sp, align 8
  %159 = load %struct.sv**, %struct.sv*** %mark, align 8
  %160 = load i32, i32* %length, align 4
  %call240 = call %struct.sv** @Perl_stack_grow(%struct.sv** %158, %struct.sv** %159, i32 %160)
  store %struct.sv** %call240, %struct.sv*** %sp, align 8
  %161 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %162 = load i32, i32* %markoff, align 4
  %idx.ext241 = sext i32 %162 to i64
  %add.ptr242 = getelementptr inbounds %struct.sv*, %struct.sv** %161, i64 %idx.ext241
  store %struct.sv** %add.ptr242, %struct.sv*** %mark, align 8
  br label %if.end.243

if.end.243:                                       ; preds = %if.then.233, %if.then.225
  %163 = load %struct.sv**, %struct.sv*** %mark, align 8
  %164 = bitcast %struct.sv** %163 to i8*
  %165 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any244 = getelementptr inbounds %struct.av, %struct.av* %165, i32 0, i32 0
  %166 = load %struct.xpvav*, %struct.xpvav** %sv_any244, align 8
  %xav_array = getelementptr inbounds %struct.xpvav, %struct.xpvav* %166, i32 0, i32 0
  %167 = load i8*, i8** %xav_array, align 8
  %168 = bitcast i8* %167 to %struct.sv**
  %169 = load i32, i32* %offset, align 4
  %idx.ext245 = sext i32 %169 to i64
  %add.ptr246 = getelementptr inbounds %struct.sv*, %struct.sv** %168, i64 %idx.ext245
  %170 = bitcast %struct.sv** %add.ptr246 to i8*
  %171 = load i32, i32* %length, align 4
  %conv247 = sext i32 %171 to i64
  %mul248 = mul i64 %conv247, 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %164, i8* %170, i64 %mul248, i32 1, i1 false)
  %172 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any249 = getelementptr inbounds %struct.av, %struct.av* %172, i32 0, i32 0
  %173 = load %struct.xpvav*, %struct.xpvav** %sv_any249, align 8
  %xav_flags250 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %173, i32 0, i32 9
  %174 = load i8, i8* %xav_flags250, align 1
  %conv251 = zext i8 %174 to i32
  %and252 = and i32 %conv251, 1
  %tobool253 = icmp ne i32 %and252, 0
  br i1 %tobool253, label %if.then.254, label %if.end.268

if.then.254:                                      ; preds = %if.end.243
  %175 = load i32, i32* @PL_tmps_ix, align 4
  %176 = load i32, i32* %length, align 4
  %add255 = add nsw i32 %175, %176
  %177 = load i32, i32* @PL_tmps_max, align 4
  %cmp256 = icmp sge i32 %add255, %177
  br i1 %cmp256, label %if.then.258, label %if.end.259

if.then.258:                                      ; preds = %if.then.254
  %178 = load i32, i32* %length, align 4
  call void @Perl_tmps_grow(i32 %178)
  br label %if.end.259

if.end.259:                                       ; preds = %if.then.258, %if.then.254
  %179 = load i32, i32* %length, align 4
  store i32 %179, i32* %i, align 4
  %180 = load %struct.sv**, %struct.sv*** %mark, align 8
  store %struct.sv** %180, %struct.sv*** %dst, align 8
  br label %for.cond.260

for.cond.260:                                     ; preds = %for.inc.265, %if.end.259
  %181 = load i32, i32* %i, align 4
  %tobool261 = icmp ne i32 %181, 0
  br i1 %tobool261, label %for.body.262, label %for.end.267

for.body.262:                                     ; preds = %for.cond.260
  %182 = load %struct.sv**, %struct.sv*** %dst, align 8
  %183 = load %struct.sv*, %struct.sv** %182, align 8
  %call263 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %183)
  %184 = load %struct.sv**, %struct.sv*** %dst, align 8
  %incdec.ptr264 = getelementptr inbounds %struct.sv*, %struct.sv** %184, i32 1
  store %struct.sv** %incdec.ptr264, %struct.sv*** %dst, align 8
  br label %for.inc.265

for.inc.265:                                      ; preds = %for.body.262
  %185 = load i32, i32* %i, align 4
  %dec266 = add nsw i32 %185, -1
  store i32 %dec266, i32* %i, align 4
  br label %for.cond.260

for.end.267:                                      ; preds = %for.cond.260
  br label %if.end.268

if.end.268:                                       ; preds = %for.end.267, %if.end.243
  %186 = load i32, i32* %length, align 4
  %sub269 = sub nsw i32 %186, 1
  %187 = load %struct.sv**, %struct.sv*** %mark, align 8
  %idx.ext270 = sext i32 %sub269 to i64
  %add.ptr271 = getelementptr inbounds %struct.sv*, %struct.sv** %187, i64 %idx.ext270
  store %struct.sv** %add.ptr271, %struct.sv*** %mark, align 8
  br label %if.end.299

if.else.272:                                      ; preds = %cond.end.221
  %188 = load i32, i32* %offset, align 4
  %189 = load i32, i32* %length, align 4
  %add273 = add nsw i32 %188, %189
  %sub274 = sub nsw i32 %add273, 1
  %idxprom = sext i32 %sub274 to i64
  %190 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any275 = getelementptr inbounds %struct.av, %struct.av* %190, i32 0, i32 0
  %191 = load %struct.xpvav*, %struct.xpvav** %sv_any275, align 8
  %xav_array276 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %191, i32 0, i32 0
  %192 = load i8*, i8** %xav_array276, align 8
  %193 = bitcast i8* %192 to %struct.sv**
  %arrayidx277 = getelementptr inbounds %struct.sv*, %struct.sv** %193, i64 %idxprom
  %194 = load %struct.sv*, %struct.sv** %arrayidx277, align 8
  %195 = load %struct.sv**, %struct.sv*** %mark, align 8
  store %struct.sv* %194, %struct.sv** %195, align 8
  %196 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any278 = getelementptr inbounds %struct.av, %struct.av* %196, i32 0, i32 0
  %197 = load %struct.xpvav*, %struct.xpvav** %sv_any278, align 8
  %xav_flags279 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %197, i32 0, i32 9
  %198 = load i8, i8* %xav_flags279, align 1
  %conv280 = zext i8 %198 to i32
  %and281 = and i32 %conv280, 1
  %tobool282 = icmp ne i32 %and281, 0
  br i1 %tobool282, label %if.then.283, label %if.end.298

if.then.283:                                      ; preds = %if.else.272
  %199 = load %struct.sv**, %struct.sv*** %mark, align 8
  %200 = load %struct.sv*, %struct.sv** %199, align 8
  %call284 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %200)
  %201 = load i32, i32* %length, align 4
  %sub285 = sub nsw i32 %201, 1
  store i32 %sub285, i32* %i, align 4
  %202 = load i32, i32* %offset, align 4
  %idxprom286 = sext i32 %202 to i64
  %203 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any287 = getelementptr inbounds %struct.av, %struct.av* %203, i32 0, i32 0
  %204 = load %struct.xpvav*, %struct.xpvav** %sv_any287, align 8
  %xav_array288 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %204, i32 0, i32 0
  %205 = load i8*, i8** %xav_array288, align 8
  %206 = bitcast i8* %205 to %struct.sv**
  %arrayidx289 = getelementptr inbounds %struct.sv*, %struct.sv** %206, i64 %idxprom286
  store %struct.sv** %arrayidx289, %struct.sv*** %dst, align 8
  br label %for.cond.290

for.cond.290:                                     ; preds = %for.inc.295, %if.then.283
  %207 = load i32, i32* %i, align 4
  %cmp291 = icmp sgt i32 %207, 0
  br i1 %cmp291, label %for.body.293, label %for.end.297

for.body.293:                                     ; preds = %for.cond.290
  %208 = load %struct.sv**, %struct.sv*** %dst, align 8
  %incdec.ptr294 = getelementptr inbounds %struct.sv*, %struct.sv** %208, i32 1
  store %struct.sv** %incdec.ptr294, %struct.sv*** %dst, align 8
  %209 = load %struct.sv*, %struct.sv** %208, align 8
  call void @Perl_sv_free(%struct.sv* %209)
  br label %for.inc.295

for.inc.295:                                      ; preds = %for.body.293
  %210 = load i32, i32* %i, align 4
  %dec296 = add nsw i32 %210, -1
  store i32 %dec296, i32* %i, align 4
  br label %for.cond.290

for.end.297:                                      ; preds = %for.cond.290
  br label %if.end.298

if.end.298:                                       ; preds = %for.end.297, %if.else.272
  br label %if.end.299

if.end.299:                                       ; preds = %if.end.298, %if.end.268
  %211 = load i32, i32* %diff, align 4
  %conv300 = sext i32 %211 to i64
  %212 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any301 = getelementptr inbounds %struct.av, %struct.av* %212, i32 0, i32 0
  %213 = load %struct.xpvav*, %struct.xpvav** %sv_any301, align 8
  %xav_fill302 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %213, i32 0, i32 1
  %214 = load i64, i64* %xav_fill302, align 8
  %add303 = add nsw i64 %214, %conv300
  store i64 %add303, i64* %xav_fill302, align 8
  %215 = load i32, i32* %offset, align 4
  %216 = load i32, i32* %after, align 4
  %cmp304 = icmp slt i32 %215, %216
  br i1 %cmp304, label %if.then.306, label %if.else.339

if.then.306:                                      ; preds = %if.end.299
  %217 = load i32, i32* %offset, align 4
  %tobool307 = icmp ne i32 %217, 0
  br i1 %tobool307, label %if.then.308, label %if.end.325

if.then.308:                                      ; preds = %if.then.306
  %218 = load i32, i32* %offset, align 4
  %sub309 = sub nsw i32 %218, 1
  %idxprom310 = sext i32 %sub309 to i64
  %219 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any311 = getelementptr inbounds %struct.av, %struct.av* %219, i32 0, i32 0
  %220 = load %struct.xpvav*, %struct.xpvav** %sv_any311, align 8
  %xav_array312 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %220, i32 0, i32 0
  %221 = load i8*, i8** %xav_array312, align 8
  %222 = bitcast i8* %221 to %struct.sv**
  %arrayidx313 = getelementptr inbounds %struct.sv*, %struct.sv** %222, i64 %idxprom310
  store %struct.sv** %arrayidx313, %struct.sv*** %src, align 8
  %223 = load %struct.sv**, %struct.sv*** %src, align 8
  %224 = load i32, i32* %diff, align 4
  %idx.ext314 = sext i32 %224 to i64
  %idx.neg = sub i64 0, %idx.ext314
  %add.ptr315 = getelementptr inbounds %struct.sv*, %struct.sv** %223, i64 %idx.neg
  store %struct.sv** %add.ptr315, %struct.sv*** %dst, align 8
  %225 = load i32, i32* %offset, align 4
  store i32 %225, i32* %i, align 4
  br label %for.cond.316

for.cond.316:                                     ; preds = %for.inc.322, %if.then.308
  %226 = load i32, i32* %i, align 4
  %cmp317 = icmp sgt i32 %226, 0
  br i1 %cmp317, label %for.body.319, label %for.end.324

for.body.319:                                     ; preds = %for.cond.316
  %227 = load %struct.sv**, %struct.sv*** %src, align 8
  %incdec.ptr320 = getelementptr inbounds %struct.sv*, %struct.sv** %227, i32 -1
  store %struct.sv** %incdec.ptr320, %struct.sv*** %src, align 8
  %228 = load %struct.sv*, %struct.sv** %227, align 8
  %229 = load %struct.sv**, %struct.sv*** %dst, align 8
  %incdec.ptr321 = getelementptr inbounds %struct.sv*, %struct.sv** %229, i32 -1
  store %struct.sv** %incdec.ptr321, %struct.sv*** %dst, align 8
  store %struct.sv* %228, %struct.sv** %229, align 8
  br label %for.inc.322

for.inc.322:                                      ; preds = %for.body.319
  %230 = load i32, i32* %i, align 4
  %dec323 = add nsw i32 %230, -1
  store i32 %dec323, i32* %i, align 4
  br label %for.cond.316

for.end.324:                                      ; preds = %for.cond.316
  br label %if.end.325

if.end.325:                                       ; preds = %for.end.324, %if.then.306
  %231 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any326 = getelementptr inbounds %struct.av, %struct.av* %231, i32 0, i32 0
  %232 = load %struct.xpvav*, %struct.xpvav** %sv_any326, align 8
  %xav_array327 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %232, i32 0, i32 0
  %233 = load i8*, i8** %xav_array327, align 8
  %234 = bitcast i8* %233 to %struct.sv**
  store %struct.sv** %234, %struct.sv*** %dst, align 8
  %235 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any328 = getelementptr inbounds %struct.av, %struct.av* %235, i32 0, i32 0
  %236 = load %struct.xpvav*, %struct.xpvav** %sv_any328, align 8
  %xav_array329 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %236, i32 0, i32 0
  %237 = load i8*, i8** %xav_array329, align 8
  %238 = bitcast i8* %237 to %struct.sv**
  %239 = load i32, i32* %diff, align 4
  %idx.ext330 = sext i32 %239 to i64
  %idx.neg331 = sub i64 0, %idx.ext330
  %add.ptr332 = getelementptr inbounds %struct.sv*, %struct.sv** %238, i64 %idx.neg331
  %240 = bitcast %struct.sv** %add.ptr332 to i8*
  %241 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any333 = getelementptr inbounds %struct.av, %struct.av* %241, i32 0, i32 0
  %242 = load %struct.xpvav*, %struct.xpvav** %sv_any333, align 8
  %243 = bitcast %struct.xpvav* %242 to %struct.xpv*
  %xpv_pv334 = getelementptr inbounds %struct.xpv, %struct.xpv* %243, i32 0, i32 0
  store i8* %240, i8** %xpv_pv334, align 8
  %244 = load i32, i32* %diff, align 4
  %conv335 = sext i32 %244 to i64
  %245 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any336 = getelementptr inbounds %struct.av, %struct.av* %245, i32 0, i32 0
  %246 = load %struct.xpvav*, %struct.xpvav** %sv_any336, align 8
  %xav_max337 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %246, i32 0, i32 2
  %247 = load i64, i64* %xav_max337, align 8
  %add338 = add nsw i64 %247, %conv335
  store i64 %add338, i64* %xav_max337, align 8
  br label %if.end.359

if.else.339:                                      ; preds = %if.end.299
  %248 = load i32, i32* %after, align 4
  %tobool340 = icmp ne i32 %248, 0
  br i1 %tobool340, label %if.then.341, label %if.end.352

if.then.341:                                      ; preds = %if.else.339
  %249 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any342 = getelementptr inbounds %struct.av, %struct.av* %249, i32 0, i32 0
  %250 = load %struct.xpvav*, %struct.xpvav** %sv_any342, align 8
  %xav_array343 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %250, i32 0, i32 0
  %251 = load i8*, i8** %xav_array343, align 8
  %252 = bitcast i8* %251 to %struct.sv**
  %253 = load i32, i32* %offset, align 4
  %idx.ext344 = sext i32 %253 to i64
  %add.ptr345 = getelementptr inbounds %struct.sv*, %struct.sv** %252, i64 %idx.ext344
  %254 = load i32, i32* %length, align 4
  %idx.ext346 = sext i32 %254 to i64
  %add.ptr347 = getelementptr inbounds %struct.sv*, %struct.sv** %add.ptr345, i64 %idx.ext346
  store %struct.sv** %add.ptr347, %struct.sv*** %src, align 8
  %255 = load %struct.sv**, %struct.sv*** %src, align 8
  %256 = load i32, i32* %diff, align 4
  %idx.ext348 = sext i32 %256 to i64
  %add.ptr349 = getelementptr inbounds %struct.sv*, %struct.sv** %255, i64 %idx.ext348
  store %struct.sv** %add.ptr349, %struct.sv*** %dst, align 8
  %257 = load %struct.sv**, %struct.sv*** %dst, align 8
  %258 = bitcast %struct.sv** %257 to i8*
  %259 = load %struct.sv**, %struct.sv*** %src, align 8
  %260 = bitcast %struct.sv** %259 to i8*
  %261 = load i32, i32* %after, align 4
  %conv350 = sext i32 %261 to i64
  %mul351 = mul i64 %conv350, 8
  call void @llvm.memmove.p0i8.p0i8.i64(i8* %258, i8* %260, i64 %mul351, i32 1, i1 false)
  br label %if.end.352

if.end.352:                                       ; preds = %if.then.341, %if.else.339
  %262 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any353 = getelementptr inbounds %struct.av, %struct.av* %262, i32 0, i32 0
  %263 = load %struct.xpvav*, %struct.xpvav** %sv_any353, align 8
  %xav_fill354 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %263, i32 0, i32 1
  %264 = load i64, i64* %xav_fill354, align 8
  %add355 = add nsw i64 %264, 1
  %265 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any356 = getelementptr inbounds %struct.av, %struct.av* %265, i32 0, i32 0
  %266 = load %struct.xpvav*, %struct.xpvav** %sv_any356, align 8
  %xav_array357 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %266, i32 0, i32 0
  %267 = load i8*, i8** %xav_array357, align 8
  %268 = bitcast i8* %267 to %struct.sv**
  %arrayidx358 = getelementptr inbounds %struct.sv*, %struct.sv** %268, i64 %add355
  store %struct.sv** %arrayidx358, %struct.sv*** %dst, align 8
  br label %if.end.359

if.end.359:                                       ; preds = %if.end.352, %if.end.325
  %269 = load i32, i32* %diff, align 4
  %sub360 = sub nsw i32 0, %269
  store i32 %sub360, i32* %i, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end.359
  %270 = load i32, i32* %i, align 4
  %tobool361 = icmp ne i32 %270, 0
  br i1 %tobool361, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %271 = load i32, i32* %i, align 4
  %dec362 = add nsw i32 %271, -1
  store i32 %dec362, i32* %i, align 4
  %idxprom363 = sext i32 %dec362 to i64
  %272 = load %struct.sv**, %struct.sv*** %dst, align 8
  %arrayidx364 = getelementptr inbounds %struct.sv*, %struct.sv** %272, i64 %idxprom363
  store %struct.sv* @PL_sv_undef, %struct.sv** %arrayidx364, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %273 = load i32, i32* %newlen, align 4
  %tobool365 = icmp ne i32 %273, 0
  br i1 %tobool365, label %if.then.366, label %if.end.373

if.then.366:                                      ; preds = %while.end
  %274 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any367 = getelementptr inbounds %struct.av, %struct.av* %274, i32 0, i32 0
  %275 = load %struct.xpvav*, %struct.xpvav** %sv_any367, align 8
  %xav_array368 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %275, i32 0, i32 0
  %276 = load i8*, i8** %xav_array368, align 8
  %277 = bitcast i8* %276 to %struct.sv**
  %278 = load i32, i32* %offset, align 4
  %idx.ext369 = sext i32 %278 to i64
  %add.ptr370 = getelementptr inbounds %struct.sv*, %struct.sv** %277, i64 %idx.ext369
  %279 = bitcast %struct.sv** %add.ptr370 to i8*
  %280 = load %struct.sv**, %struct.sv*** %tmparyval, align 8
  %281 = bitcast %struct.sv** %280 to i8*
  %282 = load i32, i32* %newlen, align 4
  %conv371 = sext i32 %282 to i64
  %mul372 = mul i64 %conv371, 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %279, i8* %281, i64 %mul372, i32 1, i1 false)
  %283 = load %struct.sv**, %struct.sv*** %tmparyval, align 8
  %284 = bitcast %struct.sv** %283 to i8*
  call void @Perl_safesysfree(i8* %284)
  br label %if.end.373

if.end.373:                                       ; preds = %if.then.366, %while.end
  br label %if.end.554

if.else.374:                                      ; preds = %for.end
  %285 = load i32, i32* %length, align 4
  %tobool375 = icmp ne i32 %285, 0
  br i1 %tobool375, label %if.then.376, label %if.end.386

if.then.376:                                      ; preds = %if.else.374
  %286 = load i32, i32* %length, align 4
  %conv377 = sext i32 %286 to i64
  %mul378 = mul i64 %conv377, 8
  %call379 = call i8* @Perl_safesysmalloc(i64 %mul378)
  %287 = bitcast i8* %call379 to %struct.sv**
  store %struct.sv** %287, %struct.sv*** %tmparyval, align 8
  %288 = load %struct.sv**, %struct.sv*** %tmparyval, align 8
  %289 = bitcast %struct.sv** %288 to i8*
  %290 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any380 = getelementptr inbounds %struct.av, %struct.av* %290, i32 0, i32 0
  %291 = load %struct.xpvav*, %struct.xpvav** %sv_any380, align 8
  %xav_array381 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %291, i32 0, i32 0
  %292 = load i8*, i8** %xav_array381, align 8
  %293 = bitcast i8* %292 to %struct.sv**
  %294 = load i32, i32* %offset, align 4
  %idx.ext382 = sext i32 %294 to i64
  %add.ptr383 = getelementptr inbounds %struct.sv*, %struct.sv** %293, i64 %idx.ext382
  %295 = bitcast %struct.sv** %add.ptr383 to i8*
  %296 = load i32, i32* %length, align 4
  %conv384 = sext i32 %296 to i64
  %mul385 = mul i64 %conv384, 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %289, i8* %295, i64 %mul385, i32 1, i1 false)
  br label %if.end.386

if.end.386:                                       ; preds = %if.then.376, %if.else.374
  %297 = load i32, i32* %diff, align 4
  %cmp387 = icmp sgt i32 %297, 0
  br i1 %cmp387, label %if.then.389, label %if.end.470

if.then.389:                                      ; preds = %if.end.386
  %298 = load i32, i32* %offset, align 4
  %299 = load i32, i32* %after, align 4
  %cmp390 = icmp slt i32 %298, %299
  br i1 %cmp390, label %land.lhs.true.392, label %if.else.430

land.lhs.true.392:                                ; preds = %if.then.389
  %300 = load i32, i32* %diff, align 4
  %conv393 = sext i32 %300 to i64
  %301 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any394 = getelementptr inbounds %struct.av, %struct.av* %301, i32 0, i32 0
  %302 = load %struct.xpvav*, %struct.xpvav** %sv_any394, align 8
  %xav_array395 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %302, i32 0, i32 0
  %303 = load i8*, i8** %xav_array395, align 8
  %304 = bitcast i8* %303 to %struct.sv**
  %305 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any396 = getelementptr inbounds %struct.av, %struct.av* %305, i32 0, i32 0
  %306 = load %struct.xpvav*, %struct.xpvav** %sv_any396, align 8
  %xav_alloc397 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %306, i32 0, i32 7
  %307 = load %struct.sv**, %struct.sv*** %xav_alloc397, align 8
  %sub.ptr.lhs.cast398 = ptrtoint %struct.sv** %304 to i64
  %sub.ptr.rhs.cast399 = ptrtoint %struct.sv** %307 to i64
  %sub.ptr.sub400 = sub i64 %sub.ptr.lhs.cast398, %sub.ptr.rhs.cast399
  %sub.ptr.div401 = sdiv exact i64 %sub.ptr.sub400, 8
  %cmp402 = icmp sle i64 %conv393, %sub.ptr.div401
  br i1 %cmp402, label %if.then.404, label %if.else.430

if.then.404:                                      ; preds = %land.lhs.true.392
  %308 = load i32, i32* %offset, align 4
  %tobool405 = icmp ne i32 %308, 0
  br i1 %tobool405, label %if.then.406, label %if.end.414

if.then.406:                                      ; preds = %if.then.404
  %309 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any407 = getelementptr inbounds %struct.av, %struct.av* %309, i32 0, i32 0
  %310 = load %struct.xpvav*, %struct.xpvav** %sv_any407, align 8
  %xav_array408 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %310, i32 0, i32 0
  %311 = load i8*, i8** %xav_array408, align 8
  %312 = bitcast i8* %311 to %struct.sv**
  store %struct.sv** %312, %struct.sv*** %src, align 8
  %313 = load %struct.sv**, %struct.sv*** %src, align 8
  %314 = load i32, i32* %diff, align 4
  %idx.ext409 = sext i32 %314 to i64
  %idx.neg410 = sub i64 0, %idx.ext409
  %add.ptr411 = getelementptr inbounds %struct.sv*, %struct.sv** %313, i64 %idx.neg410
  store %struct.sv** %add.ptr411, %struct.sv*** %dst, align 8
  %315 = load %struct.sv**, %struct.sv*** %dst, align 8
  %316 = bitcast %struct.sv** %315 to i8*
  %317 = load %struct.sv**, %struct.sv*** %src, align 8
  %318 = bitcast %struct.sv** %317 to i8*
  %319 = load i32, i32* %offset, align 4
  %conv412 = sext i32 %319 to i64
  %mul413 = mul i64 %conv412, 8
  call void @llvm.memmove.p0i8.p0i8.i64(i8* %316, i8* %318, i64 %mul413, i32 1, i1 false)
  br label %if.end.414

if.end.414:                                       ; preds = %if.then.406, %if.then.404
  %320 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any415 = getelementptr inbounds %struct.av, %struct.av* %320, i32 0, i32 0
  %321 = load %struct.xpvav*, %struct.xpvav** %sv_any415, align 8
  %xav_array416 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %321, i32 0, i32 0
  %322 = load i8*, i8** %xav_array416, align 8
  %323 = bitcast i8* %322 to %struct.sv**
  %324 = load i32, i32* %diff, align 4
  %idx.ext417 = sext i32 %324 to i64
  %idx.neg418 = sub i64 0, %idx.ext417
  %add.ptr419 = getelementptr inbounds %struct.sv*, %struct.sv** %323, i64 %idx.neg418
  %325 = bitcast %struct.sv** %add.ptr419 to i8*
  %326 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any420 = getelementptr inbounds %struct.av, %struct.av* %326, i32 0, i32 0
  %327 = load %struct.xpvav*, %struct.xpvav** %sv_any420, align 8
  %328 = bitcast %struct.xpvav* %327 to %struct.xpv*
  %xpv_pv421 = getelementptr inbounds %struct.xpv, %struct.xpv* %328, i32 0, i32 0
  store i8* %325, i8** %xpv_pv421, align 8
  %329 = load i32, i32* %diff, align 4
  %conv422 = sext i32 %329 to i64
  %330 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any423 = getelementptr inbounds %struct.av, %struct.av* %330, i32 0, i32 0
  %331 = load %struct.xpvav*, %struct.xpvav** %sv_any423, align 8
  %xav_max424 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %331, i32 0, i32 2
  %332 = load i64, i64* %xav_max424, align 8
  %add425 = add nsw i64 %332, %conv422
  store i64 %add425, i64* %xav_max424, align 8
  %333 = load i32, i32* %diff, align 4
  %conv426 = sext i32 %333 to i64
  %334 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any427 = getelementptr inbounds %struct.av, %struct.av* %334, i32 0, i32 0
  %335 = load %struct.xpvav*, %struct.xpvav** %sv_any427, align 8
  %xav_fill428 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %335, i32 0, i32 1
  %336 = load i64, i64* %xav_fill428, align 8
  %add429 = add nsw i64 %336, %conv426
  store i64 %add429, i64* %xav_fill428, align 8
  br label %if.end.469

if.else.430:                                      ; preds = %land.lhs.true.392, %if.then.389
  %337 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any431 = getelementptr inbounds %struct.av, %struct.av* %337, i32 0, i32 0
  %338 = load %struct.xpvav*, %struct.xpvav** %sv_any431, align 8
  %xav_fill432 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %338, i32 0, i32 1
  %339 = load i64, i64* %xav_fill432, align 8
  %340 = load i32, i32* %diff, align 4
  %conv433 = sext i32 %340 to i64
  %add434 = add nsw i64 %339, %conv433
  %341 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any435 = getelementptr inbounds %struct.av, %struct.av* %341, i32 0, i32 0
  %342 = load %struct.xpvav*, %struct.xpvav** %sv_any435, align 8
  %xav_max436 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %342, i32 0, i32 2
  %343 = load i64, i64* %xav_max436, align 8
  %cmp437 = icmp sge i64 %add434, %343
  br i1 %cmp437, label %if.then.439, label %if.end.445

if.then.439:                                      ; preds = %if.else.430
  %344 = load %struct.av*, %struct.av** %ary, align 8
  %345 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any440 = getelementptr inbounds %struct.av, %struct.av* %345, i32 0, i32 0
  %346 = load %struct.xpvav*, %struct.xpvav** %sv_any440, align 8
  %xav_fill441 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %346, i32 0, i32 1
  %347 = load i64, i64* %xav_fill441, align 8
  %348 = load i32, i32* %diff, align 4
  %conv442 = sext i32 %348 to i64
  %add443 = add nsw i64 %347, %conv442
  %conv444 = trunc i64 %add443 to i32
  call void @Perl_av_extend(%struct.av* %344, i32 %conv444)
  br label %if.end.445

if.end.445:                                       ; preds = %if.then.439, %if.else.430
  %349 = load i32, i32* %diff, align 4
  %conv446 = sext i32 %349 to i64
  %350 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any447 = getelementptr inbounds %struct.av, %struct.av* %350, i32 0, i32 0
  %351 = load %struct.xpvav*, %struct.xpvav** %sv_any447, align 8
  %xav_fill448 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %351, i32 0, i32 1
  %352 = load i64, i64* %xav_fill448, align 8
  %add449 = add nsw i64 %352, %conv446
  store i64 %add449, i64* %xav_fill448, align 8
  %353 = load i32, i32* %after, align 4
  %tobool450 = icmp ne i32 %353, 0
  br i1 %tobool450, label %if.then.451, label %if.end.468

if.then.451:                                      ; preds = %if.end.445
  %354 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any452 = getelementptr inbounds %struct.av, %struct.av* %354, i32 0, i32 0
  %355 = load %struct.xpvav*, %struct.xpvav** %sv_any452, align 8
  %xav_array453 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %355, i32 0, i32 0
  %356 = load i8*, i8** %xav_array453, align 8
  %357 = bitcast i8* %356 to %struct.sv**
  %358 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any454 = getelementptr inbounds %struct.av, %struct.av* %358, i32 0, i32 0
  %359 = load %struct.xpvav*, %struct.xpvav** %sv_any454, align 8
  %xav_fill455 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %359, i32 0, i32 1
  %360 = load i64, i64* %xav_fill455, align 8
  %add.ptr456 = getelementptr inbounds %struct.sv*, %struct.sv** %357, i64 %360
  store %struct.sv** %add.ptr456, %struct.sv*** %dst, align 8
  %361 = load %struct.sv**, %struct.sv*** %dst, align 8
  %362 = load i32, i32* %diff, align 4
  %idx.ext457 = sext i32 %362 to i64
  %idx.neg458 = sub i64 0, %idx.ext457
  %add.ptr459 = getelementptr inbounds %struct.sv*, %struct.sv** %361, i64 %idx.neg458
  store %struct.sv** %add.ptr459, %struct.sv*** %src, align 8
  %363 = load i32, i32* %after, align 4
  store i32 %363, i32* %i, align 4
  br label %for.cond.460

for.cond.460:                                     ; preds = %for.inc.465, %if.then.451
  %364 = load i32, i32* %i, align 4
  %tobool461 = icmp ne i32 %364, 0
  br i1 %tobool461, label %for.body.462, label %for.end.467

for.body.462:                                     ; preds = %for.cond.460
  %365 = load %struct.sv**, %struct.sv*** %src, align 8
  %incdec.ptr463 = getelementptr inbounds %struct.sv*, %struct.sv** %365, i32 -1
  store %struct.sv** %incdec.ptr463, %struct.sv*** %src, align 8
  %366 = load %struct.sv*, %struct.sv** %365, align 8
  %367 = load %struct.sv**, %struct.sv*** %dst, align 8
  %incdec.ptr464 = getelementptr inbounds %struct.sv*, %struct.sv** %367, i32 -1
  store %struct.sv** %incdec.ptr464, %struct.sv*** %dst, align 8
  store %struct.sv* %366, %struct.sv** %367, align 8
  br label %for.inc.465

for.inc.465:                                      ; preds = %for.body.462
  %368 = load i32, i32* %i, align 4
  %dec466 = add nsw i32 %368, -1
  store i32 %dec466, i32* %i, align 4
  br label %for.cond.460

for.end.467:                                      ; preds = %for.cond.460
  br label %if.end.468

if.end.468:                                       ; preds = %for.end.467, %if.end.445
  br label %if.end.469

if.end.469:                                       ; preds = %if.end.468, %if.end.414
  br label %if.end.470

if.end.470:                                       ; preds = %if.end.469, %if.end.386
  %369 = load i32, i32* %newlen, align 4
  %tobool471 = icmp ne i32 %369, 0
  br i1 %tobool471, label %if.then.472, label %if.end.479

if.then.472:                                      ; preds = %if.end.470
  %370 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any473 = getelementptr inbounds %struct.av, %struct.av* %370, i32 0, i32 0
  %371 = load %struct.xpvav*, %struct.xpvav** %sv_any473, align 8
  %xav_array474 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %371, i32 0, i32 0
  %372 = load i8*, i8** %xav_array474, align 8
  %373 = bitcast i8* %372 to %struct.sv**
  %374 = load i32, i32* %offset, align 4
  %idx.ext475 = sext i32 %374 to i64
  %add.ptr476 = getelementptr inbounds %struct.sv*, %struct.sv** %373, i64 %idx.ext475
  %375 = bitcast %struct.sv** %add.ptr476 to i8*
  %376 = load %struct.sv**, %struct.sv*** %mark, align 8
  %377 = bitcast %struct.sv** %376 to i8*
  %378 = load i32, i32* %newlen, align 4
  %conv477 = sext i32 %378 to i64
  %mul478 = mul i64 %conv477, 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %375, i8* %377, i64 %mul478, i32 1, i1 false)
  br label %if.end.479

if.end.479:                                       ; preds = %if.then.472, %if.end.470
  %379 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %380 = load i32, i32* %origmark, align 4
  %idx.ext480 = sext i32 %380 to i64
  %add.ptr481 = getelementptr inbounds %struct.sv*, %struct.sv** %379, i64 %idx.ext480
  %add.ptr482 = getelementptr inbounds %struct.sv*, %struct.sv** %add.ptr481, i64 1
  store %struct.sv** %add.ptr482, %struct.sv*** %mark, align 8
  %381 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags483 = getelementptr inbounds %struct.op, %struct.op* %381, i32 0, i32 6
  %382 = load i8, i8* %op_flags483, align 1
  %conv484 = zext i8 %382 to i32
  %and485 = and i32 %conv484, 3
  %tobool486 = icmp ne i32 %and485, 0
  br i1 %tobool486, label %cond.true.487, label %cond.false.494

cond.true.487:                                    ; preds = %if.end.479
  %383 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags488 = getelementptr inbounds %struct.op, %struct.op* %383, i32 0, i32 6
  %384 = load i8, i8* %op_flags488, align 1
  %conv489 = zext i8 %384 to i32
  %and490 = and i32 %conv489, 3
  %cmp491 = icmp eq i32 %and490, 3
  %cond493 = select i1 %cmp491, i32 1, i32 0
  br label %cond.end.496

cond.false.494:                                   ; preds = %if.end.479
  %call495 = call i32 @Perl_dowantarray()
  br label %cond.end.496

cond.end.496:                                     ; preds = %cond.false.494, %cond.true.487
  %cond497 = phi i32 [ %cond493, %cond.true.487 ], [ %call495, %cond.false.494 ]
  %cmp498 = icmp eq i32 %cond497, 1
  br i1 %cmp498, label %if.then.500, label %if.else.529

if.then.500:                                      ; preds = %cond.end.496
  %385 = load i32, i32* %length, align 4
  %tobool501 = icmp ne i32 %385, 0
  br i1 %tobool501, label %if.then.502, label %if.end.525

if.then.502:                                      ; preds = %if.then.500
  %386 = load %struct.sv**, %struct.sv*** %mark, align 8
  %387 = bitcast %struct.sv** %386 to i8*
  %388 = load %struct.sv**, %struct.sv*** %tmparyval, align 8
  %389 = bitcast %struct.sv** %388 to i8*
  %390 = load i32, i32* %length, align 4
  %conv503 = sext i32 %390 to i64
  %mul504 = mul i64 %conv503, 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %387, i8* %389, i64 %mul504, i32 1, i1 false)
  %391 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any505 = getelementptr inbounds %struct.av, %struct.av* %391, i32 0, i32 0
  %392 = load %struct.xpvav*, %struct.xpvav** %sv_any505, align 8
  %xav_flags506 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %392, i32 0, i32 9
  %393 = load i8, i8* %xav_flags506, align 1
  %conv507 = zext i8 %393 to i32
  %and508 = and i32 %conv507, 1
  %tobool509 = icmp ne i32 %and508, 0
  br i1 %tobool509, label %if.then.510, label %if.end.524

if.then.510:                                      ; preds = %if.then.502
  %394 = load i32, i32* @PL_tmps_ix, align 4
  %395 = load i32, i32* %length, align 4
  %add511 = add nsw i32 %394, %395
  %396 = load i32, i32* @PL_tmps_max, align 4
  %cmp512 = icmp sge i32 %add511, %396
  br i1 %cmp512, label %if.then.514, label %if.end.515

if.then.514:                                      ; preds = %if.then.510
  %397 = load i32, i32* %length, align 4
  call void @Perl_tmps_grow(i32 %397)
  br label %if.end.515

if.end.515:                                       ; preds = %if.then.514, %if.then.510
  %398 = load i32, i32* %length, align 4
  store i32 %398, i32* %i, align 4
  %399 = load %struct.sv**, %struct.sv*** %mark, align 8
  store %struct.sv** %399, %struct.sv*** %dst, align 8
  br label %for.cond.516

for.cond.516:                                     ; preds = %for.inc.521, %if.end.515
  %400 = load i32, i32* %i, align 4
  %tobool517 = icmp ne i32 %400, 0
  br i1 %tobool517, label %for.body.518, label %for.end.523

for.body.518:                                     ; preds = %for.cond.516
  %401 = load %struct.sv**, %struct.sv*** %dst, align 8
  %402 = load %struct.sv*, %struct.sv** %401, align 8
  %call519 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %402)
  %403 = load %struct.sv**, %struct.sv*** %dst, align 8
  %incdec.ptr520 = getelementptr inbounds %struct.sv*, %struct.sv** %403, i32 1
  store %struct.sv** %incdec.ptr520, %struct.sv*** %dst, align 8
  br label %for.inc.521

for.inc.521:                                      ; preds = %for.body.518
  %404 = load i32, i32* %i, align 4
  %dec522 = add nsw i32 %404, -1
  store i32 %dec522, i32* %i, align 4
  br label %for.cond.516

for.end.523:                                      ; preds = %for.cond.516
  br label %if.end.524

if.end.524:                                       ; preds = %for.end.523, %if.then.502
  %405 = load %struct.sv**, %struct.sv*** %tmparyval, align 8
  %406 = bitcast %struct.sv** %405 to i8*
  call void @Perl_safesysfree(i8* %406)
  br label %if.end.525

if.end.525:                                       ; preds = %if.end.524, %if.then.500
  %407 = load i32, i32* %length, align 4
  %sub526 = sub nsw i32 %407, 1
  %408 = load %struct.sv**, %struct.sv*** %mark, align 8
  %idx.ext527 = sext i32 %sub526 to i64
  %add.ptr528 = getelementptr inbounds %struct.sv*, %struct.sv** %408, i64 %idx.ext527
  store %struct.sv** %add.ptr528, %struct.sv*** %mark, align 8
  br label %if.end.553

if.else.529:                                      ; preds = %cond.end.496
  %409 = load i32, i32* %length, align 4
  %dec530 = add nsw i32 %409, -1
  store i32 %dec530, i32* %length, align 4
  %tobool531 = icmp ne i32 %409, 0
  br i1 %tobool531, label %if.then.532, label %if.else.551

if.then.532:                                      ; preds = %if.else.529
  %410 = load i32, i32* %length, align 4
  %idxprom533 = sext i32 %410 to i64
  %411 = load %struct.sv**, %struct.sv*** %tmparyval, align 8
  %arrayidx534 = getelementptr inbounds %struct.sv*, %struct.sv** %411, i64 %idxprom533
  %412 = load %struct.sv*, %struct.sv** %arrayidx534, align 8
  %413 = load %struct.sv**, %struct.sv*** %mark, align 8
  store %struct.sv* %412, %struct.sv** %413, align 8
  %414 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any535 = getelementptr inbounds %struct.av, %struct.av* %414, i32 0, i32 0
  %415 = load %struct.xpvav*, %struct.xpvav** %sv_any535, align 8
  %xav_flags536 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %415, i32 0, i32 9
  %416 = load i8, i8* %xav_flags536, align 1
  %conv537 = zext i8 %416 to i32
  %and538 = and i32 %conv537, 1
  %tobool539 = icmp ne i32 %and538, 0
  br i1 %tobool539, label %if.then.540, label %if.end.550

if.then.540:                                      ; preds = %if.then.532
  %417 = load %struct.sv**, %struct.sv*** %mark, align 8
  %418 = load %struct.sv*, %struct.sv** %417, align 8
  %call541 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %418)
  br label %while.cond.542

while.cond.542:                                   ; preds = %while.body.546, %if.then.540
  %419 = load i32, i32* %length, align 4
  %dec543 = add nsw i32 %419, -1
  store i32 %dec543, i32* %length, align 4
  %cmp544 = icmp sgt i32 %419, 0
  br i1 %cmp544, label %while.body.546, label %while.end.549

while.body.546:                                   ; preds = %while.cond.542
  %420 = load i32, i32* %length, align 4
  %idxprom547 = sext i32 %420 to i64
  %421 = load %struct.sv**, %struct.sv*** %tmparyval, align 8
  %arrayidx548 = getelementptr inbounds %struct.sv*, %struct.sv** %421, i64 %idxprom547
  %422 = load %struct.sv*, %struct.sv** %arrayidx548, align 8
  call void @Perl_sv_free(%struct.sv* %422)
  br label %while.cond.542

while.end.549:                                    ; preds = %while.cond.542
  br label %if.end.550

if.end.550:                                       ; preds = %while.end.549, %if.then.532
  %423 = load %struct.sv**, %struct.sv*** %tmparyval, align 8
  %424 = bitcast %struct.sv** %423 to i8*
  call void @Perl_safesysfree(i8* %424)
  br label %if.end.552

if.else.551:                                      ; preds = %if.else.529
  %425 = load %struct.sv**, %struct.sv*** %mark, align 8
  store %struct.sv* @PL_sv_undef, %struct.sv** %425, align 8
  br label %if.end.552

if.end.552:                                       ; preds = %if.else.551, %if.end.550
  br label %if.end.553

if.end.553:                                       ; preds = %if.end.552, %if.end.525
  br label %if.end.554

if.end.554:                                       ; preds = %if.end.553, %if.end.373
  %426 = load %struct.sv**, %struct.sv*** %mark, align 8
  store %struct.sv** %426, %struct.sv*** %sp, align 8
  %427 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %427, %struct.sv*** @PL_stack_sp, align 8
  %428 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next555 = getelementptr inbounds %struct.op, %struct.op* %428, i32 0, i32 0
  %429 = load %struct.op*, %struct.op** %op_next555, align 8
  store %struct.op* %429, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.554, %if.then.73, %cond.end.45
  %430 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %430
}

declare void @Perl_markstack_grow() #1

declare void @Perl_push_scope() #1

declare i32 @Perl_call_method(i8*, i32) #1

declare void @Perl_pop_scope() #1

declare void @Perl_av_reify(%struct.av*) #1

; Function Attrs: nounwind
declare void @llvm.memmove.p0i8.p0i8.i64(i8* nocapture, i8* nocapture readonly, i64, i32, i1) #2

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_push() #0 {
entry:
  %sp = alloca %struct.sv**, align 8
  %mark = alloca %struct.sv**, align 8
  %origmark = alloca i32, align 4
  %targ = alloca %struct.sv*, align 8
  %ary = alloca %struct.av*, align 8
  %sv = alloca %struct.sv*, align 8
  %mg = alloca %struct.magic*, align 8
  %tmp = alloca i32, align 4
  %tmp47 = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %2 = load i32*, i32** @PL_markstack_ptr, align 8
  %incdec.ptr = getelementptr inbounds i32, i32* %2, i32 -1
  store i32* %incdec.ptr, i32** @PL_markstack_ptr, align 8
  %3 = load i32, i32* %2, align 4
  %idx.ext = sext i32 %3 to i64
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %1, i64 %idx.ext
  store %struct.sv** %add.ptr, %struct.sv*** %mark, align 8
  %4 = load %struct.sv**, %struct.sv*** %mark, align 8
  %5 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %4 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %5 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %conv = trunc i64 %sub.ptr.div to i32
  store i32 %conv, i32* %origmark, align 4
  %6 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %6, i32 0, i32 3
  %7 = load i64, i64* %op_targ, align 8
  %8 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %8, i64 %7
  %9 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %9, %struct.sv** %targ, align 8
  %10 = load %struct.sv**, %struct.sv*** %mark, align 8
  %incdec.ptr1 = getelementptr inbounds %struct.sv*, %struct.sv** %10, i32 1
  store %struct.sv** %incdec.ptr1, %struct.sv*** %mark, align 8
  %11 = load %struct.sv*, %struct.sv** %incdec.ptr1, align 8
  %12 = bitcast %struct.sv* %11 to %struct.av*
  store %struct.av* %12, %struct.av** %ary, align 8
  store %struct.sv* @PL_sv_undef, %struct.sv** %sv, align 8
  %13 = load %struct.av*, %struct.av** %ary, align 8
  %14 = bitcast %struct.av* %13 to %struct.sv*
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %14, i32 0, i32 2
  %15 = load i32, i32* %sv_flags, align 4
  %and = and i32 %15, 32768
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %16 = load %struct.av*, %struct.av** %ary, align 8
  %17 = bitcast %struct.av* %16 to %struct.sv*
  %call = call %struct.magic* @Perl_mg_find(%struct.sv* %17, i32 80)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.magic* [ %call, %cond.true ], [ null, %cond.false ]
  store %struct.magic* %cond, %struct.magic** %mg, align 8
  %tobool2 = icmp ne %struct.magic* %cond, null
  br i1 %tobool2, label %if.then, label %if.else

if.then:                                          ; preds = %cond.end
  %18 = load %struct.magic*, %struct.magic** %mg, align 8
  %mg_obj = getelementptr inbounds %struct.magic, %struct.magic* %18, i32 0, i32 5
  %19 = load %struct.sv*, %struct.sv** %mg_obj, align 8
  %tobool3 = icmp ne %struct.sv* %19, null
  br i1 %tobool3, label %cond.true.4, label %cond.false.6

cond.true.4:                                      ; preds = %if.then
  %20 = load %struct.magic*, %struct.magic** %mg, align 8
  %mg_obj5 = getelementptr inbounds %struct.magic, %struct.magic* %20, i32 0, i32 5
  %21 = load %struct.sv*, %struct.sv** %mg_obj5, align 8
  br label %cond.end.9

cond.false.6:                                     ; preds = %if.then
  %22 = load %struct.av*, %struct.av** %ary, align 8
  %23 = bitcast %struct.av* %22 to %struct.sv*
  %call7 = call %struct.sv* @Perl_newRV(%struct.sv* %23)
  %call8 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call7)
  br label %cond.end.9

cond.end.9:                                       ; preds = %cond.false.6, %cond.true.4
  %cond10 = phi %struct.sv* [ %21, %cond.true.4 ], [ %call8, %cond.false.6 ]
  %24 = load %struct.sv**, %struct.sv*** %mark, align 8
  %incdec.ptr11 = getelementptr inbounds %struct.sv*, %struct.sv** %24, i32 -1
  store %struct.sv** %incdec.ptr11, %struct.sv*** %mark, align 8
  store %struct.sv* %cond10, %struct.sv** %24, align 8
  %25 = load i32*, i32** @PL_markstack_ptr, align 8
  %incdec.ptr12 = getelementptr inbounds i32, i32* %25, i32 1
  store i32* %incdec.ptr12, i32** @PL_markstack_ptr, align 8
  %26 = load i32*, i32** @PL_markstack_max, align 8
  %cmp = icmp eq i32* %incdec.ptr12, %26
  br i1 %cmp, label %if.then.14, label %if.end

if.then.14:                                       ; preds = %cond.end.9
  call void @Perl_markstack_grow()
  br label %if.end

if.end:                                           ; preds = %if.then.14, %cond.end.9
  %27 = load %struct.sv**, %struct.sv*** %mark, align 8
  %28 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %sub.ptr.lhs.cast15 = ptrtoint %struct.sv** %27 to i64
  %sub.ptr.rhs.cast16 = ptrtoint %struct.sv** %28 to i64
  %sub.ptr.sub17 = sub i64 %sub.ptr.lhs.cast15, %sub.ptr.rhs.cast16
  %sub.ptr.div18 = sdiv exact i64 %sub.ptr.sub17, 8
  %conv19 = trunc i64 %sub.ptr.div18 to i32
  %29 = load i32*, i32** @PL_markstack_ptr, align 8
  store i32 %conv19, i32* %29, align 4
  store i32 %conv19, i32* %tmp
  %30 = load i32, i32* %tmp
  %31 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %31, %struct.sv*** @PL_stack_sp, align 8
  call void @Perl_push_scope()
  %call20 = call i32 @Perl_call_method(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.45, i32 0, i32 0), i32 2)
  call void @Perl_pop_scope()
  %32 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %32, %struct.sv*** %sp, align 8
  br label %if.end.29

if.else:                                          ; preds = %cond.end
  %33 = load %struct.sv**, %struct.sv*** %mark, align 8
  %incdec.ptr21 = getelementptr inbounds %struct.sv*, %struct.sv** %33, i32 1
  store %struct.sv** %incdec.ptr21, %struct.sv*** %mark, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.else
  %34 = load %struct.sv**, %struct.sv*** %mark, align 8
  %35 = load %struct.sv**, %struct.sv*** %sp, align 8
  %cmp22 = icmp ule %struct.sv** %34, %35
  br i1 %cmp22, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %call24 = call %struct.sv* @Perl_newSV(i64 0)
  store %struct.sv* %call24, %struct.sv** %sv, align 8
  %36 = load %struct.sv**, %struct.sv*** %mark, align 8
  %37 = load %struct.sv*, %struct.sv** %36, align 8
  %tobool25 = icmp ne %struct.sv* %37, null
  br i1 %tobool25, label %if.then.26, label %if.end.27

if.then.26:                                       ; preds = %for.body
  %38 = load %struct.sv*, %struct.sv** %sv, align 8
  %39 = load %struct.sv**, %struct.sv*** %mark, align 8
  %40 = load %struct.sv*, %struct.sv** %39, align 8
  call void @Perl_sv_setsv_flags(%struct.sv* %38, %struct.sv* %40, i32 2)
  br label %if.end.27

if.end.27:                                        ; preds = %if.then.26, %for.body
  %41 = load %struct.av*, %struct.av** %ary, align 8
  %42 = load %struct.sv*, %struct.sv** %sv, align 8
  call void @Perl_av_push(%struct.av* %41, %struct.sv* %42)
  br label %for.inc

for.inc:                                          ; preds = %if.end.27
  %43 = load %struct.sv**, %struct.sv*** %mark, align 8
  %incdec.ptr28 = getelementptr inbounds %struct.sv*, %struct.sv** %43, i32 1
  store %struct.sv** %incdec.ptr28, %struct.sv*** %mark, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end.29

if.end.29:                                        ; preds = %for.end, %if.end
  %44 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %45 = load i32, i32* %origmark, align 4
  %idx.ext30 = sext i32 %45 to i64
  %add.ptr31 = getelementptr inbounds %struct.sv*, %struct.sv** %44, i64 %idx.ext30
  store %struct.sv** %add.ptr31, %struct.sv*** %sp, align 8
  %46 = load %struct.sv*, %struct.sv** %targ, align 8
  %47 = load %struct.av*, %struct.av** %ary, align 8
  %48 = bitcast %struct.av* %47 to %struct.sv*
  %sv_flags32 = getelementptr inbounds %struct.sv, %struct.sv* %48, i32 0, i32 2
  %49 = load i32, i32* %sv_flags32, align 4
  %and33 = and i32 %49, 32768
  %tobool34 = icmp ne i32 %and33, 0
  br i1 %tobool34, label %cond.true.35, label %cond.false.38

cond.true.35:                                     ; preds = %if.end.29
  %50 = load %struct.av*, %struct.av** %ary, align 8
  %51 = bitcast %struct.av* %50 to %struct.sv*
  %call36 = call i32 @Perl_mg_size(%struct.sv* %51)
  %conv37 = sext i32 %call36 to i64
  br label %cond.end.39

cond.false.38:                                    ; preds = %if.end.29
  %52 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any = getelementptr inbounds %struct.av, %struct.av* %52, i32 0, i32 0
  %53 = load %struct.xpvav*, %struct.xpvav** %sv_any, align 8
  %xav_fill = getelementptr inbounds %struct.xpvav, %struct.xpvav* %53, i32 0, i32 1
  %54 = load i64, i64* %xav_fill, align 8
  br label %cond.end.39

cond.end.39:                                      ; preds = %cond.false.38, %cond.true.35
  %cond40 = phi i64 [ %conv37, %cond.true.35 ], [ %54, %cond.false.38 ]
  %add = add nsw i64 %cond40, 1
  call void @Perl_sv_setiv(%struct.sv* %46, i64 %add)
  %55 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags41 = getelementptr inbounds %struct.sv, %struct.sv* %55, i32 0, i32 2
  %56 = load i32, i32* %sv_flags41, align 4
  %and42 = and i32 %56, 16384
  %tobool43 = icmp ne i32 %and42, 0
  br i1 %tobool43, label %if.then.44, label %if.end.46

if.then.44:                                       ; preds = %cond.end.39
  %57 = load %struct.sv*, %struct.sv** %targ, align 8
  %call45 = call i32 @Perl_mg_set(%struct.sv* %57)
  br label %if.end.46

if.end.46:                                        ; preds = %if.then.44, %cond.end.39
  %58 = load %struct.sv*, %struct.sv** %targ, align 8
  %59 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr48 = getelementptr inbounds %struct.sv*, %struct.sv** %59, i32 1
  store %struct.sv** %incdec.ptr48, %struct.sv*** %sp, align 8
  store %struct.sv* %58, %struct.sv** %incdec.ptr48, align 8
  store %struct.sv* %58, %struct.sv** %tmp47
  %60 = load %struct.sv*, %struct.sv** %tmp47
  %61 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %61, %struct.sv*** @PL_stack_sp, align 8
  %62 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %62, i32 0, i32 0
  %63 = load %struct.op*, %struct.op** %op_next, align 8
  ret %struct.op* %63
}

declare void @Perl_av_push(%struct.av*, %struct.sv*) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_pop() #0 {
entry:
  %sp = alloca %struct.sv**, align 8
  %av = alloca %struct.av*, align 8
  %sv = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %1, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %2 = load %struct.sv*, %struct.sv** %1, align 8
  %3 = bitcast %struct.sv* %2 to %struct.av*
  store %struct.av* %3, %struct.av** %av, align 8
  %4 = load %struct.av*, %struct.av** %av, align 8
  %call = call %struct.sv* @Perl_av_pop(%struct.av* %4)
  store %struct.sv* %call, %struct.sv** %sv, align 8
  %5 = load %struct.av*, %struct.av** %av, align 8
  %sv_any = getelementptr inbounds %struct.av, %struct.av* %5, i32 0, i32 0
  %6 = load %struct.xpvav*, %struct.xpvav** %sv_any, align 8
  %xav_flags = getelementptr inbounds %struct.xpvav, %struct.xpvav* %6, i32 0, i32 9
  %7 = load i8, i8* %xav_flags, align 1
  %conv = zext i8 %7 to i32
  %and = and i32 %conv, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %8 = load %struct.sv*, %struct.sv** %sv, align 8
  %call1 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %8)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %9 = load %struct.sv*, %struct.sv** %sv, align 8
  %10 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr2 = getelementptr inbounds %struct.sv*, %struct.sv** %10, i32 1
  store %struct.sv** %incdec.ptr2, %struct.sv*** %sp, align 8
  store %struct.sv* %9, %struct.sv** %incdec.ptr2, align 8
  %11 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %11, %struct.sv*** @PL_stack_sp, align 8
  %12 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %12, i32 0, i32 0
  %13 = load %struct.op*, %struct.op** %op_next, align 8
  ret %struct.op* %13
}

declare %struct.sv* @Perl_av_pop(%struct.av*) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_shift() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %av = alloca %struct.av*, align 8
  %sv = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %1, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %2 = load %struct.sv*, %struct.sv** %1, align 8
  %3 = bitcast %struct.sv* %2 to %struct.av*
  store %struct.av* %3, %struct.av** %av, align 8
  %4 = load %struct.av*, %struct.av** %av, align 8
  %call = call %struct.sv* @Perl_av_shift(%struct.av* %4)
  store %struct.sv* %call, %struct.sv** %sv, align 8
  %5 = load %struct.sv**, %struct.sv*** @PL_stack_max, align 8
  %6 = load %struct.sv**, %struct.sv*** %sp, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %5 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %6 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %cmp = icmp slt i64 %sub.ptr.div, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %7 = load %struct.sv**, %struct.sv*** %sp, align 8
  %8 = load %struct.sv**, %struct.sv*** %sp, align 8
  %call1 = call %struct.sv** @Perl_stack_grow(%struct.sv** %7, %struct.sv** %8, i32 1)
  store %struct.sv** %call1, %struct.sv*** %sp, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %9 = load %struct.sv*, %struct.sv** %sv, align 8
  %tobool = icmp ne %struct.sv* %9, null
  br i1 %tobool, label %if.end.4, label %if.then.2

if.then.2:                                        ; preds = %if.end
  %10 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr3 = getelementptr inbounds %struct.sv*, %struct.sv** %10, i32 1
  store %struct.sv** %incdec.ptr3, %struct.sv*** %sp, align 8
  store %struct.sv* @PL_sv_undef, %struct.sv** %incdec.ptr3, align 8
  %11 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %11, %struct.sv*** @PL_stack_sp, align 8
  %12 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %12, i32 0, i32 0
  %13 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %13, %struct.op** %retval
  br label %return

if.end.4:                                         ; preds = %if.end
  %14 = load %struct.av*, %struct.av** %av, align 8
  %sv_any = getelementptr inbounds %struct.av, %struct.av* %14, i32 0, i32 0
  %15 = load %struct.xpvav*, %struct.xpvav** %sv_any, align 8
  %xav_flags = getelementptr inbounds %struct.xpvav, %struct.xpvav* %15, i32 0, i32 9
  %16 = load i8, i8* %xav_flags, align 1
  %conv = zext i8 %16 to i32
  %and = and i32 %conv, 1
  %tobool5 = icmp ne i32 %and, 0
  br i1 %tobool5, label %if.then.6, label %if.end.8

if.then.6:                                        ; preds = %if.end.4
  %17 = load %struct.sv*, %struct.sv** %sv, align 8
  %call7 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %17)
  br label %if.end.8

if.end.8:                                         ; preds = %if.then.6, %if.end.4
  %18 = load %struct.sv*, %struct.sv** %sv, align 8
  %19 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr9 = getelementptr inbounds %struct.sv*, %struct.sv** %19, i32 1
  store %struct.sv** %incdec.ptr9, %struct.sv*** %sp, align 8
  store %struct.sv* %18, %struct.sv** %incdec.ptr9, align 8
  %20 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %20, %struct.sv*** @PL_stack_sp, align 8
  %21 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next10 = getelementptr inbounds %struct.op, %struct.op* %21, i32 0, i32 0
  %22 = load %struct.op*, %struct.op** %op_next10, align 8
  store %struct.op* %22, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.8, %if.then.2
  %23 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %23
}

declare %struct.sv* @Perl_av_shift(%struct.av*) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_unshift() #0 {
entry:
  %sp = alloca %struct.sv**, align 8
  %mark = alloca %struct.sv**, align 8
  %origmark = alloca i32, align 4
  %targ = alloca %struct.sv*, align 8
  %ary = alloca %struct.av*, align 8
  %sv = alloca %struct.sv*, align 8
  %i = alloca i32, align 4
  %mg = alloca %struct.magic*, align 8
  %tmp = alloca i32, align 4
  %tmp49 = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %2 = load i32*, i32** @PL_markstack_ptr, align 8
  %incdec.ptr = getelementptr inbounds i32, i32* %2, i32 -1
  store i32* %incdec.ptr, i32** @PL_markstack_ptr, align 8
  %3 = load i32, i32* %2, align 4
  %idx.ext = sext i32 %3 to i64
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %1, i64 %idx.ext
  store %struct.sv** %add.ptr, %struct.sv*** %mark, align 8
  %4 = load %struct.sv**, %struct.sv*** %mark, align 8
  %5 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %4 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %5 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %conv = trunc i64 %sub.ptr.div to i32
  store i32 %conv, i32* %origmark, align 4
  %6 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %6, i32 0, i32 3
  %7 = load i64, i64* %op_targ, align 8
  %8 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %8, i64 %7
  %9 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %9, %struct.sv** %targ, align 8
  %10 = load %struct.sv**, %struct.sv*** %mark, align 8
  %incdec.ptr1 = getelementptr inbounds %struct.sv*, %struct.sv** %10, i32 1
  store %struct.sv** %incdec.ptr1, %struct.sv*** %mark, align 8
  %11 = load %struct.sv*, %struct.sv** %incdec.ptr1, align 8
  %12 = bitcast %struct.sv* %11 to %struct.av*
  store %struct.av* %12, %struct.av** %ary, align 8
  store i32 0, i32* %i, align 4
  %13 = load %struct.av*, %struct.av** %ary, align 8
  %14 = bitcast %struct.av* %13 to %struct.sv*
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %14, i32 0, i32 2
  %15 = load i32, i32* %sv_flags, align 4
  %and = and i32 %15, 32768
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %16 = load %struct.av*, %struct.av** %ary, align 8
  %17 = bitcast %struct.av* %16 to %struct.sv*
  %call = call %struct.magic* @Perl_mg_find(%struct.sv* %17, i32 80)
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.magic* [ %call, %cond.true ], [ null, %cond.false ]
  store %struct.magic* %cond, %struct.magic** %mg, align 8
  %tobool2 = icmp ne %struct.magic* %cond, null
  br i1 %tobool2, label %if.then, label %if.else

if.then:                                          ; preds = %cond.end
  %18 = load %struct.magic*, %struct.magic** %mg, align 8
  %mg_obj = getelementptr inbounds %struct.magic, %struct.magic* %18, i32 0, i32 5
  %19 = load %struct.sv*, %struct.sv** %mg_obj, align 8
  %tobool3 = icmp ne %struct.sv* %19, null
  br i1 %tobool3, label %cond.true.4, label %cond.false.6

cond.true.4:                                      ; preds = %if.then
  %20 = load %struct.magic*, %struct.magic** %mg, align 8
  %mg_obj5 = getelementptr inbounds %struct.magic, %struct.magic* %20, i32 0, i32 5
  %21 = load %struct.sv*, %struct.sv** %mg_obj5, align 8
  br label %cond.end.9

cond.false.6:                                     ; preds = %if.then
  %22 = load %struct.av*, %struct.av** %ary, align 8
  %23 = bitcast %struct.av* %22 to %struct.sv*
  %call7 = call %struct.sv* @Perl_newRV(%struct.sv* %23)
  %call8 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call7)
  br label %cond.end.9

cond.end.9:                                       ; preds = %cond.false.6, %cond.true.4
  %cond10 = phi %struct.sv* [ %21, %cond.true.4 ], [ %call8, %cond.false.6 ]
  %24 = load %struct.sv**, %struct.sv*** %mark, align 8
  %incdec.ptr11 = getelementptr inbounds %struct.sv*, %struct.sv** %24, i32 -1
  store %struct.sv** %incdec.ptr11, %struct.sv*** %mark, align 8
  store %struct.sv* %cond10, %struct.sv** %24, align 8
  %25 = load i32*, i32** @PL_markstack_ptr, align 8
  %incdec.ptr12 = getelementptr inbounds i32, i32* %25, i32 1
  store i32* %incdec.ptr12, i32** @PL_markstack_ptr, align 8
  %26 = load i32*, i32** @PL_markstack_max, align 8
  %cmp = icmp eq i32* %incdec.ptr12, %26
  br i1 %cmp, label %if.then.14, label %if.end

if.then.14:                                       ; preds = %cond.end.9
  call void @Perl_markstack_grow()
  br label %if.end

if.end:                                           ; preds = %if.then.14, %cond.end.9
  %27 = load %struct.sv**, %struct.sv*** %mark, align 8
  %28 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %sub.ptr.lhs.cast15 = ptrtoint %struct.sv** %27 to i64
  %sub.ptr.rhs.cast16 = ptrtoint %struct.sv** %28 to i64
  %sub.ptr.sub17 = sub i64 %sub.ptr.lhs.cast15, %sub.ptr.rhs.cast16
  %sub.ptr.div18 = sdiv exact i64 %sub.ptr.sub17, 8
  %conv19 = trunc i64 %sub.ptr.div18 to i32
  %29 = load i32*, i32** @PL_markstack_ptr, align 8
  store i32 %conv19, i32* %29, align 4
  store i32 %conv19, i32* %tmp
  %30 = load i32, i32* %tmp
  %31 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %31, %struct.sv*** @PL_stack_sp, align 8
  call void @Perl_push_scope()
  %call20 = call i32 @Perl_call_method(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.46, i32 0, i32 0), i32 2)
  call void @Perl_pop_scope()
  %32 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %32, %struct.sv*** %sp, align 8
  br label %if.end.31

if.else:                                          ; preds = %cond.end
  %33 = load %struct.av*, %struct.av** %ary, align 8
  %34 = load %struct.sv**, %struct.sv*** %sp, align 8
  %35 = load %struct.sv**, %struct.sv*** %mark, align 8
  %sub.ptr.lhs.cast21 = ptrtoint %struct.sv** %34 to i64
  %sub.ptr.rhs.cast22 = ptrtoint %struct.sv** %35 to i64
  %sub.ptr.sub23 = sub i64 %sub.ptr.lhs.cast21, %sub.ptr.rhs.cast22
  %sub.ptr.div24 = sdiv exact i64 %sub.ptr.sub23, 8
  %conv25 = trunc i64 %sub.ptr.div24 to i32
  call void @Perl_av_unshift(%struct.av* %33, i32 %conv25)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.else
  %36 = load %struct.sv**, %struct.sv*** %mark, align 8
  %37 = load %struct.sv**, %struct.sv*** %sp, align 8
  %cmp26 = icmp ult %struct.sv** %36, %37
  br i1 %cmp26, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %38 = load %struct.sv**, %struct.sv*** %mark, align 8
  %incdec.ptr28 = getelementptr inbounds %struct.sv*, %struct.sv** %38, i32 1
  store %struct.sv** %incdec.ptr28, %struct.sv*** %mark, align 8
  %39 = load %struct.sv*, %struct.sv** %incdec.ptr28, align 8
  %call29 = call %struct.sv* @Perl_newSVsv(%struct.sv* %39)
  store %struct.sv* %call29, %struct.sv** %sv, align 8
  %40 = load %struct.av*, %struct.av** %ary, align 8
  %41 = load i32, i32* %i, align 4
  %inc = add nsw i32 %41, 1
  store i32 %inc, i32* %i, align 4
  %42 = load %struct.sv*, %struct.sv** %sv, align 8
  %call30 = call %struct.sv** @Perl_av_store(%struct.av* %40, i32 %41, %struct.sv* %42)
  br label %while.cond

while.end:                                        ; preds = %while.cond
  br label %if.end.31

if.end.31:                                        ; preds = %while.end, %if.end
  %43 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %44 = load i32, i32* %origmark, align 4
  %idx.ext32 = sext i32 %44 to i64
  %add.ptr33 = getelementptr inbounds %struct.sv*, %struct.sv** %43, i64 %idx.ext32
  store %struct.sv** %add.ptr33, %struct.sv*** %sp, align 8
  %45 = load %struct.sv*, %struct.sv** %targ, align 8
  %46 = load %struct.av*, %struct.av** %ary, align 8
  %47 = bitcast %struct.av* %46 to %struct.sv*
  %sv_flags34 = getelementptr inbounds %struct.sv, %struct.sv* %47, i32 0, i32 2
  %48 = load i32, i32* %sv_flags34, align 4
  %and35 = and i32 %48, 32768
  %tobool36 = icmp ne i32 %and35, 0
  br i1 %tobool36, label %cond.true.37, label %cond.false.40

cond.true.37:                                     ; preds = %if.end.31
  %49 = load %struct.av*, %struct.av** %ary, align 8
  %50 = bitcast %struct.av* %49 to %struct.sv*
  %call38 = call i32 @Perl_mg_size(%struct.sv* %50)
  %conv39 = sext i32 %call38 to i64
  br label %cond.end.41

cond.false.40:                                    ; preds = %if.end.31
  %51 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any = getelementptr inbounds %struct.av, %struct.av* %51, i32 0, i32 0
  %52 = load %struct.xpvav*, %struct.xpvav** %sv_any, align 8
  %xav_fill = getelementptr inbounds %struct.xpvav, %struct.xpvav* %52, i32 0, i32 1
  %53 = load i64, i64* %xav_fill, align 8
  br label %cond.end.41

cond.end.41:                                      ; preds = %cond.false.40, %cond.true.37
  %cond42 = phi i64 [ %conv39, %cond.true.37 ], [ %53, %cond.false.40 ]
  %add = add nsw i64 %cond42, 1
  call void @Perl_sv_setiv(%struct.sv* %45, i64 %add)
  %54 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags43 = getelementptr inbounds %struct.sv, %struct.sv* %54, i32 0, i32 2
  %55 = load i32, i32* %sv_flags43, align 4
  %and44 = and i32 %55, 16384
  %tobool45 = icmp ne i32 %and44, 0
  br i1 %tobool45, label %if.then.46, label %if.end.48

if.then.46:                                       ; preds = %cond.end.41
  %56 = load %struct.sv*, %struct.sv** %targ, align 8
  %call47 = call i32 @Perl_mg_set(%struct.sv* %56)
  br label %if.end.48

if.end.48:                                        ; preds = %if.then.46, %cond.end.41
  %57 = load %struct.sv*, %struct.sv** %targ, align 8
  %58 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr50 = getelementptr inbounds %struct.sv*, %struct.sv** %58, i32 1
  store %struct.sv** %incdec.ptr50, %struct.sv*** %sp, align 8
  store %struct.sv* %57, %struct.sv** %incdec.ptr50, align 8
  store %struct.sv* %57, %struct.sv** %tmp49
  %59 = load %struct.sv*, %struct.sv** %tmp49
  %60 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %60, %struct.sv*** @PL_stack_sp, align 8
  %61 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %61, i32 0, i32 0
  %62 = load %struct.op*, %struct.op** %op_next, align 8
  ret %struct.op* %62
}

declare void @Perl_av_unshift(%struct.av*, i32) #1

declare %struct.sv** @Perl_av_store(%struct.av*, i32, %struct.sv*) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_reverse() #0 {
entry:
  %sp = alloca %struct.sv**, align 8
  %mark = alloca %struct.sv**, align 8
  %tmp = alloca %struct.sv*, align 8
  %oldsp = alloca %struct.sv**, align 8
  %up = alloca i8*, align 8
  %down = alloca i8*, align 8
  %tmp17 = alloca i32, align 4
  %targ = alloca %struct.sv*, align 8
  %len = alloca i64, align 8
  %s = alloca i8*, align 8
  %send = alloca i8*, align 8
  %tmp114 = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %2 = load i32*, i32** @PL_markstack_ptr, align 8
  %incdec.ptr = getelementptr inbounds i32, i32* %2, i32 -1
  store i32* %incdec.ptr, i32** @PL_markstack_ptr, align 8
  %3 = load i32, i32* %2, align 4
  %idx.ext = sext i32 %3 to i64
  %add.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %1, i64 %idx.ext
  store %struct.sv** %add.ptr, %struct.sv*** %mark, align 8
  %4 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %4, %struct.sv*** %oldsp, align 8
  %5 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %5, i32 0, i32 6
  %6 = load i8, i8* %op_flags, align 1
  %conv = zext i8 %6 to i32
  %and = and i32 %conv, 3
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %7 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags2 = getelementptr inbounds %struct.op, %struct.op* %7, i32 0, i32 6
  %8 = load i8, i8* %op_flags2, align 1
  %conv3 = zext i8 %8 to i32
  %and4 = and i32 %conv3, 3
  %cmp = icmp eq i32 %and4, 3
  %cond = select i1 %cmp, i32 1, i32 0
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = call i32 @Perl_dowantarray()
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond6 = phi i32 [ %cond, %cond.true ], [ %call, %cond.false ]
  %cmp7 = icmp eq i32 %cond6, 1
  br i1 %cmp7, label %if.then, label %if.else

if.then:                                          ; preds = %cond.end
  %9 = load %struct.sv**, %struct.sv*** %mark, align 8
  %incdec.ptr9 = getelementptr inbounds %struct.sv*, %struct.sv** %9, i32 1
  store %struct.sv** %incdec.ptr9, %struct.sv*** %mark, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then
  %10 = load %struct.sv**, %struct.sv*** %mark, align 8
  %11 = load %struct.sv**, %struct.sv*** %sp, align 8
  %cmp10 = icmp ult %struct.sv** %10, %11
  br i1 %cmp10, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %12 = load %struct.sv**, %struct.sv*** %mark, align 8
  %13 = load %struct.sv*, %struct.sv** %12, align 8
  store %struct.sv* %13, %struct.sv** %tmp, align 8
  %14 = load %struct.sv**, %struct.sv*** %sp, align 8
  %15 = load %struct.sv*, %struct.sv** %14, align 8
  %16 = load %struct.sv**, %struct.sv*** %mark, align 8
  %incdec.ptr12 = getelementptr inbounds %struct.sv*, %struct.sv** %16, i32 1
  store %struct.sv** %incdec.ptr12, %struct.sv*** %mark, align 8
  store %struct.sv* %15, %struct.sv** %16, align 8
  %17 = load %struct.sv*, %struct.sv** %tmp, align 8
  %18 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr13 = getelementptr inbounds %struct.sv*, %struct.sv** %18, i32 -1
  store %struct.sv** %incdec.ptr13, %struct.sv*** %sp, align 8
  store %struct.sv* %17, %struct.sv** %18, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %19 = load %struct.sv**, %struct.sv*** %oldsp, align 8
  store %struct.sv** %19, %struct.sv*** %sp, align 8
  br label %if.end.115

if.else:                                          ; preds = %cond.end
  %20 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %20, i32 0, i32 3
  %21 = load i64, i64* %op_targ, align 8
  %22 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %22, i64 %21
  %23 = load %struct.sv*, %struct.sv** %arrayidx, align 8
  store %struct.sv* %23, %struct.sv** %targ, align 8
  %24 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %24, i32 0, i32 2
  %25 = load i32, i32* %sv_flags, align 4
  %and20 = and i32 %25, -536870913
  store i32 %and20, i32* %sv_flags, align 4
  %26 = load %struct.sv**, %struct.sv*** %sp, align 8
  %27 = load %struct.sv**, %struct.sv*** %mark, align 8
  %sub.ptr.lhs.cast = ptrtoint %struct.sv** %26 to i64
  %sub.ptr.rhs.cast = ptrtoint %struct.sv** %27 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %cmp21 = icmp sgt i64 %sub.ptr.div, 1
  br i1 %cmp21, label %if.then.23, label %if.else.24

if.then.23:                                       ; preds = %if.else
  %28 = load %struct.sv*, %struct.sv** %targ, align 8
  %29 = load %struct.sv**, %struct.sv*** %mark, align 8
  %30 = load %struct.sv**, %struct.sv*** %sp, align 8
  call void @Perl_do_join(%struct.sv* %28, %struct.sv* @PL_sv_no, %struct.sv** %29, %struct.sv** %30)
  br label %if.end

if.else.24:                                       ; preds = %if.else
  %31 = load %struct.sv*, %struct.sv** %targ, align 8
  %32 = load %struct.sv**, %struct.sv*** %sp, align 8
  %33 = load %struct.sv**, %struct.sv*** %mark, align 8
  %cmp25 = icmp ugt %struct.sv** %32, %33
  br i1 %cmp25, label %cond.true.27, label %cond.false.28

cond.true.27:                                     ; preds = %if.else.24
  %34 = load %struct.sv**, %struct.sv*** %sp, align 8
  %35 = load %struct.sv*, %struct.sv** %34, align 8
  br label %cond.end.29

cond.false.28:                                    ; preds = %if.else.24
  %36 = load %struct.gv*, %struct.gv** @PL_defgv, align 8
  %sv_any = getelementptr inbounds %struct.gv, %struct.gv* %36, i32 0, i32 0
  %37 = load %struct.xpvgv*, %struct.xpvgv** %sv_any, align 8
  %xgv_gp = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %37, i32 0, i32 7
  %38 = load %struct.gp*, %struct.gp** %xgv_gp, align 8
  %gp_sv = getelementptr inbounds %struct.gp, %struct.gp* %38, i32 0, i32 0
  %39 = load %struct.sv*, %struct.sv** %gp_sv, align 8
  br label %cond.end.29

cond.end.29:                                      ; preds = %cond.false.28, %cond.true.27
  %cond30 = phi %struct.sv* [ %35, %cond.true.27 ], [ %39, %cond.false.28 ]
  call void @Perl_sv_setsv_flags(%struct.sv* %31, %struct.sv* %cond30, i32 2)
  br label %if.end

if.end:                                           ; preds = %cond.end.29, %if.then.23
  %40 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags31 = getelementptr inbounds %struct.sv, %struct.sv* %40, i32 0, i32 2
  %41 = load i32, i32* %sv_flags31, align 4
  %and32 = and i32 %41, 10223616
  %cmp33 = icmp eq i32 %and32, 262144
  br i1 %cmp33, label %cond.true.35, label %cond.false.38

cond.true.35:                                     ; preds = %if.end
  %42 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any36 = getelementptr inbounds %struct.sv, %struct.sv* %42, i32 0, i32 0
  %43 = load i8*, i8** %sv_any36, align 8
  %44 = bitcast i8* %43 to %struct.xpv*
  %xpv_cur = getelementptr inbounds %struct.xpv, %struct.xpv* %44, i32 0, i32 1
  %45 = load i64, i64* %xpv_cur, align 8
  store i64 %45, i64* %len, align 8
  %46 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any37 = getelementptr inbounds %struct.sv, %struct.sv* %46, i32 0, i32 0
  %47 = load i8*, i8** %sv_any37, align 8
  %48 = bitcast i8* %47 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %48, i32 0, i32 0
  %49 = load i8*, i8** %xpv_pv, align 8
  br label %cond.end.40

cond.false.38:                                    ; preds = %if.end
  %50 = load %struct.sv*, %struct.sv** %targ, align 8
  %call39 = call i8* @Perl_sv_pvn_force_flags(%struct.sv* %50, i64* %len, i32 2)
  br label %cond.end.40

cond.end.40:                                      ; preds = %cond.false.38, %cond.true.35
  %cond41 = phi i8* [ %49, %cond.true.35 ], [ %call39, %cond.false.38 ]
  store i8* %cond41, i8** %up, align 8
  %51 = load i64, i64* %len, align 8
  %cmp42 = icmp ugt i64 %51, 1
  br i1 %cmp42, label %if.then.44, label %if.end.106

if.then.44:                                       ; preds = %cond.end.40
  %52 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags45 = getelementptr inbounds %struct.sv, %struct.sv* %52, i32 0, i32 2
  %53 = load i32, i32* %sv_flags45, align 4
  %and46 = and i32 %53, 536870912
  %tobool47 = icmp ne i32 %and46, 0
  br i1 %tobool47, label %land.lhs.true, label %if.end.89

land.lhs.true:                                    ; preds = %if.then.44
  %54 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %op_private = getelementptr inbounds %struct.cop, %struct.cop* %54, i32 0, i32 7
  %55 = load i8, i8* %op_private, align 1
  %conv48 = zext i8 %55 to i32
  %and49 = and i32 %conv48, 8
  %tobool50 = icmp ne i32 %and49, 0
  br i1 %tobool50, label %if.end.89, label %if.then.51

if.then.51:                                       ; preds = %land.lhs.true
  %56 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any53 = getelementptr inbounds %struct.sv, %struct.sv* %56, i32 0, i32 0
  %57 = load i8*, i8** %sv_any53, align 8
  %58 = bitcast i8* %57 to %struct.xpv*
  %xpv_pv54 = getelementptr inbounds %struct.xpv, %struct.xpv* %58, i32 0, i32 0
  %59 = load i8*, i8** %xpv_pv54, align 8
  store i8* %59, i8** %s, align 8
  %60 = load i8*, i8** %s, align 8
  %61 = load i64, i64* %len, align 8
  %add.ptr56 = getelementptr inbounds i8, i8* %60, i64 %61
  store i8* %add.ptr56, i8** %send, align 8
  br label %while.cond.57

while.cond.57:                                    ; preds = %if.end.85, %if.then.64, %if.then.51
  %62 = load i8*, i8** %s, align 8
  %63 = load i8*, i8** %send, align 8
  %cmp58 = icmp ult i8* %62, %63
  br i1 %cmp58, label %while.body.60, label %while.end.86

while.body.60:                                    ; preds = %while.cond.57
  %64 = load i8*, i8** %s, align 8
  %65 = load i8, i8* %64, align 1
  %conv61 = zext i8 %65 to i64
  %cmp62 = icmp ult i64 %conv61, 128
  br i1 %cmp62, label %if.then.64, label %if.else.66

if.then.64:                                       ; preds = %while.body.60
  %66 = load i8*, i8** %s, align 8
  %incdec.ptr65 = getelementptr inbounds i8, i8* %66, i32 1
  store i8* %incdec.ptr65, i8** %s, align 8
  br label %while.cond.57

if.else.66:                                       ; preds = %while.body.60
  %67 = load i8*, i8** %s, align 8
  %call67 = call i64 @Perl_utf8_to_uvchr(i8* %67, i64* null)
  %tobool68 = icmp ne i64 %call67, 0
  br i1 %tobool68, label %if.end.70, label %if.then.69

if.then.69:                                       ; preds = %if.else.66
  br label %while.end.86

if.end.70:                                        ; preds = %if.else.66
  %68 = load i8*, i8** %s, align 8
  store i8* %68, i8** %up, align 8
  %69 = load i8*, i8** %s, align 8
  %70 = load i8, i8* %69, align 1
  %idxprom = zext i8 %70 to i64
  %arrayidx71 = getelementptr inbounds [0 x i8], [0 x i8]* @PL_utf8skip, i32 0, i64 %idxprom
  %71 = load i8, i8* %arrayidx71, align 1
  %conv72 = zext i8 %71 to i32
  %72 = load i8*, i8** %s, align 8
  %idx.ext73 = sext i32 %conv72 to i64
  %add.ptr74 = getelementptr inbounds i8, i8* %72, i64 %idx.ext73
  store i8* %add.ptr74, i8** %s, align 8
  %73 = load i8*, i8** %s, align 8
  %add.ptr75 = getelementptr inbounds i8, i8* %73, i64 -1
  store i8* %add.ptr75, i8** %down, align 8
  br label %while.cond.76

while.cond.76:                                    ; preds = %while.body.79, %if.end.70
  %74 = load i8*, i8** %down, align 8
  %75 = load i8*, i8** %up, align 8
  %cmp77 = icmp ugt i8* %74, %75
  br i1 %cmp77, label %while.body.79, label %while.end.84

while.body.79:                                    ; preds = %while.cond.76
  %76 = load i8*, i8** %up, align 8
  %77 = load i8, i8* %76, align 1
  %conv80 = sext i8 %77 to i32
  store i32 %conv80, i32* %tmp17, align 4
  %78 = load i8*, i8** %down, align 8
  %79 = load i8, i8* %78, align 1
  %80 = load i8*, i8** %up, align 8
  %incdec.ptr81 = getelementptr inbounds i8, i8* %80, i32 1
  store i8* %incdec.ptr81, i8** %up, align 8
  store i8 %79, i8* %80, align 1
  %81 = load i32, i32* %tmp17, align 4
  %conv82 = trunc i32 %81 to i8
  %82 = load i8*, i8** %down, align 8
  %incdec.ptr83 = getelementptr inbounds i8, i8* %82, i32 -1
  store i8* %incdec.ptr83, i8** %down, align 8
  store i8 %conv82, i8* %82, align 1
  br label %while.cond.76

while.end.84:                                     ; preds = %while.cond.76
  br label %if.end.85

if.end.85:                                        ; preds = %while.end.84
  br label %while.cond.57

while.end.86:                                     ; preds = %if.then.69, %while.cond.57
  %83 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any87 = getelementptr inbounds %struct.sv, %struct.sv* %83, i32 0, i32 0
  %84 = load i8*, i8** %sv_any87, align 8
  %85 = bitcast i8* %84 to %struct.xpv*
  %xpv_pv88 = getelementptr inbounds %struct.xpv, %struct.xpv* %85, i32 0, i32 0
  %86 = load i8*, i8** %xpv_pv88, align 8
  store i8* %86, i8** %up, align 8
  br label %if.end.89

if.end.89:                                        ; preds = %while.end.86, %land.lhs.true, %if.then.44
  %87 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_any90 = getelementptr inbounds %struct.sv, %struct.sv* %87, i32 0, i32 0
  %88 = load i8*, i8** %sv_any90, align 8
  %89 = bitcast i8* %88 to %struct.xpv*
  %xpv_pv91 = getelementptr inbounds %struct.xpv, %struct.xpv* %89, i32 0, i32 0
  %90 = load i8*, i8** %xpv_pv91, align 8
  %91 = load i64, i64* %len, align 8
  %add.ptr92 = getelementptr inbounds i8, i8* %90, i64 %91
  %add.ptr93 = getelementptr inbounds i8, i8* %add.ptr92, i64 -1
  store i8* %add.ptr93, i8** %down, align 8
  br label %while.cond.94

while.cond.94:                                    ; preds = %while.body.97, %if.end.89
  %92 = load i8*, i8** %down, align 8
  %93 = load i8*, i8** %up, align 8
  %cmp95 = icmp ugt i8* %92, %93
  br i1 %cmp95, label %while.body.97, label %while.end.102

while.body.97:                                    ; preds = %while.cond.94
  %94 = load i8*, i8** %up, align 8
  %95 = load i8, i8* %94, align 1
  %conv98 = sext i8 %95 to i32
  store i32 %conv98, i32* %tmp17, align 4
  %96 = load i8*, i8** %down, align 8
  %97 = load i8, i8* %96, align 1
  %98 = load i8*, i8** %up, align 8
  %incdec.ptr99 = getelementptr inbounds i8, i8* %98, i32 1
  store i8* %incdec.ptr99, i8** %up, align 8
  store i8 %97, i8* %98, align 1
  %99 = load i32, i32* %tmp17, align 4
  %conv100 = trunc i32 %99 to i8
  %100 = load i8*, i8** %down, align 8
  %incdec.ptr101 = getelementptr inbounds i8, i8* %100, i32 -1
  store i8* %incdec.ptr101, i8** %down, align 8
  store i8 %conv100, i8* %100, align 1
  br label %while.cond.94

while.end.102:                                    ; preds = %while.cond.94
  %101 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags103 = getelementptr inbounds %struct.sv, %struct.sv* %101, i32 0, i32 2
  %102 = load i32, i32* %sv_flags103, align 4
  %and104 = and i32 %102, 1760624639
  store i32 %and104, i32* %sv_flags103, align 4
  %103 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags105 = getelementptr inbounds %struct.sv, %struct.sv* %103, i32 0, i32 2
  %104 = load i32, i32* %sv_flags105, align 4
  %or = or i32 %104, 67371008
  store i32 %or, i32* %sv_flags105, align 4
  br label %if.end.106

if.end.106:                                       ; preds = %while.end.102, %cond.end.40
  %105 = load %struct.sv**, %struct.sv*** %mark, align 8
  %add.ptr107 = getelementptr inbounds %struct.sv*, %struct.sv** %105, i64 1
  store %struct.sv** %add.ptr107, %struct.sv*** %sp, align 8
  %106 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags108 = getelementptr inbounds %struct.sv, %struct.sv* %106, i32 0, i32 2
  %107 = load i32, i32* %sv_flags108, align 4
  %and109 = and i32 %107, 16384
  %tobool110 = icmp ne i32 %and109, 0
  br i1 %tobool110, label %if.then.111, label %if.end.113

if.then.111:                                      ; preds = %if.end.106
  %108 = load %struct.sv*, %struct.sv** %targ, align 8
  %call112 = call i32 @Perl_mg_set(%struct.sv* %108)
  br label %if.end.113

if.end.113:                                       ; preds = %if.then.111, %if.end.106
  %109 = load %struct.sv*, %struct.sv** %targ, align 8
  %110 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %109, %struct.sv** %110, align 8
  store %struct.sv* %109, %struct.sv** %tmp114
  %111 = load %struct.sv*, %struct.sv** %tmp114
  br label %if.end.115

if.end.115:                                       ; preds = %if.end.113, %while.end
  %112 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %112, %struct.sv*** @PL_stack_sp, align 8
  %113 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %113, i32 0, i32 0
  %114 = load %struct.op*, %struct.op** %op_next, align 8
  ret %struct.op* %114
}

declare void @Perl_do_join(%struct.sv*, %struct.sv*, %struct.sv**, %struct.sv**) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_split() #0 {
entry:
  %retval = alloca %struct.op*, align 8
  %sp = alloca %struct.sv**, align 8
  %targ = alloca %struct.sv*, align 8
  %ary = alloca %struct.av*, align 8
  %limit = alloca i64, align 8
  %sv = alloca %struct.sv*, align 8
  %len = alloca i64, align 8
  %s = alloca i8*, align 8
  %do_utf8 = alloca i8, align 1
  %strend = alloca i8*, align 8
  %pm = alloca %struct.pmop*, align 8
  %rx = alloca %struct.regexp*, align 8
  %dstr = alloca %struct.sv*, align 8
  %m = alloca i8*, align 8
  %iters = alloca i32, align 4
  %slen = alloca i64, align 8
  %maxiters = alloca i32, align 4
  %i = alloca i32, align 4
  %orig = alloca i8*, align 8
  %origlimit = alloca i32, align 4
  %realarray = alloca i32, align 4
  %base = alloca i32, align 4
  %gimme = alloca i32, align 4
  %oldsave = alloca i32, align 4
  %make_mortal = alloca i32, align 4
  %mg = alloca %struct.magic*, align 8
  %tmp = alloca i32, align 4
  %tmp148 = alloca %struct.sv*, align 8
  %tmp207 = alloca %struct.av*, align 8
  %tmp208 = alloca %struct.av*, align 8
  %tmp362 = alloca %struct.sv*, align 8
  %tmp474 = alloca %struct.sv*, align 8
  %tail = alloca i32, align 4
  %csv = alloca %struct.sv*, align 8
  %n_a = alloca i64, align 8
  %c = alloca i8, align 1
  %tmp574 = alloca %struct.sv*, align 8
  %tmp621 = alloca %struct.sv*, align 8
  %tmp698 = alloca %struct.sv*, align 8
  %tmp747 = alloca %struct.sv*, align 8
  %l = alloca i64, align 8
  %tmp802 = alloca %struct.sv*, align 8
  %svp = alloca %struct.sv**, align 8
  %tmp920 = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr = getelementptr inbounds %struct.sv*, %struct.sv** %1, i32 -1
  store %struct.sv** %incdec.ptr, %struct.sv*** %sp, align 8
  %2 = load %struct.sv*, %struct.sv** %1, align 8
  store %struct.sv* %2, %struct.sv** @PL_Sv, align 8
  %3 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %3, i32 0, i32 2
  %4 = load i32, i32* %sv_flags, align 4
  %and = and i32 %4, 65536
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %5 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %sv_any = getelementptr inbounds %struct.sv, %struct.sv* %5, i32 0, i32 0
  %6 = load i8*, i8** %sv_any, align 8
  %7 = bitcast i8* %6 to %struct.xpviv*
  %xiv_iv = getelementptr inbounds %struct.xpviv, %struct.xpviv* %7, i32 0, i32 3
  %8 = load i64, i64* %xiv_iv, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %9 = load %struct.sv*, %struct.sv** @PL_Sv, align 8
  %call = call i64 @Perl_sv_2iv(%struct.sv* %9)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %8, %cond.true ], [ %call, %cond.false ]
  store i64 %cond, i64* %limit, align 8
  %10 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr1 = getelementptr inbounds %struct.sv*, %struct.sv** %10, i32 -1
  store %struct.sv** %incdec.ptr1, %struct.sv*** %sp, align 8
  %11 = load %struct.sv*, %struct.sv** %10, align 8
  store %struct.sv* %11, %struct.sv** %sv, align 8
  %12 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags2 = getelementptr inbounds %struct.sv, %struct.sv* %12, i32 0, i32 2
  %13 = load i32, i32* %sv_flags2, align 4
  %and3 = and i32 %13, 262144
  %cmp = icmp eq i32 %and3, 262144
  br i1 %cmp, label %cond.true.4, label %cond.false.7

cond.true.4:                                      ; preds = %cond.end
  %14 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any5 = getelementptr inbounds %struct.sv, %struct.sv* %14, i32 0, i32 0
  %15 = load i8*, i8** %sv_any5, align 8
  %16 = bitcast i8* %15 to %struct.xpv*
  %xpv_cur = getelementptr inbounds %struct.xpv, %struct.xpv* %16, i32 0, i32 1
  %17 = load i64, i64* %xpv_cur, align 8
  store i64 %17, i64* %len, align 8
  %18 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_any6 = getelementptr inbounds %struct.sv, %struct.sv* %18, i32 0, i32 0
  %19 = load i8*, i8** %sv_any6, align 8
  %20 = bitcast i8* %19 to %struct.xpv*
  %xpv_pv = getelementptr inbounds %struct.xpv, %struct.xpv* %20, i32 0, i32 0
  %21 = load i8*, i8** %xpv_pv, align 8
  br label %cond.end.9

cond.false.7:                                     ; preds = %cond.end
  %22 = load %struct.sv*, %struct.sv** %sv, align 8
  %call8 = call i8* @Perl_sv_2pv_flags(%struct.sv* %22, i64* %len, i32 2)
  br label %cond.end.9

cond.end.9:                                       ; preds = %cond.false.7, %cond.true.4
  %cond10 = phi i8* [ %21, %cond.true.4 ], [ %call8, %cond.false.7 ]
  store i8* %cond10, i8** %s, align 8
  %23 = load %struct.sv*, %struct.sv** %sv, align 8
  %sv_flags11 = getelementptr inbounds %struct.sv, %struct.sv* %23, i32 0, i32 2
  %24 = load i32, i32* %sv_flags11, align 4
  %and12 = and i32 %24, 536870912
  %tobool13 = icmp ne i32 %and12, 0
  br i1 %tobool13, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %cond.end.9
  %25 = load volatile %struct.cop*, %struct.cop** @PL_curcop, align 8
  %op_private = getelementptr inbounds %struct.cop, %struct.cop* %25, i32 0, i32 7
  %26 = load i8, i8* %op_private, align 1
  %conv = zext i8 %26 to i32
  %and14 = and i32 %conv, 8
  %tobool15 = icmp ne i32 %and14, 0
  %lnot = xor i1 %tobool15, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %cond.end.9
  %27 = phi i1 [ false, %cond.end.9 ], [ %lnot, %land.rhs ]
  %land.ext = zext i1 %27 to i32
  %conv16 = trunc i32 %land.ext to i8
  store i8 %conv16, i8* %do_utf8, align 1
  %28 = load i8*, i8** %s, align 8
  %29 = load i64, i64* %len, align 8
  %add.ptr = getelementptr inbounds i8, i8* %28, i64 %29
  store i8* %add.ptr, i8** %strend, align 8
  store i32 0, i32* %iters, align 4
  %30 = load i8, i8* %do_utf8, align 1
  %conv17 = sext i8 %30 to i32
  %tobool18 = icmp ne i32 %conv17, 0
  br i1 %tobool18, label %cond.true.19, label %cond.false.21

cond.true.19:                                     ; preds = %land.end
  %31 = load i8*, i8** %s, align 8
  %32 = load i8*, i8** %strend, align 8
  %call20 = call i64 @Perl_utf8_length(i8* %31, i8* %32)
  br label %cond.end.22

cond.false.21:                                    ; preds = %land.end
  %33 = load i8*, i8** %strend, align 8
  %34 = load i8*, i8** %s, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %33 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %34 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  br label %cond.end.22

cond.end.22:                                      ; preds = %cond.false.21, %cond.true.19
  %cond23 = phi i64 [ %call20, %cond.true.19 ], [ %sub.ptr.sub, %cond.false.21 ]
  store i64 %cond23, i64* %slen, align 8
  %35 = load i64, i64* %slen, align 8
  %add = add i64 %35, 10
  %conv24 = trunc i64 %add to i32
  store i32 %conv24, i32* %maxiters, align 4
  %36 = load i64, i64* %limit, align 8
  %conv25 = trunc i64 %36 to i32
  store i32 %conv25, i32* %origlimit, align 4
  store i32 0, i32* %realarray, align 4
  %37 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags = getelementptr inbounds %struct.op, %struct.op* %37, i32 0, i32 6
  %38 = load i8, i8* %op_flags, align 1
  %conv26 = zext i8 %38 to i32
  %and27 = and i32 %conv26, 3
  %cmp28 = icmp eq i32 %and27, 1
  br i1 %cmp28, label %cond.true.30, label %cond.false.31

cond.true.30:                                     ; preds = %cond.end.22
  br label %cond.end.51

cond.false.31:                                    ; preds = %cond.end.22
  %39 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags32 = getelementptr inbounds %struct.op, %struct.op* %39, i32 0, i32 6
  %40 = load i8, i8* %op_flags32, align 1
  %conv33 = zext i8 %40 to i32
  %and34 = and i32 %conv33, 3
  %cmp35 = icmp eq i32 %and34, 2
  br i1 %cmp35, label %cond.true.37, label %cond.false.38

cond.true.37:                                     ; preds = %cond.false.31
  br label %cond.end.49

cond.false.38:                                    ; preds = %cond.false.31
  %41 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_flags39 = getelementptr inbounds %struct.op, %struct.op* %41, i32 0, i32 6
  %42 = load i8, i8* %op_flags39, align 1
  %conv40 = zext i8 %42 to i32
  %and41 = and i32 %conv40, 3
  %cmp42 = icmp eq i32 %and41, 3
  br i1 %cmp42, label %cond.true.44, label %cond.false.45

cond.true.44:                                     ; preds = %cond.false.38
  br label %cond.end.47

cond.false.45:                                    ; preds = %cond.false.38
  %call46 = call i32 @Perl_block_gimme()
  br label %cond.end.47

cond.end.47:                                      ; preds = %cond.false.45, %cond.true.44
  %cond48 = phi i32 [ 1, %cond.true.44 ], [ %call46, %cond.false.45 ]
  br label %cond.end.49

cond.end.49:                                      ; preds = %cond.end.47, %cond.true.37
  %cond50 = phi i32 [ 0, %cond.true.37 ], [ %cond48, %cond.end.47 ]
  br label %cond.end.51

cond.end.51:                                      ; preds = %cond.end.49, %cond.true.30
  %cond52 = phi i32 [ 128, %cond.true.30 ], [ %cond50, %cond.end.49 ]
  store i32 %cond52, i32* %gimme, align 4
  %43 = load i32, i32* @PL_savestack_ix, align 4
  store i32 %43, i32* %oldsave, align 4
  store i32 1, i32* %make_mortal, align 4
  store %struct.magic* null, %struct.magic** %mg, align 8
  %44 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr53 = getelementptr inbounds %struct.sv*, %struct.sv** %44, i32 -1
  store %struct.sv** %incdec.ptr53, %struct.sv*** %sp, align 8
  %45 = load %struct.sv*, %struct.sv** %44, align 8
  %46 = bitcast %struct.sv* %45 to %struct.pmop*
  store %struct.pmop* %46, %struct.pmop** %pm, align 8
  %47 = load %struct.pmop*, %struct.pmop** %pm, align 8
  %tobool54 = icmp ne %struct.pmop* %47, null
  br i1 %tobool54, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %cond.end.51
  %48 = load i8*, i8** %s, align 8
  %tobool55 = icmp ne i8* %48, null
  br i1 %tobool55, label %if.end, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %cond.end.51
  %call56 = call %struct.op* (i8*, ...) @Perl_die(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.47, i32 0, i32 0))
  store %struct.op* %call56, %struct.op** %retval
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %49 = load %struct.pmop*, %struct.pmop** %pm, align 8
  %op_pmregexp = getelementptr inbounds %struct.pmop, %struct.pmop* %49, i32 0, i32 13
  %50 = load %struct.regexp*, %struct.regexp** %op_pmregexp, align 8
  store %struct.regexp* %50, %struct.regexp** %rx, align 8
  %51 = load %struct.pmop*, %struct.pmop** %pm, align 8
  %op_pmflags = getelementptr inbounds %struct.pmop, %struct.pmop* %51, i32 0, i32 14
  %52 = load i32, i32* %op_pmflags, align 4
  %and57 = and i32 %52, 2048
  %tobool58 = icmp ne i32 %and57, 0
  br i1 %tobool58, label %land.lhs.true, label %if.end.63

land.lhs.true:                                    ; preds = %if.end
  %53 = load %struct.pmop*, %struct.pmop** %pm, align 8
  %op_pmflags59 = getelementptr inbounds %struct.pmop, %struct.pmop* %53, i32 0, i32 14
  %54 = load i32, i32* %op_pmflags59, align 4
  %and60 = and i32 %54, 48
  %tobool61 = icmp ne i32 %and60, 0
  br i1 %tobool61, label %if.then.62, label %if.end.63

if.then.62:                                       ; preds = %land.lhs.true
  store i8 1, i8* @PL_tainted, align 1
  br label %if.end.63

if.end.63:                                        ; preds = %if.then.62, %land.lhs.true, %if.end
  %55 = load i8, i8* %do_utf8, align 1
  %conv64 = sext i8 %55 to i32
  %tobool65 = icmp ne i32 %conv64, 0
  br i1 %tobool65, label %cond.true.66, label %cond.false.67

cond.true.66:                                     ; preds = %if.end.63
  %56 = load %struct.regexp*, %struct.regexp** %rx, align 8
  %reganch = getelementptr inbounds %struct.regexp, %struct.regexp* %56, i32 0, i32 15
  %57 = load i32, i32* %reganch, align 4
  %or = or i32 %57, 268435456
  store i32 %or, i32* %reganch, align 4
  store i8 1, i8* @PL_reg_match_utf8, align 1
  br label %cond.end.70

cond.false.67:                                    ; preds = %if.end.63
  %58 = load %struct.regexp*, %struct.regexp** %rx, align 8
  %reganch68 = getelementptr inbounds %struct.regexp, %struct.regexp* %58, i32 0, i32 15
  %59 = load i32, i32* %reganch68, align 4
  %and69 = and i32 %59, -268435457
  store i32 %and69, i32* %reganch68, align 4
  store i8 0, i8* @PL_reg_match_utf8, align 1
  br label %cond.end.70

cond.end.70:                                      ; preds = %cond.false.67, %cond.true.66
  %cond71 = phi i32 [ 1, %cond.true.66 ], [ 0, %cond.false.67 ]
  %60 = load %struct.pmop*, %struct.pmop** %pm, align 8
  %op_pmreplroot = getelementptr inbounds %struct.pmop, %struct.pmop* %60, i32 0, i32 10
  %61 = load %struct.op*, %struct.op** %op_pmreplroot, align 8
  %tobool72 = icmp ne %struct.op* %61, null
  br i1 %tobool72, label %if.then.73, label %if.else

if.then.73:                                       ; preds = %cond.end.70
  %62 = load %struct.pmop*, %struct.pmop** %pm, align 8
  %op_pmreplroot74 = getelementptr inbounds %struct.pmop, %struct.pmop* %62, i32 0, i32 10
  %63 = load %struct.op*, %struct.op** %op_pmreplroot74, align 8
  %64 = bitcast %struct.op* %63 to %struct.gv*
  %sv_any75 = getelementptr inbounds %struct.gv, %struct.gv* %64, i32 0, i32 0
  %65 = load %struct.xpvgv*, %struct.xpvgv** %sv_any75, align 8
  %xgv_gp = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %65, i32 0, i32 7
  %66 = load %struct.gp*, %struct.gp** %xgv_gp, align 8
  %gp_av = getelementptr inbounds %struct.gp, %struct.gp* %66, i32 0, i32 4
  %67 = load %struct.av*, %struct.av** %gp_av, align 8
  %tobool76 = icmp ne %struct.av* %67, null
  br i1 %tobool76, label %cond.true.77, label %cond.false.82

cond.true.77:                                     ; preds = %if.then.73
  %68 = load %struct.pmop*, %struct.pmop** %pm, align 8
  %op_pmreplroot78 = getelementptr inbounds %struct.pmop, %struct.pmop* %68, i32 0, i32 10
  %69 = load %struct.op*, %struct.op** %op_pmreplroot78, align 8
  %70 = bitcast %struct.op* %69 to %struct.gv*
  %sv_any79 = getelementptr inbounds %struct.gv, %struct.gv* %70, i32 0, i32 0
  %71 = load %struct.xpvgv*, %struct.xpvgv** %sv_any79, align 8
  %xgv_gp80 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %71, i32 0, i32 7
  %72 = load %struct.gp*, %struct.gp** %xgv_gp80, align 8
  %gp_av81 = getelementptr inbounds %struct.gp, %struct.gp* %72, i32 0, i32 4
  %73 = load %struct.av*, %struct.av** %gp_av81, align 8
  br label %cond.end.88

cond.false.82:                                    ; preds = %if.then.73
  %74 = load %struct.pmop*, %struct.pmop** %pm, align 8
  %op_pmreplroot83 = getelementptr inbounds %struct.pmop, %struct.pmop* %74, i32 0, i32 10
  %75 = load %struct.op*, %struct.op** %op_pmreplroot83, align 8
  %76 = bitcast %struct.op* %75 to %struct.gv*
  %call84 = call %struct.gv* @Perl_gv_AVadd(%struct.gv* %76)
  %sv_any85 = getelementptr inbounds %struct.gv, %struct.gv* %call84, i32 0, i32 0
  %77 = load %struct.xpvgv*, %struct.xpvgv** %sv_any85, align 8
  %xgv_gp86 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %77, i32 0, i32 7
  %78 = load %struct.gp*, %struct.gp** %xgv_gp86, align 8
  %gp_av87 = getelementptr inbounds %struct.gp, %struct.gp* %78, i32 0, i32 4
  %79 = load %struct.av*, %struct.av** %gp_av87, align 8
  br label %cond.end.88

cond.end.88:                                      ; preds = %cond.false.82, %cond.true.77
  %cond89 = phi %struct.av* [ %73, %cond.true.77 ], [ %79, %cond.false.82 ]
  store %struct.av* %cond89, %struct.av** %ary, align 8
  br label %if.end.110

if.else:                                          ; preds = %cond.end.70
  %80 = load i32, i32* %gimme, align 4
  %cmp90 = icmp ne i32 %80, 1
  br i1 %cmp90, label %if.then.92, label %if.else.108

if.then.92:                                       ; preds = %if.else
  %81 = load %struct.gv*, %struct.gv** @PL_defgv, align 8
  %sv_any93 = getelementptr inbounds %struct.gv, %struct.gv* %81, i32 0, i32 0
  %82 = load %struct.xpvgv*, %struct.xpvgv** %sv_any93, align 8
  %xgv_gp94 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %82, i32 0, i32 7
  %83 = load %struct.gp*, %struct.gp** %xgv_gp94, align 8
  %gp_av95 = getelementptr inbounds %struct.gp, %struct.gp* %83, i32 0, i32 4
  %84 = load %struct.av*, %struct.av** %gp_av95, align 8
  %tobool96 = icmp ne %struct.av* %84, null
  br i1 %tobool96, label %cond.true.97, label %cond.false.101

cond.true.97:                                     ; preds = %if.then.92
  %85 = load %struct.gv*, %struct.gv** @PL_defgv, align 8
  %sv_any98 = getelementptr inbounds %struct.gv, %struct.gv* %85, i32 0, i32 0
  %86 = load %struct.xpvgv*, %struct.xpvgv** %sv_any98, align 8
  %xgv_gp99 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %86, i32 0, i32 7
  %87 = load %struct.gp*, %struct.gp** %xgv_gp99, align 8
  %gp_av100 = getelementptr inbounds %struct.gp, %struct.gp* %87, i32 0, i32 4
  %88 = load %struct.av*, %struct.av** %gp_av100, align 8
  br label %cond.end.106

cond.false.101:                                   ; preds = %if.then.92
  %89 = load %struct.gv*, %struct.gv** @PL_defgv, align 8
  %call102 = call %struct.gv* @Perl_gv_AVadd(%struct.gv* %89)
  %sv_any103 = getelementptr inbounds %struct.gv, %struct.gv* %call102, i32 0, i32 0
  %90 = load %struct.xpvgv*, %struct.xpvgv** %sv_any103, align 8
  %xgv_gp104 = getelementptr inbounds %struct.xpvgv, %struct.xpvgv* %90, i32 0, i32 7
  %91 = load %struct.gp*, %struct.gp** %xgv_gp104, align 8
  %gp_av105 = getelementptr inbounds %struct.gp, %struct.gp* %91, i32 0, i32 4
  %92 = load %struct.av*, %struct.av** %gp_av105, align 8
  br label %cond.end.106

cond.end.106:                                     ; preds = %cond.false.101, %cond.true.97
  %cond107 = phi %struct.av* [ %88, %cond.true.97 ], [ %92, %cond.false.101 ]
  store %struct.av* %cond107, %struct.av** %ary, align 8
  br label %if.end.109

if.else.108:                                      ; preds = %if.else
  store %struct.av* null, %struct.av** %ary, align 8
  br label %if.end.109

if.end.109:                                       ; preds = %if.else.108, %cond.end.106
  br label %if.end.110

if.end.110:                                       ; preds = %if.end.109, %cond.end.88
  %93 = load %struct.av*, %struct.av** %ary, align 8
  %tobool111 = icmp ne %struct.av* %93, null
  br i1 %tobool111, label %land.lhs.true.112, label %if.end.210

land.lhs.true.112:                                ; preds = %if.end.110
  %94 = load i32, i32* %gimme, align 4
  %cmp113 = icmp ne i32 %94, 1
  br i1 %cmp113, label %if.then.119, label %lor.lhs.false.115

lor.lhs.false.115:                                ; preds = %land.lhs.true.112
  %95 = load %struct.pmop*, %struct.pmop** %pm, align 8
  %op_pmflags116 = getelementptr inbounds %struct.pmop, %struct.pmop* %95, i32 0, i32 14
  %96 = load i32, i32* %op_pmflags116, align 4
  %and117 = and i32 %96, 2
  %tobool118 = icmp ne i32 %and117, 0
  br i1 %tobool118, label %if.then.119, label %if.end.210

if.then.119:                                      ; preds = %lor.lhs.false.115, %land.lhs.true.112
  store i32 1, i32* %realarray, align 4
  %97 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %97, %struct.sv*** @PL_stack_sp, align 8
  %98 = load %struct.av*, %struct.av** %ary, align 8
  call void @Perl_av_extend(%struct.av* %98, i32 0)
  %99 = load %struct.av*, %struct.av** %ary, align 8
  call void @Perl_av_clear(%struct.av* %99)
  %100 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %100, %struct.sv*** %sp, align 8
  %101 = load %struct.av*, %struct.av** %ary, align 8
  %102 = bitcast %struct.av* %101 to %struct.sv*
  %sv_flags120 = getelementptr inbounds %struct.sv, %struct.sv* %102, i32 0, i32 2
  %103 = load i32, i32* %sv_flags120, align 4
  %and121 = and i32 %103, 32768
  %tobool122 = icmp ne i32 %and121, 0
  br i1 %tobool122, label %cond.true.123, label %cond.false.125

cond.true.123:                                    ; preds = %if.then.119
  %104 = load %struct.av*, %struct.av** %ary, align 8
  %105 = bitcast %struct.av* %104 to %struct.sv*
  %call124 = call %struct.magic* @Perl_mg_find(%struct.sv* %105, i32 80)
  br label %cond.end.126

cond.false.125:                                   ; preds = %if.then.119
  br label %cond.end.126

cond.end.126:                                     ; preds = %cond.false.125, %cond.true.123
  %cond127 = phi %struct.magic* [ %call124, %cond.true.123 ], [ null, %cond.false.125 ]
  store %struct.magic* %cond127, %struct.magic** %mg, align 8
  %tobool128 = icmp ne %struct.magic* %cond127, null
  br i1 %tobool128, label %if.then.129, label %if.else.158

if.then.129:                                      ; preds = %cond.end.126
  %106 = load i32*, i32** @PL_markstack_ptr, align 8
  %incdec.ptr130 = getelementptr inbounds i32, i32* %106, i32 1
  store i32* %incdec.ptr130, i32** @PL_markstack_ptr, align 8
  %107 = load i32*, i32** @PL_markstack_max, align 8
  %cmp131 = icmp eq i32* %incdec.ptr130, %107
  br i1 %cmp131, label %if.then.133, label %if.end.134

if.then.133:                                      ; preds = %if.then.129
  call void @Perl_markstack_grow()
  br label %if.end.134

if.end.134:                                       ; preds = %if.then.133, %if.then.129
  %108 = load %struct.sv**, %struct.sv*** %sp, align 8
  %109 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %sub.ptr.lhs.cast135 = ptrtoint %struct.sv** %108 to i64
  %sub.ptr.rhs.cast136 = ptrtoint %struct.sv** %109 to i64
  %sub.ptr.sub137 = sub i64 %sub.ptr.lhs.cast135, %sub.ptr.rhs.cast136
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub137, 8
  %conv138 = trunc i64 %sub.ptr.div to i32
  %110 = load i32*, i32** @PL_markstack_ptr, align 8
  store i32 %conv138, i32* %110, align 4
  store i32 %conv138, i32* %tmp
  %111 = load i32, i32* %tmp
  %112 = load %struct.sv**, %struct.sv*** @PL_stack_max, align 8
  %113 = load %struct.sv**, %struct.sv*** %sp, align 8
  %sub.ptr.lhs.cast139 = ptrtoint %struct.sv** %112 to i64
  %sub.ptr.rhs.cast140 = ptrtoint %struct.sv** %113 to i64
  %sub.ptr.sub141 = sub i64 %sub.ptr.lhs.cast139, %sub.ptr.rhs.cast140
  %sub.ptr.div142 = sdiv exact i64 %sub.ptr.sub141, 8
  %cmp143 = icmp slt i64 %sub.ptr.div142, 1
  br i1 %cmp143, label %if.then.145, label %if.end.147

if.then.145:                                      ; preds = %if.end.134
  %114 = load %struct.sv**, %struct.sv*** %sp, align 8
  %115 = load %struct.sv**, %struct.sv*** %sp, align 8
  %call146 = call %struct.sv** @Perl_stack_grow(%struct.sv** %114, %struct.sv** %115, i32 1)
  store %struct.sv** %call146, %struct.sv*** %sp, align 8
  br label %if.end.147

if.end.147:                                       ; preds = %if.then.145, %if.end.134
  %116 = load %struct.magic*, %struct.magic** %mg, align 8
  %mg_obj = getelementptr inbounds %struct.magic, %struct.magic* %116, i32 0, i32 5
  %117 = load %struct.sv*, %struct.sv** %mg_obj, align 8
  %tobool149 = icmp ne %struct.sv* %117, null
  br i1 %tobool149, label %cond.true.150, label %cond.false.152

cond.true.150:                                    ; preds = %if.end.147
  %118 = load %struct.magic*, %struct.magic** %mg, align 8
  %mg_obj151 = getelementptr inbounds %struct.magic, %struct.magic* %118, i32 0, i32 5
  %119 = load %struct.sv*, %struct.sv** %mg_obj151, align 8
  br label %cond.end.155

cond.false.152:                                   ; preds = %if.end.147
  %120 = load %struct.av*, %struct.av** %ary, align 8
  %121 = bitcast %struct.av* %120 to %struct.sv*
  %call153 = call %struct.sv* @Perl_newRV(%struct.sv* %121)
  %call154 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %call153)
  br label %cond.end.155

cond.end.155:                                     ; preds = %cond.false.152, %cond.true.150
  %cond156 = phi %struct.sv* [ %119, %cond.true.150 ], [ %call154, %cond.false.152 ]
  %122 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr157 = getelementptr inbounds %struct.sv*, %struct.sv** %122, i32 1
  store %struct.sv** %incdec.ptr157, %struct.sv*** %sp, align 8
  store %struct.sv* %cond156, %struct.sv** %incdec.ptr157, align 8
  store %struct.sv* %cond156, %struct.sv** %tmp148
  %123 = load %struct.sv*, %struct.sv** %tmp148
  br label %if.end.209

if.else.158:                                      ; preds = %cond.end.126
  %124 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any159 = getelementptr inbounds %struct.av, %struct.av* %124, i32 0, i32 0
  %125 = load %struct.xpvav*, %struct.xpvav** %sv_any159, align 8
  %xav_flags = getelementptr inbounds %struct.xpvav, %struct.xpvav* %125, i32 0, i32 9
  %126 = load i8, i8* %xav_flags, align 1
  %conv160 = zext i8 %126 to i32
  %and161 = and i32 %conv160, 1
  %tobool162 = icmp ne i32 %and161, 0
  br i1 %tobool162, label %if.end.179, label %if.then.163

if.then.163:                                      ; preds = %if.else.158
  %127 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any164 = getelementptr inbounds %struct.av, %struct.av* %127, i32 0, i32 0
  %128 = load %struct.xpvav*, %struct.xpvav** %sv_any164, align 8
  %xav_flags165 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %128, i32 0, i32 9
  %129 = load i8, i8* %xav_flags165, align 1
  %conv166 = zext i8 %129 to i32
  %or167 = or i32 %conv166, 1
  %conv168 = trunc i32 %or167 to i8
  store i8 %conv168, i8* %xav_flags165, align 1
  %130 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any169 = getelementptr inbounds %struct.av, %struct.av* %130, i32 0, i32 0
  %131 = load %struct.xpvav*, %struct.xpvav** %sv_any169, align 8
  %xav_flags170 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %131, i32 0, i32 9
  %132 = load i8, i8* %xav_flags170, align 1
  %conv171 = zext i8 %132 to i32
  %and172 = and i32 %conv171, -3
  %conv173 = trunc i32 %and172 to i8
  store i8 %conv173, i8* %xav_flags170, align 1
  %133 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any174 = getelementptr inbounds %struct.av, %struct.av* %133, i32 0, i32 0
  %134 = load %struct.xpvav*, %struct.xpvav** %sv_any174, align 8
  %xav_fill = getelementptr inbounds %struct.xpvav, %struct.xpvav* %134, i32 0, i32 1
  %135 = load i64, i64* %xav_fill, align 8
  %conv175 = trunc i64 %135 to i32
  store i32 %conv175, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then.163
  %136 = load i32, i32* %i, align 4
  %cmp176 = icmp sge i32 %136, 0
  br i1 %cmp176, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %137 = load i32, i32* %i, align 4
  %idxprom = sext i32 %137 to i64
  %138 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any178 = getelementptr inbounds %struct.av, %struct.av* %138, i32 0, i32 0
  %139 = load %struct.xpvav*, %struct.xpvav** %sv_any178, align 8
  %xav_array = getelementptr inbounds %struct.xpvav, %struct.xpvav* %139, i32 0, i32 0
  %140 = load i8*, i8** %xav_array, align 8
  %141 = bitcast i8* %140 to %struct.sv**
  %arrayidx = getelementptr inbounds %struct.sv*, %struct.sv** %141, i64 %idxprom
  store %struct.sv* @PL_sv_undef, %struct.sv** %arrayidx, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %142 = load i32, i32* %i, align 4
  %dec = add nsw i32 %142, -1
  store i32 %dec, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end.179

if.end.179:                                       ; preds = %for.end, %if.else.158
  %143 = load i32, i32* @PL_savestack_ix, align 4
  %add180 = add nsw i32 %143, 3
  %144 = load i32, i32* @PL_savestack_max, align 4
  %cmp181 = icmp sgt i32 %add180, %144
  br i1 %cmp181, label %if.then.183, label %if.end.184

if.then.183:                                      ; preds = %if.end.179
  call void @Perl_savestack_grow()
  br label %if.end.184

if.end.184:                                       ; preds = %if.then.183, %if.end.179
  %145 = load %struct.av*, %struct.av** @PL_curstack, align 8
  %146 = bitcast %struct.av* %145 to %struct.sv*
  %147 = bitcast %struct.sv* %146 to i8*
  %148 = load i32, i32* @PL_savestack_ix, align 4
  %inc = add nsw i32 %148, 1
  store i32 %inc, i32* @PL_savestack_ix, align 4
  %idxprom185 = sext i32 %148 to i64
  %149 = load %union.any*, %union.any** @PL_savestack, align 8
  %arrayidx186 = getelementptr inbounds %union.any, %union.any* %149, i64 %idxprom185
  %any_ptr = bitcast %union.any* %arrayidx186 to i8**
  store i8* %147, i8** %any_ptr, align 8
  %150 = load %struct.av*, %struct.av** %ary, align 8
  %151 = bitcast %struct.av* %150 to %struct.sv*
  %152 = bitcast %struct.sv* %151 to i8*
  %153 = load i32, i32* @PL_savestack_ix, align 4
  %inc187 = add nsw i32 %153, 1
  store i32 %inc187, i32* @PL_savestack_ix, align 4
  %idxprom188 = sext i32 %153 to i64
  %154 = load %union.any*, %union.any** @PL_savestack, align 8
  %arrayidx189 = getelementptr inbounds %union.any, %union.any* %154, i64 %idxprom188
  %any_ptr190 = bitcast %union.any* %arrayidx189 to i8**
  store i8* %152, i8** %any_ptr190, align 8
  %155 = load i32, i32* @PL_savestack_ix, align 4
  %inc191 = add nsw i32 %155, 1
  store i32 %inc191, i32* @PL_savestack_ix, align 4
  %idxprom192 = sext i32 %155 to i64
  %156 = load %union.any*, %union.any** @PL_savestack, align 8
  %arrayidx193 = getelementptr inbounds %union.any, %union.any* %156, i64 %idxprom192
  %any_i32 = bitcast %union.any* %arrayidx193 to i32*
  store i32 40, i32* %any_i32, align 4
  %157 = load %struct.sv**, %struct.sv*** %sp, align 8
  %158 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %sub.ptr.lhs.cast194 = ptrtoint %struct.sv** %157 to i64
  %sub.ptr.rhs.cast195 = ptrtoint %struct.sv** %158 to i64
  %sub.ptr.sub196 = sub i64 %sub.ptr.lhs.cast194, %sub.ptr.rhs.cast195
  %sub.ptr.div197 = sdiv exact i64 %sub.ptr.sub196, 8
  %159 = load %struct.av*, %struct.av** @PL_curstack, align 8
  %sv_any198 = getelementptr inbounds %struct.av, %struct.av* %159, i32 0, i32 0
  %160 = load %struct.xpvav*, %struct.xpvav** %sv_any198, align 8
  %xav_fill199 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %160, i32 0, i32 1
  store i64 %sub.ptr.div197, i64* %xav_fill199, align 8
  %161 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any200 = getelementptr inbounds %struct.av, %struct.av* %161, i32 0, i32 0
  %162 = load %struct.xpvav*, %struct.xpvav** %sv_any200, align 8
  %xav_array201 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %162, i32 0, i32 0
  %163 = load i8*, i8** %xav_array201, align 8
  %164 = bitcast i8* %163 to %struct.sv**
  store %struct.sv** %164, %struct.sv*** @PL_stack_base, align 8
  %165 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %166 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any202 = getelementptr inbounds %struct.av, %struct.av* %166, i32 0, i32 0
  %167 = load %struct.xpvav*, %struct.xpvav** %sv_any202, align 8
  %xav_max = getelementptr inbounds %struct.xpvav, %struct.xpvav* %167, i32 0, i32 2
  %168 = load i64, i64* %xav_max, align 8
  %add.ptr203 = getelementptr inbounds %struct.sv*, %struct.sv** %165, i64 %168
  store %struct.sv** %add.ptr203, %struct.sv*** @PL_stack_max, align 8
  %169 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %170 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any204 = getelementptr inbounds %struct.av, %struct.av* %170, i32 0, i32 0
  %171 = load %struct.xpvav*, %struct.xpvav** %sv_any204, align 8
  %xav_fill205 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %171, i32 0, i32 1
  %172 = load i64, i64* %xav_fill205, align 8
  %add.ptr206 = getelementptr inbounds %struct.sv*, %struct.sv** %169, i64 %172
  store %struct.sv** %add.ptr206, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %add.ptr206, %struct.sv*** %sp, align 8
  %173 = load %struct.av*, %struct.av** %ary, align 8
  store %struct.av* %173, %struct.av** @PL_curstack, align 8
  store %struct.av* %173, %struct.av** %tmp207
  %174 = load %struct.av*, %struct.av** %tmp207
  %175 = load %struct.av*, %struct.av** %ary, align 8
  %176 = load %struct.stackinfo*, %struct.stackinfo** @PL_curstackinfo, align 8
  %si_stack = getelementptr inbounds %struct.stackinfo, %struct.stackinfo* %176, i32 0, i32 0
  store %struct.av* %175, %struct.av** %si_stack, align 8
  store %struct.av* %175, %struct.av** %tmp208
  %177 = load %struct.av*, %struct.av** %tmp208
  store i32 0, i32* %make_mortal, align 4
  br label %if.end.209

if.end.209:                                       ; preds = %if.end.184, %cond.end.155
  br label %if.end.210

if.end.210:                                       ; preds = %if.end.209, %lor.lhs.false.115, %if.end.110
  %178 = load %struct.sv**, %struct.sv*** %sp, align 8
  %179 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %sub.ptr.lhs.cast211 = ptrtoint %struct.sv** %178 to i64
  %sub.ptr.rhs.cast212 = ptrtoint %struct.sv** %179 to i64
  %sub.ptr.sub213 = sub i64 %sub.ptr.lhs.cast211, %sub.ptr.rhs.cast212
  %sub.ptr.div214 = sdiv exact i64 %sub.ptr.sub213, 8
  %conv215 = trunc i64 %sub.ptr.div214 to i32
  store i32 %conv215, i32* %base, align 4
  %180 = load i8*, i8** %s, align 8
  store i8* %180, i8** %orig, align 8
  %181 = load %struct.pmop*, %struct.pmop** %pm, align 8
  %op_pmflags216 = getelementptr inbounds %struct.pmop, %struct.pmop* %181, i32 0, i32 14
  %182 = load i32, i32* %op_pmflags216, align 4
  %and217 = and i32 %182, 16
  %tobool218 = icmp ne i32 %and217, 0
  br i1 %tobool218, label %if.then.219, label %if.end.263

if.then.219:                                      ; preds = %if.end.210
  %183 = load %struct.pmop*, %struct.pmop** %pm, align 8
  %op_pmflags220 = getelementptr inbounds %struct.pmop, %struct.pmop* %183, i32 0, i32 14
  %184 = load i32, i32* %op_pmflags220, align 4
  %and221 = and i32 %184, 2048
  %tobool222 = icmp ne i32 %and221, 0
  br i1 %tobool222, label %if.then.223, label %if.else.239

if.then.223:                                      ; preds = %if.then.219
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then.223
  %185 = load i8*, i8** %s, align 8
  %186 = load i8, i8* %185, align 1
  %conv224 = sext i8 %186 to i32
  %and225 = and i32 %conv224, -128
  %cmp226 = icmp eq i32 %and225, 0
  br i1 %cmp226, label %land.rhs.228, label %land.end.236

land.rhs.228:                                     ; preds = %while.cond
  %187 = load i8*, i8** %s, align 8
  %188 = load i8, i8* %187, align 1
  %conv229 = sext i8 %188 to i32
  %idxprom230 = sext i32 %conv229 to i64
  %call231 = call i16** @__ctype_b_loc()
  %189 = load i16*, i16** %call231, align 8
  %arrayidx232 = getelementptr inbounds i16, i16* %189, i64 %idxprom230
  %190 = load i16, i16* %arrayidx232, align 2
  %conv233 = zext i16 %190 to i32
  %and234 = and i32 %conv233, 8192
  %tobool235 = icmp ne i32 %and234, 0
  br label %land.end.236

land.end.236:                                     ; preds = %land.rhs.228, %while.cond
  %191 = phi i1 [ false, %while.cond ], [ %tobool235, %land.rhs.228 ]
  br i1 %191, label %while.body, label %while.end

while.body:                                       ; preds = %land.end.236
  %192 = load i8*, i8** %s, align 8
  %incdec.ptr238 = getelementptr inbounds i8, i8* %192, i32 1
  store i8* %incdec.ptr238, i8** %s, align 8
  br label %while.cond

while.end:                                        ; preds = %land.end.236
  br label %if.end.262

if.else.239:                                      ; preds = %if.then.219
  br label %while.cond.240

while.cond.240:                                   ; preds = %while.body.259, %if.else.239
  %193 = load i8*, i8** %s, align 8
  %194 = load i8, i8* %193, align 1
  %conv241 = sext i8 %194 to i32
  %cmp242 = icmp eq i32 %conv241, 32
  br i1 %cmp242, label %lor.end, label %lor.lhs.false.244

lor.lhs.false.244:                                ; preds = %while.cond.240
  %195 = load i8*, i8** %s, align 8
  %196 = load i8, i8* %195, align 1
  %conv245 = sext i8 %196 to i32
  %cmp246 = icmp eq i32 %conv245, 9
  br i1 %cmp246, label %lor.end, label %lor.lhs.false.248

lor.lhs.false.248:                                ; preds = %lor.lhs.false.244
  %197 = load i8*, i8** %s, align 8
  %198 = load i8, i8* %197, align 1
  %conv249 = sext i8 %198 to i32
  %cmp250 = icmp eq i32 %conv249, 10
  br i1 %cmp250, label %lor.end, label %lor.lhs.false.252

lor.lhs.false.252:                                ; preds = %lor.lhs.false.248
  %199 = load i8*, i8** %s, align 8
  %200 = load i8, i8* %199, align 1
  %conv253 = sext i8 %200 to i32
  %cmp254 = icmp eq i32 %conv253, 13
  br i1 %cmp254, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false.252
  %201 = load i8*, i8** %s, align 8
  %202 = load i8, i8* %201, align 1
  %conv256 = sext i8 %202 to i32
  %cmp257 = icmp eq i32 %conv256, 12
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false.252, %lor.lhs.false.248, %lor.lhs.false.244, %while.cond.240
  %203 = phi i1 [ true, %lor.lhs.false.252 ], [ true, %lor.lhs.false.248 ], [ true, %lor.lhs.false.244 ], [ true, %while.cond.240 ], [ %cmp257, %lor.rhs ]
  br i1 %203, label %while.body.259, label %while.end.261

while.body.259:                                   ; preds = %lor.end
  %204 = load i8*, i8** %s, align 8
  %incdec.ptr260 = getelementptr inbounds i8, i8* %204, i32 1
  store i8* %incdec.ptr260, i8** %s, align 8
  br label %while.cond.240

while.end.261:                                    ; preds = %lor.end
  br label %if.end.262

if.end.262:                                       ; preds = %while.end.261, %while.end
  br label %if.end.263

if.end.263:                                       ; preds = %if.end.262, %if.end.210
  %205 = load %struct.pmop*, %struct.pmop** %pm, align 8
  %op_pmflags264 = getelementptr inbounds %struct.pmop, %struct.pmop* %205, i32 0, i32 14
  %206 = load i32, i32* %op_pmflags264, align 4
  %and265 = and i32 %206, 12288
  %tobool266 = icmp ne i32 %and265, 0
  br i1 %tobool266, label %if.then.267, label %if.end.270

if.then.267:                                      ; preds = %if.end.263
  call void @Perl_save_int(i32* @PL_multiline)
  %207 = load %struct.pmop*, %struct.pmop** %pm, align 8
  %op_pmflags268 = getelementptr inbounds %struct.pmop, %struct.pmop* %207, i32 0, i32 14
  %208 = load i32, i32* %op_pmflags268, align 4
  %and269 = and i32 %208, 4096
  store i32 %and269, i32* @PL_multiline, align 4
  br label %if.end.270

if.end.270:                                       ; preds = %if.then.267, %if.end.263
  %209 = load i64, i64* %limit, align 8
  %tobool271 = icmp ne i64 %209, 0
  br i1 %tobool271, label %if.end.275, label %if.then.272

if.then.272:                                      ; preds = %if.end.270
  %210 = load i32, i32* %maxiters, align 4
  %add273 = add nsw i32 %210, 2
  %conv274 = sext i32 %add273 to i64
  store i64 %conv274, i64* %limit, align 8
  br label %if.end.275

if.end.275:                                       ; preds = %if.then.272, %if.end.270
  %211 = load %struct.pmop*, %struct.pmop** %pm, align 8
  %op_pmflags276 = getelementptr inbounds %struct.pmop, %struct.pmop* %211, i32 0, i32 14
  %212 = load i32, i32* %op_pmflags276, align 4
  %and277 = and i32 %212, 32
  %tobool278 = icmp ne i32 %and277, 0
  br i1 %tobool278, label %if.then.279, label %if.else.418

if.then.279:                                      ; preds = %if.end.275
  br label %while.cond.280

while.cond.280:                                   ; preds = %while.end.416, %if.then.279
  %213 = load i64, i64* %limit, align 8
  %dec281 = add nsw i64 %213, -1
  store i64 %dec281, i64* %limit, align 8
  %tobool282 = icmp ne i64 %dec281, 0
  br i1 %tobool282, label %while.body.283, label %while.end.417

while.body.283:                                   ; preds = %while.cond.280
  %214 = load i8*, i8** %s, align 8
  store i8* %214, i8** %m, align 8
  br label %while.cond.284

while.cond.284:                                   ; preds = %while.body.333, %while.body.283
  %215 = load i8*, i8** %m, align 8
  %216 = load i8*, i8** %strend, align 8
  %cmp285 = icmp ult i8* %215, %216
  br i1 %cmp285, label %land.rhs.287, label %land.end.331

land.rhs.287:                                     ; preds = %while.cond.284
  %217 = load %struct.pmop*, %struct.pmop** %pm, align 8
  %op_pmflags288 = getelementptr inbounds %struct.pmop, %struct.pmop* %217, i32 0, i32 14
  %218 = load i32, i32* %op_pmflags288, align 4
  %and289 = and i32 %218, 2048
  %tobool290 = icmp ne i32 %and289, 0
  br i1 %tobool290, label %cond.true.291, label %cond.false.306

cond.true.291:                                    ; preds = %land.rhs.287
  %219 = load i8*, i8** %m, align 8
  %220 = load i8, i8* %219, align 1
  %conv292 = sext i8 %220 to i32
  %and293 = and i32 %conv292, -128
  %cmp294 = icmp eq i32 %and293, 0
  br i1 %cmp294, label %land.rhs.296, label %land.end.304

land.rhs.296:                                     ; preds = %cond.true.291
  %221 = load i8*, i8** %m, align 8
  %222 = load i8, i8* %221, align 1
  %conv297 = sext i8 %222 to i32
  %idxprom298 = sext i32 %conv297 to i64
  %call299 = call i16** @__ctype_b_loc()
  %223 = load i16*, i16** %call299, align 8
  %arrayidx300 = getelementptr inbounds i16, i16* %223, i64 %idxprom298
  %224 = load i16, i16* %arrayidx300, align 2
  %conv301 = zext i16 %224 to i32
  %and302 = and i32 %conv301, 8192
  %tobool303 = icmp ne i32 %and302, 0
  br label %land.end.304

land.end.304:                                     ; preds = %land.rhs.296, %cond.true.291
  %225 = phi i1 [ false, %cond.true.291 ], [ %tobool303, %land.rhs.296 ]
  %land.ext305 = zext i1 %225 to i32
  br label %cond.end.327

cond.false.306:                                   ; preds = %land.rhs.287
  %226 = load i8*, i8** %m, align 8
  %227 = load i8, i8* %226, align 1
  %conv307 = sext i8 %227 to i32
  %cmp308 = icmp eq i32 %conv307, 32
  br i1 %cmp308, label %lor.end.326, label %lor.lhs.false.310

lor.lhs.false.310:                                ; preds = %cond.false.306
  %228 = load i8*, i8** %m, align 8
  %229 = load i8, i8* %228, align 1
  %conv311 = sext i8 %229 to i32
  %cmp312 = icmp eq i32 %conv311, 9
  br i1 %cmp312, label %lor.end.326, label %lor.lhs.false.314

lor.lhs.false.314:                                ; preds = %lor.lhs.false.310
  %230 = load i8*, i8** %m, align 8
  %231 = load i8, i8* %230, align 1
  %conv315 = sext i8 %231 to i32
  %cmp316 = icmp eq i32 %conv315, 10
  br i1 %cmp316, label %lor.end.326, label %lor.lhs.false.318

lor.lhs.false.318:                                ; preds = %lor.lhs.false.314
  %232 = load i8*, i8** %m, align 8
  %233 = load i8, i8* %232, align 1
  %conv319 = sext i8 %233 to i32
  %cmp320 = icmp eq i32 %conv319, 13
  br i1 %cmp320, label %lor.end.326, label %lor.rhs.322

lor.rhs.322:                                      ; preds = %lor.lhs.false.318
  %234 = load i8*, i8** %m, align 8
  %235 = load i8, i8* %234, align 1
  %conv323 = sext i8 %235 to i32
  %cmp324 = icmp eq i32 %conv323, 12
  br label %lor.end.326

lor.end.326:                                      ; preds = %lor.rhs.322, %lor.lhs.false.318, %lor.lhs.false.314, %lor.lhs.false.310, %cond.false.306
  %236 = phi i1 [ true, %lor.lhs.false.318 ], [ true, %lor.lhs.false.314 ], [ true, %lor.lhs.false.310 ], [ true, %cond.false.306 ], [ %cmp324, %lor.rhs.322 ]
  %lor.ext = zext i1 %236 to i32
  br label %cond.end.327

cond.end.327:                                     ; preds = %lor.end.326, %land.end.304
  %cond328 = phi i32 [ %land.ext305, %land.end.304 ], [ %lor.ext, %lor.end.326 ]
  %tobool329 = icmp ne i32 %cond328, 0
  %lnot330 = xor i1 %tobool329, true
  br label %land.end.331

land.end.331:                                     ; preds = %cond.end.327, %while.cond.284
  %237 = phi i1 [ false, %while.cond.284 ], [ %lnot330, %cond.end.327 ]
  br i1 %237, label %while.body.333, label %while.end.335

while.body.333:                                   ; preds = %land.end.331
  %238 = load i8*, i8** %m, align 8
  %incdec.ptr334 = getelementptr inbounds i8, i8* %238, i32 1
  store i8* %incdec.ptr334, i8** %m, align 8
  br label %while.cond.284

while.end.335:                                    ; preds = %land.end.331
  %239 = load i8*, i8** %m, align 8
  %240 = load i8*, i8** %strend, align 8
  %cmp336 = icmp uge i8* %239, %240
  br i1 %cmp336, label %if.then.338, label %if.end.339

if.then.338:                                      ; preds = %while.end.335
  br label %while.end.417

if.end.339:                                       ; preds = %while.end.335
  %241 = load i8*, i8** %s, align 8
  %242 = load i8*, i8** %m, align 8
  %243 = load i8*, i8** %s, align 8
  %sub.ptr.lhs.cast340 = ptrtoint i8* %242 to i64
  %sub.ptr.rhs.cast341 = ptrtoint i8* %243 to i64
  %sub.ptr.sub342 = sub i64 %sub.ptr.lhs.cast340, %sub.ptr.rhs.cast341
  %call343 = call %struct.sv* @Perl_newSVpvn(i8* %241, i64 %sub.ptr.sub342)
  store %struct.sv* %call343, %struct.sv** %dstr, align 8
  %244 = load i32, i32* %make_mortal, align 4
  %tobool344 = icmp ne i32 %244, 0
  br i1 %tobool344, label %if.then.345, label %if.end.347

if.then.345:                                      ; preds = %if.end.339
  %245 = load %struct.sv*, %struct.sv** %dstr, align 8
  %call346 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %245)
  br label %if.end.347

if.end.347:                                       ; preds = %if.then.345, %if.end.339
  %246 = load i8, i8* %do_utf8, align 1
  %tobool348 = icmp ne i8 %246, 0
  br i1 %tobool348, label %if.then.349, label %if.end.352

if.then.349:                                      ; preds = %if.end.347
  %247 = load %struct.sv*, %struct.sv** %dstr, align 8
  %sv_flags350 = getelementptr inbounds %struct.sv, %struct.sv* %247, i32 0, i32 2
  %248 = load i32, i32* %sv_flags350, align 4
  %or351 = or i32 %248, 536870912
  store i32 %or351, i32* %sv_flags350, align 4
  br label %if.end.352

if.end.352:                                       ; preds = %if.then.349, %if.end.347
  %249 = load %struct.sv**, %struct.sv*** @PL_stack_max, align 8
  %250 = load %struct.sv**, %struct.sv*** %sp, align 8
  %sub.ptr.lhs.cast353 = ptrtoint %struct.sv** %249 to i64
  %sub.ptr.rhs.cast354 = ptrtoint %struct.sv** %250 to i64
  %sub.ptr.sub355 = sub i64 %sub.ptr.lhs.cast353, %sub.ptr.rhs.cast354
  %sub.ptr.div356 = sdiv exact i64 %sub.ptr.sub355, 8
  %cmp357 = icmp slt i64 %sub.ptr.div356, 1
  br i1 %cmp357, label %if.then.359, label %if.end.361

if.then.359:                                      ; preds = %if.end.352
  %251 = load %struct.sv**, %struct.sv*** %sp, align 8
  %252 = load %struct.sv**, %struct.sv*** %sp, align 8
  %call360 = call %struct.sv** @Perl_stack_grow(%struct.sv** %251, %struct.sv** %252, i32 1)
  store %struct.sv** %call360, %struct.sv*** %sp, align 8
  br label %if.end.361

if.end.361:                                       ; preds = %if.then.359, %if.end.352
  %253 = load %struct.sv*, %struct.sv** %dstr, align 8
  %254 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr363 = getelementptr inbounds %struct.sv*, %struct.sv** %254, i32 1
  store %struct.sv** %incdec.ptr363, %struct.sv*** %sp, align 8
  store %struct.sv* %253, %struct.sv** %incdec.ptr363, align 8
  store %struct.sv* %253, %struct.sv** %tmp362
  %255 = load %struct.sv*, %struct.sv** %tmp362
  %256 = load i8*, i8** %m, align 8
  %add.ptr364 = getelementptr inbounds i8, i8* %256, i64 1
  store i8* %add.ptr364, i8** %s, align 8
  br label %while.cond.365

while.cond.365:                                   ; preds = %while.body.414, %if.end.361
  %257 = load i8*, i8** %s, align 8
  %258 = load i8*, i8** %strend, align 8
  %cmp366 = icmp ult i8* %257, %258
  br i1 %cmp366, label %land.rhs.368, label %land.end.412

land.rhs.368:                                     ; preds = %while.cond.365
  %259 = load %struct.pmop*, %struct.pmop** %pm, align 8
  %op_pmflags369 = getelementptr inbounds %struct.pmop, %struct.pmop* %259, i32 0, i32 14
  %260 = load i32, i32* %op_pmflags369, align 4
  %and370 = and i32 %260, 2048
  %tobool371 = icmp ne i32 %and370, 0
  br i1 %tobool371, label %cond.true.372, label %cond.false.387

cond.true.372:                                    ; preds = %land.rhs.368
  %261 = load i8*, i8** %s, align 8
  %262 = load i8, i8* %261, align 1
  %conv373 = sext i8 %262 to i32
  %and374 = and i32 %conv373, -128
  %cmp375 = icmp eq i32 %and374, 0
  br i1 %cmp375, label %land.rhs.377, label %land.end.385

land.rhs.377:                                     ; preds = %cond.true.372
  %263 = load i8*, i8** %s, align 8
  %264 = load i8, i8* %263, align 1
  %conv378 = sext i8 %264 to i32
  %idxprom379 = sext i32 %conv378 to i64
  %call380 = call i16** @__ctype_b_loc()
  %265 = load i16*, i16** %call380, align 8
  %arrayidx381 = getelementptr inbounds i16, i16* %265, i64 %idxprom379
  %266 = load i16, i16* %arrayidx381, align 2
  %conv382 = zext i16 %266 to i32
  %and383 = and i32 %conv382, 8192
  %tobool384 = icmp ne i32 %and383, 0
  br label %land.end.385

land.end.385:                                     ; preds = %land.rhs.377, %cond.true.372
  %267 = phi i1 [ false, %cond.true.372 ], [ %tobool384, %land.rhs.377 ]
  %land.ext386 = zext i1 %267 to i32
  br label %cond.end.409

cond.false.387:                                   ; preds = %land.rhs.368
  %268 = load i8*, i8** %s, align 8
  %269 = load i8, i8* %268, align 1
  %conv388 = sext i8 %269 to i32
  %cmp389 = icmp eq i32 %conv388, 32
  br i1 %cmp389, label %lor.end.407, label %lor.lhs.false.391

lor.lhs.false.391:                                ; preds = %cond.false.387
  %270 = load i8*, i8** %s, align 8
  %271 = load i8, i8* %270, align 1
  %conv392 = sext i8 %271 to i32
  %cmp393 = icmp eq i32 %conv392, 9
  br i1 %cmp393, label %lor.end.407, label %lor.lhs.false.395

lor.lhs.false.395:                                ; preds = %lor.lhs.false.391
  %272 = load i8*, i8** %s, align 8
  %273 = load i8, i8* %272, align 1
  %conv396 = sext i8 %273 to i32
  %cmp397 = icmp eq i32 %conv396, 10
  br i1 %cmp397, label %lor.end.407, label %lor.lhs.false.399

lor.lhs.false.399:                                ; preds = %lor.lhs.false.395
  %274 = load i8*, i8** %s, align 8
  %275 = load i8, i8* %274, align 1
  %conv400 = sext i8 %275 to i32
  %cmp401 = icmp eq i32 %conv400, 13
  br i1 %cmp401, label %lor.end.407, label %lor.rhs.403

lor.rhs.403:                                      ; preds = %lor.lhs.false.399
  %276 = load i8*, i8** %s, align 8
  %277 = load i8, i8* %276, align 1
  %conv404 = sext i8 %277 to i32
  %cmp405 = icmp eq i32 %conv404, 12
  br label %lor.end.407

lor.end.407:                                      ; preds = %lor.rhs.403, %lor.lhs.false.399, %lor.lhs.false.395, %lor.lhs.false.391, %cond.false.387
  %278 = phi i1 [ true, %lor.lhs.false.399 ], [ true, %lor.lhs.false.395 ], [ true, %lor.lhs.false.391 ], [ true, %cond.false.387 ], [ %cmp405, %lor.rhs.403 ]
  %lor.ext408 = zext i1 %278 to i32
  br label %cond.end.409

cond.end.409:                                     ; preds = %lor.end.407, %land.end.385
  %cond410 = phi i32 [ %land.ext386, %land.end.385 ], [ %lor.ext408, %lor.end.407 ]
  %tobool411 = icmp ne i32 %cond410, 0
  br label %land.end.412

land.end.412:                                     ; preds = %cond.end.409, %while.cond.365
  %279 = phi i1 [ false, %while.cond.365 ], [ %tobool411, %cond.end.409 ]
  br i1 %279, label %while.body.414, label %while.end.416

while.body.414:                                   ; preds = %land.end.412
  %280 = load i8*, i8** %s, align 8
  %incdec.ptr415 = getelementptr inbounds i8, i8* %280, i32 1
  store i8* %incdec.ptr415, i8** %s, align 8
  br label %while.cond.365

while.end.416:                                    ; preds = %land.end.412
  br label %while.cond.280

while.end.417:                                    ; preds = %if.then.338, %while.cond.280
  br label %if.end.760

if.else.418:                                      ; preds = %if.end.275
  %281 = load %struct.regexp*, %struct.regexp** %rx, align 8
  %precomp = getelementptr inbounds %struct.regexp, %struct.regexp* %281, i32 0, i32 4
  %282 = load i8*, i8** %precomp, align 8
  %arrayidx419 = getelementptr inbounds i8, i8* %282, i64 0
  %283 = load i8, i8* %arrayidx419, align 1
  %conv420 = sext i8 %283 to i32
  %cmp421 = icmp eq i32 %conv420, 94
  br i1 %cmp421, label %land.lhs.true.423, label %if.else.477

land.lhs.true.423:                                ; preds = %if.else.418
  %284 = load %struct.regexp*, %struct.regexp** %rx, align 8
  %precomp424 = getelementptr inbounds %struct.regexp, %struct.regexp* %284, i32 0, i32 4
  %285 = load i8*, i8** %precomp424, align 8
  %arrayidx425 = getelementptr inbounds i8, i8* %285, i64 1
  %286 = load i8, i8* %arrayidx425, align 1
  %conv426 = sext i8 %286 to i32
  %cmp427 = icmp eq i32 %conv426, 0
  br i1 %cmp427, label %if.then.429, label %if.else.477

if.then.429:                                      ; preds = %land.lhs.true.423
  br label %while.cond.430

while.cond.430:                                   ; preds = %if.end.473, %if.then.429
  %287 = load i64, i64* %limit, align 8
  %dec431 = add nsw i64 %287, -1
  store i64 %dec431, i64* %limit, align 8
  %tobool432 = icmp ne i64 %dec431, 0
  br i1 %tobool432, label %while.body.433, label %while.end.476

while.body.433:                                   ; preds = %while.cond.430
  %288 = load i8*, i8** %s, align 8
  store i8* %288, i8** %m, align 8
  br label %for.cond.434

for.cond.434:                                     ; preds = %for.inc.444, %while.body.433
  %289 = load i8*, i8** %m, align 8
  %290 = load i8*, i8** %strend, align 8
  %cmp435 = icmp ult i8* %289, %290
  br i1 %cmp435, label %land.rhs.437, label %land.end.441

land.rhs.437:                                     ; preds = %for.cond.434
  %291 = load i8*, i8** %m, align 8
  %292 = load i8, i8* %291, align 1
  %conv438 = sext i8 %292 to i32
  %cmp439 = icmp ne i32 %conv438, 10
  br label %land.end.441

land.end.441:                                     ; preds = %land.rhs.437, %for.cond.434
  %293 = phi i1 [ false, %for.cond.434 ], [ %cmp439, %land.rhs.437 ]
  br i1 %293, label %for.body.443, label %for.end.446

for.body.443:                                     ; preds = %land.end.441
  br label %for.inc.444

for.inc.444:                                      ; preds = %for.body.443
  %294 = load i8*, i8** %m, align 8
  %incdec.ptr445 = getelementptr inbounds i8, i8* %294, i32 1
  store i8* %incdec.ptr445, i8** %m, align 8
  br label %for.cond.434

for.end.446:                                      ; preds = %land.end.441
  %295 = load i8*, i8** %m, align 8
  %incdec.ptr447 = getelementptr inbounds i8, i8* %295, i32 1
  store i8* %incdec.ptr447, i8** %m, align 8
  %296 = load i8*, i8** %m, align 8
  %297 = load i8*, i8** %strend, align 8
  %cmp448 = icmp uge i8* %296, %297
  br i1 %cmp448, label %if.then.450, label %if.end.451

if.then.450:                                      ; preds = %for.end.446
  br label %while.end.476

if.end.451:                                       ; preds = %for.end.446
  %298 = load i8*, i8** %s, align 8
  %299 = load i8*, i8** %m, align 8
  %300 = load i8*, i8** %s, align 8
  %sub.ptr.lhs.cast452 = ptrtoint i8* %299 to i64
  %sub.ptr.rhs.cast453 = ptrtoint i8* %300 to i64
  %sub.ptr.sub454 = sub i64 %sub.ptr.lhs.cast452, %sub.ptr.rhs.cast453
  %call455 = call %struct.sv* @Perl_newSVpvn(i8* %298, i64 %sub.ptr.sub454)
  store %struct.sv* %call455, %struct.sv** %dstr, align 8
  %301 = load i32, i32* %make_mortal, align 4
  %tobool456 = icmp ne i32 %301, 0
  br i1 %tobool456, label %if.then.457, label %if.end.459

if.then.457:                                      ; preds = %if.end.451
  %302 = load %struct.sv*, %struct.sv** %dstr, align 8
  %call458 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %302)
  br label %if.end.459

if.end.459:                                       ; preds = %if.then.457, %if.end.451
  %303 = load i8, i8* %do_utf8, align 1
  %tobool460 = icmp ne i8 %303, 0
  br i1 %tobool460, label %if.then.461, label %if.end.464

if.then.461:                                      ; preds = %if.end.459
  %304 = load %struct.sv*, %struct.sv** %dstr, align 8
  %sv_flags462 = getelementptr inbounds %struct.sv, %struct.sv* %304, i32 0, i32 2
  %305 = load i32, i32* %sv_flags462, align 4
  %or463 = or i32 %305, 536870912
  store i32 %or463, i32* %sv_flags462, align 4
  br label %if.end.464

if.end.464:                                       ; preds = %if.then.461, %if.end.459
  %306 = load %struct.sv**, %struct.sv*** @PL_stack_max, align 8
  %307 = load %struct.sv**, %struct.sv*** %sp, align 8
  %sub.ptr.lhs.cast465 = ptrtoint %struct.sv** %306 to i64
  %sub.ptr.rhs.cast466 = ptrtoint %struct.sv** %307 to i64
  %sub.ptr.sub467 = sub i64 %sub.ptr.lhs.cast465, %sub.ptr.rhs.cast466
  %sub.ptr.div468 = sdiv exact i64 %sub.ptr.sub467, 8
  %cmp469 = icmp slt i64 %sub.ptr.div468, 1
  br i1 %cmp469, label %if.then.471, label %if.end.473

if.then.471:                                      ; preds = %if.end.464
  %308 = load %struct.sv**, %struct.sv*** %sp, align 8
  %309 = load %struct.sv**, %struct.sv*** %sp, align 8
  %call472 = call %struct.sv** @Perl_stack_grow(%struct.sv** %308, %struct.sv** %309, i32 1)
  store %struct.sv** %call472, %struct.sv*** %sp, align 8
  br label %if.end.473

if.end.473:                                       ; preds = %if.then.471, %if.end.464
  %310 = load %struct.sv*, %struct.sv** %dstr, align 8
  %311 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr475 = getelementptr inbounds %struct.sv*, %struct.sv** %311, i32 1
  store %struct.sv** %incdec.ptr475, %struct.sv*** %sp, align 8
  store %struct.sv* %310, %struct.sv** %incdec.ptr475, align 8
  store %struct.sv* %310, %struct.sv** %tmp474
  %312 = load %struct.sv*, %struct.sv** %tmp474
  %313 = load i8*, i8** %m, align 8
  store i8* %313, i8** %s, align 8
  br label %while.cond.430

while.end.476:                                    ; preds = %if.then.450, %while.cond.430
  br label %if.end.759

if.else.477:                                      ; preds = %land.lhs.true.423, %if.else.418
  %314 = load i8, i8* %do_utf8, align 1
  %conv478 = sext i8 %314 to i32
  %315 = load %struct.regexp*, %struct.regexp** %rx, align 8
  %reganch479 = getelementptr inbounds %struct.regexp, %struct.regexp* %315, i32 0, i32 15
  %316 = load i32, i32* %reganch479, align 4
  %and480 = and i32 %316, 65536
  %cmp481 = icmp ne i32 %and480, 0
  %conv482 = zext i1 %cmp481 to i32
  %cmp483 = icmp eq i32 %conv478, %conv482
  br i1 %cmp483, label %land.lhs.true.485, label %if.else.632

land.lhs.true.485:                                ; preds = %if.else.477
  %317 = load %struct.regexp*, %struct.regexp** %rx, align 8
  %reganch486 = getelementptr inbounds %struct.regexp, %struct.regexp* %317, i32 0, i32 15
  %318 = load i32, i32* %reganch486, align 4
  %and487 = and i32 %318, 3145728
  %tobool488 = icmp ne i32 %and487, 0
  br i1 %tobool488, label %land.lhs.true.489, label %if.else.632

land.lhs.true.489:                                ; preds = %land.lhs.true.485
  %319 = load %struct.regexp*, %struct.regexp** %rx, align 8
  %nparens = getelementptr inbounds %struct.regexp, %struct.regexp* %319, i32 0, i32 12
  %320 = load i32, i32* %nparens, align 4
  %tobool490 = icmp ne i32 %320, 0
  br i1 %tobool490, label %if.else.632, label %land.lhs.true.491

land.lhs.true.491:                                ; preds = %land.lhs.true.489
  %321 = load %struct.regexp*, %struct.regexp** %rx, align 8
  %reganch492 = getelementptr inbounds %struct.regexp, %struct.regexp* %321, i32 0, i32 15
  %322 = load i32, i32* %reganch492, align 4
  %and493 = and i32 %322, 256
  %tobool494 = icmp ne i32 %and493, 0
  br i1 %tobool494, label %land.lhs.true.495, label %if.else.632

land.lhs.true.495:                                ; preds = %land.lhs.true.491
  %323 = load %struct.regexp*, %struct.regexp** %rx, align 8
  %reganch496 = getelementptr inbounds %struct.regexp, %struct.regexp* %323, i32 0, i32 15
  %324 = load i32, i32* %reganch496, align 4
  %and497 = and i32 %324, 15
  %tobool498 = icmp ne i32 %and497, 0
  br i1 %tobool498, label %if.else.632, label %if.then.499

if.then.499:                                      ; preds = %land.lhs.true.495
  %325 = load %struct.regexp*, %struct.regexp** %rx, align 8
  %reganch501 = getelementptr inbounds %struct.regexp, %struct.regexp* %325, i32 0, i32 15
  %326 = load i32, i32* %reganch501, align 4
  %and502 = and i32 %326, 134217728
  store i32 %and502, i32* %tail, align 4
  %327 = load %struct.sv* (%struct.regexp*)*, %struct.sv* (%struct.regexp*)** @PL_regint_string, align 8
  %328 = load %struct.regexp*, %struct.regexp** %rx, align 8
  %call504 = call %struct.sv* %327(%struct.regexp* %328)
  store %struct.sv* %call504, %struct.sv** %csv, align 8
  %329 = load %struct.regexp*, %struct.regexp** %rx, align 8
  %minlen = getelementptr inbounds %struct.regexp, %struct.regexp* %329, i32 0, i32 10
  %330 = load i32, i32* %minlen, align 4
  %conv505 = sext i32 %330 to i64
  store i64 %conv505, i64* %len, align 8
  %331 = load i64, i64* %len, align 8
  %cmp506 = icmp eq i64 %331, 1
  br i1 %cmp506, label %land.lhs.true.508, label %if.else.584

land.lhs.true.508:                                ; preds = %if.then.499
  %332 = load %struct.regexp*, %struct.regexp** %rx, align 8
  %reganch509 = getelementptr inbounds %struct.regexp, %struct.regexp* %332, i32 0, i32 15
  %333 = load i32, i32* %reganch509, align 4
  %and510 = and i32 %333, 65536
  %tobool511 = icmp ne i32 %and510, 0
  br i1 %tobool511, label %if.else.584, label %land.lhs.true.512

land.lhs.true.512:                                ; preds = %land.lhs.true.508
  %334 = load i32, i32* %tail, align 4
  %tobool513 = icmp ne i32 %334, 0
  br i1 %tobool513, label %if.else.584, label %if.then.514

if.then.514:                                      ; preds = %land.lhs.true.512
  %335 = load %struct.sv*, %struct.sv** %csv, align 8
  %sv_flags517 = getelementptr inbounds %struct.sv, %struct.sv* %335, i32 0, i32 2
  %336 = load i32, i32* %sv_flags517, align 4
  %and518 = and i32 %336, 262144
  %cmp519 = icmp eq i32 %and518, 262144
  br i1 %cmp519, label %cond.true.521, label %cond.false.526

cond.true.521:                                    ; preds = %if.then.514
  %337 = load %struct.sv*, %struct.sv** %csv, align 8
  %sv_any522 = getelementptr inbounds %struct.sv, %struct.sv* %337, i32 0, i32 0
  %338 = load i8*, i8** %sv_any522, align 8
  %339 = bitcast i8* %338 to %struct.xpv*
  %xpv_cur523 = getelementptr inbounds %struct.xpv, %struct.xpv* %339, i32 0, i32 1
  %340 = load i64, i64* %xpv_cur523, align 8
  store i64 %340, i64* %n_a, align 8
  %341 = load %struct.sv*, %struct.sv** %csv, align 8
  %sv_any524 = getelementptr inbounds %struct.sv, %struct.sv* %341, i32 0, i32 0
  %342 = load i8*, i8** %sv_any524, align 8
  %343 = bitcast i8* %342 to %struct.xpv*
  %xpv_pv525 = getelementptr inbounds %struct.xpv, %struct.xpv* %343, i32 0, i32 0
  %344 = load i8*, i8** %xpv_pv525, align 8
  br label %cond.end.528

cond.false.526:                                   ; preds = %if.then.514
  %345 = load %struct.sv*, %struct.sv** %csv, align 8
  %call527 = call i8* @Perl_sv_2pv_flags(%struct.sv* %345, i64* %n_a, i32 2)
  br label %cond.end.528

cond.end.528:                                     ; preds = %cond.false.526, %cond.true.521
  %cond529 = phi i8* [ %344, %cond.true.521 ], [ %call527, %cond.false.526 ]
  %346 = load i8, i8* %cond529, align 1
  store i8 %346, i8* %c, align 1
  br label %while.cond.530

while.cond.530:                                   ; preds = %if.end.582, %cond.end.528
  %347 = load i64, i64* %limit, align 8
  %dec531 = add nsw i64 %347, -1
  store i64 %dec531, i64* %limit, align 8
  %tobool532 = icmp ne i64 %dec531, 0
  br i1 %tobool532, label %while.body.533, label %while.end.583

while.body.533:                                   ; preds = %while.cond.530
  %348 = load i8*, i8** %s, align 8
  store i8* %348, i8** %m, align 8
  br label %for.cond.534

for.cond.534:                                     ; preds = %for.inc.545, %while.body.533
  %349 = load i8*, i8** %m, align 8
  %350 = load i8*, i8** %strend, align 8
  %cmp535 = icmp ult i8* %349, %350
  br i1 %cmp535, label %land.rhs.537, label %land.end.542

land.rhs.537:                                     ; preds = %for.cond.534
  %351 = load i8*, i8** %m, align 8
  %352 = load i8, i8* %351, align 1
  %conv538 = sext i8 %352 to i32
  %353 = load i8, i8* %c, align 1
  %conv539 = sext i8 %353 to i32
  %cmp540 = icmp ne i32 %conv538, %conv539
  br label %land.end.542

land.end.542:                                     ; preds = %land.rhs.537, %for.cond.534
  %354 = phi i1 [ false, %for.cond.534 ], [ %cmp540, %land.rhs.537 ]
  br i1 %354, label %for.body.544, label %for.end.547

for.body.544:                                     ; preds = %land.end.542
  br label %for.inc.545

for.inc.545:                                      ; preds = %for.body.544
  %355 = load i8*, i8** %m, align 8
  %incdec.ptr546 = getelementptr inbounds i8, i8* %355, i32 1
  store i8* %incdec.ptr546, i8** %m, align 8
  br label %for.cond.534

for.end.547:                                      ; preds = %land.end.542
  %356 = load i8*, i8** %m, align 8
  %357 = load i8*, i8** %strend, align 8
  %cmp548 = icmp uge i8* %356, %357
  br i1 %cmp548, label %if.then.550, label %if.end.551

if.then.550:                                      ; preds = %for.end.547
  br label %while.end.583

if.end.551:                                       ; preds = %for.end.547
  %358 = load i8*, i8** %s, align 8
  %359 = load i8*, i8** %m, align 8
  %360 = load i8*, i8** %s, align 8
  %sub.ptr.lhs.cast552 = ptrtoint i8* %359 to i64
  %sub.ptr.rhs.cast553 = ptrtoint i8* %360 to i64
  %sub.ptr.sub554 = sub i64 %sub.ptr.lhs.cast552, %sub.ptr.rhs.cast553
  %call555 = call %struct.sv* @Perl_newSVpvn(i8* %358, i64 %sub.ptr.sub554)
  store %struct.sv* %call555, %struct.sv** %dstr, align 8
  %361 = load i32, i32* %make_mortal, align 4
  %tobool556 = icmp ne i32 %361, 0
  br i1 %tobool556, label %if.then.557, label %if.end.559

if.then.557:                                      ; preds = %if.end.551
  %362 = load %struct.sv*, %struct.sv** %dstr, align 8
  %call558 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %362)
  br label %if.end.559

if.end.559:                                       ; preds = %if.then.557, %if.end.551
  %363 = load i8, i8* %do_utf8, align 1
  %tobool560 = icmp ne i8 %363, 0
  br i1 %tobool560, label %if.then.561, label %if.end.564

if.then.561:                                      ; preds = %if.end.559
  %364 = load %struct.sv*, %struct.sv** %dstr, align 8
  %sv_flags562 = getelementptr inbounds %struct.sv, %struct.sv* %364, i32 0, i32 2
  %365 = load i32, i32* %sv_flags562, align 4
  %or563 = or i32 %365, 536870912
  store i32 %or563, i32* %sv_flags562, align 4
  br label %if.end.564

if.end.564:                                       ; preds = %if.then.561, %if.end.559
  %366 = load %struct.sv**, %struct.sv*** @PL_stack_max, align 8
  %367 = load %struct.sv**, %struct.sv*** %sp, align 8
  %sub.ptr.lhs.cast565 = ptrtoint %struct.sv** %366 to i64
  %sub.ptr.rhs.cast566 = ptrtoint %struct.sv** %367 to i64
  %sub.ptr.sub567 = sub i64 %sub.ptr.lhs.cast565, %sub.ptr.rhs.cast566
  %sub.ptr.div568 = sdiv exact i64 %sub.ptr.sub567, 8
  %cmp569 = icmp slt i64 %sub.ptr.div568, 1
  br i1 %cmp569, label %if.then.571, label %if.end.573

if.then.571:                                      ; preds = %if.end.564
  %368 = load %struct.sv**, %struct.sv*** %sp, align 8
  %369 = load %struct.sv**, %struct.sv*** %sp, align 8
  %call572 = call %struct.sv** @Perl_stack_grow(%struct.sv** %368, %struct.sv** %369, i32 1)
  store %struct.sv** %call572, %struct.sv*** %sp, align 8
  br label %if.end.573

if.end.573:                                       ; preds = %if.then.571, %if.end.564
  %370 = load %struct.sv*, %struct.sv** %dstr, align 8
  %371 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr575 = getelementptr inbounds %struct.sv*, %struct.sv** %371, i32 1
  store %struct.sv** %incdec.ptr575, %struct.sv*** %sp, align 8
  store %struct.sv* %370, %struct.sv** %incdec.ptr575, align 8
  store %struct.sv* %370, %struct.sv** %tmp574
  %372 = load %struct.sv*, %struct.sv** %tmp574
  %373 = load i8, i8* %do_utf8, align 1
  %tobool576 = icmp ne i8 %373, 0
  br i1 %tobool576, label %if.then.577, label %if.else.580

if.then.577:                                      ; preds = %if.end.573
  %374 = load i8*, i8** %m, align 8
  %375 = load i64, i64* %len, align 8
  %conv578 = trunc i64 %375 to i32
  %call579 = call i8* @Perl_utf8_hop(i8* %374, i32 %conv578)
  store i8* %call579, i8** %s, align 8
  br label %if.end.582

if.else.580:                                      ; preds = %if.end.573
  %376 = load i8*, i8** %m, align 8
  %377 = load i64, i64* %len, align 8
  %add.ptr581 = getelementptr inbounds i8, i8* %376, i64 %377
  store i8* %add.ptr581, i8** %s, align 8
  br label %if.end.582

if.end.582:                                       ; preds = %if.else.580, %if.then.577
  br label %while.cond.530

while.end.583:                                    ; preds = %if.then.550, %while.cond.530
  br label %if.end.631

if.else.584:                                      ; preds = %land.lhs.true.512, %land.lhs.true.508, %if.then.499
  br label %while.cond.585

while.cond.585:                                   ; preds = %if.end.629, %if.else.584
  %378 = load i8*, i8** %s, align 8
  %379 = load i8*, i8** %strend, align 8
  %cmp586 = icmp ult i8* %378, %379
  br i1 %cmp586, label %land.lhs.true.588, label %land.end.596

land.lhs.true.588:                                ; preds = %while.cond.585
  %380 = load i64, i64* %limit, align 8
  %dec589 = add nsw i64 %380, -1
  store i64 %dec589, i64* %limit, align 8
  %tobool590 = icmp ne i64 %dec589, 0
  br i1 %tobool590, label %land.rhs.591, label %land.end.596

land.rhs.591:                                     ; preds = %land.lhs.true.588
  %381 = load i8*, i8** %s, align 8
  %382 = load i8*, i8** %strend, align 8
  %383 = load %struct.sv*, %struct.sv** %csv, align 8
  %384 = load i32, i32* @PL_multiline, align 4
  %tobool592 = icmp ne i32 %384, 0
  %cond593 = select i1 %tobool592, i32 1, i32 0
  %call594 = call i8* @Perl_fbm_instr(i8* %381, i8* %382, %struct.sv* %383, i32 %cond593)
  store i8* %call594, i8** %m, align 8
  %tobool595 = icmp ne i8* %call594, null
  br label %land.end.596

land.end.596:                                     ; preds = %land.rhs.591, %land.lhs.true.588, %while.cond.585
  %385 = phi i1 [ false, %land.lhs.true.588 ], [ false, %while.cond.585 ], [ %tobool595, %land.rhs.591 ]
  br i1 %385, label %while.body.598, label %while.end.630

while.body.598:                                   ; preds = %land.end.596
  %386 = load i8*, i8** %s, align 8
  %387 = load i8*, i8** %m, align 8
  %388 = load i8*, i8** %s, align 8
  %sub.ptr.lhs.cast599 = ptrtoint i8* %387 to i64
  %sub.ptr.rhs.cast600 = ptrtoint i8* %388 to i64
  %sub.ptr.sub601 = sub i64 %sub.ptr.lhs.cast599, %sub.ptr.rhs.cast600
  %call602 = call %struct.sv* @Perl_newSVpvn(i8* %386, i64 %sub.ptr.sub601)
  store %struct.sv* %call602, %struct.sv** %dstr, align 8
  %389 = load i32, i32* %make_mortal, align 4
  %tobool603 = icmp ne i32 %389, 0
  br i1 %tobool603, label %if.then.604, label %if.end.606

if.then.604:                                      ; preds = %while.body.598
  %390 = load %struct.sv*, %struct.sv** %dstr, align 8
  %call605 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %390)
  br label %if.end.606

if.end.606:                                       ; preds = %if.then.604, %while.body.598
  %391 = load i8, i8* %do_utf8, align 1
  %tobool607 = icmp ne i8 %391, 0
  br i1 %tobool607, label %if.then.608, label %if.end.611

if.then.608:                                      ; preds = %if.end.606
  %392 = load %struct.sv*, %struct.sv** %dstr, align 8
  %sv_flags609 = getelementptr inbounds %struct.sv, %struct.sv* %392, i32 0, i32 2
  %393 = load i32, i32* %sv_flags609, align 4
  %or610 = or i32 %393, 536870912
  store i32 %or610, i32* %sv_flags609, align 4
  br label %if.end.611

if.end.611:                                       ; preds = %if.then.608, %if.end.606
  %394 = load %struct.sv**, %struct.sv*** @PL_stack_max, align 8
  %395 = load %struct.sv**, %struct.sv*** %sp, align 8
  %sub.ptr.lhs.cast612 = ptrtoint %struct.sv** %394 to i64
  %sub.ptr.rhs.cast613 = ptrtoint %struct.sv** %395 to i64
  %sub.ptr.sub614 = sub i64 %sub.ptr.lhs.cast612, %sub.ptr.rhs.cast613
  %sub.ptr.div615 = sdiv exact i64 %sub.ptr.sub614, 8
  %cmp616 = icmp slt i64 %sub.ptr.div615, 1
  br i1 %cmp616, label %if.then.618, label %if.end.620

if.then.618:                                      ; preds = %if.end.611
  %396 = load %struct.sv**, %struct.sv*** %sp, align 8
  %397 = load %struct.sv**, %struct.sv*** %sp, align 8
  %call619 = call %struct.sv** @Perl_stack_grow(%struct.sv** %396, %struct.sv** %397, i32 1)
  store %struct.sv** %call619, %struct.sv*** %sp, align 8
  br label %if.end.620

if.end.620:                                       ; preds = %if.then.618, %if.end.611
  %398 = load %struct.sv*, %struct.sv** %dstr, align 8
  %399 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr622 = getelementptr inbounds %struct.sv*, %struct.sv** %399, i32 1
  store %struct.sv** %incdec.ptr622, %struct.sv*** %sp, align 8
  store %struct.sv* %398, %struct.sv** %incdec.ptr622, align 8
  store %struct.sv* %398, %struct.sv** %tmp621
  %400 = load %struct.sv*, %struct.sv** %tmp621
  %401 = load i8, i8* %do_utf8, align 1
  %tobool623 = icmp ne i8 %401, 0
  br i1 %tobool623, label %if.then.624, label %if.else.627

if.then.624:                                      ; preds = %if.end.620
  %402 = load i8*, i8** %m, align 8
  %403 = load i64, i64* %len, align 8
  %conv625 = trunc i64 %403 to i32
  %call626 = call i8* @Perl_utf8_hop(i8* %402, i32 %conv625)
  store i8* %call626, i8** %s, align 8
  br label %if.end.629

if.else.627:                                      ; preds = %if.end.620
  %404 = load i8*, i8** %m, align 8
  %405 = load i64, i64* %len, align 8
  %add.ptr628 = getelementptr inbounds i8, i8* %404, i64 %405
  store i8* %add.ptr628, i8** %s, align 8
  br label %if.end.629

if.end.629:                                       ; preds = %if.else.627, %if.then.624
  br label %while.cond.585

while.end.630:                                    ; preds = %land.end.596
  br label %if.end.631

if.end.631:                                       ; preds = %while.end.630, %while.end.583
  br label %if.end.758

if.else.632:                                      ; preds = %land.lhs.true.495, %land.lhs.true.491, %land.lhs.true.489, %land.lhs.true.485, %if.else.477
  %406 = load i64, i64* %slen, align 8
  %407 = load %struct.regexp*, %struct.regexp** %rx, align 8
  %nparens633 = getelementptr inbounds %struct.regexp, %struct.regexp* %407, i32 0, i32 12
  %408 = load i32, i32* %nparens633, align 4
  %conv634 = zext i32 %408 to i64
  %mul = mul i64 %406, %conv634
  %409 = load i32, i32* %maxiters, align 4
  %conv635 = sext i32 %409 to i64
  %add636 = add i64 %conv635, %mul
  %conv637 = trunc i64 %add636 to i32
  store i32 %conv637, i32* %maxiters, align 4
  br label %while.cond.638

while.cond.638:                                   ; preds = %if.end.752, %if.else.632
  %410 = load i8*, i8** %s, align 8
  %411 = load i8*, i8** %strend, align 8
  %cmp639 = icmp ult i8* %410, %411
  br i1 %cmp639, label %land.rhs.641, label %land.end.644

land.rhs.641:                                     ; preds = %while.cond.638
  %412 = load i64, i64* %limit, align 8
  %dec642 = add nsw i64 %412, -1
  store i64 %dec642, i64* %limit, align 8
  %tobool643 = icmp ne i64 %dec642, 0
  br label %land.end.644

land.end.644:                                     ; preds = %land.rhs.641, %while.cond.638
  %413 = phi i1 [ false, %while.cond.638 ], [ %tobool643, %land.rhs.641 ]
  br i1 %413, label %while.body.646, label %while.end.757

while.body.646:                                   ; preds = %land.end.644
  %414 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %414, %struct.sv*** @PL_stack_sp, align 8
  %415 = load i32 (%struct.regexp*, i8*, i8*, i8*, i32, %struct.sv*, i8*, i32)*, i32 (%struct.regexp*, i8*, i8*, i8*, i32, %struct.sv*, i8*, i32)** @PL_regexecp, align 8
  %416 = load %struct.regexp*, %struct.regexp** %rx, align 8
  %417 = load i8*, i8** %s, align 8
  %418 = load i8*, i8** %strend, align 8
  %419 = load i8*, i8** %orig, align 8
  %420 = load %struct.sv*, %struct.sv** %sv, align 8
  %call647 = call i32 %415(%struct.regexp* %416, i8* %417, i8* %418, i8* %419, i32 1, %struct.sv* %420, i8* null, i32 0)
  store i32 %call647, i32* %i, align 4
  %421 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %421, %struct.sv*** %sp, align 8
  %422 = load i32, i32* %i, align 4
  %cmp648 = icmp eq i32 %422, 0
  br i1 %cmp648, label %if.then.650, label %if.end.651

if.then.650:                                      ; preds = %while.body.646
  br label %while.end.757

if.end.651:                                       ; preds = %while.body.646
  %423 = load %struct.regexp*, %struct.regexp** %rx, align 8
  %reganch652 = getelementptr inbounds %struct.regexp, %struct.regexp* %423, i32 0, i32 15
  %424 = load i32, i32* %reganch652, align 4
  %and653 = and i32 %424, 524288
  %tobool654 = icmp ne i32 %and653, 0
  br i1 %tobool654, label %if.then.655, label %if.end.656

if.then.655:                                      ; preds = %if.end.651
  store i8 1, i8* @PL_tainted, align 1
  br label %if.end.656

if.end.656:                                       ; preds = %if.then.655, %if.end.651
  %425 = load %struct.regexp*, %struct.regexp** %rx, align 8
  %reganch657 = getelementptr inbounds %struct.regexp, %struct.regexp* %425, i32 0, i32 15
  %426 = load i32, i32* %reganch657, align 4
  %and658 = and i32 %426, 262144
  %tobool659 = icmp ne i32 %and658, 0
  br i1 %tobool659, label %land.lhs.true.660, label %if.end.673

land.lhs.true.660:                                ; preds = %if.end.656
  %427 = load %struct.regexp*, %struct.regexp** %rx, align 8
  %subbeg = getelementptr inbounds %struct.regexp, %struct.regexp* %427, i32 0, i32 6
  %428 = load i8*, i8** %subbeg, align 8
  %429 = load i8*, i8** %orig, align 8
  %cmp661 = icmp ne i8* %428, %429
  br i1 %cmp661, label %if.then.663, label %if.end.673

if.then.663:                                      ; preds = %land.lhs.true.660
  %430 = load i8*, i8** %s, align 8
  store i8* %430, i8** %m, align 8
  %431 = load i8*, i8** %orig, align 8
  store i8* %431, i8** %s, align 8
  %432 = load %struct.regexp*, %struct.regexp** %rx, align 8
  %subbeg664 = getelementptr inbounds %struct.regexp, %struct.regexp* %432, i32 0, i32 6
  %433 = load i8*, i8** %subbeg664, align 8
  store i8* %433, i8** %orig, align 8
  %434 = load i8*, i8** %orig, align 8
  %435 = load i8*, i8** %m, align 8
  %436 = load i8*, i8** %s, align 8
  %sub.ptr.lhs.cast665 = ptrtoint i8* %435 to i64
  %sub.ptr.rhs.cast666 = ptrtoint i8* %436 to i64
  %sub.ptr.sub667 = sub i64 %sub.ptr.lhs.cast665, %sub.ptr.rhs.cast666
  %add.ptr668 = getelementptr inbounds i8, i8* %434, i64 %sub.ptr.sub667
  store i8* %add.ptr668, i8** %s, align 8
  %437 = load i8*, i8** %s, align 8
  %438 = load i8*, i8** %strend, align 8
  %439 = load i8*, i8** %m, align 8
  %sub.ptr.lhs.cast669 = ptrtoint i8* %438 to i64
  %sub.ptr.rhs.cast670 = ptrtoint i8* %439 to i64
  %sub.ptr.sub671 = sub i64 %sub.ptr.lhs.cast669, %sub.ptr.rhs.cast670
  %add.ptr672 = getelementptr inbounds i8, i8* %437, i64 %sub.ptr.sub671
  store i8* %add.ptr672, i8** %strend, align 8
  br label %if.end.673

if.end.673:                                       ; preds = %if.then.663, %land.lhs.true.660, %if.end.656
  %440 = load %struct.regexp*, %struct.regexp** %rx, align 8
  %startp = getelementptr inbounds %struct.regexp, %struct.regexp* %440, i32 0, i32 0
  %441 = load i32*, i32** %startp, align 8
  %arrayidx674 = getelementptr inbounds i32, i32* %441, i64 0
  %442 = load i32, i32* %arrayidx674, align 4
  %443 = load i8*, i8** %orig, align 8
  %idx.ext = sext i32 %442 to i64
  %add.ptr675 = getelementptr inbounds i8, i8* %443, i64 %idx.ext
  store i8* %add.ptr675, i8** %m, align 8
  %444 = load i8*, i8** %s, align 8
  %445 = load i8*, i8** %m, align 8
  %446 = load i8*, i8** %s, align 8
  %sub.ptr.lhs.cast676 = ptrtoint i8* %445 to i64
  %sub.ptr.rhs.cast677 = ptrtoint i8* %446 to i64
  %sub.ptr.sub678 = sub i64 %sub.ptr.lhs.cast676, %sub.ptr.rhs.cast677
  %call679 = call %struct.sv* @Perl_newSVpvn(i8* %444, i64 %sub.ptr.sub678)
  store %struct.sv* %call679, %struct.sv** %dstr, align 8
  %447 = load i32, i32* %make_mortal, align 4
  %tobool680 = icmp ne i32 %447, 0
  br i1 %tobool680, label %if.then.681, label %if.end.683

if.then.681:                                      ; preds = %if.end.673
  %448 = load %struct.sv*, %struct.sv** %dstr, align 8
  %call682 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %448)
  br label %if.end.683

if.end.683:                                       ; preds = %if.then.681, %if.end.673
  %449 = load i8, i8* %do_utf8, align 1
  %tobool684 = icmp ne i8 %449, 0
  br i1 %tobool684, label %if.then.685, label %if.end.688

if.then.685:                                      ; preds = %if.end.683
  %450 = load %struct.sv*, %struct.sv** %dstr, align 8
  %sv_flags686 = getelementptr inbounds %struct.sv, %struct.sv* %450, i32 0, i32 2
  %451 = load i32, i32* %sv_flags686, align 4
  %or687 = or i32 %451, 536870912
  store i32 %or687, i32* %sv_flags686, align 4
  br label %if.end.688

if.end.688:                                       ; preds = %if.then.685, %if.end.683
  %452 = load %struct.sv**, %struct.sv*** @PL_stack_max, align 8
  %453 = load %struct.sv**, %struct.sv*** %sp, align 8
  %sub.ptr.lhs.cast689 = ptrtoint %struct.sv** %452 to i64
  %sub.ptr.rhs.cast690 = ptrtoint %struct.sv** %453 to i64
  %sub.ptr.sub691 = sub i64 %sub.ptr.lhs.cast689, %sub.ptr.rhs.cast690
  %sub.ptr.div692 = sdiv exact i64 %sub.ptr.sub691, 8
  %cmp693 = icmp slt i64 %sub.ptr.div692, 1
  br i1 %cmp693, label %if.then.695, label %if.end.697

if.then.695:                                      ; preds = %if.end.688
  %454 = load %struct.sv**, %struct.sv*** %sp, align 8
  %455 = load %struct.sv**, %struct.sv*** %sp, align 8
  %call696 = call %struct.sv** @Perl_stack_grow(%struct.sv** %454, %struct.sv** %455, i32 1)
  store %struct.sv** %call696, %struct.sv*** %sp, align 8
  br label %if.end.697

if.end.697:                                       ; preds = %if.then.695, %if.end.688
  %456 = load %struct.sv*, %struct.sv** %dstr, align 8
  %457 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr699 = getelementptr inbounds %struct.sv*, %struct.sv** %457, i32 1
  store %struct.sv** %incdec.ptr699, %struct.sv*** %sp, align 8
  store %struct.sv* %456, %struct.sv** %incdec.ptr699, align 8
  store %struct.sv* %456, %struct.sv** %tmp698
  %458 = load %struct.sv*, %struct.sv** %tmp698
  %459 = load %struct.regexp*, %struct.regexp** %rx, align 8
  %nparens700 = getelementptr inbounds %struct.regexp, %struct.regexp* %459, i32 0, i32 12
  %460 = load i32, i32* %nparens700, align 4
  %tobool701 = icmp ne i32 %460, 0
  br i1 %tobool701, label %if.then.702, label %if.end.752

if.then.702:                                      ; preds = %if.end.697
  store i32 1, i32* %i, align 4
  br label %for.cond.703

for.cond.703:                                     ; preds = %for.inc.749, %if.then.702
  %461 = load i32, i32* %i, align 4
  %462 = load %struct.regexp*, %struct.regexp** %rx, align 8
  %nparens704 = getelementptr inbounds %struct.regexp, %struct.regexp* %462, i32 0, i32 12
  %463 = load i32, i32* %nparens704, align 4
  %cmp705 = icmp sle i32 %461, %463
  br i1 %cmp705, label %for.body.707, label %for.end.751

for.body.707:                                     ; preds = %for.cond.703
  %464 = load i32, i32* %i, align 4
  %idxprom708 = sext i32 %464 to i64
  %465 = load %struct.regexp*, %struct.regexp** %rx, align 8
  %startp709 = getelementptr inbounds %struct.regexp, %struct.regexp* %465, i32 0, i32 0
  %466 = load i32*, i32** %startp709, align 8
  %arrayidx710 = getelementptr inbounds i32, i32* %466, i64 %idxprom708
  %467 = load i32, i32* %arrayidx710, align 4
  %468 = load i8*, i8** %orig, align 8
  %idx.ext711 = sext i32 %467 to i64
  %add.ptr712 = getelementptr inbounds i8, i8* %468, i64 %idx.ext711
  store i8* %add.ptr712, i8** %s, align 8
  %469 = load i32, i32* %i, align 4
  %idxprom713 = sext i32 %469 to i64
  %470 = load %struct.regexp*, %struct.regexp** %rx, align 8
  %endp = getelementptr inbounds %struct.regexp, %struct.regexp* %470, i32 0, i32 1
  %471 = load i32*, i32** %endp, align 8
  %arrayidx714 = getelementptr inbounds i32, i32* %471, i64 %idxprom713
  %472 = load i32, i32* %arrayidx714, align 4
  %473 = load i8*, i8** %orig, align 8
  %idx.ext715 = sext i32 %472 to i64
  %add.ptr716 = getelementptr inbounds i8, i8* %473, i64 %idx.ext715
  store i8* %add.ptr716, i8** %m, align 8
  %474 = load i8*, i8** %m, align 8
  %475 = load i8*, i8** %orig, align 8
  %cmp717 = icmp uge i8* %474, %475
  br i1 %cmp717, label %land.lhs.true.719, label %if.else.727

land.lhs.true.719:                                ; preds = %for.body.707
  %476 = load i8*, i8** %s, align 8
  %477 = load i8*, i8** %orig, align 8
  %cmp720 = icmp uge i8* %476, %477
  br i1 %cmp720, label %if.then.722, label %if.else.727

if.then.722:                                      ; preds = %land.lhs.true.719
  %478 = load i8*, i8** %s, align 8
  %479 = load i8*, i8** %m, align 8
  %480 = load i8*, i8** %s, align 8
  %sub.ptr.lhs.cast723 = ptrtoint i8* %479 to i64
  %sub.ptr.rhs.cast724 = ptrtoint i8* %480 to i64
  %sub.ptr.sub725 = sub i64 %sub.ptr.lhs.cast723, %sub.ptr.rhs.cast724
  %call726 = call %struct.sv* @Perl_newSVpvn(i8* %478, i64 %sub.ptr.sub725)
  store %struct.sv* %call726, %struct.sv** %dstr, align 8
  br label %if.end.728

if.else.727:                                      ; preds = %land.lhs.true.719, %for.body.707
  store %struct.sv* @PL_sv_undef, %struct.sv** %dstr, align 8
  br label %if.end.728

if.end.728:                                       ; preds = %if.else.727, %if.then.722
  %481 = load i32, i32* %make_mortal, align 4
  %tobool729 = icmp ne i32 %481, 0
  br i1 %tobool729, label %if.then.730, label %if.end.732

if.then.730:                                      ; preds = %if.end.728
  %482 = load %struct.sv*, %struct.sv** %dstr, align 8
  %call731 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %482)
  br label %if.end.732

if.end.732:                                       ; preds = %if.then.730, %if.end.728
  %483 = load i8, i8* %do_utf8, align 1
  %tobool733 = icmp ne i8 %483, 0
  br i1 %tobool733, label %if.then.734, label %if.end.737

if.then.734:                                      ; preds = %if.end.732
  %484 = load %struct.sv*, %struct.sv** %dstr, align 8
  %sv_flags735 = getelementptr inbounds %struct.sv, %struct.sv* %484, i32 0, i32 2
  %485 = load i32, i32* %sv_flags735, align 4
  %or736 = or i32 %485, 536870912
  store i32 %or736, i32* %sv_flags735, align 4
  br label %if.end.737

if.end.737:                                       ; preds = %if.then.734, %if.end.732
  %486 = load %struct.sv**, %struct.sv*** @PL_stack_max, align 8
  %487 = load %struct.sv**, %struct.sv*** %sp, align 8
  %sub.ptr.lhs.cast738 = ptrtoint %struct.sv** %486 to i64
  %sub.ptr.rhs.cast739 = ptrtoint %struct.sv** %487 to i64
  %sub.ptr.sub740 = sub i64 %sub.ptr.lhs.cast738, %sub.ptr.rhs.cast739
  %sub.ptr.div741 = sdiv exact i64 %sub.ptr.sub740, 8
  %cmp742 = icmp slt i64 %sub.ptr.div741, 1
  br i1 %cmp742, label %if.then.744, label %if.end.746

if.then.744:                                      ; preds = %if.end.737
  %488 = load %struct.sv**, %struct.sv*** %sp, align 8
  %489 = load %struct.sv**, %struct.sv*** %sp, align 8
  %call745 = call %struct.sv** @Perl_stack_grow(%struct.sv** %488, %struct.sv** %489, i32 1)
  store %struct.sv** %call745, %struct.sv*** %sp, align 8
  br label %if.end.746

if.end.746:                                       ; preds = %if.then.744, %if.end.737
  %490 = load %struct.sv*, %struct.sv** %dstr, align 8
  %491 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr748 = getelementptr inbounds %struct.sv*, %struct.sv** %491, i32 1
  store %struct.sv** %incdec.ptr748, %struct.sv*** %sp, align 8
  store %struct.sv* %490, %struct.sv** %incdec.ptr748, align 8
  store %struct.sv* %490, %struct.sv** %tmp747
  %492 = load %struct.sv*, %struct.sv** %tmp747
  br label %for.inc.749

for.inc.749:                                      ; preds = %if.end.746
  %493 = load i32, i32* %i, align 4
  %inc750 = add nsw i32 %493, 1
  store i32 %inc750, i32* %i, align 4
  br label %for.cond.703

for.end.751:                                      ; preds = %for.cond.703
  br label %if.end.752

if.end.752:                                       ; preds = %for.end.751, %if.end.697
  %494 = load %struct.regexp*, %struct.regexp** %rx, align 8
  %endp753 = getelementptr inbounds %struct.regexp, %struct.regexp* %494, i32 0, i32 1
  %495 = load i32*, i32** %endp753, align 8
  %arrayidx754 = getelementptr inbounds i32, i32* %495, i64 0
  %496 = load i32, i32* %arrayidx754, align 4
  %497 = load i8*, i8** %orig, align 8
  %idx.ext755 = sext i32 %496 to i64
  %add.ptr756 = getelementptr inbounds i8, i8* %497, i64 %idx.ext755
  store i8* %add.ptr756, i8** %s, align 8
  br label %while.cond.638

while.end.757:                                    ; preds = %if.then.650, %land.end.644
  br label %if.end.758

if.end.758:                                       ; preds = %while.end.757, %if.end.631
  br label %if.end.759

if.end.759:                                       ; preds = %if.end.758, %while.end.476
  br label %if.end.760

if.end.760:                                       ; preds = %if.end.759, %while.end.417
  %498 = load %struct.sv**, %struct.sv*** %sp, align 8
  %499 = load %struct.sv**, %struct.sv*** @PL_stack_base, align 8
  %sub.ptr.lhs.cast761 = ptrtoint %struct.sv** %498 to i64
  %sub.ptr.rhs.cast762 = ptrtoint %struct.sv** %499 to i64
  %sub.ptr.sub763 = sub i64 %sub.ptr.lhs.cast761, %sub.ptr.rhs.cast762
  %sub.ptr.div764 = sdiv exact i64 %sub.ptr.sub763, 8
  %500 = load i32, i32* %base, align 4
  %conv765 = sext i32 %500 to i64
  %sub = sub nsw i64 %sub.ptr.div764, %conv765
  %conv766 = trunc i64 %sub to i32
  store i32 %conv766, i32* %iters, align 4
  %501 = load i32, i32* %iters, align 4
  %502 = load i32, i32* %maxiters, align 4
  %cmp767 = icmp sgt i32 %501, %502
  br i1 %cmp767, label %if.then.769, label %if.end.771

if.then.769:                                      ; preds = %if.end.760
  %call770 = call %struct.op* (i8*, ...) @Perl_die(i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.48, i32 0, i32 0))
  store %struct.op* %call770, %struct.op** %retval
  br label %return

if.end.771:                                       ; preds = %if.end.760
  %503 = load i8*, i8** %s, align 8
  %504 = load i8*, i8** %strend, align 8
  %cmp772 = icmp ult i8* %503, %504
  br i1 %cmp772, label %if.then.778, label %lor.lhs.false.774

lor.lhs.false.774:                                ; preds = %if.end.771
  %505 = load i32, i32* %iters, align 4
  %tobool775 = icmp ne i32 %505, 0
  br i1 %tobool775, label %land.lhs.true.776, label %if.else.805

land.lhs.true.776:                                ; preds = %lor.lhs.false.774
  %506 = load i32, i32* %origlimit, align 4
  %tobool777 = icmp ne i32 %506, 0
  br i1 %tobool777, label %if.then.778, label %if.else.805

if.then.778:                                      ; preds = %land.lhs.true.776, %if.end.771
  %507 = load i8*, i8** %strend, align 8
  %508 = load i8*, i8** %s, align 8
  %sub.ptr.lhs.cast780 = ptrtoint i8* %507 to i64
  %sub.ptr.rhs.cast781 = ptrtoint i8* %508 to i64
  %sub.ptr.sub782 = sub i64 %sub.ptr.lhs.cast780, %sub.ptr.rhs.cast781
  store i64 %sub.ptr.sub782, i64* %l, align 8
  %509 = load i8*, i8** %s, align 8
  %510 = load i64, i64* %l, align 8
  %call783 = call %struct.sv* @Perl_newSVpvn(i8* %509, i64 %510)
  store %struct.sv* %call783, %struct.sv** %dstr, align 8
  %511 = load i32, i32* %make_mortal, align 4
  %tobool784 = icmp ne i32 %511, 0
  br i1 %tobool784, label %if.then.785, label %if.end.787

if.then.785:                                      ; preds = %if.then.778
  %512 = load %struct.sv*, %struct.sv** %dstr, align 8
  %call786 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %512)
  br label %if.end.787

if.end.787:                                       ; preds = %if.then.785, %if.then.778
  %513 = load i8, i8* %do_utf8, align 1
  %tobool788 = icmp ne i8 %513, 0
  br i1 %tobool788, label %if.then.789, label %if.end.792

if.then.789:                                      ; preds = %if.end.787
  %514 = load %struct.sv*, %struct.sv** %dstr, align 8
  %sv_flags790 = getelementptr inbounds %struct.sv, %struct.sv* %514, i32 0, i32 2
  %515 = load i32, i32* %sv_flags790, align 4
  %or791 = or i32 %515, 536870912
  store i32 %or791, i32* %sv_flags790, align 4
  br label %if.end.792

if.end.792:                                       ; preds = %if.then.789, %if.end.787
  %516 = load %struct.sv**, %struct.sv*** @PL_stack_max, align 8
  %517 = load %struct.sv**, %struct.sv*** %sp, align 8
  %sub.ptr.lhs.cast793 = ptrtoint %struct.sv** %516 to i64
  %sub.ptr.rhs.cast794 = ptrtoint %struct.sv** %517 to i64
  %sub.ptr.sub795 = sub i64 %sub.ptr.lhs.cast793, %sub.ptr.rhs.cast794
  %sub.ptr.div796 = sdiv exact i64 %sub.ptr.sub795, 8
  %cmp797 = icmp slt i64 %sub.ptr.div796, 1
  br i1 %cmp797, label %if.then.799, label %if.end.801

if.then.799:                                      ; preds = %if.end.792
  %518 = load %struct.sv**, %struct.sv*** %sp, align 8
  %519 = load %struct.sv**, %struct.sv*** %sp, align 8
  %call800 = call %struct.sv** @Perl_stack_grow(%struct.sv** %518, %struct.sv** %519, i32 1)
  store %struct.sv** %call800, %struct.sv*** %sp, align 8
  br label %if.end.801

if.end.801:                                       ; preds = %if.then.799, %if.end.792
  %520 = load %struct.sv*, %struct.sv** %dstr, align 8
  %521 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr803 = getelementptr inbounds %struct.sv*, %struct.sv** %521, i32 1
  store %struct.sv** %incdec.ptr803, %struct.sv*** %sp, align 8
  store %struct.sv* %520, %struct.sv** %incdec.ptr803, align 8
  store %struct.sv* %520, %struct.sv** %tmp802
  %522 = load %struct.sv*, %struct.sv** %tmp802
  %523 = load i32, i32* %iters, align 4
  %inc804 = add nsw i32 %523, 1
  store i32 %inc804, i32* %iters, align 4
  br label %if.end.836

if.else.805:                                      ; preds = %land.lhs.true.776, %lor.lhs.false.774
  %524 = load i32, i32* %origlimit, align 4
  %tobool806 = icmp ne i32 %524, 0
  br i1 %tobool806, label %if.end.835, label %if.then.807

if.then.807:                                      ; preds = %if.else.805
  br label %while.cond.808

while.cond.808:                                   ; preds = %if.end.831, %if.then.807
  %525 = load i32, i32* %iters, align 4
  %cmp809 = icmp sgt i32 %525, 0
  br i1 %cmp809, label %land.rhs.811, label %land.end.823

land.rhs.811:                                     ; preds = %while.cond.808
  %526 = load %struct.sv**, %struct.sv*** %sp, align 8
  %527 = load %struct.sv*, %struct.sv** %526, align 8
  %tobool812 = icmp ne %struct.sv* %527, null
  br i1 %tobool812, label %lor.lhs.false.813, label %lor.end.821

lor.lhs.false.813:                                ; preds = %land.rhs.811
  %528 = load %struct.sv**, %struct.sv*** %sp, align 8
  %529 = load %struct.sv*, %struct.sv** %528, align 8
  %sv_any814 = getelementptr inbounds %struct.sv, %struct.sv* %529, i32 0, i32 0
  %530 = load i8*, i8** %sv_any814, align 8
  %tobool815 = icmp ne i8* %530, null
  br i1 %tobool815, label %lor.rhs.816, label %lor.end.821

lor.rhs.816:                                      ; preds = %lor.lhs.false.813
  %531 = load %struct.sv**, %struct.sv*** %sp, align 8
  %532 = load %struct.sv*, %struct.sv** %531, align 8
  %sv_any817 = getelementptr inbounds %struct.sv, %struct.sv* %532, i32 0, i32 0
  %533 = load i8*, i8** %sv_any817, align 8
  %534 = bitcast i8* %533 to %struct.xpv*
  %xpv_cur818 = getelementptr inbounds %struct.xpv, %struct.xpv* %534, i32 0, i32 1
  %535 = load i64, i64* %xpv_cur818, align 8
  %cmp819 = icmp eq i64 %535, 0
  br label %lor.end.821

lor.end.821:                                      ; preds = %lor.rhs.816, %lor.lhs.false.813, %land.rhs.811
  %536 = phi i1 [ true, %lor.lhs.false.813 ], [ true, %land.rhs.811 ], [ %cmp819, %lor.rhs.816 ]
  br label %land.end.823

land.end.823:                                     ; preds = %lor.end.821, %while.cond.808
  %537 = phi i1 [ false, %while.cond.808 ], [ %536, %lor.end.821 ]
  br i1 %537, label %while.body.825, label %while.end.834

while.body.825:                                   ; preds = %land.end.823
  %538 = load %struct.sv**, %struct.sv*** %sp, align 8
  %539 = load %struct.sv*, %struct.sv** %538, align 8
  %tobool826 = icmp ne %struct.sv* %539, null
  br i1 %tobool826, label %land.lhs.true.827, label %if.end.831

land.lhs.true.827:                                ; preds = %while.body.825
  %540 = load i32, i32* %make_mortal, align 4
  %tobool828 = icmp ne i32 %540, 0
  br i1 %tobool828, label %if.end.831, label %if.then.829

if.then.829:                                      ; preds = %land.lhs.true.827
  %541 = load %struct.sv**, %struct.sv*** %sp, align 8
  %542 = load %struct.sv*, %struct.sv** %541, align 8
  %call830 = call %struct.sv* @Perl_sv_2mortal(%struct.sv* %542)
  br label %if.end.831

if.end.831:                                       ; preds = %if.then.829, %land.lhs.true.827, %while.body.825
  %543 = load i32, i32* %iters, align 4
  %dec832 = add nsw i32 %543, -1
  store i32 %dec832, i32* %iters, align 4
  %544 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr833 = getelementptr inbounds %struct.sv*, %struct.sv** %544, i32 -1
  store %struct.sv** %incdec.ptr833, %struct.sv*** %sp, align 8
  store %struct.sv* @PL_sv_undef, %struct.sv** %544, align 8
  br label %while.cond.808

while.end.834:                                    ; preds = %land.end.823
  br label %if.end.835

if.end.835:                                       ; preds = %while.end.834, %if.else.805
  br label %if.end.836

if.end.836:                                       ; preds = %if.end.835, %if.end.801
  %545 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %545, %struct.sv*** @PL_stack_sp, align 8
  %546 = load i32, i32* @PL_savestack_ix, align 4
  %547 = load i32, i32* %oldsave, align 4
  %cmp837 = icmp sgt i32 %546, %547
  br i1 %cmp837, label %if.then.839, label %if.end.840

if.then.839:                                      ; preds = %if.end.836
  %548 = load i32, i32* %oldsave, align 4
  call void @Perl_leave_scope(i32 %548)
  br label %if.end.840

if.end.840:                                       ; preds = %if.then.839, %if.end.836
  %549 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %549, %struct.sv*** %sp, align 8
  %550 = load i32, i32* %realarray, align 4
  %tobool841 = icmp ne i32 %550, 0
  br i1 %tobool841, label %if.then.842, label %if.else.905

if.then.842:                                      ; preds = %if.end.840
  %551 = load %struct.magic*, %struct.magic** %mg, align 8
  %tobool843 = icmp ne %struct.magic* %551, null
  br i1 %tobool843, label %if.else.872, label %if.then.844

if.then.844:                                      ; preds = %if.then.842
  %552 = load %struct.av*, %struct.av** %ary, align 8
  %sv_flags845 = getelementptr inbounds %struct.av, %struct.av* %552, i32 0, i32 2
  %553 = load i32, i32* %sv_flags845, align 4
  %and846 = and i32 %553, 16384
  %tobool847 = icmp ne i32 %and846, 0
  br i1 %tobool847, label %if.then.848, label %if.end.850

if.then.848:                                      ; preds = %if.then.844
  %554 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %554, %struct.sv*** @PL_stack_sp, align 8
  %555 = load %struct.av*, %struct.av** %ary, align 8
  %556 = bitcast %struct.av* %555 to %struct.sv*
  %call849 = call i32 @Perl_mg_set(%struct.sv* %556)
  %557 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %557, %struct.sv*** %sp, align 8
  br label %if.end.850

if.end.850:                                       ; preds = %if.then.848, %if.then.844
  %558 = load i32, i32* %gimme, align 4
  %cmp851 = icmp eq i32 %558, 1
  br i1 %cmp851, label %if.then.853, label %if.end.871

if.then.853:                                      ; preds = %if.end.850
  %559 = load %struct.sv**, %struct.sv*** @PL_stack_max, align 8
  %560 = load %struct.sv**, %struct.sv*** %sp, align 8
  %sub.ptr.lhs.cast854 = ptrtoint %struct.sv** %559 to i64
  %sub.ptr.rhs.cast855 = ptrtoint %struct.sv** %560 to i64
  %sub.ptr.sub856 = sub i64 %sub.ptr.lhs.cast854, %sub.ptr.rhs.cast855
  %sub.ptr.div857 = sdiv exact i64 %sub.ptr.sub856, 8
  %561 = load i32, i32* %iters, align 4
  %conv858 = sext i32 %561 to i64
  %cmp859 = icmp slt i64 %sub.ptr.div857, %conv858
  br i1 %cmp859, label %if.then.861, label %if.end.863

if.then.861:                                      ; preds = %if.then.853
  %562 = load %struct.sv**, %struct.sv*** %sp, align 8
  %563 = load %struct.sv**, %struct.sv*** %sp, align 8
  %564 = load i32, i32* %iters, align 4
  %call862 = call %struct.sv** @Perl_stack_grow(%struct.sv** %562, %struct.sv** %563, i32 %564)
  store %struct.sv** %call862, %struct.sv*** %sp, align 8
  br label %if.end.863

if.end.863:                                       ; preds = %if.then.861, %if.then.853
  %565 = load %struct.sv**, %struct.sv*** %sp, align 8
  %add.ptr864 = getelementptr inbounds %struct.sv*, %struct.sv** %565, i64 1
  %566 = bitcast %struct.sv** %add.ptr864 to i8*
  %567 = load %struct.av*, %struct.av** %ary, align 8
  %sv_any865 = getelementptr inbounds %struct.av, %struct.av* %567, i32 0, i32 0
  %568 = load %struct.xpvav*, %struct.xpvav** %sv_any865, align 8
  %xav_array866 = getelementptr inbounds %struct.xpvav, %struct.xpvav* %568, i32 0, i32 0
  %569 = load i8*, i8** %xav_array866, align 8
  %570 = bitcast i8* %569 to %struct.sv**
  %571 = bitcast %struct.sv** %570 to i8*
  %572 = load i32, i32* %iters, align 4
  %conv867 = sext i32 %572 to i64
  %mul868 = mul i64 %conv867, 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %566, i8* %571, i64 %mul868, i32 1, i1 false)
  %573 = load i32, i32* %iters, align 4
  %574 = load %struct.sv**, %struct.sv*** %sp, align 8
  %idx.ext869 = sext i32 %573 to i64
  %add.ptr870 = getelementptr inbounds %struct.sv*, %struct.sv** %574, i64 %idx.ext869
  store %struct.sv** %add.ptr870, %struct.sv*** %sp, align 8
  %575 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %575, %struct.sv*** @PL_stack_sp, align 8
  %576 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %576, i32 0, i32 0
  %577 = load %struct.op*, %struct.op** %op_next, align 8
  store %struct.op* %577, %struct.op** %retval
  br label %return

if.end.871:                                       ; preds = %if.end.850
  br label %if.end.904

if.else.872:                                      ; preds = %if.then.842
  %578 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %578, %struct.sv*** @PL_stack_sp, align 8
  call void @Perl_push_scope()
  %call873 = call i32 @Perl_call_method(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.45, i32 0, i32 0), i32 2)
  call void @Perl_pop_scope()
  %579 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %579, %struct.sv*** %sp, align 8
  %580 = load i32, i32* %gimme, align 4
  %cmp874 = icmp eq i32 %580, 1
  br i1 %cmp874, label %if.then.876, label %if.end.903

if.then.876:                                      ; preds = %if.else.872
  %581 = load %struct.sv**, %struct.sv*** @PL_stack_max, align 8
  %582 = load %struct.sv**, %struct.sv*** %sp, align 8
  %sub.ptr.lhs.cast877 = ptrtoint %struct.sv** %581 to i64
  %sub.ptr.rhs.cast878 = ptrtoint %struct.sv** %582 to i64
  %sub.ptr.sub879 = sub i64 %sub.ptr.lhs.cast877, %sub.ptr.rhs.cast878
  %sub.ptr.div880 = sdiv exact i64 %sub.ptr.sub879, 8
  %583 = load i32, i32* %iters, align 4
  %conv881 = sext i32 %583 to i64
  %cmp882 = icmp slt i64 %sub.ptr.div880, %conv881
  br i1 %cmp882, label %if.then.884, label %if.end.886

if.then.884:                                      ; preds = %if.then.876
  %584 = load %struct.sv**, %struct.sv*** %sp, align 8
  %585 = load %struct.sv**, %struct.sv*** %sp, align 8
  %586 = load i32, i32* %iters, align 4
  %call885 = call %struct.sv** @Perl_stack_grow(%struct.sv** %584, %struct.sv** %585, i32 %586)
  store %struct.sv** %call885, %struct.sv*** %sp, align 8
  br label %if.end.886

if.end.886:                                       ; preds = %if.then.884, %if.then.876
  store i32 0, i32* %i, align 4
  br label %for.cond.887

for.cond.887:                                     ; preds = %for.inc.899, %if.end.886
  %587 = load i32, i32* %i, align 4
  %588 = load i32, i32* %iters, align 4
  %cmp888 = icmp slt i32 %587, %588
  br i1 %cmp888, label %for.body.890, label %for.end.901

for.body.890:                                     ; preds = %for.cond.887
  %589 = load %struct.av*, %struct.av** %ary, align 8
  %590 = load i32, i32* %i, align 4
  %call892 = call %struct.sv** @Perl_av_fetch(%struct.av* %589, i32 %590, i32 0)
  store %struct.sv** %call892, %struct.sv*** %svp, align 8
  %591 = load %struct.sv**, %struct.sv*** %svp, align 8
  %tobool893 = icmp ne %struct.sv** %591, null
  br i1 %tobool893, label %cond.true.894, label %cond.false.895

cond.true.894:                                    ; preds = %for.body.890
  %592 = load %struct.sv**, %struct.sv*** %svp, align 8
  %593 = load %struct.sv*, %struct.sv** %592, align 8
  br label %cond.end.896

cond.false.895:                                   ; preds = %for.body.890
  br label %cond.end.896

cond.end.896:                                     ; preds = %cond.false.895, %cond.true.894
  %cond897 = phi %struct.sv* [ %593, %cond.true.894 ], [ @PL_sv_undef, %cond.false.895 ]
  %594 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr898 = getelementptr inbounds %struct.sv*, %struct.sv** %594, i32 1
  store %struct.sv** %incdec.ptr898, %struct.sv*** %sp, align 8
  store %struct.sv* %cond897, %struct.sv** %incdec.ptr898, align 8
  br label %for.inc.899

for.inc.899:                                      ; preds = %cond.end.896
  %595 = load i32, i32* %i, align 4
  %inc900 = add nsw i32 %595, 1
  store i32 %inc900, i32* %i, align 4
  br label %for.cond.887

for.end.901:                                      ; preds = %for.cond.887
  %596 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %596, %struct.sv*** @PL_stack_sp, align 8
  %597 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next902 = getelementptr inbounds %struct.op, %struct.op* %597, i32 0, i32 0
  %598 = load %struct.op*, %struct.op** %op_next902, align 8
  store %struct.op* %598, %struct.op** %retval
  br label %return

if.end.903:                                       ; preds = %if.else.872
  br label %if.end.904

if.end.904:                                       ; preds = %if.end.903, %if.end.871
  br label %if.end.911

if.else.905:                                      ; preds = %if.end.840
  %599 = load i32, i32* %gimme, align 4
  %cmp906 = icmp eq i32 %599, 1
  br i1 %cmp906, label %if.then.908, label %if.end.910

if.then.908:                                      ; preds = %if.else.905
  %600 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %600, %struct.sv*** @PL_stack_sp, align 8
  %601 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next909 = getelementptr inbounds %struct.op, %struct.op* %601, i32 0, i32 0
  %602 = load %struct.op*, %struct.op** %op_next909, align 8
  store %struct.op* %602, %struct.op** %retval
  br label %return

if.end.910:                                       ; preds = %if.else.905
  br label %if.end.911

if.end.911:                                       ; preds = %if.end.910, %if.end.904
  %603 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_targ = getelementptr inbounds %struct.op, %struct.op* %603, i32 0, i32 3
  %604 = load i64, i64* %op_targ, align 8
  %605 = load %struct.sv**, %struct.sv*** @PL_curpad, align 8
  %arrayidx912 = getelementptr inbounds %struct.sv*, %struct.sv** %605, i64 %604
  %606 = load %struct.sv*, %struct.sv** %arrayidx912, align 8
  store %struct.sv* %606, %struct.sv** %targ, align 8
  %607 = load %struct.sv*, %struct.sv** %targ, align 8
  %608 = load i32, i32* %iters, align 4
  %conv913 = sext i32 %608 to i64
  call void @Perl_sv_setiv(%struct.sv* %607, i64 %conv913)
  %609 = load %struct.sv*, %struct.sv** %targ, align 8
  %sv_flags914 = getelementptr inbounds %struct.sv, %struct.sv* %609, i32 0, i32 2
  %610 = load i32, i32* %sv_flags914, align 4
  %and915 = and i32 %610, 16384
  %tobool916 = icmp ne i32 %and915, 0
  br i1 %tobool916, label %if.then.917, label %if.end.919

if.then.917:                                      ; preds = %if.end.911
  %611 = load %struct.sv*, %struct.sv** %targ, align 8
  %call918 = call i32 @Perl_mg_set(%struct.sv* %611)
  br label %if.end.919

if.end.919:                                       ; preds = %if.then.917, %if.end.911
  %612 = load %struct.sv*, %struct.sv** %targ, align 8
  %613 = load %struct.sv**, %struct.sv*** %sp, align 8
  %incdec.ptr921 = getelementptr inbounds %struct.sv*, %struct.sv** %613, i32 1
  store %struct.sv** %incdec.ptr921, %struct.sv*** %sp, align 8
  store %struct.sv* %612, %struct.sv** %incdec.ptr921, align 8
  store %struct.sv* %612, %struct.sv** %tmp920
  %614 = load %struct.sv*, %struct.sv** %tmp920
  %615 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %615, %struct.sv*** @PL_stack_sp, align 8
  %616 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next922 = getelementptr inbounds %struct.op, %struct.op* %616, i32 0, i32 0
  %617 = load %struct.op*, %struct.op** %op_next922, align 8
  store %struct.op* %617, %struct.op** %retval
  br label %return

return:                                           ; preds = %if.end.919, %if.then.908, %for.end.901, %if.end.863, %if.then.769, %if.then
  %618 = load %struct.op*, %struct.op** %retval
  ret %struct.op* %618
}

declare i64 @Perl_utf8_length(i8*, i8*) #1

declare %struct.gv* @Perl_gv_AVadd(%struct.gv*) #1

declare void @Perl_av_clear(%struct.av*) #1

declare void @Perl_savestack_grow() #1

declare i16** @__ctype_b_loc() #1

declare void @Perl_save_int(i32*) #1

declare i8* @Perl_utf8_hop(i8*, i32) #1

declare void @Perl_leave_scope(i32) #1

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_lock() #0 {
entry:
  %sp = alloca %struct.sv**, align 8
  %sv = alloca %struct.sv*, align 8
  %retsv = alloca %struct.sv*, align 8
  %0 = load %struct.sv**, %struct.sv*** @PL_stack_sp, align 8
  store %struct.sv** %0, %struct.sv*** %sp, align 8
  %1 = load %struct.sv**, %struct.sv*** %sp, align 8
  %2 = load %struct.sv*, %struct.sv** %1, align 8
  store %struct.sv* %2, %struct.sv** %sv, align 8
  %3 = load %struct.sv*, %struct.sv** %sv, align 8
  store %struct.sv* %3, %struct.sv** %retsv, align 8
  %4 = load void (%struct.sv*)*, void (%struct.sv*)** @PL_lockhook, align 8
  %5 = load %struct.sv*, %struct.sv** %sv, align 8
  call void %4(%struct.sv* %5)
  %6 = load %struct.sv*, %struct.sv** %retsv, align 8
  %sv_flags = getelementptr inbounds %struct.sv, %struct.sv* %6, i32 0, i32 2
  %7 = load i32, i32* %sv_flags, align 4
  %and = and i32 %7, 255
  %cmp = icmp eq i32 %and, 10
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %8 = load %struct.sv*, %struct.sv** %retsv, align 8
  %sv_flags1 = getelementptr inbounds %struct.sv, %struct.sv* %8, i32 0, i32 2
  %9 = load i32, i32* %sv_flags1, align 4
  %and2 = and i32 %9, 255
  %cmp3 = icmp eq i32 %and2, 11
  br i1 %cmp3, label %if.then, label %lor.lhs.false.4

lor.lhs.false.4:                                  ; preds = %lor.lhs.false
  %10 = load %struct.sv*, %struct.sv** %retsv, align 8
  %sv_flags5 = getelementptr inbounds %struct.sv, %struct.sv* %10, i32 0, i32 2
  %11 = load i32, i32* %sv_flags5, align 4
  %and6 = and i32 %11, 255
  %cmp7 = icmp eq i32 %and6, 12
  br i1 %cmp7, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false.4, %lor.lhs.false, %entry
  %12 = load %struct.sv*, %struct.sv** %retsv, align 8
  %call = call %struct.sv* @S_refto(%struct.sv* %12)
  store %struct.sv* %call, %struct.sv** %retsv, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false.4
  %13 = load %struct.sv*, %struct.sv** %retsv, align 8
  %14 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv* %13, %struct.sv** %14, align 8
  %15 = load %struct.sv**, %struct.sv*** %sp, align 8
  store %struct.sv** %15, %struct.sv*** @PL_stack_sp, align 8
  %16 = load %struct.op*, %struct.op** @PL_op, align 8
  %op_next = getelementptr inbounds %struct.op, %struct.op* %16, i32 0, i32 0
  %17 = load %struct.op*, %struct.op** %op_next, align 8
  ret %struct.op* %17
}

; Function Attrs: nounwind uwtable
define %struct.op* @Perl_pp_threadsv() #0 {
entry:
  %call = call %struct.op* (i8*, ...) @Perl_die(i8* getelementptr inbounds ([53 x i8], [53 x i8]* @.str.49, i32 0, i32 0))
  ret %struct.op* %call
}

declare void @Perl_vivify_defelem(%struct.sv*) #1

attributes #0 = { nounwind uwtable "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind }
attributes #3 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind readnone "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { nounwind readnone }

!llvm.ident = !{!0}

!0 = !{!"clang version 3.7.0 (tags/RELEASE_370/final)"}
