; ModuleID = './src/editfns.bc'
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.tm_zone = type opaque
%struct.emacs_globals = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8 }
%struct.buffer = type { %struct.vectorlike_header, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.buffer_text, %struct.buffer_text*, %struct.buffer*, i64, i64, i64, i64, i64, i64, %struct.buffer*, i32, i32, [50 x i8], %struct.timespec, i64, i64, i64, i64, i64, %struct.region_cache*, %struct.region_cache*, %struct.region_cache*, i8, %struct.Lisp_Overlay*, %struct.Lisp_Overlay*, i64, i64 }
%struct.vectorlike_header = type { i64 }
%struct.buffer_text = type { i8*, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.interval*, %struct.Lisp_Marker*, i8 }
%struct.interval = type { i64, i64, %struct.interval*, %struct.interval*, %union.anon, i8, i64 }
%union.anon = type { %struct.interval* }
%struct.Lisp_Marker = type { i32, %struct.buffer*, %struct.Lisp_Marker*, i64, i64 }
%struct.timespec = type { i64, i64 }
%struct.region_cache = type opaque
%struct.Lisp_Overlay = type { i32, %struct.Lisp_Overlay*, i64, i64, i64 }
%struct.Lisp_Objfwd = type { i32, i64* }
%struct.Lisp_Subr = type { %struct.vectorlike_header, %union.anon.21, i16, i16, i8*, i8*, i8* }
%union.anon.21 = type { i64 ()* }
%struct.passwd = type { i8*, i8*, i32, i32, i8*, i8*, i8* }
%struct.utsname = type { [65 x i8], [65 x i8], [65 x i8], [65 x i8], [65 x i8], [65 x i8] }
%struct.window = type { %struct.vectorlike_header, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.glyph_matrix*, %struct.glyph_matrix*, i64, i64, i64, i64, i32, i32, i32, i32, i32, i32, i32, i32, i64, i64, i64, i64, i64, i64, i64, i64, i64, i32, i32, %struct.cursor_pos, %struct.cursor_pos, %struct.cursor_pos, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i64, i32, i16, i32, i64 }
%struct.glyph_matrix = type { %struct.glyph_pool*, %struct.glyph_row*, i64, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8, %struct.buffer*, i64, i64 }
%struct.glyph_pool = type { %struct.glyph*, i64, i32, i32 }
%struct.glyph = type { i64, i64, i16, i16, i16, i16, i24, i24, %union.anon.0, %union.anon.2 }
%union.anon.0 = type { %struct.glyph_slice }
%struct.glyph_slice = type { i64 }
%union.anon.2 = type { i32 }
%struct.glyph_row = type <{ [4 x %struct.glyph*], [4 x i16], i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, %struct.display_pos, %struct.display_pos, %struct.text_pos, %struct.text_pos, i32, [11 x i8], i8, i24, i24, i32, i40, i32, %struct.XRectangle* }>
%struct.display_pos = type { %struct.text_pos, i64, %struct.text_pos, i32 }
%struct.text_pos = type { i64, i64 }
%struct.XRectangle = type { i16, i16, i16, i16 }
%struct.cursor_pos = type { i32, i32, i32, i32 }
%struct.lisp_time = type { i64, i32, i32, i32 }
%struct.rusage = type { %struct.timeval, %struct.timeval, %union.anon.6, %union.anon.7, %union.anon.8, %union.anon.9, %union.anon.10, %union.anon.11, %union.anon.12, %union.anon.13, %union.anon.14, %union.anon.15, %union.anon.16, %union.anon.17, %union.anon.18, %union.anon.19 }
%struct.timeval = type { i64, i64 }
%union.anon.6 = type { i64 }
%union.anon.7 = type { i64 }
%union.anon.8 = type { i64 }
%union.anon.9 = type { i64 }
%union.anon.10 = type { i64 }
%union.anon.11 = type { i64 }
%union.anon.12 = type { i64 }
%union.anon.13 = type { i64 }
%union.anon.14 = type { i64 }
%union.anon.15 = type { i64 }
%union.anon.16 = type { i64 }
%union.anon.17 = type { i64 }
%union.anon.18 = type { i64 }
%union.anon.19 = type { i64 }
%struct.Lisp_Cons = type { i64, %union.anon.20 }
%union.anon.20 = type { i64 }
%struct.tm = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i64, i8* }
%struct.Lisp_Char_Table = type { %struct.vectorlike_header, i64, i64, i64, i64, [64 x i64], [0 x i64] }
%struct.info = type { i64, i64, i8 }

@dump_tz_string = internal global [8 x i8] c"TZ=UtC0\00", align 1
@.str = private unnamed_addr constant [3 x i8] c"TZ\00", align 1
@wall_clock_tz = internal global %struct.tm_zone* null, align 8
@.str.1 = private unnamed_addr constant [8 x i8] c"unknown\00", align 1
@globals = external global %struct.emacs_globals, align 8
@.str.2 = private unnamed_addr constant [8 x i8] c"LOGNAME\00", align 1
@.str.3 = private unnamed_addr constant [5 x i8] c"USER\00", align 1
@.str.4 = private unnamed_addr constant [5 x i8] c"NAME\00", align 1
@.str.5 = private unnamed_addr constant [13 x i8] c"Invalid byte\00", align 1
@current_buffer = external global %struct.buffer*, align 8
@selected_window = external global i64, align 8
@.str.6 = private unnamed_addr constant [26 x i8] c"Invalid UID specification\00", align 1
@cached_system_name = internal global i64 0, align 8
@.str.7 = private unnamed_addr constant [36 x i8] c"Specified time is not representable\00", align 1
@Fcurrent_time_string.wday_name = internal constant [7 x [4 x i8]] [[4 x i8] c"Sun\00", [4 x i8] c"Mon\00", [4 x i8] c"Tue\00", [4 x i8] c"Wed\00", [4 x i8] c"Thu\00", [4 x i8] c"Fri\00", [4 x i8] c"Sat\00"], align 16
@Fcurrent_time_string.mon_name = internal constant [12 x [4 x i8]] [[4 x i8] c"Jan\00", [4 x i8] c"Feb\00", [4 x i8] c"Mar\00", [4 x i8] c"Apr\00", [4 x i8] c"May\00", [4 x i8] c"Jun\00", [4 x i8] c"Jul\00", [4 x i8] c"Aug\00", [4 x i8] c"Sep\00", [4 x i8] c"Oct\00", [4 x i8] c"Nov\00", [4 x i8] c"Dec\00"], align 16
@.str.8 = private unnamed_addr constant [28 x i8] c"%s %s%3d %02d:%02d:%02d %ld\00", align 1
@.str.9 = private unnamed_addr constant [3 x i8] c"%Z\00", align 1
@.str.10 = private unnamed_addr constant [12 x i8] c"%c%02ld%02d\00", align 1
@tzvalbuf = internal global i8* null, align 8
@emacs_setenv_TZ.tzvalbufsize = internal global i64 0, align 8
@pending_signals = external global i8, align 1
@.str.11 = private unnamed_addr constant [25 x i8] c"Selecting deleted buffer\00", align 1
@.str.12 = private unnamed_addr constant [65 x i8] c"Characters in `subst-char-in-region' have different byte-lengths\00", align 1
@.str.13 = private unnamed_addr constant [24 x i8] c"Not a translation table\00", align 1
@empty_unibyte_string = external global i64, align 8
@.str.14 = private unnamed_addr constant [3 x i8] c"OK\00", align 1
@.str.15 = private unnamed_addr constant [26 x i8] c"Wrong number of arguments\00", align 1
@.str.16 = private unnamed_addr constant [27 x i8] c"Transposed regions overlap\00", align 1
@syms_of_editfns.o_fwd = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.17 = private unnamed_addr constant [26 x i8] c"inhibit-field-text-motion\00", align 1
@syms_of_editfns.o_fwd.18 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.19 = private unnamed_addr constant [32 x i8] c"buffer-access-fontify-functions\00", align 1
@Vprin1_to_string_buffer = external global i64, align 8
@syms_of_editfns.o_fwd.20 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.21 = private unnamed_addr constant [33 x i8] c"buffer-access-fontified-property\00", align 1
@syms_of_editfns.o_fwd.22 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.23 = private unnamed_addr constant [12 x i8] c"system-name\00", align 1
@syms_of_editfns.o_fwd.24 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.25 = private unnamed_addr constant [15 x i8] c"user-full-name\00", align 1
@syms_of_editfns.o_fwd.26 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.27 = private unnamed_addr constant [16 x i8] c"user-login-name\00", align 1
@syms_of_editfns.o_fwd.28 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.29 = private unnamed_addr constant [21 x i8] c"user-real-login-name\00", align 1
@syms_of_editfns.o_fwd.30 = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.31 = private unnamed_addr constant [25 x i8] c"operating-system-release\00", align 1
@Sbuffer_string = internal global %struct.Lisp_Subr { %struct.vectorlike_header { i64 167772160 }, %union.anon.21 { i64 ()* @Fbuffer_string }, i16 0, i16 0, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.55, i32 0, i32 0), i8* null, i8* null }, align 8
@Spoint_marker = internal global %struct.Lisp_Subr { %struct.vectorlike_header { i64 167772160 }, %union.anon.21 { i64 ()* @Fpoint_marker }, i16 0, i16 0, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.57, i32 0, i32 0), i8* null, i8* null }, align 8
@Smark_marker = internal global %struct.Lisp_Subr { %struct.vectorlike_header { i64 167772160 }, %union.anon.21 { i64 ()* @Fmark_marker }, i16 0, i16 0, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.58, i32 0, i32 0), i8* null, i8* null }, align 8
@Spoint = internal global %struct.Lisp_Subr { %struct.vectorlike_header { i64 167772160 }, %union.anon.21 { i64 ()* @Fpoint }, i16 0, i16 0, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.59, i32 0, i32 0), i8* null, i8* null }, align 8
@Sregion_beginning = internal global %struct.Lisp_Subr { %struct.vectorlike_header { i64 167772160 }, %union.anon.21 { i64 ()* @Fregion_beginning }, i16 0, i16 0, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.60, i32 0, i32 0), i8* null, i8* null }, align 8
@Sregion_end = internal global %struct.Lisp_Subr { %struct.vectorlike_header { i64 167772160 }, %union.anon.21 { i64 ()* @Fregion_end }, i16 0, i16 0, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.61, i32 0, i32 0), i8* null, i8* null }, align 8
@Spoint_max = internal global %struct.Lisp_Subr { %struct.vectorlike_header { i64 167772160 }, %union.anon.21 { i64 ()* @Fpoint_max }, i16 0, i16 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.73, i32 0, i32 0), i8* null, i8* null }, align 8
@Spoint_min = internal global %struct.Lisp_Subr { %struct.vectorlike_header { i64 167772160 }, %union.anon.21 { i64 ()* @Fpoint_min }, i16 0, i16 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.74, i32 0, i32 0), i8* null, i8* null }, align 8
@Spoint_min_marker = internal global %struct.Lisp_Subr { %struct.vectorlike_header { i64 167772160 }, %union.anon.21 { i64 ()* @Fpoint_min_marker }, i16 0, i16 0, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.75, i32 0, i32 0), i8* null, i8* null }, align 8
@Spoint_max_marker = internal global %struct.Lisp_Subr { %struct.vectorlike_header { i64 167772160 }, %union.anon.21 { i64 ()* @Fpoint_max_marker }, i16 0, i16 0, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.76, i32 0, i32 0), i8* null, i8* null }, align 8
@Sgap_position = internal global %struct.Lisp_Subr { %struct.vectorlike_header { i64 167772160 }, %union.anon.21 { i64 ()* @Fgap_position }, i16 0, i16 0, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.77, i32 0, i32 0), i8* null, i8* null }, align 8
@Sgap_size = internal global %struct.Lisp_Subr { %struct.vectorlike_header { i64 167772160 }, %union.anon.21 { i64 ()* @Fgap_size }, i16 0, i16 0, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.78, i32 0, i32 0), i8* null, i8* null }, align 8
@Sbobp = internal global %struct.Lisp_Subr { %struct.vectorlike_header { i64 167772160 }, %union.anon.21 { i64 ()* @Fbobp }, i16 0, i16 0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.81, i32 0, i32 0), i8* null, i8* null }, align 8
@Seobp = internal global %struct.Lisp_Subr { %struct.vectorlike_header { i64 167772160 }, %union.anon.21 { i64 ()* @Feobp }, i16 0, i16 0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.82, i32 0, i32 0), i8* null, i8* null }, align 8
@Sbolp = internal global %struct.Lisp_Subr { %struct.vectorlike_header { i64 167772160 }, %union.anon.21 { i64 ()* @Fbolp }, i16 0, i16 0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.83, i32 0, i32 0), i8* null, i8* null }, align 8
@Seolp = internal global %struct.Lisp_Subr { %struct.vectorlike_header { i64 167772160 }, %union.anon.21 { i64 ()* @Feolp }, i16 0, i16 0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.84, i32 0, i32 0), i8* null, i8* null }, align 8
@Sfollowing_char = internal global %struct.Lisp_Subr { %struct.vectorlike_header { i64 167772160 }, %union.anon.21 { i64 ()* @Ffollowing_char }, i16 0, i16 0, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.85, i32 0, i32 0), i8* null, i8* null }, align 8
@Sprevious_char = internal global %struct.Lisp_Subr { %struct.vectorlike_header { i64 167772160 }, %union.anon.21 { i64 ()* @Fprevious_char }, i16 0, i16 0, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.86, i32 0, i32 0), i8* null, i8* null }, align 8
@Suser_real_login_name = internal global %struct.Lisp_Subr { %struct.vectorlike_header { i64 167772160 }, %union.anon.21 { i64 ()* @Fuser_real_login_name }, i16 0, i16 0, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.29, i32 0, i32 0), i8* null, i8* null }, align 8
@Suser_uid = internal global %struct.Lisp_Subr { %struct.vectorlike_header { i64 167772160 }, %union.anon.21 { i64 ()* @Fuser_uid }, i16 0, i16 0, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.96, i32 0, i32 0), i8* null, i8* null }, align 8
@Suser_real_uid = internal global %struct.Lisp_Subr { %struct.vectorlike_header { i64 167772160 }, %union.anon.21 { i64 ()* @Fuser_real_uid }, i16 0, i16 0, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.97, i32 0, i32 0), i8* null, i8* null }, align 8
@Sgroup_gid = internal global %struct.Lisp_Subr { %struct.vectorlike_header { i64 167772160 }, %union.anon.21 { i64 ()* @Fgroup_gid }, i16 0, i16 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.98, i32 0, i32 0), i8* null, i8* null }, align 8
@Sgroup_real_gid = internal global %struct.Lisp_Subr { %struct.vectorlike_header { i64 167772160 }, %union.anon.21 { i64 ()* @Fgroup_real_gid }, i16 0, i16 0, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.99, i32 0, i32 0), i8* null, i8* null }, align 8
@Semacs_pid = internal global %struct.Lisp_Subr { %struct.vectorlike_header { i64 167772160 }, %union.anon.21 { i64 ()* @Femacs_pid }, i16 0, i16 0, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.100, i32 0, i32 0), i8* null, i8* null }, align 8
@Scurrent_time = internal global %struct.Lisp_Subr { %struct.vectorlike_header { i64 167772160 }, %union.anon.21 { i64 ()* @Fcurrent_time }, i16 0, i16 0, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.101, i32 0, i32 0), i8* null, i8* null }, align 8
@Sget_internal_run_time = internal global %struct.Lisp_Subr { %struct.vectorlike_header { i64 167772160 }, %union.anon.21 { i64 ()* @Fget_internal_run_time }, i16 0, i16 0, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.105, i32 0, i32 0), i8* null, i8* null }, align 8
@Ssystem_name = internal global %struct.Lisp_Subr { %struct.vectorlike_header { i64 167772160 }, %union.anon.21 { i64 ()* @Fsystem_name }, i16 0, i16 0, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.23, i32 0, i32 0), i8* null, i8* null }, align 8
@Scurrent_message = internal global %struct.Lisp_Subr { %struct.vectorlike_header { i64 167772160 }, %union.anon.21 { i64 ()* @Fcurrent_message }, i16 0, i16 0, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.116, i32 0, i32 0), i8* null, i8* null }, align 8
@Swiden = internal global %struct.Lisp_Subr { %struct.vectorlike_header { i64 167772160 }, %union.anon.21 { i64 ()* @Fwiden }, i16 0, i16 0, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.126, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.127, i32 0, i32 0), i8* null }, align 8
@tzlookup.tzbuf_format = internal constant [19 x i8] c"XXX%s%ld:%02d:%02d\00", align 16
@local_tz = internal global %struct.tm_zone* null, align 8
@.str.32 = private unnamed_addr constant [5 x i8] c"UTC0\00", align 1
@utc_tz = internal constant %struct.tm_zone* null, align 8
@.str.33 = private unnamed_addr constant [2 x i8] c"-\00", align 1
@.str.34 = private unnamed_addr constant [32 x i8] c"Invalid time zone specification\00", align 1
@.str.35 = private unnamed_addr constant [47 x i8] c"The mark is not set now, so there is no region\00", align 1
@.str.36 = private unnamed_addr constant [27 x i8] c"Invalid time specification\00", align 1
@.str.37 = private unnamed_addr constant [49 x i8] c"Format string ends in middle of format specifier\00", align 1
@.str.38 = private unnamed_addr constant [39 x i8] c"Not enough arguments for format string\00", align 1
@.str.39 = private unnamed_addr constant [30 x i8] c"Invalid format operation %%%c\00", align 1
@.str.40 = private unnamed_addr constant [45 x i8] c"Format specifier doesn't match argument type\00", align 1
@.str.41 = private unnamed_addr constant [3 x i8] c"ld\00", align 1
@.str.42 = private unnamed_addr constant [4 x i8] c"\E2\80\98\00", align 1
@.str.43 = private unnamed_addr constant [4 x i8] c"\E2\80\99\00", align 1
@.str.44 = private unnamed_addr constant [2 x i8] c"'\00", align 1
@.str.45 = private unnamed_addr constant [2 x i8] c"`\00", align 1
@.str.46 = private unnamed_addr constant [11 x i8] c"propertize\00", align 1
@Spropertize = internal global { %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64*)* } { i64 (i64, i64*)* @Fpropertize }, i16 1, i16 -2, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.46, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.47 = private unnamed_addr constant [11 x i8] c"char-equal\00", align 1
@Schar_equal = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fchar_equal }, i16 2, i16 2, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.47, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.48 = private unnamed_addr constant [10 x i8] c"goto-char\00", align 1
@.str.49 = private unnamed_addr constant [13 x i8] c"NGoto char: \00", align 1
@Sgoto_char = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fgoto_char }, i16 1, i16 1, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.48, i32 0, i32 0), i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.49, i32 0, i32 0), i8* null }, align 8
@.str.50 = private unnamed_addr constant [15 x i8] c"string-to-char\00", align 1
@Sstring_to_char = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fstring_to_char }, i16 1, i16 1, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.50, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.51 = private unnamed_addr constant [15 x i8] c"char-to-string\00", align 1
@Schar_to_string = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fchar_to_string }, i16 1, i16 1, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.51, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.52 = private unnamed_addr constant [15 x i8] c"byte-to-string\00", align 1
@Sbyte_to_string = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fbyte_to_string }, i16 1, i16 1, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.52, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.53 = private unnamed_addr constant [17 x i8] c"buffer-substring\00", align 1
@Sbuffer_substring = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fbuffer_substring }, i16 2, i16 2, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.53, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.54 = private unnamed_addr constant [31 x i8] c"buffer-substring-no-properties\00", align 1
@Sbuffer_substring_no_properties = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fbuffer_substring_no_properties }, i16 2, i16 2, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.54, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.55 = private unnamed_addr constant [14 x i8] c"buffer-string\00", align 1
@.str.56 = private unnamed_addr constant [17 x i8] c"get-pos-property\00", align 1
@Sget_pos_property = internal global { %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64, i64)* } { i64 (i64, i64, i64)* @Fget_pos_property }, i16 2, i16 3, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.56, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.57 = private unnamed_addr constant [13 x i8] c"point-marker\00", align 1
@.str.58 = private unnamed_addr constant [12 x i8] c"mark-marker\00", align 1
@.str.59 = private unnamed_addr constant [6 x i8] c"point\00", align 1
@.str.60 = private unnamed_addr constant [17 x i8] c"region-beginning\00", align 1
@.str.61 = private unnamed_addr constant [11 x i8] c"region-end\00", align 1
@.str.62 = private unnamed_addr constant [16 x i8] c"field-beginning\00", align 1
@Sfield_beginning = internal global { %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64, i64)* } { i64 (i64, i64, i64)* @Ffield_beginning }, i16 0, i16 3, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.62, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.63 = private unnamed_addr constant [10 x i8] c"field-end\00", align 1
@Sfield_end = internal global { %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64, i64)* } { i64 (i64, i64, i64)* @Ffield_end }, i16 0, i16 3, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.63, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.64 = private unnamed_addr constant [13 x i8] c"field-string\00", align 1
@Sfield_string = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Ffield_string }, i16 0, i16 1, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.64, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.65 = private unnamed_addr constant [27 x i8] c"field-string-no-properties\00", align 1
@Sfield_string_no_properties = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Ffield_string_no_properties }, i16 0, i16 1, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.65, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.66 = private unnamed_addr constant [13 x i8] c"delete-field\00", align 1
@Sdelete_field = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fdelete_field }, i16 0, i16 1, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.66, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.67 = private unnamed_addr constant [19 x i8] c"constrain-to-field\00", align 1
@Sconstrain_to_field = internal global { %struct.vectorlike_header, { i64 (i64, i64, i64, i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64, i64, i64, i64)* } { i64 (i64, i64, i64, i64, i64)* @Fconstrain_to_field }, i16 2, i16 5, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.67, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.68 = private unnamed_addr constant [24 x i8] c"line-beginning-position\00", align 1
@Sline_beginning_position = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fline_beginning_position }, i16 0, i16 1, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.68, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.69 = private unnamed_addr constant [18 x i8] c"line-end-position\00", align 1
@Sline_end_position = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fline_end_position }, i16 0, i16 1, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.69, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.70 = private unnamed_addr constant [15 x i8] c"save-excursion\00", align 1
@Ssave_excursion = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fsave_excursion }, i16 0, i16 -1, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.70, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.71 = private unnamed_addr constant [20 x i8] c"save-current-buffer\00", align 1
@Ssave_current_buffer = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fsave_current_buffer }, i16 0, i16 -1, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.71, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.72 = private unnamed_addr constant [12 x i8] c"buffer-size\00", align 1
@Sbuffer_size = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fbuffer_size }, i16 0, i16 1, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.72, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.73 = private unnamed_addr constant [10 x i8] c"point-max\00", align 1
@.str.74 = private unnamed_addr constant [10 x i8] c"point-min\00", align 1
@.str.75 = private unnamed_addr constant [17 x i8] c"point-min-marker\00", align 1
@.str.76 = private unnamed_addr constant [17 x i8] c"point-max-marker\00", align 1
@.str.77 = private unnamed_addr constant [13 x i8] c"gap-position\00", align 1
@.str.78 = private unnamed_addr constant [9 x i8] c"gap-size\00", align 1
@.str.79 = private unnamed_addr constant [15 x i8] c"position-bytes\00", align 1
@Sposition_bytes = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fposition_bytes }, i16 1, i16 1, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.79, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.80 = private unnamed_addr constant [17 x i8] c"byte-to-position\00", align 1
@Sbyte_to_position = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fbyte_to_position }, i16 1, i16 1, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.80, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.81 = private unnamed_addr constant [5 x i8] c"bobp\00", align 1
@.str.82 = private unnamed_addr constant [5 x i8] c"eobp\00", align 1
@.str.83 = private unnamed_addr constant [5 x i8] c"bolp\00", align 1
@.str.84 = private unnamed_addr constant [5 x i8] c"eolp\00", align 1
@.str.85 = private unnamed_addr constant [15 x i8] c"following-char\00", align 1
@.str.86 = private unnamed_addr constant [15 x i8] c"preceding-char\00", align 1
@.str.87 = private unnamed_addr constant [11 x i8] c"char-after\00", align 1
@Schar_after = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fchar_after }, i16 0, i16 1, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.87, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.88 = private unnamed_addr constant [12 x i8] c"char-before\00", align 1
@Schar_before = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fchar_before }, i16 0, i16 1, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.88, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.89 = private unnamed_addr constant [7 x i8] c"insert\00", align 1
@Sinsert = internal global { %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64*)* } { i64 (i64, i64*)* @Finsert }, i16 0, i16 -2, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.89, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.90 = private unnamed_addr constant [22 x i8] c"insert-before-markers\00", align 1
@Sinsert_before_markers = internal global { %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64*)* } { i64 (i64, i64*)* @Finsert_before_markers }, i16 0, i16 -2, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.90, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.91 = private unnamed_addr constant [19 x i8] c"insert-and-inherit\00", align 1
@Sinsert_and_inherit = internal global { %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64*)* } { i64 (i64, i64*)* @Finsert_and_inherit }, i16 0, i16 -2, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.91, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.92 = private unnamed_addr constant [34 x i8] c"insert-before-markers-and-inherit\00", align 1
@Sinsert_and_inherit_before_markers = internal global { %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64*)* } { i64 (i64, i64*)* @Finsert_and_inherit_before_markers }, i16 0, i16 -2, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.92, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.93 = private unnamed_addr constant [12 x i8] c"insert-char\00", align 1
@.str.94 = private unnamed_addr constant [141 x i8] c"(list (read-char-by-name \22Insert character (Unicode name or hex): \22)              (prefix-numeric-value current-prefix-arg)              t))\00", align 1
@Sinsert_char = internal global { %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64, i64)* } { i64 (i64, i64, i64)* @Finsert_char }, i16 1, i16 3, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.93, i32 0, i32 0), i8* getelementptr inbounds ([141 x i8], [141 x i8]* @.str.94, i32 0, i32 0), i8* null }, align 8
@.str.95 = private unnamed_addr constant [12 x i8] c"insert-byte\00", align 1
@Sinsert_byte = internal global { %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64, i64)* } { i64 (i64, i64, i64)* @Finsert_byte }, i16 2, i16 3, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.95, i32 0, i32 0), i8* null, i8* null }, align 8
@Suser_login_name = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fuser_login_name }, i16 0, i16 1, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.27, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.96 = private unnamed_addr constant [9 x i8] c"user-uid\00", align 1
@.str.97 = private unnamed_addr constant [14 x i8] c"user-real-uid\00", align 1
@.str.98 = private unnamed_addr constant [10 x i8] c"group-gid\00", align 1
@.str.99 = private unnamed_addr constant [15 x i8] c"group-real-gid\00", align 1
@Suser_full_name = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fuser_full_name }, i16 0, i16 1, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.25, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.100 = private unnamed_addr constant [10 x i8] c"emacs-pid\00", align 1
@.str.101 = private unnamed_addr constant [13 x i8] c"current-time\00", align 1
@.str.102 = private unnamed_addr constant [9 x i8] c"time-add\00", align 1
@Stime_add = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Ftime_add }, i16 2, i16 2, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.102, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.103 = private unnamed_addr constant [14 x i8] c"time-subtract\00", align 1
@Stime_subtract = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Ftime_subtract }, i16 2, i16 2, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.103, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.104 = private unnamed_addr constant [12 x i8] c"time-less-p\00", align 1
@Stime_less_p = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Ftime_less_p }, i16 2, i16 2, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.104, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.105 = private unnamed_addr constant [22 x i8] c"get-internal-run-time\00", align 1
@.str.106 = private unnamed_addr constant [19 x i8] c"format-time-string\00", align 1
@Sformat_time_string = internal global { %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64, i64)* } { i64 (i64, i64, i64)* @Fformat_time_string }, i16 1, i16 3, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.106, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.107 = private unnamed_addr constant [11 x i8] c"float-time\00", align 1
@Sfloat_time = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Ffloat_time }, i16 0, i16 1, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.107, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.108 = private unnamed_addr constant [12 x i8] c"decode-time\00", align 1
@Sdecode_time = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fdecode_time }, i16 0, i16 2, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.108, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.109 = private unnamed_addr constant [12 x i8] c"encode-time\00", align 1
@Sencode_time = internal global { %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64*)* } { i64 (i64, i64*)* @Fencode_time }, i16 6, i16 -2, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.109, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.110 = private unnamed_addr constant [20 x i8] c"current-time-string\00", align 1
@Scurrent_time_string = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fcurrent_time_string }, i16 0, i16 2, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.110, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.111 = private unnamed_addr constant [18 x i8] c"current-time-zone\00", align 1
@Scurrent_time_zone = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fcurrent_time_zone }, i16 0, i16 2, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.111, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.112 = private unnamed_addr constant [19 x i8] c"set-time-zone-rule\00", align 1
@Sset_time_zone_rule = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fset_time_zone_rule }, i16 1, i16 1, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.112, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.113 = private unnamed_addr constant [8 x i8] c"message\00", align 1
@Smessage = internal global { %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64*)* } { i64 (i64, i64*)* @Fmessage }, i16 1, i16 -2, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.113, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.114 = private unnamed_addr constant [12 x i8] c"message-box\00", align 1
@Smessage_box = internal global { %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64*)* } { i64 (i64, i64*)* @Fmessage_box }, i16 1, i16 -2, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.114, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.115 = private unnamed_addr constant [15 x i8] c"message-or-box\00", align 1
@Smessage_or_box = internal global { %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64*)* } { i64 (i64, i64*)* @Fmessage_or_box }, i16 1, i16 -2, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.115, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.116 = private unnamed_addr constant [16 x i8] c"current-message\00", align 1
@.str.117 = private unnamed_addr constant [7 x i8] c"format\00", align 1
@Sformat = internal global { %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64*)* } { i64 (i64, i64*)* @Fformat }, i16 1, i16 -2, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.117, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.118 = private unnamed_addr constant [15 x i8] c"format-message\00", align 1
@Sformat_message = internal global { %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64*)* } { i64 (i64, i64*)* @Fformat_message }, i16 1, i16 -2, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.118, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.119 = private unnamed_addr constant [24 x i8] c"insert-buffer-substring\00", align 1
@Sinsert_buffer_substring = internal global { %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64, i64)* } { i64 (i64, i64, i64)* @Finsert_buffer_substring }, i16 1, i16 3, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.119, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.120 = private unnamed_addr constant [26 x i8] c"compare-buffer-substrings\00", align 1
@Scompare_buffer_substrings = internal global { %struct.vectorlike_header, { i64 (i64, i64, i64, i64, i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64, i64, i64, i64, i64)* } { i64 (i64, i64, i64, i64, i64, i64)* @Fcompare_buffer_substrings }, i16 6, i16 6, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.120, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.121 = private unnamed_addr constant [21 x i8] c"subst-char-in-region\00", align 1
@Ssubst_char_in_region = internal global { %struct.vectorlike_header, { i64 (i64, i64, i64, i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64, i64, i64, i64)* } { i64 (i64, i64, i64, i64, i64)* @Fsubst_char_in_region }, i16 4, i16 5, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.121, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.122 = private unnamed_addr constant [26 x i8] c"translate-region-internal\00", align 1
@Stranslate_region_internal = internal global { %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64, i64)* } { i64 (i64, i64, i64)* @Ftranslate_region_internal }, i16 3, i16 3, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.122, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.123 = private unnamed_addr constant [14 x i8] c"delete-region\00", align 1
@.str.124 = private unnamed_addr constant [2 x i8] c"r\00", align 1
@Sdelete_region = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fdelete_region }, i16 2, i16 2, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.123, i32 0, i32 0), i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.124, i32 0, i32 0), i8* null }, align 8
@.str.125 = private unnamed_addr constant [26 x i8] c"delete-and-extract-region\00", align 1
@Sdelete_and_extract_region = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fdelete_and_extract_region }, i16 2, i16 2, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.125, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.126 = private unnamed_addr constant [6 x i8] c"widen\00", align 1
@.str.127 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.128 = private unnamed_addr constant [17 x i8] c"narrow-to-region\00", align 1
@Snarrow_to_region = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fnarrow_to_region }, i16 2, i16 2, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.128, i32 0, i32 0), i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.124, i32 0, i32 0), i8* null }, align 8
@.str.129 = private unnamed_addr constant [17 x i8] c"save-restriction\00", align 1
@Ssave_restriction = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fsave_restriction }, i16 0, i16 -1, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.129, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.130 = private unnamed_addr constant [18 x i8] c"transpose-regions\00", align 1
@Stranspose_regions = internal global { %struct.vectorlike_header, { i64 (i64, i64, i64, i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64, i64, i64, i64)* } { i64 (i64, i64, i64, i64, i64)* @Ftranspose_regions }, i16 4, i16 5, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.130, i32 0, i32 0), i8* null, i8* null }, align 8

; Function Attrs: nounwind uwtable
define void @init_editfns(i1 zeroext %dumping) #0 {
entry:
  %dumping.addr = alloca i8, align 1
  %user_name = alloca i8*, align 8
  %p = alloca i8*, align 8
  %pw = alloca %struct.passwd*, align 8
  %tem = alloca i64, align 8
  %tz = alloca i8*, align 8
  %euid = alloca i32, align 4
  %uts = alloca %struct.utsname, align 1
  %frombool = zext i1 %dumping to i8
  store i8 %frombool, i8* %dumping.addr, align 1
  call void @init_and_cache_system_name()
  %0 = load i8, i8* %dumping.addr, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @xputenv(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @dump_tz_string, i32 0, i32 0))
  call void @tzset() #5
  br label %return

if.end:                                           ; preds = %entry
  %call = call i8* @getenv(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str, i32 0, i32 0)) #5
  store i8* %call, i8** %tz, align 8
  %1 = load i8*, i8** %tz, align 8
  %tobool1 = icmp ne i8* %1, null
  br i1 %tobool1, label %land.lhs.true, label %if.end.4

land.lhs.true:                                    ; preds = %if.end
  %2 = load i8*, i8** %tz, align 8
  %call2 = call i32 @strcmp(i8* %2, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @dump_tz_string, i32 0, i64 3)) #8
  %cmp = icmp eq i32 %call2, 0
  br i1 %cmp, label %if.then.3, label %if.end.4

if.then.3:                                        ; preds = %land.lhs.true
  %3 = load i8*, i8** %tz, align 8
  %4 = load i8, i8* %3, align 1
  %inc = add i8 %4, 1
  store i8 %inc, i8* %3, align 1
  call void @tzset() #5
  %5 = load i8*, i8** %tz, align 8
  %6 = load i8, i8* %5, align 1
  %dec = add i8 %6, -1
  store i8 %dec, i8* %5, align 1
  br label %if.end.4

if.end.4:                                         ; preds = %if.then.3, %land.lhs.true, %if.end
  %call5 = call %struct.tm_zone* @xtzalloc(i8* null)
  store %struct.tm_zone* %call5, %struct.tm_zone** @wall_clock_tz, align 8
  %7 = load i8*, i8** %tz, align 8
  %tobool6 = icmp ne i8* %7, null
  br i1 %tobool6, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.4
  %8 = load i8*, i8** %tz, align 8
  %call7 = call i64 @build_string(i8* %8)
  br label %cond.end

cond.false:                                       ; preds = %if.end.4
  %call8 = call i64 @builtin_lisp_symbol(i32 1011)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call7, %cond.true ], [ %call8, %cond.false ]
  %call9 = call %struct.tm_zone* @tzlookup(i64 %cond, i1 zeroext true)
  %call10 = call i32 @getuid() #5
  %call11 = call %struct.passwd* @getpwuid(i32 %call10)
  store %struct.passwd* %call11, %struct.passwd** %pw, align 8
  %9 = load %struct.passwd*, %struct.passwd** %pw, align 8
  %tobool12 = icmp ne %struct.passwd* %9, null
  br i1 %tobool12, label %cond.true.13, label %cond.false.14

cond.true.13:                                     ; preds = %cond.end
  %10 = load %struct.passwd*, %struct.passwd** %pw, align 8
  %pw_name = getelementptr inbounds %struct.passwd, %struct.passwd* %10, i32 0, i32 0
  %11 = load i8*, i8** %pw_name, align 8
  br label %cond.end.15

cond.false.14:                                    ; preds = %cond.end
  br label %cond.end.15

cond.end.15:                                      ; preds = %cond.false.14, %cond.true.13
  %cond16 = phi i8* [ %11, %cond.true.13 ], [ getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1, i32 0, i32 0), %cond.false.14 ]
  %call17 = call i64 @build_string(i8* %cond16)
  store i64 %call17, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 322), align 8
  %call18 = call i8* @getenv(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.2, i32 0, i32 0)) #5
  store i8* %call18, i8** %user_name, align 8
  %12 = load i8*, i8** %user_name, align 8
  %tobool19 = icmp ne i8* %12, null
  br i1 %tobool19, label %if.end.22, label %if.then.20

if.then.20:                                       ; preds = %cond.end.15
  %call21 = call i8* @getenv(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.3, i32 0, i32 0)) #5
  store i8* %call21, i8** %user_name, align 8
  br label %if.end.22

if.end.22:                                        ; preds = %if.then.20, %cond.end.15
  %13 = load i8*, i8** %user_name, align 8
  %tobool23 = icmp ne i8* %13, null
  br i1 %tobool23, label %if.end.33, label %if.then.24

if.then.24:                                       ; preds = %if.end.22
  %call25 = call i32 @geteuid() #5
  %call26 = call %struct.passwd* @getpwuid(i32 %call25)
  store %struct.passwd* %call26, %struct.passwd** %pw, align 8
  %14 = load %struct.passwd*, %struct.passwd** %pw, align 8
  %tobool27 = icmp ne %struct.passwd* %14, null
  br i1 %tobool27, label %cond.true.28, label %cond.false.30

cond.true.28:                                     ; preds = %if.then.24
  %15 = load %struct.passwd*, %struct.passwd** %pw, align 8
  %pw_name29 = getelementptr inbounds %struct.passwd, %struct.passwd* %15, i32 0, i32 0
  %16 = load i8*, i8** %pw_name29, align 8
  br label %cond.end.31

cond.false.30:                                    ; preds = %if.then.24
  br label %cond.end.31

cond.end.31:                                      ; preds = %cond.false.30, %cond.true.28
  %cond32 = phi i8* [ %16, %cond.true.28 ], [ getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1, i32 0, i32 0), %cond.false.30 ]
  store i8* %cond32, i8** %user_name, align 8
  br label %if.end.33

if.end.33:                                        ; preds = %cond.end.31, %if.end.22
  %17 = load i8*, i8** %user_name, align 8
  %call34 = call i64 @build_string(i8* %17)
  store i64 %call34, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 321), align 8
  %18 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 321), align 8
  %19 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 322), align 8
  %call35 = call i64 @Fstring_equal(i64 %18, i64 %19)
  store i64 %call35, i64* %tem, align 8
  %20 = load i64, i64* %tem, align 8
  %call36 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp37 = icmp eq i64 %20, %call36
  br i1 %cmp37, label %if.else, label %if.then.38

if.then.38:                                       ; preds = %if.end.33
  %21 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 321), align 8
  store i64 %21, i64* %tem, align 8
  br label %if.end.54

if.else:                                          ; preds = %if.end.33
  %call39 = call i32 @geteuid() #5
  store i32 %call39, i32* %euid, align 4
  %22 = load i32, i32* %euid, align 4
  %cmp40 = icmp ule i32 0, %22
  br i1 %cmp40, label %land.lhs.true.43, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else
  %23 = load i32, i32* %euid, align 4
  %conv = zext i32 %23 to i64
  %cmp41 = icmp sle i64 -2305843009213693952, %conv
  br i1 %cmp41, label %land.lhs.true.43, label %cond.true.47

land.lhs.true.43:                                 ; preds = %lor.lhs.false, %if.else
  %24 = load i32, i32* %euid, align 4
  %conv44 = zext i32 %24 to i64
  %cmp45 = icmp sle i64 %conv44, 2305843009213693951
  br i1 %cmp45, label %cond.false.50, label %cond.true.47

cond.true.47:                                     ; preds = %land.lhs.true.43, %lor.lhs.false
  %25 = load i32, i32* %euid, align 4
  %conv48 = uitofp i32 %25 to double
  %call49 = call i64 @make_float(double %conv48)
  br label %cond.end.52

cond.false.50:                                    ; preds = %land.lhs.true.43
  %26 = load i32, i32* %euid, align 4
  %conv51 = zext i32 %26 to i64
  %shl = shl i64 %conv51, 2
  %add = add i64 %shl, 2
  br label %cond.end.52

cond.end.52:                                      ; preds = %cond.false.50, %cond.true.47
  %cond53 = phi i64 [ %call49, %cond.true.47 ], [ %add, %cond.false.50 ]
  store i64 %cond53, i64* %tem, align 8
  br label %if.end.54

if.end.54:                                        ; preds = %cond.end.52, %if.then.38
  %27 = load i64, i64* %tem, align 8
  %call55 = call i64 @Fuser_full_name(i64 %27)
  store i64 %call55, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 319), align 8
  %call56 = call i8* @getenv(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.4, i32 0, i32 0)) #5
  store i8* %call56, i8** %p, align 8
  %28 = load i8*, i8** %p, align 8
  %tobool57 = icmp ne i8* %28, null
  br i1 %tobool57, label %if.then.58, label %if.else.60

if.then.58:                                       ; preds = %if.end.54
  %29 = load i8*, i8** %p, align 8
  %call59 = call i64 @build_string(i8* %29)
  store i64 %call59, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 319), align 8
  br label %if.end.67

if.else.60:                                       ; preds = %if.end.54
  %30 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 319), align 8
  %call61 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp62 = icmp eq i64 %30, %call61
  br i1 %cmp62, label %if.then.64, label %if.end.66

if.then.64:                                       ; preds = %if.else.60
  %call65 = call i64 @build_string(i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.1, i32 0, i32 0))
  store i64 %call65, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 319), align 8
  br label %if.end.66

if.end.66:                                        ; preds = %if.then.64, %if.else.60
  br label %if.end.67

if.end.67:                                        ; preds = %if.end.66, %if.then.58
  %call68 = call i32 @uname(%struct.utsname* %uts) #5
  %release = getelementptr inbounds %struct.utsname, %struct.utsname* %uts, i32 0, i32 2
  %arraydecay = getelementptr inbounds [65 x i8], [65 x i8]* %release, i32 0, i32 0
  %call69 = call i64 @build_string(i8* %arraydecay)
  store i64 %call69, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 209), align 8
  br label %return

return:                                           ; preds = %if.end.67, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @init_and_cache_system_name() #0 {
entry:
  call void @init_system_name()
  %0 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 285), align 8
  store i64 %0, i64* @cached_system_name, align 8
  ret void
}

declare void @xputenv(i8*) #1

; Function Attrs: nounwind
declare void @tzset() #2

; Function Attrs: nounwind
declare i8* @getenv(i8*) #2

; Function Attrs: nounwind readonly
declare i32 @strcmp(i8*, i8*) #3

; Function Attrs: nounwind uwtable
define internal %struct.tm_zone* @xtzalloc(i8* %name) #0 {
entry:
  %name.addr = alloca i8*, align 8
  %tz = alloca %struct.tm_zone*, align 8
  store i8* %name, i8** %name.addr, align 8
  %0 = load i8*, i8** %name.addr, align 8
  %call = call %struct.tm_zone* @tzalloc(i8* %0)
  store %struct.tm_zone* %call, %struct.tm_zone** %tz, align 8
  %1 = load %struct.tm_zone*, %struct.tm_zone** %tz, align 8
  %tobool = icmp ne %struct.tm_zone* %1, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call void @memory_full(i64 -1) #9
  unreachable

if.end:                                           ; preds = %entry
  %2 = load %struct.tm_zone*, %struct.tm_zone** %tz, align 8
  ret %struct.tm_zone* %2
}

; Function Attrs: nounwind uwtable
define internal %struct.tm_zone* @tzlookup(i64 %zone, i1 zeroext %settz) #0 {
entry:
  %retval = alloca %struct.tm_zone*, align 8
  %zone.addr = alloca i64, align 8
  %settz.addr = alloca i8, align 1
  %tzbuf = alloca [39 x i8], align 16
  %zone_string = alloca i8*, align 8
  %new_tz = alloca %struct.tm_zone*, align 8
  %abszone = alloca i64, align 8
  %hour = alloca i64, align 8
  %min = alloca i32, align 4
  %sec = alloca i32, align 4
  %old_tz = alloca %struct.tm_zone*, align 8
  store i64 %zone, i64* %zone.addr, align 8
  %frombool = zext i1 %settz to i8
  store i8 %frombool, i8* %settz.addr, align 1
  %0 = load i64, i64* %zone.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %0, %call
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load %struct.tm_zone*, %struct.tm_zone** @local_tz, align 8
  store %struct.tm_zone* %1, %struct.tm_zone** %retval
  br label %return

if.else:                                          ; preds = %entry
  %2 = load i64, i64* %zone.addr, align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp2 = icmp eq i64 %2, %call1
  br i1 %cmp2, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %if.else
  store i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.32, i32 0, i32 0), i8** %zone_string, align 8
  %3 = load %struct.tm_zone*, %struct.tm_zone** @utc_tz, align 8
  store %struct.tm_zone* %3, %struct.tm_zone** %new_tz, align 8
  br label %if.end.36

if.else.4:                                        ; preds = %if.else
  %4 = load i64, i64* %zone.addr, align 8
  %call5 = call i64 @builtin_lisp_symbol(i32 1011)
  %cmp6 = icmp eq i64 %4, %call5
  br i1 %cmp6, label %if.then.7, label %if.else.8

if.then.7:                                        ; preds = %if.else.4
  store i8* null, i8** %zone_string, align 8
  br label %if.end.34

if.else.8:                                        ; preds = %if.else.4
  %5 = load i64, i64* %zone.addr, align 8
  %call9 = call zeroext i1 @STRINGP(i64 %5)
  br i1 %call9, label %if.then.10, label %if.else.12

if.then.10:                                       ; preds = %if.else.8
  %6 = load i64, i64* %zone.addr, align 8
  %call11 = call i8* @SSDATA(i64 %6)
  store i8* %call11, i8** %zone_string, align 8
  br label %if.end.33

if.else.12:                                       ; preds = %if.else.8
  %7 = load i64, i64* %zone.addr, align 8
  %and = and i64 %7, 7
  %conv = trunc i64 %and to i32
  %and13 = and i32 %conv, -5
  %cmp14 = icmp eq i32 %and13, 2
  br i1 %cmp14, label %if.then.16, label %if.else.30

if.then.16:                                       ; preds = %if.else.12
  %8 = load i64, i64* %zone.addr, align 8
  %shr = ashr i64 %8, 2
  %cmp17 = icmp slt i64 %shr, 0
  br i1 %cmp17, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.16
  %9 = load i64, i64* %zone.addr, align 8
  %shr19 = ashr i64 %9, 2
  %sub = sub nsw i64 0, %shr19
  br label %cond.end

cond.false:                                       ; preds = %if.then.16
  %10 = load i64, i64* %zone.addr, align 8
  %shr20 = ashr i64 %10, 2
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %sub, %cond.true ], [ %shr20, %cond.false ]
  store i64 %cond, i64* %abszone, align 8
  %11 = load i64, i64* %abszone, align 8
  %div = sdiv i64 %11, 3600
  store i64 %div, i64* %hour, align 8
  %12 = load i64, i64* %abszone, align 8
  %div21 = sdiv i64 %12, 60
  %rem = srem i64 %div21, 60
  %conv22 = trunc i64 %rem to i32
  store i32 %conv22, i32* %min, align 4
  %13 = load i64, i64* %abszone, align 8
  %rem23 = srem i64 %13, 60
  %conv24 = trunc i64 %rem23 to i32
  store i32 %conv24, i32* %sec, align 4
  %arraydecay = getelementptr inbounds [39 x i8], [39 x i8]* %tzbuf, i32 0, i32 0
  %14 = load i64, i64* %zone.addr, align 8
  %shr25 = ashr i64 %14, 2
  %cmp26 = icmp slt i64 %shr25, 0
  %conv27 = zext i1 %cmp26 to i32
  %idxprom = sext i32 %conv27 to i64
  %arrayidx = getelementptr inbounds [2 x i8], [2 x i8]* @.str.33, i32 0, i64 %idxprom
  %15 = load i64, i64* %hour, align 8
  %16 = load i32, i32* %min, align 4
  %17 = load i32, i32* %sec, align 4
  %call28 = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @tzlookup.tzbuf_format, i32 0, i32 0), i8* %arrayidx, i64 %15, i32 %16, i32 %17) #5
  %arraydecay29 = getelementptr inbounds [39 x i8], [39 x i8]* %tzbuf, i32 0, i32 0
  store i8* %arraydecay29, i8** %zone_string, align 8
  br label %if.end

if.else.30:                                       ; preds = %if.else.12
  %call31 = call i64 @builtin_lisp_symbol(i32 372)
  %call32 = call i64 @build_string(i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.34, i32 0, i32 0))
  %18 = load i64, i64* %zone.addr, align 8
  call void @xsignal2(i64 %call31, i64 %call32, i64 %18) #9
  unreachable

if.end:                                           ; preds = %cond.end
  br label %if.end.33

if.end.33:                                        ; preds = %if.end, %if.then.10
  br label %if.end.34

if.end.34:                                        ; preds = %if.end.33, %if.then.7
  %19 = load i8*, i8** %zone_string, align 8
  %call35 = call %struct.tm_zone* @xtzalloc(i8* %19)
  store %struct.tm_zone* %call35, %struct.tm_zone** %new_tz, align 8
  br label %if.end.36

if.end.36:                                        ; preds = %if.end.34, %if.then.3
  br label %if.end.37

if.end.37:                                        ; preds = %if.end.36
  %20 = load i8, i8* %settz.addr, align 1
  %tobool = trunc i8 %20 to i1
  br i1 %tobool, label %if.then.38, label %if.end.40

if.then.38:                                       ; preds = %if.end.37
  call void @block_input()
  %21 = load i8*, i8** %zone_string, align 8
  %call39 = call i32 @emacs_setenv_TZ(i8* %21)
  %22 = load %struct.tm_zone*, %struct.tm_zone** @local_tz, align 8
  store %struct.tm_zone* %22, %struct.tm_zone** %old_tz, align 8
  %23 = load %struct.tm_zone*, %struct.tm_zone** %new_tz, align 8
  store %struct.tm_zone* %23, %struct.tm_zone** @local_tz, align 8
  %24 = load %struct.tm_zone*, %struct.tm_zone** %old_tz, align 8
  call void @tzfree(%struct.tm_zone* %24)
  call void @unblock_input()
  br label %if.end.40

if.end.40:                                        ; preds = %if.then.38, %if.end.37
  %25 = load %struct.tm_zone*, %struct.tm_zone** %new_tz, align 8
  store %struct.tm_zone* %25, %struct.tm_zone** %retval
  br label %return

return:                                           ; preds = %if.end.40, %if.then
  %26 = load %struct.tm_zone*, %struct.tm_zone** %retval
  ret %struct.tm_zone* %26
}

declare i64 @build_string(i8*) #1

declare i64 @builtin_lisp_symbol(i32) #1

declare %struct.passwd* @getpwuid(i32) #1

; Function Attrs: nounwind
declare i32 @getuid() #2

; Function Attrs: nounwind
declare i32 @geteuid() #2

declare i64 @Fstring_equal(i64, i64) #1

declare i64 @make_float(double) #1

; Function Attrs: nounwind uwtable
define i64 @Fuser_full_name(i64 %uid) #0 {
entry:
  %retval = alloca i64, align 8
  %uid.addr = alloca i64, align 8
  %pw = alloca %struct.passwd*, align 8
  %p = alloca i8*, align 8
  %q = alloca i8*, align 8
  %full = alloca i64, align 8
  %u = alloca i32, align 4
  %login = alloca i64, align 8
  %sa_avail = alloca i64, align 8
  %sa_count = alloca i64, align 8
  %sa_must_free = alloca i8, align 1
  %r = alloca i8*, align 8
  %s = alloca i8*, align 8
  store i64 %uid, i64* %uid.addr, align 8
  %0 = load i64, i64* %uid.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %0, %call
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 319), align 8
  store i64 %1, i64* %retval
  br label %return

if.else:                                          ; preds = %entry
  %2 = load i64, i64* %uid.addr, align 8
  %call1 = call zeroext i1 @NUMBERP(i64 %2)
  br i1 %call1, label %if.then.2, label %if.else.5

if.then.2:                                        ; preds = %if.else
  %3 = load i64, i64* %uid.addr, align 8
  %call3 = call i64 @cons_to_unsigned(i64 %3, i64 4294967295)
  %conv = trunc i64 %call3 to i32
  store i32 %conv, i32* %u, align 4
  call void @block_input()
  %4 = load i32, i32* %u, align 4
  %call4 = call %struct.passwd* @getpwuid(i32 %4)
  store %struct.passwd* %call4, %struct.passwd** %pw, align 8
  call void @unblock_input()
  br label %if.end.11

if.else.5:                                        ; preds = %if.else
  %5 = load i64, i64* %uid.addr, align 8
  %call6 = call zeroext i1 @STRINGP(i64 %5)
  br i1 %call6, label %if.then.7, label %if.else.10

if.then.7:                                        ; preds = %if.else.5
  call void @block_input()
  %6 = load i64, i64* %uid.addr, align 8
  %call8 = call i8* @SSDATA(i64 %6)
  %call9 = call %struct.passwd* @getpwnam(i8* %call8)
  store %struct.passwd* %call9, %struct.passwd** %pw, align 8
  call void @unblock_input()
  br label %if.end

if.else.10:                                       ; preds = %if.else.5
  call void (i8*, ...) @error(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.6, i32 0, i32 0)) #9
  unreachable

if.end:                                           ; preds = %if.then.7
  br label %if.end.11

if.end.11:                                        ; preds = %if.end, %if.then.2
  br label %if.end.12

if.end.12:                                        ; preds = %if.end.11
  %7 = load %struct.passwd*, %struct.passwd** %pw, align 8
  %tobool = icmp ne %struct.passwd* %7, null
  br i1 %tobool, label %if.end.15, label %if.then.13

if.then.13:                                       ; preds = %if.end.12
  %call14 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call14, i64* %retval
  br label %return

if.end.15:                                        ; preds = %if.end.12
  %8 = load %struct.passwd*, %struct.passwd** %pw, align 8
  %pw_gecos = getelementptr inbounds %struct.passwd, %struct.passwd* %8, i32 0, i32 4
  %9 = load i8*, i8** %pw_gecos, align 8
  store i8* %9, i8** %p, align 8
  %10 = load i8*, i8** %p, align 8
  %call16 = call i8* @strchr(i8* %10, i32 44) #8
  store i8* %call16, i8** %q, align 8
  %11 = load i8*, i8** %p, align 8
  %12 = load i8*, i8** %q, align 8
  %tobool17 = icmp ne i8* %12, null
  br i1 %tobool17, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.15
  %13 = load i8*, i8** %q, align 8
  %14 = load i8*, i8** %p, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %13 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %14 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  br label %cond.end

cond.false:                                       ; preds = %if.end.15
  %15 = load i8*, i8** %p, align 8
  %call18 = call i64 @strlen(i8* %15) #8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %sub.ptr.sub, %cond.true ], [ %call18, %cond.false ]
  %call19 = call i64 @make_string(i8* %11, i64 %cond)
  store i64 %call19, i64* %full, align 8
  %16 = load i64, i64* %full, align 8
  %call20 = call i8* @SSDATA(i64 %16)
  store i8* %call20, i8** %p, align 8
  %17 = load i8*, i8** %p, align 8
  %call21 = call i8* @strchr(i8* %17, i32 38) #8
  store i8* %call21, i8** %q, align 8
  %18 = load i8*, i8** %q, align 8
  %tobool22 = icmp ne i8* %18, null
  br i1 %tobool22, label %if.then.23, label %if.end.75

if.then.23:                                       ; preds = %cond.end
  %19 = load %struct.passwd*, %struct.passwd** %pw, align 8
  %pw_uid = getelementptr inbounds %struct.passwd, %struct.passwd* %19, i32 0, i32 2
  %20 = load i32, i32* %pw_uid, align 4
  %conv24 = zext i32 %20 to i64
  %shl = shl i64 %conv24, 2
  %add = add i64 %shl, 2
  %call25 = call i64 @Fuser_login_name(i64 %add)
  store i64 %call25, i64* %login, align 8
  store i64 16384, i64* %sa_avail, align 8
  %call26 = call i64 @SPECPDL_INDEX()
  store i64 %call26, i64* %sa_count, align 8
  store i8 0, i8* %sa_must_free, align 1
  %21 = load i8*, i8** %p, align 8
  %call27 = call i64 @strlen(i8* %21) #8
  %22 = load i64, i64* %login, align 8
  %call28 = call i64 @SBYTES(i64 %22)
  %add29 = add i64 %call27, %call28
  %add30 = add i64 %add29, 1
  %23 = load i64, i64* %sa_avail, align 8
  %cmp31 = icmp ule i64 %add30, %23
  br i1 %cmp31, label %cond.true.33, label %cond.false.42

cond.true.33:                                     ; preds = %if.then.23
  %24 = load i8*, i8** %p, align 8
  %call34 = call i64 @strlen(i8* %24) #8
  %25 = load i64, i64* %login, align 8
  %call35 = call i64 @SBYTES(i64 %25)
  %add36 = add i64 %call34, %call35
  %add37 = add i64 %add36, 1
  %26 = load i64, i64* %sa_avail, align 8
  %sub = sub i64 %26, %add37
  store i64 %sub, i64* %sa_avail, align 8
  %27 = load i8*, i8** %p, align 8
  %call38 = call i64 @strlen(i8* %27) #8
  %28 = load i64, i64* %login, align 8
  %call39 = call i64 @SBYTES(i64 %28)
  %add40 = add i64 %call38, %call39
  %add41 = add i64 %add40, 1
  %29 = alloca i8, i64 %add41
  br label %cond.end.48

cond.false.42:                                    ; preds = %if.then.23
  store i8 1, i8* %sa_must_free, align 1
  %30 = load i8*, i8** %p, align 8
  %call43 = call i64 @strlen(i8* %30) #8
  %31 = load i64, i64* %login, align 8
  %call44 = call i64 @SBYTES(i64 %31)
  %add45 = add i64 %call43, %call44
  %add46 = add i64 %add45, 1
  %call47 = call i8* @record_xmalloc(i64 %add46)
  br label %cond.end.48

cond.end.48:                                      ; preds = %cond.false.42, %cond.true.33
  %cond49 = phi i8* [ %29, %cond.true.33 ], [ %call47, %cond.false.42 ]
  store i8* %cond49, i8** %r, align 8
  %32 = load i8*, i8** %r, align 8
  %33 = load i8*, i8** %p, align 8
  %34 = load i8*, i8** %q, align 8
  %35 = load i8*, i8** %p, align 8
  %sub.ptr.lhs.cast50 = ptrtoint i8* %34 to i64
  %sub.ptr.rhs.cast51 = ptrtoint i8* %35 to i64
  %sub.ptr.sub52 = sub i64 %sub.ptr.lhs.cast50, %sub.ptr.rhs.cast51
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %32, i8* %33, i64 %sub.ptr.sub52, i32 1, i1 false)
  %36 = load i8*, i8** %q, align 8
  %37 = load i8*, i8** %p, align 8
  %sub.ptr.lhs.cast53 = ptrtoint i8* %36 to i64
  %sub.ptr.rhs.cast54 = ptrtoint i8* %37 to i64
  %sub.ptr.sub55 = sub i64 %sub.ptr.lhs.cast53, %sub.ptr.rhs.cast54
  %38 = load i8*, i8** %r, align 8
  %arrayidx = getelementptr inbounds i8, i8* %38, i64 %sub.ptr.sub55
  %39 = load i64, i64* %login, align 8
  %call56 = call i8* @lispstpcpy(i8* %arrayidx, i64 %39)
  store i8* %call56, i8** %s, align 8
  %40 = load i8*, i8** %q, align 8
  %41 = load i8*, i8** %p, align 8
  %sub.ptr.lhs.cast57 = ptrtoint i8* %40 to i64
  %sub.ptr.rhs.cast58 = ptrtoint i8* %41 to i64
  %sub.ptr.sub59 = sub i64 %sub.ptr.lhs.cast57, %sub.ptr.rhs.cast58
  %42 = load i8*, i8** %r, align 8
  %arrayidx60 = getelementptr inbounds i8, i8* %42, i64 %sub.ptr.sub59
  %43 = load i8, i8* %arrayidx60, align 1
  %conv61 = zext i8 %43 to i32
  %call62 = call i32 @upcase(i32 %conv61)
  %conv63 = trunc i32 %call62 to i8
  %44 = load i8*, i8** %q, align 8
  %45 = load i8*, i8** %p, align 8
  %sub.ptr.lhs.cast64 = ptrtoint i8* %44 to i64
  %sub.ptr.rhs.cast65 = ptrtoint i8* %45 to i64
  %sub.ptr.sub66 = sub i64 %sub.ptr.lhs.cast64, %sub.ptr.rhs.cast65
  %46 = load i8*, i8** %r, align 8
  %arrayidx67 = getelementptr inbounds i8, i8* %46, i64 %sub.ptr.sub66
  store i8 %conv63, i8* %arrayidx67, align 1
  %47 = load i8*, i8** %s, align 8
  %48 = load i8*, i8** %q, align 8
  %add.ptr = getelementptr inbounds i8, i8* %48, i64 1
  %call68 = call i8* @strcpy(i8* %47, i8* %add.ptr) #5
  %49 = load i8*, i8** %r, align 8
  %call69 = call i64 @build_string(i8* %49)
  store i64 %call69, i64* %full, align 8
  br label %do.body

do.body:                                          ; preds = %cond.end.48
  %50 = load i8, i8* %sa_must_free, align 1
  %tobool70 = trunc i8 %50 to i1
  br i1 %tobool70, label %if.then.71, label %if.end.74

if.then.71:                                       ; preds = %do.body
  store i8 0, i8* %sa_must_free, align 1
  %51 = load i64, i64* %sa_count, align 8
  %call72 = call i64 @builtin_lisp_symbol(i32 0)
  %call73 = call i64 @unbind_to(i64 %51, i64 %call72)
  br label %if.end.74

if.end.74:                                        ; preds = %if.then.71, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end.74
  br label %if.end.75

if.end.75:                                        ; preds = %do.end, %cond.end
  %52 = load i64, i64* %full, align 8
  store i64 %52, i64* %retval
  br label %return

return:                                           ; preds = %if.end.75, %if.then.13, %if.then
  %53 = load i64, i64* %retval
  ret i64 %53
}

; Function Attrs: nounwind
declare i32 @uname(%struct.utsname*) #2

; Function Attrs: nounwind uwtable
define i64 @Fchar_to_string(i64 %character) #0 {
entry:
  %character.addr = alloca i64, align 8
  %c = alloca i32, align 4
  %len = alloca i32, align 4
  %str = alloca [5 x i8], align 1
  store i64 %character, i64* %character.addr, align 8
  %0 = load i64, i64* %character.addr, align 8
  %call = call zeroext i1 @NATNUMP(i64 %0)
  br i1 %call, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, i64* %character.addr, align 8
  %shr = ashr i64 %1, 2
  %cmp = icmp sle i64 %shr, 4194303
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %entry
  %call1 = call i64 @builtin_lisp_symbol(i32 260)
  %2 = load i64, i64* %character.addr, align 8
  %3 = call i64 @wrong_type_argument(i64 %call1, i64 %2) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %4, %cond.true
  %5 = load i64, i64* %character.addr, align 8
  %shr2 = ashr i64 %5, 2
  %conv = trunc i64 %shr2 to i32
  store i32 %conv, i32* %c, align 4
  br i1 true, label %cond.true.3, label %cond.false.6

cond.true.3:                                      ; preds = %cond.end
  %6 = load i32, i32* %c, align 4
  %add = add i32 %6, 0
  %cmp4 = icmp ule i32 %add, 127
  br i1 %cmp4, label %cond.true.11, label %cond.false.13

cond.false.6:                                     ; preds = %cond.end
  %7 = load i32, i32* %c, align 4
  %conv7 = sext i32 %7 to i64
  %add8 = add i64 %conv7, 0
  %cmp9 = icmp ule i64 %add8, 127
  br i1 %cmp9, label %cond.true.11, label %cond.false.13

cond.true.11:                                     ; preds = %cond.false.6, %cond.true.3
  %8 = load i32, i32* %c, align 4
  %conv12 = trunc i32 %8 to i8
  %arrayidx = getelementptr inbounds [5 x i8], [5 x i8]* %str, i32 0, i64 0
  store i8 %conv12, i8* %arrayidx, align 1
  br label %cond.end.59

cond.false.13:                                    ; preds = %cond.false.6, %cond.true.3
  br i1 true, label %cond.true.14, label %cond.false.18

cond.true.14:                                     ; preds = %cond.false.13
  %9 = load i32, i32* %c, align 4
  %add15 = add i32 %9, 0
  %cmp16 = icmp ule i32 %add15, 2047
  br i1 %cmp16, label %cond.true.23, label %cond.false.30

cond.false.18:                                    ; preds = %cond.false.13
  %10 = load i32, i32* %c, align 4
  %conv19 = sext i32 %10 to i64
  %add20 = add i64 %conv19, 0
  %cmp21 = icmp ule i64 %add20, 2047
  br i1 %cmp21, label %cond.true.23, label %cond.false.30

cond.true.23:                                     ; preds = %cond.false.18, %cond.true.14
  %11 = load i32, i32* %c, align 4
  %shr24 = ashr i32 %11, 6
  %or = or i32 192, %shr24
  %conv25 = trunc i32 %or to i8
  %arrayidx26 = getelementptr inbounds [5 x i8], [5 x i8]* %str, i32 0, i64 0
  store i8 %conv25, i8* %arrayidx26, align 1
  %12 = load i32, i32* %c, align 4
  %and = and i32 %12, 63
  %or27 = or i32 128, %and
  %conv28 = trunc i32 %or27 to i8
  %arrayidx29 = getelementptr inbounds [5 x i8], [5 x i8]* %str, i32 0, i64 1
  store i8 %conv28, i8* %arrayidx29, align 1
  br label %cond.end.57

cond.false.30:                                    ; preds = %cond.false.18, %cond.true.14
  br i1 true, label %cond.true.31, label %cond.false.35

cond.true.31:                                     ; preds = %cond.false.30
  %13 = load i32, i32* %c, align 4
  %add32 = add i32 %13, 0
  %cmp33 = icmp ule i32 %add32, 65535
  br i1 %cmp33, label %cond.true.40, label %cond.false.54

cond.false.35:                                    ; preds = %cond.false.30
  %14 = load i32, i32* %c, align 4
  %conv36 = sext i32 %14 to i64
  %add37 = add i64 %conv36, 0
  %cmp38 = icmp ule i64 %add37, 65535
  br i1 %cmp38, label %cond.true.40, label %cond.false.54

cond.true.40:                                     ; preds = %cond.false.35, %cond.true.31
  %15 = load i32, i32* %c, align 4
  %shr41 = ashr i32 %15, 12
  %or42 = or i32 224, %shr41
  %conv43 = trunc i32 %or42 to i8
  %arrayidx44 = getelementptr inbounds [5 x i8], [5 x i8]* %str, i32 0, i64 0
  store i8 %conv43, i8* %arrayidx44, align 1
  %16 = load i32, i32* %c, align 4
  %shr45 = ashr i32 %16, 6
  %and46 = and i32 %shr45, 63
  %or47 = or i32 128, %and46
  %conv48 = trunc i32 %or47 to i8
  %arrayidx49 = getelementptr inbounds [5 x i8], [5 x i8]* %str, i32 0, i64 1
  store i8 %conv48, i8* %arrayidx49, align 1
  %17 = load i32, i32* %c, align 4
  %and50 = and i32 %17, 63
  %or51 = or i32 128, %and50
  %conv52 = trunc i32 %or51 to i8
  %arrayidx53 = getelementptr inbounds [5 x i8], [5 x i8]* %str, i32 0, i64 2
  store i8 %conv52, i8* %arrayidx53, align 1
  br label %cond.end.56

cond.false.54:                                    ; preds = %cond.false.35, %cond.true.31
  %18 = load i32, i32* %c, align 4
  %arraydecay = getelementptr inbounds [5 x i8], [5 x i8]* %str, i32 0, i32 0
  %call55 = call i32 @char_string(i32 %18, i8* %arraydecay)
  br label %cond.end.56

cond.end.56:                                      ; preds = %cond.false.54, %cond.true.40
  %cond = phi i32 [ 3, %cond.true.40 ], [ %call55, %cond.false.54 ]
  br label %cond.end.57

cond.end.57:                                      ; preds = %cond.end.56, %cond.true.23
  %cond58 = phi i32 [ 2, %cond.true.23 ], [ %cond, %cond.end.56 ]
  br label %cond.end.59

cond.end.59:                                      ; preds = %cond.end.57, %cond.true.11
  %cond60 = phi i32 [ 1, %cond.true.11 ], [ %cond58, %cond.end.57 ]
  store i32 %cond60, i32* %len, align 4
  %arraydecay61 = getelementptr inbounds [5 x i8], [5 x i8]* %str, i32 0, i32 0
  %19 = load i32, i32* %len, align 4
  %conv62 = sext i32 %19 to i64
  %call63 = call i64 @make_string_from_bytes(i8* %arraydecay61, i64 1, i64 %conv62)
  ret i64 %call63
}

declare zeroext i1 @NATNUMP(i64) #1

; Function Attrs: noreturn
declare i64 @wrong_type_argument(i64, i64) #4

declare i32 @char_string(i32, i8*) #1

declare i64 @make_string_from_bytes(i8*, i64, i64) #1

; Function Attrs: nounwind uwtable
define i64 @Fbyte_to_string(i64 %byte) #0 {
entry:
  %byte.addr = alloca i64, align 8
  %b = alloca i8, align 1
  store i64 %byte, i64* %byte.addr, align 8
  %0 = load i64, i64* %byte.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %and1 = and i32 %conv, -5
  %cmp = icmp eq i32 %and1, 2
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = call i64 @builtin_lisp_symbol(i32 559)
  %1 = load i64, i64* %byte.addr, align 8
  %2 = call i64 @wrong_type_argument(i64 %call, i64 %1) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %3, %cond.true
  %4 = load i64, i64* %byte.addr, align 8
  %shr = ashr i64 %4, 2
  %cmp3 = icmp slt i64 %shr, 0
  br i1 %cmp3, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end
  %5 = load i64, i64* %byte.addr, align 8
  %shr5 = ashr i64 %5, 2
  %cmp6 = icmp sgt i64 %shr5, 255
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %cond.end
  call void (i8*, ...) @error(i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.5, i32 0, i32 0)) #9
  unreachable

if.end:                                           ; preds = %lor.lhs.false
  %6 = load i64, i64* %byte.addr, align 8
  %shr8 = ashr i64 %6, 2
  %conv9 = trunc i64 %shr8 to i8
  store i8 %conv9, i8* %b, align 1
  %call10 = call i64 @make_string_from_bytes(i8* %b, i64 1, i64 1)
  ret i64 %call10
}

; Function Attrs: noreturn
declare void @error(i8*, ...) #4

; Function Attrs: nounwind uwtable
define i64 @Fstring_to_char(i64 %string) #0 {
entry:
  %string.addr = alloca i64, align 8
  %val = alloca i64, align 8
  store i64 %string, i64* %string.addr, align 8
  %0 = load i64, i64* %string.addr, align 8
  call void @CHECK_STRING(i64 %0)
  %1 = load i64, i64* %string.addr, align 8
  %call = call i64 @SCHARS(i64 %1)
  %tobool = icmp ne i64 %call, 0
  br i1 %tobool, label %if.then, label %if.else.62

if.then:                                          ; preds = %entry
  %2 = load i64, i64* %string.addr, align 8
  %call1 = call zeroext i1 @STRING_MULTIBYTE(i64 %2)
  br i1 %call1, label %if.then.2, label %if.else

if.then.2:                                        ; preds = %if.then
  %3 = load i64, i64* %string.addr, align 8
  %call3 = call i8* @SDATA(i64 %3)
  %arrayidx = getelementptr inbounds i8, i8* %call3, i64 0
  %4 = load i8, i8* %arrayidx, align 1
  %conv = zext i8 %4 to i32
  %and = and i32 %conv, 128
  %tobool4 = icmp ne i32 %and, 0
  br i1 %tobool4, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then.2
  %5 = load i64, i64* %string.addr, align 8
  %call5 = call i8* @SDATA(i64 %5)
  %arrayidx6 = getelementptr inbounds i8, i8* %call5, i64 0
  %6 = load i8, i8* %arrayidx6, align 1
  %conv7 = zext i8 %6 to i32
  br label %cond.end.55

cond.false:                                       ; preds = %if.then.2
  %7 = load i64, i64* %string.addr, align 8
  %call8 = call i8* @SDATA(i64 %7)
  %arrayidx9 = getelementptr inbounds i8, i8* %call8, i64 0
  %8 = load i8, i8* %arrayidx9, align 1
  %conv10 = zext i8 %8 to i32
  %and11 = and i32 %conv10, 32
  %tobool12 = icmp ne i32 %and11, 0
  br i1 %tobool12, label %cond.false.26, label %cond.true.13

cond.true.13:                                     ; preds = %cond.false
  %9 = load i64, i64* %string.addr, align 8
  %call14 = call i8* @SDATA(i64 %9)
  %arrayidx15 = getelementptr inbounds i8, i8* %call14, i64 0
  %10 = load i8, i8* %arrayidx15, align 1
  %conv16 = zext i8 %10 to i32
  %and17 = and i32 %conv16, 31
  %shl = shl i32 %and17, 6
  %11 = load i64, i64* %string.addr, align 8
  %call18 = call i8* @SDATA(i64 %11)
  %arrayidx19 = getelementptr inbounds i8, i8* %call18, i64 1
  %12 = load i8, i8* %arrayidx19, align 1
  %conv20 = zext i8 %12 to i32
  %and21 = and i32 %conv20, 63
  %or = or i32 %shl, %and21
  %13 = load i64, i64* %string.addr, align 8
  %call22 = call i8* @SDATA(i64 %13)
  %arrayidx23 = getelementptr inbounds i8, i8* %call22, i64 0
  %14 = load i8, i8* %arrayidx23, align 1
  %conv24 = zext i8 %14 to i32
  %cmp = icmp slt i32 %conv24, 194
  %cond = select i1 %cmp, i32 4194176, i32 0
  %add = add nsw i32 %or, %cond
  br label %cond.end.53

cond.false.26:                                    ; preds = %cond.false
  %15 = load i64, i64* %string.addr, align 8
  %call27 = call i8* @SDATA(i64 %15)
  %arrayidx28 = getelementptr inbounds i8, i8* %call27, i64 0
  %16 = load i8, i8* %arrayidx28, align 1
  %conv29 = zext i8 %16 to i32
  %and30 = and i32 %conv29, 16
  %tobool31 = icmp ne i32 %and30, 0
  br i1 %tobool31, label %cond.false.49, label %cond.true.32

cond.true.32:                                     ; preds = %cond.false.26
  %17 = load i64, i64* %string.addr, align 8
  %call33 = call i8* @SDATA(i64 %17)
  %arrayidx34 = getelementptr inbounds i8, i8* %call33, i64 0
  %18 = load i8, i8* %arrayidx34, align 1
  %conv35 = zext i8 %18 to i32
  %and36 = and i32 %conv35, 15
  %shl37 = shl i32 %and36, 12
  %19 = load i64, i64* %string.addr, align 8
  %call38 = call i8* @SDATA(i64 %19)
  %arrayidx39 = getelementptr inbounds i8, i8* %call38, i64 1
  %20 = load i8, i8* %arrayidx39, align 1
  %conv40 = zext i8 %20 to i32
  %and41 = and i32 %conv40, 63
  %shl42 = shl i32 %and41, 6
  %or43 = or i32 %shl37, %shl42
  %21 = load i64, i64* %string.addr, align 8
  %call44 = call i8* @SDATA(i64 %21)
  %arrayidx45 = getelementptr inbounds i8, i8* %call44, i64 2
  %22 = load i8, i8* %arrayidx45, align 1
  %conv46 = zext i8 %22 to i32
  %and47 = and i32 %conv46, 63
  %or48 = or i32 %or43, %and47
  br label %cond.end

cond.false.49:                                    ; preds = %cond.false.26
  %23 = load i64, i64* %string.addr, align 8
  %call50 = call i8* @SDATA(i64 %23)
  %call51 = call i32 @string_char(i8* %call50, i8** null, i32* null)
  br label %cond.end

cond.end:                                         ; preds = %cond.false.49, %cond.true.32
  %cond52 = phi i32 [ %or48, %cond.true.32 ], [ %call51, %cond.false.49 ]
  br label %cond.end.53

cond.end.53:                                      ; preds = %cond.end, %cond.true.13
  %cond54 = phi i32 [ %add, %cond.true.13 ], [ %cond52, %cond.end ]
  br label %cond.end.55

cond.end.55:                                      ; preds = %cond.end.53, %cond.true
  %cond56 = phi i32 [ %conv7, %cond.true ], [ %cond54, %cond.end.53 ]
  %conv57 = sext i32 %cond56 to i64
  %call58 = call i64 @make_natnum(i64 %conv57)
  store i64 %call58, i64* %val, align 8
  br label %if.end

if.else:                                          ; preds = %if.then
  %24 = load i64, i64* %string.addr, align 8
  %call59 = call zeroext i8 @SREF(i64 %24, i64 0)
  %conv60 = zext i8 %call59 to i64
  %call61 = call i64 @make_natnum(i64 %conv60)
  store i64 %call61, i64* %val, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %cond.end.55
  br label %if.end.64

if.else.62:                                       ; preds = %entry
  %call63 = call i64 @make_natnum(i64 0)
  store i64 %call63, i64* %val, align 8
  br label %if.end.64

if.end.64:                                        ; preds = %if.else.62, %if.end
  %25 = load i64, i64* %val, align 8
  ret i64 %25
}

declare void @CHECK_STRING(i64) #1

declare i64 @SCHARS(i64) #1

declare zeroext i1 @STRING_MULTIBYTE(i64) #1

declare i64 @make_natnum(i64) #1

declare i8* @SDATA(i64) #1

declare i32 @string_char(i8*, i8**, i32*) #1

declare zeroext i8 @SREF(i64, i64) #1

; Function Attrs: nounwind uwtable
define i64 @Fpoint() #0 {
entry:
  %temp = alloca i64, align 8
  %0 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt = getelementptr inbounds %struct.buffer, %struct.buffer* %0, i32 0, i32 75
  %1 = load i64, i64* %pt, align 8
  %add = add nsw i64 %1, 0
  %call = call i64 @make_natnum(i64 %add)
  store i64 %call, i64* %temp, align 8
  %2 = load i64, i64* %temp, align 8
  ret i64 %2
}

; Function Attrs: nounwind uwtable
define i64 @Fpoint_marker() #0 {
entry:
  %0 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %1 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt = getelementptr inbounds %struct.buffer, %struct.buffer* %1, i32 0, i32 75
  %2 = load i64, i64* %pt, align 8
  %add = add nsw i64 %2, 0
  %3 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt_byte = getelementptr inbounds %struct.buffer, %struct.buffer* %3, i32 0, i32 76
  %4 = load i64, i64* %pt_byte, align 8
  %add1 = add nsw i64 %4, 0
  %call = call i64 @build_marker(%struct.buffer* %0, i64 %add, i64 %add1)
  ret i64 %call
}

declare i64 @build_marker(%struct.buffer*, i64, i64) #1

; Function Attrs: nounwind uwtable
define i64 @Fgoto_char(i64 %position) #0 {
entry:
  %position.addr = alloca i64, align 8
  store i64 %position, i64* %position.addr, align 8
  %0 = load i64, i64* %position.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 1
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, i64* %position.addr, align 8
  %call = call i32 @XMISCTYPE(i64 %1)
  %cmp2 = icmp eq i32 %call, 24236
  br i1 %cmp2, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %2 = load i64, i64* %position.addr, align 8
  call void @set_point_from_marker(i64 %2)
  br label %if.end.13

if.else:                                          ; preds = %land.lhs.true, %entry
  %3 = load i64, i64* %position.addr, align 8
  %and4 = and i64 %3, 7
  %conv5 = trunc i64 %and4 to i32
  %and6 = and i32 %conv5, -5
  %cmp7 = icmp eq i32 %and6, 2
  br i1 %cmp7, label %if.then.9, label %if.else.11

if.then.9:                                        ; preds = %if.else
  %4 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv = getelementptr inbounds %struct.buffer, %struct.buffer* %4, i32 0, i32 77
  %5 = load i64, i64* %begv, align 8
  %6 = load i64, i64* %position.addr, align 8
  %shr = ashr i64 %6, 2
  %7 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv = getelementptr inbounds %struct.buffer, %struct.buffer* %7, i32 0, i32 79
  %8 = load i64, i64* %zv, align 8
  %call10 = call i64 @clip_to_bounds(i64 %5, i64 %shr, i64 %8)
  call void @set_point(i64 %call10)
  br label %if.end

if.else.11:                                       ; preds = %if.else
  %call12 = call i64 @builtin_lisp_symbol(i32 558)
  %9 = load i64, i64* %position.addr, align 8
  %10 = call i64 @wrong_type_argument(i64 %call12, i64 %9) #9
  unreachable

if.end:                                           ; preds = %if.then.9
  br label %if.end.13

if.end.13:                                        ; preds = %if.end, %if.then
  %11 = load i64, i64* %position.addr, align 8
  ret i64 %11
}

declare i32 @XMISCTYPE(i64) #1

declare void @set_point_from_marker(i64) #1

declare void @set_point(i64) #1

declare i64 @clip_to_bounds(i64, i64, i64) #1

; Function Attrs: nounwind uwtable
define i64 @Fregion_beginning() #0 {
entry:
  %call = call i64 @region_limit(i1 zeroext true)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define internal i64 @region_limit(i1 zeroext %beginningp) #0 {
entry:
  %beginningp.addr = alloca i8, align 1
  %m = alloca i64, align 8
  %frombool = zext i1 %beginningp to i8
  store i8 %frombool, i8* %beginningp.addr, align 1
  %0 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 305), align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %0, %call
  br i1 %cmp, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 171), align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp2 = icmp eq i64 %1, %call1
  br i1 %cmp2, label %land.lhs.true.3, label %if.end

land.lhs.true.3:                                  ; preds = %land.lhs.true
  %2 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %mark_active_ = getelementptr inbounds %struct.buffer, %struct.buffer* %2, i32 0, i32 38
  %3 = load i64, i64* %mark_active_, align 8
  %call4 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp5 = icmp eq i64 %3, %call4
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true.3
  %call6 = call i64 @builtin_lisp_symbol(i32 644)
  call void @xsignal0(i64 %call6) #9
  unreachable

if.end:                                           ; preds = %land.lhs.true.3, %land.lhs.true, %entry
  %4 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %mark_ = getelementptr inbounds %struct.buffer, %struct.buffer* %4, i32 0, i32 8
  %5 = load i64, i64* %mark_, align 8
  %call7 = call i64 @Fmarker_position(i64 %5)
  store i64 %call7, i64* %m, align 8
  %6 = load i64, i64* %m, align 8
  %call8 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp9 = icmp eq i64 %6, %call8
  br i1 %cmp9, label %if.then.10, label %if.end.11

if.then.10:                                       ; preds = %if.end
  call void (i8*, ...) @error(i8* getelementptr inbounds ([47 x i8], [47 x i8]* @.str.35, i32 0, i32 0)) #9
  unreachable

if.end.11:                                        ; preds = %if.end
  %7 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt = getelementptr inbounds %struct.buffer, %struct.buffer* %7, i32 0, i32 75
  %8 = load i64, i64* %pt, align 8
  %add = add nsw i64 %8, 0
  %9 = load i64, i64* %m, align 8
  %shr = ashr i64 %9, 2
  %cmp12 = icmp slt i64 %add, %shr
  %conv = zext i1 %cmp12 to i32
  %10 = load i8, i8* %beginningp.addr, align 1
  %tobool = trunc i8 %10 to i1
  %conv13 = zext i1 %tobool to i32
  %cmp14 = icmp eq i32 %conv, %conv13
  br i1 %cmp14, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.11
  %11 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt16 = getelementptr inbounds %struct.buffer, %struct.buffer* %11, i32 0, i32 75
  %12 = load i64, i64* %pt16, align 8
  %add17 = add nsw i64 %12, 0
  br label %cond.end

cond.false:                                       ; preds = %if.end.11
  %13 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv = getelementptr inbounds %struct.buffer, %struct.buffer* %13, i32 0, i32 77
  %14 = load i64, i64* %begv, align 8
  %15 = load i64, i64* %m, align 8
  %shr18 = ashr i64 %15, 2
  %16 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv = getelementptr inbounds %struct.buffer, %struct.buffer* %16, i32 0, i32 79
  %17 = load i64, i64* %zv, align 8
  %call19 = call i64 @clip_to_bounds(i64 %14, i64 %shr18, i64 %17)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %add17, %cond.true ], [ %call19, %cond.false ]
  %shl = shl i64 %cond, 2
  %add20 = add i64 %shl, 2
  ret i64 %add20
}

; Function Attrs: nounwind uwtable
define i64 @Fregion_end() #0 {
entry:
  %call = call i64 @region_limit(i1 zeroext false)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define i64 @Fmark_marker() #0 {
entry:
  %0 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %mark_ = getelementptr inbounds %struct.buffer, %struct.buffer* %0, i32 0, i32 8
  %1 = load i64, i64* %mark_, align 8
  ret i64 %1
}

; Function Attrs: nounwind uwtable
define i64 @Fget_pos_property(i64 %position, i64 %prop, i64 %object) #0 {
entry:
  %retval = alloca i64, align 8
  %position.addr = alloca i64, align 8
  %prop.addr = alloca i64, align 8
  %object.addr = alloca i64, align 8
  %posn = alloca i64, align 8
  %noverlays = alloca i64, align 8
  %overlay_vec = alloca i64*, align 8
  %tem = alloca i64, align 8
  %obuf = alloca %struct.buffer*, align 8
  %sa_avail = alloca i64, align 8
  %sa_count = alloca i64, align 8
  %sa_must_free = alloca i8, align 1
  %overlay_vecbuf = alloca [40 x i64], align 16
  %alloca_nbytes = alloca i64, align 8
  %arg_ = alloca i64, align 8
  %ol = alloca i64, align 8
  %start = alloca i64, align 8
  %finish = alloca i64, align 8
  %stickiness = alloca i32, align 4
  store i64 %position, i64* %position.addr, align 8
  store i64 %prop, i64* %prop.addr, align 8
  store i64 %object, i64* %object.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load i64, i64* %position.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 1
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %do.body
  %1 = load i64, i64* %position.addr, align 8
  %call = call i32 @XMISCTYPE(i64 %1)
  %cmp2 = icmp eq i32 %call, 24236
  br i1 %cmp2, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %2 = load i64, i64* %position.addr, align 8
  %call4 = call i64 @marker_position(i64 %2)
  %call5 = call i64 @make_natnum(i64 %call4)
  store i64 %call5, i64* %position.addr, align 8
  br label %if.end

if.else:                                          ; preds = %land.lhs.true, %do.body
  %3 = load i64, i64* %position.addr, align 8
  %and6 = and i64 %3, 7
  %conv7 = trunc i64 %and6 to i32
  %and8 = and i32 %conv7, -5
  %cmp9 = icmp eq i32 %and8, 2
  br i1 %cmp9, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.else
  br label %cond.end

cond.false:                                       ; preds = %if.else
  %call11 = call i64 @builtin_lisp_symbol(i32 558)
  %4 = load i64, i64* %position.addr, align 8
  %5 = call i64 @wrong_type_argument(i64 %call11, i64 %4) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %6, %cond.true
  br label %if.end

if.end:                                           ; preds = %cond.end, %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %7 = load i64, i64* %object.addr, align 8
  %call12 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp13 = icmp eq i64 %7, %call12
  br i1 %cmp13, label %if.then.15, label %if.else.17

if.then.15:                                       ; preds = %do.end
  %8 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %9 = bitcast %struct.buffer* %8 to i8*
  %call16 = call i64 @make_lisp_ptr(i8* %9, i32 5)
  store i64 %call16, i64* %object.addr, align 8
  br label %if.end.22

if.else.17:                                       ; preds = %do.end
  %10 = load i64, i64* %object.addr, align 8
  %call18 = call zeroext i1 @WINDOWP(i64 %10)
  br i1 %call18, label %if.then.19, label %if.end.21

if.then.19:                                       ; preds = %if.else.17
  %11 = load i64, i64* %object.addr, align 8
  %call20 = call %struct.window* @XWINDOW(i64 %11)
  %contents = getelementptr inbounds %struct.window, %struct.window* %call20, i32 0, i32 10
  %12 = load i64, i64* %contents, align 8
  store i64 %12, i64* %object.addr, align 8
  br label %if.end.21

if.end.21:                                        ; preds = %if.then.19, %if.else.17
  br label %if.end.22

if.end.22:                                        ; preds = %if.end.21, %if.then.15
  %13 = load i64, i64* %object.addr, align 8
  %call23 = call zeroext i1 @BUFFERP(i64 %13)
  br i1 %call23, label %if.else.26, label %if.then.24

if.then.24:                                       ; preds = %if.end.22
  %14 = load i64, i64* %position.addr, align 8
  %15 = load i64, i64* %prop.addr, align 8
  %16 = load i64, i64* %object.addr, align 8
  %call25 = call i64 @Fget_text_property(i64 %14, i64 %15, i64 %16)
  store i64 %call25, i64* %retval
  br label %return

if.else.26:                                       ; preds = %if.end.22
  %17 = load i64, i64* %position.addr, align 8
  %shr = ashr i64 %17, 2
  store i64 %shr, i64* %posn, align 8
  %18 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  store %struct.buffer* %18, %struct.buffer** %obuf, align 8
  store i64 16384, i64* %sa_avail, align 8
  %call27 = call i64 @SPECPDL_INDEX()
  store i64 %call27, i64* %sa_count, align 8
  store i8 0, i8* %sa_must_free, align 1
  %19 = load i64, i64* %object.addr, align 8
  %call28 = call %struct.buffer* @XBUFFER(i64 %19)
  call void @set_buffer_temp(%struct.buffer* %call28)
  store i64 40, i64* %noverlays, align 8
  %arraydecay = getelementptr inbounds [40 x i64], [40 x i64]* %overlay_vecbuf, i32 0, i32 0
  store i64* %arraydecay, i64** %overlay_vec, align 8
  %20 = load i64, i64* %posn, align 8
  %21 = load i64*, i64** %overlay_vec, align 8
  %22 = load i64, i64* %noverlays, align 8
  %call29 = call i64 @overlays_around(i64 %20, i64* %21, i64 %22)
  store i64 %call29, i64* %noverlays, align 8
  %23 = load i64, i64* %noverlays, align 8
  %cmp30 = icmp ult i64 40, %23
  br i1 %cmp30, label %if.then.32, label %if.end.2215

if.then.32:                                       ; preds = %if.else.26
  br label %do.body.33

do.body.33:                                       ; preds = %if.then.32
  br i1 false, label %cond.true.34, label %cond.false.510

cond.true.34:                                     ; preds = %do.body.33
  br i1 false, label %cond.true.35, label %cond.false.295

cond.true.35:                                     ; preds = %cond.true.34
  %24 = load i64, i64* %noverlays, align 8
  %conv36 = trunc i64 %24 to i8
  %conv37 = sext i8 %conv36 to i32
  %add = add nsw i32 0, %conv37
  %mul = mul nsw i32 0, %add
  %sub = sub nsw i32 %mul, 1
  %cmp38 = icmp slt i32 %sub, 0
  br i1 %cmp38, label %cond.true.40, label %cond.false.58

cond.true.40:                                     ; preds = %cond.true.35
  %25 = load i64, i64* %noverlays, align 8
  %conv41 = trunc i64 %25 to i8
  %conv42 = sext i8 %conv41 to i32
  %add43 = add nsw i32 0, %conv42
  %mul44 = mul nsw i32 0, %add43
  %add45 = add nsw i32 %mul44, 0
  %neg = xor i32 %add45, -1
  %cmp46 = icmp eq i32 %neg, -1
  %conv47 = zext i1 %cmp46 to i32
  %sub48 = sub nsw i32 0, %conv47
  %26 = load i64, i64* %noverlays, align 8
  %conv49 = trunc i64 %26 to i8
  %conv50 = sext i8 %conv49 to i32
  %add51 = add nsw i32 0, %conv50
  %mul52 = mul nsw i32 0, %add51
  %add53 = add nsw i32 %mul52, 1
  %shl = shl i32 %add53, 30
  %sub54 = sub nsw i32 %shl, 1
  %mul55 = mul nsw i32 %sub54, 2
  %add56 = add nsw i32 %mul55, 1
  %sub57 = sub nsw i32 %sub48, %add56
  br label %cond.end.64

cond.false.58:                                    ; preds = %cond.true.35
  %27 = load i64, i64* %noverlays, align 8
  %conv59 = trunc i64 %27 to i8
  %conv60 = sext i8 %conv59 to i32
  %add61 = add nsw i32 0, %conv60
  %mul62 = mul nsw i32 0, %add61
  %add63 = add nsw i32 %mul62, 0
  br label %cond.end.64

cond.end.64:                                      ; preds = %cond.false.58, %cond.true.40
  %cond = phi i32 [ %sub57, %cond.true.40 ], [ %add63, %cond.false.58 ]
  %cmp65 = icmp eq i32 %cond, 0
  br i1 %cmp65, label %land.lhs.true.67, label %lor.lhs.false

land.lhs.true.67:                                 ; preds = %cond.end.64
  %28 = load i64, i64* %noverlays, align 8
  %conv68 = trunc i64 %28 to i8
  %conv69 = sext i8 %conv68 to i32
  %cmp70 = icmp slt i32 %conv69, 0
  br i1 %cmp70, label %cond.true.249, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true.67, %cond.end.64
  br i1 false, label %cond.true.72, label %cond.false.150

cond.true.72:                                     ; preds = %lor.lhs.false
  %29 = load i64, i64* %noverlays, align 8
  %conv73 = trunc i64 %29 to i8
  %conv74 = sext i8 %conv73 to i32
  %cmp75 = icmp slt i32 %conv74, 0
  br i1 %cmp75, label %cond.true.77, label %cond.false.107

cond.true.77:                                     ; preds = %cond.true.72
  %30 = load i64, i64* %noverlays, align 8
  %conv78 = trunc i64 %30 to i8
  %conv79 = sext i8 %conv78 to i32
  %31 = load i64, i64* %noverlays, align 8
  %conv80 = trunc i64 %31 to i8
  %conv81 = sext i8 %conv80 to i32
  %add82 = add nsw i32 0, %conv81
  %mul83 = mul nsw i32 0, %add82
  %sub84 = sub nsw i32 %mul83, 1
  %cmp85 = icmp slt i32 %sub84, 0
  br i1 %cmp85, label %cond.true.87, label %cond.false.97

cond.true.87:                                     ; preds = %cond.true.77
  %32 = load i64, i64* %noverlays, align 8
  %conv88 = trunc i64 %32 to i8
  %conv89 = sext i8 %conv88 to i32
  %add90 = add nsw i32 0, %conv89
  %mul91 = mul nsw i32 0, %add90
  %add92 = add nsw i32 %mul91, 1
  %shl93 = shl i32 %add92, 30
  %sub94 = sub nsw i32 %shl93, 1
  %mul95 = mul nsw i32 %sub94, 2
  %add96 = add nsw i32 %mul95, 1
  br label %cond.end.103

cond.false.97:                                    ; preds = %cond.true.77
  %33 = load i64, i64* %noverlays, align 8
  %conv98 = trunc i64 %33 to i8
  %conv99 = sext i8 %conv98 to i32
  %add100 = add nsw i32 0, %conv99
  %mul101 = mul nsw i32 0, %add100
  %sub102 = sub nsw i32 %mul101, 1
  br label %cond.end.103

cond.end.103:                                     ; preds = %cond.false.97, %cond.true.87
  %cond104 = phi i32 [ %add96, %cond.true.87 ], [ %sub102, %cond.false.97 ]
  %div = sdiv i32 %cond104, 8
  %cmp105 = icmp slt i32 %conv79, %div
  br i1 %cmp105, label %cond.true.249, label %lor.lhs.false.229

cond.false.107:                                   ; preds = %cond.true.72
  br i1 false, label %cond.true.108, label %cond.false.109

cond.true.108:                                    ; preds = %cond.false.107
  br i1 false, label %cond.true.249, label %lor.lhs.false.229

cond.false.109:                                   ; preds = %cond.false.107
  %34 = load i64, i64* %noverlays, align 8
  %conv110 = trunc i64 %34 to i8
  %conv111 = sext i8 %conv110 to i32
  %add112 = add nsw i32 0, %conv111
  %mul113 = mul nsw i32 0, %add112
  %sub114 = sub nsw i32 %mul113, 1
  %cmp115 = icmp slt i32 %sub114, 0
  br i1 %cmp115, label %cond.true.117, label %cond.false.137

cond.true.117:                                    ; preds = %cond.false.109
  %35 = load i64, i64* %noverlays, align 8
  %conv118 = trunc i64 %35 to i8
  %conv119 = sext i8 %conv118 to i32
  %add120 = add nsw i32 0, %conv119
  %mul121 = mul nsw i32 0, %add120
  %add122 = add nsw i32 %mul121, 0
  %neg123 = xor i32 %add122, -1
  %cmp124 = icmp eq i32 %neg123, -1
  %conv125 = zext i1 %cmp124 to i32
  %sub126 = sub nsw i32 0, %conv125
  %36 = load i64, i64* %noverlays, align 8
  %conv127 = trunc i64 %36 to i8
  %conv128 = sext i8 %conv127 to i32
  %add129 = add nsw i32 0, %conv128
  %mul130 = mul nsw i32 0, %add129
  %add131 = add nsw i32 %mul130, 1
  %shl132 = shl i32 %add131, 30
  %sub133 = sub nsw i32 %shl132, 1
  %mul134 = mul nsw i32 %sub133, 2
  %add135 = add nsw i32 %mul134, 1
  %sub136 = sub nsw i32 %sub126, %add135
  br label %cond.end.143

cond.false.137:                                   ; preds = %cond.false.109
  %37 = load i64, i64* %noverlays, align 8
  %conv138 = trunc i64 %37 to i8
  %conv139 = sext i8 %conv138 to i32
  %add140 = add nsw i32 0, %conv139
  %mul141 = mul nsw i32 0, %add140
  %add142 = add nsw i32 %mul141, 0
  br label %cond.end.143

cond.end.143:                                     ; preds = %cond.false.137, %cond.true.117
  %cond144 = phi i32 [ %sub136, %cond.true.117 ], [ %add142, %cond.false.137 ]
  %div145 = sdiv i32 %cond144, 8
  %38 = load i64, i64* %noverlays, align 8
  %conv146 = trunc i64 %38 to i8
  %conv147 = sext i8 %conv146 to i32
  %cmp148 = icmp slt i32 %div145, %conv147
  br i1 %cmp148, label %cond.true.249, label %lor.lhs.false.229

cond.false.150:                                   ; preds = %lor.lhs.false
  br i1 false, label %cond.true.151, label %cond.false.152

cond.true.151:                                    ; preds = %cond.false.150
  br i1 false, label %cond.true.249, label %lor.lhs.false.229

cond.false.152:                                   ; preds = %cond.false.150
  %39 = load i64, i64* %noverlays, align 8
  %conv153 = trunc i64 %39 to i8
  %conv154 = sext i8 %conv153 to i32
  %cmp155 = icmp slt i32 %conv154, 0
  br i1 %cmp155, label %cond.true.157, label %cond.false.198

cond.true.157:                                    ; preds = %cond.false.152
  %40 = load i64, i64* %noverlays, align 8
  %conv158 = trunc i64 %40 to i8
  %conv159 = sext i8 %conv158 to i32
  %41 = load i64, i64* %noverlays, align 8
  %conv160 = trunc i64 %41 to i8
  %conv161 = sext i8 %conv160 to i32
  %add162 = add nsw i32 0, %conv161
  %mul163 = mul nsw i32 0, %add162
  %sub164 = sub nsw i32 %mul163, 1
  %cmp165 = icmp slt i32 %sub164, 0
  br i1 %cmp165, label %cond.true.167, label %cond.false.187

cond.true.167:                                    ; preds = %cond.true.157
  %42 = load i64, i64* %noverlays, align 8
  %conv168 = trunc i64 %42 to i8
  %conv169 = sext i8 %conv168 to i32
  %add170 = add nsw i32 0, %conv169
  %mul171 = mul nsw i32 0, %add170
  %add172 = add nsw i32 %mul171, 0
  %neg173 = xor i32 %add172, -1
  %cmp174 = icmp eq i32 %neg173, -1
  %conv175 = zext i1 %cmp174 to i32
  %sub176 = sub nsw i32 0, %conv175
  %43 = load i64, i64* %noverlays, align 8
  %conv177 = trunc i64 %43 to i8
  %conv178 = sext i8 %conv177 to i32
  %add179 = add nsw i32 0, %conv178
  %mul180 = mul nsw i32 0, %add179
  %add181 = add nsw i32 %mul180, 1
  %shl182 = shl i32 %add181, 30
  %sub183 = sub nsw i32 %shl182, 1
  %mul184 = mul nsw i32 %sub183, 2
  %add185 = add nsw i32 %mul184, 1
  %sub186 = sub nsw i32 %sub176, %add185
  br label %cond.end.193

cond.false.187:                                   ; preds = %cond.true.157
  %44 = load i64, i64* %noverlays, align 8
  %conv188 = trunc i64 %44 to i8
  %conv189 = sext i8 %conv188 to i32
  %add190 = add nsw i32 0, %conv189
  %mul191 = mul nsw i32 0, %add190
  %add192 = add nsw i32 %mul191, 0
  br label %cond.end.193

cond.end.193:                                     ; preds = %cond.false.187, %cond.true.167
  %cond194 = phi i32 [ %sub186, %cond.true.167 ], [ %add192, %cond.false.187 ]
  %div195 = sdiv i32 %cond194, 8
  %cmp196 = icmp slt i32 %conv159, %div195
  br i1 %cmp196, label %cond.true.249, label %lor.lhs.false.229

cond.false.198:                                   ; preds = %cond.false.152
  %45 = load i64, i64* %noverlays, align 8
  %conv199 = trunc i64 %45 to i8
  %conv200 = sext i8 %conv199 to i32
  %add201 = add nsw i32 0, %conv200
  %mul202 = mul nsw i32 0, %add201
  %sub203 = sub nsw i32 %mul202, 1
  %cmp204 = icmp slt i32 %sub203, 0
  br i1 %cmp204, label %cond.true.206, label %cond.false.216

cond.true.206:                                    ; preds = %cond.false.198
  %46 = load i64, i64* %noverlays, align 8
  %conv207 = trunc i64 %46 to i8
  %conv208 = sext i8 %conv207 to i32
  %add209 = add nsw i32 0, %conv208
  %mul210 = mul nsw i32 0, %add209
  %add211 = add nsw i32 %mul210, 1
  %shl212 = shl i32 %add211, 30
  %sub213 = sub nsw i32 %shl212, 1
  %mul214 = mul nsw i32 %sub213, 2
  %add215 = add nsw i32 %mul214, 1
  br label %cond.end.222

cond.false.216:                                   ; preds = %cond.false.198
  %47 = load i64, i64* %noverlays, align 8
  %conv217 = trunc i64 %47 to i8
  %conv218 = sext i8 %conv217 to i32
  %add219 = add nsw i32 0, %conv218
  %mul220 = mul nsw i32 0, %add219
  %sub221 = sub nsw i32 %mul220, 1
  br label %cond.end.222

cond.end.222:                                     ; preds = %cond.false.216, %cond.true.206
  %cond223 = phi i32 [ %add215, %cond.true.206 ], [ %sub221, %cond.false.216 ]
  %div224 = sdiv i32 %cond223, 8
  %48 = load i64, i64* %noverlays, align 8
  %conv225 = trunc i64 %48 to i8
  %conv226 = sext i8 %conv225 to i32
  %cmp227 = icmp slt i32 %div224, %conv226
  br i1 %cmp227, label %cond.true.249, label %lor.lhs.false.229

lor.lhs.false.229:                                ; preds = %cond.end.222, %cond.end.193, %cond.true.151, %cond.end.143, %cond.true.108, %cond.end.103
  %49 = load i64, i64* %noverlays, align 8
  %conv230 = trunc i64 %49 to i8
  %conv231 = sext i8 %conv230 to i32
  %mul232 = mul nsw i32 %conv231, 8
  %mul233 = mul nsw i32 0, %mul232
  %sub234 = sub nsw i32 %mul233, 1
  %cmp235 = icmp slt i32 %sub234, 0
  br i1 %cmp235, label %land.lhs.true.237, label %lor.lhs.false.243

land.lhs.true.237:                                ; preds = %lor.lhs.false.229
  %50 = load i64, i64* %noverlays, align 8
  %conv238 = trunc i64 %50 to i8
  %conv239 = sext i8 %conv238 to i32
  %mul240 = mul nsw i32 %conv239, 8
  %cmp241 = icmp slt i32 %mul240, -128
  br i1 %cmp241, label %cond.true.249, label %lor.lhs.false.243

lor.lhs.false.243:                                ; preds = %land.lhs.true.237, %lor.lhs.false.229
  %51 = load i64, i64* %noverlays, align 8
  %conv244 = trunc i64 %51 to i8
  %conv245 = sext i8 %conv244 to i32
  %mul246 = mul nsw i32 %conv245, 8
  %cmp247 = icmp slt i32 127, %mul246
  br i1 %cmp247, label %cond.true.249, label %cond.false.272

cond.true.249:                                    ; preds = %lor.lhs.false.243, %land.lhs.true.237, %cond.end.222, %cond.end.193, %cond.true.151, %cond.end.143, %cond.true.108, %cond.end.103, %land.lhs.true.67
  %52 = load i64, i64* %noverlays, align 8
  %conv250 = trunc i64 %52 to i8
  %conv251 = zext i8 %conv250 to i32
  %mul252 = mul nsw i32 %conv251, 8
  %cmp253 = icmp sle i32 %mul252, 127
  br i1 %cmp253, label %cond.true.255, label %cond.false.261

cond.true.255:                                    ; preds = %cond.true.249
  %53 = load i64, i64* %noverlays, align 8
  %conv256 = trunc i64 %53 to i8
  %conv257 = zext i8 %conv256 to i32
  %mul258 = mul nsw i32 %conv257, 8
  %conv259 = trunc i32 %mul258 to i8
  %conv260 = sext i8 %conv259 to i32
  br label %cond.end.269

cond.false.261:                                   ; preds = %cond.true.249
  %54 = load i64, i64* %noverlays, align 8
  %conv262 = trunc i64 %54 to i8
  %conv263 = zext i8 %conv262 to i32
  %mul264 = mul nsw i32 %conv263, 8
  %sub265 = sub nsw i32 %mul264, -128
  %conv266 = trunc i32 %sub265 to i8
  %conv267 = sext i8 %conv266 to i32
  %add268 = add nsw i32 %conv267, -128
  br label %cond.end.269

cond.end.269:                                     ; preds = %cond.false.261, %cond.true.255
  %cond270 = phi i32 [ %conv260, %cond.true.255 ], [ %add268, %cond.false.261 ]
  %conv271 = sext i32 %cond270 to i64
  store i64 %conv271, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2202, label %lor.lhs.false.2199

cond.false.272:                                   ; preds = %lor.lhs.false.243
  %55 = load i64, i64* %noverlays, align 8
  %conv273 = trunc i64 %55 to i8
  %conv274 = zext i8 %conv273 to i32
  %mul275 = mul nsw i32 %conv274, 8
  %cmp276 = icmp sle i32 %mul275, 127
  br i1 %cmp276, label %cond.true.278, label %cond.false.284

cond.true.278:                                    ; preds = %cond.false.272
  %56 = load i64, i64* %noverlays, align 8
  %conv279 = trunc i64 %56 to i8
  %conv280 = zext i8 %conv279 to i32
  %mul281 = mul nsw i32 %conv280, 8
  %conv282 = trunc i32 %mul281 to i8
  %conv283 = sext i8 %conv282 to i32
  br label %cond.end.292

cond.false.284:                                   ; preds = %cond.false.272
  %57 = load i64, i64* %noverlays, align 8
  %conv285 = trunc i64 %57 to i8
  %conv286 = zext i8 %conv285 to i32
  %mul287 = mul nsw i32 %conv286, 8
  %sub288 = sub nsw i32 %mul287, -128
  %conv289 = trunc i32 %sub288 to i8
  %conv290 = sext i8 %conv289 to i32
  %add291 = add nsw i32 %conv290, -128
  br label %cond.end.292

cond.end.292:                                     ; preds = %cond.false.284, %cond.true.278
  %cond293 = phi i32 [ %conv283, %cond.true.278 ], [ %add291, %cond.false.284 ]
  %conv294 = sext i32 %cond293 to i64
  store i64 %conv294, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2202, label %lor.lhs.false.2199

cond.false.295:                                   ; preds = %cond.true.34
  %58 = load i64, i64* %noverlays, align 8
  %add296 = add nsw i64 0, %58
  %mul297 = mul nsw i64 0, %add296
  %sub298 = sub nsw i64 %mul297, 1
  %cmp299 = icmp slt i64 %sub298, 0
  br i1 %cmp299, label %cond.true.301, label %cond.false.318

cond.true.301:                                    ; preds = %cond.false.295
  %59 = load i64, i64* %noverlays, align 8
  %add302 = add nsw i64 0, %59
  %mul303 = mul nsw i64 0, %add302
  %add304 = add nsw i64 %mul303, 0
  %neg305 = xor i64 %add304, -1
  %cmp306 = icmp eq i64 %neg305, -1
  %conv307 = zext i1 %cmp306 to i32
  %sub308 = sub nsw i32 0, %conv307
  %conv309 = sext i32 %sub308 to i64
  %60 = load i64, i64* %noverlays, align 8
  %add310 = add nsw i64 0, %60
  %mul311 = mul nsw i64 0, %add310
  %add312 = add nsw i64 %mul311, 1
  %shl313 = shl i64 %add312, 62
  %sub314 = sub nsw i64 %shl313, 1
  %mul315 = mul nsw i64 %sub314, 2
  %add316 = add nsw i64 %mul315, 1
  %sub317 = sub nsw i64 %conv309, %add316
  br label %cond.end.322

cond.false.318:                                   ; preds = %cond.false.295
  %61 = load i64, i64* %noverlays, align 8
  %add319 = add nsw i64 0, %61
  %mul320 = mul nsw i64 0, %add319
  %add321 = add nsw i64 %mul320, 0
  br label %cond.end.322

cond.end.322:                                     ; preds = %cond.false.318, %cond.true.301
  %cond323 = phi i64 [ %sub317, %cond.true.301 ], [ %add321, %cond.false.318 ]
  %cmp324 = icmp eq i64 %cond323, 0
  br i1 %cmp324, label %land.lhs.true.326, label %lor.lhs.false.329

land.lhs.true.326:                                ; preds = %cond.end.322
  %62 = load i64, i64* %noverlays, align 8
  %cmp327 = icmp slt i64 %62, 0
  br i1 %cmp327, label %cond.true.464, label %lor.lhs.false.329

lor.lhs.false.329:                                ; preds = %land.lhs.true.326, %cond.end.322
  br i1 false, label %cond.true.330, label %cond.false.390

cond.true.330:                                    ; preds = %lor.lhs.false.329
  %63 = load i64, i64* %noverlays, align 8
  %cmp331 = icmp slt i64 %63, 0
  br i1 %cmp331, label %cond.true.333, label %cond.false.356

cond.true.333:                                    ; preds = %cond.true.330
  %64 = load i64, i64* %noverlays, align 8
  %65 = load i64, i64* %noverlays, align 8
  %add334 = add nsw i64 0, %65
  %mul335 = mul nsw i64 0, %add334
  %sub336 = sub nsw i64 %mul335, 1
  %cmp337 = icmp slt i64 %sub336, 0
  br i1 %cmp337, label %cond.true.339, label %cond.false.347

cond.true.339:                                    ; preds = %cond.true.333
  %66 = load i64, i64* %noverlays, align 8
  %add340 = add nsw i64 0, %66
  %mul341 = mul nsw i64 0, %add340
  %add342 = add nsw i64 %mul341, 1
  %shl343 = shl i64 %add342, 62
  %sub344 = sub nsw i64 %shl343, 1
  %mul345 = mul nsw i64 %sub344, 2
  %add346 = add nsw i64 %mul345, 1
  br label %cond.end.351

cond.false.347:                                   ; preds = %cond.true.333
  %67 = load i64, i64* %noverlays, align 8
  %add348 = add nsw i64 0, %67
  %mul349 = mul nsw i64 0, %add348
  %sub350 = sub nsw i64 %mul349, 1
  br label %cond.end.351

cond.end.351:                                     ; preds = %cond.false.347, %cond.true.339
  %cond352 = phi i64 [ %add346, %cond.true.339 ], [ %sub350, %cond.false.347 ]
  %div353 = sdiv i64 %cond352, 8
  %cmp354 = icmp slt i64 %64, %div353
  br i1 %cmp354, label %cond.true.464, label %lor.lhs.false.450

cond.false.356:                                   ; preds = %cond.true.330
  br i1 false, label %cond.true.357, label %cond.false.358

cond.true.357:                                    ; preds = %cond.false.356
  br i1 false, label %cond.true.464, label %lor.lhs.false.450

cond.false.358:                                   ; preds = %cond.false.356
  %68 = load i64, i64* %noverlays, align 8
  %add359 = add nsw i64 0, %68
  %mul360 = mul nsw i64 0, %add359
  %sub361 = sub nsw i64 %mul360, 1
  %cmp362 = icmp slt i64 %sub361, 0
  br i1 %cmp362, label %cond.true.364, label %cond.false.381

cond.true.364:                                    ; preds = %cond.false.358
  %69 = load i64, i64* %noverlays, align 8
  %add365 = add nsw i64 0, %69
  %mul366 = mul nsw i64 0, %add365
  %add367 = add nsw i64 %mul366, 0
  %neg368 = xor i64 %add367, -1
  %cmp369 = icmp eq i64 %neg368, -1
  %conv370 = zext i1 %cmp369 to i32
  %sub371 = sub nsw i32 0, %conv370
  %conv372 = sext i32 %sub371 to i64
  %70 = load i64, i64* %noverlays, align 8
  %add373 = add nsw i64 0, %70
  %mul374 = mul nsw i64 0, %add373
  %add375 = add nsw i64 %mul374, 1
  %shl376 = shl i64 %add375, 62
  %sub377 = sub nsw i64 %shl376, 1
  %mul378 = mul nsw i64 %sub377, 2
  %add379 = add nsw i64 %mul378, 1
  %sub380 = sub nsw i64 %conv372, %add379
  br label %cond.end.385

cond.false.381:                                   ; preds = %cond.false.358
  %71 = load i64, i64* %noverlays, align 8
  %add382 = add nsw i64 0, %71
  %mul383 = mul nsw i64 0, %add382
  %add384 = add nsw i64 %mul383, 0
  br label %cond.end.385

cond.end.385:                                     ; preds = %cond.false.381, %cond.true.364
  %cond386 = phi i64 [ %sub380, %cond.true.364 ], [ %add384, %cond.false.381 ]
  %div387 = sdiv i64 %cond386, 8
  %72 = load i64, i64* %noverlays, align 8
  %cmp388 = icmp slt i64 %div387, %72
  br i1 %cmp388, label %cond.true.464, label %lor.lhs.false.450

cond.false.390:                                   ; preds = %lor.lhs.false.329
  br i1 false, label %cond.true.391, label %cond.false.392

cond.true.391:                                    ; preds = %cond.false.390
  br i1 false, label %cond.true.464, label %lor.lhs.false.450

cond.false.392:                                   ; preds = %cond.false.390
  %73 = load i64, i64* %noverlays, align 8
  %cmp393 = icmp slt i64 %73, 0
  br i1 %cmp393, label %cond.true.395, label %cond.false.427

cond.true.395:                                    ; preds = %cond.false.392
  %74 = load i64, i64* %noverlays, align 8
  %75 = load i64, i64* %noverlays, align 8
  %add396 = add nsw i64 0, %75
  %mul397 = mul nsw i64 0, %add396
  %sub398 = sub nsw i64 %mul397, 1
  %cmp399 = icmp slt i64 %sub398, 0
  br i1 %cmp399, label %cond.true.401, label %cond.false.418

cond.true.401:                                    ; preds = %cond.true.395
  %76 = load i64, i64* %noverlays, align 8
  %add402 = add nsw i64 0, %76
  %mul403 = mul nsw i64 0, %add402
  %add404 = add nsw i64 %mul403, 0
  %neg405 = xor i64 %add404, -1
  %cmp406 = icmp eq i64 %neg405, -1
  %conv407 = zext i1 %cmp406 to i32
  %sub408 = sub nsw i32 0, %conv407
  %conv409 = sext i32 %sub408 to i64
  %77 = load i64, i64* %noverlays, align 8
  %add410 = add nsw i64 0, %77
  %mul411 = mul nsw i64 0, %add410
  %add412 = add nsw i64 %mul411, 1
  %shl413 = shl i64 %add412, 62
  %sub414 = sub nsw i64 %shl413, 1
  %mul415 = mul nsw i64 %sub414, 2
  %add416 = add nsw i64 %mul415, 1
  %sub417 = sub nsw i64 %conv409, %add416
  br label %cond.end.422

cond.false.418:                                   ; preds = %cond.true.395
  %78 = load i64, i64* %noverlays, align 8
  %add419 = add nsw i64 0, %78
  %mul420 = mul nsw i64 0, %add419
  %add421 = add nsw i64 %mul420, 0
  br label %cond.end.422

cond.end.422:                                     ; preds = %cond.false.418, %cond.true.401
  %cond423 = phi i64 [ %sub417, %cond.true.401 ], [ %add421, %cond.false.418 ]
  %div424 = sdiv i64 %cond423, 8
  %cmp425 = icmp slt i64 %74, %div424
  br i1 %cmp425, label %cond.true.464, label %lor.lhs.false.450

cond.false.427:                                   ; preds = %cond.false.392
  %79 = load i64, i64* %noverlays, align 8
  %add428 = add nsw i64 0, %79
  %mul429 = mul nsw i64 0, %add428
  %sub430 = sub nsw i64 %mul429, 1
  %cmp431 = icmp slt i64 %sub430, 0
  br i1 %cmp431, label %cond.true.433, label %cond.false.441

cond.true.433:                                    ; preds = %cond.false.427
  %80 = load i64, i64* %noverlays, align 8
  %add434 = add nsw i64 0, %80
  %mul435 = mul nsw i64 0, %add434
  %add436 = add nsw i64 %mul435, 1
  %shl437 = shl i64 %add436, 62
  %sub438 = sub nsw i64 %shl437, 1
  %mul439 = mul nsw i64 %sub438, 2
  %add440 = add nsw i64 %mul439, 1
  br label %cond.end.445

cond.false.441:                                   ; preds = %cond.false.427
  %81 = load i64, i64* %noverlays, align 8
  %add442 = add nsw i64 0, %81
  %mul443 = mul nsw i64 0, %add442
  %sub444 = sub nsw i64 %mul443, 1
  br label %cond.end.445

cond.end.445:                                     ; preds = %cond.false.441, %cond.true.433
  %cond446 = phi i64 [ %add440, %cond.true.433 ], [ %sub444, %cond.false.441 ]
  %div447 = sdiv i64 %cond446, 8
  %82 = load i64, i64* %noverlays, align 8
  %cmp448 = icmp slt i64 %div447, %82
  br i1 %cmp448, label %cond.true.464, label %lor.lhs.false.450

lor.lhs.false.450:                                ; preds = %cond.end.445, %cond.end.422, %cond.true.391, %cond.end.385, %cond.true.357, %cond.end.351
  %83 = load i64, i64* %noverlays, align 8
  %mul451 = mul nsw i64 %83, 8
  %mul452 = mul nsw i64 0, %mul451
  %sub453 = sub nsw i64 %mul452, 1
  %cmp454 = icmp slt i64 %sub453, 0
  br i1 %cmp454, label %land.lhs.true.456, label %lor.lhs.false.460

land.lhs.true.456:                                ; preds = %lor.lhs.false.450
  %84 = load i64, i64* %noverlays, align 8
  %mul457 = mul nsw i64 %84, 8
  %cmp458 = icmp slt i64 %mul457, -128
  br i1 %cmp458, label %cond.true.464, label %lor.lhs.false.460

lor.lhs.false.460:                                ; preds = %land.lhs.true.456, %lor.lhs.false.450
  %85 = load i64, i64* %noverlays, align 8
  %mul461 = mul nsw i64 %85, 8
  %cmp462 = icmp slt i64 127, %mul461
  br i1 %cmp462, label %cond.true.464, label %cond.false.487

cond.true.464:                                    ; preds = %lor.lhs.false.460, %land.lhs.true.456, %cond.end.445, %cond.end.422, %cond.true.391, %cond.end.385, %cond.true.357, %cond.end.351, %land.lhs.true.326
  %86 = load i64, i64* %noverlays, align 8
  %conv465 = trunc i64 %86 to i8
  %conv466 = zext i8 %conv465 to i32
  %mul467 = mul nsw i32 %conv466, 8
  %cmp468 = icmp sle i32 %mul467, 127
  br i1 %cmp468, label %cond.true.470, label %cond.false.476

cond.true.470:                                    ; preds = %cond.true.464
  %87 = load i64, i64* %noverlays, align 8
  %conv471 = trunc i64 %87 to i8
  %conv472 = zext i8 %conv471 to i32
  %mul473 = mul nsw i32 %conv472, 8
  %conv474 = trunc i32 %mul473 to i8
  %conv475 = sext i8 %conv474 to i32
  br label %cond.end.484

cond.false.476:                                   ; preds = %cond.true.464
  %88 = load i64, i64* %noverlays, align 8
  %conv477 = trunc i64 %88 to i8
  %conv478 = zext i8 %conv477 to i32
  %mul479 = mul nsw i32 %conv478, 8
  %sub480 = sub nsw i32 %mul479, -128
  %conv481 = trunc i32 %sub480 to i8
  %conv482 = sext i8 %conv481 to i32
  %add483 = add nsw i32 %conv482, -128
  br label %cond.end.484

cond.end.484:                                     ; preds = %cond.false.476, %cond.true.470
  %cond485 = phi i32 [ %conv475, %cond.true.470 ], [ %add483, %cond.false.476 ]
  %conv486 = sext i32 %cond485 to i64
  store i64 %conv486, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2202, label %lor.lhs.false.2199

cond.false.487:                                   ; preds = %lor.lhs.false.460
  %89 = load i64, i64* %noverlays, align 8
  %conv488 = trunc i64 %89 to i8
  %conv489 = zext i8 %conv488 to i32
  %mul490 = mul nsw i32 %conv489, 8
  %cmp491 = icmp sle i32 %mul490, 127
  br i1 %cmp491, label %cond.true.493, label %cond.false.499

cond.true.493:                                    ; preds = %cond.false.487
  %90 = load i64, i64* %noverlays, align 8
  %conv494 = trunc i64 %90 to i8
  %conv495 = zext i8 %conv494 to i32
  %mul496 = mul nsw i32 %conv495, 8
  %conv497 = trunc i32 %mul496 to i8
  %conv498 = sext i8 %conv497 to i32
  br label %cond.end.507

cond.false.499:                                   ; preds = %cond.false.487
  %91 = load i64, i64* %noverlays, align 8
  %conv500 = trunc i64 %91 to i8
  %conv501 = zext i8 %conv500 to i32
  %mul502 = mul nsw i32 %conv501, 8
  %sub503 = sub nsw i32 %mul502, -128
  %conv504 = trunc i32 %sub503 to i8
  %conv505 = sext i8 %conv504 to i32
  %add506 = add nsw i32 %conv505, -128
  br label %cond.end.507

cond.end.507:                                     ; preds = %cond.false.499, %cond.true.493
  %cond508 = phi i32 [ %conv498, %cond.true.493 ], [ %add506, %cond.false.499 ]
  %conv509 = sext i32 %cond508 to i64
  store i64 %conv509, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2202, label %lor.lhs.false.2199

cond.false.510:                                   ; preds = %do.body.33
  br i1 false, label %cond.true.511, label %cond.false.995

cond.true.511:                                    ; preds = %cond.false.510
  br i1 false, label %cond.true.512, label %cond.false.780

cond.true.512:                                    ; preds = %cond.true.511
  %92 = load i64, i64* %noverlays, align 8
  %conv513 = trunc i64 %92 to i16
  %conv514 = sext i16 %conv513 to i32
  %add515 = add nsw i32 0, %conv514
  %mul516 = mul nsw i32 0, %add515
  %sub517 = sub nsw i32 %mul516, 1
  %cmp518 = icmp slt i32 %sub517, 0
  br i1 %cmp518, label %cond.true.520, label %cond.false.540

cond.true.520:                                    ; preds = %cond.true.512
  %93 = load i64, i64* %noverlays, align 8
  %conv521 = trunc i64 %93 to i16
  %conv522 = sext i16 %conv521 to i32
  %add523 = add nsw i32 0, %conv522
  %mul524 = mul nsw i32 0, %add523
  %add525 = add nsw i32 %mul524, 0
  %neg526 = xor i32 %add525, -1
  %cmp527 = icmp eq i32 %neg526, -1
  %conv528 = zext i1 %cmp527 to i32
  %sub529 = sub nsw i32 0, %conv528
  %94 = load i64, i64* %noverlays, align 8
  %conv530 = trunc i64 %94 to i16
  %conv531 = sext i16 %conv530 to i32
  %add532 = add nsw i32 0, %conv531
  %mul533 = mul nsw i32 0, %add532
  %add534 = add nsw i32 %mul533, 1
  %shl535 = shl i32 %add534, 30
  %sub536 = sub nsw i32 %shl535, 1
  %mul537 = mul nsw i32 %sub536, 2
  %add538 = add nsw i32 %mul537, 1
  %sub539 = sub nsw i32 %sub529, %add538
  br label %cond.end.546

cond.false.540:                                   ; preds = %cond.true.512
  %95 = load i64, i64* %noverlays, align 8
  %conv541 = trunc i64 %95 to i16
  %conv542 = sext i16 %conv541 to i32
  %add543 = add nsw i32 0, %conv542
  %mul544 = mul nsw i32 0, %add543
  %add545 = add nsw i32 %mul544, 0
  br label %cond.end.546

cond.end.546:                                     ; preds = %cond.false.540, %cond.true.520
  %cond547 = phi i32 [ %sub539, %cond.true.520 ], [ %add545, %cond.false.540 ]
  %cmp548 = icmp eq i32 %cond547, 0
  br i1 %cmp548, label %land.lhs.true.550, label %lor.lhs.false.555

land.lhs.true.550:                                ; preds = %cond.end.546
  %96 = load i64, i64* %noverlays, align 8
  %conv551 = trunc i64 %96 to i16
  %conv552 = sext i16 %conv551 to i32
  %cmp553 = icmp slt i32 %conv552, 0
  br i1 %cmp553, label %cond.true.734, label %lor.lhs.false.555

lor.lhs.false.555:                                ; preds = %land.lhs.true.550, %cond.end.546
  br i1 false, label %cond.true.556, label %cond.false.635

cond.true.556:                                    ; preds = %lor.lhs.false.555
  %97 = load i64, i64* %noverlays, align 8
  %conv557 = trunc i64 %97 to i16
  %conv558 = sext i16 %conv557 to i32
  %cmp559 = icmp slt i32 %conv558, 0
  br i1 %cmp559, label %cond.true.561, label %cond.false.592

cond.true.561:                                    ; preds = %cond.true.556
  %98 = load i64, i64* %noverlays, align 8
  %conv562 = trunc i64 %98 to i16
  %conv563 = sext i16 %conv562 to i32
  %99 = load i64, i64* %noverlays, align 8
  %conv564 = trunc i64 %99 to i16
  %conv565 = sext i16 %conv564 to i32
  %add566 = add nsw i32 0, %conv565
  %mul567 = mul nsw i32 0, %add566
  %sub568 = sub nsw i32 %mul567, 1
  %cmp569 = icmp slt i32 %sub568, 0
  br i1 %cmp569, label %cond.true.571, label %cond.false.581

cond.true.571:                                    ; preds = %cond.true.561
  %100 = load i64, i64* %noverlays, align 8
  %conv572 = trunc i64 %100 to i16
  %conv573 = sext i16 %conv572 to i32
  %add574 = add nsw i32 0, %conv573
  %mul575 = mul nsw i32 0, %add574
  %add576 = add nsw i32 %mul575, 1
  %shl577 = shl i32 %add576, 30
  %sub578 = sub nsw i32 %shl577, 1
  %mul579 = mul nsw i32 %sub578, 2
  %add580 = add nsw i32 %mul579, 1
  br label %cond.end.587

cond.false.581:                                   ; preds = %cond.true.561
  %101 = load i64, i64* %noverlays, align 8
  %conv582 = trunc i64 %101 to i16
  %conv583 = sext i16 %conv582 to i32
  %add584 = add nsw i32 0, %conv583
  %mul585 = mul nsw i32 0, %add584
  %sub586 = sub nsw i32 %mul585, 1
  br label %cond.end.587

cond.end.587:                                     ; preds = %cond.false.581, %cond.true.571
  %cond588 = phi i32 [ %add580, %cond.true.571 ], [ %sub586, %cond.false.581 ]
  %div589 = sdiv i32 %cond588, 8
  %cmp590 = icmp slt i32 %conv563, %div589
  br i1 %cmp590, label %cond.true.734, label %lor.lhs.false.714

cond.false.592:                                   ; preds = %cond.true.556
  br i1 false, label %cond.true.593, label %cond.false.594

cond.true.593:                                    ; preds = %cond.false.592
  br i1 false, label %cond.true.734, label %lor.lhs.false.714

cond.false.594:                                   ; preds = %cond.false.592
  %102 = load i64, i64* %noverlays, align 8
  %conv595 = trunc i64 %102 to i16
  %conv596 = sext i16 %conv595 to i32
  %add597 = add nsw i32 0, %conv596
  %mul598 = mul nsw i32 0, %add597
  %sub599 = sub nsw i32 %mul598, 1
  %cmp600 = icmp slt i32 %sub599, 0
  br i1 %cmp600, label %cond.true.602, label %cond.false.622

cond.true.602:                                    ; preds = %cond.false.594
  %103 = load i64, i64* %noverlays, align 8
  %conv603 = trunc i64 %103 to i16
  %conv604 = sext i16 %conv603 to i32
  %add605 = add nsw i32 0, %conv604
  %mul606 = mul nsw i32 0, %add605
  %add607 = add nsw i32 %mul606, 0
  %neg608 = xor i32 %add607, -1
  %cmp609 = icmp eq i32 %neg608, -1
  %conv610 = zext i1 %cmp609 to i32
  %sub611 = sub nsw i32 0, %conv610
  %104 = load i64, i64* %noverlays, align 8
  %conv612 = trunc i64 %104 to i16
  %conv613 = sext i16 %conv612 to i32
  %add614 = add nsw i32 0, %conv613
  %mul615 = mul nsw i32 0, %add614
  %add616 = add nsw i32 %mul615, 1
  %shl617 = shl i32 %add616, 30
  %sub618 = sub nsw i32 %shl617, 1
  %mul619 = mul nsw i32 %sub618, 2
  %add620 = add nsw i32 %mul619, 1
  %sub621 = sub nsw i32 %sub611, %add620
  br label %cond.end.628

cond.false.622:                                   ; preds = %cond.false.594
  %105 = load i64, i64* %noverlays, align 8
  %conv623 = trunc i64 %105 to i16
  %conv624 = sext i16 %conv623 to i32
  %add625 = add nsw i32 0, %conv624
  %mul626 = mul nsw i32 0, %add625
  %add627 = add nsw i32 %mul626, 0
  br label %cond.end.628

cond.end.628:                                     ; preds = %cond.false.622, %cond.true.602
  %cond629 = phi i32 [ %sub621, %cond.true.602 ], [ %add627, %cond.false.622 ]
  %div630 = sdiv i32 %cond629, 8
  %106 = load i64, i64* %noverlays, align 8
  %conv631 = trunc i64 %106 to i16
  %conv632 = sext i16 %conv631 to i32
  %cmp633 = icmp slt i32 %div630, %conv632
  br i1 %cmp633, label %cond.true.734, label %lor.lhs.false.714

cond.false.635:                                   ; preds = %lor.lhs.false.555
  br i1 false, label %cond.true.636, label %cond.false.637

cond.true.636:                                    ; preds = %cond.false.635
  br i1 false, label %cond.true.734, label %lor.lhs.false.714

cond.false.637:                                   ; preds = %cond.false.635
  %107 = load i64, i64* %noverlays, align 8
  %conv638 = trunc i64 %107 to i16
  %conv639 = sext i16 %conv638 to i32
  %cmp640 = icmp slt i32 %conv639, 0
  br i1 %cmp640, label %cond.true.642, label %cond.false.683

cond.true.642:                                    ; preds = %cond.false.637
  %108 = load i64, i64* %noverlays, align 8
  %conv643 = trunc i64 %108 to i16
  %conv644 = sext i16 %conv643 to i32
  %109 = load i64, i64* %noverlays, align 8
  %conv645 = trunc i64 %109 to i16
  %conv646 = sext i16 %conv645 to i32
  %add647 = add nsw i32 0, %conv646
  %mul648 = mul nsw i32 0, %add647
  %sub649 = sub nsw i32 %mul648, 1
  %cmp650 = icmp slt i32 %sub649, 0
  br i1 %cmp650, label %cond.true.652, label %cond.false.672

cond.true.652:                                    ; preds = %cond.true.642
  %110 = load i64, i64* %noverlays, align 8
  %conv653 = trunc i64 %110 to i16
  %conv654 = sext i16 %conv653 to i32
  %add655 = add nsw i32 0, %conv654
  %mul656 = mul nsw i32 0, %add655
  %add657 = add nsw i32 %mul656, 0
  %neg658 = xor i32 %add657, -1
  %cmp659 = icmp eq i32 %neg658, -1
  %conv660 = zext i1 %cmp659 to i32
  %sub661 = sub nsw i32 0, %conv660
  %111 = load i64, i64* %noverlays, align 8
  %conv662 = trunc i64 %111 to i16
  %conv663 = sext i16 %conv662 to i32
  %add664 = add nsw i32 0, %conv663
  %mul665 = mul nsw i32 0, %add664
  %add666 = add nsw i32 %mul665, 1
  %shl667 = shl i32 %add666, 30
  %sub668 = sub nsw i32 %shl667, 1
  %mul669 = mul nsw i32 %sub668, 2
  %add670 = add nsw i32 %mul669, 1
  %sub671 = sub nsw i32 %sub661, %add670
  br label %cond.end.678

cond.false.672:                                   ; preds = %cond.true.642
  %112 = load i64, i64* %noverlays, align 8
  %conv673 = trunc i64 %112 to i16
  %conv674 = sext i16 %conv673 to i32
  %add675 = add nsw i32 0, %conv674
  %mul676 = mul nsw i32 0, %add675
  %add677 = add nsw i32 %mul676, 0
  br label %cond.end.678

cond.end.678:                                     ; preds = %cond.false.672, %cond.true.652
  %cond679 = phi i32 [ %sub671, %cond.true.652 ], [ %add677, %cond.false.672 ]
  %div680 = sdiv i32 %cond679, 8
  %cmp681 = icmp slt i32 %conv644, %div680
  br i1 %cmp681, label %cond.true.734, label %lor.lhs.false.714

cond.false.683:                                   ; preds = %cond.false.637
  %113 = load i64, i64* %noverlays, align 8
  %conv684 = trunc i64 %113 to i16
  %conv685 = sext i16 %conv684 to i32
  %add686 = add nsw i32 0, %conv685
  %mul687 = mul nsw i32 0, %add686
  %sub688 = sub nsw i32 %mul687, 1
  %cmp689 = icmp slt i32 %sub688, 0
  br i1 %cmp689, label %cond.true.691, label %cond.false.701

cond.true.691:                                    ; preds = %cond.false.683
  %114 = load i64, i64* %noverlays, align 8
  %conv692 = trunc i64 %114 to i16
  %conv693 = sext i16 %conv692 to i32
  %add694 = add nsw i32 0, %conv693
  %mul695 = mul nsw i32 0, %add694
  %add696 = add nsw i32 %mul695, 1
  %shl697 = shl i32 %add696, 30
  %sub698 = sub nsw i32 %shl697, 1
  %mul699 = mul nsw i32 %sub698, 2
  %add700 = add nsw i32 %mul699, 1
  br label %cond.end.707

cond.false.701:                                   ; preds = %cond.false.683
  %115 = load i64, i64* %noverlays, align 8
  %conv702 = trunc i64 %115 to i16
  %conv703 = sext i16 %conv702 to i32
  %add704 = add nsw i32 0, %conv703
  %mul705 = mul nsw i32 0, %add704
  %sub706 = sub nsw i32 %mul705, 1
  br label %cond.end.707

cond.end.707:                                     ; preds = %cond.false.701, %cond.true.691
  %cond708 = phi i32 [ %add700, %cond.true.691 ], [ %sub706, %cond.false.701 ]
  %div709 = sdiv i32 %cond708, 8
  %116 = load i64, i64* %noverlays, align 8
  %conv710 = trunc i64 %116 to i16
  %conv711 = sext i16 %conv710 to i32
  %cmp712 = icmp slt i32 %div709, %conv711
  br i1 %cmp712, label %cond.true.734, label %lor.lhs.false.714

lor.lhs.false.714:                                ; preds = %cond.end.707, %cond.end.678, %cond.true.636, %cond.end.628, %cond.true.593, %cond.end.587
  %117 = load i64, i64* %noverlays, align 8
  %conv715 = trunc i64 %117 to i16
  %conv716 = sext i16 %conv715 to i32
  %mul717 = mul nsw i32 %conv716, 8
  %mul718 = mul nsw i32 0, %mul717
  %sub719 = sub nsw i32 %mul718, 1
  %cmp720 = icmp slt i32 %sub719, 0
  br i1 %cmp720, label %land.lhs.true.722, label %lor.lhs.false.728

land.lhs.true.722:                                ; preds = %lor.lhs.false.714
  %118 = load i64, i64* %noverlays, align 8
  %conv723 = trunc i64 %118 to i16
  %conv724 = sext i16 %conv723 to i32
  %mul725 = mul nsw i32 %conv724, 8
  %cmp726 = icmp slt i32 %mul725, -32768
  br i1 %cmp726, label %cond.true.734, label %lor.lhs.false.728

lor.lhs.false.728:                                ; preds = %land.lhs.true.722, %lor.lhs.false.714
  %119 = load i64, i64* %noverlays, align 8
  %conv729 = trunc i64 %119 to i16
  %conv730 = sext i16 %conv729 to i32
  %mul731 = mul nsw i32 %conv730, 8
  %cmp732 = icmp slt i32 32767, %mul731
  br i1 %cmp732, label %cond.true.734, label %cond.false.757

cond.true.734:                                    ; preds = %lor.lhs.false.728, %land.lhs.true.722, %cond.end.707, %cond.end.678, %cond.true.636, %cond.end.628, %cond.true.593, %cond.end.587, %land.lhs.true.550
  %120 = load i64, i64* %noverlays, align 8
  %conv735 = trunc i64 %120 to i16
  %conv736 = zext i16 %conv735 to i32
  %mul737 = mul nsw i32 %conv736, 8
  %cmp738 = icmp sle i32 %mul737, 32767
  br i1 %cmp738, label %cond.true.740, label %cond.false.746

cond.true.740:                                    ; preds = %cond.true.734
  %121 = load i64, i64* %noverlays, align 8
  %conv741 = trunc i64 %121 to i16
  %conv742 = zext i16 %conv741 to i32
  %mul743 = mul nsw i32 %conv742, 8
  %conv744 = trunc i32 %mul743 to i16
  %conv745 = sext i16 %conv744 to i32
  br label %cond.end.754

cond.false.746:                                   ; preds = %cond.true.734
  %122 = load i64, i64* %noverlays, align 8
  %conv747 = trunc i64 %122 to i16
  %conv748 = zext i16 %conv747 to i32
  %mul749 = mul nsw i32 %conv748, 8
  %sub750 = sub nsw i32 %mul749, -32768
  %conv751 = trunc i32 %sub750 to i16
  %conv752 = sext i16 %conv751 to i32
  %add753 = add nsw i32 %conv752, -32768
  br label %cond.end.754

cond.end.754:                                     ; preds = %cond.false.746, %cond.true.740
  %cond755 = phi i32 [ %conv745, %cond.true.740 ], [ %add753, %cond.false.746 ]
  %conv756 = sext i32 %cond755 to i64
  store i64 %conv756, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2202, label %lor.lhs.false.2199

cond.false.757:                                   ; preds = %lor.lhs.false.728
  %123 = load i64, i64* %noverlays, align 8
  %conv758 = trunc i64 %123 to i16
  %conv759 = zext i16 %conv758 to i32
  %mul760 = mul nsw i32 %conv759, 8
  %cmp761 = icmp sle i32 %mul760, 32767
  br i1 %cmp761, label %cond.true.763, label %cond.false.769

cond.true.763:                                    ; preds = %cond.false.757
  %124 = load i64, i64* %noverlays, align 8
  %conv764 = trunc i64 %124 to i16
  %conv765 = zext i16 %conv764 to i32
  %mul766 = mul nsw i32 %conv765, 8
  %conv767 = trunc i32 %mul766 to i16
  %conv768 = sext i16 %conv767 to i32
  br label %cond.end.777

cond.false.769:                                   ; preds = %cond.false.757
  %125 = load i64, i64* %noverlays, align 8
  %conv770 = trunc i64 %125 to i16
  %conv771 = zext i16 %conv770 to i32
  %mul772 = mul nsw i32 %conv771, 8
  %sub773 = sub nsw i32 %mul772, -32768
  %conv774 = trunc i32 %sub773 to i16
  %conv775 = sext i16 %conv774 to i32
  %add776 = add nsw i32 %conv775, -32768
  br label %cond.end.777

cond.end.777:                                     ; preds = %cond.false.769, %cond.true.763
  %cond778 = phi i32 [ %conv768, %cond.true.763 ], [ %add776, %cond.false.769 ]
  %conv779 = sext i32 %cond778 to i64
  store i64 %conv779, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2202, label %lor.lhs.false.2199

cond.false.780:                                   ; preds = %cond.true.511
  %126 = load i64, i64* %noverlays, align 8
  %add781 = add nsw i64 0, %126
  %mul782 = mul nsw i64 0, %add781
  %sub783 = sub nsw i64 %mul782, 1
  %cmp784 = icmp slt i64 %sub783, 0
  br i1 %cmp784, label %cond.true.786, label %cond.false.803

cond.true.786:                                    ; preds = %cond.false.780
  %127 = load i64, i64* %noverlays, align 8
  %add787 = add nsw i64 0, %127
  %mul788 = mul nsw i64 0, %add787
  %add789 = add nsw i64 %mul788, 0
  %neg790 = xor i64 %add789, -1
  %cmp791 = icmp eq i64 %neg790, -1
  %conv792 = zext i1 %cmp791 to i32
  %sub793 = sub nsw i32 0, %conv792
  %conv794 = sext i32 %sub793 to i64
  %128 = load i64, i64* %noverlays, align 8
  %add795 = add nsw i64 0, %128
  %mul796 = mul nsw i64 0, %add795
  %add797 = add nsw i64 %mul796, 1
  %shl798 = shl i64 %add797, 62
  %sub799 = sub nsw i64 %shl798, 1
  %mul800 = mul nsw i64 %sub799, 2
  %add801 = add nsw i64 %mul800, 1
  %sub802 = sub nsw i64 %conv794, %add801
  br label %cond.end.807

cond.false.803:                                   ; preds = %cond.false.780
  %129 = load i64, i64* %noverlays, align 8
  %add804 = add nsw i64 0, %129
  %mul805 = mul nsw i64 0, %add804
  %add806 = add nsw i64 %mul805, 0
  br label %cond.end.807

cond.end.807:                                     ; preds = %cond.false.803, %cond.true.786
  %cond808 = phi i64 [ %sub802, %cond.true.786 ], [ %add806, %cond.false.803 ]
  %cmp809 = icmp eq i64 %cond808, 0
  br i1 %cmp809, label %land.lhs.true.811, label %lor.lhs.false.814

land.lhs.true.811:                                ; preds = %cond.end.807
  %130 = load i64, i64* %noverlays, align 8
  %cmp812 = icmp slt i64 %130, 0
  br i1 %cmp812, label %cond.true.949, label %lor.lhs.false.814

lor.lhs.false.814:                                ; preds = %land.lhs.true.811, %cond.end.807
  br i1 false, label %cond.true.815, label %cond.false.875

cond.true.815:                                    ; preds = %lor.lhs.false.814
  %131 = load i64, i64* %noverlays, align 8
  %cmp816 = icmp slt i64 %131, 0
  br i1 %cmp816, label %cond.true.818, label %cond.false.841

cond.true.818:                                    ; preds = %cond.true.815
  %132 = load i64, i64* %noverlays, align 8
  %133 = load i64, i64* %noverlays, align 8
  %add819 = add nsw i64 0, %133
  %mul820 = mul nsw i64 0, %add819
  %sub821 = sub nsw i64 %mul820, 1
  %cmp822 = icmp slt i64 %sub821, 0
  br i1 %cmp822, label %cond.true.824, label %cond.false.832

cond.true.824:                                    ; preds = %cond.true.818
  %134 = load i64, i64* %noverlays, align 8
  %add825 = add nsw i64 0, %134
  %mul826 = mul nsw i64 0, %add825
  %add827 = add nsw i64 %mul826, 1
  %shl828 = shl i64 %add827, 62
  %sub829 = sub nsw i64 %shl828, 1
  %mul830 = mul nsw i64 %sub829, 2
  %add831 = add nsw i64 %mul830, 1
  br label %cond.end.836

cond.false.832:                                   ; preds = %cond.true.818
  %135 = load i64, i64* %noverlays, align 8
  %add833 = add nsw i64 0, %135
  %mul834 = mul nsw i64 0, %add833
  %sub835 = sub nsw i64 %mul834, 1
  br label %cond.end.836

cond.end.836:                                     ; preds = %cond.false.832, %cond.true.824
  %cond837 = phi i64 [ %add831, %cond.true.824 ], [ %sub835, %cond.false.832 ]
  %div838 = sdiv i64 %cond837, 8
  %cmp839 = icmp slt i64 %132, %div838
  br i1 %cmp839, label %cond.true.949, label %lor.lhs.false.935

cond.false.841:                                   ; preds = %cond.true.815
  br i1 false, label %cond.true.842, label %cond.false.843

cond.true.842:                                    ; preds = %cond.false.841
  br i1 false, label %cond.true.949, label %lor.lhs.false.935

cond.false.843:                                   ; preds = %cond.false.841
  %136 = load i64, i64* %noverlays, align 8
  %add844 = add nsw i64 0, %136
  %mul845 = mul nsw i64 0, %add844
  %sub846 = sub nsw i64 %mul845, 1
  %cmp847 = icmp slt i64 %sub846, 0
  br i1 %cmp847, label %cond.true.849, label %cond.false.866

cond.true.849:                                    ; preds = %cond.false.843
  %137 = load i64, i64* %noverlays, align 8
  %add850 = add nsw i64 0, %137
  %mul851 = mul nsw i64 0, %add850
  %add852 = add nsw i64 %mul851, 0
  %neg853 = xor i64 %add852, -1
  %cmp854 = icmp eq i64 %neg853, -1
  %conv855 = zext i1 %cmp854 to i32
  %sub856 = sub nsw i32 0, %conv855
  %conv857 = sext i32 %sub856 to i64
  %138 = load i64, i64* %noverlays, align 8
  %add858 = add nsw i64 0, %138
  %mul859 = mul nsw i64 0, %add858
  %add860 = add nsw i64 %mul859, 1
  %shl861 = shl i64 %add860, 62
  %sub862 = sub nsw i64 %shl861, 1
  %mul863 = mul nsw i64 %sub862, 2
  %add864 = add nsw i64 %mul863, 1
  %sub865 = sub nsw i64 %conv857, %add864
  br label %cond.end.870

cond.false.866:                                   ; preds = %cond.false.843
  %139 = load i64, i64* %noverlays, align 8
  %add867 = add nsw i64 0, %139
  %mul868 = mul nsw i64 0, %add867
  %add869 = add nsw i64 %mul868, 0
  br label %cond.end.870

cond.end.870:                                     ; preds = %cond.false.866, %cond.true.849
  %cond871 = phi i64 [ %sub865, %cond.true.849 ], [ %add869, %cond.false.866 ]
  %div872 = sdiv i64 %cond871, 8
  %140 = load i64, i64* %noverlays, align 8
  %cmp873 = icmp slt i64 %div872, %140
  br i1 %cmp873, label %cond.true.949, label %lor.lhs.false.935

cond.false.875:                                   ; preds = %lor.lhs.false.814
  br i1 false, label %cond.true.876, label %cond.false.877

cond.true.876:                                    ; preds = %cond.false.875
  br i1 false, label %cond.true.949, label %lor.lhs.false.935

cond.false.877:                                   ; preds = %cond.false.875
  %141 = load i64, i64* %noverlays, align 8
  %cmp878 = icmp slt i64 %141, 0
  br i1 %cmp878, label %cond.true.880, label %cond.false.912

cond.true.880:                                    ; preds = %cond.false.877
  %142 = load i64, i64* %noverlays, align 8
  %143 = load i64, i64* %noverlays, align 8
  %add881 = add nsw i64 0, %143
  %mul882 = mul nsw i64 0, %add881
  %sub883 = sub nsw i64 %mul882, 1
  %cmp884 = icmp slt i64 %sub883, 0
  br i1 %cmp884, label %cond.true.886, label %cond.false.903

cond.true.886:                                    ; preds = %cond.true.880
  %144 = load i64, i64* %noverlays, align 8
  %add887 = add nsw i64 0, %144
  %mul888 = mul nsw i64 0, %add887
  %add889 = add nsw i64 %mul888, 0
  %neg890 = xor i64 %add889, -1
  %cmp891 = icmp eq i64 %neg890, -1
  %conv892 = zext i1 %cmp891 to i32
  %sub893 = sub nsw i32 0, %conv892
  %conv894 = sext i32 %sub893 to i64
  %145 = load i64, i64* %noverlays, align 8
  %add895 = add nsw i64 0, %145
  %mul896 = mul nsw i64 0, %add895
  %add897 = add nsw i64 %mul896, 1
  %shl898 = shl i64 %add897, 62
  %sub899 = sub nsw i64 %shl898, 1
  %mul900 = mul nsw i64 %sub899, 2
  %add901 = add nsw i64 %mul900, 1
  %sub902 = sub nsw i64 %conv894, %add901
  br label %cond.end.907

cond.false.903:                                   ; preds = %cond.true.880
  %146 = load i64, i64* %noverlays, align 8
  %add904 = add nsw i64 0, %146
  %mul905 = mul nsw i64 0, %add904
  %add906 = add nsw i64 %mul905, 0
  br label %cond.end.907

cond.end.907:                                     ; preds = %cond.false.903, %cond.true.886
  %cond908 = phi i64 [ %sub902, %cond.true.886 ], [ %add906, %cond.false.903 ]
  %div909 = sdiv i64 %cond908, 8
  %cmp910 = icmp slt i64 %142, %div909
  br i1 %cmp910, label %cond.true.949, label %lor.lhs.false.935

cond.false.912:                                   ; preds = %cond.false.877
  %147 = load i64, i64* %noverlays, align 8
  %add913 = add nsw i64 0, %147
  %mul914 = mul nsw i64 0, %add913
  %sub915 = sub nsw i64 %mul914, 1
  %cmp916 = icmp slt i64 %sub915, 0
  br i1 %cmp916, label %cond.true.918, label %cond.false.926

cond.true.918:                                    ; preds = %cond.false.912
  %148 = load i64, i64* %noverlays, align 8
  %add919 = add nsw i64 0, %148
  %mul920 = mul nsw i64 0, %add919
  %add921 = add nsw i64 %mul920, 1
  %shl922 = shl i64 %add921, 62
  %sub923 = sub nsw i64 %shl922, 1
  %mul924 = mul nsw i64 %sub923, 2
  %add925 = add nsw i64 %mul924, 1
  br label %cond.end.930

cond.false.926:                                   ; preds = %cond.false.912
  %149 = load i64, i64* %noverlays, align 8
  %add927 = add nsw i64 0, %149
  %mul928 = mul nsw i64 0, %add927
  %sub929 = sub nsw i64 %mul928, 1
  br label %cond.end.930

cond.end.930:                                     ; preds = %cond.false.926, %cond.true.918
  %cond931 = phi i64 [ %add925, %cond.true.918 ], [ %sub929, %cond.false.926 ]
  %div932 = sdiv i64 %cond931, 8
  %150 = load i64, i64* %noverlays, align 8
  %cmp933 = icmp slt i64 %div932, %150
  br i1 %cmp933, label %cond.true.949, label %lor.lhs.false.935

lor.lhs.false.935:                                ; preds = %cond.end.930, %cond.end.907, %cond.true.876, %cond.end.870, %cond.true.842, %cond.end.836
  %151 = load i64, i64* %noverlays, align 8
  %mul936 = mul nsw i64 %151, 8
  %mul937 = mul nsw i64 0, %mul936
  %sub938 = sub nsw i64 %mul937, 1
  %cmp939 = icmp slt i64 %sub938, 0
  br i1 %cmp939, label %land.lhs.true.941, label %lor.lhs.false.945

land.lhs.true.941:                                ; preds = %lor.lhs.false.935
  %152 = load i64, i64* %noverlays, align 8
  %mul942 = mul nsw i64 %152, 8
  %cmp943 = icmp slt i64 %mul942, -32768
  br i1 %cmp943, label %cond.true.949, label %lor.lhs.false.945

lor.lhs.false.945:                                ; preds = %land.lhs.true.941, %lor.lhs.false.935
  %153 = load i64, i64* %noverlays, align 8
  %mul946 = mul nsw i64 %153, 8
  %cmp947 = icmp slt i64 32767, %mul946
  br i1 %cmp947, label %cond.true.949, label %cond.false.972

cond.true.949:                                    ; preds = %lor.lhs.false.945, %land.lhs.true.941, %cond.end.930, %cond.end.907, %cond.true.876, %cond.end.870, %cond.true.842, %cond.end.836, %land.lhs.true.811
  %154 = load i64, i64* %noverlays, align 8
  %conv950 = trunc i64 %154 to i16
  %conv951 = zext i16 %conv950 to i32
  %mul952 = mul nsw i32 %conv951, 8
  %cmp953 = icmp sle i32 %mul952, 32767
  br i1 %cmp953, label %cond.true.955, label %cond.false.961

cond.true.955:                                    ; preds = %cond.true.949
  %155 = load i64, i64* %noverlays, align 8
  %conv956 = trunc i64 %155 to i16
  %conv957 = zext i16 %conv956 to i32
  %mul958 = mul nsw i32 %conv957, 8
  %conv959 = trunc i32 %mul958 to i16
  %conv960 = sext i16 %conv959 to i32
  br label %cond.end.969

cond.false.961:                                   ; preds = %cond.true.949
  %156 = load i64, i64* %noverlays, align 8
  %conv962 = trunc i64 %156 to i16
  %conv963 = zext i16 %conv962 to i32
  %mul964 = mul nsw i32 %conv963, 8
  %sub965 = sub nsw i32 %mul964, -32768
  %conv966 = trunc i32 %sub965 to i16
  %conv967 = sext i16 %conv966 to i32
  %add968 = add nsw i32 %conv967, -32768
  br label %cond.end.969

cond.end.969:                                     ; preds = %cond.false.961, %cond.true.955
  %cond970 = phi i32 [ %conv960, %cond.true.955 ], [ %add968, %cond.false.961 ]
  %conv971 = sext i32 %cond970 to i64
  store i64 %conv971, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2202, label %lor.lhs.false.2199

cond.false.972:                                   ; preds = %lor.lhs.false.945
  %157 = load i64, i64* %noverlays, align 8
  %conv973 = trunc i64 %157 to i16
  %conv974 = zext i16 %conv973 to i32
  %mul975 = mul nsw i32 %conv974, 8
  %cmp976 = icmp sle i32 %mul975, 32767
  br i1 %cmp976, label %cond.true.978, label %cond.false.984

cond.true.978:                                    ; preds = %cond.false.972
  %158 = load i64, i64* %noverlays, align 8
  %conv979 = trunc i64 %158 to i16
  %conv980 = zext i16 %conv979 to i32
  %mul981 = mul nsw i32 %conv980, 8
  %conv982 = trunc i32 %mul981 to i16
  %conv983 = sext i16 %conv982 to i32
  br label %cond.end.992

cond.false.984:                                   ; preds = %cond.false.972
  %159 = load i64, i64* %noverlays, align 8
  %conv985 = trunc i64 %159 to i16
  %conv986 = zext i16 %conv985 to i32
  %mul987 = mul nsw i32 %conv986, 8
  %sub988 = sub nsw i32 %mul987, -32768
  %conv989 = trunc i32 %sub988 to i16
  %conv990 = sext i16 %conv989 to i32
  %add991 = add nsw i32 %conv990, -32768
  br label %cond.end.992

cond.end.992:                                     ; preds = %cond.false.984, %cond.true.978
  %cond993 = phi i32 [ %conv983, %cond.true.978 ], [ %add991, %cond.false.984 ]
  %conv994 = sext i32 %cond993 to i64
  store i64 %conv994, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2202, label %lor.lhs.false.2199

cond.false.995:                                   ; preds = %cond.false.510
  br i1 false, label %cond.true.996, label %cond.false.1424

cond.true.996:                                    ; preds = %cond.false.995
  br i1 false, label %cond.true.997, label %cond.false.1223

cond.true.997:                                    ; preds = %cond.true.996
  %160 = load i64, i64* %noverlays, align 8
  %conv998 = trunc i64 %160 to i32
  %add999 = add nsw i32 0, %conv998
  %mul1000 = mul nsw i32 0, %add999
  %sub1001 = sub nsw i32 %mul1000, 1
  %cmp1002 = icmp slt i32 %sub1001, 0
  br i1 %cmp1002, label %cond.true.1004, label %cond.false.1022

cond.true.1004:                                   ; preds = %cond.true.997
  %161 = load i64, i64* %noverlays, align 8
  %conv1005 = trunc i64 %161 to i32
  %add1006 = add nsw i32 0, %conv1005
  %mul1007 = mul nsw i32 0, %add1006
  %add1008 = add nsw i32 %mul1007, 0
  %neg1009 = xor i32 %add1008, -1
  %cmp1010 = icmp eq i32 %neg1009, -1
  %conv1011 = zext i1 %cmp1010 to i32
  %sub1012 = sub nsw i32 0, %conv1011
  %162 = load i64, i64* %noverlays, align 8
  %conv1013 = trunc i64 %162 to i32
  %add1014 = add nsw i32 0, %conv1013
  %mul1015 = mul nsw i32 0, %add1014
  %add1016 = add nsw i32 %mul1015, 1
  %shl1017 = shl i32 %add1016, 30
  %sub1018 = sub nsw i32 %shl1017, 1
  %mul1019 = mul nsw i32 %sub1018, 2
  %add1020 = add nsw i32 %mul1019, 1
  %sub1021 = sub nsw i32 %sub1012, %add1020
  br label %cond.end.1027

cond.false.1022:                                  ; preds = %cond.true.997
  %163 = load i64, i64* %noverlays, align 8
  %conv1023 = trunc i64 %163 to i32
  %add1024 = add nsw i32 0, %conv1023
  %mul1025 = mul nsw i32 0, %add1024
  %add1026 = add nsw i32 %mul1025, 0
  br label %cond.end.1027

cond.end.1027:                                    ; preds = %cond.false.1022, %cond.true.1004
  %cond1028 = phi i32 [ %sub1021, %cond.true.1004 ], [ %add1026, %cond.false.1022 ]
  %cmp1029 = icmp eq i32 %cond1028, 0
  br i1 %cmp1029, label %land.lhs.true.1031, label %lor.lhs.false.1035

land.lhs.true.1031:                               ; preds = %cond.end.1027
  %164 = load i64, i64* %noverlays, align 8
  %conv1032 = trunc i64 %164 to i32
  %cmp1033 = icmp slt i32 %conv1032, 0
  br i1 %cmp1033, label %cond.true.1191, label %lor.lhs.false.1035

lor.lhs.false.1035:                               ; preds = %land.lhs.true.1031, %cond.end.1027
  br i1 false, label %cond.true.1036, label %cond.false.1105

cond.true.1036:                                   ; preds = %lor.lhs.false.1035
  %165 = load i64, i64* %noverlays, align 8
  %conv1037 = trunc i64 %165 to i32
  %cmp1038 = icmp slt i32 %conv1037, 0
  br i1 %cmp1038, label %cond.true.1040, label %cond.false.1067

cond.true.1040:                                   ; preds = %cond.true.1036
  %166 = load i64, i64* %noverlays, align 8
  %conv1041 = trunc i64 %166 to i32
  %167 = load i64, i64* %noverlays, align 8
  %conv1042 = trunc i64 %167 to i32
  %add1043 = add nsw i32 0, %conv1042
  %mul1044 = mul nsw i32 0, %add1043
  %sub1045 = sub nsw i32 %mul1044, 1
  %cmp1046 = icmp slt i32 %sub1045, 0
  br i1 %cmp1046, label %cond.true.1048, label %cond.false.1057

cond.true.1048:                                   ; preds = %cond.true.1040
  %168 = load i64, i64* %noverlays, align 8
  %conv1049 = trunc i64 %168 to i32
  %add1050 = add nsw i32 0, %conv1049
  %mul1051 = mul nsw i32 0, %add1050
  %add1052 = add nsw i32 %mul1051, 1
  %shl1053 = shl i32 %add1052, 30
  %sub1054 = sub nsw i32 %shl1053, 1
  %mul1055 = mul nsw i32 %sub1054, 2
  %add1056 = add nsw i32 %mul1055, 1
  br label %cond.end.1062

cond.false.1057:                                  ; preds = %cond.true.1040
  %169 = load i64, i64* %noverlays, align 8
  %conv1058 = trunc i64 %169 to i32
  %add1059 = add nsw i32 0, %conv1058
  %mul1060 = mul nsw i32 0, %add1059
  %sub1061 = sub nsw i32 %mul1060, 1
  br label %cond.end.1062

cond.end.1062:                                    ; preds = %cond.false.1057, %cond.true.1048
  %cond1063 = phi i32 [ %add1056, %cond.true.1048 ], [ %sub1061, %cond.false.1057 ]
  %div1064 = sdiv i32 %cond1063, 8
  %cmp1065 = icmp slt i32 %conv1041, %div1064
  br i1 %cmp1065, label %cond.true.1191, label %lor.lhs.false.1174

cond.false.1067:                                  ; preds = %cond.true.1036
  br i1 false, label %cond.true.1068, label %cond.false.1069

cond.true.1068:                                   ; preds = %cond.false.1067
  br i1 false, label %cond.true.1191, label %lor.lhs.false.1174

cond.false.1069:                                  ; preds = %cond.false.1067
  %170 = load i64, i64* %noverlays, align 8
  %conv1070 = trunc i64 %170 to i32
  %add1071 = add nsw i32 0, %conv1070
  %mul1072 = mul nsw i32 0, %add1071
  %sub1073 = sub nsw i32 %mul1072, 1
  %cmp1074 = icmp slt i32 %sub1073, 0
  br i1 %cmp1074, label %cond.true.1076, label %cond.false.1094

cond.true.1076:                                   ; preds = %cond.false.1069
  %171 = load i64, i64* %noverlays, align 8
  %conv1077 = trunc i64 %171 to i32
  %add1078 = add nsw i32 0, %conv1077
  %mul1079 = mul nsw i32 0, %add1078
  %add1080 = add nsw i32 %mul1079, 0
  %neg1081 = xor i32 %add1080, -1
  %cmp1082 = icmp eq i32 %neg1081, -1
  %conv1083 = zext i1 %cmp1082 to i32
  %sub1084 = sub nsw i32 0, %conv1083
  %172 = load i64, i64* %noverlays, align 8
  %conv1085 = trunc i64 %172 to i32
  %add1086 = add nsw i32 0, %conv1085
  %mul1087 = mul nsw i32 0, %add1086
  %add1088 = add nsw i32 %mul1087, 1
  %shl1089 = shl i32 %add1088, 30
  %sub1090 = sub nsw i32 %shl1089, 1
  %mul1091 = mul nsw i32 %sub1090, 2
  %add1092 = add nsw i32 %mul1091, 1
  %sub1093 = sub nsw i32 %sub1084, %add1092
  br label %cond.end.1099

cond.false.1094:                                  ; preds = %cond.false.1069
  %173 = load i64, i64* %noverlays, align 8
  %conv1095 = trunc i64 %173 to i32
  %add1096 = add nsw i32 0, %conv1095
  %mul1097 = mul nsw i32 0, %add1096
  %add1098 = add nsw i32 %mul1097, 0
  br label %cond.end.1099

cond.end.1099:                                    ; preds = %cond.false.1094, %cond.true.1076
  %cond1100 = phi i32 [ %sub1093, %cond.true.1076 ], [ %add1098, %cond.false.1094 ]
  %div1101 = sdiv i32 %cond1100, 8
  %174 = load i64, i64* %noverlays, align 8
  %conv1102 = trunc i64 %174 to i32
  %cmp1103 = icmp slt i32 %div1101, %conv1102
  br i1 %cmp1103, label %cond.true.1191, label %lor.lhs.false.1174

cond.false.1105:                                  ; preds = %lor.lhs.false.1035
  br i1 false, label %cond.true.1106, label %cond.false.1107

cond.true.1106:                                   ; preds = %cond.false.1105
  br i1 false, label %cond.true.1191, label %lor.lhs.false.1174

cond.false.1107:                                  ; preds = %cond.false.1105
  %175 = load i64, i64* %noverlays, align 8
  %conv1108 = trunc i64 %175 to i32
  %cmp1109 = icmp slt i32 %conv1108, 0
  br i1 %cmp1109, label %cond.true.1111, label %cond.false.1147

cond.true.1111:                                   ; preds = %cond.false.1107
  %176 = load i64, i64* %noverlays, align 8
  %conv1112 = trunc i64 %176 to i32
  %177 = load i64, i64* %noverlays, align 8
  %conv1113 = trunc i64 %177 to i32
  %add1114 = add nsw i32 0, %conv1113
  %mul1115 = mul nsw i32 0, %add1114
  %sub1116 = sub nsw i32 %mul1115, 1
  %cmp1117 = icmp slt i32 %sub1116, 0
  br i1 %cmp1117, label %cond.true.1119, label %cond.false.1137

cond.true.1119:                                   ; preds = %cond.true.1111
  %178 = load i64, i64* %noverlays, align 8
  %conv1120 = trunc i64 %178 to i32
  %add1121 = add nsw i32 0, %conv1120
  %mul1122 = mul nsw i32 0, %add1121
  %add1123 = add nsw i32 %mul1122, 0
  %neg1124 = xor i32 %add1123, -1
  %cmp1125 = icmp eq i32 %neg1124, -1
  %conv1126 = zext i1 %cmp1125 to i32
  %sub1127 = sub nsw i32 0, %conv1126
  %179 = load i64, i64* %noverlays, align 8
  %conv1128 = trunc i64 %179 to i32
  %add1129 = add nsw i32 0, %conv1128
  %mul1130 = mul nsw i32 0, %add1129
  %add1131 = add nsw i32 %mul1130, 1
  %shl1132 = shl i32 %add1131, 30
  %sub1133 = sub nsw i32 %shl1132, 1
  %mul1134 = mul nsw i32 %sub1133, 2
  %add1135 = add nsw i32 %mul1134, 1
  %sub1136 = sub nsw i32 %sub1127, %add1135
  br label %cond.end.1142

cond.false.1137:                                  ; preds = %cond.true.1111
  %180 = load i64, i64* %noverlays, align 8
  %conv1138 = trunc i64 %180 to i32
  %add1139 = add nsw i32 0, %conv1138
  %mul1140 = mul nsw i32 0, %add1139
  %add1141 = add nsw i32 %mul1140, 0
  br label %cond.end.1142

cond.end.1142:                                    ; preds = %cond.false.1137, %cond.true.1119
  %cond1143 = phi i32 [ %sub1136, %cond.true.1119 ], [ %add1141, %cond.false.1137 ]
  %div1144 = sdiv i32 %cond1143, 8
  %cmp1145 = icmp slt i32 %conv1112, %div1144
  br i1 %cmp1145, label %cond.true.1191, label %lor.lhs.false.1174

cond.false.1147:                                  ; preds = %cond.false.1107
  %181 = load i64, i64* %noverlays, align 8
  %conv1148 = trunc i64 %181 to i32
  %add1149 = add nsw i32 0, %conv1148
  %mul1150 = mul nsw i32 0, %add1149
  %sub1151 = sub nsw i32 %mul1150, 1
  %cmp1152 = icmp slt i32 %sub1151, 0
  br i1 %cmp1152, label %cond.true.1154, label %cond.false.1163

cond.true.1154:                                   ; preds = %cond.false.1147
  %182 = load i64, i64* %noverlays, align 8
  %conv1155 = trunc i64 %182 to i32
  %add1156 = add nsw i32 0, %conv1155
  %mul1157 = mul nsw i32 0, %add1156
  %add1158 = add nsw i32 %mul1157, 1
  %shl1159 = shl i32 %add1158, 30
  %sub1160 = sub nsw i32 %shl1159, 1
  %mul1161 = mul nsw i32 %sub1160, 2
  %add1162 = add nsw i32 %mul1161, 1
  br label %cond.end.1168

cond.false.1163:                                  ; preds = %cond.false.1147
  %183 = load i64, i64* %noverlays, align 8
  %conv1164 = trunc i64 %183 to i32
  %add1165 = add nsw i32 0, %conv1164
  %mul1166 = mul nsw i32 0, %add1165
  %sub1167 = sub nsw i32 %mul1166, 1
  br label %cond.end.1168

cond.end.1168:                                    ; preds = %cond.false.1163, %cond.true.1154
  %cond1169 = phi i32 [ %add1162, %cond.true.1154 ], [ %sub1167, %cond.false.1163 ]
  %div1170 = sdiv i32 %cond1169, 8
  %184 = load i64, i64* %noverlays, align 8
  %conv1171 = trunc i64 %184 to i32
  %cmp1172 = icmp slt i32 %div1170, %conv1171
  br i1 %cmp1172, label %cond.true.1191, label %lor.lhs.false.1174

lor.lhs.false.1174:                               ; preds = %cond.end.1168, %cond.end.1142, %cond.true.1106, %cond.end.1099, %cond.true.1068, %cond.end.1062
  %185 = load i64, i64* %noverlays, align 8
  %conv1175 = trunc i64 %185 to i32
  %mul1176 = mul nsw i32 %conv1175, 8
  %mul1177 = mul nsw i32 0, %mul1176
  %sub1178 = sub nsw i32 %mul1177, 1
  %cmp1179 = icmp slt i32 %sub1178, 0
  br i1 %cmp1179, label %land.lhs.true.1181, label %lor.lhs.false.1186

land.lhs.true.1181:                               ; preds = %lor.lhs.false.1174
  %186 = load i64, i64* %noverlays, align 8
  %conv1182 = trunc i64 %186 to i32
  %mul1183 = mul nsw i32 %conv1182, 8
  %cmp1184 = icmp slt i32 %mul1183, -2147483648
  br i1 %cmp1184, label %cond.true.1191, label %lor.lhs.false.1186

lor.lhs.false.1186:                               ; preds = %land.lhs.true.1181, %lor.lhs.false.1174
  %187 = load i64, i64* %noverlays, align 8
  %conv1187 = trunc i64 %187 to i32
  %mul1188 = mul nsw i32 %conv1187, 8
  %cmp1189 = icmp slt i32 2147483647, %mul1188
  br i1 %cmp1189, label %cond.true.1191, label %cond.false.1207

cond.true.1191:                                   ; preds = %lor.lhs.false.1186, %land.lhs.true.1181, %cond.end.1168, %cond.end.1142, %cond.true.1106, %cond.end.1099, %cond.true.1068, %cond.end.1062, %land.lhs.true.1031
  %188 = load i64, i64* %noverlays, align 8
  %conv1192 = trunc i64 %188 to i32
  %mul1193 = mul i32 %conv1192, 8
  %cmp1194 = icmp ule i32 %mul1193, 2147483647
  br i1 %cmp1194, label %cond.true.1196, label %cond.false.1199

cond.true.1196:                                   ; preds = %cond.true.1191
  %189 = load i64, i64* %noverlays, align 8
  %conv1197 = trunc i64 %189 to i32
  %mul1198 = mul i32 %conv1197, 8
  br label %cond.end.1204

cond.false.1199:                                  ; preds = %cond.true.1191
  %190 = load i64, i64* %noverlays, align 8
  %conv1200 = trunc i64 %190 to i32
  %mul1201 = mul i32 %conv1200, 8
  %sub1202 = sub i32 %mul1201, -2147483648
  %add1203 = add nsw i32 %sub1202, -2147483648
  br label %cond.end.1204

cond.end.1204:                                    ; preds = %cond.false.1199, %cond.true.1196
  %cond1205 = phi i32 [ %mul1198, %cond.true.1196 ], [ %add1203, %cond.false.1199 ]
  %conv1206 = sext i32 %cond1205 to i64
  store i64 %conv1206, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2202, label %lor.lhs.false.2199

cond.false.1207:                                  ; preds = %lor.lhs.false.1186
  %191 = load i64, i64* %noverlays, align 8
  %conv1208 = trunc i64 %191 to i32
  %mul1209 = mul i32 %conv1208, 8
  %cmp1210 = icmp ule i32 %mul1209, 2147483647
  br i1 %cmp1210, label %cond.true.1212, label %cond.false.1215

cond.true.1212:                                   ; preds = %cond.false.1207
  %192 = load i64, i64* %noverlays, align 8
  %conv1213 = trunc i64 %192 to i32
  %mul1214 = mul i32 %conv1213, 8
  br label %cond.end.1220

cond.false.1215:                                  ; preds = %cond.false.1207
  %193 = load i64, i64* %noverlays, align 8
  %conv1216 = trunc i64 %193 to i32
  %mul1217 = mul i32 %conv1216, 8
  %sub1218 = sub i32 %mul1217, -2147483648
  %add1219 = add nsw i32 %sub1218, -2147483648
  br label %cond.end.1220

cond.end.1220:                                    ; preds = %cond.false.1215, %cond.true.1212
  %cond1221 = phi i32 [ %mul1214, %cond.true.1212 ], [ %add1219, %cond.false.1215 ]
  %conv1222 = sext i32 %cond1221 to i64
  store i64 %conv1222, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2202, label %lor.lhs.false.2199

cond.false.1223:                                  ; preds = %cond.true.996
  %194 = load i64, i64* %noverlays, align 8
  %add1224 = add nsw i64 0, %194
  %mul1225 = mul nsw i64 0, %add1224
  %sub1226 = sub nsw i64 %mul1225, 1
  %cmp1227 = icmp slt i64 %sub1226, 0
  br i1 %cmp1227, label %cond.true.1229, label %cond.false.1246

cond.true.1229:                                   ; preds = %cond.false.1223
  %195 = load i64, i64* %noverlays, align 8
  %add1230 = add nsw i64 0, %195
  %mul1231 = mul nsw i64 0, %add1230
  %add1232 = add nsw i64 %mul1231, 0
  %neg1233 = xor i64 %add1232, -1
  %cmp1234 = icmp eq i64 %neg1233, -1
  %conv1235 = zext i1 %cmp1234 to i32
  %sub1236 = sub nsw i32 0, %conv1235
  %conv1237 = sext i32 %sub1236 to i64
  %196 = load i64, i64* %noverlays, align 8
  %add1238 = add nsw i64 0, %196
  %mul1239 = mul nsw i64 0, %add1238
  %add1240 = add nsw i64 %mul1239, 1
  %shl1241 = shl i64 %add1240, 62
  %sub1242 = sub nsw i64 %shl1241, 1
  %mul1243 = mul nsw i64 %sub1242, 2
  %add1244 = add nsw i64 %mul1243, 1
  %sub1245 = sub nsw i64 %conv1237, %add1244
  br label %cond.end.1250

cond.false.1246:                                  ; preds = %cond.false.1223
  %197 = load i64, i64* %noverlays, align 8
  %add1247 = add nsw i64 0, %197
  %mul1248 = mul nsw i64 0, %add1247
  %add1249 = add nsw i64 %mul1248, 0
  br label %cond.end.1250

cond.end.1250:                                    ; preds = %cond.false.1246, %cond.true.1229
  %cond1251 = phi i64 [ %sub1245, %cond.true.1229 ], [ %add1249, %cond.false.1246 ]
  %cmp1252 = icmp eq i64 %cond1251, 0
  br i1 %cmp1252, label %land.lhs.true.1254, label %lor.lhs.false.1257

land.lhs.true.1254:                               ; preds = %cond.end.1250
  %198 = load i64, i64* %noverlays, align 8
  %cmp1255 = icmp slt i64 %198, 0
  br i1 %cmp1255, label %cond.true.1392, label %lor.lhs.false.1257

lor.lhs.false.1257:                               ; preds = %land.lhs.true.1254, %cond.end.1250
  br i1 false, label %cond.true.1258, label %cond.false.1318

cond.true.1258:                                   ; preds = %lor.lhs.false.1257
  %199 = load i64, i64* %noverlays, align 8
  %cmp1259 = icmp slt i64 %199, 0
  br i1 %cmp1259, label %cond.true.1261, label %cond.false.1284

cond.true.1261:                                   ; preds = %cond.true.1258
  %200 = load i64, i64* %noverlays, align 8
  %201 = load i64, i64* %noverlays, align 8
  %add1262 = add nsw i64 0, %201
  %mul1263 = mul nsw i64 0, %add1262
  %sub1264 = sub nsw i64 %mul1263, 1
  %cmp1265 = icmp slt i64 %sub1264, 0
  br i1 %cmp1265, label %cond.true.1267, label %cond.false.1275

cond.true.1267:                                   ; preds = %cond.true.1261
  %202 = load i64, i64* %noverlays, align 8
  %add1268 = add nsw i64 0, %202
  %mul1269 = mul nsw i64 0, %add1268
  %add1270 = add nsw i64 %mul1269, 1
  %shl1271 = shl i64 %add1270, 62
  %sub1272 = sub nsw i64 %shl1271, 1
  %mul1273 = mul nsw i64 %sub1272, 2
  %add1274 = add nsw i64 %mul1273, 1
  br label %cond.end.1279

cond.false.1275:                                  ; preds = %cond.true.1261
  %203 = load i64, i64* %noverlays, align 8
  %add1276 = add nsw i64 0, %203
  %mul1277 = mul nsw i64 0, %add1276
  %sub1278 = sub nsw i64 %mul1277, 1
  br label %cond.end.1279

cond.end.1279:                                    ; preds = %cond.false.1275, %cond.true.1267
  %cond1280 = phi i64 [ %add1274, %cond.true.1267 ], [ %sub1278, %cond.false.1275 ]
  %div1281 = sdiv i64 %cond1280, 8
  %cmp1282 = icmp slt i64 %200, %div1281
  br i1 %cmp1282, label %cond.true.1392, label %lor.lhs.false.1378

cond.false.1284:                                  ; preds = %cond.true.1258
  br i1 false, label %cond.true.1285, label %cond.false.1286

cond.true.1285:                                   ; preds = %cond.false.1284
  br i1 false, label %cond.true.1392, label %lor.lhs.false.1378

cond.false.1286:                                  ; preds = %cond.false.1284
  %204 = load i64, i64* %noverlays, align 8
  %add1287 = add nsw i64 0, %204
  %mul1288 = mul nsw i64 0, %add1287
  %sub1289 = sub nsw i64 %mul1288, 1
  %cmp1290 = icmp slt i64 %sub1289, 0
  br i1 %cmp1290, label %cond.true.1292, label %cond.false.1309

cond.true.1292:                                   ; preds = %cond.false.1286
  %205 = load i64, i64* %noverlays, align 8
  %add1293 = add nsw i64 0, %205
  %mul1294 = mul nsw i64 0, %add1293
  %add1295 = add nsw i64 %mul1294, 0
  %neg1296 = xor i64 %add1295, -1
  %cmp1297 = icmp eq i64 %neg1296, -1
  %conv1298 = zext i1 %cmp1297 to i32
  %sub1299 = sub nsw i32 0, %conv1298
  %conv1300 = sext i32 %sub1299 to i64
  %206 = load i64, i64* %noverlays, align 8
  %add1301 = add nsw i64 0, %206
  %mul1302 = mul nsw i64 0, %add1301
  %add1303 = add nsw i64 %mul1302, 1
  %shl1304 = shl i64 %add1303, 62
  %sub1305 = sub nsw i64 %shl1304, 1
  %mul1306 = mul nsw i64 %sub1305, 2
  %add1307 = add nsw i64 %mul1306, 1
  %sub1308 = sub nsw i64 %conv1300, %add1307
  br label %cond.end.1313

cond.false.1309:                                  ; preds = %cond.false.1286
  %207 = load i64, i64* %noverlays, align 8
  %add1310 = add nsw i64 0, %207
  %mul1311 = mul nsw i64 0, %add1310
  %add1312 = add nsw i64 %mul1311, 0
  br label %cond.end.1313

cond.end.1313:                                    ; preds = %cond.false.1309, %cond.true.1292
  %cond1314 = phi i64 [ %sub1308, %cond.true.1292 ], [ %add1312, %cond.false.1309 ]
  %div1315 = sdiv i64 %cond1314, 8
  %208 = load i64, i64* %noverlays, align 8
  %cmp1316 = icmp slt i64 %div1315, %208
  br i1 %cmp1316, label %cond.true.1392, label %lor.lhs.false.1378

cond.false.1318:                                  ; preds = %lor.lhs.false.1257
  br i1 false, label %cond.true.1319, label %cond.false.1320

cond.true.1319:                                   ; preds = %cond.false.1318
  br i1 false, label %cond.true.1392, label %lor.lhs.false.1378

cond.false.1320:                                  ; preds = %cond.false.1318
  %209 = load i64, i64* %noverlays, align 8
  %cmp1321 = icmp slt i64 %209, 0
  br i1 %cmp1321, label %cond.true.1323, label %cond.false.1355

cond.true.1323:                                   ; preds = %cond.false.1320
  %210 = load i64, i64* %noverlays, align 8
  %211 = load i64, i64* %noverlays, align 8
  %add1324 = add nsw i64 0, %211
  %mul1325 = mul nsw i64 0, %add1324
  %sub1326 = sub nsw i64 %mul1325, 1
  %cmp1327 = icmp slt i64 %sub1326, 0
  br i1 %cmp1327, label %cond.true.1329, label %cond.false.1346

cond.true.1329:                                   ; preds = %cond.true.1323
  %212 = load i64, i64* %noverlays, align 8
  %add1330 = add nsw i64 0, %212
  %mul1331 = mul nsw i64 0, %add1330
  %add1332 = add nsw i64 %mul1331, 0
  %neg1333 = xor i64 %add1332, -1
  %cmp1334 = icmp eq i64 %neg1333, -1
  %conv1335 = zext i1 %cmp1334 to i32
  %sub1336 = sub nsw i32 0, %conv1335
  %conv1337 = sext i32 %sub1336 to i64
  %213 = load i64, i64* %noverlays, align 8
  %add1338 = add nsw i64 0, %213
  %mul1339 = mul nsw i64 0, %add1338
  %add1340 = add nsw i64 %mul1339, 1
  %shl1341 = shl i64 %add1340, 62
  %sub1342 = sub nsw i64 %shl1341, 1
  %mul1343 = mul nsw i64 %sub1342, 2
  %add1344 = add nsw i64 %mul1343, 1
  %sub1345 = sub nsw i64 %conv1337, %add1344
  br label %cond.end.1350

cond.false.1346:                                  ; preds = %cond.true.1323
  %214 = load i64, i64* %noverlays, align 8
  %add1347 = add nsw i64 0, %214
  %mul1348 = mul nsw i64 0, %add1347
  %add1349 = add nsw i64 %mul1348, 0
  br label %cond.end.1350

cond.end.1350:                                    ; preds = %cond.false.1346, %cond.true.1329
  %cond1351 = phi i64 [ %sub1345, %cond.true.1329 ], [ %add1349, %cond.false.1346 ]
  %div1352 = sdiv i64 %cond1351, 8
  %cmp1353 = icmp slt i64 %210, %div1352
  br i1 %cmp1353, label %cond.true.1392, label %lor.lhs.false.1378

cond.false.1355:                                  ; preds = %cond.false.1320
  %215 = load i64, i64* %noverlays, align 8
  %add1356 = add nsw i64 0, %215
  %mul1357 = mul nsw i64 0, %add1356
  %sub1358 = sub nsw i64 %mul1357, 1
  %cmp1359 = icmp slt i64 %sub1358, 0
  br i1 %cmp1359, label %cond.true.1361, label %cond.false.1369

cond.true.1361:                                   ; preds = %cond.false.1355
  %216 = load i64, i64* %noverlays, align 8
  %add1362 = add nsw i64 0, %216
  %mul1363 = mul nsw i64 0, %add1362
  %add1364 = add nsw i64 %mul1363, 1
  %shl1365 = shl i64 %add1364, 62
  %sub1366 = sub nsw i64 %shl1365, 1
  %mul1367 = mul nsw i64 %sub1366, 2
  %add1368 = add nsw i64 %mul1367, 1
  br label %cond.end.1373

cond.false.1369:                                  ; preds = %cond.false.1355
  %217 = load i64, i64* %noverlays, align 8
  %add1370 = add nsw i64 0, %217
  %mul1371 = mul nsw i64 0, %add1370
  %sub1372 = sub nsw i64 %mul1371, 1
  br label %cond.end.1373

cond.end.1373:                                    ; preds = %cond.false.1369, %cond.true.1361
  %cond1374 = phi i64 [ %add1368, %cond.true.1361 ], [ %sub1372, %cond.false.1369 ]
  %div1375 = sdiv i64 %cond1374, 8
  %218 = load i64, i64* %noverlays, align 8
  %cmp1376 = icmp slt i64 %div1375, %218
  br i1 %cmp1376, label %cond.true.1392, label %lor.lhs.false.1378

lor.lhs.false.1378:                               ; preds = %cond.end.1373, %cond.end.1350, %cond.true.1319, %cond.end.1313, %cond.true.1285, %cond.end.1279
  %219 = load i64, i64* %noverlays, align 8
  %mul1379 = mul nsw i64 %219, 8
  %mul1380 = mul nsw i64 0, %mul1379
  %sub1381 = sub nsw i64 %mul1380, 1
  %cmp1382 = icmp slt i64 %sub1381, 0
  br i1 %cmp1382, label %land.lhs.true.1384, label %lor.lhs.false.1388

land.lhs.true.1384:                               ; preds = %lor.lhs.false.1378
  %220 = load i64, i64* %noverlays, align 8
  %mul1385 = mul nsw i64 %220, 8
  %cmp1386 = icmp slt i64 %mul1385, -2147483648
  br i1 %cmp1386, label %cond.true.1392, label %lor.lhs.false.1388

lor.lhs.false.1388:                               ; preds = %land.lhs.true.1384, %lor.lhs.false.1378
  %221 = load i64, i64* %noverlays, align 8
  %mul1389 = mul nsw i64 %221, 8
  %cmp1390 = icmp slt i64 2147483647, %mul1389
  br i1 %cmp1390, label %cond.true.1392, label %cond.false.1408

cond.true.1392:                                   ; preds = %lor.lhs.false.1388, %land.lhs.true.1384, %cond.end.1373, %cond.end.1350, %cond.true.1319, %cond.end.1313, %cond.true.1285, %cond.end.1279, %land.lhs.true.1254
  %222 = load i64, i64* %noverlays, align 8
  %conv1393 = trunc i64 %222 to i32
  %mul1394 = mul i32 %conv1393, 8
  %cmp1395 = icmp ule i32 %mul1394, 2147483647
  br i1 %cmp1395, label %cond.true.1397, label %cond.false.1400

cond.true.1397:                                   ; preds = %cond.true.1392
  %223 = load i64, i64* %noverlays, align 8
  %conv1398 = trunc i64 %223 to i32
  %mul1399 = mul i32 %conv1398, 8
  br label %cond.end.1405

cond.false.1400:                                  ; preds = %cond.true.1392
  %224 = load i64, i64* %noverlays, align 8
  %conv1401 = trunc i64 %224 to i32
  %mul1402 = mul i32 %conv1401, 8
  %sub1403 = sub i32 %mul1402, -2147483648
  %add1404 = add nsw i32 %sub1403, -2147483648
  br label %cond.end.1405

cond.end.1405:                                    ; preds = %cond.false.1400, %cond.true.1397
  %cond1406 = phi i32 [ %mul1399, %cond.true.1397 ], [ %add1404, %cond.false.1400 ]
  %conv1407 = sext i32 %cond1406 to i64
  store i64 %conv1407, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2202, label %lor.lhs.false.2199

cond.false.1408:                                  ; preds = %lor.lhs.false.1388
  %225 = load i64, i64* %noverlays, align 8
  %conv1409 = trunc i64 %225 to i32
  %mul1410 = mul i32 %conv1409, 8
  %cmp1411 = icmp ule i32 %mul1410, 2147483647
  br i1 %cmp1411, label %cond.true.1413, label %cond.false.1416

cond.true.1413:                                   ; preds = %cond.false.1408
  %226 = load i64, i64* %noverlays, align 8
  %conv1414 = trunc i64 %226 to i32
  %mul1415 = mul i32 %conv1414, 8
  br label %cond.end.1421

cond.false.1416:                                  ; preds = %cond.false.1408
  %227 = load i64, i64* %noverlays, align 8
  %conv1417 = trunc i64 %227 to i32
  %mul1418 = mul i32 %conv1417, 8
  %sub1419 = sub i32 %mul1418, -2147483648
  %add1420 = add nsw i32 %sub1419, -2147483648
  br label %cond.end.1421

cond.end.1421:                                    ; preds = %cond.false.1416, %cond.true.1413
  %cond1422 = phi i32 [ %mul1415, %cond.true.1413 ], [ %add1420, %cond.false.1416 ]
  %conv1423 = sext i32 %cond1422 to i64
  store i64 %conv1423, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2202, label %lor.lhs.false.2199

cond.false.1424:                                  ; preds = %cond.false.995
  br i1 true, label %cond.true.1425, label %cond.false.1812

cond.true.1425:                                   ; preds = %cond.false.1424
  br i1 false, label %cond.true.1426, label %cond.false.1619

cond.true.1426:                                   ; preds = %cond.true.1425
  %228 = load i64, i64* %noverlays, align 8
  %add1427 = add nsw i64 0, %228
  %mul1428 = mul nsw i64 0, %add1427
  %sub1429 = sub nsw i64 %mul1428, 1
  %cmp1430 = icmp slt i64 %sub1429, 0
  br i1 %cmp1430, label %cond.true.1432, label %cond.false.1449

cond.true.1432:                                   ; preds = %cond.true.1426
  %229 = load i64, i64* %noverlays, align 8
  %add1433 = add nsw i64 0, %229
  %mul1434 = mul nsw i64 0, %add1433
  %add1435 = add nsw i64 %mul1434, 0
  %neg1436 = xor i64 %add1435, -1
  %cmp1437 = icmp eq i64 %neg1436, -1
  %conv1438 = zext i1 %cmp1437 to i32
  %sub1439 = sub nsw i32 0, %conv1438
  %conv1440 = sext i32 %sub1439 to i64
  %230 = load i64, i64* %noverlays, align 8
  %add1441 = add nsw i64 0, %230
  %mul1442 = mul nsw i64 0, %add1441
  %add1443 = add nsw i64 %mul1442, 1
  %shl1444 = shl i64 %add1443, 62
  %sub1445 = sub nsw i64 %shl1444, 1
  %mul1446 = mul nsw i64 %sub1445, 2
  %add1447 = add nsw i64 %mul1446, 1
  %sub1448 = sub nsw i64 %conv1440, %add1447
  br label %cond.end.1453

cond.false.1449:                                  ; preds = %cond.true.1426
  %231 = load i64, i64* %noverlays, align 8
  %add1450 = add nsw i64 0, %231
  %mul1451 = mul nsw i64 0, %add1450
  %add1452 = add nsw i64 %mul1451, 0
  br label %cond.end.1453

cond.end.1453:                                    ; preds = %cond.false.1449, %cond.true.1432
  %cond1454 = phi i64 [ %sub1448, %cond.true.1432 ], [ %add1452, %cond.false.1449 ]
  %cmp1455 = icmp eq i64 %cond1454, 0
  br i1 %cmp1455, label %land.lhs.true.1457, label %lor.lhs.false.1460

land.lhs.true.1457:                               ; preds = %cond.end.1453
  %232 = load i64, i64* %noverlays, align 8
  %cmp1458 = icmp slt i64 %232, 0
  br i1 %cmp1458, label %cond.true.1595, label %lor.lhs.false.1460

lor.lhs.false.1460:                               ; preds = %land.lhs.true.1457, %cond.end.1453
  br i1 false, label %cond.true.1461, label %cond.false.1521

cond.true.1461:                                   ; preds = %lor.lhs.false.1460
  %233 = load i64, i64* %noverlays, align 8
  %cmp1462 = icmp slt i64 %233, 0
  br i1 %cmp1462, label %cond.true.1464, label %cond.false.1487

cond.true.1464:                                   ; preds = %cond.true.1461
  %234 = load i64, i64* %noverlays, align 8
  %235 = load i64, i64* %noverlays, align 8
  %add1465 = add nsw i64 0, %235
  %mul1466 = mul nsw i64 0, %add1465
  %sub1467 = sub nsw i64 %mul1466, 1
  %cmp1468 = icmp slt i64 %sub1467, 0
  br i1 %cmp1468, label %cond.true.1470, label %cond.false.1478

cond.true.1470:                                   ; preds = %cond.true.1464
  %236 = load i64, i64* %noverlays, align 8
  %add1471 = add nsw i64 0, %236
  %mul1472 = mul nsw i64 0, %add1471
  %add1473 = add nsw i64 %mul1472, 1
  %shl1474 = shl i64 %add1473, 62
  %sub1475 = sub nsw i64 %shl1474, 1
  %mul1476 = mul nsw i64 %sub1475, 2
  %add1477 = add nsw i64 %mul1476, 1
  br label %cond.end.1482

cond.false.1478:                                  ; preds = %cond.true.1464
  %237 = load i64, i64* %noverlays, align 8
  %add1479 = add nsw i64 0, %237
  %mul1480 = mul nsw i64 0, %add1479
  %sub1481 = sub nsw i64 %mul1480, 1
  br label %cond.end.1482

cond.end.1482:                                    ; preds = %cond.false.1478, %cond.true.1470
  %cond1483 = phi i64 [ %add1477, %cond.true.1470 ], [ %sub1481, %cond.false.1478 ]
  %div1484 = sdiv i64 %cond1483, 8
  %cmp1485 = icmp slt i64 %234, %div1484
  br i1 %cmp1485, label %cond.true.1595, label %lor.lhs.false.1581

cond.false.1487:                                  ; preds = %cond.true.1461
  br i1 false, label %cond.true.1488, label %cond.false.1489

cond.true.1488:                                   ; preds = %cond.false.1487
  br i1 false, label %cond.true.1595, label %lor.lhs.false.1581

cond.false.1489:                                  ; preds = %cond.false.1487
  %238 = load i64, i64* %noverlays, align 8
  %add1490 = add nsw i64 0, %238
  %mul1491 = mul nsw i64 0, %add1490
  %sub1492 = sub nsw i64 %mul1491, 1
  %cmp1493 = icmp slt i64 %sub1492, 0
  br i1 %cmp1493, label %cond.true.1495, label %cond.false.1512

cond.true.1495:                                   ; preds = %cond.false.1489
  %239 = load i64, i64* %noverlays, align 8
  %add1496 = add nsw i64 0, %239
  %mul1497 = mul nsw i64 0, %add1496
  %add1498 = add nsw i64 %mul1497, 0
  %neg1499 = xor i64 %add1498, -1
  %cmp1500 = icmp eq i64 %neg1499, -1
  %conv1501 = zext i1 %cmp1500 to i32
  %sub1502 = sub nsw i32 0, %conv1501
  %conv1503 = sext i32 %sub1502 to i64
  %240 = load i64, i64* %noverlays, align 8
  %add1504 = add nsw i64 0, %240
  %mul1505 = mul nsw i64 0, %add1504
  %add1506 = add nsw i64 %mul1505, 1
  %shl1507 = shl i64 %add1506, 62
  %sub1508 = sub nsw i64 %shl1507, 1
  %mul1509 = mul nsw i64 %sub1508, 2
  %add1510 = add nsw i64 %mul1509, 1
  %sub1511 = sub nsw i64 %conv1503, %add1510
  br label %cond.end.1516

cond.false.1512:                                  ; preds = %cond.false.1489
  %241 = load i64, i64* %noverlays, align 8
  %add1513 = add nsw i64 0, %241
  %mul1514 = mul nsw i64 0, %add1513
  %add1515 = add nsw i64 %mul1514, 0
  br label %cond.end.1516

cond.end.1516:                                    ; preds = %cond.false.1512, %cond.true.1495
  %cond1517 = phi i64 [ %sub1511, %cond.true.1495 ], [ %add1515, %cond.false.1512 ]
  %div1518 = sdiv i64 %cond1517, 8
  %242 = load i64, i64* %noverlays, align 8
  %cmp1519 = icmp slt i64 %div1518, %242
  br i1 %cmp1519, label %cond.true.1595, label %lor.lhs.false.1581

cond.false.1521:                                  ; preds = %lor.lhs.false.1460
  br i1 false, label %cond.true.1522, label %cond.false.1523

cond.true.1522:                                   ; preds = %cond.false.1521
  br i1 false, label %cond.true.1595, label %lor.lhs.false.1581

cond.false.1523:                                  ; preds = %cond.false.1521
  %243 = load i64, i64* %noverlays, align 8
  %cmp1524 = icmp slt i64 %243, 0
  br i1 %cmp1524, label %cond.true.1526, label %cond.false.1558

cond.true.1526:                                   ; preds = %cond.false.1523
  %244 = load i64, i64* %noverlays, align 8
  %245 = load i64, i64* %noverlays, align 8
  %add1527 = add nsw i64 0, %245
  %mul1528 = mul nsw i64 0, %add1527
  %sub1529 = sub nsw i64 %mul1528, 1
  %cmp1530 = icmp slt i64 %sub1529, 0
  br i1 %cmp1530, label %cond.true.1532, label %cond.false.1549

cond.true.1532:                                   ; preds = %cond.true.1526
  %246 = load i64, i64* %noverlays, align 8
  %add1533 = add nsw i64 0, %246
  %mul1534 = mul nsw i64 0, %add1533
  %add1535 = add nsw i64 %mul1534, 0
  %neg1536 = xor i64 %add1535, -1
  %cmp1537 = icmp eq i64 %neg1536, -1
  %conv1538 = zext i1 %cmp1537 to i32
  %sub1539 = sub nsw i32 0, %conv1538
  %conv1540 = sext i32 %sub1539 to i64
  %247 = load i64, i64* %noverlays, align 8
  %add1541 = add nsw i64 0, %247
  %mul1542 = mul nsw i64 0, %add1541
  %add1543 = add nsw i64 %mul1542, 1
  %shl1544 = shl i64 %add1543, 62
  %sub1545 = sub nsw i64 %shl1544, 1
  %mul1546 = mul nsw i64 %sub1545, 2
  %add1547 = add nsw i64 %mul1546, 1
  %sub1548 = sub nsw i64 %conv1540, %add1547
  br label %cond.end.1553

cond.false.1549:                                  ; preds = %cond.true.1526
  %248 = load i64, i64* %noverlays, align 8
  %add1550 = add nsw i64 0, %248
  %mul1551 = mul nsw i64 0, %add1550
  %add1552 = add nsw i64 %mul1551, 0
  br label %cond.end.1553

cond.end.1553:                                    ; preds = %cond.false.1549, %cond.true.1532
  %cond1554 = phi i64 [ %sub1548, %cond.true.1532 ], [ %add1552, %cond.false.1549 ]
  %div1555 = sdiv i64 %cond1554, 8
  %cmp1556 = icmp slt i64 %244, %div1555
  br i1 %cmp1556, label %cond.true.1595, label %lor.lhs.false.1581

cond.false.1558:                                  ; preds = %cond.false.1523
  %249 = load i64, i64* %noverlays, align 8
  %add1559 = add nsw i64 0, %249
  %mul1560 = mul nsw i64 0, %add1559
  %sub1561 = sub nsw i64 %mul1560, 1
  %cmp1562 = icmp slt i64 %sub1561, 0
  br i1 %cmp1562, label %cond.true.1564, label %cond.false.1572

cond.true.1564:                                   ; preds = %cond.false.1558
  %250 = load i64, i64* %noverlays, align 8
  %add1565 = add nsw i64 0, %250
  %mul1566 = mul nsw i64 0, %add1565
  %add1567 = add nsw i64 %mul1566, 1
  %shl1568 = shl i64 %add1567, 62
  %sub1569 = sub nsw i64 %shl1568, 1
  %mul1570 = mul nsw i64 %sub1569, 2
  %add1571 = add nsw i64 %mul1570, 1
  br label %cond.end.1576

cond.false.1572:                                  ; preds = %cond.false.1558
  %251 = load i64, i64* %noverlays, align 8
  %add1573 = add nsw i64 0, %251
  %mul1574 = mul nsw i64 0, %add1573
  %sub1575 = sub nsw i64 %mul1574, 1
  br label %cond.end.1576

cond.end.1576:                                    ; preds = %cond.false.1572, %cond.true.1564
  %cond1577 = phi i64 [ %add1571, %cond.true.1564 ], [ %sub1575, %cond.false.1572 ]
  %div1578 = sdiv i64 %cond1577, 8
  %252 = load i64, i64* %noverlays, align 8
  %cmp1579 = icmp slt i64 %div1578, %252
  br i1 %cmp1579, label %cond.true.1595, label %lor.lhs.false.1581

lor.lhs.false.1581:                               ; preds = %cond.end.1576, %cond.end.1553, %cond.true.1522, %cond.end.1516, %cond.true.1488, %cond.end.1482
  %253 = load i64, i64* %noverlays, align 8
  %mul1582 = mul nsw i64 %253, 8
  %mul1583 = mul nsw i64 0, %mul1582
  %sub1584 = sub nsw i64 %mul1583, 1
  %cmp1585 = icmp slt i64 %sub1584, 0
  br i1 %cmp1585, label %land.lhs.true.1587, label %lor.lhs.false.1591

land.lhs.true.1587:                               ; preds = %lor.lhs.false.1581
  %254 = load i64, i64* %noverlays, align 8
  %mul1588 = mul nsw i64 %254, 8
  %cmp1589 = icmp slt i64 %mul1588, -9223372036854775808
  br i1 %cmp1589, label %cond.true.1595, label %lor.lhs.false.1591

lor.lhs.false.1591:                               ; preds = %land.lhs.true.1587, %lor.lhs.false.1581
  %255 = load i64, i64* %noverlays, align 8
  %mul1592 = mul nsw i64 %255, 8
  %cmp1593 = icmp slt i64 9223372036854775807, %mul1592
  br i1 %cmp1593, label %cond.true.1595, label %cond.false.1607

cond.true.1595:                                   ; preds = %lor.lhs.false.1591, %land.lhs.true.1587, %cond.end.1576, %cond.end.1553, %cond.true.1522, %cond.end.1516, %cond.true.1488, %cond.end.1482, %land.lhs.true.1457
  %256 = load i64, i64* %noverlays, align 8
  %mul1596 = mul i64 %256, 8
  %cmp1597 = icmp ule i64 %mul1596, 9223372036854775807
  br i1 %cmp1597, label %cond.true.1599, label %cond.false.1601

cond.true.1599:                                   ; preds = %cond.true.1595
  %257 = load i64, i64* %noverlays, align 8
  %mul1600 = mul i64 %257, 8
  br label %cond.end.1605

cond.false.1601:                                  ; preds = %cond.true.1595
  %258 = load i64, i64* %noverlays, align 8
  %mul1602 = mul i64 %258, 8
  %sub1603 = sub i64 %mul1602, -9223372036854775808
  %add1604 = add nsw i64 %sub1603, -9223372036854775808
  br label %cond.end.1605

cond.end.1605:                                    ; preds = %cond.false.1601, %cond.true.1599
  %cond1606 = phi i64 [ %mul1600, %cond.true.1599 ], [ %add1604, %cond.false.1601 ]
  store i64 %cond1606, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2202, label %lor.lhs.false.2199

cond.false.1607:                                  ; preds = %lor.lhs.false.1591
  %259 = load i64, i64* %noverlays, align 8
  %mul1608 = mul i64 %259, 8
  %cmp1609 = icmp ule i64 %mul1608, 9223372036854775807
  br i1 %cmp1609, label %cond.true.1611, label %cond.false.1613

cond.true.1611:                                   ; preds = %cond.false.1607
  %260 = load i64, i64* %noverlays, align 8
  %mul1612 = mul i64 %260, 8
  br label %cond.end.1617

cond.false.1613:                                  ; preds = %cond.false.1607
  %261 = load i64, i64* %noverlays, align 8
  %mul1614 = mul i64 %261, 8
  %sub1615 = sub i64 %mul1614, -9223372036854775808
  %add1616 = add nsw i64 %sub1615, -9223372036854775808
  br label %cond.end.1617

cond.end.1617:                                    ; preds = %cond.false.1613, %cond.true.1611
  %cond1618 = phi i64 [ %mul1612, %cond.true.1611 ], [ %add1616, %cond.false.1613 ]
  store i64 %cond1618, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2202, label %lor.lhs.false.2199

cond.false.1619:                                  ; preds = %cond.true.1425
  %262 = load i64, i64* %noverlays, align 8
  %add1620 = add nsw i64 0, %262
  %mul1621 = mul nsw i64 0, %add1620
  %sub1622 = sub nsw i64 %mul1621, 1
  %cmp1623 = icmp slt i64 %sub1622, 0
  br i1 %cmp1623, label %cond.true.1625, label %cond.false.1642

cond.true.1625:                                   ; preds = %cond.false.1619
  %263 = load i64, i64* %noverlays, align 8
  %add1626 = add nsw i64 0, %263
  %mul1627 = mul nsw i64 0, %add1626
  %add1628 = add nsw i64 %mul1627, 0
  %neg1629 = xor i64 %add1628, -1
  %cmp1630 = icmp eq i64 %neg1629, -1
  %conv1631 = zext i1 %cmp1630 to i32
  %sub1632 = sub nsw i32 0, %conv1631
  %conv1633 = sext i32 %sub1632 to i64
  %264 = load i64, i64* %noverlays, align 8
  %add1634 = add nsw i64 0, %264
  %mul1635 = mul nsw i64 0, %add1634
  %add1636 = add nsw i64 %mul1635, 1
  %shl1637 = shl i64 %add1636, 62
  %sub1638 = sub nsw i64 %shl1637, 1
  %mul1639 = mul nsw i64 %sub1638, 2
  %add1640 = add nsw i64 %mul1639, 1
  %sub1641 = sub nsw i64 %conv1633, %add1640
  br label %cond.end.1646

cond.false.1642:                                  ; preds = %cond.false.1619
  %265 = load i64, i64* %noverlays, align 8
  %add1643 = add nsw i64 0, %265
  %mul1644 = mul nsw i64 0, %add1643
  %add1645 = add nsw i64 %mul1644, 0
  br label %cond.end.1646

cond.end.1646:                                    ; preds = %cond.false.1642, %cond.true.1625
  %cond1647 = phi i64 [ %sub1641, %cond.true.1625 ], [ %add1645, %cond.false.1642 ]
  %cmp1648 = icmp eq i64 %cond1647, 0
  br i1 %cmp1648, label %land.lhs.true.1650, label %lor.lhs.false.1653

land.lhs.true.1650:                               ; preds = %cond.end.1646
  %266 = load i64, i64* %noverlays, align 8
  %cmp1651 = icmp slt i64 %266, 0
  br i1 %cmp1651, label %cond.true.1788, label %lor.lhs.false.1653

lor.lhs.false.1653:                               ; preds = %land.lhs.true.1650, %cond.end.1646
  br i1 false, label %cond.true.1654, label %cond.false.1714

cond.true.1654:                                   ; preds = %lor.lhs.false.1653
  %267 = load i64, i64* %noverlays, align 8
  %cmp1655 = icmp slt i64 %267, 0
  br i1 %cmp1655, label %cond.true.1657, label %cond.false.1680

cond.true.1657:                                   ; preds = %cond.true.1654
  %268 = load i64, i64* %noverlays, align 8
  %269 = load i64, i64* %noverlays, align 8
  %add1658 = add nsw i64 0, %269
  %mul1659 = mul nsw i64 0, %add1658
  %sub1660 = sub nsw i64 %mul1659, 1
  %cmp1661 = icmp slt i64 %sub1660, 0
  br i1 %cmp1661, label %cond.true.1663, label %cond.false.1671

cond.true.1663:                                   ; preds = %cond.true.1657
  %270 = load i64, i64* %noverlays, align 8
  %add1664 = add nsw i64 0, %270
  %mul1665 = mul nsw i64 0, %add1664
  %add1666 = add nsw i64 %mul1665, 1
  %shl1667 = shl i64 %add1666, 62
  %sub1668 = sub nsw i64 %shl1667, 1
  %mul1669 = mul nsw i64 %sub1668, 2
  %add1670 = add nsw i64 %mul1669, 1
  br label %cond.end.1675

cond.false.1671:                                  ; preds = %cond.true.1657
  %271 = load i64, i64* %noverlays, align 8
  %add1672 = add nsw i64 0, %271
  %mul1673 = mul nsw i64 0, %add1672
  %sub1674 = sub nsw i64 %mul1673, 1
  br label %cond.end.1675

cond.end.1675:                                    ; preds = %cond.false.1671, %cond.true.1663
  %cond1676 = phi i64 [ %add1670, %cond.true.1663 ], [ %sub1674, %cond.false.1671 ]
  %div1677 = sdiv i64 %cond1676, 8
  %cmp1678 = icmp slt i64 %268, %div1677
  br i1 %cmp1678, label %cond.true.1788, label %lor.lhs.false.1774

cond.false.1680:                                  ; preds = %cond.true.1654
  br i1 false, label %cond.true.1681, label %cond.false.1682

cond.true.1681:                                   ; preds = %cond.false.1680
  br i1 false, label %cond.true.1788, label %lor.lhs.false.1774

cond.false.1682:                                  ; preds = %cond.false.1680
  %272 = load i64, i64* %noverlays, align 8
  %add1683 = add nsw i64 0, %272
  %mul1684 = mul nsw i64 0, %add1683
  %sub1685 = sub nsw i64 %mul1684, 1
  %cmp1686 = icmp slt i64 %sub1685, 0
  br i1 %cmp1686, label %cond.true.1688, label %cond.false.1705

cond.true.1688:                                   ; preds = %cond.false.1682
  %273 = load i64, i64* %noverlays, align 8
  %add1689 = add nsw i64 0, %273
  %mul1690 = mul nsw i64 0, %add1689
  %add1691 = add nsw i64 %mul1690, 0
  %neg1692 = xor i64 %add1691, -1
  %cmp1693 = icmp eq i64 %neg1692, -1
  %conv1694 = zext i1 %cmp1693 to i32
  %sub1695 = sub nsw i32 0, %conv1694
  %conv1696 = sext i32 %sub1695 to i64
  %274 = load i64, i64* %noverlays, align 8
  %add1697 = add nsw i64 0, %274
  %mul1698 = mul nsw i64 0, %add1697
  %add1699 = add nsw i64 %mul1698, 1
  %shl1700 = shl i64 %add1699, 62
  %sub1701 = sub nsw i64 %shl1700, 1
  %mul1702 = mul nsw i64 %sub1701, 2
  %add1703 = add nsw i64 %mul1702, 1
  %sub1704 = sub nsw i64 %conv1696, %add1703
  br label %cond.end.1709

cond.false.1705:                                  ; preds = %cond.false.1682
  %275 = load i64, i64* %noverlays, align 8
  %add1706 = add nsw i64 0, %275
  %mul1707 = mul nsw i64 0, %add1706
  %add1708 = add nsw i64 %mul1707, 0
  br label %cond.end.1709

cond.end.1709:                                    ; preds = %cond.false.1705, %cond.true.1688
  %cond1710 = phi i64 [ %sub1704, %cond.true.1688 ], [ %add1708, %cond.false.1705 ]
  %div1711 = sdiv i64 %cond1710, 8
  %276 = load i64, i64* %noverlays, align 8
  %cmp1712 = icmp slt i64 %div1711, %276
  br i1 %cmp1712, label %cond.true.1788, label %lor.lhs.false.1774

cond.false.1714:                                  ; preds = %lor.lhs.false.1653
  br i1 false, label %cond.true.1715, label %cond.false.1716

cond.true.1715:                                   ; preds = %cond.false.1714
  br i1 false, label %cond.true.1788, label %lor.lhs.false.1774

cond.false.1716:                                  ; preds = %cond.false.1714
  %277 = load i64, i64* %noverlays, align 8
  %cmp1717 = icmp slt i64 %277, 0
  br i1 %cmp1717, label %cond.true.1719, label %cond.false.1751

cond.true.1719:                                   ; preds = %cond.false.1716
  %278 = load i64, i64* %noverlays, align 8
  %279 = load i64, i64* %noverlays, align 8
  %add1720 = add nsw i64 0, %279
  %mul1721 = mul nsw i64 0, %add1720
  %sub1722 = sub nsw i64 %mul1721, 1
  %cmp1723 = icmp slt i64 %sub1722, 0
  br i1 %cmp1723, label %cond.true.1725, label %cond.false.1742

cond.true.1725:                                   ; preds = %cond.true.1719
  %280 = load i64, i64* %noverlays, align 8
  %add1726 = add nsw i64 0, %280
  %mul1727 = mul nsw i64 0, %add1726
  %add1728 = add nsw i64 %mul1727, 0
  %neg1729 = xor i64 %add1728, -1
  %cmp1730 = icmp eq i64 %neg1729, -1
  %conv1731 = zext i1 %cmp1730 to i32
  %sub1732 = sub nsw i32 0, %conv1731
  %conv1733 = sext i32 %sub1732 to i64
  %281 = load i64, i64* %noverlays, align 8
  %add1734 = add nsw i64 0, %281
  %mul1735 = mul nsw i64 0, %add1734
  %add1736 = add nsw i64 %mul1735, 1
  %shl1737 = shl i64 %add1736, 62
  %sub1738 = sub nsw i64 %shl1737, 1
  %mul1739 = mul nsw i64 %sub1738, 2
  %add1740 = add nsw i64 %mul1739, 1
  %sub1741 = sub nsw i64 %conv1733, %add1740
  br label %cond.end.1746

cond.false.1742:                                  ; preds = %cond.true.1719
  %282 = load i64, i64* %noverlays, align 8
  %add1743 = add nsw i64 0, %282
  %mul1744 = mul nsw i64 0, %add1743
  %add1745 = add nsw i64 %mul1744, 0
  br label %cond.end.1746

cond.end.1746:                                    ; preds = %cond.false.1742, %cond.true.1725
  %cond1747 = phi i64 [ %sub1741, %cond.true.1725 ], [ %add1745, %cond.false.1742 ]
  %div1748 = sdiv i64 %cond1747, 8
  %cmp1749 = icmp slt i64 %278, %div1748
  br i1 %cmp1749, label %cond.true.1788, label %lor.lhs.false.1774

cond.false.1751:                                  ; preds = %cond.false.1716
  %283 = load i64, i64* %noverlays, align 8
  %add1752 = add nsw i64 0, %283
  %mul1753 = mul nsw i64 0, %add1752
  %sub1754 = sub nsw i64 %mul1753, 1
  %cmp1755 = icmp slt i64 %sub1754, 0
  br i1 %cmp1755, label %cond.true.1757, label %cond.false.1765

cond.true.1757:                                   ; preds = %cond.false.1751
  %284 = load i64, i64* %noverlays, align 8
  %add1758 = add nsw i64 0, %284
  %mul1759 = mul nsw i64 0, %add1758
  %add1760 = add nsw i64 %mul1759, 1
  %shl1761 = shl i64 %add1760, 62
  %sub1762 = sub nsw i64 %shl1761, 1
  %mul1763 = mul nsw i64 %sub1762, 2
  %add1764 = add nsw i64 %mul1763, 1
  br label %cond.end.1769

cond.false.1765:                                  ; preds = %cond.false.1751
  %285 = load i64, i64* %noverlays, align 8
  %add1766 = add nsw i64 0, %285
  %mul1767 = mul nsw i64 0, %add1766
  %sub1768 = sub nsw i64 %mul1767, 1
  br label %cond.end.1769

cond.end.1769:                                    ; preds = %cond.false.1765, %cond.true.1757
  %cond1770 = phi i64 [ %add1764, %cond.true.1757 ], [ %sub1768, %cond.false.1765 ]
  %div1771 = sdiv i64 %cond1770, 8
  %286 = load i64, i64* %noverlays, align 8
  %cmp1772 = icmp slt i64 %div1771, %286
  br i1 %cmp1772, label %cond.true.1788, label %lor.lhs.false.1774

lor.lhs.false.1774:                               ; preds = %cond.end.1769, %cond.end.1746, %cond.true.1715, %cond.end.1709, %cond.true.1681, %cond.end.1675
  %287 = load i64, i64* %noverlays, align 8
  %mul1775 = mul nsw i64 %287, 8
  %mul1776 = mul nsw i64 0, %mul1775
  %sub1777 = sub nsw i64 %mul1776, 1
  %cmp1778 = icmp slt i64 %sub1777, 0
  br i1 %cmp1778, label %land.lhs.true.1780, label %lor.lhs.false.1784

land.lhs.true.1780:                               ; preds = %lor.lhs.false.1774
  %288 = load i64, i64* %noverlays, align 8
  %mul1781 = mul nsw i64 %288, 8
  %cmp1782 = icmp slt i64 %mul1781, -9223372036854775808
  br i1 %cmp1782, label %cond.true.1788, label %lor.lhs.false.1784

lor.lhs.false.1784:                               ; preds = %land.lhs.true.1780, %lor.lhs.false.1774
  %289 = load i64, i64* %noverlays, align 8
  %mul1785 = mul nsw i64 %289, 8
  %cmp1786 = icmp slt i64 9223372036854775807, %mul1785
  br i1 %cmp1786, label %cond.true.1788, label %cond.false.1800

cond.true.1788:                                   ; preds = %lor.lhs.false.1784, %land.lhs.true.1780, %cond.end.1769, %cond.end.1746, %cond.true.1715, %cond.end.1709, %cond.true.1681, %cond.end.1675, %land.lhs.true.1650
  %290 = load i64, i64* %noverlays, align 8
  %mul1789 = mul i64 %290, 8
  %cmp1790 = icmp ule i64 %mul1789, 9223372036854775807
  br i1 %cmp1790, label %cond.true.1792, label %cond.false.1794

cond.true.1792:                                   ; preds = %cond.true.1788
  %291 = load i64, i64* %noverlays, align 8
  %mul1793 = mul i64 %291, 8
  br label %cond.end.1798

cond.false.1794:                                  ; preds = %cond.true.1788
  %292 = load i64, i64* %noverlays, align 8
  %mul1795 = mul i64 %292, 8
  %sub1796 = sub i64 %mul1795, -9223372036854775808
  %add1797 = add nsw i64 %sub1796, -9223372036854775808
  br label %cond.end.1798

cond.end.1798:                                    ; preds = %cond.false.1794, %cond.true.1792
  %cond1799 = phi i64 [ %mul1793, %cond.true.1792 ], [ %add1797, %cond.false.1794 ]
  store i64 %cond1799, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2202, label %lor.lhs.false.2199

cond.false.1800:                                  ; preds = %lor.lhs.false.1784
  %293 = load i64, i64* %noverlays, align 8
  %mul1801 = mul i64 %293, 8
  %cmp1802 = icmp ule i64 %mul1801, 9223372036854775807
  br i1 %cmp1802, label %cond.true.1804, label %cond.false.1806

cond.true.1804:                                   ; preds = %cond.false.1800
  %294 = load i64, i64* %noverlays, align 8
  %mul1805 = mul i64 %294, 8
  br label %cond.end.1810

cond.false.1806:                                  ; preds = %cond.false.1800
  %295 = load i64, i64* %noverlays, align 8
  %mul1807 = mul i64 %295, 8
  %sub1808 = sub i64 %mul1807, -9223372036854775808
  %add1809 = add nsw i64 %sub1808, -9223372036854775808
  br label %cond.end.1810

cond.end.1810:                                    ; preds = %cond.false.1806, %cond.true.1804
  %cond1811 = phi i64 [ %mul1805, %cond.true.1804 ], [ %add1809, %cond.false.1806 ]
  store i64 %cond1811, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2202, label %lor.lhs.false.2199

cond.false.1812:                                  ; preds = %cond.false.1424
  br i1 false, label %cond.true.1813, label %cond.false.2006

cond.true.1813:                                   ; preds = %cond.false.1812
  %296 = load i64, i64* %noverlays, align 8
  %add1814 = add nsw i64 0, %296
  %mul1815 = mul nsw i64 0, %add1814
  %sub1816 = sub nsw i64 %mul1815, 1
  %cmp1817 = icmp slt i64 %sub1816, 0
  br i1 %cmp1817, label %cond.true.1819, label %cond.false.1836

cond.true.1819:                                   ; preds = %cond.true.1813
  %297 = load i64, i64* %noverlays, align 8
  %add1820 = add nsw i64 0, %297
  %mul1821 = mul nsw i64 0, %add1820
  %add1822 = add nsw i64 %mul1821, 0
  %neg1823 = xor i64 %add1822, -1
  %cmp1824 = icmp eq i64 %neg1823, -1
  %conv1825 = zext i1 %cmp1824 to i32
  %sub1826 = sub nsw i32 0, %conv1825
  %conv1827 = sext i32 %sub1826 to i64
  %298 = load i64, i64* %noverlays, align 8
  %add1828 = add nsw i64 0, %298
  %mul1829 = mul nsw i64 0, %add1828
  %add1830 = add nsw i64 %mul1829, 1
  %shl1831 = shl i64 %add1830, 62
  %sub1832 = sub nsw i64 %shl1831, 1
  %mul1833 = mul nsw i64 %sub1832, 2
  %add1834 = add nsw i64 %mul1833, 1
  %sub1835 = sub nsw i64 %conv1827, %add1834
  br label %cond.end.1840

cond.false.1836:                                  ; preds = %cond.true.1813
  %299 = load i64, i64* %noverlays, align 8
  %add1837 = add nsw i64 0, %299
  %mul1838 = mul nsw i64 0, %add1837
  %add1839 = add nsw i64 %mul1838, 0
  br label %cond.end.1840

cond.end.1840:                                    ; preds = %cond.false.1836, %cond.true.1819
  %cond1841 = phi i64 [ %sub1835, %cond.true.1819 ], [ %add1839, %cond.false.1836 ]
  %cmp1842 = icmp eq i64 %cond1841, 0
  br i1 %cmp1842, label %land.lhs.true.1844, label %lor.lhs.false.1847

land.lhs.true.1844:                               ; preds = %cond.end.1840
  %300 = load i64, i64* %noverlays, align 8
  %cmp1845 = icmp slt i64 %300, 0
  br i1 %cmp1845, label %cond.true.1982, label %lor.lhs.false.1847

lor.lhs.false.1847:                               ; preds = %land.lhs.true.1844, %cond.end.1840
  br i1 false, label %cond.true.1848, label %cond.false.1908

cond.true.1848:                                   ; preds = %lor.lhs.false.1847
  %301 = load i64, i64* %noverlays, align 8
  %cmp1849 = icmp slt i64 %301, 0
  br i1 %cmp1849, label %cond.true.1851, label %cond.false.1874

cond.true.1851:                                   ; preds = %cond.true.1848
  %302 = load i64, i64* %noverlays, align 8
  %303 = load i64, i64* %noverlays, align 8
  %add1852 = add nsw i64 0, %303
  %mul1853 = mul nsw i64 0, %add1852
  %sub1854 = sub nsw i64 %mul1853, 1
  %cmp1855 = icmp slt i64 %sub1854, 0
  br i1 %cmp1855, label %cond.true.1857, label %cond.false.1865

cond.true.1857:                                   ; preds = %cond.true.1851
  %304 = load i64, i64* %noverlays, align 8
  %add1858 = add nsw i64 0, %304
  %mul1859 = mul nsw i64 0, %add1858
  %add1860 = add nsw i64 %mul1859, 1
  %shl1861 = shl i64 %add1860, 62
  %sub1862 = sub nsw i64 %shl1861, 1
  %mul1863 = mul nsw i64 %sub1862, 2
  %add1864 = add nsw i64 %mul1863, 1
  br label %cond.end.1869

cond.false.1865:                                  ; preds = %cond.true.1851
  %305 = load i64, i64* %noverlays, align 8
  %add1866 = add nsw i64 0, %305
  %mul1867 = mul nsw i64 0, %add1866
  %sub1868 = sub nsw i64 %mul1867, 1
  br label %cond.end.1869

cond.end.1869:                                    ; preds = %cond.false.1865, %cond.true.1857
  %cond1870 = phi i64 [ %add1864, %cond.true.1857 ], [ %sub1868, %cond.false.1865 ]
  %div1871 = sdiv i64 %cond1870, 8
  %cmp1872 = icmp slt i64 %302, %div1871
  br i1 %cmp1872, label %cond.true.1982, label %lor.lhs.false.1968

cond.false.1874:                                  ; preds = %cond.true.1848
  br i1 false, label %cond.true.1875, label %cond.false.1876

cond.true.1875:                                   ; preds = %cond.false.1874
  br i1 false, label %cond.true.1982, label %lor.lhs.false.1968

cond.false.1876:                                  ; preds = %cond.false.1874
  %306 = load i64, i64* %noverlays, align 8
  %add1877 = add nsw i64 0, %306
  %mul1878 = mul nsw i64 0, %add1877
  %sub1879 = sub nsw i64 %mul1878, 1
  %cmp1880 = icmp slt i64 %sub1879, 0
  br i1 %cmp1880, label %cond.true.1882, label %cond.false.1899

cond.true.1882:                                   ; preds = %cond.false.1876
  %307 = load i64, i64* %noverlays, align 8
  %add1883 = add nsw i64 0, %307
  %mul1884 = mul nsw i64 0, %add1883
  %add1885 = add nsw i64 %mul1884, 0
  %neg1886 = xor i64 %add1885, -1
  %cmp1887 = icmp eq i64 %neg1886, -1
  %conv1888 = zext i1 %cmp1887 to i32
  %sub1889 = sub nsw i32 0, %conv1888
  %conv1890 = sext i32 %sub1889 to i64
  %308 = load i64, i64* %noverlays, align 8
  %add1891 = add nsw i64 0, %308
  %mul1892 = mul nsw i64 0, %add1891
  %add1893 = add nsw i64 %mul1892, 1
  %shl1894 = shl i64 %add1893, 62
  %sub1895 = sub nsw i64 %shl1894, 1
  %mul1896 = mul nsw i64 %sub1895, 2
  %add1897 = add nsw i64 %mul1896, 1
  %sub1898 = sub nsw i64 %conv1890, %add1897
  br label %cond.end.1903

cond.false.1899:                                  ; preds = %cond.false.1876
  %309 = load i64, i64* %noverlays, align 8
  %add1900 = add nsw i64 0, %309
  %mul1901 = mul nsw i64 0, %add1900
  %add1902 = add nsw i64 %mul1901, 0
  br label %cond.end.1903

cond.end.1903:                                    ; preds = %cond.false.1899, %cond.true.1882
  %cond1904 = phi i64 [ %sub1898, %cond.true.1882 ], [ %add1902, %cond.false.1899 ]
  %div1905 = sdiv i64 %cond1904, 8
  %310 = load i64, i64* %noverlays, align 8
  %cmp1906 = icmp slt i64 %div1905, %310
  br i1 %cmp1906, label %cond.true.1982, label %lor.lhs.false.1968

cond.false.1908:                                  ; preds = %lor.lhs.false.1847
  br i1 false, label %cond.true.1909, label %cond.false.1910

cond.true.1909:                                   ; preds = %cond.false.1908
  br i1 false, label %cond.true.1982, label %lor.lhs.false.1968

cond.false.1910:                                  ; preds = %cond.false.1908
  %311 = load i64, i64* %noverlays, align 8
  %cmp1911 = icmp slt i64 %311, 0
  br i1 %cmp1911, label %cond.true.1913, label %cond.false.1945

cond.true.1913:                                   ; preds = %cond.false.1910
  %312 = load i64, i64* %noverlays, align 8
  %313 = load i64, i64* %noverlays, align 8
  %add1914 = add nsw i64 0, %313
  %mul1915 = mul nsw i64 0, %add1914
  %sub1916 = sub nsw i64 %mul1915, 1
  %cmp1917 = icmp slt i64 %sub1916, 0
  br i1 %cmp1917, label %cond.true.1919, label %cond.false.1936

cond.true.1919:                                   ; preds = %cond.true.1913
  %314 = load i64, i64* %noverlays, align 8
  %add1920 = add nsw i64 0, %314
  %mul1921 = mul nsw i64 0, %add1920
  %add1922 = add nsw i64 %mul1921, 0
  %neg1923 = xor i64 %add1922, -1
  %cmp1924 = icmp eq i64 %neg1923, -1
  %conv1925 = zext i1 %cmp1924 to i32
  %sub1926 = sub nsw i32 0, %conv1925
  %conv1927 = sext i32 %sub1926 to i64
  %315 = load i64, i64* %noverlays, align 8
  %add1928 = add nsw i64 0, %315
  %mul1929 = mul nsw i64 0, %add1928
  %add1930 = add nsw i64 %mul1929, 1
  %shl1931 = shl i64 %add1930, 62
  %sub1932 = sub nsw i64 %shl1931, 1
  %mul1933 = mul nsw i64 %sub1932, 2
  %add1934 = add nsw i64 %mul1933, 1
  %sub1935 = sub nsw i64 %conv1927, %add1934
  br label %cond.end.1940

cond.false.1936:                                  ; preds = %cond.true.1913
  %316 = load i64, i64* %noverlays, align 8
  %add1937 = add nsw i64 0, %316
  %mul1938 = mul nsw i64 0, %add1937
  %add1939 = add nsw i64 %mul1938, 0
  br label %cond.end.1940

cond.end.1940:                                    ; preds = %cond.false.1936, %cond.true.1919
  %cond1941 = phi i64 [ %sub1935, %cond.true.1919 ], [ %add1939, %cond.false.1936 ]
  %div1942 = sdiv i64 %cond1941, 8
  %cmp1943 = icmp slt i64 %312, %div1942
  br i1 %cmp1943, label %cond.true.1982, label %lor.lhs.false.1968

cond.false.1945:                                  ; preds = %cond.false.1910
  %317 = load i64, i64* %noverlays, align 8
  %add1946 = add nsw i64 0, %317
  %mul1947 = mul nsw i64 0, %add1946
  %sub1948 = sub nsw i64 %mul1947, 1
  %cmp1949 = icmp slt i64 %sub1948, 0
  br i1 %cmp1949, label %cond.true.1951, label %cond.false.1959

cond.true.1951:                                   ; preds = %cond.false.1945
  %318 = load i64, i64* %noverlays, align 8
  %add1952 = add nsw i64 0, %318
  %mul1953 = mul nsw i64 0, %add1952
  %add1954 = add nsw i64 %mul1953, 1
  %shl1955 = shl i64 %add1954, 62
  %sub1956 = sub nsw i64 %shl1955, 1
  %mul1957 = mul nsw i64 %sub1956, 2
  %add1958 = add nsw i64 %mul1957, 1
  br label %cond.end.1963

cond.false.1959:                                  ; preds = %cond.false.1945
  %319 = load i64, i64* %noverlays, align 8
  %add1960 = add nsw i64 0, %319
  %mul1961 = mul nsw i64 0, %add1960
  %sub1962 = sub nsw i64 %mul1961, 1
  br label %cond.end.1963

cond.end.1963:                                    ; preds = %cond.false.1959, %cond.true.1951
  %cond1964 = phi i64 [ %add1958, %cond.true.1951 ], [ %sub1962, %cond.false.1959 ]
  %div1965 = sdiv i64 %cond1964, 8
  %320 = load i64, i64* %noverlays, align 8
  %cmp1966 = icmp slt i64 %div1965, %320
  br i1 %cmp1966, label %cond.true.1982, label %lor.lhs.false.1968

lor.lhs.false.1968:                               ; preds = %cond.end.1963, %cond.end.1940, %cond.true.1909, %cond.end.1903, %cond.true.1875, %cond.end.1869
  %321 = load i64, i64* %noverlays, align 8
  %mul1969 = mul nsw i64 %321, 8
  %mul1970 = mul nsw i64 0, %mul1969
  %sub1971 = sub nsw i64 %mul1970, 1
  %cmp1972 = icmp slt i64 %sub1971, 0
  br i1 %cmp1972, label %land.lhs.true.1974, label %lor.lhs.false.1978

land.lhs.true.1974:                               ; preds = %lor.lhs.false.1968
  %322 = load i64, i64* %noverlays, align 8
  %mul1975 = mul nsw i64 %322, 8
  %cmp1976 = icmp slt i64 %mul1975, -9223372036854775808
  br i1 %cmp1976, label %cond.true.1982, label %lor.lhs.false.1978

lor.lhs.false.1978:                               ; preds = %land.lhs.true.1974, %lor.lhs.false.1968
  %323 = load i64, i64* %noverlays, align 8
  %mul1979 = mul nsw i64 %323, 8
  %cmp1980 = icmp slt i64 9223372036854775807, %mul1979
  br i1 %cmp1980, label %cond.true.1982, label %cond.false.1994

cond.true.1982:                                   ; preds = %lor.lhs.false.1978, %land.lhs.true.1974, %cond.end.1963, %cond.end.1940, %cond.true.1909, %cond.end.1903, %cond.true.1875, %cond.end.1869, %land.lhs.true.1844
  %324 = load i64, i64* %noverlays, align 8
  %mul1983 = mul i64 %324, 8
  %cmp1984 = icmp ule i64 %mul1983, 9223372036854775807
  br i1 %cmp1984, label %cond.true.1986, label %cond.false.1988

cond.true.1986:                                   ; preds = %cond.true.1982
  %325 = load i64, i64* %noverlays, align 8
  %mul1987 = mul i64 %325, 8
  br label %cond.end.1992

cond.false.1988:                                  ; preds = %cond.true.1982
  %326 = load i64, i64* %noverlays, align 8
  %mul1989 = mul i64 %326, 8
  %sub1990 = sub i64 %mul1989, -9223372036854775808
  %add1991 = add nsw i64 %sub1990, -9223372036854775808
  br label %cond.end.1992

cond.end.1992:                                    ; preds = %cond.false.1988, %cond.true.1986
  %cond1993 = phi i64 [ %mul1987, %cond.true.1986 ], [ %add1991, %cond.false.1988 ]
  store i64 %cond1993, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2202, label %lor.lhs.false.2199

cond.false.1994:                                  ; preds = %lor.lhs.false.1978
  %327 = load i64, i64* %noverlays, align 8
  %mul1995 = mul i64 %327, 8
  %cmp1996 = icmp ule i64 %mul1995, 9223372036854775807
  br i1 %cmp1996, label %cond.true.1998, label %cond.false.2000

cond.true.1998:                                   ; preds = %cond.false.1994
  %328 = load i64, i64* %noverlays, align 8
  %mul1999 = mul i64 %328, 8
  br label %cond.end.2004

cond.false.2000:                                  ; preds = %cond.false.1994
  %329 = load i64, i64* %noverlays, align 8
  %mul2001 = mul i64 %329, 8
  %sub2002 = sub i64 %mul2001, -9223372036854775808
  %add2003 = add nsw i64 %sub2002, -9223372036854775808
  br label %cond.end.2004

cond.end.2004:                                    ; preds = %cond.false.2000, %cond.true.1998
  %cond2005 = phi i64 [ %mul1999, %cond.true.1998 ], [ %add2003, %cond.false.2000 ]
  store i64 %cond2005, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2202, label %lor.lhs.false.2199

cond.false.2006:                                  ; preds = %cond.false.1812
  %330 = load i64, i64* %noverlays, align 8
  %add2007 = add nsw i64 0, %330
  %mul2008 = mul nsw i64 0, %add2007
  %sub2009 = sub nsw i64 %mul2008, 1
  %cmp2010 = icmp slt i64 %sub2009, 0
  br i1 %cmp2010, label %cond.true.2012, label %cond.false.2029

cond.true.2012:                                   ; preds = %cond.false.2006
  %331 = load i64, i64* %noverlays, align 8
  %add2013 = add nsw i64 0, %331
  %mul2014 = mul nsw i64 0, %add2013
  %add2015 = add nsw i64 %mul2014, 0
  %neg2016 = xor i64 %add2015, -1
  %cmp2017 = icmp eq i64 %neg2016, -1
  %conv2018 = zext i1 %cmp2017 to i32
  %sub2019 = sub nsw i32 0, %conv2018
  %conv2020 = sext i32 %sub2019 to i64
  %332 = load i64, i64* %noverlays, align 8
  %add2021 = add nsw i64 0, %332
  %mul2022 = mul nsw i64 0, %add2021
  %add2023 = add nsw i64 %mul2022, 1
  %shl2024 = shl i64 %add2023, 62
  %sub2025 = sub nsw i64 %shl2024, 1
  %mul2026 = mul nsw i64 %sub2025, 2
  %add2027 = add nsw i64 %mul2026, 1
  %sub2028 = sub nsw i64 %conv2020, %add2027
  br label %cond.end.2033

cond.false.2029:                                  ; preds = %cond.false.2006
  %333 = load i64, i64* %noverlays, align 8
  %add2030 = add nsw i64 0, %333
  %mul2031 = mul nsw i64 0, %add2030
  %add2032 = add nsw i64 %mul2031, 0
  br label %cond.end.2033

cond.end.2033:                                    ; preds = %cond.false.2029, %cond.true.2012
  %cond2034 = phi i64 [ %sub2028, %cond.true.2012 ], [ %add2032, %cond.false.2029 ]
  %cmp2035 = icmp eq i64 %cond2034, 0
  br i1 %cmp2035, label %land.lhs.true.2037, label %lor.lhs.false.2040

land.lhs.true.2037:                               ; preds = %cond.end.2033
  %334 = load i64, i64* %noverlays, align 8
  %cmp2038 = icmp slt i64 %334, 0
  br i1 %cmp2038, label %cond.true.2175, label %lor.lhs.false.2040

lor.lhs.false.2040:                               ; preds = %land.lhs.true.2037, %cond.end.2033
  br i1 false, label %cond.true.2041, label %cond.false.2101

cond.true.2041:                                   ; preds = %lor.lhs.false.2040
  %335 = load i64, i64* %noverlays, align 8
  %cmp2042 = icmp slt i64 %335, 0
  br i1 %cmp2042, label %cond.true.2044, label %cond.false.2067

cond.true.2044:                                   ; preds = %cond.true.2041
  %336 = load i64, i64* %noverlays, align 8
  %337 = load i64, i64* %noverlays, align 8
  %add2045 = add nsw i64 0, %337
  %mul2046 = mul nsw i64 0, %add2045
  %sub2047 = sub nsw i64 %mul2046, 1
  %cmp2048 = icmp slt i64 %sub2047, 0
  br i1 %cmp2048, label %cond.true.2050, label %cond.false.2058

cond.true.2050:                                   ; preds = %cond.true.2044
  %338 = load i64, i64* %noverlays, align 8
  %add2051 = add nsw i64 0, %338
  %mul2052 = mul nsw i64 0, %add2051
  %add2053 = add nsw i64 %mul2052, 1
  %shl2054 = shl i64 %add2053, 62
  %sub2055 = sub nsw i64 %shl2054, 1
  %mul2056 = mul nsw i64 %sub2055, 2
  %add2057 = add nsw i64 %mul2056, 1
  br label %cond.end.2062

cond.false.2058:                                  ; preds = %cond.true.2044
  %339 = load i64, i64* %noverlays, align 8
  %add2059 = add nsw i64 0, %339
  %mul2060 = mul nsw i64 0, %add2059
  %sub2061 = sub nsw i64 %mul2060, 1
  br label %cond.end.2062

cond.end.2062:                                    ; preds = %cond.false.2058, %cond.true.2050
  %cond2063 = phi i64 [ %add2057, %cond.true.2050 ], [ %sub2061, %cond.false.2058 ]
  %div2064 = sdiv i64 %cond2063, 8
  %cmp2065 = icmp slt i64 %336, %div2064
  br i1 %cmp2065, label %cond.true.2175, label %lor.lhs.false.2161

cond.false.2067:                                  ; preds = %cond.true.2041
  br i1 false, label %cond.true.2068, label %cond.false.2069

cond.true.2068:                                   ; preds = %cond.false.2067
  br i1 false, label %cond.true.2175, label %lor.lhs.false.2161

cond.false.2069:                                  ; preds = %cond.false.2067
  %340 = load i64, i64* %noverlays, align 8
  %add2070 = add nsw i64 0, %340
  %mul2071 = mul nsw i64 0, %add2070
  %sub2072 = sub nsw i64 %mul2071, 1
  %cmp2073 = icmp slt i64 %sub2072, 0
  br i1 %cmp2073, label %cond.true.2075, label %cond.false.2092

cond.true.2075:                                   ; preds = %cond.false.2069
  %341 = load i64, i64* %noverlays, align 8
  %add2076 = add nsw i64 0, %341
  %mul2077 = mul nsw i64 0, %add2076
  %add2078 = add nsw i64 %mul2077, 0
  %neg2079 = xor i64 %add2078, -1
  %cmp2080 = icmp eq i64 %neg2079, -1
  %conv2081 = zext i1 %cmp2080 to i32
  %sub2082 = sub nsw i32 0, %conv2081
  %conv2083 = sext i32 %sub2082 to i64
  %342 = load i64, i64* %noverlays, align 8
  %add2084 = add nsw i64 0, %342
  %mul2085 = mul nsw i64 0, %add2084
  %add2086 = add nsw i64 %mul2085, 1
  %shl2087 = shl i64 %add2086, 62
  %sub2088 = sub nsw i64 %shl2087, 1
  %mul2089 = mul nsw i64 %sub2088, 2
  %add2090 = add nsw i64 %mul2089, 1
  %sub2091 = sub nsw i64 %conv2083, %add2090
  br label %cond.end.2096

cond.false.2092:                                  ; preds = %cond.false.2069
  %343 = load i64, i64* %noverlays, align 8
  %add2093 = add nsw i64 0, %343
  %mul2094 = mul nsw i64 0, %add2093
  %add2095 = add nsw i64 %mul2094, 0
  br label %cond.end.2096

cond.end.2096:                                    ; preds = %cond.false.2092, %cond.true.2075
  %cond2097 = phi i64 [ %sub2091, %cond.true.2075 ], [ %add2095, %cond.false.2092 ]
  %div2098 = sdiv i64 %cond2097, 8
  %344 = load i64, i64* %noverlays, align 8
  %cmp2099 = icmp slt i64 %div2098, %344
  br i1 %cmp2099, label %cond.true.2175, label %lor.lhs.false.2161

cond.false.2101:                                  ; preds = %lor.lhs.false.2040
  br i1 false, label %cond.true.2102, label %cond.false.2103

cond.true.2102:                                   ; preds = %cond.false.2101
  br i1 false, label %cond.true.2175, label %lor.lhs.false.2161

cond.false.2103:                                  ; preds = %cond.false.2101
  %345 = load i64, i64* %noverlays, align 8
  %cmp2104 = icmp slt i64 %345, 0
  br i1 %cmp2104, label %cond.true.2106, label %cond.false.2138

cond.true.2106:                                   ; preds = %cond.false.2103
  %346 = load i64, i64* %noverlays, align 8
  %347 = load i64, i64* %noverlays, align 8
  %add2107 = add nsw i64 0, %347
  %mul2108 = mul nsw i64 0, %add2107
  %sub2109 = sub nsw i64 %mul2108, 1
  %cmp2110 = icmp slt i64 %sub2109, 0
  br i1 %cmp2110, label %cond.true.2112, label %cond.false.2129

cond.true.2112:                                   ; preds = %cond.true.2106
  %348 = load i64, i64* %noverlays, align 8
  %add2113 = add nsw i64 0, %348
  %mul2114 = mul nsw i64 0, %add2113
  %add2115 = add nsw i64 %mul2114, 0
  %neg2116 = xor i64 %add2115, -1
  %cmp2117 = icmp eq i64 %neg2116, -1
  %conv2118 = zext i1 %cmp2117 to i32
  %sub2119 = sub nsw i32 0, %conv2118
  %conv2120 = sext i32 %sub2119 to i64
  %349 = load i64, i64* %noverlays, align 8
  %add2121 = add nsw i64 0, %349
  %mul2122 = mul nsw i64 0, %add2121
  %add2123 = add nsw i64 %mul2122, 1
  %shl2124 = shl i64 %add2123, 62
  %sub2125 = sub nsw i64 %shl2124, 1
  %mul2126 = mul nsw i64 %sub2125, 2
  %add2127 = add nsw i64 %mul2126, 1
  %sub2128 = sub nsw i64 %conv2120, %add2127
  br label %cond.end.2133

cond.false.2129:                                  ; preds = %cond.true.2106
  %350 = load i64, i64* %noverlays, align 8
  %add2130 = add nsw i64 0, %350
  %mul2131 = mul nsw i64 0, %add2130
  %add2132 = add nsw i64 %mul2131, 0
  br label %cond.end.2133

cond.end.2133:                                    ; preds = %cond.false.2129, %cond.true.2112
  %cond2134 = phi i64 [ %sub2128, %cond.true.2112 ], [ %add2132, %cond.false.2129 ]
  %div2135 = sdiv i64 %cond2134, 8
  %cmp2136 = icmp slt i64 %346, %div2135
  br i1 %cmp2136, label %cond.true.2175, label %lor.lhs.false.2161

cond.false.2138:                                  ; preds = %cond.false.2103
  %351 = load i64, i64* %noverlays, align 8
  %add2139 = add nsw i64 0, %351
  %mul2140 = mul nsw i64 0, %add2139
  %sub2141 = sub nsw i64 %mul2140, 1
  %cmp2142 = icmp slt i64 %sub2141, 0
  br i1 %cmp2142, label %cond.true.2144, label %cond.false.2152

cond.true.2144:                                   ; preds = %cond.false.2138
  %352 = load i64, i64* %noverlays, align 8
  %add2145 = add nsw i64 0, %352
  %mul2146 = mul nsw i64 0, %add2145
  %add2147 = add nsw i64 %mul2146, 1
  %shl2148 = shl i64 %add2147, 62
  %sub2149 = sub nsw i64 %shl2148, 1
  %mul2150 = mul nsw i64 %sub2149, 2
  %add2151 = add nsw i64 %mul2150, 1
  br label %cond.end.2156

cond.false.2152:                                  ; preds = %cond.false.2138
  %353 = load i64, i64* %noverlays, align 8
  %add2153 = add nsw i64 0, %353
  %mul2154 = mul nsw i64 0, %add2153
  %sub2155 = sub nsw i64 %mul2154, 1
  br label %cond.end.2156

cond.end.2156:                                    ; preds = %cond.false.2152, %cond.true.2144
  %cond2157 = phi i64 [ %add2151, %cond.true.2144 ], [ %sub2155, %cond.false.2152 ]
  %div2158 = sdiv i64 %cond2157, 8
  %354 = load i64, i64* %noverlays, align 8
  %cmp2159 = icmp slt i64 %div2158, %354
  br i1 %cmp2159, label %cond.true.2175, label %lor.lhs.false.2161

lor.lhs.false.2161:                               ; preds = %cond.end.2156, %cond.end.2133, %cond.true.2102, %cond.end.2096, %cond.true.2068, %cond.end.2062
  %355 = load i64, i64* %noverlays, align 8
  %mul2162 = mul nsw i64 %355, 8
  %mul2163 = mul nsw i64 0, %mul2162
  %sub2164 = sub nsw i64 %mul2163, 1
  %cmp2165 = icmp slt i64 %sub2164, 0
  br i1 %cmp2165, label %land.lhs.true.2167, label %lor.lhs.false.2171

land.lhs.true.2167:                               ; preds = %lor.lhs.false.2161
  %356 = load i64, i64* %noverlays, align 8
  %mul2168 = mul nsw i64 %356, 8
  %cmp2169 = icmp slt i64 %mul2168, -9223372036854775808
  br i1 %cmp2169, label %cond.true.2175, label %lor.lhs.false.2171

lor.lhs.false.2171:                               ; preds = %land.lhs.true.2167, %lor.lhs.false.2161
  %357 = load i64, i64* %noverlays, align 8
  %mul2172 = mul nsw i64 %357, 8
  %cmp2173 = icmp slt i64 9223372036854775807, %mul2172
  br i1 %cmp2173, label %cond.true.2175, label %cond.false.2187

cond.true.2175:                                   ; preds = %lor.lhs.false.2171, %land.lhs.true.2167, %cond.end.2156, %cond.end.2133, %cond.true.2102, %cond.end.2096, %cond.true.2068, %cond.end.2062, %land.lhs.true.2037
  %358 = load i64, i64* %noverlays, align 8
  %mul2176 = mul i64 %358, 8
  %cmp2177 = icmp ule i64 %mul2176, 9223372036854775807
  br i1 %cmp2177, label %cond.true.2179, label %cond.false.2181

cond.true.2179:                                   ; preds = %cond.true.2175
  %359 = load i64, i64* %noverlays, align 8
  %mul2180 = mul i64 %359, 8
  br label %cond.end.2185

cond.false.2181:                                  ; preds = %cond.true.2175
  %360 = load i64, i64* %noverlays, align 8
  %mul2182 = mul i64 %360, 8
  %sub2183 = sub i64 %mul2182, -9223372036854775808
  %add2184 = add nsw i64 %sub2183, -9223372036854775808
  br label %cond.end.2185

cond.end.2185:                                    ; preds = %cond.false.2181, %cond.true.2179
  %cond2186 = phi i64 [ %mul2180, %cond.true.2179 ], [ %add2184, %cond.false.2181 ]
  store i64 %cond2186, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2202, label %lor.lhs.false.2199

cond.false.2187:                                  ; preds = %lor.lhs.false.2171
  %361 = load i64, i64* %noverlays, align 8
  %mul2188 = mul i64 %361, 8
  %cmp2189 = icmp ule i64 %mul2188, 9223372036854775807
  br i1 %cmp2189, label %cond.true.2191, label %cond.false.2193

cond.true.2191:                                   ; preds = %cond.false.2187
  %362 = load i64, i64* %noverlays, align 8
  %mul2192 = mul i64 %362, 8
  br label %cond.end.2197

cond.false.2193:                                  ; preds = %cond.false.2187
  %363 = load i64, i64* %noverlays, align 8
  %mul2194 = mul i64 %363, 8
  %sub2195 = sub i64 %mul2194, -9223372036854775808
  %add2196 = add nsw i64 %sub2195, -9223372036854775808
  br label %cond.end.2197

cond.end.2197:                                    ; preds = %cond.false.2193, %cond.true.2191
  %cond2198 = phi i64 [ %mul2192, %cond.true.2191 ], [ %add2196, %cond.false.2193 ]
  store i64 %cond2198, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2202, label %lor.lhs.false.2199

lor.lhs.false.2199:                               ; preds = %cond.end.2197, %cond.end.2185, %cond.end.2004, %cond.end.1992, %cond.end.1810, %cond.end.1798, %cond.end.1617, %cond.end.1605, %cond.end.1421, %cond.end.1405, %cond.end.1220, %cond.end.1204, %cond.end.992, %cond.end.969, %cond.end.777, %cond.end.754, %cond.end.507, %cond.end.484, %cond.end.292, %cond.end.269
  %364 = load i64, i64* %alloca_nbytes, align 8
  %cmp2200 = icmp ult i64 -1, %364
  br i1 %cmp2200, label %if.then.2202, label %if.else.2203

if.then.2202:                                     ; preds = %lor.lhs.false.2199, %cond.end.2197, %cond.end.2185, %cond.end.2004, %cond.end.1992, %cond.end.1810, %cond.end.1798, %cond.end.1617, %cond.end.1605, %cond.end.1421, %cond.end.1405, %cond.end.1220, %cond.end.1204, %cond.end.992, %cond.end.969, %cond.end.777, %cond.end.754, %cond.end.507, %cond.end.484, %cond.end.292, %cond.end.269
  call void @memory_full(i64 -1) #9
  unreachable

if.else.2203:                                     ; preds = %lor.lhs.false.2199
  %365 = load i64, i64* %alloca_nbytes, align 8
  %366 = load i64, i64* %sa_avail, align 8
  %cmp2204 = icmp sle i64 %365, %366
  br i1 %cmp2204, label %if.then.2206, label %if.else.2208

if.then.2206:                                     ; preds = %if.else.2203
  %367 = load i64, i64* %alloca_nbytes, align 8
  %368 = load i64, i64* %sa_avail, align 8
  %sub2207 = sub nsw i64 %368, %367
  store i64 %sub2207, i64* %sa_avail, align 8
  %369 = load i64, i64* %alloca_nbytes, align 8
  %370 = alloca i8, i64 %369
  %371 = bitcast i8* %370 to i64*
  store i64* %371, i64** %overlay_vec, align 8
  br label %if.end.2211

if.else.2208:                                     ; preds = %if.else.2203
  %372 = load i64, i64* %alloca_nbytes, align 8
  %call2209 = call noalias i8* @xmalloc(i64 %372)
  %373 = bitcast i8* %call2209 to i64*
  store i64* %373, i64** %overlay_vec, align 8
  %374 = load i64*, i64** %overlay_vec, align 8
  %375 = load i64, i64* %noverlays, align 8
  %call2210 = call i64 @make_save_memory(i64* %374, i64 %375)
  store i64 %call2210, i64* %arg_, align 8
  store i8 1, i8* %sa_must_free, align 1
  %376 = load i64, i64* %arg_, align 8
  call void @record_unwind_protect(void (i64)* @free_save_value, i64 %376)
  br label %if.end.2211

if.end.2211:                                      ; preds = %if.else.2208, %if.then.2206
  br label %if.end.2212

if.end.2212:                                      ; preds = %if.end.2211
  br label %do.end.2213

do.end.2213:                                      ; preds = %if.end.2212
  %377 = load i64, i64* %posn, align 8
  %378 = load i64*, i64** %overlay_vec, align 8
  %379 = load i64, i64* %noverlays, align 8
  %call2214 = call i64 @overlays_around(i64 %377, i64* %378, i64 %379)
  store i64 %call2214, i64* %noverlays, align 8
  br label %if.end.2215

if.end.2215:                                      ; preds = %do.end.2213, %if.else.26
  %380 = load i64*, i64** %overlay_vec, align 8
  %381 = load i64, i64* %noverlays, align 8
  %call2216 = call i64 @sort_overlays(i64* %380, i64 %381, %struct.window* null)
  store i64 %call2216, i64* %noverlays, align 8
  %382 = load %struct.buffer*, %struct.buffer** %obuf, align 8
  call void @set_buffer_temp(%struct.buffer* %382)
  br label %while.cond

while.cond:                                       ; preds = %if.end.2280, %if.end.2215
  %383 = load i64, i64* %noverlays, align 8
  %dec = add nsw i64 %383, -1
  store i64 %dec, i64* %noverlays, align 8
  %cmp2217 = icmp sge i64 %dec, 0
  br i1 %cmp2217, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %384 = load i64, i64* %noverlays, align 8
  %385 = load i64*, i64** %overlay_vec, align 8
  %arrayidx = getelementptr inbounds i64, i64* %385, i64 %384
  %386 = load i64, i64* %arrayidx, align 8
  store i64 %386, i64* %ol, align 8
  %387 = load i64, i64* %ol, align 8
  %388 = load i64, i64* %prop.addr, align 8
  %call2219 = call i64 @Foverlay_get(i64 %387, i64 %388)
  store i64 %call2219, i64* %tem, align 8
  %389 = load i64, i64* %tem, align 8
  %call2220 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp2221 = icmp eq i64 %389, %call2220
  br i1 %cmp2221, label %if.end.2280, label %if.then.2223

if.then.2223:                                     ; preds = %while.body
  %390 = load i64, i64* %ol, align 8
  %call2224 = call %struct.Lisp_Overlay* @XOVERLAY(i64 %390)
  %start2225 = getelementptr inbounds %struct.Lisp_Overlay, %struct.Lisp_Overlay* %call2224, i32 0, i32 2
  %391 = load i64, i64* %start2225, align 8
  store i64 %391, i64* %start, align 8
  %392 = load i64, i64* %ol, align 8
  %call2226 = call %struct.Lisp_Overlay* @XOVERLAY(i64 %392)
  %end = getelementptr inbounds %struct.Lisp_Overlay, %struct.Lisp_Overlay* %call2226, i32 0, i32 3
  %393 = load i64, i64* %end, align 8
  store i64 %393, i64* %finish, align 8
  %394 = load i64, i64* %start, align 8
  %and2227 = and i64 %394, 7
  %conv2228 = trunc i64 %and2227 to i32
  %cmp2229 = icmp eq i32 %conv2228, 1
  br i1 %cmp2229, label %land.lhs.true.2231, label %cond.false.2237

land.lhs.true.2231:                               ; preds = %if.then.2223
  %395 = load i64, i64* %start, align 8
  %call2232 = call i32 @XMISCTYPE(i64 %395)
  %cmp2233 = icmp eq i32 %call2232, 24236
  br i1 %cmp2233, label %cond.true.2235, label %cond.false.2237

cond.true.2235:                                   ; preds = %land.lhs.true.2231
  %396 = load i64, i64* %start, align 8
  %call2236 = call i64 @marker_position(i64 %396)
  br label %cond.end.2238

cond.false.2237:                                  ; preds = %land.lhs.true.2231, %if.then.2223
  call void @emacs_abort() #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end.2238

cond.end.2238:                                    ; preds = %397, %cond.true.2235
  %cond2239 = phi i64 [ %call2236, %cond.true.2235 ], [ 0, %397 ]
  %398 = load i64, i64* %posn, align 8
  %cmp2240 = icmp eq i64 %cond2239, %398
  br i1 %cmp2240, label %land.lhs.true.2242, label %lor.lhs.false.2247

land.lhs.true.2242:                               ; preds = %cond.end.2238
  %399 = load i64, i64* %start, align 8
  %call2243 = call %struct.Lisp_Marker* @XMARKER(i64 %399)
  %400 = bitcast %struct.Lisp_Marker* %call2243 to i32*
  %bf.load = load i32, i32* %400, align 8
  %bf.lshr = lshr i32 %bf.load, 31
  %bf.cast = trunc i32 %bf.lshr to i1
  %conv2244 = zext i1 %bf.cast to i32
  %cmp2245 = icmp eq i32 %conv2244, 1
  br i1 %cmp2245, label %if.then.2271, label %lor.lhs.false.2247

lor.lhs.false.2247:                               ; preds = %land.lhs.true.2242, %cond.end.2238
  %401 = load i64, i64* %finish, align 8
  %and2248 = and i64 %401, 7
  %conv2249 = trunc i64 %and2248 to i32
  %cmp2250 = icmp eq i32 %conv2249, 1
  br i1 %cmp2250, label %land.lhs.true.2252, label %cond.false.2258

land.lhs.true.2252:                               ; preds = %lor.lhs.false.2247
  %402 = load i64, i64* %finish, align 8
  %call2253 = call i32 @XMISCTYPE(i64 %402)
  %cmp2254 = icmp eq i32 %call2253, 24236
  br i1 %cmp2254, label %cond.true.2256, label %cond.false.2258

cond.true.2256:                                   ; preds = %land.lhs.true.2252
  %403 = load i64, i64* %finish, align 8
  %call2257 = call i64 @marker_position(i64 %403)
  br label %cond.end.2259

cond.false.2258:                                  ; preds = %land.lhs.true.2252, %lor.lhs.false.2247
  call void @emacs_abort() #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end.2259

cond.end.2259:                                    ; preds = %404, %cond.true.2256
  %cond2260 = phi i64 [ %call2257, %cond.true.2256 ], [ 0, %404 ]
  %405 = load i64, i64* %posn, align 8
  %cmp2261 = icmp eq i64 %cond2260, %405
  br i1 %cmp2261, label %land.lhs.true.2263, label %if.else.2272

land.lhs.true.2263:                               ; preds = %cond.end.2259
  %406 = load i64, i64* %finish, align 8
  %call2264 = call %struct.Lisp_Marker* @XMARKER(i64 %406)
  %407 = bitcast %struct.Lisp_Marker* %call2264 to i32*
  %bf.load2265 = load i32, i32* %407, align 8
  %bf.lshr2266 = lshr i32 %bf.load2265, 31
  %bf.cast2267 = trunc i32 %bf.lshr2266 to i1
  %conv2268 = zext i1 %bf.cast2267 to i32
  %cmp2269 = icmp eq i32 %conv2268, 0
  br i1 %cmp2269, label %if.then.2271, label %if.else.2272

if.then.2271:                                     ; preds = %land.lhs.true.2263, %land.lhs.true.2242
  br label %if.end.2279

if.else.2272:                                     ; preds = %land.lhs.true.2263, %cond.end.2259
  br label %do.body.2273

do.body.2273:                                     ; preds = %if.else.2272
  %408 = load i8, i8* %sa_must_free, align 1
  %tobool = trunc i8 %408 to i1
  br i1 %tobool, label %if.then.2274, label %if.end.2277

if.then.2274:                                     ; preds = %do.body.2273
  store i8 0, i8* %sa_must_free, align 1
  %409 = load i64, i64* %sa_count, align 8
  %call2275 = call i64 @builtin_lisp_symbol(i32 0)
  %call2276 = call i64 @unbind_to(i64 %409, i64 %call2275)
  br label %if.end.2277

if.end.2277:                                      ; preds = %if.then.2274, %do.body.2273
  br label %do.end.2278

do.end.2278:                                      ; preds = %if.end.2277
  %410 = load i64, i64* %tem, align 8
  store i64 %410, i64* %retval
  br label %return

if.end.2279:                                      ; preds = %if.then.2271
  br label %if.end.2280

if.end.2280:                                      ; preds = %if.end.2279, %while.body
  br label %while.cond

while.end:                                        ; preds = %while.cond
  br label %do.body.2281

do.body.2281:                                     ; preds = %while.end
  %411 = load i8, i8* %sa_must_free, align 1
  %tobool2282 = trunc i8 %411 to i1
  br i1 %tobool2282, label %if.then.2283, label %if.end.2286

if.then.2283:                                     ; preds = %do.body.2281
  store i8 0, i8* %sa_must_free, align 1
  %412 = load i64, i64* %sa_count, align 8
  %call2284 = call i64 @builtin_lisp_symbol(i32 0)
  %call2285 = call i64 @unbind_to(i64 %412, i64 %call2284)
  br label %if.end.2286

if.end.2286:                                      ; preds = %if.then.2283, %do.body.2281
  br label %do.end.2287

do.end.2287:                                      ; preds = %if.end.2286
  %413 = load i64, i64* %prop.addr, align 8
  %414 = load i64, i64* %position.addr, align 8
  %415 = load i64, i64* %object.addr, align 8
  %call2288 = call i32 @text_property_stickiness(i64 %413, i64 %414, i64 %415)
  store i32 %call2288, i32* %stickiness, align 4
  %416 = load i32, i32* %stickiness, align 4
  %cmp2289 = icmp sgt i32 %416, 0
  br i1 %cmp2289, label %if.then.2291, label %if.else.2293

if.then.2291:                                     ; preds = %do.end.2287
  %417 = load i64, i64* %position.addr, align 8
  %418 = load i64, i64* %prop.addr, align 8
  %419 = load i64, i64* %object.addr, align 8
  %call2292 = call i64 @Fget_text_property(i64 %417, i64 %418, i64 %419)
  store i64 %call2292, i64* %retval
  br label %return

if.else.2293:                                     ; preds = %do.end.2287
  %420 = load i32, i32* %stickiness, align 4
  %cmp2294 = icmp slt i32 %420, 0
  br i1 %cmp2294, label %land.lhs.true.2296, label %if.else.2326

land.lhs.true.2296:                               ; preds = %if.else.2293
  %421 = load i64, i64* %position.addr, align 8
  %shr2297 = ashr i64 %421, 2
  %422 = load i64, i64* %object.addr, align 8
  %call2298 = call %struct.buffer* @XBUFFER(i64 %422)
  %423 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %cmp2299 = icmp eq %struct.buffer* %call2298, %423
  br i1 %cmp2299, label %cond.true.2301, label %cond.false.2302

cond.true.2301:                                   ; preds = %land.lhs.true.2296
  %424 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv = getelementptr inbounds %struct.buffer, %struct.buffer* %424, i32 0, i32 77
  %425 = load i64, i64* %begv, align 8
  br label %cond.end.2316

cond.false.2302:                                  ; preds = %land.lhs.true.2296
  %426 = load i64, i64* %object.addr, align 8
  %call2303 = call %struct.buffer* @XBUFFER(i64 %426)
  %begv_marker_ = getelementptr inbounds %struct.buffer, %struct.buffer* %call2303, i32 0, i32 46
  %427 = load i64, i64* %begv_marker_, align 8
  %call2304 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp2305 = icmp eq i64 %427, %call2304
  br i1 %cmp2305, label %cond.true.2307, label %cond.false.2310

cond.true.2307:                                   ; preds = %cond.false.2302
  %428 = load i64, i64* %object.addr, align 8
  %call2308 = call %struct.buffer* @XBUFFER(i64 %428)
  %begv2309 = getelementptr inbounds %struct.buffer, %struct.buffer* %call2308, i32 0, i32 77
  %429 = load i64, i64* %begv2309, align 8
  br label %cond.end.2314

cond.false.2310:                                  ; preds = %cond.false.2302
  %430 = load i64, i64* %object.addr, align 8
  %call2311 = call %struct.buffer* @XBUFFER(i64 %430)
  %begv_marker_2312 = getelementptr inbounds %struct.buffer, %struct.buffer* %call2311, i32 0, i32 46
  %431 = load i64, i64* %begv_marker_2312, align 8
  %call2313 = call i64 @marker_position(i64 %431)
  br label %cond.end.2314

cond.end.2314:                                    ; preds = %cond.false.2310, %cond.true.2307
  %cond2315 = phi i64 [ %429, %cond.true.2307 ], [ %call2313, %cond.false.2310 ]
  br label %cond.end.2316

cond.end.2316:                                    ; preds = %cond.end.2314, %cond.true.2301
  %cond2317 = phi i64 [ %425, %cond.true.2301 ], [ %cond2315, %cond.end.2314 ]
  %cmp2318 = icmp sgt i64 %shr2297, %cond2317
  br i1 %cmp2318, label %if.then.2320, label %if.else.2326

if.then.2320:                                     ; preds = %cond.end.2316
  %432 = load i64, i64* %position.addr, align 8
  %shr2321 = ashr i64 %432, 2
  %sub2322 = sub nsw i64 %shr2321, 1
  %shl2323 = shl i64 %sub2322, 2
  %add2324 = add i64 %shl2323, 2
  %433 = load i64, i64* %prop.addr, align 8
  %434 = load i64, i64* %object.addr, align 8
  %call2325 = call i64 @Fget_text_property(i64 %add2324, i64 %433, i64 %434)
  store i64 %call2325, i64* %retval
  br label %return

if.else.2326:                                     ; preds = %cond.end.2316, %if.else.2293
  %call2327 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call2327, i64* %retval
  br label %return

return:                                           ; preds = %if.else.2326, %if.then.2320, %if.then.2291, %do.end.2278, %if.then.24
  %435 = load i64, i64* %retval
  ret i64 %435
}

declare i64 @marker_position(i64) #1

declare i64 @make_lisp_ptr(i8*, i32) #1

declare zeroext i1 @WINDOWP(i64) #1

declare %struct.window* @XWINDOW(i64) #1

declare zeroext i1 @BUFFERP(i64) #1

declare i64 @Fget_text_property(i64, i64, i64) #1

declare i64 @SPECPDL_INDEX() #1

declare void @set_buffer_temp(%struct.buffer*) #1

declare %struct.buffer* @XBUFFER(i64) #1

; Function Attrs: nounwind uwtable
define internal i64 @overlays_around(i64 %pos, i64* %vec, i64 %len) #0 {
entry:
  %pos.addr = alloca i64, align 8
  %vec.addr = alloca i64*, align 8
  %len.addr = alloca i64, align 8
  %overlay = alloca i64, align 8
  %start = alloca i64, align 8
  %end = alloca i64, align 8
  %tail = alloca %struct.Lisp_Overlay*, align 8
  %startpos = alloca i64, align 8
  %endpos = alloca i64, align 8
  %idx = alloca i64, align 8
  store i64 %pos, i64* %pos.addr, align 8
  store i64* %vec, i64** %vec.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i64 0, i64* %idx, align 8
  %0 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %overlays_before = getelementptr inbounds %struct.buffer, %struct.buffer* %0, i32 0, i32 95
  %1 = load %struct.Lisp_Overlay*, %struct.Lisp_Overlay** %overlays_before, align 8
  store %struct.Lisp_Overlay* %1, %struct.Lisp_Overlay** %tail, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load %struct.Lisp_Overlay*, %struct.Lisp_Overlay** %tail, align 8
  %tobool = icmp ne %struct.Lisp_Overlay* %2, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load %struct.Lisp_Overlay*, %struct.Lisp_Overlay** %tail, align 8
  %4 = bitcast %struct.Lisp_Overlay* %3 to i8*
  %call = call i64 @make_lisp_ptr(i8* %4, i32 1)
  store i64 %call, i64* %overlay, align 8
  %5 = load i64, i64* %overlay, align 8
  %call1 = call %struct.Lisp_Overlay* @XOVERLAY(i64 %5)
  %end2 = getelementptr inbounds %struct.Lisp_Overlay, %struct.Lisp_Overlay* %call1, i32 0, i32 3
  %6 = load i64, i64* %end2, align 8
  store i64 %6, i64* %end, align 8
  %7 = load i64, i64* %end, align 8
  %and = and i64 %7, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 1
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %for.body
  %8 = load i64, i64* %end, align 8
  %call4 = call i32 @XMISCTYPE(i64 %8)
  %cmp5 = icmp eq i32 %call4, 24236
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true
  %9 = load i64, i64* %end, align 8
  %call7 = call i64 @marker_position(i64 %9)
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %for.body
  call void @emacs_abort() #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %10, %cond.true
  %cond = phi i64 [ %call7, %cond.true ], [ 0, %10 ]
  store i64 %cond, i64* %endpos, align 8
  %11 = load i64, i64* %endpos, align 8
  %12 = load i64, i64* %pos.addr, align 8
  %cmp8 = icmp slt i64 %11, %12
  br i1 %cmp8, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  br label %for.end

if.end:                                           ; preds = %cond.end
  %13 = load i64, i64* %overlay, align 8
  %call10 = call %struct.Lisp_Overlay* @XOVERLAY(i64 %13)
  %start11 = getelementptr inbounds %struct.Lisp_Overlay, %struct.Lisp_Overlay* %call10, i32 0, i32 2
  %14 = load i64, i64* %start11, align 8
  store i64 %14, i64* %start, align 8
  %15 = load i64, i64* %start, align 8
  %and12 = and i64 %15, 7
  %conv13 = trunc i64 %and12 to i32
  %cmp14 = icmp eq i32 %conv13, 1
  br i1 %cmp14, label %land.lhs.true.16, label %cond.false.22

land.lhs.true.16:                                 ; preds = %if.end
  %16 = load i64, i64* %start, align 8
  %call17 = call i32 @XMISCTYPE(i64 %16)
  %cmp18 = icmp eq i32 %call17, 24236
  br i1 %cmp18, label %cond.true.20, label %cond.false.22

cond.true.20:                                     ; preds = %land.lhs.true.16
  %17 = load i64, i64* %start, align 8
  %call21 = call i64 @marker_position(i64 %17)
  br label %cond.end.23

cond.false.22:                                    ; preds = %land.lhs.true.16, %if.end
  call void @emacs_abort() #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end.23

cond.end.23:                                      ; preds = %18, %cond.true.20
  %cond24 = phi i64 [ %call21, %cond.true.20 ], [ 0, %18 ]
  store i64 %cond24, i64* %startpos, align 8
  %19 = load i64, i64* %startpos, align 8
  %20 = load i64, i64* %pos.addr, align 8
  %cmp25 = icmp sle i64 %19, %20
  br i1 %cmp25, label %if.then.27, label %if.end.32

if.then.27:                                       ; preds = %cond.end.23
  %21 = load i64, i64* %idx, align 8
  %22 = load i64, i64* %len.addr, align 8
  %cmp28 = icmp slt i64 %21, %22
  br i1 %cmp28, label %if.then.30, label %if.end.31

if.then.30:                                       ; preds = %if.then.27
  %23 = load i64, i64* %overlay, align 8
  %24 = load i64, i64* %idx, align 8
  %25 = load i64*, i64** %vec.addr, align 8
  %arrayidx = getelementptr inbounds i64, i64* %25, i64 %24
  store i64 %23, i64* %arrayidx, align 8
  br label %if.end.31

if.end.31:                                        ; preds = %if.then.30, %if.then.27
  %26 = load i64, i64* %idx, align 8
  %inc = add nsw i64 %26, 1
  store i64 %inc, i64* %idx, align 8
  br label %if.end.32

if.end.32:                                        ; preds = %if.end.31, %cond.end.23
  br label %for.inc

for.inc:                                          ; preds = %if.end.32
  %27 = load %struct.Lisp_Overlay*, %struct.Lisp_Overlay** %tail, align 8
  %next = getelementptr inbounds %struct.Lisp_Overlay, %struct.Lisp_Overlay* %27, i32 0, i32 1
  %28 = load %struct.Lisp_Overlay*, %struct.Lisp_Overlay** %next, align 8
  store %struct.Lisp_Overlay* %28, %struct.Lisp_Overlay** %tail, align 8
  br label %for.cond

for.end:                                          ; preds = %if.then, %for.cond
  %29 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %overlays_after = getelementptr inbounds %struct.buffer, %struct.buffer* %29, i32 0, i32 96
  %30 = load %struct.Lisp_Overlay*, %struct.Lisp_Overlay** %overlays_after, align 8
  store %struct.Lisp_Overlay* %30, %struct.Lisp_Overlay** %tail, align 8
  br label %for.cond.33

for.cond.33:                                      ; preds = %for.inc.81, %for.end
  %31 = load %struct.Lisp_Overlay*, %struct.Lisp_Overlay** %tail, align 8
  %tobool34 = icmp ne %struct.Lisp_Overlay* %31, null
  br i1 %tobool34, label %for.body.35, label %for.end.83

for.body.35:                                      ; preds = %for.cond.33
  %32 = load %struct.Lisp_Overlay*, %struct.Lisp_Overlay** %tail, align 8
  %33 = bitcast %struct.Lisp_Overlay* %32 to i8*
  %call36 = call i64 @make_lisp_ptr(i8* %33, i32 1)
  store i64 %call36, i64* %overlay, align 8
  %34 = load i64, i64* %overlay, align 8
  %call37 = call %struct.Lisp_Overlay* @XOVERLAY(i64 %34)
  %start38 = getelementptr inbounds %struct.Lisp_Overlay, %struct.Lisp_Overlay* %call37, i32 0, i32 2
  %35 = load i64, i64* %start38, align 8
  store i64 %35, i64* %start, align 8
  %36 = load i64, i64* %start, align 8
  %and39 = and i64 %36, 7
  %conv40 = trunc i64 %and39 to i32
  %cmp41 = icmp eq i32 %conv40, 1
  br i1 %cmp41, label %land.lhs.true.43, label %cond.false.49

land.lhs.true.43:                                 ; preds = %for.body.35
  %37 = load i64, i64* %start, align 8
  %call44 = call i32 @XMISCTYPE(i64 %37)
  %cmp45 = icmp eq i32 %call44, 24236
  br i1 %cmp45, label %cond.true.47, label %cond.false.49

cond.true.47:                                     ; preds = %land.lhs.true.43
  %38 = load i64, i64* %start, align 8
  %call48 = call i64 @marker_position(i64 %38)
  br label %cond.end.50

cond.false.49:                                    ; preds = %land.lhs.true.43, %for.body.35
  call void @emacs_abort() #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end.50

cond.end.50:                                      ; preds = %39, %cond.true.47
  %cond51 = phi i64 [ %call48, %cond.true.47 ], [ 0, %39 ]
  store i64 %cond51, i64* %startpos, align 8
  %40 = load i64, i64* %pos.addr, align 8
  %41 = load i64, i64* %startpos, align 8
  %cmp52 = icmp slt i64 %40, %41
  br i1 %cmp52, label %if.then.54, label %if.end.55

if.then.54:                                       ; preds = %cond.end.50
  br label %for.end.83

if.end.55:                                        ; preds = %cond.end.50
  %42 = load i64, i64* %overlay, align 8
  %call56 = call %struct.Lisp_Overlay* @XOVERLAY(i64 %42)
  %end57 = getelementptr inbounds %struct.Lisp_Overlay, %struct.Lisp_Overlay* %call56, i32 0, i32 3
  %43 = load i64, i64* %end57, align 8
  store i64 %43, i64* %end, align 8
  %44 = load i64, i64* %end, align 8
  %and58 = and i64 %44, 7
  %conv59 = trunc i64 %and58 to i32
  %cmp60 = icmp eq i32 %conv59, 1
  br i1 %cmp60, label %land.lhs.true.62, label %cond.false.68

land.lhs.true.62:                                 ; preds = %if.end.55
  %45 = load i64, i64* %end, align 8
  %call63 = call i32 @XMISCTYPE(i64 %45)
  %cmp64 = icmp eq i32 %call63, 24236
  br i1 %cmp64, label %cond.true.66, label %cond.false.68

cond.true.66:                                     ; preds = %land.lhs.true.62
  %46 = load i64, i64* %end, align 8
  %call67 = call i64 @marker_position(i64 %46)
  br label %cond.end.69

cond.false.68:                                    ; preds = %land.lhs.true.62, %if.end.55
  call void @emacs_abort() #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end.69

cond.end.69:                                      ; preds = %47, %cond.true.66
  %cond70 = phi i64 [ %call67, %cond.true.66 ], [ 0, %47 ]
  store i64 %cond70, i64* %endpos, align 8
  %48 = load i64, i64* %pos.addr, align 8
  %49 = load i64, i64* %endpos, align 8
  %cmp71 = icmp sle i64 %48, %49
  br i1 %cmp71, label %if.then.73, label %if.end.80

if.then.73:                                       ; preds = %cond.end.69
  %50 = load i64, i64* %idx, align 8
  %51 = load i64, i64* %len.addr, align 8
  %cmp74 = icmp slt i64 %50, %51
  br i1 %cmp74, label %if.then.76, label %if.end.78

if.then.76:                                       ; preds = %if.then.73
  %52 = load i64, i64* %overlay, align 8
  %53 = load i64, i64* %idx, align 8
  %54 = load i64*, i64** %vec.addr, align 8
  %arrayidx77 = getelementptr inbounds i64, i64* %54, i64 %53
  store i64 %52, i64* %arrayidx77, align 8
  br label %if.end.78

if.end.78:                                        ; preds = %if.then.76, %if.then.73
  %55 = load i64, i64* %idx, align 8
  %inc79 = add nsw i64 %55, 1
  store i64 %inc79, i64* %idx, align 8
  br label %if.end.80

if.end.80:                                        ; preds = %if.end.78, %cond.end.69
  br label %for.inc.81

for.inc.81:                                       ; preds = %if.end.80
  %56 = load %struct.Lisp_Overlay*, %struct.Lisp_Overlay** %tail, align 8
  %next82 = getelementptr inbounds %struct.Lisp_Overlay, %struct.Lisp_Overlay* %56, i32 0, i32 1
  %57 = load %struct.Lisp_Overlay*, %struct.Lisp_Overlay** %next82, align 8
  store %struct.Lisp_Overlay* %57, %struct.Lisp_Overlay** %tail, align 8
  br label %for.cond.33

for.end.83:                                       ; preds = %if.then.54, %for.cond.33
  %58 = load i64, i64* %idx, align 8
  ret i64 %58
}

; Function Attrs: noreturn
declare void @memory_full(i64) #4

declare noalias i8* @xmalloc(i64) #1

declare i64 @make_save_memory(i64*, i64) #1

declare void @record_unwind_protect(void (i64)*, i64) #1

declare void @free_save_value(i64) #1

declare i64 @sort_overlays(i64*, i64, %struct.window*) #1

declare i64 @Foverlay_get(i64, i64) #1

declare %struct.Lisp_Overlay* @XOVERLAY(i64) #1

; Function Attrs: noreturn
declare void @emacs_abort() #4

declare %struct.Lisp_Marker* @XMARKER(i64) #1

declare i64 @unbind_to(i64, i64) #1

declare i32 @text_property_stickiness(i64, i64, i64) #1

; Function Attrs: nounwind uwtable
define i64 @Fdelete_field(i64 %pos) #0 {
entry:
  %pos.addr = alloca i64, align 8
  %beg = alloca i64, align 8
  %end = alloca i64, align 8
  store i64 %pos, i64* %pos.addr, align 8
  %0 = load i64, i64* %pos.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  call void @find_field(i64 %0, i64 %call, i64 %call1, i64* %beg, i64 %call2, i64* %end)
  %1 = load i64, i64* %beg, align 8
  %2 = load i64, i64* %end, align 8
  %cmp = icmp ne i64 %1, %2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i64, i64* %beg, align 8
  %4 = load i64, i64* %end, align 8
  call void @del_range(i64 %3, i64 %4)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  ret i64 %call3
}

; Function Attrs: nounwind uwtable
define internal void @find_field(i64 %pos, i64 %merge_at_boundary, i64 %beg_limit, i64* %beg, i64 %end_limit, i64* %end) #0 {
entry:
  %pos.addr = alloca i64, align 8
  %merge_at_boundary.addr = alloca i64, align 8
  %beg_limit.addr = alloca i64, align 8
  %beg.addr = alloca i64*, align 8
  %end_limit.addr = alloca i64, align 8
  %end.addr = alloca i64*, align 8
  %before_field = alloca i64, align 8
  %after_field = alloca i64, align 8
  %at_field_start = alloca i8, align 1
  %at_field_end = alloca i8, align 1
  %field = alloca i64, align 8
  %p = alloca i64, align 8
  store i64 %pos, i64* %pos.addr, align 8
  store i64 %merge_at_boundary, i64* %merge_at_boundary.addr, align 8
  store i64 %beg_limit, i64* %beg_limit.addr, align 8
  store i64* %beg, i64** %beg.addr, align 8
  store i64 %end_limit, i64* %end_limit.addr, align 8
  store i64* %end, i64** %end.addr, align 8
  store i8 0, i8* %at_field_start, align 1
  store i8 0, i8* %at_field_end, align 1
  %0 = load i64, i64* %pos.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %0, %call
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt = getelementptr inbounds %struct.buffer, %struct.buffer* %1, i32 0, i32 75
  %2 = load i64, i64* %pt, align 8
  %add = add nsw i64 %2, 0
  %call1 = call i64 @make_natnum(i64 %add)
  store i64 %call1, i64* %pos.addr, align 8
  br label %if.end.17

if.else:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.else
  %3 = load i64, i64* %pos.addr, align 8
  %and = and i64 %3, 7
  %conv = trunc i64 %and to i32
  %cmp2 = icmp eq i32 %conv, 1
  br i1 %cmp2, label %land.lhs.true, label %if.else.10

land.lhs.true:                                    ; preds = %do.body
  %4 = load i64, i64* %pos.addr, align 8
  %call4 = call i32 @XMISCTYPE(i64 %4)
  %cmp5 = icmp eq i32 %call4, 24236
  br i1 %cmp5, label %if.then.7, label %if.else.10

if.then.7:                                        ; preds = %land.lhs.true
  %5 = load i64, i64* %pos.addr, align 8
  %call8 = call i64 @marker_position(i64 %5)
  %call9 = call i64 @make_natnum(i64 %call8)
  store i64 %call9, i64* %pos.addr, align 8
  br label %if.end

if.else.10:                                       ; preds = %land.lhs.true, %do.body
  %6 = load i64, i64* %pos.addr, align 8
  %and11 = and i64 %6, 7
  %conv12 = trunc i64 %and11 to i32
  %and13 = and i32 %conv12, -5
  %cmp14 = icmp eq i32 %and13, 2
  br i1 %cmp14, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.else.10
  br label %cond.end

cond.false:                                       ; preds = %if.else.10
  %call16 = call i64 @builtin_lisp_symbol(i32 558)
  %7 = load i64, i64* %pos.addr, align 8
  %8 = call i64 @wrong_type_argument(i64 %call16, i64 %7) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %9, %cond.true
  br label %if.end

if.end:                                           ; preds = %cond.end, %if.then.7
  br label %do.end

do.end:                                           ; preds = %if.end
  br label %if.end.17

if.end.17:                                        ; preds = %do.end, %if.then
  %10 = load i64, i64* %pos.addr, align 8
  %call18 = call i64 @builtin_lisp_symbol(i32 403)
  %call19 = call i64 @builtin_lisp_symbol(i32 0)
  %call20 = call i64 @get_char_property_and_overlay(i64 %10, i64 %call18, i64 %call19, i64* null)
  store i64 %call20, i64* %after_field, align 8
  %11 = load i64, i64* %pos.addr, align 8
  %shr = ashr i64 %11, 2
  %12 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv = getelementptr inbounds %struct.buffer, %struct.buffer* %12, i32 0, i32 77
  %13 = load i64, i64* %begv, align 8
  %cmp21 = icmp sgt i64 %shr, %13
  br i1 %cmp21, label %cond.true.23, label %cond.false.29

cond.true.23:                                     ; preds = %if.end.17
  %14 = load i64, i64* %pos.addr, align 8
  %shr24 = ashr i64 %14, 2
  %sub = sub nsw i64 %shr24, 1
  %shl = shl i64 %sub, 2
  %add25 = add i64 %shl, 2
  %call26 = call i64 @builtin_lisp_symbol(i32 403)
  %call27 = call i64 @builtin_lisp_symbol(i32 0)
  %call28 = call i64 @get_char_property_and_overlay(i64 %add25, i64 %call26, i64 %call27, i64* null)
  br label %cond.end.30

cond.false.29:                                    ; preds = %if.end.17
  %15 = load i64, i64* %after_field, align 8
  br label %cond.end.30

cond.end.30:                                      ; preds = %cond.false.29, %cond.true.23
  %cond = phi i64 [ %call28, %cond.true.23 ], [ %15, %cond.false.29 ]
  store i64 %cond, i64* %before_field, align 8
  %16 = load i64, i64* %merge_at_boundary.addr, align 8
  %call31 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp32 = icmp eq i64 %16, %call31
  br i1 %cmp32, label %if.then.34, label %if.end.56

if.then.34:                                       ; preds = %cond.end.30
  %17 = load i64, i64* %pos.addr, align 8
  %call35 = call i64 @builtin_lisp_symbol(i32 403)
  %call36 = call i64 @builtin_lisp_symbol(i32 0)
  %call37 = call i64 @Fget_pos_property(i64 %17, i64 %call35, i64 %call36)
  store i64 %call37, i64* %field, align 8
  %18 = load i64, i64* %field, align 8
  %19 = load i64, i64* %after_field, align 8
  %cmp38 = icmp eq i64 %18, %19
  br i1 %cmp38, label %if.end.41, label %if.then.40

if.then.40:                                       ; preds = %if.then.34
  store i8 1, i8* %at_field_end, align 1
  br label %if.end.41

if.end.41:                                        ; preds = %if.then.40, %if.then.34
  %20 = load i64, i64* %field, align 8
  %21 = load i64, i64* %before_field, align 8
  %cmp42 = icmp eq i64 %20, %21
  br i1 %cmp42, label %if.end.45, label %if.then.44

if.then.44:                                       ; preds = %if.end.41
  store i8 1, i8* %at_field_start, align 1
  br label %if.end.45

if.end.45:                                        ; preds = %if.then.44, %if.end.41
  %22 = load i64, i64* %field, align 8
  %call46 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp47 = icmp eq i64 %22, %call46
  br i1 %cmp47, label %land.lhs.true.49, label %if.end.55

land.lhs.true.49:                                 ; preds = %if.end.45
  %23 = load i8, i8* %at_field_start, align 1
  %tobool = trunc i8 %23 to i1
  br i1 %tobool, label %land.lhs.true.51, label %if.end.55

land.lhs.true.51:                                 ; preds = %land.lhs.true.49
  %24 = load i8, i8* %at_field_end, align 1
  %tobool52 = trunc i8 %24 to i1
  br i1 %tobool52, label %if.then.54, label %if.end.55

if.then.54:                                       ; preds = %land.lhs.true.51
  store i8 0, i8* %at_field_start, align 1
  store i8 0, i8* %at_field_end, align 1
  br label %if.end.55

if.end.55:                                        ; preds = %if.then.54, %land.lhs.true.51, %land.lhs.true.49, %if.end.45
  br label %if.end.56

if.end.56:                                        ; preds = %if.end.55, %cond.end.30
  %25 = load i64*, i64** %beg.addr, align 8
  %tobool57 = icmp ne i64* %25, null
  br i1 %tobool57, label %if.then.58, label %if.end.88

if.then.58:                                       ; preds = %if.end.56
  %26 = load i8, i8* %at_field_start, align 1
  %tobool59 = trunc i8 %26 to i1
  br i1 %tobool59, label %if.then.60, label %if.else.62

if.then.60:                                       ; preds = %if.then.58
  %27 = load i64, i64* %pos.addr, align 8
  %shr61 = ashr i64 %27, 2
  %28 = load i64*, i64** %beg.addr, align 8
  store i64 %shr61, i64* %28, align 8
  br label %if.end.87

if.else.62:                                       ; preds = %if.then.58
  %29 = load i64, i64* %pos.addr, align 8
  store i64 %29, i64* %p, align 8
  %30 = load i64, i64* %merge_at_boundary.addr, align 8
  %call63 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp64 = icmp eq i64 %30, %call63
  br i1 %cmp64, label %if.end.74, label %land.lhs.true.66

land.lhs.true.66:                                 ; preds = %if.else.62
  %31 = load i64, i64* %before_field, align 8
  %call67 = call i64 @builtin_lisp_symbol(i32 217)
  %cmp68 = icmp eq i64 %31, %call67
  br i1 %cmp68, label %if.then.70, label %if.end.74

if.then.70:                                       ; preds = %land.lhs.true.66
  %32 = load i64, i64* %p, align 8
  %call71 = call i64 @builtin_lisp_symbol(i32 403)
  %call72 = call i64 @builtin_lisp_symbol(i32 0)
  %33 = load i64, i64* %beg_limit.addr, align 8
  %call73 = call i64 @Fprevious_single_char_property_change(i64 %32, i64 %call71, i64 %call72, i64 %33)
  store i64 %call73, i64* %p, align 8
  br label %if.end.74

if.end.74:                                        ; preds = %if.then.70, %land.lhs.true.66, %if.else.62
  %34 = load i64, i64* %p, align 8
  %call75 = call i64 @builtin_lisp_symbol(i32 403)
  %call76 = call i64 @builtin_lisp_symbol(i32 0)
  %35 = load i64, i64* %beg_limit.addr, align 8
  %call77 = call i64 @Fprevious_single_char_property_change(i64 %34, i64 %call75, i64 %call76, i64 %35)
  store i64 %call77, i64* %p, align 8
  %36 = load i64, i64* %p, align 8
  %call78 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp79 = icmp eq i64 %36, %call78
  br i1 %cmp79, label %cond.true.81, label %cond.false.83

cond.true.81:                                     ; preds = %if.end.74
  %37 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv82 = getelementptr inbounds %struct.buffer, %struct.buffer* %37, i32 0, i32 77
  %38 = load i64, i64* %begv82, align 8
  br label %cond.end.85

cond.false.83:                                    ; preds = %if.end.74
  %39 = load i64, i64* %p, align 8
  %shr84 = ashr i64 %39, 2
  br label %cond.end.85

cond.end.85:                                      ; preds = %cond.false.83, %cond.true.81
  %cond86 = phi i64 [ %38, %cond.true.81 ], [ %shr84, %cond.false.83 ]
  %40 = load i64*, i64** %beg.addr, align 8
  store i64 %cond86, i64* %40, align 8
  br label %if.end.87

if.end.87:                                        ; preds = %cond.end.85, %if.then.60
  br label %if.end.88

if.end.88:                                        ; preds = %if.end.87, %if.end.56
  %41 = load i64*, i64** %end.addr, align 8
  %tobool89 = icmp ne i64* %41, null
  br i1 %tobool89, label %if.then.90, label %if.end.119

if.then.90:                                       ; preds = %if.end.88
  %42 = load i8, i8* %at_field_end, align 1
  %tobool91 = trunc i8 %42 to i1
  br i1 %tobool91, label %if.then.92, label %if.else.94

if.then.92:                                       ; preds = %if.then.90
  %43 = load i64, i64* %pos.addr, align 8
  %shr93 = ashr i64 %43, 2
  %44 = load i64*, i64** %end.addr, align 8
  store i64 %shr93, i64* %44, align 8
  br label %if.end.118

if.else.94:                                       ; preds = %if.then.90
  %45 = load i64, i64* %merge_at_boundary.addr, align 8
  %call95 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp96 = icmp eq i64 %45, %call95
  br i1 %cmp96, label %if.end.106, label %land.lhs.true.98

land.lhs.true.98:                                 ; preds = %if.else.94
  %46 = load i64, i64* %after_field, align 8
  %call99 = call i64 @builtin_lisp_symbol(i32 217)
  %cmp100 = icmp eq i64 %46, %call99
  br i1 %cmp100, label %if.then.102, label %if.end.106

if.then.102:                                      ; preds = %land.lhs.true.98
  %47 = load i64, i64* %pos.addr, align 8
  %call103 = call i64 @builtin_lisp_symbol(i32 403)
  %call104 = call i64 @builtin_lisp_symbol(i32 0)
  %48 = load i64, i64* %end_limit.addr, align 8
  %call105 = call i64 @Fnext_single_char_property_change(i64 %47, i64 %call103, i64 %call104, i64 %48)
  store i64 %call105, i64* %pos.addr, align 8
  br label %if.end.106

if.end.106:                                       ; preds = %if.then.102, %land.lhs.true.98, %if.else.94
  %49 = load i64, i64* %pos.addr, align 8
  %call107 = call i64 @builtin_lisp_symbol(i32 403)
  %call108 = call i64 @builtin_lisp_symbol(i32 0)
  %50 = load i64, i64* %end_limit.addr, align 8
  %call109 = call i64 @Fnext_single_char_property_change(i64 %49, i64 %call107, i64 %call108, i64 %50)
  store i64 %call109, i64* %pos.addr, align 8
  %51 = load i64, i64* %pos.addr, align 8
  %call110 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp111 = icmp eq i64 %51, %call110
  br i1 %cmp111, label %cond.true.113, label %cond.false.114

cond.true.113:                                    ; preds = %if.end.106
  %52 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv = getelementptr inbounds %struct.buffer, %struct.buffer* %52, i32 0, i32 79
  %53 = load i64, i64* %zv, align 8
  br label %cond.end.116

cond.false.114:                                   ; preds = %if.end.106
  %54 = load i64, i64* %pos.addr, align 8
  %shr115 = ashr i64 %54, 2
  br label %cond.end.116

cond.end.116:                                     ; preds = %cond.false.114, %cond.true.113
  %cond117 = phi i64 [ %53, %cond.true.113 ], [ %shr115, %cond.false.114 ]
  %55 = load i64*, i64** %end.addr, align 8
  store i64 %cond117, i64* %55, align 8
  br label %if.end.118

if.end.118:                                       ; preds = %cond.end.116, %if.then.92
  br label %if.end.119

if.end.119:                                       ; preds = %if.end.118, %if.end.88
  ret void
}

declare void @del_range(i64, i64) #1

; Function Attrs: nounwind uwtable
define i64 @Ffield_string(i64 %pos) #0 {
entry:
  %pos.addr = alloca i64, align 8
  %beg = alloca i64, align 8
  %end = alloca i64, align 8
  store i64 %pos, i64* %pos.addr, align 8
  %0 = load i64, i64* %pos.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  call void @find_field(i64 %0, i64 %call, i64 %call1, i64* %beg, i64 %call2, i64* %end)
  %1 = load i64, i64* %beg, align 8
  %2 = load i64, i64* %end, align 8
  %call3 = call i64 @make_buffer_string(i64 %1, i64 %2, i1 zeroext true)
  ret i64 %call3
}

; Function Attrs: nounwind uwtable
define i64 @make_buffer_string(i64 %start, i64 %end, i1 zeroext %props) #0 {
entry:
  %start.addr = alloca i64, align 8
  %end.addr = alloca i64, align 8
  %props.addr = alloca i8, align 1
  %start_byte = alloca i64, align 8
  %end_byte = alloca i64, align 8
  store i64 %start, i64* %start.addr, align 8
  store i64 %end, i64* %end.addr, align 8
  %frombool = zext i1 %props to i8
  store i8 %frombool, i8* %props.addr, align 1
  %0 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %1 = load i64, i64* %start.addr, align 8
  %call = call i64 @buf_charpos_to_bytepos(%struct.buffer* %0, i64 %1)
  store i64 %call, i64* %start_byte, align 8
  %2 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %3 = load i64, i64* %end.addr, align 8
  %call1 = call i64 @buf_charpos_to_bytepos(%struct.buffer* %2, i64 %3)
  store i64 %call1, i64* %end_byte, align 8
  %4 = load i64, i64* %start.addr, align 8
  %5 = load i64, i64* %start_byte, align 8
  %6 = load i64, i64* %end.addr, align 8
  %7 = load i64, i64* %end_byte, align 8
  %8 = load i8, i8* %props.addr, align 1
  %tobool = trunc i8 %8 to i1
  %call2 = call i64 @make_buffer_string_both(i64 %4, i64 %5, i64 %6, i64 %7, i1 zeroext %tobool)
  ret i64 %call2
}

; Function Attrs: nounwind uwtable
define i64 @Ffield_string_no_properties(i64 %pos) #0 {
entry:
  %pos.addr = alloca i64, align 8
  %beg = alloca i64, align 8
  %end = alloca i64, align 8
  store i64 %pos, i64* %pos.addr, align 8
  %0 = load i64, i64* %pos.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  call void @find_field(i64 %0, i64 %call, i64 %call1, i64* %beg, i64 %call2, i64* %end)
  %1 = load i64, i64* %beg, align 8
  %2 = load i64, i64* %end, align 8
  %call3 = call i64 @make_buffer_string(i64 %1, i64 %2, i1 zeroext false)
  ret i64 %call3
}

; Function Attrs: nounwind uwtable
define i64 @Ffield_beginning(i64 %pos, i64 %escape_from_edge, i64 %limit) #0 {
entry:
  %pos.addr = alloca i64, align 8
  %escape_from_edge.addr = alloca i64, align 8
  %limit.addr = alloca i64, align 8
  %beg = alloca i64, align 8
  store i64 %pos, i64* %pos.addr, align 8
  store i64 %escape_from_edge, i64* %escape_from_edge.addr, align 8
  store i64 %limit, i64* %limit.addr, align 8
  %0 = load i64, i64* %pos.addr, align 8
  %1 = load i64, i64* %escape_from_edge.addr, align 8
  %2 = load i64, i64* %limit.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  call void @find_field(i64 %0, i64 %1, i64 %2, i64* %beg, i64 %call, i64* null)
  %3 = load i64, i64* %beg, align 8
  %shl = shl i64 %3, 2
  %add = add i64 %shl, 2
  ret i64 %add
}

; Function Attrs: nounwind uwtable
define i64 @Ffield_end(i64 %pos, i64 %escape_from_edge, i64 %limit) #0 {
entry:
  %pos.addr = alloca i64, align 8
  %escape_from_edge.addr = alloca i64, align 8
  %limit.addr = alloca i64, align 8
  %end = alloca i64, align 8
  store i64 %pos, i64* %pos.addr, align 8
  store i64 %escape_from_edge, i64* %escape_from_edge.addr, align 8
  store i64 %limit, i64* %limit.addr, align 8
  %0 = load i64, i64* %pos.addr, align 8
  %1 = load i64, i64* %escape_from_edge.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %2 = load i64, i64* %limit.addr, align 8
  call void @find_field(i64 %0, i64 %1, i64 %call, i64* null, i64 %2, i64* %end)
  %3 = load i64, i64* %end, align 8
  %shl = shl i64 %3, 2
  %add = add i64 %shl, 2
  ret i64 %add
}

; Function Attrs: nounwind uwtable
define i64 @Fconstrain_to_field(i64 %new_pos, i64 %old_pos, i64 %escape_from_edge, i64 %only_in_line, i64 %inhibit_capture_property) #0 {
entry:
  %new_pos.addr = alloca i64, align 8
  %old_pos.addr = alloca i64, align 8
  %escape_from_edge.addr = alloca i64, align 8
  %only_in_line.addr = alloca i64, align 8
  %inhibit_capture_property.addr = alloca i64, align 8
  %orig_point = alloca i64, align 8
  %fwd = alloca i8, align 1
  %prev_old = alloca i64, align 8
  %prev_new = alloca i64, align 8
  %shortage = alloca i64, align 8
  %field_bound = alloca i64, align 8
  store i64 %new_pos, i64* %new_pos.addr, align 8
  store i64 %old_pos, i64* %old_pos.addr, align 8
  store i64 %escape_from_edge, i64* %escape_from_edge.addr, align 8
  store i64 %only_in_line, i64* %only_in_line.addr, align 8
  store i64 %inhibit_capture_property, i64* %inhibit_capture_property.addr, align 8
  store i64 0, i64* %orig_point, align 8
  %0 = load i64, i64* %new_pos.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %0, %call
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt = getelementptr inbounds %struct.buffer, %struct.buffer* %1, i32 0, i32 75
  %2 = load i64, i64* %pt, align 8
  %add = add nsw i64 %2, 0
  store i64 %add, i64* %orig_point, align 8
  %3 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt1 = getelementptr inbounds %struct.buffer, %struct.buffer* %3, i32 0, i32 75
  %4 = load i64, i64* %pt1, align 8
  %add2 = add nsw i64 %4, 0
  %call3 = call i64 @make_natnum(i64 %add2)
  store i64 %call3, i64* %new_pos.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  br label %do.body

do.body:                                          ; preds = %if.end
  %5 = load i64, i64* %new_pos.addr, align 8
  %and = and i64 %5, 7
  %conv = trunc i64 %and to i32
  %cmp4 = icmp eq i32 %conv, 1
  br i1 %cmp4, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %do.body
  %6 = load i64, i64* %new_pos.addr, align 8
  %call6 = call i32 @XMISCTYPE(i64 %6)
  %cmp7 = icmp eq i32 %call6, 24236
  br i1 %cmp7, label %if.then.9, label %if.else

if.then.9:                                        ; preds = %land.lhs.true
  %7 = load i64, i64* %new_pos.addr, align 8
  %call10 = call i64 @marker_position(i64 %7)
  %call11 = call i64 @make_natnum(i64 %call10)
  store i64 %call11, i64* %new_pos.addr, align 8
  br label %if.end.18

if.else:                                          ; preds = %land.lhs.true, %do.body
  %8 = load i64, i64* %new_pos.addr, align 8
  %and12 = and i64 %8, 7
  %conv13 = trunc i64 %and12 to i32
  %and14 = and i32 %conv13, -5
  %cmp15 = icmp eq i32 %and14, 2
  br i1 %cmp15, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.else
  br label %cond.end

cond.false:                                       ; preds = %if.else
  %call17 = call i64 @builtin_lisp_symbol(i32 558)
  %9 = load i64, i64* %new_pos.addr, align 8
  %10 = call i64 @wrong_type_argument(i64 %call17, i64 %9) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %11, %cond.true
  br label %if.end.18

if.end.18:                                        ; preds = %cond.end, %if.then.9
  br label %do.end

do.end:                                           ; preds = %if.end.18
  br label %do.body.19

do.body.19:                                       ; preds = %do.end
  %12 = load i64, i64* %old_pos.addr, align 8
  %and20 = and i64 %12, 7
  %conv21 = trunc i64 %and20 to i32
  %cmp22 = icmp eq i32 %conv21, 1
  br i1 %cmp22, label %land.lhs.true.24, label %if.else.31

land.lhs.true.24:                                 ; preds = %do.body.19
  %13 = load i64, i64* %old_pos.addr, align 8
  %call25 = call i32 @XMISCTYPE(i64 %13)
  %cmp26 = icmp eq i32 %call25, 24236
  br i1 %cmp26, label %if.then.28, label %if.else.31

if.then.28:                                       ; preds = %land.lhs.true.24
  %14 = load i64, i64* %old_pos.addr, align 8
  %call29 = call i64 @marker_position(i64 %14)
  %call30 = call i64 @make_natnum(i64 %call29)
  store i64 %call30, i64* %old_pos.addr, align 8
  br label %if.end.41

if.else.31:                                       ; preds = %land.lhs.true.24, %do.body.19
  %15 = load i64, i64* %old_pos.addr, align 8
  %and32 = and i64 %15, 7
  %conv33 = trunc i64 %and32 to i32
  %and34 = and i32 %conv33, -5
  %cmp35 = icmp eq i32 %and34, 2
  br i1 %cmp35, label %cond.true.37, label %cond.false.38

cond.true.37:                                     ; preds = %if.else.31
  br label %cond.end.40

cond.false.38:                                    ; preds = %if.else.31
  %call39 = call i64 @builtin_lisp_symbol(i32 558)
  %16 = load i64, i64* %old_pos.addr, align 8
  %17 = call i64 @wrong_type_argument(i64 %call39, i64 %16) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end.40

cond.end.40:                                      ; preds = %18, %cond.true.37
  br label %if.end.41

if.end.41:                                        ; preds = %cond.end.40, %if.then.28
  br label %do.end.42

do.end.42:                                        ; preds = %if.end.41
  %19 = load i64, i64* %new_pos.addr, align 8
  %shr = ashr i64 %19, 2
  %20 = load i64, i64* %old_pos.addr, align 8
  %shr43 = ashr i64 %20, 2
  %cmp44 = icmp sgt i64 %shr, %shr43
  %frombool = zext i1 %cmp44 to i8
  store i8 %frombool, i8* %fwd, align 1
  %21 = load i64, i64* %old_pos.addr, align 8
  %shr46 = ashr i64 %21, 2
  %sub = sub nsw i64 %shr46, 1
  %shl = shl i64 %sub, 2
  %add47 = add i64 %shl, 2
  store i64 %add47, i64* %prev_old, align 8
  %22 = load i64, i64* %new_pos.addr, align 8
  %shr48 = ashr i64 %22, 2
  %sub49 = sub nsw i64 %shr48, 1
  %shl50 = shl i64 %sub49, 2
  %add51 = add i64 %shl50, 2
  store i64 %add51, i64* %prev_new, align 8
  %23 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 134), align 8
  %call52 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp53 = icmp eq i64 %23, %call52
  br i1 %cmp53, label %land.lhs.true.55, label %if.end.159

land.lhs.true.55:                                 ; preds = %do.end.42
  %24 = load i64, i64* %new_pos.addr, align 8
  %25 = load i64, i64* %old_pos.addr, align 8
  %cmp56 = icmp eq i64 %24, %25
  br i1 %cmp56, label %if.end.159, label %land.lhs.true.58

land.lhs.true.58:                                 ; preds = %land.lhs.true.55
  %26 = load i64, i64* %new_pos.addr, align 8
  %call59 = call i64 @builtin_lisp_symbol(i32 403)
  %call60 = call i64 @builtin_lisp_symbol(i32 0)
  %call61 = call i64 @Fget_char_property(i64 %26, i64 %call59, i64 %call60)
  %call62 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp63 = icmp eq i64 %call61, %call62
  br i1 %cmp63, label %lor.lhs.false, label %land.lhs.true.94

lor.lhs.false:                                    ; preds = %land.lhs.true.58
  %27 = load i64, i64* %old_pos.addr, align 8
  %call65 = call i64 @builtin_lisp_symbol(i32 403)
  %call66 = call i64 @builtin_lisp_symbol(i32 0)
  %call67 = call i64 @Fget_char_property(i64 %27, i64 %call65, i64 %call66)
  %call68 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp69 = icmp eq i64 %call67, %call68
  br i1 %cmp69, label %lor.lhs.false.71, label %land.lhs.true.94

lor.lhs.false.71:                                 ; preds = %lor.lhs.false
  %28 = load i64, i64* %new_pos.addr, align 8
  %shr72 = ashr i64 %28, 2
  %29 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv = getelementptr inbounds %struct.buffer, %struct.buffer* %29, i32 0, i32 77
  %30 = load i64, i64* %begv, align 8
  %cmp73 = icmp sgt i64 %shr72, %30
  br i1 %cmp73, label %land.lhs.true.75, label %lor.lhs.false.82

land.lhs.true.75:                                 ; preds = %lor.lhs.false.71
  %31 = load i64, i64* %prev_new, align 8
  %call76 = call i64 @builtin_lisp_symbol(i32 403)
  %call77 = call i64 @builtin_lisp_symbol(i32 0)
  %call78 = call i64 @Fget_char_property(i64 %31, i64 %call76, i64 %call77)
  %call79 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp80 = icmp eq i64 %call78, %call79
  br i1 %cmp80, label %lor.lhs.false.82, label %land.lhs.true.94

lor.lhs.false.82:                                 ; preds = %land.lhs.true.75, %lor.lhs.false.71
  %32 = load i64, i64* %old_pos.addr, align 8
  %shr83 = ashr i64 %32, 2
  %33 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv84 = getelementptr inbounds %struct.buffer, %struct.buffer* %33, i32 0, i32 77
  %34 = load i64, i64* %begv84, align 8
  %cmp85 = icmp sgt i64 %shr83, %34
  br i1 %cmp85, label %land.lhs.true.87, label %if.end.159

land.lhs.true.87:                                 ; preds = %lor.lhs.false.82
  %35 = load i64, i64* %prev_old, align 8
  %call88 = call i64 @builtin_lisp_symbol(i32 403)
  %call89 = call i64 @builtin_lisp_symbol(i32 0)
  %call90 = call i64 @Fget_char_property(i64 %35, i64 %call88, i64 %call89)
  %call91 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp92 = icmp eq i64 %call90, %call91
  br i1 %cmp92, label %if.end.159, label %land.lhs.true.94

land.lhs.true.94:                                 ; preds = %land.lhs.true.87, %land.lhs.true.75, %lor.lhs.false, %land.lhs.true.58
  %36 = load i64, i64* %inhibit_capture_property.addr, align 8
  %call95 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp96 = icmp eq i64 %36, %call95
  br i1 %cmp96, label %if.then.121, label %lor.lhs.false.98

lor.lhs.false.98:                                 ; preds = %land.lhs.true.94
  %37 = load i64, i64* %old_pos.addr, align 8
  %38 = load i64, i64* %inhibit_capture_property.addr, align 8
  %call99 = call i64 @builtin_lisp_symbol(i32 0)
  %call100 = call i64 @Fget_pos_property(i64 %37, i64 %38, i64 %call99)
  %call101 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp102 = icmp eq i64 %call100, %call101
  br i1 %cmp102, label %land.lhs.true.104, label %if.end.159

land.lhs.true.104:                                ; preds = %lor.lhs.false.98
  %39 = load i64, i64* %old_pos.addr, align 8
  %shr105 = ashr i64 %39, 2
  %40 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv106 = getelementptr inbounds %struct.buffer, %struct.buffer* %40, i32 0, i32 77
  %41 = load i64, i64* %begv106, align 8
  %cmp107 = icmp sle i64 %shr105, %41
  br i1 %cmp107, label %if.then.121, label %lor.lhs.false.109

lor.lhs.false.109:                                ; preds = %land.lhs.true.104
  %42 = load i64, i64* %old_pos.addr, align 8
  %43 = load i64, i64* %inhibit_capture_property.addr, align 8
  %call110 = call i64 @builtin_lisp_symbol(i32 0)
  %call111 = call i64 @Fget_char_property(i64 %42, i64 %43, i64 %call110)
  %call112 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp113 = icmp eq i64 %call111, %call112
  br i1 %cmp113, label %if.then.121, label %lor.lhs.false.115

lor.lhs.false.115:                                ; preds = %lor.lhs.false.109
  %44 = load i64, i64* %prev_old, align 8
  %45 = load i64, i64* %inhibit_capture_property.addr, align 8
  %call116 = call i64 @builtin_lisp_symbol(i32 0)
  %call117 = call i64 @Fget_char_property(i64 %44, i64 %45, i64 %call116)
  %call118 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp119 = icmp eq i64 %call117, %call118
  br i1 %cmp119, label %if.then.121, label %if.end.159

if.then.121:                                      ; preds = %lor.lhs.false.115, %lor.lhs.false.109, %land.lhs.true.104, %land.lhs.true.94
  %46 = load i8, i8* %fwd, align 1
  %tobool = trunc i8 %46 to i1
  br i1 %tobool, label %if.then.122, label %if.else.124

if.then.122:                                      ; preds = %if.then.121
  %47 = load i64, i64* %old_pos.addr, align 8
  %48 = load i64, i64* %escape_from_edge.addr, align 8
  %49 = load i64, i64* %new_pos.addr, align 8
  %call123 = call i64 @Ffield_end(i64 %47, i64 %48, i64 %49)
  store i64 %call123, i64* %field_bound, align 8
  br label %if.end.126

if.else.124:                                      ; preds = %if.then.121
  %50 = load i64, i64* %old_pos.addr, align 8
  %51 = load i64, i64* %escape_from_edge.addr, align 8
  %52 = load i64, i64* %new_pos.addr, align 8
  %call125 = call i64 @Ffield_beginning(i64 %50, i64 %51, i64 %52)
  store i64 %call125, i64* %field_bound, align 8
  br label %if.end.126

if.end.126:                                       ; preds = %if.else.124, %if.then.122
  %53 = load i64, i64* %field_bound, align 8
  %shr127 = ashr i64 %53, 2
  %54 = load i64, i64* %new_pos.addr, align 8
  %shr128 = ashr i64 %54, 2
  %cmp129 = icmp slt i64 %shr127, %shr128
  br i1 %cmp129, label %cond.true.131, label %cond.false.134

cond.true.131:                                    ; preds = %if.end.126
  %55 = load i8, i8* %fwd, align 1
  %tobool132 = trunc i8 %55 to i1
  br i1 %tobool132, label %land.lhs.true.136, label %if.end.150

cond.false.134:                                   ; preds = %if.end.126
  %56 = load i8, i8* %fwd, align 1
  %tobool135 = trunc i8 %56 to i1
  br i1 %tobool135, label %if.end.150, label %land.lhs.true.136

land.lhs.true.136:                                ; preds = %cond.false.134, %cond.true.131
  %57 = load i64, i64* %only_in_line.addr, align 8
  %call137 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp138 = icmp eq i64 %57, %call137
  br i1 %cmp138, label %if.then.149, label %lor.lhs.false.140

lor.lhs.false.140:                                ; preds = %land.lhs.true.136
  %58 = load i64, i64* %new_pos.addr, align 8
  %shr141 = ashr i64 %58, 2
  %59 = load i64, i64* %field_bound, align 8
  %shr142 = ashr i64 %59, 2
  %60 = load i8, i8* %fwd, align 1
  %tobool143 = trunc i8 %60 to i1
  %cond = select i1 %tobool143, i32 -1, i32 1
  %conv145 = sext i32 %cond to i64
  %call146 = call i64 @find_newline(i64 %shr141, i64 -1, i64 %shr142, i64 -1, i64 %conv145, i64* %shortage, i64* null, i1 zeroext true)
  %61 = load i64, i64* %shortage, align 8
  %cmp147 = icmp ne i64 %61, 0
  br i1 %cmp147, label %if.then.149, label %if.end.150

if.then.149:                                      ; preds = %lor.lhs.false.140, %land.lhs.true.136
  %62 = load i64, i64* %field_bound, align 8
  store i64 %62, i64* %new_pos.addr, align 8
  br label %if.end.150

if.end.150:                                       ; preds = %if.then.149, %lor.lhs.false.140, %cond.false.134, %cond.true.131
  %63 = load i64, i64* %orig_point, align 8
  %tobool151 = icmp ne i64 %63, 0
  br i1 %tobool151, label %land.lhs.true.152, label %if.end.158

land.lhs.true.152:                                ; preds = %if.end.150
  %64 = load i64, i64* %new_pos.addr, align 8
  %shr153 = ashr i64 %64, 2
  %65 = load i64, i64* %orig_point, align 8
  %cmp154 = icmp ne i64 %shr153, %65
  br i1 %cmp154, label %if.then.156, label %if.end.158

if.then.156:                                      ; preds = %land.lhs.true.152
  %66 = load i64, i64* %new_pos.addr, align 8
  %shr157 = ashr i64 %66, 2
  call void @set_point(i64 %shr157)
  br label %if.end.158

if.end.158:                                       ; preds = %if.then.156, %land.lhs.true.152, %if.end.150
  br label %if.end.159

if.end.159:                                       ; preds = %if.end.158, %lor.lhs.false.115, %lor.lhs.false.98, %land.lhs.true.87, %lor.lhs.false.82, %land.lhs.true.55, %do.end.42
  %67 = load i64, i64* %new_pos.addr, align 8
  ret i64 %67
}

declare i64 @Fget_char_property(i64, i64, i64) #1

declare i64 @find_newline(i64, i64, i64, i64, i64, i64*, i64*, i1 zeroext) #1

; Function Attrs: nounwind uwtable
define i64 @Fline_beginning_position(i64 %n) #0 {
entry:
  %n.addr = alloca i64, align 8
  %charpos = alloca i64, align 8
  %bytepos = alloca i64, align 8
  store i64 %n, i64* %n.addr, align 8
  %0 = load i64, i64* %n.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %0, %call
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call1 = call i64 @make_natnum(i64 1)
  store i64 %call1, i64* %n.addr, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %1 = load i64, i64* %n.addr, align 8
  %and = and i64 %1, 7
  %conv = trunc i64 %and to i32
  %and2 = and i32 %conv, -5
  %cmp3 = icmp eq i32 %and2, 2
  br i1 %cmp3, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.else
  br label %cond.end

cond.false:                                       ; preds = %if.else
  %call5 = call i64 @builtin_lisp_symbol(i32 559)
  %2 = load i64, i64* %n.addr, align 8
  %3 = call i64 @wrong_type_argument(i64 %call5, i64 %2) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %4, %cond.true
  br label %if.end

if.end:                                           ; preds = %cond.end, %if.then
  %5 = load i64, i64* %n.addr, align 8
  %shr = ashr i64 %5, 2
  %sub = sub nsw i64 %shr, 1
  %call6 = call i64 @scan_newline_from_point(i64 %sub, i64* %charpos, i64* %bytepos)
  %6 = load i64, i64* %charpos, align 8
  %shl = shl i64 %6, 2
  %add = add i64 %shl, 2
  %7 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt = getelementptr inbounds %struct.buffer, %struct.buffer* %7, i32 0, i32 75
  %8 = load i64, i64* %pt, align 8
  %add7 = add nsw i64 %8, 0
  %shl8 = shl i64 %add7, 2
  %add9 = add i64 %shl8, 2
  %9 = load i64, i64* %n.addr, align 8
  %shr10 = ashr i64 %9, 2
  %cmp11 = icmp ne i64 %shr10, 1
  br i1 %cmp11, label %cond.true.13, label %cond.false.15

cond.true.13:                                     ; preds = %if.end
  %call14 = call i64 @builtin_lisp_symbol(i32 901)
  br label %cond.end.17

cond.false.15:                                    ; preds = %if.end
  %call16 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end.17

cond.end.17:                                      ; preds = %cond.false.15, %cond.true.13
  %cond = phi i64 [ %call14, %cond.true.13 ], [ %call16, %cond.false.15 ]
  %call18 = call i64 @builtin_lisp_symbol(i32 901)
  %call19 = call i64 @builtin_lisp_symbol(i32 0)
  %call20 = call i64 @Fconstrain_to_field(i64 %add, i64 %add9, i64 %cond, i64 %call18, i64 %call19)
  ret i64 %call20
}

declare i64 @scan_newline_from_point(i64, i64*, i64*) #1

; Function Attrs: nounwind uwtable
define i64 @Fline_end_position(i64 %n) #0 {
entry:
  %n.addr = alloca i64, align 8
  %clipped_n = alloca i64, align 8
  %end_pos = alloca i64, align 8
  %orig = alloca i64, align 8
  store i64 %n, i64* %n.addr, align 8
  %0 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt = getelementptr inbounds %struct.buffer, %struct.buffer* %0, i32 0, i32 75
  %1 = load i64, i64* %pt, align 8
  %add = add nsw i64 %1, 0
  store i64 %add, i64* %orig, align 8
  %2 = load i64, i64* %n.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %2, %call
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call1 = call i64 @make_natnum(i64 1)
  store i64 %call1, i64* %n.addr, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %3 = load i64, i64* %n.addr, align 8
  %and = and i64 %3, 7
  %conv = trunc i64 %and to i32
  %and2 = and i32 %conv, -5
  %cmp3 = icmp eq i32 %and2, 2
  br i1 %cmp3, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.else
  br label %cond.end

cond.false:                                       ; preds = %if.else
  %call5 = call i64 @builtin_lisp_symbol(i32 559)
  %4 = load i64, i64* %n.addr, align 8
  %5 = call i64 @wrong_type_argument(i64 %call5, i64 %4) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %6, %cond.true
  br label %if.end

if.end:                                           ; preds = %cond.end, %if.then
  %7 = load i64, i64* %n.addr, align 8
  %shr = ashr i64 %7, 2
  %call6 = call i64 @clip_to_bounds(i64 -9223372036854775807, i64 %shr, i64 9223372036854775807)
  store i64 %call6, i64* %clipped_n, align 8
  %8 = load i64, i64* %orig, align 8
  %9 = load i64, i64* %clipped_n, align 8
  %10 = load i64, i64* %clipped_n, align 8
  %cmp7 = icmp sle i64 %10, 0
  %conv8 = zext i1 %cmp7 to i32
  %conv9 = sext i32 %conv8 to i64
  %sub = sub nsw i64 %9, %conv9
  %call10 = call i64 @find_before_next_newline(i64 %8, i64 0, i64 %sub, i64* null)
  store i64 %call10, i64* %end_pos, align 8
  %11 = load i64, i64* %end_pos, align 8
  %shl = shl i64 %11, 2
  %add11 = add i64 %shl, 2
  %12 = load i64, i64* %orig, align 8
  %shl12 = shl i64 %12, 2
  %add13 = add i64 %shl12, 2
  %call14 = call i64 @builtin_lisp_symbol(i32 0)
  %call15 = call i64 @builtin_lisp_symbol(i32 901)
  %call16 = call i64 @builtin_lisp_symbol(i32 0)
  %call17 = call i64 @Fconstrain_to_field(i64 %add11, i64 %add13, i64 %call14, i64 %call15, i64 %call16)
  ret i64 %call17
}

declare i64 @find_before_next_newline(i64, i64, i64, i64*) #1

; Function Attrs: nounwind uwtable
define i64 @save_excursion_save() #0 {
entry:
  %call = call i64 @Fpoint_marker()
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  %0 = load i64, i64* @selected_window, align 8
  %call2 = call %struct.window* @XWINDOW(i64 %0)
  %contents = getelementptr inbounds %struct.window, %struct.window* %call2, i32 0, i32 10
  %1 = load i64, i64* %contents, align 8
  %call3 = call i64 @Fcurrent_buffer()
  %cmp = icmp eq i64 %1, %call3
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load i64, i64* @selected_window, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call4 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %2, %cond.true ], [ %call4, %cond.false ]
  %call5 = call i64 @builtin_lisp_symbol(i32 0)
  %call6 = call i64 @make_save_obj_obj_obj_obj(i64 %call, i64 %call1, i64 %cond, i64 %call5)
  ret i64 %call6
}

declare i64 @make_save_obj_obj_obj_obj(i64, i64, i64, i64) #1

declare i64 @Fcurrent_buffer() #1

; Function Attrs: nounwind uwtable
define void @save_excursion_restore(i64 %info) #0 {
entry:
  %info.addr = alloca i64, align 8
  %tem = alloca i64, align 8
  %tem1 = alloca i64, align 8
  store i64 %info, i64* %info.addr, align 8
  %0 = load i64, i64* %info.addr, align 8
  %call = call i64 @XSAVE_OBJECT(i64 %0, i32 0)
  %call1 = call i64 @Fmarker_buffer(i64 %call)
  store i64 %call1, i64* %tem, align 8
  %1 = load i64, i64* %tem, align 8
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %1, %call2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %out

if.end:                                           ; preds = %entry
  %2 = load i64, i64* %tem, align 8
  %call3 = call i64 @Fset_buffer(i64 %2)
  %3 = load i64, i64* %info.addr, align 8
  %call4 = call i64 @XSAVE_OBJECT(i64 %3, i32 0)
  store i64 %call4, i64* %tem, align 8
  %4 = load i64, i64* %tem, align 8
  %call5 = call i64 @Fgoto_char(i64 %4)
  %5 = load i64, i64* %tem, align 8
  %call6 = call %struct.Lisp_Marker* @XMARKER(i64 %5)
  call void @unchain_marker(%struct.Lisp_Marker* %call6)
  %6 = load i64, i64* %info.addr, align 8
  %call7 = call i64 @XSAVE_OBJECT(i64 %6, i32 2)
  store i64 %call7, i64* %tem, align 8
  %7 = load i64, i64* %tem, align 8
  %call8 = call zeroext i1 @WINDOWP(i64 %7)
  br i1 %call8, label %land.lhs.true, label %if.end.18

land.lhs.true:                                    ; preds = %if.end
  %8 = load i64, i64* %tem, align 8
  %9 = load i64, i64* @selected_window, align 8
  %cmp9 = icmp eq i64 %8, %9
  br i1 %cmp9, label %if.end.18, label %land.lhs.true.10

land.lhs.true.10:                                 ; preds = %land.lhs.true
  %10 = load i64, i64* %tem, align 8
  %call11 = call %struct.window* @XWINDOW(i64 %10)
  %contents = getelementptr inbounds %struct.window, %struct.window* %call11, i32 0, i32 10
  %11 = load i64, i64* %contents, align 8
  store i64 %11, i64* %tem1, align 8
  %12 = load i64, i64* %tem1, align 8
  %call12 = call zeroext i1 @BUFFERP(i64 %12)
  br i1 %call12, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true.10
  %13 = load i64, i64* %tem1, align 8
  %call13 = call %struct.buffer* @XBUFFER(i64 %13)
  %14 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %cmp14 = icmp eq %struct.buffer* %call13, %14
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true.10
  %15 = phi i1 [ false, %land.lhs.true.10 ], [ %cmp14, %land.rhs ]
  br i1 %15, label %if.then.15, label %if.end.18

if.then.15:                                       ; preds = %land.end
  %16 = load i64, i64* %tem, align 8
  %17 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt = getelementptr inbounds %struct.buffer, %struct.buffer* %17, i32 0, i32 75
  %18 = load i64, i64* %pt, align 8
  %add = add nsw i64 %18, 0
  %shl = shl i64 %add, 2
  %add16 = add i64 %shl, 2
  %call17 = call i64 @Fset_window_point(i64 %16, i64 %add16)
  br label %if.end.18

if.end.18:                                        ; preds = %if.then.15, %land.end, %land.lhs.true, %if.end
  br label %out

out:                                              ; preds = %if.end.18, %if.then
  %19 = load i64, i64* %info.addr, align 8
  call void @free_misc(i64 %19)
  ret void
}

declare i64 @Fmarker_buffer(i64) #1

declare i64 @XSAVE_OBJECT(i64, i32) #1

declare i64 @Fset_buffer(i64) #1

declare void @unchain_marker(%struct.Lisp_Marker*) #1

declare i64 @Fset_window_point(i64, i64) #1

declare void @free_misc(i64) #1

; Function Attrs: nounwind uwtable
define i64 @Fsave_excursion(i64 %args) #0 {
entry:
  %args.addr = alloca i64, align 8
  %val = alloca i64, align 8
  %count = alloca i64, align 8
  store i64 %args, i64* %args.addr, align 8
  %call = call i64 @SPECPDL_INDEX()
  store i64 %call, i64* %count, align 8
  %call1 = call i64 @save_excursion_save()
  call void @record_unwind_protect(void (i64)* @save_excursion_restore, i64 %call1)
  %0 = load i64, i64* %args.addr, align 8
  %call2 = call i64 @Fprogn(i64 %0)
  store i64 %call2, i64* %val, align 8
  %1 = load i64, i64* %count, align 8
  %2 = load i64, i64* %val, align 8
  %call3 = call i64 @unbind_to(i64 %1, i64 %2)
  ret i64 %call3
}

declare i64 @Fprogn(i64) #1

; Function Attrs: nounwind uwtable
define i64 @Fsave_current_buffer(i64 %args) #0 {
entry:
  %args.addr = alloca i64, align 8
  %count = alloca i64, align 8
  store i64 %args, i64* %args.addr, align 8
  %call = call i64 @SPECPDL_INDEX()
  store i64 %call, i64* %count, align 8
  call void @record_unwind_current_buffer()
  %0 = load i64, i64* %count, align 8
  %1 = load i64, i64* %args.addr, align 8
  %call1 = call i64 @Fprogn(i64 %1)
  %call2 = call i64 @unbind_to(i64 %0, i64 %call1)
  ret i64 %call2
}

declare void @record_unwind_current_buffer() #1

; Function Attrs: nounwind uwtable
define i64 @Fbuffer_size(i64 %buffer) #0 {
entry:
  %retval = alloca i64, align 8
  %buffer.addr = alloca i64, align 8
  store i64 %buffer, i64* %buffer.addr, align 8
  %0 = load i64, i64* %buffer.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %0, %call
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text = getelementptr inbounds %struct.buffer, %struct.buffer* %1, i32 0, i32 73
  %2 = load %struct.buffer_text*, %struct.buffer_text** %text, align 8
  %z = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %2, i32 0, i32 2
  %3 = load i64, i64* %z, align 8
  %sub = sub nsw i64 %3, 1
  %shl = shl i64 %sub, 2
  %add = add i64 %shl, 2
  store i64 %add, i64* %retval
  br label %return

if.else:                                          ; preds = %entry
  %4 = load i64, i64* %buffer.addr, align 8
  call void @CHECK_BUFFER(i64 %4)
  %5 = load i64, i64* %buffer.addr, align 8
  %call1 = call %struct.buffer* @XBUFFER(i64 %5)
  %text2 = getelementptr inbounds %struct.buffer, %struct.buffer* %call1, i32 0, i32 73
  %6 = load %struct.buffer_text*, %struct.buffer_text** %text2, align 8
  %z3 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %6, i32 0, i32 2
  %7 = load i64, i64* %z3, align 8
  %sub4 = sub nsw i64 %7, 1
  %shl5 = shl i64 %sub4, 2
  %add6 = add i64 %shl5, 2
  store i64 %add6, i64* %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %8 = load i64, i64* %retval
  ret i64 %8
}

declare void @CHECK_BUFFER(i64) #1

; Function Attrs: nounwind uwtable
define i64 @Fpoint_min() #0 {
entry:
  %temp = alloca i64, align 8
  %0 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv = getelementptr inbounds %struct.buffer, %struct.buffer* %0, i32 0, i32 77
  %1 = load i64, i64* %begv, align 8
  %call = call i64 @make_natnum(i64 %1)
  store i64 %call, i64* %temp, align 8
  %2 = load i64, i64* %temp, align 8
  ret i64 %2
}

; Function Attrs: nounwind uwtable
define i64 @Fpoint_min_marker() #0 {
entry:
  %0 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %1 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv = getelementptr inbounds %struct.buffer, %struct.buffer* %1, i32 0, i32 77
  %2 = load i64, i64* %begv, align 8
  %3 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv_byte = getelementptr inbounds %struct.buffer, %struct.buffer* %3, i32 0, i32 78
  %4 = load i64, i64* %begv_byte, align 8
  %call = call i64 @build_marker(%struct.buffer* %0, i64 %2, i64 %4)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define i64 @Fpoint_max() #0 {
entry:
  %temp = alloca i64, align 8
  %0 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv = getelementptr inbounds %struct.buffer, %struct.buffer* %0, i32 0, i32 79
  %1 = load i64, i64* %zv, align 8
  %call = call i64 @make_natnum(i64 %1)
  store i64 %call, i64* %temp, align 8
  %2 = load i64, i64* %temp, align 8
  ret i64 %2
}

; Function Attrs: nounwind uwtable
define i64 @Fpoint_max_marker() #0 {
entry:
  %0 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %1 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv = getelementptr inbounds %struct.buffer, %struct.buffer* %1, i32 0, i32 79
  %2 = load i64, i64* %zv, align 8
  %3 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv_byte = getelementptr inbounds %struct.buffer, %struct.buffer* %3, i32 0, i32 80
  %4 = load i64, i64* %zv_byte, align 8
  %call = call i64 @build_marker(%struct.buffer* %0, i64 %2, i64 %4)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define i64 @Fgap_position() #0 {
entry:
  %temp = alloca i64, align 8
  %0 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text = getelementptr inbounds %struct.buffer, %struct.buffer* %0, i32 0, i32 73
  %1 = load %struct.buffer_text*, %struct.buffer_text** %text, align 8
  %gpt = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %1, i32 0, i32 1
  %2 = load i64, i64* %gpt, align 8
  %call = call i64 @make_natnum(i64 %2)
  store i64 %call, i64* %temp, align 8
  %3 = load i64, i64* %temp, align 8
  ret i64 %3
}

; Function Attrs: nounwind uwtable
define i64 @Fgap_size() #0 {
entry:
  %temp = alloca i64, align 8
  %0 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text = getelementptr inbounds %struct.buffer, %struct.buffer* %0, i32 0, i32 73
  %1 = load %struct.buffer_text*, %struct.buffer_text** %text, align 8
  %gap_size = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %1, i32 0, i32 5
  %2 = load i64, i64* %gap_size, align 8
  %call = call i64 @make_natnum(i64 %2)
  store i64 %call, i64* %temp, align 8
  %3 = load i64, i64* %temp, align 8
  ret i64 %3
}

; Function Attrs: nounwind uwtable
define i64 @Fposition_bytes(i64 %position) #0 {
entry:
  %retval = alloca i64, align 8
  %position.addr = alloca i64, align 8
  store i64 %position, i64* %position.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load i64, i64* %position.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 1
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %do.body
  %1 = load i64, i64* %position.addr, align 8
  %call = call i32 @XMISCTYPE(i64 %1)
  %cmp2 = icmp eq i32 %call, 24236
  br i1 %cmp2, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %2 = load i64, i64* %position.addr, align 8
  %call4 = call i64 @marker_position(i64 %2)
  %call5 = call i64 @make_natnum(i64 %call4)
  store i64 %call5, i64* %position.addr, align 8
  br label %if.end

if.else:                                          ; preds = %land.lhs.true, %do.body
  %3 = load i64, i64* %position.addr, align 8
  %and6 = and i64 %3, 7
  %conv7 = trunc i64 %and6 to i32
  %and8 = and i32 %conv7, -5
  %cmp9 = icmp eq i32 %and8, 2
  br i1 %cmp9, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.else
  br label %cond.end

cond.false:                                       ; preds = %if.else
  %call11 = call i64 @builtin_lisp_symbol(i32 558)
  %4 = load i64, i64* %position.addr, align 8
  %5 = call i64 @wrong_type_argument(i64 %call11, i64 %4) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %6, %cond.true
  br label %if.end

if.end:                                           ; preds = %cond.end, %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %7 = load i64, i64* %position.addr, align 8
  %shr = ashr i64 %7, 2
  %cmp12 = icmp slt i64 %shr, 1
  br i1 %cmp12, label %if.then.17, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.end
  %8 = load i64, i64* %position.addr, align 8
  %shr14 = ashr i64 %8, 2
  %9 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text = getelementptr inbounds %struct.buffer, %struct.buffer* %9, i32 0, i32 73
  %10 = load %struct.buffer_text*, %struct.buffer_text** %text, align 8
  %z = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %10, i32 0, i32 2
  %11 = load i64, i64* %z, align 8
  %cmp15 = icmp sgt i64 %shr14, %11
  br i1 %cmp15, label %if.then.17, label %if.end.19

if.then.17:                                       ; preds = %lor.lhs.false, %do.end
  %call18 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call18, i64* %retval
  br label %return

if.end.19:                                        ; preds = %lor.lhs.false
  %12 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %13 = load i64, i64* %position.addr, align 8
  %shr20 = ashr i64 %13, 2
  %call21 = call i64 @buf_charpos_to_bytepos(%struct.buffer* %12, i64 %shr20)
  %shl = shl i64 %call21, 2
  %add = add i64 %shl, 2
  store i64 %add, i64* %retval
  br label %return

return:                                           ; preds = %if.end.19, %if.then.17
  %14 = load i64, i64* %retval
  ret i64 %14
}

declare i64 @buf_charpos_to_bytepos(%struct.buffer*, i64) #1

; Function Attrs: nounwind uwtable
define i64 @Fbyte_to_position(i64 %bytepos) #0 {
entry:
  %retval = alloca i64, align 8
  %bytepos.addr = alloca i64, align 8
  %pos_byte = alloca i64, align 8
  store i64 %bytepos, i64* %bytepos.addr, align 8
  %0 = load i64, i64* %bytepos.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %and1 = and i32 %conv, -5
  %cmp = icmp eq i32 %and1, 2
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = call i64 @builtin_lisp_symbol(i32 559)
  %1 = load i64, i64* %bytepos.addr, align 8
  %2 = call i64 @wrong_type_argument(i64 %call, i64 %1) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %3, %cond.true
  %4 = load i64, i64* %bytepos.addr, align 8
  %shr = ashr i64 %4, 2
  store i64 %shr, i64* %pos_byte, align 8
  %5 = load i64, i64* %pos_byte, align 8
  %cmp3 = icmp slt i64 %5, 1
  br i1 %cmp3, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end
  %6 = load i64, i64* %pos_byte, align 8
  %7 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text = getelementptr inbounds %struct.buffer, %struct.buffer* %7, i32 0, i32 73
  %8 = load %struct.buffer_text*, %struct.buffer_text** %text, align 8
  %z_byte = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %8, i32 0, i32 4
  %9 = load i64, i64* %z_byte, align 8
  %cmp5 = icmp sgt i64 %6, %9
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %cond.end
  %call7 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call7, i64* %retval
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %10 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text8 = getelementptr inbounds %struct.buffer, %struct.buffer* %10, i32 0, i32 73
  %11 = load %struct.buffer_text*, %struct.buffer_text** %text8, align 8
  %z = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %11, i32 0, i32 2
  %12 = load i64, i64* %z, align 8
  %13 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text9 = getelementptr inbounds %struct.buffer, %struct.buffer* %13, i32 0, i32 73
  %14 = load %struct.buffer_text*, %struct.buffer_text** %text9, align 8
  %z_byte10 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %14, i32 0, i32 4
  %15 = load i64, i64* %z_byte10, align 8
  %cmp11 = icmp ne i64 %12, %15
  br i1 %cmp11, label %if.then.13, label %if.end.27

if.then.13:                                       ; preds = %if.end
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then.13
  %16 = load i64, i64* %pos_byte, align 8
  %17 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text14 = getelementptr inbounds %struct.buffer, %struct.buffer* %17, i32 0, i32 73
  %18 = load %struct.buffer_text*, %struct.buffer_text** %text14, align 8
  %gpt_byte = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %18, i32 0, i32 3
  %19 = load i64, i64* %gpt_byte, align 8
  %cmp15 = icmp sge i64 %16, %19
  br i1 %cmp15, label %cond.true.17, label %cond.false.19

cond.true.17:                                     ; preds = %while.cond
  %20 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text18 = getelementptr inbounds %struct.buffer, %struct.buffer* %20, i32 0, i32 73
  %21 = load %struct.buffer_text*, %struct.buffer_text** %text18, align 8
  %gap_size = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %21, i32 0, i32 5
  %22 = load i64, i64* %gap_size, align 8
  br label %cond.end.20

cond.false.19:                                    ; preds = %while.cond
  br label %cond.end.20

cond.end.20:                                      ; preds = %cond.false.19, %cond.true.17
  %cond = phi i64 [ %22, %cond.true.17 ], [ 0, %cond.false.19 ]
  %23 = load i64, i64* %pos_byte, align 8
  %add = add nsw i64 %cond, %23
  %24 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text21 = getelementptr inbounds %struct.buffer, %struct.buffer* %24, i32 0, i32 73
  %25 = load %struct.buffer_text*, %struct.buffer_text** %text21, align 8
  %beg = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %25, i32 0, i32 0
  %26 = load i8*, i8** %beg, align 8
  %add.ptr = getelementptr inbounds i8, i8* %26, i64 %add
  %add.ptr22 = getelementptr inbounds i8, i8* %add.ptr, i64 -1
  %27 = load i8, i8* %add.ptr22, align 1
  %conv23 = zext i8 %27 to i32
  %and24 = and i32 %conv23, 192
  %cmp25 = icmp ne i32 %and24, 128
  %lnot = xor i1 %cmp25, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %cond.end.20
  %28 = load i64, i64* %pos_byte, align 8
  %dec = add nsw i64 %28, -1
  store i64 %dec, i64* %pos_byte, align 8
  br label %while.cond

while.end:                                        ; preds = %cond.end.20
  br label %if.end.27

if.end.27:                                        ; preds = %while.end, %if.end
  %29 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %30 = load i64, i64* %pos_byte, align 8
  %call28 = call i64 @buf_bytepos_to_charpos(%struct.buffer* %29, i64 %30)
  %shl = shl i64 %call28, 2
  %add29 = add i64 %shl, 2
  store i64 %add29, i64* %retval
  br label %return

return:                                           ; preds = %if.end.27, %if.then
  %31 = load i64, i64* %retval
  ret i64 %31
}

declare i64 @buf_bytepos_to_charpos(%struct.buffer*, i64) #1

; Function Attrs: nounwind uwtable
define i64 @Ffollowing_char() #0 {
entry:
  %temp = alloca i64, align 8
  %0 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt = getelementptr inbounds %struct.buffer, %struct.buffer* %0, i32 0, i32 75
  %1 = load i64, i64* %pt, align 8
  %add = add nsw i64 %1, 0
  %2 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv = getelementptr inbounds %struct.buffer, %struct.buffer* %2, i32 0, i32 79
  %3 = load i64, i64* %zv, align 8
  %cmp = icmp sge i64 %add, %3
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call = call i64 @make_natnum(i64 0)
  store i64 %call, i64* %temp, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %4 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %enable_multibyte_characters_ = getelementptr inbounds %struct.buffer, %struct.buffer* %4, i32 0, i32 39
  %5 = load i64, i64* %enable_multibyte_characters_, align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp2 = icmp eq i64 %5, %call1
  br i1 %cmp2, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.else
  %6 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt_byte = getelementptr inbounds %struct.buffer, %struct.buffer* %6, i32 0, i32 76
  %7 = load i64, i64* %pt_byte, align 8
  %add3 = add nsw i64 %7, 0
  %call4 = call i32 @FETCH_MULTIBYTE_CHAR(i64 %add3)
  br label %cond.end.16

cond.false:                                       ; preds = %if.else
  %8 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt_byte5 = getelementptr inbounds %struct.buffer, %struct.buffer* %8, i32 0, i32 76
  %9 = load i64, i64* %pt_byte5, align 8
  %add6 = add nsw i64 %9, 0
  %10 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text = getelementptr inbounds %struct.buffer, %struct.buffer* %10, i32 0, i32 73
  %11 = load %struct.buffer_text*, %struct.buffer_text** %text, align 8
  %gpt_byte = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %11, i32 0, i32 3
  %12 = load i64, i64* %gpt_byte, align 8
  %cmp7 = icmp sge i64 %add6, %12
  br i1 %cmp7, label %cond.true.8, label %cond.false.10

cond.true.8:                                      ; preds = %cond.false
  %13 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text9 = getelementptr inbounds %struct.buffer, %struct.buffer* %13, i32 0, i32 73
  %14 = load %struct.buffer_text*, %struct.buffer_text** %text9, align 8
  %gap_size = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %14, i32 0, i32 5
  %15 = load i64, i64* %gap_size, align 8
  br label %cond.end

cond.false.10:                                    ; preds = %cond.false
  br label %cond.end

cond.end:                                         ; preds = %cond.false.10, %cond.true.8
  %cond = phi i64 [ %15, %cond.true.8 ], [ 0, %cond.false.10 ]
  %16 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt_byte11 = getelementptr inbounds %struct.buffer, %struct.buffer* %16, i32 0, i32 76
  %17 = load i64, i64* %pt_byte11, align 8
  %add12 = add nsw i64 %17, 0
  %add13 = add nsw i64 %cond, %add12
  %18 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text14 = getelementptr inbounds %struct.buffer, %struct.buffer* %18, i32 0, i32 73
  %19 = load %struct.buffer_text*, %struct.buffer_text** %text14, align 8
  %beg = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %19, i32 0, i32 0
  %20 = load i8*, i8** %beg, align 8
  %add.ptr = getelementptr inbounds i8, i8* %20, i64 %add13
  %add.ptr15 = getelementptr inbounds i8, i8* %add.ptr, i64 -1
  %21 = load i8, i8* %add.ptr15, align 1
  %conv = zext i8 %21 to i32
  br label %cond.end.16

cond.end.16:                                      ; preds = %cond.end, %cond.true
  %cond17 = phi i32 [ %call4, %cond.true ], [ %conv, %cond.end ]
  %conv18 = sext i32 %cond17 to i64
  %call19 = call i64 @make_natnum(i64 %conv18)
  store i64 %call19, i64* %temp, align 8
  br label %if.end

if.end:                                           ; preds = %cond.end.16, %if.then
  %22 = load i64, i64* %temp, align 8
  ret i64 %22
}

declare i32 @FETCH_MULTIBYTE_CHAR(i64) #1

; Function Attrs: nounwind uwtable
define i64 @Fprevious_char() #0 {
entry:
  %temp = alloca i64, align 8
  %pos = alloca i64, align 8
  %chp = alloca i8*, align 8
  %0 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt = getelementptr inbounds %struct.buffer, %struct.buffer* %0, i32 0, i32 75
  %1 = load i64, i64* %pt, align 8
  %add = add nsw i64 %1, 0
  %2 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv = getelementptr inbounds %struct.buffer, %struct.buffer* %2, i32 0, i32 77
  %3 = load i64, i64* %begv, align 8
  %cmp = icmp sle i64 %add, %3
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call = call i64 @make_natnum(i64 0)
  store i64 %call, i64* %temp, align 8
  br label %if.end.66

if.else:                                          ; preds = %entry
  %4 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %enable_multibyte_characters_ = getelementptr inbounds %struct.buffer, %struct.buffer* %4, i32 0, i32 39
  %5 = load i64, i64* %enable_multibyte_characters_, align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp2 = icmp eq i64 %5, %call1
  br i1 %cmp2, label %if.else.42, label %if.then.3

if.then.3:                                        ; preds = %if.else
  %6 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt_byte = getelementptr inbounds %struct.buffer, %struct.buffer* %6, i32 0, i32 76
  %7 = load i64, i64* %pt_byte, align 8
  %add4 = add nsw i64 %7, 0
  store i64 %add4, i64* %pos, align 8
  br label %do.body

do.body:                                          ; preds = %if.then.3
  %8 = load i64, i64* %pos, align 8
  %dec = add nsw i64 %8, -1
  store i64 %dec, i64* %pos, align 8
  %9 = load i64, i64* %pos, align 8
  %10 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text = getelementptr inbounds %struct.buffer, %struct.buffer* %10, i32 0, i32 73
  %11 = load %struct.buffer_text*, %struct.buffer_text** %text, align 8
  %gpt_byte = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %11, i32 0, i32 3
  %12 = load i64, i64* %gpt_byte, align 8
  %cmp5 = icmp slt i64 %9, %12
  br i1 %cmp5, label %if.then.6, label %if.else.9

if.then.6:                                        ; preds = %do.body
  %13 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text7 = getelementptr inbounds %struct.buffer, %struct.buffer* %13, i32 0, i32 73
  %14 = load %struct.buffer_text*, %struct.buffer_text** %text7, align 8
  %beg = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %14, i32 0, i32 0
  %15 = load i8*, i8** %beg, align 8
  %16 = load i64, i64* %pos, align 8
  %add.ptr = getelementptr inbounds i8, i8* %15, i64 %16
  %add.ptr8 = getelementptr inbounds i8, i8* %add.ptr, i64 -1
  store i8* %add.ptr8, i8** %chp, align 8
  br label %if.end

if.else.9:                                        ; preds = %do.body
  %17 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text10 = getelementptr inbounds %struct.buffer, %struct.buffer* %17, i32 0, i32 73
  %18 = load %struct.buffer_text*, %struct.buffer_text** %text10, align 8
  %beg11 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %18, i32 0, i32 0
  %19 = load i8*, i8** %beg11, align 8
  %20 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text12 = getelementptr inbounds %struct.buffer, %struct.buffer* %20, i32 0, i32 73
  %21 = load %struct.buffer_text*, %struct.buffer_text** %text12, align 8
  %gap_size = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %21, i32 0, i32 5
  %22 = load i64, i64* %gap_size, align 8
  %add.ptr13 = getelementptr inbounds i8, i8* %19, i64 %22
  %23 = load i64, i64* %pos, align 8
  %add.ptr14 = getelementptr inbounds i8, i8* %add.ptr13, i64 %23
  %add.ptr15 = getelementptr inbounds i8, i8* %add.ptr14, i64 -1
  store i8* %add.ptr15, i8** %chp, align 8
  br label %if.end

if.end:                                           ; preds = %if.else.9, %if.then.6
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end
  %24 = load i8*, i8** %chp, align 8
  %25 = load i8, i8* %24, align 1
  %conv = zext i8 %25 to i32
  %and = and i32 %conv, 192
  %cmp16 = icmp ne i32 %and, 128
  %lnot = xor i1 %cmp16, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %26 = load i8*, i8** %chp, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %26, i32 -1
  store i8* %incdec.ptr, i8** %chp, align 8
  %27 = load i64, i64* %pos, align 8
  %dec18 = add nsw i64 %27, -1
  store i64 %dec18, i64* %pos, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  br label %do.end

do.end:                                           ; preds = %while.end
  %28 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %enable_multibyte_characters_19 = getelementptr inbounds %struct.buffer, %struct.buffer* %28, i32 0, i32 39
  %29 = load i64, i64* %enable_multibyte_characters_19, align 8
  %call20 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp21 = icmp eq i64 %29, %call20
  br i1 %cmp21, label %cond.false, label %cond.true

cond.true:                                        ; preds = %do.end
  %30 = load i64, i64* %pos, align 8
  %call23 = call i32 @FETCH_MULTIBYTE_CHAR(i64 %30)
  br label %cond.end.38

cond.false:                                       ; preds = %do.end
  %31 = load i64, i64* %pos, align 8
  %32 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text24 = getelementptr inbounds %struct.buffer, %struct.buffer* %32, i32 0, i32 73
  %33 = load %struct.buffer_text*, %struct.buffer_text** %text24, align 8
  %gpt_byte25 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %33, i32 0, i32 3
  %34 = load i64, i64* %gpt_byte25, align 8
  %cmp26 = icmp sge i64 %31, %34
  br i1 %cmp26, label %cond.true.28, label %cond.false.31

cond.true.28:                                     ; preds = %cond.false
  %35 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text29 = getelementptr inbounds %struct.buffer, %struct.buffer* %35, i32 0, i32 73
  %36 = load %struct.buffer_text*, %struct.buffer_text** %text29, align 8
  %gap_size30 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %36, i32 0, i32 5
  %37 = load i64, i64* %gap_size30, align 8
  br label %cond.end

cond.false.31:                                    ; preds = %cond.false
  br label %cond.end

cond.end:                                         ; preds = %cond.false.31, %cond.true.28
  %cond = phi i64 [ %37, %cond.true.28 ], [ 0, %cond.false.31 ]
  %38 = load i64, i64* %pos, align 8
  %add32 = add nsw i64 %cond, %38
  %39 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text33 = getelementptr inbounds %struct.buffer, %struct.buffer* %39, i32 0, i32 73
  %40 = load %struct.buffer_text*, %struct.buffer_text** %text33, align 8
  %beg34 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %40, i32 0, i32 0
  %41 = load i8*, i8** %beg34, align 8
  %add.ptr35 = getelementptr inbounds i8, i8* %41, i64 %add32
  %add.ptr36 = getelementptr inbounds i8, i8* %add.ptr35, i64 -1
  %42 = load i8, i8* %add.ptr36, align 1
  %conv37 = zext i8 %42 to i32
  br label %cond.end.38

cond.end.38:                                      ; preds = %cond.end, %cond.true
  %cond39 = phi i32 [ %call23, %cond.true ], [ %conv37, %cond.end ]
  %conv40 = sext i32 %cond39 to i64
  %call41 = call i64 @make_natnum(i64 %conv40)
  store i64 %call41, i64* %temp, align 8
  br label %if.end.65

if.else.42:                                       ; preds = %if.else
  %43 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt_byte43 = getelementptr inbounds %struct.buffer, %struct.buffer* %43, i32 0, i32 76
  %44 = load i64, i64* %pt_byte43, align 8
  %add44 = add nsw i64 %44, 0
  %sub = sub nsw i64 %add44, 1
  %45 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text45 = getelementptr inbounds %struct.buffer, %struct.buffer* %45, i32 0, i32 73
  %46 = load %struct.buffer_text*, %struct.buffer_text** %text45, align 8
  %gpt_byte46 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %46, i32 0, i32 3
  %47 = load i64, i64* %gpt_byte46, align 8
  %cmp47 = icmp sge i64 %sub, %47
  br i1 %cmp47, label %cond.true.49, label %cond.false.52

cond.true.49:                                     ; preds = %if.else.42
  %48 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text50 = getelementptr inbounds %struct.buffer, %struct.buffer* %48, i32 0, i32 73
  %49 = load %struct.buffer_text*, %struct.buffer_text** %text50, align 8
  %gap_size51 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %49, i32 0, i32 5
  %50 = load i64, i64* %gap_size51, align 8
  br label %cond.end.53

cond.false.52:                                    ; preds = %if.else.42
  br label %cond.end.53

cond.end.53:                                      ; preds = %cond.false.52, %cond.true.49
  %cond54 = phi i64 [ %50, %cond.true.49 ], [ 0, %cond.false.52 ]
  %51 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt_byte55 = getelementptr inbounds %struct.buffer, %struct.buffer* %51, i32 0, i32 76
  %52 = load i64, i64* %pt_byte55, align 8
  %add56 = add nsw i64 %52, 0
  %sub57 = sub nsw i64 %add56, 1
  %add58 = add nsw i64 %cond54, %sub57
  %53 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text59 = getelementptr inbounds %struct.buffer, %struct.buffer* %53, i32 0, i32 73
  %54 = load %struct.buffer_text*, %struct.buffer_text** %text59, align 8
  %beg60 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %54, i32 0, i32 0
  %55 = load i8*, i8** %beg60, align 8
  %add.ptr61 = getelementptr inbounds i8, i8* %55, i64 %add58
  %add.ptr62 = getelementptr inbounds i8, i8* %add.ptr61, i64 -1
  %56 = load i8, i8* %add.ptr62, align 1
  %conv63 = zext i8 %56 to i64
  %call64 = call i64 @make_natnum(i64 %conv63)
  store i64 %call64, i64* %temp, align 8
  br label %if.end.65

if.end.65:                                        ; preds = %cond.end.53, %cond.end.38
  br label %if.end.66

if.end.66:                                        ; preds = %if.end.65, %if.then
  %57 = load i64, i64* %temp, align 8
  ret i64 %57
}

; Function Attrs: nounwind uwtable
define i64 @Fbobp() #0 {
entry:
  %retval = alloca i64, align 8
  %0 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt = getelementptr inbounds %struct.buffer, %struct.buffer* %0, i32 0, i32 75
  %1 = load i64, i64* %pt, align 8
  %add = add nsw i64 %1, 0
  %2 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv = getelementptr inbounds %struct.buffer, %struct.buffer* %2, i32 0, i32 77
  %3 = load i64, i64* %begv, align 8
  %cmp = icmp eq i64 %add, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i64 @builtin_lisp_symbol(i32 901)
  store i64 %call, i64* %retval
  br label %return

if.end:                                           ; preds = %entry
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call1, i64* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load i64, i64* %retval
  ret i64 %4
}

; Function Attrs: nounwind uwtable
define i64 @Feobp() #0 {
entry:
  %retval = alloca i64, align 8
  %0 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt = getelementptr inbounds %struct.buffer, %struct.buffer* %0, i32 0, i32 75
  %1 = load i64, i64* %pt, align 8
  %add = add nsw i64 %1, 0
  %2 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv = getelementptr inbounds %struct.buffer, %struct.buffer* %2, i32 0, i32 79
  %3 = load i64, i64* %zv, align 8
  %cmp = icmp eq i64 %add, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i64 @builtin_lisp_symbol(i32 901)
  store i64 %call, i64* %retval
  br label %return

if.end:                                           ; preds = %entry
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call1, i64* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load i64, i64* %retval
  ret i64 %4
}

; Function Attrs: nounwind uwtable
define i64 @Fbolp() #0 {
entry:
  %retval = alloca i64, align 8
  %0 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt = getelementptr inbounds %struct.buffer, %struct.buffer* %0, i32 0, i32 75
  %1 = load i64, i64* %pt, align 8
  %add = add nsw i64 %1, 0
  %2 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv = getelementptr inbounds %struct.buffer, %struct.buffer* %2, i32 0, i32 77
  %3 = load i64, i64* %begv, align 8
  %cmp = icmp eq i64 %add, %3
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %4 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt_byte = getelementptr inbounds %struct.buffer, %struct.buffer* %4, i32 0, i32 76
  %5 = load i64, i64* %pt_byte, align 8
  %add1 = add nsw i64 %5, 0
  %sub = sub nsw i64 %add1, 1
  %6 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text = getelementptr inbounds %struct.buffer, %struct.buffer* %6, i32 0, i32 73
  %7 = load %struct.buffer_text*, %struct.buffer_text** %text, align 8
  %gpt_byte = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %7, i32 0, i32 3
  %8 = load i64, i64* %gpt_byte, align 8
  %cmp2 = icmp sge i64 %sub, %8
  br i1 %cmp2, label %cond.true, label %cond.false

cond.true:                                        ; preds = %lor.lhs.false
  %9 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text3 = getelementptr inbounds %struct.buffer, %struct.buffer* %9, i32 0, i32 73
  %10 = load %struct.buffer_text*, %struct.buffer_text** %text3, align 8
  %gap_size = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %10, i32 0, i32 5
  %11 = load i64, i64* %gap_size, align 8
  br label %cond.end

cond.false:                                       ; preds = %lor.lhs.false
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %11, %cond.true ], [ 0, %cond.false ]
  %12 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt_byte4 = getelementptr inbounds %struct.buffer, %struct.buffer* %12, i32 0, i32 76
  %13 = load i64, i64* %pt_byte4, align 8
  %add5 = add nsw i64 %13, 0
  %sub6 = sub nsw i64 %add5, 1
  %add7 = add nsw i64 %cond, %sub6
  %14 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text8 = getelementptr inbounds %struct.buffer, %struct.buffer* %14, i32 0, i32 73
  %15 = load %struct.buffer_text*, %struct.buffer_text** %text8, align 8
  %beg = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %15, i32 0, i32 0
  %16 = load i8*, i8** %beg, align 8
  %add.ptr = getelementptr inbounds i8, i8* %16, i64 %add7
  %add.ptr9 = getelementptr inbounds i8, i8* %add.ptr, i64 -1
  %17 = load i8, i8* %add.ptr9, align 1
  %conv = zext i8 %17 to i32
  %cmp10 = icmp eq i32 %conv, 10
  br i1 %cmp10, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end, %entry
  %call = call i64 @builtin_lisp_symbol(i32 901)
  store i64 %call, i64* %retval
  br label %return

if.end:                                           ; preds = %cond.end
  %call12 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call12, i64* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %18 = load i64, i64* %retval
  ret i64 %18
}

; Function Attrs: nounwind uwtable
define i64 @Feolp() #0 {
entry:
  %retval = alloca i64, align 8
  %0 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt = getelementptr inbounds %struct.buffer, %struct.buffer* %0, i32 0, i32 75
  %1 = load i64, i64* %pt, align 8
  %add = add nsw i64 %1, 0
  %2 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv = getelementptr inbounds %struct.buffer, %struct.buffer* %2, i32 0, i32 79
  %3 = load i64, i64* %zv, align 8
  %cmp = icmp eq i64 %add, %3
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %4 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt_byte = getelementptr inbounds %struct.buffer, %struct.buffer* %4, i32 0, i32 76
  %5 = load i64, i64* %pt_byte, align 8
  %add1 = add nsw i64 %5, 0
  %6 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text = getelementptr inbounds %struct.buffer, %struct.buffer* %6, i32 0, i32 73
  %7 = load %struct.buffer_text*, %struct.buffer_text** %text, align 8
  %gpt_byte = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %7, i32 0, i32 3
  %8 = load i64, i64* %gpt_byte, align 8
  %cmp2 = icmp sge i64 %add1, %8
  br i1 %cmp2, label %cond.true, label %cond.false

cond.true:                                        ; preds = %lor.lhs.false
  %9 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text3 = getelementptr inbounds %struct.buffer, %struct.buffer* %9, i32 0, i32 73
  %10 = load %struct.buffer_text*, %struct.buffer_text** %text3, align 8
  %gap_size = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %10, i32 0, i32 5
  %11 = load i64, i64* %gap_size, align 8
  br label %cond.end

cond.false:                                       ; preds = %lor.lhs.false
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %11, %cond.true ], [ 0, %cond.false ]
  %12 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt_byte4 = getelementptr inbounds %struct.buffer, %struct.buffer* %12, i32 0, i32 76
  %13 = load i64, i64* %pt_byte4, align 8
  %add5 = add nsw i64 %13, 0
  %add6 = add nsw i64 %cond, %add5
  %14 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text7 = getelementptr inbounds %struct.buffer, %struct.buffer* %14, i32 0, i32 73
  %15 = load %struct.buffer_text*, %struct.buffer_text** %text7, align 8
  %beg = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %15, i32 0, i32 0
  %16 = load i8*, i8** %beg, align 8
  %add.ptr = getelementptr inbounds i8, i8* %16, i64 %add6
  %add.ptr8 = getelementptr inbounds i8, i8* %add.ptr, i64 -1
  %17 = load i8, i8* %add.ptr8, align 1
  %conv = zext i8 %17 to i32
  %cmp9 = icmp eq i32 %conv, 10
  br i1 %cmp9, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end, %entry
  %call = call i64 @builtin_lisp_symbol(i32 901)
  store i64 %call, i64* %retval
  br label %return

if.end:                                           ; preds = %cond.end
  %call11 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call11, i64* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %18 = load i64, i64* %retval
  ret i64 %18
}

; Function Attrs: nounwind uwtable
define i64 @Fchar_after(i64 %pos) #0 {
entry:
  %retval = alloca i64, align 8
  %pos.addr = alloca i64, align 8
  %pos_byte = alloca i64, align 8
  store i64 %pos, i64* %pos.addr, align 8
  %0 = load i64, i64* %pos.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %0, %call
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt_byte = getelementptr inbounds %struct.buffer, %struct.buffer* %1, i32 0, i32 76
  %2 = load i64, i64* %pt_byte, align 8
  %add = add nsw i64 %2, 0
  store i64 %add, i64* %pos_byte, align 8
  %3 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt = getelementptr inbounds %struct.buffer, %struct.buffer* %3, i32 0, i32 75
  %4 = load i64, i64* %pt, align 8
  %add1 = add nsw i64 %4, 0
  %call2 = call i64 @make_natnum(i64 %add1)
  store i64 %call2, i64* %pos.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load i64, i64* %pos.addr, align 8
  %and = and i64 %5, 7
  %conv = trunc i64 %and to i32
  %cmp3 = icmp eq i32 %conv, 1
  br i1 %cmp3, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.end
  %6 = load i64, i64* %pos.addr, align 8
  %call5 = call i32 @XMISCTYPE(i64 %6)
  %cmp6 = icmp eq i32 %call5, 24236
  br i1 %cmp6, label %if.then.8, label %if.else

if.then.8:                                        ; preds = %land.lhs.true
  %7 = load i64, i64* %pos.addr, align 8
  %call9 = call i64 @marker_byte_position(i64 %7)
  store i64 %call9, i64* %pos_byte, align 8
  %8 = load i64, i64* %pos_byte, align 8
  %9 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv_byte = getelementptr inbounds %struct.buffer, %struct.buffer* %9, i32 0, i32 78
  %10 = load i64, i64* %begv_byte, align 8
  %cmp10 = icmp slt i64 %8, %10
  br i1 %cmp10, label %if.then.14, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then.8
  %11 = load i64, i64* %pos_byte, align 8
  %12 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv_byte = getelementptr inbounds %struct.buffer, %struct.buffer* %12, i32 0, i32 80
  %13 = load i64, i64* %zv_byte, align 8
  %cmp12 = icmp sge i64 %11, %13
  br i1 %cmp12, label %if.then.14, label %if.end.16

if.then.14:                                       ; preds = %lor.lhs.false, %if.then.8
  %call15 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call15, i64* %retval
  br label %return

if.end.16:                                        ; preds = %lor.lhs.false
  br label %if.end.47

if.else:                                          ; preds = %land.lhs.true, %if.end
  br label %do.body

do.body:                                          ; preds = %if.else
  %14 = load i64, i64* %pos.addr, align 8
  %and17 = and i64 %14, 7
  %conv18 = trunc i64 %and17 to i32
  %cmp19 = icmp eq i32 %conv18, 1
  br i1 %cmp19, label %land.lhs.true.21, label %if.else.28

land.lhs.true.21:                                 ; preds = %do.body
  %15 = load i64, i64* %pos.addr, align 8
  %call22 = call i32 @XMISCTYPE(i64 %15)
  %cmp23 = icmp eq i32 %call22, 24236
  br i1 %cmp23, label %if.then.25, label %if.else.28

if.then.25:                                       ; preds = %land.lhs.true.21
  %16 = load i64, i64* %pos.addr, align 8
  %call26 = call i64 @marker_position(i64 %16)
  %call27 = call i64 @make_natnum(i64 %call26)
  store i64 %call27, i64* %pos.addr, align 8
  br label %if.end.35

if.else.28:                                       ; preds = %land.lhs.true.21, %do.body
  %17 = load i64, i64* %pos.addr, align 8
  %and29 = and i64 %17, 7
  %conv30 = trunc i64 %and29 to i32
  %and31 = and i32 %conv30, -5
  %cmp32 = icmp eq i32 %and31, 2
  br i1 %cmp32, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.else.28
  br label %cond.end

cond.false:                                       ; preds = %if.else.28
  %call34 = call i64 @builtin_lisp_symbol(i32 558)
  %18 = load i64, i64* %pos.addr, align 8
  %19 = call i64 @wrong_type_argument(i64 %call34, i64 %18) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %20, %cond.true
  br label %if.end.35

if.end.35:                                        ; preds = %cond.end, %if.then.25
  br label %do.end

do.end:                                           ; preds = %if.end.35
  %21 = load i64, i64* %pos.addr, align 8
  %shr = ashr i64 %21, 2
  %22 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv = getelementptr inbounds %struct.buffer, %struct.buffer* %22, i32 0, i32 77
  %23 = load i64, i64* %begv, align 8
  %cmp36 = icmp slt i64 %shr, %23
  br i1 %cmp36, label %if.then.42, label %lor.lhs.false.38

lor.lhs.false.38:                                 ; preds = %do.end
  %24 = load i64, i64* %pos.addr, align 8
  %shr39 = ashr i64 %24, 2
  %25 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv = getelementptr inbounds %struct.buffer, %struct.buffer* %25, i32 0, i32 79
  %26 = load i64, i64* %zv, align 8
  %cmp40 = icmp sge i64 %shr39, %26
  br i1 %cmp40, label %if.then.42, label %if.end.44

if.then.42:                                       ; preds = %lor.lhs.false.38, %do.end
  %call43 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call43, i64* %retval
  br label %return

if.end.44:                                        ; preds = %lor.lhs.false.38
  %27 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %28 = load i64, i64* %pos.addr, align 8
  %shr45 = ashr i64 %28, 2
  %call46 = call i64 @buf_charpos_to_bytepos(%struct.buffer* %27, i64 %shr45)
  store i64 %call46, i64* %pos_byte, align 8
  br label %if.end.47

if.end.47:                                        ; preds = %if.end.44, %if.end.16
  %29 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %enable_multibyte_characters_ = getelementptr inbounds %struct.buffer, %struct.buffer* %29, i32 0, i32 39
  %30 = load i64, i64* %enable_multibyte_characters_, align 8
  %call48 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp49 = icmp eq i64 %30, %call48
  br i1 %cmp49, label %cond.false.53, label %cond.true.51

cond.true.51:                                     ; preds = %if.end.47
  %31 = load i64, i64* %pos_byte, align 8
  %call52 = call i32 @FETCH_MULTIBYTE_CHAR(i64 %31)
  br label %cond.end.64

cond.false.53:                                    ; preds = %if.end.47
  %32 = load i64, i64* %pos_byte, align 8
  %33 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text = getelementptr inbounds %struct.buffer, %struct.buffer* %33, i32 0, i32 73
  %34 = load %struct.buffer_text*, %struct.buffer_text** %text, align 8
  %gpt_byte = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %34, i32 0, i32 3
  %35 = load i64, i64* %gpt_byte, align 8
  %cmp54 = icmp sge i64 %32, %35
  br i1 %cmp54, label %cond.true.56, label %cond.false.58

cond.true.56:                                     ; preds = %cond.false.53
  %36 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text57 = getelementptr inbounds %struct.buffer, %struct.buffer* %36, i32 0, i32 73
  %37 = load %struct.buffer_text*, %struct.buffer_text** %text57, align 8
  %gap_size = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %37, i32 0, i32 5
  %38 = load i64, i64* %gap_size, align 8
  br label %cond.end.59

cond.false.58:                                    ; preds = %cond.false.53
  br label %cond.end.59

cond.end.59:                                      ; preds = %cond.false.58, %cond.true.56
  %cond = phi i64 [ %38, %cond.true.56 ], [ 0, %cond.false.58 ]
  %39 = load i64, i64* %pos_byte, align 8
  %add60 = add nsw i64 %cond, %39
  %40 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text61 = getelementptr inbounds %struct.buffer, %struct.buffer* %40, i32 0, i32 73
  %41 = load %struct.buffer_text*, %struct.buffer_text** %text61, align 8
  %beg = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %41, i32 0, i32 0
  %42 = load i8*, i8** %beg, align 8
  %add.ptr = getelementptr inbounds i8, i8* %42, i64 %add60
  %add.ptr62 = getelementptr inbounds i8, i8* %add.ptr, i64 -1
  %43 = load i8, i8* %add.ptr62, align 1
  %conv63 = zext i8 %43 to i32
  br label %cond.end.64

cond.end.64:                                      ; preds = %cond.end.59, %cond.true.51
  %cond65 = phi i32 [ %call52, %cond.true.51 ], [ %conv63, %cond.end.59 ]
  %conv66 = sext i32 %cond65 to i64
  %shl = shl i64 %conv66, 2
  %add67 = add i64 %shl, 2
  store i64 %add67, i64* %retval
  br label %return

return:                                           ; preds = %cond.end.64, %if.then.42, %if.then.14
  %44 = load i64, i64* %retval
  ret i64 %44
}

declare i64 @marker_byte_position(i64) #1

; Function Attrs: nounwind uwtable
define i64 @Fchar_before(i64 %pos) #0 {
entry:
  %retval = alloca i64, align 8
  %pos.addr = alloca i64, align 8
  %val = alloca i64, align 8
  %pos_byte = alloca i64, align 8
  %chp = alloca i8*, align 8
  store i64 %pos, i64* %pos.addr, align 8
  %0 = load i64, i64* %pos.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %0, %call
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt_byte = getelementptr inbounds %struct.buffer, %struct.buffer* %1, i32 0, i32 76
  %2 = load i64, i64* %pt_byte, align 8
  %add = add nsw i64 %2, 0
  store i64 %add, i64* %pos_byte, align 8
  %3 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt = getelementptr inbounds %struct.buffer, %struct.buffer* %3, i32 0, i32 75
  %4 = load i64, i64* %pt, align 8
  %add1 = add nsw i64 %4, 0
  %call2 = call i64 @make_natnum(i64 %add1)
  store i64 %call2, i64* %pos.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load i64, i64* %pos.addr, align 8
  %and = and i64 %5, 7
  %conv = trunc i64 %and to i32
  %cmp3 = icmp eq i32 %conv, 1
  br i1 %cmp3, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.end
  %6 = load i64, i64* %pos.addr, align 8
  %call5 = call i32 @XMISCTYPE(i64 %6)
  %cmp6 = icmp eq i32 %call5, 24236
  br i1 %cmp6, label %if.then.8, label %if.else

if.then.8:                                        ; preds = %land.lhs.true
  %7 = load i64, i64* %pos.addr, align 8
  %call9 = call i64 @marker_byte_position(i64 %7)
  store i64 %call9, i64* %pos_byte, align 8
  %8 = load i64, i64* %pos_byte, align 8
  %9 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv_byte = getelementptr inbounds %struct.buffer, %struct.buffer* %9, i32 0, i32 78
  %10 = load i64, i64* %begv_byte, align 8
  %cmp10 = icmp sle i64 %8, %10
  br i1 %cmp10, label %if.then.14, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then.8
  %11 = load i64, i64* %pos_byte, align 8
  %12 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv_byte = getelementptr inbounds %struct.buffer, %struct.buffer* %12, i32 0, i32 80
  %13 = load i64, i64* %zv_byte, align 8
  %cmp12 = icmp sgt i64 %11, %13
  br i1 %cmp12, label %if.then.14, label %if.end.16

if.then.14:                                       ; preds = %lor.lhs.false, %if.then.8
  %call15 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call15, i64* %retval
  br label %return

if.end.16:                                        ; preds = %lor.lhs.false
  br label %if.end.47

if.else:                                          ; preds = %land.lhs.true, %if.end
  br label %do.body

do.body:                                          ; preds = %if.else
  %14 = load i64, i64* %pos.addr, align 8
  %and17 = and i64 %14, 7
  %conv18 = trunc i64 %and17 to i32
  %cmp19 = icmp eq i32 %conv18, 1
  br i1 %cmp19, label %land.lhs.true.21, label %if.else.28

land.lhs.true.21:                                 ; preds = %do.body
  %15 = load i64, i64* %pos.addr, align 8
  %call22 = call i32 @XMISCTYPE(i64 %15)
  %cmp23 = icmp eq i32 %call22, 24236
  br i1 %cmp23, label %if.then.25, label %if.else.28

if.then.25:                                       ; preds = %land.lhs.true.21
  %16 = load i64, i64* %pos.addr, align 8
  %call26 = call i64 @marker_position(i64 %16)
  %call27 = call i64 @make_natnum(i64 %call26)
  store i64 %call27, i64* %pos.addr, align 8
  br label %if.end.35

if.else.28:                                       ; preds = %land.lhs.true.21, %do.body
  %17 = load i64, i64* %pos.addr, align 8
  %and29 = and i64 %17, 7
  %conv30 = trunc i64 %and29 to i32
  %and31 = and i32 %conv30, -5
  %cmp32 = icmp eq i32 %and31, 2
  br i1 %cmp32, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.else.28
  br label %cond.end

cond.false:                                       ; preds = %if.else.28
  %call34 = call i64 @builtin_lisp_symbol(i32 558)
  %18 = load i64, i64* %pos.addr, align 8
  %19 = call i64 @wrong_type_argument(i64 %call34, i64 %18) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %20, %cond.true
  br label %if.end.35

if.end.35:                                        ; preds = %cond.end, %if.then.25
  br label %do.end

do.end:                                           ; preds = %if.end.35
  %21 = load i64, i64* %pos.addr, align 8
  %shr = ashr i64 %21, 2
  %22 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv = getelementptr inbounds %struct.buffer, %struct.buffer* %22, i32 0, i32 77
  %23 = load i64, i64* %begv, align 8
  %cmp36 = icmp sle i64 %shr, %23
  br i1 %cmp36, label %if.then.42, label %lor.lhs.false.38

lor.lhs.false.38:                                 ; preds = %do.end
  %24 = load i64, i64* %pos.addr, align 8
  %shr39 = ashr i64 %24, 2
  %25 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv = getelementptr inbounds %struct.buffer, %struct.buffer* %25, i32 0, i32 79
  %26 = load i64, i64* %zv, align 8
  %cmp40 = icmp sgt i64 %shr39, %26
  br i1 %cmp40, label %if.then.42, label %if.end.44

if.then.42:                                       ; preds = %lor.lhs.false.38, %do.end
  %call43 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call43, i64* %retval
  br label %return

if.end.44:                                        ; preds = %lor.lhs.false.38
  %27 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %28 = load i64, i64* %pos.addr, align 8
  %shr45 = ashr i64 %28, 2
  %call46 = call i64 @buf_charpos_to_bytepos(%struct.buffer* %27, i64 %shr45)
  store i64 %call46, i64* %pos_byte, align 8
  br label %if.end.47

if.end.47:                                        ; preds = %if.end.44, %if.end.16
  %29 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %enable_multibyte_characters_ = getelementptr inbounds %struct.buffer, %struct.buffer* %29, i32 0, i32 39
  %30 = load i64, i64* %enable_multibyte_characters_, align 8
  %call48 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp49 = icmp eq i64 %30, %call48
  br i1 %cmp49, label %if.else.98, label %if.then.51

if.then.51:                                       ; preds = %if.end.47
  br label %do.body.52

do.body.52:                                       ; preds = %if.then.51
  %31 = load i64, i64* %pos_byte, align 8
  %dec = add nsw i64 %31, -1
  store i64 %dec, i64* %pos_byte, align 8
  %32 = load i64, i64* %pos_byte, align 8
  %33 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text = getelementptr inbounds %struct.buffer, %struct.buffer* %33, i32 0, i32 73
  %34 = load %struct.buffer_text*, %struct.buffer_text** %text, align 8
  %gpt_byte = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %34, i32 0, i32 3
  %35 = load i64, i64* %gpt_byte, align 8
  %cmp53 = icmp slt i64 %32, %35
  br i1 %cmp53, label %if.then.55, label %if.else.58

if.then.55:                                       ; preds = %do.body.52
  %36 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text56 = getelementptr inbounds %struct.buffer, %struct.buffer* %36, i32 0, i32 73
  %37 = load %struct.buffer_text*, %struct.buffer_text** %text56, align 8
  %beg = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %37, i32 0, i32 0
  %38 = load i8*, i8** %beg, align 8
  %39 = load i64, i64* %pos_byte, align 8
  %add.ptr = getelementptr inbounds i8, i8* %38, i64 %39
  %add.ptr57 = getelementptr inbounds i8, i8* %add.ptr, i64 -1
  store i8* %add.ptr57, i8** %chp, align 8
  br label %if.end.65

if.else.58:                                       ; preds = %do.body.52
  %40 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text59 = getelementptr inbounds %struct.buffer, %struct.buffer* %40, i32 0, i32 73
  %41 = load %struct.buffer_text*, %struct.buffer_text** %text59, align 8
  %beg60 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %41, i32 0, i32 0
  %42 = load i8*, i8** %beg60, align 8
  %43 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text61 = getelementptr inbounds %struct.buffer, %struct.buffer* %43, i32 0, i32 73
  %44 = load %struct.buffer_text*, %struct.buffer_text** %text61, align 8
  %gap_size = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %44, i32 0, i32 5
  %45 = load i64, i64* %gap_size, align 8
  %add.ptr62 = getelementptr inbounds i8, i8* %42, i64 %45
  %46 = load i64, i64* %pos_byte, align 8
  %add.ptr63 = getelementptr inbounds i8, i8* %add.ptr62, i64 %46
  %add.ptr64 = getelementptr inbounds i8, i8* %add.ptr63, i64 -1
  store i8* %add.ptr64, i8** %chp, align 8
  br label %if.end.65

if.end.65:                                        ; preds = %if.else.58, %if.then.55
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end.65
  %47 = load i8*, i8** %chp, align 8
  %48 = load i8, i8* %47, align 1
  %conv66 = zext i8 %48 to i32
  %and67 = and i32 %conv66, 192
  %cmp68 = icmp ne i32 %and67, 128
  %lnot = xor i1 %cmp68, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %49 = load i8*, i8** %chp, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %49, i32 -1
  store i8* %incdec.ptr, i8** %chp, align 8
  %50 = load i64, i64* %pos_byte, align 8
  %dec70 = add nsw i64 %50, -1
  store i64 %dec70, i64* %pos_byte, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  br label %do.end.71

do.end.71:                                        ; preds = %while.end
  %51 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %enable_multibyte_characters_72 = getelementptr inbounds %struct.buffer, %struct.buffer* %51, i32 0, i32 39
  %52 = load i64, i64* %enable_multibyte_characters_72, align 8
  %call73 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp74 = icmp eq i64 %52, %call73
  br i1 %cmp74, label %cond.false.78, label %cond.true.76

cond.true.76:                                     ; preds = %do.end.71
  %53 = load i64, i64* %pos_byte, align 8
  %call77 = call i32 @FETCH_MULTIBYTE_CHAR(i64 %53)
  br label %cond.end.94

cond.false.78:                                    ; preds = %do.end.71
  %54 = load i64, i64* %pos_byte, align 8
  %55 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text79 = getelementptr inbounds %struct.buffer, %struct.buffer* %55, i32 0, i32 73
  %56 = load %struct.buffer_text*, %struct.buffer_text** %text79, align 8
  %gpt_byte80 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %56, i32 0, i32 3
  %57 = load i64, i64* %gpt_byte80, align 8
  %cmp81 = icmp sge i64 %54, %57
  br i1 %cmp81, label %cond.true.83, label %cond.false.86

cond.true.83:                                     ; preds = %cond.false.78
  %58 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text84 = getelementptr inbounds %struct.buffer, %struct.buffer* %58, i32 0, i32 73
  %59 = load %struct.buffer_text*, %struct.buffer_text** %text84, align 8
  %gap_size85 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %59, i32 0, i32 5
  %60 = load i64, i64* %gap_size85, align 8
  br label %cond.end.87

cond.false.86:                                    ; preds = %cond.false.78
  br label %cond.end.87

cond.end.87:                                      ; preds = %cond.false.86, %cond.true.83
  %cond = phi i64 [ %60, %cond.true.83 ], [ 0, %cond.false.86 ]
  %61 = load i64, i64* %pos_byte, align 8
  %add88 = add nsw i64 %cond, %61
  %62 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text89 = getelementptr inbounds %struct.buffer, %struct.buffer* %62, i32 0, i32 73
  %63 = load %struct.buffer_text*, %struct.buffer_text** %text89, align 8
  %beg90 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %63, i32 0, i32 0
  %64 = load i8*, i8** %beg90, align 8
  %add.ptr91 = getelementptr inbounds i8, i8* %64, i64 %add88
  %add.ptr92 = getelementptr inbounds i8, i8* %add.ptr91, i64 -1
  %65 = load i8, i8* %add.ptr92, align 1
  %conv93 = zext i8 %65 to i32
  br label %cond.end.94

cond.end.94:                                      ; preds = %cond.end.87, %cond.true.76
  %cond95 = phi i32 [ %call77, %cond.true.76 ], [ %conv93, %cond.end.87 ]
  %conv96 = sext i32 %cond95 to i64
  %call97 = call i64 @make_natnum(i64 %conv96)
  store i64 %call97, i64* %val, align 8
  br label %if.end.117

if.else.98:                                       ; preds = %if.end.47
  %66 = load i64, i64* %pos_byte, align 8
  %dec99 = add nsw i64 %66, -1
  store i64 %dec99, i64* %pos_byte, align 8
  %67 = load i64, i64* %pos_byte, align 8
  %68 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text100 = getelementptr inbounds %struct.buffer, %struct.buffer* %68, i32 0, i32 73
  %69 = load %struct.buffer_text*, %struct.buffer_text** %text100, align 8
  %gpt_byte101 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %69, i32 0, i32 3
  %70 = load i64, i64* %gpt_byte101, align 8
  %cmp102 = icmp sge i64 %67, %70
  br i1 %cmp102, label %cond.true.104, label %cond.false.107

cond.true.104:                                    ; preds = %if.else.98
  %71 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text105 = getelementptr inbounds %struct.buffer, %struct.buffer* %71, i32 0, i32 73
  %72 = load %struct.buffer_text*, %struct.buffer_text** %text105, align 8
  %gap_size106 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %72, i32 0, i32 5
  %73 = load i64, i64* %gap_size106, align 8
  br label %cond.end.108

cond.false.107:                                   ; preds = %if.else.98
  br label %cond.end.108

cond.end.108:                                     ; preds = %cond.false.107, %cond.true.104
  %cond109 = phi i64 [ %73, %cond.true.104 ], [ 0, %cond.false.107 ]
  %74 = load i64, i64* %pos_byte, align 8
  %add110 = add nsw i64 %cond109, %74
  %75 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text111 = getelementptr inbounds %struct.buffer, %struct.buffer* %75, i32 0, i32 73
  %76 = load %struct.buffer_text*, %struct.buffer_text** %text111, align 8
  %beg112 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %76, i32 0, i32 0
  %77 = load i8*, i8** %beg112, align 8
  %add.ptr113 = getelementptr inbounds i8, i8* %77, i64 %add110
  %add.ptr114 = getelementptr inbounds i8, i8* %add.ptr113, i64 -1
  %78 = load i8, i8* %add.ptr114, align 1
  %conv115 = zext i8 %78 to i64
  %call116 = call i64 @make_natnum(i64 %conv115)
  store i64 %call116, i64* %val, align 8
  br label %if.end.117

if.end.117:                                       ; preds = %cond.end.108, %cond.end.94
  %79 = load i64, i64* %val, align 8
  store i64 %79, i64* %retval
  br label %return

return:                                           ; preds = %if.end.117, %if.then.42, %if.then.14
  %80 = load i64, i64* %retval
  ret i64 %80
}

; Function Attrs: nounwind uwtable
define i64 @Fuser_login_name(i64 %uid) #0 {
entry:
  %retval = alloca i64, align 8
  %uid.addr = alloca i64, align 8
  %pw = alloca %struct.passwd*, align 8
  %id = alloca i32, align 4
  store i64 %uid, i64* %uid.addr, align 8
  %0 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 321), align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %0, %call
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @init_editfns(i1 zeroext false)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %1 = load i64, i64* %uid.addr, align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp2 = icmp eq i64 %1, %call1
  br i1 %cmp2, label %if.then.3, label %if.end.4

if.then.3:                                        ; preds = %if.end
  %2 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 321), align 8
  store i64 %2, i64* %retval
  br label %return

if.end.4:                                         ; preds = %if.end
  %3 = load i64, i64* %uid.addr, align 8
  %call5 = call i64 @cons_to_unsigned(i64 %3, i64 4294967295)
  %conv = trunc i64 %call5 to i32
  store i32 %conv, i32* %id, align 4
  call void @block_input()
  %4 = load i32, i32* %id, align 4
  %call6 = call %struct.passwd* @getpwuid(i32 %4)
  store %struct.passwd* %call6, %struct.passwd** %pw, align 8
  call void @unblock_input()
  %5 = load %struct.passwd*, %struct.passwd** %pw, align 8
  %tobool = icmp ne %struct.passwd* %5, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.4
  %6 = load %struct.passwd*, %struct.passwd** %pw, align 8
  %pw_name = getelementptr inbounds %struct.passwd, %struct.passwd* %6, i32 0, i32 0
  %7 = load i8*, i8** %pw_name, align 8
  %call7 = call i64 @build_string(i8* %7)
  br label %cond.end

cond.false:                                       ; preds = %if.end.4
  %call8 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call7, %cond.true ], [ %call8, %cond.false ]
  store i64 %cond, i64* %retval
  br label %return

return:                                           ; preds = %cond.end, %if.then.3
  %8 = load i64, i64* %retval
  ret i64 %8
}

declare i64 @cons_to_unsigned(i64, i64) #1

declare void @block_input() #1

declare void @unblock_input() #1

; Function Attrs: nounwind uwtable
define i64 @Fuser_real_login_name() #0 {
entry:
  %0 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 321), align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %0, %call
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @init_editfns(i1 zeroext false)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %1 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 322), align 8
  ret i64 %1
}

; Function Attrs: nounwind uwtable
define i64 @Fuser_uid() #0 {
entry:
  %euid = alloca i32, align 4
  %call = call i32 @geteuid() #5
  store i32 %call, i32* %euid, align 4
  %0 = load i32, i32* %euid, align 4
  %cmp = icmp ule i32 0, %0
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %euid, align 4
  %conv = zext i32 %1 to i64
  %cmp1 = icmp sle i64 -2305843009213693952, %conv
  br i1 %cmp1, label %land.lhs.true, label %cond.true

land.lhs.true:                                    ; preds = %lor.lhs.false, %entry
  %2 = load i32, i32* %euid, align 4
  %conv3 = zext i32 %2 to i64
  %cmp4 = icmp sle i64 %conv3, 2305843009213693951
  br i1 %cmp4, label %cond.false, label %cond.true

cond.true:                                        ; preds = %land.lhs.true, %lor.lhs.false
  %3 = load i32, i32* %euid, align 4
  %conv6 = uitofp i32 %3 to double
  %call7 = call i64 @make_float(double %conv6)
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true
  %4 = load i32, i32* %euid, align 4
  %conv8 = zext i32 %4 to i64
  %shl = shl i64 %conv8, 2
  %add = add i64 %shl, 2
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call7, %cond.true ], [ %add, %cond.false ]
  ret i64 %cond
}

; Function Attrs: nounwind uwtable
define i64 @Fuser_real_uid() #0 {
entry:
  %uid = alloca i32, align 4
  %call = call i32 @getuid() #5
  store i32 %call, i32* %uid, align 4
  %0 = load i32, i32* %uid, align 4
  %cmp = icmp ule i32 0, %0
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %uid, align 4
  %conv = zext i32 %1 to i64
  %cmp1 = icmp sle i64 -2305843009213693952, %conv
  br i1 %cmp1, label %land.lhs.true, label %cond.true

land.lhs.true:                                    ; preds = %lor.lhs.false, %entry
  %2 = load i32, i32* %uid, align 4
  %conv3 = zext i32 %2 to i64
  %cmp4 = icmp sle i64 %conv3, 2305843009213693951
  br i1 %cmp4, label %cond.false, label %cond.true

cond.true:                                        ; preds = %land.lhs.true, %lor.lhs.false
  %3 = load i32, i32* %uid, align 4
  %conv6 = uitofp i32 %3 to double
  %call7 = call i64 @make_float(double %conv6)
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true
  %4 = load i32, i32* %uid, align 4
  %conv8 = zext i32 %4 to i64
  %shl = shl i64 %conv8, 2
  %add = add i64 %shl, 2
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call7, %cond.true ], [ %add, %cond.false ]
  ret i64 %cond
}

; Function Attrs: nounwind uwtable
define i64 @Fgroup_gid() #0 {
entry:
  %egid = alloca i32, align 4
  %call = call i32 @getegid() #5
  store i32 %call, i32* %egid, align 4
  %0 = load i32, i32* %egid, align 4
  %cmp = icmp ule i32 0, %0
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %egid, align 4
  %conv = zext i32 %1 to i64
  %cmp1 = icmp sle i64 -2305843009213693952, %conv
  br i1 %cmp1, label %land.lhs.true, label %cond.true

land.lhs.true:                                    ; preds = %lor.lhs.false, %entry
  %2 = load i32, i32* %egid, align 4
  %conv3 = zext i32 %2 to i64
  %cmp4 = icmp sle i64 %conv3, 2305843009213693951
  br i1 %cmp4, label %cond.false, label %cond.true

cond.true:                                        ; preds = %land.lhs.true, %lor.lhs.false
  %3 = load i32, i32* %egid, align 4
  %conv6 = uitofp i32 %3 to double
  %call7 = call i64 @make_float(double %conv6)
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true
  %4 = load i32, i32* %egid, align 4
  %conv8 = zext i32 %4 to i64
  %shl = shl i64 %conv8, 2
  %add = add i64 %shl, 2
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call7, %cond.true ], [ %add, %cond.false ]
  ret i64 %cond
}

; Function Attrs: nounwind
declare i32 @getegid() #2

; Function Attrs: nounwind uwtable
define i64 @Fgroup_real_gid() #0 {
entry:
  %gid = alloca i32, align 4
  %call = call i32 @getgid() #5
  store i32 %call, i32* %gid, align 4
  %0 = load i32, i32* %gid, align 4
  %cmp = icmp ule i32 0, %0
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %gid, align 4
  %conv = zext i32 %1 to i64
  %cmp1 = icmp sle i64 -2305843009213693952, %conv
  br i1 %cmp1, label %land.lhs.true, label %cond.true

land.lhs.true:                                    ; preds = %lor.lhs.false, %entry
  %2 = load i32, i32* %gid, align 4
  %conv3 = zext i32 %2 to i64
  %cmp4 = icmp sle i64 %conv3, 2305843009213693951
  br i1 %cmp4, label %cond.false, label %cond.true

cond.true:                                        ; preds = %land.lhs.true, %lor.lhs.false
  %3 = load i32, i32* %gid, align 4
  %conv6 = uitofp i32 %3 to double
  %call7 = call i64 @make_float(double %conv6)
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true
  %4 = load i32, i32* %gid, align 4
  %conv8 = zext i32 %4 to i64
  %shl = shl i64 %conv8, 2
  %add = add i64 %shl, 2
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call7, %cond.true ], [ %add, %cond.false ]
  ret i64 %cond
}

; Function Attrs: nounwind
declare i32 @getgid() #2

declare zeroext i1 @NUMBERP(i64) #1

declare zeroext i1 @STRINGP(i64) #1

declare %struct.passwd* @getpwnam(i8*) #1

declare i8* @SSDATA(i64) #1

; Function Attrs: nounwind readonly
declare i8* @strchr(i8*, i32) #3

declare i64 @make_string(i8*, i64) #1

; Function Attrs: nounwind readonly
declare i64 @strlen(i8*) #3

declare i64 @SBYTES(i64) #1

declare i8* @record_xmalloc(i64) #1

; Function Attrs: nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture, i8* nocapture readonly, i64, i32, i1) #5

declare i8* @lispstpcpy(i8*, i64) #1

declare i32 @upcase(i32) #1

; Function Attrs: nounwind
declare i8* @strcpy(i8*, i8*) #2

; Function Attrs: nounwind uwtable
define i64 @Fsystem_name() #0 {
entry:
  %0 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 285), align 8
  %1 = load i64, i64* @cached_system_name, align 8
  %cmp = icmp eq i64 %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @init_and_cache_system_name()
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 285), align 8
  ret i64 %2
}

; Function Attrs: nounwind uwtable
define i64 @Femacs_pid() #0 {
entry:
  %pid = alloca i32, align 4
  %call = call i32 @getpid() #5
  store i32 %call, i32* %pid, align 4
  %0 = load i32, i32* %pid, align 4
  %cmp = icmp sle i32 0, %0
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* %pid, align 4
  %conv = sext i32 %1 to i64
  %cmp1 = icmp sle i64 -2305843009213693952, %conv
  br i1 %cmp1, label %land.lhs.true, label %cond.true

land.lhs.true:                                    ; preds = %lor.lhs.false, %entry
  %2 = load i32, i32* %pid, align 4
  %conv3 = sext i32 %2 to i64
  %cmp4 = icmp sle i64 %conv3, 2305843009213693951
  br i1 %cmp4, label %cond.false, label %cond.true

cond.true:                                        ; preds = %land.lhs.true, %lor.lhs.false
  %3 = load i32, i32* %pid, align 4
  %conv6 = sitofp i32 %3 to double
  %call7 = call i64 @make_float(double %conv6)
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true
  %4 = load i32, i32* %pid, align 4
  %conv8 = sext i32 %4 to i64
  %shl = shl i64 %conv8, 2
  %add = add i64 %shl, 2
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call7, %cond.true ], [ %add, %cond.false ]
  ret i64 %cond
}

; Function Attrs: nounwind
declare i32 @getpid() #2

; Function Attrs: noreturn nounwind uwtable
define void @time_overflow() #6 {
entry:
  call void (i8*, ...) @error(i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.7, i32 0, i32 0)) #9
  unreachable

return:                                           ; No predecessors!
  ret void
}

; Function Attrs: nounwind uwtable
define i64 @Fcurrent_time() #0 {
entry:
  %agg.tmp = alloca %struct.timespec, align 8
  %call = call { i64, i64 } @current_timespec()
  %0 = bitcast %struct.timespec* %agg.tmp to { i64, i64 }*
  %1 = getelementptr { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  %2 = extractvalue { i64, i64 } %call, 0
  store i64 %2, i64* %1, align 8
  %3 = getelementptr { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  %4 = extractvalue { i64, i64 } %call, 1
  store i64 %4, i64* %3, align 8
  %5 = bitcast %struct.timespec* %agg.tmp to { i64, i64 }*
  %6 = getelementptr { i64, i64 }, { i64, i64 }* %5, i32 0, i32 0
  %7 = load i64, i64* %6, align 1
  %8 = getelementptr { i64, i64 }, { i64, i64 }* %5, i32 0, i32 1
  %9 = load i64, i64* %8, align 1
  %call1 = call i64 @make_lisp_time(i64 %7, i64 %9)
  ret i64 %call1
}

; Function Attrs: nounwind uwtable
define i64 @make_lisp_time(i64 %t.coerce0, i64 %t.coerce1) #0 {
entry:
  %t = alloca %struct.timespec, align 8
  %s = alloca i64, align 8
  %ns = alloca i32, align 4
  %0 = bitcast %struct.timespec* %t to { i64, i64 }*
  %1 = getelementptr { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %t.coerce0, i64* %1
  %2 = getelementptr { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %t.coerce1, i64* %2
  %tv_sec = getelementptr inbounds %struct.timespec, %struct.timespec* %t, i32 0, i32 0
  %3 = load i64, i64* %tv_sec, align 8
  store i64 %3, i64* %s, align 8
  %tv_nsec = getelementptr inbounds %struct.timespec, %struct.timespec* %t, i32 0, i32 1
  %4 = load i64, i64* %tv_nsec, align 8
  %conv = trunc i64 %4 to i32
  store i32 %conv, i32* %ns, align 4
  %5 = load i64, i64* %s, align 8
  %call = call i64 @hi_time(i64 %5)
  %6 = load i64, i64* %s, align 8
  %call1 = call i32 @lo_time(i64 %6)
  %conv2 = sext i32 %call1 to i64
  %7 = load i32, i32* %ns, align 4
  %div = sdiv i32 %7, 1000
  %conv3 = sext i32 %div to i64
  %8 = load i32, i32* %ns, align 4
  %rem = srem i32 %8, 1000
  %mul = mul nsw i32 %rem, 1000
  %conv4 = sext i32 %mul to i64
  %call5 = call i64 @list4i(i64 %call, i64 %conv2, i64 %conv3, i64 %conv4)
  ret i64 %call5
}

declare { i64, i64 } @current_timespec() #1

; Function Attrs: nounwind uwtable
define i64 @Ftime_add(i64 %a, i64 %b) #0 {
entry:
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  store i64 %a, i64* %a.addr, align 8
  store i64 %b, i64* %b.addr, align 8
  %0 = load i64, i64* %a.addr, align 8
  %1 = load i64, i64* %b.addr, align 8
  %call = call i64 @time_arith(i64 %0, i64 %1, void (%struct.lisp_time*, %struct.lisp_time*, %struct.lisp_time*)* @time_add)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define internal i64 @time_arith(i64 %a, i64 %b, void (%struct.lisp_time*, %struct.lisp_time*, %struct.lisp_time*)* %op) #0 {
entry:
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  %op.addr = alloca void (%struct.lisp_time*, %struct.lisp_time*, %struct.lisp_time*)*, align 8
  %alen = alloca i32, align 4
  %blen = alloca i32, align 4
  %ta = alloca %struct.lisp_time, align 8
  %tb = alloca %struct.lisp_time, align 8
  %t = alloca %struct.lisp_time, align 8
  %val = alloca i64, align 8
  store i64 %a, i64* %a.addr, align 8
  store i64 %b, i64* %b.addr, align 8
  store void (%struct.lisp_time*, %struct.lisp_time*, %struct.lisp_time*)* %op, void (%struct.lisp_time*, %struct.lisp_time*, %struct.lisp_time*)** %op.addr, align 8
  %0 = load i64, i64* %a.addr, align 8
  call void @lisp_time_struct(%struct.lisp_time* sret %ta, i64 %0, i32* %alen)
  %1 = load i64, i64* %b.addr, align 8
  call void @lisp_time_struct(%struct.lisp_time* sret %tb, i64 %1, i32* %blen)
  %2 = load void (%struct.lisp_time*, %struct.lisp_time*, %struct.lisp_time*)*, void (%struct.lisp_time*, %struct.lisp_time*, %struct.lisp_time*)** %op.addr, align 8
  call void %2(%struct.lisp_time* sret %t, %struct.lisp_time* byval align 8 %ta, %struct.lisp_time* byval align 8 %tb)
  %hi = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %t, i32 0, i32 0
  %3 = load i64, i64* %hi, align 8
  %cmp = icmp sle i64 -2305843009213693952, %3
  br i1 %cmp, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %entry
  %hi1 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %t, i32 0, i32 0
  %4 = load i64, i64* %hi1, align 8
  %cmp2 = icmp sle i64 %4, 2305843009213693951
  br i1 %cmp2, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true, %entry
  call void @time_overflow() #9
  unreachable

if.end:                                           ; preds = %land.lhs.true
  %call = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call, i64* %val, align 8
  %5 = load i32, i32* %alen, align 4
  %6 = load i32, i32* %blen, align 4
  %cmp3 = icmp sgt i32 %5, %6
  br i1 %cmp3, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %7 = load i32, i32* %alen, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %8 = load i32, i32* %blen, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %7, %cond.true ], [ %8, %cond.false ]
  switch i32 %cond, label %sw.default [
    i32 3, label %sw.bb
    i32 2, label %sw.bb.9
  ]

sw.default:                                       ; preds = %cond.end
  %ps = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %t, i32 0, i32 3
  %9 = load i32, i32* %ps, align 4
  %conv = sext i32 %9 to i64
  %shl = shl i64 %conv, 2
  %add = add i64 %shl, 2
  %10 = load i64, i64* %val, align 8
  %call4 = call i64 @Fcons(i64 %add, i64 %10)
  store i64 %call4, i64* %val, align 8
  br label %sw.bb

sw.bb:                                            ; preds = %cond.end, %sw.default
  %us = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %t, i32 0, i32 2
  %11 = load i32, i32* %us, align 4
  %conv5 = sext i32 %11 to i64
  %shl6 = shl i64 %conv5, 2
  %add7 = add i64 %shl6, 2
  %12 = load i64, i64* %val, align 8
  %call8 = call i64 @Fcons(i64 %add7, i64 %12)
  store i64 %call8, i64* %val, align 8
  br label %sw.bb.9

sw.bb.9:                                          ; preds = %cond.end, %sw.bb
  %lo = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %t, i32 0, i32 1
  %13 = load i32, i32* %lo, align 4
  %conv10 = sext i32 %13 to i64
  %shl11 = shl i64 %conv10, 2
  %add12 = add i64 %shl11, 2
  %14 = load i64, i64* %val, align 8
  %call13 = call i64 @Fcons(i64 %add12, i64 %14)
  store i64 %call13, i64* %val, align 8
  %hi14 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %t, i32 0, i32 0
  %15 = load i64, i64* %hi14, align 8
  %shl15 = shl i64 %15, 2
  %add16 = add i64 %shl15, 2
  %16 = load i64, i64* %val, align 8
  %call17 = call i64 @Fcons(i64 %add16, i64 %16)
  store i64 %call17, i64* %val, align 8
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb.9
  %17 = load i64, i64* %val, align 8
  ret i64 %17
}

; Function Attrs: nounwind uwtable
define internal void @time_add(%struct.lisp_time* noalias sret %agg.result, %struct.lisp_time* byval align 8 %ta, %struct.lisp_time* byval align 8 %tb) #0 {
entry:
  %hi = alloca i64, align 8
  %lo = alloca i32, align 4
  %us = alloca i32, align 4
  %ps = alloca i32, align 4
  %hi1 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %ta, i32 0, i32 0
  %0 = load i64, i64* %hi1, align 8
  %hi2 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %tb, i32 0, i32 0
  %1 = load i64, i64* %hi2, align 8
  %add = add nsw i64 %0, %1
  store i64 %add, i64* %hi, align 8
  %lo3 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %ta, i32 0, i32 1
  %2 = load i32, i32* %lo3, align 4
  %lo4 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %tb, i32 0, i32 1
  %3 = load i32, i32* %lo4, align 4
  %add5 = add nsw i32 %2, %3
  store i32 %add5, i32* %lo, align 4
  %us6 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %ta, i32 0, i32 2
  %4 = load i32, i32* %us6, align 4
  %us7 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %tb, i32 0, i32 2
  %5 = load i32, i32* %us7, align 4
  %add8 = add nsw i32 %4, %5
  store i32 %add8, i32* %us, align 4
  %ps9 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %ta, i32 0, i32 3
  %6 = load i32, i32* %ps9, align 4
  %ps10 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %tb, i32 0, i32 3
  %7 = load i32, i32* %ps10, align 4
  %add11 = add nsw i32 %6, %7
  store i32 %add11, i32* %ps, align 4
  %8 = load i32, i32* %ps, align 4
  %cmp = icmp sle i32 1000000, %8
  %conv = zext i1 %cmp to i32
  %9 = load i32, i32* %us, align 4
  %add12 = add nsw i32 %9, %conv
  store i32 %add12, i32* %us, align 4
  %10 = load i32, i32* %ps, align 4
  %cmp13 = icmp sle i32 1000000, %10
  %conv14 = zext i1 %cmp13 to i32
  %mul = mul nsw i32 %conv14, 1000000
  %11 = load i32, i32* %ps, align 4
  %sub = sub nsw i32 %11, %mul
  store i32 %sub, i32* %ps, align 4
  %12 = load i32, i32* %us, align 4
  %cmp15 = icmp sle i32 1000000, %12
  %conv16 = zext i1 %cmp15 to i32
  %13 = load i32, i32* %lo, align 4
  %add17 = add nsw i32 %13, %conv16
  store i32 %add17, i32* %lo, align 4
  %14 = load i32, i32* %us, align 4
  %cmp18 = icmp sle i32 1000000, %14
  %conv19 = zext i1 %cmp18 to i32
  %mul20 = mul nsw i32 %conv19, 1000000
  %15 = load i32, i32* %us, align 4
  %sub21 = sub nsw i32 %15, %mul20
  store i32 %sub21, i32* %us, align 4
  %16 = load i32, i32* %lo, align 4
  %cmp22 = icmp sle i32 65536, %16
  %conv23 = zext i1 %cmp22 to i32
  %conv24 = sext i32 %conv23 to i64
  %17 = load i64, i64* %hi, align 8
  %add25 = add nsw i64 %17, %conv24
  store i64 %add25, i64* %hi, align 8
  %18 = load i32, i32* %lo, align 4
  %cmp26 = icmp sle i32 65536, %18
  %conv27 = zext i1 %cmp26 to i32
  %shl = shl i32 %conv27, 16
  %19 = load i32, i32* %lo, align 4
  %sub28 = sub nsw i32 %19, %shl
  store i32 %sub28, i32* %lo, align 4
  %hi29 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %agg.result, i32 0, i32 0
  %20 = load i64, i64* %hi, align 8
  store i64 %20, i64* %hi29, align 8
  %lo30 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %agg.result, i32 0, i32 1
  %21 = load i32, i32* %lo, align 4
  store i32 %21, i32* %lo30, align 4
  %us31 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %agg.result, i32 0, i32 2
  %22 = load i32, i32* %us, align 4
  store i32 %22, i32* %us31, align 4
  %ps32 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %agg.result, i32 0, i32 3
  %23 = load i32, i32* %ps, align 4
  store i32 %23, i32* %ps32, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define i64 @Ftime_subtract(i64 %a, i64 %b) #0 {
entry:
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  store i64 %a, i64* %a.addr, align 8
  store i64 %b, i64* %b.addr, align 8
  %0 = load i64, i64* %a.addr, align 8
  %1 = load i64, i64* %b.addr, align 8
  %call = call i64 @time_arith(i64 %0, i64 %1, void (%struct.lisp_time*, %struct.lisp_time*, %struct.lisp_time*)* @time_subtract)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define internal void @time_subtract(%struct.lisp_time* noalias sret %agg.result, %struct.lisp_time* byval align 8 %ta, %struct.lisp_time* byval align 8 %tb) #0 {
entry:
  %hi = alloca i64, align 8
  %lo = alloca i32, align 4
  %us = alloca i32, align 4
  %ps = alloca i32, align 4
  %hi1 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %ta, i32 0, i32 0
  %0 = load i64, i64* %hi1, align 8
  %hi2 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %tb, i32 0, i32 0
  %1 = load i64, i64* %hi2, align 8
  %sub = sub nsw i64 %0, %1
  store i64 %sub, i64* %hi, align 8
  %lo3 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %ta, i32 0, i32 1
  %2 = load i32, i32* %lo3, align 4
  %lo4 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %tb, i32 0, i32 1
  %3 = load i32, i32* %lo4, align 4
  %sub5 = sub nsw i32 %2, %3
  store i32 %sub5, i32* %lo, align 4
  %us6 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %ta, i32 0, i32 2
  %4 = load i32, i32* %us6, align 4
  %us7 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %tb, i32 0, i32 2
  %5 = load i32, i32* %us7, align 4
  %sub8 = sub nsw i32 %4, %5
  store i32 %sub8, i32* %us, align 4
  %ps9 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %ta, i32 0, i32 3
  %6 = load i32, i32* %ps9, align 4
  %ps10 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %tb, i32 0, i32 3
  %7 = load i32, i32* %ps10, align 4
  %sub11 = sub nsw i32 %6, %7
  store i32 %sub11, i32* %ps, align 4
  %8 = load i32, i32* %ps, align 4
  %cmp = icmp slt i32 %8, 0
  %conv = zext i1 %cmp to i32
  %9 = load i32, i32* %us, align 4
  %sub12 = sub nsw i32 %9, %conv
  store i32 %sub12, i32* %us, align 4
  %10 = load i32, i32* %ps, align 4
  %cmp13 = icmp slt i32 %10, 0
  %conv14 = zext i1 %cmp13 to i32
  %mul = mul nsw i32 %conv14, 1000000
  %11 = load i32, i32* %ps, align 4
  %add = add nsw i32 %11, %mul
  store i32 %add, i32* %ps, align 4
  %12 = load i32, i32* %us, align 4
  %cmp15 = icmp slt i32 %12, 0
  %conv16 = zext i1 %cmp15 to i32
  %13 = load i32, i32* %lo, align 4
  %sub17 = sub nsw i32 %13, %conv16
  store i32 %sub17, i32* %lo, align 4
  %14 = load i32, i32* %us, align 4
  %cmp18 = icmp slt i32 %14, 0
  %conv19 = zext i1 %cmp18 to i32
  %mul20 = mul nsw i32 %conv19, 1000000
  %15 = load i32, i32* %us, align 4
  %add21 = add nsw i32 %15, %mul20
  store i32 %add21, i32* %us, align 4
  %16 = load i32, i32* %lo, align 4
  %cmp22 = icmp slt i32 %16, 0
  %conv23 = zext i1 %cmp22 to i32
  %conv24 = sext i32 %conv23 to i64
  %17 = load i64, i64* %hi, align 8
  %sub25 = sub nsw i64 %17, %conv24
  store i64 %sub25, i64* %hi, align 8
  %18 = load i32, i32* %lo, align 4
  %cmp26 = icmp slt i32 %18, 0
  %conv27 = zext i1 %cmp26 to i32
  %shl = shl i32 %conv27, 16
  %19 = load i32, i32* %lo, align 4
  %add28 = add nsw i32 %19, %shl
  store i32 %add28, i32* %lo, align 4
  %hi29 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %agg.result, i32 0, i32 0
  %20 = load i64, i64* %hi, align 8
  store i64 %20, i64* %hi29, align 8
  %lo30 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %agg.result, i32 0, i32 1
  %21 = load i32, i32* %lo, align 4
  store i32 %21, i32* %lo30, align 4
  %us31 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %agg.result, i32 0, i32 2
  %22 = load i32, i32* %us, align 4
  store i32 %22, i32* %us31, align 4
  %ps32 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %agg.result, i32 0, i32 3
  %23 = load i32, i32* %ps, align 4
  store i32 %23, i32* %ps32, align 4
  ret void
}

; Function Attrs: nounwind uwtable
define i64 @Ftime_less_p(i64 %t1, i64 %t2) #0 {
entry:
  %t1.addr = alloca i64, align 8
  %t2.addr = alloca i64, align 8
  %t1len = alloca i32, align 4
  %t2len = alloca i32, align 4
  %a = alloca %struct.lisp_time, align 8
  %b = alloca %struct.lisp_time, align 8
  store i64 %t1, i64* %t1.addr, align 8
  store i64 %t2, i64* %t2.addr, align 8
  %0 = load i64, i64* %t1.addr, align 8
  call void @lisp_time_struct(%struct.lisp_time* sret %a, i64 %0, i32* %t1len)
  %1 = load i64, i64* %t2.addr, align 8
  call void @lisp_time_struct(%struct.lisp_time* sret %b, i64 %1, i32* %t2len)
  %hi = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %a, i32 0, i32 0
  %2 = load i64, i64* %hi, align 8
  %hi1 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %b, i32 0, i32 0
  %3 = load i64, i64* %hi1, align 8
  %cmp = icmp ne i64 %2, %3
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %hi2 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %a, i32 0, i32 0
  %4 = load i64, i64* %hi2, align 8
  %hi3 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %b, i32 0, i32 0
  %5 = load i64, i64* %hi3, align 8
  %cmp4 = icmp slt i64 %4, %5
  br i1 %cmp4, label %cond.true.21, label %cond.false.22

cond.false:                                       ; preds = %entry
  %lo = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %a, i32 0, i32 1
  %6 = load i32, i32* %lo, align 4
  %lo5 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %b, i32 0, i32 1
  %7 = load i32, i32* %lo5, align 4
  %cmp6 = icmp ne i32 %6, %7
  br i1 %cmp6, label %cond.true.7, label %cond.false.11

cond.true.7:                                      ; preds = %cond.false
  %lo8 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %a, i32 0, i32 1
  %8 = load i32, i32* %lo8, align 4
  %lo9 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %b, i32 0, i32 1
  %9 = load i32, i32* %lo9, align 4
  %cmp10 = icmp slt i32 %8, %9
  br i1 %cmp10, label %cond.true.21, label %cond.false.22

cond.false.11:                                    ; preds = %cond.false
  %us = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %a, i32 0, i32 2
  %10 = load i32, i32* %us, align 4
  %us12 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %b, i32 0, i32 2
  %11 = load i32, i32* %us12, align 4
  %cmp13 = icmp ne i32 %10, %11
  br i1 %cmp13, label %cond.true.14, label %cond.false.18

cond.true.14:                                     ; preds = %cond.false.11
  %us15 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %a, i32 0, i32 2
  %12 = load i32, i32* %us15, align 4
  %us16 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %b, i32 0, i32 2
  %13 = load i32, i32* %us16, align 4
  %cmp17 = icmp slt i32 %12, %13
  br i1 %cmp17, label %cond.true.21, label %cond.false.22

cond.false.18:                                    ; preds = %cond.false.11
  %ps = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %a, i32 0, i32 3
  %14 = load i32, i32* %ps, align 4
  %ps19 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %b, i32 0, i32 3
  %15 = load i32, i32* %ps19, align 4
  %cmp20 = icmp slt i32 %14, %15
  br i1 %cmp20, label %cond.true.21, label %cond.false.22

cond.true.21:                                     ; preds = %cond.false.18, %cond.true.14, %cond.true.7, %cond.true
  %call = call i64 @builtin_lisp_symbol(i32 901)
  br label %cond.end

cond.false.22:                                    ; preds = %cond.false.18, %cond.true.14, %cond.true.7, %cond.true
  %call23 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end

cond.end:                                         ; preds = %cond.false.22, %cond.true.21
  %cond = phi i64 [ %call, %cond.true.21 ], [ %call23, %cond.false.22 ]
  ret i64 %cond
}

; Function Attrs: nounwind uwtable
define internal void @lisp_time_struct(%struct.lisp_time* noalias sret %agg.result, i64 %specified_time, i32* %plen) #0 {
entry:
  %specified_time.addr = alloca i64, align 8
  %plen.addr = alloca i32*, align 8
  %high = alloca i64, align 8
  %low = alloca i64, align 8
  %usec = alloca i64, align 8
  %psec = alloca i64, align 8
  %t = alloca %struct.lisp_time, align 8
  %len = alloca i32, align 4
  %val = alloca i32, align 4
  store i64 %specified_time, i64* %specified_time.addr, align 8
  store i32* %plen, i32** %plen.addr, align 8
  %0 = load i64, i64* %specified_time.addr, align 8
  %call = call i32 @disassemble_lisp_time(i64 %0, i64* %high, i64* %low, i64* %usec, i64* %psec)
  store i32 %call, i32* %len, align 4
  %1 = load i32, i32* %len, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call void @invalid_time() #9
  unreachable

if.end:                                           ; preds = %entry
  %2 = load i64, i64* %high, align 8
  %3 = load i64, i64* %low, align 8
  %4 = load i64, i64* %usec, align 8
  %5 = load i64, i64* %psec, align 8
  %call1 = call i32 @decode_time_components(i64 %2, i64 %3, i64 %4, i64 %5, %struct.lisp_time* %t, double* null)
  store i32 %call1, i32* %val, align 4
  %6 = load i32, i32* %val, align 4
  call void @check_time_validity(i32 %6)
  %7 = load i32, i32* %len, align 4
  %8 = load i32*, i32** %plen.addr, align 8
  store i32 %7, i32* %8, align 4
  %9 = bitcast %struct.lisp_time* %agg.result to i8*
  %10 = bitcast %struct.lisp_time* %t to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %9, i8* %10, i64 24, i32 8, i1 false)
  ret void
}

; Function Attrs: nounwind uwtable
define i64 @Fget_internal_run_time() #0 {
entry:
  %usage = alloca %struct.rusage, align 8
  %secs = alloca i64, align 8
  %usecs = alloca i32, align 4
  %agg.tmp = alloca %struct.timespec, align 8
  %call = call i32 @getrusage(i32 0, %struct.rusage* %usage) #5
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call1 = call i64 @builtin_lisp_symbol(i32 372)
  call void @xsignal0(i64 %call1) #9
  unreachable

if.end:                                           ; preds = %entry
  %ru_utime = getelementptr inbounds %struct.rusage, %struct.rusage* %usage, i32 0, i32 0
  %tv_sec = getelementptr inbounds %struct.timeval, %struct.timeval* %ru_utime, i32 0, i32 0
  %0 = load i64, i64* %tv_sec, align 8
  %ru_stime = getelementptr inbounds %struct.rusage, %struct.rusage* %usage, i32 0, i32 1
  %tv_sec2 = getelementptr inbounds %struct.timeval, %struct.timeval* %ru_stime, i32 0, i32 0
  %1 = load i64, i64* %tv_sec2, align 8
  %add = add nsw i64 %0, %1
  store i64 %add, i64* %secs, align 8
  %ru_utime3 = getelementptr inbounds %struct.rusage, %struct.rusage* %usage, i32 0, i32 0
  %tv_usec = getelementptr inbounds %struct.timeval, %struct.timeval* %ru_utime3, i32 0, i32 1
  %2 = load i64, i64* %tv_usec, align 8
  %ru_stime4 = getelementptr inbounds %struct.rusage, %struct.rusage* %usage, i32 0, i32 1
  %tv_usec5 = getelementptr inbounds %struct.timeval, %struct.timeval* %ru_stime4, i32 0, i32 1
  %3 = load i64, i64* %tv_usec5, align 8
  %add6 = add nsw i64 %2, %3
  %conv = trunc i64 %add6 to i32
  store i32 %conv, i32* %usecs, align 4
  %4 = load i32, i32* %usecs, align 4
  %cmp7 = icmp sge i32 %4, 1000000
  br i1 %cmp7, label %if.then.9, label %if.end.10

if.then.9:                                        ; preds = %if.end
  %5 = load i32, i32* %usecs, align 4
  %sub = sub nsw i32 %5, 1000000
  store i32 %sub, i32* %usecs, align 4
  %6 = load i64, i64* %secs, align 8
  %inc = add nsw i64 %6, 1
  store i64 %inc, i64* %secs, align 8
  br label %if.end.10

if.end.10:                                        ; preds = %if.then.9, %if.end
  %7 = load i64, i64* %secs, align 8
  %8 = load i32, i32* %usecs, align 4
  %mul = mul nsw i32 %8, 1000
  %conv11 = sext i32 %mul to i64
  %call12 = call { i64, i64 } @make_timespec(i64 %7, i64 %conv11)
  %9 = bitcast %struct.timespec* %agg.tmp to { i64, i64 }*
  %10 = getelementptr { i64, i64 }, { i64, i64 }* %9, i32 0, i32 0
  %11 = extractvalue { i64, i64 } %call12, 0
  store i64 %11, i64* %10, align 8
  %12 = getelementptr { i64, i64 }, { i64, i64 }* %9, i32 0, i32 1
  %13 = extractvalue { i64, i64 } %call12, 1
  store i64 %13, i64* %12, align 8
  %14 = bitcast %struct.timespec* %agg.tmp to { i64, i64 }*
  %15 = getelementptr { i64, i64 }, { i64, i64 }* %14, i32 0, i32 0
  %16 = load i64, i64* %15, align 1
  %17 = getelementptr { i64, i64 }, { i64, i64 }* %14, i32 0, i32 1
  %18 = load i64, i64* %17, align 1
  %call13 = call i64 @make_lisp_time(i64 %16, i64 %18)
  ret i64 %call13
}

; Function Attrs: nounwind
declare i32 @getrusage(i32, %struct.rusage*) #2

; Function Attrs: noreturn
declare void @xsignal0(i64) #4

declare { i64, i64 } @make_timespec(i64, i64) #1

declare i64 @list4i(i64, i64, i64, i64) #1

; Function Attrs: nounwind uwtable
define internal i64 @hi_time(i64 %t) #0 {
entry:
  %t.addr = alloca i64, align 8
  %hi = alloca i64, align 8
  store i64 %t, i64* %t.addr, align 8
  %0 = load i64, i64* %t.addr, align 8
  %shr = ashr i64 %0, 16
  store i64 %shr, i64* %hi, align 8
  %1 = load i64, i64* %hi, align 8
  ret i64 %1
}

; Function Attrs: nounwind uwtable
define internal i32 @lo_time(i64 %t) #0 {
entry:
  %t.addr = alloca i64, align 8
  store i64 %t, i64* %t.addr, align 8
  %0 = load i64, i64* %t.addr, align 8
  %and = and i64 %0, 65535
  %conv = trunc i64 %and to i32
  ret i32 %conv
}

; Function Attrs: nounwind uwtable
define i32 @decode_time_components(i64 %high, i64 %low, i64 %usec, i64 %psec, %struct.lisp_time* %result, double* %dresult) #0 {
entry:
  %retval = alloca i32, align 4
  %high.addr = alloca i64, align 8
  %low.addr = alloca i64, align 8
  %usec.addr = alloca i64, align 8
  %psec.addr = alloca i64, align 8
  %result.addr = alloca %struct.lisp_time*, align 8
  %dresult.addr = alloca double*, align 8
  %hi = alloca i64, align 8
  %lo = alloca i64, align 8
  %us = alloca i64, align 8
  %ps = alloca i64, align 8
  %t = alloca double, align 8
  %now = alloca %struct.timespec, align 8
  %dhi = alloca double, align 8
  store i64 %high, i64* %high.addr, align 8
  store i64 %low, i64* %low.addr, align 8
  store i64 %usec, i64* %usec.addr, align 8
  store i64 %psec, i64* %psec.addr, align 8
  store %struct.lisp_time* %result, %struct.lisp_time** %result.addr, align 8
  store double* %dresult, double** %dresult.addr, align 8
  %0 = load i64, i64* %high.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %and1 = and i32 %conv, -5
  %cmp = icmp eq i32 %and1, 2
  br i1 %cmp, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, i64* %usec.addr, align 8
  %and3 = and i64 %1, 7
  %conv4 = trunc i64 %and3 to i32
  %and5 = and i32 %conv4, -5
  %cmp6 = icmp eq i32 %and5, 2
  br i1 %cmp6, label %land.lhs.true.8, label %if.then

land.lhs.true.8:                                  ; preds = %land.lhs.true
  %2 = load i64, i64* %psec.addr, align 8
  %and9 = and i64 %2, 7
  %conv10 = trunc i64 %and9 to i32
  %and11 = and i32 %conv10, -5
  %cmp12 = icmp eq i32 %and11, 2
  br i1 %cmp12, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true.8, %land.lhs.true, %entry
  store i32 0, i32* %retval
  br label %return

if.end:                                           ; preds = %land.lhs.true.8
  %3 = load i64, i64* %low.addr, align 8
  %and14 = and i64 %3, 7
  %conv15 = trunc i64 %and14 to i32
  %and16 = and i32 %conv15, -5
  %cmp17 = icmp eq i32 %and16, 2
  br i1 %cmp17, label %if.end.59, label %if.then.19

if.then.19:                                       ; preds = %if.end
  %4 = load i64, i64* %low.addr, align 8
  %and20 = and i64 %4, 7
  %conv21 = trunc i64 %and20 to i32
  %cmp22 = icmp eq i32 %conv21, 7
  br i1 %cmp22, label %if.then.24, label %if.else

if.then.24:                                       ; preds = %if.then.19
  %5 = load i64, i64* %low.addr, align 8
  %call = call double @XFLOAT_DATA(i64 %5)
  store double %call, double* %t, align 8
  %6 = load %struct.lisp_time*, %struct.lisp_time** %result.addr, align 8
  %tobool = icmp ne %struct.lisp_time* %6, null
  br i1 %tobool, label %land.lhs.true.25, label %if.end.28

land.lhs.true.25:                                 ; preds = %if.then.24
  %7 = load double, double* %t, align 8
  %8 = load %struct.lisp_time*, %struct.lisp_time** %result.addr, align 8
  %call26 = call zeroext i1 @decode_float_time(double %7, %struct.lisp_time* %8)
  br i1 %call26, label %if.end.28, label %if.then.27

if.then.27:                                       ; preds = %land.lhs.true.25
  store i32 -1, i32* %retval
  br label %return

if.end.28:                                        ; preds = %land.lhs.true.25, %if.then.24
  %9 = load double*, double** %dresult.addr, align 8
  %tobool29 = icmp ne double* %9, null
  br i1 %tobool29, label %if.then.30, label %if.end.31

if.then.30:                                       ; preds = %if.end.28
  %10 = load double, double* %t, align 8
  %11 = load double*, double** %dresult.addr, align 8
  store double %10, double* %11, align 8
  br label %if.end.31

if.end.31:                                        ; preds = %if.then.30, %if.end.28
  store i32 1, i32* %retval
  br label %return

if.else:                                          ; preds = %if.then.19
  %12 = load i64, i64* %low.addr, align 8
  %call32 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp33 = icmp eq i64 %12, %call32
  br i1 %cmp33, label %if.then.35, label %if.else.58

if.then.35:                                       ; preds = %if.else
  %call36 = call { i64, i64 } @current_timespec()
  %13 = bitcast %struct.timespec* %now to { i64, i64 }*
  %14 = getelementptr { i64, i64 }, { i64, i64 }* %13, i32 0, i32 0
  %15 = extractvalue { i64, i64 } %call36, 0
  store i64 %15, i64* %14, align 8
  %16 = getelementptr { i64, i64 }, { i64, i64 }* %13, i32 0, i32 1
  %17 = extractvalue { i64, i64 } %call36, 1
  store i64 %17, i64* %16, align 8
  %18 = load %struct.lisp_time*, %struct.lisp_time** %result.addr, align 8
  %tobool37 = icmp ne %struct.lisp_time* %18, null
  br i1 %tobool37, label %if.then.38, label %if.end.49

if.then.38:                                       ; preds = %if.then.35
  %tv_sec = getelementptr inbounds %struct.timespec, %struct.timespec* %now, i32 0, i32 0
  %19 = load i64, i64* %tv_sec, align 8
  %call39 = call i64 @hi_time(i64 %19)
  %20 = load %struct.lisp_time*, %struct.lisp_time** %result.addr, align 8
  %hi40 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %20, i32 0, i32 0
  store i64 %call39, i64* %hi40, align 8
  %tv_sec41 = getelementptr inbounds %struct.timespec, %struct.timespec* %now, i32 0, i32 0
  %21 = load i64, i64* %tv_sec41, align 8
  %call42 = call i32 @lo_time(i64 %21)
  %22 = load %struct.lisp_time*, %struct.lisp_time** %result.addr, align 8
  %lo43 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %22, i32 0, i32 1
  store i32 %call42, i32* %lo43, align 4
  %tv_nsec = getelementptr inbounds %struct.timespec, %struct.timespec* %now, i32 0, i32 1
  %23 = load i64, i64* %tv_nsec, align 8
  %div = sdiv i64 %23, 1000
  %conv44 = trunc i64 %div to i32
  %24 = load %struct.lisp_time*, %struct.lisp_time** %result.addr, align 8
  %us45 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %24, i32 0, i32 2
  store i32 %conv44, i32* %us45, align 4
  %tv_nsec46 = getelementptr inbounds %struct.timespec, %struct.timespec* %now, i32 0, i32 1
  %25 = load i64, i64* %tv_nsec46, align 8
  %rem = srem i64 %25, 1000
  %mul = mul nsw i64 %rem, 1000
  %conv47 = trunc i64 %mul to i32
  %26 = load %struct.lisp_time*, %struct.lisp_time** %result.addr, align 8
  %ps48 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %26, i32 0, i32 3
  store i32 %conv47, i32* %ps48, align 4
  br label %if.end.49

if.end.49:                                        ; preds = %if.then.38, %if.then.35
  %27 = load double*, double** %dresult.addr, align 8
  %tobool50 = icmp ne double* %27, null
  br i1 %tobool50, label %if.then.51, label %if.end.57

if.then.51:                                       ; preds = %if.end.49
  %tv_sec52 = getelementptr inbounds %struct.timespec, %struct.timespec* %now, i32 0, i32 0
  %28 = load i64, i64* %tv_sec52, align 8
  %conv53 = sitofp i64 %28 to double
  %tv_nsec54 = getelementptr inbounds %struct.timespec, %struct.timespec* %now, i32 0, i32 1
  %29 = load i64, i64* %tv_nsec54, align 8
  %conv55 = sitofp i64 %29 to double
  %div56 = fdiv double %conv55, 1.000000e+09
  %add = fadd double %conv53, %div56
  %30 = load double*, double** %dresult.addr, align 8
  store double %add, double* %30, align 8
  br label %if.end.57

if.end.57:                                        ; preds = %if.then.51, %if.end.49
  store i32 1, i32* %retval
  br label %return

if.else.58:                                       ; preds = %if.else
  store i32 0, i32* %retval
  br label %return

if.end.59:                                        ; preds = %if.end
  %31 = load i64, i64* %high.addr, align 8
  %shr = ashr i64 %31, 2
  store i64 %shr, i64* %hi, align 8
  %32 = load i64, i64* %low.addr, align 8
  %shr60 = ashr i64 %32, 2
  store i64 %shr60, i64* %lo, align 8
  %33 = load i64, i64* %usec.addr, align 8
  %shr61 = ashr i64 %33, 2
  store i64 %shr61, i64* %us, align 8
  %34 = load i64, i64* %psec.addr, align 8
  %shr62 = ashr i64 %34, 2
  store i64 %shr62, i64* %ps, align 8
  %35 = load i64, i64* %ps, align 8
  %div63 = sdiv i64 %35, 1000000
  %36 = load i64, i64* %ps, align 8
  %rem64 = srem i64 %36, 1000000
  %cmp65 = icmp slt i64 %rem64, 0
  %conv66 = zext i1 %cmp65 to i32
  %conv67 = sext i32 %conv66 to i64
  %sub = sub nsw i64 %div63, %conv67
  %37 = load i64, i64* %us, align 8
  %add68 = add nsw i64 %37, %sub
  store i64 %add68, i64* %us, align 8
  %38 = load i64, i64* %us, align 8
  %div69 = sdiv i64 %38, 1000000
  %39 = load i64, i64* %us, align 8
  %rem70 = srem i64 %39, 1000000
  %cmp71 = icmp slt i64 %rem70, 0
  %conv72 = zext i1 %cmp71 to i32
  %conv73 = sext i32 %conv72 to i64
  %sub74 = sub nsw i64 %div69, %conv73
  %40 = load i64, i64* %lo, align 8
  %add75 = add nsw i64 %40, %sub74
  store i64 %add75, i64* %lo, align 8
  %41 = load i64, i64* %lo, align 8
  %shr76 = ashr i64 %41, 16
  %42 = load i64, i64* %hi, align 8
  %add77 = add nsw i64 %42, %shr76
  store i64 %add77, i64* %hi, align 8
  %43 = load i64, i64* %ps, align 8
  %rem78 = srem i64 %43, 1000000
  %44 = load i64, i64* %ps, align 8
  %rem79 = srem i64 %44, 1000000
  %cmp80 = icmp slt i64 %rem79, 0
  %conv81 = zext i1 %cmp80 to i32
  %mul82 = mul nsw i32 1000000, %conv81
  %conv83 = sext i32 %mul82 to i64
  %add84 = add nsw i64 %rem78, %conv83
  store i64 %add84, i64* %ps, align 8
  %45 = load i64, i64* %us, align 8
  %rem85 = srem i64 %45, 1000000
  %46 = load i64, i64* %us, align 8
  %rem86 = srem i64 %46, 1000000
  %cmp87 = icmp slt i64 %rem86, 0
  %conv88 = zext i1 %cmp87 to i32
  %mul89 = mul nsw i32 1000000, %conv88
  %conv90 = sext i32 %mul89 to i64
  %add91 = add nsw i64 %rem85, %conv90
  store i64 %add91, i64* %us, align 8
  %47 = load i64, i64* %lo, align 8
  %and92 = and i64 %47, 65535
  store i64 %and92, i64* %lo, align 8
  %48 = load %struct.lisp_time*, %struct.lisp_time** %result.addr, align 8
  %tobool93 = icmp ne %struct.lisp_time* %48, null
  br i1 %tobool93, label %if.then.94, label %if.end.109

if.then.94:                                       ; preds = %if.end.59
  %49 = load i64, i64* %hi, align 8
  %cmp95 = icmp sle i64 -2305843009213693952, %49
  br i1 %cmp95, label %land.lhs.true.97, label %if.then.100

land.lhs.true.97:                                 ; preds = %if.then.94
  %50 = load i64, i64* %hi, align 8
  %cmp98 = icmp sle i64 %50, 2305843009213693951
  br i1 %cmp98, label %if.end.101, label %if.then.100

if.then.100:                                      ; preds = %land.lhs.true.97, %if.then.94
  store i32 -1, i32* %retval
  br label %return

if.end.101:                                       ; preds = %land.lhs.true.97
  %51 = load i64, i64* %hi, align 8
  %52 = load %struct.lisp_time*, %struct.lisp_time** %result.addr, align 8
  %hi102 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %52, i32 0, i32 0
  store i64 %51, i64* %hi102, align 8
  %53 = load i64, i64* %lo, align 8
  %conv103 = trunc i64 %53 to i32
  %54 = load %struct.lisp_time*, %struct.lisp_time** %result.addr, align 8
  %lo104 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %54, i32 0, i32 1
  store i32 %conv103, i32* %lo104, align 4
  %55 = load i64, i64* %us, align 8
  %conv105 = trunc i64 %55 to i32
  %56 = load %struct.lisp_time*, %struct.lisp_time** %result.addr, align 8
  %us106 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %56, i32 0, i32 2
  store i32 %conv105, i32* %us106, align 4
  %57 = load i64, i64* %ps, align 8
  %conv107 = trunc i64 %57 to i32
  %58 = load %struct.lisp_time*, %struct.lisp_time** %result.addr, align 8
  %ps108 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %58, i32 0, i32 3
  store i32 %conv107, i32* %ps108, align 4
  br label %if.end.109

if.end.109:                                       ; preds = %if.end.101, %if.end.59
  %59 = load double*, double** %dresult.addr, align 8
  %tobool110 = icmp ne double* %59, null
  br i1 %tobool110, label %if.then.111, label %if.end.122

if.then.111:                                      ; preds = %if.end.109
  %60 = load i64, i64* %hi, align 8
  %conv112 = sitofp i64 %60 to double
  store double %conv112, double* %dhi, align 8
  %61 = load i64, i64* %us, align 8
  %conv113 = sitofp i64 %61 to double
  %mul114 = fmul double %conv113, 1.000000e+06
  %62 = load i64, i64* %ps, align 8
  %conv115 = sitofp i64 %62 to double
  %add116 = fadd double %mul114, %conv115
  %div117 = fdiv double %add116, 1.000000e+12
  %63 = load i64, i64* %lo, align 8
  %conv118 = sitofp i64 %63 to double
  %add119 = fadd double %div117, %conv118
  %64 = load double, double* %dhi, align 8
  %mul120 = fmul double %64, 6.553600e+04
  %add121 = fadd double %add119, %mul120
  %65 = load double*, double** %dresult.addr, align 8
  store double %add121, double* %65, align 8
  br label %if.end.122

if.end.122:                                       ; preds = %if.then.111, %if.end.109
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %if.end.122, %if.then.100, %if.else.58, %if.end.57, %if.end.31, %if.then.27, %if.then
  %66 = load i32, i32* %retval
  ret i32 %66
}

declare double @XFLOAT_DATA(i64) #1

; Function Attrs: nounwind uwtable
define internal zeroext i1 @decode_float_time(double %t, %struct.lisp_time* %result) #0 {
entry:
  %retval = alloca i1, align 1
  %t.addr = alloca double, align 8
  %result.addr = alloca %struct.lisp_time*, align 8
  %lo_multiplier = alloca double, align 8
  %emacs_time_min = alloca double, align 8
  %small_t = alloca double, align 8
  %hi = alloca i64, align 8
  %t_sans_hi = alloca double, align 8
  %lo = alloca i32, align 4
  %fracps = alloca x86_fp80, align 16
  %ifracps = alloca i64, align 8
  %us = alloca i32, align 4
  %ps = alloca i32, align 4
  store double %t, double* %t.addr, align 8
  store %struct.lisp_time* %result, %struct.lisp_time** %result.addr, align 8
  store double 6.553600e+04, double* %lo_multiplier, align 8
  %0 = load double, double* %lo_multiplier, align 8
  %mul = fmul double 0xC3C0000000000000, %0
  store double %mul, double* %emacs_time_min, align 8
  %1 = load double, double* %emacs_time_min, align 8
  %2 = load double, double* %t.addr, align 8
  %cmp = fcmp ole double %1, %2
  br i1 %cmp, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %entry
  %3 = load double, double* %t.addr, align 8
  %4 = load double, double* %emacs_time_min, align 8
  %sub = fsub double -0.000000e+00, %4
  %cmp1 = fcmp olt double %3, %sub
  br i1 %cmp1, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true, %entry
  store i1 false, i1* %retval
  br label %return

if.end:                                           ; preds = %land.lhs.true
  %5 = load double, double* %t.addr, align 8
  %6 = load double, double* %lo_multiplier, align 8
  %div = fdiv double %5, %6
  store double %div, double* %small_t, align 8
  %7 = load double, double* %small_t, align 8
  %conv = fptosi double %7 to i64
  store i64 %conv, i64* %hi, align 8
  %8 = load double, double* %t.addr, align 8
  %9 = load i64, i64* %hi, align 8
  %conv2 = sitofp i64 %9 to double
  %10 = load double, double* %lo_multiplier, align 8
  %mul3 = fmul double %conv2, %10
  %sub4 = fsub double %8, %mul3
  store double %sub4, double* %t_sans_hi, align 8
  %11 = load double, double* %t_sans_hi, align 8
  %conv5 = fptosi double %11 to i32
  store i32 %conv5, i32* %lo, align 4
  %12 = load double, double* %t_sans_hi, align 8
  %13 = load i32, i32* %lo, align 4
  %conv6 = sitofp i32 %13 to double
  %sub7 = fsub double %12, %conv6
  %conv8 = fpext double %sub7 to x86_fp80
  %mul9 = fmul x86_fp80 %conv8, 0xK4026E8D4A51000000000
  store x86_fp80 %mul9, x86_fp80* %fracps, align 16
  %14 = load x86_fp80, x86_fp80* %fracps, align 16
  %conv10 = fptosi x86_fp80 %14 to i64
  store i64 %conv10, i64* %ifracps, align 8
  %15 = load i64, i64* %ifracps, align 8
  %div11 = sdiv i64 %15, 1000000
  %conv12 = trunc i64 %div11 to i32
  store i32 %conv12, i32* %us, align 4
  %16 = load i64, i64* %ifracps, align 8
  %rem = srem i64 %16, 1000000
  %conv13 = trunc i64 %rem to i32
  store i32 %conv13, i32* %ps, align 4
  %17 = load i32, i32* %ps, align 4
  %cmp14 = icmp slt i32 %17, 0
  %conv15 = zext i1 %cmp14 to i32
  %18 = load i32, i32* %us, align 4
  %sub16 = sub nsw i32 %18, %conv15
  store i32 %sub16, i32* %us, align 4
  %19 = load i32, i32* %ps, align 4
  %cmp17 = icmp slt i32 %19, 0
  %conv18 = zext i1 %cmp17 to i32
  %mul19 = mul nsw i32 %conv18, 1000000
  %20 = load i32, i32* %ps, align 4
  %add = add nsw i32 %20, %mul19
  store i32 %add, i32* %ps, align 4
  %21 = load i32, i32* %us, align 4
  %cmp20 = icmp slt i32 %21, 0
  %conv21 = zext i1 %cmp20 to i32
  %22 = load i32, i32* %lo, align 4
  %sub22 = sub nsw i32 %22, %conv21
  store i32 %sub22, i32* %lo, align 4
  %23 = load i32, i32* %us, align 4
  %cmp23 = icmp slt i32 %23, 0
  %conv24 = zext i1 %cmp23 to i32
  %mul25 = mul nsw i32 %conv24, 1000000
  %24 = load i32, i32* %us, align 4
  %add26 = add nsw i32 %24, %mul25
  store i32 %add26, i32* %us, align 4
  %25 = load i32, i32* %lo, align 4
  %cmp27 = icmp slt i32 %25, 0
  %conv28 = zext i1 %cmp27 to i32
  %conv29 = sext i32 %conv28 to i64
  %26 = load i64, i64* %hi, align 8
  %sub30 = sub nsw i64 %26, %conv29
  store i64 %sub30, i64* %hi, align 8
  %27 = load i32, i32* %lo, align 4
  %cmp31 = icmp slt i32 %27, 0
  %conv32 = zext i1 %cmp31 to i32
  %shl = shl i32 %conv32, 16
  %28 = load i32, i32* %lo, align 4
  %add33 = add nsw i32 %28, %shl
  store i32 %add33, i32* %lo, align 4
  %29 = load i64, i64* %hi, align 8
  %30 = load %struct.lisp_time*, %struct.lisp_time** %result.addr, align 8
  %hi34 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %30, i32 0, i32 0
  store i64 %29, i64* %hi34, align 8
  %31 = load i32, i32* %lo, align 4
  %32 = load %struct.lisp_time*, %struct.lisp_time** %result.addr, align 8
  %lo35 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %32, i32 0, i32 1
  store i32 %31, i32* %lo35, align 4
  %33 = load i32, i32* %us, align 4
  %34 = load %struct.lisp_time*, %struct.lisp_time** %result.addr, align 8
  %us36 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %34, i32 0, i32 2
  store i32 %33, i32* %us36, align 4
  %35 = load i32, i32* %ps, align 4
  %36 = load %struct.lisp_time*, %struct.lisp_time** %result.addr, align 8
  %ps37 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %36, i32 0, i32 3
  store i32 %35, i32* %ps37, align 4
  store i1 true, i1* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %37 = load i1, i1* %retval
  ret i1 %37
}

; Function Attrs: nounwind uwtable
define { i64, i64 } @lisp_to_timespec(%struct.lisp_time* byval align 8 %t) #0 {
entry:
  %retval = alloca %struct.timespec, align 8
  %s = alloca i64, align 8
  %ns = alloca i32, align 4
  br i1 false, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %hi = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %t, i32 0, i32 0
  %0 = load i64, i64* %hi, align 8
  %cmp = icmp sle i64 -140737488355328, %0
  br i1 %cmp, label %land.lhs.true, label %if.then

cond.false:                                       ; preds = %entry
  %hi1 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %t, i32 0, i32 0
  %1 = load i64, i64* %hi1, align 8
  %cmp2 = icmp sle i64 0, %1
  br i1 %cmp2, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %cond.false, %cond.true
  %hi3 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %t, i32 0, i32 0
  %2 = load i64, i64* %hi3, align 8
  %cmp4 = icmp sle i64 %2, 140737488355327
  br i1 %cmp4, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true, %cond.false, %cond.true
  %call = call { i64, i64 } @invalid_timespec()
  %3 = bitcast %struct.timespec* %retval to { i64, i64 }*
  %4 = getelementptr { i64, i64 }, { i64, i64 }* %3, i32 0, i32 0
  %5 = extractvalue { i64, i64 } %call, 0
  store i64 %5, i64* %4, align 8
  %6 = getelementptr { i64, i64 }, { i64, i64 }* %3, i32 0, i32 1
  %7 = extractvalue { i64, i64 } %call, 1
  store i64 %7, i64* %6, align 8
  br label %return

if.end:                                           ; preds = %land.lhs.true
  %hi5 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %t, i32 0, i32 0
  %8 = load i64, i64* %hi5, align 8
  %shl = shl i64 %8, 16
  %lo = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %t, i32 0, i32 1
  %9 = load i32, i32* %lo, align 4
  %conv = sext i32 %9 to i64
  %add = add nsw i64 %shl, %conv
  store i64 %add, i64* %s, align 8
  %us = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %t, i32 0, i32 2
  %10 = load i32, i32* %us, align 4
  %mul = mul nsw i32 %10, 1000
  %ps = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %t, i32 0, i32 3
  %11 = load i32, i32* %ps, align 4
  %div = sdiv i32 %11, 1000
  %add6 = add nsw i32 %mul, %div
  store i32 %add6, i32* %ns, align 4
  %12 = load i64, i64* %s, align 8
  %13 = load i32, i32* %ns, align 4
  %conv7 = sext i32 %13 to i64
  %call8 = call { i64, i64 } @make_timespec(i64 %12, i64 %conv7)
  %14 = bitcast %struct.timespec* %retval to { i64, i64 }*
  %15 = getelementptr { i64, i64 }, { i64, i64 }* %14, i32 0, i32 0
  %16 = extractvalue { i64, i64 } %call8, 0
  store i64 %16, i64* %15, align 8
  %17 = getelementptr { i64, i64 }, { i64, i64 }* %14, i32 0, i32 1
  %18 = extractvalue { i64, i64 } %call8, 1
  store i64 %18, i64* %17, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  %19 = bitcast %struct.timespec* %retval to { i64, i64 }*
  %20 = load { i64, i64 }, { i64, i64 }* %19, align 8
  ret { i64, i64 } %20
}

declare { i64, i64 } @invalid_timespec() #1

; Function Attrs: nounwind uwtable
define { i64, i64 } @lisp_time_argument(i64 %specified_time) #0 {
entry:
  %retval = alloca %struct.timespec, align 8
  %specified_time.addr = alloca i64, align 8
  %len = alloca i32, align 4
  %lt = alloca %struct.lisp_time, align 8
  %t = alloca %struct.timespec, align 8
  store i64 %specified_time, i64* %specified_time.addr, align 8
  %0 = load i64, i64* %specified_time.addr, align 8
  call void @lisp_time_struct(%struct.lisp_time* sret %lt, i64 %0, i32* %len)
  %call = call { i64, i64 } @lisp_to_timespec(%struct.lisp_time* byval align 8 %lt)
  %1 = bitcast %struct.timespec* %t to { i64, i64 }*
  %2 = getelementptr { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = extractvalue { i64, i64 } %call, 0
  store i64 %3, i64* %2, align 8
  %4 = getelementptr { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = extractvalue { i64, i64 } %call, 1
  store i64 %5, i64* %4, align 8
  %6 = bitcast %struct.timespec* %t to { i64, i64 }*
  %7 = getelementptr { i64, i64 }, { i64, i64 }* %6, i32 0, i32 0
  %8 = load i64, i64* %7, align 1
  %9 = getelementptr { i64, i64 }, { i64, i64 }* %6, i32 0, i32 1
  %10 = load i64, i64* %9, align 1
  %call1 = call zeroext i1 @timespec_valid_p(i64 %8, i64 %10)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call void @time_overflow() #9
  unreachable

if.end:                                           ; preds = %entry
  %11 = bitcast %struct.timespec* %retval to i8*
  %12 = bitcast %struct.timespec* %t to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %11, i8* %12, i64 16, i32 8, i1 false)
  %13 = bitcast %struct.timespec* %retval to { i64, i64 }*
  %14 = load { i64, i64 }, { i64, i64 }* %13, align 8
  ret { i64, i64 } %14
}

declare zeroext i1 @timespec_valid_p(i64, i64) #1

; Function Attrs: nounwind uwtable
define i64 @Ffloat_time(i64 %specified_time) #0 {
entry:
  %specified_time.addr = alloca i64, align 8
  %t = alloca double, align 8
  %high = alloca i64, align 8
  %low = alloca i64, align 8
  %usec = alloca i64, align 8
  %psec = alloca i64, align 8
  store i64 %specified_time, i64* %specified_time.addr, align 8
  %0 = load i64, i64* %specified_time.addr, align 8
  %call = call i32 @disassemble_lisp_time(i64 %0, i64* %high, i64* %low, i64* %usec, i64* %psec)
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, i64* %high, align 8
  %2 = load i64, i64* %low, align 8
  %3 = load i64, i64* %usec, align 8
  %4 = load i64, i64* %psec, align 8
  %call1 = call i32 @decode_time_components(i64 %1, i64 %2, i64 %3, i64 %4, %struct.lisp_time* null, double* %t)
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true, %entry
  call void @invalid_time() #9
  unreachable

if.end:                                           ; preds = %land.lhs.true
  %5 = load double, double* %t, align 8
  %call3 = call i64 @make_float(double %5)
  ret i64 %call3
}

; Function Attrs: nounwind uwtable
define internal i32 @disassemble_lisp_time(i64 %specified_time, i64* %phigh, i64* %plow, i64* %pusec, i64* %ppsec) #0 {
entry:
  %retval = alloca i32, align 4
  %specified_time.addr = alloca i64, align 8
  %phigh.addr = alloca i64*, align 8
  %plow.addr = alloca i64*, align 8
  %pusec.addr = alloca i64*, align 8
  %ppsec.addr = alloca i64*, align 8
  %high = alloca i64, align 8
  %low = alloca i64, align 8
  %usec = alloca i64, align 8
  %psec = alloca i64, align 8
  %len = alloca i32, align 4
  %low_tail = alloca i64, align 8
  store i64 %specified_time, i64* %specified_time.addr, align 8
  store i64* %phigh, i64** %phigh.addr, align 8
  store i64* %plow, i64** %plow.addr, align 8
  store i64* %pusec, i64** %pusec.addr, align 8
  store i64* %ppsec, i64** %ppsec.addr, align 8
  store i64 2, i64* %high, align 8
  %0 = load i64, i64* %specified_time.addr, align 8
  store i64 %0, i64* %low, align 8
  store i64 2, i64* %usec, align 8
  store i64 2, i64* %psec, align 8
  store i32 4, i32* %len, align 4
  %1 = load i64, i64* %specified_time.addr, align 8
  %and = and i64 %1, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %if.then, label %if.else.46

if.then:                                          ; preds = %entry
  %2 = load i64, i64* %specified_time.addr, align 8
  %sub = sub nsw i64 %2, 3
  %3 = inttoptr i64 %sub to i8*
  %4 = bitcast i8* %3 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %4, i32 0, i32 0
  %5 = load i64, i64* %car, align 8
  store i64 %5, i64* %high, align 8
  %6 = load i64, i64* %specified_time.addr, align 8
  %sub2 = sub nsw i64 %6, 3
  %7 = inttoptr i64 %sub2 to i8*
  %8 = bitcast i8* %7 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %8, i32 0, i32 1
  %cdr = bitcast %union.anon.20* %u to i64*
  %9 = load i64, i64* %cdr, align 8
  store i64 %9, i64* %low, align 8
  %10 = load i64, i64* %low, align 8
  %and3 = and i64 %10, 7
  %conv4 = trunc i64 %and3 to i32
  %cmp5 = icmp eq i32 %conv4, 3
  br i1 %cmp5, label %if.then.7, label %if.else.37

if.then.7:                                        ; preds = %if.then
  %11 = load i64, i64* %low, align 8
  %sub8 = sub nsw i64 %11, 3
  %12 = inttoptr i64 %sub8 to i8*
  %13 = bitcast i8* %12 to %struct.Lisp_Cons*
  %u9 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %13, i32 0, i32 1
  %cdr10 = bitcast %union.anon.20* %u9 to i64*
  %14 = load i64, i64* %cdr10, align 8
  store i64 %14, i64* %low_tail, align 8
  %15 = load i64, i64* %low, align 8
  %sub11 = sub nsw i64 %15, 3
  %16 = inttoptr i64 %sub11 to i8*
  %17 = bitcast i8* %16 to %struct.Lisp_Cons*
  %car12 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %17, i32 0, i32 0
  %18 = load i64, i64* %car12, align 8
  store i64 %18, i64* %low, align 8
  %19 = load i64, i64* %low_tail, align 8
  %and13 = and i64 %19, 7
  %conv14 = trunc i64 %and13 to i32
  %cmp15 = icmp eq i32 %conv14, 3
  br i1 %cmp15, label %if.then.17, label %if.else.30

if.then.17:                                       ; preds = %if.then.7
  %20 = load i64, i64* %low_tail, align 8
  %sub18 = sub nsw i64 %20, 3
  %21 = inttoptr i64 %sub18 to i8*
  %22 = bitcast i8* %21 to %struct.Lisp_Cons*
  %car19 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %22, i32 0, i32 0
  %23 = load i64, i64* %car19, align 8
  store i64 %23, i64* %usec, align 8
  %24 = load i64, i64* %low_tail, align 8
  %sub20 = sub nsw i64 %24, 3
  %25 = inttoptr i64 %sub20 to i8*
  %26 = bitcast i8* %25 to %struct.Lisp_Cons*
  %u21 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %26, i32 0, i32 1
  %cdr22 = bitcast %union.anon.20* %u21 to i64*
  %27 = load i64, i64* %cdr22, align 8
  store i64 %27, i64* %low_tail, align 8
  %28 = load i64, i64* %low_tail, align 8
  %and23 = and i64 %28, 7
  %conv24 = trunc i64 %and23 to i32
  %cmp25 = icmp eq i32 %conv24, 3
  br i1 %cmp25, label %if.then.27, label %if.else

if.then.27:                                       ; preds = %if.then.17
  %29 = load i64, i64* %low_tail, align 8
  %sub28 = sub nsw i64 %29, 3
  %30 = inttoptr i64 %sub28 to i8*
  %31 = bitcast i8* %30 to %struct.Lisp_Cons*
  %car29 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %31, i32 0, i32 0
  %32 = load i64, i64* %car29, align 8
  store i64 %32, i64* %psec, align 8
  br label %if.end

if.else:                                          ; preds = %if.then.17
  store i32 3, i32* %len, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then.27
  br label %if.end.36

if.else.30:                                       ; preds = %if.then.7
  %33 = load i64, i64* %low_tail, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp31 = icmp eq i64 %33, %call
  br i1 %cmp31, label %if.else.34, label %if.then.33

if.then.33:                                       ; preds = %if.else.30
  %34 = load i64, i64* %low_tail, align 8
  store i64 %34, i64* %usec, align 8
  store i32 3, i32* %len, align 4
  br label %if.end.35

if.else.34:                                       ; preds = %if.else.30
  store i32 2, i32* %len, align 4
  br label %if.end.35

if.end.35:                                        ; preds = %if.else.34, %if.then.33
  br label %if.end.36

if.end.36:                                        ; preds = %if.end.35, %if.end
  br label %if.end.38

if.else.37:                                       ; preds = %if.then
  store i32 2, i32* %len, align 4
  br label %if.end.38

if.end.38:                                        ; preds = %if.else.37, %if.end.36
  %35 = load i64, i64* %low, align 8
  %and39 = and i64 %35, 7
  %conv40 = trunc i64 %and39 to i32
  %and41 = and i32 %conv40, -5
  %cmp42 = icmp eq i32 %and41, 2
  br i1 %cmp42, label %if.end.45, label %if.then.44

if.then.44:                                       ; preds = %if.end.38
  store i32 0, i32* %retval
  br label %return

if.end.45:                                        ; preds = %if.end.38
  br label %if.end.54

if.else.46:                                       ; preds = %entry
  %36 = load i64, i64* %specified_time.addr, align 8
  %and47 = and i64 %36, 7
  %conv48 = trunc i64 %and47 to i32
  %and49 = and i32 %conv48, -5
  %cmp50 = icmp eq i32 %and49, 2
  br i1 %cmp50, label %if.then.52, label %if.end.53

if.then.52:                                       ; preds = %if.else.46
  store i32 2, i32* %len, align 4
  br label %if.end.53

if.end.53:                                        ; preds = %if.then.52, %if.else.46
  br label %if.end.54

if.end.54:                                        ; preds = %if.end.53, %if.end.45
  %37 = load i64, i64* %high, align 8
  %38 = load i64*, i64** %phigh.addr, align 8
  store i64 %37, i64* %38, align 8
  %39 = load i64, i64* %low, align 8
  %40 = load i64*, i64** %plow.addr, align 8
  store i64 %39, i64* %40, align 8
  %41 = load i64, i64* %usec, align 8
  %42 = load i64*, i64** %pusec.addr, align 8
  store i64 %41, i64* %42, align 8
  %43 = load i64, i64* %psec, align 8
  %44 = load i64*, i64** %ppsec.addr, align 8
  store i64 %43, i64* %44, align 8
  %45 = load i32, i32* %len, align 4
  store i32 %45, i32* %retval
  br label %return

return:                                           ; preds = %if.end.54, %if.then.44
  %46 = load i32, i32* %retval
  ret i32 %46
}

; Function Attrs: noreturn nounwind uwtable
define internal void @invalid_time() #6 {
entry:
  call void (i8*, ...) @error(i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.36, i32 0, i32 0)) #9
  unreachable

return:                                           ; No predecessors!
  ret void
}

; Function Attrs: nounwind uwtable
define i64 @Fformat_time_string(i64 %format_string, i64 %timeval, i64 %zone) #0 {
entry:
  %format_string.addr = alloca i64, align 8
  %timeval.addr = alloca i64, align 8
  %zone.addr = alloca i64, align 8
  %t = alloca %struct.timespec, align 8
  %tm = alloca %struct.tm, align 8
  store i64 %format_string, i64* %format_string.addr, align 8
  store i64 %timeval, i64* %timeval.addr, align 8
  store i64 %zone, i64* %zone.addr, align 8
  %0 = load i64, i64* %timeval.addr, align 8
  %call = call { i64, i64 } @lisp_time_argument(i64 %0)
  %1 = bitcast %struct.timespec* %t to { i64, i64 }*
  %2 = getelementptr { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = extractvalue { i64, i64 } %call, 0
  store i64 %3, i64* %2, align 8
  %4 = getelementptr { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = extractvalue { i64, i64 } %call, 1
  store i64 %5, i64* %4, align 8
  %6 = load i64, i64* %format_string.addr, align 8
  call void @CHECK_STRING(i64 %6)
  %7 = load i64, i64* %format_string.addr, align 8
  %8 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 168), align 8
  %call1 = call i64 @code_convert_string_norecord(i64 %7, i64 %8, i1 zeroext true)
  store i64 %call1, i64* %format_string.addr, align 8
  %9 = load i64, i64* %format_string.addr, align 8
  %call2 = call i8* @SSDATA(i64 %9)
  %10 = load i64, i64* %format_string.addr, align 8
  %call3 = call i64 @SBYTES(i64 %10)
  %11 = load i64, i64* %zone.addr, align 8
  %12 = bitcast %struct.timespec* %t to { i64, i64 }*
  %13 = getelementptr { i64, i64 }, { i64, i64 }* %12, i32 0, i32 0
  %14 = load i64, i64* %13, align 1
  %15 = getelementptr { i64, i64 }, { i64, i64 }* %12, i32 0, i32 1
  %16 = load i64, i64* %15, align 1
  %call4 = call i64 @format_time_string(i8* %call2, i64 %call3, i64 %14, i64 %16, i64 %11, %struct.tm* %tm)
  ret i64 %call4
}

declare i64 @code_convert_string_norecord(i64, i64, i1 zeroext) #1

; Function Attrs: nounwind uwtable
define internal i64 @format_time_string(i8* %format, i64 %formatlen, i64 %t.coerce0, i64 %t.coerce1, i64 %zone, %struct.tm* %tmp) #0 {
entry:
  %t = alloca %struct.timespec, align 8
  %format.addr = alloca i8*, align 8
  %formatlen.addr = alloca i64, align 8
  %zone.addr = alloca i64, align 8
  %tmp.addr = alloca %struct.tm*, align 8
  %buffer = alloca [4000 x i8], align 16
  %buf = alloca i8*, align 8
  %size = alloca i64, align 8
  %len = alloca i64, align 8
  %bufstring = alloca i64, align 8
  %ns = alloca i32, align 4
  %sa_avail = alloca i64, align 8
  %sa_count = alloca i64, align 8
  %sa_must_free = alloca i8, align 1
  %tz = alloca %struct.tm_zone*, align 8
  %0 = bitcast %struct.timespec* %t to { i64, i64 }*
  %1 = getelementptr { i64, i64 }, { i64, i64 }* %0, i32 0, i32 0
  store i64 %t.coerce0, i64* %1
  %2 = getelementptr { i64, i64 }, { i64, i64 }* %0, i32 0, i32 1
  store i64 %t.coerce1, i64* %2
  store i8* %format, i8** %format.addr, align 8
  store i64 %formatlen, i64* %formatlen.addr, align 8
  store i64 %zone, i64* %zone.addr, align 8
  store %struct.tm* %tmp, %struct.tm** %tmp.addr, align 8
  %arraydecay = getelementptr inbounds [4000 x i8], [4000 x i8]* %buffer, i32 0, i32 0
  store i8* %arraydecay, i8** %buf, align 8
  store i64 4000, i64* %size, align 8
  %tv_nsec = getelementptr inbounds %struct.timespec, %struct.timespec* %t, i32 0, i32 1
  %3 = load i64, i64* %tv_nsec, align 8
  %conv = trunc i64 %3 to i32
  store i32 %conv, i32* %ns, align 4
  store i64 16384, i64* %sa_avail, align 8
  %call = call i64 @SPECPDL_INDEX()
  store i64 %call, i64* %sa_count, align 8
  store i8 0, i8* %sa_must_free, align 1
  %4 = load i64, i64* %zone.addr, align 8
  %call11 = call %struct.tm_zone* @tzlookup(i64 %4, i1 zeroext false)
  store %struct.tm_zone* %call11, %struct.tm_zone** %tz, align 8
  %5 = load %struct.tm_zone*, %struct.tm_zone** %tz, align 8
  %tv_sec = getelementptr inbounds %struct.timespec, %struct.timespec* %t, i32 0, i32 0
  %6 = load %struct.tm*, %struct.tm** %tmp.addr, align 8
  %call12 = call %struct.tm* @emacs_localtime_rz(%struct.tm_zone* %5, i64* %tv_sec, %struct.tm* %6)
  store %struct.tm* %call12, %struct.tm** %tmp.addr, align 8
  %7 = load %struct.tm*, %struct.tm** %tmp.addr, align 8
  %tobool = icmp ne %struct.tm* %7, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %8 = load %struct.tm_zone*, %struct.tm_zone** %tz, align 8
  call void @xtzfree(%struct.tm_zone* %8)
  call void @time_overflow() #9
  unreachable

if.end:                                           ; preds = %entry
  call void @synchronize_system_time_locale()
  br label %while.body

while.body:                                       ; preds = %if.end, %cond.end
  %9 = load i8*, i8** %buf, align 8
  %arrayidx = getelementptr inbounds i8, i8* %9, i64 0
  store i8 1, i8* %arrayidx, align 1
  %10 = load i8*, i8** %buf, align 8
  %11 = load i64, i64* %size, align 8
  %12 = load i8*, i8** %format.addr, align 8
  %13 = load i64, i64* %formatlen.addr, align 8
  %14 = load %struct.tm*, %struct.tm** %tmp.addr, align 8
  %15 = load %struct.tm_zone*, %struct.tm_zone** %tz, align 8
  %16 = load i32, i32* %ns, align 4
  %call13 = call i64 @emacs_nmemftime(i8* %10, i64 %11, i8* %12, i64 %13, %struct.tm* %14, %struct.tm_zone* %15, i32 %16)
  store i64 %call13, i64* %len, align 8
  %17 = load i64, i64* %len, align 8
  %cmp = icmp ult i64 0, %17
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %while.body
  %18 = load i64, i64* %len, align 8
  %19 = load i64, i64* %size, align 8
  %cmp15 = icmp ult i64 %18, %19
  br i1 %cmp15, label %if.then.24, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %while.body
  %20 = load i64, i64* %len, align 8
  %cmp17 = icmp eq i64 %20, 0
  br i1 %cmp17, label %land.lhs.true.19, label %if.end.25

land.lhs.true.19:                                 ; preds = %lor.lhs.false
  %21 = load i8*, i8** %buf, align 8
  %arrayidx20 = getelementptr inbounds i8, i8* %21, i64 0
  %22 = load i8, i8* %arrayidx20, align 1
  %conv21 = sext i8 %22 to i32
  %cmp22 = icmp eq i32 %conv21, 0
  br i1 %cmp22, label %if.then.24, label %if.end.25

if.then.24:                                       ; preds = %land.lhs.true.19, %land.lhs.true
  br label %while.end

if.end.25:                                        ; preds = %land.lhs.true.19, %lor.lhs.false
  %23 = load i8*, i8** %format.addr, align 8
  %24 = load i64, i64* %formatlen.addr, align 8
  %25 = load %struct.tm*, %struct.tm** %tmp.addr, align 8
  %26 = load %struct.tm_zone*, %struct.tm_zone** %tz, align 8
  %27 = load i32, i32* %ns, align 4
  %call26 = call i64 @emacs_nmemftime(i8* null, i64 -1, i8* %23, i64 %24, %struct.tm* %25, %struct.tm_zone* %26, i32 %27)
  store i64 %call26, i64* %len, align 8
  %28 = load i64, i64* %len, align 8
  %cmp27 = icmp ule i64 2305843009213693951, %28
  br i1 %cmp27, label %if.then.29, label %if.end.30

if.then.29:                                       ; preds = %if.end.25
  %29 = load %struct.tm_zone*, %struct.tm_zone** %tz, align 8
  call void @xtzfree(%struct.tm_zone* %29)
  call void @string_overflow() #9
  unreachable

if.end.30:                                        ; preds = %if.end.25
  %30 = load i64, i64* %len, align 8
  %add = add i64 %30, 1
  store i64 %add, i64* %size, align 8
  %31 = load i64, i64* %size, align 8
  %32 = load i64, i64* %sa_avail, align 8
  %cmp31 = icmp sle i64 %31, %32
  br i1 %cmp31, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.30
  %33 = load i64, i64* %size, align 8
  %34 = load i64, i64* %sa_avail, align 8
  %sub = sub nsw i64 %34, %33
  store i64 %sub, i64* %sa_avail, align 8
  %35 = load i64, i64* %size, align 8
  %36 = alloca i8, i64 %35
  br label %cond.end

cond.false:                                       ; preds = %if.end.30
  store i8 1, i8* %sa_must_free, align 1
  %37 = load i64, i64* %size, align 8
  %call33 = call i8* @record_xmalloc(i64 %37)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %36, %cond.true ], [ %call33, %cond.false ]
  store i8* %cond, i8** %buf, align 8
  br label %while.body

while.end:                                        ; preds = %if.then.24
  %38 = load %struct.tm_zone*, %struct.tm_zone** %tz, align 8
  call void @xtzfree(%struct.tm_zone* %38)
  %39 = load i8*, i8** %buf, align 8
  %40 = load i64, i64* %len, align 8
  %call34 = call i64 @make_unibyte_string(i8* %39, i64 %40)
  store i64 %call34, i64* %bufstring, align 8
  br label %do.body

do.body:                                          ; preds = %while.end
  %41 = load i8, i8* %sa_must_free, align 1
  %tobool35 = trunc i8 %41 to i1
  br i1 %tobool35, label %if.then.36, label %if.end.39

if.then.36:                                       ; preds = %do.body
  store i8 0, i8* %sa_must_free, align 1
  %42 = load i64, i64* %sa_count, align 8
  %call37 = call i64 @builtin_lisp_symbol(i32 0)
  %call38 = call i64 @unbind_to(i64 %42, i64 %call37)
  br label %if.end.39

if.end.39:                                        ; preds = %if.then.36, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end.39
  %43 = load i64, i64* %bufstring, align 8
  %44 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 168), align 8
  %call40 = call i64 @code_convert_string_norecord(i64 %43, i64 %44, i1 zeroext false)
  ret i64 %call40
}

; Function Attrs: nounwind uwtable
define i64 @Fdecode_time(i64 %specified_time, i64 %zone) #0 {
entry:
  %specified_time.addr = alloca i64, align 8
  %zone.addr = alloca i64, align 8
  %time_spec = alloca i64, align 8
  %local_tm = alloca %struct.tm, align 8
  %gmt_tm = alloca %struct.tm, align 8
  %tz = alloca %struct.tm_zone*, align 8
  %tm = alloca %struct.tm*, align 8
  %tm_year_base = alloca i64, align 8
  %.compoundliteral = alloca [9 x i64], align 8
  store i64 %specified_time, i64* %specified_time.addr, align 8
  store i64 %zone, i64* %zone.addr, align 8
  %0 = load i64, i64* %specified_time.addr, align 8
  %call = call i64 @lisp_seconds_argument(i64 %0)
  store i64 %call, i64* %time_spec, align 8
  %1 = load i64, i64* %zone.addr, align 8
  %call1 = call %struct.tm_zone* @tzlookup(i64 %1, i1 zeroext false)
  store %struct.tm_zone* %call1, %struct.tm_zone** %tz, align 8
  %2 = load %struct.tm_zone*, %struct.tm_zone** %tz, align 8
  %call2 = call %struct.tm* @emacs_localtime_rz(%struct.tm_zone* %2, i64* %time_spec, %struct.tm* %local_tm)
  store %struct.tm* %call2, %struct.tm** %tm, align 8
  %3 = load %struct.tm_zone*, %struct.tm_zone** %tz, align 8
  call void @xtzfree(%struct.tm_zone* %3)
  %4 = load %struct.tm*, %struct.tm** %tm, align 8
  %tobool = icmp ne %struct.tm* %4, null
  br i1 %tobool, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %entry
  %tm_year = getelementptr inbounds %struct.tm, %struct.tm* %local_tm, i32 0, i32 5
  %5 = load i32, i32* %tm_year, align 4
  %conv = sext i32 %5 to i64
  %cmp = icmp sle i64 -2305843009213695852, %conv
  br i1 %cmp, label %land.lhs.true.4, label %if.then

land.lhs.true.4:                                  ; preds = %land.lhs.true
  %tm_year5 = getelementptr inbounds %struct.tm, %struct.tm* %local_tm, i32 0, i32 5
  %6 = load i32, i32* %tm_year5, align 4
  %conv6 = sext i32 %6 to i64
  %cmp7 = icmp sle i64 %conv6, 2305843009213692051
  br i1 %cmp7, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true.4, %land.lhs.true, %entry
  call void @time_overflow() #9
  unreachable

if.end:                                           ; preds = %land.lhs.true.4
  store i64 1900, i64* %tm_year_base, align 8
  %arrayinit.begin = getelementptr inbounds [9 x i64], [9 x i64]* %.compoundliteral, i64 0, i64 0
  %tm_sec = getelementptr inbounds %struct.tm, %struct.tm* %local_tm, i32 0, i32 0
  %7 = load i32, i32* %tm_sec, align 4
  %conv9 = sext i32 %7 to i64
  %shl = shl i64 %conv9, 2
  %add = add i64 %shl, 2
  store i64 %add, i64* %arrayinit.begin
  %arrayinit.element = getelementptr inbounds i64, i64* %arrayinit.begin, i64 1
  %tm_min = getelementptr inbounds %struct.tm, %struct.tm* %local_tm, i32 0, i32 1
  %8 = load i32, i32* %tm_min, align 4
  %conv10 = sext i32 %8 to i64
  %shl11 = shl i64 %conv10, 2
  %add12 = add i64 %shl11, 2
  store i64 %add12, i64* %arrayinit.element
  %arrayinit.element13 = getelementptr inbounds i64, i64* %arrayinit.element, i64 1
  %tm_hour = getelementptr inbounds %struct.tm, %struct.tm* %local_tm, i32 0, i32 2
  %9 = load i32, i32* %tm_hour, align 4
  %conv14 = sext i32 %9 to i64
  %shl15 = shl i64 %conv14, 2
  %add16 = add i64 %shl15, 2
  store i64 %add16, i64* %arrayinit.element13
  %arrayinit.element17 = getelementptr inbounds i64, i64* %arrayinit.element13, i64 1
  %tm_mday = getelementptr inbounds %struct.tm, %struct.tm* %local_tm, i32 0, i32 3
  %10 = load i32, i32* %tm_mday, align 4
  %conv18 = sext i32 %10 to i64
  %shl19 = shl i64 %conv18, 2
  %add20 = add i64 %shl19, 2
  store i64 %add20, i64* %arrayinit.element17
  %arrayinit.element21 = getelementptr inbounds i64, i64* %arrayinit.element17, i64 1
  %tm_mon = getelementptr inbounds %struct.tm, %struct.tm* %local_tm, i32 0, i32 4
  %11 = load i32, i32* %tm_mon, align 4
  %add22 = add nsw i32 %11, 1
  %conv23 = sext i32 %add22 to i64
  %shl24 = shl i64 %conv23, 2
  %add25 = add i64 %shl24, 2
  store i64 %add25, i64* %arrayinit.element21
  %arrayinit.element26 = getelementptr inbounds i64, i64* %arrayinit.element21, i64 1
  %tm_year27 = getelementptr inbounds %struct.tm, %struct.tm* %local_tm, i32 0, i32 5
  %12 = load i32, i32* %tm_year27, align 4
  %conv28 = sext i32 %12 to i64
  %13 = load i64, i64* %tm_year_base, align 8
  %add29 = add nsw i64 %conv28, %13
  %shl30 = shl i64 %add29, 2
  %add31 = add i64 %shl30, 2
  store i64 %add31, i64* %arrayinit.element26
  %arrayinit.element32 = getelementptr inbounds i64, i64* %arrayinit.element26, i64 1
  %tm_wday = getelementptr inbounds %struct.tm, %struct.tm* %local_tm, i32 0, i32 6
  %14 = load i32, i32* %tm_wday, align 4
  %conv33 = sext i32 %14 to i64
  %shl34 = shl i64 %conv33, 2
  %add35 = add i64 %shl34, 2
  store i64 %add35, i64* %arrayinit.element32
  %arrayinit.element36 = getelementptr inbounds i64, i64* %arrayinit.element32, i64 1
  %tm_isdst = getelementptr inbounds %struct.tm, %struct.tm* %local_tm, i32 0, i32 8
  %15 = load i32, i32* %tm_isdst, align 4
  %tobool37 = icmp ne i32 %15, 0
  br i1 %tobool37, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %call38 = call i64 @builtin_lisp_symbol(i32 901)
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %call39 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call38, %cond.true ], [ %call39, %cond.false ]
  store i64 %cond, i64* %arrayinit.element36
  %arrayinit.element40 = getelementptr inbounds i64, i64* %arrayinit.element36, i64 1
  %call41 = call i64 @tm_gmtoff(%struct.tm* %local_tm)
  %shl42 = shl i64 %call41, 2
  %add43 = add i64 %shl42, 2
  store i64 %add43, i64* %arrayinit.element40
  %arraydecay = getelementptr inbounds [9 x i64], [9 x i64]* %.compoundliteral, i32 0, i32 0
  %call44 = call i64 @Flist(i64 9, i64* %arraydecay)
  ret i64 %call44
}

; Function Attrs: nounwind uwtable
define internal i64 @lisp_seconds_argument(i64 %specified_time) #0 {
entry:
  %specified_time.addr = alloca i64, align 8
  %high = alloca i64, align 8
  %low = alloca i64, align 8
  %usec = alloca i64, align 8
  %psec = alloca i64, align 8
  %t = alloca %struct.lisp_time, align 8
  %val = alloca i32, align 4
  store i64 %specified_time, i64* %specified_time.addr, align 8
  %0 = load i64, i64* %specified_time.addr, align 8
  %call = call i32 @disassemble_lisp_time(i64 %0, i64* %high, i64* %low, i64* %usec, i64* %psec)
  store i32 %call, i32* %val, align 4
  %1 = load i32, i32* %val, align 4
  %cmp = icmp ne i32 %1, 0
  br i1 %cmp, label %if.then, label %if.end.10

if.then:                                          ; preds = %entry
  %2 = load i64, i64* %high, align 8
  %3 = load i64, i64* %low, align 8
  %call1 = call i32 @decode_time_components(i64 %2, i64 %3, i64 2, i64 2, %struct.lisp_time* %t, double* null)
  store i32 %call1, i32* %val, align 4
  %4 = load i32, i32* %val, align 4
  %cmp2 = icmp slt i32 0, %4
  br i1 %cmp2, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then
  br i1 false, label %cond.false, label %cond.true

cond.true:                                        ; preds = %land.lhs.true
  %hi = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %t, i32 0, i32 0
  %5 = load i64, i64* %hi, align 8
  %cmp3 = icmp sle i64 -140737488355328, %5
  br i1 %cmp3, label %land.lhs.true.6, label %if.then.9

cond.false:                                       ; preds = %land.lhs.true
  %hi4 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %t, i32 0, i32 0
  %6 = load i64, i64* %hi4, align 8
  %cmp5 = icmp sle i64 0, %6
  br i1 %cmp5, label %land.lhs.true.6, label %if.then.9

land.lhs.true.6:                                  ; preds = %cond.false, %cond.true
  %hi7 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %t, i32 0, i32 0
  %7 = load i64, i64* %hi7, align 8
  %cmp8 = icmp sle i64 %7, 140737488355327
  br i1 %cmp8, label %if.end, label %if.then.9

if.then.9:                                        ; preds = %land.lhs.true.6, %cond.false, %cond.true
  store i32 -1, i32* %val, align 4
  br label %if.end

if.end:                                           ; preds = %if.then.9, %land.lhs.true.6, %if.then
  br label %if.end.10

if.end.10:                                        ; preds = %if.end, %entry
  %8 = load i32, i32* %val, align 4
  call void @check_time_validity(i32 %8)
  %hi11 = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %t, i32 0, i32 0
  %9 = load i64, i64* %hi11, align 8
  %shl = shl i64 %9, 16
  %lo = getelementptr inbounds %struct.lisp_time, %struct.lisp_time* %t, i32 0, i32 1
  %10 = load i32, i32* %lo, align 4
  %conv = sext i32 %10 to i64
  %add = add nsw i64 %shl, %conv
  ret i64 %add
}

; Function Attrs: nounwind uwtable
define internal %struct.tm* @emacs_localtime_rz(%struct.tm_zone* %tz, i64* %t, %struct.tm* %tm) #0 {
entry:
  %tz.addr = alloca %struct.tm_zone*, align 8
  %t.addr = alloca i64*, align 8
  %tm.addr = alloca %struct.tm*, align 8
  store %struct.tm_zone* %tz, %struct.tm_zone** %tz.addr, align 8
  store i64* %t, i64** %t.addr, align 8
  store %struct.tm* %tm, %struct.tm** %tm.addr, align 8
  %0 = load %struct.tm_zone*, %struct.tm_zone** %tz.addr, align 8
  %1 = load i64*, i64** %t.addr, align 8
  %2 = load %struct.tm*, %struct.tm** %tm.addr, align 8
  %call = call %struct.tm* @localtime_rz(%struct.tm_zone* %0, i64* %1, %struct.tm* %2)
  store %struct.tm* %call, %struct.tm** %tm.addr, align 8
  %3 = load %struct.tm*, %struct.tm** %tm.addr, align 8
  %tobool = icmp ne %struct.tm* %3, null
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %call1 = call i32* @__errno_location() #10
  %4 = load i32, i32* %call1, align 4
  %cmp = icmp eq i32 %4, 12
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  call void @memory_full(i64 -1) #9
  unreachable

if.end:                                           ; preds = %land.lhs.true, %entry
  %5 = load %struct.tm*, %struct.tm** %tm.addr, align 8
  ret %struct.tm* %5
}

; Function Attrs: nounwind uwtable
define internal void @xtzfree(%struct.tm_zone* %tz) #0 {
entry:
  %tz.addr = alloca %struct.tm_zone*, align 8
  store %struct.tm_zone* %tz, %struct.tm_zone** %tz.addr, align 8
  %0 = load %struct.tm_zone*, %struct.tm_zone** %tz.addr, align 8
  %1 = load %struct.tm_zone*, %struct.tm_zone** @local_tz, align 8
  %cmp = icmp ne %struct.tm_zone* %0, %1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.tm_zone*, %struct.tm_zone** %tz.addr, align 8
  call void @tzfree(%struct.tm_zone* %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

declare i64 @Flist(i64, i64*) #1

; Function Attrs: nounwind uwtable
define internal i64 @tm_gmtoff(%struct.tm* %a) #0 {
entry:
  %a.addr = alloca %struct.tm*, align 8
  store %struct.tm* %a, %struct.tm** %a.addr, align 8
  %0 = load %struct.tm*, %struct.tm** %a.addr, align 8
  %tm_gmtoff = getelementptr inbounds %struct.tm, %struct.tm* %0, i32 0, i32 9
  %1 = load i64, i64* %tm_gmtoff, align 8
  ret i64 %1
}

; Function Attrs: nounwind uwtable
define i64 @Fencode_time(i64 %nargs, i64* %args) #0 {
entry:
  %nargs.addr = alloca i64, align 8
  %args.addr = alloca i64*, align 8
  %value = alloca i64, align 8
  %tm = alloca %struct.tm, align 8
  %zone = alloca i64, align 8
  %tz = alloca %struct.tm_zone*, align 8
  store i64 %nargs, i64* %nargs.addr, align 8
  store i64* %args, i64** %args.addr, align 8
  %0 = load i64, i64* %nargs.addr, align 8
  %cmp = icmp sgt i64 %0, 6
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load i64, i64* %nargs.addr, align 8
  %sub = sub nsw i64 %1, 1
  %2 = load i64*, i64** %args.addr, align 8
  %arrayidx = getelementptr inbounds i64, i64* %2, i64 %sub
  %3 = load i64, i64* %arrayidx, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %3, %cond.true ], [ %call, %cond.false ]
  store i64 %cond, i64* %zone, align 8
  %4 = load i64*, i64** %args.addr, align 8
  %arrayidx1 = getelementptr inbounds i64, i64* %4, i64 0
  %5 = load i64, i64* %arrayidx1, align 8
  %call2 = call i32 @check_tm_member(i64 %5, i32 0)
  %tm_sec = getelementptr inbounds %struct.tm, %struct.tm* %tm, i32 0, i32 0
  store i32 %call2, i32* %tm_sec, align 4
  %6 = load i64*, i64** %args.addr, align 8
  %arrayidx3 = getelementptr inbounds i64, i64* %6, i64 1
  %7 = load i64, i64* %arrayidx3, align 8
  %call4 = call i32 @check_tm_member(i64 %7, i32 0)
  %tm_min = getelementptr inbounds %struct.tm, %struct.tm* %tm, i32 0, i32 1
  store i32 %call4, i32* %tm_min, align 4
  %8 = load i64*, i64** %args.addr, align 8
  %arrayidx5 = getelementptr inbounds i64, i64* %8, i64 2
  %9 = load i64, i64* %arrayidx5, align 8
  %call6 = call i32 @check_tm_member(i64 %9, i32 0)
  %tm_hour = getelementptr inbounds %struct.tm, %struct.tm* %tm, i32 0, i32 2
  store i32 %call6, i32* %tm_hour, align 4
  %10 = load i64*, i64** %args.addr, align 8
  %arrayidx7 = getelementptr inbounds i64, i64* %10, i64 3
  %11 = load i64, i64* %arrayidx7, align 8
  %call8 = call i32 @check_tm_member(i64 %11, i32 0)
  %tm_mday = getelementptr inbounds %struct.tm, %struct.tm* %tm, i32 0, i32 3
  store i32 %call8, i32* %tm_mday, align 4
  %12 = load i64*, i64** %args.addr, align 8
  %arrayidx9 = getelementptr inbounds i64, i64* %12, i64 4
  %13 = load i64, i64* %arrayidx9, align 8
  %call10 = call i32 @check_tm_member(i64 %13, i32 1)
  %tm_mon = getelementptr inbounds %struct.tm, %struct.tm* %tm, i32 0, i32 4
  store i32 %call10, i32* %tm_mon, align 4
  %14 = load i64*, i64** %args.addr, align 8
  %arrayidx11 = getelementptr inbounds i64, i64* %14, i64 5
  %15 = load i64, i64* %arrayidx11, align 8
  %call12 = call i32 @check_tm_member(i64 %15, i32 1900)
  %tm_year = getelementptr inbounds %struct.tm, %struct.tm* %tm, i32 0, i32 5
  store i32 %call12, i32* %tm_year, align 4
  %tm_isdst = getelementptr inbounds %struct.tm, %struct.tm* %tm, i32 0, i32 8
  store i32 -1, i32* %tm_isdst, align 4
  %16 = load i64, i64* %zone, align 8
  %and = and i64 %16, 7
  %conv = trunc i64 %and to i32
  %cmp13 = icmp eq i32 %conv, 3
  br i1 %cmp13, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  %17 = load i64, i64* %zone, align 8
  %sub15 = sub nsw i64 %17, 3
  %18 = inttoptr i64 %sub15 to i8*
  %19 = bitcast i8* %18 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %19, i32 0, i32 0
  %20 = load i64, i64* %car, align 8
  store i64 %20, i64* %zone, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end
  %21 = load i64, i64* %zone, align 8
  %call16 = call %struct.tm_zone* @tzlookup(i64 %21, i1 zeroext false)
  store %struct.tm_zone* %call16, %struct.tm_zone** %tz, align 8
  %22 = load %struct.tm_zone*, %struct.tm_zone** %tz, align 8
  %call17 = call i64 @emacs_mktime_z(%struct.tm_zone* %22, %struct.tm* %tm)
  store i64 %call17, i64* %value, align 8
  %23 = load %struct.tm_zone*, %struct.tm_zone** %tz, align 8
  call void @xtzfree(%struct.tm_zone* %23)
  %24 = load i64, i64* %value, align 8
  %cmp18 = icmp eq i64 %24, -1
  br i1 %cmp18, label %if.then.20, label %if.end.21

if.then.20:                                       ; preds = %if.end
  call void @time_overflow() #9
  unreachable

if.end.21:                                        ; preds = %if.end
  %25 = load i64, i64* %value, align 8
  %call22 = call i64 @hi_time(i64 %25)
  %26 = load i64, i64* %value, align 8
  %call23 = call i32 @lo_time(i64 %26)
  %conv24 = sext i32 %call23 to i64
  %call25 = call i64 @list2i(i64 %call22, i64 %conv24)
  ret i64 %call25
}

; Function Attrs: nounwind uwtable
define internal i32 @check_tm_member(i64 %obj, i32 %offset) #0 {
entry:
  %obj.addr = alloca i64, align 8
  %offset.addr = alloca i32, align 4
  %n = alloca i64, align 8
  store i64 %obj, i64* %obj.addr, align 8
  store i32 %offset, i32* %offset.addr, align 4
  %0 = load i64, i64* %obj.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %and1 = and i32 %conv, -5
  %cmp = icmp eq i32 %and1, 2
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = call i64 @builtin_lisp_symbol(i32 559)
  %1 = load i64, i64* %obj.addr, align 8
  %2 = call i64 @wrong_type_argument(i64 %call, i64 %1) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %3, %cond.true
  %4 = load i64, i64* %obj.addr, align 8
  %shr = ashr i64 %4, 2
  store i64 %shr, i64* %n, align 8
  %5 = load i32, i32* %offset.addr, align 4
  %add = add nsw i32 -2147483648, %5
  %conv3 = sext i32 %add to i64
  %6 = load i64, i64* %n, align 8
  %cmp4 = icmp sle i64 %conv3, %6
  br i1 %cmp4, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %cond.end
  %7 = load i64, i64* %n, align 8
  %8 = load i32, i32* %offset.addr, align 4
  %conv6 = sext i32 %8 to i64
  %sub = sub nsw i64 %7, %conv6
  %cmp7 = icmp sle i64 %sub, 2147483647
  br i1 %cmp7, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true, %cond.end
  call void @time_overflow() #9
  unreachable

if.end:                                           ; preds = %land.lhs.true
  %9 = load i64, i64* %n, align 8
  %10 = load i32, i32* %offset.addr, align 4
  %conv9 = sext i32 %10 to i64
  %sub10 = sub nsw i64 %9, %conv9
  %conv11 = trunc i64 %sub10 to i32
  ret i32 %conv11
}

; Function Attrs: nounwind uwtable
define internal i64 @emacs_mktime_z(%struct.tm_zone* %tz, %struct.tm* %tm) #0 {
entry:
  %tz.addr = alloca %struct.tm_zone*, align 8
  %tm.addr = alloca %struct.tm*, align 8
  %t = alloca i64, align 8
  store %struct.tm_zone* %tz, %struct.tm_zone** %tz.addr, align 8
  store %struct.tm* %tm, %struct.tm** %tm.addr, align 8
  %call = call i32* @__errno_location() #10
  store i32 0, i32* %call, align 4
  %0 = load %struct.tm_zone*, %struct.tm_zone** %tz.addr, align 8
  %1 = load %struct.tm*, %struct.tm** %tm.addr, align 8
  %call1 = call i64 @mktime_z(%struct.tm_zone* %0, %struct.tm* %1)
  store i64 %call1, i64* %t, align 8
  %2 = load i64, i64* %t, align 8
  %cmp = icmp eq i64 %2, -1
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %call2 = call i32* @__errno_location() #10
  %3 = load i32, i32* %call2, align 4
  %cmp3 = icmp eq i32 %3, 12
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  call void @memory_full(i64 -1) #9
  unreachable

if.end:                                           ; preds = %land.lhs.true, %entry
  %4 = load i64, i64* %t, align 8
  ret i64 %4
}

declare i64 @list2i(i64, i64) #1

; Function Attrs: nounwind uwtable
define i64 @Fcurrent_time_string(i64 %specified_time, i64 %zone) #0 {
entry:
  %specified_time.addr = alloca i64, align 8
  %zone.addr = alloca i64, align 8
  %value = alloca i64, align 8
  %tz = alloca %struct.tm_zone*, align 8
  %tm = alloca %struct.tm, align 8
  %tmp = alloca %struct.tm*, align 8
  %year_base = alloca i64, align 8
  %buf = alloca [33 x i8], align 16
  %len = alloca i32, align 4
  store i64 %specified_time, i64* %specified_time.addr, align 8
  store i64 %zone, i64* %zone.addr, align 8
  %0 = load i64, i64* %specified_time.addr, align 8
  %call = call i64 @lisp_seconds_argument(i64 %0)
  store i64 %call, i64* %value, align 8
  %1 = load i64, i64* %zone.addr, align 8
  %call1 = call %struct.tm_zone* @tzlookup(i64 %1, i1 zeroext false)
  store %struct.tm_zone* %call1, %struct.tm_zone** %tz, align 8
  %2 = load %struct.tm_zone*, %struct.tm_zone** %tz, align 8
  %call2 = call %struct.tm* @emacs_localtime_rz(%struct.tm_zone* %2, i64* %value, %struct.tm* %tm)
  store %struct.tm* %call2, %struct.tm** %tmp, align 8
  %3 = load %struct.tm_zone*, %struct.tm_zone** %tz, align 8
  call void @xtzfree(%struct.tm_zone* %3)
  %4 = load %struct.tm*, %struct.tm** %tmp, align 8
  %tobool = icmp ne %struct.tm* %4, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  call void @time_overflow() #9
  unreachable

if.end:                                           ; preds = %entry
  store i64 1900, i64* %year_base, align 8
  %arraydecay = getelementptr inbounds [33 x i8], [33 x i8]* %buf, i32 0, i32 0
  %tm_wday = getelementptr inbounds %struct.tm, %struct.tm* %tm, i32 0, i32 6
  %5 = load i32, i32* %tm_wday, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds [7 x [4 x i8]], [7 x [4 x i8]]* @Fcurrent_time_string.wday_name, i32 0, i64 %idxprom
  %arraydecay6 = getelementptr inbounds [4 x i8], [4 x i8]* %arrayidx, i32 0, i32 0
  %tm_mon = getelementptr inbounds %struct.tm, %struct.tm* %tm, i32 0, i32 4
  %6 = load i32, i32* %tm_mon, align 4
  %idxprom7 = sext i32 %6 to i64
  %arrayidx8 = getelementptr inbounds [12 x [4 x i8]], [12 x [4 x i8]]* @Fcurrent_time_string.mon_name, i32 0, i64 %idxprom7
  %arraydecay9 = getelementptr inbounds [4 x i8], [4 x i8]* %arrayidx8, i32 0, i32 0
  %tm_mday = getelementptr inbounds %struct.tm, %struct.tm* %tm, i32 0, i32 3
  %7 = load i32, i32* %tm_mday, align 4
  %tm_hour = getelementptr inbounds %struct.tm, %struct.tm* %tm, i32 0, i32 2
  %8 = load i32, i32* %tm_hour, align 4
  %tm_min = getelementptr inbounds %struct.tm, %struct.tm* %tm, i32 0, i32 1
  %9 = load i32, i32* %tm_min, align 4
  %tm_sec = getelementptr inbounds %struct.tm, %struct.tm* %tm, i32 0, i32 0
  %10 = load i32, i32* %tm_sec, align 4
  %tm_year = getelementptr inbounds %struct.tm, %struct.tm* %tm, i32 0, i32 5
  %11 = load i32, i32* %tm_year, align 4
  %conv = sext i32 %11 to i64
  %12 = load i64, i64* %year_base, align 8
  %add = add nsw i64 %conv, %12
  %call10 = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.8, i32 0, i32 0), i8* %arraydecay6, i8* %arraydecay9, i32 %7, i32 %8, i32 %9, i32 %10, i64 %add) #5
  store i32 %call10, i32* %len, align 4
  %arraydecay11 = getelementptr inbounds [33 x i8], [33 x i8]* %buf, i32 0, i32 0
  %13 = load i32, i32* %len, align 4
  %conv12 = sext i32 %13 to i64
  %call13 = call i64 @make_unibyte_string(i8* %arraydecay11, i64 %conv12)
  ret i64 %call13
}

; Function Attrs: nounwind
declare i32 @sprintf(i8*, i8*, ...) #2

declare i64 @make_unibyte_string(i8*, i64) #1

; Function Attrs: nounwind uwtable
define i64 @Fcurrent_time_zone(i64 %specified_time, i64 %zone) #0 {
entry:
  %specified_time.addr = alloca i64, align 8
  %zone.addr = alloca i64, align 8
  %value = alloca %struct.timespec, align 8
  %local_tm = alloca %struct.tm, align 8
  %gmt_tm = alloca %struct.tm, align 8
  %zone_offset = alloca i64, align 8
  %zone_name = alloca i64, align 8
  %coerce = alloca %struct.timespec, align 8
  %offset = alloca i64, align 8
  %m = alloca i64, align 8
  %am = alloca i64, align 8
  %hour = alloca i64, align 8
  %min = alloca i32, align 4
  %buf = alloca [24 x i8], align 16
  store i64 %specified_time, i64* %specified_time.addr, align 8
  store i64 %zone, i64* %zone.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call, i64* %zone_offset, align 8
  %0 = load i64, i64* %specified_time.addr, align 8
  %call1 = call i64 @lisp_seconds_argument(i64 %0)
  %call2 = call { i64, i64 } @make_timespec(i64 %call1, i64 0)
  %1 = bitcast %struct.timespec* %coerce to { i64, i64 }*
  %2 = getelementptr { i64, i64 }, { i64, i64 }* %1, i32 0, i32 0
  %3 = extractvalue { i64, i64 } %call2, 0
  store i64 %3, i64* %2, align 8
  %4 = getelementptr { i64, i64 }, { i64, i64 }* %1, i32 0, i32 1
  %5 = extractvalue { i64, i64 } %call2, 1
  store i64 %5, i64* %4, align 8
  %6 = bitcast %struct.timespec* %value to i8*
  %7 = bitcast %struct.timespec* %coerce to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %6, i8* %7, i64 16, i32 8, i1 false)
  %8 = load i64, i64* %zone.addr, align 8
  %9 = bitcast %struct.timespec* %value to { i64, i64 }*
  %10 = getelementptr { i64, i64 }, { i64, i64 }* %9, i32 0, i32 0
  %11 = load i64, i64* %10, align 1
  %12 = getelementptr { i64, i64 }, { i64, i64 }* %9, i32 0, i32 1
  %13 = load i64, i64* %12, align 1
  %call3 = call i64 @format_time_string(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.9, i32 0, i32 0), i64 2, i64 %11, i64 %13, i64 %8, %struct.tm* %local_tm)
  store i64 %call3, i64* %zone_name, align 8
  %call4 = call i64 @tm_gmtoff(%struct.tm* %local_tm)
  store i64 %call4, i64* %offset, align 8
  %14 = load i64, i64* %offset, align 8
  %shl = shl i64 %14, 2
  %add = add i64 %shl, 2
  store i64 %add, i64* %zone_offset, align 8
  %15 = load i64, i64* %zone_name, align 8
  %call5 = call i64 @SCHARS(i64 %15)
  %cmp = icmp eq i64 %call5, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %16 = load i64, i64* %offset, align 8
  %div = sdiv i64 %16, 60
  store i64 %div, i64* %m, align 8
  %17 = load i64, i64* %offset, align 8
  %cmp6 = icmp slt i64 %17, 0
  br i1 %cmp6, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  %18 = load i64, i64* %m, align 8
  %sub = sub nsw i64 0, %18
  br label %cond.end

cond.false:                                       ; preds = %if.then
  %19 = load i64, i64* %m, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %sub, %cond.true ], [ %19, %cond.false ]
  store i64 %cond, i64* %am, align 8
  %20 = load i64, i64* %am, align 8
  %div7 = sdiv i64 %20, 60
  store i64 %div7, i64* %hour, align 8
  %21 = load i64, i64* %am, align 8
  %rem = srem i64 %21, 60
  %conv = trunc i64 %rem to i32
  store i32 %conv, i32* %min, align 4
  %arraydecay = getelementptr inbounds [24 x i8], [24 x i8]* %buf, i32 0, i32 0
  %22 = load i64, i64* %offset, align 8
  %cmp8 = icmp slt i64 %22, 0
  %cond10 = select i1 %cmp8, i32 45, i32 43
  %23 = load i64, i64* %hour, align 8
  %24 = load i32, i32* %min, align 4
  %call11 = call i64 (i8*, i8*, ...) @make_formatted_string(i8* %arraydecay, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.10, i32 0, i32 0), i32 %cond10, i64 %23, i32 %24)
  store i64 %call11, i64* %zone_name, align 8
  br label %if.end

if.end:                                           ; preds = %cond.end, %entry
  %25 = load i64, i64* %zone_offset, align 8
  %26 = load i64, i64* %zone_name, align 8
  %call12 = call i64 @list2(i64 %25, i64 %26)
  ret i64 %call12
}

declare i64 @make_formatted_string(i8*, i8*, ...) #1

declare i64 @list2(i64, i64) #1

; Function Attrs: nounwind uwtable
define i64 @Fset_time_zone_rule(i64 %tz) #0 {
entry:
  %tz.addr = alloca i64, align 8
  store i64 %tz, i64* %tz.addr, align 8
  %0 = load i64, i64* %tz.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %0, %call
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %call1 = call i64 @builtin_lisp_symbol(i32 1011)
  br label %cond.end

cond.false:                                       ; preds = %entry
  %1 = load i64, i64* %tz.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call1, %cond.true ], [ %1, %cond.false ]
  %call2 = call %struct.tm_zone* @tzlookup(i64 %cond, i1 zeroext true)
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  ret i64 %call3
}

; Function Attrs: nounwind uwtable
define i8* @emacs_getenv_TZ() #0 {
entry:
  %0 = load i8*, i8** @tzvalbuf, align 8
  %arrayidx = getelementptr inbounds i8, i8* %0, i64 0
  %1 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %1 to i32
  %cmp = icmp eq i32 %conv, 84
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load i8*, i8** @tzvalbuf, align 8
  %add.ptr = getelementptr inbounds i8, i8* %2, i64 3
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %add.ptr, %cond.true ], [ null, %cond.false ]
  ret i8* %cond
}

; Function Attrs: nounwind uwtable
define i32 @emacs_setenv_TZ(i8* %tzstring) #0 {
entry:
  %tzstring.addr = alloca i8*, align 8
  %tzstringlen = alloca i64, align 8
  %tzval = alloca i8*, align 8
  %new_tzvalbuf = alloca i8, align 1
  store i8* %tzstring, i8** %tzstring.addr, align 8
  %0 = load i8*, i8** %tzstring.addr, align 8
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load i8*, i8** %tzstring.addr, align 8
  %call = call i64 @strlen(i8* %1) #8
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call, %cond.true ], [ 0, %cond.false ]
  store i64 %cond, i64* %tzstringlen, align 8
  %2 = load i8*, i8** @tzvalbuf, align 8
  store i8* %2, i8** %tzval, align 8
  %3 = load i64, i64* @emacs_setenv_TZ.tzvalbufsize, align 8
  %4 = load i64, i64* %tzstringlen, align 8
  %add = add nsw i64 3, %4
  %cmp = icmp sle i64 %3, %add
  %frombool = zext i1 %cmp to i8
  store i8 %frombool, i8* %new_tzvalbuf, align 1
  %5 = load i8, i8* %new_tzvalbuf, align 1
  %tobool1 = trunc i8 %5 to i1
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  %6 = load i64, i64* %tzstringlen, align 8
  %add2 = add nsw i64 3, %6
  %7 = load i64, i64* @emacs_setenv_TZ.tzvalbufsize, align 8
  %sub = sub nsw i64 %add2, %7
  %add3 = add nsw i64 %sub, 1
  %call4 = call i8* @xpalloc(i8* null, i64* @emacs_setenv_TZ.tzvalbufsize, i64 %add3, i64 -1, i64 1)
  store i8* %call4, i8** %tzval, align 8
  %8 = load i8*, i8** %tzval, align 8
  store i8* %8, i8** @tzvalbuf, align 8
  %9 = load i8*, i8** %tzval, align 8
  %arrayidx = getelementptr inbounds i8, i8* %9, i64 1
  store i8 90, i8* %arrayidx, align 1
  %10 = load i8*, i8** %tzval, align 8
  %arrayidx5 = getelementptr inbounds i8, i8* %10, i64 2
  store i8 61, i8* %arrayidx5, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end
  %11 = load i8*, i8** %tzstring.addr, align 8
  %tobool6 = icmp ne i8* %11, null
  br i1 %tobool6, label %if.then.7, label %if.else

if.then.7:                                        ; preds = %if.end
  %12 = load i8*, i8** %tzval, align 8
  %arrayidx8 = getelementptr inbounds i8, i8* %12, i64 0
  store i8 84, i8* %arrayidx8, align 1
  %13 = load i8*, i8** %tzval, align 8
  %add.ptr = getelementptr inbounds i8, i8* %13, i64 3
  %14 = load i8*, i8** %tzstring.addr, align 8
  %call9 = call i8* @strcpy(i8* %add.ptr, i8* %14) #5
  br label %if.end.12

if.else:                                          ; preds = %if.end
  %15 = load i8*, i8** %tzval, align 8
  %arrayidx10 = getelementptr inbounds i8, i8* %15, i64 0
  store i8 116, i8* %arrayidx10, align 1
  %16 = load i8*, i8** %tzval, align 8
  %arrayidx11 = getelementptr inbounds i8, i8* %16, i64 3
  store i8 0, i8* %arrayidx11, align 1
  br label %if.end.12

if.end.12:                                        ; preds = %if.else, %if.then.7
  %17 = load i8, i8* %new_tzvalbuf, align 1
  %tobool13 = trunc i8 %17 to i1
  br i1 %tobool13, label %if.then.14, label %if.end.15

if.then.14:                                       ; preds = %if.end.12
  %18 = load i8*, i8** %tzval, align 8
  call void @xputenv(i8* %18)
  br label %if.end.15

if.end.15:                                        ; preds = %if.then.14, %if.end.12
  ret i32 0
}

declare i8* @xpalloc(i8*, i64*, i64, i64, i64) #1

; Function Attrs: nounwind uwtable
define void @insert1(i64 %arg) #0 {
entry:
  %arg.addr = alloca i64, align 8
  store i64 %arg, i64* %arg.addr, align 8
  %call = call i64 @Finsert(i64 1, i64* %arg.addr)
  ret void
}

; Function Attrs: nounwind uwtable
define i64 @Finsert(i64 %nargs, i64* %args) #0 {
entry:
  %nargs.addr = alloca i64, align 8
  %args.addr = alloca i64*, align 8
  store i64 %nargs, i64* %nargs.addr, align 8
  store i64* %args, i64** %args.addr, align 8
  %0 = load i64, i64* %nargs.addr, align 8
  %1 = load i64*, i64** %args.addr, align 8
  call void @general_insert_function(void (i8*, i64)* @insert, void (i64, i64, i64, i64, i64, i1)* @insert_from_string, i1 zeroext false, i64 %0, i64* %1)
  %call = call i64 @builtin_lisp_symbol(i32 0)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define internal void @general_insert_function(void (i8*, i64)* %insert_func, void (i64, i64, i64, i64, i64, i1)* %insert_from_string_func, i1 zeroext %inherit, i64 %nargs, i64* %args) #0 {
entry:
  %insert_func.addr = alloca void (i8*, i64)*, align 8
  %insert_from_string_func.addr = alloca void (i64, i64, i64, i64, i64, i1)*, align 8
  %inherit.addr = alloca i8, align 1
  %nargs.addr = alloca i64, align 8
  %args.addr = alloca i64*, align 8
  %argnum = alloca i64, align 8
  %val = alloca i64, align 8
  %c = alloca i32, align 4
  %str = alloca [5 x i8], align 1
  %len = alloca i32, align 4
  store void (i8*, i64)* %insert_func, void (i8*, i64)** %insert_func.addr, align 8
  store void (i64, i64, i64, i64, i64, i1)* %insert_from_string_func, void (i64, i64, i64, i64, i64, i1)** %insert_from_string_func.addr, align 8
  %frombool = zext i1 %inherit to i8
  store i8 %frombool, i8* %inherit.addr, align 1
  store i64 %nargs, i64* %nargs.addr, align 8
  store i64* %args, i64** %args.addr, align 8
  store i64 0, i64* %argnum, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, i64* %argnum, align 8
  %1 = load i64, i64* %nargs.addr, align 8
  %cmp = icmp slt i64 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i64, i64* %argnum, align 8
  %3 = load i64*, i64** %args.addr, align 8
  %arrayidx = getelementptr inbounds i64, i64* %3, i64 %2
  %4 = load i64, i64* %arrayidx, align 8
  store i64 %4, i64* %val, align 8
  %5 = load i64, i64* %val, align 8
  %call = call zeroext i1 @NATNUMP(i64 %5)
  br i1 %call, label %land.lhs.true, label %if.else.74

land.lhs.true:                                    ; preds = %for.body
  %6 = load i64, i64* %val, align 8
  %shr = ashr i64 %6, 2
  %cmp1 = icmp sle i64 %shr, 4194303
  br i1 %cmp1, label %if.then, label %if.else.74

if.then:                                          ; preds = %land.lhs.true
  %7 = load i64, i64* %val, align 8
  %shr2 = ashr i64 %7, 2
  %conv = trunc i64 %shr2 to i32
  store i32 %conv, i32* %c, align 4
  %8 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %enable_multibyte_characters_ = getelementptr inbounds %struct.buffer, %struct.buffer* %8, i32 0, i32 39
  %9 = load i64, i64* %enable_multibyte_characters_, align 8
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp4 = icmp eq i64 %9, %call3
  br i1 %cmp4, label %if.else, label %if.then.6

if.then.6:                                        ; preds = %if.then
  br i1 true, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.6
  %10 = load i32, i32* %c, align 4
  %add = add i32 %10, 0
  %cmp7 = icmp ule i32 %add, 127
  br i1 %cmp7, label %cond.true.13, label %cond.false.16

cond.false:                                       ; preds = %if.then.6
  %11 = load i32, i32* %c, align 4
  %conv9 = sext i32 %11 to i64
  %add10 = add i64 %conv9, 0
  %cmp11 = icmp ule i64 %add10, 127
  br i1 %cmp11, label %cond.true.13, label %cond.false.16

cond.true.13:                                     ; preds = %cond.false, %cond.true
  %12 = load i32, i32* %c, align 4
  %conv14 = trunc i32 %12 to i8
  %arrayidx15 = getelementptr inbounds [5 x i8], [5 x i8]* %str, i32 0, i64 0
  store i8 %conv14, i8* %arrayidx15, align 1
  br label %cond.end.61

cond.false.16:                                    ; preds = %cond.false, %cond.true
  br i1 true, label %cond.true.17, label %cond.false.21

cond.true.17:                                     ; preds = %cond.false.16
  %13 = load i32, i32* %c, align 4
  %add18 = add i32 %13, 0
  %cmp19 = icmp ule i32 %add18, 2047
  br i1 %cmp19, label %cond.true.26, label %cond.false.33

cond.false.21:                                    ; preds = %cond.false.16
  %14 = load i32, i32* %c, align 4
  %conv22 = sext i32 %14 to i64
  %add23 = add i64 %conv22, 0
  %cmp24 = icmp ule i64 %add23, 2047
  br i1 %cmp24, label %cond.true.26, label %cond.false.33

cond.true.26:                                     ; preds = %cond.false.21, %cond.true.17
  %15 = load i32, i32* %c, align 4
  %shr27 = ashr i32 %15, 6
  %or = or i32 192, %shr27
  %conv28 = trunc i32 %or to i8
  %arrayidx29 = getelementptr inbounds [5 x i8], [5 x i8]* %str, i32 0, i64 0
  store i8 %conv28, i8* %arrayidx29, align 1
  %16 = load i32, i32* %c, align 4
  %and = and i32 %16, 63
  %or30 = or i32 128, %and
  %conv31 = trunc i32 %or30 to i8
  %arrayidx32 = getelementptr inbounds [5 x i8], [5 x i8]* %str, i32 0, i64 1
  store i8 %conv31, i8* %arrayidx32, align 1
  br label %cond.end.59

cond.false.33:                                    ; preds = %cond.false.21, %cond.true.17
  br i1 true, label %cond.true.34, label %cond.false.38

cond.true.34:                                     ; preds = %cond.false.33
  %17 = load i32, i32* %c, align 4
  %add35 = add i32 %17, 0
  %cmp36 = icmp ule i32 %add35, 65535
  br i1 %cmp36, label %cond.true.43, label %cond.false.57

cond.false.38:                                    ; preds = %cond.false.33
  %18 = load i32, i32* %c, align 4
  %conv39 = sext i32 %18 to i64
  %add40 = add i64 %conv39, 0
  %cmp41 = icmp ule i64 %add40, 65535
  br i1 %cmp41, label %cond.true.43, label %cond.false.57

cond.true.43:                                     ; preds = %cond.false.38, %cond.true.34
  %19 = load i32, i32* %c, align 4
  %shr44 = ashr i32 %19, 12
  %or45 = or i32 224, %shr44
  %conv46 = trunc i32 %or45 to i8
  %arrayidx47 = getelementptr inbounds [5 x i8], [5 x i8]* %str, i32 0, i64 0
  store i8 %conv46, i8* %arrayidx47, align 1
  %20 = load i32, i32* %c, align 4
  %shr48 = ashr i32 %20, 6
  %and49 = and i32 %shr48, 63
  %or50 = or i32 128, %and49
  %conv51 = trunc i32 %or50 to i8
  %arrayidx52 = getelementptr inbounds [5 x i8], [5 x i8]* %str, i32 0, i64 1
  store i8 %conv51, i8* %arrayidx52, align 1
  %21 = load i32, i32* %c, align 4
  %and53 = and i32 %21, 63
  %or54 = or i32 128, %and53
  %conv55 = trunc i32 %or54 to i8
  %arrayidx56 = getelementptr inbounds [5 x i8], [5 x i8]* %str, i32 0, i64 2
  store i8 %conv55, i8* %arrayidx56, align 1
  br label %cond.end

cond.false.57:                                    ; preds = %cond.false.38, %cond.true.34
  %22 = load i32, i32* %c, align 4
  %arraydecay = getelementptr inbounds [5 x i8], [5 x i8]* %str, i32 0, i32 0
  %call58 = call i32 @char_string(i32 %22, i8* %arraydecay)
  br label %cond.end

cond.end:                                         ; preds = %cond.false.57, %cond.true.43
  %cond = phi i32 [ 3, %cond.true.43 ], [ %call58, %cond.false.57 ]
  br label %cond.end.59

cond.end.59:                                      ; preds = %cond.end, %cond.true.26
  %cond60 = phi i32 [ 2, %cond.true.26 ], [ %cond, %cond.end ]
  br label %cond.end.61

cond.end.61:                                      ; preds = %cond.end.59, %cond.true.13
  %cond62 = phi i32 [ 1, %cond.true.13 ], [ %cond60, %cond.end.59 ]
  store i32 %cond62, i32* %len, align 4
  br label %if.end

if.else:                                          ; preds = %if.then
  %23 = load i32, i32* %c, align 4
  %cmp63 = icmp sgt i32 %23, 4194175
  br i1 %cmp63, label %cond.true.65, label %cond.false.66

cond.true.65:                                     ; preds = %if.else
  %24 = load i32, i32* %c, align 4
  %sub = sub nsw i32 %24, 4194048
  br label %cond.end.68

cond.false.66:                                    ; preds = %if.else
  %25 = load i32, i32* %c, align 4
  %and67 = and i32 %25, 255
  br label %cond.end.68

cond.end.68:                                      ; preds = %cond.false.66, %cond.true.65
  %cond69 = phi i32 [ %sub, %cond.true.65 ], [ %and67, %cond.false.66 ]
  %conv70 = trunc i32 %cond69 to i8
  %arrayidx71 = getelementptr inbounds [5 x i8], [5 x i8]* %str, i32 0, i64 0
  store i8 %conv70, i8* %arrayidx71, align 1
  store i32 1, i32* %len, align 4
  br label %if.end

if.end:                                           ; preds = %cond.end.68, %cond.end.61
  %26 = load void (i8*, i64)*, void (i8*, i64)** %insert_func.addr, align 8
  %arraydecay72 = getelementptr inbounds [5 x i8], [5 x i8]* %str, i32 0, i32 0
  %27 = load i32, i32* %len, align 4
  %conv73 = sext i32 %27 to i64
  call void %26(i8* %arraydecay72, i64 %conv73)
  br label %if.end.82

if.else.74:                                       ; preds = %land.lhs.true, %for.body
  %28 = load i64, i64* %val, align 8
  %call75 = call zeroext i1 @STRINGP(i64 %28)
  br i1 %call75, label %if.then.76, label %if.else.79

if.then.76:                                       ; preds = %if.else.74
  %29 = load void (i64, i64, i64, i64, i64, i1)*, void (i64, i64, i64, i64, i64, i1)** %insert_from_string_func.addr, align 8
  %30 = load i64, i64* %val, align 8
  %31 = load i64, i64* %val, align 8
  %call77 = call i64 @SCHARS(i64 %31)
  %32 = load i64, i64* %val, align 8
  %call78 = call i64 @SBYTES(i64 %32)
  %33 = load i8, i8* %inherit.addr, align 1
  %tobool = trunc i8 %33 to i1
  call void %29(i64 %30, i64 0, i64 0, i64 %call77, i64 %call78, i1 zeroext %tobool)
  br label %if.end.81

if.else.79:                                       ; preds = %if.else.74
  %call80 = call i64 @builtin_lisp_symbol(i32 255)
  %34 = load i64, i64* %val, align 8
  %35 = call i64 @wrong_type_argument(i64 %call80, i64 %34) #9
  unreachable

if.end.81:                                        ; preds = %if.then.76
  br label %if.end.82

if.end.82:                                        ; preds = %if.end.81, %if.end
  br label %for.inc

for.inc:                                          ; preds = %if.end.82
  %36 = load i64, i64* %argnum, align 8
  %inc = add nsw i64 %36, 1
  store i64 %inc, i64* %argnum, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

declare void @insert(i8*, i64) #1

declare void @insert_from_string(i64, i64, i64, i64, i64, i1 zeroext) #1

; Function Attrs: nounwind uwtable
define i64 @Finsert_and_inherit(i64 %nargs, i64* %args) #0 {
entry:
  %nargs.addr = alloca i64, align 8
  %args.addr = alloca i64*, align 8
  store i64 %nargs, i64* %nargs.addr, align 8
  store i64* %args, i64** %args.addr, align 8
  %0 = load i64, i64* %nargs.addr, align 8
  %1 = load i64*, i64** %args.addr, align 8
  call void @general_insert_function(void (i8*, i64)* @insert_and_inherit, void (i64, i64, i64, i64, i64, i1)* @insert_from_string, i1 zeroext true, i64 %0, i64* %1)
  %call = call i64 @builtin_lisp_symbol(i32 0)
  ret i64 %call
}

declare void @insert_and_inherit(i8*, i64) #1

; Function Attrs: nounwind uwtable
define i64 @Finsert_before_markers(i64 %nargs, i64* %args) #0 {
entry:
  %nargs.addr = alloca i64, align 8
  %args.addr = alloca i64*, align 8
  store i64 %nargs, i64* %nargs.addr, align 8
  store i64* %args, i64** %args.addr, align 8
  %0 = load i64, i64* %nargs.addr, align 8
  %1 = load i64*, i64** %args.addr, align 8
  call void @general_insert_function(void (i8*, i64)* @insert_before_markers, void (i64, i64, i64, i64, i64, i1)* @insert_from_string_before_markers, i1 zeroext false, i64 %0, i64* %1)
  %call = call i64 @builtin_lisp_symbol(i32 0)
  ret i64 %call
}

declare void @insert_before_markers(i8*, i64) #1

declare void @insert_from_string_before_markers(i64, i64, i64, i64, i64, i1 zeroext) #1

; Function Attrs: nounwind uwtable
define i64 @Finsert_and_inherit_before_markers(i64 %nargs, i64* %args) #0 {
entry:
  %nargs.addr = alloca i64, align 8
  %args.addr = alloca i64*, align 8
  store i64 %nargs, i64* %nargs.addr, align 8
  store i64* %args, i64** %args.addr, align 8
  %0 = load i64, i64* %nargs.addr, align 8
  %1 = load i64*, i64** %args.addr, align 8
  call void @general_insert_function(void (i8*, i64)* @insert_before_markers_and_inherit, void (i64, i64, i64, i64, i64, i1)* @insert_from_string_before_markers, i1 zeroext true, i64 %0, i64* %1)
  %call = call i64 @builtin_lisp_symbol(i32 0)
  ret i64 %call
}

declare void @insert_before_markers_and_inherit(i8*, i64) #1

; Function Attrs: nounwind uwtable
define i64 @Finsert_char(i64 %character, i64 %count, i64 %inherit) #0 {
entry:
  %retval = alloca i64, align 8
  %character.addr = alloca i64, align 8
  %count.addr = alloca i64, align 8
  %inherit.addr = alloca i64, align 8
  %i = alloca i32, align 4
  %stringlen = alloca i32, align 4
  %n = alloca i64, align 8
  %c = alloca i32, align 4
  %len = alloca i32, align 4
  %str = alloca [5 x i8], align 1
  %string = alloca [4000 x i8], align 16
  store i64 %character, i64* %character.addr, align 8
  store i64 %count, i64* %count.addr, align 8
  store i64 %inherit, i64* %inherit.addr, align 8
  %0 = load i64, i64* %character.addr, align 8
  %call = call zeroext i1 @NATNUMP(i64 %0)
  br i1 %call, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, i64* %character.addr, align 8
  %shr = ashr i64 %1, 2
  %cmp = icmp sle i64 %shr, 4194303
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %entry
  %call1 = call i64 @builtin_lisp_symbol(i32 260)
  %2 = load i64, i64* %character.addr, align 8
  %3 = call i64 @wrong_type_argument(i64 %call1, i64 %2) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %4, %cond.true
  %5 = load i64, i64* %count.addr, align 8
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp3 = icmp eq i64 %5, %call2
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  %call4 = call i64 @make_natnum(i64 1)
  store i64 %call4, i64* %count.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end
  %6 = load i64, i64* %count.addr, align 8
  %and = and i64 %6, 7
  %conv = trunc i64 %and to i32
  %and5 = and i32 %conv, -5
  %cmp6 = icmp eq i32 %and5, 2
  br i1 %cmp6, label %cond.true.8, label %cond.false.9

cond.true.8:                                      ; preds = %if.end
  br label %cond.end.11

cond.false.9:                                     ; preds = %if.end
  %call10 = call i64 @builtin_lisp_symbol(i32 559)
  %7 = load i64, i64* %count.addr, align 8
  %8 = call i64 @wrong_type_argument(i64 %call10, i64 %7) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end.11

cond.end.11:                                      ; preds = %9, %cond.true.8
  %10 = load i64, i64* %character.addr, align 8
  %shr12 = ashr i64 %10, 2
  %conv13 = trunc i64 %shr12 to i32
  store i32 %conv13, i32* %c, align 4
  %11 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %enable_multibyte_characters_ = getelementptr inbounds %struct.buffer, %struct.buffer* %11, i32 0, i32 39
  %12 = load i64, i64* %enable_multibyte_characters_, align 8
  %call14 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp15 = icmp eq i64 %12, %call14
  br i1 %cmp15, label %if.else, label %if.then.17

if.then.17:                                       ; preds = %cond.end.11
  br i1 true, label %cond.true.18, label %cond.false.21

cond.true.18:                                     ; preds = %if.then.17
  %13 = load i32, i32* %c, align 4
  %add = add i32 %13, 0
  %cmp19 = icmp ule i32 %add, 127
  br i1 %cmp19, label %cond.true.26, label %cond.false.28

cond.false.21:                                    ; preds = %if.then.17
  %14 = load i32, i32* %c, align 4
  %conv22 = sext i32 %14 to i64
  %add23 = add i64 %conv22, 0
  %cmp24 = icmp ule i64 %add23, 127
  br i1 %cmp24, label %cond.true.26, label %cond.false.28

cond.true.26:                                     ; preds = %cond.false.21, %cond.true.18
  %15 = load i32, i32* %c, align 4
  %conv27 = trunc i32 %15 to i8
  %arrayidx = getelementptr inbounds [5 x i8], [5 x i8]* %str, i32 0, i64 0
  store i8 %conv27, i8* %arrayidx, align 1
  br label %cond.end.75

cond.false.28:                                    ; preds = %cond.false.21, %cond.true.18
  br i1 true, label %cond.true.29, label %cond.false.33

cond.true.29:                                     ; preds = %cond.false.28
  %16 = load i32, i32* %c, align 4
  %add30 = add i32 %16, 0
  %cmp31 = icmp ule i32 %add30, 2047
  br i1 %cmp31, label %cond.true.38, label %cond.false.46

cond.false.33:                                    ; preds = %cond.false.28
  %17 = load i32, i32* %c, align 4
  %conv34 = sext i32 %17 to i64
  %add35 = add i64 %conv34, 0
  %cmp36 = icmp ule i64 %add35, 2047
  br i1 %cmp36, label %cond.true.38, label %cond.false.46

cond.true.38:                                     ; preds = %cond.false.33, %cond.true.29
  %18 = load i32, i32* %c, align 4
  %shr39 = ashr i32 %18, 6
  %or = or i32 192, %shr39
  %conv40 = trunc i32 %or to i8
  %arrayidx41 = getelementptr inbounds [5 x i8], [5 x i8]* %str, i32 0, i64 0
  store i8 %conv40, i8* %arrayidx41, align 1
  %19 = load i32, i32* %c, align 4
  %and42 = and i32 %19, 63
  %or43 = or i32 128, %and42
  %conv44 = trunc i32 %or43 to i8
  %arrayidx45 = getelementptr inbounds [5 x i8], [5 x i8]* %str, i32 0, i64 1
  store i8 %conv44, i8* %arrayidx45, align 1
  br label %cond.end.73

cond.false.46:                                    ; preds = %cond.false.33, %cond.true.29
  br i1 true, label %cond.true.47, label %cond.false.51

cond.true.47:                                     ; preds = %cond.false.46
  %20 = load i32, i32* %c, align 4
  %add48 = add i32 %20, 0
  %cmp49 = icmp ule i32 %add48, 65535
  br i1 %cmp49, label %cond.true.56, label %cond.false.70

cond.false.51:                                    ; preds = %cond.false.46
  %21 = load i32, i32* %c, align 4
  %conv52 = sext i32 %21 to i64
  %add53 = add i64 %conv52, 0
  %cmp54 = icmp ule i64 %add53, 65535
  br i1 %cmp54, label %cond.true.56, label %cond.false.70

cond.true.56:                                     ; preds = %cond.false.51, %cond.true.47
  %22 = load i32, i32* %c, align 4
  %shr57 = ashr i32 %22, 12
  %or58 = or i32 224, %shr57
  %conv59 = trunc i32 %or58 to i8
  %arrayidx60 = getelementptr inbounds [5 x i8], [5 x i8]* %str, i32 0, i64 0
  store i8 %conv59, i8* %arrayidx60, align 1
  %23 = load i32, i32* %c, align 4
  %shr61 = ashr i32 %23, 6
  %and62 = and i32 %shr61, 63
  %or63 = or i32 128, %and62
  %conv64 = trunc i32 %or63 to i8
  %arrayidx65 = getelementptr inbounds [5 x i8], [5 x i8]* %str, i32 0, i64 1
  store i8 %conv64, i8* %arrayidx65, align 1
  %24 = load i32, i32* %c, align 4
  %and66 = and i32 %24, 63
  %or67 = or i32 128, %and66
  %conv68 = trunc i32 %or67 to i8
  %arrayidx69 = getelementptr inbounds [5 x i8], [5 x i8]* %str, i32 0, i64 2
  store i8 %conv68, i8* %arrayidx69, align 1
  br label %cond.end.72

cond.false.70:                                    ; preds = %cond.false.51, %cond.true.47
  %25 = load i32, i32* %c, align 4
  %arraydecay = getelementptr inbounds [5 x i8], [5 x i8]* %str, i32 0, i32 0
  %call71 = call i32 @char_string(i32 %25, i8* %arraydecay)
  br label %cond.end.72

cond.end.72:                                      ; preds = %cond.false.70, %cond.true.56
  %cond = phi i32 [ 3, %cond.true.56 ], [ %call71, %cond.false.70 ]
  br label %cond.end.73

cond.end.73:                                      ; preds = %cond.end.72, %cond.true.38
  %cond74 = phi i32 [ 2, %cond.true.38 ], [ %cond, %cond.end.72 ]
  br label %cond.end.75

cond.end.75:                                      ; preds = %cond.end.73, %cond.true.26
  %cond76 = phi i32 [ 1, %cond.true.26 ], [ %cond74, %cond.end.73 ]
  store i32 %cond76, i32* %len, align 4
  br label %if.end.79

if.else:                                          ; preds = %cond.end.11
  %26 = load i32, i32* %c, align 4
  %conv77 = trunc i32 %26 to i8
  %arrayidx78 = getelementptr inbounds [5 x i8], [5 x i8]* %str, i32 0, i64 0
  store i8 %conv77, i8* %arrayidx78, align 1
  store i32 1, i32* %len, align 4
  br label %if.end.79

if.end.79:                                        ; preds = %if.else, %cond.end.75
  %27 = load i64, i64* %count.addr, align 8
  %shr80 = ashr i64 %27, 2
  %cmp81 = icmp sle i64 %shr80, 0
  br i1 %cmp81, label %if.then.83, label %if.end.85

if.then.83:                                       ; preds = %if.end.79
  %call84 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call84, i64* %retval
  br label %return

if.end.85:                                        ; preds = %if.end.79
  %28 = load i32, i32* %len, align 4
  %conv86 = sext i32 %28 to i64
  %div = sdiv i64 2305843009213693950, %conv86
  %29 = load i64, i64* %count.addr, align 8
  %shr87 = ashr i64 %29, 2
  %cmp88 = icmp slt i64 %div, %shr87
  br i1 %cmp88, label %if.then.90, label %if.end.91

if.then.90:                                       ; preds = %if.end.85
  call void @buffer_overflow() #9
  unreachable

if.end.91:                                        ; preds = %if.end.85
  %30 = load i64, i64* %count.addr, align 8
  %shr92 = ashr i64 %30, 2
  %31 = load i32, i32* %len, align 4
  %conv93 = sext i32 %31 to i64
  %mul = mul nsw i64 %shr92, %conv93
  store i64 %mul, i64* %n, align 8
  %32 = load i64, i64* %n, align 8
  %33 = load i32, i32* %len, align 4
  %conv94 = sext i32 %33 to i64
  %rem = urem i64 4000, %conv94
  %sub = sub i64 4000, %rem
  %cmp95 = icmp ult i64 %32, %sub
  br i1 %cmp95, label %cond.true.97, label %cond.false.98

cond.true.97:                                     ; preds = %if.end.91
  %34 = load i64, i64* %n, align 8
  br label %cond.end.102

cond.false.98:                                    ; preds = %if.end.91
  %35 = load i32, i32* %len, align 4
  %conv99 = sext i32 %35 to i64
  %rem100 = urem i64 4000, %conv99
  %sub101 = sub i64 4000, %rem100
  br label %cond.end.102

cond.end.102:                                     ; preds = %cond.false.98, %cond.true.97
  %cond103 = phi i64 [ %34, %cond.true.97 ], [ %sub101, %cond.false.98 ]
  %conv104 = trunc i64 %cond103 to i32
  store i32 %conv104, i32* %stringlen, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end.102
  %36 = load i32, i32* %i, align 4
  %37 = load i32, i32* %stringlen, align 4
  %cmp105 = icmp slt i32 %36, %37
  br i1 %cmp105, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %38 = load i32, i32* %i, align 4
  %39 = load i32, i32* %len, align 4
  %rem107 = srem i32 %38, %39
  %idxprom = sext i32 %rem107 to i64
  %arrayidx108 = getelementptr inbounds [5 x i8], [5 x i8]* %str, i32 0, i64 %idxprom
  %40 = load i8, i8* %arrayidx108, align 1
  %41 = load i32, i32* %i, align 4
  %idxprom109 = sext i32 %41 to i64
  %arrayidx110 = getelementptr inbounds [4000 x i8], [4000 x i8]* %string, i32 0, i64 %idxprom109
  store i8 %40, i8* %arrayidx110, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %42 = load i32, i32* %i, align 4
  %inc = add nsw i32 %42, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %while.cond

while.cond:                                       ; preds = %if.end.135, %for.end
  %43 = load i64, i64* %n, align 8
  %44 = load i32, i32* %stringlen, align 4
  %conv111 = sext i32 %44 to i64
  %cmp112 = icmp sgt i64 %43, %conv111
  br i1 %cmp112, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  br label %do.body

do.body:                                          ; preds = %while.body
  %45 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call114 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp115 = icmp eq i64 %45, %call114
  br i1 %cmp115, label %if.else.122, label %land.lhs.true.117

land.lhs.true.117:                                ; preds = %do.body
  %46 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  %call118 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp119 = icmp eq i64 %46, %call118
  br i1 %cmp119, label %if.then.121, label %if.else.122

if.then.121:                                      ; preds = %land.lhs.true.117
  call void @process_quit_flag()
  br label %if.end.125

if.else.122:                                      ; preds = %land.lhs.true.117, %do.body
  %47 = load volatile i8, i8* @pending_signals, align 1
  %tobool = trunc i8 %47 to i1
  br i1 %tobool, label %if.then.123, label %if.end.124

if.then.123:                                      ; preds = %if.else.122
  call void @process_pending_signals()
  br label %if.end.124

if.end.124:                                       ; preds = %if.then.123, %if.else.122
  br label %if.end.125

if.end.125:                                       ; preds = %if.end.124, %if.then.121
  br label %do.end

do.end:                                           ; preds = %if.end.125
  %48 = load i64, i64* %inherit.addr, align 8
  %call126 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp127 = icmp eq i64 %48, %call126
  br i1 %cmp127, label %if.else.132, label %if.then.129

if.then.129:                                      ; preds = %do.end
  %arraydecay130 = getelementptr inbounds [4000 x i8], [4000 x i8]* %string, i32 0, i32 0
  %49 = load i32, i32* %stringlen, align 4
  %conv131 = sext i32 %49 to i64
  call void @insert_and_inherit(i8* %arraydecay130, i64 %conv131)
  br label %if.end.135

if.else.132:                                      ; preds = %do.end
  %arraydecay133 = getelementptr inbounds [4000 x i8], [4000 x i8]* %string, i32 0, i32 0
  %50 = load i32, i32* %stringlen, align 4
  %conv134 = sext i32 %50 to i64
  call void @insert(i8* %arraydecay133, i64 %conv134)
  br label %if.end.135

if.end.135:                                       ; preds = %if.else.132, %if.then.129
  %51 = load i32, i32* %stringlen, align 4
  %conv136 = sext i32 %51 to i64
  %52 = load i64, i64* %n, align 8
  %sub137 = sub nsw i64 %52, %conv136
  store i64 %sub137, i64* %n, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %53 = load i64, i64* %inherit.addr, align 8
  %call138 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp139 = icmp eq i64 %53, %call138
  br i1 %cmp139, label %if.else.143, label %if.then.141

if.then.141:                                      ; preds = %while.end
  %arraydecay142 = getelementptr inbounds [4000 x i8], [4000 x i8]* %string, i32 0, i32 0
  %54 = load i64, i64* %n, align 8
  call void @insert_and_inherit(i8* %arraydecay142, i64 %54)
  br label %if.end.145

if.else.143:                                      ; preds = %while.end
  %arraydecay144 = getelementptr inbounds [4000 x i8], [4000 x i8]* %string, i32 0, i32 0
  %55 = load i64, i64* %n, align 8
  call void @insert(i8* %arraydecay144, i64 %55)
  br label %if.end.145

if.end.145:                                       ; preds = %if.else.143, %if.then.141
  %call146 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call146, i64* %retval
  br label %return

return:                                           ; preds = %if.end.145, %if.then.83
  %56 = load i64, i64* %retval
  ret i64 %56
}

; Function Attrs: noreturn
declare void @buffer_overflow() #4

declare void @process_quit_flag() #1

declare void @process_pending_signals() #1

; Function Attrs: nounwind uwtable
define i64 @Finsert_byte(i64 %byte, i64 %count, i64 %inherit) #0 {
entry:
  %byte.addr = alloca i64, align 8
  %count.addr = alloca i64, align 8
  %inherit.addr = alloca i64, align 8
  store i64 %byte, i64* %byte.addr, align 8
  store i64 %count, i64* %count.addr, align 8
  store i64 %inherit, i64* %inherit.addr, align 8
  %0 = load i64, i64* %byte.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %and1 = and i32 %conv, -5
  %cmp = icmp eq i32 %and1, 2
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = call i64 @builtin_lisp_symbol(i32 559)
  %1 = load i64, i64* %byte.addr, align 8
  %2 = call i64 @wrong_type_argument(i64 %call, i64 %1) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %3, %cond.true
  %4 = load i64, i64* %byte.addr, align 8
  %shr = ashr i64 %4, 2
  %cmp3 = icmp slt i64 %shr, 0
  br i1 %cmp3, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end
  %5 = load i64, i64* %byte.addr, align 8
  %shr5 = ashr i64 %5, 2
  %cmp6 = icmp sgt i64 %shr5, 255
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %cond.end
  %6 = load i64, i64* %byte.addr, align 8
  call void @args_out_of_range_3(i64 %6, i64 2, i64 1022) #9
  unreachable

if.end:                                           ; preds = %lor.lhs.false
  %7 = load i64, i64* %byte.addr, align 8
  %shr8 = ashr i64 %7, 2
  %cmp9 = icmp sge i64 %shr8, 128
  br i1 %cmp9, label %land.lhs.true, label %if.end.17

land.lhs.true:                                    ; preds = %if.end
  %8 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %enable_multibyte_characters_ = getelementptr inbounds %struct.buffer, %struct.buffer* %8, i32 0, i32 39
  %9 = load i64, i64* %enable_multibyte_characters_, align 8
  %call11 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp12 = icmp eq i64 %9, %call11
  br i1 %cmp12, label %if.end.17, label %if.then.14

if.then.14:                                       ; preds = %land.lhs.true
  %10 = load i64, i64* %byte.addr, align 8
  %shr15 = ashr i64 %10, 2
  %add = add nsw i64 %shr15, 4194048
  %call16 = call i64 @make_natnum(i64 %add)
  store i64 %call16, i64* %byte.addr, align 8
  br label %if.end.17

if.end.17:                                        ; preds = %if.then.14, %land.lhs.true, %if.end
  %11 = load i64, i64* %byte.addr, align 8
  %12 = load i64, i64* %count.addr, align 8
  %13 = load i64, i64* %inherit.addr, align 8
  %call18 = call i64 @Finsert_char(i64 %11, i64 %12, i64 %13)
  ret i64 %call18
}

; Function Attrs: noreturn
declare void @args_out_of_range_3(i64, i64, i64) #4

; Function Attrs: nounwind uwtable
define i64 @make_buffer_string_both(i64 %start, i64 %start_byte, i64 %end, i64 %end_byte, i1 zeroext %props) #0 {
entry:
  %start.addr = alloca i64, align 8
  %start_byte.addr = alloca i64, align 8
  %end.addr = alloca i64, align 8
  %end_byte.addr = alloca i64, align 8
  %props.addr = alloca i8, align 1
  %result = alloca i64, align 8
  %tem = alloca i64, align 8
  %tem1 = alloca i64, align 8
  %beg0 = alloca i64, align 8
  %end0 = alloca i64, align 8
  %beg1 = alloca i64, align 8
  %end1 = alloca i64, align 8
  %size = alloca i64, align 8
  store i64 %start, i64* %start.addr, align 8
  store i64 %start_byte, i64* %start_byte.addr, align 8
  store i64 %end, i64* %end.addr, align 8
  store i64 %end_byte, i64* %end_byte.addr, align 8
  %frombool = zext i1 %props to i8
  store i8 %frombool, i8* %props.addr, align 1
  %0 = load i64, i64* %start_byte.addr, align 8
  %1 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text = getelementptr inbounds %struct.buffer, %struct.buffer* %1, i32 0, i32 73
  %2 = load %struct.buffer_text*, %struct.buffer_text** %text, align 8
  %gpt_byte = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %2, i32 0, i32 3
  %3 = load i64, i64* %gpt_byte, align 8
  %cmp = icmp slt i64 %0, %3
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %4 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text1 = getelementptr inbounds %struct.buffer, %struct.buffer* %4, i32 0, i32 73
  %5 = load %struct.buffer_text*, %struct.buffer_text** %text1, align 8
  %gpt_byte2 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %5, i32 0, i32 3
  %6 = load i64, i64* %gpt_byte2, align 8
  %7 = load i64, i64* %end_byte.addr, align 8
  %cmp3 = icmp slt i64 %6, %7
  br i1 %cmp3, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %8 = load i64, i64* %start_byte.addr, align 8
  store i64 %8, i64* %beg0, align 8
  %9 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text4 = getelementptr inbounds %struct.buffer, %struct.buffer* %9, i32 0, i32 73
  %10 = load %struct.buffer_text*, %struct.buffer_text** %text4, align 8
  %gpt_byte5 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %10, i32 0, i32 3
  %11 = load i64, i64* %gpt_byte5, align 8
  store i64 %11, i64* %end0, align 8
  %12 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text6 = getelementptr inbounds %struct.buffer, %struct.buffer* %12, i32 0, i32 73
  %13 = load %struct.buffer_text*, %struct.buffer_text** %text6, align 8
  %gpt_byte7 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %13, i32 0, i32 3
  %14 = load i64, i64* %gpt_byte7, align 8
  %15 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text8 = getelementptr inbounds %struct.buffer, %struct.buffer* %15, i32 0, i32 73
  %16 = load %struct.buffer_text*, %struct.buffer_text** %text8, align 8
  %gap_size = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %16, i32 0, i32 5
  %17 = load i64, i64* %gap_size, align 8
  %add = add nsw i64 %14, %17
  %sub = sub nsw i64 %add, 1
  store i64 %sub, i64* %beg1, align 8
  %18 = load i64, i64* %end_byte.addr, align 8
  %19 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text9 = getelementptr inbounds %struct.buffer, %struct.buffer* %19, i32 0, i32 73
  %20 = load %struct.buffer_text*, %struct.buffer_text** %text9, align 8
  %gap_size10 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %20, i32 0, i32 5
  %21 = load i64, i64* %gap_size10, align 8
  %add11 = add nsw i64 %18, %21
  %sub12 = sub nsw i64 %add11, 1
  store i64 %sub12, i64* %end1, align 8
  br label %if.end

if.else:                                          ; preds = %land.lhs.true, %entry
  %22 = load i64, i64* %start_byte.addr, align 8
  store i64 %22, i64* %beg0, align 8
  %23 = load i64, i64* %end_byte.addr, align 8
  store i64 %23, i64* %end0, align 8
  store i64 -1, i64* %beg1, align 8
  store i64 -1, i64* %end1, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %24 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %enable_multibyte_characters_ = getelementptr inbounds %struct.buffer, %struct.buffer* %24, i32 0, i32 39
  %25 = load i64, i64* %enable_multibyte_characters_, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp13 = icmp eq i64 %25, %call
  br i1 %cmp13, label %if.else.18, label %if.then.14

if.then.14:                                       ; preds = %if.end
  %26 = load i64, i64* %end.addr, align 8
  %27 = load i64, i64* %start.addr, align 8
  %sub15 = sub nsw i64 %26, %27
  %28 = load i64, i64* %end_byte.addr, align 8
  %29 = load i64, i64* %start_byte.addr, align 8
  %sub16 = sub nsw i64 %28, %29
  %call17 = call i64 @make_uninit_multibyte_string(i64 %sub15, i64 %sub16)
  store i64 %call17, i64* %result, align 8
  br label %if.end.21

if.else.18:                                       ; preds = %if.end
  %30 = load i64, i64* %end.addr, align 8
  %31 = load i64, i64* %start.addr, align 8
  %sub19 = sub nsw i64 %30, %31
  %call20 = call i64 @make_uninit_string(i64 %sub19)
  store i64 %call20, i64* %result, align 8
  br label %if.end.21

if.end.21:                                        ; preds = %if.else.18, %if.then.14
  %32 = load i64, i64* %end0, align 8
  %33 = load i64, i64* %beg0, align 8
  %sub22 = sub nsw i64 %32, %33
  store i64 %sub22, i64* %size, align 8
  %34 = load i64, i64* %result, align 8
  %call23 = call i8* @SDATA(i64 %34)
  %35 = load i64, i64* %beg0, align 8
  %36 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text24 = getelementptr inbounds %struct.buffer, %struct.buffer* %36, i32 0, i32 73
  %37 = load %struct.buffer_text*, %struct.buffer_text** %text24, align 8
  %gpt_byte25 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %37, i32 0, i32 3
  %38 = load i64, i64* %gpt_byte25, align 8
  %cmp26 = icmp sge i64 %35, %38
  br i1 %cmp26, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.21
  %39 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text27 = getelementptr inbounds %struct.buffer, %struct.buffer* %39, i32 0, i32 73
  %40 = load %struct.buffer_text*, %struct.buffer_text** %text27, align 8
  %gap_size28 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %40, i32 0, i32 5
  %41 = load i64, i64* %gap_size28, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.end.21
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %41, %cond.true ], [ 0, %cond.false ]
  %42 = load i64, i64* %beg0, align 8
  %add29 = add nsw i64 %cond, %42
  %43 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text30 = getelementptr inbounds %struct.buffer, %struct.buffer* %43, i32 0, i32 73
  %44 = load %struct.buffer_text*, %struct.buffer_text** %text30, align 8
  %beg = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %44, i32 0, i32 0
  %45 = load i8*, i8** %beg, align 8
  %add.ptr = getelementptr inbounds i8, i8* %45, i64 %add29
  %add.ptr31 = getelementptr inbounds i8, i8* %add.ptr, i64 -1
  %46 = load i64, i64* %size, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %call23, i8* %add.ptr31, i64 %46, i32 1, i1 false)
  %47 = load i64, i64* %beg1, align 8
  %cmp32 = icmp ne i64 %47, -1
  br i1 %cmp32, label %if.then.33, label %if.end.40

if.then.33:                                       ; preds = %cond.end
  %48 = load i64, i64* %result, align 8
  %call34 = call i8* @SDATA(i64 %48)
  %49 = load i64, i64* %size, align 8
  %add.ptr35 = getelementptr inbounds i8, i8* %call34, i64 %49
  %50 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text36 = getelementptr inbounds %struct.buffer, %struct.buffer* %50, i32 0, i32 73
  %51 = load %struct.buffer_text*, %struct.buffer_text** %text36, align 8
  %beg37 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %51, i32 0, i32 0
  %52 = load i8*, i8** %beg37, align 8
  %53 = load i64, i64* %beg1, align 8
  %add.ptr38 = getelementptr inbounds i8, i8* %52, i64 %53
  %54 = load i64, i64* %end1, align 8
  %55 = load i64, i64* %beg1, align 8
  %sub39 = sub nsw i64 %54, %55
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %add.ptr35, i8* %add.ptr38, i64 %sub39, i32 1, i1 false)
  br label %if.end.40

if.end.40:                                        ; preds = %if.then.33, %cond.end
  %56 = load i8, i8* %props.addr, align 1
  %tobool = trunc i8 %56 to i1
  br i1 %tobool, label %if.then.41, label %if.end.57

if.then.41:                                       ; preds = %if.end.40
  %57 = load i64, i64* %start.addr, align 8
  %58 = load i64, i64* %end.addr, align 8
  call void @update_buffer_properties(i64 %57, i64 %58)
  %59 = load i64, i64* %start.addr, align 8
  %shl = shl i64 %59, 2
  %add42 = add i64 %shl, 2
  %call43 = call i64 @builtin_lisp_symbol(i32 0)
  %60 = load i64, i64* %end.addr, align 8
  %shl44 = shl i64 %60, 2
  %add45 = add i64 %shl44, 2
  %call46 = call i64 @Fnext_property_change(i64 %add42, i64 %call43, i64 %add45)
  store i64 %call46, i64* %tem, align 8
  %61 = load i64, i64* %start.addr, align 8
  %shl47 = shl i64 %61, 2
  %add48 = add i64 %shl47, 2
  %call49 = call i64 @builtin_lisp_symbol(i32 0)
  %call50 = call i64 @Ftext_properties_at(i64 %add48, i64 %call49)
  store i64 %call50, i64* %tem1, align 8
  %62 = load i64, i64* %tem, align 8
  %shr = ashr i64 %62, 2
  %63 = load i64, i64* %end.addr, align 8
  %cmp51 = icmp ne i64 %shr, %63
  br i1 %cmp51, label %if.then.54, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.then.41
  %64 = load i64, i64* %tem1, align 8
  %call52 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp53 = icmp eq i64 %64, %call52
  br i1 %cmp53, label %if.end.56, label %if.then.54

if.then.54:                                       ; preds = %lor.lhs.false, %if.then.41
  %65 = load i64, i64* %result, align 8
  %66 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %67 = load i64, i64* %start.addr, align 8
  %68 = load i64, i64* %end.addr, align 8
  %69 = load i64, i64* %start.addr, align 8
  %sub55 = sub nsw i64 %68, %69
  call void @copy_intervals_to_string(i64 %65, %struct.buffer* %66, i64 %67, i64 %sub55)
  br label %if.end.56

if.end.56:                                        ; preds = %if.then.54, %lor.lhs.false
  br label %if.end.57

if.end.57:                                        ; preds = %if.end.56, %if.end.40
  %70 = load i64, i64* %result, align 8
  ret i64 %70
}

declare i64 @make_uninit_multibyte_string(i64, i64) #1

declare i64 @make_uninit_string(i64) #1

; Function Attrs: nounwind uwtable
define internal void @update_buffer_properties(i64 %start, i64 %end) #0 {
entry:
  %start.addr = alloca i64, align 8
  %end.addr = alloca i64, align 8
  %tem = alloca i64, align 8
  %.compoundliteral = alloca [3 x i64], align 8
  store i64 %start, i64* %start.addr, align 8
  store i64 %end, i64* %end.addr, align 8
  %0 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 17), align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %0, %call
  br i1 %cmp, label %if.end.20, label %if.then

if.then:                                          ; preds = %entry
  %1 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 16), align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp2 = icmp eq i64 %1, %call1
  br i1 %cmp2, label %if.end.12, label %if.then.3

if.then.3:                                        ; preds = %if.then
  %2 = load i64, i64* %start.addr, align 8
  %shl = shl i64 %2, 2
  %add = add i64 %shl, 2
  %3 = load i64, i64* %end.addr, align 8
  %shl4 = shl i64 %3, 2
  %add5 = add i64 %shl4, 2
  %4 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 16), align 8
  %call6 = call i64 @builtin_lisp_symbol(i32 0)
  %call7 = call i64 @builtin_lisp_symbol(i32 0)
  %call8 = call i64 @Ftext_property_any(i64 %add, i64 %add5, i64 %4, i64 %call6, i64 %call7)
  store i64 %call8, i64* %tem, align 8
  %5 = load i64, i64* %tem, align 8
  %call9 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp10 = icmp eq i64 %5, %call9
  br i1 %cmp10, label %if.then.11, label %if.end

if.then.11:                                       ; preds = %if.then.3
  br label %if.end.20

if.end:                                           ; preds = %if.then.3
  br label %if.end.12

if.end.12:                                        ; preds = %if.end, %if.then
  %arrayinit.begin = getelementptr inbounds [3 x i64], [3 x i64]* %.compoundliteral, i64 0, i64 0
  %call13 = call i64 @builtin_lisp_symbol(i32 220)
  store i64 %call13, i64* %arrayinit.begin
  %arrayinit.element = getelementptr inbounds i64, i64* %arrayinit.begin, i64 1
  %6 = load i64, i64* %start.addr, align 8
  %shl14 = shl i64 %6, 2
  %add15 = add i64 %shl14, 2
  store i64 %add15, i64* %arrayinit.element
  %arrayinit.element16 = getelementptr inbounds i64, i64* %arrayinit.element, i64 1
  %7 = load i64, i64* %end.addr, align 8
  %shl17 = shl i64 %7, 2
  %add18 = add i64 %shl17, 2
  store i64 %add18, i64* %arrayinit.element16
  %arraydecay = getelementptr inbounds [3 x i64], [3 x i64]* %.compoundliteral, i32 0, i32 0
  %call19 = call i64 @Frun_hook_with_args(i64 3, i64* %arraydecay)
  br label %if.end.20

if.end.20:                                        ; preds = %if.then.11, %if.end.12, %entry
  ret void
}

declare i64 @Fnext_property_change(i64, i64, i64) #1

declare i64 @Ftext_properties_at(i64, i64) #1

declare void @copy_intervals_to_string(i64, %struct.buffer*, i64, i64) #1

; Function Attrs: nounwind uwtable
define i64 @Fbuffer_substring(i64 %start, i64 %end) #0 {
entry:
  %start.addr = alloca i64, align 8
  %end.addr = alloca i64, align 8
  %b = alloca i64, align 8
  %e = alloca i64, align 8
  store i64 %start, i64* %start.addr, align 8
  store i64 %end, i64* %end.addr, align 8
  call void @validate_region(i64* %start.addr, i64* %end.addr)
  %0 = load i64, i64* %start.addr, align 8
  %shr = ashr i64 %0, 2
  store i64 %shr, i64* %b, align 8
  %1 = load i64, i64* %end.addr, align 8
  %shr1 = ashr i64 %1, 2
  store i64 %shr1, i64* %e, align 8
  %2 = load i64, i64* %b, align 8
  %3 = load i64, i64* %e, align 8
  %call = call i64 @make_buffer_string(i64 %2, i64 %3, i1 zeroext true)
  ret i64 %call
}

declare void @validate_region(i64*, i64*) #1

; Function Attrs: nounwind uwtable
define i64 @Fbuffer_substring_no_properties(i64 %start, i64 %end) #0 {
entry:
  %start.addr = alloca i64, align 8
  %end.addr = alloca i64, align 8
  %b = alloca i64, align 8
  %e = alloca i64, align 8
  store i64 %start, i64* %start.addr, align 8
  store i64 %end, i64* %end.addr, align 8
  call void @validate_region(i64* %start.addr, i64* %end.addr)
  %0 = load i64, i64* %start.addr, align 8
  %shr = ashr i64 %0, 2
  store i64 %shr, i64* %b, align 8
  %1 = load i64, i64* %end.addr, align 8
  %shr1 = ashr i64 %1, 2
  store i64 %shr1, i64* %e, align 8
  %2 = load i64, i64* %b, align 8
  %3 = load i64, i64* %e, align 8
  %call = call i64 @make_buffer_string(i64 %2, i64 %3, i1 zeroext false)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define i64 @Fbuffer_string() #0 {
entry:
  %0 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv = getelementptr inbounds %struct.buffer, %struct.buffer* %0, i32 0, i32 77
  %1 = load i64, i64* %begv, align 8
  %2 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv_byte = getelementptr inbounds %struct.buffer, %struct.buffer* %2, i32 0, i32 78
  %3 = load i64, i64* %begv_byte, align 8
  %4 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv = getelementptr inbounds %struct.buffer, %struct.buffer* %4, i32 0, i32 79
  %5 = load i64, i64* %zv, align 8
  %6 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv_byte = getelementptr inbounds %struct.buffer, %struct.buffer* %6, i32 0, i32 80
  %7 = load i64, i64* %zv_byte, align 8
  %call = call i64 @make_buffer_string_both(i64 %1, i64 %3, i64 %5, i64 %7, i1 zeroext true)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define i64 @Finsert_buffer_substring(i64 %buffer, i64 %start, i64 %end) #0 {
entry:
  %buffer.addr = alloca i64, align 8
  %start.addr = alloca i64, align 8
  %end.addr = alloca i64, align 8
  %b = alloca i64, align 8
  %e = alloca i64, align 8
  %temp = alloca i64, align 8
  %bp = alloca %struct.buffer*, align 8
  %obuf = alloca %struct.buffer*, align 8
  %buf = alloca i64, align 8
  store i64 %buffer, i64* %buffer.addr, align 8
  store i64 %start, i64* %start.addr, align 8
  store i64 %end, i64* %end.addr, align 8
  %0 = load i64, i64* %buffer.addr, align 8
  %call = call i64 @Fget_buffer(i64 %0)
  store i64 %call, i64* %buf, align 8
  %1 = load i64, i64* %buf, align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %1, %call1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i64, i64* %buffer.addr, align 8
  call void @nsberror(i64 %2) #9
  unreachable

if.end:                                           ; preds = %entry
  %3 = load i64, i64* %buf, align 8
  %call2 = call %struct.buffer* @XBUFFER(i64 %3)
  store %struct.buffer* %call2, %struct.buffer** %bp, align 8
  %4 = load %struct.buffer*, %struct.buffer** %bp, align 8
  %name_ = getelementptr inbounds %struct.buffer, %struct.buffer* %4, i32 0, i32 1
  %5 = load i64, i64* %name_, align 8
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp4 = icmp eq i64 %5, %call3
  br i1 %cmp4, label %if.then.5, label %if.end.6

if.then.5:                                        ; preds = %if.end
  call void (i8*, ...) @error(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.11, i32 0, i32 0)) #9
  unreachable

if.end.6:                                         ; preds = %if.end
  %6 = load i64, i64* %start.addr, align 8
  %call7 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp8 = icmp eq i64 %6, %call7
  br i1 %cmp8, label %if.then.9, label %if.else

if.then.9:                                        ; preds = %if.end.6
  %7 = load %struct.buffer*, %struct.buffer** %bp, align 8
  %8 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %cmp10 = icmp eq %struct.buffer* %7, %8
  br i1 %cmp10, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.9
  %9 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv = getelementptr inbounds %struct.buffer, %struct.buffer* %9, i32 0, i32 77
  %10 = load i64, i64* %begv, align 8
  br label %cond.end.18

cond.false:                                       ; preds = %if.then.9
  %11 = load %struct.buffer*, %struct.buffer** %bp, align 8
  %begv_marker_ = getelementptr inbounds %struct.buffer, %struct.buffer* %11, i32 0, i32 46
  %12 = load i64, i64* %begv_marker_, align 8
  %call11 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp12 = icmp eq i64 %12, %call11
  br i1 %cmp12, label %cond.true.13, label %cond.false.15

cond.true.13:                                     ; preds = %cond.false
  %13 = load %struct.buffer*, %struct.buffer** %bp, align 8
  %begv14 = getelementptr inbounds %struct.buffer, %struct.buffer* %13, i32 0, i32 77
  %14 = load i64, i64* %begv14, align 8
  br label %cond.end

cond.false.15:                                    ; preds = %cond.false
  %15 = load %struct.buffer*, %struct.buffer** %bp, align 8
  %begv_marker_16 = getelementptr inbounds %struct.buffer, %struct.buffer* %15, i32 0, i32 46
  %16 = load i64, i64* %begv_marker_16, align 8
  %call17 = call i64 @marker_position(i64 %16)
  br label %cond.end

cond.end:                                         ; preds = %cond.false.15, %cond.true.13
  %cond = phi i64 [ %14, %cond.true.13 ], [ %call17, %cond.false.15 ]
  br label %cond.end.18

cond.end.18:                                      ; preds = %cond.end, %cond.true
  %cond19 = phi i64 [ %10, %cond.true ], [ %cond, %cond.end ]
  store i64 %cond19, i64* %b, align 8
  br label %if.end.39

if.else:                                          ; preds = %if.end.6
  br label %do.body

do.body:                                          ; preds = %if.else
  %17 = load i64, i64* %start.addr, align 8
  %and = and i64 %17, 7
  %conv = trunc i64 %and to i32
  %cmp20 = icmp eq i32 %conv, 1
  br i1 %cmp20, label %land.lhs.true, label %if.else.28

land.lhs.true:                                    ; preds = %do.body
  %18 = load i64, i64* %start.addr, align 8
  %call22 = call i32 @XMISCTYPE(i64 %18)
  %cmp23 = icmp eq i32 %call22, 24236
  br i1 %cmp23, label %if.then.25, label %if.else.28

if.then.25:                                       ; preds = %land.lhs.true
  %19 = load i64, i64* %start.addr, align 8
  %call26 = call i64 @marker_position(i64 %19)
  %call27 = call i64 @make_natnum(i64 %call26)
  store i64 %call27, i64* %start.addr, align 8
  br label %if.end.38

if.else.28:                                       ; preds = %land.lhs.true, %do.body
  %20 = load i64, i64* %start.addr, align 8
  %and29 = and i64 %20, 7
  %conv30 = trunc i64 %and29 to i32
  %and31 = and i32 %conv30, -5
  %cmp32 = icmp eq i32 %and31, 2
  br i1 %cmp32, label %cond.true.34, label %cond.false.35

cond.true.34:                                     ; preds = %if.else.28
  br label %cond.end.37

cond.false.35:                                    ; preds = %if.else.28
  %call36 = call i64 @builtin_lisp_symbol(i32 558)
  %21 = load i64, i64* %start.addr, align 8
  %22 = call i64 @wrong_type_argument(i64 %call36, i64 %21) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end.37

cond.end.37:                                      ; preds = %23, %cond.true.34
  br label %if.end.38

if.end.38:                                        ; preds = %cond.end.37, %if.then.25
  br label %do.end

do.end:                                           ; preds = %if.end.38
  %24 = load i64, i64* %start.addr, align 8
  %shr = ashr i64 %24, 2
  store i64 %shr, i64* %b, align 8
  br label %if.end.39

if.end.39:                                        ; preds = %do.end, %cond.end.18
  %25 = load i64, i64* %end.addr, align 8
  %call40 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp41 = icmp eq i64 %25, %call40
  br i1 %cmp41, label %if.then.43, label %if.else.60

if.then.43:                                       ; preds = %if.end.39
  %26 = load %struct.buffer*, %struct.buffer** %bp, align 8
  %27 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %cmp44 = icmp eq %struct.buffer* %26, %27
  br i1 %cmp44, label %cond.true.46, label %cond.false.47

cond.true.46:                                     ; preds = %if.then.43
  %28 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv = getelementptr inbounds %struct.buffer, %struct.buffer* %28, i32 0, i32 79
  %29 = load i64, i64* %zv, align 8
  br label %cond.end.58

cond.false.47:                                    ; preds = %if.then.43
  %30 = load %struct.buffer*, %struct.buffer** %bp, align 8
  %zv_marker_ = getelementptr inbounds %struct.buffer, %struct.buffer* %30, i32 0, i32 47
  %31 = load i64, i64* %zv_marker_, align 8
  %call48 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp49 = icmp eq i64 %31, %call48
  br i1 %cmp49, label %cond.true.51, label %cond.false.53

cond.true.51:                                     ; preds = %cond.false.47
  %32 = load %struct.buffer*, %struct.buffer** %bp, align 8
  %zv52 = getelementptr inbounds %struct.buffer, %struct.buffer* %32, i32 0, i32 79
  %33 = load i64, i64* %zv52, align 8
  br label %cond.end.56

cond.false.53:                                    ; preds = %cond.false.47
  %34 = load %struct.buffer*, %struct.buffer** %bp, align 8
  %zv_marker_54 = getelementptr inbounds %struct.buffer, %struct.buffer* %34, i32 0, i32 47
  %35 = load i64, i64* %zv_marker_54, align 8
  %call55 = call i64 @marker_position(i64 %35)
  br label %cond.end.56

cond.end.56:                                      ; preds = %cond.false.53, %cond.true.51
  %cond57 = phi i64 [ %33, %cond.true.51 ], [ %call55, %cond.false.53 ]
  br label %cond.end.58

cond.end.58:                                      ; preds = %cond.end.56, %cond.true.46
  %cond59 = phi i64 [ %29, %cond.true.46 ], [ %cond57, %cond.end.56 ]
  store i64 %cond59, i64* %e, align 8
  br label %if.end.86

if.else.60:                                       ; preds = %if.end.39
  br label %do.body.61

do.body.61:                                       ; preds = %if.else.60
  %36 = load i64, i64* %end.addr, align 8
  %and62 = and i64 %36, 7
  %conv63 = trunc i64 %and62 to i32
  %cmp64 = icmp eq i32 %conv63, 1
  br i1 %cmp64, label %land.lhs.true.66, label %if.else.73

land.lhs.true.66:                                 ; preds = %do.body.61
  %37 = load i64, i64* %end.addr, align 8
  %call67 = call i32 @XMISCTYPE(i64 %37)
  %cmp68 = icmp eq i32 %call67, 24236
  br i1 %cmp68, label %if.then.70, label %if.else.73

if.then.70:                                       ; preds = %land.lhs.true.66
  %38 = load i64, i64* %end.addr, align 8
  %call71 = call i64 @marker_position(i64 %38)
  %call72 = call i64 @make_natnum(i64 %call71)
  store i64 %call72, i64* %end.addr, align 8
  br label %if.end.83

if.else.73:                                       ; preds = %land.lhs.true.66, %do.body.61
  %39 = load i64, i64* %end.addr, align 8
  %and74 = and i64 %39, 7
  %conv75 = trunc i64 %and74 to i32
  %and76 = and i32 %conv75, -5
  %cmp77 = icmp eq i32 %and76, 2
  br i1 %cmp77, label %cond.true.79, label %cond.false.80

cond.true.79:                                     ; preds = %if.else.73
  br label %cond.end.82

cond.false.80:                                    ; preds = %if.else.73
  %call81 = call i64 @builtin_lisp_symbol(i32 558)
  %40 = load i64, i64* %end.addr, align 8
  %41 = call i64 @wrong_type_argument(i64 %call81, i64 %40) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end.82

cond.end.82:                                      ; preds = %42, %cond.true.79
  br label %if.end.83

if.end.83:                                        ; preds = %cond.end.82, %if.then.70
  br label %do.end.84

do.end.84:                                        ; preds = %if.end.83
  %43 = load i64, i64* %end.addr, align 8
  %shr85 = ashr i64 %43, 2
  store i64 %shr85, i64* %e, align 8
  br label %if.end.86

if.end.86:                                        ; preds = %do.end.84, %cond.end.58
  %44 = load i64, i64* %b, align 8
  %45 = load i64, i64* %e, align 8
  %cmp87 = icmp sgt i64 %44, %45
  br i1 %cmp87, label %if.then.89, label %if.end.90

if.then.89:                                       ; preds = %if.end.86
  %46 = load i64, i64* %b, align 8
  store i64 %46, i64* %temp, align 8
  %47 = load i64, i64* %e, align 8
  store i64 %47, i64* %b, align 8
  %48 = load i64, i64* %temp, align 8
  store i64 %48, i64* %e, align 8
  br label %if.end.90

if.end.90:                                        ; preds = %if.then.89, %if.end.86
  %49 = load %struct.buffer*, %struct.buffer** %bp, align 8
  %50 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %cmp91 = icmp eq %struct.buffer* %49, %50
  br i1 %cmp91, label %cond.true.93, label %cond.false.95

cond.true.93:                                     ; preds = %if.end.90
  %51 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv94 = getelementptr inbounds %struct.buffer, %struct.buffer* %51, i32 0, i32 77
  %52 = load i64, i64* %begv94, align 8
  br label %cond.end.107

cond.false.95:                                    ; preds = %if.end.90
  %53 = load %struct.buffer*, %struct.buffer** %bp, align 8
  %begv_marker_96 = getelementptr inbounds %struct.buffer, %struct.buffer* %53, i32 0, i32 46
  %54 = load i64, i64* %begv_marker_96, align 8
  %call97 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp98 = icmp eq i64 %54, %call97
  br i1 %cmp98, label %cond.true.100, label %cond.false.102

cond.true.100:                                    ; preds = %cond.false.95
  %55 = load %struct.buffer*, %struct.buffer** %bp, align 8
  %begv101 = getelementptr inbounds %struct.buffer, %struct.buffer* %55, i32 0, i32 77
  %56 = load i64, i64* %begv101, align 8
  br label %cond.end.105

cond.false.102:                                   ; preds = %cond.false.95
  %57 = load %struct.buffer*, %struct.buffer** %bp, align 8
  %begv_marker_103 = getelementptr inbounds %struct.buffer, %struct.buffer* %57, i32 0, i32 46
  %58 = load i64, i64* %begv_marker_103, align 8
  %call104 = call i64 @marker_position(i64 %58)
  br label %cond.end.105

cond.end.105:                                     ; preds = %cond.false.102, %cond.true.100
  %cond106 = phi i64 [ %56, %cond.true.100 ], [ %call104, %cond.false.102 ]
  br label %cond.end.107

cond.end.107:                                     ; preds = %cond.end.105, %cond.true.93
  %cond108 = phi i64 [ %52, %cond.true.93 ], [ %cond106, %cond.end.105 ]
  %59 = load i64, i64* %b, align 8
  %cmp109 = icmp sle i64 %cond108, %59
  br i1 %cmp109, label %land.lhs.true.111, label %if.then.132

land.lhs.true.111:                                ; preds = %cond.end.107
  %60 = load i64, i64* %e, align 8
  %61 = load %struct.buffer*, %struct.buffer** %bp, align 8
  %62 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %cmp112 = icmp eq %struct.buffer* %61, %62
  br i1 %cmp112, label %cond.true.114, label %cond.false.116

cond.true.114:                                    ; preds = %land.lhs.true.111
  %63 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv115 = getelementptr inbounds %struct.buffer, %struct.buffer* %63, i32 0, i32 79
  %64 = load i64, i64* %zv115, align 8
  br label %cond.end.128

cond.false.116:                                   ; preds = %land.lhs.true.111
  %65 = load %struct.buffer*, %struct.buffer** %bp, align 8
  %zv_marker_117 = getelementptr inbounds %struct.buffer, %struct.buffer* %65, i32 0, i32 47
  %66 = load i64, i64* %zv_marker_117, align 8
  %call118 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp119 = icmp eq i64 %66, %call118
  br i1 %cmp119, label %cond.true.121, label %cond.false.123

cond.true.121:                                    ; preds = %cond.false.116
  %67 = load %struct.buffer*, %struct.buffer** %bp, align 8
  %zv122 = getelementptr inbounds %struct.buffer, %struct.buffer* %67, i32 0, i32 79
  %68 = load i64, i64* %zv122, align 8
  br label %cond.end.126

cond.false.123:                                   ; preds = %cond.false.116
  %69 = load %struct.buffer*, %struct.buffer** %bp, align 8
  %zv_marker_124 = getelementptr inbounds %struct.buffer, %struct.buffer* %69, i32 0, i32 47
  %70 = load i64, i64* %zv_marker_124, align 8
  %call125 = call i64 @marker_position(i64 %70)
  br label %cond.end.126

cond.end.126:                                     ; preds = %cond.false.123, %cond.true.121
  %cond127 = phi i64 [ %68, %cond.true.121 ], [ %call125, %cond.false.123 ]
  br label %cond.end.128

cond.end.128:                                     ; preds = %cond.end.126, %cond.true.114
  %cond129 = phi i64 [ %64, %cond.true.114 ], [ %cond127, %cond.end.126 ]
  %cmp130 = icmp sle i64 %60, %cond129
  br i1 %cmp130, label %if.end.133, label %if.then.132

if.then.132:                                      ; preds = %cond.end.128, %cond.end.107
  %71 = load i64, i64* %start.addr, align 8
  %72 = load i64, i64* %end.addr, align 8
  call void @args_out_of_range(i64 %71, i64 %72) #9
  unreachable

if.end.133:                                       ; preds = %cond.end.128
  %73 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  store %struct.buffer* %73, %struct.buffer** %obuf, align 8
  %74 = load %struct.buffer*, %struct.buffer** %bp, align 8
  call void @set_buffer_internal_1(%struct.buffer* %74)
  %75 = load i64, i64* %b, align 8
  %76 = load i64, i64* %e, align 8
  call void @update_buffer_properties(i64 %75, i64 %76)
  %77 = load %struct.buffer*, %struct.buffer** %obuf, align 8
  call void @set_buffer_internal_1(%struct.buffer* %77)
  %78 = load %struct.buffer*, %struct.buffer** %bp, align 8
  %79 = load i64, i64* %b, align 8
  %80 = load i64, i64* %e, align 8
  %81 = load i64, i64* %b, align 8
  %sub = sub nsw i64 %80, %81
  call void @insert_from_buffer(%struct.buffer* %78, i64 %79, i64 %sub, i1 zeroext false)
  %call134 = call i64 @builtin_lisp_symbol(i32 0)
  ret i64 %call134
}

declare i64 @Fget_buffer(i64) #1

; Function Attrs: noreturn
declare void @nsberror(i64) #4

; Function Attrs: noreturn
declare void @args_out_of_range(i64, i64) #4

declare void @set_buffer_internal_1(%struct.buffer*) #1

declare void @insert_from_buffer(%struct.buffer*, i64, i64, i1 zeroext) #1

; Function Attrs: nounwind uwtable
define i64 @Fcompare_buffer_substrings(i64 %buffer1, i64 %start1, i64 %end1, i64 %buffer2, i64 %start2, i64 %end2) #0 {
entry:
  %retval = alloca i64, align 8
  %buffer1.addr = alloca i64, align 8
  %start1.addr = alloca i64, align 8
  %end1.addr = alloca i64, align 8
  %buffer2.addr = alloca i64, align 8
  %start2.addr = alloca i64, align 8
  %end2.addr = alloca i64, align 8
  %begp1 = alloca i64, align 8
  %endp1 = alloca i64, align 8
  %begp2 = alloca i64, align 8
  %endp2 = alloca i64, align 8
  %temp = alloca i64, align 8
  %bp1 = alloca %struct.buffer*, align 8
  %bp2 = alloca %struct.buffer*, align 8
  %trt = alloca i64, align 8
  %chars = alloca i64, align 8
  %i1 = alloca i64, align 8
  %i2 = alloca i64, align 8
  %i1_byte = alloca i64, align 8
  %i2_byte = alloca i64, align 8
  %buf1 = alloca i64, align 8
  %buf2 = alloca i64, align 8
  %c1 = alloca i32, align 4
  %c2 = alloca i32, align 4
  %chp = alloca i8*, align 8
  %chp419 = alloca i8*, align 8
  store i64 %buffer1, i64* %buffer1.addr, align 8
  store i64 %start1, i64* %start1.addr, align 8
  store i64 %end1, i64* %end1.addr, align 8
  store i64 %buffer2, i64* %buffer2.addr, align 8
  store i64 %start2, i64* %start2.addr, align 8
  store i64 %end2, i64* %end2.addr, align 8
  %0 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %case_fold_search_ = getelementptr inbounds %struct.buffer, %struct.buffer* %0, i32 0, i32 18
  %1 = load i64, i64* %case_fold_search_, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %1, %call
  br i1 %cmp, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  %2 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %case_canon_table_ = getelementptr inbounds %struct.buffer, %struct.buffer* %2, i32 0, i32 25
  %3 = load i64, i64* %case_canon_table_, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %3, %cond.true ], [ %call1, %cond.false ]
  store i64 %cond, i64* %trt, align 8
  store i64 0, i64* %chars, align 8
  %4 = load i64, i64* %buffer1.addr, align 8
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp3 = icmp eq i64 %4, %call2
  br i1 %cmp3, label %if.then, label %if.else

if.then:                                          ; preds = %cond.end
  %5 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  store %struct.buffer* %5, %struct.buffer** %bp1, align 8
  br label %if.end.13

if.else:                                          ; preds = %cond.end
  %6 = load i64, i64* %buffer1.addr, align 8
  %call4 = call i64 @Fget_buffer(i64 %6)
  store i64 %call4, i64* %buf1, align 8
  %7 = load i64, i64* %buf1, align 8
  %call5 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp6 = icmp eq i64 %7, %call5
  br i1 %cmp6, label %if.then.7, label %if.end

if.then.7:                                        ; preds = %if.else
  %8 = load i64, i64* %buffer1.addr, align 8
  call void @nsberror(i64 %8) #9
  unreachable

if.end:                                           ; preds = %if.else
  %9 = load i64, i64* %buf1, align 8
  %call8 = call %struct.buffer* @XBUFFER(i64 %9)
  store %struct.buffer* %call8, %struct.buffer** %bp1, align 8
  %10 = load %struct.buffer*, %struct.buffer** %bp1, align 8
  %name_ = getelementptr inbounds %struct.buffer, %struct.buffer* %10, i32 0, i32 1
  %11 = load i64, i64* %name_, align 8
  %call9 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp10 = icmp eq i64 %11, %call9
  br i1 %cmp10, label %if.then.11, label %if.end.12

if.then.11:                                       ; preds = %if.end
  call void (i8*, ...) @error(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.11, i32 0, i32 0)) #9
  unreachable

if.end.12:                                        ; preds = %if.end
  br label %if.end.13

if.end.13:                                        ; preds = %if.end.12, %if.then
  %12 = load i64, i64* %start1.addr, align 8
  %call14 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp15 = icmp eq i64 %12, %call14
  br i1 %cmp15, label %if.then.16, label %if.else.31

if.then.16:                                       ; preds = %if.end.13
  %13 = load %struct.buffer*, %struct.buffer** %bp1, align 8
  %14 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %cmp17 = icmp eq %struct.buffer* %13, %14
  br i1 %cmp17, label %cond.true.18, label %cond.false.19

cond.true.18:                                     ; preds = %if.then.16
  %15 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv = getelementptr inbounds %struct.buffer, %struct.buffer* %15, i32 0, i32 77
  %16 = load i64, i64* %begv, align 8
  br label %cond.end.29

cond.false.19:                                    ; preds = %if.then.16
  %17 = load %struct.buffer*, %struct.buffer** %bp1, align 8
  %begv_marker_ = getelementptr inbounds %struct.buffer, %struct.buffer* %17, i32 0, i32 46
  %18 = load i64, i64* %begv_marker_, align 8
  %call20 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp21 = icmp eq i64 %18, %call20
  br i1 %cmp21, label %cond.true.22, label %cond.false.24

cond.true.22:                                     ; preds = %cond.false.19
  %19 = load %struct.buffer*, %struct.buffer** %bp1, align 8
  %begv23 = getelementptr inbounds %struct.buffer, %struct.buffer* %19, i32 0, i32 77
  %20 = load i64, i64* %begv23, align 8
  br label %cond.end.27

cond.false.24:                                    ; preds = %cond.false.19
  %21 = load %struct.buffer*, %struct.buffer** %bp1, align 8
  %begv_marker_25 = getelementptr inbounds %struct.buffer, %struct.buffer* %21, i32 0, i32 46
  %22 = load i64, i64* %begv_marker_25, align 8
  %call26 = call i64 @marker_position(i64 %22)
  br label %cond.end.27

cond.end.27:                                      ; preds = %cond.false.24, %cond.true.22
  %cond28 = phi i64 [ %20, %cond.true.22 ], [ %call26, %cond.false.24 ]
  br label %cond.end.29

cond.end.29:                                      ; preds = %cond.end.27, %cond.true.18
  %cond30 = phi i64 [ %16, %cond.true.18 ], [ %cond28, %cond.end.27 ]
  store i64 %cond30, i64* %begp1, align 8
  br label %if.end.51

if.else.31:                                       ; preds = %if.end.13
  br label %do.body

do.body:                                          ; preds = %if.else.31
  %23 = load i64, i64* %start1.addr, align 8
  %and = and i64 %23, 7
  %conv = trunc i64 %and to i32
  %cmp32 = icmp eq i32 %conv, 1
  br i1 %cmp32, label %land.lhs.true, label %if.else.40

land.lhs.true:                                    ; preds = %do.body
  %24 = load i64, i64* %start1.addr, align 8
  %call34 = call i32 @XMISCTYPE(i64 %24)
  %cmp35 = icmp eq i32 %call34, 24236
  br i1 %cmp35, label %if.then.37, label %if.else.40

if.then.37:                                       ; preds = %land.lhs.true
  %25 = load i64, i64* %start1.addr, align 8
  %call38 = call i64 @marker_position(i64 %25)
  %call39 = call i64 @make_natnum(i64 %call38)
  store i64 %call39, i64* %start1.addr, align 8
  br label %if.end.50

if.else.40:                                       ; preds = %land.lhs.true, %do.body
  %26 = load i64, i64* %start1.addr, align 8
  %and41 = and i64 %26, 7
  %conv42 = trunc i64 %and41 to i32
  %and43 = and i32 %conv42, -5
  %cmp44 = icmp eq i32 %and43, 2
  br i1 %cmp44, label %cond.true.46, label %cond.false.47

cond.true.46:                                     ; preds = %if.else.40
  br label %cond.end.49

cond.false.47:                                    ; preds = %if.else.40
  %call48 = call i64 @builtin_lisp_symbol(i32 558)
  %27 = load i64, i64* %start1.addr, align 8
  %28 = call i64 @wrong_type_argument(i64 %call48, i64 %27) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end.49

cond.end.49:                                      ; preds = %29, %cond.true.46
  br label %if.end.50

if.end.50:                                        ; preds = %cond.end.49, %if.then.37
  br label %do.end

do.end:                                           ; preds = %if.end.50
  %30 = load i64, i64* %start1.addr, align 8
  %shr = ashr i64 %30, 2
  store i64 %shr, i64* %begp1, align 8
  br label %if.end.51

if.end.51:                                        ; preds = %do.end, %cond.end.29
  %31 = load i64, i64* %end1.addr, align 8
  %call52 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp53 = icmp eq i64 %31, %call52
  br i1 %cmp53, label %if.then.55, label %if.else.72

if.then.55:                                       ; preds = %if.end.51
  %32 = load %struct.buffer*, %struct.buffer** %bp1, align 8
  %33 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %cmp56 = icmp eq %struct.buffer* %32, %33
  br i1 %cmp56, label %cond.true.58, label %cond.false.59

cond.true.58:                                     ; preds = %if.then.55
  %34 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv = getelementptr inbounds %struct.buffer, %struct.buffer* %34, i32 0, i32 79
  %35 = load i64, i64* %zv, align 8
  br label %cond.end.70

cond.false.59:                                    ; preds = %if.then.55
  %36 = load %struct.buffer*, %struct.buffer** %bp1, align 8
  %zv_marker_ = getelementptr inbounds %struct.buffer, %struct.buffer* %36, i32 0, i32 47
  %37 = load i64, i64* %zv_marker_, align 8
  %call60 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp61 = icmp eq i64 %37, %call60
  br i1 %cmp61, label %cond.true.63, label %cond.false.65

cond.true.63:                                     ; preds = %cond.false.59
  %38 = load %struct.buffer*, %struct.buffer** %bp1, align 8
  %zv64 = getelementptr inbounds %struct.buffer, %struct.buffer* %38, i32 0, i32 79
  %39 = load i64, i64* %zv64, align 8
  br label %cond.end.68

cond.false.65:                                    ; preds = %cond.false.59
  %40 = load %struct.buffer*, %struct.buffer** %bp1, align 8
  %zv_marker_66 = getelementptr inbounds %struct.buffer, %struct.buffer* %40, i32 0, i32 47
  %41 = load i64, i64* %zv_marker_66, align 8
  %call67 = call i64 @marker_position(i64 %41)
  br label %cond.end.68

cond.end.68:                                      ; preds = %cond.false.65, %cond.true.63
  %cond69 = phi i64 [ %39, %cond.true.63 ], [ %call67, %cond.false.65 ]
  br label %cond.end.70

cond.end.70:                                      ; preds = %cond.end.68, %cond.true.58
  %cond71 = phi i64 [ %35, %cond.true.58 ], [ %cond69, %cond.end.68 ]
  store i64 %cond71, i64* %endp1, align 8
  br label %if.end.98

if.else.72:                                       ; preds = %if.end.51
  br label %do.body.73

do.body.73:                                       ; preds = %if.else.72
  %42 = load i64, i64* %end1.addr, align 8
  %and74 = and i64 %42, 7
  %conv75 = trunc i64 %and74 to i32
  %cmp76 = icmp eq i32 %conv75, 1
  br i1 %cmp76, label %land.lhs.true.78, label %if.else.85

land.lhs.true.78:                                 ; preds = %do.body.73
  %43 = load i64, i64* %end1.addr, align 8
  %call79 = call i32 @XMISCTYPE(i64 %43)
  %cmp80 = icmp eq i32 %call79, 24236
  br i1 %cmp80, label %if.then.82, label %if.else.85

if.then.82:                                       ; preds = %land.lhs.true.78
  %44 = load i64, i64* %end1.addr, align 8
  %call83 = call i64 @marker_position(i64 %44)
  %call84 = call i64 @make_natnum(i64 %call83)
  store i64 %call84, i64* %end1.addr, align 8
  br label %if.end.95

if.else.85:                                       ; preds = %land.lhs.true.78, %do.body.73
  %45 = load i64, i64* %end1.addr, align 8
  %and86 = and i64 %45, 7
  %conv87 = trunc i64 %and86 to i32
  %and88 = and i32 %conv87, -5
  %cmp89 = icmp eq i32 %and88, 2
  br i1 %cmp89, label %cond.true.91, label %cond.false.92

cond.true.91:                                     ; preds = %if.else.85
  br label %cond.end.94

cond.false.92:                                    ; preds = %if.else.85
  %call93 = call i64 @builtin_lisp_symbol(i32 558)
  %46 = load i64, i64* %end1.addr, align 8
  %47 = call i64 @wrong_type_argument(i64 %call93, i64 %46) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end.94

cond.end.94:                                      ; preds = %48, %cond.true.91
  br label %if.end.95

if.end.95:                                        ; preds = %cond.end.94, %if.then.82
  br label %do.end.96

do.end.96:                                        ; preds = %if.end.95
  %49 = load i64, i64* %end1.addr, align 8
  %shr97 = ashr i64 %49, 2
  store i64 %shr97, i64* %endp1, align 8
  br label %if.end.98

if.end.98:                                        ; preds = %do.end.96, %cond.end.70
  %50 = load i64, i64* %begp1, align 8
  %51 = load i64, i64* %endp1, align 8
  %cmp99 = icmp sgt i64 %50, %51
  br i1 %cmp99, label %if.then.101, label %if.end.102

if.then.101:                                      ; preds = %if.end.98
  %52 = load i64, i64* %begp1, align 8
  store i64 %52, i64* %temp, align 8
  %53 = load i64, i64* %endp1, align 8
  store i64 %53, i64* %begp1, align 8
  %54 = load i64, i64* %temp, align 8
  store i64 %54, i64* %endp1, align 8
  br label %if.end.102

if.end.102:                                       ; preds = %if.then.101, %if.end.98
  %55 = load %struct.buffer*, %struct.buffer** %bp1, align 8
  %56 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %cmp103 = icmp eq %struct.buffer* %55, %56
  br i1 %cmp103, label %cond.true.105, label %cond.false.107

cond.true.105:                                    ; preds = %if.end.102
  %57 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv106 = getelementptr inbounds %struct.buffer, %struct.buffer* %57, i32 0, i32 77
  %58 = load i64, i64* %begv106, align 8
  br label %cond.end.119

cond.false.107:                                   ; preds = %if.end.102
  %59 = load %struct.buffer*, %struct.buffer** %bp1, align 8
  %begv_marker_108 = getelementptr inbounds %struct.buffer, %struct.buffer* %59, i32 0, i32 46
  %60 = load i64, i64* %begv_marker_108, align 8
  %call109 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp110 = icmp eq i64 %60, %call109
  br i1 %cmp110, label %cond.true.112, label %cond.false.114

cond.true.112:                                    ; preds = %cond.false.107
  %61 = load %struct.buffer*, %struct.buffer** %bp1, align 8
  %begv113 = getelementptr inbounds %struct.buffer, %struct.buffer* %61, i32 0, i32 77
  %62 = load i64, i64* %begv113, align 8
  br label %cond.end.117

cond.false.114:                                   ; preds = %cond.false.107
  %63 = load %struct.buffer*, %struct.buffer** %bp1, align 8
  %begv_marker_115 = getelementptr inbounds %struct.buffer, %struct.buffer* %63, i32 0, i32 46
  %64 = load i64, i64* %begv_marker_115, align 8
  %call116 = call i64 @marker_position(i64 %64)
  br label %cond.end.117

cond.end.117:                                     ; preds = %cond.false.114, %cond.true.112
  %cond118 = phi i64 [ %62, %cond.true.112 ], [ %call116, %cond.false.114 ]
  br label %cond.end.119

cond.end.119:                                     ; preds = %cond.end.117, %cond.true.105
  %cond120 = phi i64 [ %58, %cond.true.105 ], [ %cond118, %cond.end.117 ]
  %65 = load i64, i64* %begp1, align 8
  %cmp121 = icmp sle i64 %cond120, %65
  br i1 %cmp121, label %land.lhs.true.123, label %if.then.147

land.lhs.true.123:                                ; preds = %cond.end.119
  %66 = load i64, i64* %begp1, align 8
  %67 = load i64, i64* %endp1, align 8
  %cmp124 = icmp sle i64 %66, %67
  br i1 %cmp124, label %land.lhs.true.126, label %if.then.147

land.lhs.true.126:                                ; preds = %land.lhs.true.123
  %68 = load i64, i64* %endp1, align 8
  %69 = load %struct.buffer*, %struct.buffer** %bp1, align 8
  %70 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %cmp127 = icmp eq %struct.buffer* %69, %70
  br i1 %cmp127, label %cond.true.129, label %cond.false.131

cond.true.129:                                    ; preds = %land.lhs.true.126
  %71 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv130 = getelementptr inbounds %struct.buffer, %struct.buffer* %71, i32 0, i32 79
  %72 = load i64, i64* %zv130, align 8
  br label %cond.end.143

cond.false.131:                                   ; preds = %land.lhs.true.126
  %73 = load %struct.buffer*, %struct.buffer** %bp1, align 8
  %zv_marker_132 = getelementptr inbounds %struct.buffer, %struct.buffer* %73, i32 0, i32 47
  %74 = load i64, i64* %zv_marker_132, align 8
  %call133 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp134 = icmp eq i64 %74, %call133
  br i1 %cmp134, label %cond.true.136, label %cond.false.138

cond.true.136:                                    ; preds = %cond.false.131
  %75 = load %struct.buffer*, %struct.buffer** %bp1, align 8
  %zv137 = getelementptr inbounds %struct.buffer, %struct.buffer* %75, i32 0, i32 79
  %76 = load i64, i64* %zv137, align 8
  br label %cond.end.141

cond.false.138:                                   ; preds = %cond.false.131
  %77 = load %struct.buffer*, %struct.buffer** %bp1, align 8
  %zv_marker_139 = getelementptr inbounds %struct.buffer, %struct.buffer* %77, i32 0, i32 47
  %78 = load i64, i64* %zv_marker_139, align 8
  %call140 = call i64 @marker_position(i64 %78)
  br label %cond.end.141

cond.end.141:                                     ; preds = %cond.false.138, %cond.true.136
  %cond142 = phi i64 [ %76, %cond.true.136 ], [ %call140, %cond.false.138 ]
  br label %cond.end.143

cond.end.143:                                     ; preds = %cond.end.141, %cond.true.129
  %cond144 = phi i64 [ %72, %cond.true.129 ], [ %cond142, %cond.end.141 ]
  %cmp145 = icmp sle i64 %68, %cond144
  br i1 %cmp145, label %if.end.148, label %if.then.147

if.then.147:                                      ; preds = %cond.end.143, %land.lhs.true.123, %cond.end.119
  %79 = load i64, i64* %start1.addr, align 8
  %80 = load i64, i64* %end1.addr, align 8
  call void @args_out_of_range(i64 %79, i64 %80) #9
  unreachable

if.end.148:                                       ; preds = %cond.end.143
  %81 = load i64, i64* %buffer2.addr, align 8
  %call149 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp150 = icmp eq i64 %81, %call149
  br i1 %cmp150, label %if.then.152, label %if.else.153

if.then.152:                                      ; preds = %if.end.148
  %82 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  store %struct.buffer* %82, %struct.buffer** %bp2, align 8
  br label %if.end.167

if.else.153:                                      ; preds = %if.end.148
  %83 = load i64, i64* %buffer2.addr, align 8
  %call154 = call i64 @Fget_buffer(i64 %83)
  store i64 %call154, i64* %buf2, align 8
  %84 = load i64, i64* %buf2, align 8
  %call155 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp156 = icmp eq i64 %84, %call155
  br i1 %cmp156, label %if.then.158, label %if.end.159

if.then.158:                                      ; preds = %if.else.153
  %85 = load i64, i64* %buffer2.addr, align 8
  call void @nsberror(i64 %85) #9
  unreachable

if.end.159:                                       ; preds = %if.else.153
  %86 = load i64, i64* %buf2, align 8
  %call160 = call %struct.buffer* @XBUFFER(i64 %86)
  store %struct.buffer* %call160, %struct.buffer** %bp2, align 8
  %87 = load %struct.buffer*, %struct.buffer** %bp2, align 8
  %name_161 = getelementptr inbounds %struct.buffer, %struct.buffer* %87, i32 0, i32 1
  %88 = load i64, i64* %name_161, align 8
  %call162 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp163 = icmp eq i64 %88, %call162
  br i1 %cmp163, label %if.then.165, label %if.end.166

if.then.165:                                      ; preds = %if.end.159
  call void (i8*, ...) @error(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.11, i32 0, i32 0)) #9
  unreachable

if.end.166:                                       ; preds = %if.end.159
  br label %if.end.167

if.end.167:                                       ; preds = %if.end.166, %if.then.152
  %89 = load i64, i64* %start2.addr, align 8
  %call168 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp169 = icmp eq i64 %89, %call168
  br i1 %cmp169, label %if.then.171, label %if.else.190

if.then.171:                                      ; preds = %if.end.167
  %90 = load %struct.buffer*, %struct.buffer** %bp2, align 8
  %91 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %cmp172 = icmp eq %struct.buffer* %90, %91
  br i1 %cmp172, label %cond.true.174, label %cond.false.176

cond.true.174:                                    ; preds = %if.then.171
  %92 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv175 = getelementptr inbounds %struct.buffer, %struct.buffer* %92, i32 0, i32 77
  %93 = load i64, i64* %begv175, align 8
  br label %cond.end.188

cond.false.176:                                   ; preds = %if.then.171
  %94 = load %struct.buffer*, %struct.buffer** %bp2, align 8
  %begv_marker_177 = getelementptr inbounds %struct.buffer, %struct.buffer* %94, i32 0, i32 46
  %95 = load i64, i64* %begv_marker_177, align 8
  %call178 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp179 = icmp eq i64 %95, %call178
  br i1 %cmp179, label %cond.true.181, label %cond.false.183

cond.true.181:                                    ; preds = %cond.false.176
  %96 = load %struct.buffer*, %struct.buffer** %bp2, align 8
  %begv182 = getelementptr inbounds %struct.buffer, %struct.buffer* %96, i32 0, i32 77
  %97 = load i64, i64* %begv182, align 8
  br label %cond.end.186

cond.false.183:                                   ; preds = %cond.false.176
  %98 = load %struct.buffer*, %struct.buffer** %bp2, align 8
  %begv_marker_184 = getelementptr inbounds %struct.buffer, %struct.buffer* %98, i32 0, i32 46
  %99 = load i64, i64* %begv_marker_184, align 8
  %call185 = call i64 @marker_position(i64 %99)
  br label %cond.end.186

cond.end.186:                                     ; preds = %cond.false.183, %cond.true.181
  %cond187 = phi i64 [ %97, %cond.true.181 ], [ %call185, %cond.false.183 ]
  br label %cond.end.188

cond.end.188:                                     ; preds = %cond.end.186, %cond.true.174
  %cond189 = phi i64 [ %93, %cond.true.174 ], [ %cond187, %cond.end.186 ]
  store i64 %cond189, i64* %begp2, align 8
  br label %if.end.216

if.else.190:                                      ; preds = %if.end.167
  br label %do.body.191

do.body.191:                                      ; preds = %if.else.190
  %100 = load i64, i64* %start2.addr, align 8
  %and192 = and i64 %100, 7
  %conv193 = trunc i64 %and192 to i32
  %cmp194 = icmp eq i32 %conv193, 1
  br i1 %cmp194, label %land.lhs.true.196, label %if.else.203

land.lhs.true.196:                                ; preds = %do.body.191
  %101 = load i64, i64* %start2.addr, align 8
  %call197 = call i32 @XMISCTYPE(i64 %101)
  %cmp198 = icmp eq i32 %call197, 24236
  br i1 %cmp198, label %if.then.200, label %if.else.203

if.then.200:                                      ; preds = %land.lhs.true.196
  %102 = load i64, i64* %start2.addr, align 8
  %call201 = call i64 @marker_position(i64 %102)
  %call202 = call i64 @make_natnum(i64 %call201)
  store i64 %call202, i64* %start2.addr, align 8
  br label %if.end.213

if.else.203:                                      ; preds = %land.lhs.true.196, %do.body.191
  %103 = load i64, i64* %start2.addr, align 8
  %and204 = and i64 %103, 7
  %conv205 = trunc i64 %and204 to i32
  %and206 = and i32 %conv205, -5
  %cmp207 = icmp eq i32 %and206, 2
  br i1 %cmp207, label %cond.true.209, label %cond.false.210

cond.true.209:                                    ; preds = %if.else.203
  br label %cond.end.212

cond.false.210:                                   ; preds = %if.else.203
  %call211 = call i64 @builtin_lisp_symbol(i32 558)
  %104 = load i64, i64* %start2.addr, align 8
  %105 = call i64 @wrong_type_argument(i64 %call211, i64 %104) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end.212

cond.end.212:                                     ; preds = %106, %cond.true.209
  br label %if.end.213

if.end.213:                                       ; preds = %cond.end.212, %if.then.200
  br label %do.end.214

do.end.214:                                       ; preds = %if.end.213
  %107 = load i64, i64* %start2.addr, align 8
  %shr215 = ashr i64 %107, 2
  store i64 %shr215, i64* %begp2, align 8
  br label %if.end.216

if.end.216:                                       ; preds = %do.end.214, %cond.end.188
  %108 = load i64, i64* %end2.addr, align 8
  %call217 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp218 = icmp eq i64 %108, %call217
  br i1 %cmp218, label %if.then.220, label %if.else.239

if.then.220:                                      ; preds = %if.end.216
  %109 = load %struct.buffer*, %struct.buffer** %bp2, align 8
  %110 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %cmp221 = icmp eq %struct.buffer* %109, %110
  br i1 %cmp221, label %cond.true.223, label %cond.false.225

cond.true.223:                                    ; preds = %if.then.220
  %111 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv224 = getelementptr inbounds %struct.buffer, %struct.buffer* %111, i32 0, i32 79
  %112 = load i64, i64* %zv224, align 8
  br label %cond.end.237

cond.false.225:                                   ; preds = %if.then.220
  %113 = load %struct.buffer*, %struct.buffer** %bp2, align 8
  %zv_marker_226 = getelementptr inbounds %struct.buffer, %struct.buffer* %113, i32 0, i32 47
  %114 = load i64, i64* %zv_marker_226, align 8
  %call227 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp228 = icmp eq i64 %114, %call227
  br i1 %cmp228, label %cond.true.230, label %cond.false.232

cond.true.230:                                    ; preds = %cond.false.225
  %115 = load %struct.buffer*, %struct.buffer** %bp2, align 8
  %zv231 = getelementptr inbounds %struct.buffer, %struct.buffer* %115, i32 0, i32 79
  %116 = load i64, i64* %zv231, align 8
  br label %cond.end.235

cond.false.232:                                   ; preds = %cond.false.225
  %117 = load %struct.buffer*, %struct.buffer** %bp2, align 8
  %zv_marker_233 = getelementptr inbounds %struct.buffer, %struct.buffer* %117, i32 0, i32 47
  %118 = load i64, i64* %zv_marker_233, align 8
  %call234 = call i64 @marker_position(i64 %118)
  br label %cond.end.235

cond.end.235:                                     ; preds = %cond.false.232, %cond.true.230
  %cond236 = phi i64 [ %116, %cond.true.230 ], [ %call234, %cond.false.232 ]
  br label %cond.end.237

cond.end.237:                                     ; preds = %cond.end.235, %cond.true.223
  %cond238 = phi i64 [ %112, %cond.true.223 ], [ %cond236, %cond.end.235 ]
  store i64 %cond238, i64* %endp2, align 8
  br label %if.end.265

if.else.239:                                      ; preds = %if.end.216
  br label %do.body.240

do.body.240:                                      ; preds = %if.else.239
  %119 = load i64, i64* %end2.addr, align 8
  %and241 = and i64 %119, 7
  %conv242 = trunc i64 %and241 to i32
  %cmp243 = icmp eq i32 %conv242, 1
  br i1 %cmp243, label %land.lhs.true.245, label %if.else.252

land.lhs.true.245:                                ; preds = %do.body.240
  %120 = load i64, i64* %end2.addr, align 8
  %call246 = call i32 @XMISCTYPE(i64 %120)
  %cmp247 = icmp eq i32 %call246, 24236
  br i1 %cmp247, label %if.then.249, label %if.else.252

if.then.249:                                      ; preds = %land.lhs.true.245
  %121 = load i64, i64* %end2.addr, align 8
  %call250 = call i64 @marker_position(i64 %121)
  %call251 = call i64 @make_natnum(i64 %call250)
  store i64 %call251, i64* %end2.addr, align 8
  br label %if.end.262

if.else.252:                                      ; preds = %land.lhs.true.245, %do.body.240
  %122 = load i64, i64* %end2.addr, align 8
  %and253 = and i64 %122, 7
  %conv254 = trunc i64 %and253 to i32
  %and255 = and i32 %conv254, -5
  %cmp256 = icmp eq i32 %and255, 2
  br i1 %cmp256, label %cond.true.258, label %cond.false.259

cond.true.258:                                    ; preds = %if.else.252
  br label %cond.end.261

cond.false.259:                                   ; preds = %if.else.252
  %call260 = call i64 @builtin_lisp_symbol(i32 558)
  %123 = load i64, i64* %end2.addr, align 8
  %124 = call i64 @wrong_type_argument(i64 %call260, i64 %123) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end.261

cond.end.261:                                     ; preds = %125, %cond.true.258
  br label %if.end.262

if.end.262:                                       ; preds = %cond.end.261, %if.then.249
  br label %do.end.263

do.end.263:                                       ; preds = %if.end.262
  %126 = load i64, i64* %end2.addr, align 8
  %shr264 = ashr i64 %126, 2
  store i64 %shr264, i64* %endp2, align 8
  br label %if.end.265

if.end.265:                                       ; preds = %do.end.263, %cond.end.237
  %127 = load i64, i64* %begp2, align 8
  %128 = load i64, i64* %endp2, align 8
  %cmp266 = icmp sgt i64 %127, %128
  br i1 %cmp266, label %if.then.268, label %if.end.269

if.then.268:                                      ; preds = %if.end.265
  %129 = load i64, i64* %begp2, align 8
  store i64 %129, i64* %temp, align 8
  %130 = load i64, i64* %endp2, align 8
  store i64 %130, i64* %begp2, align 8
  %131 = load i64, i64* %temp, align 8
  store i64 %131, i64* %endp2, align 8
  br label %if.end.269

if.end.269:                                       ; preds = %if.then.268, %if.end.265
  %132 = load %struct.buffer*, %struct.buffer** %bp2, align 8
  %133 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %cmp270 = icmp eq %struct.buffer* %132, %133
  br i1 %cmp270, label %cond.true.272, label %cond.false.274

cond.true.272:                                    ; preds = %if.end.269
  %134 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv273 = getelementptr inbounds %struct.buffer, %struct.buffer* %134, i32 0, i32 77
  %135 = load i64, i64* %begv273, align 8
  br label %cond.end.286

cond.false.274:                                   ; preds = %if.end.269
  %136 = load %struct.buffer*, %struct.buffer** %bp2, align 8
  %begv_marker_275 = getelementptr inbounds %struct.buffer, %struct.buffer* %136, i32 0, i32 46
  %137 = load i64, i64* %begv_marker_275, align 8
  %call276 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp277 = icmp eq i64 %137, %call276
  br i1 %cmp277, label %cond.true.279, label %cond.false.281

cond.true.279:                                    ; preds = %cond.false.274
  %138 = load %struct.buffer*, %struct.buffer** %bp2, align 8
  %begv280 = getelementptr inbounds %struct.buffer, %struct.buffer* %138, i32 0, i32 77
  %139 = load i64, i64* %begv280, align 8
  br label %cond.end.284

cond.false.281:                                   ; preds = %cond.false.274
  %140 = load %struct.buffer*, %struct.buffer** %bp2, align 8
  %begv_marker_282 = getelementptr inbounds %struct.buffer, %struct.buffer* %140, i32 0, i32 46
  %141 = load i64, i64* %begv_marker_282, align 8
  %call283 = call i64 @marker_position(i64 %141)
  br label %cond.end.284

cond.end.284:                                     ; preds = %cond.false.281, %cond.true.279
  %cond285 = phi i64 [ %139, %cond.true.279 ], [ %call283, %cond.false.281 ]
  br label %cond.end.286

cond.end.286:                                     ; preds = %cond.end.284, %cond.true.272
  %cond287 = phi i64 [ %135, %cond.true.272 ], [ %cond285, %cond.end.284 ]
  %142 = load i64, i64* %begp2, align 8
  %cmp288 = icmp sle i64 %cond287, %142
  br i1 %cmp288, label %land.lhs.true.290, label %if.then.314

land.lhs.true.290:                                ; preds = %cond.end.286
  %143 = load i64, i64* %begp2, align 8
  %144 = load i64, i64* %endp2, align 8
  %cmp291 = icmp sle i64 %143, %144
  br i1 %cmp291, label %land.lhs.true.293, label %if.then.314

land.lhs.true.293:                                ; preds = %land.lhs.true.290
  %145 = load i64, i64* %endp2, align 8
  %146 = load %struct.buffer*, %struct.buffer** %bp2, align 8
  %147 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %cmp294 = icmp eq %struct.buffer* %146, %147
  br i1 %cmp294, label %cond.true.296, label %cond.false.298

cond.true.296:                                    ; preds = %land.lhs.true.293
  %148 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv297 = getelementptr inbounds %struct.buffer, %struct.buffer* %148, i32 0, i32 79
  %149 = load i64, i64* %zv297, align 8
  br label %cond.end.310

cond.false.298:                                   ; preds = %land.lhs.true.293
  %150 = load %struct.buffer*, %struct.buffer** %bp2, align 8
  %zv_marker_299 = getelementptr inbounds %struct.buffer, %struct.buffer* %150, i32 0, i32 47
  %151 = load i64, i64* %zv_marker_299, align 8
  %call300 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp301 = icmp eq i64 %151, %call300
  br i1 %cmp301, label %cond.true.303, label %cond.false.305

cond.true.303:                                    ; preds = %cond.false.298
  %152 = load %struct.buffer*, %struct.buffer** %bp2, align 8
  %zv304 = getelementptr inbounds %struct.buffer, %struct.buffer* %152, i32 0, i32 79
  %153 = load i64, i64* %zv304, align 8
  br label %cond.end.308

cond.false.305:                                   ; preds = %cond.false.298
  %154 = load %struct.buffer*, %struct.buffer** %bp2, align 8
  %zv_marker_306 = getelementptr inbounds %struct.buffer, %struct.buffer* %154, i32 0, i32 47
  %155 = load i64, i64* %zv_marker_306, align 8
  %call307 = call i64 @marker_position(i64 %155)
  br label %cond.end.308

cond.end.308:                                     ; preds = %cond.false.305, %cond.true.303
  %cond309 = phi i64 [ %153, %cond.true.303 ], [ %call307, %cond.false.305 ]
  br label %cond.end.310

cond.end.310:                                     ; preds = %cond.end.308, %cond.true.296
  %cond311 = phi i64 [ %149, %cond.true.296 ], [ %cond309, %cond.end.308 ]
  %cmp312 = icmp sle i64 %145, %cond311
  br i1 %cmp312, label %if.end.315, label %if.then.314

if.then.314:                                      ; preds = %cond.end.310, %land.lhs.true.290, %cond.end.286
  %156 = load i64, i64* %start2.addr, align 8
  %157 = load i64, i64* %end2.addr, align 8
  call void @args_out_of_range(i64 %156, i64 %157) #9
  unreachable

if.end.315:                                       ; preds = %cond.end.310
  %158 = load i64, i64* %begp1, align 8
  store i64 %158, i64* %i1, align 8
  %159 = load i64, i64* %begp2, align 8
  store i64 %159, i64* %i2, align 8
  %160 = load %struct.buffer*, %struct.buffer** %bp1, align 8
  %161 = load i64, i64* %i1, align 8
  %call316 = call i64 @buf_charpos_to_bytepos(%struct.buffer* %160, i64 %161)
  store i64 %call316, i64* %i1_byte, align 8
  %162 = load %struct.buffer*, %struct.buffer** %bp2, align 8
  %163 = load i64, i64* %i2, align 8
  %call317 = call i64 @buf_charpos_to_bytepos(%struct.buffer* %162, i64 %163)
  store i64 %call317, i64* %i2_byte, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end.516, %if.end.315
  %164 = load i64, i64* %i1, align 8
  %165 = load i64, i64* %endp1, align 8
  %cmp318 = icmp slt i64 %164, %165
  br i1 %cmp318, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %166 = load i64, i64* %i2, align 8
  %167 = load i64, i64* %endp2, align 8
  %cmp320 = icmp slt i64 %166, %167
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %168 = phi i1 [ false, %while.cond ], [ %cmp320, %land.rhs ]
  br i1 %168, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  br label %do.body.322

do.body.322:                                      ; preds = %while.body
  %169 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call323 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp324 = icmp eq i64 %169, %call323
  br i1 %cmp324, label %if.else.331, label %land.lhs.true.326

land.lhs.true.326:                                ; preds = %do.body.322
  %170 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  %call327 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp328 = icmp eq i64 %170, %call327
  br i1 %cmp328, label %if.then.330, label %if.else.331

if.then.330:                                      ; preds = %land.lhs.true.326
  call void @process_quit_flag()
  br label %if.end.334

if.else.331:                                      ; preds = %land.lhs.true.326, %do.body.322
  %171 = load volatile i8, i8* @pending_signals, align 1
  %tobool = trunc i8 %171 to i1
  br i1 %tobool, label %if.then.332, label %if.end.333

if.then.332:                                      ; preds = %if.else.331
  call void @process_pending_signals()
  br label %if.end.333

if.end.333:                                       ; preds = %if.then.332, %if.else.331
  br label %if.end.334

if.end.334:                                       ; preds = %if.end.333, %if.then.330
  br label %do.end.335

do.end.335:                                       ; preds = %if.end.334
  %172 = load %struct.buffer*, %struct.buffer** %bp1, align 8
  %enable_multibyte_characters_ = getelementptr inbounds %struct.buffer, %struct.buffer* %172, i32 0, i32 39
  %173 = load i64, i64* %enable_multibyte_characters_, align 8
  %call336 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp337 = icmp eq i64 %173, %call336
  br i1 %cmp337, label %if.else.379, label %if.then.339

if.then.339:                                      ; preds = %do.end.335
  %174 = load %struct.buffer*, %struct.buffer** %bp1, align 8
  %175 = load i64, i64* %i1_byte, align 8
  %call340 = call i32 @BUF_FETCH_MULTIBYTE_CHAR(%struct.buffer* %174, i64 %175)
  store i32 %call340, i32* %c1, align 4
  br label %do.body.341

do.body.341:                                      ; preds = %if.then.339
  %176 = load %struct.buffer*, %struct.buffer** %bp1, align 8
  %text = getelementptr inbounds %struct.buffer, %struct.buffer* %176, i32 0, i32 73
  %177 = load %struct.buffer_text*, %struct.buffer_text** %text, align 8
  %beg = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %177, i32 0, i32 0
  %178 = load i8*, i8** %beg, align 8
  %179 = load i64, i64* %i1_byte, align 8
  %add.ptr = getelementptr inbounds i8, i8* %178, i64 %179
  %add.ptr342 = getelementptr inbounds i8, i8* %add.ptr, i64 -1
  %180 = load i64, i64* %i1_byte, align 8
  %181 = load %struct.buffer*, %struct.buffer** %bp1, align 8
  %text343 = getelementptr inbounds %struct.buffer, %struct.buffer* %181, i32 0, i32 73
  %182 = load %struct.buffer_text*, %struct.buffer_text** %text343, align 8
  %gpt_byte = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %182, i32 0, i32 3
  %183 = load i64, i64* %gpt_byte, align 8
  %cmp344 = icmp sge i64 %180, %183
  br i1 %cmp344, label %cond.true.346, label %cond.false.348

cond.true.346:                                    ; preds = %do.body.341
  %184 = load %struct.buffer*, %struct.buffer** %bp1, align 8
  %text347 = getelementptr inbounds %struct.buffer, %struct.buffer* %184, i32 0, i32 73
  %185 = load %struct.buffer_text*, %struct.buffer_text** %text347, align 8
  %gap_size = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %185, i32 0, i32 5
  %186 = load i64, i64* %gap_size, align 8
  br label %cond.end.349

cond.false.348:                                   ; preds = %do.body.341
  br label %cond.end.349

cond.end.349:                                     ; preds = %cond.false.348, %cond.true.346
  %cond350 = phi i64 [ %186, %cond.true.346 ], [ 0, %cond.false.348 ]
  %add.ptr351 = getelementptr inbounds i8, i8* %add.ptr342, i64 %cond350
  store i8* %add.ptr351, i8** %chp, align 8
  %187 = load i8*, i8** %chp, align 8
  %188 = load i8, i8* %187, align 1
  %conv352 = zext i8 %188 to i32
  %and353 = and i32 %conv352, 128
  %tobool354 = icmp ne i32 %and353, 0
  br i1 %tobool354, label %cond.false.356, label %cond.true.355

cond.true.355:                                    ; preds = %cond.end.349
  br label %cond.end.375

cond.false.356:                                   ; preds = %cond.end.349
  %189 = load i8*, i8** %chp, align 8
  %190 = load i8, i8* %189, align 1
  %conv357 = zext i8 %190 to i32
  %and358 = and i32 %conv357, 32
  %tobool359 = icmp ne i32 %and358, 0
  br i1 %tobool359, label %cond.false.361, label %cond.true.360

cond.true.360:                                    ; preds = %cond.false.356
  br label %cond.end.373

cond.false.361:                                   ; preds = %cond.false.356
  %191 = load i8*, i8** %chp, align 8
  %192 = load i8, i8* %191, align 1
  %conv362 = zext i8 %192 to i32
  %and363 = and i32 %conv362, 16
  %tobool364 = icmp ne i32 %and363, 0
  br i1 %tobool364, label %cond.false.366, label %cond.true.365

cond.true.365:                                    ; preds = %cond.false.361
  br label %cond.end.371

cond.false.366:                                   ; preds = %cond.false.361
  %193 = load i8*, i8** %chp, align 8
  %194 = load i8, i8* %193, align 1
  %conv367 = zext i8 %194 to i32
  %and368 = and i32 %conv367, 8
  %tobool369 = icmp ne i32 %and368, 0
  %lnot = xor i1 %tobool369, true
  %cond370 = select i1 %lnot, i32 4, i32 5
  br label %cond.end.371

cond.end.371:                                     ; preds = %cond.false.366, %cond.true.365
  %cond372 = phi i32 [ 3, %cond.true.365 ], [ %cond370, %cond.false.366 ]
  br label %cond.end.373

cond.end.373:                                     ; preds = %cond.end.371, %cond.true.360
  %cond374 = phi i32 [ 2, %cond.true.360 ], [ %cond372, %cond.end.371 ]
  br label %cond.end.375

cond.end.375:                                     ; preds = %cond.end.373, %cond.true.355
  %cond376 = phi i32 [ 1, %cond.true.355 ], [ %cond374, %cond.end.373 ]
  %conv377 = sext i32 %cond376 to i64
  %195 = load i64, i64* %i1_byte, align 8
  %add = add nsw i64 %195, %conv377
  store i64 %add, i64* %i1_byte, align 8
  br label %do.end.378

do.end.378:                                       ; preds = %cond.end.375
  %196 = load i64, i64* %i1, align 8
  %inc = add nsw i64 %196, 1
  store i64 %inc, i64* %i1, align 8
  br label %if.end.411

if.else.379:                                      ; preds = %do.end.335
  %197 = load %struct.buffer*, %struct.buffer** %bp1, align 8
  %text380 = getelementptr inbounds %struct.buffer, %struct.buffer* %197, i32 0, i32 73
  %198 = load %struct.buffer_text*, %struct.buffer_text** %text380, align 8
  %beg381 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %198, i32 0, i32 0
  %199 = load i8*, i8** %beg381, align 8
  %200 = load i64, i64* %i1, align 8
  %add.ptr382 = getelementptr inbounds i8, i8* %199, i64 %200
  %add.ptr383 = getelementptr inbounds i8, i8* %add.ptr382, i64 -1
  %201 = load i64, i64* %i1, align 8
  %202 = load %struct.buffer*, %struct.buffer** %bp1, align 8
  %text384 = getelementptr inbounds %struct.buffer, %struct.buffer* %202, i32 0, i32 73
  %203 = load %struct.buffer_text*, %struct.buffer_text** %text384, align 8
  %gpt_byte385 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %203, i32 0, i32 3
  %204 = load i64, i64* %gpt_byte385, align 8
  %cmp386 = icmp sge i64 %201, %204
  br i1 %cmp386, label %cond.true.388, label %cond.false.391

cond.true.388:                                    ; preds = %if.else.379
  %205 = load %struct.buffer*, %struct.buffer** %bp1, align 8
  %text389 = getelementptr inbounds %struct.buffer, %struct.buffer* %205, i32 0, i32 73
  %206 = load %struct.buffer_text*, %struct.buffer_text** %text389, align 8
  %gap_size390 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %206, i32 0, i32 5
  %207 = load i64, i64* %gap_size390, align 8
  br label %cond.end.392

cond.false.391:                                   ; preds = %if.else.379
  br label %cond.end.392

cond.end.392:                                     ; preds = %cond.false.391, %cond.true.388
  %cond393 = phi i64 [ %207, %cond.true.388 ], [ 0, %cond.false.391 ]
  %add.ptr394 = getelementptr inbounds i8, i8* %add.ptr383, i64 %cond393
  %208 = load i8, i8* %add.ptr394, align 1
  %conv395 = zext i8 %208 to i32
  store i32 %conv395, i32* %c1, align 4
  br i1 true, label %cond.true.396, label %cond.false.400

cond.true.396:                                    ; preds = %cond.end.392
  %209 = load i32, i32* %c1, align 4
  %add397 = add i32 %209, 0
  %cmp398 = icmp ult i32 %add397, 128
  br i1 %cmp398, label %cond.true.405, label %cond.false.406

cond.false.400:                                   ; preds = %cond.end.392
  %210 = load i32, i32* %c1, align 4
  %conv401 = sext i32 %210 to i64
  %add402 = add i64 %conv401, 0
  %cmp403 = icmp ult i64 %add402, 128
  br i1 %cmp403, label %cond.true.405, label %cond.false.406

cond.true.405:                                    ; preds = %cond.false.400, %cond.true.396
  %211 = load i32, i32* %c1, align 4
  br label %cond.end.408

cond.false.406:                                   ; preds = %cond.false.400, %cond.true.396
  %212 = load i32, i32* %c1, align 4
  %add407 = add nsw i32 %212, 4194048
  br label %cond.end.408

cond.end.408:                                     ; preds = %cond.false.406, %cond.true.405
  %cond409 = phi i32 [ %211, %cond.true.405 ], [ %add407, %cond.false.406 ]
  store i32 %cond409, i32* %c1, align 4
  %213 = load i64, i64* %i1, align 8
  %inc410 = add nsw i64 %213, 1
  store i64 %inc410, i64* %i1, align 8
  br label %if.end.411

if.end.411:                                       ; preds = %cond.end.408, %do.end.378
  %214 = load %struct.buffer*, %struct.buffer** %bp2, align 8
  %enable_multibyte_characters_412 = getelementptr inbounds %struct.buffer, %struct.buffer* %214, i32 0, i32 39
  %215 = load i64, i64* %enable_multibyte_characters_412, align 8
  %call413 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp414 = icmp eq i64 %215, %call413
  br i1 %cmp414, label %if.else.465, label %if.then.416

if.then.416:                                      ; preds = %if.end.411
  %216 = load %struct.buffer*, %struct.buffer** %bp2, align 8
  %217 = load i64, i64* %i2_byte, align 8
  %call417 = call i32 @BUF_FETCH_MULTIBYTE_CHAR(%struct.buffer* %216, i64 %217)
  store i32 %call417, i32* %c2, align 4
  br label %do.body.418

do.body.418:                                      ; preds = %if.then.416
  %218 = load %struct.buffer*, %struct.buffer** %bp2, align 8
  %text420 = getelementptr inbounds %struct.buffer, %struct.buffer* %218, i32 0, i32 73
  %219 = load %struct.buffer_text*, %struct.buffer_text** %text420, align 8
  %beg421 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %219, i32 0, i32 0
  %220 = load i8*, i8** %beg421, align 8
  %221 = load i64, i64* %i2_byte, align 8
  %add.ptr422 = getelementptr inbounds i8, i8* %220, i64 %221
  %add.ptr423 = getelementptr inbounds i8, i8* %add.ptr422, i64 -1
  %222 = load i64, i64* %i2_byte, align 8
  %223 = load %struct.buffer*, %struct.buffer** %bp2, align 8
  %text424 = getelementptr inbounds %struct.buffer, %struct.buffer* %223, i32 0, i32 73
  %224 = load %struct.buffer_text*, %struct.buffer_text** %text424, align 8
  %gpt_byte425 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %224, i32 0, i32 3
  %225 = load i64, i64* %gpt_byte425, align 8
  %cmp426 = icmp sge i64 %222, %225
  br i1 %cmp426, label %cond.true.428, label %cond.false.431

cond.true.428:                                    ; preds = %do.body.418
  %226 = load %struct.buffer*, %struct.buffer** %bp2, align 8
  %text429 = getelementptr inbounds %struct.buffer, %struct.buffer* %226, i32 0, i32 73
  %227 = load %struct.buffer_text*, %struct.buffer_text** %text429, align 8
  %gap_size430 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %227, i32 0, i32 5
  %228 = load i64, i64* %gap_size430, align 8
  br label %cond.end.432

cond.false.431:                                   ; preds = %do.body.418
  br label %cond.end.432

cond.end.432:                                     ; preds = %cond.false.431, %cond.true.428
  %cond433 = phi i64 [ %228, %cond.true.428 ], [ 0, %cond.false.431 ]
  %add.ptr434 = getelementptr inbounds i8, i8* %add.ptr423, i64 %cond433
  store i8* %add.ptr434, i8** %chp419, align 8
  %229 = load i8*, i8** %chp419, align 8
  %230 = load i8, i8* %229, align 1
  %conv435 = zext i8 %230 to i32
  %and436 = and i32 %conv435, 128
  %tobool437 = icmp ne i32 %and436, 0
  br i1 %tobool437, label %cond.false.439, label %cond.true.438

cond.true.438:                                    ; preds = %cond.end.432
  br label %cond.end.459

cond.false.439:                                   ; preds = %cond.end.432
  %231 = load i8*, i8** %chp419, align 8
  %232 = load i8, i8* %231, align 1
  %conv440 = zext i8 %232 to i32
  %and441 = and i32 %conv440, 32
  %tobool442 = icmp ne i32 %and441, 0
  br i1 %tobool442, label %cond.false.444, label %cond.true.443

cond.true.443:                                    ; preds = %cond.false.439
  br label %cond.end.457

cond.false.444:                                   ; preds = %cond.false.439
  %233 = load i8*, i8** %chp419, align 8
  %234 = load i8, i8* %233, align 1
  %conv445 = zext i8 %234 to i32
  %and446 = and i32 %conv445, 16
  %tobool447 = icmp ne i32 %and446, 0
  br i1 %tobool447, label %cond.false.449, label %cond.true.448

cond.true.448:                                    ; preds = %cond.false.444
  br label %cond.end.455

cond.false.449:                                   ; preds = %cond.false.444
  %235 = load i8*, i8** %chp419, align 8
  %236 = load i8, i8* %235, align 1
  %conv450 = zext i8 %236 to i32
  %and451 = and i32 %conv450, 8
  %tobool452 = icmp ne i32 %and451, 0
  %lnot453 = xor i1 %tobool452, true
  %cond454 = select i1 %lnot453, i32 4, i32 5
  br label %cond.end.455

cond.end.455:                                     ; preds = %cond.false.449, %cond.true.448
  %cond456 = phi i32 [ 3, %cond.true.448 ], [ %cond454, %cond.false.449 ]
  br label %cond.end.457

cond.end.457:                                     ; preds = %cond.end.455, %cond.true.443
  %cond458 = phi i32 [ 2, %cond.true.443 ], [ %cond456, %cond.end.455 ]
  br label %cond.end.459

cond.end.459:                                     ; preds = %cond.end.457, %cond.true.438
  %cond460 = phi i32 [ 1, %cond.true.438 ], [ %cond458, %cond.end.457 ]
  %conv461 = sext i32 %cond460 to i64
  %237 = load i64, i64* %i2_byte, align 8
  %add462 = add nsw i64 %237, %conv461
  store i64 %add462, i64* %i2_byte, align 8
  br label %do.end.463

do.end.463:                                       ; preds = %cond.end.459
  %238 = load i64, i64* %i2, align 8
  %inc464 = add nsw i64 %238, 1
  store i64 %inc464, i64* %i2, align 8
  br label %if.end.497

if.else.465:                                      ; preds = %if.end.411
  %239 = load %struct.buffer*, %struct.buffer** %bp2, align 8
  %text466 = getelementptr inbounds %struct.buffer, %struct.buffer* %239, i32 0, i32 73
  %240 = load %struct.buffer_text*, %struct.buffer_text** %text466, align 8
  %beg467 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %240, i32 0, i32 0
  %241 = load i8*, i8** %beg467, align 8
  %242 = load i64, i64* %i2, align 8
  %add.ptr468 = getelementptr inbounds i8, i8* %241, i64 %242
  %add.ptr469 = getelementptr inbounds i8, i8* %add.ptr468, i64 -1
  %243 = load i64, i64* %i2, align 8
  %244 = load %struct.buffer*, %struct.buffer** %bp2, align 8
  %text470 = getelementptr inbounds %struct.buffer, %struct.buffer* %244, i32 0, i32 73
  %245 = load %struct.buffer_text*, %struct.buffer_text** %text470, align 8
  %gpt_byte471 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %245, i32 0, i32 3
  %246 = load i64, i64* %gpt_byte471, align 8
  %cmp472 = icmp sge i64 %243, %246
  br i1 %cmp472, label %cond.true.474, label %cond.false.477

cond.true.474:                                    ; preds = %if.else.465
  %247 = load %struct.buffer*, %struct.buffer** %bp2, align 8
  %text475 = getelementptr inbounds %struct.buffer, %struct.buffer* %247, i32 0, i32 73
  %248 = load %struct.buffer_text*, %struct.buffer_text** %text475, align 8
  %gap_size476 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %248, i32 0, i32 5
  %249 = load i64, i64* %gap_size476, align 8
  br label %cond.end.478

cond.false.477:                                   ; preds = %if.else.465
  br label %cond.end.478

cond.end.478:                                     ; preds = %cond.false.477, %cond.true.474
  %cond479 = phi i64 [ %249, %cond.true.474 ], [ 0, %cond.false.477 ]
  %add.ptr480 = getelementptr inbounds i8, i8* %add.ptr469, i64 %cond479
  %250 = load i8, i8* %add.ptr480, align 1
  %conv481 = zext i8 %250 to i32
  store i32 %conv481, i32* %c2, align 4
  br i1 true, label %cond.true.482, label %cond.false.486

cond.true.482:                                    ; preds = %cond.end.478
  %251 = load i32, i32* %c2, align 4
  %add483 = add i32 %251, 0
  %cmp484 = icmp ult i32 %add483, 128
  br i1 %cmp484, label %cond.true.491, label %cond.false.492

cond.false.486:                                   ; preds = %cond.end.478
  %252 = load i32, i32* %c2, align 4
  %conv487 = sext i32 %252 to i64
  %add488 = add i64 %conv487, 0
  %cmp489 = icmp ult i64 %add488, 128
  br i1 %cmp489, label %cond.true.491, label %cond.false.492

cond.true.491:                                    ; preds = %cond.false.486, %cond.true.482
  %253 = load i32, i32* %c2, align 4
  br label %cond.end.494

cond.false.492:                                   ; preds = %cond.false.486, %cond.true.482
  %254 = load i32, i32* %c2, align 4
  %add493 = add nsw i32 %254, 4194048
  br label %cond.end.494

cond.end.494:                                     ; preds = %cond.false.492, %cond.true.491
  %cond495 = phi i32 [ %253, %cond.true.491 ], [ %add493, %cond.false.492 ]
  store i32 %cond495, i32* %c2, align 4
  %255 = load i64, i64* %i2, align 8
  %inc496 = add nsw i64 %255, 1
  store i64 %inc496, i64* %i2, align 8
  br label %if.end.497

if.end.497:                                       ; preds = %cond.end.494, %do.end.463
  %256 = load i64, i64* %trt, align 8
  %call498 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp499 = icmp eq i64 %256, %call498
  br i1 %cmp499, label %if.end.504, label %if.then.501

if.then.501:                                      ; preds = %if.end.497
  %257 = load i64, i64* %trt, align 8
  %258 = load i32, i32* %c1, align 4
  %call502 = call i32 @char_table_translate(i64 %257, i32 %258)
  store i32 %call502, i32* %c1, align 4
  %259 = load i64, i64* %trt, align 8
  %260 = load i32, i32* %c2, align 4
  %call503 = call i32 @char_table_translate(i64 %259, i32 %260)
  store i32 %call503, i32* %c2, align 4
  br label %if.end.504

if.end.504:                                       ; preds = %if.then.501, %if.end.497
  %261 = load i32, i32* %c1, align 4
  %262 = load i32, i32* %c2, align 4
  %cmp505 = icmp slt i32 %261, %262
  br i1 %cmp505, label %if.then.507, label %if.end.509

if.then.507:                                      ; preds = %if.end.504
  %263 = load i64, i64* %chars, align 8
  %sub = sub nsw i64 -1, %263
  %shl = shl i64 %sub, 2
  %add508 = add i64 %shl, 2
  store i64 %add508, i64* %retval
  br label %return

if.end.509:                                       ; preds = %if.end.504
  %264 = load i32, i32* %c1, align 4
  %265 = load i32, i32* %c2, align 4
  %cmp510 = icmp sgt i32 %264, %265
  br i1 %cmp510, label %if.then.512, label %if.end.516

if.then.512:                                      ; preds = %if.end.509
  %266 = load i64, i64* %chars, align 8
  %add513 = add nsw i64 %266, 1
  %shl514 = shl i64 %add513, 2
  %add515 = add i64 %shl514, 2
  store i64 %add515, i64* %retval
  br label %return

if.end.516:                                       ; preds = %if.end.509
  %267 = load i64, i64* %chars, align 8
  %inc517 = add nsw i64 %267, 1
  store i64 %inc517, i64* %chars, align 8
  br label %while.cond

while.end:                                        ; preds = %land.end
  %268 = load i64, i64* %chars, align 8
  %269 = load i64, i64* %endp1, align 8
  %270 = load i64, i64* %begp1, align 8
  %sub518 = sub nsw i64 %269, %270
  %cmp519 = icmp slt i64 %268, %sub518
  br i1 %cmp519, label %if.then.521, label %if.else.525

if.then.521:                                      ; preds = %while.end
  %271 = load i64, i64* %chars, align 8
  %add522 = add nsw i64 %271, 1
  %shl523 = shl i64 %add522, 2
  %add524 = add i64 %shl523, 2
  store i64 %add524, i64* %retval
  br label %return

if.else.525:                                      ; preds = %while.end
  %272 = load i64, i64* %chars, align 8
  %273 = load i64, i64* %endp2, align 8
  %274 = load i64, i64* %begp2, align 8
  %sub526 = sub nsw i64 %273, %274
  %cmp527 = icmp slt i64 %272, %sub526
  br i1 %cmp527, label %if.then.529, label %if.end.534

if.then.529:                                      ; preds = %if.else.525
  %275 = load i64, i64* %chars, align 8
  %sub530 = sub nsw i64 0, %275
  %sub531 = sub nsw i64 %sub530, 1
  %shl532 = shl i64 %sub531, 2
  %add533 = add i64 %shl532, 2
  store i64 %add533, i64* %retval
  br label %return

if.end.534:                                       ; preds = %if.else.525
  br label %if.end.535

if.end.535:                                       ; preds = %if.end.534
  store i64 2, i64* %retval
  br label %return

return:                                           ; preds = %if.end.535, %if.then.529, %if.then.521, %if.then.512, %if.then.507
  %276 = load i64, i64* %retval
  ret i64 %276
}

declare i32 @BUF_FETCH_MULTIBYTE_CHAR(%struct.buffer*, i64) #1

declare i32 @char_table_translate(i64, i32) #1

; Function Attrs: nounwind uwtable
define i64 @Fsubst_char_in_region(i64 %start, i64 %end, i64 %fromchar, i64 %tochar, i64 %noundo) #0 {
entry:
  %start.addr = alloca i64, align 8
  %end.addr = alloca i64, align 8
  %fromchar.addr = alloca i64, align 8
  %tochar.addr = alloca i64, align 8
  %noundo.addr = alloca i64, align 8
  %pos = alloca i64, align 8
  %pos_byte = alloca i64, align 8
  %stop = alloca i64, align 8
  %i = alloca i64, align 8
  %len = alloca i64, align 8
  %end_byte = alloca i64, align 8
  %changed = alloca i64, align 8
  %fromstr = alloca [5 x i8], align 1
  %tostr = alloca [5 x i8], align 1
  %p = alloca i8*, align 8
  %count = alloca i64, align 8
  %maybe_byte_combining = alloca i32, align 4
  %last_changed = alloca i64, align 8
  %multibyte_p = alloca i8, align 1
  %fromc = alloca i32, align 4
  %toc = alloca i32, align 4
  %pos_byte_next = alloca i64, align 8
  %chp = alloca i8*, align 8
  %tem = alloca i64, align 8
  %string = alloca i64, align 8
  %chp483 = alloca i8*, align 8
  store i64 %start, i64* %start.addr, align 8
  store i64 %end, i64* %end.addr, align 8
  store i64 %fromchar, i64* %fromchar.addr, align 8
  store i64 %tochar, i64* %tochar.addr, align 8
  store i64 %noundo, i64* %noundo.addr, align 8
  store i64 0, i64* %changed, align 8
  %call = call i64 @SPECPDL_INDEX()
  store i64 %call, i64* %count, align 8
  store i32 0, i32* %maybe_byte_combining, align 4
  store i64 0, i64* %last_changed, align 8
  %0 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %enable_multibyte_characters_ = getelementptr inbounds %struct.buffer, %struct.buffer* %0, i32 0, i32 39
  %1 = load i64, i64* %enable_multibyte_characters_, align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %1, %call1
  %lnot = xor i1 %cmp, true
  %frombool = zext i1 %lnot to i8
  store i8 %frombool, i8* %multibyte_p, align 1
  br label %restart

restart:                                          ; preds = %if.end.368, %entry
  call void @validate_region(i64* %start.addr, i64* %end.addr)
  %2 = load i64, i64* %fromchar.addr, align 8
  %call2 = call zeroext i1 @NATNUMP(i64 %2)
  br i1 %call2, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %restart
  %3 = load i64, i64* %fromchar.addr, align 8
  %shr = ashr i64 %3, 2
  %cmp3 = icmp sle i64 %shr, 4194303
  br i1 %cmp3, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %restart
  %call4 = call i64 @builtin_lisp_symbol(i32 260)
  %4 = load i64, i64* %fromchar.addr, align 8
  %5 = call i64 @wrong_type_argument(i64 %call4, i64 %4) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %6, %cond.true
  %7 = load i64, i64* %tochar.addr, align 8
  %call5 = call zeroext i1 @NATNUMP(i64 %7)
  br i1 %call5, label %land.lhs.true.6, label %cond.false.10

land.lhs.true.6:                                  ; preds = %cond.end
  %8 = load i64, i64* %tochar.addr, align 8
  %shr7 = ashr i64 %8, 2
  %cmp8 = icmp sle i64 %shr7, 4194303
  br i1 %cmp8, label %cond.true.9, label %cond.false.10

cond.true.9:                                      ; preds = %land.lhs.true.6
  br label %cond.end.12

cond.false.10:                                    ; preds = %land.lhs.true.6, %cond.end
  %call11 = call i64 @builtin_lisp_symbol(i32 260)
  %9 = load i64, i64* %tochar.addr, align 8
  %10 = call i64 @wrong_type_argument(i64 %call11, i64 %9) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end.12

cond.end.12:                                      ; preds = %11, %cond.true.9
  %12 = load i64, i64* %fromchar.addr, align 8
  %shr13 = ashr i64 %12, 2
  %conv = trunc i64 %shr13 to i32
  store i32 %conv, i32* %fromc, align 4
  %13 = load i64, i64* %tochar.addr, align 8
  %shr14 = ashr i64 %13, 2
  %conv15 = trunc i64 %shr14 to i32
  store i32 %conv15, i32* %toc, align 4
  %14 = load i8, i8* %multibyte_p, align 1
  %tobool = trunc i8 %14 to i1
  br i1 %tobool, label %if.then, label %if.else.199

if.then:                                          ; preds = %cond.end.12
  br i1 true, label %cond.true.16, label %cond.false.19

cond.true.16:                                     ; preds = %if.then
  %15 = load i32, i32* %fromc, align 4
  %add = add i32 %15, 0
  %cmp17 = icmp ule i32 %add, 127
  br i1 %cmp17, label %cond.true.24, label %cond.false.26

cond.false.19:                                    ; preds = %if.then
  %16 = load i32, i32* %fromc, align 4
  %conv20 = sext i32 %16 to i64
  %add21 = add i64 %conv20, 0
  %cmp22 = icmp ule i64 %add21, 127
  br i1 %cmp22, label %cond.true.24, label %cond.false.26

cond.true.24:                                     ; preds = %cond.false.19, %cond.true.16
  %17 = load i32, i32* %fromc, align 4
  %conv25 = trunc i32 %17 to i8
  %arrayidx = getelementptr inbounds [5 x i8], [5 x i8]* %fromstr, i32 0, i64 0
  store i8 %conv25, i8* %arrayidx, align 1
  br label %cond.end.72

cond.false.26:                                    ; preds = %cond.false.19, %cond.true.16
  br i1 true, label %cond.true.27, label %cond.false.31

cond.true.27:                                     ; preds = %cond.false.26
  %18 = load i32, i32* %fromc, align 4
  %add28 = add i32 %18, 0
  %cmp29 = icmp ule i32 %add28, 2047
  br i1 %cmp29, label %cond.true.36, label %cond.false.43

cond.false.31:                                    ; preds = %cond.false.26
  %19 = load i32, i32* %fromc, align 4
  %conv32 = sext i32 %19 to i64
  %add33 = add i64 %conv32, 0
  %cmp34 = icmp ule i64 %add33, 2047
  br i1 %cmp34, label %cond.true.36, label %cond.false.43

cond.true.36:                                     ; preds = %cond.false.31, %cond.true.27
  %20 = load i32, i32* %fromc, align 4
  %shr37 = ashr i32 %20, 6
  %or = or i32 192, %shr37
  %conv38 = trunc i32 %or to i8
  %arrayidx39 = getelementptr inbounds [5 x i8], [5 x i8]* %fromstr, i32 0, i64 0
  store i8 %conv38, i8* %arrayidx39, align 1
  %21 = load i32, i32* %fromc, align 4
  %and = and i32 %21, 63
  %or40 = or i32 128, %and
  %conv41 = trunc i32 %or40 to i8
  %arrayidx42 = getelementptr inbounds [5 x i8], [5 x i8]* %fromstr, i32 0, i64 1
  store i8 %conv41, i8* %arrayidx42, align 1
  br label %cond.end.70

cond.false.43:                                    ; preds = %cond.false.31, %cond.true.27
  br i1 true, label %cond.true.44, label %cond.false.48

cond.true.44:                                     ; preds = %cond.false.43
  %22 = load i32, i32* %fromc, align 4
  %add45 = add i32 %22, 0
  %cmp46 = icmp ule i32 %add45, 65535
  br i1 %cmp46, label %cond.true.53, label %cond.false.67

cond.false.48:                                    ; preds = %cond.false.43
  %23 = load i32, i32* %fromc, align 4
  %conv49 = sext i32 %23 to i64
  %add50 = add i64 %conv49, 0
  %cmp51 = icmp ule i64 %add50, 65535
  br i1 %cmp51, label %cond.true.53, label %cond.false.67

cond.true.53:                                     ; preds = %cond.false.48, %cond.true.44
  %24 = load i32, i32* %fromc, align 4
  %shr54 = ashr i32 %24, 12
  %or55 = or i32 224, %shr54
  %conv56 = trunc i32 %or55 to i8
  %arrayidx57 = getelementptr inbounds [5 x i8], [5 x i8]* %fromstr, i32 0, i64 0
  store i8 %conv56, i8* %arrayidx57, align 1
  %25 = load i32, i32* %fromc, align 4
  %shr58 = ashr i32 %25, 6
  %and59 = and i32 %shr58, 63
  %or60 = or i32 128, %and59
  %conv61 = trunc i32 %or60 to i8
  %arrayidx62 = getelementptr inbounds [5 x i8], [5 x i8]* %fromstr, i32 0, i64 1
  store i8 %conv61, i8* %arrayidx62, align 1
  %26 = load i32, i32* %fromc, align 4
  %and63 = and i32 %26, 63
  %or64 = or i32 128, %and63
  %conv65 = trunc i32 %or64 to i8
  %arrayidx66 = getelementptr inbounds [5 x i8], [5 x i8]* %fromstr, i32 0, i64 2
  store i8 %conv65, i8* %arrayidx66, align 1
  br label %cond.end.69

cond.false.67:                                    ; preds = %cond.false.48, %cond.true.44
  %27 = load i32, i32* %fromc, align 4
  %arraydecay = getelementptr inbounds [5 x i8], [5 x i8]* %fromstr, i32 0, i32 0
  %call68 = call i32 @char_string(i32 %27, i8* %arraydecay)
  br label %cond.end.69

cond.end.69:                                      ; preds = %cond.false.67, %cond.true.53
  %cond = phi i32 [ 3, %cond.true.53 ], [ %call68, %cond.false.67 ]
  br label %cond.end.70

cond.end.70:                                      ; preds = %cond.end.69, %cond.true.36
  %cond71 = phi i32 [ 2, %cond.true.36 ], [ %cond, %cond.end.69 ]
  br label %cond.end.72

cond.end.72:                                      ; preds = %cond.end.70, %cond.true.24
  %cond73 = phi i32 [ 1, %cond.true.24 ], [ %cond71, %cond.end.70 ]
  %conv74 = sext i32 %cond73 to i64
  store i64 %conv74, i64* %len, align 8
  br i1 true, label %cond.true.75, label %cond.false.79

cond.true.75:                                     ; preds = %cond.end.72
  %28 = load i32, i32* %toc, align 4
  %add76 = add i32 %28, 0
  %cmp77 = icmp ule i32 %add76, 127
  br i1 %cmp77, label %cond.true.84, label %cond.false.87

cond.false.79:                                    ; preds = %cond.end.72
  %29 = load i32, i32* %toc, align 4
  %conv80 = sext i32 %29 to i64
  %add81 = add i64 %conv80, 0
  %cmp82 = icmp ule i64 %add81, 127
  br i1 %cmp82, label %cond.true.84, label %cond.false.87

cond.true.84:                                     ; preds = %cond.false.79, %cond.true.75
  %30 = load i32, i32* %toc, align 4
  %conv85 = trunc i32 %30 to i8
  %arrayidx86 = getelementptr inbounds [5 x i8], [5 x i8]* %tostr, i32 0, i64 0
  store i8 %conv85, i8* %arrayidx86, align 1
  br label %cond.end.137

cond.false.87:                                    ; preds = %cond.false.79, %cond.true.75
  br i1 true, label %cond.true.88, label %cond.false.92

cond.true.88:                                     ; preds = %cond.false.87
  %31 = load i32, i32* %toc, align 4
  %add89 = add i32 %31, 0
  %cmp90 = icmp ule i32 %add89, 2047
  br i1 %cmp90, label %cond.true.97, label %cond.false.106

cond.false.92:                                    ; preds = %cond.false.87
  %32 = load i32, i32* %toc, align 4
  %conv93 = sext i32 %32 to i64
  %add94 = add i64 %conv93, 0
  %cmp95 = icmp ule i64 %add94, 2047
  br i1 %cmp95, label %cond.true.97, label %cond.false.106

cond.true.97:                                     ; preds = %cond.false.92, %cond.true.88
  %33 = load i32, i32* %toc, align 4
  %shr98 = ashr i32 %33, 6
  %or99 = or i32 192, %shr98
  %conv100 = trunc i32 %or99 to i8
  %arrayidx101 = getelementptr inbounds [5 x i8], [5 x i8]* %tostr, i32 0, i64 0
  store i8 %conv100, i8* %arrayidx101, align 1
  %34 = load i32, i32* %toc, align 4
  %and102 = and i32 %34, 63
  %or103 = or i32 128, %and102
  %conv104 = trunc i32 %or103 to i8
  %arrayidx105 = getelementptr inbounds [5 x i8], [5 x i8]* %tostr, i32 0, i64 1
  store i8 %conv104, i8* %arrayidx105, align 1
  br label %cond.end.135

cond.false.106:                                   ; preds = %cond.false.92, %cond.true.88
  br i1 true, label %cond.true.107, label %cond.false.111

cond.true.107:                                    ; preds = %cond.false.106
  %35 = load i32, i32* %toc, align 4
  %add108 = add i32 %35, 0
  %cmp109 = icmp ule i32 %add108, 65535
  br i1 %cmp109, label %cond.true.116, label %cond.false.130

cond.false.111:                                   ; preds = %cond.false.106
  %36 = load i32, i32* %toc, align 4
  %conv112 = sext i32 %36 to i64
  %add113 = add i64 %conv112, 0
  %cmp114 = icmp ule i64 %add113, 65535
  br i1 %cmp114, label %cond.true.116, label %cond.false.130

cond.true.116:                                    ; preds = %cond.false.111, %cond.true.107
  %37 = load i32, i32* %toc, align 4
  %shr117 = ashr i32 %37, 12
  %or118 = or i32 224, %shr117
  %conv119 = trunc i32 %or118 to i8
  %arrayidx120 = getelementptr inbounds [5 x i8], [5 x i8]* %tostr, i32 0, i64 0
  store i8 %conv119, i8* %arrayidx120, align 1
  %38 = load i32, i32* %toc, align 4
  %shr121 = ashr i32 %38, 6
  %and122 = and i32 %shr121, 63
  %or123 = or i32 128, %and122
  %conv124 = trunc i32 %or123 to i8
  %arrayidx125 = getelementptr inbounds [5 x i8], [5 x i8]* %tostr, i32 0, i64 1
  store i8 %conv124, i8* %arrayidx125, align 1
  %39 = load i32, i32* %toc, align 4
  %and126 = and i32 %39, 63
  %or127 = or i32 128, %and126
  %conv128 = trunc i32 %or127 to i8
  %arrayidx129 = getelementptr inbounds [5 x i8], [5 x i8]* %tostr, i32 0, i64 2
  store i8 %conv128, i8* %arrayidx129, align 1
  br label %cond.end.133

cond.false.130:                                   ; preds = %cond.false.111, %cond.true.107
  %40 = load i32, i32* %toc, align 4
  %arraydecay131 = getelementptr inbounds [5 x i8], [5 x i8]* %tostr, i32 0, i32 0
  %call132 = call i32 @char_string(i32 %40, i8* %arraydecay131)
  br label %cond.end.133

cond.end.133:                                     ; preds = %cond.false.130, %cond.true.116
  %cond134 = phi i32 [ 3, %cond.true.116 ], [ %call132, %cond.false.130 ]
  br label %cond.end.135

cond.end.135:                                     ; preds = %cond.end.133, %cond.true.97
  %cond136 = phi i32 [ 2, %cond.true.97 ], [ %cond134, %cond.end.133 ]
  br label %cond.end.137

cond.end.137:                                     ; preds = %cond.end.135, %cond.true.84
  %cond138 = phi i32 [ 1, %cond.true.84 ], [ %cond136, %cond.end.135 ]
  %conv139 = sext i32 %cond138 to i64
  %41 = load i64, i64* %len, align 8
  %cmp140 = icmp ne i64 %conv139, %41
  br i1 %cmp140, label %if.then.142, label %if.end

if.then.142:                                      ; preds = %cond.end.137
  call void (i8*, ...) @error(i8* getelementptr inbounds ([65 x i8], [65 x i8]* @.str.12, i32 0, i32 0)) #9
  unreachable

if.end:                                           ; preds = %cond.end.137
  br i1 true, label %cond.true.143, label %cond.false.149

cond.true.143:                                    ; preds = %if.end
  %arraydecay144 = getelementptr inbounds [5 x i8], [5 x i8]* %tostr, i32 0, i32 0
  %42 = load i8, i8* %arraydecay144, align 1
  %conv145 = zext i8 %42 to i32
  %add146 = add i32 %conv145, 0
  %cmp147 = icmp ult i32 %add146, 128
  br i1 %cmp147, label %if.end.198, label %if.then.155

cond.false.149:                                   ; preds = %if.end
  %arraydecay150 = getelementptr inbounds [5 x i8], [5 x i8]* %tostr, i32 0, i32 0
  %43 = load i8, i8* %arraydecay150, align 1
  %conv151 = zext i8 %43 to i64
  %add152 = add i64 %conv151, 0
  %cmp153 = icmp ult i64 %add152, 128
  br i1 %cmp153, label %if.end.198, label %if.then.155

if.then.155:                                      ; preds = %cond.false.149, %cond.true.143
  %arraydecay156 = getelementptr inbounds [5 x i8], [5 x i8]* %tostr, i32 0, i32 0
  %44 = load i8, i8* %arraydecay156, align 1
  %conv157 = zext i8 %44 to i32
  %and158 = and i32 %conv157, 192
  %cmp159 = icmp ne i32 %and158, 128
  br i1 %cmp159, label %if.else, label %if.then.161

if.then.161:                                      ; preds = %if.then.155
  store i32 3, i32* %maybe_byte_combining, align 4
  br label %if.end.197

if.else:                                          ; preds = %if.then.155
  %arraydecay162 = getelementptr inbounds [5 x i8], [5 x i8]* %tostr, i32 0, i32 0
  %45 = load i8, i8* %arraydecay162, align 1
  %conv163 = zext i8 %45 to i32
  %and164 = and i32 %conv163, 128
  %tobool165 = icmp ne i32 %and164, 0
  br i1 %tobool165, label %cond.false.167, label %cond.true.166

cond.true.166:                                    ; preds = %if.else
  br label %cond.end.190

cond.false.167:                                   ; preds = %if.else
  %arraydecay168 = getelementptr inbounds [5 x i8], [5 x i8]* %tostr, i32 0, i32 0
  %46 = load i8, i8* %arraydecay168, align 1
  %conv169 = zext i8 %46 to i32
  %and170 = and i32 %conv169, 32
  %tobool171 = icmp ne i32 %and170, 0
  br i1 %tobool171, label %cond.false.173, label %cond.true.172

cond.true.172:                                    ; preds = %cond.false.167
  br label %cond.end.188

cond.false.173:                                   ; preds = %cond.false.167
  %arraydecay174 = getelementptr inbounds [5 x i8], [5 x i8]* %tostr, i32 0, i32 0
  %47 = load i8, i8* %arraydecay174, align 1
  %conv175 = zext i8 %47 to i32
  %and176 = and i32 %conv175, 16
  %tobool177 = icmp ne i32 %and176, 0
  br i1 %tobool177, label %cond.false.179, label %cond.true.178

cond.true.178:                                    ; preds = %cond.false.173
  br label %cond.end.186

cond.false.179:                                   ; preds = %cond.false.173
  %arraydecay180 = getelementptr inbounds [5 x i8], [5 x i8]* %tostr, i32 0, i32 0
  %48 = load i8, i8* %arraydecay180, align 1
  %conv181 = zext i8 %48 to i32
  %and182 = and i32 %conv181, 8
  %tobool183 = icmp ne i32 %and182, 0
  %lnot184 = xor i1 %tobool183, true
  %cond185 = select i1 %lnot184, i32 4, i32 5
  br label %cond.end.186

cond.end.186:                                     ; preds = %cond.false.179, %cond.true.178
  %cond187 = phi i32 [ 3, %cond.true.178 ], [ %cond185, %cond.false.179 ]
  br label %cond.end.188

cond.end.188:                                     ; preds = %cond.end.186, %cond.true.172
  %cond189 = phi i32 [ 2, %cond.true.172 ], [ %cond187, %cond.end.186 ]
  br label %cond.end.190

cond.end.190:                                     ; preds = %cond.end.188, %cond.true.166
  %cond191 = phi i32 [ 1, %cond.true.166 ], [ %cond189, %cond.end.188 ]
  %conv192 = sext i32 %cond191 to i64
  %49 = load i64, i64* %len, align 8
  %cmp193 = icmp sgt i64 %conv192, %49
  br i1 %cmp193, label %if.then.195, label %if.end.196

if.then.195:                                      ; preds = %cond.end.190
  store i32 2, i32* %maybe_byte_combining, align 4
  br label %if.end.196

if.end.196:                                       ; preds = %if.then.195, %cond.end.190
  br label %if.end.197

if.end.197:                                       ; preds = %if.end.196, %if.then.161
  br label %if.end.198

if.end.198:                                       ; preds = %if.end.197, %cond.false.149, %cond.true.143
  br label %if.end.204

if.else.199:                                      ; preds = %cond.end.12
  store i64 1, i64* %len, align 8
  %50 = load i32, i32* %fromc, align 4
  %conv200 = trunc i32 %50 to i8
  %arrayidx201 = getelementptr inbounds [5 x i8], [5 x i8]* %fromstr, i32 0, i64 0
  store i8 %conv200, i8* %arrayidx201, align 1
  %51 = load i32, i32* %toc, align 4
  %conv202 = trunc i32 %51 to i8
  %arrayidx203 = getelementptr inbounds [5 x i8], [5 x i8]* %tostr, i32 0, i64 0
  store i8 %conv202, i8* %arrayidx203, align 1
  br label %if.end.204

if.end.204:                                       ; preds = %if.else.199, %if.end.198
  %52 = load i64, i64* %start.addr, align 8
  %shr205 = ashr i64 %52, 2
  store i64 %shr205, i64* %pos, align 8
  %53 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %54 = load i64, i64* %pos, align 8
  %call206 = call i64 @buf_charpos_to_bytepos(%struct.buffer* %53, i64 %54)
  store i64 %call206, i64* %pos_byte, align 8
  %55 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %56 = load i64, i64* %end.addr, align 8
  %shr207 = ashr i64 %56, 2
  %call208 = call i64 @buf_charpos_to_bytepos(%struct.buffer* %55, i64 %shr207)
  store i64 %call208, i64* %stop, align 8
  %57 = load i64, i64* %stop, align 8
  store i64 %57, i64* %end_byte, align 8
  %58 = load i64, i64* %changed, align 8
  %tobool209 = icmp ne i64 %58, 0
  br i1 %tobool209, label %if.end.217, label %land.lhs.true.210

land.lhs.true.210:                                ; preds = %if.end.204
  %59 = load i64, i64* %noundo.addr, align 8
  %call211 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp212 = icmp eq i64 %59, %call211
  br i1 %cmp212, label %if.end.217, label %if.then.214

if.then.214:                                      ; preds = %land.lhs.true.210
  %60 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %undo_list_ = getelementptr inbounds %struct.buffer, %struct.buffer* %60, i32 0, i32 98
  %61 = load i64, i64* %undo_list_, align 8
  call void @record_unwind_protect(void (i64)* @subst_char_in_region_unwind, i64 %61)
  %62 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %call215 = call i64 @builtin_lisp_symbol(i32 901)
  call void @bset_undo_list(%struct.buffer* %62, i64 %call215)
  %63 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %filename_ = getelementptr inbounds %struct.buffer, %struct.buffer* %63, i32 0, i32 2
  %64 = load i64, i64* %filename_, align 8
  call void @record_unwind_protect(void (i64)* @subst_char_in_region_unwind_1, i64 %64)
  %65 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %call216 = call i64 @builtin_lisp_symbol(i32 0)
  call void @bset_filename(%struct.buffer* %65, i64 %call216)
  br label %if.end.217

if.end.217:                                       ; preds = %if.then.214, %land.lhs.true.210, %if.end.204
  %66 = load i64, i64* %pos_byte, align 8
  %67 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text = getelementptr inbounds %struct.buffer, %struct.buffer* %67, i32 0, i32 73
  %68 = load %struct.buffer_text*, %struct.buffer_text** %text, align 8
  %gpt_byte = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %68, i32 0, i32 3
  %69 = load i64, i64* %gpt_byte, align 8
  %cmp218 = icmp slt i64 %66, %69
  br i1 %cmp218, label %if.then.220, label %if.end.231

if.then.220:                                      ; preds = %if.end.217
  %70 = load i64, i64* %stop, align 8
  %71 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text221 = getelementptr inbounds %struct.buffer, %struct.buffer* %71, i32 0, i32 73
  %72 = load %struct.buffer_text*, %struct.buffer_text** %text221, align 8
  %gpt_byte222 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %72, i32 0, i32 3
  %73 = load i64, i64* %gpt_byte222, align 8
  %cmp223 = icmp slt i64 %70, %73
  br i1 %cmp223, label %cond.true.225, label %cond.false.226

cond.true.225:                                    ; preds = %if.then.220
  %74 = load i64, i64* %stop, align 8
  br label %cond.end.229

cond.false.226:                                   ; preds = %if.then.220
  %75 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text227 = getelementptr inbounds %struct.buffer, %struct.buffer* %75, i32 0, i32 73
  %76 = load %struct.buffer_text*, %struct.buffer_text** %text227, align 8
  %gpt_byte228 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %76, i32 0, i32 3
  %77 = load i64, i64* %gpt_byte228, align 8
  br label %cond.end.229

cond.end.229:                                     ; preds = %cond.false.226, %cond.true.225
  %cond230 = phi i64 [ %74, %cond.true.225 ], [ %77, %cond.false.226 ]
  store i64 %cond230, i64* %stop, align 8
  br label %if.end.231

if.end.231:                                       ; preds = %cond.end.229, %if.end.217
  br label %while.body

while.body:                                       ; preds = %if.end.231, %if.end.546
  %78 = load i64, i64* %pos_byte, align 8
  store i64 %78, i64* %pos_byte_next, align 8
  %79 = load i64, i64* %pos_byte, align 8
  %80 = load i64, i64* %stop, align 8
  %cmp232 = icmp sge i64 %79, %80
  br i1 %cmp232, label %if.then.234, label %if.end.239

if.then.234:                                      ; preds = %while.body
  %81 = load i64, i64* %pos_byte, align 8
  %82 = load i64, i64* %end_byte, align 8
  %cmp235 = icmp sge i64 %81, %82
  br i1 %cmp235, label %if.then.237, label %if.end.238

if.then.237:                                      ; preds = %if.then.234
  br label %while.end

if.end.238:                                       ; preds = %if.then.234
  %83 = load i64, i64* %end_byte, align 8
  store i64 %83, i64* %stop, align 8
  br label %if.end.239

if.end.239:                                       ; preds = %if.end.238, %while.body
  %84 = load i64, i64* %pos_byte, align 8
  %85 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text240 = getelementptr inbounds %struct.buffer, %struct.buffer* %85, i32 0, i32 73
  %86 = load %struct.buffer_text*, %struct.buffer_text** %text240, align 8
  %gpt_byte241 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %86, i32 0, i32 3
  %87 = load i64, i64* %gpt_byte241, align 8
  %cmp242 = icmp sge i64 %84, %87
  br i1 %cmp242, label %cond.true.244, label %cond.false.246

cond.true.244:                                    ; preds = %if.end.239
  %88 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text245 = getelementptr inbounds %struct.buffer, %struct.buffer* %88, i32 0, i32 73
  %89 = load %struct.buffer_text*, %struct.buffer_text** %text245, align 8
  %gap_size = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %89, i32 0, i32 5
  %90 = load i64, i64* %gap_size, align 8
  br label %cond.end.247

cond.false.246:                                   ; preds = %if.end.239
  br label %cond.end.247

cond.end.247:                                     ; preds = %cond.false.246, %cond.true.244
  %cond248 = phi i64 [ %90, %cond.true.244 ], [ 0, %cond.false.246 ]
  %91 = load i64, i64* %pos_byte, align 8
  %add249 = add nsw i64 %cond248, %91
  %92 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text250 = getelementptr inbounds %struct.buffer, %struct.buffer* %92, i32 0, i32 73
  %93 = load %struct.buffer_text*, %struct.buffer_text** %text250, align 8
  %beg = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %93, i32 0, i32 0
  %94 = load i8*, i8** %beg, align 8
  %add.ptr = getelementptr inbounds i8, i8* %94, i64 %add249
  %add.ptr251 = getelementptr inbounds i8, i8* %add.ptr, i64 -1
  store i8* %add.ptr251, i8** %p, align 8
  %95 = load i8, i8* %multibyte_p, align 1
  %tobool252 = trunc i8 %95 to i1
  br i1 %tobool252, label %if.then.253, label %if.else.297

if.then.253:                                      ; preds = %cond.end.247
  br label %do.body

do.body:                                          ; preds = %if.then.253
  %96 = load i64, i64* %pos_byte_next, align 8
  %97 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text254 = getelementptr inbounds %struct.buffer, %struct.buffer* %97, i32 0, i32 73
  %98 = load %struct.buffer_text*, %struct.buffer_text** %text254, align 8
  %gpt_byte255 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %98, i32 0, i32 3
  %99 = load i64, i64* %gpt_byte255, align 8
  %cmp256 = icmp sge i64 %96, %99
  br i1 %cmp256, label %cond.true.258, label %cond.false.261

cond.true.258:                                    ; preds = %do.body
  %100 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text259 = getelementptr inbounds %struct.buffer, %struct.buffer* %100, i32 0, i32 73
  %101 = load %struct.buffer_text*, %struct.buffer_text** %text259, align 8
  %gap_size260 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %101, i32 0, i32 5
  %102 = load i64, i64* %gap_size260, align 8
  br label %cond.end.262

cond.false.261:                                   ; preds = %do.body
  br label %cond.end.262

cond.end.262:                                     ; preds = %cond.false.261, %cond.true.258
  %cond263 = phi i64 [ %102, %cond.true.258 ], [ 0, %cond.false.261 ]
  %103 = load i64, i64* %pos_byte_next, align 8
  %add264 = add nsw i64 %cond263, %103
  %104 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text265 = getelementptr inbounds %struct.buffer, %struct.buffer* %104, i32 0, i32 73
  %105 = load %struct.buffer_text*, %struct.buffer_text** %text265, align 8
  %beg266 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %105, i32 0, i32 0
  %106 = load i8*, i8** %beg266, align 8
  %add.ptr267 = getelementptr inbounds i8, i8* %106, i64 %add264
  %add.ptr268 = getelementptr inbounds i8, i8* %add.ptr267, i64 -1
  store i8* %add.ptr268, i8** %chp, align 8
  %107 = load i8*, i8** %chp, align 8
  %108 = load i8, i8* %107, align 1
  %conv269 = zext i8 %108 to i32
  %and270 = and i32 %conv269, 128
  %tobool271 = icmp ne i32 %and270, 0
  br i1 %tobool271, label %cond.false.273, label %cond.true.272

cond.true.272:                                    ; preds = %cond.end.262
  br label %cond.end.293

cond.false.273:                                   ; preds = %cond.end.262
  %109 = load i8*, i8** %chp, align 8
  %110 = load i8, i8* %109, align 1
  %conv274 = zext i8 %110 to i32
  %and275 = and i32 %conv274, 32
  %tobool276 = icmp ne i32 %and275, 0
  br i1 %tobool276, label %cond.false.278, label %cond.true.277

cond.true.277:                                    ; preds = %cond.false.273
  br label %cond.end.291

cond.false.278:                                   ; preds = %cond.false.273
  %111 = load i8*, i8** %chp, align 8
  %112 = load i8, i8* %111, align 1
  %conv279 = zext i8 %112 to i32
  %and280 = and i32 %conv279, 16
  %tobool281 = icmp ne i32 %and280, 0
  br i1 %tobool281, label %cond.false.283, label %cond.true.282

cond.true.282:                                    ; preds = %cond.false.278
  br label %cond.end.289

cond.false.283:                                   ; preds = %cond.false.278
  %113 = load i8*, i8** %chp, align 8
  %114 = load i8, i8* %113, align 1
  %conv284 = zext i8 %114 to i32
  %and285 = and i32 %conv284, 8
  %tobool286 = icmp ne i32 %and285, 0
  %lnot287 = xor i1 %tobool286, true
  %cond288 = select i1 %lnot287, i32 4, i32 5
  br label %cond.end.289

cond.end.289:                                     ; preds = %cond.false.283, %cond.true.282
  %cond290 = phi i32 [ 3, %cond.true.282 ], [ %cond288, %cond.false.283 ]
  br label %cond.end.291

cond.end.291:                                     ; preds = %cond.end.289, %cond.true.277
  %cond292 = phi i32 [ 2, %cond.true.277 ], [ %cond290, %cond.end.289 ]
  br label %cond.end.293

cond.end.293:                                     ; preds = %cond.end.291, %cond.true.272
  %cond294 = phi i32 [ 1, %cond.true.272 ], [ %cond292, %cond.end.291 ]
  %conv295 = sext i32 %cond294 to i64
  %115 = load i64, i64* %pos_byte_next, align 8
  %add296 = add nsw i64 %115, %conv295
  store i64 %add296, i64* %pos_byte_next, align 8
  br label %do.end

do.end:                                           ; preds = %cond.end.293
  br label %if.end.298

if.else.297:                                      ; preds = %cond.end.247
  %116 = load i64, i64* %pos_byte_next, align 8
  %inc = add nsw i64 %116, 1
  store i64 %inc, i64* %pos_byte_next, align 8
  br label %if.end.298

if.end.298:                                       ; preds = %if.else.297, %do.end
  %117 = load i64, i64* %pos_byte_next, align 8
  %118 = load i64, i64* %pos_byte, align 8
  %sub = sub nsw i64 %117, %118
  %119 = load i64, i64* %len, align 8
  %cmp299 = icmp eq i64 %sub, %119
  br i1 %cmp299, label %land.lhs.true.301, label %if.end.546

land.lhs.true.301:                                ; preds = %if.end.298
  %120 = load i8*, i8** %p, align 8
  %arrayidx302 = getelementptr inbounds i8, i8* %120, i64 0
  %121 = load i8, i8* %arrayidx302, align 1
  %conv303 = zext i8 %121 to i32
  %arrayidx304 = getelementptr inbounds [5 x i8], [5 x i8]* %fromstr, i32 0, i64 0
  %122 = load i8, i8* %arrayidx304, align 1
  %conv305 = zext i8 %122 to i32
  %cmp306 = icmp eq i32 %conv303, %conv305
  br i1 %cmp306, label %land.lhs.true.308, label %if.end.546

land.lhs.true.308:                                ; preds = %land.lhs.true.301
  %123 = load i64, i64* %len, align 8
  %cmp309 = icmp eq i64 %123, 1
  br i1 %cmp309, label %if.then.337, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true.308
  %124 = load i8*, i8** %p, align 8
  %arrayidx311 = getelementptr inbounds i8, i8* %124, i64 1
  %125 = load i8, i8* %arrayidx311, align 1
  %conv312 = zext i8 %125 to i32
  %arrayidx313 = getelementptr inbounds [5 x i8], [5 x i8]* %fromstr, i32 0, i64 1
  %126 = load i8, i8* %arrayidx313, align 1
  %conv314 = zext i8 %126 to i32
  %cmp315 = icmp eq i32 %conv312, %conv314
  br i1 %cmp315, label %land.lhs.true.317, label %if.end.546

land.lhs.true.317:                                ; preds = %lor.lhs.false
  %127 = load i64, i64* %len, align 8
  %cmp318 = icmp eq i64 %127, 2
  br i1 %cmp318, label %if.then.337, label %lor.lhs.false.320

lor.lhs.false.320:                                ; preds = %land.lhs.true.317
  %128 = load i8*, i8** %p, align 8
  %arrayidx321 = getelementptr inbounds i8, i8* %128, i64 2
  %129 = load i8, i8* %arrayidx321, align 1
  %conv322 = zext i8 %129 to i32
  %arrayidx323 = getelementptr inbounds [5 x i8], [5 x i8]* %fromstr, i32 0, i64 2
  %130 = load i8, i8* %arrayidx323, align 1
  %conv324 = zext i8 %130 to i32
  %cmp325 = icmp eq i32 %conv322, %conv324
  br i1 %cmp325, label %land.lhs.true.327, label %if.end.546

land.lhs.true.327:                                ; preds = %lor.lhs.false.320
  %131 = load i64, i64* %len, align 8
  %cmp328 = icmp eq i64 %131, 3
  br i1 %cmp328, label %if.then.337, label %lor.lhs.false.330

lor.lhs.false.330:                                ; preds = %land.lhs.true.327
  %132 = load i8*, i8** %p, align 8
  %arrayidx331 = getelementptr inbounds i8, i8* %132, i64 3
  %133 = load i8, i8* %arrayidx331, align 1
  %conv332 = zext i8 %133 to i32
  %arrayidx333 = getelementptr inbounds [5 x i8], [5 x i8]* %fromstr, i32 0, i64 3
  %134 = load i8, i8* %arrayidx333, align 1
  %conv334 = zext i8 %134 to i32
  %cmp335 = icmp eq i32 %conv332, %conv334
  br i1 %cmp335, label %if.then.337, label %if.end.546

if.then.337:                                      ; preds = %lor.lhs.false.330, %land.lhs.true.327, %land.lhs.true.317, %land.lhs.true.308
  %135 = load i64, i64* %changed, align 8
  %cmp338 = icmp slt i64 %135, 0
  br i1 %cmp338, label %if.then.340, label %if.else.341

if.then.340:                                      ; preds = %if.then.337
  %136 = load i64, i64* %pos, align 8
  store i64 %136, i64* %changed, align 8
  br label %if.end.370

if.else.341:                                      ; preds = %if.then.337
  %137 = load i64, i64* %changed, align 8
  %tobool342 = icmp ne i64 %137, 0
  br i1 %tobool342, label %if.end.369, label %if.then.343

if.then.343:                                      ; preds = %if.else.341
  store i64 -1, i64* %changed, align 8
  %138 = load i64, i64* %pos, align 8
  %139 = load i64, i64* %end.addr, align 8
  %shr344 = ashr i64 %139, 2
  call void @modify_text(i64 %138, i64 %shr344)
  %140 = load i64, i64* %noundo.addr, align 8
  %call345 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp346 = icmp eq i64 %140, %call345
  br i1 %cmp346, label %if.end.368, label %if.then.348

if.then.348:                                      ; preds = %if.then.343
  %141 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text349 = getelementptr inbounds %struct.buffer, %struct.buffer* %141, i32 0, i32 73
  %142 = load %struct.buffer_text*, %struct.buffer_text** %text349, align 8
  %modiff = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %142, i32 0, i32 6
  %143 = load i64, i64* %modiff, align 8
  %sub350 = sub nsw i64 %143, 1
  %144 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text351 = getelementptr inbounds %struct.buffer, %struct.buffer* %144, i32 0, i32 73
  %145 = load %struct.buffer_text*, %struct.buffer_text** %text351, align 8
  %save_modiff = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %145, i32 0, i32 8
  %146 = load i64, i64* %save_modiff, align 8
  %cmp352 = icmp eq i64 %sub350, %146
  br i1 %cmp352, label %if.then.354, label %if.end.358

if.then.354:                                      ; preds = %if.then.348
  %147 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text355 = getelementptr inbounds %struct.buffer, %struct.buffer* %147, i32 0, i32 73
  %148 = load %struct.buffer_text*, %struct.buffer_text** %text355, align 8
  %save_modiff356 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %148, i32 0, i32 8
  %149 = load i64, i64* %save_modiff356, align 8
  %inc357 = add nsw i64 %149, 1
  store i64 %inc357, i64* %save_modiff356, align 8
  br label %if.end.358

if.end.358:                                       ; preds = %if.then.354, %if.then.348
  %150 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text359 = getelementptr inbounds %struct.buffer, %struct.buffer* %150, i32 0, i32 73
  %151 = load %struct.buffer_text*, %struct.buffer_text** %text359, align 8
  %modiff360 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %151, i32 0, i32 6
  %152 = load i64, i64* %modiff360, align 8
  %sub361 = sub nsw i64 %152, 1
  %153 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %auto_save_modified = getelementptr inbounds %struct.buffer, %struct.buffer* %153, i32 0, i32 87
  %154 = load i64, i64* %auto_save_modified, align 8
  %cmp362 = icmp eq i64 %sub361, %154
  br i1 %cmp362, label %if.then.364, label %if.end.367

if.then.364:                                      ; preds = %if.end.358
  %155 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %auto_save_modified365 = getelementptr inbounds %struct.buffer, %struct.buffer* %155, i32 0, i32 87
  %156 = load i64, i64* %auto_save_modified365, align 8
  %inc366 = add nsw i64 %156, 1
  store i64 %inc366, i64* %auto_save_modified365, align 8
  br label %if.end.367

if.end.367:                                       ; preds = %if.then.364, %if.end.358
  br label %if.end.368

if.end.368:                                       ; preds = %if.end.367, %if.then.343
  br label %restart

if.end.369:                                       ; preds = %if.else.341
  br label %if.end.370

if.end.370:                                       ; preds = %if.end.369, %if.then.340
  %157 = load i32, i32* %maybe_byte_combining, align 4
  %tobool371 = icmp ne i32 %157, 0
  br i1 %tobool371, label %land.lhs.true.372, label %if.else.534

land.lhs.true.372:                                ; preds = %if.end.370
  %158 = load i32, i32* %maybe_byte_combining, align 4
  %cmp373 = icmp eq i32 %158, 2
  br i1 %cmp373, label %cond.true.375, label %cond.false.399

cond.true.375:                                    ; preds = %land.lhs.true.372
  %159 = load i64, i64* %pos_byte_next, align 8
  %160 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text376 = getelementptr inbounds %struct.buffer, %struct.buffer* %160, i32 0, i32 73
  %161 = load %struct.buffer_text*, %struct.buffer_text** %text376, align 8
  %z_byte = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %161, i32 0, i32 4
  %162 = load i64, i64* %z_byte, align 8
  %cmp377 = icmp slt i64 %159, %162
  br i1 %cmp377, label %land.lhs.true.379, label %if.else.534

land.lhs.true.379:                                ; preds = %cond.true.375
  %163 = load i64, i64* %pos_byte_next, align 8
  %164 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text380 = getelementptr inbounds %struct.buffer, %struct.buffer* %164, i32 0, i32 73
  %165 = load %struct.buffer_text*, %struct.buffer_text** %text380, align 8
  %gpt_byte381 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %165, i32 0, i32 3
  %166 = load i64, i64* %gpt_byte381, align 8
  %cmp382 = icmp sge i64 %163, %166
  br i1 %cmp382, label %cond.true.384, label %cond.false.387

cond.true.384:                                    ; preds = %land.lhs.true.379
  %167 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text385 = getelementptr inbounds %struct.buffer, %struct.buffer* %167, i32 0, i32 73
  %168 = load %struct.buffer_text*, %struct.buffer_text** %text385, align 8
  %gap_size386 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %168, i32 0, i32 5
  %169 = load i64, i64* %gap_size386, align 8
  br label %cond.end.388

cond.false.387:                                   ; preds = %land.lhs.true.379
  br label %cond.end.388

cond.end.388:                                     ; preds = %cond.false.387, %cond.true.384
  %cond389 = phi i64 [ %169, %cond.true.384 ], [ 0, %cond.false.387 ]
  %170 = load i64, i64* %pos_byte_next, align 8
  %add390 = add nsw i64 %cond389, %170
  %171 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text391 = getelementptr inbounds %struct.buffer, %struct.buffer* %171, i32 0, i32 73
  %172 = load %struct.buffer_text*, %struct.buffer_text** %text391, align 8
  %beg392 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %172, i32 0, i32 0
  %173 = load i8*, i8** %beg392, align 8
  %add.ptr393 = getelementptr inbounds i8, i8* %173, i64 %add390
  %add.ptr394 = getelementptr inbounds i8, i8* %add.ptr393, i64 -1
  %174 = load i8, i8* %add.ptr394, align 1
  %conv395 = zext i8 %174 to i32
  %and396 = and i32 %conv395, 192
  %cmp397 = icmp ne i32 %and396, 128
  br i1 %cmp397, label %if.else.534, label %if.then.472

cond.false.399:                                   ; preds = %land.lhs.true.372
  %175 = load i64, i64* %pos_byte_next, align 8
  %176 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text400 = getelementptr inbounds %struct.buffer, %struct.buffer* %176, i32 0, i32 73
  %177 = load %struct.buffer_text*, %struct.buffer_text** %text400, align 8
  %z_byte401 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %177, i32 0, i32 4
  %178 = load i64, i64* %z_byte401, align 8
  %cmp402 = icmp slt i64 %175, %178
  br i1 %cmp402, label %land.lhs.true.404, label %lor.lhs.false.424

land.lhs.true.404:                                ; preds = %cond.false.399
  %179 = load i64, i64* %pos_byte_next, align 8
  %180 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text405 = getelementptr inbounds %struct.buffer, %struct.buffer* %180, i32 0, i32 73
  %181 = load %struct.buffer_text*, %struct.buffer_text** %text405, align 8
  %gpt_byte406 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %181, i32 0, i32 3
  %182 = load i64, i64* %gpt_byte406, align 8
  %cmp407 = icmp sge i64 %179, %182
  br i1 %cmp407, label %cond.true.409, label %cond.false.412

cond.true.409:                                    ; preds = %land.lhs.true.404
  %183 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text410 = getelementptr inbounds %struct.buffer, %struct.buffer* %183, i32 0, i32 73
  %184 = load %struct.buffer_text*, %struct.buffer_text** %text410, align 8
  %gap_size411 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %184, i32 0, i32 5
  %185 = load i64, i64* %gap_size411, align 8
  br label %cond.end.413

cond.false.412:                                   ; preds = %land.lhs.true.404
  br label %cond.end.413

cond.end.413:                                     ; preds = %cond.false.412, %cond.true.409
  %cond414 = phi i64 [ %185, %cond.true.409 ], [ 0, %cond.false.412 ]
  %186 = load i64, i64* %pos_byte_next, align 8
  %add415 = add nsw i64 %cond414, %186
  %187 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text416 = getelementptr inbounds %struct.buffer, %struct.buffer* %187, i32 0, i32 73
  %188 = load %struct.buffer_text*, %struct.buffer_text** %text416, align 8
  %beg417 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %188, i32 0, i32 0
  %189 = load i8*, i8** %beg417, align 8
  %add.ptr418 = getelementptr inbounds i8, i8* %189, i64 %add415
  %add.ptr419 = getelementptr inbounds i8, i8* %add.ptr418, i64 -1
  %190 = load i8, i8* %add.ptr419, align 1
  %conv420 = zext i8 %190 to i32
  %and421 = and i32 %conv420, 192
  %cmp422 = icmp ne i32 %and421, 128
  br i1 %cmp422, label %lor.lhs.false.424, label %if.then.472

lor.lhs.false.424:                                ; preds = %cond.end.413, %cond.false.399
  %191 = load i64, i64* %pos_byte, align 8
  %cmp425 = icmp sgt i64 %191, 1
  br i1 %cmp425, label %land.lhs.true.427, label %if.else.534

land.lhs.true.427:                                ; preds = %lor.lhs.false.424
  br i1 true, label %cond.true.428, label %cond.false.450

cond.true.428:                                    ; preds = %land.lhs.true.427
  %192 = load i64, i64* %pos_byte, align 8
  %sub429 = sub nsw i64 %192, 1
  %193 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text430 = getelementptr inbounds %struct.buffer, %struct.buffer* %193, i32 0, i32 73
  %194 = load %struct.buffer_text*, %struct.buffer_text** %text430, align 8
  %gpt_byte431 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %194, i32 0, i32 3
  %195 = load i64, i64* %gpt_byte431, align 8
  %cmp432 = icmp sge i64 %sub429, %195
  br i1 %cmp432, label %cond.true.434, label %cond.false.437

cond.true.434:                                    ; preds = %cond.true.428
  %196 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text435 = getelementptr inbounds %struct.buffer, %struct.buffer* %196, i32 0, i32 73
  %197 = load %struct.buffer_text*, %struct.buffer_text** %text435, align 8
  %gap_size436 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %197, i32 0, i32 5
  %198 = load i64, i64* %gap_size436, align 8
  br label %cond.end.438

cond.false.437:                                   ; preds = %cond.true.428
  br label %cond.end.438

cond.end.438:                                     ; preds = %cond.false.437, %cond.true.434
  %cond439 = phi i64 [ %198, %cond.true.434 ], [ 0, %cond.false.437 ]
  %199 = load i64, i64* %pos_byte, align 8
  %sub440 = sub nsw i64 %199, 1
  %add441 = add nsw i64 %cond439, %sub440
  %200 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text442 = getelementptr inbounds %struct.buffer, %struct.buffer* %200, i32 0, i32 73
  %201 = load %struct.buffer_text*, %struct.buffer_text** %text442, align 8
  %beg443 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %201, i32 0, i32 0
  %202 = load i8*, i8** %beg443, align 8
  %add.ptr444 = getelementptr inbounds i8, i8* %202, i64 %add441
  %add.ptr445 = getelementptr inbounds i8, i8* %add.ptr444, i64 -1
  %203 = load i8, i8* %add.ptr445, align 1
  %conv446 = zext i8 %203 to i32
  %add447 = add i32 %conv446, 0
  %cmp448 = icmp ult i32 %add447, 128
  br i1 %cmp448, label %if.else.534, label %if.then.472

cond.false.450:                                   ; preds = %land.lhs.true.427
  %204 = load i64, i64* %pos_byte, align 8
  %sub451 = sub nsw i64 %204, 1
  %205 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text452 = getelementptr inbounds %struct.buffer, %struct.buffer* %205, i32 0, i32 73
  %206 = load %struct.buffer_text*, %struct.buffer_text** %text452, align 8
  %gpt_byte453 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %206, i32 0, i32 3
  %207 = load i64, i64* %gpt_byte453, align 8
  %cmp454 = icmp sge i64 %sub451, %207
  br i1 %cmp454, label %cond.true.456, label %cond.false.459

cond.true.456:                                    ; preds = %cond.false.450
  %208 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text457 = getelementptr inbounds %struct.buffer, %struct.buffer* %208, i32 0, i32 73
  %209 = load %struct.buffer_text*, %struct.buffer_text** %text457, align 8
  %gap_size458 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %209, i32 0, i32 5
  %210 = load i64, i64* %gap_size458, align 8
  br label %cond.end.460

cond.false.459:                                   ; preds = %cond.false.450
  br label %cond.end.460

cond.end.460:                                     ; preds = %cond.false.459, %cond.true.456
  %cond461 = phi i64 [ %210, %cond.true.456 ], [ 0, %cond.false.459 ]
  %211 = load i64, i64* %pos_byte, align 8
  %sub462 = sub nsw i64 %211, 1
  %add463 = add nsw i64 %cond461, %sub462
  %212 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text464 = getelementptr inbounds %struct.buffer, %struct.buffer* %212, i32 0, i32 73
  %213 = load %struct.buffer_text*, %struct.buffer_text** %text464, align 8
  %beg465 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %213, i32 0, i32 0
  %214 = load i8*, i8** %beg465, align 8
  %add.ptr466 = getelementptr inbounds i8, i8* %214, i64 %add463
  %add.ptr467 = getelementptr inbounds i8, i8* %add.ptr466, i64 -1
  %215 = load i8, i8* %add.ptr467, align 1
  %conv468 = zext i8 %215 to i64
  %add469 = add i64 %conv468, 0
  %cmp470 = icmp ult i64 %add469, 128
  br i1 %cmp470, label %if.else.534, label %if.then.472

if.then.472:                                      ; preds = %cond.end.460, %cond.end.438, %cond.end.413, %cond.end.388
  %216 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %undo_list_473 = getelementptr inbounds %struct.buffer, %struct.buffer* %216, i32 0, i32 98
  %217 = load i64, i64* %undo_list_473, align 8
  store i64 %217, i64* %tem, align 8
  %arraydecay474 = getelementptr inbounds [5 x i8], [5 x i8]* %tostr, i32 0, i32 0
  %218 = load i64, i64* %len, align 8
  %call475 = call i64 @make_multibyte_string(i8* %arraydecay474, i64 1, i64 %218)
  store i64 %call475, i64* %string, align 8
  %219 = load i64, i64* %pos, align 8
  %220 = load i64, i64* %pos, align 8
  %add476 = add nsw i64 %220, 1
  %221 = load i64, i64* %string, align 8
  call void @replace_range(i64 %219, i64 %add476, i64 %221, i1 zeroext false, i1 zeroext false, i1 zeroext true, i1 zeroext false)
  %222 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %223 = load i64, i64* %pos, align 8
  %call477 = call i64 @buf_charpos_to_bytepos(%struct.buffer* %222, i64 %223)
  store i64 %call477, i64* %pos_byte_next, align 8
  %224 = load i64, i64* %pos_byte_next, align 8
  %225 = load i64, i64* %pos_byte, align 8
  %cmp478 = icmp sgt i64 %224, %225
  br i1 %cmp478, label %if.then.480, label %if.else.481

if.then.480:                                      ; preds = %if.then.472
  %226 = load i64, i64* %pos, align 8
  %dec = add nsw i64 %226, -1
  store i64 %dec, i64* %pos, align 8
  br label %if.end.528

if.else.481:                                      ; preds = %if.then.472
  br label %do.body.482

do.body.482:                                      ; preds = %if.else.481
  %227 = load i64, i64* %pos_byte_next, align 8
  %228 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text484 = getelementptr inbounds %struct.buffer, %struct.buffer* %228, i32 0, i32 73
  %229 = load %struct.buffer_text*, %struct.buffer_text** %text484, align 8
  %gpt_byte485 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %229, i32 0, i32 3
  %230 = load i64, i64* %gpt_byte485, align 8
  %cmp486 = icmp sge i64 %227, %230
  br i1 %cmp486, label %cond.true.488, label %cond.false.491

cond.true.488:                                    ; preds = %do.body.482
  %231 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text489 = getelementptr inbounds %struct.buffer, %struct.buffer* %231, i32 0, i32 73
  %232 = load %struct.buffer_text*, %struct.buffer_text** %text489, align 8
  %gap_size490 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %232, i32 0, i32 5
  %233 = load i64, i64* %gap_size490, align 8
  br label %cond.end.492

cond.false.491:                                   ; preds = %do.body.482
  br label %cond.end.492

cond.end.492:                                     ; preds = %cond.false.491, %cond.true.488
  %cond493 = phi i64 [ %233, %cond.true.488 ], [ 0, %cond.false.491 ]
  %234 = load i64, i64* %pos_byte_next, align 8
  %add494 = add nsw i64 %cond493, %234
  %235 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text495 = getelementptr inbounds %struct.buffer, %struct.buffer* %235, i32 0, i32 73
  %236 = load %struct.buffer_text*, %struct.buffer_text** %text495, align 8
  %beg496 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %236, i32 0, i32 0
  %237 = load i8*, i8** %beg496, align 8
  %add.ptr497 = getelementptr inbounds i8, i8* %237, i64 %add494
  %add.ptr498 = getelementptr inbounds i8, i8* %add.ptr497, i64 -1
  store i8* %add.ptr498, i8** %chp483, align 8
  %238 = load i8*, i8** %chp483, align 8
  %239 = load i8, i8* %238, align 1
  %conv499 = zext i8 %239 to i32
  %and500 = and i32 %conv499, 128
  %tobool501 = icmp ne i32 %and500, 0
  br i1 %tobool501, label %cond.false.503, label %cond.true.502

cond.true.502:                                    ; preds = %cond.end.492
  br label %cond.end.523

cond.false.503:                                   ; preds = %cond.end.492
  %240 = load i8*, i8** %chp483, align 8
  %241 = load i8, i8* %240, align 1
  %conv504 = zext i8 %241 to i32
  %and505 = and i32 %conv504, 32
  %tobool506 = icmp ne i32 %and505, 0
  br i1 %tobool506, label %cond.false.508, label %cond.true.507

cond.true.507:                                    ; preds = %cond.false.503
  br label %cond.end.521

cond.false.508:                                   ; preds = %cond.false.503
  %242 = load i8*, i8** %chp483, align 8
  %243 = load i8, i8* %242, align 1
  %conv509 = zext i8 %243 to i32
  %and510 = and i32 %conv509, 16
  %tobool511 = icmp ne i32 %and510, 0
  br i1 %tobool511, label %cond.false.513, label %cond.true.512

cond.true.512:                                    ; preds = %cond.false.508
  br label %cond.end.519

cond.false.513:                                   ; preds = %cond.false.508
  %244 = load i8*, i8** %chp483, align 8
  %245 = load i8, i8* %244, align 1
  %conv514 = zext i8 %245 to i32
  %and515 = and i32 %conv514, 8
  %tobool516 = icmp ne i32 %and515, 0
  %lnot517 = xor i1 %tobool516, true
  %cond518 = select i1 %lnot517, i32 4, i32 5
  br label %cond.end.519

cond.end.519:                                     ; preds = %cond.false.513, %cond.true.512
  %cond520 = phi i32 [ 3, %cond.true.512 ], [ %cond518, %cond.false.513 ]
  br label %cond.end.521

cond.end.521:                                     ; preds = %cond.end.519, %cond.true.507
  %cond522 = phi i32 [ 2, %cond.true.507 ], [ %cond520, %cond.end.519 ]
  br label %cond.end.523

cond.end.523:                                     ; preds = %cond.end.521, %cond.true.502
  %cond524 = phi i32 [ 1, %cond.true.502 ], [ %cond522, %cond.end.521 ]
  %conv525 = sext i32 %cond524 to i64
  %246 = load i64, i64* %pos_byte_next, align 8
  %add526 = add nsw i64 %246, %conv525
  store i64 %add526, i64* %pos_byte_next, align 8
  br label %do.end.527

do.end.527:                                       ; preds = %cond.end.523
  br label %if.end.528

if.end.528:                                       ; preds = %do.end.527, %if.then.480
  %247 = load i64, i64* %noundo.addr, align 8
  %call529 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp530 = icmp eq i64 %247, %call529
  br i1 %cmp530, label %if.end.533, label %if.then.532

if.then.532:                                      ; preds = %if.end.528
  %248 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %249 = load i64, i64* %tem, align 8
  call void @bset_undo_list(%struct.buffer* %248, i64 %249)
  br label %if.end.533

if.end.533:                                       ; preds = %if.then.532, %if.end.528
  br label %if.end.544

if.else.534:                                      ; preds = %cond.end.460, %cond.end.438, %lor.lhs.false.424, %cond.end.388, %cond.true.375, %if.end.370
  %250 = load i64, i64* %noundo.addr, align 8
  %call535 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp536 = icmp eq i64 %250, %call535
  br i1 %cmp536, label %if.then.538, label %if.end.539

if.then.538:                                      ; preds = %if.else.534
  %251 = load i64, i64* %pos, align 8
  call void @record_change(i64 %251, i64 1)
  br label %if.end.539

if.end.539:                                       ; preds = %if.then.538, %if.else.534
  store i64 0, i64* %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end.539
  %252 = load i64, i64* %i, align 8
  %253 = load i64, i64* %len, align 8
  %cmp540 = icmp slt i64 %252, %253
  br i1 %cmp540, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %254 = load i64, i64* %i, align 8
  %arrayidx542 = getelementptr inbounds [5 x i8], [5 x i8]* %tostr, i32 0, i64 %254
  %255 = load i8, i8* %arrayidx542, align 1
  %256 = load i8*, i8** %p, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %256, i32 1
  store i8* %incdec.ptr, i8** %p, align 8
  store i8 %255, i8* %256, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %257 = load i64, i64* %i, align 8
  %inc543 = add nsw i64 %257, 1
  store i64 %inc543, i64* %i, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end.544

if.end.544:                                       ; preds = %for.end, %if.end.533
  %258 = load i64, i64* %pos, align 8
  %add545 = add nsw i64 %258, 1
  store i64 %add545, i64* %last_changed, align 8
  br label %if.end.546

if.end.546:                                       ; preds = %if.end.544, %lor.lhs.false.330, %lor.lhs.false.320, %lor.lhs.false, %land.lhs.true.301, %if.end.298
  %259 = load i64, i64* %pos_byte_next, align 8
  store i64 %259, i64* %pos_byte, align 8
  %260 = load i64, i64* %pos, align 8
  %inc547 = add nsw i64 %260, 1
  store i64 %inc547, i64* %pos, align 8
  br label %while.body

while.end:                                        ; preds = %if.then.237
  %261 = load i64, i64* %changed, align 8
  %cmp548 = icmp sgt i64 %261, 0
  br i1 %cmp548, label %if.then.550, label %if.end.553

if.then.550:                                      ; preds = %while.end
  %262 = load i64, i64* %changed, align 8
  %263 = load i64, i64* %last_changed, align 8
  %264 = load i64, i64* %changed, align 8
  %sub551 = sub nsw i64 %263, %264
  %265 = load i64, i64* %last_changed, align 8
  %266 = load i64, i64* %changed, align 8
  %sub552 = sub nsw i64 %265, %266
  call void @signal_after_change(i64 %262, i64 %sub551, i64 %sub552)
  %267 = load i64, i64* %changed, align 8
  %268 = load i64, i64* %last_changed, align 8
  call void @update_compositions(i64 %267, i64 %268, i32 7)
  br label %if.end.553

if.end.553:                                       ; preds = %if.then.550, %while.end
  %269 = load i64, i64* %count, align 8
  %call554 = call i64 @builtin_lisp_symbol(i32 0)
  %call555 = call i64 @unbind_to(i64 %269, i64 %call554)
  %call556 = call i64 @builtin_lisp_symbol(i32 0)
  ret i64 %call556
}

; Function Attrs: nounwind uwtable
define internal void @subst_char_in_region_unwind(i64 %arg) #0 {
entry:
  %arg.addr = alloca i64, align 8
  store i64 %arg, i64* %arg.addr, align 8
  %0 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %1 = load i64, i64* %arg.addr, align 8
  call void @bset_undo_list(%struct.buffer* %0, i64 %1)
  ret void
}

declare void @bset_undo_list(%struct.buffer*, i64) #1

; Function Attrs: nounwind uwtable
define internal void @subst_char_in_region_unwind_1(i64 %arg) #0 {
entry:
  %arg.addr = alloca i64, align 8
  store i64 %arg, i64* %arg.addr, align 8
  %0 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %1 = load i64, i64* %arg.addr, align 8
  call void @bset_filename(%struct.buffer* %0, i64 %1)
  ret void
}

declare void @bset_filename(%struct.buffer*, i64) #1

declare void @modify_text(i64, i64) #1

declare i64 @make_multibyte_string(i8*, i64, i64) #1

declare void @replace_range(i64, i64, i64, i1 zeroext, i1 zeroext, i1 zeroext, i1 zeroext) #1

declare void @record_change(i64, i64) #1

declare void @signal_after_change(i64, i64, i64) #1

declare void @update_compositions(i64, i64, i32) #1

; Function Attrs: nounwind uwtable
define i64 @Ftranslate_region_internal(i64 %start, i64 %end, i64 %table) #0 {
entry:
  %start.addr = alloca i64, align 8
  %end.addr = alloca i64, align 8
  %table.addr = alloca i64, align 8
  %tt = alloca i8*, align 8
  %nc = alloca i32, align 4
  %cnt = alloca i32, align 4
  %size = alloca i64, align 8
  %pos = alloca i64, align 8
  %pos_byte = alloca i64, align 8
  %end_pos = alloca i64, align 8
  %multibyte = alloca i8, align 1
  %string_multibyte = alloca i8, align 1
  %p = alloca i8*, align 8
  %str = alloca i8*, align 8
  %buf = alloca [5 x i8], align 1
  %len = alloca i32, align 4
  %str_len = alloca i32, align 4
  %oc = alloca i32, align 4
  %val = alloca i64, align 8
  %string = alloca i64, align 8
  %string284 = alloca i64, align 8
  store i64 %start, i64* %start.addr, align 8
  store i64 %end, i64* %end.addr, align 8
  store i64 %table, i64* %table.addr, align 8
  %0 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %enable_multibyte_characters_ = getelementptr inbounds %struct.buffer, %struct.buffer* %0, i32 0, i32 39
  %1 = load i64, i64* %enable_multibyte_characters_, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %1, %call
  %lnot = xor i1 %cmp, true
  %frombool = zext i1 %lnot to i8
  store i8 %frombool, i8* %multibyte, align 1
  call void @validate_region(i64* %start.addr, i64* %end.addr)
  %2 = load i64, i64* %table.addr, align 8
  %call1 = call zeroext i1 @CHAR_TABLE_P(i64 %2)
  br i1 %call1, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load i64, i64* %table.addr, align 8
  %call2 = call %struct.Lisp_Char_Table* @XCHAR_TABLE(i64 %3)
  %purpose = getelementptr inbounds %struct.Lisp_Char_Table, %struct.Lisp_Char_Table* %call2, i32 0, i32 3
  %4 = load i64, i64* %purpose, align 8
  %call3 = call i64 @builtin_lisp_symbol(i32 934)
  %cmp4 = icmp eq i64 %4, %call3
  br i1 %cmp4, label %if.end, label %if.then.5

if.then.5:                                        ; preds = %if.then
  call void (i8*, ...) @error(i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.13, i32 0, i32 0)) #9
  unreachable

if.end:                                           ; preds = %if.then
  store i64 4194303, i64* %size, align 8
  store i8* null, i8** %tt, align 8
  br label %if.end.18

if.else:                                          ; preds = %entry
  %5 = load i64, i64* %table.addr, align 8
  call void @CHECK_STRING(i64 %5)
  %6 = load i8, i8* %multibyte, align 1
  %tobool = trunc i8 %6 to i1
  br i1 %tobool, label %if.end.11, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.else
  %7 = load i64, i64* %table.addr, align 8
  %call6 = call i64 @SCHARS(i64 %7)
  %8 = load i64, i64* %table.addr, align 8
  %call7 = call i64 @SBYTES(i64 %8)
  %cmp8 = icmp slt i64 %call6, %call7
  br i1 %cmp8, label %if.then.9, label %if.end.11

if.then.9:                                        ; preds = %land.lhs.true
  %9 = load i64, i64* %table.addr, align 8
  %call10 = call i64 @string_make_unibyte(i64 %9)
  store i64 %call10, i64* %table.addr, align 8
  br label %if.end.11

if.end.11:                                        ; preds = %if.then.9, %land.lhs.true, %if.else
  %10 = load i64, i64* %table.addr, align 8
  %call12 = call i64 @SCHARS(i64 %10)
  %11 = load i64, i64* %table.addr, align 8
  %call13 = call i64 @SBYTES(i64 %11)
  %cmp14 = icmp slt i64 %call12, %call13
  %frombool15 = zext i1 %cmp14 to i8
  store i8 %frombool15, i8* %string_multibyte, align 1
  %12 = load i64, i64* %table.addr, align 8
  %call16 = call i64 @SBYTES(i64 %12)
  store i64 %call16, i64* %size, align 8
  %13 = load i64, i64* %table.addr, align 8
  %call17 = call i8* @SDATA(i64 %13)
  store i8* %call17, i8** %tt, align 8
  br label %if.end.18

if.end.18:                                        ; preds = %if.end.11, %if.end
  %14 = load i64, i64* %start.addr, align 8
  %shr = ashr i64 %14, 2
  store i64 %shr, i64* %pos, align 8
  %15 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %16 = load i64, i64* %pos, align 8
  %call19 = call i64 @buf_charpos_to_bytepos(%struct.buffer* %15, i64 %16)
  store i64 %call19, i64* %pos_byte, align 8
  %17 = load i64, i64* %end.addr, align 8
  %shr20 = ashr i64 %17, 2
  store i64 %shr20, i64* %end_pos, align 8
  %18 = load i64, i64* %pos, align 8
  %19 = load i64, i64* %end_pos, align 8
  call void @modify_text(i64 %18, i64 %19)
  store i32 0, i32* %cnt, align 4
  br label %for.cond

for.cond:                                         ; preds = %if.end.326, %if.end.309, %if.then.294, %if.end.18
  %20 = load i64, i64* %pos, align 8
  %21 = load i64, i64* %end_pos, align 8
  %cmp21 = icmp slt i64 %20, %21
  br i1 %cmp21, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %22 = load i64, i64* %pos_byte, align 8
  %23 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text = getelementptr inbounds %struct.buffer, %struct.buffer* %23, i32 0, i32 73
  %24 = load %struct.buffer_text*, %struct.buffer_text** %text, align 8
  %gpt_byte = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %24, i32 0, i32 3
  %25 = load i64, i64* %gpt_byte, align 8
  %cmp22 = icmp sge i64 %22, %25
  br i1 %cmp22, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  %26 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text23 = getelementptr inbounds %struct.buffer, %struct.buffer* %26, i32 0, i32 73
  %27 = load %struct.buffer_text*, %struct.buffer_text** %text23, align 8
  %gap_size = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %27, i32 0, i32 5
  %28 = load i64, i64* %gap_size, align 8
  br label %cond.end

cond.false:                                       ; preds = %for.body
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %28, %cond.true ], [ 0, %cond.false ]
  %29 = load i64, i64* %pos_byte, align 8
  %add = add nsw i64 %cond, %29
  %30 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text24 = getelementptr inbounds %struct.buffer, %struct.buffer* %30, i32 0, i32 73
  %31 = load %struct.buffer_text*, %struct.buffer_text** %text24, align 8
  %beg = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %31, i32 0, i32 0
  %32 = load i8*, i8** %beg, align 8
  %add.ptr = getelementptr inbounds i8, i8* %32, i64 %add
  %add.ptr25 = getelementptr inbounds i8, i8* %add.ptr, i64 -1
  store i8* %add.ptr25, i8** %p, align 8
  %33 = load i8, i8* %multibyte, align 1
  %tobool26 = trunc i8 %33 to i1
  br i1 %tobool26, label %if.then.27, label %if.else.77

if.then.27:                                       ; preds = %cond.end
  %34 = load i8*, i8** %p, align 8
  %arrayidx = getelementptr inbounds i8, i8* %34, i64 0
  %35 = load i8, i8* %arrayidx, align 1
  %conv = zext i8 %35 to i32
  %and = and i32 %conv, 128
  %tobool28 = icmp ne i32 %and, 0
  br i1 %tobool28, label %cond.false.32, label %cond.true.29

cond.true.29:                                     ; preds = %if.then.27
  store i32 1, i32* %len, align 4
  %36 = load i8*, i8** %p, align 8
  %arrayidx30 = getelementptr inbounds i8, i8* %36, i64 0
  %37 = load i8, i8* %arrayidx30, align 1
  %conv31 = zext i8 %37 to i32
  br label %cond.end.75

cond.false.32:                                    ; preds = %if.then.27
  %38 = load i8*, i8** %p, align 8
  %arrayidx33 = getelementptr inbounds i8, i8* %38, i64 0
  %39 = load i8, i8* %arrayidx33, align 1
  %conv34 = zext i8 %39 to i32
  %and35 = and i32 %conv34, 32
  %tobool36 = icmp ne i32 %and35, 0
  br i1 %tobool36, label %cond.false.50, label %cond.true.37

cond.true.37:                                     ; preds = %cond.false.32
  store i32 2, i32* %len, align 4
  %40 = load i8*, i8** %p, align 8
  %arrayidx38 = getelementptr inbounds i8, i8* %40, i64 0
  %41 = load i8, i8* %arrayidx38, align 1
  %conv39 = zext i8 %41 to i32
  %and40 = and i32 %conv39, 31
  %shl = shl i32 %and40, 6
  %42 = load i8*, i8** %p, align 8
  %arrayidx41 = getelementptr inbounds i8, i8* %42, i64 1
  %43 = load i8, i8* %arrayidx41, align 1
  %conv42 = zext i8 %43 to i32
  %and43 = and i32 %conv42, 63
  %or = or i32 %shl, %and43
  %44 = load i8*, i8** %p, align 8
  %arrayidx44 = getelementptr inbounds i8, i8* %44, i64 0
  %45 = load i8, i8* %arrayidx44, align 1
  %conv45 = zext i8 %45 to i32
  %cmp46 = icmp slt i32 %conv45, 194
  %cond48 = select i1 %cmp46, i32 4194176, i32 0
  %add49 = add nsw i32 %or, %cond48
  br label %cond.end.73

cond.false.50:                                    ; preds = %cond.false.32
  %46 = load i8*, i8** %p, align 8
  %arrayidx51 = getelementptr inbounds i8, i8* %46, i64 0
  %47 = load i8, i8* %arrayidx51, align 1
  %conv52 = zext i8 %47 to i32
  %and53 = and i32 %conv52, 16
  %tobool54 = icmp ne i32 %and53, 0
  br i1 %tobool54, label %cond.false.69, label %cond.true.55

cond.true.55:                                     ; preds = %cond.false.50
  store i32 3, i32* %len, align 4
  %48 = load i8*, i8** %p, align 8
  %arrayidx56 = getelementptr inbounds i8, i8* %48, i64 0
  %49 = load i8, i8* %arrayidx56, align 1
  %conv57 = zext i8 %49 to i32
  %and58 = and i32 %conv57, 15
  %shl59 = shl i32 %and58, 12
  %50 = load i8*, i8** %p, align 8
  %arrayidx60 = getelementptr inbounds i8, i8* %50, i64 1
  %51 = load i8, i8* %arrayidx60, align 1
  %conv61 = zext i8 %51 to i32
  %and62 = and i32 %conv61, 63
  %shl63 = shl i32 %and62, 6
  %or64 = or i32 %shl59, %shl63
  %52 = load i8*, i8** %p, align 8
  %arrayidx65 = getelementptr inbounds i8, i8* %52, i64 2
  %53 = load i8, i8* %arrayidx65, align 1
  %conv66 = zext i8 %53 to i32
  %and67 = and i32 %conv66, 63
  %or68 = or i32 %or64, %and67
  br label %cond.end.71

cond.false.69:                                    ; preds = %cond.false.50
  %54 = load i8*, i8** %p, align 8
  %call70 = call i32 @string_char(i8* %54, i8** null, i32* %len)
  br label %cond.end.71

cond.end.71:                                      ; preds = %cond.false.69, %cond.true.55
  %cond72 = phi i32 [ %or68, %cond.true.55 ], [ %call70, %cond.false.69 ]
  br label %cond.end.73

cond.end.73:                                      ; preds = %cond.end.71, %cond.true.37
  %cond74 = phi i32 [ %add49, %cond.true.37 ], [ %cond72, %cond.end.71 ]
  br label %cond.end.75

cond.end.75:                                      ; preds = %cond.end.73, %cond.true.29
  %cond76 = phi i32 [ %conv31, %cond.true.29 ], [ %cond74, %cond.end.73 ]
  store i32 %cond76, i32* %oc, align 4
  br label %if.end.79

if.else.77:                                       ; preds = %cond.end
  %55 = load i8*, i8** %p, align 8
  %56 = load i8, i8* %55, align 1
  %conv78 = zext i8 %56 to i32
  store i32 %conv78, i32* %oc, align 4
  store i32 1, i32* %len, align 4
  br label %if.end.79

if.end.79:                                        ; preds = %if.else.77, %cond.end.75
  %57 = load i32, i32* %oc, align 4
  %conv80 = sext i32 %57 to i64
  %58 = load i64, i64* %size, align 8
  %cmp81 = icmp slt i64 %conv80, %58
  br i1 %cmp81, label %if.then.83, label %if.end.326

if.then.83:                                       ; preds = %if.end.79
  %59 = load i8*, i8** %tt, align 8
  %tobool84 = icmp ne i8* %59, null
  br i1 %tobool84, label %if.then.85, label %if.else.175

if.then.85:                                       ; preds = %if.then.83
  %60 = load i64, i64* %table.addr, align 8
  %call86 = call i8* @SDATA(i64 %60)
  store i8* %call86, i8** %tt, align 8
  %61 = load i8, i8* %string_multibyte, align 1
  %tobool87 = trunc i8 %61 to i1
  br i1 %tobool87, label %if.then.88, label %if.else.146

if.then.88:                                       ; preds = %if.then.85
  %62 = load i8*, i8** %tt, align 8
  %63 = load i64, i64* %table.addr, align 8
  %64 = load i32, i32* %oc, align 4
  %conv89 = sext i32 %64 to i64
  %call90 = call i64 @string_char_to_byte(i64 %63, i64 %conv89)
  %add.ptr91 = getelementptr inbounds i8, i8* %62, i64 %call90
  store i8* %add.ptr91, i8** %str, align 8
  %65 = load i8*, i8** %str, align 8
  %arrayidx92 = getelementptr inbounds i8, i8* %65, i64 0
  %66 = load i8, i8* %arrayidx92, align 1
  %conv93 = zext i8 %66 to i32
  %and94 = and i32 %conv93, 128
  %tobool95 = icmp ne i32 %and94, 0
  br i1 %tobool95, label %cond.false.99, label %cond.true.96

cond.true.96:                                     ; preds = %if.then.88
  store i32 1, i32* %str_len, align 4
  %67 = load i8*, i8** %str, align 8
  %arrayidx97 = getelementptr inbounds i8, i8* %67, i64 0
  %68 = load i8, i8* %arrayidx97, align 1
  %conv98 = zext i8 %68 to i32
  br label %cond.end.144

cond.false.99:                                    ; preds = %if.then.88
  %69 = load i8*, i8** %str, align 8
  %arrayidx100 = getelementptr inbounds i8, i8* %69, i64 0
  %70 = load i8, i8* %arrayidx100, align 1
  %conv101 = zext i8 %70 to i32
  %and102 = and i32 %conv101, 32
  %tobool103 = icmp ne i32 %and102, 0
  br i1 %tobool103, label %cond.false.119, label %cond.true.104

cond.true.104:                                    ; preds = %cond.false.99
  store i32 2, i32* %str_len, align 4
  %71 = load i8*, i8** %str, align 8
  %arrayidx105 = getelementptr inbounds i8, i8* %71, i64 0
  %72 = load i8, i8* %arrayidx105, align 1
  %conv106 = zext i8 %72 to i32
  %and107 = and i32 %conv106, 31
  %shl108 = shl i32 %and107, 6
  %73 = load i8*, i8** %str, align 8
  %arrayidx109 = getelementptr inbounds i8, i8* %73, i64 1
  %74 = load i8, i8* %arrayidx109, align 1
  %conv110 = zext i8 %74 to i32
  %and111 = and i32 %conv110, 63
  %or112 = or i32 %shl108, %and111
  %75 = load i8*, i8** %str, align 8
  %arrayidx113 = getelementptr inbounds i8, i8* %75, i64 0
  %76 = load i8, i8* %arrayidx113, align 1
  %conv114 = zext i8 %76 to i32
  %cmp115 = icmp slt i32 %conv114, 194
  %cond117 = select i1 %cmp115, i32 4194176, i32 0
  %add118 = add nsw i32 %or112, %cond117
  br label %cond.end.142

cond.false.119:                                   ; preds = %cond.false.99
  %77 = load i8*, i8** %str, align 8
  %arrayidx120 = getelementptr inbounds i8, i8* %77, i64 0
  %78 = load i8, i8* %arrayidx120, align 1
  %conv121 = zext i8 %78 to i32
  %and122 = and i32 %conv121, 16
  %tobool123 = icmp ne i32 %and122, 0
  br i1 %tobool123, label %cond.false.138, label %cond.true.124

cond.true.124:                                    ; preds = %cond.false.119
  store i32 3, i32* %str_len, align 4
  %79 = load i8*, i8** %str, align 8
  %arrayidx125 = getelementptr inbounds i8, i8* %79, i64 0
  %80 = load i8, i8* %arrayidx125, align 1
  %conv126 = zext i8 %80 to i32
  %and127 = and i32 %conv126, 15
  %shl128 = shl i32 %and127, 12
  %81 = load i8*, i8** %str, align 8
  %arrayidx129 = getelementptr inbounds i8, i8* %81, i64 1
  %82 = load i8, i8* %arrayidx129, align 1
  %conv130 = zext i8 %82 to i32
  %and131 = and i32 %conv130, 63
  %shl132 = shl i32 %and131, 6
  %or133 = or i32 %shl128, %shl132
  %83 = load i8*, i8** %str, align 8
  %arrayidx134 = getelementptr inbounds i8, i8* %83, i64 2
  %84 = load i8, i8* %arrayidx134, align 1
  %conv135 = zext i8 %84 to i32
  %and136 = and i32 %conv135, 63
  %or137 = or i32 %or133, %and136
  br label %cond.end.140

cond.false.138:                                   ; preds = %cond.false.119
  %85 = load i8*, i8** %str, align 8
  %call139 = call i32 @string_char(i8* %85, i8** null, i32* %str_len)
  br label %cond.end.140

cond.end.140:                                     ; preds = %cond.false.138, %cond.true.124
  %cond141 = phi i32 [ %or137, %cond.true.124 ], [ %call139, %cond.false.138 ]
  br label %cond.end.142

cond.end.142:                                     ; preds = %cond.end.140, %cond.true.104
  %cond143 = phi i32 [ %add118, %cond.true.104 ], [ %cond141, %cond.end.140 ]
  br label %cond.end.144

cond.end.144:                                     ; preds = %cond.end.142, %cond.true.96
  %cond145 = phi i32 [ %conv98, %cond.true.96 ], [ %cond143, %cond.end.142 ]
  store i32 %cond145, i32* %nc, align 4
  br label %if.end.174

if.else.146:                                      ; preds = %if.then.85
  %86 = load i32, i32* %oc, align 4
  %idxprom = sext i32 %86 to i64
  %87 = load i8*, i8** %tt, align 8
  %arrayidx147 = getelementptr inbounds i8, i8* %87, i64 %idxprom
  %88 = load i8, i8* %arrayidx147, align 1
  %conv148 = zext i8 %88 to i32
  store i32 %conv148, i32* %nc, align 4
  br i1 true, label %cond.true.149, label %cond.false.153

cond.true.149:                                    ; preds = %if.else.146
  %89 = load i32, i32* %nc, align 4
  %add150 = add i32 %89, 0
  %cmp151 = icmp ult i32 %add150, 128
  br i1 %cmp151, label %if.else.171, label %land.lhs.true.158

cond.false.153:                                   ; preds = %if.else.146
  %90 = load i32, i32* %nc, align 4
  %conv154 = sext i32 %90 to i64
  %add155 = add i64 %conv154, 0
  %cmp156 = icmp ult i64 %add155, 128
  br i1 %cmp156, label %if.else.171, label %land.lhs.true.158

land.lhs.true.158:                                ; preds = %cond.false.153, %cond.true.149
  %91 = load i8, i8* %multibyte, align 1
  %tobool159 = trunc i8 %91 to i1
  br i1 %tobool159, label %if.then.161, label %if.else.171

if.then.161:                                      ; preds = %land.lhs.true.158
  %92 = load i32, i32* %nc, align 4
  %shr162 = ashr i32 %92, 6
  %and163 = and i32 %shr162, 1
  %or164 = or i32 192, %and163
  %conv165 = trunc i32 %or164 to i8
  %arrayidx166 = getelementptr inbounds [5 x i8], [5 x i8]* %buf, i32 0, i64 0
  store i8 %conv165, i8* %arrayidx166, align 1
  %93 = load i32, i32* %nc, align 4
  %and167 = and i32 %93, 63
  %or168 = or i32 128, %and167
  %conv169 = trunc i32 %or168 to i8
  %arrayidx170 = getelementptr inbounds [5 x i8], [5 x i8]* %buf, i32 0, i64 1
  store i8 %conv169, i8* %arrayidx170, align 1
  store i32 2, i32* %str_len, align 4
  %arraydecay = getelementptr inbounds [5 x i8], [5 x i8]* %buf, i32 0, i32 0
  store i8* %arraydecay, i8** %str, align 8
  br label %if.end.173

if.else.171:                                      ; preds = %land.lhs.true.158, %cond.false.153, %cond.true.149
  store i32 1, i32* %str_len, align 4
  %94 = load i8*, i8** %tt, align 8
  %95 = load i32, i32* %oc, align 4
  %idx.ext = sext i32 %95 to i64
  %add.ptr172 = getelementptr inbounds i8, i8* %94, i64 %idx.ext
  store i8* %add.ptr172, i8** %str, align 8
  br label %if.end.173

if.end.173:                                       ; preds = %if.else.171, %if.then.161
  br label %if.end.174

if.end.174:                                       ; preds = %if.end.173, %cond.end.144
  br label %if.end.261

if.else.175:                                      ; preds = %if.then.83
  %96 = load i32, i32* %oc, align 4
  store i32 %96, i32* %nc, align 4
  %97 = load i64, i64* %table.addr, align 8
  %98 = load i32, i32* %oc, align 4
  %call176 = call i64 @CHAR_TABLE_REF(i64 %97, i32 %98)
  store i64 %call176, i64* %val, align 8
  %99 = load i64, i64* %val, align 8
  %call177 = call zeroext i1 @NATNUMP(i64 %99)
  br i1 %call177, label %land.lhs.true.179, label %if.else.251

land.lhs.true.179:                                ; preds = %if.else.175
  %100 = load i64, i64* %val, align 8
  %shr180 = ashr i64 %100, 2
  %cmp181 = icmp sle i64 %shr180, 4194303
  br i1 %cmp181, label %if.then.183, label %if.else.251

if.then.183:                                      ; preds = %land.lhs.true.179
  %101 = load i64, i64* %val, align 8
  %shr184 = ashr i64 %101, 2
  %conv185 = trunc i64 %shr184 to i32
  store i32 %conv185, i32* %nc, align 4
  br i1 true, label %cond.true.186, label %cond.false.190

cond.true.186:                                    ; preds = %if.then.183
  %102 = load i32, i32* %nc, align 4
  %add187 = add i32 %102, 0
  %cmp188 = icmp ule i32 %add187, 127
  br i1 %cmp188, label %cond.true.195, label %cond.false.198

cond.false.190:                                   ; preds = %if.then.183
  %103 = load i32, i32* %nc, align 4
  %conv191 = sext i32 %103 to i64
  %add192 = add i64 %conv191, 0
  %cmp193 = icmp ule i64 %add192, 127
  br i1 %cmp193, label %cond.true.195, label %cond.false.198

cond.true.195:                                    ; preds = %cond.false.190, %cond.true.186
  %104 = load i32, i32* %nc, align 4
  %conv196 = trunc i32 %104 to i8
  %arrayidx197 = getelementptr inbounds [5 x i8], [5 x i8]* %buf, i32 0, i64 0
  store i8 %conv196, i8* %arrayidx197, align 1
  br label %cond.end.248

cond.false.198:                                   ; preds = %cond.false.190, %cond.true.186
  br i1 true, label %cond.true.199, label %cond.false.203

cond.true.199:                                    ; preds = %cond.false.198
  %105 = load i32, i32* %nc, align 4
  %add200 = add i32 %105, 0
  %cmp201 = icmp ule i32 %add200, 2047
  br i1 %cmp201, label %cond.true.208, label %cond.false.217

cond.false.203:                                   ; preds = %cond.false.198
  %106 = load i32, i32* %nc, align 4
  %conv204 = sext i32 %106 to i64
  %add205 = add i64 %conv204, 0
  %cmp206 = icmp ule i64 %add205, 2047
  br i1 %cmp206, label %cond.true.208, label %cond.false.217

cond.true.208:                                    ; preds = %cond.false.203, %cond.true.199
  %107 = load i32, i32* %nc, align 4
  %shr209 = ashr i32 %107, 6
  %or210 = or i32 192, %shr209
  %conv211 = trunc i32 %or210 to i8
  %arrayidx212 = getelementptr inbounds [5 x i8], [5 x i8]* %buf, i32 0, i64 0
  store i8 %conv211, i8* %arrayidx212, align 1
  %108 = load i32, i32* %nc, align 4
  %and213 = and i32 %108, 63
  %or214 = or i32 128, %and213
  %conv215 = trunc i32 %or214 to i8
  %arrayidx216 = getelementptr inbounds [5 x i8], [5 x i8]* %buf, i32 0, i64 1
  store i8 %conv215, i8* %arrayidx216, align 1
  br label %cond.end.246

cond.false.217:                                   ; preds = %cond.false.203, %cond.true.199
  br i1 true, label %cond.true.218, label %cond.false.222

cond.true.218:                                    ; preds = %cond.false.217
  %109 = load i32, i32* %nc, align 4
  %add219 = add i32 %109, 0
  %cmp220 = icmp ule i32 %add219, 65535
  br i1 %cmp220, label %cond.true.227, label %cond.false.241

cond.false.222:                                   ; preds = %cond.false.217
  %110 = load i32, i32* %nc, align 4
  %conv223 = sext i32 %110 to i64
  %add224 = add i64 %conv223, 0
  %cmp225 = icmp ule i64 %add224, 65535
  br i1 %cmp225, label %cond.true.227, label %cond.false.241

cond.true.227:                                    ; preds = %cond.false.222, %cond.true.218
  %111 = load i32, i32* %nc, align 4
  %shr228 = ashr i32 %111, 12
  %or229 = or i32 224, %shr228
  %conv230 = trunc i32 %or229 to i8
  %arrayidx231 = getelementptr inbounds [5 x i8], [5 x i8]* %buf, i32 0, i64 0
  store i8 %conv230, i8* %arrayidx231, align 1
  %112 = load i32, i32* %nc, align 4
  %shr232 = ashr i32 %112, 6
  %and233 = and i32 %shr232, 63
  %or234 = or i32 128, %and233
  %conv235 = trunc i32 %or234 to i8
  %arrayidx236 = getelementptr inbounds [5 x i8], [5 x i8]* %buf, i32 0, i64 1
  store i8 %conv235, i8* %arrayidx236, align 1
  %113 = load i32, i32* %nc, align 4
  %and237 = and i32 %113, 63
  %or238 = or i32 128, %and237
  %conv239 = trunc i32 %or238 to i8
  %arrayidx240 = getelementptr inbounds [5 x i8], [5 x i8]* %buf, i32 0, i64 2
  store i8 %conv239, i8* %arrayidx240, align 1
  br label %cond.end.244

cond.false.241:                                   ; preds = %cond.false.222, %cond.true.218
  %114 = load i32, i32* %nc, align 4
  %arraydecay242 = getelementptr inbounds [5 x i8], [5 x i8]* %buf, i32 0, i32 0
  %call243 = call i32 @char_string(i32 %114, i8* %arraydecay242)
  br label %cond.end.244

cond.end.244:                                     ; preds = %cond.false.241, %cond.true.227
  %cond245 = phi i32 [ 3, %cond.true.227 ], [ %call243, %cond.false.241 ]
  br label %cond.end.246

cond.end.246:                                     ; preds = %cond.end.244, %cond.true.208
  %cond247 = phi i32 [ 2, %cond.true.208 ], [ %cond245, %cond.end.244 ]
  br label %cond.end.248

cond.end.248:                                     ; preds = %cond.end.246, %cond.true.195
  %cond249 = phi i32 [ 1, %cond.true.195 ], [ %cond247, %cond.end.246 ]
  store i32 %cond249, i32* %str_len, align 4
  %arraydecay250 = getelementptr inbounds [5 x i8], [5 x i8]* %buf, i32 0, i32 0
  store i8* %arraydecay250, i8** %str, align 8
  br label %if.end.260

if.else.251:                                      ; preds = %land.lhs.true.179, %if.else.175
  %115 = load i64, i64* %val, align 8
  %call252 = call zeroext i1 @VECTORP(i64 %115)
  br i1 %call252, label %if.then.258, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else.251
  %116 = load i64, i64* %val, align 8
  %and254 = and i64 %116, 7
  %conv255 = trunc i64 %and254 to i32
  %cmp256 = icmp eq i32 %conv255, 3
  br i1 %cmp256, label %if.then.258, label %if.end.259

if.then.258:                                      ; preds = %lor.lhs.false, %if.else.251
  store i32 -1, i32* %nc, align 4
  br label %if.end.259

if.end.259:                                       ; preds = %if.then.258, %lor.lhs.false
  br label %if.end.260

if.end.260:                                       ; preds = %if.end.259, %cond.end.248
  br label %if.end.261

if.end.261:                                       ; preds = %if.end.260, %if.end.174
  %117 = load i32, i32* %nc, align 4
  %118 = load i32, i32* %oc, align 4
  %cmp262 = icmp ne i32 %117, %118
  br i1 %cmp262, label %land.lhs.true.264, label %if.else.280

land.lhs.true.264:                                ; preds = %if.end.261
  %119 = load i32, i32* %nc, align 4
  %cmp265 = icmp sge i32 %119, 0
  br i1 %cmp265, label %if.then.267, label %if.else.280

if.then.267:                                      ; preds = %land.lhs.true.264
  %120 = load i32, i32* %len, align 4
  %121 = load i32, i32* %str_len, align 4
  %cmp268 = icmp ne i32 %120, %121
  br i1 %cmp268, label %if.then.270, label %if.else.274

if.then.270:                                      ; preds = %if.then.267
  %122 = load i8*, i8** %str, align 8
  %123 = load i32, i32* %str_len, align 4
  %conv271 = sext i32 %123 to i64
  %call272 = call i64 @make_multibyte_string(i8* %122, i64 1, i64 %conv271)
  store i64 %call272, i64* %string, align 8
  %124 = load i64, i64* %pos, align 8
  %125 = load i64, i64* %pos, align 8
  %add273 = add nsw i64 %125, 1
  %126 = load i64, i64* %string, align 8
  call void @replace_range(i64 %124, i64 %add273, i64 %126, i1 zeroext true, i1 zeroext false, i1 zeroext true, i1 zeroext false)
  %127 = load i32, i32* %str_len, align 4
  store i32 %127, i32* %len, align 4
  br label %if.end.279

if.else.274:                                      ; preds = %if.then.267
  %128 = load i64, i64* %pos, align 8
  call void @record_change(i64 %128, i64 1)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.else.274
  %129 = load i32, i32* %str_len, align 4
  %dec = add nsw i32 %129, -1
  store i32 %dec, i32* %str_len, align 4
  %cmp275 = icmp sgt i32 %129, 0
  br i1 %cmp275, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %130 = load i8*, i8** %str, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %130, i32 1
  store i8* %incdec.ptr, i8** %str, align 8
  %131 = load i8, i8* %130, align 1
  %132 = load i8*, i8** %p, align 8
  %incdec.ptr277 = getelementptr inbounds i8, i8* %132, i32 1
  store i8* %incdec.ptr277, i8** %p, align 8
  store i8 %131, i8* %132, align 1
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %133 = load i64, i64* %pos, align 8
  call void @signal_after_change(i64 %133, i64 1, i64 1)
  %134 = load i64, i64* %pos, align 8
  %135 = load i64, i64* %pos, align 8
  %add278 = add nsw i64 %135, 1
  call void @update_compositions(i64 %134, i64 %add278, i32 3)
  br label %if.end.279

if.end.279:                                       ; preds = %while.end, %if.then.270
  %136 = load i32, i32* %cnt, align 4
  %inc = add nsw i32 %136, 1
  store i32 %inc, i32* %cnt, align 4
  br label %if.end.325

if.else.280:                                      ; preds = %land.lhs.true.264, %if.end.261
  %137 = load i32, i32* %nc, align 4
  %cmp281 = icmp slt i32 %137, 0
  br i1 %cmp281, label %if.then.283, label %if.end.324

if.then.283:                                      ; preds = %if.else.280
  %138 = load i64, i64* %val, align 8
  %and285 = and i64 %138, 7
  %conv286 = trunc i64 %and285 to i32
  %cmp287 = icmp eq i32 %conv286, 3
  br i1 %cmp287, label %if.then.289, label %if.else.302

if.then.289:                                      ; preds = %if.then.283
  %139 = load i64, i64* %pos, align 8
  %140 = load i64, i64* %pos_byte, align 8
  %141 = load i64, i64* %end_pos, align 8
  %142 = load i64, i64* %val, align 8
  %call290 = call i64 @check_translation(i64 %139, i64 %140, i64 %141, i64 %142)
  store i64 %call290, i64* %val, align 8
  %143 = load i64, i64* %val, align 8
  %call291 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp292 = icmp eq i64 %143, %call291
  br i1 %cmp292, label %if.then.294, label %if.end.298

if.then.294:                                      ; preds = %if.then.289
  %144 = load i32, i32* %len, align 4
  %conv295 = sext i32 %144 to i64
  %145 = load i64, i64* %pos_byte, align 8
  %add296 = add nsw i64 %145, %conv295
  store i64 %add296, i64* %pos_byte, align 8
  %146 = load i64, i64* %pos, align 8
  %inc297 = add nsw i64 %146, 1
  store i64 %inc297, i64* %pos, align 8
  br label %for.cond

if.end.298:                                       ; preds = %if.then.289
  %147 = load i64, i64* %val, align 8
  %sub = sub nsw i64 %147, 3
  %148 = inttoptr i64 %sub to i8*
  %149 = bitcast i8* %148 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %149, i32 0, i32 0
  %150 = load i64, i64* %car, align 8
  %call299 = call i64 @ASIZE(i64 %150)
  %conv300 = trunc i64 %call299 to i32
  store i32 %conv300, i32* %len, align 4
  %151 = load i64, i64* %val, align 8
  %sub301 = sub nsw i64 %151, 3
  %152 = inttoptr i64 %sub301 to i8*
  %153 = bitcast i8* %152 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %153, i32 0, i32 1
  %cdr = bitcast %union.anon.20* %u to i64*
  %154 = load i64, i64* %cdr, align 8
  store i64 %154, i64* %val, align 8
  br label %if.end.303

if.else.302:                                      ; preds = %if.then.283
  store i32 1, i32* %len, align 4
  br label %if.end.303

if.end.303:                                       ; preds = %if.else.302, %if.end.298
  %155 = load i64, i64* %val, align 8
  %call304 = call zeroext i1 @VECTORP(i64 %155)
  br i1 %call304, label %if.then.305, label %if.else.307

if.then.305:                                      ; preds = %if.end.303
  %call306 = call i64 @Fconcat(i64 1, i64* %val)
  store i64 %call306, i64* %string284, align 8
  br label %if.end.309

if.else.307:                                      ; preds = %if.end.303
  %156 = load i64, i64* %val, align 8
  %call308 = call i64 @Fmake_string(i64 6, i64 %156)
  store i64 %call308, i64* %string284, align 8
  br label %if.end.309

if.end.309:                                       ; preds = %if.else.307, %if.then.305
  %157 = load i64, i64* %pos, align 8
  %158 = load i64, i64* %pos, align 8
  %159 = load i32, i32* %len, align 4
  %conv310 = sext i32 %159 to i64
  %add311 = add nsw i64 %158, %conv310
  %160 = load i64, i64* %string284, align 8
  call void @replace_range(i64 %157, i64 %add311, i64 %160, i1 zeroext true, i1 zeroext false, i1 zeroext true, i1 zeroext false)
  %161 = load i64, i64* %string284, align 8
  %call312 = call i64 @SBYTES(i64 %161)
  %162 = load i64, i64* %pos_byte, align 8
  %add313 = add nsw i64 %162, %call312
  store i64 %add313, i64* %pos_byte, align 8
  %163 = load i64, i64* %string284, align 8
  %call314 = call i64 @SCHARS(i64 %163)
  %164 = load i64, i64* %pos, align 8
  %add315 = add nsw i64 %164, %call314
  store i64 %add315, i64* %pos, align 8
  %165 = load i64, i64* %string284, align 8
  %call316 = call i64 @SCHARS(i64 %165)
  %166 = load i32, i32* %cnt, align 4
  %conv317 = sext i32 %166 to i64
  %add318 = add nsw i64 %conv317, %call316
  %conv319 = trunc i64 %add318 to i32
  store i32 %conv319, i32* %cnt, align 4
  %167 = load i64, i64* %string284, align 8
  %call320 = call i64 @SCHARS(i64 %167)
  %168 = load i32, i32* %len, align 4
  %conv321 = sext i32 %168 to i64
  %sub322 = sub nsw i64 %call320, %conv321
  %169 = load i64, i64* %end_pos, align 8
  %add323 = add nsw i64 %169, %sub322
  store i64 %add323, i64* %end_pos, align 8
  br label %for.cond

if.end.324:                                       ; preds = %if.else.280
  br label %if.end.325

if.end.325:                                       ; preds = %if.end.324, %if.end.279
  br label %if.end.326

if.end.326:                                       ; preds = %if.end.325, %if.end.79
  %170 = load i32, i32* %len, align 4
  %conv327 = sext i32 %170 to i64
  %171 = load i64, i64* %pos_byte, align 8
  %add328 = add nsw i64 %171, %conv327
  store i64 %add328, i64* %pos_byte, align 8
  %172 = load i64, i64* %pos, align 8
  %inc329 = add nsw i64 %172, 1
  store i64 %inc329, i64* %pos, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %173 = load i32, i32* %cnt, align 4
  %conv330 = sext i32 %173 to i64
  %shl331 = shl i64 %conv330, 2
  %add332 = add i64 %shl331, 2
  ret i64 %add332
}

declare zeroext i1 @CHAR_TABLE_P(i64) #1

declare %struct.Lisp_Char_Table* @XCHAR_TABLE(i64) #1

declare i64 @string_make_unibyte(i64) #1

declare i64 @string_char_to_byte(i64, i64) #1

declare i64 @CHAR_TABLE_REF(i64, i32) #1

declare zeroext i1 @VECTORP(i64) #1

; Function Attrs: nounwind uwtable
define internal i64 @check_translation(i64 %pos, i64 %pos_byte, i64 %end, i64 %val) #0 {
entry:
  %pos.addr = alloca i64, align 8
  %pos_byte.addr = alloca i64, align 8
  %end.addr = alloca i64, align 8
  %val.addr = alloca i64, align 8
  %initial_buf = alloca [16 x i32], align 16
  %buf = alloca i32*, align 8
  %buf_size = alloca i64, align 8
  %bufalloc = alloca i32*, align 8
  %buf_used = alloca i64, align 8
  %result = alloca i64, align 8
  %elt = alloca i64, align 8
  %len = alloca i64, align 8
  %i = alloca i64, align 8
  %p = alloca i8*, align 8
  %len1 = alloca i32, align 4
  store i64 %pos, i64* %pos.addr, align 8
  store i64 %pos_byte, i64* %pos_byte.addr, align 8
  store i64 %end, i64* %end.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  %arraydecay = getelementptr inbounds [16 x i32], [16 x i32]* %initial_buf, i32 0, i32 0
  store i32* %arraydecay, i32** %buf, align 8
  store i64 16, i64* %buf_size, align 8
  store i32* null, i32** %bufalloc, align 8
  store i64 0, i64* %buf_used, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call, i64* %result, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc.107, %entry
  %0 = load i64, i64* %val.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %for.body, label %for.end.109

for.body:                                         ; preds = %for.cond
  %1 = load i64, i64* %val.addr, align 8
  %sub = sub nsw i64 %1, 3
  %2 = inttoptr i64 %sub to i8*
  %3 = bitcast i8* %2 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %3, i32 0, i32 0
  %4 = load i64, i64* %car, align 8
  store i64 %4, i64* %elt, align 8
  %5 = load i64, i64* %elt, align 8
  %and2 = and i64 %5, 7
  %conv3 = trunc i64 %and2 to i32
  %cmp4 = icmp eq i32 %conv3, 3
  br i1 %cmp4, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  br label %for.inc.107

if.end:                                           ; preds = %for.body
  %6 = load i64, i64* %elt, align 8
  %sub6 = sub nsw i64 %6, 3
  %7 = inttoptr i64 %sub6 to i8*
  %8 = bitcast i8* %7 to %struct.Lisp_Cons*
  %car7 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %8, i32 0, i32 0
  %9 = load i64, i64* %car7, align 8
  store i64 %9, i64* %elt, align 8
  %10 = load i64, i64* %elt, align 8
  %call8 = call zeroext i1 @VECTORP(i64 %10)
  br i1 %call8, label %if.end.10, label %if.then.9

if.then.9:                                        ; preds = %if.end
  br label %for.inc.107

if.end.10:                                        ; preds = %if.end
  %11 = load i64, i64* %elt, align 8
  %call11 = call i64 @ASIZE(i64 %11)
  store i64 %call11, i64* %len, align 8
  %12 = load i64, i64* %len, align 8
  %13 = load i64, i64* %end.addr, align 8
  %14 = load i64, i64* %pos.addr, align 8
  %sub12 = sub nsw i64 %13, %14
  %cmp13 = icmp sle i64 %12, %sub12
  br i1 %cmp13, label %if.then.15, label %if.end.106

if.then.15:                                       ; preds = %if.end.10
  store i64 0, i64* %i, align 8
  br label %for.cond.16

for.cond.16:                                      ; preds = %for.inc, %if.then.15
  %15 = load i64, i64* %i, align 8
  %16 = load i64, i64* %len, align 8
  %cmp17 = icmp slt i64 %15, %16
  br i1 %cmp17, label %for.body.19, label %for.end

for.body.19:                                      ; preds = %for.cond.16
  %17 = load i64, i64* %buf_used, align 8
  %18 = load i64, i64* %i, align 8
  %cmp20 = icmp sle i64 %17, %18
  br i1 %cmp20, label %if.then.22, label %if.end.91

if.then.22:                                       ; preds = %for.body.19
  %19 = load i64, i64* %pos_byte.addr, align 8
  %20 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text = getelementptr inbounds %struct.buffer, %struct.buffer* %20, i32 0, i32 73
  %21 = load %struct.buffer_text*, %struct.buffer_text** %text, align 8
  %gpt_byte = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %21, i32 0, i32 3
  %22 = load i64, i64* %gpt_byte, align 8
  %cmp23 = icmp sge i64 %19, %22
  br i1 %cmp23, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.22
  %23 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text25 = getelementptr inbounds %struct.buffer, %struct.buffer* %23, i32 0, i32 73
  %24 = load %struct.buffer_text*, %struct.buffer_text** %text25, align 8
  %gap_size = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %24, i32 0, i32 5
  %25 = load i64, i64* %gap_size, align 8
  br label %cond.end

cond.false:                                       ; preds = %if.then.22
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %25, %cond.true ], [ 0, %cond.false ]
  %26 = load i64, i64* %pos_byte.addr, align 8
  %add = add nsw i64 %cond, %26
  %27 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text26 = getelementptr inbounds %struct.buffer, %struct.buffer* %27, i32 0, i32 73
  %28 = load %struct.buffer_text*, %struct.buffer_text** %text26, align 8
  %beg = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %28, i32 0, i32 0
  %29 = load i8*, i8** %beg, align 8
  %add.ptr = getelementptr inbounds i8, i8* %29, i64 %add
  %add.ptr27 = getelementptr inbounds i8, i8* %add.ptr, i64 -1
  store i8* %add.ptr27, i8** %p, align 8
  %30 = load i64, i64* %buf_used, align 8
  %31 = load i64, i64* %buf_size, align 8
  %cmp28 = icmp eq i64 %30, %31
  br i1 %cmp28, label %if.then.30, label %if.end.37

if.then.30:                                       ; preds = %cond.end
  %32 = load i32*, i32** %bufalloc, align 8
  %33 = bitcast i32* %32 to i8*
  %call31 = call i8* @xpalloc(i8* %33, i64* %buf_size, i64 1, i64 -1, i64 4)
  %34 = bitcast i8* %call31 to i32*
  store i32* %34, i32** %bufalloc, align 8
  %35 = load i32*, i32** %buf, align 8
  %arraydecay32 = getelementptr inbounds [16 x i32], [16 x i32]* %initial_buf, i32 0, i32 0
  %cmp33 = icmp eq i32* %35, %arraydecay32
  br i1 %cmp33, label %if.then.35, label %if.end.36

if.then.35:                                       ; preds = %if.then.30
  %36 = load i32*, i32** %bufalloc, align 8
  %37 = bitcast i32* %36 to i8*
  %38 = load i32*, i32** %buf, align 8
  %39 = bitcast i32* %38 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %37, i8* %39, i64 64, i32 4, i1 false)
  br label %if.end.36

if.end.36:                                        ; preds = %if.then.35, %if.then.30
  %40 = load i32*, i32** %bufalloc, align 8
  store i32* %40, i32** %buf, align 8
  br label %if.end.37

if.end.37:                                        ; preds = %if.end.36, %cond.end
  %41 = load i8*, i8** %p, align 8
  %arrayidx = getelementptr inbounds i8, i8* %41, i64 0
  %42 = load i8, i8* %arrayidx, align 1
  %conv38 = zext i8 %42 to i32
  %and39 = and i32 %conv38, 128
  %tobool = icmp ne i32 %and39, 0
  br i1 %tobool, label %cond.false.43, label %cond.true.40

cond.true.40:                                     ; preds = %if.end.37
  store i32 1, i32* %len1, align 4
  %43 = load i8*, i8** %p, align 8
  %arrayidx41 = getelementptr inbounds i8, i8* %43, i64 0
  %44 = load i8, i8* %arrayidx41, align 1
  %conv42 = zext i8 %44 to i32
  br label %cond.end.86

cond.false.43:                                    ; preds = %if.end.37
  %45 = load i8*, i8** %p, align 8
  %arrayidx44 = getelementptr inbounds i8, i8* %45, i64 0
  %46 = load i8, i8* %arrayidx44, align 1
  %conv45 = zext i8 %46 to i32
  %and46 = and i32 %conv45, 32
  %tobool47 = icmp ne i32 %and46, 0
  br i1 %tobool47, label %cond.false.61, label %cond.true.48

cond.true.48:                                     ; preds = %cond.false.43
  store i32 2, i32* %len1, align 4
  %47 = load i8*, i8** %p, align 8
  %arrayidx49 = getelementptr inbounds i8, i8* %47, i64 0
  %48 = load i8, i8* %arrayidx49, align 1
  %conv50 = zext i8 %48 to i32
  %and51 = and i32 %conv50, 31
  %shl = shl i32 %and51, 6
  %49 = load i8*, i8** %p, align 8
  %arrayidx52 = getelementptr inbounds i8, i8* %49, i64 1
  %50 = load i8, i8* %arrayidx52, align 1
  %conv53 = zext i8 %50 to i32
  %and54 = and i32 %conv53, 63
  %or = or i32 %shl, %and54
  %51 = load i8*, i8** %p, align 8
  %arrayidx55 = getelementptr inbounds i8, i8* %51, i64 0
  %52 = load i8, i8* %arrayidx55, align 1
  %conv56 = zext i8 %52 to i32
  %cmp57 = icmp slt i32 %conv56, 194
  %cond59 = select i1 %cmp57, i32 4194176, i32 0
  %add60 = add nsw i32 %or, %cond59
  br label %cond.end.84

cond.false.61:                                    ; preds = %cond.false.43
  %53 = load i8*, i8** %p, align 8
  %arrayidx62 = getelementptr inbounds i8, i8* %53, i64 0
  %54 = load i8, i8* %arrayidx62, align 1
  %conv63 = zext i8 %54 to i32
  %and64 = and i32 %conv63, 16
  %tobool65 = icmp ne i32 %and64, 0
  br i1 %tobool65, label %cond.false.80, label %cond.true.66

cond.true.66:                                     ; preds = %cond.false.61
  store i32 3, i32* %len1, align 4
  %55 = load i8*, i8** %p, align 8
  %arrayidx67 = getelementptr inbounds i8, i8* %55, i64 0
  %56 = load i8, i8* %arrayidx67, align 1
  %conv68 = zext i8 %56 to i32
  %and69 = and i32 %conv68, 15
  %shl70 = shl i32 %and69, 12
  %57 = load i8*, i8** %p, align 8
  %arrayidx71 = getelementptr inbounds i8, i8* %57, i64 1
  %58 = load i8, i8* %arrayidx71, align 1
  %conv72 = zext i8 %58 to i32
  %and73 = and i32 %conv72, 63
  %shl74 = shl i32 %and73, 6
  %or75 = or i32 %shl70, %shl74
  %59 = load i8*, i8** %p, align 8
  %arrayidx76 = getelementptr inbounds i8, i8* %59, i64 2
  %60 = load i8, i8* %arrayidx76, align 1
  %conv77 = zext i8 %60 to i32
  %and78 = and i32 %conv77, 63
  %or79 = or i32 %or75, %and78
  br label %cond.end.82

cond.false.80:                                    ; preds = %cond.false.61
  %61 = load i8*, i8** %p, align 8
  %call81 = call i32 @string_char(i8* %61, i8** null, i32* %len1)
  br label %cond.end.82

cond.end.82:                                      ; preds = %cond.false.80, %cond.true.66
  %cond83 = phi i32 [ %or79, %cond.true.66 ], [ %call81, %cond.false.80 ]
  br label %cond.end.84

cond.end.84:                                      ; preds = %cond.end.82, %cond.true.48
  %cond85 = phi i32 [ %add60, %cond.true.48 ], [ %cond83, %cond.end.82 ]
  br label %cond.end.86

cond.end.86:                                      ; preds = %cond.end.84, %cond.true.40
  %cond87 = phi i32 [ %conv42, %cond.true.40 ], [ %cond85, %cond.end.84 ]
  %62 = load i64, i64* %buf_used, align 8
  %inc = add nsw i64 %62, 1
  store i64 %inc, i64* %buf_used, align 8
  %63 = load i32*, i32** %buf, align 8
  %arrayidx88 = getelementptr inbounds i32, i32* %63, i64 %62
  store i32 %cond87, i32* %arrayidx88, align 4
  %64 = load i32, i32* %len1, align 4
  %conv89 = sext i32 %64 to i64
  %65 = load i64, i64* %pos_byte.addr, align 8
  %add90 = add nsw i64 %65, %conv89
  store i64 %add90, i64* %pos_byte.addr, align 8
  br label %if.end.91

if.end.91:                                        ; preds = %cond.end.86, %for.body.19
  %66 = load i64, i64* %elt, align 8
  %67 = load i64, i64* %i, align 8
  %call92 = call i64 @AREF(i64 %66, i64 %67)
  %shr = ashr i64 %call92, 2
  %68 = load i64, i64* %i, align 8
  %69 = load i32*, i32** %buf, align 8
  %arrayidx93 = getelementptr inbounds i32, i32* %69, i64 %68
  %70 = load i32, i32* %arrayidx93, align 4
  %conv94 = sext i32 %70 to i64
  %cmp95 = icmp ne i64 %shr, %conv94
  br i1 %cmp95, label %if.then.97, label %if.end.98

if.then.97:                                       ; preds = %if.end.91
  br label %for.end

if.end.98:                                        ; preds = %if.end.91
  br label %for.inc

for.inc:                                          ; preds = %if.end.98
  %71 = load i64, i64* %i, align 8
  %inc99 = add nsw i64 %71, 1
  store i64 %inc99, i64* %i, align 8
  br label %for.cond.16

for.end:                                          ; preds = %if.then.97, %for.cond.16
  %72 = load i64, i64* %i, align 8
  %73 = load i64, i64* %len, align 8
  %cmp100 = icmp eq i64 %72, %73
  br i1 %cmp100, label %if.then.102, label %if.end.105

if.then.102:                                      ; preds = %for.end
  %74 = load i64, i64* %val.addr, align 8
  %sub103 = sub nsw i64 %74, 3
  %75 = inttoptr i64 %sub103 to i8*
  %76 = bitcast i8* %75 to %struct.Lisp_Cons*
  %car104 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %76, i32 0, i32 0
  %77 = load i64, i64* %car104, align 8
  store i64 %77, i64* %result, align 8
  br label %for.end.109

if.end.105:                                       ; preds = %for.end
  br label %if.end.106

if.end.106:                                       ; preds = %if.end.105, %if.end.10
  br label %for.inc.107

for.inc.107:                                      ; preds = %if.end.106, %if.then.9, %if.then
  %78 = load i64, i64* %val.addr, align 8
  %sub108 = sub nsw i64 %78, 3
  %79 = inttoptr i64 %sub108 to i8*
  %80 = bitcast i8* %79 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %80, i32 0, i32 1
  %cdr = bitcast %union.anon.20* %u to i64*
  %81 = load i64, i64* %cdr, align 8
  store i64 %81, i64* %val.addr, align 8
  br label %for.cond

for.end.109:                                      ; preds = %if.then.102, %for.cond
  %82 = load i32*, i32** %bufalloc, align 8
  %83 = bitcast i32* %82 to i8*
  call void @xfree(i8* %83)
  %84 = load i64, i64* %result, align 8
  ret i64 %84
}

declare i64 @ASIZE(i64) #1

declare i64 @Fconcat(i64, i64*) #1

declare i64 @Fmake_string(i64, i64) #1

; Function Attrs: nounwind uwtable
define i64 @Fdelete_region(i64 %start, i64 %end) #0 {
entry:
  %start.addr = alloca i64, align 8
  %end.addr = alloca i64, align 8
  store i64 %start, i64* %start.addr, align 8
  store i64 %end, i64* %end.addr, align 8
  call void @validate_region(i64* %start.addr, i64* %end.addr)
  %0 = load i64, i64* %start.addr, align 8
  %shr = ashr i64 %0, 2
  %1 = load i64, i64* %end.addr, align 8
  %shr1 = ashr i64 %1, 2
  call void @del_range(i64 %shr, i64 %shr1)
  %call = call i64 @builtin_lisp_symbol(i32 0)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define i64 @Fdelete_and_extract_region(i64 %start, i64 %end) #0 {
entry:
  %retval = alloca i64, align 8
  %start.addr = alloca i64, align 8
  %end.addr = alloca i64, align 8
  store i64 %start, i64* %start.addr, align 8
  store i64 %end, i64* %end.addr, align 8
  call void @validate_region(i64* %start.addr, i64* %end.addr)
  %0 = load i64, i64* %start.addr, align 8
  %shr = ashr i64 %0, 2
  %1 = load i64, i64* %end.addr, align 8
  %shr1 = ashr i64 %1, 2
  %cmp = icmp eq i64 %shr, %shr1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i64, i64* @empty_unibyte_string, align 8
  store i64 %2, i64* %retval
  br label %return

if.end:                                           ; preds = %entry
  %3 = load i64, i64* %start.addr, align 8
  %shr2 = ashr i64 %3, 2
  %4 = load i64, i64* %end.addr, align 8
  %shr3 = ashr i64 %4, 2
  %call = call i64 @del_range_1(i64 %shr2, i64 %shr3, i1 zeroext true, i1 zeroext true)
  store i64 %call, i64* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %5 = load i64, i64* %retval
  ret i64 %5
}

declare i64 @del_range_1(i64, i64, i1 zeroext, i1 zeroext) #1

; Function Attrs: nounwind uwtable
define i64 @Fwiden() #0 {
entry:
  %0 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv = getelementptr inbounds %struct.buffer, %struct.buffer* %0, i32 0, i32 77
  %1 = load i64, i64* %begv, align 8
  %cmp = icmp ne i64 1, %1
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text = getelementptr inbounds %struct.buffer, %struct.buffer* %2, i32 0, i32 73
  %3 = load %struct.buffer_text*, %struct.buffer_text** %text, align 8
  %z = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %3, i32 0, i32 2
  %4 = load i64, i64* %z, align 8
  %5 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv = getelementptr inbounds %struct.buffer, %struct.buffer* %5, i32 0, i32 79
  %6 = load i64, i64* %zv, align 8
  %cmp1 = icmp ne i64 %4, %6
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %7 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %clip_changed = getelementptr inbounds %struct.buffer, %struct.buffer* %7, i32 0, i32 94
  %bf.load = load i8, i8* %clip_changed, align 8
  %bf.clear = and i8 %bf.load, -3
  %bf.set = or i8 %bf.clear, 2
  store i8 %bf.set, i8* %clip_changed, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %lor.lhs.false
  %8 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv2 = getelementptr inbounds %struct.buffer, %struct.buffer* %8, i32 0, i32 77
  store i64 1, i64* %begv2, align 8
  %9 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv_byte = getelementptr inbounds %struct.buffer, %struct.buffer* %9, i32 0, i32 78
  store i64 1, i64* %begv_byte, align 8
  %10 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text3 = getelementptr inbounds %struct.buffer, %struct.buffer* %10, i32 0, i32 73
  %11 = load %struct.buffer_text*, %struct.buffer_text** %text3, align 8
  %z4 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %11, i32 0, i32 2
  %12 = load i64, i64* %z4, align 8
  %13 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv5 = getelementptr inbounds %struct.buffer, %struct.buffer* %13, i32 0, i32 79
  store i64 %12, i64* %zv5, align 8
  %14 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text6 = getelementptr inbounds %struct.buffer, %struct.buffer* %14, i32 0, i32 73
  %15 = load %struct.buffer_text*, %struct.buffer_text** %text6, align 8
  %z_byte = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %15, i32 0, i32 4
  %16 = load i64, i64* %z_byte, align 8
  %17 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv_byte = getelementptr inbounds %struct.buffer, %struct.buffer* %17, i32 0, i32 80
  store i64 %16, i64* %zv_byte, align 8
  call void @invalidate_current_column()
  %call = call i64 @builtin_lisp_symbol(i32 0)
  ret i64 %call
}

declare void @invalidate_current_column() #1

; Function Attrs: nounwind uwtable
define i64 @Fnarrow_to_region(i64 %start, i64 %end) #0 {
entry:
  %start.addr = alloca i64, align 8
  %end.addr = alloca i64, align 8
  %tem = alloca i64, align 8
  store i64 %start, i64* %start.addr, align 8
  store i64 %end, i64* %end.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load i64, i64* %start.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 1
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %do.body
  %1 = load i64, i64* %start.addr, align 8
  %call = call i32 @XMISCTYPE(i64 %1)
  %cmp2 = icmp eq i32 %call, 24236
  br i1 %cmp2, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %2 = load i64, i64* %start.addr, align 8
  %call4 = call i64 @marker_position(i64 %2)
  %call5 = call i64 @make_natnum(i64 %call4)
  store i64 %call5, i64* %start.addr, align 8
  br label %if.end

if.else:                                          ; preds = %land.lhs.true, %do.body
  %3 = load i64, i64* %start.addr, align 8
  %and6 = and i64 %3, 7
  %conv7 = trunc i64 %and6 to i32
  %and8 = and i32 %conv7, -5
  %cmp9 = icmp eq i32 %and8, 2
  br i1 %cmp9, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.else
  br label %cond.end

cond.false:                                       ; preds = %if.else
  %call11 = call i64 @builtin_lisp_symbol(i32 558)
  %4 = load i64, i64* %start.addr, align 8
  %5 = call i64 @wrong_type_argument(i64 %call11, i64 %4) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %6, %cond.true
  br label %if.end

if.end:                                           ; preds = %cond.end, %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  br label %do.body.12

do.body.12:                                       ; preds = %do.end
  %7 = load i64, i64* %end.addr, align 8
  %and13 = and i64 %7, 7
  %conv14 = trunc i64 %and13 to i32
  %cmp15 = icmp eq i32 %conv14, 1
  br i1 %cmp15, label %land.lhs.true.17, label %if.else.24

land.lhs.true.17:                                 ; preds = %do.body.12
  %8 = load i64, i64* %end.addr, align 8
  %call18 = call i32 @XMISCTYPE(i64 %8)
  %cmp19 = icmp eq i32 %call18, 24236
  br i1 %cmp19, label %if.then.21, label %if.else.24

if.then.21:                                       ; preds = %land.lhs.true.17
  %9 = load i64, i64* %end.addr, align 8
  %call22 = call i64 @marker_position(i64 %9)
  %call23 = call i64 @make_natnum(i64 %call22)
  store i64 %call23, i64* %end.addr, align 8
  br label %if.end.34

if.else.24:                                       ; preds = %land.lhs.true.17, %do.body.12
  %10 = load i64, i64* %end.addr, align 8
  %and25 = and i64 %10, 7
  %conv26 = trunc i64 %and25 to i32
  %and27 = and i32 %conv26, -5
  %cmp28 = icmp eq i32 %and27, 2
  br i1 %cmp28, label %cond.true.30, label %cond.false.31

cond.true.30:                                     ; preds = %if.else.24
  br label %cond.end.33

cond.false.31:                                    ; preds = %if.else.24
  %call32 = call i64 @builtin_lisp_symbol(i32 558)
  %11 = load i64, i64* %end.addr, align 8
  %12 = call i64 @wrong_type_argument(i64 %call32, i64 %11) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end.33

cond.end.33:                                      ; preds = %13, %cond.true.30
  br label %if.end.34

if.end.34:                                        ; preds = %cond.end.33, %if.then.21
  br label %do.end.35

do.end.35:                                        ; preds = %if.end.34
  %14 = load i64, i64* %start.addr, align 8
  %shr = ashr i64 %14, 2
  %15 = load i64, i64* %end.addr, align 8
  %shr36 = ashr i64 %15, 2
  %cmp37 = icmp sgt i64 %shr, %shr36
  br i1 %cmp37, label %if.then.39, label %if.end.40

if.then.39:                                       ; preds = %do.end.35
  %16 = load i64, i64* %start.addr, align 8
  store i64 %16, i64* %tem, align 8
  %17 = load i64, i64* %end.addr, align 8
  store i64 %17, i64* %start.addr, align 8
  %18 = load i64, i64* %tem, align 8
  store i64 %18, i64* %end.addr, align 8
  br label %if.end.40

if.end.40:                                        ; preds = %if.then.39, %do.end.35
  %19 = load i64, i64* %start.addr, align 8
  %shr41 = ashr i64 %19, 2
  %cmp42 = icmp sle i64 1, %shr41
  br i1 %cmp42, label %land.lhs.true.44, label %if.then.53

land.lhs.true.44:                                 ; preds = %if.end.40
  %20 = load i64, i64* %start.addr, align 8
  %shr45 = ashr i64 %20, 2
  %21 = load i64, i64* %end.addr, align 8
  %shr46 = ashr i64 %21, 2
  %cmp47 = icmp sle i64 %shr45, %shr46
  br i1 %cmp47, label %land.lhs.true.49, label %if.then.53

land.lhs.true.49:                                 ; preds = %land.lhs.true.44
  %22 = load i64, i64* %end.addr, align 8
  %shr50 = ashr i64 %22, 2
  %23 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text = getelementptr inbounds %struct.buffer, %struct.buffer* %23, i32 0, i32 73
  %24 = load %struct.buffer_text*, %struct.buffer_text** %text, align 8
  %z = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %24, i32 0, i32 2
  %25 = load i64, i64* %z, align 8
  %cmp51 = icmp sle i64 %shr50, %25
  br i1 %cmp51, label %if.end.54, label %if.then.53

if.then.53:                                       ; preds = %land.lhs.true.49, %land.lhs.true.44, %if.end.40
  %26 = load i64, i64* %start.addr, align 8
  %27 = load i64, i64* %end.addr, align 8
  call void @args_out_of_range(i64 %26, i64 %27) #9
  unreachable

if.end.54:                                        ; preds = %land.lhs.true.49
  %28 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv = getelementptr inbounds %struct.buffer, %struct.buffer* %28, i32 0, i32 77
  %29 = load i64, i64* %begv, align 8
  %30 = load i64, i64* %start.addr, align 8
  %shr55 = ashr i64 %30, 2
  %cmp56 = icmp ne i64 %29, %shr55
  br i1 %cmp56, label %if.then.61, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end.54
  %31 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv = getelementptr inbounds %struct.buffer, %struct.buffer* %31, i32 0, i32 79
  %32 = load i64, i64* %zv, align 8
  %33 = load i64, i64* %end.addr, align 8
  %shr58 = ashr i64 %33, 2
  %cmp59 = icmp ne i64 %32, %shr58
  br i1 %cmp59, label %if.then.61, label %if.end.62

if.then.61:                                       ; preds = %lor.lhs.false, %if.end.54
  %34 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %clip_changed = getelementptr inbounds %struct.buffer, %struct.buffer* %34, i32 0, i32 94
  %bf.load = load i8, i8* %clip_changed, align 8
  %bf.clear = and i8 %bf.load, -3
  %bf.set = or i8 %bf.clear, 2
  store i8 %bf.set, i8* %clip_changed, align 8
  br label %if.end.62

if.end.62:                                        ; preds = %if.then.61, %lor.lhs.false
  %35 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %36 = load i64, i64* %start.addr, align 8
  %shr63 = ashr i64 %36, 2
  %call64 = call i64 @buf_charpos_to_bytepos(%struct.buffer* %35, i64 %shr63)
  %37 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv_byte = getelementptr inbounds %struct.buffer, %struct.buffer* %37, i32 0, i32 78
  store i64 %call64, i64* %begv_byte, align 8
  %38 = load i64, i64* %start.addr, align 8
  %shr65 = ashr i64 %38, 2
  %39 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv66 = getelementptr inbounds %struct.buffer, %struct.buffer* %39, i32 0, i32 77
  store i64 %shr65, i64* %begv66, align 8
  %40 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %41 = load i64, i64* %end.addr, align 8
  %shr67 = ashr i64 %41, 2
  %call68 = call i64 @buf_charpos_to_bytepos(%struct.buffer* %40, i64 %shr67)
  %42 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv_byte = getelementptr inbounds %struct.buffer, %struct.buffer* %42, i32 0, i32 80
  store i64 %call68, i64* %zv_byte, align 8
  %43 = load i64, i64* %end.addr, align 8
  %shr69 = ashr i64 %43, 2
  %44 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv70 = getelementptr inbounds %struct.buffer, %struct.buffer* %44, i32 0, i32 79
  store i64 %shr69, i64* %zv70, align 8
  %45 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt = getelementptr inbounds %struct.buffer, %struct.buffer* %45, i32 0, i32 75
  %46 = load i64, i64* %pt, align 8
  %add = add nsw i64 %46, 0
  %47 = load i64, i64* %start.addr, align 8
  %shr71 = ashr i64 %47, 2
  %cmp72 = icmp slt i64 %add, %shr71
  br i1 %cmp72, label %if.then.74, label %if.end.76

if.then.74:                                       ; preds = %if.end.62
  %48 = load i64, i64* %start.addr, align 8
  %shr75 = ashr i64 %48, 2
  call void @set_point(i64 %shr75)
  br label %if.end.76

if.end.76:                                        ; preds = %if.then.74, %if.end.62
  %49 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt77 = getelementptr inbounds %struct.buffer, %struct.buffer* %49, i32 0, i32 75
  %50 = load i64, i64* %pt77, align 8
  %add78 = add nsw i64 %50, 0
  %51 = load i64, i64* %end.addr, align 8
  %shr79 = ashr i64 %51, 2
  %cmp80 = icmp sgt i64 %add78, %shr79
  br i1 %cmp80, label %if.then.82, label %if.end.84

if.then.82:                                       ; preds = %if.end.76
  %52 = load i64, i64* %end.addr, align 8
  %shr83 = ashr i64 %52, 2
  call void @set_point(i64 %shr83)
  br label %if.end.84

if.end.84:                                        ; preds = %if.then.82, %if.end.76
  call void @invalidate_current_column()
  %call85 = call i64 @builtin_lisp_symbol(i32 0)
  ret i64 %call85
}

; Function Attrs: nounwind uwtable
define i64 @save_restriction_save() #0 {
entry:
  %retval = alloca i64, align 8
  %beg = alloca i64, align 8
  %end = alloca i64, align 8
  %0 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv = getelementptr inbounds %struct.buffer, %struct.buffer* %0, i32 0, i32 77
  %1 = load i64, i64* %begv, align 8
  %cmp = icmp eq i64 %1, 1
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %2 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv = getelementptr inbounds %struct.buffer, %struct.buffer* %2, i32 0, i32 79
  %3 = load i64, i64* %zv, align 8
  %4 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text = getelementptr inbounds %struct.buffer, %struct.buffer* %4, i32 0, i32 73
  %5 = load %struct.buffer_text*, %struct.buffer_text** %text, align 8
  %z = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %5, i32 0, i32 2
  %6 = load i64, i64* %z, align 8
  %cmp1 = icmp eq i64 %3, %6
  br i1 %cmp1, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %call = call i64 @Fcurrent_buffer()
  store i64 %call, i64* %retval
  br label %return

if.else:                                          ; preds = %land.lhs.true, %entry
  %7 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %8 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv2 = getelementptr inbounds %struct.buffer, %struct.buffer* %8, i32 0, i32 77
  %9 = load i64, i64* %begv2, align 8
  %10 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv_byte = getelementptr inbounds %struct.buffer, %struct.buffer* %10, i32 0, i32 78
  %11 = load i64, i64* %begv_byte, align 8
  %call3 = call i64 @build_marker(%struct.buffer* %7, i64 %9, i64 %11)
  store i64 %call3, i64* %beg, align 8
  %12 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %13 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv4 = getelementptr inbounds %struct.buffer, %struct.buffer* %13, i32 0, i32 79
  %14 = load i64, i64* %zv4, align 8
  %15 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv_byte = getelementptr inbounds %struct.buffer, %struct.buffer* %15, i32 0, i32 80
  %16 = load i64, i64* %zv_byte, align 8
  %call5 = call i64 @build_marker(%struct.buffer* %12, i64 %14, i64 %16)
  store i64 %call5, i64* %end, align 8
  %17 = load i64, i64* %end, align 8
  %call6 = call %struct.Lisp_Marker* @XMARKER(i64 %17)
  %18 = bitcast %struct.Lisp_Marker* %call6 to i32*
  %bf.load = load i32, i32* %18, align 8
  %bf.clear = and i32 %bf.load, 2147483647
  %bf.set = or i32 %bf.clear, -2147483648
  store i32 %bf.set, i32* %18, align 8
  %19 = load i64, i64* %beg, align 8
  %20 = load i64, i64* %end, align 8
  %call7 = call i64 @Fcons(i64 %19, i64 %20)
  store i64 %call7, i64* %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %21 = load i64, i64* %retval
  ret i64 %21
}

declare i64 @Fcons(i64, i64) #1

; Function Attrs: nounwind uwtable
define void @save_restriction_restore(i64 %data) #0 {
entry:
  %data.addr = alloca i64, align 8
  %cur = alloca %struct.buffer*, align 8
  %buf = alloca %struct.buffer*, align 8
  %beg = alloca %struct.Lisp_Marker*, align 8
  %end = alloca %struct.Lisp_Marker*, align 8
  %pt = alloca i64, align 8
  store i64 %data, i64* %data.addr, align 8
  store %struct.buffer* null, %struct.buffer** %cur, align 8
  %0 = load i64, i64* %data.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load i64, i64* %data.addr, align 8
  %sub = sub nsw i64 %1, 3
  %2 = inttoptr i64 %sub to i8*
  %3 = bitcast i8* %2 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %3, i32 0, i32 0
  %4 = load i64, i64* %car, align 8
  %call = call %struct.Lisp_Marker* @XMARKER(i64 %4)
  %buffer = getelementptr inbounds %struct.Lisp_Marker, %struct.Lisp_Marker* %call, i32 0, i32 1
  %5 = load %struct.buffer*, %struct.buffer** %buffer, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  %6 = load i64, i64* %data.addr, align 8
  %call2 = call %struct.buffer* @XBUFFER(i64 %6)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi %struct.buffer* [ %5, %cond.true ], [ %call2, %cond.false ]
  store %struct.buffer* %cond, %struct.buffer** %buf, align 8
  %7 = load %struct.buffer*, %struct.buffer** %buf, align 8
  %tobool = icmp ne %struct.buffer* %7, null
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %cond.end
  %8 = load %struct.buffer*, %struct.buffer** %buf, align 8
  %9 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %cmp3 = icmp ne %struct.buffer* %8, %9
  br i1 %cmp3, label %land.lhs.true.5, label %if.end

land.lhs.true.5:                                  ; preds = %land.lhs.true
  %10 = load %struct.buffer*, %struct.buffer** %buf, align 8
  %pt_marker_ = getelementptr inbounds %struct.buffer, %struct.buffer* %10, i32 0, i32 45
  %11 = load i64, i64* %pt_marker_, align 8
  %call6 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp7 = icmp eq i64 %11, %call6
  br i1 %cmp7, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true.5
  %12 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  store %struct.buffer* %12, %struct.buffer** %cur, align 8
  %13 = load %struct.buffer*, %struct.buffer** %buf, align 8
  call void @set_buffer_internal(%struct.buffer* %13)
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true.5, %land.lhs.true, %cond.end
  %14 = load i64, i64* %data.addr, align 8
  %and9 = and i64 %14, 7
  %conv10 = trunc i64 %and9 to i32
  %cmp11 = icmp eq i32 %conv10, 3
  br i1 %cmp11, label %if.then.13, label %if.else

if.then.13:                                       ; preds = %if.end
  %15 = load i64, i64* %data.addr, align 8
  %sub14 = sub nsw i64 %15, 3
  %16 = inttoptr i64 %sub14 to i8*
  %17 = bitcast i8* %16 to %struct.Lisp_Cons*
  %car15 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %17, i32 0, i32 0
  %18 = load i64, i64* %car15, align 8
  %call16 = call %struct.Lisp_Marker* @XMARKER(i64 %18)
  store %struct.Lisp_Marker* %call16, %struct.Lisp_Marker** %beg, align 8
  %19 = load i64, i64* %data.addr, align 8
  %sub17 = sub nsw i64 %19, 3
  %20 = inttoptr i64 %sub17 to i8*
  %21 = bitcast i8* %20 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %21, i32 0, i32 1
  %cdr = bitcast %union.anon.20* %u to i64*
  %22 = load i64, i64* %cdr, align 8
  %call18 = call %struct.Lisp_Marker* @XMARKER(i64 %22)
  store %struct.Lisp_Marker* %call18, %struct.Lisp_Marker** %end, align 8
  %23 = load %struct.buffer*, %struct.buffer** %buf, align 8
  %tobool19 = icmp ne %struct.buffer* %23, null
  br i1 %tobool19, label %land.lhs.true.20, label %if.end.117

land.lhs.true.20:                                 ; preds = %if.then.13
  %24 = load %struct.Lisp_Marker*, %struct.Lisp_Marker** %beg, align 8
  %charpos = getelementptr inbounds %struct.Lisp_Marker, %struct.Lisp_Marker* %24, i32 0, i32 3
  %25 = load i64, i64* %charpos, align 8
  %26 = load %struct.buffer*, %struct.buffer** %buf, align 8
  %27 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %cmp21 = icmp eq %struct.buffer* %26, %27
  br i1 %cmp21, label %cond.true.23, label %cond.false.24

cond.true.23:                                     ; preds = %land.lhs.true.20
  %28 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv = getelementptr inbounds %struct.buffer, %struct.buffer* %28, i32 0, i32 77
  %29 = load i64, i64* %begv, align 8
  br label %cond.end.35

cond.false.24:                                    ; preds = %land.lhs.true.20
  %30 = load %struct.buffer*, %struct.buffer** %buf, align 8
  %begv_marker_ = getelementptr inbounds %struct.buffer, %struct.buffer* %30, i32 0, i32 46
  %31 = load i64, i64* %begv_marker_, align 8
  %call25 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp26 = icmp eq i64 %31, %call25
  br i1 %cmp26, label %cond.true.28, label %cond.false.30

cond.true.28:                                     ; preds = %cond.false.24
  %32 = load %struct.buffer*, %struct.buffer** %buf, align 8
  %begv29 = getelementptr inbounds %struct.buffer, %struct.buffer* %32, i32 0, i32 77
  %33 = load i64, i64* %begv29, align 8
  br label %cond.end.33

cond.false.30:                                    ; preds = %cond.false.24
  %34 = load %struct.buffer*, %struct.buffer** %buf, align 8
  %begv_marker_31 = getelementptr inbounds %struct.buffer, %struct.buffer* %34, i32 0, i32 46
  %35 = load i64, i64* %begv_marker_31, align 8
  %call32 = call i64 @marker_position(i64 %35)
  br label %cond.end.33

cond.end.33:                                      ; preds = %cond.false.30, %cond.true.28
  %cond34 = phi i64 [ %33, %cond.true.28 ], [ %call32, %cond.false.30 ]
  br label %cond.end.35

cond.end.35:                                      ; preds = %cond.end.33, %cond.true.23
  %cond36 = phi i64 [ %29, %cond.true.23 ], [ %cond34, %cond.end.33 ]
  %cmp37 = icmp ne i64 %25, %cond36
  br i1 %cmp37, label %if.then.58, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end.35
  %36 = load %struct.Lisp_Marker*, %struct.Lisp_Marker** %end, align 8
  %charpos39 = getelementptr inbounds %struct.Lisp_Marker, %struct.Lisp_Marker* %36, i32 0, i32 3
  %37 = load i64, i64* %charpos39, align 8
  %38 = load %struct.buffer*, %struct.buffer** %buf, align 8
  %39 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %cmp40 = icmp eq %struct.buffer* %38, %39
  br i1 %cmp40, label %cond.true.42, label %cond.false.43

cond.true.42:                                     ; preds = %lor.lhs.false
  %40 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv = getelementptr inbounds %struct.buffer, %struct.buffer* %40, i32 0, i32 79
  %41 = load i64, i64* %zv, align 8
  br label %cond.end.54

cond.false.43:                                    ; preds = %lor.lhs.false
  %42 = load %struct.buffer*, %struct.buffer** %buf, align 8
  %zv_marker_ = getelementptr inbounds %struct.buffer, %struct.buffer* %42, i32 0, i32 47
  %43 = load i64, i64* %zv_marker_, align 8
  %call44 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp45 = icmp eq i64 %43, %call44
  br i1 %cmp45, label %cond.true.47, label %cond.false.49

cond.true.47:                                     ; preds = %cond.false.43
  %44 = load %struct.buffer*, %struct.buffer** %buf, align 8
  %zv48 = getelementptr inbounds %struct.buffer, %struct.buffer* %44, i32 0, i32 79
  %45 = load i64, i64* %zv48, align 8
  br label %cond.end.52

cond.false.49:                                    ; preds = %cond.false.43
  %46 = load %struct.buffer*, %struct.buffer** %buf, align 8
  %zv_marker_50 = getelementptr inbounds %struct.buffer, %struct.buffer* %46, i32 0, i32 47
  %47 = load i64, i64* %zv_marker_50, align 8
  %call51 = call i64 @marker_position(i64 %47)
  br label %cond.end.52

cond.end.52:                                      ; preds = %cond.false.49, %cond.true.47
  %cond53 = phi i64 [ %45, %cond.true.47 ], [ %call51, %cond.false.49 ]
  br label %cond.end.54

cond.end.54:                                      ; preds = %cond.end.52, %cond.true.42
  %cond55 = phi i64 [ %41, %cond.true.42 ], [ %cond53, %cond.end.52 ]
  %cmp56 = icmp ne i64 %37, %cond55
  br i1 %cmp56, label %if.then.58, label %if.end.117

if.then.58:                                       ; preds = %cond.end.54, %cond.end.35
  %48 = load %struct.buffer*, %struct.buffer** %buf, align 8
  %49 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %cmp59 = icmp eq %struct.buffer* %48, %49
  br i1 %cmp59, label %cond.true.61, label %cond.false.63

cond.true.61:                                     ; preds = %if.then.58
  %50 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt62 = getelementptr inbounds %struct.buffer, %struct.buffer* %50, i32 0, i32 75
  %51 = load i64, i64* %pt62, align 8
  %add = add nsw i64 %51, 0
  br label %cond.end.75

cond.false.63:                                    ; preds = %if.then.58
  %52 = load %struct.buffer*, %struct.buffer** %buf, align 8
  %pt_marker_64 = getelementptr inbounds %struct.buffer, %struct.buffer* %52, i32 0, i32 45
  %53 = load i64, i64* %pt_marker_64, align 8
  %call65 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp66 = icmp eq i64 %53, %call65
  br i1 %cmp66, label %cond.true.68, label %cond.false.70

cond.true.68:                                     ; preds = %cond.false.63
  %54 = load %struct.buffer*, %struct.buffer** %buf, align 8
  %pt69 = getelementptr inbounds %struct.buffer, %struct.buffer* %54, i32 0, i32 75
  %55 = load i64, i64* %pt69, align 8
  br label %cond.end.73

cond.false.70:                                    ; preds = %cond.false.63
  %56 = load %struct.buffer*, %struct.buffer** %buf, align 8
  %pt_marker_71 = getelementptr inbounds %struct.buffer, %struct.buffer* %56, i32 0, i32 45
  %57 = load i64, i64* %pt_marker_71, align 8
  %call72 = call i64 @marker_position(i64 %57)
  br label %cond.end.73

cond.end.73:                                      ; preds = %cond.false.70, %cond.true.68
  %cond74 = phi i64 [ %55, %cond.true.68 ], [ %call72, %cond.false.70 ]
  br label %cond.end.75

cond.end.75:                                      ; preds = %cond.end.73, %cond.true.61
  %cond76 = phi i64 [ %add, %cond.true.61 ], [ %cond74, %cond.end.73 ]
  store i64 %cond76, i64* %pt, align 8
  %58 = load %struct.Lisp_Marker*, %struct.Lisp_Marker** %beg, align 8
  %charpos77 = getelementptr inbounds %struct.Lisp_Marker, %struct.Lisp_Marker* %58, i32 0, i32 3
  %59 = load i64, i64* %charpos77, align 8
  %60 = load %struct.buffer*, %struct.buffer** %buf, align 8
  %begv78 = getelementptr inbounds %struct.buffer, %struct.buffer* %60, i32 0, i32 77
  store i64 %59, i64* %begv78, align 8
  %61 = load %struct.Lisp_Marker*, %struct.Lisp_Marker** %beg, align 8
  %bytepos = getelementptr inbounds %struct.Lisp_Marker, %struct.Lisp_Marker* %61, i32 0, i32 4
  %62 = load i64, i64* %bytepos, align 8
  %63 = load %struct.buffer*, %struct.buffer** %buf, align 8
  %begv_byte = getelementptr inbounds %struct.buffer, %struct.buffer* %63, i32 0, i32 78
  store i64 %62, i64* %begv_byte, align 8
  %64 = load %struct.Lisp_Marker*, %struct.Lisp_Marker** %end, align 8
  %charpos79 = getelementptr inbounds %struct.Lisp_Marker, %struct.Lisp_Marker* %64, i32 0, i32 3
  %65 = load i64, i64* %charpos79, align 8
  %66 = load %struct.buffer*, %struct.buffer** %buf, align 8
  %zv80 = getelementptr inbounds %struct.buffer, %struct.buffer* %66, i32 0, i32 79
  store i64 %65, i64* %zv80, align 8
  %67 = load %struct.Lisp_Marker*, %struct.Lisp_Marker** %end, align 8
  %bytepos81 = getelementptr inbounds %struct.Lisp_Marker, %struct.Lisp_Marker* %67, i32 0, i32 4
  %68 = load i64, i64* %bytepos81, align 8
  %69 = load %struct.buffer*, %struct.buffer** %buf, align 8
  %zv_byte = getelementptr inbounds %struct.buffer, %struct.buffer* %69, i32 0, i32 80
  store i64 %68, i64* %zv_byte, align 8
  %70 = load i64, i64* %pt, align 8
  %71 = load %struct.Lisp_Marker*, %struct.Lisp_Marker** %beg, align 8
  %charpos82 = getelementptr inbounds %struct.Lisp_Marker, %struct.Lisp_Marker* %71, i32 0, i32 3
  %72 = load i64, i64* %charpos82, align 8
  %cmp83 = icmp slt i64 %70, %72
  br i1 %cmp83, label %if.then.89, label %lor.lhs.false.85

lor.lhs.false.85:                                 ; preds = %cond.end.75
  %73 = load i64, i64* %pt, align 8
  %74 = load %struct.Lisp_Marker*, %struct.Lisp_Marker** %end, align 8
  %charpos86 = getelementptr inbounds %struct.Lisp_Marker, %struct.Lisp_Marker* %74, i32 0, i32 3
  %75 = load i64, i64* %charpos86, align 8
  %cmp87 = icmp sgt i64 %73, %75
  br i1 %cmp87, label %if.then.89, label %if.end.116

if.then.89:                                       ; preds = %lor.lhs.false.85, %cond.end.75
  %76 = load %struct.Lisp_Marker*, %struct.Lisp_Marker** %beg, align 8
  %charpos90 = getelementptr inbounds %struct.Lisp_Marker, %struct.Lisp_Marker* %76, i32 0, i32 3
  %77 = load i64, i64* %charpos90, align 8
  %78 = load i64, i64* %pt, align 8
  %79 = load %struct.Lisp_Marker*, %struct.Lisp_Marker** %end, align 8
  %charpos91 = getelementptr inbounds %struct.Lisp_Marker, %struct.Lisp_Marker* %79, i32 0, i32 3
  %80 = load i64, i64* %charpos91, align 8
  %call92 = call i64 @clip_to_bounds(i64 %77, i64 %78, i64 %80)
  %81 = load %struct.buffer*, %struct.buffer** %buf, align 8
  %pt93 = getelementptr inbounds %struct.buffer, %struct.buffer* %81, i32 0, i32 75
  store i64 %call92, i64* %pt93, align 8
  %82 = load %struct.Lisp_Marker*, %struct.Lisp_Marker** %beg, align 8
  %bytepos94 = getelementptr inbounds %struct.Lisp_Marker, %struct.Lisp_Marker* %82, i32 0, i32 4
  %83 = load i64, i64* %bytepos94, align 8
  %84 = load %struct.buffer*, %struct.buffer** %buf, align 8
  %85 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %cmp95 = icmp eq %struct.buffer* %84, %85
  br i1 %cmp95, label %cond.true.97, label %cond.false.99

cond.true.97:                                     ; preds = %if.then.89
  %86 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt_byte = getelementptr inbounds %struct.buffer, %struct.buffer* %86, i32 0, i32 76
  %87 = load i64, i64* %pt_byte, align 8
  %add98 = add nsw i64 %87, 0
  br label %cond.end.111

cond.false.99:                                    ; preds = %if.then.89
  %88 = load %struct.buffer*, %struct.buffer** %buf, align 8
  %pt_marker_100 = getelementptr inbounds %struct.buffer, %struct.buffer* %88, i32 0, i32 45
  %89 = load i64, i64* %pt_marker_100, align 8
  %call101 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp102 = icmp eq i64 %89, %call101
  br i1 %cmp102, label %cond.true.104, label %cond.false.106

cond.true.104:                                    ; preds = %cond.false.99
  %90 = load %struct.buffer*, %struct.buffer** %buf, align 8
  %pt_byte105 = getelementptr inbounds %struct.buffer, %struct.buffer* %90, i32 0, i32 76
  %91 = load i64, i64* %pt_byte105, align 8
  br label %cond.end.109

cond.false.106:                                   ; preds = %cond.false.99
  %92 = load %struct.buffer*, %struct.buffer** %buf, align 8
  %pt_marker_107 = getelementptr inbounds %struct.buffer, %struct.buffer* %92, i32 0, i32 45
  %93 = load i64, i64* %pt_marker_107, align 8
  %call108 = call i64 @marker_byte_position(i64 %93)
  br label %cond.end.109

cond.end.109:                                     ; preds = %cond.false.106, %cond.true.104
  %cond110 = phi i64 [ %91, %cond.true.104 ], [ %call108, %cond.false.106 ]
  br label %cond.end.111

cond.end.111:                                     ; preds = %cond.end.109, %cond.true.97
  %cond112 = phi i64 [ %add98, %cond.true.97 ], [ %cond110, %cond.end.109 ]
  %94 = load %struct.Lisp_Marker*, %struct.Lisp_Marker** %end, align 8
  %bytepos113 = getelementptr inbounds %struct.Lisp_Marker, %struct.Lisp_Marker* %94, i32 0, i32 4
  %95 = load i64, i64* %bytepos113, align 8
  %call114 = call i64 @clip_to_bounds(i64 %83, i64 %cond112, i64 %95)
  %96 = load %struct.buffer*, %struct.buffer** %buf, align 8
  %pt_byte115 = getelementptr inbounds %struct.buffer, %struct.buffer* %96, i32 0, i32 76
  store i64 %call114, i64* %pt_byte115, align 8
  br label %if.end.116

if.end.116:                                       ; preds = %cond.end.111, %lor.lhs.false.85
  %97 = load %struct.buffer*, %struct.buffer** %buf, align 8
  %clip_changed = getelementptr inbounds %struct.buffer, %struct.buffer* %97, i32 0, i32 94
  %bf.load = load i8, i8* %clip_changed, align 8
  %bf.clear = and i8 %bf.load, -3
  %bf.set = or i8 %bf.clear, 2
  store i8 %bf.set, i8* %clip_changed, align 8
  br label %if.end.117

if.end.117:                                       ; preds = %if.end.116, %cond.end.54, %if.then.13
  %98 = load i64, i64* %data.addr, align 8
  %sub118 = sub nsw i64 %98, 3
  %99 = inttoptr i64 %sub118 to i8*
  %100 = bitcast i8* %99 to %struct.Lisp_Cons*
  %car119 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %100, i32 0, i32 0
  %101 = load i64, i64* %car119, align 8
  call void @free_marker(i64 %101)
  %102 = load i64, i64* %data.addr, align 8
  %sub120 = sub nsw i64 %102, 3
  %103 = inttoptr i64 %sub120 to i8*
  %104 = bitcast i8* %103 to %struct.Lisp_Cons*
  %u121 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %104, i32 0, i32 1
  %cdr122 = bitcast %union.anon.20* %u121 to i64*
  %105 = load i64, i64* %cdr122, align 8
  call void @free_marker(i64 %105)
  %106 = load i64, i64* %data.addr, align 8
  %sub123 = sub nsw i64 %106, 3
  %107 = inttoptr i64 %sub123 to i8*
  %108 = bitcast i8* %107 to %struct.Lisp_Cons*
  call void @free_cons(%struct.Lisp_Cons* %108)
  br label %if.end.180

if.else:                                          ; preds = %if.end
  %109 = load %struct.buffer*, %struct.buffer** %buf, align 8
  %tobool124 = icmp ne %struct.buffer* %109, null
  br i1 %tobool124, label %land.lhs.true.125, label %if.end.179

land.lhs.true.125:                                ; preds = %if.else
  %110 = load %struct.buffer*, %struct.buffer** %buf, align 8
  %111 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %cmp126 = icmp eq %struct.buffer* %110, %111
  br i1 %cmp126, label %cond.true.128, label %cond.false.130

cond.true.128:                                    ; preds = %land.lhs.true.125
  %112 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv129 = getelementptr inbounds %struct.buffer, %struct.buffer* %112, i32 0, i32 77
  %113 = load i64, i64* %begv129, align 8
  br label %cond.end.142

cond.false.130:                                   ; preds = %land.lhs.true.125
  %114 = load %struct.buffer*, %struct.buffer** %buf, align 8
  %begv_marker_131 = getelementptr inbounds %struct.buffer, %struct.buffer* %114, i32 0, i32 46
  %115 = load i64, i64* %begv_marker_131, align 8
  %call132 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp133 = icmp eq i64 %115, %call132
  br i1 %cmp133, label %cond.true.135, label %cond.false.137

cond.true.135:                                    ; preds = %cond.false.130
  %116 = load %struct.buffer*, %struct.buffer** %buf, align 8
  %begv136 = getelementptr inbounds %struct.buffer, %struct.buffer* %116, i32 0, i32 77
  %117 = load i64, i64* %begv136, align 8
  br label %cond.end.140

cond.false.137:                                   ; preds = %cond.false.130
  %118 = load %struct.buffer*, %struct.buffer** %buf, align 8
  %begv_marker_138 = getelementptr inbounds %struct.buffer, %struct.buffer* %118, i32 0, i32 46
  %119 = load i64, i64* %begv_marker_138, align 8
  %call139 = call i64 @marker_position(i64 %119)
  br label %cond.end.140

cond.end.140:                                     ; preds = %cond.false.137, %cond.true.135
  %cond141 = phi i64 [ %117, %cond.true.135 ], [ %call139, %cond.false.137 ]
  br label %cond.end.142

cond.end.142:                                     ; preds = %cond.end.140, %cond.true.128
  %cond143 = phi i64 [ %113, %cond.true.128 ], [ %cond141, %cond.end.140 ]
  %cmp144 = icmp ne i64 %cond143, 1
  br i1 %cmp144, label %if.then.167, label %lor.lhs.false.146

lor.lhs.false.146:                                ; preds = %cond.end.142
  %120 = load %struct.buffer*, %struct.buffer** %buf, align 8
  %121 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %cmp147 = icmp eq %struct.buffer* %120, %121
  br i1 %cmp147, label %cond.true.149, label %cond.false.151

cond.true.149:                                    ; preds = %lor.lhs.false.146
  %122 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv150 = getelementptr inbounds %struct.buffer, %struct.buffer* %122, i32 0, i32 79
  %123 = load i64, i64* %zv150, align 8
  br label %cond.end.163

cond.false.151:                                   ; preds = %lor.lhs.false.146
  %124 = load %struct.buffer*, %struct.buffer** %buf, align 8
  %zv_marker_152 = getelementptr inbounds %struct.buffer, %struct.buffer* %124, i32 0, i32 47
  %125 = load i64, i64* %zv_marker_152, align 8
  %call153 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp154 = icmp eq i64 %125, %call153
  br i1 %cmp154, label %cond.true.156, label %cond.false.158

cond.true.156:                                    ; preds = %cond.false.151
  %126 = load %struct.buffer*, %struct.buffer** %buf, align 8
  %zv157 = getelementptr inbounds %struct.buffer, %struct.buffer* %126, i32 0, i32 79
  %127 = load i64, i64* %zv157, align 8
  br label %cond.end.161

cond.false.158:                                   ; preds = %cond.false.151
  %128 = load %struct.buffer*, %struct.buffer** %buf, align 8
  %zv_marker_159 = getelementptr inbounds %struct.buffer, %struct.buffer* %128, i32 0, i32 47
  %129 = load i64, i64* %zv_marker_159, align 8
  %call160 = call i64 @marker_position(i64 %129)
  br label %cond.end.161

cond.end.161:                                     ; preds = %cond.false.158, %cond.true.156
  %cond162 = phi i64 [ %127, %cond.true.156 ], [ %call160, %cond.false.158 ]
  br label %cond.end.163

cond.end.163:                                     ; preds = %cond.end.161, %cond.true.149
  %cond164 = phi i64 [ %123, %cond.true.149 ], [ %cond162, %cond.end.161 ]
  %130 = load %struct.buffer*, %struct.buffer** %buf, align 8
  %text = getelementptr inbounds %struct.buffer, %struct.buffer* %130, i32 0, i32 73
  %131 = load %struct.buffer_text*, %struct.buffer_text** %text, align 8
  %z = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %131, i32 0, i32 2
  %132 = load i64, i64* %z, align 8
  %cmp165 = icmp ne i64 %cond164, %132
  br i1 %cmp165, label %if.then.167, label %if.end.179

if.then.167:                                      ; preds = %cond.end.163, %cond.end.142
  %133 = load %struct.buffer*, %struct.buffer** %buf, align 8
  %begv168 = getelementptr inbounds %struct.buffer, %struct.buffer* %133, i32 0, i32 77
  store i64 1, i64* %begv168, align 8
  %134 = load %struct.buffer*, %struct.buffer** %buf, align 8
  %begv_byte169 = getelementptr inbounds %struct.buffer, %struct.buffer* %134, i32 0, i32 78
  store i64 1, i64* %begv_byte169, align 8
  %135 = load %struct.buffer*, %struct.buffer** %buf, align 8
  %text170 = getelementptr inbounds %struct.buffer, %struct.buffer* %135, i32 0, i32 73
  %136 = load %struct.buffer_text*, %struct.buffer_text** %text170, align 8
  %z171 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %136, i32 0, i32 2
  %137 = load i64, i64* %z171, align 8
  %138 = load %struct.buffer*, %struct.buffer** %buf, align 8
  %zv172 = getelementptr inbounds %struct.buffer, %struct.buffer* %138, i32 0, i32 79
  store i64 %137, i64* %zv172, align 8
  %139 = load %struct.buffer*, %struct.buffer** %buf, align 8
  %text173 = getelementptr inbounds %struct.buffer, %struct.buffer* %139, i32 0, i32 73
  %140 = load %struct.buffer_text*, %struct.buffer_text** %text173, align 8
  %z_byte = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %140, i32 0, i32 4
  %141 = load i64, i64* %z_byte, align 8
  %142 = load %struct.buffer*, %struct.buffer** %buf, align 8
  %zv_byte174 = getelementptr inbounds %struct.buffer, %struct.buffer* %142, i32 0, i32 80
  store i64 %141, i64* %zv_byte174, align 8
  %143 = load %struct.buffer*, %struct.buffer** %buf, align 8
  %clip_changed175 = getelementptr inbounds %struct.buffer, %struct.buffer* %143, i32 0, i32 94
  %bf.load176 = load i8, i8* %clip_changed175, align 8
  %bf.clear177 = and i8 %bf.load176, -3
  %bf.set178 = or i8 %bf.clear177, 2
  store i8 %bf.set178, i8* %clip_changed175, align 8
  br label %if.end.179

if.end.179:                                       ; preds = %if.then.167, %cond.end.163, %if.else
  br label %if.end.180

if.end.180:                                       ; preds = %if.end.179, %if.end.117
  call void @invalidate_current_column()
  %144 = load %struct.buffer*, %struct.buffer** %cur, align 8
  %tobool181 = icmp ne %struct.buffer* %144, null
  br i1 %tobool181, label %if.then.182, label %if.end.183

if.then.182:                                      ; preds = %if.end.180
  %145 = load %struct.buffer*, %struct.buffer** %cur, align 8
  call void @set_buffer_internal(%struct.buffer* %145)
  br label %if.end.183

if.end.183:                                       ; preds = %if.then.182, %if.end.180
  ret void
}

declare void @set_buffer_internal(%struct.buffer*) #1

declare void @free_marker(i64) #1

declare void @free_cons(%struct.Lisp_Cons*) #1

; Function Attrs: nounwind uwtable
define i64 @Fsave_restriction(i64 %body) #0 {
entry:
  %body.addr = alloca i64, align 8
  %val = alloca i64, align 8
  %count = alloca i64, align 8
  store i64 %body, i64* %body.addr, align 8
  %call = call i64 @SPECPDL_INDEX()
  store i64 %call, i64* %count, align 8
  %call1 = call i64 @save_restriction_save()
  call void @record_unwind_protect(void (i64)* @save_restriction_restore, i64 %call1)
  %0 = load i64, i64* %body.addr, align 8
  %call2 = call i64 @Fprogn(i64 %0)
  store i64 %call2, i64* %val, align 8
  %1 = load i64, i64* %count, align 8
  %2 = load i64, i64* %val, align 8
  %call3 = call i64 @unbind_to(i64 %1, i64 %2)
  ret i64 %call3
}

; Function Attrs: nounwind uwtable
define i64 @Fmessage(i64 %nargs, i64* %args) #0 {
entry:
  %retval = alloca i64, align 8
  %nargs.addr = alloca i64, align 8
  %args.addr = alloca i64*, align 8
  %val = alloca i64, align 8
  store i64 %nargs, i64* %nargs.addr, align 8
  store i64* %args, i64** %args.addr, align 8
  %0 = load i64*, i64** %args.addr, align 8
  %arrayidx = getelementptr inbounds i64, i64* %0, i64 0
  %1 = load i64, i64* %arrayidx, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %1, %call
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load i64*, i64** %args.addr, align 8
  %arrayidx1 = getelementptr inbounds i64, i64* %2, i64 0
  %3 = load i64, i64* %arrayidx1, align 8
  %call2 = call zeroext i1 @STRINGP(i64 %3)
  br i1 %call2, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %lor.lhs.false
  %4 = load i64*, i64** %args.addr, align 8
  %arrayidx3 = getelementptr inbounds i64, i64* %4, i64 0
  %5 = load i64, i64* %arrayidx3, align 8
  %call4 = call i64 @SBYTES(i64 %5)
  %cmp5 = icmp eq i64 %call4, 0
  br i1 %cmp5, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true, %entry
  call void @message1(i8* null)
  %6 = load i64*, i64** %args.addr, align 8
  %arrayidx6 = getelementptr inbounds i64, i64* %6, i64 0
  %7 = load i64, i64* %arrayidx6, align 8
  store i64 %7, i64* %retval
  br label %return

if.else:                                          ; preds = %land.lhs.true, %lor.lhs.false
  %8 = load i64, i64* %nargs.addr, align 8
  %9 = load i64*, i64** %args.addr, align 8
  %call7 = call i64 @Fformat_message(i64 %8, i64* %9)
  store i64 %call7, i64* %val, align 8
  %10 = load i64, i64* %val, align 8
  call void @message3(i64 %10)
  %11 = load i64, i64* %val, align 8
  store i64 %11, i64* %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %12 = load i64, i64* %retval
  ret i64 %12
}

declare void @message1(i8*) #1

; Function Attrs: nounwind uwtable
define i64 @Fformat_message(i64 %nargs, i64* %args) #0 {
entry:
  %nargs.addr = alloca i64, align 8
  %args.addr = alloca i64*, align 8
  store i64 %nargs, i64* %nargs.addr, align 8
  store i64* %args, i64** %args.addr, align 8
  %0 = load i64, i64* %nargs.addr, align 8
  %1 = load i64*, i64** %args.addr, align 8
  %call = call i64 @styled_format(i64 %0, i64* %1, i1 zeroext true)
  ret i64 %call
}

declare void @message3(i64) #1

; Function Attrs: nounwind uwtable
define i64 @Fmessage_box(i64 %nargs, i64* %args) #0 {
entry:
  %retval = alloca i64, align 8
  %nargs.addr = alloca i64, align 8
  %args.addr = alloca i64*, align 8
  %val = alloca i64, align 8
  %pane = alloca i64, align 8
  %menu = alloca i64, align 8
  store i64 %nargs, i64* %nargs.addr, align 8
  store i64* %args, i64** %args.addr, align 8
  %0 = load i64*, i64** %args.addr, align 8
  %arrayidx = getelementptr inbounds i64, i64* %0, i64 0
  %1 = load i64, i64* %arrayidx, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %1, %call
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  call void @message1(i8* null)
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call1, i64* %retval
  br label %return

if.else:                                          ; preds = %entry
  %2 = load i64, i64* %nargs.addr, align 8
  %3 = load i64*, i64** %args.addr, align 8
  %call2 = call i64 @Fformat_message(i64 %2, i64* %3)
  store i64 %call2, i64* %val, align 8
  %call3 = call i64 @build_string(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.14, i32 0, i32 0))
  %call4 = call i64 @builtin_lisp_symbol(i32 901)
  %call5 = call i64 @Fcons(i64 %call3, i64 %call4)
  %call6 = call i64 @list1(i64 %call5)
  store i64 %call6, i64* %pane, align 8
  %4 = load i64, i64* %val, align 8
  %5 = load i64, i64* %pane, align 8
  %call7 = call i64 @Fcons(i64 %4, i64 %5)
  store i64 %call7, i64* %menu, align 8
  %call8 = call i64 @builtin_lisp_symbol(i32 901)
  %6 = load i64, i64* %menu, align 8
  %call9 = call i64 @builtin_lisp_symbol(i32 901)
  %call10 = call i64 @Fx_popup_dialog(i64 %call8, i64 %6, i64 %call9)
  %7 = load i64, i64* %val, align 8
  store i64 %7, i64* %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %8 = load i64, i64* %retval
  ret i64 %8
}

declare i64 @list1(i64) #1

declare i64 @Fx_popup_dialog(i64, i64, i64) #1

; Function Attrs: nounwind uwtable
define i64 @Fmessage_or_box(i64 %nargs, i64* %args) #0 {
entry:
  %retval = alloca i64, align 8
  %nargs.addr = alloca i64, align 8
  %args.addr = alloca i64*, align 8
  store i64 %nargs, i64* %nargs.addr, align 8
  store i64* %args, i64** %args.addr, align 8
  %0 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 377), align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %0, %call
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 377), align 8
  %and = and i64 %1, 7
  %conv = trunc i64 %and to i32
  %cmp1 = icmp eq i32 %conv, 3
  br i1 %cmp1, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.lhs.false, %entry
  %2 = load i8, i8* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 493), align 1
  %tobool = trunc i8 %2 to i1
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %3 = load i64, i64* %nargs.addr, align 8
  %4 = load i64*, i64** %args.addr, align 8
  %call4 = call i64 @Fmessage_box(i64 %3, i64* %4)
  store i64 %call4, i64* %retval
  br label %return

if.end:                                           ; preds = %land.lhs.true, %lor.lhs.false
  %5 = load i64, i64* %nargs.addr, align 8
  %6 = load i64*, i64** %args.addr, align 8
  %call5 = call i64 @Fmessage(i64 %5, i64* %6)
  store i64 %call5, i64* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load i64, i64* %retval
  ret i64 %7
}

; Function Attrs: nounwind uwtable
define i64 @Fcurrent_message() #0 {
entry:
  %call = call i64 @current_message()
  ret i64 %call
}

declare i64 @current_message() #1

; Function Attrs: nounwind uwtable
define i64 @Fpropertize(i64 %nargs, i64* %args) #0 {
entry:
  %nargs.addr = alloca i64, align 8
  %args.addr = alloca i64*, align 8
  %properties = alloca i64, align 8
  %string = alloca i64, align 8
  %i = alloca i64, align 8
  store i64 %nargs, i64* %nargs.addr, align 8
  store i64* %args, i64** %args.addr, align 8
  %0 = load i64, i64* %nargs.addr, align 8
  %and = and i64 %0, 1
  %cmp = icmp eq i64 %and, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void (i8*, ...) @error(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.15, i32 0, i32 0)) #9
  unreachable

if.end:                                           ; preds = %entry
  %call = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call, i64* %string, align 8
  store i64 %call, i64* %properties, align 8
  %1 = load i64*, i64** %args.addr, align 8
  %arrayidx = getelementptr inbounds i64, i64* %1, i64 0
  %2 = load i64, i64* %arrayidx, align 8
  call void @CHECK_STRING(i64 %2)
  %3 = load i64*, i64** %args.addr, align 8
  %arrayidx1 = getelementptr inbounds i64, i64* %3, i64 0
  %4 = load i64, i64* %arrayidx1, align 8
  %call2 = call i64 @Fcopy_sequence(i64 %4)
  store i64 %call2, i64* %string, align 8
  store i64 1, i64* %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %5 = load i64, i64* %i, align 8
  %6 = load i64, i64* %nargs.addr, align 8
  %cmp3 = icmp slt i64 %5, %6
  br i1 %cmp3, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load i64, i64* %i, align 8
  %8 = load i64*, i64** %args.addr, align 8
  %arrayidx4 = getelementptr inbounds i64, i64* %8, i64 %7
  %9 = load i64, i64* %arrayidx4, align 8
  %10 = load i64, i64* %i, align 8
  %add = add nsw i64 %10, 1
  %11 = load i64*, i64** %args.addr, align 8
  %arrayidx5 = getelementptr inbounds i64, i64* %11, i64 %add
  %12 = load i64, i64* %arrayidx5, align 8
  %13 = load i64, i64* %properties, align 8
  %call6 = call i64 @Fcons(i64 %12, i64 %13)
  %call7 = call i64 @Fcons(i64 %9, i64 %call6)
  store i64 %call7, i64* %properties, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %14 = load i64, i64* %i, align 8
  %add8 = add nsw i64 %14, 2
  store i64 %add8, i64* %i, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %15 = load i64, i64* %string, align 8
  %call9 = call i64 @SCHARS(i64 %15)
  %shl = shl i64 %call9, 2
  %add10 = add i64 %shl, 2
  %16 = load i64, i64* %properties, align 8
  %17 = load i64, i64* %string, align 8
  %call11 = call i64 @Fadd_text_properties(i64 2, i64 %add10, i64 %16, i64 %17)
  %18 = load i64, i64* %string, align 8
  ret i64 %18
}

declare i64 @Fcopy_sequence(i64) #1

declare i64 @Fadd_text_properties(i64, i64, i64, i64) #1

; Function Attrs: nounwind uwtable
define i64 @Fformat(i64 %nargs, i64* %args) #0 {
entry:
  %nargs.addr = alloca i64, align 8
  %args.addr = alloca i64*, align 8
  store i64 %nargs, i64* %nargs.addr, align 8
  store i64* %args, i64** %args.addr, align 8
  %0 = load i64, i64* %nargs.addr, align 8
  %1 = load i64*, i64** %args.addr, align 8
  %call = call i64 @styled_format(i64 %0, i64* %1, i1 zeroext false)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define internal i64 @styled_format(i64 %nargs, i64* %args, i1 zeroext %message) #0 {
entry:
  %nargs.addr = alloca i64, align 8
  %args.addr = alloca i64*, align 8
  %message.addr = alloca i8, align 1
  %n = alloca i64, align 8
  %initial_buffer = alloca [4000 x i8], align 16
  %buf = alloca i8*, align 8
  %bufsize = alloca i64, align 8
  %max_bufsize = alloca i64, align 8
  %p = alloca i8*, align 8
  %buf_save_value_index = alloca i64, align 8
  %format = alloca i8*, align 8
  %end = alloca i8*, align 8
  %nchars = alloca i64, align 8
  %maybe_combine_byte = alloca i8, align 1
  %arg_intervals = alloca i8, align 1
  %sa_avail = alloca i64, align 8
  %sa_count = alloca i64, align 8
  %sa_must_free = alloca i8, align 1
  %info = alloca %struct.info*, align 8
  %format_start = alloca i8*, align 8
  %formatlen = alloca i64, align 8
  %alloca_size = alloca i64, align 8
  %i = alloca i64, align 8
  %discarded = alloca i8*, align 8
  %multibyte_format = alloca i8, align 1
  %multibyte = alloca i8, align 1
  %i5894 = alloca i64, align 8
  %quoting_style = alloca i32, align 4
  %n0 = alloca i64, align 8
  %format0 = alloca i8*, align 8
  %convsrc = alloca i8*, align 8
  %format_char = alloca i8, align 1
  %convbytes = alloca i64, align 8
  %minus_flag = alloca i8, align 1
  %plus_flag = alloca i8, align 1
  %space_flag = alloca i8, align 1
  %sharp_flag = alloca i8, align 1
  %zero_flag = alloca i8, align 1
  %num_end = alloca i8*, align 8
  %raw_field_width = alloca i64, align 8
  %field_width = alloca i64, align 8
  %precision_given = alloca i8, align 1
  %precision = alloca i64, align 8
  %conversion = alloca i8, align 1
  %noescape = alloca i64, align 8
  %d = alloca double, align 8
  %prec = alloca i64, align 8
  %width = alloca i64, align 8
  %nbytes = alloca i64, align 8
  %nchars_string = alloca i64, align 8
  %nch = alloca i64, align 8
  %nby = alloca i64, align 8
  %padding = alloca i64, align 8
  %convspec = alloca [9 x i8], align 1
  %f = alloca i8*, align 8
  %prec6410 = alloca i32, align 4
  %sprintf_buf = alloca [1334 x i8], align 16
  %sprintf_bytes = alloca i64, align 8
  %x = alloca double, align 8
  %x6469 = alloca i64, align 8
  %d6480 = alloca double, align 8
  %x6506 = alloca i64, align 8
  %d6517 = alloca double, align 8
  %excess_precision = alloca i64, align 8
  %leading_zeros = alloca i64, align 8
  %trailing_zeros = alloca i64, align 8
  %dot = alloca i8*, align 8
  %numwidth = alloca i64, align 8
  %padding6589 = alloca i64, align 8
  %src = alloca i8*, align 8
  %src0 = alloca i8, align 1
  %exponent_bytes = alloca i32, align 4
  %signedp = alloca i8, align 1
  %e = alloca i8*, align 8
  %significand_bytes = alloca i32, align 4
  %str = alloca [5 x i8], align 1
  %c = alloca i32, align 4
  %used = alloca i64, align 8
  %val = alloca i64, align 8
  %len = alloca i64, align 8
  %props = alloca i64, align 8
  %bytepos = alloca i64, align 8
  %position = alloca i64, align 8
  %translated = alloca i64, align 8
  %argn = alloca i64, align 8
  %list = alloca i64, align 8
  %item = alloca i64, align 8
  %pos = alloca i64, align 8
  %i7110 = alloca i64, align 8
  %new_len = alloca i64, align 8
  store i64 %nargs, i64* %nargs.addr, align 8
  store i64* %args, i64** %args.addr, align 8
  %frombool = zext i1 %message to i8
  store i8 %frombool, i8* %message.addr, align 1
  %arraydecay = getelementptr inbounds [4000 x i8], [4000 x i8]* %initial_buffer, i32 0, i32 0
  store i8* %arraydecay, i8** %buf, align 8
  store i64 4000, i64* %bufsize, align 8
  store i64 2305843009213693952, i64* %max_bufsize, align 8
  store i8 0, i8* %arg_intervals, align 1
  store i64 16384, i64* %sa_avail, align 8
  %call = call i64 @SPECPDL_INDEX()
  store i64 %call, i64* %sa_count, align 8
  store i8 0, i8* %sa_must_free, align 1
  %0 = load i64*, i64** %args.addr, align 8
  %arrayidx = getelementptr inbounds i64, i64* %0, i64 0
  %1 = load i64, i64* %arrayidx, align 8
  call void @CHECK_STRING(i64 %1)
  %2 = load i64*, i64** %args.addr, align 8
  %arrayidx1 = getelementptr inbounds i64, i64* %2, i64 0
  %3 = load i64, i64* %arrayidx1, align 8
  %call2 = call i8* @SSDATA(i64 %3)
  store i8* %call2, i8** %format_start, align 8
  %4 = load i64*, i64** %args.addr, align 8
  %arrayidx3 = getelementptr inbounds i64, i64* %4, i64 0
  %5 = load i64, i64* %arrayidx3, align 8
  %call4 = call i64 @SBYTES(i64 %5)
  store i64 %call4, i64* %formatlen, align 8
  br i1 false, label %cond.true, label %cond.false.475

cond.true:                                        ; preds = %entry
  br i1 false, label %cond.true.5, label %cond.false.260

cond.true.5:                                      ; preds = %cond.true
  %6 = load i64, i64* %nargs.addr, align 8
  %conv = trunc i64 %6 to i8
  %conv6 = sext i8 %conv to i32
  %add = add nsw i32 0, %conv6
  %mul = mul nsw i32 0, %add
  %sub = sub nsw i32 %mul, 1
  %cmp = icmp slt i32 %sub, 0
  br i1 %cmp, label %cond.true.8, label %cond.false

cond.true.8:                                      ; preds = %cond.true.5
  %7 = load i64, i64* %nargs.addr, align 8
  %conv9 = trunc i64 %7 to i8
  %conv10 = sext i8 %conv9 to i32
  %add11 = add nsw i32 0, %conv10
  %mul12 = mul nsw i32 0, %add11
  %add13 = add nsw i32 %mul12, 0
  %neg = xor i32 %add13, -1
  %cmp14 = icmp eq i32 %neg, -1
  %conv15 = zext i1 %cmp14 to i32
  %sub16 = sub nsw i32 0, %conv15
  %8 = load i64, i64* %nargs.addr, align 8
  %conv17 = trunc i64 %8 to i8
  %conv18 = sext i8 %conv17 to i32
  %add19 = add nsw i32 0, %conv18
  %mul20 = mul nsw i32 0, %add19
  %add21 = add nsw i32 %mul20, 1
  %shl = shl i32 %add21, 30
  %sub22 = sub nsw i32 %shl, 1
  %mul23 = mul nsw i32 %sub22, 2
  %add24 = add nsw i32 %mul23, 1
  %sub25 = sub nsw i32 %sub16, %add24
  br label %cond.end

cond.false:                                       ; preds = %cond.true.5
  %9 = load i64, i64* %nargs.addr, align 8
  %conv26 = trunc i64 %9 to i8
  %conv27 = sext i8 %conv26 to i32
  %add28 = add nsw i32 0, %conv27
  %mul29 = mul nsw i32 0, %add28
  %add30 = add nsw i32 %mul29, 0
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true.8
  %cond = phi i32 [ %sub25, %cond.true.8 ], [ %add30, %cond.false ]
  %cmp31 = icmp eq i32 %cond, 0
  br i1 %cmp31, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %cond.end
  %10 = load i64, i64* %nargs.addr, align 8
  %conv33 = trunc i64 %10 to i8
  %conv34 = sext i8 %conv33 to i32
  %cmp35 = icmp slt i32 %conv34, 0
  br i1 %cmp35, label %cond.true.214, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %cond.end
  br i1 false, label %cond.true.37, label %cond.false.115

cond.true.37:                                     ; preds = %lor.lhs.false
  %11 = load i64, i64* %nargs.addr, align 8
  %conv38 = trunc i64 %11 to i8
  %conv39 = sext i8 %conv38 to i32
  %cmp40 = icmp slt i32 %conv39, 0
  br i1 %cmp40, label %cond.true.42, label %cond.false.72

cond.true.42:                                     ; preds = %cond.true.37
  %12 = load i64, i64* %nargs.addr, align 8
  %conv43 = trunc i64 %12 to i8
  %conv44 = sext i8 %conv43 to i32
  %13 = load i64, i64* %nargs.addr, align 8
  %conv45 = trunc i64 %13 to i8
  %conv46 = sext i8 %conv45 to i32
  %add47 = add nsw i32 0, %conv46
  %mul48 = mul nsw i32 0, %add47
  %sub49 = sub nsw i32 %mul48, 1
  %cmp50 = icmp slt i32 %sub49, 0
  br i1 %cmp50, label %cond.true.52, label %cond.false.62

cond.true.52:                                     ; preds = %cond.true.42
  %14 = load i64, i64* %nargs.addr, align 8
  %conv53 = trunc i64 %14 to i8
  %conv54 = sext i8 %conv53 to i32
  %add55 = add nsw i32 0, %conv54
  %mul56 = mul nsw i32 0, %add55
  %add57 = add nsw i32 %mul56, 1
  %shl58 = shl i32 %add57, 30
  %sub59 = sub nsw i32 %shl58, 1
  %mul60 = mul nsw i32 %sub59, 2
  %add61 = add nsw i32 %mul60, 1
  br label %cond.end.68

cond.false.62:                                    ; preds = %cond.true.42
  %15 = load i64, i64* %nargs.addr, align 8
  %conv63 = trunc i64 %15 to i8
  %conv64 = sext i8 %conv63 to i32
  %add65 = add nsw i32 0, %conv64
  %mul66 = mul nsw i32 0, %add65
  %sub67 = sub nsw i32 %mul66, 1
  br label %cond.end.68

cond.end.68:                                      ; preds = %cond.false.62, %cond.true.52
  %cond69 = phi i32 [ %add61, %cond.true.52 ], [ %sub67, %cond.false.62 ]
  %div = sdiv i32 %cond69, 24
  %cmp70 = icmp slt i32 %conv44, %div
  br i1 %cmp70, label %cond.true.214, label %lor.lhs.false.194

cond.false.72:                                    ; preds = %cond.true.37
  br i1 false, label %cond.true.73, label %cond.false.74

cond.true.73:                                     ; preds = %cond.false.72
  br i1 false, label %cond.true.214, label %lor.lhs.false.194

cond.false.74:                                    ; preds = %cond.false.72
  %16 = load i64, i64* %nargs.addr, align 8
  %conv75 = trunc i64 %16 to i8
  %conv76 = sext i8 %conv75 to i32
  %add77 = add nsw i32 0, %conv76
  %mul78 = mul nsw i32 0, %add77
  %sub79 = sub nsw i32 %mul78, 1
  %cmp80 = icmp slt i32 %sub79, 0
  br i1 %cmp80, label %cond.true.82, label %cond.false.102

cond.true.82:                                     ; preds = %cond.false.74
  %17 = load i64, i64* %nargs.addr, align 8
  %conv83 = trunc i64 %17 to i8
  %conv84 = sext i8 %conv83 to i32
  %add85 = add nsw i32 0, %conv84
  %mul86 = mul nsw i32 0, %add85
  %add87 = add nsw i32 %mul86, 0
  %neg88 = xor i32 %add87, -1
  %cmp89 = icmp eq i32 %neg88, -1
  %conv90 = zext i1 %cmp89 to i32
  %sub91 = sub nsw i32 0, %conv90
  %18 = load i64, i64* %nargs.addr, align 8
  %conv92 = trunc i64 %18 to i8
  %conv93 = sext i8 %conv92 to i32
  %add94 = add nsw i32 0, %conv93
  %mul95 = mul nsw i32 0, %add94
  %add96 = add nsw i32 %mul95, 1
  %shl97 = shl i32 %add96, 30
  %sub98 = sub nsw i32 %shl97, 1
  %mul99 = mul nsw i32 %sub98, 2
  %add100 = add nsw i32 %mul99, 1
  %sub101 = sub nsw i32 %sub91, %add100
  br label %cond.end.108

cond.false.102:                                   ; preds = %cond.false.74
  %19 = load i64, i64* %nargs.addr, align 8
  %conv103 = trunc i64 %19 to i8
  %conv104 = sext i8 %conv103 to i32
  %add105 = add nsw i32 0, %conv104
  %mul106 = mul nsw i32 0, %add105
  %add107 = add nsw i32 %mul106, 0
  br label %cond.end.108

cond.end.108:                                     ; preds = %cond.false.102, %cond.true.82
  %cond109 = phi i32 [ %sub101, %cond.true.82 ], [ %add107, %cond.false.102 ]
  %div110 = sdiv i32 %cond109, 24
  %20 = load i64, i64* %nargs.addr, align 8
  %conv111 = trunc i64 %20 to i8
  %conv112 = sext i8 %conv111 to i32
  %cmp113 = icmp slt i32 %div110, %conv112
  br i1 %cmp113, label %cond.true.214, label %lor.lhs.false.194

cond.false.115:                                   ; preds = %lor.lhs.false
  br i1 false, label %cond.true.116, label %cond.false.117

cond.true.116:                                    ; preds = %cond.false.115
  br i1 false, label %cond.true.214, label %lor.lhs.false.194

cond.false.117:                                   ; preds = %cond.false.115
  %21 = load i64, i64* %nargs.addr, align 8
  %conv118 = trunc i64 %21 to i8
  %conv119 = sext i8 %conv118 to i32
  %cmp120 = icmp slt i32 %conv119, 0
  br i1 %cmp120, label %cond.true.122, label %cond.false.163

cond.true.122:                                    ; preds = %cond.false.117
  %22 = load i64, i64* %nargs.addr, align 8
  %conv123 = trunc i64 %22 to i8
  %conv124 = sext i8 %conv123 to i32
  %23 = load i64, i64* %nargs.addr, align 8
  %conv125 = trunc i64 %23 to i8
  %conv126 = sext i8 %conv125 to i32
  %add127 = add nsw i32 0, %conv126
  %mul128 = mul nsw i32 0, %add127
  %sub129 = sub nsw i32 %mul128, 1
  %cmp130 = icmp slt i32 %sub129, 0
  br i1 %cmp130, label %cond.true.132, label %cond.false.152

cond.true.132:                                    ; preds = %cond.true.122
  %24 = load i64, i64* %nargs.addr, align 8
  %conv133 = trunc i64 %24 to i8
  %conv134 = sext i8 %conv133 to i32
  %add135 = add nsw i32 0, %conv134
  %mul136 = mul nsw i32 0, %add135
  %add137 = add nsw i32 %mul136, 0
  %neg138 = xor i32 %add137, -1
  %cmp139 = icmp eq i32 %neg138, -1
  %conv140 = zext i1 %cmp139 to i32
  %sub141 = sub nsw i32 0, %conv140
  %25 = load i64, i64* %nargs.addr, align 8
  %conv142 = trunc i64 %25 to i8
  %conv143 = sext i8 %conv142 to i32
  %add144 = add nsw i32 0, %conv143
  %mul145 = mul nsw i32 0, %add144
  %add146 = add nsw i32 %mul145, 1
  %shl147 = shl i32 %add146, 30
  %sub148 = sub nsw i32 %shl147, 1
  %mul149 = mul nsw i32 %sub148, 2
  %add150 = add nsw i32 %mul149, 1
  %sub151 = sub nsw i32 %sub141, %add150
  br label %cond.end.158

cond.false.152:                                   ; preds = %cond.true.122
  %26 = load i64, i64* %nargs.addr, align 8
  %conv153 = trunc i64 %26 to i8
  %conv154 = sext i8 %conv153 to i32
  %add155 = add nsw i32 0, %conv154
  %mul156 = mul nsw i32 0, %add155
  %add157 = add nsw i32 %mul156, 0
  br label %cond.end.158

cond.end.158:                                     ; preds = %cond.false.152, %cond.true.132
  %cond159 = phi i32 [ %sub151, %cond.true.132 ], [ %add157, %cond.false.152 ]
  %div160 = sdiv i32 %cond159, 24
  %cmp161 = icmp slt i32 %conv124, %div160
  br i1 %cmp161, label %cond.true.214, label %lor.lhs.false.194

cond.false.163:                                   ; preds = %cond.false.117
  %27 = load i64, i64* %nargs.addr, align 8
  %conv164 = trunc i64 %27 to i8
  %conv165 = sext i8 %conv164 to i32
  %add166 = add nsw i32 0, %conv165
  %mul167 = mul nsw i32 0, %add166
  %sub168 = sub nsw i32 %mul167, 1
  %cmp169 = icmp slt i32 %sub168, 0
  br i1 %cmp169, label %cond.true.171, label %cond.false.181

cond.true.171:                                    ; preds = %cond.false.163
  %28 = load i64, i64* %nargs.addr, align 8
  %conv172 = trunc i64 %28 to i8
  %conv173 = sext i8 %conv172 to i32
  %add174 = add nsw i32 0, %conv173
  %mul175 = mul nsw i32 0, %add174
  %add176 = add nsw i32 %mul175, 1
  %shl177 = shl i32 %add176, 30
  %sub178 = sub nsw i32 %shl177, 1
  %mul179 = mul nsw i32 %sub178, 2
  %add180 = add nsw i32 %mul179, 1
  br label %cond.end.187

cond.false.181:                                   ; preds = %cond.false.163
  %29 = load i64, i64* %nargs.addr, align 8
  %conv182 = trunc i64 %29 to i8
  %conv183 = sext i8 %conv182 to i32
  %add184 = add nsw i32 0, %conv183
  %mul185 = mul nsw i32 0, %add184
  %sub186 = sub nsw i32 %mul185, 1
  br label %cond.end.187

cond.end.187:                                     ; preds = %cond.false.181, %cond.true.171
  %cond188 = phi i32 [ %add180, %cond.true.171 ], [ %sub186, %cond.false.181 ]
  %div189 = sdiv i32 %cond188, 24
  %30 = load i64, i64* %nargs.addr, align 8
  %conv190 = trunc i64 %30 to i8
  %conv191 = sext i8 %conv190 to i32
  %cmp192 = icmp slt i32 %div189, %conv191
  br i1 %cmp192, label %cond.true.214, label %lor.lhs.false.194

lor.lhs.false.194:                                ; preds = %cond.end.187, %cond.end.158, %cond.true.116, %cond.end.108, %cond.true.73, %cond.end.68
  %31 = load i64, i64* %nargs.addr, align 8
  %conv195 = trunc i64 %31 to i8
  %conv196 = sext i8 %conv195 to i32
  %mul197 = mul nsw i32 %conv196, 24
  %mul198 = mul nsw i32 0, %mul197
  %sub199 = sub nsw i32 %mul198, 1
  %cmp200 = icmp slt i32 %sub199, 0
  br i1 %cmp200, label %land.lhs.true.202, label %lor.lhs.false.208

land.lhs.true.202:                                ; preds = %lor.lhs.false.194
  %32 = load i64, i64* %nargs.addr, align 8
  %conv203 = trunc i64 %32 to i8
  %conv204 = sext i8 %conv203 to i32
  %mul205 = mul nsw i32 %conv204, 24
  %cmp206 = icmp slt i32 %mul205, -128
  br i1 %cmp206, label %cond.true.214, label %lor.lhs.false.208

lor.lhs.false.208:                                ; preds = %land.lhs.true.202, %lor.lhs.false.194
  %33 = load i64, i64* %nargs.addr, align 8
  %conv209 = trunc i64 %33 to i8
  %conv210 = sext i8 %conv209 to i32
  %mul211 = mul nsw i32 %conv210, 24
  %cmp212 = icmp slt i32 127, %mul211
  br i1 %cmp212, label %cond.true.214, label %cond.false.237

cond.true.214:                                    ; preds = %lor.lhs.false.208, %land.lhs.true.202, %cond.end.187, %cond.end.158, %cond.true.116, %cond.end.108, %cond.true.73, %cond.end.68, %land.lhs.true
  %34 = load i64, i64* %nargs.addr, align 8
  %conv215 = trunc i64 %34 to i8
  %conv216 = zext i8 %conv215 to i32
  %mul217 = mul nsw i32 %conv216, 24
  %cmp218 = icmp sle i32 %mul217, 127
  br i1 %cmp218, label %cond.true.220, label %cond.false.226

cond.true.220:                                    ; preds = %cond.true.214
  %35 = load i64, i64* %nargs.addr, align 8
  %conv221 = trunc i64 %35 to i8
  %conv222 = zext i8 %conv221 to i32
  %mul223 = mul nsw i32 %conv222, 24
  %conv224 = trunc i32 %mul223 to i8
  %conv225 = sext i8 %conv224 to i32
  br label %cond.end.234

cond.false.226:                                   ; preds = %cond.true.214
  %36 = load i64, i64* %nargs.addr, align 8
  %conv227 = trunc i64 %36 to i8
  %conv228 = zext i8 %conv227 to i32
  %mul229 = mul nsw i32 %conv228, 24
  %sub230 = sub nsw i32 %mul229, -128
  %conv231 = trunc i32 %sub230 to i8
  %conv232 = sext i8 %conv231 to i32
  %add233 = add nsw i32 %conv232, -128
  br label %cond.end.234

cond.end.234:                                     ; preds = %cond.false.226, %cond.true.220
  %cond235 = phi i32 [ %conv225, %cond.true.220 ], [ %add233, %cond.false.226 ]
  %conv236 = sext i32 %cond235 to i64
  store i64 %conv236, i64* %alloca_size, align 8
  br i1 true, label %if.then, label %lor.lhs.false.2164

cond.false.237:                                   ; preds = %lor.lhs.false.208
  %37 = load i64, i64* %nargs.addr, align 8
  %conv238 = trunc i64 %37 to i8
  %conv239 = zext i8 %conv238 to i32
  %mul240 = mul nsw i32 %conv239, 24
  %cmp241 = icmp sle i32 %mul240, 127
  br i1 %cmp241, label %cond.true.243, label %cond.false.249

cond.true.243:                                    ; preds = %cond.false.237
  %38 = load i64, i64* %nargs.addr, align 8
  %conv244 = trunc i64 %38 to i8
  %conv245 = zext i8 %conv244 to i32
  %mul246 = mul nsw i32 %conv245, 24
  %conv247 = trunc i32 %mul246 to i8
  %conv248 = sext i8 %conv247 to i32
  br label %cond.end.257

cond.false.249:                                   ; preds = %cond.false.237
  %39 = load i64, i64* %nargs.addr, align 8
  %conv250 = trunc i64 %39 to i8
  %conv251 = zext i8 %conv250 to i32
  %mul252 = mul nsw i32 %conv251, 24
  %sub253 = sub nsw i32 %mul252, -128
  %conv254 = trunc i32 %sub253 to i8
  %conv255 = sext i8 %conv254 to i32
  %add256 = add nsw i32 %conv255, -128
  br label %cond.end.257

cond.end.257:                                     ; preds = %cond.false.249, %cond.true.243
  %cond258 = phi i32 [ %conv248, %cond.true.243 ], [ %add256, %cond.false.249 ]
  %conv259 = sext i32 %cond258 to i64
  store i64 %conv259, i64* %alloca_size, align 8
  br i1 false, label %if.then, label %lor.lhs.false.2164

cond.false.260:                                   ; preds = %cond.true
  %40 = load i64, i64* %nargs.addr, align 8
  %add261 = add i64 0, %40
  %mul262 = mul i64 0, %add261
  %sub263 = sub i64 %mul262, 1
  %cmp264 = icmp ult i64 %sub263, 0
  br i1 %cmp264, label %cond.true.266, label %cond.false.283

cond.true.266:                                    ; preds = %cond.false.260
  %41 = load i64, i64* %nargs.addr, align 8
  %add267 = add i64 0, %41
  %mul268 = mul i64 0, %add267
  %add269 = add i64 %mul268, 0
  %neg270 = xor i64 %add269, -1
  %cmp271 = icmp eq i64 %neg270, -1
  %conv272 = zext i1 %cmp271 to i32
  %sub273 = sub nsw i32 0, %conv272
  %conv274 = sext i32 %sub273 to i64
  %42 = load i64, i64* %nargs.addr, align 8
  %add275 = add i64 0, %42
  %mul276 = mul i64 0, %add275
  %add277 = add i64 %mul276, 1
  %shl278 = shl i64 %add277, 62
  %sub279 = sub i64 %shl278, 1
  %mul280 = mul i64 %sub279, 2
  %add281 = add i64 %mul280, 1
  %sub282 = sub i64 %conv274, %add281
  br label %cond.end.287

cond.false.283:                                   ; preds = %cond.false.260
  %43 = load i64, i64* %nargs.addr, align 8
  %add284 = add i64 0, %43
  %mul285 = mul i64 0, %add284
  %add286 = add i64 %mul285, 0
  br label %cond.end.287

cond.end.287:                                     ; preds = %cond.false.283, %cond.true.266
  %cond288 = phi i64 [ %sub282, %cond.true.266 ], [ %add286, %cond.false.283 ]
  %cmp289 = icmp eq i64 %cond288, 0
  br i1 %cmp289, label %land.lhs.true.291, label %lor.lhs.false.294

land.lhs.true.291:                                ; preds = %cond.end.287
  %44 = load i64, i64* %nargs.addr, align 8
  %cmp292 = icmp slt i64 %44, 0
  br i1 %cmp292, label %cond.true.429, label %lor.lhs.false.294

lor.lhs.false.294:                                ; preds = %land.lhs.true.291, %cond.end.287
  br i1 false, label %cond.true.295, label %cond.false.355

cond.true.295:                                    ; preds = %lor.lhs.false.294
  %45 = load i64, i64* %nargs.addr, align 8
  %cmp296 = icmp slt i64 %45, 0
  br i1 %cmp296, label %cond.true.298, label %cond.false.321

cond.true.298:                                    ; preds = %cond.true.295
  %46 = load i64, i64* %nargs.addr, align 8
  %47 = load i64, i64* %nargs.addr, align 8
  %add299 = add i64 0, %47
  %mul300 = mul i64 0, %add299
  %sub301 = sub i64 %mul300, 1
  %cmp302 = icmp ult i64 %sub301, 0
  br i1 %cmp302, label %cond.true.304, label %cond.false.312

cond.true.304:                                    ; preds = %cond.true.298
  %48 = load i64, i64* %nargs.addr, align 8
  %add305 = add i64 0, %48
  %mul306 = mul i64 0, %add305
  %add307 = add i64 %mul306, 1
  %shl308 = shl i64 %add307, 62
  %sub309 = sub i64 %shl308, 1
  %mul310 = mul i64 %sub309, 2
  %add311 = add i64 %mul310, 1
  br label %cond.end.316

cond.false.312:                                   ; preds = %cond.true.298
  %49 = load i64, i64* %nargs.addr, align 8
  %add313 = add i64 0, %49
  %mul314 = mul i64 0, %add313
  %sub315 = sub i64 %mul314, 1
  br label %cond.end.316

cond.end.316:                                     ; preds = %cond.false.312, %cond.true.304
  %cond317 = phi i64 [ %add311, %cond.true.304 ], [ %sub315, %cond.false.312 ]
  %div318 = udiv i64 %cond317, 24
  %cmp319 = icmp ult i64 %46, %div318
  br i1 %cmp319, label %cond.true.429, label %lor.lhs.false.415

cond.false.321:                                   ; preds = %cond.true.295
  br i1 false, label %cond.true.322, label %cond.false.323

cond.true.322:                                    ; preds = %cond.false.321
  br i1 false, label %cond.true.429, label %lor.lhs.false.415

cond.false.323:                                   ; preds = %cond.false.321
  %50 = load i64, i64* %nargs.addr, align 8
  %add324 = add i64 0, %50
  %mul325 = mul i64 0, %add324
  %sub326 = sub i64 %mul325, 1
  %cmp327 = icmp ult i64 %sub326, 0
  br i1 %cmp327, label %cond.true.329, label %cond.false.346

cond.true.329:                                    ; preds = %cond.false.323
  %51 = load i64, i64* %nargs.addr, align 8
  %add330 = add i64 0, %51
  %mul331 = mul i64 0, %add330
  %add332 = add i64 %mul331, 0
  %neg333 = xor i64 %add332, -1
  %cmp334 = icmp eq i64 %neg333, -1
  %conv335 = zext i1 %cmp334 to i32
  %sub336 = sub nsw i32 0, %conv335
  %conv337 = sext i32 %sub336 to i64
  %52 = load i64, i64* %nargs.addr, align 8
  %add338 = add i64 0, %52
  %mul339 = mul i64 0, %add338
  %add340 = add i64 %mul339, 1
  %shl341 = shl i64 %add340, 62
  %sub342 = sub i64 %shl341, 1
  %mul343 = mul i64 %sub342, 2
  %add344 = add i64 %mul343, 1
  %sub345 = sub i64 %conv337, %add344
  br label %cond.end.350

cond.false.346:                                   ; preds = %cond.false.323
  %53 = load i64, i64* %nargs.addr, align 8
  %add347 = add i64 0, %53
  %mul348 = mul i64 0, %add347
  %add349 = add i64 %mul348, 0
  br label %cond.end.350

cond.end.350:                                     ; preds = %cond.false.346, %cond.true.329
  %cond351 = phi i64 [ %sub345, %cond.true.329 ], [ %add349, %cond.false.346 ]
  %div352 = udiv i64 %cond351, 24
  %54 = load i64, i64* %nargs.addr, align 8
  %cmp353 = icmp ult i64 %div352, %54
  br i1 %cmp353, label %cond.true.429, label %lor.lhs.false.415

cond.false.355:                                   ; preds = %lor.lhs.false.294
  br i1 false, label %cond.true.356, label %cond.false.357

cond.true.356:                                    ; preds = %cond.false.355
  br i1 false, label %cond.true.429, label %lor.lhs.false.415

cond.false.357:                                   ; preds = %cond.false.355
  %55 = load i64, i64* %nargs.addr, align 8
  %cmp358 = icmp slt i64 %55, 0
  br i1 %cmp358, label %cond.true.360, label %cond.false.392

cond.true.360:                                    ; preds = %cond.false.357
  %56 = load i64, i64* %nargs.addr, align 8
  %57 = load i64, i64* %nargs.addr, align 8
  %add361 = add i64 0, %57
  %mul362 = mul i64 0, %add361
  %sub363 = sub i64 %mul362, 1
  %cmp364 = icmp ult i64 %sub363, 0
  br i1 %cmp364, label %cond.true.366, label %cond.false.383

cond.true.366:                                    ; preds = %cond.true.360
  %58 = load i64, i64* %nargs.addr, align 8
  %add367 = add i64 0, %58
  %mul368 = mul i64 0, %add367
  %add369 = add i64 %mul368, 0
  %neg370 = xor i64 %add369, -1
  %cmp371 = icmp eq i64 %neg370, -1
  %conv372 = zext i1 %cmp371 to i32
  %sub373 = sub nsw i32 0, %conv372
  %conv374 = sext i32 %sub373 to i64
  %59 = load i64, i64* %nargs.addr, align 8
  %add375 = add i64 0, %59
  %mul376 = mul i64 0, %add375
  %add377 = add i64 %mul376, 1
  %shl378 = shl i64 %add377, 62
  %sub379 = sub i64 %shl378, 1
  %mul380 = mul i64 %sub379, 2
  %add381 = add i64 %mul380, 1
  %sub382 = sub i64 %conv374, %add381
  br label %cond.end.387

cond.false.383:                                   ; preds = %cond.true.360
  %60 = load i64, i64* %nargs.addr, align 8
  %add384 = add i64 0, %60
  %mul385 = mul i64 0, %add384
  %add386 = add i64 %mul385, 0
  br label %cond.end.387

cond.end.387:                                     ; preds = %cond.false.383, %cond.true.366
  %cond388 = phi i64 [ %sub382, %cond.true.366 ], [ %add386, %cond.false.383 ]
  %div389 = udiv i64 %cond388, 24
  %cmp390 = icmp ult i64 %56, %div389
  br i1 %cmp390, label %cond.true.429, label %lor.lhs.false.415

cond.false.392:                                   ; preds = %cond.false.357
  %61 = load i64, i64* %nargs.addr, align 8
  %add393 = add i64 0, %61
  %mul394 = mul i64 0, %add393
  %sub395 = sub i64 %mul394, 1
  %cmp396 = icmp ult i64 %sub395, 0
  br i1 %cmp396, label %cond.true.398, label %cond.false.406

cond.true.398:                                    ; preds = %cond.false.392
  %62 = load i64, i64* %nargs.addr, align 8
  %add399 = add i64 0, %62
  %mul400 = mul i64 0, %add399
  %add401 = add i64 %mul400, 1
  %shl402 = shl i64 %add401, 62
  %sub403 = sub i64 %shl402, 1
  %mul404 = mul i64 %sub403, 2
  %add405 = add i64 %mul404, 1
  br label %cond.end.410

cond.false.406:                                   ; preds = %cond.false.392
  %63 = load i64, i64* %nargs.addr, align 8
  %add407 = add i64 0, %63
  %mul408 = mul i64 0, %add407
  %sub409 = sub i64 %mul408, 1
  br label %cond.end.410

cond.end.410:                                     ; preds = %cond.false.406, %cond.true.398
  %cond411 = phi i64 [ %add405, %cond.true.398 ], [ %sub409, %cond.false.406 ]
  %div412 = udiv i64 %cond411, 24
  %64 = load i64, i64* %nargs.addr, align 8
  %cmp413 = icmp ult i64 %div412, %64
  br i1 %cmp413, label %cond.true.429, label %lor.lhs.false.415

lor.lhs.false.415:                                ; preds = %cond.end.410, %cond.end.387, %cond.true.356, %cond.end.350, %cond.true.322, %cond.end.316
  %65 = load i64, i64* %nargs.addr, align 8
  %mul416 = mul i64 %65, 24
  %mul417 = mul i64 0, %mul416
  %sub418 = sub i64 %mul417, 1
  %cmp419 = icmp ult i64 %sub418, 0
  br i1 %cmp419, label %land.lhs.true.421, label %lor.lhs.false.425

land.lhs.true.421:                                ; preds = %lor.lhs.false.415
  %66 = load i64, i64* %nargs.addr, align 8
  %mul422 = mul i64 %66, 24
  %cmp423 = icmp ult i64 %mul422, -128
  br i1 %cmp423, label %cond.true.429, label %lor.lhs.false.425

lor.lhs.false.425:                                ; preds = %land.lhs.true.421, %lor.lhs.false.415
  %67 = load i64, i64* %nargs.addr, align 8
  %mul426 = mul i64 %67, 24
  %cmp427 = icmp ult i64 127, %mul426
  br i1 %cmp427, label %cond.true.429, label %cond.false.452

cond.true.429:                                    ; preds = %lor.lhs.false.425, %land.lhs.true.421, %cond.end.410, %cond.end.387, %cond.true.356, %cond.end.350, %cond.true.322, %cond.end.316, %land.lhs.true.291
  %68 = load i64, i64* %nargs.addr, align 8
  %conv430 = trunc i64 %68 to i8
  %conv431 = zext i8 %conv430 to i32
  %mul432 = mul nsw i32 %conv431, 24
  %cmp433 = icmp sle i32 %mul432, 127
  br i1 %cmp433, label %cond.true.435, label %cond.false.441

cond.true.435:                                    ; preds = %cond.true.429
  %69 = load i64, i64* %nargs.addr, align 8
  %conv436 = trunc i64 %69 to i8
  %conv437 = zext i8 %conv436 to i32
  %mul438 = mul nsw i32 %conv437, 24
  %conv439 = trunc i32 %mul438 to i8
  %conv440 = sext i8 %conv439 to i32
  br label %cond.end.449

cond.false.441:                                   ; preds = %cond.true.429
  %70 = load i64, i64* %nargs.addr, align 8
  %conv442 = trunc i64 %70 to i8
  %conv443 = zext i8 %conv442 to i32
  %mul444 = mul nsw i32 %conv443, 24
  %sub445 = sub nsw i32 %mul444, -128
  %conv446 = trunc i32 %sub445 to i8
  %conv447 = sext i8 %conv446 to i32
  %add448 = add nsw i32 %conv447, -128
  br label %cond.end.449

cond.end.449:                                     ; preds = %cond.false.441, %cond.true.435
  %cond450 = phi i32 [ %conv440, %cond.true.435 ], [ %add448, %cond.false.441 ]
  %conv451 = sext i32 %cond450 to i64
  store i64 %conv451, i64* %alloca_size, align 8
  br i1 true, label %if.then, label %lor.lhs.false.2164

cond.false.452:                                   ; preds = %lor.lhs.false.425
  %71 = load i64, i64* %nargs.addr, align 8
  %conv453 = trunc i64 %71 to i8
  %conv454 = zext i8 %conv453 to i32
  %mul455 = mul nsw i32 %conv454, 24
  %cmp456 = icmp sle i32 %mul455, 127
  br i1 %cmp456, label %cond.true.458, label %cond.false.464

cond.true.458:                                    ; preds = %cond.false.452
  %72 = load i64, i64* %nargs.addr, align 8
  %conv459 = trunc i64 %72 to i8
  %conv460 = zext i8 %conv459 to i32
  %mul461 = mul nsw i32 %conv460, 24
  %conv462 = trunc i32 %mul461 to i8
  %conv463 = sext i8 %conv462 to i32
  br label %cond.end.472

cond.false.464:                                   ; preds = %cond.false.452
  %73 = load i64, i64* %nargs.addr, align 8
  %conv465 = trunc i64 %73 to i8
  %conv466 = zext i8 %conv465 to i32
  %mul467 = mul nsw i32 %conv466, 24
  %sub468 = sub nsw i32 %mul467, -128
  %conv469 = trunc i32 %sub468 to i8
  %conv470 = sext i8 %conv469 to i32
  %add471 = add nsw i32 %conv470, -128
  br label %cond.end.472

cond.end.472:                                     ; preds = %cond.false.464, %cond.true.458
  %cond473 = phi i32 [ %conv463, %cond.true.458 ], [ %add471, %cond.false.464 ]
  %conv474 = sext i32 %cond473 to i64
  store i64 %conv474, i64* %alloca_size, align 8
  br i1 false, label %if.then, label %lor.lhs.false.2164

cond.false.475:                                   ; preds = %entry
  br i1 false, label %cond.true.476, label %cond.false.960

cond.true.476:                                    ; preds = %cond.false.475
  br i1 false, label %cond.true.477, label %cond.false.745

cond.true.477:                                    ; preds = %cond.true.476
  %74 = load i64, i64* %nargs.addr, align 8
  %conv478 = trunc i64 %74 to i16
  %conv479 = sext i16 %conv478 to i32
  %add480 = add nsw i32 0, %conv479
  %mul481 = mul nsw i32 0, %add480
  %sub482 = sub nsw i32 %mul481, 1
  %cmp483 = icmp slt i32 %sub482, 0
  br i1 %cmp483, label %cond.true.485, label %cond.false.505

cond.true.485:                                    ; preds = %cond.true.477
  %75 = load i64, i64* %nargs.addr, align 8
  %conv486 = trunc i64 %75 to i16
  %conv487 = sext i16 %conv486 to i32
  %add488 = add nsw i32 0, %conv487
  %mul489 = mul nsw i32 0, %add488
  %add490 = add nsw i32 %mul489, 0
  %neg491 = xor i32 %add490, -1
  %cmp492 = icmp eq i32 %neg491, -1
  %conv493 = zext i1 %cmp492 to i32
  %sub494 = sub nsw i32 0, %conv493
  %76 = load i64, i64* %nargs.addr, align 8
  %conv495 = trunc i64 %76 to i16
  %conv496 = sext i16 %conv495 to i32
  %add497 = add nsw i32 0, %conv496
  %mul498 = mul nsw i32 0, %add497
  %add499 = add nsw i32 %mul498, 1
  %shl500 = shl i32 %add499, 30
  %sub501 = sub nsw i32 %shl500, 1
  %mul502 = mul nsw i32 %sub501, 2
  %add503 = add nsw i32 %mul502, 1
  %sub504 = sub nsw i32 %sub494, %add503
  br label %cond.end.511

cond.false.505:                                   ; preds = %cond.true.477
  %77 = load i64, i64* %nargs.addr, align 8
  %conv506 = trunc i64 %77 to i16
  %conv507 = sext i16 %conv506 to i32
  %add508 = add nsw i32 0, %conv507
  %mul509 = mul nsw i32 0, %add508
  %add510 = add nsw i32 %mul509, 0
  br label %cond.end.511

cond.end.511:                                     ; preds = %cond.false.505, %cond.true.485
  %cond512 = phi i32 [ %sub504, %cond.true.485 ], [ %add510, %cond.false.505 ]
  %cmp513 = icmp eq i32 %cond512, 0
  br i1 %cmp513, label %land.lhs.true.515, label %lor.lhs.false.520

land.lhs.true.515:                                ; preds = %cond.end.511
  %78 = load i64, i64* %nargs.addr, align 8
  %conv516 = trunc i64 %78 to i16
  %conv517 = sext i16 %conv516 to i32
  %cmp518 = icmp slt i32 %conv517, 0
  br i1 %cmp518, label %cond.true.699, label %lor.lhs.false.520

lor.lhs.false.520:                                ; preds = %land.lhs.true.515, %cond.end.511
  br i1 false, label %cond.true.521, label %cond.false.600

cond.true.521:                                    ; preds = %lor.lhs.false.520
  %79 = load i64, i64* %nargs.addr, align 8
  %conv522 = trunc i64 %79 to i16
  %conv523 = sext i16 %conv522 to i32
  %cmp524 = icmp slt i32 %conv523, 0
  br i1 %cmp524, label %cond.true.526, label %cond.false.557

cond.true.526:                                    ; preds = %cond.true.521
  %80 = load i64, i64* %nargs.addr, align 8
  %conv527 = trunc i64 %80 to i16
  %conv528 = sext i16 %conv527 to i32
  %81 = load i64, i64* %nargs.addr, align 8
  %conv529 = trunc i64 %81 to i16
  %conv530 = sext i16 %conv529 to i32
  %add531 = add nsw i32 0, %conv530
  %mul532 = mul nsw i32 0, %add531
  %sub533 = sub nsw i32 %mul532, 1
  %cmp534 = icmp slt i32 %sub533, 0
  br i1 %cmp534, label %cond.true.536, label %cond.false.546

cond.true.536:                                    ; preds = %cond.true.526
  %82 = load i64, i64* %nargs.addr, align 8
  %conv537 = trunc i64 %82 to i16
  %conv538 = sext i16 %conv537 to i32
  %add539 = add nsw i32 0, %conv538
  %mul540 = mul nsw i32 0, %add539
  %add541 = add nsw i32 %mul540, 1
  %shl542 = shl i32 %add541, 30
  %sub543 = sub nsw i32 %shl542, 1
  %mul544 = mul nsw i32 %sub543, 2
  %add545 = add nsw i32 %mul544, 1
  br label %cond.end.552

cond.false.546:                                   ; preds = %cond.true.526
  %83 = load i64, i64* %nargs.addr, align 8
  %conv547 = trunc i64 %83 to i16
  %conv548 = sext i16 %conv547 to i32
  %add549 = add nsw i32 0, %conv548
  %mul550 = mul nsw i32 0, %add549
  %sub551 = sub nsw i32 %mul550, 1
  br label %cond.end.552

cond.end.552:                                     ; preds = %cond.false.546, %cond.true.536
  %cond553 = phi i32 [ %add545, %cond.true.536 ], [ %sub551, %cond.false.546 ]
  %div554 = sdiv i32 %cond553, 24
  %cmp555 = icmp slt i32 %conv528, %div554
  br i1 %cmp555, label %cond.true.699, label %lor.lhs.false.679

cond.false.557:                                   ; preds = %cond.true.521
  br i1 false, label %cond.true.558, label %cond.false.559

cond.true.558:                                    ; preds = %cond.false.557
  br i1 false, label %cond.true.699, label %lor.lhs.false.679

cond.false.559:                                   ; preds = %cond.false.557
  %84 = load i64, i64* %nargs.addr, align 8
  %conv560 = trunc i64 %84 to i16
  %conv561 = sext i16 %conv560 to i32
  %add562 = add nsw i32 0, %conv561
  %mul563 = mul nsw i32 0, %add562
  %sub564 = sub nsw i32 %mul563, 1
  %cmp565 = icmp slt i32 %sub564, 0
  br i1 %cmp565, label %cond.true.567, label %cond.false.587

cond.true.567:                                    ; preds = %cond.false.559
  %85 = load i64, i64* %nargs.addr, align 8
  %conv568 = trunc i64 %85 to i16
  %conv569 = sext i16 %conv568 to i32
  %add570 = add nsw i32 0, %conv569
  %mul571 = mul nsw i32 0, %add570
  %add572 = add nsw i32 %mul571, 0
  %neg573 = xor i32 %add572, -1
  %cmp574 = icmp eq i32 %neg573, -1
  %conv575 = zext i1 %cmp574 to i32
  %sub576 = sub nsw i32 0, %conv575
  %86 = load i64, i64* %nargs.addr, align 8
  %conv577 = trunc i64 %86 to i16
  %conv578 = sext i16 %conv577 to i32
  %add579 = add nsw i32 0, %conv578
  %mul580 = mul nsw i32 0, %add579
  %add581 = add nsw i32 %mul580, 1
  %shl582 = shl i32 %add581, 30
  %sub583 = sub nsw i32 %shl582, 1
  %mul584 = mul nsw i32 %sub583, 2
  %add585 = add nsw i32 %mul584, 1
  %sub586 = sub nsw i32 %sub576, %add585
  br label %cond.end.593

cond.false.587:                                   ; preds = %cond.false.559
  %87 = load i64, i64* %nargs.addr, align 8
  %conv588 = trunc i64 %87 to i16
  %conv589 = sext i16 %conv588 to i32
  %add590 = add nsw i32 0, %conv589
  %mul591 = mul nsw i32 0, %add590
  %add592 = add nsw i32 %mul591, 0
  br label %cond.end.593

cond.end.593:                                     ; preds = %cond.false.587, %cond.true.567
  %cond594 = phi i32 [ %sub586, %cond.true.567 ], [ %add592, %cond.false.587 ]
  %div595 = sdiv i32 %cond594, 24
  %88 = load i64, i64* %nargs.addr, align 8
  %conv596 = trunc i64 %88 to i16
  %conv597 = sext i16 %conv596 to i32
  %cmp598 = icmp slt i32 %div595, %conv597
  br i1 %cmp598, label %cond.true.699, label %lor.lhs.false.679

cond.false.600:                                   ; preds = %lor.lhs.false.520
  br i1 false, label %cond.true.601, label %cond.false.602

cond.true.601:                                    ; preds = %cond.false.600
  br i1 false, label %cond.true.699, label %lor.lhs.false.679

cond.false.602:                                   ; preds = %cond.false.600
  %89 = load i64, i64* %nargs.addr, align 8
  %conv603 = trunc i64 %89 to i16
  %conv604 = sext i16 %conv603 to i32
  %cmp605 = icmp slt i32 %conv604, 0
  br i1 %cmp605, label %cond.true.607, label %cond.false.648

cond.true.607:                                    ; preds = %cond.false.602
  %90 = load i64, i64* %nargs.addr, align 8
  %conv608 = trunc i64 %90 to i16
  %conv609 = sext i16 %conv608 to i32
  %91 = load i64, i64* %nargs.addr, align 8
  %conv610 = trunc i64 %91 to i16
  %conv611 = sext i16 %conv610 to i32
  %add612 = add nsw i32 0, %conv611
  %mul613 = mul nsw i32 0, %add612
  %sub614 = sub nsw i32 %mul613, 1
  %cmp615 = icmp slt i32 %sub614, 0
  br i1 %cmp615, label %cond.true.617, label %cond.false.637

cond.true.617:                                    ; preds = %cond.true.607
  %92 = load i64, i64* %nargs.addr, align 8
  %conv618 = trunc i64 %92 to i16
  %conv619 = sext i16 %conv618 to i32
  %add620 = add nsw i32 0, %conv619
  %mul621 = mul nsw i32 0, %add620
  %add622 = add nsw i32 %mul621, 0
  %neg623 = xor i32 %add622, -1
  %cmp624 = icmp eq i32 %neg623, -1
  %conv625 = zext i1 %cmp624 to i32
  %sub626 = sub nsw i32 0, %conv625
  %93 = load i64, i64* %nargs.addr, align 8
  %conv627 = trunc i64 %93 to i16
  %conv628 = sext i16 %conv627 to i32
  %add629 = add nsw i32 0, %conv628
  %mul630 = mul nsw i32 0, %add629
  %add631 = add nsw i32 %mul630, 1
  %shl632 = shl i32 %add631, 30
  %sub633 = sub nsw i32 %shl632, 1
  %mul634 = mul nsw i32 %sub633, 2
  %add635 = add nsw i32 %mul634, 1
  %sub636 = sub nsw i32 %sub626, %add635
  br label %cond.end.643

cond.false.637:                                   ; preds = %cond.true.607
  %94 = load i64, i64* %nargs.addr, align 8
  %conv638 = trunc i64 %94 to i16
  %conv639 = sext i16 %conv638 to i32
  %add640 = add nsw i32 0, %conv639
  %mul641 = mul nsw i32 0, %add640
  %add642 = add nsw i32 %mul641, 0
  br label %cond.end.643

cond.end.643:                                     ; preds = %cond.false.637, %cond.true.617
  %cond644 = phi i32 [ %sub636, %cond.true.617 ], [ %add642, %cond.false.637 ]
  %div645 = sdiv i32 %cond644, 24
  %cmp646 = icmp slt i32 %conv609, %div645
  br i1 %cmp646, label %cond.true.699, label %lor.lhs.false.679

cond.false.648:                                   ; preds = %cond.false.602
  %95 = load i64, i64* %nargs.addr, align 8
  %conv649 = trunc i64 %95 to i16
  %conv650 = sext i16 %conv649 to i32
  %add651 = add nsw i32 0, %conv650
  %mul652 = mul nsw i32 0, %add651
  %sub653 = sub nsw i32 %mul652, 1
  %cmp654 = icmp slt i32 %sub653, 0
  br i1 %cmp654, label %cond.true.656, label %cond.false.666

cond.true.656:                                    ; preds = %cond.false.648
  %96 = load i64, i64* %nargs.addr, align 8
  %conv657 = trunc i64 %96 to i16
  %conv658 = sext i16 %conv657 to i32
  %add659 = add nsw i32 0, %conv658
  %mul660 = mul nsw i32 0, %add659
  %add661 = add nsw i32 %mul660, 1
  %shl662 = shl i32 %add661, 30
  %sub663 = sub nsw i32 %shl662, 1
  %mul664 = mul nsw i32 %sub663, 2
  %add665 = add nsw i32 %mul664, 1
  br label %cond.end.672

cond.false.666:                                   ; preds = %cond.false.648
  %97 = load i64, i64* %nargs.addr, align 8
  %conv667 = trunc i64 %97 to i16
  %conv668 = sext i16 %conv667 to i32
  %add669 = add nsw i32 0, %conv668
  %mul670 = mul nsw i32 0, %add669
  %sub671 = sub nsw i32 %mul670, 1
  br label %cond.end.672

cond.end.672:                                     ; preds = %cond.false.666, %cond.true.656
  %cond673 = phi i32 [ %add665, %cond.true.656 ], [ %sub671, %cond.false.666 ]
  %div674 = sdiv i32 %cond673, 24
  %98 = load i64, i64* %nargs.addr, align 8
  %conv675 = trunc i64 %98 to i16
  %conv676 = sext i16 %conv675 to i32
  %cmp677 = icmp slt i32 %div674, %conv676
  br i1 %cmp677, label %cond.true.699, label %lor.lhs.false.679

lor.lhs.false.679:                                ; preds = %cond.end.672, %cond.end.643, %cond.true.601, %cond.end.593, %cond.true.558, %cond.end.552
  %99 = load i64, i64* %nargs.addr, align 8
  %conv680 = trunc i64 %99 to i16
  %conv681 = sext i16 %conv680 to i32
  %mul682 = mul nsw i32 %conv681, 24
  %mul683 = mul nsw i32 0, %mul682
  %sub684 = sub nsw i32 %mul683, 1
  %cmp685 = icmp slt i32 %sub684, 0
  br i1 %cmp685, label %land.lhs.true.687, label %lor.lhs.false.693

land.lhs.true.687:                                ; preds = %lor.lhs.false.679
  %100 = load i64, i64* %nargs.addr, align 8
  %conv688 = trunc i64 %100 to i16
  %conv689 = sext i16 %conv688 to i32
  %mul690 = mul nsw i32 %conv689, 24
  %cmp691 = icmp slt i32 %mul690, -32768
  br i1 %cmp691, label %cond.true.699, label %lor.lhs.false.693

lor.lhs.false.693:                                ; preds = %land.lhs.true.687, %lor.lhs.false.679
  %101 = load i64, i64* %nargs.addr, align 8
  %conv694 = trunc i64 %101 to i16
  %conv695 = sext i16 %conv694 to i32
  %mul696 = mul nsw i32 %conv695, 24
  %cmp697 = icmp slt i32 32767, %mul696
  br i1 %cmp697, label %cond.true.699, label %cond.false.722

cond.true.699:                                    ; preds = %lor.lhs.false.693, %land.lhs.true.687, %cond.end.672, %cond.end.643, %cond.true.601, %cond.end.593, %cond.true.558, %cond.end.552, %land.lhs.true.515
  %102 = load i64, i64* %nargs.addr, align 8
  %conv700 = trunc i64 %102 to i16
  %conv701 = zext i16 %conv700 to i32
  %mul702 = mul nsw i32 %conv701, 24
  %cmp703 = icmp sle i32 %mul702, 32767
  br i1 %cmp703, label %cond.true.705, label %cond.false.711

cond.true.705:                                    ; preds = %cond.true.699
  %103 = load i64, i64* %nargs.addr, align 8
  %conv706 = trunc i64 %103 to i16
  %conv707 = zext i16 %conv706 to i32
  %mul708 = mul nsw i32 %conv707, 24
  %conv709 = trunc i32 %mul708 to i16
  %conv710 = sext i16 %conv709 to i32
  br label %cond.end.719

cond.false.711:                                   ; preds = %cond.true.699
  %104 = load i64, i64* %nargs.addr, align 8
  %conv712 = trunc i64 %104 to i16
  %conv713 = zext i16 %conv712 to i32
  %mul714 = mul nsw i32 %conv713, 24
  %sub715 = sub nsw i32 %mul714, -32768
  %conv716 = trunc i32 %sub715 to i16
  %conv717 = sext i16 %conv716 to i32
  %add718 = add nsw i32 %conv717, -32768
  br label %cond.end.719

cond.end.719:                                     ; preds = %cond.false.711, %cond.true.705
  %cond720 = phi i32 [ %conv710, %cond.true.705 ], [ %add718, %cond.false.711 ]
  %conv721 = sext i32 %cond720 to i64
  store i64 %conv721, i64* %alloca_size, align 8
  br i1 true, label %if.then, label %lor.lhs.false.2164

cond.false.722:                                   ; preds = %lor.lhs.false.693
  %105 = load i64, i64* %nargs.addr, align 8
  %conv723 = trunc i64 %105 to i16
  %conv724 = zext i16 %conv723 to i32
  %mul725 = mul nsw i32 %conv724, 24
  %cmp726 = icmp sle i32 %mul725, 32767
  br i1 %cmp726, label %cond.true.728, label %cond.false.734

cond.true.728:                                    ; preds = %cond.false.722
  %106 = load i64, i64* %nargs.addr, align 8
  %conv729 = trunc i64 %106 to i16
  %conv730 = zext i16 %conv729 to i32
  %mul731 = mul nsw i32 %conv730, 24
  %conv732 = trunc i32 %mul731 to i16
  %conv733 = sext i16 %conv732 to i32
  br label %cond.end.742

cond.false.734:                                   ; preds = %cond.false.722
  %107 = load i64, i64* %nargs.addr, align 8
  %conv735 = trunc i64 %107 to i16
  %conv736 = zext i16 %conv735 to i32
  %mul737 = mul nsw i32 %conv736, 24
  %sub738 = sub nsw i32 %mul737, -32768
  %conv739 = trunc i32 %sub738 to i16
  %conv740 = sext i16 %conv739 to i32
  %add741 = add nsw i32 %conv740, -32768
  br label %cond.end.742

cond.end.742:                                     ; preds = %cond.false.734, %cond.true.728
  %cond743 = phi i32 [ %conv733, %cond.true.728 ], [ %add741, %cond.false.734 ]
  %conv744 = sext i32 %cond743 to i64
  store i64 %conv744, i64* %alloca_size, align 8
  br i1 false, label %if.then, label %lor.lhs.false.2164

cond.false.745:                                   ; preds = %cond.true.476
  %108 = load i64, i64* %nargs.addr, align 8
  %add746 = add i64 0, %108
  %mul747 = mul i64 0, %add746
  %sub748 = sub i64 %mul747, 1
  %cmp749 = icmp ult i64 %sub748, 0
  br i1 %cmp749, label %cond.true.751, label %cond.false.768

cond.true.751:                                    ; preds = %cond.false.745
  %109 = load i64, i64* %nargs.addr, align 8
  %add752 = add i64 0, %109
  %mul753 = mul i64 0, %add752
  %add754 = add i64 %mul753, 0
  %neg755 = xor i64 %add754, -1
  %cmp756 = icmp eq i64 %neg755, -1
  %conv757 = zext i1 %cmp756 to i32
  %sub758 = sub nsw i32 0, %conv757
  %conv759 = sext i32 %sub758 to i64
  %110 = load i64, i64* %nargs.addr, align 8
  %add760 = add i64 0, %110
  %mul761 = mul i64 0, %add760
  %add762 = add i64 %mul761, 1
  %shl763 = shl i64 %add762, 62
  %sub764 = sub i64 %shl763, 1
  %mul765 = mul i64 %sub764, 2
  %add766 = add i64 %mul765, 1
  %sub767 = sub i64 %conv759, %add766
  br label %cond.end.772

cond.false.768:                                   ; preds = %cond.false.745
  %111 = load i64, i64* %nargs.addr, align 8
  %add769 = add i64 0, %111
  %mul770 = mul i64 0, %add769
  %add771 = add i64 %mul770, 0
  br label %cond.end.772

cond.end.772:                                     ; preds = %cond.false.768, %cond.true.751
  %cond773 = phi i64 [ %sub767, %cond.true.751 ], [ %add771, %cond.false.768 ]
  %cmp774 = icmp eq i64 %cond773, 0
  br i1 %cmp774, label %land.lhs.true.776, label %lor.lhs.false.779

land.lhs.true.776:                                ; preds = %cond.end.772
  %112 = load i64, i64* %nargs.addr, align 8
  %cmp777 = icmp slt i64 %112, 0
  br i1 %cmp777, label %cond.true.914, label %lor.lhs.false.779

lor.lhs.false.779:                                ; preds = %land.lhs.true.776, %cond.end.772
  br i1 false, label %cond.true.780, label %cond.false.840

cond.true.780:                                    ; preds = %lor.lhs.false.779
  %113 = load i64, i64* %nargs.addr, align 8
  %cmp781 = icmp slt i64 %113, 0
  br i1 %cmp781, label %cond.true.783, label %cond.false.806

cond.true.783:                                    ; preds = %cond.true.780
  %114 = load i64, i64* %nargs.addr, align 8
  %115 = load i64, i64* %nargs.addr, align 8
  %add784 = add i64 0, %115
  %mul785 = mul i64 0, %add784
  %sub786 = sub i64 %mul785, 1
  %cmp787 = icmp ult i64 %sub786, 0
  br i1 %cmp787, label %cond.true.789, label %cond.false.797

cond.true.789:                                    ; preds = %cond.true.783
  %116 = load i64, i64* %nargs.addr, align 8
  %add790 = add i64 0, %116
  %mul791 = mul i64 0, %add790
  %add792 = add i64 %mul791, 1
  %shl793 = shl i64 %add792, 62
  %sub794 = sub i64 %shl793, 1
  %mul795 = mul i64 %sub794, 2
  %add796 = add i64 %mul795, 1
  br label %cond.end.801

cond.false.797:                                   ; preds = %cond.true.783
  %117 = load i64, i64* %nargs.addr, align 8
  %add798 = add i64 0, %117
  %mul799 = mul i64 0, %add798
  %sub800 = sub i64 %mul799, 1
  br label %cond.end.801

cond.end.801:                                     ; preds = %cond.false.797, %cond.true.789
  %cond802 = phi i64 [ %add796, %cond.true.789 ], [ %sub800, %cond.false.797 ]
  %div803 = udiv i64 %cond802, 24
  %cmp804 = icmp ult i64 %114, %div803
  br i1 %cmp804, label %cond.true.914, label %lor.lhs.false.900

cond.false.806:                                   ; preds = %cond.true.780
  br i1 false, label %cond.true.807, label %cond.false.808

cond.true.807:                                    ; preds = %cond.false.806
  br i1 false, label %cond.true.914, label %lor.lhs.false.900

cond.false.808:                                   ; preds = %cond.false.806
  %118 = load i64, i64* %nargs.addr, align 8
  %add809 = add i64 0, %118
  %mul810 = mul i64 0, %add809
  %sub811 = sub i64 %mul810, 1
  %cmp812 = icmp ult i64 %sub811, 0
  br i1 %cmp812, label %cond.true.814, label %cond.false.831

cond.true.814:                                    ; preds = %cond.false.808
  %119 = load i64, i64* %nargs.addr, align 8
  %add815 = add i64 0, %119
  %mul816 = mul i64 0, %add815
  %add817 = add i64 %mul816, 0
  %neg818 = xor i64 %add817, -1
  %cmp819 = icmp eq i64 %neg818, -1
  %conv820 = zext i1 %cmp819 to i32
  %sub821 = sub nsw i32 0, %conv820
  %conv822 = sext i32 %sub821 to i64
  %120 = load i64, i64* %nargs.addr, align 8
  %add823 = add i64 0, %120
  %mul824 = mul i64 0, %add823
  %add825 = add i64 %mul824, 1
  %shl826 = shl i64 %add825, 62
  %sub827 = sub i64 %shl826, 1
  %mul828 = mul i64 %sub827, 2
  %add829 = add i64 %mul828, 1
  %sub830 = sub i64 %conv822, %add829
  br label %cond.end.835

cond.false.831:                                   ; preds = %cond.false.808
  %121 = load i64, i64* %nargs.addr, align 8
  %add832 = add i64 0, %121
  %mul833 = mul i64 0, %add832
  %add834 = add i64 %mul833, 0
  br label %cond.end.835

cond.end.835:                                     ; preds = %cond.false.831, %cond.true.814
  %cond836 = phi i64 [ %sub830, %cond.true.814 ], [ %add834, %cond.false.831 ]
  %div837 = udiv i64 %cond836, 24
  %122 = load i64, i64* %nargs.addr, align 8
  %cmp838 = icmp ult i64 %div837, %122
  br i1 %cmp838, label %cond.true.914, label %lor.lhs.false.900

cond.false.840:                                   ; preds = %lor.lhs.false.779
  br i1 false, label %cond.true.841, label %cond.false.842

cond.true.841:                                    ; preds = %cond.false.840
  br i1 false, label %cond.true.914, label %lor.lhs.false.900

cond.false.842:                                   ; preds = %cond.false.840
  %123 = load i64, i64* %nargs.addr, align 8
  %cmp843 = icmp slt i64 %123, 0
  br i1 %cmp843, label %cond.true.845, label %cond.false.877

cond.true.845:                                    ; preds = %cond.false.842
  %124 = load i64, i64* %nargs.addr, align 8
  %125 = load i64, i64* %nargs.addr, align 8
  %add846 = add i64 0, %125
  %mul847 = mul i64 0, %add846
  %sub848 = sub i64 %mul847, 1
  %cmp849 = icmp ult i64 %sub848, 0
  br i1 %cmp849, label %cond.true.851, label %cond.false.868

cond.true.851:                                    ; preds = %cond.true.845
  %126 = load i64, i64* %nargs.addr, align 8
  %add852 = add i64 0, %126
  %mul853 = mul i64 0, %add852
  %add854 = add i64 %mul853, 0
  %neg855 = xor i64 %add854, -1
  %cmp856 = icmp eq i64 %neg855, -1
  %conv857 = zext i1 %cmp856 to i32
  %sub858 = sub nsw i32 0, %conv857
  %conv859 = sext i32 %sub858 to i64
  %127 = load i64, i64* %nargs.addr, align 8
  %add860 = add i64 0, %127
  %mul861 = mul i64 0, %add860
  %add862 = add i64 %mul861, 1
  %shl863 = shl i64 %add862, 62
  %sub864 = sub i64 %shl863, 1
  %mul865 = mul i64 %sub864, 2
  %add866 = add i64 %mul865, 1
  %sub867 = sub i64 %conv859, %add866
  br label %cond.end.872

cond.false.868:                                   ; preds = %cond.true.845
  %128 = load i64, i64* %nargs.addr, align 8
  %add869 = add i64 0, %128
  %mul870 = mul i64 0, %add869
  %add871 = add i64 %mul870, 0
  br label %cond.end.872

cond.end.872:                                     ; preds = %cond.false.868, %cond.true.851
  %cond873 = phi i64 [ %sub867, %cond.true.851 ], [ %add871, %cond.false.868 ]
  %div874 = udiv i64 %cond873, 24
  %cmp875 = icmp ult i64 %124, %div874
  br i1 %cmp875, label %cond.true.914, label %lor.lhs.false.900

cond.false.877:                                   ; preds = %cond.false.842
  %129 = load i64, i64* %nargs.addr, align 8
  %add878 = add i64 0, %129
  %mul879 = mul i64 0, %add878
  %sub880 = sub i64 %mul879, 1
  %cmp881 = icmp ult i64 %sub880, 0
  br i1 %cmp881, label %cond.true.883, label %cond.false.891

cond.true.883:                                    ; preds = %cond.false.877
  %130 = load i64, i64* %nargs.addr, align 8
  %add884 = add i64 0, %130
  %mul885 = mul i64 0, %add884
  %add886 = add i64 %mul885, 1
  %shl887 = shl i64 %add886, 62
  %sub888 = sub i64 %shl887, 1
  %mul889 = mul i64 %sub888, 2
  %add890 = add i64 %mul889, 1
  br label %cond.end.895

cond.false.891:                                   ; preds = %cond.false.877
  %131 = load i64, i64* %nargs.addr, align 8
  %add892 = add i64 0, %131
  %mul893 = mul i64 0, %add892
  %sub894 = sub i64 %mul893, 1
  br label %cond.end.895

cond.end.895:                                     ; preds = %cond.false.891, %cond.true.883
  %cond896 = phi i64 [ %add890, %cond.true.883 ], [ %sub894, %cond.false.891 ]
  %div897 = udiv i64 %cond896, 24
  %132 = load i64, i64* %nargs.addr, align 8
  %cmp898 = icmp ult i64 %div897, %132
  br i1 %cmp898, label %cond.true.914, label %lor.lhs.false.900

lor.lhs.false.900:                                ; preds = %cond.end.895, %cond.end.872, %cond.true.841, %cond.end.835, %cond.true.807, %cond.end.801
  %133 = load i64, i64* %nargs.addr, align 8
  %mul901 = mul i64 %133, 24
  %mul902 = mul i64 0, %mul901
  %sub903 = sub i64 %mul902, 1
  %cmp904 = icmp ult i64 %sub903, 0
  br i1 %cmp904, label %land.lhs.true.906, label %lor.lhs.false.910

land.lhs.true.906:                                ; preds = %lor.lhs.false.900
  %134 = load i64, i64* %nargs.addr, align 8
  %mul907 = mul i64 %134, 24
  %cmp908 = icmp ult i64 %mul907, -32768
  br i1 %cmp908, label %cond.true.914, label %lor.lhs.false.910

lor.lhs.false.910:                                ; preds = %land.lhs.true.906, %lor.lhs.false.900
  %135 = load i64, i64* %nargs.addr, align 8
  %mul911 = mul i64 %135, 24
  %cmp912 = icmp ult i64 32767, %mul911
  br i1 %cmp912, label %cond.true.914, label %cond.false.937

cond.true.914:                                    ; preds = %lor.lhs.false.910, %land.lhs.true.906, %cond.end.895, %cond.end.872, %cond.true.841, %cond.end.835, %cond.true.807, %cond.end.801, %land.lhs.true.776
  %136 = load i64, i64* %nargs.addr, align 8
  %conv915 = trunc i64 %136 to i16
  %conv916 = zext i16 %conv915 to i32
  %mul917 = mul nsw i32 %conv916, 24
  %cmp918 = icmp sle i32 %mul917, 32767
  br i1 %cmp918, label %cond.true.920, label %cond.false.926

cond.true.920:                                    ; preds = %cond.true.914
  %137 = load i64, i64* %nargs.addr, align 8
  %conv921 = trunc i64 %137 to i16
  %conv922 = zext i16 %conv921 to i32
  %mul923 = mul nsw i32 %conv922, 24
  %conv924 = trunc i32 %mul923 to i16
  %conv925 = sext i16 %conv924 to i32
  br label %cond.end.934

cond.false.926:                                   ; preds = %cond.true.914
  %138 = load i64, i64* %nargs.addr, align 8
  %conv927 = trunc i64 %138 to i16
  %conv928 = zext i16 %conv927 to i32
  %mul929 = mul nsw i32 %conv928, 24
  %sub930 = sub nsw i32 %mul929, -32768
  %conv931 = trunc i32 %sub930 to i16
  %conv932 = sext i16 %conv931 to i32
  %add933 = add nsw i32 %conv932, -32768
  br label %cond.end.934

cond.end.934:                                     ; preds = %cond.false.926, %cond.true.920
  %cond935 = phi i32 [ %conv925, %cond.true.920 ], [ %add933, %cond.false.926 ]
  %conv936 = sext i32 %cond935 to i64
  store i64 %conv936, i64* %alloca_size, align 8
  br i1 true, label %if.then, label %lor.lhs.false.2164

cond.false.937:                                   ; preds = %lor.lhs.false.910
  %139 = load i64, i64* %nargs.addr, align 8
  %conv938 = trunc i64 %139 to i16
  %conv939 = zext i16 %conv938 to i32
  %mul940 = mul nsw i32 %conv939, 24
  %cmp941 = icmp sle i32 %mul940, 32767
  br i1 %cmp941, label %cond.true.943, label %cond.false.949

cond.true.943:                                    ; preds = %cond.false.937
  %140 = load i64, i64* %nargs.addr, align 8
  %conv944 = trunc i64 %140 to i16
  %conv945 = zext i16 %conv944 to i32
  %mul946 = mul nsw i32 %conv945, 24
  %conv947 = trunc i32 %mul946 to i16
  %conv948 = sext i16 %conv947 to i32
  br label %cond.end.957

cond.false.949:                                   ; preds = %cond.false.937
  %141 = load i64, i64* %nargs.addr, align 8
  %conv950 = trunc i64 %141 to i16
  %conv951 = zext i16 %conv950 to i32
  %mul952 = mul nsw i32 %conv951, 24
  %sub953 = sub nsw i32 %mul952, -32768
  %conv954 = trunc i32 %sub953 to i16
  %conv955 = sext i16 %conv954 to i32
  %add956 = add nsw i32 %conv955, -32768
  br label %cond.end.957

cond.end.957:                                     ; preds = %cond.false.949, %cond.true.943
  %cond958 = phi i32 [ %conv948, %cond.true.943 ], [ %add956, %cond.false.949 ]
  %conv959 = sext i32 %cond958 to i64
  store i64 %conv959, i64* %alloca_size, align 8
  br i1 false, label %if.then, label %lor.lhs.false.2164

cond.false.960:                                   ; preds = %cond.false.475
  br i1 false, label %cond.true.961, label %cond.false.1389

cond.true.961:                                    ; preds = %cond.false.960
  br i1 false, label %cond.true.962, label %cond.false.1188

cond.true.962:                                    ; preds = %cond.true.961
  %142 = load i64, i64* %nargs.addr, align 8
  %conv963 = trunc i64 %142 to i32
  %add964 = add nsw i32 0, %conv963
  %mul965 = mul nsw i32 0, %add964
  %sub966 = sub nsw i32 %mul965, 1
  %cmp967 = icmp slt i32 %sub966, 0
  br i1 %cmp967, label %cond.true.969, label %cond.false.987

cond.true.969:                                    ; preds = %cond.true.962
  %143 = load i64, i64* %nargs.addr, align 8
  %conv970 = trunc i64 %143 to i32
  %add971 = add nsw i32 0, %conv970
  %mul972 = mul nsw i32 0, %add971
  %add973 = add nsw i32 %mul972, 0
  %neg974 = xor i32 %add973, -1
  %cmp975 = icmp eq i32 %neg974, -1
  %conv976 = zext i1 %cmp975 to i32
  %sub977 = sub nsw i32 0, %conv976
  %144 = load i64, i64* %nargs.addr, align 8
  %conv978 = trunc i64 %144 to i32
  %add979 = add nsw i32 0, %conv978
  %mul980 = mul nsw i32 0, %add979
  %add981 = add nsw i32 %mul980, 1
  %shl982 = shl i32 %add981, 30
  %sub983 = sub nsw i32 %shl982, 1
  %mul984 = mul nsw i32 %sub983, 2
  %add985 = add nsw i32 %mul984, 1
  %sub986 = sub nsw i32 %sub977, %add985
  br label %cond.end.992

cond.false.987:                                   ; preds = %cond.true.962
  %145 = load i64, i64* %nargs.addr, align 8
  %conv988 = trunc i64 %145 to i32
  %add989 = add nsw i32 0, %conv988
  %mul990 = mul nsw i32 0, %add989
  %add991 = add nsw i32 %mul990, 0
  br label %cond.end.992

cond.end.992:                                     ; preds = %cond.false.987, %cond.true.969
  %cond993 = phi i32 [ %sub986, %cond.true.969 ], [ %add991, %cond.false.987 ]
  %cmp994 = icmp eq i32 %cond993, 0
  br i1 %cmp994, label %land.lhs.true.996, label %lor.lhs.false.1000

land.lhs.true.996:                                ; preds = %cond.end.992
  %146 = load i64, i64* %nargs.addr, align 8
  %conv997 = trunc i64 %146 to i32
  %cmp998 = icmp slt i32 %conv997, 0
  br i1 %cmp998, label %cond.true.1156, label %lor.lhs.false.1000

lor.lhs.false.1000:                               ; preds = %land.lhs.true.996, %cond.end.992
  br i1 false, label %cond.true.1001, label %cond.false.1070

cond.true.1001:                                   ; preds = %lor.lhs.false.1000
  %147 = load i64, i64* %nargs.addr, align 8
  %conv1002 = trunc i64 %147 to i32
  %cmp1003 = icmp slt i32 %conv1002, 0
  br i1 %cmp1003, label %cond.true.1005, label %cond.false.1032

cond.true.1005:                                   ; preds = %cond.true.1001
  %148 = load i64, i64* %nargs.addr, align 8
  %conv1006 = trunc i64 %148 to i32
  %149 = load i64, i64* %nargs.addr, align 8
  %conv1007 = trunc i64 %149 to i32
  %add1008 = add nsw i32 0, %conv1007
  %mul1009 = mul nsw i32 0, %add1008
  %sub1010 = sub nsw i32 %mul1009, 1
  %cmp1011 = icmp slt i32 %sub1010, 0
  br i1 %cmp1011, label %cond.true.1013, label %cond.false.1022

cond.true.1013:                                   ; preds = %cond.true.1005
  %150 = load i64, i64* %nargs.addr, align 8
  %conv1014 = trunc i64 %150 to i32
  %add1015 = add nsw i32 0, %conv1014
  %mul1016 = mul nsw i32 0, %add1015
  %add1017 = add nsw i32 %mul1016, 1
  %shl1018 = shl i32 %add1017, 30
  %sub1019 = sub nsw i32 %shl1018, 1
  %mul1020 = mul nsw i32 %sub1019, 2
  %add1021 = add nsw i32 %mul1020, 1
  br label %cond.end.1027

cond.false.1022:                                  ; preds = %cond.true.1005
  %151 = load i64, i64* %nargs.addr, align 8
  %conv1023 = trunc i64 %151 to i32
  %add1024 = add nsw i32 0, %conv1023
  %mul1025 = mul nsw i32 0, %add1024
  %sub1026 = sub nsw i32 %mul1025, 1
  br label %cond.end.1027

cond.end.1027:                                    ; preds = %cond.false.1022, %cond.true.1013
  %cond1028 = phi i32 [ %add1021, %cond.true.1013 ], [ %sub1026, %cond.false.1022 ]
  %div1029 = sdiv i32 %cond1028, 24
  %cmp1030 = icmp slt i32 %conv1006, %div1029
  br i1 %cmp1030, label %cond.true.1156, label %lor.lhs.false.1139

cond.false.1032:                                  ; preds = %cond.true.1001
  br i1 false, label %cond.true.1033, label %cond.false.1034

cond.true.1033:                                   ; preds = %cond.false.1032
  br i1 false, label %cond.true.1156, label %lor.lhs.false.1139

cond.false.1034:                                  ; preds = %cond.false.1032
  %152 = load i64, i64* %nargs.addr, align 8
  %conv1035 = trunc i64 %152 to i32
  %add1036 = add nsw i32 0, %conv1035
  %mul1037 = mul nsw i32 0, %add1036
  %sub1038 = sub nsw i32 %mul1037, 1
  %cmp1039 = icmp slt i32 %sub1038, 0
  br i1 %cmp1039, label %cond.true.1041, label %cond.false.1059

cond.true.1041:                                   ; preds = %cond.false.1034
  %153 = load i64, i64* %nargs.addr, align 8
  %conv1042 = trunc i64 %153 to i32
  %add1043 = add nsw i32 0, %conv1042
  %mul1044 = mul nsw i32 0, %add1043
  %add1045 = add nsw i32 %mul1044, 0
  %neg1046 = xor i32 %add1045, -1
  %cmp1047 = icmp eq i32 %neg1046, -1
  %conv1048 = zext i1 %cmp1047 to i32
  %sub1049 = sub nsw i32 0, %conv1048
  %154 = load i64, i64* %nargs.addr, align 8
  %conv1050 = trunc i64 %154 to i32
  %add1051 = add nsw i32 0, %conv1050
  %mul1052 = mul nsw i32 0, %add1051
  %add1053 = add nsw i32 %mul1052, 1
  %shl1054 = shl i32 %add1053, 30
  %sub1055 = sub nsw i32 %shl1054, 1
  %mul1056 = mul nsw i32 %sub1055, 2
  %add1057 = add nsw i32 %mul1056, 1
  %sub1058 = sub nsw i32 %sub1049, %add1057
  br label %cond.end.1064

cond.false.1059:                                  ; preds = %cond.false.1034
  %155 = load i64, i64* %nargs.addr, align 8
  %conv1060 = trunc i64 %155 to i32
  %add1061 = add nsw i32 0, %conv1060
  %mul1062 = mul nsw i32 0, %add1061
  %add1063 = add nsw i32 %mul1062, 0
  br label %cond.end.1064

cond.end.1064:                                    ; preds = %cond.false.1059, %cond.true.1041
  %cond1065 = phi i32 [ %sub1058, %cond.true.1041 ], [ %add1063, %cond.false.1059 ]
  %div1066 = sdiv i32 %cond1065, 24
  %156 = load i64, i64* %nargs.addr, align 8
  %conv1067 = trunc i64 %156 to i32
  %cmp1068 = icmp slt i32 %div1066, %conv1067
  br i1 %cmp1068, label %cond.true.1156, label %lor.lhs.false.1139

cond.false.1070:                                  ; preds = %lor.lhs.false.1000
  br i1 false, label %cond.true.1071, label %cond.false.1072

cond.true.1071:                                   ; preds = %cond.false.1070
  br i1 false, label %cond.true.1156, label %lor.lhs.false.1139

cond.false.1072:                                  ; preds = %cond.false.1070
  %157 = load i64, i64* %nargs.addr, align 8
  %conv1073 = trunc i64 %157 to i32
  %cmp1074 = icmp slt i32 %conv1073, 0
  br i1 %cmp1074, label %cond.true.1076, label %cond.false.1112

cond.true.1076:                                   ; preds = %cond.false.1072
  %158 = load i64, i64* %nargs.addr, align 8
  %conv1077 = trunc i64 %158 to i32
  %159 = load i64, i64* %nargs.addr, align 8
  %conv1078 = trunc i64 %159 to i32
  %add1079 = add nsw i32 0, %conv1078
  %mul1080 = mul nsw i32 0, %add1079
  %sub1081 = sub nsw i32 %mul1080, 1
  %cmp1082 = icmp slt i32 %sub1081, 0
  br i1 %cmp1082, label %cond.true.1084, label %cond.false.1102

cond.true.1084:                                   ; preds = %cond.true.1076
  %160 = load i64, i64* %nargs.addr, align 8
  %conv1085 = trunc i64 %160 to i32
  %add1086 = add nsw i32 0, %conv1085
  %mul1087 = mul nsw i32 0, %add1086
  %add1088 = add nsw i32 %mul1087, 0
  %neg1089 = xor i32 %add1088, -1
  %cmp1090 = icmp eq i32 %neg1089, -1
  %conv1091 = zext i1 %cmp1090 to i32
  %sub1092 = sub nsw i32 0, %conv1091
  %161 = load i64, i64* %nargs.addr, align 8
  %conv1093 = trunc i64 %161 to i32
  %add1094 = add nsw i32 0, %conv1093
  %mul1095 = mul nsw i32 0, %add1094
  %add1096 = add nsw i32 %mul1095, 1
  %shl1097 = shl i32 %add1096, 30
  %sub1098 = sub nsw i32 %shl1097, 1
  %mul1099 = mul nsw i32 %sub1098, 2
  %add1100 = add nsw i32 %mul1099, 1
  %sub1101 = sub nsw i32 %sub1092, %add1100
  br label %cond.end.1107

cond.false.1102:                                  ; preds = %cond.true.1076
  %162 = load i64, i64* %nargs.addr, align 8
  %conv1103 = trunc i64 %162 to i32
  %add1104 = add nsw i32 0, %conv1103
  %mul1105 = mul nsw i32 0, %add1104
  %add1106 = add nsw i32 %mul1105, 0
  br label %cond.end.1107

cond.end.1107:                                    ; preds = %cond.false.1102, %cond.true.1084
  %cond1108 = phi i32 [ %sub1101, %cond.true.1084 ], [ %add1106, %cond.false.1102 ]
  %div1109 = sdiv i32 %cond1108, 24
  %cmp1110 = icmp slt i32 %conv1077, %div1109
  br i1 %cmp1110, label %cond.true.1156, label %lor.lhs.false.1139

cond.false.1112:                                  ; preds = %cond.false.1072
  %163 = load i64, i64* %nargs.addr, align 8
  %conv1113 = trunc i64 %163 to i32
  %add1114 = add nsw i32 0, %conv1113
  %mul1115 = mul nsw i32 0, %add1114
  %sub1116 = sub nsw i32 %mul1115, 1
  %cmp1117 = icmp slt i32 %sub1116, 0
  br i1 %cmp1117, label %cond.true.1119, label %cond.false.1128

cond.true.1119:                                   ; preds = %cond.false.1112
  %164 = load i64, i64* %nargs.addr, align 8
  %conv1120 = trunc i64 %164 to i32
  %add1121 = add nsw i32 0, %conv1120
  %mul1122 = mul nsw i32 0, %add1121
  %add1123 = add nsw i32 %mul1122, 1
  %shl1124 = shl i32 %add1123, 30
  %sub1125 = sub nsw i32 %shl1124, 1
  %mul1126 = mul nsw i32 %sub1125, 2
  %add1127 = add nsw i32 %mul1126, 1
  br label %cond.end.1133

cond.false.1128:                                  ; preds = %cond.false.1112
  %165 = load i64, i64* %nargs.addr, align 8
  %conv1129 = trunc i64 %165 to i32
  %add1130 = add nsw i32 0, %conv1129
  %mul1131 = mul nsw i32 0, %add1130
  %sub1132 = sub nsw i32 %mul1131, 1
  br label %cond.end.1133

cond.end.1133:                                    ; preds = %cond.false.1128, %cond.true.1119
  %cond1134 = phi i32 [ %add1127, %cond.true.1119 ], [ %sub1132, %cond.false.1128 ]
  %div1135 = sdiv i32 %cond1134, 24
  %166 = load i64, i64* %nargs.addr, align 8
  %conv1136 = trunc i64 %166 to i32
  %cmp1137 = icmp slt i32 %div1135, %conv1136
  br i1 %cmp1137, label %cond.true.1156, label %lor.lhs.false.1139

lor.lhs.false.1139:                               ; preds = %cond.end.1133, %cond.end.1107, %cond.true.1071, %cond.end.1064, %cond.true.1033, %cond.end.1027
  %167 = load i64, i64* %nargs.addr, align 8
  %conv1140 = trunc i64 %167 to i32
  %mul1141 = mul nsw i32 %conv1140, 24
  %mul1142 = mul nsw i32 0, %mul1141
  %sub1143 = sub nsw i32 %mul1142, 1
  %cmp1144 = icmp slt i32 %sub1143, 0
  br i1 %cmp1144, label %land.lhs.true.1146, label %lor.lhs.false.1151

land.lhs.true.1146:                               ; preds = %lor.lhs.false.1139
  %168 = load i64, i64* %nargs.addr, align 8
  %conv1147 = trunc i64 %168 to i32
  %mul1148 = mul nsw i32 %conv1147, 24
  %cmp1149 = icmp slt i32 %mul1148, -2147483648
  br i1 %cmp1149, label %cond.true.1156, label %lor.lhs.false.1151

lor.lhs.false.1151:                               ; preds = %land.lhs.true.1146, %lor.lhs.false.1139
  %169 = load i64, i64* %nargs.addr, align 8
  %conv1152 = trunc i64 %169 to i32
  %mul1153 = mul nsw i32 %conv1152, 24
  %cmp1154 = icmp slt i32 2147483647, %mul1153
  br i1 %cmp1154, label %cond.true.1156, label %cond.false.1172

cond.true.1156:                                   ; preds = %lor.lhs.false.1151, %land.lhs.true.1146, %cond.end.1133, %cond.end.1107, %cond.true.1071, %cond.end.1064, %cond.true.1033, %cond.end.1027, %land.lhs.true.996
  %170 = load i64, i64* %nargs.addr, align 8
  %conv1157 = trunc i64 %170 to i32
  %mul1158 = mul i32 %conv1157, 24
  %cmp1159 = icmp ule i32 %mul1158, 2147483647
  br i1 %cmp1159, label %cond.true.1161, label %cond.false.1164

cond.true.1161:                                   ; preds = %cond.true.1156
  %171 = load i64, i64* %nargs.addr, align 8
  %conv1162 = trunc i64 %171 to i32
  %mul1163 = mul i32 %conv1162, 24
  br label %cond.end.1169

cond.false.1164:                                  ; preds = %cond.true.1156
  %172 = load i64, i64* %nargs.addr, align 8
  %conv1165 = trunc i64 %172 to i32
  %mul1166 = mul i32 %conv1165, 24
  %sub1167 = sub i32 %mul1166, -2147483648
  %add1168 = add nsw i32 %sub1167, -2147483648
  br label %cond.end.1169

cond.end.1169:                                    ; preds = %cond.false.1164, %cond.true.1161
  %cond1170 = phi i32 [ %mul1163, %cond.true.1161 ], [ %add1168, %cond.false.1164 ]
  %conv1171 = sext i32 %cond1170 to i64
  store i64 %conv1171, i64* %alloca_size, align 8
  br i1 true, label %if.then, label %lor.lhs.false.2164

cond.false.1172:                                  ; preds = %lor.lhs.false.1151
  %173 = load i64, i64* %nargs.addr, align 8
  %conv1173 = trunc i64 %173 to i32
  %mul1174 = mul i32 %conv1173, 24
  %cmp1175 = icmp ule i32 %mul1174, 2147483647
  br i1 %cmp1175, label %cond.true.1177, label %cond.false.1180

cond.true.1177:                                   ; preds = %cond.false.1172
  %174 = load i64, i64* %nargs.addr, align 8
  %conv1178 = trunc i64 %174 to i32
  %mul1179 = mul i32 %conv1178, 24
  br label %cond.end.1185

cond.false.1180:                                  ; preds = %cond.false.1172
  %175 = load i64, i64* %nargs.addr, align 8
  %conv1181 = trunc i64 %175 to i32
  %mul1182 = mul i32 %conv1181, 24
  %sub1183 = sub i32 %mul1182, -2147483648
  %add1184 = add nsw i32 %sub1183, -2147483648
  br label %cond.end.1185

cond.end.1185:                                    ; preds = %cond.false.1180, %cond.true.1177
  %cond1186 = phi i32 [ %mul1179, %cond.true.1177 ], [ %add1184, %cond.false.1180 ]
  %conv1187 = sext i32 %cond1186 to i64
  store i64 %conv1187, i64* %alloca_size, align 8
  br i1 false, label %if.then, label %lor.lhs.false.2164

cond.false.1188:                                  ; preds = %cond.true.961
  %176 = load i64, i64* %nargs.addr, align 8
  %add1189 = add i64 0, %176
  %mul1190 = mul i64 0, %add1189
  %sub1191 = sub i64 %mul1190, 1
  %cmp1192 = icmp ult i64 %sub1191, 0
  br i1 %cmp1192, label %cond.true.1194, label %cond.false.1211

cond.true.1194:                                   ; preds = %cond.false.1188
  %177 = load i64, i64* %nargs.addr, align 8
  %add1195 = add i64 0, %177
  %mul1196 = mul i64 0, %add1195
  %add1197 = add i64 %mul1196, 0
  %neg1198 = xor i64 %add1197, -1
  %cmp1199 = icmp eq i64 %neg1198, -1
  %conv1200 = zext i1 %cmp1199 to i32
  %sub1201 = sub nsw i32 0, %conv1200
  %conv1202 = sext i32 %sub1201 to i64
  %178 = load i64, i64* %nargs.addr, align 8
  %add1203 = add i64 0, %178
  %mul1204 = mul i64 0, %add1203
  %add1205 = add i64 %mul1204, 1
  %shl1206 = shl i64 %add1205, 62
  %sub1207 = sub i64 %shl1206, 1
  %mul1208 = mul i64 %sub1207, 2
  %add1209 = add i64 %mul1208, 1
  %sub1210 = sub i64 %conv1202, %add1209
  br label %cond.end.1215

cond.false.1211:                                  ; preds = %cond.false.1188
  %179 = load i64, i64* %nargs.addr, align 8
  %add1212 = add i64 0, %179
  %mul1213 = mul i64 0, %add1212
  %add1214 = add i64 %mul1213, 0
  br label %cond.end.1215

cond.end.1215:                                    ; preds = %cond.false.1211, %cond.true.1194
  %cond1216 = phi i64 [ %sub1210, %cond.true.1194 ], [ %add1214, %cond.false.1211 ]
  %cmp1217 = icmp eq i64 %cond1216, 0
  br i1 %cmp1217, label %land.lhs.true.1219, label %lor.lhs.false.1222

land.lhs.true.1219:                               ; preds = %cond.end.1215
  %180 = load i64, i64* %nargs.addr, align 8
  %cmp1220 = icmp slt i64 %180, 0
  br i1 %cmp1220, label %cond.true.1357, label %lor.lhs.false.1222

lor.lhs.false.1222:                               ; preds = %land.lhs.true.1219, %cond.end.1215
  br i1 false, label %cond.true.1223, label %cond.false.1283

cond.true.1223:                                   ; preds = %lor.lhs.false.1222
  %181 = load i64, i64* %nargs.addr, align 8
  %cmp1224 = icmp slt i64 %181, 0
  br i1 %cmp1224, label %cond.true.1226, label %cond.false.1249

cond.true.1226:                                   ; preds = %cond.true.1223
  %182 = load i64, i64* %nargs.addr, align 8
  %183 = load i64, i64* %nargs.addr, align 8
  %add1227 = add i64 0, %183
  %mul1228 = mul i64 0, %add1227
  %sub1229 = sub i64 %mul1228, 1
  %cmp1230 = icmp ult i64 %sub1229, 0
  br i1 %cmp1230, label %cond.true.1232, label %cond.false.1240

cond.true.1232:                                   ; preds = %cond.true.1226
  %184 = load i64, i64* %nargs.addr, align 8
  %add1233 = add i64 0, %184
  %mul1234 = mul i64 0, %add1233
  %add1235 = add i64 %mul1234, 1
  %shl1236 = shl i64 %add1235, 62
  %sub1237 = sub i64 %shl1236, 1
  %mul1238 = mul i64 %sub1237, 2
  %add1239 = add i64 %mul1238, 1
  br label %cond.end.1244

cond.false.1240:                                  ; preds = %cond.true.1226
  %185 = load i64, i64* %nargs.addr, align 8
  %add1241 = add i64 0, %185
  %mul1242 = mul i64 0, %add1241
  %sub1243 = sub i64 %mul1242, 1
  br label %cond.end.1244

cond.end.1244:                                    ; preds = %cond.false.1240, %cond.true.1232
  %cond1245 = phi i64 [ %add1239, %cond.true.1232 ], [ %sub1243, %cond.false.1240 ]
  %div1246 = udiv i64 %cond1245, 24
  %cmp1247 = icmp ult i64 %182, %div1246
  br i1 %cmp1247, label %cond.true.1357, label %lor.lhs.false.1343

cond.false.1249:                                  ; preds = %cond.true.1223
  br i1 false, label %cond.true.1250, label %cond.false.1251

cond.true.1250:                                   ; preds = %cond.false.1249
  br i1 false, label %cond.true.1357, label %lor.lhs.false.1343

cond.false.1251:                                  ; preds = %cond.false.1249
  %186 = load i64, i64* %nargs.addr, align 8
  %add1252 = add i64 0, %186
  %mul1253 = mul i64 0, %add1252
  %sub1254 = sub i64 %mul1253, 1
  %cmp1255 = icmp ult i64 %sub1254, 0
  br i1 %cmp1255, label %cond.true.1257, label %cond.false.1274

cond.true.1257:                                   ; preds = %cond.false.1251
  %187 = load i64, i64* %nargs.addr, align 8
  %add1258 = add i64 0, %187
  %mul1259 = mul i64 0, %add1258
  %add1260 = add i64 %mul1259, 0
  %neg1261 = xor i64 %add1260, -1
  %cmp1262 = icmp eq i64 %neg1261, -1
  %conv1263 = zext i1 %cmp1262 to i32
  %sub1264 = sub nsw i32 0, %conv1263
  %conv1265 = sext i32 %sub1264 to i64
  %188 = load i64, i64* %nargs.addr, align 8
  %add1266 = add i64 0, %188
  %mul1267 = mul i64 0, %add1266
  %add1268 = add i64 %mul1267, 1
  %shl1269 = shl i64 %add1268, 62
  %sub1270 = sub i64 %shl1269, 1
  %mul1271 = mul i64 %sub1270, 2
  %add1272 = add i64 %mul1271, 1
  %sub1273 = sub i64 %conv1265, %add1272
  br label %cond.end.1278

cond.false.1274:                                  ; preds = %cond.false.1251
  %189 = load i64, i64* %nargs.addr, align 8
  %add1275 = add i64 0, %189
  %mul1276 = mul i64 0, %add1275
  %add1277 = add i64 %mul1276, 0
  br label %cond.end.1278

cond.end.1278:                                    ; preds = %cond.false.1274, %cond.true.1257
  %cond1279 = phi i64 [ %sub1273, %cond.true.1257 ], [ %add1277, %cond.false.1274 ]
  %div1280 = udiv i64 %cond1279, 24
  %190 = load i64, i64* %nargs.addr, align 8
  %cmp1281 = icmp ult i64 %div1280, %190
  br i1 %cmp1281, label %cond.true.1357, label %lor.lhs.false.1343

cond.false.1283:                                  ; preds = %lor.lhs.false.1222
  br i1 false, label %cond.true.1284, label %cond.false.1285

cond.true.1284:                                   ; preds = %cond.false.1283
  br i1 false, label %cond.true.1357, label %lor.lhs.false.1343

cond.false.1285:                                  ; preds = %cond.false.1283
  %191 = load i64, i64* %nargs.addr, align 8
  %cmp1286 = icmp slt i64 %191, 0
  br i1 %cmp1286, label %cond.true.1288, label %cond.false.1320

cond.true.1288:                                   ; preds = %cond.false.1285
  %192 = load i64, i64* %nargs.addr, align 8
  %193 = load i64, i64* %nargs.addr, align 8
  %add1289 = add i64 0, %193
  %mul1290 = mul i64 0, %add1289
  %sub1291 = sub i64 %mul1290, 1
  %cmp1292 = icmp ult i64 %sub1291, 0
  br i1 %cmp1292, label %cond.true.1294, label %cond.false.1311

cond.true.1294:                                   ; preds = %cond.true.1288
  %194 = load i64, i64* %nargs.addr, align 8
  %add1295 = add i64 0, %194
  %mul1296 = mul i64 0, %add1295
  %add1297 = add i64 %mul1296, 0
  %neg1298 = xor i64 %add1297, -1
  %cmp1299 = icmp eq i64 %neg1298, -1
  %conv1300 = zext i1 %cmp1299 to i32
  %sub1301 = sub nsw i32 0, %conv1300
  %conv1302 = sext i32 %sub1301 to i64
  %195 = load i64, i64* %nargs.addr, align 8
  %add1303 = add i64 0, %195
  %mul1304 = mul i64 0, %add1303
  %add1305 = add i64 %mul1304, 1
  %shl1306 = shl i64 %add1305, 62
  %sub1307 = sub i64 %shl1306, 1
  %mul1308 = mul i64 %sub1307, 2
  %add1309 = add i64 %mul1308, 1
  %sub1310 = sub i64 %conv1302, %add1309
  br label %cond.end.1315

cond.false.1311:                                  ; preds = %cond.true.1288
  %196 = load i64, i64* %nargs.addr, align 8
  %add1312 = add i64 0, %196
  %mul1313 = mul i64 0, %add1312
  %add1314 = add i64 %mul1313, 0
  br label %cond.end.1315

cond.end.1315:                                    ; preds = %cond.false.1311, %cond.true.1294
  %cond1316 = phi i64 [ %sub1310, %cond.true.1294 ], [ %add1314, %cond.false.1311 ]
  %div1317 = udiv i64 %cond1316, 24
  %cmp1318 = icmp ult i64 %192, %div1317
  br i1 %cmp1318, label %cond.true.1357, label %lor.lhs.false.1343

cond.false.1320:                                  ; preds = %cond.false.1285
  %197 = load i64, i64* %nargs.addr, align 8
  %add1321 = add i64 0, %197
  %mul1322 = mul i64 0, %add1321
  %sub1323 = sub i64 %mul1322, 1
  %cmp1324 = icmp ult i64 %sub1323, 0
  br i1 %cmp1324, label %cond.true.1326, label %cond.false.1334

cond.true.1326:                                   ; preds = %cond.false.1320
  %198 = load i64, i64* %nargs.addr, align 8
  %add1327 = add i64 0, %198
  %mul1328 = mul i64 0, %add1327
  %add1329 = add i64 %mul1328, 1
  %shl1330 = shl i64 %add1329, 62
  %sub1331 = sub i64 %shl1330, 1
  %mul1332 = mul i64 %sub1331, 2
  %add1333 = add i64 %mul1332, 1
  br label %cond.end.1338

cond.false.1334:                                  ; preds = %cond.false.1320
  %199 = load i64, i64* %nargs.addr, align 8
  %add1335 = add i64 0, %199
  %mul1336 = mul i64 0, %add1335
  %sub1337 = sub i64 %mul1336, 1
  br label %cond.end.1338

cond.end.1338:                                    ; preds = %cond.false.1334, %cond.true.1326
  %cond1339 = phi i64 [ %add1333, %cond.true.1326 ], [ %sub1337, %cond.false.1334 ]
  %div1340 = udiv i64 %cond1339, 24
  %200 = load i64, i64* %nargs.addr, align 8
  %cmp1341 = icmp ult i64 %div1340, %200
  br i1 %cmp1341, label %cond.true.1357, label %lor.lhs.false.1343

lor.lhs.false.1343:                               ; preds = %cond.end.1338, %cond.end.1315, %cond.true.1284, %cond.end.1278, %cond.true.1250, %cond.end.1244
  %201 = load i64, i64* %nargs.addr, align 8
  %mul1344 = mul i64 %201, 24
  %mul1345 = mul i64 0, %mul1344
  %sub1346 = sub i64 %mul1345, 1
  %cmp1347 = icmp ult i64 %sub1346, 0
  br i1 %cmp1347, label %land.lhs.true.1349, label %lor.lhs.false.1353

land.lhs.true.1349:                               ; preds = %lor.lhs.false.1343
  %202 = load i64, i64* %nargs.addr, align 8
  %mul1350 = mul i64 %202, 24
  %cmp1351 = icmp ult i64 %mul1350, -2147483648
  br i1 %cmp1351, label %cond.true.1357, label %lor.lhs.false.1353

lor.lhs.false.1353:                               ; preds = %land.lhs.true.1349, %lor.lhs.false.1343
  %203 = load i64, i64* %nargs.addr, align 8
  %mul1354 = mul i64 %203, 24
  %cmp1355 = icmp ult i64 2147483647, %mul1354
  br i1 %cmp1355, label %cond.true.1357, label %cond.false.1373

cond.true.1357:                                   ; preds = %lor.lhs.false.1353, %land.lhs.true.1349, %cond.end.1338, %cond.end.1315, %cond.true.1284, %cond.end.1278, %cond.true.1250, %cond.end.1244, %land.lhs.true.1219
  %204 = load i64, i64* %nargs.addr, align 8
  %conv1358 = trunc i64 %204 to i32
  %mul1359 = mul i32 %conv1358, 24
  %cmp1360 = icmp ule i32 %mul1359, 2147483647
  br i1 %cmp1360, label %cond.true.1362, label %cond.false.1365

cond.true.1362:                                   ; preds = %cond.true.1357
  %205 = load i64, i64* %nargs.addr, align 8
  %conv1363 = trunc i64 %205 to i32
  %mul1364 = mul i32 %conv1363, 24
  br label %cond.end.1370

cond.false.1365:                                  ; preds = %cond.true.1357
  %206 = load i64, i64* %nargs.addr, align 8
  %conv1366 = trunc i64 %206 to i32
  %mul1367 = mul i32 %conv1366, 24
  %sub1368 = sub i32 %mul1367, -2147483648
  %add1369 = add nsw i32 %sub1368, -2147483648
  br label %cond.end.1370

cond.end.1370:                                    ; preds = %cond.false.1365, %cond.true.1362
  %cond1371 = phi i32 [ %mul1364, %cond.true.1362 ], [ %add1369, %cond.false.1365 ]
  %conv1372 = sext i32 %cond1371 to i64
  store i64 %conv1372, i64* %alloca_size, align 8
  br i1 true, label %if.then, label %lor.lhs.false.2164

cond.false.1373:                                  ; preds = %lor.lhs.false.1353
  %207 = load i64, i64* %nargs.addr, align 8
  %conv1374 = trunc i64 %207 to i32
  %mul1375 = mul i32 %conv1374, 24
  %cmp1376 = icmp ule i32 %mul1375, 2147483647
  br i1 %cmp1376, label %cond.true.1378, label %cond.false.1381

cond.true.1378:                                   ; preds = %cond.false.1373
  %208 = load i64, i64* %nargs.addr, align 8
  %conv1379 = trunc i64 %208 to i32
  %mul1380 = mul i32 %conv1379, 24
  br label %cond.end.1386

cond.false.1381:                                  ; preds = %cond.false.1373
  %209 = load i64, i64* %nargs.addr, align 8
  %conv1382 = trunc i64 %209 to i32
  %mul1383 = mul i32 %conv1382, 24
  %sub1384 = sub i32 %mul1383, -2147483648
  %add1385 = add nsw i32 %sub1384, -2147483648
  br label %cond.end.1386

cond.end.1386:                                    ; preds = %cond.false.1381, %cond.true.1378
  %cond1387 = phi i32 [ %mul1380, %cond.true.1378 ], [ %add1385, %cond.false.1381 ]
  %conv1388 = sext i32 %cond1387 to i64
  store i64 %conv1388, i64* %alloca_size, align 8
  br i1 false, label %if.then, label %lor.lhs.false.2164

cond.false.1389:                                  ; preds = %cond.false.960
  br i1 true, label %cond.true.1390, label %cond.false.1777

cond.true.1390:                                   ; preds = %cond.false.1389
  br i1 false, label %cond.true.1391, label %cond.false.1584

cond.true.1391:                                   ; preds = %cond.true.1390
  %210 = load i64, i64* %nargs.addr, align 8
  %add1392 = add nsw i64 0, %210
  %mul1393 = mul nsw i64 0, %add1392
  %sub1394 = sub nsw i64 %mul1393, 1
  %cmp1395 = icmp slt i64 %sub1394, 0
  br i1 %cmp1395, label %cond.true.1397, label %cond.false.1414

cond.true.1397:                                   ; preds = %cond.true.1391
  %211 = load i64, i64* %nargs.addr, align 8
  %add1398 = add nsw i64 0, %211
  %mul1399 = mul nsw i64 0, %add1398
  %add1400 = add nsw i64 %mul1399, 0
  %neg1401 = xor i64 %add1400, -1
  %cmp1402 = icmp eq i64 %neg1401, -1
  %conv1403 = zext i1 %cmp1402 to i32
  %sub1404 = sub nsw i32 0, %conv1403
  %conv1405 = sext i32 %sub1404 to i64
  %212 = load i64, i64* %nargs.addr, align 8
  %add1406 = add nsw i64 0, %212
  %mul1407 = mul nsw i64 0, %add1406
  %add1408 = add nsw i64 %mul1407, 1
  %shl1409 = shl i64 %add1408, 62
  %sub1410 = sub nsw i64 %shl1409, 1
  %mul1411 = mul nsw i64 %sub1410, 2
  %add1412 = add nsw i64 %mul1411, 1
  %sub1413 = sub nsw i64 %conv1405, %add1412
  br label %cond.end.1418

cond.false.1414:                                  ; preds = %cond.true.1391
  %213 = load i64, i64* %nargs.addr, align 8
  %add1415 = add nsw i64 0, %213
  %mul1416 = mul nsw i64 0, %add1415
  %add1417 = add nsw i64 %mul1416, 0
  br label %cond.end.1418

cond.end.1418:                                    ; preds = %cond.false.1414, %cond.true.1397
  %cond1419 = phi i64 [ %sub1413, %cond.true.1397 ], [ %add1417, %cond.false.1414 ]
  %cmp1420 = icmp eq i64 %cond1419, 0
  br i1 %cmp1420, label %land.lhs.true.1422, label %lor.lhs.false.1425

land.lhs.true.1422:                               ; preds = %cond.end.1418
  %214 = load i64, i64* %nargs.addr, align 8
  %cmp1423 = icmp slt i64 %214, 0
  br i1 %cmp1423, label %cond.true.1560, label %lor.lhs.false.1425

lor.lhs.false.1425:                               ; preds = %land.lhs.true.1422, %cond.end.1418
  br i1 false, label %cond.true.1426, label %cond.false.1486

cond.true.1426:                                   ; preds = %lor.lhs.false.1425
  %215 = load i64, i64* %nargs.addr, align 8
  %cmp1427 = icmp slt i64 %215, 0
  br i1 %cmp1427, label %cond.true.1429, label %cond.false.1452

cond.true.1429:                                   ; preds = %cond.true.1426
  %216 = load i64, i64* %nargs.addr, align 8
  %217 = load i64, i64* %nargs.addr, align 8
  %add1430 = add nsw i64 0, %217
  %mul1431 = mul nsw i64 0, %add1430
  %sub1432 = sub nsw i64 %mul1431, 1
  %cmp1433 = icmp slt i64 %sub1432, 0
  br i1 %cmp1433, label %cond.true.1435, label %cond.false.1443

cond.true.1435:                                   ; preds = %cond.true.1429
  %218 = load i64, i64* %nargs.addr, align 8
  %add1436 = add nsw i64 0, %218
  %mul1437 = mul nsw i64 0, %add1436
  %add1438 = add nsw i64 %mul1437, 1
  %shl1439 = shl i64 %add1438, 62
  %sub1440 = sub nsw i64 %shl1439, 1
  %mul1441 = mul nsw i64 %sub1440, 2
  %add1442 = add nsw i64 %mul1441, 1
  br label %cond.end.1447

cond.false.1443:                                  ; preds = %cond.true.1429
  %219 = load i64, i64* %nargs.addr, align 8
  %add1444 = add nsw i64 0, %219
  %mul1445 = mul nsw i64 0, %add1444
  %sub1446 = sub nsw i64 %mul1445, 1
  br label %cond.end.1447

cond.end.1447:                                    ; preds = %cond.false.1443, %cond.true.1435
  %cond1448 = phi i64 [ %add1442, %cond.true.1435 ], [ %sub1446, %cond.false.1443 ]
  %div1449 = sdiv i64 %cond1448, 24
  %cmp1450 = icmp slt i64 %216, %div1449
  br i1 %cmp1450, label %cond.true.1560, label %lor.lhs.false.1546

cond.false.1452:                                  ; preds = %cond.true.1426
  br i1 false, label %cond.true.1453, label %cond.false.1454

cond.true.1453:                                   ; preds = %cond.false.1452
  br i1 false, label %cond.true.1560, label %lor.lhs.false.1546

cond.false.1454:                                  ; preds = %cond.false.1452
  %220 = load i64, i64* %nargs.addr, align 8
  %add1455 = add nsw i64 0, %220
  %mul1456 = mul nsw i64 0, %add1455
  %sub1457 = sub nsw i64 %mul1456, 1
  %cmp1458 = icmp slt i64 %sub1457, 0
  br i1 %cmp1458, label %cond.true.1460, label %cond.false.1477

cond.true.1460:                                   ; preds = %cond.false.1454
  %221 = load i64, i64* %nargs.addr, align 8
  %add1461 = add nsw i64 0, %221
  %mul1462 = mul nsw i64 0, %add1461
  %add1463 = add nsw i64 %mul1462, 0
  %neg1464 = xor i64 %add1463, -1
  %cmp1465 = icmp eq i64 %neg1464, -1
  %conv1466 = zext i1 %cmp1465 to i32
  %sub1467 = sub nsw i32 0, %conv1466
  %conv1468 = sext i32 %sub1467 to i64
  %222 = load i64, i64* %nargs.addr, align 8
  %add1469 = add nsw i64 0, %222
  %mul1470 = mul nsw i64 0, %add1469
  %add1471 = add nsw i64 %mul1470, 1
  %shl1472 = shl i64 %add1471, 62
  %sub1473 = sub nsw i64 %shl1472, 1
  %mul1474 = mul nsw i64 %sub1473, 2
  %add1475 = add nsw i64 %mul1474, 1
  %sub1476 = sub nsw i64 %conv1468, %add1475
  br label %cond.end.1481

cond.false.1477:                                  ; preds = %cond.false.1454
  %223 = load i64, i64* %nargs.addr, align 8
  %add1478 = add nsw i64 0, %223
  %mul1479 = mul nsw i64 0, %add1478
  %add1480 = add nsw i64 %mul1479, 0
  br label %cond.end.1481

cond.end.1481:                                    ; preds = %cond.false.1477, %cond.true.1460
  %cond1482 = phi i64 [ %sub1476, %cond.true.1460 ], [ %add1480, %cond.false.1477 ]
  %div1483 = sdiv i64 %cond1482, 24
  %224 = load i64, i64* %nargs.addr, align 8
  %cmp1484 = icmp slt i64 %div1483, %224
  br i1 %cmp1484, label %cond.true.1560, label %lor.lhs.false.1546

cond.false.1486:                                  ; preds = %lor.lhs.false.1425
  br i1 false, label %cond.true.1487, label %cond.false.1488

cond.true.1487:                                   ; preds = %cond.false.1486
  br i1 false, label %cond.true.1560, label %lor.lhs.false.1546

cond.false.1488:                                  ; preds = %cond.false.1486
  %225 = load i64, i64* %nargs.addr, align 8
  %cmp1489 = icmp slt i64 %225, 0
  br i1 %cmp1489, label %cond.true.1491, label %cond.false.1523

cond.true.1491:                                   ; preds = %cond.false.1488
  %226 = load i64, i64* %nargs.addr, align 8
  %227 = load i64, i64* %nargs.addr, align 8
  %add1492 = add nsw i64 0, %227
  %mul1493 = mul nsw i64 0, %add1492
  %sub1494 = sub nsw i64 %mul1493, 1
  %cmp1495 = icmp slt i64 %sub1494, 0
  br i1 %cmp1495, label %cond.true.1497, label %cond.false.1514

cond.true.1497:                                   ; preds = %cond.true.1491
  %228 = load i64, i64* %nargs.addr, align 8
  %add1498 = add nsw i64 0, %228
  %mul1499 = mul nsw i64 0, %add1498
  %add1500 = add nsw i64 %mul1499, 0
  %neg1501 = xor i64 %add1500, -1
  %cmp1502 = icmp eq i64 %neg1501, -1
  %conv1503 = zext i1 %cmp1502 to i32
  %sub1504 = sub nsw i32 0, %conv1503
  %conv1505 = sext i32 %sub1504 to i64
  %229 = load i64, i64* %nargs.addr, align 8
  %add1506 = add nsw i64 0, %229
  %mul1507 = mul nsw i64 0, %add1506
  %add1508 = add nsw i64 %mul1507, 1
  %shl1509 = shl i64 %add1508, 62
  %sub1510 = sub nsw i64 %shl1509, 1
  %mul1511 = mul nsw i64 %sub1510, 2
  %add1512 = add nsw i64 %mul1511, 1
  %sub1513 = sub nsw i64 %conv1505, %add1512
  br label %cond.end.1518

cond.false.1514:                                  ; preds = %cond.true.1491
  %230 = load i64, i64* %nargs.addr, align 8
  %add1515 = add nsw i64 0, %230
  %mul1516 = mul nsw i64 0, %add1515
  %add1517 = add nsw i64 %mul1516, 0
  br label %cond.end.1518

cond.end.1518:                                    ; preds = %cond.false.1514, %cond.true.1497
  %cond1519 = phi i64 [ %sub1513, %cond.true.1497 ], [ %add1517, %cond.false.1514 ]
  %div1520 = sdiv i64 %cond1519, 24
  %cmp1521 = icmp slt i64 %226, %div1520
  br i1 %cmp1521, label %cond.true.1560, label %lor.lhs.false.1546

cond.false.1523:                                  ; preds = %cond.false.1488
  %231 = load i64, i64* %nargs.addr, align 8
  %add1524 = add nsw i64 0, %231
  %mul1525 = mul nsw i64 0, %add1524
  %sub1526 = sub nsw i64 %mul1525, 1
  %cmp1527 = icmp slt i64 %sub1526, 0
  br i1 %cmp1527, label %cond.true.1529, label %cond.false.1537

cond.true.1529:                                   ; preds = %cond.false.1523
  %232 = load i64, i64* %nargs.addr, align 8
  %add1530 = add nsw i64 0, %232
  %mul1531 = mul nsw i64 0, %add1530
  %add1532 = add nsw i64 %mul1531, 1
  %shl1533 = shl i64 %add1532, 62
  %sub1534 = sub nsw i64 %shl1533, 1
  %mul1535 = mul nsw i64 %sub1534, 2
  %add1536 = add nsw i64 %mul1535, 1
  br label %cond.end.1541

cond.false.1537:                                  ; preds = %cond.false.1523
  %233 = load i64, i64* %nargs.addr, align 8
  %add1538 = add nsw i64 0, %233
  %mul1539 = mul nsw i64 0, %add1538
  %sub1540 = sub nsw i64 %mul1539, 1
  br label %cond.end.1541

cond.end.1541:                                    ; preds = %cond.false.1537, %cond.true.1529
  %cond1542 = phi i64 [ %add1536, %cond.true.1529 ], [ %sub1540, %cond.false.1537 ]
  %div1543 = sdiv i64 %cond1542, 24
  %234 = load i64, i64* %nargs.addr, align 8
  %cmp1544 = icmp slt i64 %div1543, %234
  br i1 %cmp1544, label %cond.true.1560, label %lor.lhs.false.1546

lor.lhs.false.1546:                               ; preds = %cond.end.1541, %cond.end.1518, %cond.true.1487, %cond.end.1481, %cond.true.1453, %cond.end.1447
  %235 = load i64, i64* %nargs.addr, align 8
  %mul1547 = mul nsw i64 %235, 24
  %mul1548 = mul nsw i64 0, %mul1547
  %sub1549 = sub nsw i64 %mul1548, 1
  %cmp1550 = icmp slt i64 %sub1549, 0
  br i1 %cmp1550, label %land.lhs.true.1552, label %lor.lhs.false.1556

land.lhs.true.1552:                               ; preds = %lor.lhs.false.1546
  %236 = load i64, i64* %nargs.addr, align 8
  %mul1553 = mul nsw i64 %236, 24
  %cmp1554 = icmp slt i64 %mul1553, -9223372036854775808
  br i1 %cmp1554, label %cond.true.1560, label %lor.lhs.false.1556

lor.lhs.false.1556:                               ; preds = %land.lhs.true.1552, %lor.lhs.false.1546
  %237 = load i64, i64* %nargs.addr, align 8
  %mul1557 = mul nsw i64 %237, 24
  %cmp1558 = icmp slt i64 9223372036854775807, %mul1557
  br i1 %cmp1558, label %cond.true.1560, label %cond.false.1572

cond.true.1560:                                   ; preds = %lor.lhs.false.1556, %land.lhs.true.1552, %cond.end.1541, %cond.end.1518, %cond.true.1487, %cond.end.1481, %cond.true.1453, %cond.end.1447, %land.lhs.true.1422
  %238 = load i64, i64* %nargs.addr, align 8
  %mul1561 = mul i64 %238, 24
  %cmp1562 = icmp ule i64 %mul1561, 9223372036854775807
  br i1 %cmp1562, label %cond.true.1564, label %cond.false.1566

cond.true.1564:                                   ; preds = %cond.true.1560
  %239 = load i64, i64* %nargs.addr, align 8
  %mul1565 = mul i64 %239, 24
  br label %cond.end.1570

cond.false.1566:                                  ; preds = %cond.true.1560
  %240 = load i64, i64* %nargs.addr, align 8
  %mul1567 = mul i64 %240, 24
  %sub1568 = sub i64 %mul1567, -9223372036854775808
  %add1569 = add nsw i64 %sub1568, -9223372036854775808
  br label %cond.end.1570

cond.end.1570:                                    ; preds = %cond.false.1566, %cond.true.1564
  %cond1571 = phi i64 [ %mul1565, %cond.true.1564 ], [ %add1569, %cond.false.1566 ]
  store i64 %cond1571, i64* %alloca_size, align 8
  br i1 true, label %if.then, label %lor.lhs.false.2164

cond.false.1572:                                  ; preds = %lor.lhs.false.1556
  %241 = load i64, i64* %nargs.addr, align 8
  %mul1573 = mul i64 %241, 24
  %cmp1574 = icmp ule i64 %mul1573, 9223372036854775807
  br i1 %cmp1574, label %cond.true.1576, label %cond.false.1578

cond.true.1576:                                   ; preds = %cond.false.1572
  %242 = load i64, i64* %nargs.addr, align 8
  %mul1577 = mul i64 %242, 24
  br label %cond.end.1582

cond.false.1578:                                  ; preds = %cond.false.1572
  %243 = load i64, i64* %nargs.addr, align 8
  %mul1579 = mul i64 %243, 24
  %sub1580 = sub i64 %mul1579, -9223372036854775808
  %add1581 = add nsw i64 %sub1580, -9223372036854775808
  br label %cond.end.1582

cond.end.1582:                                    ; preds = %cond.false.1578, %cond.true.1576
  %cond1583 = phi i64 [ %mul1577, %cond.true.1576 ], [ %add1581, %cond.false.1578 ]
  store i64 %cond1583, i64* %alloca_size, align 8
  br i1 false, label %if.then, label %lor.lhs.false.2164

cond.false.1584:                                  ; preds = %cond.true.1390
  %244 = load i64, i64* %nargs.addr, align 8
  %add1585 = add i64 0, %244
  %mul1586 = mul i64 0, %add1585
  %sub1587 = sub i64 %mul1586, 1
  %cmp1588 = icmp ult i64 %sub1587, 0
  br i1 %cmp1588, label %cond.true.1590, label %cond.false.1607

cond.true.1590:                                   ; preds = %cond.false.1584
  %245 = load i64, i64* %nargs.addr, align 8
  %add1591 = add i64 0, %245
  %mul1592 = mul i64 0, %add1591
  %add1593 = add i64 %mul1592, 0
  %neg1594 = xor i64 %add1593, -1
  %cmp1595 = icmp eq i64 %neg1594, -1
  %conv1596 = zext i1 %cmp1595 to i32
  %sub1597 = sub nsw i32 0, %conv1596
  %conv1598 = sext i32 %sub1597 to i64
  %246 = load i64, i64* %nargs.addr, align 8
  %add1599 = add i64 0, %246
  %mul1600 = mul i64 0, %add1599
  %add1601 = add i64 %mul1600, 1
  %shl1602 = shl i64 %add1601, 62
  %sub1603 = sub i64 %shl1602, 1
  %mul1604 = mul i64 %sub1603, 2
  %add1605 = add i64 %mul1604, 1
  %sub1606 = sub i64 %conv1598, %add1605
  br label %cond.end.1611

cond.false.1607:                                  ; preds = %cond.false.1584
  %247 = load i64, i64* %nargs.addr, align 8
  %add1608 = add i64 0, %247
  %mul1609 = mul i64 0, %add1608
  %add1610 = add i64 %mul1609, 0
  br label %cond.end.1611

cond.end.1611:                                    ; preds = %cond.false.1607, %cond.true.1590
  %cond1612 = phi i64 [ %sub1606, %cond.true.1590 ], [ %add1610, %cond.false.1607 ]
  %cmp1613 = icmp eq i64 %cond1612, 0
  br i1 %cmp1613, label %land.lhs.true.1615, label %lor.lhs.false.1618

land.lhs.true.1615:                               ; preds = %cond.end.1611
  %248 = load i64, i64* %nargs.addr, align 8
  %cmp1616 = icmp slt i64 %248, 0
  br i1 %cmp1616, label %cond.true.1753, label %lor.lhs.false.1618

lor.lhs.false.1618:                               ; preds = %land.lhs.true.1615, %cond.end.1611
  br i1 false, label %cond.true.1619, label %cond.false.1679

cond.true.1619:                                   ; preds = %lor.lhs.false.1618
  %249 = load i64, i64* %nargs.addr, align 8
  %cmp1620 = icmp slt i64 %249, 0
  br i1 %cmp1620, label %cond.true.1622, label %cond.false.1645

cond.true.1622:                                   ; preds = %cond.true.1619
  %250 = load i64, i64* %nargs.addr, align 8
  %251 = load i64, i64* %nargs.addr, align 8
  %add1623 = add i64 0, %251
  %mul1624 = mul i64 0, %add1623
  %sub1625 = sub i64 %mul1624, 1
  %cmp1626 = icmp ult i64 %sub1625, 0
  br i1 %cmp1626, label %cond.true.1628, label %cond.false.1636

cond.true.1628:                                   ; preds = %cond.true.1622
  %252 = load i64, i64* %nargs.addr, align 8
  %add1629 = add i64 0, %252
  %mul1630 = mul i64 0, %add1629
  %add1631 = add i64 %mul1630, 1
  %shl1632 = shl i64 %add1631, 62
  %sub1633 = sub i64 %shl1632, 1
  %mul1634 = mul i64 %sub1633, 2
  %add1635 = add i64 %mul1634, 1
  br label %cond.end.1640

cond.false.1636:                                  ; preds = %cond.true.1622
  %253 = load i64, i64* %nargs.addr, align 8
  %add1637 = add i64 0, %253
  %mul1638 = mul i64 0, %add1637
  %sub1639 = sub i64 %mul1638, 1
  br label %cond.end.1640

cond.end.1640:                                    ; preds = %cond.false.1636, %cond.true.1628
  %cond1641 = phi i64 [ %add1635, %cond.true.1628 ], [ %sub1639, %cond.false.1636 ]
  %div1642 = udiv i64 %cond1641, 24
  %cmp1643 = icmp ult i64 %250, %div1642
  br i1 %cmp1643, label %cond.true.1753, label %lor.lhs.false.1739

cond.false.1645:                                  ; preds = %cond.true.1619
  br i1 false, label %cond.true.1646, label %cond.false.1647

cond.true.1646:                                   ; preds = %cond.false.1645
  br i1 false, label %cond.true.1753, label %lor.lhs.false.1739

cond.false.1647:                                  ; preds = %cond.false.1645
  %254 = load i64, i64* %nargs.addr, align 8
  %add1648 = add i64 0, %254
  %mul1649 = mul i64 0, %add1648
  %sub1650 = sub i64 %mul1649, 1
  %cmp1651 = icmp ult i64 %sub1650, 0
  br i1 %cmp1651, label %cond.true.1653, label %cond.false.1670

cond.true.1653:                                   ; preds = %cond.false.1647
  %255 = load i64, i64* %nargs.addr, align 8
  %add1654 = add i64 0, %255
  %mul1655 = mul i64 0, %add1654
  %add1656 = add i64 %mul1655, 0
  %neg1657 = xor i64 %add1656, -1
  %cmp1658 = icmp eq i64 %neg1657, -1
  %conv1659 = zext i1 %cmp1658 to i32
  %sub1660 = sub nsw i32 0, %conv1659
  %conv1661 = sext i32 %sub1660 to i64
  %256 = load i64, i64* %nargs.addr, align 8
  %add1662 = add i64 0, %256
  %mul1663 = mul i64 0, %add1662
  %add1664 = add i64 %mul1663, 1
  %shl1665 = shl i64 %add1664, 62
  %sub1666 = sub i64 %shl1665, 1
  %mul1667 = mul i64 %sub1666, 2
  %add1668 = add i64 %mul1667, 1
  %sub1669 = sub i64 %conv1661, %add1668
  br label %cond.end.1674

cond.false.1670:                                  ; preds = %cond.false.1647
  %257 = load i64, i64* %nargs.addr, align 8
  %add1671 = add i64 0, %257
  %mul1672 = mul i64 0, %add1671
  %add1673 = add i64 %mul1672, 0
  br label %cond.end.1674

cond.end.1674:                                    ; preds = %cond.false.1670, %cond.true.1653
  %cond1675 = phi i64 [ %sub1669, %cond.true.1653 ], [ %add1673, %cond.false.1670 ]
  %div1676 = udiv i64 %cond1675, 24
  %258 = load i64, i64* %nargs.addr, align 8
  %cmp1677 = icmp ult i64 %div1676, %258
  br i1 %cmp1677, label %cond.true.1753, label %lor.lhs.false.1739

cond.false.1679:                                  ; preds = %lor.lhs.false.1618
  br i1 false, label %cond.true.1680, label %cond.false.1681

cond.true.1680:                                   ; preds = %cond.false.1679
  br i1 false, label %cond.true.1753, label %lor.lhs.false.1739

cond.false.1681:                                  ; preds = %cond.false.1679
  %259 = load i64, i64* %nargs.addr, align 8
  %cmp1682 = icmp slt i64 %259, 0
  br i1 %cmp1682, label %cond.true.1684, label %cond.false.1716

cond.true.1684:                                   ; preds = %cond.false.1681
  %260 = load i64, i64* %nargs.addr, align 8
  %261 = load i64, i64* %nargs.addr, align 8
  %add1685 = add i64 0, %261
  %mul1686 = mul i64 0, %add1685
  %sub1687 = sub i64 %mul1686, 1
  %cmp1688 = icmp ult i64 %sub1687, 0
  br i1 %cmp1688, label %cond.true.1690, label %cond.false.1707

cond.true.1690:                                   ; preds = %cond.true.1684
  %262 = load i64, i64* %nargs.addr, align 8
  %add1691 = add i64 0, %262
  %mul1692 = mul i64 0, %add1691
  %add1693 = add i64 %mul1692, 0
  %neg1694 = xor i64 %add1693, -1
  %cmp1695 = icmp eq i64 %neg1694, -1
  %conv1696 = zext i1 %cmp1695 to i32
  %sub1697 = sub nsw i32 0, %conv1696
  %conv1698 = sext i32 %sub1697 to i64
  %263 = load i64, i64* %nargs.addr, align 8
  %add1699 = add i64 0, %263
  %mul1700 = mul i64 0, %add1699
  %add1701 = add i64 %mul1700, 1
  %shl1702 = shl i64 %add1701, 62
  %sub1703 = sub i64 %shl1702, 1
  %mul1704 = mul i64 %sub1703, 2
  %add1705 = add i64 %mul1704, 1
  %sub1706 = sub i64 %conv1698, %add1705
  br label %cond.end.1711

cond.false.1707:                                  ; preds = %cond.true.1684
  %264 = load i64, i64* %nargs.addr, align 8
  %add1708 = add i64 0, %264
  %mul1709 = mul i64 0, %add1708
  %add1710 = add i64 %mul1709, 0
  br label %cond.end.1711

cond.end.1711:                                    ; preds = %cond.false.1707, %cond.true.1690
  %cond1712 = phi i64 [ %sub1706, %cond.true.1690 ], [ %add1710, %cond.false.1707 ]
  %div1713 = udiv i64 %cond1712, 24
  %cmp1714 = icmp ult i64 %260, %div1713
  br i1 %cmp1714, label %cond.true.1753, label %lor.lhs.false.1739

cond.false.1716:                                  ; preds = %cond.false.1681
  %265 = load i64, i64* %nargs.addr, align 8
  %add1717 = add i64 0, %265
  %mul1718 = mul i64 0, %add1717
  %sub1719 = sub i64 %mul1718, 1
  %cmp1720 = icmp ult i64 %sub1719, 0
  br i1 %cmp1720, label %cond.true.1722, label %cond.false.1730

cond.true.1722:                                   ; preds = %cond.false.1716
  %266 = load i64, i64* %nargs.addr, align 8
  %add1723 = add i64 0, %266
  %mul1724 = mul i64 0, %add1723
  %add1725 = add i64 %mul1724, 1
  %shl1726 = shl i64 %add1725, 62
  %sub1727 = sub i64 %shl1726, 1
  %mul1728 = mul i64 %sub1727, 2
  %add1729 = add i64 %mul1728, 1
  br label %cond.end.1734

cond.false.1730:                                  ; preds = %cond.false.1716
  %267 = load i64, i64* %nargs.addr, align 8
  %add1731 = add i64 0, %267
  %mul1732 = mul i64 0, %add1731
  %sub1733 = sub i64 %mul1732, 1
  br label %cond.end.1734

cond.end.1734:                                    ; preds = %cond.false.1730, %cond.true.1722
  %cond1735 = phi i64 [ %add1729, %cond.true.1722 ], [ %sub1733, %cond.false.1730 ]
  %div1736 = udiv i64 %cond1735, 24
  %268 = load i64, i64* %nargs.addr, align 8
  %cmp1737 = icmp ult i64 %div1736, %268
  br i1 %cmp1737, label %cond.true.1753, label %lor.lhs.false.1739

lor.lhs.false.1739:                               ; preds = %cond.end.1734, %cond.end.1711, %cond.true.1680, %cond.end.1674, %cond.true.1646, %cond.end.1640
  %269 = load i64, i64* %nargs.addr, align 8
  %mul1740 = mul i64 %269, 24
  %mul1741 = mul i64 0, %mul1740
  %sub1742 = sub i64 %mul1741, 1
  %cmp1743 = icmp ult i64 %sub1742, 0
  br i1 %cmp1743, label %land.lhs.true.1745, label %lor.lhs.false.1749

land.lhs.true.1745:                               ; preds = %lor.lhs.false.1739
  %270 = load i64, i64* %nargs.addr, align 8
  %mul1746 = mul i64 %270, 24
  %cmp1747 = icmp ult i64 %mul1746, -9223372036854775808
  br i1 %cmp1747, label %cond.true.1753, label %lor.lhs.false.1749

lor.lhs.false.1749:                               ; preds = %land.lhs.true.1745, %lor.lhs.false.1739
  %271 = load i64, i64* %nargs.addr, align 8
  %mul1750 = mul i64 %271, 24
  %cmp1751 = icmp ult i64 9223372036854775807, %mul1750
  br i1 %cmp1751, label %cond.true.1753, label %cond.false.1765

cond.true.1753:                                   ; preds = %lor.lhs.false.1749, %land.lhs.true.1745, %cond.end.1734, %cond.end.1711, %cond.true.1680, %cond.end.1674, %cond.true.1646, %cond.end.1640, %land.lhs.true.1615
  %272 = load i64, i64* %nargs.addr, align 8
  %mul1754 = mul i64 %272, 24
  %cmp1755 = icmp ule i64 %mul1754, 9223372036854775807
  br i1 %cmp1755, label %cond.true.1757, label %cond.false.1759

cond.true.1757:                                   ; preds = %cond.true.1753
  %273 = load i64, i64* %nargs.addr, align 8
  %mul1758 = mul i64 %273, 24
  br label %cond.end.1763

cond.false.1759:                                  ; preds = %cond.true.1753
  %274 = load i64, i64* %nargs.addr, align 8
  %mul1760 = mul i64 %274, 24
  %sub1761 = sub i64 %mul1760, -9223372036854775808
  %add1762 = add nsw i64 %sub1761, -9223372036854775808
  br label %cond.end.1763

cond.end.1763:                                    ; preds = %cond.false.1759, %cond.true.1757
  %cond1764 = phi i64 [ %mul1758, %cond.true.1757 ], [ %add1762, %cond.false.1759 ]
  store i64 %cond1764, i64* %alloca_size, align 8
  br i1 true, label %if.then, label %lor.lhs.false.2164

cond.false.1765:                                  ; preds = %lor.lhs.false.1749
  %275 = load i64, i64* %nargs.addr, align 8
  %mul1766 = mul i64 %275, 24
  %cmp1767 = icmp ule i64 %mul1766, 9223372036854775807
  br i1 %cmp1767, label %cond.true.1769, label %cond.false.1771

cond.true.1769:                                   ; preds = %cond.false.1765
  %276 = load i64, i64* %nargs.addr, align 8
  %mul1770 = mul i64 %276, 24
  br label %cond.end.1775

cond.false.1771:                                  ; preds = %cond.false.1765
  %277 = load i64, i64* %nargs.addr, align 8
  %mul1772 = mul i64 %277, 24
  %sub1773 = sub i64 %mul1772, -9223372036854775808
  %add1774 = add nsw i64 %sub1773, -9223372036854775808
  br label %cond.end.1775

cond.end.1775:                                    ; preds = %cond.false.1771, %cond.true.1769
  %cond1776 = phi i64 [ %mul1770, %cond.true.1769 ], [ %add1774, %cond.false.1771 ]
  store i64 %cond1776, i64* %alloca_size, align 8
  br i1 false, label %if.then, label %lor.lhs.false.2164

cond.false.1777:                                  ; preds = %cond.false.1389
  br i1 false, label %cond.true.1778, label %cond.false.1971

cond.true.1778:                                   ; preds = %cond.false.1777
  %278 = load i64, i64* %nargs.addr, align 8
  %add1779 = add nsw i64 0, %278
  %mul1780 = mul nsw i64 0, %add1779
  %sub1781 = sub nsw i64 %mul1780, 1
  %cmp1782 = icmp slt i64 %sub1781, 0
  br i1 %cmp1782, label %cond.true.1784, label %cond.false.1801

cond.true.1784:                                   ; preds = %cond.true.1778
  %279 = load i64, i64* %nargs.addr, align 8
  %add1785 = add nsw i64 0, %279
  %mul1786 = mul nsw i64 0, %add1785
  %add1787 = add nsw i64 %mul1786, 0
  %neg1788 = xor i64 %add1787, -1
  %cmp1789 = icmp eq i64 %neg1788, -1
  %conv1790 = zext i1 %cmp1789 to i32
  %sub1791 = sub nsw i32 0, %conv1790
  %conv1792 = sext i32 %sub1791 to i64
  %280 = load i64, i64* %nargs.addr, align 8
  %add1793 = add nsw i64 0, %280
  %mul1794 = mul nsw i64 0, %add1793
  %add1795 = add nsw i64 %mul1794, 1
  %shl1796 = shl i64 %add1795, 62
  %sub1797 = sub nsw i64 %shl1796, 1
  %mul1798 = mul nsw i64 %sub1797, 2
  %add1799 = add nsw i64 %mul1798, 1
  %sub1800 = sub nsw i64 %conv1792, %add1799
  br label %cond.end.1805

cond.false.1801:                                  ; preds = %cond.true.1778
  %281 = load i64, i64* %nargs.addr, align 8
  %add1802 = add nsw i64 0, %281
  %mul1803 = mul nsw i64 0, %add1802
  %add1804 = add nsw i64 %mul1803, 0
  br label %cond.end.1805

cond.end.1805:                                    ; preds = %cond.false.1801, %cond.true.1784
  %cond1806 = phi i64 [ %sub1800, %cond.true.1784 ], [ %add1804, %cond.false.1801 ]
  %cmp1807 = icmp eq i64 %cond1806, 0
  br i1 %cmp1807, label %land.lhs.true.1809, label %lor.lhs.false.1812

land.lhs.true.1809:                               ; preds = %cond.end.1805
  %282 = load i64, i64* %nargs.addr, align 8
  %cmp1810 = icmp slt i64 %282, 0
  br i1 %cmp1810, label %cond.true.1947, label %lor.lhs.false.1812

lor.lhs.false.1812:                               ; preds = %land.lhs.true.1809, %cond.end.1805
  br i1 false, label %cond.true.1813, label %cond.false.1873

cond.true.1813:                                   ; preds = %lor.lhs.false.1812
  %283 = load i64, i64* %nargs.addr, align 8
  %cmp1814 = icmp slt i64 %283, 0
  br i1 %cmp1814, label %cond.true.1816, label %cond.false.1839

cond.true.1816:                                   ; preds = %cond.true.1813
  %284 = load i64, i64* %nargs.addr, align 8
  %285 = load i64, i64* %nargs.addr, align 8
  %add1817 = add nsw i64 0, %285
  %mul1818 = mul nsw i64 0, %add1817
  %sub1819 = sub nsw i64 %mul1818, 1
  %cmp1820 = icmp slt i64 %sub1819, 0
  br i1 %cmp1820, label %cond.true.1822, label %cond.false.1830

cond.true.1822:                                   ; preds = %cond.true.1816
  %286 = load i64, i64* %nargs.addr, align 8
  %add1823 = add nsw i64 0, %286
  %mul1824 = mul nsw i64 0, %add1823
  %add1825 = add nsw i64 %mul1824, 1
  %shl1826 = shl i64 %add1825, 62
  %sub1827 = sub nsw i64 %shl1826, 1
  %mul1828 = mul nsw i64 %sub1827, 2
  %add1829 = add nsw i64 %mul1828, 1
  br label %cond.end.1834

cond.false.1830:                                  ; preds = %cond.true.1816
  %287 = load i64, i64* %nargs.addr, align 8
  %add1831 = add nsw i64 0, %287
  %mul1832 = mul nsw i64 0, %add1831
  %sub1833 = sub nsw i64 %mul1832, 1
  br label %cond.end.1834

cond.end.1834:                                    ; preds = %cond.false.1830, %cond.true.1822
  %cond1835 = phi i64 [ %add1829, %cond.true.1822 ], [ %sub1833, %cond.false.1830 ]
  %div1836 = sdiv i64 %cond1835, 24
  %cmp1837 = icmp slt i64 %284, %div1836
  br i1 %cmp1837, label %cond.true.1947, label %lor.lhs.false.1933

cond.false.1839:                                  ; preds = %cond.true.1813
  br i1 false, label %cond.true.1840, label %cond.false.1841

cond.true.1840:                                   ; preds = %cond.false.1839
  br i1 false, label %cond.true.1947, label %lor.lhs.false.1933

cond.false.1841:                                  ; preds = %cond.false.1839
  %288 = load i64, i64* %nargs.addr, align 8
  %add1842 = add nsw i64 0, %288
  %mul1843 = mul nsw i64 0, %add1842
  %sub1844 = sub nsw i64 %mul1843, 1
  %cmp1845 = icmp slt i64 %sub1844, 0
  br i1 %cmp1845, label %cond.true.1847, label %cond.false.1864

cond.true.1847:                                   ; preds = %cond.false.1841
  %289 = load i64, i64* %nargs.addr, align 8
  %add1848 = add nsw i64 0, %289
  %mul1849 = mul nsw i64 0, %add1848
  %add1850 = add nsw i64 %mul1849, 0
  %neg1851 = xor i64 %add1850, -1
  %cmp1852 = icmp eq i64 %neg1851, -1
  %conv1853 = zext i1 %cmp1852 to i32
  %sub1854 = sub nsw i32 0, %conv1853
  %conv1855 = sext i32 %sub1854 to i64
  %290 = load i64, i64* %nargs.addr, align 8
  %add1856 = add nsw i64 0, %290
  %mul1857 = mul nsw i64 0, %add1856
  %add1858 = add nsw i64 %mul1857, 1
  %shl1859 = shl i64 %add1858, 62
  %sub1860 = sub nsw i64 %shl1859, 1
  %mul1861 = mul nsw i64 %sub1860, 2
  %add1862 = add nsw i64 %mul1861, 1
  %sub1863 = sub nsw i64 %conv1855, %add1862
  br label %cond.end.1868

cond.false.1864:                                  ; preds = %cond.false.1841
  %291 = load i64, i64* %nargs.addr, align 8
  %add1865 = add nsw i64 0, %291
  %mul1866 = mul nsw i64 0, %add1865
  %add1867 = add nsw i64 %mul1866, 0
  br label %cond.end.1868

cond.end.1868:                                    ; preds = %cond.false.1864, %cond.true.1847
  %cond1869 = phi i64 [ %sub1863, %cond.true.1847 ], [ %add1867, %cond.false.1864 ]
  %div1870 = sdiv i64 %cond1869, 24
  %292 = load i64, i64* %nargs.addr, align 8
  %cmp1871 = icmp slt i64 %div1870, %292
  br i1 %cmp1871, label %cond.true.1947, label %lor.lhs.false.1933

cond.false.1873:                                  ; preds = %lor.lhs.false.1812
  br i1 false, label %cond.true.1874, label %cond.false.1875

cond.true.1874:                                   ; preds = %cond.false.1873
  br i1 false, label %cond.true.1947, label %lor.lhs.false.1933

cond.false.1875:                                  ; preds = %cond.false.1873
  %293 = load i64, i64* %nargs.addr, align 8
  %cmp1876 = icmp slt i64 %293, 0
  br i1 %cmp1876, label %cond.true.1878, label %cond.false.1910

cond.true.1878:                                   ; preds = %cond.false.1875
  %294 = load i64, i64* %nargs.addr, align 8
  %295 = load i64, i64* %nargs.addr, align 8
  %add1879 = add nsw i64 0, %295
  %mul1880 = mul nsw i64 0, %add1879
  %sub1881 = sub nsw i64 %mul1880, 1
  %cmp1882 = icmp slt i64 %sub1881, 0
  br i1 %cmp1882, label %cond.true.1884, label %cond.false.1901

cond.true.1884:                                   ; preds = %cond.true.1878
  %296 = load i64, i64* %nargs.addr, align 8
  %add1885 = add nsw i64 0, %296
  %mul1886 = mul nsw i64 0, %add1885
  %add1887 = add nsw i64 %mul1886, 0
  %neg1888 = xor i64 %add1887, -1
  %cmp1889 = icmp eq i64 %neg1888, -1
  %conv1890 = zext i1 %cmp1889 to i32
  %sub1891 = sub nsw i32 0, %conv1890
  %conv1892 = sext i32 %sub1891 to i64
  %297 = load i64, i64* %nargs.addr, align 8
  %add1893 = add nsw i64 0, %297
  %mul1894 = mul nsw i64 0, %add1893
  %add1895 = add nsw i64 %mul1894, 1
  %shl1896 = shl i64 %add1895, 62
  %sub1897 = sub nsw i64 %shl1896, 1
  %mul1898 = mul nsw i64 %sub1897, 2
  %add1899 = add nsw i64 %mul1898, 1
  %sub1900 = sub nsw i64 %conv1892, %add1899
  br label %cond.end.1905

cond.false.1901:                                  ; preds = %cond.true.1878
  %298 = load i64, i64* %nargs.addr, align 8
  %add1902 = add nsw i64 0, %298
  %mul1903 = mul nsw i64 0, %add1902
  %add1904 = add nsw i64 %mul1903, 0
  br label %cond.end.1905

cond.end.1905:                                    ; preds = %cond.false.1901, %cond.true.1884
  %cond1906 = phi i64 [ %sub1900, %cond.true.1884 ], [ %add1904, %cond.false.1901 ]
  %div1907 = sdiv i64 %cond1906, 24
  %cmp1908 = icmp slt i64 %294, %div1907
  br i1 %cmp1908, label %cond.true.1947, label %lor.lhs.false.1933

cond.false.1910:                                  ; preds = %cond.false.1875
  %299 = load i64, i64* %nargs.addr, align 8
  %add1911 = add nsw i64 0, %299
  %mul1912 = mul nsw i64 0, %add1911
  %sub1913 = sub nsw i64 %mul1912, 1
  %cmp1914 = icmp slt i64 %sub1913, 0
  br i1 %cmp1914, label %cond.true.1916, label %cond.false.1924

cond.true.1916:                                   ; preds = %cond.false.1910
  %300 = load i64, i64* %nargs.addr, align 8
  %add1917 = add nsw i64 0, %300
  %mul1918 = mul nsw i64 0, %add1917
  %add1919 = add nsw i64 %mul1918, 1
  %shl1920 = shl i64 %add1919, 62
  %sub1921 = sub nsw i64 %shl1920, 1
  %mul1922 = mul nsw i64 %sub1921, 2
  %add1923 = add nsw i64 %mul1922, 1
  br label %cond.end.1928

cond.false.1924:                                  ; preds = %cond.false.1910
  %301 = load i64, i64* %nargs.addr, align 8
  %add1925 = add nsw i64 0, %301
  %mul1926 = mul nsw i64 0, %add1925
  %sub1927 = sub nsw i64 %mul1926, 1
  br label %cond.end.1928

cond.end.1928:                                    ; preds = %cond.false.1924, %cond.true.1916
  %cond1929 = phi i64 [ %add1923, %cond.true.1916 ], [ %sub1927, %cond.false.1924 ]
  %div1930 = sdiv i64 %cond1929, 24
  %302 = load i64, i64* %nargs.addr, align 8
  %cmp1931 = icmp slt i64 %div1930, %302
  br i1 %cmp1931, label %cond.true.1947, label %lor.lhs.false.1933

lor.lhs.false.1933:                               ; preds = %cond.end.1928, %cond.end.1905, %cond.true.1874, %cond.end.1868, %cond.true.1840, %cond.end.1834
  %303 = load i64, i64* %nargs.addr, align 8
  %mul1934 = mul nsw i64 %303, 24
  %mul1935 = mul nsw i64 0, %mul1934
  %sub1936 = sub nsw i64 %mul1935, 1
  %cmp1937 = icmp slt i64 %sub1936, 0
  br i1 %cmp1937, label %land.lhs.true.1939, label %lor.lhs.false.1943

land.lhs.true.1939:                               ; preds = %lor.lhs.false.1933
  %304 = load i64, i64* %nargs.addr, align 8
  %mul1940 = mul nsw i64 %304, 24
  %cmp1941 = icmp slt i64 %mul1940, -9223372036854775808
  br i1 %cmp1941, label %cond.true.1947, label %lor.lhs.false.1943

lor.lhs.false.1943:                               ; preds = %land.lhs.true.1939, %lor.lhs.false.1933
  %305 = load i64, i64* %nargs.addr, align 8
  %mul1944 = mul nsw i64 %305, 24
  %cmp1945 = icmp slt i64 9223372036854775807, %mul1944
  br i1 %cmp1945, label %cond.true.1947, label %cond.false.1959

cond.true.1947:                                   ; preds = %lor.lhs.false.1943, %land.lhs.true.1939, %cond.end.1928, %cond.end.1905, %cond.true.1874, %cond.end.1868, %cond.true.1840, %cond.end.1834, %land.lhs.true.1809
  %306 = load i64, i64* %nargs.addr, align 8
  %mul1948 = mul i64 %306, 24
  %cmp1949 = icmp ule i64 %mul1948, 9223372036854775807
  br i1 %cmp1949, label %cond.true.1951, label %cond.false.1953

cond.true.1951:                                   ; preds = %cond.true.1947
  %307 = load i64, i64* %nargs.addr, align 8
  %mul1952 = mul i64 %307, 24
  br label %cond.end.1957

cond.false.1953:                                  ; preds = %cond.true.1947
  %308 = load i64, i64* %nargs.addr, align 8
  %mul1954 = mul i64 %308, 24
  %sub1955 = sub i64 %mul1954, -9223372036854775808
  %add1956 = add nsw i64 %sub1955, -9223372036854775808
  br label %cond.end.1957

cond.end.1957:                                    ; preds = %cond.false.1953, %cond.true.1951
  %cond1958 = phi i64 [ %mul1952, %cond.true.1951 ], [ %add1956, %cond.false.1953 ]
  store i64 %cond1958, i64* %alloca_size, align 8
  br i1 true, label %if.then, label %lor.lhs.false.2164

cond.false.1959:                                  ; preds = %lor.lhs.false.1943
  %309 = load i64, i64* %nargs.addr, align 8
  %mul1960 = mul i64 %309, 24
  %cmp1961 = icmp ule i64 %mul1960, 9223372036854775807
  br i1 %cmp1961, label %cond.true.1963, label %cond.false.1965

cond.true.1963:                                   ; preds = %cond.false.1959
  %310 = load i64, i64* %nargs.addr, align 8
  %mul1964 = mul i64 %310, 24
  br label %cond.end.1969

cond.false.1965:                                  ; preds = %cond.false.1959
  %311 = load i64, i64* %nargs.addr, align 8
  %mul1966 = mul i64 %311, 24
  %sub1967 = sub i64 %mul1966, -9223372036854775808
  %add1968 = add nsw i64 %sub1967, -9223372036854775808
  br label %cond.end.1969

cond.end.1969:                                    ; preds = %cond.false.1965, %cond.true.1963
  %cond1970 = phi i64 [ %mul1964, %cond.true.1963 ], [ %add1968, %cond.false.1965 ]
  store i64 %cond1970, i64* %alloca_size, align 8
  br i1 false, label %if.then, label %lor.lhs.false.2164

cond.false.1971:                                  ; preds = %cond.false.1777
  %312 = load i64, i64* %nargs.addr, align 8
  %add1972 = add i64 0, %312
  %mul1973 = mul i64 0, %add1972
  %sub1974 = sub i64 %mul1973, 1
  %cmp1975 = icmp ult i64 %sub1974, 0
  br i1 %cmp1975, label %cond.true.1977, label %cond.false.1994

cond.true.1977:                                   ; preds = %cond.false.1971
  %313 = load i64, i64* %nargs.addr, align 8
  %add1978 = add i64 0, %313
  %mul1979 = mul i64 0, %add1978
  %add1980 = add i64 %mul1979, 0
  %neg1981 = xor i64 %add1980, -1
  %cmp1982 = icmp eq i64 %neg1981, -1
  %conv1983 = zext i1 %cmp1982 to i32
  %sub1984 = sub nsw i32 0, %conv1983
  %conv1985 = sext i32 %sub1984 to i64
  %314 = load i64, i64* %nargs.addr, align 8
  %add1986 = add i64 0, %314
  %mul1987 = mul i64 0, %add1986
  %add1988 = add i64 %mul1987, 1
  %shl1989 = shl i64 %add1988, 62
  %sub1990 = sub i64 %shl1989, 1
  %mul1991 = mul i64 %sub1990, 2
  %add1992 = add i64 %mul1991, 1
  %sub1993 = sub i64 %conv1985, %add1992
  br label %cond.end.1998

cond.false.1994:                                  ; preds = %cond.false.1971
  %315 = load i64, i64* %nargs.addr, align 8
  %add1995 = add i64 0, %315
  %mul1996 = mul i64 0, %add1995
  %add1997 = add i64 %mul1996, 0
  br label %cond.end.1998

cond.end.1998:                                    ; preds = %cond.false.1994, %cond.true.1977
  %cond1999 = phi i64 [ %sub1993, %cond.true.1977 ], [ %add1997, %cond.false.1994 ]
  %cmp2000 = icmp eq i64 %cond1999, 0
  br i1 %cmp2000, label %land.lhs.true.2002, label %lor.lhs.false.2005

land.lhs.true.2002:                               ; preds = %cond.end.1998
  %316 = load i64, i64* %nargs.addr, align 8
  %cmp2003 = icmp slt i64 %316, 0
  br i1 %cmp2003, label %cond.true.2140, label %lor.lhs.false.2005

lor.lhs.false.2005:                               ; preds = %land.lhs.true.2002, %cond.end.1998
  br i1 false, label %cond.true.2006, label %cond.false.2066

cond.true.2006:                                   ; preds = %lor.lhs.false.2005
  %317 = load i64, i64* %nargs.addr, align 8
  %cmp2007 = icmp slt i64 %317, 0
  br i1 %cmp2007, label %cond.true.2009, label %cond.false.2032

cond.true.2009:                                   ; preds = %cond.true.2006
  %318 = load i64, i64* %nargs.addr, align 8
  %319 = load i64, i64* %nargs.addr, align 8
  %add2010 = add i64 0, %319
  %mul2011 = mul i64 0, %add2010
  %sub2012 = sub i64 %mul2011, 1
  %cmp2013 = icmp ult i64 %sub2012, 0
  br i1 %cmp2013, label %cond.true.2015, label %cond.false.2023

cond.true.2015:                                   ; preds = %cond.true.2009
  %320 = load i64, i64* %nargs.addr, align 8
  %add2016 = add i64 0, %320
  %mul2017 = mul i64 0, %add2016
  %add2018 = add i64 %mul2017, 1
  %shl2019 = shl i64 %add2018, 62
  %sub2020 = sub i64 %shl2019, 1
  %mul2021 = mul i64 %sub2020, 2
  %add2022 = add i64 %mul2021, 1
  br label %cond.end.2027

cond.false.2023:                                  ; preds = %cond.true.2009
  %321 = load i64, i64* %nargs.addr, align 8
  %add2024 = add i64 0, %321
  %mul2025 = mul i64 0, %add2024
  %sub2026 = sub i64 %mul2025, 1
  br label %cond.end.2027

cond.end.2027:                                    ; preds = %cond.false.2023, %cond.true.2015
  %cond2028 = phi i64 [ %add2022, %cond.true.2015 ], [ %sub2026, %cond.false.2023 ]
  %div2029 = udiv i64 %cond2028, 24
  %cmp2030 = icmp ult i64 %318, %div2029
  br i1 %cmp2030, label %cond.true.2140, label %lor.lhs.false.2126

cond.false.2032:                                  ; preds = %cond.true.2006
  br i1 false, label %cond.true.2033, label %cond.false.2034

cond.true.2033:                                   ; preds = %cond.false.2032
  br i1 false, label %cond.true.2140, label %lor.lhs.false.2126

cond.false.2034:                                  ; preds = %cond.false.2032
  %322 = load i64, i64* %nargs.addr, align 8
  %add2035 = add i64 0, %322
  %mul2036 = mul i64 0, %add2035
  %sub2037 = sub i64 %mul2036, 1
  %cmp2038 = icmp ult i64 %sub2037, 0
  br i1 %cmp2038, label %cond.true.2040, label %cond.false.2057

cond.true.2040:                                   ; preds = %cond.false.2034
  %323 = load i64, i64* %nargs.addr, align 8
  %add2041 = add i64 0, %323
  %mul2042 = mul i64 0, %add2041
  %add2043 = add i64 %mul2042, 0
  %neg2044 = xor i64 %add2043, -1
  %cmp2045 = icmp eq i64 %neg2044, -1
  %conv2046 = zext i1 %cmp2045 to i32
  %sub2047 = sub nsw i32 0, %conv2046
  %conv2048 = sext i32 %sub2047 to i64
  %324 = load i64, i64* %nargs.addr, align 8
  %add2049 = add i64 0, %324
  %mul2050 = mul i64 0, %add2049
  %add2051 = add i64 %mul2050, 1
  %shl2052 = shl i64 %add2051, 62
  %sub2053 = sub i64 %shl2052, 1
  %mul2054 = mul i64 %sub2053, 2
  %add2055 = add i64 %mul2054, 1
  %sub2056 = sub i64 %conv2048, %add2055
  br label %cond.end.2061

cond.false.2057:                                  ; preds = %cond.false.2034
  %325 = load i64, i64* %nargs.addr, align 8
  %add2058 = add i64 0, %325
  %mul2059 = mul i64 0, %add2058
  %add2060 = add i64 %mul2059, 0
  br label %cond.end.2061

cond.end.2061:                                    ; preds = %cond.false.2057, %cond.true.2040
  %cond2062 = phi i64 [ %sub2056, %cond.true.2040 ], [ %add2060, %cond.false.2057 ]
  %div2063 = udiv i64 %cond2062, 24
  %326 = load i64, i64* %nargs.addr, align 8
  %cmp2064 = icmp ult i64 %div2063, %326
  br i1 %cmp2064, label %cond.true.2140, label %lor.lhs.false.2126

cond.false.2066:                                  ; preds = %lor.lhs.false.2005
  br i1 false, label %cond.true.2067, label %cond.false.2068

cond.true.2067:                                   ; preds = %cond.false.2066
  br i1 false, label %cond.true.2140, label %lor.lhs.false.2126

cond.false.2068:                                  ; preds = %cond.false.2066
  %327 = load i64, i64* %nargs.addr, align 8
  %cmp2069 = icmp slt i64 %327, 0
  br i1 %cmp2069, label %cond.true.2071, label %cond.false.2103

cond.true.2071:                                   ; preds = %cond.false.2068
  %328 = load i64, i64* %nargs.addr, align 8
  %329 = load i64, i64* %nargs.addr, align 8
  %add2072 = add i64 0, %329
  %mul2073 = mul i64 0, %add2072
  %sub2074 = sub i64 %mul2073, 1
  %cmp2075 = icmp ult i64 %sub2074, 0
  br i1 %cmp2075, label %cond.true.2077, label %cond.false.2094

cond.true.2077:                                   ; preds = %cond.true.2071
  %330 = load i64, i64* %nargs.addr, align 8
  %add2078 = add i64 0, %330
  %mul2079 = mul i64 0, %add2078
  %add2080 = add i64 %mul2079, 0
  %neg2081 = xor i64 %add2080, -1
  %cmp2082 = icmp eq i64 %neg2081, -1
  %conv2083 = zext i1 %cmp2082 to i32
  %sub2084 = sub nsw i32 0, %conv2083
  %conv2085 = sext i32 %sub2084 to i64
  %331 = load i64, i64* %nargs.addr, align 8
  %add2086 = add i64 0, %331
  %mul2087 = mul i64 0, %add2086
  %add2088 = add i64 %mul2087, 1
  %shl2089 = shl i64 %add2088, 62
  %sub2090 = sub i64 %shl2089, 1
  %mul2091 = mul i64 %sub2090, 2
  %add2092 = add i64 %mul2091, 1
  %sub2093 = sub i64 %conv2085, %add2092
  br label %cond.end.2098

cond.false.2094:                                  ; preds = %cond.true.2071
  %332 = load i64, i64* %nargs.addr, align 8
  %add2095 = add i64 0, %332
  %mul2096 = mul i64 0, %add2095
  %add2097 = add i64 %mul2096, 0
  br label %cond.end.2098

cond.end.2098:                                    ; preds = %cond.false.2094, %cond.true.2077
  %cond2099 = phi i64 [ %sub2093, %cond.true.2077 ], [ %add2097, %cond.false.2094 ]
  %div2100 = udiv i64 %cond2099, 24
  %cmp2101 = icmp ult i64 %328, %div2100
  br i1 %cmp2101, label %cond.true.2140, label %lor.lhs.false.2126

cond.false.2103:                                  ; preds = %cond.false.2068
  %333 = load i64, i64* %nargs.addr, align 8
  %add2104 = add i64 0, %333
  %mul2105 = mul i64 0, %add2104
  %sub2106 = sub i64 %mul2105, 1
  %cmp2107 = icmp ult i64 %sub2106, 0
  br i1 %cmp2107, label %cond.true.2109, label %cond.false.2117

cond.true.2109:                                   ; preds = %cond.false.2103
  %334 = load i64, i64* %nargs.addr, align 8
  %add2110 = add i64 0, %334
  %mul2111 = mul i64 0, %add2110
  %add2112 = add i64 %mul2111, 1
  %shl2113 = shl i64 %add2112, 62
  %sub2114 = sub i64 %shl2113, 1
  %mul2115 = mul i64 %sub2114, 2
  %add2116 = add i64 %mul2115, 1
  br label %cond.end.2121

cond.false.2117:                                  ; preds = %cond.false.2103
  %335 = load i64, i64* %nargs.addr, align 8
  %add2118 = add i64 0, %335
  %mul2119 = mul i64 0, %add2118
  %sub2120 = sub i64 %mul2119, 1
  br label %cond.end.2121

cond.end.2121:                                    ; preds = %cond.false.2117, %cond.true.2109
  %cond2122 = phi i64 [ %add2116, %cond.true.2109 ], [ %sub2120, %cond.false.2117 ]
  %div2123 = udiv i64 %cond2122, 24
  %336 = load i64, i64* %nargs.addr, align 8
  %cmp2124 = icmp ult i64 %div2123, %336
  br i1 %cmp2124, label %cond.true.2140, label %lor.lhs.false.2126

lor.lhs.false.2126:                               ; preds = %cond.end.2121, %cond.end.2098, %cond.true.2067, %cond.end.2061, %cond.true.2033, %cond.end.2027
  %337 = load i64, i64* %nargs.addr, align 8
  %mul2127 = mul i64 %337, 24
  %mul2128 = mul i64 0, %mul2127
  %sub2129 = sub i64 %mul2128, 1
  %cmp2130 = icmp ult i64 %sub2129, 0
  br i1 %cmp2130, label %land.lhs.true.2132, label %lor.lhs.false.2136

land.lhs.true.2132:                               ; preds = %lor.lhs.false.2126
  %338 = load i64, i64* %nargs.addr, align 8
  %mul2133 = mul i64 %338, 24
  %cmp2134 = icmp ult i64 %mul2133, -9223372036854775808
  br i1 %cmp2134, label %cond.true.2140, label %lor.lhs.false.2136

lor.lhs.false.2136:                               ; preds = %land.lhs.true.2132, %lor.lhs.false.2126
  %339 = load i64, i64* %nargs.addr, align 8
  %mul2137 = mul i64 %339, 24
  %cmp2138 = icmp ult i64 9223372036854775807, %mul2137
  br i1 %cmp2138, label %cond.true.2140, label %cond.false.2152

cond.true.2140:                                   ; preds = %lor.lhs.false.2136, %land.lhs.true.2132, %cond.end.2121, %cond.end.2098, %cond.true.2067, %cond.end.2061, %cond.true.2033, %cond.end.2027, %land.lhs.true.2002
  %340 = load i64, i64* %nargs.addr, align 8
  %mul2141 = mul i64 %340, 24
  %cmp2142 = icmp ule i64 %mul2141, 9223372036854775807
  br i1 %cmp2142, label %cond.true.2144, label %cond.false.2146

cond.true.2144:                                   ; preds = %cond.true.2140
  %341 = load i64, i64* %nargs.addr, align 8
  %mul2145 = mul i64 %341, 24
  br label %cond.end.2150

cond.false.2146:                                  ; preds = %cond.true.2140
  %342 = load i64, i64* %nargs.addr, align 8
  %mul2147 = mul i64 %342, 24
  %sub2148 = sub i64 %mul2147, -9223372036854775808
  %add2149 = add nsw i64 %sub2148, -9223372036854775808
  br label %cond.end.2150

cond.end.2150:                                    ; preds = %cond.false.2146, %cond.true.2144
  %cond2151 = phi i64 [ %mul2145, %cond.true.2144 ], [ %add2149, %cond.false.2146 ]
  store i64 %cond2151, i64* %alloca_size, align 8
  br i1 true, label %if.then, label %lor.lhs.false.2164

cond.false.2152:                                  ; preds = %lor.lhs.false.2136
  %343 = load i64, i64* %nargs.addr, align 8
  %mul2153 = mul i64 %343, 24
  %cmp2154 = icmp ule i64 %mul2153, 9223372036854775807
  br i1 %cmp2154, label %cond.true.2156, label %cond.false.2158

cond.true.2156:                                   ; preds = %cond.false.2152
  %344 = load i64, i64* %nargs.addr, align 8
  %mul2157 = mul i64 %344, 24
  br label %cond.end.2162

cond.false.2158:                                  ; preds = %cond.false.2152
  %345 = load i64, i64* %nargs.addr, align 8
  %mul2159 = mul i64 %345, 24
  %sub2160 = sub i64 %mul2159, -9223372036854775808
  %add2161 = add nsw i64 %sub2160, -9223372036854775808
  br label %cond.end.2162

cond.end.2162:                                    ; preds = %cond.false.2158, %cond.true.2156
  %cond2163 = phi i64 [ %mul2157, %cond.true.2156 ], [ %add2161, %cond.false.2158 ]
  store i64 %cond2163, i64* %alloca_size, align 8
  br i1 false, label %if.then, label %lor.lhs.false.2164

lor.lhs.false.2164:                               ; preds = %cond.end.2162, %cond.end.2150, %cond.end.1969, %cond.end.1957, %cond.end.1775, %cond.end.1763, %cond.end.1582, %cond.end.1570, %cond.end.1386, %cond.end.1370, %cond.end.1185, %cond.end.1169, %cond.end.957, %cond.end.934, %cond.end.742, %cond.end.719, %cond.end.472, %cond.end.449, %cond.end.257, %cond.end.234
  br i1 false, label %cond.true.2165, label %cond.false.2562

cond.true.2165:                                   ; preds = %lor.lhs.false.2164
  br i1 false, label %cond.true.2166, label %cond.false.2386

cond.true.2166:                                   ; preds = %cond.true.2165
  %346 = load i64, i64* %alloca_size, align 8
  %conv2167 = trunc i64 %346 to i8
  %conv2168 = sext i8 %conv2167 to i32
  %mul2169 = mul nsw i32 0, %conv2168
  %add2170 = add nsw i32 %mul2169, 24
  %mul2171 = mul nsw i32 0, %add2170
  %sub2172 = sub nsw i32 %mul2171, 1
  %cmp2173 = icmp slt i32 %sub2172, 0
  br i1 %cmp2173, label %cond.true.2175, label %cond.false.2197

cond.true.2175:                                   ; preds = %cond.true.2166
  %347 = load i64, i64* %alloca_size, align 8
  %conv2176 = trunc i64 %347 to i8
  %conv2177 = sext i8 %conv2176 to i32
  %mul2178 = mul nsw i32 0, %conv2177
  %add2179 = add nsw i32 %mul2178, 24
  %mul2180 = mul nsw i32 0, %add2179
  %add2181 = add nsw i32 %mul2180, 0
  %neg2182 = xor i32 %add2181, -1
  %cmp2183 = icmp eq i32 %neg2182, -1
  %conv2184 = zext i1 %cmp2183 to i32
  %sub2185 = sub nsw i32 0, %conv2184
  %348 = load i64, i64* %alloca_size, align 8
  %conv2186 = trunc i64 %348 to i8
  %conv2187 = sext i8 %conv2186 to i32
  %mul2188 = mul nsw i32 0, %conv2187
  %add2189 = add nsw i32 %mul2188, 24
  %mul2190 = mul nsw i32 0, %add2189
  %add2191 = add nsw i32 %mul2190, 1
  %shl2192 = shl i32 %add2191, 30
  %sub2193 = sub nsw i32 %shl2192, 1
  %mul2194 = mul nsw i32 %sub2193, 2
  %add2195 = add nsw i32 %mul2194, 1
  %sub2196 = sub nsw i32 %sub2185, %add2195
  br label %cond.end.2204

cond.false.2197:                                  ; preds = %cond.true.2166
  %349 = load i64, i64* %alloca_size, align 8
  %conv2198 = trunc i64 %349 to i8
  %conv2199 = sext i8 %conv2198 to i32
  %mul2200 = mul nsw i32 0, %conv2199
  %add2201 = add nsw i32 %mul2200, 24
  %mul2202 = mul nsw i32 0, %add2201
  %add2203 = add nsw i32 %mul2202, 0
  br label %cond.end.2204

cond.end.2204:                                    ; preds = %cond.false.2197, %cond.true.2175
  %cond2205 = phi i32 [ %sub2196, %cond.true.2175 ], [ %add2203, %cond.false.2197 ]
  %cmp2206 = icmp slt i32 %cond2205, 0
  br i1 %cmp2206, label %cond.true.2208, label %cond.false.2292

cond.true.2208:                                   ; preds = %cond.end.2204
  %350 = load i64, i64* %alloca_size, align 8
  %conv2209 = trunc i64 %350 to i8
  %conv2210 = sext i8 %conv2209 to i32
  %cmp2211 = icmp slt i32 %conv2210, 0
  br i1 %cmp2211, label %cond.true.2213, label %cond.false.2258

cond.true.2213:                                   ; preds = %cond.true.2208
  %351 = load i64, i64* %alloca_size, align 8
  %conv2214 = trunc i64 %351 to i8
  %conv2215 = sext i8 %conv2214 to i32
  %mul2216 = mul nsw i32 0, %conv2215
  %add2217 = add nsw i32 %mul2216, 24
  %mul2218 = mul nsw i32 0, %add2217
  %sub2219 = sub nsw i32 %mul2218, 1
  %cmp2220 = icmp slt i32 %sub2219, 0
  br i1 %cmp2220, label %cond.true.2222, label %cond.false.2244

cond.true.2222:                                   ; preds = %cond.true.2213
  %352 = load i64, i64* %alloca_size, align 8
  %conv2223 = trunc i64 %352 to i8
  %conv2224 = sext i8 %conv2223 to i32
  %mul2225 = mul nsw i32 0, %conv2224
  %add2226 = add nsw i32 %mul2225, 24
  %mul2227 = mul nsw i32 0, %add2226
  %add2228 = add nsw i32 %mul2227, 0
  %neg2229 = xor i32 %add2228, -1
  %cmp2230 = icmp eq i32 %neg2229, -1
  %conv2231 = zext i1 %cmp2230 to i32
  %sub2232 = sub nsw i32 0, %conv2231
  %353 = load i64, i64* %alloca_size, align 8
  %conv2233 = trunc i64 %353 to i8
  %conv2234 = sext i8 %conv2233 to i32
  %mul2235 = mul nsw i32 0, %conv2234
  %add2236 = add nsw i32 %mul2235, 24
  %mul2237 = mul nsw i32 0, %add2236
  %add2238 = add nsw i32 %mul2237, 1
  %shl2239 = shl i32 %add2238, 30
  %sub2240 = sub nsw i32 %shl2239, 1
  %mul2241 = mul nsw i32 %sub2240, 2
  %add2242 = add nsw i32 %mul2241, 1
  %sub2243 = sub nsw i32 %sub2232, %add2242
  br label %cond.end.2251

cond.false.2244:                                  ; preds = %cond.true.2213
  %354 = load i64, i64* %alloca_size, align 8
  %conv2245 = trunc i64 %354 to i8
  %conv2246 = sext i8 %conv2245 to i32
  %mul2247 = mul nsw i32 0, %conv2246
  %add2248 = add nsw i32 %mul2247, 24
  %mul2249 = mul nsw i32 0, %add2248
  %add2250 = add nsw i32 %mul2249, 0
  br label %cond.end.2251

cond.end.2251:                                    ; preds = %cond.false.2244, %cond.true.2222
  %cond2252 = phi i32 [ %sub2243, %cond.true.2222 ], [ %add2250, %cond.false.2244 ]
  %355 = load i64, i64* %alloca_size, align 8
  %conv2253 = trunc i64 %355 to i8
  %conv2254 = sext i8 %conv2253 to i32
  %sub2255 = sub nsw i32 %cond2252, %conv2254
  %cmp2256 = icmp slt i32 24, %sub2255
  br i1 %cmp2256, label %cond.true.2340, label %lor.lhs.false.2320

cond.false.2258:                                  ; preds = %cond.true.2208
  %356 = load i64, i64* %alloca_size, align 8
  %conv2259 = trunc i64 %356 to i8
  %conv2260 = sext i8 %conv2259 to i32
  %mul2261 = mul nsw i32 0, %conv2260
  %add2262 = add nsw i32 %mul2261, 24
  %mul2263 = mul nsw i32 0, %add2262
  %sub2264 = sub nsw i32 %mul2263, 1
  %cmp2265 = icmp slt i32 %sub2264, 0
  br i1 %cmp2265, label %cond.true.2267, label %cond.false.2278

cond.true.2267:                                   ; preds = %cond.false.2258
  %357 = load i64, i64* %alloca_size, align 8
  %conv2268 = trunc i64 %357 to i8
  %conv2269 = sext i8 %conv2268 to i32
  %mul2270 = mul nsw i32 0, %conv2269
  %add2271 = add nsw i32 %mul2270, 24
  %mul2272 = mul nsw i32 0, %add2271
  %add2273 = add nsw i32 %mul2272, 1
  %shl2274 = shl i32 %add2273, 30
  %sub2275 = sub nsw i32 %shl2274, 1
  %mul2276 = mul nsw i32 %sub2275, 2
  %add2277 = add nsw i32 %mul2276, 1
  br label %cond.end.2285

cond.false.2278:                                  ; preds = %cond.false.2258
  %358 = load i64, i64* %alloca_size, align 8
  %conv2279 = trunc i64 %358 to i8
  %conv2280 = sext i8 %conv2279 to i32
  %mul2281 = mul nsw i32 0, %conv2280
  %add2282 = add nsw i32 %mul2281, 24
  %mul2283 = mul nsw i32 0, %add2282
  %sub2284 = sub nsw i32 %mul2283, 1
  br label %cond.end.2285

cond.end.2285:                                    ; preds = %cond.false.2278, %cond.true.2267
  %cond2286 = phi i32 [ %add2277, %cond.true.2267 ], [ %sub2284, %cond.false.2278 ]
  %359 = load i64, i64* %alloca_size, align 8
  %conv2287 = trunc i64 %359 to i8
  %conv2288 = sext i8 %conv2287 to i32
  %sub2289 = sub nsw i32 %cond2286, %conv2288
  %cmp2290 = icmp slt i32 %sub2289, 24
  br i1 %cmp2290, label %cond.true.2340, label %lor.lhs.false.2320

cond.false.2292:                                  ; preds = %cond.end.2204
  br i1 false, label %cond.true.2293, label %cond.false.2301

cond.true.2293:                                   ; preds = %cond.false.2292
  %360 = load i64, i64* %alloca_size, align 8
  %conv2294 = trunc i64 %360 to i8
  %conv2295 = sext i8 %conv2294 to i32
  %361 = load i64, i64* %alloca_size, align 8
  %conv2296 = trunc i64 %361 to i8
  %conv2297 = sext i8 %conv2296 to i32
  %add2298 = add nsw i32 24, %conv2297
  %cmp2299 = icmp sle i32 %conv2295, %add2298
  br i1 %cmp2299, label %cond.true.2340, label %lor.lhs.false.2320

cond.false.2301:                                  ; preds = %cond.false.2292
  %362 = load i64, i64* %alloca_size, align 8
  %conv2302 = trunc i64 %362 to i8
  %conv2303 = sext i8 %conv2302 to i32
  %cmp2304 = icmp slt i32 %conv2303, 0
  br i1 %cmp2304, label %cond.true.2306, label %cond.false.2312

cond.true.2306:                                   ; preds = %cond.false.2301
  %363 = load i64, i64* %alloca_size, align 8
  %conv2307 = trunc i64 %363 to i8
  %conv2308 = sext i8 %conv2307 to i32
  %add2309 = add nsw i32 24, %conv2308
  %cmp2310 = icmp sle i32 24, %add2309
  br i1 %cmp2310, label %cond.true.2340, label %lor.lhs.false.2320

cond.false.2312:                                  ; preds = %cond.false.2301
  %364 = load i64, i64* %alloca_size, align 8
  %conv2313 = trunc i64 %364 to i8
  %conv2314 = sext i8 %conv2313 to i32
  %add2315 = add nsw i32 24, %conv2314
  %365 = load i64, i64* %alloca_size, align 8
  %conv2316 = trunc i64 %365 to i8
  %conv2317 = sext i8 %conv2316 to i32
  %cmp2318 = icmp slt i32 %add2315, %conv2317
  br i1 %cmp2318, label %cond.true.2340, label %lor.lhs.false.2320

lor.lhs.false.2320:                               ; preds = %cond.false.2312, %cond.true.2306, %cond.true.2293, %cond.end.2285, %cond.end.2251
  %366 = load i64, i64* %alloca_size, align 8
  %conv2321 = trunc i64 %366 to i8
  %conv2322 = sext i8 %conv2321 to i32
  %add2323 = add nsw i32 24, %conv2322
  %mul2324 = mul nsw i32 0, %add2323
  %sub2325 = sub nsw i32 %mul2324, 1
  %cmp2326 = icmp slt i32 %sub2325, 0
  br i1 %cmp2326, label %land.lhs.true.2328, label %lor.lhs.false.2334

land.lhs.true.2328:                               ; preds = %lor.lhs.false.2320
  %367 = load i64, i64* %alloca_size, align 8
  %conv2329 = trunc i64 %367 to i8
  %conv2330 = sext i8 %conv2329 to i32
  %add2331 = add nsw i32 24, %conv2330
  %cmp2332 = icmp slt i32 %add2331, -128
  br i1 %cmp2332, label %cond.true.2340, label %lor.lhs.false.2334

lor.lhs.false.2334:                               ; preds = %land.lhs.true.2328, %lor.lhs.false.2320
  %368 = load i64, i64* %alloca_size, align 8
  %conv2335 = trunc i64 %368 to i8
  %conv2336 = sext i8 %conv2335 to i32
  %add2337 = add nsw i32 24, %conv2336
  %cmp2338 = icmp slt i32 127, %add2337
  br i1 %cmp2338, label %cond.true.2340, label %cond.false.2363

cond.true.2340:                                   ; preds = %lor.lhs.false.2334, %land.lhs.true.2328, %cond.false.2312, %cond.true.2306, %cond.true.2293, %cond.end.2285, %cond.end.2251
  %369 = load i64, i64* %alloca_size, align 8
  %conv2341 = trunc i64 %369 to i8
  %conv2342 = zext i8 %conv2341 to i32
  %add2343 = add nsw i32 24, %conv2342
  %cmp2344 = icmp sle i32 %add2343, 127
  br i1 %cmp2344, label %cond.true.2346, label %cond.false.2352

cond.true.2346:                                   ; preds = %cond.true.2340
  %370 = load i64, i64* %alloca_size, align 8
  %conv2347 = trunc i64 %370 to i8
  %conv2348 = zext i8 %conv2347 to i32
  %add2349 = add nsw i32 24, %conv2348
  %conv2350 = trunc i32 %add2349 to i8
  %conv2351 = sext i8 %conv2350 to i32
  br label %cond.end.2360

cond.false.2352:                                  ; preds = %cond.true.2340
  %371 = load i64, i64* %alloca_size, align 8
  %conv2353 = trunc i64 %371 to i8
  %conv2354 = zext i8 %conv2353 to i32
  %add2355 = add nsw i32 24, %conv2354
  %sub2356 = sub nsw i32 %add2355, -128
  %conv2357 = trunc i32 %sub2356 to i8
  %conv2358 = sext i8 %conv2357 to i32
  %add2359 = add nsw i32 %conv2358, -128
  br label %cond.end.2360

cond.end.2360:                                    ; preds = %cond.false.2352, %cond.true.2346
  %cond2361 = phi i32 [ %conv2351, %cond.true.2346 ], [ %add2359, %cond.false.2352 ]
  %conv2362 = sext i32 %cond2361 to i64
  store i64 %conv2362, i64* %alloca_size, align 8
  br i1 true, label %if.then, label %lor.lhs.false.3926

cond.false.2363:                                  ; preds = %lor.lhs.false.2334
  %372 = load i64, i64* %alloca_size, align 8
  %conv2364 = trunc i64 %372 to i8
  %conv2365 = zext i8 %conv2364 to i32
  %add2366 = add nsw i32 24, %conv2365
  %cmp2367 = icmp sle i32 %add2366, 127
  br i1 %cmp2367, label %cond.true.2369, label %cond.false.2375

cond.true.2369:                                   ; preds = %cond.false.2363
  %373 = load i64, i64* %alloca_size, align 8
  %conv2370 = trunc i64 %373 to i8
  %conv2371 = zext i8 %conv2370 to i32
  %add2372 = add nsw i32 24, %conv2371
  %conv2373 = trunc i32 %add2372 to i8
  %conv2374 = sext i8 %conv2373 to i32
  br label %cond.end.2383

cond.false.2375:                                  ; preds = %cond.false.2363
  %374 = load i64, i64* %alloca_size, align 8
  %conv2376 = trunc i64 %374 to i8
  %conv2377 = zext i8 %conv2376 to i32
  %add2378 = add nsw i32 24, %conv2377
  %sub2379 = sub nsw i32 %add2378, -128
  %conv2380 = trunc i32 %sub2379 to i8
  %conv2381 = sext i8 %conv2380 to i32
  %add2382 = add nsw i32 %conv2381, -128
  br label %cond.end.2383

cond.end.2383:                                    ; preds = %cond.false.2375, %cond.true.2369
  %cond2384 = phi i32 [ %conv2374, %cond.true.2369 ], [ %add2382, %cond.false.2375 ]
  %conv2385 = sext i32 %cond2384 to i64
  store i64 %conv2385, i64* %alloca_size, align 8
  br i1 false, label %if.then, label %lor.lhs.false.3926

cond.false.2386:                                  ; preds = %cond.true.2165
  %375 = load i64, i64* %alloca_size, align 8
  %mul2387 = mul nsw i64 0, %375
  %add2388 = add i64 %mul2387, 24
  %mul2389 = mul i64 0, %add2388
  %sub2390 = sub i64 %mul2389, 1
  %cmp2391 = icmp ult i64 %sub2390, 0
  br i1 %cmp2391, label %cond.true.2393, label %cond.false.2412

cond.true.2393:                                   ; preds = %cond.false.2386
  %376 = load i64, i64* %alloca_size, align 8
  %mul2394 = mul nsw i64 0, %376
  %add2395 = add i64 %mul2394, 24
  %mul2396 = mul i64 0, %add2395
  %add2397 = add i64 %mul2396, 0
  %neg2398 = xor i64 %add2397, -1
  %cmp2399 = icmp eq i64 %neg2398, -1
  %conv2400 = zext i1 %cmp2399 to i32
  %sub2401 = sub nsw i32 0, %conv2400
  %conv2402 = sext i32 %sub2401 to i64
  %377 = load i64, i64* %alloca_size, align 8
  %mul2403 = mul nsw i64 0, %377
  %add2404 = add i64 %mul2403, 24
  %mul2405 = mul i64 0, %add2404
  %add2406 = add i64 %mul2405, 1
  %shl2407 = shl i64 %add2406, 62
  %sub2408 = sub i64 %shl2407, 1
  %mul2409 = mul i64 %sub2408, 2
  %add2410 = add i64 %mul2409, 1
  %sub2411 = sub i64 %conv2402, %add2410
  br label %cond.end.2417

cond.false.2412:                                  ; preds = %cond.false.2386
  %378 = load i64, i64* %alloca_size, align 8
  %mul2413 = mul nsw i64 0, %378
  %add2414 = add i64 %mul2413, 24
  %mul2415 = mul i64 0, %add2414
  %add2416 = add i64 %mul2415, 0
  br label %cond.end.2417

cond.end.2417:                                    ; preds = %cond.false.2412, %cond.true.2393
  %cond2418 = phi i64 [ %sub2411, %cond.true.2393 ], [ %add2416, %cond.false.2412 ]
  %cmp2419 = icmp ult i64 %cond2418, 0
  br i1 %cmp2419, label %cond.true.2421, label %cond.false.2486

cond.true.2421:                                   ; preds = %cond.end.2417
  %379 = load i64, i64* %alloca_size, align 8
  %cmp2422 = icmp slt i64 %379, 0
  br i1 %cmp2422, label %cond.true.2424, label %cond.false.2460

cond.true.2424:                                   ; preds = %cond.true.2421
  %380 = load i64, i64* %alloca_size, align 8
  %mul2425 = mul nsw i64 0, %380
  %add2426 = add i64 %mul2425, 24
  %mul2427 = mul i64 0, %add2426
  %sub2428 = sub i64 %mul2427, 1
  %cmp2429 = icmp ult i64 %sub2428, 0
  br i1 %cmp2429, label %cond.true.2431, label %cond.false.2450

cond.true.2431:                                   ; preds = %cond.true.2424
  %381 = load i64, i64* %alloca_size, align 8
  %mul2432 = mul nsw i64 0, %381
  %add2433 = add i64 %mul2432, 24
  %mul2434 = mul i64 0, %add2433
  %add2435 = add i64 %mul2434, 0
  %neg2436 = xor i64 %add2435, -1
  %cmp2437 = icmp eq i64 %neg2436, -1
  %conv2438 = zext i1 %cmp2437 to i32
  %sub2439 = sub nsw i32 0, %conv2438
  %conv2440 = sext i32 %sub2439 to i64
  %382 = load i64, i64* %alloca_size, align 8
  %mul2441 = mul nsw i64 0, %382
  %add2442 = add i64 %mul2441, 24
  %mul2443 = mul i64 0, %add2442
  %add2444 = add i64 %mul2443, 1
  %shl2445 = shl i64 %add2444, 62
  %sub2446 = sub i64 %shl2445, 1
  %mul2447 = mul i64 %sub2446, 2
  %add2448 = add i64 %mul2447, 1
  %sub2449 = sub i64 %conv2440, %add2448
  br label %cond.end.2455

cond.false.2450:                                  ; preds = %cond.true.2424
  %383 = load i64, i64* %alloca_size, align 8
  %mul2451 = mul nsw i64 0, %383
  %add2452 = add i64 %mul2451, 24
  %mul2453 = mul i64 0, %add2452
  %add2454 = add i64 %mul2453, 0
  br label %cond.end.2455

cond.end.2455:                                    ; preds = %cond.false.2450, %cond.true.2431
  %cond2456 = phi i64 [ %sub2449, %cond.true.2431 ], [ %add2454, %cond.false.2450 ]
  %384 = load i64, i64* %alloca_size, align 8
  %sub2457 = sub i64 %cond2456, %384
  %cmp2458 = icmp ult i64 24, %sub2457
  br i1 %cmp2458, label %cond.true.2516, label %lor.lhs.false.2502

cond.false.2460:                                  ; preds = %cond.true.2421
  %385 = load i64, i64* %alloca_size, align 8
  %mul2461 = mul nsw i64 0, %385
  %add2462 = add i64 %mul2461, 24
  %mul2463 = mul i64 0, %add2462
  %sub2464 = sub i64 %mul2463, 1
  %cmp2465 = icmp ult i64 %sub2464, 0
  br i1 %cmp2465, label %cond.true.2467, label %cond.false.2476

cond.true.2467:                                   ; preds = %cond.false.2460
  %386 = load i64, i64* %alloca_size, align 8
  %mul2468 = mul nsw i64 0, %386
  %add2469 = add i64 %mul2468, 24
  %mul2470 = mul i64 0, %add2469
  %add2471 = add i64 %mul2470, 1
  %shl2472 = shl i64 %add2471, 62
  %sub2473 = sub i64 %shl2472, 1
  %mul2474 = mul i64 %sub2473, 2
  %add2475 = add i64 %mul2474, 1
  br label %cond.end.2481

cond.false.2476:                                  ; preds = %cond.false.2460
  %387 = load i64, i64* %alloca_size, align 8
  %mul2477 = mul nsw i64 0, %387
  %add2478 = add i64 %mul2477, 24
  %mul2479 = mul i64 0, %add2478
  %sub2480 = sub i64 %mul2479, 1
  br label %cond.end.2481

cond.end.2481:                                    ; preds = %cond.false.2476, %cond.true.2467
  %cond2482 = phi i64 [ %add2475, %cond.true.2467 ], [ %sub2480, %cond.false.2476 ]
  %388 = load i64, i64* %alloca_size, align 8
  %sub2483 = sub i64 %cond2482, %388
  %cmp2484 = icmp ult i64 %sub2483, 24
  br i1 %cmp2484, label %cond.true.2516, label %lor.lhs.false.2502

cond.false.2486:                                  ; preds = %cond.end.2417
  br i1 false, label %cond.true.2487, label %cond.false.2491

cond.true.2487:                                   ; preds = %cond.false.2486
  %389 = load i64, i64* %alloca_size, align 8
  %390 = load i64, i64* %alloca_size, align 8
  %add2488 = add i64 24, %390
  %cmp2489 = icmp ule i64 %389, %add2488
  br i1 %cmp2489, label %cond.true.2516, label %lor.lhs.false.2502

cond.false.2491:                                  ; preds = %cond.false.2486
  %391 = load i64, i64* %alloca_size, align 8
  %cmp2492 = icmp slt i64 %391, 0
  br i1 %cmp2492, label %cond.true.2494, label %cond.false.2498

cond.true.2494:                                   ; preds = %cond.false.2491
  %392 = load i64, i64* %alloca_size, align 8
  %add2495 = add i64 24, %392
  %cmp2496 = icmp ule i64 24, %add2495
  br i1 %cmp2496, label %cond.true.2516, label %lor.lhs.false.2502

cond.false.2498:                                  ; preds = %cond.false.2491
  %393 = load i64, i64* %alloca_size, align 8
  %add2499 = add i64 24, %393
  %394 = load i64, i64* %alloca_size, align 8
  %cmp2500 = icmp ult i64 %add2499, %394
  br i1 %cmp2500, label %cond.true.2516, label %lor.lhs.false.2502

lor.lhs.false.2502:                               ; preds = %cond.false.2498, %cond.true.2494, %cond.true.2487, %cond.end.2481, %cond.end.2455
  %395 = load i64, i64* %alloca_size, align 8
  %add2503 = add i64 24, %395
  %mul2504 = mul i64 0, %add2503
  %sub2505 = sub i64 %mul2504, 1
  %cmp2506 = icmp ult i64 %sub2505, 0
  br i1 %cmp2506, label %land.lhs.true.2508, label %lor.lhs.false.2512

land.lhs.true.2508:                               ; preds = %lor.lhs.false.2502
  %396 = load i64, i64* %alloca_size, align 8
  %add2509 = add i64 24, %396
  %cmp2510 = icmp ult i64 %add2509, -128
  br i1 %cmp2510, label %cond.true.2516, label %lor.lhs.false.2512

lor.lhs.false.2512:                               ; preds = %land.lhs.true.2508, %lor.lhs.false.2502
  %397 = load i64, i64* %alloca_size, align 8
  %add2513 = add i64 24, %397
  %cmp2514 = icmp ult i64 127, %add2513
  br i1 %cmp2514, label %cond.true.2516, label %cond.false.2539

cond.true.2516:                                   ; preds = %lor.lhs.false.2512, %land.lhs.true.2508, %cond.false.2498, %cond.true.2494, %cond.true.2487, %cond.end.2481, %cond.end.2455
  %398 = load i64, i64* %alloca_size, align 8
  %conv2517 = trunc i64 %398 to i8
  %conv2518 = zext i8 %conv2517 to i32
  %add2519 = add nsw i32 24, %conv2518
  %cmp2520 = icmp sle i32 %add2519, 127
  br i1 %cmp2520, label %cond.true.2522, label %cond.false.2528

cond.true.2522:                                   ; preds = %cond.true.2516
  %399 = load i64, i64* %alloca_size, align 8
  %conv2523 = trunc i64 %399 to i8
  %conv2524 = zext i8 %conv2523 to i32
  %add2525 = add nsw i32 24, %conv2524
  %conv2526 = trunc i32 %add2525 to i8
  %conv2527 = sext i8 %conv2526 to i32
  br label %cond.end.2536

cond.false.2528:                                  ; preds = %cond.true.2516
  %400 = load i64, i64* %alloca_size, align 8
  %conv2529 = trunc i64 %400 to i8
  %conv2530 = zext i8 %conv2529 to i32
  %add2531 = add nsw i32 24, %conv2530
  %sub2532 = sub nsw i32 %add2531, -128
  %conv2533 = trunc i32 %sub2532 to i8
  %conv2534 = sext i8 %conv2533 to i32
  %add2535 = add nsw i32 %conv2534, -128
  br label %cond.end.2536

cond.end.2536:                                    ; preds = %cond.false.2528, %cond.true.2522
  %cond2537 = phi i32 [ %conv2527, %cond.true.2522 ], [ %add2535, %cond.false.2528 ]
  %conv2538 = sext i32 %cond2537 to i64
  store i64 %conv2538, i64* %alloca_size, align 8
  br i1 true, label %if.then, label %lor.lhs.false.3926

cond.false.2539:                                  ; preds = %lor.lhs.false.2512
  %401 = load i64, i64* %alloca_size, align 8
  %conv2540 = trunc i64 %401 to i8
  %conv2541 = zext i8 %conv2540 to i32
  %add2542 = add nsw i32 24, %conv2541
  %cmp2543 = icmp sle i32 %add2542, 127
  br i1 %cmp2543, label %cond.true.2545, label %cond.false.2551

cond.true.2545:                                   ; preds = %cond.false.2539
  %402 = load i64, i64* %alloca_size, align 8
  %conv2546 = trunc i64 %402 to i8
  %conv2547 = zext i8 %conv2546 to i32
  %add2548 = add nsw i32 24, %conv2547
  %conv2549 = trunc i32 %add2548 to i8
  %conv2550 = sext i8 %conv2549 to i32
  br label %cond.end.2559

cond.false.2551:                                  ; preds = %cond.false.2539
  %403 = load i64, i64* %alloca_size, align 8
  %conv2552 = trunc i64 %403 to i8
  %conv2553 = zext i8 %conv2552 to i32
  %add2554 = add nsw i32 24, %conv2553
  %sub2555 = sub nsw i32 %add2554, -128
  %conv2556 = trunc i32 %sub2555 to i8
  %conv2557 = sext i8 %conv2556 to i32
  %add2558 = add nsw i32 %conv2557, -128
  br label %cond.end.2559

cond.end.2559:                                    ; preds = %cond.false.2551, %cond.true.2545
  %cond2560 = phi i32 [ %conv2550, %cond.true.2545 ], [ %add2558, %cond.false.2551 ]
  %conv2561 = sext i32 %cond2560 to i64
  store i64 %conv2561, i64* %alloca_size, align 8
  br i1 false, label %if.then, label %lor.lhs.false.3926

cond.false.2562:                                  ; preds = %lor.lhs.false.2164
  br i1 false, label %cond.true.2563, label %cond.false.2960

cond.true.2563:                                   ; preds = %cond.false.2562
  br i1 false, label %cond.true.2564, label %cond.false.2784

cond.true.2564:                                   ; preds = %cond.true.2563
  %404 = load i64, i64* %alloca_size, align 8
  %conv2565 = trunc i64 %404 to i16
  %conv2566 = sext i16 %conv2565 to i32
  %mul2567 = mul nsw i32 0, %conv2566
  %add2568 = add nsw i32 %mul2567, 24
  %mul2569 = mul nsw i32 0, %add2568
  %sub2570 = sub nsw i32 %mul2569, 1
  %cmp2571 = icmp slt i32 %sub2570, 0
  br i1 %cmp2571, label %cond.true.2573, label %cond.false.2595

cond.true.2573:                                   ; preds = %cond.true.2564
  %405 = load i64, i64* %alloca_size, align 8
  %conv2574 = trunc i64 %405 to i16
  %conv2575 = sext i16 %conv2574 to i32
  %mul2576 = mul nsw i32 0, %conv2575
  %add2577 = add nsw i32 %mul2576, 24
  %mul2578 = mul nsw i32 0, %add2577
  %add2579 = add nsw i32 %mul2578, 0
  %neg2580 = xor i32 %add2579, -1
  %cmp2581 = icmp eq i32 %neg2580, -1
  %conv2582 = zext i1 %cmp2581 to i32
  %sub2583 = sub nsw i32 0, %conv2582
  %406 = load i64, i64* %alloca_size, align 8
  %conv2584 = trunc i64 %406 to i16
  %conv2585 = sext i16 %conv2584 to i32
  %mul2586 = mul nsw i32 0, %conv2585
  %add2587 = add nsw i32 %mul2586, 24
  %mul2588 = mul nsw i32 0, %add2587
  %add2589 = add nsw i32 %mul2588, 1
  %shl2590 = shl i32 %add2589, 30
  %sub2591 = sub nsw i32 %shl2590, 1
  %mul2592 = mul nsw i32 %sub2591, 2
  %add2593 = add nsw i32 %mul2592, 1
  %sub2594 = sub nsw i32 %sub2583, %add2593
  br label %cond.end.2602

cond.false.2595:                                  ; preds = %cond.true.2564
  %407 = load i64, i64* %alloca_size, align 8
  %conv2596 = trunc i64 %407 to i16
  %conv2597 = sext i16 %conv2596 to i32
  %mul2598 = mul nsw i32 0, %conv2597
  %add2599 = add nsw i32 %mul2598, 24
  %mul2600 = mul nsw i32 0, %add2599
  %add2601 = add nsw i32 %mul2600, 0
  br label %cond.end.2602

cond.end.2602:                                    ; preds = %cond.false.2595, %cond.true.2573
  %cond2603 = phi i32 [ %sub2594, %cond.true.2573 ], [ %add2601, %cond.false.2595 ]
  %cmp2604 = icmp slt i32 %cond2603, 0
  br i1 %cmp2604, label %cond.true.2606, label %cond.false.2690

cond.true.2606:                                   ; preds = %cond.end.2602
  %408 = load i64, i64* %alloca_size, align 8
  %conv2607 = trunc i64 %408 to i16
  %conv2608 = sext i16 %conv2607 to i32
  %cmp2609 = icmp slt i32 %conv2608, 0
  br i1 %cmp2609, label %cond.true.2611, label %cond.false.2656

cond.true.2611:                                   ; preds = %cond.true.2606
  %409 = load i64, i64* %alloca_size, align 8
  %conv2612 = trunc i64 %409 to i16
  %conv2613 = sext i16 %conv2612 to i32
  %mul2614 = mul nsw i32 0, %conv2613
  %add2615 = add nsw i32 %mul2614, 24
  %mul2616 = mul nsw i32 0, %add2615
  %sub2617 = sub nsw i32 %mul2616, 1
  %cmp2618 = icmp slt i32 %sub2617, 0
  br i1 %cmp2618, label %cond.true.2620, label %cond.false.2642

cond.true.2620:                                   ; preds = %cond.true.2611
  %410 = load i64, i64* %alloca_size, align 8
  %conv2621 = trunc i64 %410 to i16
  %conv2622 = sext i16 %conv2621 to i32
  %mul2623 = mul nsw i32 0, %conv2622
  %add2624 = add nsw i32 %mul2623, 24
  %mul2625 = mul nsw i32 0, %add2624
  %add2626 = add nsw i32 %mul2625, 0
  %neg2627 = xor i32 %add2626, -1
  %cmp2628 = icmp eq i32 %neg2627, -1
  %conv2629 = zext i1 %cmp2628 to i32
  %sub2630 = sub nsw i32 0, %conv2629
  %411 = load i64, i64* %alloca_size, align 8
  %conv2631 = trunc i64 %411 to i16
  %conv2632 = sext i16 %conv2631 to i32
  %mul2633 = mul nsw i32 0, %conv2632
  %add2634 = add nsw i32 %mul2633, 24
  %mul2635 = mul nsw i32 0, %add2634
  %add2636 = add nsw i32 %mul2635, 1
  %shl2637 = shl i32 %add2636, 30
  %sub2638 = sub nsw i32 %shl2637, 1
  %mul2639 = mul nsw i32 %sub2638, 2
  %add2640 = add nsw i32 %mul2639, 1
  %sub2641 = sub nsw i32 %sub2630, %add2640
  br label %cond.end.2649

cond.false.2642:                                  ; preds = %cond.true.2611
  %412 = load i64, i64* %alloca_size, align 8
  %conv2643 = trunc i64 %412 to i16
  %conv2644 = sext i16 %conv2643 to i32
  %mul2645 = mul nsw i32 0, %conv2644
  %add2646 = add nsw i32 %mul2645, 24
  %mul2647 = mul nsw i32 0, %add2646
  %add2648 = add nsw i32 %mul2647, 0
  br label %cond.end.2649

cond.end.2649:                                    ; preds = %cond.false.2642, %cond.true.2620
  %cond2650 = phi i32 [ %sub2641, %cond.true.2620 ], [ %add2648, %cond.false.2642 ]
  %413 = load i64, i64* %alloca_size, align 8
  %conv2651 = trunc i64 %413 to i16
  %conv2652 = sext i16 %conv2651 to i32
  %sub2653 = sub nsw i32 %cond2650, %conv2652
  %cmp2654 = icmp slt i32 24, %sub2653
  br i1 %cmp2654, label %cond.true.2738, label %lor.lhs.false.2718

cond.false.2656:                                  ; preds = %cond.true.2606
  %414 = load i64, i64* %alloca_size, align 8
  %conv2657 = trunc i64 %414 to i16
  %conv2658 = sext i16 %conv2657 to i32
  %mul2659 = mul nsw i32 0, %conv2658
  %add2660 = add nsw i32 %mul2659, 24
  %mul2661 = mul nsw i32 0, %add2660
  %sub2662 = sub nsw i32 %mul2661, 1
  %cmp2663 = icmp slt i32 %sub2662, 0
  br i1 %cmp2663, label %cond.true.2665, label %cond.false.2676

cond.true.2665:                                   ; preds = %cond.false.2656
  %415 = load i64, i64* %alloca_size, align 8
  %conv2666 = trunc i64 %415 to i16
  %conv2667 = sext i16 %conv2666 to i32
  %mul2668 = mul nsw i32 0, %conv2667
  %add2669 = add nsw i32 %mul2668, 24
  %mul2670 = mul nsw i32 0, %add2669
  %add2671 = add nsw i32 %mul2670, 1
  %shl2672 = shl i32 %add2671, 30
  %sub2673 = sub nsw i32 %shl2672, 1
  %mul2674 = mul nsw i32 %sub2673, 2
  %add2675 = add nsw i32 %mul2674, 1
  br label %cond.end.2683

cond.false.2676:                                  ; preds = %cond.false.2656
  %416 = load i64, i64* %alloca_size, align 8
  %conv2677 = trunc i64 %416 to i16
  %conv2678 = sext i16 %conv2677 to i32
  %mul2679 = mul nsw i32 0, %conv2678
  %add2680 = add nsw i32 %mul2679, 24
  %mul2681 = mul nsw i32 0, %add2680
  %sub2682 = sub nsw i32 %mul2681, 1
  br label %cond.end.2683

cond.end.2683:                                    ; preds = %cond.false.2676, %cond.true.2665
  %cond2684 = phi i32 [ %add2675, %cond.true.2665 ], [ %sub2682, %cond.false.2676 ]
  %417 = load i64, i64* %alloca_size, align 8
  %conv2685 = trunc i64 %417 to i16
  %conv2686 = sext i16 %conv2685 to i32
  %sub2687 = sub nsw i32 %cond2684, %conv2686
  %cmp2688 = icmp slt i32 %sub2687, 24
  br i1 %cmp2688, label %cond.true.2738, label %lor.lhs.false.2718

cond.false.2690:                                  ; preds = %cond.end.2602
  br i1 false, label %cond.true.2691, label %cond.false.2699

cond.true.2691:                                   ; preds = %cond.false.2690
  %418 = load i64, i64* %alloca_size, align 8
  %conv2692 = trunc i64 %418 to i16
  %conv2693 = sext i16 %conv2692 to i32
  %419 = load i64, i64* %alloca_size, align 8
  %conv2694 = trunc i64 %419 to i16
  %conv2695 = sext i16 %conv2694 to i32
  %add2696 = add nsw i32 24, %conv2695
  %cmp2697 = icmp sle i32 %conv2693, %add2696
  br i1 %cmp2697, label %cond.true.2738, label %lor.lhs.false.2718

cond.false.2699:                                  ; preds = %cond.false.2690
  %420 = load i64, i64* %alloca_size, align 8
  %conv2700 = trunc i64 %420 to i16
  %conv2701 = sext i16 %conv2700 to i32
  %cmp2702 = icmp slt i32 %conv2701, 0
  br i1 %cmp2702, label %cond.true.2704, label %cond.false.2710

cond.true.2704:                                   ; preds = %cond.false.2699
  %421 = load i64, i64* %alloca_size, align 8
  %conv2705 = trunc i64 %421 to i16
  %conv2706 = sext i16 %conv2705 to i32
  %add2707 = add nsw i32 24, %conv2706
  %cmp2708 = icmp sle i32 24, %add2707
  br i1 %cmp2708, label %cond.true.2738, label %lor.lhs.false.2718

cond.false.2710:                                  ; preds = %cond.false.2699
  %422 = load i64, i64* %alloca_size, align 8
  %conv2711 = trunc i64 %422 to i16
  %conv2712 = sext i16 %conv2711 to i32
  %add2713 = add nsw i32 24, %conv2712
  %423 = load i64, i64* %alloca_size, align 8
  %conv2714 = trunc i64 %423 to i16
  %conv2715 = sext i16 %conv2714 to i32
  %cmp2716 = icmp slt i32 %add2713, %conv2715
  br i1 %cmp2716, label %cond.true.2738, label %lor.lhs.false.2718

lor.lhs.false.2718:                               ; preds = %cond.false.2710, %cond.true.2704, %cond.true.2691, %cond.end.2683, %cond.end.2649
  %424 = load i64, i64* %alloca_size, align 8
  %conv2719 = trunc i64 %424 to i16
  %conv2720 = sext i16 %conv2719 to i32
  %add2721 = add nsw i32 24, %conv2720
  %mul2722 = mul nsw i32 0, %add2721
  %sub2723 = sub nsw i32 %mul2722, 1
  %cmp2724 = icmp slt i32 %sub2723, 0
  br i1 %cmp2724, label %land.lhs.true.2726, label %lor.lhs.false.2732

land.lhs.true.2726:                               ; preds = %lor.lhs.false.2718
  %425 = load i64, i64* %alloca_size, align 8
  %conv2727 = trunc i64 %425 to i16
  %conv2728 = sext i16 %conv2727 to i32
  %add2729 = add nsw i32 24, %conv2728
  %cmp2730 = icmp slt i32 %add2729, -32768
  br i1 %cmp2730, label %cond.true.2738, label %lor.lhs.false.2732

lor.lhs.false.2732:                               ; preds = %land.lhs.true.2726, %lor.lhs.false.2718
  %426 = load i64, i64* %alloca_size, align 8
  %conv2733 = trunc i64 %426 to i16
  %conv2734 = sext i16 %conv2733 to i32
  %add2735 = add nsw i32 24, %conv2734
  %cmp2736 = icmp slt i32 32767, %add2735
  br i1 %cmp2736, label %cond.true.2738, label %cond.false.2761

cond.true.2738:                                   ; preds = %lor.lhs.false.2732, %land.lhs.true.2726, %cond.false.2710, %cond.true.2704, %cond.true.2691, %cond.end.2683, %cond.end.2649
  %427 = load i64, i64* %alloca_size, align 8
  %conv2739 = trunc i64 %427 to i16
  %conv2740 = zext i16 %conv2739 to i32
  %add2741 = add nsw i32 24, %conv2740
  %cmp2742 = icmp sle i32 %add2741, 32767
  br i1 %cmp2742, label %cond.true.2744, label %cond.false.2750

cond.true.2744:                                   ; preds = %cond.true.2738
  %428 = load i64, i64* %alloca_size, align 8
  %conv2745 = trunc i64 %428 to i16
  %conv2746 = zext i16 %conv2745 to i32
  %add2747 = add nsw i32 24, %conv2746
  %conv2748 = trunc i32 %add2747 to i16
  %conv2749 = sext i16 %conv2748 to i32
  br label %cond.end.2758

cond.false.2750:                                  ; preds = %cond.true.2738
  %429 = load i64, i64* %alloca_size, align 8
  %conv2751 = trunc i64 %429 to i16
  %conv2752 = zext i16 %conv2751 to i32
  %add2753 = add nsw i32 24, %conv2752
  %sub2754 = sub nsw i32 %add2753, -32768
  %conv2755 = trunc i32 %sub2754 to i16
  %conv2756 = sext i16 %conv2755 to i32
  %add2757 = add nsw i32 %conv2756, -32768
  br label %cond.end.2758

cond.end.2758:                                    ; preds = %cond.false.2750, %cond.true.2744
  %cond2759 = phi i32 [ %conv2749, %cond.true.2744 ], [ %add2757, %cond.false.2750 ]
  %conv2760 = sext i32 %cond2759 to i64
  store i64 %conv2760, i64* %alloca_size, align 8
  br i1 true, label %if.then, label %lor.lhs.false.3926

cond.false.2761:                                  ; preds = %lor.lhs.false.2732
  %430 = load i64, i64* %alloca_size, align 8
  %conv2762 = trunc i64 %430 to i16
  %conv2763 = zext i16 %conv2762 to i32
  %add2764 = add nsw i32 24, %conv2763
  %cmp2765 = icmp sle i32 %add2764, 32767
  br i1 %cmp2765, label %cond.true.2767, label %cond.false.2773

cond.true.2767:                                   ; preds = %cond.false.2761
  %431 = load i64, i64* %alloca_size, align 8
  %conv2768 = trunc i64 %431 to i16
  %conv2769 = zext i16 %conv2768 to i32
  %add2770 = add nsw i32 24, %conv2769
  %conv2771 = trunc i32 %add2770 to i16
  %conv2772 = sext i16 %conv2771 to i32
  br label %cond.end.2781

cond.false.2773:                                  ; preds = %cond.false.2761
  %432 = load i64, i64* %alloca_size, align 8
  %conv2774 = trunc i64 %432 to i16
  %conv2775 = zext i16 %conv2774 to i32
  %add2776 = add nsw i32 24, %conv2775
  %sub2777 = sub nsw i32 %add2776, -32768
  %conv2778 = trunc i32 %sub2777 to i16
  %conv2779 = sext i16 %conv2778 to i32
  %add2780 = add nsw i32 %conv2779, -32768
  br label %cond.end.2781

cond.end.2781:                                    ; preds = %cond.false.2773, %cond.true.2767
  %cond2782 = phi i32 [ %conv2772, %cond.true.2767 ], [ %add2780, %cond.false.2773 ]
  %conv2783 = sext i32 %cond2782 to i64
  store i64 %conv2783, i64* %alloca_size, align 8
  br i1 false, label %if.then, label %lor.lhs.false.3926

cond.false.2784:                                  ; preds = %cond.true.2563
  %433 = load i64, i64* %alloca_size, align 8
  %mul2785 = mul nsw i64 0, %433
  %add2786 = add i64 %mul2785, 24
  %mul2787 = mul i64 0, %add2786
  %sub2788 = sub i64 %mul2787, 1
  %cmp2789 = icmp ult i64 %sub2788, 0
  br i1 %cmp2789, label %cond.true.2791, label %cond.false.2810

cond.true.2791:                                   ; preds = %cond.false.2784
  %434 = load i64, i64* %alloca_size, align 8
  %mul2792 = mul nsw i64 0, %434
  %add2793 = add i64 %mul2792, 24
  %mul2794 = mul i64 0, %add2793
  %add2795 = add i64 %mul2794, 0
  %neg2796 = xor i64 %add2795, -1
  %cmp2797 = icmp eq i64 %neg2796, -1
  %conv2798 = zext i1 %cmp2797 to i32
  %sub2799 = sub nsw i32 0, %conv2798
  %conv2800 = sext i32 %sub2799 to i64
  %435 = load i64, i64* %alloca_size, align 8
  %mul2801 = mul nsw i64 0, %435
  %add2802 = add i64 %mul2801, 24
  %mul2803 = mul i64 0, %add2802
  %add2804 = add i64 %mul2803, 1
  %shl2805 = shl i64 %add2804, 62
  %sub2806 = sub i64 %shl2805, 1
  %mul2807 = mul i64 %sub2806, 2
  %add2808 = add i64 %mul2807, 1
  %sub2809 = sub i64 %conv2800, %add2808
  br label %cond.end.2815

cond.false.2810:                                  ; preds = %cond.false.2784
  %436 = load i64, i64* %alloca_size, align 8
  %mul2811 = mul nsw i64 0, %436
  %add2812 = add i64 %mul2811, 24
  %mul2813 = mul i64 0, %add2812
  %add2814 = add i64 %mul2813, 0
  br label %cond.end.2815

cond.end.2815:                                    ; preds = %cond.false.2810, %cond.true.2791
  %cond2816 = phi i64 [ %sub2809, %cond.true.2791 ], [ %add2814, %cond.false.2810 ]
  %cmp2817 = icmp ult i64 %cond2816, 0
  br i1 %cmp2817, label %cond.true.2819, label %cond.false.2884

cond.true.2819:                                   ; preds = %cond.end.2815
  %437 = load i64, i64* %alloca_size, align 8
  %cmp2820 = icmp slt i64 %437, 0
  br i1 %cmp2820, label %cond.true.2822, label %cond.false.2858

cond.true.2822:                                   ; preds = %cond.true.2819
  %438 = load i64, i64* %alloca_size, align 8
  %mul2823 = mul nsw i64 0, %438
  %add2824 = add i64 %mul2823, 24
  %mul2825 = mul i64 0, %add2824
  %sub2826 = sub i64 %mul2825, 1
  %cmp2827 = icmp ult i64 %sub2826, 0
  br i1 %cmp2827, label %cond.true.2829, label %cond.false.2848

cond.true.2829:                                   ; preds = %cond.true.2822
  %439 = load i64, i64* %alloca_size, align 8
  %mul2830 = mul nsw i64 0, %439
  %add2831 = add i64 %mul2830, 24
  %mul2832 = mul i64 0, %add2831
  %add2833 = add i64 %mul2832, 0
  %neg2834 = xor i64 %add2833, -1
  %cmp2835 = icmp eq i64 %neg2834, -1
  %conv2836 = zext i1 %cmp2835 to i32
  %sub2837 = sub nsw i32 0, %conv2836
  %conv2838 = sext i32 %sub2837 to i64
  %440 = load i64, i64* %alloca_size, align 8
  %mul2839 = mul nsw i64 0, %440
  %add2840 = add i64 %mul2839, 24
  %mul2841 = mul i64 0, %add2840
  %add2842 = add i64 %mul2841, 1
  %shl2843 = shl i64 %add2842, 62
  %sub2844 = sub i64 %shl2843, 1
  %mul2845 = mul i64 %sub2844, 2
  %add2846 = add i64 %mul2845, 1
  %sub2847 = sub i64 %conv2838, %add2846
  br label %cond.end.2853

cond.false.2848:                                  ; preds = %cond.true.2822
  %441 = load i64, i64* %alloca_size, align 8
  %mul2849 = mul nsw i64 0, %441
  %add2850 = add i64 %mul2849, 24
  %mul2851 = mul i64 0, %add2850
  %add2852 = add i64 %mul2851, 0
  br label %cond.end.2853

cond.end.2853:                                    ; preds = %cond.false.2848, %cond.true.2829
  %cond2854 = phi i64 [ %sub2847, %cond.true.2829 ], [ %add2852, %cond.false.2848 ]
  %442 = load i64, i64* %alloca_size, align 8
  %sub2855 = sub i64 %cond2854, %442
  %cmp2856 = icmp ult i64 24, %sub2855
  br i1 %cmp2856, label %cond.true.2914, label %lor.lhs.false.2900

cond.false.2858:                                  ; preds = %cond.true.2819
  %443 = load i64, i64* %alloca_size, align 8
  %mul2859 = mul nsw i64 0, %443
  %add2860 = add i64 %mul2859, 24
  %mul2861 = mul i64 0, %add2860
  %sub2862 = sub i64 %mul2861, 1
  %cmp2863 = icmp ult i64 %sub2862, 0
  br i1 %cmp2863, label %cond.true.2865, label %cond.false.2874

cond.true.2865:                                   ; preds = %cond.false.2858
  %444 = load i64, i64* %alloca_size, align 8
  %mul2866 = mul nsw i64 0, %444
  %add2867 = add i64 %mul2866, 24
  %mul2868 = mul i64 0, %add2867
  %add2869 = add i64 %mul2868, 1
  %shl2870 = shl i64 %add2869, 62
  %sub2871 = sub i64 %shl2870, 1
  %mul2872 = mul i64 %sub2871, 2
  %add2873 = add i64 %mul2872, 1
  br label %cond.end.2879

cond.false.2874:                                  ; preds = %cond.false.2858
  %445 = load i64, i64* %alloca_size, align 8
  %mul2875 = mul nsw i64 0, %445
  %add2876 = add i64 %mul2875, 24
  %mul2877 = mul i64 0, %add2876
  %sub2878 = sub i64 %mul2877, 1
  br label %cond.end.2879

cond.end.2879:                                    ; preds = %cond.false.2874, %cond.true.2865
  %cond2880 = phi i64 [ %add2873, %cond.true.2865 ], [ %sub2878, %cond.false.2874 ]
  %446 = load i64, i64* %alloca_size, align 8
  %sub2881 = sub i64 %cond2880, %446
  %cmp2882 = icmp ult i64 %sub2881, 24
  br i1 %cmp2882, label %cond.true.2914, label %lor.lhs.false.2900

cond.false.2884:                                  ; preds = %cond.end.2815
  br i1 false, label %cond.true.2885, label %cond.false.2889

cond.true.2885:                                   ; preds = %cond.false.2884
  %447 = load i64, i64* %alloca_size, align 8
  %448 = load i64, i64* %alloca_size, align 8
  %add2886 = add i64 24, %448
  %cmp2887 = icmp ule i64 %447, %add2886
  br i1 %cmp2887, label %cond.true.2914, label %lor.lhs.false.2900

cond.false.2889:                                  ; preds = %cond.false.2884
  %449 = load i64, i64* %alloca_size, align 8
  %cmp2890 = icmp slt i64 %449, 0
  br i1 %cmp2890, label %cond.true.2892, label %cond.false.2896

cond.true.2892:                                   ; preds = %cond.false.2889
  %450 = load i64, i64* %alloca_size, align 8
  %add2893 = add i64 24, %450
  %cmp2894 = icmp ule i64 24, %add2893
  br i1 %cmp2894, label %cond.true.2914, label %lor.lhs.false.2900

cond.false.2896:                                  ; preds = %cond.false.2889
  %451 = load i64, i64* %alloca_size, align 8
  %add2897 = add i64 24, %451
  %452 = load i64, i64* %alloca_size, align 8
  %cmp2898 = icmp ult i64 %add2897, %452
  br i1 %cmp2898, label %cond.true.2914, label %lor.lhs.false.2900

lor.lhs.false.2900:                               ; preds = %cond.false.2896, %cond.true.2892, %cond.true.2885, %cond.end.2879, %cond.end.2853
  %453 = load i64, i64* %alloca_size, align 8
  %add2901 = add i64 24, %453
  %mul2902 = mul i64 0, %add2901
  %sub2903 = sub i64 %mul2902, 1
  %cmp2904 = icmp ult i64 %sub2903, 0
  br i1 %cmp2904, label %land.lhs.true.2906, label %lor.lhs.false.2910

land.lhs.true.2906:                               ; preds = %lor.lhs.false.2900
  %454 = load i64, i64* %alloca_size, align 8
  %add2907 = add i64 24, %454
  %cmp2908 = icmp ult i64 %add2907, -32768
  br i1 %cmp2908, label %cond.true.2914, label %lor.lhs.false.2910

lor.lhs.false.2910:                               ; preds = %land.lhs.true.2906, %lor.lhs.false.2900
  %455 = load i64, i64* %alloca_size, align 8
  %add2911 = add i64 24, %455
  %cmp2912 = icmp ult i64 32767, %add2911
  br i1 %cmp2912, label %cond.true.2914, label %cond.false.2937

cond.true.2914:                                   ; preds = %lor.lhs.false.2910, %land.lhs.true.2906, %cond.false.2896, %cond.true.2892, %cond.true.2885, %cond.end.2879, %cond.end.2853
  %456 = load i64, i64* %alloca_size, align 8
  %conv2915 = trunc i64 %456 to i16
  %conv2916 = zext i16 %conv2915 to i32
  %add2917 = add nsw i32 24, %conv2916
  %cmp2918 = icmp sle i32 %add2917, 32767
  br i1 %cmp2918, label %cond.true.2920, label %cond.false.2926

cond.true.2920:                                   ; preds = %cond.true.2914
  %457 = load i64, i64* %alloca_size, align 8
  %conv2921 = trunc i64 %457 to i16
  %conv2922 = zext i16 %conv2921 to i32
  %add2923 = add nsw i32 24, %conv2922
  %conv2924 = trunc i32 %add2923 to i16
  %conv2925 = sext i16 %conv2924 to i32
  br label %cond.end.2934

cond.false.2926:                                  ; preds = %cond.true.2914
  %458 = load i64, i64* %alloca_size, align 8
  %conv2927 = trunc i64 %458 to i16
  %conv2928 = zext i16 %conv2927 to i32
  %add2929 = add nsw i32 24, %conv2928
  %sub2930 = sub nsw i32 %add2929, -32768
  %conv2931 = trunc i32 %sub2930 to i16
  %conv2932 = sext i16 %conv2931 to i32
  %add2933 = add nsw i32 %conv2932, -32768
  br label %cond.end.2934

cond.end.2934:                                    ; preds = %cond.false.2926, %cond.true.2920
  %cond2935 = phi i32 [ %conv2925, %cond.true.2920 ], [ %add2933, %cond.false.2926 ]
  %conv2936 = sext i32 %cond2935 to i64
  store i64 %conv2936, i64* %alloca_size, align 8
  br i1 true, label %if.then, label %lor.lhs.false.3926

cond.false.2937:                                  ; preds = %lor.lhs.false.2910
  %459 = load i64, i64* %alloca_size, align 8
  %conv2938 = trunc i64 %459 to i16
  %conv2939 = zext i16 %conv2938 to i32
  %add2940 = add nsw i32 24, %conv2939
  %cmp2941 = icmp sle i32 %add2940, 32767
  br i1 %cmp2941, label %cond.true.2943, label %cond.false.2949

cond.true.2943:                                   ; preds = %cond.false.2937
  %460 = load i64, i64* %alloca_size, align 8
  %conv2944 = trunc i64 %460 to i16
  %conv2945 = zext i16 %conv2944 to i32
  %add2946 = add nsw i32 24, %conv2945
  %conv2947 = trunc i32 %add2946 to i16
  %conv2948 = sext i16 %conv2947 to i32
  br label %cond.end.2957

cond.false.2949:                                  ; preds = %cond.false.2937
  %461 = load i64, i64* %alloca_size, align 8
  %conv2950 = trunc i64 %461 to i16
  %conv2951 = zext i16 %conv2950 to i32
  %add2952 = add nsw i32 24, %conv2951
  %sub2953 = sub nsw i32 %add2952, -32768
  %conv2954 = trunc i32 %sub2953 to i16
  %conv2955 = sext i16 %conv2954 to i32
  %add2956 = add nsw i32 %conv2955, -32768
  br label %cond.end.2957

cond.end.2957:                                    ; preds = %cond.false.2949, %cond.true.2943
  %cond2958 = phi i32 [ %conv2948, %cond.true.2943 ], [ %add2956, %cond.false.2949 ]
  %conv2959 = sext i32 %cond2958 to i64
  store i64 %conv2959, i64* %alloca_size, align 8
  br i1 false, label %if.then, label %lor.lhs.false.3926

cond.false.2960:                                  ; preds = %cond.false.2562
  br i1 false, label %cond.true.2961, label %cond.false.3307

cond.true.2961:                                   ; preds = %cond.false.2960
  br i1 false, label %cond.true.2962, label %cond.false.3145

cond.true.2962:                                   ; preds = %cond.true.2961
  %462 = load i64, i64* %alloca_size, align 8
  %conv2963 = trunc i64 %462 to i32
  %mul2964 = mul nsw i32 0, %conv2963
  %add2965 = add nsw i32 %mul2964, 24
  %mul2966 = mul nsw i32 0, %add2965
  %sub2967 = sub nsw i32 %mul2966, 1
  %cmp2968 = icmp slt i32 %sub2967, 0
  br i1 %cmp2968, label %cond.true.2970, label %cond.false.2990

cond.true.2970:                                   ; preds = %cond.true.2962
  %463 = load i64, i64* %alloca_size, align 8
  %conv2971 = trunc i64 %463 to i32
  %mul2972 = mul nsw i32 0, %conv2971
  %add2973 = add nsw i32 %mul2972, 24
  %mul2974 = mul nsw i32 0, %add2973
  %add2975 = add nsw i32 %mul2974, 0
  %neg2976 = xor i32 %add2975, -1
  %cmp2977 = icmp eq i32 %neg2976, -1
  %conv2978 = zext i1 %cmp2977 to i32
  %sub2979 = sub nsw i32 0, %conv2978
  %464 = load i64, i64* %alloca_size, align 8
  %conv2980 = trunc i64 %464 to i32
  %mul2981 = mul nsw i32 0, %conv2980
  %add2982 = add nsw i32 %mul2981, 24
  %mul2983 = mul nsw i32 0, %add2982
  %add2984 = add nsw i32 %mul2983, 1
  %shl2985 = shl i32 %add2984, 30
  %sub2986 = sub nsw i32 %shl2985, 1
  %mul2987 = mul nsw i32 %sub2986, 2
  %add2988 = add nsw i32 %mul2987, 1
  %sub2989 = sub nsw i32 %sub2979, %add2988
  br label %cond.end.2996

cond.false.2990:                                  ; preds = %cond.true.2962
  %465 = load i64, i64* %alloca_size, align 8
  %conv2991 = trunc i64 %465 to i32
  %mul2992 = mul nsw i32 0, %conv2991
  %add2993 = add nsw i32 %mul2992, 24
  %mul2994 = mul nsw i32 0, %add2993
  %add2995 = add nsw i32 %mul2994, 0
  br label %cond.end.2996

cond.end.2996:                                    ; preds = %cond.false.2990, %cond.true.2970
  %cond2997 = phi i32 [ %sub2989, %cond.true.2970 ], [ %add2995, %cond.false.2990 ]
  %cmp2998 = icmp slt i32 %cond2997, 0
  br i1 %cmp2998, label %cond.true.3000, label %cond.false.3074

cond.true.3000:                                   ; preds = %cond.end.2996
  %466 = load i64, i64* %alloca_size, align 8
  %conv3001 = trunc i64 %466 to i32
  %cmp3002 = icmp slt i32 %conv3001, 0
  br i1 %cmp3002, label %cond.true.3004, label %cond.false.3044

cond.true.3004:                                   ; preds = %cond.true.3000
  %467 = load i64, i64* %alloca_size, align 8
  %conv3005 = trunc i64 %467 to i32
  %mul3006 = mul nsw i32 0, %conv3005
  %add3007 = add nsw i32 %mul3006, 24
  %mul3008 = mul nsw i32 0, %add3007
  %sub3009 = sub nsw i32 %mul3008, 1
  %cmp3010 = icmp slt i32 %sub3009, 0
  br i1 %cmp3010, label %cond.true.3012, label %cond.false.3032

cond.true.3012:                                   ; preds = %cond.true.3004
  %468 = load i64, i64* %alloca_size, align 8
  %conv3013 = trunc i64 %468 to i32
  %mul3014 = mul nsw i32 0, %conv3013
  %add3015 = add nsw i32 %mul3014, 24
  %mul3016 = mul nsw i32 0, %add3015
  %add3017 = add nsw i32 %mul3016, 0
  %neg3018 = xor i32 %add3017, -1
  %cmp3019 = icmp eq i32 %neg3018, -1
  %conv3020 = zext i1 %cmp3019 to i32
  %sub3021 = sub nsw i32 0, %conv3020
  %469 = load i64, i64* %alloca_size, align 8
  %conv3022 = trunc i64 %469 to i32
  %mul3023 = mul nsw i32 0, %conv3022
  %add3024 = add nsw i32 %mul3023, 24
  %mul3025 = mul nsw i32 0, %add3024
  %add3026 = add nsw i32 %mul3025, 1
  %shl3027 = shl i32 %add3026, 30
  %sub3028 = sub nsw i32 %shl3027, 1
  %mul3029 = mul nsw i32 %sub3028, 2
  %add3030 = add nsw i32 %mul3029, 1
  %sub3031 = sub nsw i32 %sub3021, %add3030
  br label %cond.end.3038

cond.false.3032:                                  ; preds = %cond.true.3004
  %470 = load i64, i64* %alloca_size, align 8
  %conv3033 = trunc i64 %470 to i32
  %mul3034 = mul nsw i32 0, %conv3033
  %add3035 = add nsw i32 %mul3034, 24
  %mul3036 = mul nsw i32 0, %add3035
  %add3037 = add nsw i32 %mul3036, 0
  br label %cond.end.3038

cond.end.3038:                                    ; preds = %cond.false.3032, %cond.true.3012
  %cond3039 = phi i32 [ %sub3031, %cond.true.3012 ], [ %add3037, %cond.false.3032 ]
  %471 = load i64, i64* %alloca_size, align 8
  %conv3040 = trunc i64 %471 to i32
  %sub3041 = sub nsw i32 %cond3039, %conv3040
  %cmp3042 = icmp slt i32 24, %sub3041
  br i1 %cmp3042, label %cond.true.3113, label %lor.lhs.false.3096

cond.false.3044:                                  ; preds = %cond.true.3000
  %472 = load i64, i64* %alloca_size, align 8
  %conv3045 = trunc i64 %472 to i32
  %mul3046 = mul nsw i32 0, %conv3045
  %add3047 = add nsw i32 %mul3046, 24
  %mul3048 = mul nsw i32 0, %add3047
  %sub3049 = sub nsw i32 %mul3048, 1
  %cmp3050 = icmp slt i32 %sub3049, 0
  br i1 %cmp3050, label %cond.true.3052, label %cond.false.3062

cond.true.3052:                                   ; preds = %cond.false.3044
  %473 = load i64, i64* %alloca_size, align 8
  %conv3053 = trunc i64 %473 to i32
  %mul3054 = mul nsw i32 0, %conv3053
  %add3055 = add nsw i32 %mul3054, 24
  %mul3056 = mul nsw i32 0, %add3055
  %add3057 = add nsw i32 %mul3056, 1
  %shl3058 = shl i32 %add3057, 30
  %sub3059 = sub nsw i32 %shl3058, 1
  %mul3060 = mul nsw i32 %sub3059, 2
  %add3061 = add nsw i32 %mul3060, 1
  br label %cond.end.3068

cond.false.3062:                                  ; preds = %cond.false.3044
  %474 = load i64, i64* %alloca_size, align 8
  %conv3063 = trunc i64 %474 to i32
  %mul3064 = mul nsw i32 0, %conv3063
  %add3065 = add nsw i32 %mul3064, 24
  %mul3066 = mul nsw i32 0, %add3065
  %sub3067 = sub nsw i32 %mul3066, 1
  br label %cond.end.3068

cond.end.3068:                                    ; preds = %cond.false.3062, %cond.true.3052
  %cond3069 = phi i32 [ %add3061, %cond.true.3052 ], [ %sub3067, %cond.false.3062 ]
  %475 = load i64, i64* %alloca_size, align 8
  %conv3070 = trunc i64 %475 to i32
  %sub3071 = sub nsw i32 %cond3069, %conv3070
  %cmp3072 = icmp slt i32 %sub3071, 24
  br i1 %cmp3072, label %cond.true.3113, label %lor.lhs.false.3096

cond.false.3074:                                  ; preds = %cond.end.2996
  br i1 false, label %cond.true.3075, label %cond.false.3081

cond.true.3075:                                   ; preds = %cond.false.3074
  %476 = load i64, i64* %alloca_size, align 8
  %conv3076 = trunc i64 %476 to i32
  %477 = load i64, i64* %alloca_size, align 8
  %conv3077 = trunc i64 %477 to i32
  %add3078 = add nsw i32 24, %conv3077
  %cmp3079 = icmp sle i32 %conv3076, %add3078
  br i1 %cmp3079, label %cond.true.3113, label %lor.lhs.false.3096

cond.false.3081:                                  ; preds = %cond.false.3074
  %478 = load i64, i64* %alloca_size, align 8
  %conv3082 = trunc i64 %478 to i32
  %cmp3083 = icmp slt i32 %conv3082, 0
  br i1 %cmp3083, label %cond.true.3085, label %cond.false.3090

cond.true.3085:                                   ; preds = %cond.false.3081
  %479 = load i64, i64* %alloca_size, align 8
  %conv3086 = trunc i64 %479 to i32
  %add3087 = add nsw i32 24, %conv3086
  %cmp3088 = icmp sle i32 24, %add3087
  br i1 %cmp3088, label %cond.true.3113, label %lor.lhs.false.3096

cond.false.3090:                                  ; preds = %cond.false.3081
  %480 = load i64, i64* %alloca_size, align 8
  %conv3091 = trunc i64 %480 to i32
  %add3092 = add nsw i32 24, %conv3091
  %481 = load i64, i64* %alloca_size, align 8
  %conv3093 = trunc i64 %481 to i32
  %cmp3094 = icmp slt i32 %add3092, %conv3093
  br i1 %cmp3094, label %cond.true.3113, label %lor.lhs.false.3096

lor.lhs.false.3096:                               ; preds = %cond.false.3090, %cond.true.3085, %cond.true.3075, %cond.end.3068, %cond.end.3038
  %482 = load i64, i64* %alloca_size, align 8
  %conv3097 = trunc i64 %482 to i32
  %add3098 = add nsw i32 24, %conv3097
  %mul3099 = mul nsw i32 0, %add3098
  %sub3100 = sub nsw i32 %mul3099, 1
  %cmp3101 = icmp slt i32 %sub3100, 0
  br i1 %cmp3101, label %land.lhs.true.3103, label %lor.lhs.false.3108

land.lhs.true.3103:                               ; preds = %lor.lhs.false.3096
  %483 = load i64, i64* %alloca_size, align 8
  %conv3104 = trunc i64 %483 to i32
  %add3105 = add nsw i32 24, %conv3104
  %cmp3106 = icmp slt i32 %add3105, -2147483648
  br i1 %cmp3106, label %cond.true.3113, label %lor.lhs.false.3108

lor.lhs.false.3108:                               ; preds = %land.lhs.true.3103, %lor.lhs.false.3096
  %484 = load i64, i64* %alloca_size, align 8
  %conv3109 = trunc i64 %484 to i32
  %add3110 = add nsw i32 24, %conv3109
  %cmp3111 = icmp slt i32 2147483647, %add3110
  br i1 %cmp3111, label %cond.true.3113, label %cond.false.3129

cond.true.3113:                                   ; preds = %lor.lhs.false.3108, %land.lhs.true.3103, %cond.false.3090, %cond.true.3085, %cond.true.3075, %cond.end.3068, %cond.end.3038
  %485 = load i64, i64* %alloca_size, align 8
  %conv3114 = trunc i64 %485 to i32
  %add3115 = add i32 24, %conv3114
  %cmp3116 = icmp ule i32 %add3115, 2147483647
  br i1 %cmp3116, label %cond.true.3118, label %cond.false.3121

cond.true.3118:                                   ; preds = %cond.true.3113
  %486 = load i64, i64* %alloca_size, align 8
  %conv3119 = trunc i64 %486 to i32
  %add3120 = add i32 24, %conv3119
  br label %cond.end.3126

cond.false.3121:                                  ; preds = %cond.true.3113
  %487 = load i64, i64* %alloca_size, align 8
  %conv3122 = trunc i64 %487 to i32
  %add3123 = add i32 24, %conv3122
  %sub3124 = sub i32 %add3123, -2147483648
  %add3125 = add nsw i32 %sub3124, -2147483648
  br label %cond.end.3126

cond.end.3126:                                    ; preds = %cond.false.3121, %cond.true.3118
  %cond3127 = phi i32 [ %add3120, %cond.true.3118 ], [ %add3125, %cond.false.3121 ]
  %conv3128 = sext i32 %cond3127 to i64
  store i64 %conv3128, i64* %alloca_size, align 8
  br i1 true, label %if.then, label %lor.lhs.false.3926

cond.false.3129:                                  ; preds = %lor.lhs.false.3108
  %488 = load i64, i64* %alloca_size, align 8
  %conv3130 = trunc i64 %488 to i32
  %add3131 = add i32 24, %conv3130
  %cmp3132 = icmp ule i32 %add3131, 2147483647
  br i1 %cmp3132, label %cond.true.3134, label %cond.false.3137

cond.true.3134:                                   ; preds = %cond.false.3129
  %489 = load i64, i64* %alloca_size, align 8
  %conv3135 = trunc i64 %489 to i32
  %add3136 = add i32 24, %conv3135
  br label %cond.end.3142

cond.false.3137:                                  ; preds = %cond.false.3129
  %490 = load i64, i64* %alloca_size, align 8
  %conv3138 = trunc i64 %490 to i32
  %add3139 = add i32 24, %conv3138
  %sub3140 = sub i32 %add3139, -2147483648
  %add3141 = add nsw i32 %sub3140, -2147483648
  br label %cond.end.3142

cond.end.3142:                                    ; preds = %cond.false.3137, %cond.true.3134
  %cond3143 = phi i32 [ %add3136, %cond.true.3134 ], [ %add3141, %cond.false.3137 ]
  %conv3144 = sext i32 %cond3143 to i64
  store i64 %conv3144, i64* %alloca_size, align 8
  br i1 false, label %if.then, label %lor.lhs.false.3926

cond.false.3145:                                  ; preds = %cond.true.2961
  %491 = load i64, i64* %alloca_size, align 8
  %mul3146 = mul nsw i64 0, %491
  %add3147 = add i64 %mul3146, 24
  %mul3148 = mul i64 0, %add3147
  %sub3149 = sub i64 %mul3148, 1
  %cmp3150 = icmp ult i64 %sub3149, 0
  br i1 %cmp3150, label %cond.true.3152, label %cond.false.3171

cond.true.3152:                                   ; preds = %cond.false.3145
  %492 = load i64, i64* %alloca_size, align 8
  %mul3153 = mul nsw i64 0, %492
  %add3154 = add i64 %mul3153, 24
  %mul3155 = mul i64 0, %add3154
  %add3156 = add i64 %mul3155, 0
  %neg3157 = xor i64 %add3156, -1
  %cmp3158 = icmp eq i64 %neg3157, -1
  %conv3159 = zext i1 %cmp3158 to i32
  %sub3160 = sub nsw i32 0, %conv3159
  %conv3161 = sext i32 %sub3160 to i64
  %493 = load i64, i64* %alloca_size, align 8
  %mul3162 = mul nsw i64 0, %493
  %add3163 = add i64 %mul3162, 24
  %mul3164 = mul i64 0, %add3163
  %add3165 = add i64 %mul3164, 1
  %shl3166 = shl i64 %add3165, 62
  %sub3167 = sub i64 %shl3166, 1
  %mul3168 = mul i64 %sub3167, 2
  %add3169 = add i64 %mul3168, 1
  %sub3170 = sub i64 %conv3161, %add3169
  br label %cond.end.3176

cond.false.3171:                                  ; preds = %cond.false.3145
  %494 = load i64, i64* %alloca_size, align 8
  %mul3172 = mul nsw i64 0, %494
  %add3173 = add i64 %mul3172, 24
  %mul3174 = mul i64 0, %add3173
  %add3175 = add i64 %mul3174, 0
  br label %cond.end.3176

cond.end.3176:                                    ; preds = %cond.false.3171, %cond.true.3152
  %cond3177 = phi i64 [ %sub3170, %cond.true.3152 ], [ %add3175, %cond.false.3171 ]
  %cmp3178 = icmp ult i64 %cond3177, 0
  br i1 %cmp3178, label %cond.true.3180, label %cond.false.3245

cond.true.3180:                                   ; preds = %cond.end.3176
  %495 = load i64, i64* %alloca_size, align 8
  %cmp3181 = icmp slt i64 %495, 0
  br i1 %cmp3181, label %cond.true.3183, label %cond.false.3219

cond.true.3183:                                   ; preds = %cond.true.3180
  %496 = load i64, i64* %alloca_size, align 8
  %mul3184 = mul nsw i64 0, %496
  %add3185 = add i64 %mul3184, 24
  %mul3186 = mul i64 0, %add3185
  %sub3187 = sub i64 %mul3186, 1
  %cmp3188 = icmp ult i64 %sub3187, 0
  br i1 %cmp3188, label %cond.true.3190, label %cond.false.3209

cond.true.3190:                                   ; preds = %cond.true.3183
  %497 = load i64, i64* %alloca_size, align 8
  %mul3191 = mul nsw i64 0, %497
  %add3192 = add i64 %mul3191, 24
  %mul3193 = mul i64 0, %add3192
  %add3194 = add i64 %mul3193, 0
  %neg3195 = xor i64 %add3194, -1
  %cmp3196 = icmp eq i64 %neg3195, -1
  %conv3197 = zext i1 %cmp3196 to i32
  %sub3198 = sub nsw i32 0, %conv3197
  %conv3199 = sext i32 %sub3198 to i64
  %498 = load i64, i64* %alloca_size, align 8
  %mul3200 = mul nsw i64 0, %498
  %add3201 = add i64 %mul3200, 24
  %mul3202 = mul i64 0, %add3201
  %add3203 = add i64 %mul3202, 1
  %shl3204 = shl i64 %add3203, 62
  %sub3205 = sub i64 %shl3204, 1
  %mul3206 = mul i64 %sub3205, 2
  %add3207 = add i64 %mul3206, 1
  %sub3208 = sub i64 %conv3199, %add3207
  br label %cond.end.3214

cond.false.3209:                                  ; preds = %cond.true.3183
  %499 = load i64, i64* %alloca_size, align 8
  %mul3210 = mul nsw i64 0, %499
  %add3211 = add i64 %mul3210, 24
  %mul3212 = mul i64 0, %add3211
  %add3213 = add i64 %mul3212, 0
  br label %cond.end.3214

cond.end.3214:                                    ; preds = %cond.false.3209, %cond.true.3190
  %cond3215 = phi i64 [ %sub3208, %cond.true.3190 ], [ %add3213, %cond.false.3209 ]
  %500 = load i64, i64* %alloca_size, align 8
  %sub3216 = sub i64 %cond3215, %500
  %cmp3217 = icmp ult i64 24, %sub3216
  br i1 %cmp3217, label %cond.true.3275, label %lor.lhs.false.3261

cond.false.3219:                                  ; preds = %cond.true.3180
  %501 = load i64, i64* %alloca_size, align 8
  %mul3220 = mul nsw i64 0, %501
  %add3221 = add i64 %mul3220, 24
  %mul3222 = mul i64 0, %add3221
  %sub3223 = sub i64 %mul3222, 1
  %cmp3224 = icmp ult i64 %sub3223, 0
  br i1 %cmp3224, label %cond.true.3226, label %cond.false.3235

cond.true.3226:                                   ; preds = %cond.false.3219
  %502 = load i64, i64* %alloca_size, align 8
  %mul3227 = mul nsw i64 0, %502
  %add3228 = add i64 %mul3227, 24
  %mul3229 = mul i64 0, %add3228
  %add3230 = add i64 %mul3229, 1
  %shl3231 = shl i64 %add3230, 62
  %sub3232 = sub i64 %shl3231, 1
  %mul3233 = mul i64 %sub3232, 2
  %add3234 = add i64 %mul3233, 1
  br label %cond.end.3240

cond.false.3235:                                  ; preds = %cond.false.3219
  %503 = load i64, i64* %alloca_size, align 8
  %mul3236 = mul nsw i64 0, %503
  %add3237 = add i64 %mul3236, 24
  %mul3238 = mul i64 0, %add3237
  %sub3239 = sub i64 %mul3238, 1
  br label %cond.end.3240

cond.end.3240:                                    ; preds = %cond.false.3235, %cond.true.3226
  %cond3241 = phi i64 [ %add3234, %cond.true.3226 ], [ %sub3239, %cond.false.3235 ]
  %504 = load i64, i64* %alloca_size, align 8
  %sub3242 = sub i64 %cond3241, %504
  %cmp3243 = icmp ult i64 %sub3242, 24
  br i1 %cmp3243, label %cond.true.3275, label %lor.lhs.false.3261

cond.false.3245:                                  ; preds = %cond.end.3176
  br i1 false, label %cond.true.3246, label %cond.false.3250

cond.true.3246:                                   ; preds = %cond.false.3245
  %505 = load i64, i64* %alloca_size, align 8
  %506 = load i64, i64* %alloca_size, align 8
  %add3247 = add i64 24, %506
  %cmp3248 = icmp ule i64 %505, %add3247
  br i1 %cmp3248, label %cond.true.3275, label %lor.lhs.false.3261

cond.false.3250:                                  ; preds = %cond.false.3245
  %507 = load i64, i64* %alloca_size, align 8
  %cmp3251 = icmp slt i64 %507, 0
  br i1 %cmp3251, label %cond.true.3253, label %cond.false.3257

cond.true.3253:                                   ; preds = %cond.false.3250
  %508 = load i64, i64* %alloca_size, align 8
  %add3254 = add i64 24, %508
  %cmp3255 = icmp ule i64 24, %add3254
  br i1 %cmp3255, label %cond.true.3275, label %lor.lhs.false.3261

cond.false.3257:                                  ; preds = %cond.false.3250
  %509 = load i64, i64* %alloca_size, align 8
  %add3258 = add i64 24, %509
  %510 = load i64, i64* %alloca_size, align 8
  %cmp3259 = icmp ult i64 %add3258, %510
  br i1 %cmp3259, label %cond.true.3275, label %lor.lhs.false.3261

lor.lhs.false.3261:                               ; preds = %cond.false.3257, %cond.true.3253, %cond.true.3246, %cond.end.3240, %cond.end.3214
  %511 = load i64, i64* %alloca_size, align 8
  %add3262 = add i64 24, %511
  %mul3263 = mul i64 0, %add3262
  %sub3264 = sub i64 %mul3263, 1
  %cmp3265 = icmp ult i64 %sub3264, 0
  br i1 %cmp3265, label %land.lhs.true.3267, label %lor.lhs.false.3271

land.lhs.true.3267:                               ; preds = %lor.lhs.false.3261
  %512 = load i64, i64* %alloca_size, align 8
  %add3268 = add i64 24, %512
  %cmp3269 = icmp ult i64 %add3268, -2147483648
  br i1 %cmp3269, label %cond.true.3275, label %lor.lhs.false.3271

lor.lhs.false.3271:                               ; preds = %land.lhs.true.3267, %lor.lhs.false.3261
  %513 = load i64, i64* %alloca_size, align 8
  %add3272 = add i64 24, %513
  %cmp3273 = icmp ult i64 2147483647, %add3272
  br i1 %cmp3273, label %cond.true.3275, label %cond.false.3291

cond.true.3275:                                   ; preds = %lor.lhs.false.3271, %land.lhs.true.3267, %cond.false.3257, %cond.true.3253, %cond.true.3246, %cond.end.3240, %cond.end.3214
  %514 = load i64, i64* %alloca_size, align 8
  %conv3276 = trunc i64 %514 to i32
  %add3277 = add i32 24, %conv3276
  %cmp3278 = icmp ule i32 %add3277, 2147483647
  br i1 %cmp3278, label %cond.true.3280, label %cond.false.3283

cond.true.3280:                                   ; preds = %cond.true.3275
  %515 = load i64, i64* %alloca_size, align 8
  %conv3281 = trunc i64 %515 to i32
  %add3282 = add i32 24, %conv3281
  br label %cond.end.3288

cond.false.3283:                                  ; preds = %cond.true.3275
  %516 = load i64, i64* %alloca_size, align 8
  %conv3284 = trunc i64 %516 to i32
  %add3285 = add i32 24, %conv3284
  %sub3286 = sub i32 %add3285, -2147483648
  %add3287 = add nsw i32 %sub3286, -2147483648
  br label %cond.end.3288

cond.end.3288:                                    ; preds = %cond.false.3283, %cond.true.3280
  %cond3289 = phi i32 [ %add3282, %cond.true.3280 ], [ %add3287, %cond.false.3283 ]
  %conv3290 = sext i32 %cond3289 to i64
  store i64 %conv3290, i64* %alloca_size, align 8
  br i1 true, label %if.then, label %lor.lhs.false.3926

cond.false.3291:                                  ; preds = %lor.lhs.false.3271
  %517 = load i64, i64* %alloca_size, align 8
  %conv3292 = trunc i64 %517 to i32
  %add3293 = add i32 24, %conv3292
  %cmp3294 = icmp ule i32 %add3293, 2147483647
  br i1 %cmp3294, label %cond.true.3296, label %cond.false.3299

cond.true.3296:                                   ; preds = %cond.false.3291
  %518 = load i64, i64* %alloca_size, align 8
  %conv3297 = trunc i64 %518 to i32
  %add3298 = add i32 24, %conv3297
  br label %cond.end.3304

cond.false.3299:                                  ; preds = %cond.false.3291
  %519 = load i64, i64* %alloca_size, align 8
  %conv3300 = trunc i64 %519 to i32
  %add3301 = add i32 24, %conv3300
  %sub3302 = sub i32 %add3301, -2147483648
  %add3303 = add nsw i32 %sub3302, -2147483648
  br label %cond.end.3304

cond.end.3304:                                    ; preds = %cond.false.3299, %cond.true.3296
  %cond3305 = phi i32 [ %add3298, %cond.true.3296 ], [ %add3303, %cond.false.3299 ]
  %conv3306 = sext i32 %cond3305 to i64
  store i64 %conv3306, i64* %alloca_size, align 8
  br i1 false, label %if.then, label %lor.lhs.false.3926

cond.false.3307:                                  ; preds = %cond.false.2960
  br i1 true, label %cond.true.3308, label %cond.false.3617

cond.true.3308:                                   ; preds = %cond.false.3307
  br i1 false, label %cond.true.3309, label %cond.false.3463

cond.true.3309:                                   ; preds = %cond.true.3308
  %520 = load i64, i64* %alloca_size, align 8
  %mul3310 = mul nsw i64 0, %520
  %add3311 = add nsw i64 %mul3310, 24
  %mul3312 = mul nsw i64 0, %add3311
  %sub3313 = sub nsw i64 %mul3312, 1
  %cmp3314 = icmp slt i64 %sub3313, 0
  br i1 %cmp3314, label %cond.true.3316, label %cond.false.3335

cond.true.3316:                                   ; preds = %cond.true.3309
  %521 = load i64, i64* %alloca_size, align 8
  %mul3317 = mul nsw i64 0, %521
  %add3318 = add nsw i64 %mul3317, 24
  %mul3319 = mul nsw i64 0, %add3318
  %add3320 = add nsw i64 %mul3319, 0
  %neg3321 = xor i64 %add3320, -1
  %cmp3322 = icmp eq i64 %neg3321, -1
  %conv3323 = zext i1 %cmp3322 to i32
  %sub3324 = sub nsw i32 0, %conv3323
  %conv3325 = sext i32 %sub3324 to i64
  %522 = load i64, i64* %alloca_size, align 8
  %mul3326 = mul nsw i64 0, %522
  %add3327 = add nsw i64 %mul3326, 24
  %mul3328 = mul nsw i64 0, %add3327
  %add3329 = add nsw i64 %mul3328, 1
  %shl3330 = shl i64 %add3329, 62
  %sub3331 = sub nsw i64 %shl3330, 1
  %mul3332 = mul nsw i64 %sub3331, 2
  %add3333 = add nsw i64 %mul3332, 1
  %sub3334 = sub nsw i64 %conv3325, %add3333
  br label %cond.end.3340

cond.false.3335:                                  ; preds = %cond.true.3309
  %523 = load i64, i64* %alloca_size, align 8
  %mul3336 = mul nsw i64 0, %523
  %add3337 = add nsw i64 %mul3336, 24
  %mul3338 = mul nsw i64 0, %add3337
  %add3339 = add nsw i64 %mul3338, 0
  br label %cond.end.3340

cond.end.3340:                                    ; preds = %cond.false.3335, %cond.true.3316
  %cond3341 = phi i64 [ %sub3334, %cond.true.3316 ], [ %add3339, %cond.false.3335 ]
  %cmp3342 = icmp slt i64 %cond3341, 0
  br i1 %cmp3342, label %cond.true.3344, label %cond.false.3409

cond.true.3344:                                   ; preds = %cond.end.3340
  %524 = load i64, i64* %alloca_size, align 8
  %cmp3345 = icmp slt i64 %524, 0
  br i1 %cmp3345, label %cond.true.3347, label %cond.false.3383

cond.true.3347:                                   ; preds = %cond.true.3344
  %525 = load i64, i64* %alloca_size, align 8
  %mul3348 = mul nsw i64 0, %525
  %add3349 = add nsw i64 %mul3348, 24
  %mul3350 = mul nsw i64 0, %add3349
  %sub3351 = sub nsw i64 %mul3350, 1
  %cmp3352 = icmp slt i64 %sub3351, 0
  br i1 %cmp3352, label %cond.true.3354, label %cond.false.3373

cond.true.3354:                                   ; preds = %cond.true.3347
  %526 = load i64, i64* %alloca_size, align 8
  %mul3355 = mul nsw i64 0, %526
  %add3356 = add nsw i64 %mul3355, 24
  %mul3357 = mul nsw i64 0, %add3356
  %add3358 = add nsw i64 %mul3357, 0
  %neg3359 = xor i64 %add3358, -1
  %cmp3360 = icmp eq i64 %neg3359, -1
  %conv3361 = zext i1 %cmp3360 to i32
  %sub3362 = sub nsw i32 0, %conv3361
  %conv3363 = sext i32 %sub3362 to i64
  %527 = load i64, i64* %alloca_size, align 8
  %mul3364 = mul nsw i64 0, %527
  %add3365 = add nsw i64 %mul3364, 24
  %mul3366 = mul nsw i64 0, %add3365
  %add3367 = add nsw i64 %mul3366, 1
  %shl3368 = shl i64 %add3367, 62
  %sub3369 = sub nsw i64 %shl3368, 1
  %mul3370 = mul nsw i64 %sub3369, 2
  %add3371 = add nsw i64 %mul3370, 1
  %sub3372 = sub nsw i64 %conv3363, %add3371
  br label %cond.end.3378

cond.false.3373:                                  ; preds = %cond.true.3347
  %528 = load i64, i64* %alloca_size, align 8
  %mul3374 = mul nsw i64 0, %528
  %add3375 = add nsw i64 %mul3374, 24
  %mul3376 = mul nsw i64 0, %add3375
  %add3377 = add nsw i64 %mul3376, 0
  br label %cond.end.3378

cond.end.3378:                                    ; preds = %cond.false.3373, %cond.true.3354
  %cond3379 = phi i64 [ %sub3372, %cond.true.3354 ], [ %add3377, %cond.false.3373 ]
  %529 = load i64, i64* %alloca_size, align 8
  %sub3380 = sub nsw i64 %cond3379, %529
  %cmp3381 = icmp slt i64 24, %sub3380
  br i1 %cmp3381, label %cond.true.3439, label %lor.lhs.false.3425

cond.false.3383:                                  ; preds = %cond.true.3344
  %530 = load i64, i64* %alloca_size, align 8
  %mul3384 = mul nsw i64 0, %530
  %add3385 = add nsw i64 %mul3384, 24
  %mul3386 = mul nsw i64 0, %add3385
  %sub3387 = sub nsw i64 %mul3386, 1
  %cmp3388 = icmp slt i64 %sub3387, 0
  br i1 %cmp3388, label %cond.true.3390, label %cond.false.3399

cond.true.3390:                                   ; preds = %cond.false.3383
  %531 = load i64, i64* %alloca_size, align 8
  %mul3391 = mul nsw i64 0, %531
  %add3392 = add nsw i64 %mul3391, 24
  %mul3393 = mul nsw i64 0, %add3392
  %add3394 = add nsw i64 %mul3393, 1
  %shl3395 = shl i64 %add3394, 62
  %sub3396 = sub nsw i64 %shl3395, 1
  %mul3397 = mul nsw i64 %sub3396, 2
  %add3398 = add nsw i64 %mul3397, 1
  br label %cond.end.3404

cond.false.3399:                                  ; preds = %cond.false.3383
  %532 = load i64, i64* %alloca_size, align 8
  %mul3400 = mul nsw i64 0, %532
  %add3401 = add nsw i64 %mul3400, 24
  %mul3402 = mul nsw i64 0, %add3401
  %sub3403 = sub nsw i64 %mul3402, 1
  br label %cond.end.3404

cond.end.3404:                                    ; preds = %cond.false.3399, %cond.true.3390
  %cond3405 = phi i64 [ %add3398, %cond.true.3390 ], [ %sub3403, %cond.false.3399 ]
  %533 = load i64, i64* %alloca_size, align 8
  %sub3406 = sub nsw i64 %cond3405, %533
  %cmp3407 = icmp slt i64 %sub3406, 24
  br i1 %cmp3407, label %cond.true.3439, label %lor.lhs.false.3425

cond.false.3409:                                  ; preds = %cond.end.3340
  br i1 false, label %cond.true.3410, label %cond.false.3414

cond.true.3410:                                   ; preds = %cond.false.3409
  %534 = load i64, i64* %alloca_size, align 8
  %535 = load i64, i64* %alloca_size, align 8
  %add3411 = add nsw i64 24, %535
  %cmp3412 = icmp sle i64 %534, %add3411
  br i1 %cmp3412, label %cond.true.3439, label %lor.lhs.false.3425

cond.false.3414:                                  ; preds = %cond.false.3409
  %536 = load i64, i64* %alloca_size, align 8
  %cmp3415 = icmp slt i64 %536, 0
  br i1 %cmp3415, label %cond.true.3417, label %cond.false.3421

cond.true.3417:                                   ; preds = %cond.false.3414
  %537 = load i64, i64* %alloca_size, align 8
  %add3418 = add nsw i64 24, %537
  %cmp3419 = icmp sle i64 24, %add3418
  br i1 %cmp3419, label %cond.true.3439, label %lor.lhs.false.3425

cond.false.3421:                                  ; preds = %cond.false.3414
  %538 = load i64, i64* %alloca_size, align 8
  %add3422 = add nsw i64 24, %538
  %539 = load i64, i64* %alloca_size, align 8
  %cmp3423 = icmp slt i64 %add3422, %539
  br i1 %cmp3423, label %cond.true.3439, label %lor.lhs.false.3425

lor.lhs.false.3425:                               ; preds = %cond.false.3421, %cond.true.3417, %cond.true.3410, %cond.end.3404, %cond.end.3378
  %540 = load i64, i64* %alloca_size, align 8
  %add3426 = add nsw i64 24, %540
  %mul3427 = mul nsw i64 0, %add3426
  %sub3428 = sub nsw i64 %mul3427, 1
  %cmp3429 = icmp slt i64 %sub3428, 0
  br i1 %cmp3429, label %land.lhs.true.3431, label %lor.lhs.false.3435

land.lhs.true.3431:                               ; preds = %lor.lhs.false.3425
  %541 = load i64, i64* %alloca_size, align 8
  %add3432 = add nsw i64 24, %541
  %cmp3433 = icmp slt i64 %add3432, -9223372036854775808
  br i1 %cmp3433, label %cond.true.3439, label %lor.lhs.false.3435

lor.lhs.false.3435:                               ; preds = %land.lhs.true.3431, %lor.lhs.false.3425
  %542 = load i64, i64* %alloca_size, align 8
  %add3436 = add nsw i64 24, %542
  %cmp3437 = icmp slt i64 9223372036854775807, %add3436
  br i1 %cmp3437, label %cond.true.3439, label %cond.false.3451

cond.true.3439:                                   ; preds = %lor.lhs.false.3435, %land.lhs.true.3431, %cond.false.3421, %cond.true.3417, %cond.true.3410, %cond.end.3404, %cond.end.3378
  %543 = load i64, i64* %alloca_size, align 8
  %add3440 = add i64 24, %543
  %cmp3441 = icmp ule i64 %add3440, 9223372036854775807
  br i1 %cmp3441, label %cond.true.3443, label %cond.false.3445

cond.true.3443:                                   ; preds = %cond.true.3439
  %544 = load i64, i64* %alloca_size, align 8
  %add3444 = add i64 24, %544
  br label %cond.end.3449

cond.false.3445:                                  ; preds = %cond.true.3439
  %545 = load i64, i64* %alloca_size, align 8
  %add3446 = add i64 24, %545
  %sub3447 = sub i64 %add3446, -9223372036854775808
  %add3448 = add nsw i64 %sub3447, -9223372036854775808
  br label %cond.end.3449

cond.end.3449:                                    ; preds = %cond.false.3445, %cond.true.3443
  %cond3450 = phi i64 [ %add3444, %cond.true.3443 ], [ %add3448, %cond.false.3445 ]
  store i64 %cond3450, i64* %alloca_size, align 8
  br i1 true, label %if.then, label %lor.lhs.false.3926

cond.false.3451:                                  ; preds = %lor.lhs.false.3435
  %546 = load i64, i64* %alloca_size, align 8
  %add3452 = add i64 24, %546
  %cmp3453 = icmp ule i64 %add3452, 9223372036854775807
  br i1 %cmp3453, label %cond.true.3455, label %cond.false.3457

cond.true.3455:                                   ; preds = %cond.false.3451
  %547 = load i64, i64* %alloca_size, align 8
  %add3456 = add i64 24, %547
  br label %cond.end.3461

cond.false.3457:                                  ; preds = %cond.false.3451
  %548 = load i64, i64* %alloca_size, align 8
  %add3458 = add i64 24, %548
  %sub3459 = sub i64 %add3458, -9223372036854775808
  %add3460 = add nsw i64 %sub3459, -9223372036854775808
  br label %cond.end.3461

cond.end.3461:                                    ; preds = %cond.false.3457, %cond.true.3455
  %cond3462 = phi i64 [ %add3456, %cond.true.3455 ], [ %add3460, %cond.false.3457 ]
  store i64 %cond3462, i64* %alloca_size, align 8
  br i1 false, label %if.then, label %lor.lhs.false.3926

cond.false.3463:                                  ; preds = %cond.true.3308
  %549 = load i64, i64* %alloca_size, align 8
  %mul3464 = mul nsw i64 0, %549
  %add3465 = add i64 %mul3464, 24
  %mul3466 = mul i64 0, %add3465
  %sub3467 = sub i64 %mul3466, 1
  %cmp3468 = icmp ult i64 %sub3467, 0
  br i1 %cmp3468, label %cond.true.3470, label %cond.false.3489

cond.true.3470:                                   ; preds = %cond.false.3463
  %550 = load i64, i64* %alloca_size, align 8
  %mul3471 = mul nsw i64 0, %550
  %add3472 = add i64 %mul3471, 24
  %mul3473 = mul i64 0, %add3472
  %add3474 = add i64 %mul3473, 0
  %neg3475 = xor i64 %add3474, -1
  %cmp3476 = icmp eq i64 %neg3475, -1
  %conv3477 = zext i1 %cmp3476 to i32
  %sub3478 = sub nsw i32 0, %conv3477
  %conv3479 = sext i32 %sub3478 to i64
  %551 = load i64, i64* %alloca_size, align 8
  %mul3480 = mul nsw i64 0, %551
  %add3481 = add i64 %mul3480, 24
  %mul3482 = mul i64 0, %add3481
  %add3483 = add i64 %mul3482, 1
  %shl3484 = shl i64 %add3483, 62
  %sub3485 = sub i64 %shl3484, 1
  %mul3486 = mul i64 %sub3485, 2
  %add3487 = add i64 %mul3486, 1
  %sub3488 = sub i64 %conv3479, %add3487
  br label %cond.end.3494

cond.false.3489:                                  ; preds = %cond.false.3463
  %552 = load i64, i64* %alloca_size, align 8
  %mul3490 = mul nsw i64 0, %552
  %add3491 = add i64 %mul3490, 24
  %mul3492 = mul i64 0, %add3491
  %add3493 = add i64 %mul3492, 0
  br label %cond.end.3494

cond.end.3494:                                    ; preds = %cond.false.3489, %cond.true.3470
  %cond3495 = phi i64 [ %sub3488, %cond.true.3470 ], [ %add3493, %cond.false.3489 ]
  %cmp3496 = icmp ult i64 %cond3495, 0
  br i1 %cmp3496, label %cond.true.3498, label %cond.false.3563

cond.true.3498:                                   ; preds = %cond.end.3494
  %553 = load i64, i64* %alloca_size, align 8
  %cmp3499 = icmp slt i64 %553, 0
  br i1 %cmp3499, label %cond.true.3501, label %cond.false.3537

cond.true.3501:                                   ; preds = %cond.true.3498
  %554 = load i64, i64* %alloca_size, align 8
  %mul3502 = mul nsw i64 0, %554
  %add3503 = add i64 %mul3502, 24
  %mul3504 = mul i64 0, %add3503
  %sub3505 = sub i64 %mul3504, 1
  %cmp3506 = icmp ult i64 %sub3505, 0
  br i1 %cmp3506, label %cond.true.3508, label %cond.false.3527

cond.true.3508:                                   ; preds = %cond.true.3501
  %555 = load i64, i64* %alloca_size, align 8
  %mul3509 = mul nsw i64 0, %555
  %add3510 = add i64 %mul3509, 24
  %mul3511 = mul i64 0, %add3510
  %add3512 = add i64 %mul3511, 0
  %neg3513 = xor i64 %add3512, -1
  %cmp3514 = icmp eq i64 %neg3513, -1
  %conv3515 = zext i1 %cmp3514 to i32
  %sub3516 = sub nsw i32 0, %conv3515
  %conv3517 = sext i32 %sub3516 to i64
  %556 = load i64, i64* %alloca_size, align 8
  %mul3518 = mul nsw i64 0, %556
  %add3519 = add i64 %mul3518, 24
  %mul3520 = mul i64 0, %add3519
  %add3521 = add i64 %mul3520, 1
  %shl3522 = shl i64 %add3521, 62
  %sub3523 = sub i64 %shl3522, 1
  %mul3524 = mul i64 %sub3523, 2
  %add3525 = add i64 %mul3524, 1
  %sub3526 = sub i64 %conv3517, %add3525
  br label %cond.end.3532

cond.false.3527:                                  ; preds = %cond.true.3501
  %557 = load i64, i64* %alloca_size, align 8
  %mul3528 = mul nsw i64 0, %557
  %add3529 = add i64 %mul3528, 24
  %mul3530 = mul i64 0, %add3529
  %add3531 = add i64 %mul3530, 0
  br label %cond.end.3532

cond.end.3532:                                    ; preds = %cond.false.3527, %cond.true.3508
  %cond3533 = phi i64 [ %sub3526, %cond.true.3508 ], [ %add3531, %cond.false.3527 ]
  %558 = load i64, i64* %alloca_size, align 8
  %sub3534 = sub i64 %cond3533, %558
  %cmp3535 = icmp ult i64 24, %sub3534
  br i1 %cmp3535, label %cond.true.3593, label %lor.lhs.false.3579

cond.false.3537:                                  ; preds = %cond.true.3498
  %559 = load i64, i64* %alloca_size, align 8
  %mul3538 = mul nsw i64 0, %559
  %add3539 = add i64 %mul3538, 24
  %mul3540 = mul i64 0, %add3539
  %sub3541 = sub i64 %mul3540, 1
  %cmp3542 = icmp ult i64 %sub3541, 0
  br i1 %cmp3542, label %cond.true.3544, label %cond.false.3553

cond.true.3544:                                   ; preds = %cond.false.3537
  %560 = load i64, i64* %alloca_size, align 8
  %mul3545 = mul nsw i64 0, %560
  %add3546 = add i64 %mul3545, 24
  %mul3547 = mul i64 0, %add3546
  %add3548 = add i64 %mul3547, 1
  %shl3549 = shl i64 %add3548, 62
  %sub3550 = sub i64 %shl3549, 1
  %mul3551 = mul i64 %sub3550, 2
  %add3552 = add i64 %mul3551, 1
  br label %cond.end.3558

cond.false.3553:                                  ; preds = %cond.false.3537
  %561 = load i64, i64* %alloca_size, align 8
  %mul3554 = mul nsw i64 0, %561
  %add3555 = add i64 %mul3554, 24
  %mul3556 = mul i64 0, %add3555
  %sub3557 = sub i64 %mul3556, 1
  br label %cond.end.3558

cond.end.3558:                                    ; preds = %cond.false.3553, %cond.true.3544
  %cond3559 = phi i64 [ %add3552, %cond.true.3544 ], [ %sub3557, %cond.false.3553 ]
  %562 = load i64, i64* %alloca_size, align 8
  %sub3560 = sub i64 %cond3559, %562
  %cmp3561 = icmp ult i64 %sub3560, 24
  br i1 %cmp3561, label %cond.true.3593, label %lor.lhs.false.3579

cond.false.3563:                                  ; preds = %cond.end.3494
  br i1 false, label %cond.true.3564, label %cond.false.3568

cond.true.3564:                                   ; preds = %cond.false.3563
  %563 = load i64, i64* %alloca_size, align 8
  %564 = load i64, i64* %alloca_size, align 8
  %add3565 = add i64 24, %564
  %cmp3566 = icmp ule i64 %563, %add3565
  br i1 %cmp3566, label %cond.true.3593, label %lor.lhs.false.3579

cond.false.3568:                                  ; preds = %cond.false.3563
  %565 = load i64, i64* %alloca_size, align 8
  %cmp3569 = icmp slt i64 %565, 0
  br i1 %cmp3569, label %cond.true.3571, label %cond.false.3575

cond.true.3571:                                   ; preds = %cond.false.3568
  %566 = load i64, i64* %alloca_size, align 8
  %add3572 = add i64 24, %566
  %cmp3573 = icmp ule i64 24, %add3572
  br i1 %cmp3573, label %cond.true.3593, label %lor.lhs.false.3579

cond.false.3575:                                  ; preds = %cond.false.3568
  %567 = load i64, i64* %alloca_size, align 8
  %add3576 = add i64 24, %567
  %568 = load i64, i64* %alloca_size, align 8
  %cmp3577 = icmp ult i64 %add3576, %568
  br i1 %cmp3577, label %cond.true.3593, label %lor.lhs.false.3579

lor.lhs.false.3579:                               ; preds = %cond.false.3575, %cond.true.3571, %cond.true.3564, %cond.end.3558, %cond.end.3532
  %569 = load i64, i64* %alloca_size, align 8
  %add3580 = add i64 24, %569
  %mul3581 = mul i64 0, %add3580
  %sub3582 = sub i64 %mul3581, 1
  %cmp3583 = icmp ult i64 %sub3582, 0
  br i1 %cmp3583, label %land.lhs.true.3585, label %lor.lhs.false.3589

land.lhs.true.3585:                               ; preds = %lor.lhs.false.3579
  %570 = load i64, i64* %alloca_size, align 8
  %add3586 = add i64 24, %570
  %cmp3587 = icmp ult i64 %add3586, -9223372036854775808
  br i1 %cmp3587, label %cond.true.3593, label %lor.lhs.false.3589

lor.lhs.false.3589:                               ; preds = %land.lhs.true.3585, %lor.lhs.false.3579
  %571 = load i64, i64* %alloca_size, align 8
  %add3590 = add i64 24, %571
  %cmp3591 = icmp ult i64 9223372036854775807, %add3590
  br i1 %cmp3591, label %cond.true.3593, label %cond.false.3605

cond.true.3593:                                   ; preds = %lor.lhs.false.3589, %land.lhs.true.3585, %cond.false.3575, %cond.true.3571, %cond.true.3564, %cond.end.3558, %cond.end.3532
  %572 = load i64, i64* %alloca_size, align 8
  %add3594 = add i64 24, %572
  %cmp3595 = icmp ule i64 %add3594, 9223372036854775807
  br i1 %cmp3595, label %cond.true.3597, label %cond.false.3599

cond.true.3597:                                   ; preds = %cond.true.3593
  %573 = load i64, i64* %alloca_size, align 8
  %add3598 = add i64 24, %573
  br label %cond.end.3603

cond.false.3599:                                  ; preds = %cond.true.3593
  %574 = load i64, i64* %alloca_size, align 8
  %add3600 = add i64 24, %574
  %sub3601 = sub i64 %add3600, -9223372036854775808
  %add3602 = add nsw i64 %sub3601, -9223372036854775808
  br label %cond.end.3603

cond.end.3603:                                    ; preds = %cond.false.3599, %cond.true.3597
  %cond3604 = phi i64 [ %add3598, %cond.true.3597 ], [ %add3602, %cond.false.3599 ]
  store i64 %cond3604, i64* %alloca_size, align 8
  br i1 true, label %if.then, label %lor.lhs.false.3926

cond.false.3605:                                  ; preds = %lor.lhs.false.3589
  %575 = load i64, i64* %alloca_size, align 8
  %add3606 = add i64 24, %575
  %cmp3607 = icmp ule i64 %add3606, 9223372036854775807
  br i1 %cmp3607, label %cond.true.3609, label %cond.false.3611

cond.true.3609:                                   ; preds = %cond.false.3605
  %576 = load i64, i64* %alloca_size, align 8
  %add3610 = add i64 24, %576
  br label %cond.end.3615

cond.false.3611:                                  ; preds = %cond.false.3605
  %577 = load i64, i64* %alloca_size, align 8
  %add3612 = add i64 24, %577
  %sub3613 = sub i64 %add3612, -9223372036854775808
  %add3614 = add nsw i64 %sub3613, -9223372036854775808
  br label %cond.end.3615

cond.end.3615:                                    ; preds = %cond.false.3611, %cond.true.3609
  %cond3616 = phi i64 [ %add3610, %cond.true.3609 ], [ %add3614, %cond.false.3611 ]
  store i64 %cond3616, i64* %alloca_size, align 8
  br i1 false, label %if.then, label %lor.lhs.false.3926

cond.false.3617:                                  ; preds = %cond.false.3307
  br i1 false, label %cond.true.3618, label %cond.false.3772

cond.true.3618:                                   ; preds = %cond.false.3617
  %578 = load i64, i64* %alloca_size, align 8
  %mul3619 = mul nsw i64 0, %578
  %add3620 = add nsw i64 %mul3619, 24
  %mul3621 = mul nsw i64 0, %add3620
  %sub3622 = sub nsw i64 %mul3621, 1
  %cmp3623 = icmp slt i64 %sub3622, 0
  br i1 %cmp3623, label %cond.true.3625, label %cond.false.3644

cond.true.3625:                                   ; preds = %cond.true.3618
  %579 = load i64, i64* %alloca_size, align 8
  %mul3626 = mul nsw i64 0, %579
  %add3627 = add nsw i64 %mul3626, 24
  %mul3628 = mul nsw i64 0, %add3627
  %add3629 = add nsw i64 %mul3628, 0
  %neg3630 = xor i64 %add3629, -1
  %cmp3631 = icmp eq i64 %neg3630, -1
  %conv3632 = zext i1 %cmp3631 to i32
  %sub3633 = sub nsw i32 0, %conv3632
  %conv3634 = sext i32 %sub3633 to i64
  %580 = load i64, i64* %alloca_size, align 8
  %mul3635 = mul nsw i64 0, %580
  %add3636 = add nsw i64 %mul3635, 24
  %mul3637 = mul nsw i64 0, %add3636
  %add3638 = add nsw i64 %mul3637, 1
  %shl3639 = shl i64 %add3638, 62
  %sub3640 = sub nsw i64 %shl3639, 1
  %mul3641 = mul nsw i64 %sub3640, 2
  %add3642 = add nsw i64 %mul3641, 1
  %sub3643 = sub nsw i64 %conv3634, %add3642
  br label %cond.end.3649

cond.false.3644:                                  ; preds = %cond.true.3618
  %581 = load i64, i64* %alloca_size, align 8
  %mul3645 = mul nsw i64 0, %581
  %add3646 = add nsw i64 %mul3645, 24
  %mul3647 = mul nsw i64 0, %add3646
  %add3648 = add nsw i64 %mul3647, 0
  br label %cond.end.3649

cond.end.3649:                                    ; preds = %cond.false.3644, %cond.true.3625
  %cond3650 = phi i64 [ %sub3643, %cond.true.3625 ], [ %add3648, %cond.false.3644 ]
  %cmp3651 = icmp slt i64 %cond3650, 0
  br i1 %cmp3651, label %cond.true.3653, label %cond.false.3718

cond.true.3653:                                   ; preds = %cond.end.3649
  %582 = load i64, i64* %alloca_size, align 8
  %cmp3654 = icmp slt i64 %582, 0
  br i1 %cmp3654, label %cond.true.3656, label %cond.false.3692

cond.true.3656:                                   ; preds = %cond.true.3653
  %583 = load i64, i64* %alloca_size, align 8
  %mul3657 = mul nsw i64 0, %583
  %add3658 = add nsw i64 %mul3657, 24
  %mul3659 = mul nsw i64 0, %add3658
  %sub3660 = sub nsw i64 %mul3659, 1
  %cmp3661 = icmp slt i64 %sub3660, 0
  br i1 %cmp3661, label %cond.true.3663, label %cond.false.3682

cond.true.3663:                                   ; preds = %cond.true.3656
  %584 = load i64, i64* %alloca_size, align 8
  %mul3664 = mul nsw i64 0, %584
  %add3665 = add nsw i64 %mul3664, 24
  %mul3666 = mul nsw i64 0, %add3665
  %add3667 = add nsw i64 %mul3666, 0
  %neg3668 = xor i64 %add3667, -1
  %cmp3669 = icmp eq i64 %neg3668, -1
  %conv3670 = zext i1 %cmp3669 to i32
  %sub3671 = sub nsw i32 0, %conv3670
  %conv3672 = sext i32 %sub3671 to i64
  %585 = load i64, i64* %alloca_size, align 8
  %mul3673 = mul nsw i64 0, %585
  %add3674 = add nsw i64 %mul3673, 24
  %mul3675 = mul nsw i64 0, %add3674
  %add3676 = add nsw i64 %mul3675, 1
  %shl3677 = shl i64 %add3676, 62
  %sub3678 = sub nsw i64 %shl3677, 1
  %mul3679 = mul nsw i64 %sub3678, 2
  %add3680 = add nsw i64 %mul3679, 1
  %sub3681 = sub nsw i64 %conv3672, %add3680
  br label %cond.end.3687

cond.false.3682:                                  ; preds = %cond.true.3656
  %586 = load i64, i64* %alloca_size, align 8
  %mul3683 = mul nsw i64 0, %586
  %add3684 = add nsw i64 %mul3683, 24
  %mul3685 = mul nsw i64 0, %add3684
  %add3686 = add nsw i64 %mul3685, 0
  br label %cond.end.3687

cond.end.3687:                                    ; preds = %cond.false.3682, %cond.true.3663
  %cond3688 = phi i64 [ %sub3681, %cond.true.3663 ], [ %add3686, %cond.false.3682 ]
  %587 = load i64, i64* %alloca_size, align 8
  %sub3689 = sub nsw i64 %cond3688, %587
  %cmp3690 = icmp slt i64 24, %sub3689
  br i1 %cmp3690, label %cond.true.3748, label %lor.lhs.false.3734

cond.false.3692:                                  ; preds = %cond.true.3653
  %588 = load i64, i64* %alloca_size, align 8
  %mul3693 = mul nsw i64 0, %588
  %add3694 = add nsw i64 %mul3693, 24
  %mul3695 = mul nsw i64 0, %add3694
  %sub3696 = sub nsw i64 %mul3695, 1
  %cmp3697 = icmp slt i64 %sub3696, 0
  br i1 %cmp3697, label %cond.true.3699, label %cond.false.3708

cond.true.3699:                                   ; preds = %cond.false.3692
  %589 = load i64, i64* %alloca_size, align 8
  %mul3700 = mul nsw i64 0, %589
  %add3701 = add nsw i64 %mul3700, 24
  %mul3702 = mul nsw i64 0, %add3701
  %add3703 = add nsw i64 %mul3702, 1
  %shl3704 = shl i64 %add3703, 62
  %sub3705 = sub nsw i64 %shl3704, 1
  %mul3706 = mul nsw i64 %sub3705, 2
  %add3707 = add nsw i64 %mul3706, 1
  br label %cond.end.3713

cond.false.3708:                                  ; preds = %cond.false.3692
  %590 = load i64, i64* %alloca_size, align 8
  %mul3709 = mul nsw i64 0, %590
  %add3710 = add nsw i64 %mul3709, 24
  %mul3711 = mul nsw i64 0, %add3710
  %sub3712 = sub nsw i64 %mul3711, 1
  br label %cond.end.3713

cond.end.3713:                                    ; preds = %cond.false.3708, %cond.true.3699
  %cond3714 = phi i64 [ %add3707, %cond.true.3699 ], [ %sub3712, %cond.false.3708 ]
  %591 = load i64, i64* %alloca_size, align 8
  %sub3715 = sub nsw i64 %cond3714, %591
  %cmp3716 = icmp slt i64 %sub3715, 24
  br i1 %cmp3716, label %cond.true.3748, label %lor.lhs.false.3734

cond.false.3718:                                  ; preds = %cond.end.3649
  br i1 false, label %cond.true.3719, label %cond.false.3723

cond.true.3719:                                   ; preds = %cond.false.3718
  %592 = load i64, i64* %alloca_size, align 8
  %593 = load i64, i64* %alloca_size, align 8
  %add3720 = add nsw i64 24, %593
  %cmp3721 = icmp sle i64 %592, %add3720
  br i1 %cmp3721, label %cond.true.3748, label %lor.lhs.false.3734

cond.false.3723:                                  ; preds = %cond.false.3718
  %594 = load i64, i64* %alloca_size, align 8
  %cmp3724 = icmp slt i64 %594, 0
  br i1 %cmp3724, label %cond.true.3726, label %cond.false.3730

cond.true.3726:                                   ; preds = %cond.false.3723
  %595 = load i64, i64* %alloca_size, align 8
  %add3727 = add nsw i64 24, %595
  %cmp3728 = icmp sle i64 24, %add3727
  br i1 %cmp3728, label %cond.true.3748, label %lor.lhs.false.3734

cond.false.3730:                                  ; preds = %cond.false.3723
  %596 = load i64, i64* %alloca_size, align 8
  %add3731 = add nsw i64 24, %596
  %597 = load i64, i64* %alloca_size, align 8
  %cmp3732 = icmp slt i64 %add3731, %597
  br i1 %cmp3732, label %cond.true.3748, label %lor.lhs.false.3734

lor.lhs.false.3734:                               ; preds = %cond.false.3730, %cond.true.3726, %cond.true.3719, %cond.end.3713, %cond.end.3687
  %598 = load i64, i64* %alloca_size, align 8
  %add3735 = add nsw i64 24, %598
  %mul3736 = mul nsw i64 0, %add3735
  %sub3737 = sub nsw i64 %mul3736, 1
  %cmp3738 = icmp slt i64 %sub3737, 0
  br i1 %cmp3738, label %land.lhs.true.3740, label %lor.lhs.false.3744

land.lhs.true.3740:                               ; preds = %lor.lhs.false.3734
  %599 = load i64, i64* %alloca_size, align 8
  %add3741 = add nsw i64 24, %599
  %cmp3742 = icmp slt i64 %add3741, -9223372036854775808
  br i1 %cmp3742, label %cond.true.3748, label %lor.lhs.false.3744

lor.lhs.false.3744:                               ; preds = %land.lhs.true.3740, %lor.lhs.false.3734
  %600 = load i64, i64* %alloca_size, align 8
  %add3745 = add nsw i64 24, %600
  %cmp3746 = icmp slt i64 9223372036854775807, %add3745
  br i1 %cmp3746, label %cond.true.3748, label %cond.false.3760

cond.true.3748:                                   ; preds = %lor.lhs.false.3744, %land.lhs.true.3740, %cond.false.3730, %cond.true.3726, %cond.true.3719, %cond.end.3713, %cond.end.3687
  %601 = load i64, i64* %alloca_size, align 8
  %add3749 = add i64 24, %601
  %cmp3750 = icmp ule i64 %add3749, 9223372036854775807
  br i1 %cmp3750, label %cond.true.3752, label %cond.false.3754

cond.true.3752:                                   ; preds = %cond.true.3748
  %602 = load i64, i64* %alloca_size, align 8
  %add3753 = add i64 24, %602
  br label %cond.end.3758

cond.false.3754:                                  ; preds = %cond.true.3748
  %603 = load i64, i64* %alloca_size, align 8
  %add3755 = add i64 24, %603
  %sub3756 = sub i64 %add3755, -9223372036854775808
  %add3757 = add nsw i64 %sub3756, -9223372036854775808
  br label %cond.end.3758

cond.end.3758:                                    ; preds = %cond.false.3754, %cond.true.3752
  %cond3759 = phi i64 [ %add3753, %cond.true.3752 ], [ %add3757, %cond.false.3754 ]
  store i64 %cond3759, i64* %alloca_size, align 8
  br i1 true, label %if.then, label %lor.lhs.false.3926

cond.false.3760:                                  ; preds = %lor.lhs.false.3744
  %604 = load i64, i64* %alloca_size, align 8
  %add3761 = add i64 24, %604
  %cmp3762 = icmp ule i64 %add3761, 9223372036854775807
  br i1 %cmp3762, label %cond.true.3764, label %cond.false.3766

cond.true.3764:                                   ; preds = %cond.false.3760
  %605 = load i64, i64* %alloca_size, align 8
  %add3765 = add i64 24, %605
  br label %cond.end.3770

cond.false.3766:                                  ; preds = %cond.false.3760
  %606 = load i64, i64* %alloca_size, align 8
  %add3767 = add i64 24, %606
  %sub3768 = sub i64 %add3767, -9223372036854775808
  %add3769 = add nsw i64 %sub3768, -9223372036854775808
  br label %cond.end.3770

cond.end.3770:                                    ; preds = %cond.false.3766, %cond.true.3764
  %cond3771 = phi i64 [ %add3765, %cond.true.3764 ], [ %add3769, %cond.false.3766 ]
  store i64 %cond3771, i64* %alloca_size, align 8
  br i1 false, label %if.then, label %lor.lhs.false.3926

cond.false.3772:                                  ; preds = %cond.false.3617
  %607 = load i64, i64* %alloca_size, align 8
  %mul3773 = mul nsw i64 0, %607
  %add3774 = add i64 %mul3773, 24
  %mul3775 = mul i64 0, %add3774
  %sub3776 = sub i64 %mul3775, 1
  %cmp3777 = icmp ult i64 %sub3776, 0
  br i1 %cmp3777, label %cond.true.3779, label %cond.false.3798

cond.true.3779:                                   ; preds = %cond.false.3772
  %608 = load i64, i64* %alloca_size, align 8
  %mul3780 = mul nsw i64 0, %608
  %add3781 = add i64 %mul3780, 24
  %mul3782 = mul i64 0, %add3781
  %add3783 = add i64 %mul3782, 0
  %neg3784 = xor i64 %add3783, -1
  %cmp3785 = icmp eq i64 %neg3784, -1
  %conv3786 = zext i1 %cmp3785 to i32
  %sub3787 = sub nsw i32 0, %conv3786
  %conv3788 = sext i32 %sub3787 to i64
  %609 = load i64, i64* %alloca_size, align 8
  %mul3789 = mul nsw i64 0, %609
  %add3790 = add i64 %mul3789, 24
  %mul3791 = mul i64 0, %add3790
  %add3792 = add i64 %mul3791, 1
  %shl3793 = shl i64 %add3792, 62
  %sub3794 = sub i64 %shl3793, 1
  %mul3795 = mul i64 %sub3794, 2
  %add3796 = add i64 %mul3795, 1
  %sub3797 = sub i64 %conv3788, %add3796
  br label %cond.end.3803

cond.false.3798:                                  ; preds = %cond.false.3772
  %610 = load i64, i64* %alloca_size, align 8
  %mul3799 = mul nsw i64 0, %610
  %add3800 = add i64 %mul3799, 24
  %mul3801 = mul i64 0, %add3800
  %add3802 = add i64 %mul3801, 0
  br label %cond.end.3803

cond.end.3803:                                    ; preds = %cond.false.3798, %cond.true.3779
  %cond3804 = phi i64 [ %sub3797, %cond.true.3779 ], [ %add3802, %cond.false.3798 ]
  %cmp3805 = icmp ult i64 %cond3804, 0
  br i1 %cmp3805, label %cond.true.3807, label %cond.false.3872

cond.true.3807:                                   ; preds = %cond.end.3803
  %611 = load i64, i64* %alloca_size, align 8
  %cmp3808 = icmp slt i64 %611, 0
  br i1 %cmp3808, label %cond.true.3810, label %cond.false.3846

cond.true.3810:                                   ; preds = %cond.true.3807
  %612 = load i64, i64* %alloca_size, align 8
  %mul3811 = mul nsw i64 0, %612
  %add3812 = add i64 %mul3811, 24
  %mul3813 = mul i64 0, %add3812
  %sub3814 = sub i64 %mul3813, 1
  %cmp3815 = icmp ult i64 %sub3814, 0
  br i1 %cmp3815, label %cond.true.3817, label %cond.false.3836

cond.true.3817:                                   ; preds = %cond.true.3810
  %613 = load i64, i64* %alloca_size, align 8
  %mul3818 = mul nsw i64 0, %613
  %add3819 = add i64 %mul3818, 24
  %mul3820 = mul i64 0, %add3819
  %add3821 = add i64 %mul3820, 0
  %neg3822 = xor i64 %add3821, -1
  %cmp3823 = icmp eq i64 %neg3822, -1
  %conv3824 = zext i1 %cmp3823 to i32
  %sub3825 = sub nsw i32 0, %conv3824
  %conv3826 = sext i32 %sub3825 to i64
  %614 = load i64, i64* %alloca_size, align 8
  %mul3827 = mul nsw i64 0, %614
  %add3828 = add i64 %mul3827, 24
  %mul3829 = mul i64 0, %add3828
  %add3830 = add i64 %mul3829, 1
  %shl3831 = shl i64 %add3830, 62
  %sub3832 = sub i64 %shl3831, 1
  %mul3833 = mul i64 %sub3832, 2
  %add3834 = add i64 %mul3833, 1
  %sub3835 = sub i64 %conv3826, %add3834
  br label %cond.end.3841

cond.false.3836:                                  ; preds = %cond.true.3810
  %615 = load i64, i64* %alloca_size, align 8
  %mul3837 = mul nsw i64 0, %615
  %add3838 = add i64 %mul3837, 24
  %mul3839 = mul i64 0, %add3838
  %add3840 = add i64 %mul3839, 0
  br label %cond.end.3841

cond.end.3841:                                    ; preds = %cond.false.3836, %cond.true.3817
  %cond3842 = phi i64 [ %sub3835, %cond.true.3817 ], [ %add3840, %cond.false.3836 ]
  %616 = load i64, i64* %alloca_size, align 8
  %sub3843 = sub i64 %cond3842, %616
  %cmp3844 = icmp ult i64 24, %sub3843
  br i1 %cmp3844, label %cond.true.3902, label %lor.lhs.false.3888

cond.false.3846:                                  ; preds = %cond.true.3807
  %617 = load i64, i64* %alloca_size, align 8
  %mul3847 = mul nsw i64 0, %617
  %add3848 = add i64 %mul3847, 24
  %mul3849 = mul i64 0, %add3848
  %sub3850 = sub i64 %mul3849, 1
  %cmp3851 = icmp ult i64 %sub3850, 0
  br i1 %cmp3851, label %cond.true.3853, label %cond.false.3862

cond.true.3853:                                   ; preds = %cond.false.3846
  %618 = load i64, i64* %alloca_size, align 8
  %mul3854 = mul nsw i64 0, %618
  %add3855 = add i64 %mul3854, 24
  %mul3856 = mul i64 0, %add3855
  %add3857 = add i64 %mul3856, 1
  %shl3858 = shl i64 %add3857, 62
  %sub3859 = sub i64 %shl3858, 1
  %mul3860 = mul i64 %sub3859, 2
  %add3861 = add i64 %mul3860, 1
  br label %cond.end.3867

cond.false.3862:                                  ; preds = %cond.false.3846
  %619 = load i64, i64* %alloca_size, align 8
  %mul3863 = mul nsw i64 0, %619
  %add3864 = add i64 %mul3863, 24
  %mul3865 = mul i64 0, %add3864
  %sub3866 = sub i64 %mul3865, 1
  br label %cond.end.3867

cond.end.3867:                                    ; preds = %cond.false.3862, %cond.true.3853
  %cond3868 = phi i64 [ %add3861, %cond.true.3853 ], [ %sub3866, %cond.false.3862 ]
  %620 = load i64, i64* %alloca_size, align 8
  %sub3869 = sub i64 %cond3868, %620
  %cmp3870 = icmp ult i64 %sub3869, 24
  br i1 %cmp3870, label %cond.true.3902, label %lor.lhs.false.3888

cond.false.3872:                                  ; preds = %cond.end.3803
  br i1 false, label %cond.true.3873, label %cond.false.3877

cond.true.3873:                                   ; preds = %cond.false.3872
  %621 = load i64, i64* %alloca_size, align 8
  %622 = load i64, i64* %alloca_size, align 8
  %add3874 = add i64 24, %622
  %cmp3875 = icmp ule i64 %621, %add3874
  br i1 %cmp3875, label %cond.true.3902, label %lor.lhs.false.3888

cond.false.3877:                                  ; preds = %cond.false.3872
  %623 = load i64, i64* %alloca_size, align 8
  %cmp3878 = icmp slt i64 %623, 0
  br i1 %cmp3878, label %cond.true.3880, label %cond.false.3884

cond.true.3880:                                   ; preds = %cond.false.3877
  %624 = load i64, i64* %alloca_size, align 8
  %add3881 = add i64 24, %624
  %cmp3882 = icmp ule i64 24, %add3881
  br i1 %cmp3882, label %cond.true.3902, label %lor.lhs.false.3888

cond.false.3884:                                  ; preds = %cond.false.3877
  %625 = load i64, i64* %alloca_size, align 8
  %add3885 = add i64 24, %625
  %626 = load i64, i64* %alloca_size, align 8
  %cmp3886 = icmp ult i64 %add3885, %626
  br i1 %cmp3886, label %cond.true.3902, label %lor.lhs.false.3888

lor.lhs.false.3888:                               ; preds = %cond.false.3884, %cond.true.3880, %cond.true.3873, %cond.end.3867, %cond.end.3841
  %627 = load i64, i64* %alloca_size, align 8
  %add3889 = add i64 24, %627
  %mul3890 = mul i64 0, %add3889
  %sub3891 = sub i64 %mul3890, 1
  %cmp3892 = icmp ult i64 %sub3891, 0
  br i1 %cmp3892, label %land.lhs.true.3894, label %lor.lhs.false.3898

land.lhs.true.3894:                               ; preds = %lor.lhs.false.3888
  %628 = load i64, i64* %alloca_size, align 8
  %add3895 = add i64 24, %628
  %cmp3896 = icmp ult i64 %add3895, -9223372036854775808
  br i1 %cmp3896, label %cond.true.3902, label %lor.lhs.false.3898

lor.lhs.false.3898:                               ; preds = %land.lhs.true.3894, %lor.lhs.false.3888
  %629 = load i64, i64* %alloca_size, align 8
  %add3899 = add i64 24, %629
  %cmp3900 = icmp ult i64 9223372036854775807, %add3899
  br i1 %cmp3900, label %cond.true.3902, label %cond.false.3914

cond.true.3902:                                   ; preds = %lor.lhs.false.3898, %land.lhs.true.3894, %cond.false.3884, %cond.true.3880, %cond.true.3873, %cond.end.3867, %cond.end.3841
  %630 = load i64, i64* %alloca_size, align 8
  %add3903 = add i64 24, %630
  %cmp3904 = icmp ule i64 %add3903, 9223372036854775807
  br i1 %cmp3904, label %cond.true.3906, label %cond.false.3908

cond.true.3906:                                   ; preds = %cond.true.3902
  %631 = load i64, i64* %alloca_size, align 8
  %add3907 = add i64 24, %631
  br label %cond.end.3912

cond.false.3908:                                  ; preds = %cond.true.3902
  %632 = load i64, i64* %alloca_size, align 8
  %add3909 = add i64 24, %632
  %sub3910 = sub i64 %add3909, -9223372036854775808
  %add3911 = add nsw i64 %sub3910, -9223372036854775808
  br label %cond.end.3912

cond.end.3912:                                    ; preds = %cond.false.3908, %cond.true.3906
  %cond3913 = phi i64 [ %add3907, %cond.true.3906 ], [ %add3911, %cond.false.3908 ]
  store i64 %cond3913, i64* %alloca_size, align 8
  br i1 true, label %if.then, label %lor.lhs.false.3926

cond.false.3914:                                  ; preds = %lor.lhs.false.3898
  %633 = load i64, i64* %alloca_size, align 8
  %add3915 = add i64 24, %633
  %cmp3916 = icmp ule i64 %add3915, 9223372036854775807
  br i1 %cmp3916, label %cond.true.3918, label %cond.false.3920

cond.true.3918:                                   ; preds = %cond.false.3914
  %634 = load i64, i64* %alloca_size, align 8
  %add3919 = add i64 24, %634
  br label %cond.end.3924

cond.false.3920:                                  ; preds = %cond.false.3914
  %635 = load i64, i64* %alloca_size, align 8
  %add3921 = add i64 24, %635
  %sub3922 = sub i64 %add3921, -9223372036854775808
  %add3923 = add nsw i64 %sub3922, -9223372036854775808
  br label %cond.end.3924

cond.end.3924:                                    ; preds = %cond.false.3920, %cond.true.3918
  %cond3925 = phi i64 [ %add3919, %cond.true.3918 ], [ %add3923, %cond.false.3920 ]
  store i64 %cond3925, i64* %alloca_size, align 8
  br i1 false, label %if.then, label %lor.lhs.false.3926

lor.lhs.false.3926:                               ; preds = %cond.end.3924, %cond.end.3912, %cond.end.3770, %cond.end.3758, %cond.end.3615, %cond.end.3603, %cond.end.3461, %cond.end.3449, %cond.end.3304, %cond.end.3288, %cond.end.3142, %cond.end.3126, %cond.end.2957, %cond.end.2934, %cond.end.2781, %cond.end.2758, %cond.end.2559, %cond.end.2536, %cond.end.2383, %cond.end.2360
  br i1 false, label %cond.true.3927, label %cond.false.4394

cond.true.3927:                                   ; preds = %lor.lhs.false.3926
  br i1 false, label %cond.true.3928, label %cond.false.4204

cond.true.3928:                                   ; preds = %cond.true.3927
  %636 = load i64, i64* %alloca_size, align 8
  %conv3929 = trunc i64 %636 to i8
  %conv3930 = sext i8 %conv3929 to i32
  %mul3931 = mul nsw i32 0, %conv3930
  %637 = load i64, i64* %formatlen, align 8
  %conv3932 = trunc i64 %637 to i8
  %conv3933 = sext i8 %conv3932 to i32
  %add3934 = add nsw i32 %mul3931, %conv3933
  %mul3935 = mul nsw i32 0, %add3934
  %sub3936 = sub nsw i32 %mul3935, 1
  %cmp3937 = icmp slt i32 %sub3936, 0
  br i1 %cmp3937, label %cond.true.3939, label %cond.false.3965

cond.true.3939:                                   ; preds = %cond.true.3928
  %638 = load i64, i64* %alloca_size, align 8
  %conv3940 = trunc i64 %638 to i8
  %conv3941 = sext i8 %conv3940 to i32
  %mul3942 = mul nsw i32 0, %conv3941
  %639 = load i64, i64* %formatlen, align 8
  %conv3943 = trunc i64 %639 to i8
  %conv3944 = sext i8 %conv3943 to i32
  %add3945 = add nsw i32 %mul3942, %conv3944
  %mul3946 = mul nsw i32 0, %add3945
  %add3947 = add nsw i32 %mul3946, 0
  %neg3948 = xor i32 %add3947, -1
  %cmp3949 = icmp eq i32 %neg3948, -1
  %conv3950 = zext i1 %cmp3949 to i32
  %sub3951 = sub nsw i32 0, %conv3950
  %640 = load i64, i64* %alloca_size, align 8
  %conv3952 = trunc i64 %640 to i8
  %conv3953 = sext i8 %conv3952 to i32
  %mul3954 = mul nsw i32 0, %conv3953
  %641 = load i64, i64* %formatlen, align 8
  %conv3955 = trunc i64 %641 to i8
  %conv3956 = sext i8 %conv3955 to i32
  %add3957 = add nsw i32 %mul3954, %conv3956
  %mul3958 = mul nsw i32 0, %add3957
  %add3959 = add nsw i32 %mul3958, 1
  %shl3960 = shl i32 %add3959, 30
  %sub3961 = sub nsw i32 %shl3960, 1
  %mul3962 = mul nsw i32 %sub3961, 2
  %add3963 = add nsw i32 %mul3962, 1
  %sub3964 = sub nsw i32 %sub3951, %add3963
  br label %cond.end.3974

cond.false.3965:                                  ; preds = %cond.true.3928
  %642 = load i64, i64* %alloca_size, align 8
  %conv3966 = trunc i64 %642 to i8
  %conv3967 = sext i8 %conv3966 to i32
  %mul3968 = mul nsw i32 0, %conv3967
  %643 = load i64, i64* %formatlen, align 8
  %conv3969 = trunc i64 %643 to i8
  %conv3970 = sext i8 %conv3969 to i32
  %add3971 = add nsw i32 %mul3968, %conv3970
  %mul3972 = mul nsw i32 0, %add3971
  %add3973 = add nsw i32 %mul3972, 0
  br label %cond.end.3974

cond.end.3974:                                    ; preds = %cond.false.3965, %cond.true.3939
  %cond3975 = phi i32 [ %sub3964, %cond.true.3939 ], [ %add3973, %cond.false.3965 ]
  %cmp3976 = icmp slt i32 %cond3975, 0
  br i1 %cmp3976, label %cond.true.3978, label %cond.false.4080

cond.true.3978:                                   ; preds = %cond.end.3974
  %644 = load i64, i64* %alloca_size, align 8
  %conv3979 = trunc i64 %644 to i8
  %conv3980 = sext i8 %conv3979 to i32
  %cmp3981 = icmp slt i32 %conv3980, 0
  br i1 %cmp3981, label %cond.true.3983, label %cond.false.4038

cond.true.3983:                                   ; preds = %cond.true.3978
  %645 = load i64, i64* %formatlen, align 8
  %conv3984 = trunc i64 %645 to i8
  %conv3985 = sext i8 %conv3984 to i32
  %646 = load i64, i64* %alloca_size, align 8
  %conv3986 = trunc i64 %646 to i8
  %conv3987 = sext i8 %conv3986 to i32
  %mul3988 = mul nsw i32 0, %conv3987
  %647 = load i64, i64* %formatlen, align 8
  %conv3989 = trunc i64 %647 to i8
  %conv3990 = sext i8 %conv3989 to i32
  %add3991 = add nsw i32 %mul3988, %conv3990
  %mul3992 = mul nsw i32 0, %add3991
  %sub3993 = sub nsw i32 %mul3992, 1
  %cmp3994 = icmp slt i32 %sub3993, 0
  br i1 %cmp3994, label %cond.true.3996, label %cond.false.4022

cond.true.3996:                                   ; preds = %cond.true.3983
  %648 = load i64, i64* %alloca_size, align 8
  %conv3997 = trunc i64 %648 to i8
  %conv3998 = sext i8 %conv3997 to i32
  %mul3999 = mul nsw i32 0, %conv3998
  %649 = load i64, i64* %formatlen, align 8
  %conv4000 = trunc i64 %649 to i8
  %conv4001 = sext i8 %conv4000 to i32
  %add4002 = add nsw i32 %mul3999, %conv4001
  %mul4003 = mul nsw i32 0, %add4002
  %add4004 = add nsw i32 %mul4003, 0
  %neg4005 = xor i32 %add4004, -1
  %cmp4006 = icmp eq i32 %neg4005, -1
  %conv4007 = zext i1 %cmp4006 to i32
  %sub4008 = sub nsw i32 0, %conv4007
  %650 = load i64, i64* %alloca_size, align 8
  %conv4009 = trunc i64 %650 to i8
  %conv4010 = sext i8 %conv4009 to i32
  %mul4011 = mul nsw i32 0, %conv4010
  %651 = load i64, i64* %formatlen, align 8
  %conv4012 = trunc i64 %651 to i8
  %conv4013 = sext i8 %conv4012 to i32
  %add4014 = add nsw i32 %mul4011, %conv4013
  %mul4015 = mul nsw i32 0, %add4014
  %add4016 = add nsw i32 %mul4015, 1
  %shl4017 = shl i32 %add4016, 30
  %sub4018 = sub nsw i32 %shl4017, 1
  %mul4019 = mul nsw i32 %sub4018, 2
  %add4020 = add nsw i32 %mul4019, 1
  %sub4021 = sub nsw i32 %sub4008, %add4020
  br label %cond.end.4031

cond.false.4022:                                  ; preds = %cond.true.3983
  %652 = load i64, i64* %alloca_size, align 8
  %conv4023 = trunc i64 %652 to i8
  %conv4024 = sext i8 %conv4023 to i32
  %mul4025 = mul nsw i32 0, %conv4024
  %653 = load i64, i64* %formatlen, align 8
  %conv4026 = trunc i64 %653 to i8
  %conv4027 = sext i8 %conv4026 to i32
  %add4028 = add nsw i32 %mul4025, %conv4027
  %mul4029 = mul nsw i32 0, %add4028
  %add4030 = add nsw i32 %mul4029, 0
  br label %cond.end.4031

cond.end.4031:                                    ; preds = %cond.false.4022, %cond.true.3996
  %cond4032 = phi i32 [ %sub4021, %cond.true.3996 ], [ %add4030, %cond.false.4022 ]
  %654 = load i64, i64* %alloca_size, align 8
  %conv4033 = trunc i64 %654 to i8
  %conv4034 = sext i8 %conv4033 to i32
  %sub4035 = sub nsw i32 %cond4032, %conv4034
  %cmp4036 = icmp slt i32 %conv3985, %sub4035
  br i1 %cmp4036, label %cond.true.4146, label %lor.lhs.false.4120

cond.false.4038:                                  ; preds = %cond.true.3978
  %655 = load i64, i64* %alloca_size, align 8
  %conv4039 = trunc i64 %655 to i8
  %conv4040 = sext i8 %conv4039 to i32
  %mul4041 = mul nsw i32 0, %conv4040
  %656 = load i64, i64* %formatlen, align 8
  %conv4042 = trunc i64 %656 to i8
  %conv4043 = sext i8 %conv4042 to i32
  %add4044 = add nsw i32 %mul4041, %conv4043
  %mul4045 = mul nsw i32 0, %add4044
  %sub4046 = sub nsw i32 %mul4045, 1
  %cmp4047 = icmp slt i32 %sub4046, 0
  br i1 %cmp4047, label %cond.true.4049, label %cond.false.4062

cond.true.4049:                                   ; preds = %cond.false.4038
  %657 = load i64, i64* %alloca_size, align 8
  %conv4050 = trunc i64 %657 to i8
  %conv4051 = sext i8 %conv4050 to i32
  %mul4052 = mul nsw i32 0, %conv4051
  %658 = load i64, i64* %formatlen, align 8
  %conv4053 = trunc i64 %658 to i8
  %conv4054 = sext i8 %conv4053 to i32
  %add4055 = add nsw i32 %mul4052, %conv4054
  %mul4056 = mul nsw i32 0, %add4055
  %add4057 = add nsw i32 %mul4056, 1
  %shl4058 = shl i32 %add4057, 30
  %sub4059 = sub nsw i32 %shl4058, 1
  %mul4060 = mul nsw i32 %sub4059, 2
  %add4061 = add nsw i32 %mul4060, 1
  br label %cond.end.4071

cond.false.4062:                                  ; preds = %cond.false.4038
  %659 = load i64, i64* %alloca_size, align 8
  %conv4063 = trunc i64 %659 to i8
  %conv4064 = sext i8 %conv4063 to i32
  %mul4065 = mul nsw i32 0, %conv4064
  %660 = load i64, i64* %formatlen, align 8
  %conv4066 = trunc i64 %660 to i8
  %conv4067 = sext i8 %conv4066 to i32
  %add4068 = add nsw i32 %mul4065, %conv4067
  %mul4069 = mul nsw i32 0, %add4068
  %sub4070 = sub nsw i32 %mul4069, 1
  br label %cond.end.4071

cond.end.4071:                                    ; preds = %cond.false.4062, %cond.true.4049
  %cond4072 = phi i32 [ %add4061, %cond.true.4049 ], [ %sub4070, %cond.false.4062 ]
  %661 = load i64, i64* %alloca_size, align 8
  %conv4073 = trunc i64 %661 to i8
  %conv4074 = sext i8 %conv4073 to i32
  %sub4075 = sub nsw i32 %cond4072, %conv4074
  %662 = load i64, i64* %formatlen, align 8
  %conv4076 = trunc i64 %662 to i8
  %conv4077 = sext i8 %conv4076 to i32
  %cmp4078 = icmp slt i32 %sub4075, %conv4077
  br i1 %cmp4078, label %cond.true.4146, label %lor.lhs.false.4120

cond.false.4080:                                  ; preds = %cond.end.3974
  %663 = load i64, i64* %formatlen, align 8
  %conv4081 = trunc i64 %663 to i8
  %conv4082 = sext i8 %conv4081 to i32
  %cmp4083 = icmp slt i32 %conv4082, 0
  br i1 %cmp4083, label %cond.true.4085, label %cond.false.4095

cond.true.4085:                                   ; preds = %cond.false.4080
  %664 = load i64, i64* %alloca_size, align 8
  %conv4086 = trunc i64 %664 to i8
  %conv4087 = sext i8 %conv4086 to i32
  %665 = load i64, i64* %formatlen, align 8
  %conv4088 = trunc i64 %665 to i8
  %conv4089 = sext i8 %conv4088 to i32
  %666 = load i64, i64* %alloca_size, align 8
  %conv4090 = trunc i64 %666 to i8
  %conv4091 = sext i8 %conv4090 to i32
  %add4092 = add nsw i32 %conv4089, %conv4091
  %cmp4093 = icmp sle i32 %conv4087, %add4092
  br i1 %cmp4093, label %cond.true.4146, label %lor.lhs.false.4120

cond.false.4095:                                  ; preds = %cond.false.4080
  %667 = load i64, i64* %alloca_size, align 8
  %conv4096 = trunc i64 %667 to i8
  %conv4097 = sext i8 %conv4096 to i32
  %cmp4098 = icmp slt i32 %conv4097, 0
  br i1 %cmp4098, label %cond.true.4100, label %cond.false.4110

cond.true.4100:                                   ; preds = %cond.false.4095
  %668 = load i64, i64* %formatlen, align 8
  %conv4101 = trunc i64 %668 to i8
  %conv4102 = sext i8 %conv4101 to i32
  %669 = load i64, i64* %formatlen, align 8
  %conv4103 = trunc i64 %669 to i8
  %conv4104 = sext i8 %conv4103 to i32
  %670 = load i64, i64* %alloca_size, align 8
  %conv4105 = trunc i64 %670 to i8
  %conv4106 = sext i8 %conv4105 to i32
  %add4107 = add nsw i32 %conv4104, %conv4106
  %cmp4108 = icmp sle i32 %conv4102, %add4107
  br i1 %cmp4108, label %cond.true.4146, label %lor.lhs.false.4120

cond.false.4110:                                  ; preds = %cond.false.4095
  %671 = load i64, i64* %formatlen, align 8
  %conv4111 = trunc i64 %671 to i8
  %conv4112 = sext i8 %conv4111 to i32
  %672 = load i64, i64* %alloca_size, align 8
  %conv4113 = trunc i64 %672 to i8
  %conv4114 = sext i8 %conv4113 to i32
  %add4115 = add nsw i32 %conv4112, %conv4114
  %673 = load i64, i64* %alloca_size, align 8
  %conv4116 = trunc i64 %673 to i8
  %conv4117 = sext i8 %conv4116 to i32
  %cmp4118 = icmp slt i32 %add4115, %conv4117
  br i1 %cmp4118, label %cond.true.4146, label %lor.lhs.false.4120

lor.lhs.false.4120:                               ; preds = %cond.false.4110, %cond.true.4100, %cond.true.4085, %cond.end.4071, %cond.end.4031
  %674 = load i64, i64* %formatlen, align 8
  %conv4121 = trunc i64 %674 to i8
  %conv4122 = sext i8 %conv4121 to i32
  %675 = load i64, i64* %alloca_size, align 8
  %conv4123 = trunc i64 %675 to i8
  %conv4124 = sext i8 %conv4123 to i32
  %add4125 = add nsw i32 %conv4122, %conv4124
  %mul4126 = mul nsw i32 0, %add4125
  %sub4127 = sub nsw i32 %mul4126, 1
  %cmp4128 = icmp slt i32 %sub4127, 0
  br i1 %cmp4128, label %land.lhs.true.4130, label %lor.lhs.false.4138

land.lhs.true.4130:                               ; preds = %lor.lhs.false.4120
  %676 = load i64, i64* %formatlen, align 8
  %conv4131 = trunc i64 %676 to i8
  %conv4132 = sext i8 %conv4131 to i32
  %677 = load i64, i64* %alloca_size, align 8
  %conv4133 = trunc i64 %677 to i8
  %conv4134 = sext i8 %conv4133 to i32
  %add4135 = add nsw i32 %conv4132, %conv4134
  %cmp4136 = icmp slt i32 %add4135, -128
  br i1 %cmp4136, label %cond.true.4146, label %lor.lhs.false.4138

lor.lhs.false.4138:                               ; preds = %land.lhs.true.4130, %lor.lhs.false.4120
  %678 = load i64, i64* %formatlen, align 8
  %conv4139 = trunc i64 %678 to i8
  %conv4140 = sext i8 %conv4139 to i32
  %679 = load i64, i64* %alloca_size, align 8
  %conv4141 = trunc i64 %679 to i8
  %conv4142 = sext i8 %conv4141 to i32
  %add4143 = add nsw i32 %conv4140, %conv4142
  %cmp4144 = icmp slt i32 127, %add4143
  br i1 %cmp4144, label %cond.true.4146, label %cond.false.4175

cond.true.4146:                                   ; preds = %lor.lhs.false.4138, %land.lhs.true.4130, %cond.false.4110, %cond.true.4100, %cond.true.4085, %cond.end.4071, %cond.end.4031
  %680 = load i64, i64* %formatlen, align 8
  %conv4147 = trunc i64 %680 to i8
  %conv4148 = zext i8 %conv4147 to i32
  %681 = load i64, i64* %alloca_size, align 8
  %conv4149 = trunc i64 %681 to i8
  %conv4150 = zext i8 %conv4149 to i32
  %add4151 = add nsw i32 %conv4148, %conv4150
  %cmp4152 = icmp sle i32 %add4151, 127
  br i1 %cmp4152, label %cond.true.4154, label %cond.false.4162

cond.true.4154:                                   ; preds = %cond.true.4146
  %682 = load i64, i64* %formatlen, align 8
  %conv4155 = trunc i64 %682 to i8
  %conv4156 = zext i8 %conv4155 to i32
  %683 = load i64, i64* %alloca_size, align 8
  %conv4157 = trunc i64 %683 to i8
  %conv4158 = zext i8 %conv4157 to i32
  %add4159 = add nsw i32 %conv4156, %conv4158
  %conv4160 = trunc i32 %add4159 to i8
  %conv4161 = sext i8 %conv4160 to i32
  br label %cond.end.4172

cond.false.4162:                                  ; preds = %cond.true.4146
  %684 = load i64, i64* %formatlen, align 8
  %conv4163 = trunc i64 %684 to i8
  %conv4164 = zext i8 %conv4163 to i32
  %685 = load i64, i64* %alloca_size, align 8
  %conv4165 = trunc i64 %685 to i8
  %conv4166 = zext i8 %conv4165 to i32
  %add4167 = add nsw i32 %conv4164, %conv4166
  %sub4168 = sub nsw i32 %add4167, -128
  %conv4169 = trunc i32 %sub4168 to i8
  %conv4170 = sext i8 %conv4169 to i32
  %add4171 = add nsw i32 %conv4170, -128
  br label %cond.end.4172

cond.end.4172:                                    ; preds = %cond.false.4162, %cond.true.4154
  %cond4173 = phi i32 [ %conv4161, %cond.true.4154 ], [ %add4171, %cond.false.4162 ]
  %conv4174 = sext i32 %cond4173 to i64
  store i64 %conv4174, i64* %alloca_size, align 8
  br i1 true, label %if.then, label %lor.lhs.false.5873

cond.false.4175:                                  ; preds = %lor.lhs.false.4138
  %686 = load i64, i64* %formatlen, align 8
  %conv4176 = trunc i64 %686 to i8
  %conv4177 = zext i8 %conv4176 to i32
  %687 = load i64, i64* %alloca_size, align 8
  %conv4178 = trunc i64 %687 to i8
  %conv4179 = zext i8 %conv4178 to i32
  %add4180 = add nsw i32 %conv4177, %conv4179
  %cmp4181 = icmp sle i32 %add4180, 127
  br i1 %cmp4181, label %cond.true.4183, label %cond.false.4191

cond.true.4183:                                   ; preds = %cond.false.4175
  %688 = load i64, i64* %formatlen, align 8
  %conv4184 = trunc i64 %688 to i8
  %conv4185 = zext i8 %conv4184 to i32
  %689 = load i64, i64* %alloca_size, align 8
  %conv4186 = trunc i64 %689 to i8
  %conv4187 = zext i8 %conv4186 to i32
  %add4188 = add nsw i32 %conv4185, %conv4187
  %conv4189 = trunc i32 %add4188 to i8
  %conv4190 = sext i8 %conv4189 to i32
  br label %cond.end.4201

cond.false.4191:                                  ; preds = %cond.false.4175
  %690 = load i64, i64* %formatlen, align 8
  %conv4192 = trunc i64 %690 to i8
  %conv4193 = zext i8 %conv4192 to i32
  %691 = load i64, i64* %alloca_size, align 8
  %conv4194 = trunc i64 %691 to i8
  %conv4195 = zext i8 %conv4194 to i32
  %add4196 = add nsw i32 %conv4193, %conv4195
  %sub4197 = sub nsw i32 %add4196, -128
  %conv4198 = trunc i32 %sub4197 to i8
  %conv4199 = sext i8 %conv4198 to i32
  %add4200 = add nsw i32 %conv4199, -128
  br label %cond.end.4201

cond.end.4201:                                    ; preds = %cond.false.4191, %cond.true.4183
  %cond4202 = phi i32 [ %conv4190, %cond.true.4183 ], [ %add4200, %cond.false.4191 ]
  %conv4203 = sext i32 %cond4202 to i64
  store i64 %conv4203, i64* %alloca_size, align 8
  br i1 false, label %if.then, label %lor.lhs.false.5873

cond.false.4204:                                  ; preds = %cond.true.3927
  %692 = load i64, i64* %alloca_size, align 8
  %mul4205 = mul nsw i64 0, %692
  %693 = load i64, i64* %formatlen, align 8
  %add4206 = add nsw i64 %mul4205, %693
  %mul4207 = mul nsw i64 0, %add4206
  %sub4208 = sub nsw i64 %mul4207, 1
  %cmp4209 = icmp slt i64 %sub4208, 0
  br i1 %cmp4209, label %cond.true.4211, label %cond.false.4230

cond.true.4211:                                   ; preds = %cond.false.4204
  %694 = load i64, i64* %alloca_size, align 8
  %mul4212 = mul nsw i64 0, %694
  %695 = load i64, i64* %formatlen, align 8
  %add4213 = add nsw i64 %mul4212, %695
  %mul4214 = mul nsw i64 0, %add4213
  %add4215 = add nsw i64 %mul4214, 0
  %neg4216 = xor i64 %add4215, -1
  %cmp4217 = icmp eq i64 %neg4216, -1
  %conv4218 = zext i1 %cmp4217 to i32
  %sub4219 = sub nsw i32 0, %conv4218
  %conv4220 = sext i32 %sub4219 to i64
  %696 = load i64, i64* %alloca_size, align 8
  %mul4221 = mul nsw i64 0, %696
  %697 = load i64, i64* %formatlen, align 8
  %add4222 = add nsw i64 %mul4221, %697
  %mul4223 = mul nsw i64 0, %add4222
  %add4224 = add nsw i64 %mul4223, 1
  %shl4225 = shl i64 %add4224, 62
  %sub4226 = sub nsw i64 %shl4225, 1
  %mul4227 = mul nsw i64 %sub4226, 2
  %add4228 = add nsw i64 %mul4227, 1
  %sub4229 = sub nsw i64 %conv4220, %add4228
  br label %cond.end.4235

cond.false.4230:                                  ; preds = %cond.false.4204
  %698 = load i64, i64* %alloca_size, align 8
  %mul4231 = mul nsw i64 0, %698
  %699 = load i64, i64* %formatlen, align 8
  %add4232 = add nsw i64 %mul4231, %699
  %mul4233 = mul nsw i64 0, %add4232
  %add4234 = add nsw i64 %mul4233, 0
  br label %cond.end.4235

cond.end.4235:                                    ; preds = %cond.false.4230, %cond.true.4211
  %cond4236 = phi i64 [ %sub4229, %cond.true.4211 ], [ %add4234, %cond.false.4230 ]
  %cmp4237 = icmp slt i64 %cond4236, 0
  br i1 %cmp4237, label %cond.true.4239, label %cond.false.4304

cond.true.4239:                                   ; preds = %cond.end.4235
  %700 = load i64, i64* %alloca_size, align 8
  %cmp4240 = icmp slt i64 %700, 0
  br i1 %cmp4240, label %cond.true.4242, label %cond.false.4278

cond.true.4242:                                   ; preds = %cond.true.4239
  %701 = load i64, i64* %formatlen, align 8
  %702 = load i64, i64* %alloca_size, align 8
  %mul4243 = mul nsw i64 0, %702
  %703 = load i64, i64* %formatlen, align 8
  %add4244 = add nsw i64 %mul4243, %703
  %mul4245 = mul nsw i64 0, %add4244
  %sub4246 = sub nsw i64 %mul4245, 1
  %cmp4247 = icmp slt i64 %sub4246, 0
  br i1 %cmp4247, label %cond.true.4249, label %cond.false.4268

cond.true.4249:                                   ; preds = %cond.true.4242
  %704 = load i64, i64* %alloca_size, align 8
  %mul4250 = mul nsw i64 0, %704
  %705 = load i64, i64* %formatlen, align 8
  %add4251 = add nsw i64 %mul4250, %705
  %mul4252 = mul nsw i64 0, %add4251
  %add4253 = add nsw i64 %mul4252, 0
  %neg4254 = xor i64 %add4253, -1
  %cmp4255 = icmp eq i64 %neg4254, -1
  %conv4256 = zext i1 %cmp4255 to i32
  %sub4257 = sub nsw i32 0, %conv4256
  %conv4258 = sext i32 %sub4257 to i64
  %706 = load i64, i64* %alloca_size, align 8
  %mul4259 = mul nsw i64 0, %706
  %707 = load i64, i64* %formatlen, align 8
  %add4260 = add nsw i64 %mul4259, %707
  %mul4261 = mul nsw i64 0, %add4260
  %add4262 = add nsw i64 %mul4261, 1
  %shl4263 = shl i64 %add4262, 62
  %sub4264 = sub nsw i64 %shl4263, 1
  %mul4265 = mul nsw i64 %sub4264, 2
  %add4266 = add nsw i64 %mul4265, 1
  %sub4267 = sub nsw i64 %conv4258, %add4266
  br label %cond.end.4273

cond.false.4268:                                  ; preds = %cond.true.4242
  %708 = load i64, i64* %alloca_size, align 8
  %mul4269 = mul nsw i64 0, %708
  %709 = load i64, i64* %formatlen, align 8
  %add4270 = add nsw i64 %mul4269, %709
  %mul4271 = mul nsw i64 0, %add4270
  %add4272 = add nsw i64 %mul4271, 0
  br label %cond.end.4273

cond.end.4273:                                    ; preds = %cond.false.4268, %cond.true.4249
  %cond4274 = phi i64 [ %sub4267, %cond.true.4249 ], [ %add4272, %cond.false.4268 ]
  %710 = load i64, i64* %alloca_size, align 8
  %sub4275 = sub nsw i64 %cond4274, %710
  %cmp4276 = icmp slt i64 %701, %sub4275
  br i1 %cmp4276, label %cond.true.4336, label %lor.lhs.false.4322

cond.false.4278:                                  ; preds = %cond.true.4239
  %711 = load i64, i64* %alloca_size, align 8
  %mul4279 = mul nsw i64 0, %711
  %712 = load i64, i64* %formatlen, align 8
  %add4280 = add nsw i64 %mul4279, %712
  %mul4281 = mul nsw i64 0, %add4280
  %sub4282 = sub nsw i64 %mul4281, 1
  %cmp4283 = icmp slt i64 %sub4282, 0
  br i1 %cmp4283, label %cond.true.4285, label %cond.false.4294

cond.true.4285:                                   ; preds = %cond.false.4278
  %713 = load i64, i64* %alloca_size, align 8
  %mul4286 = mul nsw i64 0, %713
  %714 = load i64, i64* %formatlen, align 8
  %add4287 = add nsw i64 %mul4286, %714
  %mul4288 = mul nsw i64 0, %add4287
  %add4289 = add nsw i64 %mul4288, 1
  %shl4290 = shl i64 %add4289, 62
  %sub4291 = sub nsw i64 %shl4290, 1
  %mul4292 = mul nsw i64 %sub4291, 2
  %add4293 = add nsw i64 %mul4292, 1
  br label %cond.end.4299

cond.false.4294:                                  ; preds = %cond.false.4278
  %715 = load i64, i64* %alloca_size, align 8
  %mul4295 = mul nsw i64 0, %715
  %716 = load i64, i64* %formatlen, align 8
  %add4296 = add nsw i64 %mul4295, %716
  %mul4297 = mul nsw i64 0, %add4296
  %sub4298 = sub nsw i64 %mul4297, 1
  br label %cond.end.4299

cond.end.4299:                                    ; preds = %cond.false.4294, %cond.true.4285
  %cond4300 = phi i64 [ %add4293, %cond.true.4285 ], [ %sub4298, %cond.false.4294 ]
  %717 = load i64, i64* %alloca_size, align 8
  %sub4301 = sub nsw i64 %cond4300, %717
  %718 = load i64, i64* %formatlen, align 8
  %cmp4302 = icmp slt i64 %sub4301, %718
  br i1 %cmp4302, label %cond.true.4336, label %lor.lhs.false.4322

cond.false.4304:                                  ; preds = %cond.end.4235
  %719 = load i64, i64* %formatlen, align 8
  %cmp4305 = icmp slt i64 %719, 0
  br i1 %cmp4305, label %cond.true.4307, label %cond.false.4311

cond.true.4307:                                   ; preds = %cond.false.4304
  %720 = load i64, i64* %alloca_size, align 8
  %721 = load i64, i64* %formatlen, align 8
  %722 = load i64, i64* %alloca_size, align 8
  %add4308 = add nsw i64 %721, %722
  %cmp4309 = icmp sle i64 %720, %add4308
  br i1 %cmp4309, label %cond.true.4336, label %lor.lhs.false.4322

cond.false.4311:                                  ; preds = %cond.false.4304
  %723 = load i64, i64* %alloca_size, align 8
  %cmp4312 = icmp slt i64 %723, 0
  br i1 %cmp4312, label %cond.true.4314, label %cond.false.4318

cond.true.4314:                                   ; preds = %cond.false.4311
  %724 = load i64, i64* %formatlen, align 8
  %725 = load i64, i64* %formatlen, align 8
  %726 = load i64, i64* %alloca_size, align 8
  %add4315 = add nsw i64 %725, %726
  %cmp4316 = icmp sle i64 %724, %add4315
  br i1 %cmp4316, label %cond.true.4336, label %lor.lhs.false.4322

cond.false.4318:                                  ; preds = %cond.false.4311
  %727 = load i64, i64* %formatlen, align 8
  %728 = load i64, i64* %alloca_size, align 8
  %add4319 = add nsw i64 %727, %728
  %729 = load i64, i64* %alloca_size, align 8
  %cmp4320 = icmp slt i64 %add4319, %729
  br i1 %cmp4320, label %cond.true.4336, label %lor.lhs.false.4322

lor.lhs.false.4322:                               ; preds = %cond.false.4318, %cond.true.4314, %cond.true.4307, %cond.end.4299, %cond.end.4273
  %730 = load i64, i64* %formatlen, align 8
  %731 = load i64, i64* %alloca_size, align 8
  %add4323 = add nsw i64 %730, %731
  %mul4324 = mul nsw i64 0, %add4323
  %sub4325 = sub nsw i64 %mul4324, 1
  %cmp4326 = icmp slt i64 %sub4325, 0
  br i1 %cmp4326, label %land.lhs.true.4328, label %lor.lhs.false.4332

land.lhs.true.4328:                               ; preds = %lor.lhs.false.4322
  %732 = load i64, i64* %formatlen, align 8
  %733 = load i64, i64* %alloca_size, align 8
  %add4329 = add nsw i64 %732, %733
  %cmp4330 = icmp slt i64 %add4329, -128
  br i1 %cmp4330, label %cond.true.4336, label %lor.lhs.false.4332

lor.lhs.false.4332:                               ; preds = %land.lhs.true.4328, %lor.lhs.false.4322
  %734 = load i64, i64* %formatlen, align 8
  %735 = load i64, i64* %alloca_size, align 8
  %add4333 = add nsw i64 %734, %735
  %cmp4334 = icmp slt i64 127, %add4333
  br i1 %cmp4334, label %cond.true.4336, label %cond.false.4365

cond.true.4336:                                   ; preds = %lor.lhs.false.4332, %land.lhs.true.4328, %cond.false.4318, %cond.true.4314, %cond.true.4307, %cond.end.4299, %cond.end.4273
  %736 = load i64, i64* %formatlen, align 8
  %conv4337 = trunc i64 %736 to i8
  %conv4338 = zext i8 %conv4337 to i32
  %737 = load i64, i64* %alloca_size, align 8
  %conv4339 = trunc i64 %737 to i8
  %conv4340 = zext i8 %conv4339 to i32
  %add4341 = add nsw i32 %conv4338, %conv4340
  %cmp4342 = icmp sle i32 %add4341, 127
  br i1 %cmp4342, label %cond.true.4344, label %cond.false.4352

cond.true.4344:                                   ; preds = %cond.true.4336
  %738 = load i64, i64* %formatlen, align 8
  %conv4345 = trunc i64 %738 to i8
  %conv4346 = zext i8 %conv4345 to i32
  %739 = load i64, i64* %alloca_size, align 8
  %conv4347 = trunc i64 %739 to i8
  %conv4348 = zext i8 %conv4347 to i32
  %add4349 = add nsw i32 %conv4346, %conv4348
  %conv4350 = trunc i32 %add4349 to i8
  %conv4351 = sext i8 %conv4350 to i32
  br label %cond.end.4362

cond.false.4352:                                  ; preds = %cond.true.4336
  %740 = load i64, i64* %formatlen, align 8
  %conv4353 = trunc i64 %740 to i8
  %conv4354 = zext i8 %conv4353 to i32
  %741 = load i64, i64* %alloca_size, align 8
  %conv4355 = trunc i64 %741 to i8
  %conv4356 = zext i8 %conv4355 to i32
  %add4357 = add nsw i32 %conv4354, %conv4356
  %sub4358 = sub nsw i32 %add4357, -128
  %conv4359 = trunc i32 %sub4358 to i8
  %conv4360 = sext i8 %conv4359 to i32
  %add4361 = add nsw i32 %conv4360, -128
  br label %cond.end.4362

cond.end.4362:                                    ; preds = %cond.false.4352, %cond.true.4344
  %cond4363 = phi i32 [ %conv4351, %cond.true.4344 ], [ %add4361, %cond.false.4352 ]
  %conv4364 = sext i32 %cond4363 to i64
  store i64 %conv4364, i64* %alloca_size, align 8
  br i1 true, label %if.then, label %lor.lhs.false.5873

cond.false.4365:                                  ; preds = %lor.lhs.false.4332
  %742 = load i64, i64* %formatlen, align 8
  %conv4366 = trunc i64 %742 to i8
  %conv4367 = zext i8 %conv4366 to i32
  %743 = load i64, i64* %alloca_size, align 8
  %conv4368 = trunc i64 %743 to i8
  %conv4369 = zext i8 %conv4368 to i32
  %add4370 = add nsw i32 %conv4367, %conv4369
  %cmp4371 = icmp sle i32 %add4370, 127
  br i1 %cmp4371, label %cond.true.4373, label %cond.false.4381

cond.true.4373:                                   ; preds = %cond.false.4365
  %744 = load i64, i64* %formatlen, align 8
  %conv4374 = trunc i64 %744 to i8
  %conv4375 = zext i8 %conv4374 to i32
  %745 = load i64, i64* %alloca_size, align 8
  %conv4376 = trunc i64 %745 to i8
  %conv4377 = zext i8 %conv4376 to i32
  %add4378 = add nsw i32 %conv4375, %conv4377
  %conv4379 = trunc i32 %add4378 to i8
  %conv4380 = sext i8 %conv4379 to i32
  br label %cond.end.4391

cond.false.4381:                                  ; preds = %cond.false.4365
  %746 = load i64, i64* %formatlen, align 8
  %conv4382 = trunc i64 %746 to i8
  %conv4383 = zext i8 %conv4382 to i32
  %747 = load i64, i64* %alloca_size, align 8
  %conv4384 = trunc i64 %747 to i8
  %conv4385 = zext i8 %conv4384 to i32
  %add4386 = add nsw i32 %conv4383, %conv4385
  %sub4387 = sub nsw i32 %add4386, -128
  %conv4388 = trunc i32 %sub4387 to i8
  %conv4389 = sext i8 %conv4388 to i32
  %add4390 = add nsw i32 %conv4389, -128
  br label %cond.end.4391

cond.end.4391:                                    ; preds = %cond.false.4381, %cond.true.4373
  %cond4392 = phi i32 [ %conv4380, %cond.true.4373 ], [ %add4390, %cond.false.4381 ]
  %conv4393 = sext i32 %cond4392 to i64
  store i64 %conv4393, i64* %alloca_size, align 8
  br i1 false, label %if.then, label %lor.lhs.false.5873

cond.false.4394:                                  ; preds = %lor.lhs.false.3926
  br i1 false, label %cond.true.4395, label %cond.false.4862

cond.true.4395:                                   ; preds = %cond.false.4394
  br i1 false, label %cond.true.4396, label %cond.false.4672

cond.true.4396:                                   ; preds = %cond.true.4395
  %748 = load i64, i64* %alloca_size, align 8
  %conv4397 = trunc i64 %748 to i16
  %conv4398 = sext i16 %conv4397 to i32
  %mul4399 = mul nsw i32 0, %conv4398
  %749 = load i64, i64* %formatlen, align 8
  %conv4400 = trunc i64 %749 to i16
  %conv4401 = sext i16 %conv4400 to i32
  %add4402 = add nsw i32 %mul4399, %conv4401
  %mul4403 = mul nsw i32 0, %add4402
  %sub4404 = sub nsw i32 %mul4403, 1
  %cmp4405 = icmp slt i32 %sub4404, 0
  br i1 %cmp4405, label %cond.true.4407, label %cond.false.4433

cond.true.4407:                                   ; preds = %cond.true.4396
  %750 = load i64, i64* %alloca_size, align 8
  %conv4408 = trunc i64 %750 to i16
  %conv4409 = sext i16 %conv4408 to i32
  %mul4410 = mul nsw i32 0, %conv4409
  %751 = load i64, i64* %formatlen, align 8
  %conv4411 = trunc i64 %751 to i16
  %conv4412 = sext i16 %conv4411 to i32
  %add4413 = add nsw i32 %mul4410, %conv4412
  %mul4414 = mul nsw i32 0, %add4413
  %add4415 = add nsw i32 %mul4414, 0
  %neg4416 = xor i32 %add4415, -1
  %cmp4417 = icmp eq i32 %neg4416, -1
  %conv4418 = zext i1 %cmp4417 to i32
  %sub4419 = sub nsw i32 0, %conv4418
  %752 = load i64, i64* %alloca_size, align 8
  %conv4420 = trunc i64 %752 to i16
  %conv4421 = sext i16 %conv4420 to i32
  %mul4422 = mul nsw i32 0, %conv4421
  %753 = load i64, i64* %formatlen, align 8
  %conv4423 = trunc i64 %753 to i16
  %conv4424 = sext i16 %conv4423 to i32
  %add4425 = add nsw i32 %mul4422, %conv4424
  %mul4426 = mul nsw i32 0, %add4425
  %add4427 = add nsw i32 %mul4426, 1
  %shl4428 = shl i32 %add4427, 30
  %sub4429 = sub nsw i32 %shl4428, 1
  %mul4430 = mul nsw i32 %sub4429, 2
  %add4431 = add nsw i32 %mul4430, 1
  %sub4432 = sub nsw i32 %sub4419, %add4431
  br label %cond.end.4442

cond.false.4433:                                  ; preds = %cond.true.4396
  %754 = load i64, i64* %alloca_size, align 8
  %conv4434 = trunc i64 %754 to i16
  %conv4435 = sext i16 %conv4434 to i32
  %mul4436 = mul nsw i32 0, %conv4435
  %755 = load i64, i64* %formatlen, align 8
  %conv4437 = trunc i64 %755 to i16
  %conv4438 = sext i16 %conv4437 to i32
  %add4439 = add nsw i32 %mul4436, %conv4438
  %mul4440 = mul nsw i32 0, %add4439
  %add4441 = add nsw i32 %mul4440, 0
  br label %cond.end.4442

cond.end.4442:                                    ; preds = %cond.false.4433, %cond.true.4407
  %cond4443 = phi i32 [ %sub4432, %cond.true.4407 ], [ %add4441, %cond.false.4433 ]
  %cmp4444 = icmp slt i32 %cond4443, 0
  br i1 %cmp4444, label %cond.true.4446, label %cond.false.4548

cond.true.4446:                                   ; preds = %cond.end.4442
  %756 = load i64, i64* %alloca_size, align 8
  %conv4447 = trunc i64 %756 to i16
  %conv4448 = sext i16 %conv4447 to i32
  %cmp4449 = icmp slt i32 %conv4448, 0
  br i1 %cmp4449, label %cond.true.4451, label %cond.false.4506

cond.true.4451:                                   ; preds = %cond.true.4446
  %757 = load i64, i64* %formatlen, align 8
  %conv4452 = trunc i64 %757 to i16
  %conv4453 = sext i16 %conv4452 to i32
  %758 = load i64, i64* %alloca_size, align 8
  %conv4454 = trunc i64 %758 to i16
  %conv4455 = sext i16 %conv4454 to i32
  %mul4456 = mul nsw i32 0, %conv4455
  %759 = load i64, i64* %formatlen, align 8
  %conv4457 = trunc i64 %759 to i16
  %conv4458 = sext i16 %conv4457 to i32
  %add4459 = add nsw i32 %mul4456, %conv4458
  %mul4460 = mul nsw i32 0, %add4459
  %sub4461 = sub nsw i32 %mul4460, 1
  %cmp4462 = icmp slt i32 %sub4461, 0
  br i1 %cmp4462, label %cond.true.4464, label %cond.false.4490

cond.true.4464:                                   ; preds = %cond.true.4451
  %760 = load i64, i64* %alloca_size, align 8
  %conv4465 = trunc i64 %760 to i16
  %conv4466 = sext i16 %conv4465 to i32
  %mul4467 = mul nsw i32 0, %conv4466
  %761 = load i64, i64* %formatlen, align 8
  %conv4468 = trunc i64 %761 to i16
  %conv4469 = sext i16 %conv4468 to i32
  %add4470 = add nsw i32 %mul4467, %conv4469
  %mul4471 = mul nsw i32 0, %add4470
  %add4472 = add nsw i32 %mul4471, 0
  %neg4473 = xor i32 %add4472, -1
  %cmp4474 = icmp eq i32 %neg4473, -1
  %conv4475 = zext i1 %cmp4474 to i32
  %sub4476 = sub nsw i32 0, %conv4475
  %762 = load i64, i64* %alloca_size, align 8
  %conv4477 = trunc i64 %762 to i16
  %conv4478 = sext i16 %conv4477 to i32
  %mul4479 = mul nsw i32 0, %conv4478
  %763 = load i64, i64* %formatlen, align 8
  %conv4480 = trunc i64 %763 to i16
  %conv4481 = sext i16 %conv4480 to i32
  %add4482 = add nsw i32 %mul4479, %conv4481
  %mul4483 = mul nsw i32 0, %add4482
  %add4484 = add nsw i32 %mul4483, 1
  %shl4485 = shl i32 %add4484, 30
  %sub4486 = sub nsw i32 %shl4485, 1
  %mul4487 = mul nsw i32 %sub4486, 2
  %add4488 = add nsw i32 %mul4487, 1
  %sub4489 = sub nsw i32 %sub4476, %add4488
  br label %cond.end.4499

cond.false.4490:                                  ; preds = %cond.true.4451
  %764 = load i64, i64* %alloca_size, align 8
  %conv4491 = trunc i64 %764 to i16
  %conv4492 = sext i16 %conv4491 to i32
  %mul4493 = mul nsw i32 0, %conv4492
  %765 = load i64, i64* %formatlen, align 8
  %conv4494 = trunc i64 %765 to i16
  %conv4495 = sext i16 %conv4494 to i32
  %add4496 = add nsw i32 %mul4493, %conv4495
  %mul4497 = mul nsw i32 0, %add4496
  %add4498 = add nsw i32 %mul4497, 0
  br label %cond.end.4499

cond.end.4499:                                    ; preds = %cond.false.4490, %cond.true.4464
  %cond4500 = phi i32 [ %sub4489, %cond.true.4464 ], [ %add4498, %cond.false.4490 ]
  %766 = load i64, i64* %alloca_size, align 8
  %conv4501 = trunc i64 %766 to i16
  %conv4502 = sext i16 %conv4501 to i32
  %sub4503 = sub nsw i32 %cond4500, %conv4502
  %cmp4504 = icmp slt i32 %conv4453, %sub4503
  br i1 %cmp4504, label %cond.true.4614, label %lor.lhs.false.4588

cond.false.4506:                                  ; preds = %cond.true.4446
  %767 = load i64, i64* %alloca_size, align 8
  %conv4507 = trunc i64 %767 to i16
  %conv4508 = sext i16 %conv4507 to i32
  %mul4509 = mul nsw i32 0, %conv4508
  %768 = load i64, i64* %formatlen, align 8
  %conv4510 = trunc i64 %768 to i16
  %conv4511 = sext i16 %conv4510 to i32
  %add4512 = add nsw i32 %mul4509, %conv4511
  %mul4513 = mul nsw i32 0, %add4512
  %sub4514 = sub nsw i32 %mul4513, 1
  %cmp4515 = icmp slt i32 %sub4514, 0
  br i1 %cmp4515, label %cond.true.4517, label %cond.false.4530

cond.true.4517:                                   ; preds = %cond.false.4506
  %769 = load i64, i64* %alloca_size, align 8
  %conv4518 = trunc i64 %769 to i16
  %conv4519 = sext i16 %conv4518 to i32
  %mul4520 = mul nsw i32 0, %conv4519
  %770 = load i64, i64* %formatlen, align 8
  %conv4521 = trunc i64 %770 to i16
  %conv4522 = sext i16 %conv4521 to i32
  %add4523 = add nsw i32 %mul4520, %conv4522
  %mul4524 = mul nsw i32 0, %add4523
  %add4525 = add nsw i32 %mul4524, 1
  %shl4526 = shl i32 %add4525, 30
  %sub4527 = sub nsw i32 %shl4526, 1
  %mul4528 = mul nsw i32 %sub4527, 2
  %add4529 = add nsw i32 %mul4528, 1
  br label %cond.end.4539

cond.false.4530:                                  ; preds = %cond.false.4506
  %771 = load i64, i64* %alloca_size, align 8
  %conv4531 = trunc i64 %771 to i16
  %conv4532 = sext i16 %conv4531 to i32
  %mul4533 = mul nsw i32 0, %conv4532
  %772 = load i64, i64* %formatlen, align 8
  %conv4534 = trunc i64 %772 to i16
  %conv4535 = sext i16 %conv4534 to i32
  %add4536 = add nsw i32 %mul4533, %conv4535
  %mul4537 = mul nsw i32 0, %add4536
  %sub4538 = sub nsw i32 %mul4537, 1
  br label %cond.end.4539

cond.end.4539:                                    ; preds = %cond.false.4530, %cond.true.4517
  %cond4540 = phi i32 [ %add4529, %cond.true.4517 ], [ %sub4538, %cond.false.4530 ]
  %773 = load i64, i64* %alloca_size, align 8
  %conv4541 = trunc i64 %773 to i16
  %conv4542 = sext i16 %conv4541 to i32
  %sub4543 = sub nsw i32 %cond4540, %conv4542
  %774 = load i64, i64* %formatlen, align 8
  %conv4544 = trunc i64 %774 to i16
  %conv4545 = sext i16 %conv4544 to i32
  %cmp4546 = icmp slt i32 %sub4543, %conv4545
  br i1 %cmp4546, label %cond.true.4614, label %lor.lhs.false.4588

cond.false.4548:                                  ; preds = %cond.end.4442
  %775 = load i64, i64* %formatlen, align 8
  %conv4549 = trunc i64 %775 to i16
  %conv4550 = sext i16 %conv4549 to i32
  %cmp4551 = icmp slt i32 %conv4550, 0
  br i1 %cmp4551, label %cond.true.4553, label %cond.false.4563

cond.true.4553:                                   ; preds = %cond.false.4548
  %776 = load i64, i64* %alloca_size, align 8
  %conv4554 = trunc i64 %776 to i16
  %conv4555 = sext i16 %conv4554 to i32
  %777 = load i64, i64* %formatlen, align 8
  %conv4556 = trunc i64 %777 to i16
  %conv4557 = sext i16 %conv4556 to i32
  %778 = load i64, i64* %alloca_size, align 8
  %conv4558 = trunc i64 %778 to i16
  %conv4559 = sext i16 %conv4558 to i32
  %add4560 = add nsw i32 %conv4557, %conv4559
  %cmp4561 = icmp sle i32 %conv4555, %add4560
  br i1 %cmp4561, label %cond.true.4614, label %lor.lhs.false.4588

cond.false.4563:                                  ; preds = %cond.false.4548
  %779 = load i64, i64* %alloca_size, align 8
  %conv4564 = trunc i64 %779 to i16
  %conv4565 = sext i16 %conv4564 to i32
  %cmp4566 = icmp slt i32 %conv4565, 0
  br i1 %cmp4566, label %cond.true.4568, label %cond.false.4578

cond.true.4568:                                   ; preds = %cond.false.4563
  %780 = load i64, i64* %formatlen, align 8
  %conv4569 = trunc i64 %780 to i16
  %conv4570 = sext i16 %conv4569 to i32
  %781 = load i64, i64* %formatlen, align 8
  %conv4571 = trunc i64 %781 to i16
  %conv4572 = sext i16 %conv4571 to i32
  %782 = load i64, i64* %alloca_size, align 8
  %conv4573 = trunc i64 %782 to i16
  %conv4574 = sext i16 %conv4573 to i32
  %add4575 = add nsw i32 %conv4572, %conv4574
  %cmp4576 = icmp sle i32 %conv4570, %add4575
  br i1 %cmp4576, label %cond.true.4614, label %lor.lhs.false.4588

cond.false.4578:                                  ; preds = %cond.false.4563
  %783 = load i64, i64* %formatlen, align 8
  %conv4579 = trunc i64 %783 to i16
  %conv4580 = sext i16 %conv4579 to i32
  %784 = load i64, i64* %alloca_size, align 8
  %conv4581 = trunc i64 %784 to i16
  %conv4582 = sext i16 %conv4581 to i32
  %add4583 = add nsw i32 %conv4580, %conv4582
  %785 = load i64, i64* %alloca_size, align 8
  %conv4584 = trunc i64 %785 to i16
  %conv4585 = sext i16 %conv4584 to i32
  %cmp4586 = icmp slt i32 %add4583, %conv4585
  br i1 %cmp4586, label %cond.true.4614, label %lor.lhs.false.4588

lor.lhs.false.4588:                               ; preds = %cond.false.4578, %cond.true.4568, %cond.true.4553, %cond.end.4539, %cond.end.4499
  %786 = load i64, i64* %formatlen, align 8
  %conv4589 = trunc i64 %786 to i16
  %conv4590 = sext i16 %conv4589 to i32
  %787 = load i64, i64* %alloca_size, align 8
  %conv4591 = trunc i64 %787 to i16
  %conv4592 = sext i16 %conv4591 to i32
  %add4593 = add nsw i32 %conv4590, %conv4592
  %mul4594 = mul nsw i32 0, %add4593
  %sub4595 = sub nsw i32 %mul4594, 1
  %cmp4596 = icmp slt i32 %sub4595, 0
  br i1 %cmp4596, label %land.lhs.true.4598, label %lor.lhs.false.4606

land.lhs.true.4598:                               ; preds = %lor.lhs.false.4588
  %788 = load i64, i64* %formatlen, align 8
  %conv4599 = trunc i64 %788 to i16
  %conv4600 = sext i16 %conv4599 to i32
  %789 = load i64, i64* %alloca_size, align 8
  %conv4601 = trunc i64 %789 to i16
  %conv4602 = sext i16 %conv4601 to i32
  %add4603 = add nsw i32 %conv4600, %conv4602
  %cmp4604 = icmp slt i32 %add4603, -32768
  br i1 %cmp4604, label %cond.true.4614, label %lor.lhs.false.4606

lor.lhs.false.4606:                               ; preds = %land.lhs.true.4598, %lor.lhs.false.4588
  %790 = load i64, i64* %formatlen, align 8
  %conv4607 = trunc i64 %790 to i16
  %conv4608 = sext i16 %conv4607 to i32
  %791 = load i64, i64* %alloca_size, align 8
  %conv4609 = trunc i64 %791 to i16
  %conv4610 = sext i16 %conv4609 to i32
  %add4611 = add nsw i32 %conv4608, %conv4610
  %cmp4612 = icmp slt i32 32767, %add4611
  br i1 %cmp4612, label %cond.true.4614, label %cond.false.4643

cond.true.4614:                                   ; preds = %lor.lhs.false.4606, %land.lhs.true.4598, %cond.false.4578, %cond.true.4568, %cond.true.4553, %cond.end.4539, %cond.end.4499
  %792 = load i64, i64* %formatlen, align 8
  %conv4615 = trunc i64 %792 to i16
  %conv4616 = zext i16 %conv4615 to i32
  %793 = load i64, i64* %alloca_size, align 8
  %conv4617 = trunc i64 %793 to i16
  %conv4618 = zext i16 %conv4617 to i32
  %add4619 = add nsw i32 %conv4616, %conv4618
  %cmp4620 = icmp sle i32 %add4619, 32767
  br i1 %cmp4620, label %cond.true.4622, label %cond.false.4630

cond.true.4622:                                   ; preds = %cond.true.4614
  %794 = load i64, i64* %formatlen, align 8
  %conv4623 = trunc i64 %794 to i16
  %conv4624 = zext i16 %conv4623 to i32
  %795 = load i64, i64* %alloca_size, align 8
  %conv4625 = trunc i64 %795 to i16
  %conv4626 = zext i16 %conv4625 to i32
  %add4627 = add nsw i32 %conv4624, %conv4626
  %conv4628 = trunc i32 %add4627 to i16
  %conv4629 = sext i16 %conv4628 to i32
  br label %cond.end.4640

cond.false.4630:                                  ; preds = %cond.true.4614
  %796 = load i64, i64* %formatlen, align 8
  %conv4631 = trunc i64 %796 to i16
  %conv4632 = zext i16 %conv4631 to i32
  %797 = load i64, i64* %alloca_size, align 8
  %conv4633 = trunc i64 %797 to i16
  %conv4634 = zext i16 %conv4633 to i32
  %add4635 = add nsw i32 %conv4632, %conv4634
  %sub4636 = sub nsw i32 %add4635, -32768
  %conv4637 = trunc i32 %sub4636 to i16
  %conv4638 = sext i16 %conv4637 to i32
  %add4639 = add nsw i32 %conv4638, -32768
  br label %cond.end.4640

cond.end.4640:                                    ; preds = %cond.false.4630, %cond.true.4622
  %cond4641 = phi i32 [ %conv4629, %cond.true.4622 ], [ %add4639, %cond.false.4630 ]
  %conv4642 = sext i32 %cond4641 to i64
  store i64 %conv4642, i64* %alloca_size, align 8
  br i1 true, label %if.then, label %lor.lhs.false.5873

cond.false.4643:                                  ; preds = %lor.lhs.false.4606
  %798 = load i64, i64* %formatlen, align 8
  %conv4644 = trunc i64 %798 to i16
  %conv4645 = zext i16 %conv4644 to i32
  %799 = load i64, i64* %alloca_size, align 8
  %conv4646 = trunc i64 %799 to i16
  %conv4647 = zext i16 %conv4646 to i32
  %add4648 = add nsw i32 %conv4645, %conv4647
  %cmp4649 = icmp sle i32 %add4648, 32767
  br i1 %cmp4649, label %cond.true.4651, label %cond.false.4659

cond.true.4651:                                   ; preds = %cond.false.4643
  %800 = load i64, i64* %formatlen, align 8
  %conv4652 = trunc i64 %800 to i16
  %conv4653 = zext i16 %conv4652 to i32
  %801 = load i64, i64* %alloca_size, align 8
  %conv4654 = trunc i64 %801 to i16
  %conv4655 = zext i16 %conv4654 to i32
  %add4656 = add nsw i32 %conv4653, %conv4655
  %conv4657 = trunc i32 %add4656 to i16
  %conv4658 = sext i16 %conv4657 to i32
  br label %cond.end.4669

cond.false.4659:                                  ; preds = %cond.false.4643
  %802 = load i64, i64* %formatlen, align 8
  %conv4660 = trunc i64 %802 to i16
  %conv4661 = zext i16 %conv4660 to i32
  %803 = load i64, i64* %alloca_size, align 8
  %conv4662 = trunc i64 %803 to i16
  %conv4663 = zext i16 %conv4662 to i32
  %add4664 = add nsw i32 %conv4661, %conv4663
  %sub4665 = sub nsw i32 %add4664, -32768
  %conv4666 = trunc i32 %sub4665 to i16
  %conv4667 = sext i16 %conv4666 to i32
  %add4668 = add nsw i32 %conv4667, -32768
  br label %cond.end.4669

cond.end.4669:                                    ; preds = %cond.false.4659, %cond.true.4651
  %cond4670 = phi i32 [ %conv4658, %cond.true.4651 ], [ %add4668, %cond.false.4659 ]
  %conv4671 = sext i32 %cond4670 to i64
  store i64 %conv4671, i64* %alloca_size, align 8
  br i1 false, label %if.then, label %lor.lhs.false.5873

cond.false.4672:                                  ; preds = %cond.true.4395
  %804 = load i64, i64* %alloca_size, align 8
  %mul4673 = mul nsw i64 0, %804
  %805 = load i64, i64* %formatlen, align 8
  %add4674 = add nsw i64 %mul4673, %805
  %mul4675 = mul nsw i64 0, %add4674
  %sub4676 = sub nsw i64 %mul4675, 1
  %cmp4677 = icmp slt i64 %sub4676, 0
  br i1 %cmp4677, label %cond.true.4679, label %cond.false.4698

cond.true.4679:                                   ; preds = %cond.false.4672
  %806 = load i64, i64* %alloca_size, align 8
  %mul4680 = mul nsw i64 0, %806
  %807 = load i64, i64* %formatlen, align 8
  %add4681 = add nsw i64 %mul4680, %807
  %mul4682 = mul nsw i64 0, %add4681
  %add4683 = add nsw i64 %mul4682, 0
  %neg4684 = xor i64 %add4683, -1
  %cmp4685 = icmp eq i64 %neg4684, -1
  %conv4686 = zext i1 %cmp4685 to i32
  %sub4687 = sub nsw i32 0, %conv4686
  %conv4688 = sext i32 %sub4687 to i64
  %808 = load i64, i64* %alloca_size, align 8
  %mul4689 = mul nsw i64 0, %808
  %809 = load i64, i64* %formatlen, align 8
  %add4690 = add nsw i64 %mul4689, %809
  %mul4691 = mul nsw i64 0, %add4690
  %add4692 = add nsw i64 %mul4691, 1
  %shl4693 = shl i64 %add4692, 62
  %sub4694 = sub nsw i64 %shl4693, 1
  %mul4695 = mul nsw i64 %sub4694, 2
  %add4696 = add nsw i64 %mul4695, 1
  %sub4697 = sub nsw i64 %conv4688, %add4696
  br label %cond.end.4703

cond.false.4698:                                  ; preds = %cond.false.4672
  %810 = load i64, i64* %alloca_size, align 8
  %mul4699 = mul nsw i64 0, %810
  %811 = load i64, i64* %formatlen, align 8
  %add4700 = add nsw i64 %mul4699, %811
  %mul4701 = mul nsw i64 0, %add4700
  %add4702 = add nsw i64 %mul4701, 0
  br label %cond.end.4703

cond.end.4703:                                    ; preds = %cond.false.4698, %cond.true.4679
  %cond4704 = phi i64 [ %sub4697, %cond.true.4679 ], [ %add4702, %cond.false.4698 ]
  %cmp4705 = icmp slt i64 %cond4704, 0
  br i1 %cmp4705, label %cond.true.4707, label %cond.false.4772

cond.true.4707:                                   ; preds = %cond.end.4703
  %812 = load i64, i64* %alloca_size, align 8
  %cmp4708 = icmp slt i64 %812, 0
  br i1 %cmp4708, label %cond.true.4710, label %cond.false.4746

cond.true.4710:                                   ; preds = %cond.true.4707
  %813 = load i64, i64* %formatlen, align 8
  %814 = load i64, i64* %alloca_size, align 8
  %mul4711 = mul nsw i64 0, %814
  %815 = load i64, i64* %formatlen, align 8
  %add4712 = add nsw i64 %mul4711, %815
  %mul4713 = mul nsw i64 0, %add4712
  %sub4714 = sub nsw i64 %mul4713, 1
  %cmp4715 = icmp slt i64 %sub4714, 0
  br i1 %cmp4715, label %cond.true.4717, label %cond.false.4736

cond.true.4717:                                   ; preds = %cond.true.4710
  %816 = load i64, i64* %alloca_size, align 8
  %mul4718 = mul nsw i64 0, %816
  %817 = load i64, i64* %formatlen, align 8
  %add4719 = add nsw i64 %mul4718, %817
  %mul4720 = mul nsw i64 0, %add4719
  %add4721 = add nsw i64 %mul4720, 0
  %neg4722 = xor i64 %add4721, -1
  %cmp4723 = icmp eq i64 %neg4722, -1
  %conv4724 = zext i1 %cmp4723 to i32
  %sub4725 = sub nsw i32 0, %conv4724
  %conv4726 = sext i32 %sub4725 to i64
  %818 = load i64, i64* %alloca_size, align 8
  %mul4727 = mul nsw i64 0, %818
  %819 = load i64, i64* %formatlen, align 8
  %add4728 = add nsw i64 %mul4727, %819
  %mul4729 = mul nsw i64 0, %add4728
  %add4730 = add nsw i64 %mul4729, 1
  %shl4731 = shl i64 %add4730, 62
  %sub4732 = sub nsw i64 %shl4731, 1
  %mul4733 = mul nsw i64 %sub4732, 2
  %add4734 = add nsw i64 %mul4733, 1
  %sub4735 = sub nsw i64 %conv4726, %add4734
  br label %cond.end.4741

cond.false.4736:                                  ; preds = %cond.true.4710
  %820 = load i64, i64* %alloca_size, align 8
  %mul4737 = mul nsw i64 0, %820
  %821 = load i64, i64* %formatlen, align 8
  %add4738 = add nsw i64 %mul4737, %821
  %mul4739 = mul nsw i64 0, %add4738
  %add4740 = add nsw i64 %mul4739, 0
  br label %cond.end.4741

cond.end.4741:                                    ; preds = %cond.false.4736, %cond.true.4717
  %cond4742 = phi i64 [ %sub4735, %cond.true.4717 ], [ %add4740, %cond.false.4736 ]
  %822 = load i64, i64* %alloca_size, align 8
  %sub4743 = sub nsw i64 %cond4742, %822
  %cmp4744 = icmp slt i64 %813, %sub4743
  br i1 %cmp4744, label %cond.true.4804, label %lor.lhs.false.4790

cond.false.4746:                                  ; preds = %cond.true.4707
  %823 = load i64, i64* %alloca_size, align 8
  %mul4747 = mul nsw i64 0, %823
  %824 = load i64, i64* %formatlen, align 8
  %add4748 = add nsw i64 %mul4747, %824
  %mul4749 = mul nsw i64 0, %add4748
  %sub4750 = sub nsw i64 %mul4749, 1
  %cmp4751 = icmp slt i64 %sub4750, 0
  br i1 %cmp4751, label %cond.true.4753, label %cond.false.4762

cond.true.4753:                                   ; preds = %cond.false.4746
  %825 = load i64, i64* %alloca_size, align 8
  %mul4754 = mul nsw i64 0, %825
  %826 = load i64, i64* %formatlen, align 8
  %add4755 = add nsw i64 %mul4754, %826
  %mul4756 = mul nsw i64 0, %add4755
  %add4757 = add nsw i64 %mul4756, 1
  %shl4758 = shl i64 %add4757, 62
  %sub4759 = sub nsw i64 %shl4758, 1
  %mul4760 = mul nsw i64 %sub4759, 2
  %add4761 = add nsw i64 %mul4760, 1
  br label %cond.end.4767

cond.false.4762:                                  ; preds = %cond.false.4746
  %827 = load i64, i64* %alloca_size, align 8
  %mul4763 = mul nsw i64 0, %827
  %828 = load i64, i64* %formatlen, align 8
  %add4764 = add nsw i64 %mul4763, %828
  %mul4765 = mul nsw i64 0, %add4764
  %sub4766 = sub nsw i64 %mul4765, 1
  br label %cond.end.4767

cond.end.4767:                                    ; preds = %cond.false.4762, %cond.true.4753
  %cond4768 = phi i64 [ %add4761, %cond.true.4753 ], [ %sub4766, %cond.false.4762 ]
  %829 = load i64, i64* %alloca_size, align 8
  %sub4769 = sub nsw i64 %cond4768, %829
  %830 = load i64, i64* %formatlen, align 8
  %cmp4770 = icmp slt i64 %sub4769, %830
  br i1 %cmp4770, label %cond.true.4804, label %lor.lhs.false.4790

cond.false.4772:                                  ; preds = %cond.end.4703
  %831 = load i64, i64* %formatlen, align 8
  %cmp4773 = icmp slt i64 %831, 0
  br i1 %cmp4773, label %cond.true.4775, label %cond.false.4779

cond.true.4775:                                   ; preds = %cond.false.4772
  %832 = load i64, i64* %alloca_size, align 8
  %833 = load i64, i64* %formatlen, align 8
  %834 = load i64, i64* %alloca_size, align 8
  %add4776 = add nsw i64 %833, %834
  %cmp4777 = icmp sle i64 %832, %add4776
  br i1 %cmp4777, label %cond.true.4804, label %lor.lhs.false.4790

cond.false.4779:                                  ; preds = %cond.false.4772
  %835 = load i64, i64* %alloca_size, align 8
  %cmp4780 = icmp slt i64 %835, 0
  br i1 %cmp4780, label %cond.true.4782, label %cond.false.4786

cond.true.4782:                                   ; preds = %cond.false.4779
  %836 = load i64, i64* %formatlen, align 8
  %837 = load i64, i64* %formatlen, align 8
  %838 = load i64, i64* %alloca_size, align 8
  %add4783 = add nsw i64 %837, %838
  %cmp4784 = icmp sle i64 %836, %add4783
  br i1 %cmp4784, label %cond.true.4804, label %lor.lhs.false.4790

cond.false.4786:                                  ; preds = %cond.false.4779
  %839 = load i64, i64* %formatlen, align 8
  %840 = load i64, i64* %alloca_size, align 8
  %add4787 = add nsw i64 %839, %840
  %841 = load i64, i64* %alloca_size, align 8
  %cmp4788 = icmp slt i64 %add4787, %841
  br i1 %cmp4788, label %cond.true.4804, label %lor.lhs.false.4790

lor.lhs.false.4790:                               ; preds = %cond.false.4786, %cond.true.4782, %cond.true.4775, %cond.end.4767, %cond.end.4741
  %842 = load i64, i64* %formatlen, align 8
  %843 = load i64, i64* %alloca_size, align 8
  %add4791 = add nsw i64 %842, %843
  %mul4792 = mul nsw i64 0, %add4791
  %sub4793 = sub nsw i64 %mul4792, 1
  %cmp4794 = icmp slt i64 %sub4793, 0
  br i1 %cmp4794, label %land.lhs.true.4796, label %lor.lhs.false.4800

land.lhs.true.4796:                               ; preds = %lor.lhs.false.4790
  %844 = load i64, i64* %formatlen, align 8
  %845 = load i64, i64* %alloca_size, align 8
  %add4797 = add nsw i64 %844, %845
  %cmp4798 = icmp slt i64 %add4797, -32768
  br i1 %cmp4798, label %cond.true.4804, label %lor.lhs.false.4800

lor.lhs.false.4800:                               ; preds = %land.lhs.true.4796, %lor.lhs.false.4790
  %846 = load i64, i64* %formatlen, align 8
  %847 = load i64, i64* %alloca_size, align 8
  %add4801 = add nsw i64 %846, %847
  %cmp4802 = icmp slt i64 32767, %add4801
  br i1 %cmp4802, label %cond.true.4804, label %cond.false.4833

cond.true.4804:                                   ; preds = %lor.lhs.false.4800, %land.lhs.true.4796, %cond.false.4786, %cond.true.4782, %cond.true.4775, %cond.end.4767, %cond.end.4741
  %848 = load i64, i64* %formatlen, align 8
  %conv4805 = trunc i64 %848 to i16
  %conv4806 = zext i16 %conv4805 to i32
  %849 = load i64, i64* %alloca_size, align 8
  %conv4807 = trunc i64 %849 to i16
  %conv4808 = zext i16 %conv4807 to i32
  %add4809 = add nsw i32 %conv4806, %conv4808
  %cmp4810 = icmp sle i32 %add4809, 32767
  br i1 %cmp4810, label %cond.true.4812, label %cond.false.4820

cond.true.4812:                                   ; preds = %cond.true.4804
  %850 = load i64, i64* %formatlen, align 8
  %conv4813 = trunc i64 %850 to i16
  %conv4814 = zext i16 %conv4813 to i32
  %851 = load i64, i64* %alloca_size, align 8
  %conv4815 = trunc i64 %851 to i16
  %conv4816 = zext i16 %conv4815 to i32
  %add4817 = add nsw i32 %conv4814, %conv4816
  %conv4818 = trunc i32 %add4817 to i16
  %conv4819 = sext i16 %conv4818 to i32
  br label %cond.end.4830

cond.false.4820:                                  ; preds = %cond.true.4804
  %852 = load i64, i64* %formatlen, align 8
  %conv4821 = trunc i64 %852 to i16
  %conv4822 = zext i16 %conv4821 to i32
  %853 = load i64, i64* %alloca_size, align 8
  %conv4823 = trunc i64 %853 to i16
  %conv4824 = zext i16 %conv4823 to i32
  %add4825 = add nsw i32 %conv4822, %conv4824
  %sub4826 = sub nsw i32 %add4825, -32768
  %conv4827 = trunc i32 %sub4826 to i16
  %conv4828 = sext i16 %conv4827 to i32
  %add4829 = add nsw i32 %conv4828, -32768
  br label %cond.end.4830

cond.end.4830:                                    ; preds = %cond.false.4820, %cond.true.4812
  %cond4831 = phi i32 [ %conv4819, %cond.true.4812 ], [ %add4829, %cond.false.4820 ]
  %conv4832 = sext i32 %cond4831 to i64
  store i64 %conv4832, i64* %alloca_size, align 8
  br i1 true, label %if.then, label %lor.lhs.false.5873

cond.false.4833:                                  ; preds = %lor.lhs.false.4800
  %854 = load i64, i64* %formatlen, align 8
  %conv4834 = trunc i64 %854 to i16
  %conv4835 = zext i16 %conv4834 to i32
  %855 = load i64, i64* %alloca_size, align 8
  %conv4836 = trunc i64 %855 to i16
  %conv4837 = zext i16 %conv4836 to i32
  %add4838 = add nsw i32 %conv4835, %conv4837
  %cmp4839 = icmp sle i32 %add4838, 32767
  br i1 %cmp4839, label %cond.true.4841, label %cond.false.4849

cond.true.4841:                                   ; preds = %cond.false.4833
  %856 = load i64, i64* %formatlen, align 8
  %conv4842 = trunc i64 %856 to i16
  %conv4843 = zext i16 %conv4842 to i32
  %857 = load i64, i64* %alloca_size, align 8
  %conv4844 = trunc i64 %857 to i16
  %conv4845 = zext i16 %conv4844 to i32
  %add4846 = add nsw i32 %conv4843, %conv4845
  %conv4847 = trunc i32 %add4846 to i16
  %conv4848 = sext i16 %conv4847 to i32
  br label %cond.end.4859

cond.false.4849:                                  ; preds = %cond.false.4833
  %858 = load i64, i64* %formatlen, align 8
  %conv4850 = trunc i64 %858 to i16
  %conv4851 = zext i16 %conv4850 to i32
  %859 = load i64, i64* %alloca_size, align 8
  %conv4852 = trunc i64 %859 to i16
  %conv4853 = zext i16 %conv4852 to i32
  %add4854 = add nsw i32 %conv4851, %conv4853
  %sub4855 = sub nsw i32 %add4854, -32768
  %conv4856 = trunc i32 %sub4855 to i16
  %conv4857 = sext i16 %conv4856 to i32
  %add4858 = add nsw i32 %conv4857, -32768
  br label %cond.end.4859

cond.end.4859:                                    ; preds = %cond.false.4849, %cond.true.4841
  %cond4860 = phi i32 [ %conv4848, %cond.true.4841 ], [ %add4858, %cond.false.4849 ]
  %conv4861 = sext i32 %cond4860 to i64
  store i64 %conv4861, i64* %alloca_size, align 8
  br i1 false, label %if.then, label %lor.lhs.false.5873

cond.false.4862:                                  ; preds = %cond.false.4394
  br i1 false, label %cond.true.4863, label %cond.false.5246

cond.true.4863:                                   ; preds = %cond.false.4862
  br i1 false, label %cond.true.4864, label %cond.false.5076

cond.true.4864:                                   ; preds = %cond.true.4863
  %860 = load i64, i64* %alloca_size, align 8
  %conv4865 = trunc i64 %860 to i32
  %mul4866 = mul nsw i32 0, %conv4865
  %861 = load i64, i64* %formatlen, align 8
  %conv4867 = trunc i64 %861 to i32
  %add4868 = add nsw i32 %mul4866, %conv4867
  %mul4869 = mul nsw i32 0, %add4868
  %sub4870 = sub nsw i32 %mul4869, 1
  %cmp4871 = icmp slt i32 %sub4870, 0
  br i1 %cmp4871, label %cond.true.4873, label %cond.false.4895

cond.true.4873:                                   ; preds = %cond.true.4864
  %862 = load i64, i64* %alloca_size, align 8
  %conv4874 = trunc i64 %862 to i32
  %mul4875 = mul nsw i32 0, %conv4874
  %863 = load i64, i64* %formatlen, align 8
  %conv4876 = trunc i64 %863 to i32
  %add4877 = add nsw i32 %mul4875, %conv4876
  %mul4878 = mul nsw i32 0, %add4877
  %add4879 = add nsw i32 %mul4878, 0
  %neg4880 = xor i32 %add4879, -1
  %cmp4881 = icmp eq i32 %neg4880, -1
  %conv4882 = zext i1 %cmp4881 to i32
  %sub4883 = sub nsw i32 0, %conv4882
  %864 = load i64, i64* %alloca_size, align 8
  %conv4884 = trunc i64 %864 to i32
  %mul4885 = mul nsw i32 0, %conv4884
  %865 = load i64, i64* %formatlen, align 8
  %conv4886 = trunc i64 %865 to i32
  %add4887 = add nsw i32 %mul4885, %conv4886
  %mul4888 = mul nsw i32 0, %add4887
  %add4889 = add nsw i32 %mul4888, 1
  %shl4890 = shl i32 %add4889, 30
  %sub4891 = sub nsw i32 %shl4890, 1
  %mul4892 = mul nsw i32 %sub4891, 2
  %add4893 = add nsw i32 %mul4892, 1
  %sub4894 = sub nsw i32 %sub4883, %add4893
  br label %cond.end.4902

cond.false.4895:                                  ; preds = %cond.true.4864
  %866 = load i64, i64* %alloca_size, align 8
  %conv4896 = trunc i64 %866 to i32
  %mul4897 = mul nsw i32 0, %conv4896
  %867 = load i64, i64* %formatlen, align 8
  %conv4898 = trunc i64 %867 to i32
  %add4899 = add nsw i32 %mul4897, %conv4898
  %mul4900 = mul nsw i32 0, %add4899
  %add4901 = add nsw i32 %mul4900, 0
  br label %cond.end.4902

cond.end.4902:                                    ; preds = %cond.false.4895, %cond.true.4873
  %cond4903 = phi i32 [ %sub4894, %cond.true.4873 ], [ %add4901, %cond.false.4895 ]
  %cmp4904 = icmp slt i32 %cond4903, 0
  br i1 %cmp4904, label %cond.true.4906, label %cond.false.4989

cond.true.4906:                                   ; preds = %cond.end.4902
  %868 = load i64, i64* %alloca_size, align 8
  %conv4907 = trunc i64 %868 to i32
  %cmp4908 = icmp slt i32 %conv4907, 0
  br i1 %cmp4908, label %cond.true.4910, label %cond.false.4955

cond.true.4910:                                   ; preds = %cond.true.4906
  %869 = load i64, i64* %formatlen, align 8
  %conv4911 = trunc i64 %869 to i32
  %870 = load i64, i64* %alloca_size, align 8
  %conv4912 = trunc i64 %870 to i32
  %mul4913 = mul nsw i32 0, %conv4912
  %871 = load i64, i64* %formatlen, align 8
  %conv4914 = trunc i64 %871 to i32
  %add4915 = add nsw i32 %mul4913, %conv4914
  %mul4916 = mul nsw i32 0, %add4915
  %sub4917 = sub nsw i32 %mul4916, 1
  %cmp4918 = icmp slt i32 %sub4917, 0
  br i1 %cmp4918, label %cond.true.4920, label %cond.false.4942

cond.true.4920:                                   ; preds = %cond.true.4910
  %872 = load i64, i64* %alloca_size, align 8
  %conv4921 = trunc i64 %872 to i32
  %mul4922 = mul nsw i32 0, %conv4921
  %873 = load i64, i64* %formatlen, align 8
  %conv4923 = trunc i64 %873 to i32
  %add4924 = add nsw i32 %mul4922, %conv4923
  %mul4925 = mul nsw i32 0, %add4924
  %add4926 = add nsw i32 %mul4925, 0
  %neg4927 = xor i32 %add4926, -1
  %cmp4928 = icmp eq i32 %neg4927, -1
  %conv4929 = zext i1 %cmp4928 to i32
  %sub4930 = sub nsw i32 0, %conv4929
  %874 = load i64, i64* %alloca_size, align 8
  %conv4931 = trunc i64 %874 to i32
  %mul4932 = mul nsw i32 0, %conv4931
  %875 = load i64, i64* %formatlen, align 8
  %conv4933 = trunc i64 %875 to i32
  %add4934 = add nsw i32 %mul4932, %conv4933
  %mul4935 = mul nsw i32 0, %add4934
  %add4936 = add nsw i32 %mul4935, 1
  %shl4937 = shl i32 %add4936, 30
  %sub4938 = sub nsw i32 %shl4937, 1
  %mul4939 = mul nsw i32 %sub4938, 2
  %add4940 = add nsw i32 %mul4939, 1
  %sub4941 = sub nsw i32 %sub4930, %add4940
  br label %cond.end.4949

cond.false.4942:                                  ; preds = %cond.true.4910
  %876 = load i64, i64* %alloca_size, align 8
  %conv4943 = trunc i64 %876 to i32
  %mul4944 = mul nsw i32 0, %conv4943
  %877 = load i64, i64* %formatlen, align 8
  %conv4945 = trunc i64 %877 to i32
  %add4946 = add nsw i32 %mul4944, %conv4945
  %mul4947 = mul nsw i32 0, %add4946
  %add4948 = add nsw i32 %mul4947, 0
  br label %cond.end.4949

cond.end.4949:                                    ; preds = %cond.false.4942, %cond.true.4920
  %cond4950 = phi i32 [ %sub4941, %cond.true.4920 ], [ %add4948, %cond.false.4942 ]
  %878 = load i64, i64* %alloca_size, align 8
  %conv4951 = trunc i64 %878 to i32
  %sub4952 = sub nsw i32 %cond4950, %conv4951
  %cmp4953 = icmp slt i32 %conv4911, %sub4952
  br i1 %cmp4953, label %cond.true.5038, label %lor.lhs.false.5018

cond.false.4955:                                  ; preds = %cond.true.4906
  %879 = load i64, i64* %alloca_size, align 8
  %conv4956 = trunc i64 %879 to i32
  %mul4957 = mul nsw i32 0, %conv4956
  %880 = load i64, i64* %formatlen, align 8
  %conv4958 = trunc i64 %880 to i32
  %add4959 = add nsw i32 %mul4957, %conv4958
  %mul4960 = mul nsw i32 0, %add4959
  %sub4961 = sub nsw i32 %mul4960, 1
  %cmp4962 = icmp slt i32 %sub4961, 0
  br i1 %cmp4962, label %cond.true.4964, label %cond.false.4975

cond.true.4964:                                   ; preds = %cond.false.4955
  %881 = load i64, i64* %alloca_size, align 8
  %conv4965 = trunc i64 %881 to i32
  %mul4966 = mul nsw i32 0, %conv4965
  %882 = load i64, i64* %formatlen, align 8
  %conv4967 = trunc i64 %882 to i32
  %add4968 = add nsw i32 %mul4966, %conv4967
  %mul4969 = mul nsw i32 0, %add4968
  %add4970 = add nsw i32 %mul4969, 1
  %shl4971 = shl i32 %add4970, 30
  %sub4972 = sub nsw i32 %shl4971, 1
  %mul4973 = mul nsw i32 %sub4972, 2
  %add4974 = add nsw i32 %mul4973, 1
  br label %cond.end.4982

cond.false.4975:                                  ; preds = %cond.false.4955
  %883 = load i64, i64* %alloca_size, align 8
  %conv4976 = trunc i64 %883 to i32
  %mul4977 = mul nsw i32 0, %conv4976
  %884 = load i64, i64* %formatlen, align 8
  %conv4978 = trunc i64 %884 to i32
  %add4979 = add nsw i32 %mul4977, %conv4978
  %mul4980 = mul nsw i32 0, %add4979
  %sub4981 = sub nsw i32 %mul4980, 1
  br label %cond.end.4982

cond.end.4982:                                    ; preds = %cond.false.4975, %cond.true.4964
  %cond4983 = phi i32 [ %add4974, %cond.true.4964 ], [ %sub4981, %cond.false.4975 ]
  %885 = load i64, i64* %alloca_size, align 8
  %conv4984 = trunc i64 %885 to i32
  %sub4985 = sub nsw i32 %cond4983, %conv4984
  %886 = load i64, i64* %formatlen, align 8
  %conv4986 = trunc i64 %886 to i32
  %cmp4987 = icmp slt i32 %sub4985, %conv4986
  br i1 %cmp4987, label %cond.true.5038, label %lor.lhs.false.5018

cond.false.4989:                                  ; preds = %cond.end.4902
  %887 = load i64, i64* %formatlen, align 8
  %conv4990 = trunc i64 %887 to i32
  %cmp4991 = icmp slt i32 %conv4990, 0
  br i1 %cmp4991, label %cond.true.4993, label %cond.false.5000

cond.true.4993:                                   ; preds = %cond.false.4989
  %888 = load i64, i64* %alloca_size, align 8
  %conv4994 = trunc i64 %888 to i32
  %889 = load i64, i64* %formatlen, align 8
  %conv4995 = trunc i64 %889 to i32
  %890 = load i64, i64* %alloca_size, align 8
  %conv4996 = trunc i64 %890 to i32
  %add4997 = add nsw i32 %conv4995, %conv4996
  %cmp4998 = icmp sle i32 %conv4994, %add4997
  br i1 %cmp4998, label %cond.true.5038, label %lor.lhs.false.5018

cond.false.5000:                                  ; preds = %cond.false.4989
  %891 = load i64, i64* %alloca_size, align 8
  %conv5001 = trunc i64 %891 to i32
  %cmp5002 = icmp slt i32 %conv5001, 0
  br i1 %cmp5002, label %cond.true.5004, label %cond.false.5011

cond.true.5004:                                   ; preds = %cond.false.5000
  %892 = load i64, i64* %formatlen, align 8
  %conv5005 = trunc i64 %892 to i32
  %893 = load i64, i64* %formatlen, align 8
  %conv5006 = trunc i64 %893 to i32
  %894 = load i64, i64* %alloca_size, align 8
  %conv5007 = trunc i64 %894 to i32
  %add5008 = add nsw i32 %conv5006, %conv5007
  %cmp5009 = icmp sle i32 %conv5005, %add5008
  br i1 %cmp5009, label %cond.true.5038, label %lor.lhs.false.5018

cond.false.5011:                                  ; preds = %cond.false.5000
  %895 = load i64, i64* %formatlen, align 8
  %conv5012 = trunc i64 %895 to i32
  %896 = load i64, i64* %alloca_size, align 8
  %conv5013 = trunc i64 %896 to i32
  %add5014 = add nsw i32 %conv5012, %conv5013
  %897 = load i64, i64* %alloca_size, align 8
  %conv5015 = trunc i64 %897 to i32
  %cmp5016 = icmp slt i32 %add5014, %conv5015
  br i1 %cmp5016, label %cond.true.5038, label %lor.lhs.false.5018

lor.lhs.false.5018:                               ; preds = %cond.false.5011, %cond.true.5004, %cond.true.4993, %cond.end.4982, %cond.end.4949
  %898 = load i64, i64* %formatlen, align 8
  %conv5019 = trunc i64 %898 to i32
  %899 = load i64, i64* %alloca_size, align 8
  %conv5020 = trunc i64 %899 to i32
  %add5021 = add nsw i32 %conv5019, %conv5020
  %mul5022 = mul nsw i32 0, %add5021
  %sub5023 = sub nsw i32 %mul5022, 1
  %cmp5024 = icmp slt i32 %sub5023, 0
  br i1 %cmp5024, label %land.lhs.true.5026, label %lor.lhs.false.5032

land.lhs.true.5026:                               ; preds = %lor.lhs.false.5018
  %900 = load i64, i64* %formatlen, align 8
  %conv5027 = trunc i64 %900 to i32
  %901 = load i64, i64* %alloca_size, align 8
  %conv5028 = trunc i64 %901 to i32
  %add5029 = add nsw i32 %conv5027, %conv5028
  %cmp5030 = icmp slt i32 %add5029, -2147483648
  br i1 %cmp5030, label %cond.true.5038, label %lor.lhs.false.5032

lor.lhs.false.5032:                               ; preds = %land.lhs.true.5026, %lor.lhs.false.5018
  %902 = load i64, i64* %formatlen, align 8
  %conv5033 = trunc i64 %902 to i32
  %903 = load i64, i64* %alloca_size, align 8
  %conv5034 = trunc i64 %903 to i32
  %add5035 = add nsw i32 %conv5033, %conv5034
  %cmp5036 = icmp slt i32 2147483647, %add5035
  br i1 %cmp5036, label %cond.true.5038, label %cond.false.5057

cond.true.5038:                                   ; preds = %lor.lhs.false.5032, %land.lhs.true.5026, %cond.false.5011, %cond.true.5004, %cond.true.4993, %cond.end.4982, %cond.end.4949
  %904 = load i64, i64* %formatlen, align 8
  %conv5039 = trunc i64 %904 to i32
  %905 = load i64, i64* %alloca_size, align 8
  %conv5040 = trunc i64 %905 to i32
  %add5041 = add i32 %conv5039, %conv5040
  %cmp5042 = icmp ule i32 %add5041, 2147483647
  br i1 %cmp5042, label %cond.true.5044, label %cond.false.5048

cond.true.5044:                                   ; preds = %cond.true.5038
  %906 = load i64, i64* %formatlen, align 8
  %conv5045 = trunc i64 %906 to i32
  %907 = load i64, i64* %alloca_size, align 8
  %conv5046 = trunc i64 %907 to i32
  %add5047 = add i32 %conv5045, %conv5046
  br label %cond.end.5054

cond.false.5048:                                  ; preds = %cond.true.5038
  %908 = load i64, i64* %formatlen, align 8
  %conv5049 = trunc i64 %908 to i32
  %909 = load i64, i64* %alloca_size, align 8
  %conv5050 = trunc i64 %909 to i32
  %add5051 = add i32 %conv5049, %conv5050
  %sub5052 = sub i32 %add5051, -2147483648
  %add5053 = add nsw i32 %sub5052, -2147483648
  br label %cond.end.5054

cond.end.5054:                                    ; preds = %cond.false.5048, %cond.true.5044
  %cond5055 = phi i32 [ %add5047, %cond.true.5044 ], [ %add5053, %cond.false.5048 ]
  %conv5056 = sext i32 %cond5055 to i64
  store i64 %conv5056, i64* %alloca_size, align 8
  br i1 true, label %if.then, label %lor.lhs.false.5873

cond.false.5057:                                  ; preds = %lor.lhs.false.5032
  %910 = load i64, i64* %formatlen, align 8
  %conv5058 = trunc i64 %910 to i32
  %911 = load i64, i64* %alloca_size, align 8
  %conv5059 = trunc i64 %911 to i32
  %add5060 = add i32 %conv5058, %conv5059
  %cmp5061 = icmp ule i32 %add5060, 2147483647
  br i1 %cmp5061, label %cond.true.5063, label %cond.false.5067

cond.true.5063:                                   ; preds = %cond.false.5057
  %912 = load i64, i64* %formatlen, align 8
  %conv5064 = trunc i64 %912 to i32
  %913 = load i64, i64* %alloca_size, align 8
  %conv5065 = trunc i64 %913 to i32
  %add5066 = add i32 %conv5064, %conv5065
  br label %cond.end.5073

cond.false.5067:                                  ; preds = %cond.false.5057
  %914 = load i64, i64* %formatlen, align 8
  %conv5068 = trunc i64 %914 to i32
  %915 = load i64, i64* %alloca_size, align 8
  %conv5069 = trunc i64 %915 to i32
  %add5070 = add i32 %conv5068, %conv5069
  %sub5071 = sub i32 %add5070, -2147483648
  %add5072 = add nsw i32 %sub5071, -2147483648
  br label %cond.end.5073

cond.end.5073:                                    ; preds = %cond.false.5067, %cond.true.5063
  %cond5074 = phi i32 [ %add5066, %cond.true.5063 ], [ %add5072, %cond.false.5067 ]
  %conv5075 = sext i32 %cond5074 to i64
  store i64 %conv5075, i64* %alloca_size, align 8
  br i1 false, label %if.then, label %lor.lhs.false.5873

cond.false.5076:                                  ; preds = %cond.true.4863
  %916 = load i64, i64* %alloca_size, align 8
  %mul5077 = mul nsw i64 0, %916
  %917 = load i64, i64* %formatlen, align 8
  %add5078 = add nsw i64 %mul5077, %917
  %mul5079 = mul nsw i64 0, %add5078
  %sub5080 = sub nsw i64 %mul5079, 1
  %cmp5081 = icmp slt i64 %sub5080, 0
  br i1 %cmp5081, label %cond.true.5083, label %cond.false.5102

cond.true.5083:                                   ; preds = %cond.false.5076
  %918 = load i64, i64* %alloca_size, align 8
  %mul5084 = mul nsw i64 0, %918
  %919 = load i64, i64* %formatlen, align 8
  %add5085 = add nsw i64 %mul5084, %919
  %mul5086 = mul nsw i64 0, %add5085
  %add5087 = add nsw i64 %mul5086, 0
  %neg5088 = xor i64 %add5087, -1
  %cmp5089 = icmp eq i64 %neg5088, -1
  %conv5090 = zext i1 %cmp5089 to i32
  %sub5091 = sub nsw i32 0, %conv5090
  %conv5092 = sext i32 %sub5091 to i64
  %920 = load i64, i64* %alloca_size, align 8
  %mul5093 = mul nsw i64 0, %920
  %921 = load i64, i64* %formatlen, align 8
  %add5094 = add nsw i64 %mul5093, %921
  %mul5095 = mul nsw i64 0, %add5094
  %add5096 = add nsw i64 %mul5095, 1
  %shl5097 = shl i64 %add5096, 62
  %sub5098 = sub nsw i64 %shl5097, 1
  %mul5099 = mul nsw i64 %sub5098, 2
  %add5100 = add nsw i64 %mul5099, 1
  %sub5101 = sub nsw i64 %conv5092, %add5100
  br label %cond.end.5107

cond.false.5102:                                  ; preds = %cond.false.5076
  %922 = load i64, i64* %alloca_size, align 8
  %mul5103 = mul nsw i64 0, %922
  %923 = load i64, i64* %formatlen, align 8
  %add5104 = add nsw i64 %mul5103, %923
  %mul5105 = mul nsw i64 0, %add5104
  %add5106 = add nsw i64 %mul5105, 0
  br label %cond.end.5107

cond.end.5107:                                    ; preds = %cond.false.5102, %cond.true.5083
  %cond5108 = phi i64 [ %sub5101, %cond.true.5083 ], [ %add5106, %cond.false.5102 ]
  %cmp5109 = icmp slt i64 %cond5108, 0
  br i1 %cmp5109, label %cond.true.5111, label %cond.false.5176

cond.true.5111:                                   ; preds = %cond.end.5107
  %924 = load i64, i64* %alloca_size, align 8
  %cmp5112 = icmp slt i64 %924, 0
  br i1 %cmp5112, label %cond.true.5114, label %cond.false.5150

cond.true.5114:                                   ; preds = %cond.true.5111
  %925 = load i64, i64* %formatlen, align 8
  %926 = load i64, i64* %alloca_size, align 8
  %mul5115 = mul nsw i64 0, %926
  %927 = load i64, i64* %formatlen, align 8
  %add5116 = add nsw i64 %mul5115, %927
  %mul5117 = mul nsw i64 0, %add5116
  %sub5118 = sub nsw i64 %mul5117, 1
  %cmp5119 = icmp slt i64 %sub5118, 0
  br i1 %cmp5119, label %cond.true.5121, label %cond.false.5140

cond.true.5121:                                   ; preds = %cond.true.5114
  %928 = load i64, i64* %alloca_size, align 8
  %mul5122 = mul nsw i64 0, %928
  %929 = load i64, i64* %formatlen, align 8
  %add5123 = add nsw i64 %mul5122, %929
  %mul5124 = mul nsw i64 0, %add5123
  %add5125 = add nsw i64 %mul5124, 0
  %neg5126 = xor i64 %add5125, -1
  %cmp5127 = icmp eq i64 %neg5126, -1
  %conv5128 = zext i1 %cmp5127 to i32
  %sub5129 = sub nsw i32 0, %conv5128
  %conv5130 = sext i32 %sub5129 to i64
  %930 = load i64, i64* %alloca_size, align 8
  %mul5131 = mul nsw i64 0, %930
  %931 = load i64, i64* %formatlen, align 8
  %add5132 = add nsw i64 %mul5131, %931
  %mul5133 = mul nsw i64 0, %add5132
  %add5134 = add nsw i64 %mul5133, 1
  %shl5135 = shl i64 %add5134, 62
  %sub5136 = sub nsw i64 %shl5135, 1
  %mul5137 = mul nsw i64 %sub5136, 2
  %add5138 = add nsw i64 %mul5137, 1
  %sub5139 = sub nsw i64 %conv5130, %add5138
  br label %cond.end.5145

cond.false.5140:                                  ; preds = %cond.true.5114
  %932 = load i64, i64* %alloca_size, align 8
  %mul5141 = mul nsw i64 0, %932
  %933 = load i64, i64* %formatlen, align 8
  %add5142 = add nsw i64 %mul5141, %933
  %mul5143 = mul nsw i64 0, %add5142
  %add5144 = add nsw i64 %mul5143, 0
  br label %cond.end.5145

cond.end.5145:                                    ; preds = %cond.false.5140, %cond.true.5121
  %cond5146 = phi i64 [ %sub5139, %cond.true.5121 ], [ %add5144, %cond.false.5140 ]
  %934 = load i64, i64* %alloca_size, align 8
  %sub5147 = sub nsw i64 %cond5146, %934
  %cmp5148 = icmp slt i64 %925, %sub5147
  br i1 %cmp5148, label %cond.true.5208, label %lor.lhs.false.5194

cond.false.5150:                                  ; preds = %cond.true.5111
  %935 = load i64, i64* %alloca_size, align 8
  %mul5151 = mul nsw i64 0, %935
  %936 = load i64, i64* %formatlen, align 8
  %add5152 = add nsw i64 %mul5151, %936
  %mul5153 = mul nsw i64 0, %add5152
  %sub5154 = sub nsw i64 %mul5153, 1
  %cmp5155 = icmp slt i64 %sub5154, 0
  br i1 %cmp5155, label %cond.true.5157, label %cond.false.5166

cond.true.5157:                                   ; preds = %cond.false.5150
  %937 = load i64, i64* %alloca_size, align 8
  %mul5158 = mul nsw i64 0, %937
  %938 = load i64, i64* %formatlen, align 8
  %add5159 = add nsw i64 %mul5158, %938
  %mul5160 = mul nsw i64 0, %add5159
  %add5161 = add nsw i64 %mul5160, 1
  %shl5162 = shl i64 %add5161, 62
  %sub5163 = sub nsw i64 %shl5162, 1
  %mul5164 = mul nsw i64 %sub5163, 2
  %add5165 = add nsw i64 %mul5164, 1
  br label %cond.end.5171

cond.false.5166:                                  ; preds = %cond.false.5150
  %939 = load i64, i64* %alloca_size, align 8
  %mul5167 = mul nsw i64 0, %939
  %940 = load i64, i64* %formatlen, align 8
  %add5168 = add nsw i64 %mul5167, %940
  %mul5169 = mul nsw i64 0, %add5168
  %sub5170 = sub nsw i64 %mul5169, 1
  br label %cond.end.5171

cond.end.5171:                                    ; preds = %cond.false.5166, %cond.true.5157
  %cond5172 = phi i64 [ %add5165, %cond.true.5157 ], [ %sub5170, %cond.false.5166 ]
  %941 = load i64, i64* %alloca_size, align 8
  %sub5173 = sub nsw i64 %cond5172, %941
  %942 = load i64, i64* %formatlen, align 8
  %cmp5174 = icmp slt i64 %sub5173, %942
  br i1 %cmp5174, label %cond.true.5208, label %lor.lhs.false.5194

cond.false.5176:                                  ; preds = %cond.end.5107
  %943 = load i64, i64* %formatlen, align 8
  %cmp5177 = icmp slt i64 %943, 0
  br i1 %cmp5177, label %cond.true.5179, label %cond.false.5183

cond.true.5179:                                   ; preds = %cond.false.5176
  %944 = load i64, i64* %alloca_size, align 8
  %945 = load i64, i64* %formatlen, align 8
  %946 = load i64, i64* %alloca_size, align 8
  %add5180 = add nsw i64 %945, %946
  %cmp5181 = icmp sle i64 %944, %add5180
  br i1 %cmp5181, label %cond.true.5208, label %lor.lhs.false.5194

cond.false.5183:                                  ; preds = %cond.false.5176
  %947 = load i64, i64* %alloca_size, align 8
  %cmp5184 = icmp slt i64 %947, 0
  br i1 %cmp5184, label %cond.true.5186, label %cond.false.5190

cond.true.5186:                                   ; preds = %cond.false.5183
  %948 = load i64, i64* %formatlen, align 8
  %949 = load i64, i64* %formatlen, align 8
  %950 = load i64, i64* %alloca_size, align 8
  %add5187 = add nsw i64 %949, %950
  %cmp5188 = icmp sle i64 %948, %add5187
  br i1 %cmp5188, label %cond.true.5208, label %lor.lhs.false.5194

cond.false.5190:                                  ; preds = %cond.false.5183
  %951 = load i64, i64* %formatlen, align 8
  %952 = load i64, i64* %alloca_size, align 8
  %add5191 = add nsw i64 %951, %952
  %953 = load i64, i64* %alloca_size, align 8
  %cmp5192 = icmp slt i64 %add5191, %953
  br i1 %cmp5192, label %cond.true.5208, label %lor.lhs.false.5194

lor.lhs.false.5194:                               ; preds = %cond.false.5190, %cond.true.5186, %cond.true.5179, %cond.end.5171, %cond.end.5145
  %954 = load i64, i64* %formatlen, align 8
  %955 = load i64, i64* %alloca_size, align 8
  %add5195 = add nsw i64 %954, %955
  %mul5196 = mul nsw i64 0, %add5195
  %sub5197 = sub nsw i64 %mul5196, 1
  %cmp5198 = icmp slt i64 %sub5197, 0
  br i1 %cmp5198, label %land.lhs.true.5200, label %lor.lhs.false.5204

land.lhs.true.5200:                               ; preds = %lor.lhs.false.5194
  %956 = load i64, i64* %formatlen, align 8
  %957 = load i64, i64* %alloca_size, align 8
  %add5201 = add nsw i64 %956, %957
  %cmp5202 = icmp slt i64 %add5201, -2147483648
  br i1 %cmp5202, label %cond.true.5208, label %lor.lhs.false.5204

lor.lhs.false.5204:                               ; preds = %land.lhs.true.5200, %lor.lhs.false.5194
  %958 = load i64, i64* %formatlen, align 8
  %959 = load i64, i64* %alloca_size, align 8
  %add5205 = add nsw i64 %958, %959
  %cmp5206 = icmp slt i64 2147483647, %add5205
  br i1 %cmp5206, label %cond.true.5208, label %cond.false.5227

cond.true.5208:                                   ; preds = %lor.lhs.false.5204, %land.lhs.true.5200, %cond.false.5190, %cond.true.5186, %cond.true.5179, %cond.end.5171, %cond.end.5145
  %960 = load i64, i64* %formatlen, align 8
  %conv5209 = trunc i64 %960 to i32
  %961 = load i64, i64* %alloca_size, align 8
  %conv5210 = trunc i64 %961 to i32
  %add5211 = add i32 %conv5209, %conv5210
  %cmp5212 = icmp ule i32 %add5211, 2147483647
  br i1 %cmp5212, label %cond.true.5214, label %cond.false.5218

cond.true.5214:                                   ; preds = %cond.true.5208
  %962 = load i64, i64* %formatlen, align 8
  %conv5215 = trunc i64 %962 to i32
  %963 = load i64, i64* %alloca_size, align 8
  %conv5216 = trunc i64 %963 to i32
  %add5217 = add i32 %conv5215, %conv5216
  br label %cond.end.5224

cond.false.5218:                                  ; preds = %cond.true.5208
  %964 = load i64, i64* %formatlen, align 8
  %conv5219 = trunc i64 %964 to i32
  %965 = load i64, i64* %alloca_size, align 8
  %conv5220 = trunc i64 %965 to i32
  %add5221 = add i32 %conv5219, %conv5220
  %sub5222 = sub i32 %add5221, -2147483648
  %add5223 = add nsw i32 %sub5222, -2147483648
  br label %cond.end.5224

cond.end.5224:                                    ; preds = %cond.false.5218, %cond.true.5214
  %cond5225 = phi i32 [ %add5217, %cond.true.5214 ], [ %add5223, %cond.false.5218 ]
  %conv5226 = sext i32 %cond5225 to i64
  store i64 %conv5226, i64* %alloca_size, align 8
  br i1 true, label %if.then, label %lor.lhs.false.5873

cond.false.5227:                                  ; preds = %lor.lhs.false.5204
  %966 = load i64, i64* %formatlen, align 8
  %conv5228 = trunc i64 %966 to i32
  %967 = load i64, i64* %alloca_size, align 8
  %conv5229 = trunc i64 %967 to i32
  %add5230 = add i32 %conv5228, %conv5229
  %cmp5231 = icmp ule i32 %add5230, 2147483647
  br i1 %cmp5231, label %cond.true.5233, label %cond.false.5237

cond.true.5233:                                   ; preds = %cond.false.5227
  %968 = load i64, i64* %formatlen, align 8
  %conv5234 = trunc i64 %968 to i32
  %969 = load i64, i64* %alloca_size, align 8
  %conv5235 = trunc i64 %969 to i32
  %add5236 = add i32 %conv5234, %conv5235
  br label %cond.end.5243

cond.false.5237:                                  ; preds = %cond.false.5227
  %970 = load i64, i64* %formatlen, align 8
  %conv5238 = trunc i64 %970 to i32
  %971 = load i64, i64* %alloca_size, align 8
  %conv5239 = trunc i64 %971 to i32
  %add5240 = add i32 %conv5238, %conv5239
  %sub5241 = sub i32 %add5240, -2147483648
  %add5242 = add nsw i32 %sub5241, -2147483648
  br label %cond.end.5243

cond.end.5243:                                    ; preds = %cond.false.5237, %cond.true.5233
  %cond5244 = phi i32 [ %add5236, %cond.true.5233 ], [ %add5242, %cond.false.5237 ]
  %conv5245 = sext i32 %cond5244 to i64
  store i64 %conv5245, i64* %alloca_size, align 8
  br i1 false, label %if.then, label %lor.lhs.false.5873

cond.false.5246:                                  ; preds = %cond.false.4862
  br i1 true, label %cond.true.5247, label %cond.false.5560

cond.true.5247:                                   ; preds = %cond.false.5246
  br i1 false, label %cond.true.5248, label %cond.false.5404

cond.true.5248:                                   ; preds = %cond.true.5247
  %972 = load i64, i64* %alloca_size, align 8
  %mul5249 = mul nsw i64 0, %972
  %973 = load i64, i64* %formatlen, align 8
  %add5250 = add nsw i64 %mul5249, %973
  %mul5251 = mul nsw i64 0, %add5250
  %sub5252 = sub nsw i64 %mul5251, 1
  %cmp5253 = icmp slt i64 %sub5252, 0
  br i1 %cmp5253, label %cond.true.5255, label %cond.false.5274

cond.true.5255:                                   ; preds = %cond.true.5248
  %974 = load i64, i64* %alloca_size, align 8
  %mul5256 = mul nsw i64 0, %974
  %975 = load i64, i64* %formatlen, align 8
  %add5257 = add nsw i64 %mul5256, %975
  %mul5258 = mul nsw i64 0, %add5257
  %add5259 = add nsw i64 %mul5258, 0
  %neg5260 = xor i64 %add5259, -1
  %cmp5261 = icmp eq i64 %neg5260, -1
  %conv5262 = zext i1 %cmp5261 to i32
  %sub5263 = sub nsw i32 0, %conv5262
  %conv5264 = sext i32 %sub5263 to i64
  %976 = load i64, i64* %alloca_size, align 8
  %mul5265 = mul nsw i64 0, %976
  %977 = load i64, i64* %formatlen, align 8
  %add5266 = add nsw i64 %mul5265, %977
  %mul5267 = mul nsw i64 0, %add5266
  %add5268 = add nsw i64 %mul5267, 1
  %shl5269 = shl i64 %add5268, 62
  %sub5270 = sub nsw i64 %shl5269, 1
  %mul5271 = mul nsw i64 %sub5270, 2
  %add5272 = add nsw i64 %mul5271, 1
  %sub5273 = sub nsw i64 %conv5264, %add5272
  br label %cond.end.5279

cond.false.5274:                                  ; preds = %cond.true.5248
  %978 = load i64, i64* %alloca_size, align 8
  %mul5275 = mul nsw i64 0, %978
  %979 = load i64, i64* %formatlen, align 8
  %add5276 = add nsw i64 %mul5275, %979
  %mul5277 = mul nsw i64 0, %add5276
  %add5278 = add nsw i64 %mul5277, 0
  br label %cond.end.5279

cond.end.5279:                                    ; preds = %cond.false.5274, %cond.true.5255
  %cond5280 = phi i64 [ %sub5273, %cond.true.5255 ], [ %add5278, %cond.false.5274 ]
  %cmp5281 = icmp slt i64 %cond5280, 0
  br i1 %cmp5281, label %cond.true.5283, label %cond.false.5348

cond.true.5283:                                   ; preds = %cond.end.5279
  %980 = load i64, i64* %alloca_size, align 8
  %cmp5284 = icmp slt i64 %980, 0
  br i1 %cmp5284, label %cond.true.5286, label %cond.false.5322

cond.true.5286:                                   ; preds = %cond.true.5283
  %981 = load i64, i64* %formatlen, align 8
  %982 = load i64, i64* %alloca_size, align 8
  %mul5287 = mul nsw i64 0, %982
  %983 = load i64, i64* %formatlen, align 8
  %add5288 = add nsw i64 %mul5287, %983
  %mul5289 = mul nsw i64 0, %add5288
  %sub5290 = sub nsw i64 %mul5289, 1
  %cmp5291 = icmp slt i64 %sub5290, 0
  br i1 %cmp5291, label %cond.true.5293, label %cond.false.5312

cond.true.5293:                                   ; preds = %cond.true.5286
  %984 = load i64, i64* %alloca_size, align 8
  %mul5294 = mul nsw i64 0, %984
  %985 = load i64, i64* %formatlen, align 8
  %add5295 = add nsw i64 %mul5294, %985
  %mul5296 = mul nsw i64 0, %add5295
  %add5297 = add nsw i64 %mul5296, 0
  %neg5298 = xor i64 %add5297, -1
  %cmp5299 = icmp eq i64 %neg5298, -1
  %conv5300 = zext i1 %cmp5299 to i32
  %sub5301 = sub nsw i32 0, %conv5300
  %conv5302 = sext i32 %sub5301 to i64
  %986 = load i64, i64* %alloca_size, align 8
  %mul5303 = mul nsw i64 0, %986
  %987 = load i64, i64* %formatlen, align 8
  %add5304 = add nsw i64 %mul5303, %987
  %mul5305 = mul nsw i64 0, %add5304
  %add5306 = add nsw i64 %mul5305, 1
  %shl5307 = shl i64 %add5306, 62
  %sub5308 = sub nsw i64 %shl5307, 1
  %mul5309 = mul nsw i64 %sub5308, 2
  %add5310 = add nsw i64 %mul5309, 1
  %sub5311 = sub nsw i64 %conv5302, %add5310
  br label %cond.end.5317

cond.false.5312:                                  ; preds = %cond.true.5286
  %988 = load i64, i64* %alloca_size, align 8
  %mul5313 = mul nsw i64 0, %988
  %989 = load i64, i64* %formatlen, align 8
  %add5314 = add nsw i64 %mul5313, %989
  %mul5315 = mul nsw i64 0, %add5314
  %add5316 = add nsw i64 %mul5315, 0
  br label %cond.end.5317

cond.end.5317:                                    ; preds = %cond.false.5312, %cond.true.5293
  %cond5318 = phi i64 [ %sub5311, %cond.true.5293 ], [ %add5316, %cond.false.5312 ]
  %990 = load i64, i64* %alloca_size, align 8
  %sub5319 = sub nsw i64 %cond5318, %990
  %cmp5320 = icmp slt i64 %981, %sub5319
  br i1 %cmp5320, label %cond.true.5380, label %lor.lhs.false.5366

cond.false.5322:                                  ; preds = %cond.true.5283
  %991 = load i64, i64* %alloca_size, align 8
  %mul5323 = mul nsw i64 0, %991
  %992 = load i64, i64* %formatlen, align 8
  %add5324 = add nsw i64 %mul5323, %992
  %mul5325 = mul nsw i64 0, %add5324
  %sub5326 = sub nsw i64 %mul5325, 1
  %cmp5327 = icmp slt i64 %sub5326, 0
  br i1 %cmp5327, label %cond.true.5329, label %cond.false.5338

cond.true.5329:                                   ; preds = %cond.false.5322
  %993 = load i64, i64* %alloca_size, align 8
  %mul5330 = mul nsw i64 0, %993
  %994 = load i64, i64* %formatlen, align 8
  %add5331 = add nsw i64 %mul5330, %994
  %mul5332 = mul nsw i64 0, %add5331
  %add5333 = add nsw i64 %mul5332, 1
  %shl5334 = shl i64 %add5333, 62
  %sub5335 = sub nsw i64 %shl5334, 1
  %mul5336 = mul nsw i64 %sub5335, 2
  %add5337 = add nsw i64 %mul5336, 1
  br label %cond.end.5343

cond.false.5338:                                  ; preds = %cond.false.5322
  %995 = load i64, i64* %alloca_size, align 8
  %mul5339 = mul nsw i64 0, %995
  %996 = load i64, i64* %formatlen, align 8
  %add5340 = add nsw i64 %mul5339, %996
  %mul5341 = mul nsw i64 0, %add5340
  %sub5342 = sub nsw i64 %mul5341, 1
  br label %cond.end.5343

cond.end.5343:                                    ; preds = %cond.false.5338, %cond.true.5329
  %cond5344 = phi i64 [ %add5337, %cond.true.5329 ], [ %sub5342, %cond.false.5338 ]
  %997 = load i64, i64* %alloca_size, align 8
  %sub5345 = sub nsw i64 %cond5344, %997
  %998 = load i64, i64* %formatlen, align 8
  %cmp5346 = icmp slt i64 %sub5345, %998
  br i1 %cmp5346, label %cond.true.5380, label %lor.lhs.false.5366

cond.false.5348:                                  ; preds = %cond.end.5279
  %999 = load i64, i64* %formatlen, align 8
  %cmp5349 = icmp slt i64 %999, 0
  br i1 %cmp5349, label %cond.true.5351, label %cond.false.5355

cond.true.5351:                                   ; preds = %cond.false.5348
  %1000 = load i64, i64* %alloca_size, align 8
  %1001 = load i64, i64* %formatlen, align 8
  %1002 = load i64, i64* %alloca_size, align 8
  %add5352 = add nsw i64 %1001, %1002
  %cmp5353 = icmp sle i64 %1000, %add5352
  br i1 %cmp5353, label %cond.true.5380, label %lor.lhs.false.5366

cond.false.5355:                                  ; preds = %cond.false.5348
  %1003 = load i64, i64* %alloca_size, align 8
  %cmp5356 = icmp slt i64 %1003, 0
  br i1 %cmp5356, label %cond.true.5358, label %cond.false.5362

cond.true.5358:                                   ; preds = %cond.false.5355
  %1004 = load i64, i64* %formatlen, align 8
  %1005 = load i64, i64* %formatlen, align 8
  %1006 = load i64, i64* %alloca_size, align 8
  %add5359 = add nsw i64 %1005, %1006
  %cmp5360 = icmp sle i64 %1004, %add5359
  br i1 %cmp5360, label %cond.true.5380, label %lor.lhs.false.5366

cond.false.5362:                                  ; preds = %cond.false.5355
  %1007 = load i64, i64* %formatlen, align 8
  %1008 = load i64, i64* %alloca_size, align 8
  %add5363 = add nsw i64 %1007, %1008
  %1009 = load i64, i64* %alloca_size, align 8
  %cmp5364 = icmp slt i64 %add5363, %1009
  br i1 %cmp5364, label %cond.true.5380, label %lor.lhs.false.5366

lor.lhs.false.5366:                               ; preds = %cond.false.5362, %cond.true.5358, %cond.true.5351, %cond.end.5343, %cond.end.5317
  %1010 = load i64, i64* %formatlen, align 8
  %1011 = load i64, i64* %alloca_size, align 8
  %add5367 = add nsw i64 %1010, %1011
  %mul5368 = mul nsw i64 0, %add5367
  %sub5369 = sub nsw i64 %mul5368, 1
  %cmp5370 = icmp slt i64 %sub5369, 0
  br i1 %cmp5370, label %land.lhs.true.5372, label %lor.lhs.false.5376

land.lhs.true.5372:                               ; preds = %lor.lhs.false.5366
  %1012 = load i64, i64* %formatlen, align 8
  %1013 = load i64, i64* %alloca_size, align 8
  %add5373 = add nsw i64 %1012, %1013
  %cmp5374 = icmp slt i64 %add5373, -9223372036854775808
  br i1 %cmp5374, label %cond.true.5380, label %lor.lhs.false.5376

lor.lhs.false.5376:                               ; preds = %land.lhs.true.5372, %lor.lhs.false.5366
  %1014 = load i64, i64* %formatlen, align 8
  %1015 = load i64, i64* %alloca_size, align 8
  %add5377 = add nsw i64 %1014, %1015
  %cmp5378 = icmp slt i64 9223372036854775807, %add5377
  br i1 %cmp5378, label %cond.true.5380, label %cond.false.5392

cond.true.5380:                                   ; preds = %lor.lhs.false.5376, %land.lhs.true.5372, %cond.false.5362, %cond.true.5358, %cond.true.5351, %cond.end.5343, %cond.end.5317
  %1016 = load i64, i64* %formatlen, align 8
  %1017 = load i64, i64* %alloca_size, align 8
  %add5381 = add i64 %1016, %1017
  %cmp5382 = icmp ule i64 %add5381, 9223372036854775807
  br i1 %cmp5382, label %cond.true.5384, label %cond.false.5386

cond.true.5384:                                   ; preds = %cond.true.5380
  %1018 = load i64, i64* %formatlen, align 8
  %1019 = load i64, i64* %alloca_size, align 8
  %add5385 = add i64 %1018, %1019
  br label %cond.end.5390

cond.false.5386:                                  ; preds = %cond.true.5380
  %1020 = load i64, i64* %formatlen, align 8
  %1021 = load i64, i64* %alloca_size, align 8
  %add5387 = add i64 %1020, %1021
  %sub5388 = sub i64 %add5387, -9223372036854775808
  %add5389 = add nsw i64 %sub5388, -9223372036854775808
  br label %cond.end.5390

cond.end.5390:                                    ; preds = %cond.false.5386, %cond.true.5384
  %cond5391 = phi i64 [ %add5385, %cond.true.5384 ], [ %add5389, %cond.false.5386 ]
  store i64 %cond5391, i64* %alloca_size, align 8
  br i1 true, label %if.then, label %lor.lhs.false.5873

cond.false.5392:                                  ; preds = %lor.lhs.false.5376
  %1022 = load i64, i64* %formatlen, align 8
  %1023 = load i64, i64* %alloca_size, align 8
  %add5393 = add i64 %1022, %1023
  %cmp5394 = icmp ule i64 %add5393, 9223372036854775807
  br i1 %cmp5394, label %cond.true.5396, label %cond.false.5398

cond.true.5396:                                   ; preds = %cond.false.5392
  %1024 = load i64, i64* %formatlen, align 8
  %1025 = load i64, i64* %alloca_size, align 8
  %add5397 = add i64 %1024, %1025
  br label %cond.end.5402

cond.false.5398:                                  ; preds = %cond.false.5392
  %1026 = load i64, i64* %formatlen, align 8
  %1027 = load i64, i64* %alloca_size, align 8
  %add5399 = add i64 %1026, %1027
  %sub5400 = sub i64 %add5399, -9223372036854775808
  %add5401 = add nsw i64 %sub5400, -9223372036854775808
  br label %cond.end.5402

cond.end.5402:                                    ; preds = %cond.false.5398, %cond.true.5396
  %cond5403 = phi i64 [ %add5397, %cond.true.5396 ], [ %add5401, %cond.false.5398 ]
  store i64 %cond5403, i64* %alloca_size, align 8
  br i1 false, label %if.then, label %lor.lhs.false.5873

cond.false.5404:                                  ; preds = %cond.true.5247
  %1028 = load i64, i64* %alloca_size, align 8
  %mul5405 = mul nsw i64 0, %1028
  %1029 = load i64, i64* %formatlen, align 8
  %add5406 = add nsw i64 %mul5405, %1029
  %mul5407 = mul nsw i64 0, %add5406
  %sub5408 = sub nsw i64 %mul5407, 1
  %cmp5409 = icmp slt i64 %sub5408, 0
  br i1 %cmp5409, label %cond.true.5411, label %cond.false.5430

cond.true.5411:                                   ; preds = %cond.false.5404
  %1030 = load i64, i64* %alloca_size, align 8
  %mul5412 = mul nsw i64 0, %1030
  %1031 = load i64, i64* %formatlen, align 8
  %add5413 = add nsw i64 %mul5412, %1031
  %mul5414 = mul nsw i64 0, %add5413
  %add5415 = add nsw i64 %mul5414, 0
  %neg5416 = xor i64 %add5415, -1
  %cmp5417 = icmp eq i64 %neg5416, -1
  %conv5418 = zext i1 %cmp5417 to i32
  %sub5419 = sub nsw i32 0, %conv5418
  %conv5420 = sext i32 %sub5419 to i64
  %1032 = load i64, i64* %alloca_size, align 8
  %mul5421 = mul nsw i64 0, %1032
  %1033 = load i64, i64* %formatlen, align 8
  %add5422 = add nsw i64 %mul5421, %1033
  %mul5423 = mul nsw i64 0, %add5422
  %add5424 = add nsw i64 %mul5423, 1
  %shl5425 = shl i64 %add5424, 62
  %sub5426 = sub nsw i64 %shl5425, 1
  %mul5427 = mul nsw i64 %sub5426, 2
  %add5428 = add nsw i64 %mul5427, 1
  %sub5429 = sub nsw i64 %conv5420, %add5428
  br label %cond.end.5435

cond.false.5430:                                  ; preds = %cond.false.5404
  %1034 = load i64, i64* %alloca_size, align 8
  %mul5431 = mul nsw i64 0, %1034
  %1035 = load i64, i64* %formatlen, align 8
  %add5432 = add nsw i64 %mul5431, %1035
  %mul5433 = mul nsw i64 0, %add5432
  %add5434 = add nsw i64 %mul5433, 0
  br label %cond.end.5435

cond.end.5435:                                    ; preds = %cond.false.5430, %cond.true.5411
  %cond5436 = phi i64 [ %sub5429, %cond.true.5411 ], [ %add5434, %cond.false.5430 ]
  %cmp5437 = icmp slt i64 %cond5436, 0
  br i1 %cmp5437, label %cond.true.5439, label %cond.false.5504

cond.true.5439:                                   ; preds = %cond.end.5435
  %1036 = load i64, i64* %alloca_size, align 8
  %cmp5440 = icmp slt i64 %1036, 0
  br i1 %cmp5440, label %cond.true.5442, label %cond.false.5478

cond.true.5442:                                   ; preds = %cond.true.5439
  %1037 = load i64, i64* %formatlen, align 8
  %1038 = load i64, i64* %alloca_size, align 8
  %mul5443 = mul nsw i64 0, %1038
  %1039 = load i64, i64* %formatlen, align 8
  %add5444 = add nsw i64 %mul5443, %1039
  %mul5445 = mul nsw i64 0, %add5444
  %sub5446 = sub nsw i64 %mul5445, 1
  %cmp5447 = icmp slt i64 %sub5446, 0
  br i1 %cmp5447, label %cond.true.5449, label %cond.false.5468

cond.true.5449:                                   ; preds = %cond.true.5442
  %1040 = load i64, i64* %alloca_size, align 8
  %mul5450 = mul nsw i64 0, %1040
  %1041 = load i64, i64* %formatlen, align 8
  %add5451 = add nsw i64 %mul5450, %1041
  %mul5452 = mul nsw i64 0, %add5451
  %add5453 = add nsw i64 %mul5452, 0
  %neg5454 = xor i64 %add5453, -1
  %cmp5455 = icmp eq i64 %neg5454, -1
  %conv5456 = zext i1 %cmp5455 to i32
  %sub5457 = sub nsw i32 0, %conv5456
  %conv5458 = sext i32 %sub5457 to i64
  %1042 = load i64, i64* %alloca_size, align 8
  %mul5459 = mul nsw i64 0, %1042
  %1043 = load i64, i64* %formatlen, align 8
  %add5460 = add nsw i64 %mul5459, %1043
  %mul5461 = mul nsw i64 0, %add5460
  %add5462 = add nsw i64 %mul5461, 1
  %shl5463 = shl i64 %add5462, 62
  %sub5464 = sub nsw i64 %shl5463, 1
  %mul5465 = mul nsw i64 %sub5464, 2
  %add5466 = add nsw i64 %mul5465, 1
  %sub5467 = sub nsw i64 %conv5458, %add5466
  br label %cond.end.5473

cond.false.5468:                                  ; preds = %cond.true.5442
  %1044 = load i64, i64* %alloca_size, align 8
  %mul5469 = mul nsw i64 0, %1044
  %1045 = load i64, i64* %formatlen, align 8
  %add5470 = add nsw i64 %mul5469, %1045
  %mul5471 = mul nsw i64 0, %add5470
  %add5472 = add nsw i64 %mul5471, 0
  br label %cond.end.5473

cond.end.5473:                                    ; preds = %cond.false.5468, %cond.true.5449
  %cond5474 = phi i64 [ %sub5467, %cond.true.5449 ], [ %add5472, %cond.false.5468 ]
  %1046 = load i64, i64* %alloca_size, align 8
  %sub5475 = sub nsw i64 %cond5474, %1046
  %cmp5476 = icmp slt i64 %1037, %sub5475
  br i1 %cmp5476, label %cond.true.5536, label %lor.lhs.false.5522

cond.false.5478:                                  ; preds = %cond.true.5439
  %1047 = load i64, i64* %alloca_size, align 8
  %mul5479 = mul nsw i64 0, %1047
  %1048 = load i64, i64* %formatlen, align 8
  %add5480 = add nsw i64 %mul5479, %1048
  %mul5481 = mul nsw i64 0, %add5480
  %sub5482 = sub nsw i64 %mul5481, 1
  %cmp5483 = icmp slt i64 %sub5482, 0
  br i1 %cmp5483, label %cond.true.5485, label %cond.false.5494

cond.true.5485:                                   ; preds = %cond.false.5478
  %1049 = load i64, i64* %alloca_size, align 8
  %mul5486 = mul nsw i64 0, %1049
  %1050 = load i64, i64* %formatlen, align 8
  %add5487 = add nsw i64 %mul5486, %1050
  %mul5488 = mul nsw i64 0, %add5487
  %add5489 = add nsw i64 %mul5488, 1
  %shl5490 = shl i64 %add5489, 62
  %sub5491 = sub nsw i64 %shl5490, 1
  %mul5492 = mul nsw i64 %sub5491, 2
  %add5493 = add nsw i64 %mul5492, 1
  br label %cond.end.5499

cond.false.5494:                                  ; preds = %cond.false.5478
  %1051 = load i64, i64* %alloca_size, align 8
  %mul5495 = mul nsw i64 0, %1051
  %1052 = load i64, i64* %formatlen, align 8
  %add5496 = add nsw i64 %mul5495, %1052
  %mul5497 = mul nsw i64 0, %add5496
  %sub5498 = sub nsw i64 %mul5497, 1
  br label %cond.end.5499

cond.end.5499:                                    ; preds = %cond.false.5494, %cond.true.5485
  %cond5500 = phi i64 [ %add5493, %cond.true.5485 ], [ %sub5498, %cond.false.5494 ]
  %1053 = load i64, i64* %alloca_size, align 8
  %sub5501 = sub nsw i64 %cond5500, %1053
  %1054 = load i64, i64* %formatlen, align 8
  %cmp5502 = icmp slt i64 %sub5501, %1054
  br i1 %cmp5502, label %cond.true.5536, label %lor.lhs.false.5522

cond.false.5504:                                  ; preds = %cond.end.5435
  %1055 = load i64, i64* %formatlen, align 8
  %cmp5505 = icmp slt i64 %1055, 0
  br i1 %cmp5505, label %cond.true.5507, label %cond.false.5511

cond.true.5507:                                   ; preds = %cond.false.5504
  %1056 = load i64, i64* %alloca_size, align 8
  %1057 = load i64, i64* %formatlen, align 8
  %1058 = load i64, i64* %alloca_size, align 8
  %add5508 = add nsw i64 %1057, %1058
  %cmp5509 = icmp sle i64 %1056, %add5508
  br i1 %cmp5509, label %cond.true.5536, label %lor.lhs.false.5522

cond.false.5511:                                  ; preds = %cond.false.5504
  %1059 = load i64, i64* %alloca_size, align 8
  %cmp5512 = icmp slt i64 %1059, 0
  br i1 %cmp5512, label %cond.true.5514, label %cond.false.5518

cond.true.5514:                                   ; preds = %cond.false.5511
  %1060 = load i64, i64* %formatlen, align 8
  %1061 = load i64, i64* %formatlen, align 8
  %1062 = load i64, i64* %alloca_size, align 8
  %add5515 = add nsw i64 %1061, %1062
  %cmp5516 = icmp sle i64 %1060, %add5515
  br i1 %cmp5516, label %cond.true.5536, label %lor.lhs.false.5522

cond.false.5518:                                  ; preds = %cond.false.5511
  %1063 = load i64, i64* %formatlen, align 8
  %1064 = load i64, i64* %alloca_size, align 8
  %add5519 = add nsw i64 %1063, %1064
  %1065 = load i64, i64* %alloca_size, align 8
  %cmp5520 = icmp slt i64 %add5519, %1065
  br i1 %cmp5520, label %cond.true.5536, label %lor.lhs.false.5522

lor.lhs.false.5522:                               ; preds = %cond.false.5518, %cond.true.5514, %cond.true.5507, %cond.end.5499, %cond.end.5473
  %1066 = load i64, i64* %formatlen, align 8
  %1067 = load i64, i64* %alloca_size, align 8
  %add5523 = add nsw i64 %1066, %1067
  %mul5524 = mul nsw i64 0, %add5523
  %sub5525 = sub nsw i64 %mul5524, 1
  %cmp5526 = icmp slt i64 %sub5525, 0
  br i1 %cmp5526, label %land.lhs.true.5528, label %lor.lhs.false.5532

land.lhs.true.5528:                               ; preds = %lor.lhs.false.5522
  %1068 = load i64, i64* %formatlen, align 8
  %1069 = load i64, i64* %alloca_size, align 8
  %add5529 = add nsw i64 %1068, %1069
  %cmp5530 = icmp slt i64 %add5529, -9223372036854775808
  br i1 %cmp5530, label %cond.true.5536, label %lor.lhs.false.5532

lor.lhs.false.5532:                               ; preds = %land.lhs.true.5528, %lor.lhs.false.5522
  %1070 = load i64, i64* %formatlen, align 8
  %1071 = load i64, i64* %alloca_size, align 8
  %add5533 = add nsw i64 %1070, %1071
  %cmp5534 = icmp slt i64 9223372036854775807, %add5533
  br i1 %cmp5534, label %cond.true.5536, label %cond.false.5548

cond.true.5536:                                   ; preds = %lor.lhs.false.5532, %land.lhs.true.5528, %cond.false.5518, %cond.true.5514, %cond.true.5507, %cond.end.5499, %cond.end.5473
  %1072 = load i64, i64* %formatlen, align 8
  %1073 = load i64, i64* %alloca_size, align 8
  %add5537 = add i64 %1072, %1073
  %cmp5538 = icmp ule i64 %add5537, 9223372036854775807
  br i1 %cmp5538, label %cond.true.5540, label %cond.false.5542

cond.true.5540:                                   ; preds = %cond.true.5536
  %1074 = load i64, i64* %formatlen, align 8
  %1075 = load i64, i64* %alloca_size, align 8
  %add5541 = add i64 %1074, %1075
  br label %cond.end.5546

cond.false.5542:                                  ; preds = %cond.true.5536
  %1076 = load i64, i64* %formatlen, align 8
  %1077 = load i64, i64* %alloca_size, align 8
  %add5543 = add i64 %1076, %1077
  %sub5544 = sub i64 %add5543, -9223372036854775808
  %add5545 = add nsw i64 %sub5544, -9223372036854775808
  br label %cond.end.5546

cond.end.5546:                                    ; preds = %cond.false.5542, %cond.true.5540
  %cond5547 = phi i64 [ %add5541, %cond.true.5540 ], [ %add5545, %cond.false.5542 ]
  store i64 %cond5547, i64* %alloca_size, align 8
  br i1 true, label %if.then, label %lor.lhs.false.5873

cond.false.5548:                                  ; preds = %lor.lhs.false.5532
  %1078 = load i64, i64* %formatlen, align 8
  %1079 = load i64, i64* %alloca_size, align 8
  %add5549 = add i64 %1078, %1079
  %cmp5550 = icmp ule i64 %add5549, 9223372036854775807
  br i1 %cmp5550, label %cond.true.5552, label %cond.false.5554

cond.true.5552:                                   ; preds = %cond.false.5548
  %1080 = load i64, i64* %formatlen, align 8
  %1081 = load i64, i64* %alloca_size, align 8
  %add5553 = add i64 %1080, %1081
  br label %cond.end.5558

cond.false.5554:                                  ; preds = %cond.false.5548
  %1082 = load i64, i64* %formatlen, align 8
  %1083 = load i64, i64* %alloca_size, align 8
  %add5555 = add i64 %1082, %1083
  %sub5556 = sub i64 %add5555, -9223372036854775808
  %add5557 = add nsw i64 %sub5556, -9223372036854775808
  br label %cond.end.5558

cond.end.5558:                                    ; preds = %cond.false.5554, %cond.true.5552
  %cond5559 = phi i64 [ %add5553, %cond.true.5552 ], [ %add5557, %cond.false.5554 ]
  store i64 %cond5559, i64* %alloca_size, align 8
  br i1 false, label %if.then, label %lor.lhs.false.5873

cond.false.5560:                                  ; preds = %cond.false.5246
  br i1 false, label %cond.true.5561, label %cond.false.5717

cond.true.5561:                                   ; preds = %cond.false.5560
  %1084 = load i64, i64* %alloca_size, align 8
  %mul5562 = mul nsw i64 0, %1084
  %1085 = load i64, i64* %formatlen, align 8
  %add5563 = add nsw i64 %mul5562, %1085
  %mul5564 = mul nsw i64 0, %add5563
  %sub5565 = sub nsw i64 %mul5564, 1
  %cmp5566 = icmp slt i64 %sub5565, 0
  br i1 %cmp5566, label %cond.true.5568, label %cond.false.5587

cond.true.5568:                                   ; preds = %cond.true.5561
  %1086 = load i64, i64* %alloca_size, align 8
  %mul5569 = mul nsw i64 0, %1086
  %1087 = load i64, i64* %formatlen, align 8
  %add5570 = add nsw i64 %mul5569, %1087
  %mul5571 = mul nsw i64 0, %add5570
  %add5572 = add nsw i64 %mul5571, 0
  %neg5573 = xor i64 %add5572, -1
  %cmp5574 = icmp eq i64 %neg5573, -1
  %conv5575 = zext i1 %cmp5574 to i32
  %sub5576 = sub nsw i32 0, %conv5575
  %conv5577 = sext i32 %sub5576 to i64
  %1088 = load i64, i64* %alloca_size, align 8
  %mul5578 = mul nsw i64 0, %1088
  %1089 = load i64, i64* %formatlen, align 8
  %add5579 = add nsw i64 %mul5578, %1089
  %mul5580 = mul nsw i64 0, %add5579
  %add5581 = add nsw i64 %mul5580, 1
  %shl5582 = shl i64 %add5581, 62
  %sub5583 = sub nsw i64 %shl5582, 1
  %mul5584 = mul nsw i64 %sub5583, 2
  %add5585 = add nsw i64 %mul5584, 1
  %sub5586 = sub nsw i64 %conv5577, %add5585
  br label %cond.end.5592

cond.false.5587:                                  ; preds = %cond.true.5561
  %1090 = load i64, i64* %alloca_size, align 8
  %mul5588 = mul nsw i64 0, %1090
  %1091 = load i64, i64* %formatlen, align 8
  %add5589 = add nsw i64 %mul5588, %1091
  %mul5590 = mul nsw i64 0, %add5589
  %add5591 = add nsw i64 %mul5590, 0
  br label %cond.end.5592

cond.end.5592:                                    ; preds = %cond.false.5587, %cond.true.5568
  %cond5593 = phi i64 [ %sub5586, %cond.true.5568 ], [ %add5591, %cond.false.5587 ]
  %cmp5594 = icmp slt i64 %cond5593, 0
  br i1 %cmp5594, label %cond.true.5596, label %cond.false.5661

cond.true.5596:                                   ; preds = %cond.end.5592
  %1092 = load i64, i64* %alloca_size, align 8
  %cmp5597 = icmp slt i64 %1092, 0
  br i1 %cmp5597, label %cond.true.5599, label %cond.false.5635

cond.true.5599:                                   ; preds = %cond.true.5596
  %1093 = load i64, i64* %formatlen, align 8
  %1094 = load i64, i64* %alloca_size, align 8
  %mul5600 = mul nsw i64 0, %1094
  %1095 = load i64, i64* %formatlen, align 8
  %add5601 = add nsw i64 %mul5600, %1095
  %mul5602 = mul nsw i64 0, %add5601
  %sub5603 = sub nsw i64 %mul5602, 1
  %cmp5604 = icmp slt i64 %sub5603, 0
  br i1 %cmp5604, label %cond.true.5606, label %cond.false.5625

cond.true.5606:                                   ; preds = %cond.true.5599
  %1096 = load i64, i64* %alloca_size, align 8
  %mul5607 = mul nsw i64 0, %1096
  %1097 = load i64, i64* %formatlen, align 8
  %add5608 = add nsw i64 %mul5607, %1097
  %mul5609 = mul nsw i64 0, %add5608
  %add5610 = add nsw i64 %mul5609, 0
  %neg5611 = xor i64 %add5610, -1
  %cmp5612 = icmp eq i64 %neg5611, -1
  %conv5613 = zext i1 %cmp5612 to i32
  %sub5614 = sub nsw i32 0, %conv5613
  %conv5615 = sext i32 %sub5614 to i64
  %1098 = load i64, i64* %alloca_size, align 8
  %mul5616 = mul nsw i64 0, %1098
  %1099 = load i64, i64* %formatlen, align 8
  %add5617 = add nsw i64 %mul5616, %1099
  %mul5618 = mul nsw i64 0, %add5617
  %add5619 = add nsw i64 %mul5618, 1
  %shl5620 = shl i64 %add5619, 62
  %sub5621 = sub nsw i64 %shl5620, 1
  %mul5622 = mul nsw i64 %sub5621, 2
  %add5623 = add nsw i64 %mul5622, 1
  %sub5624 = sub nsw i64 %conv5615, %add5623
  br label %cond.end.5630

cond.false.5625:                                  ; preds = %cond.true.5599
  %1100 = load i64, i64* %alloca_size, align 8
  %mul5626 = mul nsw i64 0, %1100
  %1101 = load i64, i64* %formatlen, align 8
  %add5627 = add nsw i64 %mul5626, %1101
  %mul5628 = mul nsw i64 0, %add5627
  %add5629 = add nsw i64 %mul5628, 0
  br label %cond.end.5630

cond.end.5630:                                    ; preds = %cond.false.5625, %cond.true.5606
  %cond5631 = phi i64 [ %sub5624, %cond.true.5606 ], [ %add5629, %cond.false.5625 ]
  %1102 = load i64, i64* %alloca_size, align 8
  %sub5632 = sub nsw i64 %cond5631, %1102
  %cmp5633 = icmp slt i64 %1093, %sub5632
  br i1 %cmp5633, label %cond.true.5693, label %lor.lhs.false.5679

cond.false.5635:                                  ; preds = %cond.true.5596
  %1103 = load i64, i64* %alloca_size, align 8
  %mul5636 = mul nsw i64 0, %1103
  %1104 = load i64, i64* %formatlen, align 8
  %add5637 = add nsw i64 %mul5636, %1104
  %mul5638 = mul nsw i64 0, %add5637
  %sub5639 = sub nsw i64 %mul5638, 1
  %cmp5640 = icmp slt i64 %sub5639, 0
  br i1 %cmp5640, label %cond.true.5642, label %cond.false.5651

cond.true.5642:                                   ; preds = %cond.false.5635
  %1105 = load i64, i64* %alloca_size, align 8
  %mul5643 = mul nsw i64 0, %1105
  %1106 = load i64, i64* %formatlen, align 8
  %add5644 = add nsw i64 %mul5643, %1106
  %mul5645 = mul nsw i64 0, %add5644
  %add5646 = add nsw i64 %mul5645, 1
  %shl5647 = shl i64 %add5646, 62
  %sub5648 = sub nsw i64 %shl5647, 1
  %mul5649 = mul nsw i64 %sub5648, 2
  %add5650 = add nsw i64 %mul5649, 1
  br label %cond.end.5656

cond.false.5651:                                  ; preds = %cond.false.5635
  %1107 = load i64, i64* %alloca_size, align 8
  %mul5652 = mul nsw i64 0, %1107
  %1108 = load i64, i64* %formatlen, align 8
  %add5653 = add nsw i64 %mul5652, %1108
  %mul5654 = mul nsw i64 0, %add5653
  %sub5655 = sub nsw i64 %mul5654, 1
  br label %cond.end.5656

cond.end.5656:                                    ; preds = %cond.false.5651, %cond.true.5642
  %cond5657 = phi i64 [ %add5650, %cond.true.5642 ], [ %sub5655, %cond.false.5651 ]
  %1109 = load i64, i64* %alloca_size, align 8
  %sub5658 = sub nsw i64 %cond5657, %1109
  %1110 = load i64, i64* %formatlen, align 8
  %cmp5659 = icmp slt i64 %sub5658, %1110
  br i1 %cmp5659, label %cond.true.5693, label %lor.lhs.false.5679

cond.false.5661:                                  ; preds = %cond.end.5592
  %1111 = load i64, i64* %formatlen, align 8
  %cmp5662 = icmp slt i64 %1111, 0
  br i1 %cmp5662, label %cond.true.5664, label %cond.false.5668

cond.true.5664:                                   ; preds = %cond.false.5661
  %1112 = load i64, i64* %alloca_size, align 8
  %1113 = load i64, i64* %formatlen, align 8
  %1114 = load i64, i64* %alloca_size, align 8
  %add5665 = add nsw i64 %1113, %1114
  %cmp5666 = icmp sle i64 %1112, %add5665
  br i1 %cmp5666, label %cond.true.5693, label %lor.lhs.false.5679

cond.false.5668:                                  ; preds = %cond.false.5661
  %1115 = load i64, i64* %alloca_size, align 8
  %cmp5669 = icmp slt i64 %1115, 0
  br i1 %cmp5669, label %cond.true.5671, label %cond.false.5675

cond.true.5671:                                   ; preds = %cond.false.5668
  %1116 = load i64, i64* %formatlen, align 8
  %1117 = load i64, i64* %formatlen, align 8
  %1118 = load i64, i64* %alloca_size, align 8
  %add5672 = add nsw i64 %1117, %1118
  %cmp5673 = icmp sle i64 %1116, %add5672
  br i1 %cmp5673, label %cond.true.5693, label %lor.lhs.false.5679

cond.false.5675:                                  ; preds = %cond.false.5668
  %1119 = load i64, i64* %formatlen, align 8
  %1120 = load i64, i64* %alloca_size, align 8
  %add5676 = add nsw i64 %1119, %1120
  %1121 = load i64, i64* %alloca_size, align 8
  %cmp5677 = icmp slt i64 %add5676, %1121
  br i1 %cmp5677, label %cond.true.5693, label %lor.lhs.false.5679

lor.lhs.false.5679:                               ; preds = %cond.false.5675, %cond.true.5671, %cond.true.5664, %cond.end.5656, %cond.end.5630
  %1122 = load i64, i64* %formatlen, align 8
  %1123 = load i64, i64* %alloca_size, align 8
  %add5680 = add nsw i64 %1122, %1123
  %mul5681 = mul nsw i64 0, %add5680
  %sub5682 = sub nsw i64 %mul5681, 1
  %cmp5683 = icmp slt i64 %sub5682, 0
  br i1 %cmp5683, label %land.lhs.true.5685, label %lor.lhs.false.5689

land.lhs.true.5685:                               ; preds = %lor.lhs.false.5679
  %1124 = load i64, i64* %formatlen, align 8
  %1125 = load i64, i64* %alloca_size, align 8
  %add5686 = add nsw i64 %1124, %1125
  %cmp5687 = icmp slt i64 %add5686, -9223372036854775808
  br i1 %cmp5687, label %cond.true.5693, label %lor.lhs.false.5689

lor.lhs.false.5689:                               ; preds = %land.lhs.true.5685, %lor.lhs.false.5679
  %1126 = load i64, i64* %formatlen, align 8
  %1127 = load i64, i64* %alloca_size, align 8
  %add5690 = add nsw i64 %1126, %1127
  %cmp5691 = icmp slt i64 9223372036854775807, %add5690
  br i1 %cmp5691, label %cond.true.5693, label %cond.false.5705

cond.true.5693:                                   ; preds = %lor.lhs.false.5689, %land.lhs.true.5685, %cond.false.5675, %cond.true.5671, %cond.true.5664, %cond.end.5656, %cond.end.5630
  %1128 = load i64, i64* %formatlen, align 8
  %1129 = load i64, i64* %alloca_size, align 8
  %add5694 = add i64 %1128, %1129
  %cmp5695 = icmp ule i64 %add5694, 9223372036854775807
  br i1 %cmp5695, label %cond.true.5697, label %cond.false.5699

cond.true.5697:                                   ; preds = %cond.true.5693
  %1130 = load i64, i64* %formatlen, align 8
  %1131 = load i64, i64* %alloca_size, align 8
  %add5698 = add i64 %1130, %1131
  br label %cond.end.5703

cond.false.5699:                                  ; preds = %cond.true.5693
  %1132 = load i64, i64* %formatlen, align 8
  %1133 = load i64, i64* %alloca_size, align 8
  %add5700 = add i64 %1132, %1133
  %sub5701 = sub i64 %add5700, -9223372036854775808
  %add5702 = add nsw i64 %sub5701, -9223372036854775808
  br label %cond.end.5703

cond.end.5703:                                    ; preds = %cond.false.5699, %cond.true.5697
  %cond5704 = phi i64 [ %add5698, %cond.true.5697 ], [ %add5702, %cond.false.5699 ]
  store i64 %cond5704, i64* %alloca_size, align 8
  br i1 true, label %if.then, label %lor.lhs.false.5873

cond.false.5705:                                  ; preds = %lor.lhs.false.5689
  %1134 = load i64, i64* %formatlen, align 8
  %1135 = load i64, i64* %alloca_size, align 8
  %add5706 = add i64 %1134, %1135
  %cmp5707 = icmp ule i64 %add5706, 9223372036854775807
  br i1 %cmp5707, label %cond.true.5709, label %cond.false.5711

cond.true.5709:                                   ; preds = %cond.false.5705
  %1136 = load i64, i64* %formatlen, align 8
  %1137 = load i64, i64* %alloca_size, align 8
  %add5710 = add i64 %1136, %1137
  br label %cond.end.5715

cond.false.5711:                                  ; preds = %cond.false.5705
  %1138 = load i64, i64* %formatlen, align 8
  %1139 = load i64, i64* %alloca_size, align 8
  %add5712 = add i64 %1138, %1139
  %sub5713 = sub i64 %add5712, -9223372036854775808
  %add5714 = add nsw i64 %sub5713, -9223372036854775808
  br label %cond.end.5715

cond.end.5715:                                    ; preds = %cond.false.5711, %cond.true.5709
  %cond5716 = phi i64 [ %add5710, %cond.true.5709 ], [ %add5714, %cond.false.5711 ]
  store i64 %cond5716, i64* %alloca_size, align 8
  br i1 false, label %if.then, label %lor.lhs.false.5873

cond.false.5717:                                  ; preds = %cond.false.5560
  %1140 = load i64, i64* %alloca_size, align 8
  %mul5718 = mul nsw i64 0, %1140
  %1141 = load i64, i64* %formatlen, align 8
  %add5719 = add nsw i64 %mul5718, %1141
  %mul5720 = mul nsw i64 0, %add5719
  %sub5721 = sub nsw i64 %mul5720, 1
  %cmp5722 = icmp slt i64 %sub5721, 0
  br i1 %cmp5722, label %cond.true.5724, label %cond.false.5743

cond.true.5724:                                   ; preds = %cond.false.5717
  %1142 = load i64, i64* %alloca_size, align 8
  %mul5725 = mul nsw i64 0, %1142
  %1143 = load i64, i64* %formatlen, align 8
  %add5726 = add nsw i64 %mul5725, %1143
  %mul5727 = mul nsw i64 0, %add5726
  %add5728 = add nsw i64 %mul5727, 0
  %neg5729 = xor i64 %add5728, -1
  %cmp5730 = icmp eq i64 %neg5729, -1
  %conv5731 = zext i1 %cmp5730 to i32
  %sub5732 = sub nsw i32 0, %conv5731
  %conv5733 = sext i32 %sub5732 to i64
  %1144 = load i64, i64* %alloca_size, align 8
  %mul5734 = mul nsw i64 0, %1144
  %1145 = load i64, i64* %formatlen, align 8
  %add5735 = add nsw i64 %mul5734, %1145
  %mul5736 = mul nsw i64 0, %add5735
  %add5737 = add nsw i64 %mul5736, 1
  %shl5738 = shl i64 %add5737, 62
  %sub5739 = sub nsw i64 %shl5738, 1
  %mul5740 = mul nsw i64 %sub5739, 2
  %add5741 = add nsw i64 %mul5740, 1
  %sub5742 = sub nsw i64 %conv5733, %add5741
  br label %cond.end.5748

cond.false.5743:                                  ; preds = %cond.false.5717
  %1146 = load i64, i64* %alloca_size, align 8
  %mul5744 = mul nsw i64 0, %1146
  %1147 = load i64, i64* %formatlen, align 8
  %add5745 = add nsw i64 %mul5744, %1147
  %mul5746 = mul nsw i64 0, %add5745
  %add5747 = add nsw i64 %mul5746, 0
  br label %cond.end.5748

cond.end.5748:                                    ; preds = %cond.false.5743, %cond.true.5724
  %cond5749 = phi i64 [ %sub5742, %cond.true.5724 ], [ %add5747, %cond.false.5743 ]
  %cmp5750 = icmp slt i64 %cond5749, 0
  br i1 %cmp5750, label %cond.true.5752, label %cond.false.5817

cond.true.5752:                                   ; preds = %cond.end.5748
  %1148 = load i64, i64* %alloca_size, align 8
  %cmp5753 = icmp slt i64 %1148, 0
  br i1 %cmp5753, label %cond.true.5755, label %cond.false.5791

cond.true.5755:                                   ; preds = %cond.true.5752
  %1149 = load i64, i64* %formatlen, align 8
  %1150 = load i64, i64* %alloca_size, align 8
  %mul5756 = mul nsw i64 0, %1150
  %1151 = load i64, i64* %formatlen, align 8
  %add5757 = add nsw i64 %mul5756, %1151
  %mul5758 = mul nsw i64 0, %add5757
  %sub5759 = sub nsw i64 %mul5758, 1
  %cmp5760 = icmp slt i64 %sub5759, 0
  br i1 %cmp5760, label %cond.true.5762, label %cond.false.5781

cond.true.5762:                                   ; preds = %cond.true.5755
  %1152 = load i64, i64* %alloca_size, align 8
  %mul5763 = mul nsw i64 0, %1152
  %1153 = load i64, i64* %formatlen, align 8
  %add5764 = add nsw i64 %mul5763, %1153
  %mul5765 = mul nsw i64 0, %add5764
  %add5766 = add nsw i64 %mul5765, 0
  %neg5767 = xor i64 %add5766, -1
  %cmp5768 = icmp eq i64 %neg5767, -1
  %conv5769 = zext i1 %cmp5768 to i32
  %sub5770 = sub nsw i32 0, %conv5769
  %conv5771 = sext i32 %sub5770 to i64
  %1154 = load i64, i64* %alloca_size, align 8
  %mul5772 = mul nsw i64 0, %1154
  %1155 = load i64, i64* %formatlen, align 8
  %add5773 = add nsw i64 %mul5772, %1155
  %mul5774 = mul nsw i64 0, %add5773
  %add5775 = add nsw i64 %mul5774, 1
  %shl5776 = shl i64 %add5775, 62
  %sub5777 = sub nsw i64 %shl5776, 1
  %mul5778 = mul nsw i64 %sub5777, 2
  %add5779 = add nsw i64 %mul5778, 1
  %sub5780 = sub nsw i64 %conv5771, %add5779
  br label %cond.end.5786

cond.false.5781:                                  ; preds = %cond.true.5755
  %1156 = load i64, i64* %alloca_size, align 8
  %mul5782 = mul nsw i64 0, %1156
  %1157 = load i64, i64* %formatlen, align 8
  %add5783 = add nsw i64 %mul5782, %1157
  %mul5784 = mul nsw i64 0, %add5783
  %add5785 = add nsw i64 %mul5784, 0
  br label %cond.end.5786

cond.end.5786:                                    ; preds = %cond.false.5781, %cond.true.5762
  %cond5787 = phi i64 [ %sub5780, %cond.true.5762 ], [ %add5785, %cond.false.5781 ]
  %1158 = load i64, i64* %alloca_size, align 8
  %sub5788 = sub nsw i64 %cond5787, %1158
  %cmp5789 = icmp slt i64 %1149, %sub5788
  br i1 %cmp5789, label %cond.true.5849, label %lor.lhs.false.5835

cond.false.5791:                                  ; preds = %cond.true.5752
  %1159 = load i64, i64* %alloca_size, align 8
  %mul5792 = mul nsw i64 0, %1159
  %1160 = load i64, i64* %formatlen, align 8
  %add5793 = add nsw i64 %mul5792, %1160
  %mul5794 = mul nsw i64 0, %add5793
  %sub5795 = sub nsw i64 %mul5794, 1
  %cmp5796 = icmp slt i64 %sub5795, 0
  br i1 %cmp5796, label %cond.true.5798, label %cond.false.5807

cond.true.5798:                                   ; preds = %cond.false.5791
  %1161 = load i64, i64* %alloca_size, align 8
  %mul5799 = mul nsw i64 0, %1161
  %1162 = load i64, i64* %formatlen, align 8
  %add5800 = add nsw i64 %mul5799, %1162
  %mul5801 = mul nsw i64 0, %add5800
  %add5802 = add nsw i64 %mul5801, 1
  %shl5803 = shl i64 %add5802, 62
  %sub5804 = sub nsw i64 %shl5803, 1
  %mul5805 = mul nsw i64 %sub5804, 2
  %add5806 = add nsw i64 %mul5805, 1
  br label %cond.end.5812

cond.false.5807:                                  ; preds = %cond.false.5791
  %1163 = load i64, i64* %alloca_size, align 8
  %mul5808 = mul nsw i64 0, %1163
  %1164 = load i64, i64* %formatlen, align 8
  %add5809 = add nsw i64 %mul5808, %1164
  %mul5810 = mul nsw i64 0, %add5809
  %sub5811 = sub nsw i64 %mul5810, 1
  br label %cond.end.5812

cond.end.5812:                                    ; preds = %cond.false.5807, %cond.true.5798
  %cond5813 = phi i64 [ %add5806, %cond.true.5798 ], [ %sub5811, %cond.false.5807 ]
  %1165 = load i64, i64* %alloca_size, align 8
  %sub5814 = sub nsw i64 %cond5813, %1165
  %1166 = load i64, i64* %formatlen, align 8
  %cmp5815 = icmp slt i64 %sub5814, %1166
  br i1 %cmp5815, label %cond.true.5849, label %lor.lhs.false.5835

cond.false.5817:                                  ; preds = %cond.end.5748
  %1167 = load i64, i64* %formatlen, align 8
  %cmp5818 = icmp slt i64 %1167, 0
  br i1 %cmp5818, label %cond.true.5820, label %cond.false.5824

cond.true.5820:                                   ; preds = %cond.false.5817
  %1168 = load i64, i64* %alloca_size, align 8
  %1169 = load i64, i64* %formatlen, align 8
  %1170 = load i64, i64* %alloca_size, align 8
  %add5821 = add nsw i64 %1169, %1170
  %cmp5822 = icmp sle i64 %1168, %add5821
  br i1 %cmp5822, label %cond.true.5849, label %lor.lhs.false.5835

cond.false.5824:                                  ; preds = %cond.false.5817
  %1171 = load i64, i64* %alloca_size, align 8
  %cmp5825 = icmp slt i64 %1171, 0
  br i1 %cmp5825, label %cond.true.5827, label %cond.false.5831

cond.true.5827:                                   ; preds = %cond.false.5824
  %1172 = load i64, i64* %formatlen, align 8
  %1173 = load i64, i64* %formatlen, align 8
  %1174 = load i64, i64* %alloca_size, align 8
  %add5828 = add nsw i64 %1173, %1174
  %cmp5829 = icmp sle i64 %1172, %add5828
  br i1 %cmp5829, label %cond.true.5849, label %lor.lhs.false.5835

cond.false.5831:                                  ; preds = %cond.false.5824
  %1175 = load i64, i64* %formatlen, align 8
  %1176 = load i64, i64* %alloca_size, align 8
  %add5832 = add nsw i64 %1175, %1176
  %1177 = load i64, i64* %alloca_size, align 8
  %cmp5833 = icmp slt i64 %add5832, %1177
  br i1 %cmp5833, label %cond.true.5849, label %lor.lhs.false.5835

lor.lhs.false.5835:                               ; preds = %cond.false.5831, %cond.true.5827, %cond.true.5820, %cond.end.5812, %cond.end.5786
  %1178 = load i64, i64* %formatlen, align 8
  %1179 = load i64, i64* %alloca_size, align 8
  %add5836 = add nsw i64 %1178, %1179
  %mul5837 = mul nsw i64 0, %add5836
  %sub5838 = sub nsw i64 %mul5837, 1
  %cmp5839 = icmp slt i64 %sub5838, 0
  br i1 %cmp5839, label %land.lhs.true.5841, label %lor.lhs.false.5845

land.lhs.true.5841:                               ; preds = %lor.lhs.false.5835
  %1180 = load i64, i64* %formatlen, align 8
  %1181 = load i64, i64* %alloca_size, align 8
  %add5842 = add nsw i64 %1180, %1181
  %cmp5843 = icmp slt i64 %add5842, -9223372036854775808
  br i1 %cmp5843, label %cond.true.5849, label %lor.lhs.false.5845

lor.lhs.false.5845:                               ; preds = %land.lhs.true.5841, %lor.lhs.false.5835
  %1182 = load i64, i64* %formatlen, align 8
  %1183 = load i64, i64* %alloca_size, align 8
  %add5846 = add nsw i64 %1182, %1183
  %cmp5847 = icmp slt i64 9223372036854775807, %add5846
  br i1 %cmp5847, label %cond.true.5849, label %cond.false.5861

cond.true.5849:                                   ; preds = %lor.lhs.false.5845, %land.lhs.true.5841, %cond.false.5831, %cond.true.5827, %cond.true.5820, %cond.end.5812, %cond.end.5786
  %1184 = load i64, i64* %formatlen, align 8
  %1185 = load i64, i64* %alloca_size, align 8
  %add5850 = add i64 %1184, %1185
  %cmp5851 = icmp ule i64 %add5850, 9223372036854775807
  br i1 %cmp5851, label %cond.true.5853, label %cond.false.5855

cond.true.5853:                                   ; preds = %cond.true.5849
  %1186 = load i64, i64* %formatlen, align 8
  %1187 = load i64, i64* %alloca_size, align 8
  %add5854 = add i64 %1186, %1187
  br label %cond.end.5859

cond.false.5855:                                  ; preds = %cond.true.5849
  %1188 = load i64, i64* %formatlen, align 8
  %1189 = load i64, i64* %alloca_size, align 8
  %add5856 = add i64 %1188, %1189
  %sub5857 = sub i64 %add5856, -9223372036854775808
  %add5858 = add nsw i64 %sub5857, -9223372036854775808
  br label %cond.end.5859

cond.end.5859:                                    ; preds = %cond.false.5855, %cond.true.5853
  %cond5860 = phi i64 [ %add5854, %cond.true.5853 ], [ %add5858, %cond.false.5855 ]
  store i64 %cond5860, i64* %alloca_size, align 8
  br i1 true, label %if.then, label %lor.lhs.false.5873

cond.false.5861:                                  ; preds = %lor.lhs.false.5845
  %1190 = load i64, i64* %formatlen, align 8
  %1191 = load i64, i64* %alloca_size, align 8
  %add5862 = add i64 %1190, %1191
  %cmp5863 = icmp ule i64 %add5862, 9223372036854775807
  br i1 %cmp5863, label %cond.true.5865, label %cond.false.5867

cond.true.5865:                                   ; preds = %cond.false.5861
  %1192 = load i64, i64* %formatlen, align 8
  %1193 = load i64, i64* %alloca_size, align 8
  %add5866 = add i64 %1192, %1193
  br label %cond.end.5871

cond.false.5867:                                  ; preds = %cond.false.5861
  %1194 = load i64, i64* %formatlen, align 8
  %1195 = load i64, i64* %alloca_size, align 8
  %add5868 = add i64 %1194, %1195
  %sub5869 = sub i64 %add5868, -9223372036854775808
  %add5870 = add nsw i64 %sub5869, -9223372036854775808
  br label %cond.end.5871

cond.end.5871:                                    ; preds = %cond.false.5867, %cond.true.5865
  %cond5872 = phi i64 [ %add5866, %cond.true.5865 ], [ %add5870, %cond.false.5867 ]
  store i64 %cond5872, i64* %alloca_size, align 8
  br i1 false, label %if.then, label %lor.lhs.false.5873

lor.lhs.false.5873:                               ; preds = %cond.end.5871, %cond.end.5859, %cond.end.5715, %cond.end.5703, %cond.end.5558, %cond.end.5546, %cond.end.5402, %cond.end.5390, %cond.end.5243, %cond.end.5224, %cond.end.5073, %cond.end.5054, %cond.end.4859, %cond.end.4830, %cond.end.4669, %cond.end.4640, %cond.end.4391, %cond.end.4362, %cond.end.4201, %cond.end.4172
  %1196 = load i64, i64* %alloca_size, align 8
  %cmp5874 = icmp ult i64 -1, %1196
  br i1 %cmp5874, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false.5873, %cond.end.5871, %cond.end.5859, %cond.end.5715, %cond.end.5703, %cond.end.5558, %cond.end.5546, %cond.end.5402, %cond.end.5390, %cond.end.5243, %cond.end.5224, %cond.end.5073, %cond.end.5054, %cond.end.4859, %cond.end.4830, %cond.end.4669, %cond.end.4640, %cond.end.4391, %cond.end.4362, %cond.end.4201, %cond.end.4172, %cond.end.3924, %cond.end.3912, %cond.end.3770, %cond.end.3758, %cond.end.3615, %cond.end.3603, %cond.end.3461, %cond.end.3449, %cond.end.3304, %cond.end.3288, %cond.end.3142, %cond.end.3126, %cond.end.2957, %cond.end.2934, %cond.end.2781, %cond.end.2758, %cond.end.2559, %cond.end.2536, %cond.end.2383, %cond.end.2360, %cond.end.2162, %cond.end.2150, %cond.end.1969, %cond.end.1957, %cond.end.1775, %cond.end.1763, %cond.end.1582, %cond.end.1570, %cond.end.1386, %cond.end.1370, %cond.end.1185, %cond.end.1169, %cond.end.957, %cond.end.934, %cond.end.742, %cond.end.719, %cond.end.472, %cond.end.449, %cond.end.257, %cond.end.234
  call void @memory_full(i64 -1) #9
  unreachable

if.end:                                           ; preds = %lor.lhs.false.5873
  %1197 = load i64, i64* %alloca_size, align 8
  %1198 = load i64, i64* %sa_avail, align 8
  %cmp5876 = icmp sle i64 %1197, %1198
  br i1 %cmp5876, label %cond.true.5878, label %cond.false.5880

cond.true.5878:                                   ; preds = %if.end
  %1199 = load i64, i64* %alloca_size, align 8
  %1200 = load i64, i64* %sa_avail, align 8
  %sub5879 = sub nsw i64 %1200, %1199
  store i64 %sub5879, i64* %sa_avail, align 8
  %1201 = load i64, i64* %alloca_size, align 8
  %1202 = alloca i8, i64 %1201
  br label %cond.end.5882

cond.false.5880:                                  ; preds = %if.end
  store i8 1, i8* %sa_must_free, align 1
  %1203 = load i64, i64* %alloca_size, align 8
  %call5881 = call i8* @record_xmalloc(i64 %1203)
  br label %cond.end.5882

cond.end.5882:                                    ; preds = %cond.false.5880, %cond.true.5878
  %cond5883 = phi i8* [ %1202, %cond.true.5878 ], [ %call5881, %cond.false.5880 ]
  %1204 = bitcast i8* %cond5883 to %struct.info*
  store %struct.info* %1204, %struct.info** %info, align 8
  %1205 = load %struct.info*, %struct.info** %info, align 8
  %1206 = bitcast %struct.info* %1205 to i8*
  %1207 = load i64, i64* %alloca_size, align 8
  call void @llvm.memset.p0i8.i64(i8* %1206, i8 0, i64 %1207, i32 8, i1 false)
  store i64 0, i64* %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end.5882
  %1208 = load i64, i64* %i, align 8
  %1209 = load i64, i64* %nargs.addr, align 8
  %add5884 = add nsw i64 %1209, 1
  %cmp5885 = icmp slt i64 %1208, %add5884
  br i1 %cmp5885, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %1210 = load i64, i64* %i, align 8
  %1211 = load %struct.info*, %struct.info** %info, align 8
  %arrayidx5887 = getelementptr inbounds %struct.info, %struct.info* %1211, i64 %1210
  %start = getelementptr inbounds %struct.info, %struct.info* %arrayidx5887, i32 0, i32 0
  store i64 -1, i64* %start, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %1212 = load i64, i64* %i, align 8
  %inc = add nsw i64 %1212, 1
  store i64 %inc, i64* %i, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %1213 = load i64, i64* %nargs.addr, align 8
  %add5888 = add nsw i64 %1213, 1
  %1214 = load %struct.info*, %struct.info** %info, align 8
  %arrayidx5889 = getelementptr inbounds %struct.info, %struct.info* %1214, i64 %add5888
  %1215 = bitcast %struct.info* %arrayidx5889 to i8*
  store i8* %1215, i8** %discarded, align 8
  %1216 = load i64*, i64** %args.addr, align 8
  %arrayidx5890 = getelementptr inbounds i64, i64* %1216, i64 0
  %1217 = load i64, i64* %arrayidx5890, align 8
  %call5891 = call zeroext i1 @STRING_MULTIBYTE(i64 %1217)
  %frombool5892 = zext i1 %call5891 to i8
  store i8 %frombool5892, i8* %multibyte_format, align 1
  %1218 = load i8, i8* %multibyte_format, align 1
  %tobool = trunc i8 %1218 to i1
  %frombool5893 = zext i1 %tobool to i8
  store i8 %frombool5893, i8* %multibyte, align 1
  store i64 1, i64* %i5894, align 8
  br label %for.cond.5895

for.cond.5895:                                    ; preds = %for.inc.5909, %for.end
  %1219 = load i8, i8* %multibyte, align 1
  %tobool5896 = trunc i8 %1219 to i1
  br i1 %tobool5896, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %for.cond.5895
  %1220 = load i64, i64* %i5894, align 8
  %1221 = load i64, i64* %nargs.addr, align 8
  %cmp5897 = icmp slt i64 %1220, %1221
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond.5895
  %1222 = phi i1 [ false, %for.cond.5895 ], [ %cmp5897, %land.rhs ]
  br i1 %1222, label %for.body.5899, label %for.end.5911

for.body.5899:                                    ; preds = %land.end
  %1223 = load i64, i64* %i5894, align 8
  %1224 = load i64*, i64** %args.addr, align 8
  %arrayidx5900 = getelementptr inbounds i64, i64* %1224, i64 %1223
  %1225 = load i64, i64* %arrayidx5900, align 8
  %call5901 = call zeroext i1 @STRINGP(i64 %1225)
  br i1 %call5901, label %land.lhs.true.5903, label %if.end.5908

land.lhs.true.5903:                               ; preds = %for.body.5899
  %1226 = load i64, i64* %i5894, align 8
  %1227 = load i64*, i64** %args.addr, align 8
  %arrayidx5904 = getelementptr inbounds i64, i64* %1227, i64 %1226
  %1228 = load i64, i64* %arrayidx5904, align 8
  %call5905 = call zeroext i1 @STRING_MULTIBYTE(i64 %1228)
  br i1 %call5905, label %if.then.5907, label %if.end.5908

if.then.5907:                                     ; preds = %land.lhs.true.5903
  store i8 1, i8* %multibyte, align 1
  br label %if.end.5908

if.end.5908:                                      ; preds = %if.then.5907, %land.lhs.true.5903, %for.body.5899
  br label %for.inc.5909

for.inc.5909:                                     ; preds = %if.end.5908
  %1229 = load i64, i64* %i5894, align 8
  %inc5910 = add nsw i64 %1229, 1
  store i64 %inc5910, i64* %i5894, align 8
  br label %for.cond.5895

for.end.5911:                                     ; preds = %land.end
  %1230 = load i8, i8* %message.addr, align 1
  %tobool5912 = trunc i8 %1230 to i1
  br i1 %tobool5912, label %cond.true.5914, label %cond.false.5916

cond.true.5914:                                   ; preds = %for.end.5911
  %call5915 = call i32 @text_quoting_style()
  br label %cond.end.5917

cond.false.5916:                                  ; preds = %for.end.5911
  br label %cond.end.5917

cond.end.5917:                                    ; preds = %cond.false.5916, %cond.true.5914
  %cond5918 = phi i32 [ %call5915, %cond.true.5914 ], [ -1, %cond.false.5916 ]
  store i32 %cond5918, i32* %quoting_style, align 4
  br label %retry

retry:                                            ; preds = %if.then.6751, %if.then.6116, %if.then.6082, %if.then.6030, %cond.end.5917
  %1231 = load i8*, i8** %buf, align 8
  store i8* %1231, i8** %p, align 8
  store i64 0, i64* %nchars, align 8
  store i64 0, i64* %n, align 8
  %1232 = load i8*, i8** %format_start, align 8
  store i8* %1232, i8** %format, align 8
  %1233 = load i8*, i8** %format, align 8
  %1234 = load i64, i64* %formatlen, align 8
  %add.ptr = getelementptr inbounds i8, i8* %1233, i64 %1234
  store i8* %add.ptr, i8** %end, align 8
  store i8 0, i8* %maybe_combine_byte, align 1
  br label %while.cond

while.cond:                                       ; preds = %if.end.6971, %if.then.6941, %if.end.6733, %if.end.6239, %retry
  %1235 = load i8*, i8** %format, align 8
  %1236 = load i8*, i8** %end, align 8
  %cmp5919 = icmp ne i8* %1235, %1236
  br i1 %cmp5919, label %while.body, label %while.end.6973

while.body:                                       ; preds = %while.cond
  %1237 = load i64, i64* %n, align 8
  store i64 %1237, i64* %n0, align 8
  %1238 = load i8*, i8** %format, align 8
  store i8* %1238, i8** %format0, align 8
  %1239 = load i8*, i8** %format, align 8
  store i8* %1239, i8** %convsrc, align 8
  %1240 = load i8*, i8** %format, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %1240, i32 1
  store i8* %incdec.ptr, i8** %format, align 8
  %1241 = load i8, i8* %1240, align 1
  store i8 %1241, i8* %format_char, align 1
  store i64 1, i64* %convbytes, align 8
  %1242 = load i8, i8* %format_char, align 1
  %conv5921 = zext i8 %1242 to i32
  %cmp5922 = icmp eq i32 %conv5921, 37
  br i1 %cmp5922, label %if.then.5924, label %if.else.6738

if.then.5924:                                     ; preds = %while.body
  store i8 0, i8* %minus_flag, align 1
  store i8 0, i8* %plus_flag, align 1
  store i8 0, i8* %space_flag, align 1
  store i8 0, i8* %sharp_flag, align 1
  store i8 0, i8* %zero_flag, align 1
  br label %for.cond.5925

for.cond.5925:                                    ; preds = %for.inc.5931, %if.then.5924
  %1243 = load i8*, i8** %format, align 8
  %1244 = load i8, i8* %1243, align 1
  %conv5926 = sext i8 %1244 to i32
  switch i32 %conv5926, label %sw.epilog [
    i32 45, label %sw.bb
    i32 43, label %sw.bb.5927
    i32 32, label %sw.bb.5928
    i32 35, label %sw.bb.5929
    i32 48, label %sw.bb.5930
  ]

sw.bb:                                            ; preds = %for.cond.5925
  store i8 1, i8* %minus_flag, align 1
  br label %for.inc.5931

sw.bb.5927:                                       ; preds = %for.cond.5925
  store i8 1, i8* %plus_flag, align 1
  br label %for.inc.5931

sw.bb.5928:                                       ; preds = %for.cond.5925
  store i8 1, i8* %space_flag, align 1
  br label %for.inc.5931

sw.bb.5929:                                       ; preds = %for.cond.5925
  store i8 1, i8* %sharp_flag, align 1
  br label %for.inc.5931

sw.bb.5930:                                       ; preds = %for.cond.5925
  store i8 1, i8* %zero_flag, align 1
  br label %for.inc.5931

sw.epilog:                                        ; preds = %for.cond.5925
  br label %for.end.5933

for.inc.5931:                                     ; preds = %sw.bb.5930, %sw.bb.5929, %sw.bb.5928, %sw.bb.5927, %sw.bb
  %1245 = load i8*, i8** %format, align 8
  %incdec.ptr5932 = getelementptr inbounds i8, i8* %1245, i32 1
  store i8* %incdec.ptr5932, i8** %format, align 8
  br label %for.cond.5925

for.end.5933:                                     ; preds = %sw.epilog
  %1246 = load i8, i8* %plus_flag, align 1
  %tobool5934 = trunc i8 %1246 to i1
  %conv5935 = zext i1 %tobool5934 to i32
  %neg5936 = xor i32 %conv5935, -1
  %1247 = load i8, i8* %space_flag, align 1
  %tobool5937 = trunc i8 %1247 to i1
  %conv5938 = zext i1 %tobool5937 to i32
  %and = and i32 %conv5938, %neg5936
  %tobool5939 = icmp ne i32 %and, 0
  %frombool5940 = zext i1 %tobool5939 to i8
  store i8 %frombool5940, i8* %space_flag, align 1
  %1248 = load i8, i8* %minus_flag, align 1
  %tobool5941 = trunc i8 %1248 to i1
  %conv5942 = zext i1 %tobool5941 to i32
  %neg5943 = xor i32 %conv5942, -1
  %1249 = load i8, i8* %zero_flag, align 1
  %tobool5944 = trunc i8 %1249 to i1
  %conv5945 = zext i1 %tobool5944 to i32
  %and5946 = and i32 %conv5945, %neg5943
  %tobool5947 = icmp ne i32 %and5946, 0
  %frombool5948 = zext i1 %tobool5947 to i8
  store i8 %frombool5948, i8* %zero_flag, align 1
  %1250 = load i8*, i8** %format, align 8
  %call5949 = call i64 @strtoumax(i8* %1250, i8** %num_end, i32 10) #5
  store i64 %call5949, i64* %raw_field_width, align 8
  %1251 = load i64, i64* %max_bufsize, align 8
  %1252 = load i64, i64* %raw_field_width, align 8
  %cmp5950 = icmp ule i64 %1251, %1252
  br i1 %cmp5950, label %if.then.5952, label %if.end.5953

if.then.5952:                                     ; preds = %for.end.5933
  call void @string_overflow() #9
  unreachable

if.end.5953:                                      ; preds = %for.end.5933
  %1253 = load i64, i64* %raw_field_width, align 8
  store i64 %1253, i64* %field_width, align 8
  %1254 = load i8*, i8** %num_end, align 8
  %1255 = load i8, i8* %1254, align 1
  %conv5954 = sext i8 %1255 to i32
  %cmp5955 = icmp eq i32 %conv5954, 46
  %frombool5957 = zext i1 %cmp5955 to i8
  store i8 %frombool5957, i8* %precision_given, align 1
  %1256 = load i8, i8* %precision_given, align 1
  %tobool5958 = trunc i8 %1256 to i1
  br i1 %tobool5958, label %cond.true.5960, label %cond.false.5963

cond.true.5960:                                   ; preds = %if.end.5953
  %1257 = load i8*, i8** %num_end, align 8
  %add.ptr5961 = getelementptr inbounds i8, i8* %1257, i64 1
  %call5962 = call i64 @strtoumax(i8* %add.ptr5961, i8** %num_end, i32 10) #5
  br label %cond.end.5964

cond.false.5963:                                  ; preds = %if.end.5953
  br label %cond.end.5964

cond.end.5964:                                    ; preds = %cond.false.5963, %cond.true.5960
  %cond5965 = phi i64 [ %call5962, %cond.true.5960 ], [ -1, %cond.false.5963 ]
  store i64 %cond5965, i64* %precision, align 8
  %1258 = load i8*, i8** %num_end, align 8
  store i8* %1258, i8** %format, align 8
  %1259 = load i8*, i8** %format, align 8
  %1260 = load i8*, i8** %end, align 8
  %cmp5966 = icmp eq i8* %1259, %1260
  br i1 %cmp5966, label %if.then.5968, label %if.end.5969

if.then.5968:                                     ; preds = %cond.end.5964
  call void (i8*, ...) @error(i8* getelementptr inbounds ([49 x i8], [49 x i8]* @.str.37, i32 0, i32 0)) #9
  unreachable

if.end.5969:                                      ; preds = %cond.end.5964
  %1261 = load i8*, i8** %format, align 8
  %incdec.ptr5970 = getelementptr inbounds i8, i8* %1261, i32 1
  store i8* %incdec.ptr5970, i8** %format, align 8
  %1262 = load i8, i8* %1261, align 1
  store i8 %1262, i8* %conversion, align 1
  %1263 = load i8*, i8** %format0, align 8
  %1264 = load i8*, i8** %format_start, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %1263 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %1264 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %1265 = load i8*, i8** %discarded, align 8
  %arrayidx5971 = getelementptr inbounds i8, i8* %1265, i64 %sub.ptr.sub
  %1266 = load i8*, i8** %format, align 8
  %1267 = load i8*, i8** %format0, align 8
  %sub.ptr.lhs.cast5972 = ptrtoint i8* %1266 to i64
  %sub.ptr.rhs.cast5973 = ptrtoint i8* %1267 to i64
  %sub.ptr.sub5974 = sub i64 %sub.ptr.lhs.cast5972, %sub.ptr.rhs.cast5973
  %1268 = load i8, i8* %conversion, align 1
  %conv5975 = sext i8 %1268 to i32
  %cmp5976 = icmp eq i32 %conv5975, 37
  %conv5977 = zext i1 %cmp5976 to i32
  %conv5978 = sext i32 %conv5977 to i64
  %sub5979 = sub nsw i64 %sub.ptr.sub5974, %conv5978
  call void @llvm.memset.p0i8.i64(i8* %arrayidx5971, i8 1, i64 %sub5979, i32 1, i1 false)
  %1269 = load i8, i8* %conversion, align 1
  %conv5980 = sext i8 %1269 to i32
  %cmp5981 = icmp eq i32 %conv5980, 37
  br i1 %cmp5981, label %if.then.5983, label %if.end.5984

if.then.5983:                                     ; preds = %if.end.5969
  br label %copy_char

if.end.5984:                                      ; preds = %if.end.5969
  %1270 = load i64, i64* %n, align 8
  %inc5985 = add nsw i64 %1270, 1
  store i64 %inc5985, i64* %n, align 8
  %1271 = load i64, i64* %n, align 8
  %1272 = load i64, i64* %nargs.addr, align 8
  %cmp5986 = icmp slt i64 %1271, %1272
  br i1 %cmp5986, label %if.end.5989, label %if.then.5988

if.then.5988:                                     ; preds = %if.end.5984
  call void (i8*, ...) @error(i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.38, i32 0, i32 0)) #9
  unreachable

if.end.5989:                                      ; preds = %if.end.5984
  %1273 = load i8, i8* %conversion, align 1
  %conv5990 = sext i8 %1273 to i32
  %cmp5991 = icmp eq i32 %conv5990, 83
  br i1 %cmp5991, label %if.then.6006, label %lor.lhs.false.5993

lor.lhs.false.5993:                               ; preds = %if.end.5989
  %1274 = load i8, i8* %conversion, align 1
  %conv5994 = sext i8 %1274 to i32
  %cmp5995 = icmp eq i32 %conv5994, 115
  br i1 %cmp5995, label %land.lhs.true.5997, label %if.else

land.lhs.true.5997:                               ; preds = %lor.lhs.false.5993
  %1275 = load i64, i64* %n, align 8
  %1276 = load i64*, i64** %args.addr, align 8
  %arrayidx5998 = getelementptr inbounds i64, i64* %1276, i64 %1275
  %1277 = load i64, i64* %arrayidx5998, align 8
  %call5999 = call zeroext i1 @STRINGP(i64 %1277)
  br i1 %call5999, label %if.else, label %land.lhs.true.6000

land.lhs.true.6000:                               ; preds = %land.lhs.true.5997
  %1278 = load i64, i64* %n, align 8
  %1279 = load i64*, i64** %args.addr, align 8
  %arrayidx6001 = getelementptr inbounds i64, i64* %1279, i64 %1278
  %1280 = load i64, i64* %arrayidx6001, align 8
  %and6002 = and i64 %1280, 7
  %conv6003 = trunc i64 %and6002 to i32
  %cmp6004 = icmp eq i32 %conv6003, 0
  br i1 %cmp6004, label %if.else, label %if.then.6006

if.then.6006:                                     ; preds = %land.lhs.true.6000, %if.end.5989
  %1281 = load i64, i64* %n, align 8
  %1282 = load %struct.info*, %struct.info** %info, align 8
  %arrayidx6007 = getelementptr inbounds %struct.info, %struct.info* %1282, i64 %1281
  %converted_to_string = getelementptr inbounds %struct.info, %struct.info* %arrayidx6007, i32 0, i32 2
  %bf.load = load i8, i8* %converted_to_string, align 8
  %bf.clear = and i8 %bf.load, 1
  %bf.cast = trunc i8 %bf.clear to i1
  br i1 %bf.cast, label %if.end.6032, label %if.then.6008

if.then.6008:                                     ; preds = %if.then.6006
  %1283 = load i8, i8* %conversion, align 1
  %conv6009 = sext i8 %1283 to i32
  %cmp6010 = icmp eq i32 %conv6009, 83
  br i1 %cmp6010, label %cond.true.6012, label %cond.false.6014

cond.true.6012:                                   ; preds = %if.then.6008
  %call6013 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end.6016

cond.false.6014:                                  ; preds = %if.then.6008
  %call6015 = call i64 @builtin_lisp_symbol(i32 901)
  br label %cond.end.6016

cond.end.6016:                                    ; preds = %cond.false.6014, %cond.true.6012
  %cond6017 = phi i64 [ %call6013, %cond.true.6012 ], [ %call6015, %cond.false.6014 ]
  store i64 %cond6017, i64* %noescape, align 8
  %1284 = load i64, i64* %n, align 8
  %1285 = load i64*, i64** %args.addr, align 8
  %arrayidx6018 = getelementptr inbounds i64, i64* %1285, i64 %1284
  %1286 = load i64, i64* %arrayidx6018, align 8
  %1287 = load i64, i64* %noescape, align 8
  %call6019 = call i64 @Fprin1_to_string(i64 %1286, i64 %1287)
  %1288 = load i64, i64* %n, align 8
  %1289 = load i64*, i64** %args.addr, align 8
  %arrayidx6020 = getelementptr inbounds i64, i64* %1289, i64 %1288
  store i64 %call6019, i64* %arrayidx6020, align 8
  %1290 = load i64, i64* %n, align 8
  %1291 = load %struct.info*, %struct.info** %info, align 8
  %arrayidx6021 = getelementptr inbounds %struct.info, %struct.info* %1291, i64 %1290
  %converted_to_string6022 = getelementptr inbounds %struct.info, %struct.info* %arrayidx6021, i32 0, i32 2
  %bf.load6023 = load i8, i8* %converted_to_string6022, align 8
  %bf.clear6024 = and i8 %bf.load6023, -2
  %bf.set = or i8 %bf.clear6024, 1
  store i8 %bf.set, i8* %converted_to_string6022, align 8
  %1292 = load i64, i64* %n, align 8
  %1293 = load i64*, i64** %args.addr, align 8
  %arrayidx6025 = getelementptr inbounds i64, i64* %1293, i64 %1292
  %1294 = load i64, i64* %arrayidx6025, align 8
  %call6026 = call zeroext i1 @STRING_MULTIBYTE(i64 %1294)
  br i1 %call6026, label %land.lhs.true.6028, label %if.end.6031

land.lhs.true.6028:                               ; preds = %cond.end.6016
  %1295 = load i8, i8* %multibyte, align 1
  %tobool6029 = trunc i8 %1295 to i1
  br i1 %tobool6029, label %if.end.6031, label %if.then.6030

if.then.6030:                                     ; preds = %land.lhs.true.6028
  store i8 1, i8* %multibyte, align 1
  br label %retry

if.end.6031:                                      ; preds = %land.lhs.true.6028, %cond.end.6016
  br label %if.end.6032

if.end.6032:                                      ; preds = %if.end.6031, %if.then.6006
  store i8 115, i8* %conversion, align 1
  br label %if.end.6101

if.else:                                          ; preds = %land.lhs.true.6000, %land.lhs.true.5997, %lor.lhs.false.5993
  %1296 = load i8, i8* %conversion, align 1
  %conv6033 = sext i8 %1296 to i32
  %cmp6034 = icmp eq i32 %conv6033, 99
  br i1 %cmp6034, label %if.then.6036, label %if.end.6100

if.then.6036:                                     ; preds = %if.else
  %1297 = load i64, i64* %n, align 8
  %1298 = load i64*, i64** %args.addr, align 8
  %arrayidx6037 = getelementptr inbounds i64, i64* %1298, i64 %1297
  %1299 = load i64, i64* %arrayidx6037, align 8
  %and6038 = and i64 %1299, 7
  %conv6039 = trunc i64 %and6038 to i32
  %cmp6040 = icmp eq i32 %conv6039, 7
  br i1 %cmp6040, label %if.then.6042, label %if.end.6061

if.then.6042:                                     ; preds = %if.then.6036
  %1300 = load i64, i64* %n, align 8
  %1301 = load i64*, i64** %args.addr, align 8
  %arrayidx6043 = getelementptr inbounds i64, i64* %1301, i64 %1300
  %1302 = load i64, i64* %arrayidx6043, align 8
  %call6044 = call double @XFLOAT_DATA(i64 %1302)
  store double %call6044, double* %d, align 8
  %1303 = load double, double* %d, align 8
  %cmp6045 = fcmp ole double 0.000000e+00, %1303
  br i1 %cmp6045, label %land.lhs.true.6050, label %lor.lhs.false.6047

lor.lhs.false.6047:                               ; preds = %if.then.6042
  %1304 = load double, double* %d, align 8
  %cmp6048 = fcmp ole double 0xC3C0000000000000, %1304
  br i1 %cmp6048, label %land.lhs.true.6050, label %cond.true.6053

land.lhs.true.6050:                               ; preds = %lor.lhs.false.6047, %if.then.6042
  %1305 = load double, double* %d, align 8
  %cmp6051 = fcmp ole double %1305, 0x43C0000000000000
  br i1 %cmp6051, label %cond.false.6054, label %cond.true.6053

cond.true.6053:                                   ; preds = %land.lhs.true.6050, %lor.lhs.false.6047
  br label %cond.end.6055

cond.false.6054:                                  ; preds = %land.lhs.true.6050
  %1306 = load double, double* %d, align 8
  br label %cond.end.6055

cond.end.6055:                                    ; preds = %cond.false.6054, %cond.true.6053
  %cond6056 = phi double [ -1.000000e+00, %cond.true.6053 ], [ %1306, %cond.false.6054 ]
  %conv6057 = fptoui double %cond6056 to i64
  %shl6058 = shl i64 %conv6057, 2
  %add6059 = add i64 %shl6058, 2
  %1307 = load i64, i64* %n, align 8
  %1308 = load i64*, i64** %args.addr, align 8
  %arrayidx6060 = getelementptr inbounds i64, i64* %1308, i64 %1307
  store i64 %add6059, i64* %arrayidx6060, align 8
  br label %if.end.6061

if.end.6061:                                      ; preds = %cond.end.6055, %if.then.6036
  %1309 = load i64, i64* %n, align 8
  %1310 = load i64*, i64** %args.addr, align 8
  %arrayidx6062 = getelementptr inbounds i64, i64* %1310, i64 %1309
  %1311 = load i64, i64* %arrayidx6062, align 8
  %and6063 = and i64 %1311, 7
  %conv6064 = trunc i64 %and6063 to i32
  %and6065 = and i32 %conv6064, -5
  %cmp6066 = icmp eq i32 %and6065, 2
  br i1 %cmp6066, label %land.lhs.true.6068, label %if.end.6092

land.lhs.true.6068:                               ; preds = %if.end.6061
  br i1 false, label %cond.true.6069, label %cond.false.6074

cond.true.6069:                                   ; preds = %land.lhs.true.6068
  %1312 = load i64, i64* %n, align 8
  %1313 = load i64*, i64** %args.addr, align 8
  %arrayidx6070 = getelementptr inbounds i64, i64* %1313, i64 %1312
  %1314 = load i64, i64* %arrayidx6070, align 8
  %shr = ashr i64 %1314, 2
  %add6071 = add nsw i64 %shr, 0
  %cmp6072 = icmp slt i64 %add6071, 128
  br i1 %cmp6072, label %if.end.6092, label %if.then.6080

cond.false.6074:                                  ; preds = %land.lhs.true.6068
  %1315 = load i64, i64* %n, align 8
  %1316 = load i64*, i64** %args.addr, align 8
  %arrayidx6075 = getelementptr inbounds i64, i64* %1316, i64 %1315
  %1317 = load i64, i64* %arrayidx6075, align 8
  %shr6076 = ashr i64 %1317, 2
  %add6077 = add i64 %shr6076, 0
  %cmp6078 = icmp ult i64 %add6077, 128
  br i1 %cmp6078, label %if.end.6092, label %if.then.6080

if.then.6080:                                     ; preds = %cond.false.6074, %cond.true.6069
  %1318 = load i8, i8* %multibyte, align 1
  %tobool6081 = trunc i8 %1318 to i1
  br i1 %tobool6081, label %if.end.6083, label %if.then.6082

if.then.6082:                                     ; preds = %if.then.6080
  store i8 1, i8* %multibyte, align 1
  br label %retry

if.end.6083:                                      ; preds = %if.then.6080
  %1319 = load i64, i64* %n, align 8
  %1320 = load i64*, i64** %args.addr, align 8
  %arrayidx6084 = getelementptr inbounds i64, i64* %1320, i64 %1319
  %1321 = load i64, i64* %arrayidx6084, align 8
  %call6085 = call i64 @Fchar_to_string(i64 %1321)
  %1322 = load i64, i64* %n, align 8
  %1323 = load i64*, i64** %args.addr, align 8
  %arrayidx6086 = getelementptr inbounds i64, i64* %1323, i64 %1322
  store i64 %call6085, i64* %arrayidx6086, align 8
  %1324 = load i64, i64* %n, align 8
  %1325 = load %struct.info*, %struct.info** %info, align 8
  %arrayidx6087 = getelementptr inbounds %struct.info, %struct.info* %1325, i64 %1324
  %converted_to_string6088 = getelementptr inbounds %struct.info, %struct.info* %arrayidx6087, i32 0, i32 2
  %bf.load6089 = load i8, i8* %converted_to_string6088, align 8
  %bf.clear6090 = and i8 %bf.load6089, -2
  %bf.set6091 = or i8 %bf.clear6090, 1
  store i8 %bf.set6091, i8* %converted_to_string6088, align 8
  br label %if.end.6092

if.end.6092:                                      ; preds = %if.end.6083, %cond.false.6074, %cond.true.6069, %if.end.6061
  %1326 = load i64, i64* %n, align 8
  %1327 = load %struct.info*, %struct.info** %info, align 8
  %arrayidx6093 = getelementptr inbounds %struct.info, %struct.info* %1327, i64 %1326
  %converted_to_string6094 = getelementptr inbounds %struct.info, %struct.info* %arrayidx6093, i32 0, i32 2
  %bf.load6095 = load i8, i8* %converted_to_string6094, align 8
  %bf.clear6096 = and i8 %bf.load6095, 1
  %bf.cast6097 = trunc i8 %bf.clear6096 to i1
  br i1 %bf.cast6097, label %if.then.6098, label %if.end.6099

if.then.6098:                                     ; preds = %if.end.6092
  store i8 115, i8* %conversion, align 1
  br label %if.end.6099

if.end.6099:                                      ; preds = %if.then.6098, %if.end.6092
  store i8 0, i8* %zero_flag, align 1
  br label %if.end.6100

if.end.6100:                                      ; preds = %if.end.6099, %if.else
  br label %if.end.6101

if.end.6101:                                      ; preds = %if.end.6100, %if.end.6032
  %1328 = load i64, i64* %n, align 8
  %1329 = load i64*, i64** %args.addr, align 8
  %arrayidx6102 = getelementptr inbounds i64, i64* %1329, i64 %1328
  %1330 = load i64, i64* %arrayidx6102, align 8
  %and6103 = and i64 %1330, 7
  %conv6104 = trunc i64 %and6103 to i32
  %cmp6105 = icmp eq i32 %conv6104, 0
  br i1 %cmp6105, label %if.then.6107, label %if.end.6118

if.then.6107:                                     ; preds = %if.end.6101
  %1331 = load i64, i64* %n, align 8
  %1332 = load i64*, i64** %args.addr, align 8
  %arrayidx6108 = getelementptr inbounds i64, i64* %1332, i64 %1331
  %1333 = load i64, i64* %arrayidx6108, align 8
  %call6109 = call i64 @SYMBOL_NAME(i64 %1333)
  %1334 = load i64, i64* %n, align 8
  %1335 = load i64*, i64** %args.addr, align 8
  %arrayidx6110 = getelementptr inbounds i64, i64* %1335, i64 %1334
  store i64 %call6109, i64* %arrayidx6110, align 8
  %1336 = load i64, i64* %n, align 8
  %1337 = load i64*, i64** %args.addr, align 8
  %arrayidx6111 = getelementptr inbounds i64, i64* %1337, i64 %1336
  %1338 = load i64, i64* %arrayidx6111, align 8
  %call6112 = call zeroext i1 @STRING_MULTIBYTE(i64 %1338)
  br i1 %call6112, label %land.lhs.true.6114, label %if.end.6117

land.lhs.true.6114:                               ; preds = %if.then.6107
  %1339 = load i8, i8* %multibyte, align 1
  %tobool6115 = trunc i8 %1339 to i1
  br i1 %tobool6115, label %if.end.6117, label %if.then.6116

if.then.6116:                                     ; preds = %land.lhs.true.6114
  store i8 1, i8* %multibyte, align 1
  br label %retry

if.end.6117:                                      ; preds = %land.lhs.true.6114, %if.then.6107
  br label %if.end.6118

if.end.6118:                                      ; preds = %if.end.6117, %if.end.6101
  %1340 = load i8, i8* %conversion, align 1
  %conv6119 = sext i8 %1340 to i32
  %cmp6120 = icmp eq i32 %conv6119, 115
  br i1 %cmp6120, label %if.then.6122, label %if.else.6241

if.then.6122:                                     ; preds = %if.end.6118
  store i64 -1, i64* %prec, align 8
  %1341 = load i8, i8* %precision_given, align 1
  %tobool6123 = trunc i8 %1341 to i1
  br i1 %tobool6123, label %land.lhs.true.6125, label %if.end.6129

land.lhs.true.6125:                               ; preds = %if.then.6122
  %1342 = load i64, i64* %precision, align 8
  %cmp6126 = icmp ule i64 %1342, 9223372036854775807
  br i1 %cmp6126, label %if.then.6128, label %if.end.6129

if.then.6128:                                     ; preds = %land.lhs.true.6125
  %1343 = load i64, i64* %precision, align 8
  store i64 %1343, i64* %prec, align 8
  br label %if.end.6129

if.end.6129:                                      ; preds = %if.then.6128, %land.lhs.true.6125, %if.then.6122
  %1344 = load i64, i64* %prec, align 8
  %cmp6130 = icmp eq i64 %1344, 0
  br i1 %cmp6130, label %if.then.6132, label %if.else.6133

if.then.6132:                                     ; preds = %if.end.6129
  store i64 0, i64* %nbytes, align 8
  store i64 0, i64* %nchars_string, align 8
  store i64 0, i64* %width, align 8
  br label %if.end.6145

if.else.6133:                                     ; preds = %if.end.6129
  %1345 = load i64, i64* %n, align 8
  %1346 = load i64*, i64** %args.addr, align 8
  %arrayidx6134 = getelementptr inbounds i64, i64* %1346, i64 %1345
  %1347 = load i64, i64* %arrayidx6134, align 8
  %1348 = load i64, i64* %prec, align 8
  %call6135 = call i64 @lisp_string_width(i64 %1347, i64 %1348, i64* %nch, i64* %nby)
  store i64 %call6135, i64* %width, align 8
  %1349 = load i64, i64* %prec, align 8
  %cmp6136 = icmp slt i64 %1349, 0
  br i1 %cmp6136, label %if.then.6138, label %if.else.6143

if.then.6138:                                     ; preds = %if.else.6133
  %1350 = load i64, i64* %n, align 8
  %1351 = load i64*, i64** %args.addr, align 8
  %arrayidx6139 = getelementptr inbounds i64, i64* %1351, i64 %1350
  %1352 = load i64, i64* %arrayidx6139, align 8
  %call6140 = call i64 @SCHARS(i64 %1352)
  store i64 %call6140, i64* %nchars_string, align 8
  %1353 = load i64, i64* %n, align 8
  %1354 = load i64*, i64** %args.addr, align 8
  %arrayidx6141 = getelementptr inbounds i64, i64* %1354, i64 %1353
  %1355 = load i64, i64* %arrayidx6141, align 8
  %call6142 = call i64 @SBYTES(i64 %1355)
  store i64 %call6142, i64* %nbytes, align 8
  br label %if.end.6144

if.else.6143:                                     ; preds = %if.else.6133
  %1356 = load i64, i64* %nch, align 8
  store i64 %1356, i64* %nchars_string, align 8
  %1357 = load i64, i64* %nby, align 8
  store i64 %1357, i64* %nbytes, align 8
  br label %if.end.6144

if.end.6144:                                      ; preds = %if.else.6143, %if.then.6138
  br label %if.end.6145

if.end.6145:                                      ; preds = %if.end.6144, %if.then.6132
  %1358 = load i64, i64* %nbytes, align 8
  store i64 %1358, i64* %convbytes, align 8
  %1359 = load i64, i64* %convbytes, align 8
  %tobool6146 = icmp ne i64 %1359, 0
  br i1 %tobool6146, label %land.lhs.true.6147, label %if.end.6157

land.lhs.true.6147:                               ; preds = %if.end.6145
  %1360 = load i8, i8* %multibyte, align 1
  %tobool6148 = trunc i8 %1360 to i1
  br i1 %tobool6148, label %land.lhs.true.6150, label %if.end.6157

land.lhs.true.6150:                               ; preds = %land.lhs.true.6147
  %1361 = load i64, i64* %n, align 8
  %1362 = load i64*, i64** %args.addr, align 8
  %arrayidx6151 = getelementptr inbounds i64, i64* %1362, i64 %1361
  %1363 = load i64, i64* %arrayidx6151, align 8
  %call6152 = call zeroext i1 @STRING_MULTIBYTE(i64 %1363)
  br i1 %call6152, label %if.end.6157, label %if.then.6153

if.then.6153:                                     ; preds = %land.lhs.true.6150
  %1364 = load i64, i64* %n, align 8
  %1365 = load i64*, i64** %args.addr, align 8
  %arrayidx6154 = getelementptr inbounds i64, i64* %1365, i64 %1364
  %1366 = load i64, i64* %arrayidx6154, align 8
  %call6155 = call i8* @SDATA(i64 %1366)
  %1367 = load i64, i64* %nbytes, align 8
  %call6156 = call i64 @count_size_as_multibyte(i8* %call6155, i64 %1367)
  store i64 %call6156, i64* %convbytes, align 8
  br label %if.end.6157

if.end.6157:                                      ; preds = %if.then.6153, %land.lhs.true.6150, %land.lhs.true.6147, %if.end.6145
  %1368 = load i64, i64* %width, align 8
  %1369 = load i64, i64* %field_width, align 8
  %cmp6158 = icmp slt i64 %1368, %1369
  br i1 %cmp6158, label %cond.true.6160, label %cond.false.6162

cond.true.6160:                                   ; preds = %if.end.6157
  %1370 = load i64, i64* %field_width, align 8
  %1371 = load i64, i64* %width, align 8
  %sub6161 = sub nsw i64 %1370, %1371
  br label %cond.end.6163

cond.false.6162:                                  ; preds = %if.end.6157
  br label %cond.end.6163

cond.end.6163:                                    ; preds = %cond.false.6162, %cond.true.6160
  %cond6164 = phi i64 [ %sub6161, %cond.true.6160 ], [ 0, %cond.false.6162 ]
  store i64 %cond6164, i64* %padding, align 8
  %1372 = load i64, i64* %max_bufsize, align 8
  %1373 = load i64, i64* %padding, align 8
  %sub6165 = sub nsw i64 %1372, %1373
  %1374 = load i64, i64* %convbytes, align 8
  %cmp6166 = icmp sle i64 %sub6165, %1374
  br i1 %cmp6166, label %if.then.6168, label %if.end.6169

if.then.6168:                                     ; preds = %cond.end.6163
  call void @string_overflow() #9
  unreachable

if.end.6169:                                      ; preds = %cond.end.6163
  %1375 = load i64, i64* %padding, align 8
  %1376 = load i64, i64* %convbytes, align 8
  %add6170 = add nsw i64 %1376, %1375
  store i64 %add6170, i64* %convbytes, align 8
  %1377 = load i64, i64* %convbytes, align 8
  %1378 = load i8*, i8** %buf, align 8
  %1379 = load i64, i64* %bufsize, align 8
  %add.ptr6171 = getelementptr inbounds i8, i8* %1378, i64 %1379
  %1380 = load i8*, i8** %p, align 8
  %sub.ptr.lhs.cast6172 = ptrtoint i8* %add.ptr6171 to i64
  %sub.ptr.rhs.cast6173 = ptrtoint i8* %1380 to i64
  %sub.ptr.sub6174 = sub i64 %sub.ptr.lhs.cast6172, %sub.ptr.rhs.cast6173
  %cmp6175 = icmp sle i64 %1377, %sub.ptr.sub6174
  br i1 %cmp6175, label %if.then.6177, label %if.end.6240

if.then.6177:                                     ; preds = %if.end.6169
  %1381 = load i8, i8* %minus_flag, align 1
  %tobool6178 = trunc i8 %1381 to i1
  br i1 %tobool6178, label %if.end.6182, label %if.then.6179

if.then.6179:                                     ; preds = %if.then.6177
  %1382 = load i8*, i8** %p, align 8
  %1383 = load i64, i64* %padding, align 8
  call void @llvm.memset.p0i8.i64(i8* %1382, i8 32, i64 %1383, i32 1, i1 false)
  %1384 = load i64, i64* %padding, align 8
  %1385 = load i8*, i8** %p, align 8
  %add.ptr6180 = getelementptr inbounds i8, i8* %1385, i64 %1384
  store i8* %add.ptr6180, i8** %p, align 8
  %1386 = load i64, i64* %padding, align 8
  %1387 = load i64, i64* %nchars, align 8
  %add6181 = add nsw i64 %1387, %1386
  store i64 %add6181, i64* %nchars, align 8
  br label %if.end.6182

if.end.6182:                                      ; preds = %if.then.6179, %if.then.6177
  %1388 = load i8*, i8** %p, align 8
  %1389 = load i8*, i8** %buf, align 8
  %cmp6183 = icmp ugt i8* %1388, %1389
  br i1 %cmp6183, label %land.lhs.true.6185, label %if.end.6213

land.lhs.true.6185:                               ; preds = %if.end.6182
  %1390 = load i8, i8* %multibyte, align 1
  %tobool6186 = trunc i8 %1390 to i1
  br i1 %tobool6186, label %land.lhs.true.6188, label %if.end.6213

land.lhs.true.6188:                               ; preds = %land.lhs.true.6185
  br i1 true, label %cond.true.6189, label %cond.false.6195

cond.true.6189:                                   ; preds = %land.lhs.true.6188
  %1391 = load i8*, i8** %p, align 8
  %add.ptr6190 = getelementptr inbounds i8, i8* %1391, i64 -1
  %1392 = load i8, i8* %add.ptr6190, align 1
  %conv6191 = zext i8 %1392 to i32
  %add6192 = add i32 %conv6191, 0
  %cmp6193 = icmp ult i32 %add6192, 128
  br i1 %cmp6193, label %if.end.6213, label %land.lhs.true.6201

cond.false.6195:                                  ; preds = %land.lhs.true.6188
  %1393 = load i8*, i8** %p, align 8
  %add.ptr6196 = getelementptr inbounds i8, i8* %1393, i64 -1
  %1394 = load i8, i8* %add.ptr6196, align 1
  %conv6197 = zext i8 %1394 to i64
  %add6198 = add i64 %conv6197, 0
  %cmp6199 = icmp ult i64 %add6198, 128
  br i1 %cmp6199, label %if.end.6213, label %land.lhs.true.6201

land.lhs.true.6201:                               ; preds = %cond.false.6195, %cond.true.6189
  %1395 = load i64, i64* %n, align 8
  %1396 = load i64*, i64** %args.addr, align 8
  %arrayidx6202 = getelementptr inbounds i64, i64* %1396, i64 %1395
  %1397 = load i64, i64* %arrayidx6202, align 8
  %call6203 = call zeroext i1 @STRING_MULTIBYTE(i64 %1397)
  br i1 %call6203, label %land.lhs.true.6205, label %if.end.6213

land.lhs.true.6205:                               ; preds = %land.lhs.true.6201
  %1398 = load i64, i64* %n, align 8
  %1399 = load i64*, i64** %args.addr, align 8
  %arrayidx6206 = getelementptr inbounds i64, i64* %1399, i64 %1398
  %1400 = load i64, i64* %arrayidx6206, align 8
  %call6207 = call zeroext i8 @SREF(i64 %1400, i64 0)
  %conv6208 = zext i8 %call6207 to i32
  %and6209 = and i32 %conv6208, 192
  %cmp6210 = icmp ne i32 %and6209, 128
  br i1 %cmp6210, label %if.end.6213, label %if.then.6212

if.then.6212:                                     ; preds = %land.lhs.true.6205
  store i8 1, i8* %maybe_combine_byte, align 1
  br label %if.end.6213

if.end.6213:                                      ; preds = %if.then.6212, %land.lhs.true.6205, %land.lhs.true.6201, %cond.false.6195, %cond.true.6189, %land.lhs.true.6185, %if.end.6182
  %1401 = load i64, i64* %n, align 8
  %1402 = load i64*, i64** %args.addr, align 8
  %arrayidx6214 = getelementptr inbounds i64, i64* %1402, i64 %1401
  %1403 = load i64, i64* %arrayidx6214, align 8
  %call6215 = call i8* @SDATA(i64 %1403)
  %1404 = load i8*, i8** %p, align 8
  %1405 = load i64, i64* %nbytes, align 8
  %1406 = load i64, i64* %n, align 8
  %1407 = load i64*, i64** %args.addr, align 8
  %arrayidx6216 = getelementptr inbounds i64, i64* %1407, i64 %1406
  %1408 = load i64, i64* %arrayidx6216, align 8
  %call6217 = call zeroext i1 @STRING_MULTIBYTE(i64 %1408)
  %1409 = load i8, i8* %multibyte, align 1
  %tobool6218 = trunc i8 %1409 to i1
  %call6219 = call i64 @copy_text(i8* %call6215, i8* %1404, i64 %1405, i1 zeroext %call6217, i1 zeroext %tobool6218)
  %1410 = load i8*, i8** %p, align 8
  %add.ptr6220 = getelementptr inbounds i8, i8* %1410, i64 %call6219
  store i8* %add.ptr6220, i8** %p, align 8
  %1411 = load i64, i64* %nchars, align 8
  %1412 = load i64, i64* %n, align 8
  %1413 = load %struct.info*, %struct.info** %info, align 8
  %arrayidx6221 = getelementptr inbounds %struct.info, %struct.info* %1413, i64 %1412
  %start6222 = getelementptr inbounds %struct.info, %struct.info* %arrayidx6221, i32 0, i32 0
  store i64 %1411, i64* %start6222, align 8
  %1414 = load i64, i64* %nchars_string, align 8
  %1415 = load i64, i64* %nchars, align 8
  %add6223 = add nsw i64 %1415, %1414
  store i64 %add6223, i64* %nchars, align 8
  %1416 = load i64, i64* %nchars, align 8
  %1417 = load i64, i64* %n, align 8
  %1418 = load %struct.info*, %struct.info** %info, align 8
  %arrayidx6224 = getelementptr inbounds %struct.info, %struct.info* %1418, i64 %1417
  %end6225 = getelementptr inbounds %struct.info, %struct.info* %arrayidx6224, i32 0, i32 1
  store i64 %1416, i64* %end6225, align 8
  %1419 = load i8, i8* %minus_flag, align 1
  %tobool6226 = trunc i8 %1419 to i1
  br i1 %tobool6226, label %if.then.6227, label %if.end.6230

if.then.6227:                                     ; preds = %if.end.6213
  %1420 = load i8*, i8** %p, align 8
  %1421 = load i64, i64* %padding, align 8
  call void @llvm.memset.p0i8.i64(i8* %1420, i8 32, i64 %1421, i32 1, i1 false)
  %1422 = load i64, i64* %padding, align 8
  %1423 = load i8*, i8** %p, align 8
  %add.ptr6228 = getelementptr inbounds i8, i8* %1423, i64 %1422
  store i8* %add.ptr6228, i8** %p, align 8
  %1424 = load i64, i64* %padding, align 8
  %1425 = load i64, i64* %nchars, align 8
  %add6229 = add nsw i64 %1425, %1424
  store i64 %add6229, i64* %nchars, align 8
  br label %if.end.6230

if.end.6230:                                      ; preds = %if.then.6227, %if.end.6213
  %1426 = load i64, i64* %n, align 8
  %1427 = load i64*, i64** %args.addr, align 8
  %arrayidx6231 = getelementptr inbounds i64, i64* %1427, i64 %1426
  %1428 = load i64, i64* %arrayidx6231, align 8
  %call6232 = call %struct.interval* @string_intervals(i64 %1428)
  %tobool6233 = icmp ne %struct.interval* %call6232, null
  br i1 %tobool6233, label %if.then.6234, label %if.end.6239

if.then.6234:                                     ; preds = %if.end.6230
  store i8 1, i8* %arg_intervals, align 1
  %1429 = load i64, i64* %n, align 8
  %1430 = load %struct.info*, %struct.info** %info, align 8
  %arrayidx6235 = getelementptr inbounds %struct.info, %struct.info* %1430, i64 %1429
  %intervals = getelementptr inbounds %struct.info, %struct.info* %arrayidx6235, i32 0, i32 2
  %bf.load6236 = load i8, i8* %intervals, align 8
  %bf.clear6237 = and i8 %bf.load6236, -3
  %bf.set6238 = or i8 %bf.clear6237, 2
  store i8 %bf.set6238, i8* %intervals, align 8
  br label %if.end.6239

if.end.6239:                                      ; preds = %if.then.6234, %if.end.6230
  br label %while.cond

if.end.6240:                                      ; preds = %if.end.6169
  br label %if.end.6737

if.else.6241:                                     ; preds = %if.end.6118
  %1431 = load i8, i8* %conversion, align 1
  %conv6242 = sext i8 %1431 to i32
  %cmp6243 = icmp eq i32 %conv6242, 99
  br i1 %cmp6243, label %if.else.6342, label %lor.lhs.false.6245

lor.lhs.false.6245:                               ; preds = %if.else.6241
  %1432 = load i8, i8* %conversion, align 1
  %conv6246 = sext i8 %1432 to i32
  %cmp6247 = icmp eq i32 %conv6246, 100
  br i1 %cmp6247, label %if.else.6342, label %lor.lhs.false.6249

lor.lhs.false.6249:                               ; preds = %lor.lhs.false.6245
  %1433 = load i8, i8* %conversion, align 1
  %conv6250 = sext i8 %1433 to i32
  %cmp6251 = icmp eq i32 %conv6250, 101
  br i1 %cmp6251, label %if.else.6342, label %lor.lhs.false.6253

lor.lhs.false.6253:                               ; preds = %lor.lhs.false.6249
  %1434 = load i8, i8* %conversion, align 1
  %conv6254 = sext i8 %1434 to i32
  %cmp6255 = icmp eq i32 %conv6254, 102
  br i1 %cmp6255, label %if.else.6342, label %lor.lhs.false.6257

lor.lhs.false.6257:                               ; preds = %lor.lhs.false.6253
  %1435 = load i8, i8* %conversion, align 1
  %conv6258 = sext i8 %1435 to i32
  %cmp6259 = icmp eq i32 %conv6258, 103
  br i1 %cmp6259, label %if.else.6342, label %lor.lhs.false.6261

lor.lhs.false.6261:                               ; preds = %lor.lhs.false.6257
  %1436 = load i8, i8* %conversion, align 1
  %conv6262 = sext i8 %1436 to i32
  %cmp6263 = icmp eq i32 %conv6262, 105
  br i1 %cmp6263, label %if.else.6342, label %lor.lhs.false.6265

lor.lhs.false.6265:                               ; preds = %lor.lhs.false.6261
  %1437 = load i8, i8* %conversion, align 1
  %conv6266 = sext i8 %1437 to i32
  %cmp6267 = icmp eq i32 %conv6266, 111
  br i1 %cmp6267, label %if.else.6342, label %lor.lhs.false.6269

lor.lhs.false.6269:                               ; preds = %lor.lhs.false.6265
  %1438 = load i8, i8* %conversion, align 1
  %conv6270 = sext i8 %1438 to i32
  %cmp6271 = icmp eq i32 %conv6270, 120
  br i1 %cmp6271, label %if.else.6342, label %lor.lhs.false.6273

lor.lhs.false.6273:                               ; preds = %lor.lhs.false.6269
  %1439 = load i8, i8* %conversion, align 1
  %conv6274 = sext i8 %1439 to i32
  %cmp6275 = icmp eq i32 %conv6274, 88
  br i1 %cmp6275, label %if.else.6342, label %if.then.6277

if.then.6277:                                     ; preds = %lor.lhs.false.6273
  %1440 = load i8*, i8** %format, align 8
  %add.ptr6278 = getelementptr inbounds i8, i8* %1440, i64 -1
  %arrayidx6279 = getelementptr inbounds i8, i8* %add.ptr6278, i64 0
  %1441 = load i8, i8* %arrayidx6279, align 1
  %conv6280 = zext i8 %1441 to i32
  %and6281 = and i32 %conv6280, 128
  %tobool6282 = icmp ne i32 %and6281, 0
  br i1 %tobool6282, label %cond.false.6287, label %cond.true.6283

cond.true.6283:                                   ; preds = %if.then.6277
  %1442 = load i8*, i8** %format, align 8
  %add.ptr6284 = getelementptr inbounds i8, i8* %1442, i64 -1
  %arrayidx6285 = getelementptr inbounds i8, i8* %add.ptr6284, i64 0
  %1443 = load i8, i8* %arrayidx6285, align 1
  %conv6286 = zext i8 %1443 to i32
  br label %cond.end.6340

cond.false.6287:                                  ; preds = %if.then.6277
  %1444 = load i8*, i8** %format, align 8
  %add.ptr6288 = getelementptr inbounds i8, i8* %1444, i64 -1
  %arrayidx6289 = getelementptr inbounds i8, i8* %add.ptr6288, i64 0
  %1445 = load i8, i8* %arrayidx6289, align 1
  %conv6290 = zext i8 %1445 to i32
  %and6291 = and i32 %conv6290, 32
  %tobool6292 = icmp ne i32 %and6291, 0
  br i1 %tobool6292, label %cond.false.6310, label %cond.true.6293

cond.true.6293:                                   ; preds = %cond.false.6287
  %1446 = load i8*, i8** %format, align 8
  %add.ptr6294 = getelementptr inbounds i8, i8* %1446, i64 -1
  %arrayidx6295 = getelementptr inbounds i8, i8* %add.ptr6294, i64 0
  %1447 = load i8, i8* %arrayidx6295, align 1
  %conv6296 = zext i8 %1447 to i32
  %and6297 = and i32 %conv6296, 31
  %shl6298 = shl i32 %and6297, 6
  %1448 = load i8*, i8** %format, align 8
  %add.ptr6299 = getelementptr inbounds i8, i8* %1448, i64 -1
  %arrayidx6300 = getelementptr inbounds i8, i8* %add.ptr6299, i64 1
  %1449 = load i8, i8* %arrayidx6300, align 1
  %conv6301 = zext i8 %1449 to i32
  %and6302 = and i32 %conv6301, 63
  %or = or i32 %shl6298, %and6302
  %1450 = load i8*, i8** %format, align 8
  %add.ptr6303 = getelementptr inbounds i8, i8* %1450, i64 -1
  %arrayidx6304 = getelementptr inbounds i8, i8* %add.ptr6303, i64 0
  %1451 = load i8, i8* %arrayidx6304, align 1
  %conv6305 = zext i8 %1451 to i32
  %cmp6306 = icmp slt i32 %conv6305, 194
  %cond6308 = select i1 %cmp6306, i32 4194176, i32 0
  %add6309 = add nsw i32 %or, %cond6308
  br label %cond.end.6338

cond.false.6310:                                  ; preds = %cond.false.6287
  %1452 = load i8*, i8** %format, align 8
  %add.ptr6311 = getelementptr inbounds i8, i8* %1452, i64 -1
  %arrayidx6312 = getelementptr inbounds i8, i8* %add.ptr6311, i64 0
  %1453 = load i8, i8* %arrayidx6312, align 1
  %conv6313 = zext i8 %1453 to i32
  %and6314 = and i32 %conv6313, 16
  %tobool6315 = icmp ne i32 %and6314, 0
  br i1 %tobool6315, label %cond.false.6333, label %cond.true.6316

cond.true.6316:                                   ; preds = %cond.false.6310
  %1454 = load i8*, i8** %format, align 8
  %add.ptr6317 = getelementptr inbounds i8, i8* %1454, i64 -1
  %arrayidx6318 = getelementptr inbounds i8, i8* %add.ptr6317, i64 0
  %1455 = load i8, i8* %arrayidx6318, align 1
  %conv6319 = zext i8 %1455 to i32
  %and6320 = and i32 %conv6319, 15
  %shl6321 = shl i32 %and6320, 12
  %1456 = load i8*, i8** %format, align 8
  %add.ptr6322 = getelementptr inbounds i8, i8* %1456, i64 -1
  %arrayidx6323 = getelementptr inbounds i8, i8* %add.ptr6322, i64 1
  %1457 = load i8, i8* %arrayidx6323, align 1
  %conv6324 = zext i8 %1457 to i32
  %and6325 = and i32 %conv6324, 63
  %shl6326 = shl i32 %and6325, 6
  %or6327 = or i32 %shl6321, %shl6326
  %1458 = load i8*, i8** %format, align 8
  %add.ptr6328 = getelementptr inbounds i8, i8* %1458, i64 -1
  %arrayidx6329 = getelementptr inbounds i8, i8* %add.ptr6328, i64 2
  %1459 = load i8, i8* %arrayidx6329, align 1
  %conv6330 = zext i8 %1459 to i32
  %and6331 = and i32 %conv6330, 63
  %or6332 = or i32 %or6327, %and6331
  br label %cond.end.6336

cond.false.6333:                                  ; preds = %cond.false.6310
  %1460 = load i8*, i8** %format, align 8
  %add.ptr6334 = getelementptr inbounds i8, i8* %1460, i64 -1
  %call6335 = call i32 @string_char(i8* %add.ptr6334, i8** null, i32* null)
  br label %cond.end.6336

cond.end.6336:                                    ; preds = %cond.false.6333, %cond.true.6316
  %cond6337 = phi i32 [ %or6332, %cond.true.6316 ], [ %call6335, %cond.false.6333 ]
  br label %cond.end.6338

cond.end.6338:                                    ; preds = %cond.end.6336, %cond.true.6293
  %cond6339 = phi i32 [ %add6309, %cond.true.6293 ], [ %cond6337, %cond.end.6336 ]
  br label %cond.end.6340

cond.end.6340:                                    ; preds = %cond.end.6338, %cond.true.6283
  %cond6341 = phi i32 [ %conv6286, %cond.true.6283 ], [ %cond6339, %cond.end.6338 ]
  call void (i8*, ...) @error(i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.39, i32 0, i32 0), i32 %cond6341) #9
  unreachable

if.else.6342:                                     ; preds = %lor.lhs.false.6273, %lor.lhs.false.6269, %lor.lhs.false.6265, %lor.lhs.false.6261, %lor.lhs.false.6257, %lor.lhs.false.6253, %lor.lhs.false.6249, %lor.lhs.false.6245, %if.else.6241
  %1461 = load i64, i64* %n, align 8
  %1462 = load i64*, i64** %args.addr, align 8
  %arrayidx6343 = getelementptr inbounds i64, i64* %1462, i64 %1461
  %1463 = load i64, i64* %arrayidx6343, align 8
  %call6344 = call zeroext i1 @NUMBERP(i64 %1463)
  br i1 %call6344, label %if.else.6346, label %if.then.6345

if.then.6345:                                     ; preds = %if.else.6342
  call void (i8*, ...) @error(i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.40, i32 0, i32 0)) #9
  unreachable

if.else.6346:                                     ; preds = %if.else.6342
  %1464 = load i8, i8* %conversion, align 1
  %conv6347 = sext i8 %1464 to i32
  %cmp6348 = icmp eq i32 %conv6347, 100
  br i1 %cmp6348, label %if.then.6354, label %lor.lhs.false.6350

lor.lhs.false.6350:                               ; preds = %if.else.6346
  %1465 = load i8, i8* %conversion, align 1
  %conv6351 = sext i8 %1465 to i32
  %cmp6352 = icmp eq i32 %conv6351, 105
  br i1 %cmp6352, label %if.then.6354, label %if.end.6355

if.then.6354:                                     ; preds = %lor.lhs.false.6350, %if.else.6346
  store i8 0, i8* %sharp_flag, align 1
  br label %if.end.6355

if.end.6355:                                      ; preds = %if.then.6354, %lor.lhs.false.6350
  %arraydecay6356 = getelementptr inbounds [9 x i8], [9 x i8]* %convspec, i32 0, i32 0
  store i8* %arraydecay6356, i8** %f, align 8
  %1466 = load i8*, i8** %f, align 8
  %incdec.ptr6357 = getelementptr inbounds i8, i8* %1466, i32 1
  store i8* %incdec.ptr6357, i8** %f, align 8
  store i8 37, i8* %1466, align 1
  %1467 = load i8*, i8** %f, align 8
  store i8 45, i8* %1467, align 1
  %1468 = load i8, i8* %minus_flag, align 1
  %tobool6358 = trunc i8 %1468 to i1
  %conv6359 = zext i1 %tobool6358 to i32
  %1469 = load i8*, i8** %f, align 8
  %idx.ext = sext i32 %conv6359 to i64
  %add.ptr6360 = getelementptr inbounds i8, i8* %1469, i64 %idx.ext
  store i8* %add.ptr6360, i8** %f, align 8
  %1470 = load i8*, i8** %f, align 8
  store i8 43, i8* %1470, align 1
  %1471 = load i8, i8* %plus_flag, align 1
  %tobool6361 = trunc i8 %1471 to i1
  %conv6362 = zext i1 %tobool6361 to i32
  %1472 = load i8*, i8** %f, align 8
  %idx.ext6363 = sext i32 %conv6362 to i64
  %add.ptr6364 = getelementptr inbounds i8, i8* %1472, i64 %idx.ext6363
  store i8* %add.ptr6364, i8** %f, align 8
  %1473 = load i8*, i8** %f, align 8
  store i8 32, i8* %1473, align 1
  %1474 = load i8, i8* %space_flag, align 1
  %tobool6365 = trunc i8 %1474 to i1
  %conv6366 = zext i1 %tobool6365 to i32
  %1475 = load i8*, i8** %f, align 8
  %idx.ext6367 = sext i32 %conv6366 to i64
  %add.ptr6368 = getelementptr inbounds i8, i8* %1475, i64 %idx.ext6367
  store i8* %add.ptr6368, i8** %f, align 8
  %1476 = load i8*, i8** %f, align 8
  store i8 35, i8* %1476, align 1
  %1477 = load i8, i8* %sharp_flag, align 1
  %tobool6369 = trunc i8 %1477 to i1
  %conv6370 = zext i1 %tobool6369 to i32
  %1478 = load i8*, i8** %f, align 8
  %idx.ext6371 = sext i32 %conv6370 to i64
  %add.ptr6372 = getelementptr inbounds i8, i8* %1478, i64 %idx.ext6371
  store i8* %add.ptr6372, i8** %f, align 8
  %1479 = load i8*, i8** %f, align 8
  store i8 48, i8* %1479, align 1
  %1480 = load i8, i8* %zero_flag, align 1
  %tobool6373 = trunc i8 %1480 to i1
  %conv6374 = zext i1 %tobool6373 to i32
  %1481 = load i8*, i8** %f, align 8
  %idx.ext6375 = sext i32 %conv6374 to i64
  %add.ptr6376 = getelementptr inbounds i8, i8* %1481, i64 %idx.ext6375
  store i8* %add.ptr6376, i8** %f, align 8
  %1482 = load i8*, i8** %f, align 8
  %incdec.ptr6377 = getelementptr inbounds i8, i8* %1482, i32 1
  store i8* %incdec.ptr6377, i8** %f, align 8
  store i8 46, i8* %1482, align 1
  %1483 = load i8*, i8** %f, align 8
  %incdec.ptr6378 = getelementptr inbounds i8, i8* %1483, i32 1
  store i8* %incdec.ptr6378, i8** %f, align 8
  store i8 42, i8* %1483, align 1
  %1484 = load i8, i8* %conversion, align 1
  %conv6379 = sext i8 %1484 to i32
  %cmp6380 = icmp eq i32 %conv6379, 100
  br i1 %cmp6380, label %if.then.6398, label %lor.lhs.false.6382

lor.lhs.false.6382:                               ; preds = %if.end.6355
  %1485 = load i8, i8* %conversion, align 1
  %conv6383 = sext i8 %1485 to i32
  %cmp6384 = icmp eq i32 %conv6383, 105
  br i1 %cmp6384, label %if.then.6398, label %lor.lhs.false.6386

lor.lhs.false.6386:                               ; preds = %lor.lhs.false.6382
  %1486 = load i8, i8* %conversion, align 1
  %conv6387 = sext i8 %1486 to i32
  %cmp6388 = icmp eq i32 %conv6387, 111
  br i1 %cmp6388, label %if.then.6398, label %lor.lhs.false.6390

lor.lhs.false.6390:                               ; preds = %lor.lhs.false.6386
  %1487 = load i8, i8* %conversion, align 1
  %conv6391 = sext i8 %1487 to i32
  %cmp6392 = icmp eq i32 %conv6391, 120
  br i1 %cmp6392, label %if.then.6398, label %lor.lhs.false.6394

lor.lhs.false.6394:                               ; preds = %lor.lhs.false.6390
  %1488 = load i8, i8* %conversion, align 1
  %conv6395 = sext i8 %1488 to i32
  %cmp6396 = icmp eq i32 %conv6395, 88
  br i1 %cmp6396, label %if.then.6398, label %if.end.6408

if.then.6398:                                     ; preds = %lor.lhs.false.6394, %lor.lhs.false.6390, %lor.lhs.false.6386, %lor.lhs.false.6382, %if.end.6355
  %1489 = load i8*, i8** %f, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1489, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.41, i32 0, i32 0), i64 1, i32 1, i1 false)
  %1490 = load i8*, i8** %f, align 8
  %add.ptr6399 = getelementptr inbounds i8, i8* %1490, i64 1
  store i8* %add.ptr6399, i8** %f, align 8
  %1491 = load i8, i8* %precision_given, align 1
  %tobool6400 = trunc i8 %1491 to i1
  %conv6401 = zext i1 %tobool6400 to i32
  %neg6402 = xor i32 %conv6401, -1
  %1492 = load i8, i8* %zero_flag, align 1
  %tobool6403 = trunc i8 %1492 to i1
  %conv6404 = zext i1 %tobool6403 to i32
  %and6405 = and i32 %conv6404, %neg6402
  %tobool6406 = icmp ne i32 %and6405, 0
  %frombool6407 = zext i1 %tobool6406 to i8
  store i8 %frombool6407, i8* %zero_flag, align 1
  br label %if.end.6408

if.end.6408:                                      ; preds = %if.then.6398, %lor.lhs.false.6394
  %1493 = load i8, i8* %conversion, align 1
  %1494 = load i8*, i8** %f, align 8
  %incdec.ptr6409 = getelementptr inbounds i8, i8* %1494, i32 1
  store i8* %incdec.ptr6409, i8** %f, align 8
  store i8 %1493, i8* %1494, align 1
  %1495 = load i8*, i8** %f, align 8
  store i8 0, i8* %1495, align 1
  store i32 -1, i32* %prec6410, align 4
  %1496 = load i8, i8* %precision_given, align 1
  %tobool6411 = trunc i8 %1496 to i1
  br i1 %tobool6411, label %if.then.6412, label %if.end.6420

if.then.6412:                                     ; preds = %if.end.6408
  %1497 = load i64, i64* %precision, align 8
  %cmp6413 = icmp ult i64 %1497, 1022
  br i1 %cmp6413, label %cond.true.6415, label %cond.false.6416

cond.true.6415:                                   ; preds = %if.then.6412
  %1498 = load i64, i64* %precision, align 8
  br label %cond.end.6417

cond.false.6416:                                  ; preds = %if.then.6412
  br label %cond.end.6417

cond.end.6417:                                    ; preds = %cond.false.6416, %cond.true.6415
  %cond6418 = phi i64 [ %1498, %cond.true.6415 ], [ 1022, %cond.false.6416 ]
  %conv6419 = trunc i64 %cond6418 to i32
  store i32 %conv6419, i32* %prec6410, align 4
  br label %if.end.6420

if.end.6420:                                      ; preds = %cond.end.6417, %if.end.6408
  %1499 = load i8, i8* %conversion, align 1
  %conv6421 = sext i8 %1499 to i32
  %cmp6422 = icmp eq i32 %conv6421, 101
  br i1 %cmp6422, label %if.then.6432, label %lor.lhs.false.6424

lor.lhs.false.6424:                               ; preds = %if.end.6420
  %1500 = load i8, i8* %conversion, align 1
  %conv6425 = sext i8 %1500 to i32
  %cmp6426 = icmp eq i32 %conv6425, 102
  br i1 %cmp6426, label %if.then.6432, label %lor.lhs.false.6428

lor.lhs.false.6428:                               ; preds = %lor.lhs.false.6424
  %1501 = load i8, i8* %conversion, align 1
  %conv6429 = sext i8 %1501 to i32
  %cmp6430 = icmp eq i32 %conv6429, 103
  br i1 %cmp6430, label %if.then.6432, label %if.else.6452

if.then.6432:                                     ; preds = %lor.lhs.false.6428, %lor.lhs.false.6424, %if.end.6420
  %1502 = load i64, i64* %n, align 8
  %1503 = load i64*, i64** %args.addr, align 8
  %arrayidx6433 = getelementptr inbounds i64, i64* %1503, i64 %1502
  %1504 = load i64, i64* %arrayidx6433, align 8
  %and6434 = and i64 %1504, 7
  %conv6435 = trunc i64 %and6434 to i32
  %and6436 = and i32 %conv6435, -5
  %cmp6437 = icmp eq i32 %and6436, 2
  br i1 %cmp6437, label %cond.true.6439, label %cond.false.6443

cond.true.6439:                                   ; preds = %if.then.6432
  %1505 = load i64, i64* %n, align 8
  %1506 = load i64*, i64** %args.addr, align 8
  %arrayidx6440 = getelementptr inbounds i64, i64* %1506, i64 %1505
  %1507 = load i64, i64* %arrayidx6440, align 8
  %shr6441 = ashr i64 %1507, 2
  %conv6442 = sitofp i64 %shr6441 to double
  br label %cond.end.6446

cond.false.6443:                                  ; preds = %if.then.6432
  %1508 = load i64, i64* %n, align 8
  %1509 = load i64*, i64** %args.addr, align 8
  %arrayidx6444 = getelementptr inbounds i64, i64* %1509, i64 %1508
  %1510 = load i64, i64* %arrayidx6444, align 8
  %call6445 = call double @XFLOAT_DATA(i64 %1510)
  br label %cond.end.6446

cond.end.6446:                                    ; preds = %cond.false.6443, %cond.true.6439
  %cond6447 = phi double [ %conv6442, %cond.true.6439 ], [ %call6445, %cond.false.6443 ]
  store double %cond6447, double* %x, align 8
  %arraydecay6448 = getelementptr inbounds [1334 x i8], [1334 x i8]* %sprintf_buf, i32 0, i32 0
  %arraydecay6449 = getelementptr inbounds [9 x i8], [9 x i8]* %convspec, i32 0, i32 0
  %1511 = load i32, i32* %prec6410, align 4
  %1512 = load double, double* %x, align 8
  %call6450 = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay6448, i8* %arraydecay6449, i32 %1511, double %1512) #5
  %conv6451 = sext i32 %call6450 to i64
  store i64 %conv6451, i64* %sprintf_bytes, align 8
  br label %if.end.6538

if.else.6452:                                     ; preds = %lor.lhs.false.6428
  %1513 = load i8, i8* %conversion, align 1
  %conv6453 = sext i8 %1513 to i32
  %cmp6454 = icmp eq i32 %conv6453, 99
  br i1 %cmp6454, label %if.then.6456, label %if.else.6464

if.then.6456:                                     ; preds = %if.else.6452
  %1514 = load i64, i64* %n, align 8
  %1515 = load i64*, i64** %args.addr, align 8
  %arrayidx6457 = getelementptr inbounds i64, i64* %1515, i64 %1514
  %1516 = load i64, i64* %arrayidx6457, align 8
  %shr6458 = ashr i64 %1516, 2
  %conv6459 = trunc i64 %shr6458 to i8
  %arrayidx6460 = getelementptr inbounds [1334 x i8], [1334 x i8]* %sprintf_buf, i32 0, i64 0
  store i8 %conv6459, i8* %arrayidx6460, align 1
  %1517 = load i32, i32* %prec6410, align 4
  %cmp6461 = icmp ne i32 %1517, 0
  %conv6462 = zext i1 %cmp6461 to i32
  %conv6463 = sext i32 %conv6462 to i64
  store i64 %conv6463, i64* %sprintf_bytes, align 8
  br label %if.end.6537

if.else.6464:                                     ; preds = %if.else.6452
  %1518 = load i8, i8* %conversion, align 1
  %conv6465 = sext i8 %1518 to i32
  %cmp6466 = icmp eq i32 %conv6465, 100
  br i1 %cmp6466, label %if.then.6468, label %if.else.6505

if.then.6468:                                     ; preds = %if.else.6464
  %1519 = load i64, i64* %n, align 8
  %1520 = load i64*, i64** %args.addr, align 8
  %arrayidx6470 = getelementptr inbounds i64, i64* %1520, i64 %1519
  %1521 = load i64, i64* %arrayidx6470, align 8
  %and6471 = and i64 %1521, 7
  %conv6472 = trunc i64 %and6471 to i32
  %and6473 = and i32 %conv6472, -5
  %cmp6474 = icmp eq i32 %and6473, 2
  br i1 %cmp6474, label %if.then.6476, label %if.else.6479

if.then.6476:                                     ; preds = %if.then.6468
  %1522 = load i64, i64* %n, align 8
  %1523 = load i64*, i64** %args.addr, align 8
  %arrayidx6477 = getelementptr inbounds i64, i64* %1523, i64 %1522
  %1524 = load i64, i64* %arrayidx6477, align 8
  %shr6478 = ashr i64 %1524, 2
  store i64 %shr6478, i64* %x6469, align 8
  br label %if.end.6500

if.else.6479:                                     ; preds = %if.then.6468
  %1525 = load i64, i64* %n, align 8
  %1526 = load i64*, i64** %args.addr, align 8
  %arrayidx6481 = getelementptr inbounds i64, i64* %1526, i64 %1525
  %1527 = load i64, i64* %arrayidx6481, align 8
  %call6482 = call double @XFLOAT_DATA(i64 %1527)
  store double %call6482, double* %d6480, align 8
  %1528 = load double, double* %d6480, align 8
  %cmp6483 = fcmp olt double %1528, 0.000000e+00
  br i1 %cmp6483, label %if.then.6485, label %if.else.6492

if.then.6485:                                     ; preds = %if.else.6479
  store i64 -9223372036854775808, i64* %x6469, align 8
  %1529 = load i64, i64* %x6469, align 8
  %conv6486 = sitofp i64 %1529 to double
  %1530 = load double, double* %d6480, align 8
  %cmp6487 = fcmp olt double %conv6486, %1530
  br i1 %cmp6487, label %if.then.6489, label %if.end.6491

if.then.6489:                                     ; preds = %if.then.6485
  %1531 = load double, double* %d6480, align 8
  %conv6490 = fptosi double %1531 to i64
  store i64 %conv6490, i64* %x6469, align 8
  br label %if.end.6491

if.end.6491:                                      ; preds = %if.then.6489, %if.then.6485
  br label %if.end.6499

if.else.6492:                                     ; preds = %if.else.6479
  store i64 9223372036854775807, i64* %x6469, align 8
  %1532 = load double, double* %d6480, align 8
  %1533 = load i64, i64* %x6469, align 8
  %conv6493 = sitofp i64 %1533 to double
  %cmp6494 = fcmp olt double %1532, %conv6493
  br i1 %cmp6494, label %if.then.6496, label %if.end.6498

if.then.6496:                                     ; preds = %if.else.6492
  %1534 = load double, double* %d6480, align 8
  %conv6497 = fptosi double %1534 to i64
  store i64 %conv6497, i64* %x6469, align 8
  br label %if.end.6498

if.end.6498:                                      ; preds = %if.then.6496, %if.else.6492
  br label %if.end.6499

if.end.6499:                                      ; preds = %if.end.6498, %if.end.6491
  br label %if.end.6500

if.end.6500:                                      ; preds = %if.end.6499, %if.then.6476
  %arraydecay6501 = getelementptr inbounds [1334 x i8], [1334 x i8]* %sprintf_buf, i32 0, i32 0
  %arraydecay6502 = getelementptr inbounds [9 x i8], [9 x i8]* %convspec, i32 0, i32 0
  %1535 = load i32, i32* %prec6410, align 4
  %1536 = load i64, i64* %x6469, align 8
  %call6503 = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay6501, i8* %arraydecay6502, i32 %1535, i64 %1536) #5
  %conv6504 = sext i32 %call6503 to i64
  store i64 %conv6504, i64* %sprintf_bytes, align 8
  br label %if.end.6536

if.else.6505:                                     ; preds = %if.else.6464
  %1537 = load i64, i64* %n, align 8
  %1538 = load i64*, i64** %args.addr, align 8
  %arrayidx6507 = getelementptr inbounds i64, i64* %1538, i64 %1537
  %1539 = load i64, i64* %arrayidx6507, align 8
  %and6508 = and i64 %1539, 7
  %conv6509 = trunc i64 %and6508 to i32
  %and6510 = and i32 %conv6509, -5
  %cmp6511 = icmp eq i32 %and6510, 2
  br i1 %cmp6511, label %if.then.6513, label %if.else.6516

if.then.6513:                                     ; preds = %if.else.6505
  %1540 = load i64, i64* %n, align 8
  %1541 = load i64*, i64** %args.addr, align 8
  %arrayidx6514 = getelementptr inbounds i64, i64* %1541, i64 %1540
  %1542 = load i64, i64* %arrayidx6514, align 8
  %call6515 = call i64 @XUINT(i64 %1542)
  store i64 %call6515, i64* %x6506, align 8
  br label %if.end.6531

if.else.6516:                                     ; preds = %if.else.6505
  %1543 = load i64, i64* %n, align 8
  %1544 = load i64*, i64** %args.addr, align 8
  %arrayidx6518 = getelementptr inbounds i64, i64* %1544, i64 %1543
  %1545 = load i64, i64* %arrayidx6518, align 8
  %call6519 = call double @XFLOAT_DATA(i64 %1545)
  store double %call6519, double* %d6517, align 8
  %1546 = load double, double* %d6517, align 8
  %cmp6520 = fcmp olt double %1546, 0.000000e+00
  br i1 %cmp6520, label %if.then.6522, label %if.else.6523

if.then.6522:                                     ; preds = %if.else.6516
  store i64 0, i64* %x6506, align 8
  br label %if.end.6530

if.else.6523:                                     ; preds = %if.else.6516
  store i64 -1, i64* %x6506, align 8
  %1547 = load double, double* %d6517, align 8
  %1548 = load i64, i64* %x6506, align 8
  %conv6524 = uitofp i64 %1548 to double
  %cmp6525 = fcmp olt double %1547, %conv6524
  br i1 %cmp6525, label %if.then.6527, label %if.end.6529

if.then.6527:                                     ; preds = %if.else.6523
  %1549 = load double, double* %d6517, align 8
  %conv6528 = fptoui double %1549 to i64
  store i64 %conv6528, i64* %x6506, align 8
  br label %if.end.6529

if.end.6529:                                      ; preds = %if.then.6527, %if.else.6523
  br label %if.end.6530

if.end.6530:                                      ; preds = %if.end.6529, %if.then.6522
  br label %if.end.6531

if.end.6531:                                      ; preds = %if.end.6530, %if.then.6513
  %arraydecay6532 = getelementptr inbounds [1334 x i8], [1334 x i8]* %sprintf_buf, i32 0, i32 0
  %arraydecay6533 = getelementptr inbounds [9 x i8], [9 x i8]* %convspec, i32 0, i32 0
  %1550 = load i32, i32* %prec6410, align 4
  %1551 = load i64, i64* %x6506, align 8
  %call6534 = call i32 (i8*, i8*, ...) @sprintf(i8* %arraydecay6532, i8* %arraydecay6533, i32 %1550, i64 %1551) #5
  %conv6535 = sext i32 %call6534 to i64
  store i64 %conv6535, i64* %sprintf_bytes, align 8
  br label %if.end.6536

if.end.6536:                                      ; preds = %if.end.6531, %if.end.6500
  br label %if.end.6537

if.end.6537:                                      ; preds = %if.end.6536, %if.then.6456
  br label %if.end.6538

if.end.6538:                                      ; preds = %if.end.6537, %cond.end.6446
  %1552 = load i64, i64* %precision, align 8
  %1553 = load i32, i32* %prec6410, align 4
  %conv6539 = sext i32 %1553 to i64
  %sub6540 = sub i64 %1552, %conv6539
  store i64 %sub6540, i64* %excess_precision, align 8
  store i64 0, i64* %leading_zeros, align 8
  store i64 0, i64* %trailing_zeros, align 8
  %1554 = load i64, i64* %excess_precision, align 8
  %tobool6541 = icmp ne i64 %1554, 0
  br i1 %tobool6541, label %if.then.6542, label %if.end.6587

if.then.6542:                                     ; preds = %if.end.6538
  %1555 = load i8, i8* %conversion, align 1
  %conv6543 = sext i8 %1555 to i32
  %cmp6544 = icmp eq i32 %conv6543, 101
  br i1 %cmp6544, label %if.then.6554, label %lor.lhs.false.6546

lor.lhs.false.6546:                               ; preds = %if.then.6542
  %1556 = load i8, i8* %conversion, align 1
  %conv6547 = sext i8 %1556 to i32
  %cmp6548 = icmp eq i32 %conv6547, 102
  br i1 %cmp6548, label %if.then.6554, label %lor.lhs.false.6550

lor.lhs.false.6550:                               ; preds = %lor.lhs.false.6546
  %1557 = load i8, i8* %conversion, align 1
  %conv6551 = sext i8 %1557 to i32
  %cmp6552 = icmp eq i32 %conv6551, 103
  br i1 %cmp6552, label %if.then.6554, label %if.else.6585

if.then.6554:                                     ; preds = %lor.lhs.false.6550, %lor.lhs.false.6546, %if.then.6542
  %1558 = load i8, i8* %conversion, align 1
  %conv6555 = sext i8 %1558 to i32
  %cmp6556 = icmp eq i32 %conv6555, 103
  br i1 %cmp6556, label %land.lhs.true.6558, label %lor.lhs.false.6560

land.lhs.true.6558:                               ; preds = %if.then.6554
  %1559 = load i8, i8* %sharp_flag, align 1
  %tobool6559 = trunc i8 %1559 to i1
  br i1 %tobool6559, label %lor.lhs.false.6560, label %if.then.6572

lor.lhs.false.6560:                               ; preds = %land.lhs.true.6558, %if.then.6554
  %1560 = load i64, i64* %sprintf_bytes, align 8
  %sub6561 = sub nsw i64 %1560, 1
  %arrayidx6562 = getelementptr inbounds [1334 x i8], [1334 x i8]* %sprintf_buf, i32 0, i64 %sub6561
  %1561 = load i8, i8* %arrayidx6562, align 1
  %conv6563 = sext i8 %1561 to i32
  %cmp6564 = icmp sle i32 48, %conv6563
  br i1 %cmp6564, label %land.lhs.true.6566, label %if.then.6572

land.lhs.true.6566:                               ; preds = %lor.lhs.false.6560
  %1562 = load i64, i64* %sprintf_bytes, align 8
  %sub6567 = sub nsw i64 %1562, 1
  %arrayidx6568 = getelementptr inbounds [1334 x i8], [1334 x i8]* %sprintf_buf, i32 0, i64 %sub6567
  %1563 = load i8, i8* %arrayidx6568, align 1
  %conv6569 = sext i8 %1563 to i32
  %cmp6570 = icmp sle i32 %conv6569, 57
  br i1 %cmp6570, label %if.else.6573, label %if.then.6572

if.then.6572:                                     ; preds = %land.lhs.true.6566, %lor.lhs.false.6560, %land.lhs.true.6558
  store i64 0, i64* %excess_precision, align 8
  br label %if.end.6584

if.else.6573:                                     ; preds = %land.lhs.true.6566
  %1564 = load i8, i8* %conversion, align 1
  %conv6574 = sext i8 %1564 to i32
  %cmp6575 = icmp eq i32 %conv6574, 103
  br i1 %cmp6575, label %if.then.6577, label %if.end.6583

if.then.6577:                                     ; preds = %if.else.6573
  %arraydecay6578 = getelementptr inbounds [1334 x i8], [1334 x i8]* %sprintf_buf, i32 0, i32 0
  %call6579 = call i8* @strchr(i8* %arraydecay6578, i32 46) #8
  store i8* %call6579, i8** %dot, align 8
  %1565 = load i8*, i8** %dot, align 8
  %tobool6580 = icmp ne i8* %1565, null
  br i1 %tobool6580, label %if.end.6582, label %if.then.6581

if.then.6581:                                     ; preds = %if.then.6577
  store i64 0, i64* %excess_precision, align 8
  br label %if.end.6582

if.end.6582:                                      ; preds = %if.then.6581, %if.then.6577
  br label %if.end.6583

if.end.6583:                                      ; preds = %if.end.6582, %if.else.6573
  br label %if.end.6584

if.end.6584:                                      ; preds = %if.end.6583, %if.then.6572
  %1566 = load i64, i64* %excess_precision, align 8
  store i64 %1566, i64* %trailing_zeros, align 8
  br label %if.end.6586

if.else.6585:                                     ; preds = %lor.lhs.false.6550
  %1567 = load i64, i64* %excess_precision, align 8
  store i64 %1567, i64* %leading_zeros, align 8
  br label %if.end.6586

if.end.6586:                                      ; preds = %if.else.6585, %if.end.6584
  br label %if.end.6587

if.end.6587:                                      ; preds = %if.end.6586, %if.end.6538
  %1568 = load i64, i64* %sprintf_bytes, align 8
  %1569 = load i64, i64* %excess_precision, align 8
  %add6588 = add i64 %1568, %1569
  store i64 %add6588, i64* %numwidth, align 8
  %1570 = load i64, i64* %numwidth, align 8
  %1571 = load i64, i64* %field_width, align 8
  %cmp6590 = icmp ult i64 %1570, %1571
  br i1 %cmp6590, label %cond.true.6592, label %cond.false.6594

cond.true.6592:                                   ; preds = %if.end.6587
  %1572 = load i64, i64* %field_width, align 8
  %1573 = load i64, i64* %numwidth, align 8
  %sub6593 = sub i64 %1572, %1573
  br label %cond.end.6595

cond.false.6594:                                  ; preds = %if.end.6587
  br label %cond.end.6595

cond.end.6595:                                    ; preds = %cond.false.6594, %cond.true.6592
  %cond6596 = phi i64 [ %sub6593, %cond.true.6592 ], [ 0, %cond.false.6594 ]
  store i64 %cond6596, i64* %padding6589, align 8
  %1574 = load i64, i64* %max_bufsize, align 8
  %1575 = load i64, i64* %sprintf_bytes, align 8
  %sub6597 = sub nsw i64 %1574, %1575
  %1576 = load i64, i64* %excess_precision, align 8
  %cmp6598 = icmp ule i64 %sub6597, %1576
  br i1 %cmp6598, label %if.then.6604, label %lor.lhs.false.6600

lor.lhs.false.6600:                               ; preds = %cond.end.6595
  %1577 = load i64, i64* %max_bufsize, align 8
  %1578 = load i64, i64* %padding6589, align 8
  %sub6601 = sub nsw i64 %1577, %1578
  %1579 = load i64, i64* %numwidth, align 8
  %cmp6602 = icmp ule i64 %sub6601, %1579
  br i1 %cmp6602, label %if.then.6604, label %if.end.6605

if.then.6604:                                     ; preds = %lor.lhs.false.6600, %cond.end.6595
  call void @string_overflow() #9
  unreachable

if.end.6605:                                      ; preds = %lor.lhs.false.6600
  %1580 = load i64, i64* %numwidth, align 8
  %1581 = load i64, i64* %padding6589, align 8
  %add6606 = add i64 %1580, %1581
  store i64 %add6606, i64* %convbytes, align 8
  %1582 = load i64, i64* %convbytes, align 8
  %1583 = load i8*, i8** %buf, align 8
  %1584 = load i64, i64* %bufsize, align 8
  %add.ptr6607 = getelementptr inbounds i8, i8* %1583, i64 %1584
  %1585 = load i8*, i8** %p, align 8
  %sub.ptr.lhs.cast6608 = ptrtoint i8* %add.ptr6607 to i64
  %sub.ptr.rhs.cast6609 = ptrtoint i8* %1585 to i64
  %sub.ptr.sub6610 = sub i64 %sub.ptr.lhs.cast6608, %sub.ptr.rhs.cast6609
  %cmp6611 = icmp sle i64 %1582, %sub.ptr.sub6610
  br i1 %cmp6611, label %if.then.6613, label %if.end.6734

if.then.6613:                                     ; preds = %if.end.6605
  %arraydecay6614 = getelementptr inbounds [1334 x i8], [1334 x i8]* %sprintf_buf, i32 0, i32 0
  store i8* %arraydecay6614, i8** %src, align 8
  %1586 = load i8*, i8** %src, align 8
  %arrayidx6615 = getelementptr inbounds i8, i8* %1586, i64 0
  %1587 = load i8, i8* %arrayidx6615, align 1
  store i8 %1587, i8* %src0, align 1
  store i32 0, i32* %exponent_bytes, align 4
  %1588 = load i8, i8* %src0, align 1
  %conv6616 = sext i8 %1588 to i32
  %cmp6617 = icmp eq i32 %conv6616, 45
  br i1 %cmp6617, label %lor.end, label %lor.lhs.false.6619

lor.lhs.false.6619:                               ; preds = %if.then.6613
  %1589 = load i8, i8* %src0, align 1
  %conv6620 = sext i8 %1589 to i32
  %cmp6621 = icmp eq i32 %conv6620, 43
  br i1 %cmp6621, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false.6619
  %1590 = load i8, i8* %src0, align 1
  %conv6623 = sext i8 %1590 to i32
  %cmp6624 = icmp eq i32 %conv6623, 32
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false.6619, %if.then.6613
  %1591 = phi i1 [ true, %lor.lhs.false.6619 ], [ true, %if.then.6613 ], [ %cmp6624, %lor.rhs ]
  %frombool6626 = zext i1 %1591 to i8
  store i8 %frombool6626, i8* %signedp, align 1
  %1592 = load i8, i8* %zero_flag, align 1
  %tobool6627 = trunc i8 %1592 to i1
  br i1 %tobool6627, label %land.lhs.true.6629, label %if.end.6672

land.lhs.true.6629:                               ; preds = %lor.end
  %1593 = load i8, i8* %signedp, align 1
  %tobool6630 = trunc i8 %1593 to i1
  %idxprom = zext i1 %tobool6630 to i64
  %1594 = load i8*, i8** %src, align 8
  %arrayidx6631 = getelementptr inbounds i8, i8* %1594, i64 %idxprom
  %1595 = load i8, i8* %arrayidx6631, align 1
  %conv6632 = sext i8 %1595 to i32
  %cmp6633 = icmp sge i32 %conv6632, 48
  br i1 %cmp6633, label %land.lhs.true.6635, label %lor.lhs.false.6642

land.lhs.true.6635:                               ; preds = %land.lhs.true.6629
  %1596 = load i8, i8* %signedp, align 1
  %tobool6636 = trunc i8 %1596 to i1
  %idxprom6637 = zext i1 %tobool6636 to i64
  %1597 = load i8*, i8** %src, align 8
  %arrayidx6638 = getelementptr inbounds i8, i8* %1597, i64 %idxprom6637
  %1598 = load i8, i8* %arrayidx6638, align 1
  %conv6639 = sext i8 %1598 to i32
  %cmp6640 = icmp sle i32 %conv6639, 57
  br i1 %cmp6640, label %if.then.6670, label %lor.lhs.false.6642

lor.lhs.false.6642:                               ; preds = %land.lhs.true.6635, %land.lhs.true.6629
  %1599 = load i8, i8* %signedp, align 1
  %tobool6643 = trunc i8 %1599 to i1
  %idxprom6644 = zext i1 %tobool6643 to i64
  %1600 = load i8*, i8** %src, align 8
  %arrayidx6645 = getelementptr inbounds i8, i8* %1600, i64 %idxprom6644
  %1601 = load i8, i8* %arrayidx6645, align 1
  %conv6646 = sext i8 %1601 to i32
  %cmp6647 = icmp sge i32 %conv6646, 97
  br i1 %cmp6647, label %land.lhs.true.6649, label %lor.lhs.false.6656

land.lhs.true.6649:                               ; preds = %lor.lhs.false.6642
  %1602 = load i8, i8* %signedp, align 1
  %tobool6650 = trunc i8 %1602 to i1
  %idxprom6651 = zext i1 %tobool6650 to i64
  %1603 = load i8*, i8** %src, align 8
  %arrayidx6652 = getelementptr inbounds i8, i8* %1603, i64 %idxprom6651
  %1604 = load i8, i8* %arrayidx6652, align 1
  %conv6653 = sext i8 %1604 to i32
  %cmp6654 = icmp sle i32 %conv6653, 102
  br i1 %cmp6654, label %if.then.6670, label %lor.lhs.false.6656

lor.lhs.false.6656:                               ; preds = %land.lhs.true.6649, %lor.lhs.false.6642
  %1605 = load i8, i8* %signedp, align 1
  %tobool6657 = trunc i8 %1605 to i1
  %idxprom6658 = zext i1 %tobool6657 to i64
  %1606 = load i8*, i8** %src, align 8
  %arrayidx6659 = getelementptr inbounds i8, i8* %1606, i64 %idxprom6658
  %1607 = load i8, i8* %arrayidx6659, align 1
  %conv6660 = sext i8 %1607 to i32
  %cmp6661 = icmp sge i32 %conv6660, 65
  br i1 %cmp6661, label %land.lhs.true.6663, label %if.end.6672

land.lhs.true.6663:                               ; preds = %lor.lhs.false.6656
  %1608 = load i8, i8* %signedp, align 1
  %tobool6664 = trunc i8 %1608 to i1
  %idxprom6665 = zext i1 %tobool6664 to i64
  %1609 = load i8*, i8** %src, align 8
  %arrayidx6666 = getelementptr inbounds i8, i8* %1609, i64 %idxprom6665
  %1610 = load i8, i8* %arrayidx6666, align 1
  %conv6667 = sext i8 %1610 to i32
  %cmp6668 = icmp sle i32 %conv6667, 70
  br i1 %cmp6668, label %if.then.6670, label %if.end.6672

if.then.6670:                                     ; preds = %land.lhs.true.6663, %land.lhs.true.6649, %land.lhs.true.6635
  %1611 = load i64, i64* %padding6589, align 8
  %1612 = load i64, i64* %leading_zeros, align 8
  %add6671 = add i64 %1612, %1611
  store i64 %add6671, i64* %leading_zeros, align 8
  store i64 0, i64* %padding6589, align 8
  br label %if.end.6672

if.end.6672:                                      ; preds = %if.then.6670, %land.lhs.true.6663, %lor.lhs.false.6656, %lor.end
  %1613 = load i64, i64* %excess_precision, align 8
  %tobool6673 = icmp ne i64 %1613, 0
  br i1 %tobool6673, label %land.lhs.true.6674, label %if.end.6692

land.lhs.true.6674:                               ; preds = %if.end.6672
  %1614 = load i8, i8* %conversion, align 1
  %conv6675 = sext i8 %1614 to i32
  %cmp6676 = icmp eq i32 %conv6675, 101
  br i1 %cmp6676, label %if.then.6682, label %lor.lhs.false.6678

lor.lhs.false.6678:                               ; preds = %land.lhs.true.6674
  %1615 = load i8, i8* %conversion, align 1
  %conv6679 = sext i8 %1615 to i32
  %cmp6680 = icmp eq i32 %conv6679, 103
  br i1 %cmp6680, label %if.then.6682, label %if.end.6692

if.then.6682:                                     ; preds = %lor.lhs.false.6678, %land.lhs.true.6674
  %1616 = load i8*, i8** %src, align 8
  %call6683 = call i8* @strchr(i8* %1616, i32 101) #8
  store i8* %call6683, i8** %e, align 8
  %1617 = load i8*, i8** %e, align 8
  %tobool6684 = icmp ne i8* %1617, null
  br i1 %tobool6684, label %if.then.6685, label %if.end.6691

if.then.6685:                                     ; preds = %if.then.6682
  %1618 = load i8*, i8** %src, align 8
  %1619 = load i64, i64* %sprintf_bytes, align 8
  %add.ptr6686 = getelementptr inbounds i8, i8* %1618, i64 %1619
  %1620 = load i8*, i8** %e, align 8
  %sub.ptr.lhs.cast6687 = ptrtoint i8* %add.ptr6686 to i64
  %sub.ptr.rhs.cast6688 = ptrtoint i8* %1620 to i64
  %sub.ptr.sub6689 = sub i64 %sub.ptr.lhs.cast6687, %sub.ptr.rhs.cast6688
  %conv6690 = trunc i64 %sub.ptr.sub6689 to i32
  store i32 %conv6690, i32* %exponent_bytes, align 4
  br label %if.end.6691

if.end.6691:                                      ; preds = %if.then.6685, %if.then.6682
  br label %if.end.6692

if.end.6692:                                      ; preds = %if.end.6691, %lor.lhs.false.6678, %if.end.6672
  %1621 = load i8, i8* %minus_flag, align 1
  %tobool6693 = trunc i8 %1621 to i1
  br i1 %tobool6693, label %if.end.6697, label %if.then.6694

if.then.6694:                                     ; preds = %if.end.6692
  %1622 = load i8*, i8** %p, align 8
  %1623 = load i64, i64* %padding6589, align 8
  call void @llvm.memset.p0i8.i64(i8* %1622, i8 32, i64 %1623, i32 1, i1 false)
  %1624 = load i64, i64* %padding6589, align 8
  %1625 = load i8*, i8** %p, align 8
  %add.ptr6695 = getelementptr inbounds i8, i8* %1625, i64 %1624
  store i8* %add.ptr6695, i8** %p, align 8
  %1626 = load i64, i64* %padding6589, align 8
  %1627 = load i64, i64* %nchars, align 8
  %add6696 = add nsw i64 %1627, %1626
  store i64 %add6696, i64* %nchars, align 8
  br label %if.end.6697

if.end.6697:                                      ; preds = %if.then.6694, %if.end.6692
  %1628 = load i8, i8* %src0, align 1
  %1629 = load i8*, i8** %p, align 8
  store i8 %1628, i8* %1629, align 1
  %1630 = load i8, i8* %signedp, align 1
  %tobool6698 = trunc i8 %1630 to i1
  %conv6699 = zext i1 %tobool6698 to i32
  %1631 = load i8*, i8** %src, align 8
  %idx.ext6700 = sext i32 %conv6699 to i64
  %add.ptr6701 = getelementptr inbounds i8, i8* %1631, i64 %idx.ext6700
  store i8* %add.ptr6701, i8** %src, align 8
  %1632 = load i8, i8* %signedp, align 1
  %tobool6702 = trunc i8 %1632 to i1
  %conv6703 = zext i1 %tobool6702 to i32
  %1633 = load i8*, i8** %p, align 8
  %idx.ext6704 = sext i32 %conv6703 to i64
  %add.ptr6705 = getelementptr inbounds i8, i8* %1633, i64 %idx.ext6704
  store i8* %add.ptr6705, i8** %p, align 8
  %1634 = load i8*, i8** %p, align 8
  %1635 = load i64, i64* %leading_zeros, align 8
  call void @llvm.memset.p0i8.i64(i8* %1634, i8 48, i64 %1635, i32 1, i1 false)
  %1636 = load i64, i64* %leading_zeros, align 8
  %1637 = load i8*, i8** %p, align 8
  %add.ptr6706 = getelementptr inbounds i8, i8* %1637, i64 %1636
  store i8* %add.ptr6706, i8** %p, align 8
  %1638 = load i64, i64* %sprintf_bytes, align 8
  %1639 = load i8, i8* %signedp, align 1
  %tobool6707 = trunc i8 %1639 to i1
  %conv6708 = zext i1 %tobool6707 to i64
  %sub6709 = sub nsw i64 %1638, %conv6708
  %1640 = load i32, i32* %exponent_bytes, align 4
  %conv6710 = sext i32 %1640 to i64
  %sub6711 = sub nsw i64 %sub6709, %conv6710
  %conv6712 = trunc i64 %sub6711 to i32
  store i32 %conv6712, i32* %significand_bytes, align 4
  %1641 = load i8*, i8** %p, align 8
  %1642 = load i8*, i8** %src, align 8
  %1643 = load i32, i32* %significand_bytes, align 4
  %conv6713 = sext i32 %1643 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1641, i8* %1642, i64 %conv6713, i32 1, i1 false)
  %1644 = load i32, i32* %significand_bytes, align 4
  %1645 = load i8*, i8** %p, align 8
  %idx.ext6714 = sext i32 %1644 to i64
  %add.ptr6715 = getelementptr inbounds i8, i8* %1645, i64 %idx.ext6714
  store i8* %add.ptr6715, i8** %p, align 8
  %1646 = load i32, i32* %significand_bytes, align 4
  %1647 = load i8*, i8** %src, align 8
  %idx.ext6716 = sext i32 %1646 to i64
  %add.ptr6717 = getelementptr inbounds i8, i8* %1647, i64 %idx.ext6716
  store i8* %add.ptr6717, i8** %src, align 8
  %1648 = load i8*, i8** %p, align 8
  %1649 = load i64, i64* %trailing_zeros, align 8
  call void @llvm.memset.p0i8.i64(i8* %1648, i8 48, i64 %1649, i32 1, i1 false)
  %1650 = load i64, i64* %trailing_zeros, align 8
  %1651 = load i8*, i8** %p, align 8
  %add.ptr6718 = getelementptr inbounds i8, i8* %1651, i64 %1650
  store i8* %add.ptr6718, i8** %p, align 8
  %1652 = load i8*, i8** %p, align 8
  %1653 = load i8*, i8** %src, align 8
  %1654 = load i32, i32* %exponent_bytes, align 4
  %conv6719 = sext i32 %1654 to i64
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1652, i8* %1653, i64 %conv6719, i32 1, i1 false)
  %1655 = load i32, i32* %exponent_bytes, align 4
  %1656 = load i8*, i8** %p, align 8
  %idx.ext6720 = sext i32 %1655 to i64
  %add.ptr6721 = getelementptr inbounds i8, i8* %1656, i64 %idx.ext6720
  store i8* %add.ptr6721, i8** %p, align 8
  %1657 = load i64, i64* %nchars, align 8
  %1658 = load i64, i64* %n, align 8
  %1659 = load %struct.info*, %struct.info** %info, align 8
  %arrayidx6722 = getelementptr inbounds %struct.info, %struct.info* %1659, i64 %1658
  %start6723 = getelementptr inbounds %struct.info, %struct.info* %arrayidx6722, i32 0, i32 0
  store i64 %1657, i64* %start6723, align 8
  %1660 = load i64, i64* %leading_zeros, align 8
  %1661 = load i64, i64* %sprintf_bytes, align 8
  %add6724 = add i64 %1660, %1661
  %1662 = load i64, i64* %trailing_zeros, align 8
  %add6725 = add i64 %add6724, %1662
  %1663 = load i64, i64* %nchars, align 8
  %add6726 = add i64 %1663, %add6725
  store i64 %add6726, i64* %nchars, align 8
  %1664 = load i64, i64* %nchars, align 8
  %1665 = load i64, i64* %n, align 8
  %1666 = load %struct.info*, %struct.info** %info, align 8
  %arrayidx6727 = getelementptr inbounds %struct.info, %struct.info* %1666, i64 %1665
  %end6728 = getelementptr inbounds %struct.info, %struct.info* %arrayidx6727, i32 0, i32 1
  store i64 %1664, i64* %end6728, align 8
  %1667 = load i8, i8* %minus_flag, align 1
  %tobool6729 = trunc i8 %1667 to i1
  br i1 %tobool6729, label %if.then.6730, label %if.end.6733

if.then.6730:                                     ; preds = %if.end.6697
  %1668 = load i8*, i8** %p, align 8
  %1669 = load i64, i64* %padding6589, align 8
  call void @llvm.memset.p0i8.i64(i8* %1668, i8 32, i64 %1669, i32 1, i1 false)
  %1670 = load i64, i64* %padding6589, align 8
  %1671 = load i8*, i8** %p, align 8
  %add.ptr6731 = getelementptr inbounds i8, i8* %1671, i64 %1670
  store i8* %add.ptr6731, i8** %p, align 8
  %1672 = load i64, i64* %padding6589, align 8
  %1673 = load i64, i64* %nchars, align 8
  %add6732 = add nsw i64 %1673, %1672
  store i64 %add6732, i64* %nchars, align 8
  br label %if.end.6733

if.end.6733:                                      ; preds = %if.then.6730, %if.end.6697
  br label %while.cond

if.end.6734:                                      ; preds = %if.end.6605
  br label %if.end.6735

if.end.6735:                                      ; preds = %if.end.6734
  br label %if.end.6736

if.end.6736:                                      ; preds = %if.end.6735
  br label %if.end.6737

if.end.6737:                                      ; preds = %if.end.6736, %if.end.6240
  br label %if.end.6945

if.else.6738:                                     ; preds = %while.body
  %1674 = load i8, i8* %format_char, align 1
  %conv6739 = zext i8 %1674 to i32
  %cmp6740 = icmp eq i32 %conv6739, 96
  br i1 %cmp6740, label %land.lhs.true.6746, label %lor.lhs.false.6742

lor.lhs.false.6742:                               ; preds = %if.else.6738
  %1675 = load i8, i8* %format_char, align 1
  %conv6743 = zext i8 %1675 to i32
  %cmp6744 = icmp eq i32 %conv6743, 39
  br i1 %cmp6744, label %land.lhs.true.6746, label %if.else.6757

land.lhs.true.6746:                               ; preds = %lor.lhs.false.6742, %if.else.6738
  %1676 = load i32, i32* %quoting_style, align 4
  %cmp6747 = icmp eq i32 %1676, 0
  br i1 %cmp6747, label %if.then.6749, label %if.else.6757

if.then.6749:                                     ; preds = %land.lhs.true.6746
  %1677 = load i8, i8* %multibyte, align 1
  %tobool6750 = trunc i8 %1677 to i1
  br i1 %tobool6750, label %if.end.6752, label %if.then.6751

if.then.6751:                                     ; preds = %if.then.6749
  store i8 1, i8* %multibyte, align 1
  br label %retry

if.end.6752:                                      ; preds = %if.then.6749
  %1678 = load i8, i8* %format_char, align 1
  %conv6753 = zext i8 %1678 to i32
  %cmp6754 = icmp eq i32 %conv6753, 96
  %cond6756 = select i1 %cmp6754, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.42, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.43, i32 0, i32 0)
  store i8* %cond6756, i8** %convsrc, align 8
  store i64 3, i64* %convbytes, align 8
  br label %if.end.6934

if.else.6757:                                     ; preds = %land.lhs.true.6746, %lor.lhs.false.6742
  %1679 = load i8, i8* %format_char, align 1
  %conv6758 = zext i8 %1679 to i32
  %cmp6759 = icmp eq i32 %conv6758, 96
  br i1 %cmp6759, label %land.lhs.true.6761, label %if.else.6765

land.lhs.true.6761:                               ; preds = %if.else.6757
  %1680 = load i32, i32* %quoting_style, align 4
  %cmp6762 = icmp eq i32 %1680, 2
  br i1 %cmp6762, label %if.then.6764, label %if.else.6765

if.then.6764:                                     ; preds = %land.lhs.true.6761
  store i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.44, i32 0, i32 0), i8** %convsrc, align 8
  br label %if.end.6933

if.else.6765:                                     ; preds = %land.lhs.true.6761, %if.else.6757
  %1681 = load i8, i8* %format_char, align 1
  %conv6766 = zext i8 %1681 to i32
  %cmp6767 = icmp eq i32 %conv6766, 226
  br i1 %cmp6767, label %land.lhs.true.6769, label %if.else.6806

land.lhs.true.6769:                               ; preds = %if.else.6765
  %1682 = load i32, i32* %quoting_style, align 4
  %cmp6770 = icmp slt i32 0, %1682
  br i1 %cmp6770, label %land.lhs.true.6772, label %if.else.6806

land.lhs.true.6772:                               ; preds = %land.lhs.true.6769
  %1683 = load i8, i8* %multibyte_format, align 1
  %tobool6773 = trunc i8 %1683 to i1
  br i1 %tobool6773, label %land.lhs.true.6775, label %if.else.6806

land.lhs.true.6775:                               ; preds = %land.lhs.true.6772
  %1684 = load i8*, i8** %format, align 8
  %arrayidx6776 = getelementptr inbounds i8, i8* %1684, i64 0
  %1685 = load i8, i8* %arrayidx6776, align 1
  %conv6777 = zext i8 %1685 to i32
  %cmp6778 = icmp eq i32 %conv6777, 128
  br i1 %cmp6778, label %land.lhs.true.6780, label %if.else.6806

land.lhs.true.6780:                               ; preds = %land.lhs.true.6775
  %1686 = load i8*, i8** %format, align 8
  %arrayidx6781 = getelementptr inbounds i8, i8* %1686, i64 1
  %1687 = load i8, i8* %arrayidx6781, align 1
  %conv6782 = zext i8 %1687 to i32
  %cmp6783 = icmp eq i32 %conv6782, 152
  br i1 %cmp6783, label %if.then.6790, label %lor.lhs.false.6785

lor.lhs.false.6785:                               ; preds = %land.lhs.true.6780
  %1688 = load i8*, i8** %format, align 8
  %arrayidx6786 = getelementptr inbounds i8, i8* %1688, i64 1
  %1689 = load i8, i8* %arrayidx6786, align 1
  %conv6787 = zext i8 %1689 to i32
  %cmp6788 = icmp eq i32 %conv6787, 153
  br i1 %cmp6788, label %if.then.6790, label %if.else.6806

if.then.6790:                                     ; preds = %lor.lhs.false.6785, %land.lhs.true.6780
  %1690 = load i8*, i8** %format, align 8
  %arrayidx6791 = getelementptr inbounds i8, i8* %1690, i64 1
  %1691 = load i8, i8* %arrayidx6791, align 1
  %conv6792 = zext i8 %1691 to i32
  %cmp6793 = icmp eq i32 %conv6792, 152
  br i1 %cmp6793, label %land.rhs.6795, label %land.end.6798

land.rhs.6795:                                    ; preds = %if.then.6790
  %1692 = load i32, i32* %quoting_style, align 4
  %cmp6796 = icmp eq i32 %1692, 1
  br label %land.end.6798

land.end.6798:                                    ; preds = %land.rhs.6795, %if.then.6790
  %1693 = phi i1 [ false, %if.then.6790 ], [ %cmp6796, %land.rhs.6795 ]
  %cond6799 = select i1 %1693, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.45, i32 0, i32 0), i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.44, i32 0, i32 0)
  store i8* %cond6799, i8** %convsrc, align 8
  %1694 = load i8*, i8** %format, align 8
  %add.ptr6800 = getelementptr inbounds i8, i8* %1694, i64 2
  store i8* %add.ptr6800, i8** %format, align 8
  %1695 = load i8*, i8** %format0, align 8
  %add.ptr6801 = getelementptr inbounds i8, i8* %1695, i64 1
  %1696 = load i8*, i8** %format_start, align 8
  %sub.ptr.lhs.cast6802 = ptrtoint i8* %add.ptr6801 to i64
  %sub.ptr.rhs.cast6803 = ptrtoint i8* %1696 to i64
  %sub.ptr.sub6804 = sub i64 %sub.ptr.lhs.cast6802, %sub.ptr.rhs.cast6803
  %1697 = load i8*, i8** %discarded, align 8
  %arrayidx6805 = getelementptr inbounds i8, i8* %1697, i64 %sub.ptr.sub6804
  call void @llvm.memset.p0i8.i64(i8* %arrayidx6805, i8 2, i64 2, i32 1, i1 false)
  br label %if.end.6932

if.else.6806:                                     ; preds = %lor.lhs.false.6785, %land.lhs.true.6775, %land.lhs.true.6772, %land.lhs.true.6769, %if.else.6765
  %1698 = load i8, i8* %multibyte_format, align 1
  %tobool6807 = trunc i8 %1698 to i1
  br i1 %tobool6807, label %if.then.6808, label %if.else.6847

if.then.6808:                                     ; preds = %if.else.6806
  %1699 = load i8*, i8** %p, align 8
  %1700 = load i8*, i8** %buf, align 8
  %cmp6809 = icmp ugt i8* %1699, %1700
  br i1 %cmp6809, label %land.lhs.true.6811, label %if.end.6830

land.lhs.true.6811:                               ; preds = %if.then.6808
  br i1 true, label %cond.true.6812, label %cond.false.6818

cond.true.6812:                                   ; preds = %land.lhs.true.6811
  %1701 = load i8*, i8** %p, align 8
  %add.ptr6813 = getelementptr inbounds i8, i8* %1701, i64 -1
  %1702 = load i8, i8* %add.ptr6813, align 1
  %conv6814 = zext i8 %1702 to i32
  %add6815 = add i32 %conv6814, 0
  %cmp6816 = icmp ult i32 %add6815, 128
  br i1 %cmp6816, label %if.end.6830, label %land.lhs.true.6824

cond.false.6818:                                  ; preds = %land.lhs.true.6811
  %1703 = load i8*, i8** %p, align 8
  %add.ptr6819 = getelementptr inbounds i8, i8* %1703, i64 -1
  %1704 = load i8, i8* %add.ptr6819, align 1
  %conv6820 = zext i8 %1704 to i64
  %add6821 = add i64 %conv6820, 0
  %cmp6822 = icmp ult i64 %add6821, 128
  br i1 %cmp6822, label %if.end.6830, label %land.lhs.true.6824

land.lhs.true.6824:                               ; preds = %cond.false.6818, %cond.true.6812
  %1705 = load i8, i8* %format_char, align 1
  %conv6825 = zext i8 %1705 to i32
  %and6826 = and i32 %conv6825, 192
  %cmp6827 = icmp ne i32 %and6826, 128
  br i1 %cmp6827, label %if.end.6830, label %if.then.6829

if.then.6829:                                     ; preds = %land.lhs.true.6824
  store i8 1, i8* %maybe_combine_byte, align 1
  br label %if.end.6830

if.end.6830:                                      ; preds = %if.then.6829, %land.lhs.true.6824, %cond.false.6818, %cond.true.6812, %if.then.6808
  br label %while.cond.6831

while.cond.6831:                                  ; preds = %while.body.6836, %if.end.6830
  %1706 = load i8*, i8** %format, align 8
  %1707 = load i8, i8* %1706, align 1
  %conv6832 = sext i8 %1707 to i32
  %and6833 = and i32 %conv6832, 192
  %cmp6834 = icmp ne i32 %and6833, 128
  %lnot = xor i1 %cmp6834, true
  br i1 %lnot, label %while.body.6836, label %while.end

while.body.6836:                                  ; preds = %while.cond.6831
  %1708 = load i8*, i8** %format, align 8
  %incdec.ptr6837 = getelementptr inbounds i8, i8* %1708, i32 1
  store i8* %incdec.ptr6837, i8** %format, align 8
  br label %while.cond.6831

while.end:                                        ; preds = %while.cond.6831
  %1709 = load i8*, i8** %format, align 8
  %1710 = load i8*, i8** %format0, align 8
  %sub.ptr.lhs.cast6838 = ptrtoint i8* %1709 to i64
  %sub.ptr.rhs.cast6839 = ptrtoint i8* %1710 to i64
  %sub.ptr.sub6840 = sub i64 %sub.ptr.lhs.cast6838, %sub.ptr.rhs.cast6839
  store i64 %sub.ptr.sub6840, i64* %convbytes, align 8
  %1711 = load i8*, i8** %format0, align 8
  %add.ptr6841 = getelementptr inbounds i8, i8* %1711, i64 1
  %1712 = load i8*, i8** %format_start, align 8
  %sub.ptr.lhs.cast6842 = ptrtoint i8* %add.ptr6841 to i64
  %sub.ptr.rhs.cast6843 = ptrtoint i8* %1712 to i64
  %sub.ptr.sub6844 = sub i64 %sub.ptr.lhs.cast6842, %sub.ptr.rhs.cast6843
  %1713 = load i8*, i8** %discarded, align 8
  %arrayidx6845 = getelementptr inbounds i8, i8* %1713, i64 %sub.ptr.sub6844
  %1714 = load i64, i64* %convbytes, align 8
  %sub6846 = sub nsw i64 %1714, 1
  call void @llvm.memset.p0i8.i64(i8* %arrayidx6845, i8 2, i64 %sub6846, i32 1, i1 false)
  br label %if.end.6931

if.else.6847:                                     ; preds = %if.else.6806
  %1715 = load i8, i8* %multibyte, align 1
  %tobool6848 = trunc i8 %1715 to i1
  br i1 %tobool6848, label %land.lhs.true.6850, label %if.end.6930

land.lhs.true.6850:                               ; preds = %if.else.6847
  br i1 true, label %cond.true.6851, label %cond.false.6856

cond.true.6851:                                   ; preds = %land.lhs.true.6850
  %1716 = load i8, i8* %format_char, align 1
  %conv6852 = zext i8 %1716 to i32
  %add6853 = add i32 %conv6852, 0
  %cmp6854 = icmp ult i32 %add6853, 128
  br i1 %cmp6854, label %if.end.6930, label %if.then.6861

cond.false.6856:                                  ; preds = %land.lhs.true.6850
  %1717 = load i8, i8* %format_char, align 1
  %conv6857 = zext i8 %1717 to i64
  %add6858 = add i64 %conv6857, 0
  %cmp6859 = icmp ult i64 %add6858, 128
  br i1 %cmp6859, label %if.end.6930, label %if.then.6861

if.then.6861:                                     ; preds = %cond.false.6856, %cond.true.6851
  %1718 = load i8, i8* %format_char, align 1
  %conv6862 = zext i8 %1718 to i32
  %add6863 = add nsw i32 %conv6862, 4194048
  store i32 %add6863, i32* %c, align 4
  br i1 true, label %cond.true.6864, label %cond.false.6868

cond.true.6864:                                   ; preds = %if.then.6861
  %1719 = load i32, i32* %c, align 4
  %add6865 = add i32 %1719, 0
  %cmp6866 = icmp ule i32 %add6865, 127
  br i1 %cmp6866, label %cond.true.6873, label %cond.false.6876

cond.false.6868:                                  ; preds = %if.then.6861
  %1720 = load i32, i32* %c, align 4
  %conv6869 = sext i32 %1720 to i64
  %add6870 = add i64 %conv6869, 0
  %cmp6871 = icmp ule i64 %add6870, 127
  br i1 %cmp6871, label %cond.true.6873, label %cond.false.6876

cond.true.6873:                                   ; preds = %cond.false.6868, %cond.true.6864
  %1721 = load i32, i32* %c, align 4
  %conv6874 = trunc i32 %1721 to i8
  %arrayidx6875 = getelementptr inbounds [5 x i8], [5 x i8]* %str, i32 0, i64 0
  store i8 %conv6874, i8* %arrayidx6875, align 1
  br label %cond.end.6926

cond.false.6876:                                  ; preds = %cond.false.6868, %cond.true.6864
  br i1 true, label %cond.true.6877, label %cond.false.6881

cond.true.6877:                                   ; preds = %cond.false.6876
  %1722 = load i32, i32* %c, align 4
  %add6878 = add i32 %1722, 0
  %cmp6879 = icmp ule i32 %add6878, 2047
  br i1 %cmp6879, label %cond.true.6886, label %cond.false.6895

cond.false.6881:                                  ; preds = %cond.false.6876
  %1723 = load i32, i32* %c, align 4
  %conv6882 = sext i32 %1723 to i64
  %add6883 = add i64 %conv6882, 0
  %cmp6884 = icmp ule i64 %add6883, 2047
  br i1 %cmp6884, label %cond.true.6886, label %cond.false.6895

cond.true.6886:                                   ; preds = %cond.false.6881, %cond.true.6877
  %1724 = load i32, i32* %c, align 4
  %shr6887 = ashr i32 %1724, 6
  %or6888 = or i32 192, %shr6887
  %conv6889 = trunc i32 %or6888 to i8
  %arrayidx6890 = getelementptr inbounds [5 x i8], [5 x i8]* %str, i32 0, i64 0
  store i8 %conv6889, i8* %arrayidx6890, align 1
  %1725 = load i32, i32* %c, align 4
  %and6891 = and i32 %1725, 63
  %or6892 = or i32 128, %and6891
  %conv6893 = trunc i32 %or6892 to i8
  %arrayidx6894 = getelementptr inbounds [5 x i8], [5 x i8]* %str, i32 0, i64 1
  store i8 %conv6893, i8* %arrayidx6894, align 1
  br label %cond.end.6924

cond.false.6895:                                  ; preds = %cond.false.6881, %cond.true.6877
  br i1 true, label %cond.true.6896, label %cond.false.6900

cond.true.6896:                                   ; preds = %cond.false.6895
  %1726 = load i32, i32* %c, align 4
  %add6897 = add i32 %1726, 0
  %cmp6898 = icmp ule i32 %add6897, 65535
  br i1 %cmp6898, label %cond.true.6905, label %cond.false.6919

cond.false.6900:                                  ; preds = %cond.false.6895
  %1727 = load i32, i32* %c, align 4
  %conv6901 = sext i32 %1727 to i64
  %add6902 = add i64 %conv6901, 0
  %cmp6903 = icmp ule i64 %add6902, 65535
  br i1 %cmp6903, label %cond.true.6905, label %cond.false.6919

cond.true.6905:                                   ; preds = %cond.false.6900, %cond.true.6896
  %1728 = load i32, i32* %c, align 4
  %shr6906 = ashr i32 %1728, 12
  %or6907 = or i32 224, %shr6906
  %conv6908 = trunc i32 %or6907 to i8
  %arrayidx6909 = getelementptr inbounds [5 x i8], [5 x i8]* %str, i32 0, i64 0
  store i8 %conv6908, i8* %arrayidx6909, align 1
  %1729 = load i32, i32* %c, align 4
  %shr6910 = ashr i32 %1729, 6
  %and6911 = and i32 %shr6910, 63
  %or6912 = or i32 128, %and6911
  %conv6913 = trunc i32 %or6912 to i8
  %arrayidx6914 = getelementptr inbounds [5 x i8], [5 x i8]* %str, i32 0, i64 1
  store i8 %conv6913, i8* %arrayidx6914, align 1
  %1730 = load i32, i32* %c, align 4
  %and6915 = and i32 %1730, 63
  %or6916 = or i32 128, %and6915
  %conv6917 = trunc i32 %or6916 to i8
  %arrayidx6918 = getelementptr inbounds [5 x i8], [5 x i8]* %str, i32 0, i64 2
  store i8 %conv6917, i8* %arrayidx6918, align 1
  br label %cond.end.6922

cond.false.6919:                                  ; preds = %cond.false.6900, %cond.true.6896
  %1731 = load i32, i32* %c, align 4
  %arraydecay6920 = getelementptr inbounds [5 x i8], [5 x i8]* %str, i32 0, i32 0
  %call6921 = call i32 @char_string(i32 %1731, i8* %arraydecay6920)
  br label %cond.end.6922

cond.end.6922:                                    ; preds = %cond.false.6919, %cond.true.6905
  %cond6923 = phi i32 [ 3, %cond.true.6905 ], [ %call6921, %cond.false.6919 ]
  br label %cond.end.6924

cond.end.6924:                                    ; preds = %cond.end.6922, %cond.true.6886
  %cond6925 = phi i32 [ 2, %cond.true.6886 ], [ %cond6923, %cond.end.6922 ]
  br label %cond.end.6926

cond.end.6926:                                    ; preds = %cond.end.6924, %cond.true.6873
  %cond6927 = phi i32 [ 1, %cond.true.6873 ], [ %cond6925, %cond.end.6924 ]
  %conv6928 = sext i32 %cond6927 to i64
  store i64 %conv6928, i64* %convbytes, align 8
  %arraydecay6929 = getelementptr inbounds [5 x i8], [5 x i8]* %str, i32 0, i32 0
  store i8* %arraydecay6929, i8** %convsrc, align 8
  br label %if.end.6930

if.end.6930:                                      ; preds = %cond.end.6926, %cond.false.6856, %cond.true.6851, %if.else.6847
  br label %if.end.6931

if.end.6931:                                      ; preds = %if.end.6930, %while.end
  br label %if.end.6932

if.end.6932:                                      ; preds = %if.end.6931, %land.end.6798
  br label %if.end.6933

if.end.6933:                                      ; preds = %if.end.6932, %if.then.6764
  br label %if.end.6934

if.end.6934:                                      ; preds = %if.end.6933, %if.end.6752
  br label %copy_char

copy_char:                                        ; preds = %if.end.6934, %if.then.5983
  %1732 = load i64, i64* %convbytes, align 8
  %1733 = load i8*, i8** %buf, align 8
  %1734 = load i64, i64* %bufsize, align 8
  %add.ptr6935 = getelementptr inbounds i8, i8* %1733, i64 %1734
  %1735 = load i8*, i8** %p, align 8
  %sub.ptr.lhs.cast6936 = ptrtoint i8* %add.ptr6935 to i64
  %sub.ptr.rhs.cast6937 = ptrtoint i8* %1735 to i64
  %sub.ptr.sub6938 = sub i64 %sub.ptr.lhs.cast6936, %sub.ptr.rhs.cast6937
  %cmp6939 = icmp sle i64 %1732, %sub.ptr.sub6938
  br i1 %cmp6939, label %if.then.6941, label %if.end.6944

if.then.6941:                                     ; preds = %copy_char
  %1736 = load i8*, i8** %p, align 8
  %1737 = load i8*, i8** %convsrc, align 8
  %1738 = load i64, i64* %convbytes, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1736, i8* %1737, i64 %1738, i32 1, i1 false)
  %1739 = load i64, i64* %convbytes, align 8
  %1740 = load i8*, i8** %p, align 8
  %add.ptr6942 = getelementptr inbounds i8, i8* %1740, i64 %1739
  store i8* %add.ptr6942, i8** %p, align 8
  %1741 = load i64, i64* %nchars, align 8
  %inc6943 = add nsw i64 %1741, 1
  store i64 %inc6943, i64* %nchars, align 8
  br label %while.cond

if.end.6944:                                      ; preds = %copy_char
  br label %if.end.6945

if.end.6945:                                      ; preds = %if.end.6944, %if.end.6737
  %1742 = load i8*, i8** %p, align 8
  %1743 = load i8*, i8** %buf, align 8
  %sub.ptr.lhs.cast6946 = ptrtoint i8* %1742 to i64
  %sub.ptr.rhs.cast6947 = ptrtoint i8* %1743 to i64
  %sub.ptr.sub6948 = sub i64 %sub.ptr.lhs.cast6946, %sub.ptr.rhs.cast6947
  store i64 %sub.ptr.sub6948, i64* %used, align 8
  %1744 = load i64, i64* %max_bufsize, align 8
  %1745 = load i64, i64* %used, align 8
  %sub6949 = sub nsw i64 %1744, %1745
  %1746 = load i64, i64* %convbytes, align 8
  %cmp6950 = icmp slt i64 %sub6949, %1746
  br i1 %cmp6950, label %if.then.6952, label %if.end.6953

if.then.6952:                                     ; preds = %if.end.6945
  call void @string_overflow() #9
  unreachable

if.end.6953:                                      ; preds = %if.end.6945
  %1747 = load i64, i64* %used, align 8
  %1748 = load i64, i64* %convbytes, align 8
  %add6954 = add nsw i64 %1747, %1748
  store i64 %add6954, i64* %bufsize, align 8
  %1749 = load i64, i64* %bufsize, align 8
  %1750 = load i64, i64* %max_bufsize, align 8
  %div6955 = sdiv i64 %1750, 2
  %cmp6956 = icmp slt i64 %1749, %div6955
  br i1 %cmp6956, label %cond.true.6958, label %cond.false.6960

cond.true.6958:                                   ; preds = %if.end.6953
  %1751 = load i64, i64* %bufsize, align 8
  %mul6959 = mul nsw i64 %1751, 2
  br label %cond.end.6961

cond.false.6960:                                  ; preds = %if.end.6953
  %1752 = load i64, i64* %max_bufsize, align 8
  br label %cond.end.6961

cond.end.6961:                                    ; preds = %cond.false.6960, %cond.true.6958
  %cond6962 = phi i64 [ %mul6959, %cond.true.6958 ], [ %1752, %cond.false.6960 ]
  store i64 %cond6962, i64* %bufsize, align 8
  %1753 = load i8*, i8** %buf, align 8
  %arraydecay6963 = getelementptr inbounds [4000 x i8], [4000 x i8]* %initial_buffer, i32 0, i32 0
  %cmp6964 = icmp eq i8* %1753, %arraydecay6963
  br i1 %cmp6964, label %if.then.6966, label %if.else.6969

if.then.6966:                                     ; preds = %cond.end.6961
  %1754 = load i64, i64* %bufsize, align 8
  %call6967 = call noalias i8* @xmalloc(i64 %1754)
  store i8* %call6967, i8** %buf, align 8
  store i8 1, i8* %sa_must_free, align 1
  %call6968 = call i64 @SPECPDL_INDEX()
  store i64 %call6968, i64* %buf_save_value_index, align 8
  %1755 = load i8*, i8** %buf, align 8
  call void @record_unwind_protect_ptr(void (i8*)* @xfree, i8* %1755)
  %1756 = load i8*, i8** %buf, align 8
  %1757 = bitcast [4000 x i8]* %initial_buffer to i8*
  %1758 = load i64, i64* %used, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %1756, i8* %1757, i64 %1758, i32 1, i1 false)
  br label %if.end.6971

if.else.6969:                                     ; preds = %cond.end.6961
  %1759 = load i8*, i8** %buf, align 8
  %1760 = load i64, i64* %bufsize, align 8
  %call6970 = call i8* @xrealloc(i8* %1759, i64 %1760)
  store i8* %call6970, i8** %buf, align 8
  %1761 = load i64, i64* %buf_save_value_index, align 8
  %1762 = load i8*, i8** %buf, align 8
  call void @set_unwind_protect_ptr(i64 %1761, void (i8*)* @xfree, i8* %1762)
  br label %if.end.6971

if.end.6971:                                      ; preds = %if.else.6969, %if.then.6966
  %1763 = load i8*, i8** %buf, align 8
  %1764 = load i64, i64* %used, align 8
  %add.ptr6972 = getelementptr inbounds i8, i8* %1763, i64 %1764
  store i8* %add.ptr6972, i8** %p, align 8
  %1765 = load i8*, i8** %format0, align 8
  store i8* %1765, i8** %format, align 8
  %1766 = load i64, i64* %n0, align 8
  store i64 %1766, i64* %n, align 8
  br label %while.cond

while.end.6973:                                   ; preds = %while.cond
  %1767 = load i64, i64* %bufsize, align 8
  %1768 = load i8*, i8** %p, align 8
  %1769 = load i8*, i8** %buf, align 8
  %sub.ptr.lhs.cast6974 = ptrtoint i8* %1768 to i64
  %sub.ptr.rhs.cast6975 = ptrtoint i8* %1769 to i64
  %sub.ptr.sub6976 = sub i64 %sub.ptr.lhs.cast6974, %sub.ptr.rhs.cast6975
  %cmp6977 = icmp slt i64 %1767, %sub.ptr.sub6976
  br i1 %cmp6977, label %if.then.6979, label %if.end.6980

if.then.6979:                                     ; preds = %while.end.6973
  call void @emacs_abort() #9
  unreachable

if.end.6980:                                      ; preds = %while.end.6973
  %1770 = load i8, i8* %maybe_combine_byte, align 1
  %tobool6981 = trunc i8 %1770 to i1
  br i1 %tobool6981, label %if.then.6982, label %if.end.6987

if.then.6982:                                     ; preds = %if.end.6980
  %1771 = load i8*, i8** %buf, align 8
  %1772 = load i8*, i8** %p, align 8
  %1773 = load i8*, i8** %buf, align 8
  %sub.ptr.lhs.cast6983 = ptrtoint i8* %1772 to i64
  %sub.ptr.rhs.cast6984 = ptrtoint i8* %1773 to i64
  %sub.ptr.sub6985 = sub i64 %sub.ptr.lhs.cast6983, %sub.ptr.rhs.cast6984
  %call6986 = call i64 @multibyte_chars_in_text(i8* %1771, i64 %sub.ptr.sub6985)
  store i64 %call6986, i64* %nchars, align 8
  br label %if.end.6987

if.end.6987:                                      ; preds = %if.then.6982, %if.end.6980
  %1774 = load i8*, i8** %buf, align 8
  %1775 = load i64, i64* %nchars, align 8
  %1776 = load i8*, i8** %p, align 8
  %1777 = load i8*, i8** %buf, align 8
  %sub.ptr.lhs.cast6988 = ptrtoint i8* %1776 to i64
  %sub.ptr.rhs.cast6989 = ptrtoint i8* %1777 to i64
  %sub.ptr.sub6990 = sub i64 %sub.ptr.lhs.cast6988, %sub.ptr.rhs.cast6989
  %1778 = load i8, i8* %multibyte, align 1
  %tobool6991 = trunc i8 %1778 to i1
  %call6992 = call i64 @make_specified_string(i8* %1774, i64 %1775, i64 %sub.ptr.sub6990, i1 zeroext %tobool6991)
  store i64 %call6992, i64* %val, align 8
  %1779 = load i64*, i64** %args.addr, align 8
  %arrayidx6993 = getelementptr inbounds i64, i64* %1779, i64 0
  %1780 = load i64, i64* %arrayidx6993, align 8
  %call6994 = call %struct.interval* @string_intervals(i64 %1780)
  %tobool6995 = icmp ne %struct.interval* %call6994, null
  br i1 %tobool6995, label %if.then.6999, label %lor.lhs.false.6996

lor.lhs.false.6996:                               ; preds = %if.end.6987
  %1781 = load i8, i8* %arg_intervals, align 1
  %tobool6997 = trunc i8 %1781 to i1
  br i1 %tobool6997, label %if.then.6999, label %if.end.7154

if.then.6999:                                     ; preds = %lor.lhs.false.6996, %if.end.6987
  %1782 = load i64*, i64** %args.addr, align 8
  %arrayidx7000 = getelementptr inbounds i64, i64* %1782, i64 0
  %1783 = load i64, i64* %arrayidx7000, align 8
  %call7001 = call i64 @SCHARS(i64 %1783)
  %shl7002 = shl i64 %call7001, 2
  %add7003 = add i64 %shl7002, 2
  store i64 %add7003, i64* %len, align 8
  %1784 = load i64*, i64** %args.addr, align 8
  %arrayidx7004 = getelementptr inbounds i64, i64* %1784, i64 0
  %1785 = load i64, i64* %arrayidx7004, align 8
  %1786 = load i64, i64* %len, align 8
  %call7005 = call i64 @builtin_lisp_symbol(i32 0)
  %call7006 = call i64 @text_property_list(i64 %1785, i64 2, i64 %1786, i64 %call7005)
  store i64 %call7006, i64* %props, align 8
  %1787 = load i64, i64* %props, align 8
  %and7007 = and i64 %1787, 7
  %conv7008 = trunc i64 %and7007 to i32
  %cmp7009 = icmp eq i32 %conv7008, 3
  br i1 %cmp7009, label %if.then.7011, label %if.end.7107

if.then.7011:                                     ; preds = %if.then.6999
  store i64 0, i64* %bytepos, align 8
  store i64 0, i64* %position, align 8
  store i64 0, i64* %translated, align 8
  store i64 1, i64* %argn, align 8
  %1788 = load i64, i64* %props, align 8
  %call7012 = call i64 @Fnreverse(i64 %1788)
  store i64 %call7012, i64* %props, align 8
  %1789 = load i64, i64* %props, align 8
  store i64 %1789, i64* %list, align 8
  br label %for.cond.7013

for.cond.7013:                                    ; preds = %for.inc.7102, %if.then.7011
  %1790 = load i64, i64* %list, align 8
  %and7014 = and i64 %1790, 7
  %conv7015 = trunc i64 %and7014 to i32
  %cmp7016 = icmp eq i32 %conv7015, 3
  br i1 %cmp7016, label %for.body.7018, label %for.end.7106

for.body.7018:                                    ; preds = %for.cond.7013
  %1791 = load i64, i64* %list, align 8
  %sub7019 = sub nsw i64 %1791, 3
  %1792 = inttoptr i64 %sub7019 to i8*
  %1793 = bitcast i8* %1792 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %1793, i32 0, i32 0
  %1794 = load i64, i64* %car, align 8
  store i64 %1794, i64* %item, align 8
  %1795 = load i64, i64* %item, align 8
  %sub7020 = sub nsw i64 %1795, 3
  %1796 = inttoptr i64 %sub7020 to i8*
  %1797 = bitcast i8* %1796 to %struct.Lisp_Cons*
  %car7021 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %1797, i32 0, i32 0
  %1798 = load i64, i64* %car7021, align 8
  %shr7022 = ashr i64 %1798, 2
  store i64 %shr7022, i64* %pos, align 8
  br label %for.cond.7023

for.cond.7023:                                    ; preds = %for.inc.7054, %for.body.7018
  %1799 = load i64, i64* %position, align 8
  %1800 = load i64, i64* %pos, align 8
  %cmp7024 = icmp slt i64 %1799, %1800
  br i1 %cmp7024, label %for.body.7026, label %for.end.7056

for.body.7026:                                    ; preds = %for.cond.7023
  %1801 = load i64, i64* %bytepos, align 8
  %1802 = load i8*, i8** %discarded, align 8
  %arrayidx7027 = getelementptr inbounds i8, i8* %1802, i64 %1801
  %1803 = load i8, i8* %arrayidx7027, align 1
  %tobool7028 = icmp ne i8 %1803, 0
  br i1 %tobool7028, label %if.else.7032, label %if.then.7029

if.then.7029:                                     ; preds = %for.body.7026
  %1804 = load i64, i64* %position, align 8
  %inc7030 = add nsw i64 %1804, 1
  store i64 %inc7030, i64* %position, align 8
  %1805 = load i64, i64* %translated, align 8
  %inc7031 = add nsw i64 %1805, 1
  store i64 %inc7031, i64* %translated, align 8
  br label %if.end.7053

if.else.7032:                                     ; preds = %for.body.7026
  %1806 = load i64, i64* %bytepos, align 8
  %1807 = load i8*, i8** %discarded, align 8
  %arrayidx7033 = getelementptr inbounds i8, i8* %1807, i64 %1806
  %1808 = load i8, i8* %arrayidx7033, align 1
  %conv7034 = sext i8 %1808 to i32
  %cmp7035 = icmp eq i32 %conv7034, 1
  br i1 %cmp7035, label %if.then.7037, label %if.end.7052

if.then.7037:                                     ; preds = %if.else.7032
  %1809 = load i64, i64* %position, align 8
  %inc7038 = add nsw i64 %1809, 1
  store i64 %inc7038, i64* %position, align 8
  %1810 = load i64, i64* %translated, align 8
  %1811 = load i64, i64* %argn, align 8
  %1812 = load %struct.info*, %struct.info** %info, align 8
  %arrayidx7039 = getelementptr inbounds %struct.info, %struct.info* %1812, i64 %1811
  %start7040 = getelementptr inbounds %struct.info, %struct.info* %arrayidx7039, i32 0, i32 0
  %1813 = load i64, i64* %start7040, align 8
  %cmp7041 = icmp eq i64 %1810, %1813
  br i1 %cmp7041, label %if.then.7043, label %if.end.7051

if.then.7043:                                     ; preds = %if.then.7037
  %1814 = load i64, i64* %argn, align 8
  %1815 = load %struct.info*, %struct.info** %info, align 8
  %arrayidx7044 = getelementptr inbounds %struct.info, %struct.info* %1815, i64 %1814
  %end7045 = getelementptr inbounds %struct.info, %struct.info* %arrayidx7044, i32 0, i32 1
  %1816 = load i64, i64* %end7045, align 8
  %1817 = load i64, i64* %argn, align 8
  %1818 = load %struct.info*, %struct.info** %info, align 8
  %arrayidx7046 = getelementptr inbounds %struct.info, %struct.info* %1818, i64 %1817
  %start7047 = getelementptr inbounds %struct.info, %struct.info* %arrayidx7046, i32 0, i32 0
  %1819 = load i64, i64* %start7047, align 8
  %sub7048 = sub nsw i64 %1816, %1819
  %1820 = load i64, i64* %translated, align 8
  %add7049 = add nsw i64 %1820, %sub7048
  store i64 %add7049, i64* %translated, align 8
  %1821 = load i64, i64* %argn, align 8
  %inc7050 = add nsw i64 %1821, 1
  store i64 %inc7050, i64* %argn, align 8
  br label %if.end.7051

if.end.7051:                                      ; preds = %if.then.7043, %if.then.7037
  br label %if.end.7052

if.end.7052:                                      ; preds = %if.end.7051, %if.else.7032
  br label %if.end.7053

if.end.7053:                                      ; preds = %if.end.7052, %if.then.7029
  br label %for.inc.7054

for.inc.7054:                                     ; preds = %if.end.7053
  %1822 = load i64, i64* %bytepos, align 8
  %inc7055 = add nsw i64 %1822, 1
  store i64 %inc7055, i64* %bytepos, align 8
  br label %for.cond.7023

for.end.7056:                                     ; preds = %for.cond.7023
  %1823 = load i64, i64* %item, align 8
  %1824 = load i64, i64* %translated, align 8
  %shl7057 = shl i64 %1824, 2
  %add7058 = add i64 %shl7057, 2
  call void @XSETCAR(i64 %1823, i64 %add7058)
  %1825 = load i64, i64* %item, align 8
  %sub7059 = sub nsw i64 %1825, 3
  %1826 = inttoptr i64 %sub7059 to i8*
  %1827 = bitcast i8* %1826 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %1827, i32 0, i32 1
  %cdr = bitcast %union.anon.20* %u to i64*
  %1828 = load i64, i64* %cdr, align 8
  %sub7060 = sub nsw i64 %1828, 3
  %1829 = inttoptr i64 %sub7060 to i8*
  %1830 = bitcast i8* %1829 to %struct.Lisp_Cons*
  %car7061 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %1830, i32 0, i32 0
  %1831 = load i64, i64* %car7061, align 8
  %shr7062 = ashr i64 %1831, 2
  store i64 %shr7062, i64* %pos, align 8
  br label %for.cond.7063

for.cond.7063:                                    ; preds = %for.inc.7094, %for.end.7056
  %1832 = load i64, i64* %position, align 8
  %1833 = load i64, i64* %pos, align 8
  %cmp7064 = icmp slt i64 %1832, %1833
  br i1 %cmp7064, label %for.body.7066, label %for.end.7096

for.body.7066:                                    ; preds = %for.cond.7063
  %1834 = load i64, i64* %bytepos, align 8
  %1835 = load i8*, i8** %discarded, align 8
  %arrayidx7067 = getelementptr inbounds i8, i8* %1835, i64 %1834
  %1836 = load i8, i8* %arrayidx7067, align 1
  %tobool7068 = icmp ne i8 %1836, 0
  br i1 %tobool7068, label %if.else.7072, label %if.then.7069

if.then.7069:                                     ; preds = %for.body.7066
  %1837 = load i64, i64* %position, align 8
  %inc7070 = add nsw i64 %1837, 1
  store i64 %inc7070, i64* %position, align 8
  %1838 = load i64, i64* %translated, align 8
  %inc7071 = add nsw i64 %1838, 1
  store i64 %inc7071, i64* %translated, align 8
  br label %if.end.7093

if.else.7072:                                     ; preds = %for.body.7066
  %1839 = load i64, i64* %bytepos, align 8
  %1840 = load i8*, i8** %discarded, align 8
  %arrayidx7073 = getelementptr inbounds i8, i8* %1840, i64 %1839
  %1841 = load i8, i8* %arrayidx7073, align 1
  %conv7074 = sext i8 %1841 to i32
  %cmp7075 = icmp eq i32 %conv7074, 1
  br i1 %cmp7075, label %if.then.7077, label %if.end.7092

if.then.7077:                                     ; preds = %if.else.7072
  %1842 = load i64, i64* %position, align 8
  %inc7078 = add nsw i64 %1842, 1
  store i64 %inc7078, i64* %position, align 8
  %1843 = load i64, i64* %translated, align 8
  %1844 = load i64, i64* %argn, align 8
  %1845 = load %struct.info*, %struct.info** %info, align 8
  %arrayidx7079 = getelementptr inbounds %struct.info, %struct.info* %1845, i64 %1844
  %start7080 = getelementptr inbounds %struct.info, %struct.info* %arrayidx7079, i32 0, i32 0
  %1846 = load i64, i64* %start7080, align 8
  %cmp7081 = icmp eq i64 %1843, %1846
  br i1 %cmp7081, label %if.then.7083, label %if.end.7091

if.then.7083:                                     ; preds = %if.then.7077
  %1847 = load i64, i64* %argn, align 8
  %1848 = load %struct.info*, %struct.info** %info, align 8
  %arrayidx7084 = getelementptr inbounds %struct.info, %struct.info* %1848, i64 %1847
  %end7085 = getelementptr inbounds %struct.info, %struct.info* %arrayidx7084, i32 0, i32 1
  %1849 = load i64, i64* %end7085, align 8
  %1850 = load i64, i64* %argn, align 8
  %1851 = load %struct.info*, %struct.info** %info, align 8
  %arrayidx7086 = getelementptr inbounds %struct.info, %struct.info* %1851, i64 %1850
  %start7087 = getelementptr inbounds %struct.info, %struct.info* %arrayidx7086, i32 0, i32 0
  %1852 = load i64, i64* %start7087, align 8
  %sub7088 = sub nsw i64 %1849, %1852
  %1853 = load i64, i64* %translated, align 8
  %add7089 = add nsw i64 %1853, %sub7088
  store i64 %add7089, i64* %translated, align 8
  %1854 = load i64, i64* %argn, align 8
  %inc7090 = add nsw i64 %1854, 1
  store i64 %inc7090, i64* %argn, align 8
  br label %if.end.7091

if.end.7091:                                      ; preds = %if.then.7083, %if.then.7077
  br label %if.end.7092

if.end.7092:                                      ; preds = %if.end.7091, %if.else.7072
  br label %if.end.7093

if.end.7093:                                      ; preds = %if.end.7092, %if.then.7069
  br label %for.inc.7094

for.inc.7094:                                     ; preds = %if.end.7093
  %1855 = load i64, i64* %bytepos, align 8
  %inc7095 = add nsw i64 %1855, 1
  store i64 %inc7095, i64* %bytepos, align 8
  br label %for.cond.7063

for.end.7096:                                     ; preds = %for.cond.7063
  %1856 = load i64, i64* %item, align 8
  %sub7097 = sub nsw i64 %1856, 3
  %1857 = inttoptr i64 %sub7097 to i8*
  %1858 = bitcast i8* %1857 to %struct.Lisp_Cons*
  %u7098 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %1858, i32 0, i32 1
  %cdr7099 = bitcast %union.anon.20* %u7098 to i64*
  %1859 = load i64, i64* %cdr7099, align 8
  %1860 = load i64, i64* %translated, align 8
  %shl7100 = shl i64 %1860, 2
  %add7101 = add i64 %shl7100, 2
  call void @XSETCAR(i64 %1859, i64 %add7101)
  br label %for.inc.7102

for.inc.7102:                                     ; preds = %for.end.7096
  %1861 = load i64, i64* %list, align 8
  %sub7103 = sub nsw i64 %1861, 3
  %1862 = inttoptr i64 %sub7103 to i8*
  %1863 = bitcast i8* %1862 to %struct.Lisp_Cons*
  %u7104 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %1863, i32 0, i32 1
  %cdr7105 = bitcast %union.anon.20* %u7104 to i64*
  %1864 = load i64, i64* %cdr7105, align 8
  store i64 %1864, i64* %list, align 8
  br label %for.cond.7013

for.end.7106:                                     ; preds = %for.cond.7013
  %1865 = load i64, i64* %val, align 8
  %1866 = load i64, i64* %props, align 8
  call void @add_text_properties_from_list(i64 %1865, i64 %1866, i64 2)
  br label %if.end.7107

if.end.7107:                                      ; preds = %for.end.7106, %if.then.6999
  %1867 = load i8, i8* %arg_intervals, align 1
  %tobool7108 = trunc i8 %1867 to i1
  br i1 %tobool7108, label %if.then.7109, label %if.end.7153

if.then.7109:                                     ; preds = %if.end.7107
  store i64 1, i64* %i7110, align 8
  br label %for.cond.7111

for.cond.7111:                                    ; preds = %for.inc.7150, %if.then.7109
  %1868 = load i64, i64* %i7110, align 8
  %1869 = load i64, i64* %nargs.addr, align 8
  %cmp7112 = icmp slt i64 %1868, %1869
  br i1 %cmp7112, label %for.body.7114, label %for.end.7152

for.body.7114:                                    ; preds = %for.cond.7111
  %1870 = load i64, i64* %i7110, align 8
  %1871 = load %struct.info*, %struct.info** %info, align 8
  %arrayidx7115 = getelementptr inbounds %struct.info, %struct.info* %1871, i64 %1870
  %intervals7116 = getelementptr inbounds %struct.info, %struct.info* %arrayidx7115, i32 0, i32 2
  %bf.load7117 = load i8, i8* %intervals7116, align 8
  %bf.lshr = lshr i8 %bf.load7117, 1
  %bf.clear7118 = and i8 %bf.lshr, 1
  %bf.cast7119 = trunc i8 %bf.clear7118 to i1
  br i1 %bf.cast7119, label %if.then.7120, label %if.end.7149

if.then.7120:                                     ; preds = %for.body.7114
  %1872 = load i64, i64* %i7110, align 8
  %1873 = load i64*, i64** %args.addr, align 8
  %arrayidx7121 = getelementptr inbounds i64, i64* %1873, i64 %1872
  %1874 = load i64, i64* %arrayidx7121, align 8
  %call7122 = call i64 @SCHARS(i64 %1874)
  %shl7123 = shl i64 %call7122, 2
  %add7124 = add i64 %shl7123, 2
  store i64 %add7124, i64* %len, align 8
  %1875 = load i64, i64* %i7110, align 8
  %1876 = load %struct.info*, %struct.info** %info, align 8
  %arrayidx7125 = getelementptr inbounds %struct.info, %struct.info* %1876, i64 %1875
  %end7126 = getelementptr inbounds %struct.info, %struct.info* %arrayidx7125, i32 0, i32 1
  %1877 = load i64, i64* %end7126, align 8
  %1878 = load i64, i64* %i7110, align 8
  %1879 = load %struct.info*, %struct.info** %info, align 8
  %arrayidx7127 = getelementptr inbounds %struct.info, %struct.info* %1879, i64 %1878
  %start7128 = getelementptr inbounds %struct.info, %struct.info* %arrayidx7127, i32 0, i32 0
  %1880 = load i64, i64* %start7128, align 8
  %sub7129 = sub nsw i64 %1877, %1880
  %shl7130 = shl i64 %sub7129, 2
  %add7131 = add i64 %shl7130, 2
  store i64 %add7131, i64* %new_len, align 8
  %1881 = load i64, i64* %i7110, align 8
  %1882 = load i64*, i64** %args.addr, align 8
  %arrayidx7132 = getelementptr inbounds i64, i64* %1882, i64 %1881
  %1883 = load i64, i64* %arrayidx7132, align 8
  %1884 = load i64, i64* %len, align 8
  %call7133 = call i64 @builtin_lisp_symbol(i32 0)
  %call7134 = call i64 @text_property_list(i64 %1883, i64 2, i64 %1884, i64 %call7133)
  store i64 %call7134, i64* %props, align 8
  %1885 = load i64, i64* %props, align 8
  %1886 = load i64, i64* %new_len, align 8
  %call7135 = call i64 @extend_property_ranges(i64 %1885, i64 %1886)
  store i64 %call7135, i64* %props, align 8
  %1887 = load i64, i64* %i7110, align 8
  %cmp7136 = icmp slt i64 1, %1887
  br i1 %cmp7136, label %land.lhs.true.7138, label %if.end.7144

land.lhs.true.7138:                               ; preds = %if.then.7120
  %1888 = load i64, i64* %i7110, align 8
  %sub7139 = sub nsw i64 %1888, 1
  %1889 = load %struct.info*, %struct.info** %info, align 8
  %arrayidx7140 = getelementptr inbounds %struct.info, %struct.info* %1889, i64 %sub7139
  %end7141 = getelementptr inbounds %struct.info, %struct.info* %arrayidx7140, i32 0, i32 1
  %1890 = load i64, i64* %end7141, align 8
  %tobool7142 = icmp ne i64 %1890, 0
  br i1 %tobool7142, label %if.then.7143, label %if.end.7144

if.then.7143:                                     ; preds = %land.lhs.true.7138
  %1891 = load i64, i64* %props, align 8
  call void @make_composition_value_copy(i64 %1891)
  br label %if.end.7144

if.end.7144:                                      ; preds = %if.then.7143, %land.lhs.true.7138, %if.then.7120
  %1892 = load i64, i64* %val, align 8
  %1893 = load i64, i64* %props, align 8
  %1894 = load i64, i64* %i7110, align 8
  %1895 = load %struct.info*, %struct.info** %info, align 8
  %arrayidx7145 = getelementptr inbounds %struct.info, %struct.info* %1895, i64 %1894
  %start7146 = getelementptr inbounds %struct.info, %struct.info* %arrayidx7145, i32 0, i32 0
  %1896 = load i64, i64* %start7146, align 8
  %shl7147 = shl i64 %1896, 2
  %add7148 = add i64 %shl7147, 2
  call void @add_text_properties_from_list(i64 %1892, i64 %1893, i64 %add7148)
  br label %if.end.7149

if.end.7149:                                      ; preds = %if.end.7144, %for.body.7114
  br label %for.inc.7150

for.inc.7150:                                     ; preds = %if.end.7149
  %1897 = load i64, i64* %i7110, align 8
  %inc7151 = add nsw i64 %1897, 1
  store i64 %inc7151, i64* %i7110, align 8
  br label %for.cond.7111

for.end.7152:                                     ; preds = %for.cond.7111
  br label %if.end.7153

if.end.7153:                                      ; preds = %for.end.7152, %if.end.7107
  br label %if.end.7154

if.end.7154:                                      ; preds = %if.end.7153, %lor.lhs.false.6996
  br label %do.body

do.body:                                          ; preds = %if.end.7154
  %1898 = load i8, i8* %sa_must_free, align 1
  %tobool7155 = trunc i8 %1898 to i1
  br i1 %tobool7155, label %if.then.7156, label %if.end.7159

if.then.7156:                                     ; preds = %do.body
  store i8 0, i8* %sa_must_free, align 1
  %1899 = load i64, i64* %sa_count, align 8
  %call7157 = call i64 @builtin_lisp_symbol(i32 0)
  %call7158 = call i64 @unbind_to(i64 %1899, i64 %call7157)
  br label %if.end.7159

if.end.7159:                                      ; preds = %if.then.7156, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end.7159
  %1900 = load i64, i64* %val, align 8
  ret i64 %1900
}

; Function Attrs: nounwind uwtable
define i64 @Fchar_equal(i64 %c1, i64 %c2) #0 {
entry:
  %retval = alloca i64, align 8
  %c1.addr = alloca i64, align 8
  %c2.addr = alloca i64, align 8
  %i1 = alloca i32, align 4
  %i2 = alloca i32, align 4
  store i64 %c1, i64* %c1.addr, align 8
  store i64 %c2, i64* %c2.addr, align 8
  %0 = load i64, i64* %c1.addr, align 8
  %call = call zeroext i1 @NATNUMP(i64 %0)
  br i1 %call, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, i64* %c1.addr, align 8
  %shr = ashr i64 %1, 2
  %cmp = icmp sle i64 %shr, 4194303
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %entry
  %call1 = call i64 @builtin_lisp_symbol(i32 260)
  %2 = load i64, i64* %c1.addr, align 8
  %3 = call i64 @wrong_type_argument(i64 %call1, i64 %2) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %4, %cond.true
  %5 = load i64, i64* %c2.addr, align 8
  %call2 = call zeroext i1 @NATNUMP(i64 %5)
  br i1 %call2, label %land.lhs.true.3, label %cond.false.7

land.lhs.true.3:                                  ; preds = %cond.end
  %6 = load i64, i64* %c2.addr, align 8
  %shr4 = ashr i64 %6, 2
  %cmp5 = icmp sle i64 %shr4, 4194303
  br i1 %cmp5, label %cond.true.6, label %cond.false.7

cond.true.6:                                      ; preds = %land.lhs.true.3
  br label %cond.end.9

cond.false.7:                                     ; preds = %land.lhs.true.3, %cond.end
  %call8 = call i64 @builtin_lisp_symbol(i32 260)
  %7 = load i64, i64* %c2.addr, align 8
  %8 = call i64 @wrong_type_argument(i64 %call8, i64 %7) #9
  unreachable
                                                  ; No predecessors!
  br label %cond.end.9

cond.end.9:                                       ; preds = %9, %cond.true.6
  %10 = load i64, i64* %c1.addr, align 8
  %shr10 = ashr i64 %10, 2
  %11 = load i64, i64* %c2.addr, align 8
  %shr11 = ashr i64 %11, 2
  %cmp12 = icmp eq i64 %shr10, %shr11
  br i1 %cmp12, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end.9
  %call13 = call i64 @builtin_lisp_symbol(i32 901)
  store i64 %call13, i64* %retval
  br label %return

if.end:                                           ; preds = %cond.end.9
  %12 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %case_fold_search_ = getelementptr inbounds %struct.buffer, %struct.buffer* %12, i32 0, i32 18
  %13 = load i64, i64* %case_fold_search_, align 8
  %call14 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp15 = icmp eq i64 %13, %call14
  br i1 %cmp15, label %if.then.16, label %if.end.18

if.then.16:                                       ; preds = %if.end
  %call17 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call17, i64* %retval
  br label %return

if.end.18:                                        ; preds = %if.end
  %14 = load i64, i64* %c1.addr, align 8
  %shr19 = ashr i64 %14, 2
  %conv = trunc i64 %shr19 to i32
  store i32 %conv, i32* %i1, align 4
  %15 = load i64, i64* %c2.addr, align 8
  %shr20 = ashr i64 %15, 2
  %conv21 = trunc i64 %shr20 to i32
  store i32 %conv21, i32* %i2, align 4
  %16 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %enable_multibyte_characters_ = getelementptr inbounds %struct.buffer, %struct.buffer* %16, i32 0, i32 39
  %17 = load i64, i64* %enable_multibyte_characters_, align 8
  %call22 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp23 = icmp eq i64 %17, %call22
  br i1 %cmp23, label %if.then.25, label %if.end.74

if.then.25:                                       ; preds = %if.end.18
  br i1 true, label %cond.true.26, label %cond.false.29

cond.true.26:                                     ; preds = %if.then.25
  %18 = load i32, i32* %i1, align 4
  %add = add i32 %18, 0
  %cmp27 = icmp ult i32 %add, 256
  br i1 %cmp27, label %if.then.34, label %if.end.48

cond.false.29:                                    ; preds = %if.then.25
  %19 = load i32, i32* %i1, align 4
  %conv30 = sext i32 %19 to i64
  %add31 = add i64 %conv30, 0
  %cmp32 = icmp ult i64 %add31, 256
  br i1 %cmp32, label %if.then.34, label %if.end.48

if.then.34:                                       ; preds = %cond.false.29, %cond.true.26
  br i1 true, label %cond.true.35, label %cond.false.39

cond.true.35:                                     ; preds = %if.then.34
  %20 = load i32, i32* %i1, align 4
  %add36 = add i32 %20, 0
  %cmp37 = icmp ult i32 %add36, 128
  br i1 %cmp37, label %cond.true.44, label %cond.false.45

cond.false.39:                                    ; preds = %if.then.34
  %21 = load i32, i32* %i1, align 4
  %conv40 = sext i32 %21 to i64
  %add41 = add i64 %conv40, 0
  %cmp42 = icmp ult i64 %add41, 128
  br i1 %cmp42, label %cond.true.44, label %cond.false.45

cond.true.44:                                     ; preds = %cond.false.39, %cond.true.35
  %22 = load i32, i32* %i1, align 4
  br label %cond.end.47

cond.false.45:                                    ; preds = %cond.false.39, %cond.true.35
  %23 = load i32, i32* %i1, align 4
  %add46 = add nsw i32 %23, 4194048
  br label %cond.end.47

cond.end.47:                                      ; preds = %cond.false.45, %cond.true.44
  %cond = phi i32 [ %22, %cond.true.44 ], [ %add46, %cond.false.45 ]
  store i32 %cond, i32* %i1, align 4
  br label %if.end.48

if.end.48:                                        ; preds = %cond.end.47, %cond.false.29, %cond.true.26
  br i1 true, label %cond.true.49, label %cond.false.53

cond.true.49:                                     ; preds = %if.end.48
  %24 = load i32, i32* %i2, align 4
  %add50 = add i32 %24, 0
  %cmp51 = icmp ult i32 %add50, 256
  br i1 %cmp51, label %if.then.58, label %if.end.73

cond.false.53:                                    ; preds = %if.end.48
  %25 = load i32, i32* %i2, align 4
  %conv54 = sext i32 %25 to i64
  %add55 = add i64 %conv54, 0
  %cmp56 = icmp ult i64 %add55, 256
  br i1 %cmp56, label %if.then.58, label %if.end.73

if.then.58:                                       ; preds = %cond.false.53, %cond.true.49
  br i1 true, label %cond.true.59, label %cond.false.63

cond.true.59:                                     ; preds = %if.then.58
  %26 = load i32, i32* %i2, align 4
  %add60 = add i32 %26, 0
  %cmp61 = icmp ult i32 %add60, 128
  br i1 %cmp61, label %cond.true.68, label %cond.false.69

cond.false.63:                                    ; preds = %if.then.58
  %27 = load i32, i32* %i2, align 4
  %conv64 = sext i32 %27 to i64
  %add65 = add i64 %conv64, 0
  %cmp66 = icmp ult i64 %add65, 128
  br i1 %cmp66, label %cond.true.68, label %cond.false.69

cond.true.68:                                     ; preds = %cond.false.63, %cond.true.59
  %28 = load i32, i32* %i2, align 4
  br label %cond.end.71

cond.false.69:                                    ; preds = %cond.false.63, %cond.true.59
  %29 = load i32, i32* %i2, align 4
  %add70 = add nsw i32 %29, 4194048
  br label %cond.end.71

cond.end.71:                                      ; preds = %cond.false.69, %cond.true.68
  %cond72 = phi i32 [ %28, %cond.true.68 ], [ %add70, %cond.false.69 ]
  store i32 %cond72, i32* %i2, align 4
  br label %if.end.73

if.end.73:                                        ; preds = %cond.end.71, %cond.false.53, %cond.true.49
  br label %if.end.74

if.end.74:                                        ; preds = %if.end.73, %if.end.18
  %30 = load i32, i32* %i1, align 4
  %call75 = call i32 @downcase(i32 %30)
  %31 = load i32, i32* %i2, align 4
  %call76 = call i32 @downcase(i32 %31)
  %cmp77 = icmp eq i32 %call75, %call76
  br i1 %cmp77, label %cond.true.79, label %cond.false.81

cond.true.79:                                     ; preds = %if.end.74
  %call80 = call i64 @builtin_lisp_symbol(i32 901)
  br label %cond.end.83

cond.false.81:                                    ; preds = %if.end.74
  %call82 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end.83

cond.end.83:                                      ; preds = %cond.false.81, %cond.true.79
  %cond84 = phi i64 [ %call80, %cond.true.79 ], [ %call82, %cond.false.81 ]
  store i64 %cond84, i64* %retval
  br label %return

return:                                           ; preds = %cond.end.83, %if.then.16, %if.then
  %32 = load i64, i64* %retval
  ret i64 %32
}

declare i32 @downcase(i32) #1

; Function Attrs: nounwind uwtable
define i64 @Ftranspose_regions(i64 %startr1, i64 %endr1, i64 %startr2, i64 %endr2, i64 %leave_markers) #0 {
entry:
  %retval = alloca i64, align 8
  %startr1.addr = alloca i64, align 8
  %endr1.addr = alloca i64, align 8
  %startr2.addr = alloca i64, align 8
  %endr2.addr = alloca i64, align 8
  %leave_markers.addr = alloca i64, align 8
  %start1 = alloca i64, align 8
  %end1 = alloca i64, align 8
  %start2 = alloca i64, align 8
  %end2 = alloca i64, align 8
  %start1_byte = alloca i64, align 8
  %start2_byte = alloca i64, align 8
  %len1_byte = alloca i64, align 8
  %len2_byte = alloca i64, align 8
  %end2_byte = alloca i64, align 8
  %gap = alloca i64, align 8
  %len1 = alloca i64, align 8
  %len_mid = alloca i64, align 8
  %len2 = alloca i64, align 8
  %start1_addr = alloca i8*, align 8
  %start2_addr = alloca i8*, align 8
  %temp = alloca i8*, align 8
  %cur_intv = alloca %struct.interval*, align 8
  %tmp_interval1 = alloca %struct.interval*, align 8
  %tmp_interval_mid = alloca %struct.interval*, align 8
  %tmp_interval2 = alloca %struct.interval*, align 8
  %tmp_interval3 = alloca %struct.interval*, align 8
  %buf = alloca i64, align 8
  %glumph = alloca i64, align 8
  %sa_avail = alloca i64, align 8
  %sa_count = alloca i64, align 8
  %sa_must_free = alloca i8, align 1
  %sa_avail122 = alloca i64, align 8
  %sa_count123 = alloca i64, align 8
  %sa_must_free125 = alloca i8, align 1
  %sa_avail183 = alloca i64, align 8
  %sa_count184 = alloca i64, align 8
  %sa_must_free186 = alloca i8, align 1
  %sa_avail245 = alloca i64, align 8
  %sa_count246 = alloca i64, align 8
  %sa_must_free248 = alloca i8, align 1
  store i64 %startr1, i64* %startr1.addr, align 8
  store i64 %endr1, i64* %endr1.addr, align 8
  store i64 %startr2, i64* %startr2.addr, align 8
  store i64 %endr2, i64* %endr2.addr, align 8
  store i64 %leave_markers, i64* %leave_markers.addr, align 8
  %0 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %1 = bitcast %struct.buffer* %0 to i8*
  %call = call i64 @make_lisp_ptr(i8* %1, i32 5)
  store i64 %call, i64* %buf, align 8
  %2 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %call1 = call %struct.interval* @buffer_intervals(%struct.buffer* %2)
  store %struct.interval* %call1, %struct.interval** %cur_intv, align 8
  call void @validate_region(i64* %startr1.addr, i64* %endr1.addr)
  call void @validate_region(i64* %startr2.addr, i64* %endr2.addr)
  %3 = load i64, i64* %startr1.addr, align 8
  %shr = ashr i64 %3, 2
  store i64 %shr, i64* %start1, align 8
  %4 = load i64, i64* %endr1.addr, align 8
  %shr2 = ashr i64 %4, 2
  store i64 %shr2, i64* %end1, align 8
  %5 = load i64, i64* %startr2.addr, align 8
  %shr3 = ashr i64 %5, 2
  store i64 %shr3, i64* %start2, align 8
  %6 = load i64, i64* %endr2.addr, align 8
  %shr4 = ashr i64 %6, 2
  store i64 %shr4, i64* %end2, align 8
  %7 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text = getelementptr inbounds %struct.buffer, %struct.buffer* %7, i32 0, i32 73
  %8 = load %struct.buffer_text*, %struct.buffer_text** %text, align 8
  %gpt = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %8, i32 0, i32 1
  %9 = load i64, i64* %gpt, align 8
  store i64 %9, i64* %gap, align 8
  %10 = load i64, i64* %start2, align 8
  %11 = load i64, i64* %end1, align 8
  %cmp = icmp slt i64 %10, %11
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %12 = load i64, i64* %start1, align 8
  store i64 %12, i64* %glumph, align 8
  %13 = load i64, i64* %start2, align 8
  store i64 %13, i64* %start1, align 8
  %14 = load i64, i64* %glumph, align 8
  store i64 %14, i64* %start2, align 8
  %15 = load i64, i64* %end1, align 8
  store i64 %15, i64* %glumph, align 8
  %16 = load i64, i64* %end2, align 8
  store i64 %16, i64* %end1, align 8
  %17 = load i64, i64* %glumph, align 8
  store i64 %17, i64* %end2, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %18 = load i64, i64* %end1, align 8
  %19 = load i64, i64* %start1, align 8
  %sub = sub nsw i64 %18, %19
  store i64 %sub, i64* %len1, align 8
  %20 = load i64, i64* %end2, align 8
  %21 = load i64, i64* %start2, align 8
  %sub5 = sub nsw i64 %20, %21
  store i64 %sub5, i64* %len2, align 8
  %22 = load i64, i64* %start2, align 8
  %23 = load i64, i64* %end1, align 8
  %cmp6 = icmp slt i64 %22, %23
  br i1 %cmp6, label %if.then.7, label %if.else

if.then.7:                                        ; preds = %if.end
  call void (i8*, ...) @error(i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.16, i32 0, i32 0)) #9
  unreachable

if.else:                                          ; preds = %if.end
  %24 = load i64, i64* %start1, align 8
  %25 = load i64, i64* %end1, align 8
  %cmp8 = icmp eq i64 %24, %25
  br i1 %cmp8, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else
  %26 = load i64, i64* %start2, align 8
  %27 = load i64, i64* %end2, align 8
  %cmp9 = icmp eq i64 %26, %27
  br i1 %cmp9, label %land.lhs.true, label %if.end.13

land.lhs.true:                                    ; preds = %lor.lhs.false, %if.else
  %28 = load i64, i64* %end1, align 8
  %29 = load i64, i64* %start2, align 8
  %cmp10 = icmp eq i64 %28, %29
  br i1 %cmp10, label %if.then.11, label %if.end.13

if.then.11:                                       ; preds = %land.lhs.true
  %call12 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call12, i64* %retval
  br label %return

if.end.13:                                        ; preds = %land.lhs.true, %lor.lhs.false
  br label %if.end.14

if.end.14:                                        ; preds = %if.end.13
  %30 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %31 = load i64, i64* %start1, align 8
  %call15 = call i64 @buf_charpos_to_bytepos(%struct.buffer* %30, i64 %31)
  store i64 %call15, i64* %start1_byte, align 8
  %32 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %33 = load i64, i64* %end2, align 8
  %call16 = call i64 @buf_charpos_to_bytepos(%struct.buffer* %32, i64 %33)
  store i64 %call16, i64* %end2_byte, align 8
  %34 = load i64, i64* %start1, align 8
  %35 = load i64, i64* %gap, align 8
  %cmp17 = icmp slt i64 %34, %35
  br i1 %cmp17, label %land.lhs.true.18, label %if.end.27

land.lhs.true.18:                                 ; preds = %if.end.14
  %36 = load i64, i64* %gap, align 8
  %37 = load i64, i64* %end2, align 8
  %cmp19 = icmp slt i64 %36, %37
  br i1 %cmp19, label %if.then.20, label %if.end.27

if.then.20:                                       ; preds = %land.lhs.true.18
  %38 = load i64, i64* %gap, align 8
  %39 = load i64, i64* %start1, align 8
  %sub21 = sub nsw i64 %38, %39
  %40 = load i64, i64* %end2, align 8
  %41 = load i64, i64* %gap, align 8
  %sub22 = sub nsw i64 %40, %41
  %cmp23 = icmp slt i64 %sub21, %sub22
  br i1 %cmp23, label %if.then.24, label %if.else.25

if.then.24:                                       ; preds = %if.then.20
  %42 = load i64, i64* %start1, align 8
  %43 = load i64, i64* %start1_byte, align 8
  call void @move_gap_both(i64 %42, i64 %43)
  br label %if.end.26

if.else.25:                                       ; preds = %if.then.20
  %44 = load i64, i64* %end2, align 8
  %45 = load i64, i64* %end2_byte, align 8
  call void @move_gap_both(i64 %44, i64 %45)
  br label %if.end.26

if.end.26:                                        ; preds = %if.else.25, %if.then.24
  br label %if.end.27

if.end.27:                                        ; preds = %if.end.26, %land.lhs.true.18, %if.end.14
  %46 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %47 = load i64, i64* %start2, align 8
  %call28 = call i64 @buf_charpos_to_bytepos(%struct.buffer* %46, i64 %47)
  store i64 %call28, i64* %start2_byte, align 8
  %48 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %49 = load i64, i64* %end1, align 8
  %call29 = call i64 @buf_charpos_to_bytepos(%struct.buffer* %48, i64 %49)
  %50 = load i64, i64* %start1_byte, align 8
  %sub30 = sub nsw i64 %call29, %50
  store i64 %sub30, i64* %len1_byte, align 8
  %51 = load i64, i64* %end2_byte, align 8
  %52 = load i64, i64* %start2_byte, align 8
  %sub31 = sub nsw i64 %51, %52
  store i64 %sub31, i64* %len2_byte, align 8
  %53 = load i64, i64* %end1, align 8
  %54 = load i64, i64* %start2, align 8
  %cmp32 = icmp eq i64 %53, %54
  br i1 %cmp32, label %if.then.33, label %if.else.117

if.then.33:                                       ; preds = %if.end.27
  %55 = load i64, i64* %start1, align 8
  %56 = load i64, i64* %end2, align 8
  call void @modify_text(i64 %55, i64 %56)
  %57 = load i64, i64* %start1, align 8
  %58 = load i64, i64* %len1, align 8
  %59 = load i64, i64* %len2, align 8
  %add = add nsw i64 %58, %59
  call void @record_change(i64 %57, i64 %add)
  %60 = load %struct.interval*, %struct.interval** %cur_intv, align 8
  %61 = load i64, i64* %start1, align 8
  %62 = load i64, i64* %len1, align 8
  %call34 = call %struct.interval* @copy_intervals(%struct.interval* %60, i64 %61, i64 %62)
  store %struct.interval* %call34, %struct.interval** %tmp_interval1, align 8
  %63 = load %struct.interval*, %struct.interval** %cur_intv, align 8
  %64 = load i64, i64* %start2, align 8
  %65 = load i64, i64* %len2, align 8
  %call35 = call %struct.interval* @copy_intervals(%struct.interval* %63, i64 %64, i64 %65)
  store %struct.interval* %call35, %struct.interval** %tmp_interval2, align 8
  %66 = load i64, i64* %buf, align 8
  %call36 = call %struct.interval* @validate_interval_range(i64 %66, i64* %startr1.addr, i64* %endr2.addr, i1 zeroext false)
  store %struct.interval* %call36, %struct.interval** %tmp_interval3, align 8
  %67 = load %struct.interval*, %struct.interval** %tmp_interval3, align 8
  %tobool = icmp ne %struct.interval* %67, null
  br i1 %tobool, label %if.then.37, label %if.end.39

if.then.37:                                       ; preds = %if.then.33
  %68 = load i64, i64* %startr1.addr, align 8
  %69 = load i64, i64* %endr2.addr, align 8
  %call38 = call i64 @builtin_lisp_symbol(i32 0)
  %70 = load i64, i64* %buf, align 8
  %71 = load %struct.interval*, %struct.interval** %tmp_interval3, align 8
  call void @set_text_properties_1(i64 %68, i64 %69, i64 %call38, i64 %70, %struct.interval* %71)
  br label %if.end.39

if.end.39:                                        ; preds = %if.then.37, %if.then.33
  store i64 16384, i64* %sa_avail, align 8
  %call40 = call i64 @SPECPDL_INDEX()
  store i64 %call40, i64* %sa_count, align 8
  store i8 0, i8* %sa_must_free, align 1
  %72 = load i64, i64* %len1_byte, align 8
  %73 = load i64, i64* %len2_byte, align 8
  %cmp41 = icmp slt i64 %72, %73
  br i1 %cmp41, label %if.then.42, label %if.else.71

if.then.42:                                       ; preds = %if.end.39
  %74 = load i64, i64* %len2_byte, align 8
  %75 = load i64, i64* %sa_avail, align 8
  %cmp43 = icmp sle i64 %74, %75
  br i1 %cmp43, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then.42
  %76 = load i64, i64* %len2_byte, align 8
  %77 = load i64, i64* %sa_avail, align 8
  %sub44 = sub nsw i64 %77, %76
  store i64 %sub44, i64* %sa_avail, align 8
  %78 = load i64, i64* %len2_byte, align 8
  %79 = alloca i8, i64 %78
  br label %cond.end

cond.false:                                       ; preds = %if.then.42
  store i8 1, i8* %sa_must_free, align 1
  %80 = load i64, i64* %len2_byte, align 8
  %call45 = call i8* @record_xmalloc(i64 %80)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %79, %cond.true ], [ %call45, %cond.false ]
  store i8* %cond, i8** %temp, align 8
  %81 = load i64, i64* %start1_byte, align 8
  %82 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text46 = getelementptr inbounds %struct.buffer, %struct.buffer* %82, i32 0, i32 73
  %83 = load %struct.buffer_text*, %struct.buffer_text** %text46, align 8
  %gpt_byte = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %83, i32 0, i32 3
  %84 = load i64, i64* %gpt_byte, align 8
  %cmp47 = icmp sge i64 %81, %84
  br i1 %cmp47, label %cond.true.48, label %cond.false.50

cond.true.48:                                     ; preds = %cond.end
  %85 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text49 = getelementptr inbounds %struct.buffer, %struct.buffer* %85, i32 0, i32 73
  %86 = load %struct.buffer_text*, %struct.buffer_text** %text49, align 8
  %gap_size = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %86, i32 0, i32 5
  %87 = load i64, i64* %gap_size, align 8
  br label %cond.end.51

cond.false.50:                                    ; preds = %cond.end
  br label %cond.end.51

cond.end.51:                                      ; preds = %cond.false.50, %cond.true.48
  %cond52 = phi i64 [ %87, %cond.true.48 ], [ 0, %cond.false.50 ]
  %88 = load i64, i64* %start1_byte, align 8
  %add53 = add nsw i64 %cond52, %88
  %89 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text54 = getelementptr inbounds %struct.buffer, %struct.buffer* %89, i32 0, i32 73
  %90 = load %struct.buffer_text*, %struct.buffer_text** %text54, align 8
  %beg = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %90, i32 0, i32 0
  %91 = load i8*, i8** %beg, align 8
  %add.ptr = getelementptr inbounds i8, i8* %91, i64 %add53
  %add.ptr55 = getelementptr inbounds i8, i8* %add.ptr, i64 -1
  store i8* %add.ptr55, i8** %start1_addr, align 8
  %92 = load i64, i64* %start2_byte, align 8
  %93 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text56 = getelementptr inbounds %struct.buffer, %struct.buffer* %93, i32 0, i32 73
  %94 = load %struct.buffer_text*, %struct.buffer_text** %text56, align 8
  %gpt_byte57 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %94, i32 0, i32 3
  %95 = load i64, i64* %gpt_byte57, align 8
  %cmp58 = icmp sge i64 %92, %95
  br i1 %cmp58, label %cond.true.59, label %cond.false.62

cond.true.59:                                     ; preds = %cond.end.51
  %96 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text60 = getelementptr inbounds %struct.buffer, %struct.buffer* %96, i32 0, i32 73
  %97 = load %struct.buffer_text*, %struct.buffer_text** %text60, align 8
  %gap_size61 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %97, i32 0, i32 5
  %98 = load i64, i64* %gap_size61, align 8
  br label %cond.end.63

cond.false.62:                                    ; preds = %cond.end.51
  br label %cond.end.63

cond.end.63:                                      ; preds = %cond.false.62, %cond.true.59
  %cond64 = phi i64 [ %98, %cond.true.59 ], [ 0, %cond.false.62 ]
  %99 = load i64, i64* %start2_byte, align 8
  %add65 = add nsw i64 %cond64, %99
  %100 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text66 = getelementptr inbounds %struct.buffer, %struct.buffer* %100, i32 0, i32 73
  %101 = load %struct.buffer_text*, %struct.buffer_text** %text66, align 8
  %beg67 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %101, i32 0, i32 0
  %102 = load i8*, i8** %beg67, align 8
  %add.ptr68 = getelementptr inbounds i8, i8* %102, i64 %add65
  %add.ptr69 = getelementptr inbounds i8, i8* %add.ptr68, i64 -1
  store i8* %add.ptr69, i8** %start2_addr, align 8
  %103 = load i8*, i8** %temp, align 8
  %104 = load i8*, i8** %start2_addr, align 8
  %105 = load i64, i64* %len2_byte, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %103, i8* %104, i64 %105, i32 1, i1 false)
  %106 = load i8*, i8** %start1_addr, align 8
  %107 = load i64, i64* %len2_byte, align 8
  %add.ptr70 = getelementptr inbounds i8, i8* %106, i64 %107
  %108 = load i8*, i8** %start1_addr, align 8
  %109 = load i64, i64* %len1_byte, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %add.ptr70, i8* %108, i64 %109, i32 1, i1 false)
  %110 = load i8*, i8** %start1_addr, align 8
  %111 = load i8*, i8** %temp, align 8
  %112 = load i64, i64* %len2_byte, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %110, i8* %111, i64 %112, i32 1, i1 false)
  br label %if.end.108

if.else.71:                                       ; preds = %if.end.39
  %113 = load i64, i64* %len1_byte, align 8
  %114 = load i64, i64* %sa_avail, align 8
  %cmp72 = icmp sle i64 %113, %114
  br i1 %cmp72, label %cond.true.73, label %cond.false.75

cond.true.73:                                     ; preds = %if.else.71
  %115 = load i64, i64* %len1_byte, align 8
  %116 = load i64, i64* %sa_avail, align 8
  %sub74 = sub nsw i64 %116, %115
  store i64 %sub74, i64* %sa_avail, align 8
  %117 = load i64, i64* %len1_byte, align 8
  %118 = alloca i8, i64 %117
  br label %cond.end.77

cond.false.75:                                    ; preds = %if.else.71
  store i8 1, i8* %sa_must_free, align 1
  %119 = load i64, i64* %len1_byte, align 8
  %call76 = call i8* @record_xmalloc(i64 %119)
  br label %cond.end.77

cond.end.77:                                      ; preds = %cond.false.75, %cond.true.73
  %cond78 = phi i8* [ %118, %cond.true.73 ], [ %call76, %cond.false.75 ]
  store i8* %cond78, i8** %temp, align 8
  %120 = load i64, i64* %start1_byte, align 8
  %121 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text79 = getelementptr inbounds %struct.buffer, %struct.buffer* %121, i32 0, i32 73
  %122 = load %struct.buffer_text*, %struct.buffer_text** %text79, align 8
  %gpt_byte80 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %122, i32 0, i32 3
  %123 = load i64, i64* %gpt_byte80, align 8
  %cmp81 = icmp sge i64 %120, %123
  br i1 %cmp81, label %cond.true.82, label %cond.false.85

cond.true.82:                                     ; preds = %cond.end.77
  %124 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text83 = getelementptr inbounds %struct.buffer, %struct.buffer* %124, i32 0, i32 73
  %125 = load %struct.buffer_text*, %struct.buffer_text** %text83, align 8
  %gap_size84 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %125, i32 0, i32 5
  %126 = load i64, i64* %gap_size84, align 8
  br label %cond.end.86

cond.false.85:                                    ; preds = %cond.end.77
  br label %cond.end.86

cond.end.86:                                      ; preds = %cond.false.85, %cond.true.82
  %cond87 = phi i64 [ %126, %cond.true.82 ], [ 0, %cond.false.85 ]
  %127 = load i64, i64* %start1_byte, align 8
  %add88 = add nsw i64 %cond87, %127
  %128 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text89 = getelementptr inbounds %struct.buffer, %struct.buffer* %128, i32 0, i32 73
  %129 = load %struct.buffer_text*, %struct.buffer_text** %text89, align 8
  %beg90 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %129, i32 0, i32 0
  %130 = load i8*, i8** %beg90, align 8
  %add.ptr91 = getelementptr inbounds i8, i8* %130, i64 %add88
  %add.ptr92 = getelementptr inbounds i8, i8* %add.ptr91, i64 -1
  store i8* %add.ptr92, i8** %start1_addr, align 8
  %131 = load i64, i64* %start2_byte, align 8
  %132 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text93 = getelementptr inbounds %struct.buffer, %struct.buffer* %132, i32 0, i32 73
  %133 = load %struct.buffer_text*, %struct.buffer_text** %text93, align 8
  %gpt_byte94 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %133, i32 0, i32 3
  %134 = load i64, i64* %gpt_byte94, align 8
  %cmp95 = icmp sge i64 %131, %134
  br i1 %cmp95, label %cond.true.96, label %cond.false.99

cond.true.96:                                     ; preds = %cond.end.86
  %135 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text97 = getelementptr inbounds %struct.buffer, %struct.buffer* %135, i32 0, i32 73
  %136 = load %struct.buffer_text*, %struct.buffer_text** %text97, align 8
  %gap_size98 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %136, i32 0, i32 5
  %137 = load i64, i64* %gap_size98, align 8
  br label %cond.end.100

cond.false.99:                                    ; preds = %cond.end.86
  br label %cond.end.100

cond.end.100:                                     ; preds = %cond.false.99, %cond.true.96
  %cond101 = phi i64 [ %137, %cond.true.96 ], [ 0, %cond.false.99 ]
  %138 = load i64, i64* %start2_byte, align 8
  %add102 = add nsw i64 %cond101, %138
  %139 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text103 = getelementptr inbounds %struct.buffer, %struct.buffer* %139, i32 0, i32 73
  %140 = load %struct.buffer_text*, %struct.buffer_text** %text103, align 8
  %beg104 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %140, i32 0, i32 0
  %141 = load i8*, i8** %beg104, align 8
  %add.ptr105 = getelementptr inbounds i8, i8* %141, i64 %add102
  %add.ptr106 = getelementptr inbounds i8, i8* %add.ptr105, i64 -1
  store i8* %add.ptr106, i8** %start2_addr, align 8
  %142 = load i8*, i8** %temp, align 8
  %143 = load i8*, i8** %start1_addr, align 8
  %144 = load i64, i64* %len1_byte, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %142, i8* %143, i64 %144, i32 1, i1 false)
  %145 = load i8*, i8** %start1_addr, align 8
  %146 = load i8*, i8** %start2_addr, align 8
  %147 = load i64, i64* %len2_byte, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %145, i8* %146, i64 %147, i32 1, i1 false)
  %148 = load i8*, i8** %start1_addr, align 8
  %149 = load i64, i64* %len2_byte, align 8
  %add.ptr107 = getelementptr inbounds i8, i8* %148, i64 %149
  %150 = load i8*, i8** %temp, align 8
  %151 = load i64, i64* %len1_byte, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %add.ptr107, i8* %150, i64 %151, i32 1, i1 false)
  br label %if.end.108

if.end.108:                                       ; preds = %cond.end.100, %cond.end.63
  br label %do.body

do.body:                                          ; preds = %if.end.108
  %152 = load i8, i8* %sa_must_free, align 1
  %tobool109 = trunc i8 %152 to i1
  br i1 %tobool109, label %if.then.110, label %if.end.113

if.then.110:                                      ; preds = %do.body
  store i8 0, i8* %sa_must_free, align 1
  %153 = load i64, i64* %sa_count, align 8
  %call111 = call i64 @builtin_lisp_symbol(i32 0)
  %call112 = call i64 @unbind_to(i64 %153, i64 %call111)
  br label %if.end.113

if.end.113:                                       ; preds = %if.then.110, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end.113
  %154 = load %struct.interval*, %struct.interval** %tmp_interval1, align 8
  %155 = load i64, i64* %start1, align 8
  %156 = load i64, i64* %len2, align 8
  %add114 = add nsw i64 %155, %156
  %157 = load i64, i64* %len1, align 8
  %158 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  call void @graft_intervals_into_buffer(%struct.interval* %154, i64 %add114, i64 %157, %struct.buffer* %158, i1 zeroext false)
  %159 = load %struct.interval*, %struct.interval** %tmp_interval2, align 8
  %160 = load i64, i64* %start1, align 8
  %161 = load i64, i64* %len2, align 8
  %162 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  call void @graft_intervals_into_buffer(%struct.interval* %159, i64 %160, i64 %161, %struct.buffer* %162, i1 zeroext false)
  %163 = load i64, i64* %start1, align 8
  %164 = load i64, i64* %start1, align 8
  %165 = load i64, i64* %len2, align 8
  %add115 = add nsw i64 %164, %165
  call void @update_compositions(i64 %163, i64 %add115, i32 3)
  %166 = load i64, i64* %start1, align 8
  %167 = load i64, i64* %len2, align 8
  %add116 = add nsw i64 %166, %167
  %168 = load i64, i64* %end2, align 8
  call void @update_compositions(i64 %add116, i64 %168, i32 2)
  br label %if.end.310

if.else.117:                                      ; preds = %if.end.27
  %169 = load i64, i64* %start2_byte, align 8
  %170 = load i64, i64* %start1_byte, align 8
  %171 = load i64, i64* %len1_byte, align 8
  %add118 = add nsw i64 %170, %171
  %sub119 = sub nsw i64 %169, %add118
  store i64 %sub119, i64* %len_mid, align 8
  %172 = load i64, i64* %len1_byte, align 8
  %173 = load i64, i64* %len2_byte, align 8
  %cmp120 = icmp eq i64 %172, %173
  br i1 %cmp120, label %if.then.121, label %if.else.180

if.then.121:                                      ; preds = %if.else.117
  store i64 16384, i64* %sa_avail122, align 8
  %call124 = call i64 @SPECPDL_INDEX()
  store i64 %call124, i64* %sa_count123, align 8
  store i8 0, i8* %sa_must_free125, align 1
  %174 = load i64, i64* %start1, align 8
  %175 = load i64, i64* %end1, align 8
  call void @modify_text(i64 %174, i64 %175)
  %176 = load i64, i64* %start2, align 8
  %177 = load i64, i64* %end2, align 8
  call void @modify_text(i64 %176, i64 %177)
  %178 = load i64, i64* %start1, align 8
  %179 = load i64, i64* %len1, align 8
  call void @record_change(i64 %178, i64 %179)
  %180 = load i64, i64* %start2, align 8
  %181 = load i64, i64* %len2, align 8
  call void @record_change(i64 %180, i64 %181)
  %182 = load %struct.interval*, %struct.interval** %cur_intv, align 8
  %183 = load i64, i64* %start1, align 8
  %184 = load i64, i64* %len1, align 8
  %call126 = call %struct.interval* @copy_intervals(%struct.interval* %182, i64 %183, i64 %184)
  store %struct.interval* %call126, %struct.interval** %tmp_interval1, align 8
  %185 = load %struct.interval*, %struct.interval** %cur_intv, align 8
  %186 = load i64, i64* %start2, align 8
  %187 = load i64, i64* %len2, align 8
  %call127 = call %struct.interval* @copy_intervals(%struct.interval* %185, i64 %186, i64 %187)
  store %struct.interval* %call127, %struct.interval** %tmp_interval2, align 8
  %188 = load i64, i64* %buf, align 8
  %call128 = call %struct.interval* @validate_interval_range(i64 %188, i64* %startr1.addr, i64* %endr1.addr, i1 zeroext false)
  store %struct.interval* %call128, %struct.interval** %tmp_interval3, align 8
  %189 = load %struct.interval*, %struct.interval** %tmp_interval3, align 8
  %tobool129 = icmp ne %struct.interval* %189, null
  br i1 %tobool129, label %if.then.130, label %if.end.132

if.then.130:                                      ; preds = %if.then.121
  %190 = load i64, i64* %startr1.addr, align 8
  %191 = load i64, i64* %endr1.addr, align 8
  %call131 = call i64 @builtin_lisp_symbol(i32 0)
  %192 = load i64, i64* %buf, align 8
  %193 = load %struct.interval*, %struct.interval** %tmp_interval3, align 8
  call void @set_text_properties_1(i64 %190, i64 %191, i64 %call131, i64 %192, %struct.interval* %193)
  br label %if.end.132

if.end.132:                                       ; preds = %if.then.130, %if.then.121
  %194 = load i64, i64* %buf, align 8
  %call133 = call %struct.interval* @validate_interval_range(i64 %194, i64* %startr2.addr, i64* %endr2.addr, i1 zeroext false)
  store %struct.interval* %call133, %struct.interval** %tmp_interval3, align 8
  %195 = load %struct.interval*, %struct.interval** %tmp_interval3, align 8
  %tobool134 = icmp ne %struct.interval* %195, null
  br i1 %tobool134, label %if.then.135, label %if.end.137

if.then.135:                                      ; preds = %if.end.132
  %196 = load i64, i64* %startr2.addr, align 8
  %197 = load i64, i64* %endr2.addr, align 8
  %call136 = call i64 @builtin_lisp_symbol(i32 0)
  %198 = load i64, i64* %buf, align 8
  %199 = load %struct.interval*, %struct.interval** %tmp_interval3, align 8
  call void @set_text_properties_1(i64 %196, i64 %197, i64 %call136, i64 %198, %struct.interval* %199)
  br label %if.end.137

if.end.137:                                       ; preds = %if.then.135, %if.end.132
  %200 = load i64, i64* %len1_byte, align 8
  %201 = load i64, i64* %sa_avail122, align 8
  %cmp138 = icmp sle i64 %200, %201
  br i1 %cmp138, label %cond.true.139, label %cond.false.141

cond.true.139:                                    ; preds = %if.end.137
  %202 = load i64, i64* %len1_byte, align 8
  %203 = load i64, i64* %sa_avail122, align 8
  %sub140 = sub nsw i64 %203, %202
  store i64 %sub140, i64* %sa_avail122, align 8
  %204 = load i64, i64* %len1_byte, align 8
  %205 = alloca i8, i64 %204
  br label %cond.end.143

cond.false.141:                                   ; preds = %if.end.137
  store i8 1, i8* %sa_must_free125, align 1
  %206 = load i64, i64* %len1_byte, align 8
  %call142 = call i8* @record_xmalloc(i64 %206)
  br label %cond.end.143

cond.end.143:                                     ; preds = %cond.false.141, %cond.true.139
  %cond144 = phi i8* [ %205, %cond.true.139 ], [ %call142, %cond.false.141 ]
  store i8* %cond144, i8** %temp, align 8
  %207 = load i64, i64* %start1_byte, align 8
  %208 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text145 = getelementptr inbounds %struct.buffer, %struct.buffer* %208, i32 0, i32 73
  %209 = load %struct.buffer_text*, %struct.buffer_text** %text145, align 8
  %gpt_byte146 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %209, i32 0, i32 3
  %210 = load i64, i64* %gpt_byte146, align 8
  %cmp147 = icmp sge i64 %207, %210
  br i1 %cmp147, label %cond.true.148, label %cond.false.151

cond.true.148:                                    ; preds = %cond.end.143
  %211 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text149 = getelementptr inbounds %struct.buffer, %struct.buffer* %211, i32 0, i32 73
  %212 = load %struct.buffer_text*, %struct.buffer_text** %text149, align 8
  %gap_size150 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %212, i32 0, i32 5
  %213 = load i64, i64* %gap_size150, align 8
  br label %cond.end.152

cond.false.151:                                   ; preds = %cond.end.143
  br label %cond.end.152

cond.end.152:                                     ; preds = %cond.false.151, %cond.true.148
  %cond153 = phi i64 [ %213, %cond.true.148 ], [ 0, %cond.false.151 ]
  %214 = load i64, i64* %start1_byte, align 8
  %add154 = add nsw i64 %cond153, %214
  %215 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text155 = getelementptr inbounds %struct.buffer, %struct.buffer* %215, i32 0, i32 73
  %216 = load %struct.buffer_text*, %struct.buffer_text** %text155, align 8
  %beg156 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %216, i32 0, i32 0
  %217 = load i8*, i8** %beg156, align 8
  %add.ptr157 = getelementptr inbounds i8, i8* %217, i64 %add154
  %add.ptr158 = getelementptr inbounds i8, i8* %add.ptr157, i64 -1
  store i8* %add.ptr158, i8** %start1_addr, align 8
  %218 = load i64, i64* %start2_byte, align 8
  %219 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text159 = getelementptr inbounds %struct.buffer, %struct.buffer* %219, i32 0, i32 73
  %220 = load %struct.buffer_text*, %struct.buffer_text** %text159, align 8
  %gpt_byte160 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %220, i32 0, i32 3
  %221 = load i64, i64* %gpt_byte160, align 8
  %cmp161 = icmp sge i64 %218, %221
  br i1 %cmp161, label %cond.true.162, label %cond.false.165

cond.true.162:                                    ; preds = %cond.end.152
  %222 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text163 = getelementptr inbounds %struct.buffer, %struct.buffer* %222, i32 0, i32 73
  %223 = load %struct.buffer_text*, %struct.buffer_text** %text163, align 8
  %gap_size164 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %223, i32 0, i32 5
  %224 = load i64, i64* %gap_size164, align 8
  br label %cond.end.166

cond.false.165:                                   ; preds = %cond.end.152
  br label %cond.end.166

cond.end.166:                                     ; preds = %cond.false.165, %cond.true.162
  %cond167 = phi i64 [ %224, %cond.true.162 ], [ 0, %cond.false.165 ]
  %225 = load i64, i64* %start2_byte, align 8
  %add168 = add nsw i64 %cond167, %225
  %226 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text169 = getelementptr inbounds %struct.buffer, %struct.buffer* %226, i32 0, i32 73
  %227 = load %struct.buffer_text*, %struct.buffer_text** %text169, align 8
  %beg170 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %227, i32 0, i32 0
  %228 = load i8*, i8** %beg170, align 8
  %add.ptr171 = getelementptr inbounds i8, i8* %228, i64 %add168
  %add.ptr172 = getelementptr inbounds i8, i8* %add.ptr171, i64 -1
  store i8* %add.ptr172, i8** %start2_addr, align 8
  %229 = load i8*, i8** %temp, align 8
  %230 = load i8*, i8** %start1_addr, align 8
  %231 = load i64, i64* %len1_byte, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %229, i8* %230, i64 %231, i32 1, i1 false)
  %232 = load i8*, i8** %start1_addr, align 8
  %233 = load i8*, i8** %start2_addr, align 8
  %234 = load i64, i64* %len2_byte, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %232, i8* %233, i64 %234, i32 1, i1 false)
  %235 = load i8*, i8** %start2_addr, align 8
  %236 = load i8*, i8** %temp, align 8
  %237 = load i64, i64* %len1_byte, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %235, i8* %236, i64 %237, i32 1, i1 false)
  br label %do.body.173

do.body.173:                                      ; preds = %cond.end.166
  %238 = load i8, i8* %sa_must_free125, align 1
  %tobool174 = trunc i8 %238 to i1
  br i1 %tobool174, label %if.then.175, label %if.end.178

if.then.175:                                      ; preds = %do.body.173
  store i8 0, i8* %sa_must_free125, align 1
  %239 = load i64, i64* %sa_count123, align 8
  %call176 = call i64 @builtin_lisp_symbol(i32 0)
  %call177 = call i64 @unbind_to(i64 %239, i64 %call176)
  br label %if.end.178

if.end.178:                                       ; preds = %if.then.175, %do.body.173
  br label %do.end.179

do.end.179:                                       ; preds = %if.end.178
  %240 = load %struct.interval*, %struct.interval** %tmp_interval1, align 8
  %241 = load i64, i64* %start2, align 8
  %242 = load i64, i64* %len1, align 8
  %243 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  call void @graft_intervals_into_buffer(%struct.interval* %240, i64 %241, i64 %242, %struct.buffer* %243, i1 zeroext false)
  %244 = load %struct.interval*, %struct.interval** %tmp_interval2, align 8
  %245 = load i64, i64* %start1, align 8
  %246 = load i64, i64* %len2, align 8
  %247 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  call void @graft_intervals_into_buffer(%struct.interval* %244, i64 %245, i64 %246, %struct.buffer* %247, i1 zeroext false)
  br label %if.end.307

if.else.180:                                      ; preds = %if.else.117
  %248 = load i64, i64* %len1_byte, align 8
  %249 = load i64, i64* %len2_byte, align 8
  %cmp181 = icmp slt i64 %248, %249
  br i1 %cmp181, label %if.then.182, label %if.else.244

if.then.182:                                      ; preds = %if.else.180
  store i64 16384, i64* %sa_avail183, align 8
  %call185 = call i64 @SPECPDL_INDEX()
  store i64 %call185, i64* %sa_count184, align 8
  store i8 0, i8* %sa_must_free186, align 1
  %250 = load i64, i64* %start1, align 8
  %251 = load i64, i64* %end2, align 8
  call void @modify_text(i64 %250, i64 %251)
  %252 = load i64, i64* %start1, align 8
  %253 = load i64, i64* %end2, align 8
  %254 = load i64, i64* %start1, align 8
  %sub187 = sub nsw i64 %253, %254
  call void @record_change(i64 %252, i64 %sub187)
  %255 = load %struct.interval*, %struct.interval** %cur_intv, align 8
  %256 = load i64, i64* %start1, align 8
  %257 = load i64, i64* %len1, align 8
  %call188 = call %struct.interval* @copy_intervals(%struct.interval* %255, i64 %256, i64 %257)
  store %struct.interval* %call188, %struct.interval** %tmp_interval1, align 8
  %258 = load %struct.interval*, %struct.interval** %cur_intv, align 8
  %259 = load i64, i64* %end1, align 8
  %260 = load i64, i64* %len_mid, align 8
  %call189 = call %struct.interval* @copy_intervals(%struct.interval* %258, i64 %259, i64 %260)
  store %struct.interval* %call189, %struct.interval** %tmp_interval_mid, align 8
  %261 = load %struct.interval*, %struct.interval** %cur_intv, align 8
  %262 = load i64, i64* %start2, align 8
  %263 = load i64, i64* %len2, align 8
  %call190 = call %struct.interval* @copy_intervals(%struct.interval* %261, i64 %262, i64 %263)
  store %struct.interval* %call190, %struct.interval** %tmp_interval2, align 8
  %264 = load i64, i64* %buf, align 8
  %call191 = call %struct.interval* @validate_interval_range(i64 %264, i64* %startr1.addr, i64* %endr2.addr, i1 zeroext false)
  store %struct.interval* %call191, %struct.interval** %tmp_interval3, align 8
  %265 = load %struct.interval*, %struct.interval** %tmp_interval3, align 8
  %tobool192 = icmp ne %struct.interval* %265, null
  br i1 %tobool192, label %if.then.193, label %if.end.195

if.then.193:                                      ; preds = %if.then.182
  %266 = load i64, i64* %startr1.addr, align 8
  %267 = load i64, i64* %endr2.addr, align 8
  %call194 = call i64 @builtin_lisp_symbol(i32 0)
  %268 = load i64, i64* %buf, align 8
  %269 = load %struct.interval*, %struct.interval** %tmp_interval3, align 8
  call void @set_text_properties_1(i64 %266, i64 %267, i64 %call194, i64 %268, %struct.interval* %269)
  br label %if.end.195

if.end.195:                                       ; preds = %if.then.193, %if.then.182
  %270 = load i64, i64* %len2_byte, align 8
  %271 = load i64, i64* %sa_avail183, align 8
  %cmp196 = icmp sle i64 %270, %271
  br i1 %cmp196, label %cond.true.197, label %cond.false.199

cond.true.197:                                    ; preds = %if.end.195
  %272 = load i64, i64* %len2_byte, align 8
  %273 = load i64, i64* %sa_avail183, align 8
  %sub198 = sub nsw i64 %273, %272
  store i64 %sub198, i64* %sa_avail183, align 8
  %274 = load i64, i64* %len2_byte, align 8
  %275 = alloca i8, i64 %274
  br label %cond.end.201

cond.false.199:                                   ; preds = %if.end.195
  store i8 1, i8* %sa_must_free186, align 1
  %276 = load i64, i64* %len2_byte, align 8
  %call200 = call i8* @record_xmalloc(i64 %276)
  br label %cond.end.201

cond.end.201:                                     ; preds = %cond.false.199, %cond.true.197
  %cond202 = phi i8* [ %275, %cond.true.197 ], [ %call200, %cond.false.199 ]
  store i8* %cond202, i8** %temp, align 8
  %277 = load i64, i64* %start1_byte, align 8
  %278 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text203 = getelementptr inbounds %struct.buffer, %struct.buffer* %278, i32 0, i32 73
  %279 = load %struct.buffer_text*, %struct.buffer_text** %text203, align 8
  %gpt_byte204 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %279, i32 0, i32 3
  %280 = load i64, i64* %gpt_byte204, align 8
  %cmp205 = icmp sge i64 %277, %280
  br i1 %cmp205, label %cond.true.206, label %cond.false.209

cond.true.206:                                    ; preds = %cond.end.201
  %281 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text207 = getelementptr inbounds %struct.buffer, %struct.buffer* %281, i32 0, i32 73
  %282 = load %struct.buffer_text*, %struct.buffer_text** %text207, align 8
  %gap_size208 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %282, i32 0, i32 5
  %283 = load i64, i64* %gap_size208, align 8
  br label %cond.end.210

cond.false.209:                                   ; preds = %cond.end.201
  br label %cond.end.210

cond.end.210:                                     ; preds = %cond.false.209, %cond.true.206
  %cond211 = phi i64 [ %283, %cond.true.206 ], [ 0, %cond.false.209 ]
  %284 = load i64, i64* %start1_byte, align 8
  %add212 = add nsw i64 %cond211, %284
  %285 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text213 = getelementptr inbounds %struct.buffer, %struct.buffer* %285, i32 0, i32 73
  %286 = load %struct.buffer_text*, %struct.buffer_text** %text213, align 8
  %beg214 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %286, i32 0, i32 0
  %287 = load i8*, i8** %beg214, align 8
  %add.ptr215 = getelementptr inbounds i8, i8* %287, i64 %add212
  %add.ptr216 = getelementptr inbounds i8, i8* %add.ptr215, i64 -1
  store i8* %add.ptr216, i8** %start1_addr, align 8
  %288 = load i64, i64* %start2_byte, align 8
  %289 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text217 = getelementptr inbounds %struct.buffer, %struct.buffer* %289, i32 0, i32 73
  %290 = load %struct.buffer_text*, %struct.buffer_text** %text217, align 8
  %gpt_byte218 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %290, i32 0, i32 3
  %291 = load i64, i64* %gpt_byte218, align 8
  %cmp219 = icmp sge i64 %288, %291
  br i1 %cmp219, label %cond.true.220, label %cond.false.223

cond.true.220:                                    ; preds = %cond.end.210
  %292 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text221 = getelementptr inbounds %struct.buffer, %struct.buffer* %292, i32 0, i32 73
  %293 = load %struct.buffer_text*, %struct.buffer_text** %text221, align 8
  %gap_size222 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %293, i32 0, i32 5
  %294 = load i64, i64* %gap_size222, align 8
  br label %cond.end.224

cond.false.223:                                   ; preds = %cond.end.210
  br label %cond.end.224

cond.end.224:                                     ; preds = %cond.false.223, %cond.true.220
  %cond225 = phi i64 [ %294, %cond.true.220 ], [ 0, %cond.false.223 ]
  %295 = load i64, i64* %start2_byte, align 8
  %add226 = add nsw i64 %cond225, %295
  %296 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text227 = getelementptr inbounds %struct.buffer, %struct.buffer* %296, i32 0, i32 73
  %297 = load %struct.buffer_text*, %struct.buffer_text** %text227, align 8
  %beg228 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %297, i32 0, i32 0
  %298 = load i8*, i8** %beg228, align 8
  %add.ptr229 = getelementptr inbounds i8, i8* %298, i64 %add226
  %add.ptr230 = getelementptr inbounds i8, i8* %add.ptr229, i64 -1
  store i8* %add.ptr230, i8** %start2_addr, align 8
  %299 = load i8*, i8** %temp, align 8
  %300 = load i8*, i8** %start2_addr, align 8
  %301 = load i64, i64* %len2_byte, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %299, i8* %300, i64 %301, i32 1, i1 false)
  %302 = load i8*, i8** %start1_addr, align 8
  %303 = load i64, i64* %len_mid, align 8
  %add.ptr231 = getelementptr inbounds i8, i8* %302, i64 %303
  %304 = load i64, i64* %len2_byte, align 8
  %add.ptr232 = getelementptr inbounds i8, i8* %add.ptr231, i64 %304
  %305 = load i8*, i8** %start1_addr, align 8
  %306 = load i64, i64* %len1_byte, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %add.ptr232, i8* %305, i64 %306, i32 1, i1 false)
  %307 = load i8*, i8** %start1_addr, align 8
  %308 = load i64, i64* %len2_byte, align 8
  %add.ptr233 = getelementptr inbounds i8, i8* %307, i64 %308
  %309 = load i8*, i8** %start1_addr, align 8
  %310 = load i64, i64* %len1_byte, align 8
  %add.ptr234 = getelementptr inbounds i8, i8* %309, i64 %310
  %311 = load i64, i64* %len_mid, align 8
  call void @llvm.memmove.p0i8.p0i8.i64(i8* %add.ptr233, i8* %add.ptr234, i64 %311, i32 1, i1 false)
  %312 = load i8*, i8** %start1_addr, align 8
  %313 = load i8*, i8** %temp, align 8
  %314 = load i64, i64* %len2_byte, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %312, i8* %313, i64 %314, i32 1, i1 false)
  br label %do.body.235

do.body.235:                                      ; preds = %cond.end.224
  %315 = load i8, i8* %sa_must_free186, align 1
  %tobool236 = trunc i8 %315 to i1
  br i1 %tobool236, label %if.then.237, label %if.end.240

if.then.237:                                      ; preds = %do.body.235
  store i8 0, i8* %sa_must_free186, align 1
  %316 = load i64, i64* %sa_count184, align 8
  %call238 = call i64 @builtin_lisp_symbol(i32 0)
  %call239 = call i64 @unbind_to(i64 %316, i64 %call238)
  br label %if.end.240

if.end.240:                                       ; preds = %if.then.237, %do.body.235
  br label %do.end.241

do.end.241:                                       ; preds = %if.end.240
  %317 = load %struct.interval*, %struct.interval** %tmp_interval1, align 8
  %318 = load i64, i64* %end2, align 8
  %319 = load i64, i64* %len1, align 8
  %sub242 = sub nsw i64 %318, %319
  %320 = load i64, i64* %len1, align 8
  %321 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  call void @graft_intervals_into_buffer(%struct.interval* %317, i64 %sub242, i64 %320, %struct.buffer* %321, i1 zeroext false)
  %322 = load %struct.interval*, %struct.interval** %tmp_interval_mid, align 8
  %323 = load i64, i64* %start1, align 8
  %324 = load i64, i64* %len2, align 8
  %add243 = add nsw i64 %323, %324
  %325 = load i64, i64* %len_mid, align 8
  %326 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  call void @graft_intervals_into_buffer(%struct.interval* %322, i64 %add243, i64 %325, %struct.buffer* %326, i1 zeroext false)
  %327 = load %struct.interval*, %struct.interval** %tmp_interval2, align 8
  %328 = load i64, i64* %start1, align 8
  %329 = load i64, i64* %len2, align 8
  %330 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  call void @graft_intervals_into_buffer(%struct.interval* %327, i64 %328, i64 %329, %struct.buffer* %330, i1 zeroext false)
  br label %if.end.306

if.else.244:                                      ; preds = %if.else.180
  store i64 16384, i64* %sa_avail245, align 8
  %call247 = call i64 @SPECPDL_INDEX()
  store i64 %call247, i64* %sa_count246, align 8
  store i8 0, i8* %sa_must_free248, align 1
  %331 = load i64, i64* %start1, align 8
  %332 = load i64, i64* %end2, align 8
  %333 = load i64, i64* %start1, align 8
  %sub249 = sub nsw i64 %332, %333
  call void @record_change(i64 %331, i64 %sub249)
  %334 = load i64, i64* %start1, align 8
  %335 = load i64, i64* %end2, align 8
  call void @modify_text(i64 %334, i64 %335)
  %336 = load %struct.interval*, %struct.interval** %cur_intv, align 8
  %337 = load i64, i64* %start1, align 8
  %338 = load i64, i64* %len1, align 8
  %call250 = call %struct.interval* @copy_intervals(%struct.interval* %336, i64 %337, i64 %338)
  store %struct.interval* %call250, %struct.interval** %tmp_interval1, align 8
  %339 = load %struct.interval*, %struct.interval** %cur_intv, align 8
  %340 = load i64, i64* %end1, align 8
  %341 = load i64, i64* %len_mid, align 8
  %call251 = call %struct.interval* @copy_intervals(%struct.interval* %339, i64 %340, i64 %341)
  store %struct.interval* %call251, %struct.interval** %tmp_interval_mid, align 8
  %342 = load %struct.interval*, %struct.interval** %cur_intv, align 8
  %343 = load i64, i64* %start2, align 8
  %344 = load i64, i64* %len2, align 8
  %call252 = call %struct.interval* @copy_intervals(%struct.interval* %342, i64 %343, i64 %344)
  store %struct.interval* %call252, %struct.interval** %tmp_interval2, align 8
  %345 = load i64, i64* %buf, align 8
  %call253 = call %struct.interval* @validate_interval_range(i64 %345, i64* %startr1.addr, i64* %endr2.addr, i1 zeroext false)
  store %struct.interval* %call253, %struct.interval** %tmp_interval3, align 8
  %346 = load %struct.interval*, %struct.interval** %tmp_interval3, align 8
  %tobool254 = icmp ne %struct.interval* %346, null
  br i1 %tobool254, label %if.then.255, label %if.end.257

if.then.255:                                      ; preds = %if.else.244
  %347 = load i64, i64* %startr1.addr, align 8
  %348 = load i64, i64* %endr2.addr, align 8
  %call256 = call i64 @builtin_lisp_symbol(i32 0)
  %349 = load i64, i64* %buf, align 8
  %350 = load %struct.interval*, %struct.interval** %tmp_interval3, align 8
  call void @set_text_properties_1(i64 %347, i64 %348, i64 %call256, i64 %349, %struct.interval* %350)
  br label %if.end.257

if.end.257:                                       ; preds = %if.then.255, %if.else.244
  %351 = load i64, i64* %len1_byte, align 8
  %352 = load i64, i64* %sa_avail245, align 8
  %cmp258 = icmp sle i64 %351, %352
  br i1 %cmp258, label %cond.true.259, label %cond.false.261

cond.true.259:                                    ; preds = %if.end.257
  %353 = load i64, i64* %len1_byte, align 8
  %354 = load i64, i64* %sa_avail245, align 8
  %sub260 = sub nsw i64 %354, %353
  store i64 %sub260, i64* %sa_avail245, align 8
  %355 = load i64, i64* %len1_byte, align 8
  %356 = alloca i8, i64 %355
  br label %cond.end.263

cond.false.261:                                   ; preds = %if.end.257
  store i8 1, i8* %sa_must_free248, align 1
  %357 = load i64, i64* %len1_byte, align 8
  %call262 = call i8* @record_xmalloc(i64 %357)
  br label %cond.end.263

cond.end.263:                                     ; preds = %cond.false.261, %cond.true.259
  %cond264 = phi i8* [ %356, %cond.true.259 ], [ %call262, %cond.false.261 ]
  store i8* %cond264, i8** %temp, align 8
  %358 = load i64, i64* %start1_byte, align 8
  %359 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text265 = getelementptr inbounds %struct.buffer, %struct.buffer* %359, i32 0, i32 73
  %360 = load %struct.buffer_text*, %struct.buffer_text** %text265, align 8
  %gpt_byte266 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %360, i32 0, i32 3
  %361 = load i64, i64* %gpt_byte266, align 8
  %cmp267 = icmp sge i64 %358, %361
  br i1 %cmp267, label %cond.true.268, label %cond.false.271

cond.true.268:                                    ; preds = %cond.end.263
  %362 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text269 = getelementptr inbounds %struct.buffer, %struct.buffer* %362, i32 0, i32 73
  %363 = load %struct.buffer_text*, %struct.buffer_text** %text269, align 8
  %gap_size270 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %363, i32 0, i32 5
  %364 = load i64, i64* %gap_size270, align 8
  br label %cond.end.272

cond.false.271:                                   ; preds = %cond.end.263
  br label %cond.end.272

cond.end.272:                                     ; preds = %cond.false.271, %cond.true.268
  %cond273 = phi i64 [ %364, %cond.true.268 ], [ 0, %cond.false.271 ]
  %365 = load i64, i64* %start1_byte, align 8
  %add274 = add nsw i64 %cond273, %365
  %366 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text275 = getelementptr inbounds %struct.buffer, %struct.buffer* %366, i32 0, i32 73
  %367 = load %struct.buffer_text*, %struct.buffer_text** %text275, align 8
  %beg276 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %367, i32 0, i32 0
  %368 = load i8*, i8** %beg276, align 8
  %add.ptr277 = getelementptr inbounds i8, i8* %368, i64 %add274
  %add.ptr278 = getelementptr inbounds i8, i8* %add.ptr277, i64 -1
  store i8* %add.ptr278, i8** %start1_addr, align 8
  %369 = load i64, i64* %start2_byte, align 8
  %370 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text279 = getelementptr inbounds %struct.buffer, %struct.buffer* %370, i32 0, i32 73
  %371 = load %struct.buffer_text*, %struct.buffer_text** %text279, align 8
  %gpt_byte280 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %371, i32 0, i32 3
  %372 = load i64, i64* %gpt_byte280, align 8
  %cmp281 = icmp sge i64 %369, %372
  br i1 %cmp281, label %cond.true.282, label %cond.false.285

cond.true.282:                                    ; preds = %cond.end.272
  %373 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text283 = getelementptr inbounds %struct.buffer, %struct.buffer* %373, i32 0, i32 73
  %374 = load %struct.buffer_text*, %struct.buffer_text** %text283, align 8
  %gap_size284 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %374, i32 0, i32 5
  %375 = load i64, i64* %gap_size284, align 8
  br label %cond.end.286

cond.false.285:                                   ; preds = %cond.end.272
  br label %cond.end.286

cond.end.286:                                     ; preds = %cond.false.285, %cond.true.282
  %cond287 = phi i64 [ %375, %cond.true.282 ], [ 0, %cond.false.285 ]
  %376 = load i64, i64* %start2_byte, align 8
  %add288 = add nsw i64 %cond287, %376
  %377 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text289 = getelementptr inbounds %struct.buffer, %struct.buffer* %377, i32 0, i32 73
  %378 = load %struct.buffer_text*, %struct.buffer_text** %text289, align 8
  %beg290 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %378, i32 0, i32 0
  %379 = load i8*, i8** %beg290, align 8
  %add.ptr291 = getelementptr inbounds i8, i8* %379, i64 %add288
  %add.ptr292 = getelementptr inbounds i8, i8* %add.ptr291, i64 -1
  store i8* %add.ptr292, i8** %start2_addr, align 8
  %380 = load i8*, i8** %temp, align 8
  %381 = load i8*, i8** %start1_addr, align 8
  %382 = load i64, i64* %len1_byte, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %380, i8* %381, i64 %382, i32 1, i1 false)
  %383 = load i8*, i8** %start1_addr, align 8
  %384 = load i8*, i8** %start2_addr, align 8
  %385 = load i64, i64* %len2_byte, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %383, i8* %384, i64 %385, i32 1, i1 false)
  %386 = load i8*, i8** %start1_addr, align 8
  %387 = load i64, i64* %len2_byte, align 8
  %add.ptr293 = getelementptr inbounds i8, i8* %386, i64 %387
  %388 = load i8*, i8** %start1_addr, align 8
  %389 = load i64, i64* %len1_byte, align 8
  %add.ptr294 = getelementptr inbounds i8, i8* %388, i64 %389
  %390 = load i64, i64* %len_mid, align 8
  call void @llvm.memmove.p0i8.p0i8.i64(i8* %add.ptr293, i8* %add.ptr294, i64 %390, i32 1, i1 false)
  %391 = load i8*, i8** %start1_addr, align 8
  %392 = load i64, i64* %len2_byte, align 8
  %add.ptr295 = getelementptr inbounds i8, i8* %391, i64 %392
  %393 = load i64, i64* %len_mid, align 8
  %add.ptr296 = getelementptr inbounds i8, i8* %add.ptr295, i64 %393
  %394 = load i8*, i8** %temp, align 8
  %395 = load i64, i64* %len1_byte, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %add.ptr296, i8* %394, i64 %395, i32 1, i1 false)
  br label %do.body.297

do.body.297:                                      ; preds = %cond.end.286
  %396 = load i8, i8* %sa_must_free248, align 1
  %tobool298 = trunc i8 %396 to i1
  br i1 %tobool298, label %if.then.299, label %if.end.302

if.then.299:                                      ; preds = %do.body.297
  store i8 0, i8* %sa_must_free248, align 1
  %397 = load i64, i64* %sa_count246, align 8
  %call300 = call i64 @builtin_lisp_symbol(i32 0)
  %call301 = call i64 @unbind_to(i64 %397, i64 %call300)
  br label %if.end.302

if.end.302:                                       ; preds = %if.then.299, %do.body.297
  br label %do.end.303

do.end.303:                                       ; preds = %if.end.302
  %398 = load %struct.interval*, %struct.interval** %tmp_interval1, align 8
  %399 = load i64, i64* %end2, align 8
  %400 = load i64, i64* %len1, align 8
  %sub304 = sub nsw i64 %399, %400
  %401 = load i64, i64* %len1, align 8
  %402 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  call void @graft_intervals_into_buffer(%struct.interval* %398, i64 %sub304, i64 %401, %struct.buffer* %402, i1 zeroext false)
  %403 = load %struct.interval*, %struct.interval** %tmp_interval_mid, align 8
  %404 = load i64, i64* %start1, align 8
  %405 = load i64, i64* %len2, align 8
  %add305 = add nsw i64 %404, %405
  %406 = load i64, i64* %len_mid, align 8
  %407 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  call void @graft_intervals_into_buffer(%struct.interval* %403, i64 %add305, i64 %406, %struct.buffer* %407, i1 zeroext false)
  %408 = load %struct.interval*, %struct.interval** %tmp_interval2, align 8
  %409 = load i64, i64* %start1, align 8
  %410 = load i64, i64* %len2, align 8
  %411 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  call void @graft_intervals_into_buffer(%struct.interval* %408, i64 %409, i64 %410, %struct.buffer* %411, i1 zeroext false)
  br label %if.end.306

if.end.306:                                       ; preds = %do.end.303, %do.end.241
  br label %if.end.307

if.end.307:                                       ; preds = %if.end.306, %do.end.179
  %412 = load i64, i64* %start1, align 8
  %413 = load i64, i64* %start1, align 8
  %414 = load i64, i64* %len2, align 8
  %add308 = add nsw i64 %413, %414
  call void @update_compositions(i64 %412, i64 %add308, i32 3)
  %415 = load i64, i64* %end2, align 8
  %416 = load i64, i64* %len1, align 8
  %sub309 = sub nsw i64 %415, %416
  %417 = load i64, i64* %end2, align 8
  call void @update_compositions(i64 %sub309, i64 %417, i32 3)
  br label %if.end.310

if.end.310:                                       ; preds = %if.end.307, %do.end
  %418 = load i64, i64* %leave_markers.addr, align 8
  %call311 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp312 = icmp eq i64 %418, %call311
  br i1 %cmp312, label %if.then.313, label %if.end.316

if.then.313:                                      ; preds = %if.end.310
  %419 = load i64, i64* %start1, align 8
  %420 = load i64, i64* %end1, align 8
  %421 = load i64, i64* %start2, align 8
  %422 = load i64, i64* %end2, align 8
  %423 = load i64, i64* %start1_byte, align 8
  %424 = load i64, i64* %start1_byte, align 8
  %425 = load i64, i64* %len1_byte, align 8
  %add314 = add nsw i64 %424, %425
  %426 = load i64, i64* %start2_byte, align 8
  %427 = load i64, i64* %start2_byte, align 8
  %428 = load i64, i64* %len2_byte, align 8
  %add315 = add nsw i64 %427, %428
  call void @transpose_markers(i64 %419, i64 %420, i64 %421, i64 %422, i64 %423, i64 %add314, i64 %426, i64 %add315)
  %429 = load i64, i64* %start1, align 8
  %430 = load i64, i64* %end2, align 8
  call void @fix_start_end_in_overlays(i64 %429, i64 %430)
  br label %if.end.316

if.end.316:                                       ; preds = %if.then.313, %if.end.310
  %431 = load i64, i64* %start1, align 8
  %432 = load i64, i64* %end2, align 8
  %433 = load i64, i64* %start1, align 8
  %sub317 = sub nsw i64 %432, %433
  %434 = load i64, i64* %end2, align 8
  %435 = load i64, i64* %start1, align 8
  %sub318 = sub nsw i64 %434, %435
  call void @signal_after_change(i64 %431, i64 %sub317, i64 %sub318)
  %call319 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call319, i64* %retval
  br label %return

return:                                           ; preds = %if.end.316, %if.then.11
  %436 = load i64, i64* %retval
  ret i64 %436
}

declare %struct.interval* @buffer_intervals(%struct.buffer*) #1

declare void @move_gap_both(i64, i64) #1

declare %struct.interval* @copy_intervals(%struct.interval*, i64, i64) #1

declare %struct.interval* @validate_interval_range(i64, i64*, i64*, i1 zeroext) #1

declare void @set_text_properties_1(i64, i64, i64, i64, %struct.interval*) #1

declare void @graft_intervals_into_buffer(%struct.interval*, i64, i64, %struct.buffer*, i1 zeroext) #1

; Function Attrs: nounwind
declare void @llvm.memmove.p0i8.p0i8.i64(i8* nocapture, i8* nocapture readonly, i64, i32, i1) #5

; Function Attrs: nounwind uwtable
define internal void @transpose_markers(i64 %start1, i64 %end1, i64 %start2, i64 %end2, i64 %start1_byte, i64 %end1_byte, i64 %start2_byte, i64 %end2_byte) #0 {
entry:
  %start1.addr = alloca i64, align 8
  %end1.addr = alloca i64, align 8
  %start2.addr = alloca i64, align 8
  %end2.addr = alloca i64, align 8
  %start1_byte.addr = alloca i64, align 8
  %end1_byte.addr = alloca i64, align 8
  %start2_byte.addr = alloca i64, align 8
  %end2_byte.addr = alloca i64, align 8
  %amt1 = alloca i64, align 8
  %amt1_byte = alloca i64, align 8
  %amt2 = alloca i64, align 8
  %amt2_byte = alloca i64, align 8
  %diff = alloca i64, align 8
  %diff_byte = alloca i64, align 8
  %mpos = alloca i64, align 8
  %marker = alloca %struct.Lisp_Marker*, align 8
  store i64 %start1, i64* %start1.addr, align 8
  store i64 %end1, i64* %end1.addr, align 8
  store i64 %start2, i64* %start2.addr, align 8
  store i64 %end2, i64* %end2.addr, align 8
  store i64 %start1_byte, i64* %start1_byte.addr, align 8
  store i64 %end1_byte, i64* %end1_byte.addr, align 8
  store i64 %start2_byte, i64* %start2_byte.addr, align 8
  store i64 %end2_byte, i64* %end2_byte.addr, align 8
  %0 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt = getelementptr inbounds %struct.buffer, %struct.buffer* %0, i32 0, i32 75
  %1 = load i64, i64* %pt, align 8
  %add = add nsw i64 %1, 0
  %2 = load i64, i64* %start1.addr, align 8
  %cmp = icmp slt i64 %add, %2
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %if.end.43

if.else:                                          ; preds = %entry
  %3 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt1 = getelementptr inbounds %struct.buffer, %struct.buffer* %3, i32 0, i32 75
  %4 = load i64, i64* %pt1, align 8
  %add2 = add nsw i64 %4, 0
  %5 = load i64, i64* %end1.addr, align 8
  %cmp3 = icmp slt i64 %add2, %5
  br i1 %cmp3, label %if.then.4, label %if.else.11

if.then.4:                                        ; preds = %if.else
  %6 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %7 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt5 = getelementptr inbounds %struct.buffer, %struct.buffer* %7, i32 0, i32 75
  %8 = load i64, i64* %pt5, align 8
  %add6 = add nsw i64 %8, 0
  %9 = load i64, i64* %end2.addr, align 8
  %10 = load i64, i64* %end1.addr, align 8
  %sub = sub nsw i64 %9, %10
  %add7 = add nsw i64 %add6, %sub
  %11 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt_byte = getelementptr inbounds %struct.buffer, %struct.buffer* %11, i32 0, i32 76
  %12 = load i64, i64* %pt_byte, align 8
  %add8 = add nsw i64 %12, 0
  %13 = load i64, i64* %end2_byte.addr, align 8
  %14 = load i64, i64* %end1_byte.addr, align 8
  %sub9 = sub nsw i64 %13, %14
  %add10 = add nsw i64 %add8, %sub9
  call void @temp_set_point_both(%struct.buffer* %6, i64 %add7, i64 %add10)
  br label %if.end.42

if.else.11:                                       ; preds = %if.else
  %15 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt12 = getelementptr inbounds %struct.buffer, %struct.buffer* %15, i32 0, i32 75
  %16 = load i64, i64* %pt12, align 8
  %add13 = add nsw i64 %16, 0
  %17 = load i64, i64* %start2.addr, align 8
  %cmp14 = icmp slt i64 %add13, %17
  br i1 %cmp14, label %if.then.15, label %if.else.28

if.then.15:                                       ; preds = %if.else.11
  %18 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %19 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt16 = getelementptr inbounds %struct.buffer, %struct.buffer* %19, i32 0, i32 75
  %20 = load i64, i64* %pt16, align 8
  %add17 = add nsw i64 %20, 0
  %21 = load i64, i64* %end2.addr, align 8
  %22 = load i64, i64* %start2.addr, align 8
  %sub18 = sub nsw i64 %21, %22
  %add19 = add nsw i64 %add17, %sub18
  %23 = load i64, i64* %end1.addr, align 8
  %24 = load i64, i64* %start1.addr, align 8
  %sub20 = sub nsw i64 %23, %24
  %sub21 = sub nsw i64 %add19, %sub20
  %25 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt_byte22 = getelementptr inbounds %struct.buffer, %struct.buffer* %25, i32 0, i32 76
  %26 = load i64, i64* %pt_byte22, align 8
  %add23 = add nsw i64 %26, 0
  %27 = load i64, i64* %end2_byte.addr, align 8
  %28 = load i64, i64* %start2_byte.addr, align 8
  %sub24 = sub nsw i64 %27, %28
  %add25 = add nsw i64 %add23, %sub24
  %29 = load i64, i64* %end1_byte.addr, align 8
  %30 = load i64, i64* %start1_byte.addr, align 8
  %sub26 = sub nsw i64 %29, %30
  %sub27 = sub nsw i64 %add25, %sub26
  call void @temp_set_point_both(%struct.buffer* %18, i64 %sub21, i64 %sub27)
  br label %if.end.41

if.else.28:                                       ; preds = %if.else.11
  %31 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt29 = getelementptr inbounds %struct.buffer, %struct.buffer* %31, i32 0, i32 75
  %32 = load i64, i64* %pt29, align 8
  %add30 = add nsw i64 %32, 0
  %33 = load i64, i64* %end2.addr, align 8
  %cmp31 = icmp slt i64 %add30, %33
  br i1 %cmp31, label %if.then.32, label %if.end

if.then.32:                                       ; preds = %if.else.28
  %34 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %35 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt33 = getelementptr inbounds %struct.buffer, %struct.buffer* %35, i32 0, i32 75
  %36 = load i64, i64* %pt33, align 8
  %add34 = add nsw i64 %36, 0
  %37 = load i64, i64* %start2.addr, align 8
  %38 = load i64, i64* %start1.addr, align 8
  %sub35 = sub nsw i64 %37, %38
  %sub36 = sub nsw i64 %add34, %sub35
  %39 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt_byte37 = getelementptr inbounds %struct.buffer, %struct.buffer* %39, i32 0, i32 76
  %40 = load i64, i64* %pt_byte37, align 8
  %add38 = add nsw i64 %40, 0
  %41 = load i64, i64* %start2_byte.addr, align 8
  %42 = load i64, i64* %start1_byte.addr, align 8
  %sub39 = sub nsw i64 %41, %42
  %sub40 = sub nsw i64 %add38, %sub39
  call void @temp_set_point_both(%struct.buffer* %34, i64 %sub36, i64 %sub40)
  br label %if.end

if.end:                                           ; preds = %if.then.32, %if.else.28
  br label %if.end.41

if.end.41:                                        ; preds = %if.end, %if.then.15
  br label %if.end.42

if.end.42:                                        ; preds = %if.end.41, %if.then.4
  br label %if.end.43

if.end.43:                                        ; preds = %if.end.42, %if.then
  %43 = load i64, i64* %end2.addr, align 8
  %44 = load i64, i64* %start2.addr, align 8
  %sub44 = sub nsw i64 %43, %44
  %45 = load i64, i64* %end1.addr, align 8
  %46 = load i64, i64* %start1.addr, align 8
  %sub45 = sub nsw i64 %45, %46
  %sub46 = sub nsw i64 %sub44, %sub45
  store i64 %sub46, i64* %diff, align 8
  %47 = load i64, i64* %end2_byte.addr, align 8
  %48 = load i64, i64* %start2_byte.addr, align 8
  %sub47 = sub nsw i64 %47, %48
  %49 = load i64, i64* %end1_byte.addr, align 8
  %50 = load i64, i64* %start1_byte.addr, align 8
  %sub48 = sub nsw i64 %49, %50
  %sub49 = sub nsw i64 %sub47, %sub48
  store i64 %sub49, i64* %diff_byte, align 8
  %51 = load i64, i64* %end2.addr, align 8
  %52 = load i64, i64* %start2.addr, align 8
  %sub50 = sub nsw i64 %51, %52
  %53 = load i64, i64* %start2.addr, align 8
  %54 = load i64, i64* %end1.addr, align 8
  %sub51 = sub nsw i64 %53, %54
  %add52 = add nsw i64 %sub50, %sub51
  store i64 %add52, i64* %amt1, align 8
  %55 = load i64, i64* %end1.addr, align 8
  %56 = load i64, i64* %start1.addr, align 8
  %sub53 = sub nsw i64 %55, %56
  %57 = load i64, i64* %start2.addr, align 8
  %58 = load i64, i64* %end1.addr, align 8
  %sub54 = sub nsw i64 %57, %58
  %add55 = add nsw i64 %sub53, %sub54
  store i64 %add55, i64* %amt2, align 8
  %59 = load i64, i64* %end2_byte.addr, align 8
  %60 = load i64, i64* %start2_byte.addr, align 8
  %sub56 = sub nsw i64 %59, %60
  %61 = load i64, i64* %start2_byte.addr, align 8
  %62 = load i64, i64* %end1_byte.addr, align 8
  %sub57 = sub nsw i64 %61, %62
  %add58 = add nsw i64 %sub56, %sub57
  store i64 %add58, i64* %amt1_byte, align 8
  %63 = load i64, i64* %end1_byte.addr, align 8
  %64 = load i64, i64* %start1_byte.addr, align 8
  %sub59 = sub nsw i64 %63, %64
  %65 = load i64, i64* %start2_byte.addr, align 8
  %66 = load i64, i64* %end1_byte.addr, align 8
  %sub60 = sub nsw i64 %65, %66
  %add61 = add nsw i64 %sub59, %sub60
  store i64 %add61, i64* %amt2_byte, align 8
  %67 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text = getelementptr inbounds %struct.buffer, %struct.buffer* %67, i32 0, i32 73
  %68 = load %struct.buffer_text*, %struct.buffer_text** %text, align 8
  %markers = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %68, i32 0, i32 16
  %69 = load %struct.Lisp_Marker*, %struct.Lisp_Marker** %markers, align 8
  store %struct.Lisp_Marker* %69, %struct.Lisp_Marker** %marker, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end.43
  %70 = load %struct.Lisp_Marker*, %struct.Lisp_Marker** %marker, align 8
  %tobool = icmp ne %struct.Lisp_Marker* %70, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %71 = load %struct.Lisp_Marker*, %struct.Lisp_Marker** %marker, align 8
  %bytepos = getelementptr inbounds %struct.Lisp_Marker, %struct.Lisp_Marker* %71, i32 0, i32 4
  %72 = load i64, i64* %bytepos, align 8
  store i64 %72, i64* %mpos, align 8
  %73 = load i64, i64* %mpos, align 8
  %74 = load i64, i64* %start1_byte.addr, align 8
  %cmp62 = icmp sge i64 %73, %74
  br i1 %cmp62, label %land.lhs.true, label %if.end.77

land.lhs.true:                                    ; preds = %for.body
  %75 = load i64, i64* %mpos, align 8
  %76 = load i64, i64* %end2_byte.addr, align 8
  %cmp63 = icmp slt i64 %75, %76
  br i1 %cmp63, label %if.then.64, label %if.end.77

if.then.64:                                       ; preds = %land.lhs.true
  %77 = load i64, i64* %mpos, align 8
  %78 = load i64, i64* %end1_byte.addr, align 8
  %cmp65 = icmp slt i64 %77, %78
  br i1 %cmp65, label %if.then.66, label %if.else.68

if.then.66:                                       ; preds = %if.then.64
  %79 = load i64, i64* %amt1_byte, align 8
  %80 = load i64, i64* %mpos, align 8
  %add67 = add nsw i64 %80, %79
  store i64 %add67, i64* %mpos, align 8
  br label %if.end.75

if.else.68:                                       ; preds = %if.then.64
  %81 = load i64, i64* %mpos, align 8
  %82 = load i64, i64* %start2_byte.addr, align 8
  %cmp69 = icmp slt i64 %81, %82
  br i1 %cmp69, label %if.then.70, label %if.else.72

if.then.70:                                       ; preds = %if.else.68
  %83 = load i64, i64* %diff_byte, align 8
  %84 = load i64, i64* %mpos, align 8
  %add71 = add nsw i64 %84, %83
  store i64 %add71, i64* %mpos, align 8
  br label %if.end.74

if.else.72:                                       ; preds = %if.else.68
  %85 = load i64, i64* %amt2_byte, align 8
  %86 = load i64, i64* %mpos, align 8
  %sub73 = sub nsw i64 %86, %85
  store i64 %sub73, i64* %mpos, align 8
  br label %if.end.74

if.end.74:                                        ; preds = %if.else.72, %if.then.70
  br label %if.end.75

if.end.75:                                        ; preds = %if.end.74, %if.then.66
  %87 = load i64, i64* %mpos, align 8
  %88 = load %struct.Lisp_Marker*, %struct.Lisp_Marker** %marker, align 8
  %bytepos76 = getelementptr inbounds %struct.Lisp_Marker, %struct.Lisp_Marker* %88, i32 0, i32 4
  store i64 %87, i64* %bytepos76, align 8
  br label %if.end.77

if.end.77:                                        ; preds = %if.end.75, %land.lhs.true, %for.body
  %89 = load %struct.Lisp_Marker*, %struct.Lisp_Marker** %marker, align 8
  %charpos = getelementptr inbounds %struct.Lisp_Marker, %struct.Lisp_Marker* %89, i32 0, i32 3
  %90 = load i64, i64* %charpos, align 8
  store i64 %90, i64* %mpos, align 8
  %91 = load i64, i64* %mpos, align 8
  %92 = load i64, i64* %start1.addr, align 8
  %cmp78 = icmp sge i64 %91, %92
  br i1 %cmp78, label %land.lhs.true.79, label %if.end.93

land.lhs.true.79:                                 ; preds = %if.end.77
  %93 = load i64, i64* %mpos, align 8
  %94 = load i64, i64* %end2.addr, align 8
  %cmp80 = icmp slt i64 %93, %94
  br i1 %cmp80, label %if.then.81, label %if.end.93

if.then.81:                                       ; preds = %land.lhs.true.79
  %95 = load i64, i64* %mpos, align 8
  %96 = load i64, i64* %end1.addr, align 8
  %cmp82 = icmp slt i64 %95, %96
  br i1 %cmp82, label %if.then.83, label %if.else.85

if.then.83:                                       ; preds = %if.then.81
  %97 = load i64, i64* %amt1, align 8
  %98 = load i64, i64* %mpos, align 8
  %add84 = add nsw i64 %98, %97
  store i64 %add84, i64* %mpos, align 8
  br label %if.end.92

if.else.85:                                       ; preds = %if.then.81
  %99 = load i64, i64* %mpos, align 8
  %100 = load i64, i64* %start2.addr, align 8
  %cmp86 = icmp slt i64 %99, %100
  br i1 %cmp86, label %if.then.87, label %if.else.89

if.then.87:                                       ; preds = %if.else.85
  %101 = load i64, i64* %diff, align 8
  %102 = load i64, i64* %mpos, align 8
  %add88 = add nsw i64 %102, %101
  store i64 %add88, i64* %mpos, align 8
  br label %if.end.91

if.else.89:                                       ; preds = %if.else.85
  %103 = load i64, i64* %amt2, align 8
  %104 = load i64, i64* %mpos, align 8
  %sub90 = sub nsw i64 %104, %103
  store i64 %sub90, i64* %mpos, align 8
  br label %if.end.91

if.end.91:                                        ; preds = %if.else.89, %if.then.87
  br label %if.end.92

if.end.92:                                        ; preds = %if.end.91, %if.then.83
  br label %if.end.93

if.end.93:                                        ; preds = %if.end.92, %land.lhs.true.79, %if.end.77
  %105 = load i64, i64* %mpos, align 8
  %106 = load %struct.Lisp_Marker*, %struct.Lisp_Marker** %marker, align 8
  %charpos94 = getelementptr inbounds %struct.Lisp_Marker, %struct.Lisp_Marker* %106, i32 0, i32 3
  store i64 %105, i64* %charpos94, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end.93
  %107 = load %struct.Lisp_Marker*, %struct.Lisp_Marker** %marker, align 8
  %next = getelementptr inbounds %struct.Lisp_Marker, %struct.Lisp_Marker* %107, i32 0, i32 2
  %108 = load %struct.Lisp_Marker*, %struct.Lisp_Marker** %next, align 8
  store %struct.Lisp_Marker* %108, %struct.Lisp_Marker** %marker, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

declare void @fix_start_end_in_overlays(i64, i64) #1

; Function Attrs: nounwind uwtable
define void @syms_of_editfns() #0 {
entry:
  %obuf = alloca i64, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_editfns.o_fwd, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.17, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 134))
  br label %do.end

do.end:                                           ; preds = %do.body
  %call = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 134), align 8
  br label %do.body.1

do.body.1:                                        ; preds = %do.end
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_editfns.o_fwd.18, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.19, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 17))
  br label %do.end.2

do.end.2:                                         ; preds = %do.body.1
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call3, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 17), align 8
  %call4 = call i64 @Fcurrent_buffer()
  store i64 %call4, i64* %obuf, align 8
  %0 = load i64, i64* @Vprin1_to_string_buffer, align 8
  %call5 = call i64 @Fset_buffer(i64 %0)
  %call6 = call i64 @builtin_lisp_symbol(i32 220)
  %call7 = call i64 @Fmake_local_variable(i64 %call6)
  %call8 = call i64 @builtin_lisp_symbol(i32 0)
  %call9 = call i64 @Fset(i64 %call7, i64 %call8)
  %1 = load i64, i64* %obuf, align 8
  %call10 = call i64 @Fset_buffer(i64 %1)
  br label %do.body.11

do.body.11:                                       ; preds = %do.end.2
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_editfns.o_fwd.20, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.21, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 16))
  br label %do.end.12

do.end.12:                                        ; preds = %do.body.11
  %call13 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call13, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 16), align 8
  br label %do.body.14

do.body.14:                                       ; preds = %do.end.12
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_editfns.o_fwd.22, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.23, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 285))
  br label %do.end.15

do.end.15:                                        ; preds = %do.body.14
  %call16 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call16, i64* @cached_system_name, align 8
  store i64 %call16, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 285), align 8
  br label %do.body.17

do.body.17:                                       ; preds = %do.end.15
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_editfns.o_fwd.24, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.25, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 319))
  br label %do.end.18

do.end.18:                                        ; preds = %do.body.17
  br label %do.body.19

do.body.19:                                       ; preds = %do.end.18
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_editfns.o_fwd.26, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.27, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 321))
  br label %do.end.20

do.end.20:                                        ; preds = %do.body.19
  %call21 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call21, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 321), align 8
  br label %do.body.22

do.body.22:                                       ; preds = %do.end.20
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_editfns.o_fwd.28, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.29, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 322))
  br label %do.end.23

do.end.23:                                        ; preds = %do.body.22
  br label %do.body.24

do.body.24:                                       ; preds = %do.end.23
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_editfns.o_fwd.30, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.31, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 209))
  br label %do.end.25

do.end.25:                                        ; preds = %do.body.24
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* }* @Spropertize to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Schar_equal to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sgoto_char to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sstring_to_char to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Schar_to_string to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sbyte_to_string to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sbuffer_substring to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sbuffer_substring_no_properties to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* @Sbuffer_string)
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sget_pos_property to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* @Spoint_marker)
  call void @defsubr(%struct.Lisp_Subr* @Smark_marker)
  call void @defsubr(%struct.Lisp_Subr* @Spoint)
  call void @defsubr(%struct.Lisp_Subr* @Sregion_beginning)
  call void @defsubr(%struct.Lisp_Subr* @Sregion_end)
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sfield_beginning to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sfield_end to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sfield_string to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sfield_string_no_properties to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sdelete_field to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64, i64, i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sconstrain_to_field to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sline_beginning_position to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sline_end_position to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Ssave_excursion to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Ssave_current_buffer to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sbuffer_size to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* @Spoint_max)
  call void @defsubr(%struct.Lisp_Subr* @Spoint_min)
  call void @defsubr(%struct.Lisp_Subr* @Spoint_min_marker)
  call void @defsubr(%struct.Lisp_Subr* @Spoint_max_marker)
  call void @defsubr(%struct.Lisp_Subr* @Sgap_position)
  call void @defsubr(%struct.Lisp_Subr* @Sgap_size)
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sposition_bytes to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sbyte_to_position to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* @Sbobp)
  call void @defsubr(%struct.Lisp_Subr* @Seobp)
  call void @defsubr(%struct.Lisp_Subr* @Sbolp)
  call void @defsubr(%struct.Lisp_Subr* @Seolp)
  call void @defsubr(%struct.Lisp_Subr* @Sfollowing_char)
  call void @defsubr(%struct.Lisp_Subr* @Sprevious_char)
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Schar_after to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Schar_before to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* }* @Sinsert to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* }* @Sinsert_before_markers to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* }* @Sinsert_and_inherit to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* }* @Sinsert_and_inherit_before_markers to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sinsert_char to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sinsert_byte to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Suser_login_name to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* @Suser_real_login_name)
  call void @defsubr(%struct.Lisp_Subr* @Suser_uid)
  call void @defsubr(%struct.Lisp_Subr* @Suser_real_uid)
  call void @defsubr(%struct.Lisp_Subr* @Sgroup_gid)
  call void @defsubr(%struct.Lisp_Subr* @Sgroup_real_gid)
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Suser_full_name to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* @Semacs_pid)
  call void @defsubr(%struct.Lisp_Subr* @Scurrent_time)
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Stime_add to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Stime_subtract to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Stime_less_p to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* @Sget_internal_run_time)
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sformat_time_string to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sfloat_time to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sdecode_time to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* }* @Sencode_time to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Scurrent_time_string to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Scurrent_time_zone to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sset_time_zone_rule to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* @Ssystem_name)
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* }* @Smessage to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* }* @Smessage_box to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* }* @Smessage_or_box to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* @Scurrent_message)
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* }* @Sformat to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* }* @Sformat_message to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sinsert_buffer_substring to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64, i64, i64, i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Scompare_buffer_substrings to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64, i64, i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Ssubst_char_in_region to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Stranslate_region_internal to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sdelete_region to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sdelete_and_extract_region to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* @Swiden)
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Snarrow_to_region to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Ssave_restriction to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64, i64, i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Stranspose_regions to %struct.Lisp_Subr*))
  ret void
}

declare void @defvar_lisp(%struct.Lisp_Objfwd*, i8*, i64*) #1

declare i64 @Fset(i64, i64) #1

declare i64 @Fmake_local_variable(i64) #1

declare void @defsubr(%struct.Lisp_Subr*) #1

declare void @init_system_name() #1

declare %struct.tm_zone* @tzalloc(i8*) #1

; Function Attrs: noreturn
declare void @xsignal2(i64, i64, i64) #4

declare void @tzfree(%struct.tm_zone*) #1

declare i64 @Fmarker_position(i64) #1

declare i64 @get_char_property_and_overlay(i64, i64, i64, i64*) #1

declare i64 @Fprevious_single_char_property_change(i64, i64, i64, i64) #1

declare i64 @Fnext_single_char_property_change(i64, i64, i64, i64) #1

; Function Attrs: nounwind uwtable
define internal void @check_time_validity(i32 %validity) #0 {
entry:
  %validity.addr = alloca i32, align 4
  store i32 %validity, i32* %validity.addr, align 4
  %0 = load i32, i32* %validity.addr, align 4
  %cmp = icmp sle i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i32, i32* %validity.addr, align 4
  %cmp1 = icmp slt i32 %1, 0
  br i1 %cmp1, label %if.then.2, label %if.else

if.then.2:                                        ; preds = %if.then
  call void @time_overflow() #9
  unreachable

if.else:                                          ; preds = %if.then
  call void @invalid_time() #9
  unreachable

if.end:                                           ; preds = %entry
  ret void
}

declare void @synchronize_system_time_locale() #1

; Function Attrs: nounwind uwtable
define internal i64 @emacs_nmemftime(i8* %s, i64 %maxsize, i8* %format, i64 %format_len, %struct.tm* %tp, %struct.tm_zone* %tz, i32 %ns) #0 {
entry:
  %retval = alloca i64, align 8
  %s.addr = alloca i8*, align 8
  %maxsize.addr = alloca i64, align 8
  %format.addr = alloca i8*, align 8
  %format_len.addr = alloca i64, align 8
  %tp.addr = alloca %struct.tm*, align 8
  %tz.addr = alloca %struct.tm_zone*, align 8
  %ns.addr = alloca i32, align 4
  %total = alloca i64, align 8
  %len = alloca i64, align 8
  %result = alloca i64, align 8
  store i8* %s, i8** %s.addr, align 8
  store i64 %maxsize, i64* %maxsize.addr, align 8
  store i8* %format, i8** %format.addr, align 8
  store i64 %format_len, i64* %format_len.addr, align 8
  store %struct.tm* %tp, %struct.tm** %tp.addr, align 8
  store %struct.tm_zone* %tz, %struct.tm_zone** %tz.addr, align 8
  store i32 %ns, i32* %ns.addr, align 4
  store i64 0, i64* %total, align 8
  br label %for.cond

for.cond:                                         ; preds = %if.end.15, %entry
  %0 = load i8*, i8** %s.addr, align 8
  %tobool = icmp ne i8* %0, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.cond
  %1 = load i8*, i8** %s.addr, align 8
  %arrayidx = getelementptr inbounds i8, i8* %1, i64 0
  store i8 1, i8* %arrayidx, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %for.cond
  %2 = load i8*, i8** %s.addr, align 8
  %3 = load i64, i64* %maxsize.addr, align 8
  %4 = load i8*, i8** %format.addr, align 8
  %5 = load %struct.tm*, %struct.tm** %tp.addr, align 8
  %6 = load %struct.tm_zone*, %struct.tm_zone** %tz.addr, align 8
  %7 = load i32, i32* %ns.addr, align 4
  %call = call i64 @nstrftime(i8* %2, i64 %3, i8* %4, %struct.tm* %5, %struct.tm_zone* %6, i32 %7)
  store i64 %call, i64* %result, align 8
  %8 = load i8*, i8** %s.addr, align 8
  %tobool1 = icmp ne i8* %8, null
  br i1 %tobool1, label %if.then.2, label %if.end.8

if.then.2:                                        ; preds = %if.end
  %9 = load i64, i64* %result, align 8
  %cmp = icmp eq i64 %9, 0
  br i1 %cmp, label %land.lhs.true, label %if.end.7

land.lhs.true:                                    ; preds = %if.then.2
  %10 = load i8*, i8** %s.addr, align 8
  %arrayidx3 = getelementptr inbounds i8, i8* %10, i64 0
  %11 = load i8, i8* %arrayidx3, align 1
  %conv = sext i8 %11 to i32
  %cmp4 = icmp ne i32 %conv, 0
  br i1 %cmp4, label %if.then.6, label %if.end.7

if.then.6:                                        ; preds = %land.lhs.true
  store i64 0, i64* %retval
  br label %return

if.end.7:                                         ; preds = %land.lhs.true, %if.then.2
  %12 = load i64, i64* %result, align 8
  %add = add i64 %12, 1
  %13 = load i8*, i8** %s.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %13, i64 %add
  store i8* %add.ptr, i8** %s.addr, align 8
  br label %if.end.8

if.end.8:                                         ; preds = %if.end.7, %if.end
  %14 = load i64, i64* %result, align 8
  %add9 = add i64 %14, 1
  %15 = load i64, i64* %maxsize.addr, align 8
  %sub = sub i64 %15, %add9
  store i64 %sub, i64* %maxsize.addr, align 8
  %16 = load i64, i64* %result, align 8
  %17 = load i64, i64* %total, align 8
  %add10 = add i64 %17, %16
  store i64 %add10, i64* %total, align 8
  %18 = load i8*, i8** %format.addr, align 8
  %call11 = call i64 @strlen(i8* %18) #8
  store i64 %call11, i64* %len, align 8
  %19 = load i64, i64* %len, align 8
  %20 = load i64, i64* %format_len.addr, align 8
  %cmp12 = icmp eq i64 %19, %20
  br i1 %cmp12, label %if.then.14, label %if.end.15

if.then.14:                                       ; preds = %if.end.8
  %21 = load i64, i64* %total, align 8
  store i64 %21, i64* %retval
  br label %return

if.end.15:                                        ; preds = %if.end.8
  %22 = load i64, i64* %total, align 8
  %inc = add i64 %22, 1
  store i64 %inc, i64* %total, align 8
  %23 = load i64, i64* %len, align 8
  %add16 = add i64 %23, 1
  %24 = load i8*, i8** %format.addr, align 8
  %add.ptr17 = getelementptr inbounds i8, i8* %24, i64 %add16
  store i8* %add.ptr17, i8** %format.addr, align 8
  %25 = load i64, i64* %len, align 8
  %add18 = add i64 %25, 1
  %26 = load i64, i64* %format_len.addr, align 8
  %sub19 = sub i64 %26, %add18
  store i64 %sub19, i64* %format_len.addr, align 8
  br label %for.cond

return:                                           ; preds = %if.then.14, %if.then.6
  %27 = load i64, i64* %retval
  ret i64 %27
}

; Function Attrs: noreturn
declare void @string_overflow() #4

declare i64 @nstrftime(i8*, i64, i8*, %struct.tm*, %struct.tm_zone*, i32) #1

declare %struct.tm* @localtime_rz(%struct.tm_zone*, i64*, %struct.tm*) #1

; Function Attrs: nounwind readnone
declare i32* @__errno_location() #7

declare i64 @mktime_z(%struct.tm_zone*, %struct.tm*) #1

declare i64 @Ftext_property_any(i64, i64, i64, i64, i64) #1

declare i64 @Frun_hook_with_args(i64, i64*) #1

declare i64 @AREF(i64, i64) #1

declare void @xfree(i8*) #1

; Function Attrs: nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture, i8, i64, i32, i1) #5

declare i32 @text_quoting_style() #1

; Function Attrs: nounwind
declare i64 @strtoumax(i8*, i8**, i32) #2

declare i64 @Fprin1_to_string(i64, i64) #1

declare i64 @SYMBOL_NAME(i64) #1

declare i64 @lisp_string_width(i64, i64, i64*, i64*) #1

declare i64 @count_size_as_multibyte(i8*, i64) #1

declare i64 @copy_text(i8*, i8*, i64, i1 zeroext, i1 zeroext) #1

declare %struct.interval* @string_intervals(i64) #1

declare i64 @XUINT(i64) #1

declare void @record_unwind_protect_ptr(void (i8*)*, i8*) #1

declare i8* @xrealloc(i8*, i64) #1

declare void @set_unwind_protect_ptr(i64, void (i8*)*, i8*) #1

declare i64 @multibyte_chars_in_text(i8*, i64) #1

declare i64 @make_specified_string(i8*, i64, i64, i1 zeroext) #1

declare i64 @text_property_list(i64, i64, i64, i64) #1

declare i64 @Fnreverse(i64) #1

declare void @XSETCAR(i64, i64) #1

declare void @add_text_properties_from_list(i64, i64, i64) #1

declare i64 @extend_property_ranges(i64, i64) #1

declare void @make_composition_value_copy(i64) #1

declare void @temp_set_point_both(%struct.buffer*, i64, i64) #1

attributes #0 = { nounwind uwtable "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nounwind readonly "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { noreturn "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { nounwind }
attributes #6 = { noreturn nounwind uwtable "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #7 = { nounwind readnone "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #8 = { nounwind readonly }
attributes #9 = { noreturn }
attributes #10 = { nounwind readnone }

!llvm.ident = !{!0}

!0 = !{!"clang version 3.7.0 (tags/RELEASE_370/final)"}
