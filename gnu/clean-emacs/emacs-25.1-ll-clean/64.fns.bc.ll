; ModuleID = './src/fns.bc'
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.emacs_globals = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8 }
%struct.Lisp_Symbol = type { i16, i64, %union.anon.1, i64, i64, %struct.Lisp_Symbol* }
%union.anon.1 = type { i64 }
%struct.buffer = type { %struct.vectorlike_header, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.buffer_text, %struct.buffer_text*, %struct.buffer*, i64, i64, i64, i64, i64, i64, %struct.buffer*, i32, i32, [50 x i8], %struct.timespec, i64, i64, i64, i64, i64, %struct.region_cache*, %struct.region_cache*, %struct.region_cache*, i8, %struct.Lisp_Overlay*, %struct.Lisp_Overlay*, i64, i64 }
%struct.vectorlike_header = type { i64 }
%struct.buffer_text = type { i8*, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.interval*, %struct.Lisp_Marker*, i8 }
%struct.interval = type { i64, i64, %struct.interval*, %struct.interval*, %union.anon.0, i8, i64 }
%union.anon.0 = type { %struct.interval* }
%struct.Lisp_Marker = type { i32, %struct.buffer*, %struct.Lisp_Marker*, i64, i64 }
%struct.timespec = type { i64, i64 }
%struct.region_cache = type opaque
%struct.Lisp_Overlay = type { i32, %struct.Lisp_Overlay*, i64, i64, i64 }
%struct.Lisp_Hash_Table = type { %struct.vectorlike_header, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.hash_table_test, %struct.Lisp_Hash_Table* }
%struct.hash_table_test = type { i64, i64, i64, i1 (%struct.hash_table_test*, i64, i64)*, i64 (%struct.hash_table_test*, i64)* }
%struct.Lisp_Objfwd = type { i32, i64* }
%struct.Lisp_Boolfwd = type { i32, i8* }
%union.specbinding = type { %struct.anon.7 }
%struct.anon.7 = type { i8, i64, i64, i64 }
%struct.Lisp_Cons = type { i64, %union.anon }
%union.anon = type { i64 }
%struct.textprop_rec = type { i64, i64, i64 }
%struct.Lisp_Vector = type { %struct.vectorlike_header, [0 x i64] }
%struct.Lisp_String = type { i64, i64, %struct.interval*, i8* }
%union.Aligned_String = type { %struct.Lisp_String }
%union.anon.3 = type { double }
%struct.Lisp_Subr = type { %struct.vectorlike_header, %union.anon.2, i16, i16, i8*, i8*, i8* }
%union.anon.2 = type { i64 ()* }

@.str = private unnamed_addr constant [14 x i8] c"List too long\00", align 1
@globals = external global %struct.emacs_globals, align 8
@pending_signals = external global i8, align 1
@string_char_byte_cache_string = internal global i64 0, align 8
@string_char_byte_cache_charpos = internal global i64 0, align 8
@string_char_byte_cache_bytepos = internal global i64 0, align 8
@.str.1 = private unnamed_addr constant [45 x i8] c"Can't convert the %ldth character to unibyte\00", align 1
@empty_unibyte_string = external global i64, align 8
@lispsym = external global [1074 x %struct.Lisp_Symbol], align 8
@.str.2 = private unnamed_addr constant [42 x i8] c"Attempt to change byte length of a string\00", align 1
@.str.3 = private unnamed_addr constant [12 x i8] c"yes-or-no-p\00", align 1
@.str.4 = private unnamed_addr constant [4 x i8] c"Yes\00", align 1
@.str.5 = private unnamed_addr constant [3 x i8] c"No\00", align 1
@.str.6 = private unnamed_addr constant [13 x i8] c"(yes or no) \00", align 1
@.str.7 = private unnamed_addr constant [4 x i8] c"yes\00", align 1
@.str.8 = private unnamed_addr constant [3 x i8] c"no\00", align 1
@.str.9 = private unnamed_addr constant [25 x i8] c"Please answer yes or no.\00", align 1
@.str.10 = private unnamed_addr constant [55 x i8] c"load-average not implemented for this operating system\00", align 1
@Vautoload_queue = external global i64, align 8
@.str.11 = private unnamed_addr constant [37 x i8] c"(require %s) while preparing to dump\00", align 1
@require_nesting_list = internal global i64 0, align 8
@.str.12 = private unnamed_addr constant [37 x i8] c"Recursive `require' for feature `%s'\00", align 1
@.str.13 = private unnamed_addr constant [39 x i8] c"Required feature `%s' was not provided\00", align 1
@Flocale_info.days = internal constant [7 x i32] [i32 131079, i32 131080, i32 131081, i32 131082, i32 131083, i32 131084, i32 131085], align 16
@Flocale_info.months = internal constant [12 x i32] [i32 131098, i32 131099, i32 131100, i32 131101, i32 131102, i32 131103, i32 131104, i32 131105, i32 131106, i32 131107, i32 131108, i32 131109], align 16
@current_buffer = external global %struct.buffer*, align 8
@.str.14 = private unnamed_addr constant [48 x i8] c"Multibyte character in data for base64 encoding\00", align 1
@.str.15 = private unnamed_addr constant [20 x i8] c"Invalid base64 data\00", align 1
@.str.16 = private unnamed_addr constant [21 x i8] c"Hash table too large\00", align 1
@weak_hash_tables = internal global %struct.Lisp_Hash_Table* null, align 8
@hashtest_eq = common global %struct.hash_table_test zeroinitializer, align 8
@hashtest_eql = common global %struct.hash_table_test zeroinitializer, align 8
@hashtest_equal = common global %struct.hash_table_test zeroinitializer, align 8
@.str.17 = private unnamed_addr constant [24 x i8] c"Invalid hash table test\00", align 1
@.str.18 = private unnamed_addr constant [24 x i8] c"Invalid hash table size\00", align 1
@.str.19 = private unnamed_addr constant [31 x i8] c"Invalid hash table rehash size\00", align 1
@.str.20 = private unnamed_addr constant [36 x i8] c"Invalid hash table rehash threshold\00", align 1
@.str.21 = private unnamed_addr constant [28 x i8] c"Invalid hash table weakness\00", align 1
@.str.22 = private unnamed_addr constant [22 x i8] c"Invalid argument list\00", align 1
@syms_of_fns.o_fwd = internal global %struct.Lisp_Objfwd zeroinitializer, align 8
@.str.23 = private unnamed_addr constant [9 x i8] c"features\00", align 1
@syms_of_fns.b_fwd = internal global %struct.Lisp_Boolfwd zeroinitializer, align 8
@.str.24 = private unnamed_addr constant [15 x i8] c"use-dialog-box\00", align 1
@syms_of_fns.b_fwd.25 = internal global %struct.Lisp_Boolfwd zeroinitializer, align 8
@.str.26 = private unnamed_addr constant [16 x i8] c"use-file-dialog\00", align 1
@.str.27 = private unnamed_addr constant [24 x i8] c"Stack overflow in equal\00", align 1
@base64_value_to_char = internal constant [64 x i8] c"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", align 16
@base64_char_to_value = internal constant [128 x i16] [i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 62, i16 -1, i16 -1, i16 -1, i16 63, i16 52, i16 53, i16 54, i16 55, i16 56, i16 57, i16 58, i16 59, i16 60, i16 61, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 0, i16 1, i16 2, i16 3, i16 4, i16 5, i16 6, i16 7, i16 8, i16 9, i16 10, i16 11, i16 12, i16 13, i16 14, i16 15, i16 16, i16 17, i16 18, i16 19, i16 20, i16 21, i16 22, i16 23, i16 24, i16 25, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1, i16 26, i16 27, i16 28, i16 29, i16 30, i16 31, i16 32, i16 33, i16 34, i16 35, i16 36, i16 37, i16 38, i16 39, i16 40, i16 41, i16 42, i16 43, i16 44, i16 45, i16 46, i16 47, i16 48, i16 49, i16 50, i16 51, i16 -1, i16 -1, i16 -1, i16 -1, i16 -1], align 16
@.str.28 = private unnamed_addr constant [31 x i8] c"Hash table too large to resize\00", align 1
@specpdl_ptr = external global %union.specbinding*, align 8
@.str.29 = private unnamed_addr constant [26 x i8] c"Invalid algorithm arg: %s\00", align 1
@secure_hash.hexdigit = internal constant [16 x i8] c"0123456789abcdef", align 16
@.str.30 = private unnamed_addr constant [7 x i8] c"sxhash\00", align 1
@Ssxhash = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fsxhash }, i16 1, i16 1, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.30, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.31 = private unnamed_addr constant [16 x i8] c"make-hash-table\00", align 1
@Smake_hash_table = internal global { %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64*)* } { i64 (i64, i64*)* @Fmake_hash_table }, i16 0, i16 -2, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.31, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.32 = private unnamed_addr constant [16 x i8] c"copy-hash-table\00", align 1
@Scopy_hash_table = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fcopy_hash_table }, i16 1, i16 1, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.32, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.33 = private unnamed_addr constant [17 x i8] c"hash-table-count\00", align 1
@Shash_table_count = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fhash_table_count }, i16 1, i16 1, i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.str.33, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.34 = private unnamed_addr constant [23 x i8] c"hash-table-rehash-size\00", align 1
@Shash_table_rehash_size = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fhash_table_rehash_size }, i16 1, i16 1, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.34, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.35 = private unnamed_addr constant [28 x i8] c"hash-table-rehash-threshold\00", align 1
@Shash_table_rehash_threshold = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fhash_table_rehash_threshold }, i16 1, i16 1, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.35, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.36 = private unnamed_addr constant [16 x i8] c"hash-table-size\00", align 1
@Shash_table_size = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fhash_table_size }, i16 1, i16 1, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.36, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.37 = private unnamed_addr constant [16 x i8] c"hash-table-test\00", align 1
@Shash_table_test = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fhash_table_test }, i16 1, i16 1, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.37, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.38 = private unnamed_addr constant [20 x i8] c"hash-table-weakness\00", align 1
@Shash_table_weakness = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fhash_table_weakness }, i16 1, i16 1, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.38, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.39 = private unnamed_addr constant [13 x i8] c"hash-table-p\00", align 1
@Shash_table_p = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fhash_table_p }, i16 1, i16 1, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.39, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.40 = private unnamed_addr constant [8 x i8] c"clrhash\00", align 1
@Sclrhash = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fclrhash }, i16 1, i16 1, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.40, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.41 = private unnamed_addr constant [8 x i8] c"gethash\00", align 1
@Sgethash = internal global { %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64, i64)* } { i64 (i64, i64, i64)* @Fgethash }, i16 2, i16 3, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.41, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.42 = private unnamed_addr constant [8 x i8] c"puthash\00", align 1
@Sputhash = internal global { %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64, i64)* } { i64 (i64, i64, i64)* @Fputhash }, i16 3, i16 3, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.42, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.43 = private unnamed_addr constant [8 x i8] c"remhash\00", align 1
@Sremhash = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fremhash }, i16 2, i16 2, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.43, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.44 = private unnamed_addr constant [8 x i8] c"maphash\00", align 1
@Smaphash = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fmaphash }, i16 2, i16 2, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.44, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.45 = private unnamed_addr constant [23 x i8] c"define-hash-table-test\00", align 1
@Sdefine_hash_table_test = internal global { %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64, i64)* } { i64 (i64, i64, i64)* @Fdefine_hash_table_test }, i16 3, i16 3, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.45, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.46 = private unnamed_addr constant [9 x i8] c"identity\00", align 1
@Sidentity = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fidentity }, i16 1, i16 1, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.46, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.47 = private unnamed_addr constant [7 x i8] c"random\00", align 1
@Srandom = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Frandom }, i16 0, i16 1, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.47, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.48 = private unnamed_addr constant [7 x i8] c"length\00", align 1
@Slength = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Flength }, i16 1, i16 1, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.48, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.49 = private unnamed_addr constant [12 x i8] c"safe-length\00", align 1
@Ssafe_length = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fsafe_length }, i16 1, i16 1, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.49, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.50 = private unnamed_addr constant [13 x i8] c"string-bytes\00", align 1
@Sstring_bytes = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fstring_bytes }, i16 1, i16 1, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.50, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.51 = private unnamed_addr constant [13 x i8] c"string-equal\00", align 1
@Sstring_equal = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fstring_equal }, i16 2, i16 2, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.51, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.52 = private unnamed_addr constant [16 x i8] c"compare-strings\00", align 1
@Scompare_strings = internal global { %struct.vectorlike_header, { i64 (i64, i64, i64, i64, i64, i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64, i64, i64, i64, i64, i64)* } { i64 (i64, i64, i64, i64, i64, i64, i64)* @Fcompare_strings }, i16 6, i16 7, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.52, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.53 = private unnamed_addr constant [13 x i8] c"string-lessp\00", align 1
@Sstring_lessp = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fstring_lessp }, i16 2, i16 2, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.53, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.54 = private unnamed_addr constant [21 x i8] c"string-collate-lessp\00", align 1
@Sstring_collate_lessp = internal global { %struct.vectorlike_header, { i64 (i64, i64, i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64, i64, i64)* } { i64 (i64, i64, i64, i64)* @Fstring_collate_lessp }, i16 2, i16 4, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.54, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.55 = private unnamed_addr constant [22 x i8] c"string-collate-equalp\00", align 1
@Sstring_collate_equalp = internal global { %struct.vectorlike_header, { i64 (i64, i64, i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64, i64, i64)* } { i64 (i64, i64, i64, i64)* @Fstring_collate_equalp }, i16 2, i16 4, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.55, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.56 = private unnamed_addr constant [7 x i8] c"append\00", align 1
@Sappend = internal global { %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64*)* } { i64 (i64, i64*)* @Fappend }, i16 0, i16 -2, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.56, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.57 = private unnamed_addr constant [7 x i8] c"concat\00", align 1
@Sconcat = internal global { %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64*)* } { i64 (i64, i64*)* @Fconcat }, i16 0, i16 -2, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.57, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.58 = private unnamed_addr constant [8 x i8] c"vconcat\00", align 1
@Svconcat = internal global { %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64*)* } { i64 (i64, i64*)* @Fvconcat }, i16 0, i16 -2, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.58, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.59 = private unnamed_addr constant [14 x i8] c"copy-sequence\00", align 1
@Scopy_sequence = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fcopy_sequence }, i16 1, i16 1, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.59, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.60 = private unnamed_addr constant [22 x i8] c"string-make-multibyte\00", align 1
@Sstring_make_multibyte = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fstring_make_multibyte }, i16 1, i16 1, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.60, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.61 = private unnamed_addr constant [20 x i8] c"string-make-unibyte\00", align 1
@Sstring_make_unibyte = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fstring_make_unibyte }, i16 1, i16 1, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.61, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.62 = private unnamed_addr constant [20 x i8] c"string-as-multibyte\00", align 1
@Sstring_as_multibyte = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fstring_as_multibyte }, i16 1, i16 1, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.62, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.63 = private unnamed_addr constant [18 x i8] c"string-as-unibyte\00", align 1
@Sstring_as_unibyte = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fstring_as_unibyte }, i16 1, i16 1, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.63, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.64 = private unnamed_addr constant [20 x i8] c"string-to-multibyte\00", align 1
@Sstring_to_multibyte = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fstring_to_multibyte }, i16 1, i16 1, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.64, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.65 = private unnamed_addr constant [18 x i8] c"string-to-unibyte\00", align 1
@Sstring_to_unibyte = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fstring_to_unibyte }, i16 1, i16 1, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.65, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.66 = private unnamed_addr constant [11 x i8] c"copy-alist\00", align 1
@Scopy_alist = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fcopy_alist }, i16 1, i16 1, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.66, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.67 = private unnamed_addr constant [10 x i8] c"substring\00", align 1
@Ssubstring = internal global { %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64, i64)* } { i64 (i64, i64, i64)* @Fsubstring }, i16 1, i16 3, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.67, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.68 = private unnamed_addr constant [24 x i8] c"substring-no-properties\00", align 1
@Ssubstring_no_properties = internal global { %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64, i64)* } { i64 (i64, i64, i64)* @Fsubstring_no_properties }, i16 1, i16 3, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.68, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.69 = private unnamed_addr constant [7 x i8] c"nthcdr\00", align 1
@Snthcdr = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fnthcdr }, i16 2, i16 2, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.69, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.70 = private unnamed_addr constant [4 x i8] c"nth\00", align 1
@Snth = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fnth }, i16 2, i16 2, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.70, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.71 = private unnamed_addr constant [4 x i8] c"elt\00", align 1
@Selt = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Felt }, i16 2, i16 2, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.71, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.72 = private unnamed_addr constant [7 x i8] c"member\00", align 1
@Smember = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fmember }, i16 2, i16 2, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.72, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.73 = private unnamed_addr constant [5 x i8] c"memq\00", align 1
@Smemq = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fmemq }, i16 2, i16 2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.73, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.74 = private unnamed_addr constant [6 x i8] c"memql\00", align 1
@Smemql = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fmemql }, i16 2, i16 2, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.74, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.75 = private unnamed_addr constant [5 x i8] c"assq\00", align 1
@Sassq = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fassq }, i16 2, i16 2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.75, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.76 = private unnamed_addr constant [6 x i8] c"assoc\00", align 1
@Sassoc = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fassoc }, i16 2, i16 2, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.76, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.77 = private unnamed_addr constant [6 x i8] c"rassq\00", align 1
@Srassq = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Frassq }, i16 2, i16 2, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.77, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.78 = private unnamed_addr constant [7 x i8] c"rassoc\00", align 1
@Srassoc = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Frassoc }, i16 2, i16 2, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.78, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.79 = private unnamed_addr constant [5 x i8] c"delq\00", align 1
@Sdelq = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fdelq }, i16 2, i16 2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.79, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.80 = private unnamed_addr constant [7 x i8] c"delete\00", align 1
@Sdelete = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fdelete }, i16 2, i16 2, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.80, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.81 = private unnamed_addr constant [9 x i8] c"nreverse\00", align 1
@Snreverse = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fnreverse }, i16 1, i16 1, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.81, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.82 = private unnamed_addr constant [8 x i8] c"reverse\00", align 1
@Sreverse = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Freverse }, i16 1, i16 1, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.82, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.83 = private unnamed_addr constant [5 x i8] c"sort\00", align 1
@Ssort = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fsort }, i16 2, i16 2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.83, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.84 = private unnamed_addr constant [10 x i8] c"plist-get\00", align 1
@Splist_get = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fplist_get }, i16 2, i16 2, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.84, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.85 = private unnamed_addr constant [4 x i8] c"get\00", align 1
@Sget = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fget }, i16 2, i16 2, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.85, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.86 = private unnamed_addr constant [10 x i8] c"plist-put\00", align 1
@Splist_put = internal global { %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64, i64)* } { i64 (i64, i64, i64)* @Fplist_put }, i16 3, i16 3, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.86, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.87 = private unnamed_addr constant [4 x i8] c"put\00", align 1
@Sput = internal global { %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64, i64)* } { i64 (i64, i64, i64)* @Fput }, i16 3, i16 3, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.87, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.88 = private unnamed_addr constant [14 x i8] c"lax-plist-get\00", align 1
@Slax_plist_get = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Flax_plist_get }, i16 2, i16 2, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.88, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.89 = private unnamed_addr constant [14 x i8] c"lax-plist-put\00", align 1
@Slax_plist_put = internal global { %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64, i64)* } { i64 (i64, i64, i64)* @Flax_plist_put }, i16 3, i16 3, i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str.89, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.90 = private unnamed_addr constant [4 x i8] c"eql\00", align 1
@Seql = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Feql }, i16 2, i16 2, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.90, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.91 = private unnamed_addr constant [6 x i8] c"equal\00", align 1
@Sequal = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fequal }, i16 2, i16 2, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.91, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.92 = private unnamed_addr constant [27 x i8] c"equal-including-properties\00", align 1
@Sequal_including_properties = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fequal_including_properties }, i16 2, i16 2, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.92, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.93 = private unnamed_addr constant [10 x i8] c"fillarray\00", align 1
@Sfillarray = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Ffillarray }, i16 2, i16 2, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.93, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.94 = private unnamed_addr constant [13 x i8] c"clear-string\00", align 1
@Sclear_string = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fclear_string }, i16 1, i16 1, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.94, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.95 = private unnamed_addr constant [6 x i8] c"nconc\00", align 1
@Snconc = internal global { %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64*)* } { i64 (i64, i64*)* @Fnconc }, i16 0, i16 -2, i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.str.95, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.96 = private unnamed_addr constant [7 x i8] c"mapcar\00", align 1
@Smapcar = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fmapcar }, i16 2, i16 2, i8* getelementptr inbounds ([7 x i8], [7 x i8]* @.str.96, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.97 = private unnamed_addr constant [5 x i8] c"mapc\00", align 1
@Smapc = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fmapc }, i16 2, i16 2, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.str.97, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.98 = private unnamed_addr constant [10 x i8] c"mapconcat\00", align 1
@Smapconcat = internal global { %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64, i64)* } { i64 (i64, i64, i64)* @Fmapconcat }, i16 3, i16 3, i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.str.98, i32 0, i32 0), i8* null, i8* null }, align 8
@Syes_or_no_p = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fyes_or_no_p }, i16 1, i16 1, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.3, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.99 = private unnamed_addr constant [13 x i8] c"load-average\00", align 1
@Sload_average = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fload_average }, i16 0, i16 1, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.99, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.100 = private unnamed_addr constant [9 x i8] c"featurep\00", align 1
@Sfeaturep = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Ffeaturep }, i16 1, i16 2, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.100, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.101 = private unnamed_addr constant [8 x i8] c"require\00", align 1
@Srequire = internal global { %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64, i64)* } { i64 (i64, i64, i64)* @Frequire }, i16 1, i16 3, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.101, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.102 = private unnamed_addr constant [8 x i8] c"provide\00", align 1
@Sprovide = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fprovide }, i16 1, i16 2, i8* getelementptr inbounds ([8 x i8], [8 x i8]* @.str.102, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.103 = private unnamed_addr constant [13 x i8] c"plist-member\00", align 1
@Splist_member = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fplist_member }, i16 2, i16 2, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.103, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.104 = private unnamed_addr constant [11 x i8] c"widget-put\00", align 1
@Swidget_put = internal global { %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64, i64)* } { i64 (i64, i64, i64)* @Fwidget_put }, i16 3, i16 3, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.104, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.105 = private unnamed_addr constant [11 x i8] c"widget-get\00", align 1
@Swidget_get = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fwidget_get }, i16 2, i16 2, i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.str.105, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.106 = private unnamed_addr constant [13 x i8] c"widget-apply\00", align 1
@Swidget_apply = internal global { %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64*)* } { i64 (i64, i64*)* @Fwidget_apply }, i16 2, i16 -2, i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.106, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.107 = private unnamed_addr constant [21 x i8] c"base64-encode-region\00", align 1
@.str.108 = private unnamed_addr constant [2 x i8] c"r\00", align 1
@Sbase64_encode_region = internal global { %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64, i64)* } { i64 (i64, i64, i64)* @Fbase64_encode_region }, i16 2, i16 3, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.107, i32 0, i32 0), i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.108, i32 0, i32 0), i8* null }, align 8
@.str.109 = private unnamed_addr constant [21 x i8] c"base64-decode-region\00", align 1
@Sbase64_decode_region = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fbase64_decode_region }, i16 2, i16 2, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.109, i32 0, i32 0), i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.108, i32 0, i32 0), i8* null }, align 8
@.str.110 = private unnamed_addr constant [21 x i8] c"base64-encode-string\00", align 1
@Sbase64_encode_string = internal global { %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64)* } { i64 (i64, i64)* @Fbase64_encode_string }, i16 1, i16 2, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.110, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.111 = private unnamed_addr constant [21 x i8] c"base64-decode-string\00", align 1
@Sbase64_decode_string = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Fbase64_decode_string }, i16 1, i16 1, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.111, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.112 = private unnamed_addr constant [4 x i8] c"md5\00", align 1
@Smd5 = internal global { %struct.vectorlike_header, { i64 (i64, i64, i64, i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64, i64, i64, i64)* } { i64 (i64, i64, i64, i64, i64)* @Fmd5 }, i16 1, i16 5, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.112, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.113 = private unnamed_addr constant [12 x i8] c"secure-hash\00", align 1
@Ssecure_hash = internal global { %struct.vectorlike_header, { i64 (i64, i64, i64, i64, i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64, i64, i64, i64, i64)* } { i64 (i64, i64, i64, i64, i64)* @Fsecure_hash }, i16 2, i16 5, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.113, i32 0, i32 0), i8* null, i8* null }, align 8
@.str.114 = private unnamed_addr constant [12 x i8] c"locale-info\00", align 1
@Slocale_info = internal global { %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* } { %struct.vectorlike_header { i64 167772160 }, { i64 (i64)* } { i64 (i64)* @Flocale_info }, i16 1, i16 1, i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.114, i32 0, i32 0), i8* null, i8* null }, align 8

; Function Attrs: nounwind readnone uwtable
define i64 @Fidentity(i64 %arg) #0 {
entry:
  %arg.addr = alloca i64, align 8
  store i64 %arg, i64* %arg.addr, align 8
  %0 = load i64, i64* %arg.addr, align 8
  ret i64 %0
}

; Function Attrs: nounwind uwtable
define i64 @Frandom(i64 %limit) #1 {
entry:
  %retval = alloca i64, align 8
  %limit.addr = alloca i64, align 8
  %val = alloca i64, align 8
  %remainder = alloca i64, align 8
  store i64 %limit, i64* %limit.addr, align 8
  %0 = load i64, i64* %limit.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 901)
  %cmp = icmp eq i64 %0, %call
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  call void @init_random()
  br label %if.end.5

if.else:                                          ; preds = %entry
  %1 = load i64, i64* %limit.addr, align 8
  %call1 = call zeroext i1 @STRINGP(i64 %1)
  br i1 %call1, label %if.then.2, label %if.end

if.then.2:                                        ; preds = %if.else
  %2 = load i64, i64* %limit.addr, align 8
  %call3 = call i8* @SSDATA(i64 %2)
  %3 = load i64, i64* %limit.addr, align 8
  %call4 = call i64 @SBYTES(i64 %3)
  call void @seed_random(i8* %call3, i64 %call4)
  br label %if.end

if.end:                                           ; preds = %if.then.2, %if.else
  br label %if.end.5

if.end.5:                                         ; preds = %if.end, %if.then
  %call6 = call i64 @get_random()
  store i64 %call6, i64* %val, align 8
  %4 = load i64, i64* %limit.addr, align 8
  %and = and i64 %4, 7
  %conv = trunc i64 %and to i32
  %and7 = and i32 %conv, -5
  %cmp8 = icmp eq i32 %and7, 2
  br i1 %cmp8, label %land.lhs.true, label %if.end.22

land.lhs.true:                                    ; preds = %if.end.5
  %5 = load i64, i64* %limit.addr, align 8
  %shr = ashr i64 %5, 2
  %cmp10 = icmp slt i64 0, %shr
  br i1 %cmp10, label %if.then.12, label %if.end.22

if.then.12:                                       ; preds = %land.lhs.true
  br label %while.body

while.body:                                       ; preds = %if.then.12, %if.end.20
  %6 = load i64, i64* %val, align 8
  %7 = load i64, i64* %limit.addr, align 8
  %shr13 = ashr i64 %7, 2
  %rem = srem i64 %6, %shr13
  store i64 %rem, i64* %remainder, align 8
  %8 = load i64, i64* %val, align 8
  %9 = load i64, i64* %remainder, align 8
  %sub = sub nsw i64 %8, %9
  %10 = load i64, i64* %limit.addr, align 8
  %shr14 = ashr i64 %10, 2
  %sub15 = sub nsw i64 4611686018427387903, %shr14
  %add = add nsw i64 %sub15, 1
  %cmp16 = icmp sle i64 %sub, %add
  br i1 %cmp16, label %if.then.18, label %if.end.20

if.then.18:                                       ; preds = %while.body
  %11 = load i64, i64* %remainder, align 8
  %shl = shl i64 %11, 2
  %add19 = add i64 %shl, 2
  store i64 %add19, i64* %retval
  br label %return

if.end.20:                                        ; preds = %while.body
  %call21 = call i64 @get_random()
  store i64 %call21, i64* %val, align 8
  br label %while.body

if.end.22:                                        ; preds = %land.lhs.true, %if.end.5
  %12 = load i64, i64* %val, align 8
  %shl23 = shl i64 %12, 2
  %add24 = add i64 %shl23, 2
  store i64 %add24, i64* %retval
  br label %return

return:                                           ; preds = %if.end.22, %if.then.18
  %13 = load i64, i64* %retval
  ret i64 %13
}

declare i64 @builtin_lisp_symbol(i32) #2

declare void @init_random() #2

declare zeroext i1 @STRINGP(i64) #2

declare void @seed_random(i8*, i64) #2

declare i8* @SSDATA(i64) #2

declare i64 @SBYTES(i64) #2

declare i64 @get_random() #2

; Function Attrs: nounwind uwtable
define i64 @Flength(i64 %sequence) #1 {
entry:
  %sequence.addr = alloca i64, align 8
  %val = alloca i64, align 8
  %i = alloca i64, align 8
  store i64 %sequence, i64* %sequence.addr, align 8
  %0 = load i64, i64* %sequence.addr, align 8
  %call = call zeroext i1 @STRINGP(i64 %0)
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i64, i64* %sequence.addr, align 8
  %call1 = call i64 @SCHARS(i64 %1)
  %call2 = call i64 @make_natnum(i64 %call1)
  store i64 %call2, i64* %val, align 8
  br label %if.end.64

if.else:                                          ; preds = %entry
  %2 = load i64, i64* %sequence.addr, align 8
  %call3 = call zeroext i1 @VECTORP(i64 %2)
  br i1 %call3, label %if.then.4, label %if.else.7

if.then.4:                                        ; preds = %if.else
  %3 = load i64, i64* %sequence.addr, align 8
  %call5 = call i64 @ASIZE(i64 %3)
  %call6 = call i64 @make_natnum(i64 %call5)
  store i64 %call6, i64* %val, align 8
  br label %if.end.63

if.else.7:                                        ; preds = %if.else
  %4 = load i64, i64* %sequence.addr, align 8
  %call8 = call zeroext i1 @CHAR_TABLE_P(i64 %4)
  br i1 %call8, label %if.then.9, label %if.else.11

if.then.9:                                        ; preds = %if.else.7
  %call10 = call i64 @make_natnum(i64 4194303)
  store i64 %call10, i64* %val, align 8
  br label %if.end.62

if.else.11:                                       ; preds = %if.else.7
  %5 = load i64, i64* %sequence.addr, align 8
  %call12 = call zeroext i1 @BOOL_VECTOR_P(i64 %5)
  br i1 %call12, label %if.then.13, label %if.else.16

if.then.13:                                       ; preds = %if.else.11
  %6 = load i64, i64* %sequence.addr, align 8
  %call14 = call i64 @bool_vector_size(i64 %6)
  %call15 = call i64 @make_natnum(i64 %call14)
  store i64 %call15, i64* %val, align 8
  br label %if.end.61

if.else.16:                                       ; preds = %if.else.11
  %7 = load i64, i64* %sequence.addr, align 8
  %call17 = call zeroext i1 @COMPILEDP(i64 %7)
  br i1 %call17, label %if.then.18, label %if.else.21

if.then.18:                                       ; preds = %if.else.16
  %8 = load i64, i64* %sequence.addr, align 8
  %call19 = call i64 @ASIZE(i64 %8)
  %and = and i64 %call19, 4095
  %call20 = call i64 @make_natnum(i64 %and)
  store i64 %call20, i64* %val, align 8
  br label %if.end.60

if.else.21:                                       ; preds = %if.else.16
  %9 = load i64, i64* %sequence.addr, align 8
  %and22 = and i64 %9, 7
  %conv = trunc i64 %and22 to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %if.then.24, label %if.else.50

if.then.24:                                       ; preds = %if.else.21
  store i64 0, i64* %i, align 8
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.then.24
  %10 = load i64, i64* %i, align 8
  %inc = add nsw i64 %10, 1
  store i64 %inc, i64* %i, align 8
  %11 = load i64, i64* %i, align 8
  %and25 = and i64 %11, 65535
  %cmp26 = icmp eq i64 %and25, 0
  br i1 %cmp26, label %if.then.28, label %if.end.44

if.then.28:                                       ; preds = %do.body
  %12 = load i64, i64* %i, align 8
  %cmp29 = icmp slt i64 2305843009213693951, %12
  br i1 %cmp29, label %if.then.31, label %if.end

if.then.31:                                       ; preds = %if.then.28
  call void (i8*, ...) @error(i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.str, i32 0, i32 0)) #8
  unreachable

if.end:                                           ; preds = %if.then.28
  br label %do.body.32

do.body.32:                                       ; preds = %if.end
  %13 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call33 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp34 = icmp eq i64 %13, %call33
  br i1 %cmp34, label %if.else.40, label %land.lhs.true

land.lhs.true:                                    ; preds = %do.body.32
  %14 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  %call36 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp37 = icmp eq i64 %14, %call36
  br i1 %cmp37, label %if.then.39, label %if.else.40

if.then.39:                                       ; preds = %land.lhs.true
  call void @process_quit_flag()
  br label %if.end.43

if.else.40:                                       ; preds = %land.lhs.true, %do.body.32
  %15 = load volatile i8, i8* @pending_signals, align 1
  %tobool = trunc i8 %15 to i1
  br i1 %tobool, label %if.then.41, label %if.end.42

if.then.41:                                       ; preds = %if.else.40
  call void @process_pending_signals()
  br label %if.end.42

if.end.42:                                        ; preds = %if.then.41, %if.else.40
  br label %if.end.43

if.end.43:                                        ; preds = %if.end.42, %if.then.39
  br label %do.end

do.end:                                           ; preds = %if.end.43
  br label %if.end.44

if.end.44:                                        ; preds = %do.end, %do.body
  %16 = load i64, i64* %sequence.addr, align 8
  %sub = sub nsw i64 %16, 3
  %17 = inttoptr i64 %sub to i8*
  %18 = bitcast i8* %17 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %18, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %19 = load i64, i64* %cdr, align 8
  store i64 %19, i64* %sequence.addr, align 8
  br label %do.cond

do.cond:                                          ; preds = %if.end.44
  %20 = load i64, i64* %sequence.addr, align 8
  %and45 = and i64 %20, 7
  %conv46 = trunc i64 %and45 to i32
  %cmp47 = icmp eq i32 %conv46, 3
  br i1 %cmp47, label %do.body, label %do.end.49

do.end.49:                                        ; preds = %do.cond
  %21 = load i64, i64* %sequence.addr, align 8
  %22 = load i64, i64* %sequence.addr, align 8
  call void @CHECK_LIST_END(i64 %21, i64 %22)
  %23 = load i64, i64* %i, align 8
  %shl = shl i64 %23, 2
  %add = add i64 %shl, 2
  store i64 %add, i64* %val, align 8
  br label %if.end.59

if.else.50:                                       ; preds = %if.else.21
  %24 = load i64, i64* %sequence.addr, align 8
  %call51 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp52 = icmp eq i64 %24, %call51
  br i1 %cmp52, label %if.then.54, label %if.else.56

if.then.54:                                       ; preds = %if.else.50
  %call55 = call i64 @make_natnum(i64 0)
  store i64 %call55, i64* %val, align 8
  br label %if.end.58

if.else.56:                                       ; preds = %if.else.50
  %call57 = call i64 @builtin_lisp_symbol(i32 844)
  %25 = load i64, i64* %sequence.addr, align 8
  %26 = call i64 @wrong_type_argument(i64 %call57, i64 %25) #8
  unreachable

if.end.58:                                        ; preds = %if.then.54
  br label %if.end.59

if.end.59:                                        ; preds = %if.end.58, %do.end.49
  br label %if.end.60

if.end.60:                                        ; preds = %if.end.59, %if.then.18
  br label %if.end.61

if.end.61:                                        ; preds = %if.end.60, %if.then.13
  br label %if.end.62

if.end.62:                                        ; preds = %if.end.61, %if.then.9
  br label %if.end.63

if.end.63:                                        ; preds = %if.end.62, %if.then.4
  br label %if.end.64

if.end.64:                                        ; preds = %if.end.63, %if.then
  %27 = load i64, i64* %val, align 8
  ret i64 %27
}

declare i64 @make_natnum(i64) #2

declare i64 @SCHARS(i64) #2

declare zeroext i1 @VECTORP(i64) #2

declare i64 @ASIZE(i64) #2

declare zeroext i1 @CHAR_TABLE_P(i64) #2

declare zeroext i1 @BOOL_VECTOR_P(i64) #2

declare i64 @bool_vector_size(i64) #2

declare zeroext i1 @COMPILEDP(i64) #2

; Function Attrs: noreturn
declare void @error(i8*, ...) #3

declare void @process_quit_flag() #2

declare void @process_pending_signals() #2

; Function Attrs: nounwind uwtable
define internal void @CHECK_LIST_END(i64 %x, i64 %y) #1 {
entry:
  %x.addr = alloca i64, align 8
  %y.addr = alloca i64, align 8
  store i64 %x, i64* %x.addr, align 8
  store i64 %y, i64* %y.addr, align 8
  %0 = load i64, i64* %x.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %0, %call
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call1 = call i64 @builtin_lisp_symbol(i32 626)
  %1 = load i64, i64* %y.addr, align 8
  %2 = call i64 @wrong_type_argument(i64 %call1, i64 %1) #8
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %3, %cond.true
  ret void
}

; Function Attrs: noreturn
declare i64 @wrong_type_argument(i64, i64) #3

; Function Attrs: nounwind uwtable
define i64 @Fsafe_length(i64 %list) #1 {
entry:
  %retval = alloca i64, align 8
  %list.addr = alloca i64, align 8
  %tail = alloca i64, align 8
  %halftail = alloca i64, align 8
  %hilen = alloca double, align 8
  %lolen = alloca i64, align 8
  store i64 %list, i64* %list.addr, align 8
  store double 0.000000e+00, double* %hilen, align 8
  store i64 1, i64* %lolen, align 8
  %0 = load i64, i64* %list.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i64 2, i64* %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64, i64* %list.addr, align 8
  store i64 %1, i64* %halftail, align 8
  store i64 %1, i64* %tail, align 8
  br label %for.cond

for.cond:                                         ; preds = %if.end.37, %if.end
  %2 = load i64, i64* %tail, align 8
  %sub = sub nsw i64 %2, 3
  %3 = inttoptr i64 %sub to i8*
  %4 = bitcast i8* %3 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %4, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %5 = load i64, i64* %cdr, align 8
  store i64 %5, i64* %tail, align 8
  %6 = load i64, i64* %tail, align 8
  %and2 = and i64 %6, 7
  %conv3 = trunc i64 %and2 to i32
  %cmp4 = icmp eq i32 %conv3, 3
  br i1 %cmp4, label %if.end.7, label %if.then.6

if.then.6:                                        ; preds = %for.cond
  br label %for.end

if.end.7:                                         ; preds = %for.cond
  %7 = load i64, i64* %tail, align 8
  %8 = load i64, i64* %halftail, align 8
  %cmp8 = icmp eq i64 %7, %8
  br i1 %cmp8, label %if.then.10, label %if.end.11

if.then.10:                                       ; preds = %if.end.7
  br label %for.end

if.end.11:                                        ; preds = %if.end.7
  %9 = load i64, i64* %lolen, align 8
  %inc = add i64 %9, 1
  store i64 %inc, i64* %lolen, align 8
  %10 = load i64, i64* %lolen, align 8
  %and12 = and i64 %10, 1
  %cmp13 = icmp eq i64 %and12, 0
  br i1 %cmp13, label %if.then.15, label %if.end.37

if.then.15:                                       ; preds = %if.end.11
  %11 = load i64, i64* %halftail, align 8
  %sub16 = sub nsw i64 %11, 3
  %12 = inttoptr i64 %sub16 to i8*
  %13 = bitcast i8* %12 to %struct.Lisp_Cons*
  %u17 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %13, i32 0, i32 1
  %cdr18 = bitcast %union.anon* %u17 to i64*
  %14 = load i64, i64* %cdr18, align 8
  store i64 %14, i64* %halftail, align 8
  %15 = load i64, i64* %lolen, align 8
  %and19 = and i64 %15, 65535
  %cmp20 = icmp eq i64 %and19, 0
  br i1 %cmp20, label %if.then.22, label %if.end.36

if.then.22:                                       ; preds = %if.then.15
  br label %do.body

do.body:                                          ; preds = %if.then.22
  %16 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp23 = icmp eq i64 %16, %call
  br i1 %cmp23, label %if.else, label %land.lhs.true

land.lhs.true:                                    ; preds = %do.body
  %17 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  %call25 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp26 = icmp eq i64 %17, %call25
  br i1 %cmp26, label %if.then.28, label %if.else

if.then.28:                                       ; preds = %land.lhs.true
  call void @process_quit_flag()
  br label %if.end.31

if.else:                                          ; preds = %land.lhs.true, %do.body
  %18 = load volatile i8, i8* @pending_signals, align 1
  %tobool = trunc i8 %18 to i1
  br i1 %tobool, label %if.then.29, label %if.end.30

if.then.29:                                       ; preds = %if.else
  call void @process_pending_signals()
  br label %if.end.30

if.end.30:                                        ; preds = %if.then.29, %if.else
  br label %if.end.31

if.end.31:                                        ; preds = %if.end.30, %if.then.28
  br label %do.end

do.end:                                           ; preds = %if.end.31
  %19 = load i64, i64* %lolen, align 8
  %cmp32 = icmp eq i64 %19, 0
  br i1 %cmp32, label %if.then.34, label %if.end.35

if.then.34:                                       ; preds = %do.end
  %20 = load double, double* %hilen, align 8
  %add = fadd double %20, 0x43F0000000000000
  store double %add, double* %hilen, align 8
  br label %if.end.35

if.end.35:                                        ; preds = %if.then.34, %do.end
  br label %if.end.36

if.end.36:                                        ; preds = %if.end.35, %if.then.15
  br label %if.end.37

if.end.37:                                        ; preds = %if.end.36, %if.end.11
  br label %for.cond

for.end:                                          ; preds = %if.then.10, %if.then.6
  %21 = load double, double* %hilen, align 8
  %tobool38 = fcmp une double %21, 0.000000e+00
  br i1 %tobool38, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.end
  %22 = load double, double* %hilen, align 8
  %23 = load i64, i64* %lolen, align 8
  %conv39 = uitofp i64 %23 to double
  %add40 = fadd double %22, %conv39
  %call41 = call i64 @make_float(double %add40)
  br label %cond.end.54

cond.false:                                       ; preds = %for.end
  %24 = load i64, i64* %lolen, align 8
  %cmp42 = icmp ule i64 0, %24
  br i1 %cmp42, label %land.lhs.true.46, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.false
  %25 = load i64, i64* %lolen, align 8
  %cmp44 = icmp ule i64 -2305843009213693952, %25
  br i1 %cmp44, label %land.lhs.true.46, label %cond.true.49

land.lhs.true.46:                                 ; preds = %lor.lhs.false, %cond.false
  %26 = load i64, i64* %lolen, align 8
  %cmp47 = icmp ule i64 %26, 2305843009213693951
  br i1 %cmp47, label %cond.false.52, label %cond.true.49

cond.true.49:                                     ; preds = %land.lhs.true.46, %lor.lhs.false
  %27 = load i64, i64* %lolen, align 8
  %conv50 = uitofp i64 %27 to double
  %call51 = call i64 @make_float(double %conv50)
  br label %cond.end

cond.false.52:                                    ; preds = %land.lhs.true.46
  %28 = load i64, i64* %lolen, align 8
  %shl = shl i64 %28, 2
  %add53 = add i64 %shl, 2
  br label %cond.end

cond.end:                                         ; preds = %cond.false.52, %cond.true.49
  %cond = phi i64 [ %call51, %cond.true.49 ], [ %add53, %cond.false.52 ]
  br label %cond.end.54

cond.end.54:                                      ; preds = %cond.end, %cond.true
  %cond55 = phi i64 [ %call41, %cond.true ], [ %cond, %cond.end ]
  store i64 %cond55, i64* %retval
  br label %return

return:                                           ; preds = %cond.end.54, %if.then
  %29 = load i64, i64* %retval
  ret i64 %29
}

declare i64 @make_float(double) #2

; Function Attrs: nounwind uwtable
define i64 @Fstring_bytes(i64 %string) #1 {
entry:
  %string.addr = alloca i64, align 8
  store i64 %string, i64* %string.addr, align 8
  %0 = load i64, i64* %string.addr, align 8
  call void @CHECK_STRING(i64 %0)
  %1 = load i64, i64* %string.addr, align 8
  %call = call i64 @SBYTES(i64 %1)
  %shl = shl i64 %call, 2
  %add = add i64 %shl, 2
  ret i64 %add
}

declare void @CHECK_STRING(i64) #2

; Function Attrs: nounwind uwtable
define i64 @Fstring_equal(i64 %s1, i64 %s2) #1 {
entry:
  %retval = alloca i64, align 8
  %s1.addr = alloca i64, align 8
  %s2.addr = alloca i64, align 8
  store i64 %s1, i64* %s1.addr, align 8
  store i64 %s2, i64* %s2.addr, align 8
  %0 = load i64, i64* %s1.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i64, i64* %s1.addr, align 8
  %call = call i64 @SYMBOL_NAME(i64 %1)
  store i64 %call, i64* %s1.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i64, i64* %s2.addr, align 8
  %and2 = and i64 %2, 7
  %conv3 = trunc i64 %and2 to i32
  %cmp4 = icmp eq i32 %conv3, 0
  br i1 %cmp4, label %if.then.6, label %if.end.8

if.then.6:                                        ; preds = %if.end
  %3 = load i64, i64* %s2.addr, align 8
  %call7 = call i64 @SYMBOL_NAME(i64 %3)
  store i64 %call7, i64* %s2.addr, align 8
  br label %if.end.8

if.end.8:                                         ; preds = %if.then.6, %if.end
  %4 = load i64, i64* %s1.addr, align 8
  call void @CHECK_STRING(i64 %4)
  %5 = load i64, i64* %s2.addr, align 8
  call void @CHECK_STRING(i64 %5)
  %6 = load i64, i64* %s1.addr, align 8
  %call9 = call i64 @SCHARS(i64 %6)
  %7 = load i64, i64* %s2.addr, align 8
  %call10 = call i64 @SCHARS(i64 %7)
  %cmp11 = icmp ne i64 %call9, %call10
  br i1 %cmp11, label %if.then.22, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end.8
  %8 = load i64, i64* %s1.addr, align 8
  %call13 = call i64 @SBYTES(i64 %8)
  %9 = load i64, i64* %s2.addr, align 8
  %call14 = call i64 @SBYTES(i64 %9)
  %cmp15 = icmp ne i64 %call13, %call14
  br i1 %cmp15, label %if.then.22, label %lor.lhs.false.17

lor.lhs.false.17:                                 ; preds = %lor.lhs.false
  %10 = load i64, i64* %s1.addr, align 8
  %call18 = call i8* @SDATA(i64 %10)
  %11 = load i64, i64* %s2.addr, align 8
  %call19 = call i8* @SDATA(i64 %11)
  %12 = load i64, i64* %s1.addr, align 8
  %call20 = call i64 @SBYTES(i64 %12)
  %call21 = call i32 @memcmp(i8* %call18, i8* %call19, i64 %call20) #9
  %tobool = icmp ne i32 %call21, 0
  br i1 %tobool, label %if.then.22, label %if.end.24

if.then.22:                                       ; preds = %lor.lhs.false.17, %lor.lhs.false, %if.end.8
  %call23 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call23, i64* %retval
  br label %return

if.end.24:                                        ; preds = %lor.lhs.false.17
  %call25 = call i64 @builtin_lisp_symbol(i32 901)
  store i64 %call25, i64* %retval
  br label %return

return:                                           ; preds = %if.end.24, %if.then.22
  %13 = load i64, i64* %retval
  ret i64 %13
}

declare i64 @SYMBOL_NAME(i64) #2

; Function Attrs: nounwind readonly
declare i32 @memcmp(i8*, i8*, i64) #4

declare i8* @SDATA(i64) #2

; Function Attrs: nounwind uwtable
define i64 @Fcompare_strings(i64 %str1, i64 %start1, i64 %end1, i64 %str2, i64 %start2, i64 %end2, i64 %ignore_case) #1 {
entry:
  %retval = alloca i64, align 8
  %str1.addr = alloca i64, align 8
  %start1.addr = alloca i64, align 8
  %end1.addr = alloca i64, align 8
  %str2.addr = alloca i64, align 8
  %start2.addr = alloca i64, align 8
  %end2.addr = alloca i64, align 8
  %ignore_case.addr = alloca i64, align 8
  %from1 = alloca i64, align 8
  %to1 = alloca i64, align 8
  %from2 = alloca i64, align 8
  %to2 = alloca i64, align 8
  %i1 = alloca i64, align 8
  %i1_byte = alloca i64, align 8
  %i2 = alloca i64, align 8
  %i2_byte = alloca i64, align 8
  %c1 = alloca i32, align 4
  %c2 = alloca i32, align 4
  %chp = alloca i8*, align 8
  %chlen = alloca i32, align 4
  %chp104 = alloca i8*, align 8
  %chlen107 = alloca i32, align 4
  store i64 %str1, i64* %str1.addr, align 8
  store i64 %start1, i64* %start1.addr, align 8
  store i64 %end1, i64* %end1.addr, align 8
  store i64 %str2, i64* %str2.addr, align 8
  store i64 %start2, i64* %start2.addr, align 8
  store i64 %end2, i64* %end2.addr, align 8
  store i64 %ignore_case, i64* %ignore_case.addr, align 8
  %0 = load i64, i64* %str1.addr, align 8
  call void @CHECK_STRING(i64 %0)
  %1 = load i64, i64* %str2.addr, align 8
  call void @CHECK_STRING(i64 %1)
  %2 = load i64, i64* %end1.addr, align 8
  %and = and i64 %2, 7
  %conv = trunc i64 %and to i32
  %and1 = and i32 %conv, -5
  %cmp = icmp eq i32 %and1, 2
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %3 = load i64, i64* %str1.addr, align 8
  %call = call i64 @SCHARS(i64 %3)
  %4 = load i64, i64* %end1.addr, align 8
  %shr = ashr i64 %4, 2
  %cmp3 = icmp slt i64 %call, %shr
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %5 = load i64, i64* %str1.addr, align 8
  %call5 = call i64 @SCHARS(i64 %5)
  %shl = shl i64 %call5, 2
  %add = add i64 %shl, 2
  store i64 %add, i64* %end1.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %6 = load i64, i64* %end2.addr, align 8
  %and6 = and i64 %6, 7
  %conv7 = trunc i64 %and6 to i32
  %and8 = and i32 %conv7, -5
  %cmp9 = icmp eq i32 %and8, 2
  br i1 %cmp9, label %land.lhs.true.11, label %if.end.20

land.lhs.true.11:                                 ; preds = %if.end
  %7 = load i64, i64* %str2.addr, align 8
  %call12 = call i64 @SCHARS(i64 %7)
  %8 = load i64, i64* %end2.addr, align 8
  %shr13 = ashr i64 %8, 2
  %cmp14 = icmp slt i64 %call12, %shr13
  br i1 %cmp14, label %if.then.16, label %if.end.20

if.then.16:                                       ; preds = %land.lhs.true.11
  %9 = load i64, i64* %str2.addr, align 8
  %call17 = call i64 @SCHARS(i64 %9)
  %shl18 = shl i64 %call17, 2
  %add19 = add i64 %shl18, 2
  store i64 %add19, i64* %end2.addr, align 8
  br label %if.end.20

if.end.20:                                        ; preds = %if.then.16, %land.lhs.true.11, %if.end
  %10 = load i64, i64* %str1.addr, align 8
  %11 = load i64, i64* %start1.addr, align 8
  %12 = load i64, i64* %end1.addr, align 8
  %13 = load i64, i64* %str1.addr, align 8
  %call21 = call i64 @SCHARS(i64 %13)
  call void @validate_subarray(i64 %10, i64 %11, i64 %12, i64 %call21, i64* %from1, i64* %to1)
  %14 = load i64, i64* %str2.addr, align 8
  %15 = load i64, i64* %start2.addr, align 8
  %16 = load i64, i64* %end2.addr, align 8
  %17 = load i64, i64* %str2.addr, align 8
  %call22 = call i64 @SCHARS(i64 %17)
  call void @validate_subarray(i64 %14, i64 %15, i64 %16, i64 %call22, i64* %from2, i64* %to2)
  %18 = load i64, i64* %from1, align 8
  store i64 %18, i64* %i1, align 8
  %19 = load i64, i64* %from2, align 8
  store i64 %19, i64* %i2, align 8
  %20 = load i64, i64* %str1.addr, align 8
  %21 = load i64, i64* %i1, align 8
  %call23 = call i64 @string_char_to_byte(i64 %20, i64 %21)
  store i64 %call23, i64* %i1_byte, align 8
  %22 = load i64, i64* %str2.addr, align 8
  %23 = load i64, i64* %i2, align 8
  %call24 = call i64 @string_char_to_byte(i64 %22, i64 %23)
  store i64 %call24, i64* %i2_byte, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.then.207, %if.then.186, %if.end.20
  %24 = load i64, i64* %i1, align 8
  %25 = load i64, i64* %to1, align 8
  %cmp25 = icmp slt i64 %24, %25
  br i1 %cmp25, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %26 = load i64, i64* %i2, align 8
  %27 = load i64, i64* %to2, align 8
  %cmp27 = icmp slt i64 %26, %27
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %28 = phi i1 [ false, %while.cond ], [ %cmp27, %land.rhs ]
  br i1 %28, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  br label %do.body

do.body:                                          ; preds = %while.body
  %29 = load i64, i64* %i1, align 8
  %inc = add nsw i64 %29, 1
  store i64 %inc, i64* %i1, align 8
  %30 = load i64, i64* %str1.addr, align 8
  %call29 = call zeroext i1 @STRING_MULTIBYTE(i64 %30)
  br i1 %call29, label %if.then.30, label %if.else

if.then.30:                                       ; preds = %do.body
  %31 = load i64, i64* %i1_byte, align 8
  %32 = load i64, i64* %str1.addr, align 8
  %call31 = call i8* @SDATA(i64 %32)
  %arrayidx = getelementptr inbounds i8, i8* %call31, i64 %31
  store i8* %arrayidx, i8** %chp, align 8
  %33 = load i8*, i8** %chp, align 8
  %arrayidx32 = getelementptr inbounds i8, i8* %33, i64 0
  %34 = load i8, i8* %arrayidx32, align 1
  %conv33 = zext i8 %34 to i32
  %and34 = and i32 %conv33, 128
  %tobool = icmp ne i32 %and34, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then.30
  store i32 1, i32* %chlen, align 4
  %35 = load i8*, i8** %chp, align 8
  %arrayidx35 = getelementptr inbounds i8, i8* %35, i64 0
  %36 = load i8, i8* %arrayidx35, align 1
  %conv36 = zext i8 %36 to i32
  br label %cond.end.78

cond.false:                                       ; preds = %if.then.30
  %37 = load i8*, i8** %chp, align 8
  %arrayidx37 = getelementptr inbounds i8, i8* %37, i64 0
  %38 = load i8, i8* %arrayidx37, align 1
  %conv38 = zext i8 %38 to i32
  %and39 = and i32 %conv38, 32
  %tobool40 = icmp ne i32 %and39, 0
  br i1 %tobool40, label %cond.false.54, label %cond.true.41

cond.true.41:                                     ; preds = %cond.false
  store i32 2, i32* %chlen, align 4
  %39 = load i8*, i8** %chp, align 8
  %arrayidx42 = getelementptr inbounds i8, i8* %39, i64 0
  %40 = load i8, i8* %arrayidx42, align 1
  %conv43 = zext i8 %40 to i32
  %and44 = and i32 %conv43, 31
  %shl45 = shl i32 %and44, 6
  %41 = load i8*, i8** %chp, align 8
  %arrayidx46 = getelementptr inbounds i8, i8* %41, i64 1
  %42 = load i8, i8* %arrayidx46, align 1
  %conv47 = zext i8 %42 to i32
  %and48 = and i32 %conv47, 63
  %or = or i32 %shl45, %and48
  %43 = load i8*, i8** %chp, align 8
  %arrayidx49 = getelementptr inbounds i8, i8* %43, i64 0
  %44 = load i8, i8* %arrayidx49, align 1
  %conv50 = zext i8 %44 to i32
  %cmp51 = icmp slt i32 %conv50, 194
  %cond = select i1 %cmp51, i32 4194176, i32 0
  %add53 = add nsw i32 %or, %cond
  br label %cond.end.76

cond.false.54:                                    ; preds = %cond.false
  %45 = load i8*, i8** %chp, align 8
  %arrayidx55 = getelementptr inbounds i8, i8* %45, i64 0
  %46 = load i8, i8* %arrayidx55, align 1
  %conv56 = zext i8 %46 to i32
  %and57 = and i32 %conv56, 16
  %tobool58 = icmp ne i32 %and57, 0
  br i1 %tobool58, label %cond.false.73, label %cond.true.59

cond.true.59:                                     ; preds = %cond.false.54
  store i32 3, i32* %chlen, align 4
  %47 = load i8*, i8** %chp, align 8
  %arrayidx60 = getelementptr inbounds i8, i8* %47, i64 0
  %48 = load i8, i8* %arrayidx60, align 1
  %conv61 = zext i8 %48 to i32
  %and62 = and i32 %conv61, 15
  %shl63 = shl i32 %and62, 12
  %49 = load i8*, i8** %chp, align 8
  %arrayidx64 = getelementptr inbounds i8, i8* %49, i64 1
  %50 = load i8, i8* %arrayidx64, align 1
  %conv65 = zext i8 %50 to i32
  %and66 = and i32 %conv65, 63
  %shl67 = shl i32 %and66, 6
  %or68 = or i32 %shl63, %shl67
  %51 = load i8*, i8** %chp, align 8
  %arrayidx69 = getelementptr inbounds i8, i8* %51, i64 2
  %52 = load i8, i8* %arrayidx69, align 1
  %conv70 = zext i8 %52 to i32
  %and71 = and i32 %conv70, 63
  %or72 = or i32 %or68, %and71
  br label %cond.end

cond.false.73:                                    ; preds = %cond.false.54
  %53 = load i8*, i8** %chp, align 8
  %call74 = call i32 @string_char(i8* %53, i8** null, i32* %chlen)
  br label %cond.end

cond.end:                                         ; preds = %cond.false.73, %cond.true.59
  %cond75 = phi i32 [ %or72, %cond.true.59 ], [ %call74, %cond.false.73 ]
  br label %cond.end.76

cond.end.76:                                      ; preds = %cond.end, %cond.true.41
  %cond77 = phi i32 [ %add53, %cond.true.41 ], [ %cond75, %cond.end ]
  br label %cond.end.78

cond.end.78:                                      ; preds = %cond.end.76, %cond.true
  %cond79 = phi i32 [ %conv36, %cond.true ], [ %cond77, %cond.end.76 ]
  store i32 %cond79, i32* %c1, align 4
  %54 = load i32, i32* %chlen, align 4
  %conv80 = sext i32 %54 to i64
  %55 = load i64, i64* %i1_byte, align 8
  %add81 = add nsw i64 %55, %conv80
  store i64 %add81, i64* %i1_byte, align 8
  br label %if.end.99

if.else:                                          ; preds = %do.body
  %56 = load i64, i64* %str1.addr, align 8
  %57 = load i64, i64* %i1_byte, align 8
  %call82 = call zeroext i8 @SREF(i64 %56, i64 %57)
  %conv83 = zext i8 %call82 to i32
  store i32 %conv83, i32* %c1, align 4
  %58 = load i64, i64* %i1_byte, align 8
  %inc84 = add nsw i64 %58, 1
  store i64 %inc84, i64* %i1_byte, align 8
  br i1 true, label %cond.true.85, label %cond.false.89

cond.true.85:                                     ; preds = %if.else
  %59 = load i32, i32* %c1, align 4
  %add86 = add i32 %59, 0
  %cmp87 = icmp ult i32 %add86, 128
  br i1 %cmp87, label %cond.true.94, label %cond.false.95

cond.false.89:                                    ; preds = %if.else
  %60 = load i32, i32* %c1, align 4
  %conv90 = sext i32 %60 to i64
  %add91 = add i64 %conv90, 0
  %cmp92 = icmp ult i64 %add91, 128
  br i1 %cmp92, label %cond.true.94, label %cond.false.95

cond.true.94:                                     ; preds = %cond.false.89, %cond.true.85
  %61 = load i32, i32* %c1, align 4
  br label %cond.end.97

cond.false.95:                                    ; preds = %cond.false.89, %cond.true.85
  %62 = load i32, i32* %c1, align 4
  %add96 = add nsw i32 %62, 4194048
  br label %cond.end.97

cond.end.97:                                      ; preds = %cond.false.95, %cond.true.94
  %cond98 = phi i32 [ %61, %cond.true.94 ], [ %add96, %cond.false.95 ]
  store i32 %cond98, i32* %c1, align 4
  br label %if.end.99

if.end.99:                                        ; preds = %cond.end.97, %cond.end.78
  br label %do.end

do.end:                                           ; preds = %if.end.99
  br label %do.body.100

do.body.100:                                      ; preds = %do.end
  %63 = load i64, i64* %i2, align 8
  %inc101 = add nsw i64 %63, 1
  store i64 %inc101, i64* %i2, align 8
  %64 = load i64, i64* %str2.addr, align 8
  %call102 = call zeroext i1 @STRING_MULTIBYTE(i64 %64)
  br i1 %call102, label %if.then.103, label %if.else.164

if.then.103:                                      ; preds = %do.body.100
  %65 = load i64, i64* %i2_byte, align 8
  %66 = load i64, i64* %str2.addr, align 8
  %call105 = call i8* @SDATA(i64 %66)
  %arrayidx106 = getelementptr inbounds i8, i8* %call105, i64 %65
  store i8* %arrayidx106, i8** %chp104, align 8
  %67 = load i8*, i8** %chp104, align 8
  %arrayidx108 = getelementptr inbounds i8, i8* %67, i64 0
  %68 = load i8, i8* %arrayidx108, align 1
  %conv109 = zext i8 %68 to i32
  %and110 = and i32 %conv109, 128
  %tobool111 = icmp ne i32 %and110, 0
  br i1 %tobool111, label %cond.false.115, label %cond.true.112

cond.true.112:                                    ; preds = %if.then.103
  store i32 1, i32* %chlen107, align 4
  %69 = load i8*, i8** %chp104, align 8
  %arrayidx113 = getelementptr inbounds i8, i8* %69, i64 0
  %70 = load i8, i8* %arrayidx113, align 1
  %conv114 = zext i8 %70 to i32
  br label %cond.end.160

cond.false.115:                                   ; preds = %if.then.103
  %71 = load i8*, i8** %chp104, align 8
  %arrayidx116 = getelementptr inbounds i8, i8* %71, i64 0
  %72 = load i8, i8* %arrayidx116, align 1
  %conv117 = zext i8 %72 to i32
  %and118 = and i32 %conv117, 32
  %tobool119 = icmp ne i32 %and118, 0
  br i1 %tobool119, label %cond.false.135, label %cond.true.120

cond.true.120:                                    ; preds = %cond.false.115
  store i32 2, i32* %chlen107, align 4
  %73 = load i8*, i8** %chp104, align 8
  %arrayidx121 = getelementptr inbounds i8, i8* %73, i64 0
  %74 = load i8, i8* %arrayidx121, align 1
  %conv122 = zext i8 %74 to i32
  %and123 = and i32 %conv122, 31
  %shl124 = shl i32 %and123, 6
  %75 = load i8*, i8** %chp104, align 8
  %arrayidx125 = getelementptr inbounds i8, i8* %75, i64 1
  %76 = load i8, i8* %arrayidx125, align 1
  %conv126 = zext i8 %76 to i32
  %and127 = and i32 %conv126, 63
  %or128 = or i32 %shl124, %and127
  %77 = load i8*, i8** %chp104, align 8
  %arrayidx129 = getelementptr inbounds i8, i8* %77, i64 0
  %78 = load i8, i8* %arrayidx129, align 1
  %conv130 = zext i8 %78 to i32
  %cmp131 = icmp slt i32 %conv130, 194
  %cond133 = select i1 %cmp131, i32 4194176, i32 0
  %add134 = add nsw i32 %or128, %cond133
  br label %cond.end.158

cond.false.135:                                   ; preds = %cond.false.115
  %79 = load i8*, i8** %chp104, align 8
  %arrayidx136 = getelementptr inbounds i8, i8* %79, i64 0
  %80 = load i8, i8* %arrayidx136, align 1
  %conv137 = zext i8 %80 to i32
  %and138 = and i32 %conv137, 16
  %tobool139 = icmp ne i32 %and138, 0
  br i1 %tobool139, label %cond.false.154, label %cond.true.140

cond.true.140:                                    ; preds = %cond.false.135
  store i32 3, i32* %chlen107, align 4
  %81 = load i8*, i8** %chp104, align 8
  %arrayidx141 = getelementptr inbounds i8, i8* %81, i64 0
  %82 = load i8, i8* %arrayidx141, align 1
  %conv142 = zext i8 %82 to i32
  %and143 = and i32 %conv142, 15
  %shl144 = shl i32 %and143, 12
  %83 = load i8*, i8** %chp104, align 8
  %arrayidx145 = getelementptr inbounds i8, i8* %83, i64 1
  %84 = load i8, i8* %arrayidx145, align 1
  %conv146 = zext i8 %84 to i32
  %and147 = and i32 %conv146, 63
  %shl148 = shl i32 %and147, 6
  %or149 = or i32 %shl144, %shl148
  %85 = load i8*, i8** %chp104, align 8
  %arrayidx150 = getelementptr inbounds i8, i8* %85, i64 2
  %86 = load i8, i8* %arrayidx150, align 1
  %conv151 = zext i8 %86 to i32
  %and152 = and i32 %conv151, 63
  %or153 = or i32 %or149, %and152
  br label %cond.end.156

cond.false.154:                                   ; preds = %cond.false.135
  %87 = load i8*, i8** %chp104, align 8
  %call155 = call i32 @string_char(i8* %87, i8** null, i32* %chlen107)
  br label %cond.end.156

cond.end.156:                                     ; preds = %cond.false.154, %cond.true.140
  %cond157 = phi i32 [ %or153, %cond.true.140 ], [ %call155, %cond.false.154 ]
  br label %cond.end.158

cond.end.158:                                     ; preds = %cond.end.156, %cond.true.120
  %cond159 = phi i32 [ %add134, %cond.true.120 ], [ %cond157, %cond.end.156 ]
  br label %cond.end.160

cond.end.160:                                     ; preds = %cond.end.158, %cond.true.112
  %cond161 = phi i32 [ %conv114, %cond.true.112 ], [ %cond159, %cond.end.158 ]
  store i32 %cond161, i32* %c2, align 4
  %88 = load i32, i32* %chlen107, align 4
  %conv162 = sext i32 %88 to i64
  %89 = load i64, i64* %i2_byte, align 8
  %add163 = add nsw i64 %89, %conv162
  store i64 %add163, i64* %i2_byte, align 8
  br label %if.end.182

if.else.164:                                      ; preds = %do.body.100
  %90 = load i64, i64* %str2.addr, align 8
  %91 = load i64, i64* %i2_byte, align 8
  %call165 = call zeroext i8 @SREF(i64 %90, i64 %91)
  %conv166 = zext i8 %call165 to i32
  store i32 %conv166, i32* %c2, align 4
  %92 = load i64, i64* %i2_byte, align 8
  %inc167 = add nsw i64 %92, 1
  store i64 %inc167, i64* %i2_byte, align 8
  br i1 true, label %cond.true.168, label %cond.false.172

cond.true.168:                                    ; preds = %if.else.164
  %93 = load i32, i32* %c2, align 4
  %add169 = add i32 %93, 0
  %cmp170 = icmp ult i32 %add169, 128
  br i1 %cmp170, label %cond.true.177, label %cond.false.178

cond.false.172:                                   ; preds = %if.else.164
  %94 = load i32, i32* %c2, align 4
  %conv173 = sext i32 %94 to i64
  %add174 = add i64 %conv173, 0
  %cmp175 = icmp ult i64 %add174, 128
  br i1 %cmp175, label %cond.true.177, label %cond.false.178

cond.true.177:                                    ; preds = %cond.false.172, %cond.true.168
  %95 = load i32, i32* %c2, align 4
  br label %cond.end.180

cond.false.178:                                   ; preds = %cond.false.172, %cond.true.168
  %96 = load i32, i32* %c2, align 4
  %add179 = add nsw i32 %96, 4194048
  br label %cond.end.180

cond.end.180:                                     ; preds = %cond.false.178, %cond.true.177
  %cond181 = phi i32 [ %95, %cond.true.177 ], [ %add179, %cond.false.178 ]
  store i32 %cond181, i32* %c2, align 4
  br label %if.end.182

if.end.182:                                       ; preds = %cond.end.180, %cond.end.160
  br label %do.end.183

do.end.183:                                       ; preds = %if.end.182
  %97 = load i32, i32* %c1, align 4
  %98 = load i32, i32* %c2, align 4
  %cmp184 = icmp eq i32 %97, %98
  br i1 %cmp184, label %if.then.186, label %if.end.187

if.then.186:                                      ; preds = %do.end.183
  br label %while.cond

if.end.187:                                       ; preds = %do.end.183
  %99 = load i64, i64* %ignore_case.addr, align 8
  %call188 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp189 = icmp eq i64 %99, %call188
  br i1 %cmp189, label %if.end.204, label %if.then.191

if.then.191:                                      ; preds = %if.end.187
  %100 = load i32, i32* %c1, align 4
  %conv192 = sext i32 %100 to i64
  %shl193 = shl i64 %conv192, 2
  %add194 = add i64 %shl193, 2
  %call195 = call i64 @Fupcase(i64 %add194)
  %shr196 = ashr i64 %call195, 2
  %conv197 = trunc i64 %shr196 to i32
  store i32 %conv197, i32* %c1, align 4
  %101 = load i32, i32* %c2, align 4
  %conv198 = sext i32 %101 to i64
  %shl199 = shl i64 %conv198, 2
  %add200 = add i64 %shl199, 2
  %call201 = call i64 @Fupcase(i64 %add200)
  %shr202 = ashr i64 %call201, 2
  %conv203 = trunc i64 %shr202 to i32
  store i32 %conv203, i32* %c2, align 4
  br label %if.end.204

if.end.204:                                       ; preds = %if.then.191, %if.end.187
  %102 = load i32, i32* %c1, align 4
  %103 = load i32, i32* %c2, align 4
  %cmp205 = icmp eq i32 %102, %103
  br i1 %cmp205, label %if.then.207, label %if.end.208

if.then.207:                                      ; preds = %if.end.204
  br label %while.cond

if.end.208:                                       ; preds = %if.end.204
  %104 = load i32, i32* %c1, align 4
  %105 = load i32, i32* %c2, align 4
  %cmp209 = icmp slt i32 %104, %105
  br i1 %cmp209, label %if.then.211, label %if.else.215

if.then.211:                                      ; preds = %if.end.208
  %106 = load i64, i64* %i1, align 8
  %sub = sub nsw i64 0, %106
  %107 = load i64, i64* %from1, align 8
  %add212 = add nsw i64 %sub, %107
  %shl213 = shl i64 %add212, 2
  %add214 = add i64 %shl213, 2
  store i64 %add214, i64* %retval
  br label %return

if.else.215:                                      ; preds = %if.end.208
  %108 = load i64, i64* %i1, align 8
  %109 = load i64, i64* %from1, align 8
  %sub216 = sub nsw i64 %108, %109
  %shl217 = shl i64 %sub216, 2
  %add218 = add i64 %shl217, 2
  store i64 %add218, i64* %retval
  br label %return

while.end:                                        ; preds = %land.end
  %110 = load i64, i64* %i1, align 8
  %111 = load i64, i64* %to1, align 8
  %cmp219 = icmp slt i64 %110, %111
  br i1 %cmp219, label %if.then.221, label %if.end.226

if.then.221:                                      ; preds = %while.end
  %112 = load i64, i64* %i1, align 8
  %113 = load i64, i64* %from1, align 8
  %sub222 = sub nsw i64 %112, %113
  %add223 = add nsw i64 %sub222, 1
  %shl224 = shl i64 %add223, 2
  %add225 = add i64 %shl224, 2
  store i64 %add225, i64* %retval
  br label %return

if.end.226:                                       ; preds = %while.end
  %114 = load i64, i64* %i2, align 8
  %115 = load i64, i64* %to2, align 8
  %cmp227 = icmp slt i64 %114, %115
  br i1 %cmp227, label %if.then.229, label %if.end.235

if.then.229:                                      ; preds = %if.end.226
  %116 = load i64, i64* %i1, align 8
  %sub230 = sub nsw i64 0, %116
  %117 = load i64, i64* %from1, align 8
  %add231 = add nsw i64 %sub230, %117
  %sub232 = sub nsw i64 %add231, 1
  %shl233 = shl i64 %sub232, 2
  %add234 = add i64 %shl233, 2
  store i64 %add234, i64* %retval
  br label %return

if.end.235:                                       ; preds = %if.end.226
  %call236 = call i64 @builtin_lisp_symbol(i32 901)
  store i64 %call236, i64* %retval
  br label %return

return:                                           ; preds = %if.end.235, %if.then.229, %if.then.221, %if.else.215, %if.then.211
  %118 = load i64, i64* %retval
  ret i64 %118
}

; Function Attrs: nounwind uwtable
define void @validate_subarray(i64 %array, i64 %from, i64 %to, i64 %size, i64* %ifrom, i64* %ito) #1 {
entry:
  %array.addr = alloca i64, align 8
  %from.addr = alloca i64, align 8
  %to.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %ifrom.addr = alloca i64*, align 8
  %ito.addr = alloca i64*, align 8
  %f = alloca i64, align 8
  %t = alloca i64, align 8
  store i64 %array, i64* %array.addr, align 8
  store i64 %from, i64* %from.addr, align 8
  store i64 %to, i64* %to.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store i64* %ifrom, i64** %ifrom.addr, align 8
  store i64* %ito, i64** %ito.addr, align 8
  %0 = load i64, i64* %from.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %and1 = and i32 %conv, -5
  %cmp = icmp eq i32 %and1, 2
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i64, i64* %from.addr, align 8
  %shr = ashr i64 %1, 2
  store i64 %shr, i64* %f, align 8
  %2 = load i64, i64* %f, align 8
  %cmp3 = icmp slt i64 %2, 0
  br i1 %cmp3, label %if.then.5, label %if.end

if.then.5:                                        ; preds = %if.then
  %3 = load i64, i64* %size.addr, align 8
  %4 = load i64, i64* %f, align 8
  %add = add nsw i64 %4, %3
  store i64 %add, i64* %f, align 8
  br label %if.end

if.end:                                           ; preds = %if.then.5, %if.then
  br label %if.end.12

if.else:                                          ; preds = %entry
  %5 = load i64, i64* %from.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp6 = icmp eq i64 %5, %call
  br i1 %cmp6, label %if.then.8, label %if.else.9

if.then.8:                                        ; preds = %if.else
  store i64 0, i64* %f, align 8
  br label %if.end.11

if.else.9:                                        ; preds = %if.else
  %call10 = call i64 @builtin_lisp_symbol(i32 559)
  %6 = load i64, i64* %from.addr, align 8
  %7 = call i64 @wrong_type_argument(i64 %call10, i64 %6) #8
  unreachable

if.end.11:                                        ; preds = %if.then.8
  br label %if.end.12

if.end.12:                                        ; preds = %if.end.11, %if.end
  %8 = load i64, i64* %to.addr, align 8
  %and13 = and i64 %8, 7
  %conv14 = trunc i64 %and13 to i32
  %and15 = and i32 %conv14, -5
  %cmp16 = icmp eq i32 %and15, 2
  br i1 %cmp16, label %if.then.18, label %if.else.25

if.then.18:                                       ; preds = %if.end.12
  %9 = load i64, i64* %to.addr, align 8
  %shr19 = ashr i64 %9, 2
  store i64 %shr19, i64* %t, align 8
  %10 = load i64, i64* %t, align 8
  %cmp20 = icmp slt i64 %10, 0
  br i1 %cmp20, label %if.then.22, label %if.end.24

if.then.22:                                       ; preds = %if.then.18
  %11 = load i64, i64* %size.addr, align 8
  %12 = load i64, i64* %t, align 8
  %add23 = add nsw i64 %12, %11
  store i64 %add23, i64* %t, align 8
  br label %if.end.24

if.end.24:                                        ; preds = %if.then.22, %if.then.18
  br label %if.end.33

if.else.25:                                       ; preds = %if.end.12
  %13 = load i64, i64* %to.addr, align 8
  %call26 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp27 = icmp eq i64 %13, %call26
  br i1 %cmp27, label %if.then.29, label %if.else.30

if.then.29:                                       ; preds = %if.else.25
  %14 = load i64, i64* %size.addr, align 8
  store i64 %14, i64* %t, align 8
  br label %if.end.32

if.else.30:                                       ; preds = %if.else.25
  %call31 = call i64 @builtin_lisp_symbol(i32 559)
  %15 = load i64, i64* %to.addr, align 8
  %16 = call i64 @wrong_type_argument(i64 %call31, i64 %15) #8
  unreachable

if.end.32:                                        ; preds = %if.then.29
  br label %if.end.33

if.end.33:                                        ; preds = %if.end.32, %if.end.24
  %17 = load i64, i64* %f, align 8
  %cmp34 = icmp sle i64 0, %17
  br i1 %cmp34, label %land.lhs.true, label %if.then.41

land.lhs.true:                                    ; preds = %if.end.33
  %18 = load i64, i64* %f, align 8
  %19 = load i64, i64* %t, align 8
  %cmp36 = icmp sle i64 %18, %19
  br i1 %cmp36, label %land.lhs.true.38, label %if.then.41

land.lhs.true.38:                                 ; preds = %land.lhs.true
  %20 = load i64, i64* %t, align 8
  %21 = load i64, i64* %size.addr, align 8
  %cmp39 = icmp sle i64 %20, %21
  br i1 %cmp39, label %if.end.42, label %if.then.41

if.then.41:                                       ; preds = %land.lhs.true.38, %land.lhs.true, %if.end.33
  %22 = load i64, i64* %array.addr, align 8
  %23 = load i64, i64* %from.addr, align 8
  %24 = load i64, i64* %to.addr, align 8
  call void @args_out_of_range_3(i64 %22, i64 %23, i64 %24) #8
  unreachable

if.end.42:                                        ; preds = %land.lhs.true.38
  %25 = load i64, i64* %f, align 8
  %26 = load i64*, i64** %ifrom.addr, align 8
  store i64 %25, i64* %26, align 8
  %27 = load i64, i64* %t, align 8
  %28 = load i64*, i64** %ito.addr, align 8
  store i64 %27, i64* %28, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define i64 @string_char_to_byte(i64 %string, i64 %char_index) #1 {
entry:
  %retval = alloca i64, align 8
  %string.addr = alloca i64, align 8
  %char_index.addr = alloca i64, align 8
  %i_byte = alloca i64, align 8
  %best_below = alloca i64, align 8
  %best_below_byte = alloca i64, align 8
  %best_above = alloca i64, align 8
  %best_above_byte = alloca i64, align 8
  %p = alloca i8*, align 8
  %p34 = alloca i8*, align 8
  store i64 %string, i64* %string.addr, align 8
  store i64 %char_index, i64* %char_index.addr, align 8
  store i64 0, i64* %best_below_byte, align 8
  store i64 0, i64* %best_below, align 8
  %0 = load i64, i64* %string.addr, align 8
  %call = call i64 @SCHARS(i64 %0)
  store i64 %call, i64* %best_above, align 8
  %1 = load i64, i64* %string.addr, align 8
  %call1 = call i64 @SBYTES(i64 %1)
  store i64 %call1, i64* %best_above_byte, align 8
  %2 = load i64, i64* %best_above, align 8
  %3 = load i64, i64* %best_above_byte, align 8
  %cmp = icmp eq i64 %2, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load i64, i64* %char_index.addr, align 8
  store i64 %4, i64* %retval
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i64, i64* %string.addr, align 8
  %6 = load i64, i64* @string_char_byte_cache_string, align 8
  %cmp2 = icmp eq i64 %5, %6
  br i1 %cmp2, label %if.then.3, label %if.end.7

if.then.3:                                        ; preds = %if.end
  %7 = load i64, i64* @string_char_byte_cache_charpos, align 8
  %8 = load i64, i64* %char_index.addr, align 8
  %cmp4 = icmp slt i64 %7, %8
  br i1 %cmp4, label %if.then.5, label %if.else

if.then.5:                                        ; preds = %if.then.3
  %9 = load i64, i64* @string_char_byte_cache_charpos, align 8
  store i64 %9, i64* %best_below, align 8
  %10 = load i64, i64* @string_char_byte_cache_bytepos, align 8
  store i64 %10, i64* %best_below_byte, align 8
  br label %if.end.6

if.else:                                          ; preds = %if.then.3
  %11 = load i64, i64* @string_char_byte_cache_charpos, align 8
  store i64 %11, i64* %best_above, align 8
  %12 = load i64, i64* @string_char_byte_cache_bytepos, align 8
  store i64 %12, i64* %best_above_byte, align 8
  br label %if.end.6

if.end.6:                                         ; preds = %if.else, %if.then.5
  br label %if.end.7

if.end.7:                                         ; preds = %if.end.6, %if.end
  %13 = load i64, i64* %char_index.addr, align 8
  %14 = load i64, i64* %best_below, align 8
  %sub = sub nsw i64 %13, %14
  %15 = load i64, i64* %best_above, align 8
  %16 = load i64, i64* %char_index.addr, align 8
  %sub8 = sub nsw i64 %15, %16
  %cmp9 = icmp slt i64 %sub, %sub8
  br i1 %cmp9, label %if.then.10, label %if.else.33

if.then.10:                                       ; preds = %if.end.7
  %17 = load i64, i64* %string.addr, align 8
  %call11 = call i8* @SDATA(i64 %17)
  %18 = load i64, i64* %best_below_byte, align 8
  %add.ptr = getelementptr inbounds i8, i8* %call11, i64 %18
  store i8* %add.ptr, i8** %p, align 8
  br label %while.cond

while.cond:                                       ; preds = %cond.end.29, %if.then.10
  %19 = load i64, i64* %best_below, align 8
  %20 = load i64, i64* %char_index.addr, align 8
  %cmp12 = icmp slt i64 %19, %20
  br i1 %cmp12, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %21 = load i8*, i8** %p, align 8
  %22 = load i8, i8* %21, align 1
  %conv = zext i8 %22 to i32
  %and = and i32 %conv, 128
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %while.body
  br label %cond.end.29

cond.false:                                       ; preds = %while.body
  %23 = load i8*, i8** %p, align 8
  %24 = load i8, i8* %23, align 1
  %conv13 = zext i8 %24 to i32
  %and14 = and i32 %conv13, 32
  %tobool15 = icmp ne i32 %and14, 0
  br i1 %tobool15, label %cond.false.17, label %cond.true.16

cond.true.16:                                     ; preds = %cond.false
  br label %cond.end.27

cond.false.17:                                    ; preds = %cond.false
  %25 = load i8*, i8** %p, align 8
  %26 = load i8, i8* %25, align 1
  %conv18 = zext i8 %26 to i32
  %and19 = and i32 %conv18, 16
  %tobool20 = icmp ne i32 %and19, 0
  br i1 %tobool20, label %cond.false.22, label %cond.true.21

cond.true.21:                                     ; preds = %cond.false.17
  br label %cond.end

cond.false.22:                                    ; preds = %cond.false.17
  %27 = load i8*, i8** %p, align 8
  %28 = load i8, i8* %27, align 1
  %conv23 = zext i8 %28 to i32
  %and24 = and i32 %conv23, 8
  %tobool25 = icmp ne i32 %and24, 0
  %lnot = xor i1 %tobool25, true
  %cond = select i1 %lnot, i32 4, i32 5
  br label %cond.end

cond.end:                                         ; preds = %cond.false.22, %cond.true.21
  %cond26 = phi i32 [ 3, %cond.true.21 ], [ %cond, %cond.false.22 ]
  br label %cond.end.27

cond.end.27:                                      ; preds = %cond.end, %cond.true.16
  %cond28 = phi i32 [ 2, %cond.true.16 ], [ %cond26, %cond.end ]
  br label %cond.end.29

cond.end.29:                                      ; preds = %cond.end.27, %cond.true
  %cond30 = phi i32 [ 1, %cond.true ], [ %cond28, %cond.end.27 ]
  %29 = load i8*, i8** %p, align 8
  %idx.ext = sext i32 %cond30 to i64
  %add.ptr31 = getelementptr inbounds i8, i8* %29, i64 %idx.ext
  store i8* %add.ptr31, i8** %p, align 8
  %30 = load i64, i64* %best_below, align 8
  %inc = add nsw i64 %30, 1
  store i64 %inc, i64* %best_below, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %31 = load i8*, i8** %p, align 8
  %32 = load i64, i64* %string.addr, align 8
  %call32 = call i8* @SDATA(i64 %32)
  %sub.ptr.lhs.cast = ptrtoint i8* %31 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %call32 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, i64* %i_byte, align 8
  br label %if.end.55

if.else.33:                                       ; preds = %if.end.7
  %33 = load i64, i64* %string.addr, align 8
  %call35 = call i8* @SDATA(i64 %33)
  %34 = load i64, i64* %best_above_byte, align 8
  %add.ptr36 = getelementptr inbounds i8, i8* %call35, i64 %34
  store i8* %add.ptr36, i8** %p34, align 8
  br label %while.cond.37

while.cond.37:                                    ; preds = %while.end.49, %if.else.33
  %35 = load i64, i64* %best_above, align 8
  %36 = load i64, i64* %char_index.addr, align 8
  %cmp38 = icmp sgt i64 %35, %36
  br i1 %cmp38, label %while.body.40, label %while.end.50

while.body.40:                                    ; preds = %while.cond.37
  %37 = load i8*, i8** %p34, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %37, i32 -1
  store i8* %incdec.ptr, i8** %p34, align 8
  br label %while.cond.41

while.cond.41:                                    ; preds = %while.body.47, %while.body.40
  %38 = load i8*, i8** %p34, align 8
  %39 = load i8, i8* %38, align 1
  %conv42 = zext i8 %39 to i32
  %and43 = and i32 %conv42, 192
  %cmp44 = icmp ne i32 %and43, 128
  %lnot46 = xor i1 %cmp44, true
  br i1 %lnot46, label %while.body.47, label %while.end.49

while.body.47:                                    ; preds = %while.cond.41
  %40 = load i8*, i8** %p34, align 8
  %incdec.ptr48 = getelementptr inbounds i8, i8* %40, i32 -1
  store i8* %incdec.ptr48, i8** %p34, align 8
  br label %while.cond.41

while.end.49:                                     ; preds = %while.cond.41
  %41 = load i64, i64* %best_above, align 8
  %dec = add nsw i64 %41, -1
  store i64 %dec, i64* %best_above, align 8
  br label %while.cond.37

while.end.50:                                     ; preds = %while.cond.37
  %42 = load i8*, i8** %p34, align 8
  %43 = load i64, i64* %string.addr, align 8
  %call51 = call i8* @SDATA(i64 %43)
  %sub.ptr.lhs.cast52 = ptrtoint i8* %42 to i64
  %sub.ptr.rhs.cast53 = ptrtoint i8* %call51 to i64
  %sub.ptr.sub54 = sub i64 %sub.ptr.lhs.cast52, %sub.ptr.rhs.cast53
  store i64 %sub.ptr.sub54, i64* %i_byte, align 8
  br label %if.end.55

if.end.55:                                        ; preds = %while.end.50, %while.end
  %44 = load i64, i64* %i_byte, align 8
  store i64 %44, i64* @string_char_byte_cache_bytepos, align 8
  %45 = load i64, i64* %char_index.addr, align 8
  store i64 %45, i64* @string_char_byte_cache_charpos, align 8
  %46 = load i64, i64* %string.addr, align 8
  store i64 %46, i64* @string_char_byte_cache_string, align 8
  %47 = load i64, i64* %i_byte, align 8
  store i64 %47, i64* %retval
  br label %return

return:                                           ; preds = %if.end.55, %if.then
  %48 = load i64, i64* %retval
  ret i64 %48
}

declare zeroext i1 @STRING_MULTIBYTE(i64) #2

declare i32 @string_char(i8*, i8**, i32*) #2

declare zeroext i8 @SREF(i64, i64) #2

declare i64 @Fupcase(i64) #2

; Function Attrs: nounwind uwtable
define i64 @Fstring_lessp(i64 %string1, i64 %string2) #1 {
entry:
  %retval = alloca i64, align 8
  %string1.addr = alloca i64, align 8
  %string2.addr = alloca i64, align 8
  %end = alloca i64, align 8
  %i1 = alloca i64, align 8
  %i1_byte = alloca i64, align 8
  %i2 = alloca i64, align 8
  %i2_byte = alloca i64, align 8
  %c1 = alloca i32, align 4
  %c2 = alloca i32, align 4
  %chp = alloca i8*, align 8
  %chlen = alloca i32, align 4
  %chp77 = alloca i8*, align 8
  %chlen80 = alloca i32, align 4
  store i64 %string1, i64* %string1.addr, align 8
  store i64 %string2, i64* %string2.addr, align 8
  %0 = load i64, i64* %string1.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i64, i64* %string1.addr, align 8
  %call = call i64 @SYMBOL_NAME(i64 %1)
  store i64 %call, i64* %string1.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i64, i64* %string2.addr, align 8
  %and2 = and i64 %2, 7
  %conv3 = trunc i64 %and2 to i32
  %cmp4 = icmp eq i32 %conv3, 0
  br i1 %cmp4, label %if.then.6, label %if.end.8

if.then.6:                                        ; preds = %if.end
  %3 = load i64, i64* %string2.addr, align 8
  %call7 = call i64 @SYMBOL_NAME(i64 %3)
  store i64 %call7, i64* %string2.addr, align 8
  br label %if.end.8

if.end.8:                                         ; preds = %if.then.6, %if.end
  %4 = load i64, i64* %string1.addr, align 8
  call void @CHECK_STRING(i64 %4)
  %5 = load i64, i64* %string2.addr, align 8
  call void @CHECK_STRING(i64 %5)
  store i64 0, i64* %i2_byte, align 8
  store i64 0, i64* %i2, align 8
  store i64 0, i64* %i1_byte, align 8
  store i64 0, i64* %i1, align 8
  %6 = load i64, i64* %string1.addr, align 8
  %call9 = call i64 @SCHARS(i64 %6)
  store i64 %call9, i64* %end, align 8
  %7 = load i64, i64* %end, align 8
  %8 = load i64, i64* %string2.addr, align 8
  %call10 = call i64 @SCHARS(i64 %8)
  %cmp11 = icmp sgt i64 %7, %call10
  br i1 %cmp11, label %if.then.13, label %if.end.15

if.then.13:                                       ; preds = %if.end.8
  %9 = load i64, i64* %string2.addr, align 8
  %call14 = call i64 @SCHARS(i64 %9)
  store i64 %call14, i64* %end, align 8
  br label %if.end.15

if.end.15:                                        ; preds = %if.then.13, %if.end.8
  br label %while.cond

while.cond:                                       ; preds = %if.end.154, %if.end.15
  %10 = load i64, i64* %i1, align 8
  %11 = load i64, i64* %end, align 8
  %cmp16 = icmp slt i64 %10, %11
  br i1 %cmp16, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  br label %do.body

do.body:                                          ; preds = %while.body
  %12 = load i64, i64* %i1, align 8
  %inc = add nsw i64 %12, 1
  store i64 %inc, i64* %i1, align 8
  %13 = load i64, i64* %string1.addr, align 8
  %call18 = call zeroext i1 @STRING_MULTIBYTE(i64 %13)
  br i1 %call18, label %if.then.19, label %if.else

if.then.19:                                       ; preds = %do.body
  %14 = load i64, i64* %i1_byte, align 8
  %15 = load i64, i64* %string1.addr, align 8
  %call20 = call i8* @SDATA(i64 %15)
  %arrayidx = getelementptr inbounds i8, i8* %call20, i64 %14
  store i8* %arrayidx, i8** %chp, align 8
  %16 = load i8*, i8** %chp, align 8
  %arrayidx21 = getelementptr inbounds i8, i8* %16, i64 0
  %17 = load i8, i8* %arrayidx21, align 1
  %conv22 = zext i8 %17 to i32
  %and23 = and i32 %conv22, 128
  %tobool = icmp ne i32 %and23, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then.19
  store i32 1, i32* %chlen, align 4
  %18 = load i8*, i8** %chp, align 8
  %arrayidx24 = getelementptr inbounds i8, i8* %18, i64 0
  %19 = load i8, i8* %arrayidx24, align 1
  %conv25 = zext i8 %19 to i32
  br label %cond.end.65

cond.false:                                       ; preds = %if.then.19
  %20 = load i8*, i8** %chp, align 8
  %arrayidx26 = getelementptr inbounds i8, i8* %20, i64 0
  %21 = load i8, i8* %arrayidx26, align 1
  %conv27 = zext i8 %21 to i32
  %and28 = and i32 %conv27, 32
  %tobool29 = icmp ne i32 %and28, 0
  br i1 %tobool29, label %cond.false.41, label %cond.true.30

cond.true.30:                                     ; preds = %cond.false
  store i32 2, i32* %chlen, align 4
  %22 = load i8*, i8** %chp, align 8
  %arrayidx31 = getelementptr inbounds i8, i8* %22, i64 0
  %23 = load i8, i8* %arrayidx31, align 1
  %conv32 = zext i8 %23 to i32
  %and33 = and i32 %conv32, 31
  %shl = shl i32 %and33, 6
  %24 = load i8*, i8** %chp, align 8
  %arrayidx34 = getelementptr inbounds i8, i8* %24, i64 1
  %25 = load i8, i8* %arrayidx34, align 1
  %conv35 = zext i8 %25 to i32
  %and36 = and i32 %conv35, 63
  %or = or i32 %shl, %and36
  %26 = load i8*, i8** %chp, align 8
  %arrayidx37 = getelementptr inbounds i8, i8* %26, i64 0
  %27 = load i8, i8* %arrayidx37, align 1
  %conv38 = zext i8 %27 to i32
  %cmp39 = icmp slt i32 %conv38, 194
  %cond = select i1 %cmp39, i32 4194176, i32 0
  %add = add nsw i32 %or, %cond
  br label %cond.end.63

cond.false.41:                                    ; preds = %cond.false
  %28 = load i8*, i8** %chp, align 8
  %arrayidx42 = getelementptr inbounds i8, i8* %28, i64 0
  %29 = load i8, i8* %arrayidx42, align 1
  %conv43 = zext i8 %29 to i32
  %and44 = and i32 %conv43, 16
  %tobool45 = icmp ne i32 %and44, 0
  br i1 %tobool45, label %cond.false.60, label %cond.true.46

cond.true.46:                                     ; preds = %cond.false.41
  store i32 3, i32* %chlen, align 4
  %30 = load i8*, i8** %chp, align 8
  %arrayidx47 = getelementptr inbounds i8, i8* %30, i64 0
  %31 = load i8, i8* %arrayidx47, align 1
  %conv48 = zext i8 %31 to i32
  %and49 = and i32 %conv48, 15
  %shl50 = shl i32 %and49, 12
  %32 = load i8*, i8** %chp, align 8
  %arrayidx51 = getelementptr inbounds i8, i8* %32, i64 1
  %33 = load i8, i8* %arrayidx51, align 1
  %conv52 = zext i8 %33 to i32
  %and53 = and i32 %conv52, 63
  %shl54 = shl i32 %and53, 6
  %or55 = or i32 %shl50, %shl54
  %34 = load i8*, i8** %chp, align 8
  %arrayidx56 = getelementptr inbounds i8, i8* %34, i64 2
  %35 = load i8, i8* %arrayidx56, align 1
  %conv57 = zext i8 %35 to i32
  %and58 = and i32 %conv57, 63
  %or59 = or i32 %or55, %and58
  br label %cond.end

cond.false.60:                                    ; preds = %cond.false.41
  %36 = load i8*, i8** %chp, align 8
  %call61 = call i32 @string_char(i8* %36, i8** null, i32* %chlen)
  br label %cond.end

cond.end:                                         ; preds = %cond.false.60, %cond.true.46
  %cond62 = phi i32 [ %or59, %cond.true.46 ], [ %call61, %cond.false.60 ]
  br label %cond.end.63

cond.end.63:                                      ; preds = %cond.end, %cond.true.30
  %cond64 = phi i32 [ %add, %cond.true.30 ], [ %cond62, %cond.end ]
  br label %cond.end.65

cond.end.65:                                      ; preds = %cond.end.63, %cond.true
  %cond66 = phi i32 [ %conv25, %cond.true ], [ %cond64, %cond.end.63 ]
  store i32 %cond66, i32* %c1, align 4
  %37 = load i32, i32* %chlen, align 4
  %conv67 = sext i32 %37 to i64
  %38 = load i64, i64* %i1_byte, align 8
  %add68 = add nsw i64 %38, %conv67
  store i64 %add68, i64* %i1_byte, align 8
  br label %if.end.72

if.else:                                          ; preds = %do.body
  %39 = load i64, i64* %string1.addr, align 8
  %40 = load i64, i64* %i1_byte, align 8
  %call69 = call zeroext i8 @SREF(i64 %39, i64 %40)
  %conv70 = zext i8 %call69 to i32
  store i32 %conv70, i32* %c1, align 4
  %41 = load i64, i64* %i1_byte, align 8
  %inc71 = add nsw i64 %41, 1
  store i64 %inc71, i64* %i1_byte, align 8
  br label %if.end.72

if.end.72:                                        ; preds = %if.else, %cond.end.65
  br label %do.end

do.end:                                           ; preds = %if.end.72
  br label %do.body.73

do.body.73:                                       ; preds = %do.end
  %42 = load i64, i64* %i2, align 8
  %inc74 = add nsw i64 %42, 1
  store i64 %inc74, i64* %i2, align 8
  %43 = load i64, i64* %string2.addr, align 8
  %call75 = call zeroext i1 @STRING_MULTIBYTE(i64 %43)
  br i1 %call75, label %if.then.76, label %if.else.137

if.then.76:                                       ; preds = %do.body.73
  %44 = load i64, i64* %i2_byte, align 8
  %45 = load i64, i64* %string2.addr, align 8
  %call78 = call i8* @SDATA(i64 %45)
  %arrayidx79 = getelementptr inbounds i8, i8* %call78, i64 %44
  store i8* %arrayidx79, i8** %chp77, align 8
  %46 = load i8*, i8** %chp77, align 8
  %arrayidx81 = getelementptr inbounds i8, i8* %46, i64 0
  %47 = load i8, i8* %arrayidx81, align 1
  %conv82 = zext i8 %47 to i32
  %and83 = and i32 %conv82, 128
  %tobool84 = icmp ne i32 %and83, 0
  br i1 %tobool84, label %cond.false.88, label %cond.true.85

cond.true.85:                                     ; preds = %if.then.76
  store i32 1, i32* %chlen80, align 4
  %48 = load i8*, i8** %chp77, align 8
  %arrayidx86 = getelementptr inbounds i8, i8* %48, i64 0
  %49 = load i8, i8* %arrayidx86, align 1
  %conv87 = zext i8 %49 to i32
  br label %cond.end.133

cond.false.88:                                    ; preds = %if.then.76
  %50 = load i8*, i8** %chp77, align 8
  %arrayidx89 = getelementptr inbounds i8, i8* %50, i64 0
  %51 = load i8, i8* %arrayidx89, align 1
  %conv90 = zext i8 %51 to i32
  %and91 = and i32 %conv90, 32
  %tobool92 = icmp ne i32 %and91, 0
  br i1 %tobool92, label %cond.false.108, label %cond.true.93

cond.true.93:                                     ; preds = %cond.false.88
  store i32 2, i32* %chlen80, align 4
  %52 = load i8*, i8** %chp77, align 8
  %arrayidx94 = getelementptr inbounds i8, i8* %52, i64 0
  %53 = load i8, i8* %arrayidx94, align 1
  %conv95 = zext i8 %53 to i32
  %and96 = and i32 %conv95, 31
  %shl97 = shl i32 %and96, 6
  %54 = load i8*, i8** %chp77, align 8
  %arrayidx98 = getelementptr inbounds i8, i8* %54, i64 1
  %55 = load i8, i8* %arrayidx98, align 1
  %conv99 = zext i8 %55 to i32
  %and100 = and i32 %conv99, 63
  %or101 = or i32 %shl97, %and100
  %56 = load i8*, i8** %chp77, align 8
  %arrayidx102 = getelementptr inbounds i8, i8* %56, i64 0
  %57 = load i8, i8* %arrayidx102, align 1
  %conv103 = zext i8 %57 to i32
  %cmp104 = icmp slt i32 %conv103, 194
  %cond106 = select i1 %cmp104, i32 4194176, i32 0
  %add107 = add nsw i32 %or101, %cond106
  br label %cond.end.131

cond.false.108:                                   ; preds = %cond.false.88
  %58 = load i8*, i8** %chp77, align 8
  %arrayidx109 = getelementptr inbounds i8, i8* %58, i64 0
  %59 = load i8, i8* %arrayidx109, align 1
  %conv110 = zext i8 %59 to i32
  %and111 = and i32 %conv110, 16
  %tobool112 = icmp ne i32 %and111, 0
  br i1 %tobool112, label %cond.false.127, label %cond.true.113

cond.true.113:                                    ; preds = %cond.false.108
  store i32 3, i32* %chlen80, align 4
  %60 = load i8*, i8** %chp77, align 8
  %arrayidx114 = getelementptr inbounds i8, i8* %60, i64 0
  %61 = load i8, i8* %arrayidx114, align 1
  %conv115 = zext i8 %61 to i32
  %and116 = and i32 %conv115, 15
  %shl117 = shl i32 %and116, 12
  %62 = load i8*, i8** %chp77, align 8
  %arrayidx118 = getelementptr inbounds i8, i8* %62, i64 1
  %63 = load i8, i8* %arrayidx118, align 1
  %conv119 = zext i8 %63 to i32
  %and120 = and i32 %conv119, 63
  %shl121 = shl i32 %and120, 6
  %or122 = or i32 %shl117, %shl121
  %64 = load i8*, i8** %chp77, align 8
  %arrayidx123 = getelementptr inbounds i8, i8* %64, i64 2
  %65 = load i8, i8* %arrayidx123, align 1
  %conv124 = zext i8 %65 to i32
  %and125 = and i32 %conv124, 63
  %or126 = or i32 %or122, %and125
  br label %cond.end.129

cond.false.127:                                   ; preds = %cond.false.108
  %66 = load i8*, i8** %chp77, align 8
  %call128 = call i32 @string_char(i8* %66, i8** null, i32* %chlen80)
  br label %cond.end.129

cond.end.129:                                     ; preds = %cond.false.127, %cond.true.113
  %cond130 = phi i32 [ %or126, %cond.true.113 ], [ %call128, %cond.false.127 ]
  br label %cond.end.131

cond.end.131:                                     ; preds = %cond.end.129, %cond.true.93
  %cond132 = phi i32 [ %add107, %cond.true.93 ], [ %cond130, %cond.end.129 ]
  br label %cond.end.133

cond.end.133:                                     ; preds = %cond.end.131, %cond.true.85
  %cond134 = phi i32 [ %conv87, %cond.true.85 ], [ %cond132, %cond.end.131 ]
  store i32 %cond134, i32* %c2, align 4
  %67 = load i32, i32* %chlen80, align 4
  %conv135 = sext i32 %67 to i64
  %68 = load i64, i64* %i2_byte, align 8
  %add136 = add nsw i64 %68, %conv135
  store i64 %add136, i64* %i2_byte, align 8
  br label %if.end.141

if.else.137:                                      ; preds = %do.body.73
  %69 = load i64, i64* %string2.addr, align 8
  %70 = load i64, i64* %i2_byte, align 8
  %call138 = call zeroext i8 @SREF(i64 %69, i64 %70)
  %conv139 = zext i8 %call138 to i32
  store i32 %conv139, i32* %c2, align 4
  %71 = load i64, i64* %i2_byte, align 8
  %inc140 = add nsw i64 %71, 1
  store i64 %inc140, i64* %i2_byte, align 8
  br label %if.end.141

if.end.141:                                       ; preds = %if.else.137, %cond.end.133
  br label %do.end.142

do.end.142:                                       ; preds = %if.end.141
  %72 = load i32, i32* %c1, align 4
  %73 = load i32, i32* %c2, align 4
  %cmp143 = icmp ne i32 %72, %73
  br i1 %cmp143, label %if.then.145, label %if.end.154

if.then.145:                                      ; preds = %do.end.142
  %74 = load i32, i32* %c1, align 4
  %75 = load i32, i32* %c2, align 4
  %cmp146 = icmp slt i32 %74, %75
  br i1 %cmp146, label %cond.true.148, label %cond.false.150

cond.true.148:                                    ; preds = %if.then.145
  %call149 = call i64 @builtin_lisp_symbol(i32 901)
  br label %cond.end.152

cond.false.150:                                   ; preds = %if.then.145
  %call151 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end.152

cond.end.152:                                     ; preds = %cond.false.150, %cond.true.148
  %cond153 = phi i64 [ %call149, %cond.true.148 ], [ %call151, %cond.false.150 ]
  store i64 %cond153, i64* %retval
  br label %return

if.end.154:                                       ; preds = %do.end.142
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %76 = load i64, i64* %i1, align 8
  %77 = load i64, i64* %string2.addr, align 8
  %call155 = call i64 @SCHARS(i64 %77)
  %cmp156 = icmp slt i64 %76, %call155
  br i1 %cmp156, label %cond.true.158, label %cond.false.160

cond.true.158:                                    ; preds = %while.end
  %call159 = call i64 @builtin_lisp_symbol(i32 901)
  br label %cond.end.162

cond.false.160:                                   ; preds = %while.end
  %call161 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end.162

cond.end.162:                                     ; preds = %cond.false.160, %cond.true.158
  %cond163 = phi i64 [ %call159, %cond.true.158 ], [ %call161, %cond.false.160 ]
  store i64 %cond163, i64* %retval
  br label %return

return:                                           ; preds = %cond.end.162, %cond.end.152
  %78 = load i64, i64* %retval
  ret i64 %78
}

; Function Attrs: nounwind uwtable
define i64 @Fstring_collate_lessp(i64 %s1, i64 %s2, i64 %locale, i64 %ignore_case) #1 {
entry:
  %s1.addr = alloca i64, align 8
  %s2.addr = alloca i64, align 8
  %locale.addr = alloca i64, align 8
  %ignore_case.addr = alloca i64, align 8
  store i64 %s1, i64* %s1.addr, align 8
  store i64 %s2, i64* %s2.addr, align 8
  store i64 %locale, i64* %locale.addr, align 8
  store i64 %ignore_case, i64* %ignore_case.addr, align 8
  %0 = load i64, i64* %s1.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i64, i64* %s1.addr, align 8
  %call = call i64 @SYMBOL_NAME(i64 %1)
  store i64 %call, i64* %s1.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i64, i64* %s2.addr, align 8
  %and2 = and i64 %2, 7
  %conv3 = trunc i64 %and2 to i32
  %cmp4 = icmp eq i32 %conv3, 0
  br i1 %cmp4, label %if.then.6, label %if.end.8

if.then.6:                                        ; preds = %if.end
  %3 = load i64, i64* %s2.addr, align 8
  %call7 = call i64 @SYMBOL_NAME(i64 %3)
  store i64 %call7, i64* %s2.addr, align 8
  br label %if.end.8

if.end.8:                                         ; preds = %if.then.6, %if.end
  %4 = load i64, i64* %s1.addr, align 8
  call void @CHECK_STRING(i64 %4)
  %5 = load i64, i64* %s2.addr, align 8
  call void @CHECK_STRING(i64 %5)
  %6 = load i64, i64* %locale.addr, align 8
  %call9 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp10 = icmp eq i64 %6, %call9
  br i1 %cmp10, label %if.end.13, label %if.then.12

if.then.12:                                       ; preds = %if.end.8
  %7 = load i64, i64* %locale.addr, align 8
  call void @CHECK_STRING(i64 %7)
  br label %if.end.13

if.end.13:                                        ; preds = %if.then.12, %if.end.8
  %8 = load i64, i64* %s1.addr, align 8
  %9 = load i64, i64* %s2.addr, align 8
  %10 = load i64, i64* %locale.addr, align 8
  %11 = load i64, i64* %ignore_case.addr, align 8
  %call14 = call i32 @str_collate(i64 %8, i64 %9, i64 %10, i64 %11)
  %cmp15 = icmp slt i32 %call14, 0
  br i1 %cmp15, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.13
  %call17 = call i64 @builtin_lisp_symbol(i32 901)
  br label %cond.end

cond.false:                                       ; preds = %if.end.13
  %call18 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call17, %cond.true ], [ %call18, %cond.false ]
  ret i64 %cond
}

declare i32 @str_collate(i64, i64, i64, i64) #2

; Function Attrs: nounwind uwtable
define i64 @Fstring_collate_equalp(i64 %s1, i64 %s2, i64 %locale, i64 %ignore_case) #1 {
entry:
  %s1.addr = alloca i64, align 8
  %s2.addr = alloca i64, align 8
  %locale.addr = alloca i64, align 8
  %ignore_case.addr = alloca i64, align 8
  store i64 %s1, i64* %s1.addr, align 8
  store i64 %s2, i64* %s2.addr, align 8
  store i64 %locale, i64* %locale.addr, align 8
  store i64 %ignore_case, i64* %ignore_case.addr, align 8
  %0 = load i64, i64* %s1.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i64, i64* %s1.addr, align 8
  %call = call i64 @SYMBOL_NAME(i64 %1)
  store i64 %call, i64* %s1.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i64, i64* %s2.addr, align 8
  %and2 = and i64 %2, 7
  %conv3 = trunc i64 %and2 to i32
  %cmp4 = icmp eq i32 %conv3, 0
  br i1 %cmp4, label %if.then.6, label %if.end.8

if.then.6:                                        ; preds = %if.end
  %3 = load i64, i64* %s2.addr, align 8
  %call7 = call i64 @SYMBOL_NAME(i64 %3)
  store i64 %call7, i64* %s2.addr, align 8
  br label %if.end.8

if.end.8:                                         ; preds = %if.then.6, %if.end
  %4 = load i64, i64* %s1.addr, align 8
  call void @CHECK_STRING(i64 %4)
  %5 = load i64, i64* %s2.addr, align 8
  call void @CHECK_STRING(i64 %5)
  %6 = load i64, i64* %locale.addr, align 8
  %call9 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp10 = icmp eq i64 %6, %call9
  br i1 %cmp10, label %if.end.13, label %if.then.12

if.then.12:                                       ; preds = %if.end.8
  %7 = load i64, i64* %locale.addr, align 8
  call void @CHECK_STRING(i64 %7)
  br label %if.end.13

if.end.13:                                        ; preds = %if.then.12, %if.end.8
  %8 = load i64, i64* %s1.addr, align 8
  %9 = load i64, i64* %s2.addr, align 8
  %10 = load i64, i64* %locale.addr, align 8
  %11 = load i64, i64* %ignore_case.addr, align 8
  %call14 = call i32 @str_collate(i64 %8, i64 %9, i64 %10, i64 %11)
  %cmp15 = icmp eq i32 %call14, 0
  br i1 %cmp15, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.13
  %call17 = call i64 @builtin_lisp_symbol(i32 901)
  br label %cond.end

cond.false:                                       ; preds = %if.end.13
  %call18 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call17, %cond.true ], [ %call18, %cond.false ]
  ret i64 %cond
}

; Function Attrs: nounwind uwtable
define i64 @concat2(i64 %s1, i64 %s2) #1 {
entry:
  %s1.addr = alloca i64, align 8
  %s2.addr = alloca i64, align 8
  %.compoundliteral = alloca [2 x i64], align 8
  store i64 %s1, i64* %s1.addr, align 8
  store i64 %s2, i64* %s2.addr, align 8
  %arrayinit.begin = getelementptr inbounds [2 x i64], [2 x i64]* %.compoundliteral, i64 0, i64 0
  %0 = load i64, i64* %s1.addr, align 8
  store i64 %0, i64* %arrayinit.begin
  %arrayinit.element = getelementptr inbounds i64, i64* %arrayinit.begin, i64 1
  %1 = load i64, i64* %s2.addr, align 8
  store i64 %1, i64* %arrayinit.element
  %arraydecay = getelementptr inbounds [2 x i64], [2 x i64]* %.compoundliteral, i32 0, i32 0
  %call = call i64 @concat(i64 2, i64* %arraydecay, i32 4, i1 zeroext false)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define internal i64 @concat(i64 %nargs, i64* %args, i32 %target_type, i1 zeroext %last_special) #1 {
entry:
  %retval = alloca i64, align 8
  %nargs.addr = alloca i64, align 8
  %args.addr = alloca i64*, align 8
  %target_type.addr = alloca i32, align 4
  %last_special.addr = alloca i8, align 1
  %val = alloca i64, align 8
  %tail = alloca i64, align 8
  %this = alloca i64, align 8
  %toindex = alloca i64, align 8
  %toindex_byte = alloca i64, align 8
  %result_len = alloca i64, align 8
  %result_len_byte = alloca i64, align 8
  %argnum = alloca i64, align 8
  %last_tail = alloca i64, align 8
  %prev = alloca i64, align 8
  %some_multibyte = alloca i8, align 1
  %textprops = alloca %struct.textprop_rec*, align 8
  %num_textprops = alloca i64, align 8
  %sa_avail = alloca i64, align 8
  %sa_count = alloca i64, align 8
  %sa_must_free = alloca i8, align 1
  %len = alloca i64, align 8
  %i = alloca i64, align 8
  %ch = alloca i64, align 8
  %c = alloca i32, align 4
  %this_len_byte = alloca i64, align 8
  %thislen = alloca i64, align 8
  %thisleni = alloca i64, align 8
  %thisindex = alloca i64, align 8
  %thisindex_byte = alloca i64, align 8
  %thislen_byte = alloca i64, align 8
  %elt = alloca i64, align 8
  %c361 = alloca i32, align 4
  %fetch_ptr = alloca i8*, align 8
  %fetch_len = alloca i32, align 4
  %c469 = alloca i32, align 4
  %props = alloca i64, align 8
  %last_to_end = alloca i64, align 8
  store i64 %nargs, i64* %nargs.addr, align 8
  store i64* %args, i64** %args.addr, align 8
  store i32 %target_type, i32* %target_type.addr, align 4
  %frombool = zext i1 %last_special to i8
  store i8 %frombool, i8* %last_special.addr, align 1
  store i64 0, i64* %toindex_byte, align 8
  store %struct.textprop_rec* null, %struct.textprop_rec** %textprops, align 8
  store i64 0, i64* %num_textprops, align 8
  store i64 16384, i64* %sa_avail, align 8
  %call = call i64 @SPECPDL_INDEX()
  store i64 %call, i64* %sa_count, align 8
  store i8 0, i8* %sa_must_free, align 1
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call1, i64* %tail, align 8
  %0 = load i8, i8* %last_special.addr, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, i64* %nargs.addr, align 8
  %cmp = icmp sgt i64 %1, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  %2 = load i64, i64* %nargs.addr, align 8
  %dec = add nsw i64 %2, -1
  store i64 %dec, i64* %nargs.addr, align 8
  %3 = load i64, i64* %nargs.addr, align 8
  %4 = load i64*, i64** %args.addr, align 8
  %arrayidx = getelementptr inbounds i64, i64* %4, i64 %3
  %5 = load i64, i64* %arrayidx, align 8
  store i64 %5, i64* %last_tail, align 8
  br label %if.end

if.else:                                          ; preds = %land.lhs.true, %entry
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call2, i64* %last_tail, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  store i64 0, i64* %argnum, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %6 = load i64, i64* %argnum, align 8
  %7 = load i64, i64* %nargs.addr, align 8
  %cmp3 = icmp slt i64 %6, %7
  br i1 %cmp3, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load i64, i64* %argnum, align 8
  %9 = load i64*, i64** %args.addr, align 8
  %arrayidx4 = getelementptr inbounds i64, i64* %9, i64 %8
  %10 = load i64, i64* %arrayidx4, align 8
  store i64 %10, i64* %this, align 8
  %11 = load i64, i64* %this, align 8
  %and = and i64 %11, 7
  %conv = trunc i64 %and to i32
  %cmp5 = icmp eq i32 %conv, 3
  br i1 %cmp5, label %if.end.24, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %12 = load i64, i64* %this, align 8
  %call7 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp8 = icmp eq i64 %12, %call7
  br i1 %cmp8, label %if.end.24, label %lor.lhs.false.10

lor.lhs.false.10:                                 ; preds = %lor.lhs.false
  %13 = load i64, i64* %this, align 8
  %call11 = call zeroext i1 @VECTORP(i64 %13)
  br i1 %call11, label %if.end.24, label %lor.lhs.false.13

lor.lhs.false.13:                                 ; preds = %lor.lhs.false.10
  %14 = load i64, i64* %this, align 8
  %call14 = call zeroext i1 @STRINGP(i64 %14)
  br i1 %call14, label %if.end.24, label %lor.lhs.false.16

lor.lhs.false.16:                                 ; preds = %lor.lhs.false.13
  %15 = load i64, i64* %this, align 8
  %call17 = call zeroext i1 @COMPILEDP(i64 %15)
  br i1 %call17, label %if.end.24, label %lor.lhs.false.19

lor.lhs.false.19:                                 ; preds = %lor.lhs.false.16
  %16 = load i64, i64* %this, align 8
  %call20 = call zeroext i1 @BOOL_VECTOR_P(i64 %16)
  br i1 %call20, label %if.end.24, label %if.then.22

if.then.22:                                       ; preds = %lor.lhs.false.19
  %call23 = call i64 @builtin_lisp_symbol(i32 844)
  %17 = load i64, i64* %this, align 8
  %18 = call i64 @wrong_type_argument(i64 %call23, i64 %17) #8
  unreachable

if.end.24:                                        ; preds = %lor.lhs.false.19, %lor.lhs.false.16, %lor.lhs.false.13, %lor.lhs.false.10, %lor.lhs.false, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end.24
  %19 = load i64, i64* %argnum, align 8
  %inc = add nsw i64 %19, 1
  store i64 %inc, i64* %argnum, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i64 0, i64* %result_len_byte, align 8
  store i64 0, i64* %result_len, align 8
  store i8 0, i8* %some_multibyte, align 1
  store i64 0, i64* %argnum, align 8
  br label %for.cond.25

for.cond.25:                                      ; preds = %for.inc.215, %for.end
  %20 = load i64, i64* %argnum, align 8
  %21 = load i64, i64* %nargs.addr, align 8
  %cmp26 = icmp slt i64 %20, %21
  br i1 %cmp26, label %for.body.28, label %for.end.217

for.body.28:                                      ; preds = %for.cond.25
  %22 = load i64, i64* %argnum, align 8
  %23 = load i64*, i64** %args.addr, align 8
  %arrayidx29 = getelementptr inbounds i64, i64* %23, i64 %22
  %24 = load i64, i64* %arrayidx29, align 8
  store i64 %24, i64* %this, align 8
  %25 = load i64, i64* %this, align 8
  %call30 = call i64 @Flength(i64 %25)
  %shr = ashr i64 %call30, 2
  store i64 %shr, i64* %len, align 8
  %26 = load i32, i32* %target_type.addr, align 4
  %cmp31 = icmp eq i32 %26, 4
  br i1 %cmp31, label %if.then.33, label %if.end.209

if.then.33:                                       ; preds = %for.body.28
  %27 = load i64, i64* %this, align 8
  %call34 = call zeroext i1 @VECTORP(i64 %27)
  br i1 %call34, label %if.then.39, label %lor.lhs.false.36

lor.lhs.false.36:                                 ; preds = %if.then.33
  %28 = load i64, i64* %this, align 8
  %call37 = call zeroext i1 @COMPILEDP(i64 %28)
  br i1 %call37, label %if.then.39, label %if.else.102

if.then.39:                                       ; preds = %lor.lhs.false.36, %if.then.33
  store i64 0, i64* %i, align 8
  br label %for.cond.40

for.cond.40:                                      ; preds = %for.inc.99, %if.then.39
  %29 = load i64, i64* %i, align 8
  %30 = load i64, i64* %len, align 8
  %cmp41 = icmp slt i64 %29, %30
  br i1 %cmp41, label %for.body.43, label %for.end.101

for.body.43:                                      ; preds = %for.cond.40
  %31 = load i64, i64* %this, align 8
  %32 = load i64, i64* %i, align 8
  %call44 = call i64 @AREF(i64 %31, i64 %32)
  store i64 %call44, i64* %ch, align 8
  %33 = load i64, i64* %ch, align 8
  %call45 = call zeroext i1 @NATNUMP(i64 %33)
  br i1 %call45, label %land.lhs.true.47, label %cond.false

land.lhs.true.47:                                 ; preds = %for.body.43
  %34 = load i64, i64* %ch, align 8
  %shr48 = ashr i64 %34, 2
  %cmp49 = icmp sle i64 %shr48, 4194303
  br i1 %cmp49, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true.47
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true.47, %for.body.43
  %call51 = call i64 @builtin_lisp_symbol(i32 260)
  %35 = load i64, i64* %ch, align 8
  %36 = call i64 @wrong_type_argument(i64 %call51, i64 %35) #8
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %37, %cond.true
  %38 = load i64, i64* %ch, align 8
  %shr52 = ashr i64 %38, 2
  %conv53 = trunc i64 %shr52 to i32
  store i32 %conv53, i32* %c, align 4
  %39 = load i32, i32* %c, align 4
  %cmp54 = icmp sle i32 %39, 127
  br i1 %cmp54, label %cond.true.56, label %cond.false.57

cond.true.56:                                     ; preds = %cond.end
  br label %cond.end.78

cond.false.57:                                    ; preds = %cond.end
  %40 = load i32, i32* %c, align 4
  %cmp58 = icmp sle i32 %40, 2047
  br i1 %cmp58, label %cond.true.60, label %cond.false.61

cond.true.60:                                     ; preds = %cond.false.57
  br label %cond.end.76

cond.false.61:                                    ; preds = %cond.false.57
  %41 = load i32, i32* %c, align 4
  %cmp62 = icmp sle i32 %41, 65535
  br i1 %cmp62, label %cond.true.64, label %cond.false.65

cond.true.64:                                     ; preds = %cond.false.61
  br label %cond.end.74

cond.false.65:                                    ; preds = %cond.false.61
  %42 = load i32, i32* %c, align 4
  %cmp66 = icmp sle i32 %42, 2097151
  br i1 %cmp66, label %cond.true.68, label %cond.false.69

cond.true.68:                                     ; preds = %cond.false.65
  br label %cond.end.72

cond.false.69:                                    ; preds = %cond.false.65
  %43 = load i32, i32* %c, align 4
  %cmp70 = icmp sle i32 %43, 4194175
  %cond = select i1 %cmp70, i32 5, i32 2
  br label %cond.end.72

cond.end.72:                                      ; preds = %cond.false.69, %cond.true.68
  %cond73 = phi i32 [ 4, %cond.true.68 ], [ %cond, %cond.false.69 ]
  br label %cond.end.74

cond.end.74:                                      ; preds = %cond.end.72, %cond.true.64
  %cond75 = phi i32 [ 3, %cond.true.64 ], [ %cond73, %cond.end.72 ]
  br label %cond.end.76

cond.end.76:                                      ; preds = %cond.end.74, %cond.true.60
  %cond77 = phi i32 [ 2, %cond.true.60 ], [ %cond75, %cond.end.74 ]
  br label %cond.end.78

cond.end.78:                                      ; preds = %cond.end.76, %cond.true.56
  %cond79 = phi i32 [ 1, %cond.true.56 ], [ %cond77, %cond.end.76 ]
  %conv80 = sext i32 %cond79 to i64
  store i64 %conv80, i64* %this_len_byte, align 8
  %44 = load i64, i64* %result_len_byte, align 8
  %sub = sub nsw i64 2305843009213693951, %44
  %45 = load i64, i64* %this_len_byte, align 8
  %cmp81 = icmp slt i64 %sub, %45
  br i1 %cmp81, label %if.then.83, label %if.end.84

if.then.83:                                       ; preds = %cond.end.78
  call void @string_overflow() #8
  unreachable

if.end.84:                                        ; preds = %cond.end.78
  %46 = load i64, i64* %this_len_byte, align 8
  %47 = load i64, i64* %result_len_byte, align 8
  %add = add nsw i64 %47, %46
  store i64 %add, i64* %result_len_byte, align 8
  br i1 true, label %cond.true.85, label %cond.false.89

cond.true.85:                                     ; preds = %if.end.84
  %48 = load i32, i32* %c, align 4
  %add86 = add i32 %48, 0
  %cmp87 = icmp ult i32 %add86, 128
  br i1 %cmp87, label %if.end.98, label %land.lhs.true.94

cond.false.89:                                    ; preds = %if.end.84
  %49 = load i32, i32* %c, align 4
  %conv90 = sext i32 %49 to i64
  %add91 = add i64 %conv90, 0
  %cmp92 = icmp ult i64 %add91, 128
  br i1 %cmp92, label %if.end.98, label %land.lhs.true.94

land.lhs.true.94:                                 ; preds = %cond.false.89, %cond.true.85
  %50 = load i32, i32* %c, align 4
  %cmp95 = icmp sgt i32 %50, 4194175
  br i1 %cmp95, label %if.end.98, label %if.then.97

if.then.97:                                       ; preds = %land.lhs.true.94
  store i8 1, i8* %some_multibyte, align 1
  br label %if.end.98

if.end.98:                                        ; preds = %if.then.97, %land.lhs.true.94, %cond.false.89, %cond.true.85
  br label %for.inc.99

for.inc.99:                                       ; preds = %if.end.98
  %51 = load i64, i64* %i, align 8
  %inc100 = add nsw i64 %51, 1
  store i64 %inc100, i64* %i, align 8
  br label %for.cond.40

for.end.101:                                      ; preds = %for.cond.40
  br label %if.end.208

if.else.102:                                      ; preds = %lor.lhs.false.36
  %52 = load i64, i64* %this, align 8
  %call103 = call zeroext i1 @BOOL_VECTOR_P(i64 %52)
  br i1 %call103, label %land.lhs.true.105, label %if.else.112

land.lhs.true.105:                                ; preds = %if.else.102
  %53 = load i64, i64* %this, align 8
  %call106 = call i64 @bool_vector_size(i64 %53)
  %cmp107 = icmp sgt i64 %call106, 0
  br i1 %cmp107, label %if.then.109, label %if.else.112

if.then.109:                                      ; preds = %land.lhs.true.105
  %call110 = call i64 @builtin_lisp_symbol(i32 559)
  %54 = load i64, i64* %this, align 8
  %call111 = call i64 @Faref(i64 %54, i64 2)
  %55 = call i64 @wrong_type_argument(i64 %call110, i64 %call111) #8
  unreachable

if.else.112:                                      ; preds = %land.lhs.true.105, %if.else.102
  %56 = load i64, i64* %this, align 8
  %and113 = and i64 %56, 7
  %conv114 = trunc i64 %and113 to i32
  %cmp115 = icmp eq i32 %conv114, 3
  br i1 %cmp115, label %if.then.117, label %if.else.188

if.then.117:                                      ; preds = %if.else.112
  br label %for.cond.118

for.cond.118:                                     ; preds = %for.inc.185, %if.then.117
  %57 = load i64, i64* %this, align 8
  %and119 = and i64 %57, 7
  %conv120 = trunc i64 %and119 to i32
  %cmp121 = icmp eq i32 %conv120, 3
  br i1 %cmp121, label %for.body.123, label %for.end.187

for.body.123:                                     ; preds = %for.cond.118
  %58 = load i64, i64* %this, align 8
  %sub124 = sub nsw i64 %58, 3
  %59 = inttoptr i64 %sub124 to i8*
  %60 = bitcast i8* %59 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %60, i32 0, i32 0
  %61 = load i64, i64* %car, align 8
  store i64 %61, i64* %ch, align 8
  %62 = load i64, i64* %ch, align 8
  %call125 = call zeroext i1 @NATNUMP(i64 %62)
  br i1 %call125, label %land.lhs.true.127, label %cond.false.132

land.lhs.true.127:                                ; preds = %for.body.123
  %63 = load i64, i64* %ch, align 8
  %shr128 = ashr i64 %63, 2
  %cmp129 = icmp sle i64 %shr128, 4194303
  br i1 %cmp129, label %cond.true.131, label %cond.false.132

cond.true.131:                                    ; preds = %land.lhs.true.127
  br label %cond.end.134

cond.false.132:                                   ; preds = %land.lhs.true.127, %for.body.123
  %call133 = call i64 @builtin_lisp_symbol(i32 260)
  %64 = load i64, i64* %ch, align 8
  %65 = call i64 @wrong_type_argument(i64 %call133, i64 %64) #8
  unreachable
                                                  ; No predecessors!
  br label %cond.end.134

cond.end.134:                                     ; preds = %66, %cond.true.131
  %67 = load i64, i64* %ch, align 8
  %shr135 = ashr i64 %67, 2
  %conv136 = trunc i64 %shr135 to i32
  store i32 %conv136, i32* %c, align 4
  %68 = load i32, i32* %c, align 4
  %cmp137 = icmp sle i32 %68, 127
  br i1 %cmp137, label %cond.true.139, label %cond.false.140

cond.true.139:                                    ; preds = %cond.end.134
  br label %cond.end.162

cond.false.140:                                   ; preds = %cond.end.134
  %69 = load i32, i32* %c, align 4
  %cmp141 = icmp sle i32 %69, 2047
  br i1 %cmp141, label %cond.true.143, label %cond.false.144

cond.true.143:                                    ; preds = %cond.false.140
  br label %cond.end.160

cond.false.144:                                   ; preds = %cond.false.140
  %70 = load i32, i32* %c, align 4
  %cmp145 = icmp sle i32 %70, 65535
  br i1 %cmp145, label %cond.true.147, label %cond.false.148

cond.true.147:                                    ; preds = %cond.false.144
  br label %cond.end.158

cond.false.148:                                   ; preds = %cond.false.144
  %71 = load i32, i32* %c, align 4
  %cmp149 = icmp sle i32 %71, 2097151
  br i1 %cmp149, label %cond.true.151, label %cond.false.152

cond.true.151:                                    ; preds = %cond.false.148
  br label %cond.end.156

cond.false.152:                                   ; preds = %cond.false.148
  %72 = load i32, i32* %c, align 4
  %cmp153 = icmp sle i32 %72, 4194175
  %cond155 = select i1 %cmp153, i32 5, i32 2
  br label %cond.end.156

cond.end.156:                                     ; preds = %cond.false.152, %cond.true.151
  %cond157 = phi i32 [ 4, %cond.true.151 ], [ %cond155, %cond.false.152 ]
  br label %cond.end.158

cond.end.158:                                     ; preds = %cond.end.156, %cond.true.147
  %cond159 = phi i32 [ 3, %cond.true.147 ], [ %cond157, %cond.end.156 ]
  br label %cond.end.160

cond.end.160:                                     ; preds = %cond.end.158, %cond.true.143
  %cond161 = phi i32 [ 2, %cond.true.143 ], [ %cond159, %cond.end.158 ]
  br label %cond.end.162

cond.end.162:                                     ; preds = %cond.end.160, %cond.true.139
  %cond163 = phi i32 [ 1, %cond.true.139 ], [ %cond161, %cond.end.160 ]
  %conv164 = sext i32 %cond163 to i64
  store i64 %conv164, i64* %this_len_byte, align 8
  %73 = load i64, i64* %result_len_byte, align 8
  %sub165 = sub nsw i64 2305843009213693951, %73
  %74 = load i64, i64* %this_len_byte, align 8
  %cmp166 = icmp slt i64 %sub165, %74
  br i1 %cmp166, label %if.then.168, label %if.end.169

if.then.168:                                      ; preds = %cond.end.162
  call void @string_overflow() #8
  unreachable

if.end.169:                                       ; preds = %cond.end.162
  %75 = load i64, i64* %this_len_byte, align 8
  %76 = load i64, i64* %result_len_byte, align 8
  %add170 = add nsw i64 %76, %75
  store i64 %add170, i64* %result_len_byte, align 8
  br i1 true, label %cond.true.171, label %cond.false.175

cond.true.171:                                    ; preds = %if.end.169
  %77 = load i32, i32* %c, align 4
  %add172 = add i32 %77, 0
  %cmp173 = icmp ult i32 %add172, 128
  br i1 %cmp173, label %if.end.184, label %land.lhs.true.180

cond.false.175:                                   ; preds = %if.end.169
  %78 = load i32, i32* %c, align 4
  %conv176 = sext i32 %78 to i64
  %add177 = add i64 %conv176, 0
  %cmp178 = icmp ult i64 %add177, 128
  br i1 %cmp178, label %if.end.184, label %land.lhs.true.180

land.lhs.true.180:                                ; preds = %cond.false.175, %cond.true.171
  %79 = load i32, i32* %c, align 4
  %cmp181 = icmp sgt i32 %79, 4194175
  br i1 %cmp181, label %if.end.184, label %if.then.183

if.then.183:                                      ; preds = %land.lhs.true.180
  store i8 1, i8* %some_multibyte, align 1
  br label %if.end.184

if.end.184:                                       ; preds = %if.then.183, %land.lhs.true.180, %cond.false.175, %cond.true.171
  br label %for.inc.185

for.inc.185:                                      ; preds = %if.end.184
  %80 = load i64, i64* %this, align 8
  %sub186 = sub nsw i64 %80, 3
  %81 = inttoptr i64 %sub186 to i8*
  %82 = bitcast i8* %81 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %82, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %83 = load i64, i64* %cdr, align 8
  store i64 %83, i64* %this, align 8
  br label %for.cond.118

for.end.187:                                      ; preds = %for.cond.118
  br label %if.end.206

if.else.188:                                      ; preds = %if.else.112
  %84 = load i64, i64* %this, align 8
  %call189 = call zeroext i1 @STRINGP(i64 %84)
  br i1 %call189, label %if.then.190, label %if.end.205

if.then.190:                                      ; preds = %if.else.188
  %85 = load i64, i64* %this, align 8
  %call191 = call zeroext i1 @STRING_MULTIBYTE(i64 %85)
  br i1 %call191, label %if.then.192, label %if.else.194

if.then.192:                                      ; preds = %if.then.190
  store i8 1, i8* %some_multibyte, align 1
  %86 = load i64, i64* %this, align 8
  %call193 = call i64 @SBYTES(i64 %86)
  store i64 %call193, i64* %this_len_byte, align 8
  br label %if.end.198

if.else.194:                                      ; preds = %if.then.190
  %87 = load i64, i64* %this, align 8
  %call195 = call i8* @SDATA(i64 %87)
  %88 = load i64, i64* %this, align 8
  %call196 = call i64 @SCHARS(i64 %88)
  %call197 = call i64 @count_size_as_multibyte(i8* %call195, i64 %call196)
  store i64 %call197, i64* %this_len_byte, align 8
  br label %if.end.198

if.end.198:                                       ; preds = %if.else.194, %if.then.192
  %89 = load i64, i64* %result_len_byte, align 8
  %sub199 = sub nsw i64 2305843009213693951, %89
  %90 = load i64, i64* %this_len_byte, align 8
  %cmp200 = icmp slt i64 %sub199, %90
  br i1 %cmp200, label %if.then.202, label %if.end.203

if.then.202:                                      ; preds = %if.end.198
  call void @string_overflow() #8
  unreachable

if.end.203:                                       ; preds = %if.end.198
  %91 = load i64, i64* %this_len_byte, align 8
  %92 = load i64, i64* %result_len_byte, align 8
  %add204 = add nsw i64 %92, %91
  store i64 %add204, i64* %result_len_byte, align 8
  br label %if.end.205

if.end.205:                                       ; preds = %if.end.203, %if.else.188
  br label %if.end.206

if.end.206:                                       ; preds = %if.end.205, %for.end.187
  br label %if.end.207

if.end.207:                                       ; preds = %if.end.206
  br label %if.end.208

if.end.208:                                       ; preds = %if.end.207, %for.end.101
  br label %if.end.209

if.end.209:                                       ; preds = %if.end.208, %for.body.28
  %93 = load i64, i64* %len, align 8
  %94 = load i64, i64* %result_len, align 8
  %add210 = add nsw i64 %94, %93
  store i64 %add210, i64* %result_len, align 8
  %95 = load i64, i64* %result_len, align 8
  %cmp211 = icmp slt i64 2305843009213693951, %95
  br i1 %cmp211, label %if.then.213, label %if.end.214

if.then.213:                                      ; preds = %if.end.209
  call void @memory_full(i64 -1) #8
  unreachable

if.end.214:                                       ; preds = %if.end.209
  br label %for.inc.215

for.inc.215:                                      ; preds = %if.end.214
  %96 = load i64, i64* %argnum, align 8
  %inc216 = add nsw i64 %96, 1
  store i64 %inc216, i64* %argnum, align 8
  br label %for.cond.25

for.end.217:                                      ; preds = %for.cond.25
  %97 = load i8, i8* %some_multibyte, align 1
  %tobool218 = trunc i8 %97 to i1
  br i1 %tobool218, label %if.end.220, label %if.then.219

if.then.219:                                      ; preds = %for.end.217
  %98 = load i64, i64* %result_len, align 8
  store i64 %98, i64* %result_len_byte, align 8
  br label %if.end.220

if.end.220:                                       ; preds = %if.then.219, %for.end.217
  %99 = load i32, i32* %target_type.addr, align 4
  %cmp221 = icmp eq i32 %99, 3
  br i1 %cmp221, label %if.then.223, label %if.else.227

if.then.223:                                      ; preds = %if.end.220
  %100 = load i64, i64* %result_len, align 8
  %shl = shl i64 %100, 2
  %add224 = add i64 %shl, 2
  %call225 = call i64 @builtin_lisp_symbol(i32 0)
  %call226 = call i64 @Fmake_list(i64 %add224, i64 %call225)
  store i64 %call226, i64* %val, align 8
  br label %if.end.243

if.else.227:                                      ; preds = %if.end.220
  %101 = load i32, i32* %target_type.addr, align 4
  %cmp228 = icmp eq i32 %101, 5
  br i1 %cmp228, label %if.then.230, label %if.else.235

if.then.230:                                      ; preds = %if.else.227
  %102 = load i64, i64* %result_len, align 8
  %shl231 = shl i64 %102, 2
  %add232 = add i64 %shl231, 2
  %call233 = call i64 @builtin_lisp_symbol(i32 0)
  %call234 = call i64 @Fmake_vector(i64 %add232, i64 %call233)
  store i64 %call234, i64* %val, align 8
  br label %if.end.242

if.else.235:                                      ; preds = %if.else.227
  %103 = load i8, i8* %some_multibyte, align 1
  %tobool236 = trunc i8 %103 to i1
  br i1 %tobool236, label %if.then.237, label %if.else.239

if.then.237:                                      ; preds = %if.else.235
  %104 = load i64, i64* %result_len, align 8
  %105 = load i64, i64* %result_len_byte, align 8
  %call238 = call i64 @make_uninit_multibyte_string(i64 %104, i64 %105)
  store i64 %call238, i64* %val, align 8
  br label %if.end.241

if.else.239:                                      ; preds = %if.else.235
  %106 = load i64, i64* %result_len, align 8
  %call240 = call i64 @make_uninit_string(i64 %106)
  store i64 %call240, i64* %val, align 8
  br label %if.end.241

if.end.241:                                       ; preds = %if.else.239, %if.then.237
  br label %if.end.242

if.end.242:                                       ; preds = %if.end.241, %if.then.230
  br label %if.end.243

if.end.243:                                       ; preds = %if.end.242, %if.then.223
  %107 = load i32, i32* %target_type.addr, align 4
  %cmp244 = icmp eq i32 %107, 3
  br i1 %cmp244, label %land.lhs.true.246, label %if.end.251

land.lhs.true.246:                                ; preds = %if.end.243
  %108 = load i64, i64* %val, align 8
  %call247 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp248 = icmp eq i64 %108, %call247
  br i1 %cmp248, label %if.then.250, label %if.end.251

if.then.250:                                      ; preds = %land.lhs.true.246
  %109 = load i64, i64* %last_tail, align 8
  store i64 %109, i64* %retval
  br label %return

if.end.251:                                       ; preds = %land.lhs.true.246, %if.end.243
  %110 = load i64, i64* %val, align 8
  %and252 = and i64 %110, 7
  %conv253 = trunc i64 %and252 to i32
  %cmp254 = icmp eq i32 %conv253, 3
  br i1 %cmp254, label %if.then.256, label %if.else.257

if.then.256:                                      ; preds = %if.end.251
  %111 = load i64, i64* %val, align 8
  store i64 %111, i64* %tail, align 8
  store i64 -1, i64* %toindex, align 8
  br label %if.end.258

if.else.257:                                      ; preds = %if.end.251
  store i64 0, i64* %toindex, align 8
  store i64 0, i64* %toindex_byte, align 8
  br label %if.end.258

if.end.258:                                       ; preds = %if.else.257, %if.then.256
  %call259 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call259, i64* %prev, align 8
  %112 = load i64, i64* %val, align 8
  %call260 = call zeroext i1 @STRINGP(i64 %112)
  br i1 %call260, label %if.then.261, label %if.end.271

if.then.261:                                      ; preds = %if.end.258
  br label %do.body

do.body:                                          ; preds = %if.then.261
  %113 = load i64, i64* %nargs.addr, align 8
  %114 = load i64, i64* %sa_avail, align 8
  %div = udiv i64 %114, 24
  %div262 = udiv i64 %div, 1
  %cmp263 = icmp ule i64 %113, %div262
  br i1 %cmp263, label %if.then.265, label %if.else.268

if.then.265:                                      ; preds = %do.body
  %115 = load i64, i64* %nargs.addr, align 8
  %mul = mul i64 24, %115
  %116 = load i64, i64* %sa_avail, align 8
  %sub266 = sub i64 %116, %mul
  store i64 %sub266, i64* %sa_avail, align 8
  %117 = load i64, i64* %nargs.addr, align 8
  %mul267 = mul i64 24, %117
  %118 = alloca i8, i64 %mul267
  %119 = bitcast i8* %118 to %struct.textprop_rec*
  store %struct.textprop_rec* %119, %struct.textprop_rec** %textprops, align 8
  br label %if.end.270

if.else.268:                                      ; preds = %do.body
  %120 = load i64, i64* %nargs.addr, align 8
  %call269 = call noalias i8* @xnmalloc(i64 %120, i64 24)
  %121 = bitcast i8* %call269 to %struct.textprop_rec*
  store %struct.textprop_rec* %121, %struct.textprop_rec** %textprops, align 8
  store i8 1, i8* %sa_must_free, align 1
  %122 = load %struct.textprop_rec*, %struct.textprop_rec** %textprops, align 8
  %123 = bitcast %struct.textprop_rec* %122 to i8*
  call void @record_unwind_protect_ptr(void (i8*)* @xfree, i8* %123)
  br label %if.end.270

if.end.270:                                       ; preds = %if.else.268, %if.then.265
  br label %do.end

do.end:                                           ; preds = %if.end.270
  br label %if.end.271

if.end.271:                                       ; preds = %do.end, %if.end.258
  store i64 0, i64* %argnum, align 8
  br label %for.cond.272

for.cond.272:                                     ; preds = %for.inc.572, %if.end.271
  %124 = load i64, i64* %argnum, align 8
  %125 = load i64, i64* %nargs.addr, align 8
  %cmp273 = icmp slt i64 %124, %125
  br i1 %cmp273, label %for.body.275, label %for.end.574

for.body.275:                                     ; preds = %for.cond.272
  store i64 0, i64* %thisleni, align 8
  store i64 0, i64* %thisindex, align 8
  store i64 0, i64* %thisindex_byte, align 8
  %126 = load i64, i64* %argnum, align 8
  %127 = load i64*, i64** %args.addr, align 8
  %arrayidx276 = getelementptr inbounds i64, i64* %127, i64 %126
  %128 = load i64, i64* %arrayidx276, align 8
  store i64 %128, i64* %this, align 8
  %129 = load i64, i64* %this, align 8
  %and277 = and i64 %129, 7
  %conv278 = trunc i64 %and277 to i32
  %cmp279 = icmp eq i32 %conv278, 3
  br i1 %cmp279, label %if.end.284, label %if.then.281

if.then.281:                                      ; preds = %for.body.275
  %130 = load i64, i64* %this, align 8
  %call282 = call i64 @Flength(i64 %130)
  store i64 %call282, i64* %thislen, align 8
  %131 = load i64, i64* %thislen, align 8
  %shr283 = ashr i64 %131, 2
  store i64 %shr283, i64* %thisleni, align 8
  br label %if.end.284

if.end.284:                                       ; preds = %if.then.281, %for.body.275
  %132 = load i64, i64* %this, align 8
  %call285 = call zeroext i1 @STRINGP(i64 %132)
  br i1 %call285, label %land.lhs.true.287, label %if.else.313

land.lhs.true.287:                                ; preds = %if.end.284
  %133 = load i64, i64* %val, align 8
  %call288 = call zeroext i1 @STRINGP(i64 %133)
  br i1 %call288, label %land.lhs.true.290, label %if.else.313

land.lhs.true.290:                                ; preds = %land.lhs.true.287
  %134 = load i64, i64* %this, align 8
  %call291 = call zeroext i1 @STRING_MULTIBYTE(i64 %134)
  %conv292 = zext i1 %call291 to i32
  %135 = load i8, i8* %some_multibyte, align 1
  %tobool293 = trunc i8 %135 to i1
  %conv294 = zext i1 %tobool293 to i32
  %cmp295 = icmp eq i32 %conv292, %conv294
  br i1 %cmp295, label %if.then.297, label %if.else.313

if.then.297:                                      ; preds = %land.lhs.true.290
  %136 = load i64, i64* %this, align 8
  %call298 = call i64 @SBYTES(i64 %136)
  store i64 %call298, i64* %thislen_byte, align 8
  %137 = load i64, i64* %val, align 8
  %call299 = call i8* @SDATA(i64 %137)
  %138 = load i64, i64* %toindex_byte, align 8
  %add.ptr = getelementptr inbounds i8, i8* %call299, i64 %138
  %139 = load i64, i64* %this, align 8
  %call300 = call i8* @SDATA(i64 %139)
  %140 = load i64, i64* %this, align 8
  %call301 = call i64 @SBYTES(i64 %140)
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %add.ptr, i8* %call300, i64 %call301, i32 1, i1 false)
  %141 = load i64, i64* %this, align 8
  %call302 = call %struct.interval* @string_intervals(i64 %141)
  %tobool303 = icmp ne %struct.interval* %call302, null
  br i1 %tobool303, label %if.then.304, label %if.end.310

if.then.304:                                      ; preds = %if.then.297
  %142 = load i64, i64* %argnum, align 8
  %143 = load i64, i64* %num_textprops, align 8
  %144 = load %struct.textprop_rec*, %struct.textprop_rec** %textprops, align 8
  %arrayidx305 = getelementptr inbounds %struct.textprop_rec, %struct.textprop_rec* %144, i64 %143
  %argnum306 = getelementptr inbounds %struct.textprop_rec, %struct.textprop_rec* %arrayidx305, i32 0, i32 0
  store i64 %142, i64* %argnum306, align 8
  %145 = load i64, i64* %num_textprops, align 8
  %146 = load %struct.textprop_rec*, %struct.textprop_rec** %textprops, align 8
  %arrayidx307 = getelementptr inbounds %struct.textprop_rec, %struct.textprop_rec* %146, i64 %145
  %from = getelementptr inbounds %struct.textprop_rec, %struct.textprop_rec* %arrayidx307, i32 0, i32 1
  store i64 0, i64* %from, align 8
  %147 = load i64, i64* %toindex, align 8
  %148 = load i64, i64* %num_textprops, align 8
  %inc308 = add nsw i64 %148, 1
  store i64 %inc308, i64* %num_textprops, align 8
  %149 = load %struct.textprop_rec*, %struct.textprop_rec** %textprops, align 8
  %arrayidx309 = getelementptr inbounds %struct.textprop_rec, %struct.textprop_rec* %149, i64 %148
  %to = getelementptr inbounds %struct.textprop_rec, %struct.textprop_rec* %arrayidx309, i32 0, i32 2
  store i64 %147, i64* %to, align 8
  br label %if.end.310

if.end.310:                                       ; preds = %if.then.304, %if.then.297
  %150 = load i64, i64* %thislen_byte, align 8
  %151 = load i64, i64* %toindex_byte, align 8
  %add311 = add nsw i64 %151, %150
  store i64 %add311, i64* %toindex_byte, align 8
  %152 = load i64, i64* %thisleni, align 8
  %153 = load i64, i64* %toindex, align 8
  %add312 = add nsw i64 %153, %152
  store i64 %add312, i64* %toindex, align 8
  br label %if.end.571

if.else.313:                                      ; preds = %land.lhs.true.290, %land.lhs.true.287, %if.end.284
  %154 = load i64, i64* %this, align 8
  %call314 = call zeroext i1 @STRINGP(i64 %154)
  br i1 %call314, label %land.lhs.true.316, label %if.else.338

land.lhs.true.316:                                ; preds = %if.else.313
  %155 = load i64, i64* %val, align 8
  %call317 = call zeroext i1 @STRINGP(i64 %155)
  br i1 %call317, label %if.then.319, label %if.else.338

if.then.319:                                      ; preds = %land.lhs.true.316
  %156 = load i64, i64* %this, align 8
  %call320 = call %struct.interval* @string_intervals(i64 %156)
  %tobool321 = icmp ne %struct.interval* %call320, null
  br i1 %tobool321, label %if.then.322, label %if.end.330

if.then.322:                                      ; preds = %if.then.319
  %157 = load i64, i64* %argnum, align 8
  %158 = load i64, i64* %num_textprops, align 8
  %159 = load %struct.textprop_rec*, %struct.textprop_rec** %textprops, align 8
  %arrayidx323 = getelementptr inbounds %struct.textprop_rec, %struct.textprop_rec* %159, i64 %158
  %argnum324 = getelementptr inbounds %struct.textprop_rec, %struct.textprop_rec* %arrayidx323, i32 0, i32 0
  store i64 %157, i64* %argnum324, align 8
  %160 = load i64, i64* %num_textprops, align 8
  %161 = load %struct.textprop_rec*, %struct.textprop_rec** %textprops, align 8
  %arrayidx325 = getelementptr inbounds %struct.textprop_rec, %struct.textprop_rec* %161, i64 %160
  %from326 = getelementptr inbounds %struct.textprop_rec, %struct.textprop_rec* %arrayidx325, i32 0, i32 1
  store i64 0, i64* %from326, align 8
  %162 = load i64, i64* %toindex, align 8
  %163 = load i64, i64* %num_textprops, align 8
  %inc327 = add nsw i64 %163, 1
  store i64 %inc327, i64* %num_textprops, align 8
  %164 = load %struct.textprop_rec*, %struct.textprop_rec** %textprops, align 8
  %arrayidx328 = getelementptr inbounds %struct.textprop_rec, %struct.textprop_rec* %164, i64 %163
  %to329 = getelementptr inbounds %struct.textprop_rec, %struct.textprop_rec* %arrayidx328, i32 0, i32 2
  store i64 %162, i64* %to329, align 8
  br label %if.end.330

if.end.330:                                       ; preds = %if.then.322, %if.then.319
  %165 = load i64, i64* %this, align 8
  %call331 = call i8* @SDATA(i64 %165)
  %166 = load i64, i64* %val, align 8
  %call332 = call i8* @SDATA(i64 %166)
  %167 = load i64, i64* %toindex_byte, align 8
  %add.ptr333 = getelementptr inbounds i8, i8* %call332, i64 %167
  %168 = load i64, i64* %this, align 8
  %call334 = call i64 @SCHARS(i64 %168)
  %call335 = call i64 @copy_text(i8* %call331, i8* %add.ptr333, i64 %call334, i1 zeroext false, i1 zeroext true)
  %169 = load i64, i64* %toindex_byte, align 8
  %add336 = add nsw i64 %169, %call335
  store i64 %add336, i64* %toindex_byte, align 8
  %170 = load i64, i64* %thisleni, align 8
  %171 = load i64, i64* %toindex, align 8
  %add337 = add nsw i64 %171, %170
  store i64 %add337, i64* %toindex, align 8
  br label %if.end.570

if.else.338:                                      ; preds = %land.lhs.true.316, %if.else.313
  br label %while.body

while.body:                                       ; preds = %if.else.338, %if.end.569
  %172 = load i64, i64* %this, align 8
  %call339 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp340 = icmp eq i64 %172, %call339
  br i1 %cmp340, label %if.then.342, label %if.end.343

if.then.342:                                      ; preds = %while.body
  br label %while.end

if.end.343:                                       ; preds = %while.body
  %173 = load i64, i64* %this, align 8
  %and344 = and i64 %173, 7
  %conv345 = trunc i64 %and344 to i32
  %cmp346 = icmp eq i32 %conv345, 3
  br i1 %cmp346, label %if.then.348, label %if.else.354

if.then.348:                                      ; preds = %if.end.343
  %174 = load i64, i64* %this, align 8
  %sub349 = sub nsw i64 %174, 3
  %175 = inttoptr i64 %sub349 to i8*
  %176 = bitcast i8* %175 to %struct.Lisp_Cons*
  %car350 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %176, i32 0, i32 0
  %177 = load i64, i64* %car350, align 8
  store i64 %177, i64* %elt, align 8
  %178 = load i64, i64* %this, align 8
  %sub351 = sub nsw i64 %178, 3
  %179 = inttoptr i64 %sub351 to i8*
  %180 = bitcast i8* %179 to %struct.Lisp_Cons*
  %u352 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %180, i32 0, i32 1
  %cdr353 = bitcast %union.anon* %u352 to i64*
  %181 = load i64, i64* %cdr353, align 8
  store i64 %181, i64* %this, align 8
  br label %if.end.457

if.else.354:                                      ; preds = %if.end.343
  %182 = load i64, i64* %thisindex, align 8
  %183 = load i64, i64* %thisleni, align 8
  %cmp355 = icmp sge i64 %182, %183
  br i1 %cmp355, label %if.then.357, label %if.else.358

if.then.357:                                      ; preds = %if.else.354
  br label %while.end

if.else.358:                                      ; preds = %if.else.354
  %184 = load i64, i64* %this, align 8
  %call359 = call zeroext i1 @STRINGP(i64 %184)
  br i1 %call359, label %if.then.360, label %if.else.446

if.then.360:                                      ; preds = %if.else.358
  %185 = load i64, i64* %this, align 8
  %call362 = call zeroext i1 @STRING_MULTIBYTE(i64 %185)
  br i1 %call362, label %if.then.363, label %if.else.424

if.then.363:                                      ; preds = %if.then.360
  br label %do.body.364

do.body.364:                                      ; preds = %if.then.363
  %186 = load i64, i64* %thisindex_byte, align 8
  %187 = load i64, i64* %this, align 8
  %call365 = call i8* @SDATA(i64 %187)
  %arrayidx366 = getelementptr inbounds i8, i8* %call365, i64 %186
  store i8* %arrayidx366, i8** %fetch_ptr, align 8
  %188 = load i8*, i8** %fetch_ptr, align 8
  %arrayidx367 = getelementptr inbounds i8, i8* %188, i64 0
  %189 = load i8, i8* %arrayidx367, align 1
  %conv368 = zext i8 %189 to i32
  %and369 = and i32 %conv368, 128
  %tobool370 = icmp ne i32 %and369, 0
  br i1 %tobool370, label %cond.false.374, label %cond.true.371

cond.true.371:                                    ; preds = %do.body.364
  store i32 1, i32* %fetch_len, align 4
  %190 = load i8*, i8** %fetch_ptr, align 8
  %arrayidx372 = getelementptr inbounds i8, i8* %190, i64 0
  %191 = load i8, i8* %arrayidx372, align 1
  %conv373 = zext i8 %191 to i32
  br label %cond.end.418

cond.false.374:                                   ; preds = %do.body.364
  %192 = load i8*, i8** %fetch_ptr, align 8
  %arrayidx375 = getelementptr inbounds i8, i8* %192, i64 0
  %193 = load i8, i8* %arrayidx375, align 1
  %conv376 = zext i8 %193 to i32
  %and377 = and i32 %conv376, 32
  %tobool378 = icmp ne i32 %and377, 0
  br i1 %tobool378, label %cond.false.393, label %cond.true.379

cond.true.379:                                    ; preds = %cond.false.374
  store i32 2, i32* %fetch_len, align 4
  %194 = load i8*, i8** %fetch_ptr, align 8
  %arrayidx380 = getelementptr inbounds i8, i8* %194, i64 0
  %195 = load i8, i8* %arrayidx380, align 1
  %conv381 = zext i8 %195 to i32
  %and382 = and i32 %conv381, 31
  %shl383 = shl i32 %and382, 6
  %196 = load i8*, i8** %fetch_ptr, align 8
  %arrayidx384 = getelementptr inbounds i8, i8* %196, i64 1
  %197 = load i8, i8* %arrayidx384, align 1
  %conv385 = zext i8 %197 to i32
  %and386 = and i32 %conv385, 63
  %or = or i32 %shl383, %and386
  %198 = load i8*, i8** %fetch_ptr, align 8
  %arrayidx387 = getelementptr inbounds i8, i8* %198, i64 0
  %199 = load i8, i8* %arrayidx387, align 1
  %conv388 = zext i8 %199 to i32
  %cmp389 = icmp slt i32 %conv388, 194
  %cond391 = select i1 %cmp389, i32 4194176, i32 0
  %add392 = add nsw i32 %or, %cond391
  br label %cond.end.416

cond.false.393:                                   ; preds = %cond.false.374
  %200 = load i8*, i8** %fetch_ptr, align 8
  %arrayidx394 = getelementptr inbounds i8, i8* %200, i64 0
  %201 = load i8, i8* %arrayidx394, align 1
  %conv395 = zext i8 %201 to i32
  %and396 = and i32 %conv395, 16
  %tobool397 = icmp ne i32 %and396, 0
  br i1 %tobool397, label %cond.false.412, label %cond.true.398

cond.true.398:                                    ; preds = %cond.false.393
  store i32 3, i32* %fetch_len, align 4
  %202 = load i8*, i8** %fetch_ptr, align 8
  %arrayidx399 = getelementptr inbounds i8, i8* %202, i64 0
  %203 = load i8, i8* %arrayidx399, align 1
  %conv400 = zext i8 %203 to i32
  %and401 = and i32 %conv400, 15
  %shl402 = shl i32 %and401, 12
  %204 = load i8*, i8** %fetch_ptr, align 8
  %arrayidx403 = getelementptr inbounds i8, i8* %204, i64 1
  %205 = load i8, i8* %arrayidx403, align 1
  %conv404 = zext i8 %205 to i32
  %and405 = and i32 %conv404, 63
  %shl406 = shl i32 %and405, 6
  %or407 = or i32 %shl402, %shl406
  %206 = load i8*, i8** %fetch_ptr, align 8
  %arrayidx408 = getelementptr inbounds i8, i8* %206, i64 2
  %207 = load i8, i8* %arrayidx408, align 1
  %conv409 = zext i8 %207 to i32
  %and410 = and i32 %conv409, 63
  %or411 = or i32 %or407, %and410
  br label %cond.end.414

cond.false.412:                                   ; preds = %cond.false.393
  %208 = load i8*, i8** %fetch_ptr, align 8
  %call413 = call i32 @string_char(i8* %208, i8** null, i32* %fetch_len)
  br label %cond.end.414

cond.end.414:                                     ; preds = %cond.false.412, %cond.true.398
  %cond415 = phi i32 [ %or411, %cond.true.398 ], [ %call413, %cond.false.412 ]
  br label %cond.end.416

cond.end.416:                                     ; preds = %cond.end.414, %cond.true.379
  %cond417 = phi i32 [ %add392, %cond.true.379 ], [ %cond415, %cond.end.414 ]
  br label %cond.end.418

cond.end.418:                                     ; preds = %cond.end.416, %cond.true.371
  %cond419 = phi i32 [ %conv373, %cond.true.371 ], [ %cond417, %cond.end.416 ]
  store i32 %cond419, i32* %c361, align 4
  %209 = load i32, i32* %fetch_len, align 4
  %conv420 = sext i32 %209 to i64
  %210 = load i64, i64* %thisindex_byte, align 8
  %add421 = add nsw i64 %210, %conv420
  store i64 %add421, i64* %thisindex_byte, align 8
  %211 = load i64, i64* %thisindex, align 8
  %inc422 = add nsw i64 %211, 1
  store i64 %inc422, i64* %thisindex, align 8
  br label %do.end.423

do.end.423:                                       ; preds = %cond.end.418
  br label %if.end.443

if.else.424:                                      ; preds = %if.then.360
  %212 = load i64, i64* %this, align 8
  %213 = load i64, i64* %thisindex, align 8
  %call425 = call zeroext i8 @SREF(i64 %212, i64 %213)
  %conv426 = zext i8 %call425 to i32
  store i32 %conv426, i32* %c361, align 4
  %214 = load i64, i64* %thisindex, align 8
  %inc427 = add nsw i64 %214, 1
  store i64 %inc427, i64* %thisindex, align 8
  %215 = load i8, i8* %some_multibyte, align 1
  %tobool428 = trunc i8 %215 to i1
  br i1 %tobool428, label %land.lhs.true.430, label %if.end.442

land.lhs.true.430:                                ; preds = %if.else.424
  br i1 true, label %cond.true.431, label %cond.false.435

cond.true.431:                                    ; preds = %land.lhs.true.430
  %216 = load i32, i32* %c361, align 4
  %add432 = add i32 %216, 0
  %cmp433 = icmp ult i32 %add432, 128
  br i1 %cmp433, label %if.end.442, label %if.then.440

cond.false.435:                                   ; preds = %land.lhs.true.430
  %217 = load i32, i32* %c361, align 4
  %conv436 = sext i32 %217 to i64
  %add437 = add i64 %conv436, 0
  %cmp438 = icmp ult i64 %add437, 128
  br i1 %cmp438, label %if.end.442, label %if.then.440

if.then.440:                                      ; preds = %cond.false.435, %cond.true.431
  %218 = load i32, i32* %c361, align 4
  %add441 = add nsw i32 %218, 4194048
  store i32 %add441, i32* %c361, align 4
  br label %if.end.442

if.end.442:                                       ; preds = %if.then.440, %cond.false.435, %cond.true.431, %if.else.424
  br label %if.end.443

if.end.443:                                       ; preds = %if.end.442, %do.end.423
  %219 = load i32, i32* %c361, align 4
  %conv444 = sext i32 %219 to i64
  %call445 = call i64 @make_natnum(i64 %conv444)
  store i64 %call445, i64* %elt, align 8
  br label %if.end.455

if.else.446:                                      ; preds = %if.else.358
  %220 = load i64, i64* %this, align 8
  %call447 = call zeroext i1 @BOOL_VECTOR_P(i64 %220)
  br i1 %call447, label %if.then.448, label %if.else.451

if.then.448:                                      ; preds = %if.else.446
  %221 = load i64, i64* %this, align 8
  %222 = load i64, i64* %thisindex, align 8
  %call449 = call i64 @bool_vector_ref(i64 %221, i64 %222)
  store i64 %call449, i64* %elt, align 8
  %223 = load i64, i64* %thisindex, align 8
  %inc450 = add nsw i64 %223, 1
  store i64 %inc450, i64* %thisindex, align 8
  br label %if.end.454

if.else.451:                                      ; preds = %if.else.446
  %224 = load i64, i64* %this, align 8
  %225 = load i64, i64* %thisindex, align 8
  %call452 = call i64 @AREF(i64 %224, i64 %225)
  store i64 %call452, i64* %elt, align 8
  %226 = load i64, i64* %thisindex, align 8
  %inc453 = add nsw i64 %226, 1
  store i64 %inc453, i64* %thisindex, align 8
  br label %if.end.454

if.end.454:                                       ; preds = %if.else.451, %if.then.448
  br label %if.end.455

if.end.455:                                       ; preds = %if.end.454, %if.end.443
  br label %if.end.456

if.end.456:                                       ; preds = %if.end.455
  br label %if.end.457

if.end.457:                                       ; preds = %if.end.456, %if.then.348
  %227 = load i64, i64* %toindex, align 8
  %cmp458 = icmp slt i64 %227, 0
  br i1 %cmp458, label %if.then.460, label %if.else.464

if.then.460:                                      ; preds = %if.end.457
  %228 = load i64, i64* %tail, align 8
  %229 = load i64, i64* %elt, align 8
  call void @XSETCAR(i64 %228, i64 %229)
  %230 = load i64, i64* %tail, align 8
  store i64 %230, i64* %prev, align 8
  %231 = load i64, i64* %tail, align 8
  %sub461 = sub nsw i64 %231, 3
  %232 = inttoptr i64 %sub461 to i8*
  %233 = bitcast i8* %232 to %struct.Lisp_Cons*
  %u462 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %233, i32 0, i32 1
  %cdr463 = bitcast %union.anon* %u462 to i64*
  %234 = load i64, i64* %cdr463, align 8
  store i64 %234, i64* %tail, align 8
  br label %if.end.569

if.else.464:                                      ; preds = %if.end.457
  %235 = load i64, i64* %val, align 8
  %call465 = call zeroext i1 @VECTORP(i64 %235)
  br i1 %call465, label %if.then.466, label %if.else.468

if.then.466:                                      ; preds = %if.else.464
  %236 = load i64, i64* %val, align 8
  %237 = load i64, i64* %toindex, align 8
  %238 = load i64, i64* %elt, align 8
  call void @ASET(i64 %236, i64 %237, i64 %238)
  %239 = load i64, i64* %toindex, align 8
  %inc467 = add nsw i64 %239, 1
  store i64 %inc467, i64* %toindex, align 8
  br label %if.end.568

if.else.468:                                      ; preds = %if.else.464
  %240 = load i64, i64* %elt, align 8
  %call470 = call zeroext i1 @NATNUMP(i64 %240)
  br i1 %call470, label %land.lhs.true.472, label %cond.false.477

land.lhs.true.472:                                ; preds = %if.else.468
  %241 = load i64, i64* %elt, align 8
  %shr473 = ashr i64 %241, 2
  %cmp474 = icmp sle i64 %shr473, 4194303
  br i1 %cmp474, label %cond.true.476, label %cond.false.477

cond.true.476:                                    ; preds = %land.lhs.true.472
  br label %cond.end.479

cond.false.477:                                   ; preds = %land.lhs.true.472, %if.else.468
  %call478 = call i64 @builtin_lisp_symbol(i32 260)
  %242 = load i64, i64* %elt, align 8
  %243 = call i64 @wrong_type_argument(i64 %call478, i64 %242) #8
  unreachable
                                                  ; No predecessors!
  br label %cond.end.479

cond.end.479:                                     ; preds = %244, %cond.true.476
  %245 = load i64, i64* %elt, align 8
  %shr480 = ashr i64 %245, 2
  %conv481 = trunc i64 %shr480 to i32
  store i32 %conv481, i32* %c469, align 4
  %246 = load i8, i8* %some_multibyte, align 1
  %tobool482 = trunc i8 %246 to i1
  br i1 %tobool482, label %if.then.483, label %if.else.563

if.then.483:                                      ; preds = %cond.end.479
  br i1 true, label %cond.true.484, label %cond.false.488

cond.true.484:                                    ; preds = %if.then.483
  %247 = load i32, i32* %c469, align 4
  %add485 = add i32 %247, 0
  %cmp486 = icmp ule i32 %add485, 127
  br i1 %cmp486, label %cond.true.493, label %cond.false.498

cond.false.488:                                   ; preds = %if.then.483
  %248 = load i32, i32* %c469, align 4
  %conv489 = sext i32 %248 to i64
  %add490 = add i64 %conv489, 0
  %cmp491 = icmp ule i64 %add490, 127
  br i1 %cmp491, label %cond.true.493, label %cond.false.498

cond.true.493:                                    ; preds = %cond.false.488, %cond.true.484
  %249 = load i32, i32* %c469, align 4
  %conv494 = trunc i32 %249 to i8
  %250 = load i64, i64* %val, align 8
  %call495 = call i8* @SDATA(i64 %250)
  %251 = load i64, i64* %toindex_byte, align 8
  %add.ptr496 = getelementptr inbounds i8, i8* %call495, i64 %251
  %arrayidx497 = getelementptr inbounds i8, i8* %add.ptr496, i64 0
  store i8 %conv494, i8* %arrayidx497, align 1
  br label %cond.end.559

cond.false.498:                                   ; preds = %cond.false.488, %cond.true.484
  br i1 true, label %cond.true.499, label %cond.false.503

cond.true.499:                                    ; preds = %cond.false.498
  %252 = load i32, i32* %c469, align 4
  %add500 = add i32 %252, 0
  %cmp501 = icmp ule i32 %add500, 2047
  br i1 %cmp501, label %cond.true.508, label %cond.false.521

cond.false.503:                                   ; preds = %cond.false.498
  %253 = load i32, i32* %c469, align 4
  %conv504 = sext i32 %253 to i64
  %add505 = add i64 %conv504, 0
  %cmp506 = icmp ule i64 %add505, 2047
  br i1 %cmp506, label %cond.true.508, label %cond.false.521

cond.true.508:                                    ; preds = %cond.false.503, %cond.true.499
  %254 = load i32, i32* %c469, align 4
  %shr509 = ashr i32 %254, 6
  %or510 = or i32 192, %shr509
  %conv511 = trunc i32 %or510 to i8
  %255 = load i64, i64* %val, align 8
  %call512 = call i8* @SDATA(i64 %255)
  %256 = load i64, i64* %toindex_byte, align 8
  %add.ptr513 = getelementptr inbounds i8, i8* %call512, i64 %256
  %arrayidx514 = getelementptr inbounds i8, i8* %add.ptr513, i64 0
  store i8 %conv511, i8* %arrayidx514, align 1
  %257 = load i32, i32* %c469, align 4
  %and515 = and i32 %257, 63
  %or516 = or i32 128, %and515
  %conv517 = trunc i32 %or516 to i8
  %258 = load i64, i64* %val, align 8
  %call518 = call i8* @SDATA(i64 %258)
  %259 = load i64, i64* %toindex_byte, align 8
  %add.ptr519 = getelementptr inbounds i8, i8* %call518, i64 %259
  %arrayidx520 = getelementptr inbounds i8, i8* %add.ptr519, i64 1
  store i8 %conv517, i8* %arrayidx520, align 1
  br label %cond.end.557

cond.false.521:                                   ; preds = %cond.false.503, %cond.true.499
  br i1 true, label %cond.true.522, label %cond.false.526

cond.true.522:                                    ; preds = %cond.false.521
  %260 = load i32, i32* %c469, align 4
  %add523 = add i32 %260, 0
  %cmp524 = icmp ule i32 %add523, 65535
  br i1 %cmp524, label %cond.true.531, label %cond.false.551

cond.false.526:                                   ; preds = %cond.false.521
  %261 = load i32, i32* %c469, align 4
  %conv527 = sext i32 %261 to i64
  %add528 = add i64 %conv527, 0
  %cmp529 = icmp ule i64 %add528, 65535
  br i1 %cmp529, label %cond.true.531, label %cond.false.551

cond.true.531:                                    ; preds = %cond.false.526, %cond.true.522
  %262 = load i32, i32* %c469, align 4
  %shr532 = ashr i32 %262, 12
  %or533 = or i32 224, %shr532
  %conv534 = trunc i32 %or533 to i8
  %263 = load i64, i64* %val, align 8
  %call535 = call i8* @SDATA(i64 %263)
  %264 = load i64, i64* %toindex_byte, align 8
  %add.ptr536 = getelementptr inbounds i8, i8* %call535, i64 %264
  %arrayidx537 = getelementptr inbounds i8, i8* %add.ptr536, i64 0
  store i8 %conv534, i8* %arrayidx537, align 1
  %265 = load i32, i32* %c469, align 4
  %shr538 = ashr i32 %265, 6
  %and539 = and i32 %shr538, 63
  %or540 = or i32 128, %and539
  %conv541 = trunc i32 %or540 to i8
  %266 = load i64, i64* %val, align 8
  %call542 = call i8* @SDATA(i64 %266)
  %267 = load i64, i64* %toindex_byte, align 8
  %add.ptr543 = getelementptr inbounds i8, i8* %call542, i64 %267
  %arrayidx544 = getelementptr inbounds i8, i8* %add.ptr543, i64 1
  store i8 %conv541, i8* %arrayidx544, align 1
  %268 = load i32, i32* %c469, align 4
  %and545 = and i32 %268, 63
  %or546 = or i32 128, %and545
  %conv547 = trunc i32 %or546 to i8
  %269 = load i64, i64* %val, align 8
  %call548 = call i8* @SDATA(i64 %269)
  %270 = load i64, i64* %toindex_byte, align 8
  %add.ptr549 = getelementptr inbounds i8, i8* %call548, i64 %270
  %arrayidx550 = getelementptr inbounds i8, i8* %add.ptr549, i64 2
  store i8 %conv547, i8* %arrayidx550, align 1
  br label %cond.end.555

cond.false.551:                                   ; preds = %cond.false.526, %cond.true.522
  %271 = load i32, i32* %c469, align 4
  %272 = load i64, i64* %val, align 8
  %call552 = call i8* @SDATA(i64 %272)
  %273 = load i64, i64* %toindex_byte, align 8
  %add.ptr553 = getelementptr inbounds i8, i8* %call552, i64 %273
  %call554 = call i32 @char_string(i32 %271, i8* %add.ptr553)
  br label %cond.end.555

cond.end.555:                                     ; preds = %cond.false.551, %cond.true.531
  %cond556 = phi i32 [ 3, %cond.true.531 ], [ %call554, %cond.false.551 ]
  br label %cond.end.557

cond.end.557:                                     ; preds = %cond.end.555, %cond.true.508
  %cond558 = phi i32 [ 2, %cond.true.508 ], [ %cond556, %cond.end.555 ]
  br label %cond.end.559

cond.end.559:                                     ; preds = %cond.end.557, %cond.true.493
  %cond560 = phi i32 [ 1, %cond.true.493 ], [ %cond558, %cond.end.557 ]
  %conv561 = sext i32 %cond560 to i64
  %274 = load i64, i64* %toindex_byte, align 8
  %add562 = add nsw i64 %274, %conv561
  store i64 %add562, i64* %toindex_byte, align 8
  br label %if.end.566

if.else.563:                                      ; preds = %cond.end.479
  %275 = load i64, i64* %val, align 8
  %276 = load i64, i64* %toindex_byte, align 8
  %inc564 = add nsw i64 %276, 1
  store i64 %inc564, i64* %toindex_byte, align 8
  %277 = load i32, i32* %c469, align 4
  %conv565 = trunc i32 %277 to i8
  call void @SSET(i64 %275, i64 %276, i8 zeroext %conv565)
  br label %if.end.566

if.end.566:                                       ; preds = %if.else.563, %cond.end.559
  %278 = load i64, i64* %toindex, align 8
  %inc567 = add nsw i64 %278, 1
  store i64 %inc567, i64* %toindex, align 8
  br label %if.end.568

if.end.568:                                       ; preds = %if.end.566, %if.then.466
  br label %if.end.569

if.end.569:                                       ; preds = %if.end.568, %if.then.460
  br label %while.body

while.end:                                        ; preds = %if.then.357, %if.then.342
  br label %if.end.570

if.end.570:                                       ; preds = %while.end, %if.end.330
  br label %if.end.571

if.end.571:                                       ; preds = %if.end.570, %if.end.310
  br label %for.inc.572

for.inc.572:                                      ; preds = %if.end.571
  %279 = load i64, i64* %argnum, align 8
  %inc573 = add nsw i64 %279, 1
  store i64 %inc573, i64* %argnum, align 8
  br label %for.cond.272

for.end.574:                                      ; preds = %for.cond.272
  %280 = load i64, i64* %prev, align 8
  %call575 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp576 = icmp eq i64 %280, %call575
  br i1 %cmp576, label %if.end.579, label %if.then.578

if.then.578:                                      ; preds = %for.end.574
  %281 = load i64, i64* %prev, align 8
  %282 = load i64, i64* %last_tail, align 8
  call void @XSETCDR(i64 %281, i64 %282)
  br label %if.end.579

if.end.579:                                       ; preds = %if.then.578, %for.end.574
  %283 = load i64, i64* %num_textprops, align 8
  %cmp580 = icmp sgt i64 %283, 0
  br i1 %cmp580, label %if.then.582, label %if.end.612

if.then.582:                                      ; preds = %if.end.579
  store i64 -1, i64* %last_to_end, align 8
  store i64 0, i64* %argnum, align 8
  br label %for.cond.583

for.cond.583:                                     ; preds = %for.inc.609, %if.then.582
  %284 = load i64, i64* %argnum, align 8
  %285 = load i64, i64* %num_textprops, align 8
  %cmp584 = icmp slt i64 %284, %285
  br i1 %cmp584, label %for.body.586, label %for.end.611

for.body.586:                                     ; preds = %for.cond.583
  %286 = load i64, i64* %argnum, align 8
  %287 = load %struct.textprop_rec*, %struct.textprop_rec** %textprops, align 8
  %arrayidx587 = getelementptr inbounds %struct.textprop_rec, %struct.textprop_rec* %287, i64 %286
  %argnum588 = getelementptr inbounds %struct.textprop_rec, %struct.textprop_rec* %arrayidx587, i32 0, i32 0
  %288 = load i64, i64* %argnum588, align 8
  %289 = load i64*, i64** %args.addr, align 8
  %arrayidx589 = getelementptr inbounds i64, i64* %289, i64 %288
  %290 = load i64, i64* %arrayidx589, align 8
  store i64 %290, i64* %this, align 8
  %291 = load i64, i64* %this, align 8
  %292 = load i64, i64* %this, align 8
  %call590 = call i64 @SCHARS(i64 %292)
  %shl591 = shl i64 %call590, 2
  %add592 = add i64 %shl591, 2
  %call593 = call i64 @builtin_lisp_symbol(i32 0)
  %call594 = call i64 @text_property_list(i64 %291, i64 2, i64 %add592, i64 %call593)
  store i64 %call594, i64* %props, align 8
  %293 = load i64, i64* %last_to_end, align 8
  %294 = load i64, i64* %argnum, align 8
  %295 = load %struct.textprop_rec*, %struct.textprop_rec** %textprops, align 8
  %arrayidx595 = getelementptr inbounds %struct.textprop_rec, %struct.textprop_rec* %295, i64 %294
  %to596 = getelementptr inbounds %struct.textprop_rec, %struct.textprop_rec* %arrayidx595, i32 0, i32 2
  %296 = load i64, i64* %to596, align 8
  %cmp597 = icmp eq i64 %293, %296
  br i1 %cmp597, label %if.then.599, label %if.end.600

if.then.599:                                      ; preds = %for.body.586
  %297 = load i64, i64* %props, align 8
  call void @make_composition_value_copy(i64 %297)
  br label %if.end.600

if.end.600:                                       ; preds = %if.then.599, %for.body.586
  %298 = load i64, i64* %val, align 8
  %299 = load i64, i64* %props, align 8
  %300 = load i64, i64* %argnum, align 8
  %301 = load %struct.textprop_rec*, %struct.textprop_rec** %textprops, align 8
  %arrayidx601 = getelementptr inbounds %struct.textprop_rec, %struct.textprop_rec* %301, i64 %300
  %to602 = getelementptr inbounds %struct.textprop_rec, %struct.textprop_rec* %arrayidx601, i32 0, i32 2
  %302 = load i64, i64* %to602, align 8
  %shl603 = shl i64 %302, 2
  %add604 = add i64 %shl603, 2
  call void @add_text_properties_from_list(i64 %298, i64 %299, i64 %add604)
  %303 = load i64, i64* %argnum, align 8
  %304 = load %struct.textprop_rec*, %struct.textprop_rec** %textprops, align 8
  %arrayidx605 = getelementptr inbounds %struct.textprop_rec, %struct.textprop_rec* %304, i64 %303
  %to606 = getelementptr inbounds %struct.textprop_rec, %struct.textprop_rec* %arrayidx605, i32 0, i32 2
  %305 = load i64, i64* %to606, align 8
  %306 = load i64, i64* %this, align 8
  %call607 = call i64 @SCHARS(i64 %306)
  %add608 = add nsw i64 %305, %call607
  store i64 %add608, i64* %last_to_end, align 8
  br label %for.inc.609

for.inc.609:                                      ; preds = %if.end.600
  %307 = load i64, i64* %argnum, align 8
  %inc610 = add nsw i64 %307, 1
  store i64 %inc610, i64* %argnum, align 8
  br label %for.cond.583

for.end.611:                                      ; preds = %for.cond.583
  br label %if.end.612

if.end.612:                                       ; preds = %for.end.611, %if.end.579
  br label %do.body.613

do.body.613:                                      ; preds = %if.end.612
  %308 = load i8, i8* %sa_must_free, align 1
  %tobool614 = trunc i8 %308 to i1
  br i1 %tobool614, label %if.then.615, label %if.end.618

if.then.615:                                      ; preds = %do.body.613
  store i8 0, i8* %sa_must_free, align 1
  %309 = load i64, i64* %sa_count, align 8
  %call616 = call i64 @builtin_lisp_symbol(i32 0)
  %call617 = call i64 @unbind_to(i64 %309, i64 %call616)
  br label %if.end.618

if.end.618:                                       ; preds = %if.then.615, %do.body.613
  br label %do.end.619

do.end.619:                                       ; preds = %if.end.618
  %310 = load i64, i64* %val, align 8
  store i64 %310, i64* %retval
  br label %return

return:                                           ; preds = %do.end.619, %if.then.250
  %311 = load i64, i64* %retval
  ret i64 %311
}

; Function Attrs: nounwind uwtable
define i64 @concat3(i64 %s1, i64 %s2, i64 %s3) #1 {
entry:
  %s1.addr = alloca i64, align 8
  %s2.addr = alloca i64, align 8
  %s3.addr = alloca i64, align 8
  %.compoundliteral = alloca [3 x i64], align 8
  store i64 %s1, i64* %s1.addr, align 8
  store i64 %s2, i64* %s2.addr, align 8
  store i64 %s3, i64* %s3.addr, align 8
  %arrayinit.begin = getelementptr inbounds [3 x i64], [3 x i64]* %.compoundliteral, i64 0, i64 0
  %0 = load i64, i64* %s1.addr, align 8
  store i64 %0, i64* %arrayinit.begin
  %arrayinit.element = getelementptr inbounds i64, i64* %arrayinit.begin, i64 1
  %1 = load i64, i64* %s2.addr, align 8
  store i64 %1, i64* %arrayinit.element
  %arrayinit.element1 = getelementptr inbounds i64, i64* %arrayinit.element, i64 1
  %2 = load i64, i64* %s3.addr, align 8
  store i64 %2, i64* %arrayinit.element1
  %arraydecay = getelementptr inbounds [3 x i64], [3 x i64]* %.compoundliteral, i32 0, i32 0
  %call = call i64 @concat(i64 3, i64* %arraydecay, i32 4, i1 zeroext false)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define i64 @Fappend(i64 %nargs, i64* %args) #1 {
entry:
  %nargs.addr = alloca i64, align 8
  %args.addr = alloca i64*, align 8
  store i64 %nargs, i64* %nargs.addr, align 8
  store i64* %args, i64** %args.addr, align 8
  %0 = load i64, i64* %nargs.addr, align 8
  %1 = load i64*, i64** %args.addr, align 8
  %call = call i64 @concat(i64 %0, i64* %1, i32 3, i1 zeroext true)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define i64 @Fconcat(i64 %nargs, i64* %args) #1 {
entry:
  %nargs.addr = alloca i64, align 8
  %args.addr = alloca i64*, align 8
  store i64 %nargs, i64* %nargs.addr, align 8
  store i64* %args, i64** %args.addr, align 8
  %0 = load i64, i64* %nargs.addr, align 8
  %1 = load i64*, i64** %args.addr, align 8
  %call = call i64 @concat(i64 %0, i64* %1, i32 4, i1 zeroext false)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define i64 @Fvconcat(i64 %nargs, i64* %args) #1 {
entry:
  %nargs.addr = alloca i64, align 8
  %args.addr = alloca i64*, align 8
  store i64 %nargs, i64* %nargs.addr, align 8
  store i64* %args, i64** %args.addr, align 8
  %0 = load i64, i64* %nargs.addr, align 8
  %1 = load i64*, i64** %args.addr, align 8
  %call = call i64 @concat(i64 %0, i64* %1, i32 5, i1 zeroext false)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define i64 @Fcopy_sequence(i64 %arg) #1 {
entry:
  %retval = alloca i64, align 8
  %arg.addr = alloca i64, align 8
  %nbits = alloca i64, align 8
  %nbytes = alloca i64, align 8
  %val = alloca i64, align 8
  store i64 %arg, i64* %arg.addr, align 8
  %0 = load i64, i64* %arg.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %0, %call
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i64, i64* %arg.addr, align 8
  store i64 %1, i64* %retval
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i64, i64* %arg.addr, align 8
  %call1 = call zeroext i1 @CHAR_TABLE_P(i64 %2)
  br i1 %call1, label %if.then.2, label %if.end.4

if.then.2:                                        ; preds = %if.end
  %3 = load i64, i64* %arg.addr, align 8
  %call3 = call i64 @copy_char_table(i64 %3)
  store i64 %call3, i64* %retval
  br label %return

if.end.4:                                         ; preds = %if.end
  %4 = load i64, i64* %arg.addr, align 8
  %call5 = call zeroext i1 @BOOL_VECTOR_P(i64 %4)
  br i1 %call5, label %if.then.6, label %if.end.12

if.then.6:                                        ; preds = %if.end.4
  %5 = load i64, i64* %arg.addr, align 8
  %call7 = call i64 @bool_vector_size(i64 %5)
  store i64 %call7, i64* %nbits, align 8
  %6 = load i64, i64* %nbits, align 8
  %call8 = call i64 @bool_vector_bytes(i64 %6)
  store i64 %call8, i64* %nbytes, align 8
  %7 = load i64, i64* %nbits, align 8
  %call9 = call i64 @make_uninit_bool_vector(i64 %7)
  store i64 %call9, i64* %val, align 8
  %8 = load i64, i64* %val, align 8
  %call10 = call i64* @bool_vector_data(i64 %8)
  %9 = bitcast i64* %call10 to i8*
  %10 = load i64, i64* %arg.addr, align 8
  %call11 = call i64* @bool_vector_data(i64 %10)
  %11 = bitcast i64* %call11 to i8*
  %12 = load i64, i64* %nbytes, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %9, i8* %11, i64 %12, i32 8, i1 false)
  %13 = load i64, i64* %val, align 8
  store i64 %13, i64* %retval
  br label %return

if.end.12:                                        ; preds = %if.end.4
  %14 = load i64, i64* %arg.addr, align 8
  %and = and i64 %14, 7
  %conv = trunc i64 %and to i32
  %cmp13 = icmp eq i32 %conv, 3
  br i1 %cmp13, label %if.end.20, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end.12
  %15 = load i64, i64* %arg.addr, align 8
  %call15 = call zeroext i1 @VECTORP(i64 %15)
  br i1 %call15, label %if.end.20, label %land.lhs.true.16

land.lhs.true.16:                                 ; preds = %land.lhs.true
  %16 = load i64, i64* %arg.addr, align 8
  %call17 = call zeroext i1 @STRINGP(i64 %16)
  br i1 %call17, label %if.end.20, label %if.then.18

if.then.18:                                       ; preds = %land.lhs.true.16
  %call19 = call i64 @builtin_lisp_symbol(i32 844)
  %17 = load i64, i64* %arg.addr, align 8
  %18 = call i64 @wrong_type_argument(i64 %call19, i64 %17) #8
  unreachable

if.end.20:                                        ; preds = %land.lhs.true.16, %land.lhs.true, %if.end.12
  %19 = load i64, i64* %arg.addr, align 8
  %and21 = and i64 %19, 7
  %conv22 = trunc i64 %and21 to i32
  %call23 = call i64 @concat(i64 1, i64* %arg.addr, i32 %conv22, i1 zeroext false)
  store i64 %call23, i64* %retval
  br label %return

return:                                           ; preds = %if.end.20, %if.then.6, %if.then.2, %if.then
  %20 = load i64, i64* %retval
  ret i64 %20
}

declare i64 @copy_char_table(i64) #2

declare i64 @bool_vector_bytes(i64) #2

declare i64 @make_uninit_bool_vector(i64) #2

declare i64* @bool_vector_data(i64) #2

; Function Attrs: nounwind
declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture, i8* nocapture readonly, i64, i32, i1) #5

; Function Attrs: nounwind uwtable
define void @clear_string_char_byte_cache() #1 {
entry:
  %call = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call, i64* @string_char_byte_cache_string, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define i64 @string_byte_to_char(i64 %string, i64 %byte_index) #1 {
entry:
  %retval = alloca i64, align 8
  %string.addr = alloca i64, align 8
  %byte_index.addr = alloca i64, align 8
  %i = alloca i64, align 8
  %i_byte = alloca i64, align 8
  %best_below = alloca i64, align 8
  %best_below_byte = alloca i64, align 8
  %best_above = alloca i64, align 8
  %best_above_byte = alloca i64, align 8
  %p = alloca i8*, align 8
  %pend = alloca i8*, align 8
  %p36 = alloca i8*, align 8
  %pbeg = alloca i8*, align 8
  store i64 %string, i64* %string.addr, align 8
  store i64 %byte_index, i64* %byte_index.addr, align 8
  store i64 0, i64* %best_below_byte, align 8
  store i64 0, i64* %best_below, align 8
  %0 = load i64, i64* %string.addr, align 8
  %call = call i64 @SCHARS(i64 %0)
  store i64 %call, i64* %best_above, align 8
  %1 = load i64, i64* %string.addr, align 8
  %call1 = call i64 @SBYTES(i64 %1)
  store i64 %call1, i64* %best_above_byte, align 8
  %2 = load i64, i64* %best_above, align 8
  %3 = load i64, i64* %best_above_byte, align 8
  %cmp = icmp eq i64 %2, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load i64, i64* %byte_index.addr, align 8
  store i64 %4, i64* %retval
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i64, i64* %string.addr, align 8
  %6 = load i64, i64* @string_char_byte_cache_string, align 8
  %cmp2 = icmp eq i64 %5, %6
  br i1 %cmp2, label %if.then.3, label %if.end.7

if.then.3:                                        ; preds = %if.end
  %7 = load i64, i64* @string_char_byte_cache_bytepos, align 8
  %8 = load i64, i64* %byte_index.addr, align 8
  %cmp4 = icmp slt i64 %7, %8
  br i1 %cmp4, label %if.then.5, label %if.else

if.then.5:                                        ; preds = %if.then.3
  %9 = load i64, i64* @string_char_byte_cache_charpos, align 8
  store i64 %9, i64* %best_below, align 8
  %10 = load i64, i64* @string_char_byte_cache_bytepos, align 8
  store i64 %10, i64* %best_below_byte, align 8
  br label %if.end.6

if.else:                                          ; preds = %if.then.3
  %11 = load i64, i64* @string_char_byte_cache_charpos, align 8
  store i64 %11, i64* %best_above, align 8
  %12 = load i64, i64* @string_char_byte_cache_bytepos, align 8
  store i64 %12, i64* %best_above_byte, align 8
  br label %if.end.6

if.end.6:                                         ; preds = %if.else, %if.then.5
  br label %if.end.7

if.end.7:                                         ; preds = %if.end.6, %if.end
  %13 = load i64, i64* %byte_index.addr, align 8
  %14 = load i64, i64* %best_below_byte, align 8
  %sub = sub nsw i64 %13, %14
  %15 = load i64, i64* %best_above_byte, align 8
  %16 = load i64, i64* %byte_index.addr, align 8
  %sub8 = sub nsw i64 %15, %16
  %cmp9 = icmp slt i64 %sub, %sub8
  br i1 %cmp9, label %if.then.10, label %if.else.35

if.then.10:                                       ; preds = %if.end.7
  %17 = load i64, i64* %string.addr, align 8
  %call11 = call i8* @SDATA(i64 %17)
  %18 = load i64, i64* %best_below_byte, align 8
  %add.ptr = getelementptr inbounds i8, i8* %call11, i64 %18
  store i8* %add.ptr, i8** %p, align 8
  %19 = load i64, i64* %string.addr, align 8
  %call12 = call i8* @SDATA(i64 %19)
  %20 = load i64, i64* %byte_index.addr, align 8
  %add.ptr13 = getelementptr inbounds i8, i8* %call12, i64 %20
  store i8* %add.ptr13, i8** %pend, align 8
  br label %while.cond

while.cond:                                       ; preds = %cond.end.31, %if.then.10
  %21 = load i8*, i8** %p, align 8
  %22 = load i8*, i8** %pend, align 8
  %cmp14 = icmp ult i8* %21, %22
  br i1 %cmp14, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %23 = load i8*, i8** %p, align 8
  %24 = load i8, i8* %23, align 1
  %conv = zext i8 %24 to i32
  %and = and i32 %conv, 128
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %while.body
  br label %cond.end.31

cond.false:                                       ; preds = %while.body
  %25 = load i8*, i8** %p, align 8
  %26 = load i8, i8* %25, align 1
  %conv15 = zext i8 %26 to i32
  %and16 = and i32 %conv15, 32
  %tobool17 = icmp ne i32 %and16, 0
  br i1 %tobool17, label %cond.false.19, label %cond.true.18

cond.true.18:                                     ; preds = %cond.false
  br label %cond.end.29

cond.false.19:                                    ; preds = %cond.false
  %27 = load i8*, i8** %p, align 8
  %28 = load i8, i8* %27, align 1
  %conv20 = zext i8 %28 to i32
  %and21 = and i32 %conv20, 16
  %tobool22 = icmp ne i32 %and21, 0
  br i1 %tobool22, label %cond.false.24, label %cond.true.23

cond.true.23:                                     ; preds = %cond.false.19
  br label %cond.end

cond.false.24:                                    ; preds = %cond.false.19
  %29 = load i8*, i8** %p, align 8
  %30 = load i8, i8* %29, align 1
  %conv25 = zext i8 %30 to i32
  %and26 = and i32 %conv25, 8
  %tobool27 = icmp ne i32 %and26, 0
  %lnot = xor i1 %tobool27, true
  %cond = select i1 %lnot, i32 4, i32 5
  br label %cond.end

cond.end:                                         ; preds = %cond.false.24, %cond.true.23
  %cond28 = phi i32 [ 3, %cond.true.23 ], [ %cond, %cond.false.24 ]
  br label %cond.end.29

cond.end.29:                                      ; preds = %cond.end, %cond.true.18
  %cond30 = phi i32 [ 2, %cond.true.18 ], [ %cond28, %cond.end ]
  br label %cond.end.31

cond.end.31:                                      ; preds = %cond.end.29, %cond.true
  %cond32 = phi i32 [ 1, %cond.true ], [ %cond30, %cond.end.29 ]
  %31 = load i8*, i8** %p, align 8
  %idx.ext = sext i32 %cond32 to i64
  %add.ptr33 = getelementptr inbounds i8, i8* %31, i64 %idx.ext
  store i8* %add.ptr33, i8** %p, align 8
  %32 = load i64, i64* %best_below, align 8
  %inc = add nsw i64 %32, 1
  store i64 %inc, i64* %best_below, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %33 = load i64, i64* %best_below, align 8
  store i64 %33, i64* %i, align 8
  %34 = load i8*, i8** %p, align 8
  %35 = load i64, i64* %string.addr, align 8
  %call34 = call i8* @SDATA(i64 %35)
  %sub.ptr.lhs.cast = ptrtoint i8* %34 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %call34 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, i64* %i_byte, align 8
  br label %if.end.59

if.else.35:                                       ; preds = %if.end.7
  %36 = load i64, i64* %string.addr, align 8
  %call37 = call i8* @SDATA(i64 %36)
  %37 = load i64, i64* %best_above_byte, align 8
  %add.ptr38 = getelementptr inbounds i8, i8* %call37, i64 %37
  store i8* %add.ptr38, i8** %p36, align 8
  %38 = load i64, i64* %string.addr, align 8
  %call39 = call i8* @SDATA(i64 %38)
  %39 = load i64, i64* %byte_index.addr, align 8
  %add.ptr40 = getelementptr inbounds i8, i8* %call39, i64 %39
  store i8* %add.ptr40, i8** %pbeg, align 8
  br label %while.cond.41

while.cond.41:                                    ; preds = %while.end.53, %if.else.35
  %40 = load i8*, i8** %p36, align 8
  %41 = load i8*, i8** %pbeg, align 8
  %cmp42 = icmp ugt i8* %40, %41
  br i1 %cmp42, label %while.body.44, label %while.end.54

while.body.44:                                    ; preds = %while.cond.41
  %42 = load i8*, i8** %p36, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %42, i32 -1
  store i8* %incdec.ptr, i8** %p36, align 8
  br label %while.cond.45

while.cond.45:                                    ; preds = %while.body.51, %while.body.44
  %43 = load i8*, i8** %p36, align 8
  %44 = load i8, i8* %43, align 1
  %conv46 = zext i8 %44 to i32
  %and47 = and i32 %conv46, 192
  %cmp48 = icmp ne i32 %and47, 128
  %lnot50 = xor i1 %cmp48, true
  br i1 %lnot50, label %while.body.51, label %while.end.53

while.body.51:                                    ; preds = %while.cond.45
  %45 = load i8*, i8** %p36, align 8
  %incdec.ptr52 = getelementptr inbounds i8, i8* %45, i32 -1
  store i8* %incdec.ptr52, i8** %p36, align 8
  br label %while.cond.45

while.end.53:                                     ; preds = %while.cond.45
  %46 = load i64, i64* %best_above, align 8
  %dec = add nsw i64 %46, -1
  store i64 %dec, i64* %best_above, align 8
  br label %while.cond.41

while.end.54:                                     ; preds = %while.cond.41
  %47 = load i64, i64* %best_above, align 8
  store i64 %47, i64* %i, align 8
  %48 = load i8*, i8** %p36, align 8
  %49 = load i64, i64* %string.addr, align 8
  %call55 = call i8* @SDATA(i64 %49)
  %sub.ptr.lhs.cast56 = ptrtoint i8* %48 to i64
  %sub.ptr.rhs.cast57 = ptrtoint i8* %call55 to i64
  %sub.ptr.sub58 = sub i64 %sub.ptr.lhs.cast56, %sub.ptr.rhs.cast57
  store i64 %sub.ptr.sub58, i64* %i_byte, align 8
  br label %if.end.59

if.end.59:                                        ; preds = %while.end.54, %while.end
  %50 = load i64, i64* %i_byte, align 8
  store i64 %50, i64* @string_char_byte_cache_bytepos, align 8
  %51 = load i64, i64* %i, align 8
  store i64 %51, i64* @string_char_byte_cache_charpos, align 8
  %52 = load i64, i64* %string.addr, align 8
  store i64 %52, i64* @string_char_byte_cache_string, align 8
  %53 = load i64, i64* %i, align 8
  store i64 %53, i64* %retval
  br label %return

return:                                           ; preds = %if.end.59, %if.then
  %54 = load i64, i64* %retval
  ret i64 %54
}

; Function Attrs: nounwind uwtable
define i64 @string_to_multibyte(i64 %string) #1 {
entry:
  %retval = alloca i64, align 8
  %string.addr = alloca i64, align 8
  %buf = alloca i8*, align 8
  %nbytes = alloca i64, align 8
  %ret = alloca i64, align 8
  %sa_avail = alloca i64, align 8
  %sa_count = alloca i64, align 8
  %sa_must_free = alloca i8, align 1
  store i64 %string, i64* %string.addr, align 8
  store i64 16384, i64* %sa_avail, align 8
  %call = call i64 @SPECPDL_INDEX()
  store i64 %call, i64* %sa_count, align 8
  store i8 0, i8* %sa_must_free, align 1
  %0 = load i64, i64* %string.addr, align 8
  %call1 = call zeroext i1 @STRING_MULTIBYTE(i64 %0)
  br i1 %call1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i64, i64* %string.addr, align 8
  store i64 %1, i64* %retval
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i64, i64* %string.addr, align 8
  %call2 = call i8* @SDATA(i64 %2)
  %3 = load i64, i64* %string.addr, align 8
  %call3 = call i64 @SBYTES(i64 %3)
  %call4 = call i64 @count_size_as_multibyte(i8* %call2, i64 %call3)
  store i64 %call4, i64* %nbytes, align 8
  %4 = load i64, i64* %nbytes, align 8
  %5 = load i64, i64* %string.addr, align 8
  %call5 = call i64 @SBYTES(i64 %5)
  %cmp = icmp eq i64 %4, %call5
  br i1 %cmp, label %if.then.6, label %if.end.9

if.then.6:                                        ; preds = %if.end
  %6 = load i64, i64* %string.addr, align 8
  %call7 = call i8* @SSDATA(i64 %6)
  %7 = load i64, i64* %nbytes, align 8
  %8 = load i64, i64* %nbytes, align 8
  %call8 = call i64 @make_multibyte_string(i8* %call7, i64 %7, i64 %8)
  store i64 %call8, i64* %retval
  br label %return

if.end.9:                                         ; preds = %if.end
  %9 = load i64, i64* %nbytes, align 8
  %10 = load i64, i64* %sa_avail, align 8
  %cmp10 = icmp sle i64 %9, %10
  br i1 %cmp10, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.9
  %11 = load i64, i64* %nbytes, align 8
  %12 = load i64, i64* %sa_avail, align 8
  %sub = sub nsw i64 %12, %11
  store i64 %sub, i64* %sa_avail, align 8
  %13 = load i64, i64* %nbytes, align 8
  %14 = alloca i8, i64 %13
  br label %cond.end

cond.false:                                       ; preds = %if.end.9
  store i8 1, i8* %sa_must_free, align 1
  %15 = load i64, i64* %nbytes, align 8
  %call11 = call i8* @record_xmalloc(i64 %15)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %14, %cond.true ], [ %call11, %cond.false ]
  store i8* %cond, i8** %buf, align 8
  %16 = load i8*, i8** %buf, align 8
  %17 = load i64, i64* %string.addr, align 8
  %call12 = call i8* @SDATA(i64 %17)
  %18 = load i64, i64* %string.addr, align 8
  %call13 = call i64 @SBYTES(i64 %18)
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %16, i8* %call12, i64 %call13, i32 1, i1 false)
  %19 = load i8*, i8** %buf, align 8
  %20 = load i64, i64* %nbytes, align 8
  %21 = load i64, i64* %string.addr, align 8
  %call14 = call i64 @SBYTES(i64 %21)
  %call15 = call i64 @str_to_multibyte(i8* %19, i64 %20, i64 %call14)
  %22 = load i8*, i8** %buf, align 8
  %23 = load i64, i64* %string.addr, align 8
  %call16 = call i64 @SCHARS(i64 %23)
  %24 = load i64, i64* %nbytes, align 8
  %call17 = call i64 @make_multibyte_string(i8* %22, i64 %call16, i64 %24)
  store i64 %call17, i64* %ret, align 8
  br label %do.body

do.body:                                          ; preds = %cond.end
  %25 = load i8, i8* %sa_must_free, align 1
  %tobool = trunc i8 %25 to i1
  br i1 %tobool, label %if.then.18, label %if.end.21

if.then.18:                                       ; preds = %do.body
  store i8 0, i8* %sa_must_free, align 1
  %26 = load i64, i64* %sa_count, align 8
  %call19 = call i64 @builtin_lisp_symbol(i32 0)
  %call20 = call i64 @unbind_to(i64 %26, i64 %call19)
  br label %if.end.21

if.end.21:                                        ; preds = %if.then.18, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end.21
  %27 = load i64, i64* %ret, align 8
  store i64 %27, i64* %retval
  br label %return

return:                                           ; preds = %do.end, %if.then.6, %if.then
  %28 = load i64, i64* %retval
  ret i64 %28
}

declare i64 @SPECPDL_INDEX() #2

declare i64 @count_size_as_multibyte(i8*, i64) #2

declare i64 @make_multibyte_string(i8*, i64, i64) #2

declare i8* @record_xmalloc(i64) #2

declare i64 @str_to_multibyte(i8*, i64, i64) #2

declare i64 @unbind_to(i64, i64) #2

; Function Attrs: nounwind uwtable
define i64 @string_make_unibyte(i64 %string) #1 {
entry:
  %retval = alloca i64, align 8
  %string.addr = alloca i64, align 8
  %nchars = alloca i64, align 8
  %buf = alloca i8*, align 8
  %ret = alloca i64, align 8
  %sa_avail = alloca i64, align 8
  %sa_count = alloca i64, align 8
  %sa_must_free = alloca i8, align 1
  store i64 %string, i64* %string.addr, align 8
  store i64 16384, i64* %sa_avail, align 8
  %call = call i64 @SPECPDL_INDEX()
  store i64 %call, i64* %sa_count, align 8
  store i8 0, i8* %sa_must_free, align 1
  %0 = load i64, i64* %string.addr, align 8
  %call1 = call zeroext i1 @STRING_MULTIBYTE(i64 %0)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load i64, i64* %string.addr, align 8
  store i64 %1, i64* %retval
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i64, i64* %string.addr, align 8
  %call2 = call i64 @SCHARS(i64 %2)
  store i64 %call2, i64* %nchars, align 8
  %3 = load i64, i64* %nchars, align 8
  %4 = load i64, i64* %sa_avail, align 8
  %cmp = icmp sle i64 %3, %4
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %5 = load i64, i64* %nchars, align 8
  %6 = load i64, i64* %sa_avail, align 8
  %sub = sub nsw i64 %6, %5
  store i64 %sub, i64* %sa_avail, align 8
  %7 = load i64, i64* %nchars, align 8
  %8 = alloca i8, i64 %7
  br label %cond.end

cond.false:                                       ; preds = %if.end
  store i8 1, i8* %sa_must_free, align 1
  %9 = load i64, i64* %nchars, align 8
  %call3 = call i8* @record_xmalloc(i64 %9)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %8, %cond.true ], [ %call3, %cond.false ]
  store i8* %cond, i8** %buf, align 8
  %10 = load i64, i64* %string.addr, align 8
  %call4 = call i8* @SDATA(i64 %10)
  %11 = load i8*, i8** %buf, align 8
  %12 = load i64, i64* %string.addr, align 8
  %call5 = call i64 @SBYTES(i64 %12)
  %call6 = call i64 @copy_text(i8* %call4, i8* %11, i64 %call5, i1 zeroext true, i1 zeroext false)
  %13 = load i8*, i8** %buf, align 8
  %14 = load i64, i64* %nchars, align 8
  %call7 = call i64 @make_unibyte_string(i8* %13, i64 %14)
  store i64 %call7, i64* %ret, align 8
  br label %do.body

do.body:                                          ; preds = %cond.end
  %15 = load i8, i8* %sa_must_free, align 1
  %tobool = trunc i8 %15 to i1
  br i1 %tobool, label %if.then.8, label %if.end.11

if.then.8:                                        ; preds = %do.body
  store i8 0, i8* %sa_must_free, align 1
  %16 = load i64, i64* %sa_count, align 8
  %call9 = call i64 @builtin_lisp_symbol(i32 0)
  %call10 = call i64 @unbind_to(i64 %16, i64 %call9)
  br label %if.end.11

if.end.11:                                        ; preds = %if.then.8, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end.11
  %17 = load i64, i64* %ret, align 8
  store i64 %17, i64* %retval
  br label %return

return:                                           ; preds = %do.end, %if.then
  %18 = load i64, i64* %retval
  ret i64 %18
}

declare i64 @copy_text(i8*, i8*, i64, i1 zeroext, i1 zeroext) #2

declare i64 @make_unibyte_string(i8*, i64) #2

; Function Attrs: nounwind uwtable
define i64 @Fstring_make_multibyte(i64 %string) #1 {
entry:
  %string.addr = alloca i64, align 8
  store i64 %string, i64* %string.addr, align 8
  %0 = load i64, i64* %string.addr, align 8
  call void @CHECK_STRING(i64 %0)
  %1 = load i64, i64* %string.addr, align 8
  %call = call i64 @string_make_multibyte(i64 %1)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define internal i64 @string_make_multibyte(i64 %string) #1 {
entry:
  %retval = alloca i64, align 8
  %string.addr = alloca i64, align 8
  %buf = alloca i8*, align 8
  %nbytes = alloca i64, align 8
  %ret = alloca i64, align 8
  %sa_avail = alloca i64, align 8
  %sa_count = alloca i64, align 8
  %sa_must_free = alloca i8, align 1
  store i64 %string, i64* %string.addr, align 8
  store i64 16384, i64* %sa_avail, align 8
  %call = call i64 @SPECPDL_INDEX()
  store i64 %call, i64* %sa_count, align 8
  store i8 0, i8* %sa_must_free, align 1
  %0 = load i64, i64* %string.addr, align 8
  %call1 = call zeroext i1 @STRING_MULTIBYTE(i64 %0)
  br i1 %call1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i64, i64* %string.addr, align 8
  store i64 %1, i64* %retval
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i64, i64* %string.addr, align 8
  %call2 = call i8* @SDATA(i64 %2)
  %3 = load i64, i64* %string.addr, align 8
  %call3 = call i64 @SCHARS(i64 %3)
  %call4 = call i64 @count_size_as_multibyte(i8* %call2, i64 %call3)
  store i64 %call4, i64* %nbytes, align 8
  %4 = load i64, i64* %nbytes, align 8
  %5 = load i64, i64* %string.addr, align 8
  %call5 = call i64 @SBYTES(i64 %5)
  %cmp = icmp eq i64 %4, %call5
  br i1 %cmp, label %if.then.6, label %if.end.7

if.then.6:                                        ; preds = %if.end
  %6 = load i64, i64* %string.addr, align 8
  store i64 %6, i64* %retval
  br label %return

if.end.7:                                         ; preds = %if.end
  %7 = load i64, i64* %nbytes, align 8
  %8 = load i64, i64* %sa_avail, align 8
  %cmp8 = icmp sle i64 %7, %8
  br i1 %cmp8, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.7
  %9 = load i64, i64* %nbytes, align 8
  %10 = load i64, i64* %sa_avail, align 8
  %sub = sub nsw i64 %10, %9
  store i64 %sub, i64* %sa_avail, align 8
  %11 = load i64, i64* %nbytes, align 8
  %12 = alloca i8, i64 %11
  br label %cond.end

cond.false:                                       ; preds = %if.end.7
  store i8 1, i8* %sa_must_free, align 1
  %13 = load i64, i64* %nbytes, align 8
  %call9 = call i8* @record_xmalloc(i64 %13)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %12, %cond.true ], [ %call9, %cond.false ]
  store i8* %cond, i8** %buf, align 8
  %14 = load i64, i64* %string.addr, align 8
  %call10 = call i8* @SDATA(i64 %14)
  %15 = load i8*, i8** %buf, align 8
  %16 = load i64, i64* %string.addr, align 8
  %call11 = call i64 @SBYTES(i64 %16)
  %call12 = call i64 @copy_text(i8* %call10, i8* %15, i64 %call11, i1 zeroext false, i1 zeroext true)
  %17 = load i8*, i8** %buf, align 8
  %18 = load i64, i64* %string.addr, align 8
  %call13 = call i64 @SCHARS(i64 %18)
  %19 = load i64, i64* %nbytes, align 8
  %call14 = call i64 @make_multibyte_string(i8* %17, i64 %call13, i64 %19)
  store i64 %call14, i64* %ret, align 8
  br label %do.body

do.body:                                          ; preds = %cond.end
  %20 = load i8, i8* %sa_must_free, align 1
  %tobool = trunc i8 %20 to i1
  br i1 %tobool, label %if.then.15, label %if.end.18

if.then.15:                                       ; preds = %do.body
  store i8 0, i8* %sa_must_free, align 1
  %21 = load i64, i64* %sa_count, align 8
  %call16 = call i64 @builtin_lisp_symbol(i32 0)
  %call17 = call i64 @unbind_to(i64 %21, i64 %call16)
  br label %if.end.18

if.end.18:                                        ; preds = %if.then.15, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end.18
  %22 = load i64, i64* %ret, align 8
  store i64 %22, i64* %retval
  br label %return

return:                                           ; preds = %do.end, %if.then.6, %if.then
  %23 = load i64, i64* %retval
  ret i64 %23
}

; Function Attrs: nounwind uwtable
define i64 @Fstring_make_unibyte(i64 %string) #1 {
entry:
  %string.addr = alloca i64, align 8
  store i64 %string, i64* %string.addr, align 8
  %0 = load i64, i64* %string.addr, align 8
  call void @CHECK_STRING(i64 %0)
  %1 = load i64, i64* %string.addr, align 8
  %call = call i64 @string_make_unibyte(i64 %1)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define i64 @Fstring_as_unibyte(i64 %string) #1 {
entry:
  %string.addr = alloca i64, align 8
  %str = alloca i8*, align 8
  %bytes = alloca i64, align 8
  store i64 %string, i64* %string.addr, align 8
  %0 = load i64, i64* %string.addr, align 8
  call void @CHECK_STRING(i64 %0)
  %1 = load i64, i64* %string.addr, align 8
  %call = call zeroext i1 @STRING_MULTIBYTE(i64 %1)
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i64, i64* %string.addr, align 8
  %call1 = call noalias i8* @xlispstrdup(i64 %2)
  store i8* %call1, i8** %str, align 8
  %3 = load i8*, i8** %str, align 8
  %4 = load i64, i64* %string.addr, align 8
  %call2 = call i64 @SBYTES(i64 %4)
  %call3 = call i64 @str_as_unibyte(i8* %3, i64 %call2)
  store i64 %call3, i64* %bytes, align 8
  %5 = load i8*, i8** %str, align 8
  %6 = load i64, i64* %bytes, align 8
  %call4 = call i64 @make_unibyte_string(i8* %5, i64 %6)
  store i64 %call4, i64* %string.addr, align 8
  %7 = load i8*, i8** %str, align 8
  call void @xfree(i8* %7)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %8 = load i64, i64* %string.addr, align 8
  ret i64 %8
}

declare noalias i8* @xlispstrdup(i64) #2

declare i64 @str_as_unibyte(i8*, i64) #2

declare void @xfree(i8*) #2

; Function Attrs: nounwind uwtable
define i64 @Fstring_as_multibyte(i64 %string) #1 {
entry:
  %string.addr = alloca i64, align 8
  %new_string = alloca i64, align 8
  %nchars = alloca i64, align 8
  %nbytes = alloca i64, align 8
  store i64 %string, i64* %string.addr, align 8
  %0 = load i64, i64* %string.addr, align 8
  call void @CHECK_STRING(i64 %0)
  %1 = load i64, i64* %string.addr, align 8
  %call = call zeroext i1 @STRING_MULTIBYTE(i64 %1)
  br i1 %call, label %if.end.12, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i64, i64* %string.addr, align 8
  %call1 = call i8* @SDATA(i64 %2)
  %3 = load i64, i64* %string.addr, align 8
  %call2 = call i64 @SBYTES(i64 %3)
  call void @parse_str_as_multibyte(i8* %call1, i64 %call2, i64* %nchars, i64* %nbytes)
  %4 = load i64, i64* %nchars, align 8
  %5 = load i64, i64* %nbytes, align 8
  %call3 = call i64 @make_uninit_multibyte_string(i64 %4, i64 %5)
  store i64 %call3, i64* %new_string, align 8
  %6 = load i64, i64* %new_string, align 8
  %call4 = call i8* @SDATA(i64 %6)
  %7 = load i64, i64* %string.addr, align 8
  %call5 = call i8* @SDATA(i64 %7)
  %8 = load i64, i64* %string.addr, align 8
  %call6 = call i64 @SBYTES(i64 %8)
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %call4, i8* %call5, i64 %call6, i32 1, i1 false)
  %9 = load i64, i64* %nbytes, align 8
  %10 = load i64, i64* %string.addr, align 8
  %call7 = call i64 @SBYTES(i64 %10)
  %cmp = icmp ne i64 %9, %call7
  br i1 %cmp, label %if.then.8, label %if.end

if.then.8:                                        ; preds = %if.then
  %11 = load i64, i64* %new_string, align 8
  %call9 = call i8* @SDATA(i64 %11)
  %12 = load i64, i64* %nbytes, align 8
  %13 = load i64, i64* %string.addr, align 8
  %call10 = call i64 @SBYTES(i64 %13)
  %call11 = call i64 @str_as_multibyte(i8* %call9, i64 %12, i64 %call10, i64* null)
  br label %if.end

if.end:                                           ; preds = %if.then.8, %if.then
  %14 = load i64, i64* %new_string, align 8
  store i64 %14, i64* %string.addr, align 8
  %15 = load i64, i64* %string.addr, align 8
  call void @set_string_intervals(i64 %15, %struct.interval* null)
  br label %if.end.12

if.end.12:                                        ; preds = %if.end, %entry
  %16 = load i64, i64* %string.addr, align 8
  ret i64 %16
}

declare void @parse_str_as_multibyte(i8*, i64, i64*, i64*) #2

declare i64 @make_uninit_multibyte_string(i64, i64) #2

declare i64 @str_as_multibyte(i8*, i64, i64, i64*) #2

declare void @set_string_intervals(i64, %struct.interval*) #2

; Function Attrs: nounwind uwtable
define i64 @Fstring_to_multibyte(i64 %string) #1 {
entry:
  %string.addr = alloca i64, align 8
  store i64 %string, i64* %string.addr, align 8
  %0 = load i64, i64* %string.addr, align 8
  call void @CHECK_STRING(i64 %0)
  %1 = load i64, i64* %string.addr, align 8
  %call = call i64 @string_to_multibyte(i64 %1)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define i64 @Fstring_to_unibyte(i64 %string) #1 {
entry:
  %string.addr = alloca i64, align 8
  %chars = alloca i64, align 8
  %str = alloca i8*, align 8
  %converted = alloca i64, align 8
  store i64 %string, i64* %string.addr, align 8
  %0 = load i64, i64* %string.addr, align 8
  call void @CHECK_STRING(i64 %0)
  %1 = load i64, i64* %string.addr, align 8
  %call = call zeroext i1 @STRING_MULTIBYTE(i64 %1)
  br i1 %call, label %if.then, label %if.end.7

if.then:                                          ; preds = %entry
  %2 = load i64, i64* %string.addr, align 8
  %call1 = call i64 @SCHARS(i64 %2)
  store i64 %call1, i64* %chars, align 8
  %3 = load i64, i64* %chars, align 8
  %call2 = call noalias i8* @xmalloc(i64 %3)
  store i8* %call2, i8** %str, align 8
  %4 = load i64, i64* %string.addr, align 8
  %call3 = call i8* @SDATA(i64 %4)
  %5 = load i8*, i8** %str, align 8
  %6 = load i64, i64* %chars, align 8
  %call4 = call i64 @str_to_unibyte(i8* %call3, i8* %5, i64 %6)
  store i64 %call4, i64* %converted, align 8
  %7 = load i64, i64* %converted, align 8
  %8 = load i64, i64* %chars, align 8
  %cmp = icmp slt i64 %7, %8
  br i1 %cmp, label %if.then.5, label %if.end

if.then.5:                                        ; preds = %if.then
  %9 = load i64, i64* %converted, align 8
  call void (i8*, ...) @error(i8* getelementptr inbounds ([45 x i8], [45 x i8]* @.str.1, i32 0, i32 0), i64 %9) #8
  unreachable

if.end:                                           ; preds = %if.then
  %10 = load i8*, i8** %str, align 8
  %11 = load i64, i64* %chars, align 8
  %call6 = call i64 @make_unibyte_string(i8* %10, i64 %11)
  store i64 %call6, i64* %string.addr, align 8
  %12 = load i8*, i8** %str, align 8
  call void @xfree(i8* %12)
  br label %if.end.7

if.end.7:                                         ; preds = %if.end, %entry
  %13 = load i64, i64* %string.addr, align 8
  ret i64 %13
}

declare noalias i8* @xmalloc(i64) #2

declare i64 @str_to_unibyte(i8*, i8*, i64) #2

; Function Attrs: nounwind uwtable
define i64 @Fcopy_alist(i64 %alist) #1 {
entry:
  %retval = alloca i64, align 8
  %alist.addr = alloca i64, align 8
  %tem = alloca i64, align 8
  %car = alloca i64, align 8
  store i64 %alist, i64* %alist.addr, align 8
  %0 = load i64, i64* %alist.addr, align 8
  call void @CHECK_LIST(i64 %0)
  %1 = load i64, i64* %alist.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %1, %call
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i64, i64* %alist.addr, align 8
  store i64 %2, i64* %retval
  br label %return

if.end:                                           ; preds = %entry
  %call1 = call i64 @concat(i64 1, i64* %alist.addr, i32 3, i1 zeroext false)
  store i64 %call1, i64* %alist.addr, align 8
  %3 = load i64, i64* %alist.addr, align 8
  store i64 %3, i64* %tem, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %4 = load i64, i64* %tem, align 8
  %and = and i64 %4, 7
  %conv = trunc i64 %and to i32
  %cmp2 = icmp eq i32 %conv, 3
  br i1 %cmp2, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load i64, i64* %tem, align 8
  %sub = sub nsw i64 %5, 3
  %6 = inttoptr i64 %sub to i8*
  %7 = bitcast i8* %6 to %struct.Lisp_Cons*
  %car4 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %7, i32 0, i32 0
  %8 = load i64, i64* %car4, align 8
  store i64 %8, i64* %car, align 8
  %9 = load i64, i64* %car, align 8
  %and5 = and i64 %9, 7
  %conv6 = trunc i64 %and5 to i32
  %cmp7 = icmp eq i32 %conv6, 3
  br i1 %cmp7, label %if.then.9, label %if.end.14

if.then.9:                                        ; preds = %for.body
  %10 = load i64, i64* %tem, align 8
  %11 = load i64, i64* %car, align 8
  %sub10 = sub nsw i64 %11, 3
  %12 = inttoptr i64 %sub10 to i8*
  %13 = bitcast i8* %12 to %struct.Lisp_Cons*
  %car11 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %13, i32 0, i32 0
  %14 = load i64, i64* %car11, align 8
  %15 = load i64, i64* %car, align 8
  %sub12 = sub nsw i64 %15, 3
  %16 = inttoptr i64 %sub12 to i8*
  %17 = bitcast i8* %16 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %17, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %18 = load i64, i64* %cdr, align 8
  %call13 = call i64 @Fcons(i64 %14, i64 %18)
  call void @XSETCAR(i64 %10, i64 %call13)
  br label %if.end.14

if.end.14:                                        ; preds = %if.then.9, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end.14
  %19 = load i64, i64* %tem, align 8
  %sub15 = sub nsw i64 %19, 3
  %20 = inttoptr i64 %sub15 to i8*
  %21 = bitcast i8* %20 to %struct.Lisp_Cons*
  %u16 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %21, i32 0, i32 1
  %cdr17 = bitcast %union.anon* %u16 to i64*
  %22 = load i64, i64* %cdr17, align 8
  store i64 %22, i64* %tem, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %23 = load i64, i64* %alist.addr, align 8
  store i64 %23, i64* %retval
  br label %return

return:                                           ; preds = %for.end, %if.then
  %24 = load i64, i64* %retval
  ret i64 %24
}

declare void @CHECK_LIST(i64) #2

declare void @XSETCAR(i64, i64) #2

declare i64 @Fcons(i64, i64) #2

; Function Attrs: noreturn
declare void @args_out_of_range_3(i64, i64, i64) #3

; Function Attrs: nounwind uwtable
define i64 @Fsubstring(i64 %string, i64 %from, i64 %to) #1 {
entry:
  %string.addr = alloca i64, align 8
  %from.addr = alloca i64, align 8
  %to.addr = alloca i64, align 8
  %res = alloca i64, align 8
  %size = alloca i64, align 8
  %ifrom = alloca i64, align 8
  %ito = alloca i64, align 8
  %from_byte = alloca i64, align 8
  %to_byte = alloca i64, align 8
  store i64 %string, i64* %string.addr, align 8
  store i64 %from, i64* %from.addr, align 8
  store i64 %to, i64* %to.addr, align 8
  %0 = load i64, i64* %string.addr, align 8
  %call = call i64 @CHECK_VECTOR_OR_STRING(i64 %0)
  store i64 %call, i64* %size, align 8
  %1 = load i64, i64* %string.addr, align 8
  %2 = load i64, i64* %from.addr, align 8
  %3 = load i64, i64* %to.addr, align 8
  %4 = load i64, i64* %size, align 8
  call void @validate_subarray(i64 %1, i64 %2, i64 %3, i64 %4, i64* %ifrom, i64* %ito)
  %5 = load i64, i64* %string.addr, align 8
  %call1 = call zeroext i1 @STRINGP(i64 %5)
  br i1 %call1, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %6 = load i64, i64* %ifrom, align 8
  %tobool = icmp ne i64 %6, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then
  br label %cond.end

cond.false:                                       ; preds = %if.then
  %7 = load i64, i64* %string.addr, align 8
  %8 = load i64, i64* %ifrom, align 8
  %call2 = call i64 @string_char_to_byte(i64 %7, i64 %8)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ 0, %cond.true ], [ %call2, %cond.false ]
  store i64 %cond, i64* %from_byte, align 8
  %9 = load i64, i64* %ito, align 8
  %10 = load i64, i64* %size, align 8
  %cmp = icmp eq i64 %9, %10
  br i1 %cmp, label %cond.true.3, label %cond.false.5

cond.true.3:                                      ; preds = %cond.end
  %11 = load i64, i64* %string.addr, align 8
  %call4 = call i64 @SBYTES(i64 %11)
  br label %cond.end.7

cond.false.5:                                     ; preds = %cond.end
  %12 = load i64, i64* %string.addr, align 8
  %13 = load i64, i64* %ito, align 8
  %call6 = call i64 @string_char_to_byte(i64 %12, i64 %13)
  br label %cond.end.7

cond.end.7:                                       ; preds = %cond.false.5, %cond.true.3
  %cond8 = phi i64 [ %call4, %cond.true.3 ], [ %call6, %cond.false.5 ]
  store i64 %cond8, i64* %to_byte, align 8
  %14 = load i64, i64* %string.addr, align 8
  %call9 = call i8* @SSDATA(i64 %14)
  %15 = load i64, i64* %from_byte, align 8
  %add.ptr = getelementptr inbounds i8, i8* %call9, i64 %15
  %16 = load i64, i64* %ito, align 8
  %17 = load i64, i64* %ifrom, align 8
  %sub = sub nsw i64 %16, %17
  %18 = load i64, i64* %to_byte, align 8
  %19 = load i64, i64* %from_byte, align 8
  %sub10 = sub nsw i64 %18, %19
  %20 = load i64, i64* %string.addr, align 8
  %call11 = call zeroext i1 @STRING_MULTIBYTE(i64 %20)
  %call12 = call i64 @make_specified_string(i8* %add.ptr, i64 %sub, i64 %sub10, i1 zeroext %call11)
  store i64 %call12, i64* %res, align 8
  %21 = load i64, i64* %ifrom, align 8
  %shl = shl i64 %21, 2
  %add = add i64 %shl, 2
  %22 = load i64, i64* %ito, align 8
  %shl13 = shl i64 %22, 2
  %add14 = add i64 %shl13, 2
  %23 = load i64, i64* %string.addr, align 8
  %24 = load i64, i64* %res, align 8
  %call15 = call i64 @builtin_lisp_symbol(i32 0)
  %call16 = call i64 @copy_text_properties(i64 %add, i64 %add14, i64 %23, i64 2, i64 %24, i64 %call15)
  br label %if.end

if.else:                                          ; preds = %entry
  %25 = load i64, i64* %ito, align 8
  %26 = load i64, i64* %ifrom, align 8
  %sub17 = sub nsw i64 %25, %26
  %27 = load i64, i64* %string.addr, align 8
  %28 = load i64, i64* %ifrom, align 8
  %call18 = call i64* @aref_addr(i64 %27, i64 %28)
  %call19 = call i64 @Fvector(i64 %sub17, i64* %call18)
  store i64 %call19, i64* %res, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %cond.end.7
  %29 = load i64, i64* %res, align 8
  ret i64 %29
}

declare i64 @CHECK_VECTOR_OR_STRING(i64) #2

declare i64 @make_specified_string(i8*, i64, i64, i1 zeroext) #2

declare i64 @copy_text_properties(i64, i64, i64, i64, i64, i64) #2

declare i64 @Fvector(i64, i64*) #2

declare i64* @aref_addr(i64, i64) #2

; Function Attrs: nounwind uwtable
define i64 @Fsubstring_no_properties(i64 %string, i64 %from, i64 %to) #1 {
entry:
  %string.addr = alloca i64, align 8
  %from.addr = alloca i64, align 8
  %to.addr = alloca i64, align 8
  %from_char = alloca i64, align 8
  %to_char = alloca i64, align 8
  %from_byte = alloca i64, align 8
  %to_byte = alloca i64, align 8
  %size = alloca i64, align 8
  store i64 %string, i64* %string.addr, align 8
  store i64 %from, i64* %from.addr, align 8
  store i64 %to, i64* %to.addr, align 8
  %0 = load i64, i64* %string.addr, align 8
  call void @CHECK_STRING(i64 %0)
  %1 = load i64, i64* %string.addr, align 8
  %call = call i64 @SCHARS(i64 %1)
  store i64 %call, i64* %size, align 8
  %2 = load i64, i64* %string.addr, align 8
  %3 = load i64, i64* %from.addr, align 8
  %4 = load i64, i64* %to.addr, align 8
  %5 = load i64, i64* %size, align 8
  call void @validate_subarray(i64 %2, i64 %3, i64 %4, i64 %5, i64* %from_char, i64* %to_char)
  %6 = load i64, i64* %from_char, align 8
  %tobool = icmp ne i64 %6, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %7 = load i64, i64* %string.addr, align 8
  %8 = load i64, i64* %from_char, align 8
  %call1 = call i64 @string_char_to_byte(i64 %7, i64 %8)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ 0, %cond.true ], [ %call1, %cond.false ]
  store i64 %cond, i64* %from_byte, align 8
  %9 = load i64, i64* %to_char, align 8
  %10 = load i64, i64* %size, align 8
  %cmp = icmp eq i64 %9, %10
  br i1 %cmp, label %cond.true.2, label %cond.false.4

cond.true.2:                                      ; preds = %cond.end
  %11 = load i64, i64* %string.addr, align 8
  %call3 = call i64 @SBYTES(i64 %11)
  br label %cond.end.6

cond.false.4:                                     ; preds = %cond.end
  %12 = load i64, i64* %string.addr, align 8
  %13 = load i64, i64* %to_char, align 8
  %call5 = call i64 @string_char_to_byte(i64 %12, i64 %13)
  br label %cond.end.6

cond.end.6:                                       ; preds = %cond.false.4, %cond.true.2
  %cond7 = phi i64 [ %call3, %cond.true.2 ], [ %call5, %cond.false.4 ]
  store i64 %cond7, i64* %to_byte, align 8
  %14 = load i64, i64* %string.addr, align 8
  %call8 = call i8* @SSDATA(i64 %14)
  %15 = load i64, i64* %from_byte, align 8
  %add.ptr = getelementptr inbounds i8, i8* %call8, i64 %15
  %16 = load i64, i64* %to_char, align 8
  %17 = load i64, i64* %from_char, align 8
  %sub = sub nsw i64 %16, %17
  %18 = load i64, i64* %to_byte, align 8
  %19 = load i64, i64* %from_byte, align 8
  %sub9 = sub nsw i64 %18, %19
  %20 = load i64, i64* %string.addr, align 8
  %call10 = call zeroext i1 @STRING_MULTIBYTE(i64 %20)
  %call11 = call i64 @make_specified_string(i8* %add.ptr, i64 %sub, i64 %sub9, i1 zeroext %call10)
  ret i64 %call11
}

; Function Attrs: nounwind uwtable
define i64 @substring_both(i64 %string, i64 %from, i64 %from_byte, i64 %to, i64 %to_byte) #1 {
entry:
  %string.addr = alloca i64, align 8
  %from.addr = alloca i64, align 8
  %from_byte.addr = alloca i64, align 8
  %to.addr = alloca i64, align 8
  %to_byte.addr = alloca i64, align 8
  %res = alloca i64, align 8
  %size = alloca i64, align 8
  store i64 %string, i64* %string.addr, align 8
  store i64 %from, i64* %from.addr, align 8
  store i64 %from_byte, i64* %from_byte.addr, align 8
  store i64 %to, i64* %to.addr, align 8
  store i64 %to_byte, i64* %to_byte.addr, align 8
  %0 = load i64, i64* %string.addr, align 8
  %call = call i64 @CHECK_VECTOR_OR_STRING(i64 %0)
  store i64 %call, i64* %size, align 8
  %1 = load i64, i64* %from.addr, align 8
  %cmp = icmp sle i64 0, %1
  br i1 %cmp, label %land.lhs.true, label %if.then

land.lhs.true:                                    ; preds = %entry
  %2 = load i64, i64* %from.addr, align 8
  %3 = load i64, i64* %to.addr, align 8
  %cmp1 = icmp sle i64 %2, %3
  br i1 %cmp1, label %land.lhs.true.2, label %if.then

land.lhs.true.2:                                  ; preds = %land.lhs.true
  %4 = load i64, i64* %to.addr, align 8
  %5 = load i64, i64* %size, align 8
  %cmp3 = icmp sle i64 %4, %5
  br i1 %cmp3, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true.2, %land.lhs.true, %entry
  %6 = load i64, i64* %string.addr, align 8
  %7 = load i64, i64* %from.addr, align 8
  %shl = shl i64 %7, 2
  %add = add i64 %shl, 2
  %8 = load i64, i64* %to.addr, align 8
  %shl4 = shl i64 %8, 2
  %add5 = add i64 %shl4, 2
  call void @args_out_of_range_3(i64 %6, i64 %add, i64 %add5) #8
  unreachable

if.end:                                           ; preds = %land.lhs.true.2
  %9 = load i64, i64* %string.addr, align 8
  %call6 = call zeroext i1 @STRINGP(i64 %9)
  br i1 %call6, label %if.then.7, label %if.else

if.then.7:                                        ; preds = %if.end
  %10 = load i64, i64* %string.addr, align 8
  %call8 = call i8* @SSDATA(i64 %10)
  %11 = load i64, i64* %from_byte.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %call8, i64 %11
  %12 = load i64, i64* %to.addr, align 8
  %13 = load i64, i64* %from.addr, align 8
  %sub = sub nsw i64 %12, %13
  %14 = load i64, i64* %to_byte.addr, align 8
  %15 = load i64, i64* %from_byte.addr, align 8
  %sub9 = sub nsw i64 %14, %15
  %16 = load i64, i64* %string.addr, align 8
  %call10 = call zeroext i1 @STRING_MULTIBYTE(i64 %16)
  %call11 = call i64 @make_specified_string(i8* %add.ptr, i64 %sub, i64 %sub9, i1 zeroext %call10)
  store i64 %call11, i64* %res, align 8
  %17 = load i64, i64* %from.addr, align 8
  %shl12 = shl i64 %17, 2
  %add13 = add i64 %shl12, 2
  %18 = load i64, i64* %to.addr, align 8
  %shl14 = shl i64 %18, 2
  %add15 = add i64 %shl14, 2
  %19 = load i64, i64* %string.addr, align 8
  %20 = load i64, i64* %res, align 8
  %call16 = call i64 @builtin_lisp_symbol(i32 0)
  %call17 = call i64 @copy_text_properties(i64 %add13, i64 %add15, i64 %19, i64 2, i64 %20, i64 %call16)
  br label %if.end.21

if.else:                                          ; preds = %if.end
  %21 = load i64, i64* %to.addr, align 8
  %22 = load i64, i64* %from.addr, align 8
  %sub18 = sub nsw i64 %21, %22
  %23 = load i64, i64* %string.addr, align 8
  %24 = load i64, i64* %from.addr, align 8
  %call19 = call i64* @aref_addr(i64 %23, i64 %24)
  %call20 = call i64 @Fvector(i64 %sub18, i64* %call19)
  store i64 %call20, i64* %res, align 8
  br label %if.end.21

if.end.21:                                        ; preds = %if.else, %if.then.7
  %25 = load i64, i64* %res, align 8
  ret i64 %25
}

; Function Attrs: nounwind uwtable
define i64 @Fnthcdr(i64 %n, i64 %list) #1 {
entry:
  %n.addr = alloca i64, align 8
  %list.addr = alloca i64, align 8
  %i = alloca i64, align 8
  %num = alloca i64, align 8
  store i64 %n, i64* %n.addr, align 8
  store i64 %list, i64* %list.addr, align 8
  %0 = load i64, i64* %n.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %and1 = and i32 %conv, -5
  %cmp = icmp eq i32 %and1, 2
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = call i64 @builtin_lisp_symbol(i32 559)
  %1 = load i64, i64* %n.addr, align 8
  %2 = call i64 @wrong_type_argument(i64 %call, i64 %1) #8
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %3, %cond.true
  %4 = load i64, i64* %n.addr, align 8
  %shr = ashr i64 %4, 2
  store i64 %shr, i64* %num, align 8
  store i64 0, i64* %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %5 = load i64, i64* %i, align 8
  %6 = load i64, i64* %num, align 8
  %cmp3 = icmp slt i64 %5, %6
  br i1 %cmp3, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %7 = load i64, i64* %list.addr, align 8
  %call5 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp6 = icmp eq i64 %7, %call5
  %lnot = xor i1 %cmp6, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %8 = phi i1 [ false, %for.cond ], [ %lnot, %land.rhs ]
  br i1 %8, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  br label %do.body

do.body:                                          ; preds = %for.body
  %9 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call8 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp9 = icmp eq i64 %9, %call8
  br i1 %cmp9, label %if.else, label %land.lhs.true

land.lhs.true:                                    ; preds = %do.body
  %10 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  %call11 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp12 = icmp eq i64 %10, %call11
  br i1 %cmp12, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  call void @process_quit_flag()
  br label %if.end.15

if.else:                                          ; preds = %land.lhs.true, %do.body
  %11 = load volatile i8, i8* @pending_signals, align 1
  %tobool = trunc i8 %11 to i1
  br i1 %tobool, label %if.then.14, label %if.end

if.then.14:                                       ; preds = %if.else
  call void @process_pending_signals()
  br label %if.end

if.end:                                           ; preds = %if.then.14, %if.else
  br label %if.end.15

if.end.15:                                        ; preds = %if.end, %if.then
  br label %do.end

do.end:                                           ; preds = %if.end.15
  %12 = load i64, i64* %list.addr, align 8
  %and16 = and i64 %12, 7
  %conv17 = trunc i64 %and16 to i32
  %cmp18 = icmp eq i32 %conv17, 3
  br i1 %cmp18, label %cond.true.20, label %cond.false.21

cond.true.20:                                     ; preds = %do.end
  br label %cond.end.23

cond.false.21:                                    ; preds = %do.end
  %call22 = call i64 @builtin_lisp_symbol(i32 626)
  %13 = load i64, i64* %list.addr, align 8
  %14 = call i64 @wrong_type_argument(i64 %call22, i64 %13) #8
  unreachable
                                                  ; No predecessors!
  br label %cond.end.23

cond.end.23:                                      ; preds = %15, %cond.true.20
  %16 = load i64, i64* %list.addr, align 8
  %sub = sub nsw i64 %16, 3
  %17 = inttoptr i64 %sub to i8*
  %18 = bitcast i8* %17 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %18, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %19 = load i64, i64* %cdr, align 8
  store i64 %19, i64* %list.addr, align 8
  br label %for.inc

for.inc:                                          ; preds = %cond.end.23
  %20 = load i64, i64* %i, align 8
  %inc = add nsw i64 %20, 1
  store i64 %inc, i64* %i, align 8
  br label %for.cond

for.end:                                          ; preds = %land.end
  %21 = load i64, i64* %list.addr, align 8
  ret i64 %21
}

; Function Attrs: nounwind uwtable
define i64 @Fnth(i64 %n, i64 %list) #1 {
entry:
  %n.addr = alloca i64, align 8
  %list.addr = alloca i64, align 8
  store i64 %n, i64* %n.addr, align 8
  store i64 %list, i64* %list.addr, align 8
  %0 = load i64, i64* %n.addr, align 8
  %1 = load i64, i64* %list.addr, align 8
  %call = call i64 @Fnthcdr(i64 %0, i64 %1)
  %call1 = call i64 @Fcar(i64 %call)
  ret i64 %call1
}

declare i64 @Fcar(i64) #2

; Function Attrs: nounwind uwtable
define i64 @Felt(i64 %sequence, i64 %n) #1 {
entry:
  %retval = alloca i64, align 8
  %sequence.addr = alloca i64, align 8
  %n.addr = alloca i64, align 8
  store i64 %sequence, i64* %sequence.addr, align 8
  store i64 %n, i64* %n.addr, align 8
  %0 = load i64, i64* %n.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %and1 = and i32 %conv, -5
  %cmp = icmp eq i32 %and1, 2
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = call i64 @builtin_lisp_symbol(i32 559)
  %1 = load i64, i64* %n.addr, align 8
  %2 = call i64 @wrong_type_argument(i64 %call, i64 %1) #8
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %3, %cond.true
  %4 = load i64, i64* %sequence.addr, align 8
  %and3 = and i64 %4, 7
  %conv4 = trunc i64 %and3 to i32
  %cmp5 = icmp eq i32 %conv4, 3
  br i1 %cmp5, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %cond.end
  %5 = load i64, i64* %sequence.addr, align 8
  %call7 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp8 = icmp eq i64 %5, %call7
  br i1 %cmp8, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %cond.end
  %6 = load i64, i64* %n.addr, align 8
  %7 = load i64, i64* %sequence.addr, align 8
  %call10 = call i64 @Fnthcdr(i64 %6, i64 %7)
  %call11 = call i64 @Fcar(i64 %call10)
  store i64 %call11, i64* %retval
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %8 = load i64, i64* %sequence.addr, align 8
  %call12 = call i64 @builtin_lisp_symbol(i32 844)
  call void @CHECK_ARRAY(i64 %8, i64 %call12)
  %9 = load i64, i64* %sequence.addr, align 8
  %10 = load i64, i64* %n.addr, align 8
  %call13 = call i64 @Faref(i64 %9, i64 %10)
  store i64 %call13, i64* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %11 = load i64, i64* %retval
  ret i64 %11
}

declare void @CHECK_ARRAY(i64, i64) #2

declare i64 @Faref(i64, i64) #2

; Function Attrs: nounwind uwtable
define i64 @Fmember(i64 %elt, i64 %list) #1 {
entry:
  %retval = alloca i64, align 8
  %elt.addr = alloca i64, align 8
  %list.addr = alloca i64, align 8
  %tail = alloca i64, align 8
  %tem = alloca i64, align 8
  store i64 %elt, i64* %elt.addr, align 8
  store i64 %list, i64* %list.addr, align 8
  %0 = load i64, i64* %list.addr, align 8
  store i64 %0, i64* %tail, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i64, i64* %tail, align 8
  %and = and i64 %1, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i64, i64* %tail, align 8
  %and2 = and i64 %2, 7
  %conv3 = trunc i64 %and2 to i32
  %cmp4 = icmp eq i32 %conv3, 3
  br i1 %cmp4, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  br label %cond.end

cond.false:                                       ; preds = %for.body
  %call = call i64 @builtin_lisp_symbol(i32 626)
  %3 = load i64, i64* %list.addr, align 8
  %4 = call i64 @wrong_type_argument(i64 %call, i64 %3) #8
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %5, %cond.true
  %6 = load i64, i64* %tail, align 8
  %sub = sub nsw i64 %6, 3
  %7 = inttoptr i64 %sub to i8*
  %8 = bitcast i8* %7 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %8, i32 0, i32 0
  %9 = load i64, i64* %car, align 8
  store i64 %9, i64* %tem, align 8
  %10 = load i64, i64* %elt.addr, align 8
  %11 = load i64, i64* %tem, align 8
  %call6 = call i64 @Fequal(i64 %10, i64 %11)
  %call7 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp8 = icmp eq i64 %call6, %call7
  br i1 %cmp8, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  %12 = load i64, i64* %tail, align 8
  store i64 %12, i64* %retval
  br label %return

if.end:                                           ; preds = %cond.end
  br label %do.body

do.body:                                          ; preds = %if.end
  %13 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call10 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp11 = icmp eq i64 %13, %call10
  br i1 %cmp11, label %if.else, label %land.lhs.true

land.lhs.true:                                    ; preds = %do.body
  %14 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  %call13 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp14 = icmp eq i64 %14, %call13
  br i1 %cmp14, label %if.then.16, label %if.else

if.then.16:                                       ; preds = %land.lhs.true
  call void @process_quit_flag()
  br label %if.end.19

if.else:                                          ; preds = %land.lhs.true, %do.body
  %15 = load volatile i8, i8* @pending_signals, align 1
  %tobool = trunc i8 %15 to i1
  br i1 %tobool, label %if.then.17, label %if.end.18

if.then.17:                                       ; preds = %if.else
  call void @process_pending_signals()
  br label %if.end.18

if.end.18:                                        ; preds = %if.then.17, %if.else
  br label %if.end.19

if.end.19:                                        ; preds = %if.end.18, %if.then.16
  br label %do.end

do.end:                                           ; preds = %if.end.19
  br label %for.inc

for.inc:                                          ; preds = %do.end
  %16 = load i64, i64* %tail, align 8
  %sub20 = sub nsw i64 %16, 3
  %17 = inttoptr i64 %sub20 to i8*
  %18 = bitcast i8* %17 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %18, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %19 = load i64, i64* %cdr, align 8
  store i64 %19, i64* %tail, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call21 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call21, i64* %retval
  br label %return

return:                                           ; preds = %for.end, %if.then
  %20 = load i64, i64* %retval
  ret i64 %20
}

; Function Attrs: nounwind uwtable
define i64 @Fequal(i64 %o1, i64 %o2) #1 {
entry:
  %o1.addr = alloca i64, align 8
  %o2.addr = alloca i64, align 8
  store i64 %o1, i64* %o1.addr, align 8
  store i64 %o2, i64* %o2.addr, align 8
  %0 = load i64, i64* %o1.addr, align 8
  %1 = load i64, i64* %o2.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %call1 = call zeroext i1 @internal_equal(i64 %0, i64 %1, i32 0, i1 zeroext false, i64 %call)
  br i1 %call1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %call2 = call i64 @builtin_lisp_symbol(i32 901)
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call2, %cond.true ], [ %call3, %cond.false ]
  ret i64 %cond
}

; Function Attrs: nounwind uwtable
define i64 @Fmemq(i64 %elt, i64 %list) #1 {
entry:
  %elt.addr = alloca i64, align 8
  %list.addr = alloca i64, align 8
  store i64 %elt, i64* %elt.addr, align 8
  store i64 %list, i64* %list.addr, align 8
  br label %while.body

while.body:                                       ; preds = %entry, %do.end
  %0 = load i64, i64* %list.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %while.body
  %1 = load i64, i64* %list.addr, align 8
  %sub = sub nsw i64 %1, 3
  %2 = inttoptr i64 %sub to i8*
  %3 = bitcast i8* %2 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %3, i32 0, i32 0
  %4 = load i64, i64* %car, align 8
  %5 = load i64, i64* %elt.addr, align 8
  %cmp2 = icmp eq i64 %4, %5
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %while.body
  br label %while.end

if.end:                                           ; preds = %lor.lhs.false
  %6 = load i64, i64* %list.addr, align 8
  %sub4 = sub nsw i64 %6, 3
  %7 = inttoptr i64 %sub4 to i8*
  %8 = bitcast i8* %7 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %8, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %9 = load i64, i64* %cdr, align 8
  store i64 %9, i64* %list.addr, align 8
  %10 = load i64, i64* %list.addr, align 8
  %and5 = and i64 %10, 7
  %conv6 = trunc i64 %and5 to i32
  %cmp7 = icmp eq i32 %conv6, 3
  br i1 %cmp7, label %lor.lhs.false.9, label %if.then.14

lor.lhs.false.9:                                  ; preds = %if.end
  %11 = load i64, i64* %list.addr, align 8
  %sub10 = sub nsw i64 %11, 3
  %12 = inttoptr i64 %sub10 to i8*
  %13 = bitcast i8* %12 to %struct.Lisp_Cons*
  %car11 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %13, i32 0, i32 0
  %14 = load i64, i64* %car11, align 8
  %15 = load i64, i64* %elt.addr, align 8
  %cmp12 = icmp eq i64 %14, %15
  br i1 %cmp12, label %if.then.14, label %if.end.15

if.then.14:                                       ; preds = %lor.lhs.false.9, %if.end
  br label %while.end

if.end.15:                                        ; preds = %lor.lhs.false.9
  %16 = load i64, i64* %list.addr, align 8
  %sub16 = sub nsw i64 %16, 3
  %17 = inttoptr i64 %sub16 to i8*
  %18 = bitcast i8* %17 to %struct.Lisp_Cons*
  %u17 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %18, i32 0, i32 1
  %cdr18 = bitcast %union.anon* %u17 to i64*
  %19 = load i64, i64* %cdr18, align 8
  store i64 %19, i64* %list.addr, align 8
  %20 = load i64, i64* %list.addr, align 8
  %and19 = and i64 %20, 7
  %conv20 = trunc i64 %and19 to i32
  %cmp21 = icmp eq i32 %conv20, 3
  br i1 %cmp21, label %lor.lhs.false.23, label %if.then.28

lor.lhs.false.23:                                 ; preds = %if.end.15
  %21 = load i64, i64* %list.addr, align 8
  %sub24 = sub nsw i64 %21, 3
  %22 = inttoptr i64 %sub24 to i8*
  %23 = bitcast i8* %22 to %struct.Lisp_Cons*
  %car25 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %23, i32 0, i32 0
  %24 = load i64, i64* %car25, align 8
  %25 = load i64, i64* %elt.addr, align 8
  %cmp26 = icmp eq i64 %24, %25
  br i1 %cmp26, label %if.then.28, label %if.end.29

if.then.28:                                       ; preds = %lor.lhs.false.23, %if.end.15
  br label %while.end

if.end.29:                                        ; preds = %lor.lhs.false.23
  %26 = load i64, i64* %list.addr, align 8
  %sub30 = sub nsw i64 %26, 3
  %27 = inttoptr i64 %sub30 to i8*
  %28 = bitcast i8* %27 to %struct.Lisp_Cons*
  %u31 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %28, i32 0, i32 1
  %cdr32 = bitcast %union.anon* %u31 to i64*
  %29 = load i64, i64* %cdr32, align 8
  store i64 %29, i64* %list.addr, align 8
  br label %do.body

do.body:                                          ; preds = %if.end.29
  %30 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp33 = icmp eq i64 %30, %call
  br i1 %cmp33, label %if.else, label %land.lhs.true

land.lhs.true:                                    ; preds = %do.body
  %31 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  %call35 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp36 = icmp eq i64 %31, %call35
  br i1 %cmp36, label %if.then.38, label %if.else

if.then.38:                                       ; preds = %land.lhs.true
  call void @process_quit_flag()
  br label %if.end.41

if.else:                                          ; preds = %land.lhs.true, %do.body
  %32 = load volatile i8, i8* @pending_signals, align 1
  %tobool = trunc i8 %32 to i1
  br i1 %tobool, label %if.then.39, label %if.end.40

if.then.39:                                       ; preds = %if.else
  call void @process_pending_signals()
  br label %if.end.40

if.end.40:                                        ; preds = %if.then.39, %if.else
  br label %if.end.41

if.end.41:                                        ; preds = %if.end.40, %if.then.38
  br label %do.end

do.end:                                           ; preds = %if.end.41
  br label %while.body

while.end:                                        ; preds = %if.then.28, %if.then.14, %if.then
  %33 = load i64, i64* %list.addr, align 8
  call void @CHECK_LIST(i64 %33)
  %34 = load i64, i64* %list.addr, align 8
  ret i64 %34
}

; Function Attrs: nounwind uwtable
define i64 @Fmemql(i64 %elt, i64 %list) #1 {
entry:
  %retval = alloca i64, align 8
  %elt.addr = alloca i64, align 8
  %list.addr = alloca i64, align 8
  %tail = alloca i64, align 8
  %tem = alloca i64, align 8
  store i64 %elt, i64* %elt.addr, align 8
  store i64 %list, i64* %list.addr, align 8
  %0 = load i64, i64* %elt.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 7
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %1 = load i64, i64* %elt.addr, align 8
  %2 = load i64, i64* %list.addr, align 8
  %call = call i64 @Fmemq(i64 %1, i64 %2)
  store i64 %call, i64* %retval
  br label %return

if.end:                                           ; preds = %entry
  %3 = load i64, i64* %list.addr, align 8
  store i64 %3, i64* %tail, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %4 = load i64, i64* %tail, align 8
  %and2 = and i64 %4, 7
  %conv3 = trunc i64 %and2 to i32
  %cmp4 = icmp eq i32 %conv3, 3
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load i64, i64* %tail, align 8
  %and6 = and i64 %5, 7
  %conv7 = trunc i64 %and6 to i32
  %cmp8 = icmp eq i32 %conv7, 3
  br i1 %cmp8, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  br label %cond.end

cond.false:                                       ; preds = %for.body
  %call10 = call i64 @builtin_lisp_symbol(i32 626)
  %6 = load i64, i64* %list.addr, align 8
  %7 = call i64 @wrong_type_argument(i64 %call10, i64 %6) #8
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %8, %cond.true
  %9 = load i64, i64* %tail, align 8
  %sub = sub nsw i64 %9, 3
  %10 = inttoptr i64 %sub to i8*
  %11 = bitcast i8* %10 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %11, i32 0, i32 0
  %12 = load i64, i64* %car, align 8
  store i64 %12, i64* %tem, align 8
  %13 = load i64, i64* %tem, align 8
  %and11 = and i64 %13, 7
  %conv12 = trunc i64 %and11 to i32
  %cmp13 = icmp eq i32 %conv12, 7
  br i1 %cmp13, label %land.lhs.true, label %if.end.19

land.lhs.true:                                    ; preds = %cond.end
  %14 = load i64, i64* %elt.addr, align 8
  %15 = load i64, i64* %tem, align 8
  %call15 = call i64 @builtin_lisp_symbol(i32 0)
  %call16 = call zeroext i1 @internal_equal(i64 %14, i64 %15, i32 0, i1 zeroext false, i64 %call15)
  br i1 %call16, label %if.then.18, label %if.end.19

if.then.18:                                       ; preds = %land.lhs.true
  %16 = load i64, i64* %tail, align 8
  store i64 %16, i64* %retval
  br label %return

if.end.19:                                        ; preds = %land.lhs.true, %cond.end
  br label %do.body

do.body:                                          ; preds = %if.end.19
  %17 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call20 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp21 = icmp eq i64 %17, %call20
  br i1 %cmp21, label %if.else, label %land.lhs.true.23

land.lhs.true.23:                                 ; preds = %do.body
  %18 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  %call24 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp25 = icmp eq i64 %18, %call24
  br i1 %cmp25, label %if.then.27, label %if.else

if.then.27:                                       ; preds = %land.lhs.true.23
  call void @process_quit_flag()
  br label %if.end.30

if.else:                                          ; preds = %land.lhs.true.23, %do.body
  %19 = load volatile i8, i8* @pending_signals, align 1
  %tobool = trunc i8 %19 to i1
  br i1 %tobool, label %if.then.28, label %if.end.29

if.then.28:                                       ; preds = %if.else
  call void @process_pending_signals()
  br label %if.end.29

if.end.29:                                        ; preds = %if.then.28, %if.else
  br label %if.end.30

if.end.30:                                        ; preds = %if.end.29, %if.then.27
  br label %do.end

do.end:                                           ; preds = %if.end.30
  br label %for.inc

for.inc:                                          ; preds = %do.end
  %20 = load i64, i64* %tail, align 8
  %sub31 = sub nsw i64 %20, 3
  %21 = inttoptr i64 %sub31 to i8*
  %22 = bitcast i8* %21 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %22, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %23 = load i64, i64* %cdr, align 8
  store i64 %23, i64* %tail, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call32 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call32, i64* %retval
  br label %return

return:                                           ; preds = %for.end, %if.then.18, %if.then
  %24 = load i64, i64* %retval
  ret i64 %24
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @internal_equal(i64 %o1, i64 %o2, i32 %depth, i1 zeroext %props, i64 %ht) #1 {
entry:
  %retval = alloca i1, align 1
  %o1.addr = alloca i64, align 8
  %o2.addr = alloca i64, align 8
  %depth.addr = alloca i32, align 4
  %props.addr = alloca i8, align 1
  %ht.addr = alloca i64, align 8
  %.compoundliteral = alloca [2 x i64], align 8
  %h = alloca %struct.Lisp_Hash_Table*, align 8
  %hash = alloca i64, align 8
  %i = alloca i64, align 8
  %o2s = alloca i64, align 8
  %d1 = alloca double, align 8
  %d2 = alloca double, align 8
  %i129 = alloca i32, align 4
  %size = alloca i64, align 8
  %size138 = alloca i64, align 8
  %v1 = alloca i64, align 8
  %v2 = alloca i64, align 8
  store i64 %o1, i64* %o1.addr, align 8
  store i64 %o2, i64* %o2.addr, align 8
  store i32 %depth, i32* %depth.addr, align 4
  %frombool = zext i1 %props to i8
  store i8 %frombool, i8* %props.addr, align 1
  store i64 %ht, i64* %ht.addr, align 8
  %0 = load i32, i32* %depth.addr, align 4
  %cmp = icmp sgt i32 %0, 10
  br i1 %cmp, label %if.then, label %if.end.27

if.then:                                          ; preds = %entry
  %1 = load i32, i32* %depth.addr, align 4
  %cmp1 = icmp sgt i32 %1, 200
  br i1 %cmp1, label %if.then.2, label %if.end

if.then.2:                                        ; preds = %if.then
  call void (i8*, ...) @error(i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.27, i32 0, i32 0)) #8
  unreachable

if.end:                                           ; preds = %if.then
  %2 = load i64, i64* %ht.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp3 = icmp eq i64 %2, %call
  br i1 %cmp3, label %if.then.4, label %if.end.8

if.then.4:                                        ; preds = %if.end
  %arrayinit.begin = getelementptr inbounds [2 x i64], [2 x i64]* %.compoundliteral, i64 0, i64 0
  %call5 = call i64 @builtin_lisp_symbol(i32 129)
  store i64 %call5, i64* %arrayinit.begin
  %arrayinit.element = getelementptr inbounds i64, i64* %arrayinit.begin, i64 1
  %call6 = call i64 @builtin_lisp_symbol(i32 369)
  store i64 %call6, i64* %arrayinit.element
  %arraydecay = getelementptr inbounds [2 x i64], [2 x i64]* %.compoundliteral, i32 0, i32 0
  %call7 = call i64 @Fmake_hash_table(i64 2, i64* %arraydecay)
  store i64 %call7, i64* %ht.addr, align 8
  br label %if.end.8

if.end.8:                                         ; preds = %if.then.4, %if.end
  %3 = load i64, i64* %o1.addr, align 8
  %and = and i64 %3, 7
  %conv = trunc i64 %and to i32
  switch i32 %conv, label %sw.default [
    i32 3, label %sw.bb
    i32 1, label %sw.bb
    i32 5, label %sw.bb
  ]

sw.bb:                                            ; preds = %if.end.8, %if.end.8, %if.end.8
  %4 = load i64, i64* %ht.addr, align 8
  %call9 = call %struct.Lisp_Hash_Table* @XHASH_TABLE(i64 %4)
  store %struct.Lisp_Hash_Table* %call9, %struct.Lisp_Hash_Table** %h, align 8
  %5 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h, align 8
  %6 = load i64, i64* %o1.addr, align 8
  %call10 = call i64 @hash_lookup(%struct.Lisp_Hash_Table* %5, i64 %6, i64* %hash)
  store i64 %call10, i64* %i, align 8
  %7 = load i64, i64* %i, align 8
  %cmp11 = icmp sge i64 %7, 0
  br i1 %cmp11, label %if.then.13, label %if.else.22

if.then.13:                                       ; preds = %sw.bb
  %8 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h, align 8
  %9 = load i64, i64* %i, align 8
  %call14 = call i64 @HASH_VALUE(%struct.Lisp_Hash_Table* %8, i64 %9)
  store i64 %call14, i64* %o2s, align 8
  %10 = load i64, i64* %o2.addr, align 8
  %11 = load i64, i64* %o2s, align 8
  %call15 = call i64 @Fmemq(i64 %10, i64 %11)
  %call16 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp17 = icmp eq i64 %call15, %call16
  br i1 %cmp17, label %if.else, label %if.then.19

if.then.19:                                       ; preds = %if.then.13
  store i1 true, i1* %retval
  br label %return

if.else:                                          ; preds = %if.then.13
  %12 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h, align 8
  %13 = load i64, i64* %i, align 8
  %14 = load i64, i64* %o2.addr, align 8
  %15 = load i64, i64* %o2s, align 8
  %call20 = call i64 @Fcons(i64 %14, i64 %15)
  call void @set_hash_value_slot(%struct.Lisp_Hash_Table* %12, i64 %13, i64 %call20)
  br label %if.end.21

if.end.21:                                        ; preds = %if.else
  br label %if.end.26

if.else.22:                                       ; preds = %sw.bb
  %16 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h, align 8
  %17 = load i64, i64* %o1.addr, align 8
  %18 = load i64, i64* %o2.addr, align 8
  %call23 = call i64 @builtin_lisp_symbol(i32 0)
  %call24 = call i64 @Fcons(i64 %18, i64 %call23)
  %19 = load i64, i64* %hash, align 8
  %call25 = call i64 @hash_put(%struct.Lisp_Hash_Table* %16, i64 %17, i64 %call24, i64 %19)
  br label %if.end.26

if.end.26:                                        ; preds = %if.else.22, %if.end.21
  br label %sw.default

sw.default:                                       ; preds = %if.end.8, %if.end.26
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default
  br label %if.end.27

if.end.27:                                        ; preds = %sw.epilog, %entry
  br label %tail_recurse

tail_recurse:                                     ; preds = %if.end.95, %if.end.68, %if.end.27
  br label %do.body

do.body:                                          ; preds = %tail_recurse
  %20 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call28 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp29 = icmp eq i64 %20, %call28
  br i1 %cmp29, label %if.else.35, label %land.lhs.true

land.lhs.true:                                    ; preds = %do.body
  %21 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  %call31 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp32 = icmp eq i64 %21, %call31
  br i1 %cmp32, label %if.then.34, label %if.else.35

if.then.34:                                       ; preds = %land.lhs.true
  call void @process_quit_flag()
  br label %if.end.38

if.else.35:                                       ; preds = %land.lhs.true, %do.body
  %22 = load volatile i8, i8* @pending_signals, align 1
  %tobool = trunc i8 %22 to i1
  br i1 %tobool, label %if.then.36, label %if.end.37

if.then.36:                                       ; preds = %if.else.35
  call void @process_pending_signals()
  br label %if.end.37

if.end.37:                                        ; preds = %if.then.36, %if.else.35
  br label %if.end.38

if.end.38:                                        ; preds = %if.end.37, %if.then.34
  br label %do.end

do.end:                                           ; preds = %if.end.38
  %23 = load i64, i64* %o1.addr, align 8
  %24 = load i64, i64* %o2.addr, align 8
  %cmp39 = icmp eq i64 %23, %24
  br i1 %cmp39, label %if.then.41, label %if.end.42

if.then.41:                                       ; preds = %do.end
  store i1 true, i1* %retval
  br label %return

if.end.42:                                        ; preds = %do.end
  %25 = load i64, i64* %o1.addr, align 8
  %and43 = and i64 %25, 7
  %conv44 = trunc i64 %and43 to i32
  %26 = load i64, i64* %o2.addr, align 8
  %and45 = and i64 %26, 7
  %conv46 = trunc i64 %and45 to i32
  %cmp47 = icmp ne i32 %conv44, %conv46
  br i1 %cmp47, label %if.then.49, label %if.end.50

if.then.49:                                       ; preds = %if.end.42
  store i1 false, i1* %retval
  br label %return

if.end.50:                                        ; preds = %if.end.42
  %27 = load i64, i64* %o1.addr, align 8
  %and51 = and i64 %27, 7
  %conv52 = trunc i64 %and51 to i32
  switch i32 %conv52, label %sw.default.205 [
    i32 7, label %sw.bb.53
    i32 3, label %sw.bb.62
    i32 1, label %sw.bb.73
    i32 5, label %sw.bb.128
    i32 4, label %sw.bb.179
  ]

sw.bb.53:                                         ; preds = %if.end.50
  %28 = load i64, i64* %o1.addr, align 8
  %call54 = call double @extract_float(i64 %28)
  store double %call54, double* %d1, align 8
  %29 = load i64, i64* %o2.addr, align 8
  %call55 = call double @extract_float(i64 %29)
  store double %call55, double* %d2, align 8
  %30 = load double, double* %d1, align 8
  %31 = load double, double* %d2, align 8
  %cmp56 = fcmp oeq double %30, %31
  br i1 %cmp56, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %sw.bb.53
  %32 = load double, double* %d1, align 8
  %33 = load double, double* %d1, align 8
  %cmp58 = fcmp une double %32, %33
  br i1 %cmp58, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %lor.rhs
  %34 = load double, double* %d2, align 8
  %35 = load double, double* %d2, align 8
  %cmp60 = fcmp une double %34, %35
  br label %land.end

land.end:                                         ; preds = %land.rhs, %lor.rhs
  %36 = phi i1 [ false, %lor.rhs ], [ %cmp60, %land.rhs ]
  br label %lor.end

lor.end:                                          ; preds = %land.end, %sw.bb.53
  %37 = phi i1 [ true, %sw.bb.53 ], [ %36, %land.end ]
  store i1 %37, i1* %retval
  br label %return

sw.bb.62:                                         ; preds = %if.end.50
  %38 = load i64, i64* %o1.addr, align 8
  %sub = sub nsw i64 %38, 3
  %39 = inttoptr i64 %sub to i8*
  %40 = bitcast i8* %39 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %40, i32 0, i32 0
  %41 = load i64, i64* %car, align 8
  %42 = load i64, i64* %o2.addr, align 8
  %sub63 = sub nsw i64 %42, 3
  %43 = inttoptr i64 %sub63 to i8*
  %44 = bitcast i8* %43 to %struct.Lisp_Cons*
  %car64 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %44, i32 0, i32 0
  %45 = load i64, i64* %car64, align 8
  %46 = load i32, i32* %depth.addr, align 4
  %add = add nsw i32 %46, 1
  %47 = load i8, i8* %props.addr, align 1
  %tobool65 = trunc i8 %47 to i1
  %48 = load i64, i64* %ht.addr, align 8
  %call66 = call zeroext i1 @internal_equal(i64 %41, i64 %45, i32 %add, i1 zeroext %tobool65, i64 %48)
  br i1 %call66, label %if.end.68, label %if.then.67

if.then.67:                                       ; preds = %sw.bb.62
  store i1 false, i1* %retval
  br label %return

if.end.68:                                        ; preds = %sw.bb.62
  %49 = load i64, i64* %o1.addr, align 8
  %sub69 = sub nsw i64 %49, 3
  %50 = inttoptr i64 %sub69 to i8*
  %51 = bitcast i8* %50 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %51, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %52 = load i64, i64* %cdr, align 8
  store i64 %52, i64* %o1.addr, align 8
  %53 = load i64, i64* %o2.addr, align 8
  %sub70 = sub nsw i64 %53, 3
  %54 = inttoptr i64 %sub70 to i8*
  %55 = bitcast i8* %54 to %struct.Lisp_Cons*
  %u71 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %55, i32 0, i32 1
  %cdr72 = bitcast %union.anon* %u71 to i64*
  %56 = load i64, i64* %cdr72, align 8
  store i64 %56, i64* %o2.addr, align 8
  br label %tail_recurse

sw.bb.73:                                         ; preds = %if.end.50
  %57 = load i64, i64* %o1.addr, align 8
  %call74 = call i32 @XMISCTYPE(i64 %57)
  %58 = load i64, i64* %o2.addr, align 8
  %call75 = call i32 @XMISCTYPE(i64 %58)
  %cmp76 = icmp ne i32 %call74, %call75
  br i1 %cmp76, label %if.then.78, label %if.end.79

if.then.78:                                       ; preds = %sw.bb.73
  store i1 false, i1* %retval
  br label %return

if.end.79:                                        ; preds = %sw.bb.73
  %59 = load i64, i64* %o1.addr, align 8
  %call80 = call zeroext i1 @OVERLAYP(i64 %59)
  br i1 %call80, label %if.then.81, label %if.end.99

if.then.81:                                       ; preds = %if.end.79
  %60 = load i64, i64* %o1.addr, align 8
  %call82 = call %struct.Lisp_Overlay* @XOVERLAY(i64 %60)
  %start = getelementptr inbounds %struct.Lisp_Overlay, %struct.Lisp_Overlay* %call82, i32 0, i32 2
  %61 = load i64, i64* %start, align 8
  %62 = load i64, i64* %o2.addr, align 8
  %call83 = call %struct.Lisp_Overlay* @XOVERLAY(i64 %62)
  %start84 = getelementptr inbounds %struct.Lisp_Overlay, %struct.Lisp_Overlay* %call83, i32 0, i32 2
  %63 = load i64, i64* %start84, align 8
  %64 = load i32, i32* %depth.addr, align 4
  %add85 = add nsw i32 %64, 1
  %65 = load i8, i8* %props.addr, align 1
  %tobool86 = trunc i8 %65 to i1
  %66 = load i64, i64* %ht.addr, align 8
  %call87 = call zeroext i1 @internal_equal(i64 %61, i64 %63, i32 %add85, i1 zeroext %tobool86, i64 %66)
  br i1 %call87, label %lor.lhs.false, label %if.then.94

lor.lhs.false:                                    ; preds = %if.then.81
  %67 = load i64, i64* %o1.addr, align 8
  %call88 = call %struct.Lisp_Overlay* @XOVERLAY(i64 %67)
  %end = getelementptr inbounds %struct.Lisp_Overlay, %struct.Lisp_Overlay* %call88, i32 0, i32 3
  %68 = load i64, i64* %end, align 8
  %69 = load i64, i64* %o2.addr, align 8
  %call89 = call %struct.Lisp_Overlay* @XOVERLAY(i64 %69)
  %end90 = getelementptr inbounds %struct.Lisp_Overlay, %struct.Lisp_Overlay* %call89, i32 0, i32 3
  %70 = load i64, i64* %end90, align 8
  %71 = load i32, i32* %depth.addr, align 4
  %add91 = add nsw i32 %71, 1
  %72 = load i8, i8* %props.addr, align 1
  %tobool92 = trunc i8 %72 to i1
  %73 = load i64, i64* %ht.addr, align 8
  %call93 = call zeroext i1 @internal_equal(i64 %68, i64 %70, i32 %add91, i1 zeroext %tobool92, i64 %73)
  br i1 %call93, label %if.end.95, label %if.then.94

if.then.94:                                       ; preds = %lor.lhs.false, %if.then.81
  store i1 false, i1* %retval
  br label %return

if.end.95:                                        ; preds = %lor.lhs.false
  %74 = load i64, i64* %o1.addr, align 8
  %call96 = call %struct.Lisp_Overlay* @XOVERLAY(i64 %74)
  %plist = getelementptr inbounds %struct.Lisp_Overlay, %struct.Lisp_Overlay* %call96, i32 0, i32 4
  %75 = load i64, i64* %plist, align 8
  store i64 %75, i64* %o1.addr, align 8
  %76 = load i64, i64* %o2.addr, align 8
  %call97 = call %struct.Lisp_Overlay* @XOVERLAY(i64 %76)
  %plist98 = getelementptr inbounds %struct.Lisp_Overlay, %struct.Lisp_Overlay* %call97, i32 0, i32 4
  %77 = load i64, i64* %plist98, align 8
  store i64 %77, i64* %o2.addr, align 8
  br label %tail_recurse

if.end.99:                                        ; preds = %if.end.79
  %78 = load i64, i64* %o1.addr, align 8
  %and100 = and i64 %78, 7
  %conv101 = trunc i64 %and100 to i32
  %cmp102 = icmp eq i32 %conv101, 1
  br i1 %cmp102, label %land.lhs.true.104, label %if.end.127

land.lhs.true.104:                                ; preds = %if.end.99
  %79 = load i64, i64* %o1.addr, align 8
  %call105 = call i32 @XMISCTYPE(i64 %79)
  %cmp106 = icmp eq i32 %call105, 24236
  br i1 %cmp106, label %if.then.108, label %if.end.127

if.then.108:                                      ; preds = %land.lhs.true.104
  %80 = load i64, i64* %o1.addr, align 8
  %call109 = call %struct.Lisp_Marker* @XMARKER(i64 %80)
  %buffer = getelementptr inbounds %struct.Lisp_Marker, %struct.Lisp_Marker* %call109, i32 0, i32 1
  %81 = load %struct.buffer*, %struct.buffer** %buffer, align 8
  %82 = load i64, i64* %o2.addr, align 8
  %call110 = call %struct.Lisp_Marker* @XMARKER(i64 %82)
  %buffer111 = getelementptr inbounds %struct.Lisp_Marker, %struct.Lisp_Marker* %call110, i32 0, i32 1
  %83 = load %struct.buffer*, %struct.buffer** %buffer111, align 8
  %cmp112 = icmp eq %struct.buffer* %81, %83
  br i1 %cmp112, label %land.rhs.114, label %land.end.126

land.rhs.114:                                     ; preds = %if.then.108
  %84 = load i64, i64* %o1.addr, align 8
  %call115 = call %struct.Lisp_Marker* @XMARKER(i64 %84)
  %buffer116 = getelementptr inbounds %struct.Lisp_Marker, %struct.Lisp_Marker* %call115, i32 0, i32 1
  %85 = load %struct.buffer*, %struct.buffer** %buffer116, align 8
  %cmp117 = icmp eq %struct.buffer* %85, null
  br i1 %cmp117, label %lor.end.125, label %lor.rhs.119

lor.rhs.119:                                      ; preds = %land.rhs.114
  %86 = load i64, i64* %o1.addr, align 8
  %call120 = call %struct.Lisp_Marker* @XMARKER(i64 %86)
  %bytepos = getelementptr inbounds %struct.Lisp_Marker, %struct.Lisp_Marker* %call120, i32 0, i32 4
  %87 = load i64, i64* %bytepos, align 8
  %88 = load i64, i64* %o2.addr, align 8
  %call121 = call %struct.Lisp_Marker* @XMARKER(i64 %88)
  %bytepos122 = getelementptr inbounds %struct.Lisp_Marker, %struct.Lisp_Marker* %call121, i32 0, i32 4
  %89 = load i64, i64* %bytepos122, align 8
  %cmp123 = icmp eq i64 %87, %89
  br label %lor.end.125

lor.end.125:                                      ; preds = %lor.rhs.119, %land.rhs.114
  %90 = phi i1 [ true, %land.rhs.114 ], [ %cmp123, %lor.rhs.119 ]
  br label %land.end.126

land.end.126:                                     ; preds = %lor.end.125, %if.then.108
  %91 = phi i1 [ false, %if.then.108 ], [ %90, %lor.end.125 ]
  store i1 %91, i1* %retval
  br label %return

if.end.127:                                       ; preds = %land.lhs.true.104, %if.end.99
  br label %sw.epilog.206

sw.bb.128:                                        ; preds = %if.end.50
  %92 = load i64, i64* %o1.addr, align 8
  %call130 = call i64 @ASIZE(i64 %92)
  store i64 %call130, i64* %size, align 8
  %93 = load i64, i64* %o2.addr, align 8
  %call131 = call i64 @ASIZE(i64 %93)
  %94 = load i64, i64* %size, align 8
  %cmp132 = icmp ne i64 %call131, %94
  br i1 %cmp132, label %if.then.134, label %if.end.135

if.then.134:                                      ; preds = %sw.bb.128
  store i1 false, i1* %retval
  br label %return

if.end.135:                                       ; preds = %sw.bb.128
  %95 = load i64, i64* %o1.addr, align 8
  %call136 = call zeroext i1 @BOOL_VECTOR_P(i64 %95)
  br i1 %call136, label %if.then.137, label %if.end.152

if.then.137:                                      ; preds = %if.end.135
  %96 = load i64, i64* %o1.addr, align 8
  %call139 = call i64 @bool_vector_size(i64 %96)
  store i64 %call139, i64* %size138, align 8
  %97 = load i64, i64* %size138, align 8
  %98 = load i64, i64* %o2.addr, align 8
  %call140 = call i64 @bool_vector_size(i64 %98)
  %cmp141 = icmp ne i64 %97, %call140
  br i1 %cmp141, label %if.then.143, label %if.end.144

if.then.143:                                      ; preds = %if.then.137
  store i1 false, i1* %retval
  br label %return

if.end.144:                                       ; preds = %if.then.137
  %99 = load i64, i64* %o1.addr, align 8
  %call145 = call i64* @bool_vector_data(i64 %99)
  %100 = bitcast i64* %call145 to i8*
  %101 = load i64, i64* %o2.addr, align 8
  %call146 = call i64* @bool_vector_data(i64 %101)
  %102 = bitcast i64* %call146 to i8*
  %103 = load i64, i64* %size138, align 8
  %call147 = call i64 @bool_vector_bytes(i64 %103)
  %call148 = call i32 @memcmp(i8* %100, i8* %102, i64 %call147) #9
  %tobool149 = icmp ne i32 %call148, 0
  br i1 %tobool149, label %if.then.150, label %if.end.151

if.then.150:                                      ; preds = %if.end.144
  store i1 false, i1* %retval
  br label %return

if.end.151:                                       ; preds = %if.end.144
  store i1 true, i1* %retval
  br label %return

if.end.152:                                       ; preds = %if.end.135
  %104 = load i64, i64* %o1.addr, align 8
  %call153 = call zeroext i1 @WINDOW_CONFIGURATIONP(i64 %104)
  br i1 %call153, label %if.then.154, label %if.end.156

if.then.154:                                      ; preds = %if.end.152
  %105 = load i64, i64* %o1.addr, align 8
  %106 = load i64, i64* %o2.addr, align 8
  %call155 = call zeroext i1 @compare_window_configurations(i64 %105, i64 %106, i1 zeroext false)
  store i1 %call155, i1* %retval
  br label %return

if.end.156:                                       ; preds = %if.end.152
  %107 = load i64, i64* %size, align 8
  %and157 = and i64 %107, 4611686018427387904
  %tobool158 = icmp ne i64 %and157, 0
  br i1 %tobool158, label %if.then.159, label %if.end.166

if.then.159:                                      ; preds = %if.end.156
  %108 = load i64, i64* %size, align 8
  %and160 = and i64 %108, 1056964608
  %shr = ashr i64 %and160, 24
  %cmp161 = icmp slt i64 %shr, 14
  br i1 %cmp161, label %if.then.163, label %if.end.164

if.then.163:                                      ; preds = %if.then.159
  store i1 false, i1* %retval
  br label %return

if.end.164:                                       ; preds = %if.then.159
  %109 = load i64, i64* %size, align 8
  %and165 = and i64 %109, 4095
  store i64 %and165, i64* %size, align 8
  br label %if.end.166

if.end.166:                                       ; preds = %if.end.164, %if.end.156
  store i32 0, i32* %i129, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end.166
  %110 = load i32, i32* %i129, align 4
  %conv167 = sext i32 %110 to i64
  %111 = load i64, i64* %size, align 8
  %cmp168 = icmp slt i64 %conv167, %111
  br i1 %cmp168, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %112 = load i64, i64* %o1.addr, align 8
  %113 = load i32, i32* %i129, align 4
  %conv170 = sext i32 %113 to i64
  %call171 = call i64 @AREF(i64 %112, i64 %conv170)
  store i64 %call171, i64* %v1, align 8
  %114 = load i64, i64* %o2.addr, align 8
  %115 = load i32, i32* %i129, align 4
  %conv172 = sext i32 %115 to i64
  %call173 = call i64 @AREF(i64 %114, i64 %conv172)
  store i64 %call173, i64* %v2, align 8
  %116 = load i64, i64* %v1, align 8
  %117 = load i64, i64* %v2, align 8
  %118 = load i32, i32* %depth.addr, align 4
  %add174 = add nsw i32 %118, 1
  %119 = load i8, i8* %props.addr, align 1
  %tobool175 = trunc i8 %119 to i1
  %120 = load i64, i64* %ht.addr, align 8
  %call176 = call zeroext i1 @internal_equal(i64 %116, i64 %117, i32 %add174, i1 zeroext %tobool175, i64 %120)
  br i1 %call176, label %if.end.178, label %if.then.177

if.then.177:                                      ; preds = %for.body
  store i1 false, i1* %retval
  br label %return

if.end.178:                                       ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end.178
  %121 = load i32, i32* %i129, align 4
  %inc = add nsw i32 %121, 1
  store i32 %inc, i32* %i129, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i1 true, i1* %retval
  br label %return

sw.bb.179:                                        ; preds = %if.end.50
  %122 = load i64, i64* %o1.addr, align 8
  %call180 = call i64 @SCHARS(i64 %122)
  %123 = load i64, i64* %o2.addr, align 8
  %call181 = call i64 @SCHARS(i64 %123)
  %cmp182 = icmp ne i64 %call180, %call181
  br i1 %cmp182, label %if.then.184, label %if.end.185

if.then.184:                                      ; preds = %sw.bb.179
  store i1 false, i1* %retval
  br label %return

if.end.185:                                       ; preds = %sw.bb.179
  %124 = load i64, i64* %o1.addr, align 8
  %call186 = call i64 @SBYTES(i64 %124)
  %125 = load i64, i64* %o2.addr, align 8
  %call187 = call i64 @SBYTES(i64 %125)
  %cmp188 = icmp ne i64 %call186, %call187
  br i1 %cmp188, label %if.then.190, label %if.end.191

if.then.190:                                      ; preds = %if.end.185
  store i1 false, i1* %retval
  br label %return

if.end.191:                                       ; preds = %if.end.185
  %126 = load i64, i64* %o1.addr, align 8
  %call192 = call i8* @SDATA(i64 %126)
  %127 = load i64, i64* %o2.addr, align 8
  %call193 = call i8* @SDATA(i64 %127)
  %128 = load i64, i64* %o1.addr, align 8
  %call194 = call i64 @SBYTES(i64 %128)
  %call195 = call i32 @memcmp(i8* %call192, i8* %call193, i64 %call194) #9
  %tobool196 = icmp ne i32 %call195, 0
  br i1 %tobool196, label %if.then.197, label %if.end.198

if.then.197:                                      ; preds = %if.end.191
  store i1 false, i1* %retval
  br label %return

if.end.198:                                       ; preds = %if.end.191
  %129 = load i8, i8* %props.addr, align 1
  %tobool199 = trunc i8 %129 to i1
  br i1 %tobool199, label %land.lhs.true.201, label %if.end.204

land.lhs.true.201:                                ; preds = %if.end.198
  %130 = load i64, i64* %o1.addr, align 8
  %131 = load i64, i64* %o2.addr, align 8
  %call202 = call zeroext i1 @compare_string_intervals(i64 %130, i64 %131)
  br i1 %call202, label %if.end.204, label %if.then.203

if.then.203:                                      ; preds = %land.lhs.true.201
  store i1 false, i1* %retval
  br label %return

if.end.204:                                       ; preds = %land.lhs.true.201, %if.end.198
  store i1 true, i1* %retval
  br label %return

sw.default.205:                                   ; preds = %if.end.50
  br label %sw.epilog.206

sw.epilog.206:                                    ; preds = %sw.default.205, %if.end.127
  store i1 false, i1* %retval
  br label %return

return:                                           ; preds = %sw.epilog.206, %if.end.204, %if.then.203, %if.then.197, %if.then.190, %if.then.184, %for.end, %if.then.177, %if.then.163, %if.then.154, %if.end.151, %if.then.150, %if.then.143, %if.then.134, %land.end.126, %if.then.94, %if.then.78, %if.then.67, %lor.end, %if.then.49, %if.then.41, %if.then.19
  %132 = load i1, i1* %retval
  ret i1 %132
}

; Function Attrs: nounwind uwtable
define i64 @Fassq(i64 %key, i64 %list) #1 {
entry:
  %key.addr = alloca i64, align 8
  %list.addr = alloca i64, align 8
  store i64 %key, i64* %key.addr, align 8
  store i64 %list, i64* %list.addr, align 8
  br label %while.body

while.body:                                       ; preds = %entry, %do.end
  %0 = load i64, i64* %list.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %while.body
  %1 = load i64, i64* %list.addr, align 8
  %sub = sub nsw i64 %1, 3
  %2 = inttoptr i64 %sub to i8*
  %3 = bitcast i8* %2 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %3, i32 0, i32 0
  %4 = load i64, i64* %car, align 8
  %and2 = and i64 %4, 7
  %conv3 = trunc i64 %and2 to i32
  %cmp4 = icmp eq i32 %conv3, 3
  br i1 %cmp4, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.lhs.false
  %5 = load i64, i64* %list.addr, align 8
  %sub6 = sub nsw i64 %5, 3
  %6 = inttoptr i64 %sub6 to i8*
  %7 = bitcast i8* %6 to %struct.Lisp_Cons*
  %car7 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %7, i32 0, i32 0
  %8 = load i64, i64* %car7, align 8
  %sub8 = sub nsw i64 %8, 3
  %9 = inttoptr i64 %sub8 to i8*
  %10 = bitcast i8* %9 to %struct.Lisp_Cons*
  %car9 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %10, i32 0, i32 0
  %11 = load i64, i64* %car9, align 8
  %12 = load i64, i64* %key.addr, align 8
  %cmp10 = icmp eq i64 %11, %12
  br i1 %cmp10, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true, %while.body
  br label %while.end

if.end:                                           ; preds = %land.lhs.true, %lor.lhs.false
  %13 = load i64, i64* %list.addr, align 8
  %sub12 = sub nsw i64 %13, 3
  %14 = inttoptr i64 %sub12 to i8*
  %15 = bitcast i8* %14 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %15, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %16 = load i64, i64* %cdr, align 8
  store i64 %16, i64* %list.addr, align 8
  %17 = load i64, i64* %list.addr, align 8
  %and13 = and i64 %17, 7
  %conv14 = trunc i64 %and13 to i32
  %cmp15 = icmp eq i32 %conv14, 3
  br i1 %cmp15, label %lor.lhs.false.17, label %if.then.31

lor.lhs.false.17:                                 ; preds = %if.end
  %18 = load i64, i64* %list.addr, align 8
  %sub18 = sub nsw i64 %18, 3
  %19 = inttoptr i64 %sub18 to i8*
  %20 = bitcast i8* %19 to %struct.Lisp_Cons*
  %car19 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %20, i32 0, i32 0
  %21 = load i64, i64* %car19, align 8
  %and20 = and i64 %21, 7
  %conv21 = trunc i64 %and20 to i32
  %cmp22 = icmp eq i32 %conv21, 3
  br i1 %cmp22, label %land.lhs.true.24, label %if.end.32

land.lhs.true.24:                                 ; preds = %lor.lhs.false.17
  %22 = load i64, i64* %list.addr, align 8
  %sub25 = sub nsw i64 %22, 3
  %23 = inttoptr i64 %sub25 to i8*
  %24 = bitcast i8* %23 to %struct.Lisp_Cons*
  %car26 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %24, i32 0, i32 0
  %25 = load i64, i64* %car26, align 8
  %sub27 = sub nsw i64 %25, 3
  %26 = inttoptr i64 %sub27 to i8*
  %27 = bitcast i8* %26 to %struct.Lisp_Cons*
  %car28 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %27, i32 0, i32 0
  %28 = load i64, i64* %car28, align 8
  %29 = load i64, i64* %key.addr, align 8
  %cmp29 = icmp eq i64 %28, %29
  br i1 %cmp29, label %if.then.31, label %if.end.32

if.then.31:                                       ; preds = %land.lhs.true.24, %if.end
  br label %while.end

if.end.32:                                        ; preds = %land.lhs.true.24, %lor.lhs.false.17
  %30 = load i64, i64* %list.addr, align 8
  %sub33 = sub nsw i64 %30, 3
  %31 = inttoptr i64 %sub33 to i8*
  %32 = bitcast i8* %31 to %struct.Lisp_Cons*
  %u34 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %32, i32 0, i32 1
  %cdr35 = bitcast %union.anon* %u34 to i64*
  %33 = load i64, i64* %cdr35, align 8
  store i64 %33, i64* %list.addr, align 8
  %34 = load i64, i64* %list.addr, align 8
  %and36 = and i64 %34, 7
  %conv37 = trunc i64 %and36 to i32
  %cmp38 = icmp eq i32 %conv37, 3
  br i1 %cmp38, label %lor.lhs.false.40, label %if.then.54

lor.lhs.false.40:                                 ; preds = %if.end.32
  %35 = load i64, i64* %list.addr, align 8
  %sub41 = sub nsw i64 %35, 3
  %36 = inttoptr i64 %sub41 to i8*
  %37 = bitcast i8* %36 to %struct.Lisp_Cons*
  %car42 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %37, i32 0, i32 0
  %38 = load i64, i64* %car42, align 8
  %and43 = and i64 %38, 7
  %conv44 = trunc i64 %and43 to i32
  %cmp45 = icmp eq i32 %conv44, 3
  br i1 %cmp45, label %land.lhs.true.47, label %if.end.55

land.lhs.true.47:                                 ; preds = %lor.lhs.false.40
  %39 = load i64, i64* %list.addr, align 8
  %sub48 = sub nsw i64 %39, 3
  %40 = inttoptr i64 %sub48 to i8*
  %41 = bitcast i8* %40 to %struct.Lisp_Cons*
  %car49 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %41, i32 0, i32 0
  %42 = load i64, i64* %car49, align 8
  %sub50 = sub nsw i64 %42, 3
  %43 = inttoptr i64 %sub50 to i8*
  %44 = bitcast i8* %43 to %struct.Lisp_Cons*
  %car51 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %44, i32 0, i32 0
  %45 = load i64, i64* %car51, align 8
  %46 = load i64, i64* %key.addr, align 8
  %cmp52 = icmp eq i64 %45, %46
  br i1 %cmp52, label %if.then.54, label %if.end.55

if.then.54:                                       ; preds = %land.lhs.true.47, %if.end.32
  br label %while.end

if.end.55:                                        ; preds = %land.lhs.true.47, %lor.lhs.false.40
  %47 = load i64, i64* %list.addr, align 8
  %sub56 = sub nsw i64 %47, 3
  %48 = inttoptr i64 %sub56 to i8*
  %49 = bitcast i8* %48 to %struct.Lisp_Cons*
  %u57 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %49, i32 0, i32 1
  %cdr58 = bitcast %union.anon* %u57 to i64*
  %50 = load i64, i64* %cdr58, align 8
  store i64 %50, i64* %list.addr, align 8
  br label %do.body

do.body:                                          ; preds = %if.end.55
  %51 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp59 = icmp eq i64 %51, %call
  br i1 %cmp59, label %if.else, label %land.lhs.true.61

land.lhs.true.61:                                 ; preds = %do.body
  %52 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  %call62 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp63 = icmp eq i64 %52, %call62
  br i1 %cmp63, label %if.then.65, label %if.else

if.then.65:                                       ; preds = %land.lhs.true.61
  call void @process_quit_flag()
  br label %if.end.68

if.else:                                          ; preds = %land.lhs.true.61, %do.body
  %53 = load volatile i8, i8* @pending_signals, align 1
  %tobool = trunc i8 %53 to i1
  br i1 %tobool, label %if.then.66, label %if.end.67

if.then.66:                                       ; preds = %if.else
  call void @process_pending_signals()
  br label %if.end.67

if.end.67:                                        ; preds = %if.then.66, %if.else
  br label %if.end.68

if.end.68:                                        ; preds = %if.end.67, %if.then.65
  br label %do.end

do.end:                                           ; preds = %if.end.68
  br label %while.body

while.end:                                        ; preds = %if.then.54, %if.then.31, %if.then
  %54 = load i64, i64* %list.addr, align 8
  %call69 = call i64 @CAR(i64 %54)
  ret i64 %call69
}

declare i64 @CAR(i64) #2

; Function Attrs: nounwind uwtable
define i64 @assq_no_quit(i64 %key, i64 %list) #1 {
entry:
  %key.addr = alloca i64, align 8
  %list.addr = alloca i64, align 8
  store i64 %key, i64* %key.addr, align 8
  store i64 %list, i64* %list.addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load i64, i64* %list.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %1 = load i64, i64* %list.addr, align 8
  %sub = sub nsw i64 %1, 3
  %2 = inttoptr i64 %sub to i8*
  %3 = bitcast i8* %2 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %3, i32 0, i32 0
  %4 = load i64, i64* %car, align 8
  %and2 = and i64 %4, 7
  %conv3 = trunc i64 %and2 to i32
  %cmp4 = icmp eq i32 %conv3, 3
  br i1 %cmp4, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %land.rhs
  %5 = load i64, i64* %list.addr, align 8
  %sub6 = sub nsw i64 %5, 3
  %6 = inttoptr i64 %sub6 to i8*
  %7 = bitcast i8* %6 to %struct.Lisp_Cons*
  %car7 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %7, i32 0, i32 0
  %8 = load i64, i64* %car7, align 8
  %sub8 = sub nsw i64 %8, 3
  %9 = inttoptr i64 %sub8 to i8*
  %10 = bitcast i8* %9 to %struct.Lisp_Cons*
  %car9 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %10, i32 0, i32 0
  %11 = load i64, i64* %car9, align 8
  %12 = load i64, i64* %key.addr, align 8
  %cmp10 = icmp eq i64 %11, %12
  %lnot = xor i1 %cmp10, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.rhs
  %13 = phi i1 [ true, %land.rhs ], [ %lnot, %lor.rhs ]
  br label %land.end

land.end:                                         ; preds = %lor.end, %while.cond
  %14 = phi i1 [ false, %while.cond ], [ %13, %lor.end ]
  br i1 %14, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %15 = load i64, i64* %list.addr, align 8
  %sub12 = sub nsw i64 %15, 3
  %16 = inttoptr i64 %sub12 to i8*
  %17 = bitcast i8* %16 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %17, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %18 = load i64, i64* %cdr, align 8
  store i64 %18, i64* %list.addr, align 8
  br label %while.cond

while.end:                                        ; preds = %land.end
  %19 = load i64, i64* %list.addr, align 8
  %call = call i64 @CAR_SAFE(i64 %19)
  ret i64 %call
}

declare i64 @CAR_SAFE(i64) #2

; Function Attrs: nounwind uwtable
define i64 @Fassoc(i64 %key, i64 %list) #1 {
entry:
  %key.addr = alloca i64, align 8
  %list.addr = alloca i64, align 8
  %car = alloca i64, align 8
  store i64 %key, i64* %key.addr, align 8
  store i64 %list, i64* %list.addr, align 8
  br label %while.body

while.body:                                       ; preds = %entry, %do.end
  %0 = load i64, i64* %list.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %while.body
  %1 = load i64, i64* %list.addr, align 8
  %sub = sub nsw i64 %1, 3
  %2 = inttoptr i64 %sub to i8*
  %3 = bitcast i8* %2 to %struct.Lisp_Cons*
  %car2 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %3, i32 0, i32 0
  %4 = load i64, i64* %car2, align 8
  %and3 = and i64 %4, 7
  %conv4 = trunc i64 %and3 to i32
  %cmp5 = icmp eq i32 %conv4, 3
  br i1 %cmp5, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.lhs.false
  %5 = load i64, i64* %list.addr, align 8
  %sub7 = sub nsw i64 %5, 3
  %6 = inttoptr i64 %sub7 to i8*
  %7 = bitcast i8* %6 to %struct.Lisp_Cons*
  %car8 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %7, i32 0, i32 0
  %8 = load i64, i64* %car8, align 8
  %sub9 = sub nsw i64 %8, 3
  %9 = inttoptr i64 %sub9 to i8*
  %10 = bitcast i8* %9 to %struct.Lisp_Cons*
  %car10 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %10, i32 0, i32 0
  %11 = load i64, i64* %car10, align 8
  store i64 %11, i64* %car, align 8
  %12 = load i64, i64* %car, align 8
  %13 = load i64, i64* %key.addr, align 8
  %cmp11 = icmp eq i64 %12, %13
  br i1 %cmp11, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.lhs.true
  %14 = load i64, i64* %car, align 8
  %15 = load i64, i64* %key.addr, align 8
  %call = call i64 @Fequal(i64 %14, i64 %15)
  %call13 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp14 = icmp eq i64 %call, %call13
  %lnot = xor i1 %cmp14, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.lhs.true
  %16 = phi i1 [ true, %land.lhs.true ], [ %lnot, %lor.rhs ]
  br i1 %16, label %if.then, label %if.end

if.then:                                          ; preds = %lor.end, %while.body
  br label %while.end

if.end:                                           ; preds = %lor.end, %lor.lhs.false
  %17 = load i64, i64* %list.addr, align 8
  %sub16 = sub nsw i64 %17, 3
  %18 = inttoptr i64 %sub16 to i8*
  %19 = bitcast i8* %18 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %19, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %20 = load i64, i64* %cdr, align 8
  store i64 %20, i64* %list.addr, align 8
  %21 = load i64, i64* %list.addr, align 8
  %and17 = and i64 %21, 7
  %conv18 = trunc i64 %and17 to i32
  %cmp19 = icmp eq i32 %conv18, 3
  br i1 %cmp19, label %lor.lhs.false.21, label %if.then.42

lor.lhs.false.21:                                 ; preds = %if.end
  %22 = load i64, i64* %list.addr, align 8
  %sub22 = sub nsw i64 %22, 3
  %23 = inttoptr i64 %sub22 to i8*
  %24 = bitcast i8* %23 to %struct.Lisp_Cons*
  %car23 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %24, i32 0, i32 0
  %25 = load i64, i64* %car23, align 8
  %and24 = and i64 %25, 7
  %conv25 = trunc i64 %and24 to i32
  %cmp26 = icmp eq i32 %conv25, 3
  br i1 %cmp26, label %land.lhs.true.28, label %if.end.43

land.lhs.true.28:                                 ; preds = %lor.lhs.false.21
  %26 = load i64, i64* %list.addr, align 8
  %sub29 = sub nsw i64 %26, 3
  %27 = inttoptr i64 %sub29 to i8*
  %28 = bitcast i8* %27 to %struct.Lisp_Cons*
  %car30 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %28, i32 0, i32 0
  %29 = load i64, i64* %car30, align 8
  %sub31 = sub nsw i64 %29, 3
  %30 = inttoptr i64 %sub31 to i8*
  %31 = bitcast i8* %30 to %struct.Lisp_Cons*
  %car32 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %31, i32 0, i32 0
  %32 = load i64, i64* %car32, align 8
  store i64 %32, i64* %car, align 8
  %33 = load i64, i64* %car, align 8
  %34 = load i64, i64* %key.addr, align 8
  %cmp33 = icmp eq i64 %33, %34
  br i1 %cmp33, label %lor.end.41, label %lor.rhs.35

lor.rhs.35:                                       ; preds = %land.lhs.true.28
  %35 = load i64, i64* %car, align 8
  %36 = load i64, i64* %key.addr, align 8
  %call36 = call i64 @Fequal(i64 %35, i64 %36)
  %call37 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp38 = icmp eq i64 %call36, %call37
  %lnot40 = xor i1 %cmp38, true
  br label %lor.end.41

lor.end.41:                                       ; preds = %lor.rhs.35, %land.lhs.true.28
  %37 = phi i1 [ true, %land.lhs.true.28 ], [ %lnot40, %lor.rhs.35 ]
  br i1 %37, label %if.then.42, label %if.end.43

if.then.42:                                       ; preds = %lor.end.41, %if.end
  br label %while.end

if.end.43:                                        ; preds = %lor.end.41, %lor.lhs.false.21
  %38 = load i64, i64* %list.addr, align 8
  %sub44 = sub nsw i64 %38, 3
  %39 = inttoptr i64 %sub44 to i8*
  %40 = bitcast i8* %39 to %struct.Lisp_Cons*
  %u45 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %40, i32 0, i32 1
  %cdr46 = bitcast %union.anon* %u45 to i64*
  %41 = load i64, i64* %cdr46, align 8
  store i64 %41, i64* %list.addr, align 8
  %42 = load i64, i64* %list.addr, align 8
  %and47 = and i64 %42, 7
  %conv48 = trunc i64 %and47 to i32
  %cmp49 = icmp eq i32 %conv48, 3
  br i1 %cmp49, label %lor.lhs.false.51, label %if.then.72

lor.lhs.false.51:                                 ; preds = %if.end.43
  %43 = load i64, i64* %list.addr, align 8
  %sub52 = sub nsw i64 %43, 3
  %44 = inttoptr i64 %sub52 to i8*
  %45 = bitcast i8* %44 to %struct.Lisp_Cons*
  %car53 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %45, i32 0, i32 0
  %46 = load i64, i64* %car53, align 8
  %and54 = and i64 %46, 7
  %conv55 = trunc i64 %and54 to i32
  %cmp56 = icmp eq i32 %conv55, 3
  br i1 %cmp56, label %land.lhs.true.58, label %if.end.73

land.lhs.true.58:                                 ; preds = %lor.lhs.false.51
  %47 = load i64, i64* %list.addr, align 8
  %sub59 = sub nsw i64 %47, 3
  %48 = inttoptr i64 %sub59 to i8*
  %49 = bitcast i8* %48 to %struct.Lisp_Cons*
  %car60 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %49, i32 0, i32 0
  %50 = load i64, i64* %car60, align 8
  %sub61 = sub nsw i64 %50, 3
  %51 = inttoptr i64 %sub61 to i8*
  %52 = bitcast i8* %51 to %struct.Lisp_Cons*
  %car62 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %52, i32 0, i32 0
  %53 = load i64, i64* %car62, align 8
  store i64 %53, i64* %car, align 8
  %54 = load i64, i64* %car, align 8
  %55 = load i64, i64* %key.addr, align 8
  %cmp63 = icmp eq i64 %54, %55
  br i1 %cmp63, label %lor.end.71, label %lor.rhs.65

lor.rhs.65:                                       ; preds = %land.lhs.true.58
  %56 = load i64, i64* %car, align 8
  %57 = load i64, i64* %key.addr, align 8
  %call66 = call i64 @Fequal(i64 %56, i64 %57)
  %call67 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp68 = icmp eq i64 %call66, %call67
  %lnot70 = xor i1 %cmp68, true
  br label %lor.end.71

lor.end.71:                                       ; preds = %lor.rhs.65, %land.lhs.true.58
  %58 = phi i1 [ true, %land.lhs.true.58 ], [ %lnot70, %lor.rhs.65 ]
  br i1 %58, label %if.then.72, label %if.end.73

if.then.72:                                       ; preds = %lor.end.71, %if.end.43
  br label %while.end

if.end.73:                                        ; preds = %lor.end.71, %lor.lhs.false.51
  %59 = load i64, i64* %list.addr, align 8
  %sub74 = sub nsw i64 %59, 3
  %60 = inttoptr i64 %sub74 to i8*
  %61 = bitcast i8* %60 to %struct.Lisp_Cons*
  %u75 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %61, i32 0, i32 1
  %cdr76 = bitcast %union.anon* %u75 to i64*
  %62 = load i64, i64* %cdr76, align 8
  store i64 %62, i64* %list.addr, align 8
  br label %do.body

do.body:                                          ; preds = %if.end.73
  %63 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call77 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp78 = icmp eq i64 %63, %call77
  br i1 %cmp78, label %if.else, label %land.lhs.true.80

land.lhs.true.80:                                 ; preds = %do.body
  %64 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  %call81 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp82 = icmp eq i64 %64, %call81
  br i1 %cmp82, label %if.then.84, label %if.else

if.then.84:                                       ; preds = %land.lhs.true.80
  call void @process_quit_flag()
  br label %if.end.87

if.else:                                          ; preds = %land.lhs.true.80, %do.body
  %65 = load volatile i8, i8* @pending_signals, align 1
  %tobool = trunc i8 %65 to i1
  br i1 %tobool, label %if.then.85, label %if.end.86

if.then.85:                                       ; preds = %if.else
  call void @process_pending_signals()
  br label %if.end.86

if.end.86:                                        ; preds = %if.then.85, %if.else
  br label %if.end.87

if.end.87:                                        ; preds = %if.end.86, %if.then.84
  br label %do.end

do.end:                                           ; preds = %if.end.87
  br label %while.body

while.end:                                        ; preds = %if.then.72, %if.then.42, %if.then
  %66 = load i64, i64* %list.addr, align 8
  %call88 = call i64 @CAR(i64 %66)
  ret i64 %call88
}

; Function Attrs: nounwind uwtable
define i64 @assoc_no_quit(i64 %key, i64 %list) #1 {
entry:
  %key.addr = alloca i64, align 8
  %list.addr = alloca i64, align 8
  store i64 %key, i64* %key.addr, align 8
  store i64 %list, i64* %list.addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load i64, i64* %list.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %land.rhs, label %land.end.20

land.rhs:                                         ; preds = %while.cond
  %1 = load i64, i64* %list.addr, align 8
  %sub = sub nsw i64 %1, 3
  %2 = inttoptr i64 %sub to i8*
  %3 = bitcast i8* %2 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %3, i32 0, i32 0
  %4 = load i64, i64* %car, align 8
  %and2 = and i64 %4, 7
  %conv3 = trunc i64 %and2 to i32
  %cmp4 = icmp eq i32 %conv3, 3
  br i1 %cmp4, label %lor.rhs, label %lor.end

lor.rhs:                                          ; preds = %land.rhs
  %5 = load i64, i64* %list.addr, align 8
  %sub6 = sub nsw i64 %5, 3
  %6 = inttoptr i64 %sub6 to i8*
  %7 = bitcast i8* %6 to %struct.Lisp_Cons*
  %car7 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %7, i32 0, i32 0
  %8 = load i64, i64* %car7, align 8
  %sub8 = sub nsw i64 %8, 3
  %9 = inttoptr i64 %sub8 to i8*
  %10 = bitcast i8* %9 to %struct.Lisp_Cons*
  %car9 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %10, i32 0, i32 0
  %11 = load i64, i64* %car9, align 8
  %12 = load i64, i64* %key.addr, align 8
  %cmp10 = icmp eq i64 %11, %12
  br i1 %cmp10, label %land.end, label %land.rhs.12

land.rhs.12:                                      ; preds = %lor.rhs
  %13 = load i64, i64* %list.addr, align 8
  %sub13 = sub nsw i64 %13, 3
  %14 = inttoptr i64 %sub13 to i8*
  %15 = bitcast i8* %14 to %struct.Lisp_Cons*
  %car14 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %15, i32 0, i32 0
  %16 = load i64, i64* %car14, align 8
  %sub15 = sub nsw i64 %16, 3
  %17 = inttoptr i64 %sub15 to i8*
  %18 = bitcast i8* %17 to %struct.Lisp_Cons*
  %car16 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %18, i32 0, i32 0
  %19 = load i64, i64* %car16, align 8
  %20 = load i64, i64* %key.addr, align 8
  %call = call i64 @Fequal(i64 %19, i64 %20)
  %call17 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp18 = icmp eq i64 %call, %call17
  br label %land.end

land.end:                                         ; preds = %land.rhs.12, %lor.rhs
  %21 = phi i1 [ false, %lor.rhs ], [ %cmp18, %land.rhs.12 ]
  br label %lor.end

lor.end:                                          ; preds = %land.end, %land.rhs
  %22 = phi i1 [ true, %land.rhs ], [ %21, %land.end ]
  br label %land.end.20

land.end.20:                                      ; preds = %lor.end, %while.cond
  %23 = phi i1 [ false, %while.cond ], [ %22, %lor.end ]
  br i1 %23, label %while.body, label %while.end

while.body:                                       ; preds = %land.end.20
  %24 = load i64, i64* %list.addr, align 8
  %sub21 = sub nsw i64 %24, 3
  %25 = inttoptr i64 %sub21 to i8*
  %26 = bitcast i8* %25 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %26, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %27 = load i64, i64* %cdr, align 8
  store i64 %27, i64* %list.addr, align 8
  br label %while.cond

while.end:                                        ; preds = %land.end.20
  %28 = load i64, i64* %list.addr, align 8
  %and22 = and i64 %28, 7
  %conv23 = trunc i64 %and22 to i32
  %cmp24 = icmp eq i32 %conv23, 3
  br i1 %cmp24, label %cond.true, label %cond.false

cond.true:                                        ; preds = %while.end
  %29 = load i64, i64* %list.addr, align 8
  %sub26 = sub nsw i64 %29, 3
  %30 = inttoptr i64 %sub26 to i8*
  %31 = bitcast i8* %30 to %struct.Lisp_Cons*
  %car27 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %31, i32 0, i32 0
  %32 = load i64, i64* %car27, align 8
  br label %cond.end

cond.false:                                       ; preds = %while.end
  %call28 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %32, %cond.true ], [ %call28, %cond.false ]
  ret i64 %cond
}

; Function Attrs: nounwind uwtable
define i64 @Frassq(i64 %key, i64 %list) #1 {
entry:
  %key.addr = alloca i64, align 8
  %list.addr = alloca i64, align 8
  store i64 %key, i64* %key.addr, align 8
  store i64 %list, i64* %list.addr, align 8
  br label %while.body

while.body:                                       ; preds = %entry, %do.end
  %0 = load i64, i64* %list.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %while.body
  %1 = load i64, i64* %list.addr, align 8
  %sub = sub nsw i64 %1, 3
  %2 = inttoptr i64 %sub to i8*
  %3 = bitcast i8* %2 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %3, i32 0, i32 0
  %4 = load i64, i64* %car, align 8
  %and2 = and i64 %4, 7
  %conv3 = trunc i64 %and2 to i32
  %cmp4 = icmp eq i32 %conv3, 3
  br i1 %cmp4, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.lhs.false
  %5 = load i64, i64* %list.addr, align 8
  %sub6 = sub nsw i64 %5, 3
  %6 = inttoptr i64 %sub6 to i8*
  %7 = bitcast i8* %6 to %struct.Lisp_Cons*
  %car7 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %7, i32 0, i32 0
  %8 = load i64, i64* %car7, align 8
  %sub8 = sub nsw i64 %8, 3
  %9 = inttoptr i64 %sub8 to i8*
  %10 = bitcast i8* %9 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %10, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %11 = load i64, i64* %cdr, align 8
  %12 = load i64, i64* %key.addr, align 8
  %cmp9 = icmp eq i64 %11, %12
  br i1 %cmp9, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true, %while.body
  br label %while.end

if.end:                                           ; preds = %land.lhs.true, %lor.lhs.false
  %13 = load i64, i64* %list.addr, align 8
  %sub11 = sub nsw i64 %13, 3
  %14 = inttoptr i64 %sub11 to i8*
  %15 = bitcast i8* %14 to %struct.Lisp_Cons*
  %u12 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %15, i32 0, i32 1
  %cdr13 = bitcast %union.anon* %u12 to i64*
  %16 = load i64, i64* %cdr13, align 8
  store i64 %16, i64* %list.addr, align 8
  %17 = load i64, i64* %list.addr, align 8
  %and14 = and i64 %17, 7
  %conv15 = trunc i64 %and14 to i32
  %cmp16 = icmp eq i32 %conv15, 3
  br i1 %cmp16, label %lor.lhs.false.18, label %if.then.33

lor.lhs.false.18:                                 ; preds = %if.end
  %18 = load i64, i64* %list.addr, align 8
  %sub19 = sub nsw i64 %18, 3
  %19 = inttoptr i64 %sub19 to i8*
  %20 = bitcast i8* %19 to %struct.Lisp_Cons*
  %car20 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %20, i32 0, i32 0
  %21 = load i64, i64* %car20, align 8
  %and21 = and i64 %21, 7
  %conv22 = trunc i64 %and21 to i32
  %cmp23 = icmp eq i32 %conv22, 3
  br i1 %cmp23, label %land.lhs.true.25, label %if.end.34

land.lhs.true.25:                                 ; preds = %lor.lhs.false.18
  %22 = load i64, i64* %list.addr, align 8
  %sub26 = sub nsw i64 %22, 3
  %23 = inttoptr i64 %sub26 to i8*
  %24 = bitcast i8* %23 to %struct.Lisp_Cons*
  %car27 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %24, i32 0, i32 0
  %25 = load i64, i64* %car27, align 8
  %sub28 = sub nsw i64 %25, 3
  %26 = inttoptr i64 %sub28 to i8*
  %27 = bitcast i8* %26 to %struct.Lisp_Cons*
  %u29 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %27, i32 0, i32 1
  %cdr30 = bitcast %union.anon* %u29 to i64*
  %28 = load i64, i64* %cdr30, align 8
  %29 = load i64, i64* %key.addr, align 8
  %cmp31 = icmp eq i64 %28, %29
  br i1 %cmp31, label %if.then.33, label %if.end.34

if.then.33:                                       ; preds = %land.lhs.true.25, %if.end
  br label %while.end

if.end.34:                                        ; preds = %land.lhs.true.25, %lor.lhs.false.18
  %30 = load i64, i64* %list.addr, align 8
  %sub35 = sub nsw i64 %30, 3
  %31 = inttoptr i64 %sub35 to i8*
  %32 = bitcast i8* %31 to %struct.Lisp_Cons*
  %u36 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %32, i32 0, i32 1
  %cdr37 = bitcast %union.anon* %u36 to i64*
  %33 = load i64, i64* %cdr37, align 8
  store i64 %33, i64* %list.addr, align 8
  %34 = load i64, i64* %list.addr, align 8
  %and38 = and i64 %34, 7
  %conv39 = trunc i64 %and38 to i32
  %cmp40 = icmp eq i32 %conv39, 3
  br i1 %cmp40, label %lor.lhs.false.42, label %if.then.57

lor.lhs.false.42:                                 ; preds = %if.end.34
  %35 = load i64, i64* %list.addr, align 8
  %sub43 = sub nsw i64 %35, 3
  %36 = inttoptr i64 %sub43 to i8*
  %37 = bitcast i8* %36 to %struct.Lisp_Cons*
  %car44 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %37, i32 0, i32 0
  %38 = load i64, i64* %car44, align 8
  %and45 = and i64 %38, 7
  %conv46 = trunc i64 %and45 to i32
  %cmp47 = icmp eq i32 %conv46, 3
  br i1 %cmp47, label %land.lhs.true.49, label %if.end.58

land.lhs.true.49:                                 ; preds = %lor.lhs.false.42
  %39 = load i64, i64* %list.addr, align 8
  %sub50 = sub nsw i64 %39, 3
  %40 = inttoptr i64 %sub50 to i8*
  %41 = bitcast i8* %40 to %struct.Lisp_Cons*
  %car51 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %41, i32 0, i32 0
  %42 = load i64, i64* %car51, align 8
  %sub52 = sub nsw i64 %42, 3
  %43 = inttoptr i64 %sub52 to i8*
  %44 = bitcast i8* %43 to %struct.Lisp_Cons*
  %u53 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %44, i32 0, i32 1
  %cdr54 = bitcast %union.anon* %u53 to i64*
  %45 = load i64, i64* %cdr54, align 8
  %46 = load i64, i64* %key.addr, align 8
  %cmp55 = icmp eq i64 %45, %46
  br i1 %cmp55, label %if.then.57, label %if.end.58

if.then.57:                                       ; preds = %land.lhs.true.49, %if.end.34
  br label %while.end

if.end.58:                                        ; preds = %land.lhs.true.49, %lor.lhs.false.42
  %47 = load i64, i64* %list.addr, align 8
  %sub59 = sub nsw i64 %47, 3
  %48 = inttoptr i64 %sub59 to i8*
  %49 = bitcast i8* %48 to %struct.Lisp_Cons*
  %u60 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %49, i32 0, i32 1
  %cdr61 = bitcast %union.anon* %u60 to i64*
  %50 = load i64, i64* %cdr61, align 8
  store i64 %50, i64* %list.addr, align 8
  br label %do.body

do.body:                                          ; preds = %if.end.58
  %51 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp62 = icmp eq i64 %51, %call
  br i1 %cmp62, label %if.else, label %land.lhs.true.64

land.lhs.true.64:                                 ; preds = %do.body
  %52 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  %call65 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp66 = icmp eq i64 %52, %call65
  br i1 %cmp66, label %if.then.68, label %if.else

if.then.68:                                       ; preds = %land.lhs.true.64
  call void @process_quit_flag()
  br label %if.end.71

if.else:                                          ; preds = %land.lhs.true.64, %do.body
  %53 = load volatile i8, i8* @pending_signals, align 1
  %tobool = trunc i8 %53 to i1
  br i1 %tobool, label %if.then.69, label %if.end.70

if.then.69:                                       ; preds = %if.else
  call void @process_pending_signals()
  br label %if.end.70

if.end.70:                                        ; preds = %if.then.69, %if.else
  br label %if.end.71

if.end.71:                                        ; preds = %if.end.70, %if.then.68
  br label %do.end

do.end:                                           ; preds = %if.end.71
  br label %while.body

while.end:                                        ; preds = %if.then.57, %if.then.33, %if.then
  %54 = load i64, i64* %list.addr, align 8
  %call72 = call i64 @CAR(i64 %54)
  ret i64 %call72
}

; Function Attrs: nounwind uwtable
define i64 @Frassoc(i64 %key, i64 %list) #1 {
entry:
  %key.addr = alloca i64, align 8
  %list.addr = alloca i64, align 8
  %cdr = alloca i64, align 8
  store i64 %key, i64* %key.addr, align 8
  store i64 %list, i64* %list.addr, align 8
  br label %while.body

while.body:                                       ; preds = %entry, %do.end
  %0 = load i64, i64* %list.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %while.body
  %1 = load i64, i64* %list.addr, align 8
  %sub = sub nsw i64 %1, 3
  %2 = inttoptr i64 %sub to i8*
  %3 = bitcast i8* %2 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %3, i32 0, i32 0
  %4 = load i64, i64* %car, align 8
  %and2 = and i64 %4, 7
  %conv3 = trunc i64 %and2 to i32
  %cmp4 = icmp eq i32 %conv3, 3
  br i1 %cmp4, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.lhs.false
  %5 = load i64, i64* %list.addr, align 8
  %sub6 = sub nsw i64 %5, 3
  %6 = inttoptr i64 %sub6 to i8*
  %7 = bitcast i8* %6 to %struct.Lisp_Cons*
  %car7 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %7, i32 0, i32 0
  %8 = load i64, i64* %car7, align 8
  %sub8 = sub nsw i64 %8, 3
  %9 = inttoptr i64 %sub8 to i8*
  %10 = bitcast i8* %9 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %10, i32 0, i32 1
  %cdr9 = bitcast %union.anon* %u to i64*
  %11 = load i64, i64* %cdr9, align 8
  store i64 %11, i64* %cdr, align 8
  %12 = load i64, i64* %cdr, align 8
  %13 = load i64, i64* %key.addr, align 8
  %cmp10 = icmp eq i64 %12, %13
  br i1 %cmp10, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %land.lhs.true
  %14 = load i64, i64* %cdr, align 8
  %15 = load i64, i64* %key.addr, align 8
  %call = call i64 @Fequal(i64 %14, i64 %15)
  %call12 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp13 = icmp eq i64 %call, %call12
  %lnot = xor i1 %cmp13, true
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %land.lhs.true
  %16 = phi i1 [ true, %land.lhs.true ], [ %lnot, %lor.rhs ]
  br i1 %16, label %if.then, label %if.end

if.then:                                          ; preds = %lor.end, %while.body
  br label %while.end

if.end:                                           ; preds = %lor.end, %lor.lhs.false
  %17 = load i64, i64* %list.addr, align 8
  %sub15 = sub nsw i64 %17, 3
  %18 = inttoptr i64 %sub15 to i8*
  %19 = bitcast i8* %18 to %struct.Lisp_Cons*
  %u16 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %19, i32 0, i32 1
  %cdr17 = bitcast %union.anon* %u16 to i64*
  %20 = load i64, i64* %cdr17, align 8
  store i64 %20, i64* %list.addr, align 8
  %21 = load i64, i64* %list.addr, align 8
  %and18 = and i64 %21, 7
  %conv19 = trunc i64 %and18 to i32
  %cmp20 = icmp eq i32 %conv19, 3
  br i1 %cmp20, label %lor.lhs.false.22, label %if.then.44

lor.lhs.false.22:                                 ; preds = %if.end
  %22 = load i64, i64* %list.addr, align 8
  %sub23 = sub nsw i64 %22, 3
  %23 = inttoptr i64 %sub23 to i8*
  %24 = bitcast i8* %23 to %struct.Lisp_Cons*
  %car24 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %24, i32 0, i32 0
  %25 = load i64, i64* %car24, align 8
  %and25 = and i64 %25, 7
  %conv26 = trunc i64 %and25 to i32
  %cmp27 = icmp eq i32 %conv26, 3
  br i1 %cmp27, label %land.lhs.true.29, label %if.end.45

land.lhs.true.29:                                 ; preds = %lor.lhs.false.22
  %26 = load i64, i64* %list.addr, align 8
  %sub30 = sub nsw i64 %26, 3
  %27 = inttoptr i64 %sub30 to i8*
  %28 = bitcast i8* %27 to %struct.Lisp_Cons*
  %car31 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %28, i32 0, i32 0
  %29 = load i64, i64* %car31, align 8
  %sub32 = sub nsw i64 %29, 3
  %30 = inttoptr i64 %sub32 to i8*
  %31 = bitcast i8* %30 to %struct.Lisp_Cons*
  %u33 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %31, i32 0, i32 1
  %cdr34 = bitcast %union.anon* %u33 to i64*
  %32 = load i64, i64* %cdr34, align 8
  store i64 %32, i64* %cdr, align 8
  %33 = load i64, i64* %cdr, align 8
  %34 = load i64, i64* %key.addr, align 8
  %cmp35 = icmp eq i64 %33, %34
  br i1 %cmp35, label %lor.end.43, label %lor.rhs.37

lor.rhs.37:                                       ; preds = %land.lhs.true.29
  %35 = load i64, i64* %cdr, align 8
  %36 = load i64, i64* %key.addr, align 8
  %call38 = call i64 @Fequal(i64 %35, i64 %36)
  %call39 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp40 = icmp eq i64 %call38, %call39
  %lnot42 = xor i1 %cmp40, true
  br label %lor.end.43

lor.end.43:                                       ; preds = %lor.rhs.37, %land.lhs.true.29
  %37 = phi i1 [ true, %land.lhs.true.29 ], [ %lnot42, %lor.rhs.37 ]
  br i1 %37, label %if.then.44, label %if.end.45

if.then.44:                                       ; preds = %lor.end.43, %if.end
  br label %while.end

if.end.45:                                        ; preds = %lor.end.43, %lor.lhs.false.22
  %38 = load i64, i64* %list.addr, align 8
  %sub46 = sub nsw i64 %38, 3
  %39 = inttoptr i64 %sub46 to i8*
  %40 = bitcast i8* %39 to %struct.Lisp_Cons*
  %u47 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %40, i32 0, i32 1
  %cdr48 = bitcast %union.anon* %u47 to i64*
  %41 = load i64, i64* %cdr48, align 8
  store i64 %41, i64* %list.addr, align 8
  %42 = load i64, i64* %list.addr, align 8
  %and49 = and i64 %42, 7
  %conv50 = trunc i64 %and49 to i32
  %cmp51 = icmp eq i32 %conv50, 3
  br i1 %cmp51, label %lor.lhs.false.53, label %if.then.75

lor.lhs.false.53:                                 ; preds = %if.end.45
  %43 = load i64, i64* %list.addr, align 8
  %sub54 = sub nsw i64 %43, 3
  %44 = inttoptr i64 %sub54 to i8*
  %45 = bitcast i8* %44 to %struct.Lisp_Cons*
  %car55 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %45, i32 0, i32 0
  %46 = load i64, i64* %car55, align 8
  %and56 = and i64 %46, 7
  %conv57 = trunc i64 %and56 to i32
  %cmp58 = icmp eq i32 %conv57, 3
  br i1 %cmp58, label %land.lhs.true.60, label %if.end.76

land.lhs.true.60:                                 ; preds = %lor.lhs.false.53
  %47 = load i64, i64* %list.addr, align 8
  %sub61 = sub nsw i64 %47, 3
  %48 = inttoptr i64 %sub61 to i8*
  %49 = bitcast i8* %48 to %struct.Lisp_Cons*
  %car62 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %49, i32 0, i32 0
  %50 = load i64, i64* %car62, align 8
  %sub63 = sub nsw i64 %50, 3
  %51 = inttoptr i64 %sub63 to i8*
  %52 = bitcast i8* %51 to %struct.Lisp_Cons*
  %u64 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %52, i32 0, i32 1
  %cdr65 = bitcast %union.anon* %u64 to i64*
  %53 = load i64, i64* %cdr65, align 8
  store i64 %53, i64* %cdr, align 8
  %54 = load i64, i64* %cdr, align 8
  %55 = load i64, i64* %key.addr, align 8
  %cmp66 = icmp eq i64 %54, %55
  br i1 %cmp66, label %lor.end.74, label %lor.rhs.68

lor.rhs.68:                                       ; preds = %land.lhs.true.60
  %56 = load i64, i64* %cdr, align 8
  %57 = load i64, i64* %key.addr, align 8
  %call69 = call i64 @Fequal(i64 %56, i64 %57)
  %call70 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp71 = icmp eq i64 %call69, %call70
  %lnot73 = xor i1 %cmp71, true
  br label %lor.end.74

lor.end.74:                                       ; preds = %lor.rhs.68, %land.lhs.true.60
  %58 = phi i1 [ true, %land.lhs.true.60 ], [ %lnot73, %lor.rhs.68 ]
  br i1 %58, label %if.then.75, label %if.end.76

if.then.75:                                       ; preds = %lor.end.74, %if.end.45
  br label %while.end

if.end.76:                                        ; preds = %lor.end.74, %lor.lhs.false.53
  %59 = load i64, i64* %list.addr, align 8
  %sub77 = sub nsw i64 %59, 3
  %60 = inttoptr i64 %sub77 to i8*
  %61 = bitcast i8* %60 to %struct.Lisp_Cons*
  %u78 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %61, i32 0, i32 1
  %cdr79 = bitcast %union.anon* %u78 to i64*
  %62 = load i64, i64* %cdr79, align 8
  store i64 %62, i64* %list.addr, align 8
  br label %do.body

do.body:                                          ; preds = %if.end.76
  %63 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call80 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp81 = icmp eq i64 %63, %call80
  br i1 %cmp81, label %if.else, label %land.lhs.true.83

land.lhs.true.83:                                 ; preds = %do.body
  %64 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  %call84 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp85 = icmp eq i64 %64, %call84
  br i1 %cmp85, label %if.then.87, label %if.else

if.then.87:                                       ; preds = %land.lhs.true.83
  call void @process_quit_flag()
  br label %if.end.90

if.else:                                          ; preds = %land.lhs.true.83, %do.body
  %65 = load volatile i8, i8* @pending_signals, align 1
  %tobool = trunc i8 %65 to i1
  br i1 %tobool, label %if.then.88, label %if.end.89

if.then.88:                                       ; preds = %if.else
  call void @process_pending_signals()
  br label %if.end.89

if.end.89:                                        ; preds = %if.then.88, %if.else
  br label %if.end.90

if.end.90:                                        ; preds = %if.end.89, %if.then.87
  br label %do.end

do.end:                                           ; preds = %if.end.90
  br label %while.body

while.end:                                        ; preds = %if.then.75, %if.then.44, %if.then
  %66 = load i64, i64* %list.addr, align 8
  %call91 = call i64 @CAR(i64 %66)
  ret i64 %call91
}

; Function Attrs: nounwind uwtable
define i64 @Fdelq(i64 %elt, i64 %list) #1 {
entry:
  %elt.addr = alloca i64, align 8
  %list.addr = alloca i64, align 8
  %tail = alloca i64, align 8
  %tortoise = alloca i64, align 8
  %prev = alloca i64, align 8
  %skip = alloca i8, align 1
  %tem = alloca i64, align 8
  store i64 %elt, i64* %elt.addr, align 8
  store i64 %list, i64* %list.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call, i64* %prev, align 8
  %0 = load i64, i64* %list.addr, align 8
  store i64 %0, i64* %tail, align 8
  store i64 %0, i64* %tortoise, align 8
  store i8 1, i8* %skip, align 1
  br label %for.cond

for.cond:                                         ; preds = %cond.end.28, %entry
  %1 = load i64, i64* %tail, align 8
  %and = and i64 %1, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i64, i64* %tail, align 8
  %sub = sub nsw i64 %2, 3
  %3 = inttoptr i64 %sub to i8*
  %4 = bitcast i8* %3 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %4, i32 0, i32 0
  %5 = load i64, i64* %car, align 8
  store i64 %5, i64* %tem, align 8
  %6 = load i64, i64* %elt.addr, align 8
  %7 = load i64, i64* %tem, align 8
  %cmp2 = icmp eq i64 %6, %7
  br i1 %cmp2, label %if.then, label %if.else.13

if.then:                                          ; preds = %for.body
  %8 = load i64, i64* %prev, align 8
  %call4 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp5 = icmp eq i64 %8, %call4
  br i1 %cmp5, label %if.then.7, label %if.else

if.then.7:                                        ; preds = %if.then
  %9 = load i64, i64* %tail, align 8
  %sub8 = sub nsw i64 %9, 3
  %10 = inttoptr i64 %sub8 to i8*
  %11 = bitcast i8* %10 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %11, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %12 = load i64, i64* %cdr, align 8
  store i64 %12, i64* %list.addr, align 8
  br label %if.end

if.else:                                          ; preds = %if.then
  %13 = load i64, i64* %prev, align 8
  %14 = load i64, i64* %tail, align 8
  %sub9 = sub nsw i64 %14, 3
  %15 = inttoptr i64 %sub9 to i8*
  %16 = bitcast i8* %15 to %struct.Lisp_Cons*
  %u10 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %16, i32 0, i32 1
  %cdr11 = bitcast %union.anon* %u10 to i64*
  %17 = load i64, i64* %cdr11, align 8
  %call12 = call i64 @Fsetcdr(i64 %13, i64 %17)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then.7
  br label %if.end.14

if.else.13:                                       ; preds = %for.body
  %18 = load i64, i64* %tail, align 8
  store i64 %18, i64* %prev, align 8
  br label %if.end.14

if.end.14:                                        ; preds = %if.else.13, %if.end
  br label %for.inc

for.inc:                                          ; preds = %if.end.14
  %19 = load i64, i64* %tail, align 8
  %sub15 = sub nsw i64 %19, 3
  %20 = inttoptr i64 %sub15 to i8*
  %21 = bitcast i8* %20 to %struct.Lisp_Cons*
  %u16 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %21, i32 0, i32 1
  %cdr17 = bitcast %union.anon* %u16 to i64*
  %22 = load i64, i64* %cdr17, align 8
  store i64 %22, i64* %tail, align 8
  %23 = load i8, i8* %skip, align 1
  %tobool = trunc i8 %23 to i1
  %lnot = xor i1 %tobool, true
  %frombool = zext i1 %lnot to i8
  store i8 %frombool, i8* %skip, align 1
  %24 = load i8, i8* %skip, align 1
  %tobool18 = trunc i8 %24 to i1
  br i1 %tobool18, label %cond.true, label %cond.false.24

cond.true:                                        ; preds = %for.inc
  %25 = load i64, i64* %tail, align 8
  %26 = load i64, i64* %tortoise, align 8
  %cmp20 = icmp eq i64 %25, %26
  br i1 %cmp20, label %cond.true.22, label %cond.false

cond.true.22:                                     ; preds = %cond.true
  %call23 = call i64 @builtin_lisp_symbol(i32 265)
  %27 = load i64, i64* %list.addr, align 8
  call void @xsignal1(i64 %call23, i64 %27) #8
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.false:                                       ; preds = %cond.true
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %28
  br label %cond.end.28

cond.false.24:                                    ; preds = %for.inc
  %29 = load i64, i64* %tortoise, align 8
  %sub25 = sub nsw i64 %29, 3
  %30 = inttoptr i64 %sub25 to i8*
  %31 = bitcast i8* %30 to %struct.Lisp_Cons*
  %u26 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %31, i32 0, i32 1
  %cdr27 = bitcast %union.anon* %u26 to i64*
  %32 = load i64, i64* %cdr27, align 8
  store i64 %32, i64* %tortoise, align 8
  br label %cond.end.28

cond.end.28:                                      ; preds = %cond.false.24, %cond.end
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %33 = load i64, i64* %list.addr, align 8
  ret i64 %33
}

declare i64 @Fsetcdr(i64, i64) #2

; Function Attrs: noreturn
declare void @xsignal1(i64, i64) #3

; Function Attrs: nounwind uwtable
define i64 @Fdelete(i64 %elt, i64 %seq) #1 {
entry:
  %elt.addr = alloca i64, align 8
  %seq.addr = alloca i64, align 8
  %i = alloca i64, align 8
  %n = alloca i64, align 8
  %p = alloca %struct.Lisp_Vector*, align 8
  %i31 = alloca i64, align 8
  %ibyte = alloca i64, align 8
  %nchars = alloca i64, align 8
  %nbytes = alloca i64, align 8
  %cbytes = alloca i64, align 8
  %c = alloca i32, align 4
  %tem = alloca i64, align 8
  %from = alloca i8*, align 8
  %to = alloca i8*, align 8
  %n296 = alloca i64, align 8
  %tail = alloca i64, align 8
  %prev = alloca i64, align 8
  store i64 %elt, i64* %elt.addr, align 8
  store i64 %seq, i64* %seq.addr, align 8
  %0 = load i64, i64* %seq.addr, align 8
  %call = call zeroext i1 @VECTORP(i64 %0)
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i64 0, i64* %n, align 8
  store i64 0, i64* %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %1 = load i64, i64* %i, align 8
  %2 = load i64, i64* %seq.addr, align 8
  %call1 = call i64 @ASIZE(i64 %2)
  %cmp = icmp slt i64 %1, %call1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i64, i64* %seq.addr, align 8
  %4 = load i64, i64* %i, align 8
  %call2 = call i64 @AREF(i64 %3, i64 %4)
  %5 = load i64, i64* %elt.addr, align 8
  %call3 = call i64 @Fequal(i64 %call2, i64 %5)
  %call4 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp5 = icmp eq i64 %call3, %call4
  br i1 %cmp5, label %if.then.6, label %if.end

if.then.6:                                        ; preds = %for.body
  %6 = load i64, i64* %n, align 8
  %inc = add nsw i64 %6, 1
  store i64 %inc, i64* %n, align 8
  br label %if.end

if.end:                                           ; preds = %if.then.6, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %7 = load i64, i64* %i, align 8
  %inc7 = add nsw i64 %7, 1
  store i64 %inc7, i64* %i, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %8 = load i64, i64* %n, align 8
  %9 = load i64, i64* %seq.addr, align 8
  %call8 = call i64 @ASIZE(i64 %9)
  %cmp9 = icmp ne i64 %8, %call8
  br i1 %cmp9, label %if.then.10, label %if.end.28

if.then.10:                                       ; preds = %for.end
  %10 = load i64, i64* %n, align 8
  %call11 = call %struct.Lisp_Vector* @allocate_vector(i64 %10)
  store %struct.Lisp_Vector* %call11, %struct.Lisp_Vector** %p, align 8
  store i64 0, i64* %n, align 8
  store i64 0, i64* %i, align 8
  br label %for.cond.12

for.cond.12:                                      ; preds = %for.inc.24, %if.then.10
  %11 = load i64, i64* %i, align 8
  %12 = load i64, i64* %seq.addr, align 8
  %call13 = call i64 @ASIZE(i64 %12)
  %cmp14 = icmp slt i64 %11, %call13
  br i1 %cmp14, label %for.body.15, label %for.end.26

for.body.15:                                      ; preds = %for.cond.12
  %13 = load i64, i64* %seq.addr, align 8
  %14 = load i64, i64* %i, align 8
  %call16 = call i64 @AREF(i64 %13, i64 %14)
  %15 = load i64, i64* %elt.addr, align 8
  %call17 = call i64 @Fequal(i64 %call16, i64 %15)
  %call18 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp19 = icmp eq i64 %call17, %call18
  br i1 %cmp19, label %if.then.20, label %if.end.23

if.then.20:                                       ; preds = %for.body.15
  %16 = load i64, i64* %seq.addr, align 8
  %17 = load i64, i64* %i, align 8
  %call21 = call i64 @AREF(i64 %16, i64 %17)
  %18 = load i64, i64* %n, align 8
  %inc22 = add nsw i64 %18, 1
  store i64 %inc22, i64* %n, align 8
  %19 = load %struct.Lisp_Vector*, %struct.Lisp_Vector** %p, align 8
  %contents = getelementptr inbounds %struct.Lisp_Vector, %struct.Lisp_Vector* %19, i32 0, i32 1
  %arrayidx = getelementptr inbounds [0 x i64], [0 x i64]* %contents, i32 0, i64 %18
  store i64 %call21, i64* %arrayidx, align 8
  br label %if.end.23

if.end.23:                                        ; preds = %if.then.20, %for.body.15
  br label %for.inc.24

for.inc.24:                                       ; preds = %if.end.23
  %20 = load i64, i64* %i, align 8
  %inc25 = add nsw i64 %20, 1
  store i64 %inc25, i64* %i, align 8
  br label %for.cond.12

for.end.26:                                       ; preds = %for.cond.12
  %21 = load %struct.Lisp_Vector*, %struct.Lisp_Vector** %p, align 8
  %22 = bitcast %struct.Lisp_Vector* %21 to i8*
  %call27 = call i64 @make_lisp_ptr(i8* %22, i32 5)
  store i64 %call27, i64* %seq.addr, align 8
  br label %if.end.28

if.end.28:                                        ; preds = %for.end.26, %for.end
  br label %if.end.364

if.else:                                          ; preds = %entry
  %23 = load i64, i64* %seq.addr, align 8
  %call29 = call zeroext i1 @STRINGP(i64 %23)
  br i1 %call29, label %if.then.30, label %if.else.310

if.then.30:                                       ; preds = %if.else
  store i64 0, i64* %ibyte, align 8
  store i64 0, i64* %nbytes, align 8
  store i64 0, i64* %nchars, align 8
  store i64 0, i64* %i31, align 8
  br label %for.cond.32

for.cond.32:                                      ; preds = %for.inc.147, %if.then.30
  %24 = load i64, i64* %i31, align 8
  %25 = load i64, i64* %seq.addr, align 8
  %call33 = call i64 @SCHARS(i64 %25)
  %cmp34 = icmp slt i64 %24, %call33
  br i1 %cmp34, label %for.body.35, label %for.end.150

for.body.35:                                      ; preds = %for.cond.32
  %26 = load i64, i64* %seq.addr, align 8
  %call36 = call zeroext i1 @STRING_MULTIBYTE(i64 %26)
  br i1 %call36, label %if.then.37, label %if.else.131

if.then.37:                                       ; preds = %for.body.35
  %27 = load i64, i64* %seq.addr, align 8
  %call38 = call i8* @SDATA(i64 %27)
  %28 = load i64, i64* %ibyte, align 8
  %add.ptr = getelementptr inbounds i8, i8* %call38, i64 %28
  %arrayidx39 = getelementptr inbounds i8, i8* %add.ptr, i64 0
  %29 = load i8, i8* %arrayidx39, align 1
  %conv = zext i8 %29 to i32
  %and = and i32 %conv, 128
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then.37
  %30 = load i64, i64* %seq.addr, align 8
  %call40 = call i8* @SDATA(i64 %30)
  %31 = load i64, i64* %ibyte, align 8
  %add.ptr41 = getelementptr inbounds i8, i8* %call40, i64 %31
  %arrayidx42 = getelementptr inbounds i8, i8* %add.ptr41, i64 0
  %32 = load i8, i8* %arrayidx42, align 1
  %conv43 = zext i8 %32 to i32
  br label %cond.end.101

cond.false:                                       ; preds = %if.then.37
  %33 = load i64, i64* %seq.addr, align 8
  %call44 = call i8* @SDATA(i64 %33)
  %34 = load i64, i64* %ibyte, align 8
  %add.ptr45 = getelementptr inbounds i8, i8* %call44, i64 %34
  %arrayidx46 = getelementptr inbounds i8, i8* %add.ptr45, i64 0
  %35 = load i8, i8* %arrayidx46, align 1
  %conv47 = zext i8 %35 to i32
  %and48 = and i32 %conv47, 32
  %tobool49 = icmp ne i32 %and48, 0
  br i1 %tobool49, label %cond.false.67, label %cond.true.50

cond.true.50:                                     ; preds = %cond.false
  %36 = load i64, i64* %seq.addr, align 8
  %call51 = call i8* @SDATA(i64 %36)
  %37 = load i64, i64* %ibyte, align 8
  %add.ptr52 = getelementptr inbounds i8, i8* %call51, i64 %37
  %arrayidx53 = getelementptr inbounds i8, i8* %add.ptr52, i64 0
  %38 = load i8, i8* %arrayidx53, align 1
  %conv54 = zext i8 %38 to i32
  %and55 = and i32 %conv54, 31
  %shl = shl i32 %and55, 6
  %39 = load i64, i64* %seq.addr, align 8
  %call56 = call i8* @SDATA(i64 %39)
  %40 = load i64, i64* %ibyte, align 8
  %add.ptr57 = getelementptr inbounds i8, i8* %call56, i64 %40
  %arrayidx58 = getelementptr inbounds i8, i8* %add.ptr57, i64 1
  %41 = load i8, i8* %arrayidx58, align 1
  %conv59 = zext i8 %41 to i32
  %and60 = and i32 %conv59, 63
  %or = or i32 %shl, %and60
  %42 = load i64, i64* %seq.addr, align 8
  %call61 = call i8* @SDATA(i64 %42)
  %43 = load i64, i64* %ibyte, align 8
  %add.ptr62 = getelementptr inbounds i8, i8* %call61, i64 %43
  %arrayidx63 = getelementptr inbounds i8, i8* %add.ptr62, i64 0
  %44 = load i8, i8* %arrayidx63, align 1
  %conv64 = zext i8 %44 to i32
  %cmp65 = icmp slt i32 %conv64, 194
  %cond = select i1 %cmp65, i32 4194176, i32 0
  %add = add nsw i32 %or, %cond
  br label %cond.end.99

cond.false.67:                                    ; preds = %cond.false
  %45 = load i64, i64* %seq.addr, align 8
  %call68 = call i8* @SDATA(i64 %45)
  %46 = load i64, i64* %ibyte, align 8
  %add.ptr69 = getelementptr inbounds i8, i8* %call68, i64 %46
  %arrayidx70 = getelementptr inbounds i8, i8* %add.ptr69, i64 0
  %47 = load i8, i8* %arrayidx70, align 1
  %conv71 = zext i8 %47 to i32
  %and72 = and i32 %conv71, 16
  %tobool73 = icmp ne i32 %and72, 0
  br i1 %tobool73, label %cond.false.94, label %cond.true.74

cond.true.74:                                     ; preds = %cond.false.67
  %48 = load i64, i64* %seq.addr, align 8
  %call75 = call i8* @SDATA(i64 %48)
  %49 = load i64, i64* %ibyte, align 8
  %add.ptr76 = getelementptr inbounds i8, i8* %call75, i64 %49
  %arrayidx77 = getelementptr inbounds i8, i8* %add.ptr76, i64 0
  %50 = load i8, i8* %arrayidx77, align 1
  %conv78 = zext i8 %50 to i32
  %and79 = and i32 %conv78, 15
  %shl80 = shl i32 %and79, 12
  %51 = load i64, i64* %seq.addr, align 8
  %call81 = call i8* @SDATA(i64 %51)
  %52 = load i64, i64* %ibyte, align 8
  %add.ptr82 = getelementptr inbounds i8, i8* %call81, i64 %52
  %arrayidx83 = getelementptr inbounds i8, i8* %add.ptr82, i64 1
  %53 = load i8, i8* %arrayidx83, align 1
  %conv84 = zext i8 %53 to i32
  %and85 = and i32 %conv84, 63
  %shl86 = shl i32 %and85, 6
  %or87 = or i32 %shl80, %shl86
  %54 = load i64, i64* %seq.addr, align 8
  %call88 = call i8* @SDATA(i64 %54)
  %55 = load i64, i64* %ibyte, align 8
  %add.ptr89 = getelementptr inbounds i8, i8* %call88, i64 %55
  %arrayidx90 = getelementptr inbounds i8, i8* %add.ptr89, i64 2
  %56 = load i8, i8* %arrayidx90, align 1
  %conv91 = zext i8 %56 to i32
  %and92 = and i32 %conv91, 63
  %or93 = or i32 %or87, %and92
  br label %cond.end

cond.false.94:                                    ; preds = %cond.false.67
  %57 = load i64, i64* %seq.addr, align 8
  %call95 = call i8* @SDATA(i64 %57)
  %58 = load i64, i64* %ibyte, align 8
  %add.ptr96 = getelementptr inbounds i8, i8* %call95, i64 %58
  %call97 = call i32 @string_char(i8* %add.ptr96, i8** null, i32* null)
  br label %cond.end

cond.end:                                         ; preds = %cond.false.94, %cond.true.74
  %cond98 = phi i32 [ %or93, %cond.true.74 ], [ %call97, %cond.false.94 ]
  br label %cond.end.99

cond.end.99:                                      ; preds = %cond.end, %cond.true.50
  %cond100 = phi i32 [ %add, %cond.true.50 ], [ %cond98, %cond.end ]
  br label %cond.end.101

cond.end.101:                                     ; preds = %cond.end.99, %cond.true
  %cond102 = phi i32 [ %conv43, %cond.true ], [ %cond100, %cond.end.99 ]
  store i32 %cond102, i32* %c, align 4
  %59 = load i32, i32* %c, align 4
  %cmp103 = icmp sle i32 %59, 127
  br i1 %cmp103, label %cond.true.105, label %cond.false.106

cond.true.105:                                    ; preds = %cond.end.101
  br label %cond.end.128

cond.false.106:                                   ; preds = %cond.end.101
  %60 = load i32, i32* %c, align 4
  %cmp107 = icmp sle i32 %60, 2047
  br i1 %cmp107, label %cond.true.109, label %cond.false.110

cond.true.109:                                    ; preds = %cond.false.106
  br label %cond.end.126

cond.false.110:                                   ; preds = %cond.false.106
  %61 = load i32, i32* %c, align 4
  %cmp111 = icmp sle i32 %61, 65535
  br i1 %cmp111, label %cond.true.113, label %cond.false.114

cond.true.113:                                    ; preds = %cond.false.110
  br label %cond.end.124

cond.false.114:                                   ; preds = %cond.false.110
  %62 = load i32, i32* %c, align 4
  %cmp115 = icmp sle i32 %62, 2097151
  br i1 %cmp115, label %cond.true.117, label %cond.false.118

cond.true.117:                                    ; preds = %cond.false.114
  br label %cond.end.122

cond.false.118:                                   ; preds = %cond.false.114
  %63 = load i32, i32* %c, align 4
  %cmp119 = icmp sle i32 %63, 4194175
  %cond121 = select i1 %cmp119, i32 5, i32 2
  br label %cond.end.122

cond.end.122:                                     ; preds = %cond.false.118, %cond.true.117
  %cond123 = phi i32 [ 4, %cond.true.117 ], [ %cond121, %cond.false.118 ]
  br label %cond.end.124

cond.end.124:                                     ; preds = %cond.end.122, %cond.true.113
  %cond125 = phi i32 [ 3, %cond.true.113 ], [ %cond123, %cond.end.122 ]
  br label %cond.end.126

cond.end.126:                                     ; preds = %cond.end.124, %cond.true.109
  %cond127 = phi i32 [ 2, %cond.true.109 ], [ %cond125, %cond.end.124 ]
  br label %cond.end.128

cond.end.128:                                     ; preds = %cond.end.126, %cond.true.105
  %cond129 = phi i32 [ 1, %cond.true.105 ], [ %cond127, %cond.end.126 ]
  %conv130 = sext i32 %cond129 to i64
  store i64 %conv130, i64* %cbytes, align 8
  br label %if.end.134

if.else.131:                                      ; preds = %for.body.35
  %64 = load i64, i64* %seq.addr, align 8
  %65 = load i64, i64* %i31, align 8
  %call132 = call zeroext i8 @SREF(i64 %64, i64 %65)
  %conv133 = zext i8 %call132 to i32
  store i32 %conv133, i32* %c, align 4
  store i64 1, i64* %cbytes, align 8
  br label %if.end.134

if.end.134:                                       ; preds = %if.else.131, %cond.end.128
  %66 = load i64, i64* %elt.addr, align 8
  %and135 = and i64 %66, 7
  %conv136 = trunc i64 %and135 to i32
  %and137 = and i32 %conv136, -5
  %cmp138 = icmp eq i32 %and137, 2
  br i1 %cmp138, label %lor.lhs.false, label %if.then.143

lor.lhs.false:                                    ; preds = %if.end.134
  %67 = load i32, i32* %c, align 4
  %conv140 = sext i32 %67 to i64
  %68 = load i64, i64* %elt.addr, align 8
  %shr = ashr i64 %68, 2
  %cmp141 = icmp ne i64 %conv140, %shr
  br i1 %cmp141, label %if.then.143, label %if.end.146

if.then.143:                                      ; preds = %lor.lhs.false, %if.end.134
  %69 = load i64, i64* %nchars, align 8
  %inc144 = add nsw i64 %69, 1
  store i64 %inc144, i64* %nchars, align 8
  %70 = load i64, i64* %cbytes, align 8
  %71 = load i64, i64* %nbytes, align 8
  %add145 = add nsw i64 %71, %70
  store i64 %add145, i64* %nbytes, align 8
  br label %if.end.146

if.end.146:                                       ; preds = %if.then.143, %lor.lhs.false
  br label %for.inc.147

for.inc.147:                                      ; preds = %if.end.146
  %72 = load i64, i64* %i31, align 8
  %inc148 = add nsw i64 %72, 1
  store i64 %inc148, i64* %i31, align 8
  %73 = load i64, i64* %cbytes, align 8
  %74 = load i64, i64* %ibyte, align 8
  %add149 = add nsw i64 %74, %73
  store i64 %add149, i64* %ibyte, align 8
  br label %for.cond.32

for.end.150:                                      ; preds = %for.cond.32
  %75 = load i64, i64* %nchars, align 8
  %76 = load i64, i64* %seq.addr, align 8
  %call151 = call i64 @SCHARS(i64 %76)
  %cmp152 = icmp ne i64 %75, %call151
  br i1 %cmp152, label %if.then.154, label %if.end.309

if.then.154:                                      ; preds = %for.end.150
  %77 = load i64, i64* %nchars, align 8
  %78 = load i64, i64* %nbytes, align 8
  %call155 = call i64 @make_uninit_multibyte_string(i64 %77, i64 %78)
  store i64 %call155, i64* %tem, align 8
  %79 = load i64, i64* %seq.addr, align 8
  %call156 = call zeroext i1 @STRING_MULTIBYTE(i64 %79)
  br i1 %call156, label %if.end.165, label %if.then.157

if.then.157:                                      ; preds = %if.then.154
  br label %do.body

do.body:                                          ; preds = %if.then.157
  %80 = load i64, i64* %tem, align 8
  %call158 = call %struct.Lisp_String* @XSTRING(i64 %80)
  %size = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %call158, i32 0, i32 0
  %81 = load i64, i64* %size, align 8
  %cmp159 = icmp eq i64 %81, 0
  br i1 %cmp159, label %if.then.161, label %if.else.162

if.then.161:                                      ; preds = %do.body
  %82 = load i64, i64* @empty_unibyte_string, align 8
  store i64 %82, i64* %tem, align 8
  br label %if.end.164

if.else.162:                                      ; preds = %do.body
  %83 = load i64, i64* %tem, align 8
  %call163 = call %struct.Lisp_String* @XSTRING(i64 %83)
  %size_byte = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %call163, i32 0, i32 1
  store i64 -1, i64* %size_byte, align 8
  br label %if.end.164

if.end.164:                                       ; preds = %if.else.162, %if.then.161
  br label %do.end

do.end:                                           ; preds = %if.end.164
  br label %if.end.165

if.end.165:                                       ; preds = %do.end, %if.then.154
  store i64 0, i64* %ibyte, align 8
  store i64 0, i64* %nbytes, align 8
  store i64 0, i64* %nchars, align 8
  store i64 0, i64* %i31, align 8
  br label %for.cond.166

for.cond.166:                                     ; preds = %for.inc.305, %if.end.165
  %84 = load i64, i64* %i31, align 8
  %85 = load i64, i64* %seq.addr, align 8
  %call167 = call i64 @SCHARS(i64 %85)
  %cmp168 = icmp slt i64 %84, %call167
  br i1 %cmp168, label %for.body.170, label %for.end.308

for.body.170:                                     ; preds = %for.cond.166
  %86 = load i64, i64* %seq.addr, align 8
  %call171 = call zeroext i1 @STRING_MULTIBYTE(i64 %86)
  br i1 %call171, label %if.then.172, label %if.else.277

if.then.172:                                      ; preds = %for.body.170
  %87 = load i64, i64* %seq.addr, align 8
  %call173 = call i8* @SDATA(i64 %87)
  %88 = load i64, i64* %ibyte, align 8
  %add.ptr174 = getelementptr inbounds i8, i8* %call173, i64 %88
  %arrayidx175 = getelementptr inbounds i8, i8* %add.ptr174, i64 0
  %89 = load i8, i8* %arrayidx175, align 1
  %conv176 = zext i8 %89 to i32
  %and177 = and i32 %conv176, 128
  %tobool178 = icmp ne i32 %and177, 0
  br i1 %tobool178, label %cond.false.184, label %cond.true.179

cond.true.179:                                    ; preds = %if.then.172
  %90 = load i64, i64* %seq.addr, align 8
  %call180 = call i8* @SDATA(i64 %90)
  %91 = load i64, i64* %ibyte, align 8
  %add.ptr181 = getelementptr inbounds i8, i8* %call180, i64 %91
  %arrayidx182 = getelementptr inbounds i8, i8* %add.ptr181, i64 0
  %92 = load i8, i8* %arrayidx182, align 1
  %conv183 = zext i8 %92 to i32
  br label %cond.end.247

cond.false.184:                                   ; preds = %if.then.172
  %93 = load i64, i64* %seq.addr, align 8
  %call185 = call i8* @SDATA(i64 %93)
  %94 = load i64, i64* %ibyte, align 8
  %add.ptr186 = getelementptr inbounds i8, i8* %call185, i64 %94
  %arrayidx187 = getelementptr inbounds i8, i8* %add.ptr186, i64 0
  %95 = load i8, i8* %arrayidx187, align 1
  %conv188 = zext i8 %95 to i32
  %and189 = and i32 %conv188, 32
  %tobool190 = icmp ne i32 %and189, 0
  br i1 %tobool190, label %cond.false.212, label %cond.true.191

cond.true.191:                                    ; preds = %cond.false.184
  %96 = load i64, i64* %seq.addr, align 8
  %call192 = call i8* @SDATA(i64 %96)
  %97 = load i64, i64* %ibyte, align 8
  %add.ptr193 = getelementptr inbounds i8, i8* %call192, i64 %97
  %arrayidx194 = getelementptr inbounds i8, i8* %add.ptr193, i64 0
  %98 = load i8, i8* %arrayidx194, align 1
  %conv195 = zext i8 %98 to i32
  %and196 = and i32 %conv195, 31
  %shl197 = shl i32 %and196, 6
  %99 = load i64, i64* %seq.addr, align 8
  %call198 = call i8* @SDATA(i64 %99)
  %100 = load i64, i64* %ibyte, align 8
  %add.ptr199 = getelementptr inbounds i8, i8* %call198, i64 %100
  %arrayidx200 = getelementptr inbounds i8, i8* %add.ptr199, i64 1
  %101 = load i8, i8* %arrayidx200, align 1
  %conv201 = zext i8 %101 to i32
  %and202 = and i32 %conv201, 63
  %or203 = or i32 %shl197, %and202
  %102 = load i64, i64* %seq.addr, align 8
  %call204 = call i8* @SDATA(i64 %102)
  %103 = load i64, i64* %ibyte, align 8
  %add.ptr205 = getelementptr inbounds i8, i8* %call204, i64 %103
  %arrayidx206 = getelementptr inbounds i8, i8* %add.ptr205, i64 0
  %104 = load i8, i8* %arrayidx206, align 1
  %conv207 = zext i8 %104 to i32
  %cmp208 = icmp slt i32 %conv207, 194
  %cond210 = select i1 %cmp208, i32 4194176, i32 0
  %add211 = add nsw i32 %or203, %cond210
  br label %cond.end.245

cond.false.212:                                   ; preds = %cond.false.184
  %105 = load i64, i64* %seq.addr, align 8
  %call213 = call i8* @SDATA(i64 %105)
  %106 = load i64, i64* %ibyte, align 8
  %add.ptr214 = getelementptr inbounds i8, i8* %call213, i64 %106
  %arrayidx215 = getelementptr inbounds i8, i8* %add.ptr214, i64 0
  %107 = load i8, i8* %arrayidx215, align 1
  %conv216 = zext i8 %107 to i32
  %and217 = and i32 %conv216, 16
  %tobool218 = icmp ne i32 %and217, 0
  br i1 %tobool218, label %cond.false.239, label %cond.true.219

cond.true.219:                                    ; preds = %cond.false.212
  %108 = load i64, i64* %seq.addr, align 8
  %call220 = call i8* @SDATA(i64 %108)
  %109 = load i64, i64* %ibyte, align 8
  %add.ptr221 = getelementptr inbounds i8, i8* %call220, i64 %109
  %arrayidx222 = getelementptr inbounds i8, i8* %add.ptr221, i64 0
  %110 = load i8, i8* %arrayidx222, align 1
  %conv223 = zext i8 %110 to i32
  %and224 = and i32 %conv223, 15
  %shl225 = shl i32 %and224, 12
  %111 = load i64, i64* %seq.addr, align 8
  %call226 = call i8* @SDATA(i64 %111)
  %112 = load i64, i64* %ibyte, align 8
  %add.ptr227 = getelementptr inbounds i8, i8* %call226, i64 %112
  %arrayidx228 = getelementptr inbounds i8, i8* %add.ptr227, i64 1
  %113 = load i8, i8* %arrayidx228, align 1
  %conv229 = zext i8 %113 to i32
  %and230 = and i32 %conv229, 63
  %shl231 = shl i32 %and230, 6
  %or232 = or i32 %shl225, %shl231
  %114 = load i64, i64* %seq.addr, align 8
  %call233 = call i8* @SDATA(i64 %114)
  %115 = load i64, i64* %ibyte, align 8
  %add.ptr234 = getelementptr inbounds i8, i8* %call233, i64 %115
  %arrayidx235 = getelementptr inbounds i8, i8* %add.ptr234, i64 2
  %116 = load i8, i8* %arrayidx235, align 1
  %conv236 = zext i8 %116 to i32
  %and237 = and i32 %conv236, 63
  %or238 = or i32 %or232, %and237
  br label %cond.end.243

cond.false.239:                                   ; preds = %cond.false.212
  %117 = load i64, i64* %seq.addr, align 8
  %call240 = call i8* @SDATA(i64 %117)
  %118 = load i64, i64* %ibyte, align 8
  %add.ptr241 = getelementptr inbounds i8, i8* %call240, i64 %118
  %call242 = call i32 @string_char(i8* %add.ptr241, i8** null, i32* null)
  br label %cond.end.243

cond.end.243:                                     ; preds = %cond.false.239, %cond.true.219
  %cond244 = phi i32 [ %or238, %cond.true.219 ], [ %call242, %cond.false.239 ]
  br label %cond.end.245

cond.end.245:                                     ; preds = %cond.end.243, %cond.true.191
  %cond246 = phi i32 [ %add211, %cond.true.191 ], [ %cond244, %cond.end.243 ]
  br label %cond.end.247

cond.end.247:                                     ; preds = %cond.end.245, %cond.true.179
  %cond248 = phi i32 [ %conv183, %cond.true.179 ], [ %cond246, %cond.end.245 ]
  store i32 %cond248, i32* %c, align 4
  %119 = load i32, i32* %c, align 4
  %cmp249 = icmp sle i32 %119, 127
  br i1 %cmp249, label %cond.true.251, label %cond.false.252

cond.true.251:                                    ; preds = %cond.end.247
  br label %cond.end.274

cond.false.252:                                   ; preds = %cond.end.247
  %120 = load i32, i32* %c, align 4
  %cmp253 = icmp sle i32 %120, 2047
  br i1 %cmp253, label %cond.true.255, label %cond.false.256

cond.true.255:                                    ; preds = %cond.false.252
  br label %cond.end.272

cond.false.256:                                   ; preds = %cond.false.252
  %121 = load i32, i32* %c, align 4
  %cmp257 = icmp sle i32 %121, 65535
  br i1 %cmp257, label %cond.true.259, label %cond.false.260

cond.true.259:                                    ; preds = %cond.false.256
  br label %cond.end.270

cond.false.260:                                   ; preds = %cond.false.256
  %122 = load i32, i32* %c, align 4
  %cmp261 = icmp sle i32 %122, 2097151
  br i1 %cmp261, label %cond.true.263, label %cond.false.264

cond.true.263:                                    ; preds = %cond.false.260
  br label %cond.end.268

cond.false.264:                                   ; preds = %cond.false.260
  %123 = load i32, i32* %c, align 4
  %cmp265 = icmp sle i32 %123, 4194175
  %cond267 = select i1 %cmp265, i32 5, i32 2
  br label %cond.end.268

cond.end.268:                                     ; preds = %cond.false.264, %cond.true.263
  %cond269 = phi i32 [ 4, %cond.true.263 ], [ %cond267, %cond.false.264 ]
  br label %cond.end.270

cond.end.270:                                     ; preds = %cond.end.268, %cond.true.259
  %cond271 = phi i32 [ 3, %cond.true.259 ], [ %cond269, %cond.end.268 ]
  br label %cond.end.272

cond.end.272:                                     ; preds = %cond.end.270, %cond.true.255
  %cond273 = phi i32 [ 2, %cond.true.255 ], [ %cond271, %cond.end.270 ]
  br label %cond.end.274

cond.end.274:                                     ; preds = %cond.end.272, %cond.true.251
  %cond275 = phi i32 [ 1, %cond.true.251 ], [ %cond273, %cond.end.272 ]
  %conv276 = sext i32 %cond275 to i64
  store i64 %conv276, i64* %cbytes, align 8
  br label %if.end.280

if.else.277:                                      ; preds = %for.body.170
  %124 = load i64, i64* %seq.addr, align 8
  %125 = load i64, i64* %i31, align 8
  %call278 = call zeroext i8 @SREF(i64 %124, i64 %125)
  %conv279 = zext i8 %call278 to i32
  store i32 %conv279, i32* %c, align 4
  store i64 1, i64* %cbytes, align 8
  br label %if.end.280

if.end.280:                                       ; preds = %if.else.277, %cond.end.274
  %126 = load i64, i64* %elt.addr, align 8
  %and281 = and i64 %126, 7
  %conv282 = trunc i64 %and281 to i32
  %and283 = and i32 %conv282, -5
  %cmp284 = icmp eq i32 %and283, 2
  br i1 %cmp284, label %lor.lhs.false.286, label %if.then.291

lor.lhs.false.286:                                ; preds = %if.end.280
  %127 = load i32, i32* %c, align 4
  %conv287 = sext i32 %127 to i64
  %128 = load i64, i64* %elt.addr, align 8
  %shr288 = ashr i64 %128, 2
  %cmp289 = icmp ne i64 %conv287, %shr288
  br i1 %cmp289, label %if.then.291, label %if.end.304

if.then.291:                                      ; preds = %lor.lhs.false.286, %if.end.280
  %129 = load i64, i64* %seq.addr, align 8
  %call292 = call i8* @SDATA(i64 %129)
  %130 = load i64, i64* %ibyte, align 8
  %add.ptr293 = getelementptr inbounds i8, i8* %call292, i64 %130
  store i8* %add.ptr293, i8** %from, align 8
  %131 = load i64, i64* %tem, align 8
  %call294 = call i8* @SDATA(i64 %131)
  %132 = load i64, i64* %nbytes, align 8
  %add.ptr295 = getelementptr inbounds i8, i8* %call294, i64 %132
  store i8* %add.ptr295, i8** %to, align 8
  %133 = load i64, i64* %nchars, align 8
  %inc297 = add nsw i64 %133, 1
  store i64 %inc297, i64* %nchars, align 8
  %134 = load i64, i64* %cbytes, align 8
  %135 = load i64, i64* %nbytes, align 8
  %add298 = add nsw i64 %135, %134
  store i64 %add298, i64* %nbytes, align 8
  %136 = load i64, i64* %cbytes, align 8
  store i64 %136, i64* %n296, align 8
  br label %for.cond.299

for.cond.299:                                     ; preds = %for.body.301, %if.then.291
  %137 = load i64, i64* %n296, align 8
  %dec = add nsw i64 %137, -1
  store i64 %dec, i64* %n296, align 8
  %tobool300 = icmp ne i64 %137, 0
  br i1 %tobool300, label %for.body.301, label %for.end.303

for.body.301:                                     ; preds = %for.cond.299
  %138 = load i8*, i8** %from, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %138, i32 1
  store i8* %incdec.ptr, i8** %from, align 8
  %139 = load i8, i8* %138, align 1
  %140 = load i8*, i8** %to, align 8
  %incdec.ptr302 = getelementptr inbounds i8, i8* %140, i32 1
  store i8* %incdec.ptr302, i8** %to, align 8
  store i8 %139, i8* %140, align 1
  br label %for.cond.299

for.end.303:                                      ; preds = %for.cond.299
  br label %if.end.304

if.end.304:                                       ; preds = %for.end.303, %lor.lhs.false.286
  br label %for.inc.305

for.inc.305:                                      ; preds = %if.end.304
  %141 = load i64, i64* %i31, align 8
  %inc306 = add nsw i64 %141, 1
  store i64 %inc306, i64* %i31, align 8
  %142 = load i64, i64* %cbytes, align 8
  %143 = load i64, i64* %ibyte, align 8
  %add307 = add nsw i64 %143, %142
  store i64 %add307, i64* %ibyte, align 8
  br label %for.cond.166

for.end.308:                                      ; preds = %for.cond.166
  %144 = load i64, i64* %tem, align 8
  store i64 %144, i64* %seq.addr, align 8
  br label %if.end.309

if.end.309:                                       ; preds = %for.end.308, %for.end.150
  br label %if.end.363

if.else.310:                                      ; preds = %if.else
  %145 = load i64, i64* %seq.addr, align 8
  store i64 %145, i64* %tail, align 8
  %call311 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call311, i64* %prev, align 8
  br label %for.cond.312

for.cond.312:                                     ; preds = %for.inc.358, %if.else.310
  %146 = load i64, i64* %tail, align 8
  %and313 = and i64 %146, 7
  %conv314 = trunc i64 %and313 to i32
  %cmp315 = icmp eq i32 %conv314, 3
  br i1 %cmp315, label %for.body.317, label %for.end.362

for.body.317:                                     ; preds = %for.cond.312
  %147 = load i64, i64* %tail, align 8
  %and318 = and i64 %147, 7
  %conv319 = trunc i64 %and318 to i32
  %cmp320 = icmp eq i32 %conv319, 3
  br i1 %cmp320, label %cond.true.322, label %cond.false.323

cond.true.322:                                    ; preds = %for.body.317
  br label %cond.end.325

cond.false.323:                                   ; preds = %for.body.317
  %call324 = call i64 @builtin_lisp_symbol(i32 626)
  %148 = load i64, i64* %seq.addr, align 8
  %149 = call i64 @wrong_type_argument(i64 %call324, i64 %148) #8
  unreachable
                                                  ; No predecessors!
  br label %cond.end.325

cond.end.325:                                     ; preds = %150, %cond.true.322
  %151 = load i64, i64* %elt.addr, align 8
  %152 = load i64, i64* %tail, align 8
  %sub = sub nsw i64 %152, 3
  %153 = inttoptr i64 %sub to i8*
  %154 = bitcast i8* %153 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %154, i32 0, i32 0
  %155 = load i64, i64* %car, align 8
  %call326 = call i64 @Fequal(i64 %151, i64 %155)
  %call327 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp328 = icmp eq i64 %call326, %call327
  br i1 %cmp328, label %if.else.342, label %if.then.330

if.then.330:                                      ; preds = %cond.end.325
  %156 = load i64, i64* %prev, align 8
  %call331 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp332 = icmp eq i64 %156, %call331
  br i1 %cmp332, label %if.then.334, label %if.else.336

if.then.334:                                      ; preds = %if.then.330
  %157 = load i64, i64* %tail, align 8
  %sub335 = sub nsw i64 %157, 3
  %158 = inttoptr i64 %sub335 to i8*
  %159 = bitcast i8* %158 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %159, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %160 = load i64, i64* %cdr, align 8
  store i64 %160, i64* %seq.addr, align 8
  br label %if.end.341

if.else.336:                                      ; preds = %if.then.330
  %161 = load i64, i64* %prev, align 8
  %162 = load i64, i64* %tail, align 8
  %sub337 = sub nsw i64 %162, 3
  %163 = inttoptr i64 %sub337 to i8*
  %164 = bitcast i8* %163 to %struct.Lisp_Cons*
  %u338 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %164, i32 0, i32 1
  %cdr339 = bitcast %union.anon* %u338 to i64*
  %165 = load i64, i64* %cdr339, align 8
  %call340 = call i64 @Fsetcdr(i64 %161, i64 %165)
  br label %if.end.341

if.end.341:                                       ; preds = %if.else.336, %if.then.334
  br label %if.end.343

if.else.342:                                      ; preds = %cond.end.325
  %166 = load i64, i64* %tail, align 8
  store i64 %166, i64* %prev, align 8
  br label %if.end.343

if.end.343:                                       ; preds = %if.else.342, %if.end.341
  br label %do.body.344

do.body.344:                                      ; preds = %if.end.343
  %167 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call345 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp346 = icmp eq i64 %167, %call345
  br i1 %cmp346, label %if.else.352, label %land.lhs.true

land.lhs.true:                                    ; preds = %do.body.344
  %168 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  %call348 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp349 = icmp eq i64 %168, %call348
  br i1 %cmp349, label %if.then.351, label %if.else.352

if.then.351:                                      ; preds = %land.lhs.true
  call void @process_quit_flag()
  br label %if.end.356

if.else.352:                                      ; preds = %land.lhs.true, %do.body.344
  %169 = load volatile i8, i8* @pending_signals, align 1
  %tobool353 = trunc i8 %169 to i1
  br i1 %tobool353, label %if.then.354, label %if.end.355

if.then.354:                                      ; preds = %if.else.352
  call void @process_pending_signals()
  br label %if.end.355

if.end.355:                                       ; preds = %if.then.354, %if.else.352
  br label %if.end.356

if.end.356:                                       ; preds = %if.end.355, %if.then.351
  br label %do.end.357

do.end.357:                                       ; preds = %if.end.356
  br label %for.inc.358

for.inc.358:                                      ; preds = %do.end.357
  %170 = load i64, i64* %tail, align 8
  %sub359 = sub nsw i64 %170, 3
  %171 = inttoptr i64 %sub359 to i8*
  %172 = bitcast i8* %171 to %struct.Lisp_Cons*
  %u360 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %172, i32 0, i32 1
  %cdr361 = bitcast %union.anon* %u360 to i64*
  %173 = load i64, i64* %cdr361, align 8
  store i64 %173, i64* %tail, align 8
  br label %for.cond.312

for.end.362:                                      ; preds = %for.cond.312
  br label %if.end.363

if.end.363:                                       ; preds = %for.end.362, %if.end.309
  br label %if.end.364

if.end.364:                                       ; preds = %if.end.363, %if.end.28
  %174 = load i64, i64* %seq.addr, align 8
  ret i64 %174
}

declare i64 @AREF(i64, i64) #2

declare %struct.Lisp_Vector* @allocate_vector(i64) #2

declare i64 @make_lisp_ptr(i8*, i32) #2

declare %struct.Lisp_String* @XSTRING(i64) #2

; Function Attrs: nounwind uwtable
define i64 @Fnreverse(i64 %seq) #1 {
entry:
  %retval = alloca i64, align 8
  %seq.addr = alloca i64, align 8
  %prev = alloca i64, align 8
  %tail = alloca i64, align 8
  %next = alloca i64, align 8
  %i = alloca i64, align 8
  %size = alloca i64, align 8
  %tem = alloca i64, align 8
  %i47 = alloca i64, align 8
  %size48 = alloca i64, align 8
  %tem55 = alloca i8, align 1
  store i64 %seq, i64* %seq.addr, align 8
  %0 = load i64, i64* %seq.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %0, %call
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i64, i64* %seq.addr, align 8
  store i64 %1, i64* %retval
  br label %return

if.else:                                          ; preds = %entry
  %2 = load i64, i64* %seq.addr, align 8
  %call1 = call zeroext i1 @STRINGP(i64 %2)
  br i1 %call1, label %if.then.2, label %if.else.4

if.then.2:                                        ; preds = %if.else
  %3 = load i64, i64* %seq.addr, align 8
  %call3 = call i64 @Freverse(i64 %3)
  store i64 %call3, i64* %retval
  br label %return

if.else.4:                                        ; preds = %if.else
  %4 = load i64, i64* %seq.addr, align 8
  %and = and i64 %4, 7
  %conv = trunc i64 %and to i32
  %cmp5 = icmp eq i32 %conv, 3
  br i1 %cmp5, label %if.then.7, label %if.else.28

if.then.7:                                        ; preds = %if.else.4
  %call8 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call8, i64* %prev, align 8
  %5 = load i64, i64* %seq.addr, align 8
  store i64 %5, i64* %tail, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then.7
  %6 = load i64, i64* %tail, align 8
  %call9 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp10 = icmp eq i64 %6, %call9
  %lnot = xor i1 %cmp10, true
  br i1 %lnot, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %do.body

do.body:                                          ; preds = %for.body
  %7 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call12 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp13 = icmp eq i64 %7, %call12
  br i1 %cmp13, label %if.else.19, label %land.lhs.true

land.lhs.true:                                    ; preds = %do.body
  %8 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  %call15 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp16 = icmp eq i64 %8, %call15
  br i1 %cmp16, label %if.then.18, label %if.else.19

if.then.18:                                       ; preds = %land.lhs.true
  call void @process_quit_flag()
  br label %if.end.21

if.else.19:                                       ; preds = %land.lhs.true, %do.body
  %9 = load volatile i8, i8* @pending_signals, align 1
  %tobool = trunc i8 %9 to i1
  br i1 %tobool, label %if.then.20, label %if.end

if.then.20:                                       ; preds = %if.else.19
  call void @process_pending_signals()
  br label %if.end

if.end:                                           ; preds = %if.then.20, %if.else.19
  br label %if.end.21

if.end.21:                                        ; preds = %if.end, %if.then.18
  br label %do.end

do.end:                                           ; preds = %if.end.21
  %10 = load i64, i64* %tail, align 8
  %and22 = and i64 %10, 7
  %conv23 = trunc i64 %and22 to i32
  %cmp24 = icmp eq i32 %conv23, 3
  br i1 %cmp24, label %cond.true, label %cond.false

cond.true:                                        ; preds = %do.end
  br label %cond.end

cond.false:                                       ; preds = %do.end
  %call26 = call i64 @builtin_lisp_symbol(i32 626)
  %11 = load i64, i64* %tail, align 8
  %12 = call i64 @wrong_type_argument(i64 %call26, i64 %11) #8
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %13, %cond.true
  %14 = load i64, i64* %tail, align 8
  %sub = sub nsw i64 %14, 3
  %15 = inttoptr i64 %sub to i8*
  %16 = bitcast i8* %15 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %16, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %17 = load i64, i64* %cdr, align 8
  store i64 %17, i64* %next, align 8
  %18 = load i64, i64* %tail, align 8
  %19 = load i64, i64* %prev, align 8
  %call27 = call i64 @Fsetcdr(i64 %18, i64 %19)
  %20 = load i64, i64* %tail, align 8
  store i64 %20, i64* %prev, align 8
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %21 = load i64, i64* %next, align 8
  store i64 %21, i64* %tail, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %22 = load i64, i64* %prev, align 8
  store i64 %22, i64* %seq.addr, align 8
  br label %if.end.70

if.else.28:                                       ; preds = %if.else.4
  %23 = load i64, i64* %seq.addr, align 8
  %call29 = call zeroext i1 @VECTORP(i64 %23)
  br i1 %call29, label %if.then.30, label %if.else.44

if.then.30:                                       ; preds = %if.else.28
  %24 = load i64, i64* %seq.addr, align 8
  %call31 = call i64 @ASIZE(i64 %24)
  store i64 %call31, i64* %size, align 8
  store i64 0, i64* %i, align 8
  br label %for.cond.32

for.cond.32:                                      ; preds = %for.inc.42, %if.then.30
  %25 = load i64, i64* %i, align 8
  %26 = load i64, i64* %size, align 8
  %div = sdiv i64 %26, 2
  %cmp33 = icmp slt i64 %25, %div
  br i1 %cmp33, label %for.body.35, label %for.end.43

for.body.35:                                      ; preds = %for.cond.32
  %27 = load i64, i64* %seq.addr, align 8
  %28 = load i64, i64* %i, align 8
  %call36 = call i64 @AREF(i64 %27, i64 %28)
  store i64 %call36, i64* %tem, align 8
  %29 = load i64, i64* %seq.addr, align 8
  %30 = load i64, i64* %i, align 8
  %31 = load i64, i64* %seq.addr, align 8
  %32 = load i64, i64* %size, align 8
  %33 = load i64, i64* %i, align 8
  %sub37 = sub nsw i64 %32, %33
  %sub38 = sub nsw i64 %sub37, 1
  %call39 = call i64 @AREF(i64 %31, i64 %sub38)
  call void @ASET(i64 %29, i64 %30, i64 %call39)
  %34 = load i64, i64* %seq.addr, align 8
  %35 = load i64, i64* %size, align 8
  %36 = load i64, i64* %i, align 8
  %sub40 = sub nsw i64 %35, %36
  %sub41 = sub nsw i64 %sub40, 1
  %37 = load i64, i64* %tem, align 8
  call void @ASET(i64 %34, i64 %sub41, i64 %37)
  br label %for.inc.42

for.inc.42:                                       ; preds = %for.body.35
  %38 = load i64, i64* %i, align 8
  %inc = add nsw i64 %38, 1
  store i64 %inc, i64* %i, align 8
  br label %for.cond.32

for.end.43:                                       ; preds = %for.cond.32
  br label %if.end.69

if.else.44:                                       ; preds = %if.else.28
  %39 = load i64, i64* %seq.addr, align 8
  %call45 = call zeroext i1 @BOOL_VECTOR_P(i64 %39)
  br i1 %call45, label %if.then.46, label %if.else.66

if.then.46:                                       ; preds = %if.else.44
  %40 = load i64, i64* %seq.addr, align 8
  %call49 = call i64 @bool_vector_size(i64 %40)
  store i64 %call49, i64* %size48, align 8
  store i64 0, i64* %i47, align 8
  br label %for.cond.50

for.cond.50:                                      ; preds = %for.inc.63, %if.then.46
  %41 = load i64, i64* %i47, align 8
  %42 = load i64, i64* %size48, align 8
  %div51 = sdiv i64 %42, 2
  %cmp52 = icmp slt i64 %41, %div51
  br i1 %cmp52, label %for.body.54, label %for.end.65

for.body.54:                                      ; preds = %for.cond.50
  %43 = load i64, i64* %seq.addr, align 8
  %44 = load i64, i64* %i47, align 8
  %call56 = call zeroext i1 @bool_vector_bitref(i64 %43, i64 %44)
  %frombool = zext i1 %call56 to i8
  store i8 %frombool, i8* %tem55, align 1
  %45 = load i64, i64* %seq.addr, align 8
  %46 = load i64, i64* %i47, align 8
  %47 = load i64, i64* %seq.addr, align 8
  %48 = load i64, i64* %size48, align 8
  %49 = load i64, i64* %i47, align 8
  %sub57 = sub nsw i64 %48, %49
  %sub58 = sub nsw i64 %sub57, 1
  %call59 = call zeroext i1 @bool_vector_bitref(i64 %47, i64 %sub58)
  call void @bool_vector_set(i64 %45, i64 %46, i1 zeroext %call59)
  %50 = load i64, i64* %seq.addr, align 8
  %51 = load i64, i64* %size48, align 8
  %52 = load i64, i64* %i47, align 8
  %sub60 = sub nsw i64 %51, %52
  %sub61 = sub nsw i64 %sub60, 1
  %53 = load i8, i8* %tem55, align 1
  %tobool62 = trunc i8 %53 to i1
  call void @bool_vector_set(i64 %50, i64 %sub61, i1 zeroext %tobool62)
  br label %for.inc.63

for.inc.63:                                       ; preds = %for.body.54
  %54 = load i64, i64* %i47, align 8
  %inc64 = add nsw i64 %54, 1
  store i64 %inc64, i64* %i47, align 8
  br label %for.cond.50

for.end.65:                                       ; preds = %for.cond.50
  br label %if.end.68

if.else.66:                                       ; preds = %if.else.44
  %call67 = call i64 @builtin_lisp_symbol(i32 179)
  %55 = load i64, i64* %seq.addr, align 8
  %56 = call i64 @wrong_type_argument(i64 %call67, i64 %55) #8
  unreachable

if.end.68:                                        ; preds = %for.end.65
  br label %if.end.69

if.end.69:                                        ; preds = %if.end.68, %for.end.43
  br label %if.end.70

if.end.70:                                        ; preds = %if.end.69, %for.end
  br label %if.end.71

if.end.71:                                        ; preds = %if.end.70
  br label %if.end.72

if.end.72:                                        ; preds = %if.end.71
  %57 = load i64, i64* %seq.addr, align 8
  store i64 %57, i64* %retval
  br label %return

return:                                           ; preds = %if.end.72, %if.then.2, %if.then
  %58 = load i64, i64* %retval
  ret i64 %58
}

; Function Attrs: nounwind uwtable
define i64 @Freverse(i64 %seq) #1 {
entry:
  %retval = alloca i64, align 8
  %seq.addr = alloca i64, align 8
  %new = alloca i64, align 8
  %i = alloca i64, align 8
  %size = alloca i64, align 8
  %i39 = alloca i64, align 8
  %nbits = alloca i64, align 8
  %size55 = alloca i64, align 8
  %bytes = alloca i64, align 8
  %i61 = alloca i64, align 8
  %p = alloca i8*, align 8
  %q = alloca i8*, align 8
  %ch = alloca i32, align 4
  %len = alloca i32, align 4
  store i64 %seq, i64* %seq.addr, align 8
  %0 = load i64, i64* %seq.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %0, %call
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call1, i64* %retval
  br label %return

if.else:                                          ; preds = %entry
  %1 = load i64, i64* %seq.addr, align 8
  %and = and i64 %1, 7
  %conv = trunc i64 %and to i32
  %cmp2 = icmp eq i32 %conv, 3
  br i1 %cmp2, label %if.then.4, label %if.else.22

if.then.4:                                        ; preds = %if.else
  %call5 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call5, i64* %new, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then.4
  %2 = load i64, i64* %seq.addr, align 8
  %and6 = and i64 %2, 7
  %conv7 = trunc i64 %and6 to i32
  %cmp8 = icmp eq i32 %conv7, 3
  br i1 %cmp8, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %do.body

do.body:                                          ; preds = %for.body
  %3 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call10 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp11 = icmp eq i64 %3, %call10
  br i1 %cmp11, label %if.else.17, label %land.lhs.true

land.lhs.true:                                    ; preds = %do.body
  %4 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  %call13 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp14 = icmp eq i64 %4, %call13
  br i1 %cmp14, label %if.then.16, label %if.else.17

if.then.16:                                       ; preds = %land.lhs.true
  call void @process_quit_flag()
  br label %if.end.19

if.else.17:                                       ; preds = %land.lhs.true, %do.body
  %5 = load volatile i8, i8* @pending_signals, align 1
  %tobool = trunc i8 %5 to i1
  br i1 %tobool, label %if.then.18, label %if.end

if.then.18:                                       ; preds = %if.else.17
  call void @process_pending_signals()
  br label %if.end

if.end:                                           ; preds = %if.then.18, %if.else.17
  br label %if.end.19

if.end.19:                                        ; preds = %if.end, %if.then.16
  br label %do.end

do.end:                                           ; preds = %if.end.19
  %6 = load i64, i64* %seq.addr, align 8
  %sub = sub nsw i64 %6, 3
  %7 = inttoptr i64 %sub to i8*
  %8 = bitcast i8* %7 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %8, i32 0, i32 0
  %9 = load i64, i64* %car, align 8
  %10 = load i64, i64* %new, align 8
  %call20 = call i64 @Fcons(i64 %9, i64 %10)
  store i64 %call20, i64* %new, align 8
  br label %for.inc

for.inc:                                          ; preds = %do.end
  %11 = load i64, i64* %seq.addr, align 8
  %sub21 = sub nsw i64 %11, 3
  %12 = inttoptr i64 %sub21 to i8*
  %13 = bitcast i8* %12 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %13, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %14 = load i64, i64* %cdr, align 8
  store i64 %14, i64* %seq.addr, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %15 = load i64, i64* %seq.addr, align 8
  %16 = load i64, i64* %seq.addr, align 8
  call void @CHECK_LIST_END(i64 %15, i64 %16)
  br label %if.end.197

if.else.22:                                       ; preds = %if.else
  %17 = load i64, i64* %seq.addr, align 8
  %call23 = call zeroext i1 @VECTORP(i64 %17)
  br i1 %call23, label %if.then.24, label %if.else.36

if.then.24:                                       ; preds = %if.else.22
  %18 = load i64, i64* %seq.addr, align 8
  %call25 = call i64 @ASIZE(i64 %18)
  store i64 %call25, i64* %size, align 8
  %19 = load i64, i64* %size, align 8
  %call26 = call i64 @make_uninit_vector(i64 %19)
  store i64 %call26, i64* %new, align 8
  store i64 0, i64* %i, align 8
  br label %for.cond.27

for.cond.27:                                      ; preds = %for.inc.34, %if.then.24
  %20 = load i64, i64* %i, align 8
  %21 = load i64, i64* %size, align 8
  %cmp28 = icmp slt i64 %20, %21
  br i1 %cmp28, label %for.body.30, label %for.end.35

for.body.30:                                      ; preds = %for.cond.27
  %22 = load i64, i64* %new, align 8
  %23 = load i64, i64* %i, align 8
  %24 = load i64, i64* %seq.addr, align 8
  %25 = load i64, i64* %size, align 8
  %26 = load i64, i64* %i, align 8
  %sub31 = sub nsw i64 %25, %26
  %sub32 = sub nsw i64 %sub31, 1
  %call33 = call i64 @AREF(i64 %24, i64 %sub32)
  call void @ASET(i64 %22, i64 %23, i64 %call33)
  br label %for.inc.34

for.inc.34:                                       ; preds = %for.body.30
  %27 = load i64, i64* %i, align 8
  %inc = add nsw i64 %27, 1
  store i64 %inc, i64* %i, align 8
  br label %for.cond.27

for.end.35:                                       ; preds = %for.cond.27
  br label %if.end.196

if.else.36:                                       ; preds = %if.else.22
  %28 = load i64, i64* %seq.addr, align 8
  %call37 = call zeroext i1 @BOOL_VECTOR_P(i64 %28)
  br i1 %call37, label %if.then.38, label %if.else.52

if.then.38:                                       ; preds = %if.else.36
  %29 = load i64, i64* %seq.addr, align 8
  %call40 = call i64 @bool_vector_size(i64 %29)
  store i64 %call40, i64* %nbits, align 8
  %30 = load i64, i64* %nbits, align 8
  %call41 = call i64 @make_uninit_bool_vector(i64 %30)
  store i64 %call41, i64* %new, align 8
  store i64 0, i64* %i39, align 8
  br label %for.cond.42

for.cond.42:                                      ; preds = %for.inc.49, %if.then.38
  %31 = load i64, i64* %i39, align 8
  %32 = load i64, i64* %nbits, align 8
  %cmp43 = icmp slt i64 %31, %32
  br i1 %cmp43, label %for.body.45, label %for.end.51

for.body.45:                                      ; preds = %for.cond.42
  %33 = load i64, i64* %new, align 8
  %34 = load i64, i64* %i39, align 8
  %35 = load i64, i64* %seq.addr, align 8
  %36 = load i64, i64* %nbits, align 8
  %37 = load i64, i64* %i39, align 8
  %sub46 = sub nsw i64 %36, %37
  %sub47 = sub nsw i64 %sub46, 1
  %call48 = call zeroext i1 @bool_vector_bitref(i64 %35, i64 %sub47)
  call void @bool_vector_set(i64 %33, i64 %34, i1 zeroext %call48)
  br label %for.inc.49

for.inc.49:                                       ; preds = %for.body.45
  %38 = load i64, i64* %i39, align 8
  %inc50 = add nsw i64 %38, 1
  store i64 %inc50, i64* %i39, align 8
  br label %for.cond.42

for.end.51:                                       ; preds = %for.cond.42
  br label %if.end.195

if.else.52:                                       ; preds = %if.else.36
  %39 = load i64, i64* %seq.addr, align 8
  %call53 = call zeroext i1 @STRINGP(i64 %39)
  br i1 %call53, label %if.then.54, label %if.else.192

if.then.54:                                       ; preds = %if.else.52
  %40 = load i64, i64* %seq.addr, align 8
  %call56 = call i64 @SCHARS(i64 %40)
  store i64 %call56, i64* %size55, align 8
  %41 = load i64, i64* %seq.addr, align 8
  %call57 = call i64 @SBYTES(i64 %41)
  store i64 %call57, i64* %bytes, align 8
  %42 = load i64, i64* %size55, align 8
  %43 = load i64, i64* %bytes, align 8
  %cmp58 = icmp eq i64 %42, %43
  br i1 %cmp58, label %if.then.60, label %if.else.73

if.then.60:                                       ; preds = %if.then.54
  %44 = load i64, i64* %size55, align 8
  %call62 = call i64 @make_uninit_string(i64 %44)
  store i64 %call62, i64* %new, align 8
  store i64 0, i64* %i61, align 8
  br label %for.cond.63

for.cond.63:                                      ; preds = %for.inc.70, %if.then.60
  %45 = load i64, i64* %i61, align 8
  %46 = load i64, i64* %size55, align 8
  %cmp64 = icmp slt i64 %45, %46
  br i1 %cmp64, label %for.body.66, label %for.end.72

for.body.66:                                      ; preds = %for.cond.63
  %47 = load i64, i64* %new, align 8
  %48 = load i64, i64* %i61, align 8
  %49 = load i64, i64* %seq.addr, align 8
  %50 = load i64, i64* %size55, align 8
  %51 = load i64, i64* %i61, align 8
  %sub67 = sub nsw i64 %50, %51
  %sub68 = sub nsw i64 %sub67, 1
  %call69 = call zeroext i8 @SREF(i64 %49, i64 %sub68)
  call void @SSET(i64 %47, i64 %48, i8 zeroext %call69)
  br label %for.inc.70

for.inc.70:                                       ; preds = %for.body.66
  %52 = load i64, i64* %i61, align 8
  %inc71 = add nsw i64 %52, 1
  store i64 %inc71, i64* %i61, align 8
  br label %for.cond.63

for.end.72:                                       ; preds = %for.cond.63
  br label %if.end.191

if.else.73:                                       ; preds = %if.then.54
  %53 = load i64, i64* %size55, align 8
  %54 = load i64, i64* %bytes, align 8
  %call74 = call i64 @make_uninit_multibyte_string(i64 %53, i64 %54)
  store i64 %call74, i64* %new, align 8
  %55 = load i64, i64* %seq.addr, align 8
  %call75 = call i8* @SDATA(i64 %55)
  store i8* %call75, i8** %p, align 8
  %56 = load i64, i64* %new, align 8
  %call76 = call i8* @SDATA(i64 %56)
  %57 = load i64, i64* %bytes, align 8
  %add.ptr = getelementptr inbounds i8, i8* %call76, i64 %57
  store i8* %add.ptr, i8** %q, align 8
  br label %while.cond

while.cond:                                       ; preds = %cond.end.189, %if.else.73
  %58 = load i8*, i8** %q, align 8
  %59 = load i64, i64* %new, align 8
  %call77 = call i8* @SDATA(i64 %59)
  %cmp78 = icmp ugt i8* %58, %call77
  br i1 %cmp78, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %60 = load i8*, i8** %p, align 8
  %arrayidx = getelementptr inbounds i8, i8* %60, i64 0
  %61 = load i8, i8* %arrayidx, align 1
  %conv80 = zext i8 %61 to i32
  %and81 = and i32 %conv80, 128
  %tobool82 = icmp ne i32 %and81, 0
  br i1 %tobool82, label %cond.false, label %cond.true

cond.true:                                        ; preds = %while.body
  store i32 1, i32* %len, align 4
  %62 = load i8*, i8** %p, align 8
  %arrayidx83 = getelementptr inbounds i8, i8* %62, i64 0
  %63 = load i8, i8* %arrayidx83, align 1
  %conv84 = zext i8 %63 to i32
  br label %cond.end.124

cond.false:                                       ; preds = %while.body
  %64 = load i8*, i8** %p, align 8
  %arrayidx85 = getelementptr inbounds i8, i8* %64, i64 0
  %65 = load i8, i8* %arrayidx85, align 1
  %conv86 = zext i8 %65 to i32
  %and87 = and i32 %conv86, 32
  %tobool88 = icmp ne i32 %and87, 0
  br i1 %tobool88, label %cond.false.100, label %cond.true.89

cond.true.89:                                     ; preds = %cond.false
  store i32 2, i32* %len, align 4
  %66 = load i8*, i8** %p, align 8
  %arrayidx90 = getelementptr inbounds i8, i8* %66, i64 0
  %67 = load i8, i8* %arrayidx90, align 1
  %conv91 = zext i8 %67 to i32
  %and92 = and i32 %conv91, 31
  %shl = shl i32 %and92, 6
  %68 = load i8*, i8** %p, align 8
  %arrayidx93 = getelementptr inbounds i8, i8* %68, i64 1
  %69 = load i8, i8* %arrayidx93, align 1
  %conv94 = zext i8 %69 to i32
  %and95 = and i32 %conv94, 63
  %or = or i32 %shl, %and95
  %70 = load i8*, i8** %p, align 8
  %arrayidx96 = getelementptr inbounds i8, i8* %70, i64 0
  %71 = load i8, i8* %arrayidx96, align 1
  %conv97 = zext i8 %71 to i32
  %cmp98 = icmp slt i32 %conv97, 194
  %cond = select i1 %cmp98, i32 4194176, i32 0
  %add = add nsw i32 %or, %cond
  br label %cond.end.122

cond.false.100:                                   ; preds = %cond.false
  %72 = load i8*, i8** %p, align 8
  %arrayidx101 = getelementptr inbounds i8, i8* %72, i64 0
  %73 = load i8, i8* %arrayidx101, align 1
  %conv102 = zext i8 %73 to i32
  %and103 = and i32 %conv102, 16
  %tobool104 = icmp ne i32 %and103, 0
  br i1 %tobool104, label %cond.false.119, label %cond.true.105

cond.true.105:                                    ; preds = %cond.false.100
  store i32 3, i32* %len, align 4
  %74 = load i8*, i8** %p, align 8
  %arrayidx106 = getelementptr inbounds i8, i8* %74, i64 0
  %75 = load i8, i8* %arrayidx106, align 1
  %conv107 = zext i8 %75 to i32
  %and108 = and i32 %conv107, 15
  %shl109 = shl i32 %and108, 12
  %76 = load i8*, i8** %p, align 8
  %arrayidx110 = getelementptr inbounds i8, i8* %76, i64 1
  %77 = load i8, i8* %arrayidx110, align 1
  %conv111 = zext i8 %77 to i32
  %and112 = and i32 %conv111, 63
  %shl113 = shl i32 %and112, 6
  %or114 = or i32 %shl109, %shl113
  %78 = load i8*, i8** %p, align 8
  %arrayidx115 = getelementptr inbounds i8, i8* %78, i64 2
  %79 = load i8, i8* %arrayidx115, align 1
  %conv116 = zext i8 %79 to i32
  %and117 = and i32 %conv116, 63
  %or118 = or i32 %or114, %and117
  br label %cond.end

cond.false.119:                                   ; preds = %cond.false.100
  %80 = load i8*, i8** %p, align 8
  %call120 = call i32 @string_char(i8* %80, i8** null, i32* %len)
  br label %cond.end

cond.end:                                         ; preds = %cond.false.119, %cond.true.105
  %cond121 = phi i32 [ %or118, %cond.true.105 ], [ %call120, %cond.false.119 ]
  br label %cond.end.122

cond.end.122:                                     ; preds = %cond.end, %cond.true.89
  %cond123 = phi i32 [ %add, %cond.true.89 ], [ %cond121, %cond.end ]
  br label %cond.end.124

cond.end.124:                                     ; preds = %cond.end.122, %cond.true
  %cond125 = phi i32 [ %conv84, %cond.true ], [ %cond123, %cond.end.122 ]
  store i32 %cond125, i32* %ch, align 4
  %81 = load i32, i32* %len, align 4
  %82 = load i8*, i8** %p, align 8
  %idx.ext = sext i32 %81 to i64
  %add.ptr126 = getelementptr inbounds i8, i8* %82, i64 %idx.ext
  store i8* %add.ptr126, i8** %p, align 8
  %83 = load i32, i32* %len, align 4
  %84 = load i8*, i8** %q, align 8
  %idx.ext127 = sext i32 %83 to i64
  %idx.neg = sub i64 0, %idx.ext127
  %add.ptr128 = getelementptr inbounds i8, i8* %84, i64 %idx.neg
  store i8* %add.ptr128, i8** %q, align 8
  br i1 true, label %cond.true.129, label %cond.false.133

cond.true.129:                                    ; preds = %cond.end.124
  %85 = load i32, i32* %ch, align 4
  %add130 = add i32 %85, 0
  %cmp131 = icmp ule i32 %add130, 127
  br i1 %cmp131, label %cond.true.138, label %cond.false.141

cond.false.133:                                   ; preds = %cond.end.124
  %86 = load i32, i32* %ch, align 4
  %conv134 = sext i32 %86 to i64
  %add135 = add i64 %conv134, 0
  %cmp136 = icmp ule i64 %add135, 127
  br i1 %cmp136, label %cond.true.138, label %cond.false.141

cond.true.138:                                    ; preds = %cond.false.133, %cond.true.129
  %87 = load i32, i32* %ch, align 4
  %conv139 = trunc i32 %87 to i8
  %88 = load i8*, i8** %q, align 8
  %arrayidx140 = getelementptr inbounds i8, i8* %88, i64 0
  store i8 %conv139, i8* %arrayidx140, align 1
  br label %cond.end.189

cond.false.141:                                   ; preds = %cond.false.133, %cond.true.129
  br i1 true, label %cond.true.142, label %cond.false.146

cond.true.142:                                    ; preds = %cond.false.141
  %89 = load i32, i32* %ch, align 4
  %add143 = add i32 %89, 0
  %cmp144 = icmp ule i32 %add143, 2047
  br i1 %cmp144, label %cond.true.151, label %cond.false.159

cond.false.146:                                   ; preds = %cond.false.141
  %90 = load i32, i32* %ch, align 4
  %conv147 = sext i32 %90 to i64
  %add148 = add i64 %conv147, 0
  %cmp149 = icmp ule i64 %add148, 2047
  br i1 %cmp149, label %cond.true.151, label %cond.false.159

cond.true.151:                                    ; preds = %cond.false.146, %cond.true.142
  %91 = load i32, i32* %ch, align 4
  %shr = ashr i32 %91, 6
  %or152 = or i32 192, %shr
  %conv153 = trunc i32 %or152 to i8
  %92 = load i8*, i8** %q, align 8
  %arrayidx154 = getelementptr inbounds i8, i8* %92, i64 0
  store i8 %conv153, i8* %arrayidx154, align 1
  %93 = load i32, i32* %ch, align 4
  %and155 = and i32 %93, 63
  %or156 = or i32 128, %and155
  %conv157 = trunc i32 %or156 to i8
  %94 = load i8*, i8** %q, align 8
  %arrayidx158 = getelementptr inbounds i8, i8* %94, i64 1
  store i8 %conv157, i8* %arrayidx158, align 1
  br label %cond.end.187

cond.false.159:                                   ; preds = %cond.false.146, %cond.true.142
  br i1 true, label %cond.true.160, label %cond.false.164

cond.true.160:                                    ; preds = %cond.false.159
  %95 = load i32, i32* %ch, align 4
  %add161 = add i32 %95, 0
  %cmp162 = icmp ule i32 %add161, 65535
  br i1 %cmp162, label %cond.true.169, label %cond.false.183

cond.false.164:                                   ; preds = %cond.false.159
  %96 = load i32, i32* %ch, align 4
  %conv165 = sext i32 %96 to i64
  %add166 = add i64 %conv165, 0
  %cmp167 = icmp ule i64 %add166, 65535
  br i1 %cmp167, label %cond.true.169, label %cond.false.183

cond.true.169:                                    ; preds = %cond.false.164, %cond.true.160
  %97 = load i32, i32* %ch, align 4
  %shr170 = ashr i32 %97, 12
  %or171 = or i32 224, %shr170
  %conv172 = trunc i32 %or171 to i8
  %98 = load i8*, i8** %q, align 8
  %arrayidx173 = getelementptr inbounds i8, i8* %98, i64 0
  store i8 %conv172, i8* %arrayidx173, align 1
  %99 = load i32, i32* %ch, align 4
  %shr174 = ashr i32 %99, 6
  %and175 = and i32 %shr174, 63
  %or176 = or i32 128, %and175
  %conv177 = trunc i32 %or176 to i8
  %100 = load i8*, i8** %q, align 8
  %arrayidx178 = getelementptr inbounds i8, i8* %100, i64 1
  store i8 %conv177, i8* %arrayidx178, align 1
  %101 = load i32, i32* %ch, align 4
  %and179 = and i32 %101, 63
  %or180 = or i32 128, %and179
  %conv181 = trunc i32 %or180 to i8
  %102 = load i8*, i8** %q, align 8
  %arrayidx182 = getelementptr inbounds i8, i8* %102, i64 2
  store i8 %conv181, i8* %arrayidx182, align 1
  br label %cond.end.185

cond.false.183:                                   ; preds = %cond.false.164, %cond.true.160
  %103 = load i32, i32* %ch, align 4
  %104 = load i8*, i8** %q, align 8
  %call184 = call i32 @char_string(i32 %103, i8* %104)
  br label %cond.end.185

cond.end.185:                                     ; preds = %cond.false.183, %cond.true.169
  %cond186 = phi i32 [ 3, %cond.true.169 ], [ %call184, %cond.false.183 ]
  br label %cond.end.187

cond.end.187:                                     ; preds = %cond.end.185, %cond.true.151
  %cond188 = phi i32 [ 2, %cond.true.151 ], [ %cond186, %cond.end.185 ]
  br label %cond.end.189

cond.end.189:                                     ; preds = %cond.end.187, %cond.true.138
  %cond190 = phi i32 [ 1, %cond.true.138 ], [ %cond188, %cond.end.187 ]
  br label %while.cond

while.end:                                        ; preds = %while.cond
  br label %if.end.191

if.end.191:                                       ; preds = %while.end, %for.end.72
  br label %if.end.194

if.else.192:                                      ; preds = %if.else.52
  %call193 = call i64 @builtin_lisp_symbol(i32 844)
  %105 = load i64, i64* %seq.addr, align 8
  %106 = call i64 @wrong_type_argument(i64 %call193, i64 %105) #8
  unreachable

if.end.194:                                       ; preds = %if.end.191
  br label %if.end.195

if.end.195:                                       ; preds = %if.end.194, %for.end.51
  br label %if.end.196

if.end.196:                                       ; preds = %if.end.195, %for.end.35
  br label %if.end.197

if.end.197:                                       ; preds = %if.end.196, %for.end
  br label %if.end.198

if.end.198:                                       ; preds = %if.end.197
  %107 = load i64, i64* %new, align 8
  store i64 %107, i64* %retval
  br label %return

return:                                           ; preds = %if.end.198, %if.then
  %108 = load i64, i64* %retval
  ret i64 %108
}

declare void @ASET(i64, i64, i64) #2

declare zeroext i1 @bool_vector_bitref(i64, i64) #2

declare void @bool_vector_set(i64, i64, i1 zeroext) #2

declare i64 @make_uninit_vector(i64) #2

declare i64 @make_uninit_string(i64) #2

declare void @SSET(i64, i64, i8 zeroext) #2

declare i32 @char_string(i32, i8*) #2

; Function Attrs: nounwind uwtable
define i64 @Fsort(i64 %seq, i64 %predicate) #1 {
entry:
  %seq.addr = alloca i64, align 8
  %predicate.addr = alloca i64, align 8
  store i64 %seq, i64* %seq.addr, align 8
  store i64 %predicate, i64* %predicate.addr, align 8
  %0 = load i64, i64* %seq.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i64, i64* %seq.addr, align 8
  %2 = load i64, i64* %predicate.addr, align 8
  %call = call i64 @sort_list(i64 %1, i64 %2)
  store i64 %call, i64* %seq.addr, align 8
  br label %if.end.11

if.else:                                          ; preds = %entry
  %3 = load i64, i64* %seq.addr, align 8
  %call2 = call zeroext i1 @VECTORP(i64 %3)
  br i1 %call2, label %if.then.3, label %if.else.4

if.then.3:                                        ; preds = %if.else
  %4 = load i64, i64* %seq.addr, align 8
  %5 = load i64, i64* %predicate.addr, align 8
  call void @sort_vector(i64 %4, i64 %5)
  br label %if.end.10

if.else.4:                                        ; preds = %if.else
  %6 = load i64, i64* %seq.addr, align 8
  %call5 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp6 = icmp eq i64 %6, %call5
  br i1 %cmp6, label %if.end, label %if.then.8

if.then.8:                                        ; preds = %if.else.4
  %call9 = call i64 @builtin_lisp_symbol(i32 844)
  %7 = load i64, i64* %seq.addr, align 8
  %8 = call i64 @wrong_type_argument(i64 %call9, i64 %7) #8
  unreachable

if.end:                                           ; preds = %if.else.4
  br label %if.end.10

if.end.10:                                        ; preds = %if.end, %if.then.3
  br label %if.end.11

if.end.11:                                        ; preds = %if.end.10, %if.then
  %9 = load i64, i64* %seq.addr, align 8
  ret i64 %9
}

; Function Attrs: nounwind uwtable
define internal i64 @sort_list(i64 %list, i64 %predicate) #1 {
entry:
  %retval = alloca i64, align 8
  %list.addr = alloca i64, align 8
  %predicate.addr = alloca i64, align 8
  %front = alloca i64, align 8
  %back = alloca i64, align 8
  %len = alloca i64, align 8
  %tem = alloca i64, align 8
  %length = alloca i64, align 8
  store i64 %list, i64* %list.addr, align 8
  store i64 %predicate, i64* %predicate.addr, align 8
  %0 = load i64, i64* %list.addr, align 8
  store i64 %0, i64* %front, align 8
  %1 = load i64, i64* %list.addr, align 8
  %call = call i64 @Flength(i64 %1)
  store i64 %call, i64* %len, align 8
  %2 = load i64, i64* %len, align 8
  %shr = ashr i64 %2, 2
  store i64 %shr, i64* %length, align 8
  %3 = load i64, i64* %length, align 8
  %cmp = icmp slt i64 %3, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load i64, i64* %list.addr, align 8
  store i64 %4, i64* %retval
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i64, i64* %length, align 8
  %div = sdiv i64 %5, 2
  %sub = sub nsw i64 %div, 1
  %shl = shl i64 %sub, 2
  %add = add i64 %shl, 2
  store i64 %add, i64* %len, align 8
  %6 = load i64, i64* %len, align 8
  %7 = load i64, i64* %list.addr, align 8
  %call1 = call i64 @Fnthcdr(i64 %6, i64 %7)
  store i64 %call1, i64* %tem, align 8
  %8 = load i64, i64* %tem, align 8
  %call2 = call i64 @Fcdr(i64 %8)
  store i64 %call2, i64* %back, align 8
  %9 = load i64, i64* %tem, align 8
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  %call4 = call i64 @Fsetcdr(i64 %9, i64 %call3)
  %10 = load i64, i64* %front, align 8
  %11 = load i64, i64* %predicate.addr, align 8
  %call5 = call i64 @Fsort(i64 %10, i64 %11)
  store i64 %call5, i64* %front, align 8
  %12 = load i64, i64* %back, align 8
  %13 = load i64, i64* %predicate.addr, align 8
  %call6 = call i64 @Fsort(i64 %12, i64 %13)
  store i64 %call6, i64* %back, align 8
  %14 = load i64, i64* %front, align 8
  %15 = load i64, i64* %back, align 8
  %16 = load i64, i64* %predicate.addr, align 8
  %call7 = call i64 @merge(i64 %14, i64 %15, i64 %16)
  store i64 %call7, i64* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %17 = load i64, i64* %retval
  ret i64 %17
}

; Function Attrs: nounwind uwtable
define internal void @sort_vector(i64 %vector, i64 %predicate) #1 {
entry:
  %vector.addr = alloca i64, align 8
  %predicate.addr = alloca i64, align 8
  %len = alloca i64, align 8
  %halflen = alloca i64, align 8
  %tmp = alloca i64*, align 8
  %sa_avail = alloca i64, align 8
  %sa_count = alloca i64, align 8
  %sa_must_free = alloca i8, align 1
  %alloca_nbytes = alloca i64, align 8
  %arg_ = alloca i64, align 8
  %i = alloca i64, align 8
  store i64 %vector, i64* %vector.addr, align 8
  store i64 %predicate, i64* %predicate.addr, align 8
  %0 = load i64, i64* %vector.addr, align 8
  %call = call i64 @ASIZE(i64 %0)
  store i64 %call, i64* %len, align 8
  %1 = load i64, i64* %len, align 8
  %cmp = icmp slt i64 %1, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %do.end.2189

if.end:                                           ; preds = %entry
  %2 = load i64, i64* %len, align 8
  %shr = ashr i64 %2, 1
  store i64 %shr, i64* %halflen, align 8
  store i64 16384, i64* %sa_avail, align 8
  %call3 = call i64 @SPECPDL_INDEX()
  store i64 %call3, i64* %sa_count, align 8
  store i8 0, i8* %sa_must_free, align 1
  br label %do.body

do.body:                                          ; preds = %if.end
  br i1 false, label %cond.true, label %cond.false.477

cond.true:                                        ; preds = %do.body
  br i1 false, label %cond.true.6, label %cond.false.262

cond.true.6:                                      ; preds = %cond.true
  %3 = load i64, i64* %halflen, align 8
  %conv = trunc i64 %3 to i8
  %conv7 = sext i8 %conv to i32
  %add = add nsw i32 0, %conv7
  %mul = mul nsw i32 0, %add
  %sub = sub nsw i32 %mul, 1
  %cmp8 = icmp slt i32 %sub, 0
  br i1 %cmp8, label %cond.true.10, label %cond.false

cond.true.10:                                     ; preds = %cond.true.6
  %4 = load i64, i64* %halflen, align 8
  %conv11 = trunc i64 %4 to i8
  %conv12 = sext i8 %conv11 to i32
  %add13 = add nsw i32 0, %conv12
  %mul14 = mul nsw i32 0, %add13
  %add15 = add nsw i32 %mul14, 0
  %neg = xor i32 %add15, -1
  %cmp16 = icmp eq i32 %neg, -1
  %conv17 = zext i1 %cmp16 to i32
  %sub18 = sub nsw i32 0, %conv17
  %5 = load i64, i64* %halflen, align 8
  %conv19 = trunc i64 %5 to i8
  %conv20 = sext i8 %conv19 to i32
  %add21 = add nsw i32 0, %conv20
  %mul22 = mul nsw i32 0, %add21
  %add23 = add nsw i32 %mul22, 1
  %shl = shl i32 %add23, 30
  %sub24 = sub nsw i32 %shl, 1
  %mul25 = mul nsw i32 %sub24, 2
  %add26 = add nsw i32 %mul25, 1
  %sub27 = sub nsw i32 %sub18, %add26
  br label %cond.end

cond.false:                                       ; preds = %cond.true.6
  %6 = load i64, i64* %halflen, align 8
  %conv28 = trunc i64 %6 to i8
  %conv29 = sext i8 %conv28 to i32
  %add30 = add nsw i32 0, %conv29
  %mul31 = mul nsw i32 0, %add30
  %add32 = add nsw i32 %mul31, 0
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true.10
  %cond = phi i32 [ %sub27, %cond.true.10 ], [ %add32, %cond.false ]
  %cmp33 = icmp eq i32 %cond, 0
  br i1 %cmp33, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %cond.end
  %7 = load i64, i64* %halflen, align 8
  %conv35 = trunc i64 %7 to i8
  %conv36 = sext i8 %conv35 to i32
  %cmp37 = icmp slt i32 %conv36, 0
  br i1 %cmp37, label %cond.true.216, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %cond.end
  br i1 false, label %cond.true.39, label %cond.false.117

cond.true.39:                                     ; preds = %lor.lhs.false
  %8 = load i64, i64* %halflen, align 8
  %conv40 = trunc i64 %8 to i8
  %conv41 = sext i8 %conv40 to i32
  %cmp42 = icmp slt i32 %conv41, 0
  br i1 %cmp42, label %cond.true.44, label %cond.false.74

cond.true.44:                                     ; preds = %cond.true.39
  %9 = load i64, i64* %halflen, align 8
  %conv45 = trunc i64 %9 to i8
  %conv46 = sext i8 %conv45 to i32
  %10 = load i64, i64* %halflen, align 8
  %conv47 = trunc i64 %10 to i8
  %conv48 = sext i8 %conv47 to i32
  %add49 = add nsw i32 0, %conv48
  %mul50 = mul nsw i32 0, %add49
  %sub51 = sub nsw i32 %mul50, 1
  %cmp52 = icmp slt i32 %sub51, 0
  br i1 %cmp52, label %cond.true.54, label %cond.false.64

cond.true.54:                                     ; preds = %cond.true.44
  %11 = load i64, i64* %halflen, align 8
  %conv55 = trunc i64 %11 to i8
  %conv56 = sext i8 %conv55 to i32
  %add57 = add nsw i32 0, %conv56
  %mul58 = mul nsw i32 0, %add57
  %add59 = add nsw i32 %mul58, 1
  %shl60 = shl i32 %add59, 30
  %sub61 = sub nsw i32 %shl60, 1
  %mul62 = mul nsw i32 %sub61, 2
  %add63 = add nsw i32 %mul62, 1
  br label %cond.end.70

cond.false.64:                                    ; preds = %cond.true.44
  %12 = load i64, i64* %halflen, align 8
  %conv65 = trunc i64 %12 to i8
  %conv66 = sext i8 %conv65 to i32
  %add67 = add nsw i32 0, %conv66
  %mul68 = mul nsw i32 0, %add67
  %sub69 = sub nsw i32 %mul68, 1
  br label %cond.end.70

cond.end.70:                                      ; preds = %cond.false.64, %cond.true.54
  %cond71 = phi i32 [ %add63, %cond.true.54 ], [ %sub69, %cond.false.64 ]
  %div = sdiv i32 %cond71, 8
  %cmp72 = icmp slt i32 %conv46, %div
  br i1 %cmp72, label %cond.true.216, label %lor.lhs.false.196

cond.false.74:                                    ; preds = %cond.true.39
  br i1 false, label %cond.true.75, label %cond.false.76

cond.true.75:                                     ; preds = %cond.false.74
  br i1 false, label %cond.true.216, label %lor.lhs.false.196

cond.false.76:                                    ; preds = %cond.false.74
  %13 = load i64, i64* %halflen, align 8
  %conv77 = trunc i64 %13 to i8
  %conv78 = sext i8 %conv77 to i32
  %add79 = add nsw i32 0, %conv78
  %mul80 = mul nsw i32 0, %add79
  %sub81 = sub nsw i32 %mul80, 1
  %cmp82 = icmp slt i32 %sub81, 0
  br i1 %cmp82, label %cond.true.84, label %cond.false.104

cond.true.84:                                     ; preds = %cond.false.76
  %14 = load i64, i64* %halflen, align 8
  %conv85 = trunc i64 %14 to i8
  %conv86 = sext i8 %conv85 to i32
  %add87 = add nsw i32 0, %conv86
  %mul88 = mul nsw i32 0, %add87
  %add89 = add nsw i32 %mul88, 0
  %neg90 = xor i32 %add89, -1
  %cmp91 = icmp eq i32 %neg90, -1
  %conv92 = zext i1 %cmp91 to i32
  %sub93 = sub nsw i32 0, %conv92
  %15 = load i64, i64* %halflen, align 8
  %conv94 = trunc i64 %15 to i8
  %conv95 = sext i8 %conv94 to i32
  %add96 = add nsw i32 0, %conv95
  %mul97 = mul nsw i32 0, %add96
  %add98 = add nsw i32 %mul97, 1
  %shl99 = shl i32 %add98, 30
  %sub100 = sub nsw i32 %shl99, 1
  %mul101 = mul nsw i32 %sub100, 2
  %add102 = add nsw i32 %mul101, 1
  %sub103 = sub nsw i32 %sub93, %add102
  br label %cond.end.110

cond.false.104:                                   ; preds = %cond.false.76
  %16 = load i64, i64* %halflen, align 8
  %conv105 = trunc i64 %16 to i8
  %conv106 = sext i8 %conv105 to i32
  %add107 = add nsw i32 0, %conv106
  %mul108 = mul nsw i32 0, %add107
  %add109 = add nsw i32 %mul108, 0
  br label %cond.end.110

cond.end.110:                                     ; preds = %cond.false.104, %cond.true.84
  %cond111 = phi i32 [ %sub103, %cond.true.84 ], [ %add109, %cond.false.104 ]
  %div112 = sdiv i32 %cond111, 8
  %17 = load i64, i64* %halflen, align 8
  %conv113 = trunc i64 %17 to i8
  %conv114 = sext i8 %conv113 to i32
  %cmp115 = icmp slt i32 %div112, %conv114
  br i1 %cmp115, label %cond.true.216, label %lor.lhs.false.196

cond.false.117:                                   ; preds = %lor.lhs.false
  br i1 false, label %cond.true.118, label %cond.false.119

cond.true.118:                                    ; preds = %cond.false.117
  br i1 false, label %cond.true.216, label %lor.lhs.false.196

cond.false.119:                                   ; preds = %cond.false.117
  %18 = load i64, i64* %halflen, align 8
  %conv120 = trunc i64 %18 to i8
  %conv121 = sext i8 %conv120 to i32
  %cmp122 = icmp slt i32 %conv121, 0
  br i1 %cmp122, label %cond.true.124, label %cond.false.165

cond.true.124:                                    ; preds = %cond.false.119
  %19 = load i64, i64* %halflen, align 8
  %conv125 = trunc i64 %19 to i8
  %conv126 = sext i8 %conv125 to i32
  %20 = load i64, i64* %halflen, align 8
  %conv127 = trunc i64 %20 to i8
  %conv128 = sext i8 %conv127 to i32
  %add129 = add nsw i32 0, %conv128
  %mul130 = mul nsw i32 0, %add129
  %sub131 = sub nsw i32 %mul130, 1
  %cmp132 = icmp slt i32 %sub131, 0
  br i1 %cmp132, label %cond.true.134, label %cond.false.154

cond.true.134:                                    ; preds = %cond.true.124
  %21 = load i64, i64* %halflen, align 8
  %conv135 = trunc i64 %21 to i8
  %conv136 = sext i8 %conv135 to i32
  %add137 = add nsw i32 0, %conv136
  %mul138 = mul nsw i32 0, %add137
  %add139 = add nsw i32 %mul138, 0
  %neg140 = xor i32 %add139, -1
  %cmp141 = icmp eq i32 %neg140, -1
  %conv142 = zext i1 %cmp141 to i32
  %sub143 = sub nsw i32 0, %conv142
  %22 = load i64, i64* %halflen, align 8
  %conv144 = trunc i64 %22 to i8
  %conv145 = sext i8 %conv144 to i32
  %add146 = add nsw i32 0, %conv145
  %mul147 = mul nsw i32 0, %add146
  %add148 = add nsw i32 %mul147, 1
  %shl149 = shl i32 %add148, 30
  %sub150 = sub nsw i32 %shl149, 1
  %mul151 = mul nsw i32 %sub150, 2
  %add152 = add nsw i32 %mul151, 1
  %sub153 = sub nsw i32 %sub143, %add152
  br label %cond.end.160

cond.false.154:                                   ; preds = %cond.true.124
  %23 = load i64, i64* %halflen, align 8
  %conv155 = trunc i64 %23 to i8
  %conv156 = sext i8 %conv155 to i32
  %add157 = add nsw i32 0, %conv156
  %mul158 = mul nsw i32 0, %add157
  %add159 = add nsw i32 %mul158, 0
  br label %cond.end.160

cond.end.160:                                     ; preds = %cond.false.154, %cond.true.134
  %cond161 = phi i32 [ %sub153, %cond.true.134 ], [ %add159, %cond.false.154 ]
  %div162 = sdiv i32 %cond161, 8
  %cmp163 = icmp slt i32 %conv126, %div162
  br i1 %cmp163, label %cond.true.216, label %lor.lhs.false.196

cond.false.165:                                   ; preds = %cond.false.119
  %24 = load i64, i64* %halflen, align 8
  %conv166 = trunc i64 %24 to i8
  %conv167 = sext i8 %conv166 to i32
  %add168 = add nsw i32 0, %conv167
  %mul169 = mul nsw i32 0, %add168
  %sub170 = sub nsw i32 %mul169, 1
  %cmp171 = icmp slt i32 %sub170, 0
  br i1 %cmp171, label %cond.true.173, label %cond.false.183

cond.true.173:                                    ; preds = %cond.false.165
  %25 = load i64, i64* %halflen, align 8
  %conv174 = trunc i64 %25 to i8
  %conv175 = sext i8 %conv174 to i32
  %add176 = add nsw i32 0, %conv175
  %mul177 = mul nsw i32 0, %add176
  %add178 = add nsw i32 %mul177, 1
  %shl179 = shl i32 %add178, 30
  %sub180 = sub nsw i32 %shl179, 1
  %mul181 = mul nsw i32 %sub180, 2
  %add182 = add nsw i32 %mul181, 1
  br label %cond.end.189

cond.false.183:                                   ; preds = %cond.false.165
  %26 = load i64, i64* %halflen, align 8
  %conv184 = trunc i64 %26 to i8
  %conv185 = sext i8 %conv184 to i32
  %add186 = add nsw i32 0, %conv185
  %mul187 = mul nsw i32 0, %add186
  %sub188 = sub nsw i32 %mul187, 1
  br label %cond.end.189

cond.end.189:                                     ; preds = %cond.false.183, %cond.true.173
  %cond190 = phi i32 [ %add182, %cond.true.173 ], [ %sub188, %cond.false.183 ]
  %div191 = sdiv i32 %cond190, 8
  %27 = load i64, i64* %halflen, align 8
  %conv192 = trunc i64 %27 to i8
  %conv193 = sext i8 %conv192 to i32
  %cmp194 = icmp slt i32 %div191, %conv193
  br i1 %cmp194, label %cond.true.216, label %lor.lhs.false.196

lor.lhs.false.196:                                ; preds = %cond.end.189, %cond.end.160, %cond.true.118, %cond.end.110, %cond.true.75, %cond.end.70
  %28 = load i64, i64* %halflen, align 8
  %conv197 = trunc i64 %28 to i8
  %conv198 = sext i8 %conv197 to i32
  %mul199 = mul nsw i32 %conv198, 8
  %mul200 = mul nsw i32 0, %mul199
  %sub201 = sub nsw i32 %mul200, 1
  %cmp202 = icmp slt i32 %sub201, 0
  br i1 %cmp202, label %land.lhs.true.204, label %lor.lhs.false.210

land.lhs.true.204:                                ; preds = %lor.lhs.false.196
  %29 = load i64, i64* %halflen, align 8
  %conv205 = trunc i64 %29 to i8
  %conv206 = sext i8 %conv205 to i32
  %mul207 = mul nsw i32 %conv206, 8
  %cmp208 = icmp slt i32 %mul207, -128
  br i1 %cmp208, label %cond.true.216, label %lor.lhs.false.210

lor.lhs.false.210:                                ; preds = %land.lhs.true.204, %lor.lhs.false.196
  %30 = load i64, i64* %halflen, align 8
  %conv211 = trunc i64 %30 to i8
  %conv212 = sext i8 %conv211 to i32
  %mul213 = mul nsw i32 %conv212, 8
  %cmp214 = icmp slt i32 127, %mul213
  br i1 %cmp214, label %cond.true.216, label %cond.false.239

cond.true.216:                                    ; preds = %lor.lhs.false.210, %land.lhs.true.204, %cond.end.189, %cond.end.160, %cond.true.118, %cond.end.110, %cond.true.75, %cond.end.70, %land.lhs.true
  %31 = load i64, i64* %halflen, align 8
  %conv217 = trunc i64 %31 to i8
  %conv218 = zext i8 %conv217 to i32
  %mul219 = mul nsw i32 %conv218, 8
  %cmp220 = icmp sle i32 %mul219, 127
  br i1 %cmp220, label %cond.true.222, label %cond.false.228

cond.true.222:                                    ; preds = %cond.true.216
  %32 = load i64, i64* %halflen, align 8
  %conv223 = trunc i64 %32 to i8
  %conv224 = zext i8 %conv223 to i32
  %mul225 = mul nsw i32 %conv224, 8
  %conv226 = trunc i32 %mul225 to i8
  %conv227 = sext i8 %conv226 to i32
  br label %cond.end.236

cond.false.228:                                   ; preds = %cond.true.216
  %33 = load i64, i64* %halflen, align 8
  %conv229 = trunc i64 %33 to i8
  %conv230 = zext i8 %conv229 to i32
  %mul231 = mul nsw i32 %conv230, 8
  %sub232 = sub nsw i32 %mul231, -128
  %conv233 = trunc i32 %sub232 to i8
  %conv234 = sext i8 %conv233 to i32
  %add235 = add nsw i32 %conv234, -128
  br label %cond.end.236

cond.end.236:                                     ; preds = %cond.false.228, %cond.true.222
  %cond237 = phi i32 [ %conv227, %cond.true.222 ], [ %add235, %cond.false.228 ]
  %conv238 = sext i32 %cond237 to i64
  store i64 %conv238, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2169, label %lor.lhs.false.2166

cond.false.239:                                   ; preds = %lor.lhs.false.210
  %34 = load i64, i64* %halflen, align 8
  %conv240 = trunc i64 %34 to i8
  %conv241 = zext i8 %conv240 to i32
  %mul242 = mul nsw i32 %conv241, 8
  %cmp243 = icmp sle i32 %mul242, 127
  br i1 %cmp243, label %cond.true.245, label %cond.false.251

cond.true.245:                                    ; preds = %cond.false.239
  %35 = load i64, i64* %halflen, align 8
  %conv246 = trunc i64 %35 to i8
  %conv247 = zext i8 %conv246 to i32
  %mul248 = mul nsw i32 %conv247, 8
  %conv249 = trunc i32 %mul248 to i8
  %conv250 = sext i8 %conv249 to i32
  br label %cond.end.259

cond.false.251:                                   ; preds = %cond.false.239
  %36 = load i64, i64* %halflen, align 8
  %conv252 = trunc i64 %36 to i8
  %conv253 = zext i8 %conv252 to i32
  %mul254 = mul nsw i32 %conv253, 8
  %sub255 = sub nsw i32 %mul254, -128
  %conv256 = trunc i32 %sub255 to i8
  %conv257 = sext i8 %conv256 to i32
  %add258 = add nsw i32 %conv257, -128
  br label %cond.end.259

cond.end.259:                                     ; preds = %cond.false.251, %cond.true.245
  %cond260 = phi i32 [ %conv250, %cond.true.245 ], [ %add258, %cond.false.251 ]
  %conv261 = sext i32 %cond260 to i64
  store i64 %conv261, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2169, label %lor.lhs.false.2166

cond.false.262:                                   ; preds = %cond.true
  %37 = load i64, i64* %halflen, align 8
  %add263 = add nsw i64 0, %37
  %mul264 = mul nsw i64 0, %add263
  %sub265 = sub nsw i64 %mul264, 1
  %cmp266 = icmp slt i64 %sub265, 0
  br i1 %cmp266, label %cond.true.268, label %cond.false.285

cond.true.268:                                    ; preds = %cond.false.262
  %38 = load i64, i64* %halflen, align 8
  %add269 = add nsw i64 0, %38
  %mul270 = mul nsw i64 0, %add269
  %add271 = add nsw i64 %mul270, 0
  %neg272 = xor i64 %add271, -1
  %cmp273 = icmp eq i64 %neg272, -1
  %conv274 = zext i1 %cmp273 to i32
  %sub275 = sub nsw i32 0, %conv274
  %conv276 = sext i32 %sub275 to i64
  %39 = load i64, i64* %halflen, align 8
  %add277 = add nsw i64 0, %39
  %mul278 = mul nsw i64 0, %add277
  %add279 = add nsw i64 %mul278, 1
  %shl280 = shl i64 %add279, 62
  %sub281 = sub nsw i64 %shl280, 1
  %mul282 = mul nsw i64 %sub281, 2
  %add283 = add nsw i64 %mul282, 1
  %sub284 = sub nsw i64 %conv276, %add283
  br label %cond.end.289

cond.false.285:                                   ; preds = %cond.false.262
  %40 = load i64, i64* %halflen, align 8
  %add286 = add nsw i64 0, %40
  %mul287 = mul nsw i64 0, %add286
  %add288 = add nsw i64 %mul287, 0
  br label %cond.end.289

cond.end.289:                                     ; preds = %cond.false.285, %cond.true.268
  %cond290 = phi i64 [ %sub284, %cond.true.268 ], [ %add288, %cond.false.285 ]
  %cmp291 = icmp eq i64 %cond290, 0
  br i1 %cmp291, label %land.lhs.true.293, label %lor.lhs.false.296

land.lhs.true.293:                                ; preds = %cond.end.289
  %41 = load i64, i64* %halflen, align 8
  %cmp294 = icmp slt i64 %41, 0
  br i1 %cmp294, label %cond.true.431, label %lor.lhs.false.296

lor.lhs.false.296:                                ; preds = %land.lhs.true.293, %cond.end.289
  br i1 false, label %cond.true.297, label %cond.false.357

cond.true.297:                                    ; preds = %lor.lhs.false.296
  %42 = load i64, i64* %halflen, align 8
  %cmp298 = icmp slt i64 %42, 0
  br i1 %cmp298, label %cond.true.300, label %cond.false.323

cond.true.300:                                    ; preds = %cond.true.297
  %43 = load i64, i64* %halflen, align 8
  %44 = load i64, i64* %halflen, align 8
  %add301 = add nsw i64 0, %44
  %mul302 = mul nsw i64 0, %add301
  %sub303 = sub nsw i64 %mul302, 1
  %cmp304 = icmp slt i64 %sub303, 0
  br i1 %cmp304, label %cond.true.306, label %cond.false.314

cond.true.306:                                    ; preds = %cond.true.300
  %45 = load i64, i64* %halflen, align 8
  %add307 = add nsw i64 0, %45
  %mul308 = mul nsw i64 0, %add307
  %add309 = add nsw i64 %mul308, 1
  %shl310 = shl i64 %add309, 62
  %sub311 = sub nsw i64 %shl310, 1
  %mul312 = mul nsw i64 %sub311, 2
  %add313 = add nsw i64 %mul312, 1
  br label %cond.end.318

cond.false.314:                                   ; preds = %cond.true.300
  %46 = load i64, i64* %halflen, align 8
  %add315 = add nsw i64 0, %46
  %mul316 = mul nsw i64 0, %add315
  %sub317 = sub nsw i64 %mul316, 1
  br label %cond.end.318

cond.end.318:                                     ; preds = %cond.false.314, %cond.true.306
  %cond319 = phi i64 [ %add313, %cond.true.306 ], [ %sub317, %cond.false.314 ]
  %div320 = sdiv i64 %cond319, 8
  %cmp321 = icmp slt i64 %43, %div320
  br i1 %cmp321, label %cond.true.431, label %lor.lhs.false.417

cond.false.323:                                   ; preds = %cond.true.297
  br i1 false, label %cond.true.324, label %cond.false.325

cond.true.324:                                    ; preds = %cond.false.323
  br i1 false, label %cond.true.431, label %lor.lhs.false.417

cond.false.325:                                   ; preds = %cond.false.323
  %47 = load i64, i64* %halflen, align 8
  %add326 = add nsw i64 0, %47
  %mul327 = mul nsw i64 0, %add326
  %sub328 = sub nsw i64 %mul327, 1
  %cmp329 = icmp slt i64 %sub328, 0
  br i1 %cmp329, label %cond.true.331, label %cond.false.348

cond.true.331:                                    ; preds = %cond.false.325
  %48 = load i64, i64* %halflen, align 8
  %add332 = add nsw i64 0, %48
  %mul333 = mul nsw i64 0, %add332
  %add334 = add nsw i64 %mul333, 0
  %neg335 = xor i64 %add334, -1
  %cmp336 = icmp eq i64 %neg335, -1
  %conv337 = zext i1 %cmp336 to i32
  %sub338 = sub nsw i32 0, %conv337
  %conv339 = sext i32 %sub338 to i64
  %49 = load i64, i64* %halflen, align 8
  %add340 = add nsw i64 0, %49
  %mul341 = mul nsw i64 0, %add340
  %add342 = add nsw i64 %mul341, 1
  %shl343 = shl i64 %add342, 62
  %sub344 = sub nsw i64 %shl343, 1
  %mul345 = mul nsw i64 %sub344, 2
  %add346 = add nsw i64 %mul345, 1
  %sub347 = sub nsw i64 %conv339, %add346
  br label %cond.end.352

cond.false.348:                                   ; preds = %cond.false.325
  %50 = load i64, i64* %halflen, align 8
  %add349 = add nsw i64 0, %50
  %mul350 = mul nsw i64 0, %add349
  %add351 = add nsw i64 %mul350, 0
  br label %cond.end.352

cond.end.352:                                     ; preds = %cond.false.348, %cond.true.331
  %cond353 = phi i64 [ %sub347, %cond.true.331 ], [ %add351, %cond.false.348 ]
  %div354 = sdiv i64 %cond353, 8
  %51 = load i64, i64* %halflen, align 8
  %cmp355 = icmp slt i64 %div354, %51
  br i1 %cmp355, label %cond.true.431, label %lor.lhs.false.417

cond.false.357:                                   ; preds = %lor.lhs.false.296
  br i1 false, label %cond.true.358, label %cond.false.359

cond.true.358:                                    ; preds = %cond.false.357
  br i1 false, label %cond.true.431, label %lor.lhs.false.417

cond.false.359:                                   ; preds = %cond.false.357
  %52 = load i64, i64* %halflen, align 8
  %cmp360 = icmp slt i64 %52, 0
  br i1 %cmp360, label %cond.true.362, label %cond.false.394

cond.true.362:                                    ; preds = %cond.false.359
  %53 = load i64, i64* %halflen, align 8
  %54 = load i64, i64* %halflen, align 8
  %add363 = add nsw i64 0, %54
  %mul364 = mul nsw i64 0, %add363
  %sub365 = sub nsw i64 %mul364, 1
  %cmp366 = icmp slt i64 %sub365, 0
  br i1 %cmp366, label %cond.true.368, label %cond.false.385

cond.true.368:                                    ; preds = %cond.true.362
  %55 = load i64, i64* %halflen, align 8
  %add369 = add nsw i64 0, %55
  %mul370 = mul nsw i64 0, %add369
  %add371 = add nsw i64 %mul370, 0
  %neg372 = xor i64 %add371, -1
  %cmp373 = icmp eq i64 %neg372, -1
  %conv374 = zext i1 %cmp373 to i32
  %sub375 = sub nsw i32 0, %conv374
  %conv376 = sext i32 %sub375 to i64
  %56 = load i64, i64* %halflen, align 8
  %add377 = add nsw i64 0, %56
  %mul378 = mul nsw i64 0, %add377
  %add379 = add nsw i64 %mul378, 1
  %shl380 = shl i64 %add379, 62
  %sub381 = sub nsw i64 %shl380, 1
  %mul382 = mul nsw i64 %sub381, 2
  %add383 = add nsw i64 %mul382, 1
  %sub384 = sub nsw i64 %conv376, %add383
  br label %cond.end.389

cond.false.385:                                   ; preds = %cond.true.362
  %57 = load i64, i64* %halflen, align 8
  %add386 = add nsw i64 0, %57
  %mul387 = mul nsw i64 0, %add386
  %add388 = add nsw i64 %mul387, 0
  br label %cond.end.389

cond.end.389:                                     ; preds = %cond.false.385, %cond.true.368
  %cond390 = phi i64 [ %sub384, %cond.true.368 ], [ %add388, %cond.false.385 ]
  %div391 = sdiv i64 %cond390, 8
  %cmp392 = icmp slt i64 %53, %div391
  br i1 %cmp392, label %cond.true.431, label %lor.lhs.false.417

cond.false.394:                                   ; preds = %cond.false.359
  %58 = load i64, i64* %halflen, align 8
  %add395 = add nsw i64 0, %58
  %mul396 = mul nsw i64 0, %add395
  %sub397 = sub nsw i64 %mul396, 1
  %cmp398 = icmp slt i64 %sub397, 0
  br i1 %cmp398, label %cond.true.400, label %cond.false.408

cond.true.400:                                    ; preds = %cond.false.394
  %59 = load i64, i64* %halflen, align 8
  %add401 = add nsw i64 0, %59
  %mul402 = mul nsw i64 0, %add401
  %add403 = add nsw i64 %mul402, 1
  %shl404 = shl i64 %add403, 62
  %sub405 = sub nsw i64 %shl404, 1
  %mul406 = mul nsw i64 %sub405, 2
  %add407 = add nsw i64 %mul406, 1
  br label %cond.end.412

cond.false.408:                                   ; preds = %cond.false.394
  %60 = load i64, i64* %halflen, align 8
  %add409 = add nsw i64 0, %60
  %mul410 = mul nsw i64 0, %add409
  %sub411 = sub nsw i64 %mul410, 1
  br label %cond.end.412

cond.end.412:                                     ; preds = %cond.false.408, %cond.true.400
  %cond413 = phi i64 [ %add407, %cond.true.400 ], [ %sub411, %cond.false.408 ]
  %div414 = sdiv i64 %cond413, 8
  %61 = load i64, i64* %halflen, align 8
  %cmp415 = icmp slt i64 %div414, %61
  br i1 %cmp415, label %cond.true.431, label %lor.lhs.false.417

lor.lhs.false.417:                                ; preds = %cond.end.412, %cond.end.389, %cond.true.358, %cond.end.352, %cond.true.324, %cond.end.318
  %62 = load i64, i64* %halflen, align 8
  %mul418 = mul nsw i64 %62, 8
  %mul419 = mul nsw i64 0, %mul418
  %sub420 = sub nsw i64 %mul419, 1
  %cmp421 = icmp slt i64 %sub420, 0
  br i1 %cmp421, label %land.lhs.true.423, label %lor.lhs.false.427

land.lhs.true.423:                                ; preds = %lor.lhs.false.417
  %63 = load i64, i64* %halflen, align 8
  %mul424 = mul nsw i64 %63, 8
  %cmp425 = icmp slt i64 %mul424, -128
  br i1 %cmp425, label %cond.true.431, label %lor.lhs.false.427

lor.lhs.false.427:                                ; preds = %land.lhs.true.423, %lor.lhs.false.417
  %64 = load i64, i64* %halflen, align 8
  %mul428 = mul nsw i64 %64, 8
  %cmp429 = icmp slt i64 127, %mul428
  br i1 %cmp429, label %cond.true.431, label %cond.false.454

cond.true.431:                                    ; preds = %lor.lhs.false.427, %land.lhs.true.423, %cond.end.412, %cond.end.389, %cond.true.358, %cond.end.352, %cond.true.324, %cond.end.318, %land.lhs.true.293
  %65 = load i64, i64* %halflen, align 8
  %conv432 = trunc i64 %65 to i8
  %conv433 = zext i8 %conv432 to i32
  %mul434 = mul nsw i32 %conv433, 8
  %cmp435 = icmp sle i32 %mul434, 127
  br i1 %cmp435, label %cond.true.437, label %cond.false.443

cond.true.437:                                    ; preds = %cond.true.431
  %66 = load i64, i64* %halflen, align 8
  %conv438 = trunc i64 %66 to i8
  %conv439 = zext i8 %conv438 to i32
  %mul440 = mul nsw i32 %conv439, 8
  %conv441 = trunc i32 %mul440 to i8
  %conv442 = sext i8 %conv441 to i32
  br label %cond.end.451

cond.false.443:                                   ; preds = %cond.true.431
  %67 = load i64, i64* %halflen, align 8
  %conv444 = trunc i64 %67 to i8
  %conv445 = zext i8 %conv444 to i32
  %mul446 = mul nsw i32 %conv445, 8
  %sub447 = sub nsw i32 %mul446, -128
  %conv448 = trunc i32 %sub447 to i8
  %conv449 = sext i8 %conv448 to i32
  %add450 = add nsw i32 %conv449, -128
  br label %cond.end.451

cond.end.451:                                     ; preds = %cond.false.443, %cond.true.437
  %cond452 = phi i32 [ %conv442, %cond.true.437 ], [ %add450, %cond.false.443 ]
  %conv453 = sext i32 %cond452 to i64
  store i64 %conv453, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2169, label %lor.lhs.false.2166

cond.false.454:                                   ; preds = %lor.lhs.false.427
  %68 = load i64, i64* %halflen, align 8
  %conv455 = trunc i64 %68 to i8
  %conv456 = zext i8 %conv455 to i32
  %mul457 = mul nsw i32 %conv456, 8
  %cmp458 = icmp sle i32 %mul457, 127
  br i1 %cmp458, label %cond.true.460, label %cond.false.466

cond.true.460:                                    ; preds = %cond.false.454
  %69 = load i64, i64* %halflen, align 8
  %conv461 = trunc i64 %69 to i8
  %conv462 = zext i8 %conv461 to i32
  %mul463 = mul nsw i32 %conv462, 8
  %conv464 = trunc i32 %mul463 to i8
  %conv465 = sext i8 %conv464 to i32
  br label %cond.end.474

cond.false.466:                                   ; preds = %cond.false.454
  %70 = load i64, i64* %halflen, align 8
  %conv467 = trunc i64 %70 to i8
  %conv468 = zext i8 %conv467 to i32
  %mul469 = mul nsw i32 %conv468, 8
  %sub470 = sub nsw i32 %mul469, -128
  %conv471 = trunc i32 %sub470 to i8
  %conv472 = sext i8 %conv471 to i32
  %add473 = add nsw i32 %conv472, -128
  br label %cond.end.474

cond.end.474:                                     ; preds = %cond.false.466, %cond.true.460
  %cond475 = phi i32 [ %conv465, %cond.true.460 ], [ %add473, %cond.false.466 ]
  %conv476 = sext i32 %cond475 to i64
  store i64 %conv476, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2169, label %lor.lhs.false.2166

cond.false.477:                                   ; preds = %do.body
  br i1 false, label %cond.true.478, label %cond.false.962

cond.true.478:                                    ; preds = %cond.false.477
  br i1 false, label %cond.true.479, label %cond.false.747

cond.true.479:                                    ; preds = %cond.true.478
  %71 = load i64, i64* %halflen, align 8
  %conv480 = trunc i64 %71 to i16
  %conv481 = sext i16 %conv480 to i32
  %add482 = add nsw i32 0, %conv481
  %mul483 = mul nsw i32 0, %add482
  %sub484 = sub nsw i32 %mul483, 1
  %cmp485 = icmp slt i32 %sub484, 0
  br i1 %cmp485, label %cond.true.487, label %cond.false.507

cond.true.487:                                    ; preds = %cond.true.479
  %72 = load i64, i64* %halflen, align 8
  %conv488 = trunc i64 %72 to i16
  %conv489 = sext i16 %conv488 to i32
  %add490 = add nsw i32 0, %conv489
  %mul491 = mul nsw i32 0, %add490
  %add492 = add nsw i32 %mul491, 0
  %neg493 = xor i32 %add492, -1
  %cmp494 = icmp eq i32 %neg493, -1
  %conv495 = zext i1 %cmp494 to i32
  %sub496 = sub nsw i32 0, %conv495
  %73 = load i64, i64* %halflen, align 8
  %conv497 = trunc i64 %73 to i16
  %conv498 = sext i16 %conv497 to i32
  %add499 = add nsw i32 0, %conv498
  %mul500 = mul nsw i32 0, %add499
  %add501 = add nsw i32 %mul500, 1
  %shl502 = shl i32 %add501, 30
  %sub503 = sub nsw i32 %shl502, 1
  %mul504 = mul nsw i32 %sub503, 2
  %add505 = add nsw i32 %mul504, 1
  %sub506 = sub nsw i32 %sub496, %add505
  br label %cond.end.513

cond.false.507:                                   ; preds = %cond.true.479
  %74 = load i64, i64* %halflen, align 8
  %conv508 = trunc i64 %74 to i16
  %conv509 = sext i16 %conv508 to i32
  %add510 = add nsw i32 0, %conv509
  %mul511 = mul nsw i32 0, %add510
  %add512 = add nsw i32 %mul511, 0
  br label %cond.end.513

cond.end.513:                                     ; preds = %cond.false.507, %cond.true.487
  %cond514 = phi i32 [ %sub506, %cond.true.487 ], [ %add512, %cond.false.507 ]
  %cmp515 = icmp eq i32 %cond514, 0
  br i1 %cmp515, label %land.lhs.true.517, label %lor.lhs.false.522

land.lhs.true.517:                                ; preds = %cond.end.513
  %75 = load i64, i64* %halflen, align 8
  %conv518 = trunc i64 %75 to i16
  %conv519 = sext i16 %conv518 to i32
  %cmp520 = icmp slt i32 %conv519, 0
  br i1 %cmp520, label %cond.true.701, label %lor.lhs.false.522

lor.lhs.false.522:                                ; preds = %land.lhs.true.517, %cond.end.513
  br i1 false, label %cond.true.523, label %cond.false.602

cond.true.523:                                    ; preds = %lor.lhs.false.522
  %76 = load i64, i64* %halflen, align 8
  %conv524 = trunc i64 %76 to i16
  %conv525 = sext i16 %conv524 to i32
  %cmp526 = icmp slt i32 %conv525, 0
  br i1 %cmp526, label %cond.true.528, label %cond.false.559

cond.true.528:                                    ; preds = %cond.true.523
  %77 = load i64, i64* %halflen, align 8
  %conv529 = trunc i64 %77 to i16
  %conv530 = sext i16 %conv529 to i32
  %78 = load i64, i64* %halflen, align 8
  %conv531 = trunc i64 %78 to i16
  %conv532 = sext i16 %conv531 to i32
  %add533 = add nsw i32 0, %conv532
  %mul534 = mul nsw i32 0, %add533
  %sub535 = sub nsw i32 %mul534, 1
  %cmp536 = icmp slt i32 %sub535, 0
  br i1 %cmp536, label %cond.true.538, label %cond.false.548

cond.true.538:                                    ; preds = %cond.true.528
  %79 = load i64, i64* %halflen, align 8
  %conv539 = trunc i64 %79 to i16
  %conv540 = sext i16 %conv539 to i32
  %add541 = add nsw i32 0, %conv540
  %mul542 = mul nsw i32 0, %add541
  %add543 = add nsw i32 %mul542, 1
  %shl544 = shl i32 %add543, 30
  %sub545 = sub nsw i32 %shl544, 1
  %mul546 = mul nsw i32 %sub545, 2
  %add547 = add nsw i32 %mul546, 1
  br label %cond.end.554

cond.false.548:                                   ; preds = %cond.true.528
  %80 = load i64, i64* %halflen, align 8
  %conv549 = trunc i64 %80 to i16
  %conv550 = sext i16 %conv549 to i32
  %add551 = add nsw i32 0, %conv550
  %mul552 = mul nsw i32 0, %add551
  %sub553 = sub nsw i32 %mul552, 1
  br label %cond.end.554

cond.end.554:                                     ; preds = %cond.false.548, %cond.true.538
  %cond555 = phi i32 [ %add547, %cond.true.538 ], [ %sub553, %cond.false.548 ]
  %div556 = sdiv i32 %cond555, 8
  %cmp557 = icmp slt i32 %conv530, %div556
  br i1 %cmp557, label %cond.true.701, label %lor.lhs.false.681

cond.false.559:                                   ; preds = %cond.true.523
  br i1 false, label %cond.true.560, label %cond.false.561

cond.true.560:                                    ; preds = %cond.false.559
  br i1 false, label %cond.true.701, label %lor.lhs.false.681

cond.false.561:                                   ; preds = %cond.false.559
  %81 = load i64, i64* %halflen, align 8
  %conv562 = trunc i64 %81 to i16
  %conv563 = sext i16 %conv562 to i32
  %add564 = add nsw i32 0, %conv563
  %mul565 = mul nsw i32 0, %add564
  %sub566 = sub nsw i32 %mul565, 1
  %cmp567 = icmp slt i32 %sub566, 0
  br i1 %cmp567, label %cond.true.569, label %cond.false.589

cond.true.569:                                    ; preds = %cond.false.561
  %82 = load i64, i64* %halflen, align 8
  %conv570 = trunc i64 %82 to i16
  %conv571 = sext i16 %conv570 to i32
  %add572 = add nsw i32 0, %conv571
  %mul573 = mul nsw i32 0, %add572
  %add574 = add nsw i32 %mul573, 0
  %neg575 = xor i32 %add574, -1
  %cmp576 = icmp eq i32 %neg575, -1
  %conv577 = zext i1 %cmp576 to i32
  %sub578 = sub nsw i32 0, %conv577
  %83 = load i64, i64* %halflen, align 8
  %conv579 = trunc i64 %83 to i16
  %conv580 = sext i16 %conv579 to i32
  %add581 = add nsw i32 0, %conv580
  %mul582 = mul nsw i32 0, %add581
  %add583 = add nsw i32 %mul582, 1
  %shl584 = shl i32 %add583, 30
  %sub585 = sub nsw i32 %shl584, 1
  %mul586 = mul nsw i32 %sub585, 2
  %add587 = add nsw i32 %mul586, 1
  %sub588 = sub nsw i32 %sub578, %add587
  br label %cond.end.595

cond.false.589:                                   ; preds = %cond.false.561
  %84 = load i64, i64* %halflen, align 8
  %conv590 = trunc i64 %84 to i16
  %conv591 = sext i16 %conv590 to i32
  %add592 = add nsw i32 0, %conv591
  %mul593 = mul nsw i32 0, %add592
  %add594 = add nsw i32 %mul593, 0
  br label %cond.end.595

cond.end.595:                                     ; preds = %cond.false.589, %cond.true.569
  %cond596 = phi i32 [ %sub588, %cond.true.569 ], [ %add594, %cond.false.589 ]
  %div597 = sdiv i32 %cond596, 8
  %85 = load i64, i64* %halflen, align 8
  %conv598 = trunc i64 %85 to i16
  %conv599 = sext i16 %conv598 to i32
  %cmp600 = icmp slt i32 %div597, %conv599
  br i1 %cmp600, label %cond.true.701, label %lor.lhs.false.681

cond.false.602:                                   ; preds = %lor.lhs.false.522
  br i1 false, label %cond.true.603, label %cond.false.604

cond.true.603:                                    ; preds = %cond.false.602
  br i1 false, label %cond.true.701, label %lor.lhs.false.681

cond.false.604:                                   ; preds = %cond.false.602
  %86 = load i64, i64* %halflen, align 8
  %conv605 = trunc i64 %86 to i16
  %conv606 = sext i16 %conv605 to i32
  %cmp607 = icmp slt i32 %conv606, 0
  br i1 %cmp607, label %cond.true.609, label %cond.false.650

cond.true.609:                                    ; preds = %cond.false.604
  %87 = load i64, i64* %halflen, align 8
  %conv610 = trunc i64 %87 to i16
  %conv611 = sext i16 %conv610 to i32
  %88 = load i64, i64* %halflen, align 8
  %conv612 = trunc i64 %88 to i16
  %conv613 = sext i16 %conv612 to i32
  %add614 = add nsw i32 0, %conv613
  %mul615 = mul nsw i32 0, %add614
  %sub616 = sub nsw i32 %mul615, 1
  %cmp617 = icmp slt i32 %sub616, 0
  br i1 %cmp617, label %cond.true.619, label %cond.false.639

cond.true.619:                                    ; preds = %cond.true.609
  %89 = load i64, i64* %halflen, align 8
  %conv620 = trunc i64 %89 to i16
  %conv621 = sext i16 %conv620 to i32
  %add622 = add nsw i32 0, %conv621
  %mul623 = mul nsw i32 0, %add622
  %add624 = add nsw i32 %mul623, 0
  %neg625 = xor i32 %add624, -1
  %cmp626 = icmp eq i32 %neg625, -1
  %conv627 = zext i1 %cmp626 to i32
  %sub628 = sub nsw i32 0, %conv627
  %90 = load i64, i64* %halflen, align 8
  %conv629 = trunc i64 %90 to i16
  %conv630 = sext i16 %conv629 to i32
  %add631 = add nsw i32 0, %conv630
  %mul632 = mul nsw i32 0, %add631
  %add633 = add nsw i32 %mul632, 1
  %shl634 = shl i32 %add633, 30
  %sub635 = sub nsw i32 %shl634, 1
  %mul636 = mul nsw i32 %sub635, 2
  %add637 = add nsw i32 %mul636, 1
  %sub638 = sub nsw i32 %sub628, %add637
  br label %cond.end.645

cond.false.639:                                   ; preds = %cond.true.609
  %91 = load i64, i64* %halflen, align 8
  %conv640 = trunc i64 %91 to i16
  %conv641 = sext i16 %conv640 to i32
  %add642 = add nsw i32 0, %conv641
  %mul643 = mul nsw i32 0, %add642
  %add644 = add nsw i32 %mul643, 0
  br label %cond.end.645

cond.end.645:                                     ; preds = %cond.false.639, %cond.true.619
  %cond646 = phi i32 [ %sub638, %cond.true.619 ], [ %add644, %cond.false.639 ]
  %div647 = sdiv i32 %cond646, 8
  %cmp648 = icmp slt i32 %conv611, %div647
  br i1 %cmp648, label %cond.true.701, label %lor.lhs.false.681

cond.false.650:                                   ; preds = %cond.false.604
  %92 = load i64, i64* %halflen, align 8
  %conv651 = trunc i64 %92 to i16
  %conv652 = sext i16 %conv651 to i32
  %add653 = add nsw i32 0, %conv652
  %mul654 = mul nsw i32 0, %add653
  %sub655 = sub nsw i32 %mul654, 1
  %cmp656 = icmp slt i32 %sub655, 0
  br i1 %cmp656, label %cond.true.658, label %cond.false.668

cond.true.658:                                    ; preds = %cond.false.650
  %93 = load i64, i64* %halflen, align 8
  %conv659 = trunc i64 %93 to i16
  %conv660 = sext i16 %conv659 to i32
  %add661 = add nsw i32 0, %conv660
  %mul662 = mul nsw i32 0, %add661
  %add663 = add nsw i32 %mul662, 1
  %shl664 = shl i32 %add663, 30
  %sub665 = sub nsw i32 %shl664, 1
  %mul666 = mul nsw i32 %sub665, 2
  %add667 = add nsw i32 %mul666, 1
  br label %cond.end.674

cond.false.668:                                   ; preds = %cond.false.650
  %94 = load i64, i64* %halflen, align 8
  %conv669 = trunc i64 %94 to i16
  %conv670 = sext i16 %conv669 to i32
  %add671 = add nsw i32 0, %conv670
  %mul672 = mul nsw i32 0, %add671
  %sub673 = sub nsw i32 %mul672, 1
  br label %cond.end.674

cond.end.674:                                     ; preds = %cond.false.668, %cond.true.658
  %cond675 = phi i32 [ %add667, %cond.true.658 ], [ %sub673, %cond.false.668 ]
  %div676 = sdiv i32 %cond675, 8
  %95 = load i64, i64* %halflen, align 8
  %conv677 = trunc i64 %95 to i16
  %conv678 = sext i16 %conv677 to i32
  %cmp679 = icmp slt i32 %div676, %conv678
  br i1 %cmp679, label %cond.true.701, label %lor.lhs.false.681

lor.lhs.false.681:                                ; preds = %cond.end.674, %cond.end.645, %cond.true.603, %cond.end.595, %cond.true.560, %cond.end.554
  %96 = load i64, i64* %halflen, align 8
  %conv682 = trunc i64 %96 to i16
  %conv683 = sext i16 %conv682 to i32
  %mul684 = mul nsw i32 %conv683, 8
  %mul685 = mul nsw i32 0, %mul684
  %sub686 = sub nsw i32 %mul685, 1
  %cmp687 = icmp slt i32 %sub686, 0
  br i1 %cmp687, label %land.lhs.true.689, label %lor.lhs.false.695

land.lhs.true.689:                                ; preds = %lor.lhs.false.681
  %97 = load i64, i64* %halflen, align 8
  %conv690 = trunc i64 %97 to i16
  %conv691 = sext i16 %conv690 to i32
  %mul692 = mul nsw i32 %conv691, 8
  %cmp693 = icmp slt i32 %mul692, -32768
  br i1 %cmp693, label %cond.true.701, label %lor.lhs.false.695

lor.lhs.false.695:                                ; preds = %land.lhs.true.689, %lor.lhs.false.681
  %98 = load i64, i64* %halflen, align 8
  %conv696 = trunc i64 %98 to i16
  %conv697 = sext i16 %conv696 to i32
  %mul698 = mul nsw i32 %conv697, 8
  %cmp699 = icmp slt i32 32767, %mul698
  br i1 %cmp699, label %cond.true.701, label %cond.false.724

cond.true.701:                                    ; preds = %lor.lhs.false.695, %land.lhs.true.689, %cond.end.674, %cond.end.645, %cond.true.603, %cond.end.595, %cond.true.560, %cond.end.554, %land.lhs.true.517
  %99 = load i64, i64* %halflen, align 8
  %conv702 = trunc i64 %99 to i16
  %conv703 = zext i16 %conv702 to i32
  %mul704 = mul nsw i32 %conv703, 8
  %cmp705 = icmp sle i32 %mul704, 32767
  br i1 %cmp705, label %cond.true.707, label %cond.false.713

cond.true.707:                                    ; preds = %cond.true.701
  %100 = load i64, i64* %halflen, align 8
  %conv708 = trunc i64 %100 to i16
  %conv709 = zext i16 %conv708 to i32
  %mul710 = mul nsw i32 %conv709, 8
  %conv711 = trunc i32 %mul710 to i16
  %conv712 = sext i16 %conv711 to i32
  br label %cond.end.721

cond.false.713:                                   ; preds = %cond.true.701
  %101 = load i64, i64* %halflen, align 8
  %conv714 = trunc i64 %101 to i16
  %conv715 = zext i16 %conv714 to i32
  %mul716 = mul nsw i32 %conv715, 8
  %sub717 = sub nsw i32 %mul716, -32768
  %conv718 = trunc i32 %sub717 to i16
  %conv719 = sext i16 %conv718 to i32
  %add720 = add nsw i32 %conv719, -32768
  br label %cond.end.721

cond.end.721:                                     ; preds = %cond.false.713, %cond.true.707
  %cond722 = phi i32 [ %conv712, %cond.true.707 ], [ %add720, %cond.false.713 ]
  %conv723 = sext i32 %cond722 to i64
  store i64 %conv723, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2169, label %lor.lhs.false.2166

cond.false.724:                                   ; preds = %lor.lhs.false.695
  %102 = load i64, i64* %halflen, align 8
  %conv725 = trunc i64 %102 to i16
  %conv726 = zext i16 %conv725 to i32
  %mul727 = mul nsw i32 %conv726, 8
  %cmp728 = icmp sle i32 %mul727, 32767
  br i1 %cmp728, label %cond.true.730, label %cond.false.736

cond.true.730:                                    ; preds = %cond.false.724
  %103 = load i64, i64* %halflen, align 8
  %conv731 = trunc i64 %103 to i16
  %conv732 = zext i16 %conv731 to i32
  %mul733 = mul nsw i32 %conv732, 8
  %conv734 = trunc i32 %mul733 to i16
  %conv735 = sext i16 %conv734 to i32
  br label %cond.end.744

cond.false.736:                                   ; preds = %cond.false.724
  %104 = load i64, i64* %halflen, align 8
  %conv737 = trunc i64 %104 to i16
  %conv738 = zext i16 %conv737 to i32
  %mul739 = mul nsw i32 %conv738, 8
  %sub740 = sub nsw i32 %mul739, -32768
  %conv741 = trunc i32 %sub740 to i16
  %conv742 = sext i16 %conv741 to i32
  %add743 = add nsw i32 %conv742, -32768
  br label %cond.end.744

cond.end.744:                                     ; preds = %cond.false.736, %cond.true.730
  %cond745 = phi i32 [ %conv735, %cond.true.730 ], [ %add743, %cond.false.736 ]
  %conv746 = sext i32 %cond745 to i64
  store i64 %conv746, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2169, label %lor.lhs.false.2166

cond.false.747:                                   ; preds = %cond.true.478
  %105 = load i64, i64* %halflen, align 8
  %add748 = add nsw i64 0, %105
  %mul749 = mul nsw i64 0, %add748
  %sub750 = sub nsw i64 %mul749, 1
  %cmp751 = icmp slt i64 %sub750, 0
  br i1 %cmp751, label %cond.true.753, label %cond.false.770

cond.true.753:                                    ; preds = %cond.false.747
  %106 = load i64, i64* %halflen, align 8
  %add754 = add nsw i64 0, %106
  %mul755 = mul nsw i64 0, %add754
  %add756 = add nsw i64 %mul755, 0
  %neg757 = xor i64 %add756, -1
  %cmp758 = icmp eq i64 %neg757, -1
  %conv759 = zext i1 %cmp758 to i32
  %sub760 = sub nsw i32 0, %conv759
  %conv761 = sext i32 %sub760 to i64
  %107 = load i64, i64* %halflen, align 8
  %add762 = add nsw i64 0, %107
  %mul763 = mul nsw i64 0, %add762
  %add764 = add nsw i64 %mul763, 1
  %shl765 = shl i64 %add764, 62
  %sub766 = sub nsw i64 %shl765, 1
  %mul767 = mul nsw i64 %sub766, 2
  %add768 = add nsw i64 %mul767, 1
  %sub769 = sub nsw i64 %conv761, %add768
  br label %cond.end.774

cond.false.770:                                   ; preds = %cond.false.747
  %108 = load i64, i64* %halflen, align 8
  %add771 = add nsw i64 0, %108
  %mul772 = mul nsw i64 0, %add771
  %add773 = add nsw i64 %mul772, 0
  br label %cond.end.774

cond.end.774:                                     ; preds = %cond.false.770, %cond.true.753
  %cond775 = phi i64 [ %sub769, %cond.true.753 ], [ %add773, %cond.false.770 ]
  %cmp776 = icmp eq i64 %cond775, 0
  br i1 %cmp776, label %land.lhs.true.778, label %lor.lhs.false.781

land.lhs.true.778:                                ; preds = %cond.end.774
  %109 = load i64, i64* %halflen, align 8
  %cmp779 = icmp slt i64 %109, 0
  br i1 %cmp779, label %cond.true.916, label %lor.lhs.false.781

lor.lhs.false.781:                                ; preds = %land.lhs.true.778, %cond.end.774
  br i1 false, label %cond.true.782, label %cond.false.842

cond.true.782:                                    ; preds = %lor.lhs.false.781
  %110 = load i64, i64* %halflen, align 8
  %cmp783 = icmp slt i64 %110, 0
  br i1 %cmp783, label %cond.true.785, label %cond.false.808

cond.true.785:                                    ; preds = %cond.true.782
  %111 = load i64, i64* %halflen, align 8
  %112 = load i64, i64* %halflen, align 8
  %add786 = add nsw i64 0, %112
  %mul787 = mul nsw i64 0, %add786
  %sub788 = sub nsw i64 %mul787, 1
  %cmp789 = icmp slt i64 %sub788, 0
  br i1 %cmp789, label %cond.true.791, label %cond.false.799

cond.true.791:                                    ; preds = %cond.true.785
  %113 = load i64, i64* %halflen, align 8
  %add792 = add nsw i64 0, %113
  %mul793 = mul nsw i64 0, %add792
  %add794 = add nsw i64 %mul793, 1
  %shl795 = shl i64 %add794, 62
  %sub796 = sub nsw i64 %shl795, 1
  %mul797 = mul nsw i64 %sub796, 2
  %add798 = add nsw i64 %mul797, 1
  br label %cond.end.803

cond.false.799:                                   ; preds = %cond.true.785
  %114 = load i64, i64* %halflen, align 8
  %add800 = add nsw i64 0, %114
  %mul801 = mul nsw i64 0, %add800
  %sub802 = sub nsw i64 %mul801, 1
  br label %cond.end.803

cond.end.803:                                     ; preds = %cond.false.799, %cond.true.791
  %cond804 = phi i64 [ %add798, %cond.true.791 ], [ %sub802, %cond.false.799 ]
  %div805 = sdiv i64 %cond804, 8
  %cmp806 = icmp slt i64 %111, %div805
  br i1 %cmp806, label %cond.true.916, label %lor.lhs.false.902

cond.false.808:                                   ; preds = %cond.true.782
  br i1 false, label %cond.true.809, label %cond.false.810

cond.true.809:                                    ; preds = %cond.false.808
  br i1 false, label %cond.true.916, label %lor.lhs.false.902

cond.false.810:                                   ; preds = %cond.false.808
  %115 = load i64, i64* %halflen, align 8
  %add811 = add nsw i64 0, %115
  %mul812 = mul nsw i64 0, %add811
  %sub813 = sub nsw i64 %mul812, 1
  %cmp814 = icmp slt i64 %sub813, 0
  br i1 %cmp814, label %cond.true.816, label %cond.false.833

cond.true.816:                                    ; preds = %cond.false.810
  %116 = load i64, i64* %halflen, align 8
  %add817 = add nsw i64 0, %116
  %mul818 = mul nsw i64 0, %add817
  %add819 = add nsw i64 %mul818, 0
  %neg820 = xor i64 %add819, -1
  %cmp821 = icmp eq i64 %neg820, -1
  %conv822 = zext i1 %cmp821 to i32
  %sub823 = sub nsw i32 0, %conv822
  %conv824 = sext i32 %sub823 to i64
  %117 = load i64, i64* %halflen, align 8
  %add825 = add nsw i64 0, %117
  %mul826 = mul nsw i64 0, %add825
  %add827 = add nsw i64 %mul826, 1
  %shl828 = shl i64 %add827, 62
  %sub829 = sub nsw i64 %shl828, 1
  %mul830 = mul nsw i64 %sub829, 2
  %add831 = add nsw i64 %mul830, 1
  %sub832 = sub nsw i64 %conv824, %add831
  br label %cond.end.837

cond.false.833:                                   ; preds = %cond.false.810
  %118 = load i64, i64* %halflen, align 8
  %add834 = add nsw i64 0, %118
  %mul835 = mul nsw i64 0, %add834
  %add836 = add nsw i64 %mul835, 0
  br label %cond.end.837

cond.end.837:                                     ; preds = %cond.false.833, %cond.true.816
  %cond838 = phi i64 [ %sub832, %cond.true.816 ], [ %add836, %cond.false.833 ]
  %div839 = sdiv i64 %cond838, 8
  %119 = load i64, i64* %halflen, align 8
  %cmp840 = icmp slt i64 %div839, %119
  br i1 %cmp840, label %cond.true.916, label %lor.lhs.false.902

cond.false.842:                                   ; preds = %lor.lhs.false.781
  br i1 false, label %cond.true.843, label %cond.false.844

cond.true.843:                                    ; preds = %cond.false.842
  br i1 false, label %cond.true.916, label %lor.lhs.false.902

cond.false.844:                                   ; preds = %cond.false.842
  %120 = load i64, i64* %halflen, align 8
  %cmp845 = icmp slt i64 %120, 0
  br i1 %cmp845, label %cond.true.847, label %cond.false.879

cond.true.847:                                    ; preds = %cond.false.844
  %121 = load i64, i64* %halflen, align 8
  %122 = load i64, i64* %halflen, align 8
  %add848 = add nsw i64 0, %122
  %mul849 = mul nsw i64 0, %add848
  %sub850 = sub nsw i64 %mul849, 1
  %cmp851 = icmp slt i64 %sub850, 0
  br i1 %cmp851, label %cond.true.853, label %cond.false.870

cond.true.853:                                    ; preds = %cond.true.847
  %123 = load i64, i64* %halflen, align 8
  %add854 = add nsw i64 0, %123
  %mul855 = mul nsw i64 0, %add854
  %add856 = add nsw i64 %mul855, 0
  %neg857 = xor i64 %add856, -1
  %cmp858 = icmp eq i64 %neg857, -1
  %conv859 = zext i1 %cmp858 to i32
  %sub860 = sub nsw i32 0, %conv859
  %conv861 = sext i32 %sub860 to i64
  %124 = load i64, i64* %halflen, align 8
  %add862 = add nsw i64 0, %124
  %mul863 = mul nsw i64 0, %add862
  %add864 = add nsw i64 %mul863, 1
  %shl865 = shl i64 %add864, 62
  %sub866 = sub nsw i64 %shl865, 1
  %mul867 = mul nsw i64 %sub866, 2
  %add868 = add nsw i64 %mul867, 1
  %sub869 = sub nsw i64 %conv861, %add868
  br label %cond.end.874

cond.false.870:                                   ; preds = %cond.true.847
  %125 = load i64, i64* %halflen, align 8
  %add871 = add nsw i64 0, %125
  %mul872 = mul nsw i64 0, %add871
  %add873 = add nsw i64 %mul872, 0
  br label %cond.end.874

cond.end.874:                                     ; preds = %cond.false.870, %cond.true.853
  %cond875 = phi i64 [ %sub869, %cond.true.853 ], [ %add873, %cond.false.870 ]
  %div876 = sdiv i64 %cond875, 8
  %cmp877 = icmp slt i64 %121, %div876
  br i1 %cmp877, label %cond.true.916, label %lor.lhs.false.902

cond.false.879:                                   ; preds = %cond.false.844
  %126 = load i64, i64* %halflen, align 8
  %add880 = add nsw i64 0, %126
  %mul881 = mul nsw i64 0, %add880
  %sub882 = sub nsw i64 %mul881, 1
  %cmp883 = icmp slt i64 %sub882, 0
  br i1 %cmp883, label %cond.true.885, label %cond.false.893

cond.true.885:                                    ; preds = %cond.false.879
  %127 = load i64, i64* %halflen, align 8
  %add886 = add nsw i64 0, %127
  %mul887 = mul nsw i64 0, %add886
  %add888 = add nsw i64 %mul887, 1
  %shl889 = shl i64 %add888, 62
  %sub890 = sub nsw i64 %shl889, 1
  %mul891 = mul nsw i64 %sub890, 2
  %add892 = add nsw i64 %mul891, 1
  br label %cond.end.897

cond.false.893:                                   ; preds = %cond.false.879
  %128 = load i64, i64* %halflen, align 8
  %add894 = add nsw i64 0, %128
  %mul895 = mul nsw i64 0, %add894
  %sub896 = sub nsw i64 %mul895, 1
  br label %cond.end.897

cond.end.897:                                     ; preds = %cond.false.893, %cond.true.885
  %cond898 = phi i64 [ %add892, %cond.true.885 ], [ %sub896, %cond.false.893 ]
  %div899 = sdiv i64 %cond898, 8
  %129 = load i64, i64* %halflen, align 8
  %cmp900 = icmp slt i64 %div899, %129
  br i1 %cmp900, label %cond.true.916, label %lor.lhs.false.902

lor.lhs.false.902:                                ; preds = %cond.end.897, %cond.end.874, %cond.true.843, %cond.end.837, %cond.true.809, %cond.end.803
  %130 = load i64, i64* %halflen, align 8
  %mul903 = mul nsw i64 %130, 8
  %mul904 = mul nsw i64 0, %mul903
  %sub905 = sub nsw i64 %mul904, 1
  %cmp906 = icmp slt i64 %sub905, 0
  br i1 %cmp906, label %land.lhs.true.908, label %lor.lhs.false.912

land.lhs.true.908:                                ; preds = %lor.lhs.false.902
  %131 = load i64, i64* %halflen, align 8
  %mul909 = mul nsw i64 %131, 8
  %cmp910 = icmp slt i64 %mul909, -32768
  br i1 %cmp910, label %cond.true.916, label %lor.lhs.false.912

lor.lhs.false.912:                                ; preds = %land.lhs.true.908, %lor.lhs.false.902
  %132 = load i64, i64* %halflen, align 8
  %mul913 = mul nsw i64 %132, 8
  %cmp914 = icmp slt i64 32767, %mul913
  br i1 %cmp914, label %cond.true.916, label %cond.false.939

cond.true.916:                                    ; preds = %lor.lhs.false.912, %land.lhs.true.908, %cond.end.897, %cond.end.874, %cond.true.843, %cond.end.837, %cond.true.809, %cond.end.803, %land.lhs.true.778
  %133 = load i64, i64* %halflen, align 8
  %conv917 = trunc i64 %133 to i16
  %conv918 = zext i16 %conv917 to i32
  %mul919 = mul nsw i32 %conv918, 8
  %cmp920 = icmp sle i32 %mul919, 32767
  br i1 %cmp920, label %cond.true.922, label %cond.false.928

cond.true.922:                                    ; preds = %cond.true.916
  %134 = load i64, i64* %halflen, align 8
  %conv923 = trunc i64 %134 to i16
  %conv924 = zext i16 %conv923 to i32
  %mul925 = mul nsw i32 %conv924, 8
  %conv926 = trunc i32 %mul925 to i16
  %conv927 = sext i16 %conv926 to i32
  br label %cond.end.936

cond.false.928:                                   ; preds = %cond.true.916
  %135 = load i64, i64* %halflen, align 8
  %conv929 = trunc i64 %135 to i16
  %conv930 = zext i16 %conv929 to i32
  %mul931 = mul nsw i32 %conv930, 8
  %sub932 = sub nsw i32 %mul931, -32768
  %conv933 = trunc i32 %sub932 to i16
  %conv934 = sext i16 %conv933 to i32
  %add935 = add nsw i32 %conv934, -32768
  br label %cond.end.936

cond.end.936:                                     ; preds = %cond.false.928, %cond.true.922
  %cond937 = phi i32 [ %conv927, %cond.true.922 ], [ %add935, %cond.false.928 ]
  %conv938 = sext i32 %cond937 to i64
  store i64 %conv938, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2169, label %lor.lhs.false.2166

cond.false.939:                                   ; preds = %lor.lhs.false.912
  %136 = load i64, i64* %halflen, align 8
  %conv940 = trunc i64 %136 to i16
  %conv941 = zext i16 %conv940 to i32
  %mul942 = mul nsw i32 %conv941, 8
  %cmp943 = icmp sle i32 %mul942, 32767
  br i1 %cmp943, label %cond.true.945, label %cond.false.951

cond.true.945:                                    ; preds = %cond.false.939
  %137 = load i64, i64* %halflen, align 8
  %conv946 = trunc i64 %137 to i16
  %conv947 = zext i16 %conv946 to i32
  %mul948 = mul nsw i32 %conv947, 8
  %conv949 = trunc i32 %mul948 to i16
  %conv950 = sext i16 %conv949 to i32
  br label %cond.end.959

cond.false.951:                                   ; preds = %cond.false.939
  %138 = load i64, i64* %halflen, align 8
  %conv952 = trunc i64 %138 to i16
  %conv953 = zext i16 %conv952 to i32
  %mul954 = mul nsw i32 %conv953, 8
  %sub955 = sub nsw i32 %mul954, -32768
  %conv956 = trunc i32 %sub955 to i16
  %conv957 = sext i16 %conv956 to i32
  %add958 = add nsw i32 %conv957, -32768
  br label %cond.end.959

cond.end.959:                                     ; preds = %cond.false.951, %cond.true.945
  %cond960 = phi i32 [ %conv950, %cond.true.945 ], [ %add958, %cond.false.951 ]
  %conv961 = sext i32 %cond960 to i64
  store i64 %conv961, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2169, label %lor.lhs.false.2166

cond.false.962:                                   ; preds = %cond.false.477
  br i1 false, label %cond.true.963, label %cond.false.1391

cond.true.963:                                    ; preds = %cond.false.962
  br i1 false, label %cond.true.964, label %cond.false.1190

cond.true.964:                                    ; preds = %cond.true.963
  %139 = load i64, i64* %halflen, align 8
  %conv965 = trunc i64 %139 to i32
  %add966 = add nsw i32 0, %conv965
  %mul967 = mul nsw i32 0, %add966
  %sub968 = sub nsw i32 %mul967, 1
  %cmp969 = icmp slt i32 %sub968, 0
  br i1 %cmp969, label %cond.true.971, label %cond.false.989

cond.true.971:                                    ; preds = %cond.true.964
  %140 = load i64, i64* %halflen, align 8
  %conv972 = trunc i64 %140 to i32
  %add973 = add nsw i32 0, %conv972
  %mul974 = mul nsw i32 0, %add973
  %add975 = add nsw i32 %mul974, 0
  %neg976 = xor i32 %add975, -1
  %cmp977 = icmp eq i32 %neg976, -1
  %conv978 = zext i1 %cmp977 to i32
  %sub979 = sub nsw i32 0, %conv978
  %141 = load i64, i64* %halflen, align 8
  %conv980 = trunc i64 %141 to i32
  %add981 = add nsw i32 0, %conv980
  %mul982 = mul nsw i32 0, %add981
  %add983 = add nsw i32 %mul982, 1
  %shl984 = shl i32 %add983, 30
  %sub985 = sub nsw i32 %shl984, 1
  %mul986 = mul nsw i32 %sub985, 2
  %add987 = add nsw i32 %mul986, 1
  %sub988 = sub nsw i32 %sub979, %add987
  br label %cond.end.994

cond.false.989:                                   ; preds = %cond.true.964
  %142 = load i64, i64* %halflen, align 8
  %conv990 = trunc i64 %142 to i32
  %add991 = add nsw i32 0, %conv990
  %mul992 = mul nsw i32 0, %add991
  %add993 = add nsw i32 %mul992, 0
  br label %cond.end.994

cond.end.994:                                     ; preds = %cond.false.989, %cond.true.971
  %cond995 = phi i32 [ %sub988, %cond.true.971 ], [ %add993, %cond.false.989 ]
  %cmp996 = icmp eq i32 %cond995, 0
  br i1 %cmp996, label %land.lhs.true.998, label %lor.lhs.false.1002

land.lhs.true.998:                                ; preds = %cond.end.994
  %143 = load i64, i64* %halflen, align 8
  %conv999 = trunc i64 %143 to i32
  %cmp1000 = icmp slt i32 %conv999, 0
  br i1 %cmp1000, label %cond.true.1158, label %lor.lhs.false.1002

lor.lhs.false.1002:                               ; preds = %land.lhs.true.998, %cond.end.994
  br i1 false, label %cond.true.1003, label %cond.false.1072

cond.true.1003:                                   ; preds = %lor.lhs.false.1002
  %144 = load i64, i64* %halflen, align 8
  %conv1004 = trunc i64 %144 to i32
  %cmp1005 = icmp slt i32 %conv1004, 0
  br i1 %cmp1005, label %cond.true.1007, label %cond.false.1034

cond.true.1007:                                   ; preds = %cond.true.1003
  %145 = load i64, i64* %halflen, align 8
  %conv1008 = trunc i64 %145 to i32
  %146 = load i64, i64* %halflen, align 8
  %conv1009 = trunc i64 %146 to i32
  %add1010 = add nsw i32 0, %conv1009
  %mul1011 = mul nsw i32 0, %add1010
  %sub1012 = sub nsw i32 %mul1011, 1
  %cmp1013 = icmp slt i32 %sub1012, 0
  br i1 %cmp1013, label %cond.true.1015, label %cond.false.1024

cond.true.1015:                                   ; preds = %cond.true.1007
  %147 = load i64, i64* %halflen, align 8
  %conv1016 = trunc i64 %147 to i32
  %add1017 = add nsw i32 0, %conv1016
  %mul1018 = mul nsw i32 0, %add1017
  %add1019 = add nsw i32 %mul1018, 1
  %shl1020 = shl i32 %add1019, 30
  %sub1021 = sub nsw i32 %shl1020, 1
  %mul1022 = mul nsw i32 %sub1021, 2
  %add1023 = add nsw i32 %mul1022, 1
  br label %cond.end.1029

cond.false.1024:                                  ; preds = %cond.true.1007
  %148 = load i64, i64* %halflen, align 8
  %conv1025 = trunc i64 %148 to i32
  %add1026 = add nsw i32 0, %conv1025
  %mul1027 = mul nsw i32 0, %add1026
  %sub1028 = sub nsw i32 %mul1027, 1
  br label %cond.end.1029

cond.end.1029:                                    ; preds = %cond.false.1024, %cond.true.1015
  %cond1030 = phi i32 [ %add1023, %cond.true.1015 ], [ %sub1028, %cond.false.1024 ]
  %div1031 = sdiv i32 %cond1030, 8
  %cmp1032 = icmp slt i32 %conv1008, %div1031
  br i1 %cmp1032, label %cond.true.1158, label %lor.lhs.false.1141

cond.false.1034:                                  ; preds = %cond.true.1003
  br i1 false, label %cond.true.1035, label %cond.false.1036

cond.true.1035:                                   ; preds = %cond.false.1034
  br i1 false, label %cond.true.1158, label %lor.lhs.false.1141

cond.false.1036:                                  ; preds = %cond.false.1034
  %149 = load i64, i64* %halflen, align 8
  %conv1037 = trunc i64 %149 to i32
  %add1038 = add nsw i32 0, %conv1037
  %mul1039 = mul nsw i32 0, %add1038
  %sub1040 = sub nsw i32 %mul1039, 1
  %cmp1041 = icmp slt i32 %sub1040, 0
  br i1 %cmp1041, label %cond.true.1043, label %cond.false.1061

cond.true.1043:                                   ; preds = %cond.false.1036
  %150 = load i64, i64* %halflen, align 8
  %conv1044 = trunc i64 %150 to i32
  %add1045 = add nsw i32 0, %conv1044
  %mul1046 = mul nsw i32 0, %add1045
  %add1047 = add nsw i32 %mul1046, 0
  %neg1048 = xor i32 %add1047, -1
  %cmp1049 = icmp eq i32 %neg1048, -1
  %conv1050 = zext i1 %cmp1049 to i32
  %sub1051 = sub nsw i32 0, %conv1050
  %151 = load i64, i64* %halflen, align 8
  %conv1052 = trunc i64 %151 to i32
  %add1053 = add nsw i32 0, %conv1052
  %mul1054 = mul nsw i32 0, %add1053
  %add1055 = add nsw i32 %mul1054, 1
  %shl1056 = shl i32 %add1055, 30
  %sub1057 = sub nsw i32 %shl1056, 1
  %mul1058 = mul nsw i32 %sub1057, 2
  %add1059 = add nsw i32 %mul1058, 1
  %sub1060 = sub nsw i32 %sub1051, %add1059
  br label %cond.end.1066

cond.false.1061:                                  ; preds = %cond.false.1036
  %152 = load i64, i64* %halflen, align 8
  %conv1062 = trunc i64 %152 to i32
  %add1063 = add nsw i32 0, %conv1062
  %mul1064 = mul nsw i32 0, %add1063
  %add1065 = add nsw i32 %mul1064, 0
  br label %cond.end.1066

cond.end.1066:                                    ; preds = %cond.false.1061, %cond.true.1043
  %cond1067 = phi i32 [ %sub1060, %cond.true.1043 ], [ %add1065, %cond.false.1061 ]
  %div1068 = sdiv i32 %cond1067, 8
  %153 = load i64, i64* %halflen, align 8
  %conv1069 = trunc i64 %153 to i32
  %cmp1070 = icmp slt i32 %div1068, %conv1069
  br i1 %cmp1070, label %cond.true.1158, label %lor.lhs.false.1141

cond.false.1072:                                  ; preds = %lor.lhs.false.1002
  br i1 false, label %cond.true.1073, label %cond.false.1074

cond.true.1073:                                   ; preds = %cond.false.1072
  br i1 false, label %cond.true.1158, label %lor.lhs.false.1141

cond.false.1074:                                  ; preds = %cond.false.1072
  %154 = load i64, i64* %halflen, align 8
  %conv1075 = trunc i64 %154 to i32
  %cmp1076 = icmp slt i32 %conv1075, 0
  br i1 %cmp1076, label %cond.true.1078, label %cond.false.1114

cond.true.1078:                                   ; preds = %cond.false.1074
  %155 = load i64, i64* %halflen, align 8
  %conv1079 = trunc i64 %155 to i32
  %156 = load i64, i64* %halflen, align 8
  %conv1080 = trunc i64 %156 to i32
  %add1081 = add nsw i32 0, %conv1080
  %mul1082 = mul nsw i32 0, %add1081
  %sub1083 = sub nsw i32 %mul1082, 1
  %cmp1084 = icmp slt i32 %sub1083, 0
  br i1 %cmp1084, label %cond.true.1086, label %cond.false.1104

cond.true.1086:                                   ; preds = %cond.true.1078
  %157 = load i64, i64* %halflen, align 8
  %conv1087 = trunc i64 %157 to i32
  %add1088 = add nsw i32 0, %conv1087
  %mul1089 = mul nsw i32 0, %add1088
  %add1090 = add nsw i32 %mul1089, 0
  %neg1091 = xor i32 %add1090, -1
  %cmp1092 = icmp eq i32 %neg1091, -1
  %conv1093 = zext i1 %cmp1092 to i32
  %sub1094 = sub nsw i32 0, %conv1093
  %158 = load i64, i64* %halflen, align 8
  %conv1095 = trunc i64 %158 to i32
  %add1096 = add nsw i32 0, %conv1095
  %mul1097 = mul nsw i32 0, %add1096
  %add1098 = add nsw i32 %mul1097, 1
  %shl1099 = shl i32 %add1098, 30
  %sub1100 = sub nsw i32 %shl1099, 1
  %mul1101 = mul nsw i32 %sub1100, 2
  %add1102 = add nsw i32 %mul1101, 1
  %sub1103 = sub nsw i32 %sub1094, %add1102
  br label %cond.end.1109

cond.false.1104:                                  ; preds = %cond.true.1078
  %159 = load i64, i64* %halflen, align 8
  %conv1105 = trunc i64 %159 to i32
  %add1106 = add nsw i32 0, %conv1105
  %mul1107 = mul nsw i32 0, %add1106
  %add1108 = add nsw i32 %mul1107, 0
  br label %cond.end.1109

cond.end.1109:                                    ; preds = %cond.false.1104, %cond.true.1086
  %cond1110 = phi i32 [ %sub1103, %cond.true.1086 ], [ %add1108, %cond.false.1104 ]
  %div1111 = sdiv i32 %cond1110, 8
  %cmp1112 = icmp slt i32 %conv1079, %div1111
  br i1 %cmp1112, label %cond.true.1158, label %lor.lhs.false.1141

cond.false.1114:                                  ; preds = %cond.false.1074
  %160 = load i64, i64* %halflen, align 8
  %conv1115 = trunc i64 %160 to i32
  %add1116 = add nsw i32 0, %conv1115
  %mul1117 = mul nsw i32 0, %add1116
  %sub1118 = sub nsw i32 %mul1117, 1
  %cmp1119 = icmp slt i32 %sub1118, 0
  br i1 %cmp1119, label %cond.true.1121, label %cond.false.1130

cond.true.1121:                                   ; preds = %cond.false.1114
  %161 = load i64, i64* %halflen, align 8
  %conv1122 = trunc i64 %161 to i32
  %add1123 = add nsw i32 0, %conv1122
  %mul1124 = mul nsw i32 0, %add1123
  %add1125 = add nsw i32 %mul1124, 1
  %shl1126 = shl i32 %add1125, 30
  %sub1127 = sub nsw i32 %shl1126, 1
  %mul1128 = mul nsw i32 %sub1127, 2
  %add1129 = add nsw i32 %mul1128, 1
  br label %cond.end.1135

cond.false.1130:                                  ; preds = %cond.false.1114
  %162 = load i64, i64* %halflen, align 8
  %conv1131 = trunc i64 %162 to i32
  %add1132 = add nsw i32 0, %conv1131
  %mul1133 = mul nsw i32 0, %add1132
  %sub1134 = sub nsw i32 %mul1133, 1
  br label %cond.end.1135

cond.end.1135:                                    ; preds = %cond.false.1130, %cond.true.1121
  %cond1136 = phi i32 [ %add1129, %cond.true.1121 ], [ %sub1134, %cond.false.1130 ]
  %div1137 = sdiv i32 %cond1136, 8
  %163 = load i64, i64* %halflen, align 8
  %conv1138 = trunc i64 %163 to i32
  %cmp1139 = icmp slt i32 %div1137, %conv1138
  br i1 %cmp1139, label %cond.true.1158, label %lor.lhs.false.1141

lor.lhs.false.1141:                               ; preds = %cond.end.1135, %cond.end.1109, %cond.true.1073, %cond.end.1066, %cond.true.1035, %cond.end.1029
  %164 = load i64, i64* %halflen, align 8
  %conv1142 = trunc i64 %164 to i32
  %mul1143 = mul nsw i32 %conv1142, 8
  %mul1144 = mul nsw i32 0, %mul1143
  %sub1145 = sub nsw i32 %mul1144, 1
  %cmp1146 = icmp slt i32 %sub1145, 0
  br i1 %cmp1146, label %land.lhs.true.1148, label %lor.lhs.false.1153

land.lhs.true.1148:                               ; preds = %lor.lhs.false.1141
  %165 = load i64, i64* %halflen, align 8
  %conv1149 = trunc i64 %165 to i32
  %mul1150 = mul nsw i32 %conv1149, 8
  %cmp1151 = icmp slt i32 %mul1150, -2147483648
  br i1 %cmp1151, label %cond.true.1158, label %lor.lhs.false.1153

lor.lhs.false.1153:                               ; preds = %land.lhs.true.1148, %lor.lhs.false.1141
  %166 = load i64, i64* %halflen, align 8
  %conv1154 = trunc i64 %166 to i32
  %mul1155 = mul nsw i32 %conv1154, 8
  %cmp1156 = icmp slt i32 2147483647, %mul1155
  br i1 %cmp1156, label %cond.true.1158, label %cond.false.1174

cond.true.1158:                                   ; preds = %lor.lhs.false.1153, %land.lhs.true.1148, %cond.end.1135, %cond.end.1109, %cond.true.1073, %cond.end.1066, %cond.true.1035, %cond.end.1029, %land.lhs.true.998
  %167 = load i64, i64* %halflen, align 8
  %conv1159 = trunc i64 %167 to i32
  %mul1160 = mul i32 %conv1159, 8
  %cmp1161 = icmp ule i32 %mul1160, 2147483647
  br i1 %cmp1161, label %cond.true.1163, label %cond.false.1166

cond.true.1163:                                   ; preds = %cond.true.1158
  %168 = load i64, i64* %halflen, align 8
  %conv1164 = trunc i64 %168 to i32
  %mul1165 = mul i32 %conv1164, 8
  br label %cond.end.1171

cond.false.1166:                                  ; preds = %cond.true.1158
  %169 = load i64, i64* %halflen, align 8
  %conv1167 = trunc i64 %169 to i32
  %mul1168 = mul i32 %conv1167, 8
  %sub1169 = sub i32 %mul1168, -2147483648
  %add1170 = add nsw i32 %sub1169, -2147483648
  br label %cond.end.1171

cond.end.1171:                                    ; preds = %cond.false.1166, %cond.true.1163
  %cond1172 = phi i32 [ %mul1165, %cond.true.1163 ], [ %add1170, %cond.false.1166 ]
  %conv1173 = sext i32 %cond1172 to i64
  store i64 %conv1173, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2169, label %lor.lhs.false.2166

cond.false.1174:                                  ; preds = %lor.lhs.false.1153
  %170 = load i64, i64* %halflen, align 8
  %conv1175 = trunc i64 %170 to i32
  %mul1176 = mul i32 %conv1175, 8
  %cmp1177 = icmp ule i32 %mul1176, 2147483647
  br i1 %cmp1177, label %cond.true.1179, label %cond.false.1182

cond.true.1179:                                   ; preds = %cond.false.1174
  %171 = load i64, i64* %halflen, align 8
  %conv1180 = trunc i64 %171 to i32
  %mul1181 = mul i32 %conv1180, 8
  br label %cond.end.1187

cond.false.1182:                                  ; preds = %cond.false.1174
  %172 = load i64, i64* %halflen, align 8
  %conv1183 = trunc i64 %172 to i32
  %mul1184 = mul i32 %conv1183, 8
  %sub1185 = sub i32 %mul1184, -2147483648
  %add1186 = add nsw i32 %sub1185, -2147483648
  br label %cond.end.1187

cond.end.1187:                                    ; preds = %cond.false.1182, %cond.true.1179
  %cond1188 = phi i32 [ %mul1181, %cond.true.1179 ], [ %add1186, %cond.false.1182 ]
  %conv1189 = sext i32 %cond1188 to i64
  store i64 %conv1189, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2169, label %lor.lhs.false.2166

cond.false.1190:                                  ; preds = %cond.true.963
  %173 = load i64, i64* %halflen, align 8
  %add1191 = add nsw i64 0, %173
  %mul1192 = mul nsw i64 0, %add1191
  %sub1193 = sub nsw i64 %mul1192, 1
  %cmp1194 = icmp slt i64 %sub1193, 0
  br i1 %cmp1194, label %cond.true.1196, label %cond.false.1213

cond.true.1196:                                   ; preds = %cond.false.1190
  %174 = load i64, i64* %halflen, align 8
  %add1197 = add nsw i64 0, %174
  %mul1198 = mul nsw i64 0, %add1197
  %add1199 = add nsw i64 %mul1198, 0
  %neg1200 = xor i64 %add1199, -1
  %cmp1201 = icmp eq i64 %neg1200, -1
  %conv1202 = zext i1 %cmp1201 to i32
  %sub1203 = sub nsw i32 0, %conv1202
  %conv1204 = sext i32 %sub1203 to i64
  %175 = load i64, i64* %halflen, align 8
  %add1205 = add nsw i64 0, %175
  %mul1206 = mul nsw i64 0, %add1205
  %add1207 = add nsw i64 %mul1206, 1
  %shl1208 = shl i64 %add1207, 62
  %sub1209 = sub nsw i64 %shl1208, 1
  %mul1210 = mul nsw i64 %sub1209, 2
  %add1211 = add nsw i64 %mul1210, 1
  %sub1212 = sub nsw i64 %conv1204, %add1211
  br label %cond.end.1217

cond.false.1213:                                  ; preds = %cond.false.1190
  %176 = load i64, i64* %halflen, align 8
  %add1214 = add nsw i64 0, %176
  %mul1215 = mul nsw i64 0, %add1214
  %add1216 = add nsw i64 %mul1215, 0
  br label %cond.end.1217

cond.end.1217:                                    ; preds = %cond.false.1213, %cond.true.1196
  %cond1218 = phi i64 [ %sub1212, %cond.true.1196 ], [ %add1216, %cond.false.1213 ]
  %cmp1219 = icmp eq i64 %cond1218, 0
  br i1 %cmp1219, label %land.lhs.true.1221, label %lor.lhs.false.1224

land.lhs.true.1221:                               ; preds = %cond.end.1217
  %177 = load i64, i64* %halflen, align 8
  %cmp1222 = icmp slt i64 %177, 0
  br i1 %cmp1222, label %cond.true.1359, label %lor.lhs.false.1224

lor.lhs.false.1224:                               ; preds = %land.lhs.true.1221, %cond.end.1217
  br i1 false, label %cond.true.1225, label %cond.false.1285

cond.true.1225:                                   ; preds = %lor.lhs.false.1224
  %178 = load i64, i64* %halflen, align 8
  %cmp1226 = icmp slt i64 %178, 0
  br i1 %cmp1226, label %cond.true.1228, label %cond.false.1251

cond.true.1228:                                   ; preds = %cond.true.1225
  %179 = load i64, i64* %halflen, align 8
  %180 = load i64, i64* %halflen, align 8
  %add1229 = add nsw i64 0, %180
  %mul1230 = mul nsw i64 0, %add1229
  %sub1231 = sub nsw i64 %mul1230, 1
  %cmp1232 = icmp slt i64 %sub1231, 0
  br i1 %cmp1232, label %cond.true.1234, label %cond.false.1242

cond.true.1234:                                   ; preds = %cond.true.1228
  %181 = load i64, i64* %halflen, align 8
  %add1235 = add nsw i64 0, %181
  %mul1236 = mul nsw i64 0, %add1235
  %add1237 = add nsw i64 %mul1236, 1
  %shl1238 = shl i64 %add1237, 62
  %sub1239 = sub nsw i64 %shl1238, 1
  %mul1240 = mul nsw i64 %sub1239, 2
  %add1241 = add nsw i64 %mul1240, 1
  br label %cond.end.1246

cond.false.1242:                                  ; preds = %cond.true.1228
  %182 = load i64, i64* %halflen, align 8
  %add1243 = add nsw i64 0, %182
  %mul1244 = mul nsw i64 0, %add1243
  %sub1245 = sub nsw i64 %mul1244, 1
  br label %cond.end.1246

cond.end.1246:                                    ; preds = %cond.false.1242, %cond.true.1234
  %cond1247 = phi i64 [ %add1241, %cond.true.1234 ], [ %sub1245, %cond.false.1242 ]
  %div1248 = sdiv i64 %cond1247, 8
  %cmp1249 = icmp slt i64 %179, %div1248
  br i1 %cmp1249, label %cond.true.1359, label %lor.lhs.false.1345

cond.false.1251:                                  ; preds = %cond.true.1225
  br i1 false, label %cond.true.1252, label %cond.false.1253

cond.true.1252:                                   ; preds = %cond.false.1251
  br i1 false, label %cond.true.1359, label %lor.lhs.false.1345

cond.false.1253:                                  ; preds = %cond.false.1251
  %183 = load i64, i64* %halflen, align 8
  %add1254 = add nsw i64 0, %183
  %mul1255 = mul nsw i64 0, %add1254
  %sub1256 = sub nsw i64 %mul1255, 1
  %cmp1257 = icmp slt i64 %sub1256, 0
  br i1 %cmp1257, label %cond.true.1259, label %cond.false.1276

cond.true.1259:                                   ; preds = %cond.false.1253
  %184 = load i64, i64* %halflen, align 8
  %add1260 = add nsw i64 0, %184
  %mul1261 = mul nsw i64 0, %add1260
  %add1262 = add nsw i64 %mul1261, 0
  %neg1263 = xor i64 %add1262, -1
  %cmp1264 = icmp eq i64 %neg1263, -1
  %conv1265 = zext i1 %cmp1264 to i32
  %sub1266 = sub nsw i32 0, %conv1265
  %conv1267 = sext i32 %sub1266 to i64
  %185 = load i64, i64* %halflen, align 8
  %add1268 = add nsw i64 0, %185
  %mul1269 = mul nsw i64 0, %add1268
  %add1270 = add nsw i64 %mul1269, 1
  %shl1271 = shl i64 %add1270, 62
  %sub1272 = sub nsw i64 %shl1271, 1
  %mul1273 = mul nsw i64 %sub1272, 2
  %add1274 = add nsw i64 %mul1273, 1
  %sub1275 = sub nsw i64 %conv1267, %add1274
  br label %cond.end.1280

cond.false.1276:                                  ; preds = %cond.false.1253
  %186 = load i64, i64* %halflen, align 8
  %add1277 = add nsw i64 0, %186
  %mul1278 = mul nsw i64 0, %add1277
  %add1279 = add nsw i64 %mul1278, 0
  br label %cond.end.1280

cond.end.1280:                                    ; preds = %cond.false.1276, %cond.true.1259
  %cond1281 = phi i64 [ %sub1275, %cond.true.1259 ], [ %add1279, %cond.false.1276 ]
  %div1282 = sdiv i64 %cond1281, 8
  %187 = load i64, i64* %halflen, align 8
  %cmp1283 = icmp slt i64 %div1282, %187
  br i1 %cmp1283, label %cond.true.1359, label %lor.lhs.false.1345

cond.false.1285:                                  ; preds = %lor.lhs.false.1224
  br i1 false, label %cond.true.1286, label %cond.false.1287

cond.true.1286:                                   ; preds = %cond.false.1285
  br i1 false, label %cond.true.1359, label %lor.lhs.false.1345

cond.false.1287:                                  ; preds = %cond.false.1285
  %188 = load i64, i64* %halflen, align 8
  %cmp1288 = icmp slt i64 %188, 0
  br i1 %cmp1288, label %cond.true.1290, label %cond.false.1322

cond.true.1290:                                   ; preds = %cond.false.1287
  %189 = load i64, i64* %halflen, align 8
  %190 = load i64, i64* %halflen, align 8
  %add1291 = add nsw i64 0, %190
  %mul1292 = mul nsw i64 0, %add1291
  %sub1293 = sub nsw i64 %mul1292, 1
  %cmp1294 = icmp slt i64 %sub1293, 0
  br i1 %cmp1294, label %cond.true.1296, label %cond.false.1313

cond.true.1296:                                   ; preds = %cond.true.1290
  %191 = load i64, i64* %halflen, align 8
  %add1297 = add nsw i64 0, %191
  %mul1298 = mul nsw i64 0, %add1297
  %add1299 = add nsw i64 %mul1298, 0
  %neg1300 = xor i64 %add1299, -1
  %cmp1301 = icmp eq i64 %neg1300, -1
  %conv1302 = zext i1 %cmp1301 to i32
  %sub1303 = sub nsw i32 0, %conv1302
  %conv1304 = sext i32 %sub1303 to i64
  %192 = load i64, i64* %halflen, align 8
  %add1305 = add nsw i64 0, %192
  %mul1306 = mul nsw i64 0, %add1305
  %add1307 = add nsw i64 %mul1306, 1
  %shl1308 = shl i64 %add1307, 62
  %sub1309 = sub nsw i64 %shl1308, 1
  %mul1310 = mul nsw i64 %sub1309, 2
  %add1311 = add nsw i64 %mul1310, 1
  %sub1312 = sub nsw i64 %conv1304, %add1311
  br label %cond.end.1317

cond.false.1313:                                  ; preds = %cond.true.1290
  %193 = load i64, i64* %halflen, align 8
  %add1314 = add nsw i64 0, %193
  %mul1315 = mul nsw i64 0, %add1314
  %add1316 = add nsw i64 %mul1315, 0
  br label %cond.end.1317

cond.end.1317:                                    ; preds = %cond.false.1313, %cond.true.1296
  %cond1318 = phi i64 [ %sub1312, %cond.true.1296 ], [ %add1316, %cond.false.1313 ]
  %div1319 = sdiv i64 %cond1318, 8
  %cmp1320 = icmp slt i64 %189, %div1319
  br i1 %cmp1320, label %cond.true.1359, label %lor.lhs.false.1345

cond.false.1322:                                  ; preds = %cond.false.1287
  %194 = load i64, i64* %halflen, align 8
  %add1323 = add nsw i64 0, %194
  %mul1324 = mul nsw i64 0, %add1323
  %sub1325 = sub nsw i64 %mul1324, 1
  %cmp1326 = icmp slt i64 %sub1325, 0
  br i1 %cmp1326, label %cond.true.1328, label %cond.false.1336

cond.true.1328:                                   ; preds = %cond.false.1322
  %195 = load i64, i64* %halflen, align 8
  %add1329 = add nsw i64 0, %195
  %mul1330 = mul nsw i64 0, %add1329
  %add1331 = add nsw i64 %mul1330, 1
  %shl1332 = shl i64 %add1331, 62
  %sub1333 = sub nsw i64 %shl1332, 1
  %mul1334 = mul nsw i64 %sub1333, 2
  %add1335 = add nsw i64 %mul1334, 1
  br label %cond.end.1340

cond.false.1336:                                  ; preds = %cond.false.1322
  %196 = load i64, i64* %halflen, align 8
  %add1337 = add nsw i64 0, %196
  %mul1338 = mul nsw i64 0, %add1337
  %sub1339 = sub nsw i64 %mul1338, 1
  br label %cond.end.1340

cond.end.1340:                                    ; preds = %cond.false.1336, %cond.true.1328
  %cond1341 = phi i64 [ %add1335, %cond.true.1328 ], [ %sub1339, %cond.false.1336 ]
  %div1342 = sdiv i64 %cond1341, 8
  %197 = load i64, i64* %halflen, align 8
  %cmp1343 = icmp slt i64 %div1342, %197
  br i1 %cmp1343, label %cond.true.1359, label %lor.lhs.false.1345

lor.lhs.false.1345:                               ; preds = %cond.end.1340, %cond.end.1317, %cond.true.1286, %cond.end.1280, %cond.true.1252, %cond.end.1246
  %198 = load i64, i64* %halflen, align 8
  %mul1346 = mul nsw i64 %198, 8
  %mul1347 = mul nsw i64 0, %mul1346
  %sub1348 = sub nsw i64 %mul1347, 1
  %cmp1349 = icmp slt i64 %sub1348, 0
  br i1 %cmp1349, label %land.lhs.true.1351, label %lor.lhs.false.1355

land.lhs.true.1351:                               ; preds = %lor.lhs.false.1345
  %199 = load i64, i64* %halflen, align 8
  %mul1352 = mul nsw i64 %199, 8
  %cmp1353 = icmp slt i64 %mul1352, -2147483648
  br i1 %cmp1353, label %cond.true.1359, label %lor.lhs.false.1355

lor.lhs.false.1355:                               ; preds = %land.lhs.true.1351, %lor.lhs.false.1345
  %200 = load i64, i64* %halflen, align 8
  %mul1356 = mul nsw i64 %200, 8
  %cmp1357 = icmp slt i64 2147483647, %mul1356
  br i1 %cmp1357, label %cond.true.1359, label %cond.false.1375

cond.true.1359:                                   ; preds = %lor.lhs.false.1355, %land.lhs.true.1351, %cond.end.1340, %cond.end.1317, %cond.true.1286, %cond.end.1280, %cond.true.1252, %cond.end.1246, %land.lhs.true.1221
  %201 = load i64, i64* %halflen, align 8
  %conv1360 = trunc i64 %201 to i32
  %mul1361 = mul i32 %conv1360, 8
  %cmp1362 = icmp ule i32 %mul1361, 2147483647
  br i1 %cmp1362, label %cond.true.1364, label %cond.false.1367

cond.true.1364:                                   ; preds = %cond.true.1359
  %202 = load i64, i64* %halflen, align 8
  %conv1365 = trunc i64 %202 to i32
  %mul1366 = mul i32 %conv1365, 8
  br label %cond.end.1372

cond.false.1367:                                  ; preds = %cond.true.1359
  %203 = load i64, i64* %halflen, align 8
  %conv1368 = trunc i64 %203 to i32
  %mul1369 = mul i32 %conv1368, 8
  %sub1370 = sub i32 %mul1369, -2147483648
  %add1371 = add nsw i32 %sub1370, -2147483648
  br label %cond.end.1372

cond.end.1372:                                    ; preds = %cond.false.1367, %cond.true.1364
  %cond1373 = phi i32 [ %mul1366, %cond.true.1364 ], [ %add1371, %cond.false.1367 ]
  %conv1374 = sext i32 %cond1373 to i64
  store i64 %conv1374, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2169, label %lor.lhs.false.2166

cond.false.1375:                                  ; preds = %lor.lhs.false.1355
  %204 = load i64, i64* %halflen, align 8
  %conv1376 = trunc i64 %204 to i32
  %mul1377 = mul i32 %conv1376, 8
  %cmp1378 = icmp ule i32 %mul1377, 2147483647
  br i1 %cmp1378, label %cond.true.1380, label %cond.false.1383

cond.true.1380:                                   ; preds = %cond.false.1375
  %205 = load i64, i64* %halflen, align 8
  %conv1381 = trunc i64 %205 to i32
  %mul1382 = mul i32 %conv1381, 8
  br label %cond.end.1388

cond.false.1383:                                  ; preds = %cond.false.1375
  %206 = load i64, i64* %halflen, align 8
  %conv1384 = trunc i64 %206 to i32
  %mul1385 = mul i32 %conv1384, 8
  %sub1386 = sub i32 %mul1385, -2147483648
  %add1387 = add nsw i32 %sub1386, -2147483648
  br label %cond.end.1388

cond.end.1388:                                    ; preds = %cond.false.1383, %cond.true.1380
  %cond1389 = phi i32 [ %mul1382, %cond.true.1380 ], [ %add1387, %cond.false.1383 ]
  %conv1390 = sext i32 %cond1389 to i64
  store i64 %conv1390, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2169, label %lor.lhs.false.2166

cond.false.1391:                                  ; preds = %cond.false.962
  br i1 true, label %cond.true.1392, label %cond.false.1779

cond.true.1392:                                   ; preds = %cond.false.1391
  br i1 false, label %cond.true.1393, label %cond.false.1586

cond.true.1393:                                   ; preds = %cond.true.1392
  %207 = load i64, i64* %halflen, align 8
  %add1394 = add nsw i64 0, %207
  %mul1395 = mul nsw i64 0, %add1394
  %sub1396 = sub nsw i64 %mul1395, 1
  %cmp1397 = icmp slt i64 %sub1396, 0
  br i1 %cmp1397, label %cond.true.1399, label %cond.false.1416

cond.true.1399:                                   ; preds = %cond.true.1393
  %208 = load i64, i64* %halflen, align 8
  %add1400 = add nsw i64 0, %208
  %mul1401 = mul nsw i64 0, %add1400
  %add1402 = add nsw i64 %mul1401, 0
  %neg1403 = xor i64 %add1402, -1
  %cmp1404 = icmp eq i64 %neg1403, -1
  %conv1405 = zext i1 %cmp1404 to i32
  %sub1406 = sub nsw i32 0, %conv1405
  %conv1407 = sext i32 %sub1406 to i64
  %209 = load i64, i64* %halflen, align 8
  %add1408 = add nsw i64 0, %209
  %mul1409 = mul nsw i64 0, %add1408
  %add1410 = add nsw i64 %mul1409, 1
  %shl1411 = shl i64 %add1410, 62
  %sub1412 = sub nsw i64 %shl1411, 1
  %mul1413 = mul nsw i64 %sub1412, 2
  %add1414 = add nsw i64 %mul1413, 1
  %sub1415 = sub nsw i64 %conv1407, %add1414
  br label %cond.end.1420

cond.false.1416:                                  ; preds = %cond.true.1393
  %210 = load i64, i64* %halflen, align 8
  %add1417 = add nsw i64 0, %210
  %mul1418 = mul nsw i64 0, %add1417
  %add1419 = add nsw i64 %mul1418, 0
  br label %cond.end.1420

cond.end.1420:                                    ; preds = %cond.false.1416, %cond.true.1399
  %cond1421 = phi i64 [ %sub1415, %cond.true.1399 ], [ %add1419, %cond.false.1416 ]
  %cmp1422 = icmp eq i64 %cond1421, 0
  br i1 %cmp1422, label %land.lhs.true.1424, label %lor.lhs.false.1427

land.lhs.true.1424:                               ; preds = %cond.end.1420
  %211 = load i64, i64* %halflen, align 8
  %cmp1425 = icmp slt i64 %211, 0
  br i1 %cmp1425, label %cond.true.1562, label %lor.lhs.false.1427

lor.lhs.false.1427:                               ; preds = %land.lhs.true.1424, %cond.end.1420
  br i1 false, label %cond.true.1428, label %cond.false.1488

cond.true.1428:                                   ; preds = %lor.lhs.false.1427
  %212 = load i64, i64* %halflen, align 8
  %cmp1429 = icmp slt i64 %212, 0
  br i1 %cmp1429, label %cond.true.1431, label %cond.false.1454

cond.true.1431:                                   ; preds = %cond.true.1428
  %213 = load i64, i64* %halflen, align 8
  %214 = load i64, i64* %halflen, align 8
  %add1432 = add nsw i64 0, %214
  %mul1433 = mul nsw i64 0, %add1432
  %sub1434 = sub nsw i64 %mul1433, 1
  %cmp1435 = icmp slt i64 %sub1434, 0
  br i1 %cmp1435, label %cond.true.1437, label %cond.false.1445

cond.true.1437:                                   ; preds = %cond.true.1431
  %215 = load i64, i64* %halflen, align 8
  %add1438 = add nsw i64 0, %215
  %mul1439 = mul nsw i64 0, %add1438
  %add1440 = add nsw i64 %mul1439, 1
  %shl1441 = shl i64 %add1440, 62
  %sub1442 = sub nsw i64 %shl1441, 1
  %mul1443 = mul nsw i64 %sub1442, 2
  %add1444 = add nsw i64 %mul1443, 1
  br label %cond.end.1449

cond.false.1445:                                  ; preds = %cond.true.1431
  %216 = load i64, i64* %halflen, align 8
  %add1446 = add nsw i64 0, %216
  %mul1447 = mul nsw i64 0, %add1446
  %sub1448 = sub nsw i64 %mul1447, 1
  br label %cond.end.1449

cond.end.1449:                                    ; preds = %cond.false.1445, %cond.true.1437
  %cond1450 = phi i64 [ %add1444, %cond.true.1437 ], [ %sub1448, %cond.false.1445 ]
  %div1451 = sdiv i64 %cond1450, 8
  %cmp1452 = icmp slt i64 %213, %div1451
  br i1 %cmp1452, label %cond.true.1562, label %lor.lhs.false.1548

cond.false.1454:                                  ; preds = %cond.true.1428
  br i1 false, label %cond.true.1455, label %cond.false.1456

cond.true.1455:                                   ; preds = %cond.false.1454
  br i1 false, label %cond.true.1562, label %lor.lhs.false.1548

cond.false.1456:                                  ; preds = %cond.false.1454
  %217 = load i64, i64* %halflen, align 8
  %add1457 = add nsw i64 0, %217
  %mul1458 = mul nsw i64 0, %add1457
  %sub1459 = sub nsw i64 %mul1458, 1
  %cmp1460 = icmp slt i64 %sub1459, 0
  br i1 %cmp1460, label %cond.true.1462, label %cond.false.1479

cond.true.1462:                                   ; preds = %cond.false.1456
  %218 = load i64, i64* %halflen, align 8
  %add1463 = add nsw i64 0, %218
  %mul1464 = mul nsw i64 0, %add1463
  %add1465 = add nsw i64 %mul1464, 0
  %neg1466 = xor i64 %add1465, -1
  %cmp1467 = icmp eq i64 %neg1466, -1
  %conv1468 = zext i1 %cmp1467 to i32
  %sub1469 = sub nsw i32 0, %conv1468
  %conv1470 = sext i32 %sub1469 to i64
  %219 = load i64, i64* %halflen, align 8
  %add1471 = add nsw i64 0, %219
  %mul1472 = mul nsw i64 0, %add1471
  %add1473 = add nsw i64 %mul1472, 1
  %shl1474 = shl i64 %add1473, 62
  %sub1475 = sub nsw i64 %shl1474, 1
  %mul1476 = mul nsw i64 %sub1475, 2
  %add1477 = add nsw i64 %mul1476, 1
  %sub1478 = sub nsw i64 %conv1470, %add1477
  br label %cond.end.1483

cond.false.1479:                                  ; preds = %cond.false.1456
  %220 = load i64, i64* %halflen, align 8
  %add1480 = add nsw i64 0, %220
  %mul1481 = mul nsw i64 0, %add1480
  %add1482 = add nsw i64 %mul1481, 0
  br label %cond.end.1483

cond.end.1483:                                    ; preds = %cond.false.1479, %cond.true.1462
  %cond1484 = phi i64 [ %sub1478, %cond.true.1462 ], [ %add1482, %cond.false.1479 ]
  %div1485 = sdiv i64 %cond1484, 8
  %221 = load i64, i64* %halflen, align 8
  %cmp1486 = icmp slt i64 %div1485, %221
  br i1 %cmp1486, label %cond.true.1562, label %lor.lhs.false.1548

cond.false.1488:                                  ; preds = %lor.lhs.false.1427
  br i1 false, label %cond.true.1489, label %cond.false.1490

cond.true.1489:                                   ; preds = %cond.false.1488
  br i1 false, label %cond.true.1562, label %lor.lhs.false.1548

cond.false.1490:                                  ; preds = %cond.false.1488
  %222 = load i64, i64* %halflen, align 8
  %cmp1491 = icmp slt i64 %222, 0
  br i1 %cmp1491, label %cond.true.1493, label %cond.false.1525

cond.true.1493:                                   ; preds = %cond.false.1490
  %223 = load i64, i64* %halflen, align 8
  %224 = load i64, i64* %halflen, align 8
  %add1494 = add nsw i64 0, %224
  %mul1495 = mul nsw i64 0, %add1494
  %sub1496 = sub nsw i64 %mul1495, 1
  %cmp1497 = icmp slt i64 %sub1496, 0
  br i1 %cmp1497, label %cond.true.1499, label %cond.false.1516

cond.true.1499:                                   ; preds = %cond.true.1493
  %225 = load i64, i64* %halflen, align 8
  %add1500 = add nsw i64 0, %225
  %mul1501 = mul nsw i64 0, %add1500
  %add1502 = add nsw i64 %mul1501, 0
  %neg1503 = xor i64 %add1502, -1
  %cmp1504 = icmp eq i64 %neg1503, -1
  %conv1505 = zext i1 %cmp1504 to i32
  %sub1506 = sub nsw i32 0, %conv1505
  %conv1507 = sext i32 %sub1506 to i64
  %226 = load i64, i64* %halflen, align 8
  %add1508 = add nsw i64 0, %226
  %mul1509 = mul nsw i64 0, %add1508
  %add1510 = add nsw i64 %mul1509, 1
  %shl1511 = shl i64 %add1510, 62
  %sub1512 = sub nsw i64 %shl1511, 1
  %mul1513 = mul nsw i64 %sub1512, 2
  %add1514 = add nsw i64 %mul1513, 1
  %sub1515 = sub nsw i64 %conv1507, %add1514
  br label %cond.end.1520

cond.false.1516:                                  ; preds = %cond.true.1493
  %227 = load i64, i64* %halflen, align 8
  %add1517 = add nsw i64 0, %227
  %mul1518 = mul nsw i64 0, %add1517
  %add1519 = add nsw i64 %mul1518, 0
  br label %cond.end.1520

cond.end.1520:                                    ; preds = %cond.false.1516, %cond.true.1499
  %cond1521 = phi i64 [ %sub1515, %cond.true.1499 ], [ %add1519, %cond.false.1516 ]
  %div1522 = sdiv i64 %cond1521, 8
  %cmp1523 = icmp slt i64 %223, %div1522
  br i1 %cmp1523, label %cond.true.1562, label %lor.lhs.false.1548

cond.false.1525:                                  ; preds = %cond.false.1490
  %228 = load i64, i64* %halflen, align 8
  %add1526 = add nsw i64 0, %228
  %mul1527 = mul nsw i64 0, %add1526
  %sub1528 = sub nsw i64 %mul1527, 1
  %cmp1529 = icmp slt i64 %sub1528, 0
  br i1 %cmp1529, label %cond.true.1531, label %cond.false.1539

cond.true.1531:                                   ; preds = %cond.false.1525
  %229 = load i64, i64* %halflen, align 8
  %add1532 = add nsw i64 0, %229
  %mul1533 = mul nsw i64 0, %add1532
  %add1534 = add nsw i64 %mul1533, 1
  %shl1535 = shl i64 %add1534, 62
  %sub1536 = sub nsw i64 %shl1535, 1
  %mul1537 = mul nsw i64 %sub1536, 2
  %add1538 = add nsw i64 %mul1537, 1
  br label %cond.end.1543

cond.false.1539:                                  ; preds = %cond.false.1525
  %230 = load i64, i64* %halflen, align 8
  %add1540 = add nsw i64 0, %230
  %mul1541 = mul nsw i64 0, %add1540
  %sub1542 = sub nsw i64 %mul1541, 1
  br label %cond.end.1543

cond.end.1543:                                    ; preds = %cond.false.1539, %cond.true.1531
  %cond1544 = phi i64 [ %add1538, %cond.true.1531 ], [ %sub1542, %cond.false.1539 ]
  %div1545 = sdiv i64 %cond1544, 8
  %231 = load i64, i64* %halflen, align 8
  %cmp1546 = icmp slt i64 %div1545, %231
  br i1 %cmp1546, label %cond.true.1562, label %lor.lhs.false.1548

lor.lhs.false.1548:                               ; preds = %cond.end.1543, %cond.end.1520, %cond.true.1489, %cond.end.1483, %cond.true.1455, %cond.end.1449
  %232 = load i64, i64* %halflen, align 8
  %mul1549 = mul nsw i64 %232, 8
  %mul1550 = mul nsw i64 0, %mul1549
  %sub1551 = sub nsw i64 %mul1550, 1
  %cmp1552 = icmp slt i64 %sub1551, 0
  br i1 %cmp1552, label %land.lhs.true.1554, label %lor.lhs.false.1558

land.lhs.true.1554:                               ; preds = %lor.lhs.false.1548
  %233 = load i64, i64* %halflen, align 8
  %mul1555 = mul nsw i64 %233, 8
  %cmp1556 = icmp slt i64 %mul1555, -9223372036854775808
  br i1 %cmp1556, label %cond.true.1562, label %lor.lhs.false.1558

lor.lhs.false.1558:                               ; preds = %land.lhs.true.1554, %lor.lhs.false.1548
  %234 = load i64, i64* %halflen, align 8
  %mul1559 = mul nsw i64 %234, 8
  %cmp1560 = icmp slt i64 9223372036854775807, %mul1559
  br i1 %cmp1560, label %cond.true.1562, label %cond.false.1574

cond.true.1562:                                   ; preds = %lor.lhs.false.1558, %land.lhs.true.1554, %cond.end.1543, %cond.end.1520, %cond.true.1489, %cond.end.1483, %cond.true.1455, %cond.end.1449, %land.lhs.true.1424
  %235 = load i64, i64* %halflen, align 8
  %mul1563 = mul i64 %235, 8
  %cmp1564 = icmp ule i64 %mul1563, 9223372036854775807
  br i1 %cmp1564, label %cond.true.1566, label %cond.false.1568

cond.true.1566:                                   ; preds = %cond.true.1562
  %236 = load i64, i64* %halflen, align 8
  %mul1567 = mul i64 %236, 8
  br label %cond.end.1572

cond.false.1568:                                  ; preds = %cond.true.1562
  %237 = load i64, i64* %halflen, align 8
  %mul1569 = mul i64 %237, 8
  %sub1570 = sub i64 %mul1569, -9223372036854775808
  %add1571 = add nsw i64 %sub1570, -9223372036854775808
  br label %cond.end.1572

cond.end.1572:                                    ; preds = %cond.false.1568, %cond.true.1566
  %cond1573 = phi i64 [ %mul1567, %cond.true.1566 ], [ %add1571, %cond.false.1568 ]
  store i64 %cond1573, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2169, label %lor.lhs.false.2166

cond.false.1574:                                  ; preds = %lor.lhs.false.1558
  %238 = load i64, i64* %halflen, align 8
  %mul1575 = mul i64 %238, 8
  %cmp1576 = icmp ule i64 %mul1575, 9223372036854775807
  br i1 %cmp1576, label %cond.true.1578, label %cond.false.1580

cond.true.1578:                                   ; preds = %cond.false.1574
  %239 = load i64, i64* %halflen, align 8
  %mul1579 = mul i64 %239, 8
  br label %cond.end.1584

cond.false.1580:                                  ; preds = %cond.false.1574
  %240 = load i64, i64* %halflen, align 8
  %mul1581 = mul i64 %240, 8
  %sub1582 = sub i64 %mul1581, -9223372036854775808
  %add1583 = add nsw i64 %sub1582, -9223372036854775808
  br label %cond.end.1584

cond.end.1584:                                    ; preds = %cond.false.1580, %cond.true.1578
  %cond1585 = phi i64 [ %mul1579, %cond.true.1578 ], [ %add1583, %cond.false.1580 ]
  store i64 %cond1585, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2169, label %lor.lhs.false.2166

cond.false.1586:                                  ; preds = %cond.true.1392
  %241 = load i64, i64* %halflen, align 8
  %add1587 = add nsw i64 0, %241
  %mul1588 = mul nsw i64 0, %add1587
  %sub1589 = sub nsw i64 %mul1588, 1
  %cmp1590 = icmp slt i64 %sub1589, 0
  br i1 %cmp1590, label %cond.true.1592, label %cond.false.1609

cond.true.1592:                                   ; preds = %cond.false.1586
  %242 = load i64, i64* %halflen, align 8
  %add1593 = add nsw i64 0, %242
  %mul1594 = mul nsw i64 0, %add1593
  %add1595 = add nsw i64 %mul1594, 0
  %neg1596 = xor i64 %add1595, -1
  %cmp1597 = icmp eq i64 %neg1596, -1
  %conv1598 = zext i1 %cmp1597 to i32
  %sub1599 = sub nsw i32 0, %conv1598
  %conv1600 = sext i32 %sub1599 to i64
  %243 = load i64, i64* %halflen, align 8
  %add1601 = add nsw i64 0, %243
  %mul1602 = mul nsw i64 0, %add1601
  %add1603 = add nsw i64 %mul1602, 1
  %shl1604 = shl i64 %add1603, 62
  %sub1605 = sub nsw i64 %shl1604, 1
  %mul1606 = mul nsw i64 %sub1605, 2
  %add1607 = add nsw i64 %mul1606, 1
  %sub1608 = sub nsw i64 %conv1600, %add1607
  br label %cond.end.1613

cond.false.1609:                                  ; preds = %cond.false.1586
  %244 = load i64, i64* %halflen, align 8
  %add1610 = add nsw i64 0, %244
  %mul1611 = mul nsw i64 0, %add1610
  %add1612 = add nsw i64 %mul1611, 0
  br label %cond.end.1613

cond.end.1613:                                    ; preds = %cond.false.1609, %cond.true.1592
  %cond1614 = phi i64 [ %sub1608, %cond.true.1592 ], [ %add1612, %cond.false.1609 ]
  %cmp1615 = icmp eq i64 %cond1614, 0
  br i1 %cmp1615, label %land.lhs.true.1617, label %lor.lhs.false.1620

land.lhs.true.1617:                               ; preds = %cond.end.1613
  %245 = load i64, i64* %halflen, align 8
  %cmp1618 = icmp slt i64 %245, 0
  br i1 %cmp1618, label %cond.true.1755, label %lor.lhs.false.1620

lor.lhs.false.1620:                               ; preds = %land.lhs.true.1617, %cond.end.1613
  br i1 false, label %cond.true.1621, label %cond.false.1681

cond.true.1621:                                   ; preds = %lor.lhs.false.1620
  %246 = load i64, i64* %halflen, align 8
  %cmp1622 = icmp slt i64 %246, 0
  br i1 %cmp1622, label %cond.true.1624, label %cond.false.1647

cond.true.1624:                                   ; preds = %cond.true.1621
  %247 = load i64, i64* %halflen, align 8
  %248 = load i64, i64* %halflen, align 8
  %add1625 = add nsw i64 0, %248
  %mul1626 = mul nsw i64 0, %add1625
  %sub1627 = sub nsw i64 %mul1626, 1
  %cmp1628 = icmp slt i64 %sub1627, 0
  br i1 %cmp1628, label %cond.true.1630, label %cond.false.1638

cond.true.1630:                                   ; preds = %cond.true.1624
  %249 = load i64, i64* %halflen, align 8
  %add1631 = add nsw i64 0, %249
  %mul1632 = mul nsw i64 0, %add1631
  %add1633 = add nsw i64 %mul1632, 1
  %shl1634 = shl i64 %add1633, 62
  %sub1635 = sub nsw i64 %shl1634, 1
  %mul1636 = mul nsw i64 %sub1635, 2
  %add1637 = add nsw i64 %mul1636, 1
  br label %cond.end.1642

cond.false.1638:                                  ; preds = %cond.true.1624
  %250 = load i64, i64* %halflen, align 8
  %add1639 = add nsw i64 0, %250
  %mul1640 = mul nsw i64 0, %add1639
  %sub1641 = sub nsw i64 %mul1640, 1
  br label %cond.end.1642

cond.end.1642:                                    ; preds = %cond.false.1638, %cond.true.1630
  %cond1643 = phi i64 [ %add1637, %cond.true.1630 ], [ %sub1641, %cond.false.1638 ]
  %div1644 = sdiv i64 %cond1643, 8
  %cmp1645 = icmp slt i64 %247, %div1644
  br i1 %cmp1645, label %cond.true.1755, label %lor.lhs.false.1741

cond.false.1647:                                  ; preds = %cond.true.1621
  br i1 false, label %cond.true.1648, label %cond.false.1649

cond.true.1648:                                   ; preds = %cond.false.1647
  br i1 false, label %cond.true.1755, label %lor.lhs.false.1741

cond.false.1649:                                  ; preds = %cond.false.1647
  %251 = load i64, i64* %halflen, align 8
  %add1650 = add nsw i64 0, %251
  %mul1651 = mul nsw i64 0, %add1650
  %sub1652 = sub nsw i64 %mul1651, 1
  %cmp1653 = icmp slt i64 %sub1652, 0
  br i1 %cmp1653, label %cond.true.1655, label %cond.false.1672

cond.true.1655:                                   ; preds = %cond.false.1649
  %252 = load i64, i64* %halflen, align 8
  %add1656 = add nsw i64 0, %252
  %mul1657 = mul nsw i64 0, %add1656
  %add1658 = add nsw i64 %mul1657, 0
  %neg1659 = xor i64 %add1658, -1
  %cmp1660 = icmp eq i64 %neg1659, -1
  %conv1661 = zext i1 %cmp1660 to i32
  %sub1662 = sub nsw i32 0, %conv1661
  %conv1663 = sext i32 %sub1662 to i64
  %253 = load i64, i64* %halflen, align 8
  %add1664 = add nsw i64 0, %253
  %mul1665 = mul nsw i64 0, %add1664
  %add1666 = add nsw i64 %mul1665, 1
  %shl1667 = shl i64 %add1666, 62
  %sub1668 = sub nsw i64 %shl1667, 1
  %mul1669 = mul nsw i64 %sub1668, 2
  %add1670 = add nsw i64 %mul1669, 1
  %sub1671 = sub nsw i64 %conv1663, %add1670
  br label %cond.end.1676

cond.false.1672:                                  ; preds = %cond.false.1649
  %254 = load i64, i64* %halflen, align 8
  %add1673 = add nsw i64 0, %254
  %mul1674 = mul nsw i64 0, %add1673
  %add1675 = add nsw i64 %mul1674, 0
  br label %cond.end.1676

cond.end.1676:                                    ; preds = %cond.false.1672, %cond.true.1655
  %cond1677 = phi i64 [ %sub1671, %cond.true.1655 ], [ %add1675, %cond.false.1672 ]
  %div1678 = sdiv i64 %cond1677, 8
  %255 = load i64, i64* %halflen, align 8
  %cmp1679 = icmp slt i64 %div1678, %255
  br i1 %cmp1679, label %cond.true.1755, label %lor.lhs.false.1741

cond.false.1681:                                  ; preds = %lor.lhs.false.1620
  br i1 false, label %cond.true.1682, label %cond.false.1683

cond.true.1682:                                   ; preds = %cond.false.1681
  br i1 false, label %cond.true.1755, label %lor.lhs.false.1741

cond.false.1683:                                  ; preds = %cond.false.1681
  %256 = load i64, i64* %halflen, align 8
  %cmp1684 = icmp slt i64 %256, 0
  br i1 %cmp1684, label %cond.true.1686, label %cond.false.1718

cond.true.1686:                                   ; preds = %cond.false.1683
  %257 = load i64, i64* %halflen, align 8
  %258 = load i64, i64* %halflen, align 8
  %add1687 = add nsw i64 0, %258
  %mul1688 = mul nsw i64 0, %add1687
  %sub1689 = sub nsw i64 %mul1688, 1
  %cmp1690 = icmp slt i64 %sub1689, 0
  br i1 %cmp1690, label %cond.true.1692, label %cond.false.1709

cond.true.1692:                                   ; preds = %cond.true.1686
  %259 = load i64, i64* %halflen, align 8
  %add1693 = add nsw i64 0, %259
  %mul1694 = mul nsw i64 0, %add1693
  %add1695 = add nsw i64 %mul1694, 0
  %neg1696 = xor i64 %add1695, -1
  %cmp1697 = icmp eq i64 %neg1696, -1
  %conv1698 = zext i1 %cmp1697 to i32
  %sub1699 = sub nsw i32 0, %conv1698
  %conv1700 = sext i32 %sub1699 to i64
  %260 = load i64, i64* %halflen, align 8
  %add1701 = add nsw i64 0, %260
  %mul1702 = mul nsw i64 0, %add1701
  %add1703 = add nsw i64 %mul1702, 1
  %shl1704 = shl i64 %add1703, 62
  %sub1705 = sub nsw i64 %shl1704, 1
  %mul1706 = mul nsw i64 %sub1705, 2
  %add1707 = add nsw i64 %mul1706, 1
  %sub1708 = sub nsw i64 %conv1700, %add1707
  br label %cond.end.1713

cond.false.1709:                                  ; preds = %cond.true.1686
  %261 = load i64, i64* %halflen, align 8
  %add1710 = add nsw i64 0, %261
  %mul1711 = mul nsw i64 0, %add1710
  %add1712 = add nsw i64 %mul1711, 0
  br label %cond.end.1713

cond.end.1713:                                    ; preds = %cond.false.1709, %cond.true.1692
  %cond1714 = phi i64 [ %sub1708, %cond.true.1692 ], [ %add1712, %cond.false.1709 ]
  %div1715 = sdiv i64 %cond1714, 8
  %cmp1716 = icmp slt i64 %257, %div1715
  br i1 %cmp1716, label %cond.true.1755, label %lor.lhs.false.1741

cond.false.1718:                                  ; preds = %cond.false.1683
  %262 = load i64, i64* %halflen, align 8
  %add1719 = add nsw i64 0, %262
  %mul1720 = mul nsw i64 0, %add1719
  %sub1721 = sub nsw i64 %mul1720, 1
  %cmp1722 = icmp slt i64 %sub1721, 0
  br i1 %cmp1722, label %cond.true.1724, label %cond.false.1732

cond.true.1724:                                   ; preds = %cond.false.1718
  %263 = load i64, i64* %halflen, align 8
  %add1725 = add nsw i64 0, %263
  %mul1726 = mul nsw i64 0, %add1725
  %add1727 = add nsw i64 %mul1726, 1
  %shl1728 = shl i64 %add1727, 62
  %sub1729 = sub nsw i64 %shl1728, 1
  %mul1730 = mul nsw i64 %sub1729, 2
  %add1731 = add nsw i64 %mul1730, 1
  br label %cond.end.1736

cond.false.1732:                                  ; preds = %cond.false.1718
  %264 = load i64, i64* %halflen, align 8
  %add1733 = add nsw i64 0, %264
  %mul1734 = mul nsw i64 0, %add1733
  %sub1735 = sub nsw i64 %mul1734, 1
  br label %cond.end.1736

cond.end.1736:                                    ; preds = %cond.false.1732, %cond.true.1724
  %cond1737 = phi i64 [ %add1731, %cond.true.1724 ], [ %sub1735, %cond.false.1732 ]
  %div1738 = sdiv i64 %cond1737, 8
  %265 = load i64, i64* %halflen, align 8
  %cmp1739 = icmp slt i64 %div1738, %265
  br i1 %cmp1739, label %cond.true.1755, label %lor.lhs.false.1741

lor.lhs.false.1741:                               ; preds = %cond.end.1736, %cond.end.1713, %cond.true.1682, %cond.end.1676, %cond.true.1648, %cond.end.1642
  %266 = load i64, i64* %halflen, align 8
  %mul1742 = mul nsw i64 %266, 8
  %mul1743 = mul nsw i64 0, %mul1742
  %sub1744 = sub nsw i64 %mul1743, 1
  %cmp1745 = icmp slt i64 %sub1744, 0
  br i1 %cmp1745, label %land.lhs.true.1747, label %lor.lhs.false.1751

land.lhs.true.1747:                               ; preds = %lor.lhs.false.1741
  %267 = load i64, i64* %halflen, align 8
  %mul1748 = mul nsw i64 %267, 8
  %cmp1749 = icmp slt i64 %mul1748, -9223372036854775808
  br i1 %cmp1749, label %cond.true.1755, label %lor.lhs.false.1751

lor.lhs.false.1751:                               ; preds = %land.lhs.true.1747, %lor.lhs.false.1741
  %268 = load i64, i64* %halflen, align 8
  %mul1752 = mul nsw i64 %268, 8
  %cmp1753 = icmp slt i64 9223372036854775807, %mul1752
  br i1 %cmp1753, label %cond.true.1755, label %cond.false.1767

cond.true.1755:                                   ; preds = %lor.lhs.false.1751, %land.lhs.true.1747, %cond.end.1736, %cond.end.1713, %cond.true.1682, %cond.end.1676, %cond.true.1648, %cond.end.1642, %land.lhs.true.1617
  %269 = load i64, i64* %halflen, align 8
  %mul1756 = mul i64 %269, 8
  %cmp1757 = icmp ule i64 %mul1756, 9223372036854775807
  br i1 %cmp1757, label %cond.true.1759, label %cond.false.1761

cond.true.1759:                                   ; preds = %cond.true.1755
  %270 = load i64, i64* %halflen, align 8
  %mul1760 = mul i64 %270, 8
  br label %cond.end.1765

cond.false.1761:                                  ; preds = %cond.true.1755
  %271 = load i64, i64* %halflen, align 8
  %mul1762 = mul i64 %271, 8
  %sub1763 = sub i64 %mul1762, -9223372036854775808
  %add1764 = add nsw i64 %sub1763, -9223372036854775808
  br label %cond.end.1765

cond.end.1765:                                    ; preds = %cond.false.1761, %cond.true.1759
  %cond1766 = phi i64 [ %mul1760, %cond.true.1759 ], [ %add1764, %cond.false.1761 ]
  store i64 %cond1766, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2169, label %lor.lhs.false.2166

cond.false.1767:                                  ; preds = %lor.lhs.false.1751
  %272 = load i64, i64* %halflen, align 8
  %mul1768 = mul i64 %272, 8
  %cmp1769 = icmp ule i64 %mul1768, 9223372036854775807
  br i1 %cmp1769, label %cond.true.1771, label %cond.false.1773

cond.true.1771:                                   ; preds = %cond.false.1767
  %273 = load i64, i64* %halflen, align 8
  %mul1772 = mul i64 %273, 8
  br label %cond.end.1777

cond.false.1773:                                  ; preds = %cond.false.1767
  %274 = load i64, i64* %halflen, align 8
  %mul1774 = mul i64 %274, 8
  %sub1775 = sub i64 %mul1774, -9223372036854775808
  %add1776 = add nsw i64 %sub1775, -9223372036854775808
  br label %cond.end.1777

cond.end.1777:                                    ; preds = %cond.false.1773, %cond.true.1771
  %cond1778 = phi i64 [ %mul1772, %cond.true.1771 ], [ %add1776, %cond.false.1773 ]
  store i64 %cond1778, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2169, label %lor.lhs.false.2166

cond.false.1779:                                  ; preds = %cond.false.1391
  br i1 false, label %cond.true.1780, label %cond.false.1973

cond.true.1780:                                   ; preds = %cond.false.1779
  %275 = load i64, i64* %halflen, align 8
  %add1781 = add nsw i64 0, %275
  %mul1782 = mul nsw i64 0, %add1781
  %sub1783 = sub nsw i64 %mul1782, 1
  %cmp1784 = icmp slt i64 %sub1783, 0
  br i1 %cmp1784, label %cond.true.1786, label %cond.false.1803

cond.true.1786:                                   ; preds = %cond.true.1780
  %276 = load i64, i64* %halflen, align 8
  %add1787 = add nsw i64 0, %276
  %mul1788 = mul nsw i64 0, %add1787
  %add1789 = add nsw i64 %mul1788, 0
  %neg1790 = xor i64 %add1789, -1
  %cmp1791 = icmp eq i64 %neg1790, -1
  %conv1792 = zext i1 %cmp1791 to i32
  %sub1793 = sub nsw i32 0, %conv1792
  %conv1794 = sext i32 %sub1793 to i64
  %277 = load i64, i64* %halflen, align 8
  %add1795 = add nsw i64 0, %277
  %mul1796 = mul nsw i64 0, %add1795
  %add1797 = add nsw i64 %mul1796, 1
  %shl1798 = shl i64 %add1797, 62
  %sub1799 = sub nsw i64 %shl1798, 1
  %mul1800 = mul nsw i64 %sub1799, 2
  %add1801 = add nsw i64 %mul1800, 1
  %sub1802 = sub nsw i64 %conv1794, %add1801
  br label %cond.end.1807

cond.false.1803:                                  ; preds = %cond.true.1780
  %278 = load i64, i64* %halflen, align 8
  %add1804 = add nsw i64 0, %278
  %mul1805 = mul nsw i64 0, %add1804
  %add1806 = add nsw i64 %mul1805, 0
  br label %cond.end.1807

cond.end.1807:                                    ; preds = %cond.false.1803, %cond.true.1786
  %cond1808 = phi i64 [ %sub1802, %cond.true.1786 ], [ %add1806, %cond.false.1803 ]
  %cmp1809 = icmp eq i64 %cond1808, 0
  br i1 %cmp1809, label %land.lhs.true.1811, label %lor.lhs.false.1814

land.lhs.true.1811:                               ; preds = %cond.end.1807
  %279 = load i64, i64* %halflen, align 8
  %cmp1812 = icmp slt i64 %279, 0
  br i1 %cmp1812, label %cond.true.1949, label %lor.lhs.false.1814

lor.lhs.false.1814:                               ; preds = %land.lhs.true.1811, %cond.end.1807
  br i1 false, label %cond.true.1815, label %cond.false.1875

cond.true.1815:                                   ; preds = %lor.lhs.false.1814
  %280 = load i64, i64* %halflen, align 8
  %cmp1816 = icmp slt i64 %280, 0
  br i1 %cmp1816, label %cond.true.1818, label %cond.false.1841

cond.true.1818:                                   ; preds = %cond.true.1815
  %281 = load i64, i64* %halflen, align 8
  %282 = load i64, i64* %halflen, align 8
  %add1819 = add nsw i64 0, %282
  %mul1820 = mul nsw i64 0, %add1819
  %sub1821 = sub nsw i64 %mul1820, 1
  %cmp1822 = icmp slt i64 %sub1821, 0
  br i1 %cmp1822, label %cond.true.1824, label %cond.false.1832

cond.true.1824:                                   ; preds = %cond.true.1818
  %283 = load i64, i64* %halflen, align 8
  %add1825 = add nsw i64 0, %283
  %mul1826 = mul nsw i64 0, %add1825
  %add1827 = add nsw i64 %mul1826, 1
  %shl1828 = shl i64 %add1827, 62
  %sub1829 = sub nsw i64 %shl1828, 1
  %mul1830 = mul nsw i64 %sub1829, 2
  %add1831 = add nsw i64 %mul1830, 1
  br label %cond.end.1836

cond.false.1832:                                  ; preds = %cond.true.1818
  %284 = load i64, i64* %halflen, align 8
  %add1833 = add nsw i64 0, %284
  %mul1834 = mul nsw i64 0, %add1833
  %sub1835 = sub nsw i64 %mul1834, 1
  br label %cond.end.1836

cond.end.1836:                                    ; preds = %cond.false.1832, %cond.true.1824
  %cond1837 = phi i64 [ %add1831, %cond.true.1824 ], [ %sub1835, %cond.false.1832 ]
  %div1838 = sdiv i64 %cond1837, 8
  %cmp1839 = icmp slt i64 %281, %div1838
  br i1 %cmp1839, label %cond.true.1949, label %lor.lhs.false.1935

cond.false.1841:                                  ; preds = %cond.true.1815
  br i1 false, label %cond.true.1842, label %cond.false.1843

cond.true.1842:                                   ; preds = %cond.false.1841
  br i1 false, label %cond.true.1949, label %lor.lhs.false.1935

cond.false.1843:                                  ; preds = %cond.false.1841
  %285 = load i64, i64* %halflen, align 8
  %add1844 = add nsw i64 0, %285
  %mul1845 = mul nsw i64 0, %add1844
  %sub1846 = sub nsw i64 %mul1845, 1
  %cmp1847 = icmp slt i64 %sub1846, 0
  br i1 %cmp1847, label %cond.true.1849, label %cond.false.1866

cond.true.1849:                                   ; preds = %cond.false.1843
  %286 = load i64, i64* %halflen, align 8
  %add1850 = add nsw i64 0, %286
  %mul1851 = mul nsw i64 0, %add1850
  %add1852 = add nsw i64 %mul1851, 0
  %neg1853 = xor i64 %add1852, -1
  %cmp1854 = icmp eq i64 %neg1853, -1
  %conv1855 = zext i1 %cmp1854 to i32
  %sub1856 = sub nsw i32 0, %conv1855
  %conv1857 = sext i32 %sub1856 to i64
  %287 = load i64, i64* %halflen, align 8
  %add1858 = add nsw i64 0, %287
  %mul1859 = mul nsw i64 0, %add1858
  %add1860 = add nsw i64 %mul1859, 1
  %shl1861 = shl i64 %add1860, 62
  %sub1862 = sub nsw i64 %shl1861, 1
  %mul1863 = mul nsw i64 %sub1862, 2
  %add1864 = add nsw i64 %mul1863, 1
  %sub1865 = sub nsw i64 %conv1857, %add1864
  br label %cond.end.1870

cond.false.1866:                                  ; preds = %cond.false.1843
  %288 = load i64, i64* %halflen, align 8
  %add1867 = add nsw i64 0, %288
  %mul1868 = mul nsw i64 0, %add1867
  %add1869 = add nsw i64 %mul1868, 0
  br label %cond.end.1870

cond.end.1870:                                    ; preds = %cond.false.1866, %cond.true.1849
  %cond1871 = phi i64 [ %sub1865, %cond.true.1849 ], [ %add1869, %cond.false.1866 ]
  %div1872 = sdiv i64 %cond1871, 8
  %289 = load i64, i64* %halflen, align 8
  %cmp1873 = icmp slt i64 %div1872, %289
  br i1 %cmp1873, label %cond.true.1949, label %lor.lhs.false.1935

cond.false.1875:                                  ; preds = %lor.lhs.false.1814
  br i1 false, label %cond.true.1876, label %cond.false.1877

cond.true.1876:                                   ; preds = %cond.false.1875
  br i1 false, label %cond.true.1949, label %lor.lhs.false.1935

cond.false.1877:                                  ; preds = %cond.false.1875
  %290 = load i64, i64* %halflen, align 8
  %cmp1878 = icmp slt i64 %290, 0
  br i1 %cmp1878, label %cond.true.1880, label %cond.false.1912

cond.true.1880:                                   ; preds = %cond.false.1877
  %291 = load i64, i64* %halflen, align 8
  %292 = load i64, i64* %halflen, align 8
  %add1881 = add nsw i64 0, %292
  %mul1882 = mul nsw i64 0, %add1881
  %sub1883 = sub nsw i64 %mul1882, 1
  %cmp1884 = icmp slt i64 %sub1883, 0
  br i1 %cmp1884, label %cond.true.1886, label %cond.false.1903

cond.true.1886:                                   ; preds = %cond.true.1880
  %293 = load i64, i64* %halflen, align 8
  %add1887 = add nsw i64 0, %293
  %mul1888 = mul nsw i64 0, %add1887
  %add1889 = add nsw i64 %mul1888, 0
  %neg1890 = xor i64 %add1889, -1
  %cmp1891 = icmp eq i64 %neg1890, -1
  %conv1892 = zext i1 %cmp1891 to i32
  %sub1893 = sub nsw i32 0, %conv1892
  %conv1894 = sext i32 %sub1893 to i64
  %294 = load i64, i64* %halflen, align 8
  %add1895 = add nsw i64 0, %294
  %mul1896 = mul nsw i64 0, %add1895
  %add1897 = add nsw i64 %mul1896, 1
  %shl1898 = shl i64 %add1897, 62
  %sub1899 = sub nsw i64 %shl1898, 1
  %mul1900 = mul nsw i64 %sub1899, 2
  %add1901 = add nsw i64 %mul1900, 1
  %sub1902 = sub nsw i64 %conv1894, %add1901
  br label %cond.end.1907

cond.false.1903:                                  ; preds = %cond.true.1880
  %295 = load i64, i64* %halflen, align 8
  %add1904 = add nsw i64 0, %295
  %mul1905 = mul nsw i64 0, %add1904
  %add1906 = add nsw i64 %mul1905, 0
  br label %cond.end.1907

cond.end.1907:                                    ; preds = %cond.false.1903, %cond.true.1886
  %cond1908 = phi i64 [ %sub1902, %cond.true.1886 ], [ %add1906, %cond.false.1903 ]
  %div1909 = sdiv i64 %cond1908, 8
  %cmp1910 = icmp slt i64 %291, %div1909
  br i1 %cmp1910, label %cond.true.1949, label %lor.lhs.false.1935

cond.false.1912:                                  ; preds = %cond.false.1877
  %296 = load i64, i64* %halflen, align 8
  %add1913 = add nsw i64 0, %296
  %mul1914 = mul nsw i64 0, %add1913
  %sub1915 = sub nsw i64 %mul1914, 1
  %cmp1916 = icmp slt i64 %sub1915, 0
  br i1 %cmp1916, label %cond.true.1918, label %cond.false.1926

cond.true.1918:                                   ; preds = %cond.false.1912
  %297 = load i64, i64* %halflen, align 8
  %add1919 = add nsw i64 0, %297
  %mul1920 = mul nsw i64 0, %add1919
  %add1921 = add nsw i64 %mul1920, 1
  %shl1922 = shl i64 %add1921, 62
  %sub1923 = sub nsw i64 %shl1922, 1
  %mul1924 = mul nsw i64 %sub1923, 2
  %add1925 = add nsw i64 %mul1924, 1
  br label %cond.end.1930

cond.false.1926:                                  ; preds = %cond.false.1912
  %298 = load i64, i64* %halflen, align 8
  %add1927 = add nsw i64 0, %298
  %mul1928 = mul nsw i64 0, %add1927
  %sub1929 = sub nsw i64 %mul1928, 1
  br label %cond.end.1930

cond.end.1930:                                    ; preds = %cond.false.1926, %cond.true.1918
  %cond1931 = phi i64 [ %add1925, %cond.true.1918 ], [ %sub1929, %cond.false.1926 ]
  %div1932 = sdiv i64 %cond1931, 8
  %299 = load i64, i64* %halflen, align 8
  %cmp1933 = icmp slt i64 %div1932, %299
  br i1 %cmp1933, label %cond.true.1949, label %lor.lhs.false.1935

lor.lhs.false.1935:                               ; preds = %cond.end.1930, %cond.end.1907, %cond.true.1876, %cond.end.1870, %cond.true.1842, %cond.end.1836
  %300 = load i64, i64* %halflen, align 8
  %mul1936 = mul nsw i64 %300, 8
  %mul1937 = mul nsw i64 0, %mul1936
  %sub1938 = sub nsw i64 %mul1937, 1
  %cmp1939 = icmp slt i64 %sub1938, 0
  br i1 %cmp1939, label %land.lhs.true.1941, label %lor.lhs.false.1945

land.lhs.true.1941:                               ; preds = %lor.lhs.false.1935
  %301 = load i64, i64* %halflen, align 8
  %mul1942 = mul nsw i64 %301, 8
  %cmp1943 = icmp slt i64 %mul1942, -9223372036854775808
  br i1 %cmp1943, label %cond.true.1949, label %lor.lhs.false.1945

lor.lhs.false.1945:                               ; preds = %land.lhs.true.1941, %lor.lhs.false.1935
  %302 = load i64, i64* %halflen, align 8
  %mul1946 = mul nsw i64 %302, 8
  %cmp1947 = icmp slt i64 9223372036854775807, %mul1946
  br i1 %cmp1947, label %cond.true.1949, label %cond.false.1961

cond.true.1949:                                   ; preds = %lor.lhs.false.1945, %land.lhs.true.1941, %cond.end.1930, %cond.end.1907, %cond.true.1876, %cond.end.1870, %cond.true.1842, %cond.end.1836, %land.lhs.true.1811
  %303 = load i64, i64* %halflen, align 8
  %mul1950 = mul i64 %303, 8
  %cmp1951 = icmp ule i64 %mul1950, 9223372036854775807
  br i1 %cmp1951, label %cond.true.1953, label %cond.false.1955

cond.true.1953:                                   ; preds = %cond.true.1949
  %304 = load i64, i64* %halflen, align 8
  %mul1954 = mul i64 %304, 8
  br label %cond.end.1959

cond.false.1955:                                  ; preds = %cond.true.1949
  %305 = load i64, i64* %halflen, align 8
  %mul1956 = mul i64 %305, 8
  %sub1957 = sub i64 %mul1956, -9223372036854775808
  %add1958 = add nsw i64 %sub1957, -9223372036854775808
  br label %cond.end.1959

cond.end.1959:                                    ; preds = %cond.false.1955, %cond.true.1953
  %cond1960 = phi i64 [ %mul1954, %cond.true.1953 ], [ %add1958, %cond.false.1955 ]
  store i64 %cond1960, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2169, label %lor.lhs.false.2166

cond.false.1961:                                  ; preds = %lor.lhs.false.1945
  %306 = load i64, i64* %halflen, align 8
  %mul1962 = mul i64 %306, 8
  %cmp1963 = icmp ule i64 %mul1962, 9223372036854775807
  br i1 %cmp1963, label %cond.true.1965, label %cond.false.1967

cond.true.1965:                                   ; preds = %cond.false.1961
  %307 = load i64, i64* %halflen, align 8
  %mul1966 = mul i64 %307, 8
  br label %cond.end.1971

cond.false.1967:                                  ; preds = %cond.false.1961
  %308 = load i64, i64* %halflen, align 8
  %mul1968 = mul i64 %308, 8
  %sub1969 = sub i64 %mul1968, -9223372036854775808
  %add1970 = add nsw i64 %sub1969, -9223372036854775808
  br label %cond.end.1971

cond.end.1971:                                    ; preds = %cond.false.1967, %cond.true.1965
  %cond1972 = phi i64 [ %mul1966, %cond.true.1965 ], [ %add1970, %cond.false.1967 ]
  store i64 %cond1972, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2169, label %lor.lhs.false.2166

cond.false.1973:                                  ; preds = %cond.false.1779
  %309 = load i64, i64* %halflen, align 8
  %add1974 = add nsw i64 0, %309
  %mul1975 = mul nsw i64 0, %add1974
  %sub1976 = sub nsw i64 %mul1975, 1
  %cmp1977 = icmp slt i64 %sub1976, 0
  br i1 %cmp1977, label %cond.true.1979, label %cond.false.1996

cond.true.1979:                                   ; preds = %cond.false.1973
  %310 = load i64, i64* %halflen, align 8
  %add1980 = add nsw i64 0, %310
  %mul1981 = mul nsw i64 0, %add1980
  %add1982 = add nsw i64 %mul1981, 0
  %neg1983 = xor i64 %add1982, -1
  %cmp1984 = icmp eq i64 %neg1983, -1
  %conv1985 = zext i1 %cmp1984 to i32
  %sub1986 = sub nsw i32 0, %conv1985
  %conv1987 = sext i32 %sub1986 to i64
  %311 = load i64, i64* %halflen, align 8
  %add1988 = add nsw i64 0, %311
  %mul1989 = mul nsw i64 0, %add1988
  %add1990 = add nsw i64 %mul1989, 1
  %shl1991 = shl i64 %add1990, 62
  %sub1992 = sub nsw i64 %shl1991, 1
  %mul1993 = mul nsw i64 %sub1992, 2
  %add1994 = add nsw i64 %mul1993, 1
  %sub1995 = sub nsw i64 %conv1987, %add1994
  br label %cond.end.2000

cond.false.1996:                                  ; preds = %cond.false.1973
  %312 = load i64, i64* %halflen, align 8
  %add1997 = add nsw i64 0, %312
  %mul1998 = mul nsw i64 0, %add1997
  %add1999 = add nsw i64 %mul1998, 0
  br label %cond.end.2000

cond.end.2000:                                    ; preds = %cond.false.1996, %cond.true.1979
  %cond2001 = phi i64 [ %sub1995, %cond.true.1979 ], [ %add1999, %cond.false.1996 ]
  %cmp2002 = icmp eq i64 %cond2001, 0
  br i1 %cmp2002, label %land.lhs.true.2004, label %lor.lhs.false.2007

land.lhs.true.2004:                               ; preds = %cond.end.2000
  %313 = load i64, i64* %halflen, align 8
  %cmp2005 = icmp slt i64 %313, 0
  br i1 %cmp2005, label %cond.true.2142, label %lor.lhs.false.2007

lor.lhs.false.2007:                               ; preds = %land.lhs.true.2004, %cond.end.2000
  br i1 false, label %cond.true.2008, label %cond.false.2068

cond.true.2008:                                   ; preds = %lor.lhs.false.2007
  %314 = load i64, i64* %halflen, align 8
  %cmp2009 = icmp slt i64 %314, 0
  br i1 %cmp2009, label %cond.true.2011, label %cond.false.2034

cond.true.2011:                                   ; preds = %cond.true.2008
  %315 = load i64, i64* %halflen, align 8
  %316 = load i64, i64* %halflen, align 8
  %add2012 = add nsw i64 0, %316
  %mul2013 = mul nsw i64 0, %add2012
  %sub2014 = sub nsw i64 %mul2013, 1
  %cmp2015 = icmp slt i64 %sub2014, 0
  br i1 %cmp2015, label %cond.true.2017, label %cond.false.2025

cond.true.2017:                                   ; preds = %cond.true.2011
  %317 = load i64, i64* %halflen, align 8
  %add2018 = add nsw i64 0, %317
  %mul2019 = mul nsw i64 0, %add2018
  %add2020 = add nsw i64 %mul2019, 1
  %shl2021 = shl i64 %add2020, 62
  %sub2022 = sub nsw i64 %shl2021, 1
  %mul2023 = mul nsw i64 %sub2022, 2
  %add2024 = add nsw i64 %mul2023, 1
  br label %cond.end.2029

cond.false.2025:                                  ; preds = %cond.true.2011
  %318 = load i64, i64* %halflen, align 8
  %add2026 = add nsw i64 0, %318
  %mul2027 = mul nsw i64 0, %add2026
  %sub2028 = sub nsw i64 %mul2027, 1
  br label %cond.end.2029

cond.end.2029:                                    ; preds = %cond.false.2025, %cond.true.2017
  %cond2030 = phi i64 [ %add2024, %cond.true.2017 ], [ %sub2028, %cond.false.2025 ]
  %div2031 = sdiv i64 %cond2030, 8
  %cmp2032 = icmp slt i64 %315, %div2031
  br i1 %cmp2032, label %cond.true.2142, label %lor.lhs.false.2128

cond.false.2034:                                  ; preds = %cond.true.2008
  br i1 false, label %cond.true.2035, label %cond.false.2036

cond.true.2035:                                   ; preds = %cond.false.2034
  br i1 false, label %cond.true.2142, label %lor.lhs.false.2128

cond.false.2036:                                  ; preds = %cond.false.2034
  %319 = load i64, i64* %halflen, align 8
  %add2037 = add nsw i64 0, %319
  %mul2038 = mul nsw i64 0, %add2037
  %sub2039 = sub nsw i64 %mul2038, 1
  %cmp2040 = icmp slt i64 %sub2039, 0
  br i1 %cmp2040, label %cond.true.2042, label %cond.false.2059

cond.true.2042:                                   ; preds = %cond.false.2036
  %320 = load i64, i64* %halflen, align 8
  %add2043 = add nsw i64 0, %320
  %mul2044 = mul nsw i64 0, %add2043
  %add2045 = add nsw i64 %mul2044, 0
  %neg2046 = xor i64 %add2045, -1
  %cmp2047 = icmp eq i64 %neg2046, -1
  %conv2048 = zext i1 %cmp2047 to i32
  %sub2049 = sub nsw i32 0, %conv2048
  %conv2050 = sext i32 %sub2049 to i64
  %321 = load i64, i64* %halflen, align 8
  %add2051 = add nsw i64 0, %321
  %mul2052 = mul nsw i64 0, %add2051
  %add2053 = add nsw i64 %mul2052, 1
  %shl2054 = shl i64 %add2053, 62
  %sub2055 = sub nsw i64 %shl2054, 1
  %mul2056 = mul nsw i64 %sub2055, 2
  %add2057 = add nsw i64 %mul2056, 1
  %sub2058 = sub nsw i64 %conv2050, %add2057
  br label %cond.end.2063

cond.false.2059:                                  ; preds = %cond.false.2036
  %322 = load i64, i64* %halflen, align 8
  %add2060 = add nsw i64 0, %322
  %mul2061 = mul nsw i64 0, %add2060
  %add2062 = add nsw i64 %mul2061, 0
  br label %cond.end.2063

cond.end.2063:                                    ; preds = %cond.false.2059, %cond.true.2042
  %cond2064 = phi i64 [ %sub2058, %cond.true.2042 ], [ %add2062, %cond.false.2059 ]
  %div2065 = sdiv i64 %cond2064, 8
  %323 = load i64, i64* %halflen, align 8
  %cmp2066 = icmp slt i64 %div2065, %323
  br i1 %cmp2066, label %cond.true.2142, label %lor.lhs.false.2128

cond.false.2068:                                  ; preds = %lor.lhs.false.2007
  br i1 false, label %cond.true.2069, label %cond.false.2070

cond.true.2069:                                   ; preds = %cond.false.2068
  br i1 false, label %cond.true.2142, label %lor.lhs.false.2128

cond.false.2070:                                  ; preds = %cond.false.2068
  %324 = load i64, i64* %halflen, align 8
  %cmp2071 = icmp slt i64 %324, 0
  br i1 %cmp2071, label %cond.true.2073, label %cond.false.2105

cond.true.2073:                                   ; preds = %cond.false.2070
  %325 = load i64, i64* %halflen, align 8
  %326 = load i64, i64* %halflen, align 8
  %add2074 = add nsw i64 0, %326
  %mul2075 = mul nsw i64 0, %add2074
  %sub2076 = sub nsw i64 %mul2075, 1
  %cmp2077 = icmp slt i64 %sub2076, 0
  br i1 %cmp2077, label %cond.true.2079, label %cond.false.2096

cond.true.2079:                                   ; preds = %cond.true.2073
  %327 = load i64, i64* %halflen, align 8
  %add2080 = add nsw i64 0, %327
  %mul2081 = mul nsw i64 0, %add2080
  %add2082 = add nsw i64 %mul2081, 0
  %neg2083 = xor i64 %add2082, -1
  %cmp2084 = icmp eq i64 %neg2083, -1
  %conv2085 = zext i1 %cmp2084 to i32
  %sub2086 = sub nsw i32 0, %conv2085
  %conv2087 = sext i32 %sub2086 to i64
  %328 = load i64, i64* %halflen, align 8
  %add2088 = add nsw i64 0, %328
  %mul2089 = mul nsw i64 0, %add2088
  %add2090 = add nsw i64 %mul2089, 1
  %shl2091 = shl i64 %add2090, 62
  %sub2092 = sub nsw i64 %shl2091, 1
  %mul2093 = mul nsw i64 %sub2092, 2
  %add2094 = add nsw i64 %mul2093, 1
  %sub2095 = sub nsw i64 %conv2087, %add2094
  br label %cond.end.2100

cond.false.2096:                                  ; preds = %cond.true.2073
  %329 = load i64, i64* %halflen, align 8
  %add2097 = add nsw i64 0, %329
  %mul2098 = mul nsw i64 0, %add2097
  %add2099 = add nsw i64 %mul2098, 0
  br label %cond.end.2100

cond.end.2100:                                    ; preds = %cond.false.2096, %cond.true.2079
  %cond2101 = phi i64 [ %sub2095, %cond.true.2079 ], [ %add2099, %cond.false.2096 ]
  %div2102 = sdiv i64 %cond2101, 8
  %cmp2103 = icmp slt i64 %325, %div2102
  br i1 %cmp2103, label %cond.true.2142, label %lor.lhs.false.2128

cond.false.2105:                                  ; preds = %cond.false.2070
  %330 = load i64, i64* %halflen, align 8
  %add2106 = add nsw i64 0, %330
  %mul2107 = mul nsw i64 0, %add2106
  %sub2108 = sub nsw i64 %mul2107, 1
  %cmp2109 = icmp slt i64 %sub2108, 0
  br i1 %cmp2109, label %cond.true.2111, label %cond.false.2119

cond.true.2111:                                   ; preds = %cond.false.2105
  %331 = load i64, i64* %halflen, align 8
  %add2112 = add nsw i64 0, %331
  %mul2113 = mul nsw i64 0, %add2112
  %add2114 = add nsw i64 %mul2113, 1
  %shl2115 = shl i64 %add2114, 62
  %sub2116 = sub nsw i64 %shl2115, 1
  %mul2117 = mul nsw i64 %sub2116, 2
  %add2118 = add nsw i64 %mul2117, 1
  br label %cond.end.2123

cond.false.2119:                                  ; preds = %cond.false.2105
  %332 = load i64, i64* %halflen, align 8
  %add2120 = add nsw i64 0, %332
  %mul2121 = mul nsw i64 0, %add2120
  %sub2122 = sub nsw i64 %mul2121, 1
  br label %cond.end.2123

cond.end.2123:                                    ; preds = %cond.false.2119, %cond.true.2111
  %cond2124 = phi i64 [ %add2118, %cond.true.2111 ], [ %sub2122, %cond.false.2119 ]
  %div2125 = sdiv i64 %cond2124, 8
  %333 = load i64, i64* %halflen, align 8
  %cmp2126 = icmp slt i64 %div2125, %333
  br i1 %cmp2126, label %cond.true.2142, label %lor.lhs.false.2128

lor.lhs.false.2128:                               ; preds = %cond.end.2123, %cond.end.2100, %cond.true.2069, %cond.end.2063, %cond.true.2035, %cond.end.2029
  %334 = load i64, i64* %halflen, align 8
  %mul2129 = mul nsw i64 %334, 8
  %mul2130 = mul nsw i64 0, %mul2129
  %sub2131 = sub nsw i64 %mul2130, 1
  %cmp2132 = icmp slt i64 %sub2131, 0
  br i1 %cmp2132, label %land.lhs.true.2134, label %lor.lhs.false.2138

land.lhs.true.2134:                               ; preds = %lor.lhs.false.2128
  %335 = load i64, i64* %halflen, align 8
  %mul2135 = mul nsw i64 %335, 8
  %cmp2136 = icmp slt i64 %mul2135, -9223372036854775808
  br i1 %cmp2136, label %cond.true.2142, label %lor.lhs.false.2138

lor.lhs.false.2138:                               ; preds = %land.lhs.true.2134, %lor.lhs.false.2128
  %336 = load i64, i64* %halflen, align 8
  %mul2139 = mul nsw i64 %336, 8
  %cmp2140 = icmp slt i64 9223372036854775807, %mul2139
  br i1 %cmp2140, label %cond.true.2142, label %cond.false.2154

cond.true.2142:                                   ; preds = %lor.lhs.false.2138, %land.lhs.true.2134, %cond.end.2123, %cond.end.2100, %cond.true.2069, %cond.end.2063, %cond.true.2035, %cond.end.2029, %land.lhs.true.2004
  %337 = load i64, i64* %halflen, align 8
  %mul2143 = mul i64 %337, 8
  %cmp2144 = icmp ule i64 %mul2143, 9223372036854775807
  br i1 %cmp2144, label %cond.true.2146, label %cond.false.2148

cond.true.2146:                                   ; preds = %cond.true.2142
  %338 = load i64, i64* %halflen, align 8
  %mul2147 = mul i64 %338, 8
  br label %cond.end.2152

cond.false.2148:                                  ; preds = %cond.true.2142
  %339 = load i64, i64* %halflen, align 8
  %mul2149 = mul i64 %339, 8
  %sub2150 = sub i64 %mul2149, -9223372036854775808
  %add2151 = add nsw i64 %sub2150, -9223372036854775808
  br label %cond.end.2152

cond.end.2152:                                    ; preds = %cond.false.2148, %cond.true.2146
  %cond2153 = phi i64 [ %mul2147, %cond.true.2146 ], [ %add2151, %cond.false.2148 ]
  store i64 %cond2153, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2169, label %lor.lhs.false.2166

cond.false.2154:                                  ; preds = %lor.lhs.false.2138
  %340 = load i64, i64* %halflen, align 8
  %mul2155 = mul i64 %340, 8
  %cmp2156 = icmp ule i64 %mul2155, 9223372036854775807
  br i1 %cmp2156, label %cond.true.2158, label %cond.false.2160

cond.true.2158:                                   ; preds = %cond.false.2154
  %341 = load i64, i64* %halflen, align 8
  %mul2159 = mul i64 %341, 8
  br label %cond.end.2164

cond.false.2160:                                  ; preds = %cond.false.2154
  %342 = load i64, i64* %halflen, align 8
  %mul2161 = mul i64 %342, 8
  %sub2162 = sub i64 %mul2161, -9223372036854775808
  %add2163 = add nsw i64 %sub2162, -9223372036854775808
  br label %cond.end.2164

cond.end.2164:                                    ; preds = %cond.false.2160, %cond.true.2158
  %cond2165 = phi i64 [ %mul2159, %cond.true.2158 ], [ %add2163, %cond.false.2160 ]
  store i64 %cond2165, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2169, label %lor.lhs.false.2166

lor.lhs.false.2166:                               ; preds = %cond.end.2164, %cond.end.2152, %cond.end.1971, %cond.end.1959, %cond.end.1777, %cond.end.1765, %cond.end.1584, %cond.end.1572, %cond.end.1388, %cond.end.1372, %cond.end.1187, %cond.end.1171, %cond.end.959, %cond.end.936, %cond.end.744, %cond.end.721, %cond.end.474, %cond.end.451, %cond.end.259, %cond.end.236
  %343 = load i64, i64* %alloca_nbytes, align 8
  %cmp2167 = icmp ult i64 -1, %343
  br i1 %cmp2167, label %if.then.2169, label %if.else

if.then.2169:                                     ; preds = %lor.lhs.false.2166, %cond.end.2164, %cond.end.2152, %cond.end.1971, %cond.end.1959, %cond.end.1777, %cond.end.1765, %cond.end.1584, %cond.end.1572, %cond.end.1388, %cond.end.1372, %cond.end.1187, %cond.end.1171, %cond.end.959, %cond.end.936, %cond.end.744, %cond.end.721, %cond.end.474, %cond.end.451, %cond.end.259, %cond.end.236
  call void @memory_full(i64 -1) #8
  unreachable

if.else:                                          ; preds = %lor.lhs.false.2166
  %344 = load i64, i64* %alloca_nbytes, align 8
  %345 = load i64, i64* %sa_avail, align 8
  %cmp2170 = icmp sle i64 %344, %345
  br i1 %cmp2170, label %if.then.2172, label %if.else.2174

if.then.2172:                                     ; preds = %if.else
  %346 = load i64, i64* %alloca_nbytes, align 8
  %347 = load i64, i64* %sa_avail, align 8
  %sub2173 = sub nsw i64 %347, %346
  store i64 %sub2173, i64* %sa_avail, align 8
  %348 = load i64, i64* %alloca_nbytes, align 8
  %349 = alloca i8, i64 %348
  %350 = bitcast i8* %349 to i64*
  store i64* %350, i64** %tmp, align 8
  br label %if.end.2178

if.else.2174:                                     ; preds = %if.else
  %351 = load i64, i64* %alloca_nbytes, align 8
  %call2176 = call noalias i8* @xmalloc(i64 %351)
  %352 = bitcast i8* %call2176 to i64*
  store i64* %352, i64** %tmp, align 8
  %353 = load i64*, i64** %tmp, align 8
  %354 = load i64, i64* %halflen, align 8
  %call2177 = call i64 @make_save_memory(i64* %353, i64 %354)
  store i64 %call2177, i64* %arg_, align 8
  store i8 1, i8* %sa_must_free, align 1
  %355 = load i64, i64* %arg_, align 8
  call void @record_unwind_protect(void (i64)* @free_save_value, i64 %355)
  br label %if.end.2178

if.end.2178:                                      ; preds = %if.else.2174, %if.then.2172
  br label %if.end.2179

if.end.2179:                                      ; preds = %if.end.2178
  br label %do.end

do.end:                                           ; preds = %if.end.2179
  store i64 0, i64* %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end
  %356 = load i64, i64* %i, align 8
  %357 = load i64, i64* %halflen, align 8
  %cmp2181 = icmp slt i64 %356, %357
  br i1 %cmp2181, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %358 = load i64, i64* %i, align 8
  %359 = load i64*, i64** %tmp, align 8
  %arrayidx = getelementptr inbounds i64, i64* %359, i64 %358
  store i64 2, i64* %arrayidx, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %360 = load i64, i64* %i, align 8
  %inc = add nsw i64 %360, 1
  store i64 %inc, i64* %i, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %361 = load i64, i64* %predicate.addr, align 8
  %362 = load i64, i64* %len, align 8
  %363 = load i64, i64* %vector.addr, align 8
  %call2183 = call %struct.Lisp_Vector* @XVECTOR(i64 %363)
  %contents = getelementptr inbounds %struct.Lisp_Vector, %struct.Lisp_Vector* %call2183, i32 0, i32 1
  %arraydecay = getelementptr inbounds [0 x i64], [0 x i64]* %contents, i32 0, i32 0
  %364 = load i64*, i64** %tmp, align 8
  call void @sort_vector_inplace(i64 %361, i64 %362, i64* %arraydecay, i64* %364)
  br label %do.body.2184

do.body.2184:                                     ; preds = %for.end
  %365 = load i8, i8* %sa_must_free, align 1
  %tobool = trunc i8 %365 to i1
  br i1 %tobool, label %if.then.2185, label %if.end.2188

if.then.2185:                                     ; preds = %do.body.2184
  store i8 0, i8* %sa_must_free, align 1
  %366 = load i64, i64* %sa_count, align 8
  %call2186 = call i64 @builtin_lisp_symbol(i32 0)
  %call2187 = call i64 @unbind_to(i64 %366, i64 %call2186)
  br label %if.end.2188

if.end.2188:                                      ; preds = %if.then.2185, %do.body.2184
  br label %do.end.2189

do.end.2189:                                      ; preds = %if.then, %if.end.2188
  ret void
}

; Function Attrs: nounwind uwtable
define i64 @merge(i64 %org_l1, i64 %org_l2, i64 %pred) #1 {
entry:
  %retval = alloca i64, align 8
  %org_l1.addr = alloca i64, align 8
  %org_l2.addr = alloca i64, align 8
  %pred.addr = alloca i64, align 8
  %l1 = alloca i64, align 8
  %l2 = alloca i64, align 8
  %tail = alloca i64, align 8
  %value = alloca i64, align 8
  %tem = alloca i64, align 8
  store i64 %org_l1, i64* %org_l1.addr, align 8
  store i64 %org_l2, i64* %org_l2.addr, align 8
  store i64 %pred, i64* %pred.addr, align 8
  %0 = load i64, i64* %org_l1.addr, align 8
  store i64 %0, i64* %l1, align 8
  %1 = load i64, i64* %org_l2.addr, align 8
  store i64 %1, i64* %l2, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call, i64* %tail, align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call1, i64* %value, align 8
  br label %while.body

while.body:                                       ; preds = %entry, %if.end.29
  %2 = load i64, i64* %l1, align 8
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %2, %call2
  br i1 %cmp, label %if.then, label %if.end.7

if.then:                                          ; preds = %while.body
  %3 = load i64, i64* %tail, align 8
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp4 = icmp eq i64 %3, %call3
  br i1 %cmp4, label %if.then.5, label %if.end

if.then.5:                                        ; preds = %if.then
  %4 = load i64, i64* %l2, align 8
  store i64 %4, i64* %retval
  br label %return

if.end:                                           ; preds = %if.then
  %5 = load i64, i64* %tail, align 8
  %6 = load i64, i64* %l2, align 8
  %call6 = call i64 @Fsetcdr(i64 %5, i64 %6)
  %7 = load i64, i64* %value, align 8
  store i64 %7, i64* %retval
  br label %return

if.end.7:                                         ; preds = %while.body
  %8 = load i64, i64* %l2, align 8
  %call8 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp9 = icmp eq i64 %8, %call8
  br i1 %cmp9, label %if.then.10, label %if.end.16

if.then.10:                                       ; preds = %if.end.7
  %9 = load i64, i64* %tail, align 8
  %call11 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp12 = icmp eq i64 %9, %call11
  br i1 %cmp12, label %if.then.13, label %if.end.14

if.then.13:                                       ; preds = %if.then.10
  %10 = load i64, i64* %l1, align 8
  store i64 %10, i64* %retval
  br label %return

if.end.14:                                        ; preds = %if.then.10
  %11 = load i64, i64* %tail, align 8
  %12 = load i64, i64* %l1, align 8
  %call15 = call i64 @Fsetcdr(i64 %11, i64 %12)
  %13 = load i64, i64* %value, align 8
  store i64 %13, i64* %retval
  br label %return

if.end.16:                                        ; preds = %if.end.7
  %14 = load i64, i64* %pred.addr, align 8
  %15 = load i64, i64* %l1, align 8
  %call17 = call i64 @Fcar(i64 %15)
  %16 = load i64, i64* %l2, align 8
  %call18 = call i64 @Fcar(i64 %16)
  %call19 = call zeroext i1 @inorder(i64 %14, i64 %call17, i64 %call18)
  br i1 %call19, label %if.then.20, label %if.else

if.then.20:                                       ; preds = %if.end.16
  %17 = load i64, i64* %l1, align 8
  store i64 %17, i64* %tem, align 8
  %18 = load i64, i64* %l1, align 8
  %call21 = call i64 @Fcdr(i64 %18)
  store i64 %call21, i64* %l1, align 8
  %19 = load i64, i64* %l1, align 8
  store i64 %19, i64* %org_l1.addr, align 8
  br label %if.end.23

if.else:                                          ; preds = %if.end.16
  %20 = load i64, i64* %l2, align 8
  store i64 %20, i64* %tem, align 8
  %21 = load i64, i64* %l2, align 8
  %call22 = call i64 @Fcdr(i64 %21)
  store i64 %call22, i64* %l2, align 8
  %22 = load i64, i64* %l2, align 8
  store i64 %22, i64* %org_l2.addr, align 8
  br label %if.end.23

if.end.23:                                        ; preds = %if.else, %if.then.20
  %23 = load i64, i64* %tail, align 8
  %call24 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp25 = icmp eq i64 %23, %call24
  br i1 %cmp25, label %if.then.26, label %if.else.27

if.then.26:                                       ; preds = %if.end.23
  %24 = load i64, i64* %tem, align 8
  store i64 %24, i64* %value, align 8
  br label %if.end.29

if.else.27:                                       ; preds = %if.end.23
  %25 = load i64, i64* %tail, align 8
  %26 = load i64, i64* %tem, align 8
  %call28 = call i64 @Fsetcdr(i64 %25, i64 %26)
  br label %if.end.29

if.end.29:                                        ; preds = %if.else.27, %if.then.26
  %27 = load i64, i64* %tem, align 8
  store i64 %27, i64* %tail, align 8
  br label %while.body

return:                                           ; preds = %if.end.14, %if.then.13, %if.end, %if.then.5
  %28 = load i64, i64* %retval
  ret i64 %28
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @inorder(i64 %pred, i64 %a, i64 %b) #1 {
entry:
  %pred.addr = alloca i64, align 8
  %a.addr = alloca i64, align 8
  %b.addr = alloca i64, align 8
  store i64 %pred, i64* %pred.addr, align 8
  store i64 %a, i64* %a.addr, align 8
  store i64 %b, i64* %b.addr, align 8
  %0 = load i64, i64* %pred.addr, align 8
  %1 = load i64, i64* %b.addr, align 8
  %2 = load i64, i64* %a.addr, align 8
  %call = call i64 @call2(i64 %0, i64 %1, i64 %2)
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %call, %call1
  ret i1 %cmp
}

declare i64 @Fcdr(i64) #2

; Function Attrs: nounwind uwtable
define i64 @Fplist_get(i64 %plist, i64 %prop) #1 {
entry:
  %retval = alloca i64, align 8
  %plist.addr = alloca i64, align 8
  %prop.addr = alloca i64, align 8
  %tail = alloca i64, align 8
  %halftail = alloca i64, align 8
  store i64 %plist, i64* %plist.addr, align 8
  store i64 %prop, i64* %prop.addr, align 8
  %0 = load i64, i64* %plist.addr, align 8
  store i64 %0, i64* %halftail, align 8
  store i64 %0, i64* %tail, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end.26, %entry
  %1 = load i64, i64* %tail, align 8
  %and = and i64 %1, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %2 = load i64, i64* %tail, align 8
  %sub = sub nsw i64 %2, 3
  %3 = inttoptr i64 %sub to i8*
  %4 = bitcast i8* %3 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %4, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %5 = load i64, i64* %cdr, align 8
  %and2 = and i64 %5, 7
  %conv3 = trunc i64 %and2 to i32
  %cmp4 = icmp eq i32 %conv3, 3
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %6 = phi i1 [ false, %while.cond ], [ %cmp4, %land.rhs ]
  br i1 %6, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %7 = load i64, i64* %prop.addr, align 8
  %8 = load i64, i64* %tail, align 8
  %sub6 = sub nsw i64 %8, 3
  %9 = inttoptr i64 %sub6 to i8*
  %10 = bitcast i8* %9 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %10, i32 0, i32 0
  %11 = load i64, i64* %car, align 8
  %cmp7 = icmp eq i64 %7, %11
  br i1 %cmp7, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %12 = load i64, i64* %tail, align 8
  %sub9 = sub nsw i64 %12, 3
  %13 = inttoptr i64 %sub9 to i8*
  %14 = bitcast i8* %13 to %struct.Lisp_Cons*
  %u10 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %14, i32 0, i32 1
  %cdr11 = bitcast %union.anon* %u10 to i64*
  %15 = load i64, i64* %cdr11, align 8
  %sub12 = sub nsw i64 %15, 3
  %16 = inttoptr i64 %sub12 to i8*
  %17 = bitcast i8* %16 to %struct.Lisp_Cons*
  %car13 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %17, i32 0, i32 0
  %18 = load i64, i64* %car13, align 8
  store i64 %18, i64* %retval
  br label %return

if.end:                                           ; preds = %while.body
  %19 = load i64, i64* %tail, align 8
  %sub14 = sub nsw i64 %19, 3
  %20 = inttoptr i64 %sub14 to i8*
  %21 = bitcast i8* %20 to %struct.Lisp_Cons*
  %u15 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %21, i32 0, i32 1
  %cdr16 = bitcast %union.anon* %u15 to i64*
  %22 = load i64, i64* %cdr16, align 8
  %sub17 = sub nsw i64 %22, 3
  %23 = inttoptr i64 %sub17 to i8*
  %24 = bitcast i8* %23 to %struct.Lisp_Cons*
  %u18 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %24, i32 0, i32 1
  %cdr19 = bitcast %union.anon* %u18 to i64*
  %25 = load i64, i64* %cdr19, align 8
  store i64 %25, i64* %tail, align 8
  %26 = load i64, i64* %halftail, align 8
  %sub20 = sub nsw i64 %26, 3
  %27 = inttoptr i64 %sub20 to i8*
  %28 = bitcast i8* %27 to %struct.Lisp_Cons*
  %u21 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %28, i32 0, i32 1
  %cdr22 = bitcast %union.anon* %u21 to i64*
  %29 = load i64, i64* %cdr22, align 8
  store i64 %29, i64* %halftail, align 8
  %30 = load i64, i64* %tail, align 8
  %31 = load i64, i64* %halftail, align 8
  %cmp23 = icmp eq i64 %30, %31
  br i1 %cmp23, label %if.then.25, label %if.end.26

if.then.25:                                       ; preds = %if.end
  br label %while.end

if.end.26:                                        ; preds = %if.end
  br label %while.cond

while.end:                                        ; preds = %if.then.25, %land.end
  %call = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call, i64* %retval
  br label %return

return:                                           ; preds = %while.end, %if.then
  %32 = load i64, i64* %retval
  ret i64 %32
}

; Function Attrs: nounwind uwtable
define i64 @Fget(i64 %symbol, i64 %propname) #1 {
entry:
  %symbol.addr = alloca i64, align 8
  %propname.addr = alloca i64, align 8
  store i64 %symbol, i64* %symbol.addr, align 8
  store i64 %propname, i64* %propname.addr, align 8
  %0 = load i64, i64* %symbol.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = call i64 @builtin_lisp_symbol(i32 897)
  %1 = load i64, i64* %symbol.addr, align 8
  %2 = call i64 @wrong_type_argument(i64 %call, i64 %1) #8
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %3, %cond.true
  %4 = load i64, i64* %symbol.addr, align 8
  %sub = sub nsw i64 %4, 0
  %add.ptr = getelementptr inbounds i8, i8* bitcast ([1074 x %struct.Lisp_Symbol]* @lispsym to i8*), i64 %sub
  %5 = bitcast i8* %add.ptr to %struct.Lisp_Symbol*
  %plist = getelementptr inbounds %struct.Lisp_Symbol, %struct.Lisp_Symbol* %5, i32 0, i32 4
  %6 = load i64, i64* %plist, align 8
  %7 = load i64, i64* %propname.addr, align 8
  %call2 = call i64 @Fplist_get(i64 %6, i64 %7)
  ret i64 %call2
}

; Function Attrs: nounwind uwtable
define i64 @Fplist_put(i64 %plist, i64 %prop, i64 %val) #1 {
entry:
  %retval = alloca i64, align 8
  %plist.addr = alloca i64, align 8
  %prop.addr = alloca i64, align 8
  %val.addr = alloca i64, align 8
  %tail = alloca i64, align 8
  %prev = alloca i64, align 8
  %newcell = alloca i64, align 8
  store i64 %plist, i64* %plist.addr, align 8
  store i64 %prop, i64* %prop.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call, i64* %prev, align 8
  %0 = load i64, i64* %plist.addr, align 8
  store i64 %0, i64* %tail, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i64, i64* %tail, align 8
  %and = and i64 %1, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %2 = load i64, i64* %tail, align 8
  %sub = sub nsw i64 %2, 3
  %3 = inttoptr i64 %sub to i8*
  %4 = bitcast i8* %3 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %4, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %5 = load i64, i64* %cdr, align 8
  %and2 = and i64 %5, 7
  %conv3 = trunc i64 %and2 to i32
  %cmp4 = icmp eq i32 %conv3, 3
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %6 = phi i1 [ false, %for.cond ], [ %cmp4, %land.rhs ]
  br i1 %6, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %7 = load i64, i64* %prop.addr, align 8
  %8 = load i64, i64* %tail, align 8
  %sub6 = sub nsw i64 %8, 3
  %9 = inttoptr i64 %sub6 to i8*
  %10 = bitcast i8* %9 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %10, i32 0, i32 0
  %11 = load i64, i64* %car, align 8
  %cmp7 = icmp eq i64 %7, %11
  br i1 %cmp7, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %12 = load i64, i64* %tail, align 8
  %sub9 = sub nsw i64 %12, 3
  %13 = inttoptr i64 %sub9 to i8*
  %14 = bitcast i8* %13 to %struct.Lisp_Cons*
  %u10 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %14, i32 0, i32 1
  %cdr11 = bitcast %union.anon* %u10 to i64*
  %15 = load i64, i64* %cdr11, align 8
  %16 = load i64, i64* %val.addr, align 8
  %call12 = call i64 @Fsetcar(i64 %15, i64 %16)
  %17 = load i64, i64* %plist.addr, align 8
  store i64 %17, i64* %retval
  br label %return

if.end:                                           ; preds = %for.body
  %18 = load i64, i64* %tail, align 8
  store i64 %18, i64* %prev, align 8
  br label %do.body

do.body:                                          ; preds = %if.end
  %19 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call13 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp14 = icmp eq i64 %19, %call13
  br i1 %cmp14, label %if.else, label %land.lhs.true

land.lhs.true:                                    ; preds = %do.body
  %20 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  %call16 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp17 = icmp eq i64 %20, %call16
  br i1 %cmp17, label %if.then.19, label %if.else

if.then.19:                                       ; preds = %land.lhs.true
  call void @process_quit_flag()
  br label %if.end.22

if.else:                                          ; preds = %land.lhs.true, %do.body
  %21 = load volatile i8, i8* @pending_signals, align 1
  %tobool = trunc i8 %21 to i1
  br i1 %tobool, label %if.then.20, label %if.end.21

if.then.20:                                       ; preds = %if.else
  call void @process_pending_signals()
  br label %if.end.21

if.end.21:                                        ; preds = %if.then.20, %if.else
  br label %if.end.22

if.end.22:                                        ; preds = %if.end.21, %if.then.19
  br label %do.end

do.end:                                           ; preds = %if.end.22
  br label %for.inc

for.inc:                                          ; preds = %do.end
  %22 = load i64, i64* %tail, align 8
  %sub23 = sub nsw i64 %22, 3
  %23 = inttoptr i64 %sub23 to i8*
  %24 = bitcast i8* %23 to %struct.Lisp_Cons*
  %u24 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %24, i32 0, i32 1
  %cdr25 = bitcast %union.anon* %u24 to i64*
  %25 = load i64, i64* %cdr25, align 8
  %sub26 = sub nsw i64 %25, 3
  %26 = inttoptr i64 %sub26 to i8*
  %27 = bitcast i8* %26 to %struct.Lisp_Cons*
  %u27 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %27, i32 0, i32 1
  %cdr28 = bitcast %union.anon* %u27 to i64*
  %28 = load i64, i64* %cdr28, align 8
  store i64 %28, i64* %tail, align 8
  br label %for.cond

for.end:                                          ; preds = %land.end
  %29 = load i64, i64* %prop.addr, align 8
  %30 = load i64, i64* %val.addr, align 8
  %31 = load i64, i64* %prev, align 8
  %call29 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp30 = icmp eq i64 %31, %call29
  br i1 %cmp30, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.end
  %32 = load i64, i64* %plist.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %for.end
  %33 = load i64, i64* %prev, align 8
  %sub32 = sub nsw i64 %33, 3
  %34 = inttoptr i64 %sub32 to i8*
  %35 = bitcast i8* %34 to %struct.Lisp_Cons*
  %u33 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %35, i32 0, i32 1
  %cdr34 = bitcast %union.anon* %u33 to i64*
  %36 = load i64, i64* %cdr34, align 8
  %sub35 = sub nsw i64 %36, 3
  %37 = inttoptr i64 %sub35 to i8*
  %38 = bitcast i8* %37 to %struct.Lisp_Cons*
  %u36 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %38, i32 0, i32 1
  %cdr37 = bitcast %union.anon* %u36 to i64*
  %39 = load i64, i64* %cdr37, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %32, %cond.true ], [ %39, %cond.false ]
  %call38 = call i64 @Fcons(i64 %30, i64 %cond)
  %call39 = call i64 @Fcons(i64 %29, i64 %call38)
  store i64 %call39, i64* %newcell, align 8
  %40 = load i64, i64* %prev, align 8
  %call40 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp41 = icmp eq i64 %40, %call40
  br i1 %cmp41, label %if.then.43, label %if.else.44

if.then.43:                                       ; preds = %cond.end
  %41 = load i64, i64* %newcell, align 8
  store i64 %41, i64* %retval
  br label %return

if.else.44:                                       ; preds = %cond.end
  %42 = load i64, i64* %prev, align 8
  %sub45 = sub nsw i64 %42, 3
  %43 = inttoptr i64 %sub45 to i8*
  %44 = bitcast i8* %43 to %struct.Lisp_Cons*
  %u46 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %44, i32 0, i32 1
  %cdr47 = bitcast %union.anon* %u46 to i64*
  %45 = load i64, i64* %cdr47, align 8
  %46 = load i64, i64* %newcell, align 8
  %call48 = call i64 @Fsetcdr(i64 %45, i64 %46)
  br label %if.end.49

if.end.49:                                        ; preds = %if.else.44
  %47 = load i64, i64* %plist.addr, align 8
  store i64 %47, i64* %retval
  br label %return

return:                                           ; preds = %if.end.49, %if.then.43, %if.then
  %48 = load i64, i64* %retval
  ret i64 %48
}

declare i64 @Fsetcar(i64, i64) #2

; Function Attrs: nounwind uwtable
define i64 @Fput(i64 %symbol, i64 %propname, i64 %value) #1 {
entry:
  %symbol.addr = alloca i64, align 8
  %propname.addr = alloca i64, align 8
  %value.addr = alloca i64, align 8
  store i64 %symbol, i64* %symbol.addr, align 8
  store i64 %propname, i64* %propname.addr, align 8
  store i64 %value, i64* %value.addr, align 8
  %0 = load i64, i64* %symbol.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = call i64 @builtin_lisp_symbol(i32 897)
  %1 = load i64, i64* %symbol.addr, align 8
  %2 = call i64 @wrong_type_argument(i64 %call, i64 %1) #8
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %3, %cond.true
  %4 = load i64, i64* %symbol.addr, align 8
  %5 = load i64, i64* %symbol.addr, align 8
  %sub = sub nsw i64 %5, 0
  %add.ptr = getelementptr inbounds i8, i8* bitcast ([1074 x %struct.Lisp_Symbol]* @lispsym to i8*), i64 %sub
  %6 = bitcast i8* %add.ptr to %struct.Lisp_Symbol*
  %plist = getelementptr inbounds %struct.Lisp_Symbol, %struct.Lisp_Symbol* %6, i32 0, i32 4
  %7 = load i64, i64* %plist, align 8
  %8 = load i64, i64* %propname.addr, align 8
  %9 = load i64, i64* %value.addr, align 8
  %call2 = call i64 @Fplist_put(i64 %7, i64 %8, i64 %9)
  call void @set_symbol_plist(i64 %4, i64 %call2)
  %10 = load i64, i64* %value.addr, align 8
  ret i64 %10
}

declare void @set_symbol_plist(i64, i64) #2

; Function Attrs: nounwind uwtable
define i64 @Flax_plist_get(i64 %plist, i64 %prop) #1 {
entry:
  %retval = alloca i64, align 8
  %plist.addr = alloca i64, align 8
  %prop.addr = alloca i64, align 8
  %tail = alloca i64, align 8
  store i64 %plist, i64* %plist.addr, align 8
  store i64 %prop, i64* %prop.addr, align 8
  %0 = load i64, i64* %plist.addr, align 8
  store i64 %0, i64* %tail, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i64, i64* %tail, align 8
  %and = and i64 %1, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %2 = load i64, i64* %tail, align 8
  %sub = sub nsw i64 %2, 3
  %3 = inttoptr i64 %sub to i8*
  %4 = bitcast i8* %3 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %4, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %5 = load i64, i64* %cdr, align 8
  %and2 = and i64 %5, 7
  %conv3 = trunc i64 %and2 to i32
  %cmp4 = icmp eq i32 %conv3, 3
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %6 = phi i1 [ false, %for.cond ], [ %cmp4, %land.rhs ]
  br i1 %6, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %7 = load i64, i64* %prop.addr, align 8
  %8 = load i64, i64* %tail, align 8
  %sub6 = sub nsw i64 %8, 3
  %9 = inttoptr i64 %sub6 to i8*
  %10 = bitcast i8* %9 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %10, i32 0, i32 0
  %11 = load i64, i64* %car, align 8
  %call = call i64 @Fequal(i64 %7, i64 %11)
  %call7 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp8 = icmp eq i64 %call, %call7
  br i1 %cmp8, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  %12 = load i64, i64* %tail, align 8
  %sub10 = sub nsw i64 %12, 3
  %13 = inttoptr i64 %sub10 to i8*
  %14 = bitcast i8* %13 to %struct.Lisp_Cons*
  %u11 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %14, i32 0, i32 1
  %cdr12 = bitcast %union.anon* %u11 to i64*
  %15 = load i64, i64* %cdr12, align 8
  %sub13 = sub nsw i64 %15, 3
  %16 = inttoptr i64 %sub13 to i8*
  %17 = bitcast i8* %16 to %struct.Lisp_Cons*
  %car14 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %17, i32 0, i32 0
  %18 = load i64, i64* %car14, align 8
  store i64 %18, i64* %retval
  br label %return

if.end:                                           ; preds = %for.body
  br label %do.body

do.body:                                          ; preds = %if.end
  %19 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call15 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp16 = icmp eq i64 %19, %call15
  br i1 %cmp16, label %if.else, label %land.lhs.true

land.lhs.true:                                    ; preds = %do.body
  %20 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  %call18 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp19 = icmp eq i64 %20, %call18
  br i1 %cmp19, label %if.then.21, label %if.else

if.then.21:                                       ; preds = %land.lhs.true
  call void @process_quit_flag()
  br label %if.end.24

if.else:                                          ; preds = %land.lhs.true, %do.body
  %21 = load volatile i8, i8* @pending_signals, align 1
  %tobool = trunc i8 %21 to i1
  br i1 %tobool, label %if.then.22, label %if.end.23

if.then.22:                                       ; preds = %if.else
  call void @process_pending_signals()
  br label %if.end.23

if.end.23:                                        ; preds = %if.then.22, %if.else
  br label %if.end.24

if.end.24:                                        ; preds = %if.end.23, %if.then.21
  br label %do.end

do.end:                                           ; preds = %if.end.24
  br label %for.inc

for.inc:                                          ; preds = %do.end
  %22 = load i64, i64* %tail, align 8
  %sub25 = sub nsw i64 %22, 3
  %23 = inttoptr i64 %sub25 to i8*
  %24 = bitcast i8* %23 to %struct.Lisp_Cons*
  %u26 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %24, i32 0, i32 1
  %cdr27 = bitcast %union.anon* %u26 to i64*
  %25 = load i64, i64* %cdr27, align 8
  %sub28 = sub nsw i64 %25, 3
  %26 = inttoptr i64 %sub28 to i8*
  %27 = bitcast i8* %26 to %struct.Lisp_Cons*
  %u29 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %27, i32 0, i32 1
  %cdr30 = bitcast %union.anon* %u29 to i64*
  %28 = load i64, i64* %cdr30, align 8
  store i64 %28, i64* %tail, align 8
  br label %for.cond

for.end:                                          ; preds = %land.end
  %29 = load i64, i64* %tail, align 8
  %30 = load i64, i64* %prop.addr, align 8
  call void @CHECK_LIST_END(i64 %29, i64 %30)
  %call31 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call31, i64* %retval
  br label %return

return:                                           ; preds = %for.end, %if.then
  %31 = load i64, i64* %retval
  ret i64 %31
}

; Function Attrs: nounwind uwtable
define i64 @Flax_plist_put(i64 %plist, i64 %prop, i64 %val) #1 {
entry:
  %retval = alloca i64, align 8
  %plist.addr = alloca i64, align 8
  %prop.addr = alloca i64, align 8
  %val.addr = alloca i64, align 8
  %tail = alloca i64, align 8
  %prev = alloca i64, align 8
  %newcell = alloca i64, align 8
  store i64 %plist, i64* %plist.addr, align 8
  store i64 %prop, i64* %prop.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call, i64* %prev, align 8
  %0 = load i64, i64* %plist.addr, align 8
  store i64 %0, i64* %tail, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i64, i64* %tail, align 8
  %and = and i64 %1, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %2 = load i64, i64* %tail, align 8
  %sub = sub nsw i64 %2, 3
  %3 = inttoptr i64 %sub to i8*
  %4 = bitcast i8* %3 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %4, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %5 = load i64, i64* %cdr, align 8
  %and2 = and i64 %5, 7
  %conv3 = trunc i64 %and2 to i32
  %cmp4 = icmp eq i32 %conv3, 3
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %6 = phi i1 [ false, %for.cond ], [ %cmp4, %land.rhs ]
  br i1 %6, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %7 = load i64, i64* %prop.addr, align 8
  %8 = load i64, i64* %tail, align 8
  %sub6 = sub nsw i64 %8, 3
  %9 = inttoptr i64 %sub6 to i8*
  %10 = bitcast i8* %9 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %10, i32 0, i32 0
  %11 = load i64, i64* %car, align 8
  %call7 = call i64 @Fequal(i64 %7, i64 %11)
  %call8 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp9 = icmp eq i64 %call7, %call8
  br i1 %cmp9, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  %12 = load i64, i64* %tail, align 8
  %sub11 = sub nsw i64 %12, 3
  %13 = inttoptr i64 %sub11 to i8*
  %14 = bitcast i8* %13 to %struct.Lisp_Cons*
  %u12 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %14, i32 0, i32 1
  %cdr13 = bitcast %union.anon* %u12 to i64*
  %15 = load i64, i64* %cdr13, align 8
  %16 = load i64, i64* %val.addr, align 8
  %call14 = call i64 @Fsetcar(i64 %15, i64 %16)
  %17 = load i64, i64* %plist.addr, align 8
  store i64 %17, i64* %retval
  br label %return

if.end:                                           ; preds = %for.body
  %18 = load i64, i64* %tail, align 8
  store i64 %18, i64* %prev, align 8
  br label %do.body

do.body:                                          ; preds = %if.end
  %19 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call15 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp16 = icmp eq i64 %19, %call15
  br i1 %cmp16, label %if.else, label %land.lhs.true

land.lhs.true:                                    ; preds = %do.body
  %20 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  %call18 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp19 = icmp eq i64 %20, %call18
  br i1 %cmp19, label %if.then.21, label %if.else

if.then.21:                                       ; preds = %land.lhs.true
  call void @process_quit_flag()
  br label %if.end.24

if.else:                                          ; preds = %land.lhs.true, %do.body
  %21 = load volatile i8, i8* @pending_signals, align 1
  %tobool = trunc i8 %21 to i1
  br i1 %tobool, label %if.then.22, label %if.end.23

if.then.22:                                       ; preds = %if.else
  call void @process_pending_signals()
  br label %if.end.23

if.end.23:                                        ; preds = %if.then.22, %if.else
  br label %if.end.24

if.end.24:                                        ; preds = %if.end.23, %if.then.21
  br label %do.end

do.end:                                           ; preds = %if.end.24
  br label %for.inc

for.inc:                                          ; preds = %do.end
  %22 = load i64, i64* %tail, align 8
  %sub25 = sub nsw i64 %22, 3
  %23 = inttoptr i64 %sub25 to i8*
  %24 = bitcast i8* %23 to %struct.Lisp_Cons*
  %u26 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %24, i32 0, i32 1
  %cdr27 = bitcast %union.anon* %u26 to i64*
  %25 = load i64, i64* %cdr27, align 8
  %sub28 = sub nsw i64 %25, 3
  %26 = inttoptr i64 %sub28 to i8*
  %27 = bitcast i8* %26 to %struct.Lisp_Cons*
  %u29 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %27, i32 0, i32 1
  %cdr30 = bitcast %union.anon* %u29 to i64*
  %28 = load i64, i64* %cdr30, align 8
  store i64 %28, i64* %tail, align 8
  br label %for.cond

for.end:                                          ; preds = %land.end
  %29 = load i64, i64* %prop.addr, align 8
  %30 = load i64, i64* %val.addr, align 8
  %call31 = call i64 @list2(i64 %29, i64 %30)
  store i64 %call31, i64* %newcell, align 8
  %31 = load i64, i64* %prev, align 8
  %call32 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp33 = icmp eq i64 %31, %call32
  br i1 %cmp33, label %if.then.35, label %if.else.36

if.then.35:                                       ; preds = %for.end
  %32 = load i64, i64* %newcell, align 8
  store i64 %32, i64* %retval
  br label %return

if.else.36:                                       ; preds = %for.end
  %33 = load i64, i64* %prev, align 8
  %sub37 = sub nsw i64 %33, 3
  %34 = inttoptr i64 %sub37 to i8*
  %35 = bitcast i8* %34 to %struct.Lisp_Cons*
  %u38 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %35, i32 0, i32 1
  %cdr39 = bitcast %union.anon* %u38 to i64*
  %36 = load i64, i64* %cdr39, align 8
  %37 = load i64, i64* %newcell, align 8
  %call40 = call i64 @Fsetcdr(i64 %36, i64 %37)
  br label %if.end.41

if.end.41:                                        ; preds = %if.else.36
  %38 = load i64, i64* %plist.addr, align 8
  store i64 %38, i64* %retval
  br label %return

return:                                           ; preds = %if.end.41, %if.then.35, %if.then
  %39 = load i64, i64* %retval
  ret i64 %39
}

declare i64 @list2(i64, i64) #2

; Function Attrs: nounwind uwtable
define i64 @Feql(i64 %obj1, i64 %obj2) #1 {
entry:
  %retval = alloca i64, align 8
  %obj1.addr = alloca i64, align 8
  %obj2.addr = alloca i64, align 8
  store i64 %obj1, i64* %obj1.addr, align 8
  store i64 %obj2, i64* %obj2.addr, align 8
  %0 = load i64, i64* %obj1.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 7
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i64, i64* %obj1.addr, align 8
  %2 = load i64, i64* %obj2.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %call2 = call zeroext i1 @internal_equal(i64 %1, i64 %2, i32 0, i1 zeroext false, i64 %call)
  br i1 %call2, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  %call4 = call i64 @builtin_lisp_symbol(i32 901)
  br label %cond.end

cond.false:                                       ; preds = %if.then
  %call5 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call4, %cond.true ], [ %call5, %cond.false ]
  store i64 %cond, i64* %retval
  br label %return

if.else:                                          ; preds = %entry
  %3 = load i64, i64* %obj1.addr, align 8
  %4 = load i64, i64* %obj2.addr, align 8
  %cmp6 = icmp eq i64 %3, %4
  br i1 %cmp6, label %cond.true.8, label %cond.false.10

cond.true.8:                                      ; preds = %if.else
  %call9 = call i64 @builtin_lisp_symbol(i32 901)
  br label %cond.end.12

cond.false.10:                                    ; preds = %if.else
  %call11 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end.12

cond.end.12:                                      ; preds = %cond.false.10, %cond.true.8
  %cond13 = phi i64 [ %call9, %cond.true.8 ], [ %call11, %cond.false.10 ]
  store i64 %cond13, i64* %retval
  br label %return

return:                                           ; preds = %cond.end.12, %cond.end
  %5 = load i64, i64* %retval
  ret i64 %5
}

; Function Attrs: nounwind uwtable
define i64 @Fequal_including_properties(i64 %o1, i64 %o2) #1 {
entry:
  %o1.addr = alloca i64, align 8
  %o2.addr = alloca i64, align 8
  store i64 %o1, i64* %o1.addr, align 8
  store i64 %o2, i64* %o2.addr, align 8
  %0 = load i64, i64* %o1.addr, align 8
  %1 = load i64, i64* %o2.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %call1 = call zeroext i1 @internal_equal(i64 %0, i64 %1, i32 0, i1 zeroext true, i64 %call)
  br i1 %call1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %call2 = call i64 @builtin_lisp_symbol(i32 901)
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call2, %cond.true ], [ %call3, %cond.false ]
  ret i64 %cond
}

; Function Attrs: nounwind uwtable
define i64 @Ffillarray(i64 %array, i64 %item) #1 {
entry:
  %retval = alloca i64, align 8
  %array.addr = alloca i64, align 8
  %item.addr = alloca i64, align 8
  %size = alloca i64, align 8
  %idx = alloca i64, align 8
  %i = alloca i32, align 4
  %p = alloca i8*, align 8
  %charval = alloca i32, align 4
  %str = alloca [5 x i8], align 1
  %len = alloca i32, align 4
  %size_byte = alloca i64, align 8
  %product = alloca i64, align 8
  store i64 %array, i64* %array.addr, align 8
  store i64 %item, i64* %item.addr, align 8
  %0 = load i64, i64* %array.addr, align 8
  %call = call zeroext i1 @VECTORP(i64 %0)
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i64 0, i64* %idx, align 8
  %1 = load i64, i64* %array.addr, align 8
  %call1 = call i64 @ASIZE(i64 %1)
  store i64 %call1, i64* %size, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %2 = load i64, i64* %idx, align 8
  %3 = load i64, i64* %size, align 8
  %cmp = icmp slt i64 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load i64, i64* %array.addr, align 8
  %5 = load i64, i64* %idx, align 8
  %6 = load i64, i64* %item.addr, align 8
  call void @ASET(i64 %4, i64 %5, i64 %6)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %7 = load i64, i64* %idx, align 8
  %inc = add nsw i64 %7, 1
  store i64 %inc, i64* %idx, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end.2994

if.else:                                          ; preds = %entry
  %8 = load i64, i64* %array.addr, align 8
  %call2 = call zeroext i1 @CHAR_TABLE_P(i64 %8)
  br i1 %call2, label %if.then.3, label %if.else.10

if.then.3:                                        ; preds = %if.else
  store i32 0, i32* %i, align 4
  br label %for.cond.4

for.cond.4:                                       ; preds = %for.inc.7, %if.then.3
  %9 = load i32, i32* %i, align 4
  %cmp5 = icmp slt i32 %9, 64
  br i1 %cmp5, label %for.body.6, label %for.end.9

for.body.6:                                       ; preds = %for.cond.4
  %10 = load i64, i64* %array.addr, align 8
  %11 = load i32, i32* %i, align 4
  %conv = sext i32 %11 to i64
  %12 = load i64, i64* %item.addr, align 8
  call void @set_char_table_contents(i64 %10, i64 %conv, i64 %12)
  br label %for.inc.7

for.inc.7:                                        ; preds = %for.body.6
  %13 = load i32, i32* %i, align 4
  %inc8 = add nsw i32 %13, 1
  store i32 %inc8, i32* %i, align 4
  br label %for.cond.4

for.end.9:                                        ; preds = %for.cond.4
  %14 = load i64, i64* %array.addr, align 8
  %15 = load i64, i64* %item.addr, align 8
  call void @set_char_table_defalt(i64 %14, i64 %15)
  br label %if.end.2993

if.else.10:                                       ; preds = %if.else
  %16 = load i64, i64* %array.addr, align 8
  %call11 = call zeroext i1 @STRINGP(i64 %16)
  br i1 %call11, label %if.then.12, label %if.else.2986

if.then.12:                                       ; preds = %if.else.10
  %17 = load i64, i64* %array.addr, align 8
  %call13 = call i8* @SDATA(i64 %17)
  store i8* %call13, i8** %p, align 8
  %18 = load i64, i64* %item.addr, align 8
  %call14 = call zeroext i1 @NATNUMP(i64 %18)
  br i1 %call14, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %if.then.12
  %19 = load i64, i64* %item.addr, align 8
  %shr = ashr i64 %19, 2
  %cmp16 = icmp sle i64 %shr, 4194303
  br i1 %cmp16, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %if.then.12
  %call18 = call i64 @builtin_lisp_symbol(i32 260)
  %20 = load i64, i64* %item.addr, align 8
  %21 = call i64 @wrong_type_argument(i64 %call18, i64 %20) #8
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %22, %cond.true
  %23 = load i64, i64* %item.addr, align 8
  %shr19 = ashr i64 %23, 2
  %conv20 = trunc i64 %shr19 to i32
  store i32 %conv20, i32* %charval, align 4
  %24 = load i64, i64* %array.addr, align 8
  %call21 = call i64 @SCHARS(i64 %24)
  store i64 %call21, i64* %size, align 8
  %25 = load i64, i64* %array.addr, align 8
  %call22 = call zeroext i1 @STRING_MULTIBYTE(i64 %25)
  br i1 %call22, label %if.then.23, label %if.else.2975

if.then.23:                                       ; preds = %cond.end
  br i1 true, label %cond.true.24, label %cond.false.27

cond.true.24:                                     ; preds = %if.then.23
  %26 = load i32, i32* %charval, align 4
  %add = add i32 %26, 0
  %cmp25 = icmp ule i32 %add, 127
  br i1 %cmp25, label %cond.true.32, label %cond.false.34

cond.false.27:                                    ; preds = %if.then.23
  %27 = load i32, i32* %charval, align 4
  %conv28 = sext i32 %27 to i64
  %add29 = add i64 %conv28, 0
  %cmp30 = icmp ule i64 %add29, 127
  br i1 %cmp30, label %cond.true.32, label %cond.false.34

cond.true.32:                                     ; preds = %cond.false.27, %cond.true.24
  %28 = load i32, i32* %charval, align 4
  %conv33 = trunc i32 %28 to i8
  %arrayidx = getelementptr inbounds [5 x i8], [5 x i8]* %str, i32 0, i64 0
  store i8 %conv33, i8* %arrayidx, align 1
  br label %cond.end.80

cond.false.34:                                    ; preds = %cond.false.27, %cond.true.24
  br i1 true, label %cond.true.35, label %cond.false.39

cond.true.35:                                     ; preds = %cond.false.34
  %29 = load i32, i32* %charval, align 4
  %add36 = add i32 %29, 0
  %cmp37 = icmp ule i32 %add36, 2047
  br i1 %cmp37, label %cond.true.44, label %cond.false.51

cond.false.39:                                    ; preds = %cond.false.34
  %30 = load i32, i32* %charval, align 4
  %conv40 = sext i32 %30 to i64
  %add41 = add i64 %conv40, 0
  %cmp42 = icmp ule i64 %add41, 2047
  br i1 %cmp42, label %cond.true.44, label %cond.false.51

cond.true.44:                                     ; preds = %cond.false.39, %cond.true.35
  %31 = load i32, i32* %charval, align 4
  %shr45 = ashr i32 %31, 6
  %or = or i32 192, %shr45
  %conv46 = trunc i32 %or to i8
  %arrayidx47 = getelementptr inbounds [5 x i8], [5 x i8]* %str, i32 0, i64 0
  store i8 %conv46, i8* %arrayidx47, align 1
  %32 = load i32, i32* %charval, align 4
  %and = and i32 %32, 63
  %or48 = or i32 128, %and
  %conv49 = trunc i32 %or48 to i8
  %arrayidx50 = getelementptr inbounds [5 x i8], [5 x i8]* %str, i32 0, i64 1
  store i8 %conv49, i8* %arrayidx50, align 1
  br label %cond.end.78

cond.false.51:                                    ; preds = %cond.false.39, %cond.true.35
  br i1 true, label %cond.true.52, label %cond.false.56

cond.true.52:                                     ; preds = %cond.false.51
  %33 = load i32, i32* %charval, align 4
  %add53 = add i32 %33, 0
  %cmp54 = icmp ule i32 %add53, 65535
  br i1 %cmp54, label %cond.true.61, label %cond.false.75

cond.false.56:                                    ; preds = %cond.false.51
  %34 = load i32, i32* %charval, align 4
  %conv57 = sext i32 %34 to i64
  %add58 = add i64 %conv57, 0
  %cmp59 = icmp ule i64 %add58, 65535
  br i1 %cmp59, label %cond.true.61, label %cond.false.75

cond.true.61:                                     ; preds = %cond.false.56, %cond.true.52
  %35 = load i32, i32* %charval, align 4
  %shr62 = ashr i32 %35, 12
  %or63 = or i32 224, %shr62
  %conv64 = trunc i32 %or63 to i8
  %arrayidx65 = getelementptr inbounds [5 x i8], [5 x i8]* %str, i32 0, i64 0
  store i8 %conv64, i8* %arrayidx65, align 1
  %36 = load i32, i32* %charval, align 4
  %shr66 = ashr i32 %36, 6
  %and67 = and i32 %shr66, 63
  %or68 = or i32 128, %and67
  %conv69 = trunc i32 %or68 to i8
  %arrayidx70 = getelementptr inbounds [5 x i8], [5 x i8]* %str, i32 0, i64 1
  store i8 %conv69, i8* %arrayidx70, align 1
  %37 = load i32, i32* %charval, align 4
  %and71 = and i32 %37, 63
  %or72 = or i32 128, %and71
  %conv73 = trunc i32 %or72 to i8
  %arrayidx74 = getelementptr inbounds [5 x i8], [5 x i8]* %str, i32 0, i64 2
  store i8 %conv73, i8* %arrayidx74, align 1
  br label %cond.end.77

cond.false.75:                                    ; preds = %cond.false.56, %cond.true.52
  %38 = load i32, i32* %charval, align 4
  %arraydecay = getelementptr inbounds [5 x i8], [5 x i8]* %str, i32 0, i32 0
  %call76 = call i32 @char_string(i32 %38, i8* %arraydecay)
  br label %cond.end.77

cond.end.77:                                      ; preds = %cond.false.75, %cond.true.61
  %cond = phi i32 [ 3, %cond.true.61 ], [ %call76, %cond.false.75 ]
  br label %cond.end.78

cond.end.78:                                      ; preds = %cond.end.77, %cond.true.44
  %cond79 = phi i32 [ 2, %cond.true.44 ], [ %cond, %cond.end.77 ]
  br label %cond.end.80

cond.end.80:                                      ; preds = %cond.end.78, %cond.true.32
  %cond81 = phi i32 [ 1, %cond.true.32 ], [ %cond79, %cond.end.78 ]
  store i32 %cond81, i32* %len, align 4
  %39 = load i64, i64* %array.addr, align 8
  %call82 = call i64 @SBYTES(i64 %39)
  store i64 %call82, i64* %size_byte, align 8
  br i1 false, label %cond.true.83, label %cond.false.738

cond.true.83:                                     ; preds = %cond.end.80
  br i1 false, label %cond.true.84, label %cond.false.453

cond.true.84:                                     ; preds = %cond.true.83
  %40 = load i32, i32* %len, align 4
  %conv85 = trunc i32 %40 to i8
  %conv86 = sext i8 %conv85 to i32
  %mul = mul nsw i32 0, %conv86
  %41 = load i64, i64* %size, align 8
  %conv87 = trunc i64 %41 to i8
  %conv88 = sext i8 %conv87 to i32
  %add89 = add nsw i32 %mul, %conv88
  %mul90 = mul nsw i32 0, %add89
  %sub = sub nsw i32 %mul90, 1
  %cmp91 = icmp slt i32 %sub, 0
  br i1 %cmp91, label %cond.true.93, label %cond.false.117

cond.true.93:                                     ; preds = %cond.true.84
  %42 = load i32, i32* %len, align 4
  %conv94 = trunc i32 %42 to i8
  %conv95 = sext i8 %conv94 to i32
  %mul96 = mul nsw i32 0, %conv95
  %43 = load i64, i64* %size, align 8
  %conv97 = trunc i64 %43 to i8
  %conv98 = sext i8 %conv97 to i32
  %add99 = add nsw i32 %mul96, %conv98
  %mul100 = mul nsw i32 0, %add99
  %add101 = add nsw i32 %mul100, 0
  %neg = xor i32 %add101, -1
  %cmp102 = icmp eq i32 %neg, -1
  %conv103 = zext i1 %cmp102 to i32
  %sub104 = sub nsw i32 0, %conv103
  %44 = load i32, i32* %len, align 4
  %conv105 = trunc i32 %44 to i8
  %conv106 = sext i8 %conv105 to i32
  %mul107 = mul nsw i32 0, %conv106
  %45 = load i64, i64* %size, align 8
  %conv108 = trunc i64 %45 to i8
  %conv109 = sext i8 %conv108 to i32
  %add110 = add nsw i32 %mul107, %conv109
  %mul111 = mul nsw i32 0, %add110
  %add112 = add nsw i32 %mul111, 1
  %shl = shl i32 %add112, 30
  %sub113 = sub nsw i32 %shl, 1
  %mul114 = mul nsw i32 %sub113, 2
  %add115 = add nsw i32 %mul114, 1
  %sub116 = sub nsw i32 %sub104, %add115
  br label %cond.end.126

cond.false.117:                                   ; preds = %cond.true.84
  %46 = load i32, i32* %len, align 4
  %conv118 = trunc i32 %46 to i8
  %conv119 = sext i8 %conv118 to i32
  %mul120 = mul nsw i32 0, %conv119
  %47 = load i64, i64* %size, align 8
  %conv121 = trunc i64 %47 to i8
  %conv122 = sext i8 %conv121 to i32
  %add123 = add nsw i32 %mul120, %conv122
  %mul124 = mul nsw i32 0, %add123
  %add125 = add nsw i32 %mul124, 0
  br label %cond.end.126

cond.end.126:                                     ; preds = %cond.false.117, %cond.true.93
  %cond127 = phi i32 [ %sub116, %cond.true.93 ], [ %add125, %cond.false.117 ]
  %cmp128 = icmp eq i32 %cond127, 0
  br i1 %cmp128, label %land.lhs.true.130, label %lor.lhs.false.149

land.lhs.true.130:                                ; preds = %cond.end.126
  %48 = load i64, i64* %size, align 8
  %conv131 = trunc i64 %48 to i8
  %conv132 = sext i8 %conv131 to i32
  %cmp133 = icmp slt i32 %conv132, 0
  br i1 %cmp133, label %land.lhs.true.135, label %lor.lhs.false

land.lhs.true.135:                                ; preds = %land.lhs.true.130
  %49 = load i32, i32* %len, align 4
  %conv136 = trunc i32 %49 to i8
  %conv137 = sext i8 %conv136 to i32
  %cmp138 = icmp slt i32 0, %conv137
  br i1 %cmp138, label %cond.true.395, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true.135, %land.lhs.true.130
  %50 = load i32, i32* %len, align 4
  %conv140 = trunc i32 %50 to i8
  %conv141 = sext i8 %conv140 to i32
  %cmp142 = icmp slt i32 %conv141, 0
  br i1 %cmp142, label %land.lhs.true.144, label %lor.lhs.false.149

land.lhs.true.144:                                ; preds = %lor.lhs.false
  %51 = load i64, i64* %size, align 8
  %conv145 = trunc i64 %51 to i8
  %conv146 = sext i8 %conv145 to i32
  %cmp147 = icmp slt i32 0, %conv146
  br i1 %cmp147, label %cond.true.395, label %lor.lhs.false.149

lor.lhs.false.149:                                ; preds = %land.lhs.true.144, %lor.lhs.false, %cond.end.126
  %52 = load i32, i32* %len, align 4
  %conv150 = trunc i32 %52 to i8
  %conv151 = sext i8 %conv150 to i32
  %cmp152 = icmp slt i32 %conv151, 0
  br i1 %cmp152, label %cond.true.154, label %cond.false.261

cond.true.154:                                    ; preds = %lor.lhs.false.149
  %53 = load i64, i64* %size, align 8
  %conv155 = trunc i64 %53 to i8
  %conv156 = sext i8 %conv155 to i32
  %cmp157 = icmp slt i32 %conv156, 0
  br i1 %cmp157, label %cond.true.159, label %cond.false.200

cond.true.159:                                    ; preds = %cond.true.154
  %54 = load i64, i64* %size, align 8
  %conv160 = trunc i64 %54 to i8
  %conv161 = sext i8 %conv160 to i32
  %55 = load i32, i32* %len, align 4
  %conv162 = trunc i32 %55 to i8
  %conv163 = sext i8 %conv162 to i32
  %mul164 = mul nsw i32 0, %conv163
  %56 = load i64, i64* %size, align 8
  %conv165 = trunc i64 %56 to i8
  %conv166 = sext i8 %conv165 to i32
  %add167 = add nsw i32 %mul164, %conv166
  %mul168 = mul nsw i32 0, %add167
  %sub169 = sub nsw i32 %mul168, 1
  %cmp170 = icmp slt i32 %sub169, 0
  br i1 %cmp170, label %cond.true.172, label %cond.false.185

cond.true.172:                                    ; preds = %cond.true.159
  %57 = load i32, i32* %len, align 4
  %conv173 = trunc i32 %57 to i8
  %conv174 = sext i8 %conv173 to i32
  %mul175 = mul nsw i32 0, %conv174
  %58 = load i64, i64* %size, align 8
  %conv176 = trunc i64 %58 to i8
  %conv177 = sext i8 %conv176 to i32
  %add178 = add nsw i32 %mul175, %conv177
  %mul179 = mul nsw i32 0, %add178
  %add180 = add nsw i32 %mul179, 1
  %shl181 = shl i32 %add180, 30
  %sub182 = sub nsw i32 %shl181, 1
  %mul183 = mul nsw i32 %sub182, 2
  %add184 = add nsw i32 %mul183, 1
  br label %cond.end.194

cond.false.185:                                   ; preds = %cond.true.159
  %59 = load i32, i32* %len, align 4
  %conv186 = trunc i32 %59 to i8
  %conv187 = sext i8 %conv186 to i32
  %mul188 = mul nsw i32 0, %conv187
  %60 = load i64, i64* %size, align 8
  %conv189 = trunc i64 %60 to i8
  %conv190 = sext i8 %conv189 to i32
  %add191 = add nsw i32 %mul188, %conv190
  %mul192 = mul nsw i32 0, %add191
  %sub193 = sub nsw i32 %mul192, 1
  br label %cond.end.194

cond.end.194:                                     ; preds = %cond.false.185, %cond.true.172
  %cond195 = phi i32 [ %add184, %cond.true.172 ], [ %sub193, %cond.false.185 ]
  %61 = load i32, i32* %len, align 4
  %conv196 = trunc i32 %61 to i8
  %conv197 = sext i8 %conv196 to i32
  %div = sdiv i32 %cond195, %conv197
  %cmp198 = icmp slt i32 %conv161, %div
  br i1 %cmp198, label %cond.true.395, label %lor.lhs.false.369

cond.false.200:                                   ; preds = %cond.true.154
  %62 = load i32, i32* %len, align 4
  %conv201 = trunc i32 %62 to i8
  %conv202 = sext i8 %conv201 to i32
  %cmp203 = icmp eq i32 %conv202, -1
  br i1 %cmp203, label %cond.true.205, label %cond.false.206

cond.true.205:                                    ; preds = %cond.false.200
  br i1 false, label %cond.true.395, label %lor.lhs.false.369

cond.false.206:                                   ; preds = %cond.false.200
  %63 = load i32, i32* %len, align 4
  %conv207 = trunc i32 %63 to i8
  %conv208 = sext i8 %conv207 to i32
  %mul209 = mul nsw i32 0, %conv208
  %64 = load i64, i64* %size, align 8
  %conv210 = trunc i64 %64 to i8
  %conv211 = sext i8 %conv210 to i32
  %add212 = add nsw i32 %mul209, %conv211
  %mul213 = mul nsw i32 0, %add212
  %sub214 = sub nsw i32 %mul213, 1
  %cmp215 = icmp slt i32 %sub214, 0
  br i1 %cmp215, label %cond.true.217, label %cond.false.243

cond.true.217:                                    ; preds = %cond.false.206
  %65 = load i32, i32* %len, align 4
  %conv218 = trunc i32 %65 to i8
  %conv219 = sext i8 %conv218 to i32
  %mul220 = mul nsw i32 0, %conv219
  %66 = load i64, i64* %size, align 8
  %conv221 = trunc i64 %66 to i8
  %conv222 = sext i8 %conv221 to i32
  %add223 = add nsw i32 %mul220, %conv222
  %mul224 = mul nsw i32 0, %add223
  %add225 = add nsw i32 %mul224, 0
  %neg226 = xor i32 %add225, -1
  %cmp227 = icmp eq i32 %neg226, -1
  %conv228 = zext i1 %cmp227 to i32
  %sub229 = sub nsw i32 0, %conv228
  %67 = load i32, i32* %len, align 4
  %conv230 = trunc i32 %67 to i8
  %conv231 = sext i8 %conv230 to i32
  %mul232 = mul nsw i32 0, %conv231
  %68 = load i64, i64* %size, align 8
  %conv233 = trunc i64 %68 to i8
  %conv234 = sext i8 %conv233 to i32
  %add235 = add nsw i32 %mul232, %conv234
  %mul236 = mul nsw i32 0, %add235
  %add237 = add nsw i32 %mul236, 1
  %shl238 = shl i32 %add237, 30
  %sub239 = sub nsw i32 %shl238, 1
  %mul240 = mul nsw i32 %sub239, 2
  %add241 = add nsw i32 %mul240, 1
  %sub242 = sub nsw i32 %sub229, %add241
  br label %cond.end.252

cond.false.243:                                   ; preds = %cond.false.206
  %69 = load i32, i32* %len, align 4
  %conv244 = trunc i32 %69 to i8
  %conv245 = sext i8 %conv244 to i32
  %mul246 = mul nsw i32 0, %conv245
  %70 = load i64, i64* %size, align 8
  %conv247 = trunc i64 %70 to i8
  %conv248 = sext i8 %conv247 to i32
  %add249 = add nsw i32 %mul246, %conv248
  %mul250 = mul nsw i32 0, %add249
  %add251 = add nsw i32 %mul250, 0
  br label %cond.end.252

cond.end.252:                                     ; preds = %cond.false.243, %cond.true.217
  %cond253 = phi i32 [ %sub242, %cond.true.217 ], [ %add251, %cond.false.243 ]
  %71 = load i32, i32* %len, align 4
  %conv254 = trunc i32 %71 to i8
  %conv255 = sext i8 %conv254 to i32
  %div256 = sdiv i32 %cond253, %conv255
  %72 = load i64, i64* %size, align 8
  %conv257 = trunc i64 %72 to i8
  %conv258 = sext i8 %conv257 to i32
  %cmp259 = icmp slt i32 %div256, %conv258
  br i1 %cmp259, label %cond.true.395, label %lor.lhs.false.369

cond.false.261:                                   ; preds = %lor.lhs.false.149
  %73 = load i32, i32* %len, align 4
  %conv262 = trunc i32 %73 to i8
  %conv263 = sext i8 %conv262 to i32
  %cmp264 = icmp eq i32 %conv263, 0
  br i1 %cmp264, label %cond.true.266, label %cond.false.267

cond.true.266:                                    ; preds = %cond.false.261
  br i1 false, label %cond.true.395, label %lor.lhs.false.369

cond.false.267:                                   ; preds = %cond.false.261
  %74 = load i64, i64* %size, align 8
  %conv268 = trunc i64 %74 to i8
  %conv269 = sext i8 %conv268 to i32
  %cmp270 = icmp slt i32 %conv269, 0
  br i1 %cmp270, label %cond.true.272, label %cond.false.327

cond.true.272:                                    ; preds = %cond.false.267
  %75 = load i64, i64* %size, align 8
  %conv273 = trunc i64 %75 to i8
  %conv274 = sext i8 %conv273 to i32
  %76 = load i32, i32* %len, align 4
  %conv275 = trunc i32 %76 to i8
  %conv276 = sext i8 %conv275 to i32
  %mul277 = mul nsw i32 0, %conv276
  %77 = load i64, i64* %size, align 8
  %conv278 = trunc i64 %77 to i8
  %conv279 = sext i8 %conv278 to i32
  %add280 = add nsw i32 %mul277, %conv279
  %mul281 = mul nsw i32 0, %add280
  %sub282 = sub nsw i32 %mul281, 1
  %cmp283 = icmp slt i32 %sub282, 0
  br i1 %cmp283, label %cond.true.285, label %cond.false.311

cond.true.285:                                    ; preds = %cond.true.272
  %78 = load i32, i32* %len, align 4
  %conv286 = trunc i32 %78 to i8
  %conv287 = sext i8 %conv286 to i32
  %mul288 = mul nsw i32 0, %conv287
  %79 = load i64, i64* %size, align 8
  %conv289 = trunc i64 %79 to i8
  %conv290 = sext i8 %conv289 to i32
  %add291 = add nsw i32 %mul288, %conv290
  %mul292 = mul nsw i32 0, %add291
  %add293 = add nsw i32 %mul292, 0
  %neg294 = xor i32 %add293, -1
  %cmp295 = icmp eq i32 %neg294, -1
  %conv296 = zext i1 %cmp295 to i32
  %sub297 = sub nsw i32 0, %conv296
  %80 = load i32, i32* %len, align 4
  %conv298 = trunc i32 %80 to i8
  %conv299 = sext i8 %conv298 to i32
  %mul300 = mul nsw i32 0, %conv299
  %81 = load i64, i64* %size, align 8
  %conv301 = trunc i64 %81 to i8
  %conv302 = sext i8 %conv301 to i32
  %add303 = add nsw i32 %mul300, %conv302
  %mul304 = mul nsw i32 0, %add303
  %add305 = add nsw i32 %mul304, 1
  %shl306 = shl i32 %add305, 30
  %sub307 = sub nsw i32 %shl306, 1
  %mul308 = mul nsw i32 %sub307, 2
  %add309 = add nsw i32 %mul308, 1
  %sub310 = sub nsw i32 %sub297, %add309
  br label %cond.end.320

cond.false.311:                                   ; preds = %cond.true.272
  %82 = load i32, i32* %len, align 4
  %conv312 = trunc i32 %82 to i8
  %conv313 = sext i8 %conv312 to i32
  %mul314 = mul nsw i32 0, %conv313
  %83 = load i64, i64* %size, align 8
  %conv315 = trunc i64 %83 to i8
  %conv316 = sext i8 %conv315 to i32
  %add317 = add nsw i32 %mul314, %conv316
  %mul318 = mul nsw i32 0, %add317
  %add319 = add nsw i32 %mul318, 0
  br label %cond.end.320

cond.end.320:                                     ; preds = %cond.false.311, %cond.true.285
  %cond321 = phi i32 [ %sub310, %cond.true.285 ], [ %add319, %cond.false.311 ]
  %84 = load i32, i32* %len, align 4
  %conv322 = trunc i32 %84 to i8
  %conv323 = sext i8 %conv322 to i32
  %div324 = sdiv i32 %cond321, %conv323
  %cmp325 = icmp slt i32 %conv274, %div324
  br i1 %cmp325, label %cond.true.395, label %lor.lhs.false.369

cond.false.327:                                   ; preds = %cond.false.267
  %85 = load i32, i32* %len, align 4
  %conv328 = trunc i32 %85 to i8
  %conv329 = sext i8 %conv328 to i32
  %mul330 = mul nsw i32 0, %conv329
  %86 = load i64, i64* %size, align 8
  %conv331 = trunc i64 %86 to i8
  %conv332 = sext i8 %conv331 to i32
  %add333 = add nsw i32 %mul330, %conv332
  %mul334 = mul nsw i32 0, %add333
  %sub335 = sub nsw i32 %mul334, 1
  %cmp336 = icmp slt i32 %sub335, 0
  br i1 %cmp336, label %cond.true.338, label %cond.false.351

cond.true.338:                                    ; preds = %cond.false.327
  %87 = load i32, i32* %len, align 4
  %conv339 = trunc i32 %87 to i8
  %conv340 = sext i8 %conv339 to i32
  %mul341 = mul nsw i32 0, %conv340
  %88 = load i64, i64* %size, align 8
  %conv342 = trunc i64 %88 to i8
  %conv343 = sext i8 %conv342 to i32
  %add344 = add nsw i32 %mul341, %conv343
  %mul345 = mul nsw i32 0, %add344
  %add346 = add nsw i32 %mul345, 1
  %shl347 = shl i32 %add346, 30
  %sub348 = sub nsw i32 %shl347, 1
  %mul349 = mul nsw i32 %sub348, 2
  %add350 = add nsw i32 %mul349, 1
  br label %cond.end.360

cond.false.351:                                   ; preds = %cond.false.327
  %89 = load i32, i32* %len, align 4
  %conv352 = trunc i32 %89 to i8
  %conv353 = sext i8 %conv352 to i32
  %mul354 = mul nsw i32 0, %conv353
  %90 = load i64, i64* %size, align 8
  %conv355 = trunc i64 %90 to i8
  %conv356 = sext i8 %conv355 to i32
  %add357 = add nsw i32 %mul354, %conv356
  %mul358 = mul nsw i32 0, %add357
  %sub359 = sub nsw i32 %mul358, 1
  br label %cond.end.360

cond.end.360:                                     ; preds = %cond.false.351, %cond.true.338
  %cond361 = phi i32 [ %add350, %cond.true.338 ], [ %sub359, %cond.false.351 ]
  %91 = load i32, i32* %len, align 4
  %conv362 = trunc i32 %91 to i8
  %conv363 = sext i8 %conv362 to i32
  %div364 = sdiv i32 %cond361, %conv363
  %92 = load i64, i64* %size, align 8
  %conv365 = trunc i64 %92 to i8
  %conv366 = sext i8 %conv365 to i32
  %cmp367 = icmp slt i32 %div364, %conv366
  br i1 %cmp367, label %cond.true.395, label %lor.lhs.false.369

lor.lhs.false.369:                                ; preds = %cond.end.360, %cond.end.320, %cond.true.266, %cond.end.252, %cond.true.205, %cond.end.194
  %93 = load i64, i64* %size, align 8
  %conv370 = trunc i64 %93 to i8
  %conv371 = sext i8 %conv370 to i32
  %94 = load i32, i32* %len, align 4
  %conv372 = trunc i32 %94 to i8
  %conv373 = sext i8 %conv372 to i32
  %mul374 = mul nsw i32 %conv371, %conv373
  %mul375 = mul nsw i32 0, %mul374
  %sub376 = sub nsw i32 %mul375, 1
  %cmp377 = icmp slt i32 %sub376, 0
  br i1 %cmp377, label %land.lhs.true.379, label %lor.lhs.false.387

land.lhs.true.379:                                ; preds = %lor.lhs.false.369
  %95 = load i64, i64* %size, align 8
  %conv380 = trunc i64 %95 to i8
  %conv381 = sext i8 %conv380 to i32
  %96 = load i32, i32* %len, align 4
  %conv382 = trunc i32 %96 to i8
  %conv383 = sext i8 %conv382 to i32
  %mul384 = mul nsw i32 %conv381, %conv383
  %cmp385 = icmp slt i32 %mul384, -128
  br i1 %cmp385, label %cond.true.395, label %lor.lhs.false.387

lor.lhs.false.387:                                ; preds = %land.lhs.true.379, %lor.lhs.false.369
  %97 = load i64, i64* %size, align 8
  %conv388 = trunc i64 %97 to i8
  %conv389 = sext i8 %conv388 to i32
  %98 = load i32, i32* %len, align 4
  %conv390 = trunc i32 %98 to i8
  %conv391 = sext i8 %conv390 to i32
  %mul392 = mul nsw i32 %conv389, %conv391
  %cmp393 = icmp slt i32 127, %mul392
  br i1 %cmp393, label %cond.true.395, label %cond.false.424

cond.true.395:                                    ; preds = %lor.lhs.false.387, %land.lhs.true.379, %cond.end.360, %cond.end.320, %cond.true.266, %cond.end.252, %cond.true.205, %cond.end.194, %land.lhs.true.144, %land.lhs.true.135
  %99 = load i64, i64* %size, align 8
  %conv396 = trunc i64 %99 to i8
  %conv397 = zext i8 %conv396 to i32
  %100 = load i32, i32* %len, align 4
  %conv398 = trunc i32 %100 to i8
  %conv399 = zext i8 %conv398 to i32
  %mul400 = mul nsw i32 %conv397, %conv399
  %cmp401 = icmp sle i32 %mul400, 127
  br i1 %cmp401, label %cond.true.403, label %cond.false.411

cond.true.403:                                    ; preds = %cond.true.395
  %101 = load i64, i64* %size, align 8
  %conv404 = trunc i64 %101 to i8
  %conv405 = zext i8 %conv404 to i32
  %102 = load i32, i32* %len, align 4
  %conv406 = trunc i32 %102 to i8
  %conv407 = zext i8 %conv406 to i32
  %mul408 = mul nsw i32 %conv405, %conv407
  %conv409 = trunc i32 %mul408 to i8
  %conv410 = sext i8 %conv409 to i32
  br label %cond.end.421

cond.false.411:                                   ; preds = %cond.true.395
  %103 = load i64, i64* %size, align 8
  %conv412 = trunc i64 %103 to i8
  %conv413 = zext i8 %conv412 to i32
  %104 = load i32, i32* %len, align 4
  %conv414 = trunc i32 %104 to i8
  %conv415 = zext i8 %conv414 to i32
  %mul416 = mul nsw i32 %conv413, %conv415
  %sub417 = sub nsw i32 %mul416, -128
  %conv418 = trunc i32 %sub417 to i8
  %conv419 = sext i8 %conv418 to i32
  %add420 = add nsw i32 %conv419, -128
  br label %cond.end.421

cond.end.421:                                     ; preds = %cond.false.411, %cond.true.403
  %cond422 = phi i32 [ %conv410, %cond.true.403 ], [ %add420, %cond.false.411 ]
  %conv423 = sext i32 %cond422 to i64
  store i64 %conv423, i64* %product, align 8
  br i1 true, label %if.then.2965, label %lor.lhs.false.2962

cond.false.424:                                   ; preds = %lor.lhs.false.387
  %105 = load i64, i64* %size, align 8
  %conv425 = trunc i64 %105 to i8
  %conv426 = zext i8 %conv425 to i32
  %106 = load i32, i32* %len, align 4
  %conv427 = trunc i32 %106 to i8
  %conv428 = zext i8 %conv427 to i32
  %mul429 = mul nsw i32 %conv426, %conv428
  %cmp430 = icmp sle i32 %mul429, 127
  br i1 %cmp430, label %cond.true.432, label %cond.false.440

cond.true.432:                                    ; preds = %cond.false.424
  %107 = load i64, i64* %size, align 8
  %conv433 = trunc i64 %107 to i8
  %conv434 = zext i8 %conv433 to i32
  %108 = load i32, i32* %len, align 4
  %conv435 = trunc i32 %108 to i8
  %conv436 = zext i8 %conv435 to i32
  %mul437 = mul nsw i32 %conv434, %conv436
  %conv438 = trunc i32 %mul437 to i8
  %conv439 = sext i8 %conv438 to i32
  br label %cond.end.450

cond.false.440:                                   ; preds = %cond.false.424
  %109 = load i64, i64* %size, align 8
  %conv441 = trunc i64 %109 to i8
  %conv442 = zext i8 %conv441 to i32
  %110 = load i32, i32* %len, align 4
  %conv443 = trunc i32 %110 to i8
  %conv444 = zext i8 %conv443 to i32
  %mul445 = mul nsw i32 %conv442, %conv444
  %sub446 = sub nsw i32 %mul445, -128
  %conv447 = trunc i32 %sub446 to i8
  %conv448 = sext i8 %conv447 to i32
  %add449 = add nsw i32 %conv448, -128
  br label %cond.end.450

cond.end.450:                                     ; preds = %cond.false.440, %cond.true.432
  %cond451 = phi i32 [ %conv439, %cond.true.432 ], [ %add449, %cond.false.440 ]
  %conv452 = sext i32 %cond451 to i64
  store i64 %conv452, i64* %product, align 8
  br i1 false, label %if.then.2965, label %lor.lhs.false.2962

cond.false.453:                                   ; preds = %cond.true.83
  %111 = load i32, i32* %len, align 4
  %mul454 = mul nsw i32 0, %111
  %conv455 = sext i32 %mul454 to i64
  %112 = load i64, i64* %size, align 8
  %add456 = add nsw i64 %conv455, %112
  %mul457 = mul nsw i64 0, %add456
  %sub458 = sub nsw i64 %mul457, 1
  %cmp459 = icmp slt i64 %sub458, 0
  br i1 %cmp459, label %cond.true.461, label %cond.false.482

cond.true.461:                                    ; preds = %cond.false.453
  %113 = load i32, i32* %len, align 4
  %mul462 = mul nsw i32 0, %113
  %conv463 = sext i32 %mul462 to i64
  %114 = load i64, i64* %size, align 8
  %add464 = add nsw i64 %conv463, %114
  %mul465 = mul nsw i64 0, %add464
  %add466 = add nsw i64 %mul465, 0
  %neg467 = xor i64 %add466, -1
  %cmp468 = icmp eq i64 %neg467, -1
  %conv469 = zext i1 %cmp468 to i32
  %sub470 = sub nsw i32 0, %conv469
  %conv471 = sext i32 %sub470 to i64
  %115 = load i32, i32* %len, align 4
  %mul472 = mul nsw i32 0, %115
  %conv473 = sext i32 %mul472 to i64
  %116 = load i64, i64* %size, align 8
  %add474 = add nsw i64 %conv473, %116
  %mul475 = mul nsw i64 0, %add474
  %add476 = add nsw i64 %mul475, 1
  %shl477 = shl i64 %add476, 62
  %sub478 = sub nsw i64 %shl477, 1
  %mul479 = mul nsw i64 %sub478, 2
  %add480 = add nsw i64 %mul479, 1
  %sub481 = sub nsw i64 %conv471, %add480
  br label %cond.end.488

cond.false.482:                                   ; preds = %cond.false.453
  %117 = load i32, i32* %len, align 4
  %mul483 = mul nsw i32 0, %117
  %conv484 = sext i32 %mul483 to i64
  %118 = load i64, i64* %size, align 8
  %add485 = add nsw i64 %conv484, %118
  %mul486 = mul nsw i64 0, %add485
  %add487 = add nsw i64 %mul486, 0
  br label %cond.end.488

cond.end.488:                                     ; preds = %cond.false.482, %cond.true.461
  %cond489 = phi i64 [ %sub481, %cond.true.461 ], [ %add487, %cond.false.482 ]
  %cmp490 = icmp eq i64 %cond489, 0
  br i1 %cmp490, label %land.lhs.true.492, label %lor.lhs.false.504

land.lhs.true.492:                                ; preds = %cond.end.488
  %119 = load i64, i64* %size, align 8
  %cmp493 = icmp slt i64 %119, 0
  br i1 %cmp493, label %land.lhs.true.495, label %lor.lhs.false.498

land.lhs.true.495:                                ; preds = %land.lhs.true.492
  %120 = load i32, i32* %len, align 4
  %cmp496 = icmp slt i32 0, %120
  br i1 %cmp496, label %cond.true.680, label %lor.lhs.false.498

lor.lhs.false.498:                                ; preds = %land.lhs.true.495, %land.lhs.true.492
  %121 = load i32, i32* %len, align 4
  %cmp499 = icmp slt i32 %121, 0
  br i1 %cmp499, label %land.lhs.true.501, label %lor.lhs.false.504

land.lhs.true.501:                                ; preds = %lor.lhs.false.498
  %122 = load i64, i64* %size, align 8
  %cmp502 = icmp slt i64 0, %122
  br i1 %cmp502, label %cond.true.680, label %lor.lhs.false.504

lor.lhs.false.504:                                ; preds = %land.lhs.true.501, %lor.lhs.false.498, %cond.end.488
  %123 = load i32, i32* %len, align 4
  %cmp505 = icmp slt i32 %123, 0
  br i1 %cmp505, label %cond.true.507, label %cond.false.585

cond.true.507:                                    ; preds = %lor.lhs.false.504
  %124 = load i64, i64* %size, align 8
  %cmp508 = icmp slt i64 %124, 0
  br i1 %cmp508, label %cond.true.510, label %cond.false.540

cond.true.510:                                    ; preds = %cond.true.507
  %125 = load i64, i64* %size, align 8
  %126 = load i32, i32* %len, align 4
  %mul511 = mul nsw i32 0, %126
  %conv512 = sext i32 %mul511 to i64
  %127 = load i64, i64* %size, align 8
  %add513 = add nsw i64 %conv512, %127
  %mul514 = mul nsw i64 0, %add513
  %sub515 = sub nsw i64 %mul514, 1
  %cmp516 = icmp slt i64 %sub515, 0
  br i1 %cmp516, label %cond.true.518, label %cond.false.528

cond.true.518:                                    ; preds = %cond.true.510
  %128 = load i32, i32* %len, align 4
  %mul519 = mul nsw i32 0, %128
  %conv520 = sext i32 %mul519 to i64
  %129 = load i64, i64* %size, align 8
  %add521 = add nsw i64 %conv520, %129
  %mul522 = mul nsw i64 0, %add521
  %add523 = add nsw i64 %mul522, 1
  %shl524 = shl i64 %add523, 62
  %sub525 = sub nsw i64 %shl524, 1
  %mul526 = mul nsw i64 %sub525, 2
  %add527 = add nsw i64 %mul526, 1
  br label %cond.end.534

cond.false.528:                                   ; preds = %cond.true.510
  %130 = load i32, i32* %len, align 4
  %mul529 = mul nsw i32 0, %130
  %conv530 = sext i32 %mul529 to i64
  %131 = load i64, i64* %size, align 8
  %add531 = add nsw i64 %conv530, %131
  %mul532 = mul nsw i64 0, %add531
  %sub533 = sub nsw i64 %mul532, 1
  br label %cond.end.534

cond.end.534:                                     ; preds = %cond.false.528, %cond.true.518
  %cond535 = phi i64 [ %add527, %cond.true.518 ], [ %sub533, %cond.false.528 ]
  %132 = load i32, i32* %len, align 4
  %conv536 = sext i32 %132 to i64
  %div537 = sdiv i64 %cond535, %conv536
  %cmp538 = icmp slt i64 %125, %div537
  br i1 %cmp538, label %cond.true.680, label %lor.lhs.false.663

cond.false.540:                                   ; preds = %cond.true.507
  %133 = load i32, i32* %len, align 4
  %cmp541 = icmp eq i32 %133, -1
  br i1 %cmp541, label %cond.true.543, label %cond.false.544

cond.true.543:                                    ; preds = %cond.false.540
  br i1 false, label %cond.true.680, label %lor.lhs.false.663

cond.false.544:                                   ; preds = %cond.false.540
  %134 = load i32, i32* %len, align 4
  %mul545 = mul nsw i32 0, %134
  %conv546 = sext i32 %mul545 to i64
  %135 = load i64, i64* %size, align 8
  %add547 = add nsw i64 %conv546, %135
  %mul548 = mul nsw i64 0, %add547
  %sub549 = sub nsw i64 %mul548, 1
  %cmp550 = icmp slt i64 %sub549, 0
  br i1 %cmp550, label %cond.true.552, label %cond.false.573

cond.true.552:                                    ; preds = %cond.false.544
  %136 = load i32, i32* %len, align 4
  %mul553 = mul nsw i32 0, %136
  %conv554 = sext i32 %mul553 to i64
  %137 = load i64, i64* %size, align 8
  %add555 = add nsw i64 %conv554, %137
  %mul556 = mul nsw i64 0, %add555
  %add557 = add nsw i64 %mul556, 0
  %neg558 = xor i64 %add557, -1
  %cmp559 = icmp eq i64 %neg558, -1
  %conv560 = zext i1 %cmp559 to i32
  %sub561 = sub nsw i32 0, %conv560
  %conv562 = sext i32 %sub561 to i64
  %138 = load i32, i32* %len, align 4
  %mul563 = mul nsw i32 0, %138
  %conv564 = sext i32 %mul563 to i64
  %139 = load i64, i64* %size, align 8
  %add565 = add nsw i64 %conv564, %139
  %mul566 = mul nsw i64 0, %add565
  %add567 = add nsw i64 %mul566, 1
  %shl568 = shl i64 %add567, 62
  %sub569 = sub nsw i64 %shl568, 1
  %mul570 = mul nsw i64 %sub569, 2
  %add571 = add nsw i64 %mul570, 1
  %sub572 = sub nsw i64 %conv562, %add571
  br label %cond.end.579

cond.false.573:                                   ; preds = %cond.false.544
  %140 = load i32, i32* %len, align 4
  %mul574 = mul nsw i32 0, %140
  %conv575 = sext i32 %mul574 to i64
  %141 = load i64, i64* %size, align 8
  %add576 = add nsw i64 %conv575, %141
  %mul577 = mul nsw i64 0, %add576
  %add578 = add nsw i64 %mul577, 0
  br label %cond.end.579

cond.end.579:                                     ; preds = %cond.false.573, %cond.true.552
  %cond580 = phi i64 [ %sub572, %cond.true.552 ], [ %add578, %cond.false.573 ]
  %142 = load i32, i32* %len, align 4
  %conv581 = sext i32 %142 to i64
  %div582 = sdiv i64 %cond580, %conv581
  %143 = load i64, i64* %size, align 8
  %cmp583 = icmp slt i64 %div582, %143
  br i1 %cmp583, label %cond.true.680, label %lor.lhs.false.663

cond.false.585:                                   ; preds = %lor.lhs.false.504
  %144 = load i32, i32* %len, align 4
  %cmp586 = icmp eq i32 %144, 0
  br i1 %cmp586, label %cond.true.588, label %cond.false.589

cond.true.588:                                    ; preds = %cond.false.585
  br i1 false, label %cond.true.680, label %lor.lhs.false.663

cond.false.589:                                   ; preds = %cond.false.585
  %145 = load i64, i64* %size, align 8
  %cmp590 = icmp slt i64 %145, 0
  br i1 %cmp590, label %cond.true.592, label %cond.false.633

cond.true.592:                                    ; preds = %cond.false.589
  %146 = load i64, i64* %size, align 8
  %147 = load i32, i32* %len, align 4
  %mul593 = mul nsw i32 0, %147
  %conv594 = sext i32 %mul593 to i64
  %148 = load i64, i64* %size, align 8
  %add595 = add nsw i64 %conv594, %148
  %mul596 = mul nsw i64 0, %add595
  %sub597 = sub nsw i64 %mul596, 1
  %cmp598 = icmp slt i64 %sub597, 0
  br i1 %cmp598, label %cond.true.600, label %cond.false.621

cond.true.600:                                    ; preds = %cond.true.592
  %149 = load i32, i32* %len, align 4
  %mul601 = mul nsw i32 0, %149
  %conv602 = sext i32 %mul601 to i64
  %150 = load i64, i64* %size, align 8
  %add603 = add nsw i64 %conv602, %150
  %mul604 = mul nsw i64 0, %add603
  %add605 = add nsw i64 %mul604, 0
  %neg606 = xor i64 %add605, -1
  %cmp607 = icmp eq i64 %neg606, -1
  %conv608 = zext i1 %cmp607 to i32
  %sub609 = sub nsw i32 0, %conv608
  %conv610 = sext i32 %sub609 to i64
  %151 = load i32, i32* %len, align 4
  %mul611 = mul nsw i32 0, %151
  %conv612 = sext i32 %mul611 to i64
  %152 = load i64, i64* %size, align 8
  %add613 = add nsw i64 %conv612, %152
  %mul614 = mul nsw i64 0, %add613
  %add615 = add nsw i64 %mul614, 1
  %shl616 = shl i64 %add615, 62
  %sub617 = sub nsw i64 %shl616, 1
  %mul618 = mul nsw i64 %sub617, 2
  %add619 = add nsw i64 %mul618, 1
  %sub620 = sub nsw i64 %conv610, %add619
  br label %cond.end.627

cond.false.621:                                   ; preds = %cond.true.592
  %153 = load i32, i32* %len, align 4
  %mul622 = mul nsw i32 0, %153
  %conv623 = sext i32 %mul622 to i64
  %154 = load i64, i64* %size, align 8
  %add624 = add nsw i64 %conv623, %154
  %mul625 = mul nsw i64 0, %add624
  %add626 = add nsw i64 %mul625, 0
  br label %cond.end.627

cond.end.627:                                     ; preds = %cond.false.621, %cond.true.600
  %cond628 = phi i64 [ %sub620, %cond.true.600 ], [ %add626, %cond.false.621 ]
  %155 = load i32, i32* %len, align 4
  %conv629 = sext i32 %155 to i64
  %div630 = sdiv i64 %cond628, %conv629
  %cmp631 = icmp slt i64 %146, %div630
  br i1 %cmp631, label %cond.true.680, label %lor.lhs.false.663

cond.false.633:                                   ; preds = %cond.false.589
  %156 = load i32, i32* %len, align 4
  %mul634 = mul nsw i32 0, %156
  %conv635 = sext i32 %mul634 to i64
  %157 = load i64, i64* %size, align 8
  %add636 = add nsw i64 %conv635, %157
  %mul637 = mul nsw i64 0, %add636
  %sub638 = sub nsw i64 %mul637, 1
  %cmp639 = icmp slt i64 %sub638, 0
  br i1 %cmp639, label %cond.true.641, label %cond.false.651

cond.true.641:                                    ; preds = %cond.false.633
  %158 = load i32, i32* %len, align 4
  %mul642 = mul nsw i32 0, %158
  %conv643 = sext i32 %mul642 to i64
  %159 = load i64, i64* %size, align 8
  %add644 = add nsw i64 %conv643, %159
  %mul645 = mul nsw i64 0, %add644
  %add646 = add nsw i64 %mul645, 1
  %shl647 = shl i64 %add646, 62
  %sub648 = sub nsw i64 %shl647, 1
  %mul649 = mul nsw i64 %sub648, 2
  %add650 = add nsw i64 %mul649, 1
  br label %cond.end.657

cond.false.651:                                   ; preds = %cond.false.633
  %160 = load i32, i32* %len, align 4
  %mul652 = mul nsw i32 0, %160
  %conv653 = sext i32 %mul652 to i64
  %161 = load i64, i64* %size, align 8
  %add654 = add nsw i64 %conv653, %161
  %mul655 = mul nsw i64 0, %add654
  %sub656 = sub nsw i64 %mul655, 1
  br label %cond.end.657

cond.end.657:                                     ; preds = %cond.false.651, %cond.true.641
  %cond658 = phi i64 [ %add650, %cond.true.641 ], [ %sub656, %cond.false.651 ]
  %162 = load i32, i32* %len, align 4
  %conv659 = sext i32 %162 to i64
  %div660 = sdiv i64 %cond658, %conv659
  %163 = load i64, i64* %size, align 8
  %cmp661 = icmp slt i64 %div660, %163
  br i1 %cmp661, label %cond.true.680, label %lor.lhs.false.663

lor.lhs.false.663:                                ; preds = %cond.end.657, %cond.end.627, %cond.true.588, %cond.end.579, %cond.true.543, %cond.end.534
  %164 = load i64, i64* %size, align 8
  %165 = load i32, i32* %len, align 4
  %conv664 = sext i32 %165 to i64
  %mul665 = mul nsw i64 %164, %conv664
  %mul666 = mul nsw i64 0, %mul665
  %sub667 = sub nsw i64 %mul666, 1
  %cmp668 = icmp slt i64 %sub667, 0
  br i1 %cmp668, label %land.lhs.true.670, label %lor.lhs.false.675

land.lhs.true.670:                                ; preds = %lor.lhs.false.663
  %166 = load i64, i64* %size, align 8
  %167 = load i32, i32* %len, align 4
  %conv671 = sext i32 %167 to i64
  %mul672 = mul nsw i64 %166, %conv671
  %cmp673 = icmp slt i64 %mul672, -128
  br i1 %cmp673, label %cond.true.680, label %lor.lhs.false.675

lor.lhs.false.675:                                ; preds = %land.lhs.true.670, %lor.lhs.false.663
  %168 = load i64, i64* %size, align 8
  %169 = load i32, i32* %len, align 4
  %conv676 = sext i32 %169 to i64
  %mul677 = mul nsw i64 %168, %conv676
  %cmp678 = icmp slt i64 127, %mul677
  br i1 %cmp678, label %cond.true.680, label %cond.false.709

cond.true.680:                                    ; preds = %lor.lhs.false.675, %land.lhs.true.670, %cond.end.657, %cond.end.627, %cond.true.588, %cond.end.579, %cond.true.543, %cond.end.534, %land.lhs.true.501, %land.lhs.true.495
  %170 = load i64, i64* %size, align 8
  %conv681 = trunc i64 %170 to i8
  %conv682 = zext i8 %conv681 to i32
  %171 = load i32, i32* %len, align 4
  %conv683 = trunc i32 %171 to i8
  %conv684 = zext i8 %conv683 to i32
  %mul685 = mul nsw i32 %conv682, %conv684
  %cmp686 = icmp sle i32 %mul685, 127
  br i1 %cmp686, label %cond.true.688, label %cond.false.696

cond.true.688:                                    ; preds = %cond.true.680
  %172 = load i64, i64* %size, align 8
  %conv689 = trunc i64 %172 to i8
  %conv690 = zext i8 %conv689 to i32
  %173 = load i32, i32* %len, align 4
  %conv691 = trunc i32 %173 to i8
  %conv692 = zext i8 %conv691 to i32
  %mul693 = mul nsw i32 %conv690, %conv692
  %conv694 = trunc i32 %mul693 to i8
  %conv695 = sext i8 %conv694 to i32
  br label %cond.end.706

cond.false.696:                                   ; preds = %cond.true.680
  %174 = load i64, i64* %size, align 8
  %conv697 = trunc i64 %174 to i8
  %conv698 = zext i8 %conv697 to i32
  %175 = load i32, i32* %len, align 4
  %conv699 = trunc i32 %175 to i8
  %conv700 = zext i8 %conv699 to i32
  %mul701 = mul nsw i32 %conv698, %conv700
  %sub702 = sub nsw i32 %mul701, -128
  %conv703 = trunc i32 %sub702 to i8
  %conv704 = sext i8 %conv703 to i32
  %add705 = add nsw i32 %conv704, -128
  br label %cond.end.706

cond.end.706:                                     ; preds = %cond.false.696, %cond.true.688
  %cond707 = phi i32 [ %conv695, %cond.true.688 ], [ %add705, %cond.false.696 ]
  %conv708 = sext i32 %cond707 to i64
  store i64 %conv708, i64* %product, align 8
  br i1 true, label %if.then.2965, label %lor.lhs.false.2962

cond.false.709:                                   ; preds = %lor.lhs.false.675
  %176 = load i64, i64* %size, align 8
  %conv710 = trunc i64 %176 to i8
  %conv711 = zext i8 %conv710 to i32
  %177 = load i32, i32* %len, align 4
  %conv712 = trunc i32 %177 to i8
  %conv713 = zext i8 %conv712 to i32
  %mul714 = mul nsw i32 %conv711, %conv713
  %cmp715 = icmp sle i32 %mul714, 127
  br i1 %cmp715, label %cond.true.717, label %cond.false.725

cond.true.717:                                    ; preds = %cond.false.709
  %178 = load i64, i64* %size, align 8
  %conv718 = trunc i64 %178 to i8
  %conv719 = zext i8 %conv718 to i32
  %179 = load i32, i32* %len, align 4
  %conv720 = trunc i32 %179 to i8
  %conv721 = zext i8 %conv720 to i32
  %mul722 = mul nsw i32 %conv719, %conv721
  %conv723 = trunc i32 %mul722 to i8
  %conv724 = sext i8 %conv723 to i32
  br label %cond.end.735

cond.false.725:                                   ; preds = %cond.false.709
  %180 = load i64, i64* %size, align 8
  %conv726 = trunc i64 %180 to i8
  %conv727 = zext i8 %conv726 to i32
  %181 = load i32, i32* %len, align 4
  %conv728 = trunc i32 %181 to i8
  %conv729 = zext i8 %conv728 to i32
  %mul730 = mul nsw i32 %conv727, %conv729
  %sub731 = sub nsw i32 %mul730, -128
  %conv732 = trunc i32 %sub731 to i8
  %conv733 = sext i8 %conv732 to i32
  %add734 = add nsw i32 %conv733, -128
  br label %cond.end.735

cond.end.735:                                     ; preds = %cond.false.725, %cond.true.717
  %cond736 = phi i32 [ %conv724, %cond.true.717 ], [ %add734, %cond.false.725 ]
  %conv737 = sext i32 %cond736 to i64
  store i64 %conv737, i64* %product, align 8
  br i1 false, label %if.then.2965, label %lor.lhs.false.2962

cond.false.738:                                   ; preds = %cond.end.80
  br i1 false, label %cond.true.739, label %cond.false.1400

cond.true.739:                                    ; preds = %cond.false.738
  br i1 false, label %cond.true.740, label %cond.false.1115

cond.true.740:                                    ; preds = %cond.true.739
  %182 = load i32, i32* %len, align 4
  %conv741 = trunc i32 %182 to i16
  %conv742 = sext i16 %conv741 to i32
  %mul743 = mul nsw i32 0, %conv742
  %183 = load i64, i64* %size, align 8
  %conv744 = trunc i64 %183 to i16
  %conv745 = sext i16 %conv744 to i32
  %add746 = add nsw i32 %mul743, %conv745
  %mul747 = mul nsw i32 0, %add746
  %sub748 = sub nsw i32 %mul747, 1
  %cmp749 = icmp slt i32 %sub748, 0
  br i1 %cmp749, label %cond.true.751, label %cond.false.777

cond.true.751:                                    ; preds = %cond.true.740
  %184 = load i32, i32* %len, align 4
  %conv752 = trunc i32 %184 to i16
  %conv753 = sext i16 %conv752 to i32
  %mul754 = mul nsw i32 0, %conv753
  %185 = load i64, i64* %size, align 8
  %conv755 = trunc i64 %185 to i16
  %conv756 = sext i16 %conv755 to i32
  %add757 = add nsw i32 %mul754, %conv756
  %mul758 = mul nsw i32 0, %add757
  %add759 = add nsw i32 %mul758, 0
  %neg760 = xor i32 %add759, -1
  %cmp761 = icmp eq i32 %neg760, -1
  %conv762 = zext i1 %cmp761 to i32
  %sub763 = sub nsw i32 0, %conv762
  %186 = load i32, i32* %len, align 4
  %conv764 = trunc i32 %186 to i16
  %conv765 = sext i16 %conv764 to i32
  %mul766 = mul nsw i32 0, %conv765
  %187 = load i64, i64* %size, align 8
  %conv767 = trunc i64 %187 to i16
  %conv768 = sext i16 %conv767 to i32
  %add769 = add nsw i32 %mul766, %conv768
  %mul770 = mul nsw i32 0, %add769
  %add771 = add nsw i32 %mul770, 1
  %shl772 = shl i32 %add771, 30
  %sub773 = sub nsw i32 %shl772, 1
  %mul774 = mul nsw i32 %sub773, 2
  %add775 = add nsw i32 %mul774, 1
  %sub776 = sub nsw i32 %sub763, %add775
  br label %cond.end.786

cond.false.777:                                   ; preds = %cond.true.740
  %188 = load i32, i32* %len, align 4
  %conv778 = trunc i32 %188 to i16
  %conv779 = sext i16 %conv778 to i32
  %mul780 = mul nsw i32 0, %conv779
  %189 = load i64, i64* %size, align 8
  %conv781 = trunc i64 %189 to i16
  %conv782 = sext i16 %conv781 to i32
  %add783 = add nsw i32 %mul780, %conv782
  %mul784 = mul nsw i32 0, %add783
  %add785 = add nsw i32 %mul784, 0
  br label %cond.end.786

cond.end.786:                                     ; preds = %cond.false.777, %cond.true.751
  %cond787 = phi i32 [ %sub776, %cond.true.751 ], [ %add785, %cond.false.777 ]
  %cmp788 = icmp eq i32 %cond787, 0
  br i1 %cmp788, label %land.lhs.true.790, label %lor.lhs.false.810

land.lhs.true.790:                                ; preds = %cond.end.786
  %190 = load i64, i64* %size, align 8
  %conv791 = trunc i64 %190 to i16
  %conv792 = sext i16 %conv791 to i32
  %cmp793 = icmp slt i32 %conv792, 0
  br i1 %cmp793, label %land.lhs.true.795, label %lor.lhs.false.800

land.lhs.true.795:                                ; preds = %land.lhs.true.790
  %191 = load i32, i32* %len, align 4
  %conv796 = trunc i32 %191 to i16
  %conv797 = sext i16 %conv796 to i32
  %cmp798 = icmp slt i32 0, %conv797
  br i1 %cmp798, label %cond.true.1057, label %lor.lhs.false.800

lor.lhs.false.800:                                ; preds = %land.lhs.true.795, %land.lhs.true.790
  %192 = load i32, i32* %len, align 4
  %conv801 = trunc i32 %192 to i16
  %conv802 = sext i16 %conv801 to i32
  %cmp803 = icmp slt i32 %conv802, 0
  br i1 %cmp803, label %land.lhs.true.805, label %lor.lhs.false.810

land.lhs.true.805:                                ; preds = %lor.lhs.false.800
  %193 = load i64, i64* %size, align 8
  %conv806 = trunc i64 %193 to i16
  %conv807 = sext i16 %conv806 to i32
  %cmp808 = icmp slt i32 0, %conv807
  br i1 %cmp808, label %cond.true.1057, label %lor.lhs.false.810

lor.lhs.false.810:                                ; preds = %land.lhs.true.805, %lor.lhs.false.800, %cond.end.786
  %194 = load i32, i32* %len, align 4
  %conv811 = trunc i32 %194 to i16
  %conv812 = sext i16 %conv811 to i32
  %cmp813 = icmp slt i32 %conv812, 0
  br i1 %cmp813, label %cond.true.815, label %cond.false.923

cond.true.815:                                    ; preds = %lor.lhs.false.810
  %195 = load i64, i64* %size, align 8
  %conv816 = trunc i64 %195 to i16
  %conv817 = sext i16 %conv816 to i32
  %cmp818 = icmp slt i32 %conv817, 0
  br i1 %cmp818, label %cond.true.820, label %cond.false.862

cond.true.820:                                    ; preds = %cond.true.815
  %196 = load i64, i64* %size, align 8
  %conv821 = trunc i64 %196 to i16
  %conv822 = sext i16 %conv821 to i32
  %197 = load i32, i32* %len, align 4
  %conv823 = trunc i32 %197 to i16
  %conv824 = sext i16 %conv823 to i32
  %mul825 = mul nsw i32 0, %conv824
  %198 = load i64, i64* %size, align 8
  %conv826 = trunc i64 %198 to i16
  %conv827 = sext i16 %conv826 to i32
  %add828 = add nsw i32 %mul825, %conv827
  %mul829 = mul nsw i32 0, %add828
  %sub830 = sub nsw i32 %mul829, 1
  %cmp831 = icmp slt i32 %sub830, 0
  br i1 %cmp831, label %cond.true.833, label %cond.false.846

cond.true.833:                                    ; preds = %cond.true.820
  %199 = load i32, i32* %len, align 4
  %conv834 = trunc i32 %199 to i16
  %conv835 = sext i16 %conv834 to i32
  %mul836 = mul nsw i32 0, %conv835
  %200 = load i64, i64* %size, align 8
  %conv837 = trunc i64 %200 to i16
  %conv838 = sext i16 %conv837 to i32
  %add839 = add nsw i32 %mul836, %conv838
  %mul840 = mul nsw i32 0, %add839
  %add841 = add nsw i32 %mul840, 1
  %shl842 = shl i32 %add841, 30
  %sub843 = sub nsw i32 %shl842, 1
  %mul844 = mul nsw i32 %sub843, 2
  %add845 = add nsw i32 %mul844, 1
  br label %cond.end.855

cond.false.846:                                   ; preds = %cond.true.820
  %201 = load i32, i32* %len, align 4
  %conv847 = trunc i32 %201 to i16
  %conv848 = sext i16 %conv847 to i32
  %mul849 = mul nsw i32 0, %conv848
  %202 = load i64, i64* %size, align 8
  %conv850 = trunc i64 %202 to i16
  %conv851 = sext i16 %conv850 to i32
  %add852 = add nsw i32 %mul849, %conv851
  %mul853 = mul nsw i32 0, %add852
  %sub854 = sub nsw i32 %mul853, 1
  br label %cond.end.855

cond.end.855:                                     ; preds = %cond.false.846, %cond.true.833
  %cond856 = phi i32 [ %add845, %cond.true.833 ], [ %sub854, %cond.false.846 ]
  %203 = load i32, i32* %len, align 4
  %conv857 = trunc i32 %203 to i16
  %conv858 = sext i16 %conv857 to i32
  %div859 = sdiv i32 %cond856, %conv858
  %cmp860 = icmp slt i32 %conv822, %div859
  br i1 %cmp860, label %cond.true.1057, label %lor.lhs.false.1031

cond.false.862:                                   ; preds = %cond.true.815
  %204 = load i32, i32* %len, align 4
  %conv863 = trunc i32 %204 to i16
  %conv864 = sext i16 %conv863 to i32
  %cmp865 = icmp eq i32 %conv864, -1
  br i1 %cmp865, label %cond.true.867, label %cond.false.868

cond.true.867:                                    ; preds = %cond.false.862
  br i1 false, label %cond.true.1057, label %lor.lhs.false.1031

cond.false.868:                                   ; preds = %cond.false.862
  %205 = load i32, i32* %len, align 4
  %conv869 = trunc i32 %205 to i16
  %conv870 = sext i16 %conv869 to i32
  %mul871 = mul nsw i32 0, %conv870
  %206 = load i64, i64* %size, align 8
  %conv872 = trunc i64 %206 to i16
  %conv873 = sext i16 %conv872 to i32
  %add874 = add nsw i32 %mul871, %conv873
  %mul875 = mul nsw i32 0, %add874
  %sub876 = sub nsw i32 %mul875, 1
  %cmp877 = icmp slt i32 %sub876, 0
  br i1 %cmp877, label %cond.true.879, label %cond.false.905

cond.true.879:                                    ; preds = %cond.false.868
  %207 = load i32, i32* %len, align 4
  %conv880 = trunc i32 %207 to i16
  %conv881 = sext i16 %conv880 to i32
  %mul882 = mul nsw i32 0, %conv881
  %208 = load i64, i64* %size, align 8
  %conv883 = trunc i64 %208 to i16
  %conv884 = sext i16 %conv883 to i32
  %add885 = add nsw i32 %mul882, %conv884
  %mul886 = mul nsw i32 0, %add885
  %add887 = add nsw i32 %mul886, 0
  %neg888 = xor i32 %add887, -1
  %cmp889 = icmp eq i32 %neg888, -1
  %conv890 = zext i1 %cmp889 to i32
  %sub891 = sub nsw i32 0, %conv890
  %209 = load i32, i32* %len, align 4
  %conv892 = trunc i32 %209 to i16
  %conv893 = sext i16 %conv892 to i32
  %mul894 = mul nsw i32 0, %conv893
  %210 = load i64, i64* %size, align 8
  %conv895 = trunc i64 %210 to i16
  %conv896 = sext i16 %conv895 to i32
  %add897 = add nsw i32 %mul894, %conv896
  %mul898 = mul nsw i32 0, %add897
  %add899 = add nsw i32 %mul898, 1
  %shl900 = shl i32 %add899, 30
  %sub901 = sub nsw i32 %shl900, 1
  %mul902 = mul nsw i32 %sub901, 2
  %add903 = add nsw i32 %mul902, 1
  %sub904 = sub nsw i32 %sub891, %add903
  br label %cond.end.914

cond.false.905:                                   ; preds = %cond.false.868
  %211 = load i32, i32* %len, align 4
  %conv906 = trunc i32 %211 to i16
  %conv907 = sext i16 %conv906 to i32
  %mul908 = mul nsw i32 0, %conv907
  %212 = load i64, i64* %size, align 8
  %conv909 = trunc i64 %212 to i16
  %conv910 = sext i16 %conv909 to i32
  %add911 = add nsw i32 %mul908, %conv910
  %mul912 = mul nsw i32 0, %add911
  %add913 = add nsw i32 %mul912, 0
  br label %cond.end.914

cond.end.914:                                     ; preds = %cond.false.905, %cond.true.879
  %cond915 = phi i32 [ %sub904, %cond.true.879 ], [ %add913, %cond.false.905 ]
  %213 = load i32, i32* %len, align 4
  %conv916 = trunc i32 %213 to i16
  %conv917 = sext i16 %conv916 to i32
  %div918 = sdiv i32 %cond915, %conv917
  %214 = load i64, i64* %size, align 8
  %conv919 = trunc i64 %214 to i16
  %conv920 = sext i16 %conv919 to i32
  %cmp921 = icmp slt i32 %div918, %conv920
  br i1 %cmp921, label %cond.true.1057, label %lor.lhs.false.1031

cond.false.923:                                   ; preds = %lor.lhs.false.810
  %215 = load i32, i32* %len, align 4
  %conv924 = trunc i32 %215 to i16
  %conv925 = sext i16 %conv924 to i32
  %cmp926 = icmp eq i32 %conv925, 0
  br i1 %cmp926, label %cond.true.928, label %cond.false.929

cond.true.928:                                    ; preds = %cond.false.923
  br i1 false, label %cond.true.1057, label %lor.lhs.false.1031

cond.false.929:                                   ; preds = %cond.false.923
  %216 = load i64, i64* %size, align 8
  %conv930 = trunc i64 %216 to i16
  %conv931 = sext i16 %conv930 to i32
  %cmp932 = icmp slt i32 %conv931, 0
  br i1 %cmp932, label %cond.true.934, label %cond.false.989

cond.true.934:                                    ; preds = %cond.false.929
  %217 = load i64, i64* %size, align 8
  %conv935 = trunc i64 %217 to i16
  %conv936 = sext i16 %conv935 to i32
  %218 = load i32, i32* %len, align 4
  %conv937 = trunc i32 %218 to i16
  %conv938 = sext i16 %conv937 to i32
  %mul939 = mul nsw i32 0, %conv938
  %219 = load i64, i64* %size, align 8
  %conv940 = trunc i64 %219 to i16
  %conv941 = sext i16 %conv940 to i32
  %add942 = add nsw i32 %mul939, %conv941
  %mul943 = mul nsw i32 0, %add942
  %sub944 = sub nsw i32 %mul943, 1
  %cmp945 = icmp slt i32 %sub944, 0
  br i1 %cmp945, label %cond.true.947, label %cond.false.973

cond.true.947:                                    ; preds = %cond.true.934
  %220 = load i32, i32* %len, align 4
  %conv948 = trunc i32 %220 to i16
  %conv949 = sext i16 %conv948 to i32
  %mul950 = mul nsw i32 0, %conv949
  %221 = load i64, i64* %size, align 8
  %conv951 = trunc i64 %221 to i16
  %conv952 = sext i16 %conv951 to i32
  %add953 = add nsw i32 %mul950, %conv952
  %mul954 = mul nsw i32 0, %add953
  %add955 = add nsw i32 %mul954, 0
  %neg956 = xor i32 %add955, -1
  %cmp957 = icmp eq i32 %neg956, -1
  %conv958 = zext i1 %cmp957 to i32
  %sub959 = sub nsw i32 0, %conv958
  %222 = load i32, i32* %len, align 4
  %conv960 = trunc i32 %222 to i16
  %conv961 = sext i16 %conv960 to i32
  %mul962 = mul nsw i32 0, %conv961
  %223 = load i64, i64* %size, align 8
  %conv963 = trunc i64 %223 to i16
  %conv964 = sext i16 %conv963 to i32
  %add965 = add nsw i32 %mul962, %conv964
  %mul966 = mul nsw i32 0, %add965
  %add967 = add nsw i32 %mul966, 1
  %shl968 = shl i32 %add967, 30
  %sub969 = sub nsw i32 %shl968, 1
  %mul970 = mul nsw i32 %sub969, 2
  %add971 = add nsw i32 %mul970, 1
  %sub972 = sub nsw i32 %sub959, %add971
  br label %cond.end.982

cond.false.973:                                   ; preds = %cond.true.934
  %224 = load i32, i32* %len, align 4
  %conv974 = trunc i32 %224 to i16
  %conv975 = sext i16 %conv974 to i32
  %mul976 = mul nsw i32 0, %conv975
  %225 = load i64, i64* %size, align 8
  %conv977 = trunc i64 %225 to i16
  %conv978 = sext i16 %conv977 to i32
  %add979 = add nsw i32 %mul976, %conv978
  %mul980 = mul nsw i32 0, %add979
  %add981 = add nsw i32 %mul980, 0
  br label %cond.end.982

cond.end.982:                                     ; preds = %cond.false.973, %cond.true.947
  %cond983 = phi i32 [ %sub972, %cond.true.947 ], [ %add981, %cond.false.973 ]
  %226 = load i32, i32* %len, align 4
  %conv984 = trunc i32 %226 to i16
  %conv985 = sext i16 %conv984 to i32
  %div986 = sdiv i32 %cond983, %conv985
  %cmp987 = icmp slt i32 %conv936, %div986
  br i1 %cmp987, label %cond.true.1057, label %lor.lhs.false.1031

cond.false.989:                                   ; preds = %cond.false.929
  %227 = load i32, i32* %len, align 4
  %conv990 = trunc i32 %227 to i16
  %conv991 = sext i16 %conv990 to i32
  %mul992 = mul nsw i32 0, %conv991
  %228 = load i64, i64* %size, align 8
  %conv993 = trunc i64 %228 to i16
  %conv994 = sext i16 %conv993 to i32
  %add995 = add nsw i32 %mul992, %conv994
  %mul996 = mul nsw i32 0, %add995
  %sub997 = sub nsw i32 %mul996, 1
  %cmp998 = icmp slt i32 %sub997, 0
  br i1 %cmp998, label %cond.true.1000, label %cond.false.1013

cond.true.1000:                                   ; preds = %cond.false.989
  %229 = load i32, i32* %len, align 4
  %conv1001 = trunc i32 %229 to i16
  %conv1002 = sext i16 %conv1001 to i32
  %mul1003 = mul nsw i32 0, %conv1002
  %230 = load i64, i64* %size, align 8
  %conv1004 = trunc i64 %230 to i16
  %conv1005 = sext i16 %conv1004 to i32
  %add1006 = add nsw i32 %mul1003, %conv1005
  %mul1007 = mul nsw i32 0, %add1006
  %add1008 = add nsw i32 %mul1007, 1
  %shl1009 = shl i32 %add1008, 30
  %sub1010 = sub nsw i32 %shl1009, 1
  %mul1011 = mul nsw i32 %sub1010, 2
  %add1012 = add nsw i32 %mul1011, 1
  br label %cond.end.1022

cond.false.1013:                                  ; preds = %cond.false.989
  %231 = load i32, i32* %len, align 4
  %conv1014 = trunc i32 %231 to i16
  %conv1015 = sext i16 %conv1014 to i32
  %mul1016 = mul nsw i32 0, %conv1015
  %232 = load i64, i64* %size, align 8
  %conv1017 = trunc i64 %232 to i16
  %conv1018 = sext i16 %conv1017 to i32
  %add1019 = add nsw i32 %mul1016, %conv1018
  %mul1020 = mul nsw i32 0, %add1019
  %sub1021 = sub nsw i32 %mul1020, 1
  br label %cond.end.1022

cond.end.1022:                                    ; preds = %cond.false.1013, %cond.true.1000
  %cond1023 = phi i32 [ %add1012, %cond.true.1000 ], [ %sub1021, %cond.false.1013 ]
  %233 = load i32, i32* %len, align 4
  %conv1024 = trunc i32 %233 to i16
  %conv1025 = sext i16 %conv1024 to i32
  %div1026 = sdiv i32 %cond1023, %conv1025
  %234 = load i64, i64* %size, align 8
  %conv1027 = trunc i64 %234 to i16
  %conv1028 = sext i16 %conv1027 to i32
  %cmp1029 = icmp slt i32 %div1026, %conv1028
  br i1 %cmp1029, label %cond.true.1057, label %lor.lhs.false.1031

lor.lhs.false.1031:                               ; preds = %cond.end.1022, %cond.end.982, %cond.true.928, %cond.end.914, %cond.true.867, %cond.end.855
  %235 = load i64, i64* %size, align 8
  %conv1032 = trunc i64 %235 to i16
  %conv1033 = sext i16 %conv1032 to i32
  %236 = load i32, i32* %len, align 4
  %conv1034 = trunc i32 %236 to i16
  %conv1035 = sext i16 %conv1034 to i32
  %mul1036 = mul nsw i32 %conv1033, %conv1035
  %mul1037 = mul nsw i32 0, %mul1036
  %sub1038 = sub nsw i32 %mul1037, 1
  %cmp1039 = icmp slt i32 %sub1038, 0
  br i1 %cmp1039, label %land.lhs.true.1041, label %lor.lhs.false.1049

land.lhs.true.1041:                               ; preds = %lor.lhs.false.1031
  %237 = load i64, i64* %size, align 8
  %conv1042 = trunc i64 %237 to i16
  %conv1043 = sext i16 %conv1042 to i32
  %238 = load i32, i32* %len, align 4
  %conv1044 = trunc i32 %238 to i16
  %conv1045 = sext i16 %conv1044 to i32
  %mul1046 = mul nsw i32 %conv1043, %conv1045
  %cmp1047 = icmp slt i32 %mul1046, -32768
  br i1 %cmp1047, label %cond.true.1057, label %lor.lhs.false.1049

lor.lhs.false.1049:                               ; preds = %land.lhs.true.1041, %lor.lhs.false.1031
  %239 = load i64, i64* %size, align 8
  %conv1050 = trunc i64 %239 to i16
  %conv1051 = sext i16 %conv1050 to i32
  %240 = load i32, i32* %len, align 4
  %conv1052 = trunc i32 %240 to i16
  %conv1053 = sext i16 %conv1052 to i32
  %mul1054 = mul nsw i32 %conv1051, %conv1053
  %cmp1055 = icmp slt i32 32767, %mul1054
  br i1 %cmp1055, label %cond.true.1057, label %cond.false.1086

cond.true.1057:                                   ; preds = %lor.lhs.false.1049, %land.lhs.true.1041, %cond.end.1022, %cond.end.982, %cond.true.928, %cond.end.914, %cond.true.867, %cond.end.855, %land.lhs.true.805, %land.lhs.true.795
  %241 = load i64, i64* %size, align 8
  %conv1058 = trunc i64 %241 to i16
  %conv1059 = zext i16 %conv1058 to i32
  %242 = load i32, i32* %len, align 4
  %conv1060 = trunc i32 %242 to i16
  %conv1061 = zext i16 %conv1060 to i32
  %mul1062 = mul nsw i32 %conv1059, %conv1061
  %cmp1063 = icmp sle i32 %mul1062, 32767
  br i1 %cmp1063, label %cond.true.1065, label %cond.false.1073

cond.true.1065:                                   ; preds = %cond.true.1057
  %243 = load i64, i64* %size, align 8
  %conv1066 = trunc i64 %243 to i16
  %conv1067 = zext i16 %conv1066 to i32
  %244 = load i32, i32* %len, align 4
  %conv1068 = trunc i32 %244 to i16
  %conv1069 = zext i16 %conv1068 to i32
  %mul1070 = mul nsw i32 %conv1067, %conv1069
  %conv1071 = trunc i32 %mul1070 to i16
  %conv1072 = sext i16 %conv1071 to i32
  br label %cond.end.1083

cond.false.1073:                                  ; preds = %cond.true.1057
  %245 = load i64, i64* %size, align 8
  %conv1074 = trunc i64 %245 to i16
  %conv1075 = zext i16 %conv1074 to i32
  %246 = load i32, i32* %len, align 4
  %conv1076 = trunc i32 %246 to i16
  %conv1077 = zext i16 %conv1076 to i32
  %mul1078 = mul nsw i32 %conv1075, %conv1077
  %sub1079 = sub nsw i32 %mul1078, -32768
  %conv1080 = trunc i32 %sub1079 to i16
  %conv1081 = sext i16 %conv1080 to i32
  %add1082 = add nsw i32 %conv1081, -32768
  br label %cond.end.1083

cond.end.1083:                                    ; preds = %cond.false.1073, %cond.true.1065
  %cond1084 = phi i32 [ %conv1072, %cond.true.1065 ], [ %add1082, %cond.false.1073 ]
  %conv1085 = sext i32 %cond1084 to i64
  store i64 %conv1085, i64* %product, align 8
  br i1 true, label %if.then.2965, label %lor.lhs.false.2962

cond.false.1086:                                  ; preds = %lor.lhs.false.1049
  %247 = load i64, i64* %size, align 8
  %conv1087 = trunc i64 %247 to i16
  %conv1088 = zext i16 %conv1087 to i32
  %248 = load i32, i32* %len, align 4
  %conv1089 = trunc i32 %248 to i16
  %conv1090 = zext i16 %conv1089 to i32
  %mul1091 = mul nsw i32 %conv1088, %conv1090
  %cmp1092 = icmp sle i32 %mul1091, 32767
  br i1 %cmp1092, label %cond.true.1094, label %cond.false.1102

cond.true.1094:                                   ; preds = %cond.false.1086
  %249 = load i64, i64* %size, align 8
  %conv1095 = trunc i64 %249 to i16
  %conv1096 = zext i16 %conv1095 to i32
  %250 = load i32, i32* %len, align 4
  %conv1097 = trunc i32 %250 to i16
  %conv1098 = zext i16 %conv1097 to i32
  %mul1099 = mul nsw i32 %conv1096, %conv1098
  %conv1100 = trunc i32 %mul1099 to i16
  %conv1101 = sext i16 %conv1100 to i32
  br label %cond.end.1112

cond.false.1102:                                  ; preds = %cond.false.1086
  %251 = load i64, i64* %size, align 8
  %conv1103 = trunc i64 %251 to i16
  %conv1104 = zext i16 %conv1103 to i32
  %252 = load i32, i32* %len, align 4
  %conv1105 = trunc i32 %252 to i16
  %conv1106 = zext i16 %conv1105 to i32
  %mul1107 = mul nsw i32 %conv1104, %conv1106
  %sub1108 = sub nsw i32 %mul1107, -32768
  %conv1109 = trunc i32 %sub1108 to i16
  %conv1110 = sext i16 %conv1109 to i32
  %add1111 = add nsw i32 %conv1110, -32768
  br label %cond.end.1112

cond.end.1112:                                    ; preds = %cond.false.1102, %cond.true.1094
  %cond1113 = phi i32 [ %conv1101, %cond.true.1094 ], [ %add1111, %cond.false.1102 ]
  %conv1114 = sext i32 %cond1113 to i64
  store i64 %conv1114, i64* %product, align 8
  br i1 false, label %if.then.2965, label %lor.lhs.false.2962

cond.false.1115:                                  ; preds = %cond.true.739
  %253 = load i32, i32* %len, align 4
  %mul1116 = mul nsw i32 0, %253
  %conv1117 = sext i32 %mul1116 to i64
  %254 = load i64, i64* %size, align 8
  %add1118 = add nsw i64 %conv1117, %254
  %mul1119 = mul nsw i64 0, %add1118
  %sub1120 = sub nsw i64 %mul1119, 1
  %cmp1121 = icmp slt i64 %sub1120, 0
  br i1 %cmp1121, label %cond.true.1123, label %cond.false.1144

cond.true.1123:                                   ; preds = %cond.false.1115
  %255 = load i32, i32* %len, align 4
  %mul1124 = mul nsw i32 0, %255
  %conv1125 = sext i32 %mul1124 to i64
  %256 = load i64, i64* %size, align 8
  %add1126 = add nsw i64 %conv1125, %256
  %mul1127 = mul nsw i64 0, %add1126
  %add1128 = add nsw i64 %mul1127, 0
  %neg1129 = xor i64 %add1128, -1
  %cmp1130 = icmp eq i64 %neg1129, -1
  %conv1131 = zext i1 %cmp1130 to i32
  %sub1132 = sub nsw i32 0, %conv1131
  %conv1133 = sext i32 %sub1132 to i64
  %257 = load i32, i32* %len, align 4
  %mul1134 = mul nsw i32 0, %257
  %conv1135 = sext i32 %mul1134 to i64
  %258 = load i64, i64* %size, align 8
  %add1136 = add nsw i64 %conv1135, %258
  %mul1137 = mul nsw i64 0, %add1136
  %add1138 = add nsw i64 %mul1137, 1
  %shl1139 = shl i64 %add1138, 62
  %sub1140 = sub nsw i64 %shl1139, 1
  %mul1141 = mul nsw i64 %sub1140, 2
  %add1142 = add nsw i64 %mul1141, 1
  %sub1143 = sub nsw i64 %conv1133, %add1142
  br label %cond.end.1150

cond.false.1144:                                  ; preds = %cond.false.1115
  %259 = load i32, i32* %len, align 4
  %mul1145 = mul nsw i32 0, %259
  %conv1146 = sext i32 %mul1145 to i64
  %260 = load i64, i64* %size, align 8
  %add1147 = add nsw i64 %conv1146, %260
  %mul1148 = mul nsw i64 0, %add1147
  %add1149 = add nsw i64 %mul1148, 0
  br label %cond.end.1150

cond.end.1150:                                    ; preds = %cond.false.1144, %cond.true.1123
  %cond1151 = phi i64 [ %sub1143, %cond.true.1123 ], [ %add1149, %cond.false.1144 ]
  %cmp1152 = icmp eq i64 %cond1151, 0
  br i1 %cmp1152, label %land.lhs.true.1154, label %lor.lhs.false.1166

land.lhs.true.1154:                               ; preds = %cond.end.1150
  %261 = load i64, i64* %size, align 8
  %cmp1155 = icmp slt i64 %261, 0
  br i1 %cmp1155, label %land.lhs.true.1157, label %lor.lhs.false.1160

land.lhs.true.1157:                               ; preds = %land.lhs.true.1154
  %262 = load i32, i32* %len, align 4
  %cmp1158 = icmp slt i32 0, %262
  br i1 %cmp1158, label %cond.true.1342, label %lor.lhs.false.1160

lor.lhs.false.1160:                               ; preds = %land.lhs.true.1157, %land.lhs.true.1154
  %263 = load i32, i32* %len, align 4
  %cmp1161 = icmp slt i32 %263, 0
  br i1 %cmp1161, label %land.lhs.true.1163, label %lor.lhs.false.1166

land.lhs.true.1163:                               ; preds = %lor.lhs.false.1160
  %264 = load i64, i64* %size, align 8
  %cmp1164 = icmp slt i64 0, %264
  br i1 %cmp1164, label %cond.true.1342, label %lor.lhs.false.1166

lor.lhs.false.1166:                               ; preds = %land.lhs.true.1163, %lor.lhs.false.1160, %cond.end.1150
  %265 = load i32, i32* %len, align 4
  %cmp1167 = icmp slt i32 %265, 0
  br i1 %cmp1167, label %cond.true.1169, label %cond.false.1247

cond.true.1169:                                   ; preds = %lor.lhs.false.1166
  %266 = load i64, i64* %size, align 8
  %cmp1170 = icmp slt i64 %266, 0
  br i1 %cmp1170, label %cond.true.1172, label %cond.false.1202

cond.true.1172:                                   ; preds = %cond.true.1169
  %267 = load i64, i64* %size, align 8
  %268 = load i32, i32* %len, align 4
  %mul1173 = mul nsw i32 0, %268
  %conv1174 = sext i32 %mul1173 to i64
  %269 = load i64, i64* %size, align 8
  %add1175 = add nsw i64 %conv1174, %269
  %mul1176 = mul nsw i64 0, %add1175
  %sub1177 = sub nsw i64 %mul1176, 1
  %cmp1178 = icmp slt i64 %sub1177, 0
  br i1 %cmp1178, label %cond.true.1180, label %cond.false.1190

cond.true.1180:                                   ; preds = %cond.true.1172
  %270 = load i32, i32* %len, align 4
  %mul1181 = mul nsw i32 0, %270
  %conv1182 = sext i32 %mul1181 to i64
  %271 = load i64, i64* %size, align 8
  %add1183 = add nsw i64 %conv1182, %271
  %mul1184 = mul nsw i64 0, %add1183
  %add1185 = add nsw i64 %mul1184, 1
  %shl1186 = shl i64 %add1185, 62
  %sub1187 = sub nsw i64 %shl1186, 1
  %mul1188 = mul nsw i64 %sub1187, 2
  %add1189 = add nsw i64 %mul1188, 1
  br label %cond.end.1196

cond.false.1190:                                  ; preds = %cond.true.1172
  %272 = load i32, i32* %len, align 4
  %mul1191 = mul nsw i32 0, %272
  %conv1192 = sext i32 %mul1191 to i64
  %273 = load i64, i64* %size, align 8
  %add1193 = add nsw i64 %conv1192, %273
  %mul1194 = mul nsw i64 0, %add1193
  %sub1195 = sub nsw i64 %mul1194, 1
  br label %cond.end.1196

cond.end.1196:                                    ; preds = %cond.false.1190, %cond.true.1180
  %cond1197 = phi i64 [ %add1189, %cond.true.1180 ], [ %sub1195, %cond.false.1190 ]
  %274 = load i32, i32* %len, align 4
  %conv1198 = sext i32 %274 to i64
  %div1199 = sdiv i64 %cond1197, %conv1198
  %cmp1200 = icmp slt i64 %267, %div1199
  br i1 %cmp1200, label %cond.true.1342, label %lor.lhs.false.1325

cond.false.1202:                                  ; preds = %cond.true.1169
  %275 = load i32, i32* %len, align 4
  %cmp1203 = icmp eq i32 %275, -1
  br i1 %cmp1203, label %cond.true.1205, label %cond.false.1206

cond.true.1205:                                   ; preds = %cond.false.1202
  br i1 false, label %cond.true.1342, label %lor.lhs.false.1325

cond.false.1206:                                  ; preds = %cond.false.1202
  %276 = load i32, i32* %len, align 4
  %mul1207 = mul nsw i32 0, %276
  %conv1208 = sext i32 %mul1207 to i64
  %277 = load i64, i64* %size, align 8
  %add1209 = add nsw i64 %conv1208, %277
  %mul1210 = mul nsw i64 0, %add1209
  %sub1211 = sub nsw i64 %mul1210, 1
  %cmp1212 = icmp slt i64 %sub1211, 0
  br i1 %cmp1212, label %cond.true.1214, label %cond.false.1235

cond.true.1214:                                   ; preds = %cond.false.1206
  %278 = load i32, i32* %len, align 4
  %mul1215 = mul nsw i32 0, %278
  %conv1216 = sext i32 %mul1215 to i64
  %279 = load i64, i64* %size, align 8
  %add1217 = add nsw i64 %conv1216, %279
  %mul1218 = mul nsw i64 0, %add1217
  %add1219 = add nsw i64 %mul1218, 0
  %neg1220 = xor i64 %add1219, -1
  %cmp1221 = icmp eq i64 %neg1220, -1
  %conv1222 = zext i1 %cmp1221 to i32
  %sub1223 = sub nsw i32 0, %conv1222
  %conv1224 = sext i32 %sub1223 to i64
  %280 = load i32, i32* %len, align 4
  %mul1225 = mul nsw i32 0, %280
  %conv1226 = sext i32 %mul1225 to i64
  %281 = load i64, i64* %size, align 8
  %add1227 = add nsw i64 %conv1226, %281
  %mul1228 = mul nsw i64 0, %add1227
  %add1229 = add nsw i64 %mul1228, 1
  %shl1230 = shl i64 %add1229, 62
  %sub1231 = sub nsw i64 %shl1230, 1
  %mul1232 = mul nsw i64 %sub1231, 2
  %add1233 = add nsw i64 %mul1232, 1
  %sub1234 = sub nsw i64 %conv1224, %add1233
  br label %cond.end.1241

cond.false.1235:                                  ; preds = %cond.false.1206
  %282 = load i32, i32* %len, align 4
  %mul1236 = mul nsw i32 0, %282
  %conv1237 = sext i32 %mul1236 to i64
  %283 = load i64, i64* %size, align 8
  %add1238 = add nsw i64 %conv1237, %283
  %mul1239 = mul nsw i64 0, %add1238
  %add1240 = add nsw i64 %mul1239, 0
  br label %cond.end.1241

cond.end.1241:                                    ; preds = %cond.false.1235, %cond.true.1214
  %cond1242 = phi i64 [ %sub1234, %cond.true.1214 ], [ %add1240, %cond.false.1235 ]
  %284 = load i32, i32* %len, align 4
  %conv1243 = sext i32 %284 to i64
  %div1244 = sdiv i64 %cond1242, %conv1243
  %285 = load i64, i64* %size, align 8
  %cmp1245 = icmp slt i64 %div1244, %285
  br i1 %cmp1245, label %cond.true.1342, label %lor.lhs.false.1325

cond.false.1247:                                  ; preds = %lor.lhs.false.1166
  %286 = load i32, i32* %len, align 4
  %cmp1248 = icmp eq i32 %286, 0
  br i1 %cmp1248, label %cond.true.1250, label %cond.false.1251

cond.true.1250:                                   ; preds = %cond.false.1247
  br i1 false, label %cond.true.1342, label %lor.lhs.false.1325

cond.false.1251:                                  ; preds = %cond.false.1247
  %287 = load i64, i64* %size, align 8
  %cmp1252 = icmp slt i64 %287, 0
  br i1 %cmp1252, label %cond.true.1254, label %cond.false.1295

cond.true.1254:                                   ; preds = %cond.false.1251
  %288 = load i64, i64* %size, align 8
  %289 = load i32, i32* %len, align 4
  %mul1255 = mul nsw i32 0, %289
  %conv1256 = sext i32 %mul1255 to i64
  %290 = load i64, i64* %size, align 8
  %add1257 = add nsw i64 %conv1256, %290
  %mul1258 = mul nsw i64 0, %add1257
  %sub1259 = sub nsw i64 %mul1258, 1
  %cmp1260 = icmp slt i64 %sub1259, 0
  br i1 %cmp1260, label %cond.true.1262, label %cond.false.1283

cond.true.1262:                                   ; preds = %cond.true.1254
  %291 = load i32, i32* %len, align 4
  %mul1263 = mul nsw i32 0, %291
  %conv1264 = sext i32 %mul1263 to i64
  %292 = load i64, i64* %size, align 8
  %add1265 = add nsw i64 %conv1264, %292
  %mul1266 = mul nsw i64 0, %add1265
  %add1267 = add nsw i64 %mul1266, 0
  %neg1268 = xor i64 %add1267, -1
  %cmp1269 = icmp eq i64 %neg1268, -1
  %conv1270 = zext i1 %cmp1269 to i32
  %sub1271 = sub nsw i32 0, %conv1270
  %conv1272 = sext i32 %sub1271 to i64
  %293 = load i32, i32* %len, align 4
  %mul1273 = mul nsw i32 0, %293
  %conv1274 = sext i32 %mul1273 to i64
  %294 = load i64, i64* %size, align 8
  %add1275 = add nsw i64 %conv1274, %294
  %mul1276 = mul nsw i64 0, %add1275
  %add1277 = add nsw i64 %mul1276, 1
  %shl1278 = shl i64 %add1277, 62
  %sub1279 = sub nsw i64 %shl1278, 1
  %mul1280 = mul nsw i64 %sub1279, 2
  %add1281 = add nsw i64 %mul1280, 1
  %sub1282 = sub nsw i64 %conv1272, %add1281
  br label %cond.end.1289

cond.false.1283:                                  ; preds = %cond.true.1254
  %295 = load i32, i32* %len, align 4
  %mul1284 = mul nsw i32 0, %295
  %conv1285 = sext i32 %mul1284 to i64
  %296 = load i64, i64* %size, align 8
  %add1286 = add nsw i64 %conv1285, %296
  %mul1287 = mul nsw i64 0, %add1286
  %add1288 = add nsw i64 %mul1287, 0
  br label %cond.end.1289

cond.end.1289:                                    ; preds = %cond.false.1283, %cond.true.1262
  %cond1290 = phi i64 [ %sub1282, %cond.true.1262 ], [ %add1288, %cond.false.1283 ]
  %297 = load i32, i32* %len, align 4
  %conv1291 = sext i32 %297 to i64
  %div1292 = sdiv i64 %cond1290, %conv1291
  %cmp1293 = icmp slt i64 %288, %div1292
  br i1 %cmp1293, label %cond.true.1342, label %lor.lhs.false.1325

cond.false.1295:                                  ; preds = %cond.false.1251
  %298 = load i32, i32* %len, align 4
  %mul1296 = mul nsw i32 0, %298
  %conv1297 = sext i32 %mul1296 to i64
  %299 = load i64, i64* %size, align 8
  %add1298 = add nsw i64 %conv1297, %299
  %mul1299 = mul nsw i64 0, %add1298
  %sub1300 = sub nsw i64 %mul1299, 1
  %cmp1301 = icmp slt i64 %sub1300, 0
  br i1 %cmp1301, label %cond.true.1303, label %cond.false.1313

cond.true.1303:                                   ; preds = %cond.false.1295
  %300 = load i32, i32* %len, align 4
  %mul1304 = mul nsw i32 0, %300
  %conv1305 = sext i32 %mul1304 to i64
  %301 = load i64, i64* %size, align 8
  %add1306 = add nsw i64 %conv1305, %301
  %mul1307 = mul nsw i64 0, %add1306
  %add1308 = add nsw i64 %mul1307, 1
  %shl1309 = shl i64 %add1308, 62
  %sub1310 = sub nsw i64 %shl1309, 1
  %mul1311 = mul nsw i64 %sub1310, 2
  %add1312 = add nsw i64 %mul1311, 1
  br label %cond.end.1319

cond.false.1313:                                  ; preds = %cond.false.1295
  %302 = load i32, i32* %len, align 4
  %mul1314 = mul nsw i32 0, %302
  %conv1315 = sext i32 %mul1314 to i64
  %303 = load i64, i64* %size, align 8
  %add1316 = add nsw i64 %conv1315, %303
  %mul1317 = mul nsw i64 0, %add1316
  %sub1318 = sub nsw i64 %mul1317, 1
  br label %cond.end.1319

cond.end.1319:                                    ; preds = %cond.false.1313, %cond.true.1303
  %cond1320 = phi i64 [ %add1312, %cond.true.1303 ], [ %sub1318, %cond.false.1313 ]
  %304 = load i32, i32* %len, align 4
  %conv1321 = sext i32 %304 to i64
  %div1322 = sdiv i64 %cond1320, %conv1321
  %305 = load i64, i64* %size, align 8
  %cmp1323 = icmp slt i64 %div1322, %305
  br i1 %cmp1323, label %cond.true.1342, label %lor.lhs.false.1325

lor.lhs.false.1325:                               ; preds = %cond.end.1319, %cond.end.1289, %cond.true.1250, %cond.end.1241, %cond.true.1205, %cond.end.1196
  %306 = load i64, i64* %size, align 8
  %307 = load i32, i32* %len, align 4
  %conv1326 = sext i32 %307 to i64
  %mul1327 = mul nsw i64 %306, %conv1326
  %mul1328 = mul nsw i64 0, %mul1327
  %sub1329 = sub nsw i64 %mul1328, 1
  %cmp1330 = icmp slt i64 %sub1329, 0
  br i1 %cmp1330, label %land.lhs.true.1332, label %lor.lhs.false.1337

land.lhs.true.1332:                               ; preds = %lor.lhs.false.1325
  %308 = load i64, i64* %size, align 8
  %309 = load i32, i32* %len, align 4
  %conv1333 = sext i32 %309 to i64
  %mul1334 = mul nsw i64 %308, %conv1333
  %cmp1335 = icmp slt i64 %mul1334, -32768
  br i1 %cmp1335, label %cond.true.1342, label %lor.lhs.false.1337

lor.lhs.false.1337:                               ; preds = %land.lhs.true.1332, %lor.lhs.false.1325
  %310 = load i64, i64* %size, align 8
  %311 = load i32, i32* %len, align 4
  %conv1338 = sext i32 %311 to i64
  %mul1339 = mul nsw i64 %310, %conv1338
  %cmp1340 = icmp slt i64 32767, %mul1339
  br i1 %cmp1340, label %cond.true.1342, label %cond.false.1371

cond.true.1342:                                   ; preds = %lor.lhs.false.1337, %land.lhs.true.1332, %cond.end.1319, %cond.end.1289, %cond.true.1250, %cond.end.1241, %cond.true.1205, %cond.end.1196, %land.lhs.true.1163, %land.lhs.true.1157
  %312 = load i64, i64* %size, align 8
  %conv1343 = trunc i64 %312 to i16
  %conv1344 = zext i16 %conv1343 to i32
  %313 = load i32, i32* %len, align 4
  %conv1345 = trunc i32 %313 to i16
  %conv1346 = zext i16 %conv1345 to i32
  %mul1347 = mul nsw i32 %conv1344, %conv1346
  %cmp1348 = icmp sle i32 %mul1347, 32767
  br i1 %cmp1348, label %cond.true.1350, label %cond.false.1358

cond.true.1350:                                   ; preds = %cond.true.1342
  %314 = load i64, i64* %size, align 8
  %conv1351 = trunc i64 %314 to i16
  %conv1352 = zext i16 %conv1351 to i32
  %315 = load i32, i32* %len, align 4
  %conv1353 = trunc i32 %315 to i16
  %conv1354 = zext i16 %conv1353 to i32
  %mul1355 = mul nsw i32 %conv1352, %conv1354
  %conv1356 = trunc i32 %mul1355 to i16
  %conv1357 = sext i16 %conv1356 to i32
  br label %cond.end.1368

cond.false.1358:                                  ; preds = %cond.true.1342
  %316 = load i64, i64* %size, align 8
  %conv1359 = trunc i64 %316 to i16
  %conv1360 = zext i16 %conv1359 to i32
  %317 = load i32, i32* %len, align 4
  %conv1361 = trunc i32 %317 to i16
  %conv1362 = zext i16 %conv1361 to i32
  %mul1363 = mul nsw i32 %conv1360, %conv1362
  %sub1364 = sub nsw i32 %mul1363, -32768
  %conv1365 = trunc i32 %sub1364 to i16
  %conv1366 = sext i16 %conv1365 to i32
  %add1367 = add nsw i32 %conv1366, -32768
  br label %cond.end.1368

cond.end.1368:                                    ; preds = %cond.false.1358, %cond.true.1350
  %cond1369 = phi i32 [ %conv1357, %cond.true.1350 ], [ %add1367, %cond.false.1358 ]
  %conv1370 = sext i32 %cond1369 to i64
  store i64 %conv1370, i64* %product, align 8
  br i1 true, label %if.then.2965, label %lor.lhs.false.2962

cond.false.1371:                                  ; preds = %lor.lhs.false.1337
  %318 = load i64, i64* %size, align 8
  %conv1372 = trunc i64 %318 to i16
  %conv1373 = zext i16 %conv1372 to i32
  %319 = load i32, i32* %len, align 4
  %conv1374 = trunc i32 %319 to i16
  %conv1375 = zext i16 %conv1374 to i32
  %mul1376 = mul nsw i32 %conv1373, %conv1375
  %cmp1377 = icmp sle i32 %mul1376, 32767
  br i1 %cmp1377, label %cond.true.1379, label %cond.false.1387

cond.true.1379:                                   ; preds = %cond.false.1371
  %320 = load i64, i64* %size, align 8
  %conv1380 = trunc i64 %320 to i16
  %conv1381 = zext i16 %conv1380 to i32
  %321 = load i32, i32* %len, align 4
  %conv1382 = trunc i32 %321 to i16
  %conv1383 = zext i16 %conv1382 to i32
  %mul1384 = mul nsw i32 %conv1381, %conv1383
  %conv1385 = trunc i32 %mul1384 to i16
  %conv1386 = sext i16 %conv1385 to i32
  br label %cond.end.1397

cond.false.1387:                                  ; preds = %cond.false.1371
  %322 = load i64, i64* %size, align 8
  %conv1388 = trunc i64 %322 to i16
  %conv1389 = zext i16 %conv1388 to i32
  %323 = load i32, i32* %len, align 4
  %conv1390 = trunc i32 %323 to i16
  %conv1391 = zext i16 %conv1390 to i32
  %mul1392 = mul nsw i32 %conv1389, %conv1391
  %sub1393 = sub nsw i32 %mul1392, -32768
  %conv1394 = trunc i32 %sub1393 to i16
  %conv1395 = sext i16 %conv1394 to i32
  %add1396 = add nsw i32 %conv1395, -32768
  br label %cond.end.1397

cond.end.1397:                                    ; preds = %cond.false.1387, %cond.true.1379
  %cond1398 = phi i32 [ %conv1386, %cond.true.1379 ], [ %add1396, %cond.false.1387 ]
  %conv1399 = sext i32 %cond1398 to i64
  store i64 %conv1399, i64* %product, align 8
  br i1 false, label %if.then.2965, label %lor.lhs.false.2962

cond.false.1400:                                  ; preds = %cond.false.738
  br i1 false, label %cond.true.1401, label %cond.false.1921

cond.true.1401:                                   ; preds = %cond.false.1400
  br i1 false, label %cond.true.1402, label %cond.false.1662

cond.true.1402:                                   ; preds = %cond.true.1401
  %324 = load i32, i32* %len, align 4
  %mul1403 = mul nsw i32 0, %324
  %325 = load i64, i64* %size, align 8
  %conv1404 = trunc i64 %325 to i32
  %add1405 = add nsw i32 %mul1403, %conv1404
  %mul1406 = mul nsw i32 0, %add1405
  %sub1407 = sub nsw i32 %mul1406, 1
  %cmp1408 = icmp slt i32 %sub1407, 0
  br i1 %cmp1408, label %cond.true.1410, label %cond.false.1430

cond.true.1410:                                   ; preds = %cond.true.1402
  %326 = load i32, i32* %len, align 4
  %mul1411 = mul nsw i32 0, %326
  %327 = load i64, i64* %size, align 8
  %conv1412 = trunc i64 %327 to i32
  %add1413 = add nsw i32 %mul1411, %conv1412
  %mul1414 = mul nsw i32 0, %add1413
  %add1415 = add nsw i32 %mul1414, 0
  %neg1416 = xor i32 %add1415, -1
  %cmp1417 = icmp eq i32 %neg1416, -1
  %conv1418 = zext i1 %cmp1417 to i32
  %sub1419 = sub nsw i32 0, %conv1418
  %328 = load i32, i32* %len, align 4
  %mul1420 = mul nsw i32 0, %328
  %329 = load i64, i64* %size, align 8
  %conv1421 = trunc i64 %329 to i32
  %add1422 = add nsw i32 %mul1420, %conv1421
  %mul1423 = mul nsw i32 0, %add1422
  %add1424 = add nsw i32 %mul1423, 1
  %shl1425 = shl i32 %add1424, 30
  %sub1426 = sub nsw i32 %shl1425, 1
  %mul1427 = mul nsw i32 %sub1426, 2
  %add1428 = add nsw i32 %mul1427, 1
  %sub1429 = sub nsw i32 %sub1419, %add1428
  br label %cond.end.1436

cond.false.1430:                                  ; preds = %cond.true.1402
  %330 = load i32, i32* %len, align 4
  %mul1431 = mul nsw i32 0, %330
  %331 = load i64, i64* %size, align 8
  %conv1432 = trunc i64 %331 to i32
  %add1433 = add nsw i32 %mul1431, %conv1432
  %mul1434 = mul nsw i32 0, %add1433
  %add1435 = add nsw i32 %mul1434, 0
  br label %cond.end.1436

cond.end.1436:                                    ; preds = %cond.false.1430, %cond.true.1410
  %cond1437 = phi i32 [ %sub1429, %cond.true.1410 ], [ %add1435, %cond.false.1430 ]
  %cmp1438 = icmp eq i32 %cond1437, 0
  br i1 %cmp1438, label %land.lhs.true.1440, label %lor.lhs.false.1454

land.lhs.true.1440:                               ; preds = %cond.end.1436
  %332 = load i64, i64* %size, align 8
  %conv1441 = trunc i64 %332 to i32
  %cmp1442 = icmp slt i32 %conv1441, 0
  br i1 %cmp1442, label %land.lhs.true.1444, label %lor.lhs.false.1447

land.lhs.true.1444:                               ; preds = %land.lhs.true.1440
  %333 = load i32, i32* %len, align 4
  %cmp1445 = icmp slt i32 0, %333
  br i1 %cmp1445, label %cond.true.1630, label %lor.lhs.false.1447

lor.lhs.false.1447:                               ; preds = %land.lhs.true.1444, %land.lhs.true.1440
  %334 = load i32, i32* %len, align 4
  %cmp1448 = icmp slt i32 %334, 0
  br i1 %cmp1448, label %land.lhs.true.1450, label %lor.lhs.false.1454

land.lhs.true.1450:                               ; preds = %lor.lhs.false.1447
  %335 = load i64, i64* %size, align 8
  %conv1451 = trunc i64 %335 to i32
  %cmp1452 = icmp slt i32 0, %conv1451
  br i1 %cmp1452, label %cond.true.1630, label %lor.lhs.false.1454

lor.lhs.false.1454:                               ; preds = %land.lhs.true.1450, %lor.lhs.false.1447, %cond.end.1436
  %336 = load i32, i32* %len, align 4
  %cmp1455 = icmp slt i32 %336, 0
  br i1 %cmp1455, label %cond.true.1457, label %cond.false.1535

cond.true.1457:                                   ; preds = %lor.lhs.false.1454
  %337 = load i64, i64* %size, align 8
  %conv1458 = trunc i64 %337 to i32
  %cmp1459 = icmp slt i32 %conv1458, 0
  br i1 %cmp1459, label %cond.true.1461, label %cond.false.1491

cond.true.1461:                                   ; preds = %cond.true.1457
  %338 = load i64, i64* %size, align 8
  %conv1462 = trunc i64 %338 to i32
  %339 = load i32, i32* %len, align 4
  %mul1463 = mul nsw i32 0, %339
  %340 = load i64, i64* %size, align 8
  %conv1464 = trunc i64 %340 to i32
  %add1465 = add nsw i32 %mul1463, %conv1464
  %mul1466 = mul nsw i32 0, %add1465
  %sub1467 = sub nsw i32 %mul1466, 1
  %cmp1468 = icmp slt i32 %sub1467, 0
  br i1 %cmp1468, label %cond.true.1470, label %cond.false.1480

cond.true.1470:                                   ; preds = %cond.true.1461
  %341 = load i32, i32* %len, align 4
  %mul1471 = mul nsw i32 0, %341
  %342 = load i64, i64* %size, align 8
  %conv1472 = trunc i64 %342 to i32
  %add1473 = add nsw i32 %mul1471, %conv1472
  %mul1474 = mul nsw i32 0, %add1473
  %add1475 = add nsw i32 %mul1474, 1
  %shl1476 = shl i32 %add1475, 30
  %sub1477 = sub nsw i32 %shl1476, 1
  %mul1478 = mul nsw i32 %sub1477, 2
  %add1479 = add nsw i32 %mul1478, 1
  br label %cond.end.1486

cond.false.1480:                                  ; preds = %cond.true.1461
  %343 = load i32, i32* %len, align 4
  %mul1481 = mul nsw i32 0, %343
  %344 = load i64, i64* %size, align 8
  %conv1482 = trunc i64 %344 to i32
  %add1483 = add nsw i32 %mul1481, %conv1482
  %mul1484 = mul nsw i32 0, %add1483
  %sub1485 = sub nsw i32 %mul1484, 1
  br label %cond.end.1486

cond.end.1486:                                    ; preds = %cond.false.1480, %cond.true.1470
  %cond1487 = phi i32 [ %add1479, %cond.true.1470 ], [ %sub1485, %cond.false.1480 ]
  %345 = load i32, i32* %len, align 4
  %div1488 = sdiv i32 %cond1487, %345
  %cmp1489 = icmp slt i32 %conv1462, %div1488
  br i1 %cmp1489, label %cond.true.1630, label %lor.lhs.false.1613

cond.false.1491:                                  ; preds = %cond.true.1457
  %346 = load i32, i32* %len, align 4
  %cmp1492 = icmp eq i32 %346, -1
  br i1 %cmp1492, label %cond.true.1494, label %cond.false.1495

cond.true.1494:                                   ; preds = %cond.false.1491
  br i1 false, label %cond.true.1630, label %lor.lhs.false.1613

cond.false.1495:                                  ; preds = %cond.false.1491
  %347 = load i32, i32* %len, align 4
  %mul1496 = mul nsw i32 0, %347
  %348 = load i64, i64* %size, align 8
  %conv1497 = trunc i64 %348 to i32
  %add1498 = add nsw i32 %mul1496, %conv1497
  %mul1499 = mul nsw i32 0, %add1498
  %sub1500 = sub nsw i32 %mul1499, 1
  %cmp1501 = icmp slt i32 %sub1500, 0
  br i1 %cmp1501, label %cond.true.1503, label %cond.false.1523

cond.true.1503:                                   ; preds = %cond.false.1495
  %349 = load i32, i32* %len, align 4
  %mul1504 = mul nsw i32 0, %349
  %350 = load i64, i64* %size, align 8
  %conv1505 = trunc i64 %350 to i32
  %add1506 = add nsw i32 %mul1504, %conv1505
  %mul1507 = mul nsw i32 0, %add1506
  %add1508 = add nsw i32 %mul1507, 0
  %neg1509 = xor i32 %add1508, -1
  %cmp1510 = icmp eq i32 %neg1509, -1
  %conv1511 = zext i1 %cmp1510 to i32
  %sub1512 = sub nsw i32 0, %conv1511
  %351 = load i32, i32* %len, align 4
  %mul1513 = mul nsw i32 0, %351
  %352 = load i64, i64* %size, align 8
  %conv1514 = trunc i64 %352 to i32
  %add1515 = add nsw i32 %mul1513, %conv1514
  %mul1516 = mul nsw i32 0, %add1515
  %add1517 = add nsw i32 %mul1516, 1
  %shl1518 = shl i32 %add1517, 30
  %sub1519 = sub nsw i32 %shl1518, 1
  %mul1520 = mul nsw i32 %sub1519, 2
  %add1521 = add nsw i32 %mul1520, 1
  %sub1522 = sub nsw i32 %sub1512, %add1521
  br label %cond.end.1529

cond.false.1523:                                  ; preds = %cond.false.1495
  %353 = load i32, i32* %len, align 4
  %mul1524 = mul nsw i32 0, %353
  %354 = load i64, i64* %size, align 8
  %conv1525 = trunc i64 %354 to i32
  %add1526 = add nsw i32 %mul1524, %conv1525
  %mul1527 = mul nsw i32 0, %add1526
  %add1528 = add nsw i32 %mul1527, 0
  br label %cond.end.1529

cond.end.1529:                                    ; preds = %cond.false.1523, %cond.true.1503
  %cond1530 = phi i32 [ %sub1522, %cond.true.1503 ], [ %add1528, %cond.false.1523 ]
  %355 = load i32, i32* %len, align 4
  %div1531 = sdiv i32 %cond1530, %355
  %356 = load i64, i64* %size, align 8
  %conv1532 = trunc i64 %356 to i32
  %cmp1533 = icmp slt i32 %div1531, %conv1532
  br i1 %cmp1533, label %cond.true.1630, label %lor.lhs.false.1613

cond.false.1535:                                  ; preds = %lor.lhs.false.1454
  %357 = load i32, i32* %len, align 4
  %cmp1536 = icmp eq i32 %357, 0
  br i1 %cmp1536, label %cond.true.1538, label %cond.false.1539

cond.true.1538:                                   ; preds = %cond.false.1535
  br i1 false, label %cond.true.1630, label %lor.lhs.false.1613

cond.false.1539:                                  ; preds = %cond.false.1535
  %358 = load i64, i64* %size, align 8
  %conv1540 = trunc i64 %358 to i32
  %cmp1541 = icmp slt i32 %conv1540, 0
  br i1 %cmp1541, label %cond.true.1543, label %cond.false.1583

cond.true.1543:                                   ; preds = %cond.false.1539
  %359 = load i64, i64* %size, align 8
  %conv1544 = trunc i64 %359 to i32
  %360 = load i32, i32* %len, align 4
  %mul1545 = mul nsw i32 0, %360
  %361 = load i64, i64* %size, align 8
  %conv1546 = trunc i64 %361 to i32
  %add1547 = add nsw i32 %mul1545, %conv1546
  %mul1548 = mul nsw i32 0, %add1547
  %sub1549 = sub nsw i32 %mul1548, 1
  %cmp1550 = icmp slt i32 %sub1549, 0
  br i1 %cmp1550, label %cond.true.1552, label %cond.false.1572

cond.true.1552:                                   ; preds = %cond.true.1543
  %362 = load i32, i32* %len, align 4
  %mul1553 = mul nsw i32 0, %362
  %363 = load i64, i64* %size, align 8
  %conv1554 = trunc i64 %363 to i32
  %add1555 = add nsw i32 %mul1553, %conv1554
  %mul1556 = mul nsw i32 0, %add1555
  %add1557 = add nsw i32 %mul1556, 0
  %neg1558 = xor i32 %add1557, -1
  %cmp1559 = icmp eq i32 %neg1558, -1
  %conv1560 = zext i1 %cmp1559 to i32
  %sub1561 = sub nsw i32 0, %conv1560
  %364 = load i32, i32* %len, align 4
  %mul1562 = mul nsw i32 0, %364
  %365 = load i64, i64* %size, align 8
  %conv1563 = trunc i64 %365 to i32
  %add1564 = add nsw i32 %mul1562, %conv1563
  %mul1565 = mul nsw i32 0, %add1564
  %add1566 = add nsw i32 %mul1565, 1
  %shl1567 = shl i32 %add1566, 30
  %sub1568 = sub nsw i32 %shl1567, 1
  %mul1569 = mul nsw i32 %sub1568, 2
  %add1570 = add nsw i32 %mul1569, 1
  %sub1571 = sub nsw i32 %sub1561, %add1570
  br label %cond.end.1578

cond.false.1572:                                  ; preds = %cond.true.1543
  %366 = load i32, i32* %len, align 4
  %mul1573 = mul nsw i32 0, %366
  %367 = load i64, i64* %size, align 8
  %conv1574 = trunc i64 %367 to i32
  %add1575 = add nsw i32 %mul1573, %conv1574
  %mul1576 = mul nsw i32 0, %add1575
  %add1577 = add nsw i32 %mul1576, 0
  br label %cond.end.1578

cond.end.1578:                                    ; preds = %cond.false.1572, %cond.true.1552
  %cond1579 = phi i32 [ %sub1571, %cond.true.1552 ], [ %add1577, %cond.false.1572 ]
  %368 = load i32, i32* %len, align 4
  %div1580 = sdiv i32 %cond1579, %368
  %cmp1581 = icmp slt i32 %conv1544, %div1580
  br i1 %cmp1581, label %cond.true.1630, label %lor.lhs.false.1613

cond.false.1583:                                  ; preds = %cond.false.1539
  %369 = load i32, i32* %len, align 4
  %mul1584 = mul nsw i32 0, %369
  %370 = load i64, i64* %size, align 8
  %conv1585 = trunc i64 %370 to i32
  %add1586 = add nsw i32 %mul1584, %conv1585
  %mul1587 = mul nsw i32 0, %add1586
  %sub1588 = sub nsw i32 %mul1587, 1
  %cmp1589 = icmp slt i32 %sub1588, 0
  br i1 %cmp1589, label %cond.true.1591, label %cond.false.1601

cond.true.1591:                                   ; preds = %cond.false.1583
  %371 = load i32, i32* %len, align 4
  %mul1592 = mul nsw i32 0, %371
  %372 = load i64, i64* %size, align 8
  %conv1593 = trunc i64 %372 to i32
  %add1594 = add nsw i32 %mul1592, %conv1593
  %mul1595 = mul nsw i32 0, %add1594
  %add1596 = add nsw i32 %mul1595, 1
  %shl1597 = shl i32 %add1596, 30
  %sub1598 = sub nsw i32 %shl1597, 1
  %mul1599 = mul nsw i32 %sub1598, 2
  %add1600 = add nsw i32 %mul1599, 1
  br label %cond.end.1607

cond.false.1601:                                  ; preds = %cond.false.1583
  %373 = load i32, i32* %len, align 4
  %mul1602 = mul nsw i32 0, %373
  %374 = load i64, i64* %size, align 8
  %conv1603 = trunc i64 %374 to i32
  %add1604 = add nsw i32 %mul1602, %conv1603
  %mul1605 = mul nsw i32 0, %add1604
  %sub1606 = sub nsw i32 %mul1605, 1
  br label %cond.end.1607

cond.end.1607:                                    ; preds = %cond.false.1601, %cond.true.1591
  %cond1608 = phi i32 [ %add1600, %cond.true.1591 ], [ %sub1606, %cond.false.1601 ]
  %375 = load i32, i32* %len, align 4
  %div1609 = sdiv i32 %cond1608, %375
  %376 = load i64, i64* %size, align 8
  %conv1610 = trunc i64 %376 to i32
  %cmp1611 = icmp slt i32 %div1609, %conv1610
  br i1 %cmp1611, label %cond.true.1630, label %lor.lhs.false.1613

lor.lhs.false.1613:                               ; preds = %cond.end.1607, %cond.end.1578, %cond.true.1538, %cond.end.1529, %cond.true.1494, %cond.end.1486
  %377 = load i64, i64* %size, align 8
  %conv1614 = trunc i64 %377 to i32
  %378 = load i32, i32* %len, align 4
  %mul1615 = mul nsw i32 %conv1614, %378
  %mul1616 = mul nsw i32 0, %mul1615
  %sub1617 = sub nsw i32 %mul1616, 1
  %cmp1618 = icmp slt i32 %sub1617, 0
  br i1 %cmp1618, label %land.lhs.true.1620, label %lor.lhs.false.1625

land.lhs.true.1620:                               ; preds = %lor.lhs.false.1613
  %379 = load i64, i64* %size, align 8
  %conv1621 = trunc i64 %379 to i32
  %380 = load i32, i32* %len, align 4
  %mul1622 = mul nsw i32 %conv1621, %380
  %cmp1623 = icmp slt i32 %mul1622, -2147483648
  br i1 %cmp1623, label %cond.true.1630, label %lor.lhs.false.1625

lor.lhs.false.1625:                               ; preds = %land.lhs.true.1620, %lor.lhs.false.1613
  %381 = load i64, i64* %size, align 8
  %conv1626 = trunc i64 %381 to i32
  %382 = load i32, i32* %len, align 4
  %mul1627 = mul nsw i32 %conv1626, %382
  %cmp1628 = icmp slt i32 2147483647, %mul1627
  br i1 %cmp1628, label %cond.true.1630, label %cond.false.1646

cond.true.1630:                                   ; preds = %lor.lhs.false.1625, %land.lhs.true.1620, %cond.end.1607, %cond.end.1578, %cond.true.1538, %cond.end.1529, %cond.true.1494, %cond.end.1486, %land.lhs.true.1450, %land.lhs.true.1444
  %383 = load i64, i64* %size, align 8
  %conv1631 = trunc i64 %383 to i32
  %384 = load i32, i32* %len, align 4
  %mul1632 = mul i32 %conv1631, %384
  %cmp1633 = icmp ule i32 %mul1632, 2147483647
  br i1 %cmp1633, label %cond.true.1635, label %cond.false.1638

cond.true.1635:                                   ; preds = %cond.true.1630
  %385 = load i64, i64* %size, align 8
  %conv1636 = trunc i64 %385 to i32
  %386 = load i32, i32* %len, align 4
  %mul1637 = mul i32 %conv1636, %386
  br label %cond.end.1643

cond.false.1638:                                  ; preds = %cond.true.1630
  %387 = load i64, i64* %size, align 8
  %conv1639 = trunc i64 %387 to i32
  %388 = load i32, i32* %len, align 4
  %mul1640 = mul i32 %conv1639, %388
  %sub1641 = sub i32 %mul1640, -2147483648
  %add1642 = add nsw i32 %sub1641, -2147483648
  br label %cond.end.1643

cond.end.1643:                                    ; preds = %cond.false.1638, %cond.true.1635
  %cond1644 = phi i32 [ %mul1637, %cond.true.1635 ], [ %add1642, %cond.false.1638 ]
  %conv1645 = sext i32 %cond1644 to i64
  store i64 %conv1645, i64* %product, align 8
  br i1 true, label %if.then.2965, label %lor.lhs.false.2962

cond.false.1646:                                  ; preds = %lor.lhs.false.1625
  %389 = load i64, i64* %size, align 8
  %conv1647 = trunc i64 %389 to i32
  %390 = load i32, i32* %len, align 4
  %mul1648 = mul i32 %conv1647, %390
  %cmp1649 = icmp ule i32 %mul1648, 2147483647
  br i1 %cmp1649, label %cond.true.1651, label %cond.false.1654

cond.true.1651:                                   ; preds = %cond.false.1646
  %391 = load i64, i64* %size, align 8
  %conv1652 = trunc i64 %391 to i32
  %392 = load i32, i32* %len, align 4
  %mul1653 = mul i32 %conv1652, %392
  br label %cond.end.1659

cond.false.1654:                                  ; preds = %cond.false.1646
  %393 = load i64, i64* %size, align 8
  %conv1655 = trunc i64 %393 to i32
  %394 = load i32, i32* %len, align 4
  %mul1656 = mul i32 %conv1655, %394
  %sub1657 = sub i32 %mul1656, -2147483648
  %add1658 = add nsw i32 %sub1657, -2147483648
  br label %cond.end.1659

cond.end.1659:                                    ; preds = %cond.false.1654, %cond.true.1651
  %cond1660 = phi i32 [ %mul1653, %cond.true.1651 ], [ %add1658, %cond.false.1654 ]
  %conv1661 = sext i32 %cond1660 to i64
  store i64 %conv1661, i64* %product, align 8
  br i1 false, label %if.then.2965, label %lor.lhs.false.2962

cond.false.1662:                                  ; preds = %cond.true.1401
  %395 = load i32, i32* %len, align 4
  %mul1663 = mul nsw i32 0, %395
  %conv1664 = sext i32 %mul1663 to i64
  %396 = load i64, i64* %size, align 8
  %add1665 = add nsw i64 %conv1664, %396
  %mul1666 = mul nsw i64 0, %add1665
  %sub1667 = sub nsw i64 %mul1666, 1
  %cmp1668 = icmp slt i64 %sub1667, 0
  br i1 %cmp1668, label %cond.true.1670, label %cond.false.1691

cond.true.1670:                                   ; preds = %cond.false.1662
  %397 = load i32, i32* %len, align 4
  %mul1671 = mul nsw i32 0, %397
  %conv1672 = sext i32 %mul1671 to i64
  %398 = load i64, i64* %size, align 8
  %add1673 = add nsw i64 %conv1672, %398
  %mul1674 = mul nsw i64 0, %add1673
  %add1675 = add nsw i64 %mul1674, 0
  %neg1676 = xor i64 %add1675, -1
  %cmp1677 = icmp eq i64 %neg1676, -1
  %conv1678 = zext i1 %cmp1677 to i32
  %sub1679 = sub nsw i32 0, %conv1678
  %conv1680 = sext i32 %sub1679 to i64
  %399 = load i32, i32* %len, align 4
  %mul1681 = mul nsw i32 0, %399
  %conv1682 = sext i32 %mul1681 to i64
  %400 = load i64, i64* %size, align 8
  %add1683 = add nsw i64 %conv1682, %400
  %mul1684 = mul nsw i64 0, %add1683
  %add1685 = add nsw i64 %mul1684, 1
  %shl1686 = shl i64 %add1685, 62
  %sub1687 = sub nsw i64 %shl1686, 1
  %mul1688 = mul nsw i64 %sub1687, 2
  %add1689 = add nsw i64 %mul1688, 1
  %sub1690 = sub nsw i64 %conv1680, %add1689
  br label %cond.end.1697

cond.false.1691:                                  ; preds = %cond.false.1662
  %401 = load i32, i32* %len, align 4
  %mul1692 = mul nsw i32 0, %401
  %conv1693 = sext i32 %mul1692 to i64
  %402 = load i64, i64* %size, align 8
  %add1694 = add nsw i64 %conv1693, %402
  %mul1695 = mul nsw i64 0, %add1694
  %add1696 = add nsw i64 %mul1695, 0
  br label %cond.end.1697

cond.end.1697:                                    ; preds = %cond.false.1691, %cond.true.1670
  %cond1698 = phi i64 [ %sub1690, %cond.true.1670 ], [ %add1696, %cond.false.1691 ]
  %cmp1699 = icmp eq i64 %cond1698, 0
  br i1 %cmp1699, label %land.lhs.true.1701, label %lor.lhs.false.1713

land.lhs.true.1701:                               ; preds = %cond.end.1697
  %403 = load i64, i64* %size, align 8
  %cmp1702 = icmp slt i64 %403, 0
  br i1 %cmp1702, label %land.lhs.true.1704, label %lor.lhs.false.1707

land.lhs.true.1704:                               ; preds = %land.lhs.true.1701
  %404 = load i32, i32* %len, align 4
  %cmp1705 = icmp slt i32 0, %404
  br i1 %cmp1705, label %cond.true.1889, label %lor.lhs.false.1707

lor.lhs.false.1707:                               ; preds = %land.lhs.true.1704, %land.lhs.true.1701
  %405 = load i32, i32* %len, align 4
  %cmp1708 = icmp slt i32 %405, 0
  br i1 %cmp1708, label %land.lhs.true.1710, label %lor.lhs.false.1713

land.lhs.true.1710:                               ; preds = %lor.lhs.false.1707
  %406 = load i64, i64* %size, align 8
  %cmp1711 = icmp slt i64 0, %406
  br i1 %cmp1711, label %cond.true.1889, label %lor.lhs.false.1713

lor.lhs.false.1713:                               ; preds = %land.lhs.true.1710, %lor.lhs.false.1707, %cond.end.1697
  %407 = load i32, i32* %len, align 4
  %cmp1714 = icmp slt i32 %407, 0
  br i1 %cmp1714, label %cond.true.1716, label %cond.false.1794

cond.true.1716:                                   ; preds = %lor.lhs.false.1713
  %408 = load i64, i64* %size, align 8
  %cmp1717 = icmp slt i64 %408, 0
  br i1 %cmp1717, label %cond.true.1719, label %cond.false.1749

cond.true.1719:                                   ; preds = %cond.true.1716
  %409 = load i64, i64* %size, align 8
  %410 = load i32, i32* %len, align 4
  %mul1720 = mul nsw i32 0, %410
  %conv1721 = sext i32 %mul1720 to i64
  %411 = load i64, i64* %size, align 8
  %add1722 = add nsw i64 %conv1721, %411
  %mul1723 = mul nsw i64 0, %add1722
  %sub1724 = sub nsw i64 %mul1723, 1
  %cmp1725 = icmp slt i64 %sub1724, 0
  br i1 %cmp1725, label %cond.true.1727, label %cond.false.1737

cond.true.1727:                                   ; preds = %cond.true.1719
  %412 = load i32, i32* %len, align 4
  %mul1728 = mul nsw i32 0, %412
  %conv1729 = sext i32 %mul1728 to i64
  %413 = load i64, i64* %size, align 8
  %add1730 = add nsw i64 %conv1729, %413
  %mul1731 = mul nsw i64 0, %add1730
  %add1732 = add nsw i64 %mul1731, 1
  %shl1733 = shl i64 %add1732, 62
  %sub1734 = sub nsw i64 %shl1733, 1
  %mul1735 = mul nsw i64 %sub1734, 2
  %add1736 = add nsw i64 %mul1735, 1
  br label %cond.end.1743

cond.false.1737:                                  ; preds = %cond.true.1719
  %414 = load i32, i32* %len, align 4
  %mul1738 = mul nsw i32 0, %414
  %conv1739 = sext i32 %mul1738 to i64
  %415 = load i64, i64* %size, align 8
  %add1740 = add nsw i64 %conv1739, %415
  %mul1741 = mul nsw i64 0, %add1740
  %sub1742 = sub nsw i64 %mul1741, 1
  br label %cond.end.1743

cond.end.1743:                                    ; preds = %cond.false.1737, %cond.true.1727
  %cond1744 = phi i64 [ %add1736, %cond.true.1727 ], [ %sub1742, %cond.false.1737 ]
  %416 = load i32, i32* %len, align 4
  %conv1745 = sext i32 %416 to i64
  %div1746 = sdiv i64 %cond1744, %conv1745
  %cmp1747 = icmp slt i64 %409, %div1746
  br i1 %cmp1747, label %cond.true.1889, label %lor.lhs.false.1872

cond.false.1749:                                  ; preds = %cond.true.1716
  %417 = load i32, i32* %len, align 4
  %cmp1750 = icmp eq i32 %417, -1
  br i1 %cmp1750, label %cond.true.1752, label %cond.false.1753

cond.true.1752:                                   ; preds = %cond.false.1749
  br i1 false, label %cond.true.1889, label %lor.lhs.false.1872

cond.false.1753:                                  ; preds = %cond.false.1749
  %418 = load i32, i32* %len, align 4
  %mul1754 = mul nsw i32 0, %418
  %conv1755 = sext i32 %mul1754 to i64
  %419 = load i64, i64* %size, align 8
  %add1756 = add nsw i64 %conv1755, %419
  %mul1757 = mul nsw i64 0, %add1756
  %sub1758 = sub nsw i64 %mul1757, 1
  %cmp1759 = icmp slt i64 %sub1758, 0
  br i1 %cmp1759, label %cond.true.1761, label %cond.false.1782

cond.true.1761:                                   ; preds = %cond.false.1753
  %420 = load i32, i32* %len, align 4
  %mul1762 = mul nsw i32 0, %420
  %conv1763 = sext i32 %mul1762 to i64
  %421 = load i64, i64* %size, align 8
  %add1764 = add nsw i64 %conv1763, %421
  %mul1765 = mul nsw i64 0, %add1764
  %add1766 = add nsw i64 %mul1765, 0
  %neg1767 = xor i64 %add1766, -1
  %cmp1768 = icmp eq i64 %neg1767, -1
  %conv1769 = zext i1 %cmp1768 to i32
  %sub1770 = sub nsw i32 0, %conv1769
  %conv1771 = sext i32 %sub1770 to i64
  %422 = load i32, i32* %len, align 4
  %mul1772 = mul nsw i32 0, %422
  %conv1773 = sext i32 %mul1772 to i64
  %423 = load i64, i64* %size, align 8
  %add1774 = add nsw i64 %conv1773, %423
  %mul1775 = mul nsw i64 0, %add1774
  %add1776 = add nsw i64 %mul1775, 1
  %shl1777 = shl i64 %add1776, 62
  %sub1778 = sub nsw i64 %shl1777, 1
  %mul1779 = mul nsw i64 %sub1778, 2
  %add1780 = add nsw i64 %mul1779, 1
  %sub1781 = sub nsw i64 %conv1771, %add1780
  br label %cond.end.1788

cond.false.1782:                                  ; preds = %cond.false.1753
  %424 = load i32, i32* %len, align 4
  %mul1783 = mul nsw i32 0, %424
  %conv1784 = sext i32 %mul1783 to i64
  %425 = load i64, i64* %size, align 8
  %add1785 = add nsw i64 %conv1784, %425
  %mul1786 = mul nsw i64 0, %add1785
  %add1787 = add nsw i64 %mul1786, 0
  br label %cond.end.1788

cond.end.1788:                                    ; preds = %cond.false.1782, %cond.true.1761
  %cond1789 = phi i64 [ %sub1781, %cond.true.1761 ], [ %add1787, %cond.false.1782 ]
  %426 = load i32, i32* %len, align 4
  %conv1790 = sext i32 %426 to i64
  %div1791 = sdiv i64 %cond1789, %conv1790
  %427 = load i64, i64* %size, align 8
  %cmp1792 = icmp slt i64 %div1791, %427
  br i1 %cmp1792, label %cond.true.1889, label %lor.lhs.false.1872

cond.false.1794:                                  ; preds = %lor.lhs.false.1713
  %428 = load i32, i32* %len, align 4
  %cmp1795 = icmp eq i32 %428, 0
  br i1 %cmp1795, label %cond.true.1797, label %cond.false.1798

cond.true.1797:                                   ; preds = %cond.false.1794
  br i1 false, label %cond.true.1889, label %lor.lhs.false.1872

cond.false.1798:                                  ; preds = %cond.false.1794
  %429 = load i64, i64* %size, align 8
  %cmp1799 = icmp slt i64 %429, 0
  br i1 %cmp1799, label %cond.true.1801, label %cond.false.1842

cond.true.1801:                                   ; preds = %cond.false.1798
  %430 = load i64, i64* %size, align 8
  %431 = load i32, i32* %len, align 4
  %mul1802 = mul nsw i32 0, %431
  %conv1803 = sext i32 %mul1802 to i64
  %432 = load i64, i64* %size, align 8
  %add1804 = add nsw i64 %conv1803, %432
  %mul1805 = mul nsw i64 0, %add1804
  %sub1806 = sub nsw i64 %mul1805, 1
  %cmp1807 = icmp slt i64 %sub1806, 0
  br i1 %cmp1807, label %cond.true.1809, label %cond.false.1830

cond.true.1809:                                   ; preds = %cond.true.1801
  %433 = load i32, i32* %len, align 4
  %mul1810 = mul nsw i32 0, %433
  %conv1811 = sext i32 %mul1810 to i64
  %434 = load i64, i64* %size, align 8
  %add1812 = add nsw i64 %conv1811, %434
  %mul1813 = mul nsw i64 0, %add1812
  %add1814 = add nsw i64 %mul1813, 0
  %neg1815 = xor i64 %add1814, -1
  %cmp1816 = icmp eq i64 %neg1815, -1
  %conv1817 = zext i1 %cmp1816 to i32
  %sub1818 = sub nsw i32 0, %conv1817
  %conv1819 = sext i32 %sub1818 to i64
  %435 = load i32, i32* %len, align 4
  %mul1820 = mul nsw i32 0, %435
  %conv1821 = sext i32 %mul1820 to i64
  %436 = load i64, i64* %size, align 8
  %add1822 = add nsw i64 %conv1821, %436
  %mul1823 = mul nsw i64 0, %add1822
  %add1824 = add nsw i64 %mul1823, 1
  %shl1825 = shl i64 %add1824, 62
  %sub1826 = sub nsw i64 %shl1825, 1
  %mul1827 = mul nsw i64 %sub1826, 2
  %add1828 = add nsw i64 %mul1827, 1
  %sub1829 = sub nsw i64 %conv1819, %add1828
  br label %cond.end.1836

cond.false.1830:                                  ; preds = %cond.true.1801
  %437 = load i32, i32* %len, align 4
  %mul1831 = mul nsw i32 0, %437
  %conv1832 = sext i32 %mul1831 to i64
  %438 = load i64, i64* %size, align 8
  %add1833 = add nsw i64 %conv1832, %438
  %mul1834 = mul nsw i64 0, %add1833
  %add1835 = add nsw i64 %mul1834, 0
  br label %cond.end.1836

cond.end.1836:                                    ; preds = %cond.false.1830, %cond.true.1809
  %cond1837 = phi i64 [ %sub1829, %cond.true.1809 ], [ %add1835, %cond.false.1830 ]
  %439 = load i32, i32* %len, align 4
  %conv1838 = sext i32 %439 to i64
  %div1839 = sdiv i64 %cond1837, %conv1838
  %cmp1840 = icmp slt i64 %430, %div1839
  br i1 %cmp1840, label %cond.true.1889, label %lor.lhs.false.1872

cond.false.1842:                                  ; preds = %cond.false.1798
  %440 = load i32, i32* %len, align 4
  %mul1843 = mul nsw i32 0, %440
  %conv1844 = sext i32 %mul1843 to i64
  %441 = load i64, i64* %size, align 8
  %add1845 = add nsw i64 %conv1844, %441
  %mul1846 = mul nsw i64 0, %add1845
  %sub1847 = sub nsw i64 %mul1846, 1
  %cmp1848 = icmp slt i64 %sub1847, 0
  br i1 %cmp1848, label %cond.true.1850, label %cond.false.1860

cond.true.1850:                                   ; preds = %cond.false.1842
  %442 = load i32, i32* %len, align 4
  %mul1851 = mul nsw i32 0, %442
  %conv1852 = sext i32 %mul1851 to i64
  %443 = load i64, i64* %size, align 8
  %add1853 = add nsw i64 %conv1852, %443
  %mul1854 = mul nsw i64 0, %add1853
  %add1855 = add nsw i64 %mul1854, 1
  %shl1856 = shl i64 %add1855, 62
  %sub1857 = sub nsw i64 %shl1856, 1
  %mul1858 = mul nsw i64 %sub1857, 2
  %add1859 = add nsw i64 %mul1858, 1
  br label %cond.end.1866

cond.false.1860:                                  ; preds = %cond.false.1842
  %444 = load i32, i32* %len, align 4
  %mul1861 = mul nsw i32 0, %444
  %conv1862 = sext i32 %mul1861 to i64
  %445 = load i64, i64* %size, align 8
  %add1863 = add nsw i64 %conv1862, %445
  %mul1864 = mul nsw i64 0, %add1863
  %sub1865 = sub nsw i64 %mul1864, 1
  br label %cond.end.1866

cond.end.1866:                                    ; preds = %cond.false.1860, %cond.true.1850
  %cond1867 = phi i64 [ %add1859, %cond.true.1850 ], [ %sub1865, %cond.false.1860 ]
  %446 = load i32, i32* %len, align 4
  %conv1868 = sext i32 %446 to i64
  %div1869 = sdiv i64 %cond1867, %conv1868
  %447 = load i64, i64* %size, align 8
  %cmp1870 = icmp slt i64 %div1869, %447
  br i1 %cmp1870, label %cond.true.1889, label %lor.lhs.false.1872

lor.lhs.false.1872:                               ; preds = %cond.end.1866, %cond.end.1836, %cond.true.1797, %cond.end.1788, %cond.true.1752, %cond.end.1743
  %448 = load i64, i64* %size, align 8
  %449 = load i32, i32* %len, align 4
  %conv1873 = sext i32 %449 to i64
  %mul1874 = mul nsw i64 %448, %conv1873
  %mul1875 = mul nsw i64 0, %mul1874
  %sub1876 = sub nsw i64 %mul1875, 1
  %cmp1877 = icmp slt i64 %sub1876, 0
  br i1 %cmp1877, label %land.lhs.true.1879, label %lor.lhs.false.1884

land.lhs.true.1879:                               ; preds = %lor.lhs.false.1872
  %450 = load i64, i64* %size, align 8
  %451 = load i32, i32* %len, align 4
  %conv1880 = sext i32 %451 to i64
  %mul1881 = mul nsw i64 %450, %conv1880
  %cmp1882 = icmp slt i64 %mul1881, -2147483648
  br i1 %cmp1882, label %cond.true.1889, label %lor.lhs.false.1884

lor.lhs.false.1884:                               ; preds = %land.lhs.true.1879, %lor.lhs.false.1872
  %452 = load i64, i64* %size, align 8
  %453 = load i32, i32* %len, align 4
  %conv1885 = sext i32 %453 to i64
  %mul1886 = mul nsw i64 %452, %conv1885
  %cmp1887 = icmp slt i64 2147483647, %mul1886
  br i1 %cmp1887, label %cond.true.1889, label %cond.false.1905

cond.true.1889:                                   ; preds = %lor.lhs.false.1884, %land.lhs.true.1879, %cond.end.1866, %cond.end.1836, %cond.true.1797, %cond.end.1788, %cond.true.1752, %cond.end.1743, %land.lhs.true.1710, %land.lhs.true.1704
  %454 = load i64, i64* %size, align 8
  %conv1890 = trunc i64 %454 to i32
  %455 = load i32, i32* %len, align 4
  %mul1891 = mul i32 %conv1890, %455
  %cmp1892 = icmp ule i32 %mul1891, 2147483647
  br i1 %cmp1892, label %cond.true.1894, label %cond.false.1897

cond.true.1894:                                   ; preds = %cond.true.1889
  %456 = load i64, i64* %size, align 8
  %conv1895 = trunc i64 %456 to i32
  %457 = load i32, i32* %len, align 4
  %mul1896 = mul i32 %conv1895, %457
  br label %cond.end.1902

cond.false.1897:                                  ; preds = %cond.true.1889
  %458 = load i64, i64* %size, align 8
  %conv1898 = trunc i64 %458 to i32
  %459 = load i32, i32* %len, align 4
  %mul1899 = mul i32 %conv1898, %459
  %sub1900 = sub i32 %mul1899, -2147483648
  %add1901 = add nsw i32 %sub1900, -2147483648
  br label %cond.end.1902

cond.end.1902:                                    ; preds = %cond.false.1897, %cond.true.1894
  %cond1903 = phi i32 [ %mul1896, %cond.true.1894 ], [ %add1901, %cond.false.1897 ]
  %conv1904 = sext i32 %cond1903 to i64
  store i64 %conv1904, i64* %product, align 8
  br i1 true, label %if.then.2965, label %lor.lhs.false.2962

cond.false.1905:                                  ; preds = %lor.lhs.false.1884
  %460 = load i64, i64* %size, align 8
  %conv1906 = trunc i64 %460 to i32
  %461 = load i32, i32* %len, align 4
  %mul1907 = mul i32 %conv1906, %461
  %cmp1908 = icmp ule i32 %mul1907, 2147483647
  br i1 %cmp1908, label %cond.true.1910, label %cond.false.1913

cond.true.1910:                                   ; preds = %cond.false.1905
  %462 = load i64, i64* %size, align 8
  %conv1911 = trunc i64 %462 to i32
  %463 = load i32, i32* %len, align 4
  %mul1912 = mul i32 %conv1911, %463
  br label %cond.end.1918

cond.false.1913:                                  ; preds = %cond.false.1905
  %464 = load i64, i64* %size, align 8
  %conv1914 = trunc i64 %464 to i32
  %465 = load i32, i32* %len, align 4
  %mul1915 = mul i32 %conv1914, %465
  %sub1916 = sub i32 %mul1915, -2147483648
  %add1917 = add nsw i32 %sub1916, -2147483648
  br label %cond.end.1918

cond.end.1918:                                    ; preds = %cond.false.1913, %cond.true.1910
  %cond1919 = phi i32 [ %mul1912, %cond.true.1910 ], [ %add1917, %cond.false.1913 ]
  %conv1920 = sext i32 %cond1919 to i64
  store i64 %conv1920, i64* %product, align 8
  br i1 false, label %if.then.2965, label %lor.lhs.false.2962

cond.false.1921:                                  ; preds = %cond.false.1400
  br i1 true, label %cond.true.1922, label %cond.false.2442

cond.true.1922:                                   ; preds = %cond.false.1921
  br i1 false, label %cond.true.1923, label %cond.false.2185

cond.true.1923:                                   ; preds = %cond.true.1922
  %466 = load i32, i32* %len, align 4
  %conv1924 = sext i32 %466 to i64
  %mul1925 = mul nsw i64 0, %conv1924
  %467 = load i64, i64* %size, align 8
  %add1926 = add nsw i64 %mul1925, %467
  %mul1927 = mul nsw i64 0, %add1926
  %sub1928 = sub nsw i64 %mul1927, 1
  %cmp1929 = icmp slt i64 %sub1928, 0
  br i1 %cmp1929, label %cond.true.1931, label %cond.false.1952

cond.true.1931:                                   ; preds = %cond.true.1923
  %468 = load i32, i32* %len, align 4
  %conv1932 = sext i32 %468 to i64
  %mul1933 = mul nsw i64 0, %conv1932
  %469 = load i64, i64* %size, align 8
  %add1934 = add nsw i64 %mul1933, %469
  %mul1935 = mul nsw i64 0, %add1934
  %add1936 = add nsw i64 %mul1935, 0
  %neg1937 = xor i64 %add1936, -1
  %cmp1938 = icmp eq i64 %neg1937, -1
  %conv1939 = zext i1 %cmp1938 to i32
  %sub1940 = sub nsw i32 0, %conv1939
  %conv1941 = sext i32 %sub1940 to i64
  %470 = load i32, i32* %len, align 4
  %conv1942 = sext i32 %470 to i64
  %mul1943 = mul nsw i64 0, %conv1942
  %471 = load i64, i64* %size, align 8
  %add1944 = add nsw i64 %mul1943, %471
  %mul1945 = mul nsw i64 0, %add1944
  %add1946 = add nsw i64 %mul1945, 1
  %shl1947 = shl i64 %add1946, 62
  %sub1948 = sub nsw i64 %shl1947, 1
  %mul1949 = mul nsw i64 %sub1948, 2
  %add1950 = add nsw i64 %mul1949, 1
  %sub1951 = sub nsw i64 %conv1941, %add1950
  br label %cond.end.1958

cond.false.1952:                                  ; preds = %cond.true.1923
  %472 = load i32, i32* %len, align 4
  %conv1953 = sext i32 %472 to i64
  %mul1954 = mul nsw i64 0, %conv1953
  %473 = load i64, i64* %size, align 8
  %add1955 = add nsw i64 %mul1954, %473
  %mul1956 = mul nsw i64 0, %add1955
  %add1957 = add nsw i64 %mul1956, 0
  br label %cond.end.1958

cond.end.1958:                                    ; preds = %cond.false.1952, %cond.true.1931
  %cond1959 = phi i64 [ %sub1951, %cond.true.1931 ], [ %add1957, %cond.false.1952 ]
  %cmp1960 = icmp eq i64 %cond1959, 0
  br i1 %cmp1960, label %land.lhs.true.1962, label %lor.lhs.false.1976

land.lhs.true.1962:                               ; preds = %cond.end.1958
  %474 = load i64, i64* %size, align 8
  %cmp1963 = icmp slt i64 %474, 0
  br i1 %cmp1963, label %land.lhs.true.1965, label %lor.lhs.false.1969

land.lhs.true.1965:                               ; preds = %land.lhs.true.1962
  %475 = load i32, i32* %len, align 4
  %conv1966 = sext i32 %475 to i64
  %cmp1967 = icmp slt i64 0, %conv1966
  br i1 %cmp1967, label %cond.true.2155, label %lor.lhs.false.1969

lor.lhs.false.1969:                               ; preds = %land.lhs.true.1965, %land.lhs.true.1962
  %476 = load i32, i32* %len, align 4
  %conv1970 = sext i32 %476 to i64
  %cmp1971 = icmp slt i64 %conv1970, 0
  br i1 %cmp1971, label %land.lhs.true.1973, label %lor.lhs.false.1976

land.lhs.true.1973:                               ; preds = %lor.lhs.false.1969
  %477 = load i64, i64* %size, align 8
  %cmp1974 = icmp slt i64 0, %477
  br i1 %cmp1974, label %cond.true.2155, label %lor.lhs.false.1976

lor.lhs.false.1976:                               ; preds = %land.lhs.true.1973, %lor.lhs.false.1969, %cond.end.1958
  %478 = load i32, i32* %len, align 4
  %conv1977 = sext i32 %478 to i64
  %cmp1978 = icmp slt i64 %conv1977, 0
  br i1 %cmp1978, label %cond.true.1980, label %cond.false.2059

cond.true.1980:                                   ; preds = %lor.lhs.false.1976
  %479 = load i64, i64* %size, align 8
  %cmp1981 = icmp slt i64 %479, 0
  br i1 %cmp1981, label %cond.true.1983, label %cond.false.2013

cond.true.1983:                                   ; preds = %cond.true.1980
  %480 = load i64, i64* %size, align 8
  %481 = load i32, i32* %len, align 4
  %conv1984 = sext i32 %481 to i64
  %mul1985 = mul nsw i64 0, %conv1984
  %482 = load i64, i64* %size, align 8
  %add1986 = add nsw i64 %mul1985, %482
  %mul1987 = mul nsw i64 0, %add1986
  %sub1988 = sub nsw i64 %mul1987, 1
  %cmp1989 = icmp slt i64 %sub1988, 0
  br i1 %cmp1989, label %cond.true.1991, label %cond.false.2001

cond.true.1991:                                   ; preds = %cond.true.1983
  %483 = load i32, i32* %len, align 4
  %conv1992 = sext i32 %483 to i64
  %mul1993 = mul nsw i64 0, %conv1992
  %484 = load i64, i64* %size, align 8
  %add1994 = add nsw i64 %mul1993, %484
  %mul1995 = mul nsw i64 0, %add1994
  %add1996 = add nsw i64 %mul1995, 1
  %shl1997 = shl i64 %add1996, 62
  %sub1998 = sub nsw i64 %shl1997, 1
  %mul1999 = mul nsw i64 %sub1998, 2
  %add2000 = add nsw i64 %mul1999, 1
  br label %cond.end.2007

cond.false.2001:                                  ; preds = %cond.true.1983
  %485 = load i32, i32* %len, align 4
  %conv2002 = sext i32 %485 to i64
  %mul2003 = mul nsw i64 0, %conv2002
  %486 = load i64, i64* %size, align 8
  %add2004 = add nsw i64 %mul2003, %486
  %mul2005 = mul nsw i64 0, %add2004
  %sub2006 = sub nsw i64 %mul2005, 1
  br label %cond.end.2007

cond.end.2007:                                    ; preds = %cond.false.2001, %cond.true.1991
  %cond2008 = phi i64 [ %add2000, %cond.true.1991 ], [ %sub2006, %cond.false.2001 ]
  %487 = load i32, i32* %len, align 4
  %conv2009 = sext i32 %487 to i64
  %div2010 = sdiv i64 %cond2008, %conv2009
  %cmp2011 = icmp slt i64 %480, %div2010
  br i1 %cmp2011, label %cond.true.2155, label %lor.lhs.false.2138

cond.false.2013:                                  ; preds = %cond.true.1980
  %488 = load i32, i32* %len, align 4
  %conv2014 = sext i32 %488 to i64
  %cmp2015 = icmp eq i64 %conv2014, -1
  br i1 %cmp2015, label %cond.true.2017, label %cond.false.2018

cond.true.2017:                                   ; preds = %cond.false.2013
  br i1 false, label %cond.true.2155, label %lor.lhs.false.2138

cond.false.2018:                                  ; preds = %cond.false.2013
  %489 = load i32, i32* %len, align 4
  %conv2019 = sext i32 %489 to i64
  %mul2020 = mul nsw i64 0, %conv2019
  %490 = load i64, i64* %size, align 8
  %add2021 = add nsw i64 %mul2020, %490
  %mul2022 = mul nsw i64 0, %add2021
  %sub2023 = sub nsw i64 %mul2022, 1
  %cmp2024 = icmp slt i64 %sub2023, 0
  br i1 %cmp2024, label %cond.true.2026, label %cond.false.2047

cond.true.2026:                                   ; preds = %cond.false.2018
  %491 = load i32, i32* %len, align 4
  %conv2027 = sext i32 %491 to i64
  %mul2028 = mul nsw i64 0, %conv2027
  %492 = load i64, i64* %size, align 8
  %add2029 = add nsw i64 %mul2028, %492
  %mul2030 = mul nsw i64 0, %add2029
  %add2031 = add nsw i64 %mul2030, 0
  %neg2032 = xor i64 %add2031, -1
  %cmp2033 = icmp eq i64 %neg2032, -1
  %conv2034 = zext i1 %cmp2033 to i32
  %sub2035 = sub nsw i32 0, %conv2034
  %conv2036 = sext i32 %sub2035 to i64
  %493 = load i32, i32* %len, align 4
  %conv2037 = sext i32 %493 to i64
  %mul2038 = mul nsw i64 0, %conv2037
  %494 = load i64, i64* %size, align 8
  %add2039 = add nsw i64 %mul2038, %494
  %mul2040 = mul nsw i64 0, %add2039
  %add2041 = add nsw i64 %mul2040, 1
  %shl2042 = shl i64 %add2041, 62
  %sub2043 = sub nsw i64 %shl2042, 1
  %mul2044 = mul nsw i64 %sub2043, 2
  %add2045 = add nsw i64 %mul2044, 1
  %sub2046 = sub nsw i64 %conv2036, %add2045
  br label %cond.end.2053

cond.false.2047:                                  ; preds = %cond.false.2018
  %495 = load i32, i32* %len, align 4
  %conv2048 = sext i32 %495 to i64
  %mul2049 = mul nsw i64 0, %conv2048
  %496 = load i64, i64* %size, align 8
  %add2050 = add nsw i64 %mul2049, %496
  %mul2051 = mul nsw i64 0, %add2050
  %add2052 = add nsw i64 %mul2051, 0
  br label %cond.end.2053

cond.end.2053:                                    ; preds = %cond.false.2047, %cond.true.2026
  %cond2054 = phi i64 [ %sub2046, %cond.true.2026 ], [ %add2052, %cond.false.2047 ]
  %497 = load i32, i32* %len, align 4
  %conv2055 = sext i32 %497 to i64
  %div2056 = sdiv i64 %cond2054, %conv2055
  %498 = load i64, i64* %size, align 8
  %cmp2057 = icmp slt i64 %div2056, %498
  br i1 %cmp2057, label %cond.true.2155, label %lor.lhs.false.2138

cond.false.2059:                                  ; preds = %lor.lhs.false.1976
  %499 = load i32, i32* %len, align 4
  %conv2060 = sext i32 %499 to i64
  %cmp2061 = icmp eq i64 %conv2060, 0
  br i1 %cmp2061, label %cond.true.2063, label %cond.false.2064

cond.true.2063:                                   ; preds = %cond.false.2059
  br i1 false, label %cond.true.2155, label %lor.lhs.false.2138

cond.false.2064:                                  ; preds = %cond.false.2059
  %500 = load i64, i64* %size, align 8
  %cmp2065 = icmp slt i64 %500, 0
  br i1 %cmp2065, label %cond.true.2067, label %cond.false.2108

cond.true.2067:                                   ; preds = %cond.false.2064
  %501 = load i64, i64* %size, align 8
  %502 = load i32, i32* %len, align 4
  %conv2068 = sext i32 %502 to i64
  %mul2069 = mul nsw i64 0, %conv2068
  %503 = load i64, i64* %size, align 8
  %add2070 = add nsw i64 %mul2069, %503
  %mul2071 = mul nsw i64 0, %add2070
  %sub2072 = sub nsw i64 %mul2071, 1
  %cmp2073 = icmp slt i64 %sub2072, 0
  br i1 %cmp2073, label %cond.true.2075, label %cond.false.2096

cond.true.2075:                                   ; preds = %cond.true.2067
  %504 = load i32, i32* %len, align 4
  %conv2076 = sext i32 %504 to i64
  %mul2077 = mul nsw i64 0, %conv2076
  %505 = load i64, i64* %size, align 8
  %add2078 = add nsw i64 %mul2077, %505
  %mul2079 = mul nsw i64 0, %add2078
  %add2080 = add nsw i64 %mul2079, 0
  %neg2081 = xor i64 %add2080, -1
  %cmp2082 = icmp eq i64 %neg2081, -1
  %conv2083 = zext i1 %cmp2082 to i32
  %sub2084 = sub nsw i32 0, %conv2083
  %conv2085 = sext i32 %sub2084 to i64
  %506 = load i32, i32* %len, align 4
  %conv2086 = sext i32 %506 to i64
  %mul2087 = mul nsw i64 0, %conv2086
  %507 = load i64, i64* %size, align 8
  %add2088 = add nsw i64 %mul2087, %507
  %mul2089 = mul nsw i64 0, %add2088
  %add2090 = add nsw i64 %mul2089, 1
  %shl2091 = shl i64 %add2090, 62
  %sub2092 = sub nsw i64 %shl2091, 1
  %mul2093 = mul nsw i64 %sub2092, 2
  %add2094 = add nsw i64 %mul2093, 1
  %sub2095 = sub nsw i64 %conv2085, %add2094
  br label %cond.end.2102

cond.false.2096:                                  ; preds = %cond.true.2067
  %508 = load i32, i32* %len, align 4
  %conv2097 = sext i32 %508 to i64
  %mul2098 = mul nsw i64 0, %conv2097
  %509 = load i64, i64* %size, align 8
  %add2099 = add nsw i64 %mul2098, %509
  %mul2100 = mul nsw i64 0, %add2099
  %add2101 = add nsw i64 %mul2100, 0
  br label %cond.end.2102

cond.end.2102:                                    ; preds = %cond.false.2096, %cond.true.2075
  %cond2103 = phi i64 [ %sub2095, %cond.true.2075 ], [ %add2101, %cond.false.2096 ]
  %510 = load i32, i32* %len, align 4
  %conv2104 = sext i32 %510 to i64
  %div2105 = sdiv i64 %cond2103, %conv2104
  %cmp2106 = icmp slt i64 %501, %div2105
  br i1 %cmp2106, label %cond.true.2155, label %lor.lhs.false.2138

cond.false.2108:                                  ; preds = %cond.false.2064
  %511 = load i32, i32* %len, align 4
  %conv2109 = sext i32 %511 to i64
  %mul2110 = mul nsw i64 0, %conv2109
  %512 = load i64, i64* %size, align 8
  %add2111 = add nsw i64 %mul2110, %512
  %mul2112 = mul nsw i64 0, %add2111
  %sub2113 = sub nsw i64 %mul2112, 1
  %cmp2114 = icmp slt i64 %sub2113, 0
  br i1 %cmp2114, label %cond.true.2116, label %cond.false.2126

cond.true.2116:                                   ; preds = %cond.false.2108
  %513 = load i32, i32* %len, align 4
  %conv2117 = sext i32 %513 to i64
  %mul2118 = mul nsw i64 0, %conv2117
  %514 = load i64, i64* %size, align 8
  %add2119 = add nsw i64 %mul2118, %514
  %mul2120 = mul nsw i64 0, %add2119
  %add2121 = add nsw i64 %mul2120, 1
  %shl2122 = shl i64 %add2121, 62
  %sub2123 = sub nsw i64 %shl2122, 1
  %mul2124 = mul nsw i64 %sub2123, 2
  %add2125 = add nsw i64 %mul2124, 1
  br label %cond.end.2132

cond.false.2126:                                  ; preds = %cond.false.2108
  %515 = load i32, i32* %len, align 4
  %conv2127 = sext i32 %515 to i64
  %mul2128 = mul nsw i64 0, %conv2127
  %516 = load i64, i64* %size, align 8
  %add2129 = add nsw i64 %mul2128, %516
  %mul2130 = mul nsw i64 0, %add2129
  %sub2131 = sub nsw i64 %mul2130, 1
  br label %cond.end.2132

cond.end.2132:                                    ; preds = %cond.false.2126, %cond.true.2116
  %cond2133 = phi i64 [ %add2125, %cond.true.2116 ], [ %sub2131, %cond.false.2126 ]
  %517 = load i32, i32* %len, align 4
  %conv2134 = sext i32 %517 to i64
  %div2135 = sdiv i64 %cond2133, %conv2134
  %518 = load i64, i64* %size, align 8
  %cmp2136 = icmp slt i64 %div2135, %518
  br i1 %cmp2136, label %cond.true.2155, label %lor.lhs.false.2138

lor.lhs.false.2138:                               ; preds = %cond.end.2132, %cond.end.2102, %cond.true.2063, %cond.end.2053, %cond.true.2017, %cond.end.2007
  %519 = load i64, i64* %size, align 8
  %520 = load i32, i32* %len, align 4
  %conv2139 = sext i32 %520 to i64
  %mul2140 = mul nsw i64 %519, %conv2139
  %mul2141 = mul nsw i64 0, %mul2140
  %sub2142 = sub nsw i64 %mul2141, 1
  %cmp2143 = icmp slt i64 %sub2142, 0
  br i1 %cmp2143, label %land.lhs.true.2145, label %lor.lhs.false.2150

land.lhs.true.2145:                               ; preds = %lor.lhs.false.2138
  %521 = load i64, i64* %size, align 8
  %522 = load i32, i32* %len, align 4
  %conv2146 = sext i32 %522 to i64
  %mul2147 = mul nsw i64 %521, %conv2146
  %cmp2148 = icmp slt i64 %mul2147, -9223372036854775808
  br i1 %cmp2148, label %cond.true.2155, label %lor.lhs.false.2150

lor.lhs.false.2150:                               ; preds = %land.lhs.true.2145, %lor.lhs.false.2138
  %523 = load i64, i64* %size, align 8
  %524 = load i32, i32* %len, align 4
  %conv2151 = sext i32 %524 to i64
  %mul2152 = mul nsw i64 %523, %conv2151
  %cmp2153 = icmp slt i64 9223372036854775807, %mul2152
  br i1 %cmp2153, label %cond.true.2155, label %cond.false.2170

cond.true.2155:                                   ; preds = %lor.lhs.false.2150, %land.lhs.true.2145, %cond.end.2132, %cond.end.2102, %cond.true.2063, %cond.end.2053, %cond.true.2017, %cond.end.2007, %land.lhs.true.1973, %land.lhs.true.1965
  %525 = load i64, i64* %size, align 8
  %526 = load i32, i32* %len, align 4
  %conv2156 = sext i32 %526 to i64
  %mul2157 = mul i64 %525, %conv2156
  %cmp2158 = icmp ule i64 %mul2157, 9223372036854775807
  br i1 %cmp2158, label %cond.true.2160, label %cond.false.2163

cond.true.2160:                                   ; preds = %cond.true.2155
  %527 = load i64, i64* %size, align 8
  %528 = load i32, i32* %len, align 4
  %conv2161 = sext i32 %528 to i64
  %mul2162 = mul i64 %527, %conv2161
  br label %cond.end.2168

cond.false.2163:                                  ; preds = %cond.true.2155
  %529 = load i64, i64* %size, align 8
  %530 = load i32, i32* %len, align 4
  %conv2164 = sext i32 %530 to i64
  %mul2165 = mul i64 %529, %conv2164
  %sub2166 = sub i64 %mul2165, -9223372036854775808
  %add2167 = add nsw i64 %sub2166, -9223372036854775808
  br label %cond.end.2168

cond.end.2168:                                    ; preds = %cond.false.2163, %cond.true.2160
  %cond2169 = phi i64 [ %mul2162, %cond.true.2160 ], [ %add2167, %cond.false.2163 ]
  store i64 %cond2169, i64* %product, align 8
  br i1 true, label %if.then.2965, label %lor.lhs.false.2962

cond.false.2170:                                  ; preds = %lor.lhs.false.2150
  %531 = load i64, i64* %size, align 8
  %532 = load i32, i32* %len, align 4
  %conv2171 = sext i32 %532 to i64
  %mul2172 = mul i64 %531, %conv2171
  %cmp2173 = icmp ule i64 %mul2172, 9223372036854775807
  br i1 %cmp2173, label %cond.true.2175, label %cond.false.2178

cond.true.2175:                                   ; preds = %cond.false.2170
  %533 = load i64, i64* %size, align 8
  %534 = load i32, i32* %len, align 4
  %conv2176 = sext i32 %534 to i64
  %mul2177 = mul i64 %533, %conv2176
  br label %cond.end.2183

cond.false.2178:                                  ; preds = %cond.false.2170
  %535 = load i64, i64* %size, align 8
  %536 = load i32, i32* %len, align 4
  %conv2179 = sext i32 %536 to i64
  %mul2180 = mul i64 %535, %conv2179
  %sub2181 = sub i64 %mul2180, -9223372036854775808
  %add2182 = add nsw i64 %sub2181, -9223372036854775808
  br label %cond.end.2183

cond.end.2183:                                    ; preds = %cond.false.2178, %cond.true.2175
  %cond2184 = phi i64 [ %mul2177, %cond.true.2175 ], [ %add2182, %cond.false.2178 ]
  store i64 %cond2184, i64* %product, align 8
  br i1 false, label %if.then.2965, label %lor.lhs.false.2962

cond.false.2185:                                  ; preds = %cond.true.1922
  %537 = load i32, i32* %len, align 4
  %mul2186 = mul nsw i32 0, %537
  %conv2187 = sext i32 %mul2186 to i64
  %538 = load i64, i64* %size, align 8
  %add2188 = add nsw i64 %conv2187, %538
  %mul2189 = mul nsw i64 0, %add2188
  %sub2190 = sub nsw i64 %mul2189, 1
  %cmp2191 = icmp slt i64 %sub2190, 0
  br i1 %cmp2191, label %cond.true.2193, label %cond.false.2214

cond.true.2193:                                   ; preds = %cond.false.2185
  %539 = load i32, i32* %len, align 4
  %mul2194 = mul nsw i32 0, %539
  %conv2195 = sext i32 %mul2194 to i64
  %540 = load i64, i64* %size, align 8
  %add2196 = add nsw i64 %conv2195, %540
  %mul2197 = mul nsw i64 0, %add2196
  %add2198 = add nsw i64 %mul2197, 0
  %neg2199 = xor i64 %add2198, -1
  %cmp2200 = icmp eq i64 %neg2199, -1
  %conv2201 = zext i1 %cmp2200 to i32
  %sub2202 = sub nsw i32 0, %conv2201
  %conv2203 = sext i32 %sub2202 to i64
  %541 = load i32, i32* %len, align 4
  %mul2204 = mul nsw i32 0, %541
  %conv2205 = sext i32 %mul2204 to i64
  %542 = load i64, i64* %size, align 8
  %add2206 = add nsw i64 %conv2205, %542
  %mul2207 = mul nsw i64 0, %add2206
  %add2208 = add nsw i64 %mul2207, 1
  %shl2209 = shl i64 %add2208, 62
  %sub2210 = sub nsw i64 %shl2209, 1
  %mul2211 = mul nsw i64 %sub2210, 2
  %add2212 = add nsw i64 %mul2211, 1
  %sub2213 = sub nsw i64 %conv2203, %add2212
  br label %cond.end.2220

cond.false.2214:                                  ; preds = %cond.false.2185
  %543 = load i32, i32* %len, align 4
  %mul2215 = mul nsw i32 0, %543
  %conv2216 = sext i32 %mul2215 to i64
  %544 = load i64, i64* %size, align 8
  %add2217 = add nsw i64 %conv2216, %544
  %mul2218 = mul nsw i64 0, %add2217
  %add2219 = add nsw i64 %mul2218, 0
  br label %cond.end.2220

cond.end.2220:                                    ; preds = %cond.false.2214, %cond.true.2193
  %cond2221 = phi i64 [ %sub2213, %cond.true.2193 ], [ %add2219, %cond.false.2214 ]
  %cmp2222 = icmp eq i64 %cond2221, 0
  br i1 %cmp2222, label %land.lhs.true.2224, label %lor.lhs.false.2236

land.lhs.true.2224:                               ; preds = %cond.end.2220
  %545 = load i64, i64* %size, align 8
  %cmp2225 = icmp slt i64 %545, 0
  br i1 %cmp2225, label %land.lhs.true.2227, label %lor.lhs.false.2230

land.lhs.true.2227:                               ; preds = %land.lhs.true.2224
  %546 = load i32, i32* %len, align 4
  %cmp2228 = icmp slt i32 0, %546
  br i1 %cmp2228, label %cond.true.2412, label %lor.lhs.false.2230

lor.lhs.false.2230:                               ; preds = %land.lhs.true.2227, %land.lhs.true.2224
  %547 = load i32, i32* %len, align 4
  %cmp2231 = icmp slt i32 %547, 0
  br i1 %cmp2231, label %land.lhs.true.2233, label %lor.lhs.false.2236

land.lhs.true.2233:                               ; preds = %lor.lhs.false.2230
  %548 = load i64, i64* %size, align 8
  %cmp2234 = icmp slt i64 0, %548
  br i1 %cmp2234, label %cond.true.2412, label %lor.lhs.false.2236

lor.lhs.false.2236:                               ; preds = %land.lhs.true.2233, %lor.lhs.false.2230, %cond.end.2220
  %549 = load i32, i32* %len, align 4
  %cmp2237 = icmp slt i32 %549, 0
  br i1 %cmp2237, label %cond.true.2239, label %cond.false.2317

cond.true.2239:                                   ; preds = %lor.lhs.false.2236
  %550 = load i64, i64* %size, align 8
  %cmp2240 = icmp slt i64 %550, 0
  br i1 %cmp2240, label %cond.true.2242, label %cond.false.2272

cond.true.2242:                                   ; preds = %cond.true.2239
  %551 = load i64, i64* %size, align 8
  %552 = load i32, i32* %len, align 4
  %mul2243 = mul nsw i32 0, %552
  %conv2244 = sext i32 %mul2243 to i64
  %553 = load i64, i64* %size, align 8
  %add2245 = add nsw i64 %conv2244, %553
  %mul2246 = mul nsw i64 0, %add2245
  %sub2247 = sub nsw i64 %mul2246, 1
  %cmp2248 = icmp slt i64 %sub2247, 0
  br i1 %cmp2248, label %cond.true.2250, label %cond.false.2260

cond.true.2250:                                   ; preds = %cond.true.2242
  %554 = load i32, i32* %len, align 4
  %mul2251 = mul nsw i32 0, %554
  %conv2252 = sext i32 %mul2251 to i64
  %555 = load i64, i64* %size, align 8
  %add2253 = add nsw i64 %conv2252, %555
  %mul2254 = mul nsw i64 0, %add2253
  %add2255 = add nsw i64 %mul2254, 1
  %shl2256 = shl i64 %add2255, 62
  %sub2257 = sub nsw i64 %shl2256, 1
  %mul2258 = mul nsw i64 %sub2257, 2
  %add2259 = add nsw i64 %mul2258, 1
  br label %cond.end.2266

cond.false.2260:                                  ; preds = %cond.true.2242
  %556 = load i32, i32* %len, align 4
  %mul2261 = mul nsw i32 0, %556
  %conv2262 = sext i32 %mul2261 to i64
  %557 = load i64, i64* %size, align 8
  %add2263 = add nsw i64 %conv2262, %557
  %mul2264 = mul nsw i64 0, %add2263
  %sub2265 = sub nsw i64 %mul2264, 1
  br label %cond.end.2266

cond.end.2266:                                    ; preds = %cond.false.2260, %cond.true.2250
  %cond2267 = phi i64 [ %add2259, %cond.true.2250 ], [ %sub2265, %cond.false.2260 ]
  %558 = load i32, i32* %len, align 4
  %conv2268 = sext i32 %558 to i64
  %div2269 = sdiv i64 %cond2267, %conv2268
  %cmp2270 = icmp slt i64 %551, %div2269
  br i1 %cmp2270, label %cond.true.2412, label %lor.lhs.false.2395

cond.false.2272:                                  ; preds = %cond.true.2239
  %559 = load i32, i32* %len, align 4
  %cmp2273 = icmp eq i32 %559, -1
  br i1 %cmp2273, label %cond.true.2275, label %cond.false.2276

cond.true.2275:                                   ; preds = %cond.false.2272
  br i1 false, label %cond.true.2412, label %lor.lhs.false.2395

cond.false.2276:                                  ; preds = %cond.false.2272
  %560 = load i32, i32* %len, align 4
  %mul2277 = mul nsw i32 0, %560
  %conv2278 = sext i32 %mul2277 to i64
  %561 = load i64, i64* %size, align 8
  %add2279 = add nsw i64 %conv2278, %561
  %mul2280 = mul nsw i64 0, %add2279
  %sub2281 = sub nsw i64 %mul2280, 1
  %cmp2282 = icmp slt i64 %sub2281, 0
  br i1 %cmp2282, label %cond.true.2284, label %cond.false.2305

cond.true.2284:                                   ; preds = %cond.false.2276
  %562 = load i32, i32* %len, align 4
  %mul2285 = mul nsw i32 0, %562
  %conv2286 = sext i32 %mul2285 to i64
  %563 = load i64, i64* %size, align 8
  %add2287 = add nsw i64 %conv2286, %563
  %mul2288 = mul nsw i64 0, %add2287
  %add2289 = add nsw i64 %mul2288, 0
  %neg2290 = xor i64 %add2289, -1
  %cmp2291 = icmp eq i64 %neg2290, -1
  %conv2292 = zext i1 %cmp2291 to i32
  %sub2293 = sub nsw i32 0, %conv2292
  %conv2294 = sext i32 %sub2293 to i64
  %564 = load i32, i32* %len, align 4
  %mul2295 = mul nsw i32 0, %564
  %conv2296 = sext i32 %mul2295 to i64
  %565 = load i64, i64* %size, align 8
  %add2297 = add nsw i64 %conv2296, %565
  %mul2298 = mul nsw i64 0, %add2297
  %add2299 = add nsw i64 %mul2298, 1
  %shl2300 = shl i64 %add2299, 62
  %sub2301 = sub nsw i64 %shl2300, 1
  %mul2302 = mul nsw i64 %sub2301, 2
  %add2303 = add nsw i64 %mul2302, 1
  %sub2304 = sub nsw i64 %conv2294, %add2303
  br label %cond.end.2311

cond.false.2305:                                  ; preds = %cond.false.2276
  %566 = load i32, i32* %len, align 4
  %mul2306 = mul nsw i32 0, %566
  %conv2307 = sext i32 %mul2306 to i64
  %567 = load i64, i64* %size, align 8
  %add2308 = add nsw i64 %conv2307, %567
  %mul2309 = mul nsw i64 0, %add2308
  %add2310 = add nsw i64 %mul2309, 0
  br label %cond.end.2311

cond.end.2311:                                    ; preds = %cond.false.2305, %cond.true.2284
  %cond2312 = phi i64 [ %sub2304, %cond.true.2284 ], [ %add2310, %cond.false.2305 ]
  %568 = load i32, i32* %len, align 4
  %conv2313 = sext i32 %568 to i64
  %div2314 = sdiv i64 %cond2312, %conv2313
  %569 = load i64, i64* %size, align 8
  %cmp2315 = icmp slt i64 %div2314, %569
  br i1 %cmp2315, label %cond.true.2412, label %lor.lhs.false.2395

cond.false.2317:                                  ; preds = %lor.lhs.false.2236
  %570 = load i32, i32* %len, align 4
  %cmp2318 = icmp eq i32 %570, 0
  br i1 %cmp2318, label %cond.true.2320, label %cond.false.2321

cond.true.2320:                                   ; preds = %cond.false.2317
  br i1 false, label %cond.true.2412, label %lor.lhs.false.2395

cond.false.2321:                                  ; preds = %cond.false.2317
  %571 = load i64, i64* %size, align 8
  %cmp2322 = icmp slt i64 %571, 0
  br i1 %cmp2322, label %cond.true.2324, label %cond.false.2365

cond.true.2324:                                   ; preds = %cond.false.2321
  %572 = load i64, i64* %size, align 8
  %573 = load i32, i32* %len, align 4
  %mul2325 = mul nsw i32 0, %573
  %conv2326 = sext i32 %mul2325 to i64
  %574 = load i64, i64* %size, align 8
  %add2327 = add nsw i64 %conv2326, %574
  %mul2328 = mul nsw i64 0, %add2327
  %sub2329 = sub nsw i64 %mul2328, 1
  %cmp2330 = icmp slt i64 %sub2329, 0
  br i1 %cmp2330, label %cond.true.2332, label %cond.false.2353

cond.true.2332:                                   ; preds = %cond.true.2324
  %575 = load i32, i32* %len, align 4
  %mul2333 = mul nsw i32 0, %575
  %conv2334 = sext i32 %mul2333 to i64
  %576 = load i64, i64* %size, align 8
  %add2335 = add nsw i64 %conv2334, %576
  %mul2336 = mul nsw i64 0, %add2335
  %add2337 = add nsw i64 %mul2336, 0
  %neg2338 = xor i64 %add2337, -1
  %cmp2339 = icmp eq i64 %neg2338, -1
  %conv2340 = zext i1 %cmp2339 to i32
  %sub2341 = sub nsw i32 0, %conv2340
  %conv2342 = sext i32 %sub2341 to i64
  %577 = load i32, i32* %len, align 4
  %mul2343 = mul nsw i32 0, %577
  %conv2344 = sext i32 %mul2343 to i64
  %578 = load i64, i64* %size, align 8
  %add2345 = add nsw i64 %conv2344, %578
  %mul2346 = mul nsw i64 0, %add2345
  %add2347 = add nsw i64 %mul2346, 1
  %shl2348 = shl i64 %add2347, 62
  %sub2349 = sub nsw i64 %shl2348, 1
  %mul2350 = mul nsw i64 %sub2349, 2
  %add2351 = add nsw i64 %mul2350, 1
  %sub2352 = sub nsw i64 %conv2342, %add2351
  br label %cond.end.2359

cond.false.2353:                                  ; preds = %cond.true.2324
  %579 = load i32, i32* %len, align 4
  %mul2354 = mul nsw i32 0, %579
  %conv2355 = sext i32 %mul2354 to i64
  %580 = load i64, i64* %size, align 8
  %add2356 = add nsw i64 %conv2355, %580
  %mul2357 = mul nsw i64 0, %add2356
  %add2358 = add nsw i64 %mul2357, 0
  br label %cond.end.2359

cond.end.2359:                                    ; preds = %cond.false.2353, %cond.true.2332
  %cond2360 = phi i64 [ %sub2352, %cond.true.2332 ], [ %add2358, %cond.false.2353 ]
  %581 = load i32, i32* %len, align 4
  %conv2361 = sext i32 %581 to i64
  %div2362 = sdiv i64 %cond2360, %conv2361
  %cmp2363 = icmp slt i64 %572, %div2362
  br i1 %cmp2363, label %cond.true.2412, label %lor.lhs.false.2395

cond.false.2365:                                  ; preds = %cond.false.2321
  %582 = load i32, i32* %len, align 4
  %mul2366 = mul nsw i32 0, %582
  %conv2367 = sext i32 %mul2366 to i64
  %583 = load i64, i64* %size, align 8
  %add2368 = add nsw i64 %conv2367, %583
  %mul2369 = mul nsw i64 0, %add2368
  %sub2370 = sub nsw i64 %mul2369, 1
  %cmp2371 = icmp slt i64 %sub2370, 0
  br i1 %cmp2371, label %cond.true.2373, label %cond.false.2383

cond.true.2373:                                   ; preds = %cond.false.2365
  %584 = load i32, i32* %len, align 4
  %mul2374 = mul nsw i32 0, %584
  %conv2375 = sext i32 %mul2374 to i64
  %585 = load i64, i64* %size, align 8
  %add2376 = add nsw i64 %conv2375, %585
  %mul2377 = mul nsw i64 0, %add2376
  %add2378 = add nsw i64 %mul2377, 1
  %shl2379 = shl i64 %add2378, 62
  %sub2380 = sub nsw i64 %shl2379, 1
  %mul2381 = mul nsw i64 %sub2380, 2
  %add2382 = add nsw i64 %mul2381, 1
  br label %cond.end.2389

cond.false.2383:                                  ; preds = %cond.false.2365
  %586 = load i32, i32* %len, align 4
  %mul2384 = mul nsw i32 0, %586
  %conv2385 = sext i32 %mul2384 to i64
  %587 = load i64, i64* %size, align 8
  %add2386 = add nsw i64 %conv2385, %587
  %mul2387 = mul nsw i64 0, %add2386
  %sub2388 = sub nsw i64 %mul2387, 1
  br label %cond.end.2389

cond.end.2389:                                    ; preds = %cond.false.2383, %cond.true.2373
  %cond2390 = phi i64 [ %add2382, %cond.true.2373 ], [ %sub2388, %cond.false.2383 ]
  %588 = load i32, i32* %len, align 4
  %conv2391 = sext i32 %588 to i64
  %div2392 = sdiv i64 %cond2390, %conv2391
  %589 = load i64, i64* %size, align 8
  %cmp2393 = icmp slt i64 %div2392, %589
  br i1 %cmp2393, label %cond.true.2412, label %lor.lhs.false.2395

lor.lhs.false.2395:                               ; preds = %cond.end.2389, %cond.end.2359, %cond.true.2320, %cond.end.2311, %cond.true.2275, %cond.end.2266
  %590 = load i64, i64* %size, align 8
  %591 = load i32, i32* %len, align 4
  %conv2396 = sext i32 %591 to i64
  %mul2397 = mul nsw i64 %590, %conv2396
  %mul2398 = mul nsw i64 0, %mul2397
  %sub2399 = sub nsw i64 %mul2398, 1
  %cmp2400 = icmp slt i64 %sub2399, 0
  br i1 %cmp2400, label %land.lhs.true.2402, label %lor.lhs.false.2407

land.lhs.true.2402:                               ; preds = %lor.lhs.false.2395
  %592 = load i64, i64* %size, align 8
  %593 = load i32, i32* %len, align 4
  %conv2403 = sext i32 %593 to i64
  %mul2404 = mul nsw i64 %592, %conv2403
  %cmp2405 = icmp slt i64 %mul2404, -9223372036854775808
  br i1 %cmp2405, label %cond.true.2412, label %lor.lhs.false.2407

lor.lhs.false.2407:                               ; preds = %land.lhs.true.2402, %lor.lhs.false.2395
  %594 = load i64, i64* %size, align 8
  %595 = load i32, i32* %len, align 4
  %conv2408 = sext i32 %595 to i64
  %mul2409 = mul nsw i64 %594, %conv2408
  %cmp2410 = icmp slt i64 9223372036854775807, %mul2409
  br i1 %cmp2410, label %cond.true.2412, label %cond.false.2427

cond.true.2412:                                   ; preds = %lor.lhs.false.2407, %land.lhs.true.2402, %cond.end.2389, %cond.end.2359, %cond.true.2320, %cond.end.2311, %cond.true.2275, %cond.end.2266, %land.lhs.true.2233, %land.lhs.true.2227
  %596 = load i64, i64* %size, align 8
  %597 = load i32, i32* %len, align 4
  %conv2413 = sext i32 %597 to i64
  %mul2414 = mul i64 %596, %conv2413
  %cmp2415 = icmp ule i64 %mul2414, 9223372036854775807
  br i1 %cmp2415, label %cond.true.2417, label %cond.false.2420

cond.true.2417:                                   ; preds = %cond.true.2412
  %598 = load i64, i64* %size, align 8
  %599 = load i32, i32* %len, align 4
  %conv2418 = sext i32 %599 to i64
  %mul2419 = mul i64 %598, %conv2418
  br label %cond.end.2425

cond.false.2420:                                  ; preds = %cond.true.2412
  %600 = load i64, i64* %size, align 8
  %601 = load i32, i32* %len, align 4
  %conv2421 = sext i32 %601 to i64
  %mul2422 = mul i64 %600, %conv2421
  %sub2423 = sub i64 %mul2422, -9223372036854775808
  %add2424 = add nsw i64 %sub2423, -9223372036854775808
  br label %cond.end.2425

cond.end.2425:                                    ; preds = %cond.false.2420, %cond.true.2417
  %cond2426 = phi i64 [ %mul2419, %cond.true.2417 ], [ %add2424, %cond.false.2420 ]
  store i64 %cond2426, i64* %product, align 8
  br i1 true, label %if.then.2965, label %lor.lhs.false.2962

cond.false.2427:                                  ; preds = %lor.lhs.false.2407
  %602 = load i64, i64* %size, align 8
  %603 = load i32, i32* %len, align 4
  %conv2428 = sext i32 %603 to i64
  %mul2429 = mul i64 %602, %conv2428
  %cmp2430 = icmp ule i64 %mul2429, 9223372036854775807
  br i1 %cmp2430, label %cond.true.2432, label %cond.false.2435

cond.true.2432:                                   ; preds = %cond.false.2427
  %604 = load i64, i64* %size, align 8
  %605 = load i32, i32* %len, align 4
  %conv2433 = sext i32 %605 to i64
  %mul2434 = mul i64 %604, %conv2433
  br label %cond.end.2440

cond.false.2435:                                  ; preds = %cond.false.2427
  %606 = load i64, i64* %size, align 8
  %607 = load i32, i32* %len, align 4
  %conv2436 = sext i32 %607 to i64
  %mul2437 = mul i64 %606, %conv2436
  %sub2438 = sub i64 %mul2437, -9223372036854775808
  %add2439 = add nsw i64 %sub2438, -9223372036854775808
  br label %cond.end.2440

cond.end.2440:                                    ; preds = %cond.false.2435, %cond.true.2432
  %cond2441 = phi i64 [ %mul2434, %cond.true.2432 ], [ %add2439, %cond.false.2435 ]
  store i64 %cond2441, i64* %product, align 8
  br i1 false, label %if.then.2965, label %lor.lhs.false.2962

cond.false.2442:                                  ; preds = %cond.false.1921
  br i1 false, label %cond.true.2443, label %cond.false.2705

cond.true.2443:                                   ; preds = %cond.false.2442
  %608 = load i32, i32* %len, align 4
  %conv2444 = sext i32 %608 to i64
  %mul2445 = mul nsw i64 0, %conv2444
  %609 = load i64, i64* %size, align 8
  %add2446 = add nsw i64 %mul2445, %609
  %mul2447 = mul nsw i64 0, %add2446
  %sub2448 = sub nsw i64 %mul2447, 1
  %cmp2449 = icmp slt i64 %sub2448, 0
  br i1 %cmp2449, label %cond.true.2451, label %cond.false.2472

cond.true.2451:                                   ; preds = %cond.true.2443
  %610 = load i32, i32* %len, align 4
  %conv2452 = sext i32 %610 to i64
  %mul2453 = mul nsw i64 0, %conv2452
  %611 = load i64, i64* %size, align 8
  %add2454 = add nsw i64 %mul2453, %611
  %mul2455 = mul nsw i64 0, %add2454
  %add2456 = add nsw i64 %mul2455, 0
  %neg2457 = xor i64 %add2456, -1
  %cmp2458 = icmp eq i64 %neg2457, -1
  %conv2459 = zext i1 %cmp2458 to i32
  %sub2460 = sub nsw i32 0, %conv2459
  %conv2461 = sext i32 %sub2460 to i64
  %612 = load i32, i32* %len, align 4
  %conv2462 = sext i32 %612 to i64
  %mul2463 = mul nsw i64 0, %conv2462
  %613 = load i64, i64* %size, align 8
  %add2464 = add nsw i64 %mul2463, %613
  %mul2465 = mul nsw i64 0, %add2464
  %add2466 = add nsw i64 %mul2465, 1
  %shl2467 = shl i64 %add2466, 62
  %sub2468 = sub nsw i64 %shl2467, 1
  %mul2469 = mul nsw i64 %sub2468, 2
  %add2470 = add nsw i64 %mul2469, 1
  %sub2471 = sub nsw i64 %conv2461, %add2470
  br label %cond.end.2478

cond.false.2472:                                  ; preds = %cond.true.2443
  %614 = load i32, i32* %len, align 4
  %conv2473 = sext i32 %614 to i64
  %mul2474 = mul nsw i64 0, %conv2473
  %615 = load i64, i64* %size, align 8
  %add2475 = add nsw i64 %mul2474, %615
  %mul2476 = mul nsw i64 0, %add2475
  %add2477 = add nsw i64 %mul2476, 0
  br label %cond.end.2478

cond.end.2478:                                    ; preds = %cond.false.2472, %cond.true.2451
  %cond2479 = phi i64 [ %sub2471, %cond.true.2451 ], [ %add2477, %cond.false.2472 ]
  %cmp2480 = icmp eq i64 %cond2479, 0
  br i1 %cmp2480, label %land.lhs.true.2482, label %lor.lhs.false.2496

land.lhs.true.2482:                               ; preds = %cond.end.2478
  %616 = load i64, i64* %size, align 8
  %cmp2483 = icmp slt i64 %616, 0
  br i1 %cmp2483, label %land.lhs.true.2485, label %lor.lhs.false.2489

land.lhs.true.2485:                               ; preds = %land.lhs.true.2482
  %617 = load i32, i32* %len, align 4
  %conv2486 = sext i32 %617 to i64
  %cmp2487 = icmp slt i64 0, %conv2486
  br i1 %cmp2487, label %cond.true.2675, label %lor.lhs.false.2489

lor.lhs.false.2489:                               ; preds = %land.lhs.true.2485, %land.lhs.true.2482
  %618 = load i32, i32* %len, align 4
  %conv2490 = sext i32 %618 to i64
  %cmp2491 = icmp slt i64 %conv2490, 0
  br i1 %cmp2491, label %land.lhs.true.2493, label %lor.lhs.false.2496

land.lhs.true.2493:                               ; preds = %lor.lhs.false.2489
  %619 = load i64, i64* %size, align 8
  %cmp2494 = icmp slt i64 0, %619
  br i1 %cmp2494, label %cond.true.2675, label %lor.lhs.false.2496

lor.lhs.false.2496:                               ; preds = %land.lhs.true.2493, %lor.lhs.false.2489, %cond.end.2478
  %620 = load i32, i32* %len, align 4
  %conv2497 = sext i32 %620 to i64
  %cmp2498 = icmp slt i64 %conv2497, 0
  br i1 %cmp2498, label %cond.true.2500, label %cond.false.2579

cond.true.2500:                                   ; preds = %lor.lhs.false.2496
  %621 = load i64, i64* %size, align 8
  %cmp2501 = icmp slt i64 %621, 0
  br i1 %cmp2501, label %cond.true.2503, label %cond.false.2533

cond.true.2503:                                   ; preds = %cond.true.2500
  %622 = load i64, i64* %size, align 8
  %623 = load i32, i32* %len, align 4
  %conv2504 = sext i32 %623 to i64
  %mul2505 = mul nsw i64 0, %conv2504
  %624 = load i64, i64* %size, align 8
  %add2506 = add nsw i64 %mul2505, %624
  %mul2507 = mul nsw i64 0, %add2506
  %sub2508 = sub nsw i64 %mul2507, 1
  %cmp2509 = icmp slt i64 %sub2508, 0
  br i1 %cmp2509, label %cond.true.2511, label %cond.false.2521

cond.true.2511:                                   ; preds = %cond.true.2503
  %625 = load i32, i32* %len, align 4
  %conv2512 = sext i32 %625 to i64
  %mul2513 = mul nsw i64 0, %conv2512
  %626 = load i64, i64* %size, align 8
  %add2514 = add nsw i64 %mul2513, %626
  %mul2515 = mul nsw i64 0, %add2514
  %add2516 = add nsw i64 %mul2515, 1
  %shl2517 = shl i64 %add2516, 62
  %sub2518 = sub nsw i64 %shl2517, 1
  %mul2519 = mul nsw i64 %sub2518, 2
  %add2520 = add nsw i64 %mul2519, 1
  br label %cond.end.2527

cond.false.2521:                                  ; preds = %cond.true.2503
  %627 = load i32, i32* %len, align 4
  %conv2522 = sext i32 %627 to i64
  %mul2523 = mul nsw i64 0, %conv2522
  %628 = load i64, i64* %size, align 8
  %add2524 = add nsw i64 %mul2523, %628
  %mul2525 = mul nsw i64 0, %add2524
  %sub2526 = sub nsw i64 %mul2525, 1
  br label %cond.end.2527

cond.end.2527:                                    ; preds = %cond.false.2521, %cond.true.2511
  %cond2528 = phi i64 [ %add2520, %cond.true.2511 ], [ %sub2526, %cond.false.2521 ]
  %629 = load i32, i32* %len, align 4
  %conv2529 = sext i32 %629 to i64
  %div2530 = sdiv i64 %cond2528, %conv2529
  %cmp2531 = icmp slt i64 %622, %div2530
  br i1 %cmp2531, label %cond.true.2675, label %lor.lhs.false.2658

cond.false.2533:                                  ; preds = %cond.true.2500
  %630 = load i32, i32* %len, align 4
  %conv2534 = sext i32 %630 to i64
  %cmp2535 = icmp eq i64 %conv2534, -1
  br i1 %cmp2535, label %cond.true.2537, label %cond.false.2538

cond.true.2537:                                   ; preds = %cond.false.2533
  br i1 false, label %cond.true.2675, label %lor.lhs.false.2658

cond.false.2538:                                  ; preds = %cond.false.2533
  %631 = load i32, i32* %len, align 4
  %conv2539 = sext i32 %631 to i64
  %mul2540 = mul nsw i64 0, %conv2539
  %632 = load i64, i64* %size, align 8
  %add2541 = add nsw i64 %mul2540, %632
  %mul2542 = mul nsw i64 0, %add2541
  %sub2543 = sub nsw i64 %mul2542, 1
  %cmp2544 = icmp slt i64 %sub2543, 0
  br i1 %cmp2544, label %cond.true.2546, label %cond.false.2567

cond.true.2546:                                   ; preds = %cond.false.2538
  %633 = load i32, i32* %len, align 4
  %conv2547 = sext i32 %633 to i64
  %mul2548 = mul nsw i64 0, %conv2547
  %634 = load i64, i64* %size, align 8
  %add2549 = add nsw i64 %mul2548, %634
  %mul2550 = mul nsw i64 0, %add2549
  %add2551 = add nsw i64 %mul2550, 0
  %neg2552 = xor i64 %add2551, -1
  %cmp2553 = icmp eq i64 %neg2552, -1
  %conv2554 = zext i1 %cmp2553 to i32
  %sub2555 = sub nsw i32 0, %conv2554
  %conv2556 = sext i32 %sub2555 to i64
  %635 = load i32, i32* %len, align 4
  %conv2557 = sext i32 %635 to i64
  %mul2558 = mul nsw i64 0, %conv2557
  %636 = load i64, i64* %size, align 8
  %add2559 = add nsw i64 %mul2558, %636
  %mul2560 = mul nsw i64 0, %add2559
  %add2561 = add nsw i64 %mul2560, 1
  %shl2562 = shl i64 %add2561, 62
  %sub2563 = sub nsw i64 %shl2562, 1
  %mul2564 = mul nsw i64 %sub2563, 2
  %add2565 = add nsw i64 %mul2564, 1
  %sub2566 = sub nsw i64 %conv2556, %add2565
  br label %cond.end.2573

cond.false.2567:                                  ; preds = %cond.false.2538
  %637 = load i32, i32* %len, align 4
  %conv2568 = sext i32 %637 to i64
  %mul2569 = mul nsw i64 0, %conv2568
  %638 = load i64, i64* %size, align 8
  %add2570 = add nsw i64 %mul2569, %638
  %mul2571 = mul nsw i64 0, %add2570
  %add2572 = add nsw i64 %mul2571, 0
  br label %cond.end.2573

cond.end.2573:                                    ; preds = %cond.false.2567, %cond.true.2546
  %cond2574 = phi i64 [ %sub2566, %cond.true.2546 ], [ %add2572, %cond.false.2567 ]
  %639 = load i32, i32* %len, align 4
  %conv2575 = sext i32 %639 to i64
  %div2576 = sdiv i64 %cond2574, %conv2575
  %640 = load i64, i64* %size, align 8
  %cmp2577 = icmp slt i64 %div2576, %640
  br i1 %cmp2577, label %cond.true.2675, label %lor.lhs.false.2658

cond.false.2579:                                  ; preds = %lor.lhs.false.2496
  %641 = load i32, i32* %len, align 4
  %conv2580 = sext i32 %641 to i64
  %cmp2581 = icmp eq i64 %conv2580, 0
  br i1 %cmp2581, label %cond.true.2583, label %cond.false.2584

cond.true.2583:                                   ; preds = %cond.false.2579
  br i1 false, label %cond.true.2675, label %lor.lhs.false.2658

cond.false.2584:                                  ; preds = %cond.false.2579
  %642 = load i64, i64* %size, align 8
  %cmp2585 = icmp slt i64 %642, 0
  br i1 %cmp2585, label %cond.true.2587, label %cond.false.2628

cond.true.2587:                                   ; preds = %cond.false.2584
  %643 = load i64, i64* %size, align 8
  %644 = load i32, i32* %len, align 4
  %conv2588 = sext i32 %644 to i64
  %mul2589 = mul nsw i64 0, %conv2588
  %645 = load i64, i64* %size, align 8
  %add2590 = add nsw i64 %mul2589, %645
  %mul2591 = mul nsw i64 0, %add2590
  %sub2592 = sub nsw i64 %mul2591, 1
  %cmp2593 = icmp slt i64 %sub2592, 0
  br i1 %cmp2593, label %cond.true.2595, label %cond.false.2616

cond.true.2595:                                   ; preds = %cond.true.2587
  %646 = load i32, i32* %len, align 4
  %conv2596 = sext i32 %646 to i64
  %mul2597 = mul nsw i64 0, %conv2596
  %647 = load i64, i64* %size, align 8
  %add2598 = add nsw i64 %mul2597, %647
  %mul2599 = mul nsw i64 0, %add2598
  %add2600 = add nsw i64 %mul2599, 0
  %neg2601 = xor i64 %add2600, -1
  %cmp2602 = icmp eq i64 %neg2601, -1
  %conv2603 = zext i1 %cmp2602 to i32
  %sub2604 = sub nsw i32 0, %conv2603
  %conv2605 = sext i32 %sub2604 to i64
  %648 = load i32, i32* %len, align 4
  %conv2606 = sext i32 %648 to i64
  %mul2607 = mul nsw i64 0, %conv2606
  %649 = load i64, i64* %size, align 8
  %add2608 = add nsw i64 %mul2607, %649
  %mul2609 = mul nsw i64 0, %add2608
  %add2610 = add nsw i64 %mul2609, 1
  %shl2611 = shl i64 %add2610, 62
  %sub2612 = sub nsw i64 %shl2611, 1
  %mul2613 = mul nsw i64 %sub2612, 2
  %add2614 = add nsw i64 %mul2613, 1
  %sub2615 = sub nsw i64 %conv2605, %add2614
  br label %cond.end.2622

cond.false.2616:                                  ; preds = %cond.true.2587
  %650 = load i32, i32* %len, align 4
  %conv2617 = sext i32 %650 to i64
  %mul2618 = mul nsw i64 0, %conv2617
  %651 = load i64, i64* %size, align 8
  %add2619 = add nsw i64 %mul2618, %651
  %mul2620 = mul nsw i64 0, %add2619
  %add2621 = add nsw i64 %mul2620, 0
  br label %cond.end.2622

cond.end.2622:                                    ; preds = %cond.false.2616, %cond.true.2595
  %cond2623 = phi i64 [ %sub2615, %cond.true.2595 ], [ %add2621, %cond.false.2616 ]
  %652 = load i32, i32* %len, align 4
  %conv2624 = sext i32 %652 to i64
  %div2625 = sdiv i64 %cond2623, %conv2624
  %cmp2626 = icmp slt i64 %643, %div2625
  br i1 %cmp2626, label %cond.true.2675, label %lor.lhs.false.2658

cond.false.2628:                                  ; preds = %cond.false.2584
  %653 = load i32, i32* %len, align 4
  %conv2629 = sext i32 %653 to i64
  %mul2630 = mul nsw i64 0, %conv2629
  %654 = load i64, i64* %size, align 8
  %add2631 = add nsw i64 %mul2630, %654
  %mul2632 = mul nsw i64 0, %add2631
  %sub2633 = sub nsw i64 %mul2632, 1
  %cmp2634 = icmp slt i64 %sub2633, 0
  br i1 %cmp2634, label %cond.true.2636, label %cond.false.2646

cond.true.2636:                                   ; preds = %cond.false.2628
  %655 = load i32, i32* %len, align 4
  %conv2637 = sext i32 %655 to i64
  %mul2638 = mul nsw i64 0, %conv2637
  %656 = load i64, i64* %size, align 8
  %add2639 = add nsw i64 %mul2638, %656
  %mul2640 = mul nsw i64 0, %add2639
  %add2641 = add nsw i64 %mul2640, 1
  %shl2642 = shl i64 %add2641, 62
  %sub2643 = sub nsw i64 %shl2642, 1
  %mul2644 = mul nsw i64 %sub2643, 2
  %add2645 = add nsw i64 %mul2644, 1
  br label %cond.end.2652

cond.false.2646:                                  ; preds = %cond.false.2628
  %657 = load i32, i32* %len, align 4
  %conv2647 = sext i32 %657 to i64
  %mul2648 = mul nsw i64 0, %conv2647
  %658 = load i64, i64* %size, align 8
  %add2649 = add nsw i64 %mul2648, %658
  %mul2650 = mul nsw i64 0, %add2649
  %sub2651 = sub nsw i64 %mul2650, 1
  br label %cond.end.2652

cond.end.2652:                                    ; preds = %cond.false.2646, %cond.true.2636
  %cond2653 = phi i64 [ %add2645, %cond.true.2636 ], [ %sub2651, %cond.false.2646 ]
  %659 = load i32, i32* %len, align 4
  %conv2654 = sext i32 %659 to i64
  %div2655 = sdiv i64 %cond2653, %conv2654
  %660 = load i64, i64* %size, align 8
  %cmp2656 = icmp slt i64 %div2655, %660
  br i1 %cmp2656, label %cond.true.2675, label %lor.lhs.false.2658

lor.lhs.false.2658:                               ; preds = %cond.end.2652, %cond.end.2622, %cond.true.2583, %cond.end.2573, %cond.true.2537, %cond.end.2527
  %661 = load i64, i64* %size, align 8
  %662 = load i32, i32* %len, align 4
  %conv2659 = sext i32 %662 to i64
  %mul2660 = mul nsw i64 %661, %conv2659
  %mul2661 = mul nsw i64 0, %mul2660
  %sub2662 = sub nsw i64 %mul2661, 1
  %cmp2663 = icmp slt i64 %sub2662, 0
  br i1 %cmp2663, label %land.lhs.true.2665, label %lor.lhs.false.2670

land.lhs.true.2665:                               ; preds = %lor.lhs.false.2658
  %663 = load i64, i64* %size, align 8
  %664 = load i32, i32* %len, align 4
  %conv2666 = sext i32 %664 to i64
  %mul2667 = mul nsw i64 %663, %conv2666
  %cmp2668 = icmp slt i64 %mul2667, -9223372036854775808
  br i1 %cmp2668, label %cond.true.2675, label %lor.lhs.false.2670

lor.lhs.false.2670:                               ; preds = %land.lhs.true.2665, %lor.lhs.false.2658
  %665 = load i64, i64* %size, align 8
  %666 = load i32, i32* %len, align 4
  %conv2671 = sext i32 %666 to i64
  %mul2672 = mul nsw i64 %665, %conv2671
  %cmp2673 = icmp slt i64 9223372036854775807, %mul2672
  br i1 %cmp2673, label %cond.true.2675, label %cond.false.2690

cond.true.2675:                                   ; preds = %lor.lhs.false.2670, %land.lhs.true.2665, %cond.end.2652, %cond.end.2622, %cond.true.2583, %cond.end.2573, %cond.true.2537, %cond.end.2527, %land.lhs.true.2493, %land.lhs.true.2485
  %667 = load i64, i64* %size, align 8
  %668 = load i32, i32* %len, align 4
  %conv2676 = sext i32 %668 to i64
  %mul2677 = mul i64 %667, %conv2676
  %cmp2678 = icmp ule i64 %mul2677, 9223372036854775807
  br i1 %cmp2678, label %cond.true.2680, label %cond.false.2683

cond.true.2680:                                   ; preds = %cond.true.2675
  %669 = load i64, i64* %size, align 8
  %670 = load i32, i32* %len, align 4
  %conv2681 = sext i32 %670 to i64
  %mul2682 = mul i64 %669, %conv2681
  br label %cond.end.2688

cond.false.2683:                                  ; preds = %cond.true.2675
  %671 = load i64, i64* %size, align 8
  %672 = load i32, i32* %len, align 4
  %conv2684 = sext i32 %672 to i64
  %mul2685 = mul i64 %671, %conv2684
  %sub2686 = sub i64 %mul2685, -9223372036854775808
  %add2687 = add nsw i64 %sub2686, -9223372036854775808
  br label %cond.end.2688

cond.end.2688:                                    ; preds = %cond.false.2683, %cond.true.2680
  %cond2689 = phi i64 [ %mul2682, %cond.true.2680 ], [ %add2687, %cond.false.2683 ]
  store i64 %cond2689, i64* %product, align 8
  br i1 true, label %if.then.2965, label %lor.lhs.false.2962

cond.false.2690:                                  ; preds = %lor.lhs.false.2670
  %673 = load i64, i64* %size, align 8
  %674 = load i32, i32* %len, align 4
  %conv2691 = sext i32 %674 to i64
  %mul2692 = mul i64 %673, %conv2691
  %cmp2693 = icmp ule i64 %mul2692, 9223372036854775807
  br i1 %cmp2693, label %cond.true.2695, label %cond.false.2698

cond.true.2695:                                   ; preds = %cond.false.2690
  %675 = load i64, i64* %size, align 8
  %676 = load i32, i32* %len, align 4
  %conv2696 = sext i32 %676 to i64
  %mul2697 = mul i64 %675, %conv2696
  br label %cond.end.2703

cond.false.2698:                                  ; preds = %cond.false.2690
  %677 = load i64, i64* %size, align 8
  %678 = load i32, i32* %len, align 4
  %conv2699 = sext i32 %678 to i64
  %mul2700 = mul i64 %677, %conv2699
  %sub2701 = sub i64 %mul2700, -9223372036854775808
  %add2702 = add nsw i64 %sub2701, -9223372036854775808
  br label %cond.end.2703

cond.end.2703:                                    ; preds = %cond.false.2698, %cond.true.2695
  %cond2704 = phi i64 [ %mul2697, %cond.true.2695 ], [ %add2702, %cond.false.2698 ]
  store i64 %cond2704, i64* %product, align 8
  br i1 false, label %if.then.2965, label %lor.lhs.false.2962

cond.false.2705:                                  ; preds = %cond.false.2442
  %679 = load i32, i32* %len, align 4
  %mul2706 = mul nsw i32 0, %679
  %conv2707 = sext i32 %mul2706 to i64
  %680 = load i64, i64* %size, align 8
  %add2708 = add nsw i64 %conv2707, %680
  %mul2709 = mul nsw i64 0, %add2708
  %sub2710 = sub nsw i64 %mul2709, 1
  %cmp2711 = icmp slt i64 %sub2710, 0
  br i1 %cmp2711, label %cond.true.2713, label %cond.false.2734

cond.true.2713:                                   ; preds = %cond.false.2705
  %681 = load i32, i32* %len, align 4
  %mul2714 = mul nsw i32 0, %681
  %conv2715 = sext i32 %mul2714 to i64
  %682 = load i64, i64* %size, align 8
  %add2716 = add nsw i64 %conv2715, %682
  %mul2717 = mul nsw i64 0, %add2716
  %add2718 = add nsw i64 %mul2717, 0
  %neg2719 = xor i64 %add2718, -1
  %cmp2720 = icmp eq i64 %neg2719, -1
  %conv2721 = zext i1 %cmp2720 to i32
  %sub2722 = sub nsw i32 0, %conv2721
  %conv2723 = sext i32 %sub2722 to i64
  %683 = load i32, i32* %len, align 4
  %mul2724 = mul nsw i32 0, %683
  %conv2725 = sext i32 %mul2724 to i64
  %684 = load i64, i64* %size, align 8
  %add2726 = add nsw i64 %conv2725, %684
  %mul2727 = mul nsw i64 0, %add2726
  %add2728 = add nsw i64 %mul2727, 1
  %shl2729 = shl i64 %add2728, 62
  %sub2730 = sub nsw i64 %shl2729, 1
  %mul2731 = mul nsw i64 %sub2730, 2
  %add2732 = add nsw i64 %mul2731, 1
  %sub2733 = sub nsw i64 %conv2723, %add2732
  br label %cond.end.2740

cond.false.2734:                                  ; preds = %cond.false.2705
  %685 = load i32, i32* %len, align 4
  %mul2735 = mul nsw i32 0, %685
  %conv2736 = sext i32 %mul2735 to i64
  %686 = load i64, i64* %size, align 8
  %add2737 = add nsw i64 %conv2736, %686
  %mul2738 = mul nsw i64 0, %add2737
  %add2739 = add nsw i64 %mul2738, 0
  br label %cond.end.2740

cond.end.2740:                                    ; preds = %cond.false.2734, %cond.true.2713
  %cond2741 = phi i64 [ %sub2733, %cond.true.2713 ], [ %add2739, %cond.false.2734 ]
  %cmp2742 = icmp eq i64 %cond2741, 0
  br i1 %cmp2742, label %land.lhs.true.2744, label %lor.lhs.false.2756

land.lhs.true.2744:                               ; preds = %cond.end.2740
  %687 = load i64, i64* %size, align 8
  %cmp2745 = icmp slt i64 %687, 0
  br i1 %cmp2745, label %land.lhs.true.2747, label %lor.lhs.false.2750

land.lhs.true.2747:                               ; preds = %land.lhs.true.2744
  %688 = load i32, i32* %len, align 4
  %cmp2748 = icmp slt i32 0, %688
  br i1 %cmp2748, label %cond.true.2932, label %lor.lhs.false.2750

lor.lhs.false.2750:                               ; preds = %land.lhs.true.2747, %land.lhs.true.2744
  %689 = load i32, i32* %len, align 4
  %cmp2751 = icmp slt i32 %689, 0
  br i1 %cmp2751, label %land.lhs.true.2753, label %lor.lhs.false.2756

land.lhs.true.2753:                               ; preds = %lor.lhs.false.2750
  %690 = load i64, i64* %size, align 8
  %cmp2754 = icmp slt i64 0, %690
  br i1 %cmp2754, label %cond.true.2932, label %lor.lhs.false.2756

lor.lhs.false.2756:                               ; preds = %land.lhs.true.2753, %lor.lhs.false.2750, %cond.end.2740
  %691 = load i32, i32* %len, align 4
  %cmp2757 = icmp slt i32 %691, 0
  br i1 %cmp2757, label %cond.true.2759, label %cond.false.2837

cond.true.2759:                                   ; preds = %lor.lhs.false.2756
  %692 = load i64, i64* %size, align 8
  %cmp2760 = icmp slt i64 %692, 0
  br i1 %cmp2760, label %cond.true.2762, label %cond.false.2792

cond.true.2762:                                   ; preds = %cond.true.2759
  %693 = load i64, i64* %size, align 8
  %694 = load i32, i32* %len, align 4
  %mul2763 = mul nsw i32 0, %694
  %conv2764 = sext i32 %mul2763 to i64
  %695 = load i64, i64* %size, align 8
  %add2765 = add nsw i64 %conv2764, %695
  %mul2766 = mul nsw i64 0, %add2765
  %sub2767 = sub nsw i64 %mul2766, 1
  %cmp2768 = icmp slt i64 %sub2767, 0
  br i1 %cmp2768, label %cond.true.2770, label %cond.false.2780

cond.true.2770:                                   ; preds = %cond.true.2762
  %696 = load i32, i32* %len, align 4
  %mul2771 = mul nsw i32 0, %696
  %conv2772 = sext i32 %mul2771 to i64
  %697 = load i64, i64* %size, align 8
  %add2773 = add nsw i64 %conv2772, %697
  %mul2774 = mul nsw i64 0, %add2773
  %add2775 = add nsw i64 %mul2774, 1
  %shl2776 = shl i64 %add2775, 62
  %sub2777 = sub nsw i64 %shl2776, 1
  %mul2778 = mul nsw i64 %sub2777, 2
  %add2779 = add nsw i64 %mul2778, 1
  br label %cond.end.2786

cond.false.2780:                                  ; preds = %cond.true.2762
  %698 = load i32, i32* %len, align 4
  %mul2781 = mul nsw i32 0, %698
  %conv2782 = sext i32 %mul2781 to i64
  %699 = load i64, i64* %size, align 8
  %add2783 = add nsw i64 %conv2782, %699
  %mul2784 = mul nsw i64 0, %add2783
  %sub2785 = sub nsw i64 %mul2784, 1
  br label %cond.end.2786

cond.end.2786:                                    ; preds = %cond.false.2780, %cond.true.2770
  %cond2787 = phi i64 [ %add2779, %cond.true.2770 ], [ %sub2785, %cond.false.2780 ]
  %700 = load i32, i32* %len, align 4
  %conv2788 = sext i32 %700 to i64
  %div2789 = sdiv i64 %cond2787, %conv2788
  %cmp2790 = icmp slt i64 %693, %div2789
  br i1 %cmp2790, label %cond.true.2932, label %lor.lhs.false.2915

cond.false.2792:                                  ; preds = %cond.true.2759
  %701 = load i32, i32* %len, align 4
  %cmp2793 = icmp eq i32 %701, -1
  br i1 %cmp2793, label %cond.true.2795, label %cond.false.2796

cond.true.2795:                                   ; preds = %cond.false.2792
  br i1 false, label %cond.true.2932, label %lor.lhs.false.2915

cond.false.2796:                                  ; preds = %cond.false.2792
  %702 = load i32, i32* %len, align 4
  %mul2797 = mul nsw i32 0, %702
  %conv2798 = sext i32 %mul2797 to i64
  %703 = load i64, i64* %size, align 8
  %add2799 = add nsw i64 %conv2798, %703
  %mul2800 = mul nsw i64 0, %add2799
  %sub2801 = sub nsw i64 %mul2800, 1
  %cmp2802 = icmp slt i64 %sub2801, 0
  br i1 %cmp2802, label %cond.true.2804, label %cond.false.2825

cond.true.2804:                                   ; preds = %cond.false.2796
  %704 = load i32, i32* %len, align 4
  %mul2805 = mul nsw i32 0, %704
  %conv2806 = sext i32 %mul2805 to i64
  %705 = load i64, i64* %size, align 8
  %add2807 = add nsw i64 %conv2806, %705
  %mul2808 = mul nsw i64 0, %add2807
  %add2809 = add nsw i64 %mul2808, 0
  %neg2810 = xor i64 %add2809, -1
  %cmp2811 = icmp eq i64 %neg2810, -1
  %conv2812 = zext i1 %cmp2811 to i32
  %sub2813 = sub nsw i32 0, %conv2812
  %conv2814 = sext i32 %sub2813 to i64
  %706 = load i32, i32* %len, align 4
  %mul2815 = mul nsw i32 0, %706
  %conv2816 = sext i32 %mul2815 to i64
  %707 = load i64, i64* %size, align 8
  %add2817 = add nsw i64 %conv2816, %707
  %mul2818 = mul nsw i64 0, %add2817
  %add2819 = add nsw i64 %mul2818, 1
  %shl2820 = shl i64 %add2819, 62
  %sub2821 = sub nsw i64 %shl2820, 1
  %mul2822 = mul nsw i64 %sub2821, 2
  %add2823 = add nsw i64 %mul2822, 1
  %sub2824 = sub nsw i64 %conv2814, %add2823
  br label %cond.end.2831

cond.false.2825:                                  ; preds = %cond.false.2796
  %708 = load i32, i32* %len, align 4
  %mul2826 = mul nsw i32 0, %708
  %conv2827 = sext i32 %mul2826 to i64
  %709 = load i64, i64* %size, align 8
  %add2828 = add nsw i64 %conv2827, %709
  %mul2829 = mul nsw i64 0, %add2828
  %add2830 = add nsw i64 %mul2829, 0
  br label %cond.end.2831

cond.end.2831:                                    ; preds = %cond.false.2825, %cond.true.2804
  %cond2832 = phi i64 [ %sub2824, %cond.true.2804 ], [ %add2830, %cond.false.2825 ]
  %710 = load i32, i32* %len, align 4
  %conv2833 = sext i32 %710 to i64
  %div2834 = sdiv i64 %cond2832, %conv2833
  %711 = load i64, i64* %size, align 8
  %cmp2835 = icmp slt i64 %div2834, %711
  br i1 %cmp2835, label %cond.true.2932, label %lor.lhs.false.2915

cond.false.2837:                                  ; preds = %lor.lhs.false.2756
  %712 = load i32, i32* %len, align 4
  %cmp2838 = icmp eq i32 %712, 0
  br i1 %cmp2838, label %cond.true.2840, label %cond.false.2841

cond.true.2840:                                   ; preds = %cond.false.2837
  br i1 false, label %cond.true.2932, label %lor.lhs.false.2915

cond.false.2841:                                  ; preds = %cond.false.2837
  %713 = load i64, i64* %size, align 8
  %cmp2842 = icmp slt i64 %713, 0
  br i1 %cmp2842, label %cond.true.2844, label %cond.false.2885

cond.true.2844:                                   ; preds = %cond.false.2841
  %714 = load i64, i64* %size, align 8
  %715 = load i32, i32* %len, align 4
  %mul2845 = mul nsw i32 0, %715
  %conv2846 = sext i32 %mul2845 to i64
  %716 = load i64, i64* %size, align 8
  %add2847 = add nsw i64 %conv2846, %716
  %mul2848 = mul nsw i64 0, %add2847
  %sub2849 = sub nsw i64 %mul2848, 1
  %cmp2850 = icmp slt i64 %sub2849, 0
  br i1 %cmp2850, label %cond.true.2852, label %cond.false.2873

cond.true.2852:                                   ; preds = %cond.true.2844
  %717 = load i32, i32* %len, align 4
  %mul2853 = mul nsw i32 0, %717
  %conv2854 = sext i32 %mul2853 to i64
  %718 = load i64, i64* %size, align 8
  %add2855 = add nsw i64 %conv2854, %718
  %mul2856 = mul nsw i64 0, %add2855
  %add2857 = add nsw i64 %mul2856, 0
  %neg2858 = xor i64 %add2857, -1
  %cmp2859 = icmp eq i64 %neg2858, -1
  %conv2860 = zext i1 %cmp2859 to i32
  %sub2861 = sub nsw i32 0, %conv2860
  %conv2862 = sext i32 %sub2861 to i64
  %719 = load i32, i32* %len, align 4
  %mul2863 = mul nsw i32 0, %719
  %conv2864 = sext i32 %mul2863 to i64
  %720 = load i64, i64* %size, align 8
  %add2865 = add nsw i64 %conv2864, %720
  %mul2866 = mul nsw i64 0, %add2865
  %add2867 = add nsw i64 %mul2866, 1
  %shl2868 = shl i64 %add2867, 62
  %sub2869 = sub nsw i64 %shl2868, 1
  %mul2870 = mul nsw i64 %sub2869, 2
  %add2871 = add nsw i64 %mul2870, 1
  %sub2872 = sub nsw i64 %conv2862, %add2871
  br label %cond.end.2879

cond.false.2873:                                  ; preds = %cond.true.2844
  %721 = load i32, i32* %len, align 4
  %mul2874 = mul nsw i32 0, %721
  %conv2875 = sext i32 %mul2874 to i64
  %722 = load i64, i64* %size, align 8
  %add2876 = add nsw i64 %conv2875, %722
  %mul2877 = mul nsw i64 0, %add2876
  %add2878 = add nsw i64 %mul2877, 0
  br label %cond.end.2879

cond.end.2879:                                    ; preds = %cond.false.2873, %cond.true.2852
  %cond2880 = phi i64 [ %sub2872, %cond.true.2852 ], [ %add2878, %cond.false.2873 ]
  %723 = load i32, i32* %len, align 4
  %conv2881 = sext i32 %723 to i64
  %div2882 = sdiv i64 %cond2880, %conv2881
  %cmp2883 = icmp slt i64 %714, %div2882
  br i1 %cmp2883, label %cond.true.2932, label %lor.lhs.false.2915

cond.false.2885:                                  ; preds = %cond.false.2841
  %724 = load i32, i32* %len, align 4
  %mul2886 = mul nsw i32 0, %724
  %conv2887 = sext i32 %mul2886 to i64
  %725 = load i64, i64* %size, align 8
  %add2888 = add nsw i64 %conv2887, %725
  %mul2889 = mul nsw i64 0, %add2888
  %sub2890 = sub nsw i64 %mul2889, 1
  %cmp2891 = icmp slt i64 %sub2890, 0
  br i1 %cmp2891, label %cond.true.2893, label %cond.false.2903

cond.true.2893:                                   ; preds = %cond.false.2885
  %726 = load i32, i32* %len, align 4
  %mul2894 = mul nsw i32 0, %726
  %conv2895 = sext i32 %mul2894 to i64
  %727 = load i64, i64* %size, align 8
  %add2896 = add nsw i64 %conv2895, %727
  %mul2897 = mul nsw i64 0, %add2896
  %add2898 = add nsw i64 %mul2897, 1
  %shl2899 = shl i64 %add2898, 62
  %sub2900 = sub nsw i64 %shl2899, 1
  %mul2901 = mul nsw i64 %sub2900, 2
  %add2902 = add nsw i64 %mul2901, 1
  br label %cond.end.2909

cond.false.2903:                                  ; preds = %cond.false.2885
  %728 = load i32, i32* %len, align 4
  %mul2904 = mul nsw i32 0, %728
  %conv2905 = sext i32 %mul2904 to i64
  %729 = load i64, i64* %size, align 8
  %add2906 = add nsw i64 %conv2905, %729
  %mul2907 = mul nsw i64 0, %add2906
  %sub2908 = sub nsw i64 %mul2907, 1
  br label %cond.end.2909

cond.end.2909:                                    ; preds = %cond.false.2903, %cond.true.2893
  %cond2910 = phi i64 [ %add2902, %cond.true.2893 ], [ %sub2908, %cond.false.2903 ]
  %730 = load i32, i32* %len, align 4
  %conv2911 = sext i32 %730 to i64
  %div2912 = sdiv i64 %cond2910, %conv2911
  %731 = load i64, i64* %size, align 8
  %cmp2913 = icmp slt i64 %div2912, %731
  br i1 %cmp2913, label %cond.true.2932, label %lor.lhs.false.2915

lor.lhs.false.2915:                               ; preds = %cond.end.2909, %cond.end.2879, %cond.true.2840, %cond.end.2831, %cond.true.2795, %cond.end.2786
  %732 = load i64, i64* %size, align 8
  %733 = load i32, i32* %len, align 4
  %conv2916 = sext i32 %733 to i64
  %mul2917 = mul nsw i64 %732, %conv2916
  %mul2918 = mul nsw i64 0, %mul2917
  %sub2919 = sub nsw i64 %mul2918, 1
  %cmp2920 = icmp slt i64 %sub2919, 0
  br i1 %cmp2920, label %land.lhs.true.2922, label %lor.lhs.false.2927

land.lhs.true.2922:                               ; preds = %lor.lhs.false.2915
  %734 = load i64, i64* %size, align 8
  %735 = load i32, i32* %len, align 4
  %conv2923 = sext i32 %735 to i64
  %mul2924 = mul nsw i64 %734, %conv2923
  %cmp2925 = icmp slt i64 %mul2924, -9223372036854775808
  br i1 %cmp2925, label %cond.true.2932, label %lor.lhs.false.2927

lor.lhs.false.2927:                               ; preds = %land.lhs.true.2922, %lor.lhs.false.2915
  %736 = load i64, i64* %size, align 8
  %737 = load i32, i32* %len, align 4
  %conv2928 = sext i32 %737 to i64
  %mul2929 = mul nsw i64 %736, %conv2928
  %cmp2930 = icmp slt i64 9223372036854775807, %mul2929
  br i1 %cmp2930, label %cond.true.2932, label %cond.false.2947

cond.true.2932:                                   ; preds = %lor.lhs.false.2927, %land.lhs.true.2922, %cond.end.2909, %cond.end.2879, %cond.true.2840, %cond.end.2831, %cond.true.2795, %cond.end.2786, %land.lhs.true.2753, %land.lhs.true.2747
  %738 = load i64, i64* %size, align 8
  %739 = load i32, i32* %len, align 4
  %conv2933 = sext i32 %739 to i64
  %mul2934 = mul i64 %738, %conv2933
  %cmp2935 = icmp ule i64 %mul2934, 9223372036854775807
  br i1 %cmp2935, label %cond.true.2937, label %cond.false.2940

cond.true.2937:                                   ; preds = %cond.true.2932
  %740 = load i64, i64* %size, align 8
  %741 = load i32, i32* %len, align 4
  %conv2938 = sext i32 %741 to i64
  %mul2939 = mul i64 %740, %conv2938
  br label %cond.end.2945

cond.false.2940:                                  ; preds = %cond.true.2932
  %742 = load i64, i64* %size, align 8
  %743 = load i32, i32* %len, align 4
  %conv2941 = sext i32 %743 to i64
  %mul2942 = mul i64 %742, %conv2941
  %sub2943 = sub i64 %mul2942, -9223372036854775808
  %add2944 = add nsw i64 %sub2943, -9223372036854775808
  br label %cond.end.2945

cond.end.2945:                                    ; preds = %cond.false.2940, %cond.true.2937
  %cond2946 = phi i64 [ %mul2939, %cond.true.2937 ], [ %add2944, %cond.false.2940 ]
  store i64 %cond2946, i64* %product, align 8
  br i1 true, label %if.then.2965, label %lor.lhs.false.2962

cond.false.2947:                                  ; preds = %lor.lhs.false.2927
  %744 = load i64, i64* %size, align 8
  %745 = load i32, i32* %len, align 4
  %conv2948 = sext i32 %745 to i64
  %mul2949 = mul i64 %744, %conv2948
  %cmp2950 = icmp ule i64 %mul2949, 9223372036854775807
  br i1 %cmp2950, label %cond.true.2952, label %cond.false.2955

cond.true.2952:                                   ; preds = %cond.false.2947
  %746 = load i64, i64* %size, align 8
  %747 = load i32, i32* %len, align 4
  %conv2953 = sext i32 %747 to i64
  %mul2954 = mul i64 %746, %conv2953
  br label %cond.end.2960

cond.false.2955:                                  ; preds = %cond.false.2947
  %748 = load i64, i64* %size, align 8
  %749 = load i32, i32* %len, align 4
  %conv2956 = sext i32 %749 to i64
  %mul2957 = mul i64 %748, %conv2956
  %sub2958 = sub i64 %mul2957, -9223372036854775808
  %add2959 = add nsw i64 %sub2958, -9223372036854775808
  br label %cond.end.2960

cond.end.2960:                                    ; preds = %cond.false.2955, %cond.true.2952
  %cond2961 = phi i64 [ %mul2954, %cond.true.2952 ], [ %add2959, %cond.false.2955 ]
  store i64 %cond2961, i64* %product, align 8
  br i1 false, label %if.then.2965, label %lor.lhs.false.2962

lor.lhs.false.2962:                               ; preds = %cond.end.2960, %cond.end.2945, %cond.end.2703, %cond.end.2688, %cond.end.2440, %cond.end.2425, %cond.end.2183, %cond.end.2168, %cond.end.1918, %cond.end.1902, %cond.end.1659, %cond.end.1643, %cond.end.1397, %cond.end.1368, %cond.end.1112, %cond.end.1083, %cond.end.735, %cond.end.706, %cond.end.450, %cond.end.421
  %750 = load i64, i64* %product, align 8
  %751 = load i64, i64* %size_byte, align 8
  %cmp2963 = icmp ne i64 %750, %751
  br i1 %cmp2963, label %if.then.2965, label %if.end

if.then.2965:                                     ; preds = %lor.lhs.false.2962, %cond.end.2960, %cond.end.2945, %cond.end.2703, %cond.end.2688, %cond.end.2440, %cond.end.2425, %cond.end.2183, %cond.end.2168, %cond.end.1918, %cond.end.1902, %cond.end.1659, %cond.end.1643, %cond.end.1397, %cond.end.1368, %cond.end.1112, %cond.end.1083, %cond.end.735, %cond.end.706, %cond.end.450, %cond.end.421
  call void (i8*, ...) @error(i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.2, i32 0, i32 0)) #8
  unreachable

if.end:                                           ; preds = %lor.lhs.false.2962
  store i64 0, i64* %idx, align 8
  br label %for.cond.2966

for.cond.2966:                                    ; preds = %for.inc.2972, %if.end
  %752 = load i64, i64* %idx, align 8
  %753 = load i64, i64* %size_byte, align 8
  %cmp2967 = icmp slt i64 %752, %753
  br i1 %cmp2967, label %for.body.2969, label %for.end.2974

for.body.2969:                                    ; preds = %for.cond.2966
  %754 = load i64, i64* %idx, align 8
  %755 = load i32, i32* %len, align 4
  %conv2970 = sext i32 %755 to i64
  %rem = srem i64 %754, %conv2970
  %arrayidx2971 = getelementptr inbounds [5 x i8], [5 x i8]* %str, i32 0, i64 %rem
  %756 = load i8, i8* %arrayidx2971, align 1
  %757 = load i8*, i8** %p, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %757, i32 1
  store i8* %incdec.ptr, i8** %p, align 8
  store i8 %756, i8* %757, align 1
  br label %for.inc.2972

for.inc.2972:                                     ; preds = %for.body.2969
  %758 = load i64, i64* %idx, align 8
  %inc2973 = add nsw i64 %758, 1
  store i64 %inc2973, i64* %idx, align 8
  br label %for.cond.2966

for.end.2974:                                     ; preds = %for.cond.2966
  br label %if.end.2985

if.else.2975:                                     ; preds = %cond.end
  store i64 0, i64* %idx, align 8
  br label %for.cond.2976

for.cond.2976:                                    ; preds = %for.inc.2982, %if.else.2975
  %759 = load i64, i64* %idx, align 8
  %760 = load i64, i64* %size, align 8
  %cmp2977 = icmp slt i64 %759, %760
  br i1 %cmp2977, label %for.body.2979, label %for.end.2984

for.body.2979:                                    ; preds = %for.cond.2976
  %761 = load i32, i32* %charval, align 4
  %conv2980 = trunc i32 %761 to i8
  %762 = load i64, i64* %idx, align 8
  %763 = load i8*, i8** %p, align 8
  %arrayidx2981 = getelementptr inbounds i8, i8* %763, i64 %762
  store i8 %conv2980, i8* %arrayidx2981, align 1
  br label %for.inc.2982

for.inc.2982:                                     ; preds = %for.body.2979
  %764 = load i64, i64* %idx, align 8
  %inc2983 = add nsw i64 %764, 1
  store i64 %inc2983, i64* %idx, align 8
  br label %for.cond.2976

for.end.2984:                                     ; preds = %for.cond.2976
  br label %if.end.2985

if.end.2985:                                      ; preds = %for.end.2984, %for.end.2974
  br label %if.end.2992

if.else.2986:                                     ; preds = %if.else.10
  %765 = load i64, i64* %array.addr, align 8
  %call2987 = call zeroext i1 @BOOL_VECTOR_P(i64 %765)
  br i1 %call2987, label %if.then.2988, label %if.else.2990

if.then.2988:                                     ; preds = %if.else.2986
  %766 = load i64, i64* %array.addr, align 8
  %767 = load i64, i64* %item.addr, align 8
  %call2989 = call i64 @bool_vector_fill(i64 %766, i64 %767)
  store i64 %call2989, i64* %retval
  br label %return

if.else.2990:                                     ; preds = %if.else.2986
  %call2991 = call i64 @builtin_lisp_symbol(i32 179)
  %768 = load i64, i64* %array.addr, align 8
  %769 = call i64 @wrong_type_argument(i64 %call2991, i64 %768) #8
  unreachable

if.end.2992:                                      ; preds = %if.end.2985
  br label %if.end.2993

if.end.2993:                                      ; preds = %if.end.2992, %for.end.9
  br label %if.end.2994

if.end.2994:                                      ; preds = %if.end.2993, %for.end
  %770 = load i64, i64* %array.addr, align 8
  store i64 %770, i64* %retval
  br label %return

return:                                           ; preds = %if.end.2994, %if.then.2988
  %771 = load i64, i64* %retval
  ret i64 %771
}

declare void @set_char_table_contents(i64, i64, i64) #2

declare void @set_char_table_defalt(i64, i64) #2

declare zeroext i1 @NATNUMP(i64) #2

declare i64 @bool_vector_fill(i64, i64) #2

; Function Attrs: nounwind uwtable
define i64 @Fclear_string(i64 %string) #1 {
entry:
  %string.addr = alloca i64, align 8
  %len = alloca i64, align 8
  store i64 %string, i64* %string.addr, align 8
  %0 = load i64, i64* %string.addr, align 8
  call void @CHECK_STRING(i64 %0)
  %1 = load i64, i64* %string.addr, align 8
  %call = call i64 @SBYTES(i64 %1)
  store i64 %call, i64* %len, align 8
  %2 = load i64, i64* %string.addr, align 8
  %call1 = call i8* @SDATA(i64 %2)
  %3 = load i64, i64* %len, align 8
  call void @llvm.memset.p0i8.i64(i8* %call1, i8 0, i64 %3, i32 1, i1 false)
  %4 = load i64, i64* %string.addr, align 8
  %5 = load i64, i64* %len, align 8
  call void @STRING_SET_CHARS(i64 %4, i64 %5)
  br label %do.body

do.body:                                          ; preds = %entry
  %6 = load i64, i64* %string.addr, align 8
  %call2 = call %struct.Lisp_String* @XSTRING(i64 %6)
  %size = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %call2, i32 0, i32 0
  %7 = load i64, i64* %size, align 8
  %cmp = icmp eq i64 %7, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %do.body
  %8 = load i64, i64* @empty_unibyte_string, align 8
  store i64 %8, i64* %string.addr, align 8
  br label %if.end

if.else:                                          ; preds = %do.body
  %9 = load i64, i64* %string.addr, align 8
  %call3 = call %struct.Lisp_String* @XSTRING(i64 %9)
  %size_byte = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %call3, i32 0, i32 1
  store i64 -1, i64* %size_byte, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  br label %do.end

do.end:                                           ; preds = %if.end
  %call4 = call i64 @builtin_lisp_symbol(i32 0)
  ret i64 %call4
}

; Function Attrs: nounwind
declare void @llvm.memset.p0i8.i64(i8* nocapture, i8, i64, i32, i1) #5

declare void @STRING_SET_CHARS(i64, i64) #2

; Function Attrs: nounwind uwtable
define i64 @nconc2(i64 %s1, i64 %s2) #1 {
entry:
  %s1.addr = alloca i64, align 8
  %s2.addr = alloca i64, align 8
  %.compoundliteral = alloca [2 x i64], align 8
  store i64 %s1, i64* %s1.addr, align 8
  store i64 %s2, i64* %s2.addr, align 8
  %arrayinit.begin = getelementptr inbounds [2 x i64], [2 x i64]* %.compoundliteral, i64 0, i64 0
  %0 = load i64, i64* %s1.addr, align 8
  store i64 %0, i64* %arrayinit.begin
  %arrayinit.element = getelementptr inbounds i64, i64* %arrayinit.begin, i64 1
  %1 = load i64, i64* %s2.addr, align 8
  store i64 %1, i64* %arrayinit.element
  %arraydecay = getelementptr inbounds [2 x i64], [2 x i64]* %.compoundliteral, i32 0, i32 0
  %call = call i64 @Fnconc(i64 2, i64* %arraydecay)
  ret i64 %call
}

; Function Attrs: nounwind uwtable
define i64 @Fnconc(i64 %nargs, i64* %args) #1 {
entry:
  %nargs.addr = alloca i64, align 8
  %args.addr = alloca i64*, align 8
  %argnum = alloca i64, align 8
  %tail = alloca i64, align 8
  %tem = alloca i64, align 8
  %val = alloca i64, align 8
  store i64 %nargs, i64* %nargs.addr, align 8
  store i64* %args, i64** %args.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call, i64* %tail, align 8
  store i64 %call, i64* %val, align 8
  store i64 0, i64* %argnum, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, i64* %argnum, align 8
  %1 = load i64, i64* %nargs.addr, align 8
  %cmp = icmp slt i64 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i64, i64* %argnum, align 8
  %3 = load i64*, i64** %args.addr, align 8
  %arrayidx = getelementptr inbounds i64, i64* %3, i64 %2
  %4 = load i64, i64* %arrayidx, align 8
  store i64 %4, i64* %tem, align 8
  %5 = load i64, i64* %tem, align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp2 = icmp eq i64 %5, %call1
  br i1 %cmp2, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  br label %for.inc

if.end:                                           ; preds = %for.body
  %6 = load i64, i64* %val, align 8
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp4 = icmp eq i64 %6, %call3
  br i1 %cmp4, label %if.then.5, label %if.end.6

if.then.5:                                        ; preds = %if.end
  %7 = load i64, i64* %tem, align 8
  store i64 %7, i64* %val, align 8
  br label %if.end.6

if.end.6:                                         ; preds = %if.then.5, %if.end
  %8 = load i64, i64* %argnum, align 8
  %add = add nsw i64 %8, 1
  %9 = load i64, i64* %nargs.addr, align 8
  %cmp7 = icmp eq i64 %add, %9
  br i1 %cmp7, label %if.then.8, label %if.end.9

if.then.8:                                        ; preds = %if.end.6
  br label %for.end

if.end.9:                                         ; preds = %if.end.6
  %10 = load i64, i64* %tem, align 8
  %and = and i64 %10, 7
  %conv = trunc i64 %and to i32
  %cmp10 = icmp eq i32 %conv, 3
  br i1 %cmp10, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.9
  br label %cond.end

cond.false:                                       ; preds = %if.end.9
  %call12 = call i64 @builtin_lisp_symbol(i32 626)
  %11 = load i64, i64* %tem, align 8
  %12 = call i64 @wrong_type_argument(i64 %call12, i64 %11) #8
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %13, %cond.true
  br label %while.cond

while.cond:                                       ; preds = %do.end, %cond.end
  %14 = load i64, i64* %tem, align 8
  %and13 = and i64 %14, 7
  %conv14 = trunc i64 %and13 to i32
  %cmp15 = icmp eq i32 %conv14, 3
  br i1 %cmp15, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %15 = load i64, i64* %tem, align 8
  store i64 %15, i64* %tail, align 8
  %16 = load i64, i64* %tail, align 8
  %sub = sub nsw i64 %16, 3
  %17 = inttoptr i64 %sub to i8*
  %18 = bitcast i8* %17 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %18, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %19 = load i64, i64* %cdr, align 8
  store i64 %19, i64* %tem, align 8
  br label %do.body

do.body:                                          ; preds = %while.body
  %20 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call17 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp18 = icmp eq i64 %20, %call17
  br i1 %cmp18, label %if.else, label %land.lhs.true

land.lhs.true:                                    ; preds = %do.body
  %21 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  %call20 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp21 = icmp eq i64 %21, %call20
  br i1 %cmp21, label %if.then.23, label %if.else

if.then.23:                                       ; preds = %land.lhs.true
  call void @process_quit_flag()
  br label %if.end.26

if.else:                                          ; preds = %land.lhs.true, %do.body
  %22 = load volatile i8, i8* @pending_signals, align 1
  %tobool = trunc i8 %22 to i1
  br i1 %tobool, label %if.then.24, label %if.end.25

if.then.24:                                       ; preds = %if.else
  call void @process_pending_signals()
  br label %if.end.25

if.end.25:                                        ; preds = %if.then.24, %if.else
  br label %if.end.26

if.end.26:                                        ; preds = %if.end.25, %if.then.23
  br label %do.end

do.end:                                           ; preds = %if.end.26
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %23 = load i64, i64* %argnum, align 8
  %add27 = add nsw i64 %23, 1
  %24 = load i64*, i64** %args.addr, align 8
  %arrayidx28 = getelementptr inbounds i64, i64* %24, i64 %add27
  %25 = load i64, i64* %arrayidx28, align 8
  store i64 %25, i64* %tem, align 8
  %26 = load i64, i64* %tail, align 8
  %27 = load i64, i64* %tem, align 8
  %call29 = call i64 @Fsetcdr(i64 %26, i64 %27)
  %28 = load i64, i64* %tem, align 8
  %call30 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp31 = icmp eq i64 %28, %call30
  br i1 %cmp31, label %if.then.33, label %if.end.36

if.then.33:                                       ; preds = %while.end
  %29 = load i64, i64* %tail, align 8
  %30 = load i64, i64* %argnum, align 8
  %add34 = add nsw i64 %30, 1
  %31 = load i64*, i64** %args.addr, align 8
  %arrayidx35 = getelementptr inbounds i64, i64* %31, i64 %add34
  store i64 %29, i64* %arrayidx35, align 8
  br label %if.end.36

if.end.36:                                        ; preds = %if.then.33, %while.end
  br label %for.inc

for.inc:                                          ; preds = %if.end.36, %if.then
  %32 = load i64, i64* %argnum, align 8
  %inc = add nsw i64 %32, 1
  store i64 %inc, i64* %argnum, align 8
  br label %for.cond

for.end:                                          ; preds = %if.then.8, %for.cond
  %33 = load i64, i64* %val, align 8
  ret i64 %33
}

; Function Attrs: nounwind uwtable
define i64 @Fmapconcat(i64 %function, i64 %sequence, i64 %separator) #1 {
entry:
  %retval = alloca i64, align 8
  %function.addr = alloca i64, align 8
  %sequence.addr = alloca i64, align 8
  %separator.addr = alloca i64, align 8
  %len = alloca i64, align 8
  %leni = alloca i64, align 8
  %nargs = alloca i64, align 8
  %i = alloca i64, align 8
  %args = alloca i64*, align 8
  %ret = alloca i64, align 8
  %sa_avail = alloca i64, align 8
  %sa_count = alloca i64, align 8
  %sa_must_free = alloca i8, align 1
  %alloca_nbytes = alloca i64, align 8
  %arg_ = alloca i64, align 8
  store i64 %function, i64* %function.addr, align 8
  store i64 %sequence, i64* %sequence.addr, align 8
  store i64 %separator, i64* %separator.addr, align 8
  store i64 16384, i64* %sa_avail, align 8
  %call = call i64 @SPECPDL_INDEX()
  store i64 %call, i64* %sa_count, align 8
  store i8 0, i8* %sa_must_free, align 1
  %0 = load i64, i64* %sequence.addr, align 8
  %call1 = call i64 @Flength(i64 %0)
  store i64 %call1, i64* %len, align 8
  %1 = load i64, i64* %sequence.addr, align 8
  %call2 = call zeroext i1 @CHAR_TABLE_P(i64 %1)
  br i1 %call2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call3 = call i64 @builtin_lisp_symbol(i32 626)
  %2 = load i64, i64* %sequence.addr, align 8
  %3 = call i64 @wrong_type_argument(i64 %call3, i64 %2) #8
  unreachable

if.end:                                           ; preds = %entry
  %4 = load i64, i64* %len, align 8
  %shr = ashr i64 %4, 2
  store i64 %shr, i64* %leni, align 8
  %5 = load i64, i64* %leni, align 8
  %6 = load i64, i64* %leni, align 8
  %add = add nsw i64 %5, %6
  %sub = sub nsw i64 %add, 1
  store i64 %sub, i64* %nargs, align 8
  %7 = load i64, i64* %nargs, align 8
  %cmp = icmp slt i64 %7, 0
  br i1 %cmp, label %if.then.4, label %if.end.5

if.then.4:                                        ; preds = %if.end
  %8 = load i64, i64* @empty_unibyte_string, align 8
  store i64 %8, i64* %retval
  br label %return

if.end.5:                                         ; preds = %if.end
  br label %do.body

do.body:                                          ; preds = %if.end.5
  br i1 false, label %cond.true, label %cond.false.479

cond.true:                                        ; preds = %do.body
  br i1 false, label %cond.true.6, label %cond.false.264

cond.true.6:                                      ; preds = %cond.true
  %9 = load i64, i64* %nargs, align 8
  %conv = trunc i64 %9 to i8
  %conv7 = sext i8 %conv to i32
  %add8 = add nsw i32 0, %conv7
  %mul = mul nsw i32 0, %add8
  %sub9 = sub nsw i32 %mul, 1
  %cmp10 = icmp slt i32 %sub9, 0
  br i1 %cmp10, label %cond.true.12, label %cond.false

cond.true.12:                                     ; preds = %cond.true.6
  %10 = load i64, i64* %nargs, align 8
  %conv13 = trunc i64 %10 to i8
  %conv14 = sext i8 %conv13 to i32
  %add15 = add nsw i32 0, %conv14
  %mul16 = mul nsw i32 0, %add15
  %add17 = add nsw i32 %mul16, 0
  %neg = xor i32 %add17, -1
  %cmp18 = icmp eq i32 %neg, -1
  %conv19 = zext i1 %cmp18 to i32
  %sub20 = sub nsw i32 0, %conv19
  %11 = load i64, i64* %nargs, align 8
  %conv21 = trunc i64 %11 to i8
  %conv22 = sext i8 %conv21 to i32
  %add23 = add nsw i32 0, %conv22
  %mul24 = mul nsw i32 0, %add23
  %add25 = add nsw i32 %mul24, 1
  %shl = shl i32 %add25, 30
  %sub26 = sub nsw i32 %shl, 1
  %mul27 = mul nsw i32 %sub26, 2
  %add28 = add nsw i32 %mul27, 1
  %sub29 = sub nsw i32 %sub20, %add28
  br label %cond.end

cond.false:                                       ; preds = %cond.true.6
  %12 = load i64, i64* %nargs, align 8
  %conv30 = trunc i64 %12 to i8
  %conv31 = sext i8 %conv30 to i32
  %add32 = add nsw i32 0, %conv31
  %mul33 = mul nsw i32 0, %add32
  %add34 = add nsw i32 %mul33, 0
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true.12
  %cond = phi i32 [ %sub29, %cond.true.12 ], [ %add34, %cond.false ]
  %cmp35 = icmp eq i32 %cond, 0
  br i1 %cmp35, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %cond.end
  %13 = load i64, i64* %nargs, align 8
  %conv37 = trunc i64 %13 to i8
  %conv38 = sext i8 %conv37 to i32
  %cmp39 = icmp slt i32 %conv38, 0
  br i1 %cmp39, label %cond.true.218, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %cond.end
  br i1 false, label %cond.true.41, label %cond.false.119

cond.true.41:                                     ; preds = %lor.lhs.false
  %14 = load i64, i64* %nargs, align 8
  %conv42 = trunc i64 %14 to i8
  %conv43 = sext i8 %conv42 to i32
  %cmp44 = icmp slt i32 %conv43, 0
  br i1 %cmp44, label %cond.true.46, label %cond.false.76

cond.true.46:                                     ; preds = %cond.true.41
  %15 = load i64, i64* %nargs, align 8
  %conv47 = trunc i64 %15 to i8
  %conv48 = sext i8 %conv47 to i32
  %16 = load i64, i64* %nargs, align 8
  %conv49 = trunc i64 %16 to i8
  %conv50 = sext i8 %conv49 to i32
  %add51 = add nsw i32 0, %conv50
  %mul52 = mul nsw i32 0, %add51
  %sub53 = sub nsw i32 %mul52, 1
  %cmp54 = icmp slt i32 %sub53, 0
  br i1 %cmp54, label %cond.true.56, label %cond.false.66

cond.true.56:                                     ; preds = %cond.true.46
  %17 = load i64, i64* %nargs, align 8
  %conv57 = trunc i64 %17 to i8
  %conv58 = sext i8 %conv57 to i32
  %add59 = add nsw i32 0, %conv58
  %mul60 = mul nsw i32 0, %add59
  %add61 = add nsw i32 %mul60, 1
  %shl62 = shl i32 %add61, 30
  %sub63 = sub nsw i32 %shl62, 1
  %mul64 = mul nsw i32 %sub63, 2
  %add65 = add nsw i32 %mul64, 1
  br label %cond.end.72

cond.false.66:                                    ; preds = %cond.true.46
  %18 = load i64, i64* %nargs, align 8
  %conv67 = trunc i64 %18 to i8
  %conv68 = sext i8 %conv67 to i32
  %add69 = add nsw i32 0, %conv68
  %mul70 = mul nsw i32 0, %add69
  %sub71 = sub nsw i32 %mul70, 1
  br label %cond.end.72

cond.end.72:                                      ; preds = %cond.false.66, %cond.true.56
  %cond73 = phi i32 [ %add65, %cond.true.56 ], [ %sub71, %cond.false.66 ]
  %div = sdiv i32 %cond73, 8
  %cmp74 = icmp slt i32 %conv48, %div
  br i1 %cmp74, label %cond.true.218, label %lor.lhs.false.198

cond.false.76:                                    ; preds = %cond.true.41
  br i1 false, label %cond.true.77, label %cond.false.78

cond.true.77:                                     ; preds = %cond.false.76
  br i1 false, label %cond.true.218, label %lor.lhs.false.198

cond.false.78:                                    ; preds = %cond.false.76
  %19 = load i64, i64* %nargs, align 8
  %conv79 = trunc i64 %19 to i8
  %conv80 = sext i8 %conv79 to i32
  %add81 = add nsw i32 0, %conv80
  %mul82 = mul nsw i32 0, %add81
  %sub83 = sub nsw i32 %mul82, 1
  %cmp84 = icmp slt i32 %sub83, 0
  br i1 %cmp84, label %cond.true.86, label %cond.false.106

cond.true.86:                                     ; preds = %cond.false.78
  %20 = load i64, i64* %nargs, align 8
  %conv87 = trunc i64 %20 to i8
  %conv88 = sext i8 %conv87 to i32
  %add89 = add nsw i32 0, %conv88
  %mul90 = mul nsw i32 0, %add89
  %add91 = add nsw i32 %mul90, 0
  %neg92 = xor i32 %add91, -1
  %cmp93 = icmp eq i32 %neg92, -1
  %conv94 = zext i1 %cmp93 to i32
  %sub95 = sub nsw i32 0, %conv94
  %21 = load i64, i64* %nargs, align 8
  %conv96 = trunc i64 %21 to i8
  %conv97 = sext i8 %conv96 to i32
  %add98 = add nsw i32 0, %conv97
  %mul99 = mul nsw i32 0, %add98
  %add100 = add nsw i32 %mul99, 1
  %shl101 = shl i32 %add100, 30
  %sub102 = sub nsw i32 %shl101, 1
  %mul103 = mul nsw i32 %sub102, 2
  %add104 = add nsw i32 %mul103, 1
  %sub105 = sub nsw i32 %sub95, %add104
  br label %cond.end.112

cond.false.106:                                   ; preds = %cond.false.78
  %22 = load i64, i64* %nargs, align 8
  %conv107 = trunc i64 %22 to i8
  %conv108 = sext i8 %conv107 to i32
  %add109 = add nsw i32 0, %conv108
  %mul110 = mul nsw i32 0, %add109
  %add111 = add nsw i32 %mul110, 0
  br label %cond.end.112

cond.end.112:                                     ; preds = %cond.false.106, %cond.true.86
  %cond113 = phi i32 [ %sub105, %cond.true.86 ], [ %add111, %cond.false.106 ]
  %div114 = sdiv i32 %cond113, 8
  %23 = load i64, i64* %nargs, align 8
  %conv115 = trunc i64 %23 to i8
  %conv116 = sext i8 %conv115 to i32
  %cmp117 = icmp slt i32 %div114, %conv116
  br i1 %cmp117, label %cond.true.218, label %lor.lhs.false.198

cond.false.119:                                   ; preds = %lor.lhs.false
  br i1 false, label %cond.true.120, label %cond.false.121

cond.true.120:                                    ; preds = %cond.false.119
  br i1 false, label %cond.true.218, label %lor.lhs.false.198

cond.false.121:                                   ; preds = %cond.false.119
  %24 = load i64, i64* %nargs, align 8
  %conv122 = trunc i64 %24 to i8
  %conv123 = sext i8 %conv122 to i32
  %cmp124 = icmp slt i32 %conv123, 0
  br i1 %cmp124, label %cond.true.126, label %cond.false.167

cond.true.126:                                    ; preds = %cond.false.121
  %25 = load i64, i64* %nargs, align 8
  %conv127 = trunc i64 %25 to i8
  %conv128 = sext i8 %conv127 to i32
  %26 = load i64, i64* %nargs, align 8
  %conv129 = trunc i64 %26 to i8
  %conv130 = sext i8 %conv129 to i32
  %add131 = add nsw i32 0, %conv130
  %mul132 = mul nsw i32 0, %add131
  %sub133 = sub nsw i32 %mul132, 1
  %cmp134 = icmp slt i32 %sub133, 0
  br i1 %cmp134, label %cond.true.136, label %cond.false.156

cond.true.136:                                    ; preds = %cond.true.126
  %27 = load i64, i64* %nargs, align 8
  %conv137 = trunc i64 %27 to i8
  %conv138 = sext i8 %conv137 to i32
  %add139 = add nsw i32 0, %conv138
  %mul140 = mul nsw i32 0, %add139
  %add141 = add nsw i32 %mul140, 0
  %neg142 = xor i32 %add141, -1
  %cmp143 = icmp eq i32 %neg142, -1
  %conv144 = zext i1 %cmp143 to i32
  %sub145 = sub nsw i32 0, %conv144
  %28 = load i64, i64* %nargs, align 8
  %conv146 = trunc i64 %28 to i8
  %conv147 = sext i8 %conv146 to i32
  %add148 = add nsw i32 0, %conv147
  %mul149 = mul nsw i32 0, %add148
  %add150 = add nsw i32 %mul149, 1
  %shl151 = shl i32 %add150, 30
  %sub152 = sub nsw i32 %shl151, 1
  %mul153 = mul nsw i32 %sub152, 2
  %add154 = add nsw i32 %mul153, 1
  %sub155 = sub nsw i32 %sub145, %add154
  br label %cond.end.162

cond.false.156:                                   ; preds = %cond.true.126
  %29 = load i64, i64* %nargs, align 8
  %conv157 = trunc i64 %29 to i8
  %conv158 = sext i8 %conv157 to i32
  %add159 = add nsw i32 0, %conv158
  %mul160 = mul nsw i32 0, %add159
  %add161 = add nsw i32 %mul160, 0
  br label %cond.end.162

cond.end.162:                                     ; preds = %cond.false.156, %cond.true.136
  %cond163 = phi i32 [ %sub155, %cond.true.136 ], [ %add161, %cond.false.156 ]
  %div164 = sdiv i32 %cond163, 8
  %cmp165 = icmp slt i32 %conv128, %div164
  br i1 %cmp165, label %cond.true.218, label %lor.lhs.false.198

cond.false.167:                                   ; preds = %cond.false.121
  %30 = load i64, i64* %nargs, align 8
  %conv168 = trunc i64 %30 to i8
  %conv169 = sext i8 %conv168 to i32
  %add170 = add nsw i32 0, %conv169
  %mul171 = mul nsw i32 0, %add170
  %sub172 = sub nsw i32 %mul171, 1
  %cmp173 = icmp slt i32 %sub172, 0
  br i1 %cmp173, label %cond.true.175, label %cond.false.185

cond.true.175:                                    ; preds = %cond.false.167
  %31 = load i64, i64* %nargs, align 8
  %conv176 = trunc i64 %31 to i8
  %conv177 = sext i8 %conv176 to i32
  %add178 = add nsw i32 0, %conv177
  %mul179 = mul nsw i32 0, %add178
  %add180 = add nsw i32 %mul179, 1
  %shl181 = shl i32 %add180, 30
  %sub182 = sub nsw i32 %shl181, 1
  %mul183 = mul nsw i32 %sub182, 2
  %add184 = add nsw i32 %mul183, 1
  br label %cond.end.191

cond.false.185:                                   ; preds = %cond.false.167
  %32 = load i64, i64* %nargs, align 8
  %conv186 = trunc i64 %32 to i8
  %conv187 = sext i8 %conv186 to i32
  %add188 = add nsw i32 0, %conv187
  %mul189 = mul nsw i32 0, %add188
  %sub190 = sub nsw i32 %mul189, 1
  br label %cond.end.191

cond.end.191:                                     ; preds = %cond.false.185, %cond.true.175
  %cond192 = phi i32 [ %add184, %cond.true.175 ], [ %sub190, %cond.false.185 ]
  %div193 = sdiv i32 %cond192, 8
  %33 = load i64, i64* %nargs, align 8
  %conv194 = trunc i64 %33 to i8
  %conv195 = sext i8 %conv194 to i32
  %cmp196 = icmp slt i32 %div193, %conv195
  br i1 %cmp196, label %cond.true.218, label %lor.lhs.false.198

lor.lhs.false.198:                                ; preds = %cond.end.191, %cond.end.162, %cond.true.120, %cond.end.112, %cond.true.77, %cond.end.72
  %34 = load i64, i64* %nargs, align 8
  %conv199 = trunc i64 %34 to i8
  %conv200 = sext i8 %conv199 to i32
  %mul201 = mul nsw i32 %conv200, 8
  %mul202 = mul nsw i32 0, %mul201
  %sub203 = sub nsw i32 %mul202, 1
  %cmp204 = icmp slt i32 %sub203, 0
  br i1 %cmp204, label %land.lhs.true.206, label %lor.lhs.false.212

land.lhs.true.206:                                ; preds = %lor.lhs.false.198
  %35 = load i64, i64* %nargs, align 8
  %conv207 = trunc i64 %35 to i8
  %conv208 = sext i8 %conv207 to i32
  %mul209 = mul nsw i32 %conv208, 8
  %cmp210 = icmp slt i32 %mul209, -128
  br i1 %cmp210, label %cond.true.218, label %lor.lhs.false.212

lor.lhs.false.212:                                ; preds = %land.lhs.true.206, %lor.lhs.false.198
  %36 = load i64, i64* %nargs, align 8
  %conv213 = trunc i64 %36 to i8
  %conv214 = sext i8 %conv213 to i32
  %mul215 = mul nsw i32 %conv214, 8
  %cmp216 = icmp slt i32 127, %mul215
  br i1 %cmp216, label %cond.true.218, label %cond.false.241

cond.true.218:                                    ; preds = %lor.lhs.false.212, %land.lhs.true.206, %cond.end.191, %cond.end.162, %cond.true.120, %cond.end.112, %cond.true.77, %cond.end.72, %land.lhs.true
  %37 = load i64, i64* %nargs, align 8
  %conv219 = trunc i64 %37 to i8
  %conv220 = zext i8 %conv219 to i32
  %mul221 = mul nsw i32 %conv220, 8
  %cmp222 = icmp sle i32 %mul221, 127
  br i1 %cmp222, label %cond.true.224, label %cond.false.230

cond.true.224:                                    ; preds = %cond.true.218
  %38 = load i64, i64* %nargs, align 8
  %conv225 = trunc i64 %38 to i8
  %conv226 = zext i8 %conv225 to i32
  %mul227 = mul nsw i32 %conv226, 8
  %conv228 = trunc i32 %mul227 to i8
  %conv229 = sext i8 %conv228 to i32
  br label %cond.end.238

cond.false.230:                                   ; preds = %cond.true.218
  %39 = load i64, i64* %nargs, align 8
  %conv231 = trunc i64 %39 to i8
  %conv232 = zext i8 %conv231 to i32
  %mul233 = mul nsw i32 %conv232, 8
  %sub234 = sub nsw i32 %mul233, -128
  %conv235 = trunc i32 %sub234 to i8
  %conv236 = sext i8 %conv235 to i32
  %add237 = add nsw i32 %conv236, -128
  br label %cond.end.238

cond.end.238:                                     ; preds = %cond.false.230, %cond.true.224
  %cond239 = phi i32 [ %conv229, %cond.true.224 ], [ %add237, %cond.false.230 ]
  %conv240 = sext i32 %cond239 to i64
  store i64 %conv240, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2171, label %lor.lhs.false.2168

cond.false.241:                                   ; preds = %lor.lhs.false.212
  %40 = load i64, i64* %nargs, align 8
  %conv242 = trunc i64 %40 to i8
  %conv243 = zext i8 %conv242 to i32
  %mul244 = mul nsw i32 %conv243, 8
  %cmp245 = icmp sle i32 %mul244, 127
  br i1 %cmp245, label %cond.true.247, label %cond.false.253

cond.true.247:                                    ; preds = %cond.false.241
  %41 = load i64, i64* %nargs, align 8
  %conv248 = trunc i64 %41 to i8
  %conv249 = zext i8 %conv248 to i32
  %mul250 = mul nsw i32 %conv249, 8
  %conv251 = trunc i32 %mul250 to i8
  %conv252 = sext i8 %conv251 to i32
  br label %cond.end.261

cond.false.253:                                   ; preds = %cond.false.241
  %42 = load i64, i64* %nargs, align 8
  %conv254 = trunc i64 %42 to i8
  %conv255 = zext i8 %conv254 to i32
  %mul256 = mul nsw i32 %conv255, 8
  %sub257 = sub nsw i32 %mul256, -128
  %conv258 = trunc i32 %sub257 to i8
  %conv259 = sext i8 %conv258 to i32
  %add260 = add nsw i32 %conv259, -128
  br label %cond.end.261

cond.end.261:                                     ; preds = %cond.false.253, %cond.true.247
  %cond262 = phi i32 [ %conv252, %cond.true.247 ], [ %add260, %cond.false.253 ]
  %conv263 = sext i32 %cond262 to i64
  store i64 %conv263, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2171, label %lor.lhs.false.2168

cond.false.264:                                   ; preds = %cond.true
  %43 = load i64, i64* %nargs, align 8
  %add265 = add nsw i64 0, %43
  %mul266 = mul nsw i64 0, %add265
  %sub267 = sub nsw i64 %mul266, 1
  %cmp268 = icmp slt i64 %sub267, 0
  br i1 %cmp268, label %cond.true.270, label %cond.false.287

cond.true.270:                                    ; preds = %cond.false.264
  %44 = load i64, i64* %nargs, align 8
  %add271 = add nsw i64 0, %44
  %mul272 = mul nsw i64 0, %add271
  %add273 = add nsw i64 %mul272, 0
  %neg274 = xor i64 %add273, -1
  %cmp275 = icmp eq i64 %neg274, -1
  %conv276 = zext i1 %cmp275 to i32
  %sub277 = sub nsw i32 0, %conv276
  %conv278 = sext i32 %sub277 to i64
  %45 = load i64, i64* %nargs, align 8
  %add279 = add nsw i64 0, %45
  %mul280 = mul nsw i64 0, %add279
  %add281 = add nsw i64 %mul280, 1
  %shl282 = shl i64 %add281, 62
  %sub283 = sub nsw i64 %shl282, 1
  %mul284 = mul nsw i64 %sub283, 2
  %add285 = add nsw i64 %mul284, 1
  %sub286 = sub nsw i64 %conv278, %add285
  br label %cond.end.291

cond.false.287:                                   ; preds = %cond.false.264
  %46 = load i64, i64* %nargs, align 8
  %add288 = add nsw i64 0, %46
  %mul289 = mul nsw i64 0, %add288
  %add290 = add nsw i64 %mul289, 0
  br label %cond.end.291

cond.end.291:                                     ; preds = %cond.false.287, %cond.true.270
  %cond292 = phi i64 [ %sub286, %cond.true.270 ], [ %add290, %cond.false.287 ]
  %cmp293 = icmp eq i64 %cond292, 0
  br i1 %cmp293, label %land.lhs.true.295, label %lor.lhs.false.298

land.lhs.true.295:                                ; preds = %cond.end.291
  %47 = load i64, i64* %nargs, align 8
  %cmp296 = icmp slt i64 %47, 0
  br i1 %cmp296, label %cond.true.433, label %lor.lhs.false.298

lor.lhs.false.298:                                ; preds = %land.lhs.true.295, %cond.end.291
  br i1 false, label %cond.true.299, label %cond.false.359

cond.true.299:                                    ; preds = %lor.lhs.false.298
  %48 = load i64, i64* %nargs, align 8
  %cmp300 = icmp slt i64 %48, 0
  br i1 %cmp300, label %cond.true.302, label %cond.false.325

cond.true.302:                                    ; preds = %cond.true.299
  %49 = load i64, i64* %nargs, align 8
  %50 = load i64, i64* %nargs, align 8
  %add303 = add nsw i64 0, %50
  %mul304 = mul nsw i64 0, %add303
  %sub305 = sub nsw i64 %mul304, 1
  %cmp306 = icmp slt i64 %sub305, 0
  br i1 %cmp306, label %cond.true.308, label %cond.false.316

cond.true.308:                                    ; preds = %cond.true.302
  %51 = load i64, i64* %nargs, align 8
  %add309 = add nsw i64 0, %51
  %mul310 = mul nsw i64 0, %add309
  %add311 = add nsw i64 %mul310, 1
  %shl312 = shl i64 %add311, 62
  %sub313 = sub nsw i64 %shl312, 1
  %mul314 = mul nsw i64 %sub313, 2
  %add315 = add nsw i64 %mul314, 1
  br label %cond.end.320

cond.false.316:                                   ; preds = %cond.true.302
  %52 = load i64, i64* %nargs, align 8
  %add317 = add nsw i64 0, %52
  %mul318 = mul nsw i64 0, %add317
  %sub319 = sub nsw i64 %mul318, 1
  br label %cond.end.320

cond.end.320:                                     ; preds = %cond.false.316, %cond.true.308
  %cond321 = phi i64 [ %add315, %cond.true.308 ], [ %sub319, %cond.false.316 ]
  %div322 = sdiv i64 %cond321, 8
  %cmp323 = icmp slt i64 %49, %div322
  br i1 %cmp323, label %cond.true.433, label %lor.lhs.false.419

cond.false.325:                                   ; preds = %cond.true.299
  br i1 false, label %cond.true.326, label %cond.false.327

cond.true.326:                                    ; preds = %cond.false.325
  br i1 false, label %cond.true.433, label %lor.lhs.false.419

cond.false.327:                                   ; preds = %cond.false.325
  %53 = load i64, i64* %nargs, align 8
  %add328 = add nsw i64 0, %53
  %mul329 = mul nsw i64 0, %add328
  %sub330 = sub nsw i64 %mul329, 1
  %cmp331 = icmp slt i64 %sub330, 0
  br i1 %cmp331, label %cond.true.333, label %cond.false.350

cond.true.333:                                    ; preds = %cond.false.327
  %54 = load i64, i64* %nargs, align 8
  %add334 = add nsw i64 0, %54
  %mul335 = mul nsw i64 0, %add334
  %add336 = add nsw i64 %mul335, 0
  %neg337 = xor i64 %add336, -1
  %cmp338 = icmp eq i64 %neg337, -1
  %conv339 = zext i1 %cmp338 to i32
  %sub340 = sub nsw i32 0, %conv339
  %conv341 = sext i32 %sub340 to i64
  %55 = load i64, i64* %nargs, align 8
  %add342 = add nsw i64 0, %55
  %mul343 = mul nsw i64 0, %add342
  %add344 = add nsw i64 %mul343, 1
  %shl345 = shl i64 %add344, 62
  %sub346 = sub nsw i64 %shl345, 1
  %mul347 = mul nsw i64 %sub346, 2
  %add348 = add nsw i64 %mul347, 1
  %sub349 = sub nsw i64 %conv341, %add348
  br label %cond.end.354

cond.false.350:                                   ; preds = %cond.false.327
  %56 = load i64, i64* %nargs, align 8
  %add351 = add nsw i64 0, %56
  %mul352 = mul nsw i64 0, %add351
  %add353 = add nsw i64 %mul352, 0
  br label %cond.end.354

cond.end.354:                                     ; preds = %cond.false.350, %cond.true.333
  %cond355 = phi i64 [ %sub349, %cond.true.333 ], [ %add353, %cond.false.350 ]
  %div356 = sdiv i64 %cond355, 8
  %57 = load i64, i64* %nargs, align 8
  %cmp357 = icmp slt i64 %div356, %57
  br i1 %cmp357, label %cond.true.433, label %lor.lhs.false.419

cond.false.359:                                   ; preds = %lor.lhs.false.298
  br i1 false, label %cond.true.360, label %cond.false.361

cond.true.360:                                    ; preds = %cond.false.359
  br i1 false, label %cond.true.433, label %lor.lhs.false.419

cond.false.361:                                   ; preds = %cond.false.359
  %58 = load i64, i64* %nargs, align 8
  %cmp362 = icmp slt i64 %58, 0
  br i1 %cmp362, label %cond.true.364, label %cond.false.396

cond.true.364:                                    ; preds = %cond.false.361
  %59 = load i64, i64* %nargs, align 8
  %60 = load i64, i64* %nargs, align 8
  %add365 = add nsw i64 0, %60
  %mul366 = mul nsw i64 0, %add365
  %sub367 = sub nsw i64 %mul366, 1
  %cmp368 = icmp slt i64 %sub367, 0
  br i1 %cmp368, label %cond.true.370, label %cond.false.387

cond.true.370:                                    ; preds = %cond.true.364
  %61 = load i64, i64* %nargs, align 8
  %add371 = add nsw i64 0, %61
  %mul372 = mul nsw i64 0, %add371
  %add373 = add nsw i64 %mul372, 0
  %neg374 = xor i64 %add373, -1
  %cmp375 = icmp eq i64 %neg374, -1
  %conv376 = zext i1 %cmp375 to i32
  %sub377 = sub nsw i32 0, %conv376
  %conv378 = sext i32 %sub377 to i64
  %62 = load i64, i64* %nargs, align 8
  %add379 = add nsw i64 0, %62
  %mul380 = mul nsw i64 0, %add379
  %add381 = add nsw i64 %mul380, 1
  %shl382 = shl i64 %add381, 62
  %sub383 = sub nsw i64 %shl382, 1
  %mul384 = mul nsw i64 %sub383, 2
  %add385 = add nsw i64 %mul384, 1
  %sub386 = sub nsw i64 %conv378, %add385
  br label %cond.end.391

cond.false.387:                                   ; preds = %cond.true.364
  %63 = load i64, i64* %nargs, align 8
  %add388 = add nsw i64 0, %63
  %mul389 = mul nsw i64 0, %add388
  %add390 = add nsw i64 %mul389, 0
  br label %cond.end.391

cond.end.391:                                     ; preds = %cond.false.387, %cond.true.370
  %cond392 = phi i64 [ %sub386, %cond.true.370 ], [ %add390, %cond.false.387 ]
  %div393 = sdiv i64 %cond392, 8
  %cmp394 = icmp slt i64 %59, %div393
  br i1 %cmp394, label %cond.true.433, label %lor.lhs.false.419

cond.false.396:                                   ; preds = %cond.false.361
  %64 = load i64, i64* %nargs, align 8
  %add397 = add nsw i64 0, %64
  %mul398 = mul nsw i64 0, %add397
  %sub399 = sub nsw i64 %mul398, 1
  %cmp400 = icmp slt i64 %sub399, 0
  br i1 %cmp400, label %cond.true.402, label %cond.false.410

cond.true.402:                                    ; preds = %cond.false.396
  %65 = load i64, i64* %nargs, align 8
  %add403 = add nsw i64 0, %65
  %mul404 = mul nsw i64 0, %add403
  %add405 = add nsw i64 %mul404, 1
  %shl406 = shl i64 %add405, 62
  %sub407 = sub nsw i64 %shl406, 1
  %mul408 = mul nsw i64 %sub407, 2
  %add409 = add nsw i64 %mul408, 1
  br label %cond.end.414

cond.false.410:                                   ; preds = %cond.false.396
  %66 = load i64, i64* %nargs, align 8
  %add411 = add nsw i64 0, %66
  %mul412 = mul nsw i64 0, %add411
  %sub413 = sub nsw i64 %mul412, 1
  br label %cond.end.414

cond.end.414:                                     ; preds = %cond.false.410, %cond.true.402
  %cond415 = phi i64 [ %add409, %cond.true.402 ], [ %sub413, %cond.false.410 ]
  %div416 = sdiv i64 %cond415, 8
  %67 = load i64, i64* %nargs, align 8
  %cmp417 = icmp slt i64 %div416, %67
  br i1 %cmp417, label %cond.true.433, label %lor.lhs.false.419

lor.lhs.false.419:                                ; preds = %cond.end.414, %cond.end.391, %cond.true.360, %cond.end.354, %cond.true.326, %cond.end.320
  %68 = load i64, i64* %nargs, align 8
  %mul420 = mul nsw i64 %68, 8
  %mul421 = mul nsw i64 0, %mul420
  %sub422 = sub nsw i64 %mul421, 1
  %cmp423 = icmp slt i64 %sub422, 0
  br i1 %cmp423, label %land.lhs.true.425, label %lor.lhs.false.429

land.lhs.true.425:                                ; preds = %lor.lhs.false.419
  %69 = load i64, i64* %nargs, align 8
  %mul426 = mul nsw i64 %69, 8
  %cmp427 = icmp slt i64 %mul426, -128
  br i1 %cmp427, label %cond.true.433, label %lor.lhs.false.429

lor.lhs.false.429:                                ; preds = %land.lhs.true.425, %lor.lhs.false.419
  %70 = load i64, i64* %nargs, align 8
  %mul430 = mul nsw i64 %70, 8
  %cmp431 = icmp slt i64 127, %mul430
  br i1 %cmp431, label %cond.true.433, label %cond.false.456

cond.true.433:                                    ; preds = %lor.lhs.false.429, %land.lhs.true.425, %cond.end.414, %cond.end.391, %cond.true.360, %cond.end.354, %cond.true.326, %cond.end.320, %land.lhs.true.295
  %71 = load i64, i64* %nargs, align 8
  %conv434 = trunc i64 %71 to i8
  %conv435 = zext i8 %conv434 to i32
  %mul436 = mul nsw i32 %conv435, 8
  %cmp437 = icmp sle i32 %mul436, 127
  br i1 %cmp437, label %cond.true.439, label %cond.false.445

cond.true.439:                                    ; preds = %cond.true.433
  %72 = load i64, i64* %nargs, align 8
  %conv440 = trunc i64 %72 to i8
  %conv441 = zext i8 %conv440 to i32
  %mul442 = mul nsw i32 %conv441, 8
  %conv443 = trunc i32 %mul442 to i8
  %conv444 = sext i8 %conv443 to i32
  br label %cond.end.453

cond.false.445:                                   ; preds = %cond.true.433
  %73 = load i64, i64* %nargs, align 8
  %conv446 = trunc i64 %73 to i8
  %conv447 = zext i8 %conv446 to i32
  %mul448 = mul nsw i32 %conv447, 8
  %sub449 = sub nsw i32 %mul448, -128
  %conv450 = trunc i32 %sub449 to i8
  %conv451 = sext i8 %conv450 to i32
  %add452 = add nsw i32 %conv451, -128
  br label %cond.end.453

cond.end.453:                                     ; preds = %cond.false.445, %cond.true.439
  %cond454 = phi i32 [ %conv444, %cond.true.439 ], [ %add452, %cond.false.445 ]
  %conv455 = sext i32 %cond454 to i64
  store i64 %conv455, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2171, label %lor.lhs.false.2168

cond.false.456:                                   ; preds = %lor.lhs.false.429
  %74 = load i64, i64* %nargs, align 8
  %conv457 = trunc i64 %74 to i8
  %conv458 = zext i8 %conv457 to i32
  %mul459 = mul nsw i32 %conv458, 8
  %cmp460 = icmp sle i32 %mul459, 127
  br i1 %cmp460, label %cond.true.462, label %cond.false.468

cond.true.462:                                    ; preds = %cond.false.456
  %75 = load i64, i64* %nargs, align 8
  %conv463 = trunc i64 %75 to i8
  %conv464 = zext i8 %conv463 to i32
  %mul465 = mul nsw i32 %conv464, 8
  %conv466 = trunc i32 %mul465 to i8
  %conv467 = sext i8 %conv466 to i32
  br label %cond.end.476

cond.false.468:                                   ; preds = %cond.false.456
  %76 = load i64, i64* %nargs, align 8
  %conv469 = trunc i64 %76 to i8
  %conv470 = zext i8 %conv469 to i32
  %mul471 = mul nsw i32 %conv470, 8
  %sub472 = sub nsw i32 %mul471, -128
  %conv473 = trunc i32 %sub472 to i8
  %conv474 = sext i8 %conv473 to i32
  %add475 = add nsw i32 %conv474, -128
  br label %cond.end.476

cond.end.476:                                     ; preds = %cond.false.468, %cond.true.462
  %cond477 = phi i32 [ %conv467, %cond.true.462 ], [ %add475, %cond.false.468 ]
  %conv478 = sext i32 %cond477 to i64
  store i64 %conv478, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2171, label %lor.lhs.false.2168

cond.false.479:                                   ; preds = %do.body
  br i1 false, label %cond.true.480, label %cond.false.964

cond.true.480:                                    ; preds = %cond.false.479
  br i1 false, label %cond.true.481, label %cond.false.749

cond.true.481:                                    ; preds = %cond.true.480
  %77 = load i64, i64* %nargs, align 8
  %conv482 = trunc i64 %77 to i16
  %conv483 = sext i16 %conv482 to i32
  %add484 = add nsw i32 0, %conv483
  %mul485 = mul nsw i32 0, %add484
  %sub486 = sub nsw i32 %mul485, 1
  %cmp487 = icmp slt i32 %sub486, 0
  br i1 %cmp487, label %cond.true.489, label %cond.false.509

cond.true.489:                                    ; preds = %cond.true.481
  %78 = load i64, i64* %nargs, align 8
  %conv490 = trunc i64 %78 to i16
  %conv491 = sext i16 %conv490 to i32
  %add492 = add nsw i32 0, %conv491
  %mul493 = mul nsw i32 0, %add492
  %add494 = add nsw i32 %mul493, 0
  %neg495 = xor i32 %add494, -1
  %cmp496 = icmp eq i32 %neg495, -1
  %conv497 = zext i1 %cmp496 to i32
  %sub498 = sub nsw i32 0, %conv497
  %79 = load i64, i64* %nargs, align 8
  %conv499 = trunc i64 %79 to i16
  %conv500 = sext i16 %conv499 to i32
  %add501 = add nsw i32 0, %conv500
  %mul502 = mul nsw i32 0, %add501
  %add503 = add nsw i32 %mul502, 1
  %shl504 = shl i32 %add503, 30
  %sub505 = sub nsw i32 %shl504, 1
  %mul506 = mul nsw i32 %sub505, 2
  %add507 = add nsw i32 %mul506, 1
  %sub508 = sub nsw i32 %sub498, %add507
  br label %cond.end.515

cond.false.509:                                   ; preds = %cond.true.481
  %80 = load i64, i64* %nargs, align 8
  %conv510 = trunc i64 %80 to i16
  %conv511 = sext i16 %conv510 to i32
  %add512 = add nsw i32 0, %conv511
  %mul513 = mul nsw i32 0, %add512
  %add514 = add nsw i32 %mul513, 0
  br label %cond.end.515

cond.end.515:                                     ; preds = %cond.false.509, %cond.true.489
  %cond516 = phi i32 [ %sub508, %cond.true.489 ], [ %add514, %cond.false.509 ]
  %cmp517 = icmp eq i32 %cond516, 0
  br i1 %cmp517, label %land.lhs.true.519, label %lor.lhs.false.524

land.lhs.true.519:                                ; preds = %cond.end.515
  %81 = load i64, i64* %nargs, align 8
  %conv520 = trunc i64 %81 to i16
  %conv521 = sext i16 %conv520 to i32
  %cmp522 = icmp slt i32 %conv521, 0
  br i1 %cmp522, label %cond.true.703, label %lor.lhs.false.524

lor.lhs.false.524:                                ; preds = %land.lhs.true.519, %cond.end.515
  br i1 false, label %cond.true.525, label %cond.false.604

cond.true.525:                                    ; preds = %lor.lhs.false.524
  %82 = load i64, i64* %nargs, align 8
  %conv526 = trunc i64 %82 to i16
  %conv527 = sext i16 %conv526 to i32
  %cmp528 = icmp slt i32 %conv527, 0
  br i1 %cmp528, label %cond.true.530, label %cond.false.561

cond.true.530:                                    ; preds = %cond.true.525
  %83 = load i64, i64* %nargs, align 8
  %conv531 = trunc i64 %83 to i16
  %conv532 = sext i16 %conv531 to i32
  %84 = load i64, i64* %nargs, align 8
  %conv533 = trunc i64 %84 to i16
  %conv534 = sext i16 %conv533 to i32
  %add535 = add nsw i32 0, %conv534
  %mul536 = mul nsw i32 0, %add535
  %sub537 = sub nsw i32 %mul536, 1
  %cmp538 = icmp slt i32 %sub537, 0
  br i1 %cmp538, label %cond.true.540, label %cond.false.550

cond.true.540:                                    ; preds = %cond.true.530
  %85 = load i64, i64* %nargs, align 8
  %conv541 = trunc i64 %85 to i16
  %conv542 = sext i16 %conv541 to i32
  %add543 = add nsw i32 0, %conv542
  %mul544 = mul nsw i32 0, %add543
  %add545 = add nsw i32 %mul544, 1
  %shl546 = shl i32 %add545, 30
  %sub547 = sub nsw i32 %shl546, 1
  %mul548 = mul nsw i32 %sub547, 2
  %add549 = add nsw i32 %mul548, 1
  br label %cond.end.556

cond.false.550:                                   ; preds = %cond.true.530
  %86 = load i64, i64* %nargs, align 8
  %conv551 = trunc i64 %86 to i16
  %conv552 = sext i16 %conv551 to i32
  %add553 = add nsw i32 0, %conv552
  %mul554 = mul nsw i32 0, %add553
  %sub555 = sub nsw i32 %mul554, 1
  br label %cond.end.556

cond.end.556:                                     ; preds = %cond.false.550, %cond.true.540
  %cond557 = phi i32 [ %add549, %cond.true.540 ], [ %sub555, %cond.false.550 ]
  %div558 = sdiv i32 %cond557, 8
  %cmp559 = icmp slt i32 %conv532, %div558
  br i1 %cmp559, label %cond.true.703, label %lor.lhs.false.683

cond.false.561:                                   ; preds = %cond.true.525
  br i1 false, label %cond.true.562, label %cond.false.563

cond.true.562:                                    ; preds = %cond.false.561
  br i1 false, label %cond.true.703, label %lor.lhs.false.683

cond.false.563:                                   ; preds = %cond.false.561
  %87 = load i64, i64* %nargs, align 8
  %conv564 = trunc i64 %87 to i16
  %conv565 = sext i16 %conv564 to i32
  %add566 = add nsw i32 0, %conv565
  %mul567 = mul nsw i32 0, %add566
  %sub568 = sub nsw i32 %mul567, 1
  %cmp569 = icmp slt i32 %sub568, 0
  br i1 %cmp569, label %cond.true.571, label %cond.false.591

cond.true.571:                                    ; preds = %cond.false.563
  %88 = load i64, i64* %nargs, align 8
  %conv572 = trunc i64 %88 to i16
  %conv573 = sext i16 %conv572 to i32
  %add574 = add nsw i32 0, %conv573
  %mul575 = mul nsw i32 0, %add574
  %add576 = add nsw i32 %mul575, 0
  %neg577 = xor i32 %add576, -1
  %cmp578 = icmp eq i32 %neg577, -1
  %conv579 = zext i1 %cmp578 to i32
  %sub580 = sub nsw i32 0, %conv579
  %89 = load i64, i64* %nargs, align 8
  %conv581 = trunc i64 %89 to i16
  %conv582 = sext i16 %conv581 to i32
  %add583 = add nsw i32 0, %conv582
  %mul584 = mul nsw i32 0, %add583
  %add585 = add nsw i32 %mul584, 1
  %shl586 = shl i32 %add585, 30
  %sub587 = sub nsw i32 %shl586, 1
  %mul588 = mul nsw i32 %sub587, 2
  %add589 = add nsw i32 %mul588, 1
  %sub590 = sub nsw i32 %sub580, %add589
  br label %cond.end.597

cond.false.591:                                   ; preds = %cond.false.563
  %90 = load i64, i64* %nargs, align 8
  %conv592 = trunc i64 %90 to i16
  %conv593 = sext i16 %conv592 to i32
  %add594 = add nsw i32 0, %conv593
  %mul595 = mul nsw i32 0, %add594
  %add596 = add nsw i32 %mul595, 0
  br label %cond.end.597

cond.end.597:                                     ; preds = %cond.false.591, %cond.true.571
  %cond598 = phi i32 [ %sub590, %cond.true.571 ], [ %add596, %cond.false.591 ]
  %div599 = sdiv i32 %cond598, 8
  %91 = load i64, i64* %nargs, align 8
  %conv600 = trunc i64 %91 to i16
  %conv601 = sext i16 %conv600 to i32
  %cmp602 = icmp slt i32 %div599, %conv601
  br i1 %cmp602, label %cond.true.703, label %lor.lhs.false.683

cond.false.604:                                   ; preds = %lor.lhs.false.524
  br i1 false, label %cond.true.605, label %cond.false.606

cond.true.605:                                    ; preds = %cond.false.604
  br i1 false, label %cond.true.703, label %lor.lhs.false.683

cond.false.606:                                   ; preds = %cond.false.604
  %92 = load i64, i64* %nargs, align 8
  %conv607 = trunc i64 %92 to i16
  %conv608 = sext i16 %conv607 to i32
  %cmp609 = icmp slt i32 %conv608, 0
  br i1 %cmp609, label %cond.true.611, label %cond.false.652

cond.true.611:                                    ; preds = %cond.false.606
  %93 = load i64, i64* %nargs, align 8
  %conv612 = trunc i64 %93 to i16
  %conv613 = sext i16 %conv612 to i32
  %94 = load i64, i64* %nargs, align 8
  %conv614 = trunc i64 %94 to i16
  %conv615 = sext i16 %conv614 to i32
  %add616 = add nsw i32 0, %conv615
  %mul617 = mul nsw i32 0, %add616
  %sub618 = sub nsw i32 %mul617, 1
  %cmp619 = icmp slt i32 %sub618, 0
  br i1 %cmp619, label %cond.true.621, label %cond.false.641

cond.true.621:                                    ; preds = %cond.true.611
  %95 = load i64, i64* %nargs, align 8
  %conv622 = trunc i64 %95 to i16
  %conv623 = sext i16 %conv622 to i32
  %add624 = add nsw i32 0, %conv623
  %mul625 = mul nsw i32 0, %add624
  %add626 = add nsw i32 %mul625, 0
  %neg627 = xor i32 %add626, -1
  %cmp628 = icmp eq i32 %neg627, -1
  %conv629 = zext i1 %cmp628 to i32
  %sub630 = sub nsw i32 0, %conv629
  %96 = load i64, i64* %nargs, align 8
  %conv631 = trunc i64 %96 to i16
  %conv632 = sext i16 %conv631 to i32
  %add633 = add nsw i32 0, %conv632
  %mul634 = mul nsw i32 0, %add633
  %add635 = add nsw i32 %mul634, 1
  %shl636 = shl i32 %add635, 30
  %sub637 = sub nsw i32 %shl636, 1
  %mul638 = mul nsw i32 %sub637, 2
  %add639 = add nsw i32 %mul638, 1
  %sub640 = sub nsw i32 %sub630, %add639
  br label %cond.end.647

cond.false.641:                                   ; preds = %cond.true.611
  %97 = load i64, i64* %nargs, align 8
  %conv642 = trunc i64 %97 to i16
  %conv643 = sext i16 %conv642 to i32
  %add644 = add nsw i32 0, %conv643
  %mul645 = mul nsw i32 0, %add644
  %add646 = add nsw i32 %mul645, 0
  br label %cond.end.647

cond.end.647:                                     ; preds = %cond.false.641, %cond.true.621
  %cond648 = phi i32 [ %sub640, %cond.true.621 ], [ %add646, %cond.false.641 ]
  %div649 = sdiv i32 %cond648, 8
  %cmp650 = icmp slt i32 %conv613, %div649
  br i1 %cmp650, label %cond.true.703, label %lor.lhs.false.683

cond.false.652:                                   ; preds = %cond.false.606
  %98 = load i64, i64* %nargs, align 8
  %conv653 = trunc i64 %98 to i16
  %conv654 = sext i16 %conv653 to i32
  %add655 = add nsw i32 0, %conv654
  %mul656 = mul nsw i32 0, %add655
  %sub657 = sub nsw i32 %mul656, 1
  %cmp658 = icmp slt i32 %sub657, 0
  br i1 %cmp658, label %cond.true.660, label %cond.false.670

cond.true.660:                                    ; preds = %cond.false.652
  %99 = load i64, i64* %nargs, align 8
  %conv661 = trunc i64 %99 to i16
  %conv662 = sext i16 %conv661 to i32
  %add663 = add nsw i32 0, %conv662
  %mul664 = mul nsw i32 0, %add663
  %add665 = add nsw i32 %mul664, 1
  %shl666 = shl i32 %add665, 30
  %sub667 = sub nsw i32 %shl666, 1
  %mul668 = mul nsw i32 %sub667, 2
  %add669 = add nsw i32 %mul668, 1
  br label %cond.end.676

cond.false.670:                                   ; preds = %cond.false.652
  %100 = load i64, i64* %nargs, align 8
  %conv671 = trunc i64 %100 to i16
  %conv672 = sext i16 %conv671 to i32
  %add673 = add nsw i32 0, %conv672
  %mul674 = mul nsw i32 0, %add673
  %sub675 = sub nsw i32 %mul674, 1
  br label %cond.end.676

cond.end.676:                                     ; preds = %cond.false.670, %cond.true.660
  %cond677 = phi i32 [ %add669, %cond.true.660 ], [ %sub675, %cond.false.670 ]
  %div678 = sdiv i32 %cond677, 8
  %101 = load i64, i64* %nargs, align 8
  %conv679 = trunc i64 %101 to i16
  %conv680 = sext i16 %conv679 to i32
  %cmp681 = icmp slt i32 %div678, %conv680
  br i1 %cmp681, label %cond.true.703, label %lor.lhs.false.683

lor.lhs.false.683:                                ; preds = %cond.end.676, %cond.end.647, %cond.true.605, %cond.end.597, %cond.true.562, %cond.end.556
  %102 = load i64, i64* %nargs, align 8
  %conv684 = trunc i64 %102 to i16
  %conv685 = sext i16 %conv684 to i32
  %mul686 = mul nsw i32 %conv685, 8
  %mul687 = mul nsw i32 0, %mul686
  %sub688 = sub nsw i32 %mul687, 1
  %cmp689 = icmp slt i32 %sub688, 0
  br i1 %cmp689, label %land.lhs.true.691, label %lor.lhs.false.697

land.lhs.true.691:                                ; preds = %lor.lhs.false.683
  %103 = load i64, i64* %nargs, align 8
  %conv692 = trunc i64 %103 to i16
  %conv693 = sext i16 %conv692 to i32
  %mul694 = mul nsw i32 %conv693, 8
  %cmp695 = icmp slt i32 %mul694, -32768
  br i1 %cmp695, label %cond.true.703, label %lor.lhs.false.697

lor.lhs.false.697:                                ; preds = %land.lhs.true.691, %lor.lhs.false.683
  %104 = load i64, i64* %nargs, align 8
  %conv698 = trunc i64 %104 to i16
  %conv699 = sext i16 %conv698 to i32
  %mul700 = mul nsw i32 %conv699, 8
  %cmp701 = icmp slt i32 32767, %mul700
  br i1 %cmp701, label %cond.true.703, label %cond.false.726

cond.true.703:                                    ; preds = %lor.lhs.false.697, %land.lhs.true.691, %cond.end.676, %cond.end.647, %cond.true.605, %cond.end.597, %cond.true.562, %cond.end.556, %land.lhs.true.519
  %105 = load i64, i64* %nargs, align 8
  %conv704 = trunc i64 %105 to i16
  %conv705 = zext i16 %conv704 to i32
  %mul706 = mul nsw i32 %conv705, 8
  %cmp707 = icmp sle i32 %mul706, 32767
  br i1 %cmp707, label %cond.true.709, label %cond.false.715

cond.true.709:                                    ; preds = %cond.true.703
  %106 = load i64, i64* %nargs, align 8
  %conv710 = trunc i64 %106 to i16
  %conv711 = zext i16 %conv710 to i32
  %mul712 = mul nsw i32 %conv711, 8
  %conv713 = trunc i32 %mul712 to i16
  %conv714 = sext i16 %conv713 to i32
  br label %cond.end.723

cond.false.715:                                   ; preds = %cond.true.703
  %107 = load i64, i64* %nargs, align 8
  %conv716 = trunc i64 %107 to i16
  %conv717 = zext i16 %conv716 to i32
  %mul718 = mul nsw i32 %conv717, 8
  %sub719 = sub nsw i32 %mul718, -32768
  %conv720 = trunc i32 %sub719 to i16
  %conv721 = sext i16 %conv720 to i32
  %add722 = add nsw i32 %conv721, -32768
  br label %cond.end.723

cond.end.723:                                     ; preds = %cond.false.715, %cond.true.709
  %cond724 = phi i32 [ %conv714, %cond.true.709 ], [ %add722, %cond.false.715 ]
  %conv725 = sext i32 %cond724 to i64
  store i64 %conv725, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2171, label %lor.lhs.false.2168

cond.false.726:                                   ; preds = %lor.lhs.false.697
  %108 = load i64, i64* %nargs, align 8
  %conv727 = trunc i64 %108 to i16
  %conv728 = zext i16 %conv727 to i32
  %mul729 = mul nsw i32 %conv728, 8
  %cmp730 = icmp sle i32 %mul729, 32767
  br i1 %cmp730, label %cond.true.732, label %cond.false.738

cond.true.732:                                    ; preds = %cond.false.726
  %109 = load i64, i64* %nargs, align 8
  %conv733 = trunc i64 %109 to i16
  %conv734 = zext i16 %conv733 to i32
  %mul735 = mul nsw i32 %conv734, 8
  %conv736 = trunc i32 %mul735 to i16
  %conv737 = sext i16 %conv736 to i32
  br label %cond.end.746

cond.false.738:                                   ; preds = %cond.false.726
  %110 = load i64, i64* %nargs, align 8
  %conv739 = trunc i64 %110 to i16
  %conv740 = zext i16 %conv739 to i32
  %mul741 = mul nsw i32 %conv740, 8
  %sub742 = sub nsw i32 %mul741, -32768
  %conv743 = trunc i32 %sub742 to i16
  %conv744 = sext i16 %conv743 to i32
  %add745 = add nsw i32 %conv744, -32768
  br label %cond.end.746

cond.end.746:                                     ; preds = %cond.false.738, %cond.true.732
  %cond747 = phi i32 [ %conv737, %cond.true.732 ], [ %add745, %cond.false.738 ]
  %conv748 = sext i32 %cond747 to i64
  store i64 %conv748, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2171, label %lor.lhs.false.2168

cond.false.749:                                   ; preds = %cond.true.480
  %111 = load i64, i64* %nargs, align 8
  %add750 = add nsw i64 0, %111
  %mul751 = mul nsw i64 0, %add750
  %sub752 = sub nsw i64 %mul751, 1
  %cmp753 = icmp slt i64 %sub752, 0
  br i1 %cmp753, label %cond.true.755, label %cond.false.772

cond.true.755:                                    ; preds = %cond.false.749
  %112 = load i64, i64* %nargs, align 8
  %add756 = add nsw i64 0, %112
  %mul757 = mul nsw i64 0, %add756
  %add758 = add nsw i64 %mul757, 0
  %neg759 = xor i64 %add758, -1
  %cmp760 = icmp eq i64 %neg759, -1
  %conv761 = zext i1 %cmp760 to i32
  %sub762 = sub nsw i32 0, %conv761
  %conv763 = sext i32 %sub762 to i64
  %113 = load i64, i64* %nargs, align 8
  %add764 = add nsw i64 0, %113
  %mul765 = mul nsw i64 0, %add764
  %add766 = add nsw i64 %mul765, 1
  %shl767 = shl i64 %add766, 62
  %sub768 = sub nsw i64 %shl767, 1
  %mul769 = mul nsw i64 %sub768, 2
  %add770 = add nsw i64 %mul769, 1
  %sub771 = sub nsw i64 %conv763, %add770
  br label %cond.end.776

cond.false.772:                                   ; preds = %cond.false.749
  %114 = load i64, i64* %nargs, align 8
  %add773 = add nsw i64 0, %114
  %mul774 = mul nsw i64 0, %add773
  %add775 = add nsw i64 %mul774, 0
  br label %cond.end.776

cond.end.776:                                     ; preds = %cond.false.772, %cond.true.755
  %cond777 = phi i64 [ %sub771, %cond.true.755 ], [ %add775, %cond.false.772 ]
  %cmp778 = icmp eq i64 %cond777, 0
  br i1 %cmp778, label %land.lhs.true.780, label %lor.lhs.false.783

land.lhs.true.780:                                ; preds = %cond.end.776
  %115 = load i64, i64* %nargs, align 8
  %cmp781 = icmp slt i64 %115, 0
  br i1 %cmp781, label %cond.true.918, label %lor.lhs.false.783

lor.lhs.false.783:                                ; preds = %land.lhs.true.780, %cond.end.776
  br i1 false, label %cond.true.784, label %cond.false.844

cond.true.784:                                    ; preds = %lor.lhs.false.783
  %116 = load i64, i64* %nargs, align 8
  %cmp785 = icmp slt i64 %116, 0
  br i1 %cmp785, label %cond.true.787, label %cond.false.810

cond.true.787:                                    ; preds = %cond.true.784
  %117 = load i64, i64* %nargs, align 8
  %118 = load i64, i64* %nargs, align 8
  %add788 = add nsw i64 0, %118
  %mul789 = mul nsw i64 0, %add788
  %sub790 = sub nsw i64 %mul789, 1
  %cmp791 = icmp slt i64 %sub790, 0
  br i1 %cmp791, label %cond.true.793, label %cond.false.801

cond.true.793:                                    ; preds = %cond.true.787
  %119 = load i64, i64* %nargs, align 8
  %add794 = add nsw i64 0, %119
  %mul795 = mul nsw i64 0, %add794
  %add796 = add nsw i64 %mul795, 1
  %shl797 = shl i64 %add796, 62
  %sub798 = sub nsw i64 %shl797, 1
  %mul799 = mul nsw i64 %sub798, 2
  %add800 = add nsw i64 %mul799, 1
  br label %cond.end.805

cond.false.801:                                   ; preds = %cond.true.787
  %120 = load i64, i64* %nargs, align 8
  %add802 = add nsw i64 0, %120
  %mul803 = mul nsw i64 0, %add802
  %sub804 = sub nsw i64 %mul803, 1
  br label %cond.end.805

cond.end.805:                                     ; preds = %cond.false.801, %cond.true.793
  %cond806 = phi i64 [ %add800, %cond.true.793 ], [ %sub804, %cond.false.801 ]
  %div807 = sdiv i64 %cond806, 8
  %cmp808 = icmp slt i64 %117, %div807
  br i1 %cmp808, label %cond.true.918, label %lor.lhs.false.904

cond.false.810:                                   ; preds = %cond.true.784
  br i1 false, label %cond.true.811, label %cond.false.812

cond.true.811:                                    ; preds = %cond.false.810
  br i1 false, label %cond.true.918, label %lor.lhs.false.904

cond.false.812:                                   ; preds = %cond.false.810
  %121 = load i64, i64* %nargs, align 8
  %add813 = add nsw i64 0, %121
  %mul814 = mul nsw i64 0, %add813
  %sub815 = sub nsw i64 %mul814, 1
  %cmp816 = icmp slt i64 %sub815, 0
  br i1 %cmp816, label %cond.true.818, label %cond.false.835

cond.true.818:                                    ; preds = %cond.false.812
  %122 = load i64, i64* %nargs, align 8
  %add819 = add nsw i64 0, %122
  %mul820 = mul nsw i64 0, %add819
  %add821 = add nsw i64 %mul820, 0
  %neg822 = xor i64 %add821, -1
  %cmp823 = icmp eq i64 %neg822, -1
  %conv824 = zext i1 %cmp823 to i32
  %sub825 = sub nsw i32 0, %conv824
  %conv826 = sext i32 %sub825 to i64
  %123 = load i64, i64* %nargs, align 8
  %add827 = add nsw i64 0, %123
  %mul828 = mul nsw i64 0, %add827
  %add829 = add nsw i64 %mul828, 1
  %shl830 = shl i64 %add829, 62
  %sub831 = sub nsw i64 %shl830, 1
  %mul832 = mul nsw i64 %sub831, 2
  %add833 = add nsw i64 %mul832, 1
  %sub834 = sub nsw i64 %conv826, %add833
  br label %cond.end.839

cond.false.835:                                   ; preds = %cond.false.812
  %124 = load i64, i64* %nargs, align 8
  %add836 = add nsw i64 0, %124
  %mul837 = mul nsw i64 0, %add836
  %add838 = add nsw i64 %mul837, 0
  br label %cond.end.839

cond.end.839:                                     ; preds = %cond.false.835, %cond.true.818
  %cond840 = phi i64 [ %sub834, %cond.true.818 ], [ %add838, %cond.false.835 ]
  %div841 = sdiv i64 %cond840, 8
  %125 = load i64, i64* %nargs, align 8
  %cmp842 = icmp slt i64 %div841, %125
  br i1 %cmp842, label %cond.true.918, label %lor.lhs.false.904

cond.false.844:                                   ; preds = %lor.lhs.false.783
  br i1 false, label %cond.true.845, label %cond.false.846

cond.true.845:                                    ; preds = %cond.false.844
  br i1 false, label %cond.true.918, label %lor.lhs.false.904

cond.false.846:                                   ; preds = %cond.false.844
  %126 = load i64, i64* %nargs, align 8
  %cmp847 = icmp slt i64 %126, 0
  br i1 %cmp847, label %cond.true.849, label %cond.false.881

cond.true.849:                                    ; preds = %cond.false.846
  %127 = load i64, i64* %nargs, align 8
  %128 = load i64, i64* %nargs, align 8
  %add850 = add nsw i64 0, %128
  %mul851 = mul nsw i64 0, %add850
  %sub852 = sub nsw i64 %mul851, 1
  %cmp853 = icmp slt i64 %sub852, 0
  br i1 %cmp853, label %cond.true.855, label %cond.false.872

cond.true.855:                                    ; preds = %cond.true.849
  %129 = load i64, i64* %nargs, align 8
  %add856 = add nsw i64 0, %129
  %mul857 = mul nsw i64 0, %add856
  %add858 = add nsw i64 %mul857, 0
  %neg859 = xor i64 %add858, -1
  %cmp860 = icmp eq i64 %neg859, -1
  %conv861 = zext i1 %cmp860 to i32
  %sub862 = sub nsw i32 0, %conv861
  %conv863 = sext i32 %sub862 to i64
  %130 = load i64, i64* %nargs, align 8
  %add864 = add nsw i64 0, %130
  %mul865 = mul nsw i64 0, %add864
  %add866 = add nsw i64 %mul865, 1
  %shl867 = shl i64 %add866, 62
  %sub868 = sub nsw i64 %shl867, 1
  %mul869 = mul nsw i64 %sub868, 2
  %add870 = add nsw i64 %mul869, 1
  %sub871 = sub nsw i64 %conv863, %add870
  br label %cond.end.876

cond.false.872:                                   ; preds = %cond.true.849
  %131 = load i64, i64* %nargs, align 8
  %add873 = add nsw i64 0, %131
  %mul874 = mul nsw i64 0, %add873
  %add875 = add nsw i64 %mul874, 0
  br label %cond.end.876

cond.end.876:                                     ; preds = %cond.false.872, %cond.true.855
  %cond877 = phi i64 [ %sub871, %cond.true.855 ], [ %add875, %cond.false.872 ]
  %div878 = sdiv i64 %cond877, 8
  %cmp879 = icmp slt i64 %127, %div878
  br i1 %cmp879, label %cond.true.918, label %lor.lhs.false.904

cond.false.881:                                   ; preds = %cond.false.846
  %132 = load i64, i64* %nargs, align 8
  %add882 = add nsw i64 0, %132
  %mul883 = mul nsw i64 0, %add882
  %sub884 = sub nsw i64 %mul883, 1
  %cmp885 = icmp slt i64 %sub884, 0
  br i1 %cmp885, label %cond.true.887, label %cond.false.895

cond.true.887:                                    ; preds = %cond.false.881
  %133 = load i64, i64* %nargs, align 8
  %add888 = add nsw i64 0, %133
  %mul889 = mul nsw i64 0, %add888
  %add890 = add nsw i64 %mul889, 1
  %shl891 = shl i64 %add890, 62
  %sub892 = sub nsw i64 %shl891, 1
  %mul893 = mul nsw i64 %sub892, 2
  %add894 = add nsw i64 %mul893, 1
  br label %cond.end.899

cond.false.895:                                   ; preds = %cond.false.881
  %134 = load i64, i64* %nargs, align 8
  %add896 = add nsw i64 0, %134
  %mul897 = mul nsw i64 0, %add896
  %sub898 = sub nsw i64 %mul897, 1
  br label %cond.end.899

cond.end.899:                                     ; preds = %cond.false.895, %cond.true.887
  %cond900 = phi i64 [ %add894, %cond.true.887 ], [ %sub898, %cond.false.895 ]
  %div901 = sdiv i64 %cond900, 8
  %135 = load i64, i64* %nargs, align 8
  %cmp902 = icmp slt i64 %div901, %135
  br i1 %cmp902, label %cond.true.918, label %lor.lhs.false.904

lor.lhs.false.904:                                ; preds = %cond.end.899, %cond.end.876, %cond.true.845, %cond.end.839, %cond.true.811, %cond.end.805
  %136 = load i64, i64* %nargs, align 8
  %mul905 = mul nsw i64 %136, 8
  %mul906 = mul nsw i64 0, %mul905
  %sub907 = sub nsw i64 %mul906, 1
  %cmp908 = icmp slt i64 %sub907, 0
  br i1 %cmp908, label %land.lhs.true.910, label %lor.lhs.false.914

land.lhs.true.910:                                ; preds = %lor.lhs.false.904
  %137 = load i64, i64* %nargs, align 8
  %mul911 = mul nsw i64 %137, 8
  %cmp912 = icmp slt i64 %mul911, -32768
  br i1 %cmp912, label %cond.true.918, label %lor.lhs.false.914

lor.lhs.false.914:                                ; preds = %land.lhs.true.910, %lor.lhs.false.904
  %138 = load i64, i64* %nargs, align 8
  %mul915 = mul nsw i64 %138, 8
  %cmp916 = icmp slt i64 32767, %mul915
  br i1 %cmp916, label %cond.true.918, label %cond.false.941

cond.true.918:                                    ; preds = %lor.lhs.false.914, %land.lhs.true.910, %cond.end.899, %cond.end.876, %cond.true.845, %cond.end.839, %cond.true.811, %cond.end.805, %land.lhs.true.780
  %139 = load i64, i64* %nargs, align 8
  %conv919 = trunc i64 %139 to i16
  %conv920 = zext i16 %conv919 to i32
  %mul921 = mul nsw i32 %conv920, 8
  %cmp922 = icmp sle i32 %mul921, 32767
  br i1 %cmp922, label %cond.true.924, label %cond.false.930

cond.true.924:                                    ; preds = %cond.true.918
  %140 = load i64, i64* %nargs, align 8
  %conv925 = trunc i64 %140 to i16
  %conv926 = zext i16 %conv925 to i32
  %mul927 = mul nsw i32 %conv926, 8
  %conv928 = trunc i32 %mul927 to i16
  %conv929 = sext i16 %conv928 to i32
  br label %cond.end.938

cond.false.930:                                   ; preds = %cond.true.918
  %141 = load i64, i64* %nargs, align 8
  %conv931 = trunc i64 %141 to i16
  %conv932 = zext i16 %conv931 to i32
  %mul933 = mul nsw i32 %conv932, 8
  %sub934 = sub nsw i32 %mul933, -32768
  %conv935 = trunc i32 %sub934 to i16
  %conv936 = sext i16 %conv935 to i32
  %add937 = add nsw i32 %conv936, -32768
  br label %cond.end.938

cond.end.938:                                     ; preds = %cond.false.930, %cond.true.924
  %cond939 = phi i32 [ %conv929, %cond.true.924 ], [ %add937, %cond.false.930 ]
  %conv940 = sext i32 %cond939 to i64
  store i64 %conv940, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2171, label %lor.lhs.false.2168

cond.false.941:                                   ; preds = %lor.lhs.false.914
  %142 = load i64, i64* %nargs, align 8
  %conv942 = trunc i64 %142 to i16
  %conv943 = zext i16 %conv942 to i32
  %mul944 = mul nsw i32 %conv943, 8
  %cmp945 = icmp sle i32 %mul944, 32767
  br i1 %cmp945, label %cond.true.947, label %cond.false.953

cond.true.947:                                    ; preds = %cond.false.941
  %143 = load i64, i64* %nargs, align 8
  %conv948 = trunc i64 %143 to i16
  %conv949 = zext i16 %conv948 to i32
  %mul950 = mul nsw i32 %conv949, 8
  %conv951 = trunc i32 %mul950 to i16
  %conv952 = sext i16 %conv951 to i32
  br label %cond.end.961

cond.false.953:                                   ; preds = %cond.false.941
  %144 = load i64, i64* %nargs, align 8
  %conv954 = trunc i64 %144 to i16
  %conv955 = zext i16 %conv954 to i32
  %mul956 = mul nsw i32 %conv955, 8
  %sub957 = sub nsw i32 %mul956, -32768
  %conv958 = trunc i32 %sub957 to i16
  %conv959 = sext i16 %conv958 to i32
  %add960 = add nsw i32 %conv959, -32768
  br label %cond.end.961

cond.end.961:                                     ; preds = %cond.false.953, %cond.true.947
  %cond962 = phi i32 [ %conv952, %cond.true.947 ], [ %add960, %cond.false.953 ]
  %conv963 = sext i32 %cond962 to i64
  store i64 %conv963, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2171, label %lor.lhs.false.2168

cond.false.964:                                   ; preds = %cond.false.479
  br i1 false, label %cond.true.965, label %cond.false.1393

cond.true.965:                                    ; preds = %cond.false.964
  br i1 false, label %cond.true.966, label %cond.false.1192

cond.true.966:                                    ; preds = %cond.true.965
  %145 = load i64, i64* %nargs, align 8
  %conv967 = trunc i64 %145 to i32
  %add968 = add nsw i32 0, %conv967
  %mul969 = mul nsw i32 0, %add968
  %sub970 = sub nsw i32 %mul969, 1
  %cmp971 = icmp slt i32 %sub970, 0
  br i1 %cmp971, label %cond.true.973, label %cond.false.991

cond.true.973:                                    ; preds = %cond.true.966
  %146 = load i64, i64* %nargs, align 8
  %conv974 = trunc i64 %146 to i32
  %add975 = add nsw i32 0, %conv974
  %mul976 = mul nsw i32 0, %add975
  %add977 = add nsw i32 %mul976, 0
  %neg978 = xor i32 %add977, -1
  %cmp979 = icmp eq i32 %neg978, -1
  %conv980 = zext i1 %cmp979 to i32
  %sub981 = sub nsw i32 0, %conv980
  %147 = load i64, i64* %nargs, align 8
  %conv982 = trunc i64 %147 to i32
  %add983 = add nsw i32 0, %conv982
  %mul984 = mul nsw i32 0, %add983
  %add985 = add nsw i32 %mul984, 1
  %shl986 = shl i32 %add985, 30
  %sub987 = sub nsw i32 %shl986, 1
  %mul988 = mul nsw i32 %sub987, 2
  %add989 = add nsw i32 %mul988, 1
  %sub990 = sub nsw i32 %sub981, %add989
  br label %cond.end.996

cond.false.991:                                   ; preds = %cond.true.966
  %148 = load i64, i64* %nargs, align 8
  %conv992 = trunc i64 %148 to i32
  %add993 = add nsw i32 0, %conv992
  %mul994 = mul nsw i32 0, %add993
  %add995 = add nsw i32 %mul994, 0
  br label %cond.end.996

cond.end.996:                                     ; preds = %cond.false.991, %cond.true.973
  %cond997 = phi i32 [ %sub990, %cond.true.973 ], [ %add995, %cond.false.991 ]
  %cmp998 = icmp eq i32 %cond997, 0
  br i1 %cmp998, label %land.lhs.true.1000, label %lor.lhs.false.1004

land.lhs.true.1000:                               ; preds = %cond.end.996
  %149 = load i64, i64* %nargs, align 8
  %conv1001 = trunc i64 %149 to i32
  %cmp1002 = icmp slt i32 %conv1001, 0
  br i1 %cmp1002, label %cond.true.1160, label %lor.lhs.false.1004

lor.lhs.false.1004:                               ; preds = %land.lhs.true.1000, %cond.end.996
  br i1 false, label %cond.true.1005, label %cond.false.1074

cond.true.1005:                                   ; preds = %lor.lhs.false.1004
  %150 = load i64, i64* %nargs, align 8
  %conv1006 = trunc i64 %150 to i32
  %cmp1007 = icmp slt i32 %conv1006, 0
  br i1 %cmp1007, label %cond.true.1009, label %cond.false.1036

cond.true.1009:                                   ; preds = %cond.true.1005
  %151 = load i64, i64* %nargs, align 8
  %conv1010 = trunc i64 %151 to i32
  %152 = load i64, i64* %nargs, align 8
  %conv1011 = trunc i64 %152 to i32
  %add1012 = add nsw i32 0, %conv1011
  %mul1013 = mul nsw i32 0, %add1012
  %sub1014 = sub nsw i32 %mul1013, 1
  %cmp1015 = icmp slt i32 %sub1014, 0
  br i1 %cmp1015, label %cond.true.1017, label %cond.false.1026

cond.true.1017:                                   ; preds = %cond.true.1009
  %153 = load i64, i64* %nargs, align 8
  %conv1018 = trunc i64 %153 to i32
  %add1019 = add nsw i32 0, %conv1018
  %mul1020 = mul nsw i32 0, %add1019
  %add1021 = add nsw i32 %mul1020, 1
  %shl1022 = shl i32 %add1021, 30
  %sub1023 = sub nsw i32 %shl1022, 1
  %mul1024 = mul nsw i32 %sub1023, 2
  %add1025 = add nsw i32 %mul1024, 1
  br label %cond.end.1031

cond.false.1026:                                  ; preds = %cond.true.1009
  %154 = load i64, i64* %nargs, align 8
  %conv1027 = trunc i64 %154 to i32
  %add1028 = add nsw i32 0, %conv1027
  %mul1029 = mul nsw i32 0, %add1028
  %sub1030 = sub nsw i32 %mul1029, 1
  br label %cond.end.1031

cond.end.1031:                                    ; preds = %cond.false.1026, %cond.true.1017
  %cond1032 = phi i32 [ %add1025, %cond.true.1017 ], [ %sub1030, %cond.false.1026 ]
  %div1033 = sdiv i32 %cond1032, 8
  %cmp1034 = icmp slt i32 %conv1010, %div1033
  br i1 %cmp1034, label %cond.true.1160, label %lor.lhs.false.1143

cond.false.1036:                                  ; preds = %cond.true.1005
  br i1 false, label %cond.true.1037, label %cond.false.1038

cond.true.1037:                                   ; preds = %cond.false.1036
  br i1 false, label %cond.true.1160, label %lor.lhs.false.1143

cond.false.1038:                                  ; preds = %cond.false.1036
  %155 = load i64, i64* %nargs, align 8
  %conv1039 = trunc i64 %155 to i32
  %add1040 = add nsw i32 0, %conv1039
  %mul1041 = mul nsw i32 0, %add1040
  %sub1042 = sub nsw i32 %mul1041, 1
  %cmp1043 = icmp slt i32 %sub1042, 0
  br i1 %cmp1043, label %cond.true.1045, label %cond.false.1063

cond.true.1045:                                   ; preds = %cond.false.1038
  %156 = load i64, i64* %nargs, align 8
  %conv1046 = trunc i64 %156 to i32
  %add1047 = add nsw i32 0, %conv1046
  %mul1048 = mul nsw i32 0, %add1047
  %add1049 = add nsw i32 %mul1048, 0
  %neg1050 = xor i32 %add1049, -1
  %cmp1051 = icmp eq i32 %neg1050, -1
  %conv1052 = zext i1 %cmp1051 to i32
  %sub1053 = sub nsw i32 0, %conv1052
  %157 = load i64, i64* %nargs, align 8
  %conv1054 = trunc i64 %157 to i32
  %add1055 = add nsw i32 0, %conv1054
  %mul1056 = mul nsw i32 0, %add1055
  %add1057 = add nsw i32 %mul1056, 1
  %shl1058 = shl i32 %add1057, 30
  %sub1059 = sub nsw i32 %shl1058, 1
  %mul1060 = mul nsw i32 %sub1059, 2
  %add1061 = add nsw i32 %mul1060, 1
  %sub1062 = sub nsw i32 %sub1053, %add1061
  br label %cond.end.1068

cond.false.1063:                                  ; preds = %cond.false.1038
  %158 = load i64, i64* %nargs, align 8
  %conv1064 = trunc i64 %158 to i32
  %add1065 = add nsw i32 0, %conv1064
  %mul1066 = mul nsw i32 0, %add1065
  %add1067 = add nsw i32 %mul1066, 0
  br label %cond.end.1068

cond.end.1068:                                    ; preds = %cond.false.1063, %cond.true.1045
  %cond1069 = phi i32 [ %sub1062, %cond.true.1045 ], [ %add1067, %cond.false.1063 ]
  %div1070 = sdiv i32 %cond1069, 8
  %159 = load i64, i64* %nargs, align 8
  %conv1071 = trunc i64 %159 to i32
  %cmp1072 = icmp slt i32 %div1070, %conv1071
  br i1 %cmp1072, label %cond.true.1160, label %lor.lhs.false.1143

cond.false.1074:                                  ; preds = %lor.lhs.false.1004
  br i1 false, label %cond.true.1075, label %cond.false.1076

cond.true.1075:                                   ; preds = %cond.false.1074
  br i1 false, label %cond.true.1160, label %lor.lhs.false.1143

cond.false.1076:                                  ; preds = %cond.false.1074
  %160 = load i64, i64* %nargs, align 8
  %conv1077 = trunc i64 %160 to i32
  %cmp1078 = icmp slt i32 %conv1077, 0
  br i1 %cmp1078, label %cond.true.1080, label %cond.false.1116

cond.true.1080:                                   ; preds = %cond.false.1076
  %161 = load i64, i64* %nargs, align 8
  %conv1081 = trunc i64 %161 to i32
  %162 = load i64, i64* %nargs, align 8
  %conv1082 = trunc i64 %162 to i32
  %add1083 = add nsw i32 0, %conv1082
  %mul1084 = mul nsw i32 0, %add1083
  %sub1085 = sub nsw i32 %mul1084, 1
  %cmp1086 = icmp slt i32 %sub1085, 0
  br i1 %cmp1086, label %cond.true.1088, label %cond.false.1106

cond.true.1088:                                   ; preds = %cond.true.1080
  %163 = load i64, i64* %nargs, align 8
  %conv1089 = trunc i64 %163 to i32
  %add1090 = add nsw i32 0, %conv1089
  %mul1091 = mul nsw i32 0, %add1090
  %add1092 = add nsw i32 %mul1091, 0
  %neg1093 = xor i32 %add1092, -1
  %cmp1094 = icmp eq i32 %neg1093, -1
  %conv1095 = zext i1 %cmp1094 to i32
  %sub1096 = sub nsw i32 0, %conv1095
  %164 = load i64, i64* %nargs, align 8
  %conv1097 = trunc i64 %164 to i32
  %add1098 = add nsw i32 0, %conv1097
  %mul1099 = mul nsw i32 0, %add1098
  %add1100 = add nsw i32 %mul1099, 1
  %shl1101 = shl i32 %add1100, 30
  %sub1102 = sub nsw i32 %shl1101, 1
  %mul1103 = mul nsw i32 %sub1102, 2
  %add1104 = add nsw i32 %mul1103, 1
  %sub1105 = sub nsw i32 %sub1096, %add1104
  br label %cond.end.1111

cond.false.1106:                                  ; preds = %cond.true.1080
  %165 = load i64, i64* %nargs, align 8
  %conv1107 = trunc i64 %165 to i32
  %add1108 = add nsw i32 0, %conv1107
  %mul1109 = mul nsw i32 0, %add1108
  %add1110 = add nsw i32 %mul1109, 0
  br label %cond.end.1111

cond.end.1111:                                    ; preds = %cond.false.1106, %cond.true.1088
  %cond1112 = phi i32 [ %sub1105, %cond.true.1088 ], [ %add1110, %cond.false.1106 ]
  %div1113 = sdiv i32 %cond1112, 8
  %cmp1114 = icmp slt i32 %conv1081, %div1113
  br i1 %cmp1114, label %cond.true.1160, label %lor.lhs.false.1143

cond.false.1116:                                  ; preds = %cond.false.1076
  %166 = load i64, i64* %nargs, align 8
  %conv1117 = trunc i64 %166 to i32
  %add1118 = add nsw i32 0, %conv1117
  %mul1119 = mul nsw i32 0, %add1118
  %sub1120 = sub nsw i32 %mul1119, 1
  %cmp1121 = icmp slt i32 %sub1120, 0
  br i1 %cmp1121, label %cond.true.1123, label %cond.false.1132

cond.true.1123:                                   ; preds = %cond.false.1116
  %167 = load i64, i64* %nargs, align 8
  %conv1124 = trunc i64 %167 to i32
  %add1125 = add nsw i32 0, %conv1124
  %mul1126 = mul nsw i32 0, %add1125
  %add1127 = add nsw i32 %mul1126, 1
  %shl1128 = shl i32 %add1127, 30
  %sub1129 = sub nsw i32 %shl1128, 1
  %mul1130 = mul nsw i32 %sub1129, 2
  %add1131 = add nsw i32 %mul1130, 1
  br label %cond.end.1137

cond.false.1132:                                  ; preds = %cond.false.1116
  %168 = load i64, i64* %nargs, align 8
  %conv1133 = trunc i64 %168 to i32
  %add1134 = add nsw i32 0, %conv1133
  %mul1135 = mul nsw i32 0, %add1134
  %sub1136 = sub nsw i32 %mul1135, 1
  br label %cond.end.1137

cond.end.1137:                                    ; preds = %cond.false.1132, %cond.true.1123
  %cond1138 = phi i32 [ %add1131, %cond.true.1123 ], [ %sub1136, %cond.false.1132 ]
  %div1139 = sdiv i32 %cond1138, 8
  %169 = load i64, i64* %nargs, align 8
  %conv1140 = trunc i64 %169 to i32
  %cmp1141 = icmp slt i32 %div1139, %conv1140
  br i1 %cmp1141, label %cond.true.1160, label %lor.lhs.false.1143

lor.lhs.false.1143:                               ; preds = %cond.end.1137, %cond.end.1111, %cond.true.1075, %cond.end.1068, %cond.true.1037, %cond.end.1031
  %170 = load i64, i64* %nargs, align 8
  %conv1144 = trunc i64 %170 to i32
  %mul1145 = mul nsw i32 %conv1144, 8
  %mul1146 = mul nsw i32 0, %mul1145
  %sub1147 = sub nsw i32 %mul1146, 1
  %cmp1148 = icmp slt i32 %sub1147, 0
  br i1 %cmp1148, label %land.lhs.true.1150, label %lor.lhs.false.1155

land.lhs.true.1150:                               ; preds = %lor.lhs.false.1143
  %171 = load i64, i64* %nargs, align 8
  %conv1151 = trunc i64 %171 to i32
  %mul1152 = mul nsw i32 %conv1151, 8
  %cmp1153 = icmp slt i32 %mul1152, -2147483648
  br i1 %cmp1153, label %cond.true.1160, label %lor.lhs.false.1155

lor.lhs.false.1155:                               ; preds = %land.lhs.true.1150, %lor.lhs.false.1143
  %172 = load i64, i64* %nargs, align 8
  %conv1156 = trunc i64 %172 to i32
  %mul1157 = mul nsw i32 %conv1156, 8
  %cmp1158 = icmp slt i32 2147483647, %mul1157
  br i1 %cmp1158, label %cond.true.1160, label %cond.false.1176

cond.true.1160:                                   ; preds = %lor.lhs.false.1155, %land.lhs.true.1150, %cond.end.1137, %cond.end.1111, %cond.true.1075, %cond.end.1068, %cond.true.1037, %cond.end.1031, %land.lhs.true.1000
  %173 = load i64, i64* %nargs, align 8
  %conv1161 = trunc i64 %173 to i32
  %mul1162 = mul i32 %conv1161, 8
  %cmp1163 = icmp ule i32 %mul1162, 2147483647
  br i1 %cmp1163, label %cond.true.1165, label %cond.false.1168

cond.true.1165:                                   ; preds = %cond.true.1160
  %174 = load i64, i64* %nargs, align 8
  %conv1166 = trunc i64 %174 to i32
  %mul1167 = mul i32 %conv1166, 8
  br label %cond.end.1173

cond.false.1168:                                  ; preds = %cond.true.1160
  %175 = load i64, i64* %nargs, align 8
  %conv1169 = trunc i64 %175 to i32
  %mul1170 = mul i32 %conv1169, 8
  %sub1171 = sub i32 %mul1170, -2147483648
  %add1172 = add nsw i32 %sub1171, -2147483648
  br label %cond.end.1173

cond.end.1173:                                    ; preds = %cond.false.1168, %cond.true.1165
  %cond1174 = phi i32 [ %mul1167, %cond.true.1165 ], [ %add1172, %cond.false.1168 ]
  %conv1175 = sext i32 %cond1174 to i64
  store i64 %conv1175, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2171, label %lor.lhs.false.2168

cond.false.1176:                                  ; preds = %lor.lhs.false.1155
  %176 = load i64, i64* %nargs, align 8
  %conv1177 = trunc i64 %176 to i32
  %mul1178 = mul i32 %conv1177, 8
  %cmp1179 = icmp ule i32 %mul1178, 2147483647
  br i1 %cmp1179, label %cond.true.1181, label %cond.false.1184

cond.true.1181:                                   ; preds = %cond.false.1176
  %177 = load i64, i64* %nargs, align 8
  %conv1182 = trunc i64 %177 to i32
  %mul1183 = mul i32 %conv1182, 8
  br label %cond.end.1189

cond.false.1184:                                  ; preds = %cond.false.1176
  %178 = load i64, i64* %nargs, align 8
  %conv1185 = trunc i64 %178 to i32
  %mul1186 = mul i32 %conv1185, 8
  %sub1187 = sub i32 %mul1186, -2147483648
  %add1188 = add nsw i32 %sub1187, -2147483648
  br label %cond.end.1189

cond.end.1189:                                    ; preds = %cond.false.1184, %cond.true.1181
  %cond1190 = phi i32 [ %mul1183, %cond.true.1181 ], [ %add1188, %cond.false.1184 ]
  %conv1191 = sext i32 %cond1190 to i64
  store i64 %conv1191, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2171, label %lor.lhs.false.2168

cond.false.1192:                                  ; preds = %cond.true.965
  %179 = load i64, i64* %nargs, align 8
  %add1193 = add nsw i64 0, %179
  %mul1194 = mul nsw i64 0, %add1193
  %sub1195 = sub nsw i64 %mul1194, 1
  %cmp1196 = icmp slt i64 %sub1195, 0
  br i1 %cmp1196, label %cond.true.1198, label %cond.false.1215

cond.true.1198:                                   ; preds = %cond.false.1192
  %180 = load i64, i64* %nargs, align 8
  %add1199 = add nsw i64 0, %180
  %mul1200 = mul nsw i64 0, %add1199
  %add1201 = add nsw i64 %mul1200, 0
  %neg1202 = xor i64 %add1201, -1
  %cmp1203 = icmp eq i64 %neg1202, -1
  %conv1204 = zext i1 %cmp1203 to i32
  %sub1205 = sub nsw i32 0, %conv1204
  %conv1206 = sext i32 %sub1205 to i64
  %181 = load i64, i64* %nargs, align 8
  %add1207 = add nsw i64 0, %181
  %mul1208 = mul nsw i64 0, %add1207
  %add1209 = add nsw i64 %mul1208, 1
  %shl1210 = shl i64 %add1209, 62
  %sub1211 = sub nsw i64 %shl1210, 1
  %mul1212 = mul nsw i64 %sub1211, 2
  %add1213 = add nsw i64 %mul1212, 1
  %sub1214 = sub nsw i64 %conv1206, %add1213
  br label %cond.end.1219

cond.false.1215:                                  ; preds = %cond.false.1192
  %182 = load i64, i64* %nargs, align 8
  %add1216 = add nsw i64 0, %182
  %mul1217 = mul nsw i64 0, %add1216
  %add1218 = add nsw i64 %mul1217, 0
  br label %cond.end.1219

cond.end.1219:                                    ; preds = %cond.false.1215, %cond.true.1198
  %cond1220 = phi i64 [ %sub1214, %cond.true.1198 ], [ %add1218, %cond.false.1215 ]
  %cmp1221 = icmp eq i64 %cond1220, 0
  br i1 %cmp1221, label %land.lhs.true.1223, label %lor.lhs.false.1226

land.lhs.true.1223:                               ; preds = %cond.end.1219
  %183 = load i64, i64* %nargs, align 8
  %cmp1224 = icmp slt i64 %183, 0
  br i1 %cmp1224, label %cond.true.1361, label %lor.lhs.false.1226

lor.lhs.false.1226:                               ; preds = %land.lhs.true.1223, %cond.end.1219
  br i1 false, label %cond.true.1227, label %cond.false.1287

cond.true.1227:                                   ; preds = %lor.lhs.false.1226
  %184 = load i64, i64* %nargs, align 8
  %cmp1228 = icmp slt i64 %184, 0
  br i1 %cmp1228, label %cond.true.1230, label %cond.false.1253

cond.true.1230:                                   ; preds = %cond.true.1227
  %185 = load i64, i64* %nargs, align 8
  %186 = load i64, i64* %nargs, align 8
  %add1231 = add nsw i64 0, %186
  %mul1232 = mul nsw i64 0, %add1231
  %sub1233 = sub nsw i64 %mul1232, 1
  %cmp1234 = icmp slt i64 %sub1233, 0
  br i1 %cmp1234, label %cond.true.1236, label %cond.false.1244

cond.true.1236:                                   ; preds = %cond.true.1230
  %187 = load i64, i64* %nargs, align 8
  %add1237 = add nsw i64 0, %187
  %mul1238 = mul nsw i64 0, %add1237
  %add1239 = add nsw i64 %mul1238, 1
  %shl1240 = shl i64 %add1239, 62
  %sub1241 = sub nsw i64 %shl1240, 1
  %mul1242 = mul nsw i64 %sub1241, 2
  %add1243 = add nsw i64 %mul1242, 1
  br label %cond.end.1248

cond.false.1244:                                  ; preds = %cond.true.1230
  %188 = load i64, i64* %nargs, align 8
  %add1245 = add nsw i64 0, %188
  %mul1246 = mul nsw i64 0, %add1245
  %sub1247 = sub nsw i64 %mul1246, 1
  br label %cond.end.1248

cond.end.1248:                                    ; preds = %cond.false.1244, %cond.true.1236
  %cond1249 = phi i64 [ %add1243, %cond.true.1236 ], [ %sub1247, %cond.false.1244 ]
  %div1250 = sdiv i64 %cond1249, 8
  %cmp1251 = icmp slt i64 %185, %div1250
  br i1 %cmp1251, label %cond.true.1361, label %lor.lhs.false.1347

cond.false.1253:                                  ; preds = %cond.true.1227
  br i1 false, label %cond.true.1254, label %cond.false.1255

cond.true.1254:                                   ; preds = %cond.false.1253
  br i1 false, label %cond.true.1361, label %lor.lhs.false.1347

cond.false.1255:                                  ; preds = %cond.false.1253
  %189 = load i64, i64* %nargs, align 8
  %add1256 = add nsw i64 0, %189
  %mul1257 = mul nsw i64 0, %add1256
  %sub1258 = sub nsw i64 %mul1257, 1
  %cmp1259 = icmp slt i64 %sub1258, 0
  br i1 %cmp1259, label %cond.true.1261, label %cond.false.1278

cond.true.1261:                                   ; preds = %cond.false.1255
  %190 = load i64, i64* %nargs, align 8
  %add1262 = add nsw i64 0, %190
  %mul1263 = mul nsw i64 0, %add1262
  %add1264 = add nsw i64 %mul1263, 0
  %neg1265 = xor i64 %add1264, -1
  %cmp1266 = icmp eq i64 %neg1265, -1
  %conv1267 = zext i1 %cmp1266 to i32
  %sub1268 = sub nsw i32 0, %conv1267
  %conv1269 = sext i32 %sub1268 to i64
  %191 = load i64, i64* %nargs, align 8
  %add1270 = add nsw i64 0, %191
  %mul1271 = mul nsw i64 0, %add1270
  %add1272 = add nsw i64 %mul1271, 1
  %shl1273 = shl i64 %add1272, 62
  %sub1274 = sub nsw i64 %shl1273, 1
  %mul1275 = mul nsw i64 %sub1274, 2
  %add1276 = add nsw i64 %mul1275, 1
  %sub1277 = sub nsw i64 %conv1269, %add1276
  br label %cond.end.1282

cond.false.1278:                                  ; preds = %cond.false.1255
  %192 = load i64, i64* %nargs, align 8
  %add1279 = add nsw i64 0, %192
  %mul1280 = mul nsw i64 0, %add1279
  %add1281 = add nsw i64 %mul1280, 0
  br label %cond.end.1282

cond.end.1282:                                    ; preds = %cond.false.1278, %cond.true.1261
  %cond1283 = phi i64 [ %sub1277, %cond.true.1261 ], [ %add1281, %cond.false.1278 ]
  %div1284 = sdiv i64 %cond1283, 8
  %193 = load i64, i64* %nargs, align 8
  %cmp1285 = icmp slt i64 %div1284, %193
  br i1 %cmp1285, label %cond.true.1361, label %lor.lhs.false.1347

cond.false.1287:                                  ; preds = %lor.lhs.false.1226
  br i1 false, label %cond.true.1288, label %cond.false.1289

cond.true.1288:                                   ; preds = %cond.false.1287
  br i1 false, label %cond.true.1361, label %lor.lhs.false.1347

cond.false.1289:                                  ; preds = %cond.false.1287
  %194 = load i64, i64* %nargs, align 8
  %cmp1290 = icmp slt i64 %194, 0
  br i1 %cmp1290, label %cond.true.1292, label %cond.false.1324

cond.true.1292:                                   ; preds = %cond.false.1289
  %195 = load i64, i64* %nargs, align 8
  %196 = load i64, i64* %nargs, align 8
  %add1293 = add nsw i64 0, %196
  %mul1294 = mul nsw i64 0, %add1293
  %sub1295 = sub nsw i64 %mul1294, 1
  %cmp1296 = icmp slt i64 %sub1295, 0
  br i1 %cmp1296, label %cond.true.1298, label %cond.false.1315

cond.true.1298:                                   ; preds = %cond.true.1292
  %197 = load i64, i64* %nargs, align 8
  %add1299 = add nsw i64 0, %197
  %mul1300 = mul nsw i64 0, %add1299
  %add1301 = add nsw i64 %mul1300, 0
  %neg1302 = xor i64 %add1301, -1
  %cmp1303 = icmp eq i64 %neg1302, -1
  %conv1304 = zext i1 %cmp1303 to i32
  %sub1305 = sub nsw i32 0, %conv1304
  %conv1306 = sext i32 %sub1305 to i64
  %198 = load i64, i64* %nargs, align 8
  %add1307 = add nsw i64 0, %198
  %mul1308 = mul nsw i64 0, %add1307
  %add1309 = add nsw i64 %mul1308, 1
  %shl1310 = shl i64 %add1309, 62
  %sub1311 = sub nsw i64 %shl1310, 1
  %mul1312 = mul nsw i64 %sub1311, 2
  %add1313 = add nsw i64 %mul1312, 1
  %sub1314 = sub nsw i64 %conv1306, %add1313
  br label %cond.end.1319

cond.false.1315:                                  ; preds = %cond.true.1292
  %199 = load i64, i64* %nargs, align 8
  %add1316 = add nsw i64 0, %199
  %mul1317 = mul nsw i64 0, %add1316
  %add1318 = add nsw i64 %mul1317, 0
  br label %cond.end.1319

cond.end.1319:                                    ; preds = %cond.false.1315, %cond.true.1298
  %cond1320 = phi i64 [ %sub1314, %cond.true.1298 ], [ %add1318, %cond.false.1315 ]
  %div1321 = sdiv i64 %cond1320, 8
  %cmp1322 = icmp slt i64 %195, %div1321
  br i1 %cmp1322, label %cond.true.1361, label %lor.lhs.false.1347

cond.false.1324:                                  ; preds = %cond.false.1289
  %200 = load i64, i64* %nargs, align 8
  %add1325 = add nsw i64 0, %200
  %mul1326 = mul nsw i64 0, %add1325
  %sub1327 = sub nsw i64 %mul1326, 1
  %cmp1328 = icmp slt i64 %sub1327, 0
  br i1 %cmp1328, label %cond.true.1330, label %cond.false.1338

cond.true.1330:                                   ; preds = %cond.false.1324
  %201 = load i64, i64* %nargs, align 8
  %add1331 = add nsw i64 0, %201
  %mul1332 = mul nsw i64 0, %add1331
  %add1333 = add nsw i64 %mul1332, 1
  %shl1334 = shl i64 %add1333, 62
  %sub1335 = sub nsw i64 %shl1334, 1
  %mul1336 = mul nsw i64 %sub1335, 2
  %add1337 = add nsw i64 %mul1336, 1
  br label %cond.end.1342

cond.false.1338:                                  ; preds = %cond.false.1324
  %202 = load i64, i64* %nargs, align 8
  %add1339 = add nsw i64 0, %202
  %mul1340 = mul nsw i64 0, %add1339
  %sub1341 = sub nsw i64 %mul1340, 1
  br label %cond.end.1342

cond.end.1342:                                    ; preds = %cond.false.1338, %cond.true.1330
  %cond1343 = phi i64 [ %add1337, %cond.true.1330 ], [ %sub1341, %cond.false.1338 ]
  %div1344 = sdiv i64 %cond1343, 8
  %203 = load i64, i64* %nargs, align 8
  %cmp1345 = icmp slt i64 %div1344, %203
  br i1 %cmp1345, label %cond.true.1361, label %lor.lhs.false.1347

lor.lhs.false.1347:                               ; preds = %cond.end.1342, %cond.end.1319, %cond.true.1288, %cond.end.1282, %cond.true.1254, %cond.end.1248
  %204 = load i64, i64* %nargs, align 8
  %mul1348 = mul nsw i64 %204, 8
  %mul1349 = mul nsw i64 0, %mul1348
  %sub1350 = sub nsw i64 %mul1349, 1
  %cmp1351 = icmp slt i64 %sub1350, 0
  br i1 %cmp1351, label %land.lhs.true.1353, label %lor.lhs.false.1357

land.lhs.true.1353:                               ; preds = %lor.lhs.false.1347
  %205 = load i64, i64* %nargs, align 8
  %mul1354 = mul nsw i64 %205, 8
  %cmp1355 = icmp slt i64 %mul1354, -2147483648
  br i1 %cmp1355, label %cond.true.1361, label %lor.lhs.false.1357

lor.lhs.false.1357:                               ; preds = %land.lhs.true.1353, %lor.lhs.false.1347
  %206 = load i64, i64* %nargs, align 8
  %mul1358 = mul nsw i64 %206, 8
  %cmp1359 = icmp slt i64 2147483647, %mul1358
  br i1 %cmp1359, label %cond.true.1361, label %cond.false.1377

cond.true.1361:                                   ; preds = %lor.lhs.false.1357, %land.lhs.true.1353, %cond.end.1342, %cond.end.1319, %cond.true.1288, %cond.end.1282, %cond.true.1254, %cond.end.1248, %land.lhs.true.1223
  %207 = load i64, i64* %nargs, align 8
  %conv1362 = trunc i64 %207 to i32
  %mul1363 = mul i32 %conv1362, 8
  %cmp1364 = icmp ule i32 %mul1363, 2147483647
  br i1 %cmp1364, label %cond.true.1366, label %cond.false.1369

cond.true.1366:                                   ; preds = %cond.true.1361
  %208 = load i64, i64* %nargs, align 8
  %conv1367 = trunc i64 %208 to i32
  %mul1368 = mul i32 %conv1367, 8
  br label %cond.end.1374

cond.false.1369:                                  ; preds = %cond.true.1361
  %209 = load i64, i64* %nargs, align 8
  %conv1370 = trunc i64 %209 to i32
  %mul1371 = mul i32 %conv1370, 8
  %sub1372 = sub i32 %mul1371, -2147483648
  %add1373 = add nsw i32 %sub1372, -2147483648
  br label %cond.end.1374

cond.end.1374:                                    ; preds = %cond.false.1369, %cond.true.1366
  %cond1375 = phi i32 [ %mul1368, %cond.true.1366 ], [ %add1373, %cond.false.1369 ]
  %conv1376 = sext i32 %cond1375 to i64
  store i64 %conv1376, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2171, label %lor.lhs.false.2168

cond.false.1377:                                  ; preds = %lor.lhs.false.1357
  %210 = load i64, i64* %nargs, align 8
  %conv1378 = trunc i64 %210 to i32
  %mul1379 = mul i32 %conv1378, 8
  %cmp1380 = icmp ule i32 %mul1379, 2147483647
  br i1 %cmp1380, label %cond.true.1382, label %cond.false.1385

cond.true.1382:                                   ; preds = %cond.false.1377
  %211 = load i64, i64* %nargs, align 8
  %conv1383 = trunc i64 %211 to i32
  %mul1384 = mul i32 %conv1383, 8
  br label %cond.end.1390

cond.false.1385:                                  ; preds = %cond.false.1377
  %212 = load i64, i64* %nargs, align 8
  %conv1386 = trunc i64 %212 to i32
  %mul1387 = mul i32 %conv1386, 8
  %sub1388 = sub i32 %mul1387, -2147483648
  %add1389 = add nsw i32 %sub1388, -2147483648
  br label %cond.end.1390

cond.end.1390:                                    ; preds = %cond.false.1385, %cond.true.1382
  %cond1391 = phi i32 [ %mul1384, %cond.true.1382 ], [ %add1389, %cond.false.1385 ]
  %conv1392 = sext i32 %cond1391 to i64
  store i64 %conv1392, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2171, label %lor.lhs.false.2168

cond.false.1393:                                  ; preds = %cond.false.964
  br i1 true, label %cond.true.1394, label %cond.false.1781

cond.true.1394:                                   ; preds = %cond.false.1393
  br i1 false, label %cond.true.1395, label %cond.false.1588

cond.true.1395:                                   ; preds = %cond.true.1394
  %213 = load i64, i64* %nargs, align 8
  %add1396 = add nsw i64 0, %213
  %mul1397 = mul nsw i64 0, %add1396
  %sub1398 = sub nsw i64 %mul1397, 1
  %cmp1399 = icmp slt i64 %sub1398, 0
  br i1 %cmp1399, label %cond.true.1401, label %cond.false.1418

cond.true.1401:                                   ; preds = %cond.true.1395
  %214 = load i64, i64* %nargs, align 8
  %add1402 = add nsw i64 0, %214
  %mul1403 = mul nsw i64 0, %add1402
  %add1404 = add nsw i64 %mul1403, 0
  %neg1405 = xor i64 %add1404, -1
  %cmp1406 = icmp eq i64 %neg1405, -1
  %conv1407 = zext i1 %cmp1406 to i32
  %sub1408 = sub nsw i32 0, %conv1407
  %conv1409 = sext i32 %sub1408 to i64
  %215 = load i64, i64* %nargs, align 8
  %add1410 = add nsw i64 0, %215
  %mul1411 = mul nsw i64 0, %add1410
  %add1412 = add nsw i64 %mul1411, 1
  %shl1413 = shl i64 %add1412, 62
  %sub1414 = sub nsw i64 %shl1413, 1
  %mul1415 = mul nsw i64 %sub1414, 2
  %add1416 = add nsw i64 %mul1415, 1
  %sub1417 = sub nsw i64 %conv1409, %add1416
  br label %cond.end.1422

cond.false.1418:                                  ; preds = %cond.true.1395
  %216 = load i64, i64* %nargs, align 8
  %add1419 = add nsw i64 0, %216
  %mul1420 = mul nsw i64 0, %add1419
  %add1421 = add nsw i64 %mul1420, 0
  br label %cond.end.1422

cond.end.1422:                                    ; preds = %cond.false.1418, %cond.true.1401
  %cond1423 = phi i64 [ %sub1417, %cond.true.1401 ], [ %add1421, %cond.false.1418 ]
  %cmp1424 = icmp eq i64 %cond1423, 0
  br i1 %cmp1424, label %land.lhs.true.1426, label %lor.lhs.false.1429

land.lhs.true.1426:                               ; preds = %cond.end.1422
  %217 = load i64, i64* %nargs, align 8
  %cmp1427 = icmp slt i64 %217, 0
  br i1 %cmp1427, label %cond.true.1564, label %lor.lhs.false.1429

lor.lhs.false.1429:                               ; preds = %land.lhs.true.1426, %cond.end.1422
  br i1 false, label %cond.true.1430, label %cond.false.1490

cond.true.1430:                                   ; preds = %lor.lhs.false.1429
  %218 = load i64, i64* %nargs, align 8
  %cmp1431 = icmp slt i64 %218, 0
  br i1 %cmp1431, label %cond.true.1433, label %cond.false.1456

cond.true.1433:                                   ; preds = %cond.true.1430
  %219 = load i64, i64* %nargs, align 8
  %220 = load i64, i64* %nargs, align 8
  %add1434 = add nsw i64 0, %220
  %mul1435 = mul nsw i64 0, %add1434
  %sub1436 = sub nsw i64 %mul1435, 1
  %cmp1437 = icmp slt i64 %sub1436, 0
  br i1 %cmp1437, label %cond.true.1439, label %cond.false.1447

cond.true.1439:                                   ; preds = %cond.true.1433
  %221 = load i64, i64* %nargs, align 8
  %add1440 = add nsw i64 0, %221
  %mul1441 = mul nsw i64 0, %add1440
  %add1442 = add nsw i64 %mul1441, 1
  %shl1443 = shl i64 %add1442, 62
  %sub1444 = sub nsw i64 %shl1443, 1
  %mul1445 = mul nsw i64 %sub1444, 2
  %add1446 = add nsw i64 %mul1445, 1
  br label %cond.end.1451

cond.false.1447:                                  ; preds = %cond.true.1433
  %222 = load i64, i64* %nargs, align 8
  %add1448 = add nsw i64 0, %222
  %mul1449 = mul nsw i64 0, %add1448
  %sub1450 = sub nsw i64 %mul1449, 1
  br label %cond.end.1451

cond.end.1451:                                    ; preds = %cond.false.1447, %cond.true.1439
  %cond1452 = phi i64 [ %add1446, %cond.true.1439 ], [ %sub1450, %cond.false.1447 ]
  %div1453 = sdiv i64 %cond1452, 8
  %cmp1454 = icmp slt i64 %219, %div1453
  br i1 %cmp1454, label %cond.true.1564, label %lor.lhs.false.1550

cond.false.1456:                                  ; preds = %cond.true.1430
  br i1 false, label %cond.true.1457, label %cond.false.1458

cond.true.1457:                                   ; preds = %cond.false.1456
  br i1 false, label %cond.true.1564, label %lor.lhs.false.1550

cond.false.1458:                                  ; preds = %cond.false.1456
  %223 = load i64, i64* %nargs, align 8
  %add1459 = add nsw i64 0, %223
  %mul1460 = mul nsw i64 0, %add1459
  %sub1461 = sub nsw i64 %mul1460, 1
  %cmp1462 = icmp slt i64 %sub1461, 0
  br i1 %cmp1462, label %cond.true.1464, label %cond.false.1481

cond.true.1464:                                   ; preds = %cond.false.1458
  %224 = load i64, i64* %nargs, align 8
  %add1465 = add nsw i64 0, %224
  %mul1466 = mul nsw i64 0, %add1465
  %add1467 = add nsw i64 %mul1466, 0
  %neg1468 = xor i64 %add1467, -1
  %cmp1469 = icmp eq i64 %neg1468, -1
  %conv1470 = zext i1 %cmp1469 to i32
  %sub1471 = sub nsw i32 0, %conv1470
  %conv1472 = sext i32 %sub1471 to i64
  %225 = load i64, i64* %nargs, align 8
  %add1473 = add nsw i64 0, %225
  %mul1474 = mul nsw i64 0, %add1473
  %add1475 = add nsw i64 %mul1474, 1
  %shl1476 = shl i64 %add1475, 62
  %sub1477 = sub nsw i64 %shl1476, 1
  %mul1478 = mul nsw i64 %sub1477, 2
  %add1479 = add nsw i64 %mul1478, 1
  %sub1480 = sub nsw i64 %conv1472, %add1479
  br label %cond.end.1485

cond.false.1481:                                  ; preds = %cond.false.1458
  %226 = load i64, i64* %nargs, align 8
  %add1482 = add nsw i64 0, %226
  %mul1483 = mul nsw i64 0, %add1482
  %add1484 = add nsw i64 %mul1483, 0
  br label %cond.end.1485

cond.end.1485:                                    ; preds = %cond.false.1481, %cond.true.1464
  %cond1486 = phi i64 [ %sub1480, %cond.true.1464 ], [ %add1484, %cond.false.1481 ]
  %div1487 = sdiv i64 %cond1486, 8
  %227 = load i64, i64* %nargs, align 8
  %cmp1488 = icmp slt i64 %div1487, %227
  br i1 %cmp1488, label %cond.true.1564, label %lor.lhs.false.1550

cond.false.1490:                                  ; preds = %lor.lhs.false.1429
  br i1 false, label %cond.true.1491, label %cond.false.1492

cond.true.1491:                                   ; preds = %cond.false.1490
  br i1 false, label %cond.true.1564, label %lor.lhs.false.1550

cond.false.1492:                                  ; preds = %cond.false.1490
  %228 = load i64, i64* %nargs, align 8
  %cmp1493 = icmp slt i64 %228, 0
  br i1 %cmp1493, label %cond.true.1495, label %cond.false.1527

cond.true.1495:                                   ; preds = %cond.false.1492
  %229 = load i64, i64* %nargs, align 8
  %230 = load i64, i64* %nargs, align 8
  %add1496 = add nsw i64 0, %230
  %mul1497 = mul nsw i64 0, %add1496
  %sub1498 = sub nsw i64 %mul1497, 1
  %cmp1499 = icmp slt i64 %sub1498, 0
  br i1 %cmp1499, label %cond.true.1501, label %cond.false.1518

cond.true.1501:                                   ; preds = %cond.true.1495
  %231 = load i64, i64* %nargs, align 8
  %add1502 = add nsw i64 0, %231
  %mul1503 = mul nsw i64 0, %add1502
  %add1504 = add nsw i64 %mul1503, 0
  %neg1505 = xor i64 %add1504, -1
  %cmp1506 = icmp eq i64 %neg1505, -1
  %conv1507 = zext i1 %cmp1506 to i32
  %sub1508 = sub nsw i32 0, %conv1507
  %conv1509 = sext i32 %sub1508 to i64
  %232 = load i64, i64* %nargs, align 8
  %add1510 = add nsw i64 0, %232
  %mul1511 = mul nsw i64 0, %add1510
  %add1512 = add nsw i64 %mul1511, 1
  %shl1513 = shl i64 %add1512, 62
  %sub1514 = sub nsw i64 %shl1513, 1
  %mul1515 = mul nsw i64 %sub1514, 2
  %add1516 = add nsw i64 %mul1515, 1
  %sub1517 = sub nsw i64 %conv1509, %add1516
  br label %cond.end.1522

cond.false.1518:                                  ; preds = %cond.true.1495
  %233 = load i64, i64* %nargs, align 8
  %add1519 = add nsw i64 0, %233
  %mul1520 = mul nsw i64 0, %add1519
  %add1521 = add nsw i64 %mul1520, 0
  br label %cond.end.1522

cond.end.1522:                                    ; preds = %cond.false.1518, %cond.true.1501
  %cond1523 = phi i64 [ %sub1517, %cond.true.1501 ], [ %add1521, %cond.false.1518 ]
  %div1524 = sdiv i64 %cond1523, 8
  %cmp1525 = icmp slt i64 %229, %div1524
  br i1 %cmp1525, label %cond.true.1564, label %lor.lhs.false.1550

cond.false.1527:                                  ; preds = %cond.false.1492
  %234 = load i64, i64* %nargs, align 8
  %add1528 = add nsw i64 0, %234
  %mul1529 = mul nsw i64 0, %add1528
  %sub1530 = sub nsw i64 %mul1529, 1
  %cmp1531 = icmp slt i64 %sub1530, 0
  br i1 %cmp1531, label %cond.true.1533, label %cond.false.1541

cond.true.1533:                                   ; preds = %cond.false.1527
  %235 = load i64, i64* %nargs, align 8
  %add1534 = add nsw i64 0, %235
  %mul1535 = mul nsw i64 0, %add1534
  %add1536 = add nsw i64 %mul1535, 1
  %shl1537 = shl i64 %add1536, 62
  %sub1538 = sub nsw i64 %shl1537, 1
  %mul1539 = mul nsw i64 %sub1538, 2
  %add1540 = add nsw i64 %mul1539, 1
  br label %cond.end.1545

cond.false.1541:                                  ; preds = %cond.false.1527
  %236 = load i64, i64* %nargs, align 8
  %add1542 = add nsw i64 0, %236
  %mul1543 = mul nsw i64 0, %add1542
  %sub1544 = sub nsw i64 %mul1543, 1
  br label %cond.end.1545

cond.end.1545:                                    ; preds = %cond.false.1541, %cond.true.1533
  %cond1546 = phi i64 [ %add1540, %cond.true.1533 ], [ %sub1544, %cond.false.1541 ]
  %div1547 = sdiv i64 %cond1546, 8
  %237 = load i64, i64* %nargs, align 8
  %cmp1548 = icmp slt i64 %div1547, %237
  br i1 %cmp1548, label %cond.true.1564, label %lor.lhs.false.1550

lor.lhs.false.1550:                               ; preds = %cond.end.1545, %cond.end.1522, %cond.true.1491, %cond.end.1485, %cond.true.1457, %cond.end.1451
  %238 = load i64, i64* %nargs, align 8
  %mul1551 = mul nsw i64 %238, 8
  %mul1552 = mul nsw i64 0, %mul1551
  %sub1553 = sub nsw i64 %mul1552, 1
  %cmp1554 = icmp slt i64 %sub1553, 0
  br i1 %cmp1554, label %land.lhs.true.1556, label %lor.lhs.false.1560

land.lhs.true.1556:                               ; preds = %lor.lhs.false.1550
  %239 = load i64, i64* %nargs, align 8
  %mul1557 = mul nsw i64 %239, 8
  %cmp1558 = icmp slt i64 %mul1557, -9223372036854775808
  br i1 %cmp1558, label %cond.true.1564, label %lor.lhs.false.1560

lor.lhs.false.1560:                               ; preds = %land.lhs.true.1556, %lor.lhs.false.1550
  %240 = load i64, i64* %nargs, align 8
  %mul1561 = mul nsw i64 %240, 8
  %cmp1562 = icmp slt i64 9223372036854775807, %mul1561
  br i1 %cmp1562, label %cond.true.1564, label %cond.false.1576

cond.true.1564:                                   ; preds = %lor.lhs.false.1560, %land.lhs.true.1556, %cond.end.1545, %cond.end.1522, %cond.true.1491, %cond.end.1485, %cond.true.1457, %cond.end.1451, %land.lhs.true.1426
  %241 = load i64, i64* %nargs, align 8
  %mul1565 = mul i64 %241, 8
  %cmp1566 = icmp ule i64 %mul1565, 9223372036854775807
  br i1 %cmp1566, label %cond.true.1568, label %cond.false.1570

cond.true.1568:                                   ; preds = %cond.true.1564
  %242 = load i64, i64* %nargs, align 8
  %mul1569 = mul i64 %242, 8
  br label %cond.end.1574

cond.false.1570:                                  ; preds = %cond.true.1564
  %243 = load i64, i64* %nargs, align 8
  %mul1571 = mul i64 %243, 8
  %sub1572 = sub i64 %mul1571, -9223372036854775808
  %add1573 = add nsw i64 %sub1572, -9223372036854775808
  br label %cond.end.1574

cond.end.1574:                                    ; preds = %cond.false.1570, %cond.true.1568
  %cond1575 = phi i64 [ %mul1569, %cond.true.1568 ], [ %add1573, %cond.false.1570 ]
  store i64 %cond1575, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2171, label %lor.lhs.false.2168

cond.false.1576:                                  ; preds = %lor.lhs.false.1560
  %244 = load i64, i64* %nargs, align 8
  %mul1577 = mul i64 %244, 8
  %cmp1578 = icmp ule i64 %mul1577, 9223372036854775807
  br i1 %cmp1578, label %cond.true.1580, label %cond.false.1582

cond.true.1580:                                   ; preds = %cond.false.1576
  %245 = load i64, i64* %nargs, align 8
  %mul1581 = mul i64 %245, 8
  br label %cond.end.1586

cond.false.1582:                                  ; preds = %cond.false.1576
  %246 = load i64, i64* %nargs, align 8
  %mul1583 = mul i64 %246, 8
  %sub1584 = sub i64 %mul1583, -9223372036854775808
  %add1585 = add nsw i64 %sub1584, -9223372036854775808
  br label %cond.end.1586

cond.end.1586:                                    ; preds = %cond.false.1582, %cond.true.1580
  %cond1587 = phi i64 [ %mul1581, %cond.true.1580 ], [ %add1585, %cond.false.1582 ]
  store i64 %cond1587, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2171, label %lor.lhs.false.2168

cond.false.1588:                                  ; preds = %cond.true.1394
  %247 = load i64, i64* %nargs, align 8
  %add1589 = add nsw i64 0, %247
  %mul1590 = mul nsw i64 0, %add1589
  %sub1591 = sub nsw i64 %mul1590, 1
  %cmp1592 = icmp slt i64 %sub1591, 0
  br i1 %cmp1592, label %cond.true.1594, label %cond.false.1611

cond.true.1594:                                   ; preds = %cond.false.1588
  %248 = load i64, i64* %nargs, align 8
  %add1595 = add nsw i64 0, %248
  %mul1596 = mul nsw i64 0, %add1595
  %add1597 = add nsw i64 %mul1596, 0
  %neg1598 = xor i64 %add1597, -1
  %cmp1599 = icmp eq i64 %neg1598, -1
  %conv1600 = zext i1 %cmp1599 to i32
  %sub1601 = sub nsw i32 0, %conv1600
  %conv1602 = sext i32 %sub1601 to i64
  %249 = load i64, i64* %nargs, align 8
  %add1603 = add nsw i64 0, %249
  %mul1604 = mul nsw i64 0, %add1603
  %add1605 = add nsw i64 %mul1604, 1
  %shl1606 = shl i64 %add1605, 62
  %sub1607 = sub nsw i64 %shl1606, 1
  %mul1608 = mul nsw i64 %sub1607, 2
  %add1609 = add nsw i64 %mul1608, 1
  %sub1610 = sub nsw i64 %conv1602, %add1609
  br label %cond.end.1615

cond.false.1611:                                  ; preds = %cond.false.1588
  %250 = load i64, i64* %nargs, align 8
  %add1612 = add nsw i64 0, %250
  %mul1613 = mul nsw i64 0, %add1612
  %add1614 = add nsw i64 %mul1613, 0
  br label %cond.end.1615

cond.end.1615:                                    ; preds = %cond.false.1611, %cond.true.1594
  %cond1616 = phi i64 [ %sub1610, %cond.true.1594 ], [ %add1614, %cond.false.1611 ]
  %cmp1617 = icmp eq i64 %cond1616, 0
  br i1 %cmp1617, label %land.lhs.true.1619, label %lor.lhs.false.1622

land.lhs.true.1619:                               ; preds = %cond.end.1615
  %251 = load i64, i64* %nargs, align 8
  %cmp1620 = icmp slt i64 %251, 0
  br i1 %cmp1620, label %cond.true.1757, label %lor.lhs.false.1622

lor.lhs.false.1622:                               ; preds = %land.lhs.true.1619, %cond.end.1615
  br i1 false, label %cond.true.1623, label %cond.false.1683

cond.true.1623:                                   ; preds = %lor.lhs.false.1622
  %252 = load i64, i64* %nargs, align 8
  %cmp1624 = icmp slt i64 %252, 0
  br i1 %cmp1624, label %cond.true.1626, label %cond.false.1649

cond.true.1626:                                   ; preds = %cond.true.1623
  %253 = load i64, i64* %nargs, align 8
  %254 = load i64, i64* %nargs, align 8
  %add1627 = add nsw i64 0, %254
  %mul1628 = mul nsw i64 0, %add1627
  %sub1629 = sub nsw i64 %mul1628, 1
  %cmp1630 = icmp slt i64 %sub1629, 0
  br i1 %cmp1630, label %cond.true.1632, label %cond.false.1640

cond.true.1632:                                   ; preds = %cond.true.1626
  %255 = load i64, i64* %nargs, align 8
  %add1633 = add nsw i64 0, %255
  %mul1634 = mul nsw i64 0, %add1633
  %add1635 = add nsw i64 %mul1634, 1
  %shl1636 = shl i64 %add1635, 62
  %sub1637 = sub nsw i64 %shl1636, 1
  %mul1638 = mul nsw i64 %sub1637, 2
  %add1639 = add nsw i64 %mul1638, 1
  br label %cond.end.1644

cond.false.1640:                                  ; preds = %cond.true.1626
  %256 = load i64, i64* %nargs, align 8
  %add1641 = add nsw i64 0, %256
  %mul1642 = mul nsw i64 0, %add1641
  %sub1643 = sub nsw i64 %mul1642, 1
  br label %cond.end.1644

cond.end.1644:                                    ; preds = %cond.false.1640, %cond.true.1632
  %cond1645 = phi i64 [ %add1639, %cond.true.1632 ], [ %sub1643, %cond.false.1640 ]
  %div1646 = sdiv i64 %cond1645, 8
  %cmp1647 = icmp slt i64 %253, %div1646
  br i1 %cmp1647, label %cond.true.1757, label %lor.lhs.false.1743

cond.false.1649:                                  ; preds = %cond.true.1623
  br i1 false, label %cond.true.1650, label %cond.false.1651

cond.true.1650:                                   ; preds = %cond.false.1649
  br i1 false, label %cond.true.1757, label %lor.lhs.false.1743

cond.false.1651:                                  ; preds = %cond.false.1649
  %257 = load i64, i64* %nargs, align 8
  %add1652 = add nsw i64 0, %257
  %mul1653 = mul nsw i64 0, %add1652
  %sub1654 = sub nsw i64 %mul1653, 1
  %cmp1655 = icmp slt i64 %sub1654, 0
  br i1 %cmp1655, label %cond.true.1657, label %cond.false.1674

cond.true.1657:                                   ; preds = %cond.false.1651
  %258 = load i64, i64* %nargs, align 8
  %add1658 = add nsw i64 0, %258
  %mul1659 = mul nsw i64 0, %add1658
  %add1660 = add nsw i64 %mul1659, 0
  %neg1661 = xor i64 %add1660, -1
  %cmp1662 = icmp eq i64 %neg1661, -1
  %conv1663 = zext i1 %cmp1662 to i32
  %sub1664 = sub nsw i32 0, %conv1663
  %conv1665 = sext i32 %sub1664 to i64
  %259 = load i64, i64* %nargs, align 8
  %add1666 = add nsw i64 0, %259
  %mul1667 = mul nsw i64 0, %add1666
  %add1668 = add nsw i64 %mul1667, 1
  %shl1669 = shl i64 %add1668, 62
  %sub1670 = sub nsw i64 %shl1669, 1
  %mul1671 = mul nsw i64 %sub1670, 2
  %add1672 = add nsw i64 %mul1671, 1
  %sub1673 = sub nsw i64 %conv1665, %add1672
  br label %cond.end.1678

cond.false.1674:                                  ; preds = %cond.false.1651
  %260 = load i64, i64* %nargs, align 8
  %add1675 = add nsw i64 0, %260
  %mul1676 = mul nsw i64 0, %add1675
  %add1677 = add nsw i64 %mul1676, 0
  br label %cond.end.1678

cond.end.1678:                                    ; preds = %cond.false.1674, %cond.true.1657
  %cond1679 = phi i64 [ %sub1673, %cond.true.1657 ], [ %add1677, %cond.false.1674 ]
  %div1680 = sdiv i64 %cond1679, 8
  %261 = load i64, i64* %nargs, align 8
  %cmp1681 = icmp slt i64 %div1680, %261
  br i1 %cmp1681, label %cond.true.1757, label %lor.lhs.false.1743

cond.false.1683:                                  ; preds = %lor.lhs.false.1622
  br i1 false, label %cond.true.1684, label %cond.false.1685

cond.true.1684:                                   ; preds = %cond.false.1683
  br i1 false, label %cond.true.1757, label %lor.lhs.false.1743

cond.false.1685:                                  ; preds = %cond.false.1683
  %262 = load i64, i64* %nargs, align 8
  %cmp1686 = icmp slt i64 %262, 0
  br i1 %cmp1686, label %cond.true.1688, label %cond.false.1720

cond.true.1688:                                   ; preds = %cond.false.1685
  %263 = load i64, i64* %nargs, align 8
  %264 = load i64, i64* %nargs, align 8
  %add1689 = add nsw i64 0, %264
  %mul1690 = mul nsw i64 0, %add1689
  %sub1691 = sub nsw i64 %mul1690, 1
  %cmp1692 = icmp slt i64 %sub1691, 0
  br i1 %cmp1692, label %cond.true.1694, label %cond.false.1711

cond.true.1694:                                   ; preds = %cond.true.1688
  %265 = load i64, i64* %nargs, align 8
  %add1695 = add nsw i64 0, %265
  %mul1696 = mul nsw i64 0, %add1695
  %add1697 = add nsw i64 %mul1696, 0
  %neg1698 = xor i64 %add1697, -1
  %cmp1699 = icmp eq i64 %neg1698, -1
  %conv1700 = zext i1 %cmp1699 to i32
  %sub1701 = sub nsw i32 0, %conv1700
  %conv1702 = sext i32 %sub1701 to i64
  %266 = load i64, i64* %nargs, align 8
  %add1703 = add nsw i64 0, %266
  %mul1704 = mul nsw i64 0, %add1703
  %add1705 = add nsw i64 %mul1704, 1
  %shl1706 = shl i64 %add1705, 62
  %sub1707 = sub nsw i64 %shl1706, 1
  %mul1708 = mul nsw i64 %sub1707, 2
  %add1709 = add nsw i64 %mul1708, 1
  %sub1710 = sub nsw i64 %conv1702, %add1709
  br label %cond.end.1715

cond.false.1711:                                  ; preds = %cond.true.1688
  %267 = load i64, i64* %nargs, align 8
  %add1712 = add nsw i64 0, %267
  %mul1713 = mul nsw i64 0, %add1712
  %add1714 = add nsw i64 %mul1713, 0
  br label %cond.end.1715

cond.end.1715:                                    ; preds = %cond.false.1711, %cond.true.1694
  %cond1716 = phi i64 [ %sub1710, %cond.true.1694 ], [ %add1714, %cond.false.1711 ]
  %div1717 = sdiv i64 %cond1716, 8
  %cmp1718 = icmp slt i64 %263, %div1717
  br i1 %cmp1718, label %cond.true.1757, label %lor.lhs.false.1743

cond.false.1720:                                  ; preds = %cond.false.1685
  %268 = load i64, i64* %nargs, align 8
  %add1721 = add nsw i64 0, %268
  %mul1722 = mul nsw i64 0, %add1721
  %sub1723 = sub nsw i64 %mul1722, 1
  %cmp1724 = icmp slt i64 %sub1723, 0
  br i1 %cmp1724, label %cond.true.1726, label %cond.false.1734

cond.true.1726:                                   ; preds = %cond.false.1720
  %269 = load i64, i64* %nargs, align 8
  %add1727 = add nsw i64 0, %269
  %mul1728 = mul nsw i64 0, %add1727
  %add1729 = add nsw i64 %mul1728, 1
  %shl1730 = shl i64 %add1729, 62
  %sub1731 = sub nsw i64 %shl1730, 1
  %mul1732 = mul nsw i64 %sub1731, 2
  %add1733 = add nsw i64 %mul1732, 1
  br label %cond.end.1738

cond.false.1734:                                  ; preds = %cond.false.1720
  %270 = load i64, i64* %nargs, align 8
  %add1735 = add nsw i64 0, %270
  %mul1736 = mul nsw i64 0, %add1735
  %sub1737 = sub nsw i64 %mul1736, 1
  br label %cond.end.1738

cond.end.1738:                                    ; preds = %cond.false.1734, %cond.true.1726
  %cond1739 = phi i64 [ %add1733, %cond.true.1726 ], [ %sub1737, %cond.false.1734 ]
  %div1740 = sdiv i64 %cond1739, 8
  %271 = load i64, i64* %nargs, align 8
  %cmp1741 = icmp slt i64 %div1740, %271
  br i1 %cmp1741, label %cond.true.1757, label %lor.lhs.false.1743

lor.lhs.false.1743:                               ; preds = %cond.end.1738, %cond.end.1715, %cond.true.1684, %cond.end.1678, %cond.true.1650, %cond.end.1644
  %272 = load i64, i64* %nargs, align 8
  %mul1744 = mul nsw i64 %272, 8
  %mul1745 = mul nsw i64 0, %mul1744
  %sub1746 = sub nsw i64 %mul1745, 1
  %cmp1747 = icmp slt i64 %sub1746, 0
  br i1 %cmp1747, label %land.lhs.true.1749, label %lor.lhs.false.1753

land.lhs.true.1749:                               ; preds = %lor.lhs.false.1743
  %273 = load i64, i64* %nargs, align 8
  %mul1750 = mul nsw i64 %273, 8
  %cmp1751 = icmp slt i64 %mul1750, -9223372036854775808
  br i1 %cmp1751, label %cond.true.1757, label %lor.lhs.false.1753

lor.lhs.false.1753:                               ; preds = %land.lhs.true.1749, %lor.lhs.false.1743
  %274 = load i64, i64* %nargs, align 8
  %mul1754 = mul nsw i64 %274, 8
  %cmp1755 = icmp slt i64 9223372036854775807, %mul1754
  br i1 %cmp1755, label %cond.true.1757, label %cond.false.1769

cond.true.1757:                                   ; preds = %lor.lhs.false.1753, %land.lhs.true.1749, %cond.end.1738, %cond.end.1715, %cond.true.1684, %cond.end.1678, %cond.true.1650, %cond.end.1644, %land.lhs.true.1619
  %275 = load i64, i64* %nargs, align 8
  %mul1758 = mul i64 %275, 8
  %cmp1759 = icmp ule i64 %mul1758, 9223372036854775807
  br i1 %cmp1759, label %cond.true.1761, label %cond.false.1763

cond.true.1761:                                   ; preds = %cond.true.1757
  %276 = load i64, i64* %nargs, align 8
  %mul1762 = mul i64 %276, 8
  br label %cond.end.1767

cond.false.1763:                                  ; preds = %cond.true.1757
  %277 = load i64, i64* %nargs, align 8
  %mul1764 = mul i64 %277, 8
  %sub1765 = sub i64 %mul1764, -9223372036854775808
  %add1766 = add nsw i64 %sub1765, -9223372036854775808
  br label %cond.end.1767

cond.end.1767:                                    ; preds = %cond.false.1763, %cond.true.1761
  %cond1768 = phi i64 [ %mul1762, %cond.true.1761 ], [ %add1766, %cond.false.1763 ]
  store i64 %cond1768, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2171, label %lor.lhs.false.2168

cond.false.1769:                                  ; preds = %lor.lhs.false.1753
  %278 = load i64, i64* %nargs, align 8
  %mul1770 = mul i64 %278, 8
  %cmp1771 = icmp ule i64 %mul1770, 9223372036854775807
  br i1 %cmp1771, label %cond.true.1773, label %cond.false.1775

cond.true.1773:                                   ; preds = %cond.false.1769
  %279 = load i64, i64* %nargs, align 8
  %mul1774 = mul i64 %279, 8
  br label %cond.end.1779

cond.false.1775:                                  ; preds = %cond.false.1769
  %280 = load i64, i64* %nargs, align 8
  %mul1776 = mul i64 %280, 8
  %sub1777 = sub i64 %mul1776, -9223372036854775808
  %add1778 = add nsw i64 %sub1777, -9223372036854775808
  br label %cond.end.1779

cond.end.1779:                                    ; preds = %cond.false.1775, %cond.true.1773
  %cond1780 = phi i64 [ %mul1774, %cond.true.1773 ], [ %add1778, %cond.false.1775 ]
  store i64 %cond1780, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2171, label %lor.lhs.false.2168

cond.false.1781:                                  ; preds = %cond.false.1393
  br i1 false, label %cond.true.1782, label %cond.false.1975

cond.true.1782:                                   ; preds = %cond.false.1781
  %281 = load i64, i64* %nargs, align 8
  %add1783 = add nsw i64 0, %281
  %mul1784 = mul nsw i64 0, %add1783
  %sub1785 = sub nsw i64 %mul1784, 1
  %cmp1786 = icmp slt i64 %sub1785, 0
  br i1 %cmp1786, label %cond.true.1788, label %cond.false.1805

cond.true.1788:                                   ; preds = %cond.true.1782
  %282 = load i64, i64* %nargs, align 8
  %add1789 = add nsw i64 0, %282
  %mul1790 = mul nsw i64 0, %add1789
  %add1791 = add nsw i64 %mul1790, 0
  %neg1792 = xor i64 %add1791, -1
  %cmp1793 = icmp eq i64 %neg1792, -1
  %conv1794 = zext i1 %cmp1793 to i32
  %sub1795 = sub nsw i32 0, %conv1794
  %conv1796 = sext i32 %sub1795 to i64
  %283 = load i64, i64* %nargs, align 8
  %add1797 = add nsw i64 0, %283
  %mul1798 = mul nsw i64 0, %add1797
  %add1799 = add nsw i64 %mul1798, 1
  %shl1800 = shl i64 %add1799, 62
  %sub1801 = sub nsw i64 %shl1800, 1
  %mul1802 = mul nsw i64 %sub1801, 2
  %add1803 = add nsw i64 %mul1802, 1
  %sub1804 = sub nsw i64 %conv1796, %add1803
  br label %cond.end.1809

cond.false.1805:                                  ; preds = %cond.true.1782
  %284 = load i64, i64* %nargs, align 8
  %add1806 = add nsw i64 0, %284
  %mul1807 = mul nsw i64 0, %add1806
  %add1808 = add nsw i64 %mul1807, 0
  br label %cond.end.1809

cond.end.1809:                                    ; preds = %cond.false.1805, %cond.true.1788
  %cond1810 = phi i64 [ %sub1804, %cond.true.1788 ], [ %add1808, %cond.false.1805 ]
  %cmp1811 = icmp eq i64 %cond1810, 0
  br i1 %cmp1811, label %land.lhs.true.1813, label %lor.lhs.false.1816

land.lhs.true.1813:                               ; preds = %cond.end.1809
  %285 = load i64, i64* %nargs, align 8
  %cmp1814 = icmp slt i64 %285, 0
  br i1 %cmp1814, label %cond.true.1951, label %lor.lhs.false.1816

lor.lhs.false.1816:                               ; preds = %land.lhs.true.1813, %cond.end.1809
  br i1 false, label %cond.true.1817, label %cond.false.1877

cond.true.1817:                                   ; preds = %lor.lhs.false.1816
  %286 = load i64, i64* %nargs, align 8
  %cmp1818 = icmp slt i64 %286, 0
  br i1 %cmp1818, label %cond.true.1820, label %cond.false.1843

cond.true.1820:                                   ; preds = %cond.true.1817
  %287 = load i64, i64* %nargs, align 8
  %288 = load i64, i64* %nargs, align 8
  %add1821 = add nsw i64 0, %288
  %mul1822 = mul nsw i64 0, %add1821
  %sub1823 = sub nsw i64 %mul1822, 1
  %cmp1824 = icmp slt i64 %sub1823, 0
  br i1 %cmp1824, label %cond.true.1826, label %cond.false.1834

cond.true.1826:                                   ; preds = %cond.true.1820
  %289 = load i64, i64* %nargs, align 8
  %add1827 = add nsw i64 0, %289
  %mul1828 = mul nsw i64 0, %add1827
  %add1829 = add nsw i64 %mul1828, 1
  %shl1830 = shl i64 %add1829, 62
  %sub1831 = sub nsw i64 %shl1830, 1
  %mul1832 = mul nsw i64 %sub1831, 2
  %add1833 = add nsw i64 %mul1832, 1
  br label %cond.end.1838

cond.false.1834:                                  ; preds = %cond.true.1820
  %290 = load i64, i64* %nargs, align 8
  %add1835 = add nsw i64 0, %290
  %mul1836 = mul nsw i64 0, %add1835
  %sub1837 = sub nsw i64 %mul1836, 1
  br label %cond.end.1838

cond.end.1838:                                    ; preds = %cond.false.1834, %cond.true.1826
  %cond1839 = phi i64 [ %add1833, %cond.true.1826 ], [ %sub1837, %cond.false.1834 ]
  %div1840 = sdiv i64 %cond1839, 8
  %cmp1841 = icmp slt i64 %287, %div1840
  br i1 %cmp1841, label %cond.true.1951, label %lor.lhs.false.1937

cond.false.1843:                                  ; preds = %cond.true.1817
  br i1 false, label %cond.true.1844, label %cond.false.1845

cond.true.1844:                                   ; preds = %cond.false.1843
  br i1 false, label %cond.true.1951, label %lor.lhs.false.1937

cond.false.1845:                                  ; preds = %cond.false.1843
  %291 = load i64, i64* %nargs, align 8
  %add1846 = add nsw i64 0, %291
  %mul1847 = mul nsw i64 0, %add1846
  %sub1848 = sub nsw i64 %mul1847, 1
  %cmp1849 = icmp slt i64 %sub1848, 0
  br i1 %cmp1849, label %cond.true.1851, label %cond.false.1868

cond.true.1851:                                   ; preds = %cond.false.1845
  %292 = load i64, i64* %nargs, align 8
  %add1852 = add nsw i64 0, %292
  %mul1853 = mul nsw i64 0, %add1852
  %add1854 = add nsw i64 %mul1853, 0
  %neg1855 = xor i64 %add1854, -1
  %cmp1856 = icmp eq i64 %neg1855, -1
  %conv1857 = zext i1 %cmp1856 to i32
  %sub1858 = sub nsw i32 0, %conv1857
  %conv1859 = sext i32 %sub1858 to i64
  %293 = load i64, i64* %nargs, align 8
  %add1860 = add nsw i64 0, %293
  %mul1861 = mul nsw i64 0, %add1860
  %add1862 = add nsw i64 %mul1861, 1
  %shl1863 = shl i64 %add1862, 62
  %sub1864 = sub nsw i64 %shl1863, 1
  %mul1865 = mul nsw i64 %sub1864, 2
  %add1866 = add nsw i64 %mul1865, 1
  %sub1867 = sub nsw i64 %conv1859, %add1866
  br label %cond.end.1872

cond.false.1868:                                  ; preds = %cond.false.1845
  %294 = load i64, i64* %nargs, align 8
  %add1869 = add nsw i64 0, %294
  %mul1870 = mul nsw i64 0, %add1869
  %add1871 = add nsw i64 %mul1870, 0
  br label %cond.end.1872

cond.end.1872:                                    ; preds = %cond.false.1868, %cond.true.1851
  %cond1873 = phi i64 [ %sub1867, %cond.true.1851 ], [ %add1871, %cond.false.1868 ]
  %div1874 = sdiv i64 %cond1873, 8
  %295 = load i64, i64* %nargs, align 8
  %cmp1875 = icmp slt i64 %div1874, %295
  br i1 %cmp1875, label %cond.true.1951, label %lor.lhs.false.1937

cond.false.1877:                                  ; preds = %lor.lhs.false.1816
  br i1 false, label %cond.true.1878, label %cond.false.1879

cond.true.1878:                                   ; preds = %cond.false.1877
  br i1 false, label %cond.true.1951, label %lor.lhs.false.1937

cond.false.1879:                                  ; preds = %cond.false.1877
  %296 = load i64, i64* %nargs, align 8
  %cmp1880 = icmp slt i64 %296, 0
  br i1 %cmp1880, label %cond.true.1882, label %cond.false.1914

cond.true.1882:                                   ; preds = %cond.false.1879
  %297 = load i64, i64* %nargs, align 8
  %298 = load i64, i64* %nargs, align 8
  %add1883 = add nsw i64 0, %298
  %mul1884 = mul nsw i64 0, %add1883
  %sub1885 = sub nsw i64 %mul1884, 1
  %cmp1886 = icmp slt i64 %sub1885, 0
  br i1 %cmp1886, label %cond.true.1888, label %cond.false.1905

cond.true.1888:                                   ; preds = %cond.true.1882
  %299 = load i64, i64* %nargs, align 8
  %add1889 = add nsw i64 0, %299
  %mul1890 = mul nsw i64 0, %add1889
  %add1891 = add nsw i64 %mul1890, 0
  %neg1892 = xor i64 %add1891, -1
  %cmp1893 = icmp eq i64 %neg1892, -1
  %conv1894 = zext i1 %cmp1893 to i32
  %sub1895 = sub nsw i32 0, %conv1894
  %conv1896 = sext i32 %sub1895 to i64
  %300 = load i64, i64* %nargs, align 8
  %add1897 = add nsw i64 0, %300
  %mul1898 = mul nsw i64 0, %add1897
  %add1899 = add nsw i64 %mul1898, 1
  %shl1900 = shl i64 %add1899, 62
  %sub1901 = sub nsw i64 %shl1900, 1
  %mul1902 = mul nsw i64 %sub1901, 2
  %add1903 = add nsw i64 %mul1902, 1
  %sub1904 = sub nsw i64 %conv1896, %add1903
  br label %cond.end.1909

cond.false.1905:                                  ; preds = %cond.true.1882
  %301 = load i64, i64* %nargs, align 8
  %add1906 = add nsw i64 0, %301
  %mul1907 = mul nsw i64 0, %add1906
  %add1908 = add nsw i64 %mul1907, 0
  br label %cond.end.1909

cond.end.1909:                                    ; preds = %cond.false.1905, %cond.true.1888
  %cond1910 = phi i64 [ %sub1904, %cond.true.1888 ], [ %add1908, %cond.false.1905 ]
  %div1911 = sdiv i64 %cond1910, 8
  %cmp1912 = icmp slt i64 %297, %div1911
  br i1 %cmp1912, label %cond.true.1951, label %lor.lhs.false.1937

cond.false.1914:                                  ; preds = %cond.false.1879
  %302 = load i64, i64* %nargs, align 8
  %add1915 = add nsw i64 0, %302
  %mul1916 = mul nsw i64 0, %add1915
  %sub1917 = sub nsw i64 %mul1916, 1
  %cmp1918 = icmp slt i64 %sub1917, 0
  br i1 %cmp1918, label %cond.true.1920, label %cond.false.1928

cond.true.1920:                                   ; preds = %cond.false.1914
  %303 = load i64, i64* %nargs, align 8
  %add1921 = add nsw i64 0, %303
  %mul1922 = mul nsw i64 0, %add1921
  %add1923 = add nsw i64 %mul1922, 1
  %shl1924 = shl i64 %add1923, 62
  %sub1925 = sub nsw i64 %shl1924, 1
  %mul1926 = mul nsw i64 %sub1925, 2
  %add1927 = add nsw i64 %mul1926, 1
  br label %cond.end.1932

cond.false.1928:                                  ; preds = %cond.false.1914
  %304 = load i64, i64* %nargs, align 8
  %add1929 = add nsw i64 0, %304
  %mul1930 = mul nsw i64 0, %add1929
  %sub1931 = sub nsw i64 %mul1930, 1
  br label %cond.end.1932

cond.end.1932:                                    ; preds = %cond.false.1928, %cond.true.1920
  %cond1933 = phi i64 [ %add1927, %cond.true.1920 ], [ %sub1931, %cond.false.1928 ]
  %div1934 = sdiv i64 %cond1933, 8
  %305 = load i64, i64* %nargs, align 8
  %cmp1935 = icmp slt i64 %div1934, %305
  br i1 %cmp1935, label %cond.true.1951, label %lor.lhs.false.1937

lor.lhs.false.1937:                               ; preds = %cond.end.1932, %cond.end.1909, %cond.true.1878, %cond.end.1872, %cond.true.1844, %cond.end.1838
  %306 = load i64, i64* %nargs, align 8
  %mul1938 = mul nsw i64 %306, 8
  %mul1939 = mul nsw i64 0, %mul1938
  %sub1940 = sub nsw i64 %mul1939, 1
  %cmp1941 = icmp slt i64 %sub1940, 0
  br i1 %cmp1941, label %land.lhs.true.1943, label %lor.lhs.false.1947

land.lhs.true.1943:                               ; preds = %lor.lhs.false.1937
  %307 = load i64, i64* %nargs, align 8
  %mul1944 = mul nsw i64 %307, 8
  %cmp1945 = icmp slt i64 %mul1944, -9223372036854775808
  br i1 %cmp1945, label %cond.true.1951, label %lor.lhs.false.1947

lor.lhs.false.1947:                               ; preds = %land.lhs.true.1943, %lor.lhs.false.1937
  %308 = load i64, i64* %nargs, align 8
  %mul1948 = mul nsw i64 %308, 8
  %cmp1949 = icmp slt i64 9223372036854775807, %mul1948
  br i1 %cmp1949, label %cond.true.1951, label %cond.false.1963

cond.true.1951:                                   ; preds = %lor.lhs.false.1947, %land.lhs.true.1943, %cond.end.1932, %cond.end.1909, %cond.true.1878, %cond.end.1872, %cond.true.1844, %cond.end.1838, %land.lhs.true.1813
  %309 = load i64, i64* %nargs, align 8
  %mul1952 = mul i64 %309, 8
  %cmp1953 = icmp ule i64 %mul1952, 9223372036854775807
  br i1 %cmp1953, label %cond.true.1955, label %cond.false.1957

cond.true.1955:                                   ; preds = %cond.true.1951
  %310 = load i64, i64* %nargs, align 8
  %mul1956 = mul i64 %310, 8
  br label %cond.end.1961

cond.false.1957:                                  ; preds = %cond.true.1951
  %311 = load i64, i64* %nargs, align 8
  %mul1958 = mul i64 %311, 8
  %sub1959 = sub i64 %mul1958, -9223372036854775808
  %add1960 = add nsw i64 %sub1959, -9223372036854775808
  br label %cond.end.1961

cond.end.1961:                                    ; preds = %cond.false.1957, %cond.true.1955
  %cond1962 = phi i64 [ %mul1956, %cond.true.1955 ], [ %add1960, %cond.false.1957 ]
  store i64 %cond1962, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2171, label %lor.lhs.false.2168

cond.false.1963:                                  ; preds = %lor.lhs.false.1947
  %312 = load i64, i64* %nargs, align 8
  %mul1964 = mul i64 %312, 8
  %cmp1965 = icmp ule i64 %mul1964, 9223372036854775807
  br i1 %cmp1965, label %cond.true.1967, label %cond.false.1969

cond.true.1967:                                   ; preds = %cond.false.1963
  %313 = load i64, i64* %nargs, align 8
  %mul1968 = mul i64 %313, 8
  br label %cond.end.1973

cond.false.1969:                                  ; preds = %cond.false.1963
  %314 = load i64, i64* %nargs, align 8
  %mul1970 = mul i64 %314, 8
  %sub1971 = sub i64 %mul1970, -9223372036854775808
  %add1972 = add nsw i64 %sub1971, -9223372036854775808
  br label %cond.end.1973

cond.end.1973:                                    ; preds = %cond.false.1969, %cond.true.1967
  %cond1974 = phi i64 [ %mul1968, %cond.true.1967 ], [ %add1972, %cond.false.1969 ]
  store i64 %cond1974, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2171, label %lor.lhs.false.2168

cond.false.1975:                                  ; preds = %cond.false.1781
  %315 = load i64, i64* %nargs, align 8
  %add1976 = add nsw i64 0, %315
  %mul1977 = mul nsw i64 0, %add1976
  %sub1978 = sub nsw i64 %mul1977, 1
  %cmp1979 = icmp slt i64 %sub1978, 0
  br i1 %cmp1979, label %cond.true.1981, label %cond.false.1998

cond.true.1981:                                   ; preds = %cond.false.1975
  %316 = load i64, i64* %nargs, align 8
  %add1982 = add nsw i64 0, %316
  %mul1983 = mul nsw i64 0, %add1982
  %add1984 = add nsw i64 %mul1983, 0
  %neg1985 = xor i64 %add1984, -1
  %cmp1986 = icmp eq i64 %neg1985, -1
  %conv1987 = zext i1 %cmp1986 to i32
  %sub1988 = sub nsw i32 0, %conv1987
  %conv1989 = sext i32 %sub1988 to i64
  %317 = load i64, i64* %nargs, align 8
  %add1990 = add nsw i64 0, %317
  %mul1991 = mul nsw i64 0, %add1990
  %add1992 = add nsw i64 %mul1991, 1
  %shl1993 = shl i64 %add1992, 62
  %sub1994 = sub nsw i64 %shl1993, 1
  %mul1995 = mul nsw i64 %sub1994, 2
  %add1996 = add nsw i64 %mul1995, 1
  %sub1997 = sub nsw i64 %conv1989, %add1996
  br label %cond.end.2002

cond.false.1998:                                  ; preds = %cond.false.1975
  %318 = load i64, i64* %nargs, align 8
  %add1999 = add nsw i64 0, %318
  %mul2000 = mul nsw i64 0, %add1999
  %add2001 = add nsw i64 %mul2000, 0
  br label %cond.end.2002

cond.end.2002:                                    ; preds = %cond.false.1998, %cond.true.1981
  %cond2003 = phi i64 [ %sub1997, %cond.true.1981 ], [ %add2001, %cond.false.1998 ]
  %cmp2004 = icmp eq i64 %cond2003, 0
  br i1 %cmp2004, label %land.lhs.true.2006, label %lor.lhs.false.2009

land.lhs.true.2006:                               ; preds = %cond.end.2002
  %319 = load i64, i64* %nargs, align 8
  %cmp2007 = icmp slt i64 %319, 0
  br i1 %cmp2007, label %cond.true.2144, label %lor.lhs.false.2009

lor.lhs.false.2009:                               ; preds = %land.lhs.true.2006, %cond.end.2002
  br i1 false, label %cond.true.2010, label %cond.false.2070

cond.true.2010:                                   ; preds = %lor.lhs.false.2009
  %320 = load i64, i64* %nargs, align 8
  %cmp2011 = icmp slt i64 %320, 0
  br i1 %cmp2011, label %cond.true.2013, label %cond.false.2036

cond.true.2013:                                   ; preds = %cond.true.2010
  %321 = load i64, i64* %nargs, align 8
  %322 = load i64, i64* %nargs, align 8
  %add2014 = add nsw i64 0, %322
  %mul2015 = mul nsw i64 0, %add2014
  %sub2016 = sub nsw i64 %mul2015, 1
  %cmp2017 = icmp slt i64 %sub2016, 0
  br i1 %cmp2017, label %cond.true.2019, label %cond.false.2027

cond.true.2019:                                   ; preds = %cond.true.2013
  %323 = load i64, i64* %nargs, align 8
  %add2020 = add nsw i64 0, %323
  %mul2021 = mul nsw i64 0, %add2020
  %add2022 = add nsw i64 %mul2021, 1
  %shl2023 = shl i64 %add2022, 62
  %sub2024 = sub nsw i64 %shl2023, 1
  %mul2025 = mul nsw i64 %sub2024, 2
  %add2026 = add nsw i64 %mul2025, 1
  br label %cond.end.2031

cond.false.2027:                                  ; preds = %cond.true.2013
  %324 = load i64, i64* %nargs, align 8
  %add2028 = add nsw i64 0, %324
  %mul2029 = mul nsw i64 0, %add2028
  %sub2030 = sub nsw i64 %mul2029, 1
  br label %cond.end.2031

cond.end.2031:                                    ; preds = %cond.false.2027, %cond.true.2019
  %cond2032 = phi i64 [ %add2026, %cond.true.2019 ], [ %sub2030, %cond.false.2027 ]
  %div2033 = sdiv i64 %cond2032, 8
  %cmp2034 = icmp slt i64 %321, %div2033
  br i1 %cmp2034, label %cond.true.2144, label %lor.lhs.false.2130

cond.false.2036:                                  ; preds = %cond.true.2010
  br i1 false, label %cond.true.2037, label %cond.false.2038

cond.true.2037:                                   ; preds = %cond.false.2036
  br i1 false, label %cond.true.2144, label %lor.lhs.false.2130

cond.false.2038:                                  ; preds = %cond.false.2036
  %325 = load i64, i64* %nargs, align 8
  %add2039 = add nsw i64 0, %325
  %mul2040 = mul nsw i64 0, %add2039
  %sub2041 = sub nsw i64 %mul2040, 1
  %cmp2042 = icmp slt i64 %sub2041, 0
  br i1 %cmp2042, label %cond.true.2044, label %cond.false.2061

cond.true.2044:                                   ; preds = %cond.false.2038
  %326 = load i64, i64* %nargs, align 8
  %add2045 = add nsw i64 0, %326
  %mul2046 = mul nsw i64 0, %add2045
  %add2047 = add nsw i64 %mul2046, 0
  %neg2048 = xor i64 %add2047, -1
  %cmp2049 = icmp eq i64 %neg2048, -1
  %conv2050 = zext i1 %cmp2049 to i32
  %sub2051 = sub nsw i32 0, %conv2050
  %conv2052 = sext i32 %sub2051 to i64
  %327 = load i64, i64* %nargs, align 8
  %add2053 = add nsw i64 0, %327
  %mul2054 = mul nsw i64 0, %add2053
  %add2055 = add nsw i64 %mul2054, 1
  %shl2056 = shl i64 %add2055, 62
  %sub2057 = sub nsw i64 %shl2056, 1
  %mul2058 = mul nsw i64 %sub2057, 2
  %add2059 = add nsw i64 %mul2058, 1
  %sub2060 = sub nsw i64 %conv2052, %add2059
  br label %cond.end.2065

cond.false.2061:                                  ; preds = %cond.false.2038
  %328 = load i64, i64* %nargs, align 8
  %add2062 = add nsw i64 0, %328
  %mul2063 = mul nsw i64 0, %add2062
  %add2064 = add nsw i64 %mul2063, 0
  br label %cond.end.2065

cond.end.2065:                                    ; preds = %cond.false.2061, %cond.true.2044
  %cond2066 = phi i64 [ %sub2060, %cond.true.2044 ], [ %add2064, %cond.false.2061 ]
  %div2067 = sdiv i64 %cond2066, 8
  %329 = load i64, i64* %nargs, align 8
  %cmp2068 = icmp slt i64 %div2067, %329
  br i1 %cmp2068, label %cond.true.2144, label %lor.lhs.false.2130

cond.false.2070:                                  ; preds = %lor.lhs.false.2009
  br i1 false, label %cond.true.2071, label %cond.false.2072

cond.true.2071:                                   ; preds = %cond.false.2070
  br i1 false, label %cond.true.2144, label %lor.lhs.false.2130

cond.false.2072:                                  ; preds = %cond.false.2070
  %330 = load i64, i64* %nargs, align 8
  %cmp2073 = icmp slt i64 %330, 0
  br i1 %cmp2073, label %cond.true.2075, label %cond.false.2107

cond.true.2075:                                   ; preds = %cond.false.2072
  %331 = load i64, i64* %nargs, align 8
  %332 = load i64, i64* %nargs, align 8
  %add2076 = add nsw i64 0, %332
  %mul2077 = mul nsw i64 0, %add2076
  %sub2078 = sub nsw i64 %mul2077, 1
  %cmp2079 = icmp slt i64 %sub2078, 0
  br i1 %cmp2079, label %cond.true.2081, label %cond.false.2098

cond.true.2081:                                   ; preds = %cond.true.2075
  %333 = load i64, i64* %nargs, align 8
  %add2082 = add nsw i64 0, %333
  %mul2083 = mul nsw i64 0, %add2082
  %add2084 = add nsw i64 %mul2083, 0
  %neg2085 = xor i64 %add2084, -1
  %cmp2086 = icmp eq i64 %neg2085, -1
  %conv2087 = zext i1 %cmp2086 to i32
  %sub2088 = sub nsw i32 0, %conv2087
  %conv2089 = sext i32 %sub2088 to i64
  %334 = load i64, i64* %nargs, align 8
  %add2090 = add nsw i64 0, %334
  %mul2091 = mul nsw i64 0, %add2090
  %add2092 = add nsw i64 %mul2091, 1
  %shl2093 = shl i64 %add2092, 62
  %sub2094 = sub nsw i64 %shl2093, 1
  %mul2095 = mul nsw i64 %sub2094, 2
  %add2096 = add nsw i64 %mul2095, 1
  %sub2097 = sub nsw i64 %conv2089, %add2096
  br label %cond.end.2102

cond.false.2098:                                  ; preds = %cond.true.2075
  %335 = load i64, i64* %nargs, align 8
  %add2099 = add nsw i64 0, %335
  %mul2100 = mul nsw i64 0, %add2099
  %add2101 = add nsw i64 %mul2100, 0
  br label %cond.end.2102

cond.end.2102:                                    ; preds = %cond.false.2098, %cond.true.2081
  %cond2103 = phi i64 [ %sub2097, %cond.true.2081 ], [ %add2101, %cond.false.2098 ]
  %div2104 = sdiv i64 %cond2103, 8
  %cmp2105 = icmp slt i64 %331, %div2104
  br i1 %cmp2105, label %cond.true.2144, label %lor.lhs.false.2130

cond.false.2107:                                  ; preds = %cond.false.2072
  %336 = load i64, i64* %nargs, align 8
  %add2108 = add nsw i64 0, %336
  %mul2109 = mul nsw i64 0, %add2108
  %sub2110 = sub nsw i64 %mul2109, 1
  %cmp2111 = icmp slt i64 %sub2110, 0
  br i1 %cmp2111, label %cond.true.2113, label %cond.false.2121

cond.true.2113:                                   ; preds = %cond.false.2107
  %337 = load i64, i64* %nargs, align 8
  %add2114 = add nsw i64 0, %337
  %mul2115 = mul nsw i64 0, %add2114
  %add2116 = add nsw i64 %mul2115, 1
  %shl2117 = shl i64 %add2116, 62
  %sub2118 = sub nsw i64 %shl2117, 1
  %mul2119 = mul nsw i64 %sub2118, 2
  %add2120 = add nsw i64 %mul2119, 1
  br label %cond.end.2125

cond.false.2121:                                  ; preds = %cond.false.2107
  %338 = load i64, i64* %nargs, align 8
  %add2122 = add nsw i64 0, %338
  %mul2123 = mul nsw i64 0, %add2122
  %sub2124 = sub nsw i64 %mul2123, 1
  br label %cond.end.2125

cond.end.2125:                                    ; preds = %cond.false.2121, %cond.true.2113
  %cond2126 = phi i64 [ %add2120, %cond.true.2113 ], [ %sub2124, %cond.false.2121 ]
  %div2127 = sdiv i64 %cond2126, 8
  %339 = load i64, i64* %nargs, align 8
  %cmp2128 = icmp slt i64 %div2127, %339
  br i1 %cmp2128, label %cond.true.2144, label %lor.lhs.false.2130

lor.lhs.false.2130:                               ; preds = %cond.end.2125, %cond.end.2102, %cond.true.2071, %cond.end.2065, %cond.true.2037, %cond.end.2031
  %340 = load i64, i64* %nargs, align 8
  %mul2131 = mul nsw i64 %340, 8
  %mul2132 = mul nsw i64 0, %mul2131
  %sub2133 = sub nsw i64 %mul2132, 1
  %cmp2134 = icmp slt i64 %sub2133, 0
  br i1 %cmp2134, label %land.lhs.true.2136, label %lor.lhs.false.2140

land.lhs.true.2136:                               ; preds = %lor.lhs.false.2130
  %341 = load i64, i64* %nargs, align 8
  %mul2137 = mul nsw i64 %341, 8
  %cmp2138 = icmp slt i64 %mul2137, -9223372036854775808
  br i1 %cmp2138, label %cond.true.2144, label %lor.lhs.false.2140

lor.lhs.false.2140:                               ; preds = %land.lhs.true.2136, %lor.lhs.false.2130
  %342 = load i64, i64* %nargs, align 8
  %mul2141 = mul nsw i64 %342, 8
  %cmp2142 = icmp slt i64 9223372036854775807, %mul2141
  br i1 %cmp2142, label %cond.true.2144, label %cond.false.2156

cond.true.2144:                                   ; preds = %lor.lhs.false.2140, %land.lhs.true.2136, %cond.end.2125, %cond.end.2102, %cond.true.2071, %cond.end.2065, %cond.true.2037, %cond.end.2031, %land.lhs.true.2006
  %343 = load i64, i64* %nargs, align 8
  %mul2145 = mul i64 %343, 8
  %cmp2146 = icmp ule i64 %mul2145, 9223372036854775807
  br i1 %cmp2146, label %cond.true.2148, label %cond.false.2150

cond.true.2148:                                   ; preds = %cond.true.2144
  %344 = load i64, i64* %nargs, align 8
  %mul2149 = mul i64 %344, 8
  br label %cond.end.2154

cond.false.2150:                                  ; preds = %cond.true.2144
  %345 = load i64, i64* %nargs, align 8
  %mul2151 = mul i64 %345, 8
  %sub2152 = sub i64 %mul2151, -9223372036854775808
  %add2153 = add nsw i64 %sub2152, -9223372036854775808
  br label %cond.end.2154

cond.end.2154:                                    ; preds = %cond.false.2150, %cond.true.2148
  %cond2155 = phi i64 [ %mul2149, %cond.true.2148 ], [ %add2153, %cond.false.2150 ]
  store i64 %cond2155, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2171, label %lor.lhs.false.2168

cond.false.2156:                                  ; preds = %lor.lhs.false.2140
  %346 = load i64, i64* %nargs, align 8
  %mul2157 = mul i64 %346, 8
  %cmp2158 = icmp ule i64 %mul2157, 9223372036854775807
  br i1 %cmp2158, label %cond.true.2160, label %cond.false.2162

cond.true.2160:                                   ; preds = %cond.false.2156
  %347 = load i64, i64* %nargs, align 8
  %mul2161 = mul i64 %347, 8
  br label %cond.end.2166

cond.false.2162:                                  ; preds = %cond.false.2156
  %348 = load i64, i64* %nargs, align 8
  %mul2163 = mul i64 %348, 8
  %sub2164 = sub i64 %mul2163, -9223372036854775808
  %add2165 = add nsw i64 %sub2164, -9223372036854775808
  br label %cond.end.2166

cond.end.2166:                                    ; preds = %cond.false.2162, %cond.true.2160
  %cond2167 = phi i64 [ %mul2161, %cond.true.2160 ], [ %add2165, %cond.false.2162 ]
  store i64 %cond2167, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2171, label %lor.lhs.false.2168

lor.lhs.false.2168:                               ; preds = %cond.end.2166, %cond.end.2154, %cond.end.1973, %cond.end.1961, %cond.end.1779, %cond.end.1767, %cond.end.1586, %cond.end.1574, %cond.end.1390, %cond.end.1374, %cond.end.1189, %cond.end.1173, %cond.end.961, %cond.end.938, %cond.end.746, %cond.end.723, %cond.end.476, %cond.end.453, %cond.end.261, %cond.end.238
  %349 = load i64, i64* %alloca_nbytes, align 8
  %cmp2169 = icmp ult i64 -1, %349
  br i1 %cmp2169, label %if.then.2171, label %if.else

if.then.2171:                                     ; preds = %lor.lhs.false.2168, %cond.end.2166, %cond.end.2154, %cond.end.1973, %cond.end.1961, %cond.end.1779, %cond.end.1767, %cond.end.1586, %cond.end.1574, %cond.end.1390, %cond.end.1374, %cond.end.1189, %cond.end.1173, %cond.end.961, %cond.end.938, %cond.end.746, %cond.end.723, %cond.end.476, %cond.end.453, %cond.end.261, %cond.end.238
  call void @memory_full(i64 -1) #8
  unreachable

if.else:                                          ; preds = %lor.lhs.false.2168
  %350 = load i64, i64* %alloca_nbytes, align 8
  %351 = load i64, i64* %sa_avail, align 8
  %cmp2172 = icmp sle i64 %350, %351
  br i1 %cmp2172, label %if.then.2174, label %if.else.2176

if.then.2174:                                     ; preds = %if.else
  %352 = load i64, i64* %alloca_nbytes, align 8
  %353 = load i64, i64* %sa_avail, align 8
  %sub2175 = sub nsw i64 %353, %352
  store i64 %sub2175, i64* %sa_avail, align 8
  %354 = load i64, i64* %alloca_nbytes, align 8
  %355 = alloca i8, i64 %354
  %356 = bitcast i8* %355 to i64*
  store i64* %356, i64** %args, align 8
  br label %if.end.2179

if.else.2176:                                     ; preds = %if.else
  %357 = load i64, i64* %alloca_nbytes, align 8
  %call2177 = call noalias i8* @xmalloc(i64 %357)
  %358 = bitcast i8* %call2177 to i64*
  store i64* %358, i64** %args, align 8
  %359 = load i64*, i64** %args, align 8
  %360 = load i64, i64* %nargs, align 8
  %call2178 = call i64 @make_save_memory(i64* %359, i64 %360)
  store i64 %call2178, i64* %arg_, align 8
  store i8 1, i8* %sa_must_free, align 1
  %361 = load i64, i64* %arg_, align 8
  call void @record_unwind_protect(void (i64)* @free_save_value, i64 %361)
  br label %if.end.2179

if.end.2179:                                      ; preds = %if.else.2176, %if.then.2174
  br label %if.end.2180

if.end.2180:                                      ; preds = %if.end.2179
  br label %do.end

do.end:                                           ; preds = %if.end.2180
  %362 = load i64, i64* %leni, align 8
  %363 = load i64*, i64** %args, align 8
  %364 = load i64, i64* %function.addr, align 8
  %365 = load i64, i64* %sequence.addr, align 8
  call void @mapcar1(i64 %362, i64* %363, i64 %364, i64 %365)
  %366 = load i64, i64* %leni, align 8
  %sub2181 = sub nsw i64 %366, 1
  store i64 %sub2181, i64* %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end
  %367 = load i64, i64* %i, align 8
  %cmp2182 = icmp sgt i64 %367, 0
  br i1 %cmp2182, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %368 = load i64, i64* %i, align 8
  %369 = load i64*, i64** %args, align 8
  %arrayidx = getelementptr inbounds i64, i64* %369, i64 %368
  %370 = load i64, i64* %arrayidx, align 8
  %371 = load i64, i64* %i, align 8
  %372 = load i64, i64* %i, align 8
  %add2184 = add nsw i64 %371, %372
  %373 = load i64*, i64** %args, align 8
  %arrayidx2185 = getelementptr inbounds i64, i64* %373, i64 %add2184
  store i64 %370, i64* %arrayidx2185, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %374 = load i64, i64* %i, align 8
  %dec = add nsw i64 %374, -1
  store i64 %dec, i64* %i, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i64 1, i64* %i, align 8
  br label %for.cond.2186

for.cond.2186:                                    ; preds = %for.inc.2191, %for.end
  %375 = load i64, i64* %i, align 8
  %376 = load i64, i64* %nargs, align 8
  %cmp2187 = icmp slt i64 %375, %376
  br i1 %cmp2187, label %for.body.2189, label %for.end.2193

for.body.2189:                                    ; preds = %for.cond.2186
  %377 = load i64, i64* %separator.addr, align 8
  %378 = load i64, i64* %i, align 8
  %379 = load i64*, i64** %args, align 8
  %arrayidx2190 = getelementptr inbounds i64, i64* %379, i64 %378
  store i64 %377, i64* %arrayidx2190, align 8
  br label %for.inc.2191

for.inc.2191:                                     ; preds = %for.body.2189
  %380 = load i64, i64* %i, align 8
  %add2192 = add nsw i64 %380, 2
  store i64 %add2192, i64* %i, align 8
  br label %for.cond.2186

for.end.2193:                                     ; preds = %for.cond.2186
  %381 = load i64, i64* %nargs, align 8
  %382 = load i64*, i64** %args, align 8
  %call2194 = call i64 @Fconcat(i64 %381, i64* %382)
  store i64 %call2194, i64* %ret, align 8
  br label %do.body.2195

do.body.2195:                                     ; preds = %for.end.2193
  %383 = load i8, i8* %sa_must_free, align 1
  %tobool = trunc i8 %383 to i1
  br i1 %tobool, label %if.then.2196, label %if.end.2199

if.then.2196:                                     ; preds = %do.body.2195
  store i8 0, i8* %sa_must_free, align 1
  %384 = load i64, i64* %sa_count, align 8
  %call2197 = call i64 @builtin_lisp_symbol(i32 0)
  %call2198 = call i64 @unbind_to(i64 %384, i64 %call2197)
  br label %if.end.2199

if.end.2199:                                      ; preds = %if.then.2196, %do.body.2195
  br label %do.end.2200

do.end.2200:                                      ; preds = %if.end.2199
  %385 = load i64, i64* %ret, align 8
  store i64 %385, i64* %retval
  br label %return

return:                                           ; preds = %do.end.2200, %if.then.4
  %386 = load i64, i64* %retval
  ret i64 %386
}

; Function Attrs: noreturn
declare void @memory_full(i64) #3

declare i64 @make_save_memory(i64*, i64) #2

declare void @record_unwind_protect(void (i64)*, i64) #2

declare void @free_save_value(i64) #2

; Function Attrs: nounwind uwtable
define internal void @mapcar1(i64 %leni, i64* %vals, i64 %fn, i64 %seq) #1 {
entry:
  %leni.addr = alloca i64, align 8
  %vals.addr = alloca i64*, align 8
  %fn.addr = alloca i64, align 8
  %seq.addr = alloca i64, align 8
  %tail = alloca i64, align 8
  %dummy = alloca i64, align 8
  %i = alloca i64, align 8
  %i_byte = alloca i64, align 8
  %c = alloca i32, align 4
  %i_before = alloca i64, align 8
  %chp = alloca i8*, align 8
  %chlen = alloca i32, align 4
  store i64 %leni, i64* %leni.addr, align 8
  store i64* %vals, i64** %vals.addr, align 8
  store i64 %fn, i64* %fn.addr, align 8
  store i64 %seq, i64* %seq.addr, align 8
  %0 = load i64, i64* %seq.addr, align 8
  %call = call zeroext i1 @VECTORP(i64 %0)
  br i1 %call, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i64, i64* %seq.addr, align 8
  %call1 = call zeroext i1 @COMPILEDP(i64 %1)
  br i1 %call1, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i64 0, i64* %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %2 = load i64, i64* %i, align 8
  %3 = load i64, i64* %leni.addr, align 8
  %cmp = icmp slt i64 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load i64, i64* %fn.addr, align 8
  %5 = load i64, i64* %seq.addr, align 8
  %6 = load i64, i64* %i, align 8
  %call2 = call i64 @AREF(i64 %5, i64 %6)
  %call3 = call i64 @call1(i64 %4, i64 %call2)
  store i64 %call3, i64* %dummy, align 8
  %7 = load i64*, i64** %vals.addr, align 8
  %tobool = icmp ne i64* %7, null
  br i1 %tobool, label %if.then.4, label %if.end

if.then.4:                                        ; preds = %for.body
  %8 = load i64, i64* %dummy, align 8
  %9 = load i64, i64* %i, align 8
  %10 = load i64*, i64** %vals.addr, align 8
  %arrayidx = getelementptr inbounds i64, i64* %10, i64 %9
  store i64 %8, i64* %arrayidx, align 8
  br label %if.end

if.end:                                           ; preds = %if.then.4, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %11 = load i64, i64* %i, align 8
  %inc = add nsw i64 %11, 1
  store i64 %inc, i64* %i, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end.110

if.else:                                          ; preds = %lor.lhs.false
  %12 = load i64, i64* %seq.addr, align 8
  %call5 = call zeroext i1 @BOOL_VECTOR_P(i64 %12)
  br i1 %call5, label %if.then.6, label %if.else.19

if.then.6:                                        ; preds = %if.else
  store i64 0, i64* %i, align 8
  br label %for.cond.7

for.cond.7:                                       ; preds = %for.inc.16, %if.then.6
  %13 = load i64, i64* %i, align 8
  %14 = load i64, i64* %leni.addr, align 8
  %cmp8 = icmp slt i64 %13, %14
  br i1 %cmp8, label %for.body.9, label %for.end.18

for.body.9:                                       ; preds = %for.cond.7
  %15 = load i64, i64* %fn.addr, align 8
  %16 = load i64, i64* %seq.addr, align 8
  %17 = load i64, i64* %i, align 8
  %call10 = call i64 @bool_vector_ref(i64 %16, i64 %17)
  %call11 = call i64 @call1(i64 %15, i64 %call10)
  store i64 %call11, i64* %dummy, align 8
  %18 = load i64*, i64** %vals.addr, align 8
  %tobool12 = icmp ne i64* %18, null
  br i1 %tobool12, label %if.then.13, label %if.end.15

if.then.13:                                       ; preds = %for.body.9
  %19 = load i64, i64* %dummy, align 8
  %20 = load i64, i64* %i, align 8
  %21 = load i64*, i64** %vals.addr, align 8
  %arrayidx14 = getelementptr inbounds i64, i64* %21, i64 %20
  store i64 %19, i64* %arrayidx14, align 8
  br label %if.end.15

if.end.15:                                        ; preds = %if.then.13, %for.body.9
  br label %for.inc.16

for.inc.16:                                       ; preds = %if.end.15
  %22 = load i64, i64* %i, align 8
  %inc17 = add nsw i64 %22, 1
  store i64 %inc17, i64* %i, align 8
  br label %for.cond.7

for.end.18:                                       ; preds = %for.cond.7
  br label %if.end.109

if.else.19:                                       ; preds = %if.else
  %23 = load i64, i64* %seq.addr, align 8
  %call20 = call zeroext i1 @STRINGP(i64 %23)
  br i1 %call20, label %if.then.21, label %if.else.90

if.then.21:                                       ; preds = %if.else.19
  store i64 0, i64* %i, align 8
  store i64 0, i64* %i_byte, align 8
  br label %for.cond.22

for.cond.22:                                      ; preds = %if.end.88, %if.then.21
  %24 = load i64, i64* %i, align 8
  %25 = load i64, i64* %leni.addr, align 8
  %cmp23 = icmp slt i64 %24, %25
  br i1 %cmp23, label %for.body.24, label %for.end.89

for.body.24:                                      ; preds = %for.cond.22
  %26 = load i64, i64* %i, align 8
  store i64 %26, i64* %i_before, align 8
  br label %do.body

do.body:                                          ; preds = %for.body.24
  %27 = load i64, i64* %i, align 8
  %inc25 = add nsw i64 %27, 1
  store i64 %inc25, i64* %i, align 8
  %28 = load i64, i64* %seq.addr, align 8
  %call26 = call zeroext i1 @STRING_MULTIBYTE(i64 %28)
  br i1 %call26, label %if.then.27, label %if.else.77

if.then.27:                                       ; preds = %do.body
  %29 = load i64, i64* %i_byte, align 8
  %30 = load i64, i64* %seq.addr, align 8
  %call28 = call i8* @SDATA(i64 %30)
  %arrayidx29 = getelementptr inbounds i8, i8* %call28, i64 %29
  store i8* %arrayidx29, i8** %chp, align 8
  %31 = load i8*, i8** %chp, align 8
  %arrayidx30 = getelementptr inbounds i8, i8* %31, i64 0
  %32 = load i8, i8* %arrayidx30, align 1
  %conv = zext i8 %32 to i32
  %and = and i32 %conv, 128
  %tobool31 = icmp ne i32 %and, 0
  br i1 %tobool31, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then.27
  store i32 1, i32* %chlen, align 4
  %33 = load i8*, i8** %chp, align 8
  %arrayidx32 = getelementptr inbounds i8, i8* %33, i64 0
  %34 = load i8, i8* %arrayidx32, align 1
  %conv33 = zext i8 %34 to i32
  br label %cond.end.73

cond.false:                                       ; preds = %if.then.27
  %35 = load i8*, i8** %chp, align 8
  %arrayidx34 = getelementptr inbounds i8, i8* %35, i64 0
  %36 = load i8, i8* %arrayidx34, align 1
  %conv35 = zext i8 %36 to i32
  %and36 = and i32 %conv35, 32
  %tobool37 = icmp ne i32 %and36, 0
  br i1 %tobool37, label %cond.false.49, label %cond.true.38

cond.true.38:                                     ; preds = %cond.false
  store i32 2, i32* %chlen, align 4
  %37 = load i8*, i8** %chp, align 8
  %arrayidx39 = getelementptr inbounds i8, i8* %37, i64 0
  %38 = load i8, i8* %arrayidx39, align 1
  %conv40 = zext i8 %38 to i32
  %and41 = and i32 %conv40, 31
  %shl = shl i32 %and41, 6
  %39 = load i8*, i8** %chp, align 8
  %arrayidx42 = getelementptr inbounds i8, i8* %39, i64 1
  %40 = load i8, i8* %arrayidx42, align 1
  %conv43 = zext i8 %40 to i32
  %and44 = and i32 %conv43, 63
  %or = or i32 %shl, %and44
  %41 = load i8*, i8** %chp, align 8
  %arrayidx45 = getelementptr inbounds i8, i8* %41, i64 0
  %42 = load i8, i8* %arrayidx45, align 1
  %conv46 = zext i8 %42 to i32
  %cmp47 = icmp slt i32 %conv46, 194
  %cond = select i1 %cmp47, i32 4194176, i32 0
  %add = add nsw i32 %or, %cond
  br label %cond.end.71

cond.false.49:                                    ; preds = %cond.false
  %43 = load i8*, i8** %chp, align 8
  %arrayidx50 = getelementptr inbounds i8, i8* %43, i64 0
  %44 = load i8, i8* %arrayidx50, align 1
  %conv51 = zext i8 %44 to i32
  %and52 = and i32 %conv51, 16
  %tobool53 = icmp ne i32 %and52, 0
  br i1 %tobool53, label %cond.false.68, label %cond.true.54

cond.true.54:                                     ; preds = %cond.false.49
  store i32 3, i32* %chlen, align 4
  %45 = load i8*, i8** %chp, align 8
  %arrayidx55 = getelementptr inbounds i8, i8* %45, i64 0
  %46 = load i8, i8* %arrayidx55, align 1
  %conv56 = zext i8 %46 to i32
  %and57 = and i32 %conv56, 15
  %shl58 = shl i32 %and57, 12
  %47 = load i8*, i8** %chp, align 8
  %arrayidx59 = getelementptr inbounds i8, i8* %47, i64 1
  %48 = load i8, i8* %arrayidx59, align 1
  %conv60 = zext i8 %48 to i32
  %and61 = and i32 %conv60, 63
  %shl62 = shl i32 %and61, 6
  %or63 = or i32 %shl58, %shl62
  %49 = load i8*, i8** %chp, align 8
  %arrayidx64 = getelementptr inbounds i8, i8* %49, i64 2
  %50 = load i8, i8* %arrayidx64, align 1
  %conv65 = zext i8 %50 to i32
  %and66 = and i32 %conv65, 63
  %or67 = or i32 %or63, %and66
  br label %cond.end

cond.false.68:                                    ; preds = %cond.false.49
  %51 = load i8*, i8** %chp, align 8
  %call69 = call i32 @string_char(i8* %51, i8** null, i32* %chlen)
  br label %cond.end

cond.end:                                         ; preds = %cond.false.68, %cond.true.54
  %cond70 = phi i32 [ %or67, %cond.true.54 ], [ %call69, %cond.false.68 ]
  br label %cond.end.71

cond.end.71:                                      ; preds = %cond.end, %cond.true.38
  %cond72 = phi i32 [ %add, %cond.true.38 ], [ %cond70, %cond.end ]
  br label %cond.end.73

cond.end.73:                                      ; preds = %cond.end.71, %cond.true
  %cond74 = phi i32 [ %conv33, %cond.true ], [ %cond72, %cond.end.71 ]
  store i32 %cond74, i32* %c, align 4
  %52 = load i32, i32* %chlen, align 4
  %conv75 = sext i32 %52 to i64
  %53 = load i64, i64* %i_byte, align 8
  %add76 = add nsw i64 %53, %conv75
  store i64 %add76, i64* %i_byte, align 8
  br label %if.end.81

if.else.77:                                       ; preds = %do.body
  %54 = load i64, i64* %seq.addr, align 8
  %55 = load i64, i64* %i_byte, align 8
  %call78 = call zeroext i8 @SREF(i64 %54, i64 %55)
  %conv79 = zext i8 %call78 to i32
  store i32 %conv79, i32* %c, align 4
  %56 = load i64, i64* %i_byte, align 8
  %inc80 = add nsw i64 %56, 1
  store i64 %inc80, i64* %i_byte, align 8
  br label %if.end.81

if.end.81:                                        ; preds = %if.else.77, %cond.end.73
  br label %do.end

do.end:                                           ; preds = %if.end.81
  %57 = load i32, i32* %c, align 4
  %conv82 = sext i32 %57 to i64
  %call83 = call i64 @make_natnum(i64 %conv82)
  store i64 %call83, i64* %dummy, align 8
  %58 = load i64, i64* %fn.addr, align 8
  %59 = load i64, i64* %dummy, align 8
  %call84 = call i64 @call1(i64 %58, i64 %59)
  store i64 %call84, i64* %dummy, align 8
  %60 = load i64*, i64** %vals.addr, align 8
  %tobool85 = icmp ne i64* %60, null
  br i1 %tobool85, label %if.then.86, label %if.end.88

if.then.86:                                       ; preds = %do.end
  %61 = load i64, i64* %dummy, align 8
  %62 = load i64, i64* %i_before, align 8
  %63 = load i64*, i64** %vals.addr, align 8
  %arrayidx87 = getelementptr inbounds i64, i64* %63, i64 %62
  store i64 %61, i64* %arrayidx87, align 8
  br label %if.end.88

if.end.88:                                        ; preds = %if.then.86, %do.end
  br label %for.cond.22

for.end.89:                                       ; preds = %for.cond.22
  br label %if.end.108

if.else.90:                                       ; preds = %if.else.19
  %64 = load i64, i64* %seq.addr, align 8
  store i64 %64, i64* %tail, align 8
  store i64 0, i64* %i, align 8
  br label %for.cond.91

for.cond.91:                                      ; preds = %for.inc.105, %if.else.90
  %65 = load i64, i64* %i, align 8
  %66 = load i64, i64* %leni.addr, align 8
  %cmp92 = icmp slt i64 %65, %66
  br i1 %cmp92, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond.91
  %67 = load i64, i64* %tail, align 8
  %and94 = and i64 %67, 7
  %conv95 = trunc i64 %and94 to i32
  %cmp96 = icmp eq i32 %conv95, 3
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond.91
  %68 = phi i1 [ false, %for.cond.91 ], [ %cmp96, %land.rhs ]
  br i1 %68, label %for.body.98, label %for.end.107

for.body.98:                                      ; preds = %land.end
  %69 = load i64, i64* %fn.addr, align 8
  %70 = load i64, i64* %tail, align 8
  %sub = sub nsw i64 %70, 3
  %71 = inttoptr i64 %sub to i8*
  %72 = bitcast i8* %71 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %72, i32 0, i32 0
  %73 = load i64, i64* %car, align 8
  %call99 = call i64 @call1(i64 %69, i64 %73)
  store i64 %call99, i64* %dummy, align 8
  %74 = load i64*, i64** %vals.addr, align 8
  %tobool100 = icmp ne i64* %74, null
  br i1 %tobool100, label %if.then.101, label %if.end.103

if.then.101:                                      ; preds = %for.body.98
  %75 = load i64, i64* %dummy, align 8
  %76 = load i64, i64* %i, align 8
  %77 = load i64*, i64** %vals.addr, align 8
  %arrayidx102 = getelementptr inbounds i64, i64* %77, i64 %76
  store i64 %75, i64* %arrayidx102, align 8
  br label %if.end.103

if.end.103:                                       ; preds = %if.then.101, %for.body.98
  %78 = load i64, i64* %tail, align 8
  %sub104 = sub nsw i64 %78, 3
  %79 = inttoptr i64 %sub104 to i8*
  %80 = bitcast i8* %79 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %80, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %81 = load i64, i64* %cdr, align 8
  store i64 %81, i64* %tail, align 8
  br label %for.inc.105

for.inc.105:                                      ; preds = %if.end.103
  %82 = load i64, i64* %i, align 8
  %inc106 = add nsw i64 %82, 1
  store i64 %inc106, i64* %i, align 8
  br label %for.cond.91

for.end.107:                                      ; preds = %land.end
  br label %if.end.108

if.end.108:                                       ; preds = %for.end.107, %for.end.89
  br label %if.end.109

if.end.109:                                       ; preds = %if.end.108, %for.end.18
  br label %if.end.110

if.end.110:                                       ; preds = %if.end.109, %for.end
  ret void
}

; Function Attrs: nounwind uwtable
define i64 @Fmapcar(i64 %function, i64 %sequence) #1 {
entry:
  %function.addr = alloca i64, align 8
  %sequence.addr = alloca i64, align 8
  %len = alloca i64, align 8
  %leni = alloca i64, align 8
  %args = alloca i64*, align 8
  %ret = alloca i64, align 8
  %sa_avail = alloca i64, align 8
  %sa_count = alloca i64, align 8
  %sa_must_free = alloca i8, align 1
  %alloca_nbytes = alloca i64, align 8
  %arg_ = alloca i64, align 8
  store i64 %function, i64* %function.addr, align 8
  store i64 %sequence, i64* %sequence.addr, align 8
  store i64 16384, i64* %sa_avail, align 8
  %call = call i64 @SPECPDL_INDEX()
  store i64 %call, i64* %sa_count, align 8
  store i8 0, i8* %sa_must_free, align 1
  %0 = load i64, i64* %sequence.addr, align 8
  %call1 = call i64 @Flength(i64 %0)
  store i64 %call1, i64* %len, align 8
  %1 = load i64, i64* %sequence.addr, align 8
  %call2 = call zeroext i1 @CHAR_TABLE_P(i64 %1)
  br i1 %call2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call3 = call i64 @builtin_lisp_symbol(i32 626)
  %2 = load i64, i64* %sequence.addr, align 8
  %3 = call i64 @wrong_type_argument(i64 %call3, i64 %2) #8
  unreachable

if.end:                                           ; preds = %entry
  %4 = load i64, i64* %len, align 8
  %shr = ashr i64 %4, 2
  store i64 %shr, i64* %leni, align 8
  br label %do.body

do.body:                                          ; preds = %if.end
  br i1 false, label %cond.true, label %cond.false.474

cond.true:                                        ; preds = %do.body
  br i1 false, label %cond.true.4, label %cond.false.259

cond.true.4:                                      ; preds = %cond.true
  %5 = load i64, i64* %leni, align 8
  %conv = trunc i64 %5 to i8
  %conv5 = sext i8 %conv to i32
  %add = add nsw i32 0, %conv5
  %mul = mul nsw i32 0, %add
  %sub = sub nsw i32 %mul, 1
  %cmp = icmp slt i32 %sub, 0
  br i1 %cmp, label %cond.true.7, label %cond.false

cond.true.7:                                      ; preds = %cond.true.4
  %6 = load i64, i64* %leni, align 8
  %conv8 = trunc i64 %6 to i8
  %conv9 = sext i8 %conv8 to i32
  %add10 = add nsw i32 0, %conv9
  %mul11 = mul nsw i32 0, %add10
  %add12 = add nsw i32 %mul11, 0
  %neg = xor i32 %add12, -1
  %cmp13 = icmp eq i32 %neg, -1
  %conv14 = zext i1 %cmp13 to i32
  %sub15 = sub nsw i32 0, %conv14
  %7 = load i64, i64* %leni, align 8
  %conv16 = trunc i64 %7 to i8
  %conv17 = sext i8 %conv16 to i32
  %add18 = add nsw i32 0, %conv17
  %mul19 = mul nsw i32 0, %add18
  %add20 = add nsw i32 %mul19, 1
  %shl = shl i32 %add20, 30
  %sub21 = sub nsw i32 %shl, 1
  %mul22 = mul nsw i32 %sub21, 2
  %add23 = add nsw i32 %mul22, 1
  %sub24 = sub nsw i32 %sub15, %add23
  br label %cond.end

cond.false:                                       ; preds = %cond.true.4
  %8 = load i64, i64* %leni, align 8
  %conv25 = trunc i64 %8 to i8
  %conv26 = sext i8 %conv25 to i32
  %add27 = add nsw i32 0, %conv26
  %mul28 = mul nsw i32 0, %add27
  %add29 = add nsw i32 %mul28, 0
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true.7
  %cond = phi i32 [ %sub24, %cond.true.7 ], [ %add29, %cond.false ]
  %cmp30 = icmp eq i32 %cond, 0
  br i1 %cmp30, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %cond.end
  %9 = load i64, i64* %leni, align 8
  %conv32 = trunc i64 %9 to i8
  %conv33 = sext i8 %conv32 to i32
  %cmp34 = icmp slt i32 %conv33, 0
  br i1 %cmp34, label %cond.true.213, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %cond.end
  br i1 false, label %cond.true.36, label %cond.false.114

cond.true.36:                                     ; preds = %lor.lhs.false
  %10 = load i64, i64* %leni, align 8
  %conv37 = trunc i64 %10 to i8
  %conv38 = sext i8 %conv37 to i32
  %cmp39 = icmp slt i32 %conv38, 0
  br i1 %cmp39, label %cond.true.41, label %cond.false.71

cond.true.41:                                     ; preds = %cond.true.36
  %11 = load i64, i64* %leni, align 8
  %conv42 = trunc i64 %11 to i8
  %conv43 = sext i8 %conv42 to i32
  %12 = load i64, i64* %leni, align 8
  %conv44 = trunc i64 %12 to i8
  %conv45 = sext i8 %conv44 to i32
  %add46 = add nsw i32 0, %conv45
  %mul47 = mul nsw i32 0, %add46
  %sub48 = sub nsw i32 %mul47, 1
  %cmp49 = icmp slt i32 %sub48, 0
  br i1 %cmp49, label %cond.true.51, label %cond.false.61

cond.true.51:                                     ; preds = %cond.true.41
  %13 = load i64, i64* %leni, align 8
  %conv52 = trunc i64 %13 to i8
  %conv53 = sext i8 %conv52 to i32
  %add54 = add nsw i32 0, %conv53
  %mul55 = mul nsw i32 0, %add54
  %add56 = add nsw i32 %mul55, 1
  %shl57 = shl i32 %add56, 30
  %sub58 = sub nsw i32 %shl57, 1
  %mul59 = mul nsw i32 %sub58, 2
  %add60 = add nsw i32 %mul59, 1
  br label %cond.end.67

cond.false.61:                                    ; preds = %cond.true.41
  %14 = load i64, i64* %leni, align 8
  %conv62 = trunc i64 %14 to i8
  %conv63 = sext i8 %conv62 to i32
  %add64 = add nsw i32 0, %conv63
  %mul65 = mul nsw i32 0, %add64
  %sub66 = sub nsw i32 %mul65, 1
  br label %cond.end.67

cond.end.67:                                      ; preds = %cond.false.61, %cond.true.51
  %cond68 = phi i32 [ %add60, %cond.true.51 ], [ %sub66, %cond.false.61 ]
  %div = sdiv i32 %cond68, 8
  %cmp69 = icmp slt i32 %conv43, %div
  br i1 %cmp69, label %cond.true.213, label %lor.lhs.false.193

cond.false.71:                                    ; preds = %cond.true.36
  br i1 false, label %cond.true.72, label %cond.false.73

cond.true.72:                                     ; preds = %cond.false.71
  br i1 false, label %cond.true.213, label %lor.lhs.false.193

cond.false.73:                                    ; preds = %cond.false.71
  %15 = load i64, i64* %leni, align 8
  %conv74 = trunc i64 %15 to i8
  %conv75 = sext i8 %conv74 to i32
  %add76 = add nsw i32 0, %conv75
  %mul77 = mul nsw i32 0, %add76
  %sub78 = sub nsw i32 %mul77, 1
  %cmp79 = icmp slt i32 %sub78, 0
  br i1 %cmp79, label %cond.true.81, label %cond.false.101

cond.true.81:                                     ; preds = %cond.false.73
  %16 = load i64, i64* %leni, align 8
  %conv82 = trunc i64 %16 to i8
  %conv83 = sext i8 %conv82 to i32
  %add84 = add nsw i32 0, %conv83
  %mul85 = mul nsw i32 0, %add84
  %add86 = add nsw i32 %mul85, 0
  %neg87 = xor i32 %add86, -1
  %cmp88 = icmp eq i32 %neg87, -1
  %conv89 = zext i1 %cmp88 to i32
  %sub90 = sub nsw i32 0, %conv89
  %17 = load i64, i64* %leni, align 8
  %conv91 = trunc i64 %17 to i8
  %conv92 = sext i8 %conv91 to i32
  %add93 = add nsw i32 0, %conv92
  %mul94 = mul nsw i32 0, %add93
  %add95 = add nsw i32 %mul94, 1
  %shl96 = shl i32 %add95, 30
  %sub97 = sub nsw i32 %shl96, 1
  %mul98 = mul nsw i32 %sub97, 2
  %add99 = add nsw i32 %mul98, 1
  %sub100 = sub nsw i32 %sub90, %add99
  br label %cond.end.107

cond.false.101:                                   ; preds = %cond.false.73
  %18 = load i64, i64* %leni, align 8
  %conv102 = trunc i64 %18 to i8
  %conv103 = sext i8 %conv102 to i32
  %add104 = add nsw i32 0, %conv103
  %mul105 = mul nsw i32 0, %add104
  %add106 = add nsw i32 %mul105, 0
  br label %cond.end.107

cond.end.107:                                     ; preds = %cond.false.101, %cond.true.81
  %cond108 = phi i32 [ %sub100, %cond.true.81 ], [ %add106, %cond.false.101 ]
  %div109 = sdiv i32 %cond108, 8
  %19 = load i64, i64* %leni, align 8
  %conv110 = trunc i64 %19 to i8
  %conv111 = sext i8 %conv110 to i32
  %cmp112 = icmp slt i32 %div109, %conv111
  br i1 %cmp112, label %cond.true.213, label %lor.lhs.false.193

cond.false.114:                                   ; preds = %lor.lhs.false
  br i1 false, label %cond.true.115, label %cond.false.116

cond.true.115:                                    ; preds = %cond.false.114
  br i1 false, label %cond.true.213, label %lor.lhs.false.193

cond.false.116:                                   ; preds = %cond.false.114
  %20 = load i64, i64* %leni, align 8
  %conv117 = trunc i64 %20 to i8
  %conv118 = sext i8 %conv117 to i32
  %cmp119 = icmp slt i32 %conv118, 0
  br i1 %cmp119, label %cond.true.121, label %cond.false.162

cond.true.121:                                    ; preds = %cond.false.116
  %21 = load i64, i64* %leni, align 8
  %conv122 = trunc i64 %21 to i8
  %conv123 = sext i8 %conv122 to i32
  %22 = load i64, i64* %leni, align 8
  %conv124 = trunc i64 %22 to i8
  %conv125 = sext i8 %conv124 to i32
  %add126 = add nsw i32 0, %conv125
  %mul127 = mul nsw i32 0, %add126
  %sub128 = sub nsw i32 %mul127, 1
  %cmp129 = icmp slt i32 %sub128, 0
  br i1 %cmp129, label %cond.true.131, label %cond.false.151

cond.true.131:                                    ; preds = %cond.true.121
  %23 = load i64, i64* %leni, align 8
  %conv132 = trunc i64 %23 to i8
  %conv133 = sext i8 %conv132 to i32
  %add134 = add nsw i32 0, %conv133
  %mul135 = mul nsw i32 0, %add134
  %add136 = add nsw i32 %mul135, 0
  %neg137 = xor i32 %add136, -1
  %cmp138 = icmp eq i32 %neg137, -1
  %conv139 = zext i1 %cmp138 to i32
  %sub140 = sub nsw i32 0, %conv139
  %24 = load i64, i64* %leni, align 8
  %conv141 = trunc i64 %24 to i8
  %conv142 = sext i8 %conv141 to i32
  %add143 = add nsw i32 0, %conv142
  %mul144 = mul nsw i32 0, %add143
  %add145 = add nsw i32 %mul144, 1
  %shl146 = shl i32 %add145, 30
  %sub147 = sub nsw i32 %shl146, 1
  %mul148 = mul nsw i32 %sub147, 2
  %add149 = add nsw i32 %mul148, 1
  %sub150 = sub nsw i32 %sub140, %add149
  br label %cond.end.157

cond.false.151:                                   ; preds = %cond.true.121
  %25 = load i64, i64* %leni, align 8
  %conv152 = trunc i64 %25 to i8
  %conv153 = sext i8 %conv152 to i32
  %add154 = add nsw i32 0, %conv153
  %mul155 = mul nsw i32 0, %add154
  %add156 = add nsw i32 %mul155, 0
  br label %cond.end.157

cond.end.157:                                     ; preds = %cond.false.151, %cond.true.131
  %cond158 = phi i32 [ %sub150, %cond.true.131 ], [ %add156, %cond.false.151 ]
  %div159 = sdiv i32 %cond158, 8
  %cmp160 = icmp slt i32 %conv123, %div159
  br i1 %cmp160, label %cond.true.213, label %lor.lhs.false.193

cond.false.162:                                   ; preds = %cond.false.116
  %26 = load i64, i64* %leni, align 8
  %conv163 = trunc i64 %26 to i8
  %conv164 = sext i8 %conv163 to i32
  %add165 = add nsw i32 0, %conv164
  %mul166 = mul nsw i32 0, %add165
  %sub167 = sub nsw i32 %mul166, 1
  %cmp168 = icmp slt i32 %sub167, 0
  br i1 %cmp168, label %cond.true.170, label %cond.false.180

cond.true.170:                                    ; preds = %cond.false.162
  %27 = load i64, i64* %leni, align 8
  %conv171 = trunc i64 %27 to i8
  %conv172 = sext i8 %conv171 to i32
  %add173 = add nsw i32 0, %conv172
  %mul174 = mul nsw i32 0, %add173
  %add175 = add nsw i32 %mul174, 1
  %shl176 = shl i32 %add175, 30
  %sub177 = sub nsw i32 %shl176, 1
  %mul178 = mul nsw i32 %sub177, 2
  %add179 = add nsw i32 %mul178, 1
  br label %cond.end.186

cond.false.180:                                   ; preds = %cond.false.162
  %28 = load i64, i64* %leni, align 8
  %conv181 = trunc i64 %28 to i8
  %conv182 = sext i8 %conv181 to i32
  %add183 = add nsw i32 0, %conv182
  %mul184 = mul nsw i32 0, %add183
  %sub185 = sub nsw i32 %mul184, 1
  br label %cond.end.186

cond.end.186:                                     ; preds = %cond.false.180, %cond.true.170
  %cond187 = phi i32 [ %add179, %cond.true.170 ], [ %sub185, %cond.false.180 ]
  %div188 = sdiv i32 %cond187, 8
  %29 = load i64, i64* %leni, align 8
  %conv189 = trunc i64 %29 to i8
  %conv190 = sext i8 %conv189 to i32
  %cmp191 = icmp slt i32 %div188, %conv190
  br i1 %cmp191, label %cond.true.213, label %lor.lhs.false.193

lor.lhs.false.193:                                ; preds = %cond.end.186, %cond.end.157, %cond.true.115, %cond.end.107, %cond.true.72, %cond.end.67
  %30 = load i64, i64* %leni, align 8
  %conv194 = trunc i64 %30 to i8
  %conv195 = sext i8 %conv194 to i32
  %mul196 = mul nsw i32 %conv195, 8
  %mul197 = mul nsw i32 0, %mul196
  %sub198 = sub nsw i32 %mul197, 1
  %cmp199 = icmp slt i32 %sub198, 0
  br i1 %cmp199, label %land.lhs.true.201, label %lor.lhs.false.207

land.lhs.true.201:                                ; preds = %lor.lhs.false.193
  %31 = load i64, i64* %leni, align 8
  %conv202 = trunc i64 %31 to i8
  %conv203 = sext i8 %conv202 to i32
  %mul204 = mul nsw i32 %conv203, 8
  %cmp205 = icmp slt i32 %mul204, -128
  br i1 %cmp205, label %cond.true.213, label %lor.lhs.false.207

lor.lhs.false.207:                                ; preds = %land.lhs.true.201, %lor.lhs.false.193
  %32 = load i64, i64* %leni, align 8
  %conv208 = trunc i64 %32 to i8
  %conv209 = sext i8 %conv208 to i32
  %mul210 = mul nsw i32 %conv209, 8
  %cmp211 = icmp slt i32 127, %mul210
  br i1 %cmp211, label %cond.true.213, label %cond.false.236

cond.true.213:                                    ; preds = %lor.lhs.false.207, %land.lhs.true.201, %cond.end.186, %cond.end.157, %cond.true.115, %cond.end.107, %cond.true.72, %cond.end.67, %land.lhs.true
  %33 = load i64, i64* %leni, align 8
  %conv214 = trunc i64 %33 to i8
  %conv215 = zext i8 %conv214 to i32
  %mul216 = mul nsw i32 %conv215, 8
  %cmp217 = icmp sle i32 %mul216, 127
  br i1 %cmp217, label %cond.true.219, label %cond.false.225

cond.true.219:                                    ; preds = %cond.true.213
  %34 = load i64, i64* %leni, align 8
  %conv220 = trunc i64 %34 to i8
  %conv221 = zext i8 %conv220 to i32
  %mul222 = mul nsw i32 %conv221, 8
  %conv223 = trunc i32 %mul222 to i8
  %conv224 = sext i8 %conv223 to i32
  br label %cond.end.233

cond.false.225:                                   ; preds = %cond.true.213
  %35 = load i64, i64* %leni, align 8
  %conv226 = trunc i64 %35 to i8
  %conv227 = zext i8 %conv226 to i32
  %mul228 = mul nsw i32 %conv227, 8
  %sub229 = sub nsw i32 %mul228, -128
  %conv230 = trunc i32 %sub229 to i8
  %conv231 = sext i8 %conv230 to i32
  %add232 = add nsw i32 %conv231, -128
  br label %cond.end.233

cond.end.233:                                     ; preds = %cond.false.225, %cond.true.219
  %cond234 = phi i32 [ %conv224, %cond.true.219 ], [ %add232, %cond.false.225 ]
  %conv235 = sext i32 %cond234 to i64
  store i64 %conv235, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2166, label %lor.lhs.false.2163

cond.false.236:                                   ; preds = %lor.lhs.false.207
  %36 = load i64, i64* %leni, align 8
  %conv237 = trunc i64 %36 to i8
  %conv238 = zext i8 %conv237 to i32
  %mul239 = mul nsw i32 %conv238, 8
  %cmp240 = icmp sle i32 %mul239, 127
  br i1 %cmp240, label %cond.true.242, label %cond.false.248

cond.true.242:                                    ; preds = %cond.false.236
  %37 = load i64, i64* %leni, align 8
  %conv243 = trunc i64 %37 to i8
  %conv244 = zext i8 %conv243 to i32
  %mul245 = mul nsw i32 %conv244, 8
  %conv246 = trunc i32 %mul245 to i8
  %conv247 = sext i8 %conv246 to i32
  br label %cond.end.256

cond.false.248:                                   ; preds = %cond.false.236
  %38 = load i64, i64* %leni, align 8
  %conv249 = trunc i64 %38 to i8
  %conv250 = zext i8 %conv249 to i32
  %mul251 = mul nsw i32 %conv250, 8
  %sub252 = sub nsw i32 %mul251, -128
  %conv253 = trunc i32 %sub252 to i8
  %conv254 = sext i8 %conv253 to i32
  %add255 = add nsw i32 %conv254, -128
  br label %cond.end.256

cond.end.256:                                     ; preds = %cond.false.248, %cond.true.242
  %cond257 = phi i32 [ %conv247, %cond.true.242 ], [ %add255, %cond.false.248 ]
  %conv258 = sext i32 %cond257 to i64
  store i64 %conv258, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2166, label %lor.lhs.false.2163

cond.false.259:                                   ; preds = %cond.true
  %39 = load i64, i64* %leni, align 8
  %add260 = add nsw i64 0, %39
  %mul261 = mul nsw i64 0, %add260
  %sub262 = sub nsw i64 %mul261, 1
  %cmp263 = icmp slt i64 %sub262, 0
  br i1 %cmp263, label %cond.true.265, label %cond.false.282

cond.true.265:                                    ; preds = %cond.false.259
  %40 = load i64, i64* %leni, align 8
  %add266 = add nsw i64 0, %40
  %mul267 = mul nsw i64 0, %add266
  %add268 = add nsw i64 %mul267, 0
  %neg269 = xor i64 %add268, -1
  %cmp270 = icmp eq i64 %neg269, -1
  %conv271 = zext i1 %cmp270 to i32
  %sub272 = sub nsw i32 0, %conv271
  %conv273 = sext i32 %sub272 to i64
  %41 = load i64, i64* %leni, align 8
  %add274 = add nsw i64 0, %41
  %mul275 = mul nsw i64 0, %add274
  %add276 = add nsw i64 %mul275, 1
  %shl277 = shl i64 %add276, 62
  %sub278 = sub nsw i64 %shl277, 1
  %mul279 = mul nsw i64 %sub278, 2
  %add280 = add nsw i64 %mul279, 1
  %sub281 = sub nsw i64 %conv273, %add280
  br label %cond.end.286

cond.false.282:                                   ; preds = %cond.false.259
  %42 = load i64, i64* %leni, align 8
  %add283 = add nsw i64 0, %42
  %mul284 = mul nsw i64 0, %add283
  %add285 = add nsw i64 %mul284, 0
  br label %cond.end.286

cond.end.286:                                     ; preds = %cond.false.282, %cond.true.265
  %cond287 = phi i64 [ %sub281, %cond.true.265 ], [ %add285, %cond.false.282 ]
  %cmp288 = icmp eq i64 %cond287, 0
  br i1 %cmp288, label %land.lhs.true.290, label %lor.lhs.false.293

land.lhs.true.290:                                ; preds = %cond.end.286
  %43 = load i64, i64* %leni, align 8
  %cmp291 = icmp slt i64 %43, 0
  br i1 %cmp291, label %cond.true.428, label %lor.lhs.false.293

lor.lhs.false.293:                                ; preds = %land.lhs.true.290, %cond.end.286
  br i1 false, label %cond.true.294, label %cond.false.354

cond.true.294:                                    ; preds = %lor.lhs.false.293
  %44 = load i64, i64* %leni, align 8
  %cmp295 = icmp slt i64 %44, 0
  br i1 %cmp295, label %cond.true.297, label %cond.false.320

cond.true.297:                                    ; preds = %cond.true.294
  %45 = load i64, i64* %leni, align 8
  %46 = load i64, i64* %leni, align 8
  %add298 = add nsw i64 0, %46
  %mul299 = mul nsw i64 0, %add298
  %sub300 = sub nsw i64 %mul299, 1
  %cmp301 = icmp slt i64 %sub300, 0
  br i1 %cmp301, label %cond.true.303, label %cond.false.311

cond.true.303:                                    ; preds = %cond.true.297
  %47 = load i64, i64* %leni, align 8
  %add304 = add nsw i64 0, %47
  %mul305 = mul nsw i64 0, %add304
  %add306 = add nsw i64 %mul305, 1
  %shl307 = shl i64 %add306, 62
  %sub308 = sub nsw i64 %shl307, 1
  %mul309 = mul nsw i64 %sub308, 2
  %add310 = add nsw i64 %mul309, 1
  br label %cond.end.315

cond.false.311:                                   ; preds = %cond.true.297
  %48 = load i64, i64* %leni, align 8
  %add312 = add nsw i64 0, %48
  %mul313 = mul nsw i64 0, %add312
  %sub314 = sub nsw i64 %mul313, 1
  br label %cond.end.315

cond.end.315:                                     ; preds = %cond.false.311, %cond.true.303
  %cond316 = phi i64 [ %add310, %cond.true.303 ], [ %sub314, %cond.false.311 ]
  %div317 = sdiv i64 %cond316, 8
  %cmp318 = icmp slt i64 %45, %div317
  br i1 %cmp318, label %cond.true.428, label %lor.lhs.false.414

cond.false.320:                                   ; preds = %cond.true.294
  br i1 false, label %cond.true.321, label %cond.false.322

cond.true.321:                                    ; preds = %cond.false.320
  br i1 false, label %cond.true.428, label %lor.lhs.false.414

cond.false.322:                                   ; preds = %cond.false.320
  %49 = load i64, i64* %leni, align 8
  %add323 = add nsw i64 0, %49
  %mul324 = mul nsw i64 0, %add323
  %sub325 = sub nsw i64 %mul324, 1
  %cmp326 = icmp slt i64 %sub325, 0
  br i1 %cmp326, label %cond.true.328, label %cond.false.345

cond.true.328:                                    ; preds = %cond.false.322
  %50 = load i64, i64* %leni, align 8
  %add329 = add nsw i64 0, %50
  %mul330 = mul nsw i64 0, %add329
  %add331 = add nsw i64 %mul330, 0
  %neg332 = xor i64 %add331, -1
  %cmp333 = icmp eq i64 %neg332, -1
  %conv334 = zext i1 %cmp333 to i32
  %sub335 = sub nsw i32 0, %conv334
  %conv336 = sext i32 %sub335 to i64
  %51 = load i64, i64* %leni, align 8
  %add337 = add nsw i64 0, %51
  %mul338 = mul nsw i64 0, %add337
  %add339 = add nsw i64 %mul338, 1
  %shl340 = shl i64 %add339, 62
  %sub341 = sub nsw i64 %shl340, 1
  %mul342 = mul nsw i64 %sub341, 2
  %add343 = add nsw i64 %mul342, 1
  %sub344 = sub nsw i64 %conv336, %add343
  br label %cond.end.349

cond.false.345:                                   ; preds = %cond.false.322
  %52 = load i64, i64* %leni, align 8
  %add346 = add nsw i64 0, %52
  %mul347 = mul nsw i64 0, %add346
  %add348 = add nsw i64 %mul347, 0
  br label %cond.end.349

cond.end.349:                                     ; preds = %cond.false.345, %cond.true.328
  %cond350 = phi i64 [ %sub344, %cond.true.328 ], [ %add348, %cond.false.345 ]
  %div351 = sdiv i64 %cond350, 8
  %53 = load i64, i64* %leni, align 8
  %cmp352 = icmp slt i64 %div351, %53
  br i1 %cmp352, label %cond.true.428, label %lor.lhs.false.414

cond.false.354:                                   ; preds = %lor.lhs.false.293
  br i1 false, label %cond.true.355, label %cond.false.356

cond.true.355:                                    ; preds = %cond.false.354
  br i1 false, label %cond.true.428, label %lor.lhs.false.414

cond.false.356:                                   ; preds = %cond.false.354
  %54 = load i64, i64* %leni, align 8
  %cmp357 = icmp slt i64 %54, 0
  br i1 %cmp357, label %cond.true.359, label %cond.false.391

cond.true.359:                                    ; preds = %cond.false.356
  %55 = load i64, i64* %leni, align 8
  %56 = load i64, i64* %leni, align 8
  %add360 = add nsw i64 0, %56
  %mul361 = mul nsw i64 0, %add360
  %sub362 = sub nsw i64 %mul361, 1
  %cmp363 = icmp slt i64 %sub362, 0
  br i1 %cmp363, label %cond.true.365, label %cond.false.382

cond.true.365:                                    ; preds = %cond.true.359
  %57 = load i64, i64* %leni, align 8
  %add366 = add nsw i64 0, %57
  %mul367 = mul nsw i64 0, %add366
  %add368 = add nsw i64 %mul367, 0
  %neg369 = xor i64 %add368, -1
  %cmp370 = icmp eq i64 %neg369, -1
  %conv371 = zext i1 %cmp370 to i32
  %sub372 = sub nsw i32 0, %conv371
  %conv373 = sext i32 %sub372 to i64
  %58 = load i64, i64* %leni, align 8
  %add374 = add nsw i64 0, %58
  %mul375 = mul nsw i64 0, %add374
  %add376 = add nsw i64 %mul375, 1
  %shl377 = shl i64 %add376, 62
  %sub378 = sub nsw i64 %shl377, 1
  %mul379 = mul nsw i64 %sub378, 2
  %add380 = add nsw i64 %mul379, 1
  %sub381 = sub nsw i64 %conv373, %add380
  br label %cond.end.386

cond.false.382:                                   ; preds = %cond.true.359
  %59 = load i64, i64* %leni, align 8
  %add383 = add nsw i64 0, %59
  %mul384 = mul nsw i64 0, %add383
  %add385 = add nsw i64 %mul384, 0
  br label %cond.end.386

cond.end.386:                                     ; preds = %cond.false.382, %cond.true.365
  %cond387 = phi i64 [ %sub381, %cond.true.365 ], [ %add385, %cond.false.382 ]
  %div388 = sdiv i64 %cond387, 8
  %cmp389 = icmp slt i64 %55, %div388
  br i1 %cmp389, label %cond.true.428, label %lor.lhs.false.414

cond.false.391:                                   ; preds = %cond.false.356
  %60 = load i64, i64* %leni, align 8
  %add392 = add nsw i64 0, %60
  %mul393 = mul nsw i64 0, %add392
  %sub394 = sub nsw i64 %mul393, 1
  %cmp395 = icmp slt i64 %sub394, 0
  br i1 %cmp395, label %cond.true.397, label %cond.false.405

cond.true.397:                                    ; preds = %cond.false.391
  %61 = load i64, i64* %leni, align 8
  %add398 = add nsw i64 0, %61
  %mul399 = mul nsw i64 0, %add398
  %add400 = add nsw i64 %mul399, 1
  %shl401 = shl i64 %add400, 62
  %sub402 = sub nsw i64 %shl401, 1
  %mul403 = mul nsw i64 %sub402, 2
  %add404 = add nsw i64 %mul403, 1
  br label %cond.end.409

cond.false.405:                                   ; preds = %cond.false.391
  %62 = load i64, i64* %leni, align 8
  %add406 = add nsw i64 0, %62
  %mul407 = mul nsw i64 0, %add406
  %sub408 = sub nsw i64 %mul407, 1
  br label %cond.end.409

cond.end.409:                                     ; preds = %cond.false.405, %cond.true.397
  %cond410 = phi i64 [ %add404, %cond.true.397 ], [ %sub408, %cond.false.405 ]
  %div411 = sdiv i64 %cond410, 8
  %63 = load i64, i64* %leni, align 8
  %cmp412 = icmp slt i64 %div411, %63
  br i1 %cmp412, label %cond.true.428, label %lor.lhs.false.414

lor.lhs.false.414:                                ; preds = %cond.end.409, %cond.end.386, %cond.true.355, %cond.end.349, %cond.true.321, %cond.end.315
  %64 = load i64, i64* %leni, align 8
  %mul415 = mul nsw i64 %64, 8
  %mul416 = mul nsw i64 0, %mul415
  %sub417 = sub nsw i64 %mul416, 1
  %cmp418 = icmp slt i64 %sub417, 0
  br i1 %cmp418, label %land.lhs.true.420, label %lor.lhs.false.424

land.lhs.true.420:                                ; preds = %lor.lhs.false.414
  %65 = load i64, i64* %leni, align 8
  %mul421 = mul nsw i64 %65, 8
  %cmp422 = icmp slt i64 %mul421, -128
  br i1 %cmp422, label %cond.true.428, label %lor.lhs.false.424

lor.lhs.false.424:                                ; preds = %land.lhs.true.420, %lor.lhs.false.414
  %66 = load i64, i64* %leni, align 8
  %mul425 = mul nsw i64 %66, 8
  %cmp426 = icmp slt i64 127, %mul425
  br i1 %cmp426, label %cond.true.428, label %cond.false.451

cond.true.428:                                    ; preds = %lor.lhs.false.424, %land.lhs.true.420, %cond.end.409, %cond.end.386, %cond.true.355, %cond.end.349, %cond.true.321, %cond.end.315, %land.lhs.true.290
  %67 = load i64, i64* %leni, align 8
  %conv429 = trunc i64 %67 to i8
  %conv430 = zext i8 %conv429 to i32
  %mul431 = mul nsw i32 %conv430, 8
  %cmp432 = icmp sle i32 %mul431, 127
  br i1 %cmp432, label %cond.true.434, label %cond.false.440

cond.true.434:                                    ; preds = %cond.true.428
  %68 = load i64, i64* %leni, align 8
  %conv435 = trunc i64 %68 to i8
  %conv436 = zext i8 %conv435 to i32
  %mul437 = mul nsw i32 %conv436, 8
  %conv438 = trunc i32 %mul437 to i8
  %conv439 = sext i8 %conv438 to i32
  br label %cond.end.448

cond.false.440:                                   ; preds = %cond.true.428
  %69 = load i64, i64* %leni, align 8
  %conv441 = trunc i64 %69 to i8
  %conv442 = zext i8 %conv441 to i32
  %mul443 = mul nsw i32 %conv442, 8
  %sub444 = sub nsw i32 %mul443, -128
  %conv445 = trunc i32 %sub444 to i8
  %conv446 = sext i8 %conv445 to i32
  %add447 = add nsw i32 %conv446, -128
  br label %cond.end.448

cond.end.448:                                     ; preds = %cond.false.440, %cond.true.434
  %cond449 = phi i32 [ %conv439, %cond.true.434 ], [ %add447, %cond.false.440 ]
  %conv450 = sext i32 %cond449 to i64
  store i64 %conv450, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2166, label %lor.lhs.false.2163

cond.false.451:                                   ; preds = %lor.lhs.false.424
  %70 = load i64, i64* %leni, align 8
  %conv452 = trunc i64 %70 to i8
  %conv453 = zext i8 %conv452 to i32
  %mul454 = mul nsw i32 %conv453, 8
  %cmp455 = icmp sle i32 %mul454, 127
  br i1 %cmp455, label %cond.true.457, label %cond.false.463

cond.true.457:                                    ; preds = %cond.false.451
  %71 = load i64, i64* %leni, align 8
  %conv458 = trunc i64 %71 to i8
  %conv459 = zext i8 %conv458 to i32
  %mul460 = mul nsw i32 %conv459, 8
  %conv461 = trunc i32 %mul460 to i8
  %conv462 = sext i8 %conv461 to i32
  br label %cond.end.471

cond.false.463:                                   ; preds = %cond.false.451
  %72 = load i64, i64* %leni, align 8
  %conv464 = trunc i64 %72 to i8
  %conv465 = zext i8 %conv464 to i32
  %mul466 = mul nsw i32 %conv465, 8
  %sub467 = sub nsw i32 %mul466, -128
  %conv468 = trunc i32 %sub467 to i8
  %conv469 = sext i8 %conv468 to i32
  %add470 = add nsw i32 %conv469, -128
  br label %cond.end.471

cond.end.471:                                     ; preds = %cond.false.463, %cond.true.457
  %cond472 = phi i32 [ %conv462, %cond.true.457 ], [ %add470, %cond.false.463 ]
  %conv473 = sext i32 %cond472 to i64
  store i64 %conv473, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2166, label %lor.lhs.false.2163

cond.false.474:                                   ; preds = %do.body
  br i1 false, label %cond.true.475, label %cond.false.959

cond.true.475:                                    ; preds = %cond.false.474
  br i1 false, label %cond.true.476, label %cond.false.744

cond.true.476:                                    ; preds = %cond.true.475
  %73 = load i64, i64* %leni, align 8
  %conv477 = trunc i64 %73 to i16
  %conv478 = sext i16 %conv477 to i32
  %add479 = add nsw i32 0, %conv478
  %mul480 = mul nsw i32 0, %add479
  %sub481 = sub nsw i32 %mul480, 1
  %cmp482 = icmp slt i32 %sub481, 0
  br i1 %cmp482, label %cond.true.484, label %cond.false.504

cond.true.484:                                    ; preds = %cond.true.476
  %74 = load i64, i64* %leni, align 8
  %conv485 = trunc i64 %74 to i16
  %conv486 = sext i16 %conv485 to i32
  %add487 = add nsw i32 0, %conv486
  %mul488 = mul nsw i32 0, %add487
  %add489 = add nsw i32 %mul488, 0
  %neg490 = xor i32 %add489, -1
  %cmp491 = icmp eq i32 %neg490, -1
  %conv492 = zext i1 %cmp491 to i32
  %sub493 = sub nsw i32 0, %conv492
  %75 = load i64, i64* %leni, align 8
  %conv494 = trunc i64 %75 to i16
  %conv495 = sext i16 %conv494 to i32
  %add496 = add nsw i32 0, %conv495
  %mul497 = mul nsw i32 0, %add496
  %add498 = add nsw i32 %mul497, 1
  %shl499 = shl i32 %add498, 30
  %sub500 = sub nsw i32 %shl499, 1
  %mul501 = mul nsw i32 %sub500, 2
  %add502 = add nsw i32 %mul501, 1
  %sub503 = sub nsw i32 %sub493, %add502
  br label %cond.end.510

cond.false.504:                                   ; preds = %cond.true.476
  %76 = load i64, i64* %leni, align 8
  %conv505 = trunc i64 %76 to i16
  %conv506 = sext i16 %conv505 to i32
  %add507 = add nsw i32 0, %conv506
  %mul508 = mul nsw i32 0, %add507
  %add509 = add nsw i32 %mul508, 0
  br label %cond.end.510

cond.end.510:                                     ; preds = %cond.false.504, %cond.true.484
  %cond511 = phi i32 [ %sub503, %cond.true.484 ], [ %add509, %cond.false.504 ]
  %cmp512 = icmp eq i32 %cond511, 0
  br i1 %cmp512, label %land.lhs.true.514, label %lor.lhs.false.519

land.lhs.true.514:                                ; preds = %cond.end.510
  %77 = load i64, i64* %leni, align 8
  %conv515 = trunc i64 %77 to i16
  %conv516 = sext i16 %conv515 to i32
  %cmp517 = icmp slt i32 %conv516, 0
  br i1 %cmp517, label %cond.true.698, label %lor.lhs.false.519

lor.lhs.false.519:                                ; preds = %land.lhs.true.514, %cond.end.510
  br i1 false, label %cond.true.520, label %cond.false.599

cond.true.520:                                    ; preds = %lor.lhs.false.519
  %78 = load i64, i64* %leni, align 8
  %conv521 = trunc i64 %78 to i16
  %conv522 = sext i16 %conv521 to i32
  %cmp523 = icmp slt i32 %conv522, 0
  br i1 %cmp523, label %cond.true.525, label %cond.false.556

cond.true.525:                                    ; preds = %cond.true.520
  %79 = load i64, i64* %leni, align 8
  %conv526 = trunc i64 %79 to i16
  %conv527 = sext i16 %conv526 to i32
  %80 = load i64, i64* %leni, align 8
  %conv528 = trunc i64 %80 to i16
  %conv529 = sext i16 %conv528 to i32
  %add530 = add nsw i32 0, %conv529
  %mul531 = mul nsw i32 0, %add530
  %sub532 = sub nsw i32 %mul531, 1
  %cmp533 = icmp slt i32 %sub532, 0
  br i1 %cmp533, label %cond.true.535, label %cond.false.545

cond.true.535:                                    ; preds = %cond.true.525
  %81 = load i64, i64* %leni, align 8
  %conv536 = trunc i64 %81 to i16
  %conv537 = sext i16 %conv536 to i32
  %add538 = add nsw i32 0, %conv537
  %mul539 = mul nsw i32 0, %add538
  %add540 = add nsw i32 %mul539, 1
  %shl541 = shl i32 %add540, 30
  %sub542 = sub nsw i32 %shl541, 1
  %mul543 = mul nsw i32 %sub542, 2
  %add544 = add nsw i32 %mul543, 1
  br label %cond.end.551

cond.false.545:                                   ; preds = %cond.true.525
  %82 = load i64, i64* %leni, align 8
  %conv546 = trunc i64 %82 to i16
  %conv547 = sext i16 %conv546 to i32
  %add548 = add nsw i32 0, %conv547
  %mul549 = mul nsw i32 0, %add548
  %sub550 = sub nsw i32 %mul549, 1
  br label %cond.end.551

cond.end.551:                                     ; preds = %cond.false.545, %cond.true.535
  %cond552 = phi i32 [ %add544, %cond.true.535 ], [ %sub550, %cond.false.545 ]
  %div553 = sdiv i32 %cond552, 8
  %cmp554 = icmp slt i32 %conv527, %div553
  br i1 %cmp554, label %cond.true.698, label %lor.lhs.false.678

cond.false.556:                                   ; preds = %cond.true.520
  br i1 false, label %cond.true.557, label %cond.false.558

cond.true.557:                                    ; preds = %cond.false.556
  br i1 false, label %cond.true.698, label %lor.lhs.false.678

cond.false.558:                                   ; preds = %cond.false.556
  %83 = load i64, i64* %leni, align 8
  %conv559 = trunc i64 %83 to i16
  %conv560 = sext i16 %conv559 to i32
  %add561 = add nsw i32 0, %conv560
  %mul562 = mul nsw i32 0, %add561
  %sub563 = sub nsw i32 %mul562, 1
  %cmp564 = icmp slt i32 %sub563, 0
  br i1 %cmp564, label %cond.true.566, label %cond.false.586

cond.true.566:                                    ; preds = %cond.false.558
  %84 = load i64, i64* %leni, align 8
  %conv567 = trunc i64 %84 to i16
  %conv568 = sext i16 %conv567 to i32
  %add569 = add nsw i32 0, %conv568
  %mul570 = mul nsw i32 0, %add569
  %add571 = add nsw i32 %mul570, 0
  %neg572 = xor i32 %add571, -1
  %cmp573 = icmp eq i32 %neg572, -1
  %conv574 = zext i1 %cmp573 to i32
  %sub575 = sub nsw i32 0, %conv574
  %85 = load i64, i64* %leni, align 8
  %conv576 = trunc i64 %85 to i16
  %conv577 = sext i16 %conv576 to i32
  %add578 = add nsw i32 0, %conv577
  %mul579 = mul nsw i32 0, %add578
  %add580 = add nsw i32 %mul579, 1
  %shl581 = shl i32 %add580, 30
  %sub582 = sub nsw i32 %shl581, 1
  %mul583 = mul nsw i32 %sub582, 2
  %add584 = add nsw i32 %mul583, 1
  %sub585 = sub nsw i32 %sub575, %add584
  br label %cond.end.592

cond.false.586:                                   ; preds = %cond.false.558
  %86 = load i64, i64* %leni, align 8
  %conv587 = trunc i64 %86 to i16
  %conv588 = sext i16 %conv587 to i32
  %add589 = add nsw i32 0, %conv588
  %mul590 = mul nsw i32 0, %add589
  %add591 = add nsw i32 %mul590, 0
  br label %cond.end.592

cond.end.592:                                     ; preds = %cond.false.586, %cond.true.566
  %cond593 = phi i32 [ %sub585, %cond.true.566 ], [ %add591, %cond.false.586 ]
  %div594 = sdiv i32 %cond593, 8
  %87 = load i64, i64* %leni, align 8
  %conv595 = trunc i64 %87 to i16
  %conv596 = sext i16 %conv595 to i32
  %cmp597 = icmp slt i32 %div594, %conv596
  br i1 %cmp597, label %cond.true.698, label %lor.lhs.false.678

cond.false.599:                                   ; preds = %lor.lhs.false.519
  br i1 false, label %cond.true.600, label %cond.false.601

cond.true.600:                                    ; preds = %cond.false.599
  br i1 false, label %cond.true.698, label %lor.lhs.false.678

cond.false.601:                                   ; preds = %cond.false.599
  %88 = load i64, i64* %leni, align 8
  %conv602 = trunc i64 %88 to i16
  %conv603 = sext i16 %conv602 to i32
  %cmp604 = icmp slt i32 %conv603, 0
  br i1 %cmp604, label %cond.true.606, label %cond.false.647

cond.true.606:                                    ; preds = %cond.false.601
  %89 = load i64, i64* %leni, align 8
  %conv607 = trunc i64 %89 to i16
  %conv608 = sext i16 %conv607 to i32
  %90 = load i64, i64* %leni, align 8
  %conv609 = trunc i64 %90 to i16
  %conv610 = sext i16 %conv609 to i32
  %add611 = add nsw i32 0, %conv610
  %mul612 = mul nsw i32 0, %add611
  %sub613 = sub nsw i32 %mul612, 1
  %cmp614 = icmp slt i32 %sub613, 0
  br i1 %cmp614, label %cond.true.616, label %cond.false.636

cond.true.616:                                    ; preds = %cond.true.606
  %91 = load i64, i64* %leni, align 8
  %conv617 = trunc i64 %91 to i16
  %conv618 = sext i16 %conv617 to i32
  %add619 = add nsw i32 0, %conv618
  %mul620 = mul nsw i32 0, %add619
  %add621 = add nsw i32 %mul620, 0
  %neg622 = xor i32 %add621, -1
  %cmp623 = icmp eq i32 %neg622, -1
  %conv624 = zext i1 %cmp623 to i32
  %sub625 = sub nsw i32 0, %conv624
  %92 = load i64, i64* %leni, align 8
  %conv626 = trunc i64 %92 to i16
  %conv627 = sext i16 %conv626 to i32
  %add628 = add nsw i32 0, %conv627
  %mul629 = mul nsw i32 0, %add628
  %add630 = add nsw i32 %mul629, 1
  %shl631 = shl i32 %add630, 30
  %sub632 = sub nsw i32 %shl631, 1
  %mul633 = mul nsw i32 %sub632, 2
  %add634 = add nsw i32 %mul633, 1
  %sub635 = sub nsw i32 %sub625, %add634
  br label %cond.end.642

cond.false.636:                                   ; preds = %cond.true.606
  %93 = load i64, i64* %leni, align 8
  %conv637 = trunc i64 %93 to i16
  %conv638 = sext i16 %conv637 to i32
  %add639 = add nsw i32 0, %conv638
  %mul640 = mul nsw i32 0, %add639
  %add641 = add nsw i32 %mul640, 0
  br label %cond.end.642

cond.end.642:                                     ; preds = %cond.false.636, %cond.true.616
  %cond643 = phi i32 [ %sub635, %cond.true.616 ], [ %add641, %cond.false.636 ]
  %div644 = sdiv i32 %cond643, 8
  %cmp645 = icmp slt i32 %conv608, %div644
  br i1 %cmp645, label %cond.true.698, label %lor.lhs.false.678

cond.false.647:                                   ; preds = %cond.false.601
  %94 = load i64, i64* %leni, align 8
  %conv648 = trunc i64 %94 to i16
  %conv649 = sext i16 %conv648 to i32
  %add650 = add nsw i32 0, %conv649
  %mul651 = mul nsw i32 0, %add650
  %sub652 = sub nsw i32 %mul651, 1
  %cmp653 = icmp slt i32 %sub652, 0
  br i1 %cmp653, label %cond.true.655, label %cond.false.665

cond.true.655:                                    ; preds = %cond.false.647
  %95 = load i64, i64* %leni, align 8
  %conv656 = trunc i64 %95 to i16
  %conv657 = sext i16 %conv656 to i32
  %add658 = add nsw i32 0, %conv657
  %mul659 = mul nsw i32 0, %add658
  %add660 = add nsw i32 %mul659, 1
  %shl661 = shl i32 %add660, 30
  %sub662 = sub nsw i32 %shl661, 1
  %mul663 = mul nsw i32 %sub662, 2
  %add664 = add nsw i32 %mul663, 1
  br label %cond.end.671

cond.false.665:                                   ; preds = %cond.false.647
  %96 = load i64, i64* %leni, align 8
  %conv666 = trunc i64 %96 to i16
  %conv667 = sext i16 %conv666 to i32
  %add668 = add nsw i32 0, %conv667
  %mul669 = mul nsw i32 0, %add668
  %sub670 = sub nsw i32 %mul669, 1
  br label %cond.end.671

cond.end.671:                                     ; preds = %cond.false.665, %cond.true.655
  %cond672 = phi i32 [ %add664, %cond.true.655 ], [ %sub670, %cond.false.665 ]
  %div673 = sdiv i32 %cond672, 8
  %97 = load i64, i64* %leni, align 8
  %conv674 = trunc i64 %97 to i16
  %conv675 = sext i16 %conv674 to i32
  %cmp676 = icmp slt i32 %div673, %conv675
  br i1 %cmp676, label %cond.true.698, label %lor.lhs.false.678

lor.lhs.false.678:                                ; preds = %cond.end.671, %cond.end.642, %cond.true.600, %cond.end.592, %cond.true.557, %cond.end.551
  %98 = load i64, i64* %leni, align 8
  %conv679 = trunc i64 %98 to i16
  %conv680 = sext i16 %conv679 to i32
  %mul681 = mul nsw i32 %conv680, 8
  %mul682 = mul nsw i32 0, %mul681
  %sub683 = sub nsw i32 %mul682, 1
  %cmp684 = icmp slt i32 %sub683, 0
  br i1 %cmp684, label %land.lhs.true.686, label %lor.lhs.false.692

land.lhs.true.686:                                ; preds = %lor.lhs.false.678
  %99 = load i64, i64* %leni, align 8
  %conv687 = trunc i64 %99 to i16
  %conv688 = sext i16 %conv687 to i32
  %mul689 = mul nsw i32 %conv688, 8
  %cmp690 = icmp slt i32 %mul689, -32768
  br i1 %cmp690, label %cond.true.698, label %lor.lhs.false.692

lor.lhs.false.692:                                ; preds = %land.lhs.true.686, %lor.lhs.false.678
  %100 = load i64, i64* %leni, align 8
  %conv693 = trunc i64 %100 to i16
  %conv694 = sext i16 %conv693 to i32
  %mul695 = mul nsw i32 %conv694, 8
  %cmp696 = icmp slt i32 32767, %mul695
  br i1 %cmp696, label %cond.true.698, label %cond.false.721

cond.true.698:                                    ; preds = %lor.lhs.false.692, %land.lhs.true.686, %cond.end.671, %cond.end.642, %cond.true.600, %cond.end.592, %cond.true.557, %cond.end.551, %land.lhs.true.514
  %101 = load i64, i64* %leni, align 8
  %conv699 = trunc i64 %101 to i16
  %conv700 = zext i16 %conv699 to i32
  %mul701 = mul nsw i32 %conv700, 8
  %cmp702 = icmp sle i32 %mul701, 32767
  br i1 %cmp702, label %cond.true.704, label %cond.false.710

cond.true.704:                                    ; preds = %cond.true.698
  %102 = load i64, i64* %leni, align 8
  %conv705 = trunc i64 %102 to i16
  %conv706 = zext i16 %conv705 to i32
  %mul707 = mul nsw i32 %conv706, 8
  %conv708 = trunc i32 %mul707 to i16
  %conv709 = sext i16 %conv708 to i32
  br label %cond.end.718

cond.false.710:                                   ; preds = %cond.true.698
  %103 = load i64, i64* %leni, align 8
  %conv711 = trunc i64 %103 to i16
  %conv712 = zext i16 %conv711 to i32
  %mul713 = mul nsw i32 %conv712, 8
  %sub714 = sub nsw i32 %mul713, -32768
  %conv715 = trunc i32 %sub714 to i16
  %conv716 = sext i16 %conv715 to i32
  %add717 = add nsw i32 %conv716, -32768
  br label %cond.end.718

cond.end.718:                                     ; preds = %cond.false.710, %cond.true.704
  %cond719 = phi i32 [ %conv709, %cond.true.704 ], [ %add717, %cond.false.710 ]
  %conv720 = sext i32 %cond719 to i64
  store i64 %conv720, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2166, label %lor.lhs.false.2163

cond.false.721:                                   ; preds = %lor.lhs.false.692
  %104 = load i64, i64* %leni, align 8
  %conv722 = trunc i64 %104 to i16
  %conv723 = zext i16 %conv722 to i32
  %mul724 = mul nsw i32 %conv723, 8
  %cmp725 = icmp sle i32 %mul724, 32767
  br i1 %cmp725, label %cond.true.727, label %cond.false.733

cond.true.727:                                    ; preds = %cond.false.721
  %105 = load i64, i64* %leni, align 8
  %conv728 = trunc i64 %105 to i16
  %conv729 = zext i16 %conv728 to i32
  %mul730 = mul nsw i32 %conv729, 8
  %conv731 = trunc i32 %mul730 to i16
  %conv732 = sext i16 %conv731 to i32
  br label %cond.end.741

cond.false.733:                                   ; preds = %cond.false.721
  %106 = load i64, i64* %leni, align 8
  %conv734 = trunc i64 %106 to i16
  %conv735 = zext i16 %conv734 to i32
  %mul736 = mul nsw i32 %conv735, 8
  %sub737 = sub nsw i32 %mul736, -32768
  %conv738 = trunc i32 %sub737 to i16
  %conv739 = sext i16 %conv738 to i32
  %add740 = add nsw i32 %conv739, -32768
  br label %cond.end.741

cond.end.741:                                     ; preds = %cond.false.733, %cond.true.727
  %cond742 = phi i32 [ %conv732, %cond.true.727 ], [ %add740, %cond.false.733 ]
  %conv743 = sext i32 %cond742 to i64
  store i64 %conv743, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2166, label %lor.lhs.false.2163

cond.false.744:                                   ; preds = %cond.true.475
  %107 = load i64, i64* %leni, align 8
  %add745 = add nsw i64 0, %107
  %mul746 = mul nsw i64 0, %add745
  %sub747 = sub nsw i64 %mul746, 1
  %cmp748 = icmp slt i64 %sub747, 0
  br i1 %cmp748, label %cond.true.750, label %cond.false.767

cond.true.750:                                    ; preds = %cond.false.744
  %108 = load i64, i64* %leni, align 8
  %add751 = add nsw i64 0, %108
  %mul752 = mul nsw i64 0, %add751
  %add753 = add nsw i64 %mul752, 0
  %neg754 = xor i64 %add753, -1
  %cmp755 = icmp eq i64 %neg754, -1
  %conv756 = zext i1 %cmp755 to i32
  %sub757 = sub nsw i32 0, %conv756
  %conv758 = sext i32 %sub757 to i64
  %109 = load i64, i64* %leni, align 8
  %add759 = add nsw i64 0, %109
  %mul760 = mul nsw i64 0, %add759
  %add761 = add nsw i64 %mul760, 1
  %shl762 = shl i64 %add761, 62
  %sub763 = sub nsw i64 %shl762, 1
  %mul764 = mul nsw i64 %sub763, 2
  %add765 = add nsw i64 %mul764, 1
  %sub766 = sub nsw i64 %conv758, %add765
  br label %cond.end.771

cond.false.767:                                   ; preds = %cond.false.744
  %110 = load i64, i64* %leni, align 8
  %add768 = add nsw i64 0, %110
  %mul769 = mul nsw i64 0, %add768
  %add770 = add nsw i64 %mul769, 0
  br label %cond.end.771

cond.end.771:                                     ; preds = %cond.false.767, %cond.true.750
  %cond772 = phi i64 [ %sub766, %cond.true.750 ], [ %add770, %cond.false.767 ]
  %cmp773 = icmp eq i64 %cond772, 0
  br i1 %cmp773, label %land.lhs.true.775, label %lor.lhs.false.778

land.lhs.true.775:                                ; preds = %cond.end.771
  %111 = load i64, i64* %leni, align 8
  %cmp776 = icmp slt i64 %111, 0
  br i1 %cmp776, label %cond.true.913, label %lor.lhs.false.778

lor.lhs.false.778:                                ; preds = %land.lhs.true.775, %cond.end.771
  br i1 false, label %cond.true.779, label %cond.false.839

cond.true.779:                                    ; preds = %lor.lhs.false.778
  %112 = load i64, i64* %leni, align 8
  %cmp780 = icmp slt i64 %112, 0
  br i1 %cmp780, label %cond.true.782, label %cond.false.805

cond.true.782:                                    ; preds = %cond.true.779
  %113 = load i64, i64* %leni, align 8
  %114 = load i64, i64* %leni, align 8
  %add783 = add nsw i64 0, %114
  %mul784 = mul nsw i64 0, %add783
  %sub785 = sub nsw i64 %mul784, 1
  %cmp786 = icmp slt i64 %sub785, 0
  br i1 %cmp786, label %cond.true.788, label %cond.false.796

cond.true.788:                                    ; preds = %cond.true.782
  %115 = load i64, i64* %leni, align 8
  %add789 = add nsw i64 0, %115
  %mul790 = mul nsw i64 0, %add789
  %add791 = add nsw i64 %mul790, 1
  %shl792 = shl i64 %add791, 62
  %sub793 = sub nsw i64 %shl792, 1
  %mul794 = mul nsw i64 %sub793, 2
  %add795 = add nsw i64 %mul794, 1
  br label %cond.end.800

cond.false.796:                                   ; preds = %cond.true.782
  %116 = load i64, i64* %leni, align 8
  %add797 = add nsw i64 0, %116
  %mul798 = mul nsw i64 0, %add797
  %sub799 = sub nsw i64 %mul798, 1
  br label %cond.end.800

cond.end.800:                                     ; preds = %cond.false.796, %cond.true.788
  %cond801 = phi i64 [ %add795, %cond.true.788 ], [ %sub799, %cond.false.796 ]
  %div802 = sdiv i64 %cond801, 8
  %cmp803 = icmp slt i64 %113, %div802
  br i1 %cmp803, label %cond.true.913, label %lor.lhs.false.899

cond.false.805:                                   ; preds = %cond.true.779
  br i1 false, label %cond.true.806, label %cond.false.807

cond.true.806:                                    ; preds = %cond.false.805
  br i1 false, label %cond.true.913, label %lor.lhs.false.899

cond.false.807:                                   ; preds = %cond.false.805
  %117 = load i64, i64* %leni, align 8
  %add808 = add nsw i64 0, %117
  %mul809 = mul nsw i64 0, %add808
  %sub810 = sub nsw i64 %mul809, 1
  %cmp811 = icmp slt i64 %sub810, 0
  br i1 %cmp811, label %cond.true.813, label %cond.false.830

cond.true.813:                                    ; preds = %cond.false.807
  %118 = load i64, i64* %leni, align 8
  %add814 = add nsw i64 0, %118
  %mul815 = mul nsw i64 0, %add814
  %add816 = add nsw i64 %mul815, 0
  %neg817 = xor i64 %add816, -1
  %cmp818 = icmp eq i64 %neg817, -1
  %conv819 = zext i1 %cmp818 to i32
  %sub820 = sub nsw i32 0, %conv819
  %conv821 = sext i32 %sub820 to i64
  %119 = load i64, i64* %leni, align 8
  %add822 = add nsw i64 0, %119
  %mul823 = mul nsw i64 0, %add822
  %add824 = add nsw i64 %mul823, 1
  %shl825 = shl i64 %add824, 62
  %sub826 = sub nsw i64 %shl825, 1
  %mul827 = mul nsw i64 %sub826, 2
  %add828 = add nsw i64 %mul827, 1
  %sub829 = sub nsw i64 %conv821, %add828
  br label %cond.end.834

cond.false.830:                                   ; preds = %cond.false.807
  %120 = load i64, i64* %leni, align 8
  %add831 = add nsw i64 0, %120
  %mul832 = mul nsw i64 0, %add831
  %add833 = add nsw i64 %mul832, 0
  br label %cond.end.834

cond.end.834:                                     ; preds = %cond.false.830, %cond.true.813
  %cond835 = phi i64 [ %sub829, %cond.true.813 ], [ %add833, %cond.false.830 ]
  %div836 = sdiv i64 %cond835, 8
  %121 = load i64, i64* %leni, align 8
  %cmp837 = icmp slt i64 %div836, %121
  br i1 %cmp837, label %cond.true.913, label %lor.lhs.false.899

cond.false.839:                                   ; preds = %lor.lhs.false.778
  br i1 false, label %cond.true.840, label %cond.false.841

cond.true.840:                                    ; preds = %cond.false.839
  br i1 false, label %cond.true.913, label %lor.lhs.false.899

cond.false.841:                                   ; preds = %cond.false.839
  %122 = load i64, i64* %leni, align 8
  %cmp842 = icmp slt i64 %122, 0
  br i1 %cmp842, label %cond.true.844, label %cond.false.876

cond.true.844:                                    ; preds = %cond.false.841
  %123 = load i64, i64* %leni, align 8
  %124 = load i64, i64* %leni, align 8
  %add845 = add nsw i64 0, %124
  %mul846 = mul nsw i64 0, %add845
  %sub847 = sub nsw i64 %mul846, 1
  %cmp848 = icmp slt i64 %sub847, 0
  br i1 %cmp848, label %cond.true.850, label %cond.false.867

cond.true.850:                                    ; preds = %cond.true.844
  %125 = load i64, i64* %leni, align 8
  %add851 = add nsw i64 0, %125
  %mul852 = mul nsw i64 0, %add851
  %add853 = add nsw i64 %mul852, 0
  %neg854 = xor i64 %add853, -1
  %cmp855 = icmp eq i64 %neg854, -1
  %conv856 = zext i1 %cmp855 to i32
  %sub857 = sub nsw i32 0, %conv856
  %conv858 = sext i32 %sub857 to i64
  %126 = load i64, i64* %leni, align 8
  %add859 = add nsw i64 0, %126
  %mul860 = mul nsw i64 0, %add859
  %add861 = add nsw i64 %mul860, 1
  %shl862 = shl i64 %add861, 62
  %sub863 = sub nsw i64 %shl862, 1
  %mul864 = mul nsw i64 %sub863, 2
  %add865 = add nsw i64 %mul864, 1
  %sub866 = sub nsw i64 %conv858, %add865
  br label %cond.end.871

cond.false.867:                                   ; preds = %cond.true.844
  %127 = load i64, i64* %leni, align 8
  %add868 = add nsw i64 0, %127
  %mul869 = mul nsw i64 0, %add868
  %add870 = add nsw i64 %mul869, 0
  br label %cond.end.871

cond.end.871:                                     ; preds = %cond.false.867, %cond.true.850
  %cond872 = phi i64 [ %sub866, %cond.true.850 ], [ %add870, %cond.false.867 ]
  %div873 = sdiv i64 %cond872, 8
  %cmp874 = icmp slt i64 %123, %div873
  br i1 %cmp874, label %cond.true.913, label %lor.lhs.false.899

cond.false.876:                                   ; preds = %cond.false.841
  %128 = load i64, i64* %leni, align 8
  %add877 = add nsw i64 0, %128
  %mul878 = mul nsw i64 0, %add877
  %sub879 = sub nsw i64 %mul878, 1
  %cmp880 = icmp slt i64 %sub879, 0
  br i1 %cmp880, label %cond.true.882, label %cond.false.890

cond.true.882:                                    ; preds = %cond.false.876
  %129 = load i64, i64* %leni, align 8
  %add883 = add nsw i64 0, %129
  %mul884 = mul nsw i64 0, %add883
  %add885 = add nsw i64 %mul884, 1
  %shl886 = shl i64 %add885, 62
  %sub887 = sub nsw i64 %shl886, 1
  %mul888 = mul nsw i64 %sub887, 2
  %add889 = add nsw i64 %mul888, 1
  br label %cond.end.894

cond.false.890:                                   ; preds = %cond.false.876
  %130 = load i64, i64* %leni, align 8
  %add891 = add nsw i64 0, %130
  %mul892 = mul nsw i64 0, %add891
  %sub893 = sub nsw i64 %mul892, 1
  br label %cond.end.894

cond.end.894:                                     ; preds = %cond.false.890, %cond.true.882
  %cond895 = phi i64 [ %add889, %cond.true.882 ], [ %sub893, %cond.false.890 ]
  %div896 = sdiv i64 %cond895, 8
  %131 = load i64, i64* %leni, align 8
  %cmp897 = icmp slt i64 %div896, %131
  br i1 %cmp897, label %cond.true.913, label %lor.lhs.false.899

lor.lhs.false.899:                                ; preds = %cond.end.894, %cond.end.871, %cond.true.840, %cond.end.834, %cond.true.806, %cond.end.800
  %132 = load i64, i64* %leni, align 8
  %mul900 = mul nsw i64 %132, 8
  %mul901 = mul nsw i64 0, %mul900
  %sub902 = sub nsw i64 %mul901, 1
  %cmp903 = icmp slt i64 %sub902, 0
  br i1 %cmp903, label %land.lhs.true.905, label %lor.lhs.false.909

land.lhs.true.905:                                ; preds = %lor.lhs.false.899
  %133 = load i64, i64* %leni, align 8
  %mul906 = mul nsw i64 %133, 8
  %cmp907 = icmp slt i64 %mul906, -32768
  br i1 %cmp907, label %cond.true.913, label %lor.lhs.false.909

lor.lhs.false.909:                                ; preds = %land.lhs.true.905, %lor.lhs.false.899
  %134 = load i64, i64* %leni, align 8
  %mul910 = mul nsw i64 %134, 8
  %cmp911 = icmp slt i64 32767, %mul910
  br i1 %cmp911, label %cond.true.913, label %cond.false.936

cond.true.913:                                    ; preds = %lor.lhs.false.909, %land.lhs.true.905, %cond.end.894, %cond.end.871, %cond.true.840, %cond.end.834, %cond.true.806, %cond.end.800, %land.lhs.true.775
  %135 = load i64, i64* %leni, align 8
  %conv914 = trunc i64 %135 to i16
  %conv915 = zext i16 %conv914 to i32
  %mul916 = mul nsw i32 %conv915, 8
  %cmp917 = icmp sle i32 %mul916, 32767
  br i1 %cmp917, label %cond.true.919, label %cond.false.925

cond.true.919:                                    ; preds = %cond.true.913
  %136 = load i64, i64* %leni, align 8
  %conv920 = trunc i64 %136 to i16
  %conv921 = zext i16 %conv920 to i32
  %mul922 = mul nsw i32 %conv921, 8
  %conv923 = trunc i32 %mul922 to i16
  %conv924 = sext i16 %conv923 to i32
  br label %cond.end.933

cond.false.925:                                   ; preds = %cond.true.913
  %137 = load i64, i64* %leni, align 8
  %conv926 = trunc i64 %137 to i16
  %conv927 = zext i16 %conv926 to i32
  %mul928 = mul nsw i32 %conv927, 8
  %sub929 = sub nsw i32 %mul928, -32768
  %conv930 = trunc i32 %sub929 to i16
  %conv931 = sext i16 %conv930 to i32
  %add932 = add nsw i32 %conv931, -32768
  br label %cond.end.933

cond.end.933:                                     ; preds = %cond.false.925, %cond.true.919
  %cond934 = phi i32 [ %conv924, %cond.true.919 ], [ %add932, %cond.false.925 ]
  %conv935 = sext i32 %cond934 to i64
  store i64 %conv935, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2166, label %lor.lhs.false.2163

cond.false.936:                                   ; preds = %lor.lhs.false.909
  %138 = load i64, i64* %leni, align 8
  %conv937 = trunc i64 %138 to i16
  %conv938 = zext i16 %conv937 to i32
  %mul939 = mul nsw i32 %conv938, 8
  %cmp940 = icmp sle i32 %mul939, 32767
  br i1 %cmp940, label %cond.true.942, label %cond.false.948

cond.true.942:                                    ; preds = %cond.false.936
  %139 = load i64, i64* %leni, align 8
  %conv943 = trunc i64 %139 to i16
  %conv944 = zext i16 %conv943 to i32
  %mul945 = mul nsw i32 %conv944, 8
  %conv946 = trunc i32 %mul945 to i16
  %conv947 = sext i16 %conv946 to i32
  br label %cond.end.956

cond.false.948:                                   ; preds = %cond.false.936
  %140 = load i64, i64* %leni, align 8
  %conv949 = trunc i64 %140 to i16
  %conv950 = zext i16 %conv949 to i32
  %mul951 = mul nsw i32 %conv950, 8
  %sub952 = sub nsw i32 %mul951, -32768
  %conv953 = trunc i32 %sub952 to i16
  %conv954 = sext i16 %conv953 to i32
  %add955 = add nsw i32 %conv954, -32768
  br label %cond.end.956

cond.end.956:                                     ; preds = %cond.false.948, %cond.true.942
  %cond957 = phi i32 [ %conv947, %cond.true.942 ], [ %add955, %cond.false.948 ]
  %conv958 = sext i32 %cond957 to i64
  store i64 %conv958, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2166, label %lor.lhs.false.2163

cond.false.959:                                   ; preds = %cond.false.474
  br i1 false, label %cond.true.960, label %cond.false.1388

cond.true.960:                                    ; preds = %cond.false.959
  br i1 false, label %cond.true.961, label %cond.false.1187

cond.true.961:                                    ; preds = %cond.true.960
  %141 = load i64, i64* %leni, align 8
  %conv962 = trunc i64 %141 to i32
  %add963 = add nsw i32 0, %conv962
  %mul964 = mul nsw i32 0, %add963
  %sub965 = sub nsw i32 %mul964, 1
  %cmp966 = icmp slt i32 %sub965, 0
  br i1 %cmp966, label %cond.true.968, label %cond.false.986

cond.true.968:                                    ; preds = %cond.true.961
  %142 = load i64, i64* %leni, align 8
  %conv969 = trunc i64 %142 to i32
  %add970 = add nsw i32 0, %conv969
  %mul971 = mul nsw i32 0, %add970
  %add972 = add nsw i32 %mul971, 0
  %neg973 = xor i32 %add972, -1
  %cmp974 = icmp eq i32 %neg973, -1
  %conv975 = zext i1 %cmp974 to i32
  %sub976 = sub nsw i32 0, %conv975
  %143 = load i64, i64* %leni, align 8
  %conv977 = trunc i64 %143 to i32
  %add978 = add nsw i32 0, %conv977
  %mul979 = mul nsw i32 0, %add978
  %add980 = add nsw i32 %mul979, 1
  %shl981 = shl i32 %add980, 30
  %sub982 = sub nsw i32 %shl981, 1
  %mul983 = mul nsw i32 %sub982, 2
  %add984 = add nsw i32 %mul983, 1
  %sub985 = sub nsw i32 %sub976, %add984
  br label %cond.end.991

cond.false.986:                                   ; preds = %cond.true.961
  %144 = load i64, i64* %leni, align 8
  %conv987 = trunc i64 %144 to i32
  %add988 = add nsw i32 0, %conv987
  %mul989 = mul nsw i32 0, %add988
  %add990 = add nsw i32 %mul989, 0
  br label %cond.end.991

cond.end.991:                                     ; preds = %cond.false.986, %cond.true.968
  %cond992 = phi i32 [ %sub985, %cond.true.968 ], [ %add990, %cond.false.986 ]
  %cmp993 = icmp eq i32 %cond992, 0
  br i1 %cmp993, label %land.lhs.true.995, label %lor.lhs.false.999

land.lhs.true.995:                                ; preds = %cond.end.991
  %145 = load i64, i64* %leni, align 8
  %conv996 = trunc i64 %145 to i32
  %cmp997 = icmp slt i32 %conv996, 0
  br i1 %cmp997, label %cond.true.1155, label %lor.lhs.false.999

lor.lhs.false.999:                                ; preds = %land.lhs.true.995, %cond.end.991
  br i1 false, label %cond.true.1000, label %cond.false.1069

cond.true.1000:                                   ; preds = %lor.lhs.false.999
  %146 = load i64, i64* %leni, align 8
  %conv1001 = trunc i64 %146 to i32
  %cmp1002 = icmp slt i32 %conv1001, 0
  br i1 %cmp1002, label %cond.true.1004, label %cond.false.1031

cond.true.1004:                                   ; preds = %cond.true.1000
  %147 = load i64, i64* %leni, align 8
  %conv1005 = trunc i64 %147 to i32
  %148 = load i64, i64* %leni, align 8
  %conv1006 = trunc i64 %148 to i32
  %add1007 = add nsw i32 0, %conv1006
  %mul1008 = mul nsw i32 0, %add1007
  %sub1009 = sub nsw i32 %mul1008, 1
  %cmp1010 = icmp slt i32 %sub1009, 0
  br i1 %cmp1010, label %cond.true.1012, label %cond.false.1021

cond.true.1012:                                   ; preds = %cond.true.1004
  %149 = load i64, i64* %leni, align 8
  %conv1013 = trunc i64 %149 to i32
  %add1014 = add nsw i32 0, %conv1013
  %mul1015 = mul nsw i32 0, %add1014
  %add1016 = add nsw i32 %mul1015, 1
  %shl1017 = shl i32 %add1016, 30
  %sub1018 = sub nsw i32 %shl1017, 1
  %mul1019 = mul nsw i32 %sub1018, 2
  %add1020 = add nsw i32 %mul1019, 1
  br label %cond.end.1026

cond.false.1021:                                  ; preds = %cond.true.1004
  %150 = load i64, i64* %leni, align 8
  %conv1022 = trunc i64 %150 to i32
  %add1023 = add nsw i32 0, %conv1022
  %mul1024 = mul nsw i32 0, %add1023
  %sub1025 = sub nsw i32 %mul1024, 1
  br label %cond.end.1026

cond.end.1026:                                    ; preds = %cond.false.1021, %cond.true.1012
  %cond1027 = phi i32 [ %add1020, %cond.true.1012 ], [ %sub1025, %cond.false.1021 ]
  %div1028 = sdiv i32 %cond1027, 8
  %cmp1029 = icmp slt i32 %conv1005, %div1028
  br i1 %cmp1029, label %cond.true.1155, label %lor.lhs.false.1138

cond.false.1031:                                  ; preds = %cond.true.1000
  br i1 false, label %cond.true.1032, label %cond.false.1033

cond.true.1032:                                   ; preds = %cond.false.1031
  br i1 false, label %cond.true.1155, label %lor.lhs.false.1138

cond.false.1033:                                  ; preds = %cond.false.1031
  %151 = load i64, i64* %leni, align 8
  %conv1034 = trunc i64 %151 to i32
  %add1035 = add nsw i32 0, %conv1034
  %mul1036 = mul nsw i32 0, %add1035
  %sub1037 = sub nsw i32 %mul1036, 1
  %cmp1038 = icmp slt i32 %sub1037, 0
  br i1 %cmp1038, label %cond.true.1040, label %cond.false.1058

cond.true.1040:                                   ; preds = %cond.false.1033
  %152 = load i64, i64* %leni, align 8
  %conv1041 = trunc i64 %152 to i32
  %add1042 = add nsw i32 0, %conv1041
  %mul1043 = mul nsw i32 0, %add1042
  %add1044 = add nsw i32 %mul1043, 0
  %neg1045 = xor i32 %add1044, -1
  %cmp1046 = icmp eq i32 %neg1045, -1
  %conv1047 = zext i1 %cmp1046 to i32
  %sub1048 = sub nsw i32 0, %conv1047
  %153 = load i64, i64* %leni, align 8
  %conv1049 = trunc i64 %153 to i32
  %add1050 = add nsw i32 0, %conv1049
  %mul1051 = mul nsw i32 0, %add1050
  %add1052 = add nsw i32 %mul1051, 1
  %shl1053 = shl i32 %add1052, 30
  %sub1054 = sub nsw i32 %shl1053, 1
  %mul1055 = mul nsw i32 %sub1054, 2
  %add1056 = add nsw i32 %mul1055, 1
  %sub1057 = sub nsw i32 %sub1048, %add1056
  br label %cond.end.1063

cond.false.1058:                                  ; preds = %cond.false.1033
  %154 = load i64, i64* %leni, align 8
  %conv1059 = trunc i64 %154 to i32
  %add1060 = add nsw i32 0, %conv1059
  %mul1061 = mul nsw i32 0, %add1060
  %add1062 = add nsw i32 %mul1061, 0
  br label %cond.end.1063

cond.end.1063:                                    ; preds = %cond.false.1058, %cond.true.1040
  %cond1064 = phi i32 [ %sub1057, %cond.true.1040 ], [ %add1062, %cond.false.1058 ]
  %div1065 = sdiv i32 %cond1064, 8
  %155 = load i64, i64* %leni, align 8
  %conv1066 = trunc i64 %155 to i32
  %cmp1067 = icmp slt i32 %div1065, %conv1066
  br i1 %cmp1067, label %cond.true.1155, label %lor.lhs.false.1138

cond.false.1069:                                  ; preds = %lor.lhs.false.999
  br i1 false, label %cond.true.1070, label %cond.false.1071

cond.true.1070:                                   ; preds = %cond.false.1069
  br i1 false, label %cond.true.1155, label %lor.lhs.false.1138

cond.false.1071:                                  ; preds = %cond.false.1069
  %156 = load i64, i64* %leni, align 8
  %conv1072 = trunc i64 %156 to i32
  %cmp1073 = icmp slt i32 %conv1072, 0
  br i1 %cmp1073, label %cond.true.1075, label %cond.false.1111

cond.true.1075:                                   ; preds = %cond.false.1071
  %157 = load i64, i64* %leni, align 8
  %conv1076 = trunc i64 %157 to i32
  %158 = load i64, i64* %leni, align 8
  %conv1077 = trunc i64 %158 to i32
  %add1078 = add nsw i32 0, %conv1077
  %mul1079 = mul nsw i32 0, %add1078
  %sub1080 = sub nsw i32 %mul1079, 1
  %cmp1081 = icmp slt i32 %sub1080, 0
  br i1 %cmp1081, label %cond.true.1083, label %cond.false.1101

cond.true.1083:                                   ; preds = %cond.true.1075
  %159 = load i64, i64* %leni, align 8
  %conv1084 = trunc i64 %159 to i32
  %add1085 = add nsw i32 0, %conv1084
  %mul1086 = mul nsw i32 0, %add1085
  %add1087 = add nsw i32 %mul1086, 0
  %neg1088 = xor i32 %add1087, -1
  %cmp1089 = icmp eq i32 %neg1088, -1
  %conv1090 = zext i1 %cmp1089 to i32
  %sub1091 = sub nsw i32 0, %conv1090
  %160 = load i64, i64* %leni, align 8
  %conv1092 = trunc i64 %160 to i32
  %add1093 = add nsw i32 0, %conv1092
  %mul1094 = mul nsw i32 0, %add1093
  %add1095 = add nsw i32 %mul1094, 1
  %shl1096 = shl i32 %add1095, 30
  %sub1097 = sub nsw i32 %shl1096, 1
  %mul1098 = mul nsw i32 %sub1097, 2
  %add1099 = add nsw i32 %mul1098, 1
  %sub1100 = sub nsw i32 %sub1091, %add1099
  br label %cond.end.1106

cond.false.1101:                                  ; preds = %cond.true.1075
  %161 = load i64, i64* %leni, align 8
  %conv1102 = trunc i64 %161 to i32
  %add1103 = add nsw i32 0, %conv1102
  %mul1104 = mul nsw i32 0, %add1103
  %add1105 = add nsw i32 %mul1104, 0
  br label %cond.end.1106

cond.end.1106:                                    ; preds = %cond.false.1101, %cond.true.1083
  %cond1107 = phi i32 [ %sub1100, %cond.true.1083 ], [ %add1105, %cond.false.1101 ]
  %div1108 = sdiv i32 %cond1107, 8
  %cmp1109 = icmp slt i32 %conv1076, %div1108
  br i1 %cmp1109, label %cond.true.1155, label %lor.lhs.false.1138

cond.false.1111:                                  ; preds = %cond.false.1071
  %162 = load i64, i64* %leni, align 8
  %conv1112 = trunc i64 %162 to i32
  %add1113 = add nsw i32 0, %conv1112
  %mul1114 = mul nsw i32 0, %add1113
  %sub1115 = sub nsw i32 %mul1114, 1
  %cmp1116 = icmp slt i32 %sub1115, 0
  br i1 %cmp1116, label %cond.true.1118, label %cond.false.1127

cond.true.1118:                                   ; preds = %cond.false.1111
  %163 = load i64, i64* %leni, align 8
  %conv1119 = trunc i64 %163 to i32
  %add1120 = add nsw i32 0, %conv1119
  %mul1121 = mul nsw i32 0, %add1120
  %add1122 = add nsw i32 %mul1121, 1
  %shl1123 = shl i32 %add1122, 30
  %sub1124 = sub nsw i32 %shl1123, 1
  %mul1125 = mul nsw i32 %sub1124, 2
  %add1126 = add nsw i32 %mul1125, 1
  br label %cond.end.1132

cond.false.1127:                                  ; preds = %cond.false.1111
  %164 = load i64, i64* %leni, align 8
  %conv1128 = trunc i64 %164 to i32
  %add1129 = add nsw i32 0, %conv1128
  %mul1130 = mul nsw i32 0, %add1129
  %sub1131 = sub nsw i32 %mul1130, 1
  br label %cond.end.1132

cond.end.1132:                                    ; preds = %cond.false.1127, %cond.true.1118
  %cond1133 = phi i32 [ %add1126, %cond.true.1118 ], [ %sub1131, %cond.false.1127 ]
  %div1134 = sdiv i32 %cond1133, 8
  %165 = load i64, i64* %leni, align 8
  %conv1135 = trunc i64 %165 to i32
  %cmp1136 = icmp slt i32 %div1134, %conv1135
  br i1 %cmp1136, label %cond.true.1155, label %lor.lhs.false.1138

lor.lhs.false.1138:                               ; preds = %cond.end.1132, %cond.end.1106, %cond.true.1070, %cond.end.1063, %cond.true.1032, %cond.end.1026
  %166 = load i64, i64* %leni, align 8
  %conv1139 = trunc i64 %166 to i32
  %mul1140 = mul nsw i32 %conv1139, 8
  %mul1141 = mul nsw i32 0, %mul1140
  %sub1142 = sub nsw i32 %mul1141, 1
  %cmp1143 = icmp slt i32 %sub1142, 0
  br i1 %cmp1143, label %land.lhs.true.1145, label %lor.lhs.false.1150

land.lhs.true.1145:                               ; preds = %lor.lhs.false.1138
  %167 = load i64, i64* %leni, align 8
  %conv1146 = trunc i64 %167 to i32
  %mul1147 = mul nsw i32 %conv1146, 8
  %cmp1148 = icmp slt i32 %mul1147, -2147483648
  br i1 %cmp1148, label %cond.true.1155, label %lor.lhs.false.1150

lor.lhs.false.1150:                               ; preds = %land.lhs.true.1145, %lor.lhs.false.1138
  %168 = load i64, i64* %leni, align 8
  %conv1151 = trunc i64 %168 to i32
  %mul1152 = mul nsw i32 %conv1151, 8
  %cmp1153 = icmp slt i32 2147483647, %mul1152
  br i1 %cmp1153, label %cond.true.1155, label %cond.false.1171

cond.true.1155:                                   ; preds = %lor.lhs.false.1150, %land.lhs.true.1145, %cond.end.1132, %cond.end.1106, %cond.true.1070, %cond.end.1063, %cond.true.1032, %cond.end.1026, %land.lhs.true.995
  %169 = load i64, i64* %leni, align 8
  %conv1156 = trunc i64 %169 to i32
  %mul1157 = mul i32 %conv1156, 8
  %cmp1158 = icmp ule i32 %mul1157, 2147483647
  br i1 %cmp1158, label %cond.true.1160, label %cond.false.1163

cond.true.1160:                                   ; preds = %cond.true.1155
  %170 = load i64, i64* %leni, align 8
  %conv1161 = trunc i64 %170 to i32
  %mul1162 = mul i32 %conv1161, 8
  br label %cond.end.1168

cond.false.1163:                                  ; preds = %cond.true.1155
  %171 = load i64, i64* %leni, align 8
  %conv1164 = trunc i64 %171 to i32
  %mul1165 = mul i32 %conv1164, 8
  %sub1166 = sub i32 %mul1165, -2147483648
  %add1167 = add nsw i32 %sub1166, -2147483648
  br label %cond.end.1168

cond.end.1168:                                    ; preds = %cond.false.1163, %cond.true.1160
  %cond1169 = phi i32 [ %mul1162, %cond.true.1160 ], [ %add1167, %cond.false.1163 ]
  %conv1170 = sext i32 %cond1169 to i64
  store i64 %conv1170, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2166, label %lor.lhs.false.2163

cond.false.1171:                                  ; preds = %lor.lhs.false.1150
  %172 = load i64, i64* %leni, align 8
  %conv1172 = trunc i64 %172 to i32
  %mul1173 = mul i32 %conv1172, 8
  %cmp1174 = icmp ule i32 %mul1173, 2147483647
  br i1 %cmp1174, label %cond.true.1176, label %cond.false.1179

cond.true.1176:                                   ; preds = %cond.false.1171
  %173 = load i64, i64* %leni, align 8
  %conv1177 = trunc i64 %173 to i32
  %mul1178 = mul i32 %conv1177, 8
  br label %cond.end.1184

cond.false.1179:                                  ; preds = %cond.false.1171
  %174 = load i64, i64* %leni, align 8
  %conv1180 = trunc i64 %174 to i32
  %mul1181 = mul i32 %conv1180, 8
  %sub1182 = sub i32 %mul1181, -2147483648
  %add1183 = add nsw i32 %sub1182, -2147483648
  br label %cond.end.1184

cond.end.1184:                                    ; preds = %cond.false.1179, %cond.true.1176
  %cond1185 = phi i32 [ %mul1178, %cond.true.1176 ], [ %add1183, %cond.false.1179 ]
  %conv1186 = sext i32 %cond1185 to i64
  store i64 %conv1186, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2166, label %lor.lhs.false.2163

cond.false.1187:                                  ; preds = %cond.true.960
  %175 = load i64, i64* %leni, align 8
  %add1188 = add nsw i64 0, %175
  %mul1189 = mul nsw i64 0, %add1188
  %sub1190 = sub nsw i64 %mul1189, 1
  %cmp1191 = icmp slt i64 %sub1190, 0
  br i1 %cmp1191, label %cond.true.1193, label %cond.false.1210

cond.true.1193:                                   ; preds = %cond.false.1187
  %176 = load i64, i64* %leni, align 8
  %add1194 = add nsw i64 0, %176
  %mul1195 = mul nsw i64 0, %add1194
  %add1196 = add nsw i64 %mul1195, 0
  %neg1197 = xor i64 %add1196, -1
  %cmp1198 = icmp eq i64 %neg1197, -1
  %conv1199 = zext i1 %cmp1198 to i32
  %sub1200 = sub nsw i32 0, %conv1199
  %conv1201 = sext i32 %sub1200 to i64
  %177 = load i64, i64* %leni, align 8
  %add1202 = add nsw i64 0, %177
  %mul1203 = mul nsw i64 0, %add1202
  %add1204 = add nsw i64 %mul1203, 1
  %shl1205 = shl i64 %add1204, 62
  %sub1206 = sub nsw i64 %shl1205, 1
  %mul1207 = mul nsw i64 %sub1206, 2
  %add1208 = add nsw i64 %mul1207, 1
  %sub1209 = sub nsw i64 %conv1201, %add1208
  br label %cond.end.1214

cond.false.1210:                                  ; preds = %cond.false.1187
  %178 = load i64, i64* %leni, align 8
  %add1211 = add nsw i64 0, %178
  %mul1212 = mul nsw i64 0, %add1211
  %add1213 = add nsw i64 %mul1212, 0
  br label %cond.end.1214

cond.end.1214:                                    ; preds = %cond.false.1210, %cond.true.1193
  %cond1215 = phi i64 [ %sub1209, %cond.true.1193 ], [ %add1213, %cond.false.1210 ]
  %cmp1216 = icmp eq i64 %cond1215, 0
  br i1 %cmp1216, label %land.lhs.true.1218, label %lor.lhs.false.1221

land.lhs.true.1218:                               ; preds = %cond.end.1214
  %179 = load i64, i64* %leni, align 8
  %cmp1219 = icmp slt i64 %179, 0
  br i1 %cmp1219, label %cond.true.1356, label %lor.lhs.false.1221

lor.lhs.false.1221:                               ; preds = %land.lhs.true.1218, %cond.end.1214
  br i1 false, label %cond.true.1222, label %cond.false.1282

cond.true.1222:                                   ; preds = %lor.lhs.false.1221
  %180 = load i64, i64* %leni, align 8
  %cmp1223 = icmp slt i64 %180, 0
  br i1 %cmp1223, label %cond.true.1225, label %cond.false.1248

cond.true.1225:                                   ; preds = %cond.true.1222
  %181 = load i64, i64* %leni, align 8
  %182 = load i64, i64* %leni, align 8
  %add1226 = add nsw i64 0, %182
  %mul1227 = mul nsw i64 0, %add1226
  %sub1228 = sub nsw i64 %mul1227, 1
  %cmp1229 = icmp slt i64 %sub1228, 0
  br i1 %cmp1229, label %cond.true.1231, label %cond.false.1239

cond.true.1231:                                   ; preds = %cond.true.1225
  %183 = load i64, i64* %leni, align 8
  %add1232 = add nsw i64 0, %183
  %mul1233 = mul nsw i64 0, %add1232
  %add1234 = add nsw i64 %mul1233, 1
  %shl1235 = shl i64 %add1234, 62
  %sub1236 = sub nsw i64 %shl1235, 1
  %mul1237 = mul nsw i64 %sub1236, 2
  %add1238 = add nsw i64 %mul1237, 1
  br label %cond.end.1243

cond.false.1239:                                  ; preds = %cond.true.1225
  %184 = load i64, i64* %leni, align 8
  %add1240 = add nsw i64 0, %184
  %mul1241 = mul nsw i64 0, %add1240
  %sub1242 = sub nsw i64 %mul1241, 1
  br label %cond.end.1243

cond.end.1243:                                    ; preds = %cond.false.1239, %cond.true.1231
  %cond1244 = phi i64 [ %add1238, %cond.true.1231 ], [ %sub1242, %cond.false.1239 ]
  %div1245 = sdiv i64 %cond1244, 8
  %cmp1246 = icmp slt i64 %181, %div1245
  br i1 %cmp1246, label %cond.true.1356, label %lor.lhs.false.1342

cond.false.1248:                                  ; preds = %cond.true.1222
  br i1 false, label %cond.true.1249, label %cond.false.1250

cond.true.1249:                                   ; preds = %cond.false.1248
  br i1 false, label %cond.true.1356, label %lor.lhs.false.1342

cond.false.1250:                                  ; preds = %cond.false.1248
  %185 = load i64, i64* %leni, align 8
  %add1251 = add nsw i64 0, %185
  %mul1252 = mul nsw i64 0, %add1251
  %sub1253 = sub nsw i64 %mul1252, 1
  %cmp1254 = icmp slt i64 %sub1253, 0
  br i1 %cmp1254, label %cond.true.1256, label %cond.false.1273

cond.true.1256:                                   ; preds = %cond.false.1250
  %186 = load i64, i64* %leni, align 8
  %add1257 = add nsw i64 0, %186
  %mul1258 = mul nsw i64 0, %add1257
  %add1259 = add nsw i64 %mul1258, 0
  %neg1260 = xor i64 %add1259, -1
  %cmp1261 = icmp eq i64 %neg1260, -1
  %conv1262 = zext i1 %cmp1261 to i32
  %sub1263 = sub nsw i32 0, %conv1262
  %conv1264 = sext i32 %sub1263 to i64
  %187 = load i64, i64* %leni, align 8
  %add1265 = add nsw i64 0, %187
  %mul1266 = mul nsw i64 0, %add1265
  %add1267 = add nsw i64 %mul1266, 1
  %shl1268 = shl i64 %add1267, 62
  %sub1269 = sub nsw i64 %shl1268, 1
  %mul1270 = mul nsw i64 %sub1269, 2
  %add1271 = add nsw i64 %mul1270, 1
  %sub1272 = sub nsw i64 %conv1264, %add1271
  br label %cond.end.1277

cond.false.1273:                                  ; preds = %cond.false.1250
  %188 = load i64, i64* %leni, align 8
  %add1274 = add nsw i64 0, %188
  %mul1275 = mul nsw i64 0, %add1274
  %add1276 = add nsw i64 %mul1275, 0
  br label %cond.end.1277

cond.end.1277:                                    ; preds = %cond.false.1273, %cond.true.1256
  %cond1278 = phi i64 [ %sub1272, %cond.true.1256 ], [ %add1276, %cond.false.1273 ]
  %div1279 = sdiv i64 %cond1278, 8
  %189 = load i64, i64* %leni, align 8
  %cmp1280 = icmp slt i64 %div1279, %189
  br i1 %cmp1280, label %cond.true.1356, label %lor.lhs.false.1342

cond.false.1282:                                  ; preds = %lor.lhs.false.1221
  br i1 false, label %cond.true.1283, label %cond.false.1284

cond.true.1283:                                   ; preds = %cond.false.1282
  br i1 false, label %cond.true.1356, label %lor.lhs.false.1342

cond.false.1284:                                  ; preds = %cond.false.1282
  %190 = load i64, i64* %leni, align 8
  %cmp1285 = icmp slt i64 %190, 0
  br i1 %cmp1285, label %cond.true.1287, label %cond.false.1319

cond.true.1287:                                   ; preds = %cond.false.1284
  %191 = load i64, i64* %leni, align 8
  %192 = load i64, i64* %leni, align 8
  %add1288 = add nsw i64 0, %192
  %mul1289 = mul nsw i64 0, %add1288
  %sub1290 = sub nsw i64 %mul1289, 1
  %cmp1291 = icmp slt i64 %sub1290, 0
  br i1 %cmp1291, label %cond.true.1293, label %cond.false.1310

cond.true.1293:                                   ; preds = %cond.true.1287
  %193 = load i64, i64* %leni, align 8
  %add1294 = add nsw i64 0, %193
  %mul1295 = mul nsw i64 0, %add1294
  %add1296 = add nsw i64 %mul1295, 0
  %neg1297 = xor i64 %add1296, -1
  %cmp1298 = icmp eq i64 %neg1297, -1
  %conv1299 = zext i1 %cmp1298 to i32
  %sub1300 = sub nsw i32 0, %conv1299
  %conv1301 = sext i32 %sub1300 to i64
  %194 = load i64, i64* %leni, align 8
  %add1302 = add nsw i64 0, %194
  %mul1303 = mul nsw i64 0, %add1302
  %add1304 = add nsw i64 %mul1303, 1
  %shl1305 = shl i64 %add1304, 62
  %sub1306 = sub nsw i64 %shl1305, 1
  %mul1307 = mul nsw i64 %sub1306, 2
  %add1308 = add nsw i64 %mul1307, 1
  %sub1309 = sub nsw i64 %conv1301, %add1308
  br label %cond.end.1314

cond.false.1310:                                  ; preds = %cond.true.1287
  %195 = load i64, i64* %leni, align 8
  %add1311 = add nsw i64 0, %195
  %mul1312 = mul nsw i64 0, %add1311
  %add1313 = add nsw i64 %mul1312, 0
  br label %cond.end.1314

cond.end.1314:                                    ; preds = %cond.false.1310, %cond.true.1293
  %cond1315 = phi i64 [ %sub1309, %cond.true.1293 ], [ %add1313, %cond.false.1310 ]
  %div1316 = sdiv i64 %cond1315, 8
  %cmp1317 = icmp slt i64 %191, %div1316
  br i1 %cmp1317, label %cond.true.1356, label %lor.lhs.false.1342

cond.false.1319:                                  ; preds = %cond.false.1284
  %196 = load i64, i64* %leni, align 8
  %add1320 = add nsw i64 0, %196
  %mul1321 = mul nsw i64 0, %add1320
  %sub1322 = sub nsw i64 %mul1321, 1
  %cmp1323 = icmp slt i64 %sub1322, 0
  br i1 %cmp1323, label %cond.true.1325, label %cond.false.1333

cond.true.1325:                                   ; preds = %cond.false.1319
  %197 = load i64, i64* %leni, align 8
  %add1326 = add nsw i64 0, %197
  %mul1327 = mul nsw i64 0, %add1326
  %add1328 = add nsw i64 %mul1327, 1
  %shl1329 = shl i64 %add1328, 62
  %sub1330 = sub nsw i64 %shl1329, 1
  %mul1331 = mul nsw i64 %sub1330, 2
  %add1332 = add nsw i64 %mul1331, 1
  br label %cond.end.1337

cond.false.1333:                                  ; preds = %cond.false.1319
  %198 = load i64, i64* %leni, align 8
  %add1334 = add nsw i64 0, %198
  %mul1335 = mul nsw i64 0, %add1334
  %sub1336 = sub nsw i64 %mul1335, 1
  br label %cond.end.1337

cond.end.1337:                                    ; preds = %cond.false.1333, %cond.true.1325
  %cond1338 = phi i64 [ %add1332, %cond.true.1325 ], [ %sub1336, %cond.false.1333 ]
  %div1339 = sdiv i64 %cond1338, 8
  %199 = load i64, i64* %leni, align 8
  %cmp1340 = icmp slt i64 %div1339, %199
  br i1 %cmp1340, label %cond.true.1356, label %lor.lhs.false.1342

lor.lhs.false.1342:                               ; preds = %cond.end.1337, %cond.end.1314, %cond.true.1283, %cond.end.1277, %cond.true.1249, %cond.end.1243
  %200 = load i64, i64* %leni, align 8
  %mul1343 = mul nsw i64 %200, 8
  %mul1344 = mul nsw i64 0, %mul1343
  %sub1345 = sub nsw i64 %mul1344, 1
  %cmp1346 = icmp slt i64 %sub1345, 0
  br i1 %cmp1346, label %land.lhs.true.1348, label %lor.lhs.false.1352

land.lhs.true.1348:                               ; preds = %lor.lhs.false.1342
  %201 = load i64, i64* %leni, align 8
  %mul1349 = mul nsw i64 %201, 8
  %cmp1350 = icmp slt i64 %mul1349, -2147483648
  br i1 %cmp1350, label %cond.true.1356, label %lor.lhs.false.1352

lor.lhs.false.1352:                               ; preds = %land.lhs.true.1348, %lor.lhs.false.1342
  %202 = load i64, i64* %leni, align 8
  %mul1353 = mul nsw i64 %202, 8
  %cmp1354 = icmp slt i64 2147483647, %mul1353
  br i1 %cmp1354, label %cond.true.1356, label %cond.false.1372

cond.true.1356:                                   ; preds = %lor.lhs.false.1352, %land.lhs.true.1348, %cond.end.1337, %cond.end.1314, %cond.true.1283, %cond.end.1277, %cond.true.1249, %cond.end.1243, %land.lhs.true.1218
  %203 = load i64, i64* %leni, align 8
  %conv1357 = trunc i64 %203 to i32
  %mul1358 = mul i32 %conv1357, 8
  %cmp1359 = icmp ule i32 %mul1358, 2147483647
  br i1 %cmp1359, label %cond.true.1361, label %cond.false.1364

cond.true.1361:                                   ; preds = %cond.true.1356
  %204 = load i64, i64* %leni, align 8
  %conv1362 = trunc i64 %204 to i32
  %mul1363 = mul i32 %conv1362, 8
  br label %cond.end.1369

cond.false.1364:                                  ; preds = %cond.true.1356
  %205 = load i64, i64* %leni, align 8
  %conv1365 = trunc i64 %205 to i32
  %mul1366 = mul i32 %conv1365, 8
  %sub1367 = sub i32 %mul1366, -2147483648
  %add1368 = add nsw i32 %sub1367, -2147483648
  br label %cond.end.1369

cond.end.1369:                                    ; preds = %cond.false.1364, %cond.true.1361
  %cond1370 = phi i32 [ %mul1363, %cond.true.1361 ], [ %add1368, %cond.false.1364 ]
  %conv1371 = sext i32 %cond1370 to i64
  store i64 %conv1371, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2166, label %lor.lhs.false.2163

cond.false.1372:                                  ; preds = %lor.lhs.false.1352
  %206 = load i64, i64* %leni, align 8
  %conv1373 = trunc i64 %206 to i32
  %mul1374 = mul i32 %conv1373, 8
  %cmp1375 = icmp ule i32 %mul1374, 2147483647
  br i1 %cmp1375, label %cond.true.1377, label %cond.false.1380

cond.true.1377:                                   ; preds = %cond.false.1372
  %207 = load i64, i64* %leni, align 8
  %conv1378 = trunc i64 %207 to i32
  %mul1379 = mul i32 %conv1378, 8
  br label %cond.end.1385

cond.false.1380:                                  ; preds = %cond.false.1372
  %208 = load i64, i64* %leni, align 8
  %conv1381 = trunc i64 %208 to i32
  %mul1382 = mul i32 %conv1381, 8
  %sub1383 = sub i32 %mul1382, -2147483648
  %add1384 = add nsw i32 %sub1383, -2147483648
  br label %cond.end.1385

cond.end.1385:                                    ; preds = %cond.false.1380, %cond.true.1377
  %cond1386 = phi i32 [ %mul1379, %cond.true.1377 ], [ %add1384, %cond.false.1380 ]
  %conv1387 = sext i32 %cond1386 to i64
  store i64 %conv1387, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2166, label %lor.lhs.false.2163

cond.false.1388:                                  ; preds = %cond.false.959
  br i1 true, label %cond.true.1389, label %cond.false.1776

cond.true.1389:                                   ; preds = %cond.false.1388
  br i1 false, label %cond.true.1390, label %cond.false.1583

cond.true.1390:                                   ; preds = %cond.true.1389
  %209 = load i64, i64* %leni, align 8
  %add1391 = add nsw i64 0, %209
  %mul1392 = mul nsw i64 0, %add1391
  %sub1393 = sub nsw i64 %mul1392, 1
  %cmp1394 = icmp slt i64 %sub1393, 0
  br i1 %cmp1394, label %cond.true.1396, label %cond.false.1413

cond.true.1396:                                   ; preds = %cond.true.1390
  %210 = load i64, i64* %leni, align 8
  %add1397 = add nsw i64 0, %210
  %mul1398 = mul nsw i64 0, %add1397
  %add1399 = add nsw i64 %mul1398, 0
  %neg1400 = xor i64 %add1399, -1
  %cmp1401 = icmp eq i64 %neg1400, -1
  %conv1402 = zext i1 %cmp1401 to i32
  %sub1403 = sub nsw i32 0, %conv1402
  %conv1404 = sext i32 %sub1403 to i64
  %211 = load i64, i64* %leni, align 8
  %add1405 = add nsw i64 0, %211
  %mul1406 = mul nsw i64 0, %add1405
  %add1407 = add nsw i64 %mul1406, 1
  %shl1408 = shl i64 %add1407, 62
  %sub1409 = sub nsw i64 %shl1408, 1
  %mul1410 = mul nsw i64 %sub1409, 2
  %add1411 = add nsw i64 %mul1410, 1
  %sub1412 = sub nsw i64 %conv1404, %add1411
  br label %cond.end.1417

cond.false.1413:                                  ; preds = %cond.true.1390
  %212 = load i64, i64* %leni, align 8
  %add1414 = add nsw i64 0, %212
  %mul1415 = mul nsw i64 0, %add1414
  %add1416 = add nsw i64 %mul1415, 0
  br label %cond.end.1417

cond.end.1417:                                    ; preds = %cond.false.1413, %cond.true.1396
  %cond1418 = phi i64 [ %sub1412, %cond.true.1396 ], [ %add1416, %cond.false.1413 ]
  %cmp1419 = icmp eq i64 %cond1418, 0
  br i1 %cmp1419, label %land.lhs.true.1421, label %lor.lhs.false.1424

land.lhs.true.1421:                               ; preds = %cond.end.1417
  %213 = load i64, i64* %leni, align 8
  %cmp1422 = icmp slt i64 %213, 0
  br i1 %cmp1422, label %cond.true.1559, label %lor.lhs.false.1424

lor.lhs.false.1424:                               ; preds = %land.lhs.true.1421, %cond.end.1417
  br i1 false, label %cond.true.1425, label %cond.false.1485

cond.true.1425:                                   ; preds = %lor.lhs.false.1424
  %214 = load i64, i64* %leni, align 8
  %cmp1426 = icmp slt i64 %214, 0
  br i1 %cmp1426, label %cond.true.1428, label %cond.false.1451

cond.true.1428:                                   ; preds = %cond.true.1425
  %215 = load i64, i64* %leni, align 8
  %216 = load i64, i64* %leni, align 8
  %add1429 = add nsw i64 0, %216
  %mul1430 = mul nsw i64 0, %add1429
  %sub1431 = sub nsw i64 %mul1430, 1
  %cmp1432 = icmp slt i64 %sub1431, 0
  br i1 %cmp1432, label %cond.true.1434, label %cond.false.1442

cond.true.1434:                                   ; preds = %cond.true.1428
  %217 = load i64, i64* %leni, align 8
  %add1435 = add nsw i64 0, %217
  %mul1436 = mul nsw i64 0, %add1435
  %add1437 = add nsw i64 %mul1436, 1
  %shl1438 = shl i64 %add1437, 62
  %sub1439 = sub nsw i64 %shl1438, 1
  %mul1440 = mul nsw i64 %sub1439, 2
  %add1441 = add nsw i64 %mul1440, 1
  br label %cond.end.1446

cond.false.1442:                                  ; preds = %cond.true.1428
  %218 = load i64, i64* %leni, align 8
  %add1443 = add nsw i64 0, %218
  %mul1444 = mul nsw i64 0, %add1443
  %sub1445 = sub nsw i64 %mul1444, 1
  br label %cond.end.1446

cond.end.1446:                                    ; preds = %cond.false.1442, %cond.true.1434
  %cond1447 = phi i64 [ %add1441, %cond.true.1434 ], [ %sub1445, %cond.false.1442 ]
  %div1448 = sdiv i64 %cond1447, 8
  %cmp1449 = icmp slt i64 %215, %div1448
  br i1 %cmp1449, label %cond.true.1559, label %lor.lhs.false.1545

cond.false.1451:                                  ; preds = %cond.true.1425
  br i1 false, label %cond.true.1452, label %cond.false.1453

cond.true.1452:                                   ; preds = %cond.false.1451
  br i1 false, label %cond.true.1559, label %lor.lhs.false.1545

cond.false.1453:                                  ; preds = %cond.false.1451
  %219 = load i64, i64* %leni, align 8
  %add1454 = add nsw i64 0, %219
  %mul1455 = mul nsw i64 0, %add1454
  %sub1456 = sub nsw i64 %mul1455, 1
  %cmp1457 = icmp slt i64 %sub1456, 0
  br i1 %cmp1457, label %cond.true.1459, label %cond.false.1476

cond.true.1459:                                   ; preds = %cond.false.1453
  %220 = load i64, i64* %leni, align 8
  %add1460 = add nsw i64 0, %220
  %mul1461 = mul nsw i64 0, %add1460
  %add1462 = add nsw i64 %mul1461, 0
  %neg1463 = xor i64 %add1462, -1
  %cmp1464 = icmp eq i64 %neg1463, -1
  %conv1465 = zext i1 %cmp1464 to i32
  %sub1466 = sub nsw i32 0, %conv1465
  %conv1467 = sext i32 %sub1466 to i64
  %221 = load i64, i64* %leni, align 8
  %add1468 = add nsw i64 0, %221
  %mul1469 = mul nsw i64 0, %add1468
  %add1470 = add nsw i64 %mul1469, 1
  %shl1471 = shl i64 %add1470, 62
  %sub1472 = sub nsw i64 %shl1471, 1
  %mul1473 = mul nsw i64 %sub1472, 2
  %add1474 = add nsw i64 %mul1473, 1
  %sub1475 = sub nsw i64 %conv1467, %add1474
  br label %cond.end.1480

cond.false.1476:                                  ; preds = %cond.false.1453
  %222 = load i64, i64* %leni, align 8
  %add1477 = add nsw i64 0, %222
  %mul1478 = mul nsw i64 0, %add1477
  %add1479 = add nsw i64 %mul1478, 0
  br label %cond.end.1480

cond.end.1480:                                    ; preds = %cond.false.1476, %cond.true.1459
  %cond1481 = phi i64 [ %sub1475, %cond.true.1459 ], [ %add1479, %cond.false.1476 ]
  %div1482 = sdiv i64 %cond1481, 8
  %223 = load i64, i64* %leni, align 8
  %cmp1483 = icmp slt i64 %div1482, %223
  br i1 %cmp1483, label %cond.true.1559, label %lor.lhs.false.1545

cond.false.1485:                                  ; preds = %lor.lhs.false.1424
  br i1 false, label %cond.true.1486, label %cond.false.1487

cond.true.1486:                                   ; preds = %cond.false.1485
  br i1 false, label %cond.true.1559, label %lor.lhs.false.1545

cond.false.1487:                                  ; preds = %cond.false.1485
  %224 = load i64, i64* %leni, align 8
  %cmp1488 = icmp slt i64 %224, 0
  br i1 %cmp1488, label %cond.true.1490, label %cond.false.1522

cond.true.1490:                                   ; preds = %cond.false.1487
  %225 = load i64, i64* %leni, align 8
  %226 = load i64, i64* %leni, align 8
  %add1491 = add nsw i64 0, %226
  %mul1492 = mul nsw i64 0, %add1491
  %sub1493 = sub nsw i64 %mul1492, 1
  %cmp1494 = icmp slt i64 %sub1493, 0
  br i1 %cmp1494, label %cond.true.1496, label %cond.false.1513

cond.true.1496:                                   ; preds = %cond.true.1490
  %227 = load i64, i64* %leni, align 8
  %add1497 = add nsw i64 0, %227
  %mul1498 = mul nsw i64 0, %add1497
  %add1499 = add nsw i64 %mul1498, 0
  %neg1500 = xor i64 %add1499, -1
  %cmp1501 = icmp eq i64 %neg1500, -1
  %conv1502 = zext i1 %cmp1501 to i32
  %sub1503 = sub nsw i32 0, %conv1502
  %conv1504 = sext i32 %sub1503 to i64
  %228 = load i64, i64* %leni, align 8
  %add1505 = add nsw i64 0, %228
  %mul1506 = mul nsw i64 0, %add1505
  %add1507 = add nsw i64 %mul1506, 1
  %shl1508 = shl i64 %add1507, 62
  %sub1509 = sub nsw i64 %shl1508, 1
  %mul1510 = mul nsw i64 %sub1509, 2
  %add1511 = add nsw i64 %mul1510, 1
  %sub1512 = sub nsw i64 %conv1504, %add1511
  br label %cond.end.1517

cond.false.1513:                                  ; preds = %cond.true.1490
  %229 = load i64, i64* %leni, align 8
  %add1514 = add nsw i64 0, %229
  %mul1515 = mul nsw i64 0, %add1514
  %add1516 = add nsw i64 %mul1515, 0
  br label %cond.end.1517

cond.end.1517:                                    ; preds = %cond.false.1513, %cond.true.1496
  %cond1518 = phi i64 [ %sub1512, %cond.true.1496 ], [ %add1516, %cond.false.1513 ]
  %div1519 = sdiv i64 %cond1518, 8
  %cmp1520 = icmp slt i64 %225, %div1519
  br i1 %cmp1520, label %cond.true.1559, label %lor.lhs.false.1545

cond.false.1522:                                  ; preds = %cond.false.1487
  %230 = load i64, i64* %leni, align 8
  %add1523 = add nsw i64 0, %230
  %mul1524 = mul nsw i64 0, %add1523
  %sub1525 = sub nsw i64 %mul1524, 1
  %cmp1526 = icmp slt i64 %sub1525, 0
  br i1 %cmp1526, label %cond.true.1528, label %cond.false.1536

cond.true.1528:                                   ; preds = %cond.false.1522
  %231 = load i64, i64* %leni, align 8
  %add1529 = add nsw i64 0, %231
  %mul1530 = mul nsw i64 0, %add1529
  %add1531 = add nsw i64 %mul1530, 1
  %shl1532 = shl i64 %add1531, 62
  %sub1533 = sub nsw i64 %shl1532, 1
  %mul1534 = mul nsw i64 %sub1533, 2
  %add1535 = add nsw i64 %mul1534, 1
  br label %cond.end.1540

cond.false.1536:                                  ; preds = %cond.false.1522
  %232 = load i64, i64* %leni, align 8
  %add1537 = add nsw i64 0, %232
  %mul1538 = mul nsw i64 0, %add1537
  %sub1539 = sub nsw i64 %mul1538, 1
  br label %cond.end.1540

cond.end.1540:                                    ; preds = %cond.false.1536, %cond.true.1528
  %cond1541 = phi i64 [ %add1535, %cond.true.1528 ], [ %sub1539, %cond.false.1536 ]
  %div1542 = sdiv i64 %cond1541, 8
  %233 = load i64, i64* %leni, align 8
  %cmp1543 = icmp slt i64 %div1542, %233
  br i1 %cmp1543, label %cond.true.1559, label %lor.lhs.false.1545

lor.lhs.false.1545:                               ; preds = %cond.end.1540, %cond.end.1517, %cond.true.1486, %cond.end.1480, %cond.true.1452, %cond.end.1446
  %234 = load i64, i64* %leni, align 8
  %mul1546 = mul nsw i64 %234, 8
  %mul1547 = mul nsw i64 0, %mul1546
  %sub1548 = sub nsw i64 %mul1547, 1
  %cmp1549 = icmp slt i64 %sub1548, 0
  br i1 %cmp1549, label %land.lhs.true.1551, label %lor.lhs.false.1555

land.lhs.true.1551:                               ; preds = %lor.lhs.false.1545
  %235 = load i64, i64* %leni, align 8
  %mul1552 = mul nsw i64 %235, 8
  %cmp1553 = icmp slt i64 %mul1552, -9223372036854775808
  br i1 %cmp1553, label %cond.true.1559, label %lor.lhs.false.1555

lor.lhs.false.1555:                               ; preds = %land.lhs.true.1551, %lor.lhs.false.1545
  %236 = load i64, i64* %leni, align 8
  %mul1556 = mul nsw i64 %236, 8
  %cmp1557 = icmp slt i64 9223372036854775807, %mul1556
  br i1 %cmp1557, label %cond.true.1559, label %cond.false.1571

cond.true.1559:                                   ; preds = %lor.lhs.false.1555, %land.lhs.true.1551, %cond.end.1540, %cond.end.1517, %cond.true.1486, %cond.end.1480, %cond.true.1452, %cond.end.1446, %land.lhs.true.1421
  %237 = load i64, i64* %leni, align 8
  %mul1560 = mul i64 %237, 8
  %cmp1561 = icmp ule i64 %mul1560, 9223372036854775807
  br i1 %cmp1561, label %cond.true.1563, label %cond.false.1565

cond.true.1563:                                   ; preds = %cond.true.1559
  %238 = load i64, i64* %leni, align 8
  %mul1564 = mul i64 %238, 8
  br label %cond.end.1569

cond.false.1565:                                  ; preds = %cond.true.1559
  %239 = load i64, i64* %leni, align 8
  %mul1566 = mul i64 %239, 8
  %sub1567 = sub i64 %mul1566, -9223372036854775808
  %add1568 = add nsw i64 %sub1567, -9223372036854775808
  br label %cond.end.1569

cond.end.1569:                                    ; preds = %cond.false.1565, %cond.true.1563
  %cond1570 = phi i64 [ %mul1564, %cond.true.1563 ], [ %add1568, %cond.false.1565 ]
  store i64 %cond1570, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2166, label %lor.lhs.false.2163

cond.false.1571:                                  ; preds = %lor.lhs.false.1555
  %240 = load i64, i64* %leni, align 8
  %mul1572 = mul i64 %240, 8
  %cmp1573 = icmp ule i64 %mul1572, 9223372036854775807
  br i1 %cmp1573, label %cond.true.1575, label %cond.false.1577

cond.true.1575:                                   ; preds = %cond.false.1571
  %241 = load i64, i64* %leni, align 8
  %mul1576 = mul i64 %241, 8
  br label %cond.end.1581

cond.false.1577:                                  ; preds = %cond.false.1571
  %242 = load i64, i64* %leni, align 8
  %mul1578 = mul i64 %242, 8
  %sub1579 = sub i64 %mul1578, -9223372036854775808
  %add1580 = add nsw i64 %sub1579, -9223372036854775808
  br label %cond.end.1581

cond.end.1581:                                    ; preds = %cond.false.1577, %cond.true.1575
  %cond1582 = phi i64 [ %mul1576, %cond.true.1575 ], [ %add1580, %cond.false.1577 ]
  store i64 %cond1582, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2166, label %lor.lhs.false.2163

cond.false.1583:                                  ; preds = %cond.true.1389
  %243 = load i64, i64* %leni, align 8
  %add1584 = add nsw i64 0, %243
  %mul1585 = mul nsw i64 0, %add1584
  %sub1586 = sub nsw i64 %mul1585, 1
  %cmp1587 = icmp slt i64 %sub1586, 0
  br i1 %cmp1587, label %cond.true.1589, label %cond.false.1606

cond.true.1589:                                   ; preds = %cond.false.1583
  %244 = load i64, i64* %leni, align 8
  %add1590 = add nsw i64 0, %244
  %mul1591 = mul nsw i64 0, %add1590
  %add1592 = add nsw i64 %mul1591, 0
  %neg1593 = xor i64 %add1592, -1
  %cmp1594 = icmp eq i64 %neg1593, -1
  %conv1595 = zext i1 %cmp1594 to i32
  %sub1596 = sub nsw i32 0, %conv1595
  %conv1597 = sext i32 %sub1596 to i64
  %245 = load i64, i64* %leni, align 8
  %add1598 = add nsw i64 0, %245
  %mul1599 = mul nsw i64 0, %add1598
  %add1600 = add nsw i64 %mul1599, 1
  %shl1601 = shl i64 %add1600, 62
  %sub1602 = sub nsw i64 %shl1601, 1
  %mul1603 = mul nsw i64 %sub1602, 2
  %add1604 = add nsw i64 %mul1603, 1
  %sub1605 = sub nsw i64 %conv1597, %add1604
  br label %cond.end.1610

cond.false.1606:                                  ; preds = %cond.false.1583
  %246 = load i64, i64* %leni, align 8
  %add1607 = add nsw i64 0, %246
  %mul1608 = mul nsw i64 0, %add1607
  %add1609 = add nsw i64 %mul1608, 0
  br label %cond.end.1610

cond.end.1610:                                    ; preds = %cond.false.1606, %cond.true.1589
  %cond1611 = phi i64 [ %sub1605, %cond.true.1589 ], [ %add1609, %cond.false.1606 ]
  %cmp1612 = icmp eq i64 %cond1611, 0
  br i1 %cmp1612, label %land.lhs.true.1614, label %lor.lhs.false.1617

land.lhs.true.1614:                               ; preds = %cond.end.1610
  %247 = load i64, i64* %leni, align 8
  %cmp1615 = icmp slt i64 %247, 0
  br i1 %cmp1615, label %cond.true.1752, label %lor.lhs.false.1617

lor.lhs.false.1617:                               ; preds = %land.lhs.true.1614, %cond.end.1610
  br i1 false, label %cond.true.1618, label %cond.false.1678

cond.true.1618:                                   ; preds = %lor.lhs.false.1617
  %248 = load i64, i64* %leni, align 8
  %cmp1619 = icmp slt i64 %248, 0
  br i1 %cmp1619, label %cond.true.1621, label %cond.false.1644

cond.true.1621:                                   ; preds = %cond.true.1618
  %249 = load i64, i64* %leni, align 8
  %250 = load i64, i64* %leni, align 8
  %add1622 = add nsw i64 0, %250
  %mul1623 = mul nsw i64 0, %add1622
  %sub1624 = sub nsw i64 %mul1623, 1
  %cmp1625 = icmp slt i64 %sub1624, 0
  br i1 %cmp1625, label %cond.true.1627, label %cond.false.1635

cond.true.1627:                                   ; preds = %cond.true.1621
  %251 = load i64, i64* %leni, align 8
  %add1628 = add nsw i64 0, %251
  %mul1629 = mul nsw i64 0, %add1628
  %add1630 = add nsw i64 %mul1629, 1
  %shl1631 = shl i64 %add1630, 62
  %sub1632 = sub nsw i64 %shl1631, 1
  %mul1633 = mul nsw i64 %sub1632, 2
  %add1634 = add nsw i64 %mul1633, 1
  br label %cond.end.1639

cond.false.1635:                                  ; preds = %cond.true.1621
  %252 = load i64, i64* %leni, align 8
  %add1636 = add nsw i64 0, %252
  %mul1637 = mul nsw i64 0, %add1636
  %sub1638 = sub nsw i64 %mul1637, 1
  br label %cond.end.1639

cond.end.1639:                                    ; preds = %cond.false.1635, %cond.true.1627
  %cond1640 = phi i64 [ %add1634, %cond.true.1627 ], [ %sub1638, %cond.false.1635 ]
  %div1641 = sdiv i64 %cond1640, 8
  %cmp1642 = icmp slt i64 %249, %div1641
  br i1 %cmp1642, label %cond.true.1752, label %lor.lhs.false.1738

cond.false.1644:                                  ; preds = %cond.true.1618
  br i1 false, label %cond.true.1645, label %cond.false.1646

cond.true.1645:                                   ; preds = %cond.false.1644
  br i1 false, label %cond.true.1752, label %lor.lhs.false.1738

cond.false.1646:                                  ; preds = %cond.false.1644
  %253 = load i64, i64* %leni, align 8
  %add1647 = add nsw i64 0, %253
  %mul1648 = mul nsw i64 0, %add1647
  %sub1649 = sub nsw i64 %mul1648, 1
  %cmp1650 = icmp slt i64 %sub1649, 0
  br i1 %cmp1650, label %cond.true.1652, label %cond.false.1669

cond.true.1652:                                   ; preds = %cond.false.1646
  %254 = load i64, i64* %leni, align 8
  %add1653 = add nsw i64 0, %254
  %mul1654 = mul nsw i64 0, %add1653
  %add1655 = add nsw i64 %mul1654, 0
  %neg1656 = xor i64 %add1655, -1
  %cmp1657 = icmp eq i64 %neg1656, -1
  %conv1658 = zext i1 %cmp1657 to i32
  %sub1659 = sub nsw i32 0, %conv1658
  %conv1660 = sext i32 %sub1659 to i64
  %255 = load i64, i64* %leni, align 8
  %add1661 = add nsw i64 0, %255
  %mul1662 = mul nsw i64 0, %add1661
  %add1663 = add nsw i64 %mul1662, 1
  %shl1664 = shl i64 %add1663, 62
  %sub1665 = sub nsw i64 %shl1664, 1
  %mul1666 = mul nsw i64 %sub1665, 2
  %add1667 = add nsw i64 %mul1666, 1
  %sub1668 = sub nsw i64 %conv1660, %add1667
  br label %cond.end.1673

cond.false.1669:                                  ; preds = %cond.false.1646
  %256 = load i64, i64* %leni, align 8
  %add1670 = add nsw i64 0, %256
  %mul1671 = mul nsw i64 0, %add1670
  %add1672 = add nsw i64 %mul1671, 0
  br label %cond.end.1673

cond.end.1673:                                    ; preds = %cond.false.1669, %cond.true.1652
  %cond1674 = phi i64 [ %sub1668, %cond.true.1652 ], [ %add1672, %cond.false.1669 ]
  %div1675 = sdiv i64 %cond1674, 8
  %257 = load i64, i64* %leni, align 8
  %cmp1676 = icmp slt i64 %div1675, %257
  br i1 %cmp1676, label %cond.true.1752, label %lor.lhs.false.1738

cond.false.1678:                                  ; preds = %lor.lhs.false.1617
  br i1 false, label %cond.true.1679, label %cond.false.1680

cond.true.1679:                                   ; preds = %cond.false.1678
  br i1 false, label %cond.true.1752, label %lor.lhs.false.1738

cond.false.1680:                                  ; preds = %cond.false.1678
  %258 = load i64, i64* %leni, align 8
  %cmp1681 = icmp slt i64 %258, 0
  br i1 %cmp1681, label %cond.true.1683, label %cond.false.1715

cond.true.1683:                                   ; preds = %cond.false.1680
  %259 = load i64, i64* %leni, align 8
  %260 = load i64, i64* %leni, align 8
  %add1684 = add nsw i64 0, %260
  %mul1685 = mul nsw i64 0, %add1684
  %sub1686 = sub nsw i64 %mul1685, 1
  %cmp1687 = icmp slt i64 %sub1686, 0
  br i1 %cmp1687, label %cond.true.1689, label %cond.false.1706

cond.true.1689:                                   ; preds = %cond.true.1683
  %261 = load i64, i64* %leni, align 8
  %add1690 = add nsw i64 0, %261
  %mul1691 = mul nsw i64 0, %add1690
  %add1692 = add nsw i64 %mul1691, 0
  %neg1693 = xor i64 %add1692, -1
  %cmp1694 = icmp eq i64 %neg1693, -1
  %conv1695 = zext i1 %cmp1694 to i32
  %sub1696 = sub nsw i32 0, %conv1695
  %conv1697 = sext i32 %sub1696 to i64
  %262 = load i64, i64* %leni, align 8
  %add1698 = add nsw i64 0, %262
  %mul1699 = mul nsw i64 0, %add1698
  %add1700 = add nsw i64 %mul1699, 1
  %shl1701 = shl i64 %add1700, 62
  %sub1702 = sub nsw i64 %shl1701, 1
  %mul1703 = mul nsw i64 %sub1702, 2
  %add1704 = add nsw i64 %mul1703, 1
  %sub1705 = sub nsw i64 %conv1697, %add1704
  br label %cond.end.1710

cond.false.1706:                                  ; preds = %cond.true.1683
  %263 = load i64, i64* %leni, align 8
  %add1707 = add nsw i64 0, %263
  %mul1708 = mul nsw i64 0, %add1707
  %add1709 = add nsw i64 %mul1708, 0
  br label %cond.end.1710

cond.end.1710:                                    ; preds = %cond.false.1706, %cond.true.1689
  %cond1711 = phi i64 [ %sub1705, %cond.true.1689 ], [ %add1709, %cond.false.1706 ]
  %div1712 = sdiv i64 %cond1711, 8
  %cmp1713 = icmp slt i64 %259, %div1712
  br i1 %cmp1713, label %cond.true.1752, label %lor.lhs.false.1738

cond.false.1715:                                  ; preds = %cond.false.1680
  %264 = load i64, i64* %leni, align 8
  %add1716 = add nsw i64 0, %264
  %mul1717 = mul nsw i64 0, %add1716
  %sub1718 = sub nsw i64 %mul1717, 1
  %cmp1719 = icmp slt i64 %sub1718, 0
  br i1 %cmp1719, label %cond.true.1721, label %cond.false.1729

cond.true.1721:                                   ; preds = %cond.false.1715
  %265 = load i64, i64* %leni, align 8
  %add1722 = add nsw i64 0, %265
  %mul1723 = mul nsw i64 0, %add1722
  %add1724 = add nsw i64 %mul1723, 1
  %shl1725 = shl i64 %add1724, 62
  %sub1726 = sub nsw i64 %shl1725, 1
  %mul1727 = mul nsw i64 %sub1726, 2
  %add1728 = add nsw i64 %mul1727, 1
  br label %cond.end.1733

cond.false.1729:                                  ; preds = %cond.false.1715
  %266 = load i64, i64* %leni, align 8
  %add1730 = add nsw i64 0, %266
  %mul1731 = mul nsw i64 0, %add1730
  %sub1732 = sub nsw i64 %mul1731, 1
  br label %cond.end.1733

cond.end.1733:                                    ; preds = %cond.false.1729, %cond.true.1721
  %cond1734 = phi i64 [ %add1728, %cond.true.1721 ], [ %sub1732, %cond.false.1729 ]
  %div1735 = sdiv i64 %cond1734, 8
  %267 = load i64, i64* %leni, align 8
  %cmp1736 = icmp slt i64 %div1735, %267
  br i1 %cmp1736, label %cond.true.1752, label %lor.lhs.false.1738

lor.lhs.false.1738:                               ; preds = %cond.end.1733, %cond.end.1710, %cond.true.1679, %cond.end.1673, %cond.true.1645, %cond.end.1639
  %268 = load i64, i64* %leni, align 8
  %mul1739 = mul nsw i64 %268, 8
  %mul1740 = mul nsw i64 0, %mul1739
  %sub1741 = sub nsw i64 %mul1740, 1
  %cmp1742 = icmp slt i64 %sub1741, 0
  br i1 %cmp1742, label %land.lhs.true.1744, label %lor.lhs.false.1748

land.lhs.true.1744:                               ; preds = %lor.lhs.false.1738
  %269 = load i64, i64* %leni, align 8
  %mul1745 = mul nsw i64 %269, 8
  %cmp1746 = icmp slt i64 %mul1745, -9223372036854775808
  br i1 %cmp1746, label %cond.true.1752, label %lor.lhs.false.1748

lor.lhs.false.1748:                               ; preds = %land.lhs.true.1744, %lor.lhs.false.1738
  %270 = load i64, i64* %leni, align 8
  %mul1749 = mul nsw i64 %270, 8
  %cmp1750 = icmp slt i64 9223372036854775807, %mul1749
  br i1 %cmp1750, label %cond.true.1752, label %cond.false.1764

cond.true.1752:                                   ; preds = %lor.lhs.false.1748, %land.lhs.true.1744, %cond.end.1733, %cond.end.1710, %cond.true.1679, %cond.end.1673, %cond.true.1645, %cond.end.1639, %land.lhs.true.1614
  %271 = load i64, i64* %leni, align 8
  %mul1753 = mul i64 %271, 8
  %cmp1754 = icmp ule i64 %mul1753, 9223372036854775807
  br i1 %cmp1754, label %cond.true.1756, label %cond.false.1758

cond.true.1756:                                   ; preds = %cond.true.1752
  %272 = load i64, i64* %leni, align 8
  %mul1757 = mul i64 %272, 8
  br label %cond.end.1762

cond.false.1758:                                  ; preds = %cond.true.1752
  %273 = load i64, i64* %leni, align 8
  %mul1759 = mul i64 %273, 8
  %sub1760 = sub i64 %mul1759, -9223372036854775808
  %add1761 = add nsw i64 %sub1760, -9223372036854775808
  br label %cond.end.1762

cond.end.1762:                                    ; preds = %cond.false.1758, %cond.true.1756
  %cond1763 = phi i64 [ %mul1757, %cond.true.1756 ], [ %add1761, %cond.false.1758 ]
  store i64 %cond1763, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2166, label %lor.lhs.false.2163

cond.false.1764:                                  ; preds = %lor.lhs.false.1748
  %274 = load i64, i64* %leni, align 8
  %mul1765 = mul i64 %274, 8
  %cmp1766 = icmp ule i64 %mul1765, 9223372036854775807
  br i1 %cmp1766, label %cond.true.1768, label %cond.false.1770

cond.true.1768:                                   ; preds = %cond.false.1764
  %275 = load i64, i64* %leni, align 8
  %mul1769 = mul i64 %275, 8
  br label %cond.end.1774

cond.false.1770:                                  ; preds = %cond.false.1764
  %276 = load i64, i64* %leni, align 8
  %mul1771 = mul i64 %276, 8
  %sub1772 = sub i64 %mul1771, -9223372036854775808
  %add1773 = add nsw i64 %sub1772, -9223372036854775808
  br label %cond.end.1774

cond.end.1774:                                    ; preds = %cond.false.1770, %cond.true.1768
  %cond1775 = phi i64 [ %mul1769, %cond.true.1768 ], [ %add1773, %cond.false.1770 ]
  store i64 %cond1775, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2166, label %lor.lhs.false.2163

cond.false.1776:                                  ; preds = %cond.false.1388
  br i1 false, label %cond.true.1777, label %cond.false.1970

cond.true.1777:                                   ; preds = %cond.false.1776
  %277 = load i64, i64* %leni, align 8
  %add1778 = add nsw i64 0, %277
  %mul1779 = mul nsw i64 0, %add1778
  %sub1780 = sub nsw i64 %mul1779, 1
  %cmp1781 = icmp slt i64 %sub1780, 0
  br i1 %cmp1781, label %cond.true.1783, label %cond.false.1800

cond.true.1783:                                   ; preds = %cond.true.1777
  %278 = load i64, i64* %leni, align 8
  %add1784 = add nsw i64 0, %278
  %mul1785 = mul nsw i64 0, %add1784
  %add1786 = add nsw i64 %mul1785, 0
  %neg1787 = xor i64 %add1786, -1
  %cmp1788 = icmp eq i64 %neg1787, -1
  %conv1789 = zext i1 %cmp1788 to i32
  %sub1790 = sub nsw i32 0, %conv1789
  %conv1791 = sext i32 %sub1790 to i64
  %279 = load i64, i64* %leni, align 8
  %add1792 = add nsw i64 0, %279
  %mul1793 = mul nsw i64 0, %add1792
  %add1794 = add nsw i64 %mul1793, 1
  %shl1795 = shl i64 %add1794, 62
  %sub1796 = sub nsw i64 %shl1795, 1
  %mul1797 = mul nsw i64 %sub1796, 2
  %add1798 = add nsw i64 %mul1797, 1
  %sub1799 = sub nsw i64 %conv1791, %add1798
  br label %cond.end.1804

cond.false.1800:                                  ; preds = %cond.true.1777
  %280 = load i64, i64* %leni, align 8
  %add1801 = add nsw i64 0, %280
  %mul1802 = mul nsw i64 0, %add1801
  %add1803 = add nsw i64 %mul1802, 0
  br label %cond.end.1804

cond.end.1804:                                    ; preds = %cond.false.1800, %cond.true.1783
  %cond1805 = phi i64 [ %sub1799, %cond.true.1783 ], [ %add1803, %cond.false.1800 ]
  %cmp1806 = icmp eq i64 %cond1805, 0
  br i1 %cmp1806, label %land.lhs.true.1808, label %lor.lhs.false.1811

land.lhs.true.1808:                               ; preds = %cond.end.1804
  %281 = load i64, i64* %leni, align 8
  %cmp1809 = icmp slt i64 %281, 0
  br i1 %cmp1809, label %cond.true.1946, label %lor.lhs.false.1811

lor.lhs.false.1811:                               ; preds = %land.lhs.true.1808, %cond.end.1804
  br i1 false, label %cond.true.1812, label %cond.false.1872

cond.true.1812:                                   ; preds = %lor.lhs.false.1811
  %282 = load i64, i64* %leni, align 8
  %cmp1813 = icmp slt i64 %282, 0
  br i1 %cmp1813, label %cond.true.1815, label %cond.false.1838

cond.true.1815:                                   ; preds = %cond.true.1812
  %283 = load i64, i64* %leni, align 8
  %284 = load i64, i64* %leni, align 8
  %add1816 = add nsw i64 0, %284
  %mul1817 = mul nsw i64 0, %add1816
  %sub1818 = sub nsw i64 %mul1817, 1
  %cmp1819 = icmp slt i64 %sub1818, 0
  br i1 %cmp1819, label %cond.true.1821, label %cond.false.1829

cond.true.1821:                                   ; preds = %cond.true.1815
  %285 = load i64, i64* %leni, align 8
  %add1822 = add nsw i64 0, %285
  %mul1823 = mul nsw i64 0, %add1822
  %add1824 = add nsw i64 %mul1823, 1
  %shl1825 = shl i64 %add1824, 62
  %sub1826 = sub nsw i64 %shl1825, 1
  %mul1827 = mul nsw i64 %sub1826, 2
  %add1828 = add nsw i64 %mul1827, 1
  br label %cond.end.1833

cond.false.1829:                                  ; preds = %cond.true.1815
  %286 = load i64, i64* %leni, align 8
  %add1830 = add nsw i64 0, %286
  %mul1831 = mul nsw i64 0, %add1830
  %sub1832 = sub nsw i64 %mul1831, 1
  br label %cond.end.1833

cond.end.1833:                                    ; preds = %cond.false.1829, %cond.true.1821
  %cond1834 = phi i64 [ %add1828, %cond.true.1821 ], [ %sub1832, %cond.false.1829 ]
  %div1835 = sdiv i64 %cond1834, 8
  %cmp1836 = icmp slt i64 %283, %div1835
  br i1 %cmp1836, label %cond.true.1946, label %lor.lhs.false.1932

cond.false.1838:                                  ; preds = %cond.true.1812
  br i1 false, label %cond.true.1839, label %cond.false.1840

cond.true.1839:                                   ; preds = %cond.false.1838
  br i1 false, label %cond.true.1946, label %lor.lhs.false.1932

cond.false.1840:                                  ; preds = %cond.false.1838
  %287 = load i64, i64* %leni, align 8
  %add1841 = add nsw i64 0, %287
  %mul1842 = mul nsw i64 0, %add1841
  %sub1843 = sub nsw i64 %mul1842, 1
  %cmp1844 = icmp slt i64 %sub1843, 0
  br i1 %cmp1844, label %cond.true.1846, label %cond.false.1863

cond.true.1846:                                   ; preds = %cond.false.1840
  %288 = load i64, i64* %leni, align 8
  %add1847 = add nsw i64 0, %288
  %mul1848 = mul nsw i64 0, %add1847
  %add1849 = add nsw i64 %mul1848, 0
  %neg1850 = xor i64 %add1849, -1
  %cmp1851 = icmp eq i64 %neg1850, -1
  %conv1852 = zext i1 %cmp1851 to i32
  %sub1853 = sub nsw i32 0, %conv1852
  %conv1854 = sext i32 %sub1853 to i64
  %289 = load i64, i64* %leni, align 8
  %add1855 = add nsw i64 0, %289
  %mul1856 = mul nsw i64 0, %add1855
  %add1857 = add nsw i64 %mul1856, 1
  %shl1858 = shl i64 %add1857, 62
  %sub1859 = sub nsw i64 %shl1858, 1
  %mul1860 = mul nsw i64 %sub1859, 2
  %add1861 = add nsw i64 %mul1860, 1
  %sub1862 = sub nsw i64 %conv1854, %add1861
  br label %cond.end.1867

cond.false.1863:                                  ; preds = %cond.false.1840
  %290 = load i64, i64* %leni, align 8
  %add1864 = add nsw i64 0, %290
  %mul1865 = mul nsw i64 0, %add1864
  %add1866 = add nsw i64 %mul1865, 0
  br label %cond.end.1867

cond.end.1867:                                    ; preds = %cond.false.1863, %cond.true.1846
  %cond1868 = phi i64 [ %sub1862, %cond.true.1846 ], [ %add1866, %cond.false.1863 ]
  %div1869 = sdiv i64 %cond1868, 8
  %291 = load i64, i64* %leni, align 8
  %cmp1870 = icmp slt i64 %div1869, %291
  br i1 %cmp1870, label %cond.true.1946, label %lor.lhs.false.1932

cond.false.1872:                                  ; preds = %lor.lhs.false.1811
  br i1 false, label %cond.true.1873, label %cond.false.1874

cond.true.1873:                                   ; preds = %cond.false.1872
  br i1 false, label %cond.true.1946, label %lor.lhs.false.1932

cond.false.1874:                                  ; preds = %cond.false.1872
  %292 = load i64, i64* %leni, align 8
  %cmp1875 = icmp slt i64 %292, 0
  br i1 %cmp1875, label %cond.true.1877, label %cond.false.1909

cond.true.1877:                                   ; preds = %cond.false.1874
  %293 = load i64, i64* %leni, align 8
  %294 = load i64, i64* %leni, align 8
  %add1878 = add nsw i64 0, %294
  %mul1879 = mul nsw i64 0, %add1878
  %sub1880 = sub nsw i64 %mul1879, 1
  %cmp1881 = icmp slt i64 %sub1880, 0
  br i1 %cmp1881, label %cond.true.1883, label %cond.false.1900

cond.true.1883:                                   ; preds = %cond.true.1877
  %295 = load i64, i64* %leni, align 8
  %add1884 = add nsw i64 0, %295
  %mul1885 = mul nsw i64 0, %add1884
  %add1886 = add nsw i64 %mul1885, 0
  %neg1887 = xor i64 %add1886, -1
  %cmp1888 = icmp eq i64 %neg1887, -1
  %conv1889 = zext i1 %cmp1888 to i32
  %sub1890 = sub nsw i32 0, %conv1889
  %conv1891 = sext i32 %sub1890 to i64
  %296 = load i64, i64* %leni, align 8
  %add1892 = add nsw i64 0, %296
  %mul1893 = mul nsw i64 0, %add1892
  %add1894 = add nsw i64 %mul1893, 1
  %shl1895 = shl i64 %add1894, 62
  %sub1896 = sub nsw i64 %shl1895, 1
  %mul1897 = mul nsw i64 %sub1896, 2
  %add1898 = add nsw i64 %mul1897, 1
  %sub1899 = sub nsw i64 %conv1891, %add1898
  br label %cond.end.1904

cond.false.1900:                                  ; preds = %cond.true.1877
  %297 = load i64, i64* %leni, align 8
  %add1901 = add nsw i64 0, %297
  %mul1902 = mul nsw i64 0, %add1901
  %add1903 = add nsw i64 %mul1902, 0
  br label %cond.end.1904

cond.end.1904:                                    ; preds = %cond.false.1900, %cond.true.1883
  %cond1905 = phi i64 [ %sub1899, %cond.true.1883 ], [ %add1903, %cond.false.1900 ]
  %div1906 = sdiv i64 %cond1905, 8
  %cmp1907 = icmp slt i64 %293, %div1906
  br i1 %cmp1907, label %cond.true.1946, label %lor.lhs.false.1932

cond.false.1909:                                  ; preds = %cond.false.1874
  %298 = load i64, i64* %leni, align 8
  %add1910 = add nsw i64 0, %298
  %mul1911 = mul nsw i64 0, %add1910
  %sub1912 = sub nsw i64 %mul1911, 1
  %cmp1913 = icmp slt i64 %sub1912, 0
  br i1 %cmp1913, label %cond.true.1915, label %cond.false.1923

cond.true.1915:                                   ; preds = %cond.false.1909
  %299 = load i64, i64* %leni, align 8
  %add1916 = add nsw i64 0, %299
  %mul1917 = mul nsw i64 0, %add1916
  %add1918 = add nsw i64 %mul1917, 1
  %shl1919 = shl i64 %add1918, 62
  %sub1920 = sub nsw i64 %shl1919, 1
  %mul1921 = mul nsw i64 %sub1920, 2
  %add1922 = add nsw i64 %mul1921, 1
  br label %cond.end.1927

cond.false.1923:                                  ; preds = %cond.false.1909
  %300 = load i64, i64* %leni, align 8
  %add1924 = add nsw i64 0, %300
  %mul1925 = mul nsw i64 0, %add1924
  %sub1926 = sub nsw i64 %mul1925, 1
  br label %cond.end.1927

cond.end.1927:                                    ; preds = %cond.false.1923, %cond.true.1915
  %cond1928 = phi i64 [ %add1922, %cond.true.1915 ], [ %sub1926, %cond.false.1923 ]
  %div1929 = sdiv i64 %cond1928, 8
  %301 = load i64, i64* %leni, align 8
  %cmp1930 = icmp slt i64 %div1929, %301
  br i1 %cmp1930, label %cond.true.1946, label %lor.lhs.false.1932

lor.lhs.false.1932:                               ; preds = %cond.end.1927, %cond.end.1904, %cond.true.1873, %cond.end.1867, %cond.true.1839, %cond.end.1833
  %302 = load i64, i64* %leni, align 8
  %mul1933 = mul nsw i64 %302, 8
  %mul1934 = mul nsw i64 0, %mul1933
  %sub1935 = sub nsw i64 %mul1934, 1
  %cmp1936 = icmp slt i64 %sub1935, 0
  br i1 %cmp1936, label %land.lhs.true.1938, label %lor.lhs.false.1942

land.lhs.true.1938:                               ; preds = %lor.lhs.false.1932
  %303 = load i64, i64* %leni, align 8
  %mul1939 = mul nsw i64 %303, 8
  %cmp1940 = icmp slt i64 %mul1939, -9223372036854775808
  br i1 %cmp1940, label %cond.true.1946, label %lor.lhs.false.1942

lor.lhs.false.1942:                               ; preds = %land.lhs.true.1938, %lor.lhs.false.1932
  %304 = load i64, i64* %leni, align 8
  %mul1943 = mul nsw i64 %304, 8
  %cmp1944 = icmp slt i64 9223372036854775807, %mul1943
  br i1 %cmp1944, label %cond.true.1946, label %cond.false.1958

cond.true.1946:                                   ; preds = %lor.lhs.false.1942, %land.lhs.true.1938, %cond.end.1927, %cond.end.1904, %cond.true.1873, %cond.end.1867, %cond.true.1839, %cond.end.1833, %land.lhs.true.1808
  %305 = load i64, i64* %leni, align 8
  %mul1947 = mul i64 %305, 8
  %cmp1948 = icmp ule i64 %mul1947, 9223372036854775807
  br i1 %cmp1948, label %cond.true.1950, label %cond.false.1952

cond.true.1950:                                   ; preds = %cond.true.1946
  %306 = load i64, i64* %leni, align 8
  %mul1951 = mul i64 %306, 8
  br label %cond.end.1956

cond.false.1952:                                  ; preds = %cond.true.1946
  %307 = load i64, i64* %leni, align 8
  %mul1953 = mul i64 %307, 8
  %sub1954 = sub i64 %mul1953, -9223372036854775808
  %add1955 = add nsw i64 %sub1954, -9223372036854775808
  br label %cond.end.1956

cond.end.1956:                                    ; preds = %cond.false.1952, %cond.true.1950
  %cond1957 = phi i64 [ %mul1951, %cond.true.1950 ], [ %add1955, %cond.false.1952 ]
  store i64 %cond1957, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2166, label %lor.lhs.false.2163

cond.false.1958:                                  ; preds = %lor.lhs.false.1942
  %308 = load i64, i64* %leni, align 8
  %mul1959 = mul i64 %308, 8
  %cmp1960 = icmp ule i64 %mul1959, 9223372036854775807
  br i1 %cmp1960, label %cond.true.1962, label %cond.false.1964

cond.true.1962:                                   ; preds = %cond.false.1958
  %309 = load i64, i64* %leni, align 8
  %mul1963 = mul i64 %309, 8
  br label %cond.end.1968

cond.false.1964:                                  ; preds = %cond.false.1958
  %310 = load i64, i64* %leni, align 8
  %mul1965 = mul i64 %310, 8
  %sub1966 = sub i64 %mul1965, -9223372036854775808
  %add1967 = add nsw i64 %sub1966, -9223372036854775808
  br label %cond.end.1968

cond.end.1968:                                    ; preds = %cond.false.1964, %cond.true.1962
  %cond1969 = phi i64 [ %mul1963, %cond.true.1962 ], [ %add1967, %cond.false.1964 ]
  store i64 %cond1969, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2166, label %lor.lhs.false.2163

cond.false.1970:                                  ; preds = %cond.false.1776
  %311 = load i64, i64* %leni, align 8
  %add1971 = add nsw i64 0, %311
  %mul1972 = mul nsw i64 0, %add1971
  %sub1973 = sub nsw i64 %mul1972, 1
  %cmp1974 = icmp slt i64 %sub1973, 0
  br i1 %cmp1974, label %cond.true.1976, label %cond.false.1993

cond.true.1976:                                   ; preds = %cond.false.1970
  %312 = load i64, i64* %leni, align 8
  %add1977 = add nsw i64 0, %312
  %mul1978 = mul nsw i64 0, %add1977
  %add1979 = add nsw i64 %mul1978, 0
  %neg1980 = xor i64 %add1979, -1
  %cmp1981 = icmp eq i64 %neg1980, -1
  %conv1982 = zext i1 %cmp1981 to i32
  %sub1983 = sub nsw i32 0, %conv1982
  %conv1984 = sext i32 %sub1983 to i64
  %313 = load i64, i64* %leni, align 8
  %add1985 = add nsw i64 0, %313
  %mul1986 = mul nsw i64 0, %add1985
  %add1987 = add nsw i64 %mul1986, 1
  %shl1988 = shl i64 %add1987, 62
  %sub1989 = sub nsw i64 %shl1988, 1
  %mul1990 = mul nsw i64 %sub1989, 2
  %add1991 = add nsw i64 %mul1990, 1
  %sub1992 = sub nsw i64 %conv1984, %add1991
  br label %cond.end.1997

cond.false.1993:                                  ; preds = %cond.false.1970
  %314 = load i64, i64* %leni, align 8
  %add1994 = add nsw i64 0, %314
  %mul1995 = mul nsw i64 0, %add1994
  %add1996 = add nsw i64 %mul1995, 0
  br label %cond.end.1997

cond.end.1997:                                    ; preds = %cond.false.1993, %cond.true.1976
  %cond1998 = phi i64 [ %sub1992, %cond.true.1976 ], [ %add1996, %cond.false.1993 ]
  %cmp1999 = icmp eq i64 %cond1998, 0
  br i1 %cmp1999, label %land.lhs.true.2001, label %lor.lhs.false.2004

land.lhs.true.2001:                               ; preds = %cond.end.1997
  %315 = load i64, i64* %leni, align 8
  %cmp2002 = icmp slt i64 %315, 0
  br i1 %cmp2002, label %cond.true.2139, label %lor.lhs.false.2004

lor.lhs.false.2004:                               ; preds = %land.lhs.true.2001, %cond.end.1997
  br i1 false, label %cond.true.2005, label %cond.false.2065

cond.true.2005:                                   ; preds = %lor.lhs.false.2004
  %316 = load i64, i64* %leni, align 8
  %cmp2006 = icmp slt i64 %316, 0
  br i1 %cmp2006, label %cond.true.2008, label %cond.false.2031

cond.true.2008:                                   ; preds = %cond.true.2005
  %317 = load i64, i64* %leni, align 8
  %318 = load i64, i64* %leni, align 8
  %add2009 = add nsw i64 0, %318
  %mul2010 = mul nsw i64 0, %add2009
  %sub2011 = sub nsw i64 %mul2010, 1
  %cmp2012 = icmp slt i64 %sub2011, 0
  br i1 %cmp2012, label %cond.true.2014, label %cond.false.2022

cond.true.2014:                                   ; preds = %cond.true.2008
  %319 = load i64, i64* %leni, align 8
  %add2015 = add nsw i64 0, %319
  %mul2016 = mul nsw i64 0, %add2015
  %add2017 = add nsw i64 %mul2016, 1
  %shl2018 = shl i64 %add2017, 62
  %sub2019 = sub nsw i64 %shl2018, 1
  %mul2020 = mul nsw i64 %sub2019, 2
  %add2021 = add nsw i64 %mul2020, 1
  br label %cond.end.2026

cond.false.2022:                                  ; preds = %cond.true.2008
  %320 = load i64, i64* %leni, align 8
  %add2023 = add nsw i64 0, %320
  %mul2024 = mul nsw i64 0, %add2023
  %sub2025 = sub nsw i64 %mul2024, 1
  br label %cond.end.2026

cond.end.2026:                                    ; preds = %cond.false.2022, %cond.true.2014
  %cond2027 = phi i64 [ %add2021, %cond.true.2014 ], [ %sub2025, %cond.false.2022 ]
  %div2028 = sdiv i64 %cond2027, 8
  %cmp2029 = icmp slt i64 %317, %div2028
  br i1 %cmp2029, label %cond.true.2139, label %lor.lhs.false.2125

cond.false.2031:                                  ; preds = %cond.true.2005
  br i1 false, label %cond.true.2032, label %cond.false.2033

cond.true.2032:                                   ; preds = %cond.false.2031
  br i1 false, label %cond.true.2139, label %lor.lhs.false.2125

cond.false.2033:                                  ; preds = %cond.false.2031
  %321 = load i64, i64* %leni, align 8
  %add2034 = add nsw i64 0, %321
  %mul2035 = mul nsw i64 0, %add2034
  %sub2036 = sub nsw i64 %mul2035, 1
  %cmp2037 = icmp slt i64 %sub2036, 0
  br i1 %cmp2037, label %cond.true.2039, label %cond.false.2056

cond.true.2039:                                   ; preds = %cond.false.2033
  %322 = load i64, i64* %leni, align 8
  %add2040 = add nsw i64 0, %322
  %mul2041 = mul nsw i64 0, %add2040
  %add2042 = add nsw i64 %mul2041, 0
  %neg2043 = xor i64 %add2042, -1
  %cmp2044 = icmp eq i64 %neg2043, -1
  %conv2045 = zext i1 %cmp2044 to i32
  %sub2046 = sub nsw i32 0, %conv2045
  %conv2047 = sext i32 %sub2046 to i64
  %323 = load i64, i64* %leni, align 8
  %add2048 = add nsw i64 0, %323
  %mul2049 = mul nsw i64 0, %add2048
  %add2050 = add nsw i64 %mul2049, 1
  %shl2051 = shl i64 %add2050, 62
  %sub2052 = sub nsw i64 %shl2051, 1
  %mul2053 = mul nsw i64 %sub2052, 2
  %add2054 = add nsw i64 %mul2053, 1
  %sub2055 = sub nsw i64 %conv2047, %add2054
  br label %cond.end.2060

cond.false.2056:                                  ; preds = %cond.false.2033
  %324 = load i64, i64* %leni, align 8
  %add2057 = add nsw i64 0, %324
  %mul2058 = mul nsw i64 0, %add2057
  %add2059 = add nsw i64 %mul2058, 0
  br label %cond.end.2060

cond.end.2060:                                    ; preds = %cond.false.2056, %cond.true.2039
  %cond2061 = phi i64 [ %sub2055, %cond.true.2039 ], [ %add2059, %cond.false.2056 ]
  %div2062 = sdiv i64 %cond2061, 8
  %325 = load i64, i64* %leni, align 8
  %cmp2063 = icmp slt i64 %div2062, %325
  br i1 %cmp2063, label %cond.true.2139, label %lor.lhs.false.2125

cond.false.2065:                                  ; preds = %lor.lhs.false.2004
  br i1 false, label %cond.true.2066, label %cond.false.2067

cond.true.2066:                                   ; preds = %cond.false.2065
  br i1 false, label %cond.true.2139, label %lor.lhs.false.2125

cond.false.2067:                                  ; preds = %cond.false.2065
  %326 = load i64, i64* %leni, align 8
  %cmp2068 = icmp slt i64 %326, 0
  br i1 %cmp2068, label %cond.true.2070, label %cond.false.2102

cond.true.2070:                                   ; preds = %cond.false.2067
  %327 = load i64, i64* %leni, align 8
  %328 = load i64, i64* %leni, align 8
  %add2071 = add nsw i64 0, %328
  %mul2072 = mul nsw i64 0, %add2071
  %sub2073 = sub nsw i64 %mul2072, 1
  %cmp2074 = icmp slt i64 %sub2073, 0
  br i1 %cmp2074, label %cond.true.2076, label %cond.false.2093

cond.true.2076:                                   ; preds = %cond.true.2070
  %329 = load i64, i64* %leni, align 8
  %add2077 = add nsw i64 0, %329
  %mul2078 = mul nsw i64 0, %add2077
  %add2079 = add nsw i64 %mul2078, 0
  %neg2080 = xor i64 %add2079, -1
  %cmp2081 = icmp eq i64 %neg2080, -1
  %conv2082 = zext i1 %cmp2081 to i32
  %sub2083 = sub nsw i32 0, %conv2082
  %conv2084 = sext i32 %sub2083 to i64
  %330 = load i64, i64* %leni, align 8
  %add2085 = add nsw i64 0, %330
  %mul2086 = mul nsw i64 0, %add2085
  %add2087 = add nsw i64 %mul2086, 1
  %shl2088 = shl i64 %add2087, 62
  %sub2089 = sub nsw i64 %shl2088, 1
  %mul2090 = mul nsw i64 %sub2089, 2
  %add2091 = add nsw i64 %mul2090, 1
  %sub2092 = sub nsw i64 %conv2084, %add2091
  br label %cond.end.2097

cond.false.2093:                                  ; preds = %cond.true.2070
  %331 = load i64, i64* %leni, align 8
  %add2094 = add nsw i64 0, %331
  %mul2095 = mul nsw i64 0, %add2094
  %add2096 = add nsw i64 %mul2095, 0
  br label %cond.end.2097

cond.end.2097:                                    ; preds = %cond.false.2093, %cond.true.2076
  %cond2098 = phi i64 [ %sub2092, %cond.true.2076 ], [ %add2096, %cond.false.2093 ]
  %div2099 = sdiv i64 %cond2098, 8
  %cmp2100 = icmp slt i64 %327, %div2099
  br i1 %cmp2100, label %cond.true.2139, label %lor.lhs.false.2125

cond.false.2102:                                  ; preds = %cond.false.2067
  %332 = load i64, i64* %leni, align 8
  %add2103 = add nsw i64 0, %332
  %mul2104 = mul nsw i64 0, %add2103
  %sub2105 = sub nsw i64 %mul2104, 1
  %cmp2106 = icmp slt i64 %sub2105, 0
  br i1 %cmp2106, label %cond.true.2108, label %cond.false.2116

cond.true.2108:                                   ; preds = %cond.false.2102
  %333 = load i64, i64* %leni, align 8
  %add2109 = add nsw i64 0, %333
  %mul2110 = mul nsw i64 0, %add2109
  %add2111 = add nsw i64 %mul2110, 1
  %shl2112 = shl i64 %add2111, 62
  %sub2113 = sub nsw i64 %shl2112, 1
  %mul2114 = mul nsw i64 %sub2113, 2
  %add2115 = add nsw i64 %mul2114, 1
  br label %cond.end.2120

cond.false.2116:                                  ; preds = %cond.false.2102
  %334 = load i64, i64* %leni, align 8
  %add2117 = add nsw i64 0, %334
  %mul2118 = mul nsw i64 0, %add2117
  %sub2119 = sub nsw i64 %mul2118, 1
  br label %cond.end.2120

cond.end.2120:                                    ; preds = %cond.false.2116, %cond.true.2108
  %cond2121 = phi i64 [ %add2115, %cond.true.2108 ], [ %sub2119, %cond.false.2116 ]
  %div2122 = sdiv i64 %cond2121, 8
  %335 = load i64, i64* %leni, align 8
  %cmp2123 = icmp slt i64 %div2122, %335
  br i1 %cmp2123, label %cond.true.2139, label %lor.lhs.false.2125

lor.lhs.false.2125:                               ; preds = %cond.end.2120, %cond.end.2097, %cond.true.2066, %cond.end.2060, %cond.true.2032, %cond.end.2026
  %336 = load i64, i64* %leni, align 8
  %mul2126 = mul nsw i64 %336, 8
  %mul2127 = mul nsw i64 0, %mul2126
  %sub2128 = sub nsw i64 %mul2127, 1
  %cmp2129 = icmp slt i64 %sub2128, 0
  br i1 %cmp2129, label %land.lhs.true.2131, label %lor.lhs.false.2135

land.lhs.true.2131:                               ; preds = %lor.lhs.false.2125
  %337 = load i64, i64* %leni, align 8
  %mul2132 = mul nsw i64 %337, 8
  %cmp2133 = icmp slt i64 %mul2132, -9223372036854775808
  br i1 %cmp2133, label %cond.true.2139, label %lor.lhs.false.2135

lor.lhs.false.2135:                               ; preds = %land.lhs.true.2131, %lor.lhs.false.2125
  %338 = load i64, i64* %leni, align 8
  %mul2136 = mul nsw i64 %338, 8
  %cmp2137 = icmp slt i64 9223372036854775807, %mul2136
  br i1 %cmp2137, label %cond.true.2139, label %cond.false.2151

cond.true.2139:                                   ; preds = %lor.lhs.false.2135, %land.lhs.true.2131, %cond.end.2120, %cond.end.2097, %cond.true.2066, %cond.end.2060, %cond.true.2032, %cond.end.2026, %land.lhs.true.2001
  %339 = load i64, i64* %leni, align 8
  %mul2140 = mul i64 %339, 8
  %cmp2141 = icmp ule i64 %mul2140, 9223372036854775807
  br i1 %cmp2141, label %cond.true.2143, label %cond.false.2145

cond.true.2143:                                   ; preds = %cond.true.2139
  %340 = load i64, i64* %leni, align 8
  %mul2144 = mul i64 %340, 8
  br label %cond.end.2149

cond.false.2145:                                  ; preds = %cond.true.2139
  %341 = load i64, i64* %leni, align 8
  %mul2146 = mul i64 %341, 8
  %sub2147 = sub i64 %mul2146, -9223372036854775808
  %add2148 = add nsw i64 %sub2147, -9223372036854775808
  br label %cond.end.2149

cond.end.2149:                                    ; preds = %cond.false.2145, %cond.true.2143
  %cond2150 = phi i64 [ %mul2144, %cond.true.2143 ], [ %add2148, %cond.false.2145 ]
  store i64 %cond2150, i64* %alloca_nbytes, align 8
  br i1 true, label %if.then.2166, label %lor.lhs.false.2163

cond.false.2151:                                  ; preds = %lor.lhs.false.2135
  %342 = load i64, i64* %leni, align 8
  %mul2152 = mul i64 %342, 8
  %cmp2153 = icmp ule i64 %mul2152, 9223372036854775807
  br i1 %cmp2153, label %cond.true.2155, label %cond.false.2157

cond.true.2155:                                   ; preds = %cond.false.2151
  %343 = load i64, i64* %leni, align 8
  %mul2156 = mul i64 %343, 8
  br label %cond.end.2161

cond.false.2157:                                  ; preds = %cond.false.2151
  %344 = load i64, i64* %leni, align 8
  %mul2158 = mul i64 %344, 8
  %sub2159 = sub i64 %mul2158, -9223372036854775808
  %add2160 = add nsw i64 %sub2159, -9223372036854775808
  br label %cond.end.2161

cond.end.2161:                                    ; preds = %cond.false.2157, %cond.true.2155
  %cond2162 = phi i64 [ %mul2156, %cond.true.2155 ], [ %add2160, %cond.false.2157 ]
  store i64 %cond2162, i64* %alloca_nbytes, align 8
  br i1 false, label %if.then.2166, label %lor.lhs.false.2163

lor.lhs.false.2163:                               ; preds = %cond.end.2161, %cond.end.2149, %cond.end.1968, %cond.end.1956, %cond.end.1774, %cond.end.1762, %cond.end.1581, %cond.end.1569, %cond.end.1385, %cond.end.1369, %cond.end.1184, %cond.end.1168, %cond.end.956, %cond.end.933, %cond.end.741, %cond.end.718, %cond.end.471, %cond.end.448, %cond.end.256, %cond.end.233
  %345 = load i64, i64* %alloca_nbytes, align 8
  %cmp2164 = icmp ult i64 -1, %345
  br i1 %cmp2164, label %if.then.2166, label %if.else

if.then.2166:                                     ; preds = %lor.lhs.false.2163, %cond.end.2161, %cond.end.2149, %cond.end.1968, %cond.end.1956, %cond.end.1774, %cond.end.1762, %cond.end.1581, %cond.end.1569, %cond.end.1385, %cond.end.1369, %cond.end.1184, %cond.end.1168, %cond.end.956, %cond.end.933, %cond.end.741, %cond.end.718, %cond.end.471, %cond.end.448, %cond.end.256, %cond.end.233
  call void @memory_full(i64 -1) #8
  unreachable

if.else:                                          ; preds = %lor.lhs.false.2163
  %346 = load i64, i64* %alloca_nbytes, align 8
  %347 = load i64, i64* %sa_avail, align 8
  %cmp2167 = icmp sle i64 %346, %347
  br i1 %cmp2167, label %if.then.2169, label %if.else.2171

if.then.2169:                                     ; preds = %if.else
  %348 = load i64, i64* %alloca_nbytes, align 8
  %349 = load i64, i64* %sa_avail, align 8
  %sub2170 = sub nsw i64 %349, %348
  store i64 %sub2170, i64* %sa_avail, align 8
  %350 = load i64, i64* %alloca_nbytes, align 8
  %351 = alloca i8, i64 %350
  %352 = bitcast i8* %351 to i64*
  store i64* %352, i64** %args, align 8
  br label %if.end.2174

if.else.2171:                                     ; preds = %if.else
  %353 = load i64, i64* %alloca_nbytes, align 8
  %call2172 = call noalias i8* @xmalloc(i64 %353)
  %354 = bitcast i8* %call2172 to i64*
  store i64* %354, i64** %args, align 8
  %355 = load i64*, i64** %args, align 8
  %356 = load i64, i64* %leni, align 8
  %call2173 = call i64 @make_save_memory(i64* %355, i64 %356)
  store i64 %call2173, i64* %arg_, align 8
  store i8 1, i8* %sa_must_free, align 1
  %357 = load i64, i64* %arg_, align 8
  call void @record_unwind_protect(void (i64)* @free_save_value, i64 %357)
  br label %if.end.2174

if.end.2174:                                      ; preds = %if.else.2171, %if.then.2169
  br label %if.end.2175

if.end.2175:                                      ; preds = %if.end.2174
  br label %do.end

do.end:                                           ; preds = %if.end.2175
  %358 = load i64, i64* %leni, align 8
  %359 = load i64*, i64** %args, align 8
  %360 = load i64, i64* %function.addr, align 8
  %361 = load i64, i64* %sequence.addr, align 8
  call void @mapcar1(i64 %358, i64* %359, i64 %360, i64 %361)
  %362 = load i64, i64* %leni, align 8
  %363 = load i64*, i64** %args, align 8
  %call2176 = call i64 @Flist(i64 %362, i64* %363)
  store i64 %call2176, i64* %ret, align 8
  br label %do.body.2177

do.body.2177:                                     ; preds = %do.end
  %364 = load i8, i8* %sa_must_free, align 1
  %tobool = trunc i8 %364 to i1
  br i1 %tobool, label %if.then.2178, label %if.end.2181

if.then.2178:                                     ; preds = %do.body.2177
  store i8 0, i8* %sa_must_free, align 1
  %365 = load i64, i64* %sa_count, align 8
  %call2179 = call i64 @builtin_lisp_symbol(i32 0)
  %call2180 = call i64 @unbind_to(i64 %365, i64 %call2179)
  br label %if.end.2181

if.end.2181:                                      ; preds = %if.then.2178, %do.body.2177
  br label %do.end.2182

do.end.2182:                                      ; preds = %if.end.2181
  %366 = load i64, i64* %ret, align 8
  ret i64 %366
}

declare i64 @Flist(i64, i64*) #2

; Function Attrs: nounwind uwtable
define i64 @Fmapc(i64 %function, i64 %sequence) #1 {
entry:
  %function.addr = alloca i64, align 8
  %sequence.addr = alloca i64, align 8
  %leni = alloca i64, align 8
  store i64 %function, i64* %function.addr, align 8
  store i64 %sequence, i64* %sequence.addr, align 8
  %0 = load i64, i64* %sequence.addr, align 8
  %call = call i64 @Flength(i64 %0)
  %shr = ashr i64 %call, 2
  store i64 %shr, i64* %leni, align 8
  %1 = load i64, i64* %sequence.addr, align 8
  %call1 = call zeroext i1 @CHAR_TABLE_P(i64 %1)
  br i1 %call1, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call2 = call i64 @builtin_lisp_symbol(i32 626)
  %2 = load i64, i64* %sequence.addr, align 8
  %3 = call i64 @wrong_type_argument(i64 %call2, i64 %2) #8
  unreachable

if.end:                                           ; preds = %entry
  %4 = load i64, i64* %leni, align 8
  %5 = load i64, i64* %function.addr, align 8
  %6 = load i64, i64* %sequence.addr, align 8
  call void @mapcar1(i64 %4, i64* null, i64 %5, i64 %6)
  %7 = load i64, i64* %sequence.addr, align 8
  ret i64 %7
}

; Function Attrs: nounwind uwtable
define i64 @do_yes_or_no_p(i64 %prompt) #1 {
entry:
  %prompt.addr = alloca i64, align 8
  store i64 %prompt, i64* %prompt.addr, align 8
  %call = call i64 @intern(i8* getelementptr inbounds ([12 x i8], [12 x i8]* @.str.3, i32 0, i32 0))
  %0 = load i64, i64* %prompt.addr, align 8
  %call1 = call i64 @call1(i64 %call, i64 %0)
  ret i64 %call1
}

declare i64 @call1(i64, i64) #2

declare i64 @intern(i8*) #2

; Function Attrs: nounwind uwtable
define i64 @Fyes_or_no_p(i64 %prompt) #1 {
entry:
  %retval = alloca i64, align 8
  %prompt.addr = alloca i64, align 8
  %ans = alloca i64, align 8
  %pane = alloca i64, align 8
  %menu = alloca i64, align 8
  %obj = alloca i64, align 8
  %yes_or_no = alloca i64, align 8
  %.compoundliteral = alloca %union.Aligned_String, align 8
  %.compoundliteral21 = alloca [2 x i64], align 8
  store i64 %prompt, i64* %prompt.addr, align 8
  %0 = load i64, i64* %prompt.addr, align 8
  call void @CHECK_STRING(i64 %0)
  %1 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 377), align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %1, %call
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 377), align 8
  %and = and i64 %2, 7
  %conv = trunc i64 %and to i32
  %cmp1 = icmp eq i32 %conv, 3
  br i1 %cmp1, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %lor.lhs.false, %entry
  %3 = load i8, i8* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 493), align 1
  %tobool = trunc i8 %3 to i1
  br i1 %tobool, label %land.lhs.true.4, label %if.end

land.lhs.true.4:                                  ; preds = %land.lhs.true
  %4 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 376), align 8
  %call5 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp6 = icmp eq i64 %4, %call5
  br i1 %cmp6, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true.4
  call void @redisplay_preserve_echo_area(i32 4)
  %call8 = call i64 @build_string(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.4, i32 0, i32 0))
  %call9 = call i64 @builtin_lisp_symbol(i32 901)
  %call10 = call i64 @Fcons(i64 %call8, i64 %call9)
  %call11 = call i64 @build_string(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.5, i32 0, i32 0))
  %call12 = call i64 @builtin_lisp_symbol(i32 0)
  %call13 = call i64 @Fcons(i64 %call11, i64 %call12)
  %call14 = call i64 @list2(i64 %call10, i64 %call13)
  store i64 %call14, i64* %pane, align 8
  %5 = load i64, i64* %prompt.addr, align 8
  %6 = load i64, i64* %pane, align 8
  %call15 = call i64 @Fcons(i64 %5, i64 %6)
  store i64 %call15, i64* %menu, align 8
  %call16 = call i64 @builtin_lisp_symbol(i32 901)
  %7 = load i64, i64* %menu, align 8
  %call17 = call i64 @builtin_lisp_symbol(i32 0)
  %call18 = call i64 @Fx_popup_dialog(i64 %call16, i64 %7, i64 %call17)
  store i64 %call18, i64* %obj, align 8
  %8 = load i64, i64* %obj, align 8
  store i64 %8, i64* %retval
  br label %return

if.end:                                           ; preds = %land.lhs.true.4, %land.lhs.true, %lor.lhs.false
  %s = bitcast %union.Aligned_String* %.compoundliteral to %struct.Lisp_String*
  %size = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s, i32 0, i32 0
  store i64 12, i64* %size, align 8
  %size_byte = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s, i32 0, i32 1
  store i64 -1, i64* %size_byte, align 8
  %intervals = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s, i32 0, i32 2
  store %struct.interval* null, %struct.interval** %intervals, align 8
  %data = getelementptr inbounds %struct.Lisp_String, %struct.Lisp_String* %s, i32 0, i32 3
  store i8* getelementptr inbounds ([13 x i8], [13 x i8]* @.str.6, i32 0, i32 0), i8** %data, align 8
  %s19 = bitcast %union.Aligned_String* %.compoundliteral to %struct.Lisp_String*
  %9 = bitcast %struct.Lisp_String* %s19 to i8*
  %call20 = call i64 @make_lisp_ptr(i8* %9, i32 4)
  store i64 %call20, i64* %yes_or_no, align 8
  %arrayinit.begin = getelementptr inbounds [2 x i64], [2 x i64]* %.compoundliteral21, i64 0, i64 0
  %10 = load i64, i64* %prompt.addr, align 8
  store i64 %10, i64* %arrayinit.begin
  %arrayinit.element = getelementptr inbounds i64, i64* %arrayinit.begin, i64 1
  %11 = load i64, i64* %yes_or_no, align 8
  store i64 %11, i64* %arrayinit.element
  %arraydecay = getelementptr inbounds [2 x i64], [2 x i64]* %.compoundliteral21, i32 0, i32 0
  %call22 = call i64 @Fconcat(i64 2, i64* %arraydecay)
  store i64 %call22, i64* %prompt.addr, align 8
  br label %while.body

while.body:                                       ; preds = %if.end, %if.end.50
  %12 = load i64, i64* %prompt.addr, align 8
  %call23 = call i64 @builtin_lisp_symbol(i32 0)
  %call24 = call i64 @builtin_lisp_symbol(i32 0)
  %call25 = call i64 @builtin_lisp_symbol(i32 0)
  %call26 = call i64 @builtin_lisp_symbol(i32 1072)
  %call27 = call i64 @builtin_lisp_symbol(i32 0)
  %call28 = call i64 @builtin_lisp_symbol(i32 0)
  %call29 = call i64 @Fread_from_minibuffer(i64 %12, i64 %call23, i64 %call24, i64 %call25, i64 %call26, i64 %call27, i64 %call28)
  %call30 = call i64 @Fdowncase(i64 %call29)
  store i64 %call30, i64* %ans, align 8
  %13 = load i64, i64* %ans, align 8
  %call31 = call i64 @SCHARS(i64 %13)
  %cmp32 = icmp eq i64 %call31, 3
  br i1 %cmp32, label %land.lhs.true.34, label %if.end.40

land.lhs.true.34:                                 ; preds = %while.body
  %14 = load i64, i64* %ans, align 8
  %call35 = call i8* @SSDATA(i64 %14)
  %call36 = call i32 @strcmp(i8* %call35, i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.7, i32 0, i32 0)) #9
  %tobool37 = icmp ne i32 %call36, 0
  br i1 %tobool37, label %if.end.40, label %if.then.38

if.then.38:                                       ; preds = %land.lhs.true.34
  %call39 = call i64 @builtin_lisp_symbol(i32 901)
  store i64 %call39, i64* %retval
  br label %return

if.end.40:                                        ; preds = %land.lhs.true.34, %while.body
  %15 = load i64, i64* %ans, align 8
  %call41 = call i64 @SCHARS(i64 %15)
  %cmp42 = icmp eq i64 %call41, 2
  br i1 %cmp42, label %land.lhs.true.44, label %if.end.50

land.lhs.true.44:                                 ; preds = %if.end.40
  %16 = load i64, i64* %ans, align 8
  %call45 = call i8* @SSDATA(i64 %16)
  %call46 = call i32 @strcmp(i8* %call45, i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.8, i32 0, i32 0)) #9
  %tobool47 = icmp ne i32 %call46, 0
  br i1 %tobool47, label %if.end.50, label %if.then.48

if.then.48:                                       ; preds = %land.lhs.true.44
  %call49 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call49, i64* %retval
  br label %return

if.end.50:                                        ; preds = %land.lhs.true.44, %if.end.40
  %call51 = call i64 @builtin_lisp_symbol(i32 0)
  %call52 = call i64 @Fding(i64 %call51)
  %call53 = call i64 @Fdiscard_input()
  call void @message1(i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.9, i32 0, i32 0))
  %call54 = call i64 @builtin_lisp_symbol(i32 0)
  %call55 = call i64 @Fsleep_for(i64 10, i64 %call54)
  br label %while.body

return:                                           ; preds = %if.then.48, %if.then.38, %if.then
  %17 = load i64, i64* %retval
  ret i64 %17
}

declare void @redisplay_preserve_echo_area(i32) #2

declare i64 @build_string(i8*) #2

declare i64 @Fx_popup_dialog(i64, i64, i64) #2

declare i64 @Fdowncase(i64) #2

declare i64 @Fread_from_minibuffer(i64, i64, i64, i64, i64, i64, i64) #2

; Function Attrs: nounwind readonly
declare i32 @strcmp(i8*, i8*) #4

declare i64 @Fding(i64) #2

declare i64 @Fdiscard_input() #2

declare void @message1(i8*) #2

declare i64 @Fsleep_for(i64, i64) #2

; Function Attrs: nounwind uwtable
define i64 @Fload_average(i64 %use_floats) #1 {
entry:
  %use_floats.addr = alloca i64, align 8
  %load_ave = alloca [3 x double], align 16
  %loads = alloca i32, align 4
  %ret = alloca i64, align 8
  %load = alloca i64, align 8
  store i64 %use_floats, i64* %use_floats.addr, align 8
  %arraydecay = getelementptr inbounds [3 x double], [3 x double]* %load_ave, i32 0, i32 0
  %call = call i32 @getloadavg(double* %arraydecay, i32 3) #5
  store i32 %call, i32* %loads, align 4
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call1, i64* %ret, align 8
  %0 = load i32, i32* %loads, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void (i8*, ...) @error(i8* getelementptr inbounds ([55 x i8], [55 x i8]* @.str.10, i32 0, i32 0)) #8
  unreachable

if.end:                                           ; preds = %entry
  br label %while.cond

while.cond:                                       ; preds = %cond.end, %if.end
  %1 = load i32, i32* %loads, align 4
  %dec = add nsw i32 %1, -1
  store i32 %dec, i32* %loads, align 4
  %cmp2 = icmp sgt i32 %1, 0
  br i1 %cmp2, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load i64, i64* %use_floats.addr, align 8
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp4 = icmp eq i64 %2, %call3
  br i1 %cmp4, label %cond.true, label %cond.false

cond.true:                                        ; preds = %while.body
  %3 = load i32, i32* %loads, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds [3 x double], [3 x double]* %load_ave, i32 0, i64 %idxprom
  %4 = load double, double* %arrayidx, align 8
  %mul = fmul double 1.000000e+02, %4
  %conv = fptoui double %mul to i64
  %shl = shl i64 %conv, 2
  %add = add i64 %shl, 2
  br label %cond.end

cond.false:                                       ; preds = %while.body
  %5 = load i32, i32* %loads, align 4
  %idxprom5 = sext i32 %5 to i64
  %arrayidx6 = getelementptr inbounds [3 x double], [3 x double]* %load_ave, i32 0, i64 %idxprom5
  %6 = load double, double* %arrayidx6, align 8
  %call7 = call i64 @make_float(double %6)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %add, %cond.true ], [ %call7, %cond.false ]
  store i64 %cond, i64* %load, align 8
  %7 = load i64, i64* %load, align 8
  %8 = load i64, i64* %ret, align 8
  %call8 = call i64 @Fcons(i64 %7, i64 %8)
  store i64 %call8, i64* %ret, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %9 = load i64, i64* %ret, align 8
  ret i64 %9
}

; Function Attrs: nounwind
declare i32 @getloadavg(double*, i32) #6

; Function Attrs: nounwind uwtable
define i64 @Ffeaturep(i64 %feature, i64 %subfeature) #1 {
entry:
  %feature.addr = alloca i64, align 8
  %subfeature.addr = alloca i64, align 8
  %tem = alloca i64, align 8
  store i64 %feature, i64* %feature.addr, align 8
  store i64 %subfeature, i64* %subfeature.addr, align 8
  %0 = load i64, i64* %feature.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = call i64 @builtin_lisp_symbol(i32 897)
  %1 = load i64, i64* %feature.addr, align 8
  %2 = call i64 @wrong_type_argument(i64 %call, i64 %1) #8
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %3, %cond.true
  %4 = load i64, i64* %feature.addr, align 8
  %5 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 92), align 8
  %call2 = call i64 @Fmemq(i64 %4, i64 %5)
  store i64 %call2, i64* %tem, align 8
  %6 = load i64, i64* %tem, align 8
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp4 = icmp eq i64 %6, %call3
  br i1 %cmp4, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %cond.end
  %7 = load i64, i64* %subfeature.addr, align 8
  %call6 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp7 = icmp eq i64 %7, %call6
  br i1 %cmp7, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %8 = load i64, i64* %subfeature.addr, align 8
  %9 = load i64, i64* %feature.addr, align 8
  %call9 = call i64 @builtin_lisp_symbol(i32 887)
  %call10 = call i64 @Fget(i64 %9, i64 %call9)
  %call11 = call i64 @Fmember(i64 %8, i64 %call10)
  store i64 %call11, i64* %tem, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %cond.end
  %10 = load i64, i64* %tem, align 8
  %call12 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp13 = icmp eq i64 %10, %call12
  br i1 %cmp13, label %cond.true.15, label %cond.false.17

cond.true.15:                                     ; preds = %if.end
  %call16 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end.19

cond.false.17:                                    ; preds = %if.end
  %call18 = call i64 @builtin_lisp_symbol(i32 901)
  br label %cond.end.19

cond.end.19:                                      ; preds = %cond.false.17, %cond.true.15
  %cond = phi i64 [ %call16, %cond.true.15 ], [ %call18, %cond.false.17 ]
  ret i64 %cond
}

; Function Attrs: nounwind uwtable
define i64 @Fprovide(i64 %feature, i64 %subfeatures) #1 {
entry:
  %feature.addr = alloca i64, align 8
  %subfeatures.addr = alloca i64, align 8
  %tem = alloca i64, align 8
  store i64 %feature, i64* %feature.addr, align 8
  store i64 %subfeatures, i64* %subfeatures.addr, align 8
  %0 = load i64, i64* %feature.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = call i64 @builtin_lisp_symbol(i32 897)
  %1 = load i64, i64* %feature.addr, align 8
  %2 = call i64 @wrong_type_argument(i64 %call, i64 %1) #8
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %3, %cond.true
  %4 = load i64, i64* %subfeatures.addr, align 8
  call void @CHECK_LIST(i64 %4)
  %5 = load i64, i64* @Vautoload_queue, align 8
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp3 = icmp eq i64 %5, %call2
  br i1 %cmp3, label %if.end, label %if.then

if.then:                                          ; preds = %cond.end
  %6 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 92), align 8
  %call5 = call i64 @Fcons(i64 2, i64 %6)
  %7 = load i64, i64* @Vautoload_queue, align 8
  %call6 = call i64 @Fcons(i64 %call5, i64 %7)
  store i64 %call6, i64* @Vautoload_queue, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end
  %8 = load i64, i64* %feature.addr, align 8
  %9 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 92), align 8
  %call7 = call i64 @Fmemq(i64 %8, i64 %9)
  store i64 %call7, i64* %tem, align 8
  %10 = load i64, i64* %tem, align 8
  %call8 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp9 = icmp eq i64 %10, %call8
  br i1 %cmp9, label %if.then.11, label %if.end.13

if.then.11:                                       ; preds = %if.end
  %11 = load i64, i64* %feature.addr, align 8
  %12 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 92), align 8
  %call12 = call i64 @Fcons(i64 %11, i64 %12)
  store i64 %call12, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 92), align 8
  br label %if.end.13

if.end.13:                                        ; preds = %if.then.11, %if.end
  %13 = load i64, i64* %subfeatures.addr, align 8
  %call14 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp15 = icmp eq i64 %13, %call14
  br i1 %cmp15, label %if.end.20, label %if.then.17

if.then.17:                                       ; preds = %if.end.13
  %14 = load i64, i64* %feature.addr, align 8
  %call18 = call i64 @builtin_lisp_symbol(i32 887)
  %15 = load i64, i64* %subfeatures.addr, align 8
  %call19 = call i64 @Fput(i64 %14, i64 %call18, i64 %15)
  br label %if.end.20

if.end.20:                                        ; preds = %if.then.17, %if.end.13
  %call21 = call i64 @builtin_lisp_symbol(i32 779)
  %16 = load i64, i64* %feature.addr, align 8
  %call22 = call i64 @Fcons(i64 %call21, i64 %16)
  call void @LOADHIST_ATTACH(i64 %call22)
  %17 = load i64, i64* %feature.addr, align 8
  %18 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 3), align 8
  %call23 = call i64 @Fassq(i64 %17, i64 %18)
  store i64 %call23, i64* %tem, align 8
  %19 = load i64, i64* %tem, align 8
  %and24 = and i64 %19, 7
  %conv25 = trunc i64 %and24 to i32
  %cmp26 = icmp eq i32 %conv25, 3
  br i1 %cmp26, label %if.then.28, label %if.end.31

if.then.28:                                       ; preds = %if.end.20
  %call29 = call i64 @builtin_lisp_symbol(i32 474)
  %20 = load i64, i64* %tem, align 8
  %sub = sub nsw i64 %20, 3
  %21 = inttoptr i64 %sub to i8*
  %22 = bitcast i8* %21 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %22, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %23 = load i64, i64* %cdr, align 8
  %call30 = call i64 @Fmapc(i64 %call29, i64 %23)
  br label %if.end.31

if.end.31:                                        ; preds = %if.then.28, %if.end.20
  %24 = load i64, i64* %feature.addr, align 8
  ret i64 %24
}

declare void @LOADHIST_ATTACH(i64) #2

; Function Attrs: nounwind uwtable
define i64 @Frequire(i64 %feature, i64 %filename, i64 %noerror) #1 {
entry:
  %retval = alloca i64, align 8
  %feature.addr = alloca i64, align 8
  %filename.addr = alloca i64, align 8
  %noerror.addr = alloca i64, align 8
  %tem = alloca i64, align 8
  %from_file = alloca i8, align 1
  %count = alloca i64, align 8
  %nesting = alloca i32, align 4
  store i64 %feature, i64* %feature.addr, align 8
  store i64 %filename, i64* %filename.addr, align 8
  store i64 %noerror, i64* %noerror.addr, align 8
  %0 = load i8, i8* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 466), align 1
  %tobool = trunc i8 %0 to i1
  %frombool = zext i1 %tobool to i8
  store i8 %frombool, i8* %from_file, align 1
  %1 = load i64, i64* %feature.addr, align 8
  %and = and i64 %1, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = call i64 @builtin_lisp_symbol(i32 897)
  %2 = load i64, i64* %feature.addr, align 8
  %3 = call i64 @wrong_type_argument(i64 %call, i64 %2) #8
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %4, %cond.true
  %5 = load i8, i8* %from_file, align 1
  %tobool2 = trunc i8 %5 to i1
  br i1 %tobool2, label %if.end.17, label %if.then

if.then:                                          ; preds = %cond.end
  %6 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 49), align 8
  store i64 %6, i64* %tem, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %7 = load i64, i64* %tem, align 8
  %and3 = and i64 %7, 7
  %conv4 = trunc i64 %and3 to i32
  %cmp5 = icmp eq i32 %conv4, 3
  br i1 %cmp5, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load i64, i64* %tem, align 8
  %sub = sub nsw i64 %8, 3
  %9 = inttoptr i64 %sub to i8*
  %10 = bitcast i8* %9 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %10, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %11 = load i64, i64* %cdr, align 8
  %call7 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp8 = icmp eq i64 %11, %call7
  br i1 %cmp8, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.body
  %12 = load i64, i64* %tem, align 8
  %sub10 = sub nsw i64 %12, 3
  %13 = inttoptr i64 %sub10 to i8*
  %14 = bitcast i8* %13 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %14, i32 0, i32 0
  %15 = load i64, i64* %car, align 8
  %call11 = call zeroext i1 @STRINGP(i64 %15)
  br i1 %call11, label %if.then.13, label %if.end

if.then.13:                                       ; preds = %land.lhs.true
  store i8 1, i8* %from_file, align 1
  br label %if.end

if.end:                                           ; preds = %if.then.13, %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %16 = load i64, i64* %tem, align 8
  %sub14 = sub nsw i64 %16, 3
  %17 = inttoptr i64 %sub14 to i8*
  %18 = bitcast i8* %17 to %struct.Lisp_Cons*
  %u15 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %18, i32 0, i32 1
  %cdr16 = bitcast %union.anon* %u15 to i64*
  %19 = load i64, i64* %cdr16, align 8
  store i64 %19, i64* %tem, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end.17

if.end.17:                                        ; preds = %for.end, %cond.end
  %20 = load i8, i8* %from_file, align 1
  %tobool18 = trunc i8 %20 to i1
  br i1 %tobool18, label %if.then.19, label %if.end.28

if.then.19:                                       ; preds = %if.end.17
  %call20 = call i64 @builtin_lisp_symbol(i32 808)
  %21 = load i64, i64* %feature.addr, align 8
  %call21 = call i64 @Fcons(i64 %call20, i64 %21)
  store i64 %call21, i64* %tem, align 8
  %22 = load i64, i64* %tem, align 8
  %23 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 49), align 8
  %call22 = call i64 @Fmember(i64 %22, i64 %23)
  %call23 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp24 = icmp eq i64 %call22, %call23
  br i1 %cmp24, label %if.then.26, label %if.end.27

if.then.26:                                       ; preds = %if.then.19
  %24 = load i64, i64* %tem, align 8
  call void @LOADHIST_ATTACH(i64 %24)
  br label %if.end.27

if.end.27:                                        ; preds = %if.then.26, %if.then.19
  br label %if.end.28

if.end.28:                                        ; preds = %if.end.27, %if.end.17
  %25 = load i64, i64* %feature.addr, align 8
  %26 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 92), align 8
  %call29 = call i64 @Fmemq(i64 %25, i64 %26)
  store i64 %call29, i64* %tem, align 8
  %27 = load i64, i64* %tem, align 8
  %call30 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp31 = icmp eq i64 %27, %call30
  br i1 %cmp31, label %if.then.33, label %if.end.100

if.then.33:                                       ; preds = %if.end.28
  %call34 = call i64 @SPECPDL_INDEX()
  store i64 %call34, i64* %count, align 8
  store i32 0, i32* %nesting, align 4
  %28 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 240), align 8
  %call35 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp36 = icmp eq i64 %28, %call35
  br i1 %cmp36, label %if.end.41, label %if.then.38

if.then.38:                                       ; preds = %if.then.33
  %29 = load i64, i64* %feature.addr, align 8
  %call39 = call i64 @SYMBOL_NAME(i64 %29)
  %call40 = call i8* @SDATA(i64 %call39)
  call void (i8*, ...) @error(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.11, i32 0, i32 0), i8* %call40) #8
  unreachable

if.end.41:                                        ; preds = %if.then.33
  %30 = load i64, i64* @require_nesting_list, align 8
  store i64 %30, i64* %tem, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end.52, %if.end.41
  %31 = load i64, i64* %tem, align 8
  %call42 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp43 = icmp eq i64 %31, %call42
  %lnot = xor i1 %cmp43, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %32 = load i64, i64* %feature.addr, align 8
  %33 = load i64, i64* %tem, align 8
  %sub45 = sub nsw i64 %33, 3
  %34 = inttoptr i64 %sub45 to i8*
  %35 = bitcast i8* %34 to %struct.Lisp_Cons*
  %car46 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %35, i32 0, i32 0
  %36 = load i64, i64* %car46, align 8
  %call47 = call i64 @Fequal(i64 %32, i64 %36)
  %call48 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp49 = icmp eq i64 %call47, %call48
  br i1 %cmp49, label %if.end.52, label %if.then.51

if.then.51:                                       ; preds = %while.body
  %37 = load i32, i32* %nesting, align 4
  %inc = add nsw i32 %37, 1
  store i32 %inc, i32* %nesting, align 4
  br label %if.end.52

if.end.52:                                        ; preds = %if.then.51, %while.body
  %38 = load i64, i64* %tem, align 8
  %sub53 = sub nsw i64 %38, 3
  %39 = inttoptr i64 %sub53 to i8*
  %40 = bitcast i8* %39 to %struct.Lisp_Cons*
  %u54 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %40, i32 0, i32 1
  %cdr55 = bitcast %union.anon* %u54 to i64*
  %41 = load i64, i64* %cdr55, align 8
  store i64 %41, i64* %tem, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %42 = load i32, i32* %nesting, align 4
  %cmp56 = icmp sgt i32 %42, 3
  br i1 %cmp56, label %if.then.58, label %if.end.61

if.then.58:                                       ; preds = %while.end
  %43 = load i64, i64* %feature.addr, align 8
  %call59 = call i64 @SYMBOL_NAME(i64 %43)
  %call60 = call i8* @SDATA(i64 %call59)
  call void (i8*, ...) @error(i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.12, i32 0, i32 0), i8* %call60) #8
  unreachable

if.end.61:                                        ; preds = %while.end
  %44 = load i64, i64* @require_nesting_list, align 8
  call void @record_unwind_protect(void (i64)* @require_unwind, i64 %44)
  %45 = load i64, i64* %feature.addr, align 8
  %46 = load i64, i64* @require_nesting_list, align 8
  %call62 = call i64 @Fcons(i64 %45, i64 %46)
  store i64 %call62, i64* @require_nesting_list, align 8
  %47 = load i64, i64* @Vautoload_queue, align 8
  call void @record_unwind_protect(void (i64)* @un_autoload, i64 %47)
  %call63 = call i64 @builtin_lisp_symbol(i32 901)
  store i64 %call63, i64* @Vautoload_queue, align 8
  %48 = load i64, i64* %filename.addr, align 8
  %call64 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp65 = icmp eq i64 %48, %call64
  br i1 %cmp65, label %cond.true.67, label %cond.false.69

cond.true.67:                                     ; preds = %if.end.61
  %49 = load i64, i64* %feature.addr, align 8
  %call68 = call i64 @Fsymbol_name(i64 %49)
  br label %cond.end.70

cond.false.69:                                    ; preds = %if.end.61
  %50 = load i64, i64* %filename.addr, align 8
  br label %cond.end.70

cond.end.70:                                      ; preds = %cond.false.69, %cond.true.67
  %cond = phi i64 [ %call68, %cond.true.67 ], [ %50, %cond.false.69 ]
  %51 = load i64, i64* %noerror.addr, align 8
  %call71 = call i64 @builtin_lisp_symbol(i32 901)
  %call72 = call i64 @builtin_lisp_symbol(i32 0)
  %52 = load i64, i64* %filename.addr, align 8
  %call73 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp74 = icmp eq i64 %52, %call73
  br i1 %cmp74, label %cond.true.76, label %cond.false.78

cond.true.76:                                     ; preds = %cond.end.70
  %call77 = call i64 @builtin_lisp_symbol(i32 901)
  br label %cond.end.80

cond.false.78:                                    ; preds = %cond.end.70
  %call79 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end.80

cond.end.80:                                      ; preds = %cond.false.78, %cond.true.76
  %cond81 = phi i64 [ %call77, %cond.true.76 ], [ %call79, %cond.false.78 ]
  %call82 = call i64 @Fload(i64 %cond, i64 %51, i64 %call71, i64 %call72, i64 %cond81)
  store i64 %call82, i64* %tem, align 8
  %53 = load i64, i64* %tem, align 8
  %call83 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp84 = icmp eq i64 %53, %call83
  br i1 %cmp84, label %if.then.86, label %if.end.89

if.then.86:                                       ; preds = %cond.end.80
  %54 = load i64, i64* %count, align 8
  %call87 = call i64 @builtin_lisp_symbol(i32 0)
  %call88 = call i64 @unbind_to(i64 %54, i64 %call87)
  store i64 %call88, i64* %retval
  br label %return

if.end.89:                                        ; preds = %cond.end.80
  %55 = load i64, i64* %feature.addr, align 8
  %56 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 92), align 8
  %call90 = call i64 @Fmemq(i64 %55, i64 %56)
  store i64 %call90, i64* %tem, align 8
  %57 = load i64, i64* %tem, align 8
  %call91 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp92 = icmp eq i64 %57, %call91
  br i1 %cmp92, label %if.then.94, label %if.end.97

if.then.94:                                       ; preds = %if.end.89
  %58 = load i64, i64* %feature.addr, align 8
  %call95 = call i64 @SYMBOL_NAME(i64 %58)
  %call96 = call i8* @SDATA(i64 %call95)
  call void (i8*, ...) @error(i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.13, i32 0, i32 0), i8* %call96) #8
  unreachable

if.end.97:                                        ; preds = %if.end.89
  %call98 = call i64 @builtin_lisp_symbol(i32 901)
  store i64 %call98, i64* @Vautoload_queue, align 8
  %59 = load i64, i64* %count, align 8
  %60 = load i64, i64* %feature.addr, align 8
  %call99 = call i64 @unbind_to(i64 %59, i64 %60)
  store i64 %call99, i64* %feature.addr, align 8
  br label %if.end.100

if.end.100:                                       ; preds = %if.end.97, %if.end.28
  %61 = load i64, i64* %feature.addr, align 8
  store i64 %61, i64* %retval
  br label %return

return:                                           ; preds = %if.end.100, %if.then.86
  %62 = load i64, i64* %retval
  ret i64 %62
}

; Function Attrs: nounwind uwtable
define internal void @require_unwind(i64 %old_value) #1 {
entry:
  %old_value.addr = alloca i64, align 8
  store i64 %old_value, i64* %old_value.addr, align 8
  %0 = load i64, i64* %old_value.addr, align 8
  store i64 %0, i64* @require_nesting_list, align 8
  ret void
}

declare void @un_autoload(i64) #2

declare i64 @Fload(i64, i64, i64, i64, i64) #2

declare i64 @Fsymbol_name(i64) #2

; Function Attrs: nounwind uwtable
define i64 @Fplist_member(i64 %plist, i64 %prop) #1 {
entry:
  %plist.addr = alloca i64, align 8
  %prop.addr = alloca i64, align 8
  store i64 %plist, i64* %plist.addr, align 8
  store i64 %prop, i64* %prop.addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %do.end, %entry
  %0 = load i64, i64* %plist.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 3
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %while.cond
  %1 = load i64, i64* %plist.addr, align 8
  %sub = sub nsw i64 %1, 3
  %2 = inttoptr i64 %sub to i8*
  %3 = bitcast i8* %2 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %3, i32 0, i32 0
  %4 = load i64, i64* %car, align 8
  %5 = load i64, i64* %prop.addr, align 8
  %cmp2 = icmp eq i64 %4, %5
  %lnot = xor i1 %cmp2, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %while.cond
  %6 = phi i1 [ false, %while.cond ], [ %lnot, %land.rhs ]
  br i1 %6, label %while.body, label %while.end

while.body:                                       ; preds = %land.end
  %7 = load i64, i64* %plist.addr, align 8
  %sub4 = sub nsw i64 %7, 3
  %8 = inttoptr i64 %sub4 to i8*
  %9 = bitcast i8* %8 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %9, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %10 = load i64, i64* %cdr, align 8
  store i64 %10, i64* %plist.addr, align 8
  %11 = load i64, i64* %plist.addr, align 8
  %call = call i64 @CDR(i64 %11)
  store i64 %call, i64* %plist.addr, align 8
  br label %do.body

do.body:                                          ; preds = %while.body
  %12 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 241), align 8
  %call5 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp6 = icmp eq i64 %12, %call5
  br i1 %cmp6, label %if.else, label %land.lhs.true

land.lhs.true:                                    ; preds = %do.body
  %13 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 138), align 8
  %call8 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp9 = icmp eq i64 %13, %call8
  br i1 %cmp9, label %if.then, label %if.else

if.then:                                          ; preds = %land.lhs.true
  call void @process_quit_flag()
  br label %if.end.12

if.else:                                          ; preds = %land.lhs.true, %do.body
  %14 = load volatile i8, i8* @pending_signals, align 1
  %tobool = trunc i8 %14 to i1
  br i1 %tobool, label %if.then.11, label %if.end

if.then.11:                                       ; preds = %if.else
  call void @process_pending_signals()
  br label %if.end

if.end:                                           ; preds = %if.then.11, %if.else
  br label %if.end.12

if.end.12:                                        ; preds = %if.end, %if.then
  br label %do.end

do.end:                                           ; preds = %if.end.12
  br label %while.cond

while.end:                                        ; preds = %land.end
  %15 = load i64, i64* %plist.addr, align 8
  ret i64 %15
}

declare i64 @CDR(i64) #2

; Function Attrs: nounwind uwtable
define i64 @Fwidget_put(i64 %widget, i64 %property, i64 %value) #1 {
entry:
  %widget.addr = alloca i64, align 8
  %property.addr = alloca i64, align 8
  %value.addr = alloca i64, align 8
  store i64 %widget, i64* %widget.addr, align 8
  store i64 %property, i64* %property.addr, align 8
  store i64 %value, i64* %value.addr, align 8
  %0 = load i64, i64* %widget.addr, align 8
  call void @CHECK_CONS(i64 %0)
  %1 = load i64, i64* %widget.addr, align 8
  %2 = load i64, i64* %widget.addr, align 8
  %sub = sub nsw i64 %2, 3
  %3 = inttoptr i64 %sub to i8*
  %4 = bitcast i8* %3 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %4, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %5 = load i64, i64* %cdr, align 8
  %6 = load i64, i64* %property.addr, align 8
  %7 = load i64, i64* %value.addr, align 8
  %call = call i64 @Fplist_put(i64 %5, i64 %6, i64 %7)
  call void @XSETCDR(i64 %1, i64 %call)
  %8 = load i64, i64* %value.addr, align 8
  ret i64 %8
}

declare void @CHECK_CONS(i64) #2

declare void @XSETCDR(i64, i64) #2

; Function Attrs: nounwind uwtable
define i64 @Fwidget_get(i64 %widget, i64 %property) #1 {
entry:
  %retval = alloca i64, align 8
  %widget.addr = alloca i64, align 8
  %property.addr = alloca i64, align 8
  %tmp = alloca i64, align 8
  store i64 %widget, i64* %widget.addr, align 8
  store i64 %property, i64* %property.addr, align 8
  br label %while.body

while.body:                                       ; preds = %entry, %if.end.17
  %0 = load i64, i64* %widget.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %0, %call
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call1, i64* %retval
  br label %return

if.end:                                           ; preds = %while.body
  %1 = load i64, i64* %widget.addr, align 8
  call void @CHECK_CONS(i64 %1)
  %2 = load i64, i64* %widget.addr, align 8
  %sub = sub nsw i64 %2, 3
  %3 = inttoptr i64 %sub to i8*
  %4 = bitcast i8* %3 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %4, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %5 = load i64, i64* %cdr, align 8
  %6 = load i64, i64* %property.addr, align 8
  %call2 = call i64 @Fplist_member(i64 %5, i64 %6)
  store i64 %call2, i64* %tmp, align 8
  %7 = load i64, i64* %tmp, align 8
  %and = and i64 %7, 7
  %conv = trunc i64 %and to i32
  %cmp3 = icmp eq i32 %conv, 3
  br i1 %cmp3, label %if.then.5, label %if.end.10

if.then.5:                                        ; preds = %if.end
  %8 = load i64, i64* %tmp, align 8
  %sub6 = sub nsw i64 %8, 3
  %9 = inttoptr i64 %sub6 to i8*
  %10 = bitcast i8* %9 to %struct.Lisp_Cons*
  %u7 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %10, i32 0, i32 1
  %cdr8 = bitcast %union.anon* %u7 to i64*
  %11 = load i64, i64* %cdr8, align 8
  store i64 %11, i64* %tmp, align 8
  %12 = load i64, i64* %tmp, align 8
  %call9 = call i64 @CAR(i64 %12)
  store i64 %call9, i64* %retval
  br label %return

if.end.10:                                        ; preds = %if.end
  %13 = load i64, i64* %widget.addr, align 8
  %sub11 = sub nsw i64 %13, 3
  %14 = inttoptr i64 %sub11 to i8*
  %15 = bitcast i8* %14 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %15, i32 0, i32 0
  %16 = load i64, i64* %car, align 8
  store i64 %16, i64* %tmp, align 8
  %17 = load i64, i64* %tmp, align 8
  %call12 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp13 = icmp eq i64 %17, %call12
  br i1 %cmp13, label %if.then.15, label %if.end.17

if.then.15:                                       ; preds = %if.end.10
  %call16 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call16, i64* %retval
  br label %return

if.end.17:                                        ; preds = %if.end.10
  %18 = load i64, i64* %tmp, align 8
  %call18 = call i64 @builtin_lisp_symbol(i32 1016)
  %call19 = call i64 @Fget(i64 %18, i64 %call18)
  store i64 %call19, i64* %widget.addr, align 8
  br label %while.body

return:                                           ; preds = %if.then.15, %if.then.5, %if.then
  %19 = load i64, i64* %retval
  ret i64 %19
}

; Function Attrs: nounwind uwtable
define i64 @Fwidget_apply(i64 %nargs, i64* %args) #1 {
entry:
  %nargs.addr = alloca i64, align 8
  %args.addr = alloca i64*, align 8
  %widget = alloca i64, align 8
  %property = alloca i64, align 8
  %propval = alloca i64, align 8
  %trailing_args = alloca i64, align 8
  %result = alloca i64, align 8
  %.compoundliteral = alloca [3 x i64], align 8
  store i64 %nargs, i64* %nargs.addr, align 8
  store i64* %args, i64** %args.addr, align 8
  %0 = load i64*, i64** %args.addr, align 8
  %arrayidx = getelementptr inbounds i64, i64* %0, i64 0
  %1 = load i64, i64* %arrayidx, align 8
  store i64 %1, i64* %widget, align 8
  %2 = load i64*, i64** %args.addr, align 8
  %arrayidx1 = getelementptr inbounds i64, i64* %2, i64 1
  %3 = load i64, i64* %arrayidx1, align 8
  store i64 %3, i64* %property, align 8
  %4 = load i64, i64* %widget, align 8
  %5 = load i64, i64* %property, align 8
  %call = call i64 @Fwidget_get(i64 %4, i64 %5)
  store i64 %call, i64* %propval, align 8
  %6 = load i64, i64* %nargs.addr, align 8
  %sub = sub nsw i64 %6, 2
  %7 = load i64*, i64** %args.addr, align 8
  %add.ptr = getelementptr inbounds i64, i64* %7, i64 2
  %call2 = call i64 @Flist(i64 %sub, i64* %add.ptr)
  store i64 %call2, i64* %trailing_args, align 8
  %arrayinit.begin = getelementptr inbounds [3 x i64], [3 x i64]* %.compoundliteral, i64 0, i64 0
  %8 = load i64, i64* %propval, align 8
  store i64 %8, i64* %arrayinit.begin
  %arrayinit.element = getelementptr inbounds i64, i64* %arrayinit.begin, i64 1
  %9 = load i64, i64* %widget, align 8
  store i64 %9, i64* %arrayinit.element
  %arrayinit.element3 = getelementptr inbounds i64, i64* %arrayinit.element, i64 1
  %10 = load i64, i64* %trailing_args, align 8
  store i64 %10, i64* %arrayinit.element3
  %arraydecay = getelementptr inbounds [3 x i64], [3 x i64]* %.compoundliteral, i32 0, i32 0
  %call4 = call i64 @Fapply(i64 3, i64* %arraydecay)
  store i64 %call4, i64* %result, align 8
  %11 = load i64, i64* %result, align 8
  ret i64 %11
}

declare i64 @Fapply(i64, i64*) #2

; Function Attrs: nounwind uwtable
define i64 @Flocale_info(i64 %item) #1 {
entry:
  %retval = alloca i64, align 8
  %item.addr = alloca i64, align 8
  %str = alloca i8*, align 8
  %val = alloca i64, align 8
  %v = alloca i64, align 8
  %i = alloca i32, align 4
  %v17 = alloca i64, align 8
  %i20 = alloca i32, align 4
  store i64 %item, i64* %item.addr, align 8
  store i8* null, i8** %str, align 8
  %0 = load i64, i64* %item.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 276)
  %cmp = icmp eq i64 %0, %call
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %call1 = call i8* @nl_langinfo(i32 14) #5
  store i8* %call1, i8** %str, align 8
  %1 = load i8*, i8** %str, align 8
  %call2 = call i64 @build_string(i8* %1)
  store i64 %call2, i64* %retval
  br label %return

if.else:                                          ; preds = %entry
  %2 = load i64, i64* %item.addr, align 8
  %call3 = call i64 @builtin_lisp_symbol(i32 317)
  %cmp4 = icmp eq i64 %2, %call3
  br i1 %cmp4, label %if.then.5, label %if.else.12

if.then.5:                                        ; preds = %if.else
  %call6 = call i64 @builtin_lisp_symbol(i32 0)
  %call7 = call i64 @Fmake_vector(i64 30, i64 %call6)
  store i64 %call7, i64* %v, align 8
  call void @synchronize_system_time_locale()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then.5
  %3 = load i32, i32* %i, align 4
  %cmp8 = icmp slt i32 %3, 7
  br i1 %cmp8, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load i32, i32* %i, align 4
  %idxprom = sext i32 %4 to i64
  %arrayidx = getelementptr inbounds [7 x i32], [7 x i32]* @Flocale_info.days, i32 0, i64 %idxprom
  %5 = load i32, i32* %arrayidx, align 4
  %call9 = call i8* @nl_langinfo(i32 %5) #5
  store i8* %call9, i8** %str, align 8
  %6 = load i8*, i8** %str, align 8
  %call10 = call i64 @build_unibyte_string(i8* %6)
  store i64 %call10, i64* %val, align 8
  %7 = load i64, i64* %v, align 8
  %8 = load i32, i32* %i, align 4
  %conv = sext i32 %8 to i64
  %9 = load i64, i64* %val, align 8
  %10 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 168), align 8
  %call11 = call i64 @code_convert_string_norecord(i64 %9, i64 %10, i1 zeroext false)
  call void @ASET(i64 %7, i64 %conv, i64 %call11)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %11 = load i32, i32* %i, align 4
  %inc = add nsw i32 %11, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %12 = load i64, i64* %v, align 8
  store i64 %12, i64* %retval
  br label %return

if.else.12:                                       ; preds = %if.else
  %13 = load i64, i64* %item.addr, align 8
  %call13 = call i64 @builtin_lisp_symbol(i32 683)
  %cmp14 = icmp eq i64 %13, %call13
  br i1 %cmp14, label %if.then.16, label %if.end

if.then.16:                                       ; preds = %if.else.12
  %call18 = call i64 @builtin_lisp_symbol(i32 0)
  %call19 = call i64 @Fmake_vector(i64 50, i64 %call18)
  store i64 %call19, i64* %v17, align 8
  call void @synchronize_system_time_locale()
  store i32 0, i32* %i20, align 4
  br label %for.cond.21

for.cond.21:                                      ; preds = %for.inc.31, %if.then.16
  %14 = load i32, i32* %i20, align 4
  %cmp22 = icmp slt i32 %14, 12
  br i1 %cmp22, label %for.body.24, label %for.end.33

for.body.24:                                      ; preds = %for.cond.21
  %15 = load i32, i32* %i20, align 4
  %idxprom25 = sext i32 %15 to i64
  %arrayidx26 = getelementptr inbounds [12 x i32], [12 x i32]* @Flocale_info.months, i32 0, i64 %idxprom25
  %16 = load i32, i32* %arrayidx26, align 4
  %call27 = call i8* @nl_langinfo(i32 %16) #5
  store i8* %call27, i8** %str, align 8
  %17 = load i8*, i8** %str, align 8
  %call28 = call i64 @build_unibyte_string(i8* %17)
  store i64 %call28, i64* %val, align 8
  %18 = load i64, i64* %v17, align 8
  %19 = load i32, i32* %i20, align 4
  %conv29 = sext i32 %19 to i64
  %20 = load i64, i64* %val, align 8
  %21 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 168), align 8
  %call30 = call i64 @code_convert_string_norecord(i64 %20, i64 %21, i1 zeroext false)
  call void @ASET(i64 %18, i64 %conv29, i64 %call30)
  br label %for.inc.31

for.inc.31:                                       ; preds = %for.body.24
  %22 = load i32, i32* %i20, align 4
  %inc32 = add nsw i32 %22, 1
  store i32 %inc32, i32* %i20, align 4
  br label %for.cond.21

for.end.33:                                       ; preds = %for.cond.21
  %23 = load i64, i64* %v17, align 8
  store i64 %23, i64* %retval
  br label %return

if.end:                                           ; preds = %if.else.12
  br label %if.end.34

if.end.34:                                        ; preds = %if.end
  br label %if.end.35

if.end.35:                                        ; preds = %if.end.34
  %call36 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call36, i64* %retval
  br label %return

return:                                           ; preds = %if.end.35, %for.end.33, %for.end, %if.then
  %24 = load i64, i64* %retval
  ret i64 %24
}

; Function Attrs: nounwind
declare i8* @nl_langinfo(i32) #6

declare i64 @Fmake_vector(i64, i64) #2

declare void @synchronize_system_time_locale() #2

declare i64 @build_unibyte_string(i8*) #2

declare i64 @code_convert_string_norecord(i64, i64, i1 zeroext) #2

; Function Attrs: nounwind uwtable
define i64 @Fbase64_encode_region(i64 %beg, i64 %end, i64 %no_line_break) #1 {
entry:
  %beg.addr = alloca i64, align 8
  %end.addr = alloca i64, align 8
  %no_line_break.addr = alloca i64, align 8
  %encoded = alloca i8*, align 8
  %allength = alloca i64, align 8
  %length = alloca i64, align 8
  %ibeg = alloca i64, align 8
  %iend = alloca i64, align 8
  %encoded_length = alloca i64, align 8
  %old_pos = alloca i64, align 8
  %sa_avail = alloca i64, align 8
  %sa_count = alloca i64, align 8
  %sa_must_free = alloca i8, align 1
  store i64 %beg, i64* %beg.addr, align 8
  store i64 %end, i64* %end.addr, align 8
  store i64 %no_line_break, i64* %no_line_break.addr, align 8
  %0 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt = getelementptr inbounds %struct.buffer, %struct.buffer* %0, i32 0, i32 75
  %1 = load i64, i64* %pt, align 8
  %add = add nsw i64 %1, 0
  store i64 %add, i64* %old_pos, align 8
  store i64 16384, i64* %sa_avail, align 8
  %call = call i64 @SPECPDL_INDEX()
  store i64 %call, i64* %sa_count, align 8
  store i8 0, i8* %sa_must_free, align 1
  call void @validate_region(i64* %beg.addr, i64* %end.addr)
  %2 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %3 = load i64, i64* %beg.addr, align 8
  %shr = ashr i64 %3, 2
  %call1 = call i64 @buf_charpos_to_bytepos(%struct.buffer* %2, i64 %shr)
  store i64 %call1, i64* %ibeg, align 8
  %4 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %5 = load i64, i64* %end.addr, align 8
  %shr2 = ashr i64 %5, 2
  %call3 = call i64 @buf_charpos_to_bytepos(%struct.buffer* %4, i64 %shr2)
  store i64 %call3, i64* %iend, align 8
  %6 = load i64, i64* %beg.addr, align 8
  %shr4 = ashr i64 %6, 2
  %7 = load i64, i64* %ibeg, align 8
  call void @move_gap_both(i64 %shr4, i64 %7)
  %8 = load i64, i64* %iend, align 8
  %9 = load i64, i64* %ibeg, align 8
  %sub = sub nsw i64 %8, %9
  store i64 %sub, i64* %length, align 8
  %10 = load i64, i64* %length, align 8
  %11 = load i64, i64* %length, align 8
  %div = sdiv i64 %11, 3
  %add5 = add nsw i64 %10, %div
  %add6 = add nsw i64 %add5, 1
  store i64 %add6, i64* %allength, align 8
  %12 = load i64, i64* %allength, align 8
  %div7 = sdiv i64 %12, 76
  %add8 = add nsw i64 %div7, 1
  %add9 = add nsw i64 %add8, 6
  %13 = load i64, i64* %allength, align 8
  %add10 = add nsw i64 %13, %add9
  store i64 %add10, i64* %allength, align 8
  %14 = load i64, i64* %allength, align 8
  %15 = load i64, i64* %sa_avail, align 8
  %cmp = icmp sle i64 %14, %15
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %16 = load i64, i64* %allength, align 8
  %17 = load i64, i64* %sa_avail, align 8
  %sub11 = sub nsw i64 %17, %16
  store i64 %sub11, i64* %sa_avail, align 8
  %18 = load i64, i64* %allength, align 8
  %19 = alloca i8, i64 %18
  br label %cond.end

cond.false:                                       ; preds = %entry
  store i8 1, i8* %sa_must_free, align 1
  %20 = load i64, i64* %allength, align 8
  %call12 = call i8* @record_xmalloc(i64 %20)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %19, %cond.true ], [ %call12, %cond.false ]
  store i8* %cond, i8** %encoded, align 8
  %21 = load i64, i64* %ibeg, align 8
  %22 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text = getelementptr inbounds %struct.buffer, %struct.buffer* %22, i32 0, i32 73
  %23 = load %struct.buffer_text*, %struct.buffer_text** %text, align 8
  %gpt_byte = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %23, i32 0, i32 3
  %24 = load i64, i64* %gpt_byte, align 8
  %cmp13 = icmp sge i64 %21, %24
  br i1 %cmp13, label %cond.true.14, label %cond.false.16

cond.true.14:                                     ; preds = %cond.end
  %25 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text15 = getelementptr inbounds %struct.buffer, %struct.buffer* %25, i32 0, i32 73
  %26 = load %struct.buffer_text*, %struct.buffer_text** %text15, align 8
  %gap_size = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %26, i32 0, i32 5
  %27 = load i64, i64* %gap_size, align 8
  br label %cond.end.17

cond.false.16:                                    ; preds = %cond.end
  br label %cond.end.17

cond.end.17:                                      ; preds = %cond.false.16, %cond.true.14
  %cond18 = phi i64 [ %27, %cond.true.14 ], [ 0, %cond.false.16 ]
  %28 = load i64, i64* %ibeg, align 8
  %add19 = add nsw i64 %cond18, %28
  %29 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text20 = getelementptr inbounds %struct.buffer, %struct.buffer* %29, i32 0, i32 73
  %30 = load %struct.buffer_text*, %struct.buffer_text** %text20, align 8
  %beg21 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %30, i32 0, i32 0
  %31 = load i8*, i8** %beg21, align 8
  %add.ptr = getelementptr inbounds i8, i8* %31, i64 %add19
  %add.ptr22 = getelementptr inbounds i8, i8* %add.ptr, i64 -1
  %32 = load i8*, i8** %encoded, align 8
  %33 = load i64, i64* %length, align 8
  %34 = load i64, i64* %no_line_break.addr, align 8
  %call23 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp24 = icmp eq i64 %34, %call23
  %35 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %enable_multibyte_characters_ = getelementptr inbounds %struct.buffer, %struct.buffer* %35, i32 0, i32 39
  %36 = load i64, i64* %enable_multibyte_characters_, align 8
  %call25 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp26 = icmp eq i64 %36, %call25
  %lnot = xor i1 %cmp26, true
  %call27 = call i64 @base64_encode_1(i8* %add.ptr22, i8* %32, i64 %33, i1 zeroext %cmp24, i1 zeroext %lnot)
  store i64 %call27, i64* %encoded_length, align 8
  %37 = load i64, i64* %encoded_length, align 8
  %38 = load i64, i64* %allength, align 8
  %cmp28 = icmp sgt i64 %37, %38
  br i1 %cmp28, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end.17
  call void @emacs_abort() #8
  unreachable

if.end:                                           ; preds = %cond.end.17
  %39 = load i64, i64* %encoded_length, align 8
  %cmp29 = icmp slt i64 %39, 0
  br i1 %cmp29, label %if.then.30, label %if.end.35

if.then.30:                                       ; preds = %if.end
  br label %do.body

do.body:                                          ; preds = %if.then.30
  %40 = load i8, i8* %sa_must_free, align 1
  %tobool = trunc i8 %40 to i1
  br i1 %tobool, label %if.then.31, label %if.end.34

if.then.31:                                       ; preds = %do.body
  store i8 0, i8* %sa_must_free, align 1
  %41 = load i64, i64* %sa_count, align 8
  %call32 = call i64 @builtin_lisp_symbol(i32 0)
  %call33 = call i64 @unbind_to(i64 %41, i64 %call32)
  br label %if.end.34

if.end.34:                                        ; preds = %if.then.31, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end.34
  call void (i8*, ...) @error(i8* getelementptr inbounds ([48 x i8], [48 x i8]* @.str.14, i32 0, i32 0)) #8
  unreachable

if.end.35:                                        ; preds = %if.end
  %42 = load i64, i64* %beg.addr, align 8
  %shr36 = ashr i64 %42, 2
  %43 = load i64, i64* %ibeg, align 8
  call void @set_point_both(i64 %shr36, i64 %43)
  %44 = load i8*, i8** %encoded, align 8
  %45 = load i64, i64* %encoded_length, align 8
  call void @insert(i8* %44, i64 %45)
  br label %do.body.37

do.body.37:                                       ; preds = %if.end.35
  %46 = load i8, i8* %sa_must_free, align 1
  %tobool38 = trunc i8 %46 to i1
  br i1 %tobool38, label %if.then.39, label %if.end.42

if.then.39:                                       ; preds = %do.body.37
  store i8 0, i8* %sa_must_free, align 1
  %47 = load i64, i64* %sa_count, align 8
  %call40 = call i64 @builtin_lisp_symbol(i32 0)
  %call41 = call i64 @unbind_to(i64 %47, i64 %call40)
  br label %if.end.42

if.end.42:                                        ; preds = %if.then.39, %do.body.37
  br label %do.end.43

do.end.43:                                        ; preds = %if.end.42
  %48 = load i64, i64* %ibeg, align 8
  %49 = load i64, i64* %encoded_length, align 8
  %add44 = add nsw i64 %48, %49
  %50 = load i64, i64* %iend, align 8
  %51 = load i64, i64* %encoded_length, align 8
  %add45 = add nsw i64 %50, %51
  call void @del_range_byte(i64 %add44, i64 %add45, i1 zeroext true)
  %52 = load i64, i64* %old_pos, align 8
  %53 = load i64, i64* %end.addr, align 8
  %shr46 = ashr i64 %53, 2
  %cmp47 = icmp sge i64 %52, %shr46
  br i1 %cmp47, label %if.then.48, label %if.else

if.then.48:                                       ; preds = %do.end.43
  %54 = load i64, i64* %encoded_length, align 8
  %55 = load i64, i64* %end.addr, align 8
  %shr49 = ashr i64 %55, 2
  %56 = load i64, i64* %beg.addr, align 8
  %shr50 = ashr i64 %56, 2
  %sub51 = sub nsw i64 %shr49, %shr50
  %sub52 = sub nsw i64 %54, %sub51
  %57 = load i64, i64* %old_pos, align 8
  %add53 = add nsw i64 %57, %sub52
  store i64 %add53, i64* %old_pos, align 8
  br label %if.end.59

if.else:                                          ; preds = %do.end.43
  %58 = load i64, i64* %old_pos, align 8
  %59 = load i64, i64* %beg.addr, align 8
  %shr54 = ashr i64 %59, 2
  %cmp55 = icmp sgt i64 %58, %shr54
  br i1 %cmp55, label %if.then.56, label %if.end.58

if.then.56:                                       ; preds = %if.else
  %60 = load i64, i64* %beg.addr, align 8
  %shr57 = ashr i64 %60, 2
  store i64 %shr57, i64* %old_pos, align 8
  br label %if.end.58

if.end.58:                                        ; preds = %if.then.56, %if.else
  br label %if.end.59

if.end.59:                                        ; preds = %if.end.58, %if.then.48
  %61 = load i64, i64* %old_pos, align 8
  call void @set_point(i64 %61)
  %62 = load i64, i64* %encoded_length, align 8
  %shl = shl i64 %62, 2
  %add60 = add i64 %shl, 2
  ret i64 %add60
}

declare void @validate_region(i64*, i64*) #2

declare i64 @buf_charpos_to_bytepos(%struct.buffer*, i64) #2

declare void @move_gap_both(i64, i64) #2

; Function Attrs: nounwind uwtable
define internal i64 @base64_encode_1(i8* %from, i8* %to, i64 %length, i1 zeroext %line_break, i1 zeroext %multibyte) #1 {
entry:
  %retval = alloca i64, align 8
  %from.addr = alloca i8*, align 8
  %to.addr = alloca i8*, align 8
  %length.addr = alloca i64, align 8
  %line_break.addr = alloca i8, align 1
  %multibyte.addr = alloca i8, align 1
  %counter = alloca i32, align 4
  %i = alloca i64, align 8
  %e = alloca i8*, align 8
  %c = alloca i32, align 4
  %value = alloca i32, align 4
  %bytes = alloca i32, align 4
  store i8* %from, i8** %from.addr, align 8
  store i8* %to, i8** %to.addr, align 8
  store i64 %length, i64* %length.addr, align 8
  %frombool = zext i1 %line_break to i8
  store i8 %frombool, i8* %line_break.addr, align 1
  %frombool1 = zext i1 %multibyte to i8
  store i8 %frombool1, i8* %multibyte.addr, align 1
  store i32 0, i32* %counter, align 4
  store i64 0, i64* %i, align 8
  %0 = load i8*, i8** %to.addr, align 8
  store i8* %0, i8** %e, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end.295, %entry
  %1 = load i64, i64* %i, align 8
  %2 = load i64, i64* %length.addr, align 8
  %cmp = icmp slt i64 %1, %2
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %3 = load i8, i8* %multibyte.addr, align 1
  %tobool = trunc i8 %3 to i1
  br i1 %tobool, label %if.then, label %if.else.71

if.then:                                          ; preds = %while.body
  %4 = load i8*, i8** %from.addr, align 8
  %5 = load i64, i64* %i, align 8
  %add.ptr = getelementptr inbounds i8, i8* %4, i64 %5
  %arrayidx = getelementptr inbounds i8, i8* %add.ptr, i64 0
  %6 = load i8, i8* %arrayidx, align 1
  %conv = zext i8 %6 to i32
  %and = and i32 %conv, 128
  %tobool2 = icmp ne i32 %and, 0
  br i1 %tobool2, label %cond.false, label %cond.true

cond.true:                                        ; preds = %if.then
  store i32 1, i32* %bytes, align 4
  %7 = load i8*, i8** %from.addr, align 8
  %8 = load i64, i64* %i, align 8
  %add.ptr3 = getelementptr inbounds i8, i8* %7, i64 %8
  %arrayidx4 = getelementptr inbounds i8, i8* %add.ptr3, i64 0
  %9 = load i8, i8* %arrayidx4, align 1
  %conv5 = zext i8 %9 to i32
  br label %cond.end.53

cond.false:                                       ; preds = %if.then
  %10 = load i8*, i8** %from.addr, align 8
  %11 = load i64, i64* %i, align 8
  %add.ptr6 = getelementptr inbounds i8, i8* %10, i64 %11
  %arrayidx7 = getelementptr inbounds i8, i8* %add.ptr6, i64 0
  %12 = load i8, i8* %arrayidx7, align 1
  %conv8 = zext i8 %12 to i32
  %and9 = and i32 %conv8, 32
  %tobool10 = icmp ne i32 %and9, 0
  br i1 %tobool10, label %cond.false.25, label %cond.true.11

cond.true.11:                                     ; preds = %cond.false
  store i32 2, i32* %bytes, align 4
  %13 = load i8*, i8** %from.addr, align 8
  %14 = load i64, i64* %i, align 8
  %add.ptr12 = getelementptr inbounds i8, i8* %13, i64 %14
  %arrayidx13 = getelementptr inbounds i8, i8* %add.ptr12, i64 0
  %15 = load i8, i8* %arrayidx13, align 1
  %conv14 = zext i8 %15 to i32
  %and15 = and i32 %conv14, 31
  %shl = shl i32 %and15, 6
  %16 = load i8*, i8** %from.addr, align 8
  %17 = load i64, i64* %i, align 8
  %add.ptr16 = getelementptr inbounds i8, i8* %16, i64 %17
  %arrayidx17 = getelementptr inbounds i8, i8* %add.ptr16, i64 1
  %18 = load i8, i8* %arrayidx17, align 1
  %conv18 = zext i8 %18 to i32
  %and19 = and i32 %conv18, 63
  %or = or i32 %shl, %and19
  %19 = load i8*, i8** %from.addr, align 8
  %20 = load i64, i64* %i, align 8
  %add.ptr20 = getelementptr inbounds i8, i8* %19, i64 %20
  %arrayidx21 = getelementptr inbounds i8, i8* %add.ptr20, i64 0
  %21 = load i8, i8* %arrayidx21, align 1
  %conv22 = zext i8 %21 to i32
  %cmp23 = icmp slt i32 %conv22, 194
  %cond = select i1 %cmp23, i32 4194176, i32 0
  %add = add nsw i32 %or, %cond
  br label %cond.end.51

cond.false.25:                                    ; preds = %cond.false
  %22 = load i8*, i8** %from.addr, align 8
  %23 = load i64, i64* %i, align 8
  %add.ptr26 = getelementptr inbounds i8, i8* %22, i64 %23
  %arrayidx27 = getelementptr inbounds i8, i8* %add.ptr26, i64 0
  %24 = load i8, i8* %arrayidx27, align 1
  %conv28 = zext i8 %24 to i32
  %and29 = and i32 %conv28, 16
  %tobool30 = icmp ne i32 %and29, 0
  br i1 %tobool30, label %cond.false.48, label %cond.true.31

cond.true.31:                                     ; preds = %cond.false.25
  store i32 3, i32* %bytes, align 4
  %25 = load i8*, i8** %from.addr, align 8
  %26 = load i64, i64* %i, align 8
  %add.ptr32 = getelementptr inbounds i8, i8* %25, i64 %26
  %arrayidx33 = getelementptr inbounds i8, i8* %add.ptr32, i64 0
  %27 = load i8, i8* %arrayidx33, align 1
  %conv34 = zext i8 %27 to i32
  %and35 = and i32 %conv34, 15
  %shl36 = shl i32 %and35, 12
  %28 = load i8*, i8** %from.addr, align 8
  %29 = load i64, i64* %i, align 8
  %add.ptr37 = getelementptr inbounds i8, i8* %28, i64 %29
  %arrayidx38 = getelementptr inbounds i8, i8* %add.ptr37, i64 1
  %30 = load i8, i8* %arrayidx38, align 1
  %conv39 = zext i8 %30 to i32
  %and40 = and i32 %conv39, 63
  %shl41 = shl i32 %and40, 6
  %or42 = or i32 %shl36, %shl41
  %31 = load i8*, i8** %from.addr, align 8
  %32 = load i64, i64* %i, align 8
  %add.ptr43 = getelementptr inbounds i8, i8* %31, i64 %32
  %arrayidx44 = getelementptr inbounds i8, i8* %add.ptr43, i64 2
  %33 = load i8, i8* %arrayidx44, align 1
  %conv45 = zext i8 %33 to i32
  %and46 = and i32 %conv45, 63
  %or47 = or i32 %or42, %and46
  br label %cond.end

cond.false.48:                                    ; preds = %cond.false.25
  %34 = load i8*, i8** %from.addr, align 8
  %35 = load i64, i64* %i, align 8
  %add.ptr49 = getelementptr inbounds i8, i8* %34, i64 %35
  %call = call i32 @string_char(i8* %add.ptr49, i8** null, i32* %bytes)
  br label %cond.end

cond.end:                                         ; preds = %cond.false.48, %cond.true.31
  %cond50 = phi i32 [ %or47, %cond.true.31 ], [ %call, %cond.false.48 ]
  br label %cond.end.51

cond.end.51:                                      ; preds = %cond.end, %cond.true.11
  %cond52 = phi i32 [ %add, %cond.true.11 ], [ %cond50, %cond.end ]
  br label %cond.end.53

cond.end.53:                                      ; preds = %cond.end.51, %cond.true
  %cond54 = phi i32 [ %conv5, %cond.true ], [ %cond52, %cond.end.51 ]
  store i32 %cond54, i32* %c, align 4
  %36 = load i32, i32* %c, align 4
  %cmp55 = icmp sgt i32 %36, 4194175
  br i1 %cmp55, label %if.then.57, label %if.else

if.then.57:                                       ; preds = %cond.end.53
  %37 = load i32, i32* %c, align 4
  %cmp58 = icmp sgt i32 %37, 4194175
  br i1 %cmp58, label %cond.true.60, label %cond.false.61

cond.true.60:                                     ; preds = %if.then.57
  %38 = load i32, i32* %c, align 4
  %sub = sub nsw i32 %38, 4194048
  br label %cond.end.63

cond.false.61:                                    ; preds = %if.then.57
  %39 = load i32, i32* %c, align 4
  %and62 = and i32 %39, 255
  br label %cond.end.63

cond.end.63:                                      ; preds = %cond.false.61, %cond.true.60
  %cond64 = phi i32 [ %sub, %cond.true.60 ], [ %and62, %cond.false.61 ]
  store i32 %cond64, i32* %c, align 4
  br label %if.end.68

if.else:                                          ; preds = %cond.end.53
  %40 = load i32, i32* %c, align 4
  %cmp65 = icmp sge i32 %40, 256
  br i1 %cmp65, label %if.then.67, label %if.end

if.then.67:                                       ; preds = %if.else
  store i64 -1, i64* %retval
  br label %return

if.end:                                           ; preds = %if.else
  br label %if.end.68

if.end.68:                                        ; preds = %if.end, %cond.end.63
  %41 = load i32, i32* %bytes, align 4
  %conv69 = sext i32 %41 to i64
  %42 = load i64, i64* %i, align 8
  %add70 = add nsw i64 %42, %conv69
  store i64 %add70, i64* %i, align 8
  br label %if.end.74

if.else.71:                                       ; preds = %while.body
  %43 = load i64, i64* %i, align 8
  %inc = add nsw i64 %43, 1
  store i64 %inc, i64* %i, align 8
  %44 = load i8*, i8** %from.addr, align 8
  %arrayidx72 = getelementptr inbounds i8, i8* %44, i64 %43
  %45 = load i8, i8* %arrayidx72, align 1
  %conv73 = sext i8 %45 to i32
  store i32 %conv73, i32* %c, align 4
  br label %if.end.74

if.end.74:                                        ; preds = %if.else.71, %if.end.68
  %46 = load i8, i8* %line_break.addr, align 1
  %tobool75 = trunc i8 %46 to i1
  br i1 %tobool75, label %if.then.76, label %if.end.83

if.then.76:                                       ; preds = %if.end.74
  %47 = load i32, i32* %counter, align 4
  %cmp77 = icmp slt i32 %47, 19
  br i1 %cmp77, label %if.then.79, label %if.else.81

if.then.79:                                       ; preds = %if.then.76
  %48 = load i32, i32* %counter, align 4
  %inc80 = add nsw i32 %48, 1
  store i32 %inc80, i32* %counter, align 4
  br label %if.end.82

if.else.81:                                       ; preds = %if.then.76
  %49 = load i8*, i8** %e, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %49, i32 1
  store i8* %incdec.ptr, i8** %e, align 8
  store i8 10, i8* %49, align 1
  store i32 1, i32* %counter, align 4
  br label %if.end.82

if.end.82:                                        ; preds = %if.else.81, %if.then.79
  br label %if.end.83

if.end.83:                                        ; preds = %if.end.82, %if.end.74
  %50 = load i32, i32* %c, align 4
  %shr = ashr i32 %50, 2
  %and84 = and i32 63, %shr
  %idxprom = sext i32 %and84 to i64
  %arrayidx85 = getelementptr inbounds [64 x i8], [64 x i8]* @base64_value_to_char, i32 0, i64 %idxprom
  %51 = load i8, i8* %arrayidx85, align 1
  %52 = load i8*, i8** %e, align 8
  %incdec.ptr86 = getelementptr inbounds i8, i8* %52, i32 1
  store i8* %incdec.ptr86, i8** %e, align 8
  store i8 %51, i8* %52, align 1
  %53 = load i32, i32* %c, align 4
  %and87 = and i32 3, %53
  %shl88 = shl i32 %and87, 4
  store i32 %shl88, i32* %value, align 4
  %54 = load i64, i64* %i, align 8
  %55 = load i64, i64* %length.addr, align 8
  %cmp89 = icmp eq i64 %54, %55
  br i1 %cmp89, label %if.then.91, label %if.end.97

if.then.91:                                       ; preds = %if.end.83
  %56 = load i32, i32* %value, align 4
  %idxprom92 = zext i32 %56 to i64
  %arrayidx93 = getelementptr inbounds [64 x i8], [64 x i8]* @base64_value_to_char, i32 0, i64 %idxprom92
  %57 = load i8, i8* %arrayidx93, align 1
  %58 = load i8*, i8** %e, align 8
  %incdec.ptr94 = getelementptr inbounds i8, i8* %58, i32 1
  store i8* %incdec.ptr94, i8** %e, align 8
  store i8 %57, i8* %58, align 1
  %59 = load i8*, i8** %e, align 8
  %incdec.ptr95 = getelementptr inbounds i8, i8* %59, i32 1
  store i8* %incdec.ptr95, i8** %e, align 8
  store i8 61, i8* %59, align 1
  %60 = load i8*, i8** %e, align 8
  %incdec.ptr96 = getelementptr inbounds i8, i8* %60, i32 1
  store i8* %incdec.ptr96, i8** %e, align 8
  store i8 61, i8* %60, align 1
  br label %while.end

if.end.97:                                        ; preds = %if.end.83
  %61 = load i8, i8* %multibyte.addr, align 1
  %tobool98 = trunc i8 %61 to i1
  br i1 %tobool98, label %if.then.99, label %if.else.184

if.then.99:                                       ; preds = %if.end.97
  %62 = load i8*, i8** %from.addr, align 8
  %63 = load i64, i64* %i, align 8
  %add.ptr100 = getelementptr inbounds i8, i8* %62, i64 %63
  %arrayidx101 = getelementptr inbounds i8, i8* %add.ptr100, i64 0
  %64 = load i8, i8* %arrayidx101, align 1
  %conv102 = zext i8 %64 to i32
  %and103 = and i32 %conv102, 128
  %tobool104 = icmp ne i32 %and103, 0
  br i1 %tobool104, label %cond.false.109, label %cond.true.105

cond.true.105:                                    ; preds = %if.then.99
  store i32 1, i32* %bytes, align 4
  %65 = load i8*, i8** %from.addr, align 8
  %66 = load i64, i64* %i, align 8
  %add.ptr106 = getelementptr inbounds i8, i8* %65, i64 %66
  %arrayidx107 = getelementptr inbounds i8, i8* %add.ptr106, i64 0
  %67 = load i8, i8* %arrayidx107, align 1
  %conv108 = zext i8 %67 to i32
  br label %cond.end.163

cond.false.109:                                   ; preds = %if.then.99
  %68 = load i8*, i8** %from.addr, align 8
  %69 = load i64, i64* %i, align 8
  %add.ptr110 = getelementptr inbounds i8, i8* %68, i64 %69
  %arrayidx111 = getelementptr inbounds i8, i8* %add.ptr110, i64 0
  %70 = load i8, i8* %arrayidx111, align 1
  %conv112 = zext i8 %70 to i32
  %and113 = and i32 %conv112, 32
  %tobool114 = icmp ne i32 %and113, 0
  br i1 %tobool114, label %cond.false.133, label %cond.true.115

cond.true.115:                                    ; preds = %cond.false.109
  store i32 2, i32* %bytes, align 4
  %71 = load i8*, i8** %from.addr, align 8
  %72 = load i64, i64* %i, align 8
  %add.ptr116 = getelementptr inbounds i8, i8* %71, i64 %72
  %arrayidx117 = getelementptr inbounds i8, i8* %add.ptr116, i64 0
  %73 = load i8, i8* %arrayidx117, align 1
  %conv118 = zext i8 %73 to i32
  %and119 = and i32 %conv118, 31
  %shl120 = shl i32 %and119, 6
  %74 = load i8*, i8** %from.addr, align 8
  %75 = load i64, i64* %i, align 8
  %add.ptr121 = getelementptr inbounds i8, i8* %74, i64 %75
  %arrayidx122 = getelementptr inbounds i8, i8* %add.ptr121, i64 1
  %76 = load i8, i8* %arrayidx122, align 1
  %conv123 = zext i8 %76 to i32
  %and124 = and i32 %conv123, 63
  %or125 = or i32 %shl120, %and124
  %77 = load i8*, i8** %from.addr, align 8
  %78 = load i64, i64* %i, align 8
  %add.ptr126 = getelementptr inbounds i8, i8* %77, i64 %78
  %arrayidx127 = getelementptr inbounds i8, i8* %add.ptr126, i64 0
  %79 = load i8, i8* %arrayidx127, align 1
  %conv128 = zext i8 %79 to i32
  %cmp129 = icmp slt i32 %conv128, 194
  %cond131 = select i1 %cmp129, i32 4194176, i32 0
  %add132 = add nsw i32 %or125, %cond131
  br label %cond.end.161

cond.false.133:                                   ; preds = %cond.false.109
  %80 = load i8*, i8** %from.addr, align 8
  %81 = load i64, i64* %i, align 8
  %add.ptr134 = getelementptr inbounds i8, i8* %80, i64 %81
  %arrayidx135 = getelementptr inbounds i8, i8* %add.ptr134, i64 0
  %82 = load i8, i8* %arrayidx135, align 1
  %conv136 = zext i8 %82 to i32
  %and137 = and i32 %conv136, 16
  %tobool138 = icmp ne i32 %and137, 0
  br i1 %tobool138, label %cond.false.156, label %cond.true.139

cond.true.139:                                    ; preds = %cond.false.133
  store i32 3, i32* %bytes, align 4
  %83 = load i8*, i8** %from.addr, align 8
  %84 = load i64, i64* %i, align 8
  %add.ptr140 = getelementptr inbounds i8, i8* %83, i64 %84
  %arrayidx141 = getelementptr inbounds i8, i8* %add.ptr140, i64 0
  %85 = load i8, i8* %arrayidx141, align 1
  %conv142 = zext i8 %85 to i32
  %and143 = and i32 %conv142, 15
  %shl144 = shl i32 %and143, 12
  %86 = load i8*, i8** %from.addr, align 8
  %87 = load i64, i64* %i, align 8
  %add.ptr145 = getelementptr inbounds i8, i8* %86, i64 %87
  %arrayidx146 = getelementptr inbounds i8, i8* %add.ptr145, i64 1
  %88 = load i8, i8* %arrayidx146, align 1
  %conv147 = zext i8 %88 to i32
  %and148 = and i32 %conv147, 63
  %shl149 = shl i32 %and148, 6
  %or150 = or i32 %shl144, %shl149
  %89 = load i8*, i8** %from.addr, align 8
  %90 = load i64, i64* %i, align 8
  %add.ptr151 = getelementptr inbounds i8, i8* %89, i64 %90
  %arrayidx152 = getelementptr inbounds i8, i8* %add.ptr151, i64 2
  %91 = load i8, i8* %arrayidx152, align 1
  %conv153 = zext i8 %91 to i32
  %and154 = and i32 %conv153, 63
  %or155 = or i32 %or150, %and154
  br label %cond.end.159

cond.false.156:                                   ; preds = %cond.false.133
  %92 = load i8*, i8** %from.addr, align 8
  %93 = load i64, i64* %i, align 8
  %add.ptr157 = getelementptr inbounds i8, i8* %92, i64 %93
  %call158 = call i32 @string_char(i8* %add.ptr157, i8** null, i32* %bytes)
  br label %cond.end.159

cond.end.159:                                     ; preds = %cond.false.156, %cond.true.139
  %cond160 = phi i32 [ %or155, %cond.true.139 ], [ %call158, %cond.false.156 ]
  br label %cond.end.161

cond.end.161:                                     ; preds = %cond.end.159, %cond.true.115
  %cond162 = phi i32 [ %add132, %cond.true.115 ], [ %cond160, %cond.end.159 ]
  br label %cond.end.163

cond.end.163:                                     ; preds = %cond.end.161, %cond.true.105
  %cond164 = phi i32 [ %conv108, %cond.true.105 ], [ %cond162, %cond.end.161 ]
  store i32 %cond164, i32* %c, align 4
  %94 = load i32, i32* %c, align 4
  %cmp165 = icmp sgt i32 %94, 4194175
  br i1 %cmp165, label %if.then.167, label %if.else.176

if.then.167:                                      ; preds = %cond.end.163
  %95 = load i32, i32* %c, align 4
  %cmp168 = icmp sgt i32 %95, 4194175
  br i1 %cmp168, label %cond.true.170, label %cond.false.172

cond.true.170:                                    ; preds = %if.then.167
  %96 = load i32, i32* %c, align 4
  %sub171 = sub nsw i32 %96, 4194048
  br label %cond.end.174

cond.false.172:                                   ; preds = %if.then.167
  %97 = load i32, i32* %c, align 4
  %and173 = and i32 %97, 255
  br label %cond.end.174

cond.end.174:                                     ; preds = %cond.false.172, %cond.true.170
  %cond175 = phi i32 [ %sub171, %cond.true.170 ], [ %and173, %cond.false.172 ]
  store i32 %cond175, i32* %c, align 4
  br label %if.end.181

if.else.176:                                      ; preds = %cond.end.163
  %98 = load i32, i32* %c, align 4
  %cmp177 = icmp sge i32 %98, 256
  br i1 %cmp177, label %if.then.179, label %if.end.180

if.then.179:                                      ; preds = %if.else.176
  store i64 -1, i64* %retval
  br label %return

if.end.180:                                       ; preds = %if.else.176
  br label %if.end.181

if.end.181:                                       ; preds = %if.end.180, %cond.end.174
  %99 = load i32, i32* %bytes, align 4
  %conv182 = sext i32 %99 to i64
  %100 = load i64, i64* %i, align 8
  %add183 = add nsw i64 %100, %conv182
  store i64 %add183, i64* %i, align 8
  br label %if.end.188

if.else.184:                                      ; preds = %if.end.97
  %101 = load i64, i64* %i, align 8
  %inc185 = add nsw i64 %101, 1
  store i64 %inc185, i64* %i, align 8
  %102 = load i8*, i8** %from.addr, align 8
  %arrayidx186 = getelementptr inbounds i8, i8* %102, i64 %101
  %103 = load i8, i8* %arrayidx186, align 1
  %conv187 = sext i8 %103 to i32
  store i32 %conv187, i32* %c, align 4
  br label %if.end.188

if.end.188:                                       ; preds = %if.else.184, %if.end.181
  %104 = load i32, i32* %value, align 4
  %105 = load i32, i32* %c, align 4
  %shr189 = ashr i32 %105, 4
  %and190 = and i32 15, %shr189
  %or191 = or i32 %104, %and190
  %idxprom192 = zext i32 %or191 to i64
  %arrayidx193 = getelementptr inbounds [64 x i8], [64 x i8]* @base64_value_to_char, i32 0, i64 %idxprom192
  %106 = load i8, i8* %arrayidx193, align 1
  %107 = load i8*, i8** %e, align 8
  %incdec.ptr194 = getelementptr inbounds i8, i8* %107, i32 1
  store i8* %incdec.ptr194, i8** %e, align 8
  store i8 %106, i8* %107, align 1
  %108 = load i32, i32* %c, align 4
  %and195 = and i32 15, %108
  %shl196 = shl i32 %and195, 2
  store i32 %shl196, i32* %value, align 4
  %109 = load i64, i64* %i, align 8
  %110 = load i64, i64* %length.addr, align 8
  %cmp197 = icmp eq i64 %109, %110
  br i1 %cmp197, label %if.then.199, label %if.end.204

if.then.199:                                      ; preds = %if.end.188
  %111 = load i32, i32* %value, align 4
  %idxprom200 = zext i32 %111 to i64
  %arrayidx201 = getelementptr inbounds [64 x i8], [64 x i8]* @base64_value_to_char, i32 0, i64 %idxprom200
  %112 = load i8, i8* %arrayidx201, align 1
  %113 = load i8*, i8** %e, align 8
  %incdec.ptr202 = getelementptr inbounds i8, i8* %113, i32 1
  store i8* %incdec.ptr202, i8** %e, align 8
  store i8 %112, i8* %113, align 1
  %114 = load i8*, i8** %e, align 8
  %incdec.ptr203 = getelementptr inbounds i8, i8* %114, i32 1
  store i8* %incdec.ptr203, i8** %e, align 8
  store i8 61, i8* %114, align 1
  br label %while.end

if.end.204:                                       ; preds = %if.end.188
  %115 = load i8, i8* %multibyte.addr, align 1
  %tobool205 = trunc i8 %115 to i1
  br i1 %tobool205, label %if.then.206, label %if.else.291

if.then.206:                                      ; preds = %if.end.204
  %116 = load i8*, i8** %from.addr, align 8
  %117 = load i64, i64* %i, align 8
  %add.ptr207 = getelementptr inbounds i8, i8* %116, i64 %117
  %arrayidx208 = getelementptr inbounds i8, i8* %add.ptr207, i64 0
  %118 = load i8, i8* %arrayidx208, align 1
  %conv209 = zext i8 %118 to i32
  %and210 = and i32 %conv209, 128
  %tobool211 = icmp ne i32 %and210, 0
  br i1 %tobool211, label %cond.false.216, label %cond.true.212

cond.true.212:                                    ; preds = %if.then.206
  store i32 1, i32* %bytes, align 4
  %119 = load i8*, i8** %from.addr, align 8
  %120 = load i64, i64* %i, align 8
  %add.ptr213 = getelementptr inbounds i8, i8* %119, i64 %120
  %arrayidx214 = getelementptr inbounds i8, i8* %add.ptr213, i64 0
  %121 = load i8, i8* %arrayidx214, align 1
  %conv215 = zext i8 %121 to i32
  br label %cond.end.270

cond.false.216:                                   ; preds = %if.then.206
  %122 = load i8*, i8** %from.addr, align 8
  %123 = load i64, i64* %i, align 8
  %add.ptr217 = getelementptr inbounds i8, i8* %122, i64 %123
  %arrayidx218 = getelementptr inbounds i8, i8* %add.ptr217, i64 0
  %124 = load i8, i8* %arrayidx218, align 1
  %conv219 = zext i8 %124 to i32
  %and220 = and i32 %conv219, 32
  %tobool221 = icmp ne i32 %and220, 0
  br i1 %tobool221, label %cond.false.240, label %cond.true.222

cond.true.222:                                    ; preds = %cond.false.216
  store i32 2, i32* %bytes, align 4
  %125 = load i8*, i8** %from.addr, align 8
  %126 = load i64, i64* %i, align 8
  %add.ptr223 = getelementptr inbounds i8, i8* %125, i64 %126
  %arrayidx224 = getelementptr inbounds i8, i8* %add.ptr223, i64 0
  %127 = load i8, i8* %arrayidx224, align 1
  %conv225 = zext i8 %127 to i32
  %and226 = and i32 %conv225, 31
  %shl227 = shl i32 %and226, 6
  %128 = load i8*, i8** %from.addr, align 8
  %129 = load i64, i64* %i, align 8
  %add.ptr228 = getelementptr inbounds i8, i8* %128, i64 %129
  %arrayidx229 = getelementptr inbounds i8, i8* %add.ptr228, i64 1
  %130 = load i8, i8* %arrayidx229, align 1
  %conv230 = zext i8 %130 to i32
  %and231 = and i32 %conv230, 63
  %or232 = or i32 %shl227, %and231
  %131 = load i8*, i8** %from.addr, align 8
  %132 = load i64, i64* %i, align 8
  %add.ptr233 = getelementptr inbounds i8, i8* %131, i64 %132
  %arrayidx234 = getelementptr inbounds i8, i8* %add.ptr233, i64 0
  %133 = load i8, i8* %arrayidx234, align 1
  %conv235 = zext i8 %133 to i32
  %cmp236 = icmp slt i32 %conv235, 194
  %cond238 = select i1 %cmp236, i32 4194176, i32 0
  %add239 = add nsw i32 %or232, %cond238
  br label %cond.end.268

cond.false.240:                                   ; preds = %cond.false.216
  %134 = load i8*, i8** %from.addr, align 8
  %135 = load i64, i64* %i, align 8
  %add.ptr241 = getelementptr inbounds i8, i8* %134, i64 %135
  %arrayidx242 = getelementptr inbounds i8, i8* %add.ptr241, i64 0
  %136 = load i8, i8* %arrayidx242, align 1
  %conv243 = zext i8 %136 to i32
  %and244 = and i32 %conv243, 16
  %tobool245 = icmp ne i32 %and244, 0
  br i1 %tobool245, label %cond.false.263, label %cond.true.246

cond.true.246:                                    ; preds = %cond.false.240
  store i32 3, i32* %bytes, align 4
  %137 = load i8*, i8** %from.addr, align 8
  %138 = load i64, i64* %i, align 8
  %add.ptr247 = getelementptr inbounds i8, i8* %137, i64 %138
  %arrayidx248 = getelementptr inbounds i8, i8* %add.ptr247, i64 0
  %139 = load i8, i8* %arrayidx248, align 1
  %conv249 = zext i8 %139 to i32
  %and250 = and i32 %conv249, 15
  %shl251 = shl i32 %and250, 12
  %140 = load i8*, i8** %from.addr, align 8
  %141 = load i64, i64* %i, align 8
  %add.ptr252 = getelementptr inbounds i8, i8* %140, i64 %141
  %arrayidx253 = getelementptr inbounds i8, i8* %add.ptr252, i64 1
  %142 = load i8, i8* %arrayidx253, align 1
  %conv254 = zext i8 %142 to i32
  %and255 = and i32 %conv254, 63
  %shl256 = shl i32 %and255, 6
  %or257 = or i32 %shl251, %shl256
  %143 = load i8*, i8** %from.addr, align 8
  %144 = load i64, i64* %i, align 8
  %add.ptr258 = getelementptr inbounds i8, i8* %143, i64 %144
  %arrayidx259 = getelementptr inbounds i8, i8* %add.ptr258, i64 2
  %145 = load i8, i8* %arrayidx259, align 1
  %conv260 = zext i8 %145 to i32
  %and261 = and i32 %conv260, 63
  %or262 = or i32 %or257, %and261
  br label %cond.end.266

cond.false.263:                                   ; preds = %cond.false.240
  %146 = load i8*, i8** %from.addr, align 8
  %147 = load i64, i64* %i, align 8
  %add.ptr264 = getelementptr inbounds i8, i8* %146, i64 %147
  %call265 = call i32 @string_char(i8* %add.ptr264, i8** null, i32* %bytes)
  br label %cond.end.266

cond.end.266:                                     ; preds = %cond.false.263, %cond.true.246
  %cond267 = phi i32 [ %or262, %cond.true.246 ], [ %call265, %cond.false.263 ]
  br label %cond.end.268

cond.end.268:                                     ; preds = %cond.end.266, %cond.true.222
  %cond269 = phi i32 [ %add239, %cond.true.222 ], [ %cond267, %cond.end.266 ]
  br label %cond.end.270

cond.end.270:                                     ; preds = %cond.end.268, %cond.true.212
  %cond271 = phi i32 [ %conv215, %cond.true.212 ], [ %cond269, %cond.end.268 ]
  store i32 %cond271, i32* %c, align 4
  %148 = load i32, i32* %c, align 4
  %cmp272 = icmp sgt i32 %148, 4194175
  br i1 %cmp272, label %if.then.274, label %if.else.283

if.then.274:                                      ; preds = %cond.end.270
  %149 = load i32, i32* %c, align 4
  %cmp275 = icmp sgt i32 %149, 4194175
  br i1 %cmp275, label %cond.true.277, label %cond.false.279

cond.true.277:                                    ; preds = %if.then.274
  %150 = load i32, i32* %c, align 4
  %sub278 = sub nsw i32 %150, 4194048
  br label %cond.end.281

cond.false.279:                                   ; preds = %if.then.274
  %151 = load i32, i32* %c, align 4
  %and280 = and i32 %151, 255
  br label %cond.end.281

cond.end.281:                                     ; preds = %cond.false.279, %cond.true.277
  %cond282 = phi i32 [ %sub278, %cond.true.277 ], [ %and280, %cond.false.279 ]
  store i32 %cond282, i32* %c, align 4
  br label %if.end.288

if.else.283:                                      ; preds = %cond.end.270
  %152 = load i32, i32* %c, align 4
  %cmp284 = icmp sge i32 %152, 256
  br i1 %cmp284, label %if.then.286, label %if.end.287

if.then.286:                                      ; preds = %if.else.283
  store i64 -1, i64* %retval
  br label %return

if.end.287:                                       ; preds = %if.else.283
  br label %if.end.288

if.end.288:                                       ; preds = %if.end.287, %cond.end.281
  %153 = load i32, i32* %bytes, align 4
  %conv289 = sext i32 %153 to i64
  %154 = load i64, i64* %i, align 8
  %add290 = add nsw i64 %154, %conv289
  store i64 %add290, i64* %i, align 8
  br label %if.end.295

if.else.291:                                      ; preds = %if.end.204
  %155 = load i64, i64* %i, align 8
  %inc292 = add nsw i64 %155, 1
  store i64 %inc292, i64* %i, align 8
  %156 = load i8*, i8** %from.addr, align 8
  %arrayidx293 = getelementptr inbounds i8, i8* %156, i64 %155
  %157 = load i8, i8* %arrayidx293, align 1
  %conv294 = sext i8 %157 to i32
  store i32 %conv294, i32* %c, align 4
  br label %if.end.295

if.end.295:                                       ; preds = %if.else.291, %if.end.288
  %158 = load i32, i32* %value, align 4
  %159 = load i32, i32* %c, align 4
  %shr296 = ashr i32 %159, 6
  %and297 = and i32 3, %shr296
  %or298 = or i32 %158, %and297
  %idxprom299 = zext i32 %or298 to i64
  %arrayidx300 = getelementptr inbounds [64 x i8], [64 x i8]* @base64_value_to_char, i32 0, i64 %idxprom299
  %160 = load i8, i8* %arrayidx300, align 1
  %161 = load i8*, i8** %e, align 8
  %incdec.ptr301 = getelementptr inbounds i8, i8* %161, i32 1
  store i8* %incdec.ptr301, i8** %e, align 8
  store i8 %160, i8* %161, align 1
  %162 = load i32, i32* %c, align 4
  %and302 = and i32 63, %162
  %idxprom303 = sext i32 %and302 to i64
  %arrayidx304 = getelementptr inbounds [64 x i8], [64 x i8]* @base64_value_to_char, i32 0, i64 %idxprom303
  %163 = load i8, i8* %arrayidx304, align 1
  %164 = load i8*, i8** %e, align 8
  %incdec.ptr305 = getelementptr inbounds i8, i8* %164, i32 1
  store i8* %incdec.ptr305, i8** %e, align 8
  store i8 %163, i8* %164, align 1
  br label %while.cond

while.end:                                        ; preds = %if.then.199, %if.then.91, %while.cond
  %165 = load i8*, i8** %e, align 8
  %166 = load i8*, i8** %to.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %165 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %166 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, i64* %retval
  br label %return

return:                                           ; preds = %while.end, %if.then.286, %if.then.179, %if.then.67
  %167 = load i64, i64* %retval
  ret i64 %167
}

; Function Attrs: noreturn
declare void @emacs_abort() #3

declare void @set_point_both(i64, i64) #2

declare void @insert(i8*, i64) #2

declare void @del_range_byte(i64, i64, i1 zeroext) #2

declare void @set_point(i64) #2

; Function Attrs: nounwind uwtable
define i64 @Fbase64_encode_string(i64 %string, i64 %no_line_break) #1 {
entry:
  %string.addr = alloca i64, align 8
  %no_line_break.addr = alloca i64, align 8
  %allength = alloca i64, align 8
  %length = alloca i64, align 8
  %encoded_length = alloca i64, align 8
  %encoded = alloca i8*, align 8
  %encoded_string = alloca i64, align 8
  %sa_avail = alloca i64, align 8
  %sa_count = alloca i64, align 8
  %sa_must_free = alloca i8, align 1
  store i64 %string, i64* %string.addr, align 8
  store i64 %no_line_break, i64* %no_line_break.addr, align 8
  store i64 16384, i64* %sa_avail, align 8
  %call = call i64 @SPECPDL_INDEX()
  store i64 %call, i64* %sa_count, align 8
  store i8 0, i8* %sa_must_free, align 1
  %0 = load i64, i64* %string.addr, align 8
  call void @CHECK_STRING(i64 %0)
  %1 = load i64, i64* %string.addr, align 8
  %call1 = call i64 @SBYTES(i64 %1)
  store i64 %call1, i64* %length, align 8
  %2 = load i64, i64* %length, align 8
  %3 = load i64, i64* %length, align 8
  %div = sdiv i64 %3, 3
  %add = add nsw i64 %2, %div
  %add2 = add nsw i64 %add, 1
  store i64 %add2, i64* %allength, align 8
  %4 = load i64, i64* %allength, align 8
  %div3 = sdiv i64 %4, 76
  %add4 = add nsw i64 %div3, 1
  %add5 = add nsw i64 %add4, 6
  %5 = load i64, i64* %allength, align 8
  %add6 = add nsw i64 %5, %add5
  store i64 %add6, i64* %allength, align 8
  %6 = load i64, i64* %allength, align 8
  %7 = load i64, i64* %sa_avail, align 8
  %cmp = icmp sle i64 %6, %7
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %8 = load i64, i64* %allength, align 8
  %9 = load i64, i64* %sa_avail, align 8
  %sub = sub nsw i64 %9, %8
  store i64 %sub, i64* %sa_avail, align 8
  %10 = load i64, i64* %allength, align 8
  %11 = alloca i8, i64 %10
  br label %cond.end

cond.false:                                       ; preds = %entry
  store i8 1, i8* %sa_must_free, align 1
  %12 = load i64, i64* %allength, align 8
  %call7 = call i8* @record_xmalloc(i64 %12)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %11, %cond.true ], [ %call7, %cond.false ]
  store i8* %cond, i8** %encoded, align 8
  %13 = load i64, i64* %string.addr, align 8
  %call8 = call i8* @SSDATA(i64 %13)
  %14 = load i8*, i8** %encoded, align 8
  %15 = load i64, i64* %length, align 8
  %16 = load i64, i64* %no_line_break.addr, align 8
  %call9 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp10 = icmp eq i64 %16, %call9
  %17 = load i64, i64* %string.addr, align 8
  %call11 = call zeroext i1 @STRING_MULTIBYTE(i64 %17)
  %call12 = call i64 @base64_encode_1(i8* %call8, i8* %14, i64 %15, i1 zeroext %cmp10, i1 zeroext %call11)
  store i64 %call12, i64* %encoded_length, align 8
  %18 = load i64, i64* %encoded_length, align 8
  %19 = load i64, i64* %allength, align 8
  %cmp13 = icmp sgt i64 %18, %19
  br i1 %cmp13, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  call void @emacs_abort() #8
  unreachable

if.end:                                           ; preds = %cond.end
  %20 = load i64, i64* %encoded_length, align 8
  %cmp14 = icmp slt i64 %20, 0
  br i1 %cmp14, label %if.then.15, label %if.end.16

if.then.15:                                       ; preds = %if.end
  call void (i8*, ...) @error(i8* getelementptr inbounds ([48 x i8], [48 x i8]* @.str.14, i32 0, i32 0)) #8
  unreachable

if.end.16:                                        ; preds = %if.end
  %21 = load i8*, i8** %encoded, align 8
  %22 = load i64, i64* %encoded_length, align 8
  %call17 = call i64 @make_unibyte_string(i8* %21, i64 %22)
  store i64 %call17, i64* %encoded_string, align 8
  br label %do.body

do.body:                                          ; preds = %if.end.16
  %23 = load i8, i8* %sa_must_free, align 1
  %tobool = trunc i8 %23 to i1
  br i1 %tobool, label %if.then.18, label %if.end.21

if.then.18:                                       ; preds = %do.body
  store i8 0, i8* %sa_must_free, align 1
  %24 = load i64, i64* %sa_count, align 8
  %call19 = call i64 @builtin_lisp_symbol(i32 0)
  %call20 = call i64 @unbind_to(i64 %24, i64 %call19)
  br label %if.end.21

if.end.21:                                        ; preds = %if.then.18, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end.21
  %25 = load i64, i64* %encoded_string, align 8
  ret i64 %25
}

; Function Attrs: nounwind uwtable
define i64 @Fbase64_decode_region(i64 %beg, i64 %end) #1 {
entry:
  %beg.addr = alloca i64, align 8
  %end.addr = alloca i64, align 8
  %ibeg = alloca i64, align 8
  %iend = alloca i64, align 8
  %length = alloca i64, align 8
  %allength = alloca i64, align 8
  %decoded = alloca i8*, align 8
  %old_pos = alloca i64, align 8
  %decoded_length = alloca i64, align 8
  %inserted_chars = alloca i64, align 8
  %multibyte = alloca i8, align 1
  %sa_avail = alloca i64, align 8
  %sa_count = alloca i64, align 8
  %sa_must_free = alloca i8, align 1
  store i64 %beg, i64* %beg.addr, align 8
  store i64 %end, i64* %end.addr, align 8
  %0 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt = getelementptr inbounds %struct.buffer, %struct.buffer* %0, i32 0, i32 75
  %1 = load i64, i64* %pt, align 8
  %add = add nsw i64 %1, 0
  store i64 %add, i64* %old_pos, align 8
  %2 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %enable_multibyte_characters_ = getelementptr inbounds %struct.buffer, %struct.buffer* %2, i32 0, i32 39
  %3 = load i64, i64* %enable_multibyte_characters_, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %3, %call
  %lnot = xor i1 %cmp, true
  %frombool = zext i1 %lnot to i8
  store i8 %frombool, i8* %multibyte, align 1
  store i64 16384, i64* %sa_avail, align 8
  %call1 = call i64 @SPECPDL_INDEX()
  store i64 %call1, i64* %sa_count, align 8
  store i8 0, i8* %sa_must_free, align 1
  call void @validate_region(i64* %beg.addr, i64* %end.addr)
  %4 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %5 = load i64, i64* %beg.addr, align 8
  %shr = ashr i64 %5, 2
  %call2 = call i64 @buf_charpos_to_bytepos(%struct.buffer* %4, i64 %shr)
  store i64 %call2, i64* %ibeg, align 8
  %6 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %7 = load i64, i64* %end.addr, align 8
  %shr3 = ashr i64 %7, 2
  %call4 = call i64 @buf_charpos_to_bytepos(%struct.buffer* %6, i64 %shr3)
  store i64 %call4, i64* %iend, align 8
  %8 = load i64, i64* %iend, align 8
  %9 = load i64, i64* %ibeg, align 8
  %sub = sub nsw i64 %8, %9
  store i64 %sub, i64* %length, align 8
  %10 = load i8, i8* %multibyte, align 1
  %tobool = trunc i8 %10 to i1
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %11 = load i64, i64* %length, align 8
  %mul = mul nsw i64 %11, 2
  br label %cond.end

cond.false:                                       ; preds = %entry
  %12 = load i64, i64* %length, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %mul, %cond.true ], [ %12, %cond.false ]
  store i64 %cond, i64* %allength, align 8
  %13 = load i64, i64* %allength, align 8
  %14 = load i64, i64* %sa_avail, align 8
  %cmp5 = icmp sle i64 %13, %14
  br i1 %cmp5, label %cond.true.6, label %cond.false.8

cond.true.6:                                      ; preds = %cond.end
  %15 = load i64, i64* %allength, align 8
  %16 = load i64, i64* %sa_avail, align 8
  %sub7 = sub nsw i64 %16, %15
  store i64 %sub7, i64* %sa_avail, align 8
  %17 = load i64, i64* %allength, align 8
  %18 = alloca i8, i64 %17
  br label %cond.end.10

cond.false.8:                                     ; preds = %cond.end
  store i8 1, i8* %sa_must_free, align 1
  %19 = load i64, i64* %allength, align 8
  %call9 = call i8* @record_xmalloc(i64 %19)
  br label %cond.end.10

cond.end.10:                                      ; preds = %cond.false.8, %cond.true.6
  %cond11 = phi i8* [ %18, %cond.true.6 ], [ %call9, %cond.false.8 ]
  store i8* %cond11, i8** %decoded, align 8
  %20 = load i64, i64* %beg.addr, align 8
  %shr12 = ashr i64 %20, 2
  %21 = load i64, i64* %ibeg, align 8
  call void @move_gap_both(i64 %shr12, i64 %21)
  %22 = load i64, i64* %ibeg, align 8
  %23 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text = getelementptr inbounds %struct.buffer, %struct.buffer* %23, i32 0, i32 73
  %24 = load %struct.buffer_text*, %struct.buffer_text** %text, align 8
  %gpt_byte = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %24, i32 0, i32 3
  %25 = load i64, i64* %gpt_byte, align 8
  %cmp13 = icmp sge i64 %22, %25
  br i1 %cmp13, label %cond.true.14, label %cond.false.16

cond.true.14:                                     ; preds = %cond.end.10
  %26 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text15 = getelementptr inbounds %struct.buffer, %struct.buffer* %26, i32 0, i32 73
  %27 = load %struct.buffer_text*, %struct.buffer_text** %text15, align 8
  %gap_size = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %27, i32 0, i32 5
  %28 = load i64, i64* %gap_size, align 8
  br label %cond.end.17

cond.false.16:                                    ; preds = %cond.end.10
  br label %cond.end.17

cond.end.17:                                      ; preds = %cond.false.16, %cond.true.14
  %cond18 = phi i64 [ %28, %cond.true.14 ], [ 0, %cond.false.16 ]
  %29 = load i64, i64* %ibeg, align 8
  %add19 = add nsw i64 %cond18, %29
  %30 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %text20 = getelementptr inbounds %struct.buffer, %struct.buffer* %30, i32 0, i32 73
  %31 = load %struct.buffer_text*, %struct.buffer_text** %text20, align 8
  %beg21 = getelementptr inbounds %struct.buffer_text, %struct.buffer_text* %31, i32 0, i32 0
  %32 = load i8*, i8** %beg21, align 8
  %add.ptr = getelementptr inbounds i8, i8* %32, i64 %add19
  %add.ptr22 = getelementptr inbounds i8, i8* %add.ptr, i64 -1
  %33 = load i8*, i8** %decoded, align 8
  %34 = load i64, i64* %length, align 8
  %35 = load i8, i8* %multibyte, align 1
  %tobool23 = trunc i8 %35 to i1
  %call24 = call i64 @base64_decode_1(i8* %add.ptr22, i8* %33, i64 %34, i1 zeroext %tobool23, i64* %inserted_chars)
  store i64 %call24, i64* %decoded_length, align 8
  %36 = load i64, i64* %decoded_length, align 8
  %37 = load i64, i64* %allength, align 8
  %cmp25 = icmp sgt i64 %36, %37
  br i1 %cmp25, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end.17
  call void @emacs_abort() #8
  unreachable

if.end:                                           ; preds = %cond.end.17
  %38 = load i64, i64* %decoded_length, align 8
  %cmp26 = icmp slt i64 %38, 0
  br i1 %cmp26, label %if.then.27, label %if.end.28

if.then.27:                                       ; preds = %if.end
  call void (i8*, ...) @error(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.15, i32 0, i32 0)) #8
  unreachable

if.end.28:                                        ; preds = %if.end
  %39 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %40 = load i64, i64* %beg.addr, align 8
  %shr29 = ashr i64 %40, 2
  %41 = load i64, i64* %ibeg, align 8
  call void @temp_set_point_both(%struct.buffer* %39, i64 %shr29, i64 %41)
  %42 = load i8*, i8** %decoded, align 8
  %43 = load i64, i64* %inserted_chars, align 8
  %44 = load i64, i64* %decoded_length, align 8
  call void @insert_1_both(i8* %42, i64 %43, i64 %44, i1 zeroext false, i1 zeroext true, i1 zeroext false)
  br label %do.body

do.body:                                          ; preds = %if.end.28
  %45 = load i8, i8* %sa_must_free, align 1
  %tobool30 = trunc i8 %45 to i1
  br i1 %tobool30, label %if.then.31, label %if.end.34

if.then.31:                                       ; preds = %do.body
  store i8 0, i8* %sa_must_free, align 1
  %46 = load i64, i64* %sa_count, align 8
  %call32 = call i64 @builtin_lisp_symbol(i32 0)
  %call33 = call i64 @unbind_to(i64 %46, i64 %call32)
  br label %if.end.34

if.end.34:                                        ; preds = %if.then.31, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end.34
  %47 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt35 = getelementptr inbounds %struct.buffer, %struct.buffer* %47, i32 0, i32 75
  %48 = load i64, i64* %pt35, align 8
  %add36 = add nsw i64 %48, 0
  %49 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %pt_byte = getelementptr inbounds %struct.buffer, %struct.buffer* %49, i32 0, i32 76
  %50 = load i64, i64* %pt_byte, align 8
  %add37 = add nsw i64 %50, 0
  %51 = load i64, i64* %end.addr, align 8
  %shr38 = ashr i64 %51, 2
  %52 = load i64, i64* %inserted_chars, align 8
  %add39 = add nsw i64 %shr38, %52
  %53 = load i64, i64* %iend, align 8
  %54 = load i64, i64* %decoded_length, align 8
  %add40 = add nsw i64 %53, %54
  call void @del_range_both(i64 %add36, i64 %add37, i64 %add39, i64 %add40, i1 zeroext true)
  %55 = load i64, i64* %old_pos, align 8
  %56 = load i64, i64* %end.addr, align 8
  %shr41 = ashr i64 %56, 2
  %cmp42 = icmp sge i64 %55, %shr41
  br i1 %cmp42, label %if.then.43, label %if.else

if.then.43:                                       ; preds = %do.end
  %57 = load i64, i64* %inserted_chars, align 8
  %58 = load i64, i64* %end.addr, align 8
  %shr44 = ashr i64 %58, 2
  %59 = load i64, i64* %beg.addr, align 8
  %shr45 = ashr i64 %59, 2
  %sub46 = sub nsw i64 %shr44, %shr45
  %sub47 = sub nsw i64 %57, %sub46
  %60 = load i64, i64* %old_pos, align 8
  %add48 = add nsw i64 %60, %sub47
  store i64 %add48, i64* %old_pos, align 8
  br label %if.end.54

if.else:                                          ; preds = %do.end
  %61 = load i64, i64* %old_pos, align 8
  %62 = load i64, i64* %beg.addr, align 8
  %shr49 = ashr i64 %62, 2
  %cmp50 = icmp sgt i64 %61, %shr49
  br i1 %cmp50, label %if.then.51, label %if.end.53

if.then.51:                                       ; preds = %if.else
  %63 = load i64, i64* %beg.addr, align 8
  %shr52 = ashr i64 %63, 2
  store i64 %shr52, i64* %old_pos, align 8
  br label %if.end.53

if.end.53:                                        ; preds = %if.then.51, %if.else
  br label %if.end.54

if.end.54:                                        ; preds = %if.end.53, %if.then.43
  %64 = load i64, i64* %old_pos, align 8
  %65 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv = getelementptr inbounds %struct.buffer, %struct.buffer* %65, i32 0, i32 79
  %66 = load i64, i64* %zv, align 8
  %cmp55 = icmp sgt i64 %64, %66
  br i1 %cmp55, label %cond.true.56, label %cond.false.58

cond.true.56:                                     ; preds = %if.end.54
  %67 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv57 = getelementptr inbounds %struct.buffer, %struct.buffer* %67, i32 0, i32 79
  %68 = load i64, i64* %zv57, align 8
  br label %cond.end.59

cond.false.58:                                    ; preds = %if.end.54
  %69 = load i64, i64* %old_pos, align 8
  br label %cond.end.59

cond.end.59:                                      ; preds = %cond.false.58, %cond.true.56
  %cond60 = phi i64 [ %68, %cond.true.56 ], [ %69, %cond.false.58 ]
  call void @set_point(i64 %cond60)
  %70 = load i64, i64* %inserted_chars, align 8
  %shl = shl i64 %70, 2
  %add61 = add i64 %shl, 2
  ret i64 %add61
}

; Function Attrs: nounwind uwtable
define internal i64 @base64_decode_1(i8* %from, i8* %to, i64 %length, i1 zeroext %multibyte, i64* %nchars_return) #1 {
entry:
  %retval = alloca i64, align 8
  %from.addr = alloca i8*, align 8
  %to.addr = alloca i8*, align 8
  %length.addr = alloca i64, align 8
  %multibyte.addr = alloca i8, align 1
  %nchars_return.addr = alloca i64*, align 8
  %i = alloca i64, align 8
  %e = alloca i8*, align 8
  %c = alloca i8, align 1
  %value = alloca i64, align 8
  %nchars = alloca i64, align 8
  store i8* %from, i8** %from.addr, align 8
  store i8* %to, i8** %to.addr, align 8
  store i64 %length, i64* %length.addr, align 8
  %frombool = zext i1 %multibyte to i8
  store i8 %frombool, i8* %multibyte.addr, align 1
  store i64* %nchars_return, i64** %nchars_return.addr, align 8
  store i64 0, i64* %i, align 8
  %0 = load i8*, i8** %to.addr, align 8
  store i8* %0, i8** %e, align 8
  store i64 0, i64* %nchars, align 8
  br label %while.body

while.body:                                       ; preds = %entry, %if.end.172, %if.then.252, %if.end.292
  br label %do.body

do.body:                                          ; preds = %lor.end, %while.body
  %1 = load i64, i64* %i, align 8
  %2 = load i64, i64* %length.addr, align 8
  %cmp = icmp eq i64 %1, %2
  br i1 %cmp, label %if.then, label %if.end.2

if.then:                                          ; preds = %do.body
  %3 = load i64*, i64** %nchars_return.addr, align 8
  %tobool = icmp ne i64* %3, null
  br i1 %tobool, label %if.then.1, label %if.end

if.then.1:                                        ; preds = %if.then
  %4 = load i64, i64* %nchars, align 8
  %5 = load i64*, i64** %nchars_return.addr, align 8
  store i64 %4, i64* %5, align 8
  br label %if.end

if.end:                                           ; preds = %if.then.1, %if.then
  %6 = load i8*, i8** %e, align 8
  %7 = load i8*, i8** %to.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %6 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %7 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  store i64 %sub.ptr.sub, i64* %retval
  br label %return

if.end.2:                                         ; preds = %do.body
  %8 = load i64, i64* %i, align 8
  %inc = add nsw i64 %8, 1
  store i64 %inc, i64* %i, align 8
  %9 = load i8*, i8** %from.addr, align 8
  %arrayidx = getelementptr inbounds i8, i8* %9, i64 %8
  %10 = load i8, i8* %arrayidx, align 1
  store i8 %10, i8* %c, align 1
  br label %do.cond

do.cond:                                          ; preds = %if.end.2
  %11 = load i8, i8* %c, align 1
  %conv = zext i8 %11 to i32
  %cmp3 = icmp eq i32 %conv, 32
  br i1 %cmp3, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.cond
  %12 = load i8, i8* %c, align 1
  %conv5 = zext i8 %12 to i32
  %cmp6 = icmp eq i32 %conv5, 9
  br i1 %cmp6, label %lor.end, label %lor.lhs.false.8

lor.lhs.false.8:                                  ; preds = %lor.lhs.false
  %13 = load i8, i8* %c, align 1
  %conv9 = zext i8 %13 to i32
  %cmp10 = icmp eq i32 %conv9, 10
  br i1 %cmp10, label %lor.end, label %lor.lhs.false.12

lor.lhs.false.12:                                 ; preds = %lor.lhs.false.8
  %14 = load i8, i8* %c, align 1
  %conv13 = zext i8 %14 to i32
  %cmp14 = icmp eq i32 %conv13, 12
  br i1 %cmp14, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false.12
  %15 = load i8, i8* %c, align 1
  %conv16 = zext i8 %15 to i32
  %cmp17 = icmp eq i32 %conv16, 13
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false.12, %lor.lhs.false.8, %lor.lhs.false, %do.cond
  %16 = phi i1 [ true, %lor.lhs.false.12 ], [ true, %lor.lhs.false.8 ], [ true, %lor.lhs.false ], [ true, %do.cond ], [ %cmp17, %lor.rhs ]
  br i1 %16, label %do.body, label %do.end

do.end:                                           ; preds = %lor.end
  %17 = load i8, i8* %c, align 1
  %conv19 = zext i8 %17 to i32
  %cmp20 = icmp slt i32 %conv19, 128
  br i1 %cmp20, label %land.lhs.true, label %if.then.26

land.lhs.true:                                    ; preds = %do.end
  %18 = load i8, i8* %c, align 1
  %idxprom = zext i8 %18 to i64
  %arrayidx22 = getelementptr inbounds [128 x i16], [128 x i16]* @base64_char_to_value, i32 0, i64 %idxprom
  %19 = load i16, i16* %arrayidx22, align 2
  %conv23 = sext i16 %19 to i32
  %cmp24 = icmp sge i32 %conv23, 0
  br i1 %cmp24, label %if.end.27, label %if.then.26

if.then.26:                                       ; preds = %land.lhs.true, %do.end
  store i64 -1, i64* %retval
  br label %return

if.end.27:                                        ; preds = %land.lhs.true
  %20 = load i8, i8* %c, align 1
  %idxprom28 = zext i8 %20 to i64
  %arrayidx29 = getelementptr inbounds [128 x i16], [128 x i16]* @base64_char_to_value, i32 0, i64 %idxprom28
  %21 = load i16, i16* %arrayidx29, align 2
  %conv30 = sext i16 %21 to i32
  %shl = shl i32 %conv30, 18
  %conv31 = sext i32 %shl to i64
  store i64 %conv31, i64* %value, align 8
  br label %do.body.32

do.body.32:                                       ; preds = %lor.end.62, %if.end.27
  %22 = load i64, i64* %i, align 8
  %23 = load i64, i64* %length.addr, align 8
  %cmp33 = icmp eq i64 %22, %23
  br i1 %cmp33, label %if.then.35, label %if.end.39

if.then.35:                                       ; preds = %do.body.32
  %24 = load i64*, i64** %nchars_return.addr, align 8
  %tobool36 = icmp ne i64* %24, null
  br i1 %tobool36, label %if.then.37, label %if.end.38

if.then.37:                                       ; preds = %if.then.35
  %25 = load i64, i64* %nchars, align 8
  %26 = load i64*, i64** %nchars_return.addr, align 8
  store i64 %25, i64* %26, align 8
  br label %if.end.38

if.end.38:                                        ; preds = %if.then.37, %if.then.35
  store i64 -1, i64* %retval
  br label %return

if.end.39:                                        ; preds = %do.body.32
  %27 = load i64, i64* %i, align 8
  %inc40 = add nsw i64 %27, 1
  store i64 %inc40, i64* %i, align 8
  %28 = load i8*, i8** %from.addr, align 8
  %arrayidx41 = getelementptr inbounds i8, i8* %28, i64 %27
  %29 = load i8, i8* %arrayidx41, align 1
  store i8 %29, i8* %c, align 1
  br label %do.cond.42

do.cond.42:                                       ; preds = %if.end.39
  %30 = load i8, i8* %c, align 1
  %conv43 = zext i8 %30 to i32
  %cmp44 = icmp eq i32 %conv43, 32
  br i1 %cmp44, label %lor.end.62, label %lor.lhs.false.46

lor.lhs.false.46:                                 ; preds = %do.cond.42
  %31 = load i8, i8* %c, align 1
  %conv47 = zext i8 %31 to i32
  %cmp48 = icmp eq i32 %conv47, 9
  br i1 %cmp48, label %lor.end.62, label %lor.lhs.false.50

lor.lhs.false.50:                                 ; preds = %lor.lhs.false.46
  %32 = load i8, i8* %c, align 1
  %conv51 = zext i8 %32 to i32
  %cmp52 = icmp eq i32 %conv51, 10
  br i1 %cmp52, label %lor.end.62, label %lor.lhs.false.54

lor.lhs.false.54:                                 ; preds = %lor.lhs.false.50
  %33 = load i8, i8* %c, align 1
  %conv55 = zext i8 %33 to i32
  %cmp56 = icmp eq i32 %conv55, 12
  br i1 %cmp56, label %lor.end.62, label %lor.rhs.58

lor.rhs.58:                                       ; preds = %lor.lhs.false.54
  %34 = load i8, i8* %c, align 1
  %conv59 = zext i8 %34 to i32
  %cmp60 = icmp eq i32 %conv59, 13
  br label %lor.end.62

lor.end.62:                                       ; preds = %lor.rhs.58, %lor.lhs.false.54, %lor.lhs.false.50, %lor.lhs.false.46, %do.cond.42
  %35 = phi i1 [ true, %lor.lhs.false.54 ], [ true, %lor.lhs.false.50 ], [ true, %lor.lhs.false.46 ], [ true, %do.cond.42 ], [ %cmp60, %lor.rhs.58 ]
  br i1 %35, label %do.body.32, label %do.end.63

do.end.63:                                        ; preds = %lor.end.62
  %36 = load i8, i8* %c, align 1
  %conv64 = zext i8 %36 to i32
  %cmp65 = icmp slt i32 %conv64, 128
  br i1 %cmp65, label %land.lhs.true.67, label %if.then.73

land.lhs.true.67:                                 ; preds = %do.end.63
  %37 = load i8, i8* %c, align 1
  %idxprom68 = zext i8 %37 to i64
  %arrayidx69 = getelementptr inbounds [128 x i16], [128 x i16]* @base64_char_to_value, i32 0, i64 %idxprom68
  %38 = load i16, i16* %arrayidx69, align 2
  %conv70 = sext i16 %38 to i32
  %cmp71 = icmp sge i32 %conv70, 0
  br i1 %cmp71, label %if.end.74, label %if.then.73

if.then.73:                                       ; preds = %land.lhs.true.67, %do.end.63
  store i64 -1, i64* %retval
  br label %return

if.end.74:                                        ; preds = %land.lhs.true.67
  %39 = load i8, i8* %c, align 1
  %idxprom75 = zext i8 %39 to i64
  %arrayidx76 = getelementptr inbounds [128 x i16], [128 x i16]* @base64_char_to_value, i32 0, i64 %idxprom75
  %40 = load i16, i16* %arrayidx76, align 2
  %conv77 = sext i16 %40 to i32
  %shl78 = shl i32 %conv77, 12
  %conv79 = sext i32 %shl78 to i64
  %41 = load i64, i64* %value, align 8
  %or = or i64 %41, %conv79
  store i64 %or, i64* %value, align 8
  %42 = load i64, i64* %value, align 8
  %shr = lshr i64 %42, 16
  %conv80 = trunc i64 %shr to i8
  store i8 %conv80, i8* %c, align 1
  %43 = load i8, i8* %multibyte.addr, align 1
  %tobool81 = trunc i8 %43 to i1
  br i1 %tobool81, label %land.lhs.true.83, label %if.else

land.lhs.true.83:                                 ; preds = %if.end.74
  %44 = load i8, i8* %c, align 1
  %conv84 = zext i8 %44 to i32
  %cmp85 = icmp sge i32 %conv84, 128
  br i1 %cmp85, label %if.then.87, label %if.else

if.then.87:                                       ; preds = %land.lhs.true.83
  %45 = load i8, i8* %c, align 1
  %conv88 = zext i8 %45 to i32
  %shr89 = ashr i32 %conv88, 6
  %and = and i32 %shr89, 1
  %or90 = or i32 192, %and
  %conv91 = trunc i32 %or90 to i8
  %46 = load i8*, i8** %e, align 8
  %arrayidx92 = getelementptr inbounds i8, i8* %46, i64 0
  store i8 %conv91, i8* %arrayidx92, align 1
  %47 = load i8, i8* %c, align 1
  %conv93 = zext i8 %47 to i32
  %and94 = and i32 %conv93, 63
  %or95 = or i32 128, %and94
  %conv96 = trunc i32 %or95 to i8
  %48 = load i8*, i8** %e, align 8
  %arrayidx97 = getelementptr inbounds i8, i8* %48, i64 1
  store i8 %conv96, i8* %arrayidx97, align 1
  %49 = load i8*, i8** %e, align 8
  %add.ptr = getelementptr inbounds i8, i8* %49, i64 2
  store i8* %add.ptr, i8** %e, align 8
  br label %if.end.98

if.else:                                          ; preds = %land.lhs.true.83, %if.end.74
  %50 = load i8, i8* %c, align 1
  %51 = load i8*, i8** %e, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %51, i32 1
  store i8* %incdec.ptr, i8** %e, align 8
  store i8 %50, i8* %51, align 1
  br label %if.end.98

if.end.98:                                        ; preds = %if.else, %if.then.87
  %52 = load i64, i64* %nchars, align 8
  %inc99 = add nsw i64 %52, 1
  store i64 %inc99, i64* %nchars, align 8
  br label %do.body.100

do.body.100:                                      ; preds = %lor.end.130, %if.end.98
  %53 = load i64, i64* %i, align 8
  %54 = load i64, i64* %length.addr, align 8
  %cmp101 = icmp eq i64 %53, %54
  br i1 %cmp101, label %if.then.103, label %if.end.107

if.then.103:                                      ; preds = %do.body.100
  %55 = load i64*, i64** %nchars_return.addr, align 8
  %tobool104 = icmp ne i64* %55, null
  br i1 %tobool104, label %if.then.105, label %if.end.106

if.then.105:                                      ; preds = %if.then.103
  %56 = load i64, i64* %nchars, align 8
  %57 = load i64*, i64** %nchars_return.addr, align 8
  store i64 %56, i64* %57, align 8
  br label %if.end.106

if.end.106:                                       ; preds = %if.then.105, %if.then.103
  store i64 -1, i64* %retval
  br label %return

if.end.107:                                       ; preds = %do.body.100
  %58 = load i64, i64* %i, align 8
  %inc108 = add nsw i64 %58, 1
  store i64 %inc108, i64* %i, align 8
  %59 = load i8*, i8** %from.addr, align 8
  %arrayidx109 = getelementptr inbounds i8, i8* %59, i64 %58
  %60 = load i8, i8* %arrayidx109, align 1
  store i8 %60, i8* %c, align 1
  br label %do.cond.110

do.cond.110:                                      ; preds = %if.end.107
  %61 = load i8, i8* %c, align 1
  %conv111 = zext i8 %61 to i32
  %cmp112 = icmp eq i32 %conv111, 32
  br i1 %cmp112, label %lor.end.130, label %lor.lhs.false.114

lor.lhs.false.114:                                ; preds = %do.cond.110
  %62 = load i8, i8* %c, align 1
  %conv115 = zext i8 %62 to i32
  %cmp116 = icmp eq i32 %conv115, 9
  br i1 %cmp116, label %lor.end.130, label %lor.lhs.false.118

lor.lhs.false.118:                                ; preds = %lor.lhs.false.114
  %63 = load i8, i8* %c, align 1
  %conv119 = zext i8 %63 to i32
  %cmp120 = icmp eq i32 %conv119, 10
  br i1 %cmp120, label %lor.end.130, label %lor.lhs.false.122

lor.lhs.false.122:                                ; preds = %lor.lhs.false.118
  %64 = load i8, i8* %c, align 1
  %conv123 = zext i8 %64 to i32
  %cmp124 = icmp eq i32 %conv123, 12
  br i1 %cmp124, label %lor.end.130, label %lor.rhs.126

lor.rhs.126:                                      ; preds = %lor.lhs.false.122
  %65 = load i8, i8* %c, align 1
  %conv127 = zext i8 %65 to i32
  %cmp128 = icmp eq i32 %conv127, 13
  br label %lor.end.130

lor.end.130:                                      ; preds = %lor.rhs.126, %lor.lhs.false.122, %lor.lhs.false.118, %lor.lhs.false.114, %do.cond.110
  %66 = phi i1 [ true, %lor.lhs.false.122 ], [ true, %lor.lhs.false.118 ], [ true, %lor.lhs.false.114 ], [ true, %do.cond.110 ], [ %cmp128, %lor.rhs.126 ]
  br i1 %66, label %do.body.100, label %do.end.131

do.end.131:                                       ; preds = %lor.end.130
  %67 = load i8, i8* %c, align 1
  %conv132 = zext i8 %67 to i32
  %cmp133 = icmp eq i32 %conv132, 61
  br i1 %cmp133, label %if.then.135, label %if.end.173

if.then.135:                                      ; preds = %do.end.131
  br label %do.body.136

do.body.136:                                      ; preds = %lor.end.166, %if.then.135
  %68 = load i64, i64* %i, align 8
  %69 = load i64, i64* %length.addr, align 8
  %cmp137 = icmp eq i64 %68, %69
  br i1 %cmp137, label %if.then.139, label %if.end.143

if.then.139:                                      ; preds = %do.body.136
  %70 = load i64*, i64** %nchars_return.addr, align 8
  %tobool140 = icmp ne i64* %70, null
  br i1 %tobool140, label %if.then.141, label %if.end.142

if.then.141:                                      ; preds = %if.then.139
  %71 = load i64, i64* %nchars, align 8
  %72 = load i64*, i64** %nchars_return.addr, align 8
  store i64 %71, i64* %72, align 8
  br label %if.end.142

if.end.142:                                       ; preds = %if.then.141, %if.then.139
  store i64 -1, i64* %retval
  br label %return

if.end.143:                                       ; preds = %do.body.136
  %73 = load i64, i64* %i, align 8
  %inc144 = add nsw i64 %73, 1
  store i64 %inc144, i64* %i, align 8
  %74 = load i8*, i8** %from.addr, align 8
  %arrayidx145 = getelementptr inbounds i8, i8* %74, i64 %73
  %75 = load i8, i8* %arrayidx145, align 1
  store i8 %75, i8* %c, align 1
  br label %do.cond.146

do.cond.146:                                      ; preds = %if.end.143
  %76 = load i8, i8* %c, align 1
  %conv147 = zext i8 %76 to i32
  %cmp148 = icmp eq i32 %conv147, 32
  br i1 %cmp148, label %lor.end.166, label %lor.lhs.false.150

lor.lhs.false.150:                                ; preds = %do.cond.146
  %77 = load i8, i8* %c, align 1
  %conv151 = zext i8 %77 to i32
  %cmp152 = icmp eq i32 %conv151, 9
  br i1 %cmp152, label %lor.end.166, label %lor.lhs.false.154

lor.lhs.false.154:                                ; preds = %lor.lhs.false.150
  %78 = load i8, i8* %c, align 1
  %conv155 = zext i8 %78 to i32
  %cmp156 = icmp eq i32 %conv155, 10
  br i1 %cmp156, label %lor.end.166, label %lor.lhs.false.158

lor.lhs.false.158:                                ; preds = %lor.lhs.false.154
  %79 = load i8, i8* %c, align 1
  %conv159 = zext i8 %79 to i32
  %cmp160 = icmp eq i32 %conv159, 12
  br i1 %cmp160, label %lor.end.166, label %lor.rhs.162

lor.rhs.162:                                      ; preds = %lor.lhs.false.158
  %80 = load i8, i8* %c, align 1
  %conv163 = zext i8 %80 to i32
  %cmp164 = icmp eq i32 %conv163, 13
  br label %lor.end.166

lor.end.166:                                      ; preds = %lor.rhs.162, %lor.lhs.false.158, %lor.lhs.false.154, %lor.lhs.false.150, %do.cond.146
  %81 = phi i1 [ true, %lor.lhs.false.158 ], [ true, %lor.lhs.false.154 ], [ true, %lor.lhs.false.150 ], [ true, %do.cond.146 ], [ %cmp164, %lor.rhs.162 ]
  br i1 %81, label %do.body.136, label %do.end.167

do.end.167:                                       ; preds = %lor.end.166
  %82 = load i8, i8* %c, align 1
  %conv168 = zext i8 %82 to i32
  %cmp169 = icmp ne i32 %conv168, 61
  br i1 %cmp169, label %if.then.171, label %if.end.172

if.then.171:                                      ; preds = %do.end.167
  store i64 -1, i64* %retval
  br label %return

if.end.172:                                       ; preds = %do.end.167
  br label %while.body

if.end.173:                                       ; preds = %do.end.131
  %83 = load i8, i8* %c, align 1
  %conv174 = zext i8 %83 to i32
  %cmp175 = icmp slt i32 %conv174, 128
  br i1 %cmp175, label %land.lhs.true.177, label %if.then.183

land.lhs.true.177:                                ; preds = %if.end.173
  %84 = load i8, i8* %c, align 1
  %idxprom178 = zext i8 %84 to i64
  %arrayidx179 = getelementptr inbounds [128 x i16], [128 x i16]* @base64_char_to_value, i32 0, i64 %idxprom178
  %85 = load i16, i16* %arrayidx179, align 2
  %conv180 = sext i16 %85 to i32
  %cmp181 = icmp sge i32 %conv180, 0
  br i1 %cmp181, label %if.end.184, label %if.then.183

if.then.183:                                      ; preds = %land.lhs.true.177, %if.end.173
  store i64 -1, i64* %retval
  br label %return

if.end.184:                                       ; preds = %land.lhs.true.177
  %86 = load i8, i8* %c, align 1
  %idxprom185 = zext i8 %86 to i64
  %arrayidx186 = getelementptr inbounds [128 x i16], [128 x i16]* @base64_char_to_value, i32 0, i64 %idxprom185
  %87 = load i16, i16* %arrayidx186, align 2
  %conv187 = sext i16 %87 to i32
  %shl188 = shl i32 %conv187, 6
  %conv189 = sext i32 %shl188 to i64
  %88 = load i64, i64* %value, align 8
  %or190 = or i64 %88, %conv189
  store i64 %or190, i64* %value, align 8
  %89 = load i64, i64* %value, align 8
  %shr191 = lshr i64 %89, 8
  %and192 = and i64 255, %shr191
  %conv193 = trunc i64 %and192 to i8
  store i8 %conv193, i8* %c, align 1
  %90 = load i8, i8* %multibyte.addr, align 1
  %tobool194 = trunc i8 %90 to i1
  br i1 %tobool194, label %land.lhs.true.196, label %if.else.213

land.lhs.true.196:                                ; preds = %if.end.184
  %91 = load i8, i8* %c, align 1
  %conv197 = zext i8 %91 to i32
  %cmp198 = icmp sge i32 %conv197, 128
  br i1 %cmp198, label %if.then.200, label %if.else.213

if.then.200:                                      ; preds = %land.lhs.true.196
  %92 = load i8, i8* %c, align 1
  %conv201 = zext i8 %92 to i32
  %shr202 = ashr i32 %conv201, 6
  %and203 = and i32 %shr202, 1
  %or204 = or i32 192, %and203
  %conv205 = trunc i32 %or204 to i8
  %93 = load i8*, i8** %e, align 8
  %arrayidx206 = getelementptr inbounds i8, i8* %93, i64 0
  store i8 %conv205, i8* %arrayidx206, align 1
  %94 = load i8, i8* %c, align 1
  %conv207 = zext i8 %94 to i32
  %and208 = and i32 %conv207, 63
  %or209 = or i32 128, %and208
  %conv210 = trunc i32 %or209 to i8
  %95 = load i8*, i8** %e, align 8
  %arrayidx211 = getelementptr inbounds i8, i8* %95, i64 1
  store i8 %conv210, i8* %arrayidx211, align 1
  %96 = load i8*, i8** %e, align 8
  %add.ptr212 = getelementptr inbounds i8, i8* %96, i64 2
  store i8* %add.ptr212, i8** %e, align 8
  br label %if.end.215

if.else.213:                                      ; preds = %land.lhs.true.196, %if.end.184
  %97 = load i8, i8* %c, align 1
  %98 = load i8*, i8** %e, align 8
  %incdec.ptr214 = getelementptr inbounds i8, i8* %98, i32 1
  store i8* %incdec.ptr214, i8** %e, align 8
  store i8 %97, i8* %98, align 1
  br label %if.end.215

if.end.215:                                       ; preds = %if.else.213, %if.then.200
  %99 = load i64, i64* %nchars, align 8
  %inc216 = add nsw i64 %99, 1
  store i64 %inc216, i64* %nchars, align 8
  br label %do.body.217

do.body.217:                                      ; preds = %lor.end.247, %if.end.215
  %100 = load i64, i64* %i, align 8
  %101 = load i64, i64* %length.addr, align 8
  %cmp218 = icmp eq i64 %100, %101
  br i1 %cmp218, label %if.then.220, label %if.end.224

if.then.220:                                      ; preds = %do.body.217
  %102 = load i64*, i64** %nchars_return.addr, align 8
  %tobool221 = icmp ne i64* %102, null
  br i1 %tobool221, label %if.then.222, label %if.end.223

if.then.222:                                      ; preds = %if.then.220
  %103 = load i64, i64* %nchars, align 8
  %104 = load i64*, i64** %nchars_return.addr, align 8
  store i64 %103, i64* %104, align 8
  br label %if.end.223

if.end.223:                                       ; preds = %if.then.222, %if.then.220
  store i64 -1, i64* %retval
  br label %return

if.end.224:                                       ; preds = %do.body.217
  %105 = load i64, i64* %i, align 8
  %inc225 = add nsw i64 %105, 1
  store i64 %inc225, i64* %i, align 8
  %106 = load i8*, i8** %from.addr, align 8
  %arrayidx226 = getelementptr inbounds i8, i8* %106, i64 %105
  %107 = load i8, i8* %arrayidx226, align 1
  store i8 %107, i8* %c, align 1
  br label %do.cond.227

do.cond.227:                                      ; preds = %if.end.224
  %108 = load i8, i8* %c, align 1
  %conv228 = zext i8 %108 to i32
  %cmp229 = icmp eq i32 %conv228, 32
  br i1 %cmp229, label %lor.end.247, label %lor.lhs.false.231

lor.lhs.false.231:                                ; preds = %do.cond.227
  %109 = load i8, i8* %c, align 1
  %conv232 = zext i8 %109 to i32
  %cmp233 = icmp eq i32 %conv232, 9
  br i1 %cmp233, label %lor.end.247, label %lor.lhs.false.235

lor.lhs.false.235:                                ; preds = %lor.lhs.false.231
  %110 = load i8, i8* %c, align 1
  %conv236 = zext i8 %110 to i32
  %cmp237 = icmp eq i32 %conv236, 10
  br i1 %cmp237, label %lor.end.247, label %lor.lhs.false.239

lor.lhs.false.239:                                ; preds = %lor.lhs.false.235
  %111 = load i8, i8* %c, align 1
  %conv240 = zext i8 %111 to i32
  %cmp241 = icmp eq i32 %conv240, 12
  br i1 %cmp241, label %lor.end.247, label %lor.rhs.243

lor.rhs.243:                                      ; preds = %lor.lhs.false.239
  %112 = load i8, i8* %c, align 1
  %conv244 = zext i8 %112 to i32
  %cmp245 = icmp eq i32 %conv244, 13
  br label %lor.end.247

lor.end.247:                                      ; preds = %lor.rhs.243, %lor.lhs.false.239, %lor.lhs.false.235, %lor.lhs.false.231, %do.cond.227
  %113 = phi i1 [ true, %lor.lhs.false.239 ], [ true, %lor.lhs.false.235 ], [ true, %lor.lhs.false.231 ], [ true, %do.cond.227 ], [ %cmp245, %lor.rhs.243 ]
  br i1 %113, label %do.body.217, label %do.end.248

do.end.248:                                       ; preds = %lor.end.247
  %114 = load i8, i8* %c, align 1
  %conv249 = zext i8 %114 to i32
  %cmp250 = icmp eq i32 %conv249, 61
  br i1 %cmp250, label %if.then.252, label %if.end.253

if.then.252:                                      ; preds = %do.end.248
  br label %while.body

if.end.253:                                       ; preds = %do.end.248
  %115 = load i8, i8* %c, align 1
  %conv254 = zext i8 %115 to i32
  %cmp255 = icmp slt i32 %conv254, 128
  br i1 %cmp255, label %land.lhs.true.257, label %if.then.263

land.lhs.true.257:                                ; preds = %if.end.253
  %116 = load i8, i8* %c, align 1
  %idxprom258 = zext i8 %116 to i64
  %arrayidx259 = getelementptr inbounds [128 x i16], [128 x i16]* @base64_char_to_value, i32 0, i64 %idxprom258
  %117 = load i16, i16* %arrayidx259, align 2
  %conv260 = sext i16 %117 to i32
  %cmp261 = icmp sge i32 %conv260, 0
  br i1 %cmp261, label %if.end.264, label %if.then.263

if.then.263:                                      ; preds = %land.lhs.true.257, %if.end.253
  store i64 -1, i64* %retval
  br label %return

if.end.264:                                       ; preds = %land.lhs.true.257
  %118 = load i8, i8* %c, align 1
  %idxprom265 = zext i8 %118 to i64
  %arrayidx266 = getelementptr inbounds [128 x i16], [128 x i16]* @base64_char_to_value, i32 0, i64 %idxprom265
  %119 = load i16, i16* %arrayidx266, align 2
  %conv267 = sext i16 %119 to i64
  %120 = load i64, i64* %value, align 8
  %or268 = or i64 %120, %conv267
  store i64 %or268, i64* %value, align 8
  %121 = load i64, i64* %value, align 8
  %and269 = and i64 255, %121
  %conv270 = trunc i64 %and269 to i8
  store i8 %conv270, i8* %c, align 1
  %122 = load i8, i8* %multibyte.addr, align 1
  %tobool271 = trunc i8 %122 to i1
  br i1 %tobool271, label %land.lhs.true.273, label %if.else.290

land.lhs.true.273:                                ; preds = %if.end.264
  %123 = load i8, i8* %c, align 1
  %conv274 = zext i8 %123 to i32
  %cmp275 = icmp sge i32 %conv274, 128
  br i1 %cmp275, label %if.then.277, label %if.else.290

if.then.277:                                      ; preds = %land.lhs.true.273
  %124 = load i8, i8* %c, align 1
  %conv278 = zext i8 %124 to i32
  %shr279 = ashr i32 %conv278, 6
  %and280 = and i32 %shr279, 1
  %or281 = or i32 192, %and280
  %conv282 = trunc i32 %or281 to i8
  %125 = load i8*, i8** %e, align 8
  %arrayidx283 = getelementptr inbounds i8, i8* %125, i64 0
  store i8 %conv282, i8* %arrayidx283, align 1
  %126 = load i8, i8* %c, align 1
  %conv284 = zext i8 %126 to i32
  %and285 = and i32 %conv284, 63
  %or286 = or i32 128, %and285
  %conv287 = trunc i32 %or286 to i8
  %127 = load i8*, i8** %e, align 8
  %arrayidx288 = getelementptr inbounds i8, i8* %127, i64 1
  store i8 %conv287, i8* %arrayidx288, align 1
  %128 = load i8*, i8** %e, align 8
  %add.ptr289 = getelementptr inbounds i8, i8* %128, i64 2
  store i8* %add.ptr289, i8** %e, align 8
  br label %if.end.292

if.else.290:                                      ; preds = %land.lhs.true.273, %if.end.264
  %129 = load i8, i8* %c, align 1
  %130 = load i8*, i8** %e, align 8
  %incdec.ptr291 = getelementptr inbounds i8, i8* %130, i32 1
  store i8* %incdec.ptr291, i8** %e, align 8
  store i8 %129, i8* %130, align 1
  br label %if.end.292

if.end.292:                                       ; preds = %if.else.290, %if.then.277
  %131 = load i64, i64* %nchars, align 8
  %inc293 = add nsw i64 %131, 1
  store i64 %inc293, i64* %nchars, align 8
  br label %while.body

return:                                           ; preds = %if.then.263, %if.end.223, %if.then.183, %if.then.171, %if.end.142, %if.end.106, %if.then.73, %if.end.38, %if.then.26, %if.end
  %132 = load i64, i64* %retval
  ret i64 %132
}

declare void @temp_set_point_both(%struct.buffer*, i64, i64) #2

declare void @insert_1_both(i8*, i64, i64, i1 zeroext, i1 zeroext, i1 zeroext) #2

declare void @del_range_both(i64, i64, i64, i64, i1 zeroext) #2

; Function Attrs: nounwind uwtable
define i64 @Fbase64_decode_string(i64 %string) #1 {
entry:
  %string.addr = alloca i64, align 8
  %decoded = alloca i8*, align 8
  %length = alloca i64, align 8
  %decoded_length = alloca i64, align 8
  %decoded_string = alloca i64, align 8
  %sa_avail = alloca i64, align 8
  %sa_count = alloca i64, align 8
  %sa_must_free = alloca i8, align 1
  store i64 %string, i64* %string.addr, align 8
  store i64 16384, i64* %sa_avail, align 8
  %call = call i64 @SPECPDL_INDEX()
  store i64 %call, i64* %sa_count, align 8
  store i8 0, i8* %sa_must_free, align 1
  %0 = load i64, i64* %string.addr, align 8
  call void @CHECK_STRING(i64 %0)
  %1 = load i64, i64* %string.addr, align 8
  %call1 = call i64 @SBYTES(i64 %1)
  store i64 %call1, i64* %length, align 8
  %2 = load i64, i64* %length, align 8
  %3 = load i64, i64* %sa_avail, align 8
  %cmp = icmp sle i64 %2, %3
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %4 = load i64, i64* %length, align 8
  %5 = load i64, i64* %sa_avail, align 8
  %sub = sub nsw i64 %5, %4
  store i64 %sub, i64* %sa_avail, align 8
  %6 = load i64, i64* %length, align 8
  %7 = alloca i8, i64 %6
  br label %cond.end

cond.false:                                       ; preds = %entry
  store i8 1, i8* %sa_must_free, align 1
  %8 = load i64, i64* %length, align 8
  %call2 = call i8* @record_xmalloc(i64 %8)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %7, %cond.true ], [ %call2, %cond.false ]
  store i8* %cond, i8** %decoded, align 8
  %9 = load i64, i64* %string.addr, align 8
  %call3 = call i8* @SSDATA(i64 %9)
  %10 = load i8*, i8** %decoded, align 8
  %11 = load i64, i64* %length, align 8
  %call4 = call i64 @base64_decode_1(i8* %call3, i8* %10, i64 %11, i1 zeroext false, i64* null)
  store i64 %call4, i64* %decoded_length, align 8
  %12 = load i64, i64* %decoded_length, align 8
  %13 = load i64, i64* %length, align 8
  %cmp5 = icmp sgt i64 %12, %13
  br i1 %cmp5, label %if.then, label %if.else

if.then:                                          ; preds = %cond.end
  call void @emacs_abort() #8
  unreachable

if.else:                                          ; preds = %cond.end
  %14 = load i64, i64* %decoded_length, align 8
  %cmp6 = icmp sge i64 %14, 0
  br i1 %cmp6, label %if.then.7, label %if.else.9

if.then.7:                                        ; preds = %if.else
  %15 = load i8*, i8** %decoded, align 8
  %16 = load i64, i64* %decoded_length, align 8
  %call8 = call i64 @make_unibyte_string(i8* %15, i64 %16)
  store i64 %call8, i64* %decoded_string, align 8
  br label %if.end

if.else.9:                                        ; preds = %if.else
  %call10 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call10, i64* %decoded_string, align 8
  br label %if.end

if.end:                                           ; preds = %if.else.9, %if.then.7
  br label %if.end.11

if.end.11:                                        ; preds = %if.end
  br label %do.body

do.body:                                          ; preds = %if.end.11
  %17 = load i8, i8* %sa_must_free, align 1
  %tobool = trunc i8 %17 to i1
  br i1 %tobool, label %if.then.12, label %if.end.15

if.then.12:                                       ; preds = %do.body
  store i8 0, i8* %sa_must_free, align 1
  %18 = load i64, i64* %sa_count, align 8
  %call13 = call i64 @builtin_lisp_symbol(i32 0)
  %call14 = call i64 @unbind_to(i64 %18, i64 %call13)
  br label %if.end.15

if.end.15:                                        ; preds = %if.then.12, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end.15
  %19 = load i64, i64* %decoded_string, align 8
  %call16 = call zeroext i1 @STRINGP(i64 %19)
  br i1 %call16, label %if.end.18, label %if.then.17

if.then.17:                                       ; preds = %do.end
  call void (i8*, ...) @error(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.15, i32 0, i32 0)) #8
  unreachable

if.end.18:                                        ; preds = %do.end
  %20 = load i64, i64* %decoded_string, align 8
  ret i64 %20
}

; Function Attrs: nounwind readnone uwtable
define i64 @next_almost_prime(i64 %n) #0 {
entry:
  %n.addr = alloca i64, align 8
  store i64 %n, i64* %n.addr, align 8
  %0 = load i64, i64* %n.addr, align 8
  %or = or i64 %0, 1
  store i64 %or, i64* %n.addr, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i64, i64* %n.addr, align 8
  %rem = srem i64 %1, 3
  %cmp = icmp ne i64 %rem, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.cond
  %2 = load i64, i64* %n.addr, align 8
  %rem1 = srem i64 %2, 5
  %cmp2 = icmp ne i64 %rem1, 0
  br i1 %cmp2, label %land.lhs.true.3, label %if.end

land.lhs.true.3:                                  ; preds = %land.lhs.true
  %3 = load i64, i64* %n.addr, align 8
  %rem4 = srem i64 %3, 7
  %cmp5 = icmp ne i64 %rem4, 0
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true.3
  %4 = load i64, i64* %n.addr, align 8
  ret i64 %4

if.end:                                           ; preds = %land.lhs.true.3, %land.lhs.true, %for.cond
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %5 = load i64, i64* %n.addr, align 8
  %add = add nsw i64 %5, 2
  store i64 %add, i64* %n.addr, align 8
  br label %for.cond
}

; Function Attrs: nounwind uwtable
define i64 @larger_vector(i64 %vec, i64 %incr_min, i64 %nitems_max) #1 {
entry:
  %vec.addr = alloca i64, align 8
  %incr_min.addr = alloca i64, align 8
  %nitems_max.addr = alloca i64, align 8
  %v = alloca %struct.Lisp_Vector*, align 8
  %incr = alloca i64, align 8
  %incr_max = alloca i64, align 8
  %old_size = alloca i64, align 8
  %new_size = alloca i64, align 8
  %C_language_max = alloca i64, align 8
  %n_max = alloca i64, align 8
  store i64 %vec, i64* %vec.addr, align 8
  store i64 %incr_min, i64* %incr_min.addr, align 8
  store i64 %nitems_max, i64* %nitems_max.addr, align 8
  store i64 1152921504606846975, i64* %C_language_max, align 8
  %0 = load i64, i64* %nitems_max.addr, align 8
  %cmp = icmp sle i64 0, %0
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, i64* %nitems_max.addr, align 8
  %2 = load i64, i64* %C_language_max, align 8
  %cmp1 = icmp slt i64 %1, %2
  br i1 %cmp1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true
  %3 = load i64, i64* %nitems_max.addr, align 8
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %entry
  %4 = load i64, i64* %C_language_max, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %3, %cond.true ], [ %4, %cond.false ]
  store i64 %cond, i64* %n_max, align 8
  %5 = load i64, i64* %vec.addr, align 8
  %call = call i64 @ASIZE(i64 %5)
  store i64 %call, i64* %old_size, align 8
  %6 = load i64, i64* %n_max, align 8
  %7 = load i64, i64* %old_size, align 8
  %sub = sub nsw i64 %6, %7
  store i64 %sub, i64* %incr_max, align 8
  %8 = load i64, i64* %incr_min.addr, align 8
  %9 = load i64, i64* %old_size, align 8
  %shr = ashr i64 %9, 1
  %10 = load i64, i64* %incr_max, align 8
  %cmp2 = icmp slt i64 %shr, %10
  br i1 %cmp2, label %cond.true.3, label %cond.false.5

cond.true.3:                                      ; preds = %cond.end
  %11 = load i64, i64* %old_size, align 8
  %shr4 = ashr i64 %11, 1
  br label %cond.end.6

cond.false.5:                                     ; preds = %cond.end
  %12 = load i64, i64* %incr_max, align 8
  br label %cond.end.6

cond.end.6:                                       ; preds = %cond.false.5, %cond.true.3
  %cond7 = phi i64 [ %shr4, %cond.true.3 ], [ %12, %cond.false.5 ]
  %cmp8 = icmp sgt i64 %8, %cond7
  br i1 %cmp8, label %cond.true.9, label %cond.false.10

cond.true.9:                                      ; preds = %cond.end.6
  %13 = load i64, i64* %incr_min.addr, align 8
  br label %cond.end.18

cond.false.10:                                    ; preds = %cond.end.6
  %14 = load i64, i64* %old_size, align 8
  %shr11 = ashr i64 %14, 1
  %15 = load i64, i64* %incr_max, align 8
  %cmp12 = icmp slt i64 %shr11, %15
  br i1 %cmp12, label %cond.true.13, label %cond.false.15

cond.true.13:                                     ; preds = %cond.false.10
  %16 = load i64, i64* %old_size, align 8
  %shr14 = ashr i64 %16, 1
  br label %cond.end.16

cond.false.15:                                    ; preds = %cond.false.10
  %17 = load i64, i64* %incr_max, align 8
  br label %cond.end.16

cond.end.16:                                      ; preds = %cond.false.15, %cond.true.13
  %cond17 = phi i64 [ %shr14, %cond.true.13 ], [ %17, %cond.false.15 ]
  br label %cond.end.18

cond.end.18:                                      ; preds = %cond.end.16, %cond.true.9
  %cond19 = phi i64 [ %13, %cond.true.9 ], [ %cond17, %cond.end.16 ]
  store i64 %cond19, i64* %incr, align 8
  %18 = load i64, i64* %incr_max, align 8
  %19 = load i64, i64* %incr, align 8
  %cmp20 = icmp slt i64 %18, %19
  br i1 %cmp20, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end.18
  call void @memory_full(i64 -1) #8
  unreachable

if.end:                                           ; preds = %cond.end.18
  %20 = load i64, i64* %old_size, align 8
  %21 = load i64, i64* %incr, align 8
  %add = add nsw i64 %20, %21
  store i64 %add, i64* %new_size, align 8
  %22 = load i64, i64* %new_size, align 8
  %call21 = call %struct.Lisp_Vector* @allocate_vector(i64 %22)
  store %struct.Lisp_Vector* %call21, %struct.Lisp_Vector** %v, align 8
  %23 = load %struct.Lisp_Vector*, %struct.Lisp_Vector** %v, align 8
  %contents = getelementptr inbounds %struct.Lisp_Vector, %struct.Lisp_Vector* %23, i32 0, i32 1
  %24 = bitcast [0 x i64]* %contents to i8*
  %25 = load i64, i64* %vec.addr, align 8
  %call22 = call %struct.Lisp_Vector* @XVECTOR(i64 %25)
  %contents23 = getelementptr inbounds %struct.Lisp_Vector, %struct.Lisp_Vector* %call22, i32 0, i32 1
  %26 = bitcast [0 x i64]* %contents23 to i8*
  %27 = load i64, i64* %old_size, align 8
  %mul = mul i64 %27, 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %24, i8* %26, i64 %mul, i32 8, i1 false)
  %28 = load %struct.Lisp_Vector*, %struct.Lisp_Vector** %v, align 8
  %contents24 = getelementptr inbounds %struct.Lisp_Vector, %struct.Lisp_Vector* %28, i32 0, i32 1
  %arraydecay = getelementptr inbounds [0 x i64], [0 x i64]* %contents24, i32 0, i32 0
  %29 = load i64, i64* %old_size, align 8
  %add.ptr = getelementptr inbounds i64, i64* %arraydecay, i64 %29
  %30 = bitcast i64* %add.ptr to i8*
  %31 = load i64, i64* %incr, align 8
  %mul25 = mul nsw i64 %31, 8
  call void @memclear(i8* %30, i64 %mul25)
  %32 = load %struct.Lisp_Vector*, %struct.Lisp_Vector** %v, align 8
  %33 = bitcast %struct.Lisp_Vector* %32 to i8*
  %call26 = call i64 @make_lisp_ptr(i8* %33, i32 5)
  store i64 %call26, i64* %vec.addr, align 8
  %34 = load i64, i64* %vec.addr, align 8
  ret i64 %34
}

declare %struct.Lisp_Vector* @XVECTOR(i64) #2

declare void @memclear(i8*, i64) #2

; Function Attrs: nounwind uwtable
define i64 @make_hash_table(%struct.hash_table_test* byval align 8 %test, i64 %size, i64 %rehash_size, i64 %rehash_threshold, i64 %weak) #1 {
entry:
  %size.addr = alloca i64, align 8
  %rehash_size.addr = alloca i64, align 8
  %rehash_threshold.addr = alloca i64, align 8
  %weak.addr = alloca i64, align 8
  %h = alloca %struct.Lisp_Hash_Table*, align 8
  %table = alloca i64, align 8
  %index_size = alloca i64, align 8
  %sz = alloca i64, align 8
  %i = alloca i64, align 8
  %index_float = alloca double, align 8
  store i64 %size, i64* %size.addr, align 8
  store i64 %rehash_size, i64* %rehash_size.addr, align 8
  store i64 %rehash_threshold, i64* %rehash_threshold.addr, align 8
  store i64 %weak, i64* %weak.addr, align 8
  %0 = load i64, i64* %size.addr, align 8
  %shr = ashr i64 %0, 2
  %cmp = icmp eq i64 %shr, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 6, i64* %size.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %1 = load i64, i64* %size.addr, align 8
  %shr1 = ashr i64 %1, 2
  store i64 %shr1, i64* %sz, align 8
  %2 = load i64, i64* %sz, align 8
  %conv = sitofp i64 %2 to double
  %3 = load i64, i64* %rehash_threshold.addr, align 8
  %call = call double @XFLOAT_DATA(i64 %3)
  %div = fdiv double %conv, %call
  store double %div, double* %index_float, align 8
  %4 = load double, double* %index_float, align 8
  %cmp2 = fcmp olt double %4, 0x43B0000000000000
  br i1 %cmp2, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %5 = load double, double* %index_float, align 8
  %conv4 = fptosi double %5 to i64
  %call5 = call i64 @next_almost_prime(i64 %conv4) #10
  br label %cond.end

cond.false:                                       ; preds = %if.end
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call5, %cond.true ], [ 1152921504606846976, %cond.false ]
  store i64 %cond, i64* %index_size, align 8
  %6 = load i64, i64* %index_size, align 8
  %7 = load i64, i64* %sz, align 8
  %mul = mul nsw i64 2, %7
  %cmp6 = icmp sgt i64 %6, %mul
  br i1 %cmp6, label %cond.true.8, label %cond.false.9

cond.true.8:                                      ; preds = %cond.end
  %8 = load i64, i64* %index_size, align 8
  br label %cond.end.11

cond.false.9:                                     ; preds = %cond.end
  %9 = load i64, i64* %sz, align 8
  %mul10 = mul nsw i64 2, %9
  br label %cond.end.11

cond.end.11:                                      ; preds = %cond.false.9, %cond.true.8
  %cond12 = phi i64 [ %8, %cond.true.8 ], [ %mul10, %cond.false.9 ]
  %cmp13 = icmp slt i64 1152921504606846975, %cond12
  br i1 %cmp13, label %if.then.15, label %if.end.16

if.then.15:                                       ; preds = %cond.end.11
  call void (i8*, ...) @error(i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.16, i32 0, i32 0)) #8
  unreachable

if.end.16:                                        ; preds = %cond.end.11
  %call17 = call %struct.Lisp_Hash_Table* @allocate_hash_table()
  store %struct.Lisp_Hash_Table* %call17, %struct.Lisp_Hash_Table** %h, align 8
  %10 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h, align 8
  %test18 = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %10, i32 0, i32 10
  %11 = bitcast %struct.hash_table_test* %test18 to i8*
  %12 = bitcast %struct.hash_table_test* %test to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %11, i8* %12, i64 40, i32 8, i1 false)
  %13 = load i64, i64* %weak.addr, align 8
  %14 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h, align 8
  %weak19 = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %14, i32 0, i32 1
  store i64 %13, i64* %weak19, align 8
  %15 = load i64, i64* %rehash_threshold.addr, align 8
  %16 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h, align 8
  %rehash_threshold20 = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %16, i32 0, i32 3
  store i64 %15, i64* %rehash_threshold20, align 8
  %17 = load i64, i64* %rehash_size.addr, align 8
  %18 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h, align 8
  %rehash_size21 = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %18, i32 0, i32 2
  store i64 %17, i64* %rehash_size21, align 8
  %19 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h, align 8
  %count = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %19, i32 0, i32 8
  store i64 0, i64* %count, align 8
  %20 = load i64, i64* %sz, align 8
  %mul22 = mul nsw i64 2, %20
  %shl = shl i64 %mul22, 2
  %add = add i64 %shl, 2
  %call23 = call i64 @builtin_lisp_symbol(i32 0)
  %call24 = call i64 @Fmake_vector(i64 %add, i64 %call23)
  %21 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h, align 8
  %key_and_value = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %21, i32 0, i32 9
  store i64 %call24, i64* %key_and_value, align 8
  %22 = load i64, i64* %size.addr, align 8
  %call25 = call i64 @builtin_lisp_symbol(i32 0)
  %call26 = call i64 @Fmake_vector(i64 %22, i64 %call25)
  %23 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h, align 8
  %hash = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %23, i32 0, i32 4
  store i64 %call26, i64* %hash, align 8
  %24 = load i64, i64* %size.addr, align 8
  %call27 = call i64 @builtin_lisp_symbol(i32 0)
  %call28 = call i64 @Fmake_vector(i64 %24, i64 %call27)
  %25 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h, align 8
  %next = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %25, i32 0, i32 5
  store i64 %call28, i64* %next, align 8
  %26 = load i64, i64* %index_size, align 8
  %shl29 = shl i64 %26, 2
  %add30 = add i64 %shl29, 2
  %call31 = call i64 @builtin_lisp_symbol(i32 0)
  %call32 = call i64 @Fmake_vector(i64 %add30, i64 %call31)
  %27 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h, align 8
  %index = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %27, i32 0, i32 7
  store i64 %call32, i64* %index, align 8
  store i64 0, i64* %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end.16
  %28 = load i64, i64* %i, align 8
  %29 = load i64, i64* %sz, align 8
  %sub = sub nsw i64 %29, 1
  %cmp33 = icmp slt i64 %28, %sub
  br i1 %cmp33, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %30 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h, align 8
  %31 = load i64, i64* %i, align 8
  %32 = load i64, i64* %i, align 8
  %add35 = add nsw i64 %32, 1
  %shl36 = shl i64 %add35, 2
  %add37 = add i64 %shl36, 2
  call void @set_hash_next_slot(%struct.Lisp_Hash_Table* %30, i64 %31, i64 %add37)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %33 = load i64, i64* %i, align 8
  %inc = add nsw i64 %33, 1
  store i64 %inc, i64* %i, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %34 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h, align 8
  %next_free = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %34, i32 0, i32 6
  store i64 2, i64* %next_free, align 8
  %35 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h, align 8
  %36 = bitcast %struct.Lisp_Hash_Table* %35 to i8*
  %call38 = call i64 @make_lisp_ptr(i8* %36, i32 5)
  store i64 %call38, i64* %table, align 8
  %37 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h, align 8
  %weak39 = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %37, i32 0, i32 1
  %38 = load i64, i64* %weak39, align 8
  %call40 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp41 = icmp eq i64 %38, %call40
  br i1 %cmp41, label %if.then.43, label %if.else

if.then.43:                                       ; preds = %for.end
  %39 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h, align 8
  %next_weak = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %39, i32 0, i32 11
  store %struct.Lisp_Hash_Table* null, %struct.Lisp_Hash_Table** %next_weak, align 8
  br label %if.end.45

if.else:                                          ; preds = %for.end
  %40 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** @weak_hash_tables, align 8
  %41 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h, align 8
  %next_weak44 = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %41, i32 0, i32 11
  store %struct.Lisp_Hash_Table* %40, %struct.Lisp_Hash_Table** %next_weak44, align 8
  %42 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h, align 8
  store %struct.Lisp_Hash_Table* %42, %struct.Lisp_Hash_Table** @weak_hash_tables, align 8
  br label %if.end.45

if.end.45:                                        ; preds = %if.else, %if.then.43
  %43 = load i64, i64* %table, align 8
  ret i64 %43
}

declare double @XFLOAT_DATA(i64) #2

; Function Attrs: nounwind uwtable
define internal %struct.Lisp_Hash_Table* @allocate_hash_table() #1 {
entry:
  %call = call %struct.Lisp_Vector* @allocate_pseudovector(i32 15, i32 7, i32 7, i32 7)
  %0 = bitcast %struct.Lisp_Vector* %call to %struct.Lisp_Hash_Table*
  ret %struct.Lisp_Hash_Table* %0
}

; Function Attrs: nounwind uwtable
define internal void @set_hash_next_slot(%struct.Lisp_Hash_Table* %h, i64 %idx, i64 %val) #1 {
entry:
  %h.addr = alloca %struct.Lisp_Hash_Table*, align 8
  %idx.addr = alloca i64, align 8
  %val.addr = alloca i64, align 8
  store %struct.Lisp_Hash_Table* %h, %struct.Lisp_Hash_Table** %h.addr, align 8
  store i64 %idx, i64* %idx.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  %0 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %next = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %0, i32 0, i32 5
  %1 = load i64, i64* %next, align 8
  %2 = load i64, i64* %idx.addr, align 8
  %3 = load i64, i64* %val.addr, align 8
  call void @gc_aset(i64 %1, i64 %2, i64 %3)
  ret void
}

; Function Attrs: nounwind uwtable
define i64 @hash_lookup(%struct.Lisp_Hash_Table* %h, i64 %key, i64* %hash) #1 {
entry:
  %h.addr = alloca %struct.Lisp_Hash_Table*, align 8
  %key.addr = alloca i64, align 8
  %hash.addr = alloca i64*, align 8
  %hash_code = alloca i64, align 8
  %start_of_bucket = alloca i64, align 8
  %idx = alloca i64, align 8
  %i = alloca i64, align 8
  store %struct.Lisp_Hash_Table* %h, %struct.Lisp_Hash_Table** %h.addr, align 8
  store i64 %key, i64* %key.addr, align 8
  store i64* %hash, i64** %hash.addr, align 8
  %0 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %test = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %0, i32 0, i32 10
  %hashfn = getelementptr inbounds %struct.hash_table_test, %struct.hash_table_test* %test, i32 0, i32 4
  %1 = load i64 (%struct.hash_table_test*, i64)*, i64 (%struct.hash_table_test*, i64)** %hashfn, align 8
  %2 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %test1 = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %2, i32 0, i32 10
  %3 = load i64, i64* %key.addr, align 8
  %call = call i64 %1(%struct.hash_table_test* %test1, i64 %3)
  store i64 %call, i64* %hash_code, align 8
  %4 = load i64*, i64** %hash.addr, align 8
  %tobool = icmp ne i64* %4, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load i64, i64* %hash_code, align 8
  %6 = load i64*, i64** %hash.addr, align 8
  store i64 %5, i64* %6, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %7 = load i64, i64* %hash_code, align 8
  %8 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %index = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %8, i32 0, i32 7
  %9 = load i64, i64* %index, align 8
  %call2 = call i64 @ASIZE(i64 %9)
  %rem = urem i64 %7, %call2
  store i64 %rem, i64* %start_of_bucket, align 8
  %10 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %11 = load i64, i64* %start_of_bucket, align 8
  %call3 = call i64 @HASH_INDEX(%struct.Lisp_Hash_Table* %10, i64 %11)
  store i64 %call3, i64* %idx, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end.19, %if.end
  %12 = load i64, i64* %idx, align 8
  %call4 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %12, %call4
  %lnot = xor i1 %cmp, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %13 = load i64, i64* %idx, align 8
  %shr = ashr i64 %13, 2
  store i64 %shr, i64* %i, align 8
  %14 = load i64, i64* %key.addr, align 8
  %15 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %16 = load i64, i64* %i, align 8
  %call5 = call i64 @HASH_KEY(%struct.Lisp_Hash_Table* %15, i64 %16)
  %cmp6 = icmp eq i64 %14, %call5
  br i1 %cmp6, label %if.then.18, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %while.body
  %17 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %test7 = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %17, i32 0, i32 10
  %cmpfn = getelementptr inbounds %struct.hash_table_test, %struct.hash_table_test* %test7, i32 0, i32 3
  %18 = load i1 (%struct.hash_table_test*, i64, i64)*, i1 (%struct.hash_table_test*, i64, i64)** %cmpfn, align 8
  %tobool8 = icmp ne i1 (%struct.hash_table_test*, i64, i64)* %18, null
  br i1 %tobool8, label %land.lhs.true, label %if.end.19

land.lhs.true:                                    ; preds = %lor.lhs.false
  %19 = load i64, i64* %hash_code, align 8
  %20 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %21 = load i64, i64* %i, align 8
  %call9 = call i64 @HASH_HASH(%struct.Lisp_Hash_Table* %20, i64 %21)
  %call10 = call i64 @XUINT(i64 %call9)
  %cmp11 = icmp eq i64 %19, %call10
  br i1 %cmp11, label %land.lhs.true.12, label %if.end.19

land.lhs.true.12:                                 ; preds = %land.lhs.true
  %22 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %test13 = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %22, i32 0, i32 10
  %cmpfn14 = getelementptr inbounds %struct.hash_table_test, %struct.hash_table_test* %test13, i32 0, i32 3
  %23 = load i1 (%struct.hash_table_test*, i64, i64)*, i1 (%struct.hash_table_test*, i64, i64)** %cmpfn14, align 8
  %24 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %test15 = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %24, i32 0, i32 10
  %25 = load i64, i64* %key.addr, align 8
  %26 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %27 = load i64, i64* %i, align 8
  %call16 = call i64 @HASH_KEY(%struct.Lisp_Hash_Table* %26, i64 %27)
  %call17 = call zeroext i1 %23(%struct.hash_table_test* %test15, i64 %25, i64 %call16)
  br i1 %call17, label %if.then.18, label %if.end.19

if.then.18:                                       ; preds = %land.lhs.true.12, %while.body
  br label %while.end

if.end.19:                                        ; preds = %land.lhs.true.12, %land.lhs.true, %lor.lhs.false
  %28 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %29 = load i64, i64* %i, align 8
  %call20 = call i64 @HASH_NEXT(%struct.Lisp_Hash_Table* %28, i64 %29)
  store i64 %call20, i64* %idx, align 8
  br label %while.cond

while.end:                                        ; preds = %if.then.18, %while.cond
  %30 = load i64, i64* %idx, align 8
  %call21 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp22 = icmp eq i64 %30, %call21
  br i1 %cmp22, label %cond.true, label %cond.false

cond.true:                                        ; preds = %while.end
  br label %cond.end

cond.false:                                       ; preds = %while.end
  %31 = load i64, i64* %idx, align 8
  %shr23 = ashr i64 %31, 2
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ -1, %cond.true ], [ %shr23, %cond.false ]
  ret i64 %cond
}

declare i64 @HASH_INDEX(%struct.Lisp_Hash_Table*, i64) #2

declare i64 @HASH_KEY(%struct.Lisp_Hash_Table*, i64) #2

declare i64 @XUINT(i64) #2

declare i64 @HASH_HASH(%struct.Lisp_Hash_Table*, i64) #2

declare i64 @HASH_NEXT(%struct.Lisp_Hash_Table*, i64) #2

; Function Attrs: nounwind uwtable
define i64 @hash_put(%struct.Lisp_Hash_Table* %h, i64 %key, i64 %value, i64 %hash) #1 {
entry:
  %h.addr = alloca %struct.Lisp_Hash_Table*, align 8
  %key.addr = alloca i64, align 8
  %value.addr = alloca i64, align 8
  %hash.addr = alloca i64, align 8
  %start_of_bucket = alloca i64, align 8
  %i = alloca i64, align 8
  store %struct.Lisp_Hash_Table* %h, %struct.Lisp_Hash_Table** %h.addr, align 8
  store i64 %key, i64* %key.addr, align 8
  store i64 %value, i64* %value.addr, align 8
  store i64 %hash, i64* %hash.addr, align 8
  %0 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  call void @maybe_resize_hash_table(%struct.Lisp_Hash_Table* %0)
  %1 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %count = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %1, i32 0, i32 8
  %2 = load i64, i64* %count, align 8
  %inc = add nsw i64 %2, 1
  store i64 %inc, i64* %count, align 8
  %3 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %next_free = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %3, i32 0, i32 6
  %4 = load i64, i64* %next_free, align 8
  %shr = ashr i64 %4, 2
  store i64 %shr, i64* %i, align 8
  %5 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %6 = load i64, i64* %i, align 8
  %call = call i64 @HASH_NEXT(%struct.Lisp_Hash_Table* %5, i64 %6)
  %7 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %next_free1 = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %7, i32 0, i32 6
  store i64 %call, i64* %next_free1, align 8
  %8 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %9 = load i64, i64* %i, align 8
  %10 = load i64, i64* %key.addr, align 8
  call void @set_hash_key_slot(%struct.Lisp_Hash_Table* %8, i64 %9, i64 %10)
  %11 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %12 = load i64, i64* %i, align 8
  %13 = load i64, i64* %value.addr, align 8
  call void @set_hash_value_slot(%struct.Lisp_Hash_Table* %11, i64 %12, i64 %13)
  %14 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %15 = load i64, i64* %i, align 8
  %16 = load i64, i64* %hash.addr, align 8
  %shl = shl i64 %16, 2
  %add = add i64 %shl, 2
  call void @set_hash_hash_slot(%struct.Lisp_Hash_Table* %14, i64 %15, i64 %add)
  %17 = load i64, i64* %hash.addr, align 8
  %18 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %index = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %18, i32 0, i32 7
  %19 = load i64, i64* %index, align 8
  %call2 = call i64 @ASIZE(i64 %19)
  %rem = urem i64 %17, %call2
  store i64 %rem, i64* %start_of_bucket, align 8
  %20 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %21 = load i64, i64* %i, align 8
  %22 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %23 = load i64, i64* %start_of_bucket, align 8
  %call3 = call i64 @HASH_INDEX(%struct.Lisp_Hash_Table* %22, i64 %23)
  call void @set_hash_next_slot(%struct.Lisp_Hash_Table* %20, i64 %21, i64 %call3)
  %24 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %25 = load i64, i64* %start_of_bucket, align 8
  %26 = load i64, i64* %i, align 8
  %shl4 = shl i64 %26, 2
  %add5 = add i64 %shl4, 2
  call void @set_hash_index_slot(%struct.Lisp_Hash_Table* %24, i64 %25, i64 %add5)
  %27 = load i64, i64* %i, align 8
  ret i64 %27
}

; Function Attrs: nounwind uwtable
define internal void @maybe_resize_hash_table(%struct.Lisp_Hash_Table* %h) #1 {
entry:
  %h.addr = alloca %struct.Lisp_Hash_Table*, align 8
  %old_size = alloca i64, align 8
  %new_size = alloca i64, align 8
  %index_size = alloca i64, align 8
  %nsize = alloca i64, align 8
  %i = alloca i64, align 8
  %index_float = alloca double, align 8
  %float_new_size = alloca double, align 8
  %last = alloca i64, align 8
  %next59 = alloca i64, align 8
  %hash_code = alloca i64, align 8
  %start_of_bucket = alloca i64, align 8
  store %struct.Lisp_Hash_Table* %h, %struct.Lisp_Hash_Table** %h.addr, align 8
  %0 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %next_free = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %0, i32 0, i32 6
  %1 = load i64, i64* %next_free, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %1, %call
  br i1 %cmp, label %if.then, label %if.end.92

if.then:                                          ; preds = %entry
  %2 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %call1 = call i64 @HASH_TABLE_SIZE(%struct.Lisp_Hash_Table* %2)
  store i64 %call1, i64* %old_size, align 8
  %3 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %rehash_size = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %3, i32 0, i32 2
  %4 = load i64, i64* %rehash_size, align 8
  %and = and i64 %4, 7
  %conv = trunc i64 %and to i32
  %and2 = and i32 %conv, -5
  %cmp3 = icmp eq i32 %and2, 2
  br i1 %cmp3, label %if.then.5, label %if.else

if.then.5:                                        ; preds = %if.then
  %5 = load i64, i64* %old_size, align 8
  %6 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %rehash_size6 = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %6, i32 0, i32 2
  %7 = load i64, i64* %rehash_size6, align 8
  %shr = ashr i64 %7, 2
  %add = add nsw i64 %5, %shr
  store i64 %add, i64* %new_size, align 8
  br label %if.end.20

if.else:                                          ; preds = %if.then
  %8 = load i64, i64* %old_size, align 8
  %conv7 = sitofp i64 %8 to double
  %9 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %rehash_size8 = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %9, i32 0, i32 2
  %10 = load i64, i64* %rehash_size8, align 8
  %call9 = call double @XFLOAT_DATA(i64 %10)
  %mul = fmul double %conv7, %call9
  store double %mul, double* %float_new_size, align 8
  %11 = load double, double* %float_new_size, align 8
  %cmp10 = fcmp olt double %11, 0x43B0000000000000
  br i1 %cmp10, label %if.then.12, label %if.else.18

if.then.12:                                       ; preds = %if.else
  %12 = load double, double* %float_new_size, align 8
  %conv13 = fptosi double %12 to i64
  store i64 %conv13, i64* %new_size, align 8
  %13 = load i64, i64* %new_size, align 8
  %14 = load i64, i64* %old_size, align 8
  %cmp14 = icmp sle i64 %13, %14
  br i1 %cmp14, label %if.then.16, label %if.end

if.then.16:                                       ; preds = %if.then.12
  %15 = load i64, i64* %old_size, align 8
  %add17 = add nsw i64 %15, 1
  store i64 %add17, i64* %new_size, align 8
  br label %if.end

if.end:                                           ; preds = %if.then.16, %if.then.12
  br label %if.end.19

if.else.18:                                       ; preds = %if.else
  store i64 1152921504606846976, i64* %new_size, align 8
  br label %if.end.19

if.end.19:                                        ; preds = %if.else.18, %if.end
  br label %if.end.20

if.end.20:                                        ; preds = %if.end.19, %if.then.5
  %16 = load i64, i64* %new_size, align 8
  %conv21 = sitofp i64 %16 to double
  %17 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %rehash_threshold = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %17, i32 0, i32 3
  %18 = load i64, i64* %rehash_threshold, align 8
  %call22 = call double @XFLOAT_DATA(i64 %18)
  %div = fdiv double %conv21, %call22
  store double %div, double* %index_float, align 8
  %19 = load double, double* %index_float, align 8
  %cmp23 = fcmp olt double %19, 0x43B0000000000000
  br i1 %cmp23, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end.20
  %20 = load double, double* %index_float, align 8
  %conv25 = fptosi double %20 to i64
  %call26 = call i64 @next_almost_prime(i64 %conv25) #10
  br label %cond.end

cond.false:                                       ; preds = %if.end.20
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call26, %cond.true ], [ 1152921504606846976, %cond.false ]
  store i64 %cond, i64* %index_size, align 8
  %21 = load i64, i64* %index_size, align 8
  %22 = load i64, i64* %new_size, align 8
  %mul27 = mul nsw i64 2, %22
  %cmp28 = icmp sgt i64 %21, %mul27
  br i1 %cmp28, label %cond.true.30, label %cond.false.31

cond.true.30:                                     ; preds = %cond.end
  %23 = load i64, i64* %index_size, align 8
  br label %cond.end.33

cond.false.31:                                    ; preds = %cond.end
  %24 = load i64, i64* %new_size, align 8
  %mul32 = mul nsw i64 2, %24
  br label %cond.end.33

cond.end.33:                                      ; preds = %cond.false.31, %cond.true.30
  %cond34 = phi i64 [ %23, %cond.true.30 ], [ %mul32, %cond.false.31 ]
  store i64 %cond34, i64* %nsize, align 8
  %25 = load i64, i64* %nsize, align 8
  %cmp35 = icmp slt i64 1152921504606846975, %25
  br i1 %cmp35, label %if.then.37, label %if.end.38

if.then.37:                                       ; preds = %cond.end.33
  call void (i8*, ...) @error(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.28, i32 0, i32 0)) #8
  unreachable

if.end.38:                                        ; preds = %cond.end.33
  %26 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %27 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %key_and_value = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %27, i32 0, i32 9
  %28 = load i64, i64* %key_and_value, align 8
  %29 = load i64, i64* %new_size, align 8
  %30 = load i64, i64* %old_size, align 8
  %sub = sub nsw i64 %29, %30
  %mul39 = mul nsw i64 2, %sub
  %call40 = call i64 @larger_vector(i64 %28, i64 %mul39, i64 -1)
  call void @set_hash_key_and_value(%struct.Lisp_Hash_Table* %26, i64 %call40)
  %31 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %32 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %next = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %32, i32 0, i32 5
  %33 = load i64, i64* %next, align 8
  %34 = load i64, i64* %new_size, align 8
  %35 = load i64, i64* %old_size, align 8
  %sub41 = sub nsw i64 %34, %35
  %call42 = call i64 @larger_vector(i64 %33, i64 %sub41, i64 -1)
  call void @set_hash_next(%struct.Lisp_Hash_Table* %31, i64 %call42)
  %36 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %37 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %hash = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %37, i32 0, i32 4
  %38 = load i64, i64* %hash, align 8
  %39 = load i64, i64* %new_size, align 8
  %40 = load i64, i64* %old_size, align 8
  %sub43 = sub nsw i64 %39, %40
  %call44 = call i64 @larger_vector(i64 %38, i64 %sub43, i64 -1)
  call void @set_hash_hash(%struct.Lisp_Hash_Table* %36, i64 %call44)
  %41 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %42 = load i64, i64* %index_size, align 8
  %shl = shl i64 %42, 2
  %add45 = add i64 %shl, 2
  %call46 = call i64 @builtin_lisp_symbol(i32 0)
  %call47 = call i64 @Fmake_vector(i64 %add45, i64 %call46)
  call void @set_hash_index(%struct.Lisp_Hash_Table* %41, i64 %call47)
  %43 = load i64, i64* %old_size, align 8
  store i64 %43, i64* %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end.38
  %44 = load i64, i64* %i, align 8
  %45 = load i64, i64* %new_size, align 8
  %sub48 = sub nsw i64 %45, 1
  %cmp49 = icmp slt i64 %44, %sub48
  br i1 %cmp49, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %46 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %47 = load i64, i64* %i, align 8
  %48 = load i64, i64* %i, align 8
  %add51 = add nsw i64 %48, 1
  %shl52 = shl i64 %add51, 2
  %add53 = add i64 %shl52, 2
  call void @set_hash_next_slot(%struct.Lisp_Hash_Table* %46, i64 %47, i64 %add53)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %49 = load i64, i64* %i, align 8
  %inc = add nsw i64 %49, 1
  store i64 %inc, i64* %i, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %50 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %next_free54 = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %50, i32 0, i32 6
  %51 = load i64, i64* %next_free54, align 8
  %call55 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp56 = icmp eq i64 %51, %call55
  br i1 %cmp56, label %if.else.69, label %if.then.58

if.then.58:                                       ; preds = %for.end
  %52 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %next_free60 = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %52, i32 0, i32 6
  %53 = load i64, i64* %next_free60, align 8
  store i64 %53, i64* %last, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.then.58
  %54 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %55 = load i64, i64* %last, align 8
  %shr61 = ashr i64 %55, 2
  %call62 = call i64 @HASH_NEXT(%struct.Lisp_Hash_Table* %54, i64 %shr61)
  store i64 %call62, i64* %next59, align 8
  %56 = load i64, i64* %next59, align 8
  %call63 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp64 = icmp eq i64 %56, %call63
  %lnot = xor i1 %cmp64, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %57 = load i64, i64* %next59, align 8
  store i64 %57, i64* %last, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %58 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %59 = load i64, i64* %last, align 8
  %shr66 = ashr i64 %59, 2
  %60 = load i64, i64* %old_size, align 8
  %shl67 = shl i64 %60, 2
  %add68 = add i64 %shl67, 2
  call void @set_hash_next_slot(%struct.Lisp_Hash_Table* %58, i64 %shr66, i64 %add68)
  br label %if.end.72

if.else.69:                                       ; preds = %for.end
  %61 = load i64, i64* %old_size, align 8
  %call70 = call i64 @make_natnum(i64 %61)
  %62 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %next_free71 = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %62, i32 0, i32 6
  store i64 %call70, i64* %next_free71, align 8
  br label %if.end.72

if.end.72:                                        ; preds = %if.else.69, %while.end
  store i64 0, i64* %i, align 8
  br label %for.cond.73

for.cond.73:                                      ; preds = %for.inc.89, %if.end.72
  %63 = load i64, i64* %i, align 8
  %64 = load i64, i64* %old_size, align 8
  %cmp74 = icmp slt i64 %63, %64
  br i1 %cmp74, label %for.body.76, label %for.end.91

for.body.76:                                      ; preds = %for.cond.73
  %65 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %66 = load i64, i64* %i, align 8
  %call77 = call i64 @HASH_HASH(%struct.Lisp_Hash_Table* %65, i64 %66)
  %call78 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp79 = icmp eq i64 %call77, %call78
  br i1 %cmp79, label %if.end.88, label %if.then.81

if.then.81:                                       ; preds = %for.body.76
  %67 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %68 = load i64, i64* %i, align 8
  %call82 = call i64 @HASH_HASH(%struct.Lisp_Hash_Table* %67, i64 %68)
  %call83 = call i64 @XUINT(i64 %call82)
  store i64 %call83, i64* %hash_code, align 8
  %69 = load i64, i64* %hash_code, align 8
  %70 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %index = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %70, i32 0, i32 7
  %71 = load i64, i64* %index, align 8
  %call84 = call i64 @ASIZE(i64 %71)
  %rem = urem i64 %69, %call84
  store i64 %rem, i64* %start_of_bucket, align 8
  %72 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %73 = load i64, i64* %i, align 8
  %74 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %75 = load i64, i64* %start_of_bucket, align 8
  %call85 = call i64 @HASH_INDEX(%struct.Lisp_Hash_Table* %74, i64 %75)
  call void @set_hash_next_slot(%struct.Lisp_Hash_Table* %72, i64 %73, i64 %call85)
  %76 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %77 = load i64, i64* %start_of_bucket, align 8
  %78 = load i64, i64* %i, align 8
  %shl86 = shl i64 %78, 2
  %add87 = add i64 %shl86, 2
  call void @set_hash_index_slot(%struct.Lisp_Hash_Table* %76, i64 %77, i64 %add87)
  br label %if.end.88

if.end.88:                                        ; preds = %if.then.81, %for.body.76
  br label %for.inc.89

for.inc.89:                                       ; preds = %if.end.88
  %79 = load i64, i64* %i, align 8
  %inc90 = add nsw i64 %79, 1
  store i64 %inc90, i64* %i, align 8
  br label %for.cond.73

for.end.91:                                       ; preds = %for.cond.73
  br label %if.end.92

if.end.92:                                        ; preds = %for.end.91, %entry
  ret void
}

declare void @set_hash_key_slot(%struct.Lisp_Hash_Table*, i64, i64) #2

declare void @set_hash_value_slot(%struct.Lisp_Hash_Table*, i64, i64) #2

; Function Attrs: nounwind uwtable
define internal void @set_hash_hash_slot(%struct.Lisp_Hash_Table* %h, i64 %idx, i64 %val) #1 {
entry:
  %h.addr = alloca %struct.Lisp_Hash_Table*, align 8
  %idx.addr = alloca i64, align 8
  %val.addr = alloca i64, align 8
  store %struct.Lisp_Hash_Table* %h, %struct.Lisp_Hash_Table** %h.addr, align 8
  store i64 %idx, i64* %idx.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  %0 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %hash = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %0, i32 0, i32 4
  %1 = load i64, i64* %hash, align 8
  %2 = load i64, i64* %idx.addr, align 8
  %3 = load i64, i64* %val.addr, align 8
  call void @gc_aset(i64 %1, i64 %2, i64 %3)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @set_hash_index_slot(%struct.Lisp_Hash_Table* %h, i64 %idx, i64 %val) #1 {
entry:
  %h.addr = alloca %struct.Lisp_Hash_Table*, align 8
  %idx.addr = alloca i64, align 8
  %val.addr = alloca i64, align 8
  store %struct.Lisp_Hash_Table* %h, %struct.Lisp_Hash_Table** %h.addr, align 8
  store i64 %idx, i64* %idx.addr, align 8
  store i64 %val, i64* %val.addr, align 8
  %0 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %index = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %0, i32 0, i32 7
  %1 = load i64, i64* %index, align 8
  %2 = load i64, i64* %idx.addr, align 8
  %3 = load i64, i64* %val.addr, align 8
  call void @gc_aset(i64 %1, i64 %2, i64 %3)
  ret void
}

; Function Attrs: nounwind uwtable
define void @hash_remove_from_table(%struct.Lisp_Hash_Table* %h, i64 %key) #1 {
entry:
  %h.addr = alloca %struct.Lisp_Hash_Table*, align 8
  %key.addr = alloca i64, align 8
  %hash_code = alloca i64, align 8
  %start_of_bucket = alloca i64, align 8
  %idx = alloca i64, align 8
  %prev = alloca i64, align 8
  %i = alloca i64, align 8
  store %struct.Lisp_Hash_Table* %h, %struct.Lisp_Hash_Table** %h.addr, align 8
  store i64 %key, i64* %key.addr, align 8
  %0 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %test = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %0, i32 0, i32 10
  %hashfn = getelementptr inbounds %struct.hash_table_test, %struct.hash_table_test* %test, i32 0, i32 4
  %1 = load i64 (%struct.hash_table_test*, i64)*, i64 (%struct.hash_table_test*, i64)** %hashfn, align 8
  %2 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %test1 = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %2, i32 0, i32 10
  %3 = load i64, i64* %key.addr, align 8
  %call = call i64 %1(%struct.hash_table_test* %test1, i64 %3)
  store i64 %call, i64* %hash_code, align 8
  %4 = load i64, i64* %hash_code, align 8
  %5 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %index = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %5, i32 0, i32 7
  %6 = load i64, i64* %index, align 8
  %call2 = call i64 @ASIZE(i64 %6)
  %rem = urem i64 %4, %call2
  store i64 %rem, i64* %start_of_bucket, align 8
  %7 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %8 = load i64, i64* %start_of_bucket, align 8
  %call3 = call i64 @HASH_INDEX(%struct.Lisp_Hash_Table* %7, i64 %8)
  store i64 %call3, i64* %idx, align 8
  %call4 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call4, i64* %prev, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end.30, %entry
  %9 = load i64, i64* %idx, align 8
  %call5 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %9, %call5
  %lnot = xor i1 %cmp, true
  br i1 %lnot, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %10 = load i64, i64* %idx, align 8
  %shr = ashr i64 %10, 2
  store i64 %shr, i64* %i, align 8
  %11 = load i64, i64* %key.addr, align 8
  %12 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %13 = load i64, i64* %i, align 8
  %call6 = call i64 @HASH_KEY(%struct.Lisp_Hash_Table* %12, i64 %13)
  %cmp7 = icmp eq i64 %11, %call6
  br i1 %cmp7, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %while.body
  %14 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %test8 = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %14, i32 0, i32 10
  %cmpfn = getelementptr inbounds %struct.hash_table_test, %struct.hash_table_test* %test8, i32 0, i32 3
  %15 = load i1 (%struct.hash_table_test*, i64, i64)*, i1 (%struct.hash_table_test*, i64, i64)** %cmpfn, align 8
  %tobool = icmp ne i1 (%struct.hash_table_test*, i64, i64)* %15, null
  br i1 %tobool, label %land.lhs.true, label %if.else.28

land.lhs.true:                                    ; preds = %lor.lhs.false
  %16 = load i64, i64* %hash_code, align 8
  %17 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %18 = load i64, i64* %i, align 8
  %call9 = call i64 @HASH_HASH(%struct.Lisp_Hash_Table* %17, i64 %18)
  %call10 = call i64 @XUINT(i64 %call9)
  %cmp11 = icmp eq i64 %16, %call10
  br i1 %cmp11, label %land.lhs.true.12, label %if.else.28

land.lhs.true.12:                                 ; preds = %land.lhs.true
  %19 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %test13 = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %19, i32 0, i32 10
  %cmpfn14 = getelementptr inbounds %struct.hash_table_test, %struct.hash_table_test* %test13, i32 0, i32 3
  %20 = load i1 (%struct.hash_table_test*, i64, i64)*, i1 (%struct.hash_table_test*, i64, i64)** %cmpfn14, align 8
  %21 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %test15 = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %21, i32 0, i32 10
  %22 = load i64, i64* %key.addr, align 8
  %23 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %24 = load i64, i64* %i, align 8
  %call16 = call i64 @HASH_KEY(%struct.Lisp_Hash_Table* %23, i64 %24)
  %call17 = call zeroext i1 %20(%struct.hash_table_test* %test15, i64 %22, i64 %call16)
  br i1 %call17, label %if.then, label %if.else.28

if.then:                                          ; preds = %land.lhs.true.12, %while.body
  %25 = load i64, i64* %prev, align 8
  %call18 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp19 = icmp eq i64 %25, %call18
  br i1 %cmp19, label %if.then.20, label %if.else

if.then.20:                                       ; preds = %if.then
  %26 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %27 = load i64, i64* %start_of_bucket, align 8
  %28 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %29 = load i64, i64* %i, align 8
  %call21 = call i64 @HASH_NEXT(%struct.Lisp_Hash_Table* %28, i64 %29)
  call void @set_hash_index_slot(%struct.Lisp_Hash_Table* %26, i64 %27, i64 %call21)
  br label %if.end

if.else:                                          ; preds = %if.then
  %30 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %31 = load i64, i64* %prev, align 8
  %shr22 = ashr i64 %31, 2
  %32 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %33 = load i64, i64* %i, align 8
  %call23 = call i64 @HASH_NEXT(%struct.Lisp_Hash_Table* %32, i64 %33)
  call void @set_hash_next_slot(%struct.Lisp_Hash_Table* %30, i64 %shr22, i64 %call23)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then.20
  %34 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %35 = load i64, i64* %i, align 8
  %call24 = call i64 @builtin_lisp_symbol(i32 0)
  call void @set_hash_key_slot(%struct.Lisp_Hash_Table* %34, i64 %35, i64 %call24)
  %36 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %37 = load i64, i64* %i, align 8
  %call25 = call i64 @builtin_lisp_symbol(i32 0)
  call void @set_hash_value_slot(%struct.Lisp_Hash_Table* %36, i64 %37, i64 %call25)
  %38 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %39 = load i64, i64* %i, align 8
  %call26 = call i64 @builtin_lisp_symbol(i32 0)
  call void @set_hash_hash_slot(%struct.Lisp_Hash_Table* %38, i64 %39, i64 %call26)
  %40 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %41 = load i64, i64* %i, align 8
  %42 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %next_free = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %42, i32 0, i32 6
  %43 = load i64, i64* %next_free, align 8
  call void @set_hash_next_slot(%struct.Lisp_Hash_Table* %40, i64 %41, i64 %43)
  %44 = load i64, i64* %i, align 8
  %shl = shl i64 %44, 2
  %add = add i64 %shl, 2
  %45 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %next_free27 = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %45, i32 0, i32 6
  store i64 %add, i64* %next_free27, align 8
  %46 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %count = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %46, i32 0, i32 8
  %47 = load i64, i64* %count, align 8
  %dec = add nsw i64 %47, -1
  store i64 %dec, i64* %count, align 8
  br label %while.end

if.else.28:                                       ; preds = %land.lhs.true.12, %land.lhs.true, %lor.lhs.false
  %48 = load i64, i64* %idx, align 8
  store i64 %48, i64* %prev, align 8
  %49 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %50 = load i64, i64* %i, align 8
  %call29 = call i64 @HASH_NEXT(%struct.Lisp_Hash_Table* %49, i64 %50)
  store i64 %call29, i64* %idx, align 8
  br label %if.end.30

if.end.30:                                        ; preds = %if.else.28
  br label %while.cond

while.end:                                        ; preds = %if.end, %while.cond
  ret void
}

; Function Attrs: noinline nounwind uwtable
define void @sweep_weak_hash_tables() #7 {
entry:
  %h = alloca %struct.Lisp_Hash_Table*, align 8
  %used = alloca %struct.Lisp_Hash_Table*, align 8
  %next = alloca %struct.Lisp_Hash_Table*, align 8
  %marked = alloca i8, align 1
  br label %do.body

do.body:                                          ; preds = %do.cond, %entry
  store i8 0, i8* %marked, align 1
  %0 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** @weak_hash_tables, align 8
  store %struct.Lisp_Hash_Table* %0, %struct.Lisp_Hash_Table** %h, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.body
  %1 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h, align 8
  %tobool = icmp ne %struct.Lisp_Hash_Table* %1, null
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h, align 8
  %header = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %2, i32 0, i32 0
  %size = getelementptr inbounds %struct.vectorlike_header, %struct.vectorlike_header* %header, i32 0, i32 0
  %3 = load i64, i64* %size, align 8
  %and = and i64 %3, -9223372036854775808
  %tobool1 = icmp ne i64 %and, 0
  br i1 %tobool1, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %4 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h, align 8
  %call = call zeroext i1 @sweep_weak_table(%struct.Lisp_Hash_Table* %4, i1 zeroext false)
  %conv = zext i1 %call to i32
  %5 = load i8, i8* %marked, align 1
  %tobool2 = trunc i8 %5 to i1
  %conv3 = zext i1 %tobool2 to i32
  %or = or i32 %conv3, %conv
  %tobool4 = icmp ne i32 %or, 0
  %frombool = zext i1 %tobool4 to i8
  store i8 %frombool, i8* %marked, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %6 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h, align 8
  %next_weak = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %6, i32 0, i32 11
  %7 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %next_weak, align 8
  store %struct.Lisp_Hash_Table* %7, %struct.Lisp_Hash_Table** %h, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %do.cond

do.cond:                                          ; preds = %for.end
  %8 = load i8, i8* %marked, align 1
  %tobool5 = trunc i8 %8 to i1
  br i1 %tobool5, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  %9 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** @weak_hash_tables, align 8
  store %struct.Lisp_Hash_Table* %9, %struct.Lisp_Hash_Table** %h, align 8
  store %struct.Lisp_Hash_Table* null, %struct.Lisp_Hash_Table** %used, align 8
  br label %for.cond.6

for.cond.6:                                       ; preds = %for.inc.21, %do.end
  %10 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h, align 8
  %tobool7 = icmp ne %struct.Lisp_Hash_Table* %10, null
  br i1 %tobool7, label %for.body.8, label %for.end.22

for.body.8:                                       ; preds = %for.cond.6
  %11 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h, align 8
  %next_weak9 = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %11, i32 0, i32 11
  %12 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %next_weak9, align 8
  store %struct.Lisp_Hash_Table* %12, %struct.Lisp_Hash_Table** %next, align 8
  %13 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h, align 8
  %header10 = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %13, i32 0, i32 0
  %size11 = getelementptr inbounds %struct.vectorlike_header, %struct.vectorlike_header* %header10, i32 0, i32 0
  %14 = load i64, i64* %size11, align 8
  %and12 = and i64 %14, -9223372036854775808
  %tobool13 = icmp ne i64 %and12, 0
  br i1 %tobool13, label %if.then.14, label %if.end.20

if.then.14:                                       ; preds = %for.body.8
  %15 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h, align 8
  %count = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %15, i32 0, i32 8
  %16 = load i64, i64* %count, align 8
  %cmp = icmp sgt i64 %16, 0
  br i1 %cmp, label %if.then.16, label %if.end.18

if.then.16:                                       ; preds = %if.then.14
  %17 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h, align 8
  %call17 = call zeroext i1 @sweep_weak_table(%struct.Lisp_Hash_Table* %17, i1 zeroext true)
  br label %if.end.18

if.end.18:                                        ; preds = %if.then.16, %if.then.14
  %18 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %used, align 8
  %19 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h, align 8
  %next_weak19 = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %19, i32 0, i32 11
  store %struct.Lisp_Hash_Table* %18, %struct.Lisp_Hash_Table** %next_weak19, align 8
  %20 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h, align 8
  store %struct.Lisp_Hash_Table* %20, %struct.Lisp_Hash_Table** %used, align 8
  br label %if.end.20

if.end.20:                                        ; preds = %if.end.18, %for.body.8
  br label %for.inc.21

for.inc.21:                                       ; preds = %if.end.20
  %21 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %next, align 8
  store %struct.Lisp_Hash_Table* %21, %struct.Lisp_Hash_Table** %h, align 8
  br label %for.cond.6

for.end.22:                                       ; preds = %for.cond.6
  %22 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %used, align 8
  store %struct.Lisp_Hash_Table* %22, %struct.Lisp_Hash_Table** @weak_hash_tables, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @sweep_weak_table(%struct.Lisp_Hash_Table* %h, i1 zeroext %remove_entries_p) #1 {
entry:
  %h.addr = alloca %struct.Lisp_Hash_Table*, align 8
  %remove_entries_p.addr = alloca i8, align 1
  %n = alloca i64, align 8
  %marked = alloca i8, align 1
  %bucket = alloca i64, align 8
  %idx = alloca i64, align 8
  %next = alloca i64, align 8
  %prev = alloca i64, align 8
  %i = alloca i64, align 8
  %key_known_to_survive_p = alloca i8, align 1
  %value_known_to_survive_p = alloca i8, align 1
  %remove_p = alloca i8, align 1
  store %struct.Lisp_Hash_Table* %h, %struct.Lisp_Hash_Table** %h.addr, align 8
  %frombool = zext i1 %remove_entries_p to i8
  store i8 %frombool, i8* %remove_entries_p.addr, align 1
  %0 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %index = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %0, i32 0, i32 7
  %1 = load i64, i64* %index, align 8
  %call = call i64 @gc_asize(i64 %1)
  store i64 %call, i64* %n, align 8
  store i8 0, i8* %marked, align 1
  store i64 0, i64* %bucket, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc.76, %entry
  %2 = load i64, i64* %bucket, align 8
  %3 = load i64, i64* %n, align 8
  %cmp = icmp slt i64 %2, %3
  br i1 %cmp, label %for.body, label %for.end.77

for.body:                                         ; preds = %for.cond
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call1, i64* %prev, align 8
  %4 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %5 = load i64, i64* %bucket, align 8
  %call2 = call i64 @HASH_INDEX(%struct.Lisp_Hash_Table* %4, i64 %5)
  store i64 %call2, i64* %idx, align 8
  br label %for.cond.3

for.cond.3:                                       ; preds = %for.inc, %for.body
  %6 = load i64, i64* %idx, align 8
  %call4 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp5 = icmp eq i64 %6, %call4
  %lnot = xor i1 %cmp5, true
  br i1 %lnot, label %for.body.6, label %for.end

for.body.6:                                       ; preds = %for.cond.3
  %7 = load i64, i64* %idx, align 8
  %shr = ashr i64 %7, 2
  store i64 %shr, i64* %i, align 8
  %8 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %9 = load i64, i64* %i, align 8
  %call7 = call i64 @HASH_KEY(%struct.Lisp_Hash_Table* %8, i64 %9)
  %call8 = call zeroext i1 @survives_gc_p(i64 %call7)
  %frombool9 = zext i1 %call8 to i8
  store i8 %frombool9, i8* %key_known_to_survive_p, align 1
  %10 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %11 = load i64, i64* %i, align 8
  %call10 = call i64 @HASH_VALUE(%struct.Lisp_Hash_Table* %10, i64 %11)
  %call11 = call zeroext i1 @survives_gc_p(i64 %call10)
  %frombool12 = zext i1 %call11 to i8
  store i8 %frombool12, i8* %value_known_to_survive_p, align 1
  %12 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %weak = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %12, i32 0, i32 1
  %13 = load i64, i64* %weak, align 8
  %call13 = call i64 @builtin_lisp_symbol(i32 586)
  %cmp14 = icmp eq i64 %13, %call13
  br i1 %cmp14, label %if.then, label %if.else

if.then:                                          ; preds = %for.body.6
  %14 = load i8, i8* %key_known_to_survive_p, align 1
  %tobool = trunc i8 %14 to i1
  %lnot15 = xor i1 %tobool, true
  %frombool16 = zext i1 %lnot15 to i8
  store i8 %frombool16, i8* %remove_p, align 1
  br label %if.end.45

if.else:                                          ; preds = %for.body.6
  %15 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %weak17 = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %15, i32 0, i32 1
  %16 = load i64, i64* %weak17, align 8
  %call18 = call i64 @builtin_lisp_symbol(i32 991)
  %cmp19 = icmp eq i64 %16, %call18
  br i1 %cmp19, label %if.then.20, label %if.else.24

if.then.20:                                       ; preds = %if.else
  %17 = load i8, i8* %value_known_to_survive_p, align 1
  %tobool21 = trunc i8 %17 to i1
  %lnot22 = xor i1 %tobool21, true
  %frombool23 = zext i1 %lnot22 to i8
  store i8 %frombool23, i8* %remove_p, align 1
  br label %if.end.44

if.else.24:                                       ; preds = %if.else
  %18 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %weak25 = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %18, i32 0, i32 1
  %19 = load i64, i64* %weak25, align 8
  %call26 = call i64 @builtin_lisp_symbol(i32 588)
  %cmp27 = icmp eq i64 %19, %call26
  br i1 %cmp27, label %if.then.28, label %if.else.33

if.then.28:                                       ; preds = %if.else.24
  %20 = load i8, i8* %key_known_to_survive_p, align 1
  %tobool29 = trunc i8 %20 to i1
  br i1 %tobool29, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.then.28
  %21 = load i8, i8* %value_known_to_survive_p, align 1
  %tobool30 = trunc i8 %21 to i1
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.then.28
  %22 = phi i1 [ true, %if.then.28 ], [ %tobool30, %lor.rhs ]
  %lnot31 = xor i1 %22, true
  %frombool32 = zext i1 %lnot31 to i8
  store i8 %frombool32, i8* %remove_p, align 1
  br label %if.end.43

if.else.33:                                       ; preds = %if.else.24
  %23 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %weak34 = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %23, i32 0, i32 1
  %24 = load i64, i64* %weak34, align 8
  %call35 = call i64 @builtin_lisp_symbol(i32 587)
  %cmp36 = icmp eq i64 %24, %call35
  br i1 %cmp36, label %if.then.37, label %if.else.42

if.then.37:                                       ; preds = %if.else.33
  %25 = load i8, i8* %key_known_to_survive_p, align 1
  %tobool38 = trunc i8 %25 to i1
  br i1 %tobool38, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %if.then.37
  %26 = load i8, i8* %value_known_to_survive_p, align 1
  %tobool39 = trunc i8 %26 to i1
  br label %land.end

land.end:                                         ; preds = %land.rhs, %if.then.37
  %27 = phi i1 [ false, %if.then.37 ], [ %tobool39, %land.rhs ]
  %lnot40 = xor i1 %27, true
  %frombool41 = zext i1 %lnot40 to i8
  store i8 %frombool41, i8* %remove_p, align 1
  br label %if.end

if.else.42:                                       ; preds = %if.else.33
  call void @emacs_abort() #8
  unreachable

if.end:                                           ; preds = %land.end
  br label %if.end.43

if.end.43:                                        ; preds = %if.end, %lor.end
  br label %if.end.44

if.end.44:                                        ; preds = %if.end.43, %if.then.20
  br label %if.end.45

if.end.45:                                        ; preds = %if.end.44, %if.then
  %28 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %29 = load i64, i64* %i, align 8
  %call46 = call i64 @HASH_NEXT(%struct.Lisp_Hash_Table* %28, i64 %29)
  store i64 %call46, i64* %next, align 8
  %30 = load i8, i8* %remove_entries_p.addr, align 1
  %tobool47 = trunc i8 %30 to i1
  br i1 %tobool47, label %if.then.48, label %if.else.63

if.then.48:                                       ; preds = %if.end.45
  %31 = load i8, i8* %remove_p, align 1
  %tobool49 = trunc i8 %31 to i1
  br i1 %tobool49, label %if.then.50, label %if.else.61

if.then.50:                                       ; preds = %if.then.48
  %32 = load i64, i64* %prev, align 8
  %call51 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp52 = icmp eq i64 %32, %call51
  br i1 %cmp52, label %if.then.53, label %if.else.54

if.then.53:                                       ; preds = %if.then.50
  %33 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %34 = load i64, i64* %bucket, align 8
  %35 = load i64, i64* %next, align 8
  call void @set_hash_index_slot(%struct.Lisp_Hash_Table* %33, i64 %34, i64 %35)
  br label %if.end.56

if.else.54:                                       ; preds = %if.then.50
  %36 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %37 = load i64, i64* %prev, align 8
  %shr55 = ashr i64 %37, 2
  %38 = load i64, i64* %next, align 8
  call void @set_hash_next_slot(%struct.Lisp_Hash_Table* %36, i64 %shr55, i64 %38)
  br label %if.end.56

if.end.56:                                        ; preds = %if.else.54, %if.then.53
  %39 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %40 = load i64, i64* %i, align 8
  %41 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %next_free = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %41, i32 0, i32 6
  %42 = load i64, i64* %next_free, align 8
  call void @set_hash_next_slot(%struct.Lisp_Hash_Table* %39, i64 %40, i64 %42)
  %43 = load i64, i64* %idx, align 8
  %44 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %next_free57 = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %44, i32 0, i32 6
  store i64 %43, i64* %next_free57, align 8
  %45 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %46 = load i64, i64* %i, align 8
  %call58 = call i64 @builtin_lisp_symbol(i32 0)
  call void @set_hash_key_slot(%struct.Lisp_Hash_Table* %45, i64 %46, i64 %call58)
  %47 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %48 = load i64, i64* %i, align 8
  %call59 = call i64 @builtin_lisp_symbol(i32 0)
  call void @set_hash_value_slot(%struct.Lisp_Hash_Table* %47, i64 %48, i64 %call59)
  %49 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %50 = load i64, i64* %i, align 8
  %call60 = call i64 @builtin_lisp_symbol(i32 0)
  call void @set_hash_hash_slot(%struct.Lisp_Hash_Table* %49, i64 %50, i64 %call60)
  %51 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %count = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %51, i32 0, i32 8
  %52 = load i64, i64* %count, align 8
  %dec = add nsw i64 %52, -1
  store i64 %dec, i64* %count, align 8
  br label %if.end.62

if.else.61:                                       ; preds = %if.then.48
  %53 = load i64, i64* %idx, align 8
  store i64 %53, i64* %prev, align 8
  br label %if.end.62

if.end.62:                                        ; preds = %if.else.61, %if.end.56
  br label %if.end.75

if.else.63:                                       ; preds = %if.end.45
  %54 = load i8, i8* %remove_p, align 1
  %tobool64 = trunc i8 %54 to i1
  br i1 %tobool64, label %if.end.74, label %if.then.65

if.then.65:                                       ; preds = %if.else.63
  %55 = load i8, i8* %key_known_to_survive_p, align 1
  %tobool66 = trunc i8 %55 to i1
  br i1 %tobool66, label %if.end.69, label %if.then.67

if.then.67:                                       ; preds = %if.then.65
  %56 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %57 = load i64, i64* %i, align 8
  %call68 = call i64 @HASH_KEY(%struct.Lisp_Hash_Table* %56, i64 %57)
  call void @mark_object(i64 %call68)
  store i8 1, i8* %marked, align 1
  br label %if.end.69

if.end.69:                                        ; preds = %if.then.67, %if.then.65
  %58 = load i8, i8* %value_known_to_survive_p, align 1
  %tobool70 = trunc i8 %58 to i1
  br i1 %tobool70, label %if.end.73, label %if.then.71

if.then.71:                                       ; preds = %if.end.69
  %59 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %60 = load i64, i64* %i, align 8
  %call72 = call i64 @HASH_VALUE(%struct.Lisp_Hash_Table* %59, i64 %60)
  call void @mark_object(i64 %call72)
  store i8 1, i8* %marked, align 1
  br label %if.end.73

if.end.73:                                        ; preds = %if.then.71, %if.end.69
  br label %if.end.74

if.end.74:                                        ; preds = %if.end.73, %if.else.63
  br label %if.end.75

if.end.75:                                        ; preds = %if.end.74, %if.end.62
  br label %for.inc

for.inc:                                          ; preds = %if.end.75
  %61 = load i64, i64* %next, align 8
  store i64 %61, i64* %idx, align 8
  br label %for.cond.3

for.end:                                          ; preds = %for.cond.3
  br label %for.inc.76

for.inc.76:                                       ; preds = %for.end
  %62 = load i64, i64* %bucket, align 8
  %inc = add nsw i64 %62, 1
  store i64 %inc, i64* %bucket, align 8
  br label %for.cond

for.end.77:                                       ; preds = %for.cond
  %63 = load i8, i8* %marked, align 1
  %tobool78 = trunc i8 %63 to i1
  ret i1 %tobool78
}

; Function Attrs: nounwind uwtable
define i64 @hash_string(i8* %ptr, i64 %len) #1 {
entry:
  %ptr.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %p = alloca i8*, align 8
  %end = alloca i8*, align 8
  %c = alloca i8, align 1
  %hash = alloca i64, align 8
  store i8* %ptr, i8** %ptr.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  %0 = load i8*, i8** %ptr.addr, align 8
  store i8* %0, i8** %p, align 8
  %1 = load i8*, i8** %p, align 8
  %2 = load i64, i64* %len.addr, align 8
  %add.ptr = getelementptr inbounds i8, i8* %1, i64 %2
  store i8* %add.ptr, i8** %end, align 8
  store i64 0, i64* %hash, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %3 = load i8*, i8** %p, align 8
  %4 = load i8*, i8** %end, align 8
  %cmp = icmp ne i8* %3, %4
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %5 = load i8*, i8** %p, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %5, i32 1
  store i8* %incdec.ptr, i8** %p, align 8
  %6 = load i8, i8* %5, align 1
  store i8 %6, i8* %c, align 1
  %7 = load i64, i64* %hash, align 8
  %8 = load i8, i8* %c, align 1
  %conv = zext i8 %8 to i64
  %call = call i64 @sxhash_combine(i64 %7, i64 %conv)
  store i64 %call, i64* %hash, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %9 = load i64, i64* %hash, align 8
  ret i64 %9
}

declare i64 @sxhash_combine(i64, i64) #2

; Function Attrs: nounwind uwtable
define i64 @sxhash(i64 %obj, i32 %depth) #1 {
entry:
  %retval = alloca i64, align 8
  %obj.addr = alloca i64, align 8
  %depth.addr = alloca i32, align 4
  %hash = alloca i64, align 8
  store i64 %obj, i64* %obj.addr, align 8
  store i32 %depth, i32* %depth.addr, align 4
  %0 = load i32, i32* %depth.addr, align 4
  %cmp = icmp sgt i32 %0, 3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i64 0, i64* %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load i64, i64* %obj.addr, align 8
  %and = and i64 %1, 7
  %conv = trunc i64 %and to i32
  switch i32 %conv, label %sw.default [
    i32 2, label %sw.bb
    i32 6, label %sw.bb
    i32 1, label %sw.bb.1
    i32 0, label %sw.bb.1
    i32 4, label %sw.bb.3
    i32 5, label %sw.bb.7
    i32 3, label %sw.bb.18
    i32 7, label %sw.bb.20
  ]

sw.bb:                                            ; preds = %if.end, %if.end
  %2 = load i64, i64* %obj.addr, align 8
  %call = call i64 @XUINT(i64 %2)
  store i64 %call, i64* %hash, align 8
  br label %sw.epilog

sw.bb.1:                                          ; preds = %if.end, %if.end
  %3 = load i64, i64* %obj.addr, align 8
  %call2 = call i64 @XUINT(i64 %3)
  store i64 %call2, i64* %hash, align 8
  br label %sw.epilog

sw.bb.3:                                          ; preds = %if.end
  %4 = load i64, i64* %obj.addr, align 8
  %call4 = call i8* @SSDATA(i64 %4)
  %5 = load i64, i64* %obj.addr, align 8
  %call5 = call i64 @SBYTES(i64 %5)
  %call6 = call i64 @sxhash_string(i8* %call4, i64 %call5)
  store i64 %call6, i64* %hash, align 8
  br label %sw.epilog

sw.bb.7:                                          ; preds = %if.end
  %6 = load i64, i64* %obj.addr, align 8
  %call8 = call zeroext i1 @VECTORP(i64 %6)
  br i1 %call8, label %if.then.9, label %if.else

if.then.9:                                        ; preds = %sw.bb.7
  %7 = load i64, i64* %obj.addr, align 8
  %8 = load i32, i32* %depth.addr, align 4
  %call10 = call i64 @sxhash_vector(i64 %7, i32 %8)
  store i64 %call10, i64* %hash, align 8
  br label %if.end.17

if.else:                                          ; preds = %sw.bb.7
  %9 = load i64, i64* %obj.addr, align 8
  %call11 = call zeroext i1 @BOOL_VECTOR_P(i64 %9)
  br i1 %call11, label %if.then.12, label %if.else.14

if.then.12:                                       ; preds = %if.else
  %10 = load i64, i64* %obj.addr, align 8
  %call13 = call i64 @sxhash_bool_vector(i64 %10)
  store i64 %call13, i64* %hash, align 8
  br label %if.end.16

if.else.14:                                       ; preds = %if.else
  %11 = load i64, i64* %obj.addr, align 8
  %call15 = call i64 @XUINT(i64 %11)
  store i64 %call15, i64* %hash, align 8
  br label %if.end.16

if.end.16:                                        ; preds = %if.else.14, %if.then.12
  br label %if.end.17

if.end.17:                                        ; preds = %if.end.16, %if.then.9
  br label %sw.epilog

sw.bb.18:                                         ; preds = %if.end
  %12 = load i64, i64* %obj.addr, align 8
  %13 = load i32, i32* %depth.addr, align 4
  %call19 = call i64 @sxhash_list(i64 %12, i32 %13)
  store i64 %call19, i64* %hash, align 8
  br label %sw.epilog

sw.bb.20:                                         ; preds = %if.end
  %14 = load i64, i64* %obj.addr, align 8
  %call21 = call double @XFLOAT_DATA(i64 %14)
  %call22 = call i64 @sxhash_float(double %call21)
  store i64 %call22, i64* %hash, align 8
  br label %sw.epilog

sw.default:                                       ; preds = %if.end
  call void @emacs_abort() #8
  unreachable

sw.epilog:                                        ; preds = %sw.bb.20, %sw.bb.18, %if.end.17, %sw.bb.3, %sw.bb.1, %sw.bb
  %15 = load i64, i64* %hash, align 8
  store i64 %15, i64* %retval
  br label %return

return:                                           ; preds = %sw.epilog, %if.then
  %16 = load i64, i64* %retval
  ret i64 %16
}

; Function Attrs: nounwind uwtable
define internal i64 @sxhash_string(i8* %ptr, i64 %len) #1 {
entry:
  %ptr.addr = alloca i8*, align 8
  %len.addr = alloca i64, align 8
  %hash = alloca i64, align 8
  store i8* %ptr, i8** %ptr.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  %0 = load i8*, i8** %ptr.addr, align 8
  %1 = load i64, i64* %len.addr, align 8
  %call = call i64 @hash_string(i8* %0, i64 %1)
  store i64 %call, i64* %hash, align 8
  %2 = load i64, i64* %hash, align 8
  %call1 = call i64 @SXHASH_REDUCE(i64 %2)
  ret i64 %call1
}

; Function Attrs: nounwind uwtable
define internal i64 @sxhash_vector(i64 %vec, i32 %depth) #1 {
entry:
  %vec.addr = alloca i64, align 8
  %depth.addr = alloca i32, align 4
  %hash = alloca i64, align 8
  %i = alloca i32, align 4
  %n = alloca i32, align 4
  %hash2 = alloca i64, align 8
  store i64 %vec, i64* %vec.addr, align 8
  store i32 %depth, i32* %depth.addr, align 4
  %0 = load i64, i64* %vec.addr, align 8
  %call = call i64 @ASIZE(i64 %0)
  store i64 %call, i64* %hash, align 8
  %1 = load i64, i64* %vec.addr, align 8
  %call1 = call i64 @ASIZE(i64 %1)
  %cmp = icmp slt i64 7, %call1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %2 = load i64, i64* %vec.addr, align 8
  %call2 = call i64 @ASIZE(i64 %2)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ 7, %cond.true ], [ %call2, %cond.false ]
  %conv = trunc i64 %cond to i32
  store i32 %conv, i32* %n, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %3 = load i32, i32* %i, align 4
  %4 = load i32, i32* %n, align 4
  %cmp3 = icmp slt i32 %3, %4
  br i1 %cmp3, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load i64, i64* %vec.addr, align 8
  %6 = load i32, i32* %i, align 4
  %conv5 = sext i32 %6 to i64
  %call6 = call i64 @AREF(i64 %5, i64 %conv5)
  %7 = load i32, i32* %depth.addr, align 4
  %add = add nsw i32 %7, 1
  %call7 = call i64 @sxhash(i64 %call6, i32 %add)
  store i64 %call7, i64* %hash2, align 8
  %8 = load i64, i64* %hash, align 8
  %9 = load i64, i64* %hash2, align 8
  %call8 = call i64 @sxhash_combine(i64 %8, i64 %9)
  store i64 %call8, i64* %hash, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i32, i32* %i, align 4
  %inc = add nsw i32 %10, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %11 = load i64, i64* %hash, align 8
  %call9 = call i64 @SXHASH_REDUCE(i64 %11)
  ret i64 %call9
}

; Function Attrs: nounwind uwtable
define internal i64 @sxhash_bool_vector(i64 %vec) #1 {
entry:
  %vec.addr = alloca i64, align 8
  %size = alloca i64, align 8
  %hash = alloca i64, align 8
  %i = alloca i32, align 4
  %n = alloca i32, align 4
  store i64 %vec, i64* %vec.addr, align 8
  %0 = load i64, i64* %vec.addr, align 8
  %call = call i64 @bool_vector_size(i64 %0)
  store i64 %call, i64* %size, align 8
  %1 = load i64, i64* %size, align 8
  store i64 %1, i64* %hash, align 8
  %2 = load i64, i64* %size, align 8
  %call1 = call i64 @bool_vector_words(i64 %2)
  %cmp = icmp slt i64 7, %call1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %3 = load i64, i64* %size, align 8
  %call2 = call i64 @bool_vector_words(i64 %3)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ 7, %cond.true ], [ %call2, %cond.false ]
  %conv = trunc i64 %cond to i32
  store i32 %conv, i32* %n, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %cond.end
  %4 = load i32, i32* %i, align 4
  %5 = load i32, i32* %n, align 4
  %cmp3 = icmp slt i32 %4, %5
  br i1 %cmp3, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load i64, i64* %hash, align 8
  %7 = load i32, i32* %i, align 4
  %idxprom = sext i32 %7 to i64
  %8 = load i64, i64* %vec.addr, align 8
  %call5 = call i64* @bool_vector_data(i64 %8)
  %arrayidx = getelementptr inbounds i64, i64* %call5, i64 %idxprom
  %9 = load i64, i64* %arrayidx, align 8
  %call6 = call i64 @sxhash_combine(i64 %6, i64 %9)
  store i64 %call6, i64* %hash, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load i32, i32* %i, align 4
  %inc = add nsw i32 %10, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %11 = load i64, i64* %hash, align 8
  %call7 = call i64 @SXHASH_REDUCE(i64 %11)
  ret i64 %call7
}

; Function Attrs: nounwind uwtable
define internal i64 @sxhash_list(i64 %list, i32 %depth) #1 {
entry:
  %list.addr = alloca i64, align 8
  %depth.addr = alloca i32, align 4
  %hash = alloca i64, align 8
  %i = alloca i32, align 4
  %hash2 = alloca i64, align 8
  %hash211 = alloca i64, align 8
  store i64 %list, i64* %list.addr, align 8
  store i32 %depth, i32* %depth.addr, align 4
  store i64 0, i64* %hash, align 8
  %0 = load i32, i32* %depth.addr, align 4
  %cmp = icmp slt i32 %0, 3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %1 = load i64, i64* %list.addr, align 8
  %and = and i64 %1, 7
  %conv = trunc i64 %and to i32
  %cmp1 = icmp eq i32 %conv, 3
  br i1 %cmp1, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond
  %2 = load i32, i32* %i, align 4
  %cmp3 = icmp slt i32 %2, 7
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond
  %3 = phi i1 [ false, %for.cond ], [ %cmp3, %land.rhs ]
  br i1 %3, label %for.body, label %for.end

for.body:                                         ; preds = %land.end
  %4 = load i64, i64* %list.addr, align 8
  %sub = sub nsw i64 %4, 3
  %5 = inttoptr i64 %sub to i8*
  %6 = bitcast i8* %5 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %6, i32 0, i32 0
  %7 = load i64, i64* %car, align 8
  %8 = load i32, i32* %depth.addr, align 4
  %add = add nsw i32 %8, 1
  %call = call i64 @sxhash(i64 %7, i32 %add)
  store i64 %call, i64* %hash2, align 8
  %9 = load i64, i64* %hash, align 8
  %10 = load i64, i64* %hash2, align 8
  %call5 = call i64 @sxhash_combine(i64 %9, i64 %10)
  store i64 %call5, i64* %hash, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %11 = load i64, i64* %list.addr, align 8
  %sub6 = sub nsw i64 %11, 3
  %12 = inttoptr i64 %sub6 to i8*
  %13 = bitcast i8* %12 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %13, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %14 = load i64, i64* %cdr, align 8
  store i64 %14, i64* %list.addr, align 8
  %15 = load i32, i32* %i, align 4
  %inc = add nsw i32 %15, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %land.end
  br label %if.end

if.end:                                           ; preds = %for.end, %entry
  %16 = load i64, i64* %list.addr, align 8
  %call7 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp8 = icmp eq i64 %16, %call7
  br i1 %cmp8, label %if.end.15, label %if.then.10

if.then.10:                                       ; preds = %if.end
  %17 = load i64, i64* %list.addr, align 8
  %18 = load i32, i32* %depth.addr, align 4
  %add12 = add nsw i32 %18, 1
  %call13 = call i64 @sxhash(i64 %17, i32 %add12)
  store i64 %call13, i64* %hash211, align 8
  %19 = load i64, i64* %hash, align 8
  %20 = load i64, i64* %hash211, align 8
  %call14 = call i64 @sxhash_combine(i64 %19, i64 %20)
  store i64 %call14, i64* %hash, align 8
  br label %if.end.15

if.end.15:                                        ; preds = %if.then.10, %if.end
  %21 = load i64, i64* %hash, align 8
  %call16 = call i64 @SXHASH_REDUCE(i64 %21)
  ret i64 %call16
}

; Function Attrs: nounwind uwtable
define internal i64 @sxhash_float(double %val) #1 {
entry:
  %val.addr = alloca double, align 8
  %hash = alloca i64, align 8
  %u = alloca %union.anon.3, align 8
  %i = alloca i32, align 4
  store double %val, double* %val.addr, align 8
  store i64 0, i64* %hash, align 8
  %0 = load double, double* %val.addr, align 8
  %val1 = bitcast %union.anon.3* %u to double*
  store double %0, double* %val1, align 8
  %val2 = bitcast %union.anon.3* %u to double*
  %add.ptr = getelementptr inbounds double, double* %val2, i64 1
  %1 = bitcast double* %add.ptr to i8*
  call void @llvm.memset.p0i8.i64(i8* %1, i8 0, i64 0, i32 8, i1 false)
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %2, 1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i64, i64* %hash, align 8
  %4 = load i32, i32* %i, align 4
  %idxprom = sext i32 %4 to i64
  %word = bitcast %union.anon.3* %u to [1 x i64]*
  %arrayidx = getelementptr inbounds [1 x i64], [1 x i64]* %word, i32 0, i64 %idxprom
  %5 = load i64, i64* %arrayidx, align 8
  %call = call i64 @sxhash_combine(i64 %3, i64 %5)
  store i64 %call, i64* %hash, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %6 = load i32, i32* %i, align 4
  %inc = add nsw i32 %6, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %7 = load i64, i64* %hash, align 8
  %call3 = call i64 @SXHASH_REDUCE(i64 %7)
  ret i64 %call3
}

; Function Attrs: nounwind uwtable
define i64 @Fsxhash(i64 %obj) #1 {
entry:
  %obj.addr = alloca i64, align 8
  %hash = alloca i64, align 8
  store i64 %obj, i64* %obj.addr, align 8
  %0 = load i64, i64* %obj.addr, align 8
  %call = call i64 @sxhash(i64 %0, i32 0)
  store i64 %call, i64* %hash, align 8
  %1 = load i64, i64* %hash, align 8
  %shl = shl i64 %1, 2
  %add = add i64 %shl, 2
  ret i64 %add
}

; Function Attrs: nounwind uwtable
define i64 @Fmake_hash_table(i64 %nargs, i64* %args) #1 {
entry:
  %nargs.addr = alloca i64, align 8
  %args.addr = alloca i64*, align 8
  %test = alloca i64, align 8
  %size = alloca i64, align 8
  %rehash_size = alloca i64, align 8
  %rehash_threshold = alloca i64, align 8
  %weak = alloca i64, align 8
  %testdesc = alloca %struct.hash_table_test, align 8
  %i = alloca i64, align 8
  %sa_avail = alloca i64, align 8
  %sa_count = alloca i64, align 8
  %sa_must_free = alloca i8, align 1
  %used = alloca i8*, align 8
  %prop = alloca i64, align 8
  store i64 %nargs, i64* %nargs.addr, align 8
  store i64* %args, i64** %args.addr, align 8
  store i64 16384, i64* %sa_avail, align 8
  %call = call i64 @SPECPDL_INDEX()
  store i64 %call, i64* %sa_count, align 8
  store i8 0, i8* %sa_must_free, align 1
  %0 = load i64, i64* %nargs.addr, align 8
  %mul = mul i64 %0, 1
  %1 = load i64, i64* %sa_avail, align 8
  %cmp = icmp ule i64 %mul, %1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load i64, i64* %nargs.addr, align 8
  %mul1 = mul i64 %2, 1
  %3 = load i64, i64* %sa_avail, align 8
  %sub = sub i64 %3, %mul1
  store i64 %sub, i64* %sa_avail, align 8
  %4 = load i64, i64* %nargs.addr, align 8
  %mul2 = mul i64 %4, 1
  %5 = alloca i8, i64 %mul2
  br label %cond.end

cond.false:                                       ; preds = %entry
  store i8 1, i8* %sa_must_free, align 1
  %6 = load i64, i64* %nargs.addr, align 8
  %mul3 = mul i64 %6, 1
  %call4 = call i8* @record_xmalloc(i64 %mul3)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i8* [ %5, %cond.true ], [ %call4, %cond.false ]
  store i8* %cond, i8** %used, align 8
  %7 = load i8*, i8** %used, align 8
  %8 = load i64, i64* %nargs.addr, align 8
  %mul5 = mul i64 %8, 1
  call void @llvm.memset.p0i8.i64(i8* %7, i8 0, i64 %mul5, i32 1, i1 false)
  %call6 = call i64 @builtin_lisp_symbol(i32 129)
  %9 = load i64, i64* %nargs.addr, align 8
  %10 = load i64*, i64** %args.addr, align 8
  %11 = load i8*, i8** %used, align 8
  %call7 = call i64 @get_key_arg(i64 %call6, i64 %9, i64* %10, i8* %11)
  store i64 %call7, i64* %i, align 8
  %12 = load i64, i64* %i, align 8
  %tobool = icmp ne i64 %12, 0
  br i1 %tobool, label %cond.true.8, label %cond.false.9

cond.true.8:                                      ; preds = %cond.end
  %13 = load i64, i64* %i, align 8
  %14 = load i64*, i64** %args.addr, align 8
  %arrayidx = getelementptr inbounds i64, i64* %14, i64 %13
  %15 = load i64, i64* %arrayidx, align 8
  br label %cond.end.11

cond.false.9:                                     ; preds = %cond.end
  %call10 = call i64 @builtin_lisp_symbol(i32 370)
  br label %cond.end.11

cond.end.11:                                      ; preds = %cond.false.9, %cond.true.8
  %cond12 = phi i64 [ %15, %cond.true.8 ], [ %call10, %cond.false.9 ]
  store i64 %cond12, i64* %test, align 8
  %16 = load i64, i64* %test, align 8
  %call13 = call i64 @builtin_lisp_symbol(i32 369)
  %cmp14 = icmp eq i64 %16, %call13
  br i1 %cmp14, label %if.then, label %if.else

if.then:                                          ; preds = %cond.end.11
  %17 = bitcast %struct.hash_table_test* %testdesc to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %17, i8* bitcast (%struct.hash_table_test* @hashtest_eq to i8*), i64 40, i32 8, i1 false)
  br label %if.end.41

if.else:                                          ; preds = %cond.end.11
  %18 = load i64, i64* %test, align 8
  %call15 = call i64 @builtin_lisp_symbol(i32 370)
  %cmp16 = icmp eq i64 %18, %call15
  br i1 %cmp16, label %if.then.17, label %if.else.18

if.then.17:                                       ; preds = %if.else
  %19 = bitcast %struct.hash_table_test* %testdesc to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %19, i8* bitcast (%struct.hash_table_test* @hashtest_eql to i8*), i64 40, i32 8, i1 false)
  br label %if.end.40

if.else.18:                                       ; preds = %if.else
  %20 = load i64, i64* %test, align 8
  %call19 = call i64 @builtin_lisp_symbol(i32 371)
  %cmp20 = icmp eq i64 %20, %call19
  br i1 %cmp20, label %if.then.21, label %if.else.22

if.then.21:                                       ; preds = %if.else.18
  %21 = bitcast %struct.hash_table_test* %testdesc to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %21, i8* bitcast (%struct.hash_table_test* @hashtest_equal to i8*), i64 40, i32 8, i1 false)
  br label %if.end.39

if.else.22:                                       ; preds = %if.else.18
  %22 = load i64, i64* %test, align 8
  %call23 = call i64 @builtin_lisp_symbol(i32 511)
  %call24 = call i64 @Fget(i64 %22, i64 %call23)
  store i64 %call24, i64* %prop, align 8
  %23 = load i64, i64* %prop, align 8
  %and = and i64 %23, 7
  %conv = trunc i64 %and to i32
  %cmp25 = icmp eq i32 %conv, 3
  br i1 %cmp25, label %lor.lhs.false, label %if.then.32

lor.lhs.false:                                    ; preds = %if.else.22
  %24 = load i64, i64* %prop, align 8
  %sub27 = sub nsw i64 %24, 3
  %25 = inttoptr i64 %sub27 to i8*
  %26 = bitcast i8* %25 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %26, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %27 = load i64, i64* %cdr, align 8
  %and28 = and i64 %27, 7
  %conv29 = trunc i64 %and28 to i32
  %cmp30 = icmp eq i32 %conv29, 3
  br i1 %cmp30, label %if.end, label %if.then.32

if.then.32:                                       ; preds = %lor.lhs.false, %if.else.22
  %28 = load i64, i64* %test, align 8
  call void @signal_error(i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.17, i32 0, i32 0), i64 %28) #8
  unreachable

if.end:                                           ; preds = %lor.lhs.false
  %29 = load i64, i64* %test, align 8
  %name = getelementptr inbounds %struct.hash_table_test, %struct.hash_table_test* %testdesc, i32 0, i32 0
  store i64 %29, i64* %name, align 8
  %30 = load i64, i64* %prop, align 8
  %sub33 = sub nsw i64 %30, 3
  %31 = inttoptr i64 %sub33 to i8*
  %32 = bitcast i8* %31 to %struct.Lisp_Cons*
  %car = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %32, i32 0, i32 0
  %33 = load i64, i64* %car, align 8
  %user_cmp_function = getelementptr inbounds %struct.hash_table_test, %struct.hash_table_test* %testdesc, i32 0, i32 2
  store i64 %33, i64* %user_cmp_function, align 8
  %34 = load i64, i64* %prop, align 8
  %sub34 = sub nsw i64 %34, 3
  %35 = inttoptr i64 %sub34 to i8*
  %36 = bitcast i8* %35 to %struct.Lisp_Cons*
  %u35 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %36, i32 0, i32 1
  %cdr36 = bitcast %union.anon* %u35 to i64*
  %37 = load i64, i64* %cdr36, align 8
  %sub37 = sub nsw i64 %37, 3
  %38 = inttoptr i64 %sub37 to i8*
  %39 = bitcast i8* %38 to %struct.Lisp_Cons*
  %car38 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %39, i32 0, i32 0
  %40 = load i64, i64* %car38, align 8
  %user_hash_function = getelementptr inbounds %struct.hash_table_test, %struct.hash_table_test* %testdesc, i32 0, i32 1
  store i64 %40, i64* %user_hash_function, align 8
  %hashfn = getelementptr inbounds %struct.hash_table_test, %struct.hash_table_test* %testdesc, i32 0, i32 4
  store i64 (%struct.hash_table_test*, i64)* @hashfn_user_defined, i64 (%struct.hash_table_test*, i64)** %hashfn, align 8
  %cmpfn = getelementptr inbounds %struct.hash_table_test, %struct.hash_table_test* %testdesc, i32 0, i32 3
  store i1 (%struct.hash_table_test*, i64, i64)* @cmpfn_user_defined, i1 (%struct.hash_table_test*, i64, i64)** %cmpfn, align 8
  br label %if.end.39

if.end.39:                                        ; preds = %if.end, %if.then.21
  br label %if.end.40

if.end.40:                                        ; preds = %if.end.39, %if.then.17
  br label %if.end.41

if.end.41:                                        ; preds = %if.end.40, %if.then
  %call42 = call i64 @builtin_lisp_symbol(i32 118)
  %41 = load i64, i64* %nargs.addr, align 8
  %42 = load i64*, i64** %args.addr, align 8
  %43 = load i8*, i8** %used, align 8
  %call43 = call i64 @get_key_arg(i64 %call42, i64 %41, i64* %42, i8* %43)
  store i64 %call43, i64* %i, align 8
  %44 = load i64, i64* %i, align 8
  %tobool44 = icmp ne i64 %44, 0
  br i1 %tobool44, label %cond.true.45, label %cond.false.47

cond.true.45:                                     ; preds = %if.end.41
  %45 = load i64, i64* %i, align 8
  %46 = load i64*, i64** %args.addr, align 8
  %arrayidx46 = getelementptr inbounds i64, i64* %46, i64 %45
  %47 = load i64, i64* %arrayidx46, align 8
  br label %cond.end.49

cond.false.47:                                    ; preds = %if.end.41
  %call48 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end.49

cond.end.49:                                      ; preds = %cond.false.47, %cond.true.45
  %cond50 = phi i64 [ %47, %cond.true.45 ], [ %call48, %cond.false.47 ]
  store i64 %cond50, i64* %size, align 8
  %48 = load i64, i64* %size, align 8
  %call51 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp52 = icmp eq i64 %48, %call51
  br i1 %cmp52, label %if.then.54, label %if.else.55

if.then.54:                                       ; preds = %cond.end.49
  store i64 262, i64* %size, align 8
  br label %if.end.66

if.else.55:                                       ; preds = %cond.end.49
  %49 = load i64, i64* %size, align 8
  %and56 = and i64 %49, 7
  %conv57 = trunc i64 %and56 to i32
  %and58 = and i32 %conv57, -5
  %cmp59 = icmp eq i32 %and58, 2
  br i1 %cmp59, label %lor.lhs.false.61, label %if.then.64

lor.lhs.false.61:                                 ; preds = %if.else.55
  %50 = load i64, i64* %size, align 8
  %shr = ashr i64 %50, 2
  %cmp62 = icmp slt i64 %shr, 0
  br i1 %cmp62, label %if.then.64, label %if.end.65

if.then.64:                                       ; preds = %lor.lhs.false.61, %if.else.55
  %51 = load i64, i64* %size, align 8
  call void @signal_error(i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.18, i32 0, i32 0), i64 %51) #8
  unreachable

if.end.65:                                        ; preds = %lor.lhs.false.61
  br label %if.end.66

if.end.66:                                        ; preds = %if.end.65, %if.then.54
  %call67 = call i64 @builtin_lisp_symbol(i32 103)
  %52 = load i64, i64* %nargs.addr, align 8
  %53 = load i64*, i64** %args.addr, align 8
  %54 = load i8*, i8** %used, align 8
  %call68 = call i64 @get_key_arg(i64 %call67, i64 %52, i64* %53, i8* %54)
  store i64 %call68, i64* %i, align 8
  %55 = load i64, i64* %i, align 8
  %tobool69 = icmp ne i64 %55, 0
  br i1 %tobool69, label %cond.true.70, label %cond.false.72

cond.true.70:                                     ; preds = %if.end.66
  %56 = load i64, i64* %i, align 8
  %57 = load i64*, i64** %args.addr, align 8
  %arrayidx71 = getelementptr inbounds i64, i64* %57, i64 %56
  %58 = load i64, i64* %arrayidx71, align 8
  br label %cond.end.74

cond.false.72:                                    ; preds = %if.end.66
  %call73 = call i64 @make_float(double 1.500000e+00)
  br label %cond.end.74

cond.end.74:                                      ; preds = %cond.false.72, %cond.true.70
  %cond75 = phi i64 [ %58, %cond.true.70 ], [ %call73, %cond.false.72 ]
  store i64 %cond75, i64* %rehash_size, align 8
  %59 = load i64, i64* %rehash_size, align 8
  %and76 = and i64 %59, 7
  %conv77 = trunc i64 %and76 to i32
  %and78 = and i32 %conv77, -5
  %cmp79 = icmp eq i32 %and78, 2
  br i1 %cmp79, label %land.lhs.true, label %lor.lhs.false.84

land.lhs.true:                                    ; preds = %cond.end.74
  %60 = load i64, i64* %rehash_size, align 8
  %shr81 = ashr i64 %60, 2
  %cmp82 = icmp slt i64 0, %shr81
  br i1 %cmp82, label %if.end.94, label %lor.lhs.false.84

lor.lhs.false.84:                                 ; preds = %land.lhs.true, %cond.end.74
  %61 = load i64, i64* %rehash_size, align 8
  %and85 = and i64 %61, 7
  %conv86 = trunc i64 %and85 to i32
  %cmp87 = icmp eq i32 %conv86, 7
  br i1 %cmp87, label %land.lhs.true.89, label %if.then.93

land.lhs.true.89:                                 ; preds = %lor.lhs.false.84
  %62 = load i64, i64* %rehash_size, align 8
  %call90 = call double @XFLOAT_DATA(i64 %62)
  %cmp91 = fcmp olt double 1.000000e+00, %call90
  br i1 %cmp91, label %if.end.94, label %if.then.93

if.then.93:                                       ; preds = %land.lhs.true.89, %lor.lhs.false.84
  %63 = load i64, i64* %rehash_size, align 8
  call void @signal_error(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.19, i32 0, i32 0), i64 %63) #8
  unreachable

if.end.94:                                        ; preds = %land.lhs.true.89, %land.lhs.true
  %call95 = call i64 @builtin_lisp_symbol(i32 104)
  %64 = load i64, i64* %nargs.addr, align 8
  %65 = load i64*, i64** %args.addr, align 8
  %66 = load i8*, i8** %used, align 8
  %call96 = call i64 @get_key_arg(i64 %call95, i64 %64, i64* %65, i8* %66)
  store i64 %call96, i64* %i, align 8
  %67 = load i64, i64* %i, align 8
  %tobool97 = icmp ne i64 %67, 0
  br i1 %tobool97, label %cond.true.98, label %cond.false.100

cond.true.98:                                     ; preds = %if.end.94
  %68 = load i64, i64* %i, align 8
  %69 = load i64*, i64** %args.addr, align 8
  %arrayidx99 = getelementptr inbounds i64, i64* %69, i64 %68
  %70 = load i64, i64* %arrayidx99, align 8
  br label %cond.end.102

cond.false.100:                                   ; preds = %if.end.94
  %call101 = call i64 @make_float(double 8.000000e-01)
  br label %cond.end.102

cond.end.102:                                     ; preds = %cond.false.100, %cond.true.98
  %cond103 = phi i64 [ %70, %cond.true.98 ], [ %call101, %cond.false.100 ]
  store i64 %cond103, i64* %rehash_threshold, align 8
  %71 = load i64, i64* %rehash_threshold, align 8
  %and104 = and i64 %71, 7
  %conv105 = trunc i64 %and104 to i32
  %cmp106 = icmp eq i32 %conv105, 7
  br i1 %cmp106, label %land.lhs.true.108, label %if.then.116

land.lhs.true.108:                                ; preds = %cond.end.102
  %72 = load i64, i64* %rehash_threshold, align 8
  %call109 = call double @XFLOAT_DATA(i64 %72)
  %cmp110 = fcmp olt double 0.000000e+00, %call109
  br i1 %cmp110, label %land.lhs.true.112, label %if.then.116

land.lhs.true.112:                                ; preds = %land.lhs.true.108
  %73 = load i64, i64* %rehash_threshold, align 8
  %call113 = call double @XFLOAT_DATA(i64 %73)
  %cmp114 = fcmp ole double %call113, 1.000000e+00
  br i1 %cmp114, label %if.end.117, label %if.then.116

if.then.116:                                      ; preds = %land.lhs.true.112, %land.lhs.true.108, %cond.end.102
  %74 = load i64, i64* %rehash_threshold, align 8
  call void @signal_error(i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.20, i32 0, i32 0), i64 %74) #8
  unreachable

if.end.117:                                       ; preds = %land.lhs.true.112
  %call118 = call i64 @builtin_lisp_symbol(i32 137)
  %75 = load i64, i64* %nargs.addr, align 8
  %76 = load i64*, i64** %args.addr, align 8
  %77 = load i8*, i8** %used, align 8
  %call119 = call i64 @get_key_arg(i64 %call118, i64 %75, i64* %76, i8* %77)
  store i64 %call119, i64* %i, align 8
  %78 = load i64, i64* %i, align 8
  %tobool120 = icmp ne i64 %78, 0
  br i1 %tobool120, label %cond.true.121, label %cond.false.123

cond.true.121:                                    ; preds = %if.end.117
  %79 = load i64, i64* %i, align 8
  %80 = load i64*, i64** %args.addr, align 8
  %arrayidx122 = getelementptr inbounds i64, i64* %80, i64 %79
  %81 = load i64, i64* %arrayidx122, align 8
  br label %cond.end.125

cond.false.123:                                   ; preds = %if.end.117
  %call124 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end.125

cond.end.125:                                     ; preds = %cond.false.123, %cond.true.121
  %cond126 = phi i64 [ %81, %cond.true.121 ], [ %call124, %cond.false.123 ]
  store i64 %cond126, i64* %weak, align 8
  %82 = load i64, i64* %weak, align 8
  %call127 = call i64 @builtin_lisp_symbol(i32 901)
  %cmp128 = icmp eq i64 %82, %call127
  br i1 %cmp128, label %if.then.130, label %if.end.132

if.then.130:                                      ; preds = %cond.end.125
  %call131 = call i64 @builtin_lisp_symbol(i32 587)
  store i64 %call131, i64* %weak, align 8
  br label %if.end.132

if.end.132:                                       ; preds = %if.then.130, %cond.end.125
  %83 = load i64, i64* %weak, align 8
  %call133 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp134 = icmp eq i64 %83, %call133
  br i1 %cmp134, label %if.end.153, label %land.lhs.true.136

land.lhs.true.136:                                ; preds = %if.end.132
  %84 = load i64, i64* %weak, align 8
  %call137 = call i64 @builtin_lisp_symbol(i32 586)
  %cmp138 = icmp eq i64 %84, %call137
  br i1 %cmp138, label %if.end.153, label %land.lhs.true.140

land.lhs.true.140:                                ; preds = %land.lhs.true.136
  %85 = load i64, i64* %weak, align 8
  %call141 = call i64 @builtin_lisp_symbol(i32 991)
  %cmp142 = icmp eq i64 %85, %call141
  br i1 %cmp142, label %if.end.153, label %land.lhs.true.144

land.lhs.true.144:                                ; preds = %land.lhs.true.140
  %86 = load i64, i64* %weak, align 8
  %call145 = call i64 @builtin_lisp_symbol(i32 588)
  %cmp146 = icmp eq i64 %86, %call145
  br i1 %cmp146, label %if.end.153, label %land.lhs.true.148

land.lhs.true.148:                                ; preds = %land.lhs.true.144
  %87 = load i64, i64* %weak, align 8
  %call149 = call i64 @builtin_lisp_symbol(i32 587)
  %cmp150 = icmp eq i64 %87, %call149
  br i1 %cmp150, label %if.end.153, label %if.then.152

if.then.152:                                      ; preds = %land.lhs.true.148
  %88 = load i64, i64* %weak, align 8
  call void @signal_error(i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.21, i32 0, i32 0), i64 %88) #8
  unreachable

if.end.153:                                       ; preds = %land.lhs.true.148, %land.lhs.true.144, %land.lhs.true.140, %land.lhs.true.136, %if.end.132
  store i64 0, i64* %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end.153
  %89 = load i64, i64* %i, align 8
  %90 = load i64, i64* %nargs.addr, align 8
  %cmp154 = icmp slt i64 %89, %90
  br i1 %cmp154, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %91 = load i64, i64* %i, align 8
  %92 = load i8*, i8** %used, align 8
  %arrayidx156 = getelementptr inbounds i8, i8* %92, i64 %91
  %93 = load i8, i8* %arrayidx156, align 1
  %tobool157 = icmp ne i8 %93, 0
  br i1 %tobool157, label %if.end.160, label %if.then.158

if.then.158:                                      ; preds = %for.body
  %94 = load i64, i64* %i, align 8
  %95 = load i64*, i64** %args.addr, align 8
  %arrayidx159 = getelementptr inbounds i64, i64* %95, i64 %94
  %96 = load i64, i64* %arrayidx159, align 8
  call void @signal_error(i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.22, i32 0, i32 0), i64 %96) #8
  unreachable

if.end.160:                                       ; preds = %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end.160
  %97 = load i64, i64* %i, align 8
  %inc = add nsw i64 %97, 1
  store i64 %inc, i64* %i, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %do.body

do.body:                                          ; preds = %for.end
  %98 = load i8, i8* %sa_must_free, align 1
  %tobool161 = trunc i8 %98 to i1
  br i1 %tobool161, label %if.then.162, label %if.end.165

if.then.162:                                      ; preds = %do.body
  store i8 0, i8* %sa_must_free, align 1
  %99 = load i64, i64* %sa_count, align 8
  %call163 = call i64 @builtin_lisp_symbol(i32 0)
  %call164 = call i64 @unbind_to(i64 %99, i64 %call163)
  br label %if.end.165

if.end.165:                                       ; preds = %if.then.162, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end.165
  %100 = load i64, i64* %size, align 8
  %101 = load i64, i64* %rehash_size, align 8
  %102 = load i64, i64* %rehash_threshold, align 8
  %103 = load i64, i64* %weak, align 8
  %call166 = call i64 @make_hash_table(%struct.hash_table_test* byval align 8 %testdesc, i64 %100, i64 %101, i64 %102, i64 %103)
  ret i64 %call166
}

; Function Attrs: nounwind uwtable
define internal i64 @get_key_arg(i64 %key, i64 %nargs, i64* %args, i8* %used) #1 {
entry:
  %retval = alloca i64, align 8
  %key.addr = alloca i64, align 8
  %nargs.addr = alloca i64, align 8
  %args.addr = alloca i64*, align 8
  %used.addr = alloca i8*, align 8
  %i = alloca i64, align 8
  store i64 %key, i64* %key.addr, align 8
  store i64 %nargs, i64* %nargs.addr, align 8
  store i64* %args, i64** %args.addr, align 8
  store i8* %used, i8** %used.addr, align 8
  store i64 1, i64* %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i64, i64* %i, align 8
  %1 = load i64, i64* %nargs.addr, align 8
  %cmp = icmp slt i64 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i64, i64* %i, align 8
  %sub = sub nsw i64 %2, 1
  %3 = load i8*, i8** %used.addr, align 8
  %arrayidx = getelementptr inbounds i8, i8* %3, i64 %sub
  %4 = load i8, i8* %arrayidx, align 1
  %tobool = icmp ne i8 %4, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %5 = load i64, i64* %i, align 8
  %sub1 = sub nsw i64 %5, 1
  %6 = load i64*, i64** %args.addr, align 8
  %arrayidx2 = getelementptr inbounds i64, i64* %6, i64 %sub1
  %7 = load i64, i64* %arrayidx2, align 8
  %8 = load i64, i64* %key.addr, align 8
  %cmp3 = icmp eq i64 %7, %8
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %9 = load i64, i64* %i, align 8
  %sub4 = sub nsw i64 %9, 1
  %10 = load i8*, i8** %used.addr, align 8
  %arrayidx5 = getelementptr inbounds i8, i8* %10, i64 %sub4
  store i8 1, i8* %arrayidx5, align 1
  %11 = load i64, i64* %i, align 8
  %12 = load i8*, i8** %used.addr, align 8
  %arrayidx6 = getelementptr inbounds i8, i8* %12, i64 %11
  store i8 1, i8* %arrayidx6, align 1
  %13 = load i64, i64* %i, align 8
  store i64 %13, i64* %retval
  br label %return

if.end:                                           ; preds = %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %14 = load i64, i64* %i, align 8
  %inc = add nsw i64 %14, 1
  store i64 %inc, i64* %i, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i64 0, i64* %retval
  br label %return

return:                                           ; preds = %for.end, %if.then
  %15 = load i64, i64* %retval
  ret i64 %15
}

; Function Attrs: noreturn
declare void @signal_error(i8*, i64) #3

; Function Attrs: nounwind uwtable
define internal i64 @hashfn_user_defined(%struct.hash_table_test* %ht, i64 %key) #1 {
entry:
  %ht.addr = alloca %struct.hash_table_test*, align 8
  %key.addr = alloca i64, align 8
  %hash = alloca i64, align 8
  store %struct.hash_table_test* %ht, %struct.hash_table_test** %ht.addr, align 8
  store i64 %key, i64* %key.addr, align 8
  %0 = load %struct.hash_table_test*, %struct.hash_table_test** %ht.addr, align 8
  %user_hash_function = getelementptr inbounds %struct.hash_table_test, %struct.hash_table_test* %0, i32 0, i32 1
  %1 = load i64, i64* %user_hash_function, align 8
  %2 = load i64, i64* %key.addr, align 8
  %call = call i64 @call1(i64 %1, i64 %2)
  store i64 %call, i64* %hash, align 8
  %3 = load %struct.hash_table_test*, %struct.hash_table_test** %ht.addr, align 8
  %4 = load i64, i64* %hash, align 8
  %call1 = call i64 @hashfn_eq(%struct.hash_table_test* %3, i64 %4)
  ret i64 %call1
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @cmpfn_user_defined(%struct.hash_table_test* %ht, i64 %key1, i64 %key2) #1 {
entry:
  %ht.addr = alloca %struct.hash_table_test*, align 8
  %key1.addr = alloca i64, align 8
  %key2.addr = alloca i64, align 8
  store %struct.hash_table_test* %ht, %struct.hash_table_test** %ht.addr, align 8
  store i64 %key1, i64* %key1.addr, align 8
  store i64 %key2, i64* %key2.addr, align 8
  %0 = load %struct.hash_table_test*, %struct.hash_table_test** %ht.addr, align 8
  %user_cmp_function = getelementptr inbounds %struct.hash_table_test, %struct.hash_table_test* %0, i32 0, i32 2
  %1 = load i64, i64* %user_cmp_function, align 8
  %2 = load i64, i64* %key1.addr, align 8
  %3 = load i64, i64* %key2.addr, align 8
  %call = call i64 @call2(i64 %1, i64 %2, i64 %3)
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %call, %call1
  %lnot = xor i1 %cmp, true
  ret i1 %lnot
}

; Function Attrs: nounwind uwtable
define i64 @Fcopy_hash_table(i64 %table) #1 {
entry:
  %table.addr = alloca i64, align 8
  store i64 %table, i64* %table.addr, align 8
  %0 = load i64, i64* %table.addr, align 8
  %call = call %struct.Lisp_Hash_Table* @check_hash_table(i64 %0)
  %call1 = call i64 @copy_hash_table(%struct.Lisp_Hash_Table* %call)
  ret i64 %call1
}

; Function Attrs: nounwind uwtable
define internal i64 @copy_hash_table(%struct.Lisp_Hash_Table* %h1) #1 {
entry:
  %h1.addr = alloca %struct.Lisp_Hash_Table*, align 8
  %table = alloca i64, align 8
  %h2 = alloca %struct.Lisp_Hash_Table*, align 8
  store %struct.Lisp_Hash_Table* %h1, %struct.Lisp_Hash_Table** %h1.addr, align 8
  %call = call %struct.Lisp_Hash_Table* @allocate_hash_table()
  store %struct.Lisp_Hash_Table* %call, %struct.Lisp_Hash_Table** %h2, align 8
  %0 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h2, align 8
  %1 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h1.addr, align 8
  %2 = bitcast %struct.Lisp_Hash_Table* %0 to i8*
  %3 = bitcast %struct.Lisp_Hash_Table* %1 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %2, i8* %3, i64 128, i32 8, i1 false)
  %4 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h1.addr, align 8
  %key_and_value = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %4, i32 0, i32 9
  %5 = load i64, i64* %key_and_value, align 8
  %call1 = call i64 @Fcopy_sequence(i64 %5)
  %6 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h2, align 8
  %key_and_value2 = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %6, i32 0, i32 9
  store i64 %call1, i64* %key_and_value2, align 8
  %7 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h1.addr, align 8
  %hash = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %7, i32 0, i32 4
  %8 = load i64, i64* %hash, align 8
  %call3 = call i64 @Fcopy_sequence(i64 %8)
  %9 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h2, align 8
  %hash4 = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %9, i32 0, i32 4
  store i64 %call3, i64* %hash4, align 8
  %10 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h1.addr, align 8
  %next = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %10, i32 0, i32 5
  %11 = load i64, i64* %next, align 8
  %call5 = call i64 @Fcopy_sequence(i64 %11)
  %12 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h2, align 8
  %next6 = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %12, i32 0, i32 5
  store i64 %call5, i64* %next6, align 8
  %13 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h1.addr, align 8
  %index = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %13, i32 0, i32 7
  %14 = load i64, i64* %index, align 8
  %call7 = call i64 @Fcopy_sequence(i64 %14)
  %15 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h2, align 8
  %index8 = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %15, i32 0, i32 7
  store i64 %call7, i64* %index8, align 8
  %16 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h2, align 8
  %17 = bitcast %struct.Lisp_Hash_Table* %16 to i8*
  %call9 = call i64 @make_lisp_ptr(i8* %17, i32 5)
  store i64 %call9, i64* %table, align 8
  %18 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h2, align 8
  %weak = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %18, i32 0, i32 1
  %19 = load i64, i64* %weak, align 8
  %call10 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %19, %call10
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %20 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** @weak_hash_tables, align 8
  %21 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h2, align 8
  %next_weak = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %21, i32 0, i32 11
  store %struct.Lisp_Hash_Table* %20, %struct.Lisp_Hash_Table** %next_weak, align 8
  %22 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h2, align 8
  store %struct.Lisp_Hash_Table* %22, %struct.Lisp_Hash_Table** @weak_hash_tables, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %23 = load i64, i64* %table, align 8
  ret i64 %23
}

; Function Attrs: nounwind uwtable
define internal %struct.Lisp_Hash_Table* @check_hash_table(i64 %obj) #1 {
entry:
  %obj.addr = alloca i64, align 8
  store i64 %obj, i64* %obj.addr, align 8
  %0 = load i64, i64* %obj.addr, align 8
  call void @CHECK_HASH_TABLE(i64 %0)
  %1 = load i64, i64* %obj.addr, align 8
  %call = call %struct.Lisp_Hash_Table* @XHASH_TABLE(i64 %1)
  ret %struct.Lisp_Hash_Table* %call
}

; Function Attrs: nounwind uwtable
define i64 @Fhash_table_count(i64 %table) #1 {
entry:
  %table.addr = alloca i64, align 8
  store i64 %table, i64* %table.addr, align 8
  %0 = load i64, i64* %table.addr, align 8
  %call = call %struct.Lisp_Hash_Table* @check_hash_table(i64 %0)
  %count = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %call, i32 0, i32 8
  %1 = load i64, i64* %count, align 8
  %shl = shl i64 %1, 2
  %add = add i64 %shl, 2
  ret i64 %add
}

; Function Attrs: nounwind uwtable
define i64 @Fhash_table_rehash_size(i64 %table) #1 {
entry:
  %table.addr = alloca i64, align 8
  store i64 %table, i64* %table.addr, align 8
  %0 = load i64, i64* %table.addr, align 8
  %call = call %struct.Lisp_Hash_Table* @check_hash_table(i64 %0)
  %rehash_size = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %call, i32 0, i32 2
  %1 = load i64, i64* %rehash_size, align 8
  ret i64 %1
}

; Function Attrs: nounwind uwtable
define i64 @Fhash_table_rehash_threshold(i64 %table) #1 {
entry:
  %table.addr = alloca i64, align 8
  store i64 %table, i64* %table.addr, align 8
  %0 = load i64, i64* %table.addr, align 8
  %call = call %struct.Lisp_Hash_Table* @check_hash_table(i64 %0)
  %rehash_threshold = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %call, i32 0, i32 3
  %1 = load i64, i64* %rehash_threshold, align 8
  ret i64 %1
}

; Function Attrs: nounwind uwtable
define i64 @Fhash_table_size(i64 %table) #1 {
entry:
  %table.addr = alloca i64, align 8
  %h = alloca %struct.Lisp_Hash_Table*, align 8
  store i64 %table, i64* %table.addr, align 8
  %0 = load i64, i64* %table.addr, align 8
  %call = call %struct.Lisp_Hash_Table* @check_hash_table(i64 %0)
  store %struct.Lisp_Hash_Table* %call, %struct.Lisp_Hash_Table** %h, align 8
  %1 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h, align 8
  %call1 = call i64 @HASH_TABLE_SIZE(%struct.Lisp_Hash_Table* %1)
  %shl = shl i64 %call1, 2
  %add = add i64 %shl, 2
  ret i64 %add
}

declare i64 @HASH_TABLE_SIZE(%struct.Lisp_Hash_Table*) #2

; Function Attrs: nounwind uwtable
define i64 @Fhash_table_test(i64 %table) #1 {
entry:
  %table.addr = alloca i64, align 8
  store i64 %table, i64* %table.addr, align 8
  %0 = load i64, i64* %table.addr, align 8
  %call = call %struct.Lisp_Hash_Table* @check_hash_table(i64 %0)
  %test = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %call, i32 0, i32 10
  %name = getelementptr inbounds %struct.hash_table_test, %struct.hash_table_test* %test, i32 0, i32 0
  %1 = load i64, i64* %name, align 8
  ret i64 %1
}

; Function Attrs: nounwind uwtable
define i64 @Fhash_table_weakness(i64 %table) #1 {
entry:
  %table.addr = alloca i64, align 8
  store i64 %table, i64* %table.addr, align 8
  %0 = load i64, i64* %table.addr, align 8
  %call = call %struct.Lisp_Hash_Table* @check_hash_table(i64 %0)
  %weak = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %call, i32 0, i32 1
  %1 = load i64, i64* %weak, align 8
  ret i64 %1
}

; Function Attrs: nounwind uwtable
define i64 @Fhash_table_p(i64 %obj) #1 {
entry:
  %obj.addr = alloca i64, align 8
  store i64 %obj, i64* %obj.addr, align 8
  %0 = load i64, i64* %obj.addr, align 8
  %call = call zeroext i1 @HASH_TABLE_P(i64 %0)
  br i1 %call, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %call1 = call i64 @builtin_lisp_symbol(i32 901)
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call2 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call1, %cond.true ], [ %call2, %cond.false ]
  ret i64 %cond
}

declare zeroext i1 @HASH_TABLE_P(i64) #2

; Function Attrs: nounwind uwtable
define i64 @Fclrhash(i64 %table) #1 {
entry:
  %table.addr = alloca i64, align 8
  store i64 %table, i64* %table.addr, align 8
  %0 = load i64, i64* %table.addr, align 8
  %call = call %struct.Lisp_Hash_Table* @check_hash_table(i64 %0)
  call void @hash_clear(%struct.Lisp_Hash_Table* %call)
  %1 = load i64, i64* %table.addr, align 8
  ret i64 %1
}

; Function Attrs: nounwind uwtable
define internal void @hash_clear(%struct.Lisp_Hash_Table* %h) #1 {
entry:
  %h.addr = alloca %struct.Lisp_Hash_Table*, align 8
  %i = alloca i64, align 8
  %size = alloca i64, align 8
  store %struct.Lisp_Hash_Table* %h, %struct.Lisp_Hash_Table** %h.addr, align 8
  %0 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %count = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %0, i32 0, i32 8
  %1 = load i64, i64* %count, align 8
  %cmp = icmp sgt i64 %1, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %call = call i64 @HASH_TABLE_SIZE(%struct.Lisp_Hash_Table* %2)
  store i64 %call, i64* %size, align 8
  store i64 0, i64* %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %3 = load i64, i64* %i, align 8
  %4 = load i64, i64* %size, align 8
  %cmp1 = icmp slt i64 %3, %4
  br i1 %cmp1, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %6 = load i64, i64* %i, align 8
  %7 = load i64, i64* %i, align 8
  %8 = load i64, i64* %size, align 8
  %sub = sub nsw i64 %8, 1
  %cmp2 = icmp slt i64 %7, %sub
  br i1 %cmp2, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  %9 = load i64, i64* %i, align 8
  %add = add nsw i64 %9, 1
  %shl = shl i64 %add, 2
  %add3 = add i64 %shl, 2
  br label %cond.end

cond.false:                                       ; preds = %for.body
  %call4 = call i64 @builtin_lisp_symbol(i32 0)
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %add3, %cond.true ], [ %call4, %cond.false ]
  call void @set_hash_next_slot(%struct.Lisp_Hash_Table* %5, i64 %6, i64 %cond)
  %10 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %11 = load i64, i64* %i, align 8
  %call5 = call i64 @builtin_lisp_symbol(i32 0)
  call void @set_hash_key_slot(%struct.Lisp_Hash_Table* %10, i64 %11, i64 %call5)
  %12 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %13 = load i64, i64* %i, align 8
  %call6 = call i64 @builtin_lisp_symbol(i32 0)
  call void @set_hash_value_slot(%struct.Lisp_Hash_Table* %12, i64 %13, i64 %call6)
  %14 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %15 = load i64, i64* %i, align 8
  %call7 = call i64 @builtin_lisp_symbol(i32 0)
  call void @set_hash_hash_slot(%struct.Lisp_Hash_Table* %14, i64 %15, i64 %call7)
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %16 = load i64, i64* %i, align 8
  %inc = add nsw i64 %16, 1
  store i64 %inc, i64* %i, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  store i64 0, i64* %i, align 8
  br label %for.cond.8

for.cond.8:                                       ; preds = %for.inc.14, %for.end
  %17 = load i64, i64* %i, align 8
  %18 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %index = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %18, i32 0, i32 7
  %19 = load i64, i64* %index, align 8
  %call9 = call i64 @ASIZE(i64 %19)
  %cmp10 = icmp slt i64 %17, %call9
  br i1 %cmp10, label %for.body.11, label %for.end.16

for.body.11:                                      ; preds = %for.cond.8
  %20 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %index12 = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %20, i32 0, i32 7
  %21 = load i64, i64* %index12, align 8
  %22 = load i64, i64* %i, align 8
  %call13 = call i64 @builtin_lisp_symbol(i32 0)
  call void @ASET(i64 %21, i64 %22, i64 %call13)
  br label %for.inc.14

for.inc.14:                                       ; preds = %for.body.11
  %23 = load i64, i64* %i, align 8
  %inc15 = add nsw i64 %23, 1
  store i64 %inc15, i64* %i, align 8
  br label %for.cond.8

for.end.16:                                       ; preds = %for.cond.8
  %24 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %next_free = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %24, i32 0, i32 6
  store i64 2, i64* %next_free, align 8
  %25 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %count17 = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %25, i32 0, i32 8
  store i64 0, i64* %count17, align 8
  br label %if.end

if.end:                                           ; preds = %for.end.16, %entry
  ret void
}

; Function Attrs: nounwind uwtable
define i64 @Fgethash(i64 %key, i64 %table, i64 %dflt) #1 {
entry:
  %key.addr = alloca i64, align 8
  %table.addr = alloca i64, align 8
  %dflt.addr = alloca i64, align 8
  %h = alloca %struct.Lisp_Hash_Table*, align 8
  %i = alloca i64, align 8
  store i64 %key, i64* %key.addr, align 8
  store i64 %table, i64* %table.addr, align 8
  store i64 %dflt, i64* %dflt.addr, align 8
  %0 = load i64, i64* %table.addr, align 8
  %call = call %struct.Lisp_Hash_Table* @check_hash_table(i64 %0)
  store %struct.Lisp_Hash_Table* %call, %struct.Lisp_Hash_Table** %h, align 8
  %1 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h, align 8
  %2 = load i64, i64* %key.addr, align 8
  %call1 = call i64 @hash_lookup(%struct.Lisp_Hash_Table* %1, i64 %2, i64* null)
  store i64 %call1, i64* %i, align 8
  %3 = load i64, i64* %i, align 8
  %cmp = icmp sge i64 %3, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %4 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h, align 8
  %5 = load i64, i64* %i, align 8
  %call2 = call i64 @HASH_VALUE(%struct.Lisp_Hash_Table* %4, i64 %5)
  br label %cond.end

cond.false:                                       ; preds = %entry
  %6 = load i64, i64* %dflt.addr, align 8
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %call2, %cond.true ], [ %6, %cond.false ]
  ret i64 %cond
}

declare i64 @HASH_VALUE(%struct.Lisp_Hash_Table*, i64) #2

; Function Attrs: nounwind uwtable
define i64 @Fputhash(i64 %key, i64 %value, i64 %table) #1 {
entry:
  %key.addr = alloca i64, align 8
  %value.addr = alloca i64, align 8
  %table.addr = alloca i64, align 8
  %h = alloca %struct.Lisp_Hash_Table*, align 8
  %i = alloca i64, align 8
  %hash = alloca i64, align 8
  store i64 %key, i64* %key.addr, align 8
  store i64 %value, i64* %value.addr, align 8
  store i64 %table, i64* %table.addr, align 8
  %0 = load i64, i64* %table.addr, align 8
  %call = call %struct.Lisp_Hash_Table* @check_hash_table(i64 %0)
  store %struct.Lisp_Hash_Table* %call, %struct.Lisp_Hash_Table** %h, align 8
  %1 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h, align 8
  %2 = load i64, i64* %key.addr, align 8
  %call1 = call i64 @hash_lookup(%struct.Lisp_Hash_Table* %1, i64 %2, i64* %hash)
  store i64 %call1, i64* %i, align 8
  %3 = load i64, i64* %i, align 8
  %cmp = icmp sge i64 %3, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %4 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h, align 8
  %5 = load i64, i64* %i, align 8
  %6 = load i64, i64* %value.addr, align 8
  call void @set_hash_value_slot(%struct.Lisp_Hash_Table* %4, i64 %5, i64 %6)
  br label %if.end

if.else:                                          ; preds = %entry
  %7 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h, align 8
  %8 = load i64, i64* %key.addr, align 8
  %9 = load i64, i64* %value.addr, align 8
  %10 = load i64, i64* %hash, align 8
  %call2 = call i64 @hash_put(%struct.Lisp_Hash_Table* %7, i64 %8, i64 %9, i64 %10)
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %11 = load i64, i64* %value.addr, align 8
  ret i64 %11
}

; Function Attrs: nounwind uwtable
define i64 @Fremhash(i64 %key, i64 %table) #1 {
entry:
  %key.addr = alloca i64, align 8
  %table.addr = alloca i64, align 8
  %h = alloca %struct.Lisp_Hash_Table*, align 8
  store i64 %key, i64* %key.addr, align 8
  store i64 %table, i64* %table.addr, align 8
  %0 = load i64, i64* %table.addr, align 8
  %call = call %struct.Lisp_Hash_Table* @check_hash_table(i64 %0)
  store %struct.Lisp_Hash_Table* %call, %struct.Lisp_Hash_Table** %h, align 8
  %1 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h, align 8
  %2 = load i64, i64* %key.addr, align 8
  call void @hash_remove_from_table(%struct.Lisp_Hash_Table* %1, i64 %2)
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  ret i64 %call1
}

; Function Attrs: nounwind uwtable
define i64 @Fmaphash(i64 %function, i64 %table) #1 {
entry:
  %function.addr = alloca i64, align 8
  %table.addr = alloca i64, align 8
  %h = alloca %struct.Lisp_Hash_Table*, align 8
  %i = alloca i64, align 8
  store i64 %function, i64* %function.addr, align 8
  store i64 %table, i64* %table.addr, align 8
  %0 = load i64, i64* %table.addr, align 8
  %call = call %struct.Lisp_Hash_Table* @check_hash_table(i64 %0)
  store %struct.Lisp_Hash_Table* %call, %struct.Lisp_Hash_Table** %h, align 8
  store i64 0, i64* %i, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i64, i64* %i, align 8
  %2 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h, align 8
  %call1 = call i64 @HASH_TABLE_SIZE(%struct.Lisp_Hash_Table* %2)
  %cmp = icmp slt i64 %1, %call1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h, align 8
  %4 = load i64, i64* %i, align 8
  %call2 = call i64 @HASH_HASH(%struct.Lisp_Hash_Table* %3, i64 %4)
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp4 = icmp eq i64 %call2, %call3
  br i1 %cmp4, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  %5 = load i64, i64* %function.addr, align 8
  %6 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h, align 8
  %7 = load i64, i64* %i, align 8
  %call5 = call i64 @HASH_KEY(%struct.Lisp_Hash_Table* %6, i64 %7)
  %8 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h, align 8
  %9 = load i64, i64* %i, align 8
  %call6 = call i64 @HASH_VALUE(%struct.Lisp_Hash_Table* %8, i64 %9)
  %call7 = call i64 @call2(i64 %5, i64 %call5, i64 %call6)
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %10 = load i64, i64* %i, align 8
  %inc = add nsw i64 %10, 1
  store i64 %inc, i64* %i, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call8 = call i64 @builtin_lisp_symbol(i32 0)
  ret i64 %call8
}

declare i64 @call2(i64, i64, i64) #2

; Function Attrs: nounwind uwtable
define i64 @Fdefine_hash_table_test(i64 %name, i64 %test, i64 %hash) #1 {
entry:
  %name.addr = alloca i64, align 8
  %test.addr = alloca i64, align 8
  %hash.addr = alloca i64, align 8
  store i64 %name, i64* %name.addr, align 8
  store i64 %test, i64* %test.addr, align 8
  store i64 %hash, i64* %hash.addr, align 8
  %0 = load i64, i64* %name.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 511)
  %1 = load i64, i64* %test.addr, align 8
  %2 = load i64, i64* %hash.addr, align 8
  %call1 = call i64 @list2(i64 %1, i64 %2)
  %call2 = call i64 @Fput(i64 %0, i64 %call, i64 %call1)
  ret i64 %call2
}

; Function Attrs: nounwind uwtable
define i64 @Fmd5(i64 %object, i64 %start, i64 %end, i64 %coding_system, i64 %noerror) #1 {
entry:
  %object.addr = alloca i64, align 8
  %start.addr = alloca i64, align 8
  %end.addr = alloca i64, align 8
  %coding_system.addr = alloca i64, align 8
  %noerror.addr = alloca i64, align 8
  store i64 %object, i64* %object.addr, align 8
  store i64 %start, i64* %start.addr, align 8
  store i64 %end, i64* %end.addr, align 8
  store i64 %coding_system, i64* %coding_system.addr, align 8
  store i64 %noerror, i64* %noerror.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 649)
  %0 = load i64, i64* %object.addr, align 8
  %1 = load i64, i64* %start.addr, align 8
  %2 = load i64, i64* %end.addr, align 8
  %3 = load i64, i64* %coding_system.addr, align 8
  %4 = load i64, i64* %noerror.addr, align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  %call2 = call i64 @secure_hash(i64 %call, i64 %0, i64 %1, i64 %2, i64 %3, i64 %4, i64 %call1)
  ret i64 %call2
}

; Function Attrs: nounwind uwtable
define internal i64 @secure_hash(i64 %algorithm, i64 %object, i64 %start, i64 %end, i64 %coding_system, i64 %noerror, i64 %binary) #1 {
entry:
  %retval = alloca i64, align 8
  %algorithm.addr = alloca i64, align 8
  %object.addr = alloca i64, align 8
  %start.addr = alloca i64, align 8
  %end.addr = alloca i64, align 8
  %coding_system.addr = alloca i64, align 8
  %noerror.addr = alloca i64, align 8
  %binary.addr = alloca i64, align 8
  %i = alloca i32, align 4
  %size = alloca i64, align 8
  %start_char = alloca i64, align 8
  %start_byte = alloca i64, align 8
  %end_char = alloca i64, align 8
  %end_byte = alloca i64, align 8
  %b = alloca i64, align 8
  %e = alloca i64, align 8
  %bp = alloca %struct.buffer*, align 8
  %temp = alloca i64, align 8
  %digest_size = alloca i32, align 4
  %hash_func = alloca i8* (i8*, i64, i8*)*, align 8
  %digest = alloca i64, align 8
  %prev = alloca %struct.buffer*, align 8
  %force_raw_text = alloca i8, align 1
  %val = alloca i64, align 8
  %.compoundliteral = alloca [4 x i64], align 8
  %p = alloca i8*, align 8
  %p_i = alloca i32, align 4
  store i64 %algorithm, i64* %algorithm.addr, align 8
  store i64 %object, i64* %object.addr, align 8
  store i64 %start, i64* %start.addr, align 8
  store i64 %end, i64* %end.addr, align 8
  store i64 %coding_system, i64* %coding_system.addr, align 8
  store i64 %noerror, i64* %noerror.addr, align 8
  store i64 %binary, i64* %binary.addr, align 8
  store i64 0, i64* %start_char, align 8
  store i64 0, i64* %end_char, align 8
  %0 = load i64, i64* %algorithm.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call = call i64 @builtin_lisp_symbol(i32 897)
  %1 = load i64, i64* %algorithm.addr, align 8
  %2 = call i64 @wrong_type_argument(i64 %call, i64 %1) #8
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %3, %cond.true
  %4 = load i64, i64* %object.addr, align 8
  %call2 = call zeroext i1 @STRINGP(i64 %4)
  br i1 %call2, label %if.then, label %if.else.44

if.then:                                          ; preds = %cond.end
  %5 = load i64, i64* %coding_system.addr, align 8
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp4 = icmp eq i64 %5, %call3
  br i1 %cmp4, label %if.then.6, label %if.end.11

if.then.6:                                        ; preds = %if.then
  %6 = load i64, i64* %object.addr, align 8
  %call7 = call zeroext i1 @STRING_MULTIBYTE(i64 %6)
  br i1 %call7, label %if.then.8, label %if.else

if.then.8:                                        ; preds = %if.then.6
  %call9 = call i64 @preferred_coding_system()
  store i64 %call9, i64* %coding_system.addr, align 8
  br label %if.end

if.else:                                          ; preds = %if.then.6
  %call10 = call i64 @builtin_lisp_symbol(i32 788)
  store i64 %call10, i64* %coding_system.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then.8
  br label %if.end.11

if.end.11:                                        ; preds = %if.end, %if.then
  %7 = load i64, i64* %coding_system.addr, align 8
  %call12 = call i64 @Fcoding_system_p(i64 %7)
  %call13 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp14 = icmp eq i64 %call12, %call13
  br i1 %cmp14, label %if.then.16, label %if.end.25

if.then.16:                                       ; preds = %if.end.11
  %8 = load i64, i64* %noerror.addr, align 8
  %call17 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp18 = icmp eq i64 %8, %call17
  br i1 %cmp18, label %if.else.22, label %if.then.20

if.then.20:                                       ; preds = %if.then.16
  %call21 = call i64 @builtin_lisp_symbol(i32 788)
  store i64 %call21, i64* %coding_system.addr, align 8
  br label %if.end.24

if.else.22:                                       ; preds = %if.then.16
  %call23 = call i64 @builtin_lisp_symbol(i32 278)
  %9 = load i64, i64* %coding_system.addr, align 8
  call void @xsignal1(i64 %call23, i64 %9) #8
  unreachable

if.end.24:                                        ; preds = %if.then.20
  br label %if.end.25

if.end.25:                                        ; preds = %if.end.24, %if.end.11
  %10 = load i64, i64* %object.addr, align 8
  %call26 = call zeroext i1 @STRING_MULTIBYTE(i64 %10)
  br i1 %call26, label %if.then.27, label %if.end.30

if.then.27:                                       ; preds = %if.end.25
  %11 = load i64, i64* %object.addr, align 8
  %12 = load i64, i64* %coding_system.addr, align 8
  %call28 = call i64 @builtin_lisp_symbol(i32 0)
  %call29 = call i64 @code_convert_string(i64 %11, i64 %12, i64 %call28, i1 zeroext true, i1 zeroext false, i1 zeroext true)
  store i64 %call29, i64* %object.addr, align 8
  br label %if.end.30

if.end.30:                                        ; preds = %if.then.27, %if.end.25
  %13 = load i64, i64* %object.addr, align 8
  %call31 = call i64 @SCHARS(i64 %13)
  store i64 %call31, i64* %size, align 8
  %14 = load i64, i64* %object.addr, align 8
  %15 = load i64, i64* %start.addr, align 8
  %16 = load i64, i64* %end.addr, align 8
  %17 = load i64, i64* %size, align 8
  call void @validate_subarray(i64 %14, i64 %15, i64 %16, i64 %17, i64* %start_char, i64* %end_char)
  %18 = load i64, i64* %start_char, align 8
  %tobool = icmp ne i64 %18, 0
  br i1 %tobool, label %cond.false.33, label %cond.true.32

cond.true.32:                                     ; preds = %if.end.30
  br label %cond.end.35

cond.false.33:                                    ; preds = %if.end.30
  %19 = load i64, i64* %object.addr, align 8
  %20 = load i64, i64* %start_char, align 8
  %call34 = call i64 @string_char_to_byte(i64 %19, i64 %20)
  br label %cond.end.35

cond.end.35:                                      ; preds = %cond.false.33, %cond.true.32
  %cond = phi i64 [ 0, %cond.true.32 ], [ %call34, %cond.false.33 ]
  store i64 %cond, i64* %start_byte, align 8
  %21 = load i64, i64* %end_char, align 8
  %22 = load i64, i64* %size, align 8
  %cmp36 = icmp eq i64 %21, %22
  br i1 %cmp36, label %cond.true.38, label %cond.false.40

cond.true.38:                                     ; preds = %cond.end.35
  %23 = load i64, i64* %object.addr, align 8
  %call39 = call i64 @SBYTES(i64 %23)
  br label %cond.end.42

cond.false.40:                                    ; preds = %cond.end.35
  %24 = load i64, i64* %object.addr, align 8
  %25 = load i64, i64* %end_char, align 8
  %call41 = call i64 @string_char_to_byte(i64 %24, i64 %25)
  br label %cond.end.42

cond.end.42:                                      ; preds = %cond.false.40, %cond.true.38
  %cond43 = phi i64 [ %call39, %cond.true.38 ], [ %call41, %cond.false.40 ]
  store i64 %cond43, i64* %end_byte, align 8
  br label %if.end.224

if.else.44:                                       ; preds = %cond.end
  %26 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  store %struct.buffer* %26, %struct.buffer** %prev, align 8
  call void @record_unwind_current_buffer()
  %27 = load i64, i64* %object.addr, align 8
  call void @CHECK_BUFFER(i64 %27)
  %28 = load i64, i64* %object.addr, align 8
  %call45 = call %struct.buffer* @XBUFFER(i64 %28)
  store %struct.buffer* %call45, %struct.buffer** %bp, align 8
  %29 = load %struct.buffer*, %struct.buffer** %bp, align 8
  call void @set_buffer_internal(%struct.buffer* %29)
  %30 = load i64, i64* %start.addr, align 8
  %call46 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp47 = icmp eq i64 %30, %call46
  br i1 %cmp47, label %if.then.49, label %if.else.50

if.then.49:                                       ; preds = %if.else.44
  %31 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv = getelementptr inbounds %struct.buffer, %struct.buffer* %31, i32 0, i32 77
  %32 = load i64, i64* %begv, align 8
  store i64 %32, i64* %b, align 8
  br label %if.end.72

if.else.50:                                       ; preds = %if.else.44
  br label %do.body

do.body:                                          ; preds = %if.else.50
  %33 = load i64, i64* %start.addr, align 8
  %and51 = and i64 %33, 7
  %conv52 = trunc i64 %and51 to i32
  %cmp53 = icmp eq i32 %conv52, 1
  br i1 %cmp53, label %land.lhs.true, label %if.else.61

land.lhs.true:                                    ; preds = %do.body
  %34 = load i64, i64* %start.addr, align 8
  %call55 = call i32 @XMISCTYPE(i64 %34)
  %cmp56 = icmp eq i32 %call55, 24236
  br i1 %cmp56, label %if.then.58, label %if.else.61

if.then.58:                                       ; preds = %land.lhs.true
  %35 = load i64, i64* %start.addr, align 8
  %call59 = call i64 @marker_position(i64 %35)
  %call60 = call i64 @make_natnum(i64 %call59)
  store i64 %call60, i64* %start.addr, align 8
  br label %if.end.71

if.else.61:                                       ; preds = %land.lhs.true, %do.body
  %36 = load i64, i64* %start.addr, align 8
  %and62 = and i64 %36, 7
  %conv63 = trunc i64 %and62 to i32
  %and64 = and i32 %conv63, -5
  %cmp65 = icmp eq i32 %and64, 2
  br i1 %cmp65, label %cond.true.67, label %cond.false.68

cond.true.67:                                     ; preds = %if.else.61
  br label %cond.end.70

cond.false.68:                                    ; preds = %if.else.61
  %call69 = call i64 @builtin_lisp_symbol(i32 558)
  %37 = load i64, i64* %start.addr, align 8
  %38 = call i64 @wrong_type_argument(i64 %call69, i64 %37) #8
  unreachable
                                                  ; No predecessors!
  br label %cond.end.70

cond.end.70:                                      ; preds = %39, %cond.true.67
  br label %if.end.71

if.end.71:                                        ; preds = %cond.end.70, %if.then.58
  br label %do.end

do.end:                                           ; preds = %if.end.71
  %40 = load i64, i64* %start.addr, align 8
  %shr = ashr i64 %40, 2
  store i64 %shr, i64* %b, align 8
  br label %if.end.72

if.end.72:                                        ; preds = %do.end, %if.then.49
  %41 = load i64, i64* %end.addr, align 8
  %call73 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp74 = icmp eq i64 %41, %call73
  br i1 %cmp74, label %if.then.76, label %if.else.77

if.then.76:                                       ; preds = %if.end.72
  %42 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv = getelementptr inbounds %struct.buffer, %struct.buffer* %42, i32 0, i32 79
  %43 = load i64, i64* %zv, align 8
  store i64 %43, i64* %e, align 8
  br label %if.end.103

if.else.77:                                       ; preds = %if.end.72
  br label %do.body.78

do.body.78:                                       ; preds = %if.else.77
  %44 = load i64, i64* %end.addr, align 8
  %and79 = and i64 %44, 7
  %conv80 = trunc i64 %and79 to i32
  %cmp81 = icmp eq i32 %conv80, 1
  br i1 %cmp81, label %land.lhs.true.83, label %if.else.90

land.lhs.true.83:                                 ; preds = %do.body.78
  %45 = load i64, i64* %end.addr, align 8
  %call84 = call i32 @XMISCTYPE(i64 %45)
  %cmp85 = icmp eq i32 %call84, 24236
  br i1 %cmp85, label %if.then.87, label %if.else.90

if.then.87:                                       ; preds = %land.lhs.true.83
  %46 = load i64, i64* %end.addr, align 8
  %call88 = call i64 @marker_position(i64 %46)
  %call89 = call i64 @make_natnum(i64 %call88)
  store i64 %call89, i64* %end.addr, align 8
  br label %if.end.100

if.else.90:                                       ; preds = %land.lhs.true.83, %do.body.78
  %47 = load i64, i64* %end.addr, align 8
  %and91 = and i64 %47, 7
  %conv92 = trunc i64 %and91 to i32
  %and93 = and i32 %conv92, -5
  %cmp94 = icmp eq i32 %and93, 2
  br i1 %cmp94, label %cond.true.96, label %cond.false.97

cond.true.96:                                     ; preds = %if.else.90
  br label %cond.end.99

cond.false.97:                                    ; preds = %if.else.90
  %call98 = call i64 @builtin_lisp_symbol(i32 558)
  %48 = load i64, i64* %end.addr, align 8
  %49 = call i64 @wrong_type_argument(i64 %call98, i64 %48) #8
  unreachable
                                                  ; No predecessors!
  br label %cond.end.99

cond.end.99:                                      ; preds = %50, %cond.true.96
  br label %if.end.100

if.end.100:                                       ; preds = %cond.end.99, %if.then.87
  br label %do.end.101

do.end.101:                                       ; preds = %if.end.100
  %51 = load i64, i64* %end.addr, align 8
  %shr102 = ashr i64 %51, 2
  store i64 %shr102, i64* %e, align 8
  br label %if.end.103

if.end.103:                                       ; preds = %do.end.101, %if.then.76
  %52 = load i64, i64* %b, align 8
  %53 = load i64, i64* %e, align 8
  %cmp104 = icmp sgt i64 %52, %53
  br i1 %cmp104, label %if.then.106, label %if.end.107

if.then.106:                                      ; preds = %if.end.103
  %54 = load i64, i64* %b, align 8
  store i64 %54, i64* %temp, align 8
  %55 = load i64, i64* %e, align 8
  store i64 %55, i64* %b, align 8
  %56 = load i64, i64* %temp, align 8
  store i64 %56, i64* %e, align 8
  br label %if.end.107

if.end.107:                                       ; preds = %if.then.106, %if.end.103
  %57 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %begv108 = getelementptr inbounds %struct.buffer, %struct.buffer* %57, i32 0, i32 77
  %58 = load i64, i64* %begv108, align 8
  %59 = load i64, i64* %b, align 8
  %cmp109 = icmp sle i64 %58, %59
  br i1 %cmp109, label %land.lhs.true.111, label %if.then.115

land.lhs.true.111:                                ; preds = %if.end.107
  %60 = load i64, i64* %e, align 8
  %61 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %zv112 = getelementptr inbounds %struct.buffer, %struct.buffer* %61, i32 0, i32 79
  %62 = load i64, i64* %zv112, align 8
  %cmp113 = icmp sle i64 %60, %62
  br i1 %cmp113, label %if.end.116, label %if.then.115

if.then.115:                                      ; preds = %land.lhs.true.111, %if.end.107
  %63 = load i64, i64* %start.addr, align 8
  %64 = load i64, i64* %end.addr, align 8
  call void @args_out_of_range(i64 %63, i64 %64) #8
  unreachable

if.end.116:                                       ; preds = %land.lhs.true.111
  %65 = load i64, i64* %coding_system.addr, align 8
  %call117 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp118 = icmp eq i64 %65, %call117
  br i1 %cmp118, label %if.then.120, label %if.end.216

if.then.120:                                      ; preds = %if.end.116
  %66 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 36), align 8
  %call121 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp122 = icmp eq i64 %66, %call121
  br i1 %cmp122, label %if.else.125, label %if.then.124

if.then.124:                                      ; preds = %if.then.120
  %67 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 36), align 8
  store i64 %67, i64* %coding_system.addr, align 8
  br label %if.end.201

if.else.125:                                      ; preds = %if.then.120
  store i8 0, i8* %force_raw_text, align 1
  %68 = load i64, i64* %object.addr, align 8
  %call126 = call %struct.buffer* @XBUFFER(i64 %68)
  %buffer_file_coding_system_ = getelementptr inbounds %struct.buffer, %struct.buffer* %call126, i32 0, i32 40
  %69 = load i64, i64* %buffer_file_coding_system_, align 8
  store i64 %69, i64* %coding_system.addr, align 8
  %70 = load i64, i64* %coding_system.addr, align 8
  %call127 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp128 = icmp eq i64 %70, %call127
  br i1 %cmp128, label %if.then.136, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else.125
  %call130 = call i64 @builtin_lisp_symbol(i32 221)
  %call131 = call i64 @builtin_lisp_symbol(i32 0)
  %call132 = call i64 @Flocal_variable_p(i64 %call130, i64 %call131)
  %call133 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp134 = icmp eq i64 %call132, %call133
  br i1 %cmp134, label %if.then.136, label %if.end.143

if.then.136:                                      ; preds = %lor.lhs.false, %if.else.125
  %call137 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call137, i64* %coding_system.addr, align 8
  %71 = load %struct.buffer*, %struct.buffer** @current_buffer, align 8
  %enable_multibyte_characters_ = getelementptr inbounds %struct.buffer, %struct.buffer* %71, i32 0, i32 39
  %72 = load i64, i64* %enable_multibyte_characters_, align 8
  %call138 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp139 = icmp eq i64 %72, %call138
  br i1 %cmp139, label %if.then.141, label %if.end.142

if.then.141:                                      ; preds = %if.then.136
  store i8 1, i8* %force_raw_text, align 1
  br label %if.end.142

if.end.142:                                       ; preds = %if.then.141, %if.then.136
  br label %if.end.143

if.end.143:                                       ; preds = %if.end.142, %lor.lhs.false
  %73 = load i64, i64* %coding_system.addr, align 8
  %call144 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp145 = icmp eq i64 %73, %call144
  br i1 %cmp145, label %land.lhs.true.147, label %if.end.171

land.lhs.true.147:                                ; preds = %if.end.143
  %74 = load i64, i64* %object.addr, align 8
  %call148 = call i64 @Fbuffer_file_name(i64 %74)
  %call149 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp150 = icmp eq i64 %call148, %call149
  br i1 %cmp150, label %if.end.171, label %if.then.152

if.then.152:                                      ; preds = %land.lhs.true.147
  %arrayinit.begin = getelementptr inbounds [4 x i64], [4 x i64]* %.compoundliteral, i64 0, i64 0
  %call153 = call i64 @builtin_lisp_symbol(i32 1040)
  store i64 %call153, i64* %arrayinit.begin
  %arrayinit.element = getelementptr inbounds i64, i64* %arrayinit.begin, i64 1
  %75 = load i64, i64* %start.addr, align 8
  store i64 %75, i64* %arrayinit.element
  %arrayinit.element154 = getelementptr inbounds i64, i64* %arrayinit.element, i64 1
  %76 = load i64, i64* %end.addr, align 8
  store i64 %76, i64* %arrayinit.element154
  %arrayinit.element155 = getelementptr inbounds i64, i64* %arrayinit.element154, i64 1
  %77 = load i64, i64* %object.addr, align 8
  %call156 = call i64 @Fbuffer_file_name(i64 %77)
  store i64 %call156, i64* %arrayinit.element155
  %arraydecay = getelementptr inbounds [4 x i64], [4 x i64]* %.compoundliteral, i32 0, i32 0
  %call157 = call i64 @Ffind_operation_coding_system(i64 4, i64* %arraydecay)
  store i64 %call157, i64* %val, align 8
  %78 = load i64, i64* %val, align 8
  %and158 = and i64 %78, 7
  %conv159 = trunc i64 %and158 to i32
  %cmp160 = icmp eq i32 %conv159, 3
  br i1 %cmp160, label %land.lhs.true.162, label %if.end.170

land.lhs.true.162:                                ; preds = %if.then.152
  %79 = load i64, i64* %val, align 8
  %sub = sub nsw i64 %79, 3
  %80 = inttoptr i64 %sub to i8*
  %81 = bitcast i8* %80 to %struct.Lisp_Cons*
  %u = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %81, i32 0, i32 1
  %cdr = bitcast %union.anon* %u to i64*
  %82 = load i64, i64* %cdr, align 8
  %call163 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp164 = icmp eq i64 %82, %call163
  br i1 %cmp164, label %if.end.170, label %if.then.166

if.then.166:                                      ; preds = %land.lhs.true.162
  %83 = load i64, i64* %val, align 8
  %sub167 = sub nsw i64 %83, 3
  %84 = inttoptr i64 %sub167 to i8*
  %85 = bitcast i8* %84 to %struct.Lisp_Cons*
  %u168 = getelementptr inbounds %struct.Lisp_Cons, %struct.Lisp_Cons* %85, i32 0, i32 1
  %cdr169 = bitcast %union.anon* %u168 to i64*
  %86 = load i64, i64* %cdr169, align 8
  store i64 %86, i64* %coding_system.addr, align 8
  br label %if.end.170

if.end.170:                                       ; preds = %if.then.166, %land.lhs.true.162, %if.then.152
  br label %if.end.171

if.end.171:                                       ; preds = %if.end.170, %land.lhs.true.147, %if.end.143
  %87 = load i64, i64* %coding_system.addr, align 8
  %call172 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp173 = icmp eq i64 %87, %call172
  br i1 %cmp173, label %land.lhs.true.175, label %if.end.184

land.lhs.true.175:                                ; preds = %if.end.171
  %88 = load i64, i64* %object.addr, align 8
  %call176 = call %struct.buffer* @XBUFFER(i64 %88)
  %buffer_file_coding_system_177 = getelementptr inbounds %struct.buffer, %struct.buffer* %call176, i32 0, i32 40
  %89 = load i64, i64* %buffer_file_coding_system_177, align 8
  %call178 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp179 = icmp eq i64 %89, %call178
  br i1 %cmp179, label %if.end.184, label %if.then.181

if.then.181:                                      ; preds = %land.lhs.true.175
  %90 = load i64, i64* %object.addr, align 8
  %call182 = call %struct.buffer* @XBUFFER(i64 %90)
  %buffer_file_coding_system_183 = getelementptr inbounds %struct.buffer, %struct.buffer* %call182, i32 0, i32 40
  %91 = load i64, i64* %buffer_file_coding_system_183, align 8
  store i64 %91, i64* %coding_system.addr, align 8
  br label %if.end.184

if.end.184:                                       ; preds = %if.then.181, %land.lhs.true.175, %if.end.171
  %92 = load i8, i8* %force_raw_text, align 1
  %tobool185 = trunc i8 %92 to i1
  br i1 %tobool185, label %if.end.196, label %land.lhs.true.186

land.lhs.true.186:                                ; preds = %if.end.184
  %93 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 264), align 8
  %call187 = call i64 @Ffboundp(i64 %93)
  %call188 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp189 = icmp eq i64 %call187, %call188
  br i1 %cmp189, label %if.end.196, label %if.then.191

if.then.191:                                      ; preds = %land.lhs.true.186
  %94 = load i64, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 264), align 8
  %95 = load i64, i64* %b, align 8
  %shl = shl i64 %95, 2
  %add = add i64 %shl, 2
  %96 = load i64, i64* %e, align 8
  %shl192 = shl i64 %96, 2
  %add193 = add i64 %shl192, 2
  %97 = load i64, i64* %coding_system.addr, align 8
  %call194 = call i64 @builtin_lisp_symbol(i32 0)
  %call195 = call i64 @call4(i64 %94, i64 %add, i64 %add193, i64 %97, i64 %call194)
  store i64 %call195, i64* %coding_system.addr, align 8
  br label %if.end.196

if.end.196:                                       ; preds = %if.then.191, %land.lhs.true.186, %if.end.184
  %98 = load i8, i8* %force_raw_text, align 1
  %tobool197 = trunc i8 %98 to i1
  br i1 %tobool197, label %if.then.198, label %if.end.200

if.then.198:                                      ; preds = %if.end.196
  %call199 = call i64 @builtin_lisp_symbol(i32 788)
  store i64 %call199, i64* %coding_system.addr, align 8
  br label %if.end.200

if.end.200:                                       ; preds = %if.then.198, %if.end.196
  br label %if.end.201

if.end.201:                                       ; preds = %if.end.200, %if.then.124
  %99 = load i64, i64* %coding_system.addr, align 8
  %call202 = call i64 @Fcoding_system_p(i64 %99)
  %call203 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp204 = icmp eq i64 %call202, %call203
  br i1 %cmp204, label %if.then.206, label %if.end.215

if.then.206:                                      ; preds = %if.end.201
  %100 = load i64, i64* %noerror.addr, align 8
  %call207 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp208 = icmp eq i64 %100, %call207
  br i1 %cmp208, label %if.else.212, label %if.then.210

if.then.210:                                      ; preds = %if.then.206
  %call211 = call i64 @builtin_lisp_symbol(i32 788)
  store i64 %call211, i64* %coding_system.addr, align 8
  br label %if.end.214

if.else.212:                                      ; preds = %if.then.206
  %call213 = call i64 @builtin_lisp_symbol(i32 278)
  %101 = load i64, i64* %coding_system.addr, align 8
  call void @xsignal1(i64 %call213, i64 %101) #8
  unreachable

if.end.214:                                       ; preds = %if.then.210
  br label %if.end.215

if.end.215:                                       ; preds = %if.end.214, %if.end.201
  br label %if.end.216

if.end.216:                                       ; preds = %if.end.215, %if.end.116
  %102 = load i64, i64* %b, align 8
  %103 = load i64, i64* %e, align 8
  %call217 = call i64 @make_buffer_string(i64 %102, i64 %103, i1 zeroext false)
  store i64 %call217, i64* %object.addr, align 8
  %104 = load %struct.buffer*, %struct.buffer** %prev, align 8
  call void @set_buffer_internal(%struct.buffer* %104)
  %105 = load %union.specbinding*, %union.specbinding** @specpdl_ptr, align 8
  %incdec.ptr = getelementptr inbounds %union.specbinding, %union.specbinding* %105, i32 -1
  store %union.specbinding* %incdec.ptr, %union.specbinding** @specpdl_ptr, align 8
  %106 = load i64, i64* %object.addr, align 8
  %call218 = call zeroext i1 @STRING_MULTIBYTE(i64 %106)
  br i1 %call218, label %if.then.219, label %if.end.222

if.then.219:                                      ; preds = %if.end.216
  %107 = load i64, i64* %object.addr, align 8
  %108 = load i64, i64* %coding_system.addr, align 8
  %call220 = call i64 @builtin_lisp_symbol(i32 0)
  %call221 = call i64 @code_convert_string(i64 %107, i64 %108, i64 %call220, i1 zeroext true, i1 zeroext false, i1 zeroext false)
  store i64 %call221, i64* %object.addr, align 8
  br label %if.end.222

if.end.222:                                       ; preds = %if.then.219, %if.end.216
  store i64 0, i64* %start_byte, align 8
  %109 = load i64, i64* %object.addr, align 8
  %call223 = call i64 @SBYTES(i64 %109)
  store i64 %call223, i64* %end_byte, align 8
  br label %if.end.224

if.end.224:                                       ; preds = %if.end.222, %cond.end.42
  %110 = load i64, i64* %algorithm.addr, align 8
  %call225 = call i64 @builtin_lisp_symbol(i32 649)
  %cmp226 = icmp eq i64 %110, %call225
  br i1 %cmp226, label %if.then.228, label %if.else.229

if.then.228:                                      ; preds = %if.end.224
  store i32 16, i32* %digest_size, align 4
  store i8* (i8*, i64, i8*)* @md5_buffer, i8* (i8*, i64, i8*)** %hash_func, align 8
  br label %if.end.262

if.else.229:                                      ; preds = %if.end.224
  %111 = load i64, i64* %algorithm.addr, align 8
  %call230 = call i64 @builtin_lisp_symbol(i32 856)
  %cmp231 = icmp eq i64 %111, %call230
  br i1 %cmp231, label %if.then.233, label %if.else.234

if.then.233:                                      ; preds = %if.else.229
  store i32 20, i32* %digest_size, align 4
  store i8* (i8*, i64, i8*)* @sha1_buffer, i8* (i8*, i64, i8*)** %hash_func, align 8
  br label %if.end.261

if.else.234:                                      ; preds = %if.else.229
  %112 = load i64, i64* %algorithm.addr, align 8
  %call235 = call i64 @builtin_lisp_symbol(i32 857)
  %cmp236 = icmp eq i64 %112, %call235
  br i1 %cmp236, label %if.then.238, label %if.else.239

if.then.238:                                      ; preds = %if.else.234
  store i32 28, i32* %digest_size, align 4
  store i8* (i8*, i64, i8*)* @sha224_buffer, i8* (i8*, i64, i8*)** %hash_func, align 8
  br label %if.end.260

if.else.239:                                      ; preds = %if.else.234
  %113 = load i64, i64* %algorithm.addr, align 8
  %call240 = call i64 @builtin_lisp_symbol(i32 858)
  %cmp241 = icmp eq i64 %113, %call240
  br i1 %cmp241, label %if.then.243, label %if.else.244

if.then.243:                                      ; preds = %if.else.239
  store i32 32, i32* %digest_size, align 4
  store i8* (i8*, i64, i8*)* @sha256_buffer, i8* (i8*, i64, i8*)** %hash_func, align 8
  br label %if.end.259

if.else.244:                                      ; preds = %if.else.239
  %114 = load i64, i64* %algorithm.addr, align 8
  %call245 = call i64 @builtin_lisp_symbol(i32 859)
  %cmp246 = icmp eq i64 %114, %call245
  br i1 %cmp246, label %if.then.248, label %if.else.249

if.then.248:                                      ; preds = %if.else.244
  store i32 48, i32* %digest_size, align 4
  store i8* (i8*, i64, i8*)* @sha384_buffer, i8* (i8*, i64, i8*)** %hash_func, align 8
  br label %if.end.258

if.else.249:                                      ; preds = %if.else.244
  %115 = load i64, i64* %algorithm.addr, align 8
  %call250 = call i64 @builtin_lisp_symbol(i32 860)
  %cmp251 = icmp eq i64 %115, %call250
  br i1 %cmp251, label %if.then.253, label %if.else.254

if.then.253:                                      ; preds = %if.else.249
  store i32 64, i32* %digest_size, align 4
  store i8* (i8*, i64, i8*)* @sha512_buffer, i8* (i8*, i64, i8*)** %hash_func, align 8
  br label %if.end.257

if.else.254:                                      ; preds = %if.else.249
  %116 = load i64, i64* %algorithm.addr, align 8
  %call255 = call i64 @Fsymbol_name(i64 %116)
  %call256 = call i8* @SDATA(i64 %call255)
  call void (i8*, ...) @error(i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.29, i32 0, i32 0), i8* %call256) #8
  unreachable

if.end.257:                                       ; preds = %if.then.253
  br label %if.end.258

if.end.258:                                       ; preds = %if.end.257, %if.then.248
  br label %if.end.259

if.end.259:                                       ; preds = %if.end.258, %if.then.243
  br label %if.end.260

if.end.260:                                       ; preds = %if.end.259, %if.then.238
  br label %if.end.261

if.end.261:                                       ; preds = %if.end.260, %if.then.233
  br label %if.end.262

if.end.262:                                       ; preds = %if.end.261, %if.then.228
  %117 = load i32, i32* %digest_size, align 4
  %mul = mul nsw i32 %117, 2
  %conv263 = sext i32 %mul to i64
  %call264 = call i64 @make_uninit_string(i64 %conv263)
  store i64 %call264, i64* %digest, align 8
  %118 = load i8* (i8*, i64, i8*)*, i8* (i8*, i64, i8*)** %hash_func, align 8
  %119 = load i64, i64* %object.addr, align 8
  %call265 = call i8* @SSDATA(i64 %119)
  %120 = load i64, i64* %start_byte, align 8
  %add.ptr = getelementptr inbounds i8, i8* %call265, i64 %120
  %121 = load i64, i64* %end_byte, align 8
  %122 = load i64, i64* %start_byte, align 8
  %sub266 = sub nsw i64 %121, %122
  %123 = load i64, i64* %digest, align 8
  %call267 = call i8* @SSDATA(i64 %123)
  %call268 = call i8* %118(i8* %add.ptr, i64 %sub266, i8* %call267)
  %124 = load i64, i64* %binary.addr, align 8
  %call269 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp270 = icmp eq i64 %124, %call269
  br i1 %cmp270, label %if.then.272, label %if.else.291

if.then.272:                                      ; preds = %if.end.262
  %125 = load i64, i64* %digest, align 8
  %call273 = call i8* @SDATA(i64 %125)
  store i8* %call273, i8** %p, align 8
  %126 = load i32, i32* %digest_size, align 4
  %sub274 = sub nsw i32 %126, 1
  store i32 %sub274, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then.272
  %127 = load i32, i32* %i, align 4
  %cmp275 = icmp sge i32 %127, 0
  br i1 %cmp275, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %128 = load i32, i32* %i, align 4
  %idxprom = sext i32 %128 to i64
  %129 = load i8*, i8** %p, align 8
  %arrayidx = getelementptr inbounds i8, i8* %129, i64 %idxprom
  %130 = load i8, i8* %arrayidx, align 1
  %conv277 = zext i8 %130 to i32
  store i32 %conv277, i32* %p_i, align 4
  %131 = load i32, i32* %p_i, align 4
  %shr278 = ashr i32 %131, 4
  %idxprom279 = sext i32 %shr278 to i64
  %arrayidx280 = getelementptr inbounds [16 x i8], [16 x i8]* @secure_hash.hexdigit, i32 0, i64 %idxprom279
  %132 = load i8, i8* %arrayidx280, align 1
  %133 = load i32, i32* %i, align 4
  %mul281 = mul nsw i32 2, %133
  %idxprom282 = sext i32 %mul281 to i64
  %134 = load i8*, i8** %p, align 8
  %arrayidx283 = getelementptr inbounds i8, i8* %134, i64 %idxprom282
  store i8 %132, i8* %arrayidx283, align 1
  %135 = load i32, i32* %p_i, align 4
  %and284 = and i32 %135, 15
  %idxprom285 = sext i32 %and284 to i64
  %arrayidx286 = getelementptr inbounds [16 x i8], [16 x i8]* @secure_hash.hexdigit, i32 0, i64 %idxprom285
  %136 = load i8, i8* %arrayidx286, align 1
  %137 = load i32, i32* %i, align 4
  %mul287 = mul nsw i32 2, %137
  %add288 = add nsw i32 %mul287, 1
  %idxprom289 = sext i32 %add288 to i64
  %138 = load i8*, i8** %p, align 8
  %arrayidx290 = getelementptr inbounds i8, i8* %138, i64 %idxprom289
  store i8 %136, i8* %arrayidx290, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %139 = load i32, i32* %i, align 4
  %dec = add nsw i32 %139, -1
  store i32 %dec, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %140 = load i64, i64* %digest, align 8
  store i64 %140, i64* %retval
  br label %return

if.else.291:                                      ; preds = %if.end.262
  %141 = load i64, i64* %digest, align 8
  %call292 = call i8* @SSDATA(i64 %141)
  %142 = load i32, i32* %digest_size, align 4
  %conv293 = sext i32 %142 to i64
  %call294 = call i64 @make_unibyte_string(i8* %call292, i64 %conv293)
  store i64 %call294, i64* %retval
  br label %return

return:                                           ; preds = %if.else.291, %for.end
  %143 = load i64, i64* %retval
  ret i64 %143
}

; Function Attrs: nounwind uwtable
define i64 @Fsecure_hash(i64 %algorithm, i64 %object, i64 %start, i64 %end, i64 %binary) #1 {
entry:
  %algorithm.addr = alloca i64, align 8
  %object.addr = alloca i64, align 8
  %start.addr = alloca i64, align 8
  %end.addr = alloca i64, align 8
  %binary.addr = alloca i64, align 8
  store i64 %algorithm, i64* %algorithm.addr, align 8
  store i64 %object, i64* %object.addr, align 8
  store i64 %start, i64* %start.addr, align 8
  store i64 %end, i64* %end.addr, align 8
  store i64 %binary, i64* %binary.addr, align 8
  %0 = load i64, i64* %algorithm.addr, align 8
  %1 = load i64, i64* %object.addr, align 8
  %2 = load i64, i64* %start.addr, align 8
  %3 = load i64, i64* %end.addr, align 8
  %call = call i64 @builtin_lisp_symbol(i32 0)
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  %4 = load i64, i64* %binary.addr, align 8
  %call2 = call i64 @secure_hash(i64 %0, i64 %1, i64 %2, i64 %3, i64 %call, i64 %call1, i64 %4)
  ret i64 %call2
}

; Function Attrs: nounwind uwtable
define void @syms_of_fns() #1 {
entry:
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Ssxhash to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* }* @Smake_hash_table to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Scopy_hash_table to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Shash_table_count to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Shash_table_rehash_size to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Shash_table_rehash_threshold to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Shash_table_size to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Shash_table_test to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Shash_table_weakness to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Shash_table_p to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sclrhash to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sgethash to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sputhash to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sremhash to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Smaphash to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sdefine_hash_table_test to %struct.Lisp_Subr*))
  call void @staticpro(i64* @string_char_byte_cache_string)
  %call = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call, i64* @string_char_byte_cache_string, align 8
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call1, i64* @require_nesting_list, align 8
  call void @staticpro(i64* @require_nesting_list)
  %call2 = call i64 @builtin_lisp_symbol(i32 1072)
  %call3 = call i64 @builtin_lisp_symbol(i32 0)
  %call4 = call i64 @Fset(i64 %call2, i64 %call3)
  br label %do.body

do.body:                                          ; preds = %entry
  call void @defvar_lisp(%struct.Lisp_Objfwd* @syms_of_fns.o_fwd, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str.23, i32 0, i32 0), i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 92))
  br label %do.end

do.end:                                           ; preds = %do.body
  %call5 = call i64 @builtin_lisp_symbol(i32 360)
  %call6 = call i64 @list1(i64 %call5)
  store i64 %call6, i64* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 92), align 8
  br label %do.body.7

do.body.7:                                        ; preds = %do.end
  call void @defvar_bool(%struct.Lisp_Boolfwd* @syms_of_fns.b_fwd, i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.str.24, i32 0, i32 0), i8* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 493))
  br label %do.end.8

do.end.8:                                         ; preds = %do.body.7
  store i8 1, i8* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 493), align 1
  br label %do.body.9

do.body.9:                                        ; preds = %do.end.8
  call void @defvar_bool(%struct.Lisp_Boolfwd* @syms_of_fns.b_fwd.25, i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.26, i32 0, i32 0), i8* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 494))
  br label %do.end.10

do.end.10:                                        ; preds = %do.body.9
  store i8 1, i8* getelementptr inbounds (%struct.emacs_globals, %struct.emacs_globals* @globals, i32 0, i32 494), align 1
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sidentity to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Srandom to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Slength to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Ssafe_length to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sstring_bytes to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sstring_equal to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64, i64, i64, i64, i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Scompare_strings to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sstring_lessp to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64, i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sstring_collate_lessp to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64, i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sstring_collate_equalp to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* }* @Sappend to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* }* @Sconcat to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* }* @Svconcat to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Scopy_sequence to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sstring_make_multibyte to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sstring_make_unibyte to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sstring_as_multibyte to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sstring_as_unibyte to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sstring_to_multibyte to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sstring_to_unibyte to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Scopy_alist to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Ssubstring to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Ssubstring_no_properties to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Snthcdr to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Snth to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Selt to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Smember to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Smemq to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Smemql to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sassq to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sassoc to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Srassq to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Srassoc to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sdelq to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sdelete to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Snreverse to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sreverse to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Ssort to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Splist_get to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sget to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Splist_put to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sput to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Slax_plist_get to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Slax_plist_put to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Seql to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sequal to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sequal_including_properties to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sfillarray to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sclear_string to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* }* @Snconc to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Smapcar to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Smapc to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Smapconcat to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Syes_or_no_p to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sload_average to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sfeaturep to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Srequire to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sprovide to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Splist_member to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Swidget_put to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Swidget_get to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64*)* }, i16, i16, i8*, i8*, i8* }* @Swidget_apply to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sbase64_encode_region to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sbase64_decode_region to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Sbase64_encode_string to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Sbase64_decode_string to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64, i64, i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Smd5 to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64, i64, i64, i64, i64)* }, i16, i16, i8*, i8*, i8* }* @Ssecure_hash to %struct.Lisp_Subr*))
  call void @defsubr(%struct.Lisp_Subr* bitcast ({ %struct.vectorlike_header, { i64 (i64)* }, i16, i16, i8*, i8*, i8* }* @Slocale_info to %struct.Lisp_Subr*))
  %call11 = call i64 @builtin_lisp_symbol(i32 369)
  store i64 %call11, i64* getelementptr inbounds (%struct.hash_table_test, %struct.hash_table_test* @hashtest_eq, i32 0, i32 0), align 8
  %call12 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call12, i64* getelementptr inbounds (%struct.hash_table_test, %struct.hash_table_test* @hashtest_eq, i32 0, i32 1), align 8
  %call13 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call13, i64* getelementptr inbounds (%struct.hash_table_test, %struct.hash_table_test* @hashtest_eq, i32 0, i32 2), align 8
  store i1 (%struct.hash_table_test*, i64, i64)* null, i1 (%struct.hash_table_test*, i64, i64)** getelementptr inbounds (%struct.hash_table_test, %struct.hash_table_test* @hashtest_eq, i32 0, i32 3), align 8
  store i64 (%struct.hash_table_test*, i64)* @hashfn_eq, i64 (%struct.hash_table_test*, i64)** getelementptr inbounds (%struct.hash_table_test, %struct.hash_table_test* @hashtest_eq, i32 0, i32 4), align 8
  %call14 = call i64 @builtin_lisp_symbol(i32 370)
  store i64 %call14, i64* getelementptr inbounds (%struct.hash_table_test, %struct.hash_table_test* @hashtest_eql, i32 0, i32 0), align 8
  %call15 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call15, i64* getelementptr inbounds (%struct.hash_table_test, %struct.hash_table_test* @hashtest_eql, i32 0, i32 1), align 8
  %call16 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call16, i64* getelementptr inbounds (%struct.hash_table_test, %struct.hash_table_test* @hashtest_eql, i32 0, i32 2), align 8
  store i1 (%struct.hash_table_test*, i64, i64)* @cmpfn_eql, i1 (%struct.hash_table_test*, i64, i64)** getelementptr inbounds (%struct.hash_table_test, %struct.hash_table_test* @hashtest_eql, i32 0, i32 3), align 8
  store i64 (%struct.hash_table_test*, i64)* @hashfn_eql, i64 (%struct.hash_table_test*, i64)** getelementptr inbounds (%struct.hash_table_test, %struct.hash_table_test* @hashtest_eql, i32 0, i32 4), align 8
  %call17 = call i64 @builtin_lisp_symbol(i32 371)
  store i64 %call17, i64* getelementptr inbounds (%struct.hash_table_test, %struct.hash_table_test* @hashtest_equal, i32 0, i32 0), align 8
  %call18 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call18, i64* getelementptr inbounds (%struct.hash_table_test, %struct.hash_table_test* @hashtest_equal, i32 0, i32 1), align 8
  %call19 = call i64 @builtin_lisp_symbol(i32 0)
  store i64 %call19, i64* getelementptr inbounds (%struct.hash_table_test, %struct.hash_table_test* @hashtest_equal, i32 0, i32 2), align 8
  store i1 (%struct.hash_table_test*, i64, i64)* @cmpfn_equal, i1 (%struct.hash_table_test*, i64, i64)** getelementptr inbounds (%struct.hash_table_test, %struct.hash_table_test* @hashtest_equal, i32 0, i32 3), align 8
  store i64 (%struct.hash_table_test*, i64)* @hashfn_equal, i64 (%struct.hash_table_test*, i64)** getelementptr inbounds (%struct.hash_table_test, %struct.hash_table_test* @hashtest_equal, i32 0, i32 4), align 8
  ret void
}

declare void @defsubr(%struct.Lisp_Subr*) #2

declare void @staticpro(i64*) #2

declare i64 @Fset(i64, i64) #2

declare void @defvar_lisp(%struct.Lisp_Objfwd*, i8*, i64*) #2

declare i64 @list1(i64) #2

declare void @defvar_bool(%struct.Lisp_Boolfwd*, i8*, i8*) #2

; Function Attrs: nounwind uwtable
define internal i64 @hashfn_eq(%struct.hash_table_test* %ht, i64 %key) #1 {
entry:
  %ht.addr = alloca %struct.hash_table_test*, align 8
  %key.addr = alloca i64, align 8
  %hash = alloca i64, align 8
  store %struct.hash_table_test* %ht, %struct.hash_table_test** %ht.addr, align 8
  store i64 %key, i64* %key.addr, align 8
  %0 = load i64, i64* %key.addr, align 8
  %call = call i64 @XUINT(i64 %0)
  %1 = load i64, i64* %key.addr, align 8
  %and = and i64 %1, 7
  %conv = trunc i64 %and to i32
  %conv1 = zext i32 %conv to i64
  %xor = xor i64 %call, %conv1
  store i64 %xor, i64* %hash, align 8
  %2 = load i64, i64* %hash, align 8
  ret i64 %2
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @cmpfn_eql(%struct.hash_table_test* %ht, i64 %key1, i64 %key2) #1 {
entry:
  %ht.addr = alloca %struct.hash_table_test*, align 8
  %key1.addr = alloca i64, align 8
  %key2.addr = alloca i64, align 8
  store %struct.hash_table_test* %ht, %struct.hash_table_test** %ht.addr, align 8
  store i64 %key1, i64* %key1.addr, align 8
  store i64 %key2, i64* %key2.addr, align 8
  %0 = load i64, i64* %key1.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 7
  br i1 %cmp, label %land.lhs.true, label %land.end

land.lhs.true:                                    ; preds = %entry
  %1 = load i64, i64* %key2.addr, align 8
  %and2 = and i64 %1, 7
  %conv3 = trunc i64 %and2 to i32
  %cmp4 = icmp eq i32 %conv3, 7
  br i1 %cmp4, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true
  %2 = load i64, i64* %key1.addr, align 8
  %call = call double @XFLOAT_DATA(i64 %2)
  %3 = load i64, i64* %key2.addr, align 8
  %call6 = call double @XFLOAT_DATA(i64 %3)
  %cmp7 = fcmp oeq double %call, %call6
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true, %entry
  %4 = phi i1 [ false, %land.lhs.true ], [ false, %entry ], [ %cmp7, %land.rhs ]
  ret i1 %4
}

; Function Attrs: nounwind uwtable
define internal i64 @hashfn_eql(%struct.hash_table_test* %ht, i64 %key) #1 {
entry:
  %ht.addr = alloca %struct.hash_table_test*, align 8
  %key.addr = alloca i64, align 8
  %hash = alloca i64, align 8
  store %struct.hash_table_test* %ht, %struct.hash_table_test** %ht.addr, align 8
  store i64 %key, i64* %key.addr, align 8
  %0 = load i64, i64* %key.addr, align 8
  %and = and i64 %0, 7
  %conv = trunc i64 %and to i32
  %cmp = icmp eq i32 %conv, 7
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i64, i64* %key.addr, align 8
  %call = call i64 @sxhash(i64 %1, i32 0)
  store i64 %call, i64* %hash, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %2 = load i64, i64* %key.addr, align 8
  %call2 = call i64 @XUINT(i64 %2)
  %3 = load i64, i64* %key.addr, align 8
  %and3 = and i64 %3, 7
  %conv4 = trunc i64 %and3 to i32
  %conv5 = zext i32 %conv4 to i64
  %xor = xor i64 %call2, %conv5
  store i64 %xor, i64* %hash, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %4 = load i64, i64* %hash, align 8
  ret i64 %4
}

; Function Attrs: nounwind uwtable
define internal zeroext i1 @cmpfn_equal(%struct.hash_table_test* %ht, i64 %key1, i64 %key2) #1 {
entry:
  %ht.addr = alloca %struct.hash_table_test*, align 8
  %key1.addr = alloca i64, align 8
  %key2.addr = alloca i64, align 8
  store %struct.hash_table_test* %ht, %struct.hash_table_test** %ht.addr, align 8
  store i64 %key1, i64* %key1.addr, align 8
  store i64 %key2, i64* %key2.addr, align 8
  %0 = load i64, i64* %key1.addr, align 8
  %1 = load i64, i64* %key2.addr, align 8
  %call = call i64 @Fequal(i64 %0, i64 %1)
  %call1 = call i64 @builtin_lisp_symbol(i32 0)
  %cmp = icmp eq i64 %call, %call1
  %lnot = xor i1 %cmp, true
  ret i1 %lnot
}

; Function Attrs: nounwind uwtable
define internal i64 @hashfn_equal(%struct.hash_table_test* %ht, i64 %key) #1 {
entry:
  %ht.addr = alloca %struct.hash_table_test*, align 8
  %key.addr = alloca i64, align 8
  %hash = alloca i64, align 8
  store %struct.hash_table_test* %ht, %struct.hash_table_test** %ht.addr, align 8
  store i64 %key, i64* %key.addr, align 8
  %0 = load i64, i64* %key.addr, align 8
  %call = call i64 @sxhash(i64 %0, i32 0)
  store i64 %call, i64* %hash, align 8
  %1 = load i64, i64* %hash, align 8
  ret i64 %1
}

; Function Attrs: noreturn
declare void @string_overflow() #3

declare i64 @Fmake_list(i64, i64) #2

declare noalias i8* @xnmalloc(i64, i64) #2

declare void @record_unwind_protect_ptr(void (i8*)*, i8*) #2

declare %struct.interval* @string_intervals(i64) #2

declare i64 @bool_vector_ref(i64, i64) #2

declare i64 @text_property_list(i64, i64, i64, i64) #2

declare void @make_composition_value_copy(i64) #2

declare void @add_text_properties_from_list(i64, i64, i64) #2

; Function Attrs: nounwind uwtable
define internal void @sort_vector_inplace(i64 %pred, i64 %len, i64* noalias nonnull %vec, i64* noalias nonnull %tmp) #1 {
entry:
  %pred.addr = alloca i64, align 8
  %len.addr = alloca i64, align 8
  %vec.addr = alloca i64*, align 8
  %tmp.addr = alloca i64*, align 8
  %halflen = alloca i64, align 8
  store i64 %pred, i64* %pred.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i64* %vec, i64** %vec.addr, align 8
  store i64* %tmp, i64** %tmp.addr, align 8
  %0 = load i64, i64* %len.addr, align 8
  %1 = load i64, i64* %len.addr, align 8
  %shr = ashr i64 %1, 1
  %2 = load i64, i64* %len.addr, align 8
  %cmp = icmp sle i64 2, %2
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  unreachable

unreachable.cont:                                 ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %unreachable.cont, %cond.true
  %3 = load i64, i64* %len.addr, align 8
  %shr2 = ashr i64 %3, 1
  store i64 %shr2, i64* %halflen, align 8
  %4 = load i64, i64* %pred.addr, align 8
  %5 = load i64, i64* %halflen, align 8
  %6 = load i64*, i64** %vec.addr, align 8
  %7 = load i64*, i64** %tmp.addr, align 8
  call void @sort_vector_copy(i64 %4, i64 %5, i64* %6, i64* %7)
  %8 = load i64, i64* %len.addr, align 8
  %9 = load i64, i64* %halflen, align 8
  %sub = sub nsw i64 %8, %9
  %cmp3 = icmp slt i64 1, %sub
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  %10 = load i64, i64* %pred.addr, align 8
  %11 = load i64, i64* %len.addr, align 8
  %12 = load i64, i64* %halflen, align 8
  %sub4 = sub nsw i64 %11, %12
  %13 = load i64*, i64** %vec.addr, align 8
  %14 = load i64, i64* %halflen, align 8
  %add.ptr = getelementptr inbounds i64, i64* %13, i64 %14
  %15 = load i64*, i64** %vec.addr, align 8
  call void @sort_vector_inplace(i64 %10, i64 %sub4, i64* %add.ptr, i64* %15)
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end
  %16 = load i64, i64* %pred.addr, align 8
  %17 = load i64, i64* %halflen, align 8
  %18 = load i64*, i64** %tmp.addr, align 8
  %19 = load i64, i64* %len.addr, align 8
  %20 = load i64, i64* %halflen, align 8
  %sub5 = sub nsw i64 %19, %20
  %21 = load i64*, i64** %vec.addr, align 8
  %22 = load i64, i64* %halflen, align 8
  %add.ptr6 = getelementptr inbounds i64, i64* %21, i64 %22
  %23 = load i64*, i64** %vec.addr, align 8
  call void @merge_vectors(i64 %16, i64 %17, i64* %18, i64 %sub5, i64* %add.ptr6, i64* %23)
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @sort_vector_copy(i64 %pred, i64 %len, i64* noalias nonnull %src, i64* noalias nonnull %dest) #1 {
entry:
  %pred.addr = alloca i64, align 8
  %len.addr = alloca i64, align 8
  %src.addr = alloca i64*, align 8
  %dest.addr = alloca i64*, align 8
  %halflen = alloca i64, align 8
  store i64 %pred, i64* %pred.addr, align 8
  store i64 %len, i64* %len.addr, align 8
  store i64* %src, i64** %src.addr, align 8
  store i64* %dest, i64** %dest.addr, align 8
  %0 = load i64, i64* %len.addr, align 8
  %1 = load i64, i64* %len.addr, align 8
  %2 = load i64, i64* %len.addr, align 8
  %cmp = icmp slt i64 0, %2
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  unreachable

unreachable.cont:                                 ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %unreachable.cont, %cond.true
  %3 = load i64, i64* %len.addr, align 8
  %shr = ashr i64 %3, 1
  store i64 %shr, i64* %halflen, align 8
  %4 = load i64, i64* %halflen, align 8
  %cmp1 = icmp slt i64 %4, 1
  br i1 %cmp1, label %if.then, label %if.else

if.then:                                          ; preds = %cond.end
  %5 = load i64*, i64** %src.addr, align 8
  %arrayidx = getelementptr inbounds i64, i64* %5, i64 0
  %6 = load i64, i64* %arrayidx, align 8
  %7 = load i64*, i64** %dest.addr, align 8
  %arrayidx2 = getelementptr inbounds i64, i64* %7, i64 0
  store i64 %6, i64* %arrayidx2, align 8
  br label %if.end.11

if.else:                                          ; preds = %cond.end
  %8 = load i64, i64* %halflen, align 8
  %cmp3 = icmp slt i64 1, %8
  br i1 %cmp3, label %if.then.4, label %if.end

if.then.4:                                        ; preds = %if.else
  %9 = load i64, i64* %pred.addr, align 8
  %10 = load i64, i64* %halflen, align 8
  %11 = load i64*, i64** %src.addr, align 8
  %12 = load i64*, i64** %dest.addr, align 8
  call void @sort_vector_inplace(i64 %9, i64 %10, i64* %11, i64* %12)
  br label %if.end

if.end:                                           ; preds = %if.then.4, %if.else
  %13 = load i64, i64* %len.addr, align 8
  %14 = load i64, i64* %halflen, align 8
  %sub = sub nsw i64 %13, %14
  %cmp5 = icmp slt i64 1, %sub
  br i1 %cmp5, label %if.then.6, label %if.end.8

if.then.6:                                        ; preds = %if.end
  %15 = load i64, i64* %pred.addr, align 8
  %16 = load i64, i64* %len.addr, align 8
  %17 = load i64, i64* %halflen, align 8
  %sub7 = sub nsw i64 %16, %17
  %18 = load i64*, i64** %src.addr, align 8
  %19 = load i64, i64* %halflen, align 8
  %add.ptr = getelementptr inbounds i64, i64* %18, i64 %19
  %20 = load i64*, i64** %dest.addr, align 8
  call void @sort_vector_inplace(i64 %15, i64 %sub7, i64* %add.ptr, i64* %20)
  br label %if.end.8

if.end.8:                                         ; preds = %if.then.6, %if.end
  %21 = load i64, i64* %pred.addr, align 8
  %22 = load i64, i64* %halflen, align 8
  %23 = load i64*, i64** %src.addr, align 8
  %24 = load i64, i64* %len.addr, align 8
  %25 = load i64, i64* %halflen, align 8
  %sub9 = sub nsw i64 %24, %25
  %26 = load i64*, i64** %src.addr, align 8
  %27 = load i64, i64* %halflen, align 8
  %add.ptr10 = getelementptr inbounds i64, i64* %26, i64 %27
  %28 = load i64*, i64** %dest.addr, align 8
  call void @merge_vectors(i64 %21, i64 %22, i64* %23, i64 %sub9, i64* %add.ptr10, i64* %28)
  br label %if.end.11

if.end.11:                                        ; preds = %if.end.8, %if.then
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @merge_vectors(i64 %pred, i64 %alen, i64* noalias nonnull %a, i64 %blen, i64* nonnull %b, i64* nonnull %dest) #1 {
entry:
  %pred.addr = alloca i64, align 8
  %alen.addr = alloca i64, align 8
  %a.addr = alloca i64*, align 8
  %blen.addr = alloca i64, align 8
  %b.addr = alloca i64*, align 8
  %dest.addr = alloca i64*, align 8
  %alim = alloca i64*, align 8
  %blim = alloca i64*, align 8
  store i64 %pred, i64* %pred.addr, align 8
  store i64 %alen, i64* %alen.addr, align 8
  store i64* %a, i64** %a.addr, align 8
  store i64 %blen, i64* %blen.addr, align 8
  store i64* %b, i64** %b.addr, align 8
  store i64* %dest, i64** %dest.addr, align 8
  %0 = load i64, i64* %alen.addr, align 8
  %1 = load i64, i64* %blen.addr, align 8
  %2 = load i64, i64* %alen.addr, align 8
  %3 = load i64, i64* %blen.addr, align 8
  %add = add nsw i64 %2, %3
  %4 = load i64, i64* %alen.addr, align 8
  %cmp = icmp slt i64 0, %4
  br i1 %cmp, label %land.lhs.true, label %cond.false

land.lhs.true:                                    ; preds = %entry
  %5 = load i64, i64* %blen.addr, align 8
  %cmp1 = icmp slt i64 0, %5
  br i1 %cmp1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true
  br label %cond.end

cond.false:                                       ; preds = %land.lhs.true, %entry
  unreachable

unreachable.cont:                                 ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %unreachable.cont, %cond.true
  %6 = load i64*, i64** %a.addr, align 8
  %7 = load i64, i64* %alen.addr, align 8
  %add.ptr = getelementptr inbounds i64, i64* %6, i64 %7
  store i64* %add.ptr, i64** %alim, align 8
  %8 = load i64*, i64** %b.addr, align 8
  %9 = load i64, i64* %blen.addr, align 8
  %add.ptr2 = getelementptr inbounds i64, i64* %8, i64 %9
  store i64* %add.ptr2, i64** %blim, align 8
  br label %while.body

while.body:                                       ; preds = %cond.end, %if.end.20
  %10 = load i64, i64* %pred.addr, align 8
  %11 = load i64*, i64** %a.addr, align 8
  %arrayidx = getelementptr inbounds i64, i64* %11, i64 0
  %12 = load i64, i64* %arrayidx, align 8
  %13 = load i64*, i64** %b.addr, align 8
  %arrayidx3 = getelementptr inbounds i64, i64* %13, i64 0
  %14 = load i64, i64* %arrayidx3, align 8
  %call = call zeroext i1 @inorder(i64 %10, i64 %12, i64 %14)
  br i1 %call, label %if.then, label %if.else

if.then:                                          ; preds = %while.body
  %15 = load i64*, i64** %a.addr, align 8
  %incdec.ptr = getelementptr inbounds i64, i64* %15, i32 1
  store i64* %incdec.ptr, i64** %a.addr, align 8
  %16 = load i64, i64* %15, align 8
  %17 = load i64*, i64** %dest.addr, align 8
  %incdec.ptr4 = getelementptr inbounds i64, i64* %17, i32 1
  store i64* %incdec.ptr4, i64** %dest.addr, align 8
  store i64 %16, i64* %17, align 8
  %18 = load i64*, i64** %a.addr, align 8
  %19 = load i64*, i64** %alim, align 8
  %cmp5 = icmp eq i64* %18, %19
  br i1 %cmp5, label %if.then.6, label %if.end.9

if.then.6:                                        ; preds = %if.then
  %20 = load i64*, i64** %dest.addr, align 8
  %21 = load i64*, i64** %b.addr, align 8
  %cmp7 = icmp ne i64* %20, %21
  br i1 %cmp7, label %if.then.8, label %if.end

if.then.8:                                        ; preds = %if.then.6
  %22 = load i64*, i64** %dest.addr, align 8
  %23 = bitcast i64* %22 to i8*
  %24 = load i64*, i64** %b.addr, align 8
  %25 = bitcast i64* %24 to i8*
  %26 = load i64*, i64** %blim, align 8
  %27 = load i64*, i64** %b.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint i64* %26 to i64
  %sub.ptr.rhs.cast = ptrtoint i64* %27 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %sub.ptr.div = sdiv exact i64 %sub.ptr.sub, 8
  %mul = mul i64 %sub.ptr.div, 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %23, i8* %25, i64 %mul, i32 8, i1 false)
  br label %if.end

if.end:                                           ; preds = %if.then.8, %if.then.6
  br label %return

if.end.9:                                         ; preds = %if.then
  br label %if.end.20

if.else:                                          ; preds = %while.body
  %28 = load i64*, i64** %b.addr, align 8
  %incdec.ptr10 = getelementptr inbounds i64, i64* %28, i32 1
  store i64* %incdec.ptr10, i64** %b.addr, align 8
  %29 = load i64, i64* %28, align 8
  %30 = load i64*, i64** %dest.addr, align 8
  %incdec.ptr11 = getelementptr inbounds i64, i64* %30, i32 1
  store i64* %incdec.ptr11, i64** %dest.addr, align 8
  store i64 %29, i64* %30, align 8
  %31 = load i64*, i64** %b.addr, align 8
  %32 = load i64*, i64** %blim, align 8
  %cmp12 = icmp eq i64* %31, %32
  br i1 %cmp12, label %if.then.13, label %if.end.19

if.then.13:                                       ; preds = %if.else
  %33 = load i64*, i64** %dest.addr, align 8
  %34 = bitcast i64* %33 to i8*
  %35 = load i64*, i64** %a.addr, align 8
  %36 = bitcast i64* %35 to i8*
  %37 = load i64*, i64** %alim, align 8
  %38 = load i64*, i64** %a.addr, align 8
  %sub.ptr.lhs.cast14 = ptrtoint i64* %37 to i64
  %sub.ptr.rhs.cast15 = ptrtoint i64* %38 to i64
  %sub.ptr.sub16 = sub i64 %sub.ptr.lhs.cast14, %sub.ptr.rhs.cast15
  %sub.ptr.div17 = sdiv exact i64 %sub.ptr.sub16, 8
  %mul18 = mul i64 %sub.ptr.div17, 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %34, i8* %36, i64 %mul18, i32 8, i1 false)
  br label %return

if.end.19:                                        ; preds = %if.else
  br label %if.end.20

if.end.20:                                        ; preds = %if.end.19, %if.end.9
  br label %while.body

return:                                           ; preds = %if.then.13, %if.end
  ret void
}

declare %struct.Lisp_Hash_Table* @XHASH_TABLE(i64) #2

declare double @extract_float(i64) #2

declare i32 @XMISCTYPE(i64) #2

declare zeroext i1 @OVERLAYP(i64) #2

declare %struct.Lisp_Overlay* @XOVERLAY(i64) #2

declare %struct.Lisp_Marker* @XMARKER(i64) #2

declare zeroext i1 @WINDOW_CONFIGURATIONP(i64) #2

declare zeroext i1 @compare_window_configurations(i64, i64, i1 zeroext) #2

declare zeroext i1 @compare_string_intervals(i64, i64) #2

declare %struct.Lisp_Vector* @allocate_pseudovector(i32, i32, i32, i32) #2

declare void @gc_aset(i64, i64, i64) #2

; Function Attrs: nounwind uwtable
define internal void @set_hash_key_and_value(%struct.Lisp_Hash_Table* %h, i64 %key_and_value) #1 {
entry:
  %h.addr = alloca %struct.Lisp_Hash_Table*, align 8
  %key_and_value.addr = alloca i64, align 8
  store %struct.Lisp_Hash_Table* %h, %struct.Lisp_Hash_Table** %h.addr, align 8
  store i64 %key_and_value, i64* %key_and_value.addr, align 8
  %0 = load i64, i64* %key_and_value.addr, align 8
  %1 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %key_and_value1 = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %1, i32 0, i32 9
  store i64 %0, i64* %key_and_value1, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @set_hash_next(%struct.Lisp_Hash_Table* %h, i64 %next) #1 {
entry:
  %h.addr = alloca %struct.Lisp_Hash_Table*, align 8
  %next.addr = alloca i64, align 8
  store %struct.Lisp_Hash_Table* %h, %struct.Lisp_Hash_Table** %h.addr, align 8
  store i64 %next, i64* %next.addr, align 8
  %0 = load i64, i64* %next.addr, align 8
  %1 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %next1 = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %1, i32 0, i32 5
  store i64 %0, i64* %next1, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @set_hash_hash(%struct.Lisp_Hash_Table* %h, i64 %hash) #1 {
entry:
  %h.addr = alloca %struct.Lisp_Hash_Table*, align 8
  %hash.addr = alloca i64, align 8
  store %struct.Lisp_Hash_Table* %h, %struct.Lisp_Hash_Table** %h.addr, align 8
  store i64 %hash, i64* %hash.addr, align 8
  %0 = load i64, i64* %hash.addr, align 8
  %1 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %hash1 = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %1, i32 0, i32 4
  store i64 %0, i64* %hash1, align 8
  ret void
}

; Function Attrs: nounwind uwtable
define internal void @set_hash_index(%struct.Lisp_Hash_Table* %h, i64 %index) #1 {
entry:
  %h.addr = alloca %struct.Lisp_Hash_Table*, align 8
  %index.addr = alloca i64, align 8
  store %struct.Lisp_Hash_Table* %h, %struct.Lisp_Hash_Table** %h.addr, align 8
  store i64 %index, i64* %index.addr, align 8
  %0 = load i64, i64* %index.addr, align 8
  %1 = load %struct.Lisp_Hash_Table*, %struct.Lisp_Hash_Table** %h.addr, align 8
  %index1 = getelementptr inbounds %struct.Lisp_Hash_Table, %struct.Lisp_Hash_Table* %1, i32 0, i32 7
  store i64 %0, i64* %index1, align 8
  ret void
}

declare i64 @gc_asize(i64) #2

declare zeroext i1 @survives_gc_p(i64) #2

declare void @mark_object(i64) #2

declare i64 @SXHASH_REDUCE(i64) #2

declare i64 @bool_vector_words(i64) #2

; Function Attrs: nounwind uwtable
define internal void @CHECK_HASH_TABLE(i64 %x) #1 {
entry:
  %x.addr = alloca i64, align 8
  store i64 %x, i64* %x.addr, align 8
  %0 = load i64, i64* %x.addr, align 8
  %call = call zeroext i1 @HASH_TABLE_P(i64 %0)
  br i1 %call, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %call1 = call i64 @builtin_lisp_symbol(i32 510)
  %1 = load i64, i64* %x.addr, align 8
  %2 = call i64 @wrong_type_argument(i64 %call1, i64 %1) #8
  unreachable
                                                  ; No predecessors!
  br label %cond.end

cond.end:                                         ; preds = %3, %cond.true
  ret void
}

declare i64 @preferred_coding_system() #2

declare i64 @Fcoding_system_p(i64) #2

declare i64 @code_convert_string(i64, i64, i64, i1 zeroext, i1 zeroext, i1 zeroext) #2

declare void @record_unwind_current_buffer() #2

declare void @CHECK_BUFFER(i64) #2

declare %struct.buffer* @XBUFFER(i64) #2

declare void @set_buffer_internal(%struct.buffer*) #2

declare i64 @marker_position(i64) #2

; Function Attrs: noreturn
declare void @args_out_of_range(i64, i64) #3

declare i64 @Flocal_variable_p(i64, i64) #2

declare i64 @Fbuffer_file_name(i64) #2

declare i64 @Ffind_operation_coding_system(i64, i64*) #2

declare i64 @Ffboundp(i64) #2

declare i64 @call4(i64, i64, i64, i64, i64) #2

declare i64 @make_buffer_string(i64, i64, i1 zeroext) #2

; Function Attrs: nounwind
declare i8* @md5_buffer(i8*, i64, i8*) #6

declare i8* @sha1_buffer(i8*, i64, i8*) #2

declare i8* @sha224_buffer(i8*, i64, i8*) #2

declare i8* @sha256_buffer(i8*, i64, i8*) #2

declare i8* @sha384_buffer(i8*, i64, i8*) #2

declare i8* @sha512_buffer(i8*, i64, i8*) #2

attributes #0 = { nounwind readnone uwtable "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind uwtable "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { noreturn "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind readonly "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { nounwind }
attributes #6 = { nounwind "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #7 = { noinline nounwind uwtable "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+sse,+sse2" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #8 = { noreturn }
attributes #9 = { nounwind readonly }
attributes #10 = { nounwind readnone }

!llvm.ident = !{!0}

!0 = !{!"clang version 3.7.0 (tags/RELEASE_370/final)"}
